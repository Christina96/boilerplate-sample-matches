
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.149606299212598%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "colpartition.h"
5  #include "colpartitiongrid.h"
6  #include "colpartitionset.h"
7  #include "detlinefit.h"
8  #include "dppoint.h"
9  #include "helpers.h" 
10  #include "host.h"    
11  #include "imagefind.h"
12  #include "workingpartset.h"
13  #include <algorithm>
14  namespace tesseract {
15  enum SpacingNeighbourhood {
16    PN_ABOVE2,
17    PN_ABOVE1,
18    PN_UPPER,
19    PN_LOWER,
20    PN_BELOW1,
21    PN_BELOW2,
22    PN_COUNT
23  };
24  const double kMaxSpacingDrift = 1.0 / 72; 
25  const double kMaxTopSpacingFraction = 0.25;
26  const double kMaxSameBlockLineSpacing = 3;
27  const double kMaxSizeRatio = 1.5;
28  const double kMaxLeaderGapFractionOfMax = 0.25;
29  const double kMaxLeaderGapFractionOfMin = 0.5;
30  const int kMinLeaderCount = 5;
31  const int kMinStrongTextValue = 6;
32  const int kMinChainTextValue = 3;
33  const int kHorzStrongTextlineCount = 8;
34  const int kHorzStrongTextlineHeight = 10;
35  const int kHorzStrongTextlineAspect = 5;
36  const double kMaxBaselineError = 0.4375;
37  const double kMinBaselineCoverage = 0.5;
38  const int kMaxRMSColorNoise = 128;
39  const int kMaxColorDistance = 900;
40  ColPartition::ColPartition(BlobRegionType blob_type, const ICOORD &vertical)
41      : left_margin_(-INT32_MAX),
42        right_margin_(INT32_MAX),
43        median_bottom_(INT32_MAX),
44        median_top_(-INT32_MAX),
45        median_left_(INT32_MAX),
46        median_right_(-INT32_MAX),
47        blob_type_(blob_type),
48        vertical_(vertical) {
49    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
50  }
51  ColPartition *ColPartition::FakePartition(const TBOX &box,
52                                            PolyBlockType block_type,
53                                            BlobRegionType blob_type,
54                                            BlobTextFlowType flow) {
55    auto *part = new ColPartition(blob_type, ICOORD(0, 1));
56    part->set_type(block_type);
57    part->set_flow(flow);
58    part->AddBox(new BLOBNBOX(C_BLOB::FakeBlob(box)));
59    part->set_left_margin(box.left());
60    part->set_right_margin(box.right());
61    part->SetBlobTypes();
62    part->ComputeLimits();
63    part->ClaimBoxes();
64    return part;
65  }
66  ColPartition *ColPartition::MakeBigPartition(BLOBNBOX *box,
67                                               ColPartition_LIST *big_part_list) {
68    box->set_owner(nullptr);
69    auto *single = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
70    single->set_flow(BTFT_NONE);
71    single->AddBox(box);
72    single->ComputeLimits();
73    single->ClaimBoxes();
74    single->SetBlobTypes();
75    single->set_block_owned(true);
76    if (big_part_list != nullptr) {
77      ColPartition_IT part_it(big_part_list);
78      part_it.add_to_end(single);
79    }
80    return single;
81  }
82  ColPartition::~ColPartition() {
83    ColPartition_C_IT it(&upper_partners_);
84    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
85      it.data()->RemovePartner(false, this);
86    }
87    it.set_to_list(&lower_partners_);
88    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
89      it.data()->RemovePartner(true, this);
90    }
91  }
92  ColPartition *ColPartition::MakeLinePartition(BlobRegionType blob_type,
93                                                const ICOORD &vertical, int left,
94                                                int bottom, int right, int top) {
95    auto *part = new ColPartition(blob_type, vertical);
96    part->bounding_box_ = TBOX(left, bottom, right, top);
97    part->median_bottom_ = bottom;
98    part->median_top_ = top;
99    part->median_height_ = top - bottom;
100    part->median_left_ = left;
101    part->median_right_ = right;
102    part->median_width_ = right - left;
103    part->left_key_ = part->BoxLeftKey();
104    part->right_key_ = part->BoxRightKey();
105    return part;
106  }
107  void ColPartition::AddBox(BLOBNBOX *bbox) {
108    TBOX box = bbox->bounding_box();
109    if (boxes_.empty()) {
110      bounding_box_ = box;
111    } else {
112      bounding_box_ += box;
113    }
114    if (IsVerticalType()) {
115      if (!last_add_was_vertical_) {
116        boxes_.sort(SortByBoxBottom<BLOBNBOX>);
117        last_add_was_vertical_ = true;
118      }
119      boxes_.add_sorted(SortByBoxBottom<BLOBNBOX>, true, bbox);
120    } else {
121      if (last_add_was_vertical_) {
122        boxes_.sort(SortByBoxLeft<BLOBNBOX>);
123        last_add_was_vertical_ = false;
124      }
125      boxes_.add_sorted(SortByBoxLeft<BLOBNBOX>, true, bbox);
126    }
127    if (!left_key_tab_) {
128      left_key_ = BoxLeftKey();
129    }
130    if (!right_key_tab_) {
131      right_key_ = BoxRightKey();
132    }
133    if (TabFind::WithinTestRegion(2, box.left(), box.bottom())) {
134      tprintf("Added box (%d,%d)->(%d,%d) left_blob_x_=%d, right_blob_x_ = %d\n",
135              box.left(), box.bottom(), box.right(), box.top(),
136              bounding_box_.left(), bounding_box_.right());
137    }
138  }
139  void ColPartition::RemoveBox(BLOBNBOX *box) {
140    BLOBNBOX_C_IT bb_it(&boxes_);
141    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
142      if (box == bb_it.data()) {
143        bb_it.extract();
144        ComputeLimits();
145        return;
146      }
147    }
148  }
149  BLOBNBOX *ColPartition::BiggestBox() {
150    BLOBNBOX *biggest = nullptr;
151    BLOBNBOX_C_IT bb_it(&boxes_);
152    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
153      BLOBNBOX *bbox = bb_it.data();
154      if (IsVerticalType()) {
155        if (biggest == nullptr ||
156            bbox->bounding_box().width() > biggest->bounding_box().width()) {
157          biggest = bbox;
158        }
159      } else {
160        if (biggest == nullptr ||
161            bbox->bounding_box().height() > biggest->bounding_box().height()) {
162          biggest = bbox;
163        }
164      }
165    }
166    return biggest;
167  }
168  TBOX ColPartition::BoundsWithoutBox(BLOBNBOX *box) {
169    TBOX result;
170    BLOBNBOX_C_IT bb_it(&boxes_);
171    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
172      if (box != bb_it.data()) {
173        result += bb_it.data()->bounding_box();
174      }
175    }
176    return result;
177  }
178  void ColPartition::ClaimBoxes() {
179    BLOBNBOX_C_IT bb_it(&boxes_);
180    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
181      BLOBNBOX *bblob = bb_it.data();
182      ColPartition *other = bblob->owner();
183      if (other == nullptr) {
184        bblob->set_owner(this);
185      } else {
186        ASSERT_HOST(other == this);
187      }
188    }
189  }
190  void ColPartition::DisownBoxes() {
191    BLOBNBOX_C_IT bb_it(&boxes_);
192    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
193      BLOBNBOX *bblob = bb_it.data();
194      ASSERT_HOST(bblob->owner() == this || bblob->owner() == nullptr);
195      bblob->set_owner(nullptr);
196    }
197  }
198  void ColPartition::DisownBoxesNoAssert() {
199    BLOBNBOX_C_IT bb_it(&boxes_);
200    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
201      BLOBNBOX *bblob = bb_it.data();
202      if (bblob->owner() == this) {
203        bblob->set_owner(nullptr);
204      }
205    }
206  }
207  bool ColPartition::ReleaseNonLeaderBoxes() {
208    BLOBNBOX_C_IT bb_it(&boxes_);
209    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
210      BLOBNBOX *bblob = bb_it.data();
211      if (bblob->flow() != BTFT_LEADER) {
212        if (bblob->owner() == this) {
213          bblob->set_owner(nullptr);
214        }
215        bb_it.extract();
216      }
217    }
218    if (bb_it.empty()) {
219      return false;
220    }
221    flow_ = BTFT_LEADER;
222    ComputeLimits();
223    return true;
224  }
225  void ColPartition::DeleteBoxes() {
226    for (BLOBNBOX_C_IT bb_it(&boxes_); !bb_it.empty(); bb_it.forward()) {
227      BLOBNBOX *bblob = bb_it.extract();
228      delete bblob->remove_cblob();
229      delete bblob;
230    }
231  }
232  void ColPartition::ReflectInYAxis() {
233    BLOBNBOX_CLIST reversed_boxes;
234    BLOBNBOX_C_IT reversed_it(&reversed_boxes);
235    BLOBNBOX_C_IT bb_it(&boxes_);
236    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
237      reversed_it.add_before_then_move(bb_it.extract());
238    }
239    bb_it.add_list_after(&reversed_boxes);
240    ASSERT_HOST(!left_key_tab_ && !right_key_tab_);
241    int tmp = left_margin_;
242    left_margin_ = -right_margin_;
243    right_margin_ = -tmp;
244    ComputeLimits();
245  }
246  bool ColPartition::IsLegal() {
247    if (bounding_box_.left() > bounding_box_.right()) {
248      if (textord_debug_bugs) {
249        tprintf("Bounding box invalid\n");
250        Print();
251      }
252      return false; 
253    }
254    if (left_margin_ > bounding_box_.left() ||
255        right_margin_ < bounding_box_.right()) {
256      if (textord_debug_bugs) {
257        tprintf("Margins invalid\n");
258        Print();
259      }
260      return false; 
261    }
262    if (left_key_ > BoxLeftKey() || right_key_ < BoxRightKey()) {
263      if (textord_debug_bugs) {
264        tprintf("Key inside box: %d v %d or %d v %d\n", left_key_, BoxLeftKey(),
265                right_key_, BoxRightKey());
266        Print();
267      }
268      return false; 
269    }
270    return true;
271  }
272  bool ColPartition::MatchingColumns(const ColPartition &other) const {
273    int y = (MidY() + other.MidY()) / 2;
274    if (!NearlyEqual(other.LeftAtY(y) / kColumnWidthFactor,
275                     LeftAtY(y) / kColumnWidthFactor, 1)) {
276      return false;
277    }
278    if (!NearlyEqual(other.RightAtY(y) / kColumnWidthFactor,
279                     RightAtY(y) / kColumnWidthFactor, 1)) {
280      return false;
281    }
282    return true;
283  }
284  bool ColPartition::MatchingTextColor(const ColPartition &other) const {
285    if (color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise &&
286        other.color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise) {
287      return false; 
288    }
289    double d_this1_o =
290        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color1_);
291    double d_this2_o =
292        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color2_);
293    double d_o1_this =
294        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color1_);
295    double d_o2_this =
296        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color2_);
297    return d_this1_o < kMaxColorDistance && d_this2_o < kMaxColorDistance &&
298           d_o1_this < kMaxColorDistance && d_o2_this < kMaxColorDistance;
299  }
300  bool ColPartition::MatchingSizes(const ColPartition &other) const {
301    if (blob_type_ == BRT_VERT_TEXT || other.blob_type_ == BRT_VERT_TEXT) {
302      return !TabFind::DifferentSizes(median_width_, other.median_width_);
303    } else {
304      return !TabFind::DifferentSizes(median_height_, other.median_height_);
305    }
306  }
307  bool ColPartition::ConfirmNoTabViolation(const ColPartition &other) const {
308    if (bounding_box_.right() < other.bounding_box_.left() &&
309        bounding_box_.right() < other.LeftBlobRule()) {
310      return false;
311    }
312    if (other.bounding_box_.right() < bounding_box_.left() &&
313        other.bounding_box_.right() < LeftBlobRule()) {
314      return false;
315    }
316    if (bounding_box_.left() > other.bounding_box_.right() &&
317        bounding_box_.left() > other.RightBlobRule()) {
318      return false;
319    }
320    if (other.bounding_box_.left() > bounding_box_.right() &&
321        other.bounding_box_.left() > RightBlobRule()) {
322      return false;
323    }
324    return true;
325  }
326  bool ColPartition::MatchingStrokeWidth(const ColPartition &other,
327                                         double fractional_tolerance,
328                                         double constant_tolerance) const {
329    int match_count = 0;
330    int nonmatch_count = 0;
331    BLOBNBOX_C_IT box_it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
332    BLOBNBOX_C_IT other_it(const_cast<BLOBNBOX_CLIST *>(&other.boxes_));
333    box_it.mark_cycle_pt();
334    other_it.mark_cycle_pt();
335    while (!box_it.cycled_list() && !other_it.cycled_list()) {
336      if (box_it.data()->MatchingStrokeWidth(
337              *other_it.data(), fractional_tolerance, constant_tolerance)) {
338        ++match_count;
339      } else {
340        ++nonmatch_count;
341      }
342      box_it.forward();
343      other_it.forward();
344    }
345    return match_count > nonmatch_count;
346  }
347  bool ColPartition::OKDiacriticMerge(const ColPartition &candidate,
348                                      bool debug) const {
349    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
350    int min_top = INT32_MAX;
351    int max_bottom = -INT32_MAX;
352    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
353      BLOBNBOX *blob = it.data();
354      if (!blob->IsDiacritic()) {
355        if (debug) {
356          tprintf("Blob is not a diacritic:");
357          blob->bounding_box().print();
358        }
359        return false; 
360      }
361      if (blob->base_char_top() < min_top) {
362        min_top = blob->base_char_top();
363      }
364      if (blob->base_char_bottom() > max_bottom) {
365        max_bottom = blob->base_char_bottom();
366      }
367    }
368    bool result =
369        min_top > candidate.median_bottom_ && max_bottom < candidate.median_top_;
370    if (debug) {
371      if (result) {
372        tprintf("OKDiacritic!\n");
373      } else {
374        tprintf("y ranges don\'t overlap: %d-%d / %d-%d\n", max_bottom, min_top,
375                median_bottom_, median_top_);
376      }
377    }
378    return result;
379  }
380  void ColPartition::SetLeftTab(const TabVector *tab_vector) {
381    if (tab_vector != nullptr) {
382      left_key_ = tab_vector->sort_key();
383      left_key_tab_ = left_key_ <= BoxLeftKey();
384    } else {
385      left_key_tab_ = false;
386    }
387    if (!left_key_tab_) {
388      left_key_ = BoxLeftKey();
389    }
390  }
391  void ColPartition::SetRightTab(const TabVector *tab_vector) {
392    if (tab_vector != nullptr) {
393      right_key_ = tab_vector->sort_key();
394      right_key_tab_ = right_key_ >= BoxRightKey();
395    } else {
396      right_key_tab_ = false;
397    }
398    if (!right_key_tab_) {
399      right_key_ = BoxRightKey();
400    }
401  }
402  void ColPartition::CopyLeftTab(const ColPartition &src, bool take_box) {
403    left_key_tab_ = take_box ? false : src.left_key_tab_;
404    if (left_key_tab_) {
405      left_key_ = src.left_key_;
406    } else {
407      bounding_box_.set_left(XAtY(src.BoxLeftKey(), MidY()));
408      left_key_ = BoxLeftKey();
409    }
410    if (left_margin_ > bounding_box_.left()) {
411      left_margin_ = src.left_margin_;
412    }
413  }
414  void ColPartition::CopyRightTab(const ColPartition &src, bool take_box) {
415    right_key_tab_ = take_box ? false : src.right_key_tab_;
416    if (right_key_tab_) {
417      right_key_ = src.right_key_;
418    } else {
419      bounding_box_.set_right(XAtY(src.BoxRightKey(), MidY()));
420      right_key_ = BoxRightKey();
421    }
422    if (right_margin_ < bounding_box_.right()) {
423      right_margin_ = src.right_margin_;
424    }
425  }
426  int ColPartition::LeftBlobRule() const {
427    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
428    return it.data()->left_rule();
429  }
430  int ColPartition::RightBlobRule() const {
431    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
432    it.move_to_last();
433    return it.data()->right_rule();
434  }
435  float ColPartition::SpecialBlobsDensity(const BlobSpecialTextType type) const {
436    ASSERT_HOST(type < BSTT_COUNT);
437    return special_blobs_densities_[type];
438  }
439  int ColPartition::SpecialBlobsCount(const BlobSpecialTextType type) {
440    ASSERT_HOST(type < BSTT_COUNT);
441    BLOBNBOX_C_IT blob_it(&boxes_);
442    int count = 0;
443    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
444      BLOBNBOX *blob = blob_it.data();
445      BlobSpecialTextType blob_type = blob->special_text_type();
446      if (blob_type == type) {
447        count++;
448      }
449    }
450    return count;
451  }
452  void ColPartition::SetSpecialBlobsDensity(const BlobSpecialTextType type,
453                                            const float density) {
454    ASSERT_HOST(type < BSTT_COUNT);
455    special_blobs_densities_[type] = density;
456  }
457  void ColPartition::ComputeSpecialBlobsDensity() {
458    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
459    if (boxes_.empty()) {
460      return;
461    }
462    BLOBNBOX_C_IT blob_it(&boxes_);
463    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
464      BLOBNBOX *blob = blob_it.data();
465      BlobSpecialTextType type = blob->special_text_type();
466      special_blobs_densities_[type]++;
467    }
468    for (float &special_blobs_density : special_blobs_densities_) {
469      special_blobs_density /= boxes_.length();
470    }
471  }
472  void ColPartition::AddPartner(bool upper, ColPartition *partner) {
473    if (upper) {
474      partner->lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
475                                          this);
476      upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
477    } else {
478      partner->upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
479                                          this);
480      lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
481    }
482  }
483  void ColPartition::RemovePartner(bool upper, ColPartition *partner) {
484    ColPartition_C_IT it(upper ? &upper_partners_ : &lower_partners_);
485    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
486      if (it.data() == partner) {
487        it.extract();
488        break;
489      }
490    }
491  }
492  ColPartition *ColPartition::SingletonPartner(bool upper) {
493    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
494    if (!partners->singleton()) {
495      return nullptr;
496    }
497    ColPartition_C_IT it(partners);
498    return it.data();
499  }
500  void ColPartition::Absorb(ColPartition *other, const WidthCallback &cb) {
501    ASSERT_HOST(owns_blobs() == other->owns_blobs());
502    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
503                                  bounding_box_.bottom()) ||
504        TabFind::WithinTestRegion(2, other->bounding_box_.left(),
505                                  other->bounding_box_.bottom())) {
506      tprintf("Merging:");
507      Print();
508      other->Print();
509    }
510    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
511    for (int type = 0; type < BSTT_COUNT; ++type) {
512      unsigned w1 = boxes_.length();
513      unsigned w2 = other->boxes_.length();
514      float new_val = special_blobs_densities_[type] * w1 +
515                      other->special_blobs_densities_[type] * w2;
516      if (!w1 || !w2) {
517        ASSERT_HOST((w1 + w2) > 0);
518        special_blobs_densities_[type] = new_val / (w1 + w2);
519      }
520    }
521    BLOBNBOX_C_IT it(&boxes_);
522    BLOBNBOX_C_IT it2(&other->boxes_);
523    for (; !it2.empty(); it2.forward()) {
524      BLOBNBOX *bbox2 = it2.extract();
525      ColPartition *prev_owner = bbox2->owner();
526      if (prev_owner != other && prev_owner != nullptr) {
527        continue;
528      }
529      ASSERT_HOST(prev_owner == other || prev_owner == nullptr);
530      if (prev_owner == other) {
531        bbox2->set_owner(this);
532      }
533      it.add_to_end(bbox2);
534    }
535    left_margin_ = std::min(left_margin_, other->left_margin_);
536    right_margin_ = std::max(right_margin_, other->right_margin_);
537    if (other->left_key_ < left_key_) {
538      left_key_ = other->left_key_;
539      left_key_tab_ = other->left_key_tab_;
540    }
541    if (other->right_key_ > right_key_) {
542      right_key_ = other->right_key_;
543      right_key_tab_ = other->right_key_tab_;
544    }
545    if (!DominatesInMerge(flow_, other->flow_)) {
546      flow_ = other->flow_;
547      blob_type_ = other->blob_type_;
548    }
549    SetBlobTypes();
550    if (IsVerticalType()) {
551      boxes_.sort(SortByBoxBottom<BLOBNBOX>);
552      last_add_was_vertical_ = true;
553    } else {
554      boxes_.sort(SortByBoxLeft<BLOBNBOX>);
555      last_add_was_vertical_ = false;
556    }
557    ComputeLimits();
558    for (int upper = 0; upper < 2; ++upper) {
559      ColPartition_CLIST partners;
560      ColPartition_C_IT part_it(&partners);
561      part_it.add_list_after(upper ? &other->upper_partners_
562                                   : &other->lower_partners_);
563      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
564        ColPartition *partner = part_it.extract();
565        partner->RemovePartner(!upper, other);
566        partner->RemovePartner(!upper, this);
567        partner->AddPartner(!upper, this);
568      }
569    }
570    delete other;
571    if (cb != nullptr) {
572      SetColumnGoodness(cb);
573    }
574  }
575  bool ColPartition::OKMergeOverlap(const ColPartition &merge1,
576                                    const ColPartition &merge2,
577                                    int ok_box_overlap, bool debug) {
578    if (IsVerticalType() || merge1.IsVerticalType() || merge2.IsVerticalType()) {
579      if (debug) {
580        tprintf("Vertical partition\n");
581      }
582      return false;
583    }
584    if (!merge1.VSignificantCoreOverlap(merge2)) {
585      if (debug) {
586        tprintf("Voverlap %d (%d)\n", merge1.VCoreOverlap(merge2),
587                merge1.VSignificantCoreOverlap(merge2));
588      }
589      return false;
590    }
591    TBOX merged_box(merge1.bounding_box());
592    merged_box += merge2.bounding_box();
593    if (merged_box.bottom() < median_top_ && merged_box.top() > median_bottom_ &&
594        merged_box.bottom() < bounding_box_.top() - ok_box_overlap &&
595        merged_box.top() > bounding_box_.bottom() + ok_box_overlap) {
596      if (debug) {
597        tprintf("Excessive box overlap\n");
598      }
599      return false;
600    }
601    return true;
602  }
603  BLOBNBOX *ColPartition::OverlapSplitBlob(const TBOX &box) {
604    if (boxes_.empty() || boxes_.singleton()) {
605      return nullptr;
606    }
607    BLOBNBOX_C_IT it(&boxes_);
608    TBOX left_box(it.data()->bounding_box());
609    for (it.forward(); !it.at_first(); it.forward()) {
610      BLOBNBOX *bbox = it.data();
611      left_box += bbox->bounding_box();
612      if (left_box.overlap(box)) {
613        return bbox;
614      }
615    }
616    return nullptr;
617  }
618  ColPartition *ColPartition::SplitAtBlob(BLOBNBOX *split_blob) {
619    ColPartition *split_part = ShallowCopy();
620    split_part->set_owns_blobs(owns_blobs());
621    BLOBNBOX_C_IT it(&boxes_);
622    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
623      BLOBNBOX *bbox = it.data();
624      ColPartition *prev_owner = bbox->owner();
625      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
626      if (bbox == split_blob || !split_part->boxes_.empty()) {
627        split_part->AddBox(it.extract());
628        if (owns_blobs() && prev_owner != nullptr) {
629          bbox->set_owner(split_part);
630        }
631      }
632    }
633    ASSERT_HOST(!it.empty());
634    if (split_part->IsEmpty()) {
635      delete split_part;
636      return nullptr;
637    }
638    right_key_tab_ = false;
639    split_part->left_key_tab_ = false;
640    ComputeLimits();
641    split_part->ComputeLimits();
642    return split_part;
643  }
644  ColPartition *ColPartition::SplitAt(int split_x) {
645    if (split_x <= bounding_box_.left() || split_x >= bounding_box_.right()) {
646      return nullptr; 
647    }
648    ColPartition *split_part = ShallowCopy();
649    split_part->set_owns_blobs(owns_blobs());
650    BLOBNBOX_C_IT it(&boxes_);
651    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
652      BLOBNBOX *bbox = it.data();
653      ColPartition *prev_owner = bbox->owner();
654      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
655      const TBOX &box = bbox->bounding_box();
656      if (box.left() >= split_x) {
657        split_part->AddBox(it.extract());
658        if (owns_blobs() && prev_owner != nullptr) {
659          bbox->set_owner(split_part);
660        }
661      }
662    }
663    if (it.empty()) {
664      it.add_list_after(&split_part->boxes_);
665    }
666    ASSERT_HOST(!it.empty());
667    if (split_part->IsEmpty()) {
668      delete split_part;
669      return nullptr;
670    }
671    right_key_tab_ = false;
672    split_part->left_key_tab_ = false;
673    right_margin_ = split_x;
674    split_part->left_margin_ = split_x;
675    ComputeLimits();
676    split_part->ComputeLimits();
677    return split_part;
678  }
679  void ColPartition::ComputeLimits() {
680    bounding_box_ = TBOX(); 
681    BLOBNBOX_C_IT it(&boxes_);
682    BLOBNBOX *bbox = nullptr;
683    int non_leader_count = 0;
684    if (it.empty()) {
685      bounding_box_.set_left(left_margin_);
686      bounding_box_.set_right(right_margin_);
687      bounding_box_.set_bottom(0);
688      bounding_box_.set_top(0);
689    } else {
690      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
691        bbox = it.data();
692        bounding_box_ += bbox->bounding_box();
693        if (bbox->flow() != BTFT_LEADER) {
694          ++non_leader_count;
695        }
696      }
697    }
698    if (!left_key_tab_) {
699      left_key_ = BoxLeftKey();
700    }
701    if (left_key_ > BoxLeftKey() && textord_debug_bugs) {
702      tprintf("Computed left-illegal partition\n");
703      Print();
704    }
705    if (!right_key_tab_) {
706      right_key_ = BoxRightKey();
707    }
708    if (right_key_ < BoxRightKey() && textord_debug_bugs) {
709      tprintf("Computed right-illegal partition\n");
710      Print();
711    }
712    if (it.empty()) {
713      return;
714    }
715    if (IsImageType() || blob_type() == BRT_RECTIMAGE ||
716        blob_type() == BRT_POLYIMAGE) {
717      median_top_ = bounding_box_.top();
718      median_bottom_ = bounding_box_.bottom();
719      median_height_ = bounding_box_.height();
720      median_left_ = bounding_box_.left();
721      median_right_ = bounding_box_.right();
722      median_width_ = bounding_box_.width();
723    } else {
724      STATS top_stats(bounding_box_.bottom(), bounding_box_.top());
725      STATS bottom_stats(bounding_box_.bottom(), bounding_box_.top());
726      STATS height_stats(0, bounding_box_.height());
727      STATS left_stats(bounding_box_.left(), bounding_box_.right());
728      STATS right_stats(bounding_box_.left(), bounding_box_.right());
729      STATS width_stats(0, bounding_box_.width());
730      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
731        bbox = it.data();
732        if (non_leader_count == 0 || bbox->flow() != BTFT_LEADER) {
733          const TBOX &box = bbox->bounding_box();
734          int area = box.area();
735          top_stats.add(box.top(), area);
736          bottom_stats.add(box.bottom(), area);
737          height_stats.add(box.height(), area);
738          left_stats.add(box.left(), area);
739          right_stats.add(box.right(), area);
740          width_stats.add(box.width(), area);
741        }
742      }
743      median_top_ = static_cast<int>(top_stats.median() + 0.5);
744      median_bottom_ = static_cast<int>(bottom_stats.median() + 0.5);
745      median_height_ = static_cast<int>(height_stats.median() + 0.5);
746      median_left_ = static_cast<int>(left_stats.median() + 0.5);
747      median_right_ = static_cast<int>(right_stats.median() + 0.5);
748      median_width_ = static_cast<int>(width_stats.median() + 0.5);
749    }
750    if (right_margin_ < bounding_box_.right() && textord_debug_bugs) {
751      tprintf("Made partition with bad right coords, %d < %d\n", right_margin_,
752              bounding_box_.right());
753      Print();
754    }
755    if (left_margin_ > bounding_box_.left() && textord_debug_bugs) {
756      tprintf("Made partition with bad left coords, %d > %d\n", left_margin_,
757              bounding_box_.left());
758      Print();
759    }
760    for (int upper = 0; upper < 2; ++upper) {
761      ColPartition_CLIST partners;
762      ColPartition_C_IT part_it(&partners);
763      part_it.add_list_after(upper ? &upper_partners_ : &lower_partners_);
764      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
765        ColPartition *partner = part_it.extract();
766        partner->RemovePartner(!upper, this);
767        partner->AddPartner(!upper, this);
768      }
769    }
770    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
771                                  bounding_box_.bottom())) {
772      tprintf("Recomputed box for partition %p\n", static_cast<void *>(this));
773      Print();
774    }
775  }
776  int ColPartition::CountOverlappingBoxes(const TBOX &box) {
777    BLOBNBOX_C_IT it(&boxes_);
778    int overlap_count = 0;
779    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
780      BLOBNBOX *bbox = it.data();
781      if (box.overlap(bbox->bounding_box())) {
782        ++overlap_count;
783      }
784    }
785    return overlap_count;
786  }
787  void ColPartition::SetPartitionType(int resolution, ColPartitionSet *columns) {
788    int first_spanned_col = -1;
789    ColumnSpanningType span_type = columns->SpanningType(
790        resolution, bounding_box_.left(), bounding_box_.right(),
791        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
792        left_margin_, right_margin_, &first_column_, &last_column_,
793        &first_spanned_col);
794    column_set_ = columns;
795    if (first_column_ < last_column_ && span_type == CST_PULLOUT &&
796        !IsLineType()) {
797      if (first_spanned_col >= 0) {
798        first_column_ = first_spanned_col;
799        last_column_ = first_spanned_col;
800      } else {
801        if ((first_column_ & 1) == 0) {
802          last_column_ = first_column_;
803        } else if ((last_column_ & 1) == 0) {
804          first_column_ = last_column_;
805        } else {
806          first_column_ = last_column_ = (first_column_ + last_column_) / 2;
807        }
808      }
809    }
810    type_ = PartitionType(span_type);
811  }
812  PolyBlockType ColPartition::PartitionType(ColumnSpanningType flow) const {
813    if (flow == CST_NOISE) {
814      if (blob_type_ != BRT_HLINE && blob_type_ != BRT_VLINE &&
815          blob_type_ != BRT_RECTIMAGE && blob_type_ != BRT_VERT_TEXT) {
816        return PT_NOISE;
817      }
818      flow = CST_FLOWING;
<span onclick='openModal()' class='match'>819    }
820    switch (blob_type_) {
821      case BRT_NOISE:
822        return PT_NOISE;
823      case BRT_HLINE:
824        return PT_HORZ_LINE;
825      case BRT_VLINE:
826        return PT_VERT_LINE;
827      case BRT_RECTIMAGE:
828      case BRT_POLYIMAGE:
</span>829        switch (flow) {
830          case CST_FLOWING:
831            return PT_FLOWING_IMAGE;
832          case CST_HEADING:
833            return PT_HEADING_IMAGE;
834          case CST_PULLOUT:
835            return PT_PULLOUT_IMAGE;
836          default:
837            ASSERT_HOST(!"Undefined flow type for image!");
838        }
839        break;
840      case BRT_VERT_TEXT:
841        return PT_VERTICAL_TEXT;
842      case BRT_TEXT:
843      case BRT_UNKNOWN:
844      default:
845        switch (flow) {
846          case CST_FLOWING:
847            return PT_FLOWING_TEXT;
848          case CST_HEADING:
849            return PT_HEADING_TEXT;
850          case CST_PULLOUT:
851            return PT_PULLOUT_TEXT;
852          default:
853            ASSERT_HOST(!"Undefined flow type for text!");
854        }
855    }
856    ASSERT_HOST(!"Should never get here!");
857    return PT_NOISE;
858  }
859  void ColPartition::ColumnRange(int resolution, ColPartitionSet *columns,
860                                 int *first_col, int *last_col) {
861    int first_spanned_col = -1;
862    ColumnSpanningType span_type = columns->SpanningType(
863        resolution, bounding_box_.left(), bounding_box_.right(),
864        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
865        left_margin_, right_margin_, first_col, last_col, &first_spanned_col);
866    type_ = PartitionType(span_type);
867  }
868  void ColPartition::SetColumnGoodness(const WidthCallback &cb) {
869    int y = MidY();
870    int width = RightAtY(y) - LeftAtY(y);
871    good_width_ = cb(width);
872    good_column_ = blob_type_ == BRT_TEXT && left_key_tab_ && right_key_tab_;
873  }
874  bool ColPartition::MarkAsLeaderIfMonospaced() {
875    bool result = false;
876    int part_width = bounding_box_.width();
877    STATS gap_stats(0, part_width - 1);
878    STATS width_stats(0, part_width - 1);
879    BLOBNBOX_C_IT it(&boxes_);
880    BLOBNBOX *prev_blob = it.data();
881    prev_blob->set_flow(BTFT_NEIGHBOURS);
882    width_stats.add(prev_blob->bounding_box().width(), 1);
883    int blob_count = 1;
884    for (it.forward(); !it.at_first(); it.forward()) {
885      BLOBNBOX *blob = it.data();
886      int left = blob->bounding_box().left();
887      int right = blob->bounding_box().right();
888      gap_stats.add(left - prev_blob->bounding_box().right(), 1);
889      width_stats.add(right - left, 1);
890      blob->set_flow(BTFT_NEIGHBOURS);
891      prev_blob = blob;
892      ++blob_count;
893    }
894    double median_gap = gap_stats.median();
895    double median_width = width_stats.median();
896    double max_width = std::max(median_gap, median_width);
897    double min_width = std::min(median_gap, median_width);
898    double gap_iqr = gap_stats.ile(0.75f) - gap_stats.ile(0.25f);
899    if (textord_debug_tabfind >= 4) {
900      tprintf("gap iqr = %g, blob_count=%d, limits=%g,%g\n", gap_iqr, blob_count,
901              max_width * kMaxLeaderGapFractionOfMax,
902              min_width * kMaxLeaderGapFractionOfMin);
903    }
904    if (gap_iqr < max_width * kMaxLeaderGapFractionOfMax &&
905        gap_iqr < min_width * kMaxLeaderGapFractionOfMin &&
906        blob_count >= kMinLeaderCount) {
907      int offset = static_cast<int>(ceil(gap_iqr * 2));
908      int min_step = static_cast<int>(median_gap + median_width + 0.5);
909      int max_step = min_step + offset;
910      min_step -= offset;
911      int part_left = bounding_box_.left() - min_step / 2;
912      part_width += min_step;
913      auto *projection = new DPPoint[part_width];
914      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
915        BLOBNBOX *blob = it.data();
916        int left = blob->bounding_box().left();
917        int right = blob->bounding_box().right();
918        int height = blob->bounding_box().height();
919        for (int x = left; x < right; ++x) {
920          projection[left - part_left].AddLocalCost(height);
921        }
922      }
923      DPPoint *best_end =
924          DPPoint::Solve(min_step, max_step, false, &DPPoint::CostWithVariance,
925                         part_width, projection);
926      if (best_end != nullptr && best_end->total_cost() < blob_count) {
927        result = true;
928        bool modified_blob_list = false;
929        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
930          BLOBNBOX *blob = it.data();
931          if (it.at_first()) {
932            int gap = it.data_relative(1)->bounding_box().left() -
933                      blob->bounding_box().right();
934            if (blob->bounding_box().width() + gap > max_step) {
935              it.extract();
936              modified_blob_list = true;
937              continue;
938            }
939          }
940          if (it.at_last()) {
941            int gap = blob->bounding_box().left() -
942                      it.data_relative(-1)->bounding_box().right();
943            if (blob->bounding_box().width() + gap > max_step) {
944              it.extract();
945              modified_blob_list = true;
946              break;
947            }
948          }
949          blob->set_region_type(BRT_TEXT);
950          blob->set_flow(BTFT_LEADER);
951        }
952        if (modified_blob_list) {
953          ComputeLimits();
954        }
955        blob_type_ = BRT_TEXT;
956        flow_ = BTFT_LEADER;
957      } else if (textord_debug_tabfind) {
958        if (best_end == nullptr) {
959          tprintf("No path\n");
960        } else {
961          tprintf("Total cost = %d vs allowed %d\n", best_end->total_cost(),
962                  blob_count);
963        }
964      }
965      delete[] projection;
966    }
967    return result;
968  }
969  void ColPartition::SetRegionAndFlowTypesFromProjectionValue(int value) {
970    int blob_count = 0;       
971    int good_blob_score_ = 0; 
972    int noisy_count = 0;      
973    int hline_count = 0;
974    int vline_count = 0;
975    BLOBNBOX_C_IT it(&boxes_);
976    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
977      BLOBNBOX *blob = it.data();
978      ++blob_count;
979      noisy_count += blob->NoisyNeighbours();
980      good_blob_score_ += blob->GoodTextBlob();
981      if (blob->region_type() == BRT_HLINE) {
982        ++hline_count;
983      }
984      if (blob->region_type() == BRT_VLINE) {
985        ++vline_count;
986      }
987    }
988    flow_ = BTFT_NEIGHBOURS;
989    blob_type_ = BRT_UNKNOWN;
990    if (hline_count > vline_count) {
991      flow_ = BTFT_NONE;
992      blob_type_ = BRT_HLINE;
993    } else if (vline_count > hline_count) {
994      flow_ = BTFT_NONE;
995      blob_type_ = BRT_VLINE;
996    } else if (value < -1 || 1 < value) {
997      int long_side;
998      int short_side;
999      if (value > 0) {
1000        long_side = bounding_box_.width();
1001        short_side = bounding_box_.height();
1002        blob_type_ = BRT_TEXT;
1003      } else {
1004        long_side = bounding_box_.height();
1005        short_side = bounding_box_.width();
1006        blob_type_ = BRT_VERT_TEXT;
1007      }
1008      int strong_score = blob_count >= kHorzStrongTextlineCount ? 1 : 0;
1009      if (short_side > kHorzStrongTextlineHeight) {
1010        ++strong_score;
1011      }
1012      if (short_side * kHorzStrongTextlineAspect < long_side) {
1013        ++strong_score;
1014      }
1015      if (abs(value) >= kMinStrongTextValue) {
1016        flow_ = BTFT_STRONG_CHAIN;
1017      } else if (abs(value) >= kMinChainTextValue) {
1018        flow_ = BTFT_CHAIN;
1019      } else {
1020        flow_ = BTFT_NEIGHBOURS;
1021      }
1022      if (flow_ == BTFT_CHAIN && strong_score == 3) {
1023        flow_ = BTFT_STRONG_CHAIN;
1024      }
1025      if (flow_ == BTFT_STRONG_CHAIN && value < 0 && strong_score < 2) {
1026        flow_ = BTFT_CHAIN;
1027      }
1028    }
1029    if (flow_ == BTFT_NEIGHBOURS) {
1030      if (noisy_count >= blob_count) {
1031        flow_ = BTFT_NONTEXT;
1032        blob_type_ = BRT_NOISE;
1033      }
1034    }
1035    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
1036                                  bounding_box_.bottom())) {
1037      tprintf("RegionFlowTypesFromProjectionValue count=%d, noisy=%d, score=%d,",
1038              blob_count, noisy_count, good_blob_score_);
1039      tprintf(" Projection value=%d, flow=%d, blob_type=%d\n", value, flow_,
1040              blob_type_);
1041      Print();
1042    }
1043    SetBlobTypes();
1044  }
1045  void ColPartition::SetBlobTypes() {
1046    if (!owns_blobs()) {
1047      return;
1048    }
1049    BLOBNBOX_C_IT it(&boxes_);
1050    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1051      BLOBNBOX *blob = it.data();
1052      if (blob->flow() != BTFT_LEADER) {
1053        blob->set_flow(flow_);
1054      }
1055      blob->set_region_type(blob_type_);
1056      ASSERT_HOST(blob->owner() == nullptr || blob->owner() == this);
1057    }
1058  }
1059  bool ColPartition::HasGoodBaseline() {
1060    DetLineFit linepoints;
1061    int total_height = 0;
1062    int coverage = 0;
1063    int height_count = 0;
1064    int width = 0;
1065    BLOBNBOX_C_IT it(&boxes_);
1066    TBOX box(it.data()->bounding_box());
1067    if (IsVerticalType()) {
1068      ICOORD first_pt(box.right(), box.bottom());
1069      linepoints.Add(first_pt);
1070      for (it.forward(); !it.at_last(); it.forward()) {
1071        BLOBNBOX *blob = it.data();
1072        box = blob->bounding_box();
1073        ICOORD box_pt(box.right(), (box.top() + box.bottom()) / 2);
1074        linepoints.Add(box_pt);
1075        total_height += box.width();
1076        coverage += box.height();
1077        ++height_count;
1078      }
1079      box = it.data()->bounding_box();
1080      ICOORD last_pt(box.right(), box.top());
1081      linepoints.Add(last_pt);
1082      width = last_pt.y() - first_pt.y();
1083    } else {
1084      TBOX box(it.data()->bounding_box());
1085      ICOORD first_pt(box.left(), box.bottom());
1086      linepoints.Add(first_pt);
1087      for (it.forward(); !it.at_last(); it.forward()) {
1088        BLOBNBOX *blob = it.data();
1089        box = blob->bounding_box();
1090        ICOORD box_pt((box.left() + box.right()) / 2, box.bottom());
1091        linepoints.Add(box_pt);
1092        total_height += box.height();
1093        coverage += box.width();
1094        ++height_count;
1095      }
1096      box = it.data()->bounding_box();
1097      ICOORD last_pt(box.right(), box.bottom());
1098      linepoints.Add(last_pt);
1099      width = last_pt.x() - first_pt.x();
1100    }
1101    if (height_count == 0) {
1102      return false;
1103    }
1104    double max_error = kMaxBaselineError * total_height / height_count;
1105    ICOORD start_pt, end_pt;
1106    double error = linepoints.Fit(&start_pt, &end_pt);
1107    return error < max_error && coverage >= kMinBaselineCoverage * width;
1108  }
1109  void ColPartition::AddToWorkingSet(const ICOORD &bleft, const ICOORD &tright,
1110                                     int resolution,
1111                                     ColPartition_LIST *used_parts,
1112                                     WorkingPartSet_LIST *working_sets) {
1113    if (block_owned_) {
1114      return; 
1115    }
1116    block_owned_ = true;
1117    WorkingPartSet_IT it(working_sets);
1118    ColPartition *partner = SingletonPartner(true);
1119    if (partner != nullptr && partner->working_set_ != nullptr) {
1120      working_set_ = partner->working_set_;
1121      working_set_->AddPartition(this);
1122      return;
1123    }
1124    if (partner != nullptr && textord_debug_bugs) {
1125      tprintf("Partition with partner has no working set!:");
1126      Print();
1127      partner->Print();
1128    }
1129    WorkingPartSet *work_set = nullptr;
1130    it.move_to_first();
1131    int col_index = 0;
1132    for (it.mark_cycle_pt(); !it.cycled_list() && col_index != first_column_;
1133         it.forward(), ++col_index) {
1134      ;
1135    }
1136    if (textord_debug_tabfind >= 2) {
1137      tprintf("Match is %s for:", (col_index & 1) ? "Real" : "Between");
1138      Print();
1139    }
1140    if (it.cycled_list() && textord_debug_bugs) {
1141      tprintf("Target column=%d, only had %d\n", first_column_, col_index);
1142    }
1143    ASSERT_HOST(!it.cycled_list());
1144    work_set = it.data();
1145    if (!it.cycled_list() && last_column_ != first_column_ && !IsPulloutType()) {
1146      BLOCK_LIST completed_blocks;
1147      TO_BLOCK_LIST to_blocks;
1148      for (; !it.cycled_list() && col_index <= last_column_;
1149           it.forward(), ++col_index) {
1150        WorkingPartSet *end_set = it.data();
1151        end_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
1152                                        &completed_blocks, &to_blocks);
1153      }
1154      work_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
1155    }
1156    working_set_ = work_set;
1157    work_set->AddPartition(this);
1158  }
1159  void ColPartition::LineSpacingBlocks(const ICOORD &bleft, const ICOORD &tright,
1160                                       int resolution,
1161                                       ColPartition_LIST *block_parts,
1162                                       ColPartition_LIST *used_parts,
1163                                       BLOCK_LIST *completed_blocks,
1164                                       TO_BLOCK_LIST *to_blocks) {
1165    int page_height = tright.y() - bleft.y();
1166    ColPartition_IT it(block_parts);
1167    int part_count = 0;
1168    int max_line_height = 0;
1169    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1170      ColPartition *part = it.data();
1171      ASSERT_HOST(!part->boxes()->empty());
1172      STATS side_steps(0, part->bounding_box().height() - 1);
1173      if (part->bounding_box().height() > max_line_height) {
1174        max_line_height = part->bounding_box().height();
1175      }
1176      BLOBNBOX_C_IT blob_it(part->boxes());
1177      int prev_bottom = blob_it.data()->bounding_box().bottom();
1178      for (blob_it.forward(); !blob_it.at_first(); blob_it.forward()) {
1179        BLOBNBOX *blob = blob_it.data();
1180        int bottom = blob->bounding_box().bottom();
1181        int step = bottom - prev_bottom;
1182        if (step < 0) {
1183          step = -step;
1184        }
1185        side_steps.add(step, 1);
1186        prev_bottom = bottom;
1187      }
1188      part->set_side_step(static_cast<int>(side_steps.median() + 0.5));
1189      if (!it.at_last()) {
1190        ColPartition *next_part = it.data_relative(1);
1191        part->set_bottom_spacing(part->median_bottom() -
1192                                 next_part->median_bottom());
1193        part->set_top_spacing(part->median_top() - next_part->median_top());
1194      } else {
1195        part->set_bottom_spacing(page_height);
1196        part->set_top_spacing(page_height);
1197      }
1198      if (textord_debug_tabfind) {
1199        part->Print();
1200        tprintf("side step = %.2f, top spacing = %d, bottom spacing=%d\n",
1201                side_steps.median(), part->top_spacing(), part->bottom_spacing());
1202      }
1203      ++part_count;
1204    }
1205    if (part_count == 0) {
1206      return;
1207    }
1208    SmoothSpacings(resolution, page_height, block_parts);
1209    BLOCK_IT block_it(completed_blocks);
1210    TO_BLOCK_IT to_block_it(to_blocks);
1211    ColPartition_LIST spacing_parts;
1212    ColPartition_IT sp_block_it(&spacing_parts);
1213    int same_block_threshold = max_line_height * kMaxSameBlockLineSpacing;
1214    for (it.mark_cycle_pt(); !it.empty();) {
1215      ColPartition *part = it.extract();
1216      sp_block_it.add_to_end(part);
1217      it.forward();
1218      if (it.empty() || part->bottom_spacing() > same_block_threshold ||
1219          !part->SpacingsEqual(*it.data(), resolution)) {
1220        if (!it.empty() && part->bottom_spacing() <= same_block_threshold) {
1221          ColPartition *next_part = it.data();
1222          ColPartition *third_part = it.at_last() ? nullptr : it.data_relative(1);
1223          if (textord_debug_tabfind) {
1224            tprintf(
1225                "Spacings unequal: upper:%d/%d, lower:%d/%d,"
1226                " sizes %d %d %d\n",
1227                part->top_spacing(), part->bottom_spacing(),
1228                next_part->top_spacing(), next_part->bottom_spacing(),
1229                part->median_height(), next_part->median_height(),
1230                third_part != nullptr ? third_part->median_height() : 0);
1231          }
1232          if (part->SizesSimilar(*next_part) &&
1233              next_part->median_height() * kMaxSameBlockLineSpacing >
1234                  part->bottom_spacing() &&
1235              part->median_height() * kMaxSameBlockLineSpacing >
1236                  part->top_spacing()) {
1237            if (third_part == nullptr || !next_part->SizesSimilar(*third_part) ||
1238                third_part->median_height() * kMaxSameBlockLineSpacing <=
1239                    next_part->bottom_spacing() ||
1240                next_part->median_height() * kMaxSameBlockLineSpacing <=
1241                    next_part->top_spacing() ||
1242                next_part->bottom_spacing() > part->bottom_spacing()) {
1243              sp_block_it.add_to_end(it.extract());
1244              it.forward();
1245              if (textord_debug_tabfind) {
1246                tprintf("Added line to current block.\n");
1247              }
1248            }
1249          }
1250        }
1251        TO_BLOCK *to_block = MakeBlock(bleft, tright, &spacing_parts, used_parts);
1252        if (to_block != nullptr) {
1253          to_block_it.add_to_end(to_block);
1254          block_it.add_to_end(to_block->block);
1255        }
1256        sp_block_it.set_to_list(&spacing_parts);
1257      } else {
1258        if (textord_debug_tabfind && !it.empty()) {
1259          ColPartition *next_part = it.data();
1260          tprintf("Spacings equal: upper:%d/%d, lower:%d/%d, median:%d/%d\n",
1261                  part->top_spacing(), part->bottom_spacing(),
1262                  next_part->top_spacing(), next_part->bottom_spacing(),
1263                  part->median_height(), next_part->median_height());
1264        }
1265      }
1266    }
1267  }
1268  static void ClipCoord(const ICOORD &bleft, const ICOORD &tright, ICOORD *pos) {
1269    if (pos->x() < bleft.x()) {
1270      pos->set_x(bleft.x());
1271    }
1272    if (pos->x() > tright.x()) {
1273      pos->set_x(tright.x());
1274    }
1275    if (pos->y() < bleft.y()) {
1276      pos->set_y(bleft.y());
1277    }
1278    if (pos->y() > tright.y()) {
1279      pos->set_y(tright.y());
1280    }
1281  }
1282  static TO_BLOCK *MoveBlobsToBlock(bool vertical_text, int line_spacing,
1283                                    BLOCK *block, ColPartition_LIST *block_parts,
1284                                    ColPartition_LIST *used_parts) {
1285    TBOX block_box(block->pdblk.bounding_box());
1286    STATS sizes(0, std::max(block_box.width(), block_box.height()) - 1);
1287    bool text_type = block->pdblk.poly_block()->IsText();
1288    ColPartition_IT it(block_parts);
1289    auto *to_block = new TO_BLOCK(block);
1290    BLOBNBOX_IT blob_it(&to_block->blobs);
1291    ColPartition_IT used_it(used_parts);
1292    for (it.move_to_first(); !it.empty(); it.forward()) {
1293      ColPartition *part = it.extract();
1294      for (BLOBNBOX_C_IT bb_it(part->boxes()); !bb_it.empty(); bb_it.forward()) {
1295        BLOBNBOX *bblob = bb_it.extract();
1296        if (bblob->owner() != part) {
1297          tprintf("Ownership incorrect for blob:");
1298          bblob->bounding_box().print();
1299          tprintf("Part=");
1300          part->Print();
1301          if (bblob->owner() == nullptr) {
1302            tprintf("Not owned\n");
1303          } else {
1304            tprintf("Owner part:");
1305            bblob->owner()->Print();
1306          }
1307        }
1308        ASSERT_HOST(bblob->owner() == part);
1309        ASSERT_HOST(!text_type || bblob->region_type() >= BRT_UNKNOWN);
1310        C_OUTLINE_LIST *outlines = bblob->cblob()->out_list();
1311        C_OUTLINE_IT ol_it(outlines);
1312        ASSERT_HOST(!text_type || ol_it.data()->pathlength() > 0);
1313        if (vertical_text) {
1314          sizes.add(bblob->bounding_box().width(), 1);
1315        } else {
1316          sizes.add(bblob->bounding_box().height(), 1);
1317        }
1318        blob_it.add_after_then_move(bblob);
1319      }
1320      used_it.add_to_end(part);
1321    }
1322    if (text_type && blob_it.empty()) {
1323      delete block;
1324      delete to_block;
1325      return nullptr;
1326    }
1327    to_block->line_size = sizes.median();
1328    if (vertical_text) {
1329      int block_width = block->pdblk.bounding_box().width();
1330      if (block_width < line_spacing) {
1331        line_spacing = block_width;
1332      }
1333      to_block->line_spacing = static_cast<float>(line_spacing);
1334      to_block->max_blob_size = static_cast<float>(block_width + 1);
1335    } else {
1336      int block_height = block->pdblk.bounding_box().height();
1337      if (block_height < line_spacing) {
1338        line_spacing = block_height;
1339      }
1340      to_block->line_spacing = static_cast<float>(line_spacing);
1341      to_block->max_blob_size = static_cast<float>(block_height + 1);
1342    }
1343    return to_block;
1344  }
1345  TO_BLOCK *ColPartition::MakeBlock(const ICOORD &bleft, const ICOORD &tright,
1346                                    ColPartition_LIST *block_parts,
1347                                    ColPartition_LIST *used_parts) {
1348    if (block_parts->empty()) {
1349      return nullptr; 
1350    }
1351    block_parts->sort(&ColPartition::SortByBBox);
1352    ColPartition_IT it(block_parts);
1353    ColPartition *part = it.data();
1354    PolyBlockType type = part->type();
1355    if (type == PT_VERTICAL_TEXT) {
1356      return MakeVerticalTextBlock(bleft, tright, block_parts, used_parts);
1357    }
1358    int line_spacing = part->bottom_spacing();
1359    if (line_spacing < part->median_height()) {
1360      line_spacing = part->bounding_box().height();
1361    }
1362    ICOORDELT_LIST vertices;
1363    ICOORDELT_IT vert_it(&vertices);
1364    ICOORD start, end;
1365    int min_x = INT32_MAX;
1366    int max_x = -INT32_MAX;
1367    int min_y = INT32_MAX;
1368    int max_y = -INT32_MAX;
1369    int iteration = 0;
1370    do {
1371      if (iteration == 0) {
1372        ColPartition::LeftEdgeRun(&it, &start, &end);
1373      } else {
1374        ColPartition::RightEdgeRun(&it, &start, &end);
1375      }
1376      ClipCoord(bleft, tright, &start);
1377      ClipCoord(bleft, tright, &end);
1378      vert_it.add_after_then_move(new ICOORDELT(start));
1379      vert_it.add_after_then_move(new ICOORDELT(end));
1380      UpdateRange(start.x(), &min_x, &max_x);
1381      UpdateRange(end.x(), &min_x, &max_x);
1382      UpdateRange(start.y(), &min_y, &max_y);
1383      UpdateRange(end.y(), &min_y, &max_y);
1384      if ((iteration == 0 && it.at_first()) || (iteration == 1 && it.at_last())) {
1385        ++iteration;
1386        it.move_to_last();
1387      }
1388    } while (iteration < 2);
1389    if (textord_debug_tabfind) {
1390      tprintf("Making block at (%d,%d)->(%d,%d)\n", min_x, min_y, max_x, max_y);
1391    }
1392    auto *block = new BLOCK("", true, 0, 0, min_x, min_y, max_x, max_y);
1393    block->pdblk.set_poly_block(new POLY_BLOCK(&vertices, type));
1394    return MoveBlobsToBlock(false, line_spacing, block, block_parts, used_parts);
1395  }
1396  TO_BLOCK *ColPartition::MakeVerticalTextBlock(const ICOORD &bleft,
1397                                                const ICOORD &tright,
1398                                                ColPartition_LIST *block_parts,
1399                                                ColPartition_LIST *used_parts) {
1400    if (block_parts->empty()) {
1401      return nullptr; 
1402    }
1403    ColPartition_IT it(block_parts);
1404    ColPartition *part = it.data();
1405    TBOX block_box = part->bounding_box();
1406    int line_spacing = block_box.width();
1407    PolyBlockType type = it.data()->type();
1408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1409      block_box += it.data()->bounding_box();
1410    }
1411    if (textord_debug_tabfind) {
1412      tprintf("Making block at:");
1413      block_box.print();
1414    }
1415    auto *block = new BLOCK("", true, 0, 0, block_box.left(), block_box.bottom(),
1416                            block_box.right(), block_box.top());
1417    block->pdblk.set_poly_block(new POLY_BLOCK(block_box, type));
1418    return MoveBlobsToBlock(true, line_spacing, block, block_parts, used_parts);
1419  }
1420  TO_ROW *ColPartition::MakeToRow() {
1421    BLOBNBOX_C_IT blob_it(&boxes_);
1422    TO_ROW *row = nullptr;
1423    int line_size = IsVerticalType() ? median_width_ : median_height_;
1424    for (; !blob_it.empty(); blob_it.forward()) {
1425      BLOBNBOX *blob = blob_it.extract();
1426      int top = blob->bounding_box().top();
1427      int bottom = blob->bounding_box().bottom();
1428      if (row == nullptr) {
1429        row =
1430            new TO_ROW(blob, static_cast<float>(top), static_cast<float>(bottom),
1431                       static_cast<float>(line_size));
1432      } else {
1433        row->add_blob(blob, static_cast<float>(top), static_cast<float>(bottom),
1434                      static_cast<float>(line_size));
1435      }
1436    }
1437    return row;
1438  }
1439  ColPartition *ColPartition::ShallowCopy() const {
1440    auto *part = new ColPartition(blob_type_, vertical_);
1441    part->left_margin_ = left_margin_;
1442    part->right_margin_ = right_margin_;
1443    part->bounding_box_ = bounding_box_;
1444    memcpy(part->special_blobs_densities_, special_blobs_densities_,
1445           sizeof(special_blobs_densities_));
1446    part->median_bottom_ = median_bottom_;
1447    part->median_top_ = median_top_;
1448    part->median_height_ = median_height_;
1449    part->median_left_ = median_left_;
1450    part->median_right_ = median_right_;
1451    part->median_width_ = median_width_;
1452    part->good_width_ = good_width_;
1453    part->good_column_ = good_column_;
1454    part->left_key_tab_ = left_key_tab_;
1455    part->right_key_tab_ = right_key_tab_;
1456    part->type_ = type_;
1457    part->flow_ = flow_;
1458    part->left_key_ = left_key_;
1459    part->right_key_ = right_key_;
1460    part->first_column_ = first_column_;
1461    part->last_column_ = last_column_;
1462    part->owns_blobs_ = false;
1463    return part;
1464  }
1465  ColPartition *ColPartition::CopyButDontOwnBlobs() {
1466    ColPartition *copy = ShallowCopy();
1467    copy->set_owns_blobs(false);
1468    BLOBNBOX_C_IT inserter(copy->boxes());
1469    BLOBNBOX_C_IT traverser(boxes());
1470    for (traverser.mark_cycle_pt(); !traverser.cycled_list();
1471         traverser.forward()) {
1472      inserter.add_after_then_move(traverser.data());
1473    }
1474    return copy;
1475  }
1476  #ifndef GRAPHICS_DISABLED
1477  ScrollView::Color ColPartition::BoxColor() const {
1478    if (type_ == PT_UNKNOWN) {
1479      return BLOBNBOX::TextlineColor(blob_type_, flow_);
1480    }
1481    return POLY_BLOCK::ColorForPolyBlockType(type_);
1482  }
1483  #endif 
1484  static char kBlobTypes[BRT_COUNT + 1] = "NHSRIUVT";
1485  void ColPartition::Print() const {
1486    int y = MidY();
1487    tprintf(
1488        "ColPart:%c(M%d-%c%d-B%d/%d,%d/%d)->(%dB-%d%c-%dM/%d,%d/%d)"
1489        " w-ok=%d, v-ok=%d, type=%d%c%d, fc=%d, lc=%d, boxes=%d"
1490        " ts=%d bs=%d ls=%d rs=%d\n",
1491        boxes_.empty() ? 'E' : ' ', left_margin_, left_key_tab_ ? 'T' : 'B',
1492        LeftAtY(y), bounding_box_.left(), median_left_, bounding_box_.bottom(),
1493        median_bottom_, bounding_box_.right(), RightAtY(y),
1494        right_key_tab_ ? 'T' : 'B', right_margin_, median_right_,
1495        bounding_box_.top(), median_top_, good_width_, good_column_, type_,
1496        kBlobTypes[blob_type_], flow_, first_column_, last_column_,
1497        boxes_.length(), space_above_, space_below_, space_to_left_,
1498        space_to_right_);
1499  }
1500  void ColPartition::PrintColors() {
1501    tprintf("Colors:(%d, %d, %d)%d -> (%d, %d, %d)\n", color1_[COLOR_RED],
1502            color1_[COLOR_GREEN], color1_[COLOR_BLUE], color1_[L_ALPHA_CHANNEL],
1503            color2_[COLOR_RED], color2_[COLOR_GREEN], color2_[COLOR_BLUE]);
1504  }
1505  void ColPartition::SmoothPartnerRun(int working_set_count) {
1506    STATS left_stats(0, working_set_count - 1);
1507    STATS right_stats(0, working_set_count - 1);
1508    PolyBlockType max_type = type_;
1509    ColPartition *partner;
1510    for (partner = SingletonPartner(false); partner != nullptr;
1511         partner = partner->SingletonPartner(false)) {
1512      if (partner->type_ > max_type) {
1513        max_type = partner->type_;
1514      }
1515      if (column_set_ == partner->column_set_) {
1516        left_stats.add(partner->first_column_, 1);
1517        right_stats.add(partner->last_column_, 1);
1518      }
1519    }
1520    type_ = max_type;
1521  #if 0
1522    first_column_ = left_stats.mode();
1523    last_column_ = right_stats.mode();
1524    if (last_column_ < first_column_)
1525      last_column_ = first_column_;
1526  #endif
1527    for (partner = SingletonPartner(false); partner != nullptr;
1528         partner = partner->SingletonPartner(false)) {
1529      partner->type_ = max_type;
1530  #if 0 
1531      if (column_set_ == partner->column_set_) {
1532        partner->first_column_ = first_column_;
1533        partner->last_column_ = last_column_;
1534      }
1535  #endif
1536    }
1537  }
1538  void ColPartition::RefinePartners(PolyBlockType type, bool get_desperate,
1539                                    ColPartitionGrid *grid) {
1540    if (TypesSimilar(type_, type)) {
1541      RefinePartnersInternal(true, get_desperate, grid);
1542      RefinePartnersInternal(false, get_desperate, grid);
1543    } else if (type == PT_COUNT) {
1544      RefinePartnersByType(true, &upper_partners_);
1545      RefinePartnersByType(false, &lower_partners_);
1546      if (!upper_partners_.empty() && !upper_partners_.singleton()) {
1547        RefinePartnersByOverlap(true, &upper_partners_);
1548      }
1549      if (!lower_partners_.empty() && !lower_partners_.singleton()) {
1550        RefinePartnersByOverlap(false, &lower_partners_);
1551      }
1552    }
1553  }
1554  void ColPartition::RefinePartnersInternal(bool upper, bool get_desperate,
1555                                            ColPartitionGrid *grid) {
1556    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
1557    if (!partners->empty() && !partners->singleton()) {
1558      RefinePartnersByType(upper, partners);
1559      if (!partners->empty() && !partners->singleton()) {
1560        RefinePartnerShortcuts(upper, partners);
1561        if (!partners->empty() && !partners->singleton()) {
1562          if (TypesSimilar(type_, PT_FLOWING_TEXT) && get_desperate) {
1563            RefineTextPartnersByMerge(upper, false, partners, grid);
1564            if (!partners->empty() && !partners->singleton()) {
1565              RefineTextPartnersByMerge(upper, true, partners, grid);
1566            }
1567          }
1568          if (!partners->empty() && !partners->singleton()) {
1569            RefinePartnersByOverlap(upper, partners);
1570          }
1571        }
1572      }
1573    }
1574  }
1575  void ColPartition::RefinePartnersByType(bool upper,
1576                                          ColPartition_CLIST *partners) {
1577    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1578                                           bounding_box_.bottom());
1579    if (debug) {
1580      tprintf("Refining %d %s partners by type for:\n", partners->length(),
1581              upper ? "Upper" : "Lower");
1582      Print();
1583    }
1584    ColPartition_C_IT it(partners);
1585    if (!IsImageType() && !IsLineType() && type() != PT_TABLE) {
1586      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1587        ColPartition *partner = it.data();
1588        if (!TypesSimilar(type_, partner->type_)) {
1589          if (debug) {
1590            tprintf("Removing partner:");
1591            partner->Print();
1592          }
1593          partner->RemovePartner(!upper, this);
1594          it.extract();
1595        } else if (debug) {
1596          tprintf("Keeping partner:");
1597          partner->Print();
1598        }
1599      }
1600    } else {
1601      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1602        ColPartition *partner = it.data();
1603        if (partner->blob_type() != BRT_POLYIMAGE ||
1604            blob_type() != BRT_POLYIMAGE) {
1605          if (debug) {
1606            tprintf("Removing partner:");
1607            partner->Print();
1608          }
1609          partner->RemovePartner(!upper, this);
1610          it.extract();
1611        } else if (debug) {
1612          tprintf("Keeping partner:");
1613          partner->Print();
1614        }
1615      }
1616    }
1617  }
1618  void ColPartition::RefinePartnerShortcuts(bool upper,
1619                                            ColPartition_CLIST *partners) {
1620    bool done_any = false;
1621    do {
1622      done_any = false;
1623      ColPartition_C_IT it(partners);
1624      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1625        ColPartition *a = it.data();
1626        ColPartition_C_IT it1(upper ? &a->upper_partners_ : &a->lower_partners_);
1627        for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
1628          ColPartition *b1 = it1.data();
1629          if (b1 == this) {
1630            done_any = true;
1631            it.extract();
1632            a->RemovePartner(!upper, this);
1633            break;
1634          }
1635          ColPartition_C_IT it2(partners);
1636          for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
1637            ColPartition *b2 = it2.data();
1638            if (b1 == b2) {
1639              it2.extract();
1640              b2->RemovePartner(!upper, this);
1641              done_any = true;
1642              break;
1643            }
1644          }
1645          if (done_any) {
1646            break;
1647          }
1648        }
1649        if (done_any) {
1650          break;
1651        }
1652      }
1653    } while (done_any && !partners->empty() && !partners->singleton());
1654  }
1655  void ColPartition::RefineTextPartnersByMerge(bool upper, bool desperate,
1656                                               ColPartition_CLIST *partners,
1657                                               ColPartitionGrid *grid) {
1658    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1659                                           bounding_box_.bottom());
1660    if (debug) {
1661      tprintf("Refining %d %s partners by merge for:\n", partners->length(),
1662              upper ? "Upper" : "Lower");
1663      Print();
1664    }
1665    while (!partners->empty() && !partners->singleton()) {
1666      ColPartition_C_IT it(partners);
1667      ColPartition *part = it.data();
1668      ColPartition_CLIST candidates;
1669      ColPartition_C_IT cand_it(&candidates);
1670      for (it.forward(); !it.at_first(); it.forward()) {
1671        ColPartition *candidate = it.data();
1672        if (part->first_column_ == candidate->last_column_ &&
1673            part->last_column_ == candidate->first_column_) {
1674          cand_it.add_after_then_move(it.data());
1675        }
1676      }
1677      int overlap_increase;
1678      ColPartition *candidate = grid->BestMergeCandidate(
1679          part, &candidates, debug, nullptr, &overlap_increase);
1680      if (candidate != nullptr && (overlap_increase <= 0 || desperate)) {
1681        if (debug) {
1682          tprintf("Merging:hoverlap=%d, voverlap=%d, OLI=%d\n",
1683                  part->HCoreOverlap(*candidate), part->VCoreOverlap(*candidate),
1684                  overlap_increase);
1685        }
1686        grid->RemoveBBox(candidate);
1687        grid->RemoveBBox(part);
1688        part->Absorb(candidate, nullptr);
1689        grid->InsertBBox(true, true, part);
1690        if (overlap_increase > 0) {
1691          part->desperately_merged_ = true;
1692        }
1693      } else {
1694        break; 
1695      }
1696    }
1697  }
1698  void ColPartition::RefinePartnersByOverlap(bool upper,
1699                                             ColPartition_CLIST *partners) {
1700    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1701                                           bounding_box_.bottom());
1702    if (debug) {
1703      tprintf("Refining %d %s partners by overlap for:\n", partners->length(),
1704              upper ? "Upper" : "Lower");
1705      Print();
1706    }
1707    ColPartition_C_IT it(partners);
1708    ColPartition *best_partner = it.data();
1709    int best_overlap = 0;
1710    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1711      ColPartition *partner = it.data();
1712      int overlap =
1713          std::min(bounding_box_.right(), partner->bounding_box_.right()) -
1714          std::max(bounding_box_.left(), partner->bounding_box_.left());
1715      if (overlap > best_overlap) {
1716        best_overlap = overlap;
1717        best_partner = partner;
1718      }
1719    }
1720    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1721      ColPartition *partner = it.data();
1722      if (partner != best_partner) {
1723        if (debug) {
1724          tprintf("Removing partner:");
1725          partner->Print();
1726        }
1727        partner->RemovePartner(!upper, this);
1728        it.extract();
1729      }
1730    }
1731  }
1732  bool ColPartition::ThisPartitionBetter(BLOBNBOX *bbox,
1733                                         const ColPartition &other) {
1734    const TBOX &box = bbox->bounding_box();
1735    int left = box.left();
1736    int right = box.right();
1737    if (left < left_margin_ || right > right_margin_) {
1738      return false;
1739    }
1740    if (left < other.left_margin_ || right > other.right_margin_) {
1741      return true;
1742    }
1743    int top = box.top();
1744    int bottom = box.bottom();
1745    int this_overlap =
1746        std::min(top, median_top_) - std::max(bottom, median_bottom_);
1747    int other_overlap =
1748        std::min(top, other.median_top_) - std::max(bottom, other.median_bottom_);
1749    int this_miss = median_top_ - median_bottom_ - this_overlap;
1750    int other_miss = other.median_top_ - other.median_bottom_ - other_overlap;
1751    if (TabFind::WithinTestRegion(3, box.left(), box.bottom())) {
1752      tprintf("Unique on (%d,%d)->(%d,%d) overlap %d/%d, miss %d/%d, mt=%d/%d\n",
1753              box.left(), box.bottom(), box.right(), box.top(), this_overlap,
1754              other_overlap, this_miss, other_miss, median_top_,
1755              other.median_top_);
1756    }
1757    if (this_miss < other_miss) {
1758      return true;
1759    }
1760    if (this_miss > other_miss) {
1761      return false;
1762    }
1763    if (this_overlap > other_overlap) {
1764      return true;
1765    }
1766    if (this_overlap < other_overlap) {
1767      return false;
1768    }
1769    return median_top_ >= other.median_top_;
1770  }
1771  static int MedianSpacing(int page_height, ColPartition_IT it) {
1772    STATS stats(0, page_height - 1);
1773    while (!it.cycled_list()) {
1774      ColPartition *part = it.data();
1775      it.forward();
1776      stats.add(part->bottom_spacing(), 1);
1777      stats.add(part->top_spacing(), 1);
1778    }
1779    return static_cast<int>(stats.median() + 0.5);
1780  }
1781  bool ColPartition::IsInSameColumnAs(const ColPartition &part) const {
1782    return (last_column_ >= part.first_column_) &&
1783           (first_column_ <= part.last_column_);
1784  }
1785  void ColPartition::SmoothSpacings(int resolution, int page_height,
1786                                    ColPartition_LIST *parts) {
1787    ColPartition *neighbourhood[PN_COUNT];
1788    ColPartition_IT it(parts);
1789    it.mark_cycle_pt();
1790    int median_space = MedianSpacing(page_height, it);
1791    ColPartition_IT start_it(it);
1792    ColPartition_IT end_it(it);
1793    for (int i = 0; i < PN_COUNT; ++i) {
1794      if (i < PN_UPPER || it.cycled_list()) {
1795        neighbourhood[i] = nullptr;
1796      } else {
1797        if (i == PN_LOWER) {
1798          end_it = it;
1799        }
1800        neighbourhood[i] = it.data();
1801        it.forward();
1802      }
1803    }
1804    while (neighbourhood[PN_UPPER] != nullptr) {
1805      if (neighbourhood[PN_LOWER] == nullptr ||
1806          (!neighbourhood[PN_UPPER]->SpacingsEqual(*neighbourhood[PN_LOWER],
1807                                                   resolution) &&
1808           (neighbourhood[PN_UPPER] == nullptr ||
1809            neighbourhood[PN_LOWER] == nullptr ||
1810            !OKSpacingBlip(resolution, median_space, neighbourhood, 0)) &&
1811           (neighbourhood[PN_UPPER - 1] == nullptr ||
1812            neighbourhood[PN_LOWER - 1] == nullptr ||
1813            !OKSpacingBlip(resolution, median_space, neighbourhood, -1) ||
1814            !neighbourhood[PN_LOWER]->SpacingEqual(median_space, resolution)) &&
1815           (neighbourhood[PN_UPPER + 1] == nullptr ||
1816            neighbourhood[PN_LOWER + 1] == nullptr ||
1817            !OKSpacingBlip(resolution, median_space, neighbourhood, 1) ||
1818            !neighbourhood[PN_UPPER]->SpacingEqual(median_space, resolution)))) {
1819        ColPartition_IT sum_it(start_it);
1820        ColPartition *last_part = neighbourhood[PN_UPPER];
1821        double total_bottom = 0.0;
1822        double total_top = 0.0;
1823        int total_count = 0;
1824        ColPartition *upper = sum_it.data();
1825        while (upper != last_part) {
1826          total_bottom += upper->bottom_spacing();
1827          total_top += upper->top_spacing();
1828          ++total_count;
1829          sum_it.forward();
1830          upper = sum_it.data();
1831        }
1832        if (total_count > 0) {
1833          int top_spacing = static_cast<int>(total_top / total_count + 0.5);
1834          int bottom_spacing = static_cast<int>(total_bottom / total_count + 0.5);
1835          if (textord_debug_tabfind) {
1836            tprintf("Spacing run ended. Cause:");
1837            if (neighbourhood[PN_LOWER] == nullptr) {
1838              tprintf("No more lines\n");
1839            } else {
1840              tprintf("Spacing change. Spacings:\n");
1841              for (int i = 0; i < PN_COUNT; ++i) {
1842                if (neighbourhood[i] == nullptr) {
1843                  tprintf("NULL");
1844                  if (i > 0 && neighbourhood[i - 1] != nullptr) {
1845                    if (neighbourhood[i - 1]->SingletonPartner(false) !=
1846                        nullptr) {
1847                      tprintf(" Lower partner:");
1848                      neighbourhood[i - 1]->SingletonPartner(false)->Print();
1849                    } else {
1850                      tprintf(" nullptr lower partner:\n");
1851                    }
1852                  } else {
1853                    tprintf("\n");
1854                  }
1855                } else {
1856                  tprintf("Top = %d, bottom = %d\n",
1857                          neighbourhood[i]->top_spacing(),
1858                          neighbourhood[i]->bottom_spacing());
1859                }
1860              }
1861            }
1862            tprintf("Mean spacing = %d/%d\n", top_spacing, bottom_spacing);
1863          }
1864          sum_it = start_it;
1865          upper = sum_it.data();
1866          while (upper != last_part) {
1867            upper->set_top_spacing(top_spacing);
1868            upper->set_bottom_spacing(bottom_spacing);
1869            if (textord_debug_tabfind) {
1870              tprintf("Setting mean on:");
1871              upper->Print();
1872            }
1873            sum_it.forward();
1874            upper = sum_it.data();
1875          }
1876        }
1877        start_it = end_it;
1878        median_space = MedianSpacing(page_height, end_it);
1879      }
1880      for (int j = 1; j < PN_COUNT; ++j) {
1881        neighbourhood[j - 1] = neighbourhood[j];
1882      }
1883      if (it.cycled_list()) {
1884        neighbourhood[PN_COUNT - 1] = nullptr;
1885      } else {
1886        neighbourhood[PN_COUNT - 1] = it.data();
1887        it.forward();
1888      }
1889      end_it.forward();
1890    }
1891  }
1892  bool ColPartition::OKSpacingBlip(int resolution, int median_spacing,
1893                                   ColPartition **parts, int offset) {
1894    parts += offset;
1895    return parts[PN_UPPER]->SummedSpacingOK(*parts[PN_LOWER], median_spacing,
1896                                            resolution) &&
1897           ((parts[PN_ABOVE1] != nullptr &&
1898             parts[PN_ABOVE1]->SpacingEqual(median_spacing, resolution)) ||
1899            (parts[PN_BELOW1] != nullptr &&
1900             parts[PN_BELOW1]->SpacingEqual(median_spacing, resolution)));
1901  }
1902  bool ColPartition::SpacingEqual(int spacing, int resolution) const {
1903    int bottom_error = BottomSpacingMargin(resolution);
1904    int top_error = TopSpacingMargin(resolution);
1905    return NearlyEqual(bottom_spacing_, spacing, bottom_error) &&
1906           NearlyEqual(top_spacing_, spacing, top_error);
1907  }
1908  bool ColPartition::SpacingsEqual(const ColPartition &other,
1909                                   int resolution) const {
1910    int bottom_error = std::max(BottomSpacingMargin(resolution),
1911                                other.BottomSpacingMargin(resolution));
1912    int top_error = std::max(TopSpacingMargin(resolution),
1913                             other.TopSpacingMargin(resolution));
1914    return NearlyEqual(bottom_spacing_, other.bottom_spacing_, bottom_error) &&
1915           (NearlyEqual(top_spacing_, other.top_spacing_, top_error) ||
1916            NearlyEqual(top_spacing_ + other.top_spacing_, bottom_spacing_ * 2,
1917                        bottom_error));
1918  }
1919  bool ColPartition::SummedSpacingOK(const ColPartition &other, int spacing,
1920                                     int resolution) const {
1921    int bottom_error = std::max(BottomSpacingMargin(resolution),
1922                                other.BottomSpacingMargin(resolution));
1923    int top_error = std::max(TopSpacingMargin(resolution),
1924                             other.TopSpacingMargin(resolution));
1925    int bottom_total = bottom_spacing_ + other.bottom_spacing_;
1926    int top_total = top_spacing_ + other.top_spacing_;
1927    return (NearlyEqual(spacing, bottom_total, bottom_error) &&
1928            NearlyEqual(spacing, top_total, top_error)) ||
1929           (NearlyEqual(spacing * 2, bottom_total, bottom_error) &&
1930            NearlyEqual(spacing * 2, top_total, top_error));
1931  }
1932  int ColPartition::BottomSpacingMargin(int resolution) const {
1933    return static_cast<int>(kMaxSpacingDrift * resolution + 0.5) + side_step_;
1934  }
1935  int ColPartition::TopSpacingMargin(int resolution) const {
1936    return static_cast<int>(kMaxTopSpacingFraction * median_height_ + 0.5) +
1937           BottomSpacingMargin(resolution);
1938  }
1939  bool ColPartition::SizesSimilar(const ColPartition &other) const {
1940    return median_height_ <= other.median_height_ * kMaxSizeRatio &&
1941           other.median_height_ <= median_height_ * kMaxSizeRatio;
1942  }
1943  static bool UpdateLeftMargin(const ColPartition &part, int *margin_left,
1944                               int *margin_right) {
1945    const TBOX &part_box = part.bounding_box();
1946    int top = part_box.top();
1947    int bottom = part_box.bottom();
1948    int tl_key = part.SortKey(part.left_margin(), top);
1949    int tr_key = part.SortKey(part_box.left(), top);
1950    int bl_key = part.SortKey(part.left_margin(), bottom);
1951    int br_key = part.SortKey(part_box.left(), bottom);
1952    int left_key = std::max(tl_key, bl_key);
1953    int right_key = std::min(tr_key, br_key);
1954    if (left_key <= *margin_right && right_key >= *margin_left) {
1955      *margin_right = std::min(*margin_right, right_key);
1956      *margin_left = std::max(*margin_left, left_key);
1957      return true;
1958    }
1959    return false;
1960  }
1961  void ColPartition::LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start,
1962                                 ICOORD *end) {
1963    ColPartition *part = part_it->data();
1964    ColPartition *start_part = part;
1965    int start_y = part->bounding_box_.top();
1966    if (!part_it->at_first()) {
1967      int prev_bottom = part_it->data_relative(-1)->bounding_box_.bottom();
1968      if (prev_bottom < start_y) {
1969        start_y = prev_bottom;
1970      } else if (prev_bottom > start_y) {
1971        start_y = (start_y + prev_bottom) / 2;
1972      }
1973    }
1974    int end_y = part->bounding_box_.bottom();
1975    int margin_right = INT32_MAX;
1976    int margin_left = -INT32_MAX;
1977    UpdateLeftMargin(*part, &margin_left, &margin_right);
1978    do {
1979      part_it->forward();
1980      part = part_it->data();
1981    } while (!part_it->at_first() &&
1982             UpdateLeftMargin(*part, &margin_left, &margin_right));
1983    int next_margin_right = INT32_MAX;
1984    int next_margin_left = -INT32_MAX;
1985    UpdateLeftMargin(*part, &next_margin_left, &next_margin_right);
1986    if (next_margin_left > margin_right) {
1987      ColPartition_IT next_it(*part_it);
1988      do {
1989        next_it.forward();
1990        part = next_it.data();
1991      } while (!next_it.at_first() &&
1992               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1993      do {
1994        part_it->backward();
1995        part = part_it->data();
1996      } while (part != start_part &&
1997               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1998      part_it->forward();
1999    }
2000    part = part_it->data_relative(-1);
2001    end_y = part->bounding_box_.bottom();
2002    if (!part_it->at_first() && part_it->data()->bounding_box_.top() < end_y) {
2003      end_y = (end_y + part_it->data()->bounding_box_.top()) / 2;
2004    }
2005    start->set_y(start_y);
2006    start->set_x(part->XAtY(margin_right, start_y));
2007    end->set_y(end_y);
2008    end->set_x(part->XAtY(margin_right, end_y));
2009    if (textord_debug_tabfind && !part_it->at_first()) {
2010      tprintf("Left run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2011              start_y, end_y, part->XAtY(margin_left, end_y), end->x(),
2012              part->left_margin_, part->bounding_box_.left());
2013    }
2014  }
2015  static bool UpdateRightMargin(const ColPartition &part, int *margin_left,
2016                                int *margin_right) {
2017    const TBOX &part_box = part.bounding_box();
2018    int top = part_box.top();
2019    int bottom = part_box.bottom();
2020    int tl_key = part.SortKey(part_box.right(), top);
2021    int tr_key = part.SortKey(part.right_margin(), top);
2022    int bl_key = part.SortKey(part_box.right(), bottom);
2023    int br_key = part.SortKey(part.right_margin(), bottom);
2024    int left_key = std::max(tl_key, bl_key);
2025    int right_key = std::min(tr_key, br_key);
2026    if (left_key <= *margin_right && right_key >= *margin_left) {
2027      *margin_right = std::min(*margin_right, right_key);
2028      *margin_left = std::max(*margin_left, left_key);
2029      return true;
2030    }
2031    return false;
2032  }
2033  void ColPartition::RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
2034                                  ICOORD *end) {
2035    ColPartition *part = part_it->data();
2036    ColPartition *start_part = part;
2037    int start_y = part->bounding_box_.bottom();
2038    if (!part_it->at_last()) {
2039      int next_y = part_it->data_relative(1)->bounding_box_.top();
2040      if (next_y > start_y) {
2041        start_y = next_y;
2042      } else if (next_y < start_y) {
2043        start_y = (start_y + next_y) / 2;
2044      }
2045    }
2046    int end_y = part->bounding_box_.top();
2047    int margin_right = INT32_MAX;
2048    int margin_left = -INT32_MAX;
2049    UpdateRightMargin(*part, &margin_left, &margin_right);
2050    do {
2051      part_it->backward();
2052      part = part_it->data();
2053    } while (!part_it->at_last() &&
2054             UpdateRightMargin(*part, &margin_left, &margin_right));
2055    int next_margin_right = INT32_MAX;
2056    int next_margin_left = -INT32_MAX;
2057    UpdateRightMargin(*part, &next_margin_left, &next_margin_right);
2058    if (next_margin_right < margin_left) {
2059      ColPartition_IT next_it(*part_it);
2060      do {
2061        next_it.backward();
2062        part = next_it.data();
2063      } while (!next_it.at_last() &&
2064               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2065      do {
2066        part_it->forward();
2067        part = part_it->data();
2068      } while (part != start_part &&
2069               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2070      part_it->backward();
2071    }
2072    part = part_it->data_relative(1);
2073    end_y = part->bounding_box().top();
2074    if (!part_it->at_last() && part_it->data()->bounding_box_.bottom() > end_y) {
2075      end_y = (end_y + part_it->data()->bounding_box_.bottom()) / 2;
2076    }
2077    start->set_y(start_y);
2078    start->set_x(part->XAtY(margin_left, start_y));
2079    end->set_y(end_y);
2080    end->set_x(part->XAtY(margin_left, end_y));
2081    if (textord_debug_tabfind && !part_it->at_last()) {
2082      tprintf("Right run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2083              start_y, end_y, end->x(), part->XAtY(margin_right, end_y),
2084              part->bounding_box_.right(), part->right_margin_);
2085    }
2086  }
2087  } 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-json.hpp</h3>
            <pre><code>1  #ifndef INCLUDE_NLOHMANN_JSON_HPP_
2  #define INCLUDE_NLOHMANN_JSON_HPP_
3  #include <algorithm> 
4  #include <cstddef> 
5  #include <functional> 
6  #include <initializer_list> 
7  #ifndef JSON_NO_IO
8      #include <iosfwd> 
9  #endif  
10  #include <iterator> 
11  #include <memory> 
12  #include <numeric> 
13  #include <string> 
14  #include <utility> 
15  #include <vector> 
16  #include <utility>
17  #ifndef JSON_SKIP_LIBRARY_VERSION_CHECK
18      #if defined(NLOHMANN_JSON_VERSION_MAJOR) && defined(NLOHMANN_JSON_VERSION_MINOR) && defined(NLOHMANN_JSON_VERSION_PATCH)
19          #if NLOHMANN_JSON_VERSION_MAJOR != 3 || NLOHMANN_JSON_VERSION_MINOR != 11 || NLOHMANN_JSON_VERSION_PATCH != 2
20              #warning "Already included a different version of the library!"
21          #endif
22      #endif
23  #endif
24  #define NLOHMANN_JSON_VERSION_MAJOR 3   
25  #define NLOHMANN_JSON_VERSION_MINOR 11  
26  #define NLOHMANN_JSON_VERSION_PATCH 2   
27  #ifndef JSON_DIAGNOSTICS
28      #define JSON_DIAGNOSTICS 0
29  #endif
30  #ifndef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
31      #define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0
32  #endif
33  #if JSON_DIAGNOSTICS
34      #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS _diag
35  #else
36      #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS
37  #endif
38  #if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
39      #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON _ldvcmp
40  #else
41      #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON
42  #endif
43  #ifndef NLOHMANN_JSON_NAMESPACE_NO_VERSION
44      #define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0
45  #endif
46  #define NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b) json_abi ## a ## b
47  #define NLOHMANN_JSON_ABI_TAGS_CONCAT(a, b) \
48      NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b)
49  #define NLOHMANN_JSON_ABI_TAGS                                       \
50      NLOHMANN_JSON_ABI_TAGS_CONCAT(                                   \
51              NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS,                       \
52              NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON)
53  #define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch) \
54      _v ## major ## _ ## minor ## _ ## patch
55  #define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(major, minor, patch) \
56      NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch)
57  #if NLOHMANN_JSON_NAMESPACE_NO_VERSION
58  #define NLOHMANN_JSON_NAMESPACE_VERSION
59  #else
60  #define NLOHMANN_JSON_NAMESPACE_VERSION                                 \
61      NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(NLOHMANN_JSON_VERSION_MAJOR, \
62                                             NLOHMANN_JSON_VERSION_MINOR, \
63                                             NLOHMANN_JSON_VERSION_PATCH)
64  #endif
65  #define NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b) a ## b
66  #define NLOHMANN_JSON_NAMESPACE_CONCAT(a, b) \
67      NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b)
68  #ifndef NLOHMANN_JSON_NAMESPACE
69  #define NLOHMANN_JSON_NAMESPACE               \
70      nlohmann::NLOHMANN_JSON_NAMESPACE_CONCAT( \
71              NLOHMANN_JSON_ABI_TAGS,           \
72              NLOHMANN_JSON_NAMESPACE_VERSION)
73  #endif
74  #ifndef NLOHMANN_JSON_NAMESPACE_BEGIN
75  #define NLOHMANN_JSON_NAMESPACE_BEGIN                \
76      namespace nlohmann                               \
77      {                                                \
78      inline namespace NLOHMANN_JSON_NAMESPACE_CONCAT( \
79                  NLOHMANN_JSON_ABI_TAGS,              \
80                  NLOHMANN_JSON_NAMESPACE_VERSION)     \
81      {
82  #endif
83  #ifndef NLOHMANN_JSON_NAMESPACE_END
84  #define NLOHMANN_JSON_NAMESPACE_END                                     \
85      }  &bsol;* namespace (inline namespace) NOLINT(readability/namespace) */ \
86      }  
87  #endif
88  #include <algorithm> 
89  #include <array> 
90  #include <forward_list> 
91  #include <iterator> 
92  #include <map> 
93  #include <string> 
94  #include <tuple> 
95  #include <type_traits> 
96  #include <unordered_map> 
97  #include <utility> 
98  #include <valarray> 
99  #include <cstddef> 
100  #include <exception> 
101  #include <stdexcept> 
102  #include <string> 
103  #include <vector> 
104  #include <array> 
105  #include <cstddef> 
106  #include <cstdint> 
107  #include <string> 
108  #include <utility> 
109  #include <type_traits>
110  NLOHMANN_JSON_NAMESPACE_BEGIN
111  namespace detail
112  {
113  template<typename ...Ts> struct make_void
114  {
115      using type = void;
116  };
117  template<typename ...Ts> using void_t = typename make_void<Ts...>::type;
118  }  
119  NLOHMANN_JSON_NAMESPACE_END
120  NLOHMANN_JSON_NAMESPACE_BEGIN
121  namespace detail
122  {
123  struct nonesuch
124  {
125      nonesuch() = delete;
126      ~nonesuch() = delete;
127      nonesuch(nonesuch const&) = delete;
128      nonesuch(nonesuch const&&) = delete;
129      void operator=(nonesuch const&) = delete;
130      void operator=(nonesuch&&) = delete;
131  };
132  template<class Default,
133           class AlwaysVoid,
134           template<class...> class Op,
135           class... Args>
136  struct detector
137  {
138      using value_t = std::false_type;
139      using type = Default;
140  };
141  template<class Default, template<class...> class Op, class... Args>
142  struct detector<Default, void_t<Op<Args...>>, Op, Args...>
143  {
144      using value_t = std::true_type;
145      using type = Op<Args...>;
146  };
147  template<template<class...> class Op, class... Args>
148  using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;
149  template<template<class...> class Op, class... Args>
150  struct is_detected_lazy : is_detected<Op, Args...> { };
151  template<template<class...> class Op, class... Args>
152  using detected_t = typename detector<nonesuch, void, Op, Args...>::type;
153  template<class Default, template<class...> class Op, class... Args>
154  using detected_or = detector<Default, void, Op, Args...>;
155  template<class Default, template<class...> class Op, class... Args>
156  using detected_or_t = typename detected_or<Default, Op, Args...>::type;
157  template<class Expected, template<class...> class Op, class... Args>
158  using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;
159  template<class To, template<class...> class Op, class... Args>
160  using is_detected_convertible =
161      std::is_convertible<detected_t<Op, Args...>, To>;
162  }  
163  NLOHMANN_JSON_NAMESPACE_END
164  #if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 15)
165  #if defined(JSON_HEDLEY_VERSION)
166      #undef JSON_HEDLEY_VERSION
167  #endif
168  #define JSON_HEDLEY_VERSION 15
169  #if defined(JSON_HEDLEY_STRINGIFY_EX)
170      #undef JSON_HEDLEY_STRINGIFY_EX
171  #endif
172  #define JSON_HEDLEY_STRINGIFY_EX(x) #x
173  #if defined(JSON_HEDLEY_STRINGIFY)
174      #undef JSON_HEDLEY_STRINGIFY
175  #endif
176  #define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)
177  #if defined(JSON_HEDLEY_CONCAT_EX)
178      #undef JSON_HEDLEY_CONCAT_EX
179  #endif
180  #define JSON_HEDLEY_CONCAT_EX(a,b) a##b
181  #if defined(JSON_HEDLEY_CONCAT)
182      #undef JSON_HEDLEY_CONCAT
183  #endif
184  #define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)
185  #if defined(JSON_HEDLEY_CONCAT3_EX)
186      #undef JSON_HEDLEY_CONCAT3_EX
187  #endif
188  #define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c
189  #if defined(JSON_HEDLEY_CONCAT3)
190      #undef JSON_HEDLEY_CONCAT3
191  #endif
192  #define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)
193  #if defined(JSON_HEDLEY_VERSION_ENCODE)
194      #undef JSON_HEDLEY_VERSION_ENCODE
195  #endif
196  #define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))
197  #if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
198      #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
199  #endif
200  #define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)
201  #if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
202      #undef JSON_HEDLEY_VERSION_DECODE_MINOR
203  #endif
204  #define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)
205  #if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
206      #undef JSON_HEDLEY_VERSION_DECODE_REVISION
207  #endif
208  #define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)
209  #if defined(JSON_HEDLEY_GNUC_VERSION)
210      #undef JSON_HEDLEY_GNUC_VERSION
211  #endif
212  #if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
213      #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
214  #elif defined(__GNUC__)
215      #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
216  #endif
217  #if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
218      #undef JSON_HEDLEY_GNUC_VERSION_CHECK
219  #endif
220  #if defined(JSON_HEDLEY_GNUC_VERSION)
221      #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
222  #else
223      #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
224  #endif
225  #if defined(JSON_HEDLEY_MSVC_VERSION)
226      #undef JSON_HEDLEY_MSVC_VERSION
227  #endif
228  #if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)
229      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
230  #elif defined(_MSC_FULL_VER) && !defined(__ICL)
231      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
232  #elif defined(_MSC_VER) && !defined(__ICL)
233      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
234  #endif
235  #if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
236      #undef JSON_HEDLEY_MSVC_VERSION_CHECK
237  #endif
238  #if !defined(JSON_HEDLEY_MSVC_VERSION)
239      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
240  #elif defined(_MSC_VER) && (_MSC_VER >= 1400)
241      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
242  #elif defined(_MSC_VER) && (_MSC_VER >= 1200)
243      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
244  #else
245      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
246  #endif
247  #if defined(JSON_HEDLEY_INTEL_VERSION)
248      #undef JSON_HEDLEY_INTEL_VERSION
249  #endif
250  #if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && !defined(__ICL)
251      #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
252  #elif defined(__INTEL_COMPILER) && !defined(__ICL)
253      #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
254  #endif
255  #if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
256      #undef JSON_HEDLEY_INTEL_VERSION_CHECK
257  #endif
258  #if defined(JSON_HEDLEY_INTEL_VERSION)
259      #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
260  #else
261      #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
262  #endif
263  #if defined(JSON_HEDLEY_INTEL_CL_VERSION)
264      #undef JSON_HEDLEY_INTEL_CL_VERSION
265  #endif
266  #if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && defined(__ICL)
267      #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
268  #endif
269  #if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)
270      #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
271  #endif
272  #if defined(JSON_HEDLEY_INTEL_CL_VERSION)
273      #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
274  #else
275      #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)
276  #endif
277  #if defined(JSON_HEDLEY_PGI_VERSION)
278      #undef JSON_HEDLEY_PGI_VERSION
279  #endif
280  #if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
281      #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
282  #endif
283  #if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
284      #undef JSON_HEDLEY_PGI_VERSION_CHECK
285  #endif
286  #if defined(JSON_HEDLEY_PGI_VERSION)
287      #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
288  #else
289      #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
290  #endif
291  #if defined(JSON_HEDLEY_SUNPRO_VERSION)
292      #undef JSON_HEDLEY_SUNPRO_VERSION
293  #endif
294  #if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
295      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
296  #elif defined(__SUNPRO_C)
297      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
298  #elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
299      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
300  #elif defined(__SUNPRO_CC)
301      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
302  #endif
303  #if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
304      #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
305  #endif
306  #if defined(JSON_HEDLEY_SUNPRO_VERSION)
307      #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
308  #else
309      #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
310  #endif
311  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
312      #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
313  #endif
314  #if defined(__EMSCRIPTEN__)
315      #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
316  #endif
317  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
318      #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
319  #endif
320  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
321      #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
322  #else
323      #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
324  #endif
325  #if defined(JSON_HEDLEY_ARM_VERSION)
326      #undef JSON_HEDLEY_ARM_VERSION
327  #endif
328  #if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
329      #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
330  #elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
331      #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
332  #endif
333  #if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
334      #undef JSON_HEDLEY_ARM_VERSION_CHECK
335  #endif
336  #if defined(JSON_HEDLEY_ARM_VERSION)
337      #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
338  #else
339      #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
340  #endif
341  #if defined(JSON_HEDLEY_IBM_VERSION)
342      #undef JSON_HEDLEY_IBM_VERSION
343  #endif
344  #if defined(__ibmxl__)
345      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
346  #elif defined(__xlC__) && defined(__xlC_ver__)
347      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
348  #elif defined(__xlC__)
349      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
350  #endif
351  #if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
352      #undef JSON_HEDLEY_IBM_VERSION_CHECK
353  #endif
354  #if defined(JSON_HEDLEY_IBM_VERSION)
355      #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
356  #else
357      #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
358  #endif
359  #if defined(JSON_HEDLEY_TI_VERSION)
360      #undef JSON_HEDLEY_TI_VERSION
361  #endif
362  #if \
363      defined(__TI_COMPILER_VERSION__) && \
364      ( \
365        defined(__TMS470__) || defined(__TI_ARM__) || \
366        defined(__MSP430__) || \
367        defined(__TMS320C2000__) \
368      )
369  #if (__TI_COMPILER_VERSION__ >= 16000000)
370      #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
371  #endif
372  #endif
373  #if defined(JSON_HEDLEY_TI_VERSION_CHECK)
374      #undef JSON_HEDLEY_TI_VERSION_CHECK
375  #endif
376  #if defined(JSON_HEDLEY_TI_VERSION)
377      #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
378  #else
379      #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
380  #endif
381  #if defined(JSON_HEDLEY_TI_CL2000_VERSION)
382      #undef JSON_HEDLEY_TI_CL2000_VERSION
383  #endif
384  #if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
385      #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
386  #endif
387  #if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
388      #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
389  #endif
390  #if defined(JSON_HEDLEY_TI_CL2000_VERSION)
391      #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
392  #else
393      #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
394  #endif
395  #if defined(JSON_HEDLEY_TI_CL430_VERSION)
396      #undef JSON_HEDLEY_TI_CL430_VERSION
397  #endif
398  #if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
399      #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
400  #endif
401  #if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
402      #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
403  #endif
404  #if defined(JSON_HEDLEY_TI_CL430_VERSION)
405      #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
406  #else
407      #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
408  #endif
409  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
410      #undef JSON_HEDLEY_TI_ARMCL_VERSION
411  #endif
412  #if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))
413      #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
414  #endif
415  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
416      #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
417  #endif
418  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
419      #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
420  #else
421      #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
422  #endif
423  #if defined(JSON_HEDLEY_TI_CL6X_VERSION)
424      #undef JSON_HEDLEY_TI_CL6X_VERSION
425  #endif
426  #if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
427      #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
428  #endif
429  #if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
430      #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
431  #endif
432  #if defined(JSON_HEDLEY_TI_CL6X_VERSION)
433      #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
434  #else
435      #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
436  #endif
437  #if defined(JSON_HEDLEY_TI_CL7X_VERSION)
438      #undef JSON_HEDLEY_TI_CL7X_VERSION
439  #endif
440  #if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
441      #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
442  #endif
443  #if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
444      #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
445  #endif
446  #if defined(JSON_HEDLEY_TI_CL7X_VERSION)
447      #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
448  #else
449      #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
450  #endif
451  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
452      #undef JSON_HEDLEY_TI_CLPRU_VERSION
453  #endif
454  #if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
455      #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
456  #endif
457  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
458      #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
459  #endif
460  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
461      #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
462  #else
463      #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
464  #endif
465  #if defined(JSON_HEDLEY_CRAY_VERSION)
466      #undef JSON_HEDLEY_CRAY_VERSION
467  #endif
468  #if defined(_CRAYC)
469      #if defined(_RELEASE_PATCHLEVEL)
470          #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
471      #else
472          #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
473      #endif
474  #endif
475  #if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
476      #undef JSON_HEDLEY_CRAY_VERSION_CHECK
477  #endif
478  #if defined(JSON_HEDLEY_CRAY_VERSION)
479      #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
480  #else
481      #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
482  #endif
483  #if defined(JSON_HEDLEY_IAR_VERSION)
484      #undef JSON_HEDLEY_IAR_VERSION
485  #endif
486  #if defined(__IAR_SYSTEMS_ICC__)
487      #if __VER__ > 1000
488          #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
489      #else
490          #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)
491      #endif
492  #endif
493  #if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
494      #undef JSON_HEDLEY_IAR_VERSION_CHECK
495  #endif
496  #if defined(JSON_HEDLEY_IAR_VERSION)
497      #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
498  #else
499      #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
500  #endif
501  #if defined(JSON_HEDLEY_TINYC_VERSION)
502      #undef JSON_HEDLEY_TINYC_VERSION
503  #endif
504  #if defined(__TINYC__)
505      #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
506  #endif
507  #if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
508      #undef JSON_HEDLEY_TINYC_VERSION_CHECK
509  #endif
510  #if defined(JSON_HEDLEY_TINYC_VERSION)
511      #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
512  #else
513      #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
514  #endif
515  #if defined(JSON_HEDLEY_DMC_VERSION)
516      #undef JSON_HEDLEY_DMC_VERSION
517  #endif
518  #if defined(__DMC__)
519      #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
520  #endif
521  #if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
522      #undef JSON_HEDLEY_DMC_VERSION_CHECK
523  #endif
524  #if defined(JSON_HEDLEY_DMC_VERSION)
525      #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
526  #else
527      #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
528  #endif
529  #if defined(JSON_HEDLEY_COMPCERT_VERSION)
530      #undef JSON_HEDLEY_COMPCERT_VERSION
531  #endif
532  #if defined(__COMPCERT_VERSION__)
533      #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
534  #endif
535  #if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
536      #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
537  #endif
538  #if defined(JSON_HEDLEY_COMPCERT_VERSION)
539      #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
540  #else
541      #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
542  #endif
543  #if defined(JSON_HEDLEY_PELLES_VERSION)
544      #undef JSON_HEDLEY_PELLES_VERSION
545  #endif
546  #if defined(__POCC__)
547      #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
548  #endif
549  #if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
550      #undef JSON_HEDLEY_PELLES_VERSION_CHECK
551  #endif
552  #if defined(JSON_HEDLEY_PELLES_VERSION)
553      #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
554  #else
555      #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
556  #endif
557  #if defined(JSON_HEDLEY_MCST_LCC_VERSION)
558      #undef JSON_HEDLEY_MCST_LCC_VERSION
559  #endif
560  #if defined(__LCC__) && defined(__LCC_MINOR__)
561      #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)
562  #endif
563  #if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)
564      #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
565  #endif
566  #if defined(JSON_HEDLEY_MCST_LCC_VERSION)
567      #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
568  #else
569      #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)
570  #endif
571  #if defined(JSON_HEDLEY_GCC_VERSION)
572      #undef JSON_HEDLEY_GCC_VERSION
573  #endif
574  #if \
575      defined(JSON_HEDLEY_GNUC_VERSION) && \
576      !defined(__clang__) && \
577      !defined(JSON_HEDLEY_INTEL_VERSION) && \
578      !defined(JSON_HEDLEY_PGI_VERSION) && \
579      !defined(JSON_HEDLEY_ARM_VERSION) && \
580      !defined(JSON_HEDLEY_CRAY_VERSION) && \
581      !defined(JSON_HEDLEY_TI_VERSION) && \
582      !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \
583      !defined(JSON_HEDLEY_TI_CL430_VERSION) && \
584      !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \
585      !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \
586      !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \
587      !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \
588      !defined(__COMPCERT__) && \
589      !defined(JSON_HEDLEY_MCST_LCC_VERSION)
590      #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
591  #endif
592  #if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
593      #undef JSON_HEDLEY_GCC_VERSION_CHECK
594  #endif
595  #if defined(JSON_HEDLEY_GCC_VERSION)
596      #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
597  #else
598      #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
599  #endif
600  #if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
601      #undef JSON_HEDLEY_HAS_ATTRIBUTE
602  #endif
603  #if \
604    defined(__has_attribute) && \
605    ( \
606      (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \
607    )
608  #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
609  #else
610  #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
611  #endif
612  #if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
613      #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
614  #endif
615  #if defined(__has_attribute)
616      #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
617  #else
618      #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
619  #endif
620  #if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
621      #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
622  #endif
623  #if defined(__has_attribute)
624      #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
625  #else
626      #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
627  #endif
628  #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
629      #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
630  #endif
631  #if \
632      defined(__has_cpp_attribute) && \
633      defined(__cplusplus) && \
634      (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
635      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
636  #else
637      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
638  #endif
639  #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
640      #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
641  #endif
642  #if !defined(__cplusplus) || !defined(__has_cpp_attribute)
643      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
644  #elif \
645      !defined(JSON_HEDLEY_PGI_VERSION) && \
646      !defined(JSON_HEDLEY_IAR_VERSION) && \
647      (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
648      (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
649      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
650  #else
651      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
652  #endif
653  #if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
654      #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
655  #endif
656  #if defined(__has_cpp_attribute) && defined(__cplusplus)
657      #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
658  #else
659      #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
660  #endif
661  #if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
662      #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
663  #endif
664  #if defined(__has_cpp_attribute) && defined(__cplusplus)
665      #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
666  #else
667      #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
668  #endif
669  #if defined(JSON_HEDLEY_HAS_BUILTIN)
670      #undef JSON_HEDLEY_HAS_BUILTIN
671  #endif
672  #if defined(__has_builtin)
673      #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
674  #else
675      #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
676  #endif
677  #if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
678      #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
679  #endif
680  #if defined(__has_builtin)
681      #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
682  #else
683      #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
684  #endif
685  #if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
686      #undef JSON_HEDLEY_GCC_HAS_BUILTIN
687  #endif
688  #if defined(__has_builtin)
689      #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
690  #else
691      #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
692  #endif
693  #if defined(JSON_HEDLEY_HAS_FEATURE)
694      #undef JSON_HEDLEY_HAS_FEATURE
695  #endif
696  #if defined(__has_feature)
697      #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
698  #else
699      #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
700  #endif
701  #if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
702      #undef JSON_HEDLEY_GNUC_HAS_FEATURE
703  #endif
704  #if defined(__has_feature)
705      #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
706  #else
707      #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
708  #endif
709  #if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
710      #undef JSON_HEDLEY_GCC_HAS_FEATURE
711  #endif
712  #if defined(__has_feature)
713      #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
714  #else
715      #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
716  #endif
717  #if defined(JSON_HEDLEY_HAS_EXTENSION)
718      #undef JSON_HEDLEY_HAS_EXTENSION
719  #endif
720  #if defined(__has_extension)
721      #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
722  #else
723      #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
724  #endif
725  #if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
726      #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
727  #endif
728  #if defined(__has_extension)
729      #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
730  #else
731      #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
732  #endif
733  #if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
734      #undef JSON_HEDLEY_GCC_HAS_EXTENSION
735  #endif
736  #if defined(__has_extension)
737      #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
738  #else
739      #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
740  #endif
741  #if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
742      #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
743  #endif
744  #if defined(__has_declspec_attribute)
745      #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
746  #else
747      #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
748  #endif
749  #if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
750      #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
751  #endif
752  #if defined(__has_declspec_attribute)
753      #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
754  #else
755      #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
756  #endif
757  #if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
758      #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
759  #endif
760  #if defined(__has_declspec_attribute)
761      #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
762  #else
763      #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
764  #endif
765  #if defined(JSON_HEDLEY_HAS_WARNING)
766      #undef JSON_HEDLEY_HAS_WARNING
767  #endif
768  #if defined(__has_warning)
769      #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
770  #else
771      #define JSON_HEDLEY_HAS_WARNING(warning) (0)
772  #endif
773  #if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
774      #undef JSON_HEDLEY_GNUC_HAS_WARNING
775  #endif
776  #if defined(__has_warning)
777      #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
778  #else
779      #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
780  #endif
781  #if defined(JSON_HEDLEY_GCC_HAS_WARNING)
782      #undef JSON_HEDLEY_GCC_HAS_WARNING
783  #endif
784  #if defined(__has_warning)
785      #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
786  #else
787      #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
788  #endif
789  #if \
790      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
791      defined(__clang__) || \
792      JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
793      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
794      JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
795      JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
796      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
797      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
798      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
799      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
800      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
801      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
802      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
803      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
804      JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
805      JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
806      JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
807      (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
808      #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
809  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
810      #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
811  #else
812      #define JSON_HEDLEY_PRAGMA(value)
813  #endif
814  #if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
815      #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
816  #endif
817  #if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
818      #undef JSON_HEDLEY_DIAGNOSTIC_POP
819  #endif
820  #if defined(__clang__)
821      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
822      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
823  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
824      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
825      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
826  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
827      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
828      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
829  #elif \
830      JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
831      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
832      #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
833      #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
834  #elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
835      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
836      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
837  #elif \
838      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
839      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
840      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
841      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
842      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
843      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
844      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
845      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
846  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
847      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
848      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
849  #else
850      #define JSON_HEDLEY_DIAGNOSTIC_PUSH
851      #define JSON_HEDLEY_DIAGNOSTIC_POP
852  #endif
853  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
854      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
855  #endif
856  #if defined(__cplusplus)
857  #  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat")
858  #    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions")
859  #      if JSON_HEDLEY_HAS_WARNING("-Wc++1z-extensions")
860  #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
861      JSON_HEDLEY_DIAGNOSTIC_PUSH \
862      _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
863      _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
864      _Pragma("clang diagnostic ignored \"-Wc++1z-extensions\"") \
865      xpr \
866      JSON_HEDLEY_DIAGNOSTIC_POP
867  #      else
868  #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
869      JSON_HEDLEY_DIAGNOSTIC_PUSH \
870      _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
871      _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
872      xpr \
873      JSON_HEDLEY_DIAGNOSTIC_POP
874  #      endif
875  #    else
876  #      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
877      JSON_HEDLEY_DIAGNOSTIC_PUSH \
878      _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
879      xpr \
880      JSON_HEDLEY_DIAGNOSTIC_POP
881  #    endif
882  #  endif
883  #endif
884  #if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
885      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
886  #endif
887  #if defined(JSON_HEDLEY_CONST_CAST)
888      #undef JSON_HEDLEY_CONST_CAST
889  #endif
890  #if defined(__cplusplus)
891  #  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
892  #elif \
893    JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
894    JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
895    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
896  #  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
897          JSON_HEDLEY_DIAGNOSTIC_PUSH \
898          JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
899          ((T) (expr)); \
900          JSON_HEDLEY_DIAGNOSTIC_POP \
901      }))
902  #else
903  #  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
904  #endif
905  #if defined(JSON_HEDLEY_REINTERPRET_CAST)
906      #undef JSON_HEDLEY_REINTERPRET_CAST
907  #endif
908  #if defined(__cplusplus)
909      #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
910  #else
911      #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
912  #endif
913  #if defined(JSON_HEDLEY_STATIC_CAST)
914      #undef JSON_HEDLEY_STATIC_CAST
915  #endif
916  #if defined(__cplusplus)
917      #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
918  #else
919      #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
920  #endif
921  #if defined(JSON_HEDLEY_CPP_CAST)
922      #undef JSON_HEDLEY_CPP_CAST
923  #endif
924  #if defined(__cplusplus)
925  #  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast")
926  #    define JSON_HEDLEY_CPP_CAST(T, expr) \
927      JSON_HEDLEY_DIAGNOSTIC_PUSH \
928      _Pragma("clang diagnostic ignored \"-Wold-style-cast\"") \
929      ((T) (expr)) \
930      JSON_HEDLEY_DIAGNOSTIC_POP
931  #  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
932  #    define JSON_HEDLEY_CPP_CAST(T, expr) \
933      JSON_HEDLEY_DIAGNOSTIC_PUSH \
934      _Pragma("diag_suppress=Pe137") \
935      JSON_HEDLEY_DIAGNOSTIC_POP
936  #  else
937  #    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
938  #  endif
939  #else
940  #  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
941  #endif
942  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
943      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
944  #endif
945  #if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
946      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
947  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
948      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
949  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
950      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))
951  #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
952      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1216,1444,1445")
953  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
954      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
955  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
956      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
957  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
958      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
959  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
960      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
961  #elif \
962      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
963      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
964      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
965      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
966      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
967      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
968      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
969      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
970      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
971      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
972      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
973      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
974  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
975      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
976  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
977      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
978  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
979      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
980  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
981      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
982  #else
983      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
984  #endif
985  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
986      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
987  #endif
988  #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
989      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
990  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
991      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
992  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
993      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))
994  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
995      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
996  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
997      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
998  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
999      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
1000  #elif \
1001      JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
1002      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
1003      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1004      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
1005      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
1006  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
1007      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
1008  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1009      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
1010  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1011      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 161")
1012  #else
1013      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
1014  #endif
1015  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
1016      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
1017  #endif
1018  #if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes")
1019      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
1020  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
1021      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
1022  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
1023      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)")
1024  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1025      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))
1026  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
1027      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
1028  #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
1029      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097,1098")
1030  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
1031      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
1032  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)
1033      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)")
1034  #elif \
1035      JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
1036      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
1037      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
1038      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173")
1039  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1040      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097")
1041  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1042      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
1043  #else
1044      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
1045  #endif
1046  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
1047      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
1048  #endif
1049  #if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
1050      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
1051  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1052      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
1053  #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
1054      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
1055  #else
1056      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
1057  #endif
1058  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)
1059      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
1060  #endif
1061  #if JSON_HEDLEY_HAS_WARNING("-Wunused-function")
1062      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("clang diagnostic ignored \"-Wunused-function\"")
1063  #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)
1064      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("GCC diagnostic ignored \"-Wunused-function\"")
1065  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)
1066      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))
1067  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1068      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("diag_suppress 3142")
1069  #else
1070      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
1071  #endif
1072  #if defined(JSON_HEDLEY_DEPRECATED)
1073      #undef JSON_HEDLEY_DEPRECATED
1074  #endif
1075  #if defined(JSON_HEDLEY_DEPRECATED_FOR)
1076      #undef JSON_HEDLEY_DEPRECATED_FOR
1077  #endif
1078  #if \
1079      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1080      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1081      #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
1082      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
1083  #elif \
1084      (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
1085      JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
1086      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1087      JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
1088      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
1089      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1090      JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
1091      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
1092      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
1093      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1094      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \
1095      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1096      #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
1097      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
1098  #elif defined(__cplusplus) && (__cplusplus >= 201402L)
1099      #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since)]])
1100      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since "; use " #replacement)]])
1101  #elif \
1102      JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
1103      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1104      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1105      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1106      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1107      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1108      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1109      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1110      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1111      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1112      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1113      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1114      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1115      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1116      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1117      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1118      #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
1119      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
1120  #elif \
1121      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1122      JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \
1123      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1124      #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
1125      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
1126  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1127      #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
1128      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
1129  #else
1130      #define JSON_HEDLEY_DEPRECATED(since)
1131      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
1132  #endif
1133  #if defined(JSON_HEDLEY_UNAVAILABLE)
1134      #undef JSON_HEDLEY_UNAVAILABLE
1135  #endif
1136  #if \
1137      JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
1138      JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
1139      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1140      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1141      #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
1142  #else
1143      #define JSON_HEDLEY_UNAVAILABLE(available_since)
1144  #endif
1145  #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
1146      #undef JSON_HEDLEY_WARN_UNUSED_RESULT
1147  #endif
1148  #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
1149      #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
1150  #endif
1151  #if \
1152      JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
1153      JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1154      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1155      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1156      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1157      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1158      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1159      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1160      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1161      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1162      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1163      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1164      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1165      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1166      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
1167      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1168      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1169      #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
1170      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
1171  #elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
1172      #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1173      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
1174  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
1175      #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1176      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1177  #elif defined(_Check_return_) &bsol;* SAL */
1178      #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
1179      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
1180  #else
1181      #define JSON_HEDLEY_WARN_UNUSED_RESULT
1182      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
1183  #endif
1184  #if defined(JSON_HEDLEY_SENTINEL)
1185      #undef JSON_HEDLEY_SENTINEL
1186  #endif
1187  #if \
1188      JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
1189      JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1190      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1191      JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
1192      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1193      #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
1194  #else
1195      #define JSON_HEDLEY_SENTINEL(position)
1196  #endif
1197  #if defined(JSON_HEDLEY_NO_RETURN)
1198      #undef JSON_HEDLEY_NO_RETURN
1199  #endif
1200  #if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1201      #define JSON_HEDLEY_NO_RETURN __noreturn
1202  #elif \
1203      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1204      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1205      #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
1206  #elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
1207      #define JSON_HEDLEY_NO_RETURN _Noreturn
1208  #elif defined(__cplusplus) && (__cplusplus >= 201103L)
1209      #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
1210  #elif \
1211      JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
1212      JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
1213      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1214      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1215      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1216      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1217      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1218      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1219      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1220      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1221      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1222      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1223      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1224      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1225      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1226      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1227      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1228      #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
1229  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1230      #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return")
1231  #elif \
1232      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1233      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1234      #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
1235  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
1236      #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
1237  #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
1238      #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
1239  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
1240      #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
1241  #else
1242      #define JSON_HEDLEY_NO_RETURN
1243  #endif
1244  #if defined(JSON_HEDLEY_NO_ESCAPE)
1245      #undef JSON_HEDLEY_NO_ESCAPE
1246  #endif
1247  #if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
1248      #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
1249  #else
1250      #define JSON_HEDLEY_NO_ESCAPE
1251  #endif
1252  #if defined(JSON_HEDLEY_UNREACHABLE)
1253      #undef JSON_HEDLEY_UNREACHABLE
1254  #endif
1255  #if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
1256      #undef JSON_HEDLEY_UNREACHABLE_RETURN
1257  #endif
1258  #if defined(JSON_HEDLEY_ASSUME)
1259      #undef JSON_HEDLEY_ASSUME
1260  #endif
1261  #if \
1262      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1263      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1264      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1265      #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
1266  #elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
1267      #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
1268  #elif \
1269      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1270      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
1271      #if defined(__cplusplus)
1272          #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
1273      #else
1274          #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
1275      #endif
1276  #endif
1277  #if \
1278      (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
1279      JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
1280      JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
1281      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1282      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \
1283      JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \
1284      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1285      #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
1286  #elif defined(JSON_HEDLEY_ASSUME)
1287      #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
1288  #endif
1289  #if !defined(JSON_HEDLEY_ASSUME)
1290      #if defined(JSON_HEDLEY_UNREACHABLE)
1291          #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
1292      #else
1293          #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
1294      #endif
1295  #endif
1296  #if defined(JSON_HEDLEY_UNREACHABLE)
1297      #if  \
1298          JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1299          JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
1300          #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
1301      #else
1302          #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
1303      #endif
1304  #else
1305      #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
1306  #endif
1307  #if !defined(JSON_HEDLEY_UNREACHABLE)
1308      #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
1309  #endif
1310  JSON_HEDLEY_DIAGNOSTIC_PUSH
1311  #if JSON_HEDLEY_HAS_WARNING("-Wpedantic")
1312      #pragma clang diagnostic ignored "-Wpedantic"
1313  #endif
1314  #if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
1315      #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
1316  #endif
1317  #if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros",4,0,0)
1318      #if defined(__clang__)
1319          #pragma clang diagnostic ignored "-Wvariadic-macros"
1320      #elif defined(JSON_HEDLEY_GCC_VERSION)
1321          #pragma GCC diagnostic ignored "-Wvariadic-macros"
1322      #endif
1323  #endif
1324  #if defined(JSON_HEDLEY_NON_NULL)
1325      #undef JSON_HEDLEY_NON_NULL
1326  #endif
1327  #if \
1328      JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
1329      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1330      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1331      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
1332      #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
1333  #else
1334      #define JSON_HEDLEY_NON_NULL(...)
1335  #endif
1336  JSON_HEDLEY_DIAGNOSTIC_POP
1337  #if defined(JSON_HEDLEY_PRINTF_FORMAT)
1338      #undef JSON_HEDLEY_PRINTF_FORMAT
1339  #endif
1340  #if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
1341      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
1342  #elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
1343      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
1344  #elif \
1345      JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
1346      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1347      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1348      JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
1349      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1350      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1351      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1352      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1353      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1354      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1355      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1356      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1357      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1358      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1359      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1360      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1361      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1362      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
1363  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
1364      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
1365  #else
1366      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
1367  #endif
1368  #if defined(JSON_HEDLEY_CONSTEXPR)
1369      #undef JSON_HEDLEY_CONSTEXPR
1370  #endif
1371  #if defined(__cplusplus)
1372      #if __cplusplus >= 201103L
1373          #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
1374      #endif
1375  #endif
1376  #if !defined(JSON_HEDLEY_CONSTEXPR)
1377      #define JSON_HEDLEY_CONSTEXPR
1378  #endif
1379  #if defined(JSON_HEDLEY_PREDICT)
1380      #undef JSON_HEDLEY_PREDICT
1381  #endif
1382  #if defined(JSON_HEDLEY_LIKELY)
1383      #undef JSON_HEDLEY_LIKELY
1384  #endif
1385  #if defined(JSON_HEDLEY_UNLIKELY)
1386      #undef JSON_HEDLEY_UNLIKELY
1387  #endif
1388  #if defined(JSON_HEDLEY_UNPREDICTABLE)
1389      #undef JSON_HEDLEY_UNPREDICTABLE
1390  #endif
1391  #if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
1392      #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
1393  #endif
1394  #if \
1395    (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) && !defined(JSON_HEDLEY_PGI_VERSION)) || \
1396    JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \
1397    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1398  #  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
1399  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
1400  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
1401  #  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
1402  #  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
1403  #elif \
1404    (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
1405    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
1406    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1407    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
1408    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1409    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1410    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1411    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
1412    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
1413    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
1414    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1415    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1416    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1417    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
1418    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1419    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1420  #  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
1421      (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
1422  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
1423      (__extension__ ({ \
1424          double hedley_probability_ = (probability); \
1425          ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
1426      }))
1427  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
1428      (__extension__ ({ \
1429          double hedley_probability_ = (probability); \
1430          ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
1431      }))
1432  #  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
1433  #  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
1434  #else
1435  #  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
1436  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
1437  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
1438  #  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
1439  #  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
1440  #endif
1441  #if !defined(JSON_HEDLEY_UNPREDICTABLE)
1442      #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
1443  #endif
1444  #if defined(JSON_HEDLEY_MALLOC)
1445      #undef JSON_HEDLEY_MALLOC
1446  #endif
1447  #if \
1448      JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
1449      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1450      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1451      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1452      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1453      JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
1454      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1455      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1456      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1457      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1458      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1459      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1460      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1461      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1462      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1463      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1464      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1465      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1466      #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
1467  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1468      #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory")
1469  #elif \
1470      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1471      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1472      #define JSON_HEDLEY_MALLOC __declspec(restrict)
1473  #else
1474      #define JSON_HEDLEY_MALLOC
1475  #endif
1476  #if defined(JSON_HEDLEY_PURE)
1477      #undef JSON_HEDLEY_PURE
1478  #endif
1479  #if \
1480    JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
1481    JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
1482    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1483    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1484    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1485    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1486    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1487    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1488    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1489    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1490    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1491    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1492    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1493    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1494    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1495    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1496    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1497    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1498    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1499  #  define JSON_HEDLEY_PURE __attribute__((__pure__))
1500  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1501  #  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data")
1502  #elif defined(__cplusplus) && \
1503      ( \
1504        JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
1505        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
1506        JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
1507      )
1508  #  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
1509  #else
1510  #  define JSON_HEDLEY_PURE
1511  #endif
1512  #if defined(JSON_HEDLEY_CONST)
1513      #undef JSON_HEDLEY_CONST
1514  #endif
1515  #if \
1516      JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
1517      JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
1518      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1519      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1520      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1521      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1522      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1523      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1524      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1525      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1526      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1527      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1528      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1529      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1530      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1531      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1532      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1533      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1534      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1535      #define JSON_HEDLEY_CONST __attribute__((__const__))
1536  #elif \
1537      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1538      #define JSON_HEDLEY_CONST _Pragma("no_side_effect")
1539  #else
1540      #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
1541  #endif
1542  #if defined(JSON_HEDLEY_RESTRICT)
1543      #undef JSON_HEDLEY_RESTRICT
1544  #endif
1545  #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
1546      #define JSON_HEDLEY_RESTRICT restrict
1547  #elif \
1548      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1549      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1550      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1551      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1552      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1553      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1554      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1555      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1556      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
1557      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
1558      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1559      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
1560      JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
1561      defined(__clang__) || \
1562      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1563      #define JSON_HEDLEY_RESTRICT __restrict
1564  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
1565      #define JSON_HEDLEY_RESTRICT _Restrict
1566  #else
1567      #define JSON_HEDLEY_RESTRICT
1568  #endif
1569  #if defined(JSON_HEDLEY_INLINE)
1570      #undef JSON_HEDLEY_INLINE
1571  #endif
1572  #if \
1573      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
1574      (defined(__cplusplus) && (__cplusplus >= 199711L))
1575      #define JSON_HEDLEY_INLINE inline
1576  #elif \
1577      defined(JSON_HEDLEY_GCC_VERSION) || \
1578      JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
1579      #define JSON_HEDLEY_INLINE __inline__
1580  #elif \
1581      JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
1582      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1583      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1584      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
1585      JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
1586      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1587      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
1588      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1589      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1590      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1591      #define JSON_HEDLEY_INLINE __inline
1592  #else
1593      #define JSON_HEDLEY_INLINE
1594  #endif
1595  #if defined(JSON_HEDLEY_ALWAYS_INLINE)
1596      #undef JSON_HEDLEY_ALWAYS_INLINE
1597  #endif
1598  #if \
1599    JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
1600    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1601    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1602    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1603    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1604    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1605    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1606    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1607    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1608    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1609    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1610    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1611    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1612    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1613    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1614    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1615    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1616    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1617    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1618  #  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
1619  #elif \
1620    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
1621    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1622  #  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
1623  #elif defined(__cplusplus) && \
1624      ( \
1625        JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1626        JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1627        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1628        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1629        JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1630        JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
1631      )
1632  #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
1633  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1634  #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
1635  #else
1636  #  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
1637  #endif
1638  #if defined(JSON_HEDLEY_NEVER_INLINE)
1639      #undef JSON_HEDLEY_NEVER_INLINE
1640  #endif
1641  #if \
1642      JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
1643      JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1644      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1645      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1646      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1647      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1648      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1649      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1650      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1651      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1652      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1653      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1654      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1655      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1656      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1657      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1658      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1659      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1660      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1661      #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
1662  #elif \
1663      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1664      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1665      #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
1666  #elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
1667      #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
1668  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
1669      #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
1670  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1671      #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
1672  #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
1673      #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
1674  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
1675      #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
1676  #else
1677      #define JSON_HEDLEY_NEVER_INLINE
1678  #endif
1679  #if defined(JSON_HEDLEY_PRIVATE)
1680      #undef JSON_HEDLEY_PRIVATE
1681  #endif
1682  #if defined(JSON_HEDLEY_PUBLIC)
1683      #undef JSON_HEDLEY_PUBLIC
1684  #endif
1685  #if defined(JSON_HEDLEY_IMPORT)
1686      #undef JSON_HEDLEY_IMPORT
1687  #endif
1688  #if defined(_WIN32) || defined(__CYGWIN__)
1689  #  define JSON_HEDLEY_PRIVATE
1690  #  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
1691  #  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
1692  #else
1693  #  if \
1694      JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
1695      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1696      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1697      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1698      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1699      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1700      ( \
1701        defined(__TI_EABI__) && \
1702        ( \
1703          (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1704          JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
1705        ) \
1706      ) || \
1707      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1708  #    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
1709  #    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
1710  #  else
1711  #    define JSON_HEDLEY_PRIVATE
1712  #    define JSON_HEDLEY_PUBLIC
1713  #  endif
1714  #  define JSON_HEDLEY_IMPORT    extern
1715  #endif
1716  #if defined(JSON_HEDLEY_NO_THROW)
1717      #undef JSON_HEDLEY_NO_THROW
1718  #endif
1719  #if \
1720      JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
1721      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1722      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1723      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1724      #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
1725  #elif \
1726      JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
1727      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1728      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
1729      #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
1730  #else
1731      #define JSON_HEDLEY_NO_THROW
1732  #endif
1733  #if defined(JSON_HEDLEY_FALL_THROUGH)
1734      #undef JSON_HEDLEY_FALL_THROUGH
1735  #endif
1736  #if \
1737      JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
1738      JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \
1739      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1740      #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
1741  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
1742      #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
1743  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
1744      #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
1745  #elif defined(__fallthrough) &bsol;* SAL */
1746      #define JSON_HEDLEY_FALL_THROUGH __fallthrough
1747  #else
1748      #define JSON_HEDLEY_FALL_THROUGH
1749  #endif
1750  #if defined(JSON_HEDLEY_RETURNS_NON_NULL)
1751      #undef JSON_HEDLEY_RETURNS_NON_NULL
1752  #endif
1753  #if \
1754      JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
1755      JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
1756      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1757      #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
1758  #elif defined(_Ret_notnull_) &bsol;* SAL */
1759      #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
1760  #else
1761      #define JSON_HEDLEY_RETURNS_NON_NULL
1762  #endif
1763  #if defined(JSON_HEDLEY_ARRAY_PARAM)
1764      #undef JSON_HEDLEY_ARRAY_PARAM
1765  #endif
1766  #if \
1767      defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
1768      !defined(__STDC_NO_VLA__) && \
1769      !defined(__cplusplus) && \
1770      !defined(JSON_HEDLEY_PGI_VERSION) && \
1771      !defined(JSON_HEDLEY_TINYC_VERSION)
1772      #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
1773  #else
1774      #define JSON_HEDLEY_ARRAY_PARAM(name)
1775  #endif
1776  #if defined(JSON_HEDLEY_IS_CONSTANT)
1777      #undef JSON_HEDLEY_IS_CONSTANT
1778  #endif
1779  #if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
1780      #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
1781  #endif
1782  #if defined(JSON_HEDLEY_IS_CONSTEXPR_)
1783      #undef JSON_HEDLEY_IS_CONSTEXPR_
1784  #endif
1785  #if \
1786      JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
1787      JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1788      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1789      JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
1790      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1791      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1792      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1793      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \
1794      JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1795      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1796      #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
1797  #endif
1798  #if !defined(__cplusplus)
1799  #  if \
1800         JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
1801         JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1802         JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1803         JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1804         JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1805         JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
1806         JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
1807  #if defined(__INTPTR_TYPE__)
1808      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
1809  #else
1810      #include <stdint.h>
1811      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
1812  #endif
1813  #  elif \
1814         ( \
1815            defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
1816            !defined(JSON_HEDLEY_SUNPRO_VERSION) && \
1817            !defined(JSON_HEDLEY_PGI_VERSION) && \
1818            !defined(JSON_HEDLEY_IAR_VERSION)) || \
1819         (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
1820         JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
1821         JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
1822         JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
1823         JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
1824  #if defined(__INTPTR_TYPE__)
1825      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
1826  #else
1827      #include <stdint.h>
1828      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
1829  #endif
1830  #  elif \
1831         defined(JSON_HEDLEY_GCC_VERSION) || \
1832         defined(JSON_HEDLEY_INTEL_VERSION) || \
1833         defined(JSON_HEDLEY_TINYC_VERSION) || \
1834         defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
1835         JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
1836         defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
1837         defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
1838         defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
1839         defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
1840         defined(__clang__)
1841  #    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
1842          sizeof(void) != \
1843          sizeof(*( \
1844                    1 ? \
1845                    ((void*) ((expr) * 0L) ) : \
1846  ((struct { char v[sizeof(void) * 2]; } *) 1) \
1847                  ) \
1848                ) \
1849                                              )
1850  #  endif
1851  #endif
1852  #if defined(JSON_HEDLEY_IS_CONSTEXPR_)
1853      #if !defined(JSON_HEDLEY_IS_CONSTANT)
1854          #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
1855      #endif
1856      #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
1857  #else
1858      #if !defined(JSON_HEDLEY_IS_CONSTANT)
1859          #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
1860      #endif
1861      #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
1862  #endif
1863  #if defined(JSON_HEDLEY_BEGIN_C_DECLS)
1864      #undef JSON_HEDLEY_BEGIN_C_DECLS
1865  #endif
1866  #if defined(JSON_HEDLEY_END_C_DECLS)
1867      #undef JSON_HEDLEY_END_C_DECLS
1868  #endif
1869  #if defined(JSON_HEDLEY_C_DECL)
1870      #undef JSON_HEDLEY_C_DECL
1871  #endif
1872  #if defined(__cplusplus)
1873      #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
1874      #define JSON_HEDLEY_END_C_DECLS }
1875      #define JSON_HEDLEY_C_DECL extern "C"
1876  #else
1877      #define JSON_HEDLEY_BEGIN_C_DECLS
1878      #define JSON_HEDLEY_END_C_DECLS
1879      #define JSON_HEDLEY_C_DECL
1880  #endif
1881  #if defined(JSON_HEDLEY_STATIC_ASSERT)
1882      #undef JSON_HEDLEY_STATIC_ASSERT
1883  #endif
1884  #if \
1885    !defined(__cplusplus) && ( \
1886        (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
1887        (JSON_HEDLEY_HAS_FEATURE(c_static_assert) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
1888        JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
1889        JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1890        defined(_Static_assert) \
1891      )
1892  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
1893  #elif \
1894    (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
1895    JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
1896    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1897  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
1898  #else
1899  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
1900  #endif
1901  #if defined(JSON_HEDLEY_NULL)
1902      #undef JSON_HEDLEY_NULL
1903  #endif
1904  #if defined(__cplusplus)
1905      #if __cplusplus >= 201103L
1906          #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
1907      #elif defined(NULL)
1908          #define JSON_HEDLEY_NULL NULL
1909      #else
1910          #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
1911      #endif
1912  #elif defined(NULL)
1913      #define JSON_HEDLEY_NULL NULL
1914  #else
1915      #define JSON_HEDLEY_NULL ((void*) 0)
1916  #endif
1917  #if defined(JSON_HEDLEY_MESSAGE)
1918      #undef JSON_HEDLEY_MESSAGE
1919  #endif
1920  #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
1921  #  define JSON_HEDLEY_MESSAGE(msg) \
1922      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1923      JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
1924      JSON_HEDLEY_PRAGMA(message msg) \
1925      JSON_HEDLEY_DIAGNOSTIC_POP
1926  #elif \
1927    JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
1928    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1929  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
1930  #elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
1931  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
1932  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1933  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
1934  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
1935  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
1936  #else
1937  #  define JSON_HEDLEY_MESSAGE(msg)
1938  #endif
1939  #if defined(JSON_HEDLEY_WARNING)
1940      #undef JSON_HEDLEY_WARNING
1941  #endif
1942  #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
1943  #  define JSON_HEDLEY_WARNING(msg) \
1944      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1945      JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
1946      JSON_HEDLEY_PRAGMA(clang warning msg) \
1947      JSON_HEDLEY_DIAGNOSTIC_POP
1948  #elif \
1949    JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
1950    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
1951    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1952  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
1953  #elif \
1954    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
1955    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1956  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
1957  #else
1958  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
1959  #endif
1960  #if defined(JSON_HEDLEY_REQUIRE)
1961      #undef JSON_HEDLEY_REQUIRE
1962  #endif
1963  #if defined(JSON_HEDLEY_REQUIRE_MSG)
1964      #undef JSON_HEDLEY_REQUIRE_MSG
1965  #endif
1966  #if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
1967  #  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
1968  #    define JSON_HEDLEY_REQUIRE(expr) \
1969      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1970      _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
1971      __attribute__((diagnose_if(!(expr), #expr, "error"))) \
1972      JSON_HEDLEY_DIAGNOSTIC_POP
1973  #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
1974      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1975      _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
1976      __attribute__((diagnose_if(!(expr), msg, "error"))) \
1977      JSON_HEDLEY_DIAGNOSTIC_POP
1978  #  else
1979  #    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error")))
1980  #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error")))
1981  #  endif
1982  #else
1983  #  define JSON_HEDLEY_REQUIRE(expr)
1984  #  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
1985  #endif
1986  #if defined(JSON_HEDLEY_FLAGS)
1987      #undef JSON_HEDLEY_FLAGS
1988  #endif
1989  #if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) && (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING("-Wbitfield-enum-conversion"))
1990      #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
1991  #else
1992      #define JSON_HEDLEY_FLAGS
1993  #endif
1994  #if defined(JSON_HEDLEY_FLAGS_CAST)
1995      #undef JSON_HEDLEY_FLAGS_CAST
1996  #endif
1997  #if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
1998  #  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
1999          JSON_HEDLEY_DIAGNOSTIC_PUSH \
2000          _Pragma("warning(disable:188)") \
2001          ((T) (expr)); \
2002          JSON_HEDLEY_DIAGNOSTIC_POP \
2003      }))
2004  #else
2005  #  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
2006  #endif
2007  #if defined(JSON_HEDLEY_EMPTY_BASES)
2008      #undef JSON_HEDLEY_EMPTY_BASES
2009  #endif
2010  #if \
2011      (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \
2012      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
2013      #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
2014  #else
2015      #define JSON_HEDLEY_EMPTY_BASES
2016  #endif
2017  #if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
2018      #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
2019  #endif
2020  #if defined(__clang__)
2021      #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
2022  #else
2023      #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
2024  #endif
2025  #if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
2026      #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
2027  #endif
2028  #define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
2029  #if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
2030      #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
2031  #endif
2032  #define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)
2033  #if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
2034      #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
2035  #endif
2036  #define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)
2037  #if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
2038      #undef JSON_HEDLEY_CLANG_HAS_FEATURE
2039  #endif
2040  #define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)
2041  #if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
2042      #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
2043  #endif
2044  #define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)
2045  #if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
2046      #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
2047  #endif
2048  #define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)
2049  #if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
2050      #undef JSON_HEDLEY_CLANG_HAS_WARNING
2051  #endif
2052  #define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)
2053  #endif &bsol;* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */
2054  #if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
2055      #if defined(__clang__)
2056          #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
2057              #error "unsupported Clang version - see https:&bsol;&bsol;github.com/nlohmann/json#supported-compilers"
2058          #endif
2059      #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
2060          #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
2061              #error "unsupported GCC version - see https:&bsol;&bsol;github.com/nlohmann/json#supported-compilers"
2062          #endif
2063      #endif
2064  #endif
2065  #if !defined(JSON_HAS_CPP_20) && !defined(JSON_HAS_CPP_17) && !defined(JSON_HAS_CPP_14) && !defined(JSON_HAS_CPP_11)
2066      #if (defined(__cplusplus) && __cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)
2067          #define JSON_HAS_CPP_20
2068          #define JSON_HAS_CPP_17
2069          #define JSON_HAS_CPP_14
2070      #elif (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) 
2071          #define JSON_HAS_CPP_17
2072          #define JSON_HAS_CPP_14
2073      #elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
2074          #define JSON_HAS_CPP_14
2075      #endif
2076      #define JSON_HAS_CPP_11
2077  #endif
2078  #ifdef __has_include
2079      #if __has_include(<version>)
2080          #include <version>
2081      #endif
2082  #endif
2083  #if !defined(JSON_HAS_FILESYSTEM) && !defined(JSON_HAS_EXPERIMENTAL_FILESYSTEM)
2084      #ifdef JSON_HAS_CPP_17
2085          #if defined(__cpp_lib_filesystem)
2086              #define JSON_HAS_FILESYSTEM 1
2087          #elif defined(__cpp_lib_experimental_filesystem)
2088              #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
2089          #elif !defined(__has_include)
2090              #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
2091          #elif __has_include(<filesystem>)
2092              #define JSON_HAS_FILESYSTEM 1
2093          #elif __has_include(<experimental/filesystem>)
2094              #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
2095          #endif
2096          #if defined(__MINGW32__) && defined(__GNUC__) && __GNUC__ == 8
2097              #undef JSON_HAS_FILESYSTEM
2098              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2099          #endif
2100          #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 8
2101              #undef JSON_HAS_FILESYSTEM
2102              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2103          #endif
2104          #if defined(__clang_major__) && __clang_major__ < 7
2105              #undef JSON_HAS_FILESYSTEM
2106              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2107          #endif
2108          #if defined(_MSC_VER) && _MSC_VER < 1914
2109              #undef JSON_HAS_FILESYSTEM
2110              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2111          #endif
2112          #if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < 130000
2113              #undef JSON_HAS_FILESYSTEM
2114              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2115          #endif
2116          #if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < 101500
2117              #undef JSON_HAS_FILESYSTEM
2118              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2119          #endif
2120      #endif
2121  #endif
2122  #ifndef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2123      #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 0
2124  #endif
2125  #ifndef JSON_HAS_FILESYSTEM
2126      #define JSON_HAS_FILESYSTEM 0
2127  #endif
2128  #ifndef JSON_HAS_THREE_WAY_COMPARISON
2129      #if defined(__cpp_impl_three_way_comparison) && __cpp_impl_three_way_comparison >= 201907L \
2130          && defined(__cpp_lib_three_way_comparison) && __cpp_lib_three_way_comparison >= 201907L
2131          #define JSON_HAS_THREE_WAY_COMPARISON 1
2132      #else
2133          #define JSON_HAS_THREE_WAY_COMPARISON 0
2134      #endif
2135  #endif
2136  #ifndef JSON_HAS_RANGES
2137      #if defined(__GLIBCXX__) && __GLIBCXX__ == 20210427
2138          #define JSON_HAS_RANGES 0
2139      #elif defined(__cpp_lib_ranges)
2140          #define JSON_HAS_RANGES 1
2141      #else
2142          #define JSON_HAS_RANGES 0
2143      #endif
2144  #endif
2145  #ifdef JSON_HAS_CPP_17
2146      #define JSON_INLINE_VARIABLE inline
2147  #else
2148      #define JSON_INLINE_VARIABLE
2149  #endif
2150  #if JSON_HEDLEY_HAS_ATTRIBUTE(no_unique_address)
2151      #define JSON_NO_UNIQUE_ADDRESS [[no_unique_address]]
2152  #else
2153      #define JSON_NO_UNIQUE_ADDRESS
2154  #endif
2155  #if defined(__clang__)
2156      #pragma clang diagnostic push
2157      #pragma clang diagnostic ignored "-Wdocumentation"
2158      #pragma clang diagnostic ignored "-Wdocumentation-unknown-command"
2159  #endif
2160  #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
2161      #define JSON_THROW(exception) throw exception
2162      #define JSON_TRY try
2163      #define JSON_CATCH(exception) catch(exception)
2164      #define JSON_INTERNAL_CATCH(exception) catch(exception)
2165  #else
2166      #include <cstdlib>
2167      #define JSON_THROW(exception) std::abort()
2168      #define JSON_TRY if(true)
2169      #define JSON_CATCH(exception) if(false)
2170      #define JSON_INTERNAL_CATCH(exception) if(false)
2171  #endif
2172  #if defined(JSON_THROW_USER)
2173      #undef JSON_THROW
2174      #define JSON_THROW JSON_THROW_USER
2175  #endif
2176  #if defined(JSON_TRY_USER)
2177      #undef JSON_TRY
2178      #define JSON_TRY JSON_TRY_USER
2179  #endif
2180  #if defined(JSON_CATCH_USER)
2181      #undef JSON_CATCH
2182      #define JSON_CATCH JSON_CATCH_USER
2183      #undef JSON_INTERNAL_CATCH
2184      #define JSON_INTERNAL_CATCH JSON_CATCH_USER
2185  #endif
2186  #if defined(JSON_INTERNAL_CATCH_USER)
2187      #undef JSON_INTERNAL_CATCH
2188      #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
2189  #endif
2190  #if !defined(JSON_ASSERT)
2191      #include <cassert> 
2192      #define JSON_ASSERT(x) assert(x)
2193  #endif
2194  #if defined(JSON_TESTS_PRIVATE)
2195      #define JSON_PRIVATE_UNLESS_TESTED public
2196  #else
2197      #define JSON_PRIVATE_UNLESS_TESTED private
2198  #endif
2199  #define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
2200      template<typename BasicJsonType>                                                            \
2201      inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
2202      {                                                                                           \
2203          static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
2204          static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
2205          auto it = std::find_if(std::begin(m), std::end(m),                                      \
2206                                 [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
2207          {                                                                                       \
2208              return ej_pair.first == e;                                                          \
2209          });                                                                                     \
2210          j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
2211      }                                                                                           \
2212      template<typename BasicJsonType>                                                            \
2213      inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
2214      {                                                                                           \
2215          static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
2216          static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
2217          auto it = std::find_if(std::begin(m), std::end(m),                                      \
2218                                 [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
2219          {                                                                                       \
2220              return ej_pair.second == j;                                                         \
2221          });                                                                                     \
2222          e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
2223      }
2224  #define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
2225      template<template<typename, typename, typename...> class ObjectType,   \
2226               template<typename, typename...> class ArrayType,              \
2227               class StringType, class BooleanType, class NumberIntegerType, \
2228               class NumberUnsignedType, class NumberFloatType,              \
2229               template<typename> class AllocatorType,                       \
2230               template<typename, typename = void> class JSONSerializer,     \
2231               class BinaryType>
2232  #define NLOHMANN_BASIC_JSON_TPL                                            \
2233      basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
2234      NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
2235      AllocatorType, JSONSerializer, BinaryType>
2236  #define NLOHMANN_JSON_EXPAND( x ) x
2237  #define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
2238  #define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
2239          NLOHMANN_JSON_PASTE64, \
2240          NLOHMANN_JSON_PASTE63, \
2241          NLOHMANN_JSON_PASTE62, \
2242          NLOHMANN_JSON_PASTE61, \
2243          NLOHMANN_JSON_PASTE60, \
2244          NLOHMANN_JSON_PASTE59, \
2245          NLOHMANN_JSON_PASTE58, \
2246          NLOHMANN_JSON_PASTE57, \
2247          NLOHMANN_JSON_PASTE56, \
2248          NLOHMANN_JSON_PASTE55, \
2249          NLOHMANN_JSON_PASTE54, \
2250          NLOHMANN_JSON_PASTE53, \
2251          NLOHMANN_JSON_PASTE52, \
2252          NLOHMANN_JSON_PASTE51, \
2253          NLOHMANN_JSON_PASTE50, \
2254          NLOHMANN_JSON_PASTE49, \
2255          NLOHMANN_JSON_PASTE48, \
2256          NLOHMANN_JSON_PASTE47, \
2257          NLOHMANN_JSON_PASTE46, \
2258          NLOHMANN_JSON_PASTE45, \
2259          NLOHMANN_JSON_PASTE44, \
2260          NLOHMANN_JSON_PASTE43, \
2261          NLOHMANN_JSON_PASTE42, \
2262          NLOHMANN_JSON_PASTE41, \
2263          NLOHMANN_JSON_PASTE40, \
2264          NLOHMANN_JSON_PASTE39, \
2265          NLOHMANN_JSON_PASTE38, \
2266          NLOHMANN_JSON_PASTE37, \
2267          NLOHMANN_JSON_PASTE36, \
2268          NLOHMANN_JSON_PASTE35, \
2269          NLOHMANN_JSON_PASTE34, \
2270          NLOHMANN_JSON_PASTE33, \
2271          NLOHMANN_JSON_PASTE32, \
2272          NLOHMANN_JSON_PASTE31, \
2273          NLOHMANN_JSON_PASTE30, \
2274          NLOHMANN_JSON_PASTE29, \
2275          NLOHMANN_JSON_PASTE28, \
2276          NLOHMANN_JSON_PASTE27, \
2277          NLOHMANN_JSON_PASTE26, \
2278          NLOHMANN_JSON_PASTE25, \
2279          NLOHMANN_JSON_PASTE24, \
2280          NLOHMANN_JSON_PASTE23, \
2281          NLOHMANN_JSON_PASTE22, \
2282          NLOHMANN_JSON_PASTE21, \
2283          NLOHMANN_JSON_PASTE20, \
2284          NLOHMANN_JSON_PASTE19, \
2285          NLOHMANN_JSON_PASTE18, \
2286          NLOHMANN_JSON_PASTE17, \
2287          NLOHMANN_JSON_PASTE16, \
2288          NLOHMANN_JSON_PASTE15, \
2289          NLOHMANN_JSON_PASTE14, \
2290          NLOHMANN_JSON_PASTE13, \
2291          NLOHMANN_JSON_PASTE12, \
2292          NLOHMANN_JSON_PASTE11, \
2293          NLOHMANN_JSON_PASTE10, \
2294          NLOHMANN_JSON_PASTE9, \
2295          NLOHMANN_JSON_PASTE8, \
2296          NLOHMANN_JSON_PASTE7, \
2297          NLOHMANN_JSON_PASTE6, \
2298          NLOHMANN_JSON_PASTE5, \
2299          NLOHMANN_JSON_PASTE4, \
2300          NLOHMANN_JSON_PASTE3, \
2301          NLOHMANN_JSON_PASTE2, \
2302          NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
2303  #define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
2304  #define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
2305  #define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
2306  #define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
2307  #define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
2308  #define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
2309  #define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
2310  #define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
2311  #define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
2312  #define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
2313  #define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
2314  #define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
2315  #define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
2316  #define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
2317  #define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
2318  #define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
2319  #define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
2320  #define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
2321  #define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
2322  #define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
2323  #define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
2324  #define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
2325  #define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
2326  #define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
2327  #define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
2328  #define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
2329  #define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
2330  #define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
2331  #define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
2332  #define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
2333  #define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
2334  #define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
2335  #define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
2336  #define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
2337  #define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
2338  #define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
2339  #define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
2340  #define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
2341  #define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
2342  #define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
2343  #define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
2344  #define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
2345  #define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
2346  #define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
2347  #define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
2348  #define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
2349  #define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
2350  #define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
2351  #define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
2352  #define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
2353  #define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
2354  #define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
2355  #define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
2356  #define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
2357  #define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
2358  #define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
2359  #define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
2360  #define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
2361  #define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
2362  #define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
2363  #define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
2364  #define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
2365  #define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)
2366  #define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
2367  #define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);
2368  #define NLOHMANN_JSON_FROM_WITH_DEFAULT(v1) nlohmann_json_t.v1 = nlohmann_json_j.value(#v1, nlohmann_json_default_obj.v1);
2369  #define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
2370      friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2371      friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
2372  #define NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
2373      friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2374      friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { Type nlohmann_json_default_obj; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }
2375  #define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
2376      inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2377      inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
2378  #define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
2379      inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2380      inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { Type nlohmann_json_default_obj; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }
2381  #define NLOHMANN_CAN_CALL_STD_FUNC_IMPL(std_name)                                 \
2382      namespace detail {                                                            \
2383      using std::std_name;                                                          \
2384      \
2385      template<typename... T>                                                       \
2386      using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
2387      }                                                                             \
2388      \
2389      namespace detail2 {                                                           \
2390      struct std_name##_tag                                                         \
2391      {                                                                             \
2392      };                                                                            \
2393      \
2394      template<typename... T>                                                       \
2395      std_name##_tag std_name(T&&...);                                              \
2396      \
2397      template<typename... T>                                                       \
2398      using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
2399      \
2400      template<typename... T>                                                       \
2401      struct would_call_std_##std_name                                              \
2402      {                                                                             \
2403          static constexpr auto const value = ::nlohmann::detail::                  \
2404                                              is_detected_exact<std_name##_tag, result_of_##std_name, T...>::value; \
2405      };                                                                            \
2406      } &bsol;* namespace detail2 */ \
2407      \
2408      template<typename... T>                                                       \
2409      struct would_call_std_##std_name : detail2::would_call_std_##std_name<T...>   \
2410      {                                                                             \
2411      }
2412  #ifndef JSON_USE_IMPLICIT_CONVERSIONS
2413      #define JSON_USE_IMPLICIT_CONVERSIONS 1
2414  #endif
2415  #if JSON_USE_IMPLICIT_CONVERSIONS
2416      #define JSON_EXPLICIT
2417  #else
2418      #define JSON_EXPLICIT explicit
2419  #endif
2420  #ifndef JSON_DISABLE_ENUM_SERIALIZATION
2421      #define JSON_DISABLE_ENUM_SERIALIZATION 0
2422  #endif
2423  #ifndef JSON_USE_GLOBAL_UDLS
2424      #define JSON_USE_GLOBAL_UDLS 1
2425  #endif
2426  #if JSON_HAS_THREE_WAY_COMPARISON
2427      #include <compare> 
2428  #endif
2429  NLOHMANN_JSON_NAMESPACE_BEGIN
2430  namespace detail
2431  {
2432  enum class value_t : std::uint8_t
2433  {
2434      null,             
2435      object,           
2436      array,            
2437      string,           
2438      boolean,          
2439      number_integer,   
2440      number_unsigned,  
2441      number_float,     
2442      binary,           
2443      discarded         
2444  };
2445  #if JSON_HAS_THREE_WAY_COMPARISON
2446      inline std::partial_ordering operator<=>(const value_t lhs, const value_t rhs) noexcept 
2447  #else
2448      inline bool operator<(const value_t lhs, const value_t rhs) noexcept
2449  #endif
2450  {
2451      static constexpr std::array<std::uint8_t, 9> order = {{
2452              0 &bsol;* null */, 3 &bsol;* object */, 4 &bsol;* array */, 5 &bsol;* string */,
2453              1 &bsol;* boolean */, 2 &bsol;* integer */, 2 &bsol;* unsigned */, 2 &bsol;* float */,
2454              6 &bsol;* binary */
2455          }
2456      };
2457      const auto l_index = static_cast<std::size_t>(lhs);
2458      const auto r_index = static_cast<std::size_t>(rhs);
2459  #if JSON_HAS_THREE_WAY_COMPARISON
2460      if (l_index < order.size() && r_index < order.size())
2461      {
2462          return order[l_index] <=> order[r_index]; 
2463      }
2464      return std::partial_ordering::unordered;
2465  #else
2466      return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];
2467  #endif
2468  }
2469  #if JSON_HAS_THREE_WAY_COMPARISON && defined(__GNUC__)
2470  inline bool operator<(const value_t lhs, const value_t rhs) noexcept
2471  {
2472      return std::is_lt(lhs <=> rhs); 
2473  }
2474  #endif
2475  }  
2476  NLOHMANN_JSON_NAMESPACE_END
2477  NLOHMANN_JSON_NAMESPACE_BEGIN
2478  namespace detail
2479  {
2480  template<typename StringType>
2481  inline void replace_substring(StringType& s, const StringType& f,
2482                                const StringType& t)
2483  {
2484      JSON_ASSERT(!f.empty());
2485      for (auto pos = s.find(f);                
2486              pos != StringType::npos;          
2487              s.replace(pos, f.size(), t),      
2488              pos = s.find(f, pos + t.size()))  
2489      {}
2490  }
2491  template<typename StringType>
2492  inline StringType escape(StringType s)
2493  {
2494      replace_substring(s, StringType{"~"}, StringType{"~0"});
2495      replace_substring(s, StringType{"/"}, StringType{"~1"});
2496      return s;
2497  }
2498  template<typename StringType>
2499  static void unescape(StringType& s)
2500  {
2501      replace_substring(s, StringType{"~1"}, StringType{"/"});
2502      replace_substring(s, StringType{"~0"}, StringType{"~"});
2503  }
2504  }  
2505  NLOHMANN_JSON_NAMESPACE_END
2506  #include <cstddef> 
2507  NLOHMANN_JSON_NAMESPACE_BEGIN
2508  namespace detail
2509  {
2510  struct position_t
2511  {
2512      std::size_t chars_read_total = 0;
2513      std::size_t chars_read_current_line = 0;
2514      std::size_t lines_read = 0;
2515      constexpr operator size_t() const
2516      {
2517          return chars_read_total;
2518      }
2519  };
2520  }  
2521  NLOHMANN_JSON_NAMESPACE_END
2522  #include <array> 
2523  #include <cstddef> 
2524  #include <type_traits> 
2525  #include <utility> 
2526  NLOHMANN_JSON_NAMESPACE_BEGIN
2527  namespace detail
2528  {
2529  template<typename T>
2530  using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;
2531  #ifdef JSON_HAS_CPP_14
2532  using std::enable_if_t;
2533  using std::index_sequence;
2534  using std::make_index_sequence;
2535  using std::index_sequence_for;
2536  #else
2537  template<bool B, typename T = void>
2538  using enable_if_t = typename std::enable_if<B, T>::type;
2539  template <typename T, T... Ints>
2540  struct integer_sequence
2541  {
2542      using value_type = T;
2543      static constexpr std::size_t size() noexcept
2544      {
2545          return sizeof...(Ints);
2546      }
2547  };
2548  template <size_t... Ints>
2549  using index_sequence = integer_sequence<size_t, Ints...>;
2550  namespace utility_internal
2551  {
2552  template <typename Seq, size_t SeqSize, size_t Rem>
2553  struct Extend;
2554  template <typename T, T... Ints, size_t SeqSize>
2555  struct Extend<integer_sequence<T, Ints...>, SeqSize, 0>
2556  {
2557      using type = integer_sequence < T, Ints..., (Ints + SeqSize)... >;
2558  };
2559  template <typename T, T... Ints, size_t SeqSize>
2560  struct Extend<integer_sequence<T, Ints...>, SeqSize, 1>
2561  {
2562      using type = integer_sequence < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;
2563  };
2564  template <typename T, size_t N>
2565  struct Gen
2566  {
2567      using type =
2568          typename Extend < typename Gen < T, N / 2 >::type, N / 2, N % 2 >::type;
2569  };
2570  template <typename T>
2571  struct Gen<T, 0>
2572  {
2573      using type = integer_sequence<T>;
2574  };
2575  }  
2576  template <typename T, T N>
2577  using make_integer_sequence = typename utility_internal::Gen<T, N>::type;
2578  template <size_t N>
2579  using make_index_sequence = make_integer_sequence<size_t, N>;
2580  template <typename... Ts>
2581  using index_sequence_for = make_index_sequence<sizeof...(Ts)>;
2582  #endif
2583  template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
2584  template<> struct priority_tag<0> {};
2585  template<typename T>
2586  struct static_const
2587  {
2588      static JSON_INLINE_VARIABLE constexpr T value{};
2589  };
2590  #ifndef JSON_HAS_CPP_17
2591      template<typename T>
2592      constexpr T static_const<T>::value;
2593  #endif
2594  template<typename T, typename... Args>
2595  inline constexpr std::array<T, sizeof...(Args)> make_array(Args&& ... args)
2596  {
2597      return std::array<T, sizeof...(Args)> {{static_cast<T>(std::forward<Args>(args))...}};
2598  }
2599  }  
2600  NLOHMANN_JSON_NAMESPACE_END
2601  #include <limits> 
2602  #include <type_traits> 
2603  #include <utility> 
2604  #include <tuple> 
2605  #include <iterator> 
2606  NLOHMANN_JSON_NAMESPACE_BEGIN
2607  namespace detail
2608  {
2609  template<typename It, typename = void>
2610  struct iterator_types {};
2611  template<typename It>
2612  struct iterator_types <
2613      It,
2614      void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
2615      typename It::reference, typename It::iterator_category >>
2616  {
2617      using difference_type = typename It::difference_type;
2618      using value_type = typename It::value_type;
2619      using pointer = typename It::pointer;
2620      using reference = typename It::reference;
2621      using iterator_category = typename It::iterator_category;
2622  };
2623  template<typename T, typename = void>
2624  struct iterator_traits
2625  {
2626  };
2627  template<typename T>
2628  struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
2629              : iterator_types<T>
2630  {
2631  };
2632  template<typename T>
2633  struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
2634  {
2635      using iterator_category = std::random_access_iterator_tag;
2636      using value_type = T;
2637      using difference_type = ptrdiff_t;
2638      using pointer = T*;
2639      using reference = T&;
2640  };
2641  }  
2642  NLOHMANN_JSON_NAMESPACE_END
2643  NLOHMANN_JSON_NAMESPACE_BEGIN
2644  NLOHMANN_CAN_CALL_STD_FUNC_IMPL(begin);
2645  NLOHMANN_JSON_NAMESPACE_END
2646  NLOHMANN_JSON_NAMESPACE_BEGIN
2647  NLOHMANN_CAN_CALL_STD_FUNC_IMPL(end);
2648  NLOHMANN_JSON_NAMESPACE_END
2649  #ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
2650      #define INCLUDE_NLOHMANN_JSON_FWD_HPP_
2651      #include <cstdint> 
2652      #include <map> 
2653      #include <memory> 
2654      #include <string> 
2655      #include <vector> 
2656      NLOHMANN_JSON_NAMESPACE_BEGIN
2657      template<typename T = void, typename SFINAE = void>
2658      struct adl_serializer;
2659      template<template<typename U, typename V, typename... Args> class ObjectType =
2660      std::map,
2661      template<typename U, typename... Args> class ArrayType = std::vector,
2662      class StringType = std::string, class BooleanType = bool,
2663      class NumberIntegerType = std::int64_t,
2664      class NumberUnsignedType = std::uint64_t,
2665      class NumberFloatType = double,
2666      template<typename U> class AllocatorType = std::allocator,
2667      template<typename T, typename SFINAE = void> class JSONSerializer =
2668      adl_serializer,
2669      class BinaryType = std::vector<std::uint8_t>>
2670      class basic_json;
2671      template<typename RefStringType>
2672      class json_pointer;
2673      using json = basic_json<>;
2674      template<class Key, class T, class IgnoredLess, class Allocator>
2675      struct ordered_map;
2676      using ordered_json = basic_json<nlohmann::ordered_map>;
2677      NLOHMANN_JSON_NAMESPACE_END
2678  #endif  
2679  NLOHMANN_JSON_NAMESPACE_BEGIN
2680  namespace detail
2681  {
2682  template<typename> struct is_basic_json : std::false_type {};
2683  NLOHMANN_BASIC_JSON_TPL_DECLARATION
2684  struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};
2685  template<typename BasicJsonContext>
2686  struct is_basic_json_context :
2687      std::integral_constant < bool,
2688      is_basic_json<typename std::remove_cv<typename std::remove_pointer<BasicJsonContext>::type>::type>::value
2689      || std::is_same<BasicJsonContext, std::nullptr_t>::value >
2690  {};
2691  template<typename>
2692  class json_ref;
2693  template<typename>
2694  struct is_json_ref : std::false_type {};
2695  template<typename T>
2696  struct is_json_ref<json_ref<T>> : std::true_type {};
2697  template<typename T>
2698  using mapped_type_t = typename T::mapped_type;
2699  template<typename T>
2700  using key_type_t = typename T::key_type;
2701  template<typename T>
2702  using value_type_t = typename T::value_type;
2703  template<typename T>
2704  using difference_type_t = typename T::difference_type;
2705  template<typename T>
2706  using pointer_t = typename T::pointer;
2707  template<typename T>
2708  using reference_t = typename T::reference;
2709  template<typename T>
2710  using iterator_category_t = typename T::iterator_category;
2711  template<typename T, typename... Args>
2712  using to_json_function = decltype(T::to_json(std::declval<Args>()...));
2713  template<typename T, typename... Args>
2714  using from_json_function = decltype(T::from_json(std::declval<Args>()...));
2715  template<typename T, typename U>
2716  using get_template_function = decltype(std::declval<T>().template get<U>());
2717  template<typename BasicJsonType, typename T, typename = void>
2718  struct has_from_json : std::false_type {};
2719  template <typename BasicJsonType, typename T>
2720  struct is_getable
2721  {
2722      static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;
2723  };
2724  template<typename BasicJsonType, typename T>
2725  struct has_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
2726  {
2727      using serializer = typename BasicJsonType::template json_serializer<T, void>;
2728      static constexpr bool value =
2729          is_detected_exact<void, from_json_function, serializer,
2730          const BasicJsonType&, T&>::value;
2731  };
2732  template<typename BasicJsonType, typename T, typename = void>
2733  struct has_non_default_from_json : std::false_type {};
2734  template<typename BasicJsonType, typename T>
2735  struct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
2736  {
2737      using serializer = typename BasicJsonType::template json_serializer<T, void>;
2738      static constexpr bool value =
2739          is_detected_exact<T, from_json_function, serializer,
2740          const BasicJsonType&>::value;
2741  };
2742  template<typename BasicJsonType, typename T, typename = void>
2743  struct has_to_json : std::false_type {};
2744  template<typename BasicJsonType, typename T>
2745  struct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
2746  {
2747      using serializer = typename BasicJsonType::template json_serializer<T, void>;
2748      static constexpr bool value =
2749          is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
2750          T>::value;
2751  };
2752  template<typename T>
2753  using detect_key_compare = typename T::key_compare;
2754  template<typename T>
2755  struct has_key_compare : std::integral_constant<bool, is_detected<detect_key_compare, T>::value> {};
2756  template<typename BasicJsonType>
2757  struct actual_object_comparator
2758  {
2759      using object_t = typename BasicJsonType::object_t;
2760      using object_comparator_t = typename BasicJsonType::default_object_comparator_t;
2761      using type = typename std::conditional < has_key_compare<object_t>::value,
2762            typename object_t::key_compare, object_comparator_t>::type;
2763  };
2764  template<typename BasicJsonType>
2765  using actual_object_comparator_t = typename actual_object_comparator<BasicJsonType>::type;
2766  template<class...> struct conjunction : std::true_type { };
2767  template<class B> struct conjunction<B> : B { };
2768  template<class B, class... Bn>
2769  struct conjunction<B, Bn...>
2770  : std::conditional<static_cast<bool>(B::value), conjunction<Bn...>, B>::type {};
2771  template<class B> struct negation : std::integral_constant < bool, !B::value > { };
2772  template <typename T>
2773  struct is_default_constructible : std::is_default_constructible<T> {};
2774  template <typename T1, typename T2>
2775  struct is_default_constructible<std::pair<T1, T2>>
2776              : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};
2777  template <typename T1, typename T2>
2778  struct is_default_constructible<const std::pair<T1, T2>>
2779              : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};
2780  template <typename... Ts>
2781  struct is_default_constructible<std::tuple<Ts...>>
2782              : conjunction<is_default_constructible<Ts>...> {};
2783  template <typename... Ts>
2784  struct is_default_constructible<const std::tuple<Ts...>>
2785              : conjunction<is_default_constructible<Ts>...> {};
2786  template <typename T, typename... Args>
2787  struct is_constructible : std::is_constructible<T, Args...> {};
2788  template <typename T1, typename T2>
2789  struct is_constructible<std::pair<T1, T2>> : is_default_constructible<std::pair<T1, T2>> {};
2790  template <typename T1, typename T2>
2791  struct is_constructible<const std::pair<T1, T2>> : is_default_constructible<const std::pair<T1, T2>> {};
2792  template <typename... Ts>
2793  struct is_constructible<std::tuple<Ts...>> : is_default_constructible<std::tuple<Ts...>> {};
2794  template <typename... Ts>
2795  struct is_constructible<const std::tuple<Ts...>> : is_default_constructible<const std::tuple<Ts...>> {};
2796  template<typename T, typename = void>
2797  struct is_iterator_traits : std::false_type {};
2798  template<typename T>
2799  struct is_iterator_traits<iterator_traits<T>>
2800  {
2801    private:
2802      using traits = iterator_traits<T>;
2803    public:
2804      static constexpr auto value =
2805          is_detected<value_type_t, traits>::value &&
2806          is_detected<difference_type_t, traits>::value &&
2807          is_detected<pointer_t, traits>::value &&
2808          is_detected<iterator_category_t, traits>::value &&
2809          is_detected<reference_t, traits>::value;
2810  };
2811  template<typename T>
2812  struct is_range
2813  {
2814    private:
2815      using t_ref = typename std::add_lvalue_reference<T>::type;
2816      using iterator = detected_t<result_of_begin, t_ref>;
2817      using sentinel = detected_t<result_of_end, t_ref>;
2818      static constexpr auto is_iterator_begin =
2819          is_iterator_traits<iterator_traits<iterator>>::value;
2820    public:
2821      static constexpr bool value = !std::is_same<iterator, nonesuch>::value && !std::is_same<sentinel, nonesuch>::value && is_iterator_begin;
2822  };
2823  template<typename R>
2824  using iterator_t = enable_if_t<is_range<R>::value, result_of_begin<decltype(std::declval<R&>())>>;
2825  template<typename T>
2826  using range_value_t = value_type_t<iterator_traits<iterator_t<T>>>;
2827  template<typename T, typename = void>
2828  struct is_complete_type : std::false_type {};
2829  template<typename T>
2830  struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};
2831  template<typename BasicJsonType, typename CompatibleObjectType,
2832           typename = void>
2833  struct is_compatible_object_type_impl : std::false_type {};
2834  template<typename BasicJsonType, typename CompatibleObjectType>
2835  struct is_compatible_object_type_impl <
2836      BasicJsonType, CompatibleObjectType,
2837      enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&
2838      is_detected<key_type_t, CompatibleObjectType>::value >>
2839  {
2840      using object_t = typename BasicJsonType::object_t;
2841      static constexpr bool value =
2842          is_constructible<typename object_t::key_type,
2843          typename CompatibleObjectType::key_type>::value &&
2844          is_constructible<typename object_t::mapped_type,
2845          typename CompatibleObjectType::mapped_type>::value;
2846  };
2847  template<typename BasicJsonType, typename CompatibleObjectType>
2848  struct is_compatible_object_type
2849      : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};
2850  template<typename BasicJsonType, typename ConstructibleObjectType,
2851           typename = void>
2852  struct is_constructible_object_type_impl : std::false_type {};
2853  template<typename BasicJsonType, typename ConstructibleObjectType>
2854  struct is_constructible_object_type_impl <
2855      BasicJsonType, ConstructibleObjectType,
2856      enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&
2857      is_detected<key_type_t, ConstructibleObjectType>::value >>
2858  {
2859      using object_t = typename BasicJsonType::object_t;
2860      static constexpr bool value =
2861          (is_default_constructible<ConstructibleObjectType>::value &&
2862           (std::is_move_assignable<ConstructibleObjectType>::value ||
2863            std::is_copy_assignable<ConstructibleObjectType>::value) &&
2864           (is_constructible<typename ConstructibleObjectType::key_type,
2865            typename object_t::key_type>::value &&
2866            std::is_same <
2867            typename object_t::mapped_type,
2868            typename ConstructibleObjectType::mapped_type >::value)) ||
2869          (has_from_json<BasicJsonType,
2870           typename ConstructibleObjectType::mapped_type>::value ||
2871           has_non_default_from_json <
2872           BasicJsonType,
2873           typename ConstructibleObjectType::mapped_type >::value);
2874  };
2875  template<typename BasicJsonType, typename ConstructibleObjectType>
2876  struct is_constructible_object_type
2877      : is_constructible_object_type_impl<BasicJsonType,
2878        ConstructibleObjectType> {};
2879  template<typename BasicJsonType, typename CompatibleStringType>
2880  struct is_compatible_string_type
2881  {
2882      static constexpr auto value =
2883          is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
2884  };
2885  template<typename BasicJsonType, typename ConstructibleStringType>
2886  struct is_constructible_string_type
2887  {
2888  #ifdef __INTEL_COMPILER
2889      using laundered_type = decltype(std::declval<ConstructibleStringType>());
2890  #else
2891      using laundered_type = ConstructibleStringType;
2892  #endif
2893      static constexpr auto value =
2894          conjunction <
2895          is_constructible<laundered_type, typename BasicJsonType::string_t>,
2896          is_detected_exact<typename BasicJsonType::string_t::value_type,
2897          value_type_t, laundered_type >>::value;
2898  };
2899  template<typename BasicJsonType, typename CompatibleArrayType, typename = void>
2900  struct is_compatible_array_type_impl : std::false_type {};
2901  template<typename BasicJsonType, typename CompatibleArrayType>
2902  struct is_compatible_array_type_impl <
2903      BasicJsonType, CompatibleArrayType,
2904      enable_if_t <
2905      is_detected<iterator_t, CompatibleArrayType>::value&&
2906      is_iterator_traits<iterator_traits<detected_t<iterator_t, CompatibleArrayType>>>::value&&
2907      !std::is_same<CompatibleArrayType, detected_t<range_value_t, CompatibleArrayType>>::value >>
2908  {
2909      static constexpr bool value =
2910          is_constructible<BasicJsonType,
2911          range_value_t<CompatibleArrayType>>::value;
2912  };
2913  template<typename BasicJsonType, typename CompatibleArrayType>
2914  struct is_compatible_array_type
2915      : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};
2916  template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>
2917  struct is_constructible_array_type_impl : std::false_type {};
2918  template<typename BasicJsonType, typename ConstructibleArrayType>
2919  struct is_constructible_array_type_impl <
2920      BasicJsonType, ConstructibleArrayType,
2921      enable_if_t<std::is_same<ConstructibleArrayType,
2922      typename BasicJsonType::value_type>::value >>
2923              : std::true_type {};
2924  template<typename BasicJsonType, typename ConstructibleArrayType>
2925  struct is_constructible_array_type_impl <
2926      BasicJsonType, ConstructibleArrayType,
2927      enable_if_t < !std::is_same<ConstructibleArrayType,
2928      typename BasicJsonType::value_type>::value&&
2929      !is_compatible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
2930      is_default_constructible<ConstructibleArrayType>::value&&
2931  (std::is_move_assignable<ConstructibleArrayType>::value ||
2932   std::is_copy_assignable<ConstructibleArrayType>::value)&&
2933  is_detected<iterator_t, ConstructibleArrayType>::value&&
2934  is_iterator_traits<iterator_traits<detected_t<iterator_t, ConstructibleArrayType>>>::value&&
2935  is_detected<range_value_t, ConstructibleArrayType>::value&&
2936  !std::is_same<ConstructibleArrayType, detected_t<range_value_t, ConstructibleArrayType>>::value&&
2937          is_complete_type <
2938          detected_t<range_value_t, ConstructibleArrayType >>::value >>
2939  {
2940      using value_type = range_value_t<ConstructibleArrayType>;
2941      static constexpr bool value =
2942          std::is_same<value_type,
2943          typename BasicJsonType::array_t::value_type>::value ||
2944          has_from_json<BasicJsonType,
2945          value_type>::value ||
2946          has_non_default_from_json <
2947          BasicJsonType,
2948          value_type >::value;
2949  };
2950  template<typename BasicJsonType, typename ConstructibleArrayType>
2951  struct is_constructible_array_type
2952      : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};
2953  template<typename RealIntegerType, typename CompatibleNumberIntegerType,
2954           typename = void>
2955  struct is_compatible_integer_type_impl : std::false_type {};
2956  template<typename RealIntegerType, typename CompatibleNumberIntegerType>
2957  struct is_compatible_integer_type_impl <
2958      RealIntegerType, CompatibleNumberIntegerType,
2959      enable_if_t < std::is_integral<RealIntegerType>::value&&
2960      std::is_integral<CompatibleNumberIntegerType>::value&&
2961      !std::is_same<bool, CompatibleNumberIntegerType>::value >>
2962  {
2963      using RealLimits = std::numeric_limits<RealIntegerType>;
2964      using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;
2965      static constexpr auto value =
2966          is_constructible<RealIntegerType,
2967          CompatibleNumberIntegerType>::value &&
2968          CompatibleLimits::is_integer &&
2969          RealLimits::is_signed == CompatibleLimits::is_signed;
2970  };
2971  template<typename RealIntegerType, typename CompatibleNumberIntegerType>
2972  struct is_compatible_integer_type
2973      : is_compatible_integer_type_impl<RealIntegerType,
2974        CompatibleNumberIntegerType> {};
2975  template<typename BasicJsonType, typename CompatibleType, typename = void>
2976  struct is_compatible_type_impl: std::false_type {};
2977  template<typename BasicJsonType, typename CompatibleType>
2978  struct is_compatible_type_impl <
2979      BasicJsonType, CompatibleType,
2980      enable_if_t<is_complete_type<CompatibleType>::value >>
2981  {
2982      static constexpr bool value =
2983          has_to_json<BasicJsonType, CompatibleType>::value;
2984  };
2985  template<typename BasicJsonType, typename CompatibleType>
2986  struct is_compatible_type
2987      : is_compatible_type_impl<BasicJsonType, CompatibleType> {};
2988  template<typename T1, typename T2>
2989  struct is_constructible_tuple : std::false_type {};
2990  template<typename T1, typename... Args>
2991  struct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<is_constructible<T1, Args>...> {};
2992  template<typename BasicJsonType, typename T>
2993  struct is_json_iterator_of : std::false_type {};
2994  template<typename BasicJsonType>
2995  struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::iterator> : std::true_type {};
2996  template<typename BasicJsonType>
2997  struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::const_iterator> : std::true_type
2998  {};
2999  template<template <typename...> class Primary, typename T>
3000  struct is_specialization_of : std::false_type {};
3001  template<template <typename...> class Primary, typename... Args>
3002  struct is_specialization_of<Primary, Primary<Args...>> : std::true_type {};
3003  template<typename T>
3004  using is_json_pointer = is_specialization_of<::nlohmann::json_pointer, uncvref_t<T>>;
3005  template<typename Compare, typename A, typename B, typename = void>
3006  struct is_comparable : std::false_type {};
3007  template<typename Compare, typename A, typename B>
3008  struct is_comparable<Compare, A, B, void_t<
3009  decltype(std::declval<Compare>()(std::declval<A>(), std::declval<B>())),
3010  decltype(std::declval<Compare>()(std::declval<B>(), std::declval<A>()))
3011  >> : std::true_type {};
3012  template<typename T>
3013  using detect_is_transparent = typename T::is_transparent;
3014  template<typename Comparator, typename ObjectKeyType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
3015           bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
3016  using is_usable_as_key_type = typename std::conditional <
3017                                is_comparable<Comparator, ObjectKeyType, KeyTypeCVRef>::value
3018                                && !(ExcludeObjectKeyType && std::is_same<KeyType,
3019                                     ObjectKeyType>::value)
3020                                && (!RequireTransparentComparator
3021                                    || is_detected <detect_is_transparent, Comparator>::value)
3022                                && !is_json_pointer<KeyType>::value,
3023                                std::true_type,
3024                                std::false_type >::type;
3025  template<typename BasicJsonType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
3026           bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
3027  using is_usable_as_basic_json_key_type = typename std::conditional <
3028          is_usable_as_key_type<typename BasicJsonType::object_comparator_t,
3029          typename BasicJsonType::object_t::key_type, KeyTypeCVRef,
3030          RequireTransparentComparator, ExcludeObjectKeyType>::value
3031          && !is_json_iterator_of<BasicJsonType, KeyType>::value,
3032          std::true_type,
3033          std::false_type >::type;
3034  template<typename ObjectType, typename KeyType>
3035  using detect_erase_with_key_type = decltype(std::declval<ObjectType&>().erase(std::declval<KeyType>()));
3036  template<typename BasicJsonType, typename KeyType>
3037  using has_erase_with_key_type = typename std::conditional <
3038                                  is_detected <
3039                                  detect_erase_with_key_type,
3040                                  typename BasicJsonType::object_t, KeyType >::value,
3041                                  std::true_type,
3042                                  std::false_type >::type;
3043  template <typename T>
3044  struct is_ordered_map
3045  {
3046      using one = char;
3047      struct two
3048      {
3049          char x[2]; 
3050      };
3051      template <typename C> static one test( decltype(&C::capacity) ) ;
3052      template <typename C> static two test(...);
3053      enum { value = sizeof(test<T>(nullptr)) == sizeof(char) }; 
3054  };
3055  template < typename T, typename U, enable_if_t < !std::is_same<T, U>::value, int > = 0 >
3056  T conditional_static_cast(U value)
3057  {
3058      return static_cast<T>(value);
3059  }
3060  template<typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>
3061  T conditional_static_cast(U value)
3062  {
3063      return value;
3064  }
3065  template<typename... Types>
3066  using all_integral = conjunction<std::is_integral<Types>...>;
3067  template<typename... Types>
3068  using all_signed = conjunction<std::is_signed<Types>...>;
3069  template<typename... Types>
3070  using all_unsigned = conjunction<std::is_unsigned<Types>...>;
3071  template<typename... Types>
3072  using same_sign = std::integral_constant < bool,
3073        all_signed<Types...>::value || all_unsigned<Types...>::value >;
3074  template<typename OfType, typename T>
3075  using never_out_of_range = std::integral_constant < bool,
3076        (std::is_signed<OfType>::value && (sizeof(T) < sizeof(OfType)))
3077        || (same_sign<OfType, T>::value && sizeof(OfType) == sizeof(T)) >;
3078  template<typename OfType, typename T,
3079           bool OfTypeSigned = std::is_signed<OfType>::value,
3080           bool TSigned = std::is_signed<T>::value>
3081  struct value_in_range_of_impl2;
3082  template<typename OfType, typename T>
3083  struct value_in_range_of_impl2<OfType, T, false, false>
3084  {
3085      static constexpr bool test(T val)
3086      {
3087          using CommonType = typename std::common_type<OfType, T>::type;
3088          return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
3089      }
3090  };
3091  template<typename OfType, typename T>
3092  struct value_in_range_of_impl2<OfType, T, true, false>
3093  {
3094      static constexpr bool test(T val)
3095      {
3096          using CommonType = typename std::common_type<OfType, T>::type;
3097          return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
3098      }
3099  };
3100  template<typename OfType, typename T>
3101  struct value_in_range_of_impl2<OfType, T, false, true>
3102  {
3103      static constexpr bool test(T val)
3104      {
3105          using CommonType = typename std::common_type<OfType, T>::type;
3106          return val >= 0 && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
3107      }
3108  };
3109  template<typename OfType, typename T>
3110  struct value_in_range_of_impl2<OfType, T, true, true>
3111  {
3112      static constexpr bool test(T val)
3113      {
3114          using CommonType = typename std::common_type<OfType, T>::type;
3115          return static_cast<CommonType>(val) >= static_cast<CommonType>((std::numeric_limits<OfType>::min)())
3116                 && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
3117      }
3118  };
3119  template<typename OfType, typename T,
3120           bool NeverOutOfRange = never_out_of_range<OfType, T>::value,
3121           typename = detail::enable_if_t<all_integral<OfType, T>::value>>
3122  struct value_in_range_of_impl1;
3123  template<typename OfType, typename T>
3124  struct value_in_range_of_impl1<OfType, T, false>
3125  {
3126      static constexpr bool test(T val)
3127      {
3128          return value_in_range_of_impl2<OfType, T>::test(val);
3129      }
3130  };
3131  template<typename OfType, typename T>
3132  struct value_in_range_of_impl1<OfType, T, true>
3133  {
3134      static constexpr bool test(T &bsol;*val*/)
3135      {
3136          return true;
3137      }
3138  };
3139  template<typename OfType, typename T>
3140  inline constexpr bool value_in_range_of(T val)
3141  {
3142      return value_in_range_of_impl1<OfType, T>::test(val);
3143  }
3144  template<bool Value>
3145  using bool_constant = std::integral_constant<bool, Value>;
3146  namespace impl
3147  {
3148  template<typename T>
3149  inline constexpr bool is_c_string()
3150  {
3151      using TUnExt = typename std::remove_extent<T>::type;
3152      using TUnCVExt = typename std::remove_cv<TUnExt>::type;
3153      using TUnPtr = typename std::remove_pointer<T>::type;
3154      using TUnCVPtr = typename std::remove_cv<TUnPtr>::type;
3155      return
3156          (std::is_array<T>::value && std::is_same<TUnCVExt, char>::value)
3157          || (std::is_pointer<T>::value && std::is_same<TUnCVPtr, char>::value);
3158  }
3159  }  
3160  template<typename T>
3161  struct is_c_string : bool_constant<impl::is_c_string<T>()> {};
3162  template<typename T>
3163  using is_c_string_uncvref = is_c_string<uncvref_t<T>>;
3164  namespace impl
3165  {
3166  template<typename T>
3167  inline constexpr bool is_transparent()
3168  {
3169      return is_detected<detect_is_transparent, T>::value;
3170  }
3171  }  
3172  template<typename T>
3173  struct is_transparent : bool_constant<impl::is_transparent<T>()> {};
3174  }  
3175  NLOHMANN_JSON_NAMESPACE_END
3176  #include <cstring> 
3177  #include <string> 
3178  #include <utility> 
3179  NLOHMANN_JSON_NAMESPACE_BEGIN
3180  namespace detail
3181  {
3182  inline std::size_t concat_length()
3183  {
3184      return 0;
3185  }
3186  template<typename... Args>
3187  inline std::size_t concat_length(const char* cstr, Args&& ... rest);
3188  template<typename StringType, typename... Args>
3189  inline std::size_t concat_length(const StringType& str, Args&& ... rest);
3190  template<typename... Args>
3191  inline std::size_t concat_length(const char &bsol;*c*/, Args&& ... rest)
3192  {
3193      return 1 + concat_length(std::forward<Args>(rest)...);
3194  }
3195  template<typename... Args>
3196  inline std::size_t concat_length(const char* cstr, Args&& ... rest)
3197  {
3198      return ::strlen(cstr) + concat_length(std::forward<Args>(rest)...);
3199  }
3200  template<typename StringType, typename... Args>
3201  inline std::size_t concat_length(const StringType& str, Args&& ... rest)
3202  {
3203      return str.size() + concat_length(std::forward<Args>(rest)...);
3204  }
3205  template<typename OutStringType>
3206  inline void concat_into(OutStringType& &bsol;*out*/)
3207  {}
3208  template<typename StringType, typename Arg>
3209  using string_can_append = decltype(std::declval<StringType&>().append(std::declval < Arg && > ()));
3210  template<typename StringType, typename Arg>
3211  using detect_string_can_append = is_detected<string_can_append, StringType, Arg>;
3212  template<typename StringType, typename Arg>
3213  using string_can_append_op = decltype(std::declval<StringType&>() += std::declval < Arg && > ());
3214  template<typename StringType, typename Arg>
3215  using detect_string_can_append_op = is_detected<string_can_append_op, StringType, Arg>;
3216  template<typename StringType, typename Arg>
3217  using string_can_append_iter = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().begin(), std::declval<const Arg&>().end()));
3218  template<typename StringType, typename Arg>
3219  using detect_string_can_append_iter = is_detected<string_can_append_iter, StringType, Arg>;
3220  template<typename StringType, typename Arg>
3221  using string_can_append_data = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().data(), std::declval<const Arg&>().size()));
3222  template<typename StringType, typename Arg>
3223  using detect_string_can_append_data = is_detected<string_can_append_data, StringType, Arg>;
3224  template < typename OutStringType, typename Arg, typename... Args,
3225             enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
3226                           && detect_string_can_append_op<OutStringType, Arg>::value, int > = 0 >
3227  inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest);
3228  template < typename OutStringType, typename Arg, typename... Args,
3229             enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
3230                           && !detect_string_can_append_op<OutStringType, Arg>::value
3231                           && detect_string_can_append_iter<OutStringType, Arg>::value, int > = 0 >
3232  inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);
3233  template < typename OutStringType, typename Arg, typename... Args,
3234             enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
3235                           && !detect_string_can_append_op<OutStringType, Arg>::value
3236                           && !detect_string_can_append_iter<OutStringType, Arg>::value
3237                           && detect_string_can_append_data<OutStringType, Arg>::value, int > = 0 >
3238  inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);
3239  template<typename OutStringType, typename Arg, typename... Args,
3240           enable_if_t<detect_string_can_append<OutStringType, Arg>::value, int> = 0>
3241  inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest)
3242  {
3243      out.append(std::forward<Arg>(arg));
3244      concat_into(out, std::forward<Args>(rest)...);
3245  }
3246  template < typename OutStringType, typename Arg, typename... Args,
3247             enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
3248                           && detect_string_can_append_op<OutStringType, Arg>::value, int > >
3249  inline void concat_into(OutStringType& out, Arg&& arg, Args&& ... rest)
3250  {
3251      out += std::forward<Arg>(arg);
3252      concat_into(out, std::forward<Args>(rest)...);
3253  }
3254  template < typename OutStringType, typename Arg, typename... Args,
3255             enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
3256                           && !detect_string_can_append_op<OutStringType, Arg>::value
3257                           && detect_string_can_append_iter<OutStringType, Arg>::value, int > >
3258  inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
3259  {
3260      out.append(arg.begin(), arg.end());
3261      concat_into(out, std::forward<Args>(rest)...);
3262  }
3263  template < typename OutStringType, typename Arg, typename... Args,
3264             enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
3265                           && !detect_string_can_append_op<OutStringType, Arg>::value
3266                           && !detect_string_can_append_iter<OutStringType, Arg>::value
3267                           && detect_string_can_append_data<OutStringType, Arg>::value, int > >
3268  inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
3269  {
3270      out.append(arg.data(), arg.size());
3271      concat_into(out, std::forward<Args>(rest)...);
3272  }
3273  template<typename OutStringType = std::string, typename... Args>
3274  inline OutStringType concat(Args && ... args)
3275  {
3276      OutStringType str;
3277      str.reserve(concat_length(std::forward<Args>(args)...));
3278      concat_into(str, std::forward<Args>(args)...);
3279      return str;
3280  }
3281  }  
3282  NLOHMANN_JSON_NAMESPACE_END
3283  NLOHMANN_JSON_NAMESPACE_BEGIN
3284  namespace detail
3285  {
3286  class exception : public std::exception
3287  {
3288    public:
3289      const char* what() const noexcept override
3290      {
3291          return m.what();
3292      }
3293      const int id; 
3294    protected:
3295      JSON_HEDLEY_NON_NULL(3)
3296      exception(int id_, const char* what_arg) : id(id_), m(what_arg) {} 
3297      static std::string name(const std::string& ename, int id_)
3298      {
3299          return concat("[json.exception.", ename, '.', std::to_string(id_), "] ");
3300      }
3301      static std::string diagnostics(std::nullptr_t &bsol;*leaf_element*/)
3302      {
3303          return "";
3304      }
3305      template<typename BasicJsonType>
3306      static std::string diagnostics(const BasicJsonType* leaf_element)
3307      {
3308  #if JSON_DIAGNOSTICS
3309          std::vector<std::string> tokens;
3310          for (const auto* current = leaf_element; current != nullptr && current->m_parent != nullptr; current = current->m_parent)
3311          {
3312              switch (current->m_parent->type())
3313              {
3314                  case value_t::array:
3315                  {
3316                      for (std::size_t i = 0; i < current->m_parent->m_value.array->size(); ++i)
3317                      {
3318                          if (&current->m_parent->m_value.array->operator[](i) == current)
3319                          {
3320                              tokens.emplace_back(std::to_string(i));
3321                              break;
3322                          }
3323                      }
3324                      break;
3325                  }
3326                  case value_t::object:
3327                  {
3328                      for (const auto& element : *current->m_parent->m_value.object)
3329                      {
3330                          if (&element.second == current)
3331                          {
3332                              tokens.emplace_back(element.first.c_str());
3333                              break;
3334                          }
3335                      }
3336                      break;
3337                  }
3338                  case value_t::null: 
3339                  case value_t::string: 
3340                  case value_t::boolean: 
3341                  case value_t::number_integer: 
3342                  case value_t::number_unsigned: 
3343                  case value_t::number_float: 
3344                  case value_t::binary: 
3345                  case value_t::discarded: 
3346                  default:   
3347                      break; 
3348              }
3349          }
3350          if (tokens.empty())
3351          {
3352              return "";
3353          }
3354          auto str = std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},
3355                                     [](const std::string & a, const std::string & b)
3356          {
3357              return concat(a, '/', detail::escape(b));
3358          });
3359          return concat('(', str, ") ");
3360  #else
3361          static_cast<void>(leaf_element);
3362          return "";
3363  #endif
3364      }
3365    private:
3366      std::runtime_error m;
3367  };
3368  class parse_error : public exception
3369  {
3370    public:
3371      template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
3372      static parse_error create(int id_, const position_t& pos, const std::string& what_arg, BasicJsonContext context)
3373      {
3374          std::string w = concat(exception::name("parse_error", id_), "parse error",
3375                                 position_string(pos), ": ", exception::diagnostics(context), what_arg);
3376          return {id_, pos.chars_read_total, w.c_str()};
3377      }
3378      template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
3379      static parse_error create(int id_, std::size_t byte_, const std::string& what_arg, BasicJsonContext context)
3380      {
3381          std::string w = concat(exception::name("parse_error", id_), "parse error",
3382                                 (byte_ != 0 ? (concat(" at byte ", std::to_string(byte_))) : ""),
3383                                 ": ", exception::diagnostics(context), what_arg);
3384          return {id_, byte_, w.c_str()};
3385      }
3386      const std::size_t byte;
3387    private:
3388      parse_error(int id_, std::size_t byte_, const char* what_arg)
3389          : exception(id_, what_arg), byte(byte_) {}
3390      static std::string position_string(const position_t& pos)
3391      {
3392          return concat(" at line ", std::to_string(pos.lines_read + 1),
3393                        ", column ", std::to_string(pos.chars_read_current_line));
3394      }
3395  };
3396  class invalid_iterator : public exception
3397  {
3398    public:
3399      template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
3400      static invalid_iterator create(int id_, const std::string& what_arg, BasicJsonContext context)
3401      {
3402          std::string w = concat(exception::name("invalid_iterator", id_), exception::diagnostics(context), what_arg);
3403          return {id_, w.c_str()};
3404      }
3405    private:
3406      JSON_HEDLEY_NON_NULL(3)
3407      invalid_iterator(int id_, const char* what_arg)
3408          : exception(id_, what_arg) {}
3409  };
3410  class type_error : public exception
3411  {
3412    public:
3413      template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
3414      static type_error create(int id_, const std::string& what_arg, BasicJsonContext context)
3415      {
3416          std::string w = concat(exception::name("type_error", id_), exception::diagnostics(context), what_arg);
3417          return {id_, w.c_str()};
3418      }
3419    private:
3420      JSON_HEDLEY_NON_NULL(3)
3421      type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
3422  };
3423  class out_of_range : public exception
3424  {
3425    public:
3426      template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
3427      static out_of_range create(int id_, const std::string& what_arg, BasicJsonContext context)
3428      {
3429          std::string w = concat(exception::name("out_of_range", id_), exception::diagnostics(context), what_arg);
3430          return {id_, w.c_str()};
3431      }
3432    private:
3433      JSON_HEDLEY_NON_NULL(3)
3434      out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
3435  };
3436  class other_error : public exception
3437  {
3438    public:
3439      template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
3440      static other_error create(int id_, const std::string& what_arg, BasicJsonContext context)
3441      {
3442          std::string w = concat(exception::name("other_error", id_), exception::diagnostics(context), what_arg);
3443          return {id_, w.c_str()};
3444      }
3445    private:
3446      JSON_HEDLEY_NON_NULL(3)
3447      other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
3448  };
3449  }  
3450  NLOHMANN_JSON_NAMESPACE_END
3451  NLOHMANN_JSON_NAMESPACE_BEGIN
3452  namespace detail
3453  {
3454  template <class T> struct identity_tag {};
3455  }  
3456  NLOHMANN_JSON_NAMESPACE_END
3457  #if JSON_HAS_EXPERIMENTAL_FILESYSTEM
3458  #include <experimental/filesystem>
3459  NLOHMANN_JSON_NAMESPACE_BEGIN
3460  namespace detail
3461  {
3462  namespace std_fs = std::experimental::filesystem;
3463  }  
3464  NLOHMANN_JSON_NAMESPACE_END
3465  #elif JSON_HAS_FILESYSTEM
3466  #include <filesystem>
3467  NLOHMANN_JSON_NAMESPACE_BEGIN
3468  namespace detail
3469  {
3470  namespace std_fs = std::filesystem;
3471  }  
3472  NLOHMANN_JSON_NAMESPACE_END
3473  #endif
3474  NLOHMANN_JSON_NAMESPACE_BEGIN
3475  namespace detail
3476  {
3477  template<typename BasicJsonType>
3478  inline void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
3479  {
3480      if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
3481      {
3482          JSON_THROW(type_error::create(302, concat("type must be null, but is ", j.type_name()), &j));
3483      }
3484      n = nullptr;
3485  }
3486  template < typename BasicJsonType, typename ArithmeticType,
3487             enable_if_t < std::is_arithmetic<ArithmeticType>::value&&
3488                           !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
3489                           int > = 0 >
3490  void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
3491  {
3492      switch (static_cast<value_t>(j))
3493      {
3494          case value_t::number_unsigned:
3495          {
3496              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
3497              break;
3498          }
3499          case value_t::number_integer:
3500          {
3501              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
3502              break;
3503          }
3504          case value_t::number_float:
3505          {
3506              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
3507              break;
3508          }
3509          case value_t::null:
3510          case value_t::object:
3511          case value_t::array:
3512          case value_t::string:
3513          case value_t::boolean:
3514          case value_t::binary:
3515          case value_t::discarded:
3516          default:
3517              JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
3518      }
3519  }
3520  template<typename BasicJsonType>
3521  inline void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
3522  {
3523      if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
3524      {
3525          JSON_THROW(type_error::create(302, concat("type must be boolean, but is ", j.type_name()), &j));
3526      }
3527      b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
3528  }
3529  template<typename BasicJsonType>
3530  inline void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
3531  {
3532      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3533      {
3534          JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
3535      }
3536      s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
3537  }
3538  template <
3539      typename BasicJsonType, typename StringType,
3540      enable_if_t <
3541          std::is_assignable<StringType&, const typename BasicJsonType::string_t>::value
3542          && is_detected_exact<typename BasicJsonType::string_t::value_type, value_type_t, StringType>::value
3543          && !std::is_same<typename BasicJsonType::string_t, StringType>::value
3544          && !is_json_ref<StringType>::value, int > = 0 >
3545  inline void from_json(const BasicJsonType& j, StringType& s)
3546  {
3547      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3548      {
3549          JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
3550      }
3551      s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
3552  }
3553  template<typename BasicJsonType>
3554  inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
3555  {
3556      get_arithmetic_value(j, val);
3557  }
3558  template<typename BasicJsonType>
3559  inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
3560  {
3561      get_arithmetic_value(j, val);
3562  }
3563  template<typename BasicJsonType>
3564  inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
3565  {
3566      get_arithmetic_value(j, val);
3567  }
3568  #if !JSON_DISABLE_ENUM_SERIALIZATION
3569  template<typename BasicJsonType, typename EnumType,
3570           enable_if_t<std::is_enum<EnumType>::value, int> = 0>
3571  inline void from_json(const BasicJsonType& j, EnumType& e)
3572  {
3573      typename std::underlying_type<EnumType>::type val;
3574      get_arithmetic_value(j, val);
3575      e = static_cast<EnumType>(val);
3576  }
3577  #endif  
3578  template<typename BasicJsonType, typename T, typename Allocator,
3579           enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
3580  inline void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
3581  {
3582      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3583      {
3584          JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
3585      }
3586      l.clear();
3587      std::transform(j.rbegin(), j.rend(),
3588                     std::front_inserter(l), [](const BasicJsonType & i)
3589      {
3590          return i.template get<T>();
3591      });
3592  }
3593  template<typename BasicJsonType, typename T,
3594           enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
3595  inline void from_json(const BasicJsonType& j, std::valarray<T>& l)
3596  {
3597      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3598      {
3599          JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
3600      }
3601      l.resize(j.size());
3602      std::transform(j.begin(), j.end(), std::begin(l),
3603                     [](const BasicJsonType & elem)
3604      {
3605          return elem.template get<T>();
3606      });
3607  }
3608  template<typename BasicJsonType, typename T, std::size_t N>
3609  auto from_json(const BasicJsonType& j, T (&arr)[N])  
3610  -> decltype(j.template get<T>(), void())
3611  {
3612      for (std::size_t i = 0; i < N; ++i)
3613      {
3614          arr[i] = j.at(i).template get<T>();
3615      }
3616  }
3617  template<typename BasicJsonType>
3618  inline void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> &bsol;*unused*/)
3619  {
3620      arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
3621  }
3622  template<typename BasicJsonType, typename T, std::size_t N>
3623  auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
3624                            priority_tag<2> &bsol;*unused*/)
3625  -> decltype(j.template get<T>(), void())
3626  {
3627      for (std::size_t i = 0; i < N; ++i)
3628      {
3629          arr[i] = j.at(i).template get<T>();
3630      }
3631  }
3632  template<typename BasicJsonType, typename ConstructibleArrayType,
3633           enable_if_t<
3634               std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
3635               int> = 0>
3636  auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> &bsol;*unused*/)
3637  -> decltype(
3638      arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
3639      j.template get<typename ConstructibleArrayType::value_type>(),
3640      void())
3641  {
3642      using std::end;
3643      ConstructibleArrayType ret;
3644      ret.reserve(j.size());
3645      std::transform(j.begin(), j.end(),
3646                     std::inserter(ret, end(ret)), [](const BasicJsonType & i)
3647      {
3648          return i.template get<typename ConstructibleArrayType::value_type>();
3649      });
3650      arr = std::move(ret);
3651  }
3652  template<typename BasicJsonType, typename ConstructibleArrayType,
3653           enable_if_t<
3654               std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
3655               int> = 0>
3656  inline void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
3657                                   priority_tag<0> &bsol;*unused*/)
3658  {
3659      using std::end;
3660      ConstructibleArrayType ret;
3661      std::transform(
3662          j.begin(), j.end(), std::inserter(ret, end(ret)),
3663          [](const BasicJsonType & i)
3664      {
3665          return i.template get<typename ConstructibleArrayType::value_type>();
3666      });
3667      arr = std::move(ret);
3668  }
3669  template < typename BasicJsonType, typename ConstructibleArrayType,
3670             enable_if_t <
3671                 is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&
3672                 !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&
3673                 !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
3674                 !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&
3675                 !is_basic_json<ConstructibleArrayType>::value,
3676                 int > = 0 >
3677  auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
3678  -> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
3679  j.template get<typename ConstructibleArrayType::value_type>(),
3680  void())
3681  {
3682      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3683      {
3684          JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
3685      }
3686      from_json_array_impl(j, arr, priority_tag<3> {});
3687  }
3688  template < typename BasicJsonType, typename T, std::size_t... Idx >
3689  std::array<T, sizeof...(Idx)> from_json_inplace_array_impl(BasicJsonType&& j,
3690          identity_tag<std::array<T, sizeof...(Idx)>> &bsol;*unused*/, index_sequence<Idx...> &bsol;*unused*/)
3691  {
3692      return { { std::forward<BasicJsonType>(j).at(Idx).template get<T>()... } };
3693  }
3694  template < typename BasicJsonType, typename T, std::size_t N >
3695  auto from_json(BasicJsonType&& j, identity_tag<std::array<T, N>> tag)
3696  -> decltype(from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {}))
3697  {
3698      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3699      {
3700          JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
3701      }
3702      return from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {});
3703  }
3704  template<typename BasicJsonType>
3705  inline void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)
3706  {
3707      if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
3708      {
3709          JSON_THROW(type_error::create(302, concat("type must be binary, but is ", j.type_name()), &j));
3710      }
3711      bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();
3712  }
3713  template<typename BasicJsonType, typename ConstructibleObjectType,
3714           enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
3715  inline void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
3716  {
3717      if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
3718      {
3719          JSON_THROW(type_error::create(302, concat("type must be object, but is ", j.type_name()), &j));
3720      }
3721      ConstructibleObjectType ret;
3722      const auto* inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
3723      using value_type = typename ConstructibleObjectType::value_type;
3724      std::transform(
3725          inner_object->begin(), inner_object->end(),
3726          std::inserter(ret, ret.begin()),
3727          [](typename BasicJsonType::object_t::value_type const & p)
3728      {
3729          return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
3730      });
3731      obj = std::move(ret);
3732  }
3733  template < typename BasicJsonType, typename ArithmeticType,
3734             enable_if_t <
3735                 std::is_arithmetic<ArithmeticType>::value&&
3736                 !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&
3737                 !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&
3738                 !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&
3739                 !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
3740                 int > = 0 >
3741  inline void from_json(const BasicJsonType& j, ArithmeticType& val)
3742  {
3743      switch (static_cast<value_t>(j))
3744      {
3745          case value_t::number_unsigned:
3746          {
3747              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
3748              break;
3749          }
3750          case value_t::number_integer:
3751          {
3752              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
3753              break;
3754          }
3755          case value_t::number_float:
3756          {
3757              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
3758              break;
3759          }
3760          case value_t::boolean:
3761          {
3762              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
3763              break;
3764          }
3765          case value_t::null:
3766          case value_t::object:
3767          case value_t::array:
3768          case value_t::string:
3769          case value_t::binary:
3770          case value_t::discarded:
3771          default:
3772              JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
3773      }
3774  }
3775  template<typename BasicJsonType, typename... Args, std::size_t... Idx>
3776  std::tuple<Args...> from_json_tuple_impl_base(BasicJsonType&& j, index_sequence<Idx...> &bsol;*unused*/)
3777  {
3778      return std::make_tuple(std::forward<BasicJsonType>(j).at(Idx).template get<Args>()...);
3779  }
3780  template < typename BasicJsonType, class A1, class A2 >
3781  std::pair<A1, A2> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::pair<A1, A2>> &bsol;*unused*/, priority_tag<0> &bsol;*unused*/)
3782  {
3783      return {std::forward<BasicJsonType>(j).at(0).template get<A1>(),
3784              std::forward<BasicJsonType>(j).at(1).template get<A2>()};
3785  }
3786  template<typename BasicJsonType, typename A1, typename A2>
3787  inline void from_json_tuple_impl(BasicJsonType&& j, std::pair<A1, A2>& p, priority_tag<1> &bsol;*unused*/)
3788  {
3789      p = from_json_tuple_impl(std::forward<BasicJsonType>(j), identity_tag<std::pair<A1, A2>> {}, priority_tag<0> {});
3790  }
3791  template<typename BasicJsonType, typename... Args>
3792  std::tuple<Args...> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::tuple<Args...>> &bsol;*unused*/, priority_tag<2> &bsol;*unused*/)
3793  {
3794      return from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
3795  }
3796  template<typename BasicJsonType, typename... Args>
3797  inline void from_json_tuple_impl(BasicJsonType&& j, std::tuple<Args...>& t, priority_tag<3> &bsol;*unused*/)
3798  {
3799      t = from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
3800  }
3801  template<typename BasicJsonType, typename TupleRelated>
3802  auto from_json(BasicJsonType&& j, TupleRelated&& t)
3803  -> decltype(from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {}))
3804  {
3805      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3806      {
3807          JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
3808      }
3809      return from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {});
3810  }
3811  template < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
3812             typename = enable_if_t < !std::is_constructible <
3813                                          typename BasicJsonType::string_t, Key >::value >>
3814  inline void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
3815  {
3816      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3817      {
3818          JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
3819      }
3820      m.clear();
3821      for (const auto& p : j)
3822      {
3823          if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
3824          {
3825              JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
3826          }
3827          m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
3828      }
3829  }
3830  template < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
3831             typename = enable_if_t < !std::is_constructible <
3832                                          typename BasicJsonType::string_t, Key >::value >>
3833  inline void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
3834  {
3835      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3836      {
3837          JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
3838      }
3839      m.clear();
3840      for (const auto& p : j)
3841      {
3842          if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
3843          {
3844              JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
3845          }
3846          m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
3847      }
3848  }
3849  #if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
3850  template<typename BasicJsonType>
3851  inline void from_json(const BasicJsonType& j, std_fs::path& p)
3852  {
3853      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3854      {
3855          JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
3856      }
3857      p = *j.template get_ptr<const typename BasicJsonType::string_t*>();
3858  }
3859  #endif
3860  struct from_json_fn
3861  {
3862      template<typename BasicJsonType, typename T>
3863      auto operator()(const BasicJsonType& j, T&& val) const
3864      noexcept(noexcept(from_json(j, std::forward<T>(val))))
3865      -> decltype(from_json(j, std::forward<T>(val)))
3866      {
3867          return from_json(j, std::forward<T>(val));
3868      }
3869  };
3870  }  
3871  #ifndef JSON_HAS_CPP_17
3872  namespace 
3873  {
3874  #endif
3875  JSON_INLINE_VARIABLE constexpr const auto& from_json = 
3876      detail::static_const<detail::from_json_fn>::value;
3877  #ifndef JSON_HAS_CPP_17
3878  }  
3879  #endif
3880  NLOHMANN_JSON_NAMESPACE_END
3881  #include <algorithm> 
3882  #include <iterator> 
3883  #include <string> 
3884  #include <tuple> 
3885  #include <type_traits> 
3886  #include <utility> 
3887  #include <valarray> 
3888  #include <vector> 
3889  #include <cstddef> 
3890  #include <iterator> 
3891  #include <string> 
3892  #include <tuple> 
3893  #include <utility> 
3894  #if JSON_HAS_RANGES
3895      #include <ranges> 
3896  #endif
3897  NLOHMANN_JSON_NAMESPACE_BEGIN
3898  namespace detail
3899  {
3900  template<typename string_type>
3901  void int_to_string( string_type& target, std::size_t value )
3902  {
3903      using std::to_string;
3904      target = to_string(value);
3905  }
3906  template<typename IteratorType> class iteration_proxy_value
3907  {
3908    public:
3909      using difference_type = std::ptrdiff_t;
3910      using value_type = iteration_proxy_value;
3911      using pointer = value_type *;
3912      using reference = value_type &;
3913      using iterator_category = std::input_iterator_tag;
3914      using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;
3915    private:
3916      IteratorType anchor{};
3917      std::size_t array_index = 0;
3918      mutable std::size_t array_index_last = 0;
3919      mutable string_type array_index_str = "0";
3920      string_type empty_str{};
3921    public:
3922      explicit iteration_proxy_value() = default;
3923      explicit iteration_proxy_value(IteratorType it, std::size_t array_index_ = 0)
3924      noexcept(std::is_nothrow_move_constructible<IteratorType>::value
3925               && std::is_nothrow_default_constructible<string_type>::value)
3926          : anchor(std::move(it))
3927          , array_index(array_index_)
3928      {}
3929      iteration_proxy_value(iteration_proxy_value const&) = default;
3930      iteration_proxy_value& operator=(iteration_proxy_value const&) = default;
3931      iteration_proxy_value(iteration_proxy_value&&)
3932      noexcept(std::is_nothrow_move_constructible<IteratorType>::value
3933               && std::is_nothrow_move_constructible<string_type>::value) = default;
3934      iteration_proxy_value& operator=(iteration_proxy_value&&)
3935      noexcept(std::is_nothrow_move_assignable<IteratorType>::value
3936               && std::is_nothrow_move_assignable<string_type>::value) = default;
3937      ~iteration_proxy_value() = default;
3938      const iteration_proxy_value& operator*() const
3939      {
3940          return *this;
3941      }
3942      iteration_proxy_value& operator++()
3943      {
3944          ++anchor;
3945          ++array_index;
3946          return *this;
3947      }
3948      iteration_proxy_value operator++(int)& 
3949      {
3950          auto tmp = iteration_proxy_value(anchor, array_index);
3951          ++anchor;
3952          ++array_index;
3953          return tmp;
3954      }
3955      bool operator==(const iteration_proxy_value& o) const
3956      {
3957          return anchor == o.anchor;
3958      }
3959      bool operator!=(const iteration_proxy_value& o) const
3960      {
3961          return anchor != o.anchor;
3962      }
3963      const string_type& key() const
3964      {
3965          JSON_ASSERT(anchor.m_object != nullptr);
3966          switch (anchor.m_object->type())
3967          {
3968              case value_t::array:
3969              {
3970                  if (array_index != array_index_last)
3971                  {
3972                      int_to_string( array_index_str, array_index );
3973                      array_index_last = array_index;
3974                  }
3975                  return array_index_str;
3976              }
3977              case value_t::object:
3978                  return anchor.key();
3979              case value_t::null:
3980              case value_t::string:
3981              case value_t::boolean:
3982              case value_t::number_integer:
3983              case value_t::number_unsigned:
3984              case value_t::number_float:
3985              case value_t::binary:
3986              case value_t::discarded:
3987              default:
3988                  return empty_str;
3989          }
3990      }
3991      typename IteratorType::reference value() const
3992      {
3993          return anchor.value();
3994      }
3995  };
3996  template<typename IteratorType> class iteration_proxy
3997  {
3998    private:
3999      typename IteratorType::pointer container = nullptr;
4000    public:
4001      explicit iteration_proxy() = default;
4002      explicit iteration_proxy(typename IteratorType::reference cont) noexcept
4003          : container(&cont) {}
4004      iteration_proxy(iteration_proxy const&) = default;
4005      iteration_proxy& operator=(iteration_proxy const&) = default;
4006      iteration_proxy(iteration_proxy&&) noexcept = default;
4007      iteration_proxy& operator=(iteration_proxy&&) noexcept = default;
4008      ~iteration_proxy() = default;
4009      iteration_proxy_value<IteratorType> begin() const noexcept
4010      {
4011          return iteration_proxy_value<IteratorType>(container->begin());
4012      }
4013      iteration_proxy_value<IteratorType> end() const noexcept
4014      {
4015          return iteration_proxy_value<IteratorType>(container->end());
4016      }
4017  };
4018  template<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
4019  auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
4020  {
4021      return i.key();
4022  }
4023  template<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
4024  auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
4025  {
4026      return i.value();
4027  }
4028  }  
4029  NLOHMANN_JSON_NAMESPACE_END
4030  namespace std
4031  {
4032  #if defined(__clang__)
4033      #pragma clang diagnostic push
4034      #pragma clang diagnostic ignored "-Wmismatched-tags"
4035  #endif
4036  template<typename IteratorType>
4037  class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>>
4038              : public std::integral_constant<std::size_t, 2> {};
4039  template<std::size_t N, typename IteratorType>
4040  class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >>
4041  {
4042    public:
4043      using type = decltype(
4044                       get<N>(std::declval <
4045                              ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
4046  };
4047  #if defined(__clang__)
4048      #pragma clang diagnostic pop
4049  #endif
4050  }  
4051  #if JSON_HAS_RANGES
4052      template <typename IteratorType>
4053      inline constexpr bool ::std::ranges::enable_borrowed_range<::nlohmann::detail::iteration_proxy<IteratorType>> = true;
4054  #endif
4055  NLOHMANN_JSON_NAMESPACE_BEGIN
4056  namespace detail
4057  {
4058  template<value_t> struct external_constructor;
4059  template<>
4060  struct external_constructor<value_t::boolean>
4061  {
4062      template<typename BasicJsonType>
4063      static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
4064      {
4065          j.m_value.destroy(j.m_type);
4066          j.m_type = value_t::boolean;
4067          j.m_value = b;
4068          j.assert_invariant();
4069      }
4070  };
4071  template<>
4072  struct external_constructor<value_t::string>
4073  {
4074      template<typename BasicJsonType>
4075      static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
4076      {
4077          j.m_value.destroy(j.m_type);
4078          j.m_type = value_t::string;
4079          j.m_value = s;
4080          j.assert_invariant();
4081      }
4082      template<typename BasicJsonType>
4083      static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
4084      {
4085          j.m_value.destroy(j.m_type);
4086          j.m_type = value_t::string;
4087          j.m_value = std::move(s);
4088          j.assert_invariant();
4089      }
4090      template < typename BasicJsonType, typename CompatibleStringType,
4091                 enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
4092                               int > = 0 >
4093      static void construct(BasicJsonType& j, const CompatibleStringType& str)
4094      {
4095          j.m_value.destroy(j.m_type);
4096          j.m_type = value_t::string;
4097          j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
4098          j.assert_invariant();
4099      }
4100  };
4101  template<>
4102  struct external_constructor<value_t::binary>
4103  {
4104      template<typename BasicJsonType>
4105      static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)
4106      {
4107          j.m_value.destroy(j.m_type);
4108          j.m_type = value_t::binary;
4109          j.m_value = typename BasicJsonType::binary_t(b);
4110          j.assert_invariant();
4111      }
4112      template<typename BasicJsonType>
4113      static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)
4114      {
4115          j.m_value.destroy(j.m_type);
4116          j.m_type = value_t::binary;
4117          j.m_value = typename BasicJsonType::binary_t(std::move(b));
4118          j.assert_invariant();
4119      }
4120  };
4121  template<>
4122  struct external_constructor<value_t::number_float>
4123  {
4124      template<typename BasicJsonType>
4125      static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
4126      {
4127          j.m_value.destroy(j.m_type);
4128          j.m_type = value_t::number_float;
4129          j.m_value = val;
4130          j.assert_invariant();
4131      }
4132  };
4133  template<>
4134  struct external_constructor<value_t::number_unsigned>
4135  {
4136      template<typename BasicJsonType>
4137      static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
4138      {
4139          j.m_value.destroy(j.m_type);
4140          j.m_type = value_t::number_unsigned;
4141          j.m_value = val;
4142          j.assert_invariant();
4143      }
4144  };
4145  template<>
4146  struct external_constructor<value_t::number_integer>
4147  {
4148      template<typename BasicJsonType>
4149      static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
4150      {
4151          j.m_value.destroy(j.m_type);
4152          j.m_type = value_t::number_integer;
4153          j.m_value = val;
4154          j.assert_invariant();
4155      }
4156  };
4157  template<>
4158  struct external_constructor<value_t::array>
4159  {
4160      template<typename BasicJsonType>
4161      static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
4162      {
4163          j.m_value.destroy(j.m_type);
4164          j.m_type = value_t::array;
4165          j.m_value = arr;
4166          j.set_parents();
4167          j.assert_invariant();
4168      }
4169      template<typename BasicJsonType>
4170      static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
4171      {
4172          j.m_value.destroy(j.m_type);
4173          j.m_type = value_t::array;
4174          j.m_value = std::move(arr);
4175          j.set_parents();
4176          j.assert_invariant();
4177      }
4178      template < typename BasicJsonType, typename CompatibleArrayType,
4179                 enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
4180                               int > = 0 >
4181      static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
4182      {
4183          using std::begin;
4184          using std::end;
4185          j.m_value.destroy(j.m_type);
4186          j.m_type = value_t::array;
4187          j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
4188          j.set_parents();
4189          j.assert_invariant();
4190      }
4191      template<typename BasicJsonType>
4192      static void construct(BasicJsonType& j, const std::vector<bool>& arr)
4193      {
4194          j.m_value.destroy(j.m_type);
4195          j.m_type = value_t::array;
4196          j.m_value = value_t::array;
4197          j.m_value.array->reserve(arr.size());
4198          for (const bool x : arr)
4199          {
4200              j.m_value.array->push_back(x);
4201              j.set_parent(j.m_value.array->back());
4202          }
4203          j.assert_invariant();
4204      }
4205      template<typename BasicJsonType, typename T,
4206               enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
4207      static void construct(BasicJsonType& j, const std::valarray<T>& arr)
4208      {
4209          j.m_value.destroy(j.m_type);
4210          j.m_type = value_t::array;
4211          j.m_value = value_t::array;
4212          j.m_value.array->resize(arr.size());
4213          if (arr.size() > 0)
4214          {
4215              std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
4216          }
4217          j.set_parents();
4218          j.assert_invariant();
4219      }
4220  };
4221  template<>
4222  struct external_constructor<value_t::object>
4223  {
4224      template<typename BasicJsonType>
4225      static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
4226      {
4227          j.m_value.destroy(j.m_type);
4228          j.m_type = value_t::object;
4229          j.m_value = obj;
4230          j.set_parents();
4231          j.assert_invariant();
4232      }
4233      template<typename BasicJsonType>
4234      static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
4235      {
4236          j.m_value.destroy(j.m_type);
4237          j.m_type = value_t::object;
4238          j.m_value = std::move(obj);
4239          j.set_parents();
4240          j.assert_invariant();
4241      }
4242      template < typename BasicJsonType, typename CompatibleObjectType,
4243                 enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >
4244      static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
4245      {
4246          using std::begin;
4247          using std::end;
4248          j.m_value.destroy(j.m_type);
4249          j.m_type = value_t::object;
4250          j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
4251          j.set_parents();
4252          j.assert_invariant();
4253      }
4254  };
4255  template<typename BasicJsonType, typename T,
4256           enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
4257  inline void to_json(BasicJsonType& j, T b) noexcept
4258  {
4259      external_constructor<value_t::boolean>::construct(j, b);
4260  }
4261  template < typename BasicJsonType, typename BoolRef,
4262             enable_if_t <
4263                 ((std::is_same<std::vector<bool>::reference, BoolRef>::value
4264                   && !std::is_same <std::vector<bool>::reference, typename BasicJsonType::boolean_t&>::value)
4265                  || (std::is_same<std::vector<bool>::const_reference, BoolRef>::value
4266                      && !std::is_same <detail::uncvref_t<std::vector<bool>::const_reference>,
4267                                        typename BasicJsonType::boolean_t >::value))
4268                 && std::is_convertible<const BoolRef&, typename BasicJsonType::boolean_t>::value, int > = 0 >
4269  inline void to_json(BasicJsonType& j, const BoolRef& b) noexcept
4270  {
4271      external_constructor<value_t::boolean>::construct(j, static_cast<typename BasicJsonType::boolean_t>(b));
4272  }
4273  template<typename BasicJsonType, typename CompatibleString,
4274           enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
4275  inline void to_json(BasicJsonType& j, const CompatibleString& s)
4276  {
4277      external_constructor<value_t::string>::construct(j, s);
4278  }
4279  template<typename BasicJsonType>
4280  inline void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
4281  {
4282      external_constructor<value_t::string>::construct(j, std::move(s));
4283  }
4284  template<typename BasicJsonType, typename FloatType,
4285           enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
4286  inline void to_json(BasicJsonType& j, FloatType val) noexcept
4287  {
4288      external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
4289  }
4290  template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
4291           enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
4292  inline void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
4293  {
4294      external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
4295  }
4296  template<typename BasicJsonType, typename CompatibleNumberIntegerType,
4297           enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
4298  inline void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
4299  {
4300      external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
4301  }
4302  #if !JSON_DISABLE_ENUM_SERIALIZATION
4303  template<typename BasicJsonType, typename EnumType,
4304           enable_if_t<std::is_enum<EnumType>::value, int> = 0>
4305  inline void to_json(BasicJsonType& j, EnumType e) noexcept
4306  {
4307      using underlying_type = typename std::underlying_type<EnumType>::type;
4308      external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
4309  }
4310  #endif  
4311  template<typename BasicJsonType>
4312  inline void to_json(BasicJsonType& j, const std::vector<bool>& e)
4313  {
4314      external_constructor<value_t::array>::construct(j, e);
4315  }
4316  template < typename BasicJsonType, typename CompatibleArrayType,
4317             enable_if_t < is_compatible_array_type<BasicJsonType,
4318                           CompatibleArrayType>::value&&
4319                           !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&
4320                           !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&
4321                           !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&
4322                           !is_basic_json<CompatibleArrayType>::value,
4323                           int > = 0 >
4324  inline void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
4325  {
4326      external_constructor<value_t::array>::construct(j, arr);
4327  }
4328  template<typename BasicJsonType>
4329  inline void to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)
4330  {
4331      external_constructor<value_t::binary>::construct(j, bin);
4332  }
4333  template<typename BasicJsonType, typename T,
4334           enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
4335  inline void to_json(BasicJsonType& j, const std::valarray<T>& arr)
4336  {
4337      external_constructor<value_t::array>::construct(j, std::move(arr));
4338  }
4339  template<typename BasicJsonType>
4340  inline void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
4341  {
4342      external_constructor<value_t::array>::construct(j, std::move(arr));
4343  }
4344  template < typename BasicJsonType, typename CompatibleObjectType,
4345             enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >
4346  inline void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
4347  {
4348      external_constructor<value_t::object>::construct(j, obj);
4349  }
4350  template<typename BasicJsonType>
4351  inline void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
4352  {
4353      external_constructor<value_t::object>::construct(j, std::move(obj));
4354  }
4355  template <
4356      typename BasicJsonType, typename T, std::size_t N,
4357      enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,
4358                    const T(&)[N]>::value, 
4359                    int > = 0 >
4360  inline void to_json(BasicJsonType& j, const T(&arr)[N]) 
4361  {
4362      external_constructor<value_t::array>::construct(j, arr);
4363  }
4364  template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >
4365  inline void to_json(BasicJsonType& j, const std::pair<T1, T2>& p)
4366  {
4367      j = { p.first, p.second };
4368  }
4369  template<typename BasicJsonType, typename T,
4370           enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
4371  inline void to_json(BasicJsonType& j, const T& b)
4372  {
4373      j = { {b.key(), b.value()} };
4374  }
4375  template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
4376  inline void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> &bsol;*unused*/)
4377  {
4378      j = { std::get<Idx>(t)... };
4379  }
4380  template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>
4381  inline void to_json(BasicJsonType& j, const T& t)
4382  {
4383      to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});
4384  }
4385  #if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
4386  template<typename BasicJsonType>
4387  inline void to_json(BasicJsonType& j, const std_fs::path& p)
4388  {
4389      j = p.string();
4390  }
4391  #endif
4392  struct to_json_fn
4393  {
4394      template<typename BasicJsonType, typename T>
4395      auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
4396      -> decltype(to_json(j, std::forward<T>(val)), void())
4397      {
4398          return to_json(j, std::forward<T>(val));
4399      }
4400  };
4401  }  
4402  #ifndef JSON_HAS_CPP_17
4403  namespace 
4404  {
4405  #endif
4406  JSON_INLINE_VARIABLE constexpr const auto& to_json = 
4407      detail::static_const<detail::to_json_fn>::value;
4408  #ifndef JSON_HAS_CPP_17
4409  }  
4410  #endif
4411  NLOHMANN_JSON_NAMESPACE_END
4412  NLOHMANN_JSON_NAMESPACE_BEGIN
4413  template<typename ValueType, typename>
4414  struct adl_serializer
4415  {
4416      template<typename BasicJsonType, typename TargetType = ValueType>
4417      static auto from_json(BasicJsonType && j, TargetType& val) noexcept(
4418          noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
4419      -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
4420      {
4421          ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
4422      }
4423      template<typename BasicJsonType, typename TargetType = ValueType>
4424      static auto from_json(BasicJsonType && j) noexcept(
4425      noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {})))
4426      -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {}))
4427      {
4428          return ::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {});
4429      }
4430      template<typename BasicJsonType, typename TargetType = ValueType>
4431      static auto to_json(BasicJsonType& j, TargetType && val) noexcept(
4432          noexcept(::nlohmann::to_json(j, std::forward<TargetType>(val))))
4433      -> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())
4434      {
4435          ::nlohmann::to_json(j, std::forward<TargetType>(val));
4436      }
4437  };
4438  NLOHMANN_JSON_NAMESPACE_END
4439  #include <cstdint> 
4440  #include <tuple> 
4441  #include <utility> 
4442  NLOHMANN_JSON_NAMESPACE_BEGIN
4443  template<typename BinaryType>
4444  class byte_container_with_subtype : public BinaryType
4445  {
4446    public:
4447      using container_type = BinaryType;
4448      using subtype_type = std::uint64_t;
4449      byte_container_with_subtype() noexcept(noexcept(container_type()))
4450          : container_type()
4451      {}
4452      byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))
4453          : container_type(b)
4454      {}
4455      byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))
4456          : container_type(std::move(b))
4457      {}
4458      byte_container_with_subtype(const container_type& b, subtype_type subtype_) noexcept(noexcept(container_type(b)))
4459          : container_type(b)
4460          , m_subtype(subtype_)
4461          , m_has_subtype(true)
4462      {}
4463      byte_container_with_subtype(container_type&& b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))
4464          : container_type(std::move(b))
4465          , m_subtype(subtype_)
4466          , m_has_subtype(true)
4467      {}
4468      bool operator==(const byte_container_with_subtype& rhs) const
4469      {
4470          return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==
4471                 std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);
4472      }
4473      bool operator!=(const byte_container_with_subtype& rhs) const
4474      {
4475          return !(rhs == *this);
4476      }
4477      void set_subtype(subtype_type subtype_) noexcept
4478      {
4479          m_subtype = subtype_;
4480          m_has_subtype = true;
4481      }
4482      constexpr subtype_type subtype() const noexcept
4483      {
4484          return m_has_subtype ? m_subtype : static_cast<subtype_type>(-1);
4485      }
4486      constexpr bool has_subtype() const noexcept
4487      {
4488          return m_has_subtype;
4489      }
4490      void clear_subtype() noexcept
4491      {
4492          m_subtype = 0;
4493          m_has_subtype = false;
4494      }
4495    private:
4496      subtype_type m_subtype = 0;
4497      bool m_has_subtype = false;
4498  };
4499  NLOHMANN_JSON_NAMESPACE_END
4500  #include <cstdint> 
4501  #include <cstddef> 
4502  #include <functional> 
4503  NLOHMANN_JSON_NAMESPACE_BEGIN
4504  namespace detail
4505  {
4506  inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
4507  {
4508      seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);
4509      return seed;
4510  }
4511  template<typename BasicJsonType>
4512  std::size_t hash(const BasicJsonType& j)
4513  {
4514      using string_t = typename BasicJsonType::string_t;
4515      using number_integer_t = typename BasicJsonType::number_integer_t;
4516      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4517      using number_float_t = typename BasicJsonType::number_float_t;
4518      const auto type = static_cast<std::size_t>(j.type());
4519      switch (j.type())
4520      {
4521          case BasicJsonType::value_t::null:
4522          case BasicJsonType::value_t::discarded:
4523          {
4524              return combine(type, 0);
4525          }
4526          case BasicJsonType::value_t::object:
4527          {
4528              auto seed = combine(type, j.size());
4529              for (const auto& element : j.items())
4530              {
4531                  const auto h = std::hash<string_t> {}(element.key());
4532                  seed = combine(seed, h);
4533                  seed = combine(seed, hash(element.value()));
4534              }
4535              return seed;
4536          }
4537          case BasicJsonType::value_t::array:
4538          {
4539              auto seed = combine(type, j.size());
4540              for (const auto& element : j)
4541              {
4542                  seed = combine(seed, hash(element));
4543              }
4544              return seed;
4545          }
4546          case BasicJsonType::value_t::string:
4547          {
4548              const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());
4549              return combine(type, h);
4550          }
4551          case BasicJsonType::value_t::boolean:
4552          {
4553              const auto h = std::hash<bool> {}(j.template get<bool>());
4554              return combine(type, h);
4555          }
4556          case BasicJsonType::value_t::number_integer:
4557          {
4558              const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());
4559              return combine(type, h);
4560          }
4561          case BasicJsonType::value_t::number_unsigned:
4562          {
4563              const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());
4564              return combine(type, h);
4565          }
4566          case BasicJsonType::value_t::number_float:
4567          {
4568              const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());
4569              return combine(type, h);
4570          }
4571          case BasicJsonType::value_t::binary:
4572          {
4573              auto seed = combine(type, j.get_binary().size());
4574              const auto h = std::hash<bool> {}(j.get_binary().has_subtype());
4575              seed = combine(seed, h);
4576              seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));
4577              for (const auto byte : j.get_binary())
4578              {
4579                  seed = combine(seed, std::hash<std::uint8_t> {}(byte));
4580              }
4581              return seed;
4582          }
4583          default:                   
4584              JSON_ASSERT(false); 
4585              return 0;              
4586      }
4587  }
4588  }  
4589  NLOHMANN_JSON_NAMESPACE_END
4590  #include <algorithm> 
4591  #include <array> 
4592  #include <cmath> 
4593  #include <cstddef> 
4594  #include <cstdint> 
4595  #include <cstdio> 
4596  #include <cstring> 
4597  #include <iterator> 
4598  #include <limits> 
4599  #include <string> 
4600  #include <utility> 
4601  #include <vector> 
4602  #include <array> 
4603  #include <cstddef> 
4604  #include <cstring> 
4605  #include <iterator> 
4606  #include <memory> 
4607  #include <numeric> 
4608  #include <string> 
4609  #include <type_traits> 
4610  #include <utility> 
4611  #ifndef JSON_NO_IO
4612      #include <cstdio>   
4613      #include <istream>  
4614  #endif                  
4615  NLOHMANN_JSON_NAMESPACE_BEGIN
4616  namespace detail
4617  {
4618  enum class input_format_t { json, cbor, msgpack, ubjson, bson, bjdata };
4619  #ifndef JSON_NO_IO
4620  class file_input_adapter
4621  {
4622    public:
4623      using char_type = char;
4624      JSON_HEDLEY_NON_NULL(2)
4625      explicit file_input_adapter(std::FILE* f) noexcept
4626          : m_file(f)
4627      {
4628          JSON_ASSERT(m_file != nullptr);
4629      }
4630      file_input_adapter(const file_input_adapter&) = delete;
4631      file_input_adapter(file_input_adapter&&) noexcept = default;
4632      file_input_adapter& operator=(const file_input_adapter&) = delete;
4633      file_input_adapter& operator=(file_input_adapter&&) = delete;
4634      ~file_input_adapter() = default;
4635      std::char_traits<char>::int_type get_character() noexcept
4636      {
4637          return std::fgetc(m_file);
4638      }
4639    private:
4640      std::FILE* m_file;
4641  };
4642  class input_stream_adapter
4643  {
4644    public:
4645      using char_type = char;
4646      ~input_stream_adapter()
4647      {
4648          if (is != nullptr)
4649          {
4650              is->clear(is->rdstate() & std::ios::eofbit);
4651          }
4652      }
4653      explicit input_stream_adapter(std::istream& i)
4654          : is(&i), sb(i.rdbuf())
4655      {}
4656      input_stream_adapter(const input_stream_adapter&) = delete;
4657      input_stream_adapter& operator=(input_stream_adapter&) = delete;
4658      input_stream_adapter& operator=(input_stream_adapter&&) = delete;
4659      input_stream_adapter(input_stream_adapter&& rhs) noexcept
4660          : is(rhs.is), sb(rhs.sb)
4661      {
4662          rhs.is = nullptr;
4663          rhs.sb = nullptr;
4664      }
4665      std::char_traits<char>::int_type get_character()
4666      {
4667          auto res = sb->sbumpc();
4668          if (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))
4669          {
4670              is->clear(is->rdstate() | std::ios::eofbit);
4671          }
4672          return res;
4673      }
4674    private:
4675      std::istream* is = nullptr;
4676      std::streambuf* sb = nullptr;
4677  };
4678  #endif  
4679  template<typename IteratorType>
4680  class iterator_input_adapter
4681  {
4682    public:
4683      using char_type = typename std::iterator_traits<IteratorType>::value_type;
4684      iterator_input_adapter(IteratorType first, IteratorType last)
4685          : current(std::move(first)), end(std::move(last))
4686      {}
4687      typename std::char_traits<char_type>::int_type get_character()
4688      {
4689          if (JSON_HEDLEY_LIKELY(current != end))
4690          {
4691              auto result = std::char_traits<char_type>::to_int_type(*current);
4692              std::advance(current, 1);
4693              return result;
4694          }
4695          return std::char_traits<char_type>::eof();
4696      }
4697    private:
4698      IteratorType current;
4699      IteratorType end;
4700      template<typename BaseInputAdapter, size_t T>
4701      friend struct wide_string_input_helper;
4702      bool empty() const
4703      {
4704          return current == end;
4705      }
4706  };
4707  template<typename BaseInputAdapter, size_t T>
4708  struct wide_string_input_helper;
4709  template<typename BaseInputAdapter>
4710  struct wide_string_input_helper<BaseInputAdapter, 4>
4711  {
4712      static void fill_buffer(BaseInputAdapter& input,
4713                              std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
4714                              size_t& utf8_bytes_index,
4715                              size_t& utf8_bytes_filled)
4716      {
4717          utf8_bytes_index = 0;
4718          if (JSON_HEDLEY_UNLIKELY(input.empty()))
4719          {
4720              utf8_bytes[0] = std::char_traits<char>::eof();
4721              utf8_bytes_filled = 1;
4722          }
4723          else
4724          {
4725              const auto wc = input.get_character();
4726              if (wc < 0x80)
4727              {
4728                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
4729                  utf8_bytes_filled = 1;
4730              }
4731              else if (wc <= 0x7FF)
4732              {
4733                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));
4734                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4735                  utf8_bytes_filled = 2;
4736              }
4737              else if (wc <= 0xFFFF)
4738              {
4739                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));
4740                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
4741                  utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4742                  utf8_bytes_filled = 3;
4743              }
4744              else if (wc <= 0x10FFFF)
4745              {
4746                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));
4747                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));
4748                  utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
4749                  utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4750                  utf8_bytes_filled = 4;
4751              }
4752              else
4753              {
4754                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
4755                  utf8_bytes_filled = 1;
4756              }
4757          }
4758      }
4759  };
4760  template<typename BaseInputAdapter>
4761  struct wide_string_input_helper<BaseInputAdapter, 2>
4762  {
4763      static void fill_buffer(BaseInputAdapter& input,
4764                              std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
4765                              size_t& utf8_bytes_index,
4766                              size_t& utf8_bytes_filled)
4767      {
4768          utf8_bytes_index = 0;
4769          if (JSON_HEDLEY_UNLIKELY(input.empty()))
4770          {
4771              utf8_bytes[0] = std::char_traits<char>::eof();
4772              utf8_bytes_filled = 1;
4773          }
4774          else
4775          {
4776              const auto wc = input.get_character();
4777              if (wc < 0x80)
4778              {
4779                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
4780                  utf8_bytes_filled = 1;
4781              }
4782              else if (wc <= 0x7FF)
4783              {
4784                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));
4785                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4786                  utf8_bytes_filled = 2;
4787              }
4788              else if (0xD800 > wc || wc >= 0xE000)
4789              {
4790                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));
4791                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
4792                  utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4793                  utf8_bytes_filled = 3;
4794              }
4795              else
4796              {
4797                  if (JSON_HEDLEY_UNLIKELY(!input.empty()))
4798                  {
4799                      const auto wc2 = static_cast<unsigned int>(input.get_character());
4800                      const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
4801                      utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
4802                      utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
4803                      utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
4804                      utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
4805                      utf8_bytes_filled = 4;
4806                  }
4807                  else
4808                  {
4809                      utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
4810                      utf8_bytes_filled = 1;
4811                  }
4812              }
4813          }
4814      }
4815  };
4816  template<typename BaseInputAdapter, typename WideCharType>
4817  class wide_string_input_adapter
4818  {
4819    public:
4820      using char_type = char;
4821      wide_string_input_adapter(BaseInputAdapter base)
4822          : base_adapter(base) {}
4823      typename std::char_traits<char>::int_type get_character() noexcept
4824      {
4825          if (utf8_bytes_index == utf8_bytes_filled)
4826          {
4827              fill_buffer<sizeof(WideCharType)>();
4828              JSON_ASSERT(utf8_bytes_filled > 0);
4829              JSON_ASSERT(utf8_bytes_index == 0);
4830          }
4831          JSON_ASSERT(utf8_bytes_filled > 0);
4832          JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);
4833          return utf8_bytes[utf8_bytes_index++];
4834      }
4835    private:
4836      BaseInputAdapter base_adapter;
4837      template<size_t T>
4838      void fill_buffer()
4839      {
4840          wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
4841      }
4842      std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};
4843      std::size_t utf8_bytes_index = 0;
4844      std::size_t utf8_bytes_filled = 0;
4845  };
4846  template<typename IteratorType, typename Enable = void>
4847  struct iterator_input_adapter_factory
4848  {
4849      using iterator_type = IteratorType;
4850      using char_type = typename std::iterator_traits<iterator_type>::value_type;
4851      using adapter_type = iterator_input_adapter<iterator_type>;
4852      static adapter_type create(IteratorType first, IteratorType last)
4853      {
4854          return adapter_type(std::move(first), std::move(last));
4855      }
4856  };
4857  template<typename T>
4858  struct is_iterator_of_multibyte
4859  {
4860      using value_type = typename std::iterator_traits<T>::value_type;
4861      enum
4862      {
4863          value = sizeof(value_type) > 1
4864      };
4865  };
4866  template<typename IteratorType>
4867  struct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>
4868  {
4869      using iterator_type = IteratorType;
4870      using char_type = typename std::iterator_traits<iterator_type>::value_type;
4871      using base_adapter_type = iterator_input_adapter<iterator_type>;
4872      using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;
4873      static adapter_type create(IteratorType first, IteratorType last)
4874      {
4875          return adapter_type(base_adapter_type(std::move(first), std::move(last)));
4876      }
4877  };
4878  template<typename IteratorType>
4879  typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)
4880  {
4881      using factory_type = iterator_input_adapter_factory<IteratorType>;
4882      return factory_type::create(first, last);
4883  }
4884  namespace container_input_adapter_factory_impl
4885  {
4886  using std::begin;
4887  using std::end;
4888  template<typename ContainerType, typename Enable = void>
4889  struct container_input_adapter_factory {};
4890  template<typename ContainerType>
4891  struct container_input_adapter_factory< ContainerType,
4892         void_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>
4893         {
4894             using adapter_type = decltype(input_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));
4895             static adapter_type create(const ContainerType& container)
4896  {
4897      return input_adapter(begin(container), end(container));
4898  }
4899         };
4900  }  
4901  template<typename ContainerType>
4902  typename container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::adapter_type input_adapter(const ContainerType& container)
4903  {
4904      return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);
4905  }
4906  #ifndef JSON_NO_IO
4907  inline file_input_adapter input_adapter(std::FILE* file)
4908  {
4909      return file_input_adapter(file);
4910  }
4911  inline input_stream_adapter input_adapter(std::istream& stream)
4912  {
4913      return input_stream_adapter(stream);
4914  }
4915  inline input_stream_adapter input_adapter(std::istream&& stream)
4916  {
4917      return input_stream_adapter(stream);
4918  }
4919  #endif  
4920  using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));
4921  template < typename CharT,
4922             typename std::enable_if <
4923                 std::is_pointer<CharT>::value&&
4924                 !std::is_array<CharT>::value&&
4925                 std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
4926                 sizeof(typename std::remove_pointer<CharT>::type) == 1,
4927                 int >::type = 0 >
4928  contiguous_bytes_input_adapter input_adapter(CharT b)
4929  {
4930      auto length = std::strlen(reinterpret_cast<const char*>(b));
4931      const auto* ptr = reinterpret_cast<const char*>(b);
4932      return input_adapter(ptr, ptr + length);
4933  }
4934  template<typename T, std::size_t N>
4935  auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N)) 
4936  {
4937      return input_adapter(array, array + N);
4938  }
4939  class span_input_adapter
4940  {
4941    public:
4942      template < typename CharT,
4943                 typename std::enable_if <
4944                     std::is_pointer<CharT>::value&&
4945                     std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
4946                     sizeof(typename std::remove_pointer<CharT>::type) == 1,
4947                     int >::type = 0 >
4948      span_input_adapter(CharT b, std::size_t l)
4949          : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}
4950      template<class IteratorType,
4951               typename std::enable_if<
4952                   std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
4953                   int>::type = 0>
4954      span_input_adapter(IteratorType first, IteratorType last)
4955          : ia(input_adapter(first, last)) {}
4956      contiguous_bytes_input_adapter&& get()
4957      {
4958          return std::move(ia); 
4959      }
4960    private:
4961      contiguous_bytes_input_adapter ia;
4962  };
4963  }  
4964  NLOHMANN_JSON_NAMESPACE_END
4965  #include <cstddef>
4966  #include <string> 
4967  #include <utility> 
4968  #include <vector> 
4969  NLOHMANN_JSON_NAMESPACE_BEGIN
4970  template<typename BasicJsonType>
4971  struct json_sax
4972  {
4973      using number_integer_t = typename BasicJsonType::number_integer_t;
4974      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4975      using number_float_t = typename BasicJsonType::number_float_t;
4976      using string_t = typename BasicJsonType::string_t;
4977      using binary_t = typename BasicJsonType::binary_t;
4978      virtual bool null() = 0;
4979      virtual bool boolean(bool val) = 0;
4980      virtual bool number_integer(number_integer_t val) = 0;
4981      virtual bool number_unsigned(number_unsigned_t val) = 0;
4982      virtual bool number_float(number_float_t val, const string_t& s) = 0;
4983      virtual bool string(string_t& val) = 0;
4984      virtual bool binary(binary_t& val) = 0;
4985      virtual bool start_object(std::size_t elements) = 0;
4986      virtual bool key(string_t& val) = 0;
4987      virtual bool end_object() = 0;
4988      virtual bool start_array(std::size_t elements) = 0;
4989      virtual bool end_array() = 0;
4990      virtual bool parse_error(std::size_t position,
4991                               const std::string& last_token,
4992                               const detail::exception& ex) = 0;
4993      json_sax() = default;
4994      json_sax(const json_sax&) = default;
4995      json_sax(json_sax&&) noexcept = default;
4996      json_sax& operator=(const json_sax&) = default;
4997      json_sax& operator=(json_sax&&) noexcept = default;
4998      virtual ~json_sax() = default;
4999  };
5000  namespace detail
5001  {
5002  template<typename BasicJsonType>
5003  class json_sax_dom_parser
5004  {
5005    public:
5006      using number_integer_t = typename BasicJsonType::number_integer_t;
5007      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
5008      using number_float_t = typename BasicJsonType::number_float_t;
5009      using string_t = typename BasicJsonType::string_t;
5010      using binary_t = typename BasicJsonType::binary_t;
5011      explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
5012          : root(r), allow_exceptions(allow_exceptions_)
5013      {}
5014      json_sax_dom_parser(const json_sax_dom_parser&) = delete;
5015      json_sax_dom_parser(json_sax_dom_parser&&) = default; 
5016      json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
5017      json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default; 
5018      ~json_sax_dom_parser() = default;
5019      bool null()
5020      {
5021          handle_value(nullptr);
5022          return true;
5023      }
5024      bool boolean(bool val)
5025      {
5026          handle_value(val);
5027          return true;
5028      }
5029      bool number_integer(number_integer_t val)
5030      {
5031          handle_value(val);
5032          return true;
5033      }
5034      bool number_unsigned(number_unsigned_t val)
5035      {
5036          handle_value(val);
5037          return true;
5038      }
5039      bool number_float(number_float_t val, const string_t& &bsol;*unused*/)
5040      {
5041          handle_value(val);
5042          return true;
5043      }
5044      bool string(string_t& val)
5045      {
5046          handle_value(val);
5047          return true;
5048      }
5049      bool binary(binary_t& val)
5050      {
5051          handle_value(std::move(val));
5052          return true;
5053      }
5054      bool start_object(std::size_t len)
5055      {
5056          ref_stack.push_back(handle_value(BasicJsonType::value_t::object));
5057          if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
5058          {
5059              JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
5060          }
5061          return true;
5062      }
5063      bool key(string_t& val)
5064      {
5065          JSON_ASSERT(!ref_stack.empty());
5066          JSON_ASSERT(ref_stack.back()->is_object());
5067          object_element = &(ref_stack.back()->m_value.object->operator[](val));
5068          return true;
5069      }
5070      bool end_object()
5071      {
5072          JSON_ASSERT(!ref_stack.empty());
5073          JSON_ASSERT(ref_stack.back()->is_object());
5074          ref_stack.back()->set_parents();
5075          ref_stack.pop_back();
5076          return true;
5077      }
5078      bool start_array(std::size_t len)
5079      {
5080          ref_stack.push_back(handle_value(BasicJsonType::value_t::array));
5081          if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
5082          {
5083              JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
5084          }
5085          return true;
5086      }
5087      bool end_array()
5088      {
5089          JSON_ASSERT(!ref_stack.empty());
5090          JSON_ASSERT(ref_stack.back()->is_array());
5091          ref_stack.back()->set_parents();
5092          ref_stack.pop_back();
5093          return true;
5094      }
5095      template<class Exception>
5096      bool parse_error(std::size_t &bsol;*unused*/, const std::string& &bsol;*unused*/,
5097                       const Exception& ex)
5098      {
5099          errored = true;
5100          static_cast<void>(ex);
5101          if (allow_exceptions)
5102          {
5103              JSON_THROW(ex);
5104          }
5105          return false;
5106      }
5107      constexpr bool is_errored() const
5108      {
5109          return errored;
5110      }
5111    private:
5112      template<typename Value>
5113      JSON_HEDLEY_RETURNS_NON_NULL
5114      BasicJsonType* handle_value(Value&& v)
5115      {
5116          if (ref_stack.empty())
5117          {
5118              root = BasicJsonType(std::forward<Value>(v));
5119              return &root;
5120          }
5121          JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());
5122          if (ref_stack.back()->is_array())
5123          {
5124              ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
5125              return &(ref_stack.back()->m_value.array->back());
5126          }
5127          JSON_ASSERT(ref_stack.back()->is_object());
5128          JSON_ASSERT(object_element);
5129          *object_element = BasicJsonType(std::forward<Value>(v));
5130          return object_element;
5131      }
5132      BasicJsonType& root;
5133      std::vector<BasicJsonType*> ref_stack {};
5134      BasicJsonType* object_element = nullptr;
5135      bool errored = false;
5136      const bool allow_exceptions = true;
5137  };
5138  template<typename BasicJsonType>
5139  class json_sax_dom_callback_parser
5140  {
5141    public:
5142      using number_integer_t = typename BasicJsonType::number_integer_t;
5143      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
5144      using number_float_t = typename BasicJsonType::number_float_t;
5145      using string_t = typename BasicJsonType::string_t;
5146      using binary_t = typename BasicJsonType::binary_t;
5147      using parser_callback_t = typename BasicJsonType::parser_callback_t;
5148      using parse_event_t = typename BasicJsonType::parse_event_t;
5149      json_sax_dom_callback_parser(BasicJsonType& r,
5150                                   const parser_callback_t cb,
5151                                   const bool allow_exceptions_ = true)
5152          : root(r), callback(cb), allow_exceptions(allow_exceptions_)
5153      {
5154          keep_stack.push_back(true);
5155      }
5156      json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
5157      json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default; 
5158      json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
5159      json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default; 
5160      ~json_sax_dom_callback_parser() = default;
5161      bool null()
5162      {
5163          handle_value(nullptr);
5164          return true;
5165      }
5166      bool boolean(bool val)
5167      {
5168          handle_value(val);
5169          return true;
5170      }
5171      bool number_integer(number_integer_t val)
5172      {
5173          handle_value(val);
5174          return true;
5175      }
5176      bool number_unsigned(number_unsigned_t val)
5177      {
5178          handle_value(val);
5179          return true;
5180      }
5181      bool number_float(number_float_t val, const string_t& &bsol;*unused*/)
5182      {
5183          handle_value(val);
5184          return true;
5185      }
5186      bool string(string_t& val)
5187      {
5188          handle_value(val);
5189          return true;
5190      }
5191      bool binary(binary_t& val)
5192      {
5193          handle_value(std::move(val));
5194          return true;
5195      }
5196      bool start_object(std::size_t len)
5197      {
5198          const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
5199          keep_stack.push_back(keep);
5200          auto val = handle_value(BasicJsonType::value_t::object, true);
5201          ref_stack.push_back(val.second);
5202          if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
5203          {
5204              JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
5205          }
5206          return true;
5207      }
5208      bool key(string_t& val)
5209      {
5210          BasicJsonType k = BasicJsonType(val);
5211          const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
5212          key_keep_stack.push_back(keep);
5213          if (keep && ref_stack.back())
5214          {
5215              object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
5216          }
5217          return true;
5218      }
5219      bool end_object()
5220      {
5221          if (ref_stack.back())
5222          {
5223              if (!callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
5224              {
5225                  *ref_stack.back() = discarded;
5226              }
5227              else
5228              {
5229                  ref_stack.back()->set_parents();
5230              }
5231          }
5232          JSON_ASSERT(!ref_stack.empty());
5233          JSON_ASSERT(!keep_stack.empty());
5234          ref_stack.pop_back();
5235          keep_stack.pop_back();
5236          if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
5237          {
5238              for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
5239              {
5240                  if (it->is_discarded())
5241                  {
5242                      ref_stack.back()->erase(it);
5243                      break;
5244                  }
5245              }
5246          }
5247          return true;
5248      }
5249      bool start_array(std::size_t len)
5250      {
5251          const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
5252          keep_stack.push_back(keep);
5253          auto val = handle_value(BasicJsonType::value_t::array, true);
5254          ref_stack.push_back(val.second);
5255          if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
5256          {
5257              JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
5258          }
5259          return true;
5260      }
5261      bool end_array()
5262      {
5263          bool keep = true;
5264          if (ref_stack.back())
5265          {
5266              keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
5267              if (keep)
5268              {
5269                  ref_stack.back()->set_parents();
5270              }
5271              else
5272              {
5273                  *ref_stack.back() = discarded;
5274              }
5275          }
5276          JSON_ASSERT(!ref_stack.empty());
5277          JSON_ASSERT(!keep_stack.empty());
5278          ref_stack.pop_back();
5279          keep_stack.pop_back();
5280          if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
5281          {
5282              ref_stack.back()->m_value.array->pop_back();
5283          }
5284          return true;
5285      }
5286      template<class Exception>
5287      bool parse_error(std::size_t &bsol;*unused*/, const std::string& &bsol;*unused*/,
5288                       const Exception& ex)
5289      {
5290          errored = true;
5291          static_cast<void>(ex);
5292          if (allow_exceptions)
5293          {
5294              JSON_THROW(ex);
5295          }
5296          return false;
5297      }
5298      constexpr bool is_errored() const
5299      {
5300          return errored;
5301      }
5302    private:
5303      template<typename Value>
5304      std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
5305      {
5306          JSON_ASSERT(!keep_stack.empty());
5307          if (!keep_stack.back())
5308          {
5309              return {false, nullptr};
5310          }
5311          auto value = BasicJsonType(std::forward<Value>(v));
5312          const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);
5313          if (!keep)
5314          {
5315              return {false, nullptr};
5316          }
5317          if (ref_stack.empty())
5318          {
5319              root = std::move(value);
5320              return {true, &root};
5321          }
5322          if (!ref_stack.back())
5323          {
5324              return {false, nullptr};
5325          }
5326          JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());
5327          if (ref_stack.back()->is_array())
5328          {
5329              ref_stack.back()->m_value.array->emplace_back(std::move(value));
5330              return {true, &(ref_stack.back()->m_value.array->back())};
5331          }
5332          JSON_ASSERT(ref_stack.back()->is_object());
5333          JSON_ASSERT(!key_keep_stack.empty());
5334          const bool store_element = key_keep_stack.back();
5335          key_keep_stack.pop_back();
5336          if (!store_element)
5337          {
5338              return {false, nullptr};
5339          }
5340          JSON_ASSERT(object_element);
5341          *object_element = std::move(value);
5342          return {true, object_element};
5343      }
5344      BasicJsonType& root;
5345      std::vector<BasicJsonType*> ref_stack {};
5346      std::vector<bool> keep_stack {};
5347      std::vector<bool> key_keep_stack {};
5348      BasicJsonType* object_element = nullptr;
5349      bool errored = false;
5350      const parser_callback_t callback = nullptr;
5351      const bool allow_exceptions = true;
5352      BasicJsonType discarded = BasicJsonType::value_t::discarded;
5353  };
5354  template<typename BasicJsonType>
5355  class json_sax_acceptor
5356  {
5357    public:
5358      using number_integer_t = typename BasicJsonType::number_integer_t;
5359      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
5360      using number_float_t = typename BasicJsonType::number_float_t;
5361      using string_t = typename BasicJsonType::string_t;
5362      using binary_t = typename BasicJsonType::binary_t;
5363      bool null()
5364      {
5365          return true;
5366      }
5367      bool boolean(bool &bsol;*unused*/)
5368      {
5369          return true;
5370      }
5371      bool number_integer(number_integer_t &bsol;*unused*/)
5372      {
5373          return true;
5374      }
5375      bool number_unsigned(number_unsigned_t &bsol;*unused*/)
5376      {
5377          return true;
5378      }
5379      bool number_float(number_float_t &bsol;*unused*/, const string_t& &bsol;*unused*/)
5380      {
5381          return true;
5382      }
5383      bool string(string_t& &bsol;*unused*/)
5384      {
5385          return true;
5386      }
5387      bool binary(binary_t& &bsol;*unused*/)
5388      {
5389          return true;
5390      }
5391      bool start_object(std::size_t &bsol;*unused*/ = static_cast<std::size_t>(-1))
5392      {
5393          return true;
5394      }
5395      bool key(string_t& &bsol;*unused*/)
5396      {
5397          return true;
5398      }
5399      bool end_object()
5400      {
5401          return true;
5402      }
5403      bool start_array(std::size_t &bsol;*unused*/ = static_cast<std::size_t>(-1))
5404      {
5405          return true;
5406      }
5407      bool end_array()
5408      {
5409          return true;
5410      }
5411      bool parse_error(std::size_t &bsol;*unused*/, const std::string& &bsol;*unused*/, const detail::exception& &bsol;*unused*/)
5412      {
5413          return false;
5414      }
5415  };
5416  }  
5417  NLOHMANN_JSON_NAMESPACE_END
5418  #include <array> 
5419  #include <clocale> 
5420  #include <cstddef> 
5421  #include <cstdio> 
5422  #include <cstdlib> 
5423  #include <initializer_list> 
5424  #include <string> 
5425  #include <utility> 
5426  #include <vector> 
5427  NLOHMANN_JSON_NAMESPACE_BEGIN
5428  namespace detail
5429  {
5430  template<typename BasicJsonType>
5431  class lexer_base
5432  {
5433    public:
5434      enum class token_type
5435      {
5436          uninitialized,    
5437          literal_true,     
5438          literal_false,    
5439          literal_null,     
5440          value_string,     
5441          value_unsigned,   
5442          value_integer,    
5443          value_float,      
5444          begin_array,      
5445          begin_object,     
5446          end_array,        
5447          end_object,       
5448          name_separator,   
5449          value_separator,  
5450          parse_error,      
5451          end_of_input,     
5452          literal_or_value  
5453      };
5454      JSON_HEDLEY_RETURNS_NON_NULL
5455      JSON_HEDLEY_CONST
5456      static const char* token_type_name(const token_type t) noexcept
5457      {
5458          switch (t)
5459          {
5460              case token_type::uninitialized:
5461                  return "<uninitialized>";
5462              case token_type::literal_true:
5463                  return "true literal";
5464              case token_type::literal_false:
5465                  return "false literal";
5466              case token_type::literal_null:
5467                  return "null literal";
5468              case token_type::value_string:
5469                  return "string literal";
5470              case token_type::value_unsigned:
5471              case token_type::value_integer:
5472              case token_type::value_float:
5473                  return "number literal";
5474              case token_type::begin_array:
5475                  return "'['";
5476              case token_type::begin_object:
5477                  return "'{'";
5478              case token_type::end_array:
5479                  return "']'";
5480              case token_type::end_object:
5481                  return "'}'";
5482              case token_type::name_separator:
5483                  return "':'";
5484              case token_type::value_separator:
5485                  return "','";
5486              case token_type::parse_error:
5487                  return "<parse error>";
5488              case token_type::end_of_input:
5489                  return "end of input";
5490              case token_type::literal_or_value:
5491                  return "'[', '{', or a literal";
5492              default: 
5493                  return "unknown token";
5494          }
5495      }
5496  };
5497  template<typename BasicJsonType, typename InputAdapterType>
5498  class lexer : public lexer_base<BasicJsonType>
5499  {
5500      using number_integer_t = typename BasicJsonType::number_integer_t;
5501      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
5502      using number_float_t = typename BasicJsonType::number_float_t;
5503      using string_t = typename BasicJsonType::string_t;
5504      using char_type = typename InputAdapterType::char_type;
5505      using char_int_type = typename std::char_traits<char_type>::int_type;
5506    public:
5507      using token_type = typename lexer_base<BasicJsonType>::token_type;
5508      explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false) noexcept
5509          : ia(std::move(adapter))
5510          , ignore_comments(ignore_comments_)
5511          , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))
5512      {}
5513      lexer(const lexer&) = delete;
5514      lexer(lexer&&) = default; 
5515      lexer& operator=(lexer&) = delete;
5516      lexer& operator=(lexer&&) = default; 
5517      ~lexer() = default;
5518    private:
5519      JSON_HEDLEY_PURE
5520      static char get_decimal_point() noexcept
5521      {
5522          const auto* loc = localeconv();
5523          JSON_ASSERT(loc != nullptr);
5524          return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
5525      }
5526      int get_codepoint()
5527      {
5528          JSON_ASSERT(current == 'u');
5529          int codepoint = 0;
5530          const auto factors = { 12u, 8u, 4u, 0u };
5531          for (const auto factor : factors)
5532          {
5533              get();
5534              if (current >= '0' && current <= '9')
5535              {
5536                  codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
5537              }
5538              else if (current >= 'A' && current <= 'F')
5539              {
5540                  codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
5541              }
5542              else if (current >= 'a' && current <= 'f')
5543              {
5544                  codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
5545              }
5546              else
5547              {
5548                  return -1;
5549              }
5550          }
5551          JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);
5552          return codepoint;
5553      }
5554      bool next_byte_in_range(std::initializer_list<char_int_type> ranges)
5555      {
5556          JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
5557          add(current);
5558          for (auto range = ranges.begin(); range != ranges.end(); ++range)
5559          {
5560              get();
5561              if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range)))
5562              {
5563                  add(current);
5564              }
5565              else
5566              {
5567                  error_message = "invalid string: ill-formed UTF-8 byte";
5568                  return false;
5569              }
5570          }
5571          return true;
5572      }
5573      token_type scan_string()
5574      {
5575          reset();
5576          JSON_ASSERT(current == '\"');
5577          while (true)
5578          {
5579              switch (get())
5580              {
5581                  case std::char_traits<char_type>::eof():
5582                  {
5583                      error_message = "invalid string: missing closing quote";
5584                      return token_type::parse_error;
5585                  }
5586                  case '\"':
5587                  {
5588                      return token_type::value_string;
5589                  }
5590                  case '\\':
5591                  {
5592                      switch (get())
5593                      {
5594                          case '\"':
5595                              add('\"');
5596                              break;
5597                          case '\\':
5598                              add('\\');
5599                              break;
5600                          case '/':
5601                              add('/');
5602                              break;
5603                          case 'b':
5604                              add('\b');
5605                              break;
5606                          case 'f':
5607                              add('\f');
5608                              break;
5609                          case 'n':
5610                              add('\n');
5611                              break;
5612                          case 'r':
5613                              add('\r');
5614                              break;
5615                          case 't':
5616                              add('\t');
5617                              break;
5618                          case 'u':
5619                          {
5620                              const int codepoint1 = get_codepoint();
5621                              int codepoint = codepoint1; 
5622                              if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
5623                              {
5624                                  error_message = "invalid string: '\\u' must be followed by 4 hex digits";
5625                                  return token_type::parse_error;
5626                              }
5627                              if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)
5628                              {
5629                                  if (JSON_HEDLEY_LIKELY(get() == '\\' && get() == 'u'))
5630                                  {
5631                                      const int codepoint2 = get_codepoint();
5632                                      if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
5633                                      {
5634                                          error_message = "invalid string: '\\u' must be followed by 4 hex digits";
5635                                          return token_type::parse_error;
5636                                      }
5637                                      if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))
5638                                      {
5639                                          codepoint = static_cast<int>(
5640                                                          (static_cast<unsigned int>(codepoint1) << 10u)
5641                                                          + static_cast<unsigned int>(codepoint2)
5642                                                          - 0x35FDC00u);
5643                                      }
5644                                      else
5645                                      {
5646                                          error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
5647                                          return token_type::parse_error;
5648                                      }
5649                                  }
5650                                  else
5651                                  {
5652                                      error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
5653                                      return token_type::parse_error;
5654                                  }
5655                              }
5656                              else
5657                              {
5658                                  if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))
5659                                  {
5660                                      error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
5661                                      return token_type::parse_error;
5662                                  }
5663                              }
5664                              JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);
5665                              if (codepoint < 0x80)
5666                              {
5667                                  add(static_cast<char_int_type>(codepoint));
5668                              }
5669                              else if (codepoint <= 0x7FF)
5670                              {
5671                                  add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
5672                                  add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
5673                              }
5674                              else if (codepoint <= 0xFFFF)
5675                              {
5676                                  add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
5677                                  add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
5678                                  add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
5679                              }
5680                              else
5681                              {
5682                                  add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
5683                                  add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
5684                                  add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
5685                                  add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
5686                              }
5687                              break;
5688                          }
5689                          default:
5690                              error_message = "invalid string: forbidden character after backslash";
5691                              return token_type::parse_error;
5692                      }
5693                      break;
5694                  }
5695                  case 0x00:
5696                  {
5697                      error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
5698                      return token_type::parse_error;
5699                  }
5700                  case 0x01:
5701                  {
5702                      error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
5703                      return token_type::parse_error;
5704                  }
5705                  case 0x02:
5706                  {
5707                      error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
5708                      return token_type::parse_error;
5709                  }
5710                  case 0x03:
5711                  {
5712                      error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
5713                      return token_type::parse_error;
5714                  }
5715                  case 0x04:
5716                  {
5717                      error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
5718                      return token_type::parse_error;
5719                  }
5720                  case 0x05:
5721                  {
5722                      error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
5723                      return token_type::parse_error;
5724                  }
5725                  case 0x06:
5726                  {
5727                      error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
5728                      return token_type::parse_error;
5729                  }
5730                  case 0x07:
5731                  {
5732                      error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
5733                      return token_type::parse_error;
5734                  }
5735                  case 0x08:
5736                  {
5737                      error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
5738                      return token_type::parse_error;
5739                  }
5740                  case 0x09:
5741                  {
5742                      error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
5743                      return token_type::parse_error;
5744                  }
5745                  case 0x0A:
5746                  {
5747                      error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
5748                      return token_type::parse_error;
5749                  }
5750                  case 0x0B:
5751                  {
5752                      error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
5753                      return token_type::parse_error;
5754                  }
5755                  case 0x0C:
5756                  {
5757                      error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
5758                      return token_type::parse_error;
5759                  }
5760                  case 0x0D:
5761                  {
5762                      error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
5763                      return token_type::parse_error;
5764                  }
5765                  case 0x0E:
5766                  {
5767                      error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
5768                      return token_type::parse_error;
5769                  }
5770                  case 0x0F:
5771                  {
5772                      error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
5773                      return token_type::parse_error;
5774                  }
5775                  case 0x10:
5776                  {
5777                      error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
5778                      return token_type::parse_error;
5779                  }
5780                  case 0x11:
5781                  {
5782                      error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
5783                      return token_type::parse_error;
5784                  }
5785                  case 0x12:
5786                  {
5787                      error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
5788                      return token_type::parse_error;
5789                  }
5790                  case 0x13:
5791                  {
5792                      error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
5793                      return token_type::parse_error;
5794                  }
5795                  case 0x14:
5796                  {
5797                      error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
5798                      return token_type::parse_error;
5799                  }
5800                  case 0x15:
5801                  {
5802                      error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
5803                      return token_type::parse_error;
5804                  }
5805                  case 0x16:
5806                  {
5807                      error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
5808                      return token_type::parse_error;
5809                  }
5810                  case 0x17:
5811                  {
5812                      error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
5813                      return token_type::parse_error;
5814                  }
5815                  case 0x18:
5816                  {
5817                      error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
5818                      return token_type::parse_error;
5819                  }
5820                  case 0x19:
5821                  {
5822                      error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
5823                      return token_type::parse_error;
5824                  }
5825                  case 0x1A:
5826                  {
5827                      error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
5828                      return token_type::parse_error;
5829                  }
5830                  case 0x1B:
5831                  {
5832                      error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
5833                      return token_type::parse_error;
5834                  }
5835                  case 0x1C:
5836                  {
5837                      error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
5838                      return token_type::parse_error;
5839                  }
5840                  case 0x1D:
5841                  {
5842                      error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
5843                      return token_type::parse_error;
5844                  }
5845                  case 0x1E:
5846                  {
5847                      error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
5848                      return token_type::parse_error;
5849                  }
5850                  case 0x1F:
5851                  {
5852                      error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
5853                      return token_type::parse_error;
5854                  }
5855                  case 0x20:
5856                  case 0x21:
5857                  case 0x23:
5858                  case 0x24:
5859                  case 0x25:
5860                  case 0x26:
5861                  case 0x27:
5862                  case 0x28:
5863                  case 0x29:
5864                  case 0x2A:
5865                  case 0x2B:
5866                  case 0x2C:
5867                  case 0x2D:
5868                  case 0x2E:
5869                  case 0x2F:
5870                  case 0x30:
5871                  case 0x31:
5872                  case 0x32:
5873                  case 0x33:
5874                  case 0x34:
5875                  case 0x35:
5876                  case 0x36:
5877                  case 0x37:
5878                  case 0x38:
5879                  case 0x39:
5880                  case 0x3A:
5881                  case 0x3B:
5882                  case 0x3C:
5883                  case 0x3D:
5884                  case 0x3E:
5885                  case 0x3F:
5886                  case 0x40:
5887                  case 0x41:
5888                  case 0x42:
5889                  case 0x43:
5890                  case 0x44:
5891                  case 0x45:
5892                  case 0x46:
5893                  case 0x47:
5894                  case 0x48:
5895                  case 0x49:
5896                  case 0x4A:
5897                  case 0x4B:
5898                  case 0x4C:
5899                  case 0x4D:
5900                  case 0x4E:
5901                  case 0x4F:
5902                  case 0x50:
5903                  case 0x51:
5904                  case 0x52:
5905                  case 0x53:
5906                  case 0x54:
5907                  case 0x55:
5908                  case 0x56:
5909                  case 0x57:
5910                  case 0x58:
5911                  case 0x59:
5912                  case 0x5A:
5913                  case 0x5B:
5914                  case 0x5D:
5915                  case 0x5E:
5916                  case 0x5F:
5917                  case 0x60:
5918                  case 0x61:
5919                  case 0x62:
5920                  case 0x63:
5921                  case 0x64:
5922                  case 0x65:
5923                  case 0x66:
5924                  case 0x67:
5925                  case 0x68:
5926                  case 0x69:
5927                  case 0x6A:
5928                  case 0x6B:
5929                  case 0x6C:
5930                  case 0x6D:
5931                  case 0x6E:
5932                  case 0x6F:
5933                  case 0x70:
5934                  case 0x71:
5935                  case 0x72:
5936                  case 0x73:
5937                  case 0x74:
5938                  case 0x75:
5939                  case 0x76:
5940                  case 0x77:
5941                  case 0x78:
5942                  case 0x79:
5943                  case 0x7A:
5944                  case 0x7B:
5945                  case 0x7C:
5946                  case 0x7D:
5947                  case 0x7E:
5948                  case 0x7F:
5949                  {
5950                      add(current);
5951                      break;
5952                  }
5953                  case 0xC2:
5954                  case 0xC3:
5955                  case 0xC4:
5956                  case 0xC5:
5957                  case 0xC6:
5958                  case 0xC7:
5959                  case 0xC8:
5960                  case 0xC9:
5961                  case 0xCA:
5962                  case 0xCB:
5963                  case 0xCC:
5964                  case 0xCD:
5965                  case 0xCE:
5966                  case 0xCF:
5967                  case 0xD0:
5968                  case 0xD1:
5969                  case 0xD2:
5970                  case 0xD3:
5971                  case 0xD4:
5972                  case 0xD5:
5973                  case 0xD6:
5974                  case 0xD7:
5975                  case 0xD8:
5976                  case 0xD9:
5977                  case 0xDA:
5978                  case 0xDB:
5979                  case 0xDC:
5980                  case 0xDD:
5981                  case 0xDE:
5982                  case 0xDF:
5983                  {
5984                      if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
5985                      {
5986                          return token_type::parse_error;
5987                      }
5988                      break;
5989                  }
5990                  case 0xE0:
5991                  {
5992                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
5993                      {
5994                          return token_type::parse_error;
5995                      }
5996                      break;
5997                  }
5998                  case 0xE1:
5999                  case 0xE2:
6000                  case 0xE3:
6001                  case 0xE4:
6002                  case 0xE5:
6003                  case 0xE6:
6004                  case 0xE7:
6005                  case 0xE8:
6006                  case 0xE9:
6007                  case 0xEA:
6008                  case 0xEB:
6009                  case 0xEC:
6010                  case 0xEE:
6011                  case 0xEF:
6012                  {
6013                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
6014                      {
6015                          return token_type::parse_error;
6016                      }
6017                      break;
6018                  }
6019                  case 0xED:
6020                  {
6021                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
6022                      {
6023                          return token_type::parse_error;
6024                      }
6025                      break;
6026                  }
6027                  case 0xF0:
6028                  {
6029                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
6030                      {
6031                          return token_type::parse_error;
6032                      }
6033                      break;
6034                  }
6035                  case 0xF1:
6036                  case 0xF2:
6037                  case 0xF3:
6038                  {
6039                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
6040                      {
6041                          return token_type::parse_error;
6042                      }
6043                      break;
6044                  }
6045                  case 0xF4:
6046                  {
6047                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
6048                      {
6049                          return token_type::parse_error;
6050                      }
6051                      break;
6052                  }
6053                  default:
6054                  {
6055                      error_message = "invalid string: ill-formed UTF-8 byte";
6056                      return token_type::parse_error;
6057                  }
6058              }
6059          }
6060      }
6061      bool scan_comment()
6062      {
6063          switch (get())
6064          {
6065              case '/':
6066              {
6067                  while (true)
6068                  {
6069                      switch (get())
6070                      {
6071                          case '\n':
6072                          case '\r':
6073                          case std::char_traits<char_type>::eof():
6074                          case '\0':
6075                              return true;
6076                          default:
6077                              break;
6078                      }
6079                  }
6080              }
6081              case '*':
6082              {
6083                  while (true)
6084                  {
6085                      switch (get())
6086                      {
6087                          case std::char_traits<char_type>::eof():
6088                          case '\0':
6089                          {
6090                              error_message = "invalid comment; missing closing '*/'";
6091                              return false;
6092                          }
6093                          case '*':
6094                          {
6095                              switch (get())
6096                              {
6097                                  case '/':
6098                                      return true;
6099                                  default:
6100                                  {
6101                                      unget();
6102                                      continue;
6103                                  }
6104                              }
6105                          }
6106                          default:
6107                              continue;
6108                      }
6109                  }
6110              }
6111              default:
6112              {
6113                  error_message = "invalid comment; expecting '/' or '*' after '/'";
6114                  return false;
6115              }
6116          }
6117      }
6118      JSON_HEDLEY_NON_NULL(2)
6119      static void strtof(float& f, const char* str, char** endptr) noexcept
6120      {
6121          f = std::strtof(str, endptr);
6122      }
6123      JSON_HEDLEY_NON_NULL(2)
6124      static void strtof(double& f, const char* str, char** endptr) noexcept
6125      {
6126          f = std::strtod(str, endptr);
6127      }
6128      JSON_HEDLEY_NON_NULL(2)
6129      static void strtof(long double& f, const char* str, char** endptr) noexcept
6130      {
6131          f = std::strtold(str, endptr);
6132      }
6133      token_type scan_number()  
6134      {
6135          reset();
6136          token_type number_type = token_type::value_unsigned;
6137          switch (current)
6138          {
6139              case '-':
6140              {
6141                  add(current);
6142                  goto scan_number_minus;
6143              }
6144              case '0':
6145              {
6146                  add(current);
6147                  goto scan_number_zero;
6148              }
6149              case '1':
6150              case '2':
6151              case '3':
6152              case '4':
6153              case '5':
6154              case '6':
6155              case '7':
6156              case '8':
6157              case '9':
6158              {
6159                  add(current);
6160                  goto scan_number_any1;
6161              }
6162              default:            
6163                  JSON_ASSERT(false); 
6164          }
6165  scan_number_minus:
6166          number_type = token_type::value_integer;
6167          switch (get())
6168          {
6169              case '0':
6170              {
6171                  add(current);
6172                  goto scan_number_zero;
6173              }
6174              case '1':
6175              case '2':
6176              case '3':
6177              case '4':
6178              case '5':
6179              case '6':
6180              case '7':
6181              case '8':
6182              case '9':
6183              {
6184                  add(current);
6185                  goto scan_number_any1;
6186              }
6187              default:
6188              {
6189                  error_message = "invalid number; expected digit after '-'";
6190                  return token_type::parse_error;
6191              }
6192          }
6193  scan_number_zero:
6194          switch (get())
6195          {
6196              case '.':
6197              {
6198                  add(decimal_point_char);
6199                  goto scan_number_decimal1;
6200              }
6201              case 'e':
6202              case 'E':
6203              {
6204                  add(current);
6205                  goto scan_number_exponent;
6206              }
6207              default:
6208                  goto scan_number_done;
6209          }
6210  scan_number_any1:
6211          switch (get())
6212          {
6213              case '0':
6214              case '1':
6215              case '2':
6216              case '3':
6217              case '4':
6218              case '5':
6219              case '6':
6220              case '7':
6221              case '8':
6222              case '9':
6223              {
6224                  add(current);
6225                  goto scan_number_any1;
6226              }
6227              case '.':
6228              {
6229                  add(decimal_point_char);
6230                  goto scan_number_decimal1;
6231              }
6232              case 'e':
6233              case 'E':
6234              {
6235                  add(current);
6236                  goto scan_number_exponent;
6237              }
6238              default:
6239                  goto scan_number_done;
6240          }
6241  scan_number_decimal1:
6242          number_type = token_type::value_float;
6243          switch (get())
6244          {
6245              case '0':
6246              case '1':
6247              case '2':
6248              case '3':
6249              case '4':
6250              case '5':
6251              case '6':
6252              case '7':
6253              case '8':
6254              case '9':
6255              {
6256                  add(current);
6257                  goto scan_number_decimal2;
6258              }
6259              default:
6260              {
6261                  error_message = "invalid number; expected digit after '.'";
6262                  return token_type::parse_error;
6263              }
6264          }
6265  scan_number_decimal2:
6266          switch (get())
6267          {
6268              case '0':
6269              case '1':
6270              case '2':
6271              case '3':
6272              case '4':
6273              case '5':
6274              case '6':
6275              case '7':
6276              case '8':
6277              case '9':
6278              {
6279                  add(current);
6280                  goto scan_number_decimal2;
6281              }
6282              case 'e':
6283              case 'E':
6284              {
6285                  add(current);
6286                  goto scan_number_exponent;
6287              }
6288              default:
6289                  goto scan_number_done;
6290          }
6291  scan_number_exponent:
6292          number_type = token_type::value_float;
6293          switch (get())
6294          {
6295              case '+':
6296              case '-':
6297              {
6298                  add(current);
6299                  goto scan_number_sign;
6300              }
6301              case '0':
6302              case '1':
6303              case '2':
6304              case '3':
6305              case '4':
6306              case '5':
6307              case '6':
6308              case '7':
6309              case '8':
6310              case '9':
6311              {
6312                  add(current);
6313                  goto scan_number_any2;
6314              }
6315              default:
6316              {
6317                  error_message =
6318                      "invalid number; expected '+', '-', or digit after exponent";
6319                  return token_type::parse_error;
6320              }
6321          }
6322  scan_number_sign:
6323          switch (get())
6324          {
6325              case '0':
6326              case '1':
6327              case '2':
6328              case '3':
6329              case '4':
6330              case '5':
6331              case '6':
6332              case '7':
6333              case '8':
6334              case '9':
6335              {
6336                  add(current);
6337                  goto scan_number_any2;
6338              }
6339              default:
6340              {
6341                  error_message = "invalid number; expected digit after exponent sign";
6342                  return token_type::parse_error;
6343              }
6344          }
6345  scan_number_any2:
6346          switch (get())
6347          {
6348              case '0':
6349              case '1':
6350              case '2':
6351              case '3':
6352              case '4':
6353              case '5':
6354              case '6':
6355              case '7':
6356              case '8':
6357              case '9':
6358              {
6359                  add(current);
6360                  goto scan_number_any2;
6361              }
6362              default:
6363                  goto scan_number_done;
6364          }
6365  scan_number_done:
6366          unget();
6367          char* endptr = nullptr; 
6368          errno = 0;
6369          if (number_type == token_type::value_unsigned)
6370          {
6371              const auto x = std::strtoull(token_buffer.data(), &endptr, 10);
6372              JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
6373              if (errno == 0)
6374              {
6375                  value_unsigned = static_cast<number_unsigned_t>(x);
6376                  if (value_unsigned == x)
6377                  {
6378                      return token_type::value_unsigned;
6379                  }
6380              }
6381          }
6382          else if (number_type == token_type::value_integer)
6383          {
6384              const auto x = std::strtoll(token_buffer.data(), &endptr, 10);
6385              JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
6386              if (errno == 0)
6387              {
6388                  value_integer = static_cast<number_integer_t>(x);
6389                  if (value_integer == x)
6390                  {
6391                      return token_type::value_integer;
6392                  }
6393              }
6394          }
6395          strtof(value_float, token_buffer.data(), &endptr);
6396          JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
6397          return token_type::value_float;
6398      }
6399      JSON_HEDLEY_NON_NULL(2)
6400      token_type scan_literal(const char_type* literal_text, const std::size_t length,
6401                              token_type return_type)
6402      {
6403          JSON_ASSERT(std::char_traits<char_type>::to_char_type(current) == literal_text[0]);
6404          for (std::size_t i = 1; i < length; ++i)
6405          {
6406              if (JSON_HEDLEY_UNLIKELY(std::char_traits<char_type>::to_char_type(get()) != literal_text[i]))
6407              {
6408                  error_message = "invalid literal";
6409                  return token_type::parse_error;
6410              }
6411          }
6412          return return_type;
6413      }
6414      void reset() noexcept
6415      {
6416          token_buffer.clear();
6417          token_string.clear();
6418          token_string.push_back(std::char_traits<char_type>::to_char_type(current));
6419      }
6420      char_int_type get()
6421      {
6422          ++position.chars_read_total;
6423          ++position.chars_read_current_line;
6424          if (next_unget)
6425          {
6426              next_unget = false;
6427          }
6428          else
6429          {
6430              current = ia.get_character();
6431          }
6432          if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
6433          {
6434              token_string.push_back(std::char_traits<char_type>::to_char_type(current));
6435          }
6436          if (current == '\n')
6437          {
6438              ++position.lines_read;
6439              position.chars_read_current_line = 0;
6440          }
6441          return current;
6442      }
6443      void unget()
6444      {
6445          next_unget = true;
6446          --position.chars_read_total;
6447          if (position.chars_read_current_line == 0)
6448          {
6449              if (position.lines_read > 0)
6450              {
6451                  --position.lines_read;
6452              }
6453          }
6454          else
6455          {
6456              --position.chars_read_current_line;
6457          }
6458          if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
6459          {
6460              JSON_ASSERT(!token_string.empty());
6461              token_string.pop_back();
6462          }
6463      }
6464      void add(char_int_type c)
6465      {
6466          token_buffer.push_back(static_cast<typename string_t::value_type>(c));
6467      }
6468    public:
6469      constexpr number_integer_t get_number_integer() const noexcept
6470      {
6471          return value_integer;
6472      }
6473      constexpr number_unsigned_t get_number_unsigned() const noexcept
6474      {
6475          return value_unsigned;
6476      }
6477      constexpr number_float_t get_number_float() const noexcept
6478      {
6479          return value_float;
6480      }
6481      string_t& get_string()
6482      {
6483          return token_buffer;
6484      }
6485      constexpr position_t get_position() const noexcept
6486      {
6487          return position;
6488      }
6489      std::string get_token_string() const
6490      {
6491          std::string result;
6492          for (const auto c : token_string)
6493          {
6494              if (static_cast<unsigned char>(c) <= '\x1F')
6495              {
6496                  std::array<char, 9> cs{{}};
6497                  static_cast<void>((std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c))); 
6498                  result += cs.data();
6499              }
6500              else
6501              {
6502                  result.push_back(static_cast<std::string::value_type>(c));
6503              }
6504          }
6505          return result;
6506      }
6507      JSON_HEDLEY_RETURNS_NON_NULL
6508      constexpr const char* get_error_message() const noexcept
6509      {
6510          return error_message;
6511      }
6512      bool skip_bom()
6513      {
6514          if (get() == 0xEF)
6515          {
6516              return get() == 0xBB && get() == 0xBF;
6517          }
6518          unget();
6519          return true;
6520      }
6521      void skip_whitespace()
6522      {
6523          do
6524          {
6525              get();
6526          }
6527          while (current == ' ' || current == '\t' || current == '\n' || current == '\r');
6528      }
6529      token_type scan()
6530      {
6531          if (position.chars_read_total == 0 && !skip_bom())
6532          {
6533              error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
6534              return token_type::parse_error;
6535          }
6536          skip_whitespace();
6537          while (ignore_comments && current == '/')
6538          {
6539              if (!scan_comment())
6540              {
6541                  return token_type::parse_error;
6542              }
6543              skip_whitespace();
6544          }
6545          switch (current)
6546          {
6547              case '[':
6548                  return token_type::begin_array;
6549              case ']':
6550                  return token_type::end_array;
6551              case '{':
6552                  return token_type::begin_object;
6553              case '}':
6554                  return token_type::end_object;
6555              case ':':
6556                  return token_type::name_separator;
6557              case ',':
6558                  return token_type::value_separator;
6559              case 't':
6560              {
6561                  std::array<char_type, 4> true_literal = {{static_cast<char_type>('t'), static_cast<char_type>('r'), static_cast<char_type>('u'), static_cast<char_type>('e')}};
6562                  return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
6563              }
6564              case 'f':
6565              {
6566                  std::array<char_type, 5> false_literal = {{static_cast<char_type>('f'), static_cast<char_type>('a'), static_cast<char_type>('l'), static_cast<char_type>('s'), static_cast<char_type>('e')}};
6567                  return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
6568              }
6569              case 'n':
6570              {
6571                  std::array<char_type, 4> null_literal = {{static_cast<char_type>('n'), static_cast<char_type>('u'), static_cast<char_type>('l'), static_cast<char_type>('l')}};
6572                  return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
6573              }
6574              case '\"':
6575                  return scan_string();
6576              case '-':
6577              case '0':
6578              case '1':
6579              case '2':
6580              case '3':
6581              case '4':
6582              case '5':
6583              case '6':
6584              case '7':
6585              case '8':
6586              case '9':
6587                  return scan_number();
6588              case '\0':
6589              case std::char_traits<char_type>::eof():
6590                  return token_type::end_of_input;
6591              default:
6592                  error_message = "invalid literal";
6593                  return token_type::parse_error;
6594          }
6595      }
6596    private:
6597      InputAdapterType ia;
6598      const bool ignore_comments = false;
6599      char_int_type current = std::char_traits<char_type>::eof();
6600      bool next_unget = false;
6601      position_t position {};
6602      std::vector<char_type> token_string {};
6603      string_t token_buffer {};
6604      const char* error_message = "";
6605      number_integer_t value_integer = 0;
6606      number_unsigned_t value_unsigned = 0;
6607      number_float_t value_float = 0;
6608      const char_int_type decimal_point_char = '.';
6609  };
6610  }  
6611  NLOHMANN_JSON_NAMESPACE_END
6612  #include <cstdint> 
6613  #include <utility> 
6614  #include <string> 
6615  NLOHMANN_JSON_NAMESPACE_BEGIN
6616  namespace detail
6617  {
6618  template<typename T>
6619  using null_function_t = decltype(std::declval<T&>().null());
6620  template<typename T>
6621  using boolean_function_t =
6622      decltype(std::declval<T&>().boolean(std::declval<bool>()));
6623  template<typename T, typename Integer>
6624  using number_integer_function_t =
6625      decltype(std::declval<T&>().number_integer(std::declval<Integer>()));
6626  template<typename T, typename Unsigned>
6627  using number_unsigned_function_t =
6628      decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));
6629  template<typename T, typename Float, typename String>
6630  using number_float_function_t = decltype(std::declval<T&>().number_float(
6631                                      std::declval<Float>(), std::declval<const String&>()));
6632  template<typename T, typename String>
6633  using string_function_t =
6634      decltype(std::declval<T&>().string(std::declval<String&>()));
6635  template<typename T, typename Binary>
6636  using binary_function_t =
6637      decltype(std::declval<T&>().binary(std::declval<Binary&>()));
6638  template<typename T>
6639  using start_object_function_t =
6640      decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));
6641  template<typename T, typename String>
6642  using key_function_t =
6643      decltype(std::declval<T&>().key(std::declval<String&>()));
6644  template<typename T>
6645  using end_object_function_t = decltype(std::declval<T&>().end_object());
6646  template<typename T>
6647  using start_array_function_t =
6648      decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));
6649  template<typename T>
6650  using end_array_function_t = decltype(std::declval<T&>().end_array());
6651  template<typename T, typename Exception>
6652  using parse_error_function_t = decltype(std::declval<T&>().parse_error(
6653          std::declval<std::size_t>(), std::declval<const std::string&>(),
6654          std::declval<const Exception&>()));
6655  template<typename SAX, typename BasicJsonType>
6656  struct is_sax
6657  {
6658    private:
6659      static_assert(is_basic_json<BasicJsonType>::value,
6660                    "BasicJsonType must be of type basic_json<...>");
6661      using number_integer_t = typename BasicJsonType::number_integer_t;
6662      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6663      using number_float_t = typename BasicJsonType::number_float_t;
6664      using string_t = typename BasicJsonType::string_t;
6665      using binary_t = typename BasicJsonType::binary_t;
6666      using exception_t = typename BasicJsonType::exception;
6667    public:
6668      static constexpr bool value =
6669          is_detected_exact<bool, null_function_t, SAX>::value &&
6670          is_detected_exact<bool, boolean_function_t, SAX>::value &&
6671          is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&
6672          is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&
6673          is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&
6674          is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
6675          is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&
6676          is_detected_exact<bool, start_object_function_t, SAX>::value &&
6677          is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
6678          is_detected_exact<bool, end_object_function_t, SAX>::value &&
6679          is_detected_exact<bool, start_array_function_t, SAX>::value &&
6680          is_detected_exact<bool, end_array_function_t, SAX>::value &&
6681          is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
6682  };
6683  template<typename SAX, typename BasicJsonType>
6684  struct is_sax_static_asserts
6685  {
6686    private:
6687      static_assert(is_basic_json<BasicJsonType>::value,
6688                    "BasicJsonType must be of type basic_json<...>");
6689      using number_integer_t = typename BasicJsonType::number_integer_t;
6690      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6691      using number_float_t = typename BasicJsonType::number_float_t;
6692      using string_t = typename BasicJsonType::string_t;
6693      using binary_t = typename BasicJsonType::binary_t;
6694      using exception_t = typename BasicJsonType::exception;
6695    public:
6696      static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
6697                    "Missing/invalid function: bool null()");
6698      static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
6699                    "Missing/invalid function: bool boolean(bool)");
6700      static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
6701                    "Missing/invalid function: bool boolean(bool)");
6702      static_assert(
6703          is_detected_exact<bool, number_integer_function_t, SAX,
6704          number_integer_t>::value,
6705          "Missing/invalid function: bool number_integer(number_integer_t)");
6706      static_assert(
6707          is_detected_exact<bool, number_unsigned_function_t, SAX,
6708          number_unsigned_t>::value,
6709          "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
6710      static_assert(is_detected_exact<bool, number_float_function_t, SAX,
6711                    number_float_t, string_t>::value,
6712                    "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
6713      static_assert(
6714          is_detected_exact<bool, string_function_t, SAX, string_t>::value,
6715          "Missing/invalid function: bool string(string_t&)");
6716      static_assert(
6717          is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,
6718          "Missing/invalid function: bool binary(binary_t&)");
6719      static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
6720                    "Missing/invalid function: bool start_object(std::size_t)");
6721      static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
6722                    "Missing/invalid function: bool key(string_t&)");
6723      static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
6724                    "Missing/invalid function: bool end_object()");
6725      static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
6726                    "Missing/invalid function: bool start_array(std::size_t)");
6727      static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
6728                    "Missing/invalid function: bool end_array()");
6729      static_assert(
6730          is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
6731          "Missing/invalid function: bool parse_error(std::size_t, const "
6732          "std::string&, const exception&)");
6733  };
6734  }  
6735  NLOHMANN_JSON_NAMESPACE_END
6736  NLOHMANN_JSON_NAMESPACE_BEGIN
6737  namespace detail
6738  {
6739  enum class cbor_tag_handler_t
6740  {
6741      error,   
6742      ignore,  
6743      store    
6744  };
6745  static inline bool little_endianness(int num = 1) noexcept
6746  {
6747      return *reinterpret_cast<char*>(&num) == 1;
6748  }
6749  template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType>>
6750  class binary_reader
6751  {
6752      using number_integer_t = typename BasicJsonType::number_integer_t;
6753      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6754      using number_float_t = typename BasicJsonType::number_float_t;
6755      using string_t = typename BasicJsonType::string_t;
6756      using binary_t = typename BasicJsonType::binary_t;
6757      using json_sax_t = SAX;
6758      using char_type = typename InputAdapterType::char_type;
6759      using char_int_type = typename std::char_traits<char_type>::int_type;
6760    public:
6761      explicit binary_reader(InputAdapterType&& adapter, const input_format_t format = input_format_t::json) noexcept : ia(std::move(adapter)), input_format(format)
6762      {
6763          (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
6764      }
6765      binary_reader(const binary_reader&) = delete;
6766      binary_reader(binary_reader&&) = default; 
6767      binary_reader& operator=(const binary_reader&) = delete;
6768      binary_reader& operator=(binary_reader&&) = default; 
6769      ~binary_reader() = default;
6770      JSON_HEDLEY_NON_NULL(3)
6771      bool sax_parse(const input_format_t format,
6772                     json_sax_t* sax_,
6773                     const bool strict = true,
6774                     const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
6775      {
6776          sax = sax_;
6777          bool result = false;
6778          switch (format)
6779          {
6780              case input_format_t::bson:
6781                  result = parse_bson_internal();
6782                  break;
6783              case input_format_t::cbor:
6784                  result = parse_cbor_internal(true, tag_handler);
6785                  break;
6786              case input_format_t::msgpack:
6787                  result = parse_msgpack_internal();
6788                  break;
6789              case input_format_t::ubjson:
6790              case input_format_t::bjdata:
6791                  result = parse_ubjson_internal();
6792                  break;
6793              case input_format_t::json: 
6794              default:            
6795                  JSON_ASSERT(false); 
6796          }
6797          if (result && strict)
6798          {
6799              if (input_format == input_format_t::ubjson || input_format == input_format_t::bjdata)
6800              {
6801                  get_ignore_noop();
6802              }
6803              else
6804              {
6805                  get();
6806              }
6807              if (JSON_HEDLEY_UNLIKELY(current != std::char_traits<char_type>::eof()))
6808              {
6809                  return sax->parse_error(chars_read, get_token_string(), parse_error::create(110, chars_read,
6810                                          exception_message(input_format, concat("expected end of input; last byte: 0x", get_token_string()), "value"), nullptr));
6811              }
6812          }
6813          return result;
6814      }
6815    private:
6816      bool parse_bson_internal()
6817      {
6818          std::int32_t document_size{};
6819          get_number<std::int32_t, true>(input_format_t::bson, document_size);
6820          if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
6821          {
6822              return false;
6823          }
6824          if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(&bsol;*is_array*/false)))
6825          {
6826              return false;
6827          }
6828          return sax->end_object();
6829      }
6830      bool get_bson_cstr(string_t& result)
6831      {
6832          auto out = std::back_inserter(result);
6833          while (true)
6834          {
6835              get();
6836              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "cstring")))
6837              {
6838                  return false;
6839              }
6840              if (current == 0x00)
6841              {
6842                  return true;
6843              }
6844              *out++ = static_cast<typename string_t::value_type>(current);
6845          }
6846      }
6847      template<typename NumberType>
6848      bool get_bson_string(const NumberType len, string_t& result)
6849      {
6850          if (JSON_HEDLEY_UNLIKELY(len < 1))
6851          {
6852              auto last_token = get_token_string();
6853              return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
6854                                      exception_message(input_format_t::bson, concat("string length must be at least 1, is ", std::to_string(len)), "string"), nullptr));
6855          }
6856          return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != std::char_traits<char_type>::eof();
6857      }
6858      template<typename NumberType>
6859      bool get_bson_binary(const NumberType len, binary_t& result)
6860      {
6861          if (JSON_HEDLEY_UNLIKELY(len < 0))
6862          {
6863              auto last_token = get_token_string();
6864              return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
6865                                      exception_message(input_format_t::bson, concat("byte array length cannot be negative, is ", std::to_string(len)), "binary"), nullptr));
6866          }
6867          std::uint8_t subtype{};
6868          get_number<std::uint8_t>(input_format_t::bson, subtype);
6869          result.set_subtype(subtype);
6870          return get_binary(input_format_t::bson, len, result);
6871      }
6872      bool parse_bson_element_internal(const char_int_type element_type,
6873                                       const std::size_t element_type_parse_position)
6874      {
6875          switch (element_type)
6876          {
6877              case 0x01: 
6878              {
6879                  double number{};
6880                  return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), "");
6881              }
6882              case 0x02: 
6883              {
6884                  std::int32_t len{};
6885                  string_t value;
6886                  return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);
6887              }
6888              case 0x03: 
6889              {
6890                  return parse_bson_internal();
6891              }
6892              case 0x04: 
6893              {
6894                  return parse_bson_array();
6895              }
6896              case 0x05: 
6897              {
6898                  std::int32_t len{};
6899                  binary_t value;
6900                  return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);
6901              }
6902              case 0x08: 
6903              {
6904                  return sax->boolean(get() != 0);
6905              }
6906              case 0x0A: 
6907              {
6908                  return sax->null();
6909              }
6910              case 0x10: 
6911              {
6912                  std::int32_t value{};
6913                  return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);
6914              }
6915              case 0x12: 
6916              {
6917                  std::int64_t value{};
6918                  return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);
6919              }
6920              default: 
6921              {
6922                  std::array<char, 3> cr{{}};
6923                  static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type))); 
6924                  std::string cr_str{cr.data()};
6925                  return sax->parse_error(element_type_parse_position, cr_str,
6926                                          parse_error::create(114, element_type_parse_position, concat("Unsupported BSON record type 0x", cr_str), nullptr));
6927              }
6928          }
6929      }
6930      bool parse_bson_element_list(const bool is_array)
6931      {
6932          string_t key;
6933          while (auto element_type = get())
6934          {
6935              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "element list")))
6936              {
6937                  return false;
6938              }
6939              const std::size_t element_type_parse_position = chars_read;
6940              if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
6941              {
6942                  return false;
6943              }
6944              if (!is_array && !sax->key(key))
6945              {
6946                  return false;
6947              }
6948              if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
6949              {
6950                  return false;
6951              }
6952              key.clear();
6953          }
6954          return true;
6955      }
6956      bool parse_bson_array()
6957      {
6958          std::int32_t document_size{};
6959          get_number<std::int32_t, true>(input_format_t::bson, document_size);
6960          if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
6961          {
6962              return false;
6963          }
6964          if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(&bsol;*is_array*/true)))
6965          {
6966              return false;
6967          }
6968          return sax->end_array();
6969      }
6970      bool parse_cbor_internal(const bool get_char,
6971                               const cbor_tag_handler_t tag_handler)
6972      {
6973          switch (get_char ? get() : current)
6974          {
6975              case std::char_traits<char_type>::eof():
6976                  return unexpect_eof(input_format_t::cbor, "value");
6977              case 0x00:
6978              case 0x01:
6979              case 0x02:
6980              case 0x03:
6981              case 0x04:
6982              case 0x05:
6983              case 0x06:
6984              case 0x07:
6985              case 0x08:
6986              case 0x09:
6987              case 0x0A:
6988              case 0x0B:
6989              case 0x0C:
6990              case 0x0D:
6991              case 0x0E:
6992              case 0x0F:
6993              case 0x10:
6994              case 0x11:
6995              case 0x12:
6996              case 0x13:
6997              case 0x14:
6998              case 0x15:
6999              case 0x16:
7000              case 0x17:
7001                  return sax->number_unsigned(static_cast<number_unsigned_t>(current));
7002              case 0x18: 
7003              {
7004                  std::uint8_t number{};
7005                  return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
7006              }
7007              case 0x19: 
7008              {
7009                  std::uint16_t number{};
7010                  return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
7011              }
7012              case 0x1A: 
7013              {
7014                  std::uint32_t number{};
7015                  return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
7016              }
7017              case 0x1B: 
7018              {
7019                  std::uint64_t number{};
7020                  return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
7021              }
7022              case 0x20:
7023              case 0x21:
7024              case 0x22:
7025              case 0x23:
7026              case 0x24:
7027              case 0x25:
7028              case 0x26:
7029              case 0x27:
7030              case 0x28:
7031              case 0x29:
7032              case 0x2A:
7033              case 0x2B:
7034              case 0x2C:
7035              case 0x2D:
7036              case 0x2E:
7037              case 0x2F:
7038              case 0x30:
7039              case 0x31:
7040              case 0x32:
7041              case 0x33:
7042              case 0x34:
7043              case 0x35:
7044              case 0x36:
7045              case 0x37:
7046                  return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));
7047              case 0x38: 
7048              {
7049                  std::uint8_t number{};
7050                  return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
7051              }
7052              case 0x39: 
7053              {
7054                  std::uint16_t number{};
7055                  return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
7056              }
7057              case 0x3A: 
7058              {
7059                  std::uint32_t number{};
7060                  return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
7061              }
7062              case 0x3B: 
7063              {
7064                  std::uint64_t number{};
7065                  return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1)
7066                          - static_cast<number_integer_t>(number));
7067              }
7068              case 0x40:
7069              case 0x41:
7070              case 0x42:
7071              case 0x43:
7072              case 0x44:
7073              case 0x45:
7074              case 0x46:
7075              case 0x47:
7076              case 0x48:
7077              case 0x49:
7078              case 0x4A:
7079              case 0x4B:
7080              case 0x4C:
7081              case 0x4D:
7082              case 0x4E:
7083              case 0x4F:
7084              case 0x50:
7085              case 0x51:
7086              case 0x52:
7087              case 0x53:
7088              case 0x54:
7089              case 0x55:
7090              case 0x56:
7091              case 0x57:
7092              case 0x58: 
7093              case 0x59: 
7094              case 0x5A: 
7095              case 0x5B: 
7096              case 0x5F: 
7097              {
7098                  binary_t b;
7099                  return get_cbor_binary(b) && sax->binary(b);
7100              }
7101              case 0x60:
7102              case 0x61:
7103              case 0x62:
7104              case 0x63:
7105              case 0x64:
7106              case 0x65:
7107              case 0x66:
7108              case 0x67:
7109              case 0x68:
7110              case 0x69:
7111              case 0x6A:
7112              case 0x6B:
7113              case 0x6C:
7114              case 0x6D:
7115              case 0x6E:
7116              case 0x6F:
7117              case 0x70:
7118              case 0x71:
7119              case 0x72:
7120              case 0x73:
7121              case 0x74:
7122              case 0x75:
7123              case 0x76:
7124              case 0x77:
7125              case 0x78: 
7126              case 0x79: 
7127              case 0x7A: 
7128              case 0x7B: 
7129              case 0x7F: 
7130              {
7131                  string_t s;
7132                  return get_cbor_string(s) && sax->string(s);
7133              }
7134              case 0x80:
7135              case 0x81:
7136              case 0x82:
7137              case 0x83:
7138              case 0x84:
7139              case 0x85:
7140              case 0x86:
7141              case 0x87:
7142              case 0x88:
7143              case 0x89:
7144              case 0x8A:
7145              case 0x8B:
7146              case 0x8C:
7147              case 0x8D:
7148              case 0x8E:
7149              case 0x8F:
7150              case 0x90:
7151              case 0x91:
7152              case 0x92:
7153              case 0x93:
7154              case 0x94:
7155              case 0x95:
7156              case 0x96:
7157              case 0x97:
7158                  return get_cbor_array(
7159                             conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);
7160              case 0x98: 
7161              {
7162                  std::uint8_t len{};
7163                  return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
7164              }
7165              case 0x99: 
7166              {
7167                  std::uint16_t len{};
7168                  return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
7169              }
7170              case 0x9A: 
7171              {
7172                  std::uint32_t len{};
7173                  return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
7174              }
7175              case 0x9B: 
7176              {
7177                  std::uint64_t len{};
7178                  return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
7179              }
7180              case 0x9F: 
7181                  return get_cbor_array(static_cast<std::size_t>(-1), tag_handler);
7182              case 0xA0:
7183              case 0xA1:
7184              case 0xA2:
7185              case 0xA3:
7186              case 0xA4:
7187              case 0xA5:
7188              case 0xA6:
7189              case 0xA7:
7190              case 0xA8:
7191              case 0xA9:
7192              case 0xAA:
7193              case 0xAB:
7194              case 0xAC:
7195              case 0xAD:
7196              case 0xAE:
7197              case 0xAF:
7198              case 0xB0:
7199              case 0xB1:
7200              case 0xB2:
7201              case 0xB3:
7202              case 0xB4:
7203              case 0xB5:
7204              case 0xB6:
7205              case 0xB7:
7206                  return get_cbor_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);
7207              case 0xB8: 
7208              {
7209                  std::uint8_t len{};
7210                  return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
7211              }
7212              case 0xB9: 
7213              {
7214                  std::uint16_t len{};
7215                  return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
7216              }
7217              case 0xBA: 
7218              {
7219                  std::uint32_t len{};
7220                  return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
7221              }
7222              case 0xBB: 
7223              {
7224                  std::uint64_t len{};
7225                  return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
7226              }
7227              case 0xBF: 
7228                  return get_cbor_object(static_cast<std::size_t>(-1), tag_handler);
7229              case 0xC6: 
7230              case 0xC7:
7231              case 0xC8:
7232              case 0xC9:
7233              case 0xCA:
7234              case 0xCB:
7235              case 0xCC:
7236              case 0xCD:
7237              case 0xCE:
7238              case 0xCF:
7239              case 0xD0:
7240              case 0xD1:
7241              case 0xD2:
7242              case 0xD3:
7243              case 0xD4:
7244              case 0xD8: 
7245              case 0xD9: 
7246              case 0xDA: 
7247              case 0xDB: 
7248              {
7249                  switch (tag_handler)
7250                  {
7251                      case cbor_tag_handler_t::error:
7252                      {
7253                          auto last_token = get_token_string();
7254                          return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
7255                                                  exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
7256                      }
7257                      case cbor_tag_handler_t::ignore:
7258                      {
7259                          switch (current)
7260                          {
7261                              case 0xD8:
7262                              {
7263                                  std::uint8_t subtype_to_ignore{};
7264                                  get_number(input_format_t::cbor, subtype_to_ignore);
7265                                  break;
7266                              }
7267                              case 0xD9:
7268                              {
7269                                  std::uint16_t subtype_to_ignore{};
7270                                  get_number(input_format_t::cbor, subtype_to_ignore);
7271                                  break;
7272                              }
7273                              case 0xDA:
7274                              {
7275                                  std::uint32_t subtype_to_ignore{};
7276                                  get_number(input_format_t::cbor, subtype_to_ignore);
7277                                  break;
7278                              }
7279                              case 0xDB:
7280                              {
7281                                  std::uint64_t subtype_to_ignore{};
7282                                  get_number(input_format_t::cbor, subtype_to_ignore);
7283                                  break;
7284                              }
7285                              default:
7286                                  break;
7287                          }
7288                          return parse_cbor_internal(true, tag_handler);
7289                      }
7290                      case cbor_tag_handler_t::store:
7291                      {
7292                          binary_t b;
7293                          switch (current)
7294                          {
7295                              case 0xD8:
7296                              {
7297                                  std::uint8_t subtype{};
7298                                  get_number(input_format_t::cbor, subtype);
7299                                  b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
7300                                  break;
7301                              }
7302                              case 0xD9:
7303                              {
7304                                  std::uint16_t subtype{};
7305                                  get_number(input_format_t::cbor, subtype);
7306                                  b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
7307                                  break;
7308                              }
7309                              case 0xDA:
7310                              {
7311                                  std::uint32_t subtype{};
7312                                  get_number(input_format_t::cbor, subtype);
7313                                  b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
7314                                  break;
7315                              }
7316                              case 0xDB:
7317                              {
7318                                  std::uint64_t subtype{};
7319                                  get_number(input_format_t::cbor, subtype);
7320                                  b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
7321                                  break;
7322                              }
7323                              default:
7324                                  return parse_cbor_internal(true, tag_handler);
7325                          }
7326                          get();
7327                          return get_cbor_binary(b) && sax->binary(b);
7328                      }
7329                      default:                 
7330                          JSON_ASSERT(false); 
7331                          return false;        
7332                  }
7333              }
7334              case 0xF4: 
7335                  return sax->boolean(false);
7336              case 0xF5: 
7337                  return sax->boolean(true);
7338              case 0xF6: 
7339                  return sax->null();
7340              case 0xF9: 
7341              {
7342                  const auto byte1_raw = get();
7343                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
7344                  {
7345                      return false;
7346                  }
7347                  const auto byte2_raw = get();
7348                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
7349                  {
7350                      return false;
7351                  }
7352                  const auto byte1 = static_cast<unsigned char>(byte1_raw);
7353                  const auto byte2 = static_cast<unsigned char>(byte2_raw);
7354                  const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
7355                  const double val = [&half]
7356                  {
7357                      const int exp = (half >> 10u) & 0x1Fu;
7358                      const unsigned int mant = half & 0x3FFu;
7359                      JSON_ASSERT(0 <= exp&& exp <= 32);
7360                      JSON_ASSERT(mant <= 1024);
7361                      switch (exp)
7362                      {
7363                          case 0:
7364                              return std::ldexp(mant, -24);
7365                          case 31:
7366                              return (mant == 0)
7367                              ? std::numeric_limits<double>::infinity()
7368                              : std::numeric_limits<double>::quiet_NaN();
7369                          default:
7370                              return std::ldexp(mant + 1024, exp - 25);
7371                      }
7372                  }();
7373                  return sax->number_float((half & 0x8000u) != 0
7374                                           ? static_cast<number_float_t>(-val)
7375                                           : static_cast<number_float_t>(val), "");
7376              }
7377              case 0xFA: 
7378              {
7379                  float number{};
7380                  return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
7381              }
7382              case 0xFB: 
7383              {
7384                  double number{};
7385                  return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
7386              }
7387              default: 
7388              {
7389                  auto last_token = get_token_string();
7390                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
7391                                          exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
7392              }
7393          }
7394      }
7395      bool get_cbor_string(string_t& result)
7396      {
7397          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "string")))
7398          {
7399              return false;
7400          }
7401          switch (current)
7402          {
7403              case 0x60:
7404              case 0x61:
7405              case 0x62:
7406              case 0x63:
7407              case 0x64:
7408              case 0x65:
7409              case 0x66:
7410              case 0x67:
7411              case 0x68:
7412              case 0x69:
7413              case 0x6A:
7414              case 0x6B:
7415              case 0x6C:
7416              case 0x6D:
7417              case 0x6E:
7418              case 0x6F:
7419              case 0x70:
7420              case 0x71:
7421              case 0x72:
7422              case 0x73:
7423              case 0x74:
7424              case 0x75:
7425              case 0x76:
7426              case 0x77:
7427              {
7428                  return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
7429              }
7430              case 0x78: 
7431              {
7432                  std::uint8_t len{};
7433                  return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
7434              }
7435              case 0x79: 
7436              {
7437                  std::uint16_t len{};
7438                  return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
7439              }
7440              case 0x7A: 
7441              {
7442                  std::uint32_t len{};
7443                  return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
7444              }
7445              case 0x7B: 
7446              {
7447                  std::uint64_t len{};
7448                  return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
7449              }
7450              case 0x7F: 
7451              {
7452                  while (get() != 0xFF)
7453                  {
7454                      string_t chunk;
7455                      if (!get_cbor_string(chunk))
7456                      {
7457                          return false;
7458                      }
7459                      result.append(chunk);
7460                  }
7461                  return true;
7462              }
7463              default:
7464              {
7465                  auto last_token = get_token_string();
7466                  return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
7467                                          exception_message(input_format_t::cbor, concat("expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x", last_token), "string"), nullptr));
7468              }
7469          }
7470      }
7471      bool get_cbor_binary(binary_t& result)
7472      {
7473          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "binary")))
7474          {
7475              return false;
7476          }
7477          switch (current)
7478          {
7479              case 0x40:
7480              case 0x41:
7481              case 0x42:
7482              case 0x43:
7483              case 0x44:
7484              case 0x45:
7485              case 0x46:
7486              case 0x47:
7487              case 0x48:
7488              case 0x49:
7489              case 0x4A:
7490              case 0x4B:
7491              case 0x4C:
7492              case 0x4D:
7493              case 0x4E:
7494              case 0x4F:
7495              case 0x50:
7496              case 0x51:
7497              case 0x52:
7498              case 0x53:
7499              case 0x54:
7500              case 0x55:
7501              case 0x56:
7502              case 0x57:
7503              {
7504                  return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
7505              }
7506              case 0x58: 
7507              {
7508                  std::uint8_t len{};
7509                  return get_number(input_format_t::cbor, len) &&
7510                         get_binary(input_format_t::cbor, len, result);
7511              }
7512              case 0x59: 
7513              {
7514                  std::uint16_t len{};
7515                  return get_number(input_format_t::cbor, len) &&
7516                         get_binary(input_format_t::cbor, len, result);
7517              }
7518              case 0x5A: 
7519              {
7520                  std::uint32_t len{};
7521                  return get_number(input_format_t::cbor, len) &&
7522                         get_binary(input_format_t::cbor, len, result);
7523              }
7524              case 0x5B: 
7525              {
7526                  std::uint64_t len{};
7527                  return get_number(input_format_t::cbor, len) &&
7528                         get_binary(input_format_t::cbor, len, result);
7529              }
7530              case 0x5F: 
7531              {
7532                  while (get() != 0xFF)
7533                  {
7534                      binary_t chunk;
7535                      if (!get_cbor_binary(chunk))
7536                      {
7537                          return false;
7538                      }
7539                      result.insert(result.end(), chunk.begin(), chunk.end());
7540                  }
7541                  return true;
7542              }
7543              default:
7544              {
7545                  auto last_token = get_token_string();
7546                  return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
7547                                          exception_message(input_format_t::cbor, concat("expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x", last_token), "binary"), nullptr));
7548              }
7549          }
7550      }
7551      bool get_cbor_array(const std::size_t len,
7552                          const cbor_tag_handler_t tag_handler)
7553      {
7554          if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
7555          {
7556              return false;
7557          }
7558          if (len != static_cast<std::size_t>(-1))
7559          {
7560              for (std::size_t i = 0; i < len; ++i)
7561              {
7562                  if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
7563                  {
7564                      return false;
7565                  }
7566              }
7567          }
7568          else
7569          {
7570              while (get() != 0xFF)
7571              {
7572                  if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
7573                  {
7574                      return false;
7575                  }
7576              }
7577          }
7578          return sax->end_array();
7579      }
7580      bool get_cbor_object(const std::size_t len,
7581                           const cbor_tag_handler_t tag_handler)
7582      {
7583          if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
7584          {
7585              return false;
7586          }
7587          if (len != 0)
7588          {
7589              string_t key;
7590              if (len != static_cast<std::size_t>(-1))
7591              {
7592                  for (std::size_t i = 0; i < len; ++i)
7593                  {
7594                      get();
7595                      if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
7596                      {
7597                          return false;
7598                      }
7599                      if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
7600                      {
7601                          return false;
7602                      }
7603                      key.clear();
7604                  }
7605              }
7606              else
7607              {
7608                  while (get() != 0xFF)
7609                  {
7610                      if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
7611                      {
7612                          return false;
7613                      }
7614                      if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
7615                      {
7616                          return false;
7617                      }
7618                      key.clear();
7619                  }
7620              }
7621          }
7622          return sax->end_object();
7623      }
7624      bool parse_msgpack_internal()
7625      {
7626          switch (get())
7627          {
7628              case std::char_traits<char_type>::eof():
7629                  return unexpect_eof(input_format_t::msgpack, "value");
7630              case 0x00:
7631              case 0x01:
7632              case 0x02:
7633              case 0x03:
7634              case 0x04:
7635              case 0x05:
7636              case 0x06:
7637              case 0x07:
7638              case 0x08:
7639              case 0x09:
7640              case 0x0A:
7641              case 0x0B:
7642              case 0x0C:
7643              case 0x0D:
7644              case 0x0E:
7645              case 0x0F:
7646              case 0x10:
7647              case 0x11:
7648              case 0x12:
7649              case 0x13:
7650              case 0x14:
7651              case 0x15:
7652              case 0x16:
7653              case 0x17:
7654              case 0x18:
7655              case 0x19:
7656              case 0x1A:
7657              case 0x1B:
7658              case 0x1C:
7659              case 0x1D:
7660              case 0x1E:
7661              case 0x1F:
7662              case 0x20:
7663              case 0x21:
7664              case 0x22:
7665              case 0x23:
7666              case 0x24:
7667              case 0x25:
7668              case 0x26:
7669              case 0x27:
7670              case 0x28:
7671              case 0x29:
7672              case 0x2A:
7673              case 0x2B:
7674              case 0x2C:
7675              case 0x2D:
7676              case 0x2E:
7677              case 0x2F:
7678              case 0x30:
7679              case 0x31:
7680              case 0x32:
7681              case 0x33:
7682              case 0x34:
7683              case 0x35:
7684              case 0x36:
7685              case 0x37:
7686              case 0x38:
7687              case 0x39:
7688              case 0x3A:
7689              case 0x3B:
7690              case 0x3C:
7691              case 0x3D:
7692              case 0x3E:
7693              case 0x3F:
7694              case 0x40:
7695              case 0x41:
7696              case 0x42:
7697              case 0x43:
7698              case 0x44:
7699              case 0x45:
7700              case 0x46:
7701              case 0x47:
7702              case 0x48:
7703              case 0x49:
7704              case 0x4A:
7705              case 0x4B:
7706              case 0x4C:
7707              case 0x4D:
7708              case 0x4E:
7709              case 0x4F:
7710              case 0x50:
7711              case 0x51:
7712              case 0x52:
7713              case 0x53:
7714              case 0x54:
7715              case 0x55:
7716              case 0x56:
7717              case 0x57:
7718              case 0x58:
7719              case 0x59:
7720              case 0x5A:
7721              case 0x5B:
7722              case 0x5C:
7723              case 0x5D:
7724              case 0x5E:
7725              case 0x5F:
7726              case 0x60:
7727              case 0x61:
7728              case 0x62:
7729              case 0x63:
7730              case 0x64:
7731              case 0x65:
7732              case 0x66:
7733              case 0x67:
7734              case 0x68:
7735              case 0x69:
7736              case 0x6A:
7737              case 0x6B:
7738              case 0x6C:
7739              case 0x6D:
7740              case 0x6E:
7741              case 0x6F:
7742              case 0x70:
7743              case 0x71:
7744              case 0x72:
7745              case 0x73:
7746              case 0x74:
7747              case 0x75:
7748              case 0x76:
7749              case 0x77:
7750              case 0x78:
7751              case 0x79:
7752              case 0x7A:
7753              case 0x7B:
7754              case 0x7C:
7755              case 0x7D:
7756              case 0x7E:
7757              case 0x7F:
7758                  return sax->number_unsigned(static_cast<number_unsigned_t>(current));
7759              case 0x80:
7760              case 0x81:
7761              case 0x82:
7762              case 0x83:
7763              case 0x84:
7764              case 0x85:
7765              case 0x86:
7766              case 0x87:
7767              case 0x88:
7768              case 0x89:
7769              case 0x8A:
7770              case 0x8B:
7771              case 0x8C:
7772              case 0x8D:
7773              case 0x8E:
7774              case 0x8F:
7775                  return get_msgpack_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));
7776              case 0x90:
7777              case 0x91:
7778              case 0x92:
7779              case 0x93:
7780              case 0x94:
7781              case 0x95:
7782              case 0x96:
7783              case 0x97:
7784              case 0x98:
7785              case 0x99:
7786              case 0x9A:
7787              case 0x9B:
7788              case 0x9C:
7789              case 0x9D:
7790              case 0x9E:
7791              case 0x9F:
7792                  return get_msgpack_array(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));
7793              case 0xA0:
7794              case 0xA1:
7795              case 0xA2:
7796              case 0xA3:
7797              case 0xA4:
7798              case 0xA5:
7799              case 0xA6:
7800              case 0xA7:
7801              case 0xA8:
7802              case 0xA9:
7803              case 0xAA:
7804              case 0xAB:
7805              case 0xAC:
7806              case 0xAD:
7807              case 0xAE:
7808              case 0xAF:
7809              case 0xB0:
7810              case 0xB1:
7811              case 0xB2:
7812              case 0xB3:
7813              case 0xB4:
7814              case 0xB5:
7815              case 0xB6:
7816              case 0xB7:
7817              case 0xB8:
7818              case 0xB9:
7819              case 0xBA:
7820              case 0xBB:
7821              case 0xBC:
7822              case 0xBD:
7823              case 0xBE:
7824              case 0xBF:
7825              case 0xD9: 
7826              case 0xDA: 
7827              case 0xDB: 
7828              {
7829                  string_t s;
7830                  return get_msgpack_string(s) && sax->string(s);
7831              }
7832              case 0xC0: 
7833                  return sax->null();
7834              case 0xC2: 
7835                  return sax->boolean(false);
7836              case 0xC3: 
7837                  return sax->boolean(true);
7838              case 0xC4: 
7839              case 0xC5: 
7840              case 0xC6: 
7841              case 0xC7: 
7842              case 0xC8: 
7843              case 0xC9: 
7844              case 0xD4: 
7845              case 0xD5: 
7846              case 0xD6: 
7847              case 0xD7: 
7848              case 0xD8: 
7849              {
7850                  binary_t b;
7851                  return get_msgpack_binary(b) && sax->binary(b);
7852              }
7853              case 0xCA: 
7854              {
7855                  float number{};
7856                  return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
7857              }
7858              case 0xCB: 
7859              {
7860                  double number{};
7861                  return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
7862              }
7863              case 0xCC: 
7864              {
7865                  std::uint8_t number{};
7866                  return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
7867              }
7868              case 0xCD: 
7869              {
7870                  std::uint16_t number{};
7871                  return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
7872              }
7873              case 0xCE: 
7874              {
7875                  std::uint32_t number{};
7876                  return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
7877              }
7878              case 0xCF: 
7879              {
7880                  std::uint64_t number{};
7881                  return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
7882              }
7883              case 0xD0: 
7884              {
7885                  std::int8_t number{};
7886                  return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
7887              }
7888              case 0xD1: 
7889              {
7890                  std::int16_t number{};
7891                  return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
7892              }
7893              case 0xD2: 
7894              {
7895                  std::int32_t number{};
7896                  return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
7897              }
7898              case 0xD3: 
7899              {
7900                  std::int64_t number{};
7901                  return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
7902              }
7903              case 0xDC: 
7904              {
7905                  std::uint16_t len{};
7906                  return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
7907              }
7908              case 0xDD: 
7909              {
7910                  std::uint32_t len{};
7911                  return get_number(input_format_t::msgpack, len) && get_msgpack_array(conditional_static_cast<std::size_t>(len));
7912              }
7913              case 0xDE: 
7914              {
7915                  std::uint16_t len{};
7916                  return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
7917              }
7918              case 0xDF: 
7919              {
7920                  std::uint32_t len{};
7921                  return get_number(input_format_t::msgpack, len) && get_msgpack_object(conditional_static_cast<std::size_t>(len));
7922              }
7923              case 0xE0:
7924              case 0xE1:
7925              case 0xE2:
7926              case 0xE3:
7927              case 0xE4:
7928              case 0xE5:
7929              case 0xE6:
7930              case 0xE7:
7931              case 0xE8:
7932              case 0xE9:
7933              case 0xEA:
7934              case 0xEB:
7935              case 0xEC:
7936              case 0xED:
7937              case 0xEE:
7938              case 0xEF:
7939              case 0xF0:
7940              case 0xF1:
7941              case 0xF2:
7942              case 0xF3:
7943              case 0xF4:
7944              case 0xF5:
7945              case 0xF6:
7946              case 0xF7:
7947              case 0xF8:
7948              case 0xF9:
7949              case 0xFA:
7950              case 0xFB:
7951              case 0xFC:
7952              case 0xFD:
7953              case 0xFE:
7954              case 0xFF:
7955                  return sax->number_integer(static_cast<std::int8_t>(current));
7956              default: 
7957              {
7958                  auto last_token = get_token_string();
7959                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
7960                                          exception_message(input_format_t::msgpack, concat("invalid byte: 0x", last_token), "value"), nullptr));
7961              }
7962          }
7963      }
7964      bool get_msgpack_string(string_t& result)
7965      {
7966          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, "string")))
7967          {
7968              return false;
7969          }
7970          switch (current)
7971          {
7972              case 0xA0:
7973              case 0xA1:
7974              case 0xA2:
7975              case 0xA3:
7976              case 0xA4:
7977              case 0xA5:
7978              case 0xA6:
7979              case 0xA7:
7980              case 0xA8:
7981              case 0xA9:
7982              case 0xAA:
7983              case 0xAB:
7984              case 0xAC:
7985              case 0xAD:
7986              case 0xAE:
7987              case 0xAF:
7988              case 0xB0:
7989              case 0xB1:
7990              case 0xB2:
7991              case 0xB3:
7992              case 0xB4:
7993              case 0xB5:
7994              case 0xB6:
7995              case 0xB7:
7996              case 0xB8:
7997              case 0xB9:
7998              case 0xBA:
7999              case 0xBB:
8000              case 0xBC:
8001              case 0xBD:
8002              case 0xBE:
8003              case 0xBF:
8004              {
8005                  return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
8006              }
8007              case 0xD9: 
8008              {
8009                  std::uint8_t len{};
8010                  return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
8011              }
8012              case 0xDA: 
8013              {
8014                  std::uint16_t len{};
8015                  return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
8016              }
8017              case 0xDB: 
8018              {
8019                  std::uint32_t len{};
8020                  return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
8021              }
8022              default:
8023              {
8024                  auto last_token = get_token_string();
8025                  return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
8026                                          exception_message(input_format_t::msgpack, concat("expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x", last_token), "string"), nullptr));
8027              }
8028          }
8029      }
8030      bool get_msgpack_binary(binary_t& result)
8031      {
8032          auto assign_and_return_true = [&result](std::int8_t subtype)
8033          {
8034              result.set_subtype(static_cast<std::uint8_t>(subtype));
8035              return true;
8036          };
8037          switch (current)
8038          {
8039              case 0xC4: 
8040              {
8041                  std::uint8_t len{};
8042                  return get_number(input_format_t::msgpack, len) &&
8043                         get_binary(input_format_t::msgpack, len, result);
8044              }
8045              case 0xC5: 
8046              {
8047                  std::uint16_t len{};
8048                  return get_number(input_format_t::msgpack, len) &&
8049                         get_binary(input_format_t::msgpack, len, result);
8050              }
8051              case 0xC6: 
8052              {
8053                  std::uint32_t len{};
8054                  return get_number(input_format_t::msgpack, len) &&
8055                         get_binary(input_format_t::msgpack, len, result);
8056              }
8057              case 0xC7: 
8058              {
8059                  std::uint8_t len{};
8060                  std::int8_t subtype{};
8061                  return get_number(input_format_t::msgpack, len) &&
8062                         get_number(input_format_t::msgpack, subtype) &&
8063                         get_binary(input_format_t::msgpack, len, result) &&
8064                         assign_and_return_true(subtype);
8065              }
8066              case 0xC8: 
8067              {
8068                  std::uint16_t len{};
8069                  std::int8_t subtype{};
8070                  return get_number(input_format_t::msgpack, len) &&
8071                         get_number(input_format_t::msgpack, subtype) &&
8072                         get_binary(input_format_t::msgpack, len, result) &&
8073                         assign_and_return_true(subtype);
8074              }
8075              case 0xC9: 
8076              {
8077                  std::uint32_t len{};
8078                  std::int8_t subtype{};
8079                  return get_number(input_format_t::msgpack, len) &&
8080                         get_number(input_format_t::msgpack, subtype) &&
8081                         get_binary(input_format_t::msgpack, len, result) &&
8082                         assign_and_return_true(subtype);
8083              }
8084              case 0xD4: 
8085              {
8086                  std::int8_t subtype{};
8087                  return get_number(input_format_t::msgpack, subtype) &&
8088                         get_binary(input_format_t::msgpack, 1, result) &&
8089                         assign_and_return_true(subtype);
8090              }
8091              case 0xD5: 
8092              {
8093                  std::int8_t subtype{};
8094                  return get_number(input_format_t::msgpack, subtype) &&
8095                         get_binary(input_format_t::msgpack, 2, result) &&
8096                         assign_and_return_true(subtype);
8097              }
8098              case 0xD6: 
8099              {
8100                  std::int8_t subtype{};
8101                  return get_number(input_format_t::msgpack, subtype) &&
8102                         get_binary(input_format_t::msgpack, 4, result) &&
8103                         assign_and_return_true(subtype);
8104              }
8105              case 0xD7: 
8106              {
8107                  std::int8_t subtype{};
8108                  return get_number(input_format_t::msgpack, subtype) &&
8109                         get_binary(input_format_t::msgpack, 8, result) &&
8110                         assign_and_return_true(subtype);
8111              }
8112              case 0xD8: 
8113              {
8114                  std::int8_t subtype{};
8115                  return get_number(input_format_t::msgpack, subtype) &&
8116                         get_binary(input_format_t::msgpack, 16, result) &&
8117                         assign_and_return_true(subtype);
8118              }
8119              default:           
8120                  return false;  
8121          }
8122      }
8123      bool get_msgpack_array(const std::size_t len)
8124      {
8125          if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
8126          {
8127              return false;
8128          }
8129          for (std::size_t i = 0; i < len; ++i)
8130          {
8131              if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
8132              {
8133                  return false;
8134              }
8135          }
8136          return sax->end_array();
8137      }
8138      bool get_msgpack_object(const std::size_t len)
8139      {
8140          if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
8141          {
8142              return false;
8143          }
8144          string_t key;
8145          for (std::size_t i = 0; i < len; ++i)
8146          {
8147              get();
8148              if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))
8149              {
8150                  return false;
8151              }
8152              if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
8153              {
8154                  return false;
8155              }
8156              key.clear();
8157          }
8158          return sax->end_object();
8159      }
8160      bool parse_ubjson_internal(const bool get_char = true)
8161      {
8162          return get_ubjson_value(get_char ? get_ignore_noop() : current);
8163      }
8164      bool get_ubjson_string(string_t& result, const bool get_char = true)
8165      {
8166          if (get_char)
8167          {
8168              get();  
8169          }
8170          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
8171          {
8172              return false;
8173          }
8174          switch (current)
8175          {
8176              case 'U':
8177              {
8178                  std::uint8_t len{};
8179                  return get_number(input_format, len) && get_string(input_format, len, result);
8180              }
8181              case 'i':
8182              {
8183                  std::int8_t len{};
8184                  return get_number(input_format, len) && get_string(input_format, len, result);
8185              }
8186              case 'I':
8187              {
8188                  std::int16_t len{};
8189                  return get_number(input_format, len) && get_string(input_format, len, result);
8190              }
8191              case 'l':
8192              {
8193                  std::int32_t len{};
8194                  return get_number(input_format, len) && get_string(input_format, len, result);
8195              }
8196              case 'L':
8197              {
8198                  std::int64_t len{};
8199                  return get_number(input_format, len) && get_string(input_format, len, result);
8200              }
8201              case 'u':
8202              {
8203                  if (input_format != input_format_t::bjdata)
8204                  {
8205                      break;
8206                  }
8207                  std::uint16_t len{};
8208                  return get_number(input_format, len) && get_string(input_format, len, result);
8209              }
8210              case 'm':
8211              {
8212                  if (input_format != input_format_t::bjdata)
8213                  {
8214                      break;
8215                  }
8216                  std::uint32_t len{};
8217                  return get_number(input_format, len) && get_string(input_format, len, result);
8218              }
8219              case 'M':
8220              {
8221                  if (input_format != input_format_t::bjdata)
8222                  {
8223                      break;
8224                  }
8225                  std::uint64_t len{};
8226                  return get_number(input_format, len) && get_string(input_format, len, result);
8227              }
8228              default:
8229                  break;
8230          }
8231          auto last_token = get_token_string();
8232          std::string message;
8233          if (input_format != input_format_t::bjdata)
8234          {
8235              message = "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token;
8236          }
8237          else
8238          {
8239              message = "expected length type specification (U, i, u, I, m, l, M, L); last byte: 0x" + last_token;
8240          }
8241          return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "string"), nullptr));
8242      }
8243      bool get_ubjson_ndarray_size(std::vector<size_t>& dim)
8244      {
8245          std::pair<std::size_t, char_int_type> size_and_type;
8246          size_t dimlen = 0;
8247          bool no_ndarray = true;
8248          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type, no_ndarray)))
8249          {
8250              return false;
8251          }
8252          if (size_and_type.first != npos)
8253          {
8254              if (size_and_type.second != 0)
8255              {
8256                  if (size_and_type.second != 'N')
8257                  {
8258                      for (std::size_t i = 0; i < size_and_type.first; ++i)
8259                      {
8260                          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, size_and_type.second)))
8261                          {
8262                              return false;
8263                          }
8264                          dim.push_back(dimlen);
8265                      }
8266                  }
8267              }
8268              else
8269              {
8270                  for (std::size_t i = 0; i < size_and_type.first; ++i)
8271                  {
8272                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray)))
8273                      {
8274                          return false;
8275                      }
8276                      dim.push_back(dimlen);
8277                  }
8278              }
8279          }
8280          else
8281          {
8282              while (current != ']')
8283              {
8284                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, current)))
8285                  {
8286                      return false;
8287                  }
8288                  dim.push_back(dimlen);
8289                  get_ignore_noop();
8290              }
8291          }
8292          return true;
8293      }
8294      bool get_ubjson_size_value(std::size_t& result, bool& is_ndarray, char_int_type prefix = 0)
8295      {
8296          if (prefix == 0)
8297          {
8298              prefix = get_ignore_noop();
8299          }
8300          switch (prefix)
8301          {
8302              case 'U':
8303              {
8304                  std::uint8_t number{};
8305                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8306                  {
8307                      return false;
8308                  }
8309                  result = static_cast<std::size_t>(number);
8310                  return true;
8311              }
8312              case 'i':
8313              {
8314                  std::int8_t number{};
8315                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8316                  {
8317                      return false;
8318                  }
8319                  if (number < 0)
8320                  {
8321                      return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
8322                                              exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
8323                  }
8324                  result = static_cast<std::size_t>(number); 
8325                  return true;
8326              }
8327              case 'I':
8328              {
8329                  std::int16_t number{};
8330                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8331                  {
8332                      return false;
8333                  }
8334                  if (number < 0)
8335                  {
8336                      return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
8337                                              exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
8338                  }
8339                  result = static_cast<std::size_t>(number);
8340                  return true;
8341              }
8342              case 'l':
8343              {
8344                  std::int32_t number{};
8345                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8346                  {
8347                      return false;
8348                  }
8349                  if (number < 0)
8350                  {
8351                      return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
8352                                              exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
8353                  }
8354                  result = static_cast<std::size_t>(number);
8355                  return true;
8356              }
8357              case 'L':
8358              {
8359                  std::int64_t number{};
8360                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8361                  {
8362                      return false;
8363                  }
8364                  if (number < 0)
8365                  {
8366                      return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
8367                                              exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
8368                  }
8369                  if (!value_in_range_of<std::size_t>(number))
8370                  {
8371                      return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
8372                                              exception_message(input_format, "integer value overflow", "size"), nullptr));
8373                  }
8374                  result = static_cast<std::size_t>(number);
8375                  return true;
8376              }
8377              case 'u':
8378              {
8379                  if (input_format != input_format_t::bjdata)
8380                  {
8381                      break;
8382                  }
8383                  std::uint16_t number{};
8384                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8385                  {
8386                      return false;
8387                  }
8388                  result = static_cast<std::size_t>(number);
8389                  return true;
8390              }
8391              case 'm':
8392              {
8393                  if (input_format != input_format_t::bjdata)
8394                  {
8395                      break;
8396                  }
8397                  std::uint32_t number{};
8398                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8399                  {
8400                      return false;
8401                  }
8402                  result = conditional_static_cast<std::size_t>(number);
8403                  return true;
8404              }
8405              case 'M':
8406              {
8407                  if (input_format != input_format_t::bjdata)
8408                  {
8409                      break;
8410                  }
8411                  std::uint64_t number{};
8412                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8413                  {
8414                      return false;
8415                  }
8416                  if (!value_in_range_of<std::size_t>(number))
8417                  {
8418                      return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
8419                                              exception_message(input_format, "integer value overflow", "size"), nullptr));
8420                  }
8421                  result = detail::conditional_static_cast<std::size_t>(number);
8422                  return true;
8423              }
8424              case '[':
8425              {
8426                  if (input_format != input_format_t::bjdata)
8427                  {
8428                      break;
8429                  }
8430                  if (is_ndarray) 
8431                  {
8432                      return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read, exception_message(input_format, "ndarray dimentional vector is not allowed", "size"), nullptr));
8433                  }
8434                  std::vector<size_t> dim;
8435                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_ndarray_size(dim)))
8436                  {
8437                      return false;
8438                  }
8439                  if (dim.size() == 1 || (dim.size() == 2 && dim.at(0) == 1)) 
8440                  {
8441                      result = dim.at(dim.size() - 1);
8442                      return true;
8443                  }
8444                  if (!dim.empty())  
8445                  {
8446                      for (auto i : dim) 
8447                      {
8448                          if ( i == 0 )
8449                          {
8450                              result = 0;
8451                              return true;
8452                          }
8453                      }
8454                      string_t key = "_ArraySize_";
8455                      if (JSON_HEDLEY_UNLIKELY(!sax->start_object(3) || !sax->key(key) || !sax->start_array(dim.size())))
8456                      {
8457                          return false;
8458                      }
8459                      result = 1;
8460                      for (auto i : dim)
8461                      {
8462                          result *= i;
8463                          if (result == 0 || result == npos) 
8464                          {
8465                              return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408, exception_message(input_format, "excessive ndarray size caused overflow", "size"), nullptr));
8466                          }
8467                          if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(static_cast<number_unsigned_t>(i))))
8468                          {
8469                              return false;
8470                          }
8471                      }
8472                      is_ndarray = true;
8473                      return sax->end_array();
8474                  }
8475                  result = 0;
8476                  return true;
8477              }
8478              default:
8479                  break;
8480          }
8481          auto last_token = get_token_string();
8482          std::string message;
8483          if (input_format != input_format_t::bjdata)
8484          {
8485              message = "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token;
8486          }
8487          else
8488          {
8489              message = "expected length type specification (U, i, u, I, m, l, M, L) after '#'; last byte: 0x" + last_token;
8490          }
8491          return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "size"), nullptr));
8492      }
8493      bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result, bool inside_ndarray = false)
8494      {
8495          result.first = npos; 
8496          result.second = 0; 
8497          bool is_ndarray = false;
8498          get_ignore_noop();
8499          if (current == '$')
8500          {
8501              result.second = get();  
8502              if (input_format == input_format_t::bjdata
8503                      && JSON_HEDLEY_UNLIKELY(std::binary_search(bjd_optimized_type_markers.begin(), bjd_optimized_type_markers.end(), result.second)))
8504              {
8505                  auto last_token = get_token_string();
8506                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
8507                                          exception_message(input_format, concat("marker 0x", last_token, " is not a permitted optimized array type"), "type"), nullptr));
8508              }
8509              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "type")))
8510              {
8511                  return false;
8512              }
8513              get_ignore_noop();
8514              if (JSON_HEDLEY_UNLIKELY(current != '#'))
8515              {
8516                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
8517                  {
8518                      return false;
8519                  }
8520                  auto last_token = get_token_string();
8521                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
8522                                          exception_message(input_format, concat("expected '#' after type information; last byte: 0x", last_token), "size"), nullptr));
8523              }
8524              bool is_error = get_ubjson_size_value(result.first, is_ndarray);
8525              if (input_format == input_format_t::bjdata && is_ndarray)
8526              {
8527                  if (inside_ndarray)
8528                  {
8529                      return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
8530                                              exception_message(input_format, "ndarray can not be recursive", "size"), nullptr));
8531                  }
8532                  result.second |= (1 << 8); 
8533              }
8534              return is_error;
8535          }
8536          if (current == '#')
8537          {
8538              bool is_error = get_ubjson_size_value(result.first, is_ndarray);
8539              if (input_format == input_format_t::bjdata && is_ndarray)
8540              {
8541                  return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
8542                                          exception_message(input_format, "ndarray requires both type and size", "size"), nullptr));
8543              }
8544              return is_error;
8545          }
8546          return true;
8547      }
8548      bool get_ubjson_value(const char_int_type prefix)
8549      {
8550          switch (prefix)
8551          {
8552              case std::char_traits<char_type>::eof():  
8553                  return unexpect_eof(input_format, "value");
8554              case 'T':  
8555                  return sax->boolean(true);
8556              case 'F':  
8557                  return sax->boolean(false);
8558              case 'Z':  
8559                  return sax->null();
8560              case 'U':
8561              {
8562                  std::uint8_t number{};
8563                  return get_number(input_format, number) && sax->number_unsigned(number);
8564              }
8565              case 'i':
8566              {
8567                  std::int8_t number{};
8568                  return get_number(input_format, number) && sax->number_integer(number);
8569              }
8570              case 'I':
8571              {
8572                  std::int16_t number{};
8573                  return get_number(input_format, number) && sax->number_integer(number);
8574              }
8575              case 'l':
8576              {
8577                  std::int32_t number{};
8578                  return get_number(input_format, number) && sax->number_integer(number);
8579              }
8580              case 'L':
8581              {
8582                  std::int64_t number{};
8583                  return get_number(input_format, number) && sax->number_integer(number);
8584              }
8585              case 'u':
8586              {
8587                  if (input_format != input_format_t::bjdata)
8588                  {
8589                      break;
8590                  }
8591                  std::uint16_t number{};
8592                  return get_number(input_format, number) && sax->number_unsigned(number);
8593              }
8594              case 'm':
8595              {
8596                  if (input_format != input_format_t::bjdata)
8597                  {
8598                      break;
8599                  }
8600                  std::uint32_t number{};
8601                  return get_number(input_format, number) && sax->number_unsigned(number);
8602              }
8603              case 'M':
8604              {
8605                  if (input_format != input_format_t::bjdata)
8606                  {
8607                      break;
8608                  }
8609                  std::uint64_t number{};
8610                  return get_number(input_format, number) && sax->number_unsigned(number);
8611              }
8612              case 'h':
8613              {
8614                  if (input_format != input_format_t::bjdata)
8615                  {
8616                      break;
8617                  }
8618                  const auto byte1_raw = get();
8619                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
8620                  {
8621                      return false;
8622                  }
8623                  const auto byte2_raw = get();
8624                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
8625                  {
8626                      return false;
8627                  }
8628                  const auto byte1 = static_cast<unsigned char>(byte1_raw);
8629                  const auto byte2 = static_cast<unsigned char>(byte2_raw);
8630                  const auto half = static_cast<unsigned int>((byte2 << 8u) + byte1);
8631                  const double val = [&half]
8632                  {
8633                      const int exp = (half >> 10u) & 0x1Fu;
8634                      const unsigned int mant = half & 0x3FFu;
8635                      JSON_ASSERT(0 <= exp&& exp <= 32);
8636                      JSON_ASSERT(mant <= 1024);
8637                      switch (exp)
8638                      {
8639                          case 0:
8640                              return std::ldexp(mant, -24);
8641                          case 31:
8642                              return (mant == 0)
8643                              ? std::numeric_limits<double>::infinity()
8644                              : std::numeric_limits<double>::quiet_NaN();
8645                          default:
8646                              return std::ldexp(mant + 1024, exp - 25);
8647                      }
8648                  }();
8649                  return sax->number_float((half & 0x8000u) != 0
8650                                           ? static_cast<number_float_t>(-val)
8651                                           : static_cast<number_float_t>(val), "");
8652              }
8653              case 'd':
8654              {
8655                  float number{};
8656                  return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
8657              }
8658              case 'D':
8659              {
8660                  double number{};
8661                  return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
8662              }
8663              case 'H':
8664              {
8665                  return get_ubjson_high_precision_number();
8666              }
8667              case 'C':  
8668              {
8669                  get();
8670                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "char")))
8671                  {
8672                      return false;
8673                  }
8674                  if (JSON_HEDLEY_UNLIKELY(current > 127))
8675                  {
8676                      auto last_token = get_token_string();
8677                      return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
8678                                              exception_message(input_format, concat("byte after 'C' must be in range 0x00..0x7F; last byte: 0x", last_token), "char"), nullptr));
8679                  }
8680                  string_t s(1, static_cast<typename string_t::value_type>(current));
8681                  return sax->string(s);
8682              }
8683              case 'S':  
8684              {
8685                  string_t s;
8686                  return get_ubjson_string(s) && sax->string(s);
8687              }
8688              case '[':  
8689                  return get_ubjson_array();
8690              case '{':  
8691                  return get_ubjson_object();
8692              default: 
8693                  break;
8694          }
8695          auto last_token = get_token_string();
8696          return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format, "invalid byte: 0x" + last_token, "value"), nullptr));
8697      }
8698      bool get_ubjson_array()
8699      {
8700          std::pair<std::size_t, char_int_type> size_and_type;
8701          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
8702          {
8703              return false;
8704          }
8705          if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
8706          {
8707              size_and_type.second &= ~(static_cast<char_int_type>(1) << 8);  
8708              auto it = std::lower_bound(bjd_types_map.begin(), bjd_types_map.end(), size_and_type.second, [](const bjd_type & p, char_int_type t)
8709              {
8710                  return p.first < t;
8711              });
8712              string_t key = "_ArrayType_";
8713              if (JSON_HEDLEY_UNLIKELY(it == bjd_types_map.end() || it->first != size_and_type.second))
8714              {
8715                  auto last_token = get_token_string();
8716                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
8717                                          exception_message(input_format, "invalid byte: 0x" + last_token, "type"), nullptr));
8718              }
8719              string_t type = it->second; 
8720              if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->string(type)))
8721              {
8722                  return false;
8723              }
8724              if (size_and_type.second == 'C')
8725              {
8726                  size_and_type.second = 'U';
8727              }
8728              key = "_ArrayData_";
8729              if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->start_array(size_and_type.first) ))
8730              {
8731                  return false;
8732              }
8733              for (std::size_t i = 0; i < size_and_type.first; ++i)
8734              {
8735                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
8736                  {
8737                      return false;
8738                  }
8739              }
8740              return (sax->end_array() && sax->end_object());
8741          }
8742          if (size_and_type.first != npos)
8743          {
8744              if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))
8745              {
8746                  return false;
8747              }
8748              if (size_and_type.second != 0)
8749              {
8750                  if (size_and_type.second != 'N')
8751                  {
8752                      for (std::size_t i = 0; i < size_and_type.first; ++i)
8753                      {
8754                          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
8755                          {
8756                              return false;
8757                          }
8758                      }
8759                  }
8760              }
8761              else
8762              {
8763                  for (std::size_t i = 0; i < size_and_type.first; ++i)
8764                  {
8765                      if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
8766                      {
8767                          return false;
8768                      }
8769                  }
8770              }
8771          }
8772          else
8773          {
8774              if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
8775              {
8776                  return false;
8777              }
8778              while (current != ']')
8779              {
8780                  if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
8781                  {
8782                      return false;
8783                  }
8784                  get_ignore_noop();
8785              }
8786          }
8787          return sax->end_array();
8788      }
8789      bool get_ubjson_object()
8790      {
8791          std::pair<std::size_t, char_int_type> size_and_type;
8792          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
8793          {
8794              return false;
8795          }
8796          if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
8797          {
8798              auto last_token = get_token_string();
8799              return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
8800                                      exception_message(input_format, "BJData object does not support ND-array size in optimized format", "object"), nullptr));
8801          }
8802          string_t key;
8803          if (size_and_type.first != npos)
8804          {
8805              if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))
8806              {
8807                  return false;
8808              }
8809              if (size_and_type.second != 0)
8810              {
8811                  for (std::size_t i = 0; i < size_and_type.first; ++i)
8812                  {
8813                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
8814                      {
8815                          return false;
8816                      }
8817                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
8818                      {
8819                          return false;
8820                      }
8821                      key.clear();
8822                  }
8823              }
8824              else
8825              {
8826                  for (std::size_t i = 0; i < size_and_type.first; ++i)
8827                  {
8828                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
8829                      {
8830                          return false;
8831                      }
8832                      if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
8833                      {
8834                          return false;
8835                      }
8836                      key.clear();
8837                  }
8838              }
8839          }
8840          else
8841          {
8842              if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
8843              {
8844                  return false;
8845              }
8846              while (current != '}')
8847              {
8848                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))
8849                  {
8850                      return false;
8851                  }
8852                  if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
8853                  {
8854                      return false;
8855                  }
8856                  get_ignore_noop();
8857                  key.clear();
8858              }
8859          }
8860          return sax->end_object();
8861      }
8862      bool get_ubjson_high_precision_number()
8863      {
8864          std::size_t size{};
8865          bool no_ndarray = true;
8866          auto res = get_ubjson_size_value(size, no_ndarray);
8867          if (JSON_HEDLEY_UNLIKELY(!res))
8868          {
8869              return res;
8870          }
8871          std::vector<char> number_vector;
8872          for (std::size_t i = 0; i < size; ++i)
8873          {
8874              get();
8875              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
8876              {
8877                  return false;
8878              }
8879              number_vector.push_back(static_cast<char>(current));
8880          }
8881          using ia_type = decltype(detail::input_adapter(number_vector));
8882          auto number_lexer = detail::lexer<BasicJsonType, ia_type>(detail::input_adapter(number_vector), false);
8883          const auto result_number = number_lexer.scan();
8884          const auto number_string = number_lexer.get_token_string();
8885          const auto result_remainder = number_lexer.scan();
8886          using token_type = typename detail::lexer_base<BasicJsonType>::token_type;
8887          if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
8888          {
8889              return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
8890                                      exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
<span onclick='openModal()' class='match'>8891          }
8892          switch (result_number)
8893          {
8894              case token_type::value_integer:
8895                  return sax->number_integer(number_lexer.get_number_integer());
8896              case token_type::value_unsigned:
8897                  return sax->number_unsigned(number_lexer.get_number_unsigned());
8898              case token_type::value_float:
8899                  return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
8900              case token_type::uninitialized:
8901              case token_type::literal_true:
</span>8902              case token_type::literal_false:
8903              case token_type::literal_null:
8904              case token_type::value_string:
8905              case token_type::begin_array:
8906              case token_type::begin_object:
8907              case token_type::end_array:
8908              case token_type::end_object:
8909              case token_type::name_separator:
8910              case token_type::value_separator:
8911              case token_type::parse_error:
8912              case token_type::end_of_input:
8913              case token_type::literal_or_value:
8914              default:
8915                  return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
8916                                          exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
8917          }
8918      }
8919      char_int_type get()
8920      {
8921          ++chars_read;
8922          return current = ia.get_character();
8923      }
8924      char_int_type get_ignore_noop()
8925      {
8926          do
8927          {
8928              get();
8929          }
8930          while (current == 'N');
8931          return current;
8932      }
8933      template<typename NumberType, bool InputIsLittleEndian = false>
8934      bool get_number(const input_format_t format, NumberType& result)
8935      {
8936          std::array<std::uint8_t, sizeof(NumberType)> vec{};
8937          for (std::size_t i = 0; i < sizeof(NumberType); ++i)
8938          {
8939              get();
8940              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "number")))
8941              {
8942                  return false;
8943              }
8944              if (is_little_endian != (InputIsLittleEndian || format == input_format_t::bjdata))
8945              {
8946                  vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
8947              }
8948              else
8949              {
8950                  vec[i] = static_cast<std::uint8_t>(current); 
8951              }
8952          }
8953          std::memcpy(&result, vec.data(), sizeof(NumberType));
8954          return true;
8955      }
8956      template<typename NumberType>
8957      bool get_string(const input_format_t format,
8958                      const NumberType len,
8959                      string_t& result)
8960      {
8961          bool success = true;
8962          for (NumberType i = 0; i < len; i++)
8963          {
8964              get();
8965              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "string")))
8966              {
8967                  success = false;
8968                  break;
8969              }
8970              result.push_back(static_cast<typename string_t::value_type>(current));
8971          }
8972          return success;
8973      }
8974      template<typename NumberType>
8975      bool get_binary(const input_format_t format,
8976                      const NumberType len,
8977                      binary_t& result)
8978      {
8979          bool success = true;
8980          for (NumberType i = 0; i < len; i++)
8981          {
8982              get();
8983              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "binary")))
8984              {
8985                  success = false;
8986                  break;
8987              }
8988              result.push_back(static_cast<std::uint8_t>(current));
8989          }
8990          return success;
8991      }
8992      JSON_HEDLEY_NON_NULL(3)
8993      bool unexpect_eof(const input_format_t format, const char* context) const
8994      {
8995          if (JSON_HEDLEY_UNLIKELY(current == std::char_traits<char_type>::eof()))
8996          {
8997              return sax->parse_error(chars_read, "<end of file>",
8998                                      parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context), nullptr));
8999          }
9000          return true;
9001      }
9002      std::string get_token_string() const
9003      {
9004          std::array<char, 3> cr{{}};
9005          static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current))); 
9006          return std::string{cr.data()};
9007      }
9008      std::string exception_message(const input_format_t format,
9009                                    const std::string& detail,
9010                                    const std::string& context) const
9011      {
9012          std::string error_msg = "syntax error while parsing ";
9013          switch (format)
9014          {
9015              case input_format_t::cbor:
9016                  error_msg += "CBOR";
9017                  break;
9018              case input_format_t::msgpack:
9019                  error_msg += "MessagePack";
9020                  break;
9021              case input_format_t::ubjson:
9022                  error_msg += "UBJSON";
9023                  break;
9024              case input_format_t::bson:
9025                  error_msg += "BSON";
9026                  break;
9027              case input_format_t::bjdata:
9028                  error_msg += "BJData";
9029                  break;
9030              case input_format_t::json: 
9031              default:            
9032                  JSON_ASSERT(false); 
9033          }
9034          return concat(error_msg, ' ', context, ": ", detail);
9035      }
9036    private:
9037      static JSON_INLINE_VARIABLE constexpr std::size_t npos = static_cast<std::size_t>(-1);
9038      InputAdapterType ia;
9039      char_int_type current = std::char_traits<char_type>::eof();
9040      std::size_t chars_read = 0;
9041      const bool is_little_endian = little_endianness();
9042      const input_format_t input_format = input_format_t::json;
9043      json_sax_t* sax = nullptr;
9044  #define JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_ \
9045      make_array<char_int_type>('F', 'H', 'N', 'S', 'T', 'Z', '[', '{')
9046  #define JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_ \
9047      make_array<bjd_type>(                      \
9048      bjd_type{'C', "char"},                     \
9049      bjd_type{'D', "double"},                   \
9050      bjd_type{'I', "int16"},                    \
9051      bjd_type{'L', "int64"},                    \
9052      bjd_type{'M', "uint64"},                   \
9053      bjd_type{'U', "uint8"},                    \
9054      bjd_type{'d', "single"},                   \
9055      bjd_type{'i', "int8"},                     \
9056      bjd_type{'l', "int32"},                    \
9057      bjd_type{'m', "uint32"},                   \
9058      bjd_type{'u', "uint16"})
9059    JSON_PRIVATE_UNLESS_TESTED:
9060      const decltype(JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_) bjd_optimized_type_markers =
9061          JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_;
9062      using bjd_type = std::pair<char_int_type, string_t>;
9063      const decltype(JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_) bjd_types_map =
9064          JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_;
9065  #undef JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_
9066  #undef JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_
9067  };
9068  #ifndef JSON_HAS_CPP_17
9069      template<typename BasicJsonType, typename InputAdapterType, typename SAX>
9070      constexpr std::size_t binary_reader<BasicJsonType, InputAdapterType, SAX>::npos;
9071  #endif
9072  }  
9073  NLOHMANN_JSON_NAMESPACE_END
9074  #include <cmath> 
9075  #include <cstdint> 
9076  #include <functional> 
9077  #include <string> 
9078  #include <utility> 
9079  #include <vector> 
9080  NLOHMANN_JSON_NAMESPACE_BEGIN
9081  namespace detail
9082  {
9083  enum class parse_event_t : std::uint8_t
9084  {
9085      object_start,
9086      object_end,
9087      array_start,
9088      array_end,
9089      key,
9090      value
9091  };
9092  template<typename BasicJsonType>
9093  using parser_callback_t =
9094      std::function<bool(int &bsol;*depth*/, parse_event_t &bsol;*event*/, BasicJsonType& &bsol;*parsed*/)>;
9095  template<typename BasicJsonType, typename InputAdapterType>
9096  class parser
9097  {
9098      using number_integer_t = typename BasicJsonType::number_integer_t;
9099      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
9100      using number_float_t = typename BasicJsonType::number_float_t;
9101      using string_t = typename BasicJsonType::string_t;
9102      using lexer_t = lexer<BasicJsonType, InputAdapterType>;
9103      using token_type = typename lexer_t::token_type;
9104    public:
9105      explicit parser(InputAdapterType&& adapter,
9106                      const parser_callback_t<BasicJsonType> cb = nullptr,
9107                      const bool allow_exceptions_ = true,
9108                      const bool skip_comments = false)
9109          : callback(cb)
9110          , m_lexer(std::move(adapter), skip_comments)
9111          , allow_exceptions(allow_exceptions_)
9112      {
9113          get_token();
9114      }
9115      void parse(const bool strict, BasicJsonType& result)
9116      {
9117          if (callback)
9118          {
9119              json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
9120              sax_parse_internal(&sdp);
9121              if (strict && (get_token() != token_type::end_of_input))
9122              {
9123                  sdp.parse_error(m_lexer.get_position(),
9124                                  m_lexer.get_token_string(),
9125                                  parse_error::create(101, m_lexer.get_position(),
9126                                                      exception_message(token_type::end_of_input, "value"), nullptr));
9127              }
9128              if (sdp.is_errored())
9129              {
9130                  result = value_t::discarded;
9131                  return;
9132              }
9133              if (result.is_discarded())
9134              {
9135                  result = nullptr;
9136              }
9137          }
9138          else
9139          {
9140              json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
9141              sax_parse_internal(&sdp);
9142              if (strict && (get_token() != token_type::end_of_input))
9143              {
9144                  sdp.parse_error(m_lexer.get_position(),
9145                                  m_lexer.get_token_string(),
9146                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
9147              }
9148              if (sdp.is_errored())
9149              {
9150                  result = value_t::discarded;
9151                  return;
9152              }
9153          }
9154          result.assert_invariant();
9155      }
9156      bool accept(const bool strict = true)
9157      {
9158          json_sax_acceptor<BasicJsonType> sax_acceptor;
9159          return sax_parse(&sax_acceptor, strict);
9160      }
9161      template<typename SAX>
9162      JSON_HEDLEY_NON_NULL(2)
9163      bool sax_parse(SAX* sax, const bool strict = true)
9164      {
9165          (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
9166          const bool result = sax_parse_internal(sax);
9167          if (result && strict && (get_token() != token_type::end_of_input))
9168          {
9169              return sax->parse_error(m_lexer.get_position(),
9170                                      m_lexer.get_token_string(),
9171                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
9172          }
9173          return result;
9174      }
9175    private:
9176      template<typename SAX>
9177      JSON_HEDLEY_NON_NULL(2)
9178      bool sax_parse_internal(SAX* sax)
9179      {
9180          std::vector<bool> states;
9181          bool skip_to_state_evaluation = false;
9182          while (true)
9183          {
9184              if (!skip_to_state_evaluation)
9185              {
9186                  switch (last_token)
9187                  {
9188                      case token_type::begin_object:
9189                      {
9190                          if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
9191                          {
9192                              return false;
9193                          }
9194                          if (get_token() == token_type::end_object)
9195                          {
9196                              if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
9197                              {
9198                                  return false;
9199                              }
9200                              break;
9201                          }
9202                          if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
9203                          {
9204                              return sax->parse_error(m_lexer.get_position(),
9205                                                      m_lexer.get_token_string(),
9206                                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
9207                          }
9208                          if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
9209                          {
9210                              return false;
9211                          }
9212                          if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
9213                          {
9214                              return sax->parse_error(m_lexer.get_position(),
9215                                                      m_lexer.get_token_string(),
9216                                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
9217                          }
9218                          states.push_back(false);
9219                          get_token();
9220                          continue;
9221                      }
9222                      case token_type::begin_array:
9223                      {
9224                          if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
9225                          {
9226                              return false;
9227                          }
9228                          if (get_token() == token_type::end_array)
9229                          {
9230                              if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
9231                              {
9232                                  return false;
9233                              }
9234                              break;
9235                          }
9236                          states.push_back(true);
9237                          continue;
9238                      }
9239                      case token_type::value_float:
9240                      {
9241                          const auto res = m_lexer.get_number_float();
9242                          if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
9243                          {
9244                              return sax->parse_error(m_lexer.get_position(),
9245                                                      m_lexer.get_token_string(),
9246                                                      out_of_range::create(406, concat("number overflow parsing '", m_lexer.get_token_string(), '\''), nullptr));
9247                          }
9248                          if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))
9249                          {
9250                              return false;
9251                          }
9252                          break;
9253                      }
9254                      case token_type::literal_false:
9255                      {
9256                          if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))
9257                          {
9258                              return false;
9259                          }
9260                          break;
9261                      }
9262                      case token_type::literal_null:
9263                      {
9264                          if (JSON_HEDLEY_UNLIKELY(!sax->null()))
9265                          {
9266                              return false;
9267                          }
9268                          break;
9269                      }
9270                      case token_type::literal_true:
9271                      {
9272                          if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))
9273                          {
9274                              return false;
9275                          }
9276                          break;
9277                      }
9278                      case token_type::value_integer:
9279                      {
9280                          if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))
9281                          {
9282                              return false;
9283                          }
9284                          break;
9285                      }
9286                      case token_type::value_string:
9287                      {
9288                          if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))
9289                          {
9290                              return false;
9291                          }
9292                          break;
9293                      }
9294                      case token_type::value_unsigned:
9295                      {
9296                          if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))
9297                          {
9298                              return false;
9299                          }
9300                          break;
9301                      }
9302                      case token_type::parse_error:
9303                      {
9304                          return sax->parse_error(m_lexer.get_position(),
9305                                                  m_lexer.get_token_string(),
9306                                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, "value"), nullptr));
9307                      }
9308                      case token_type::uninitialized:
9309                      case token_type::end_array:
9310                      case token_type::end_object:
9311                      case token_type::name_separator:
9312                      case token_type::value_separator:
9313                      case token_type::end_of_input:
9314                      case token_type::literal_or_value:
9315                      default: 
9316                      {
9317                          return sax->parse_error(m_lexer.get_position(),
9318                                                  m_lexer.get_token_string(),
9319                                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
9320                      }
9321                  }
9322              }
9323              else
9324              {
9325                  skip_to_state_evaluation = false;
9326              }
9327              if (states.empty())
9328              {
9329                  return true;
9330              }
9331              if (states.back())  
9332              {
9333                  if (get_token() == token_type::value_separator)
9334                  {
9335                      get_token();
9336                      continue;
9337                  }
9338                  if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
9339                  {
9340                      if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
9341                      {
9342                          return false;
9343                      }
9344                      JSON_ASSERT(!states.empty());
9345                      states.pop_back();
9346                      skip_to_state_evaluation = true;
9347                      continue;
9348                  }
9349                  return sax->parse_error(m_lexer.get_position(),
9350                                          m_lexer.get_token_string(),
9351                                          parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, "array"), nullptr));
9352              }
9353              if (get_token() == token_type::value_separator)
9354              {
9355                  if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
9356                  {
9357                      return sax->parse_error(m_lexer.get_position(),
9358                                              m_lexer.get_token_string(),
9359                                              parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
9360                  }
9361                  if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
9362                  {
9363                      return false;
9364                  }
9365                  if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
9366                  {
9367                      return sax->parse_error(m_lexer.get_position(),
9368                                              m_lexer.get_token_string(),
9369                                              parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
9370                  }
9371                  get_token();
9372                  continue;
9373              }
9374              if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
9375              {
9376                  if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
9377                  {
9378                      return false;
9379                  }
9380                  JSON_ASSERT(!states.empty());
9381                  states.pop_back();
9382                  skip_to_state_evaluation = true;
9383                  continue;
9384              }
9385              return sax->parse_error(m_lexer.get_position(),
9386                                      m_lexer.get_token_string(),
9387                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, "object"), nullptr));
9388          }
9389      }
9390      token_type get_token()
9391      {
9392          return last_token = m_lexer.scan();
9393      }
9394      std::string exception_message(const token_type expected, const std::string& context)
9395      {
9396          std::string error_msg = "syntax error ";
9397          if (!context.empty())
9398          {
9399              error_msg += concat("while parsing ", context, ' ');
9400          }
9401          error_msg += "- ";
9402          if (last_token == token_type::parse_error)
9403          {
9404              error_msg += concat(m_lexer.get_error_message(), "; last read: '",
9405                                  m_lexer.get_token_string(), '\'');
9406          }
9407          else
9408          {
9409              error_msg += concat("unexpected ", lexer_t::token_type_name(last_token));
9410          }
9411          if (expected != token_type::uninitialized)
9412          {
9413              error_msg += concat("; expected ", lexer_t::token_type_name(expected));
9414          }
9415          return error_msg;
9416      }
9417    private:
9418      const parser_callback_t<BasicJsonType> callback = nullptr;
9419      token_type last_token = token_type::uninitialized;
9420      lexer_t m_lexer;
9421      const bool allow_exceptions = true;
9422  };
9423  }  
9424  NLOHMANN_JSON_NAMESPACE_END
9425  #include <cstddef> 
9426  #include <limits>  
9427  NLOHMANN_JSON_NAMESPACE_BEGIN
9428  namespace detail
9429  {
9430  class primitive_iterator_t
9431  {
9432    private:
9433      using difference_type = std::ptrdiff_t;
9434      static constexpr difference_type begin_value = 0;
9435      static constexpr difference_type end_value = begin_value + 1;
9436    JSON_PRIVATE_UNLESS_TESTED:
9437      difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();
9438    public:
9439      constexpr difference_type get_value() const noexcept
9440      {
9441          return m_it;
9442      }
9443      void set_begin() noexcept
9444      {
9445          m_it = begin_value;
9446      }
9447      void set_end() noexcept
9448      {
9449          m_it = end_value;
9450      }
9451      constexpr bool is_begin() const noexcept
9452      {
9453          return m_it == begin_value;
9454      }
9455      constexpr bool is_end() const noexcept
9456      {
9457          return m_it == end_value;
9458      }
9459      friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
9460      {
9461          return lhs.m_it == rhs.m_it;
9462      }
9463      friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
9464      {
9465          return lhs.m_it < rhs.m_it;
9466      }
9467      primitive_iterator_t operator+(difference_type n) noexcept
9468      {
9469          auto result = *this;
9470          result += n;
9471          return result;
9472      }
9473      friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
9474      {
9475          return lhs.m_it - rhs.m_it;
9476      }
9477      primitive_iterator_t& operator++() noexcept
9478      {
9479          ++m_it;
9480          return *this;
9481      }
9482      primitive_iterator_t operator++(int)& noexcept 
9483      {
9484          auto result = *this;
9485          ++m_it;
9486          return result;
9487      }
9488      primitive_iterator_t& operator--() noexcept
9489      {
9490          --m_it;
9491          return *this;
9492      }
9493      primitive_iterator_t operator--(int)& noexcept 
9494      {
9495          auto result = *this;
9496          --m_it;
9497          return result;
9498      }
9499      primitive_iterator_t& operator+=(difference_type n) noexcept
9500      {
9501          m_it += n;
9502          return *this;
9503      }
9504      primitive_iterator_t& operator-=(difference_type n) noexcept
9505      {
9506          m_it -= n;
9507          return *this;
9508      }
9509  };
9510  }  
9511  NLOHMANN_JSON_NAMESPACE_END
9512  NLOHMANN_JSON_NAMESPACE_BEGIN
9513  namespace detail
9514  {
9515  template<typename BasicJsonType> struct internal_iterator
9516  {
9517      typename BasicJsonType::object_t::iterator object_iterator {};
9518      typename BasicJsonType::array_t::iterator array_iterator {};
9519      primitive_iterator_t primitive_iterator {};
9520  };
9521  }  
9522  NLOHMANN_JSON_NAMESPACE_END
9523  #include <iterator> 
9524  #include <type_traits> 
9525  NLOHMANN_JSON_NAMESPACE_BEGIN
9526  namespace detail
9527  {
9528  template<typename IteratorType> class iteration_proxy;
9529  template<typename IteratorType> class iteration_proxy_value;
9530  template<typename BasicJsonType>
9531  class iter_impl 
9532  {
9533      using other_iter_impl = iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
9534      friend other_iter_impl;
9535      friend BasicJsonType;
9536      friend iteration_proxy<iter_impl>;
9537      friend iteration_proxy_value<iter_impl>;
9538      using object_t = typename BasicJsonType::object_t;
9539      using array_t = typename BasicJsonType::array_t;
9540      static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
9541                    "iter_impl only accepts (const) basic_json");
9542      static_assert(std::is_base_of<std::bidirectional_iterator_tag, std::bidirectional_iterator_tag>::value
9543                    &&  std::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<typename array_t::iterator>::iterator_category>::value,
9544                    "basic_json iterator assumes array and object type iterators satisfy the LegacyBidirectionalIterator named requirement.");
9545    public:
9546      using iterator_category = std::bidirectional_iterator_tag;
9547      using value_type = typename BasicJsonType::value_type;
9548      using difference_type = typename BasicJsonType::difference_type;
9549      using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
9550            typename BasicJsonType::const_pointer,
9551            typename BasicJsonType::pointer>::type;
9552      using reference =
9553          typename std::conditional<std::is_const<BasicJsonType>::value,
9554          typename BasicJsonType::const_reference,
9555          typename BasicJsonType::reference>::type;
9556      iter_impl() = default;
9557      ~iter_impl() = default;
9558      iter_impl(iter_impl&&) noexcept = default;
9559      iter_impl& operator=(iter_impl&&) noexcept = default;
9560      explicit iter_impl(pointer object) noexcept : m_object(object)
9561      {
9562          JSON_ASSERT(m_object != nullptr);
9563          switch (m_object->m_type)
9564          {
9565              case value_t::object:
9566              {
9567                  m_it.object_iterator = typename object_t::iterator();
9568                  break;
9569              }
9570              case value_t::array:
9571              {
9572                  m_it.array_iterator = typename array_t::iterator();
9573                  break;
9574              }
9575              case value_t::null:
9576              case value_t::string:
9577              case value_t::boolean:
9578              case value_t::number_integer:
9579              case value_t::number_unsigned:
9580              case value_t::number_float:
9581              case value_t::binary:
9582              case value_t::discarded:
9583              default:
9584              {
9585                  m_it.primitive_iterator = primitive_iterator_t();
9586                  break;
9587              }
9588          }
9589      }
9590      iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
9591          : m_object(other.m_object), m_it(other.m_it)
9592      {}
9593      iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
9594      {
9595          if (&other != this)
9596          {
9597              m_object = other.m_object;
9598              m_it = other.m_it;
9599          }
9600          return *this;
9601      }
9602      iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
9603          : m_object(other.m_object), m_it(other.m_it)
9604      {}
9605      iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept 
9606      {
9607          m_object = other.m_object;
9608          m_it = other.m_it;
9609          return *this;
9610      }
9611    JSON_PRIVATE_UNLESS_TESTED:
9612      void set_begin() noexcept
9613      {
9614          JSON_ASSERT(m_object != nullptr);
9615          switch (m_object->m_type)
9616          {
9617              case value_t::object:
9618              {
9619                  m_it.object_iterator = m_object->m_value.object->begin();
9620                  break;
9621              }
9622              case value_t::array:
9623              {
9624                  m_it.array_iterator = m_object->m_value.array->begin();
9625                  break;
9626              }
9627              case value_t::null:
9628              {
9629                  m_it.primitive_iterator.set_end();
9630                  break;
9631              }
9632              case value_t::string:
9633              case value_t::boolean:
9634              case value_t::number_integer:
9635              case value_t::number_unsigned:
9636              case value_t::number_float:
9637              case value_t::binary:
9638              case value_t::discarded:
9639              default:
9640              {
9641                  m_it.primitive_iterator.set_begin();
9642                  break;
9643              }
9644          }
9645      }
9646      void set_end() noexcept
9647      {
9648          JSON_ASSERT(m_object != nullptr);
9649          switch (m_object->m_type)
9650          {
9651              case value_t::object:
9652              {
9653                  m_it.object_iterator = m_object->m_value.object->end();
9654                  break;
9655              }
9656              case value_t::array:
9657              {
9658                  m_it.array_iterator = m_object->m_value.array->end();
9659                  break;
9660              }
9661              case value_t::null:
9662              case value_t::string:
9663              case value_t::boolean:
9664              case value_t::number_integer:
9665              case value_t::number_unsigned:
9666              case value_t::number_float:
9667              case value_t::binary:
9668              case value_t::discarded:
9669              default:
9670              {
9671                  m_it.primitive_iterator.set_end();
9672                  break;
9673              }
9674          }
9675      }
9676    public:
9677      reference operator*() const
9678      {
9679          JSON_ASSERT(m_object != nullptr);
9680          switch (m_object->m_type)
9681          {
9682              case value_t::object:
9683              {
9684                  JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());
9685                  return m_it.object_iterator->second;
9686              }
9687              case value_t::array:
9688              {
9689                  JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());
9690                  return *m_it.array_iterator;
9691              }
9692              case value_t::null:
9693                  JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
9694              case value_t::string:
9695              case value_t::boolean:
9696              case value_t::number_integer:
9697              case value_t::number_unsigned:
9698              case value_t::number_float:
9699              case value_t::binary:
9700              case value_t::discarded:
9701              default:
9702              {
9703                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
9704                  {
9705                      return *m_object;
9706                  }
9707                  JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
9708              }
9709          }
9710      }
9711      pointer operator->() const
9712      {
9713          JSON_ASSERT(m_object != nullptr);
9714          switch (m_object->m_type)
9715          {
9716              case value_t::object:
9717              {
9718                  JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());
9719                  return &(m_it.object_iterator->second);
9720              }
9721              case value_t::array:
9722              {
9723                  JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());
9724                  return &*m_it.array_iterator;
9725              }
9726              case value_t::null:
9727              case value_t::string:
9728              case value_t::boolean:
9729              case value_t::number_integer:
9730              case value_t::number_unsigned:
9731              case value_t::number_float:
9732              case value_t::binary:
9733              case value_t::discarded:
9734              default:
9735              {
9736                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
9737                  {
9738                      return m_object;
9739                  }
9740                  JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
9741              }
9742          }
9743      }
9744      iter_impl operator++(int)& 
9745      {
9746          auto result = *this;
9747          ++(*this);
9748          return result;
9749      }
9750      iter_impl& operator++()
9751      {
9752          JSON_ASSERT(m_object != nullptr);
9753          switch (m_object->m_type)
9754          {
9755              case value_t::object:
9756              {
9757                  std::advance(m_it.object_iterator, 1);
9758                  break;
9759              }
9760              case value_t::array:
9761              {
9762                  std::advance(m_it.array_iterator, 1);
9763                  break;
9764              }
9765              case value_t::null:
9766              case value_t::string:
9767              case value_t::boolean:
9768              case value_t::number_integer:
9769              case value_t::number_unsigned:
9770              case value_t::number_float:
9771              case value_t::binary:
9772              case value_t::discarded:
9773              default:
9774              {
9775                  ++m_it.primitive_iterator;
9776                  break;
9777              }
9778          }
9779          return *this;
9780      }
9781      iter_impl operator--(int)& 
9782      {
9783          auto result = *this;
9784          --(*this);
9785          return result;
9786      }
9787      iter_impl& operator--()
9788      {
9789          JSON_ASSERT(m_object != nullptr);
9790          switch (m_object->m_type)
9791          {
9792              case value_t::object:
9793              {
9794                  std::advance(m_it.object_iterator, -1);
9795                  break;
9796              }
9797              case value_t::array:
9798              {
9799                  std::advance(m_it.array_iterator, -1);
9800                  break;
9801              }
9802              case value_t::null:
9803              case value_t::string:
9804              case value_t::boolean:
9805              case value_t::number_integer:
9806              case value_t::number_unsigned:
9807              case value_t::number_float:
9808              case value_t::binary:
9809              case value_t::discarded:
9810              default:
9811              {
9812                  --m_it.primitive_iterator;
9813                  break;
9814              }
9815          }
9816          return *this;
9817      }
9818      template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
9819      bool operator==(const IterImpl& other) const
9820      {
9821          if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
9822          {
9823              JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
9824          }
9825          JSON_ASSERT(m_object != nullptr);
9826          switch (m_object->m_type)
9827          {
9828              case value_t::object:
9829                  return (m_it.object_iterator == other.m_it.object_iterator);
9830              case value_t::array:
9831                  return (m_it.array_iterator == other.m_it.array_iterator);
9832              case value_t::null:
9833              case value_t::string:
9834              case value_t::boolean:
9835              case value_t::number_integer:
9836              case value_t::number_unsigned:
9837              case value_t::number_float:
9838              case value_t::binary:
9839              case value_t::discarded:
9840              default:
9841                  return (m_it.primitive_iterator == other.m_it.primitive_iterator);
9842          }
9843      }
9844      template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
9845      bool operator!=(const IterImpl& other) const
9846      {
9847          return !operator==(other);
9848      }
9849      bool operator<(const iter_impl& other) const
9850      {
9851          if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
9852          {
9853              JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
9854          }
9855          JSON_ASSERT(m_object != nullptr);
9856          switch (m_object->m_type)
9857          {
9858              case value_t::object:
9859                  JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators", m_object));
9860              case value_t::array:
9861                  return (m_it.array_iterator < other.m_it.array_iterator);
9862              case value_t::null:
9863              case value_t::string:
9864              case value_t::boolean:
9865              case value_t::number_integer:
9866              case value_t::number_unsigned:
9867              case value_t::number_float:
9868              case value_t::binary:
9869              case value_t::discarded:
9870              default:
9871                  return (m_it.primitive_iterator < other.m_it.primitive_iterator);
9872          }
9873      }
9874      bool operator<=(const iter_impl& other) const
9875      {
9876          return !other.operator < (*this);
9877      }
9878      bool operator>(const iter_impl& other) const
9879      {
9880          return !operator<=(other);
9881      }
9882      bool operator>=(const iter_impl& other) const
9883      {
9884          return !operator<(other);
9885      }
9886      iter_impl& operator+=(difference_type i)
9887      {
9888          JSON_ASSERT(m_object != nullptr);
9889          switch (m_object->m_type)
9890          {
9891              case value_t::object:
9892                  JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));
9893              case value_t::array:
9894              {
9895                  std::advance(m_it.array_iterator, i);
9896                  break;
9897              }
9898              case value_t::null:
9899              case value_t::string:
9900              case value_t::boolean:
9901              case value_t::number_integer:
9902              case value_t::number_unsigned:
9903              case value_t::number_float:
9904              case value_t::binary:
9905              case value_t::discarded:
9906              default:
9907              {
9908                  m_it.primitive_iterator += i;
9909                  break;
9910              }
9911          }
9912          return *this;
9913      }
9914      iter_impl& operator-=(difference_type i)
9915      {
9916          return operator+=(-i);
9917      }
9918      iter_impl operator+(difference_type i) const
9919      {
9920          auto result = *this;
9921          result += i;
9922          return result;
9923      }
9924      friend iter_impl operator+(difference_type i, const iter_impl& it)
9925      {
9926          auto result = it;
9927          result += i;
9928          return result;
9929      }
9930      iter_impl operator-(difference_type i) const
9931      {
9932          auto result = *this;
9933          result -= i;
9934          return result;
9935      }
9936      difference_type operator-(const iter_impl& other) const
9937      {
9938          JSON_ASSERT(m_object != nullptr);
9939          switch (m_object->m_type)
9940          {
9941              case value_t::object:
9942                  JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));
9943              case value_t::array:
9944                  return m_it.array_iterator - other.m_it.array_iterator;
9945              case value_t::null:
9946              case value_t::string:
9947              case value_t::boolean:
9948              case value_t::number_integer:
9949              case value_t::number_unsigned:
9950              case value_t::number_float:
9951              case value_t::binary:
9952              case value_t::discarded:
9953              default:
9954                  return m_it.primitive_iterator - other.m_it.primitive_iterator;
9955          }
9956      }
9957      reference operator[](difference_type n) const
9958      {
9959          JSON_ASSERT(m_object != nullptr);
9960          switch (m_object->m_type)
9961          {
9962              case value_t::object:
9963                  JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators", m_object));
9964              case value_t::array:
9965                  return *std::next(m_it.array_iterator, n);
9966              case value_t::null:
9967                  JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
9968              case value_t::string:
9969              case value_t::boolean:
9970              case value_t::number_integer:
9971              case value_t::number_unsigned:
9972              case value_t::number_float:
9973              case value_t::binary:
9974              case value_t::discarded:
9975              default:
9976              {
9977                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
9978                  {
9979                      return *m_object;
9980                  }
9981                  JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
9982              }
9983          }
9984      }
9985      const typename object_t::key_type& key() const
9986      {
9987          JSON_ASSERT(m_object != nullptr);
9988          if (JSON_HEDLEY_LIKELY(m_object->is_object()))
9989          {
9990              return m_it.object_iterator->first;
9991          }
9992          JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators", m_object));
9993      }
9994      reference value() const
9995      {
9996          return operator*();
9997      }
9998    JSON_PRIVATE_UNLESS_TESTED:
9999      pointer m_object = nullptr;
10000      internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
10001  };
10002  }  
10003  NLOHMANN_JSON_NAMESPACE_END
10004  #include <cstddef> 
10005  #include <iterator> 
10006  #include <utility> 
10007  NLOHMANN_JSON_NAMESPACE_BEGIN
10008  namespace detail
10009  {
10010  template<typename Base>
10011  class json_reverse_iterator : public std::reverse_iterator<Base>
10012  {
10013    public:
10014      using difference_type = std::ptrdiff_t;
10015      using base_iterator = std::reverse_iterator<Base>;
10016      using reference = typename Base::reference;
10017      explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
10018          : base_iterator(it) {}
10019      explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}
10020      json_reverse_iterator operator++(int)& 
10021      {
10022          return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
10023      }
10024      json_reverse_iterator& operator++()
10025      {
10026          return static_cast<json_reverse_iterator&>(base_iterator::operator++());
10027      }
10028      json_reverse_iterator operator--(int)& 
10029      {
10030          return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
10031      }
10032      json_reverse_iterator& operator--()
10033      {
10034          return static_cast<json_reverse_iterator&>(base_iterator::operator--());
10035      }
10036      json_reverse_iterator& operator+=(difference_type i)
10037      {
10038          return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
10039      }
10040      json_reverse_iterator operator+(difference_type i) const
10041      {
10042          return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
10043      }
10044      json_reverse_iterator operator-(difference_type i) const
10045      {
10046          return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
10047      }
10048      difference_type operator-(const json_reverse_iterator& other) const
10049      {
10050          return base_iterator(*this) - base_iterator(other);
10051      }
10052      reference operator[](difference_type n) const
10053      {
10054          return *(this->operator+(n));
10055      }
10056      auto key() const -> decltype(std::declval<Base>().key())
10057      {
10058          auto it = --this->base();
10059          return it.key();
10060      }
10061      reference value() const
10062      {
10063          auto it = --this->base();
10064          return it.operator * ();
10065      }
10066  };
10067  }  
10068  NLOHMANN_JSON_NAMESPACE_END
10069  #include <algorithm> 
10070  #include <cctype> 
10071  #include <cerrno> 
10072  #include <cstdlib> 
10073  #ifndef JSON_NO_IO
10074      #include <iosfwd> 
10075  #endif  
10076  #include <limits> 
10077  #include <numeric> 
10078  #include <string> 
10079  #include <utility> 
10080  #include <vector> 
10081  NLOHMANN_JSON_NAMESPACE_BEGIN
10082  template<typename RefStringType>
10083  class json_pointer
10084  {
10085      NLOHMANN_BASIC_JSON_TPL_DECLARATION
10086      friend class basic_json;
10087      template<typename>
10088      friend class json_pointer;
10089      template<typename T>
10090      struct string_t_helper
10091      {
10092          using type = T;
10093      };
10094      NLOHMANN_BASIC_JSON_TPL_DECLARATION
10095      struct string_t_helper<NLOHMANN_BASIC_JSON_TPL>
10096      {
10097          using type = StringType;
10098      };
10099    public:
10100      using string_t = typename string_t_helper<RefStringType>::type;
10101      explicit json_pointer(const string_t& s = "")
10102          : reference_tokens(split(s))
10103      {}
10104      string_t to_string() const
10105      {
10106          return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
10107                                 string_t{},
10108                                 [](const string_t& a, const string_t& b)
10109          {
10110              return detail::concat(a, '/', detail::escape(b));
10111          });
10112      }
10113      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, to_string())
10114      operator string_t() const
10115      {
10116          return to_string();
10117      }
10118  #ifndef JSON_NO_IO
10119      friend std::ostream& operator<<(std::ostream& o, const json_pointer& ptr)
10120      {
10121          o << ptr.to_string();
10122          return o;
10123      }
10124  #endif
10125      json_pointer& operator/=(const json_pointer& ptr)
10126      {
10127          reference_tokens.insert(reference_tokens.end(),
10128                                  ptr.reference_tokens.begin(),
10129                                  ptr.reference_tokens.end());
10130          return *this;
10131      }
10132      json_pointer& operator/=(string_t token)
10133      {
10134          push_back(std::move(token));
10135          return *this;
10136      }
10137      json_pointer& operator/=(std::size_t array_idx)
10138      {
10139          return *this /= std::to_string(array_idx);
10140      }
10141      friend json_pointer operator/(const json_pointer& lhs,
10142                                    const json_pointer& rhs)
10143      {
10144          return json_pointer(lhs) /= rhs;
10145      }
10146      friend json_pointer operator/(const json_pointer& lhs, string_t token) 
10147      {
10148          return json_pointer(lhs) /= std::move(token);
10149      }
10150      friend json_pointer operator/(const json_pointer& lhs, std::size_t array_idx)
10151      {
10152          return json_pointer(lhs) /= array_idx;
10153      }
10154      json_pointer parent_pointer() const
10155      {
10156          if (empty())
10157          {
10158              return *this;
10159          }
10160          json_pointer res = *this;
10161          res.pop_back();
10162          return res;
10163      }
10164      void pop_back()
10165      {
10166          if (JSON_HEDLEY_UNLIKELY(empty()))
10167          {
10168              JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
10169          }
10170          reference_tokens.pop_back();
10171      }
10172      const string_t& back() const
10173      {
10174          if (JSON_HEDLEY_UNLIKELY(empty()))
10175          {
10176              JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
10177          }
10178          return reference_tokens.back();
10179      }
10180      void push_back(const string_t& token)
10181      {
10182          reference_tokens.push_back(token);
10183      }
10184      void push_back(string_t&& token)
10185      {
10186          reference_tokens.push_back(std::move(token));
10187      }
10188      bool empty() const noexcept
10189      {
10190          return reference_tokens.empty();
10191      }
10192    private:
10193      template<typename BasicJsonType>
10194      static typename BasicJsonType::size_type array_index(const string_t& s)
10195      {
10196          using size_type = typename BasicJsonType::size_type;
10197          if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))
10198          {
10199              JSON_THROW(detail::parse_error::create(106, 0, detail::concat("array index '", s, "' must not begin with '0'"), nullptr));
10200          }
10201          if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))
10202          {
10203              JSON_THROW(detail::parse_error::create(109, 0, detail::concat("array index '", s, "' is not a number"), nullptr));
10204          }
10205          const char* p = s.c_str();
10206          char* p_end = nullptr;
10207          errno = 0; 
10208          unsigned long long res = std::strtoull(p, &p_end, 10); 
10209          if (p == p_end 
10210                  || errno == ERANGE 
10211                  || JSON_HEDLEY_UNLIKELY(static_cast<std::size_t>(p_end - p) != s.size())) 
10212          {
10213              JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", s, "'"), nullptr));
10214          }
10215          if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  
10216          {
10217              JSON_THROW(detail::out_of_range::create(410, detail::concat("array index ", s, " exceeds size_type"), nullptr));   
10218          }
10219          return static_cast<size_type>(res);
10220      }
10221    JSON_PRIVATE_UNLESS_TESTED:
10222      json_pointer top() const
10223      {
10224          if (JSON_HEDLEY_UNLIKELY(empty()))
10225          {
10226              JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
10227          }
10228          json_pointer result = *this;
10229          result.reference_tokens = {reference_tokens[0]};
10230          return result;
10231      }
10232    private:
10233      template<typename BasicJsonType>
10234      BasicJsonType& get_and_create(BasicJsonType& j) const
10235      {
10236          auto* result = &j;
10237          for (const auto& reference_token : reference_tokens)
10238          {
10239              switch (result->type())
10240              {
10241                  case detail::value_t::null:
10242                  {
10243                      if (reference_token == "0")
10244                      {
10245                          result = &result->operator[](0);
10246                      }
10247                      else
10248                      {
10249                          result = &result->operator[](reference_token);
10250                      }
10251                      break;
10252                  }
10253                  case detail::value_t::object:
10254                  {
10255                      result = &result->operator[](reference_token);
10256                      break;
10257                  }
10258                  case detail::value_t::array:
10259                  {
10260                      result = &result->operator[](array_index<BasicJsonType>(reference_token));
10261                      break;
10262                  }
10263                  case detail::value_t::string:
10264                  case detail::value_t::boolean:
10265                  case detail::value_t::number_integer:
10266                  case detail::value_t::number_unsigned:
10267                  case detail::value_t::number_float:
10268                  case detail::value_t::binary:
10269                  case detail::value_t::discarded:
10270                  default:
10271                      JSON_THROW(detail::type_error::create(313, "invalid value to unflatten", &j));
10272              }
10273          }
10274          return *result;
10275      }
10276      template<typename BasicJsonType>
10277      BasicJsonType& get_unchecked(BasicJsonType* ptr) const
10278      {
10279          for (const auto& reference_token : reference_tokens)
10280          {
10281              if (ptr->is_null())
10282              {
10283                  const bool nums =
10284                      std::all_of(reference_token.begin(), reference_token.end(),
10285                                  [](const unsigned char x)
10286                  {
10287                      return std::isdigit(x);
10288                  });
10289                  *ptr = (nums || reference_token == "-")
10290                         ? detail::value_t::array
10291                         : detail::value_t::object;
10292              }
10293              switch (ptr->type())
10294              {
10295                  case detail::value_t::object:
10296                  {
10297                      ptr = &ptr->operator[](reference_token);
10298                      break;
10299                  }
10300                  case detail::value_t::array:
10301                  {
10302                      if (reference_token == "-")
10303                      {
10304                          ptr = &ptr->operator[](ptr->m_value.array->size());
10305                      }
10306                      else
10307                      {
10308                          ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
10309                      }
10310                      break;
10311                  }
10312                  case detail::value_t::null:
10313                  case detail::value_t::string:
10314                  case detail::value_t::boolean:
10315                  case detail::value_t::number_integer:
10316                  case detail::value_t::number_unsigned:
10317                  case detail::value_t::number_float:
10318                  case detail::value_t::binary:
10319                  case detail::value_t::discarded:
10320                  default:
10321                      JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
10322              }
10323          }
10324          return *ptr;
10325      }
10326      template<typename BasicJsonType>
10327      BasicJsonType& get_checked(BasicJsonType* ptr) const
10328      {
10329          for (const auto& reference_token : reference_tokens)
10330          {
10331              switch (ptr->type())
10332              {
10333                  case detail::value_t::object:
10334                  {
10335                      ptr = &ptr->at(reference_token);
10336                      break;
10337                  }
10338                  case detail::value_t::array:
10339                  {
10340                      if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
10341                      {
10342                          JSON_THROW(detail::out_of_range::create(402, detail::concat(
10343                                  "array index '-' (", std::to_string(ptr->m_value.array->size()),
10344                                  ") is out of range"), ptr));
10345                      }
10346                      ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
10347                      break;
10348                  }
10349                  case detail::value_t::null:
10350                  case detail::value_t::string:
10351                  case detail::value_t::boolean:
10352                  case detail::value_t::number_integer:
10353                  case detail::value_t::number_unsigned:
10354                  case detail::value_t::number_float:
10355                  case detail::value_t::binary:
10356                  case detail::value_t::discarded:
10357                  default:
10358                      JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
10359              }
10360          }
10361          return *ptr;
10362      }
10363      template<typename BasicJsonType>
10364      const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
10365      {
10366          for (const auto& reference_token : reference_tokens)
10367          {
10368              switch (ptr->type())
10369              {
10370                  case detail::value_t::object:
10371                  {
10372                      ptr = &ptr->operator[](reference_token);
10373                      break;
10374                  }
10375                  case detail::value_t::array:
10376                  {
10377                      if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
10378                      {
10379                          JSON_THROW(detail::out_of_range::create(402, detail::concat("array index '-' (", std::to_string(ptr->m_value.array->size()), ") is out of range"), ptr));
10380                      }
10381                      ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
10382                      break;
10383                  }
10384                  case detail::value_t::null:
10385                  case detail::value_t::string:
10386                  case detail::value_t::boolean:
10387                  case detail::value_t::number_integer:
10388                  case detail::value_t::number_unsigned:
10389                  case detail::value_t::number_float:
10390                  case detail::value_t::binary:
10391                  case detail::value_t::discarded:
10392                  default:
10393                      JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
10394              }
10395          }
10396          return *ptr;
10397      }
10398      template<typename BasicJsonType>
10399      const BasicJsonType& get_checked(const BasicJsonType* ptr) const
10400      {
10401          for (const auto& reference_token : reference_tokens)
10402          {
10403              switch (ptr->type())
10404              {
10405                  case detail::value_t::object:
10406                  {
10407                      ptr = &ptr->at(reference_token);
10408                      break;
10409                  }
10410                  case detail::value_t::array:
10411                  {
10412                      if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
10413                      {
10414                          JSON_THROW(detail::out_of_range::create(402, detail::concat(
10415                                  "array index '-' (", std::to_string(ptr->m_value.array->size()),
10416                                  ") is out of range"), ptr));
10417                      }
10418                      ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
10419                      break;
10420                  }
10421                  case detail::value_t::null:
10422                  case detail::value_t::string:
10423                  case detail::value_t::boolean:
10424                  case detail::value_t::number_integer:
10425                  case detail::value_t::number_unsigned:
10426                  case detail::value_t::number_float:
10427                  case detail::value_t::binary:
10428                  case detail::value_t::discarded:
10429                  default:
10430                      JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
10431              }
10432          }
10433          return *ptr;
10434      }
10435      template<typename BasicJsonType>
10436      bool contains(const BasicJsonType* ptr) const
10437      {
10438          for (const auto& reference_token : reference_tokens)
10439          {
10440              switch (ptr->type())
10441              {
10442                  case detail::value_t::object:
10443                  {
10444                      if (!ptr->contains(reference_token))
10445                      {
10446                          return false;
10447                      }
10448                      ptr = &ptr->operator[](reference_token);
10449                      break;
10450                  }
10451                  case detail::value_t::array:
10452                  {
10453                      if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
10454                      {
10455                          return false;
10456                      }
10457                      if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !("0" <= reference_token && reference_token <= "9")))
10458                      {
10459                          return false;
10460                      }
10461                      if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))
10462                      {
10463                          if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))
10464                          {
10465                              return false;
10466                          }
10467                          for (std::size_t i = 1; i < reference_token.size(); i++)
10468                          {
10469                              if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))
10470                              {
10471                                  return false;
10472                              }
10473                          }
10474                      }
10475                      const auto idx = array_index<BasicJsonType>(reference_token);
10476                      if (idx >= ptr->size())
10477                      {
10478                          return false;
10479                      }
10480                      ptr = &ptr->operator[](idx);
10481                      break;
10482                  }
10483                  case detail::value_t::null:
10484                  case detail::value_t::string:
10485                  case detail::value_t::boolean:
10486                  case detail::value_t::number_integer:
10487                  case detail::value_t::number_unsigned:
10488                  case detail::value_t::number_float:
10489                  case detail::value_t::binary:
10490                  case detail::value_t::discarded:
10491                  default:
10492                  {
10493                      return false;
10494                  }
10495              }
10496          }
10497          return true;
10498      }
10499      static std::vector<string_t> split(const string_t& reference_string)
10500      {
10501          std::vector<string_t> result;
10502          if (reference_string.empty())
10503          {
10504              return result;
10505          }
10506          if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
10507          {
10508              JSON_THROW(detail::parse_error::create(107, 1, detail::concat("JSON pointer must be empty or begin with '/' - was: '", reference_string, "'"), nullptr));
10509          }
10510          for (
10511              std::size_t slash = reference_string.find_first_of('/', 1),
10512              start = 1;
10513              start != 0;
10514              start = (slash == string_t::npos) ? 0 : slash + 1,
10515              slash = reference_string.find_first_of('/', start))
10516          {
10517              auto reference_token = reference_string.substr(start, slash - start);
10518              for (std::size_t pos = reference_token.find_first_of('~');
10519                      pos != string_t::npos;
10520                      pos = reference_token.find_first_of('~', pos + 1))
10521              {
10522                  JSON_ASSERT(reference_token[pos] == '~');
10523                  if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
10524                                           (reference_token[pos + 1] != '0' &&
10525                                            reference_token[pos + 1] != '1')))
10526                  {
10527                      JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'", nullptr));
10528                  }
10529              }
10530              detail::unescape(reference_token);
10531              result.push_back(reference_token);
10532          }
10533          return result;
10534      }
10535    private:
10536      template<typename BasicJsonType>
10537      static void flatten(const string_t& reference_string,
10538                          const BasicJsonType& value,
10539                          BasicJsonType& result)
10540      {
10541          switch (value.type())
10542          {
10543              case detail::value_t::array:
10544              {
10545                  if (value.m_value.array->empty())
10546                  {
10547                      result[reference_string] = nullptr;
10548                  }
10549                  else
10550                  {
10551                      for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
10552                      {
10553                          flatten(detail::concat(reference_string, '/', std::to_string(i)),
10554                                  value.m_value.array->operator[](i), result);
10555                      }
10556                  }
10557                  break;
10558              }
10559              case detail::value_t::object:
10560              {
10561                  if (value.m_value.object->empty())
10562                  {
10563                      result[reference_string] = nullptr;
10564                  }
10565                  else
10566                  {
10567                      for (const auto& element : *value.m_value.object)
10568                      {
10569                          flatten(detail::concat(reference_string, '/', detail::escape(element.first)), element.second, result);
10570                      }
10571                  }
10572                  break;
10573              }
10574              case detail::value_t::null:
10575              case detail::value_t::string:
10576              case detail::value_t::boolean:
10577              case detail::value_t::number_integer:
10578              case detail::value_t::number_unsigned:
10579              case detail::value_t::number_float:
10580              case detail::value_t::binary:
10581              case detail::value_t::discarded:
10582              default:
10583              {
10584                  result[reference_string] = value;
10585                  break;
10586              }
10587          }
10588      }
10589      template<typename BasicJsonType>
10590      static BasicJsonType
10591      unflatten(const BasicJsonType& value)
10592      {
10593          if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
10594          {
10595              JSON_THROW(detail::type_error::create(314, "only objects can be unflattened", &value));
10596          }
10597          BasicJsonType result;
10598          for (const auto& element : *value.m_value.object)
10599          {
10600              if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
10601              {
10602                  JSON_THROW(detail::type_error::create(315, "values in object must be primitive", &element.second));
10603              }
10604              json_pointer(element.first).get_and_create(result) = element.second;
10605          }
10606          return result;
10607      }
10608      json_pointer<string_t> convert() const&
10609      {
10610          json_pointer<string_t> result;
10611          result.reference_tokens = reference_tokens;
10612          return result;
10613      }
10614      json_pointer<string_t> convert()&&
10615      {
10616          json_pointer<string_t> result;
10617          result.reference_tokens = std::move(reference_tokens);
10618          return result;
10619      }
10620    public:
10621  #if JSON_HAS_THREE_WAY_COMPARISON
10622      template<typename RefStringTypeRhs>
10623      bool operator==(const json_pointer<RefStringTypeRhs>& rhs) const noexcept
10624      {
10625          return reference_tokens == rhs.reference_tokens;
10626      }
10627      JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer))
10628      bool operator==(const string_t& rhs) const
10629      {
10630          return *this == json_pointer(rhs);
10631      }
10632      template<typename RefStringTypeRhs>
10633      std::strong_ordering operator<=>(const json_pointer<RefStringTypeRhs>& rhs) const noexcept 
10634      {
10635          return  reference_tokens <=> rhs.reference_tokens; 
10636      }
10637  #else
10638      template<typename RefStringTypeLhs, typename RefStringTypeRhs>
10639      friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
10640                             const json_pointer<RefStringTypeRhs>& rhs) noexcept;
10641      template<typename RefStringTypeLhs, typename StringType>
10642      friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
10643                             const StringType& rhs);
10644      template<typename RefStringTypeRhs, typename StringType>
10645      friend bool operator==(const StringType& lhs,
10646                             const json_pointer<RefStringTypeRhs>& rhs);
10647      template<typename RefStringTypeLhs, typename RefStringTypeRhs>
10648      friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
10649                             const json_pointer<RefStringTypeRhs>& rhs) noexcept;
10650      template<typename RefStringTypeLhs, typename StringType>
10651      friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
10652                             const StringType& rhs);
10653      template<typename RefStringTypeRhs, typename StringType>
10654      friend bool operator!=(const StringType& lhs,
10655                             const json_pointer<RefStringTypeRhs>& rhs);
10656      template<typename RefStringTypeLhs, typename RefStringTypeRhs>
10657      friend bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
10658                            const json_pointer<RefStringTypeRhs>& rhs) noexcept;
10659  #endif
10660    private:
10661      std::vector<string_t> reference_tokens;
10662  };
10663  #if !JSON_HAS_THREE_WAY_COMPARISON
10664  template<typename RefStringTypeLhs, typename RefStringTypeRhs>
10665  inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
10666                         const json_pointer<RefStringTypeRhs>& rhs) noexcept
10667  {
10668      return lhs.reference_tokens == rhs.reference_tokens;
10669  }
10670  template<typename RefStringTypeLhs,
10671           typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
10672  JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
10673  inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
10674                         const StringType& rhs)
10675  {
10676      return lhs == json_pointer<RefStringTypeLhs>(rhs);
10677  }
10678  template<typename RefStringTypeRhs,
10679           typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
10680  JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
10681  inline bool operator==(const StringType& lhs,
10682                         const json_pointer<RefStringTypeRhs>& rhs)
10683  {
10684      return json_pointer<RefStringTypeRhs>(lhs) == rhs;
10685  }
10686  template<typename RefStringTypeLhs, typename RefStringTypeRhs>
10687  inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
10688                         const json_pointer<RefStringTypeRhs>& rhs) noexcept
10689  {
10690      return !(lhs == rhs);
10691  }
10692  template<typename RefStringTypeLhs,
10693           typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
10694  JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
10695  inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
10696                         const StringType& rhs)
10697  {
10698      return !(lhs == rhs);
10699  }
10700  template<typename RefStringTypeRhs,
10701           typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
10702  JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
10703  inline bool operator!=(const StringType& lhs,
10704                         const json_pointer<RefStringTypeRhs>& rhs)
10705  {
10706      return !(lhs == rhs);
10707  }
10708  template<typename RefStringTypeLhs, typename RefStringTypeRhs>
10709  inline bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
10710                        const json_pointer<RefStringTypeRhs>& rhs) noexcept
10711  {
10712      return lhs.reference_tokens < rhs.reference_tokens;
10713  }
10714  #endif
10715  NLOHMANN_JSON_NAMESPACE_END
10716  #include <initializer_list>
10717  #include <utility>
10718  NLOHMANN_JSON_NAMESPACE_BEGIN
10719  namespace detail
10720  {
10721  template<typename BasicJsonType>
10722  class json_ref
10723  {
10724    public:
10725      using value_type = BasicJsonType;
10726      json_ref(value_type&& value)
10727          : owned_value(std::move(value))
10728      {}
10729      json_ref(const value_type& value)
10730          : value_ref(&value)
10731      {}
10732      json_ref(std::initializer_list<json_ref> init)
10733          : owned_value(init)
10734      {}
10735      template <
10736          class... Args,
10737          enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
10738      json_ref(Args && ... args)
10739          : owned_value(std::forward<Args>(args)...)
10740      {}
10741      json_ref(json_ref&&) noexcept = default;
10742      json_ref(const json_ref&) = delete;
10743      json_ref& operator=(const json_ref&) = delete;
10744      json_ref& operator=(json_ref&&) = delete;
10745      ~json_ref() = default;
10746      value_type moved_or_copied() const
10747      {
10748          if (value_ref == nullptr)
10749          {
10750              return std::move(owned_value);
10751          }
10752          return *value_ref;
10753      }
10754      value_type const& operator*() const
10755      {
10756          return value_ref ? *value_ref : owned_value;
10757      }
10758      value_type const* operator->() const
10759      {
10760          return &** this;
10761      }
10762    private:
10763      mutable value_type owned_value = nullptr;
10764      value_type const* value_ref = nullptr;
10765  };
10766  }  
10767  NLOHMANN_JSON_NAMESPACE_END
10768  #include <algorithm> 
10769  #include <array> 
10770  #include <map> 
10771  #include <cmath> 
10772  #include <cstdint> 
10773  #include <cstring> 
10774  #include <limits> 
10775  #include <string> 
10776  #include <utility> 
10777  #include <vector> 
10778  #include <algorithm> 
10779  #include <cstddef> 
10780  #include <iterator> 
10781  #include <memory> 
10782  #include <string> 
10783  #include <vector> 
10784  #ifndef JSON_NO_IO
10785      #include <ios>      
10786      #include <ostream>  
10787  #endif  
10788  NLOHMANN_JSON_NAMESPACE_BEGIN
10789  namespace detail
10790  {
10791  template<typename CharType> struct output_adapter_protocol
10792  {
10793      virtual void write_character(CharType c) = 0;
10794      virtual void write_characters(const CharType* s, std::size_t length) = 0;
10795      virtual ~output_adapter_protocol() = default;
10796      output_adapter_protocol() = default;
10797      output_adapter_protocol(const output_adapter_protocol&) = default;
10798      output_adapter_protocol(output_adapter_protocol&&) noexcept = default;
10799      output_adapter_protocol& operator=(const output_adapter_protocol&) = default;
10800      output_adapter_protocol& operator=(output_adapter_protocol&&) noexcept = default;
10801  };
10802  template<typename CharType>
10803  using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;
10804  template<typename CharType, typename AllocatorType = std::allocator<CharType>>
10805  class output_vector_adapter : public output_adapter_protocol<CharType>
10806  {
10807    public:
10808      explicit output_vector_adapter(std::vector<CharType, AllocatorType>& vec) noexcept
10809          : v(vec)
10810      {}
10811      void write_character(CharType c) override
10812      {
10813          v.push_back(c);
10814      }
10815      JSON_HEDLEY_NON_NULL(2)
10816      void write_characters(const CharType* s, std::size_t length) override
10817      {
10818          v.insert(v.end(), s, s + length);
10819      }
10820    private:
10821      std::vector<CharType, AllocatorType>& v;
10822  };
10823  #ifndef JSON_NO_IO
10824  template<typename CharType>
10825  class output_stream_adapter : public output_adapter_protocol<CharType>
10826  {
10827    public:
10828      explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
10829          : stream(s)
10830      {}
10831      void write_character(CharType c) override
10832      {
10833          stream.put(c);
10834      }
10835      JSON_HEDLEY_NON_NULL(2)
10836      void write_characters(const CharType* s, std::size_t length) override
10837      {
10838          stream.write(s, static_cast<std::streamsize>(length));
10839      }
10840    private:
10841      std::basic_ostream<CharType>& stream;
10842  };
10843  #endif  
10844  template<typename CharType, typename StringType = std::basic_string<CharType>>
10845  class output_string_adapter : public output_adapter_protocol<CharType>
10846  {
10847    public:
10848      explicit output_string_adapter(StringType& s) noexcept
10849          : str(s)
10850      {}
10851      void write_character(CharType c) override
10852      {
10853          str.push_back(c);
10854      }
10855      JSON_HEDLEY_NON_NULL(2)
10856      void write_characters(const CharType* s, std::size_t length) override
10857      {
10858          str.append(s, length);
10859      }
10860    private:
10861      StringType& str;
10862  };
10863  template<typename CharType, typename StringType = std::basic_string<CharType>>
10864  class output_adapter
10865  {
10866    public:
10867      template<typename AllocatorType = std::allocator<CharType>>
10868      output_adapter(std::vector<CharType, AllocatorType>& vec)
10869          : oa(std::make_shared<output_vector_adapter<CharType, AllocatorType>>(vec)) {}
10870  #ifndef JSON_NO_IO
10871      output_adapter(std::basic_ostream<CharType>& s)
10872          : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}
10873  #endif  
10874      output_adapter(StringType& s)
10875          : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}
10876      operator output_adapter_t<CharType>()
10877      {
10878          return oa;
10879      }
10880    private:
10881      output_adapter_t<CharType> oa = nullptr;
10882  };
10883  }  
10884  NLOHMANN_JSON_NAMESPACE_END
10885  NLOHMANN_JSON_NAMESPACE_BEGIN
10886  namespace detail
10887  {
10888  template<typename BasicJsonType, typename CharType>
10889  class binary_writer
10890  {
10891      using string_t = typename BasicJsonType::string_t;
10892      using binary_t = typename BasicJsonType::binary_t;
10893      using number_float_t = typename BasicJsonType::number_float_t;
10894    public:
10895      explicit binary_writer(output_adapter_t<CharType> adapter) : oa(std::move(adapter))
10896      {
10897          JSON_ASSERT(oa);
10898      }
10899      void write_bson(const BasicJsonType& j)
10900      {
10901          switch (j.type())
10902          {
10903              case value_t::object:
10904              {
10905                  write_bson_object(*j.m_value.object);
10906                  break;
10907              }
10908              case value_t::null:
10909              case value_t::array:
10910              case value_t::string:
10911              case value_t::boolean:
10912              case value_t::number_integer:
10913              case value_t::number_unsigned:
10914              case value_t::number_float:
10915              case value_t::binary:
10916              case value_t::discarded:
10917              default:
10918              {
10919                  JSON_THROW(type_error::create(317, concat("to serialize to BSON, top-level type must be object, but is ", j.type_name()), &j));
10920              }
10921          }
10922      }
10923      void write_cbor(const BasicJsonType& j)
10924      {
10925          switch (j.type())
10926          {
10927              case value_t::null:
10928              {
10929                  oa->write_character(to_char_type(0xF6));
10930                  break;
10931              }
10932              case value_t::boolean:
10933              {
10934                  oa->write_character(j.m_value.boolean
10935                                      ? to_char_type(0xF5)
10936                                      : to_char_type(0xF4));
10937                  break;
10938              }
10939              case value_t::number_integer:
10940              {
10941                  if (j.m_value.number_integer >= 0)
10942                  {
10943                      if (j.m_value.number_integer <= 0x17)
10944                      {
10945                          write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
10946                      }
10947                      else if (j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
10948                      {
10949                          oa->write_character(to_char_type(0x18));
10950                          write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
10951                      }
10952                      else if (j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
10953                      {
10954                          oa->write_character(to_char_type(0x19));
10955                          write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
10956                      }
10957                      else if (j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
10958                      {
10959                          oa->write_character(to_char_type(0x1A));
10960                          write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
10961                      }
10962                      else
10963                      {
10964                          oa->write_character(to_char_type(0x1B));
10965                          write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
10966                      }
10967                  }
10968                  else
10969                  {
10970                      const auto positive_number = -1 - j.m_value.number_integer;
10971                      if (j.m_value.number_integer >= -24)
10972                      {
10973                          write_number(static_cast<std::uint8_t>(0x20 + positive_number));
10974                      }
10975                      else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
10976                      {
10977                          oa->write_character(to_char_type(0x38));
10978                          write_number(static_cast<std::uint8_t>(positive_number));
10979                      }
10980                      else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
10981                      {
10982                          oa->write_character(to_char_type(0x39));
10983                          write_number(static_cast<std::uint16_t>(positive_number));
10984                      }
10985                      else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
10986                      {
10987                          oa->write_character(to_char_type(0x3A));
10988                          write_number(static_cast<std::uint32_t>(positive_number));
10989                      }
10990                      else
10991                      {
10992                          oa->write_character(to_char_type(0x3B));
10993                          write_number(static_cast<std::uint64_t>(positive_number));
10994                      }
10995                  }
10996                  break;
10997              }
10998              case value_t::number_unsigned:
10999              {
11000                  if (j.m_value.number_unsigned <= 0x17)
11001                  {
11002                      write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
11003                  }
11004                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
11005                  {
11006                      oa->write_character(to_char_type(0x18));
11007                      write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
11008                  }
11009                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
11010                  {
11011                      oa->write_character(to_char_type(0x19));
11012                      write_number(static_cast<std::uint16_t>(j.m_value.number_unsigned));
11013                  }
11014                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
11015                  {
11016                      oa->write_character(to_char_type(0x1A));
11017                      write_number(static_cast<std::uint32_t>(j.m_value.number_unsigned));
11018                  }
11019                  else
11020                  {
11021                      oa->write_character(to_char_type(0x1B));
11022                      write_number(static_cast<std::uint64_t>(j.m_value.number_unsigned));
11023                  }
11024                  break;
11025              }
11026              case value_t::number_float:
11027              {
11028                  if (std::isnan(j.m_value.number_float))
11029                  {
11030                      oa->write_character(to_char_type(0xF9));
11031                      oa->write_character(to_char_type(0x7E));
11032                      oa->write_character(to_char_type(0x00));
11033                  }
11034                  else if (std::isinf(j.m_value.number_float))
11035                  {
11036                      oa->write_character(to_char_type(0xf9));
11037                      oa->write_character(j.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));
11038                      oa->write_character(to_char_type(0x00));
11039                  }
11040                  else
11041                  {
11042                      write_compact_float(j.m_value.number_float, detail::input_format_t::cbor);
11043                  }
11044                  break;
11045              }
11046              case value_t::string:
11047              {
11048                  const auto N = j.m_value.string->size();
11049                  if (N <= 0x17)
11050                  {
11051                      write_number(static_cast<std::uint8_t>(0x60 + N));
11052                  }
11053                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
11054                  {
11055                      oa->write_character(to_char_type(0x78));
11056                      write_number(static_cast<std::uint8_t>(N));
11057                  }
11058                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
11059                  {
11060                      oa->write_character(to_char_type(0x79));
11061                      write_number(static_cast<std::uint16_t>(N));
11062                  }
11063                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
11064                  {
11065                      oa->write_character(to_char_type(0x7A));
11066                      write_number(static_cast<std::uint32_t>(N));
11067                  }
11068                  else if (N <= (std::numeric_limits<std::uint64_t>::max)())
11069                  {
11070                      oa->write_character(to_char_type(0x7B));
11071                      write_number(static_cast<std::uint64_t>(N));
11072                  }
11073                  oa->write_characters(
11074                      reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
11075                      j.m_value.string->size());
11076                  break;
11077              }
11078              case value_t::array:
11079              {
11080                  const auto N = j.m_value.array->size();
11081                  if (N <= 0x17)
11082                  {
11083                      write_number(static_cast<std::uint8_t>(0x80 + N));
11084                  }
11085                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
11086                  {
11087                      oa->write_character(to_char_type(0x98));
11088                      write_number(static_cast<std::uint8_t>(N));
11089                  }
11090                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
11091                  {
11092                      oa->write_character(to_char_type(0x99));
11093                      write_number(static_cast<std::uint16_t>(N));
11094                  }
11095                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
11096                  {
11097                      oa->write_character(to_char_type(0x9A));
11098                      write_number(static_cast<std::uint32_t>(N));
11099                  }
11100                  else if (N <= (std::numeric_limits<std::uint64_t>::max)())
11101                  {
11102                      oa->write_character(to_char_type(0x9B));
11103                      write_number(static_cast<std::uint64_t>(N));
11104                  }
11105                  for (const auto& el : *j.m_value.array)
11106                  {
11107                      write_cbor(el);
11108                  }
11109                  break;
11110              }
11111              case value_t::binary:
11112              {
11113                  if (j.m_value.binary->has_subtype())
11114                  {
11115                      if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint8_t>::max)())
11116                      {
11117                          write_number(static_cast<std::uint8_t>(0xd8));
11118                          write_number(static_cast<std::uint8_t>(j.m_value.binary->subtype()));
11119                      }
11120                      else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint16_t>::max)())
11121                      {
11122                          write_number(static_cast<std::uint8_t>(0xd9));
11123                          write_number(static_cast<std::uint16_t>(j.m_value.binary->subtype()));
11124                      }
11125                      else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint32_t>::max)())
11126                      {
11127                          write_number(static_cast<std::uint8_t>(0xda));
11128                          write_number(static_cast<std::uint32_t>(j.m_value.binary->subtype()));
11129                      }
11130                      else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint64_t>::max)())
11131                      {
11132                          write_number(static_cast<std::uint8_t>(0xdb));
11133                          write_number(static_cast<std::uint64_t>(j.m_value.binary->subtype()));
11134                      }
11135                  }
11136                  const auto N = j.m_value.binary->size();
11137                  if (N <= 0x17)
11138                  {
11139                      write_number(static_cast<std::uint8_t>(0x40 + N));
11140                  }
11141                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
11142                  {
11143                      oa->write_character(to_char_type(0x58));
11144                      write_number(static_cast<std::uint8_t>(N));
11145                  }
11146                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
11147                  {
11148                      oa->write_character(to_char_type(0x59));
11149                      write_number(static_cast<std::uint16_t>(N));
11150                  }
11151                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
11152                  {
11153                      oa->write_character(to_char_type(0x5A));
11154                      write_number(static_cast<std::uint32_t>(N));
11155                  }
11156                  else if (N <= (std::numeric_limits<std::uint64_t>::max)())
11157                  {
11158                      oa->write_character(to_char_type(0x5B));
11159                      write_number(static_cast<std::uint64_t>(N));
11160                  }
11161                  oa->write_characters(
11162                      reinterpret_cast<const CharType*>(j.m_value.binary->data()),
11163                      N);
11164                  break;
11165              }
11166              case value_t::object:
11167              {
11168                  const auto N = j.m_value.object->size();
11169                  if (N <= 0x17)
11170                  {
11171                      write_number(static_cast<std::uint8_t>(0xA0 + N));
11172                  }
11173                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
11174                  {
11175                      oa->write_character(to_char_type(0xB8));
11176                      write_number(static_cast<std::uint8_t>(N));
11177                  }
11178                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
11179                  {
11180                      oa->write_character(to_char_type(0xB9));
11181                      write_number(static_cast<std::uint16_t>(N));
11182                  }
11183                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
11184                  {
11185                      oa->write_character(to_char_type(0xBA));
11186                      write_number(static_cast<std::uint32_t>(N));
11187                  }
11188                  else if (N <= (std::numeric_limits<std::uint64_t>::max)())
11189                  {
11190                      oa->write_character(to_char_type(0xBB));
11191                      write_number(static_cast<std::uint64_t>(N));
11192                  }
11193                  for (const auto& el : *j.m_value.object)
11194                  {
11195                      write_cbor(el.first);
11196                      write_cbor(el.second);
11197                  }
11198                  break;
11199              }
11200              case value_t::discarded:
11201              default:
11202                  break;
11203          }
11204      }
11205      void write_msgpack(const BasicJsonType& j)
11206      {
11207          switch (j.type())
11208          {
11209              case value_t::null: 
11210              {
11211                  oa->write_character(to_char_type(0xC0));
11212                  break;
11213              }
11214              case value_t::boolean: 
11215              {
11216                  oa->write_character(j.m_value.boolean
11217                                      ? to_char_type(0xC3)
11218                                      : to_char_type(0xC2));
11219                  break;
11220              }
11221              case value_t::number_integer:
11222              {
11223                  if (j.m_value.number_integer >= 0)
11224                  {
11225                      if (j.m_value.number_unsigned < 128)
11226                      {
11227                          write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
11228                      }
11229                      else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
11230                      {
11231                          oa->write_character(to_char_type(0xCC));
11232                          write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
11233                      }
11234                      else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
11235                      {
11236                          oa->write_character(to_char_type(0xCD));
11237                          write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
11238                      }
11239                      else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
11240                      {
11241                          oa->write_character(to_char_type(0xCE));
11242                          write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
11243                      }
11244                      else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
11245                      {
11246                          oa->write_character(to_char_type(0xCF));
11247                          write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
11248                      }
11249                  }
11250                  else
11251                  {
11252                      if (j.m_value.number_integer >= -32)
11253                      {
11254                          write_number(static_cast<std::int8_t>(j.m_value.number_integer));
11255                      }
11256                      else if (j.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&
11257                               j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
11258                      {
11259                          oa->write_character(to_char_type(0xD0));
11260                          write_number(static_cast<std::int8_t>(j.m_value.number_integer));
11261                      }
11262                      else if (j.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&
11263                               j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
11264                      {
11265                          oa->write_character(to_char_type(0xD1));
11266                          write_number(static_cast<std::int16_t>(j.m_value.number_integer));
11267                      }
11268                      else if (j.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&
11269                               j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
11270                      {
11271                          oa->write_character(to_char_type(0xD2));
11272                          write_number(static_cast<std::int32_t>(j.m_value.number_integer));
11273                      }
11274                      else if (j.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&
11275                               j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
11276                      {
11277                          oa->write_character(to_char_type(0xD3));
11278                          write_number(static_cast<std::int64_t>(j.m_value.number_integer));
11279                      }
11280                  }
11281                  break;
11282              }
11283              case value_t::number_unsigned:
11284              {
11285                  if (j.m_value.number_unsigned < 128)
11286                  {
11287                      write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
11288                  }
11289                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
11290                  {
11291                      oa->write_character(to_char_type(0xCC));
11292                      write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
11293                  }
11294                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
11295                  {
11296                      oa->write_character(to_char_type(0xCD));
11297                      write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
11298                  }
11299                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
11300                  {
11301                      oa->write_character(to_char_type(0xCE));
11302                      write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
11303                  }
11304                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
11305                  {
11306                      oa->write_character(to_char_type(0xCF));
11307                      write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
11308                  }
11309                  break;
11310              }
11311              case value_t::number_float:
11312              {
11313                  write_compact_float(j.m_value.number_float, detail::input_format_t::msgpack);
11314                  break;
11315              }
11316              case value_t::string:
11317              {
11318                  const auto N = j.m_value.string->size();
11319                  if (N <= 31)
11320                  {
11321                      write_number(static_cast<std::uint8_t>(0xA0 | N));
11322                  }
11323                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
11324                  {
11325                      oa->write_character(to_char_type(0xD9));
11326                      write_number(static_cast<std::uint8_t>(N));
11327                  }
11328                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
11329                  {
11330                      oa->write_character(to_char_type(0xDA));
11331                      write_number(static_cast<std::uint16_t>(N));
11332                  }
11333                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
11334                  {
11335                      oa->write_character(to_char_type(0xDB));
11336                      write_number(static_cast<std::uint32_t>(N));
11337                  }
11338                  oa->write_characters(
11339                      reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
11340                      j.m_value.string->size());
11341                  break;
11342              }
11343              case value_t::array:
11344              {
11345                  const auto N = j.m_value.array->size();
11346                  if (N <= 15)
11347                  {
11348                      write_number(static_cast<std::uint8_t>(0x90 | N));
11349                  }
11350                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
11351                  {
11352                      oa->write_character(to_char_type(0xDC));
11353                      write_number(static_cast<std::uint16_t>(N));
11354                  }
11355                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
11356                  {
11357                      oa->write_character(to_char_type(0xDD));
11358                      write_number(static_cast<std::uint32_t>(N));
11359                  }
11360                  for (const auto& el : *j.m_value.array)
11361                  {
11362                      write_msgpack(el);
11363                  }
11364                  break;
11365              }
11366              case value_t::binary:
11367              {
11368                  const bool use_ext = j.m_value.binary->has_subtype();
11369                  const auto N = j.m_value.binary->size();
11370                  if (N <= (std::numeric_limits<std::uint8_t>::max)())
11371                  {
11372                      std::uint8_t output_type{};
11373                      bool fixed = true;
11374                      if (use_ext)
11375                      {
11376                          switch (N)
11377                          {
11378                              case 1:
11379                                  output_type = 0xD4; 
11380                                  break;
11381                              case 2:
11382                                  output_type = 0xD5; 
11383                                  break;
11384                              case 4:
11385                                  output_type = 0xD6; 
11386                                  break;
11387                              case 8:
11388                                  output_type = 0xD7; 
11389                                  break;
11390                              case 16:
11391                                  output_type = 0xD8; 
11392                                  break;
11393                              default:
11394                                  output_type = 0xC7; 
11395                                  fixed = false;
11396                                  break;
11397                          }
11398                      }
11399                      else
11400                      {
11401                          output_type = 0xC4; 
11402                          fixed = false;
11403                      }
11404                      oa->write_character(to_char_type(output_type));
11405                      if (!fixed)
11406                      {
11407                          write_number(static_cast<std::uint8_t>(N));
11408                      }
11409                  }
11410                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
11411                  {
11412                      std::uint8_t output_type = use_ext
11413                                                 ? 0xC8 
11414                                                 : 0xC5; 
11415                      oa->write_character(to_char_type(output_type));
11416                      write_number(static_cast<std::uint16_t>(N));
11417                  }
11418                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
11419                  {
11420                      std::uint8_t output_type = use_ext
11421                                                 ? 0xC9 
11422                                                 : 0xC6; 
11423                      oa->write_character(to_char_type(output_type));
11424                      write_number(static_cast<std::uint32_t>(N));
11425                  }
11426                  if (use_ext)
11427                  {
11428                      write_number(static_cast<std::int8_t>(j.m_value.binary->subtype()));
11429                  }
11430                  oa->write_characters(
11431                      reinterpret_cast<const CharType*>(j.m_value.binary->data()),
11432                      N);
11433                  break;
11434              }
11435              case value_t::object:
11436              {
11437                  const auto N = j.m_value.object->size();
11438                  if (N <= 15)
11439                  {
11440                      write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
11441                  }
11442                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
11443                  {
11444                      oa->write_character(to_char_type(0xDE));
11445                      write_number(static_cast<std::uint16_t>(N));
11446                  }
11447                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
11448                  {
11449                      oa->write_character(to_char_type(0xDF));
11450                      write_number(static_cast<std::uint32_t>(N));
11451                  }
11452                  for (const auto& el : *j.m_value.object)
11453                  {
11454                      write_msgpack(el.first);
11455                      write_msgpack(el.second);
11456                  }
11457                  break;
11458              }
11459              case value_t::discarded:
11460              default:
11461                  break;
11462          }
11463      }
11464      void write_ubjson(const BasicJsonType& j, const bool use_count,
11465                        const bool use_type, const bool add_prefix = true,
11466                        const bool use_bjdata = false)
11467      {
11468          switch (j.type())
11469          {
11470              case value_t::null:
11471              {
11472                  if (add_prefix)
11473                  {
11474                      oa->write_character(to_char_type('Z'));
11475                  }
11476                  break;
11477              }
11478              case value_t::boolean:
11479              {
11480                  if (add_prefix)
11481                  {
11482                      oa->write_character(j.m_value.boolean
11483                                          ? to_char_type('T')
11484                                          : to_char_type('F'));
11485                  }
11486                  break;
11487              }
11488              case value_t::number_integer:
11489              {
11490                  write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix, use_bjdata);
11491                  break;
11492              }
11493              case value_t::number_unsigned:
11494              {
11495                  write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix, use_bjdata);
11496                  break;
11497              }
11498              case value_t::number_float:
11499              {
11500                  write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix, use_bjdata);
11501                  break;
11502              }
11503              case value_t::string:
11504              {
11505                  if (add_prefix)
11506                  {
11507                      oa->write_character(to_char_type('S'));
11508                  }
11509                  write_number_with_ubjson_prefix(j.m_value.string->size(), true, use_bjdata);
11510                  oa->write_characters(
11511                      reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
11512                      j.m_value.string->size());
11513                  break;
11514              }
11515              case value_t::array:
11516              {
11517                  if (add_prefix)
11518                  {
11519                      oa->write_character(to_char_type('['));
11520                  }
11521                  bool prefix_required = true;
11522                  if (use_type && !j.m_value.array->empty())
11523                  {
11524                      JSON_ASSERT(use_count);
11525                      const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
11526                      const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
11527                                                           [this, first_prefix, use_bjdata](const BasicJsonType & v)
11528                      {
11529                          return ubjson_prefix(v, use_bjdata) == first_prefix;
11530                      });
11531                      std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; 
11532                      if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
11533                      {
11534                          prefix_required = false;
11535                          oa->write_character(to_char_type('$'));
11536                          oa->write_character(first_prefix);
11537                      }
11538                  }
11539                  if (use_count)
11540                  {
11541                      oa->write_character(to_char_type('#'));
11542                      write_number_with_ubjson_prefix(j.m_value.array->size(), true, use_bjdata);
11543                  }
11544                  for (const auto& el : *j.m_value.array)
11545                  {
11546                      write_ubjson(el, use_count, use_type, prefix_required, use_bjdata);
11547                  }
11548                  if (!use_count)
11549                  {
11550                      oa->write_character(to_char_type(']'));
11551                  }
11552                  break;
11553              }
11554              case value_t::binary:
11555              {
11556                  if (add_prefix)
11557                  {
11558                      oa->write_character(to_char_type('['));
11559                  }
11560                  if (use_type && !j.m_value.binary->empty())
11561                  {
11562                      JSON_ASSERT(use_count);
11563                      oa->write_character(to_char_type('$'));
11564                      oa->write_character('U');
11565                  }
11566                  if (use_count)
11567                  {
11568                      oa->write_character(to_char_type('#'));
11569                      write_number_with_ubjson_prefix(j.m_value.binary->size(), true, use_bjdata);
11570                  }
11571                  if (use_type)
11572                  {
11573                      oa->write_characters(
11574                          reinterpret_cast<const CharType*>(j.m_value.binary->data()),
11575                          j.m_value.binary->size());
11576                  }
11577                  else
11578                  {
11579                      for (size_t i = 0; i < j.m_value.binary->size(); ++i)
11580                      {
11581                          oa->write_character(to_char_type('U'));
11582                          oa->write_character(j.m_value.binary->data()[i]);
11583                      }
11584                  }
11585                  if (!use_count)
11586                  {
11587                      oa->write_character(to_char_type(']'));
11588                  }
11589                  break;
11590              }
11591              case value_t::object:
11592              {
11593                  if (use_bjdata && j.m_value.object->size() == 3 && j.m_value.object->find("_ArrayType_") != j.m_value.object->end() && j.m_value.object->find("_ArraySize_") != j.m_value.object->end() && j.m_value.object->find("_ArrayData_") != j.m_value.object->end())
11594                  {
11595                      if (!write_bjdata_ndarray(*j.m_value.object, use_count, use_type))  
11596                      {
11597                          break;
11598                      }
11599                  }
11600                  if (add_prefix)
11601                  {
11602                      oa->write_character(to_char_type('{'));
11603                  }
11604                  bool prefix_required = true;
11605                  if (use_type && !j.m_value.object->empty())
11606                  {
11607                      JSON_ASSERT(use_count);
11608                      const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
11609                      const bool same_prefix = std::all_of(j.begin(), j.end(),
11610                                                           [this, first_prefix, use_bjdata](const BasicJsonType & v)
11611                      {
11612                          return ubjson_prefix(v, use_bjdata) == first_prefix;
11613                      });
11614                      std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; 
11615                      if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
11616                      {
11617                          prefix_required = false;
11618                          oa->write_character(to_char_type('$'));
11619                          oa->write_character(first_prefix);
11620                      }
11621                  }
11622                  if (use_count)
11623                  {
11624                      oa->write_character(to_char_type('#'));
11625                      write_number_with_ubjson_prefix(j.m_value.object->size(), true, use_bjdata);
11626                  }
11627                  for (const auto& el : *j.m_value.object)
11628                  {
11629                      write_number_with_ubjson_prefix(el.first.size(), true, use_bjdata);
11630                      oa->write_characters(
11631                          reinterpret_cast<const CharType*>(el.first.c_str()),
11632                          el.first.size());
11633                      write_ubjson(el.second, use_count, use_type, prefix_required, use_bjdata);
11634                  }
11635                  if (!use_count)
11636                  {
11637                      oa->write_character(to_char_type('}'));
11638                  }
11639                  break;
11640              }
11641              case value_t::discarded:
11642              default:
11643                  break;
11644          }
11645      }
11646    private:
11647      static std::size_t calc_bson_entry_header_size(const string_t& name, const BasicJsonType& j)
11648      {
11649          const auto it = name.find(static_cast<typename string_t::value_type>(0));
11650          if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
11651          {
11652              JSON_THROW(out_of_range::create(409, concat("BSON key cannot contain code point U+0000 (at byte ", std::to_string(it), ")"), &j));
11653              static_cast<void>(j);
11654          }
11655          return &bsol;*id*/ 1ul + name.size() + &bsol;*zero-terminator*/1u;
11656      }
11657      void write_bson_entry_header(const string_t& name,
11658                                   const std::uint8_t element_type)
11659      {
11660          oa->write_character(to_char_type(element_type)); 
11661          oa->write_characters(
11662              reinterpret_cast<const CharType*>(name.c_str()),
11663              name.size() + 1u);
11664      }
11665      void write_bson_boolean(const string_t& name,
11666                              const bool value)
11667      {
11668          write_bson_entry_header(name, 0x08);
11669          oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
11670      }
11671      void write_bson_double(const string_t& name,
11672                             const double value)
11673      {
11674          write_bson_entry_header(name, 0x01);
11675          write_number<double>(value, true);
11676      }
11677      static std::size_t calc_bson_string_size(const string_t& value)
11678      {
11679          return sizeof(std::int32_t) + value.size() + 1ul;
11680      }
11681      void write_bson_string(const string_t& name,
11682                             const string_t& value)
11683      {
11684          write_bson_entry_header(name, 0x02);
11685          write_number<std::int32_t>(static_cast<std::int32_t>(value.size() + 1ul), true);
11686          oa->write_characters(
11687              reinterpret_cast<const CharType*>(value.c_str()),
11688              value.size() + 1);
11689      }
11690      void write_bson_null(const string_t& name)
11691      {
11692          write_bson_entry_header(name, 0x0A);
11693      }
11694      static std::size_t calc_bson_integer_size(const std::int64_t value)
11695      {
11696          return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()
11697                 ? sizeof(std::int32_t)
11698                 : sizeof(std::int64_t);
11699      }
11700      void write_bson_integer(const string_t& name,
11701                              const std::int64_t value)
11702      {
11703          if ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())
11704          {
11705              write_bson_entry_header(name, 0x10); 
11706              write_number<std::int32_t>(static_cast<std::int32_t>(value), true);
11707          }
11708          else
11709          {
11710              write_bson_entry_header(name, 0x12); 
11711              write_number<std::int64_t>(static_cast<std::int64_t>(value), true);
11712          }
11713      }
11714      static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
11715      {
11716          return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
11717                 ? sizeof(std::int32_t)
11718                 : sizeof(std::int64_t);
11719      }
11720      void write_bson_unsigned(const string_t& name,
11721                               const BasicJsonType& j)
11722      {
11723          if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
11724          {
11725              write_bson_entry_header(name, 0x10 &bsol;* int32 */);
11726              write_number<std::int32_t>(static_cast<std::int32_t>(j.m_value.number_unsigned), true);
11727          }
11728          else if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
11729          {
11730              write_bson_entry_header(name, 0x12 &bsol;* int64 */);
11731              write_number<std::int64_t>(static_cast<std::int64_t>(j.m_value.number_unsigned), true);
11732          }
11733          else
11734          {
11735              JSON_THROW(out_of_range::create(407, concat("integer number ", std::to_string(j.m_value.number_unsigned), " cannot be represented by BSON as it does not fit int64"), &j));
11736          }
11737      }
11738      void write_bson_object_entry(const string_t& name,
11739                                   const typename BasicJsonType::object_t& value)
11740      {
11741          write_bson_entry_header(name, 0x03); 
11742          write_bson_object(value);
11743      }
11744      static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
11745      {
11746          std::size_t array_index = 0ul;
11747          const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), static_cast<std::size_t>(0), [&array_index](std::size_t result, const typename BasicJsonType::array_t::value_type & el)
11748          {
11749              return result + calc_bson_element_size(std::to_string(array_index++), el);
11750          });
11751          return sizeof(std::int32_t) + embedded_document_size + 1ul;
11752      }
11753      static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t& value)
11754      {
11755          return sizeof(std::int32_t) + value.size() + 1ul;
11756      }
11757      void write_bson_array(const string_t& name,
11758                            const typename BasicJsonType::array_t& value)
11759      {
11760          write_bson_entry_header(name, 0x04); 
11761          write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_array_size(value)), true);
11762          std::size_t array_index = 0ul;
11763          for (const auto& el : value)
11764          {
11765              write_bson_element(std::to_string(array_index++), el);
11766          }
11767          oa->write_character(to_char_type(0x00));
11768      }
11769      void write_bson_binary(const string_t& name,
11770                             const binary_t& value)
11771      {
11772          write_bson_entry_header(name, 0x05);
11773          write_number<std::int32_t>(static_cast<std::int32_t>(value.size()), true);
11774          write_number(value.has_subtype() ? static_cast<std::uint8_t>(value.subtype()) : static_cast<std::uint8_t>(0x00));
11775          oa->write_characters(reinterpret_cast<const CharType*>(value.data()), value.size());
11776      }
11777      static std::size_t calc_bson_element_size(const string_t& name,
11778              const BasicJsonType& j)
11779      {
11780          const auto header_size = calc_bson_entry_header_size(name, j);
11781          switch (j.type())
11782          {
11783              case value_t::object:
11784                  return header_size + calc_bson_object_size(*j.m_value.object);
11785              case value_t::array:
11786                  return header_size + calc_bson_array_size(*j.m_value.array);
11787              case value_t::binary:
11788                  return header_size + calc_bson_binary_size(*j.m_value.binary);
11789              case value_t::boolean:
11790                  return header_size + 1ul;
11791              case value_t::number_float:
11792                  return header_size + 8ul;
11793              case value_t::number_integer:
11794                  return header_size + calc_bson_integer_size(j.m_value.number_integer);
11795              case value_t::number_unsigned:
11796                  return header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);
11797              case value_t::string:
11798                  return header_size + calc_bson_string_size(*j.m_value.string);
11799              case value_t::null:
11800                  return header_size + 0ul;
11801              case value_t::discarded:
11802              default:
11803                  JSON_ASSERT(false); 
11804                  return 0ul;
11805          }
11806      }
11807      void write_bson_element(const string_t& name,
11808                              const BasicJsonType& j)
11809      {
11810          switch (j.type())
11811          {
11812              case value_t::object:
11813                  return write_bson_object_entry(name, *j.m_value.object);
11814              case value_t::array:
11815                  return write_bson_array(name, *j.m_value.array);
11816              case value_t::binary:
11817                  return write_bson_binary(name, *j.m_value.binary);
11818              case value_t::boolean:
11819                  return write_bson_boolean(name, j.m_value.boolean);
11820              case value_t::number_float:
11821                  return write_bson_double(name, j.m_value.number_float);
11822              case value_t::number_integer:
11823                  return write_bson_integer(name, j.m_value.number_integer);
11824              case value_t::number_unsigned:
11825                  return write_bson_unsigned(name, j);
11826              case value_t::string:
11827                  return write_bson_string(name, *j.m_value.string);
11828              case value_t::null:
11829                  return write_bson_null(name);
11830              case value_t::discarded:
11831              default:
11832                  JSON_ASSERT(false); 
11833                  return;
11834          }
11835      }
11836      static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
11837      {
11838          std::size_t document_size = std::accumulate(value.begin(), value.end(), static_cast<std::size_t>(0),
11839                                      [](size_t result, const typename BasicJsonType::object_t::value_type & el)
11840          {
11841              return result += calc_bson_element_size(el.first, el.second);
11842          });
11843          return sizeof(std::int32_t) + document_size + 1ul;
11844      }
11845      void write_bson_object(const typename BasicJsonType::object_t& value)
11846      {
11847          write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_object_size(value)), true);
11848          for (const auto& el : value)
11849          {
11850              write_bson_element(el.first, el.second);
11851          }
11852          oa->write_character(to_char_type(0x00));
11853      }
11854      static constexpr CharType get_cbor_float_prefix(float &bsol;*unused*/)
11855      {
11856          return to_char_type(0xFA);  
11857      }
11858      static constexpr CharType get_cbor_float_prefix(double &bsol;*unused*/)
11859      {
11860          return to_char_type(0xFB);  
11861      }
11862      static constexpr CharType get_msgpack_float_prefix(float &bsol;*unused*/)
11863      {
11864          return to_char_type(0xCA);  
11865      }
11866      static constexpr CharType get_msgpack_float_prefix(double &bsol;*unused*/)
11867      {
11868          return to_char_type(0xCB);  
11869      }
11870      template<typename NumberType, typename std::enable_if<
11871                   std::is_floating_point<NumberType>::value, int>::type = 0>
11872      void write_number_with_ubjson_prefix(const NumberType n,
11873                                           const bool add_prefix,
11874                                           const bool use_bjdata)
11875      {
11876          if (add_prefix)
11877          {
11878              oa->write_character(get_ubjson_float_prefix(n));
11879          }
11880          write_number(n, use_bjdata);
11881      }
11882      template<typename NumberType, typename std::enable_if<
11883                   std::is_unsigned<NumberType>::value, int>::type = 0>
11884      void write_number_with_ubjson_prefix(const NumberType n,
11885                                           const bool add_prefix,
11886                                           const bool use_bjdata)
11887      {
11888          if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
11889          {
11890              if (add_prefix)
11891              {
11892                  oa->write_character(to_char_type('i'));  
11893              }
11894              write_number(static_cast<std::uint8_t>(n), use_bjdata);
11895          }
11896          else if (n <= (std::numeric_limits<std::uint8_t>::max)())
11897          {
11898              if (add_prefix)
11899              {
11900                  oa->write_character(to_char_type('U'));  
11901              }
11902              write_number(static_cast<std::uint8_t>(n), use_bjdata);
11903          }
11904          else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
11905          {
11906              if (add_prefix)
11907              {
11908                  oa->write_character(to_char_type('I'));  
11909              }
11910              write_number(static_cast<std::int16_t>(n), use_bjdata);
11911          }
11912          else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint16_t>::max)()))
11913          {
11914              if (add_prefix)
11915              {
11916                  oa->write_character(to_char_type('u'));  
11917              }
11918              write_number(static_cast<std::uint16_t>(n), use_bjdata);
11919          }
11920          else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
11921          {
11922              if (add_prefix)
11923              {
11924                  oa->write_character(to_char_type('l'));  
11925              }
11926              write_number(static_cast<std::int32_t>(n), use_bjdata);
11927          }
11928          else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint32_t>::max)()))
11929          {
11930              if (add_prefix)
11931              {
11932                  oa->write_character(to_char_type('m'));  
11933              }
11934              write_number(static_cast<std::uint32_t>(n), use_bjdata);
11935          }
11936          else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
11937          {
11938              if (add_prefix)
11939              {
11940                  oa->write_character(to_char_type('L'));  
11941              }
11942              write_number(static_cast<std::int64_t>(n), use_bjdata);
11943          }
11944          else if (use_bjdata && n <= (std::numeric_limits<uint64_t>::max)())
11945          {
11946              if (add_prefix)
11947              {
11948                  oa->write_character(to_char_type('M'));  
11949              }
11950              write_number(static_cast<std::uint64_t>(n), use_bjdata);
11951          }
11952          else
11953          {
11954              if (add_prefix)
11955              {
11956                  oa->write_character(to_char_type('H'));  
11957              }
11958              const auto number = BasicJsonType(n).dump();
11959              write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
11960              for (std::size_t i = 0; i < number.size(); ++i)
11961              {
11962                  oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
11963              }
11964          }
11965      }
11966      template < typename NumberType, typename std::enable_if <
11967                     std::is_signed<NumberType>::value&&
11968                     !std::is_floating_point<NumberType>::value, int >::type = 0 >
11969      void write_number_with_ubjson_prefix(const NumberType n,
11970                                           const bool add_prefix,
11971                                           const bool use_bjdata)
11972      {
11973          if ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())
11974          {
11975              if (add_prefix)
11976              {
11977                  oa->write_character(to_char_type('i'));  
11978              }
11979              write_number(static_cast<std::int8_t>(n), use_bjdata);
11980          }
11981          else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
11982          {
11983              if (add_prefix)
11984              {
11985                  oa->write_character(to_char_type('U'));  
11986              }
11987              write_number(static_cast<std::uint8_t>(n), use_bjdata);
11988          }
11989          else if ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())
11990          {
11991              if (add_prefix)
11992              {
11993                  oa->write_character(to_char_type('I'));  
11994              }
11995              write_number(static_cast<std::int16_t>(n), use_bjdata);
11996          }
11997          else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::max)())))
11998          {
11999              if (add_prefix)
12000              {
12001                  oa->write_character(to_char_type('u'));  
12002              }
12003              write_number(static_cast<uint16_t>(n), use_bjdata);
12004          }
12005          else if ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())
12006          {
12007              if (add_prefix)
12008              {
12009                  oa->write_character(to_char_type('l'));  
12010              }
12011              write_number(static_cast<std::int32_t>(n), use_bjdata);
12012          }
12013          else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::max)())))
12014          {
12015              if (add_prefix)
12016              {
12017                  oa->write_character(to_char_type('m'));  
12018              }
12019              write_number(static_cast<uint32_t>(n), use_bjdata);
12020          }
12021          else if ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())
12022          {
12023              if (add_prefix)
12024              {
12025                  oa->write_character(to_char_type('L'));  
12026              }
12027              write_number(static_cast<std::int64_t>(n), use_bjdata);
12028          }
12029          else
12030          {
12031              if (add_prefix)
12032              {
12033                  oa->write_character(to_char_type('H'));  
12034              }
12035              const auto number = BasicJsonType(n).dump();
12036              write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
12037              for (std::size_t i = 0; i < number.size(); ++i)
12038              {
12039                  oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
12040              }
12041          }
12042      }
12043      CharType ubjson_prefix(const BasicJsonType& j, const bool use_bjdata) const noexcept
12044      {
12045          switch (j.type())
12046          {
12047              case value_t::null:
12048                  return 'Z';
12049              case value_t::boolean:
12050                  return j.m_value.boolean ? 'T' : 'F';
12051              case value_t::number_integer:
12052              {
12053                  if ((std::numeric_limits<std::int8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
12054                  {
12055                      return 'i';
12056                  }
12057                  if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
12058                  {
12059                      return 'U';
12060                  }
12061                  if ((std::numeric_limits<std::int16_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
12062                  {
12063                      return 'I';
12064                  }
12065                  if (use_bjdata && ((std::numeric_limits<std::uint16_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)()))
12066                  {
12067                      return 'u';
12068                  }
12069                  if ((std::numeric_limits<std::int32_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
12070                  {
12071                      return 'l';
12072                  }
12073                  if (use_bjdata && ((std::numeric_limits<std::uint32_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)()))
12074                  {
12075                      return 'm';
12076                  }
12077                  if ((std::numeric_limits<std::int64_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
12078                  {
12079                      return 'L';
12080                  }
12081                  return 'H'; 
12082              }
12083              case value_t::number_unsigned:
12084              {
12085                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
12086                  {
12087                      return 'i';
12088                  }
12089                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
12090                  {
12091                      return 'U';
12092                  }
12093                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
12094                  {
12095                      return 'I';
12096                  }
12097                  if (use_bjdata && j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint16_t>::max)()))
12098                  {
12099                      return 'u';
12100                  }
12101                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
12102                  {
12103                      return 'l';
12104                  }
12105                  if (use_bjdata && j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint32_t>::max)()))
12106                  {
12107                      return 'm';
12108                  }
12109                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
12110                  {
12111                      return 'L';
12112                  }
12113                  if (use_bjdata && j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
12114                  {
12115                      return 'M';
12116                  }
12117                  return 'H'; 
12118              }
12119              case value_t::number_float:
12120                  return get_ubjson_float_prefix(j.m_value.number_float);
12121              case value_t::string:
12122                  return 'S';
12123              case value_t::array: 
12124              case value_t::binary:
12125                  return '[';
12126              case value_t::object:
12127                  return '{';
12128              case value_t::discarded:
12129              default:  
12130                  return 'N';
12131          }
12132      }
12133      static constexpr CharType get_ubjson_float_prefix(float &bsol;*unused*/)
12134      {
12135          return 'd';  
12136      }
12137      static constexpr CharType get_ubjson_float_prefix(double &bsol;*unused*/)
12138      {
12139          return 'D';  
12140      }
12141      bool write_bjdata_ndarray(const typename BasicJsonType::object_t& value, const bool use_count, const bool use_type)
12142      {
12143          std::map<string_t, CharType> bjdtype = {{"uint8", 'U'},  {"int8", 'i'},  {"uint16", 'u'}, {"int16", 'I'},
12144              {"uint32", 'm'}, {"int32", 'l'}, {"uint64", 'M'}, {"int64", 'L'}, {"single", 'd'}, {"double", 'D'}, {"char", 'C'}
12145          };
12146          string_t key = "_ArrayType_";
12147          auto it = bjdtype.find(static_cast<string_t>(value.at(key)));
12148          if (it == bjdtype.end())
12149          {
12150              return true;
12151          }
12152          CharType dtype = it->second;
12153          key = "_ArraySize_";
12154          std::size_t len = (value.at(key).empty() ? 0 : 1);
12155          for (const auto& el : value.at(key))
12156          {
12157              len *= static_cast<std::size_t>(el.m_value.number_unsigned);
12158          }
12159          key = "_ArrayData_";
12160          if (value.at(key).size() != len)
12161          {
12162              return true;
12163          }
12164          oa->write_character('[');
12165          oa->write_character('$');
12166          oa->write_character(dtype);
12167          oa->write_character('#');
12168          key = "_ArraySize_";
12169          write_ubjson(value.at(key), use_count, use_type, true,  true);
12170          key = "_ArrayData_";
12171          if (dtype == 'U' || dtype == 'C')
12172          {
12173              for (const auto& el : value.at(key))
12174              {
12175                  write_number(static_cast<std::uint8_t>(el.m_value.number_unsigned), true);
12176              }
12177          }
12178          else if (dtype == 'i')
12179          {
12180              for (const auto& el : value.at(key))
12181              {
12182                  write_number(static_cast<std::int8_t>(el.m_value.number_integer), true);
12183              }
12184          }
12185          else if (dtype == 'u')
12186          {
12187              for (const auto& el : value.at(key))
12188              {
12189                  write_number(static_cast<std::uint16_t>(el.m_value.number_unsigned), true);
12190              }
12191          }
12192          else if (dtype == 'I')
12193          {
12194              for (const auto& el : value.at(key))
12195              {
12196                  write_number(static_cast<std::int16_t>(el.m_value.number_integer), true);
12197              }
12198          }
12199          else if (dtype == 'm')
12200          {
12201              for (const auto& el : value.at(key))
12202              {
12203                  write_number(static_cast<std::uint32_t>(el.m_value.number_unsigned), true);
12204              }
12205          }
12206          else if (dtype == 'l')
12207          {
12208              for (const auto& el : value.at(key))
12209              {
12210                  write_number(static_cast<std::int32_t>(el.m_value.number_integer), true);
12211              }
12212          }
12213          else if (dtype == 'M')
12214          {
12215              for (const auto& el : value.at(key))
12216              {
12217                  write_number(static_cast<std::uint64_t>(el.m_value.number_unsigned), true);
12218              }
12219          }
12220          else if (dtype == 'L')
12221          {
12222              for (const auto& el : value.at(key))
12223              {
12224                  write_number(static_cast<std::int64_t>(el.m_value.number_integer), true);
12225              }
12226          }
12227          else if (dtype == 'd')
12228          {
12229              for (const auto& el : value.at(key))
12230              {
12231                  write_number(static_cast<float>(el.m_value.number_float), true);
12232              }
12233          }
12234          else if (dtype == 'D')
12235          {
12236              for (const auto& el : value.at(key))
12237              {
12238                  write_number(static_cast<double>(el.m_value.number_float), true);
12239              }
12240          }
12241          return false;
12242      }
12243      template<typename NumberType>
12244      void write_number(const NumberType n, const bool OutputIsLittleEndian = false)
12245      {
12246          std::array<CharType, sizeof(NumberType)> vec{};
12247          std::memcpy(vec.data(), &n, sizeof(NumberType));
12248          if (is_little_endian != OutputIsLittleEndian)
12249          {
12250              std::reverse(vec.begin(), vec.end());
12251          }
12252          oa->write_characters(vec.data(), sizeof(NumberType));
12253      }
12254      void write_compact_float(const number_float_t n, detail::input_format_t format)
12255      {
12256  #ifdef __GNUC__
12257  #pragma GCC diagnostic push
12258  #pragma GCC diagnostic ignored "-Wfloat-equal"
12259  #endif
12260          if (static_cast<double>(n) >= static_cast<double>(std::numeric_limits<float>::lowest()) &&
12261                  static_cast<double>(n) <= static_cast<double>((std::numeric_limits<float>::max)()) &&
12262                  static_cast<double>(static_cast<float>(n)) == static_cast<double>(n))
12263          {
12264              oa->write_character(format == detail::input_format_t::cbor
12265                                  ? get_cbor_float_prefix(static_cast<float>(n))
12266                                  : get_msgpack_float_prefix(static_cast<float>(n)));
12267              write_number(static_cast<float>(n));
12268          }
12269          else
12270          {
12271              oa->write_character(format == detail::input_format_t::cbor
12272                                  ? get_cbor_float_prefix(n)
12273                                  : get_msgpack_float_prefix(n));
12274              write_number(n);
12275          }
12276  #ifdef __GNUC__
12277  #pragma GCC diagnostic pop
12278  #endif
12279      }
12280    public:
12281      template < typename C = CharType,
12282                 enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = nullptr >
12283      static constexpr CharType to_char_type(std::uint8_t x) noexcept
12284      {
12285          return *reinterpret_cast<char*>(&x);
12286      }
12287      template < typename C = CharType,
12288                 enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = nullptr >
12289      static CharType to_char_type(std::uint8_t x) noexcept
12290      {
12291          static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
12292          static_assert(std::is_trivial<CharType>::value, "CharType must be trivial");
12293          CharType result;
12294          std::memcpy(&result, &x, sizeof(x));
12295          return result;
12296      }
12297      template<typename C = CharType,
12298               enable_if_t<std::is_unsigned<C>::value>* = nullptr>
12299      static constexpr CharType to_char_type(std::uint8_t x) noexcept
12300      {
12301          return x;
12302      }
12303      template < typename InputCharType, typename C = CharType,
12304                 enable_if_t <
12305                     std::is_signed<C>::value &&
12306                     std::is_signed<char>::value &&
12307                     std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
12308                     > * = nullptr >
12309      static constexpr CharType to_char_type(InputCharType x) noexcept
12310      {
12311          return x;
12312      }
12313    private:
12314      const bool is_little_endian = little_endianness();
12315      output_adapter_t<CharType> oa = nullptr;
12316  };
12317  }  
12318  NLOHMANN_JSON_NAMESPACE_END
12319  #include <algorithm> 
12320  #include <array> 
12321  #include <clocale> 
12322  #include <cmath> 
12323  #include <cstddef> 
12324  #include <cstdint> 
12325  #include <cstdio> 
12326  #include <limits> 
12327  #include <string> 
12328  #include <iomanip> 
12329  #include <type_traits> 
12330  #include <utility> 
12331  #include <array> 
12332  #include <cmath>   
12333  #include <cstdint> 
12334  #include <cstring> 
12335  #include <limits> 
12336  #include <type_traits> 
12337  NLOHMANN_JSON_NAMESPACE_BEGIN
12338  namespace detail
12339  {
12340  namespace dtoa_impl
12341  {
12342  template<typename Target, typename Source>
12343  Target reinterpret_bits(const Source source)
12344  {
12345      static_assert(sizeof(Target) == sizeof(Source), "size mismatch");
12346      Target target;
12347      std::memcpy(&target, &source, sizeof(Source));
12348      return target;
12349  }
12350  struct diyfp 
12351  {
12352      static constexpr int kPrecision = 64; 
12353      std::uint64_t f = 0;
12354      int e = 0;
12355      constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}
12356      static diyfp sub(const diyfp& x, const diyfp& y) noexcept
12357      {
12358          JSON_ASSERT(x.e == y.e);
12359          JSON_ASSERT(x.f >= y.f);
12360          return {x.f - y.f, x.e};
12361      }
12362      static diyfp mul(const diyfp& x, const diyfp& y) noexcept
12363      {
12364          static_assert(kPrecision == 64, "internal error");
12365          const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
12366          const std::uint64_t u_hi = x.f >> 32u;
12367          const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
12368          const std::uint64_t v_hi = y.f >> 32u;
12369          const std::uint64_t p0 = u_lo * v_lo;
12370          const std::uint64_t p1 = u_lo * v_hi;
12371          const std::uint64_t p2 = u_hi * v_lo;
12372          const std::uint64_t p3 = u_hi * v_hi;
12373          const std::uint64_t p0_hi = p0 >> 32u;
12374          const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
12375          const std::uint64_t p1_hi = p1 >> 32u;
12376          const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
12377          const std::uint64_t p2_hi = p2 >> 32u;
12378          std::uint64_t Q = p0_hi + p1_lo + p2_lo;
12379          Q += std::uint64_t{1} << (64u - 32u - 1u); 
12380          const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);
12381          return {h, x.e + y.e + 64};
12382      }
12383      static diyfp normalize(diyfp x) noexcept
12384      {
12385          JSON_ASSERT(x.f != 0);
12386          while ((x.f >> 63u) == 0)
12387          {
12388              x.f <<= 1u;
12389              x.e--;
12390          }
12391          return x;
12392      }
12393      static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
12394      {
12395          const int delta = x.e - target_exponent;
12396          JSON_ASSERT(delta >= 0);
12397          JSON_ASSERT(((x.f << delta) >> delta) == x.f);
12398          return {x.f << delta, target_exponent};
12399      }
12400  };
12401  struct boundaries
12402  {
12403      diyfp w;
12404      diyfp minus;
12405      diyfp plus;
12406  };
12407  template<typename FloatType>
12408  boundaries compute_boundaries(FloatType value)
12409  {
12410      JSON_ASSERT(std::isfinite(value));
12411      JSON_ASSERT(value > 0);
12412      static_assert(std::numeric_limits<FloatType>::is_iec559,
12413                    "internal error: dtoa_short requires an IEEE-754 floating-point implementation");
12414      constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; 
12415      constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
12416      constexpr int      kMinExp    = 1 - kBias;
12417      constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); 
12418      using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;
12419      const auto bits = static_cast<std::uint64_t>(reinterpret_bits<bits_type>(value));
12420      const std::uint64_t E = bits >> (kPrecision - 1);
12421      const std::uint64_t F = bits & (kHiddenBit - 1);
12422      const bool is_denormal = E == 0;
12423      const diyfp v = is_denormal
12424                      ? diyfp(F, kMinExp)
12425                      : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);
12426      const bool lower_boundary_is_closer = F == 0 && E > 1;
12427      const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
12428      const diyfp m_minus = lower_boundary_is_closer
12429                            ? diyfp(4 * v.f - 1, v.e - 2)  
12430                            : diyfp(2 * v.f - 1, v.e - 1); 
12431      const diyfp w_plus = diyfp::normalize(m_plus);
12432      const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);
12433      return {diyfp::normalize(v), w_minus, w_plus};
12434  }
12435  constexpr int kAlpha = -60;
12436  constexpr int kGamma = -32;
12437  struct cached_power 
12438  {
12439      std::uint64_t f;
12440      int e;
12441      int k;
12442  };
12443  inline cached_power get_cached_power_for_binary_exponent(int e)
12444  {
12445      constexpr int kCachedPowersMinDecExp = -300;
12446      constexpr int kCachedPowersDecStep = 8;
12447      static constexpr std::array<cached_power, 79> kCachedPowers =
12448      {
12449          {
12450              { 0xAB70FE17C79AC6CA, -1060, -300 },
12451              { 0xFF77B1FCBEBCDC4F, -1034, -292 },
12452              { 0xBE5691EF416BD60C, -1007, -284 },
12453              { 0x8DD01FAD907FFC3C,  -980, -276 },
12454              { 0xD3515C2831559A83,  -954, -268 },
12455              { 0x9D71AC8FADA6C9B5,  -927, -260 },
12456              { 0xEA9C227723EE8BCB,  -901, -252 },
12457              { 0xAECC49914078536D,  -874, -244 },
12458              { 0x823C12795DB6CE57,  -847, -236 },
12459              { 0xC21094364DFB5637,  -821, -228 },
12460              { 0x9096EA6F3848984F,  -794, -220 },
12461              { 0xD77485CB25823AC7,  -768, -212 },
12462              { 0xA086CFCD97BF97F4,  -741, -204 },
12463              { 0xEF340A98172AACE5,  -715, -196 },
12464              { 0xB23867FB2A35B28E,  -688, -188 },
12465              { 0x84C8D4DFD2C63F3B,  -661, -180 },
12466              { 0xC5DD44271AD3CDBA,  -635, -172 },
12467              { 0x936B9FCEBB25C996,  -608, -164 },
12468              { 0xDBAC6C247D62A584,  -582, -156 },
12469              { 0xA3AB66580D5FDAF6,  -555, -148 },
12470              { 0xF3E2F893DEC3F126,  -529, -140 },
12471              { 0xB5B5ADA8AAFF80B8,  -502, -132 },
12472              { 0x87625F056C7C4A8B,  -475, -124 },
12473              { 0xC9BCFF6034C13053,  -449, -116 },
12474              { 0x964E858C91BA2655,  -422, -108 },
12475              { 0xDFF9772470297EBD,  -396, -100 },
12476              { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
12477              { 0xF8A95FCF88747D94,  -343,  -84 },
12478              { 0xB94470938FA89BCF,  -316,  -76 },
12479              { 0x8A08F0F8BF0F156B,  -289,  -68 },
12480              { 0xCDB02555653131B6,  -263,  -60 },
12481              { 0x993FE2C6D07B7FAC,  -236,  -52 },
12482              { 0xE45C10C42A2B3B06,  -210,  -44 },
12483              { 0xAA242499697392D3,  -183,  -36 },
12484              { 0xFD87B5F28300CA0E,  -157,  -28 },
12485              { 0xBCE5086492111AEB,  -130,  -20 },
12486              { 0x8CBCCC096F5088CC,  -103,  -12 },
12487              { 0xD1B71758E219652C,   -77,   -4 },
12488              { 0x9C40000000000000,   -50,    4 },
12489              { 0xE8D4A51000000000,   -24,   12 },
12490              { 0xAD78EBC5AC620000,     3,   20 },
12491              { 0x813F3978F8940984,    30,   28 },
12492              { 0xC097CE7BC90715B3,    56,   36 },
12493              { 0x8F7E32CE7BEA5C70,    83,   44 },
12494              { 0xD5D238A4ABE98068,   109,   52 },
12495              { 0x9F4F2726179A2245,   136,   60 },
12496              { 0xED63A231D4C4FB27,   162,   68 },
12497              { 0xB0DE65388CC8ADA8,   189,   76 },
12498              { 0x83C7088E1AAB65DB,   216,   84 },
12499              { 0xC45D1DF942711D9A,   242,   92 },
12500              { 0x924D692CA61BE758,   269,  100 },
12501              { 0xDA01EE641A708DEA,   295,  108 },
12502              { 0xA26DA3999AEF774A,   322,  116 },
12503              { 0xF209787BB47D6B85,   348,  124 },
12504              { 0xB454E4A179DD1877,   375,  132 },
12505              { 0x865B86925B9BC5C2,   402,  140 },
12506              { 0xC83553C5C8965D3D,   428,  148 },
12507              { 0x952AB45CFA97A0B3,   455,  156 },
12508              { 0xDE469FBD99A05FE3,   481,  164 },
12509              { 0xA59BC234DB398C25,   508,  172 },
12510              { 0xF6C69A72A3989F5C,   534,  180 },
12511              { 0xB7DCBF5354E9BECE,   561,  188 },
12512              { 0x88FCF317F22241E2,   588,  196 },
12513              { 0xCC20CE9BD35C78A5,   614,  204 },
12514              { 0x98165AF37B2153DF,   641,  212 },
12515              { 0xE2A0B5DC971F303A,   667,  220 },
12516              { 0xA8D9D1535CE3B396,   694,  228 },
12517              { 0xFB9B7CD9A4A7443C,   720,  236 },
12518              { 0xBB764C4CA7A44410,   747,  244 },
12519              { 0x8BAB8EEFB6409C1A,   774,  252 },
12520              { 0xD01FEF10A657842C,   800,  260 },
12521              { 0x9B10A4E5E9913129,   827,  268 },
12522              { 0xE7109BFBA19C0C9D,   853,  276 },
12523              { 0xAC2820D9623BF429,   880,  284 },
12524              { 0x80444B5E7AA7CF85,   907,  292 },
12525              { 0xBF21E44003ACDD2D,   933,  300 },
12526              { 0x8E679C2F5E44FF8F,   960,  308 },
12527              { 0xD433179D9C8CB841,   986,  316 },
12528              { 0x9E19DB92B4E31BA9,  1013,  324 },
12529          }
12530      };
12531      JSON_ASSERT(e >= -1500);
12532      JSON_ASSERT(e <=  1500);
12533      const int f = kAlpha - e - 1;
12534      const int k = (f * 78913) / (1 << 18) + static_cast<int>(f > 0);
12535      const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
12536      JSON_ASSERT(index >= 0);
12537      JSON_ASSERT(static_cast<std::size_t>(index) < kCachedPowers.size());
12538      const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
12539      JSON_ASSERT(kAlpha <= cached.e + e + 64);
12540      JSON_ASSERT(kGamma >= cached.e + e + 64);
12541      return cached;
12542  }
12543  inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
12544  {
12545      if (n >= 1000000000)
12546      {
12547          pow10 = 1000000000;
12548          return 10;
12549      }
12550      if (n >= 100000000)
12551      {
12552          pow10 = 100000000;
12553          return  9;
12554      }
12555      if (n >= 10000000)
12556      {
12557          pow10 = 10000000;
12558          return  8;
12559      }
12560      if (n >= 1000000)
12561      {
12562          pow10 = 1000000;
12563          return  7;
12564      }
12565      if (n >= 100000)
12566      {
12567          pow10 = 100000;
12568          return  6;
12569      }
12570      if (n >= 10000)
12571      {
12572          pow10 = 10000;
12573          return  5;
12574      }
12575      if (n >= 1000)
12576      {
12577          pow10 = 1000;
12578          return  4;
12579      }
12580      if (n >= 100)
12581      {
12582          pow10 = 100;
12583          return  3;
12584      }
12585      if (n >= 10)
12586      {
12587          pow10 = 10;
12588          return  2;
12589      }
12590      pow10 = 1;
12591      return 1;
12592  }
12593  inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
12594                           std::uint64_t rest, std::uint64_t ten_k)
12595  {
12596      JSON_ASSERT(len >= 1);
12597      JSON_ASSERT(dist <= delta);
12598      JSON_ASSERT(rest <= delta);
12599      JSON_ASSERT(ten_k > 0);
12600      while (rest < dist
12601              && delta - rest >= ten_k
12602              && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
12603      {
12604          JSON_ASSERT(buf[len - 1] != '0');
12605          buf[len - 1]--;
12606          rest += ten_k;
12607      }
12608  }
12609  inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
12610                               diyfp M_minus, diyfp w, diyfp M_plus)
12611  {
12612      static_assert(kAlpha >= -60, "internal error");
12613      static_assert(kGamma <= -32, "internal error");
12614      JSON_ASSERT(M_plus.e >= kAlpha);
12615      JSON_ASSERT(M_plus.e <= kGamma);
12616      std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; 
12617      std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; 
12618      const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);
12619      auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); 
12620      std::uint64_t p2 = M_plus.f & (one.f - 1);                    
12621      JSON_ASSERT(p1 > 0);
12622      std::uint32_t pow10{};
12623      const int k = find_largest_pow10(p1, pow10);
12624      int n = k;
12625      while (n > 0)
12626      {
12627          const std::uint32_t d = p1 / pow10;  
12628          const std::uint32_t r = p1 % pow10;  
12629          JSON_ASSERT(d <= 9);
12630          buffer[length++] = static_cast<char>('0' + d); 
12631          p1 = r;
12632          n--;
12633          const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
12634          if (rest <= delta)
12635          {
12636              decimal_exponent += n;
12637              const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
12638              grisu2_round(buffer, length, dist, delta, rest, ten_n);
12639              return;
12640          }
12641          pow10 /= 10;
12642      }
12643      JSON_ASSERT(p2 > delta);
12644      int m = 0;
12645      for (;;)
12646      {
12647          JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
12648          p2 *= 10;
12649          const std::uint64_t d = p2 >> -one.e;     
12650          const std::uint64_t r = p2 & (one.f - 1); 
12651          JSON_ASSERT(d <= 9);
12652          buffer[length++] = static_cast<char>('0' + d); 
12653          p2 = r;
12654          m++;
12655          delta *= 10;
12656          dist  *= 10;
12657          if (p2 <= delta)
12658          {
12659              break;
12660          }
12661      }
12662      decimal_exponent -= m;
12663      const std::uint64_t ten_m = one.f;
12664      grisu2_round(buffer, length, dist, delta, p2, ten_m);
12665  }
12666  JSON_HEDLEY_NON_NULL(1)
12667  inline void grisu2(char* buf, int& len, int& decimal_exponent,
12668                     diyfp m_minus, diyfp v, diyfp m_plus)
12669  {
12670      JSON_ASSERT(m_plus.e == m_minus.e);
12671      JSON_ASSERT(m_plus.e == v.e);
12672      const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);
12673      const diyfp c_minus_k(cached.f, cached.e); 
12674      const diyfp w       = diyfp::mul(v,       c_minus_k);
12675      const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
12676      const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);
12677      const diyfp M_minus(w_minus.f + 1, w_minus.e);
12678      const diyfp M_plus (w_plus.f  - 1, w_plus.e );
12679      decimal_exponent = -cached.k; 
12680      grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
12681  }
12682  template<typename FloatType>
12683  JSON_HEDLEY_NON_NULL(1)
12684  void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
12685  {
12686      static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
12687                    "internal error: not enough precision");
12688      JSON_ASSERT(std::isfinite(value));
12689      JSON_ASSERT(value > 0);
12690  #if 0
12691      const boundaries w = compute_boundaries(static_cast<double>(value));
12692  #else
12693      const boundaries w = compute_boundaries(value);
12694  #endif
12695      grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
12696  }
12697  JSON_HEDLEY_NON_NULL(1)
12698  JSON_HEDLEY_RETURNS_NON_NULL
12699  inline char* append_exponent(char* buf, int e)
12700  {
12701      JSON_ASSERT(e > -1000);
12702      JSON_ASSERT(e <  1000);
12703      if (e < 0)
12704      {
12705          e = -e;
12706          *buf++ = '-';
12707      }
12708      else
12709      {
12710          *buf++ = '+';
12711      }
12712      auto k = static_cast<std::uint32_t>(e);
12713      if (k < 10)
12714      {
12715          *buf++ = '0';
12716          *buf++ = static_cast<char>('0' + k);
12717      }
12718      else if (k < 100)
12719      {
12720          *buf++ = static_cast<char>('0' + k / 10);
12721          k %= 10;
12722          *buf++ = static_cast<char>('0' + k);
12723      }
12724      else
12725      {
12726          *buf++ = static_cast<char>('0' + k / 100);
12727          k %= 100;
12728          *buf++ = static_cast<char>('0' + k / 10);
12729          k %= 10;
12730          *buf++ = static_cast<char>('0' + k);
12731      }
12732      return buf;
12733  }
12734  JSON_HEDLEY_NON_NULL(1)
12735  JSON_HEDLEY_RETURNS_NON_NULL
12736  inline char* format_buffer(char* buf, int len, int decimal_exponent,
12737                             int min_exp, int max_exp)
12738  {
12739      JSON_ASSERT(min_exp < 0);
12740      JSON_ASSERT(max_exp > 0);
12741      const int k = len;
12742      const int n = len + decimal_exponent;
12743      if (k <= n && n <= max_exp)
12744      {
12745          std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
12746          buf[n + 0] = '.';
12747          buf[n + 1] = '0';
12748          return buf + (static_cast<size_t>(n) + 2);
12749      }
12750      if (0 < n && n <= max_exp)
12751      {
12752          JSON_ASSERT(k > n);
12753          std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
12754          buf[n] = '.';
12755          return buf + (static_cast<size_t>(k) + 1U);
12756      }
12757      if (min_exp < n && n <= 0)
12758      {
12759          std::memmove(buf + (2 + static_cast<size_t>(-n)), buf, static_cast<size_t>(k));
12760          buf[0] = '0';
12761          buf[1] = '.';
12762          std::memset(buf + 2, '0', static_cast<size_t>(-n));
12763          return buf + (2U + static_cast<size_t>(-n) + static_cast<size_t>(k));
12764      }
12765      if (k == 1)
12766      {
12767          buf += 1;
12768      }
12769      else
12770      {
12771          std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
12772          buf[1] = '.';
12773          buf += 1 + static_cast<size_t>(k);
12774      }
12775      *buf++ = 'e';
12776      return append_exponent(buf, n - 1);
12777  }
12778  }  
12779  template<typename FloatType>
12780  JSON_HEDLEY_NON_NULL(1, 2)
12781  JSON_HEDLEY_RETURNS_NON_NULL
12782  char* to_chars(char* first, const char* last, FloatType value)
12783  {
12784      static_cast<void>(last); 
12785      JSON_ASSERT(std::isfinite(value));
12786      if (std::signbit(value))
12787      {
12788          value = -value;
12789          *first++ = '-';
12790      }
12791  #ifdef __GNUC__
12792  #pragma GCC diagnostic push
12793  #pragma GCC diagnostic ignored "-Wfloat-equal"
12794  #endif
12795      if (value == 0) 
12796      {
12797          *first++ = '0';
12798          *first++ = '.';
12799          *first++ = '0';
12800          return first;
12801      }
12802  #ifdef __GNUC__
12803  #pragma GCC diagnostic pop
12804  #endif
12805      JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);
12806      int len = 0;
12807      int decimal_exponent = 0;
12808      dtoa_impl::grisu2(first, len, decimal_exponent, value);
12809      JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);
12810      constexpr int kMinExp = -4;
12811      constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;
12812      JSON_ASSERT(last - first >= kMaxExp + 2);
12813      JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
12814      JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);
12815      return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
12816  }
12817  }  
12818  NLOHMANN_JSON_NAMESPACE_END
12819  NLOHMANN_JSON_NAMESPACE_BEGIN
12820  namespace detail
12821  {
12822  enum class error_handler_t
12823  {
12824      strict,  
12825      replace, 
12826      ignore   
12827  };
12828  template<typename BasicJsonType>
12829  class serializer
12830  {
12831      using string_t = typename BasicJsonType::string_t;
12832      using number_float_t = typename BasicJsonType::number_float_t;
12833      using number_integer_t = typename BasicJsonType::number_integer_t;
12834      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
12835      using binary_char_t = typename BasicJsonType::binary_t::value_type;
12836      static constexpr std::uint8_t UTF8_ACCEPT = 0;
12837      static constexpr std::uint8_t UTF8_REJECT = 1;
12838    public:
12839      serializer(output_adapter_t<char> s, const char ichar,
12840                 error_handler_t error_handler_ = error_handler_t::strict)
12841          : o(std::move(s))
12842          , loc(std::localeconv())
12843          , thousands_sep(loc->thousands_sep == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))
12844          , decimal_point(loc->decimal_point == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->decimal_point)))
12845          , indent_char(ichar)
12846          , indent_string(512, indent_char)
12847          , error_handler(error_handler_)
12848      {}
12849      serializer(const serializer&) = delete;
12850      serializer& operator=(const serializer&) = delete;
12851      serializer(serializer&&) = delete;
12852      serializer& operator=(serializer&&) = delete;
12853      ~serializer() = default;
12854      void dump(const BasicJsonType& val,
12855                const bool pretty_print,
12856                const bool ensure_ascii,
12857                const unsigned int indent_step,
12858                const unsigned int current_indent = 0)
12859      {
12860          switch (val.m_type)
12861          {
12862              case value_t::object:
12863              {
12864                  if (val.m_value.object->empty())
12865                  {
12866                      o->write_characters("{}", 2);
12867                      return;
12868                  }
12869                  if (pretty_print)
12870                  {
12871                      o->write_characters("{\n", 2);
12872                      const auto new_indent = current_indent + indent_step;
12873                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
12874                      {
12875                          indent_string.resize(indent_string.size() * 2, ' ');
12876                      }
12877                      auto i = val.m_value.object->cbegin();
12878                      for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
12879                      {
12880                          o->write_characters(indent_string.c_str(), new_indent);
12881                          o->write_character('\"');
12882                          dump_escaped(i->first, ensure_ascii);
12883                          o->write_characters("\": ", 3);
12884                          dump(i->second, true, ensure_ascii, indent_step, new_indent);
12885                          o->write_characters(",\n", 2);
12886                      }
12887                      JSON_ASSERT(i != val.m_value.object->cend());
12888                      JSON_ASSERT(std::next(i) == val.m_value.object->cend());
12889                      o->write_characters(indent_string.c_str(), new_indent);
12890                      o->write_character('\"');
12891                      dump_escaped(i->first, ensure_ascii);
12892                      o->write_characters("\": ", 3);
12893                      dump(i->second, true, ensure_ascii, indent_step, new_indent);
12894                      o->write_character('\n');
12895                      o->write_characters(indent_string.c_str(), current_indent);
12896                      o->write_character('}');
12897                  }
12898                  else
12899                  {
12900                      o->write_character('{');
12901                      auto i = val.m_value.object->cbegin();
12902                      for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
12903                      {
12904                          o->write_character('\"');
12905                          dump_escaped(i->first, ensure_ascii);
12906                          o->write_characters("\":", 2);
12907                          dump(i->second, false, ensure_ascii, indent_step, current_indent);
12908                          o->write_character(',');
12909                      }
12910                      JSON_ASSERT(i != val.m_value.object->cend());
12911                      JSON_ASSERT(std::next(i) == val.m_value.object->cend());
12912                      o->write_character('\"');
12913                      dump_escaped(i->first, ensure_ascii);
12914                      o->write_characters("\":", 2);
12915                      dump(i->second, false, ensure_ascii, indent_step, current_indent);
12916                      o->write_character('}');
12917                  }
12918                  return;
12919              }
12920              case value_t::array:
12921              {
12922                  if (val.m_value.array->empty())
12923                  {
12924                      o->write_characters("[]", 2);
12925                      return;
12926                  }
12927                  if (pretty_print)
12928                  {
12929                      o->write_characters("[\n", 2);
12930                      const auto new_indent = current_indent + indent_step;
12931                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
12932                      {
12933                          indent_string.resize(indent_string.size() * 2, ' ');
12934                      }
12935                      for (auto i = val.m_value.array->cbegin();
12936                              i != val.m_value.array->cend() - 1; ++i)
12937                      {
12938                          o->write_characters(indent_string.c_str(), new_indent);
12939                          dump(*i, true, ensure_ascii, indent_step, new_indent);
12940                          o->write_characters(",\n", 2);
12941                      }
12942                      JSON_ASSERT(!val.m_value.array->empty());
12943                      o->write_characters(indent_string.c_str(), new_indent);
12944                      dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);
12945                      o->write_character('\n');
12946                      o->write_characters(indent_string.c_str(), current_indent);
12947                      o->write_character(']');
12948                  }
12949                  else
12950                  {
12951                      o->write_character('[');
12952                      for (auto i = val.m_value.array->cbegin();
12953                              i != val.m_value.array->cend() - 1; ++i)
12954                      {
12955                          dump(*i, false, ensure_ascii, indent_step, current_indent);
12956                          o->write_character(',');
12957                      }
12958                      JSON_ASSERT(!val.m_value.array->empty());
12959                      dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);
12960                      o->write_character(']');
12961                  }
12962                  return;
12963              }
12964              case value_t::string:
12965              {
12966                  o->write_character('\"');
12967                  dump_escaped(*val.m_value.string, ensure_ascii);
12968                  o->write_character('\"');
12969                  return;
12970              }
12971              case value_t::binary:
12972              {
12973                  if (pretty_print)
12974                  {
12975                      o->write_characters("{\n", 2);
12976                      const auto new_indent = current_indent + indent_step;
12977                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
12978                      {
12979                          indent_string.resize(indent_string.size() * 2, ' ');
12980                      }
12981                      o->write_characters(indent_string.c_str(), new_indent);
12982                      o->write_characters("\"bytes\": [", 10);
12983                      if (!val.m_value.binary->empty())
12984                      {
12985                          for (auto i = val.m_value.binary->cbegin();
12986                                  i != val.m_value.binary->cend() - 1; ++i)
12987                          {
12988                              dump_integer(*i);
12989                              o->write_characters(", ", 2);
12990                          }
12991                          dump_integer(val.m_value.binary->back());
12992                      }
12993                      o->write_characters("],\n", 3);
12994                      o->write_characters(indent_string.c_str(), new_indent);
12995                      o->write_characters("\"subtype\": ", 11);
12996                      if (val.m_value.binary->has_subtype())
12997                      {
12998                          dump_integer(val.m_value.binary->subtype());
12999                      }
13000                      else
13001                      {
13002                          o->write_characters("null", 4);
13003                      }
13004                      o->write_character('\n');
13005                      o->write_characters(indent_string.c_str(), current_indent);
13006                      o->write_character('}');
13007                  }
13008                  else
13009                  {
13010                      o->write_characters("{\"bytes\":[", 10);
13011                      if (!val.m_value.binary->empty())
13012                      {
13013                          for (auto i = val.m_value.binary->cbegin();
13014                                  i != val.m_value.binary->cend() - 1; ++i)
13015                          {
13016                              dump_integer(*i);
13017                              o->write_character(',');
13018                          }
13019                          dump_integer(val.m_value.binary->back());
13020                      }
13021                      o->write_characters("],\"subtype\":", 12);
13022                      if (val.m_value.binary->has_subtype())
13023                      {
13024                          dump_integer(val.m_value.binary->subtype());
13025                          o->write_character('}');
13026                      }
13027                      else
13028                      {
13029                          o->write_characters("null}", 5);
13030                      }
13031                  }
13032                  return;
13033              }
13034              case value_t::boolean:
13035              {
13036                  if (val.m_value.boolean)
13037                  {
13038                      o->write_characters("true", 4);
13039                  }
13040                  else
13041                  {
13042                      o->write_characters("false", 5);
13043                  }
13044                  return;
13045              }
13046              case value_t::number_integer:
13047              {
13048                  dump_integer(val.m_value.number_integer);
13049                  return;
13050              }
13051              case value_t::number_unsigned:
13052              {
13053                  dump_integer(val.m_value.number_unsigned);
13054                  return;
13055              }
13056              case value_t::number_float:
13057              {
13058                  dump_float(val.m_value.number_float);
13059                  return;
13060              }
13061              case value_t::discarded:
13062              {
13063                  o->write_characters("<discarded>", 11);
13064                  return;
13065              }
13066              case value_t::null:
13067              {
13068                  o->write_characters("null", 4);
13069                  return;
13070              }
13071              default:            
13072                  JSON_ASSERT(false); 
13073          }
13074      }
13075    JSON_PRIVATE_UNLESS_TESTED:
13076      void dump_escaped(const string_t& s, const bool ensure_ascii)
13077      {
13078          std::uint32_t codepoint{};
13079          std::uint8_t state = UTF8_ACCEPT;
13080          std::size_t bytes = 0;  
13081          std::size_t bytes_after_last_accept = 0;
13082          std::size_t undumped_chars = 0;
13083          for (std::size_t i = 0; i < s.size(); ++i)
13084          {
13085              const auto byte = static_cast<std::uint8_t>(s[i]);
13086              switch (decode(state, codepoint, byte))
13087              {
13088                  case UTF8_ACCEPT:  
13089                  {
13090                      switch (codepoint)
13091                      {
13092                          case 0x08: 
13093                          {
13094                              string_buffer[bytes++] = '\\';
13095                              string_buffer[bytes++] = 'b';
13096                              break;
13097                          }
13098                          case 0x09: 
13099                          {
13100                              string_buffer[bytes++] = '\\';
13101                              string_buffer[bytes++] = 't';
13102                              break;
13103                          }
13104                          case 0x0A: 
13105                          {
13106                              string_buffer[bytes++] = '\\';
13107                              string_buffer[bytes++] = 'n';
13108                              break;
13109                          }
13110                          case 0x0C: 
13111                          {
13112                              string_buffer[bytes++] = '\\';
13113                              string_buffer[bytes++] = 'f';
13114                              break;
13115                          }
13116                          case 0x0D: 
13117                          {
13118                              string_buffer[bytes++] = '\\';
13119                              string_buffer[bytes++] = 'r';
13120                              break;
13121                          }
13122                          case 0x22: 
13123                          {
13124                              string_buffer[bytes++] = '\\';
13125                              string_buffer[bytes++] = '\"';
13126                              break;
13127                          }
13128                          case 0x5C: 
13129                          {
13130                              string_buffer[bytes++] = '\\';
13131                              string_buffer[bytes++] = '\\';
13132                              break;
13133                          }
13134                          default:
13135                          {
13136                              if ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))
13137                              {
13138                                  if (codepoint <= 0xFFFF)
13139                                  {
13140                                      static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
13141                                                                        static_cast<std::uint16_t>(codepoint)));
13142                                      bytes += 6;
13143                                  }
13144                                  else
13145                                  {
13146                                      static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
13147                                                                        static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
13148                                                                        static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu))));
13149                                      bytes += 12;
13150                                  }
13151                              }
13152                              else
13153                              {
13154                                  string_buffer[bytes++] = s[i];
13155                              }
13156                              break;
13157                          }
13158                      }
13159                      if (string_buffer.size() - bytes < 13)
13160                      {
13161                          o->write_characters(string_buffer.data(), bytes);
13162                          bytes = 0;
13163                      }
13164                      bytes_after_last_accept = bytes;
13165                      undumped_chars = 0;
13166                      break;
13167                  }
13168                  case UTF8_REJECT:  
13169                  {
13170                      switch (error_handler)
13171                      {
13172                          case error_handler_t::strict:
13173                          {
13174                              JSON_THROW(type_error::create(316, concat("invalid UTF-8 byte at index ", std::to_string(i), ": 0x", hex_bytes(byte | 0)), nullptr));
13175                          }
13176                          case error_handler_t::ignore:
13177                          case error_handler_t::replace:
13178                          {
13179                              if (undumped_chars > 0)
13180                              {
13181                                  --i;
13182                              }
13183                              bytes = bytes_after_last_accept;
13184                              if (error_handler == error_handler_t::replace)
13185                              {
13186                                  if (ensure_ascii)
13187                                  {
13188                                      string_buffer[bytes++] = '\\';
13189                                      string_buffer[bytes++] = 'u';
13190                                      string_buffer[bytes++] = 'f';
13191                                      string_buffer[bytes++] = 'f';
13192                                      string_buffer[bytes++] = 'f';
13193                                      string_buffer[bytes++] = 'd';
13194                                  }
13195                                  else
13196                                  {
13197                                      string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
13198                                      string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
13199                                      string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
13200                                  }
13201                                  if (string_buffer.size() - bytes < 13)
13202                                  {
13203                                      o->write_characters(string_buffer.data(), bytes);
13204                                      bytes = 0;
13205                                  }
13206                                  bytes_after_last_accept = bytes;
13207                              }
13208                              undumped_chars = 0;
13209                              state = UTF8_ACCEPT;
13210                              break;
13211                          }
13212                          default:            
13213                              JSON_ASSERT(false); 
13214                      }
13215                      break;
13216                  }
13217                  default:  
13218                  {
13219                      if (!ensure_ascii)
13220                      {
13221                          string_buffer[bytes++] = s[i];
13222                      }
13223                      ++undumped_chars;
13224                      break;
13225                  }
13226              }
13227          }
13228          if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
13229          {
13230              if (bytes > 0)
13231              {
13232                  o->write_characters(string_buffer.data(), bytes);
13233              }
13234          }
13235          else
13236          {
13237              switch (error_handler)
13238              {
13239                  case error_handler_t::strict:
13240                  {
13241                      JSON_THROW(type_error::create(316, concat("incomplete UTF-8 string; last byte: 0x", hex_bytes(static_cast<std::uint8_t>(s.back() | 0))), nullptr));
13242                  }
13243                  case error_handler_t::ignore:
13244                  {
13245                      o->write_characters(string_buffer.data(), bytes_after_last_accept);
13246                      break;
13247                  }
13248                  case error_handler_t::replace:
13249                  {
13250                      o->write_characters(string_buffer.data(), bytes_after_last_accept);
13251                      if (ensure_ascii)
13252                      {
13253                          o->write_characters("\\ufffd", 6);
13254                      }
13255                      else
13256                      {
13257                          o->write_characters("\xEF\xBF\xBD", 3);
13258                      }
13259                      break;
13260                  }
13261                  default:            
13262                      JSON_ASSERT(false); 
13263              }
13264          }
13265      }
13266    private:
13267      inline unsigned int count_digits(number_unsigned_t x) noexcept
13268      {
13269          unsigned int n_digits = 1;
13270          for (;;)
13271          {
13272              if (x < 10)
13273              {
13274                  return n_digits;
13275              }
13276              if (x < 100)
13277              {
13278                  return n_digits + 1;
13279              }
13280              if (x < 1000)
13281              {
13282                  return n_digits + 2;
13283              }
13284              if (x < 10000)
13285              {
13286                  return n_digits + 3;
13287              }
13288              x = x / 10000u;
13289              n_digits += 4;
13290          }
13291      }
13292      static std::string hex_bytes(std::uint8_t byte)
13293      {
13294          std::string result = "FF";
13295          constexpr const char* nibble_to_hex = "0123456789ABCDEF";
13296          result[0] = nibble_to_hex[byte / 16];
13297          result[1] = nibble_to_hex[byte % 16];
13298          return result;
13299      }
13300      template <typename NumberType, enable_if_t<std::is_signed<NumberType>::value, int> = 0>
13301      bool is_negative_number(NumberType x)
13302      {
13303          return x < 0;
13304      }
13305      template < typename NumberType, enable_if_t <std::is_unsigned<NumberType>::value, int > = 0 >
13306      bool is_negative_number(NumberType &bsol;*unused*/)
13307      {
13308          return false;
13309      }
13310      template < typename NumberType, detail::enable_if_t <
13311                     std::is_integral<NumberType>::value ||
13312                     std::is_same<NumberType, number_unsigned_t>::value ||
13313                     std::is_same<NumberType, number_integer_t>::value ||
13314                     std::is_same<NumberType, binary_char_t>::value,
13315                     int > = 0 >
13316      void dump_integer(NumberType x)
13317      {
13318          static constexpr std::array<std::array<char, 2>, 100> digits_to_99
13319          {
13320              {
13321                  {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
13322                  {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
13323                  {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
13324                  {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
13325                  {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
13326                  {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
13327                  {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
13328                  {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
13329                  {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
13330                  {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
13331              }
13332          };
13333          if (x == 0)
13334          {
13335              o->write_character('0');
13336              return;
13337          }
13338          auto buffer_ptr = number_buffer.begin(); 
13339          number_unsigned_t abs_value;
13340          unsigned int n_chars{};
13341          if (is_negative_number(x))
13342          {
13343              *buffer_ptr = '-';
13344              abs_value = remove_sign(static_cast<number_integer_t>(x));
13345              n_chars = 1 + count_digits(abs_value);
13346          }
13347          else
13348          {
13349              abs_value = static_cast<number_unsigned_t>(x);
13350              n_chars = count_digits(abs_value);
13351          }
13352          JSON_ASSERT(n_chars < number_buffer.size() - 1);
13353          buffer_ptr += n_chars;
13354          while (abs_value >= 100)
13355          {
13356              const auto digits_index = static_cast<unsigned>((abs_value % 100));
13357              abs_value /= 100;
13358              *(--buffer_ptr) = digits_to_99[digits_index][1];
13359              *(--buffer_ptr) = digits_to_99[digits_index][0];
13360          }
13361          if (abs_value >= 10)
13362          {
13363              const auto digits_index = static_cast<unsigned>(abs_value);
13364              *(--buffer_ptr) = digits_to_99[digits_index][1];
13365              *(--buffer_ptr) = digits_to_99[digits_index][0];
13366          }
13367          else
13368          {
13369              *(--buffer_ptr) = static_cast<char>('0' + abs_value);
13370          }
13371          o->write_characters(number_buffer.data(), n_chars);
13372      }
13373      void dump_float(number_float_t x)
13374      {
13375          if (!std::isfinite(x))
13376          {
13377              o->write_characters("null", 4);
13378              return;
13379          }
13380          static constexpr bool is_ieee_single_or_double
13381              = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||
13382                (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);
13383          dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
13384      }
13385      void dump_float(number_float_t x, std::true_type &bsol;*is_ieee_single_or_double*/)
13386      {
13387          auto* begin = number_buffer.data();
13388          auto* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);
13389          o->write_characters(begin, static_cast<size_t>(end - begin));
13390      }
13391      void dump_float(number_float_t x, std::false_type &bsol;*is_ieee_single_or_double*/)
13392      {
13393          static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;
13394          std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);
13395          JSON_ASSERT(len > 0);
13396          JSON_ASSERT(static_cast<std::size_t>(len) < number_buffer.size());
13397          if (thousands_sep != '\0')
13398          {
13399              const auto end = std::remove(number_buffer.begin(), number_buffer.begin() + len, thousands_sep);
13400              std::fill(end, number_buffer.end(), '\0');
13401              JSON_ASSERT((end - number_buffer.begin()) <= len);
13402              len = (end - number_buffer.begin());
13403          }
13404          if (decimal_point != '\0' && decimal_point != '.')
13405          {
13406              const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
13407              if (dec_pos != number_buffer.end())
13408              {
13409                  *dec_pos = '.';
13410              }
13411          }
13412          o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));
13413          const bool value_is_int_like =
13414              std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
13415                           [](char c)
13416          {
13417              return c == '.' || c == 'e';
13418          });
13419          if (value_is_int_like)
13420          {
13421              o->write_characters(".0", 2);
13422          }
13423      }
13424      static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
13425      {
13426          static const std::array<std::uint8_t, 400> utf8d =
13427          {
13428              {
13429                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
13430                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
13431                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
13432                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
13433                  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
13434                  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
13435                  8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
13436                  0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, 
13437                  0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 
13438                  0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, 
13439                  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 
13440                  1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 
13441                  1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 
13442                  1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 
13443              }
13444          };
13445          JSON_ASSERT(byte < utf8d.size());
13446          const std::uint8_t type = utf8d[byte];
13447          codep = (state != UTF8_ACCEPT)
13448                  ? (byte & 0x3fu) | (codep << 6u)
13449                  : (0xFFu >> type) & (byte);
13450          std::size_t index = 256u + static_cast<size_t>(state) * 16u + static_cast<size_t>(type);
13451          JSON_ASSERT(index < 400);
13452          state = utf8d[index];
13453          return state;
13454      }
13455      number_unsigned_t remove_sign(number_unsigned_t x)
13456      {
13457          JSON_ASSERT(false); 
13458          return x; 
13459      }
13460      inline number_unsigned_t remove_sign(number_integer_t x) noexcept
13461      {
13462          JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)()); 
13463          return static_cast<number_unsigned_t>(-(x + 1)) + 1;
13464      }
13465    private:
13466      output_adapter_t<char> o = nullptr;
13467      std::array<char, 64> number_buffer{{}};
13468      const std::lconv* loc = nullptr;
13469      const char thousands_sep = '\0';
13470      const char decimal_point = '\0';
13471      std::array<char, 512> string_buffer{{}};
13472      const char indent_char;
13473      string_t indent_string;
13474      const error_handler_t error_handler;
13475  };
13476  }  
13477  NLOHMANN_JSON_NAMESPACE_END
13478  #include <functional> 
13479  #include <initializer_list> 
13480  #include <iterator> 
13481  #include <memory> 
13482  #include <stdexcept> 
13483  #include <type_traits> 
13484  #include <utility> 
13485  #include <vector> 
13486  NLOHMANN_JSON_NAMESPACE_BEGIN
13487  template <class Key, class T, class IgnoredLess = std::less<Key>,
13488            class Allocator = std::allocator<std::pair<const Key, T>>>
13489                    struct ordered_map : std::vector<std::pair<const Key, T>, Allocator>
13490  {
13491      using key_type = Key;
13492      using mapped_type = T;
13493      using Container = std::vector<std::pair<const Key, T>, Allocator>;
13494      using iterator = typename Container::iterator;
13495      using const_iterator = typename Container::const_iterator;
13496      using size_type = typename Container::size_type;
13497      using value_type = typename Container::value_type;
13498  #ifdef JSON_HAS_CPP_14
13499      using key_compare = std::equal_to<>;
13500  #else
13501      using key_compare = std::equal_to<Key>;
13502  #endif
13503      ordered_map() noexcept(noexcept(Container())) : Container{} {}
13504      explicit ordered_map(const Allocator& alloc) noexcept(noexcept(Container(alloc))) : Container{alloc} {}
13505      template <class It>
13506      ordered_map(It first, It last, const Allocator& alloc = Allocator())
13507          : Container{first, last, alloc} {}
13508      ordered_map(std::initializer_list<value_type> init, const Allocator& alloc = Allocator() )
13509          : Container{init, alloc} {}
13510      std::pair<iterator, bool> emplace(const key_type& key, T&& t)
13511      {
13512          for (auto it = this->begin(); it != this->end(); ++it)
13513          {
13514              if (m_compare(it->first, key))
13515              {
13516                  return {it, false};
13517              }
13518          }
13519          Container::emplace_back(key, std::forward<T>(t));
13520          return {std::prev(this->end()), true};
13521      }
13522      template<class KeyType, detail::enable_if_t<
13523                   detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
13524      std::pair<iterator, bool> emplace(KeyType && key, T && t)
13525      {
13526          for (auto it = this->begin(); it != this->end(); ++it)
13527          {
13528              if (m_compare(it->first, key))
13529              {
13530                  return {it, false};
13531              }
13532          }
13533          Container::emplace_back(std::forward<KeyType>(key), std::forward<T>(t));
13534          return {std::prev(this->end()), true};
13535      }
13536      T& operator[](const key_type& key)
13537      {
13538          return emplace(key, T{}).first->second;
13539      }
13540      template<class KeyType, detail::enable_if_t<
13541                   detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
13542      T & operator[](KeyType && key)
13543      {
13544          return emplace(std::forward<KeyType>(key), T{}).first->second;
13545      }
13546      const T& operator[](const key_type& key) const
13547      {
13548          return at(key);
13549      }
13550      template<class KeyType, detail::enable_if_t<
13551                   detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
13552      const T & operator[](KeyType && key) const
13553      {
13554          return at(std::forward<KeyType>(key));
13555      }
13556      T& at(const key_type& key)
13557      {
13558          for (auto it = this->begin(); it != this->end(); ++it)
13559          {
13560              if (m_compare(it->first, key))
13561              {
13562                  return it->second;
13563              }
13564          }
13565          JSON_THROW(std::out_of_range("key not found"));
13566      }
13567      template<class KeyType, detail::enable_if_t<
13568                   detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
13569      T & at(KeyType && key)
13570      {
13571          for (auto it = this->begin(); it != this->end(); ++it)
13572          {
13573              if (m_compare(it->first, key))
13574              {
13575                  return it->second;
13576              }
13577          }
13578          JSON_THROW(std::out_of_range("key not found"));
13579      }
13580      const T& at(const key_type& key) const
13581      {
13582          for (auto it = this->begin(); it != this->end(); ++it)
13583          {
13584              if (m_compare(it->first, key))
13585              {
13586                  return it->second;
13587              }
13588          }
13589          JSON_THROW(std::out_of_range("key not found"));
13590      }
13591      template<class KeyType, detail::enable_if_t<
13592                   detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
13593      const T & at(KeyType && key) const
13594      {
13595          for (auto it = this->begin(); it != this->end(); ++it)
13596          {
13597              if (m_compare(it->first, key))
13598              {
13599                  return it->second;
13600              }
13601          }
13602          JSON_THROW(std::out_of_range("key not found"));
13603      }
13604      size_type erase(const key_type& key)
13605      {
13606          for (auto it = this->begin(); it != this->end(); ++it)
13607          {
13608              if (m_compare(it->first, key))
13609              {
13610                  for (auto next = it; ++next != this->end(); ++it)
13611                  {
13612                      it->~value_type(); 
13613                      new (&*it) value_type{std::move(*next)};
13614                  }
13615                  Container::pop_back();
13616                  return 1;
13617              }
13618          }
13619          return 0;
13620      }
13621      template<class KeyType, detail::enable_if_t<
13622                   detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
13623      size_type erase(KeyType && key)
13624      {
13625          for (auto it = this->begin(); it != this->end(); ++it)
13626          {
13627              if (m_compare(it->first, key))
13628              {
13629                  for (auto next = it; ++next != this->end(); ++it)
13630                  {
13631                      it->~value_type(); 
13632                      new (&*it) value_type{std::move(*next)};
13633                  }
13634                  Container::pop_back();
13635                  return 1;
13636              }
13637          }
13638          return 0;
13639      }
13640      iterator erase(iterator pos)
13641      {
13642          return erase(pos, std::next(pos));
13643      }
13644      iterator erase(iterator first, iterator last)
13645      {
13646          if (first == last)
13647          {
13648              return first;
13649          }
13650          const auto elements_affected = std::distance(first, last);
13651          const auto offset = std::distance(Container::begin(), first);
13652          for (auto it = first; std::next(it, elements_affected) != Container::end(); ++it)
13653          {
13654              it->~value_type(); 
13655              new (&*it) value_type{std::move(*std::next(it, elements_affected))}; 
13656          }
13657          Container::resize(this->size() - static_cast<size_type>(elements_affected));
13658          return Container::begin() + offset;
13659      }
13660      size_type count(const key_type& key) const
13661      {
13662          for (auto it = this->begin(); it != this->end(); ++it)
13663          {
13664              if (m_compare(it->first, key))
13665              {
13666                  return 1;
13667              }
13668          }
13669          return 0;
13670      }
13671      template<class KeyType, detail::enable_if_t<
13672                   detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
13673      size_type count(KeyType && key) const
13674      {
13675          for (auto it = this->begin(); it != this->end(); ++it)
13676          {
13677              if (m_compare(it->first, key))
13678              {
13679                  return 1;
13680              }
13681          }
13682          return 0;
13683      }
13684      iterator find(const key_type& key)
13685      {
13686          for (auto it = this->begin(); it != this->end(); ++it)
13687          {
13688              if (m_compare(it->first, key))
13689              {
13690                  return it;
13691              }
13692          }
13693          return Container::end();
13694      }
13695      template<class KeyType, detail::enable_if_t<
13696                   detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
13697      iterator find(KeyType && key)
13698      {
13699          for (auto it = this->begin(); it != this->end(); ++it)
13700          {
13701              if (m_compare(it->first, key))
13702              {
13703                  return it;
13704              }
13705          }
13706          return Container::end();
13707      }
13708      const_iterator find(const key_type& key) const
13709      {
13710          for (auto it = this->begin(); it != this->end(); ++it)
13711          {
13712              if (m_compare(it->first, key))
13713              {
13714                  return it;
13715              }
13716          }
13717          return Container::end();
13718      }
13719      std::pair<iterator, bool> insert( value_type&& value )
13720      {
13721          return emplace(value.first, std::move(value.second));
13722      }
13723      std::pair<iterator, bool> insert( const value_type& value )
13724      {
13725          for (auto it = this->begin(); it != this->end(); ++it)
13726          {
13727              if (m_compare(it->first, value.first))
13728              {
13729                  return {it, false};
13730              }
13731          }
13732          Container::push_back(value);
13733          return {--this->end(), true};
13734      }
13735      template<typename InputIt>
13736      using require_input_iter = typename std::enable_if<std::is_convertible<typename std::iterator_traits<InputIt>::iterator_category,
13737              std::input_iterator_tag>::value>::type;
13738      template<typename InputIt, typename = require_input_iter<InputIt>>
13739      void insert(InputIt first, InputIt last)
13740      {
13741          for (auto it = first; it != last; ++it)
13742          {
13743              insert(*it);
13744          }
13745      }
13746  private:
13747      JSON_NO_UNIQUE_ADDRESS key_compare m_compare = key_compare();
13748  };
13749  NLOHMANN_JSON_NAMESPACE_END
13750  #if defined(JSON_HAS_CPP_17)
13751      #include <any>
13752      #include <string_view>
13753  #endif
13754  NLOHMANN_JSON_NAMESPACE_BEGIN
13755  NLOHMANN_BASIC_JSON_TPL_DECLARATION
13756  class basic_json 
13757  {
13758    private:
13759      template<detail::value_t> friend struct detail::external_constructor;
13760      template<typename>
13761      friend class ::nlohmann::json_pointer;
13762      template<typename BasicJsonType, typename InputType>
13763      friend class ::nlohmann::detail::parser;
13764      friend ::nlohmann::detail::serializer<basic_json>;
13765      template<typename BasicJsonType>
13766      friend class ::nlohmann::detail::iter_impl;
13767      template<typename BasicJsonType, typename CharType>
13768      friend class ::nlohmann::detail::binary_writer;
13769      template<typename BasicJsonType, typename InputType, typename SAX>
13770      friend class ::nlohmann::detail::binary_reader;
13771      template<typename BasicJsonType>
13772      friend class ::nlohmann::detail::json_sax_dom_parser;
13773      template<typename BasicJsonType>
13774      friend class ::nlohmann::detail::json_sax_dom_callback_parser;
13775      friend class ::nlohmann::detail::exception;
13776      using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
13777    JSON_PRIVATE_UNLESS_TESTED:
13778      using lexer = ::nlohmann::detail::lexer_base<basic_json>;
13779      template<typename InputAdapterType>
13780      static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(
13781          InputAdapterType adapter,
13782          detail::parser_callback_t<basic_json>cb = nullptr,
13783          const bool allow_exceptions = true,
13784          const bool ignore_comments = false
13785                                   )
13786      {
13787          return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),
13788                  std::move(cb), allow_exceptions, ignore_comments);
13789      }
13790    private:
13791      using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
13792      template<typename BasicJsonType>
13793      using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
13794      template<typename BasicJsonType>
13795      using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
13796      template<typename Iterator>
13797      using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
13798      template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;
13799      template<typename CharType>
13800      using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;
13801      template<typename InputType>
13802      using binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;
13803      template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;
13804    JSON_PRIVATE_UNLESS_TESTED:
13805      using serializer = ::nlohmann::detail::serializer<basic_json>;
13806    public:
13807      using value_t = detail::value_t;
13808      using json_pointer = ::nlohmann::json_pointer<StringType>;
13809      template<typename T, typename SFINAE>
13810      using json_serializer = JSONSerializer<T, SFINAE>;
13811      using error_handler_t = detail::error_handler_t;
13812      using cbor_tag_handler_t = detail::cbor_tag_handler_t;
13813      using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;
13814      using input_format_t = detail::input_format_t;
13815      using json_sax_t = json_sax<basic_json>;
13816      using exception = detail::exception;
13817      using parse_error = detail::parse_error;
13818      using invalid_iterator = detail::invalid_iterator;
13819      using type_error = detail::type_error;
13820      using out_of_range = detail::out_of_range;
13821      using other_error = detail::other_error;
13822      using value_type = basic_json;
13823      using reference = value_type&;
13824      using const_reference = const value_type&;
13825      using difference_type = std::ptrdiff_t;
13826      using size_type = std::size_t;
13827      using allocator_type = AllocatorType<basic_json>;
13828      using pointer = typename std::allocator_traits<allocator_type>::pointer;
13829      using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;
13830      using iterator = iter_impl<basic_json>;
13831      using const_iterator = iter_impl<const basic_json>;
13832      using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
13833      using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;
13834      static allocator_type get_allocator()
13835      {
13836          return allocator_type();
13837      }
13838      JSON_HEDLEY_WARN_UNUSED_RESULT
13839      static basic_json meta()
13840      {
13841          basic_json result;
13842          result["copyright"] = "(C) 2013-2022 Niels Lohmann";
13843          result["name"] = "JSON for Modern C++";
13844          result["url"] = "https:&bsol;&bsol;github.com/nlohmann/json";
13845          result["version"]["string"] =
13846              detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), '.',
13847                             std::to_string(NLOHMANN_JSON_VERSION_MINOR), '.',
13848                             std::to_string(NLOHMANN_JSON_VERSION_PATCH));
13849          result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
13850          result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
13851          result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;
13852  #ifdef _WIN32
13853          result["platform"] = "win32";
13854  #elif defined __linux__
13855          result["platform"] = "linux";
13856  #elif defined __APPLE__
13857          result["platform"] = "apple";
13858  #elif defined __unix__
13859          result["platform"] = "unix";
13860  #else
13861          result["platform"] = "unknown";
13862  #endif
13863  #if defined(__ICC) || defined(__INTEL_COMPILER)
13864          result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
13865  #elif defined(__clang__)
13866          result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
13867  #elif defined(__GNUC__) || defined(__GNUG__)
13868          result["compiler"] = {{"family", "gcc"}, {"version", detail::concat(
13869                      std::to_string(__GNUC__), '.',
13870                      std::to_string(__GNUC_MINOR__), '.',
13871                      std::to_string(__GNUC_PATCHLEVEL__))
13872              }
13873          };
13874  #elif defined(__HP_cc) || defined(__HP_aCC)
13875          result["compiler"] = "hp"
13876  #elif defined(__IBMCPP__)
13877          result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
13878  #elif defined(_MSC_VER)
13879          result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
13880  #elif defined(__PGI)
13881          result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
13882  #elif defined(__SUNPRO_CC)
13883          result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
13884  #else
13885          result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
13886  #endif
13887  #if defined(_MSVC_LANG)
13888          result["compiler"]["c++"] = std::to_string(_MSVC_LANG);
13889  #elif defined(__cplusplus)
13890          result["compiler"]["c++"] = std::to_string(__cplusplus);
13891  #else
13892          result["compiler"]["c++"] = "unknown";
13893  #endif
13894          return result;
13895      }
13896  #if defined(JSON_HAS_CPP_14)
13897      using default_object_comparator_t = std::less<>;
13898  #else
13899      using default_object_comparator_t = std::less<StringType>;
13900  #endif
13901      using object_t = ObjectType<StringType,
13902            basic_json,
13903            default_object_comparator_t,
13904            AllocatorType<std::pair<const StringType,
13905            basic_json>>>;
13906      using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;
13907      using string_t = StringType;
13908      using boolean_t = BooleanType;
13909      using number_integer_t = NumberIntegerType;
13910      using number_unsigned_t = NumberUnsignedType;
13911      using number_float_t = NumberFloatType;
13912      using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;
13913      using object_comparator_t = detail::actual_object_comparator_t<basic_json>;
13914    private:
13915      template<typename T, typename... Args>
13916      JSON_HEDLEY_RETURNS_NON_NULL
13917      static T* create(Args&& ... args)
13918      {
13919          AllocatorType<T> alloc;
13920          using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;
13921          auto deleter = [&](T * obj)
13922          {
13923              AllocatorTraits::deallocate(alloc, obj, 1);
13924          };
13925          std::unique_ptr<T, decltype(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);
13926          AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);
13927          JSON_ASSERT(obj != nullptr);
13928          return obj.release();
13929      }
13930    JSON_PRIVATE_UNLESS_TESTED:
13931      union json_value
13932      {
13933          object_t* object;
13934          array_t* array;
13935          string_t* string;
13936          binary_t* binary;
13937          boolean_t boolean;
13938          number_integer_t number_integer;
13939          number_unsigned_t number_unsigned;
13940          number_float_t number_float;
13941          json_value() = default;
13942          json_value(boolean_t v) noexcept : boolean(v) {}
13943          json_value(number_integer_t v) noexcept : number_integer(v) {}
13944          json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
13945          json_value(number_float_t v) noexcept : number_float(v) {}
13946          json_value(value_t t)
13947          {
13948              switch (t)
13949              {
13950                  case value_t::object:
13951                  {
13952                      object = create<object_t>();
13953                      break;
13954                  }
13955                  case value_t::array:
13956                  {
13957                      array = create<array_t>();
13958                      break;
13959                  }
13960                  case value_t::string:
13961                  {
13962                      string = create<string_t>("");
13963                      break;
13964                  }
13965                  case value_t::binary:
13966                  {
13967                      binary = create<binary_t>();
13968                      break;
13969                  }
13970                  case value_t::boolean:
13971                  {
13972                      boolean = static_cast<boolean_t>(false);
13973                      break;
13974                  }
13975                  case value_t::number_integer:
13976                  {
13977                      number_integer = static_cast<number_integer_t>(0);
13978                      break;
13979                  }
13980                  case value_t::number_unsigned:
13981                  {
13982                      number_unsigned = static_cast<number_unsigned_t>(0);
13983                      break;
13984                  }
13985                  case value_t::number_float:
13986                  {
13987                      number_float = static_cast<number_float_t>(0.0);
13988                      break;
13989                  }
13990                  case value_t::null:
13991                  {
13992                      object = nullptr;  
13993                      break;
13994                  }
13995                  case value_t::discarded:
13996                  default:
13997                  {
13998                      object = nullptr;  
13999                      if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
14000                      {
14001                          JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.11.2", nullptr)); 
14002                      }
14003                      break;
14004                  }
14005              }
14006          }
14007          json_value(const string_t& value) : string(create<string_t>(value)) {}
14008          json_value(string_t&& value) : string(create<string_t>(std::move(value))) {}
14009          json_value(const object_t& value) : object(create<object_t>(value)) {}
14010          json_value(object_t&& value) : object(create<object_t>(std::move(value))) {}
14011          json_value(const array_t& value) : array(create<array_t>(value)) {}
14012          json_value(array_t&& value) : array(create<array_t>(std::move(value))) {}
14013          json_value(const typename binary_t::container_type& value) : binary(create<binary_t>(value)) {}
14014          json_value(typename binary_t::container_type&& value) : binary(create<binary_t>(std::move(value))) {}
14015          json_value(const binary_t& value) : binary(create<binary_t>(value)) {}
14016          json_value(binary_t&& value) : binary(create<binary_t>(std::move(value))) {}
14017          void destroy(value_t t)
14018          {
14019              if (t == value_t::array || t == value_t::object)
14020              {
14021                  std::vector<basic_json> stack;
14022                  if (t == value_t::array)
14023                  {
14024                      stack.reserve(array->size());
14025                      std::move(array->begin(), array->end(), std::back_inserter(stack));
14026                  }
14027                  else
14028                  {
14029                      stack.reserve(object->size());
14030                      for (auto&& it : *object)
14031                      {
14032                          stack.push_back(std::move(it.second));
14033                      }
14034                  }
14035                  while (!stack.empty())
14036                  {
14037                      basic_json current_item(std::move(stack.back()));
14038                      stack.pop_back();
14039                      if (current_item.is_array())
14040                      {
14041                          std::move(current_item.m_value.array->begin(), current_item.m_value.array->end(), std::back_inserter(stack));
14042                          current_item.m_value.array->clear();
14043                      }
14044                      else if (current_item.is_object())
14045                      {
14046                          for (auto&& it : *current_item.m_value.object)
14047                          {
14048                              stack.push_back(std::move(it.second));
14049                          }
14050                          current_item.m_value.object->clear();
14051                      }
14052                  }
14053              }
14054              switch (t)
14055              {
14056                  case value_t::object:
14057                  {
14058                      AllocatorType<object_t> alloc;
14059                      std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
14060                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
14061                      break;
14062                  }
14063                  case value_t::array:
14064                  {
14065                      AllocatorType<array_t> alloc;
14066                      std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
14067                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
14068                      break;
14069                  }
14070                  case value_t::string:
14071                  {
14072                      AllocatorType<string_t> alloc;
14073                      std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
14074                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
14075                      break;
14076                  }
14077                  case value_t::binary:
14078                  {
14079                      AllocatorType<binary_t> alloc;
14080                      std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);
14081                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);
14082                      break;
14083                  }
14084                  case value_t::null:
14085                  case value_t::boolean:
14086                  case value_t::number_integer:
14087                  case value_t::number_unsigned:
14088                  case value_t::number_float:
14089                  case value_t::discarded:
14090                  default:
14091                  {
14092                      break;
14093                  }
14094              }
14095          }
14096      };
14097    private:
14098      void assert_invariant(bool check_parents = true) const noexcept
14099      {
14100          JSON_ASSERT(m_type != value_t::object || m_value.object != nullptr);
14101          JSON_ASSERT(m_type != value_t::array || m_value.array != nullptr);
14102          JSON_ASSERT(m_type != value_t::string || m_value.string != nullptr);
14103          JSON_ASSERT(m_type != value_t::binary || m_value.binary != nullptr);
14104  #if JSON_DIAGNOSTICS
14105          JSON_TRY
14106          {
14107              JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [this](const basic_json & j)
14108              {
14109                  return j.m_parent == this;
14110              }));
14111          }
14112          JSON_CATCH(...) {} 
14113  #endif
14114          static_cast<void>(check_parents);
14115      }
14116      void set_parents()
14117      {
14118  #if JSON_DIAGNOSTICS
14119          switch (m_type)
14120          {
14121              case value_t::array:
14122              {
14123                  for (auto& element : *m_value.array)
14124                  {
14125                      element.m_parent = this;
14126                  }
14127                  break;
14128              }
14129              case value_t::object:
14130              {
14131                  for (auto& element : *m_value.object)
14132                  {
14133                      element.second.m_parent = this;
14134                  }
14135                  break;
14136              }
14137              case value_t::null:
14138              case value_t::string:
14139              case value_t::boolean:
14140              case value_t::number_integer:
14141              case value_t::number_unsigned:
14142              case value_t::number_float:
14143              case value_t::binary:
14144              case value_t::discarded:
14145              default:
14146                  break;
14147          }
14148  #endif
14149      }
14150      iterator set_parents(iterator it, typename iterator::difference_type count_set_parents)
14151      {
14152  #if JSON_DIAGNOSTICS
14153          for (typename iterator::difference_type i = 0; i < count_set_parents; ++i)
14154          {
14155              (it + i)->m_parent = this;
14156          }
14157  #else
14158          static_cast<void>(count_set_parents);
14159  #endif
14160          return it;
14161      }
14162      reference set_parent(reference j, std::size_t old_capacity = static_cast<std::size_t>(-1))
14163      {
14164  #if JSON_DIAGNOSTICS
14165          if (old_capacity != static_cast<std::size_t>(-1))
14166          {
14167              JSON_ASSERT(type() == value_t::array);
14168              if (JSON_HEDLEY_UNLIKELY(m_value.array->capacity() != old_capacity))
14169              {
14170                  set_parents();
14171                  return j;
14172              }
14173          }
14174  #ifdef JSON_HEDLEY_MSVC_VERSION
14175  #pragma warning(push )
14176  #pragma warning(disable : 4127) 
14177  #endif
14178          if (detail::is_ordered_map<object_t>::value)
14179          {
14180              set_parents();
14181              return j;
14182          }
14183  #ifdef JSON_HEDLEY_MSVC_VERSION
14184  #pragma warning( pop )
14185  #endif
14186          j.m_parent = this;
14187  #else
14188          static_cast<void>(j);
14189          static_cast<void>(old_capacity);
14190  #endif
14191          return j;
14192      }
14193    public:
14194      using parse_event_t = detail::parse_event_t;
14195      using parser_callback_t = detail::parser_callback_t<basic_json>;
14196      basic_json(const value_t v)
14197          : m_type(v), m_value(v)
14198      {
14199          assert_invariant();
14200      }
14201      basic_json(std::nullptr_t = nullptr) noexcept 
14202          : basic_json(value_t::null)
14203      {
14204          assert_invariant();
14205      }
14206      template < typename CompatibleType,
14207                 typename U = detail::uncvref_t<CompatibleType>,
14208                 detail::enable_if_t <
14209                     !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, int > = 0 >
14210      basic_json(CompatibleType && val) noexcept(noexcept( 
14211                  JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
14212                                             std::forward<CompatibleType>(val))))
14213      {
14214          JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
14215          set_parents();
14216          assert_invariant();
14217      }
14218      template < typename BasicJsonType,
14219                 detail::enable_if_t <
14220                     detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, int > = 0 >
14221      basic_json(const BasicJsonType& val)
14222      {
14223          using other_boolean_t = typename BasicJsonType::boolean_t;
14224          using other_number_float_t = typename BasicJsonType::number_float_t;
14225          using other_number_integer_t = typename BasicJsonType::number_integer_t;
14226          using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
14227          using other_string_t = typename BasicJsonType::string_t;
14228          using other_object_t = typename BasicJsonType::object_t;
14229          using other_array_t = typename BasicJsonType::array_t;
14230          using other_binary_t = typename BasicJsonType::binary_t;
14231          switch (val.type())
14232          {
14233              case value_t::boolean:
14234                  JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
14235                  break;
14236              case value_t::number_float:
14237                  JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
14238                  break;
14239              case value_t::number_integer:
14240                  JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
14241                  break;
14242              case value_t::number_unsigned:
14243                  JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
14244                  break;
14245              case value_t::string:
14246                  JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
14247                  break;
14248              case value_t::object:
14249                  JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
14250                  break;
14251              case value_t::array:
14252                  JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
14253                  break;
14254              case value_t::binary:
14255                  JSONSerializer<other_binary_t>::to_json(*this, val.template get_ref<const other_binary_t&>());
14256                  break;
14257              case value_t::null:
14258                  *this = nullptr;
14259                  break;
14260              case value_t::discarded:
14261                  m_type = value_t::discarded;
14262                  break;
14263              default:            
14264                  JSON_ASSERT(false); 
14265          }
14266          JSON_ASSERT(m_type == val.type());
14267          set_parents();
14268          assert_invariant();
14269      }
14270      basic_json(initializer_list_t init,
14271                 bool type_deduction = true,
14272                 value_t manual_type = value_t::array)
14273      {
14274          bool is_an_object = std::all_of(init.begin(), init.end(),
14275                                          [](const detail::json_ref<basic_json>& element_ref)
14276          {
14277              return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[0].is_string();
14278          });
14279          if (!type_deduction)
14280          {
14281              if (manual_type == value_t::array)
14282              {
14283                  is_an_object = false;
14284              }
14285              if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))
14286              {
14287                  JSON_THROW(type_error::create(301, "cannot create object from initializer list", nullptr));
14288              }
14289          }
14290          if (is_an_object)
14291          {
14292              m_type = value_t::object;
14293              m_value = value_t::object;
14294              for (auto& element_ref : init)
14295              {
14296                  auto element = element_ref.moved_or_copied();
14297                  m_value.object->emplace(
14298                      std::move(*((*element.m_value.array)[0].m_value.string)),
14299                      std::move((*element.m_value.array)[1]));
14300              }
14301          }
14302          else
14303          {
14304              m_type = value_t::array;
14305              m_value.array = create<array_t>(init.begin(), init.end());
14306          }
14307          set_parents();
14308          assert_invariant();
14309      }
14310      JSON_HEDLEY_WARN_UNUSED_RESULT
14311      static basic_json binary(const typename binary_t::container_type& init)
14312      {
14313          auto res = basic_json();
14314          res.m_type = value_t::binary;
14315          res.m_value = init;
14316          return res;
14317      }
14318      JSON_HEDLEY_WARN_UNUSED_RESULT
14319      static basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype)
14320      {
14321          auto res = basic_json();
14322          res.m_type = value_t::binary;
14323          res.m_value = binary_t(init, subtype);
14324          return res;
14325      }
14326      JSON_HEDLEY_WARN_UNUSED_RESULT
14327      static basic_json binary(typename binary_t::container_type&& init)
14328      {
14329          auto res = basic_json();
14330          res.m_type = value_t::binary;
14331          res.m_value = std::move(init);
14332          return res;
14333      }
14334      JSON_HEDLEY_WARN_UNUSED_RESULT
14335      static basic_json binary(typename binary_t::container_type&& init, typename binary_t::subtype_type subtype)
14336      {
14337          auto res = basic_json();
14338          res.m_type = value_t::binary;
14339          res.m_value = binary_t(std::move(init), subtype);
14340          return res;
14341      }
14342      JSON_HEDLEY_WARN_UNUSED_RESULT
14343      static basic_json array(initializer_list_t init = {})
14344      {
14345          return basic_json(init, false, value_t::array);
14346      }
14347      JSON_HEDLEY_WARN_UNUSED_RESULT
14348      static basic_json object(initializer_list_t init = {})
14349      {
14350          return basic_json(init, false, value_t::object);
14351      }
14352      basic_json(size_type cnt, const basic_json& val)
14353          : m_type(value_t::array)
14354      {
14355          m_value.array = create<array_t>(cnt, val);
14356          set_parents();
14357          assert_invariant();
14358      }
14359      template < class InputIT, typename std::enable_if <
14360                     std::is_same<InputIT, typename basic_json_t::iterator>::value ||
14361                     std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int >::type = 0 >
14362      basic_json(InputIT first, InputIT last)
14363      {
14364          JSON_ASSERT(first.m_object != nullptr);
14365          JSON_ASSERT(last.m_object != nullptr);
14366          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
14367          {
14368              JSON_THROW(invalid_iterator::create(201, "iterators are not compatible", nullptr));
14369          }
14370          m_type = first.m_object->m_type;
14371          switch (m_type)
14372          {
14373              case value_t::boolean:
14374              case value_t::number_float:
14375              case value_t::number_integer:
14376              case value_t::number_unsigned:
14377              case value_t::string:
14378              {
14379                  if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
14380                                           || !last.m_it.primitive_iterator.is_end()))
14381                  {
14382                      JSON_THROW(invalid_iterator::create(204, "iterators out of range", first.m_object));
14383                  }
14384                  break;
14385              }
14386              case value_t::null:
14387              case value_t::object:
14388              case value_t::array:
14389              case value_t::binary:
14390              case value_t::discarded:
14391              default:
14392                  break;
14393          }
14394          switch (m_type)
14395          {
14396              case value_t::number_integer:
14397              {
14398                  m_value.number_integer = first.m_object->m_value.number_integer;
14399                  break;
14400              }
14401              case value_t::number_unsigned:
14402              {
14403                  m_value.number_unsigned = first.m_object->m_value.number_unsigned;
14404                  break;
14405              }
14406              case value_t::number_float:
14407              {
14408                  m_value.number_float = first.m_object->m_value.number_float;
14409                  break;
14410              }
14411              case value_t::boolean:
14412              {
14413                  m_value.boolean = first.m_object->m_value.boolean;
14414                  break;
14415              }
14416              case value_t::string:
14417              {
14418                  m_value = *first.m_object->m_value.string;
14419                  break;
14420              }
14421              case value_t::object:
14422              {
14423                  m_value.object = create<object_t>(first.m_it.object_iterator,
14424                                                    last.m_it.object_iterator);
14425                  break;
14426              }
14427              case value_t::array:
14428              {
14429                  m_value.array = create<array_t>(first.m_it.array_iterator,
14430                                                  last.m_it.array_iterator);
14431                  break;
14432              }
14433              case value_t::binary:
14434              {
14435                  m_value = *first.m_object->m_value.binary;
14436                  break;
14437              }
14438              case value_t::null:
14439              case value_t::discarded:
14440              default:
14441                  JSON_THROW(invalid_iterator::create(206, detail::concat("cannot construct with iterators from ", first.m_object->type_name()), first.m_object));
14442          }
14443          set_parents();
14444          assert_invariant();
14445      }
14446      template<typename JsonRef,
14447               detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,
14448                                   std::is_same<typename JsonRef::value_type, basic_json>>::value, int> = 0 >
14449      basic_json(const JsonRef& ref) : basic_json(ref.moved_or_copied()) {}
14450      basic_json(const basic_json& other)
14451          : m_type(other.m_type)
14452      {
14453          other.assert_invariant();
14454          switch (m_type)
14455          {
14456              case value_t::object:
14457              {
14458                  m_value = *other.m_value.object;
14459                  break;
14460              }
14461              case value_t::array:
14462              {
14463                  m_value = *other.m_value.array;
14464                  break;
14465              }
14466              case value_t::string:
14467              {
14468                  m_value = *other.m_value.string;
14469                  break;
14470              }
14471              case value_t::boolean:
14472              {
14473                  m_value = other.m_value.boolean;
14474                  break;
14475              }
14476              case value_t::number_integer:
14477              {
14478                  m_value = other.m_value.number_integer;
14479                  break;
14480              }
14481              case value_t::number_unsigned:
14482              {
14483                  m_value = other.m_value.number_unsigned;
14484                  break;
14485              }
14486              case value_t::number_float:
14487              {
14488                  m_value = other.m_value.number_float;
14489                  break;
14490              }
14491              case value_t::binary:
14492              {
14493                  m_value = *other.m_value.binary;
14494                  break;
14495              }
14496              case value_t::null:
14497              case value_t::discarded:
14498              default:
14499                  break;
14500          }
14501          set_parents();
14502          assert_invariant();
14503      }
14504      basic_json(basic_json&& other) noexcept
14505          : m_type(std::move(other.m_type)),
14506            m_value(std::move(other.m_value))
14507      {
14508          other.assert_invariant(false);
14509          other.m_type = value_t::null;
14510          other.m_value = {};
14511          set_parents();
14512          assert_invariant();
14513      }
14514      basic_json& operator=(basic_json other) noexcept (
14515          std::is_nothrow_move_constructible<value_t>::value&&
14516          std::is_nothrow_move_assignable<value_t>::value&&
14517          std::is_nothrow_move_constructible<json_value>::value&&
14518          std::is_nothrow_move_assignable<json_value>::value
14519      )
14520      {
14521          other.assert_invariant();
14522          using std::swap;
14523          swap(m_type, other.m_type);
14524          swap(m_value, other.m_value);
14525          set_parents();
14526          assert_invariant();
14527          return *this;
14528      }
14529      ~basic_json() noexcept
14530      {
14531          assert_invariant(false);
14532          m_value.destroy(m_type);
14533      }
14534    public:
14535      string_t dump(const int indent = -1,
14536                    const char indent_char = ' ',
14537                    const bool ensure_ascii = false,
14538                    const error_handler_t error_handler = error_handler_t::strict) const
14539      {
14540          string_t result;
14541          serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);
14542          if (indent >= 0)
14543          {
14544              s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
14545          }
14546          else
14547          {
14548              s.dump(*this, false, ensure_ascii, 0);
14549          }
14550          return result;
14551      }
14552      constexpr value_t type() const noexcept
14553      {
14554          return m_type;
14555      }
14556      constexpr bool is_primitive() const noexcept
14557      {
14558          return is_null() || is_string() || is_boolean() || is_number() || is_binary();
14559      }
14560      constexpr bool is_structured() const noexcept
14561      {
14562          return is_array() || is_object();
14563      }
14564      constexpr bool is_null() const noexcept
14565      {
14566          return m_type == value_t::null;
14567      }
14568      constexpr bool is_boolean() const noexcept
14569      {
14570          return m_type == value_t::boolean;
14571      }
14572      constexpr bool is_number() const noexcept
14573      {
14574          return is_number_integer() || is_number_float();
14575      }
14576      constexpr bool is_number_integer() const noexcept
14577      {
14578          return m_type == value_t::number_integer || m_type == value_t::number_unsigned;
14579      }
14580      constexpr bool is_number_unsigned() const noexcept
14581      {
14582          return m_type == value_t::number_unsigned;
14583      }
14584      constexpr bool is_number_float() const noexcept
14585      {
14586          return m_type == value_t::number_float;
14587      }
14588      constexpr bool is_object() const noexcept
14589      {
14590          return m_type == value_t::object;
14591      }
14592      constexpr bool is_array() const noexcept
14593      {
14594          return m_type == value_t::array;
14595      }
14596      constexpr bool is_string() const noexcept
14597      {
14598          return m_type == value_t::string;
14599      }
14600      constexpr bool is_binary() const noexcept
14601      {
14602          return m_type == value_t::binary;
14603      }
14604      constexpr bool is_discarded() const noexcept
14605      {
14606          return m_type == value_t::discarded;
14607      }
14608      constexpr operator value_t() const noexcept
14609      {
14610          return m_type;
14611      }
14612    private:
14613      boolean_t get_impl(boolean_t* &bsol;*unused*/) const
14614      {
14615          if (JSON_HEDLEY_LIKELY(is_boolean()))
14616          {
14617              return m_value.boolean;
14618          }
14619          JSON_THROW(type_error::create(302, detail::concat("type must be boolean, but is ", type_name()), this));
14620      }
14621      object_t* get_impl_ptr(object_t* &bsol;*unused*/) noexcept
14622      {
14623          return is_object() ? m_value.object : nullptr;
14624      }
14625      constexpr const object_t* get_impl_ptr(const object_t* &bsol;*unused*/) const noexcept
14626      {
14627          return is_object() ? m_value.object : nullptr;
14628      }
14629      array_t* get_impl_ptr(array_t* &bsol;*unused*/) noexcept
14630      {
14631          return is_array() ? m_value.array : nullptr;
14632      }
14633      constexpr const array_t* get_impl_ptr(const array_t* &bsol;*unused*/) const noexcept
14634      {
14635          return is_array() ? m_value.array : nullptr;
14636      }
14637      string_t* get_impl_ptr(string_t* &bsol;*unused*/) noexcept
14638      {
14639          return is_string() ? m_value.string : nullptr;
14640      }
14641      constexpr const string_t* get_impl_ptr(const string_t* &bsol;*unused*/) const noexcept
14642      {
14643          return is_string() ? m_value.string : nullptr;
14644      }
14645      boolean_t* get_impl_ptr(boolean_t* &bsol;*unused*/) noexcept
14646      {
14647          return is_boolean() ? &m_value.boolean : nullptr;
14648      }
14649      constexpr const boolean_t* get_impl_ptr(const boolean_t* &bsol;*unused*/) const noexcept
14650      {
14651          return is_boolean() ? &m_value.boolean : nullptr;
14652      }
14653      number_integer_t* get_impl_ptr(number_integer_t* &bsol;*unused*/) noexcept
14654      {
14655          return is_number_integer() ? &m_value.number_integer : nullptr;
14656      }
14657      constexpr const number_integer_t* get_impl_ptr(const number_integer_t* &bsol;*unused*/) const noexcept
14658      {
14659          return is_number_integer() ? &m_value.number_integer : nullptr;
14660      }
14661      number_unsigned_t* get_impl_ptr(number_unsigned_t* &bsol;*unused*/) noexcept
14662      {
14663          return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
14664      }
14665      constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* &bsol;*unused*/) const noexcept
14666      {
14667          return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
14668      }
14669      number_float_t* get_impl_ptr(number_float_t* &bsol;*unused*/) noexcept
14670      {
14671          return is_number_float() ? &m_value.number_float : nullptr;
14672      }
14673      constexpr const number_float_t* get_impl_ptr(const number_float_t* &bsol;*unused*/) const noexcept
14674      {
14675          return is_number_float() ? &m_value.number_float : nullptr;
14676      }
14677      binary_t* get_impl_ptr(binary_t* &bsol;*unused*/) noexcept
14678      {
14679          return is_binary() ? m_value.binary : nullptr;
14680      }
14681      constexpr const binary_t* get_impl_ptr(const binary_t* &bsol;*unused*/) const noexcept
14682      {
14683          return is_binary() ? m_value.binary : nullptr;
14684      }
14685      template<typename ReferenceType, typename ThisType>
14686      static ReferenceType get_ref_impl(ThisType& obj)
14687      {
14688          auto* ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();
14689          if (JSON_HEDLEY_LIKELY(ptr != nullptr))
14690          {
14691              return *ptr;
14692          }
14693          JSON_THROW(type_error::create(303, detail::concat("incompatible ReferenceType for get_ref, actual type is ", obj.type_name()), &obj));
14694      }
14695    public:
14696      template<typename PointerType, typename std::enable_if<
14697                   std::is_pointer<PointerType>::value, int>::type = 0>
14698      auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
14699      {
14700          return get_impl_ptr(static_cast<PointerType>(nullptr));
14701      }
14702      template < typename PointerType, typename std::enable_if <
14703                     std::is_pointer<PointerType>::value&&
14704                     std::is_const<typename std::remove_pointer<PointerType>::type>::value, int >::type = 0 >
14705      constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
14706      {
14707          return get_impl_ptr(static_cast<PointerType>(nullptr));
14708      }
14709    private:
14710      template < typename ValueType,
14711                 detail::enable_if_t <
14712                     detail::is_default_constructible<ValueType>::value&&
14713                     detail::has_from_json<basic_json_t, ValueType>::value,
14714                     int > = 0 >
14715      ValueType get_impl(detail::priority_tag<0> &bsol;*unused*/) const noexcept(noexcept(
14716                  JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
14717      {
14718          auto ret = ValueType();
14719          JSONSerializer<ValueType>::from_json(*this, ret);
14720          return ret;
14721      }
14722      template < typename ValueType,
14723                 detail::enable_if_t <
14724                     detail::has_non_default_from_json<basic_json_t, ValueType>::value,
14725                     int > = 0 >
14726      ValueType get_impl(detail::priority_tag<1> &bsol;*unused*/) const noexcept(noexcept(
14727                  JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))
14728      {
14729          return JSONSerializer<ValueType>::from_json(*this);
14730      }
14731      template < typename BasicJsonType,
14732                 detail::enable_if_t <
14733                     detail::is_basic_json<BasicJsonType>::value,
14734                     int > = 0 >
14735      BasicJsonType get_impl(detail::priority_tag<2> &bsol;*unused*/) const
14736      {
14737          return *this;
14738      }
14739      template<typename BasicJsonType,
14740               detail::enable_if_t<
14741                   std::is_same<BasicJsonType, basic_json_t>::value,
14742                   int> = 0>
14743      basic_json get_impl(detail::priority_tag<3> &bsol;*unused*/) const
14744      {
14745          return *this;
14746      }
14747      template<typename PointerType,
14748               detail::enable_if_t<
14749                   std::is_pointer<PointerType>::value,
14750                   int> = 0>
14751      constexpr auto get_impl(detail::priority_tag<4> &bsol;*unused*/) const noexcept
14752      -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
14753      {
14754          return get_ptr<PointerType>();
14755      }
14756    public:
14757      template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>>
14758  #if defined(JSON_HAS_CPP_14)
14759      constexpr
14760  #endif
14761      auto get() const noexcept(
14762      noexcept(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {})))
14763      -> decltype(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {}))
14764      {
14765          static_assert(!std::is_reference<ValueTypeCV>::value,
14766                        "get() cannot be used with reference types, you might want to use get_ref()");
14767          return get_impl<ValueType>(detail::priority_tag<4> {});
14768      }
14769      template<typename PointerType, typename std::enable_if<
14770                   std::is_pointer<PointerType>::value, int>::type = 0>
14771      auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
14772      {
14773          return get_ptr<PointerType>();
14774      }
14775      template < typename ValueType,
14776                 detail::enable_if_t <
14777                     !detail::is_basic_json<ValueType>::value&&
14778                     detail::has_from_json<basic_json_t, ValueType>::value,
14779                     int > = 0 >
14780      ValueType & get_to(ValueType& v) const noexcept(noexcept(
14781                  JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
14782      {
14783          JSONSerializer<ValueType>::from_json(*this, v);
14784          return v;
14785      }
14786      template<typename ValueType,
14787               detail::enable_if_t <
14788                   detail::is_basic_json<ValueType>::value,
14789                   int> = 0>
14790      ValueType & get_to(ValueType& v) const
14791      {
14792          v = *this;
14793          return v;
14794      }
14795      template <
14796          typename T, std::size_t N,
14797          typename Array = T (&)[N], 
14798          detail::enable_if_t <
14799              detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
14800      Array get_to(T (&v)[N]) const 
14801      noexcept(noexcept(JSONSerializer<Array>::from_json(
14802                            std::declval<const basic_json_t&>(), v)))
14803      {
14804          JSONSerializer<Array>::from_json(*this, v);
14805          return v;
14806      }
14807      template<typename ReferenceType, typename std::enable_if<
14808                   std::is_reference<ReferenceType>::value, int>::type = 0>
14809      ReferenceType get_ref()
14810      {
14811          return get_ref_impl<ReferenceType>(*this);
14812      }
14813      template < typename ReferenceType, typename std::enable_if <
14814                     std::is_reference<ReferenceType>::value&&
14815                     std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int >::type = 0 >
14816      ReferenceType get_ref() const
14817      {
14818          return get_ref_impl<ReferenceType>(*this);
14819      }
14820      template < typename ValueType, typename std::enable_if <
14821                     detail::conjunction <
14822                         detail::negation<std::is_pointer<ValueType>>,
14823                         detail::negation<std::is_same<ValueType, std::nullptr_t>>,
14824                         detail::negation<std::is_same<ValueType, detail::json_ref<basic_json>>>,
14825                                          detail::negation<std::is_same<ValueType, typename string_t::value_type>>,
14826                                          detail::negation<detail::is_basic_json<ValueType>>,
14827                                          detail::negation<std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>>,
14828  #if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))
14829                                                  detail::negation<std::is_same<ValueType, std::string_view>>,
14830  #endif
14831  #if defined(JSON_HAS_CPP_17)
14832                                                  detail::negation<std::is_same<ValueType, std::any>>,
14833  #endif
14834                                                  detail::is_detected_lazy<detail::get_template_function, const basic_json_t&, ValueType>
14835                                                  >::value, int >::type = 0 >
14836                                          JSON_EXPLICIT operator ValueType() const
14837      {
14838          return get<ValueType>();
14839      }
14840      binary_t& get_binary()
14841      {
14842          if (!is_binary())
14843          {
14844              JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
14845          }
14846          return *get_ptr<binary_t*>();
14847      }
14848      const binary_t& get_binary() const
14849      {
14850          if (!is_binary())
14851          {
14852              JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
14853          }
14854          return *get_ptr<const binary_t*>();
14855      }
14856      reference at(size_type idx)
14857      {
14858          if (JSON_HEDLEY_LIKELY(is_array()))
14859          {
14860              JSON_TRY
14861              {
14862                  return set_parent(m_value.array->at(idx));
14863              }
14864              JSON_CATCH (std::out_of_range&)
14865              {
14866                  JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
14867              }
14868          }
14869          else
14870          {
14871              JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
14872          }
14873      }
14874      const_reference at(size_type idx) const
14875      {
14876          if (JSON_HEDLEY_LIKELY(is_array()))
14877          {
14878              JSON_TRY
14879              {
14880                  return m_value.array->at(idx);
14881              }
14882              JSON_CATCH (std::out_of_range&)
14883              {
14884                  JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
14885              }
14886          }
14887          else
14888          {
14889              JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
14890          }
14891      }
14892      reference at(const typename object_t::key_type& key)
14893      {
14894          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14895          {
14896              JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
14897          }
14898          auto it = m_value.object->find(key);
14899          if (it == m_value.object->end())
14900          {
14901              JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
14902          }
14903          return set_parent(it->second);
14904      }
14905      template<class KeyType, detail::enable_if_t<
14906                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
14907      reference at(KeyType && key)
14908      {
14909          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14910          {
14911              JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
14912          }
14913          auto it = m_value.object->find(std::forward<KeyType>(key));
14914          if (it == m_value.object->end())
14915          {
14916              JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
14917          }
14918          return set_parent(it->second);
14919      }
14920      const_reference at(const typename object_t::key_type& key) const
14921      {
14922          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14923          {
14924              JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
14925          }
14926          auto it = m_value.object->find(key);
14927          if (it == m_value.object->end())
14928          {
14929              JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
14930          }
14931          return it->second;
14932      }
14933      template<class KeyType, detail::enable_if_t<
14934                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
14935      const_reference at(KeyType && key) const
14936      {
14937          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14938          {
14939              JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
14940          }
14941          auto it = m_value.object->find(std::forward<KeyType>(key));
14942          if (it == m_value.object->end())
14943          {
14944              JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
14945          }
14946          return it->second;
14947      }
14948      reference operator[](size_type idx)
14949      {
14950          if (is_null())
14951          {
14952              m_type = value_t::array;
14953              m_value.array = create<array_t>();
14954              assert_invariant();
14955          }
14956          if (JSON_HEDLEY_LIKELY(is_array()))
14957          {
14958              if (idx >= m_value.array->size())
14959              {
14960  #if JSON_DIAGNOSTICS
14961                  const auto old_size = m_value.array->size();
14962                  const auto old_capacity = m_value.array->capacity();
14963  #endif
14964                  m_value.array->resize(idx + 1);
14965  #if JSON_DIAGNOSTICS
14966                  if (JSON_HEDLEY_UNLIKELY(m_value.array->capacity() != old_capacity))
14967                  {
14968                      set_parents();
14969                  }
14970                  else
14971                  {
14972                      set_parents(begin() + static_cast<typename iterator::difference_type>(old_size), static_cast<typename iterator::difference_type>(idx + 1 - old_size));
14973                  }
14974  #endif
14975                  assert_invariant();
14976              }
14977              return m_value.array->operator[](idx);
14978          }
14979          JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
14980      }
14981      const_reference operator[](size_type idx) const
14982      {
14983          if (JSON_HEDLEY_LIKELY(is_array()))
14984          {
14985              return m_value.array->operator[](idx);
14986          }
14987          JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
14988      }
14989      reference operator[](typename object_t::key_type key)
14990      {
14991          if (is_null())
14992          {
14993              m_type = value_t::object;
14994              m_value.object = create<object_t>();
14995              assert_invariant();
14996          }
14997          if (JSON_HEDLEY_LIKELY(is_object()))
14998          {
14999              auto result = m_value.object->emplace(std::move(key), nullptr);
15000              return set_parent(result.first->second);
15001          }
15002          JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
15003      }
15004      const_reference operator[](const typename object_t::key_type& key) const
15005      {
15006          if (JSON_HEDLEY_LIKELY(is_object()))
15007          {
15008              auto it = m_value.object->find(key);
15009              JSON_ASSERT(it != m_value.object->end());
15010              return it->second;
15011          }
15012          JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
15013      }
15014      template<typename T>
15015      reference operator[](T* key)
15016      {
15017          return operator[](typename object_t::key_type(key));
15018      }
15019      template<typename T>
15020      const_reference operator[](T* key) const
15021      {
15022          return operator[](typename object_t::key_type(key));
15023      }
15024      template<class KeyType, detail::enable_if_t<
15025                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
15026      reference operator[](KeyType && key)
15027      {
15028          if (is_null())
15029          {
15030              m_type = value_t::object;
15031              m_value.object = create<object_t>();
15032              assert_invariant();
15033          }
15034          if (JSON_HEDLEY_LIKELY(is_object()))
15035          {
15036              auto result = m_value.object->emplace(std::forward<KeyType>(key), nullptr);
15037              return set_parent(result.first->second);
15038          }
15039          JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
15040      }
15041      template<class KeyType, detail::enable_if_t<
15042                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
15043      const_reference operator[](KeyType && key) const
15044      {
15045          if (JSON_HEDLEY_LIKELY(is_object()))
15046          {
15047              auto it = m_value.object->find(std::forward<KeyType>(key));
15048              JSON_ASSERT(it != m_value.object->end());
15049              return it->second;
15050          }
15051          JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
15052      }
15053    private:
15054      template<typename KeyType>
15055      using is_comparable_with_object_key = detail::is_comparable <
15056          object_comparator_t, const typename object_t::key_type&, KeyType >;
15057      template<typename ValueType>
15058      using value_return_type = std::conditional <
15059          detail::is_c_string_uncvref<ValueType>::value,
15060          string_t, typename std::decay<ValueType>::type >;
15061    public:
15062      template < class ValueType, detail::enable_if_t <
15063                     !detail::is_transparent<object_comparator_t>::value
15064                     && detail::is_getable<basic_json_t, ValueType>::value
15065                     && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
15066      ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
15067      {
15068          if (JSON_HEDLEY_LIKELY(is_object()))
15069          {
15070              const auto it = find(key);
15071              if (it != end())
15072              {
15073                  return it->template get<ValueType>();
15074              }
15075              return default_value;
15076          }
15077          JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
15078      }
15079      template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
15080                 detail::enable_if_t <
15081                     !detail::is_transparent<object_comparator_t>::value
15082                     && detail::is_getable<basic_json_t, ReturnType>::value
15083                     && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
15084      ReturnType value(const typename object_t::key_type& key, ValueType && default_value) const
15085      {
15086          if (JSON_HEDLEY_LIKELY(is_object()))
15087          {
15088              const auto it = find(key);
15089              if (it != end())
15090              {
15091                  return it->template get<ReturnType>();
15092              }
15093              return std::forward<ValueType>(default_value);
15094          }
15095          JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
15096      }
15097      template < class ValueType, class KeyType, detail::enable_if_t <
15098                     detail::is_transparent<object_comparator_t>::value
15099                     && !detail::is_json_pointer<KeyType>::value
15100                     && is_comparable_with_object_key<KeyType>::value
15101                     && detail::is_getable<basic_json_t, ValueType>::value
15102                     && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
15103      ValueType value(KeyType && key, const ValueType& default_value) const
15104      {
15105          if (JSON_HEDLEY_LIKELY(is_object()))
15106          {
15107              const auto it = find(std::forward<KeyType>(key));
15108              if (it != end())
15109              {
15110                  return it->template get<ValueType>();
15111              }
15112              return default_value;
15113          }
15114          JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
15115      }
15116      template < class ValueType, class KeyType, class ReturnType = typename value_return_type<ValueType>::type,
15117                 detail::enable_if_t <
15118                     detail::is_transparent<object_comparator_t>::value
15119                     && !detail::is_json_pointer<KeyType>::value
15120                     && is_comparable_with_object_key<KeyType>::value
15121                     && detail::is_getable<basic_json_t, ReturnType>::value
15122                     && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
15123      ReturnType value(KeyType && key, ValueType && default_value) const
15124      {
15125          if (JSON_HEDLEY_LIKELY(is_object()))
15126          {
15127              const auto it = find(std::forward<KeyType>(key));
15128              if (it != end())
15129              {
15130                  return it->template get<ReturnType>();
15131              }
15132              return std::forward<ValueType>(default_value);
15133          }
15134          JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
15135      }
15136      template < class ValueType, detail::enable_if_t <
15137                     detail::is_getable<basic_json_t, ValueType>::value
15138                     && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
15139      ValueType value(const json_pointer& ptr, const ValueType& default_value) const
15140      {
15141          if (JSON_HEDLEY_LIKELY(is_object()))
15142          {
15143              JSON_TRY
15144              {
15145                  return ptr.get_checked(this).template get<ValueType>();
15146              }
15147              JSON_INTERNAL_CATCH (out_of_range&)
15148              {
15149                  return default_value;
15150              }
15151          }
15152          JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
15153      }
15154      template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
15155                 detail::enable_if_t <
15156                     detail::is_getable<basic_json_t, ReturnType>::value
15157                     && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
15158      ReturnType value(const json_pointer& ptr, ValueType && default_value) const
15159      {
15160          if (JSON_HEDLEY_LIKELY(is_object()))
15161          {
15162              JSON_TRY
15163              {
15164                  return ptr.get_checked(this).template get<ReturnType>();
15165              }
15166              JSON_INTERNAL_CATCH (out_of_range&)
15167              {
15168                  return std::forward<ValueType>(default_value);
15169              }
15170          }
15171          JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
15172      }
15173      template < class ValueType, class BasicJsonType, detail::enable_if_t <
15174                     detail::is_basic_json<BasicJsonType>::value
15175                     && detail::is_getable<basic_json_t, ValueType>::value
15176                     && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
15177      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) 
15178      ValueType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, const ValueType& default_value) const
15179      {
15180          return value(ptr.convert(), default_value);
15181      }
15182      template < class ValueType, class BasicJsonType, class ReturnType = typename value_return_type<ValueType>::type,
15183                 detail::enable_if_t <
15184                     detail::is_basic_json<BasicJsonType>::value
15185                     && detail::is_getable<basic_json_t, ReturnType>::value
15186                     && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
15187      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) 
15188      ReturnType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, ValueType && default_value) const
15189      {
15190          return value(ptr.convert(), std::forward<ValueType>(default_value));
15191      }
15192      reference front()
15193      {
15194          return *begin();
15195      }
15196      const_reference front() const
15197      {
15198          return *cbegin();
15199      }
15200      reference back()
15201      {
15202          auto tmp = end();
15203          --tmp;
15204          return *tmp;
15205      }
15206      const_reference back() const
15207      {
15208          auto tmp = cend();
15209          --tmp;
15210          return *tmp;
15211      }
15212      template < class IteratorType, detail::enable_if_t <
15213                     std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
15214                     std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
15215      IteratorType erase(IteratorType pos)
15216      {
15217          if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
15218          {
15219              JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
15220          }
15221          IteratorType result = end();
15222          switch (m_type)
15223          {
15224              case value_t::boolean:
15225              case value_t::number_float:
15226              case value_t::number_integer:
15227              case value_t::number_unsigned:
15228              case value_t::string:
15229              case value_t::binary:
15230              {
15231                  if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
15232                  {
15233                      JSON_THROW(invalid_iterator::create(205, "iterator out of range", this));
15234                  }
15235                  if (is_string())
15236                  {
15237                      AllocatorType<string_t> alloc;
15238                      std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
15239                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
15240                      m_value.string = nullptr;
15241                  }
15242                  else if (is_binary())
15243                  {
15244                      AllocatorType<binary_t> alloc;
15245                      std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.binary);
15246                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.binary, 1);
15247                      m_value.binary = nullptr;
15248                  }
15249                  m_type = value_t::null;
15250                  assert_invariant();
15251                  break;
15252              }
15253              case value_t::object:
15254              {
15255                  result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
15256                  break;
15257              }
15258              case value_t::array:
15259              {
15260                  result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
15261                  break;
15262              }
15263              case value_t::null:
15264              case value_t::discarded:
15265              default:
15266                  JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
15267          }
15268          return result;
15269      }
15270      template < class IteratorType, detail::enable_if_t <
15271                     std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
15272                     std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
15273      IteratorType erase(IteratorType first, IteratorType last)
15274      {
15275          if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
15276          {
15277              JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value", this));
15278          }
15279          IteratorType result = end();
15280          switch (m_type)
15281          {
15282              case value_t::boolean:
15283              case value_t::number_float:
15284              case value_t::number_integer:
15285              case value_t::number_unsigned:
15286              case value_t::string:
15287              case value_t::binary:
15288              {
15289                  if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
15290                                         || !last.m_it.primitive_iterator.is_end()))
15291                  {
15292                      JSON_THROW(invalid_iterator::create(204, "iterators out of range", this));
15293                  }
15294                  if (is_string())
15295                  {
15296                      AllocatorType<string_t> alloc;
15297                      std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
15298                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
15299                      m_value.string = nullptr;
15300                  }
15301                  else if (is_binary())
15302                  {
15303                      AllocatorType<binary_t> alloc;
15304                      std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.binary);
15305                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.binary, 1);
15306                      m_value.binary = nullptr;
15307                  }
15308                  m_type = value_t::null;
15309                  assert_invariant();
15310                  break;
15311              }
15312              case value_t::object:
15313              {
15314                  result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
15315                                                last.m_it.object_iterator);
15316                  break;
15317              }
15318              case value_t::array:
15319              {
15320                  result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
15321                                               last.m_it.array_iterator);
15322                  break;
15323              }
15324              case value_t::null:
15325              case value_t::discarded:
15326              default:
15327                  JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
15328          }
15329          return result;
15330      }
15331    private:
15332      template < typename KeyType, detail::enable_if_t <
15333                     detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
15334      size_type erase_internal(KeyType && key)
15335      {
15336          if (JSON_HEDLEY_UNLIKELY(!is_object()))
15337          {
15338              JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
15339          }
15340          return m_value.object->erase(std::forward<KeyType>(key));
15341      }
15342      template < typename KeyType, detail::enable_if_t <
15343                     !detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
15344      size_type erase_internal(KeyType && key)
15345      {
15346          if (JSON_HEDLEY_UNLIKELY(!is_object()))
15347          {
15348              JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
15349          }
15350          const auto it = m_value.object->find(std::forward<KeyType>(key));
15351          if (it != m_value.object->end())
15352          {
15353              m_value.object->erase(it);
15354              return 1;
15355          }
15356          return 0;
15357      }
15358    public:
15359      size_type erase(const typename object_t::key_type& key)
15360      {
15361          return erase_internal(key);
15362      }
15363      template<class KeyType, detail::enable_if_t<
15364                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
15365      size_type erase(KeyType && key)
15366      {
15367          return erase_internal(std::forward<KeyType>(key));
15368      }
15369      void erase(const size_type idx)
15370      {
15371          if (JSON_HEDLEY_LIKELY(is_array()))
15372          {
15373              if (JSON_HEDLEY_UNLIKELY(idx >= size()))
15374              {
15375                  JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
15376              }
15377              m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
15378          }
15379          else
15380          {
15381              JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
15382          }
15383      }
15384      iterator find(const typename object_t::key_type& key)
15385      {
15386          auto result = end();
15387          if (is_object())
15388          {
15389              result.m_it.object_iterator = m_value.object->find(key);
15390          }
15391          return result;
15392      }
15393      const_iterator find(const typename object_t::key_type& key) const
15394      {
15395          auto result = cend();
15396          if (is_object())
15397          {
15398              result.m_it.object_iterator = m_value.object->find(key);
15399          }
15400          return result;
15401      }
15402      template<class KeyType, detail::enable_if_t<
15403                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
15404      iterator find(KeyType && key)
15405      {
15406          auto result = end();
15407          if (is_object())
15408          {
15409              result.m_it.object_iterator = m_value.object->find(std::forward<KeyType>(key));
15410          }
15411          return result;
15412      }
15413      template<class KeyType, detail::enable_if_t<
15414                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
15415      const_iterator find(KeyType && key) const
15416      {
15417          auto result = cend();
15418          if (is_object())
15419          {
15420              result.m_it.object_iterator = m_value.object->find(std::forward<KeyType>(key));
15421          }
15422          return result;
15423      }
15424      size_type count(const typename object_t::key_type& key) const
15425      {
15426          return is_object() ? m_value.object->count(key) : 0;
15427      }
15428      template<class KeyType, detail::enable_if_t<
15429                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
15430      size_type count(KeyType && key) const
15431      {
15432          return is_object() ? m_value.object->count(std::forward<KeyType>(key)) : 0;
15433      }
15434      bool contains(const typename object_t::key_type& key) const
15435      {
15436          return is_object() && m_value.object->find(key) != m_value.object->end();
15437      }
15438      template<class KeyType, detail::enable_if_t<
15439                   detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
15440      bool contains(KeyType && key) const
15441      {
15442          return is_object() && m_value.object->find(std::forward<KeyType>(key)) != m_value.object->end();
15443      }
15444      bool contains(const json_pointer& ptr) const
15445      {
15446          return ptr.contains(this);
15447      }
15448      template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
15449      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) 
15450      bool contains(const typename ::nlohmann::json_pointer<BasicJsonType>& ptr) const
15451      {
15452          return ptr.contains(this);
15453      }
15454      iterator begin() noexcept
15455      {
15456          iterator result(this);
15457          result.set_begin();
15458          return result;
15459      }
15460      const_iterator begin() const noexcept
15461      {
15462          return cbegin();
15463      }
15464      const_iterator cbegin() const noexcept
15465      {
15466          const_iterator result(this);
15467          result.set_begin();
15468          return result;
15469      }
15470      iterator end() noexcept
15471      {
15472          iterator result(this);
15473          result.set_end();
15474          return result;
15475      }
15476      const_iterator end() const noexcept
15477      {
15478          return cend();
15479      }
15480      const_iterator cend() const noexcept
15481      {
15482          const_iterator result(this);
15483          result.set_end();
15484          return result;
15485      }
15486      reverse_iterator rbegin() noexcept
15487      {
15488          return reverse_iterator(end());
15489      }
15490      const_reverse_iterator rbegin() const noexcept
15491      {
15492          return crbegin();
15493      }
15494      reverse_iterator rend() noexcept
15495      {
15496          return reverse_iterator(begin());
15497      }
15498      const_reverse_iterator rend() const noexcept
15499      {
15500          return crend();
15501      }
15502      const_reverse_iterator crbegin() const noexcept
15503      {
15504          return const_reverse_iterator(cend());
15505      }
15506      const_reverse_iterator crend() const noexcept
15507      {
15508          return const_reverse_iterator(cbegin());
15509      }
15510    public:
15511      JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
15512      static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
15513      {
15514          return ref.items();
15515      }
15516      JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
15517      static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
15518      {
15519          return ref.items();
15520      }
15521      iteration_proxy<iterator> items() noexcept
15522      {
15523          return iteration_proxy<iterator>(*this);
15524      }
15525      iteration_proxy<const_iterator> items() const noexcept
15526      {
15527          return iteration_proxy<const_iterator>(*this);
15528      }
15529      bool empty() const noexcept
15530      {
15531          switch (m_type)
15532          {
15533              case value_t::null:
15534              {
15535                  return true;
15536              }
15537              case value_t::array:
15538              {
15539                  return m_value.array->empty();
15540              }
15541              case value_t::object:
15542              {
15543                  return m_value.object->empty();
15544              }
15545              case value_t::string:
15546              case value_t::boolean:
15547              case value_t::number_integer:
15548              case value_t::number_unsigned:
15549              case value_t::number_float:
15550              case value_t::binary:
15551              case value_t::discarded:
15552              default:
15553              {
15554                  return false;
15555              }
15556          }
15557      }
15558      size_type size() const noexcept
15559      {
15560          switch (m_type)
15561          {
15562              case value_t::null:
15563              {
15564                  return 0;
15565              }
15566              case value_t::array:
15567              {
15568                  return m_value.array->size();
15569              }
15570              case value_t::object:
15571              {
15572                  return m_value.object->size();
15573              }
15574              case value_t::string:
15575              case value_t::boolean:
15576              case value_t::number_integer:
15577              case value_t::number_unsigned:
15578              case value_t::number_float:
15579              case value_t::binary:
15580              case value_t::discarded:
15581              default:
15582              {
15583                  return 1;
15584              }
15585          }
15586      }
15587      size_type max_size() const noexcept
15588      {
15589          switch (m_type)
15590          {
15591              case value_t::array:
15592              {
15593                  return m_value.array->max_size();
15594              }
15595              case value_t::object:
15596              {
15597                  return m_value.object->max_size();
15598              }
15599              case value_t::null:
15600              case value_t::string:
15601              case value_t::boolean:
15602              case value_t::number_integer:
15603              case value_t::number_unsigned:
15604              case value_t::number_float:
15605              case value_t::binary:
15606              case value_t::discarded:
15607              default:
15608              {
15609                  return size();
15610              }
15611          }
15612      }
15613      void clear() noexcept
15614      {
15615          switch (m_type)
15616          {
15617              case value_t::number_integer:
15618              {
15619                  m_value.number_integer = 0;
15620                  break;
15621              }
15622              case value_t::number_unsigned:
15623              {
15624                  m_value.number_unsigned = 0;
15625                  break;
15626              }
15627              case value_t::number_float:
15628              {
15629                  m_value.number_float = 0.0;
15630                  break;
15631              }
15632              case value_t::boolean:
15633              {
15634                  m_value.boolean = false;
15635                  break;
15636              }
15637              case value_t::string:
15638              {
15639                  m_value.string->clear();
15640                  break;
15641              }
15642              case value_t::binary:
15643              {
15644                  m_value.binary->clear();
15645                  break;
15646              }
15647              case value_t::array:
15648              {
15649                  m_value.array->clear();
15650                  break;
15651              }
15652              case value_t::object:
15653              {
15654                  m_value.object->clear();
15655                  break;
15656              }
15657              case value_t::null:
15658              case value_t::discarded:
15659              default:
15660                  break;
15661          }
15662      }
15663      void push_back(basic_json&& val)
15664      {
15665          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
15666          {
15667              JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
15668          }
15669          if (is_null())
15670          {
15671              m_type = value_t::array;
15672              m_value = value_t::array;
15673              assert_invariant();
15674          }
15675          const auto old_capacity = m_value.array->capacity();
15676          m_value.array->push_back(std::move(val));
15677          set_parent(m_value.array->back(), old_capacity);
15678      }
15679      reference operator+=(basic_json&& val)
15680      {
15681          push_back(std::move(val));
15682          return *this;
15683      }
15684      void push_back(const basic_json& val)
15685      {
15686          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
15687          {
15688              JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
15689          }
15690          if (is_null())
15691          {
15692              m_type = value_t::array;
15693              m_value = value_t::array;
15694              assert_invariant();
15695          }
15696          const auto old_capacity = m_value.array->capacity();
15697          m_value.array->push_back(val);
15698          set_parent(m_value.array->back(), old_capacity);
15699      }
15700      reference operator+=(const basic_json& val)
15701      {
15702          push_back(val);
15703          return *this;
15704      }
15705      void push_back(const typename object_t::value_type& val)
15706      {
15707          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
15708          {
15709              JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
15710          }
15711          if (is_null())
15712          {
15713              m_type = value_t::object;
15714              m_value = value_t::object;
15715              assert_invariant();
15716          }
15717          auto res = m_value.object->insert(val);
15718          set_parent(res.first->second);
15719      }
15720      reference operator+=(const typename object_t::value_type& val)
15721      {
15722          push_back(val);
15723          return *this;
15724      }
15725      void push_back(initializer_list_t init)
15726      {
15727          if (is_object() && init.size() == 2 && (*init.begin())->is_string())
15728          {
15729              basic_json&& key = init.begin()->moved_or_copied();
15730              push_back(typename object_t::value_type(
15731                            std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
15732          }
15733          else
15734          {
15735              push_back(basic_json(init));
15736          }
15737      }
15738      reference operator+=(initializer_list_t init)
15739      {
15740          push_back(init);
15741          return *this;
15742      }
15743      template<class... Args>
15744      reference emplace_back(Args&& ... args)
15745      {
15746          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
15747          {
15748              JSON_THROW(type_error::create(311, detail::concat("cannot use emplace_back() with ", type_name()), this));
15749          }
15750          if (is_null())
15751          {
15752              m_type = value_t::array;
15753              m_value = value_t::array;
15754              assert_invariant();
15755          }
15756          const auto old_capacity = m_value.array->capacity();
15757          m_value.array->emplace_back(std::forward<Args>(args)...);
15758          return set_parent(m_value.array->back(), old_capacity);
15759      }
15760      template<class... Args>
15761      std::pair<iterator, bool> emplace(Args&& ... args)
15762      {
15763          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
15764          {
15765              JSON_THROW(type_error::create(311, detail::concat("cannot use emplace() with ", type_name()), this));
15766          }
15767          if (is_null())
15768          {
15769              m_type = value_t::object;
15770              m_value = value_t::object;
15771              assert_invariant();
15772          }
15773          auto res = m_value.object->emplace(std::forward<Args>(args)...);
15774          set_parent(res.first->second);
15775          auto it = begin();
15776          it.m_it.object_iterator = res.first;
15777          return {it, res.second};
15778      }
15779      template<typename... Args>
15780      iterator insert_iterator(const_iterator pos, Args&& ... args)
15781      {
15782          iterator result(this);
15783          JSON_ASSERT(m_value.array != nullptr);
15784          auto insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);
15785          m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
15786          result.m_it.array_iterator = m_value.array->begin() + insert_pos;
15787          set_parents();
15788          return result;
15789      }
15790      iterator insert(const_iterator pos, const basic_json& val)
15791      {
15792          if (JSON_HEDLEY_LIKELY(is_array()))
15793          {
15794              if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
15795              {
15796                  JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
15797              }
15798              return insert_iterator(pos, val);
15799          }
15800          JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
15801      }
15802      iterator insert(const_iterator pos, basic_json&& val)
15803      {
15804          return insert(pos, val);
15805      }
15806      iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
15807      {
15808          if (JSON_HEDLEY_LIKELY(is_array()))
15809          {
15810              if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
15811              {
15812                  JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
15813              }
15814              return insert_iterator(pos, cnt, val);
15815          }
15816          JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
15817      }
15818      iterator insert(const_iterator pos, const_iterator first, const_iterator last)
15819      {
15820          if (JSON_HEDLEY_UNLIKELY(!is_array()))
15821          {
15822              JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
15823          }
15824          if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
15825          {
15826              JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
15827          }
15828          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
15829          {
15830              JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
15831          }
15832          if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
15833          {
15834              JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container", this));
15835          }
15836          return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
15837      }
15838      iterator insert(const_iterator pos, initializer_list_t ilist)
15839      {
15840          if (JSON_HEDLEY_UNLIKELY(!is_array()))
15841          {
15842              JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
15843          }
15844          if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
15845          {
15846              JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
15847          }
15848          return insert_iterator(pos, ilist.begin(), ilist.end());
15849      }
15850      void insert(const_iterator first, const_iterator last)
15851      {
15852          if (JSON_HEDLEY_UNLIKELY(!is_object()))
15853          {
15854              JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
15855          }
15856          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
15857          {
15858              JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
15859          }
15860          if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
15861          {
15862              JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects", this));
15863          }
15864          m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
15865      }
15866      void update(const_reference j, bool merge_objects = false)
15867      {
15868          update(j.begin(), j.end(), merge_objects);
15869      }
15870      void update(const_iterator first, const_iterator last, bool merge_objects = false)
15871      {
15872          if (is_null())
15873          {
15874              m_type = value_t::object;
15875              m_value.object = create<object_t>();
15876              assert_invariant();
15877          }
15878          if (JSON_HEDLEY_UNLIKELY(!is_object()))
15879          {
15880              JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", type_name()), this));
15881          }
15882          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
15883          {
15884              JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
15885          }
15886          if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
15887          {
15888              JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", first.m_object->type_name()), first.m_object));
15889          }
15890          for (auto it = first; it != last; ++it)
15891          {
15892              if (merge_objects && it.value().is_object())
15893              {
15894                  auto it2 = m_value.object->find(it.key());
15895                  if (it2 != m_value.object->end())
15896                  {
15897                      it2->second.update(it.value(), true);
15898                      continue;
15899                  }
15900              }
15901              m_value.object->operator[](it.key()) = it.value();
15902  #if JSON_DIAGNOSTICS
15903              m_value.object->operator[](it.key()).m_parent = this;
15904  #endif
15905          }
15906      }
15907      void swap(reference other) noexcept (
15908          std::is_nothrow_move_constructible<value_t>::value&&
15909          std::is_nothrow_move_assignable<value_t>::value&&
15910          std::is_nothrow_move_constructible<json_value>::value&&
15911          std::is_nothrow_move_assignable<json_value>::value
15912      )
15913      {
15914          std::swap(m_type, other.m_type);
15915          std::swap(m_value, other.m_value);
15916          set_parents();
15917          other.set_parents();
15918          assert_invariant();
15919      }
15920      friend void swap(reference left, reference right) noexcept (
15921          std::is_nothrow_move_constructible<value_t>::value&&
15922          std::is_nothrow_move_assignable<value_t>::value&&
15923          std::is_nothrow_move_constructible<json_value>::value&&
15924          std::is_nothrow_move_assignable<json_value>::value
15925      )
15926      {
15927          left.swap(right);
15928      }
15929      void swap(array_t& other) 
15930      {
15931          if (JSON_HEDLEY_LIKELY(is_array()))
15932          {
15933              using std::swap;
15934              swap(*(m_value.array), other);
15935          }
15936          else
15937          {
15938              JSON_THROW(type_error::create(310, detail::concat("cannot use swap(array_t&) with ", type_name()), this));
15939          }
15940      }
15941      void swap(object_t& other) 
15942      {
15943          if (JSON_HEDLEY_LIKELY(is_object()))
15944          {
15945              using std::swap;
15946              swap(*(m_value.object), other);
15947          }
15948          else
15949          {
15950              JSON_THROW(type_error::create(310, detail::concat("cannot use swap(object_t&) with ", type_name()), this));
15951          }
15952      }
15953      void swap(string_t& other) 
15954      {
15955          if (JSON_HEDLEY_LIKELY(is_string()))
15956          {
15957              using std::swap;
15958              swap(*(m_value.string), other);
15959          }
15960          else
15961          {
15962              JSON_THROW(type_error::create(310, detail::concat("cannot use swap(string_t&) with ", type_name()), this));
15963          }
15964      }
15965      void swap(binary_t& other) 
15966      {
15967          if (JSON_HEDLEY_LIKELY(is_binary()))
15968          {
15969              using std::swap;
15970              swap(*(m_value.binary), other);
15971          }
15972          else
15973          {
15974              JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t&) with ", type_name()), this));
15975          }
15976      }
15977      void swap(typename binary_t::container_type& other) 
15978      {
15979          if (JSON_HEDLEY_LIKELY(is_binary()))
15980          {
15981              using std::swap;
15982              swap(*(m_value.binary), other);
15983          }
15984          else
15985          {
15986              JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t::container_type&) with ", type_name()), this));
15987          }
15988      }
15989  #define JSON_IMPLEMENT_OPERATOR(op, null_result, unordered_result, default_result)                       \
15990      const auto lhs_type = lhs.type();                                                                    \
15991      const auto rhs_type = rhs.type();                                                                    \
15992      \
15993      if (lhs_type == rhs_type) &bsol;* NOLINT(readability/braces) */                                           \
15994      {                                                                                                    \
15995          switch (lhs_type)                                                                                \
15996          {                                                                                                \
15997              case value_t::array:                                                                         \
15998                  return (*lhs.m_value.array) op (*rhs.m_value.array);                                     \
15999                  \
16000              case value_t::object:                                                                        \
16001                  return (*lhs.m_value.object) op (*rhs.m_value.object);                                   \
16002                  \
16003              case value_t::null:                                                                          \
16004                  return (null_result);                                                                    \
16005                  \
16006              case value_t::string:                                                                        \
16007                  return (*lhs.m_value.string) op (*rhs.m_value.string);                                   \
16008                  \
16009              case value_t::boolean:                                                                       \
16010                  return (lhs.m_value.boolean) op (rhs.m_value.boolean);                                   \
16011                  \
16012              case value_t::number_integer:                                                                \
16013                  return (lhs.m_value.number_integer) op (rhs.m_value.number_integer);                     \
16014                  \
16015              case value_t::number_unsigned:                                                               \
16016                  return (lhs.m_value.number_unsigned) op (rhs.m_value.number_unsigned);                   \
16017                  \
16018              case value_t::number_float:                                                                  \
16019                  return (lhs.m_value.number_float) op (rhs.m_value.number_float);                         \
16020                  \
16021              case value_t::binary:                                                                        \
16022                  return (*lhs.m_value.binary) op (*rhs.m_value.binary);                                   \
16023                  \
16024              case value_t::discarded:                                                                     \
16025              default:                                                                                     \
16026                  return (unordered_result);                                                               \
16027          }                                                                                                \
16028      }                                                                                                    \
16029      else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)                   \
16030      {                                                                                                    \
16031          return static_cast<number_float_t>(lhs.m_value.number_integer) op rhs.m_value.number_float;      \
16032      }                                                                                                    \
16033      else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)                   \
16034      {                                                                                                    \
16035          return lhs.m_value.number_float op static_cast<number_float_t>(rhs.m_value.number_integer);      \
16036      }                                                                                                    \
16037      else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)                  \
16038      {                                                                                                    \
16039          return static_cast<number_float_t>(lhs.m_value.number_unsigned) op rhs.m_value.number_float;     \
16040      }                                                                                                    \
16041      else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)                  \
16042      {                                                                                                    \
16043          return lhs.m_value.number_float op static_cast<number_float_t>(rhs.m_value.number_unsigned);     \
16044      }                                                                                                    \
16045      else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)                \
16046      {                                                                                                    \
16047          return static_cast<number_integer_t>(lhs.m_value.number_unsigned) op rhs.m_value.number_integer; \
16048      }                                                                                                    \
16049      else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)                \
16050      {                                                                                                    \
16051          return lhs.m_value.number_integer op static_cast<number_integer_t>(rhs.m_value.number_unsigned); \
16052      }                                                                                                    \
16053      else if(compares_unordered(lhs, rhs))\
16054      {\
16055          return (unordered_result);\
16056      }\
16057      \
16058      return (default_result);
16059    JSON_PRIVATE_UNLESS_TESTED:
16060      static bool compares_unordered(const_reference lhs, const_reference rhs, bool inverse = false) noexcept
16061      {
16062          if ((lhs.is_number_float() && std::isnan(lhs.m_value.number_float) && rhs.is_number())
16063                  || (rhs.is_number_float() && std::isnan(rhs.m_value.number_float) && lhs.is_number()))
16064          {
16065              return true;
16066          }
16067  #if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
16068          return (lhs.is_discarded() || rhs.is_discarded()) && !inverse;
16069  #else
16070          static_cast<void>(inverse);
16071          return lhs.is_discarded() || rhs.is_discarded();
16072  #endif
16073      }
16074    private:
16075      bool compares_unordered(const_reference rhs, bool inverse = false) const noexcept
16076      {
16077          return compares_unordered(*this, rhs, inverse);
16078      }
16079    public:
16080  #if JSON_HAS_THREE_WAY_COMPARISON
16081      bool operator==(const_reference rhs) const noexcept
16082      {
16083  #ifdef __GNUC__
16084  #pragma GCC diagnostic push
16085  #pragma GCC diagnostic ignored "-Wfloat-equal"
16086  #endif
16087          const_reference lhs = *this;
16088          JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
16089  #ifdef __GNUC__
16090  #pragma GCC diagnostic pop
16091  #endif
16092      }
16093      template<typename ScalarType>
16094      requires std::is_scalar_v<ScalarType>
16095      bool operator==(ScalarType rhs) const noexcept
16096      {
16097          return *this == basic_json(rhs);
16098      }
16099      bool operator!=(const_reference rhs) const noexcept
16100      {
16101          if (compares_unordered(rhs, true))
16102          {
16103              return false;
16104          }
16105          return !operator==(rhs);
16106      }
16107      std::partial_ordering operator<=>(const_reference rhs) const noexcept 
16108      {
16109          const_reference lhs = *this;
16110          JSON_IMPLEMENT_OPERATOR(<=>, 
16111                                  std::partial_ordering::equivalent,
16112                                  std::partial_ordering::unordered,
16113                                  lhs_type <=> rhs_type) 
16114      }
16115      template<typename ScalarType>
16116      requires std::is_scalar_v<ScalarType>
16117      std::partial_ordering operator<=>(ScalarType rhs) const noexcept 
16118      {
16119          return *this <=> basic_json(rhs); 
16120      }
16121  #if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
16122      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
16123      bool operator<=(const_reference rhs) const noexcept
16124      {
16125          if (compares_unordered(rhs, true))
16126          {
16127              return false;
16128          }
16129          return !(rhs < *this);
16130      }
16131      template<typename ScalarType>
16132      requires std::is_scalar_v<ScalarType>
16133      bool operator<=(ScalarType rhs) const noexcept
16134      {
16135          return *this <= basic_json(rhs);
16136      }
16137      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
16138      bool operator>=(const_reference rhs) const noexcept
16139      {
16140          if (compares_unordered(rhs, true))
16141          {
16142              return false;
16143          }
16144          return !(*this < rhs);
16145      }
16146      template<typename ScalarType>
16147      requires std::is_scalar_v<ScalarType>
16148      bool operator>=(ScalarType rhs) const noexcept
16149      {
16150          return *this >= basic_json(rhs);
16151      }
16152  #endif
16153  #else
16154      friend bool operator==(const_reference lhs, const_reference rhs) noexcept
16155      {
16156  #ifdef __GNUC__
16157  #pragma GCC diagnostic push
16158  #pragma GCC diagnostic ignored "-Wfloat-equal"
16159  #endif
16160          JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
16161  #ifdef __GNUC__
16162  #pragma GCC diagnostic pop
16163  #endif
16164      }
16165      template<typename ScalarType, typename std::enable_if<
16166                   std::is_scalar<ScalarType>::value, int>::type = 0>
16167      friend bool operator==(const_reference lhs, ScalarType rhs) noexcept
16168      {
16169          return lhs == basic_json(rhs);
16170      }
16171      template<typename ScalarType, typename std::enable_if<
16172                   std::is_scalar<ScalarType>::value, int>::type = 0>
16173      friend bool operator==(ScalarType lhs, const_reference rhs) noexcept
16174      {
16175          return basic_json(lhs) == rhs;
16176      }
16177      friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
16178      {
16179          if (compares_unordered(lhs, rhs, true))
16180          {
16181              return false;
16182          }
16183          return !(lhs == rhs);
16184      }
16185      template<typename ScalarType, typename std::enable_if<
16186                   std::is_scalar<ScalarType>::value, int>::type = 0>
16187      friend bool operator!=(const_reference lhs, ScalarType rhs) noexcept
16188      {
16189          return lhs != basic_json(rhs);
16190      }
16191      template<typename ScalarType, typename std::enable_if<
16192                   std::is_scalar<ScalarType>::value, int>::type = 0>
16193      friend bool operator!=(ScalarType lhs, const_reference rhs) noexcept
16194      {
16195          return basic_json(lhs) != rhs;
16196      }
16197      friend bool operator<(const_reference lhs, const_reference rhs) noexcept
16198      {
16199          JSON_IMPLEMENT_OPERATOR( <, false, false, operator<(lhs_type, rhs_type))
16200      }
16201      template<typename ScalarType, typename std::enable_if<
16202                   std::is_scalar<ScalarType>::value, int>::type = 0>
16203      friend bool operator<(const_reference lhs, ScalarType rhs) noexcept
16204      {
16205          return lhs < basic_json(rhs);
16206      }
16207      template<typename ScalarType, typename std::enable_if<
16208                   std::is_scalar<ScalarType>::value, int>::type = 0>
16209      friend bool operator<(ScalarType lhs, const_reference rhs) noexcept
16210      {
16211          return basic_json(lhs) < rhs;
16212      }
16213      friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
16214      {
16215          if (compares_unordered(lhs, rhs, true))
16216          {
16217              return false;
16218          }
16219          return !(rhs < lhs);
16220      }
16221      template<typename ScalarType, typename std::enable_if<
16222                   std::is_scalar<ScalarType>::value, int>::type = 0>
16223      friend bool operator<=(const_reference lhs, ScalarType rhs) noexcept
16224      {
16225          return lhs <= basic_json(rhs);
16226      }
16227      template<typename ScalarType, typename std::enable_if<
16228                   std::is_scalar<ScalarType>::value, int>::type = 0>
16229      friend bool operator<=(ScalarType lhs, const_reference rhs) noexcept
16230      {
16231          return basic_json(lhs) <= rhs;
16232      }
16233      friend bool operator>(const_reference lhs, const_reference rhs) noexcept
16234      {
16235          if (compares_unordered(lhs, rhs))
16236          {
16237              return false;
16238          }
16239          return !(lhs <= rhs);
16240      }
16241      template<typename ScalarType, typename std::enable_if<
16242                   std::is_scalar<ScalarType>::value, int>::type = 0>
16243      friend bool operator>(const_reference lhs, ScalarType rhs) noexcept
16244      {
16245          return lhs > basic_json(rhs);
16246      }
16247      template<typename ScalarType, typename std::enable_if<
16248                   std::is_scalar<ScalarType>::value, int>::type = 0>
16249      friend bool operator>(ScalarType lhs, const_reference rhs) noexcept
16250      {
16251          return basic_json(lhs) > rhs;
16252      }
16253      friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
16254      {
16255          if (compares_unordered(lhs, rhs, true))
16256          {
16257              return false;
16258          }
16259          return !(lhs < rhs);
16260      }
16261      template<typename ScalarType, typename std::enable_if<
16262                   std::is_scalar<ScalarType>::value, int>::type = 0>
16263      friend bool operator>=(const_reference lhs, ScalarType rhs) noexcept
16264      {
16265          return lhs >= basic_json(rhs);
16266      }
16267      template<typename ScalarType, typename std::enable_if<
16268                   std::is_scalar<ScalarType>::value, int>::type = 0>
16269      friend bool operator>=(ScalarType lhs, const_reference rhs) noexcept
16270      {
16271          return basic_json(lhs) >= rhs;
16272      }
16273  #endif
16274  #undef JSON_IMPLEMENT_OPERATOR
16275  #ifndef JSON_NO_IO
16276      friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
16277      {
16278          const bool pretty_print = o.width() > 0;
16279          const auto indentation = pretty_print ? o.width() : 0;
16280          o.width(0);
16281          serializer s(detail::output_adapter<char>(o), o.fill());
16282          s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
16283          return o;
16284      }
16285      JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator<<(std::ostream&, const basic_json&))
16286      friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
16287      {
16288          return o << j;
16289      }
16290  #endif  
16291      template<typename InputType>
16292      JSON_HEDLEY_WARN_UNUSED_RESULT
16293      static basic_json parse(InputType&& i,
16294                              const parser_callback_t cb = nullptr,
16295                              const bool allow_exceptions = true,
16296                              const bool ignore_comments = false)
16297      {
16298          basic_json result;
16299          parser(detail::input_adapter(std::forward<InputType>(i)), cb, allow_exceptions, ignore_comments).parse(true, result);
16300          return result;
16301      }
16302      template<typename IteratorType>
16303      JSON_HEDLEY_WARN_UNUSED_RESULT
16304      static basic_json parse(IteratorType first,
16305                              IteratorType last,
16306                              const parser_callback_t cb = nullptr,
16307                              const bool allow_exceptions = true,
16308                              const bool ignore_comments = false)
16309      {
16310          basic_json result;
16311          parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(true, result);
16312          return result;
16313      }
16314      JSON_HEDLEY_WARN_UNUSED_RESULT
16315      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
16316      static basic_json parse(detail::span_input_adapter&& i,
16317                              const parser_callback_t cb = nullptr,
16318                              const bool allow_exceptions = true,
16319                              const bool ignore_comments = false)
16320      {
16321          basic_json result;
16322          parser(i.get(), cb, allow_exceptions, ignore_comments).parse(true, result);
16323          return result;
16324      }
16325      template<typename InputType>
16326      static bool accept(InputType&& i,
16327                         const bool ignore_comments = false)
16328      {
16329          return parser(detail::input_adapter(std::forward<InputType>(i)), nullptr, false, ignore_comments).accept(true);
16330      }
16331      template<typename IteratorType>
16332      static bool accept(IteratorType first, IteratorType last,
16333                         const bool ignore_comments = false)
16334      {
16335          return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
16336      }
16337      JSON_HEDLEY_WARN_UNUSED_RESULT
16338      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
16339      static bool accept(detail::span_input_adapter&& i,
16340                         const bool ignore_comments = false)
16341      {
16342          return parser(i.get(), nullptr, false, ignore_comments).accept(true);
16343      }
16344      template <typename InputType, typename SAX>
16345      JSON_HEDLEY_NON_NULL(2)
16346      static bool sax_parse(InputType&& i, SAX* sax,
16347                            input_format_t format = input_format_t::json,
16348                            const bool strict = true,
16349                            const bool ignore_comments = false)
16350      {
16351          auto ia = detail::input_adapter(std::forward<InputType>(i));
16352          return format == input_format_t::json
16353                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
16354                 : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
16355      }
16356      template<class IteratorType, class SAX>
16357      JSON_HEDLEY_NON_NULL(3)
16358      static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
16359                            input_format_t format = input_format_t::json,
16360                            const bool strict = true,
16361                            const bool ignore_comments = false)
16362      {
16363          auto ia = detail::input_adapter(std::move(first), std::move(last));
16364          return format == input_format_t::json
16365                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
16366                 : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
16367      }
16368      template <typename SAX>
16369      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
16370      JSON_HEDLEY_NON_NULL(2)
16371      static bool sax_parse(detail::span_input_adapter&& i, SAX* sax,
16372                            input_format_t format = input_format_t::json,
16373                            const bool strict = true,
16374                            const bool ignore_comments = false)
16375      {
16376          auto ia = i.get();
16377          return format == input_format_t::json
16378                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
16379                 : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
16380      }
16381  #ifndef JSON_NO_IO
16382      JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator>>(std::istream&, basic_json&))
16383      friend std::istream& operator<<(basic_json& j, std::istream& i)
16384      {
16385          return operator>>(i, j);
16386      }
16387      friend std::istream& operator>>(std::istream& i, basic_json& j)
16388      {
16389          parser(detail::input_adapter(i)).parse(false, j);
16390          return i;
16391      }
16392  #endif  
16393      JSON_HEDLEY_RETURNS_NON_NULL
16394      const char* type_name() const noexcept
16395      {
16396          switch (m_type)
16397          {
16398              case value_t::null:
16399                  return "null";
16400              case value_t::object:
16401                  return "object";
16402              case value_t::array:
16403                  return "array";
16404              case value_t::string:
16405                  return "string";
16406              case value_t::boolean:
16407                  return "boolean";
16408              case value_t::binary:
16409                  return "binary";
16410              case value_t::discarded:
16411                  return "discarded";
16412              case value_t::number_integer:
16413              case value_t::number_unsigned:
16414              case value_t::number_float:
16415              default:
16416                  return "number";
16417          }
16418      }
16419    JSON_PRIVATE_UNLESS_TESTED:
16420      value_t m_type = value_t::null;
16421      json_value m_value = {};
16422  #if JSON_DIAGNOSTICS
16423      basic_json* m_parent = nullptr;
16424  #endif
16425    public:
16426      static std::vector<std::uint8_t> to_cbor(const basic_json& j)
16427      {
16428          std::vector<std::uint8_t> result;
16429          to_cbor(j, result);
16430          return result;
16431      }
16432      static void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o)
16433      {
16434          binary_writer<std::uint8_t>(o).write_cbor(j);
16435      }
16436      static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
16437      {
16438          binary_writer<char>(o).write_cbor(j);
16439      }
16440      static std::vector<std::uint8_t> to_msgpack(const basic_json& j)
16441      {
16442          std::vector<std::uint8_t> result;
16443          to_msgpack(j, result);
16444          return result;
16445      }
16446      static void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o)
16447      {
16448          binary_writer<std::uint8_t>(o).write_msgpack(j);
16449      }
16450      static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
16451      {
16452          binary_writer<char>(o).write_msgpack(j);
16453      }
16454      static std::vector<std::uint8_t> to_ubjson(const basic_json& j,
16455              const bool use_size = false,
16456              const bool use_type = false)
16457      {
16458          std::vector<std::uint8_t> result;
16459          to_ubjson(j, result, use_size, use_type);
16460          return result;
16461      }
16462      static void to_ubjson(const basic_json& j, detail::output_adapter<std::uint8_t> o,
16463                            const bool use_size = false, const bool use_type = false)
16464      {
16465          binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type);
16466      }
16467      static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
16468                            const bool use_size = false, const bool use_type = false)
16469      {
16470          binary_writer<char>(o).write_ubjson(j, use_size, use_type);
16471      }
16472      static std::vector<std::uint8_t> to_bjdata(const basic_json& j,
16473              const bool use_size = false,
16474              const bool use_type = false)
16475      {
16476          std::vector<std::uint8_t> result;
16477          to_bjdata(j, result, use_size, use_type);
16478          return result;
16479      }
16480      static void to_bjdata(const basic_json& j, detail::output_adapter<std::uint8_t> o,
16481                            const bool use_size = false, const bool use_type = false)
16482      {
16483          binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type, true, true);
16484      }
16485      static void to_bjdata(const basic_json& j, detail::output_adapter<char> o,
16486                            const bool use_size = false, const bool use_type = false)
16487      {
16488          binary_writer<char>(o).write_ubjson(j, use_size, use_type, true, true);
16489      }
16490      static std::vector<std::uint8_t> to_bson(const basic_json& j)
16491      {
16492          std::vector<std::uint8_t> result;
16493          to_bson(j, result);
16494          return result;
16495      }
16496      static void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o)
16497      {
16498          binary_writer<std::uint8_t>(o).write_bson(j);
16499      }
16500      static void to_bson(const basic_json& j, detail::output_adapter<char> o)
16501      {
16502          binary_writer<char>(o).write_bson(j);
16503      }
16504      template<typename InputType>
16505      JSON_HEDLEY_WARN_UNUSED_RESULT
16506      static basic_json from_cbor(InputType&& i,
16507                                  const bool strict = true,
16508                                  const bool allow_exceptions = true,
16509                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
16510      {
16511          basic_json result;
16512          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16513          auto ia = detail::input_adapter(std::forward<InputType>(i));
16514          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
16515          return res ? result : basic_json(value_t::discarded);
16516      }
16517      template<typename IteratorType>
16518      JSON_HEDLEY_WARN_UNUSED_RESULT
16519      static basic_json from_cbor(IteratorType first, IteratorType last,
16520                                  const bool strict = true,
16521                                  const bool allow_exceptions = true,
16522                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
16523      {
16524          basic_json result;
16525          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16526          auto ia = detail::input_adapter(std::move(first), std::move(last));
16527          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
16528          return res ? result : basic_json(value_t::discarded);
16529      }
16530      template<typename T>
16531      JSON_HEDLEY_WARN_UNUSED_RESULT
16532      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
16533      static basic_json from_cbor(const T* ptr, std::size_t len,
16534                                  const bool strict = true,
16535                                  const bool allow_exceptions = true,
16536                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
16537      {
16538          return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
16539      }
16540      JSON_HEDLEY_WARN_UNUSED_RESULT
16541      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
16542      static basic_json from_cbor(detail::span_input_adapter&& i,
16543                                  const bool strict = true,
16544                                  const bool allow_exceptions = true,
16545                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
16546      {
16547          basic_json result;
16548          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16549          auto ia = i.get();
16550          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
16551          return res ? result : basic_json(value_t::discarded);
16552      }
16553      template<typename InputType>
16554      JSON_HEDLEY_WARN_UNUSED_RESULT
16555      static basic_json from_msgpack(InputType&& i,
16556                                     const bool strict = true,
16557                                     const bool allow_exceptions = true)
16558      {
16559          basic_json result;
16560          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16561          auto ia = detail::input_adapter(std::forward<InputType>(i));
16562          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
16563          return res ? result : basic_json(value_t::discarded);
16564      }
16565      template<typename IteratorType>
16566      JSON_HEDLEY_WARN_UNUSED_RESULT
16567      static basic_json from_msgpack(IteratorType first, IteratorType last,
16568                                     const bool strict = true,
16569                                     const bool allow_exceptions = true)
16570      {
16571          basic_json result;
16572          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16573          auto ia = detail::input_adapter(std::move(first), std::move(last));
16574          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
16575          return res ? result : basic_json(value_t::discarded);
16576      }
16577      template<typename T>
16578      JSON_HEDLEY_WARN_UNUSED_RESULT
16579      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
16580      static basic_json from_msgpack(const T* ptr, std::size_t len,
16581                                     const bool strict = true,
16582                                     const bool allow_exceptions = true)
16583      {
16584          return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
16585      }
16586      JSON_HEDLEY_WARN_UNUSED_RESULT
16587      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
16588      static basic_json from_msgpack(detail::span_input_adapter&& i,
16589                                     const bool strict = true,
16590                                     const bool allow_exceptions = true)
16591      {
16592          basic_json result;
16593          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16594          auto ia = i.get();
16595          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
16596          return res ? result : basic_json(value_t::discarded);
16597      }
16598      template<typename InputType>
16599      JSON_HEDLEY_WARN_UNUSED_RESULT
16600      static basic_json from_ubjson(InputType&& i,
16601                                    const bool strict = true,
16602                                    const bool allow_exceptions = true)
16603      {
16604          basic_json result;
16605          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16606          auto ia = detail::input_adapter(std::forward<InputType>(i));
16607          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
16608          return res ? result : basic_json(value_t::discarded);
16609      }
16610      template<typename IteratorType>
16611      JSON_HEDLEY_WARN_UNUSED_RESULT
16612      static basic_json from_ubjson(IteratorType first, IteratorType last,
16613                                    const bool strict = true,
16614                                    const bool allow_exceptions = true)
16615      {
16616          basic_json result;
16617          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16618          auto ia = detail::input_adapter(std::move(first), std::move(last));
16619          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
16620          return res ? result : basic_json(value_t::discarded);
16621      }
16622      template<typename T>
16623      JSON_HEDLEY_WARN_UNUSED_RESULT
16624      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
16625      static basic_json from_ubjson(const T* ptr, std::size_t len,
16626                                    const bool strict = true,
16627                                    const bool allow_exceptions = true)
16628      {
16629          return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
16630      }
16631      JSON_HEDLEY_WARN_UNUSED_RESULT
16632      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
16633      static basic_json from_ubjson(detail::span_input_adapter&& i,
16634                                    const bool strict = true,
16635                                    const bool allow_exceptions = true)
16636      {
16637          basic_json result;
16638          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16639          auto ia = i.get();
16640          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
16641          return res ? result : basic_json(value_t::discarded);
16642      }
16643      template<typename InputType>
16644      JSON_HEDLEY_WARN_UNUSED_RESULT
16645      static basic_json from_bjdata(InputType&& i,
16646                                    const bool strict = true,
16647                                    const bool allow_exceptions = true)
16648      {
16649          basic_json result;
16650          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16651          auto ia = detail::input_adapter(std::forward<InputType>(i));
16652          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict);
16653          return res ? result : basic_json(value_t::discarded);
16654      }
16655      template<typename IteratorType>
16656      JSON_HEDLEY_WARN_UNUSED_RESULT
16657      static basic_json from_bjdata(IteratorType first, IteratorType last,
16658                                    const bool strict = true,
16659                                    const bool allow_exceptions = true)
16660      {
16661          basic_json result;
16662          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16663          auto ia = detail::input_adapter(std::move(first), std::move(last));
16664          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict);
16665          return res ? result : basic_json(value_t::discarded);
16666      }
16667      template<typename InputType>
16668      JSON_HEDLEY_WARN_UNUSED_RESULT
16669      static basic_json from_bson(InputType&& i,
16670                                  const bool strict = true,
16671                                  const bool allow_exceptions = true)
16672      {
16673          basic_json result;
16674          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16675          auto ia = detail::input_adapter(std::forward<InputType>(i));
16676          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
16677          return res ? result : basic_json(value_t::discarded);
16678      }
16679      template<typename IteratorType>
16680      JSON_HEDLEY_WARN_UNUSED_RESULT
16681      static basic_json from_bson(IteratorType first, IteratorType last,
16682                                  const bool strict = true,
16683                                  const bool allow_exceptions = true)
16684      {
16685          basic_json result;
16686          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16687          auto ia = detail::input_adapter(std::move(first), std::move(last));
16688          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
16689          return res ? result : basic_json(value_t::discarded);
16690      }
16691      template<typename T>
16692      JSON_HEDLEY_WARN_UNUSED_RESULT
16693      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
16694      static basic_json from_bson(const T* ptr, std::size_t len,
16695                                  const bool strict = true,
16696                                  const bool allow_exceptions = true)
16697      {
16698          return from_bson(ptr, ptr + len, strict, allow_exceptions);
16699      }
16700      JSON_HEDLEY_WARN_UNUSED_RESULT
16701      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
16702      static basic_json from_bson(detail::span_input_adapter&& i,
16703                                  const bool strict = true,
16704                                  const bool allow_exceptions = true)
16705      {
16706          basic_json result;
16707          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
16708          auto ia = i.get();
16709          const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
16710          return res ? result : basic_json(value_t::discarded);
16711      }
16712      reference operator[](const json_pointer& ptr)
16713      {
16714          return ptr.get_unchecked(this);
16715      }
16716      template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
16717      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) 
16718      reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr)
16719      {
16720          return ptr.get_unchecked(this);
16721      }
16722      const_reference operator[](const json_pointer& ptr) const
16723      {
16724          return ptr.get_unchecked(this);
16725      }
16726      template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
16727      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) 
16728      const_reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
16729      {
16730          return ptr.get_unchecked(this);
16731      }
16732      reference at(const json_pointer& ptr)
16733      {
16734          return ptr.get_checked(this);
16735      }
16736      template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
16737      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) 
16738      reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr)
16739      {
16740          return ptr.get_checked(this);
16741      }
16742      const_reference at(const json_pointer& ptr) const
16743      {
16744          return ptr.get_checked(this);
16745      }
16746      template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
16747      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) 
16748      const_reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
16749      {
16750          return ptr.get_checked(this);
16751      }
16752      basic_json flatten() const
16753      {
16754          basic_json result(value_t::object);
16755          json_pointer::flatten("", *this, result);
16756          return result;
16757      }
16758      basic_json unflatten() const
16759      {
16760          return json_pointer::unflatten(*this);
16761      }
16762      void patch_inplace(const basic_json& json_patch)
16763      {
16764          basic_json& result = *this;
16765          enum class patch_operations {add, remove, replace, move, copy, test, invalid};
16766          const auto get_op = [](const std::string & op)
16767          {
16768              if (op == "add")
16769              {
16770                  return patch_operations::add;
16771              }
16772              if (op == "remove")
16773              {
16774                  return patch_operations::remove;
16775              }
16776              if (op == "replace")
16777              {
16778                  return patch_operations::replace;
16779              }
16780              if (op == "move")
16781              {
16782                  return patch_operations::move;
16783              }
16784              if (op == "copy")
16785              {
16786                  return patch_operations::copy;
16787              }
16788              if (op == "test")
16789              {
16790                  return patch_operations::test;
16791              }
16792              return patch_operations::invalid;
16793          };
16794          const auto operation_add = [&result](json_pointer & ptr, basic_json val)
16795          {
16796              if (ptr.empty())
16797              {
16798                  result = val;
16799                  return;
16800              }
16801              json_pointer top_pointer = ptr.top();
16802              if (top_pointer != ptr)
16803              {
16804                  result.at(top_pointer);
16805              }
16806              const auto last_path = ptr.back();
16807              ptr.pop_back();
16808              basic_json& parent = result.at(ptr);
16809              switch (parent.m_type)
16810              {
16811                  case value_t::null:
16812                  case value_t::object:
16813                  {
16814                      parent[last_path] = val;
16815                      break;
16816                  }
16817                  case value_t::array:
16818                  {
16819                      if (last_path == "-")
16820                      {
16821                          parent.push_back(val);
16822                      }
16823                      else
16824                      {
16825                          const auto idx = json_pointer::template array_index<basic_json_t>(last_path);
16826                          if (JSON_HEDLEY_UNLIKELY(idx > parent.size()))
16827                          {
16828                              JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), &parent));
16829                          }
16830                          parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
16831                      }
16832                      break;
16833                  }
16834                  case value_t::string: 
16835                  case value_t::boolean: 
16836                  case value_t::number_integer: 
16837                  case value_t::number_unsigned: 
16838                  case value_t::number_float: 
16839                  case value_t::binary: 
16840                  case value_t::discarded: 
16841                  default:            
16842                      JSON_ASSERT(false); 
16843              }
16844          };
16845          const auto operation_remove = [this, &result](json_pointer & ptr)
16846          {
16847              const auto last_path = ptr.back();
16848              ptr.pop_back();
16849              basic_json& parent = result.at(ptr);
16850              if (parent.is_object())
16851              {
16852                  auto it = parent.find(last_path);
16853                  if (JSON_HEDLEY_LIKELY(it != parent.end()))
16854                  {
16855                      parent.erase(it);
16856                  }
16857                  else
16858                  {
16859                      JSON_THROW(out_of_range::create(403, detail::concat("key '", last_path, "' not found"), this));
16860                  }
16861              }
16862              else if (parent.is_array())
16863              {
16864                  parent.erase(json_pointer::template array_index<basic_json_t>(last_path));
16865              }
16866          };
16867          if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
16868          {
16869              JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &json_patch));
16870          }
16871          for (const auto& val : json_patch)
16872          {
16873              const auto get_value = [&val](const std::string & op,
16874                                            const std::string & member,
16875                                            bool string_type) -> basic_json &
16876              {
16877                  auto it = val.m_value.object->find(member);
16878                  const auto error_msg = (op == "op") ? "operation" : detail::concat("operation '", op, '\'');
16879                  if (JSON_HEDLEY_UNLIKELY(it == val.m_value.object->end()))
16880                  {
16881                      JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have member '", member, "'"), &val));
16882                  }
16883                  if (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))
16884                  {
16885                      JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have string member '", member, "'"), &val));
16886                  }
16887                  return it->second;
16888              };
16889              if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
16890              {
16891                  JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &val));
16892              }
16893              const auto op = get_value("op", "op", true).template get<std::string>();
16894              const auto path = get_value(op, "path", true).template get<std::string>();
16895              json_pointer ptr(path);
16896              switch (get_op(op))
16897              {
16898                  case patch_operations::add:
16899                  {
16900                      operation_add(ptr, get_value("add", "value", false));
16901                      break;
16902                  }
16903                  case patch_operations::remove:
16904                  {
16905                      operation_remove(ptr);
16906                      break;
16907                  }
16908                  case patch_operations::replace:
16909                  {
16910                      result.at(ptr) = get_value("replace", "value", false);
16911                      break;
16912                  }
16913                  case patch_operations::move:
16914                  {
16915                      const auto from_path = get_value("move", "from", true).template get<std::string>();
16916                      json_pointer from_ptr(from_path);
16917                      basic_json v = result.at(from_ptr);
16918                      operation_remove(from_ptr);
16919                      operation_add(ptr, v);
16920                      break;
16921                  }
16922                  case patch_operations::copy:
16923                  {
16924                      const auto from_path = get_value("copy", "from", true).template get<std::string>();
16925                      const json_pointer from_ptr(from_path);
16926                      basic_json v = result.at(from_ptr);
16927                      operation_add(ptr, v);
16928                      break;
16929                  }
16930                  case patch_operations::test:
16931                  {
16932                      bool success = false;
16933                      JSON_TRY
16934                      {
16935                          success = (result.at(ptr) == get_value("test", "value", false));
16936                      }
16937                      JSON_INTERNAL_CATCH (out_of_range&)
16938                      {
16939                      }
16940                      if (JSON_HEDLEY_UNLIKELY(!success))
16941                      {
16942                          JSON_THROW(other_error::create(501, detail::concat("unsuccessful: ", val.dump()), &val));
16943                      }
16944                      break;
16945                  }
16946                  case patch_operations::invalid:
16947                  default:
16948                  {
16949                      JSON_THROW(parse_error::create(105, 0, detail::concat("operation value '", op, "' is invalid"), &val));
16950                  }
16951              }
16952          }
16953      }
16954      basic_json patch(const basic_json& json_patch) const
16955      {
16956          basic_json result = *this;
16957          result.patch_inplace(json_patch);
16958          return result;
16959      }
16960      JSON_HEDLEY_WARN_UNUSED_RESULT
16961      static basic_json diff(const basic_json& source, const basic_json& target,
16962                             const std::string& path = "")
16963      {
16964          basic_json result(value_t::array);
16965          if (source == target)
16966          {
16967              return result;
16968          }
16969          if (source.type() != target.type())
16970          {
16971              result.push_back(
16972              {
16973                  {"op", "replace"}, {"path", path}, {"value", target}
16974              });
16975              return result;
16976          }
16977          switch (source.type())
16978          {
16979              case value_t::array:
16980              {
16981                  std::size_t i = 0;
16982                  while (i < source.size() && i < target.size())
16983                  {
16984                      auto temp_diff = diff(source[i], target[i], detail::concat(path, '/', std::to_string(i)));
16985                      result.insert(result.end(), temp_diff.begin(), temp_diff.end());
16986                      ++i;
16987                  }
16988                  const auto end_index = static_cast<difference_type>(result.size());
16989                  while (i < source.size())
16990                  {
16991                      result.insert(result.begin() + end_index, object(
16992                      {
16993                          {"op", "remove"},
16994                          {"path", detail::concat(path, '/', std::to_string(i))}
16995                      }));
16996                      ++i;
16997                  }
16998                  while (i < target.size())
16999                  {
17000                      result.push_back(
17001                      {
17002                          {"op", "add"},
17003                          {"path", detail::concat(path, "/-")},
17004                          {"value", target[i]}
17005                      });
17006                      ++i;
17007                  }
17008                  break;
17009              }
17010              case value_t::object:
17011              {
17012                  for (auto it = source.cbegin(); it != source.cend(); ++it)
17013                  {
17014                      const auto path_key = detail::concat(path, '/', detail::escape(it.key()));
17015                      if (target.find(it.key()) != target.end())
17016                      {
17017                          auto temp_diff = diff(it.value(), target[it.key()], path_key);
17018                          result.insert(result.end(), temp_diff.begin(), temp_diff.end());
17019                      }
17020                      else
17021                      {
17022                          result.push_back(object(
17023                          {
17024                              {"op", "remove"}, {"path", path_key}
17025                          }));
17026                      }
17027                  }
17028                  for (auto it = target.cbegin(); it != target.cend(); ++it)
17029                  {
17030                      if (source.find(it.key()) == source.end())
17031                      {
17032                          const auto path_key = detail::concat(path, '/', detail::escape(it.key()));
17033                          result.push_back(
17034                          {
17035                              {"op", "add"}, {"path", path_key},
17036                              {"value", it.value()}
17037                          });
17038                      }
17039                  }
17040                  break;
17041              }
17042              case value_t::null:
17043              case value_t::string:
17044              case value_t::boolean:
17045              case value_t::number_integer:
17046              case value_t::number_unsigned:
17047              case value_t::number_float:
17048              case value_t::binary:
17049              case value_t::discarded:
17050              default:
17051              {
17052                  result.push_back(
17053                  {
17054                      {"op", "replace"}, {"path", path}, {"value", target}
17055                  });
17056                  break;
17057              }
17058          }
17059          return result;
17060      }
17061      void merge_patch(const basic_json& apply_patch)
17062      {
17063          if (apply_patch.is_object())
17064          {
17065              if (!is_object())
17066              {
17067                  *this = object();
17068              }
17069              for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
17070              {
17071                  if (it.value().is_null())
17072                  {
17073                      erase(it.key());
17074                  }
17075                  else
17076                  {
17077                      operator[](it.key()).merge_patch(it.value());
17078                  }
17079              }
17080          }
17081          else
17082          {
17083              *this = apply_patch;
17084          }
17085      }
17086  };
17087  NLOHMANN_BASIC_JSON_TPL_DECLARATION
17088  std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
17089  {
17090      return j.dump();
17091  }
17092  inline namespace literals
17093  {
17094  inline namespace json_literals
17095  {
17096  JSON_HEDLEY_NON_NULL(1)
17097  inline nlohmann::json operator "" _json(const char* s, std::size_t n)
17098  {
17099      return nlohmann::json::parse(s, s + n);
17100  }
17101  JSON_HEDLEY_NON_NULL(1)
17102  inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
17103  {
17104      return nlohmann::json::json_pointer(std::string(s, n));
17105  }
17106  }  
17107  }  
17108  NLOHMANN_JSON_NAMESPACE_END
17109  namespace std 
17110  {
17111  NLOHMANN_BASIC_JSON_TPL_DECLARATION
17112  struct hash<nlohmann::NLOHMANN_BASIC_JSON_TPL>
17113  {
17114      std::size_t operator()(const nlohmann::NLOHMANN_BASIC_JSON_TPL& j) const
17115      {
17116          return nlohmann::detail::hash(j);
17117      }
17118  };
17119  template<>
17120  struct less< ::nlohmann::detail::value_t> 
17121  {
17122      bool operator()(::nlohmann::detail::value_t lhs,
17123                      ::nlohmann::detail::value_t rhs) const noexcept
17124      {
17125  #if JSON_HAS_THREE_WAY_COMPARISON
17126          return std::is_lt(lhs <=> rhs); 
17127  #else
17128          return ::nlohmann::detail::operator<(lhs, rhs);
17129  #endif
17130      }
17131  };
17132  #ifndef JSON_HAS_CPP_20
17133  NLOHMANN_BASIC_JSON_TPL_DECLARATION
17134  inline void swap(nlohmann::NLOHMANN_BASIC_JSON_TPL& j1, nlohmann::NLOHMANN_BASIC_JSON_TPL& j2) noexcept(  
17135      is_nothrow_move_constructible<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value&&                          
17136      is_nothrow_move_assignable<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value)
17137  {
17138      j1.swap(j2);
17139  }
17140  #endif
17141  }  
17142  #if JSON_USE_GLOBAL_UDLS
17143      using nlohmann::literals::json_literals::operator "" _json; 
17144      using nlohmann::literals::json_literals::operator "" _json_pointer; 
17145  #endif
17146  #if defined(__clang__)
17147      #pragma clang diagnostic pop
17148  #endif
17149  #undef JSON_ASSERT
17150  #undef JSON_INTERNAL_CATCH
17151  #undef JSON_THROW
17152  #undef JSON_PRIVATE_UNLESS_TESTED
17153  #undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
17154  #undef NLOHMANN_BASIC_JSON_TPL
17155  #undef JSON_EXPLICIT
17156  #undef NLOHMANN_CAN_CALL_STD_FUNC_IMPL
17157  #undef JSON_INLINE_VARIABLE
17158  #undef JSON_NO_UNIQUE_ADDRESS
17159  #undef JSON_DISABLE_ENUM_SERIALIZATION
17160  #undef JSON_USE_GLOBAL_UDLS
17161  #ifndef JSON_TEST_KEEP_MACROS
17162      #undef JSON_CATCH
17163      #undef JSON_TRY
17164      #undef JSON_HAS_CPP_11
17165      #undef JSON_HAS_CPP_14
17166      #undef JSON_HAS_CPP_17
17167      #undef JSON_HAS_CPP_20
17168      #undef JSON_HAS_FILESYSTEM
17169      #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
17170      #undef JSON_HAS_THREE_WAY_COMPARISON
17171      #undef JSON_HAS_RANGES
17172      #undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
17173  #endif
17174  #undef JSON_HEDLEY_ALWAYS_INLINE
17175  #undef JSON_HEDLEY_ARM_VERSION
17176  #undef JSON_HEDLEY_ARM_VERSION_CHECK
17177  #undef JSON_HEDLEY_ARRAY_PARAM
17178  #undef JSON_HEDLEY_ASSUME
17179  #undef JSON_HEDLEY_BEGIN_C_DECLS
17180  #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
17181  #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
17182  #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
17183  #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
17184  #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
17185  #undef JSON_HEDLEY_CLANG_HAS_FEATURE
17186  #undef JSON_HEDLEY_CLANG_HAS_WARNING
17187  #undef JSON_HEDLEY_COMPCERT_VERSION
17188  #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
17189  #undef JSON_HEDLEY_CONCAT
17190  #undef JSON_HEDLEY_CONCAT3
17191  #undef JSON_HEDLEY_CONCAT3_EX
17192  #undef JSON_HEDLEY_CONCAT_EX
17193  #undef JSON_HEDLEY_CONST
17194  #undef JSON_HEDLEY_CONSTEXPR
17195  #undef JSON_HEDLEY_CONST_CAST
17196  #undef JSON_HEDLEY_CPP_CAST
17197  #undef JSON_HEDLEY_CRAY_VERSION
17198  #undef JSON_HEDLEY_CRAY_VERSION_CHECK
17199  #undef JSON_HEDLEY_C_DECL
17200  #undef JSON_HEDLEY_DEPRECATED
17201  #undef JSON_HEDLEY_DEPRECATED_FOR
17202  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
17203  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
17204  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
17205  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
17206  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
17207  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
17208  #undef JSON_HEDLEY_DIAGNOSTIC_POP
17209  #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
17210  #undef JSON_HEDLEY_DMC_VERSION
17211  #undef JSON_HEDLEY_DMC_VERSION_CHECK
17212  #undef JSON_HEDLEY_EMPTY_BASES
17213  #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
17214  #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
17215  #undef JSON_HEDLEY_END_C_DECLS
17216  #undef JSON_HEDLEY_FLAGS
17217  #undef JSON_HEDLEY_FLAGS_CAST
17218  #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
17219  #undef JSON_HEDLEY_GCC_HAS_BUILTIN
17220  #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
17221  #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
17222  #undef JSON_HEDLEY_GCC_HAS_EXTENSION
17223  #undef JSON_HEDLEY_GCC_HAS_FEATURE
17224  #undef JSON_HEDLEY_GCC_HAS_WARNING
17225  #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
17226  #undef JSON_HEDLEY_GCC_VERSION
17227  #undef JSON_HEDLEY_GCC_VERSION_CHECK
17228  #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
17229  #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
17230  #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
17231  #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
17232  #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
17233  #undef JSON_HEDLEY_GNUC_HAS_FEATURE
17234  #undef JSON_HEDLEY_GNUC_HAS_WARNING
17235  #undef JSON_HEDLEY_GNUC_VERSION
17236  #undef JSON_HEDLEY_GNUC_VERSION_CHECK
17237  #undef JSON_HEDLEY_HAS_ATTRIBUTE
17238  #undef JSON_HEDLEY_HAS_BUILTIN
17239  #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
17240  #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
17241  #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
17242  #undef JSON_HEDLEY_HAS_EXTENSION
17243  #undef JSON_HEDLEY_HAS_FEATURE
17244  #undef JSON_HEDLEY_HAS_WARNING
17245  #undef JSON_HEDLEY_IAR_VERSION
17246  #undef JSON_HEDLEY_IAR_VERSION_CHECK
17247  #undef JSON_HEDLEY_IBM_VERSION
17248  #undef JSON_HEDLEY_IBM_VERSION_CHECK
17249  #undef JSON_HEDLEY_IMPORT
17250  #undef JSON_HEDLEY_INLINE
17251  #undef JSON_HEDLEY_INTEL_CL_VERSION
17252  #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
17253  #undef JSON_HEDLEY_INTEL_VERSION
17254  #undef JSON_HEDLEY_INTEL_VERSION_CHECK
17255  #undef JSON_HEDLEY_IS_CONSTANT
17256  #undef JSON_HEDLEY_IS_CONSTEXPR_
17257  #undef JSON_HEDLEY_LIKELY
17258  #undef JSON_HEDLEY_MALLOC
17259  #undef JSON_HEDLEY_MCST_LCC_VERSION
17260  #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
17261  #undef JSON_HEDLEY_MESSAGE
17262  #undef JSON_HEDLEY_MSVC_VERSION
17263  #undef JSON_HEDLEY_MSVC_VERSION_CHECK
17264  #undef JSON_HEDLEY_NEVER_INLINE
17265  #undef JSON_HEDLEY_NON_NULL
17266  #undef JSON_HEDLEY_NO_ESCAPE
17267  #undef JSON_HEDLEY_NO_RETURN
17268  #undef JSON_HEDLEY_NO_THROW
17269  #undef JSON_HEDLEY_NULL
17270  #undef JSON_HEDLEY_PELLES_VERSION
17271  #undef JSON_HEDLEY_PELLES_VERSION_CHECK
17272  #undef JSON_HEDLEY_PGI_VERSION
17273  #undef JSON_HEDLEY_PGI_VERSION_CHECK
17274  #undef JSON_HEDLEY_PREDICT
17275  #undef JSON_HEDLEY_PRINTF_FORMAT
17276  #undef JSON_HEDLEY_PRIVATE
17277  #undef JSON_HEDLEY_PUBLIC
17278  #undef JSON_HEDLEY_PURE
17279  #undef JSON_HEDLEY_REINTERPRET_CAST
17280  #undef JSON_HEDLEY_REQUIRE
17281  #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
17282  #undef JSON_HEDLEY_REQUIRE_MSG
17283  #undef JSON_HEDLEY_RESTRICT
17284  #undef JSON_HEDLEY_RETURNS_NON_NULL
17285  #undef JSON_HEDLEY_SENTINEL
17286  #undef JSON_HEDLEY_STATIC_ASSERT
17287  #undef JSON_HEDLEY_STATIC_CAST
17288  #undef JSON_HEDLEY_STRINGIFY
17289  #undef JSON_HEDLEY_STRINGIFY_EX
17290  #undef JSON_HEDLEY_SUNPRO_VERSION
17291  #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
17292  #undef JSON_HEDLEY_TINYC_VERSION
17293  #undef JSON_HEDLEY_TINYC_VERSION_CHECK
17294  #undef JSON_HEDLEY_TI_ARMCL_VERSION
17295  #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
17296  #undef JSON_HEDLEY_TI_CL2000_VERSION
17297  #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
17298  #undef JSON_HEDLEY_TI_CL430_VERSION
17299  #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
17300  #undef JSON_HEDLEY_TI_CL6X_VERSION
17301  #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
17302  #undef JSON_HEDLEY_TI_CL7X_VERSION
17303  #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
17304  #undef JSON_HEDLEY_TI_CLPRU_VERSION
17305  #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
17306  #undef JSON_HEDLEY_TI_VERSION
17307  #undef JSON_HEDLEY_TI_VERSION_CHECK
17308  #undef JSON_HEDLEY_UNAVAILABLE
17309  #undef JSON_HEDLEY_UNLIKELY
17310  #undef JSON_HEDLEY_UNPREDICTABLE
17311  #undef JSON_HEDLEY_UNREACHABLE
17312  #undef JSON_HEDLEY_UNREACHABLE_RETURN
17313  #undef JSON_HEDLEY_VERSION
17314  #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
17315  #undef JSON_HEDLEY_VERSION_DECODE_MINOR
17316  #undef JSON_HEDLEY_VERSION_DECODE_REVISION
17317  #undef JSON_HEDLEY_VERSION_ENCODE
17318  #undef JSON_HEDLEY_WARNING
17319  #undef JSON_HEDLEY_WARN_UNUSED_RESULT
17320  #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
17321  #undef JSON_HEDLEY_FALL_THROUGH
17322  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-json.hpp</div>
                <div class="column column_space"><pre><code>819    }
820    switch (blob_type_) {
821      case BRT_NOISE:
822        return PT_NOISE;
823      case BRT_HLINE:
824        return PT_HORZ_LINE;
825      case BRT_VLINE:
826        return PT_VERT_LINE;
827      case BRT_RECTIMAGE:
828      case BRT_POLYIMAGE:
</pre></code></div>
                <div class="column column_space"><pre><code>8891          }
8892          switch (result_number)
8893          {
8894              case token_type::value_integer:
8895                  return sax->number_integer(number_lexer.get_number_integer());
8896              case token_type::value_unsigned:
8897                  return sax->number_unsigned(number_lexer.get_number_unsigned());
8898              case token_type::value_float:
8899                  return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
8900              case token_type::uninitialized:
8901              case token_type::literal_true:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    