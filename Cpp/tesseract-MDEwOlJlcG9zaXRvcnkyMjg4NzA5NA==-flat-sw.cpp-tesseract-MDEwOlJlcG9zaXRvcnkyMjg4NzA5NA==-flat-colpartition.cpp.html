
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.5683037556747832%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-sw.cpp</h3>
            <pre><code>1  void build(Solution &s)
2  {
3      auto &tess = s.addProject("google.tesseract", "main");
4      tess += Git("https:&bsol;&bsol;github.com/tesseract-ocr/tesseract", "", "{v}");
5      auto cppstd = cpp17;
6      auto &libtesseract = tess.addTarget<LibraryTarget>("libtesseract");
7      {
8          libtesseract.setChecks("libtesseract");
<span onclick='openModal()' class='match'>9          libtesseract.PackageDefinitions = true;
10          libtesseract += cppstd;
11          libtesseract += "TESS_API"_api;
12          libtesseract += "include/.*"_rr;
13          libtesseract += "src/.+/.*"_rr;
14          libtesseract -= "src/lstm/.*\\.cc"_rr;
15          libtesseract -= "src/training/.*"_rr;
16          libtesseract.Public += "include"_idir;
17          libtesseract.Protected +=
</span>18              "src/opencl"_id,
19              "src/ccmain"_id,
20              "src/api"_id,
21              "src/dict"_id,
22              "src/viewer"_id,
23              "src/wordrec"_id,
24              "src/ccstruct"_id,
25              "src/cutil"_id,
26              "src/textord"_id,
27              "src/ccutil"_id,
28              "src/lstm"_id,
29              "src/classify"_id,
30              "src/arch"_id,
31              "src/training"_id;
32          if (libtesseract.getCompilerType() == CompilerType::MSVC ||
33              libtesseract.getCompilerType() == CompilerType::ClangCl)
34          {
35              libtesseract += "__SSE4_1__"_def;
36              libtesseract.CompileOptions.push_back("-arch:AVX2");
37              if (0)
38              {
39                  if (libtesseract.getCompilerType() == CompilerType::MSVC)
40                      libtesseract.CompileOptions.push_back("-openmp");
41                  else
42                      libtesseract.CompileOptions.push_back("-fopenmp");
43                  libtesseract += "_OPENMP=201107"_def;
44                  if (libtesseract.getBuildSettings().Native.ConfigurationType == ConfigurationType::Debug)
45                      libtesseract += "vcompd.lib"_slib;
46                  else
47                      libtesseract += "vcomp.lib"_slib;
48              }
49          }
50          auto win_or_mingw =
51              libtesseract.getBuildSettings().TargetOS.Type == OSType::Windows ||
52              libtesseract.getBuildSettings().TargetOS.Type == OSType::Mingw
53              ;
54          libtesseract -= "src/arch/dotproductfma.cpp";
55          libtesseract -= "src/arch/dotproductneon.cpp";
56          if (libtesseract.getBuildSettings().TargetOS.Type != OSType::Windows &&
57              libtesseract.getBuildSettings().TargetOS.Arch != ArchType::aarch64)
58          {
59              libtesseract["src/arch/dotproductavx.cpp"].args.push_back("-mavx");
60              libtesseract["src/arch/dotproductavx512.cpp"].args.push_back("-mavx512f");
61              libtesseract["src/arch/dotproductsse.cpp"].args.push_back("-msse4.1");
62              libtesseract["src/arch/intsimdmatrixsse.cpp"].args.push_back("-msse4.1");
63              libtesseract["src/arch/intsimdmatrixavx2.cpp"].args.push_back("-mavx2");
64          }
65          if (!win_or_mingw)
66          {
67  #if SW_MODULE_ABI_VERSION > 29
68              if (!libtesseract.getBuildSettings().TargetOS.Android)
69  #endif
70                  libtesseract += "pthread"_slib;
71          }
72          if (libtesseract.getBuildSettings().TargetOS.Arch == ArchType::aarch64)
73          {
74              libtesseract += "src/arch/dotproductneon.cpp";
75          }
76          libtesseract.Public += "HAVE_CONFIG_H"_d;
77          libtesseract.Public += "_SILENCE_STDEXT_HASH_DEPRECATION_WARNINGS=1"_d;
78          libtesseract.Public += "HAVE_LIBARCHIVE"_d;
79          libtesseract.Public += "org.sw.demo.danbloomberg.leptonica"_dep;
80          libtesseract.Public += "org.sw.demo.libarchive.libarchive"_dep;
81          if (win_or_mingw)
82          {
83              libtesseract.Public += "ws2_32.lib"_slib;
84              libtesseract.Protected += "NOMINMAX"_def;
85          }
86          if (libtesseract.getCompilerType() == CompilerType::MSVC)
87              libtesseract.Protected.CompileOptions.push_back("-utf-8");
88          libtesseract.Variables["TESSERACT_MAJOR_VERSION"] = libtesseract.Variables["PACKAGE_MAJOR_VERSION"];
89          libtesseract.Variables["TESSERACT_MINOR_VERSION"] = libtesseract.Variables["PACKAGE_MINOR_VERSION"];
90          libtesseract.Variables["TESSERACT_MICRO_VERSION"] = libtesseract.Variables["PACKAGE_PATCH_VERSION"];
91          libtesseract.Variables["TESSERACT_VERSION_STR"] = "master";
92          libtesseract.configureFile("include/tesseract/version.h.in", "tesseract/version.h");
93      }
94      auto &tesseract = tess.addExecutable("tesseract");
95      {
96          tesseract += cppstd;
97          tesseract += "src/tesseract.cpp";
98          tesseract += libtesseract;
99      }
100      auto &svpaint = tess.addExecutable("svpaint");
101      {
102          svpaint += cppstd;
103          svpaint += "src/svpaint.cpp";
104          svpaint += libtesseract;
105      }
106      auto &training = tess.addDirectory("training");
107      auto &common_training = training.addLibrary("common_training");
108      {
109          common_training += "TESS_COMMON_TRAINING_API"_api;
110          common_training += cppstd;
111          common_training += "src/training/common/.*"_rr;
112          common_training.Public += "src/training/common"_idir;
113          common_training.Public += libtesseract;
114      }
115      auto &unicharset_training = training.addLibrary("unicharset_training");
116      {
117          unicharset_training += "TESS_UNICHARSET_TRAINING_API"_api;
118          unicharset_training += cppstd;
119          unicharset_training += "src/training/unicharset/.*"_rr;
120          unicharset_training.Public += "src/training/unicharset"_idir;
121          unicharset_training.Public += common_training;
122          unicharset_training.Public += "org.sw.demo.unicode.icu.i18n"_dep;
123          auto win_or_mingw =
124            unicharset_training.getBuildSettings().TargetOS.Type == OSType::Windows ||
125            unicharset_training.getBuildSettings().TargetOS.Type == OSType::Mingw
126            ;
127          if (!win_or_mingw)
128            unicharset_training += "pthread"_slib;
129      }
130  #define ADD_EXE(n, ...)                     \
131      auto &n = training.addExecutable(#n);   \
132      n += cppstd;                            \
133      n += "src/training/" #n ".*"_rr;        \
134      n.Public += __VA_ARGS__;                \
135      n
136      ADD_EXE(ambiguous_words, common_training);
137      ADD_EXE(classifier_tester, common_training);
138      ADD_EXE(combine_lang_model, unicharset_training);
139      ADD_EXE(combine_tessdata, common_training);
140      ADD_EXE(cntraining, common_training);
141      ADD_EXE(dawg2wordlist, common_training);
142      ADD_EXE(mftraining, common_training) += "src/training/mergenf.*"_rr;
143      ADD_EXE(shapeclustering, common_training);
144      ADD_EXE(unicharset_extractor, unicharset_training);
145      ADD_EXE(wordlist2dawg, common_training);
146      ADD_EXE(lstmeval, unicharset_training);
147      ADD_EXE(lstmtraining, unicharset_training);
148      ADD_EXE(set_unicharset_properties, unicharset_training);
149      ADD_EXE(merge_unicharsets, common_training);
150      auto &pango_training = training.addLibrary("pango_training");
151      {
152          pango_training += "TESS_PANGO_TRAINING_API"_api;
153          pango_training += cppstd;
154          pango_training += "src/training/pango/.*"_rr;
155          pango_training.Public += "src/training/pango"_idir;
156          pango_training.Public += unicharset_training;
157          pango_training.Public += "org.sw.demo.gnome.pango.pangocairo"_dep;
158      }
159      ADD_EXE(text2image, pango_training);
160      {
161          text2image += cppstd;
162          text2image +=
163              "src/training/degradeimage.cpp",
164              "src/training/degradeimage.h",
165              "src/training/text2image.cpp"
166              ;
167      }
168      if (!s.getExternalVariables()["with-tests"])
169          return;
170      {
171          auto &test = tess.addDirectory("test");
172          test.Scope = TargetScope::Test;
173          String skipped_tests_str;
174          if (s.getExternalVariables()["skip-tests"])
175              skipped_tests_str = s.getExternalVariables()["skip-tests"].getValue();
176          auto skipped_tests = split_string(skipped_tests_str, ",");
177          auto add_test = [&test, &s, &cppstd, &libtesseract, &pango_training, &skipped_tests](const String &name) -> decltype(auto)
178          {
179              auto &t = test.addTarget<ExecutableTarget>(name);
180              t += cppstd;
181              t += FileRegex("unittest", name + "_test.*", false);
182              t += "unittest"_idir;
183              t += "SW_TESTING"_def;
184              auto datadir = test.SourceDir / "tessdata_unittest";
185              if (s.getExternalVariables()["test-data-dir"])
186                  datadir = fs::current_path() / s.getExternalVariables()["test-data-dir"].getValue();
187              t += Definition("TESSBIN_DIR=\"" + ""s + "\"");
188              t += Definition("TESTING_DIR=\"" + to_printable_string(normalize_path(test.SourceDir / "test/testing")) + "\"");
189              t += Definition("TESTDATA_DIR=\"" + to_printable_string(normalize_path(test.SourceDir / "test/testdata")) + "\"");
190              t += Definition("LANGDATA_DIR=\"" + to_printable_string(normalize_path(datadir / "langdata_lstm")) + "\"");
191              t += Definition("TESSDATA_DIR=\"" + to_printable_string(normalize_path(datadir / "tessdata")) + "\"");
192              t += Definition("TESSDATA_BEST_DIR=\"" + to_printable_string(normalize_path(datadir / "tessdata_best")) + "\"");
193              t += pango_training;
194              t += "org.sw.demo.google.googletest.gmock.main"_dep;
195              t += "org.sw.demo.google.googletest.gtest.main"_dep;
196              if (t.getCompilerType() == CompilerType::MSVC)
197                  t.CompileOptions.push_back("-utf-8");
198              auto win_or_mingw =
199                t.getBuildSettings().TargetOS.Type == OSType::Windows ||
200                t.getBuildSettings().TargetOS.Type == OSType::Mingw
201                ;
202              if (!win_or_mingw)
203                t += "pthread"_slib;
204              auto tst = libtesseract.addTest(t, name);
205              for (auto &st : skipped_tests)
206              {
207                  std::regex r(st);
208                  if (std::regex_match(name, r))
209                  {
210                      tst.skip(true);
211                      break;
212                  }
213              }
214              return t;
215          };
216          Strings tests
217          {
218              "apiexample",
219              "applybox",
220              "baseapi",
221              "baseapi_thread",
222              "bitvector",
223              "capiexample",
224              "capiexample_c",
225              "cleanapi",
226              "colpartition",
227              "commandlineflags",
228              "denorm",
229              "equationdetect",
230              "fileio",
231              "heap",
232              "imagedata",
233              "indexmapbidi",
234              "intfeaturemap",
235              "intsimdmatrix",
236              "lang_model",
237              "layout",
238              "ligature_table",
239              "linlsq",
240              "list",
241              "lstm_recode",
242              "lstm_squashed",
243              "lstm",
244              "lstmtrainer",
245              "loadlang",
246              "mastertrainer",
247              "matrix",
248              "networkio",
249              "normstrngs",
250              "nthitem",
251              "osd",
252              "pagesegmode",
253              "pango_font_info",
254              "paragraphs",
255              "params_model",
256              "progress",
257              "qrsequence",
258              "recodebeam",
259              "rect",
260              "resultiterator",
261              "scanutils",
262              "shapetable",
263              "stats",
264              "stringrenderer",
265              "stridemap",
266              "tablefind",
267              "tablerecog",
268              "tabvector",
269              "textlineprojection",
270              "tfile",
271              "unichar",
272              "unicharcompress",
273              "unicharset",
274              "validate_grapheme",
275              "validate_indic",
276              "validate_khmer",
277              "validate_myanmar",
278              "validator",
279          };
280          for (auto t : tests)
281              add_test(t);
282          auto &dt = add_test("dawg");
283          dt += Definition("wordlist2dawg_prog=\"" + to_printable_string(normalize_path(wordlist2dawg.getOutputFile())) + "\"");
284          dt += Definition("dawg2wordlist_prog=\"" + to_printable_string(normalize_path(dawg2wordlist.getOutputFile())) + "\"");
285          auto &tw = add_test("tatweel");
286          tw += "unittest/util/.*"_rr;
287          tw += "unittest/third_party/.*"_rr;
288          tw -= "unittest/third_party/googletest/.*"_rr;
289      }
290  }
291  void check(Checker &c)
292  {
293      auto &s = c.addSet("libtesseract");
294      s.checkFunctionExists("getline");
295      s.checkIncludeExists("dlfcn.h");
296      s.checkIncludeExists("inttypes.h");
297      s.checkIncludeExists("memory.h");
298      s.checkIncludeExists("stdint.h");
299      s.checkIncludeExists("stdlib.h");
300      s.checkIncludeExists("string.h");
301      s.checkIncludeExists("sys/stat.h");
302      s.checkIncludeExists("sys/types.h");
303      s.checkIncludeExists("tiffio.h");
304      s.checkIncludeExists("unistd.h");
305      s.checkTypeSize("long long int");
306      s.checkTypeSize("size_t");
307      s.checkTypeSize("void *");
308      s.checkTypeSize("wchar_t");
309      {
310          auto &c = s.checkSymbolExists("snprintf");
311          c.Parameters.Includes.push_back("stdio.h");
312      }
313  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "colpartition.h"
5  #include "colpartitiongrid.h"
6  #include "colpartitionset.h"
7  #include "detlinefit.h"
8  #include "dppoint.h"
9  #include "helpers.h" 
10  #include "host.h"    
11  #include "imagefind.h"
12  #include "workingpartset.h"
13  #include <algorithm>
14  namespace tesseract {
15  enum SpacingNeighbourhood {
16    PN_ABOVE2,
17    PN_ABOVE1,
18    PN_UPPER,
19    PN_LOWER,
20    PN_BELOW1,
21    PN_BELOW2,
22    PN_COUNT
23  };
24  const double kMaxSpacingDrift = 1.0 / 72; 
25  const double kMaxTopSpacingFraction = 0.25;
26  const double kMaxSameBlockLineSpacing = 3;
27  const double kMaxSizeRatio = 1.5;
28  const double kMaxLeaderGapFractionOfMax = 0.25;
29  const double kMaxLeaderGapFractionOfMin = 0.5;
30  const int kMinLeaderCount = 5;
31  const int kMinStrongTextValue = 6;
32  const int kMinChainTextValue = 3;
33  const int kHorzStrongTextlineCount = 8;
34  const int kHorzStrongTextlineHeight = 10;
35  const int kHorzStrongTextlineAspect = 5;
36  const double kMaxBaselineError = 0.4375;
37  const double kMinBaselineCoverage = 0.5;
38  const int kMaxRMSColorNoise = 128;
39  const int kMaxColorDistance = 900;
40  ColPartition::ColPartition(BlobRegionType blob_type, const ICOORD &vertical)
41      : left_margin_(-INT32_MAX),
42        right_margin_(INT32_MAX),
43        median_bottom_(INT32_MAX),
44        median_top_(-INT32_MAX),
45        median_left_(INT32_MAX),
46        median_right_(-INT32_MAX),
47        blob_type_(blob_type),
48        vertical_(vertical) {
49    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
50  }
51  ColPartition *ColPartition::FakePartition(const TBOX &box,
52                                            PolyBlockType block_type,
53                                            BlobRegionType blob_type,
54                                            BlobTextFlowType flow) {
55    auto *part = new ColPartition(blob_type, ICOORD(0, 1));
56    part->set_type(block_type);
57    part->set_flow(flow);
58    part->AddBox(new BLOBNBOX(C_BLOB::FakeBlob(box)));
59    part->set_left_margin(box.left());
60    part->set_right_margin(box.right());
61    part->SetBlobTypes();
62    part->ComputeLimits();
63    part->ClaimBoxes();
64    return part;
65  }
66  ColPartition *ColPartition::MakeBigPartition(BLOBNBOX *box,
67                                               ColPartition_LIST *big_part_list) {
68    box->set_owner(nullptr);
69    auto *single = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
70    single->set_flow(BTFT_NONE);
71    single->AddBox(box);
72    single->ComputeLimits();
73    single->ClaimBoxes();
74    single->SetBlobTypes();
75    single->set_block_owned(true);
76    if (big_part_list != nullptr) {
77      ColPartition_IT part_it(big_part_list);
78      part_it.add_to_end(single);
79    }
80    return single;
81  }
82  ColPartition::~ColPartition() {
83    ColPartition_C_IT it(&upper_partners_);
84    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
85      it.data()->RemovePartner(false, this);
86    }
87    it.set_to_list(&lower_partners_);
88    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
89      it.data()->RemovePartner(true, this);
90    }
91  }
92  ColPartition *ColPartition::MakeLinePartition(BlobRegionType blob_type,
93                                                const ICOORD &vertical, int left,
94                                                int bottom, int right, int top) {
95    auto *part = new ColPartition(blob_type, vertical);
<span onclick='openModal()' class='match'>96    part->bounding_box_ = TBOX(left, bottom, right, top);
97    part->median_bottom_ = bottom;
98    part->median_top_ = top;
99    part->median_height_ = top - bottom;
100    part->median_left_ = left;
101    part->median_right_ = right;
102    part->median_width_ = right - left;
103    part->left_key_ = part->BoxLeftKey();
104    part->right_key_ = part->BoxRightKey();
</span>105    return part;
106  }
107  void ColPartition::AddBox(BLOBNBOX *bbox) {
108    TBOX box = bbox->bounding_box();
109    if (boxes_.empty()) {
110      bounding_box_ = box;
111    } else {
112      bounding_box_ += box;
113    }
114    if (IsVerticalType()) {
115      if (!last_add_was_vertical_) {
116        boxes_.sort(SortByBoxBottom<BLOBNBOX>);
117        last_add_was_vertical_ = true;
118      }
119      boxes_.add_sorted(SortByBoxBottom<BLOBNBOX>, true, bbox);
120    } else {
121      if (last_add_was_vertical_) {
122        boxes_.sort(SortByBoxLeft<BLOBNBOX>);
123        last_add_was_vertical_ = false;
124      }
125      boxes_.add_sorted(SortByBoxLeft<BLOBNBOX>, true, bbox);
126    }
127    if (!left_key_tab_) {
128      left_key_ = BoxLeftKey();
129    }
130    if (!right_key_tab_) {
131      right_key_ = BoxRightKey();
132    }
133    if (TabFind::WithinTestRegion(2, box.left(), box.bottom())) {
134      tprintf("Added box (%d,%d)->(%d,%d) left_blob_x_=%d, right_blob_x_ = %d\n",
135              box.left(), box.bottom(), box.right(), box.top(),
136              bounding_box_.left(), bounding_box_.right());
137    }
138  }
139  void ColPartition::RemoveBox(BLOBNBOX *box) {
140    BLOBNBOX_C_IT bb_it(&boxes_);
141    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
142      if (box == bb_it.data()) {
143        bb_it.extract();
144        ComputeLimits();
145        return;
146      }
147    }
148  }
149  BLOBNBOX *ColPartition::BiggestBox() {
150    BLOBNBOX *biggest = nullptr;
151    BLOBNBOX_C_IT bb_it(&boxes_);
152    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
153      BLOBNBOX *bbox = bb_it.data();
154      if (IsVerticalType()) {
155        if (biggest == nullptr ||
156            bbox->bounding_box().width() > biggest->bounding_box().width()) {
157          biggest = bbox;
158        }
159      } else {
160        if (biggest == nullptr ||
161            bbox->bounding_box().height() > biggest->bounding_box().height()) {
162          biggest = bbox;
163        }
164      }
165    }
166    return biggest;
167  }
168  TBOX ColPartition::BoundsWithoutBox(BLOBNBOX *box) {
169    TBOX result;
170    BLOBNBOX_C_IT bb_it(&boxes_);
171    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
172      if (box != bb_it.data()) {
173        result += bb_it.data()->bounding_box();
174      }
175    }
176    return result;
177  }
178  void ColPartition::ClaimBoxes() {
179    BLOBNBOX_C_IT bb_it(&boxes_);
180    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
181      BLOBNBOX *bblob = bb_it.data();
182      ColPartition *other = bblob->owner();
183      if (other == nullptr) {
184        bblob->set_owner(this);
185      } else {
186        ASSERT_HOST(other == this);
187      }
188    }
189  }
190  void ColPartition::DisownBoxes() {
191    BLOBNBOX_C_IT bb_it(&boxes_);
192    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
193      BLOBNBOX *bblob = bb_it.data();
194      ASSERT_HOST(bblob->owner() == this || bblob->owner() == nullptr);
195      bblob->set_owner(nullptr);
196    }
197  }
198  void ColPartition::DisownBoxesNoAssert() {
199    BLOBNBOX_C_IT bb_it(&boxes_);
200    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
201      BLOBNBOX *bblob = bb_it.data();
202      if (bblob->owner() == this) {
203        bblob->set_owner(nullptr);
204      }
205    }
206  }
207  bool ColPartition::ReleaseNonLeaderBoxes() {
208    BLOBNBOX_C_IT bb_it(&boxes_);
209    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
210      BLOBNBOX *bblob = bb_it.data();
211      if (bblob->flow() != BTFT_LEADER) {
212        if (bblob->owner() == this) {
213          bblob->set_owner(nullptr);
214        }
215        bb_it.extract();
216      }
217    }
218    if (bb_it.empty()) {
219      return false;
220    }
221    flow_ = BTFT_LEADER;
222    ComputeLimits();
223    return true;
224  }
225  void ColPartition::DeleteBoxes() {
226    for (BLOBNBOX_C_IT bb_it(&boxes_); !bb_it.empty(); bb_it.forward()) {
227      BLOBNBOX *bblob = bb_it.extract();
228      delete bblob->remove_cblob();
229      delete bblob;
230    }
231  }
232  void ColPartition::ReflectInYAxis() {
233    BLOBNBOX_CLIST reversed_boxes;
234    BLOBNBOX_C_IT reversed_it(&reversed_boxes);
235    BLOBNBOX_C_IT bb_it(&boxes_);
236    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
237      reversed_it.add_before_then_move(bb_it.extract());
238    }
239    bb_it.add_list_after(&reversed_boxes);
240    ASSERT_HOST(!left_key_tab_ && !right_key_tab_);
241    int tmp = left_margin_;
242    left_margin_ = -right_margin_;
243    right_margin_ = -tmp;
244    ComputeLimits();
245  }
246  bool ColPartition::IsLegal() {
247    if (bounding_box_.left() > bounding_box_.right()) {
248      if (textord_debug_bugs) {
249        tprintf("Bounding box invalid\n");
250        Print();
251      }
252      return false; 
253    }
254    if (left_margin_ > bounding_box_.left() ||
255        right_margin_ < bounding_box_.right()) {
256      if (textord_debug_bugs) {
257        tprintf("Margins invalid\n");
258        Print();
259      }
260      return false; 
261    }
262    if (left_key_ > BoxLeftKey() || right_key_ < BoxRightKey()) {
263      if (textord_debug_bugs) {
264        tprintf("Key inside box: %d v %d or %d v %d\n", left_key_, BoxLeftKey(),
265                right_key_, BoxRightKey());
266        Print();
267      }
268      return false; 
269    }
270    return true;
271  }
272  bool ColPartition::MatchingColumns(const ColPartition &other) const {
273    int y = (MidY() + other.MidY()) / 2;
274    if (!NearlyEqual(other.LeftAtY(y) / kColumnWidthFactor,
275                     LeftAtY(y) / kColumnWidthFactor, 1)) {
276      return false;
277    }
278    if (!NearlyEqual(other.RightAtY(y) / kColumnWidthFactor,
279                     RightAtY(y) / kColumnWidthFactor, 1)) {
280      return false;
281    }
282    return true;
283  }
284  bool ColPartition::MatchingTextColor(const ColPartition &other) const {
285    if (color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise &&
286        other.color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise) {
287      return false; 
288    }
289    double d_this1_o =
290        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color1_);
291    double d_this2_o =
292        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color2_);
293    double d_o1_this =
294        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color1_);
295    double d_o2_this =
296        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color2_);
297    return d_this1_o < kMaxColorDistance && d_this2_o < kMaxColorDistance &&
298           d_o1_this < kMaxColorDistance && d_o2_this < kMaxColorDistance;
299  }
300  bool ColPartition::MatchingSizes(const ColPartition &other) const {
301    if (blob_type_ == BRT_VERT_TEXT || other.blob_type_ == BRT_VERT_TEXT) {
302      return !TabFind::DifferentSizes(median_width_, other.median_width_);
303    } else {
304      return !TabFind::DifferentSizes(median_height_, other.median_height_);
305    }
306  }
307  bool ColPartition::ConfirmNoTabViolation(const ColPartition &other) const {
308    if (bounding_box_.right() < other.bounding_box_.left() &&
309        bounding_box_.right() < other.LeftBlobRule()) {
310      return false;
311    }
312    if (other.bounding_box_.right() < bounding_box_.left() &&
313        other.bounding_box_.right() < LeftBlobRule()) {
314      return false;
315    }
316    if (bounding_box_.left() > other.bounding_box_.right() &&
317        bounding_box_.left() > other.RightBlobRule()) {
318      return false;
319    }
320    if (other.bounding_box_.left() > bounding_box_.right() &&
321        other.bounding_box_.left() > RightBlobRule()) {
322      return false;
323    }
324    return true;
325  }
326  bool ColPartition::MatchingStrokeWidth(const ColPartition &other,
327                                         double fractional_tolerance,
328                                         double constant_tolerance) const {
329    int match_count = 0;
330    int nonmatch_count = 0;
331    BLOBNBOX_C_IT box_it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
332    BLOBNBOX_C_IT other_it(const_cast<BLOBNBOX_CLIST *>(&other.boxes_));
333    box_it.mark_cycle_pt();
334    other_it.mark_cycle_pt();
335    while (!box_it.cycled_list() && !other_it.cycled_list()) {
336      if (box_it.data()->MatchingStrokeWidth(
337              *other_it.data(), fractional_tolerance, constant_tolerance)) {
338        ++match_count;
339      } else {
340        ++nonmatch_count;
341      }
342      box_it.forward();
343      other_it.forward();
344    }
345    return match_count > nonmatch_count;
346  }
347  bool ColPartition::OKDiacriticMerge(const ColPartition &candidate,
348                                      bool debug) const {
349    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
350    int min_top = INT32_MAX;
351    int max_bottom = -INT32_MAX;
352    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
353      BLOBNBOX *blob = it.data();
354      if (!blob->IsDiacritic()) {
355        if (debug) {
356          tprintf("Blob is not a diacritic:");
357          blob->bounding_box().print();
358        }
359        return false; 
360      }
361      if (blob->base_char_top() < min_top) {
362        min_top = blob->base_char_top();
363      }
364      if (blob->base_char_bottom() > max_bottom) {
365        max_bottom = blob->base_char_bottom();
366      }
367    }
368    bool result =
369        min_top > candidate.median_bottom_ && max_bottom < candidate.median_top_;
370    if (debug) {
371      if (result) {
372        tprintf("OKDiacritic!\n");
373      } else {
374        tprintf("y ranges don\'t overlap: %d-%d / %d-%d\n", max_bottom, min_top,
375                median_bottom_, median_top_);
376      }
377    }
378    return result;
379  }
380  void ColPartition::SetLeftTab(const TabVector *tab_vector) {
381    if (tab_vector != nullptr) {
382      left_key_ = tab_vector->sort_key();
383      left_key_tab_ = left_key_ <= BoxLeftKey();
384    } else {
385      left_key_tab_ = false;
386    }
387    if (!left_key_tab_) {
388      left_key_ = BoxLeftKey();
389    }
390  }
391  void ColPartition::SetRightTab(const TabVector *tab_vector) {
392    if (tab_vector != nullptr) {
393      right_key_ = tab_vector->sort_key();
394      right_key_tab_ = right_key_ >= BoxRightKey();
395    } else {
396      right_key_tab_ = false;
397    }
398    if (!right_key_tab_) {
399      right_key_ = BoxRightKey();
400    }
401  }
402  void ColPartition::CopyLeftTab(const ColPartition &src, bool take_box) {
403    left_key_tab_ = take_box ? false : src.left_key_tab_;
404    if (left_key_tab_) {
405      left_key_ = src.left_key_;
406    } else {
407      bounding_box_.set_left(XAtY(src.BoxLeftKey(), MidY()));
408      left_key_ = BoxLeftKey();
409    }
410    if (left_margin_ > bounding_box_.left()) {
411      left_margin_ = src.left_margin_;
412    }
413  }
414  void ColPartition::CopyRightTab(const ColPartition &src, bool take_box) {
415    right_key_tab_ = take_box ? false : src.right_key_tab_;
416    if (right_key_tab_) {
417      right_key_ = src.right_key_;
418    } else {
419      bounding_box_.set_right(XAtY(src.BoxRightKey(), MidY()));
420      right_key_ = BoxRightKey();
421    }
422    if (right_margin_ < bounding_box_.right()) {
423      right_margin_ = src.right_margin_;
424    }
425  }
426  int ColPartition::LeftBlobRule() const {
427    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
428    return it.data()->left_rule();
429  }
430  int ColPartition::RightBlobRule() const {
431    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
432    it.move_to_last();
433    return it.data()->right_rule();
434  }
435  float ColPartition::SpecialBlobsDensity(const BlobSpecialTextType type) const {
436    ASSERT_HOST(type < BSTT_COUNT);
437    return special_blobs_densities_[type];
438  }
439  int ColPartition::SpecialBlobsCount(const BlobSpecialTextType type) {
440    ASSERT_HOST(type < BSTT_COUNT);
441    BLOBNBOX_C_IT blob_it(&boxes_);
442    int count = 0;
443    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
444      BLOBNBOX *blob = blob_it.data();
445      BlobSpecialTextType blob_type = blob->special_text_type();
446      if (blob_type == type) {
447        count++;
448      }
449    }
450    return count;
451  }
452  void ColPartition::SetSpecialBlobsDensity(const BlobSpecialTextType type,
453                                            const float density) {
454    ASSERT_HOST(type < BSTT_COUNT);
455    special_blobs_densities_[type] = density;
456  }
457  void ColPartition::ComputeSpecialBlobsDensity() {
458    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
459    if (boxes_.empty()) {
460      return;
461    }
462    BLOBNBOX_C_IT blob_it(&boxes_);
463    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
464      BLOBNBOX *blob = blob_it.data();
465      BlobSpecialTextType type = blob->special_text_type();
466      special_blobs_densities_[type]++;
467    }
468    for (float &special_blobs_density : special_blobs_densities_) {
469      special_blobs_density /= boxes_.length();
470    }
471  }
472  void ColPartition::AddPartner(bool upper, ColPartition *partner) {
473    if (upper) {
474      partner->lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
475                                          this);
476      upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
477    } else {
478      partner->upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
479                                          this);
480      lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
481    }
482  }
483  void ColPartition::RemovePartner(bool upper, ColPartition *partner) {
484    ColPartition_C_IT it(upper ? &upper_partners_ : &lower_partners_);
485    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
486      if (it.data() == partner) {
487        it.extract();
488        break;
489      }
490    }
491  }
492  ColPartition *ColPartition::SingletonPartner(bool upper) {
493    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
494    if (!partners->singleton()) {
495      return nullptr;
496    }
497    ColPartition_C_IT it(partners);
498    return it.data();
499  }
500  void ColPartition::Absorb(ColPartition *other, const WidthCallback &cb) {
501    ASSERT_HOST(owns_blobs() == other->owns_blobs());
502    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
503                                  bounding_box_.bottom()) ||
504        TabFind::WithinTestRegion(2, other->bounding_box_.left(),
505                                  other->bounding_box_.bottom())) {
506      tprintf("Merging:");
507      Print();
508      other->Print();
509    }
510    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
511    for (int type = 0; type < BSTT_COUNT; ++type) {
512      unsigned w1 = boxes_.length();
513      unsigned w2 = other->boxes_.length();
514      float new_val = special_blobs_densities_[type] * w1 +
515                      other->special_blobs_densities_[type] * w2;
516      if (!w1 || !w2) {
517        ASSERT_HOST((w1 + w2) > 0);
518        special_blobs_densities_[type] = new_val / (w1 + w2);
519      }
520    }
521    BLOBNBOX_C_IT it(&boxes_);
522    BLOBNBOX_C_IT it2(&other->boxes_);
523    for (; !it2.empty(); it2.forward()) {
524      BLOBNBOX *bbox2 = it2.extract();
525      ColPartition *prev_owner = bbox2->owner();
526      if (prev_owner != other && prev_owner != nullptr) {
527        continue;
528      }
529      ASSERT_HOST(prev_owner == other || prev_owner == nullptr);
530      if (prev_owner == other) {
531        bbox2->set_owner(this);
532      }
533      it.add_to_end(bbox2);
534    }
535    left_margin_ = std::min(left_margin_, other->left_margin_);
536    right_margin_ = std::max(right_margin_, other->right_margin_);
537    if (other->left_key_ < left_key_) {
538      left_key_ = other->left_key_;
539      left_key_tab_ = other->left_key_tab_;
540    }
541    if (other->right_key_ > right_key_) {
542      right_key_ = other->right_key_;
543      right_key_tab_ = other->right_key_tab_;
544    }
545    if (!DominatesInMerge(flow_, other->flow_)) {
546      flow_ = other->flow_;
547      blob_type_ = other->blob_type_;
548    }
549    SetBlobTypes();
550    if (IsVerticalType()) {
551      boxes_.sort(SortByBoxBottom<BLOBNBOX>);
552      last_add_was_vertical_ = true;
553    } else {
554      boxes_.sort(SortByBoxLeft<BLOBNBOX>);
555      last_add_was_vertical_ = false;
556    }
557    ComputeLimits();
558    for (int upper = 0; upper < 2; ++upper) {
559      ColPartition_CLIST partners;
560      ColPartition_C_IT part_it(&partners);
561      part_it.add_list_after(upper ? &other->upper_partners_
562                                   : &other->lower_partners_);
563      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
564        ColPartition *partner = part_it.extract();
565        partner->RemovePartner(!upper, other);
566        partner->RemovePartner(!upper, this);
567        partner->AddPartner(!upper, this);
568      }
569    }
570    delete other;
571    if (cb != nullptr) {
572      SetColumnGoodness(cb);
573    }
574  }
575  bool ColPartition::OKMergeOverlap(const ColPartition &merge1,
576                                    const ColPartition &merge2,
577                                    int ok_box_overlap, bool debug) {
578    if (IsVerticalType() || merge1.IsVerticalType() || merge2.IsVerticalType()) {
579      if (debug) {
580        tprintf("Vertical partition\n");
581      }
582      return false;
583    }
584    if (!merge1.VSignificantCoreOverlap(merge2)) {
585      if (debug) {
586        tprintf("Voverlap %d (%d)\n", merge1.VCoreOverlap(merge2),
587                merge1.VSignificantCoreOverlap(merge2));
588      }
589      return false;
590    }
591    TBOX merged_box(merge1.bounding_box());
592    merged_box += merge2.bounding_box();
593    if (merged_box.bottom() < median_top_ && merged_box.top() > median_bottom_ &&
594        merged_box.bottom() < bounding_box_.top() - ok_box_overlap &&
595        merged_box.top() > bounding_box_.bottom() + ok_box_overlap) {
596      if (debug) {
597        tprintf("Excessive box overlap\n");
598      }
599      return false;
600    }
601    return true;
602  }
603  BLOBNBOX *ColPartition::OverlapSplitBlob(const TBOX &box) {
604    if (boxes_.empty() || boxes_.singleton()) {
605      return nullptr;
606    }
607    BLOBNBOX_C_IT it(&boxes_);
608    TBOX left_box(it.data()->bounding_box());
609    for (it.forward(); !it.at_first(); it.forward()) {
610      BLOBNBOX *bbox = it.data();
611      left_box += bbox->bounding_box();
612      if (left_box.overlap(box)) {
613        return bbox;
614      }
615    }
616    return nullptr;
617  }
618  ColPartition *ColPartition::SplitAtBlob(BLOBNBOX *split_blob) {
619    ColPartition *split_part = ShallowCopy();
620    split_part->set_owns_blobs(owns_blobs());
621    BLOBNBOX_C_IT it(&boxes_);
622    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
623      BLOBNBOX *bbox = it.data();
624      ColPartition *prev_owner = bbox->owner();
625      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
626      if (bbox == split_blob || !split_part->boxes_.empty()) {
627        split_part->AddBox(it.extract());
628        if (owns_blobs() && prev_owner != nullptr) {
629          bbox->set_owner(split_part);
630        }
631      }
632    }
633    ASSERT_HOST(!it.empty());
634    if (split_part->IsEmpty()) {
635      delete split_part;
636      return nullptr;
637    }
638    right_key_tab_ = false;
639    split_part->left_key_tab_ = false;
640    ComputeLimits();
641    split_part->ComputeLimits();
642    return split_part;
643  }
644  ColPartition *ColPartition::SplitAt(int split_x) {
645    if (split_x <= bounding_box_.left() || split_x >= bounding_box_.right()) {
646      return nullptr; 
647    }
648    ColPartition *split_part = ShallowCopy();
649    split_part->set_owns_blobs(owns_blobs());
650    BLOBNBOX_C_IT it(&boxes_);
651    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
652      BLOBNBOX *bbox = it.data();
653      ColPartition *prev_owner = bbox->owner();
654      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
655      const TBOX &box = bbox->bounding_box();
656      if (box.left() >= split_x) {
657        split_part->AddBox(it.extract());
658        if (owns_blobs() && prev_owner != nullptr) {
659          bbox->set_owner(split_part);
660        }
661      }
662    }
663    if (it.empty()) {
664      it.add_list_after(&split_part->boxes_);
665    }
666    ASSERT_HOST(!it.empty());
667    if (split_part->IsEmpty()) {
668      delete split_part;
669      return nullptr;
670    }
671    right_key_tab_ = false;
672    split_part->left_key_tab_ = false;
673    right_margin_ = split_x;
674    split_part->left_margin_ = split_x;
675    ComputeLimits();
676    split_part->ComputeLimits();
677    return split_part;
678  }
679  void ColPartition::ComputeLimits() {
680    bounding_box_ = TBOX(); 
681    BLOBNBOX_C_IT it(&boxes_);
682    BLOBNBOX *bbox = nullptr;
683    int non_leader_count = 0;
684    if (it.empty()) {
685      bounding_box_.set_left(left_margin_);
686      bounding_box_.set_right(right_margin_);
687      bounding_box_.set_bottom(0);
688      bounding_box_.set_top(0);
689    } else {
690      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
691        bbox = it.data();
692        bounding_box_ += bbox->bounding_box();
693        if (bbox->flow() != BTFT_LEADER) {
694          ++non_leader_count;
695        }
696      }
697    }
698    if (!left_key_tab_) {
699      left_key_ = BoxLeftKey();
700    }
701    if (left_key_ > BoxLeftKey() && textord_debug_bugs) {
702      tprintf("Computed left-illegal partition\n");
703      Print();
704    }
705    if (!right_key_tab_) {
706      right_key_ = BoxRightKey();
707    }
708    if (right_key_ < BoxRightKey() && textord_debug_bugs) {
709      tprintf("Computed right-illegal partition\n");
710      Print();
711    }
712    if (it.empty()) {
713      return;
714    }
715    if (IsImageType() || blob_type() == BRT_RECTIMAGE ||
716        blob_type() == BRT_POLYIMAGE) {
717      median_top_ = bounding_box_.top();
718      median_bottom_ = bounding_box_.bottom();
719      median_height_ = bounding_box_.height();
720      median_left_ = bounding_box_.left();
721      median_right_ = bounding_box_.right();
722      median_width_ = bounding_box_.width();
723    } else {
724      STATS top_stats(bounding_box_.bottom(), bounding_box_.top());
725      STATS bottom_stats(bounding_box_.bottom(), bounding_box_.top());
726      STATS height_stats(0, bounding_box_.height());
727      STATS left_stats(bounding_box_.left(), bounding_box_.right());
728      STATS right_stats(bounding_box_.left(), bounding_box_.right());
729      STATS width_stats(0, bounding_box_.width());
730      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
731        bbox = it.data();
732        if (non_leader_count == 0 || bbox->flow() != BTFT_LEADER) {
733          const TBOX &box = bbox->bounding_box();
734          int area = box.area();
735          top_stats.add(box.top(), area);
736          bottom_stats.add(box.bottom(), area);
737          height_stats.add(box.height(), area);
738          left_stats.add(box.left(), area);
739          right_stats.add(box.right(), area);
740          width_stats.add(box.width(), area);
741        }
742      }
743      median_top_ = static_cast<int>(top_stats.median() + 0.5);
744      median_bottom_ = static_cast<int>(bottom_stats.median() + 0.5);
745      median_height_ = static_cast<int>(height_stats.median() + 0.5);
746      median_left_ = static_cast<int>(left_stats.median() + 0.5);
747      median_right_ = static_cast<int>(right_stats.median() + 0.5);
748      median_width_ = static_cast<int>(width_stats.median() + 0.5);
749    }
750    if (right_margin_ < bounding_box_.right() && textord_debug_bugs) {
751      tprintf("Made partition with bad right coords, %d < %d\n", right_margin_,
752              bounding_box_.right());
753      Print();
754    }
755    if (left_margin_ > bounding_box_.left() && textord_debug_bugs) {
756      tprintf("Made partition with bad left coords, %d > %d\n", left_margin_,
757              bounding_box_.left());
758      Print();
759    }
760    for (int upper = 0; upper < 2; ++upper) {
761      ColPartition_CLIST partners;
762      ColPartition_C_IT part_it(&partners);
763      part_it.add_list_after(upper ? &upper_partners_ : &lower_partners_);
764      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
765        ColPartition *partner = part_it.extract();
766        partner->RemovePartner(!upper, this);
767        partner->AddPartner(!upper, this);
768      }
769    }
770    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
771                                  bounding_box_.bottom())) {
772      tprintf("Recomputed box for partition %p\n", static_cast<void *>(this));
773      Print();
774    }
775  }
776  int ColPartition::CountOverlappingBoxes(const TBOX &box) {
777    BLOBNBOX_C_IT it(&boxes_);
778    int overlap_count = 0;
779    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
780      BLOBNBOX *bbox = it.data();
781      if (box.overlap(bbox->bounding_box())) {
782        ++overlap_count;
783      }
784    }
785    return overlap_count;
786  }
787  void ColPartition::SetPartitionType(int resolution, ColPartitionSet *columns) {
788    int first_spanned_col = -1;
789    ColumnSpanningType span_type = columns->SpanningType(
790        resolution, bounding_box_.left(), bounding_box_.right(),
791        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
792        left_margin_, right_margin_, &first_column_, &last_column_,
793        &first_spanned_col);
794    column_set_ = columns;
795    if (first_column_ < last_column_ && span_type == CST_PULLOUT &&
796        !IsLineType()) {
797      if (first_spanned_col >= 0) {
798        first_column_ = first_spanned_col;
799        last_column_ = first_spanned_col;
800      } else {
801        if ((first_column_ & 1) == 0) {
802          last_column_ = first_column_;
803        } else if ((last_column_ & 1) == 0) {
804          first_column_ = last_column_;
805        } else {
806          first_column_ = last_column_ = (first_column_ + last_column_) / 2;
807        }
808      }
809    }
810    type_ = PartitionType(span_type);
811  }
812  PolyBlockType ColPartition::PartitionType(ColumnSpanningType flow) const {
813    if (flow == CST_NOISE) {
814      if (blob_type_ != BRT_HLINE && blob_type_ != BRT_VLINE &&
815          blob_type_ != BRT_RECTIMAGE && blob_type_ != BRT_VERT_TEXT) {
816        return PT_NOISE;
817      }
818      flow = CST_FLOWING;
819    }
820    switch (blob_type_) {
821      case BRT_NOISE:
822        return PT_NOISE;
823      case BRT_HLINE:
824        return PT_HORZ_LINE;
825      case BRT_VLINE:
826        return PT_VERT_LINE;
827      case BRT_RECTIMAGE:
828      case BRT_POLYIMAGE:
829        switch (flow) {
830          case CST_FLOWING:
831            return PT_FLOWING_IMAGE;
832          case CST_HEADING:
833            return PT_HEADING_IMAGE;
834          case CST_PULLOUT:
835            return PT_PULLOUT_IMAGE;
836          default:
837            ASSERT_HOST(!"Undefined flow type for image!");
838        }
839        break;
840      case BRT_VERT_TEXT:
841        return PT_VERTICAL_TEXT;
842      case BRT_TEXT:
843      case BRT_UNKNOWN:
844      default:
845        switch (flow) {
846          case CST_FLOWING:
847            return PT_FLOWING_TEXT;
848          case CST_HEADING:
849            return PT_HEADING_TEXT;
850          case CST_PULLOUT:
851            return PT_PULLOUT_TEXT;
852          default:
853            ASSERT_HOST(!"Undefined flow type for text!");
854        }
855    }
856    ASSERT_HOST(!"Should never get here!");
857    return PT_NOISE;
858  }
859  void ColPartition::ColumnRange(int resolution, ColPartitionSet *columns,
860                                 int *first_col, int *last_col) {
861    int first_spanned_col = -1;
862    ColumnSpanningType span_type = columns->SpanningType(
863        resolution, bounding_box_.left(), bounding_box_.right(),
864        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
865        left_margin_, right_margin_, first_col, last_col, &first_spanned_col);
866    type_ = PartitionType(span_type);
867  }
868  void ColPartition::SetColumnGoodness(const WidthCallback &cb) {
869    int y = MidY();
870    int width = RightAtY(y) - LeftAtY(y);
871    good_width_ = cb(width);
872    good_column_ = blob_type_ == BRT_TEXT && left_key_tab_ && right_key_tab_;
873  }
874  bool ColPartition::MarkAsLeaderIfMonospaced() {
875    bool result = false;
876    int part_width = bounding_box_.width();
877    STATS gap_stats(0, part_width - 1);
878    STATS width_stats(0, part_width - 1);
879    BLOBNBOX_C_IT it(&boxes_);
880    BLOBNBOX *prev_blob = it.data();
881    prev_blob->set_flow(BTFT_NEIGHBOURS);
882    width_stats.add(prev_blob->bounding_box().width(), 1);
883    int blob_count = 1;
884    for (it.forward(); !it.at_first(); it.forward()) {
885      BLOBNBOX *blob = it.data();
886      int left = blob->bounding_box().left();
887      int right = blob->bounding_box().right();
888      gap_stats.add(left - prev_blob->bounding_box().right(), 1);
889      width_stats.add(right - left, 1);
890      blob->set_flow(BTFT_NEIGHBOURS);
891      prev_blob = blob;
892      ++blob_count;
893    }
894    double median_gap = gap_stats.median();
895    double median_width = width_stats.median();
896    double max_width = std::max(median_gap, median_width);
897    double min_width = std::min(median_gap, median_width);
898    double gap_iqr = gap_stats.ile(0.75f) - gap_stats.ile(0.25f);
899    if (textord_debug_tabfind >= 4) {
900      tprintf("gap iqr = %g, blob_count=%d, limits=%g,%g\n", gap_iqr, blob_count,
901              max_width * kMaxLeaderGapFractionOfMax,
902              min_width * kMaxLeaderGapFractionOfMin);
903    }
904    if (gap_iqr < max_width * kMaxLeaderGapFractionOfMax &&
905        gap_iqr < min_width * kMaxLeaderGapFractionOfMin &&
906        blob_count >= kMinLeaderCount) {
907      int offset = static_cast<int>(ceil(gap_iqr * 2));
908      int min_step = static_cast<int>(median_gap + median_width + 0.5);
909      int max_step = min_step + offset;
910      min_step -= offset;
911      int part_left = bounding_box_.left() - min_step / 2;
912      part_width += min_step;
913      auto *projection = new DPPoint[part_width];
914      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
915        BLOBNBOX *blob = it.data();
916        int left = blob->bounding_box().left();
917        int right = blob->bounding_box().right();
918        int height = blob->bounding_box().height();
919        for (int x = left; x < right; ++x) {
920          projection[left - part_left].AddLocalCost(height);
921        }
922      }
923      DPPoint *best_end =
924          DPPoint::Solve(min_step, max_step, false, &DPPoint::CostWithVariance,
925                         part_width, projection);
926      if (best_end != nullptr && best_end->total_cost() < blob_count) {
927        result = true;
928        bool modified_blob_list = false;
929        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
930          BLOBNBOX *blob = it.data();
931          if (it.at_first()) {
932            int gap = it.data_relative(1)->bounding_box().left() -
933                      blob->bounding_box().right();
934            if (blob->bounding_box().width() + gap > max_step) {
935              it.extract();
936              modified_blob_list = true;
937              continue;
938            }
939          }
940          if (it.at_last()) {
941            int gap = blob->bounding_box().left() -
942                      it.data_relative(-1)->bounding_box().right();
943            if (blob->bounding_box().width() + gap > max_step) {
944              it.extract();
945              modified_blob_list = true;
946              break;
947            }
948          }
949          blob->set_region_type(BRT_TEXT);
950          blob->set_flow(BTFT_LEADER);
951        }
952        if (modified_blob_list) {
953          ComputeLimits();
954        }
955        blob_type_ = BRT_TEXT;
956        flow_ = BTFT_LEADER;
957      } else if (textord_debug_tabfind) {
958        if (best_end == nullptr) {
959          tprintf("No path\n");
960        } else {
961          tprintf("Total cost = %d vs allowed %d\n", best_end->total_cost(),
962                  blob_count);
963        }
964      }
965      delete[] projection;
966    }
967    return result;
968  }
969  void ColPartition::SetRegionAndFlowTypesFromProjectionValue(int value) {
970    int blob_count = 0;       
971    int good_blob_score_ = 0; 
972    int noisy_count = 0;      
973    int hline_count = 0;
974    int vline_count = 0;
975    BLOBNBOX_C_IT it(&boxes_);
976    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
977      BLOBNBOX *blob = it.data();
978      ++blob_count;
979      noisy_count += blob->NoisyNeighbours();
980      good_blob_score_ += blob->GoodTextBlob();
981      if (blob->region_type() == BRT_HLINE) {
982        ++hline_count;
983      }
984      if (blob->region_type() == BRT_VLINE) {
985        ++vline_count;
986      }
987    }
988    flow_ = BTFT_NEIGHBOURS;
989    blob_type_ = BRT_UNKNOWN;
990    if (hline_count > vline_count) {
991      flow_ = BTFT_NONE;
992      blob_type_ = BRT_HLINE;
993    } else if (vline_count > hline_count) {
994      flow_ = BTFT_NONE;
995      blob_type_ = BRT_VLINE;
996    } else if (value < -1 || 1 < value) {
997      int long_side;
998      int short_side;
999      if (value > 0) {
1000        long_side = bounding_box_.width();
1001        short_side = bounding_box_.height();
1002        blob_type_ = BRT_TEXT;
1003      } else {
1004        long_side = bounding_box_.height();
1005        short_side = bounding_box_.width();
1006        blob_type_ = BRT_VERT_TEXT;
1007      }
1008      int strong_score = blob_count >= kHorzStrongTextlineCount ? 1 : 0;
1009      if (short_side > kHorzStrongTextlineHeight) {
1010        ++strong_score;
1011      }
1012      if (short_side * kHorzStrongTextlineAspect < long_side) {
1013        ++strong_score;
1014      }
1015      if (abs(value) >= kMinStrongTextValue) {
1016        flow_ = BTFT_STRONG_CHAIN;
1017      } else if (abs(value) >= kMinChainTextValue) {
1018        flow_ = BTFT_CHAIN;
1019      } else {
1020        flow_ = BTFT_NEIGHBOURS;
1021      }
1022      if (flow_ == BTFT_CHAIN && strong_score == 3) {
1023        flow_ = BTFT_STRONG_CHAIN;
1024      }
1025      if (flow_ == BTFT_STRONG_CHAIN && value < 0 && strong_score < 2) {
1026        flow_ = BTFT_CHAIN;
1027      }
1028    }
1029    if (flow_ == BTFT_NEIGHBOURS) {
1030      if (noisy_count >= blob_count) {
1031        flow_ = BTFT_NONTEXT;
1032        blob_type_ = BRT_NOISE;
1033      }
1034    }
1035    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
1036                                  bounding_box_.bottom())) {
1037      tprintf("RegionFlowTypesFromProjectionValue count=%d, noisy=%d, score=%d,",
1038              blob_count, noisy_count, good_blob_score_);
1039      tprintf(" Projection value=%d, flow=%d, blob_type=%d\n", value, flow_,
1040              blob_type_);
1041      Print();
1042    }
1043    SetBlobTypes();
1044  }
1045  void ColPartition::SetBlobTypes() {
1046    if (!owns_blobs()) {
1047      return;
1048    }
1049    BLOBNBOX_C_IT it(&boxes_);
1050    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1051      BLOBNBOX *blob = it.data();
1052      if (blob->flow() != BTFT_LEADER) {
1053        blob->set_flow(flow_);
1054      }
1055      blob->set_region_type(blob_type_);
1056      ASSERT_HOST(blob->owner() == nullptr || blob->owner() == this);
1057    }
1058  }
1059  bool ColPartition::HasGoodBaseline() {
1060    DetLineFit linepoints;
1061    int total_height = 0;
1062    int coverage = 0;
1063    int height_count = 0;
1064    int width = 0;
1065    BLOBNBOX_C_IT it(&boxes_);
1066    TBOX box(it.data()->bounding_box());
1067    if (IsVerticalType()) {
1068      ICOORD first_pt(box.right(), box.bottom());
1069      linepoints.Add(first_pt);
1070      for (it.forward(); !it.at_last(); it.forward()) {
1071        BLOBNBOX *blob = it.data();
1072        box = blob->bounding_box();
1073        ICOORD box_pt(box.right(), (box.top() + box.bottom()) / 2);
1074        linepoints.Add(box_pt);
1075        total_height += box.width();
1076        coverage += box.height();
1077        ++height_count;
1078      }
1079      box = it.data()->bounding_box();
1080      ICOORD last_pt(box.right(), box.top());
1081      linepoints.Add(last_pt);
1082      width = last_pt.y() - first_pt.y();
1083    } else {
1084      TBOX box(it.data()->bounding_box());
1085      ICOORD first_pt(box.left(), box.bottom());
1086      linepoints.Add(first_pt);
1087      for (it.forward(); !it.at_last(); it.forward()) {
1088        BLOBNBOX *blob = it.data();
1089        box = blob->bounding_box();
1090        ICOORD box_pt((box.left() + box.right()) / 2, box.bottom());
1091        linepoints.Add(box_pt);
1092        total_height += box.height();
1093        coverage += box.width();
1094        ++height_count;
1095      }
1096      box = it.data()->bounding_box();
1097      ICOORD last_pt(box.right(), box.bottom());
1098      linepoints.Add(last_pt);
1099      width = last_pt.x() - first_pt.x();
1100    }
1101    if (height_count == 0) {
1102      return false;
1103    }
1104    double max_error = kMaxBaselineError * total_height / height_count;
1105    ICOORD start_pt, end_pt;
1106    double error = linepoints.Fit(&start_pt, &end_pt);
1107    return error < max_error && coverage >= kMinBaselineCoverage * width;
1108  }
1109  void ColPartition::AddToWorkingSet(const ICOORD &bleft, const ICOORD &tright,
1110                                     int resolution,
1111                                     ColPartition_LIST *used_parts,
1112                                     WorkingPartSet_LIST *working_sets) {
1113    if (block_owned_) {
1114      return; 
1115    }
1116    block_owned_ = true;
1117    WorkingPartSet_IT it(working_sets);
1118    ColPartition *partner = SingletonPartner(true);
1119    if (partner != nullptr && partner->working_set_ != nullptr) {
1120      working_set_ = partner->working_set_;
1121      working_set_->AddPartition(this);
1122      return;
1123    }
1124    if (partner != nullptr && textord_debug_bugs) {
1125      tprintf("Partition with partner has no working set!:");
1126      Print();
1127      partner->Print();
1128    }
1129    WorkingPartSet *work_set = nullptr;
1130    it.move_to_first();
1131    int col_index = 0;
1132    for (it.mark_cycle_pt(); !it.cycled_list() && col_index != first_column_;
1133         it.forward(), ++col_index) {
1134      ;
1135    }
1136    if (textord_debug_tabfind >= 2) {
1137      tprintf("Match is %s for:", (col_index & 1) ? "Real" : "Between");
1138      Print();
1139    }
1140    if (it.cycled_list() && textord_debug_bugs) {
1141      tprintf("Target column=%d, only had %d\n", first_column_, col_index);
1142    }
1143    ASSERT_HOST(!it.cycled_list());
1144    work_set = it.data();
1145    if (!it.cycled_list() && last_column_ != first_column_ && !IsPulloutType()) {
1146      BLOCK_LIST completed_blocks;
1147      TO_BLOCK_LIST to_blocks;
1148      for (; !it.cycled_list() && col_index <= last_column_;
1149           it.forward(), ++col_index) {
1150        WorkingPartSet *end_set = it.data();
1151        end_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
1152                                        &completed_blocks, &to_blocks);
1153      }
1154      work_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
1155    }
1156    working_set_ = work_set;
1157    work_set->AddPartition(this);
1158  }
1159  void ColPartition::LineSpacingBlocks(const ICOORD &bleft, const ICOORD &tright,
1160                                       int resolution,
1161                                       ColPartition_LIST *block_parts,
1162                                       ColPartition_LIST *used_parts,
1163                                       BLOCK_LIST *completed_blocks,
1164                                       TO_BLOCK_LIST *to_blocks) {
1165    int page_height = tright.y() - bleft.y();
1166    ColPartition_IT it(block_parts);
1167    int part_count = 0;
1168    int max_line_height = 0;
1169    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1170      ColPartition *part = it.data();
1171      ASSERT_HOST(!part->boxes()->empty());
1172      STATS side_steps(0, part->bounding_box().height() - 1);
1173      if (part->bounding_box().height() > max_line_height) {
1174        max_line_height = part->bounding_box().height();
1175      }
1176      BLOBNBOX_C_IT blob_it(part->boxes());
1177      int prev_bottom = blob_it.data()->bounding_box().bottom();
1178      for (blob_it.forward(); !blob_it.at_first(); blob_it.forward()) {
1179        BLOBNBOX *blob = blob_it.data();
1180        int bottom = blob->bounding_box().bottom();
1181        int step = bottom - prev_bottom;
1182        if (step < 0) {
1183          step = -step;
1184        }
1185        side_steps.add(step, 1);
1186        prev_bottom = bottom;
1187      }
1188      part->set_side_step(static_cast<int>(side_steps.median() + 0.5));
1189      if (!it.at_last()) {
1190        ColPartition *next_part = it.data_relative(1);
1191        part->set_bottom_spacing(part->median_bottom() -
1192                                 next_part->median_bottom());
1193        part->set_top_spacing(part->median_top() - next_part->median_top());
1194      } else {
1195        part->set_bottom_spacing(page_height);
1196        part->set_top_spacing(page_height);
1197      }
1198      if (textord_debug_tabfind) {
1199        part->Print();
1200        tprintf("side step = %.2f, top spacing = %d, bottom spacing=%d\n",
1201                side_steps.median(), part->top_spacing(), part->bottom_spacing());
1202      }
1203      ++part_count;
1204    }
1205    if (part_count == 0) {
1206      return;
1207    }
1208    SmoothSpacings(resolution, page_height, block_parts);
1209    BLOCK_IT block_it(completed_blocks);
1210    TO_BLOCK_IT to_block_it(to_blocks);
1211    ColPartition_LIST spacing_parts;
1212    ColPartition_IT sp_block_it(&spacing_parts);
1213    int same_block_threshold = max_line_height * kMaxSameBlockLineSpacing;
1214    for (it.mark_cycle_pt(); !it.empty();) {
1215      ColPartition *part = it.extract();
1216      sp_block_it.add_to_end(part);
1217      it.forward();
1218      if (it.empty() || part->bottom_spacing() > same_block_threshold ||
1219          !part->SpacingsEqual(*it.data(), resolution)) {
1220        if (!it.empty() && part->bottom_spacing() <= same_block_threshold) {
1221          ColPartition *next_part = it.data();
1222          ColPartition *third_part = it.at_last() ? nullptr : it.data_relative(1);
1223          if (textord_debug_tabfind) {
1224            tprintf(
1225                "Spacings unequal: upper:%d/%d, lower:%d/%d,"
1226                " sizes %d %d %d\n",
1227                part->top_spacing(), part->bottom_spacing(),
1228                next_part->top_spacing(), next_part->bottom_spacing(),
1229                part->median_height(), next_part->median_height(),
1230                third_part != nullptr ? third_part->median_height() : 0);
1231          }
1232          if (part->SizesSimilar(*next_part) &&
1233              next_part->median_height() * kMaxSameBlockLineSpacing >
1234                  part->bottom_spacing() &&
1235              part->median_height() * kMaxSameBlockLineSpacing >
1236                  part->top_spacing()) {
1237            if (third_part == nullptr || !next_part->SizesSimilar(*third_part) ||
1238                third_part->median_height() * kMaxSameBlockLineSpacing <=
1239                    next_part->bottom_spacing() ||
1240                next_part->median_height() * kMaxSameBlockLineSpacing <=
1241                    next_part->top_spacing() ||
1242                next_part->bottom_spacing() > part->bottom_spacing()) {
1243              sp_block_it.add_to_end(it.extract());
1244              it.forward();
1245              if (textord_debug_tabfind) {
1246                tprintf("Added line to current block.\n");
1247              }
1248            }
1249          }
1250        }
1251        TO_BLOCK *to_block = MakeBlock(bleft, tright, &spacing_parts, used_parts);
1252        if (to_block != nullptr) {
1253          to_block_it.add_to_end(to_block);
1254          block_it.add_to_end(to_block->block);
1255        }
1256        sp_block_it.set_to_list(&spacing_parts);
1257      } else {
1258        if (textord_debug_tabfind && !it.empty()) {
1259          ColPartition *next_part = it.data();
1260          tprintf("Spacings equal: upper:%d/%d, lower:%d/%d, median:%d/%d\n",
1261                  part->top_spacing(), part->bottom_spacing(),
1262                  next_part->top_spacing(), next_part->bottom_spacing(),
1263                  part->median_height(), next_part->median_height());
1264        }
1265      }
1266    }
1267  }
1268  static void ClipCoord(const ICOORD &bleft, const ICOORD &tright, ICOORD *pos) {
1269    if (pos->x() < bleft.x()) {
1270      pos->set_x(bleft.x());
1271    }
1272    if (pos->x() > tright.x()) {
1273      pos->set_x(tright.x());
1274    }
1275    if (pos->y() < bleft.y()) {
1276      pos->set_y(bleft.y());
1277    }
1278    if (pos->y() > tright.y()) {
1279      pos->set_y(tright.y());
1280    }
1281  }
1282  static TO_BLOCK *MoveBlobsToBlock(bool vertical_text, int line_spacing,
1283                                    BLOCK *block, ColPartition_LIST *block_parts,
1284                                    ColPartition_LIST *used_parts) {
1285    TBOX block_box(block->pdblk.bounding_box());
1286    STATS sizes(0, std::max(block_box.width(), block_box.height()) - 1);
1287    bool text_type = block->pdblk.poly_block()->IsText();
1288    ColPartition_IT it(block_parts);
1289    auto *to_block = new TO_BLOCK(block);
1290    BLOBNBOX_IT blob_it(&to_block->blobs);
1291    ColPartition_IT used_it(used_parts);
1292    for (it.move_to_first(); !it.empty(); it.forward()) {
1293      ColPartition *part = it.extract();
1294      for (BLOBNBOX_C_IT bb_it(part->boxes()); !bb_it.empty(); bb_it.forward()) {
1295        BLOBNBOX *bblob = bb_it.extract();
1296        if (bblob->owner() != part) {
1297          tprintf("Ownership incorrect for blob:");
1298          bblob->bounding_box().print();
1299          tprintf("Part=");
1300          part->Print();
1301          if (bblob->owner() == nullptr) {
1302            tprintf("Not owned\n");
1303          } else {
1304            tprintf("Owner part:");
1305            bblob->owner()->Print();
1306          }
1307        }
1308        ASSERT_HOST(bblob->owner() == part);
1309        ASSERT_HOST(!text_type || bblob->region_type() >= BRT_UNKNOWN);
1310        C_OUTLINE_LIST *outlines = bblob->cblob()->out_list();
1311        C_OUTLINE_IT ol_it(outlines);
1312        ASSERT_HOST(!text_type || ol_it.data()->pathlength() > 0);
1313        if (vertical_text) {
1314          sizes.add(bblob->bounding_box().width(), 1);
1315        } else {
1316          sizes.add(bblob->bounding_box().height(), 1);
1317        }
1318        blob_it.add_after_then_move(bblob);
1319      }
1320      used_it.add_to_end(part);
1321    }
1322    if (text_type && blob_it.empty()) {
1323      delete block;
1324      delete to_block;
1325      return nullptr;
1326    }
1327    to_block->line_size = sizes.median();
1328    if (vertical_text) {
1329      int block_width = block->pdblk.bounding_box().width();
1330      if (block_width < line_spacing) {
1331        line_spacing = block_width;
1332      }
1333      to_block->line_spacing = static_cast<float>(line_spacing);
1334      to_block->max_blob_size = static_cast<float>(block_width + 1);
1335    } else {
1336      int block_height = block->pdblk.bounding_box().height();
1337      if (block_height < line_spacing) {
1338        line_spacing = block_height;
1339      }
1340      to_block->line_spacing = static_cast<float>(line_spacing);
1341      to_block->max_blob_size = static_cast<float>(block_height + 1);
1342    }
1343    return to_block;
1344  }
1345  TO_BLOCK *ColPartition::MakeBlock(const ICOORD &bleft, const ICOORD &tright,
1346                                    ColPartition_LIST *block_parts,
1347                                    ColPartition_LIST *used_parts) {
1348    if (block_parts->empty()) {
1349      return nullptr; 
1350    }
1351    block_parts->sort(&ColPartition::SortByBBox);
1352    ColPartition_IT it(block_parts);
1353    ColPartition *part = it.data();
1354    PolyBlockType type = part->type();
1355    if (type == PT_VERTICAL_TEXT) {
1356      return MakeVerticalTextBlock(bleft, tright, block_parts, used_parts);
1357    }
1358    int line_spacing = part->bottom_spacing();
1359    if (line_spacing < part->median_height()) {
1360      line_spacing = part->bounding_box().height();
1361    }
1362    ICOORDELT_LIST vertices;
1363    ICOORDELT_IT vert_it(&vertices);
1364    ICOORD start, end;
1365    int min_x = INT32_MAX;
1366    int max_x = -INT32_MAX;
1367    int min_y = INT32_MAX;
1368    int max_y = -INT32_MAX;
1369    int iteration = 0;
1370    do {
1371      if (iteration == 0) {
1372        ColPartition::LeftEdgeRun(&it, &start, &end);
1373      } else {
1374        ColPartition::RightEdgeRun(&it, &start, &end);
1375      }
1376      ClipCoord(bleft, tright, &start);
1377      ClipCoord(bleft, tright, &end);
1378      vert_it.add_after_then_move(new ICOORDELT(start));
1379      vert_it.add_after_then_move(new ICOORDELT(end));
1380      UpdateRange(start.x(), &min_x, &max_x);
1381      UpdateRange(end.x(), &min_x, &max_x);
1382      UpdateRange(start.y(), &min_y, &max_y);
1383      UpdateRange(end.y(), &min_y, &max_y);
1384      if ((iteration == 0 && it.at_first()) || (iteration == 1 && it.at_last())) {
1385        ++iteration;
1386        it.move_to_last();
1387      }
1388    } while (iteration < 2);
1389    if (textord_debug_tabfind) {
1390      tprintf("Making block at (%d,%d)->(%d,%d)\n", min_x, min_y, max_x, max_y);
1391    }
1392    auto *block = new BLOCK("", true, 0, 0, min_x, min_y, max_x, max_y);
1393    block->pdblk.set_poly_block(new POLY_BLOCK(&vertices, type));
1394    return MoveBlobsToBlock(false, line_spacing, block, block_parts, used_parts);
1395  }
1396  TO_BLOCK *ColPartition::MakeVerticalTextBlock(const ICOORD &bleft,
1397                                                const ICOORD &tright,
1398                                                ColPartition_LIST *block_parts,
1399                                                ColPartition_LIST *used_parts) {
1400    if (block_parts->empty()) {
1401      return nullptr; 
1402    }
1403    ColPartition_IT it(block_parts);
1404    ColPartition *part = it.data();
1405    TBOX block_box = part->bounding_box();
1406    int line_spacing = block_box.width();
1407    PolyBlockType type = it.data()->type();
1408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1409      block_box += it.data()->bounding_box();
1410    }
1411    if (textord_debug_tabfind) {
1412      tprintf("Making block at:");
1413      block_box.print();
1414    }
1415    auto *block = new BLOCK("", true, 0, 0, block_box.left(), block_box.bottom(),
1416                            block_box.right(), block_box.top());
1417    block->pdblk.set_poly_block(new POLY_BLOCK(block_box, type));
1418    return MoveBlobsToBlock(true, line_spacing, block, block_parts, used_parts);
1419  }
1420  TO_ROW *ColPartition::MakeToRow() {
1421    BLOBNBOX_C_IT blob_it(&boxes_);
1422    TO_ROW *row = nullptr;
1423    int line_size = IsVerticalType() ? median_width_ : median_height_;
1424    for (; !blob_it.empty(); blob_it.forward()) {
1425      BLOBNBOX *blob = blob_it.extract();
1426      int top = blob->bounding_box().top();
1427      int bottom = blob->bounding_box().bottom();
1428      if (row == nullptr) {
1429        row =
1430            new TO_ROW(blob, static_cast<float>(top), static_cast<float>(bottom),
1431                       static_cast<float>(line_size));
1432      } else {
1433        row->add_blob(blob, static_cast<float>(top), static_cast<float>(bottom),
1434                      static_cast<float>(line_size));
1435      }
1436    }
1437    return row;
1438  }
1439  ColPartition *ColPartition::ShallowCopy() const {
1440    auto *part = new ColPartition(blob_type_, vertical_);
1441    part->left_margin_ = left_margin_;
1442    part->right_margin_ = right_margin_;
1443    part->bounding_box_ = bounding_box_;
1444    memcpy(part->special_blobs_densities_, special_blobs_densities_,
1445           sizeof(special_blobs_densities_));
1446    part->median_bottom_ = median_bottom_;
1447    part->median_top_ = median_top_;
1448    part->median_height_ = median_height_;
1449    part->median_left_ = median_left_;
1450    part->median_right_ = median_right_;
1451    part->median_width_ = median_width_;
1452    part->good_width_ = good_width_;
1453    part->good_column_ = good_column_;
1454    part->left_key_tab_ = left_key_tab_;
1455    part->right_key_tab_ = right_key_tab_;
1456    part->type_ = type_;
1457    part->flow_ = flow_;
1458    part->left_key_ = left_key_;
1459    part->right_key_ = right_key_;
1460    part->first_column_ = first_column_;
1461    part->last_column_ = last_column_;
1462    part->owns_blobs_ = false;
1463    return part;
1464  }
1465  ColPartition *ColPartition::CopyButDontOwnBlobs() {
1466    ColPartition *copy = ShallowCopy();
1467    copy->set_owns_blobs(false);
1468    BLOBNBOX_C_IT inserter(copy->boxes());
1469    BLOBNBOX_C_IT traverser(boxes());
1470    for (traverser.mark_cycle_pt(); !traverser.cycled_list();
1471         traverser.forward()) {
1472      inserter.add_after_then_move(traverser.data());
1473    }
1474    return copy;
1475  }
1476  #ifndef GRAPHICS_DISABLED
1477  ScrollView::Color ColPartition::BoxColor() const {
1478    if (type_ == PT_UNKNOWN) {
1479      return BLOBNBOX::TextlineColor(blob_type_, flow_);
1480    }
1481    return POLY_BLOCK::ColorForPolyBlockType(type_);
1482  }
1483  #endif 
1484  static char kBlobTypes[BRT_COUNT + 1] = "NHSRIUVT";
1485  void ColPartition::Print() const {
1486    int y = MidY();
1487    tprintf(
1488        "ColPart:%c(M%d-%c%d-B%d/%d,%d/%d)->(%dB-%d%c-%dM/%d,%d/%d)"
1489        " w-ok=%d, v-ok=%d, type=%d%c%d, fc=%d, lc=%d, boxes=%d"
1490        " ts=%d bs=%d ls=%d rs=%d\n",
1491        boxes_.empty() ? 'E' : ' ', left_margin_, left_key_tab_ ? 'T' : 'B',
1492        LeftAtY(y), bounding_box_.left(), median_left_, bounding_box_.bottom(),
1493        median_bottom_, bounding_box_.right(), RightAtY(y),
1494        right_key_tab_ ? 'T' : 'B', right_margin_, median_right_,
1495        bounding_box_.top(), median_top_, good_width_, good_column_, type_,
1496        kBlobTypes[blob_type_], flow_, first_column_, last_column_,
1497        boxes_.length(), space_above_, space_below_, space_to_left_,
1498        space_to_right_);
1499  }
1500  void ColPartition::PrintColors() {
1501    tprintf("Colors:(%d, %d, %d)%d -> (%d, %d, %d)\n", color1_[COLOR_RED],
1502            color1_[COLOR_GREEN], color1_[COLOR_BLUE], color1_[L_ALPHA_CHANNEL],
1503            color2_[COLOR_RED], color2_[COLOR_GREEN], color2_[COLOR_BLUE]);
1504  }
1505  void ColPartition::SmoothPartnerRun(int working_set_count) {
1506    STATS left_stats(0, working_set_count - 1);
1507    STATS right_stats(0, working_set_count - 1);
1508    PolyBlockType max_type = type_;
1509    ColPartition *partner;
1510    for (partner = SingletonPartner(false); partner != nullptr;
1511         partner = partner->SingletonPartner(false)) {
1512      if (partner->type_ > max_type) {
1513        max_type = partner->type_;
1514      }
1515      if (column_set_ == partner->column_set_) {
1516        left_stats.add(partner->first_column_, 1);
1517        right_stats.add(partner->last_column_, 1);
1518      }
1519    }
1520    type_ = max_type;
1521  #if 0
1522    first_column_ = left_stats.mode();
1523    last_column_ = right_stats.mode();
1524    if (last_column_ < first_column_)
1525      last_column_ = first_column_;
1526  #endif
1527    for (partner = SingletonPartner(false); partner != nullptr;
1528         partner = partner->SingletonPartner(false)) {
1529      partner->type_ = max_type;
1530  #if 0 
1531      if (column_set_ == partner->column_set_) {
1532        partner->first_column_ = first_column_;
1533        partner->last_column_ = last_column_;
1534      }
1535  #endif
1536    }
1537  }
1538  void ColPartition::RefinePartners(PolyBlockType type, bool get_desperate,
1539                                    ColPartitionGrid *grid) {
1540    if (TypesSimilar(type_, type)) {
1541      RefinePartnersInternal(true, get_desperate, grid);
1542      RefinePartnersInternal(false, get_desperate, grid);
1543    } else if (type == PT_COUNT) {
1544      RefinePartnersByType(true, &upper_partners_);
1545      RefinePartnersByType(false, &lower_partners_);
1546      if (!upper_partners_.empty() && !upper_partners_.singleton()) {
1547        RefinePartnersByOverlap(true, &upper_partners_);
1548      }
1549      if (!lower_partners_.empty() && !lower_partners_.singleton()) {
1550        RefinePartnersByOverlap(false, &lower_partners_);
1551      }
1552    }
1553  }
1554  void ColPartition::RefinePartnersInternal(bool upper, bool get_desperate,
1555                                            ColPartitionGrid *grid) {
1556    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
1557    if (!partners->empty() && !partners->singleton()) {
1558      RefinePartnersByType(upper, partners);
1559      if (!partners->empty() && !partners->singleton()) {
1560        RefinePartnerShortcuts(upper, partners);
1561        if (!partners->empty() && !partners->singleton()) {
1562          if (TypesSimilar(type_, PT_FLOWING_TEXT) && get_desperate) {
1563            RefineTextPartnersByMerge(upper, false, partners, grid);
1564            if (!partners->empty() && !partners->singleton()) {
1565              RefineTextPartnersByMerge(upper, true, partners, grid);
1566            }
1567          }
1568          if (!partners->empty() && !partners->singleton()) {
1569            RefinePartnersByOverlap(upper, partners);
1570          }
1571        }
1572      }
1573    }
1574  }
1575  void ColPartition::RefinePartnersByType(bool upper,
1576                                          ColPartition_CLIST *partners) {
1577    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1578                                           bounding_box_.bottom());
1579    if (debug) {
1580      tprintf("Refining %d %s partners by type for:\n", partners->length(),
1581              upper ? "Upper" : "Lower");
1582      Print();
1583    }
1584    ColPartition_C_IT it(partners);
1585    if (!IsImageType() && !IsLineType() && type() != PT_TABLE) {
1586      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1587        ColPartition *partner = it.data();
1588        if (!TypesSimilar(type_, partner->type_)) {
1589          if (debug) {
1590            tprintf("Removing partner:");
1591            partner->Print();
1592          }
1593          partner->RemovePartner(!upper, this);
1594          it.extract();
1595        } else if (debug) {
1596          tprintf("Keeping partner:");
1597          partner->Print();
1598        }
1599      }
1600    } else {
1601      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1602        ColPartition *partner = it.data();
1603        if (partner->blob_type() != BRT_POLYIMAGE ||
1604            blob_type() != BRT_POLYIMAGE) {
1605          if (debug) {
1606            tprintf("Removing partner:");
1607            partner->Print();
1608          }
1609          partner->RemovePartner(!upper, this);
1610          it.extract();
1611        } else if (debug) {
1612          tprintf("Keeping partner:");
1613          partner->Print();
1614        }
1615      }
1616    }
1617  }
1618  void ColPartition::RefinePartnerShortcuts(bool upper,
1619                                            ColPartition_CLIST *partners) {
1620    bool done_any = false;
1621    do {
1622      done_any = false;
1623      ColPartition_C_IT it(partners);
1624      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1625        ColPartition *a = it.data();
1626        ColPartition_C_IT it1(upper ? &a->upper_partners_ : &a->lower_partners_);
1627        for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
1628          ColPartition *b1 = it1.data();
1629          if (b1 == this) {
1630            done_any = true;
1631            it.extract();
1632            a->RemovePartner(!upper, this);
1633            break;
1634          }
1635          ColPartition_C_IT it2(partners);
1636          for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
1637            ColPartition *b2 = it2.data();
1638            if (b1 == b2) {
1639              it2.extract();
1640              b2->RemovePartner(!upper, this);
1641              done_any = true;
1642              break;
1643            }
1644          }
1645          if (done_any) {
1646            break;
1647          }
1648        }
1649        if (done_any) {
1650          break;
1651        }
1652      }
1653    } while (done_any && !partners->empty() && !partners->singleton());
1654  }
1655  void ColPartition::RefineTextPartnersByMerge(bool upper, bool desperate,
1656                                               ColPartition_CLIST *partners,
1657                                               ColPartitionGrid *grid) {
1658    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1659                                           bounding_box_.bottom());
1660    if (debug) {
1661      tprintf("Refining %d %s partners by merge for:\n", partners->length(),
1662              upper ? "Upper" : "Lower");
1663      Print();
1664    }
1665    while (!partners->empty() && !partners->singleton()) {
1666      ColPartition_C_IT it(partners);
1667      ColPartition *part = it.data();
1668      ColPartition_CLIST candidates;
1669      ColPartition_C_IT cand_it(&candidates);
1670      for (it.forward(); !it.at_first(); it.forward()) {
1671        ColPartition *candidate = it.data();
1672        if (part->first_column_ == candidate->last_column_ &&
1673            part->last_column_ == candidate->first_column_) {
1674          cand_it.add_after_then_move(it.data());
1675        }
1676      }
1677      int overlap_increase;
1678      ColPartition *candidate = grid->BestMergeCandidate(
1679          part, &candidates, debug, nullptr, &overlap_increase);
1680      if (candidate != nullptr && (overlap_increase <= 0 || desperate)) {
1681        if (debug) {
1682          tprintf("Merging:hoverlap=%d, voverlap=%d, OLI=%d\n",
1683                  part->HCoreOverlap(*candidate), part->VCoreOverlap(*candidate),
1684                  overlap_increase);
1685        }
1686        grid->RemoveBBox(candidate);
1687        grid->RemoveBBox(part);
1688        part->Absorb(candidate, nullptr);
1689        grid->InsertBBox(true, true, part);
1690        if (overlap_increase > 0) {
1691          part->desperately_merged_ = true;
1692        }
1693      } else {
1694        break; 
1695      }
1696    }
1697  }
1698  void ColPartition::RefinePartnersByOverlap(bool upper,
1699                                             ColPartition_CLIST *partners) {
1700    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1701                                           bounding_box_.bottom());
1702    if (debug) {
1703      tprintf("Refining %d %s partners by overlap for:\n", partners->length(),
1704              upper ? "Upper" : "Lower");
1705      Print();
1706    }
1707    ColPartition_C_IT it(partners);
1708    ColPartition *best_partner = it.data();
1709    int best_overlap = 0;
1710    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1711      ColPartition *partner = it.data();
1712      int overlap =
1713          std::min(bounding_box_.right(), partner->bounding_box_.right()) -
1714          std::max(bounding_box_.left(), partner->bounding_box_.left());
1715      if (overlap > best_overlap) {
1716        best_overlap = overlap;
1717        best_partner = partner;
1718      }
1719    }
1720    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1721      ColPartition *partner = it.data();
1722      if (partner != best_partner) {
1723        if (debug) {
1724          tprintf("Removing partner:");
1725          partner->Print();
1726        }
1727        partner->RemovePartner(!upper, this);
1728        it.extract();
1729      }
1730    }
1731  }
1732  bool ColPartition::ThisPartitionBetter(BLOBNBOX *bbox,
1733                                         const ColPartition &other) {
1734    const TBOX &box = bbox->bounding_box();
1735    int left = box.left();
1736    int right = box.right();
1737    if (left < left_margin_ || right > right_margin_) {
1738      return false;
1739    }
1740    if (left < other.left_margin_ || right > other.right_margin_) {
1741      return true;
1742    }
1743    int top = box.top();
1744    int bottom = box.bottom();
1745    int this_overlap =
1746        std::min(top, median_top_) - std::max(bottom, median_bottom_);
1747    int other_overlap =
1748        std::min(top, other.median_top_) - std::max(bottom, other.median_bottom_);
1749    int this_miss = median_top_ - median_bottom_ - this_overlap;
1750    int other_miss = other.median_top_ - other.median_bottom_ - other_overlap;
1751    if (TabFind::WithinTestRegion(3, box.left(), box.bottom())) {
1752      tprintf("Unique on (%d,%d)->(%d,%d) overlap %d/%d, miss %d/%d, mt=%d/%d\n",
1753              box.left(), box.bottom(), box.right(), box.top(), this_overlap,
1754              other_overlap, this_miss, other_miss, median_top_,
1755              other.median_top_);
1756    }
1757    if (this_miss < other_miss) {
1758      return true;
1759    }
1760    if (this_miss > other_miss) {
1761      return false;
1762    }
1763    if (this_overlap > other_overlap) {
1764      return true;
1765    }
1766    if (this_overlap < other_overlap) {
1767      return false;
1768    }
1769    return median_top_ >= other.median_top_;
1770  }
1771  static int MedianSpacing(int page_height, ColPartition_IT it) {
1772    STATS stats(0, page_height - 1);
1773    while (!it.cycled_list()) {
1774      ColPartition *part = it.data();
1775      it.forward();
1776      stats.add(part->bottom_spacing(), 1);
1777      stats.add(part->top_spacing(), 1);
1778    }
1779    return static_cast<int>(stats.median() + 0.5);
1780  }
1781  bool ColPartition::IsInSameColumnAs(const ColPartition &part) const {
1782    return (last_column_ >= part.first_column_) &&
1783           (first_column_ <= part.last_column_);
1784  }
1785  void ColPartition::SmoothSpacings(int resolution, int page_height,
1786                                    ColPartition_LIST *parts) {
1787    ColPartition *neighbourhood[PN_COUNT];
1788    ColPartition_IT it(parts);
1789    it.mark_cycle_pt();
1790    int median_space = MedianSpacing(page_height, it);
1791    ColPartition_IT start_it(it);
1792    ColPartition_IT end_it(it);
1793    for (int i = 0; i < PN_COUNT; ++i) {
1794      if (i < PN_UPPER || it.cycled_list()) {
1795        neighbourhood[i] = nullptr;
1796      } else {
1797        if (i == PN_LOWER) {
1798          end_it = it;
1799        }
1800        neighbourhood[i] = it.data();
1801        it.forward();
1802      }
1803    }
1804    while (neighbourhood[PN_UPPER] != nullptr) {
1805      if (neighbourhood[PN_LOWER] == nullptr ||
1806          (!neighbourhood[PN_UPPER]->SpacingsEqual(*neighbourhood[PN_LOWER],
1807                                                   resolution) &&
1808           (neighbourhood[PN_UPPER] == nullptr ||
1809            neighbourhood[PN_LOWER] == nullptr ||
1810            !OKSpacingBlip(resolution, median_space, neighbourhood, 0)) &&
1811           (neighbourhood[PN_UPPER - 1] == nullptr ||
1812            neighbourhood[PN_LOWER - 1] == nullptr ||
1813            !OKSpacingBlip(resolution, median_space, neighbourhood, -1) ||
1814            !neighbourhood[PN_LOWER]->SpacingEqual(median_space, resolution)) &&
1815           (neighbourhood[PN_UPPER + 1] == nullptr ||
1816            neighbourhood[PN_LOWER + 1] == nullptr ||
1817            !OKSpacingBlip(resolution, median_space, neighbourhood, 1) ||
1818            !neighbourhood[PN_UPPER]->SpacingEqual(median_space, resolution)))) {
1819        ColPartition_IT sum_it(start_it);
1820        ColPartition *last_part = neighbourhood[PN_UPPER];
1821        double total_bottom = 0.0;
1822        double total_top = 0.0;
1823        int total_count = 0;
1824        ColPartition *upper = sum_it.data();
1825        while (upper != last_part) {
1826          total_bottom += upper->bottom_spacing();
1827          total_top += upper->top_spacing();
1828          ++total_count;
1829          sum_it.forward();
1830          upper = sum_it.data();
1831        }
1832        if (total_count > 0) {
1833          int top_spacing = static_cast<int>(total_top / total_count + 0.5);
1834          int bottom_spacing = static_cast<int>(total_bottom / total_count + 0.5);
1835          if (textord_debug_tabfind) {
1836            tprintf("Spacing run ended. Cause:");
1837            if (neighbourhood[PN_LOWER] == nullptr) {
1838              tprintf("No more lines\n");
1839            } else {
1840              tprintf("Spacing change. Spacings:\n");
1841              for (int i = 0; i < PN_COUNT; ++i) {
1842                if (neighbourhood[i] == nullptr) {
1843                  tprintf("NULL");
1844                  if (i > 0 && neighbourhood[i - 1] != nullptr) {
1845                    if (neighbourhood[i - 1]->SingletonPartner(false) !=
1846                        nullptr) {
1847                      tprintf(" Lower partner:");
1848                      neighbourhood[i - 1]->SingletonPartner(false)->Print();
1849                    } else {
1850                      tprintf(" nullptr lower partner:\n");
1851                    }
1852                  } else {
1853                    tprintf("\n");
1854                  }
1855                } else {
1856                  tprintf("Top = %d, bottom = %d\n",
1857                          neighbourhood[i]->top_spacing(),
1858                          neighbourhood[i]->bottom_spacing());
1859                }
1860              }
1861            }
1862            tprintf("Mean spacing = %d/%d\n", top_spacing, bottom_spacing);
1863          }
1864          sum_it = start_it;
1865          upper = sum_it.data();
1866          while (upper != last_part) {
1867            upper->set_top_spacing(top_spacing);
1868            upper->set_bottom_spacing(bottom_spacing);
1869            if (textord_debug_tabfind) {
1870              tprintf("Setting mean on:");
1871              upper->Print();
1872            }
1873            sum_it.forward();
1874            upper = sum_it.data();
1875          }
1876        }
1877        start_it = end_it;
1878        median_space = MedianSpacing(page_height, end_it);
1879      }
1880      for (int j = 1; j < PN_COUNT; ++j) {
1881        neighbourhood[j - 1] = neighbourhood[j];
1882      }
1883      if (it.cycled_list()) {
1884        neighbourhood[PN_COUNT - 1] = nullptr;
1885      } else {
1886        neighbourhood[PN_COUNT - 1] = it.data();
1887        it.forward();
1888      }
1889      end_it.forward();
1890    }
1891  }
1892  bool ColPartition::OKSpacingBlip(int resolution, int median_spacing,
1893                                   ColPartition **parts, int offset) {
1894    parts += offset;
1895    return parts[PN_UPPER]->SummedSpacingOK(*parts[PN_LOWER], median_spacing,
1896                                            resolution) &&
1897           ((parts[PN_ABOVE1] != nullptr &&
1898             parts[PN_ABOVE1]->SpacingEqual(median_spacing, resolution)) ||
1899            (parts[PN_BELOW1] != nullptr &&
1900             parts[PN_BELOW1]->SpacingEqual(median_spacing, resolution)));
1901  }
1902  bool ColPartition::SpacingEqual(int spacing, int resolution) const {
1903    int bottom_error = BottomSpacingMargin(resolution);
1904    int top_error = TopSpacingMargin(resolution);
1905    return NearlyEqual(bottom_spacing_, spacing, bottom_error) &&
1906           NearlyEqual(top_spacing_, spacing, top_error);
1907  }
1908  bool ColPartition::SpacingsEqual(const ColPartition &other,
1909                                   int resolution) const {
1910    int bottom_error = std::max(BottomSpacingMargin(resolution),
1911                                other.BottomSpacingMargin(resolution));
1912    int top_error = std::max(TopSpacingMargin(resolution),
1913                             other.TopSpacingMargin(resolution));
1914    return NearlyEqual(bottom_spacing_, other.bottom_spacing_, bottom_error) &&
1915           (NearlyEqual(top_spacing_, other.top_spacing_, top_error) ||
1916            NearlyEqual(top_spacing_ + other.top_spacing_, bottom_spacing_ * 2,
1917                        bottom_error));
1918  }
1919  bool ColPartition::SummedSpacingOK(const ColPartition &other, int spacing,
1920                                     int resolution) const {
1921    int bottom_error = std::max(BottomSpacingMargin(resolution),
1922                                other.BottomSpacingMargin(resolution));
1923    int top_error = std::max(TopSpacingMargin(resolution),
1924                             other.TopSpacingMargin(resolution));
1925    int bottom_total = bottom_spacing_ + other.bottom_spacing_;
1926    int top_total = top_spacing_ + other.top_spacing_;
1927    return (NearlyEqual(spacing, bottom_total, bottom_error) &&
1928            NearlyEqual(spacing, top_total, top_error)) ||
1929           (NearlyEqual(spacing * 2, bottom_total, bottom_error) &&
1930            NearlyEqual(spacing * 2, top_total, top_error));
1931  }
1932  int ColPartition::BottomSpacingMargin(int resolution) const {
1933    return static_cast<int>(kMaxSpacingDrift * resolution + 0.5) + side_step_;
1934  }
1935  int ColPartition::TopSpacingMargin(int resolution) const {
1936    return static_cast<int>(kMaxTopSpacingFraction * median_height_ + 0.5) +
1937           BottomSpacingMargin(resolution);
1938  }
1939  bool ColPartition::SizesSimilar(const ColPartition &other) const {
1940    return median_height_ <= other.median_height_ * kMaxSizeRatio &&
1941           other.median_height_ <= median_height_ * kMaxSizeRatio;
1942  }
1943  static bool UpdateLeftMargin(const ColPartition &part, int *margin_left,
1944                               int *margin_right) {
1945    const TBOX &part_box = part.bounding_box();
1946    int top = part_box.top();
1947    int bottom = part_box.bottom();
1948    int tl_key = part.SortKey(part.left_margin(), top);
1949    int tr_key = part.SortKey(part_box.left(), top);
1950    int bl_key = part.SortKey(part.left_margin(), bottom);
1951    int br_key = part.SortKey(part_box.left(), bottom);
1952    int left_key = std::max(tl_key, bl_key);
1953    int right_key = std::min(tr_key, br_key);
1954    if (left_key <= *margin_right && right_key >= *margin_left) {
1955      *margin_right = std::min(*margin_right, right_key);
1956      *margin_left = std::max(*margin_left, left_key);
1957      return true;
1958    }
1959    return false;
1960  }
1961  void ColPartition::LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start,
1962                                 ICOORD *end) {
1963    ColPartition *part = part_it->data();
1964    ColPartition *start_part = part;
1965    int start_y = part->bounding_box_.top();
1966    if (!part_it->at_first()) {
1967      int prev_bottom = part_it->data_relative(-1)->bounding_box_.bottom();
1968      if (prev_bottom < start_y) {
1969        start_y = prev_bottom;
1970      } else if (prev_bottom > start_y) {
1971        start_y = (start_y + prev_bottom) / 2;
1972      }
1973    }
1974    int end_y = part->bounding_box_.bottom();
1975    int margin_right = INT32_MAX;
1976    int margin_left = -INT32_MAX;
1977    UpdateLeftMargin(*part, &margin_left, &margin_right);
1978    do {
1979      part_it->forward();
1980      part = part_it->data();
1981    } while (!part_it->at_first() &&
1982             UpdateLeftMargin(*part, &margin_left, &margin_right));
1983    int next_margin_right = INT32_MAX;
1984    int next_margin_left = -INT32_MAX;
1985    UpdateLeftMargin(*part, &next_margin_left, &next_margin_right);
1986    if (next_margin_left > margin_right) {
1987      ColPartition_IT next_it(*part_it);
1988      do {
1989        next_it.forward();
1990        part = next_it.data();
1991      } while (!next_it.at_first() &&
1992               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1993      do {
1994        part_it->backward();
1995        part = part_it->data();
1996      } while (part != start_part &&
1997               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1998      part_it->forward();
1999    }
2000    part = part_it->data_relative(-1);
2001    end_y = part->bounding_box_.bottom();
2002    if (!part_it->at_first() && part_it->data()->bounding_box_.top() < end_y) {
2003      end_y = (end_y + part_it->data()->bounding_box_.top()) / 2;
2004    }
2005    start->set_y(start_y);
2006    start->set_x(part->XAtY(margin_right, start_y));
2007    end->set_y(end_y);
2008    end->set_x(part->XAtY(margin_right, end_y));
2009    if (textord_debug_tabfind && !part_it->at_first()) {
2010      tprintf("Left run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2011              start_y, end_y, part->XAtY(margin_left, end_y), end->x(),
2012              part->left_margin_, part->bounding_box_.left());
2013    }
2014  }
2015  static bool UpdateRightMargin(const ColPartition &part, int *margin_left,
2016                                int *margin_right) {
2017    const TBOX &part_box = part.bounding_box();
2018    int top = part_box.top();
2019    int bottom = part_box.bottom();
2020    int tl_key = part.SortKey(part_box.right(), top);
2021    int tr_key = part.SortKey(part.right_margin(), top);
2022    int bl_key = part.SortKey(part_box.right(), bottom);
2023    int br_key = part.SortKey(part.right_margin(), bottom);
2024    int left_key = std::max(tl_key, bl_key);
2025    int right_key = std::min(tr_key, br_key);
2026    if (left_key <= *margin_right && right_key >= *margin_left) {
2027      *margin_right = std::min(*margin_right, right_key);
2028      *margin_left = std::max(*margin_left, left_key);
2029      return true;
2030    }
2031    return false;
2032  }
2033  void ColPartition::RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
2034                                  ICOORD *end) {
2035    ColPartition *part = part_it->data();
2036    ColPartition *start_part = part;
2037    int start_y = part->bounding_box_.bottom();
2038    if (!part_it->at_last()) {
2039      int next_y = part_it->data_relative(1)->bounding_box_.top();
2040      if (next_y > start_y) {
2041        start_y = next_y;
2042      } else if (next_y < start_y) {
2043        start_y = (start_y + next_y) / 2;
2044      }
2045    }
2046    int end_y = part->bounding_box_.top();
2047    int margin_right = INT32_MAX;
2048    int margin_left = -INT32_MAX;
2049    UpdateRightMargin(*part, &margin_left, &margin_right);
2050    do {
2051      part_it->backward();
2052      part = part_it->data();
2053    } while (!part_it->at_last() &&
2054             UpdateRightMargin(*part, &margin_left, &margin_right));
2055    int next_margin_right = INT32_MAX;
2056    int next_margin_left = -INT32_MAX;
2057    UpdateRightMargin(*part, &next_margin_left, &next_margin_right);
2058    if (next_margin_right < margin_left) {
2059      ColPartition_IT next_it(*part_it);
2060      do {
2061        next_it.backward();
2062        part = next_it.data();
2063      } while (!next_it.at_last() &&
2064               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2065      do {
2066        part_it->forward();
2067        part = part_it->data();
2068      } while (part != start_part &&
2069               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2070      part_it->backward();
2071    }
2072    part = part_it->data_relative(1);
2073    end_y = part->bounding_box().top();
2074    if (!part_it->at_last() && part_it->data()->bounding_box_.bottom() > end_y) {
2075      end_y = (end_y + part_it->data()->bounding_box_.bottom()) / 2;
2076    }
2077    start->set_y(start_y);
2078    start->set_x(part->XAtY(margin_left, start_y));
2079    end->set_y(end_y);
2080    end->set_x(part->XAtY(margin_left, end_y));
2081    if (textord_debug_tabfind && !part_it->at_last()) {
2082      tprintf("Right run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2083              start_y, end_y, end->x(), part->XAtY(margin_right, end_y),
2084              part->bounding_box_.right(), part->right_margin_);
2085    }
2086  }
2087  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-sw.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</div>
                </div>
                <div class="column column_space"><pre><code>9          libtesseract.PackageDefinitions = true;
10          libtesseract += cppstd;
11          libtesseract += "TESS_API"_api;
12          libtesseract += "include/.*"_rr;
13          libtesseract += "src/.+/.*"_rr;
14          libtesseract -= "src/lstm/.*\\.cc"_rr;
15          libtesseract -= "src/training/.*"_rr;
16          libtesseract.Public += "include"_idir;
17          libtesseract.Protected +=
</pre></code></div>
                <div class="column column_space"><pre><code>96    part->bounding_box_ = TBOX(left, bottom, right, top);
97    part->median_bottom_ = bottom;
98    part->median_top_ = top;
99    part->median_height_ = top - bottom;
100    part->median_left_ = left;
101    part->median_right_ = right;
102    part->median_width_ = right - left;
103    part->left_key_ = part->BoxLeftKey();
104    part->right_key_ = part->BoxRightKey();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    