<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for cs-module.cpp &amp; lp-reassembler.t.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cs-module.cpp &amp; lp-reassembler.t.cpp
      </h3>
<h1 align="center">
        4.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cs-module.cpp (8.280254%)<th>lp-reassembler.t.cpp (2.9816513%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(41-50)<td><a href="#" name="0">(152-164)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cs-module.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "cs-module.hpp"
2 #include "format-helpers.hpp"
3 #include &lt;ndn-cxx/util/indented-stream.hpp&gt;
4 namespace nfd {
5 namespace tools {
6 namespace nfdc {
7 void
8 CsModule::registerCommands(CommandParser&amp; parser)
9 {
10 <a name="0"></a>  CommandDefinition defCsConfig("cs", "config");
11   defCsConfig
12     .setTitle("change CS configuration")
13 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    .addArg("capacity", ArgValueType::UNSIGNED, Required::NO, Positional::NO)
14     .addArg("admit", ArgValueType::BOOLEAN, Required::NO, Positional::NO)
15     .addArg("serve", ArgValueType::BOOLEAN, Required::NO, Positional::NO);
16   parser.addCommand(defCsConfig, &amp;CsModule::config);
17   CommandDefinition defCsErase("cs", "erase");
18   defCsErase
19     .setTitle("erase cached Data")
20     .addArg("prefix", ArgValueType::NAME, Required::YES, Positional::YES)
21     .addArg("count", ArgValueType::UNSIGNED, Required::NO, Positional::NO);</b></font>
22   parser.addCommand(defCsErase, &amp;CsModule::erase);
23 }
24 void
25 CsModule::config(ExecuteContext&amp; ctx)
26 {
27   using boost::logic::indeterminate;
28   auto capacity = ctx.args.getOptional&lt;uint64_t&gt;("capacity");
29   auto enableAdmit = ctx.args.getTribool("admit");
30   auto enableServe = ctx.args.getTribool("serve");
31   ControlParameters p;
32   if (capacity) {
33     p.setCapacity(*capacity);
34   }
35   if (!indeterminate(enableAdmit)) {
36     p.setFlagBit(ndn::nfd::BIT_CS_ENABLE_ADMIT, bool(enableAdmit));
37   }
38   if (!indeterminate(enableServe)) {
39     p.setFlagBit(ndn::nfd::BIT_CS_ENABLE_SERVE, bool(enableServe));
40   }
41   ctx.controller.start&lt;ndn::nfd::CsConfigCommand&gt;(p,
42     [&amp;] (const ControlParameters&amp; resp) {
43       text::ItemAttributes ia;
44       ctx.out &lt;&lt; "cs-config-updated "
45               &lt;&lt; ia("capacity") &lt;&lt; resp.getCapacity()
46               &lt;&lt; ia("admit") &lt;&lt; text::OnOff{resp.getFlagBit(ndn::nfd::BIT_CS_ENABLE_ADMIT)}
47               &lt;&lt; ia("serve") &lt;&lt; text::OnOff{resp.getFlagBit(ndn::nfd::BIT_CS_ENABLE_SERVE)}
48               &lt;&lt; '\n';
49     },
50     ctx.makeCommandFailureHandler("updating CS config"),
51     ctx.makeCommandOptions());
52   ctx.face.processEvents();
53 }
54 void
55 CsModule::erase(ExecuteContext&amp; ctx)
56 {
57   auto prefix = ctx.args.get&lt;Name&gt;("prefix");
58   auto count = ctx.args.getOptional&lt;uint64_t&gt;("count");
59   uint64_t numErased = 0;
60   bool wasLimited = false;
61   bool wasSuccessful = true;
62   ControlParameters params;
63   params.setName(prefix);
64   do {
65     if (count) {
66       params.setCount(*count - numErased);
67     }
68     wasSuccessful = false;
69     ctx.controller.start&lt;ndn::nfd::CsEraseCommand&gt;(
70       params,
71       [&amp;] (const ControlParameters&amp; resp) {
72         wasSuccessful = true;
73         numErased += resp.getCount();
74         wasLimited = resp.hasCapacity();
75       },
76       ctx.makeCommandFailureHandler("erasing cached Data"),
77       ctx.makeCommandOptions());
78     ctx.face.processEvents();
79   } while (wasSuccessful &amp;&amp; wasLimited);
80   if (wasSuccessful) {
81     text::ItemAttributes ia;
82     ctx.out &lt;&lt; "cs-erased "
83             &lt;&lt; ia("prefix") &lt;&lt; prefix
84             &lt;&lt; ia("count") &lt;&lt; numErased
85             &lt;&lt; '\n';
86   }
87 }
88 void
89 CsModule::fetchStatus(Controller&amp; controller,
90                       const std::function&lt;void()&gt;&amp; onSuccess,
91                       const Controller::DatasetFailCallback&amp; onFailure,
92                       const CommandOptions&amp; options)
93 {
94   controller.fetch&lt;ndn::nfd::CsInfoDataset&gt;(
95     [this, onSuccess] (const CsInfo&amp; result) {
96       m_status = result;
97       onSuccess();
98     },
99     onFailure, options);
100 }
101 void
102 CsModule::formatStatusXml(std::ostream&amp; os) const
103 {
104   formatItemXml(os, m_status);
105 }
106 void
107 CsModule::formatItemXml(std::ostream&amp; os, const CsInfo&amp; item)
108 {
109   os &lt;&lt; "&lt;cs&gt;";
110   os &lt;&lt; "&lt;capacity&gt;" &lt;&lt; item.getCapacity() &lt;&lt; "&lt;/capacity&gt;";
111   os &lt;&lt; xml::Flag{"admitEnabled", item.getEnableAdmit()};
112   os &lt;&lt; xml::Flag{"serveEnabled", item.getEnableServe()};
113   os &lt;&lt; "&lt;nEntries&gt;" &lt;&lt; item.getNEntries() &lt;&lt; "&lt;/nEntries&gt;";
114   os &lt;&lt; "&lt;nHits&gt;" &lt;&lt; item.getNHits() &lt;&lt; "&lt;/nHits&gt;";
115   os &lt;&lt; "&lt;nMisses&gt;" &lt;&lt; item.getNMisses() &lt;&lt; "&lt;/nMisses&gt;";
116   os &lt;&lt; "&lt;/cs&gt;";
117 }
118 void
119 CsModule::formatStatusText(std::ostream&amp; os) const
120 {
121   os &lt;&lt; "CS information:\n";
122   ndn::util::IndentedStream indented(os, "  ");
123   formatItemText(indented, m_status);
124 }
125 void
126 CsModule::formatItemText(std::ostream&amp; os, const CsInfo&amp; item)
127 {
128   text::ItemAttributes ia(true, 8);
129   os &lt;&lt; ia("capacity") &lt;&lt; item.getCapacity()
130      &lt;&lt; ia("admit") &lt;&lt; text::OnOff{item.getEnableAdmit()}
131      &lt;&lt; ia("serve") &lt;&lt; text::OnOff{item.getEnableServe()}
132      &lt;&lt; ia("nEntries") &lt;&lt; item.getNEntries()
133      &lt;&lt; ia("nHits") &lt;&lt; item.getNHits()
134      &lt;&lt; ia("nMisses") &lt;&lt; item.getNMisses()
135      &lt;&lt; ia.end();
136 }
} } } </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lp-reassembler.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "face/lp-reassembler.hpp"
2 #include "tests/test-common.hpp"
3 #include "tests/daemon/global-io-fixture.hpp"
4 namespace nfd {
5 namespace face {
6 namespace tests {
7 using namespace nfd::tests;
8 class LpReassemblerFixture : public GlobalIoTimeFixture
9 {
10 protected:
11   LpReassemblerFixture()
12   {
13     reassembler.beforeTimeout.connect(
14       [this] (EndpointId remoteEp, size_t nDroppedFragments) {
15         timeoutHistory.push_back({remoteEp, nDroppedFragments});
16       });
17   }
18 protected:
19   LpReassembler reassembler{{}};
20   std::vector&lt;std::pair&lt;EndpointId, size_t&gt;&gt; timeoutHistory;
21   static const uint8_t data[10];
22 };
23 const uint8_t LpReassemblerFixture::data[10] = {
24   0x06, 0x08,         0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
25 };
26 BOOST_AUTO_TEST_SUITE(Face)
27 BOOST_FIXTURE_TEST_SUITE(TestLpReassembler, LpReassemblerFixture)
28 BOOST_AUTO_TEST_SUITE(SingleFragment)
29 BOOST_AUTO_TEST_CASE(Normal)
30 {
31   ndn::Buffer dataBuffer(data, sizeof(data));
32   lp::Packet received;
33   received.add&lt;lp::FragmentField&gt;(std::make_pair(dataBuffer.begin(), dataBuffer.end()));
34   received.add&lt;lp::FragIndexField&gt;(0);
35   received.add&lt;lp::FragCountField&gt;(1);
36   received.add&lt;lp::SequenceField&gt;(1000);
37   received.add&lt;lp::NextHopFaceIdField&gt;(200);
38   bool isComplete = false;
39   Block netPacket;
40   lp::Packet packet;
41   std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received);
42   BOOST_REQUIRE(isComplete);
43   BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
44   BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
45   BOOST_CHECK_EQUAL(reassembler.size(), 0);
46 }
47 BOOST_AUTO_TEST_CASE(OmitFragIndex)
48 {
49   ndn::Buffer dataBuffer(data, sizeof(data));
50   lp::Packet received;
51   received.add&lt;lp::FragmentField&gt;(std::make_pair(dataBuffer.begin(), dataBuffer.end()));
52   received.add&lt;lp::FragCountField&gt;(1);
53   received.add&lt;lp::SequenceField&gt;(1000);
54   received.add&lt;lp::NextHopFaceIdField&gt;(200);
55   bool isComplete = false;
56   Block netPacket;
57   lp::Packet packet;
58   std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received);
59   BOOST_REQUIRE(isComplete);
60   BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
61   BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
62 }
63 BOOST_AUTO_TEST_CASE(OmitFragCount)
64 {
65   ndn::Buffer dataBuffer(data, sizeof(data));
66   lp::Packet received;
67   received.add&lt;lp::FragmentField&gt;(std::make_pair(dataBuffer.begin(), dataBuffer.end()));
68   received.add&lt;lp::FragIndexField&gt;(0);
69   received.add&lt;lp::SequenceField&gt;(1000);
70   received.add&lt;lp::NextHopFaceIdField&gt;(200);
71   bool isComplete = false;
72   Block netPacket;
73   lp::Packet packet;
74   std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received);
75   BOOST_REQUIRE(isComplete);
76   BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
77   BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
78 }
79 BOOST_AUTO_TEST_CASE(OmitFragIndexAndFragCount)
80 {
81   ndn::Buffer dataBuffer(data, sizeof(data));
82   lp::Packet received;
83   received.add&lt;lp::FragmentField&gt;(std::make_pair(dataBuffer.begin(), dataBuffer.end()));
84   received.add&lt;lp::SequenceField&gt;(1000);
85   received.add&lt;lp::NextHopFaceIdField&gt;(200);
86   bool isComplete = false;
87   Block netPacket;
88   lp::Packet packet;
89   std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received);
90   BOOST_REQUIRE(isComplete);
91   BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
92   BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
93 }
94 BOOST_AUTO_TEST_SUITE_END() 
95 BOOST_AUTO_TEST_SUITE(MultiFragment)
96 <a name="0"></a>
97 BOOST_AUTO_TEST_CASE(Normal)
98 {
99 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  ndn::Buffer data1Buffer(data, 4);
100   ndn::Buffer data2Buffer(data + 4, 4);
101   ndn::Buffer data3Buffer(data + 8, 2);
102   lp::Packet received1;
103   received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
104   received1.add&lt;lp::FragIndexField&gt;(0);
105   received1.add&lt;lp::FragCountField&gt;(3);
106   received1.add&lt;lp::SequenceField&gt;(1000);
107   received1.add&lt;lp::NextHopFaceIdField&gt;(200);
108   lp::Packet received2;
109   received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));</b></font>
110   received2.add&lt;lp::FragIndexField&gt;(1);
111   received2.add&lt;lp::FragCountField&gt;(3);
112   received2.add&lt;lp::SequenceField&gt;(1001);
113   lp::Packet received3;
114   received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
115   received3.add&lt;lp::FragIndexField&gt;(2);
116   received3.add&lt;lp::FragCountField&gt;(3);
117   received3.add&lt;lp::SequenceField&gt;(1002);
118   bool isComplete = false;
119   Block netPacket;
120   lp::Packet packet;
121   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
122   BOOST_REQUIRE(!isComplete);
123   BOOST_CHECK_EQUAL(reassembler.size(), 1);
124   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
125   BOOST_REQUIRE(!isComplete);
126   BOOST_CHECK_EQUAL(reassembler.size(), 1);
127   std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received3);
128   BOOST_REQUIRE(isComplete);
129   BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
130   BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
131   BOOST_CHECK_EQUAL(reassembler.size(), 0);
132 }
133 BOOST_AUTO_TEST_CASE(OmitFragIndex0)
134 {
135   ndn::Buffer data1Buffer(data, 4);
136   ndn::Buffer data2Buffer(data + 4, 4);
137   ndn::Buffer data3Buffer(data + 8, 2);
138   lp::Packet received1;
139   received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
140   received1.add&lt;lp::FragCountField&gt;(3);
141   received1.add&lt;lp::SequenceField&gt;(1000);
142   received1.add&lt;lp::NextHopFaceIdField&gt;(200);
143   lp::Packet received2;
144   received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
145   received2.add&lt;lp::FragIndexField&gt;(1);
146   received2.add&lt;lp::FragCountField&gt;(3);
147   received2.add&lt;lp::SequenceField&gt;(1001);
148   lp::Packet received3;
149   received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
150   received3.add&lt;lp::FragIndexField&gt;(2);
151   received3.add&lt;lp::FragCountField&gt;(3);
152   received3.add&lt;lp::SequenceField&gt;(1002);
153   bool isComplete = false;
154   Block netPacket;
155   lp::Packet packet;
156   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
157   BOOST_REQUIRE(!isComplete);
158   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
159   BOOST_REQUIRE(!isComplete);
160   std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received3);
161   BOOST_REQUIRE(isComplete);
162   BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
163   BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
164 }
165 BOOST_AUTO_TEST_CASE(OutOfOrder)
166 {
167   ndn::Buffer data0Buffer(data, 4);
168   ndn::Buffer data1Buffer(data + 4, 4);
169   ndn::Buffer data2Buffer(data + 8, 2);
170   lp::Packet frag0;
171   frag0.add&lt;lp::FragmentField&gt;(std::make_pair(data0Buffer.begin(), data0Buffer.end()));
172   frag0.add&lt;lp::FragIndexField&gt;(0);
173   frag0.add&lt;lp::FragCountField&gt;(3);
174   frag0.add&lt;lp::SequenceField&gt;(1000);
175   frag0.add&lt;lp::NextHopFaceIdField&gt;(200);
176   lp::Packet frag1;
177   frag1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
178   frag1.add&lt;lp::FragIndexField&gt;(1);
179   frag1.add&lt;lp::FragCountField&gt;(3);
180   frag1.add&lt;lp::SequenceField&gt;(1001);
181   lp::Packet frag2;
182   frag2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
183   frag2.add&lt;lp::FragIndexField&gt;(2);
184   frag2.add&lt;lp::FragCountField&gt;(3);
185   frag2.add&lt;lp::SequenceField&gt;(1002);
186   bool isComplete = false;
187   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, frag2);
188   BOOST_REQUIRE(!isComplete);
189   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, frag0);
190   BOOST_REQUIRE(!isComplete);
191   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, frag1);
192   BOOST_REQUIRE(isComplete);
193 }
194 BOOST_AUTO_TEST_CASE(Duplicate)
195 {
196   ndn::Buffer data0Buffer(data, 5);
197   lp::Packet frag0;
198   frag0.add&lt;lp::FragmentField&gt;(std::make_pair(data0Buffer.begin(), data0Buffer.end()));
199   frag0.add&lt;lp::FragIndexField&gt;(0);
200   frag0.add&lt;lp::FragCountField&gt;(2);
201   frag0.add&lt;lp::SequenceField&gt;(1000);
202   bool isComplete = false;
203   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, frag0);
204   BOOST_REQUIRE(!isComplete);
205   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(1, frag0);
206   BOOST_REQUIRE(!isComplete);
207 }
208 BOOST_AUTO_TEST_CASE(Timeout)
209 {
210   ndn::Buffer data1Buffer(data, 5);
211   ndn::Buffer data2Buffer(data + 5, 5);
212   lp::Packet received1;
213   received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
214   received1.add&lt;lp::FragIndexField&gt;(0);
215   received1.add&lt;lp::FragCountField&gt;(2);
216   received1.add&lt;lp::SequenceField&gt;(1000);
217   received1.add&lt;lp::NextHopFaceIdField&gt;(200);
218   lp::Packet received2;
219   received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
220   received2.add&lt;lp::FragIndexField&gt;(1);
221   received2.add&lt;lp::FragCountField&gt;(2);
222   received2.add&lt;lp::SequenceField&gt;(1001);
223   const EndpointId REMOTE_EP = 11028;
224   bool isComplete = false;
225   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(REMOTE_EP, received1);
226   BOOST_REQUIRE(!isComplete);
227   BOOST_CHECK_EQUAL(reassembler.size(), 1);
228   BOOST_CHECK(timeoutHistory.empty());
229   advanceClocks(1_ms, 600);
230   BOOST_CHECK_EQUAL(reassembler.size(), 0);
231   BOOST_REQUIRE_EQUAL(timeoutHistory.size(), 1);
232   BOOST_CHECK_EQUAL(std::get&lt;0&gt;(timeoutHistory.back()), REMOTE_EP);
233   BOOST_CHECK_EQUAL(std::get&lt;1&gt;(timeoutHistory.back()), 1);
234   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(REMOTE_EP, received2);
235   BOOST_REQUIRE(!isComplete);
236 }
237 BOOST_AUTO_TEST_CASE(MissingSequence)
238 {
239   ndn::Buffer data1Buffer(data, 4);
240   ndn::Buffer data2Buffer(data + 4, 4);
241   ndn::Buffer data3Buffer(data + 8, 2);
242   lp::Packet received1;
243   received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
244   received1.add&lt;lp::FragIndexField&gt;(0);
245   received1.add&lt;lp::FragCountField&gt;(3);
246   received1.add&lt;lp::SequenceField&gt;(1000);
247   received1.add&lt;lp::NextHopFaceIdField&gt;(200);
248   lp::Packet received2;
249   received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
250   received2.add&lt;lp::FragIndexField&gt;(1);
251   received2.add&lt;lp::FragCountField&gt;(3);
252   lp::Packet received3;
253   received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
254   received3.add&lt;lp::FragIndexField&gt;(2);
255   received3.add&lt;lp::FragCountField&gt;(3);
256   received3.add&lt;lp::SequenceField&gt;(1002);
257   bool isComplete = false;
258   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
259   BOOST_REQUIRE(!isComplete);
260   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
261   BOOST_REQUIRE(!isComplete);
262   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received3);
263   BOOST_REQUIRE(!isComplete);
264   advanceClocks(1_ms, 600);
265   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
266   BOOST_REQUIRE(!isComplete);
267 }
268 BOOST_AUTO_TEST_CASE(FragCountOverLimit)
269 {
270   ndn::Buffer data1Buffer(data, sizeof(data));
271   lp::Packet received1;
272   received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
273   received1.add&lt;lp::FragIndexField&gt;(0);
274   received1.add&lt;lp::FragCountField&gt;(256);
275   received1.add&lt;lp::SequenceField&gt;(1000);
276   received1.add&lt;lp::NextHopFaceIdField&gt;(200);
277   bool isComplete = false;
278   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
279   BOOST_REQUIRE(!isComplete);
280 }
281 BOOST_AUTO_TEST_CASE(MissingFragCount)
282 {
283   ndn::Buffer data1Buffer(data, 4);
284   ndn::Buffer data2Buffer(data + 4, 4);
285   ndn::Buffer data3Buffer(data + 8, 2);
286   lp::Packet received1;
287   received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
288   received1.add&lt;lp::FragIndexField&gt;(0);
289   received1.add&lt;lp::FragCountField&gt;(3);
290   received1.add&lt;lp::SequenceField&gt;(1000);
291   received1.add&lt;lp::NextHopFaceIdField&gt;(200);
292   lp::Packet received2;
293   received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
294   received2.add&lt;lp::FragIndexField&gt;(1);
295   received2.add&lt;lp::FragCountField&gt;(50);
296   received2.add&lt;lp::SequenceField&gt;(1001);
297   lp::Packet received3;
298   received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
299   received3.add&lt;lp::FragIndexField&gt;(2);
300   received3.add&lt;lp::FragCountField&gt;(3);
301   received3.add&lt;lp::SequenceField&gt;(1002);
302   bool isComplete = false;
303   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
304   BOOST_REQUIRE(!isComplete);
305   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
306   BOOST_REQUIRE(!isComplete);
307   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received3);
308   BOOST_REQUIRE(!isComplete);
309 }
310 BOOST_AUTO_TEST_CASE(OverFragCount)
311 {
312   LpReassembler::Options options;
313   options.nMaxFragments = 2;
314   reassembler.setOptions(options);
315   ndn::Buffer data1Buffer(data, 4);
316   ndn::Buffer data2Buffer(data + 4, 4);
317   ndn::Buffer data3Buffer(data + 8, 2);
318   lp::Packet received1;
319   received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
320   received1.add&lt;lp::FragIndexField&gt;(0);
321   received1.add&lt;lp::FragCountField&gt;(3);
322   received1.add&lt;lp::SequenceField&gt;(1000);
323   received1.add&lt;lp::NextHopFaceIdField&gt;(200);
324   lp::Packet received2;
325   received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
326   received2.add&lt;lp::FragIndexField&gt;(1);
327   received2.add&lt;lp::FragCountField&gt;(3);
328   received2.add&lt;lp::SequenceField&gt;(1001);
329   lp::Packet received3;
330   received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
331   received3.add&lt;lp::FragIndexField&gt;(2);
332   received3.add&lt;lp::FragCountField&gt;(3);
333   received3.add&lt;lp::SequenceField&gt;(1002);
334   bool isComplete = false;
335   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
336   BOOST_REQUIRE(!isComplete);
337   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
338   BOOST_REQUIRE(!isComplete);
339   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received3);
340   BOOST_REQUIRE(!isComplete);
341 }
342 BOOST_AUTO_TEST_SUITE_END() 
343 BOOST_AUTO_TEST_SUITE(MultipleRemoteEndpoints)
344 BOOST_AUTO_TEST_CASE(Normal)
345 {
346   ndn::Buffer data1Buffer(data, 5);
347   ndn::Buffer data2Buffer(data + 5, 5);
348   lp::Packet frag1_1;
349   frag1_1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
350   frag1_1.add&lt;lp::FragIndexField&gt;(0);
351   frag1_1.add&lt;lp::FragCountField&gt;(2);
352   frag1_1.add&lt;lp::SequenceField&gt;(2000);
353   frag1_1.add&lt;lp::NextHopFaceIdField&gt;(200);
354   lp::Packet frag1_2;
355   frag1_2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
356   frag1_2.add&lt;lp::FragIndexField&gt;(1);
357   frag1_2.add&lt;lp::FragCountField&gt;(2);
358   frag1_2.add&lt;lp::SequenceField&gt;(2001);
359   lp::Packet frag2_1;
360   frag2_1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
361   frag2_1.add&lt;lp::FragIndexField&gt;(0);
362   frag2_1.add&lt;lp::FragCountField&gt;(2);
363   frag2_1.add&lt;lp::SequenceField&gt;(2000);
364   frag2_1.add&lt;lp::NextHopFaceIdField&gt;(200);
365   lp::Packet frag2_2;
366   frag2_2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
367   frag2_2.add&lt;lp::FragIndexField&gt;(1);
368   frag2_2.add&lt;lp::FragCountField&gt;(2);
369   frag2_2.add&lt;lp::SequenceField&gt;(2001);
370   bool isComplete = false;
371   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(1, frag1_1);
372   BOOST_REQUIRE(!isComplete);
373   BOOST_CHECK_EQUAL(reassembler.size(), 1);
374   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(2, frag2_2);
375   BOOST_REQUIRE(!isComplete);
376   BOOST_CHECK_EQUAL(reassembler.size(), 2);
377   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(1, frag1_2);
378   BOOST_REQUIRE(isComplete);
379   BOOST_CHECK_EQUAL(reassembler.size(), 1);
380   std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(2, frag2_1);
381   BOOST_REQUIRE(isComplete);
382   BOOST_CHECK_EQUAL(reassembler.size(), 0);
383 }
384 BOOST_AUTO_TEST_SUITE_END() 
385 BOOST_AUTO_TEST_SUITE_END() BOOST_AUTO_TEST_SUITE_END() 
} } } </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
