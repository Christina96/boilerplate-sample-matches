<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for cs-module.cpp & lp-reassembler.t.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for cs-module.cpp & lp-reassembler.t.cpp
      </h3>
      <h1 align="center">
        4.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>cs-module.cpp (8.280254%)<TH>lp-reassembler.t.cpp (2.9816513%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match816-0.html#0',2,'match816-1.html#0',3)" NAME="0">(41-50)<TD><A HREF="javascript:ZweiFrames('match816-0.html#0',2,'match816-1.html#0',3)" NAME="0">(152-164)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cs-module.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2020,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;cs-module.hpp&quot;
#include &quot;format-helpers.hpp&quot;

#include &lt;ndn-cxx/util/indented-stream.hpp&gt;

namespace nfd {
namespace tools {
namespace nfdc {

void
CsModule::registerCommands(CommandParser&amp; parser)
{
<A NAME="0"></A>  CommandDefinition defCsConfig(&quot;cs&quot;, &quot;config&quot;);
  defCsConfig
    .setTitle(&quot;change CS configuration&quot;)
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match816-1.html#0',3,'match816-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    .addArg(&quot;capacity&quot;, ArgValueType::UNSIGNED, Required::NO, Positional::NO)
    .addArg(&quot;admit&quot;, ArgValueType::BOOLEAN, Required::NO, Positional::NO)
    .addArg(&quot;serve&quot;, ArgValueType::BOOLEAN, Required::NO, Positional::NO);
  parser.addCommand(defCsConfig, &amp;CsModule::config);

  CommandDefinition defCsErase(&quot;cs&quot;, &quot;erase&quot;);
  defCsErase
    .setTitle(&quot;erase cached Data&quot;)
    .addArg(&quot;prefix&quot;, ArgValueType::NAME, Required::YES, Positional::YES)
    .addArg(&quot;count&quot;, ArgValueType::UNSIGNED, Required::NO, Positional::NO);</B></FONT>
  parser.addCommand(defCsErase, &amp;CsModule::erase);
}

void
CsModule::config(ExecuteContext&amp; ctx)
{
  using boost::logic::indeterminate;

  auto capacity = ctx.args.getOptional&lt;uint64_t&gt;(&quot;capacity&quot;);
  auto enableAdmit = ctx.args.getTribool(&quot;admit&quot;);
  auto enableServe = ctx.args.getTribool(&quot;serve&quot;);

  ControlParameters p;
  if (capacity) {
    p.setCapacity(*capacity);
  }
  if (!indeterminate(enableAdmit)) {
    p.setFlagBit(ndn::nfd::BIT_CS_ENABLE_ADMIT, bool(enableAdmit));
  }
  if (!indeterminate(enableServe)) {
    p.setFlagBit(ndn::nfd::BIT_CS_ENABLE_SERVE, bool(enableServe));
  }

  ctx.controller.start&lt;ndn::nfd::CsConfigCommand&gt;(p,
    [&amp;] (const ControlParameters&amp; resp) {
      text::ItemAttributes ia;
      ctx.out &lt;&lt; &quot;cs-config-updated &quot;
              &lt;&lt; ia(&quot;capacity&quot;) &lt;&lt; resp.getCapacity()
              &lt;&lt; ia(&quot;admit&quot;) &lt;&lt; text::OnOff{resp.getFlagBit(ndn::nfd::BIT_CS_ENABLE_ADMIT)}
              &lt;&lt; ia(&quot;serve&quot;) &lt;&lt; text::OnOff{resp.getFlagBit(ndn::nfd::BIT_CS_ENABLE_SERVE)}
              &lt;&lt; '\n';
    },
    ctx.makeCommandFailureHandler(&quot;updating CS config&quot;),
    ctx.makeCommandOptions());

  ctx.face.processEvents();
}

void
CsModule::erase(ExecuteContext&amp; ctx)
{
  auto prefix = ctx.args.get&lt;Name&gt;(&quot;prefix&quot;);
  auto count = ctx.args.getOptional&lt;uint64_t&gt;(&quot;count&quot;);

  uint64_t numErased = 0;
  bool wasLimited = false;
  bool wasSuccessful = true;

  ControlParameters params;
  params.setName(prefix);

  // The cs/erase command can have a limit on the number of CS entries erased in a single operation.
  // Therefore, we may need to run cs/erase multiple times to achieve the desired number of erases.
  do {
    if (count) {
      params.setCount(*count - numErased);
    }

    wasSuccessful = false;

    ctx.controller.start&lt;ndn::nfd::CsEraseCommand&gt;(
      params,
      [&amp;] (const ControlParameters&amp; resp) {
        wasSuccessful = true;
        numErased += resp.getCount();
        wasLimited = resp.hasCapacity();
      },
      ctx.makeCommandFailureHandler(&quot;erasing cached Data&quot;),
      ctx.makeCommandOptions());

    ctx.face.processEvents();
  } while (wasSuccessful &amp;&amp; wasLimited);

  if (wasSuccessful) {
    text::ItemAttributes ia;
    ctx.out &lt;&lt; &quot;cs-erased &quot;
            &lt;&lt; ia(&quot;prefix&quot;) &lt;&lt; prefix
            &lt;&lt; ia(&quot;count&quot;) &lt;&lt; numErased
            &lt;&lt; '\n';
  }
}

void
CsModule::fetchStatus(Controller&amp; controller,
                      const std::function&lt;void()&gt;&amp; onSuccess,
                      const Controller::DatasetFailCallback&amp; onFailure,
                      const CommandOptions&amp; options)
{
  controller.fetch&lt;ndn::nfd::CsInfoDataset&gt;(
    [this, onSuccess] (const CsInfo&amp; result) {
      m_status = result;
      onSuccess();
    },
    onFailure, options);
}

void
CsModule::formatStatusXml(std::ostream&amp; os) const
{
  formatItemXml(os, m_status);
}

void
CsModule::formatItemXml(std::ostream&amp; os, const CsInfo&amp; item)
{
  os &lt;&lt; &quot;&lt;cs&gt;&quot;;
  os &lt;&lt; &quot;&lt;capacity&gt;&quot; &lt;&lt; item.getCapacity() &lt;&lt; &quot;&lt;/capacity&gt;&quot;;
  os &lt;&lt; xml::Flag{&quot;admitEnabled&quot;, item.getEnableAdmit()};
  os &lt;&lt; xml::Flag{&quot;serveEnabled&quot;, item.getEnableServe()};
  os &lt;&lt; &quot;&lt;nEntries&gt;&quot; &lt;&lt; item.getNEntries() &lt;&lt; &quot;&lt;/nEntries&gt;&quot;;
  os &lt;&lt; &quot;&lt;nHits&gt;&quot; &lt;&lt; item.getNHits() &lt;&lt; &quot;&lt;/nHits&gt;&quot;;
  os &lt;&lt; &quot;&lt;nMisses&gt;&quot; &lt;&lt; item.getNMisses() &lt;&lt; &quot;&lt;/nMisses&gt;&quot;;
  os &lt;&lt; &quot;&lt;/cs&gt;&quot;;
}

void
CsModule::formatStatusText(std::ostream&amp; os) const
{
  os &lt;&lt; &quot;CS information:\n&quot;;
  ndn::util::IndentedStream indented(os, &quot;  &quot;);
  formatItemText(indented, m_status);
}

void
CsModule::formatItemText(std::ostream&amp; os, const CsInfo&amp; item)
{
  text::ItemAttributes ia(true, 8);
  os &lt;&lt; ia(&quot;capacity&quot;) &lt;&lt; item.getCapacity()
     &lt;&lt; ia(&quot;admit&quot;) &lt;&lt; text::OnOff{item.getEnableAdmit()}
     &lt;&lt; ia(&quot;serve&quot;) &lt;&lt; text::OnOff{item.getEnableServe()}
     &lt;&lt; ia(&quot;nEntries&quot;) &lt;&lt; item.getNEntries()
     &lt;&lt; ia(&quot;nHits&quot;) &lt;&lt; item.getNHits()
     &lt;&lt; ia(&quot;nMisses&quot;) &lt;&lt; item.getNMisses()
     &lt;&lt; ia.end();
}

} // namespace nfdc
} // namespace tools
} // namespace nfd
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lp-reassembler.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2019,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;face/lp-reassembler.hpp&quot;

#include &quot;tests/test-common.hpp&quot;
#include &quot;tests/daemon/global-io-fixture.hpp&quot;

namespace nfd {
namespace face {
namespace tests {

using namespace nfd::tests;

class LpReassemblerFixture : public GlobalIoTimeFixture
{
protected:
  LpReassemblerFixture()
  {
    reassembler.beforeTimeout.connect(
      [this] (EndpointId remoteEp, size_t nDroppedFragments) {
        timeoutHistory.push_back({remoteEp, nDroppedFragments});
      });
  }

protected:
  LpReassembler reassembler{{}};
  std::vector&lt;std::pair&lt;EndpointId, size_t&gt;&gt; timeoutHistory;

  static const uint8_t data[10];
};

const uint8_t LpReassemblerFixture::data[10] = {
  0x06, 0x08, // Data
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
};

BOOST_AUTO_TEST_SUITE(Face)
BOOST_FIXTURE_TEST_SUITE(TestLpReassembler, LpReassemblerFixture)

BOOST_AUTO_TEST_SUITE(SingleFragment)

BOOST_AUTO_TEST_CASE(Normal)
{
  ndn::Buffer dataBuffer(data, sizeof(data));

  lp::Packet received;
  received.add&lt;lp::FragmentField&gt;(std::make_pair(dataBuffer.begin(), dataBuffer.end()));
  received.add&lt;lp::FragIndexField&gt;(0);
  received.add&lt;lp::FragCountField&gt;(1);
  received.add&lt;lp::SequenceField&gt;(1000);
  received.add&lt;lp::NextHopFaceIdField&gt;(200);

  bool isComplete = false;
  Block netPacket;
  lp::Packet packet;
  std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received);

  BOOST_REQUIRE(isComplete);
  BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
  BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
  BOOST_CHECK_EQUAL(reassembler.size(), 0);
}

BOOST_AUTO_TEST_CASE(OmitFragIndex)
{
  ndn::Buffer dataBuffer(data, sizeof(data));

  lp::Packet received;
  received.add&lt;lp::FragmentField&gt;(std::make_pair(dataBuffer.begin(), dataBuffer.end()));
  received.add&lt;lp::FragCountField&gt;(1);
  received.add&lt;lp::SequenceField&gt;(1000);
  received.add&lt;lp::NextHopFaceIdField&gt;(200);

  bool isComplete = false;
  Block netPacket;
  lp::Packet packet;
  std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received);

  BOOST_REQUIRE(isComplete);
  BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
  BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
}

BOOST_AUTO_TEST_CASE(OmitFragCount)
{
  ndn::Buffer dataBuffer(data, sizeof(data));

  lp::Packet received;
  received.add&lt;lp::FragmentField&gt;(std::make_pair(dataBuffer.begin(), dataBuffer.end()));
  received.add&lt;lp::FragIndexField&gt;(0);
  received.add&lt;lp::SequenceField&gt;(1000);
  received.add&lt;lp::NextHopFaceIdField&gt;(200);

  bool isComplete = false;
  Block netPacket;
  lp::Packet packet;
  std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received);

  BOOST_REQUIRE(isComplete);
  BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
  BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
}

BOOST_AUTO_TEST_CASE(OmitFragIndexAndFragCount)
{
  ndn::Buffer dataBuffer(data, sizeof(data));

  lp::Packet received;
  received.add&lt;lp::FragmentField&gt;(std::make_pair(dataBuffer.begin(), dataBuffer.end()));
  received.add&lt;lp::SequenceField&gt;(1000);
  received.add&lt;lp::NextHopFaceIdField&gt;(200);

  bool isComplete = false;
  Block netPacket;
  lp::Packet packet;
  std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received);

  BOOST_REQUIRE(isComplete);
  BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
  BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
}

BOOST_AUTO_TEST_SUITE_END() // SingleFragment

BOOST_AUTO_TEST_SUITE(MultiFragment)
<A NAME="0"></A>
BOOST_AUTO_TEST_CASE(Normal)
{
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match816-0.html#0',2,'match816-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  ndn::Buffer data1Buffer(data, 4);
  ndn::Buffer data2Buffer(data + 4, 4);
  ndn::Buffer data3Buffer(data + 8, 2);

  lp::Packet received1;
  received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  received1.add&lt;lp::FragIndexField&gt;(0);
  received1.add&lt;lp::FragCountField&gt;(3);
  received1.add&lt;lp::SequenceField&gt;(1000);
  received1.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet received2;
  received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));</B></FONT>
  received2.add&lt;lp::FragIndexField&gt;(1);
  received2.add&lt;lp::FragCountField&gt;(3);
  received2.add&lt;lp::SequenceField&gt;(1001);

  lp::Packet received3;
  received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
  received3.add&lt;lp::FragIndexField&gt;(2);
  received3.add&lt;lp::FragCountField&gt;(3);
  received3.add&lt;lp::SequenceField&gt;(1002);

  bool isComplete = false;
  Block netPacket;
  lp::Packet packet;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
  BOOST_REQUIRE(!isComplete);
  BOOST_CHECK_EQUAL(reassembler.size(), 1);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
  BOOST_REQUIRE(!isComplete);
  BOOST_CHECK_EQUAL(reassembler.size(), 1);

  std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received3);
  BOOST_REQUIRE(isComplete);
  BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
  BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
  BOOST_CHECK_EQUAL(reassembler.size(), 0);
}

BOOST_AUTO_TEST_CASE(OmitFragIndex0)
{
  ndn::Buffer data1Buffer(data, 4);
  ndn::Buffer data2Buffer(data + 4, 4);
  ndn::Buffer data3Buffer(data + 8, 2);

  lp::Packet received1;
  received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  received1.add&lt;lp::FragCountField&gt;(3);
  received1.add&lt;lp::SequenceField&gt;(1000);
  received1.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet received2;
  received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
  received2.add&lt;lp::FragIndexField&gt;(1);
  received2.add&lt;lp::FragCountField&gt;(3);
  received2.add&lt;lp::SequenceField&gt;(1001);

  lp::Packet received3;
  received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
  received3.add&lt;lp::FragIndexField&gt;(2);
  received3.add&lt;lp::FragCountField&gt;(3);
  received3.add&lt;lp::SequenceField&gt;(1002);

  bool isComplete = false;
  Block netPacket;
  lp::Packet packet;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, netPacket, packet) = reassembler.receiveFragment(0, received3);
  BOOST_REQUIRE(isComplete);
  BOOST_CHECK(packet.has&lt;lp::NextHopFaceIdField&gt;());
  BOOST_CHECK_EQUAL_COLLECTIONS(data, data + sizeof(data), netPacket.begin(), netPacket.end());
}

BOOST_AUTO_TEST_CASE(OutOfOrder)
{
  ndn::Buffer data0Buffer(data, 4);
  ndn::Buffer data1Buffer(data + 4, 4);
  ndn::Buffer data2Buffer(data + 8, 2);

  lp::Packet frag0;
  frag0.add&lt;lp::FragmentField&gt;(std::make_pair(data0Buffer.begin(), data0Buffer.end()));
  frag0.add&lt;lp::FragIndexField&gt;(0);
  frag0.add&lt;lp::FragCountField&gt;(3);
  frag0.add&lt;lp::SequenceField&gt;(1000);
  frag0.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet frag1;
  frag1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  frag1.add&lt;lp::FragIndexField&gt;(1);
  frag1.add&lt;lp::FragCountField&gt;(3);
  frag1.add&lt;lp::SequenceField&gt;(1001);

  lp::Packet frag2;
  frag2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
  frag2.add&lt;lp::FragIndexField&gt;(2);
  frag2.add&lt;lp::FragCountField&gt;(3);
  frag2.add&lt;lp::SequenceField&gt;(1002);

  bool isComplete = false;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, frag2);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, frag0);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, frag1);
  BOOST_REQUIRE(isComplete);
}

BOOST_AUTO_TEST_CASE(Duplicate)
{
  ndn::Buffer data0Buffer(data, 5);

  lp::Packet frag0;
  frag0.add&lt;lp::FragmentField&gt;(std::make_pair(data0Buffer.begin(), data0Buffer.end()));
  frag0.add&lt;lp::FragIndexField&gt;(0);
  frag0.add&lt;lp::FragCountField&gt;(2);
  frag0.add&lt;lp::SequenceField&gt;(1000);

  bool isComplete = false;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, frag0);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(1, frag0);
  BOOST_REQUIRE(!isComplete);
}

BOOST_AUTO_TEST_CASE(Timeout)
{
  ndn::Buffer data1Buffer(data, 5);
  ndn::Buffer data2Buffer(data + 5, 5);

  lp::Packet received1;
  received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  received1.add&lt;lp::FragIndexField&gt;(0);
  received1.add&lt;lp::FragCountField&gt;(2);
  received1.add&lt;lp::SequenceField&gt;(1000);
  received1.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet received2;
  received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
  received2.add&lt;lp::FragIndexField&gt;(1);
  received2.add&lt;lp::FragCountField&gt;(2);
  received2.add&lt;lp::SequenceField&gt;(1001);

  const EndpointId REMOTE_EP = 11028;
  bool isComplete = false;
  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(REMOTE_EP, received1);
  BOOST_REQUIRE(!isComplete);
  BOOST_CHECK_EQUAL(reassembler.size(), 1);
  BOOST_CHECK(timeoutHistory.empty());

  advanceClocks(1_ms, 600);
  BOOST_CHECK_EQUAL(reassembler.size(), 0);
  BOOST_REQUIRE_EQUAL(timeoutHistory.size(), 1);
  BOOST_CHECK_EQUAL(std::get&lt;0&gt;(timeoutHistory.back()), REMOTE_EP);
  BOOST_CHECK_EQUAL(std::get&lt;1&gt;(timeoutHistory.back()), 1);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(REMOTE_EP, received2);
  BOOST_REQUIRE(!isComplete);
}

BOOST_AUTO_TEST_CASE(MissingSequence)
{
  ndn::Buffer data1Buffer(data, 4);
  ndn::Buffer data2Buffer(data + 4, 4);
  ndn::Buffer data3Buffer(data + 8, 2);

  lp::Packet received1;
  received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  received1.add&lt;lp::FragIndexField&gt;(0);
  received1.add&lt;lp::FragCountField&gt;(3);
  received1.add&lt;lp::SequenceField&gt;(1000);
  received1.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet received2;
  received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
  received2.add&lt;lp::FragIndexField&gt;(1);
  received2.add&lt;lp::FragCountField&gt;(3);

  lp::Packet received3;
  received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
  received3.add&lt;lp::FragIndexField&gt;(2);
  received3.add&lt;lp::FragCountField&gt;(3);
  received3.add&lt;lp::SequenceField&gt;(1002);

  bool isComplete = false;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received3);
  BOOST_REQUIRE(!isComplete);

  advanceClocks(1_ms, 600);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
  BOOST_REQUIRE(!isComplete);
}

BOOST_AUTO_TEST_CASE(FragCountOverLimit)
{
  ndn::Buffer data1Buffer(data, sizeof(data));

  lp::Packet received1;
  received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  received1.add&lt;lp::FragIndexField&gt;(0);
  received1.add&lt;lp::FragCountField&gt;(256);
  received1.add&lt;lp::SequenceField&gt;(1000);
  received1.add&lt;lp::NextHopFaceIdField&gt;(200);

  bool isComplete = false;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
  BOOST_REQUIRE(!isComplete);
}

BOOST_AUTO_TEST_CASE(MissingFragCount)
{
  ndn::Buffer data1Buffer(data, 4);
  ndn::Buffer data2Buffer(data + 4, 4);
  ndn::Buffer data3Buffer(data + 8, 2);

  lp::Packet received1;
  received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  received1.add&lt;lp::FragIndexField&gt;(0);
  received1.add&lt;lp::FragCountField&gt;(3);
  received1.add&lt;lp::SequenceField&gt;(1000);
  received1.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet received2;
  received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
  received2.add&lt;lp::FragIndexField&gt;(1);
  received2.add&lt;lp::FragCountField&gt;(50);
  received2.add&lt;lp::SequenceField&gt;(1001);

  lp::Packet received3;
  received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
  received3.add&lt;lp::FragIndexField&gt;(2);
  received3.add&lt;lp::FragCountField&gt;(3);
  received3.add&lt;lp::SequenceField&gt;(1002);

  bool isComplete = false;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received3);
  BOOST_REQUIRE(!isComplete);
}

BOOST_AUTO_TEST_CASE(OverFragCount)
{
  LpReassembler::Options options;
  options.nMaxFragments = 2;
  reassembler.setOptions(options);

  ndn::Buffer data1Buffer(data, 4);
  ndn::Buffer data2Buffer(data + 4, 4);
  ndn::Buffer data3Buffer(data + 8, 2);

  lp::Packet received1;
  received1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  received1.add&lt;lp::FragIndexField&gt;(0);
  received1.add&lt;lp::FragCountField&gt;(3);
  received1.add&lt;lp::SequenceField&gt;(1000);
  received1.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet received2;
  received2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
  received2.add&lt;lp::FragIndexField&gt;(1);
  received2.add&lt;lp::FragCountField&gt;(3);
  received2.add&lt;lp::SequenceField&gt;(1001);

  lp::Packet received3;
  received3.add&lt;lp::FragmentField&gt;(std::make_pair(data3Buffer.begin(), data3Buffer.end()));
  received3.add&lt;lp::FragIndexField&gt;(2);
  received3.add&lt;lp::FragCountField&gt;(3);
  received3.add&lt;lp::SequenceField&gt;(1002);

  bool isComplete = false;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received1);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received2);
  BOOST_REQUIRE(!isComplete);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(0, received3);
  BOOST_REQUIRE(!isComplete);
}

BOOST_AUTO_TEST_SUITE_END() // MultiFragment

BOOST_AUTO_TEST_SUITE(MultipleRemoteEndpoints)

BOOST_AUTO_TEST_CASE(Normal)
{
  ndn::Buffer data1Buffer(data, 5);
  ndn::Buffer data2Buffer(data + 5, 5);

  lp::Packet frag1_1;
  frag1_1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  frag1_1.add&lt;lp::FragIndexField&gt;(0);
  frag1_1.add&lt;lp::FragCountField&gt;(2);
  frag1_1.add&lt;lp::SequenceField&gt;(2000);
  frag1_1.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet frag1_2;
  frag1_2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
  frag1_2.add&lt;lp::FragIndexField&gt;(1);
  frag1_2.add&lt;lp::FragCountField&gt;(2);
  frag1_2.add&lt;lp::SequenceField&gt;(2001);

  lp::Packet frag2_1;
  frag2_1.add&lt;lp::FragmentField&gt;(std::make_pair(data1Buffer.begin(), data1Buffer.end()));
  frag2_1.add&lt;lp::FragIndexField&gt;(0);
  frag2_1.add&lt;lp::FragCountField&gt;(2);
  frag2_1.add&lt;lp::SequenceField&gt;(2000);
  frag2_1.add&lt;lp::NextHopFaceIdField&gt;(200);

  lp::Packet frag2_2;
  frag2_2.add&lt;lp::FragmentField&gt;(std::make_pair(data2Buffer.begin(), data2Buffer.end()));
  frag2_2.add&lt;lp::FragIndexField&gt;(1);
  frag2_2.add&lt;lp::FragCountField&gt;(2);
  frag2_2.add&lt;lp::SequenceField&gt;(2001);

  bool isComplete = false;

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(1, frag1_1);
  BOOST_REQUIRE(!isComplete);
  BOOST_CHECK_EQUAL(reassembler.size(), 1);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(2, frag2_2);
  BOOST_REQUIRE(!isComplete);
  BOOST_CHECK_EQUAL(reassembler.size(), 2);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(1, frag1_2);
  BOOST_REQUIRE(isComplete);
  BOOST_CHECK_EQUAL(reassembler.size(), 1);

  std::tie(isComplete, std::ignore, std::ignore) = reassembler.receiveFragment(2, frag2_1);
  BOOST_REQUIRE(isComplete);
  BOOST_CHECK_EQUAL(reassembler.size(), 0);
}

BOOST_AUTO_TEST_SUITE_END() // MultipleRemoteEndpoints

BOOST_AUTO_TEST_SUITE_END() // TestLpReassembler
BOOST_AUTO_TEST_SUITE_END() // Face

} // namespace tests
} // namespace face
} // namespace nfd
</PRE>
</div>
  </div>
</body>
</html>
