
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-unordered_map_constructor_test.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_UNORDERED_MAP_CONSTRUCTOR_TEST_H_
2  #define ABSL_CONTAINER_INTERNAL_UNORDERED_MAP_CONSTRUCTOR_TEST_H_
3  #include &lt;algorithm&gt;
4  #include &lt;unordered_map&gt;
5  #include &lt;vector&gt;
6  #include &quot;gmock/gmock.h&quot;
7  #include &quot;gtest/gtest.h&quot;
8  #include &quot;absl/container/internal/hash_generator_testing.h&quot;
9  #include &quot;absl/container/internal/hash_policy_testing.h&quot;
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  namespace container_internal {
13  template &lt;class UnordMap&gt;
14  class ConstructorTest : public ::testing::Test {};
15  TYPED_TEST_SUITE_P(ConstructorTest);
16  TYPED_TEST_P(ConstructorTest, NoArgs) {
17    TypeParam m;
18    EXPECT_TRUE(m.empty());
19    EXPECT_THAT(m, ::testing::UnorderedElementsAre());
20  }
21  TYPED_TEST_P(ConstructorTest, BucketCount) {
22    TypeParam m(123);
23    EXPECT_TRUE(m.empty());
24    EXPECT_THAT(m, ::testing::UnorderedElementsAre());
25    EXPECT_GE(m.bucket_count(), 123);
26  }
27  TYPED_TEST_P(ConstructorTest, BucketCountHash) {
28    using H = typename TypeParam::hasher;
29    H hasher;
30    TypeParam m(123, hasher);
31    EXPECT_EQ(m.hash_function(), hasher);
32    EXPECT_TRUE(m.empty());
33    EXPECT_THAT(m, ::testing::UnorderedElementsAre());
34    EXPECT_GE(m.bucket_count(), 123);
35  }
36  TYPED_TEST_P(ConstructorTest, BucketCountHashEqual) {
37    using H = typename TypeParam::hasher;
38    using E = typename TypeParam::key_equal;
39    H hasher;
40    E equal;
41    TypeParam m(123, hasher, equal);
42    EXPECT_EQ(m.hash_function(), hasher);
43    EXPECT_EQ(m.key_eq(), equal);
44    EXPECT_TRUE(m.empty());
45    EXPECT_THAT(m, ::testing::UnorderedElementsAre());
46    EXPECT_GE(m.bucket_count(), 123);
47  }
48  TYPED_TEST_P(ConstructorTest, BucketCountHashEqualAlloc) {
49    using H = typename TypeParam::hasher;
50    using E = typename TypeParam::key_equal;
51    using A = typename TypeParam::allocator_type;
52    H hasher;
53    E equal;
54    A alloc(0);
55    TypeParam m(123, hasher, equal, alloc);
56    EXPECT_EQ(m.hash_function(), hasher);
57    EXPECT_EQ(m.key_eq(), equal);
58    EXPECT_EQ(m.get_allocator(), alloc);
59    EXPECT_TRUE(m.empty());
60    EXPECT_THAT(m, ::testing::UnorderedElementsAre());
61    EXPECT_GE(m.bucket_count(), 123);
62  }
63  template &lt;typename T&gt;
64  struct is_std_unordered_map : std::false_type {};
65  template &lt;typename... T&gt;
66  struct is_std_unordered_map&lt;std::unordered_map&lt;T...&gt;&gt; : std::true_type {};
67  #if defined(UNORDERED_MAP_CXX14) || defined(UNORDERED_MAP_CXX17)
68  using has_cxx14_std_apis = std::true_type;
69  #else
70  using has_cxx14_std_apis = std::false_type;
71  #endif
72  template &lt;typename T&gt;
73  using expect_cxx14_apis =
74      absl::disjunction&lt;absl::negation&lt;is_std_unordered_map&lt;T&gt;&gt;,
75                        has_cxx14_std_apis&gt;;
76  template &lt;typename TypeParam&gt;
77  void BucketCountAllocTest(std::false_type) {}
78  template &lt;typename TypeParam&gt;
79  void BucketCountAllocTest(std::true_type) {
80    using A = typename TypeParam::allocator_type;
81    A alloc(0);
82    TypeParam m(123, alloc);
83    EXPECT_EQ(m.get_allocator(), alloc);
84    EXPECT_TRUE(m.empty());
85    EXPECT_THAT(m, ::testing::UnorderedElementsAre());
86    EXPECT_GE(m.bucket_count(), 123);
87  }
88  TYPED_TEST_P(ConstructorTest, BucketCountAlloc) {
89    BucketCountAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
90  }
91  template &lt;typename TypeParam&gt;
92  void BucketCountHashAllocTest(std::false_type) {}
93  template &lt;typename TypeParam&gt;
94  void BucketCountHashAllocTest(std::true_type) {
95    using H = typename TypeParam::hasher;
96    using A = typename TypeParam::allocator_type;
97    H hasher;
98    A alloc(0);
99    TypeParam m(123, hasher, alloc);
100    EXPECT_EQ(m.hash_function(), hasher);
101    EXPECT_EQ(m.get_allocator(), alloc);
102    EXPECT_TRUE(m.empty());
103    EXPECT_THAT(m, ::testing::UnorderedElementsAre());
104    EXPECT_GE(m.bucket_count(), 123);
105  }
106  TYPED_TEST_P(ConstructorTest, BucketCountHashAlloc) {
107    BucketCountHashAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
108  }
109  #if ABSL_UNORDERED_SUPPORTS_ALLOC_CTORS
110  using has_alloc_std_constructors = std::true_type;
111  #else
112  using has_alloc_std_constructors = std::false_type;
113  #endif
114  template &lt;typename T&gt;
115  using expect_alloc_constructors =
116      absl::disjunction&lt;absl::negation&lt;is_std_unordered_map&lt;T&gt;&gt;,
117                        has_alloc_std_constructors&gt;;
118  template &lt;typename TypeParam&gt;
119  void AllocTest(std::false_type) {}
120  template &lt;typename TypeParam&gt;
121  void AllocTest(std::true_type) {
122    using A = typename TypeParam::allocator_type;
123    A alloc(0);
124    TypeParam m(alloc);
125    EXPECT_EQ(m.get_allocator(), alloc);
126    EXPECT_TRUE(m.empty());
127    EXPECT_THAT(m, ::testing::UnorderedElementsAre());
128  }
129  TYPED_TEST_P(ConstructorTest, Alloc) {
130    AllocTest&lt;TypeParam&gt;(expect_alloc_constructors&lt;TypeParam&gt;());
131  }
132  TYPED_TEST_P(ConstructorTest, InputIteratorBucketHashEqualAlloc) {
133    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
134    using H = typename TypeParam::hasher;
135    using E = typename TypeParam::key_equal;
136    using A = typename TypeParam::allocator_type;
137    H hasher;
138    E equal;
139    A alloc(0);
140    std::vector&lt;T&gt; values;
141    std::generate_n(std::back_inserter(values), 10,
142                    hash_internal::UniqueGenerator&lt;T&gt;());
143    TypeParam m(values.begin(), values.end(), 123, hasher, equal, alloc);
144    EXPECT_EQ(m.hash_function(), hasher);
145    EXPECT_EQ(m.key_eq(), equal);
146    EXPECT_EQ(m.get_allocator(), alloc);
147    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
148    EXPECT_GE(m.bucket_count(), 123);
149  }
150  template &lt;typename TypeParam&gt;
151  void InputIteratorBucketAllocTest(std::false_type) {}
152  template &lt;typename TypeParam&gt;
153  void InputIteratorBucketAllocTest(std::true_type) {
154    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
155    using A = typename TypeParam::allocator_type;
156    A alloc(0);
157    std::vector&lt;T&gt; values;
158    std::generate_n(std::back_inserter(values), 10,
159                    hash_internal::UniqueGenerator&lt;T&gt;());
160    TypeParam m(values.begin(), values.end(), 123, alloc);
161    EXPECT_EQ(m.get_allocator(), alloc);
162    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
163    EXPECT_GE(m.bucket_count(), 123);
164  }
165  TYPED_TEST_P(ConstructorTest, InputIteratorBucketAlloc) {
166    InputIteratorBucketAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
167  }
168  template &lt;typename TypeParam&gt;
169  void InputIteratorBucketHashAllocTest(std::false_type) {}
170  template &lt;typename TypeParam&gt;
171  void InputIteratorBucketHashAllocTest(std::true_type) {
172    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
173    using H = typename TypeParam::hasher;
174    using A = typename TypeParam::allocator_type;
175    H hasher;
176    A alloc(0);
177    std::vector&lt;T&gt; values;
178    std::generate_n(std::back_inserter(values), 10,
179                    hash_internal::UniqueGenerator&lt;T&gt;());
180    TypeParam m(values.begin(), values.end(), 123, hasher, alloc);
181    EXPECT_EQ(m.hash_function(), hasher);
182    EXPECT_EQ(m.get_allocator(), alloc);
183    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
184    EXPECT_GE(m.bucket_count(), 123);
185  }
186  TYPED_TEST_P(ConstructorTest, InputIteratorBucketHashAlloc) {
187    InputIteratorBucketHashAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
188  }
189  TYPED_TEST_P(ConstructorTest, CopyConstructor) {
190    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
191    using H = typename TypeParam::hasher;
192    using E = typename TypeParam::key_equal;
193    using A = typename TypeParam::allocator_type;
194    H hasher;
195    E equal;
196    A alloc(0);
197    hash_internal::UniqueGenerator&lt;T&gt; gen;
198    TypeParam m(123, hasher, equal, alloc);
199    for (size_t i = 0; i != 10; ++i) m.insert(gen());
200    TypeParam n(m);
201    EXPECT_EQ(m.hash_function(), n.hash_function());
202    EXPECT_EQ(m.key_eq(), n.key_eq());
203    EXPECT_EQ(m.get_allocator(), n.get_allocator());
204    EXPECT_EQ(m, n);
205  }
206  template &lt;typename TypeParam&gt;
<span onclick='openModal()' class='match'>207  void CopyConstructorAllocTest(std::false_type) {}
208  template &lt;typename TypeParam&gt;
209  void CopyConstructorAllocTest(std::true_type) {
210    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
</span>211    using H = typename TypeParam::hasher;
212    using E = typename TypeParam::key_equal;
213    using A = typename TypeParam::allocator_type;
214    H hasher;
215    E equal;
216    A alloc(0);
217    hash_internal::UniqueGenerator&lt;T&gt; gen;
218    TypeParam m(123, hasher, equal, alloc);
219    for (size_t i = 0; i != 10; ++i) m.insert(gen());
220    TypeParam n(m, A(11));
221    EXPECT_EQ(m.hash_function(), n.hash_function());
222    EXPECT_EQ(m.key_eq(), n.key_eq());
223    EXPECT_NE(m.get_allocator(), n.get_allocator());
224    EXPECT_EQ(m, n);
225  }
226  TYPED_TEST_P(ConstructorTest, CopyConstructorAlloc) {
227    CopyConstructorAllocTest&lt;TypeParam&gt;(expect_alloc_constructors&lt;TypeParam&gt;());
228  }
229  TYPED_TEST_P(ConstructorTest, MoveConstructor) {
230    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
231    using H = typename TypeParam::hasher;
232    using E = typename TypeParam::key_equal;
233    using A = typename TypeParam::allocator_type;
234    H hasher;
235    E equal;
236    A alloc(0);
237    hash_internal::UniqueGenerator&lt;T&gt; gen;
238    TypeParam m(123, hasher, equal, alloc);
239    for (size_t i = 0; i != 10; ++i) m.insert(gen());
240    TypeParam t(m);
241    TypeParam n(std::move(t));
242    EXPECT_EQ(m.hash_function(), n.hash_function());
243    EXPECT_EQ(m.key_eq(), n.key_eq());
244    EXPECT_EQ(m.get_allocator(), n.get_allocator());
245    EXPECT_EQ(m, n);
246  }
247  template &lt;typename TypeParam&gt;
248  void MoveConstructorAllocTest(std::false_type) {}
249  template &lt;typename TypeParam&gt;
250  void MoveConstructorAllocTest(std::true_type) {
251    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
252    using H = typename TypeParam::hasher;
253    using E = typename TypeParam::key_equal;
254    using A = typename TypeParam::allocator_type;
255    H hasher;
256    E equal;
257    A alloc(0);
258    hash_internal::UniqueGenerator&lt;T&gt; gen;
259    TypeParam m(123, hasher, equal, alloc);
260    for (size_t i = 0; i != 10; ++i) m.insert(gen());
261    TypeParam t(m);
262    TypeParam n(std::move(t), A(1));
263    EXPECT_EQ(m.hash_function(), n.hash_function());
264    EXPECT_EQ(m.key_eq(), n.key_eq());
265    EXPECT_NE(m.get_allocator(), n.get_allocator());
266    EXPECT_EQ(m, n);
267  }
268  TYPED_TEST_P(ConstructorTest, MoveConstructorAlloc) {
269    MoveConstructorAllocTest&lt;TypeParam&gt;(expect_alloc_constructors&lt;TypeParam&gt;());
270  }
271  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashEqualAlloc) {
272    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
273    hash_internal::UniqueGenerator&lt;T&gt; gen;
274    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
275    using H = typename TypeParam::hasher;
276    using E = typename TypeParam::key_equal;
277    using A = typename TypeParam::allocator_type;
278    H hasher;
279    E equal;
280    A alloc(0);
281    TypeParam m(values, 123, hasher, equal, alloc);
282    EXPECT_EQ(m.hash_function(), hasher);
283    EXPECT_EQ(m.key_eq(), equal);
284    EXPECT_EQ(m.get_allocator(), alloc);
285    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
286    EXPECT_GE(m.bucket_count(), 123);
287  }
288  template &lt;typename TypeParam&gt;
289  void InitializerListBucketAllocTest(std::false_type) {}
290  template &lt;typename TypeParam&gt;
291  void InitializerListBucketAllocTest(std::true_type) {
292    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
293    using A = typename TypeParam::allocator_type;
294    hash_internal::UniqueGenerator&lt;T&gt; gen;
295    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
296    A alloc(0);
297    TypeParam m(values, 123, alloc);
298    EXPECT_EQ(m.get_allocator(), alloc);
299    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
300    EXPECT_GE(m.bucket_count(), 123);
301  }
302  TYPED_TEST_P(ConstructorTest, InitializerListBucketAlloc) {
303    InitializerListBucketAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
304  }
305  template &lt;typename TypeParam&gt;
306  void InitializerListBucketHashAllocTest(std::false_type) {}
307  template &lt;typename TypeParam&gt;
308  void InitializerListBucketHashAllocTest(std::true_type) {
309    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
310    using H = typename TypeParam::hasher;
311    using A = typename TypeParam::allocator_type;
312    H hasher;
313    A alloc(0);
314    hash_internal::UniqueGenerator&lt;T&gt; gen;
315    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
316    TypeParam m(values, 123, hasher, alloc);
317    EXPECT_EQ(m.hash_function(), hasher);
318    EXPECT_EQ(m.get_allocator(), alloc);
319    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
320    EXPECT_GE(m.bucket_count(), 123);
321  }
322  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashAlloc) {
323    InitializerListBucketHashAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
324  }
325  TYPED_TEST_P(ConstructorTest, Assignment) {
326    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
327    using H = typename TypeParam::hasher;
328    using E = typename TypeParam::key_equal;
329    using A = typename TypeParam::allocator_type;
330    H hasher;
331    E equal;
332    A alloc(0);
333    hash_internal::UniqueGenerator&lt;T&gt; gen;
334    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
335    TypeParam n;
336    n = m;
337    EXPECT_EQ(m.hash_function(), n.hash_function());
338    EXPECT_EQ(m.key_eq(), n.key_eq());
339    EXPECT_EQ(m, n);
340  }
341  TYPED_TEST_P(ConstructorTest, MoveAssignment) {
342    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
343    using H = typename TypeParam::hasher;
344    using E = typename TypeParam::key_equal;
345    using A = typename TypeParam::allocator_type;
346    H hasher;
347    E equal;
348    A alloc(0);
349    hash_internal::UniqueGenerator&lt;T&gt; gen;
350    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
351    TypeParam t(m);
352    TypeParam n;
353    n = std::move(t);
354    EXPECT_EQ(m.hash_function(), n.hash_function());
355    EXPECT_EQ(m.key_eq(), n.key_eq());
356    EXPECT_EQ(m, n);
357  }
358  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerList) {
359    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
360    hash_internal::UniqueGenerator&lt;T&gt; gen;
361    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
362    TypeParam m;
363    m = values;
364    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
365  }
366  TYPED_TEST_P(ConstructorTest, AssignmentOverwritesExisting) {
367    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
368    hash_internal::UniqueGenerator&lt;T&gt; gen;
369    TypeParam m({gen(), gen(), gen()});
370    TypeParam n({gen()});
371    n = m;
372    EXPECT_EQ(m, n);
373  }
374  TYPED_TEST_P(ConstructorTest, MoveAssignmentOverwritesExisting) {
375    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
376    hash_internal::UniqueGenerator&lt;T&gt; gen;
377    TypeParam m({gen(), gen(), gen()});
378    TypeParam t(m);
379    TypeParam n({gen()});
380    n = std::move(t);
381    EXPECT_EQ(m, n);
382  }
383  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerListOverwritesExisting) {
384    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
385    hash_internal::UniqueGenerator&lt;T&gt; gen;
386    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
387    TypeParam m;
388    m = values;
389    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
390  }
391  TYPED_TEST_P(ConstructorTest, AssignmentOnSelf) {
392    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
393    hash_internal::UniqueGenerator&lt;T&gt; gen;
394    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
395    TypeParam m(values);
396    m = *&amp;m;  
397    EXPECT_THAT(items(m), ::testing::UnorderedElementsAreArray(values));
398  }
399  REGISTER_TYPED_TEST_SUITE_P(
400      ConstructorTest, NoArgs, BucketCount, BucketCountHash, BucketCountHashEqual,
401      BucketCountHashEqualAlloc, BucketCountAlloc, BucketCountHashAlloc, Alloc,
402      InputIteratorBucketHashEqualAlloc, InputIteratorBucketAlloc,
403      InputIteratorBucketHashAlloc, CopyConstructor, CopyConstructorAlloc,
404      MoveConstructor, MoveConstructorAlloc, InitializerListBucketHashEqualAlloc,
405      InitializerListBucketAlloc, InitializerListBucketHashAlloc, Assignment,
406      MoveAssignment, AssignmentFromInitializerList, AssignmentOverwritesExisting,
407      MoveAssignmentOverwritesExisting,
408      AssignmentFromInitializerListOverwritesExisting, AssignmentOnSelf);
409  }  
410  ABSL_NAMESPACE_END
411  }  
412  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-unordered_set_constructor_test.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_UNORDERED_SET_CONSTRUCTOR_TEST_H_
2  #define ABSL_CONTAINER_INTERNAL_UNORDERED_SET_CONSTRUCTOR_TEST_H_
3  #include &lt;algorithm&gt;
4  #include &lt;unordered_set&gt;
5  #include &lt;vector&gt;
6  #include &quot;gmock/gmock.h&quot;
7  #include &quot;gtest/gtest.h&quot;
8  #include &quot;absl/container/internal/hash_generator_testing.h&quot;
9  #include &quot;absl/container/internal/hash_policy_testing.h&quot;
10  #include &quot;absl/meta/type_traits.h&quot;
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace container_internal {
14  template &lt;class UnordMap&gt;
15  class ConstructorTest : public ::testing::Test {};
16  TYPED_TEST_SUITE_P(ConstructorTest);
17  TYPED_TEST_P(ConstructorTest, NoArgs) {
18    TypeParam m;
19    EXPECT_TRUE(m.empty());
20    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
21  }
22  TYPED_TEST_P(ConstructorTest, BucketCount) {
23    TypeParam m(123);
24    EXPECT_TRUE(m.empty());
25    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
26    EXPECT_GE(m.bucket_count(), 123);
27  }
28  TYPED_TEST_P(ConstructorTest, BucketCountHash) {
29    using H = typename TypeParam::hasher;
30    H hasher;
31    TypeParam m(123, hasher);
32    EXPECT_EQ(m.hash_function(), hasher);
33    EXPECT_TRUE(m.empty());
34    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
35    EXPECT_GE(m.bucket_count(), 123);
36  }
37  TYPED_TEST_P(ConstructorTest, BucketCountHashEqual) {
38    using H = typename TypeParam::hasher;
39    using E = typename TypeParam::key_equal;
40    H hasher;
41    E equal;
42    TypeParam m(123, hasher, equal);
43    EXPECT_EQ(m.hash_function(), hasher);
44    EXPECT_EQ(m.key_eq(), equal);
45    EXPECT_TRUE(m.empty());
46    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
47    EXPECT_GE(m.bucket_count(), 123);
48  }
49  TYPED_TEST_P(ConstructorTest, BucketCountHashEqualAlloc) {
50    using H = typename TypeParam::hasher;
51    using E = typename TypeParam::key_equal;
52    using A = typename TypeParam::allocator_type;
53    H hasher;
54    E equal;
55    A alloc(0);
56    TypeParam m(123, hasher, equal, alloc);
57    EXPECT_EQ(m.hash_function(), hasher);
58    EXPECT_EQ(m.key_eq(), equal);
59    EXPECT_EQ(m.get_allocator(), alloc);
60    EXPECT_TRUE(m.empty());
61    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
62    EXPECT_GE(m.bucket_count(), 123);
63    const auto&amp; cm = m;
64    EXPECT_EQ(cm.hash_function(), hasher);
65    EXPECT_EQ(cm.key_eq(), equal);
66    EXPECT_EQ(cm.get_allocator(), alloc);
67    EXPECT_TRUE(cm.empty());
68    EXPECT_THAT(keys(cm), ::testing::UnorderedElementsAre());
69    EXPECT_GE(cm.bucket_count(), 123);
70  }
71  template &lt;typename T&gt;
72  struct is_std_unordered_set : std::false_type {};
73  template &lt;typename... T&gt;
74  struct is_std_unordered_set&lt;std::unordered_set&lt;T...&gt;&gt; : std::true_type {};
75  #if defined(UNORDERED_SET_CXX14) || defined(UNORDERED_SET_CXX17)
76  using has_cxx14_std_apis = std::true_type;
77  #else
78  using has_cxx14_std_apis = std::false_type;
79  #endif
80  template &lt;typename T&gt;
81  using expect_cxx14_apis =
82      absl::disjunction&lt;absl::negation&lt;is_std_unordered_set&lt;T&gt;&gt;,
83                        has_cxx14_std_apis&gt;;
84  template &lt;typename TypeParam&gt;
85  void BucketCountAllocTest(std::false_type) {}
86  template &lt;typename TypeParam&gt;
87  void BucketCountAllocTest(std::true_type) {
88    using A = typename TypeParam::allocator_type;
89    A alloc(0);
90    TypeParam m(123, alloc);
91    EXPECT_EQ(m.get_allocator(), alloc);
92    EXPECT_TRUE(m.empty());
93    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
94    EXPECT_GE(m.bucket_count(), 123);
95  }
96  TYPED_TEST_P(ConstructorTest, BucketCountAlloc) {
97    BucketCountAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
98  }
99  template &lt;typename TypeParam&gt;
<span onclick='openModal()' class='match'>100  void BucketCountHashAllocTest(std::false_type) {}
101  template &lt;typename TypeParam&gt;
102  void BucketCountHashAllocTest(std::true_type) {
103    using H = typename TypeParam::hasher;
</span>104    using A = typename TypeParam::allocator_type;
105    H hasher;
106    A alloc(0);
107    TypeParam m(123, hasher, alloc);
108    EXPECT_EQ(m.hash_function(), hasher);
109    EXPECT_EQ(m.get_allocator(), alloc);
110    EXPECT_TRUE(m.empty());
111    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
112    EXPECT_GE(m.bucket_count(), 123);
113  }
114  TYPED_TEST_P(ConstructorTest, BucketCountHashAlloc) {
115    BucketCountHashAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
116  }
117  #if ABSL_UNORDERED_SUPPORTS_ALLOC_CTORS
118  using has_alloc_std_constructors = std::true_type;
119  #else
120  using has_alloc_std_constructors = std::false_type;
121  #endif
122  template &lt;typename T&gt;
123  using expect_alloc_constructors =
124      absl::disjunction&lt;absl::negation&lt;is_std_unordered_set&lt;T&gt;&gt;,
125                        has_alloc_std_constructors&gt;;
126  template &lt;typename TypeParam&gt;
127  void AllocTest(std::false_type) {}
128  template &lt;typename TypeParam&gt;
129  void AllocTest(std::true_type) {
130    using A = typename TypeParam::allocator_type;
131    A alloc(0);
132    TypeParam m(alloc);
133    EXPECT_EQ(m.get_allocator(), alloc);
134    EXPECT_TRUE(m.empty());
135    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
136  }
137  TYPED_TEST_P(ConstructorTest, Alloc) {
138    AllocTest&lt;TypeParam&gt;(expect_alloc_constructors&lt;TypeParam&gt;());
139  }
140  TYPED_TEST_P(ConstructorTest, InputIteratorBucketHashEqualAlloc) {
141    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
142    using H = typename TypeParam::hasher;
143    using E = typename TypeParam::key_equal;
144    using A = typename TypeParam::allocator_type;
145    H hasher;
146    E equal;
147    A alloc(0);
148    std::vector&lt;T&gt; values;
149    for (size_t i = 0; i != 10; ++i)
150      values.push_back(hash_internal::Generator&lt;T&gt;()());
151    TypeParam m(values.begin(), values.end(), 123, hasher, equal, alloc);
152    EXPECT_EQ(m.hash_function(), hasher);
153    EXPECT_EQ(m.key_eq(), equal);
154    EXPECT_EQ(m.get_allocator(), alloc);
155    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
156    EXPECT_GE(m.bucket_count(), 123);
157  }
158  template &lt;typename TypeParam&gt;
159  void InputIteratorBucketAllocTest(std::false_type) {}
160  template &lt;typename TypeParam&gt;
161  void InputIteratorBucketAllocTest(std::true_type) {
162    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
163    using A = typename TypeParam::allocator_type;
164    A alloc(0);
165    std::vector&lt;T&gt; values;
166    for (size_t i = 0; i != 10; ++i)
167      values.push_back(hash_internal::Generator&lt;T&gt;()());
168    TypeParam m(values.begin(), values.end(), 123, alloc);
169    EXPECT_EQ(m.get_allocator(), alloc);
170    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
171    EXPECT_GE(m.bucket_count(), 123);
172  }
173  TYPED_TEST_P(ConstructorTest, InputIteratorBucketAlloc) {
174    InputIteratorBucketAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
175  }
176  template &lt;typename TypeParam&gt;
177  void InputIteratorBucketHashAllocTest(std::false_type) {}
178  template &lt;typename TypeParam&gt;
179  void InputIteratorBucketHashAllocTest(std::true_type) {
180    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
181    using H = typename TypeParam::hasher;
182    using A = typename TypeParam::allocator_type;
183    H hasher;
184    A alloc(0);
185    std::vector&lt;T&gt; values;
186    for (size_t i = 0; i != 10; ++i)
187      values.push_back(hash_internal::Generator&lt;T&gt;()());
188    TypeParam m(values.begin(), values.end(), 123, hasher, alloc);
189    EXPECT_EQ(m.hash_function(), hasher);
190    EXPECT_EQ(m.get_allocator(), alloc);
191    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
192    EXPECT_GE(m.bucket_count(), 123);
193  }
194  TYPED_TEST_P(ConstructorTest, InputIteratorBucketHashAlloc) {
195    InputIteratorBucketHashAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
196  }
197  TYPED_TEST_P(ConstructorTest, CopyConstructor) {
198    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
199    using H = typename TypeParam::hasher;
200    using E = typename TypeParam::key_equal;
201    using A = typename TypeParam::allocator_type;
202    H hasher;
203    E equal;
204    A alloc(0);
205    TypeParam m(123, hasher, equal, alloc);
206    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator&lt;T&gt;()());
207    TypeParam n(m);
208    EXPECT_EQ(m.hash_function(), n.hash_function());
209    EXPECT_EQ(m.key_eq(), n.key_eq());
210    EXPECT_EQ(m.get_allocator(), n.get_allocator());
211    EXPECT_EQ(m, n);
212    EXPECT_NE(TypeParam(0, hasher, equal, alloc), n);
213  }
214  template &lt;typename TypeParam&gt;
215  void CopyConstructorAllocTest(std::false_type) {}
216  template &lt;typename TypeParam&gt;
217  void CopyConstructorAllocTest(std::true_type) {
218    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
219    using H = typename TypeParam::hasher;
220    using E = typename TypeParam::key_equal;
221    using A = typename TypeParam::allocator_type;
222    H hasher;
223    E equal;
224    A alloc(0);
225    TypeParam m(123, hasher, equal, alloc);
226    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator&lt;T&gt;()());
227    TypeParam n(m, A(11));
228    EXPECT_EQ(m.hash_function(), n.hash_function());
229    EXPECT_EQ(m.key_eq(), n.key_eq());
230    EXPECT_NE(m.get_allocator(), n.get_allocator());
231    EXPECT_EQ(m, n);
232  }
233  TYPED_TEST_P(ConstructorTest, CopyConstructorAlloc) {
234    CopyConstructorAllocTest&lt;TypeParam&gt;(expect_alloc_constructors&lt;TypeParam&gt;());
235  }
236  TYPED_TEST_P(ConstructorTest, MoveConstructor) {
237    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
238    using H = typename TypeParam::hasher;
239    using E = typename TypeParam::key_equal;
240    using A = typename TypeParam::allocator_type;
241    H hasher;
242    E equal;
243    A alloc(0);
244    TypeParam m(123, hasher, equal, alloc);
245    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator&lt;T&gt;()());
246    TypeParam t(m);
247    TypeParam n(std::move(t));
248    EXPECT_EQ(m.hash_function(), n.hash_function());
249    EXPECT_EQ(m.key_eq(), n.key_eq());
250    EXPECT_EQ(m.get_allocator(), n.get_allocator());
251    EXPECT_EQ(m, n);
252  }
253  template &lt;typename TypeParam&gt;
254  void MoveConstructorAllocTest(std::false_type) {}
255  template &lt;typename TypeParam&gt;
256  void MoveConstructorAllocTest(std::true_type) {
257    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
258    using H = typename TypeParam::hasher;
259    using E = typename TypeParam::key_equal;
260    using A = typename TypeParam::allocator_type;
261    H hasher;
262    E equal;
263    A alloc(0);
264    TypeParam m(123, hasher, equal, alloc);
265    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator&lt;T&gt;()());
266    TypeParam t(m);
267    TypeParam n(std::move(t), A(1));
268    EXPECT_EQ(m.hash_function(), n.hash_function());
269    EXPECT_EQ(m.key_eq(), n.key_eq());
270    EXPECT_NE(m.get_allocator(), n.get_allocator());
271    EXPECT_EQ(m, n);
272  }
273  TYPED_TEST_P(ConstructorTest, MoveConstructorAlloc) {
274    MoveConstructorAllocTest&lt;TypeParam&gt;(expect_alloc_constructors&lt;TypeParam&gt;());
275  }
276  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashEqualAlloc) {
277    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
278    hash_internal::Generator&lt;T&gt; gen;
279    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
280    using H = typename TypeParam::hasher;
281    using E = typename TypeParam::key_equal;
282    using A = typename TypeParam::allocator_type;
283    H hasher;
284    E equal;
285    A alloc(0);
286    TypeParam m(values, 123, hasher, equal, alloc);
287    EXPECT_EQ(m.hash_function(), hasher);
288    EXPECT_EQ(m.key_eq(), equal);
289    EXPECT_EQ(m.get_allocator(), alloc);
290    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
291    EXPECT_GE(m.bucket_count(), 123);
292  }
293  template &lt;typename TypeParam&gt;
294  void InitializerListBucketAllocTest(std::false_type) {}
295  template &lt;typename TypeParam&gt;
296  void InitializerListBucketAllocTest(std::true_type) {
297    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
298    using A = typename TypeParam::allocator_type;
299    hash_internal::Generator&lt;T&gt; gen;
300    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
301    A alloc(0);
302    TypeParam m(values, 123, alloc);
303    EXPECT_EQ(m.get_allocator(), alloc);
304    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
305    EXPECT_GE(m.bucket_count(), 123);
306  }
307  TYPED_TEST_P(ConstructorTest, InitializerListBucketAlloc) {
308    InitializerListBucketAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
309  }
310  template &lt;typename TypeParam&gt;
311  void InitializerListBucketHashAllocTest(std::false_type) {}
312  template &lt;typename TypeParam&gt;
313  void InitializerListBucketHashAllocTest(std::true_type) {
314    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
315    using H = typename TypeParam::hasher;
316    using A = typename TypeParam::allocator_type;
317    H hasher;
318    A alloc(0);
319    hash_internal::Generator&lt;T&gt; gen;
320    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
321    TypeParam m(values, 123, hasher, alloc);
322    EXPECT_EQ(m.hash_function(), hasher);
323    EXPECT_EQ(m.get_allocator(), alloc);
324    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
325    EXPECT_GE(m.bucket_count(), 123);
326  }
327  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashAlloc) {
328    InitializerListBucketHashAllocTest&lt;TypeParam&gt;(expect_cxx14_apis&lt;TypeParam&gt;());
329  }
330  TYPED_TEST_P(ConstructorTest, CopyAssignment) {
331    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
332    using H = typename TypeParam::hasher;
333    using E = typename TypeParam::key_equal;
334    using A = typename TypeParam::allocator_type;
335    H hasher;
336    E equal;
337    A alloc(0);
338    hash_internal::Generator&lt;T&gt; gen;
339    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
340    TypeParam n;
341    n = m;
342    EXPECT_EQ(m.hash_function(), n.hash_function());
343    EXPECT_EQ(m.key_eq(), n.key_eq());
344    EXPECT_EQ(m, n);
345  }
346  TYPED_TEST_P(ConstructorTest, MoveAssignment) {
347    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
348    using H = typename TypeParam::hasher;
349    using E = typename TypeParam::key_equal;
350    using A = typename TypeParam::allocator_type;
351    H hasher;
352    E equal;
353    A alloc(0);
354    hash_internal::Generator&lt;T&gt; gen;
355    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
356    TypeParam t(m);
357    TypeParam n;
358    n = std::move(t);
359    EXPECT_EQ(m.hash_function(), n.hash_function());
360    EXPECT_EQ(m.key_eq(), n.key_eq());
361    EXPECT_EQ(m, n);
362  }
363  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerList) {
364    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
365    hash_internal::Generator&lt;T&gt; gen;
366    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
367    TypeParam m;
368    m = values;
369    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
370  }
371  TYPED_TEST_P(ConstructorTest, AssignmentOverwritesExisting) {
372    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
373    hash_internal::Generator&lt;T&gt; gen;
374    TypeParam m({gen(), gen(), gen()});
375    TypeParam n({gen()});
376    n = m;
377    EXPECT_EQ(m, n);
378  }
379  TYPED_TEST_P(ConstructorTest, MoveAssignmentOverwritesExisting) {
380    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
381    hash_internal::Generator&lt;T&gt; gen;
382    TypeParam m({gen(), gen(), gen()});
383    TypeParam t(m);
384    TypeParam n({gen()});
385    n = std::move(t);
386    EXPECT_EQ(m, n);
387  }
388  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerListOverwritesExisting) {
389    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
390    hash_internal::Generator&lt;T&gt; gen;
391    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
392    TypeParam m;
393    m = values;
394    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
395  }
396  TYPED_TEST_P(ConstructorTest, AssignmentOnSelf) {
397    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
398    hash_internal::Generator&lt;T&gt; gen;
399    std::initializer_list&lt;T&gt; values = {gen(), gen(), gen(), gen(), gen()};
400    TypeParam m(values);
401    m = *&amp;m;  
402    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
403  }
404  REGISTER_TYPED_TEST_SUITE_P(
405      ConstructorTest, NoArgs, BucketCount, BucketCountHash, BucketCountHashEqual,
406      BucketCountHashEqualAlloc, BucketCountAlloc, BucketCountHashAlloc, Alloc,
407      InputIteratorBucketHashEqualAlloc, InputIteratorBucketAlloc,
408      InputIteratorBucketHashAlloc, CopyConstructor, CopyConstructorAlloc,
409      MoveConstructor, MoveConstructorAlloc, InitializerListBucketHashEqualAlloc,
410      InitializerListBucketAlloc, InitializerListBucketHashAlloc, CopyAssignment,
411      MoveAssignment, AssignmentFromInitializerList, AssignmentOverwritesExisting,
412      MoveAssignmentOverwritesExisting,
413      AssignmentFromInitializerListOverwritesExisting, AssignmentOnSelf);
414  }  
415  ABSL_NAMESPACE_END
416  }  
417  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-unordered_map_constructor_test.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-unordered_set_constructor_test.h</div>
                </div>
                <div class="column column_space"><pre><code>207  void CopyConstructorAllocTest(std::false_type) {}
208  template &lt;typename TypeParam&gt;
209  void CopyConstructorAllocTest(std::true_type) {
210    using T = hash_internal::GeneratedType&lt;TypeParam&gt;;
</pre></code></div>
                <div class="column column_space"><pre><code>100  void BucketCountHashAllocTest(std::false_type) {}
101  template &lt;typename TypeParam&gt;
102  void BucketCountHashAllocTest(std::true_type) {
103    using H = typename TypeParam::hasher;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    