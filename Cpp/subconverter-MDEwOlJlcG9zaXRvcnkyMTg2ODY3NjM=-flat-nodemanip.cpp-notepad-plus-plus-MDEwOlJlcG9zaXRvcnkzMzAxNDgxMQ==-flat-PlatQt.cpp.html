
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-nodemanip.cpp</h3>
            <pre><code>1  #include <string>
2  #include <vector>
3  #include <iostream>
4  #include <algorithm>
5  #include "../../handler/settings.h"
6  #include "../../handler/webget.h"
7  #include "../../parser/config/proxy.h"
8  #include "../../parser/infoparser.h"
9  #include "../../parser/subparser.h"
10  #include "../../script/script_quickjs.h"
11  #include "../../utils/file_extra.h"
12  #include "../../utils/logger.h"
13  #include "../../utils/map_extra.h"
14  #include "../../utils/network.h"
15  #include "../../utils/regexp.h"
16  #include "../../utils/urlencode.h"
17  #include "nodemanip.h"
18  #include "subexport.h"
19  extern Settings global;
20  bool applyMatcher(const std::string &rule, std::string &real_rule, const Proxy &node);
21  int explodeConf(const std::string &filepath, std::vector<Proxy> &nodes)
22  {
23      return explodeConfContent(fileGet(filepath), nodes);
24  }
25  void copyNodes(std::vector<Proxy> &source, std::vector<Proxy> &dest)
26  {
27      std::move(source.begin(), source.end(), std::back_inserter(dest));
28  }
29  int addNodes(std::string link, std::vector<Proxy> &allNodes, int groupID, parse_settings &parse_set)
30  {
31      std::string &proxy = *parse_set.proxy, &subInfo = *parse_set.sub_info;
32      string_array &exclude_remarks = *parse_set.exclude_remarks;
33      string_array &include_remarks = *parse_set.include_remarks;
34      RegexMatchConfigs &stream_rules = *parse_set.stream_rules;
35      RegexMatchConfigs &time_rules = *parse_set.time_rules;
36      string_icase_map *request_headers = parse_set.request_header;
37      bool &authorized = parse_set.authorized;
<span onclick='openModal()' class='match'>38      ConfType linkType = ConfType::Unknow;
39      std::vector<Proxy> nodes;
40      Proxy node;
</span>41      std::string strSub, extra_headers, custom_group;
42      link = replaceAllDistinct(link, "\"", "");
43      if(authorized) script_safe_runner(parse_set.js_runtime, parse_set.js_context, [&](qjs::Context &ctx)
44      {
45          if(startsWith(link, "script:")) 
46          {
47              writeLog(0, "Found script link. Start running...", LOG_LEVEL_INFO);
48              string_array args = split(link.substr(7), ",");
49              if(args.size() >= 1)
50              {
51                  std::string script = fileGet(args[0], false);
52                  try
53                  {
54                      ctx.eval(script);
55                      args.erase(args.begin()); 
56                      auto parse = (std::function<std::string(const std::string&, const string_array&)>) ctx.eval("parse");
57                      switch(args.size())
58                      {
59                      case 0:
60                          link = parse(std::string(), string_array());
61                          break;
62                      case 1:
63                          link = parse(args[0], string_array());
64                          break;
65                      default:
66                          {
67                              std::string first = args[0];
68                              args.erase(args.begin());
69                              link = parse(first, args);
70                              break;
71                          }
72                      }
73                  }
74                  catch(qjs::exception)
75                  {
76                      script_print_stack(ctx);
77                  }
78              }
79          }
80      }, global.scriptCleanContext);
81      if(startsWith(link, "tag:"))
82      {
83          string_size pos = link.find(",");
84          if(pos != link.npos)
85          {
86              custom_group = link.substr(4, pos - 4);
87              link.erase(0, pos + 1);
88          }
89      }
90      if(link == "nullnode")
91      {
92          node.GroupId = 0;
93          writeLog(0, "Adding node placeholder...");
94          allNodes.emplace_back(std::move(node));
95          return 0;
96      }
97      writeLog(LOG_TYPE_INFO, "Received Link.");
98      if(startsWith(link, "https:&bsol;&bsol;t.me/socks") || startsWith(link, "tg:&bsol;&bsol;socks"))
99          linkType = ConfType::SOCKS;
100      else if(startsWith(link, "https:&bsol;&bsol;t.me/http") || startsWith(link, "tg:&bsol;&bsol;http"))
101          linkType = ConfType::HTTP;
102      else if(isLink(link) || startsWith(link, "surge:&bsol;&bsol;/install-config"))
103          linkType = ConfType::SUB;
104      else if(startsWith(link, "Netch:&bsol;&bsol;"))
105          linkType = ConfType::Netch;
106      else if(fileExist(link))
107          linkType = ConfType::Local;
108      switch(linkType)
109      {
110      case ConfType::SUB:
111          writeLog(LOG_TYPE_INFO, "Downloading subscription data...");
112          if(startsWith(link, "surge:&bsol;&bsol;/install-config")) &bsol;&bsol;surge config link
113              link = urlDecode(getUrlArg(link, "url"));
114          strSub = webGet(link, proxy, global.cacheSubscription, &extra_headers, request_headers);
115          if(strSub.size())
116          {
117              writeLog(LOG_TYPE_INFO, "Parsing subscription data...");
118              if(explodeConfContent(strSub, nodes) == 0)
119              {
120                  writeLog(LOG_TYPE_ERROR, "Invalid subscription: '" + link + "'!");
121                  return -1;
122              }
123              if(startsWith(strSub, "ssd:&bsol;&bsol;"))
124              {
125                  getSubInfoFromSSD(strSub, subInfo);
126              }
127              else
128              {
129                  if(!getSubInfoFromHeader(extra_headers, subInfo))
130                      getSubInfoFromNodes(nodes, stream_rules, time_rules, subInfo);
131              }
132              filterNodes(nodes, exclude_remarks, include_remarks, groupID);
133              for(Proxy &x : nodes)
134              {
135                  x.GroupId = groupID;
136                  if(custom_group.size())
137                      x.Group = custom_group;
138              }
139              copyNodes(nodes, allNodes);
140          }
141          else
142          {
143              writeLog(LOG_TYPE_ERROR, "Cannot download subscription data.");
144              return -1;
145          }
146          break;
147      case ConfType::Local:
148          if(!authorized)
149              return -1;
150          writeLog(LOG_TYPE_INFO, "Parsing configuration file data...");
151          if(explodeConf(link, nodes) == 0)
152          {
153              writeLog(LOG_TYPE_ERROR, "Invalid configuration file!");
154              return -1;
155          }
156          if(startsWith(strSub, "ssd:&bsol;&bsol;"))
157          {
158              getSubInfoFromSSD(strSub, subInfo);
159          }
160          else
161          {
162              getSubInfoFromNodes(nodes, stream_rules, time_rules, subInfo);
163          }
164          filterNodes(nodes, exclude_remarks, include_remarks, groupID);
165          for(Proxy &x : nodes)
166          {
167              x.GroupId = groupID;
168              if(custom_group.size())
169                  x.Group = custom_group;
170          }
171          copyNodes(nodes, allNodes);
172          break;
173      default:
174          explode(link, node);
175          if(node.Type == -1)
176          {
177              writeLog(LOG_TYPE_ERROR, "No valid link found.");
178              return -1;
179          }
180          node.GroupId = groupID;
181          if(custom_group.size())
182              node.Group = custom_group;
183          allNodes.emplace_back(std::move(node));
184      }
185      return 0;
186  }
187  bool chkIgnore(const Proxy &node, string_array &exclude_remarks, string_array &include_remarks)
188  {
189      bool excluded = false, included = false;
190      excluded = std::any_of(exclude_remarks.cbegin(), exclude_remarks.cend(), [&node](const auto &x)
191      {
192          std::string real_rule;
193          if(applyMatcher(x, real_rule, node))
194          {
195              if(real_rule.empty()) return true;
196              return regFind(node.Remark, real_rule);
197          }
198          else
199              return false;
200      });
201      if(include_remarks.size() != 0)
202      {
203          included = std::any_of(include_remarks.cbegin(), include_remarks.cend(), [&node](const auto &x)
204          {
205              std::string real_rule;
206              if(applyMatcher(x, real_rule, node))
207              {
208                  if(real_rule.empty()) return true;
209                  return regFind(node.Remark, real_rule);
210              }
211              else
212                  return false;
213          });
214      }
215      else
216      {
217          included = true;
218      }
219      return excluded || !included;
220  }
221  void filterNodes(std::vector<Proxy> &nodes, string_array &exclude_remarks, string_array &include_remarks, int groupID)
222  {
223      int node_index = 0;
224      std::vector<Proxy>::iterator iter = nodes.begin();
225      while(iter != nodes.end())
226      {
227          if(chkIgnore(*iter, exclude_remarks, include_remarks))
228          {
229              writeLog(LOG_TYPE_INFO, "Node  " + iter->Group + " - " + iter->Remark + "  has been ignored and will not be added.");
230              nodes.erase(iter);
231          }
232          else
233          {
234              writeLog(LOG_TYPE_INFO, "Node  " + iter->Group + " - " + iter->Remark + "  has been added.");
235              iter->Id = node_index;
236              iter->GroupId = groupID;
237              ++node_index;
238              ++iter;
239          }
240      }
241      writeLog(LOG_TYPE_INFO, "Filter done.");
242  }
243  void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)
244  {
245      std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;
246      for(const RegexMatchConfig &x : rename_array)
247      {
248          if(!x.Script.empty() && ext.authorized)
249          {
250              script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
251              {
252                  std::string script = x.Script;
253                  if(startsWith(script, "path:"))
254                      script = fileGet(script.substr(5), true);
255                  try
256                  {
257                      ctx.eval(script);
258                      auto rename = (std::function<std::string(const Proxy&)>) ctx.eval("rename");
259                      returned_remark = rename(node);
260                      if(!returned_remark.empty())
261                          remark = returned_remark;
262                  }
263                  catch (qjs::exception)
264                  {
265                      script_print_stack(ctx);
266                  }
267              }, global.scriptCleanContext);
268              continue;
269          }
270          if(applyMatcher(x.Match, real_rule, node) && real_rule.size())
271              remark = regReplace(remark, real_rule, x.Replace);
272      }
273      if(remark.empty())
274          remark = original_remark;
275      return;
276  }
277  std::string removeEmoji(const std::string &orig_remark)
278  {
279      char emoji_id[2] = {(char)-16, (char)-97};
280      std::string remark = orig_remark;
281      while(true)
282      {
283          if(remark[0] == emoji_id[0] && remark[1] == emoji_id[1])
284              remark.erase(0, 4);
285          else
286              break;
287      }
288      if(remark.empty())
289          return orig_remark;
290      return remark;
291  }
292  std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)
293  {
294      std::string real_rule, ret;
295      for(const RegexMatchConfig &x : emoji_array)
296      {
297          if(!x.Script.empty() && ext.authorized)
298          {
299              std::string result;
300              script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
301              {
302                  std::string script = x.Script;
303                  if(startsWith(script, "path:"))
304                      script = fileGet(script.substr(5), true);
305                  try
306                  {
307                      ctx.eval(script);
308                      auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval("getEmoji");
309                      ret = getEmoji(node);
310                      if(!ret.empty())
311                          result = ret + " " + node.Remark;
312                  }
313                  catch (qjs::exception)
314                  {
315                      script_print_stack(ctx);
316                  }
317              }, global.scriptCleanContext);
318              if(!result.empty())
319                  return result;
320              continue;
321          }
322          if(x.Replace.empty())
323              continue;
324          if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))
325              return x.Replace + " " + node.Remark;
326      }
327      return node.Remark;
328  }
329  void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)
330  {
331      std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)
332      {
333          if(ext.remove_emoji)
334              x.Remark = trim(removeEmoji(x.Remark));
335          nodeRename(x, ext.rename_array, ext);
336          if(ext.add_emoji)
337              x.Remark = addEmoji(x, ext.emoji_array, ext);
338      });
339      if(ext.sort_flag)
340      {
341          bool failed = true;
342          if(ext.sort_script.size() && ext.authorized)
343          {
344              std::string script = ext.sort_script;
345              if(startsWith(script, "path:"))
346                  script = fileGet(script.substr(5), false);
347              script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
348              {
349                  try
350                  {
351                      ctx.eval(script);
352                      auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval("compare");
353                      auto comparer = [&](const Proxy &a, const Proxy &b)
354                      {
355                          if(a.Type == ProxyType::Unknow)
356                              return 1;
357                          if(b.Type == ProxyType::Unknow)
358                              return 0;
359                          return compare(a, b);
360                      };
361                      std::stable_sort(nodes.begin(), nodes.end(), comparer);
362                      failed = false;
363                  }
364                  catch(qjs::exception)
365                  {
366                      script_print_stack(ctx);
367                  }
368              }, global.scriptCleanContext);
369          }
370          if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)
371          {
372              return a.Remark < b.Remark;
373          });
374      }
375  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatQt.cpp</h3>
            <pre><code>1  #include <cstdio>
2  #include "PlatQt.h"
3  #include "Scintilla.h"
4  #include "XPM.h"
5  #include "UniConversion.h"
6  #include "DBCS.h"
7  #include <QApplication>
8  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
9  #include <QScreen>
10  #endif
11  #include <QFont>
12  #include <QColor>
13  #include <QRect>
14  #include <QPaintDevice>
15  #include <QPaintEngine>
16  #include <QWidget>
17  #include <QPixmap>
18  #include <QPainter>
19  #include <QPainterPath>
20  #include <QMenu>
21  #include <QAction>
22  #include <QTime>
23  #include <QMessageBox>
24  #include <QTextCodec>
25  #include <QListWidget>
26  #include <QVarLengthArray>
27  #include <QScrollBar>
28  #include <QTextLayout>
29  #include <QTextLine>
30  #include <QLibrary>
31  using namespace Scintilla;
32  namespace Scintilla::Internal {
33  const char *CharacterSetID(CharacterSet characterSet)
34  {
35  	switch (characterSet) {
36  	case CharacterSet::Default:
37  		return "ISO 8859-1";
38  	case CharacterSet::Baltic:
39  		return "ISO 8859-13";
40  	case CharacterSet::ChineseBig5:
41  		return "Big5";
42  	case CharacterSet::EastEurope:
43  		return "ISO 8859-2";
44  	case CharacterSet::GB2312:
45  		return "GB18030-0";
46  	case CharacterSet::Greek:
47  		return "ISO 8859-7";
48  	case CharacterSet::Hangul:
49  		return "CP949";
50  	case CharacterSet::Mac:
51  		return "Apple Roman";
52  	case CharacterSet::Russian:
53  		return "KOI8-R";
54  	case CharacterSet::Cyrillic:
55  		return "Windows-1251";
56  	case CharacterSet::ShiftJis:
57  		return "Shift-JIS";
58  	case CharacterSet::Turkish:
59  		return "ISO 8859-9";
60  	case CharacterSet::Hebrew:
61  		return "ISO 8859-8";
62  	case CharacterSet::Arabic:
63  		return "ISO 8859-6";
64  	case CharacterSet::Vietnamese:
65  		return "Windows-1258";
66  	case CharacterSet::Thai:
67  		return "TIS-620";
68  	case CharacterSet::Iso8859_15:
69  		return "ISO 8859-15";
70  	default:
71  		return "ISO 8859-1";
72  	}
73  }
74  QString UnicodeFromText(QTextCodec *codec, std::string_view text) {
75  	return codec->toUnicode(text.data(), static_cast<int>(text.length()));
76  }
77  static QFont::StyleStrategy ChooseStrategy(FontQuality eff)
78  {
79  	switch (eff) {
80  		case FontQuality::QualityDefault:         return QFont::PreferDefault;
81  		case FontQuality::QualityNonAntialiased: return QFont::NoAntialias;
82  		case FontQuality::QualityAntialiased:     return QFont::PreferAntialias;
83  		case FontQuality::QualityLcdOptimized:   return QFont::PreferAntialias;
84  		default:                             return QFont::PreferDefault;
85  	}
86  }
87  class FontAndCharacterSet : public Font {
88  public:
<span onclick='openModal()' class='match'>89  	CharacterSet characterSet = CharacterSet::Ansi;
90  	std::unique_ptr<QFont> pfont;
91  	explicit FontAndCharacterSet(const FontParameters &fp) : characterSet(fp.characterSet) {
</span>92  		pfont = std::make_unique<QFont>();
93  		pfont->setStyleStrategy(ChooseStrategy(fp.extraFontFlag));
94  		pfont->setFamily(QString::fromUtf8(fp.faceName));
95  		pfont->setPointSizeF(fp.size);
96  		pfont->setBold(static_cast<int>(fp.weight) > 500);
97  		pfont->setItalic(fp.italic);
98  	}
99  };
100  namespace {
101  const Supports SupportsQt[] = {
102  	Supports::LineDrawsFinal,
103  	Supports::FractionalStrokeWidth,
104  	Supports::TranslucentStroke,
105  	Supports::PixelModification,
106  };
107  const FontAndCharacterSet *AsFontAndCharacterSet(const Font *f) {
108  	return dynamic_cast<const FontAndCharacterSet *>(f);
109  }
110  QFont *FontPointer(const Font *f)
111  {
112  	return AsFontAndCharacterSet(f)->pfont.get();
113  }
114  }
115  std::shared_ptr<Font> Font::Allocate(const FontParameters &fp)
116  {
117  	return std::make_shared<FontAndCharacterSet>(fp);
118  }
119  SurfaceImpl::SurfaceImpl() = default;
120  SurfaceImpl::SurfaceImpl(int width, int height, SurfaceMode mode_)
121  {
122  	if (width < 1) width = 1;
123  	if (height < 1) height = 1;
124  	deviceOwned = true;
125  	device = new QPixmap(width, height);
126  	mode = mode_;
127  }
128  SurfaceImpl::~SurfaceImpl()
129  {
130  	Clear();
131  }
132  void SurfaceImpl::Clear()
133  {
134  	if (painterOwned && painter) {
135  		delete painter;
136  	}
137  	if (deviceOwned && device) {
138  		delete device;
139  	}
140  	device = nullptr;
141  	painter = nullptr;
142  	deviceOwned = false;
143  	painterOwned = false;
144  }
145  void SurfaceImpl::Init(WindowID wid)
146  {
147  	Release();
148  	device = static_cast<QWidget *>(wid);
149  }
150  void SurfaceImpl::Init(SurfaceID sid, WindowID &bsol;*wid*/)
151  {
152  	Release();
153  	device = static_cast<QPaintDevice *>(sid);
154  }
155  std::unique_ptr<Surface> SurfaceImpl::AllocatePixMap(int width, int height)
156  {
157  	return std::make_unique<SurfaceImpl>(width, height, mode);
158  }
159  void SurfaceImpl::SetMode(SurfaceMode mode_)
160  {
161  	mode = mode_;
162  }
163  void SurfaceImpl::Release() noexcept
164  {
165  	Clear();
166  }
167  int SurfaceImpl::SupportsFeature(Supports feature) noexcept
168  {
169  	for (const Supports f : SupportsQt) {
170  		if (f == feature)
171  			return 1;
172  	}
173  	return 0;
174  }
175  bool SurfaceImpl::Initialised()
176  {
177  	return device != nullptr;
178  }
179  void SurfaceImpl::PenColour(ColourRGBA fore)
180  {
181  	QPen penOutline(QColorFromColourRGBA(fore));
182  	penOutline.setCapStyle(Qt::FlatCap);
183  	GetPainter()->setPen(penOutline);
184  }
185  void SurfaceImpl::PenColourWidth(ColourRGBA fore, XYPOSITION strokeWidth) {
186  	QPen penOutline(QColorFromColourRGBA(fore));
187  	penOutline.setCapStyle(Qt::FlatCap);
188  	penOutline.setJoinStyle(Qt::MiterJoin);
189  	penOutline.setWidthF(strokeWidth);
190  	GetPainter()->setPen(penOutline);
191  }
192  void SurfaceImpl::BrushColour(ColourRGBA back)
193  {
194  	GetPainter()->setBrush(QBrush(QColorFromColourRGBA(back)));
195  }
196  void SurfaceImpl::SetCodec(const Font *font)
197  {
198  	const FontAndCharacterSet *pfacs = AsFontAndCharacterSet(font);
199  	if (pfacs && pfacs->pfont) {
200  		const char *csid = "UTF-8";
201  		if (!(mode.codePage == SC_CP_UTF8))
202  			csid = CharacterSetID(pfacs->characterSet);
203  		if (csid != codecName) {
204  			codecName = csid;
205  			codec = QTextCodec::codecForName(csid);
206  		}
207  	}
208  }
209  void SurfaceImpl::SetFont(const Font *font)
210  {
211  	const FontAndCharacterSet *pfacs = AsFontAndCharacterSet(font);
212  	if (pfacs && pfacs->pfont) {
213  		GetPainter()->setFont(*(pfacs->pfont));
214  		SetCodec(font);
215  	}
216  }
217  int SurfaceImpl::LogPixelsY()
218  {
219  	return device->logicalDpiY();
220  }
221  int SurfaceImpl::PixelDivisions()
222  {
223  	return 1;
224  }
225  int SurfaceImpl::DeviceHeightFont(int points)
226  {
227  	return points;
228  }
229  void SurfaceImpl::LineDraw(Point start, Point end, Stroke stroke)
230  {
231  	PenColourWidth(stroke.colour, stroke.width);
232  	QLineF line(start.x, start.y, end.x, end.y);
233  	GetPainter()->drawLine(line);
234  }
235  void SurfaceImpl::PolyLine(const Point *pts, size_t npts, Stroke stroke)
236  {
237  	PenColourWidth(stroke.colour, stroke.width);
238  	std::vector<QPointF> qpts;
239  	std::transform(pts, pts + npts, std::back_inserter(qpts), QPointFFromPoint);
240  	GetPainter()->drawPolyline(&qpts[0], static_cast<int>(npts));
241  }
242  void SurfaceImpl::Polygon(const Point *pts, size_t npts, FillStroke fillStroke)
243  {
244  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
245  	BrushColour(fillStroke.fill.colour);
246  	std::vector<QPointF> qpts;
247  	std::transform(pts, pts + npts, std::back_inserter(qpts), QPointFFromPoint);
248  	GetPainter()->drawPolygon(&qpts[0], static_cast<int>(npts));
249  }
250  void SurfaceImpl::RectangleDraw(PRectangle rc, FillStroke fillStroke)
251  {
252  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
253  	BrushColour(fillStroke.fill.colour);
254  	const QRectF rect = QRectFFromPRect(rc.Inset(fillStroke.stroke.width / 2));
255  	GetPainter()->drawRect(rect);
256  }
257  void SurfaceImpl::RectangleFrame(PRectangle rc, Stroke stroke) {
258  	PenColourWidth(stroke.colour, stroke.width);
259  	GetPainter()->setBrush(QBrush());
260  	const QRectF rect = QRectFFromPRect(rc.Inset(stroke.width / 2));
261  	GetPainter()->drawRect(rect);
262  }
263  void SurfaceImpl::FillRectangle(PRectangle rc, Fill fill)
264  {
265  	GetPainter()->fillRect(QRectFFromPRect(rc), QColorFromColourRGBA(fill.colour));
266  }
267  void SurfaceImpl::FillRectangleAligned(PRectangle rc, Fill fill)
268  {
269  	FillRectangle(PixelAlign(rc, 1), fill);
270  }
271  void SurfaceImpl::FillRectangle(PRectangle rc, Surface &surfacePattern)
272  {
273  	SurfaceImpl *surface = dynamic_cast<SurfaceImpl *>(&surfacePattern);
274  	const QPixmap *pixmap = static_cast<QPixmap *>(surface->GetPaintDevice());
275  	GetPainter()->drawTiledPixmap(QRectFromPRect(rc), *pixmap);
276  }
277  void SurfaceImpl::RoundedRectangle(PRectangle rc, FillStroke fillStroke)
278  {
279  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
280  	BrushColour(fillStroke.fill.colour);
281  	GetPainter()->drawRoundedRect(QRectFFromPRect(rc), 3.0f, 3.0f);
282  }
283  void SurfaceImpl::AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke)
284  {
285  	QColor qFill = QColorFromColourRGBA(fillStroke.fill.colour);
286  	QBrush brushFill(qFill);
287  	GetPainter()->setBrush(brushFill);
288  	if (fillStroke.fill.colour == fillStroke.stroke.colour) {
289  		painter->setPen(Qt::NoPen);
290  		QRectF rect = QRectFFromPRect(rc);
291  		if (cornerSize > 0.0f) {
292  			qreal radius = cornerSize+1;
293  			GetPainter()->drawRoundedRect(rect, radius, radius);
294  		} else {
295  			GetPainter()->fillRect(rect, brushFill);
296  		}
297  	} else {
298  		QColor qOutline = QColorFromColourRGBA(fillStroke.stroke.colour);
299  		QPen penOutline(qOutline);
300  		penOutline.setWidthF(fillStroke.stroke.width);
301  		GetPainter()->setPen(penOutline);
302  		QRectF rect = QRectFFromPRect(rc.Inset(fillStroke.stroke.width / 2));
303  		if (cornerSize > 0.0f) {
304  			qreal radius = cornerSize+1;
305  			GetPainter()->drawRoundedRect(rect, radius, radius);
306  		} else {
307  			GetPainter()->drawRect(rect);
308  		}
309  	}
310  }
311  void SurfaceImpl::GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) {
312  	QRectF rect = QRectFFromPRect(rc);
313  	QLinearGradient linearGradient;
314  	switch (options) {
315  	case GradientOptions::leftToRight:
316  		linearGradient = QLinearGradient(rc.left, rc.top, rc.right, rc.top);
317  		break;
318  	case GradientOptions::topToBottom:
319  	default:
320  		linearGradient = QLinearGradient(rc.left, rc.top, rc.left, rc.bottom);
321  		break;
322  	}
323  	linearGradient.setSpread(QGradient::RepeatSpread);
324  	for (const ColourStop &stop : stops) {
325  		linearGradient.setColorAt(stop.position, QColorFromColourRGBA(stop.colour));
326  	}
327  	QBrush brush = QBrush(linearGradient);
328  	GetPainter()->fillRect(rect, brush);
329  }
330  static std::vector<unsigned char> ImageByteSwapped(int width, int height, const unsigned char *pixelsImage)
331  {
332  	size_t bytes = width * height * 4;
333  	std::vector<unsigned char> imageBytes(pixelsImage, pixelsImage+bytes);
334  	for (size_t i=0; i<bytes; i+=4)
335  		std::swap(imageBytes[i], imageBytes[i+2]);
336  	return imageBytes;
337  }
338  void SurfaceImpl::DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage)
339  {
340  	std::vector<unsigned char> imageBytes = ImageByteSwapped(width, height, pixelsImage);
341  	QImage image(&imageBytes[0], width, height, QImage::Format_ARGB32);
342  	QPoint pt(rc.left, rc.top);
343  	GetPainter()->drawImage(pt, image);
344  }
345  void SurfaceImpl::Ellipse(PRectangle rc, FillStroke fillStroke)
346  {
347  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
348  	BrushColour(fillStroke.fill.colour);
349  	const QRectF rect = QRectFFromPRect(rc.Inset(fillStroke.stroke.width / 2));
350  	GetPainter()->drawEllipse(rect);
351  }
352  void SurfaceImpl::Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) {
353  	const XYPOSITION halfStroke = fillStroke.stroke.width / 2.0f;
354  	const XYPOSITION radius = rc.Height() / 2.0f - halfStroke;
355  	PRectangle rcInner = rc;
356  	rcInner.left += radius;
357  	rcInner.right -= radius;
358  	const XYPOSITION arcHeight = rc.Height() - fillStroke.stroke.width;
359  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
360  	BrushColour(fillStroke.fill.colour);
361  	QPainterPath path;
362  	const Ends leftSide = static_cast<Ends>(static_cast<unsigned int>(ends) & 0xfu);
363  	const Ends rightSide = static_cast<Ends>(static_cast<unsigned int>(ends) & 0xf0u);
364  	switch (leftSide) {
365  		case Ends::leftFlat:
366  			path.moveTo(rc.left + halfStroke, rc.top + halfStroke);
367  			path.lineTo(rc.left + halfStroke, rc.bottom - halfStroke);
368  			break;
369  		case Ends::leftAngle:
370  			path.moveTo(rcInner.left + halfStroke, rc.top + halfStroke);
371  			path.lineTo(rc.left + halfStroke, rc.Centre().y);
372  			path.lineTo(rcInner.left + halfStroke, rc.bottom - halfStroke);
373  			break;
374  		case Ends::semiCircles:
375  		default:
376  			path.moveTo(rcInner.left + halfStroke, rc.top + halfStroke);
377  			QRectF rectangleArc(rc.left + halfStroke, rc.top + halfStroke,
378  					    arcHeight, arcHeight);
379  			path.arcTo(rectangleArc, 90, 180);
380  			break;
381  	}
382  	switch (rightSide) {
383  		case Ends::rightFlat:
384  			path.lineTo(rc.right - halfStroke, rc.bottom - halfStroke);
385  			path.lineTo(rc.right - halfStroke, rc.top + halfStroke);
386  			break;
387  		case Ends::rightAngle:
388  			path.lineTo(rcInner.right - halfStroke, rc.bottom - halfStroke);
389  			path.lineTo(rc.right - halfStroke, rc.Centre().y);
390  			path.lineTo(rcInner.right - halfStroke, rc.top + halfStroke);
391  			break;
392  		case Ends::semiCircles:
393  		default:
394  			path.lineTo(rcInner.right - halfStroke, rc.bottom - halfStroke);
395  			QRectF rectangleArc(rc.right - arcHeight - halfStroke, rc.top + halfStroke,
396  					    arcHeight, arcHeight);
397  			path.arcTo(rectangleArc, 270, 180);
398  			break;
399  	}
400  	path.closeSubpath();
401  	GetPainter()->drawPath(path);
402  }
403  void SurfaceImpl::Copy(PRectangle rc, Point from, Surface &surfaceSource)
404  {
405  	SurfaceImpl *source = dynamic_cast<SurfaceImpl *>(&surfaceSource);
406  	QPixmap *pixmap = static_cast<QPixmap *>(source->GetPaintDevice());
407  	GetPainter()->drawPixmap(rc.left, rc.top, *pixmap, from.x, from.y, -1, -1);
408  }
409  std::unique_ptr<IScreenLineLayout> SurfaceImpl::Layout(const IScreenLine *)
410  {
411  	return {};
412  }
413  void SurfaceImpl::DrawTextNoClip(PRectangle rc,
414  				 const Font *font,
415                                   XYPOSITION ybase,
416  				 std::string_view text,
417  				 ColourRGBA fore,
418  				 ColourRGBA back)
419  {
420  	SetFont(font);
421  	PenColour(fore);
422  	GetPainter()->setBackground(QColorFromColourRGBA(back));
423  	GetPainter()->setBackgroundMode(Qt::OpaqueMode);
424  	QString su = UnicodeFromText(codec, text);
425  	GetPainter()->drawText(QPointF(rc.left, ybase), su);
426  }
427  void SurfaceImpl::DrawTextClipped(PRectangle rc,
428  				  const Font *font,
429                                    XYPOSITION ybase,
430  				  std::string_view text,
431  				  ColourRGBA fore,
432  				  ColourRGBA back)
433  {
434  	SetClip(rc);
435  	DrawTextNoClip(rc, font, ybase, text, fore, back);
436  	PopClip();
437  }
438  void SurfaceImpl::DrawTextTransparent(PRectangle rc,
439  				      const Font *font,
440                                        XYPOSITION ybase,
441  				      std::string_view text,
442  	ColourRGBA fore)
443  {
444  	SetFont(font);
445  	PenColour(fore);
446  	GetPainter()->setBackgroundMode(Qt::TransparentMode);
447  	QString su = UnicodeFromText(codec, text);
448  	GetPainter()->drawText(QPointF(rc.left, ybase), su);
449  }
450  void SurfaceImpl::SetClip(PRectangle rc)
451  {
452  	GetPainter()->save();
453  	GetPainter()->setClipRect(QRectFFromPRect(rc), Qt::IntersectClip);
454  }
455  void SurfaceImpl::PopClip()
456  {
457  	GetPainter()->restore();
458  }
459  void SurfaceImpl::MeasureWidths(const Font *font,
460  				std::string_view text,
461                                  XYPOSITION *positions)
462  {
463  	if (!font)
464  		return;
465  	SetCodec(font);
466  	QString su = UnicodeFromText(codec, text);
467  	QTextLayout tlay(su, *FontPointer(font), GetPaintDevice());
468  	tlay.beginLayout();
469  	QTextLine tl = tlay.createLine();
470  	tlay.endLayout();
471  	if (mode.codePage == SC_CP_UTF8) {
472  		int fit = su.size();
473  		int ui=0;
474  		size_t i=0;
475  		while (ui<fit) {
476  			const unsigned char uch = text[i];
477  			const unsigned int byteCount = UTF8BytesOfLead[uch];
478  			const int codeUnits = UTF16LengthFromUTF8ByteCount(byteCount);
479  			qreal xPosition = tl.cursorToX(ui+codeUnits);
480  			for (size_t bytePos=0; (bytePos<byteCount) && (i<text.length()); bytePos++) {
481  				positions[i++] = xPosition;
482  			}
483  			ui += codeUnits;
484  		}
485  		XYPOSITION lastPos = 0;
486  		if (i > 0)
487  			lastPos = positions[i-1];
488  		while (i<text.length()) {
489  			positions[i++] = lastPos;
490  		}
491  	} else if (mode.codePage) {
492  		int ui = 0;
493  		for (size_t i=0; i<text.length();) {
494  			size_t lenChar = DBCSIsLeadByte(mode.codePage, text[i]) ? 2 : 1;
495  			qreal xPosition = tl.cursorToX(ui+1);
496  			for (unsigned int bytePos=0; (bytePos<lenChar) && (i<text.length()); bytePos++) {
497  				positions[i++] = xPosition;
498  			}
499  			ui++;
500  		}
501  	} else {
502  		for (int i=0; i<static_cast<int>(text.length()); i++) {
503  			positions[i] = tl.cursorToX(i+1);
504  		}
505  	}
506  }
507  XYPOSITION SurfaceImpl::WidthText(const Font *font, std::string_view text)
508  {
509  	QFontMetricsF metrics(*FontPointer(font), device);
510  	SetCodec(font);
511  	QString su = UnicodeFromText(codec, text);
512  #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
513  	return metrics.horizontalAdvance(su);
514  #else
515  	return metrics.width(su);
516  #endif
517  }
518  void SurfaceImpl::DrawTextNoClipUTF8(PRectangle rc,
519  				 const Font *font,
520  				 XYPOSITION ybase,
521  				 std::string_view text,
522  				 ColourRGBA fore,
523  				 ColourRGBA back)
524  {
525  	SetFont(font);
526  	PenColour(fore);
527  	GetPainter()->setBackground(QColorFromColourRGBA(back));
528  	GetPainter()->setBackgroundMode(Qt::OpaqueMode);
529  	QString su = QString::fromUtf8(text.data(), static_cast<int>(text.length()));
530  	GetPainter()->drawText(QPointF(rc.left, ybase), su);
531  }
532  void SurfaceImpl::DrawTextClippedUTF8(PRectangle rc,
533  				  const Font *font,
534  				  XYPOSITION ybase,
535  				  std::string_view text,
536  				  ColourRGBA fore,
537  				  ColourRGBA back)
538  {
539  	SetClip(rc);
540  	DrawTextNoClip(rc, font, ybase, text, fore, back);
541  	PopClip();
542  }
543  void SurfaceImpl::DrawTextTransparentUTF8(PRectangle rc,
544  				      const Font *font,
545  				      XYPOSITION ybase,
546  				      std::string_view text,
547  	ColourRGBA fore)
548  {
549  	SetFont(font);
550  	PenColour(fore);
551  	GetPainter()->setBackgroundMode(Qt::TransparentMode);
552  	QString su = QString::fromUtf8(text.data(), static_cast<int>(text.length()));
553  	GetPainter()->drawText(QPointF(rc.left, ybase), su);
554  }
555  void SurfaceImpl::MeasureWidthsUTF8(const Font *font,
556  				std::string_view text,
557  				XYPOSITION *positions)
558  {
559  	if (!font)
560  		return;
561  	QString su = QString::fromUtf8(text.data(), static_cast<int>(text.length()));
562  	QTextLayout tlay(su, *FontPointer(font), GetPaintDevice());
563  	tlay.beginLayout();
564  	QTextLine tl = tlay.createLine();
565  	tlay.endLayout();
566  	int fit = su.size();
567  	int ui=0;
568  	size_t i=0;
569  	while (ui<fit) {
570  		const unsigned char uch = text[i];
571  		const unsigned int byteCount = UTF8BytesOfLead[uch];
572  		const int codeUnits = UTF16LengthFromUTF8ByteCount(byteCount);
573  		qreal xPosition = tl.cursorToX(ui+codeUnits);
574  		for (size_t bytePos=0; (bytePos<byteCount) && (i<text.length()); bytePos++) {
575  			positions[i++] = xPosition;
576  		}
577  		ui += codeUnits;
578  	}
579  	XYPOSITION lastPos = 0;
580  	if (i > 0)
581  		lastPos = positions[i-1];
582  	while (i<text.length()) {
583  		positions[i++] = lastPos;
584  	}
585  }
586  XYPOSITION SurfaceImpl::WidthTextUTF8(const Font *font, std::string_view text)
587  {
588  	QFontMetricsF metrics(*FontPointer(font), device);
589  	QString su = QString::fromUtf8(text.data(), static_cast<int>(text.length()));
590  #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
591  	return metrics.horizontalAdvance(su);
592  #else
593  	return metrics.width(su);
594  #endif
595  }
596  XYPOSITION SurfaceImpl::Ascent(const Font *font)
597  {
598  	QFontMetricsF metrics(*FontPointer(font), device);
599  	return metrics.ascent();
600  }
601  XYPOSITION SurfaceImpl::Descent(const Font *font)
602  {
603  	QFontMetricsF metrics(*FontPointer(font), device);
604  	return metrics.descent() + 1;
605  }
606  XYPOSITION SurfaceImpl::InternalLeading(const Font * &bsol;* font */)
607  {
608  	return 0;
609  }
610  XYPOSITION SurfaceImpl::Height(const Font *font)
611  {
612  	QFontMetricsF metrics(*FontPointer(font), device);
613  	return metrics.height();
614  }
615  XYPOSITION SurfaceImpl::AverageCharWidth(const Font *font)
616  {
617  	QFontMetricsF metrics(*FontPointer(font), device);
618  	return metrics.averageCharWidth();
619  }
620  void SurfaceImpl::FlushCachedState()
621  {
622  	if (device->paintingActive()) {
623  		GetPainter()->setPen(QPen());
624  		GetPainter()->setBrush(QBrush());
625  	}
626  }
627  void SurfaceImpl::FlushDrawing()
628  {
629  }
630  QPaintDevice *SurfaceImpl::GetPaintDevice()
631  {
632  	return device;
633  }
634  QPainter *SurfaceImpl::GetPainter()
635  {
636  	Q_ASSERT(device);
637  	if (!painter) {
638  		if (device->paintingActive()) {
639  			painter = device->paintEngine()->painter();
640  		} else {
641  			painterOwned = true;
642  			painter = new QPainter(device);
643  		}
644  		painter->setRenderHint(QPainter::TextAntialiasing, true);
645  		painter->setRenderHint(QPainter::Antialiasing, true);
646  	}
647  	return painter;
648  }
649  std::unique_ptr<Surface> Surface::Allocate(Technology)
650  {
651  	return std::make_unique<SurfaceImpl>();
652  }
653  namespace {
654  QWidget *window(WindowID wid) noexcept
655  {
656  	return static_cast<QWidget *>(wid);
657  }
658  QRect ScreenRectangleForPoint(QPoint posGlobal)
659  {
660  #if QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)
661  	const QScreen *screen = QGuiApplication::screenAt(posGlobal);
662  	if (!screen) {
663  		screen = QGuiApplication::primaryScreen();
664  	}
665  	return screen->availableGeometry();
666  #else
667  	const QDesktopWidget *desktop = QApplication::desktop();
668  	return desktop->availableGeometry(posGlobal);
669  #endif
670  }
671  }
672  Window::~Window() noexcept = default;
673  void Window::Destroy() noexcept
674  {
675  	if (wid)
676  		delete window(wid);
677  	wid = nullptr;
678  }
679  PRectangle Window::GetPosition() const
680  {
681  	return wid ? PRectFromQRect(window(wid)->frameGeometry()) : PRectangle(0, 0, 1000, 1000);
682  }
683  void Window::SetPosition(PRectangle rc)
684  {
685  	if (wid)
686  		window(wid)->setGeometry(QRectFromPRect(rc));
687  }
688  void Window::SetPositionRelative(PRectangle rc, const Window *relativeTo)
689  {
690  	QPoint oPos = window(relativeTo->wid)->mapToGlobal(QPoint(0,0));
691  	int ox = oPos.x();
692  	int oy = oPos.y();
693  	ox += rc.left;
694  	oy += rc.top;
695  	const QRect rectDesk = ScreenRectangleForPoint(QPoint(ox, oy));
696  	int sizex = rc.right - rc.left;
697  	int sizey = rc.bottom - rc.top;
698  	int screenWidth = rectDesk.width();
699  	if (ox < rectDesk.x())
700  		ox = rectDesk.x();
701  	if (sizex > screenWidth)
702  		ox = rectDesk.x(); &bsol;* the best we can do */
703  	else if (ox + sizex > rectDesk.right())
704  		ox = rectDesk.right() - sizex;
705  	if (oy + sizey > rectDesk.bottom())
706  		oy = rectDesk.bottom() - sizey;
707  	if (oy < rectDesk.top())
708  		oy = rectDesk.top();
709  	Q_ASSERT(wid);
710  	window(wid)->move(ox, oy);
711  	window(wid)->resize(sizex, sizey);
712  }
713  PRectangle Window::GetClientPosition() const
714  {
715  	return GetPosition();
716  }
717  void Window::Show(bool show)
718  {
719  	if (wid)
720  		window(wid)->setVisible(show);
721  }
722  void Window::InvalidateAll()
723  {
724  	if (wid)
725  		window(wid)->update();
726  }
727  void Window::InvalidateRectangle(PRectangle rc)
728  {
729  	if (wid)
730  		window(wid)->update(QRectFromPRect(rc));
731  }
732  void Window::SetCursor(Cursor curs)
733  {
734  	if (wid) {
735  		Qt::CursorShape shape;
736  		switch (curs) {
737  			case Cursor::text:  shape = Qt::IBeamCursor;        break;
738  			case Cursor::arrow: shape = Qt::ArrowCursor;        break;
739  			case Cursor::up:    shape = Qt::UpArrowCursor;      break;
740  			case Cursor::wait:  shape = Qt::WaitCursor;         break;
741  			case Cursor::horizontal: shape = Qt::SizeHorCursor; break;
742  			case Cursor::vertical:  shape = Qt::SizeVerCursor;  break;
743  			case Cursor::hand:  shape = Qt::PointingHandCursor; break;
744  			default:            shape = Qt::ArrowCursor;        break;
745  		}
746  		QCursor cursor = QCursor(shape);
747  		if (curs != cursorLast) {
748  			window(wid)->setCursor(cursor);
749  			cursorLast = curs;
750  		}
751  	}
752  }
753  PRectangle Window::GetMonitorRect(Point pt)
754  {
755  	const QPoint posGlobal = window(wid)->mapToGlobal(QPoint(pt.x, pt.y));
756  	const QPoint originGlobal = window(wid)->mapToGlobal(QPoint(0, 0));
757  	QRect rectScreen = ScreenRectangleForPoint(posGlobal);
758  	rectScreen.translate(-originGlobal.x(), -originGlobal.y());
759  	return PRectFromQRect(rectScreen);
760  }
761  class ListWidget : public QListWidget {
762  public:
763  	explicit ListWidget(QWidget *parent);
764  	void setDelegate(IListBoxDelegate *lbDelegate);
765  	int currentSelection();
766  protected:
767  	void selectionChanged(const QItemSelection &selected, const QItemSelection &deselected) override;
768  	void mouseDoubleClickEvent(QMouseEvent *event) override;
769  #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
770  	void initViewItemOption(QStyleOptionViewItem *option) const override;
771  #else
772  	QStyleOptionViewItem viewOptions() const override;
773  #endif
774  private:
775  	IListBoxDelegate *delegate;
776  };
777  class ListBoxImpl : public ListBox {
778  public:
779  	ListBoxImpl() noexcept;
780  	void SetFont(const Font *font) override;
781  	void Create(Window &parent, int ctrlID, Point location,
782  						int lineHeight, bool unicodeMode_, Technology technology) override;
783  	void SetAverageCharWidth(int width) override;
784  	void SetVisibleRows(int rows) override;
785  	int GetVisibleRows() const override;
786  	PRectangle GetDesiredRect() override;
787  	int CaretFromEdge() override;
788  	void Clear() noexcept override;
789  	void Append(char *s, int type) override;
790  	int Length() override;
791  	void Select(int n) override;
792  	int GetSelection() override;
793  	int Find(const char *prefix) override;
794  	std::string GetValue(int n) override;
795  	void RegisterImage(int type, const char *xpmData) override;
796  	void RegisterRGBAImage(int type, int width, int height,
797  		const unsigned char *pixelsImage) override;
798  	virtual void RegisterQPixmapImage(int type, const QPixmap& pm);
799  	void ClearRegisteredImages() override;
800  	void SetDelegate(IListBoxDelegate *lbDelegate) override;
801  	void SetList(const char *list, char separator, char typesep) override;
802  	void SetOptions(ListOptions options_) override;
803  	[[nodiscard]] ListWidget *GetWidget() const noexcept;
804  private:
805  	bool unicodeMode{false};
806  	int visibleRows{5};
807  	QMap<int,QPixmap> images;
808  };
809  ListBoxImpl::ListBoxImpl() noexcept = default;
810  void ListBoxImpl::Create(Window &parent,
811                           int &bsol;*ctrlID*/,
812                           Point location,
813                           int &bsol;*lineHeight*/,
814                           bool unicodeMode_,
815  			 Technology)
816  {
817  	unicodeMode = unicodeMode_;
818  	QWidget *qparent = static_cast<QWidget *>(parent.GetID());
819  	ListWidget *list = new ListWidget(qparent);
820  #if defined(Q_OS_WIN)
821  	list->setParent(nullptr, Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint
822  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
823  		| Qt::WindowDoesNotAcceptFocus
824  #endif
825  	);
826  #else
827  	list->setParent(nullptr, static_cast<Qt::WindowFlags>(Qt::ToolTip | Qt::FramelessWindowHint));
828  #endif
829  	list->setAttribute(Qt::WA_ShowWithoutActivating);
830  	list->setFocusPolicy(Qt::NoFocus);
831  	list->setUniformItemSizes(true);
832  	list->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
833  	list->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
834  	list->move(location.x, location.y);
835  	int maxIconWidth = 0;
836  	int maxIconHeight = 0;
837  	foreach (QPixmap im, images) {
838  		if (maxIconWidth < im.width())
839  			maxIconWidth = im.width();
840  		if (maxIconHeight < im.height())
841  			maxIconHeight = im.height();
842  	}
843  	list->setIconSize(QSize(maxIconWidth, maxIconHeight));
844  	wid = list;
845  }
846  void ListBoxImpl::SetFont(const Font *font)
847  {
848  	ListWidget *list = GetWidget();
849  	const FontAndCharacterSet *pfacs = AsFontAndCharacterSet(font);
850  	if (pfacs && pfacs->pfont) {
851  		list->setFont(*(pfacs->pfont));
852  	}
853  }
854  void ListBoxImpl::SetAverageCharWidth(int &bsol;*width*/) {}
855  void ListBoxImpl::SetVisibleRows(int rows)
856  {
857  	visibleRows = rows;
858  }
859  int ListBoxImpl::GetVisibleRows() const
860  {
861  	return visibleRows;
862  }
863  PRectangle ListBoxImpl::GetDesiredRect()
864  {
865  	ListWidget *list = GetWidget();
866  	int rows = Length();
867  	if (rows == 0 || rows > visibleRows) {
868  		rows = visibleRows;
869  	}
870  	int rowHeight = list->sizeHintForRow(0);
871  	int height = (rows * rowHeight) + (2 * list->frameWidth());
872  	QStyle *style = QApplication::style();
873  	int width = list->sizeHintForColumn(0) + (2 * list->frameWidth());
874  	if (Length() > rows) {
875  		width += style->pixelMetric(QStyle::PM_ScrollBarExtent);
876  	}
877  	return PRectangle(0, 0, width, height);
878  }
879  int ListBoxImpl::CaretFromEdge()
880  {
881  	ListWidget *list = GetWidget();
882  	int maxIconWidth = 0;
883  	foreach (QPixmap im, images) {
884  		if (maxIconWidth < im.width())
885  			maxIconWidth = im.width();
886  	}
887  	int extra;
888  #ifdef Q_OS_DARWIN
889  	extra = 12;
890  #else
891  	extra = 7;
892  #endif
893  	return maxIconWidth + (2 * list->frameWidth()) + extra;
894  }
895  void ListBoxImpl::Clear() noexcept
896  {
897  	ListWidget *list = GetWidget();
898  	list->clear();
899  }
900  void ListBoxImpl::Append(char *s, int type)
901  {
902  	ListWidget *list = GetWidget();
903  	QString str = unicodeMode ? QString::fromUtf8(s) : QString::fromLocal8Bit(s);
904  	QIcon icon;
905  	if (type >= 0) {
906  		Q_ASSERT(images.contains(type));
907  		icon = images.value(type);
908  	}
909  	new QListWidgetItem(icon, str, list);
910  }
911  int ListBoxImpl::Length()
912  {
913  	ListWidget *list = GetWidget();
914  	return list->count();
915  }
916  void ListBoxImpl::Select(int n)
917  {
918  	ListWidget *list = GetWidget();
919  	QModelIndex index = list->model()->index(n, 0);
920  	if (index.isValid()) {
921  		QRect row_rect = list->visualRect(index);
922  		if (!list->viewport()->rect().contains(row_rect)) {
923  			list->scrollTo(index, QAbstractItemView::PositionAtTop);
924  		}
925  	}
926  	list->setCurrentRow(n);
927  }
928  int ListBoxImpl::GetSelection()
929  {
930  	ListWidget *list = GetWidget();
931  	return list->currentSelection();
932  }
933  int ListBoxImpl::Find(const char *prefix)
934  {
935  	ListWidget *list = GetWidget();
936  	QString sPrefix = unicodeMode ? QString::fromUtf8(prefix) : QString::fromLocal8Bit(prefix);
937  	QList<QListWidgetItem *> ms = list->findItems(sPrefix, Qt::MatchStartsWith);
938  	int result = -1;
939  	if (!ms.isEmpty()) {
940  		result = list->row(ms.first());
941  	}
942  	return result;
943  }
944  std::string ListBoxImpl::GetValue(int n)
945  {
946  	ListWidget *list = GetWidget();
947  	QListWidgetItem *item = list->item(n);
948  	QString str = item->data(Qt::DisplayRole).toString();
949  	QByteArray bytes = unicodeMode ? str.toUtf8() : str.toLocal8Bit();
950  	return std::string(bytes.constData());
951  }
952  void ListBoxImpl::RegisterQPixmapImage(int type, const QPixmap& pm)
953  {
954  	images[type] = pm;
955  	ListWidget *list = GetWidget();
956  	if (list) {
957  		QSize iconSize = list->iconSize();
958  		if (pm.width() > iconSize.width() || pm.height() > iconSize.height())
959  			list->setIconSize(QSize(qMax(pm.width(), iconSize.width()),
960  						 qMax(pm.height(), iconSize.height())));
961  	}
962  }
963  void ListBoxImpl::RegisterImage(int type, const char *xpmData)
964  {
965  	XPM xpmImage(xpmData);
966  	RGBAImage rgbaImage(xpmImage);
967  	RegisterRGBAImage(type, rgbaImage.GetWidth(), rgbaImage.GetHeight(), rgbaImage.Pixels());
968  }
969  void ListBoxImpl::RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage)
970  {
971  	std::vector<unsigned char> imageBytes = ImageByteSwapped(width, height, pixelsImage);
972  	QImage image(&imageBytes[0], width, height, QImage::Format_ARGB32);
973  	RegisterQPixmapImage(type, QPixmap::fromImage(image));
974  }
975  void ListBoxImpl::ClearRegisteredImages()
976  {
977  	images.clear();
978  	ListWidget *list = GetWidget();
979  	if (list)
980  		list->setIconSize(QSize(0, 0));
981  }
982  void ListBoxImpl::SetDelegate(IListBoxDelegate *lbDelegate)
983  {
984  	ListWidget *list = GetWidget();
985  	list->setDelegate(lbDelegate);
986  }
987  void ListBoxImpl::SetList(const char *list, char separator, char typesep)
988  {
989  	Clear();
990  	size_t count = strlen(list) + 1;
991  	std::vector<char> words(list, list+count);
992  	char *startword = &words[0];
993  	char *numword = nullptr;
994  	int i = 0;
995  	for (; words[i]; i++) {
996  		if (words[i] == separator) {
997  			words[i] = '\0';
998  			if (numword)
999  				*numword = '\0';
1000  			Append(startword, numword?atoi(numword + 1):-1);
1001  			startword = &words[0] + i + 1;
1002  			numword = nullptr;
1003  		} else if (words[i] == typesep) {
1004  			numword = &words[0] + i;
1005  		}
1006  	}
1007  	if (startword) {
1008  		if (numword)
1009  			*numword = '\0';
1010  		Append(startword, numword?atoi(numword + 1):-1);
1011  	}
1012  }
1013  void ListBoxImpl::SetOptions(ListOptions)
1014  {
1015  }
1016  ListWidget *ListBoxImpl::GetWidget() const noexcept
1017  {
1018  	return static_cast<ListWidget *>(wid);
1019  }
1020  ListBox::ListBox() noexcept = default;
1021  ListBox::~ListBox() noexcept = default;
1022  std::unique_ptr<ListBox> ListBox::Allocate()
1023  {
1024  	return std::make_unique<ListBoxImpl>();
1025  }
1026  ListWidget::ListWidget(QWidget *parent)
1027  : QListWidget(parent), delegate(nullptr)
1028  {}
1029  void ListWidget::setDelegate(IListBoxDelegate *lbDelegate)
1030  {
1031  	delegate = lbDelegate;
1032  }
1033  void ListWidget::selectionChanged(const QItemSelection &selected, const QItemSelection &deselected) {
1034  	QListWidget::selectionChanged(selected, deselected);
1035  	if (delegate) {
1036  		const int selection = currentSelection();
1037  		if (selection >= 0) {
1038  			ListBoxEvent event(ListBoxEvent::EventType::selectionChange);
1039  			delegate->ListNotify(&event);
1040  		}
1041  	}
1042  }
1043  int ListWidget::currentSelection() {
1044  	const QModelIndexList indices = selectionModel()->selectedRows();
1045  	foreach (const QModelIndex ind, indices) {
1046  		return ind.row();
1047  	}
1048  	return -1;
1049  }
1050  void ListWidget::mouseDoubleClickEvent(QMouseEvent * &bsol;* event */)
1051  {
1052  	if (delegate) {
1053  		ListBoxEvent event(ListBoxEvent::EventType::doubleClick);
1054  		delegate->ListNotify(&event);
1055  	}
1056  }
1057  #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
1058  void ListWidget::initViewItemOption(QStyleOptionViewItem *option) const
1059  {
1060  	QListWidget::initViewItemOption(option);
1061  	option->state |= QStyle::State_Active;
1062  }
1063  #else
1064  QStyleOptionViewItem ListWidget::viewOptions() const
1065  {
1066  	QStyleOptionViewItem result = QListWidget::viewOptions();
1067  	result.state |= QStyle::State_Active;
1068  	return result;
1069  }
1070  #endif
1071  Menu::Menu() noexcept : mid(nullptr) {}
1072  void Menu::CreatePopUp()
1073  {
1074  	Destroy();
1075  	mid = new QMenu();
1076  }
1077  void Menu::Destroy() noexcept
1078  {
1079  	if (mid) {
1080  		QMenu *menu = static_cast<QMenu *>(mid);
1081  		delete menu;
1082  	}
1083  	mid = nullptr;
1084  }
1085  void Menu::Show(Point pt, const Window & &bsol;*w*/)
1086  {
1087  	QMenu *menu = static_cast<QMenu *>(mid);
1088  	menu->exec(QPoint(pt.x, pt.y));
1089  	Destroy();
1090  }
1091  ColourRGBA Platform::Chrome()
1092  {
1093  	QColor c(Qt::gray);
1094  	return ColourRGBA(c.red(), c.green(), c.blue());
1095  }
1096  ColourRGBA Platform::ChromeHighlight()
1097  {
1098  	QColor c(Qt::lightGray);
1099  	return ColourRGBA(c.red(), c.green(), c.blue());
1100  }
1101  const char *Platform::DefaultFont()
1102  {
1103  	static char fontNameDefault[200] = "";
1104  	if (!fontNameDefault[0]) {
1105  		QFont font = QApplication::font();
1106  		strcpy(fontNameDefault, font.family().toUtf8());
1107  	}
1108  	return fontNameDefault;
1109  }
1110  int Platform::DefaultFontSize()
1111  {
1112  	QFont font = QApplication::font();
1113  	return font.pointSize();
1114  }
1115  unsigned int Platform::DoubleClickTime()
1116  {
1117  	return QApplication::doubleClickInterval();
1118  }
1119  void Platform::DebugDisplay(const char *s) noexcept
1120  {
1121  	qWarning("Scintilla: %s", s);
1122  }
1123  void Platform::DebugPrintf(const char *format, ...) noexcept
1124  {
1125  	char buffer[2000];
1126  	va_list pArguments{};
1127  	va_start(pArguments, format);
1128  	vsnprintf(buffer, std::size(buffer), format, pArguments);
1129  	va_end(pArguments);
1130  	Platform::DebugDisplay(buffer);
1131  }
1132  bool Platform::ShowAssertionPopUps(bool &bsol;*assertionPopUps*/) noexcept
1133  {
1134  	return false;
1135  }
1136  void Platform::Assert(const char *c, const char *file, int line) noexcept
1137  {
1138  	char buffer[2000];
1139  	snprintf(buffer, std::size(buffer), "Assertion [%s] failed at %s %d", c, file, line);
1140  	if (Platform::ShowAssertionPopUps(false)) {
1141  		QMessageBox mb("Assertion Failure", buffer, QMessageBox::NoIcon,
1142  			QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
1143  		mb.exec();
1144  	} else {
1145  		strcat(buffer, "\n");
1146  		Platform::DebugDisplay(buffer);
1147  	}
1148  }
1149  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-nodemanip.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatQt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>38      ConfType linkType = ConfType::Unknow;
39      std::vector<Proxy> nodes;
40      Proxy node;
</pre></code></div>
                <div class="column column_space"><pre><code>89  	CharacterSet characterSet = CharacterSet::Ansi;
90  	std::unique_ptr<QFont> pfont;
91  	explicit FontAndCharacterSet(const FontParameters &fp) : characterSet(fp.characterSet) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    