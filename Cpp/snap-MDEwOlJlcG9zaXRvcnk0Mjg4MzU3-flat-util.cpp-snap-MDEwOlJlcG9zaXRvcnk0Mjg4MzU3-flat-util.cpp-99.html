
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 51, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</h3>
            <pre><code>1  void TGUtil::GetCdf(const TIntPrV&amp; PdfV, TIntPrV&amp; CdfV) {
2    CdfV = PdfV;
3    for (int i = 1; i &lt; CdfV.Len(); i++) {
4      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
5  }
6  void TGUtil::GetCdf(const TFltPrV&amp; PdfV, TFltPrV&amp; CdfV) {
7    CdfV = PdfV;
8    for (int i = 1; i &lt; CdfV.Len(); i++) {
9      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
10  }
11  void TGUtil::GetCdf(const TIntFltKdV&amp; PdfV, TIntFltKdV&amp; CdfV) {
12    CdfV = PdfV;
13    for (int i = 1; i &lt; CdfV.Len(); i++) {
14      CdfV[i].Dat = CdfV[i-1].Dat + CdfV[i].Dat; }
15  }
16  TIntPrV TGUtil::GetCdf(const TIntPrV&amp; PdfV) {
17    TIntPrV CdfV;
18    GetCdf(PdfV, CdfV);
19    return CdfV;
20  }
21  TFltPrV TGUtil::GetCdf(const TFltPrV&amp; PdfV) {
22    TFltPrV CdfV;
23    GetCdf(PdfV, CdfV);
24    return CdfV;
25  }
26  void TGUtil::GetCCdf(const TIntPrV&amp; PdfV, TIntPrV&amp; CCdfV) {
27    CCdfV = PdfV;
28    for (int i = CCdfV.Len()-2; i &gt;= 0; i--) {
29      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
30  }
31  void TGUtil::GetCCdf(const TFltPrV&amp; PdfV, TFltPrV&amp; CCdfV) {
32    CCdfV = PdfV;
33    for (int i = CCdfV.Len()-2; i &gt;= 0; i--) {
34      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
35  }
36  void TGUtil::GetCCdf(const TIntFltKdV&amp; PdfV, TIntFltKdV&amp; CCdfV) {
37    CCdfV = PdfV;
38    for (int i = CCdfV.Len()-2; i &gt;= 0; i--) {
39      CCdfV[i].Dat = CCdfV[i+1].Dat + CCdfV[i].Dat; }
40  }
41  TIntPrV TGUtil::GetCCdf(const TIntPrV&amp; PdfV) {
42    TIntPrV CCdfV;
43    GetCCdf(PdfV, CCdfV);
44    return CCdfV;
45  }
46  TFltPrV TGUtil::GetCCdf(const TFltPrV&amp; PdfV) {
47    TFltPrV CCdfV;
48    GetCCdf(PdfV, CCdfV);
49    return CCdfV;
50  }
51  void TGUtil::GetPdf(const TIntPrV&amp; CdfV, TIntPrV&amp; PdfV) {
52    PdfV = CdfV;
53    for (int i = PdfV.Len()-1; i &gt; 0; i--) {
54      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
55  }
56  void TGUtil::GetPdf(const TFltPrV&amp; CdfV, TFltPrV&amp; PdfV) {
57    PdfV = CdfV;
58    for (int i = PdfV.Len()-1; i &gt; 0; i--) {
59      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
60  }
61  void TGUtil::GetPdf(const TIntFltKdV&amp; CdfV, TIntFltKdV&amp; PdfV) {
62    PdfV = CdfV;
63    for (int i = PdfV.Len()-1; i &gt; 0; i--) {
64      PdfV[i].Dat = PdfV[i].Dat - PdfV[i-1].Dat; }
65  }
66  void TGUtil::Normalize(TFltPrV&amp; PdfV) {
67    double Sum = 0.0;
68    for (int i = 0; i &lt; PdfV.Len(); i++) {
69      Sum += PdfV[i].Val2; }
70    if (Sum &lt;= 0.0) { return; }
71    for (int i = 0; i &lt; PdfV.Len(); i++) {
72      PdfV[i].Val2 /= Sum; }
73  }
74  void TGUtil::Normalize(TIntFltKdV&amp; PdfV) {
75    double Sum = 0.0;
76    for (int i = 0; i &lt; PdfV.Len(); i++) {
77      Sum += PdfV[i].Dat; }
78    if (Sum &lt;= 0.0) { return; }
79    for (int i = 0; i &lt; PdfV.Len(); i++) {
80      PdfV[i].Dat /= Sum; }
81  }
82  void TGUtil::MakeExpBins(const TFltPrV&amp; XYValV, TFltPrV&amp; ExpXYValV, const double&amp; BinFactor, const double&amp; MinYVal) {
83    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
84  }
85  void TGUtil::MakeExpBins(const TFltKdV&amp; XYValV, TFltKdV&amp; ExpXYValV, const double&amp; BinFactor, const double&amp; MinYVal) {
86    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
87  }
88  void TGUtil::MakeExpBins(const TFltV&amp; YValV, TFltV&amp; ExpYValV, const double&amp; BinFactor) {
89    ExpYValV.Clr(true);
90    int prevI=0;
91    for (int i = 0; i &lt; YValV.Len(); ) {
92      ExpYValV.Add(YValV[i]);
93      i = int(i*BinFactor);
94      if (i==prevI) { i++; }
95      prevI = i;
96    }
97  }
98  void TGUtil::MakeExpBins(const TIntV&amp; YValV, TIntV&amp; ExpYValV, const double&amp; BinFactor) {
99    ExpYValV.Clr(true);
100    int prevI=0;
101    for (int i = 0; i &lt; YValV.Len(); ) {
102      ExpYValV.Add(YValV[i]);
103      i = int(i*BinFactor);
104      if (i==prevI) { i++; }
105      prevI = i;
106    }
107  }
108  TChA&amp; TStrUtil::GetXmlTagVal(TXmlLx&amp; XmlLx, const TChA&amp; TagNm) {
109    static TChA TagVal;
110    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
111    EAssertR(TagNm == XmlLx.TagNm.CStr(), TagNm);
112    const TXmlLxSym NextSym = XmlLx.GetSym();
113    TagVal = XmlLx.TxtChA;
114    if (NextSym == xsyStr) {
115      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
116    } else {
117      EAssertR(NextSym == xsyETag, TagNm); 
118    }
119    EAssertR(XmlLx.TagNm == TagNm, TagNm);
120    return TagVal;
121  }
122  void TStrUtil::GetXmlTagNmVal(TXmlLx&amp; XmlLx, TChA&amp; TagNm, TChA&amp; TagVal) {
123    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
124    TagNm = XmlLx.TagNm;
125    const TXmlLxSym NextSym = XmlLx.GetSym();
126    TagVal = XmlLx.TxtChA;
127    if (NextSym == xsyStr) {
128      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
129    } else {
130      EAssertR(NextSym == xsyETag, TagNm); 
131    }
132  }
133  bool TStrUtil::GetXmlTagNmVal2(TXmlLx&amp; XmlLx, TChA&amp; TagNm, TChA&amp; TagVal, const bool&amp; TakeTagNms) {
134    if (XmlLx.GetSym() != xsySTag) {
135      return false; }
136    TagVal.Clr();
137    TagNm = XmlLx.TagNm;
138    while (XmlLx.Sym != xsyETag || XmlLx.TagNm != TagNm.CStr()) {
139      if (TakeTagNms) {
140        TagVal += XmlLx.TxtChA; }
141      else if (XmlLx.Sym == xsyStr) {
142        TagVal += XmlLx.TxtChA; }
143      XmlLx.GetSym();
144    }
145    return true;
146  }
147  TChA TStrUtil::GetDomNm(const TChA&amp; UrlChA) {
148    int EndSlash = UrlChA.SearchCh(&#x27;/&#x27;, 7)-1; 
149    if (EndSlash &gt; 0) {
150      const int BegSlash = UrlChA.SearchChBack(&#x27;/&#x27;, EndSlash);
151      if (BegSlash &gt; 0) { return UrlChA.GetSubStr(BegSlash+1, EndSlash).ToLc(); }
152      else { return UrlChA.GetSubStr(0, UrlChA.SearchCh(&#x27;/&#x27;, 0)-1).ToLc(); }
153    } else {
154      if (UrlChA.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;&quot;)) { return UrlChA.GetSubStr(7, UrlChA.Len()-1).ToLc(); }
155      EndSlash = UrlChA.SearchCh(&#x27;/&#x27;, 0);
156      if (EndSlash &gt; 0) { return UrlChA.GetSubStr(0, EndSlash-1).ToLc(); }
157      else { return TChA(UrlChA).ToLc(); }
158    }
159  }
160  TChA TStrUtil::GetDomNm2(const TChA&amp; UrlChA) {
161    TChA Dom = GetDomNm(UrlChA);
162    if (Dom.IsPrefix(&quot;www.&quot;)) { return Dom.GetSubStr(4, TInt::Mx); }
163    else { return Dom; }
164  }
165  int GetNthOccurence(const TChA&amp; Url, const int&amp; Count, const char Ch=&#x27;/&#x27;) {
166    const char *c = Url.CStr();
167    int cnt = 0;
168    while (*c &amp;&amp; cnt != Count) {
169      if (*c == Ch) { cnt++; }
170      c++;
171    }
172    return int(c-Url.CStr()-1);
173  }
174  TChA TStrUtil::GetWebsiteNm(const TChA&amp; PostUrlStr) {
175    TChA DomNm = TStrUtil::GetDomNm2(PostUrlStr);
176    if (DomNm == &quot;blog.myspace.com&quot;) {
177      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 2, &#x27;&amp;&#x27;)-1);
178    }
179    if (DomNm==&quot;blogs.msdn.com&quot; || DomNm==&quot;ameblo.jp&quot; || DomNm==&quot;xfruits.com&quot; || DomNm==&quot;scienceblogs.com&quot; || DomNm==&quot;blogs.sun.com&quot;
180      || DomNm==&quot;blog.wired.com&quot; || DomNm==&quot;weblogs.asp.net&quot; || DomNm==&quot;blogs.technet.com&quot; || DomNm==&quot;blogs.guardian.co&quot;
181      || DomNm==&quot;blogs.clarin.com&quot; || DomNm==&quot;blogs.sun.com&quot; || DomNm==&quot;blog.wired.com&quot; || DomNm==&quot;weblogs.asp.net&quot;
182      || DomNm==&quot;blogs.technet.com&quot; || DomNm==&quot;blogs.guardian.com&quot; || DomNm==&quot;blogs.clarin.com&quot; || DomNm==&quot;blogs.zdnet.com&quot;
183      || DomNm==&quot;blogs.citypages.com&quot; || DomNm==&quot;voices.washingtonpost.com&quot; || DomNm==&quot;blog.tv2.dk&quot;
184      || DomNm==&quot;blogs.menomoneefallsnow.com&quot; || DomNm==&quot;weblogs.baltimoresun.com&quot; || DomNm==&quot;eonline.com&quot;) {
185        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1);
186    }
187    if (DomNm == &quot;digg.com&quot;) {
188      if (PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;digg.com/submit?&quot;)) {
189        const int Url = PostUrlStr.SearchStr(&quot;;url=&quot;);
190        if (Url != -1) {
191          return GetWebsiteNm(PostUrlStr.GetSubStr(Url+5, PostUrlStr.SearchCh(&#x27;&amp;&#x27;, Url+5))); }
192      } else {
193        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1); }
194    }
195    if (PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;nydailynews.com/blogs/&quot;) || PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;bbc.co.uk/blogs/&quot;)
196      || PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;nydailynews.com/blogs/&quot;) || PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;newsbusters.org/blogs/&quot;)) {
197      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
198    }
199    if (DomNm==&quot;feeds.feedburner.com&quot;) {
200      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
201    }
202    if (DomNm==&quot;groups.google.com&quot;) {
203      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
204    }
205    if (DomNm==&quot;news.google.com&quot;) { 
206      const int UrlPos = PostUrlStr.SearchStr(&quot;&amp;url=&quot;);
207      if (UrlPos != -1) {
208        return GetWebsiteNm(PostUrlStr.GetSubStr(UrlPos+5, PostUrlStr.SearchCh(&#x27;&amp;&#x27;, UrlPos+5))); }
209    }
210    if (DomNm == &quot;bloggrevyen.no&quot;) { 
211      const int Http2 = PostUrlStr.SearchStr(&quot;/http:&amp;bsol;&amp;bsol;&quot;);
212      if (Http2!=-1) {
213        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+1, PostUrlStr.Len()-1)); }
214    }
215    if (DomNm.IsSuffix(&quot;.rd.yahoo.com&quot;)) {
216      const int Http2 = PostUrlStr.SearchStr(&quot;&amp;bsol;*&quot;);
217      if (Http2!=-1) {
218        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+9, PostUrlStr.Len()-1)); }
219    }
220    return DomNm;
221  }
222  bool TStrUtil::GetNormalizedUrl(const TChA&amp; UrlIn, const TChA&amp; BaseUrl, TChA&amp; UrlOut) {
223    UrlOut = UrlIn;
224    if (StripEnd(UrlIn, &quot;/&quot;, UrlOut)) {}
225    else if (StripEnd(UrlIn, &quot;/index.html&quot;, UrlOut)) {}
226    else if (StripEnd(UrlIn, &quot;/index.htm&quot;, UrlOut)) {}
227    else if (StripEnd(UrlIn, &quot;/index.php&quot;, UrlOut)) {}
228    if (! (UrlOut.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;&quot;) || UrlOut.IsPrefix(&quot;ftp:&amp;bsol;&amp;bsol;&quot;))) {
229      if (UrlIn.Empty() || ! (BaseUrl.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;&quot;) || BaseUrl.IsPrefix(&quot;ftp:&amp;bsol;&amp;bsol;&quot;))) {
230        return false; }
231      TChA Out;
232      if (! GetNormalizedUrl(BaseUrl, TChA(), Out)) { return false; }
233      if (UrlIn[0] != &#x27;/&#x27;) { Out.AddCh(&#x27;/&#x27;); }
234      Out += UrlOut;
235      UrlOut = Out;
236    }
237    if (UrlOut.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;www.&quot;)) {
238      UrlOut = TChA(&quot;http:&amp;bsol;&amp;bsol;&quot;) + UrlOut.GetSubStr(11, TInt::Mx);
239    }
240    UrlOut.ToLc();
241    return true;
242  }
243  bool TStrUtil::StripEnd(const TChA&amp; Str, const TChA&amp; SearchStr, TChA&amp; NewStr) {
244    const int StrLen = Str.Len();
245    const int SearchStrLen = SearchStr.Len();
246    if (StrLen &lt; SearchStrLen) { return false; }
247    for (int i = 0; i &lt; SearchStrLen; i++) {
248      if (Str[StrLen-i-1] != SearchStr[SearchStrLen-i-1]) { return false; }
249    }
250    NewStr = Str.GetSubStr(0, StrLen-SearchStrLen-1);
251    return true;
252  }
253  TChA TStrUtil::GetShorStr(const TChA&amp; LongStr, const int MaxLen) {
254    if (LongStr.Len() &lt; MaxLen) { return LongStr; }
255    TChA Str = LongStr.GetSubStr(0, MaxLen-1);
256    Str += &quot;...&quot;;
257    return Str;
258  }
259  TChA TStrUtil::GetCleanWrdStr(const TChA&amp; ChA) {
260    char *b = (char *) ChA.CStr();
261    while (*b &amp;&amp; ! TCh::IsAlNum(*b)) { b++; }
262    if (*b == 0) { return TChA(); }
263    TChA OutChA(ChA.Len());
264    char *e = b, tmp;
265    while (*e) {
266      b = e;
267      while (*e &amp;&amp; (TCh::IsAlNum(*e) || ((*e==&#x27;\&#x27;&#x27; || *e==&#x27;-&#x27;) &amp;&amp; TCh::IsAlNum(*(e+1))))) { e++; }
268      if (b &lt; e) {
269        tmp = *e; *e=0;
270        OutChA += b;  OutChA.AddCh(&#x27; &#x27;);
271        *e = tmp;
272      }
273      while (*e &amp;&amp; ! TCh::IsAlNum(*e)) { e++; }
274      if (! *e) { break; }
275    }
276    OutChA.DelLastCh();  OutChA.ToLc();
277    return OutChA;
278  }
279  TChA TStrUtil::GetCleanStr(const TChA&amp; ChA) {
280    char *b = (char *) ChA.CStr();
281    while (*b &amp;&amp; ! TCh::IsAlNum(*b)) { b++; }
282    if (*b == 0) { return TChA(); }
283    TChA OutChA(ChA.Len());
284    char *e = b;
285    bool ws=false;
286    while (*e) {
287      while (*e &amp;&amp; TCh::IsWs(*e)) { e++; ws=true; }
288      if (! *e) { break; }
289      if (ws) { OutChA.AddCh(&#x27; &#x27;); ws=false; }
290      OutChA.AddCh(*e);
291      e++;
292    }
293    return OutChA;
294  }
295  int TStrUtil::CountWords(const TChA&amp; ChA) {
296    return CountWords(ChA.CStr());
297  }
298  int TStrUtil::CountWords(const char* CStr) {
299    int WrdCnt = 1;
300    for (const char *c = CStr; *c; c++) {
301      if (TCh::IsWs(*c)) { WrdCnt++; }
302    }
303    return WrdCnt;
304  }
305  int TStrUtil::CountWords(const TChA&amp; ChA, const TStrHash&lt;TInt&gt;&amp; StopWordH) {
306    TChA Tmp;
307    TVec&lt;char *&gt; WrdV;
308    SplitWords(Tmp, WrdV);
309    int SWordCnt = 0;
310    for (int w = 0; w &lt; WrdV.Len(); w++) {
311      if (StopWordH.IsKey(WrdV[w])) { SWordCnt++; }
312    }
313    return WrdV.Len() - SWordCnt;
314  }
315  int TStrUtil::SplitWords(TChA&amp; ChA, TVec&lt;char *&gt;&amp; WrdV, const bool&amp; SplitOnWs) {
316    WrdV.Clr(false);
317    WrdV.Add(ChA.CStr());
318    for (char *c = (char *) ChA.CStr(); *c; c++) {
319      if ((SplitOnWs &amp;&amp; *c == &#x27; &#x27;) || (! SplitOnWs &amp;&amp; ! TCh::IsAlNum(*c))) {
320        *c = 0;
321        if (! WrdV.Empty() &amp;&amp; strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
322        WrdV.Add(c+1);
323      }
324    }
325    return WrdV.Len();
326  }
327  int TStrUtil::SplitOnCh(TChA&amp; ChA, TVec&lt;char *&gt;&amp; WrdV, const char&amp; Ch, const bool&amp; SkipEmpty) {
328    WrdV.Clr(false);
329    WrdV.Add(ChA.CStr());
330    for (char *c = (char *) ChA.CStr(); *c; c++) {
331      if (*c == Ch) {
332        *c = 0;
333        if (SkipEmpty &amp;&amp; ! WrdV.Empty() &amp;&amp; strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
334        WrdV.Add(c+1);
335      }
336    }
337    if (SkipEmpty &amp;&amp; ! WrdV.Empty() &amp;&amp; strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
338    return WrdV.Len();
339  }
340  int TStrUtil::SplitLines(TChA&amp; ChA, TVec&lt;char *&gt;&amp; LineV, const bool&amp; SkipEmpty) {
341    LineV.Clr(false);
342    LineV.Add(ChA.CStr());
343    bool IsChs=false;
344    for (char *c = (char *) ChA.CStr(); *c; c++) {
345      if (*c == &#x27;\n&#x27;) {
346        if (c &gt; ChA.CStr() &amp;&amp; *(c-1)==&#x27;\r&#x27;) { *(c-1)=0; } 
347        *c=0;
348        if (SkipEmpty) {
349          if (IsChs) { LineV.Add(c+1); }
350        } else {
351          LineV.Add(c+1);
352        }
353        IsChs=false;
354      } else {
355        IsChs=true;
356      }
357    }
358    return LineV.Len();
359  }
360  int TStrUtil::SplitSentences(TChA&amp; ChA, TVec&lt;char *&gt;&amp; SentenceV) {
361    SentenceV.Clr();
362    const char *B = ChA.CStr();
363    const char *E = B+ChA.Len();
364    char *c = (char *) B;
365    while (*c &amp;&amp; TCh::IsWs(*c)) { c++; }
366    if (*c) { SentenceV.Add(c); } else { return 0; }
367    for (; c &lt; E; c++) {
368      if (c&lt;E &amp;&amp; (*c == &#x27;.&#x27; || *c == &#x27;!&#x27; || *c == &#x27;?&#x27;) &amp;&amp; ! TCh::IsAlNum(*(c+1))) { 
369        if (c&lt;E &amp;&amp; *(c+1)==&#x27;&quot;&#x27;) { *c=&#x27;&quot;&#x27;;  c++; } 
370        if (c&gt;=E) { continue; }
371        *c=0;  c++;
372        char *e = c-1;
373        while (e&gt;B &amp;&amp; *e!=&#x27;&quot;&#x27; &amp;&amp; ! TCh::IsAlNum(*e)) { *e=0; e--; } 
374        while (c&lt;E &amp;&amp; ! (TCh::IsAlNum(*c) || (*c==&#x27;&quot;&#x27; &amp;&amp; TCh::IsAlNum(*(c+1))))) { c++; } 
375        if (c&lt;E) { SentenceV.Add(c); }
376      }
377    }
378    return SentenceV.Len();
379  }
380  void TStrUtil::RemoveHtmlTags(const TChA&amp; HtmlStr, TChA&amp; TextStr) {
381    TextStr.Clr();
382    char *StrB, *StrE;
383    StrB = (char *) HtmlStr.CStr();
384    StrE = (char *) StrB+HtmlStr.Len(); 
385    for (char *e = StrB; e &lt; StrE; ) {
386      char* b = e;
387      while (e&lt;StrE &amp;&amp; *e != &#x27;&lt;&#x27;) { e++; }
388      char tmp=*e;  *e = 0;
389      TextStr+= b; TextStr.AddCh(&#x27; &#x27;);  *e = tmp;
390      if (e &gt;= StrE) { return; }
391      if (e[1]==&#x27;!&#x27; &amp;&amp; e[2]==&#x27;-&#x27; &amp;&amp; e[3]==&#x27;-&#x27;) { 
392        e += 3;
393        while(e&lt;StrE &amp;&amp; !(*(e-2)==&#x27;-&#x27; &amp;&amp; *(e-1)==&#x27;-&#x27; &amp;&amp; *e==&#x27;&gt;&#x27;)) { e++; }
394        e++;  continue;
395      }
396      if (e[1]==&#x27;s&#x27; &amp;&amp; e[2]==&#x27;c&#x27; &amp;&amp; e[3]==&#x27;r&#x27; &amp;&amp; e[4]==&#x27;i&#x27; &amp;&amp; e[5]==&#x27;p&#x27; &amp;&amp; e[6]==&#x27;t&#x27;) {
397        e += 5;
398        while(e&lt;StrE &amp;&amp; !(*(e-6)==&#x27;s&#x27; &amp;&amp; *(e-5)==&#x27;c&#x27; &amp;&amp; *(e-4)==&#x27;r&#x27; &amp;&amp; *(e-3)==&#x27;i&#x27; &amp;&amp; *(e-2)==&#x27;p&#x27; &amp;&amp; *(e-1)==&#x27;t&#x27; &amp;&amp; *e==&#x27;&gt;&#x27;)) { e++; }
399        e++;  continue;
400      }
401      while (e &lt; StrE &amp;&amp; *e != &#x27;&gt;&#x27;) { e++; }
402      if (e&gt;=StrE) { return; }
403      e++;
404    }
405  }
406  bool TStrUtil::IsLatinStr(const TChA&amp; Str, const double&amp; MinAlFrac) {
407    int AlNumCnt=0, ChCnt=0;
408    for (const char *c = Str.CStr(); *c; c++) {
409      if (TCh::IsWs(*c)) { continue; }
410      if (*c &gt; 0 &amp;&amp; TCh::IsAlNum(*c)) { AlNumCnt++; }
411      ChCnt++;
412    }
413    if (double(AlNumCnt)/double(ChCnt) &gt; MinAlFrac) { return true; }
414    return false;
415  }
416  void TStrUtil::GetWIdV(const TStrHash&lt;TInt&gt;&amp; StrH, const char *CStr, TIntV&amp; WIdV) {
417    const int NotWId = -1;
<span onclick='openModal()' class='match'>418    TChA ChA(CStr);
419    TVec&lt;char *&gt; WrdV;
420    TInt WId;
421    TStrUtil::SplitWords(ChA, WrdV);
422    WIdV.Clr(false);
423    for (int w = 0; w &lt; WrdV.Len(); w++) {
424      if (StrH.IsKeyGetDat(WrdV[w], WId)) { WIdV.Add(WId); }
</span>425      else { WIdV.Add(NotWId); }
426    }
427  }
428  void TStrUtil::GetAddWIdV(TStrHash&lt;TInt&gt;&amp; StrH, const char *CStr, TIntV&amp; WIdV) {
429    TChA ChA(CStr);
430    TVec&lt;char *&gt; WrdV;
431    TInt WId;
432    TStrUtil::SplitWords(ChA, WrdV);
433    WIdV.Clr(false);
434    for (int w = 0; w &lt; WrdV.Len(); w++) {
435      WIdV.Add(StrH.AddDatId(WrdV[w]));
436    }
437  }
438  bool TStrUtil::GetTmFromStr(const char* TmStr, TSecTm&amp; Tm) {
439    static TStrV MonthV1, MonthV2;
440    if (MonthV1.Empty()) {
441      TStr(&quot;january|february|march|april|may|june|july|august|september|october|november|december&quot;).SplitOnAllCh(&#x27;|&#x27;, MonthV1);
442      TStr(&quot;jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec&quot;).SplitOnAllCh(&#x27;|&#x27;, MonthV2);
443    }
444    TChA Tmp(TmStr);
445    Tmp.ToLc();
446    TVec&lt;char *&gt; WrdV;
447    const char* End = Tmp.CStr()+Tmp.Len();
448    int Col = -1, Cols=0;
449    for (char *b = Tmp.CStr(); b &lt;End; ) {
450      WrdV.Add(b);
451      while (*b &amp;&amp; ! (*b==&#x27; &#x27; || *b==&#x27;-&#x27; || *b==&#x27;:&#x27; || *b==&#x27;,&#x27;)) { b++; }
452      if (*b==&#x27;:&#x27;) { if(Col==-1) { Col=WrdV.Len(); } Cols++;  }
453      *b=0; b++;
454      while (*b &amp;&amp; (*b==&#x27; &#x27; || *b==&#x27;-&#x27; || *b==&#x27;:&#x27; || *b==&#x27;,&#x27;)) { b++; }
455    }
456    if (Cols == 2) {
457      if (Col+1 &gt;= WrdV.Len()) { return false; }
458      WrdV.Del(Col+1);
459    }
460    if (Col&lt;1) { return false; }
461    const int Hr = atoi(WrdV[Col-1]);
462    const int Min = atoi(WrdV[Col]);
463    WrdV.Del(Col);  WrdV.Del(Col-1);
464    if (WrdV.Len() != 3) { return false; }
465    int y=0,m=1,d=2, Mon=-1;
466    if (TCh::IsAlpha(WrdV[0][0])) {
467      y=2; m=0; d=1;
468    } else if (TCh::IsAlpha(WrdV[1][0])) {
469      y=2; m=1; d=0;
470    } else if (TCh::IsAlpha(WrdV[2][0])) {
471      y=0; m=2; d=1;
472    } else {
473      y=0; m=1; d=2;
474      Mon = atoi(WrdV[m]);
475    }
476    int Day = atoi(WrdV[d]);
477    if (Mon &lt;= 0) { Mon = MonthV1.SearchForw(WrdV[m])+1; }
478    if (Mon &lt;= 0) { Mon = MonthV2.SearchForw(WrdV[m])+1; }
479    if (Mon == 0) { return false; }
480    int Year = atoi(WrdV[y]);
481    if (Day &gt; Year) { ::Swap(Day, Year); }
482    Tm = TSecTm(Year, Mon, Day, Hr, Min, 0);
483    return true;
484  }
485  TStr TStrUtil::GetStdName(TStr AuthorName) {
486    TStr StdName;
487    AuthorName.ToLc();
488    AuthorName.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;);
489    AuthorName.ChangeChAll(&#x27;.&#x27;, &#x27; &#x27;);
490    int i, pos = 0;
491    while (pos&lt;AuthorName.Len() &amp;&amp; (AuthorName[pos]!=&#x27;#&#x27; &amp;&amp; !TCh::IsNum(AuthorName[pos]))) {
492      pos++; }
493    if (pos &lt; AuthorName.Len()) {
494      AuthorName = AuthorName.GetSubStr(0, pos-1).ToTrunc(); }
495    if (AuthorName.Empty()) { return TStr::GetNullStr(); }
496    int b = AuthorName.SearchCh(&#x27;(&#x27;);
497    if (b != -1) {
498      AuthorName = AuthorName.GetSubStr(0, b-1).ToTrunc(); }
499    if (AuthorName .SearchCh(&#x27;)&#x27;)!=-1) { return TStr::GetNullStr(); }
500    if (AuthorName .SearchStr(&quot;figures&quot;)!=-1 || AuthorName .SearchStr(&quot;macros&quot;)!=-1
501     || AuthorName .SearchStr(&quot;univ&quot;)!=-1 || AuthorName .SearchStr(&quot;institute&quot;)!=-1) {
502      return TStr::GetNullStr();
503    }
504    TChA NewName;
505    for (i = 0; i &lt; AuthorName.Len(); i++) {
506      const char Ch = AuthorName[i];
507      if (TCh::IsAlpha(Ch) || TCh::IsWs(Ch) || Ch==&#x27;-&#x27;) { NewName += Ch; }
508    }
509    StdName = NewName;  StdName.ToTrunc();
510    TStrV AuthNmV; StdName.SplitOnWs(AuthNmV);
511    if (! AuthNmV.Empty() &amp;&amp; AuthNmV.Last() == &quot;jr&quot;) AuthNmV.DelLast();
512    if (AuthNmV.Len() &lt; 2) return TStr::GetNullStr();
513    const TStr LastNm = AuthNmV.Last();
514    if (! TCh::IsAlpha(LastNm[0]) || LastNm.Len() == 1) return TStr::GetNullStr();
515    IAssert(isalpha(AuthNmV[0][0]));
516    return TStr::Fmt(&quot;%s_%c&quot;, LastNm.CStr(), AuthNmV[0][0]);
517  }
518  void TStrUtil::GetStdNameV(TStr AuthorNames, TStrV&amp; StdNameV) {
519    AuthorNames.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;);
520    AuthorNames.ToLc();
521    TStrV AuthV, TmpV, Tmp2V;
522    AuthorNames.SplitOnStr(&quot; and &quot;, TmpV);
523    int i;
524    for (i = 0; i &lt; TmpV.Len(); i++) {
525      TmpV[i].SplitOnAllCh(&#x27;,&#x27;, Tmp2V);  AuthV.AddV(Tmp2V); }
526    TmpV = AuthV;  AuthV.Clr();
527    for (i = 0; i &lt; TmpV.Len(); i++) {
528      TmpV[i].SplitOnAllCh(&#x27;&amp;&#x27;, Tmp2V);  AuthV.AddV(Tmp2V); }
529    TmpV = AuthV;  AuthV.Clr();
530    for (i = 0; i &lt; TmpV.Len(); i++) {
531      TmpV[i].SplitOnAllCh(&#x27;,&#x27;, Tmp2V);  AuthV.AddV(Tmp2V); }
532    TmpV = AuthV;  AuthV.Clr();
533    for (i = 0; i &lt; TmpV.Len(); i++) {
534      TmpV[i].SplitOnAllCh(&#x27;;&#x27;, Tmp2V);  AuthV.AddV(Tmp2V); }
535    StdNameV.Clr();
536    for (i = 0; i &lt; AuthV.Len(); i++) {
537      TStr StdName = GetStdName(AuthV[i]);
538      if (! StdName.Empty()) {
539        StdNameV.Add(StdName);
540      }
541    }
542  }
543  double TStopwatch::Tick() {
544  #ifdef USE_OPENMP
545    return omp_get_wtime();
546  #else
547  #ifdef GLib_WIN32
548    return GetTickCount() / 1000.0;
549  #else
550    struct rusage rusage;
551    getrusage(RUSAGE_SELF, &amp;rusage);
552    float cputime =
553    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
554    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
555    return cputime;
556  #endif
557  #endif
558  }
559  void TStopwatch::Start(const TExperiment Exp) {
560    Starts[Exp] = Tick();
561  }
562  void TStopwatch::Stop(const TExperiment Exp) {
563    double Duration = Tick() - Starts[Exp];
564    Sums[Exp] += Duration;
565    Maxs[Exp] = Maxs[Exp] &gt;= Duration ? Maxs[Exp] : Duration;
566    Mins[Exp] = Mins[Exp] &lt;= Duration ? Mins[Exp] : Duration;
567    Cnts[Exp]++;
568  }
569  int TStopwatch::Cnt(const TExperiment Exp) const {
570    return Cnts[Exp];
571  }
572  double TStopwatch::Sum(const TExperiment Exp) const {
573    return Sums[Exp];
574  }
575  double TStopwatch::Avg(const TExperiment Exp) const {
576    return Sums[Exp] / Cnts[Exp];
577  }
578  double TStopwatch::Max(const TExperiment Exp) const {
579    return Maxs[Exp];
580  }
581  double TStopwatch::Min(const TExperiment Exp) const {
582    return Mins[Exp];
583  }
584  #if defined(SW_WRITEN)
585  int WriteN(int fd, char *ptr, int nbytes) {
586    int nleft;
587    int nwritten;
588    nleft = nbytes;
589    while (nleft &gt; 0) {
590      nwritten = (int) write(fd, ptr, nleft);
591      if (nwritten &lt;= 0) {
592        return nwritten;
593      }
594      nleft -= nwritten;
595      ptr += nwritten;
596    }
597    return (nbytes-nleft);
598  }
599  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</h3>
            <pre><code>1  void TGUtil::GetCdf(const TIntPrV&amp; PdfV, TIntPrV&amp; CdfV) {
2    CdfV = PdfV;
3    for (int i = 1; i &lt; CdfV.Len(); i++) {
4      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
5  }
6  void TGUtil::GetCdf(const TFltPrV&amp; PdfV, TFltPrV&amp; CdfV) {
7    CdfV = PdfV;
8    for (int i = 1; i &lt; CdfV.Len(); i++) {
9      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
10  }
11  void TGUtil::GetCdf(const TIntFltKdV&amp; PdfV, TIntFltKdV&amp; CdfV) {
12    CdfV = PdfV;
13    for (int i = 1; i &lt; CdfV.Len(); i++) {
14      CdfV[i].Dat = CdfV[i-1].Dat + CdfV[i].Dat; }
15  }
16  TIntPrV TGUtil::GetCdf(const TIntPrV&amp; PdfV) {
17    TIntPrV CdfV;
18    GetCdf(PdfV, CdfV);
19    return CdfV;
20  }
21  TFltPrV TGUtil::GetCdf(const TFltPrV&amp; PdfV) {
22    TFltPrV CdfV;
23    GetCdf(PdfV, CdfV);
24    return CdfV;
25  }
26  void TGUtil::GetCCdf(const TIntPrV&amp; PdfV, TIntPrV&amp; CCdfV) {
27    CCdfV = PdfV;
28    for (int i = CCdfV.Len()-2; i &gt;= 0; i--) {
29      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
30  }
31  void TGUtil::GetCCdf(const TFltPrV&amp; PdfV, TFltPrV&amp; CCdfV) {
32    CCdfV = PdfV;
33    for (int i = CCdfV.Len()-2; i &gt;= 0; i--) {
34      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
35  }
36  void TGUtil::GetCCdf(const TIntFltKdV&amp; PdfV, TIntFltKdV&amp; CCdfV) {
37    CCdfV = PdfV;
38    for (int i = CCdfV.Len()-2; i &gt;= 0; i--) {
39      CCdfV[i].Dat = CCdfV[i+1].Dat + CCdfV[i].Dat; }
40  }
41  TIntPrV TGUtil::GetCCdf(const TIntPrV&amp; PdfV) {
42    TIntPrV CCdfV;
43    GetCCdf(PdfV, CCdfV);
44    return CCdfV;
45  }
46  TFltPrV TGUtil::GetCCdf(const TFltPrV&amp; PdfV) {
47    TFltPrV CCdfV;
48    GetCCdf(PdfV, CCdfV);
49    return CCdfV;
50  }
51  void TGUtil::GetPdf(const TIntPrV&amp; CdfV, TIntPrV&amp; PdfV) {
52    PdfV = CdfV;
53    for (int i = PdfV.Len()-1; i &gt; 0; i--) {
54      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
55  }
56  void TGUtil::GetPdf(const TFltPrV&amp; CdfV, TFltPrV&amp; PdfV) {
57    PdfV = CdfV;
58    for (int i = PdfV.Len()-1; i &gt; 0; i--) {
59      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
60  }
61  void TGUtil::GetPdf(const TIntFltKdV&amp; CdfV, TIntFltKdV&amp; PdfV) {
62    PdfV = CdfV;
63    for (int i = PdfV.Len()-1; i &gt; 0; i--) {
64      PdfV[i].Dat = PdfV[i].Dat - PdfV[i-1].Dat; }
65  }
66  void TGUtil::Normalize(TFltPrV&amp; PdfV) {
67    double Sum = 0.0;
68    for (int i = 0; i &lt; PdfV.Len(); i++) {
69      Sum += PdfV[i].Val2; }
70    if (Sum &lt;= 0.0) { return; }
71    for (int i = 0; i &lt; PdfV.Len(); i++) {
72      PdfV[i].Val2 /= Sum; }
73  }
74  void TGUtil::Normalize(TIntFltKdV&amp; PdfV) {
75    double Sum = 0.0;
76    for (int i = 0; i &lt; PdfV.Len(); i++) {
77      Sum += PdfV[i].Dat; }
78    if (Sum &lt;= 0.0) { return; }
79    for (int i = 0; i &lt; PdfV.Len(); i++) {
80      PdfV[i].Dat /= Sum; }
81  }
82  void TGUtil::MakeExpBins(const TFltPrV&amp; XYValV, TFltPrV&amp; ExpXYValV, const double&amp; BinFactor, const double&amp; MinYVal) {
83    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
84  }
85  void TGUtil::MakeExpBins(const TFltKdV&amp; XYValV, TFltKdV&amp; ExpXYValV, const double&amp; BinFactor, const double&amp; MinYVal) {
86    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
87  }
88  void TGUtil::MakeExpBins(const TFltV&amp; YValV, TFltV&amp; ExpYValV, const double&amp; BinFactor) {
89    ExpYValV.Clr(true);
90    int prevI=0;
91    for (int i = 0; i &lt; YValV.Len(); ) {
92      ExpYValV.Add(YValV[i]);
93      i = int(i*BinFactor);
94      if (i==prevI) { i++; }
95      prevI = i;
96    }
97  }
98  void TGUtil::MakeExpBins(const TIntV&amp; YValV, TIntV&amp; ExpYValV, const double&amp; BinFactor) {
99    ExpYValV.Clr(true);
100    int prevI=0;
101    for (int i = 0; i &lt; YValV.Len(); ) {
102      ExpYValV.Add(YValV[i]);
103      i = int(i*BinFactor);
104      if (i==prevI) { i++; }
105      prevI = i;
106    }
107  }
108  TChA&amp; TStrUtil::GetXmlTagVal(TXmlLx&amp; XmlLx, const TChA&amp; TagNm) {
109    static TChA TagVal;
110    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
111    EAssertR(TagNm == XmlLx.TagNm.CStr(), TagNm);
112    const TXmlLxSym NextSym = XmlLx.GetSym();
113    TagVal = XmlLx.TxtChA;
114    if (NextSym == xsyStr) {
115      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
116    } else {
117      EAssertR(NextSym == xsyETag, TagNm); 
118    }
119    EAssertR(XmlLx.TagNm == TagNm, TagNm);
120    return TagVal;
121  }
122  void TStrUtil::GetXmlTagNmVal(TXmlLx&amp; XmlLx, TChA&amp; TagNm, TChA&amp; TagVal) {
123    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
124    TagNm = XmlLx.TagNm;
125    const TXmlLxSym NextSym = XmlLx.GetSym();
126    TagVal = XmlLx.TxtChA;
127    if (NextSym == xsyStr) {
128      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
129    } else {
130      EAssertR(NextSym == xsyETag, TagNm); 
131    }
132  }
133  bool TStrUtil::GetXmlTagNmVal2(TXmlLx&amp; XmlLx, TChA&amp; TagNm, TChA&amp; TagVal, const bool&amp; TakeTagNms) {
134    if (XmlLx.GetSym() != xsySTag) {
135      return false; }
136    TagVal.Clr();
137    TagNm = XmlLx.TagNm;
138    while (XmlLx.Sym != xsyETag || XmlLx.TagNm != TagNm.CStr()) {
139      if (TakeTagNms) {
140        TagVal += XmlLx.TxtChA; }
141      else if (XmlLx.Sym == xsyStr) {
142        TagVal += XmlLx.TxtChA; }
143      XmlLx.GetSym();
144    }
145    return true;
146  }
147  TChA TStrUtil::GetDomNm(const TChA&amp; UrlChA) {
148    int EndSlash = UrlChA.SearchCh(&#x27;/&#x27;, 7)-1; 
149    if (EndSlash &gt; 0) {
150      const int BegSlash = UrlChA.SearchChBack(&#x27;/&#x27;, EndSlash);
151      if (BegSlash &gt; 0) { return UrlChA.GetSubStr(BegSlash+1, EndSlash).ToLc(); }
152      else { return UrlChA.GetSubStr(0, UrlChA.SearchCh(&#x27;/&#x27;, 0)-1).ToLc(); }
153    } else {
154      if (UrlChA.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;&quot;)) { return UrlChA.GetSubStr(7, UrlChA.Len()-1).ToLc(); }
155      EndSlash = UrlChA.SearchCh(&#x27;/&#x27;, 0);
156      if (EndSlash &gt; 0) { return UrlChA.GetSubStr(0, EndSlash-1).ToLc(); }
157      else { return TChA(UrlChA).ToLc(); }
158    }
159  }
160  TChA TStrUtil::GetDomNm2(const TChA&amp; UrlChA) {
161    TChA Dom = GetDomNm(UrlChA);
162    if (Dom.IsPrefix(&quot;www.&quot;)) { return Dom.GetSubStr(4, TInt::Mx); }
163    else { return Dom; }
164  }
165  int GetNthOccurence(const TChA&amp; Url, const int&amp; Count, const char Ch=&#x27;/&#x27;) {
166    const char *c = Url.CStr();
167    int cnt = 0;
168    while (*c &amp;&amp; cnt != Count) {
169      if (*c == Ch) { cnt++; }
170      c++;
171    }
172    return int(c-Url.CStr()-1);
173  }
174  TChA TStrUtil::GetWebsiteNm(const TChA&amp; PostUrlStr) {
175    TChA DomNm = TStrUtil::GetDomNm2(PostUrlStr);
176    if (DomNm == &quot;blog.myspace.com&quot;) {
177      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 2, &#x27;&amp;&#x27;)-1);
178    }
179    if (DomNm==&quot;blogs.msdn.com&quot; || DomNm==&quot;ameblo.jp&quot; || DomNm==&quot;xfruits.com&quot; || DomNm==&quot;scienceblogs.com&quot; || DomNm==&quot;blogs.sun.com&quot;
180      || DomNm==&quot;blog.wired.com&quot; || DomNm==&quot;weblogs.asp.net&quot; || DomNm==&quot;blogs.technet.com&quot; || DomNm==&quot;blogs.guardian.co&quot;
181      || DomNm==&quot;blogs.clarin.com&quot; || DomNm==&quot;blogs.sun.com&quot; || DomNm==&quot;blog.wired.com&quot; || DomNm==&quot;weblogs.asp.net&quot;
182      || DomNm==&quot;blogs.technet.com&quot; || DomNm==&quot;blogs.guardian.com&quot; || DomNm==&quot;blogs.clarin.com&quot; || DomNm==&quot;blogs.zdnet.com&quot;
183      || DomNm==&quot;blogs.citypages.com&quot; || DomNm==&quot;voices.washingtonpost.com&quot; || DomNm==&quot;blog.tv2.dk&quot;
184      || DomNm==&quot;blogs.menomoneefallsnow.com&quot; || DomNm==&quot;weblogs.baltimoresun.com&quot; || DomNm==&quot;eonline.com&quot;) {
185        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1);
186    }
187    if (DomNm == &quot;digg.com&quot;) {
188      if (PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;digg.com/submit?&quot;)) {
189        const int Url = PostUrlStr.SearchStr(&quot;;url=&quot;);
190        if (Url != -1) {
191          return GetWebsiteNm(PostUrlStr.GetSubStr(Url+5, PostUrlStr.SearchCh(&#x27;&amp;&#x27;, Url+5))); }
192      } else {
193        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1); }
194    }
195    if (PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;nydailynews.com/blogs/&quot;) || PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;bbc.co.uk/blogs/&quot;)
196      || PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;nydailynews.com/blogs/&quot;) || PostUrlStr.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;newsbusters.org/blogs/&quot;)) {
197      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
198    }
199    if (DomNm==&quot;feeds.feedburner.com&quot;) {
200      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
201    }
202    if (DomNm==&quot;groups.google.com&quot;) {
203      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
204    }
205    if (DomNm==&quot;news.google.com&quot;) { 
206      const int UrlPos = PostUrlStr.SearchStr(&quot;&amp;url=&quot;);
207      if (UrlPos != -1) {
208        return GetWebsiteNm(PostUrlStr.GetSubStr(UrlPos+5, PostUrlStr.SearchCh(&#x27;&amp;&#x27;, UrlPos+5))); }
209    }
210    if (DomNm == &quot;bloggrevyen.no&quot;) { 
211      const int Http2 = PostUrlStr.SearchStr(&quot;/http:&amp;bsol;&amp;bsol;&quot;);
212      if (Http2!=-1) {
213        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+1, PostUrlStr.Len()-1)); }
214    }
215    if (DomNm.IsSuffix(&quot;.rd.yahoo.com&quot;)) {
216      const int Http2 = PostUrlStr.SearchStr(&quot;&amp;bsol;*&quot;);
217      if (Http2!=-1) {
218        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+9, PostUrlStr.Len()-1)); }
219    }
220    return DomNm;
221  }
222  bool TStrUtil::GetNormalizedUrl(const TChA&amp; UrlIn, const TChA&amp; BaseUrl, TChA&amp; UrlOut) {
223    UrlOut = UrlIn;
224    if (StripEnd(UrlIn, &quot;/&quot;, UrlOut)) {}
225    else if (StripEnd(UrlIn, &quot;/index.html&quot;, UrlOut)) {}
226    else if (StripEnd(UrlIn, &quot;/index.htm&quot;, UrlOut)) {}
227    else if (StripEnd(UrlIn, &quot;/index.php&quot;, UrlOut)) {}
228    if (! (UrlOut.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;&quot;) || UrlOut.IsPrefix(&quot;ftp:&amp;bsol;&amp;bsol;&quot;))) {
229      if (UrlIn.Empty() || ! (BaseUrl.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;&quot;) || BaseUrl.IsPrefix(&quot;ftp:&amp;bsol;&amp;bsol;&quot;))) {
230        return false; }
231      TChA Out;
232      if (! GetNormalizedUrl(BaseUrl, TChA(), Out)) { return false; }
233      if (UrlIn[0] != &#x27;/&#x27;) { Out.AddCh(&#x27;/&#x27;); }
234      Out += UrlOut;
235      UrlOut = Out;
236    }
237    if (UrlOut.IsPrefix(&quot;http:&amp;bsol;&amp;bsol;www.&quot;)) {
238      UrlOut = TChA(&quot;http:&amp;bsol;&amp;bsol;&quot;) + UrlOut.GetSubStr(11, TInt::Mx);
239    }
240    UrlOut.ToLc();
241    return true;
242  }
243  bool TStrUtil::StripEnd(const TChA&amp; Str, const TChA&amp; SearchStr, TChA&amp; NewStr) {
244    const int StrLen = Str.Len();
245    const int SearchStrLen = SearchStr.Len();
246    if (StrLen &lt; SearchStrLen) { return false; }
247    for (int i = 0; i &lt; SearchStrLen; i++) {
248      if (Str[StrLen-i-1] != SearchStr[SearchStrLen-i-1]) { return false; }
249    }
250    NewStr = Str.GetSubStr(0, StrLen-SearchStrLen-1);
251    return true;
252  }
253  TChA TStrUtil::GetShorStr(const TChA&amp; LongStr, const int MaxLen) {
254    if (LongStr.Len() &lt; MaxLen) { return LongStr; }
255    TChA Str = LongStr.GetSubStr(0, MaxLen-1);
256    Str += &quot;...&quot;;
257    return Str;
258  }
259  TChA TStrUtil::GetCleanWrdStr(const TChA&amp; ChA) {
260    char *b = (char *) ChA.CStr();
261    while (*b &amp;&amp; ! TCh::IsAlNum(*b)) { b++; }
262    if (*b == 0) { return TChA(); }
263    TChA OutChA(ChA.Len());
264    char *e = b, tmp;
265    while (*e) {
266      b = e;
267      while (*e &amp;&amp; (TCh::IsAlNum(*e) || ((*e==&#x27;\&#x27;&#x27; || *e==&#x27;-&#x27;) &amp;&amp; TCh::IsAlNum(*(e+1))))) { e++; }
268      if (b &lt; e) {
269        tmp = *e; *e=0;
270        OutChA += b;  OutChA.AddCh(&#x27; &#x27;);
271        *e = tmp;
272      }
273      while (*e &amp;&amp; ! TCh::IsAlNum(*e)) { e++; }
274      if (! *e) { break; }
275    }
276    OutChA.DelLastCh();  OutChA.ToLc();
277    return OutChA;
278  }
279  TChA TStrUtil::GetCleanStr(const TChA&amp; ChA) {
280    char *b = (char *) ChA.CStr();
281    while (*b &amp;&amp; ! TCh::IsAlNum(*b)) { b++; }
282    if (*b == 0) { return TChA(); }
283    TChA OutChA(ChA.Len());
284    char *e = b;
285    bool ws=false;
286    while (*e) {
287      while (*e &amp;&amp; TCh::IsWs(*e)) { e++; ws=true; }
288      if (! *e) { break; }
289      if (ws) { OutChA.AddCh(&#x27; &#x27;); ws=false; }
290      OutChA.AddCh(*e);
291      e++;
292    }
293    return OutChA;
294  }
295  int TStrUtil::CountWords(const TChA&amp; ChA) {
296    return CountWords(ChA.CStr());
297  }
298  int TStrUtil::CountWords(const char* CStr) {
299    int WrdCnt = 1;
300    for (const char *c = CStr; *c; c++) {
301      if (TCh::IsWs(*c)) { WrdCnt++; }
302    }
303    return WrdCnt;
304  }
305  int TStrUtil::CountWords(const TChA&amp; ChA, const TStrHash&lt;TInt&gt;&amp; StopWordH) {
306    TChA Tmp;
307    TVec&lt;char *&gt; WrdV;
308    SplitWords(Tmp, WrdV);
309    int SWordCnt = 0;
310    for (int w = 0; w &lt; WrdV.Len(); w++) {
311      if (StopWordH.IsKey(WrdV[w])) { SWordCnt++; }
312    }
313    return WrdV.Len() - SWordCnt;
314  }
315  int TStrUtil::SplitWords(TChA&amp; ChA, TVec&lt;char *&gt;&amp; WrdV, const bool&amp; SplitOnWs) {
316    WrdV.Clr(false);
317    WrdV.Add(ChA.CStr());
318    for (char *c = (char *) ChA.CStr(); *c; c++) {
319      if ((SplitOnWs &amp;&amp; *c == &#x27; &#x27;) || (! SplitOnWs &amp;&amp; ! TCh::IsAlNum(*c))) {
320        *c = 0;
321        if (! WrdV.Empty() &amp;&amp; strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
322        WrdV.Add(c+1);
323      }
324    }
325    return WrdV.Len();
326  }
327  int TStrUtil::SplitOnCh(TChA&amp; ChA, TVec&lt;char *&gt;&amp; WrdV, const char&amp; Ch, const bool&amp; SkipEmpty) {
328    WrdV.Clr(false);
329    WrdV.Add(ChA.CStr());
330    for (char *c = (char *) ChA.CStr(); *c; c++) {
331      if (*c == Ch) {
332        *c = 0;
333        if (SkipEmpty &amp;&amp; ! WrdV.Empty() &amp;&amp; strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
334        WrdV.Add(c+1);
335      }
336    }
337    if (SkipEmpty &amp;&amp; ! WrdV.Empty() &amp;&amp; strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
338    return WrdV.Len();
339  }
340  int TStrUtil::SplitLines(TChA&amp; ChA, TVec&lt;char *&gt;&amp; LineV, const bool&amp; SkipEmpty) {
341    LineV.Clr(false);
342    LineV.Add(ChA.CStr());
343    bool IsChs=false;
344    for (char *c = (char *) ChA.CStr(); *c; c++) {
345      if (*c == &#x27;\n&#x27;) {
346        if (c &gt; ChA.CStr() &amp;&amp; *(c-1)==&#x27;\r&#x27;) { *(c-1)=0; } 
347        *c=0;
348        if (SkipEmpty) {
349          if (IsChs) { LineV.Add(c+1); }
350        } else {
351          LineV.Add(c+1);
352        }
353        IsChs=false;
354      } else {
355        IsChs=true;
356      }
357    }
358    return LineV.Len();
359  }
360  int TStrUtil::SplitSentences(TChA&amp; ChA, TVec&lt;char *&gt;&amp; SentenceV) {
361    SentenceV.Clr();
362    const char *B = ChA.CStr();
363    const char *E = B+ChA.Len();
364    char *c = (char *) B;
365    while (*c &amp;&amp; TCh::IsWs(*c)) { c++; }
366    if (*c) { SentenceV.Add(c); } else { return 0; }
367    for (; c &lt; E; c++) {
368      if (c&lt;E &amp;&amp; (*c == &#x27;.&#x27; || *c == &#x27;!&#x27; || *c == &#x27;?&#x27;) &amp;&amp; ! TCh::IsAlNum(*(c+1))) { 
369        if (c&lt;E &amp;&amp; *(c+1)==&#x27;&quot;&#x27;) { *c=&#x27;&quot;&#x27;;  c++; } 
370        if (c&gt;=E) { continue; }
371        *c=0;  c++;
372        char *e = c-1;
373        while (e&gt;B &amp;&amp; *e!=&#x27;&quot;&#x27; &amp;&amp; ! TCh::IsAlNum(*e)) { *e=0; e--; } 
374        while (c&lt;E &amp;&amp; ! (TCh::IsAlNum(*c) || (*c==&#x27;&quot;&#x27; &amp;&amp; TCh::IsAlNum(*(c+1))))) { c++; } 
375        if (c&lt;E) { SentenceV.Add(c); }
376      }
377    }
378    return SentenceV.Len();
379  }
380  void TStrUtil::RemoveHtmlTags(const TChA&amp; HtmlStr, TChA&amp; TextStr) {
381    TextStr.Clr();
382    char *StrB, *StrE;
383    StrB = (char *) HtmlStr.CStr();
384    StrE = (char *) StrB+HtmlStr.Len(); 
385    for (char *e = StrB; e &lt; StrE; ) {
386      char* b = e;
387      while (e&lt;StrE &amp;&amp; *e != &#x27;&lt;&#x27;) { e++; }
388      char tmp=*e;  *e = 0;
389      TextStr+= b; TextStr.AddCh(&#x27; &#x27;);  *e = tmp;
390      if (e &gt;= StrE) { return; }
391      if (e[1]==&#x27;!&#x27; &amp;&amp; e[2]==&#x27;-&#x27; &amp;&amp; e[3]==&#x27;-&#x27;) { 
392        e += 3;
393        while(e&lt;StrE &amp;&amp; !(*(e-2)==&#x27;-&#x27; &amp;&amp; *(e-1)==&#x27;-&#x27; &amp;&amp; *e==&#x27;&gt;&#x27;)) { e++; }
394        e++;  continue;
395      }
396      if (e[1]==&#x27;s&#x27; &amp;&amp; e[2]==&#x27;c&#x27; &amp;&amp; e[3]==&#x27;r&#x27; &amp;&amp; e[4]==&#x27;i&#x27; &amp;&amp; e[5]==&#x27;p&#x27; &amp;&amp; e[6]==&#x27;t&#x27;) {
397        e += 5;
398        while(e&lt;StrE &amp;&amp; !(*(e-6)==&#x27;s&#x27; &amp;&amp; *(e-5)==&#x27;c&#x27; &amp;&amp; *(e-4)==&#x27;r&#x27; &amp;&amp; *(e-3)==&#x27;i&#x27; &amp;&amp; *(e-2)==&#x27;p&#x27; &amp;&amp; *(e-1)==&#x27;t&#x27; &amp;&amp; *e==&#x27;&gt;&#x27;)) { e++; }
399        e++;  continue;
400      }
401      while (e &lt; StrE &amp;&amp; *e != &#x27;&gt;&#x27;) { e++; }
402      if (e&gt;=StrE) { return; }
403      e++;
404    }
405  }
406  bool TStrUtil::IsLatinStr(const TChA&amp; Str, const double&amp; MinAlFrac) {
407    int AlNumCnt=0, ChCnt=0;
408    for (const char *c = Str.CStr(); *c; c++) {
409      if (TCh::IsWs(*c)) { continue; }
410      if (*c &gt; 0 &amp;&amp; TCh::IsAlNum(*c)) { AlNumCnt++; }
411      ChCnt++;
412    }
413    if (double(AlNumCnt)/double(ChCnt) &gt; MinAlFrac) { return true; }
414    return false;
415  }
416  void TStrUtil::GetWIdV(const TStrHash&lt;TInt&gt;&amp; StrH, const char *CStr, TIntV&amp; WIdV) {
417    const int NotWId = -1;
418    TChA ChA(CStr);
419    TVec&lt;char *&gt; WrdV;
420    TInt WId;
421    TStrUtil::SplitWords(ChA, WrdV);
422    WIdV.Clr(false);
423    for (int w = 0; w &lt; WrdV.Len(); w++) {
424      if (StrH.IsKeyGetDat(WrdV[w], WId)) { WIdV.Add(WId); }
425      else { WIdV.Add(NotWId); }
426    }
427  }
428  void TStrUtil::GetAddWIdV(TStrHash&lt;TInt&gt;&amp; StrH, const char *CStr, TIntV&amp; WIdV) {
<span onclick='openModal()' class='match'>429    TChA ChA(CStr);
430    TVec&lt;char *&gt; WrdV;
431    TInt WId;
432    TStrUtil::SplitWords(ChA, WrdV);
433    WIdV.Clr(false);
434    for (int w = 0; w &lt; WrdV.Len(); w++) {
435      WIdV.Add(StrH.AddDatId(WrdV[w]));
</span>436    }
437  }
438  bool TStrUtil::GetTmFromStr(const char* TmStr, TSecTm&amp; Tm) {
439    static TStrV MonthV1, MonthV2;
440    if (MonthV1.Empty()) {
441      TStr(&quot;january|february|march|april|may|june|july|august|september|october|november|december&quot;).SplitOnAllCh(&#x27;|&#x27;, MonthV1);
442      TStr(&quot;jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec&quot;).SplitOnAllCh(&#x27;|&#x27;, MonthV2);
443    }
444    TChA Tmp(TmStr);
445    Tmp.ToLc();
446    TVec&lt;char *&gt; WrdV;
447    const char* End = Tmp.CStr()+Tmp.Len();
448    int Col = -1, Cols=0;
449    for (char *b = Tmp.CStr(); b &lt;End; ) {
450      WrdV.Add(b);
451      while (*b &amp;&amp; ! (*b==&#x27; &#x27; || *b==&#x27;-&#x27; || *b==&#x27;:&#x27; || *b==&#x27;,&#x27;)) { b++; }
452      if (*b==&#x27;:&#x27;) { if(Col==-1) { Col=WrdV.Len(); } Cols++;  }
453      *b=0; b++;
454      while (*b &amp;&amp; (*b==&#x27; &#x27; || *b==&#x27;-&#x27; || *b==&#x27;:&#x27; || *b==&#x27;,&#x27;)) { b++; }
455    }
456    if (Cols == 2) {
457      if (Col+1 &gt;= WrdV.Len()) { return false; }
458      WrdV.Del(Col+1);
459    }
460    if (Col&lt;1) { return false; }
461    const int Hr = atoi(WrdV[Col-1]);
462    const int Min = atoi(WrdV[Col]);
463    WrdV.Del(Col);  WrdV.Del(Col-1);
464    if (WrdV.Len() != 3) { return false; }
465    int y=0,m=1,d=2, Mon=-1;
466    if (TCh::IsAlpha(WrdV[0][0])) {
467      y=2; m=0; d=1;
468    } else if (TCh::IsAlpha(WrdV[1][0])) {
469      y=2; m=1; d=0;
470    } else if (TCh::IsAlpha(WrdV[2][0])) {
471      y=0; m=2; d=1;
472    } else {
473      y=0; m=1; d=2;
474      Mon = atoi(WrdV[m]);
475    }
476    int Day = atoi(WrdV[d]);
477    if (Mon &lt;= 0) { Mon = MonthV1.SearchForw(WrdV[m])+1; }
478    if (Mon &lt;= 0) { Mon = MonthV2.SearchForw(WrdV[m])+1; }
479    if (Mon == 0) { return false; }
480    int Year = atoi(WrdV[y]);
481    if (Day &gt; Year) { ::Swap(Day, Year); }
482    Tm = TSecTm(Year, Mon, Day, Hr, Min, 0);
483    return true;
484  }
485  TStr TStrUtil::GetStdName(TStr AuthorName) {
486    TStr StdName;
487    AuthorName.ToLc();
488    AuthorName.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;);
489    AuthorName.ChangeChAll(&#x27;.&#x27;, &#x27; &#x27;);
490    int i, pos = 0;
491    while (pos&lt;AuthorName.Len() &amp;&amp; (AuthorName[pos]!=&#x27;#&#x27; &amp;&amp; !TCh::IsNum(AuthorName[pos]))) {
492      pos++; }
493    if (pos &lt; AuthorName.Len()) {
494      AuthorName = AuthorName.GetSubStr(0, pos-1).ToTrunc(); }
495    if (AuthorName.Empty()) { return TStr::GetNullStr(); }
496    int b = AuthorName.SearchCh(&#x27;(&#x27;);
497    if (b != -1) {
498      AuthorName = AuthorName.GetSubStr(0, b-1).ToTrunc(); }
499    if (AuthorName .SearchCh(&#x27;)&#x27;)!=-1) { return TStr::GetNullStr(); }
500    if (AuthorName .SearchStr(&quot;figures&quot;)!=-1 || AuthorName .SearchStr(&quot;macros&quot;)!=-1
501     || AuthorName .SearchStr(&quot;univ&quot;)!=-1 || AuthorName .SearchStr(&quot;institute&quot;)!=-1) {
502      return TStr::GetNullStr();
503    }
504    TChA NewName;
505    for (i = 0; i &lt; AuthorName.Len(); i++) {
506      const char Ch = AuthorName[i];
507      if (TCh::IsAlpha(Ch) || TCh::IsWs(Ch) || Ch==&#x27;-&#x27;) { NewName += Ch; }
508    }
509    StdName = NewName;  StdName.ToTrunc();
510    TStrV AuthNmV; StdName.SplitOnWs(AuthNmV);
511    if (! AuthNmV.Empty() &amp;&amp; AuthNmV.Last() == &quot;jr&quot;) AuthNmV.DelLast();
512    if (AuthNmV.Len() &lt; 2) return TStr::GetNullStr();
513    const TStr LastNm = AuthNmV.Last();
514    if (! TCh::IsAlpha(LastNm[0]) || LastNm.Len() == 1) return TStr::GetNullStr();
515    IAssert(isalpha(AuthNmV[0][0]));
516    return TStr::Fmt(&quot;%s_%c&quot;, LastNm.CStr(), AuthNmV[0][0]);
517  }
518  void TStrUtil::GetStdNameV(TStr AuthorNames, TStrV&amp; StdNameV) {
519    AuthorNames.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;);
520    AuthorNames.ToLc();
521    TStrV AuthV, TmpV, Tmp2V;
522    AuthorNames.SplitOnStr(&quot; and &quot;, TmpV);
523    int i;
524    for (i = 0; i &lt; TmpV.Len(); i++) {
525      TmpV[i].SplitOnAllCh(&#x27;,&#x27;, Tmp2V);  AuthV.AddV(Tmp2V); }
526    TmpV = AuthV;  AuthV.Clr();
527    for (i = 0; i &lt; TmpV.Len(); i++) {
528      TmpV[i].SplitOnAllCh(&#x27;&amp;&#x27;, Tmp2V);  AuthV.AddV(Tmp2V); }
529    TmpV = AuthV;  AuthV.Clr();
530    for (i = 0; i &lt; TmpV.Len(); i++) {
531      TmpV[i].SplitOnAllCh(&#x27;,&#x27;, Tmp2V);  AuthV.AddV(Tmp2V); }
532    TmpV = AuthV;  AuthV.Clr();
533    for (i = 0; i &lt; TmpV.Len(); i++) {
534      TmpV[i].SplitOnAllCh(&#x27;;&#x27;, Tmp2V);  AuthV.AddV(Tmp2V); }
535    StdNameV.Clr();
536    for (i = 0; i &lt; AuthV.Len(); i++) {
537      TStr StdName = GetStdName(AuthV[i]);
538      if (! StdName.Empty()) {
539        StdNameV.Add(StdName);
540      }
541    }
542  }
543  double TStopwatch::Tick() {
544  #ifdef USE_OPENMP
545    return omp_get_wtime();
546  #else
547  #ifdef GLib_WIN32
548    return GetTickCount() / 1000.0;
549  #else
550    struct rusage rusage;
551    getrusage(RUSAGE_SELF, &amp;rusage);
552    float cputime =
553    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
554    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
555    return cputime;
556  #endif
557  #endif
558  }
559  void TStopwatch::Start(const TExperiment Exp) {
560    Starts[Exp] = Tick();
561  }
562  void TStopwatch::Stop(const TExperiment Exp) {
563    double Duration = Tick() - Starts[Exp];
564    Sums[Exp] += Duration;
565    Maxs[Exp] = Maxs[Exp] &gt;= Duration ? Maxs[Exp] : Duration;
566    Mins[Exp] = Mins[Exp] &lt;= Duration ? Mins[Exp] : Duration;
567    Cnts[Exp]++;
568  }
569  int TStopwatch::Cnt(const TExperiment Exp) const {
570    return Cnts[Exp];
571  }
572  double TStopwatch::Sum(const TExperiment Exp) const {
573    return Sums[Exp];
574  }
575  double TStopwatch::Avg(const TExperiment Exp) const {
576    return Sums[Exp] / Cnts[Exp];
577  }
578  double TStopwatch::Max(const TExperiment Exp) const {
579    return Maxs[Exp];
580  }
581  double TStopwatch::Min(const TExperiment Exp) const {
582    return Mins[Exp];
583  }
584  #if defined(SW_WRITEN)
585  int WriteN(int fd, char *ptr, int nbytes) {
586    int nleft;
587    int nwritten;
588    nleft = nbytes;
589    while (nleft &gt; 0) {
590      nwritten = (int) write(fd, ptr, nleft);
591      if (nwritten &lt;= 0) {
592        return nwritten;
593      }
594      nleft -= nwritten;
595      ptr += nwritten;
596    }
597    return (nbytes-nleft);
598  }
599  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</div>
                </div>
                <div class="column column_space"><pre><code>418    TChA ChA(CStr);
419    TVec&lt;char *&gt; WrdV;
420    TInt WId;
421    TStrUtil::SplitWords(ChA, WrdV);
422    WIdV.Clr(false);
423    for (int w = 0; w &lt; WrdV.Len(); w++) {
424      if (StrH.IsKeyGetDat(WrdV[w], WId)) { WIdV.Add(WId); }
</pre></code></div>
                <div class="column column_space"><pre><code>429    TChA ChA(CStr);
430    TVec&lt;char *&gt; WrdV;
431    TInt WId;
432    TStrUtil::SplitWords(ChA, WrdV);
433    WIdV.Clr(false);
434    for (int w = 0; w &lt; WrdV.Len(); w++) {
435      WIdV.Add(StrH.AddDatId(WrdV[w]));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    