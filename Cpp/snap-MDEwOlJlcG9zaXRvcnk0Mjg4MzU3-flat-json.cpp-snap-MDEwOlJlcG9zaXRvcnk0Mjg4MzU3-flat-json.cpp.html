
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-json.cpp</h3>
            <pre><code>1  TJsonVal::TJsonVal(TSIn& SIn):
2    JsonValType((TJsonValType)(TInt(SIn).Val)), Bool(SIn), 
3    Num(SIn), Str(SIn), ValV(SIn), KeyValH(SIn) { }
4  void TJsonVal::Save(TSOut& SOut) const {
5    TInt((int)JsonValType).Save(SOut);
6    Bool.Save(SOut); Num.Save(SOut);
7    Str.Save(SOut); ValV.Save(SOut);
8    KeyValH.Save(SOut);
9  }
10  TStr TJsonVal::SaveStr() { 
11    return GetStrFromVal(this); 
12  }
13  bool TJsonVal::operator==(const TJsonVal& JsonVal) const {
14    return JsonValType == JsonVal.JsonValType &&
15      Bool == JsonVal.Bool &&
16      Num == JsonVal.Num &&
17      Str == JsonVal.Str &&
18      ValV == JsonVal.ValV && 
19      KeyValH == JsonVal.KeyValH;    
20  }
21  bool TJsonVal::operator!=(const TJsonVal& JsonVal) const {
22    return !(*this == JsonVal);
23  }
24  void TJsonVal::AddToObj(const PJsonVal& Val) {
25  	EAssert(Val->IsObj());
26  	int KeyId = Val->KeyValH.FFirstKeyId();
27  	while (Val->KeyValH.FNextKeyId(KeyId)) {
28  		AddToObj(Val->KeyValH.GetKey(KeyId), Val->KeyValH[KeyId]);
29  	}
30  }
31  PJsonVal TJsonVal::NewArr(const TJsonValV& ValV) {
32  	PJsonVal Val = TJsonVal::NewArr();
33  	for (int ValN = 0; ValN < ValV.Len(); ValN++) {
34  		Val->AddToArr(ValV[ValN]);
35  	}
36  	return Val;
37  }
38  PJsonVal TJsonVal::NewArr(const TIntV& IntV) {
39  	PJsonVal Val = TJsonVal::NewArr();
40  	for (int IntN = 0; IntN < IntV.Len(); IntN++) {
41  		Val->AddToArr(TJsonVal::NewNum((double)IntV[IntN]));
42  	}
43  	return Val;
44  }
45  PJsonVal TJsonVal::NewArr(const TFltV& FltV) {
46  	PJsonVal Val = TJsonVal::NewArr();
47  	for (int FltN = 0; FltN < FltV.Len(); FltN++) {
48  		Val->AddToArr(TJsonVal::NewNum(FltV[FltN]));
49  	}
50  	return Val;
51  }
52  PJsonVal TJsonVal::NewArr(const TStrV& StrV) {
53  	PJsonVal Val = TJsonVal::NewArr();
54  	for (int StrN = 0; StrN < StrV.Len(); StrN++) {
55  		Val->AddToArr(TJsonVal::NewStr(StrV[StrN]));
56  	}
57  	return Val;
58  }
59  PJsonVal TJsonVal::NewArr(const TFltPr& FltPr) {
60    PJsonVal Val = TJsonVal::NewArr();
61    Val->AddToArr(TJsonVal::NewNum(FltPr.Val1));
62    Val->AddToArr(TJsonVal::NewNum(FltPr.Val2));
63    return Val;
64  }
65  PJsonVal TJsonVal::GetObjKey(const TStr& Key) const {
66    EAssert(IsObj());
<span onclick='openModal()' class='match'>67    EAssert(IsObjKey(Key)); 
68    return KeyValH.GetDat(Key);
69  }
70  PJsonVal TJsonVal::GetObjKey(const char *Key) const {
</span>71    EAssert(IsObj());
72    EAssert(IsObjKey(Key));
73    return KeyValH.GetDat(Key);
74  }
75  bool TJsonVal::GetObjBool(const TStr& Key, const bool& DefBool) const { 
76    EAssert(IsObj());
77    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetBool() : DefBool;
78  }
79  bool TJsonVal::GetObjBool(const char *Key, const bool& DefBool) const { 
80    EAssert(IsObj());
81    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetBool() : DefBool;
82  }
83  double TJsonVal::GetObjNum(const TStr& Key, const double& DefNum) const { 
84    EAssert(IsObj());
85    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetNum() : DefNum;
86  } 
87  double TJsonVal::GetObjNum(const char *Key, const double& DefNum) const { 
88    EAssert(IsObj());
89    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetNum() : DefNum;
90  }
91  TStr TJsonVal::GetObjStr(const TStr& Key, const TStr& DefStr) const { 
92    EAssert(IsObj());
93    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetStr() : DefStr;
94  }
95  TStr TJsonVal::GetObjStr(const char *Key, const TStr& DefStr) const { 
96    EAssert(IsObj());
97    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetStr() : DefStr;
98  }
99  PJsonVal TJsonVal::GetValFromLx(TILx& Lx){
100    static TFSet ValExpect=TFSet()|syIdStr|syFlt|syQStr|syLBracket|syLBrace|syRBracket;
101    PJsonVal Val=TJsonVal::New();
102    if ((Lx.Sym==syIdStr)&&(Lx.Str=="null")){
103      Val->PutNull(); Lx.GetSym();
104    } else if ((Lx.Sym==syIdStr)&&(Lx.Str=="true")){
105      Val->PutBool(true); Lx.GetSym();
106    } else if ((Lx.Sym==syIdStr)&&(Lx.Str=="false")){
107      Val->PutBool(false); Lx.GetSym();
108    } else if (Lx.Sym==syFlt){
109      Val->PutNum(Lx.Flt); Lx.GetSym();
110    } else if (Lx.Sym==syQStr){
111      Val->PutStr(Lx.Str); Lx.GetSym();
112    } else if (Lx.Sym==syLBracket){
113      Val->PutArr(); Lx.GetSym(ValExpect); 
114      if (Lx.Sym!=syRBracket){
115        forever{
116          PJsonVal SubVal=TJsonVal::GetValFromLx(Lx);
117          Val->AddToArr(SubVal);
118          if (Lx.Sym==syComma){Lx.GetSym(ValExpect);} 
119          else if (Lx.Sym==syRBracket){break;} 
120          else {TExcept::Throw("JSON Array not properly formed.");}
121        }
122      }
123      Lx.GetSym();
124    } else if (Lx.Sym==syLBrace){
125      Val->PutObj(); Lx.GetSym(TFSet()|syRBrace|syQStr);
126      if (Lx.Sym!=syRBrace){
127        forever{
128          TStr SubKey=Lx.Str; 
129          Lx.GetSym(syColon); 
130          Lx.GetSym(ValExpect);
131          PJsonVal SubVal=TJsonVal::GetValFromLx(Lx);
132          Val->AddToObj(SubKey, SubVal);
133          if (Lx.Sym==syComma){Lx.GetSym(TFSet()|syQStr);} 
134          else if (Lx.Sym==syRBrace){break;} 
135          else {TExcept::Throw("JSON Object not properly formed.");}
136        }
137      }
138      Lx.GetSym();
139    } else {
140      TExcept::Throw("Unexpected JSON symbol.");
141    }
142    return Val;
143  }
144  PJsonVal TJsonVal::GetValFromSIn(const PSIn& SIn){
145    TILx Lx(SIn, TFSet()|iloCmtAlw|iloCsSens|iloExcept|iloSigNum);
146    PJsonVal Val;
147    TStr MsgStr="Ok";
148    try {
149      Lx.GetSym(TFSet()|syLBracket|syLBrace);
150      Val=GetValFromLx(Lx);
151    }
152    catch (PExcept Except){
153      MsgStr=Except->GetMsgStr();
154      Val=TJsonVal::New();
155    }
156    return Val;
157  }
158  PJsonVal TJsonVal::GetValFromStr(const TStr& JsonStr){
159    PSIn SIn=TStrIn::New(JsonStr);
160    return GetValFromSIn(SIn);
161  }
162  void TJsonVal::AddEscapeChAFromStr(const TStr& Str, TChA& ChA){
163  	if (TUnicodeDef::IsDef()) {
164  		TIntV UStr; TUnicodeDef::GetDef()->DecodeUtf8(Str, UStr);
165  		for (int ChN = 0; ChN < UStr.Len(); ChN++) {
166  			const int UCh = UStr[ChN];
167  			if (UCh < 0x80) {
168  				const char Ch = (char)UCh;
169  				switch (Ch) {
170  					case '"' : ChA.AddCh('\\'); ChA.AddCh('"'); break;
171  					case '\\' : ChA.AddCh('\\'); ChA.AddCh('\\'); break;
172  					case '/' : ChA.AddCh('\\'); ChA.AddCh('/'); break;
173  					case '\b' : ChA.AddCh('\\'); ChA.AddCh('b'); break;
174  					case '\f' : ChA.AddCh('\\'); ChA.AddCh('f'); break;
175  					case '\n' : ChA.AddCh('\\'); ChA.AddCh('n'); break;
176  					case '\r' : ChA.AddCh('\\'); ChA.AddCh('r'); break;
177  					case '\t' : ChA.AddCh('\\'); ChA.AddCh('t'); break;
178  					default :
179  						ChA.AddCh(Ch);
180  				}
181  			} else {
182  				ChA += "\\u";
183  				ChA += TStr::Fmt("%04x", UCh);
184  			}
185  		}
186  	} else {
187  		for (int ChN = 0; ChN < Str.Len(); ChN++) {
188  			const char Ch = Str[ChN];
189  			if ((Ch & 0x80) == 0) {
190  				switch (Ch) {
191  					case '"' : ChA.AddCh('\\'); ChA.AddCh('"'); break;
192  					case '\\' : ChA.AddCh('\\'); ChA.AddCh('\\'); break;
193  					case '/' : ChA.AddCh('\\'); ChA.AddCh('/'); break;
194  					case '\b' : ChA.AddCh('\\'); ChA.AddCh('b'); break;
195  					case '\f' : ChA.AddCh('\\'); ChA.AddCh('f'); break;
196  					case '\n' : ChA.AddCh('\\'); ChA.AddCh('n'); break;
197  					case '\r' : ChA.AddCh('\\'); ChA.AddCh('r'); break;
198  					case '\t' : ChA.AddCh('\\'); ChA.AddCh('t'); break;
199  					default : ChA.AddCh(Ch);
200  				}
201  			} else {
202  				ChA += "\\u";
203  				ChA += TStr::Fmt("%02x", (int)Ch);
204  			}
205  		}
206  	}
207  }
208  void TJsonVal::AddQChAFromStr(const TStr& Str, TChA& ChA){
209    ChA+="\"";
210    AddEscapeChAFromStr(Str, ChA);
211    ChA+="\"";
212  }
213  void TJsonVal::GetChAFromVal(const PJsonVal& Val, TChA& ChA){
214    switch (Val->GetJsonValType()){
215      case jvtNull: 
216        ChA+="null"; break;
217      case jvtBool:
218        if (Val->GetBool()){ChA+="true";} else {ChA+="false";} break;
219      case jvtNum: 
220        ChA+=TStr::Fmt("%f", Val->GetNum()); break;
221      case jvtStr:
222        AddQChAFromStr(Val->GetStr(), ChA); break;
223      case jvtArr:
224        ChA+="[";
225        for (int ArrValN=0; ArrValN<Val->GetArrVals(); ArrValN++){
226          if (ArrValN>0){ChA+=", ";}
227          GetChAFromVal(Val->GetArrVal(ArrValN), ChA);
228        }
229        ChA+="]"; 
230        break;
231      case jvtObj:
232        ChA+="{";
233        for (int ObjKeyN=0; ObjKeyN<Val->GetObjKeys(); ObjKeyN++){
234          if (ObjKeyN>0){ChA+=", ";}
235          TStr ObjKey; PJsonVal ObjVal; Val->GetObjKeyVal(ObjKeyN, ObjKey, ObjVal);
236          AddQChAFromStr(ObjKey, ChA);
237          ChA+=":";
238          GetChAFromVal(ObjVal, ChA);
239        }
240        ChA+="}"; 
241        break;
242  	default: TExcept::Throw("Error parsing json");
243    }
244  }
245  TStr TJsonVal::GetStrFromVal(const PJsonVal& Val){
246    TChA ChA;
247    GetChAFromVal(Val, ChA);
248    return ChA;
249  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-json.cpp</h3>
            <pre><code>1  TJsonVal::TJsonVal(TSIn& SIn):
2    JsonValType((TJsonValType)(TInt(SIn).Val)), Bool(SIn), 
3    Num(SIn), Str(SIn), ValV(SIn), KeyValH(SIn) { }
4  void TJsonVal::Save(TSOut& SOut) const {
5    TInt((int)JsonValType).Save(SOut);
6    Bool.Save(SOut); Num.Save(SOut);
7    Str.Save(SOut); ValV.Save(SOut);
8    KeyValH.Save(SOut);
9  }
10  TStr TJsonVal::SaveStr() { 
11    return GetStrFromVal(this); 
12  }
13  bool TJsonVal::operator==(const TJsonVal& JsonVal) const {
14    return JsonValType == JsonVal.JsonValType &&
15      Bool == JsonVal.Bool &&
16      Num == JsonVal.Num &&
17      Str == JsonVal.Str &&
18      ValV == JsonVal.ValV && 
19      KeyValH == JsonVal.KeyValH;    
20  }
21  bool TJsonVal::operator!=(const TJsonVal& JsonVal) const {
22    return !(*this == JsonVal);
23  }
24  void TJsonVal::AddToObj(const PJsonVal& Val) {
25  	EAssert(Val->IsObj());
26  	int KeyId = Val->KeyValH.FFirstKeyId();
27  	while (Val->KeyValH.FNextKeyId(KeyId)) {
28  		AddToObj(Val->KeyValH.GetKey(KeyId), Val->KeyValH[KeyId]);
29  	}
30  }
31  PJsonVal TJsonVal::NewArr(const TJsonValV& ValV) {
32  	PJsonVal Val = TJsonVal::NewArr();
33  	for (int ValN = 0; ValN < ValV.Len(); ValN++) {
34  		Val->AddToArr(ValV[ValN]);
35  	}
36  	return Val;
37  }
38  PJsonVal TJsonVal::NewArr(const TIntV& IntV) {
39  	PJsonVal Val = TJsonVal::NewArr();
40  	for (int IntN = 0; IntN < IntV.Len(); IntN++) {
41  		Val->AddToArr(TJsonVal::NewNum((double)IntV[IntN]));
42  	}
43  	return Val;
44  }
45  PJsonVal TJsonVal::NewArr(const TFltV& FltV) {
46  	PJsonVal Val = TJsonVal::NewArr();
47  	for (int FltN = 0; FltN < FltV.Len(); FltN++) {
48  		Val->AddToArr(TJsonVal::NewNum(FltV[FltN]));
49  	}
50  	return Val;
51  }
52  PJsonVal TJsonVal::NewArr(const TStrV& StrV) {
53  	PJsonVal Val = TJsonVal::NewArr();
54  	for (int StrN = 0; StrN < StrV.Len(); StrN++) {
55  		Val->AddToArr(TJsonVal::NewStr(StrV[StrN]));
56  	}
57  	return Val;
58  }
59  PJsonVal TJsonVal::NewArr(const TFltPr& FltPr) {
60    PJsonVal Val = TJsonVal::NewArr();
61    Val->AddToArr(TJsonVal::NewNum(FltPr.Val1));
62    Val->AddToArr(TJsonVal::NewNum(FltPr.Val2));
63    return Val;
64  }
65  PJsonVal TJsonVal::GetObjKey(const TStr& Key) const {
66    EAssert(IsObj());
67    EAssert(IsObjKey(Key)); 
68    return KeyValH.GetDat(Key);
69  }
70  PJsonVal TJsonVal::GetObjKey(const char *Key) const {
71    EAssert(IsObj());
<span onclick='openModal()' class='match'>72    EAssert(IsObjKey(Key));
73    return KeyValH.GetDat(Key);
74  }
75  bool TJsonVal::GetObjBool(const TStr& Key, const bool& DefBool) const { 
</span>76    EAssert(IsObj());
77    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetBool() : DefBool;
78  }
79  bool TJsonVal::GetObjBool(const char *Key, const bool& DefBool) const { 
80    EAssert(IsObj());
81    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetBool() : DefBool;
82  }
83  double TJsonVal::GetObjNum(const TStr& Key, const double& DefNum) const { 
84    EAssert(IsObj());
85    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetNum() : DefNum;
86  } 
87  double TJsonVal::GetObjNum(const char *Key, const double& DefNum) const { 
88    EAssert(IsObj());
89    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetNum() : DefNum;
90  }
91  TStr TJsonVal::GetObjStr(const TStr& Key, const TStr& DefStr) const { 
92    EAssert(IsObj());
93    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetStr() : DefStr;
94  }
95  TStr TJsonVal::GetObjStr(const char *Key, const TStr& DefStr) const { 
96    EAssert(IsObj());
97    return (IsObjKey(Key)) ? KeyValH.GetDat(Key)->GetStr() : DefStr;
98  }
99  PJsonVal TJsonVal::GetValFromLx(TILx& Lx){
100    static TFSet ValExpect=TFSet()|syIdStr|syFlt|syQStr|syLBracket|syLBrace|syRBracket;
101    PJsonVal Val=TJsonVal::New();
102    if ((Lx.Sym==syIdStr)&&(Lx.Str=="null")){
103      Val->PutNull(); Lx.GetSym();
104    } else if ((Lx.Sym==syIdStr)&&(Lx.Str=="true")){
105      Val->PutBool(true); Lx.GetSym();
106    } else if ((Lx.Sym==syIdStr)&&(Lx.Str=="false")){
107      Val->PutBool(false); Lx.GetSym();
108    } else if (Lx.Sym==syFlt){
109      Val->PutNum(Lx.Flt); Lx.GetSym();
110    } else if (Lx.Sym==syQStr){
111      Val->PutStr(Lx.Str); Lx.GetSym();
112    } else if (Lx.Sym==syLBracket){
113      Val->PutArr(); Lx.GetSym(ValExpect); 
114      if (Lx.Sym!=syRBracket){
115        forever{
116          PJsonVal SubVal=TJsonVal::GetValFromLx(Lx);
117          Val->AddToArr(SubVal);
118          if (Lx.Sym==syComma){Lx.GetSym(ValExpect);} 
119          else if (Lx.Sym==syRBracket){break;} 
120          else {TExcept::Throw("JSON Array not properly formed.");}
121        }
122      }
123      Lx.GetSym();
124    } else if (Lx.Sym==syLBrace){
125      Val->PutObj(); Lx.GetSym(TFSet()|syRBrace|syQStr);
126      if (Lx.Sym!=syRBrace){
127        forever{
128          TStr SubKey=Lx.Str; 
129          Lx.GetSym(syColon); 
130          Lx.GetSym(ValExpect);
131          PJsonVal SubVal=TJsonVal::GetValFromLx(Lx);
132          Val->AddToObj(SubKey, SubVal);
133          if (Lx.Sym==syComma){Lx.GetSym(TFSet()|syQStr);} 
134          else if (Lx.Sym==syRBrace){break;} 
135          else {TExcept::Throw("JSON Object not properly formed.");}
136        }
137      }
138      Lx.GetSym();
139    } else {
140      TExcept::Throw("Unexpected JSON symbol.");
141    }
142    return Val;
143  }
144  PJsonVal TJsonVal::GetValFromSIn(const PSIn& SIn){
145    TILx Lx(SIn, TFSet()|iloCmtAlw|iloCsSens|iloExcept|iloSigNum);
146    PJsonVal Val;
147    TStr MsgStr="Ok";
148    try {
149      Lx.GetSym(TFSet()|syLBracket|syLBrace);
150      Val=GetValFromLx(Lx);
151    }
152    catch (PExcept Except){
153      MsgStr=Except->GetMsgStr();
154      Val=TJsonVal::New();
155    }
156    return Val;
157  }
158  PJsonVal TJsonVal::GetValFromStr(const TStr& JsonStr){
159    PSIn SIn=TStrIn::New(JsonStr);
160    return GetValFromSIn(SIn);
161  }
162  void TJsonVal::AddEscapeChAFromStr(const TStr& Str, TChA& ChA){
163  	if (TUnicodeDef::IsDef()) {
164  		TIntV UStr; TUnicodeDef::GetDef()->DecodeUtf8(Str, UStr);
165  		for (int ChN = 0; ChN < UStr.Len(); ChN++) {
166  			const int UCh = UStr[ChN];
167  			if (UCh < 0x80) {
168  				const char Ch = (char)UCh;
169  				switch (Ch) {
170  					case '"' : ChA.AddCh('\\'); ChA.AddCh('"'); break;
171  					case '\\' : ChA.AddCh('\\'); ChA.AddCh('\\'); break;
172  					case '/' : ChA.AddCh('\\'); ChA.AddCh('/'); break;
173  					case '\b' : ChA.AddCh('\\'); ChA.AddCh('b'); break;
174  					case '\f' : ChA.AddCh('\\'); ChA.AddCh('f'); break;
175  					case '\n' : ChA.AddCh('\\'); ChA.AddCh('n'); break;
176  					case '\r' : ChA.AddCh('\\'); ChA.AddCh('r'); break;
177  					case '\t' : ChA.AddCh('\\'); ChA.AddCh('t'); break;
178  					default :
179  						ChA.AddCh(Ch);
180  				}
181  			} else {
182  				ChA += "\\u";
183  				ChA += TStr::Fmt("%04x", UCh);
184  			}
185  		}
186  	} else {
187  		for (int ChN = 0; ChN < Str.Len(); ChN++) {
188  			const char Ch = Str[ChN];
189  			if ((Ch & 0x80) == 0) {
190  				switch (Ch) {
191  					case '"' : ChA.AddCh('\\'); ChA.AddCh('"'); break;
192  					case '\\' : ChA.AddCh('\\'); ChA.AddCh('\\'); break;
193  					case '/' : ChA.AddCh('\\'); ChA.AddCh('/'); break;
194  					case '\b' : ChA.AddCh('\\'); ChA.AddCh('b'); break;
195  					case '\f' : ChA.AddCh('\\'); ChA.AddCh('f'); break;
196  					case '\n' : ChA.AddCh('\\'); ChA.AddCh('n'); break;
197  					case '\r' : ChA.AddCh('\\'); ChA.AddCh('r'); break;
198  					case '\t' : ChA.AddCh('\\'); ChA.AddCh('t'); break;
199  					default : ChA.AddCh(Ch);
200  				}
201  			} else {
202  				ChA += "\\u";
203  				ChA += TStr::Fmt("%02x", (int)Ch);
204  			}
205  		}
206  	}
207  }
208  void TJsonVal::AddQChAFromStr(const TStr& Str, TChA& ChA){
209    ChA+="\"";
210    AddEscapeChAFromStr(Str, ChA);
211    ChA+="\"";
212  }
213  void TJsonVal::GetChAFromVal(const PJsonVal& Val, TChA& ChA){
214    switch (Val->GetJsonValType()){
215      case jvtNull: 
216        ChA+="null"; break;
217      case jvtBool:
218        if (Val->GetBool()){ChA+="true";} else {ChA+="false";} break;
219      case jvtNum: 
220        ChA+=TStr::Fmt("%f", Val->GetNum()); break;
221      case jvtStr:
222        AddQChAFromStr(Val->GetStr(), ChA); break;
223      case jvtArr:
224        ChA+="[";
225        for (int ArrValN=0; ArrValN<Val->GetArrVals(); ArrValN++){
226          if (ArrValN>0){ChA+=", ";}
227          GetChAFromVal(Val->GetArrVal(ArrValN), ChA);
228        }
229        ChA+="]"; 
230        break;
231      case jvtObj:
232        ChA+="{";
233        for (int ObjKeyN=0; ObjKeyN<Val->GetObjKeys(); ObjKeyN++){
234          if (ObjKeyN>0){ChA+=", ";}
235          TStr ObjKey; PJsonVal ObjVal; Val->GetObjKeyVal(ObjKeyN, ObjKey, ObjVal);
236          AddQChAFromStr(ObjKey, ChA);
237          ChA+=":";
238          GetChAFromVal(ObjVal, ChA);
239        }
240        ChA+="}"; 
241        break;
242  	default: TExcept::Throw("Error parsing json");
243    }
244  }
245  TStr TJsonVal::GetStrFromVal(const PJsonVal& Val){
246    TChA ChA;
247    GetChAFromVal(Val, ChA);
248    return ChA;
249  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-json.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-json.cpp</div>
                </div>
                <div class="column column_space"><pre><code>67    EAssert(IsObjKey(Key)); 
68    return KeyValH.GetDat(Key);
69  }
70  PJsonVal TJsonVal::GetObjKey(const char *Key) const {
</pre></code></div>
                <div class="column column_space"><pre><code>72    EAssert(IsObjKey(Key));
73    return KeyValH.GetDat(Key);
74  }
75  bool TJsonVal::GetObjBool(const TStr& Key, const bool& DefBool) const { 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    