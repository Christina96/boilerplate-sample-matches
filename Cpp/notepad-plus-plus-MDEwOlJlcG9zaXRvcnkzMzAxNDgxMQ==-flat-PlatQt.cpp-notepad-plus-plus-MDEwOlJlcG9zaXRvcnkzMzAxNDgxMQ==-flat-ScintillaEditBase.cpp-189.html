
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatQt.cpp</h3>
            <pre><code>1  #include &lt;cstdio&gt;
2  #include &quot;PlatQt.h&quot;
3  #include &quot;Scintilla.h&quot;
4  #include &quot;XPM.h&quot;
5  #include &quot;UniConversion.h&quot;
6  #include &quot;DBCS.h&quot;
7  #include &lt;QApplication&gt;
8  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 0, 0)
9  #include &lt;QScreen&gt;
10  #endif
11  #include &lt;QFont&gt;
12  #include &lt;QColor&gt;
13  #include &lt;QRect&gt;
14  #include &lt;QPaintDevice&gt;
15  #include &lt;QPaintEngine&gt;
16  #include &lt;QWidget&gt;
17  #include &lt;QPixmap&gt;
18  #include &lt;QPainter&gt;
19  #include &lt;QPainterPath&gt;
20  #include &lt;QMenu&gt;
21  #include &lt;QAction&gt;
22  #include &lt;QTime&gt;
23  #include &lt;QMessageBox&gt;
24  #include &lt;QTextCodec&gt;
25  #include &lt;QListWidget&gt;
26  #include &lt;QVarLengthArray&gt;
27  #include &lt;QScrollBar&gt;
28  #include &lt;QTextLayout&gt;
29  #include &lt;QTextLine&gt;
30  #include &lt;QLibrary&gt;
31  using namespace Scintilla;
32  namespace Scintilla::Internal {
33  const char *CharacterSetID(CharacterSet characterSet)
34  {
35  	switch (characterSet) {
36  	case CharacterSet::Default:
37  		return &quot;ISO 8859-1&quot;;
38  	case CharacterSet::Baltic:
39  		return &quot;ISO 8859-13&quot;;
40  	case CharacterSet::ChineseBig5:
41  		return &quot;Big5&quot;;
42  	case CharacterSet::EastEurope:
43  		return &quot;ISO 8859-2&quot;;
44  	case CharacterSet::GB2312:
45  		return &quot;GB18030-0&quot;;
46  	case CharacterSet::Greek:
47  		return &quot;ISO 8859-7&quot;;
48  	case CharacterSet::Hangul:
49  		return &quot;CP949&quot;;
50  	case CharacterSet::Mac:
51  		return &quot;Apple Roman&quot;;
52  	case CharacterSet::Russian:
53  		return &quot;KOI8-R&quot;;
54  	case CharacterSet::Cyrillic:
55  		return &quot;Windows-1251&quot;;
56  	case CharacterSet::ShiftJis:
57  		return &quot;Shift-JIS&quot;;
58  	case CharacterSet::Turkish:
59  		return &quot;ISO 8859-9&quot;;
60  	case CharacterSet::Hebrew:
61  		return &quot;ISO 8859-8&quot;;
62  	case CharacterSet::Arabic:
63  		return &quot;ISO 8859-6&quot;;
64  	case CharacterSet::Vietnamese:
65  		return &quot;Windows-1258&quot;;
66  	case CharacterSet::Thai:
67  		return &quot;TIS-620&quot;;
68  	case CharacterSet::Iso8859_15:
69  		return &quot;ISO 8859-15&quot;;
70  	default:
71  		return &quot;ISO 8859-1&quot;;
72  	}
73  }
74  QString UnicodeFromText(QTextCodec *codec, std::string_view text) {
75  	return codec-&gt;toUnicode(text.data(), static_cast&lt;int&gt;(text.length()));
76  }
77  static QFont::StyleStrategy ChooseStrategy(FontQuality eff)
78  {
79  	switch (eff) {
80  		case FontQuality::QualityDefault:         return QFont::PreferDefault;
81  		case FontQuality::QualityNonAntialiased: return QFont::NoAntialias;
82  		case FontQuality::QualityAntialiased:     return QFont::PreferAntialias;
83  		case FontQuality::QualityLcdOptimized:   return QFont::PreferAntialias;
84  		default:                             return QFont::PreferDefault;
85  	}
86  }
87  class FontAndCharacterSet : public Font {
88  public:
89  	CharacterSet characterSet = CharacterSet::Ansi;
90  	std::unique_ptr&lt;QFont&gt; pfont;
91  	explicit FontAndCharacterSet(const FontParameters &amp;fp) : characterSet(fp.characterSet) {
92  		pfont = std::make_unique&lt;QFont&gt;();
93  		pfont-&gt;setStyleStrategy(ChooseStrategy(fp.extraFontFlag));
94  		pfont-&gt;setFamily(QString::fromUtf8(fp.faceName));
95  		pfont-&gt;setPointSizeF(fp.size);
96  		pfont-&gt;setBold(static_cast&lt;int&gt;(fp.weight) &gt; 500);
97  		pfont-&gt;setItalic(fp.italic);
98  	}
99  };
100  namespace {
101  const Supports SupportsQt[] = {
102  	Supports::LineDrawsFinal,
103  	Supports::FractionalStrokeWidth,
104  	Supports::TranslucentStroke,
105  	Supports::PixelModification,
106  };
107  const FontAndCharacterSet *AsFontAndCharacterSet(const Font *f) {
108  	return dynamic_cast&lt;const FontAndCharacterSet *&gt;(f);
109  }
110  QFont *FontPointer(const Font *f)
111  {
112  	return AsFontAndCharacterSet(f)-&gt;pfont.get();
113  }
114  }
115  std::shared_ptr&lt;Font&gt; Font::Allocate(const FontParameters &amp;fp)
116  {
117  	return std::make_shared&lt;FontAndCharacterSet&gt;(fp);
118  }
119  SurfaceImpl::SurfaceImpl() = default;
120  SurfaceImpl::SurfaceImpl(int width, int height, SurfaceMode mode_)
121  {
122  	if (width &lt; 1) width = 1;
123  	if (height &lt; 1) height = 1;
124  	deviceOwned = true;
125  	device = new QPixmap(width, height);
126  	mode = mode_;
127  }
128  SurfaceImpl::~SurfaceImpl()
129  {
130  	Clear();
131  }
132  void SurfaceImpl::Clear()
133  {
134  	if (painterOwned &amp;&amp; painter) {
135  		delete painter;
136  	}
137  	if (deviceOwned &amp;&amp; device) {
138  		delete device;
139  	}
140  	device = nullptr;
141  	painter = nullptr;
142  	deviceOwned = false;
143  	painterOwned = false;
144  }
145  void SurfaceImpl::Init(WindowID wid)
146  {
147  	Release();
148  	device = static_cast&lt;QWidget *&gt;(wid);
149  }
150  void SurfaceImpl::Init(SurfaceID sid, WindowID &amp;bsol;*wid*/)
151  {
152  	Release();
153  	device = static_cast&lt;QPaintDevice *&gt;(sid);
154  }
155  std::unique_ptr&lt;Surface&gt; SurfaceImpl::AllocatePixMap(int width, int height)
156  {
157  	return std::make_unique&lt;SurfaceImpl&gt;(width, height, mode);
158  }
159  void SurfaceImpl::SetMode(SurfaceMode mode_)
160  {
161  	mode = mode_;
162  }
163  void SurfaceImpl::Release() noexcept
164  {
165  	Clear();
166  }
167  int SurfaceImpl::SupportsFeature(Supports feature) noexcept
168  {
169  	for (const Supports f : SupportsQt) {
170  		if (f == feature)
171  			return 1;
172  	}
173  	return 0;
174  }
175  bool SurfaceImpl::Initialised()
176  {
177  	return device != nullptr;
178  }
179  void SurfaceImpl::PenColour(ColourRGBA fore)
180  {
181  	QPen penOutline(QColorFromColourRGBA(fore));
182  	penOutline.setCapStyle(Qt::FlatCap);
183  	GetPainter()-&gt;setPen(penOutline);
184  }
185  void SurfaceImpl::PenColourWidth(ColourRGBA fore, XYPOSITION strokeWidth) {
186  	QPen penOutline(QColorFromColourRGBA(fore));
187  	penOutline.setCapStyle(Qt::FlatCap);
188  	penOutline.setJoinStyle(Qt::MiterJoin);
189  	penOutline.setWidthF(strokeWidth);
190  	GetPainter()-&gt;setPen(penOutline);
191  }
192  void SurfaceImpl::BrushColour(ColourRGBA back)
193  {
194  	GetPainter()-&gt;setBrush(QBrush(QColorFromColourRGBA(back)));
195  }
196  void SurfaceImpl::SetCodec(const Font *font)
197  {
198  	const FontAndCharacterSet *pfacs = AsFontAndCharacterSet(font);
199  	if (pfacs &amp;&amp; pfacs-&gt;pfont) {
200  		const char *csid = &quot;UTF-8&quot;;
201  		if (!(mode.codePage == SC_CP_UTF8))
202  			csid = CharacterSetID(pfacs-&gt;characterSet);
203  		if (csid != codecName) {
204  			codecName = csid;
205  			codec = QTextCodec::codecForName(csid);
206  		}
207  	}
208  }
209  void SurfaceImpl::SetFont(const Font *font)
210  {
211  	const FontAndCharacterSet *pfacs = AsFontAndCharacterSet(font);
212  	if (pfacs &amp;&amp; pfacs-&gt;pfont) {
213  		GetPainter()-&gt;setFont(*(pfacs-&gt;pfont));
214  		SetCodec(font);
215  	}
216  }
217  int SurfaceImpl::LogPixelsY()
218  {
219  	return device-&gt;logicalDpiY();
220  }
221  int SurfaceImpl::PixelDivisions()
222  {
223  	return 1;
224  }
225  int SurfaceImpl::DeviceHeightFont(int points)
226  {
227  	return points;
228  }
229  void SurfaceImpl::LineDraw(Point start, Point end, Stroke stroke)
230  {
231  	PenColourWidth(stroke.colour, stroke.width);
232  	QLineF line(start.x, start.y, end.x, end.y);
233  	GetPainter()-&gt;drawLine(line);
234  }
235  void SurfaceImpl::PolyLine(const Point *pts, size_t npts, Stroke stroke)
236  {
237  	PenColourWidth(stroke.colour, stroke.width);
238  	std::vector&lt;QPointF&gt; qpts;
239  	std::transform(pts, pts + npts, std::back_inserter(qpts), QPointFFromPoint);
240  	GetPainter()-&gt;drawPolyline(&amp;qpts[0], static_cast&lt;int&gt;(npts));
241  }
242  void SurfaceImpl::Polygon(const Point *pts, size_t npts, FillStroke fillStroke)
243  {
244  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
245  	BrushColour(fillStroke.fill.colour);
246  	std::vector&lt;QPointF&gt; qpts;
247  	std::transform(pts, pts + npts, std::back_inserter(qpts), QPointFFromPoint);
248  	GetPainter()-&gt;drawPolygon(&amp;qpts[0], static_cast&lt;int&gt;(npts));
249  }
250  void SurfaceImpl::RectangleDraw(PRectangle rc, FillStroke fillStroke)
251  {
252  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
253  	BrushColour(fillStroke.fill.colour);
254  	const QRectF rect = QRectFFromPRect(rc.Inset(fillStroke.stroke.width / 2));
255  	GetPainter()-&gt;drawRect(rect);
256  }
257  void SurfaceImpl::RectangleFrame(PRectangle rc, Stroke stroke) {
258  	PenColourWidth(stroke.colour, stroke.width);
259  	GetPainter()-&gt;setBrush(QBrush());
260  	const QRectF rect = QRectFFromPRect(rc.Inset(stroke.width / 2));
261  	GetPainter()-&gt;drawRect(rect);
262  }
263  void SurfaceImpl::FillRectangle(PRectangle rc, Fill fill)
264  {
265  	GetPainter()-&gt;fillRect(QRectFFromPRect(rc), QColorFromColourRGBA(fill.colour));
266  }
267  void SurfaceImpl::FillRectangleAligned(PRectangle rc, Fill fill)
268  {
269  	FillRectangle(PixelAlign(rc, 1), fill);
270  }
271  void SurfaceImpl::FillRectangle(PRectangle rc, Surface &amp;surfacePattern)
272  {
273  	SurfaceImpl *surface = dynamic_cast&lt;SurfaceImpl *&gt;(&amp;surfacePattern);
274  	const QPixmap *pixmap = static_cast&lt;QPixmap *&gt;(surface-&gt;GetPaintDevice());
275  	GetPainter()-&gt;drawTiledPixmap(QRectFromPRect(rc), *pixmap);
276  }
277  void SurfaceImpl::RoundedRectangle(PRectangle rc, FillStroke fillStroke)
278  {
279  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
280  	BrushColour(fillStroke.fill.colour);
281  	GetPainter()-&gt;drawRoundedRect(QRectFFromPRect(rc), 3.0f, 3.0f);
282  }
283  void SurfaceImpl::AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke)
284  {
285  	QColor qFill = QColorFromColourRGBA(fillStroke.fill.colour);
286  	QBrush brushFill(qFill);
287  	GetPainter()-&gt;setBrush(brushFill);
288  	if (fillStroke.fill.colour == fillStroke.stroke.colour) {
289  		painter-&gt;setPen(Qt::NoPen);
290  		QRectF rect = QRectFFromPRect(rc);
291  		if (cornerSize &gt; 0.0f) {
292  			qreal radius = cornerSize+1;
293  			GetPainter()-&gt;drawRoundedRect(rect, radius, radius);
294  		} else {
295  			GetPainter()-&gt;fillRect(rect, brushFill);
296  		}
297  	} else {
298  		QColor qOutline = QColorFromColourRGBA(fillStroke.stroke.colour);
299  		QPen penOutline(qOutline);
300  		penOutline.setWidthF(fillStroke.stroke.width);
301  		GetPainter()-&gt;setPen(penOutline);
302  		QRectF rect = QRectFFromPRect(rc.Inset(fillStroke.stroke.width / 2));
303  		if (cornerSize &gt; 0.0f) {
304  			qreal radius = cornerSize+1;
305  			GetPainter()-&gt;drawRoundedRect(rect, radius, radius);
306  		} else {
307  			GetPainter()-&gt;drawRect(rect);
308  		}
309  	}
310  }
311  void SurfaceImpl::GradientRectangle(PRectangle rc, const std::vector&lt;ColourStop&gt; &amp;stops, GradientOptions options) {
312  	QRectF rect = QRectFFromPRect(rc);
313  	QLinearGradient linearGradient;
314  	switch (options) {
315  	case GradientOptions::leftToRight:
316  		linearGradient = QLinearGradient(rc.left, rc.top, rc.right, rc.top);
317  		break;
318  	case GradientOptions::topToBottom:
319  	default:
320  		linearGradient = QLinearGradient(rc.left, rc.top, rc.left, rc.bottom);
321  		break;
322  	}
323  	linearGradient.setSpread(QGradient::RepeatSpread);
324  	for (const ColourStop &amp;stop : stops) {
325  		linearGradient.setColorAt(stop.position, QColorFromColourRGBA(stop.colour));
326  	}
327  	QBrush brush = QBrush(linearGradient);
328  	GetPainter()-&gt;fillRect(rect, brush);
329  }
330  static std::vector&lt;unsigned char&gt; ImageByteSwapped(int width, int height, const unsigned char *pixelsImage)
331  {
332  	size_t bytes = width * height * 4;
333  	std::vector&lt;unsigned char&gt; imageBytes(pixelsImage, pixelsImage+bytes);
334  	for (size_t i=0; i&lt;bytes; i+=4)
335  		std::swap(imageBytes[i], imageBytes[i+2]);
336  	return imageBytes;
337  }
338  void SurfaceImpl::DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage)
339  {
340  	std::vector&lt;unsigned char&gt; imageBytes = ImageByteSwapped(width, height, pixelsImage);
341  	QImage image(&amp;imageBytes[0], width, height, QImage::Format_ARGB32);
342  	QPoint pt(rc.left, rc.top);
343  	GetPainter()-&gt;drawImage(pt, image);
344  }
345  void SurfaceImpl::Ellipse(PRectangle rc, FillStroke fillStroke)
346  {
347  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
348  	BrushColour(fillStroke.fill.colour);
349  	const QRectF rect = QRectFFromPRect(rc.Inset(fillStroke.stroke.width / 2));
350  	GetPainter()-&gt;drawEllipse(rect);
351  }
352  void SurfaceImpl::Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) {
353  	const XYPOSITION halfStroke = fillStroke.stroke.width / 2.0f;
354  	const XYPOSITION radius = rc.Height() / 2.0f - halfStroke;
355  	PRectangle rcInner = rc;
356  	rcInner.left += radius;
357  	rcInner.right -= radius;
358  	const XYPOSITION arcHeight = rc.Height() - fillStroke.stroke.width;
359  	PenColourWidth(fillStroke.stroke.colour, fillStroke.stroke.width);
360  	BrushColour(fillStroke.fill.colour);
361  	QPainterPath path;
362  	const Ends leftSide = static_cast&lt;Ends&gt;(static_cast&lt;unsigned int&gt;(ends) &amp; 0xfu);
363  	const Ends rightSide = static_cast&lt;Ends&gt;(static_cast&lt;unsigned int&gt;(ends) &amp; 0xf0u);
364  	switch (leftSide) {
365  		case Ends::leftFlat:
366  			path.moveTo(rc.left + halfStroke, rc.top + halfStroke);
367  			path.lineTo(rc.left + halfStroke, rc.bottom - halfStroke);
368  			break;
369  		case Ends::leftAngle:
370  			path.moveTo(rcInner.left + halfStroke, rc.top + halfStroke);
371  			path.lineTo(rc.left + halfStroke, rc.Centre().y);
372  			path.lineTo(rcInner.left + halfStroke, rc.bottom - halfStroke);
373  			break;
374  		case Ends::semiCircles:
375  		default:
376  			path.moveTo(rcInner.left + halfStroke, rc.top + halfStroke);
377  			QRectF rectangleArc(rc.left + halfStroke, rc.top + halfStroke,
378  					    arcHeight, arcHeight);
379  			path.arcTo(rectangleArc, 90, 180);
380  			break;
381  	}
382  	switch (rightSide) {
383  		case Ends::rightFlat:
384  			path.lineTo(rc.right - halfStroke, rc.bottom - halfStroke);
385  			path.lineTo(rc.right - halfStroke, rc.top + halfStroke);
386  			break;
387  		case Ends::rightAngle:
388  			path.lineTo(rcInner.right - halfStroke, rc.bottom - halfStroke);
389  			path.lineTo(rc.right - halfStroke, rc.Centre().y);
390  			path.lineTo(rcInner.right - halfStroke, rc.top + halfStroke);
391  			break;
392  		case Ends::semiCircles:
393  		default:
394  			path.lineTo(rcInner.right - halfStroke, rc.bottom - halfStroke);
395  			QRectF rectangleArc(rc.right - arcHeight - halfStroke, rc.top + halfStroke,
396  					    arcHeight, arcHeight);
397  			path.arcTo(rectangleArc, 270, 180);
398  			break;
399  	}
400  	path.closeSubpath();
401  	GetPainter()-&gt;drawPath(path);
402  }
403  void SurfaceImpl::Copy(PRectangle rc, Point from, Surface &amp;surfaceSource)
404  {
405  	SurfaceImpl *source = dynamic_cast&lt;SurfaceImpl *&gt;(&amp;surfaceSource);
406  	QPixmap *pixmap = static_cast&lt;QPixmap *&gt;(source-&gt;GetPaintDevice());
407  	GetPainter()-&gt;drawPixmap(rc.left, rc.top, *pixmap, from.x, from.y, -1, -1);
408  }
409  std::unique_ptr&lt;IScreenLineLayout&gt; SurfaceImpl::Layout(const IScreenLine *)
410  {
411  	return {};
412  }
413  void SurfaceImpl::DrawTextNoClip(PRectangle rc,
414  				 const Font *font,
415                                   XYPOSITION ybase,
416  				 std::string_view text,
417  				 ColourRGBA fore,
418  				 ColourRGBA back)
419  {
420  	SetFont(font);
421  	PenColour(fore);
422  	GetPainter()-&gt;setBackground(QColorFromColourRGBA(back));
423  	GetPainter()-&gt;setBackgroundMode(Qt::OpaqueMode);
424  	QString su = UnicodeFromText(codec, text);
425  	GetPainter()-&gt;drawText(QPointF(rc.left, ybase), su);
426  }
427  void SurfaceImpl::DrawTextClipped(PRectangle rc,
428  				  const Font *font,
429                                    XYPOSITION ybase,
430  				  std::string_view text,
431  				  ColourRGBA fore,
432  				  ColourRGBA back)
433  {
434  	SetClip(rc);
435  	DrawTextNoClip(rc, font, ybase, text, fore, back);
436  	PopClip();
437  }
438  void SurfaceImpl::DrawTextTransparent(PRectangle rc,
439  				      const Font *font,
440                                        XYPOSITION ybase,
441  				      std::string_view text,
442  	ColourRGBA fore)
443  {
444  	SetFont(font);
445  	PenColour(fore);
446  	GetPainter()-&gt;setBackgroundMode(Qt::TransparentMode);
447  	QString su = UnicodeFromText(codec, text);
448  	GetPainter()-&gt;drawText(QPointF(rc.left, ybase), su);
449  }
450  void SurfaceImpl::SetClip(PRectangle rc)
451  {
452  	GetPainter()-&gt;save();
453  	GetPainter()-&gt;setClipRect(QRectFFromPRect(rc), Qt::IntersectClip);
454  }
455  void SurfaceImpl::PopClip()
456  {
457  	GetPainter()-&gt;restore();
458  }
459  void SurfaceImpl::MeasureWidths(const Font *font,
460  				std::string_view text,
461                                  XYPOSITION *positions)
462  {
463  	if (!font)
464  		return;
465  	SetCodec(font);
466  	QString su = UnicodeFromText(codec, text);
467  	QTextLayout tlay(su, *FontPointer(font), GetPaintDevice());
468  	tlay.beginLayout();
469  	QTextLine tl = tlay.createLine();
470  	tlay.endLayout();
471  	if (mode.codePage == SC_CP_UTF8) {
472  		int fit = su.size();
473  		int ui=0;
474  		size_t i=0;
475  		while (ui&lt;fit) {
476  			const unsigned char uch = text[i];
477  			const unsigned int byteCount = UTF8BytesOfLead[uch];
478  			const int codeUnits = UTF16LengthFromUTF8ByteCount(byteCount);
479  			qreal xPosition = tl.cursorToX(ui+codeUnits);
480  			for (size_t bytePos=0; (bytePos&lt;byteCount) &amp;&amp; (i&lt;text.length()); bytePos++) {
481  				positions[i++] = xPosition;
482  			}
483  			ui += codeUnits;
484  		}
485  		XYPOSITION lastPos = 0;
486  		if (i &gt; 0)
487  			lastPos = positions[i-1];
488  		while (i&lt;text.length()) {
489  			positions[i++] = lastPos;
490  		}
491  	} else if (mode.codePage) {
492  		int ui = 0;
493  		for (size_t i=0; i&lt;text.length();) {
494  			size_t lenChar = DBCSIsLeadByte(mode.codePage, text[i]) ? 2 : 1;
495  			qreal xPosition = tl.cursorToX(ui+1);
496  			for (unsigned int bytePos=0; (bytePos&lt;lenChar) &amp;&amp; (i&lt;text.length()); bytePos++) {
497  				positions[i++] = xPosition;
498  			}
499  			ui++;
500  		}
501  	} else {
502  		for (int i=0; i&lt;static_cast&lt;int&gt;(text.length()); i++) {
503  			positions[i] = tl.cursorToX(i+1);
504  		}
505  	}
506  }
507  XYPOSITION SurfaceImpl::WidthText(const Font *font, std::string_view text)
508  {
509  	QFontMetricsF metrics(*FontPointer(font), device);
510  	SetCodec(font);
511  	QString su = UnicodeFromText(codec, text);
512  #if QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0)
513  	return metrics.horizontalAdvance(su);
514  #else
515  	return metrics.width(su);
516  #endif
517  }
518  void SurfaceImpl::DrawTextNoClipUTF8(PRectangle rc,
519  				 const Font *font,
520  				 XYPOSITION ybase,
521  				 std::string_view text,
522  				 ColourRGBA fore,
523  				 ColourRGBA back)
524  {
525  	SetFont(font);
526  	PenColour(fore);
527  	GetPainter()-&gt;setBackground(QColorFromColourRGBA(back));
528  	GetPainter()-&gt;setBackgroundMode(Qt::OpaqueMode);
529  	QString su = QString::fromUtf8(text.data(), static_cast&lt;int&gt;(text.length()));
530  	GetPainter()-&gt;drawText(QPointF(rc.left, ybase), su);
531  }
532  void SurfaceImpl::DrawTextClippedUTF8(PRectangle rc,
533  				  const Font *font,
534  				  XYPOSITION ybase,
535  				  std::string_view text,
536  				  ColourRGBA fore,
537  				  ColourRGBA back)
538  {
539  	SetClip(rc);
540  	DrawTextNoClip(rc, font, ybase, text, fore, back);
541  	PopClip();
542  }
543  void SurfaceImpl::DrawTextTransparentUTF8(PRectangle rc,
544  				      const Font *font,
545  				      XYPOSITION ybase,
546  				      std::string_view text,
547  	ColourRGBA fore)
548  {
549  	SetFont(font);
550  	PenColour(fore);
551  	GetPainter()-&gt;setBackgroundMode(Qt::TransparentMode);
552  	QString su = QString::fromUtf8(text.data(), static_cast&lt;int&gt;(text.length()));
553  	GetPainter()-&gt;drawText(QPointF(rc.left, ybase), su);
554  }
555  void SurfaceImpl::MeasureWidthsUTF8(const Font *font,
556  				std::string_view text,
557  				XYPOSITION *positions)
558  {
559  	if (!font)
560  		return;
561  	QString su = QString::fromUtf8(text.data(), static_cast&lt;int&gt;(text.length()));
562  	QTextLayout tlay(su, *FontPointer(font), GetPaintDevice());
563  	tlay.beginLayout();
564  	QTextLine tl = tlay.createLine();
565  	tlay.endLayout();
566  	int fit = su.size();
567  	int ui=0;
568  	size_t i=0;
569  	while (ui&lt;fit) {
570  		const unsigned char uch = text[i];
571  		const unsigned int byteCount = UTF8BytesOfLead[uch];
572  		const int codeUnits = UTF16LengthFromUTF8ByteCount(byteCount);
573  		qreal xPosition = tl.cursorToX(ui+codeUnits);
574  		for (size_t bytePos=0; (bytePos&lt;byteCount) &amp;&amp; (i&lt;text.length()); bytePos++) {
575  			positions[i++] = xPosition;
576  		}
577  		ui += codeUnits;
578  	}
579  	XYPOSITION lastPos = 0;
580  	if (i &gt; 0)
581  		lastPos = positions[i-1];
582  	while (i&lt;text.length()) {
583  		positions[i++] = lastPos;
584  	}
585  }
586  XYPOSITION SurfaceImpl::WidthTextUTF8(const Font *font, std::string_view text)
587  {
588  	QFontMetricsF metrics(*FontPointer(font), device);
589  	QString su = QString::fromUtf8(text.data(), static_cast&lt;int&gt;(text.length()));
590  #if QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0)
591  	return metrics.horizontalAdvance(su);
592  #else
593  	return metrics.width(su);
594  #endif
595  }
596  XYPOSITION SurfaceImpl::Ascent(const Font *font)
597  {
598  	QFontMetricsF metrics(*FontPointer(font), device);
599  	return metrics.ascent();
600  }
601  XYPOSITION SurfaceImpl::Descent(const Font *font)
602  {
603  	QFontMetricsF metrics(*FontPointer(font), device);
604  	return metrics.descent() + 1;
605  }
606  XYPOSITION SurfaceImpl::InternalLeading(const Font * &amp;bsol;* font */)
607  {
608  	return 0;
609  }
610  XYPOSITION SurfaceImpl::Height(const Font *font)
611  {
612  	QFontMetricsF metrics(*FontPointer(font), device);
613  	return metrics.height();
614  }
615  XYPOSITION SurfaceImpl::AverageCharWidth(const Font *font)
616  {
617  	QFontMetricsF metrics(*FontPointer(font), device);
618  	return metrics.averageCharWidth();
619  }
620  void SurfaceImpl::FlushCachedState()
621  {
622  	if (device-&gt;paintingActive()) {
623  		GetPainter()-&gt;setPen(QPen());
624  		GetPainter()-&gt;setBrush(QBrush());
625  	}
626  }
627  void SurfaceImpl::FlushDrawing()
628  {
629  }
630  QPaintDevice *SurfaceImpl::GetPaintDevice()
631  {
632  	return device;
633  }
634  QPainter *SurfaceImpl::GetPainter()
635  {
636  	Q_ASSERT(device);
637  	if (!painter) {
638  		if (device-&gt;paintingActive()) {
639  			painter = device-&gt;paintEngine()-&gt;painter();
640  		} else {
641  			painterOwned = true;
642  			painter = new QPainter(device);
643  		}
644  		painter-&gt;setRenderHint(QPainter::TextAntialiasing, true);
645  		painter-&gt;setRenderHint(QPainter::Antialiasing, true);
646  	}
647  	return painter;
648  }
649  std::unique_ptr&lt;Surface&gt; Surface::Allocate(Technology)
650  {
651  	return std::make_unique&lt;SurfaceImpl&gt;();
652  }
653  namespace {
654  QWidget *window(WindowID wid) noexcept
655  {
656  	return static_cast&lt;QWidget *&gt;(wid);
657  }
658  QRect ScreenRectangleForPoint(QPoint posGlobal)
659  {
660  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 10, 0)
661  	const QScreen *screen = QGuiApplication::screenAt(posGlobal);
662  	if (!screen) {
663  		screen = QGuiApplication::primaryScreen();
664  	}
665  	return screen-&gt;availableGeometry();
666  #else
667  	const QDesktopWidget *desktop = QApplication::desktop();
668  	return desktop-&gt;availableGeometry(posGlobal);
669  #endif
670  }
671  }
672  Window::~Window() noexcept = default;
673  void Window::Destroy() noexcept
674  {
675  	if (wid)
676  		delete window(wid);
677  	wid = nullptr;
678  }
679  PRectangle Window::GetPosition() const
680  {
681  	return wid ? PRectFromQRect(window(wid)-&gt;frameGeometry()) : PRectangle(0, 0, 1000, 1000);
682  }
683  void Window::SetPosition(PRectangle rc)
684  {
685  	if (wid)
686  		window(wid)-&gt;setGeometry(QRectFromPRect(rc));
687  }
688  void Window::SetPositionRelative(PRectangle rc, const Window *relativeTo)
689  {
690  	QPoint oPos = window(relativeTo-&gt;wid)-&gt;mapToGlobal(QPoint(0,0));
691  	int ox = oPos.x();
692  	int oy = oPos.y();
693  	ox += rc.left;
694  	oy += rc.top;
695  	const QRect rectDesk = ScreenRectangleForPoint(QPoint(ox, oy));
696  	int sizex = rc.right - rc.left;
697  	int sizey = rc.bottom - rc.top;
698  	int screenWidth = rectDesk.width();
699  	if (ox &lt; rectDesk.x())
700  		ox = rectDesk.x();
701  	if (sizex &gt; screenWidth)
702  		ox = rectDesk.x(); &amp;bsol;* the best we can do */
703  	else if (ox + sizex &gt; rectDesk.right())
704  		ox = rectDesk.right() - sizex;
705  	if (oy + sizey &gt; rectDesk.bottom())
706  		oy = rectDesk.bottom() - sizey;
707  	if (oy &lt; rectDesk.top())
708  		oy = rectDesk.top();
709  	Q_ASSERT(wid);
710  	window(wid)-&gt;move(ox, oy);
711  	window(wid)-&gt;resize(sizex, sizey);
712  }
713  PRectangle Window::GetClientPosition() const
714  {
715  	return GetPosition();
716  }
717  void Window::Show(bool show)
718  {
719  	if (wid)
720  		window(wid)-&gt;setVisible(show);
721  }
722  void Window::InvalidateAll()
723  {
724  	if (wid)
725  		window(wid)-&gt;update();
726  }
727  void Window::InvalidateRectangle(PRectangle rc)
728  {
729  	if (wid)
730  		window(wid)-&gt;update(QRectFromPRect(rc));
731  }
732  void Window::SetCursor(Cursor curs)
733  {
734  	if (wid) {
735  		Qt::CursorShape shape;
736  		switch (curs) {
737  			case Cursor::text:  shape = Qt::IBeamCursor;        break;
738  			case Cursor::arrow: shape = Qt::ArrowCursor;        break;
739  			case Cursor::up:    shape = Qt::UpArrowCursor;      break;
740  			case Cursor::wait:  shape = Qt::WaitCursor;         break;
741  			case Cursor::horizontal: shape = Qt::SizeHorCursor; break;
742  			case Cursor::vertical:  shape = Qt::SizeVerCursor;  break;
743  			case Cursor::hand:  shape = Qt::PointingHandCursor; break;
744  			default:            shape = Qt::ArrowCursor;        break;
745  		}
746  		QCursor cursor = QCursor(shape);
747  		if (curs != cursorLast) {
748  			window(wid)-&gt;setCursor(cursor);
749  			cursorLast = curs;
750  		}
751  	}
752  }
753  PRectangle Window::GetMonitorRect(Point pt)
754  {
755  	const QPoint posGlobal = window(wid)-&gt;mapToGlobal(QPoint(pt.x, pt.y));
756  	const QPoint originGlobal = window(wid)-&gt;mapToGlobal(QPoint(0, 0));
757  	QRect rectScreen = ScreenRectangleForPoint(posGlobal);
758  	rectScreen.translate(-originGlobal.x(), -originGlobal.y());
759  	return PRectFromQRect(rectScreen);
760  }
761  class ListWidget : public QListWidget {
762  public:
763  	explicit ListWidget(QWidget *parent);
764  	void setDelegate(IListBoxDelegate *lbDelegate);
765  	int currentSelection();
766  protected:
767  	void selectionChanged(const QItemSelection &amp;selected, const QItemSelection &amp;deselected) override;
768  	void mouseDoubleClickEvent(QMouseEvent *event) override;
769  #if QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0)
770  	void initViewItemOption(QStyleOptionViewItem *option) const override;
771  #else
772  	QStyleOptionViewItem viewOptions() const override;
773  #endif
774  private:
775  	IListBoxDelegate *delegate;
776  };
777  class ListBoxImpl : public ListBox {
778  public:
779  	ListBoxImpl() noexcept;
780  	void SetFont(const Font *font) override;
781  	void Create(Window &amp;parent, int ctrlID, Point location,
782  						int lineHeight, bool unicodeMode_, Technology technology) override;
783  	void SetAverageCharWidth(int width) override;
784  	void SetVisibleRows(int rows) override;
785  	int GetVisibleRows() const override;
786  	PRectangle GetDesiredRect() override;
787  	int CaretFromEdge() override;
788  	void Clear() noexcept override;
789  	void Append(char *s, int type) override;
790  	int Length() override;
791  	void Select(int n) override;
792  	int GetSelection() override;
793  	int Find(const char *prefix) override;
794  	std::string GetValue(int n) override;
795  	void RegisterImage(int type, const char *xpmData) override;
796  	void RegisterRGBAImage(int type, int width, int height,
797  		const unsigned char *pixelsImage) override;
798  	virtual void RegisterQPixmapImage(int type, const QPixmap&amp; pm);
799  	void ClearRegisteredImages() override;
800  	void SetDelegate(IListBoxDelegate *lbDelegate) override;
801  	void SetList(const char *list, char separator, char typesep) override;
802  	void SetOptions(ListOptions options_) override;
803  	[[nodiscard]] ListWidget *GetWidget() const noexcept;
804  private:
805  	bool unicodeMode{false};
806  	int visibleRows{5};
807  	QMap&lt;int,QPixmap&gt; images;
808  };
809  ListBoxImpl::ListBoxImpl() noexcept = default;
810  void ListBoxImpl::Create(Window &amp;parent,
811                           int &amp;bsol;*ctrlID*/,
812                           Point location,
813                           int &amp;bsol;*lineHeight*/,
814                           bool unicodeMode_,
815  			 Technology)
816  {
817  	unicodeMode = unicodeMode_;
818  	QWidget *qparent = static_cast&lt;QWidget *&gt;(parent.GetID());
819  	ListWidget *list = new ListWidget(qparent);
820  #if defined(Q_OS_WIN)
821  	list-&gt;setParent(nullptr, Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint
822  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 0, 0)
823  		| Qt::WindowDoesNotAcceptFocus
824  #endif
825  	);
826  #else
827  	list-&gt;setParent(nullptr, static_cast&lt;Qt::WindowFlags&gt;(Qt::ToolTip | Qt::FramelessWindowHint));
828  #endif
829  	list-&gt;setAttribute(Qt::WA_ShowWithoutActivating);
830  	list-&gt;setFocusPolicy(Qt::NoFocus);
831  	list-&gt;setUniformItemSizes(true);
832  	list-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
833  	list-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
834  	list-&gt;move(location.x, location.y);
835  	int maxIconWidth = 0;
836  	int maxIconHeight = 0;
837  	foreach (QPixmap im, images) {
838  		if (maxIconWidth &lt; im.width())
839  			maxIconWidth = im.width();
840  		if (maxIconHeight &lt; im.height())
841  			maxIconHeight = im.height();
842  	}
843  	list-&gt;setIconSize(QSize(maxIconWidth, maxIconHeight));
844  	wid = list;
845  }
846  void ListBoxImpl::SetFont(const Font *font)
847  {
848  	ListWidget *list = GetWidget();
849  	const FontAndCharacterSet *pfacs = AsFontAndCharacterSet(font);
850  	if (pfacs &amp;&amp; pfacs-&gt;pfont) {
851  		list-&gt;setFont(*(pfacs-&gt;pfont));
852  	}
853  }
854  void ListBoxImpl::SetAverageCharWidth(int &amp;bsol;*width*/) {}
855  void ListBoxImpl::SetVisibleRows(int rows)
856  {
857  	visibleRows = rows;
858  }
859  int ListBoxImpl::GetVisibleRows() const
860  {
861  	return visibleRows;
862  }
863  PRectangle ListBoxImpl::GetDesiredRect()
864  {
865  	ListWidget *list = GetWidget();
866  	int rows = Length();
867  	if (rows == 0 || rows &gt; visibleRows) {
868  		rows = visibleRows;
869  	}
870  	int rowHeight = list-&gt;sizeHintForRow(0);
871  	int height = (rows * rowHeight) + (2 * list-&gt;frameWidth());
872  	QStyle *style = QApplication::style();
873  	int width = list-&gt;sizeHintForColumn(0) + (2 * list-&gt;frameWidth());
874  	if (Length() &gt; rows) {
875  		width += style-&gt;pixelMetric(QStyle::PM_ScrollBarExtent);
876  	}
877  	return PRectangle(0, 0, width, height);
878  }
879  int ListBoxImpl::CaretFromEdge()
880  {
881  	ListWidget *list = GetWidget();
882  	int maxIconWidth = 0;
883  	foreach (QPixmap im, images) {
884  		if (maxIconWidth &lt; im.width())
885  			maxIconWidth = im.width();
886  	}
887  	int extra;
888  #ifdef Q_OS_DARWIN
889  	extra = 12;
890  #else
891  	extra = 7;
892  #endif
893  	return maxIconWidth + (2 * list-&gt;frameWidth()) + extra;
894  }
895  void ListBoxImpl::Clear() noexcept
896  {
897  	ListWidget *list = GetWidget();
898  	list-&gt;clear();
899  }
900  void ListBoxImpl::Append(char *s, int type)
901  {
902  	ListWidget *list = GetWidget();
903  	QString str = unicodeMode ? QString::fromUtf8(s) : QString::fromLocal8Bit(s);
904  	QIcon icon;
905  	if (type &gt;= 0) {
906  		Q_ASSERT(images.contains(type));
907  		icon = images.value(type);
908  	}
909  	new QListWidgetItem(icon, str, list);
910  }
911  int ListBoxImpl::Length()
912  {
913  	ListWidget *list = GetWidget();
914  	return list-&gt;count();
915  }
916  void ListBoxImpl::Select(int n)
917  {
918  	ListWidget *list = GetWidget();
919  	QModelIndex index = list-&gt;model()-&gt;index(n, 0);
920  	if (index.isValid()) {
921  		QRect row_rect = list-&gt;visualRect(index);
922  		if (!list-&gt;viewport()-&gt;rect().contains(row_rect)) {
923  			list-&gt;scrollTo(index, QAbstractItemView::PositionAtTop);
924  		}
925  	}
926  	list-&gt;setCurrentRow(n);
927  }
928  int ListBoxImpl::GetSelection()
929  {
930  	ListWidget *list = GetWidget();
931  	return list-&gt;currentSelection();
932  }
933  int ListBoxImpl::Find(const char *prefix)
934  {
935  	ListWidget *list = GetWidget();
936  	QString sPrefix = unicodeMode ? QString::fromUtf8(prefix) : QString::fromLocal8Bit(prefix);
937  	QList&lt;QListWidgetItem *&gt; ms = list-&gt;findItems(sPrefix, Qt::MatchStartsWith);
938  	int result = -1;
939  	if (!ms.isEmpty()) {
940  		result = list-&gt;row(ms.first());
941  	}
942  	return result;
943  }
944  std::string ListBoxImpl::GetValue(int n)
945  {
946  	ListWidget *list = GetWidget();
947  	QListWidgetItem *item = list-&gt;item(n);
948  	QString str = item-&gt;data(Qt::DisplayRole).toString();
949  	QByteArray bytes = unicodeMode ? str.toUtf8() : str.toLocal8Bit();
950  	return std::string(bytes.constData());
951  }
952  void ListBoxImpl::RegisterQPixmapImage(int type, const QPixmap&amp; pm)
953  {
954  	images[type] = pm;
955  	ListWidget *list = GetWidget();
956  	if (list) {
957  		QSize iconSize = list-&gt;iconSize();
958  		if (pm.width() &gt; iconSize.width() || pm.height() &gt; iconSize.height())
959  			list-&gt;setIconSize(QSize(qMax(pm.width(), iconSize.width()),
960  						 qMax(pm.height(), iconSize.height())));
961  	}
962  }
963  void ListBoxImpl::RegisterImage(int type, const char *xpmData)
964  {
965  	XPM xpmImage(xpmData);
966  	RGBAImage rgbaImage(xpmImage);
967  	RegisterRGBAImage(type, rgbaImage.GetWidth(), rgbaImage.GetHeight(), rgbaImage.Pixels());
968  }
969  void ListBoxImpl::RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage)
970  {
971  	std::vector&lt;unsigned char&gt; imageBytes = ImageByteSwapped(width, height, pixelsImage);
972  	QImage image(&amp;imageBytes[0], width, height, QImage::Format_ARGB32);
973  	RegisterQPixmapImage(type, QPixmap::fromImage(image));
974  }
975  void ListBoxImpl::ClearRegisteredImages()
976  {
977  	images.clear();
978  	ListWidget *list = GetWidget();
979  	if (list)
980  		list-&gt;setIconSize(QSize(0, 0));
981  }
982  void ListBoxImpl::SetDelegate(IListBoxDelegate *lbDelegate)
983  {
984  	ListWidget *list = GetWidget();
985  	list-&gt;setDelegate(lbDelegate);
986  }
987  void ListBoxImpl::SetList(const char *list, char separator, char typesep)
988  {
989  	Clear();
990  	size_t count = strlen(list) + 1;
991  	std::vector&lt;char&gt; words(list, list+count);
992  	char *startword = &amp;words[0];
993  	char *numword = nullptr;
994  	int i = 0;
995  	for (; words[i]; i++) {
996  		if (words[i] == separator) {
997  			words[i] = &#x27;\0&#x27;;
998  			if (numword)
999  				*numword = &#x27;\0&#x27;;
1000  			Append(startword, numword?atoi(numword + 1):-1);
1001  			startword = &amp;words[0] + i + 1;
1002  			numword = nullptr;
1003  		} else if (words[i] == typesep) {
1004  			numword = &amp;words[0] + i;
1005  		}
1006  	}
1007  	if (startword) {
1008  		if (numword)
1009  			*numword = &#x27;\0&#x27;;
1010  		Append(startword, numword?atoi(numword + 1):-1);
1011  	}
1012  }
1013  void ListBoxImpl::SetOptions(ListOptions)
1014  {
1015  }
1016  ListWidget *ListBoxImpl::GetWidget() const noexcept
1017  {
1018  	return static_cast&lt;ListWidget *&gt;(wid);
1019  }
1020  ListBox::ListBox() noexcept = default;
1021  ListBox::~ListBox() noexcept = default;
1022  std::unique_ptr&lt;ListBox&gt; ListBox::Allocate()
1023  {
1024  	return std::make_unique&lt;ListBoxImpl&gt;();
1025  }
1026  ListWidget::ListWidget(QWidget *parent)
1027  : QListWidget(parent), delegate(nullptr)
1028  {}
1029  void ListWidget::setDelegate(IListBoxDelegate *lbDelegate)
1030  {
1031  	delegate = lbDelegate;
1032  }
1033  void ListWidget::selectionChanged(const QItemSelection &amp;selected, const QItemSelection &amp;deselected) {
1034  	QListWidget::selectionChanged(selected, deselected);
1035  	if (delegate) {
1036  		const int selection = currentSelection();
1037  		if (selection &gt;= 0) {
1038  			ListBoxEvent event(ListBoxEvent::EventType::selectionChange);
1039  			delegate-&gt;ListNotify(&amp;event);
1040  		}
1041  	}
1042  }
1043  int ListWidget::currentSelection() {
1044  	const QModelIndexList indices = selectionModel()-&gt;selectedRows();
1045  	foreach (const QModelIndex ind, indices) {
1046  		return ind.row();
1047  	}
1048  	return -1;
1049  }
<span onclick='openModal()' class='match'>1050  void ListWidget::mouseDoubleClickEvent(QMouseEvent * &amp;bsol;* event */)
1051  {
1052  	if (delegate) {
</span>1053  		ListBoxEvent event(ListBoxEvent::EventType::doubleClick);
1054  		delegate-&gt;ListNotify(&amp;event);
1055  	}
1056  }
1057  #if QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0)
1058  void ListWidget::initViewItemOption(QStyleOptionViewItem *option) const
1059  {
1060  	QListWidget::initViewItemOption(option);
1061  	option-&gt;state |= QStyle::State_Active;
1062  }
1063  #else
1064  QStyleOptionViewItem ListWidget::viewOptions() const
1065  {
1066  	QStyleOptionViewItem result = QListWidget::viewOptions();
1067  	result.state |= QStyle::State_Active;
1068  	return result;
1069  }
1070  #endif
1071  Menu::Menu() noexcept : mid(nullptr) {}
1072  void Menu::CreatePopUp()
1073  {
1074  	Destroy();
1075  	mid = new QMenu();
1076  }
1077  void Menu::Destroy() noexcept
1078  {
1079  	if (mid) {
1080  		QMenu *menu = static_cast&lt;QMenu *&gt;(mid);
1081  		delete menu;
1082  	}
1083  	mid = nullptr;
1084  }
1085  void Menu::Show(Point pt, const Window &amp; &amp;bsol;*w*/)
1086  {
1087  	QMenu *menu = static_cast&lt;QMenu *&gt;(mid);
1088  	menu-&gt;exec(QPoint(pt.x, pt.y));
1089  	Destroy();
1090  }
1091  ColourRGBA Platform::Chrome()
1092  {
1093  	QColor c(Qt::gray);
1094  	return ColourRGBA(c.red(), c.green(), c.blue());
1095  }
1096  ColourRGBA Platform::ChromeHighlight()
1097  {
1098  	QColor c(Qt::lightGray);
1099  	return ColourRGBA(c.red(), c.green(), c.blue());
1100  }
1101  const char *Platform::DefaultFont()
1102  {
1103  	static char fontNameDefault[200] = &quot;&quot;;
1104  	if (!fontNameDefault[0]) {
1105  		QFont font = QApplication::font();
1106  		strcpy(fontNameDefault, font.family().toUtf8());
1107  	}
1108  	return fontNameDefault;
1109  }
1110  int Platform::DefaultFontSize()
1111  {
1112  	QFont font = QApplication::font();
1113  	return font.pointSize();
1114  }
1115  unsigned int Platform::DoubleClickTime()
1116  {
1117  	return QApplication::doubleClickInterval();
1118  }
1119  void Platform::DebugDisplay(const char *s) noexcept
1120  {
1121  	qWarning(&quot;Scintilla: %s&quot;, s);
1122  }
1123  void Platform::DebugPrintf(const char *format, ...) noexcept
1124  {
1125  	char buffer[2000];
1126  	va_list pArguments{};
1127  	va_start(pArguments, format);
1128  	vsnprintf(buffer, std::size(buffer), format, pArguments);
1129  	va_end(pArguments);
1130  	Platform::DebugDisplay(buffer);
1131  }
1132  bool Platform::ShowAssertionPopUps(bool &amp;bsol;*assertionPopUps*/) noexcept
1133  {
1134  	return false;
1135  }
1136  void Platform::Assert(const char *c, const char *file, int line) noexcept
1137  {
1138  	char buffer[2000];
1139  	snprintf(buffer, std::size(buffer), &quot;Assertion [%s] failed at %s %d&quot;, c, file, line);
1140  	if (Platform::ShowAssertionPopUps(false)) {
1141  		QMessageBox mb(&quot;Assertion Failure&quot;, buffer, QMessageBox::NoIcon,
1142  			QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
1143  		mb.exec();
1144  	} else {
1145  		strcat(buffer, &quot;\n&quot;);
1146  		Platform::DebugDisplay(buffer);
1147  	}
1148  }
1149  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditBase.cpp</h3>
            <pre><code>1  #include &quot;ScintillaEditBase.h&quot;
2  #include &quot;ScintillaQt.h&quot;
3  #include &quot;PlatQt.h&quot;
4  #include &lt;QApplication&gt;
5  #if QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
6  #include &lt;QInputContext&gt;
7  #endif
8  #include &lt;QPainter&gt;
9  #include &lt;QVarLengthArray&gt;
10  #include &lt;QScrollBar&gt;
11  #include &lt;QTextFormat&gt;
12  constexpr int IndicatorInput = static_cast&lt;int&gt;(Scintilla::IndicatorNumbers::Ime);
13  constexpr int IndicatorTarget = IndicatorInput + 1;
14  constexpr int IndicatorConverted = IndicatorInput + 2;
15  constexpr int IndicatorUnknown = IndicatorInput + 3;
16  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 0, 0)
17  #ifdef Q_OS_MAC
18  #define Q_WS_MAC 1
19  #endif
20  #if !defined(Q_OS_MAC) &amp;&amp; !defined(Q_OS_WIN)
21  #define Q_WS_X11 1
22  #endif
23  #endif 
24  using namespace Scintilla;
25  using namespace Scintilla::Internal;
26  ScintillaEditBase::ScintillaEditBase(QWidget *parent)
27  : QAbstractScrollArea(parent), sqt(new ScintillaQt(this)), preeditPos(-1), wheelDelta(0)
28  {
29  	time.start();
30  	setAcceptDrops(true);
31  	setMouseTracking(true);
32  	setAutoFillBackground(false);
33  	setFrameStyle(QFrame::NoFrame);
34  	setFocusPolicy(Qt::StrongFocus);
35  	setAttribute(Qt::WA_StaticContents);
36  	viewport()-&gt;setAutoFillBackground(false);
37  	setAttribute(Qt::WA_KeyCompression);
38  	setAttribute(Qt::WA_InputMethodEnabled);
39  	const ColourRGBA colourIME(0, 0, UCHAR_MAX);
40  	sqt-&gt;vs.indicators[IndicatorUnknown] = Indicator(IndicatorStyle::Hidden, colourIME);
41  	sqt-&gt;vs.indicators[IndicatorInput] = Indicator(IndicatorStyle::Dots, colourIME);
42  	sqt-&gt;vs.indicators[IndicatorConverted] = Indicator(IndicatorStyle::CompositionThick, colourIME);
43  	sqt-&gt;vs.indicators[IndicatorTarget] = Indicator(IndicatorStyle::StraightBox, colourIME);
44  	connect(sqt, SIGNAL(notifyParent(Scintilla::NotificationData)),
45  		this, SLOT(notifyParent(Scintilla::NotificationData)));
46  	connect(verticalScrollBar(), SIGNAL(valueChanged(int)),
47  	        this, SLOT(scrollVertical(int)));
48  	connect(horizontalScrollBar(), SIGNAL(valueChanged(int)),
49  	        this, SLOT(scrollHorizontal(int)));
50  	connect(sqt, SIGNAL(horizontalRangeChanged(int,int)),
51  	        this, SIGNAL(horizontalRangeChanged(int,int)));
52  	connect(sqt, SIGNAL(verticalRangeChanged(int,int)),
53  	        this, SIGNAL(verticalRangeChanged(int,int)));
54  	connect(sqt, SIGNAL(horizontalScrolled(int)),
55  	        this, SIGNAL(horizontalScrolled(int)));
56  	connect(sqt, SIGNAL(verticalScrolled(int)),
57  	        this, SIGNAL(verticalScrolled(int)));
58  	connect(sqt, SIGNAL(notifyChange()),
59  	        this, SIGNAL(notifyChange()));
60  	connect(sqt, SIGNAL(command(Scintilla::uptr_t,Scintilla::sptr_t)),
61  		this, SLOT(event_command(Scintilla::uptr_t,Scintilla::sptr_t)));
62  	connect(sqt, SIGNAL(aboutToCopy(QMimeData*)),
63  		this, SIGNAL(aboutToCopy(QMimeData*)));
64  }
65  ScintillaEditBase::~ScintillaEditBase() = default;
66  sptr_t ScintillaEditBase::send(
67  	unsigned int iMessage,
68  	uptr_t wParam,
69  	sptr_t lParam) const
70  {
71  	return sqt-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
72  }
73  sptr_t ScintillaEditBase::sends(
74      unsigned int iMessage,
75      uptr_t wParam,
76      const char *s) const
77  {
78  	return sqt-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, reinterpret_cast&lt;sptr_t&gt;(s));
79  }
80  void ScintillaEditBase::scrollHorizontal(int value)
81  {
82  	sqt-&gt;HorizontalScrollTo(value);
83  }
84  void ScintillaEditBase::scrollVertical(int value)
85  {
86  	sqt-&gt;ScrollTo(value);
87  }
88  bool ScintillaEditBase::event(QEvent *event)
89  {
90  	bool result = false;
91  	if (event-&gt;type() == QEvent::KeyPress) {
92  		keyPressEvent(static_cast&lt;QKeyEvent *&gt;(event));
93  		result = event-&gt;isAccepted();
94  	} else if (event-&gt;type() == QEvent::Show) {
95  		setMouseTracking(true);
96  		result = QAbstractScrollArea::event(event);
97  	} else if (event-&gt;type() == QEvent::Hide) {
98  		setMouseTracking(false);
99  		result = QAbstractScrollArea::event(event);
100  	} else {
101  		result = QAbstractScrollArea::event(event);
102  	}
103  	return result;
104  }
105  void ScintillaEditBase::paintEvent(QPaintEvent *event)
106  {
107  	sqt-&gt;PartialPaint(PRectFromQRect(event-&gt;rect()));
108  }
109  namespace {
110  bool isWheelEventHorizontal(QWheelEvent *event) {
111  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 15, 0)
112  	return event-&gt;angleDelta().y() == 0;
113  #else
114  	return event-&gt;orientation() == Qt::Horizontal;
115  #endif
116  }
117  int wheelEventYDelta(QWheelEvent *event) {
118  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 15, 0)
119  	return event-&gt;angleDelta().y();
120  #else
121  	return event-&gt;delta();
122  #endif
123  }
124  }
125  void ScintillaEditBase::wheelEvent(QWheelEvent *event)
126  {
127  	if (isWheelEventHorizontal(event)) {
128  		QAbstractScrollArea::wheelEvent(event);
129  	} else {
130  		if (QApplication::keyboardModifiers() &amp; Qt::ControlModifier) {
131  			if (wheelEventYDelta(event) &gt; 0) {
132  				sqt-&gt;KeyCommand(Message::ZoomIn);
133  			} else {
134  				sqt-&gt;KeyCommand(Message::ZoomOut);
135  			}
136  		} else {
137  			QAbstractScrollArea::wheelEvent(event);
138  		}
139  	}
140  }
141  void ScintillaEditBase::focusInEvent(QFocusEvent *event)
142  {
143  	sqt-&gt;SetFocusState(true);
144  	QAbstractScrollArea::focusInEvent(event);
145  }
146  void ScintillaEditBase::focusOutEvent(QFocusEvent *event)
147  {
148  	sqt-&gt;SetFocusState(false);
149  	QAbstractScrollArea::focusOutEvent(event);
150  }
151  void ScintillaEditBase::resizeEvent(QResizeEvent *)
152  {
153  	sqt-&gt;ChangeSize();
154  	emit resized();
155  }
156  void ScintillaEditBase::keyPressEvent(QKeyEvent *event)
157  {
158  	if (QApplication::keyboardModifiers() &amp; Qt::MetaModifier) {
159  		QAbstractScrollArea::keyPressEvent(event);
160  		emit keyPressed(event);
161  		return;
162  	}
163  	int key = 0;
164  	switch (event-&gt;key()) {
165  		case Qt::Key_Down:          key = SCK_DOWN;     break;
166  		case Qt::Key_Up:            key = SCK_UP;       break;
167  		case Qt::Key_Left:          key = SCK_LEFT;     break;
168  		case Qt::Key_Right:         key = SCK_RIGHT;    break;
169  		case Qt::Key_Home:          key = SCK_HOME;     break;
170  		case Qt::Key_End:           key = SCK_END;      break;
171  		case Qt::Key_PageUp:        key = SCK_PRIOR;    break;
172  		case Qt::Key_PageDown:      key = SCK_NEXT;     break;
173  		case Qt::Key_Delete:        key = SCK_DELETE;   break;
174  		case Qt::Key_Insert:        key = SCK_INSERT;   break;
175  		case Qt::Key_Escape:        key = SCK_ESCAPE;   break;
176  		case Qt::Key_Backspace:     key = SCK_BACK;     break;
177  		case Qt::Key_Plus:          key = SCK_ADD;      break;
178  		case Qt::Key_Minus:         key = SCK_SUBTRACT; break;
179  		case Qt::Key_Backtab:       
180  		case Qt::Key_Tab:           key = SCK_TAB;      break;
181  		case Qt::Key_Enter:         
182  		case Qt::Key_Return:        key = SCK_RETURN;   break;
183  		case Qt::Key_Control:       key = 0;            break;
184  		case Qt::Key_Alt:           key = 0;            break;
185  		case Qt::Key_Shift:         key = 0;            break;
186  		case Qt::Key_Meta:          key = 0;            break;
187  		default:                    key = event-&gt;key(); break;
188  	}
189  	bool shift = QApplication::keyboardModifiers() &amp; Qt::ShiftModifier;
190  	bool ctrl  = QApplication::keyboardModifiers() &amp; Qt::ControlModifier;
191  	bool alt   = QApplication::keyboardModifiers() &amp; Qt::AltModifier;
192  	bool consumed = false;
193  	bool added = sqt-&gt;KeyDownWithModifiers(static_cast&lt;Keys&gt;(key),
194  					       ModifierFlags(shift, ctrl, alt),
195  					       &amp;consumed) != 0;
196  	if (!consumed)
197  		consumed = added;
198  	if (!consumed) {
199  		bool input = (!ctrl || alt);
200  #ifndef Q_WS_MAC
201  		input &amp;= (!alt || ctrl);
202  #endif
203  		QString text = event-&gt;text();
204  		if (input &amp;&amp; !text.isEmpty() &amp;&amp; text[0].isPrint()) {
205  			const int strLen = text.length();
206  			for (int i = 0; i &lt; strLen;) {
207  				const int ucWidth = text.at(i).isHighSurrogate() ? 2 : 1;
208  				const QString oneCharUTF16 = text.mid(i, ucWidth);
209  				const QByteArray oneChar = sqt-&gt;BytesForDocument(oneCharUTF16);
210  				sqt-&gt;InsertCharacter(std::string_view(oneChar.data(), oneChar.length()), CharacterSource::DirectInput);
211  				i += ucWidth;
212  			}
213  		} else {
214  			event-&gt;ignore();
215  		}
216  	}
217  	emit keyPressed(event);
218  }
219  static int modifierTranslated(int sciModifier)
220  {
221  	switch (sciModifier) {
222  		case SCMOD_SHIFT:
223  			return Qt::ShiftModifier;
224  		case SCMOD_CTRL:
225  			return Qt::ControlModifier;
226  		case SCMOD_ALT:
227  			return Qt::AltModifier;
228  		case SCMOD_SUPER:
229  			return Qt::MetaModifier;
230  		default:
231  			return 0;
232  	}
233  }
234  void ScintillaEditBase::mousePressEvent(QMouseEvent *event)
235  {
236  	Point pos = PointFromQPoint(event-&gt;pos());
237  	emit buttonPressed(event);
238  	if (event-&gt;button() == Qt::MiddleButton &amp;&amp;
239  	    QApplication::clipboard()-&gt;supportsSelection()) {
240  		SelectionPosition selPos = sqt-&gt;SPositionFromLocation(
241  					pos, false, false, sqt-&gt;UserVirtualSpace());
242  		sqt-&gt;sel.Clear();
243  		sqt-&gt;SetSelection(selPos, selPos);
244  		sqt-&gt;PasteFromMode(QClipboard::Selection);
245  		return;
246  	}
247  	if (event-&gt;button() == Qt::LeftButton) {
248  		bool shift = QApplication::keyboardModifiers() &amp; Qt::ShiftModifier;
249  		bool ctrl  = QApplication::keyboardModifiers() &amp; Qt::ControlModifier;
250  		bool alt   = QApplication::keyboardModifiers() &amp; modifierTranslated(sqt-&gt;rectangularSelectionModifier);
251  		sqt-&gt;ButtonDownWithModifiers(pos, time.elapsed(), ModifierFlags(shift, ctrl, alt));
252  	}
253  	if (event-&gt;button() == Qt::RightButton) {
254  		sqt-&gt;RightButtonDownWithModifiers(pos, time.elapsed(), ModifiersOfKeyboard());
255  	}
256  }
257  void ScintillaEditBase::mouseReleaseEvent(QMouseEvent *event)
258  {
259  	const QPoint point = event-&gt;pos();
260  	if (event-&gt;button() == Qt::LeftButton)
261  		sqt-&gt;ButtonUpWithModifiers(PointFromQPoint(point), time.elapsed(), ModifiersOfKeyboard());
262  	const sptr_t pos = send(SCI_POSITIONFROMPOINT, point.x(), point.y());
263  	const sptr_t line = send(SCI_LINEFROMPOSITION, pos);
264  	int modifiers = QApplication::keyboardModifiers();
265  	emit textAreaClicked(line, modifiers);
266  	emit buttonReleased(event);
267  }
268  void ScintillaEditBase::mouseDoubleClickEvent(QMouseEvent *event)
269  {
270  	mousePressEvent(event);
271  }
272  void ScintillaEditBase::mouseMoveEvent(QMouseEvent *event)
273  {
274  	Point pos = PointFromQPoint(event-&gt;pos());
275  	bool shift = QApplication::keyboardModifiers() &amp; Qt::ShiftModifier;
276  	bool ctrl  = QApplication::keyboardModifiers() &amp; Qt::ControlModifier;
277  	bool alt   = QApplication::keyboardModifiers() &amp; modifierTranslated(sqt-&gt;rectangularSelectionModifier);
278  	const KeyMod modifiers = ModifierFlags(shift, ctrl, alt);
279  	sqt-&gt;ButtonMoveWithModifiers(pos, time.elapsed(), modifiers);
280  }
281  void ScintillaEditBase::contextMenuEvent(QContextMenuEvent *event)
282  {
283  	Point pos = PointFromQPoint(event-&gt;globalPos());
284  	Point pt = PointFromQPoint(event-&gt;pos());
285  	if (!sqt-&gt;PointInSelection(pt)) {
286  		sqt-&gt;SetEmptySelection(sqt-&gt;PositionFromLocation(pt));
287  	}
288  	if (sqt-&gt;ShouldDisplayPopup(pt)) {
289  		sqt-&gt;ContextMenu(pos);
290  	}
291  }
292  void ScintillaEditBase::dragEnterEvent(QDragEnterEvent *event)
293  {
294  	if (event-&gt;mimeData()-&gt;hasUrls()) {
295  		event-&gt;acceptProposedAction();
296  	} else if (event-&gt;mimeData()-&gt;hasText()) {
297  		event-&gt;acceptProposedAction();
298  		Point point = PointFromQPoint(event-&gt;pos());
299  		sqt-&gt;DragEnter(point);
300  	} else {
301  		event-&gt;ignore();
302  	}
303  }
<span onclick='openModal()' class='match'>304  void ScintillaEditBase::dragLeaveEvent(QDragLeaveEvent * &amp;bsol;* event */)
305  {
306  	sqt-&gt;DragLeave();
</span>307  }
308  void ScintillaEditBase::dragMoveEvent(QDragMoveEvent *event)
309  {
310  	if (event-&gt;mimeData()-&gt;hasUrls()) {
311  		event-&gt;acceptProposedAction();
312  	} else if (event-&gt;mimeData()-&gt;hasText()) {
313  		event-&gt;acceptProposedAction();
314  		Point point = PointFromQPoint(event-&gt;pos());
315  		sqt-&gt;DragMove(point);
316  	} else {
317  		event-&gt;ignore();
318  	}
319  }
320  void ScintillaEditBase::dropEvent(QDropEvent *event)
321  {
322  	if (event-&gt;mimeData()-&gt;hasUrls()) {
323  		event-&gt;acceptProposedAction();
324  		sqt-&gt;DropUrls(event-&gt;mimeData());
325  	} else if (event-&gt;mimeData()-&gt;hasText()) {
326  		event-&gt;acceptProposedAction();
327  		Point point = PointFromQPoint(event-&gt;pos());
328  		bool move = (event-&gt;source() == this &amp;&amp;
329                   event-&gt;proposedAction() == Qt::MoveAction);
330  		sqt-&gt;Drop(point, event-&gt;mimeData(), move);
331  	} else {
332  		event-&gt;ignore();
333  	}
334  }
335  bool ScintillaEditBase::IsHangul(const QChar qchar)
336  {
337  	unsigned int unicode = qchar.unicode();
338  	const bool HangulJamo = (0x1100 &lt;= unicode &amp;&amp; unicode &lt;= 0x11FF);
339  	const bool HangulCompatibleJamo = (0x3130 &lt;= unicode &amp;&amp; unicode &lt;= 0x318F);
340  	const bool HangulJamoExtendedA = (0xA960 &lt;= unicode &amp;&amp; unicode &lt;= 0xA97F);
341  	const bool HangulJamoExtendedB = (0xD7B0 &lt;= unicode &amp;&amp; unicode &lt;= 0xD7FF);
342  	const bool HangulSyllable = (0xAC00 &lt;= unicode &amp;&amp; unicode &lt;= 0xD7A3);
343  	return HangulJamo || HangulCompatibleJamo  || HangulSyllable ||
344  				HangulJamoExtendedA || HangulJamoExtendedB;
345  }
346  void ScintillaEditBase::MoveImeCarets(Scintilla::Position offset)
347  {
348  	for (size_t r=0; r &lt; sqt-&gt;sel.Count(); r++) {
349  		const Sci::Position positionInsert = sqt-&gt;sel.Range(r).Start().Position();
350  		sqt-&gt;sel.Range(r).caret.SetPosition(positionInsert + offset);
351  		sqt-&gt;sel.Range(r).anchor.SetPosition(positionInsert + offset);
352   	}
353  }
354  void ScintillaEditBase::DrawImeIndicator(int indicator, int len)
355  {
356  	if (indicator &lt; INDICATOR_CONTAINER || indicator &gt; INDICATOR_MAX) {
357  		return;
358  	}
359  	sqt-&gt;pdoc-&gt;DecorationSetCurrentIndicator(indicator);
360  	for (size_t r=0; r&lt; sqt-&gt; sel.Count(); r++) {
361  		const Sci::Position positionInsert = sqt-&gt;sel.Range(r).Start().Position();
362  		sqt-&gt;pdoc-&gt;DecorationFillRange(positionInsert - len, 1, len);
363  	}
364  }
365  static int GetImeCaretPos(QInputMethodEvent *event)
366  {
367  	foreach (QInputMethodEvent::Attribute attr, event-&gt;attributes()) {
368  		if (attr.type == QInputMethodEvent::Cursor)
369  			return attr.start;
370  	}
371  	return 0;
372  }
373  static std::vector&lt;int&gt; MapImeIndicators(QInputMethodEvent *event)
374  {
375  	std::vector&lt;int&gt; imeIndicator(event-&gt;preeditString().size(), IndicatorUnknown);
376  	foreach (QInputMethodEvent::Attribute attr, event-&gt;attributes()) {
377  		if (attr.type == QInputMethodEvent::TextFormat) {
378  			QTextFormat format = attr.value.value&lt;QTextFormat&gt;();
379  			QTextCharFormat charFormat = format.toCharFormat();
380  			int indicator = IndicatorUnknown;
381  			switch (charFormat.underlineStyle()) {
382  				case QTextCharFormat::NoUnderline: 
383  				case QTextCharFormat::SingleUnderline: 
384  				case QTextCharFormat::DashUnderline: 
385  					indicator = IndicatorInput;
386  					break;
387  				case QTextCharFormat::DotLine:
388  				case QTextCharFormat::DashDotLine:
389  				case QTextCharFormat::WaveUnderline:
390  				case QTextCharFormat::SpellCheckUnderline:
391  					indicator = IndicatorConverted;
392  					break;
393  				default:
394  					indicator = IndicatorUnknown;
395  			}
396  			if (format.hasProperty(QTextFormat::BackgroundBrush)) 
397  				indicator = IndicatorTarget;
398  #ifdef Q_OS_OSX
399  			if (charFormat.underlineStyle() == QTextCharFormat::SingleUnderline) {
400  				QColor uc = charFormat.underlineColor();
401  				if (uc.lightness() &lt; 2) { 
402  					indicator = IndicatorTarget;
403  				}
404  			}
405  #endif
406  			for (int i = attr.start; i &lt; attr.start+attr.length; i++) {
407  				imeIndicator[i] = indicator;
408  			}
409  		}
410  	}
411  	return imeIndicator;
412  }
413  void ScintillaEditBase::inputMethodEvent(QInputMethodEvent *event)
414  {
415  	if (sqt-&gt;pdoc-&gt;IsReadOnly() || sqt-&gt;SelectionContainsProtected()) {
416  		return;
417  	}
418  	bool initialCompose = false;
419  	if (sqt-&gt;pdoc-&gt;TentativeActive()) {
420  		sqt-&gt;pdoc-&gt;TentativeUndo();
421  	} else {
422  		initialCompose = true;
423  	}
424  	sqt-&gt;view.imeCaretBlockOverride = false;
425  	preeditPos = -1; 
426  	if (!event-&gt;commitString().isEmpty()) {
427  		const QString &amp;commitStr = event-&gt;commitString();
428  		const int commitStrLen = commitStr.length();
429  		for (int i = 0; i &lt; commitStrLen;) {
430  			const int ucWidth = commitStr.at(i).isHighSurrogate() ? 2 : 1;
431  			const QString oneCharUTF16 = commitStr.mid(i, ucWidth);
432  			const QByteArray oneChar = sqt-&gt;BytesForDocument(oneCharUTF16);
433  			sqt-&gt;InsertCharacter(std::string_view(oneChar.data(), oneChar.length()), CharacterSource::DirectInput);
434  			i += ucWidth;
435  		}
436  	} else if (!event-&gt;preeditString().isEmpty()) {
437  		const QString preeditStr = event-&gt;preeditString();
438  		const int preeditStrLen = preeditStr.length();
439  		if (preeditStrLen == 0) {
440  			sqt-&gt;ShowCaretAtCurrentPosition();
441  			return;
442  		}
443  		if (initialCompose)
444  			sqt-&gt;ClearBeforeTentativeStart();
445  		sqt-&gt;pdoc-&gt;TentativeStart(); 
446  		preeditPos = sqt-&gt;CurrentPosition();
447  		std::vector&lt;int&gt; imeIndicator = MapImeIndicators(event);
448  		for (int i = 0; i &lt; preeditStrLen;) {
449  			const int ucWidth = preeditStr.at(i).isHighSurrogate() ? 2 : 1;
450  			const QString oneCharUTF16 = preeditStr.mid(i, ucWidth);
451  			const QByteArray oneChar = sqt-&gt;BytesForDocument(oneCharUTF16);
452  			const int oneCharLen = oneChar.length();
453  			sqt-&gt;InsertCharacter(std::string_view(oneChar.data(), oneCharLen), CharacterSource::TentativeInput);
454  			DrawImeIndicator(imeIndicator[i], oneCharLen);
455  			i += ucWidth;
456  		}
457  		int imeCaretPos = GetImeCaretPos(event);
458  		int imeEndToImeCaretU16 = imeCaretPos - preeditStrLen;
459  		const Sci::Position imeCaretPosDoc = sqt-&gt;pdoc-&gt;GetRelativePositionUTF16(sqt-&gt;CurrentPosition(), imeEndToImeCaretU16);
460  		MoveImeCarets(- sqt-&gt;CurrentPosition() + imeCaretPosDoc);
461  		if (IsHangul(preeditStr.at(0))) {
462  #ifndef Q_OS_WIN
463  			if (imeCaretPos &gt; 0) {
464  				int oneCharBefore = sqt-&gt;pdoc-&gt;GetRelativePosition(sqt-&gt;CurrentPosition(), -1);
465  				MoveImeCarets(- sqt-&gt;CurrentPosition() + oneCharBefore);
466  			}
467  #endif
468  			sqt-&gt;view.imeCaretBlockOverride = true;
469  		}
470  		const bool targetAny = std::any_of(imeIndicator.begin(), imeIndicator.end(), [](int i) noexcept {
471  			return i == IndicatorTarget;
472  		});
473  		if (targetAny)
474  			preeditPos = sqt-&gt;CurrentPosition();
475  		sqt-&gt;EnsureCaretVisible();
476  	}
477  	sqt-&gt;ShowCaretAtCurrentPosition();
478  }
479  QVariant ScintillaEditBase::inputMethodQuery(Qt::InputMethodQuery query) const
480  {
481  	const Scintilla::Position pos = send(SCI_GETCURRENTPOS);
482  	const Scintilla::Position line = send(SCI_LINEFROMPOSITION, pos);
483  	switch (query) {
484  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0)
485  		case Qt::ImCursorRectangle:
486  		{
487  			const Scintilla::Position startPos = (preeditPos &gt;= 0) ? preeditPos : pos;
488  			const Point pt = sqt-&gt;LocationFromPosition(startPos);
489  			const int width = static_cast&lt;int&gt;(send(SCI_GETCARETWIDTH));
490  			const int height = static_cast&lt;int&gt;(send(SCI_TEXTHEIGHT, line));
491  			return QRectF(pt.x, pt.y, width, height).toRect();
492  		}
493  #else
494  		case Qt::ImMicroFocus:
495  		{
496  			const Scintilla::Position startPos = (preeditPos &gt;= 0) ? preeditPos : pos;
497  			const Point pt = sqt-&gt;LocationFromPosition(startPos);
498  			const int width = static_cast&lt;int&gt;(send(SCI_GETCARETWIDTH));
499  			const int height = static_cast&lt;int&gt;(send(SCI_TEXTHEIGHT, line));
500  			return QRect(pt.x, pt.y, width, height);
501  		}
502  #endif
503  		case Qt::ImFont:
504  		{
505  			char fontName[64];
506  			const sptr_t style = send(SCI_GETSTYLEAT, pos);
507  			const int len = static_cast&lt;int&gt;(sends(SCI_STYLEGETFONT, style, fontName));
508  			const int size = static_cast&lt;int&gt;(send(SCI_STYLEGETSIZE, style));
509  			const bool italic = send(SCI_STYLEGETITALIC, style);
510  			const int weight = send(SCI_STYLEGETBOLD, style) ? QFont::Bold : -1;
511  			return QFont(QString::fromUtf8(fontName, len), size, weight, italic);
512  		}
513  		case Qt::ImCursorPosition:
514  		{
515  			const Scintilla::Position paraStart = sqt-&gt;pdoc-&gt;ParaUp(pos);
516  			return static_cast&lt;int&gt;(sqt-&gt;pdoc-&gt;CountUTF16(paraStart, pos));
517  		}
518  		case Qt::ImSurroundingText:
519  		{
520  			const Scintilla::Position paraStart = sqt-&gt;pdoc-&gt;ParaUp(pos);
521  			const Scintilla::Position paraEnd = sqt-&gt;pdoc-&gt;ParaDown(pos);
522  			const std::string buffer = sqt-&gt;RangeText(paraStart, paraEnd);
523  			return sqt-&gt;StringFromDocument(buffer.c_str());
524  		}
525  		case Qt::ImCurrentSelection:
526  		{
527  			QVarLengthArray&lt;char,1024&gt; buffer(send(SCI_GETSELTEXT));
528  			sends(SCI_GETSELTEXT, 0, buffer.data());
529  			return sqt-&gt;StringFromDocument(buffer.constData());
530  		}
531  		default:
532  			return QVariant();
533  	}
534  }
535  void ScintillaEditBase::notifyParent(NotificationData scn)
536  {
537  	emit notify(&amp;scn);
538  	switch (scn.nmhdr.code) {
539  		case Notification::StyleNeeded:
540  			emit styleNeeded(scn.position);
541  			break;
542  		case Notification::CharAdded:
543  			emit charAdded(scn.ch);
544  			break;
545  		case Notification::SavePointReached:
546  			emit savePointChanged(false);
547  			break;
548  		case Notification::SavePointLeft:
549  			emit savePointChanged(true);
550  			break;
551  		case Notification::ModifyAttemptRO:
552  			emit modifyAttemptReadOnly();
553  			break;
554  		case Notification::Key:
555  			emit key(scn.ch);
556  			break;
557  		case Notification::DoubleClick:
558  			emit doubleClick(scn.position, scn.line);
559  			break;
560  		case Notification::UpdateUI:
561  			emit updateUi(scn.updated);
562  			break;
563  		case Notification::Modified:
564  		{
565  			const bool added = FlagSet(scn.modificationType, ModificationFlags::InsertText);
566  			const bool deleted = FlagSet(scn.modificationType, ModificationFlags::DeleteText);
567  			const Scintilla::Position length = send(SCI_GETTEXTLENGTH);
568  			bool firstLineAdded = (added &amp;&amp; length == 1) ||
569  			                      (deleted &amp;&amp; length == 0);
570  			if (scn.linesAdded != 0) {
571  				emit linesAdded(scn.linesAdded);
572  			} else if (firstLineAdded) {
573  				emit linesAdded(added ? 1 : -1);
574  			}
575  			const QByteArray bytes = QByteArray::fromRawData(scn.text, scn.text ? scn.length : 0);
576  			emit modified(scn.modificationType, scn.position, scn.length,
577  			              scn.linesAdded, bytes, scn.line,
578  			              scn.foldLevelNow, scn.foldLevelPrev);
579  			break;
580  		}
581  		case Notification::MacroRecord:
582  			emit macroRecord(scn.message, scn.wParam, scn.lParam);
583  			break;
584  		case Notification::MarginClick:
585  			emit marginClicked(scn.position, scn.modifiers, scn.margin);
586  			break;
587  		case Notification::NeedShown:
588  			emit needShown(scn.position, scn.length);
589  			break;
590  		case Notification::Painted:
591  			emit painted();
592  			break;
593  		case Notification::UserListSelection:
594  			emit userListSelection();
595  			break;
596  		case Notification::URIDropped:
597  			emit uriDropped(QString::fromUtf8(scn.text));
598  			break;
599  		case Notification::DwellStart:
600  			emit dwellStart(scn.x, scn.y);
601  			break;
602  		case Notification::DwellEnd:
603  			emit dwellEnd(scn.x, scn.y);
604  			break;
605  		case Notification::Zoom:
606  			emit zoom(send(SCI_GETZOOM));
607  			break;
608  		case Notification::HotSpotClick:
609  			emit hotSpotClick(scn.position, scn.modifiers);
610  			break;
611  		case Notification::HotSpotDoubleClick:
612  			emit hotSpotDoubleClick(scn.position, scn.modifiers);
613  			break;
614  		case Notification::CallTipClick:
615  			emit callTipClick();
616  			break;
617  		case Notification::AutoCSelection:
618  			emit autoCompleteSelection(scn.lParam, QString::fromUtf8(scn.text));
619  			break;
620  		case Notification::AutoCCancelled:
621  			emit autoCompleteCancelled();
622  			break;
623  		case Notification::FocusIn:
624  			emit focusChanged(true);
625  			break;
626  		case Notification::FocusOut:
627  			emit focusChanged(false);
628  			break;
629  		default:
630  			return;
631  	}
632  }
633  void ScintillaEditBase::event_command(uptr_t wParam, sptr_t lParam)
634  {
635  	emit command(wParam, lParam);
636  }
637  KeyMod ScintillaEditBase::ModifiersOfKeyboard()
638  {
639  	const bool shift = QApplication::keyboardModifiers() &amp; Qt::ShiftModifier;
640  	const bool ctrl  = QApplication::keyboardModifiers() &amp; Qt::ControlModifier;
641  	const bool alt   = QApplication::keyboardModifiers() &amp; Qt::AltModifier;
642  	return ModifierFlags(shift, ctrl, alt);
643  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatQt.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditBase.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1050  void ListWidget::mouseDoubleClickEvent(QMouseEvent * &amp;bsol;* event */)
1051  {
1052  	if (delegate) {
</pre></code></div>
                <div class="column column_space"><pre><code>304  void ScintillaEditBase::dragLeaveEvent(QDragLeaveEvent * &amp;bsol;* event */)
305  {
306  	sqt-&gt;DragLeave();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    