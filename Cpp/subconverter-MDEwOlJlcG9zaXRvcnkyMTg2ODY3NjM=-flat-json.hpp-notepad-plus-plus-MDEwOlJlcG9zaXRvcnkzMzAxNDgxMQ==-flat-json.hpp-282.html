
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 805, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-json.hpp</h3>
            <pre><code>1  #ifndef INCLUDE_NLOHMANN_JSON_HPP_
2  #define INCLUDE_NLOHMANN_JSON_HPP_
3  #define NLOHMANN_JSON_VERSION_MAJOR 3
4  #define NLOHMANN_JSON_VERSION_MINOR 10
5  #define NLOHMANN_JSON_VERSION_PATCH 2
6  #include &lt;algorithm&gt; 
7  #include &lt;cstddef&gt; 
8  #include &lt;functional&gt; 
9  #include &lt;initializer_list&gt; 
10  #ifndef JSON_NO_IO
11      #include &lt;iosfwd&gt; 
12  #endif  
13  #include &lt;iterator&gt; 
14  #include &lt;memory&gt; 
15  #include &lt;numeric&gt; 
16  #include &lt;string&gt; 
17  #include &lt;utility&gt; 
18  #include &lt;vector&gt; 
19  #include &lt;type_traits&gt;
20  #include &lt;utility&gt;
21  #include &lt;algorithm&gt; 
22  #include &lt;array&gt; 
23  #include &lt;forward_list&gt; 
24  #include &lt;iterator&gt; 
25  #include &lt;map&gt; 
26  #include &lt;string&gt; 
27  #include &lt;tuple&gt; 
28  #include &lt;type_traits&gt; 
29  #include &lt;unordered_map&gt; 
30  #include &lt;utility&gt; 
31  #include &lt;valarray&gt; 
32  #include &lt;exception&gt; 
33  #include &lt;stdexcept&gt; 
34  #include &lt;string&gt; 
35  #include &lt;vector&gt; 
36  #include &lt;array&gt; 
37  #include &lt;cstddef&gt; 
38  #include &lt;cstdint&gt; 
39  #include &lt;string&gt; 
40  namespace nlohmann
41  {
42  namespace detail
43  {
44  enum class value_t : std::uint8_t
45  {
46      null,             
47      object,           
48      array,            
49      string,           
50      boolean,          
51      number_integer,   
52      number_unsigned,  
53      number_float,     
54      binary,           
55      discarded         
56  };
57  inline bool operator&lt;(const value_t lhs, const value_t rhs) noexcept
58  {
59      static constexpr std::array&lt;std::uint8_t, 9&gt; order = {{
60              0 &amp;bsol;* null */, 3 &amp;bsol;* object */, 4 &amp;bsol;* array */, 5 &amp;bsol;* string */,
61              1 &amp;bsol;* boolean */, 2 &amp;bsol;* integer */, 2 &amp;bsol;* unsigned */, 2 &amp;bsol;* float */,
62              6 &amp;bsol;* binary */
63          }
64      };
65      const auto l_index = static_cast&lt;std::size_t&gt;(lhs);
66      const auto r_index = static_cast&lt;std::size_t&gt;(rhs);
67      return l_index &lt; order.size() &amp;&amp; r_index &lt; order.size() &amp;&amp; order[l_index] &lt; order[r_index];
68  }
69  }  
70  }  
71  #include &lt;string&gt;
72  #include &lt;utility&gt; 
73  #if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION &lt; 15)
74  #if defined(JSON_HEDLEY_VERSION)
75      #undef JSON_HEDLEY_VERSION
76  #endif
77  #define JSON_HEDLEY_VERSION 15
78  #if defined(JSON_HEDLEY_STRINGIFY_EX)
79      #undef JSON_HEDLEY_STRINGIFY_EX
80  #endif
81  #define JSON_HEDLEY_STRINGIFY_EX(x) #x
82  #if defined(JSON_HEDLEY_STRINGIFY)
83      #undef JSON_HEDLEY_STRINGIFY
84  #endif
85  #define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)
86  #if defined(JSON_HEDLEY_CONCAT_EX)
87      #undef JSON_HEDLEY_CONCAT_EX
88  #endif
89  #define JSON_HEDLEY_CONCAT_EX(a,b) a##b
90  #if defined(JSON_HEDLEY_CONCAT)
91      #undef JSON_HEDLEY_CONCAT
92  #endif
93  #define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)
94  #if defined(JSON_HEDLEY_CONCAT3_EX)
95      #undef JSON_HEDLEY_CONCAT3_EX
96  #endif
97  #define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c
98  #if defined(JSON_HEDLEY_CONCAT3)
99      #undef JSON_HEDLEY_CONCAT3
100  #endif
101  #define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)
102  #if defined(JSON_HEDLEY_VERSION_ENCODE)
103      #undef JSON_HEDLEY_VERSION_ENCODE
104  #endif
105  #define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))
106  #if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
107      #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
108  #endif
109  #define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)
110  #if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
111      #undef JSON_HEDLEY_VERSION_DECODE_MINOR
112  #endif
113  #define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)
114  #if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
115      #undef JSON_HEDLEY_VERSION_DECODE_REVISION
116  #endif
117  #define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)
118  #if defined(JSON_HEDLEY_GNUC_VERSION)
119      #undef JSON_HEDLEY_GNUC_VERSION
120  #endif
121  #if defined(__GNUC__) &amp;&amp; defined(__GNUC_PATCHLEVEL__)
122      #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
123  #elif defined(__GNUC__)
124      #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
125  #endif
126  #if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
127      #undef JSON_HEDLEY_GNUC_VERSION_CHECK
128  #endif
129  #if defined(JSON_HEDLEY_GNUC_VERSION)
130      #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
131  #else
132      #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
133  #endif
134  #if defined(JSON_HEDLEY_MSVC_VERSION)
135      #undef JSON_HEDLEY_MSVC_VERSION
136  #endif
137  #if defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 140000000) &amp;&amp; !defined(__ICL)
138      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
139  #elif defined(_MSC_FULL_VER) &amp;&amp; !defined(__ICL)
140      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
141  #elif defined(_MSC_VER) &amp;&amp; !defined(__ICL)
142      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
143  #endif
144  #if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
145      #undef JSON_HEDLEY_MSVC_VERSION_CHECK
146  #endif
147  #if !defined(JSON_HEDLEY_MSVC_VERSION)
148      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
149  #elif defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400)
150      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER &gt;= ((major * 10000000) + (minor * 100000) + (patch)))
151  #elif defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
152      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER &gt;= ((major * 1000000) + (minor * 10000) + (patch)))
153  #else
154      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER &gt;= ((major * 100) + (minor)))
155  #endif
156  #if defined(JSON_HEDLEY_INTEL_VERSION)
157      #undef JSON_HEDLEY_INTEL_VERSION
158  #endif
159  #if defined(__INTEL_COMPILER) &amp;&amp; defined(__INTEL_COMPILER_UPDATE) &amp;&amp; !defined(__ICL)
160      #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
161  #elif defined(__INTEL_COMPILER) &amp;&amp; !defined(__ICL)
162      #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
163  #endif
164  #if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
165      #undef JSON_HEDLEY_INTEL_VERSION_CHECK
166  #endif
167  #if defined(JSON_HEDLEY_INTEL_VERSION)
168      #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
169  #else
170      #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
171  #endif
172  #if defined(JSON_HEDLEY_INTEL_CL_VERSION)
173      #undef JSON_HEDLEY_INTEL_CL_VERSION
174  #endif
175  #if defined(__INTEL_COMPILER) &amp;&amp; defined(__INTEL_COMPILER_UPDATE) &amp;&amp; defined(__ICL)
176      #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
177  #endif
178  #if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)
179      #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
180  #endif
181  #if defined(JSON_HEDLEY_INTEL_CL_VERSION)
182      #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
183  #else
184      #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)
185  #endif
186  #if defined(JSON_HEDLEY_PGI_VERSION)
187      #undef JSON_HEDLEY_PGI_VERSION
188  #endif
189  #if defined(__PGI) &amp;&amp; defined(__PGIC__) &amp;&amp; defined(__PGIC_MINOR__) &amp;&amp; defined(__PGIC_PATCHLEVEL__)
190      #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
191  #endif
192  #if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
193      #undef JSON_HEDLEY_PGI_VERSION_CHECK
194  #endif
195  #if defined(JSON_HEDLEY_PGI_VERSION)
196      #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
197  #else
198      #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
199  #endif
200  #if defined(JSON_HEDLEY_SUNPRO_VERSION)
201      #undef JSON_HEDLEY_SUNPRO_VERSION
202  #endif
203  #if defined(__SUNPRO_C) &amp;&amp; (__SUNPRO_C &gt; 0x1000)
204      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C &gt;&gt; 16) &amp; 0xf) * 10) + ((__SUNPRO_C &gt;&gt; 12) &amp; 0xf), (((__SUNPRO_C &gt;&gt; 8) &amp; 0xf) * 10) + ((__SUNPRO_C &gt;&gt; 4) &amp; 0xf), (__SUNPRO_C &amp; 0xf) * 10)
205  #elif defined(__SUNPRO_C)
206      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C &gt;&gt; 8) &amp; 0xf, (__SUNPRO_C &gt;&gt; 4) &amp; 0xf, (__SUNPRO_C) &amp; 0xf)
207  #elif defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &gt; 0x1000)
208      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC &gt;&gt; 16) &amp; 0xf) * 10) + ((__SUNPRO_CC &gt;&gt; 12) &amp; 0xf), (((__SUNPRO_CC &gt;&gt; 8) &amp; 0xf) * 10) + ((__SUNPRO_CC &gt;&gt; 4) &amp; 0xf), (__SUNPRO_CC &amp; 0xf) * 10)
209  #elif defined(__SUNPRO_CC)
210      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC &gt;&gt; 8) &amp; 0xf, (__SUNPRO_CC &gt;&gt; 4) &amp; 0xf, (__SUNPRO_CC) &amp; 0xf)
211  #endif
212  #if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
213      #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
214  #endif
215  #if defined(JSON_HEDLEY_SUNPRO_VERSION)
216      #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
217  #else
218      #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
219  #endif
220  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
221      #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
222  #endif
223  #if defined(__EMSCRIPTEN__)
224      #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
225  #endif
226  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
227      #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
228  #endif
229  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
230      #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
231  #else
232      #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
233  #endif
234  #if defined(JSON_HEDLEY_ARM_VERSION)
235      #undef JSON_HEDLEY_ARM_VERSION
236  #endif
237  #if defined(__CC_ARM) &amp;&amp; defined(__ARMCOMPILER_VERSION)
238      #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
239  #elif defined(__CC_ARM) &amp;&amp; defined(__ARMCC_VERSION)
240      #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
241  #endif
242  #if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
243      #undef JSON_HEDLEY_ARM_VERSION_CHECK
244  #endif
245  #if defined(JSON_HEDLEY_ARM_VERSION)
246      #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
247  #else
248      #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
249  #endif
250  #if defined(JSON_HEDLEY_IBM_VERSION)
251      #undef JSON_HEDLEY_IBM_VERSION
252  #endif
253  #if defined(__ibmxl__)
254      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
255  #elif defined(__xlC__) &amp;&amp; defined(__xlC_ver__)
256      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ &gt;&gt; 8, __xlC__ &amp; 0xff, (__xlC_ver__ &gt;&gt; 8) &amp; 0xff)
257  #elif defined(__xlC__)
258      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ &gt;&gt; 8, __xlC__ &amp; 0xff, 0)
259  #endif
260  #if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
261      #undef JSON_HEDLEY_IBM_VERSION_CHECK
262  #endif
263  #if defined(JSON_HEDLEY_IBM_VERSION)
264      #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
265  #else
266      #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
267  #endif
268  #if defined(JSON_HEDLEY_TI_VERSION)
269      #undef JSON_HEDLEY_TI_VERSION
270  #endif
271  #if \
272      defined(__TI_COMPILER_VERSION__) &amp;&amp; \
273      ( \
274        defined(__TMS470__) || defined(__TI_ARM__) || \
275        defined(__MSP430__) || \
276        defined(__TMS320C2000__) \
277      )
278  #if (__TI_COMPILER_VERSION__ &gt;= 16000000)
279      #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
280  #endif
281  #endif
282  #if defined(JSON_HEDLEY_TI_VERSION_CHECK)
283      #undef JSON_HEDLEY_TI_VERSION_CHECK
284  #endif
285  #if defined(JSON_HEDLEY_TI_VERSION)
286      #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
287  #else
288      #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
289  #endif
290  #if defined(JSON_HEDLEY_TI_CL2000_VERSION)
291      #undef JSON_HEDLEY_TI_CL2000_VERSION
292  #endif
293  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__TMS320C2000__)
294      #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
295  #endif
296  #if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
297      #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
298  #endif
299  #if defined(JSON_HEDLEY_TI_CL2000_VERSION)
300      #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
301  #else
302      #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
303  #endif
304  #if defined(JSON_HEDLEY_TI_CL430_VERSION)
305      #undef JSON_HEDLEY_TI_CL430_VERSION
306  #endif
307  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__MSP430__)
308      #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
309  #endif
310  #if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
311      #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
312  #endif
313  #if defined(JSON_HEDLEY_TI_CL430_VERSION)
314      #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
315  #else
316      #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
317  #endif
318  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
319      #undef JSON_HEDLEY_TI_ARMCL_VERSION
320  #endif
321  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; (defined(__TMS470__) || defined(__TI_ARM__))
322      #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
323  #endif
324  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
325      #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
326  #endif
327  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
328      #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
329  #else
330      #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
331  #endif
332  #if defined(JSON_HEDLEY_TI_CL6X_VERSION)
333      #undef JSON_HEDLEY_TI_CL6X_VERSION
334  #endif
335  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__TMS320C6X__)
336      #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
337  #endif
338  #if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
339      #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
340  #endif
341  #if defined(JSON_HEDLEY_TI_CL6X_VERSION)
342      #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
343  #else
344      #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
345  #endif
346  #if defined(JSON_HEDLEY_TI_CL7X_VERSION)
347      #undef JSON_HEDLEY_TI_CL7X_VERSION
348  #endif
349  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__C7000__)
350      #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
351  #endif
352  #if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
353      #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
354  #endif
355  #if defined(JSON_HEDLEY_TI_CL7X_VERSION)
356      #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
357  #else
358      #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
359  #endif
360  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
361      #undef JSON_HEDLEY_TI_CLPRU_VERSION
362  #endif
363  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__PRU__)
364      #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
365  #endif
366  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
367      #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
368  #endif
369  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
370      #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
371  #else
372      #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
373  #endif
374  #if defined(JSON_HEDLEY_CRAY_VERSION)
375      #undef JSON_HEDLEY_CRAY_VERSION
376  #endif
377  #if defined(_CRAYC)
378      #if defined(_RELEASE_PATCHLEVEL)
379          #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
380      #else
381          #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
382      #endif
383  #endif
384  #if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
385      #undef JSON_HEDLEY_CRAY_VERSION_CHECK
386  #endif
387  #if defined(JSON_HEDLEY_CRAY_VERSION)
388      #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
389  #else
390      #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
391  #endif
392  #if defined(JSON_HEDLEY_IAR_VERSION)
393      #undef JSON_HEDLEY_IAR_VERSION
394  #endif
395  #if defined(__IAR_SYSTEMS_ICC__)
396      #if __VER__ &gt; 1000
397          #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
398      #else
399          #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)
400      #endif
401  #endif
402  #if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
403      #undef JSON_HEDLEY_IAR_VERSION_CHECK
404  #endif
405  #if defined(JSON_HEDLEY_IAR_VERSION)
406      #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
407  #else
408      #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
409  #endif
410  #if defined(JSON_HEDLEY_TINYC_VERSION)
411      #undef JSON_HEDLEY_TINYC_VERSION
412  #endif
413  #if defined(__TINYC__)
414      #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
415  #endif
416  #if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
417      #undef JSON_HEDLEY_TINYC_VERSION_CHECK
418  #endif
419  #if defined(JSON_HEDLEY_TINYC_VERSION)
420      #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
421  #else
422      #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
423  #endif
424  #if defined(JSON_HEDLEY_DMC_VERSION)
425      #undef JSON_HEDLEY_DMC_VERSION
426  #endif
427  #if defined(__DMC__)
428      #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ &gt;&gt; 8, (__DMC__ &gt;&gt; 4) &amp; 0xf, __DMC__ &amp; 0xf)
429  #endif
430  #if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
431      #undef JSON_HEDLEY_DMC_VERSION_CHECK
432  #endif
433  #if defined(JSON_HEDLEY_DMC_VERSION)
434      #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
435  #else
436      #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
437  #endif
438  #if defined(JSON_HEDLEY_COMPCERT_VERSION)
439      #undef JSON_HEDLEY_COMPCERT_VERSION
440  #endif
441  #if defined(__COMPCERT_VERSION__)
442      #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
443  #endif
444  #if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
445      #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
446  #endif
447  #if defined(JSON_HEDLEY_COMPCERT_VERSION)
448      #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
449  #else
450      #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
451  #endif
452  #if defined(JSON_HEDLEY_PELLES_VERSION)
453      #undef JSON_HEDLEY_PELLES_VERSION
454  #endif
455  #if defined(__POCC__)
456      #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
457  #endif
458  #if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
459      #undef JSON_HEDLEY_PELLES_VERSION_CHECK
460  #endif
461  #if defined(JSON_HEDLEY_PELLES_VERSION)
462      #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
463  #else
464      #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
465  #endif
466  #if defined(JSON_HEDLEY_MCST_LCC_VERSION)
467      #undef JSON_HEDLEY_MCST_LCC_VERSION
468  #endif
469  #if defined(__LCC__) &amp;&amp; defined(__LCC_MINOR__)
470      #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)
471  #endif
472  #if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)
473      #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
474  #endif
475  #if defined(JSON_HEDLEY_MCST_LCC_VERSION)
476      #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
477  #else
478      #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)
479  #endif
480  #if defined(JSON_HEDLEY_GCC_VERSION)
481      #undef JSON_HEDLEY_GCC_VERSION
482  #endif
483  #if \
484      defined(JSON_HEDLEY_GNUC_VERSION) &amp;&amp; \
485      !defined(__clang__) &amp;&amp; \
486      !defined(JSON_HEDLEY_INTEL_VERSION) &amp;&amp; \
487      !defined(JSON_HEDLEY_PGI_VERSION) &amp;&amp; \
488      !defined(JSON_HEDLEY_ARM_VERSION) &amp;&amp; \
489      !defined(JSON_HEDLEY_CRAY_VERSION) &amp;&amp; \
490      !defined(JSON_HEDLEY_TI_VERSION) &amp;&amp; \
491      !defined(JSON_HEDLEY_TI_ARMCL_VERSION) &amp;&amp; \
492      !defined(JSON_HEDLEY_TI_CL430_VERSION) &amp;&amp; \
493      !defined(JSON_HEDLEY_TI_CL2000_VERSION) &amp;&amp; \
494      !defined(JSON_HEDLEY_TI_CL6X_VERSION) &amp;&amp; \
495      !defined(JSON_HEDLEY_TI_CL7X_VERSION) &amp;&amp; \
496      !defined(JSON_HEDLEY_TI_CLPRU_VERSION) &amp;&amp; \
497      !defined(__COMPCERT__) &amp;&amp; \
498      !defined(JSON_HEDLEY_MCST_LCC_VERSION)
499      #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
500  #endif
501  #if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
502      #undef JSON_HEDLEY_GCC_VERSION_CHECK
503  #endif
504  #if defined(JSON_HEDLEY_GCC_VERSION)
505      #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
506  #else
507      #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
508  #endif
509  #if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
510      #undef JSON_HEDLEY_HAS_ATTRIBUTE
511  #endif
512  #if \
513    defined(__has_attribute) &amp;&amp; \
514    ( \
515      (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \
516    )
517  #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
518  #else
519  #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
520  #endif
521  #if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
522      #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
523  #endif
524  #if defined(__has_attribute)
525      #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
526  #else
527      #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
528  #endif
529  #if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
530      #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
531  #endif
532  #if defined(__has_attribute)
533      #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
534  #else
535      #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
536  #endif
537  #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
538      #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
539  #endif
540  #if \
541      defined(__has_cpp_attribute) &amp;&amp; \
542      defined(__cplusplus) &amp;&amp; \
543      (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
544      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
545  #else
546      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
547  #endif
548  #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
549      #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
550  #endif
551  #if !defined(__cplusplus) || !defined(__has_cpp_attribute)
552      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
553  #elif \
554      !defined(JSON_HEDLEY_PGI_VERSION) &amp;&amp; \
555      !defined(JSON_HEDLEY_IAR_VERSION) &amp;&amp; \
556      (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) &amp;&amp; \
557      (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
558      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
559  #else
560      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
561  #endif
562  #if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
563      #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
564  #endif
565  #if defined(__has_cpp_attribute) &amp;&amp; defined(__cplusplus)
566      #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
567  #else
568      #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
569  #endif
570  #if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
571      #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
572  #endif
573  #if defined(__has_cpp_attribute) &amp;&amp; defined(__cplusplus)
574      #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
575  #else
576      #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
577  #endif
578  #if defined(JSON_HEDLEY_HAS_BUILTIN)
579      #undef JSON_HEDLEY_HAS_BUILTIN
580  #endif
581  #if defined(__has_builtin)
582      #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
583  #else
584      #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
585  #endif
586  #if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
587      #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
588  #endif
589  #if defined(__has_builtin)
590      #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
591  #else
592      #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
593  #endif
594  #if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
595      #undef JSON_HEDLEY_GCC_HAS_BUILTIN
596  #endif
597  #if defined(__has_builtin)
598      #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
599  #else
600      #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
601  #endif
602  #if defined(JSON_HEDLEY_HAS_FEATURE)
603      #undef JSON_HEDLEY_HAS_FEATURE
604  #endif
605  #if defined(__has_feature)
606      #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
607  #else
608      #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
609  #endif
610  #if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
611      #undef JSON_HEDLEY_GNUC_HAS_FEATURE
612  #endif
613  #if defined(__has_feature)
614      #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
615  #else
616      #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
617  #endif
618  #if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
619      #undef JSON_HEDLEY_GCC_HAS_FEATURE
620  #endif
621  #if defined(__has_feature)
622      #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
623  #else
624      #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
625  #endif
626  #if defined(JSON_HEDLEY_HAS_EXTENSION)
627      #undef JSON_HEDLEY_HAS_EXTENSION
628  #endif
629  #if defined(__has_extension)
630      #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
631  #else
632      #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
633  #endif
634  #if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
635      #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
636  #endif
637  #if defined(__has_extension)
638      #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
639  #else
640      #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
641  #endif
642  #if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
643      #undef JSON_HEDLEY_GCC_HAS_EXTENSION
644  #endif
645  #if defined(__has_extension)
646      #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
647  #else
648      #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
649  #endif
650  #if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
651      #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
652  #endif
653  #if defined(__has_declspec_attribute)
654      #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
655  #else
656      #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
657  #endif
658  #if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
659      #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
660  #endif
661  #if defined(__has_declspec_attribute)
662      #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
663  #else
664      #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
665  #endif
666  #if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
667      #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
668  #endif
669  #if defined(__has_declspec_attribute)
670      #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
671  #else
672      #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
673  #endif
674  #if defined(JSON_HEDLEY_HAS_WARNING)
675      #undef JSON_HEDLEY_HAS_WARNING
676  #endif
677  #if defined(__has_warning)
678      #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
679  #else
680      #define JSON_HEDLEY_HAS_WARNING(warning) (0)
681  #endif
682  #if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
683      #undef JSON_HEDLEY_GNUC_HAS_WARNING
684  #endif
685  #if defined(__has_warning)
686      #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
687  #else
688      #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
689  #endif
690  #if defined(JSON_HEDLEY_GCC_HAS_WARNING)
691      #undef JSON_HEDLEY_GCC_HAS_WARNING
692  #endif
693  #if defined(__has_warning)
694      #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
695  #else
696      #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
697  #endif
698  #if \
699      (defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L)) || \
700      defined(__clang__) || \
701      JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
702      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
703      JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
704      JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
705      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
706      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
707      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
708      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
709      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
710      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
711      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
712      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
713      JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
714      JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
715      JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
716      (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) &amp;&amp; defined(__C99_PRAGMA_OPERATOR))
717      #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
718  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
719      #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
720  #else
721      #define JSON_HEDLEY_PRAGMA(value)
722  #endif
723  #if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
724      #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
725  #endif
726  #if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
727      #undef JSON_HEDLEY_DIAGNOSTIC_POP
728  #endif
729  #if defined(__clang__)
730      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;clang diagnostic push&quot;)
731      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;clang diagnostic pop&quot;)
732  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
733      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;warning(push)&quot;)
734      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;warning(pop)&quot;)
735  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
736      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;GCC diagnostic push&quot;)
737      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;GCC diagnostic pop&quot;)
738  #elif \
739      JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
740      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
741      #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
742      #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
743  #elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
744      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;push&quot;)
745      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;pop&quot;)
746  #elif \
747      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
748      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
749      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
750      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
751      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
752      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
753      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;diag_push&quot;)
754      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;diag_pop&quot;)
755  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
756      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;warning(push)&quot;)
757      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;warning(pop)&quot;)
758  #else
759      #define JSON_HEDLEY_DIAGNOSTIC_PUSH
760      #define JSON_HEDLEY_DIAGNOSTIC_POP
761  #endif
762  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
763      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
764  #endif
765  #if defined(__cplusplus)
766  #  if JSON_HEDLEY_HAS_WARNING(&quot;-Wc++98-compat&quot;)
767  #    if JSON_HEDLEY_HAS_WARNING(&quot;-Wc++17-extensions&quot;)
768  #      if JSON_HEDLEY_HAS_WARNING(&quot;-Wc++1z-extensions&quot;)
769  #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
770      JSON_HEDLEY_DIAGNOSTIC_PUSH \
771      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++98-compat\&quot;&quot;) \
772      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++17-extensions\&quot;&quot;) \
773      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++1z-extensions\&quot;&quot;) \
774      xpr \
775      JSON_HEDLEY_DIAGNOSTIC_POP
776  #      else
777  #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
778      JSON_HEDLEY_DIAGNOSTIC_PUSH \
779      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++98-compat\&quot;&quot;) \
780      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++17-extensions\&quot;&quot;) \
781      xpr \
782      JSON_HEDLEY_DIAGNOSTIC_POP
783  #      endif
784  #    else
785  #      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
786      JSON_HEDLEY_DIAGNOSTIC_PUSH \
787      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++98-compat\&quot;&quot;) \
788      xpr \
789      JSON_HEDLEY_DIAGNOSTIC_POP
790  #    endif
791  #  endif
792  #endif
793  #if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
794      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
795  #endif
796  #if defined(JSON_HEDLEY_CONST_CAST)
797      #undef JSON_HEDLEY_CONST_CAST
798  #endif
799  #if defined(__cplusplus)
800  #  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast&lt;T&gt;(expr))
801  #elif \
802    JSON_HEDLEY_HAS_WARNING(&quot;-Wcast-qual&quot;) || \
803    JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
804    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
805  #  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
806          JSON_HEDLEY_DIAGNOSTIC_PUSH \
807          JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
808          ((T) (expr)); \
809          JSON_HEDLEY_DIAGNOSTIC_POP \
810      }))
811  #else
812  #  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
813  #endif
814  #if defined(JSON_HEDLEY_REINTERPRET_CAST)
815      #undef JSON_HEDLEY_REINTERPRET_CAST
816  #endif
817  #if defined(__cplusplus)
818      #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast&lt;T&gt;(expr))
819  #else
820      #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
821  #endif
822  #if defined(JSON_HEDLEY_STATIC_CAST)
823      #undef JSON_HEDLEY_STATIC_CAST
824  #endif
825  #if defined(__cplusplus)
826      #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast&lt;T&gt;(expr))
827  #else
828      #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
829  #endif
830  #if defined(JSON_HEDLEY_CPP_CAST)
831      #undef JSON_HEDLEY_CPP_CAST
832  #endif
833  #if defined(__cplusplus)
834  #  if JSON_HEDLEY_HAS_WARNING(&quot;-Wold-style-cast&quot;)
835  #    define JSON_HEDLEY_CPP_CAST(T, expr) \
836      JSON_HEDLEY_DIAGNOSTIC_PUSH \
837      _Pragma(&quot;clang diagnostic ignored \&quot;-Wold-style-cast\&quot;&quot;) \
838      ((T) (expr)) \
839      JSON_HEDLEY_DIAGNOSTIC_POP
840  #  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
841  #    define JSON_HEDLEY_CPP_CAST(T, expr) \
842      JSON_HEDLEY_DIAGNOSTIC_PUSH \
843      _Pragma(&quot;diag_suppress=Pe137&quot;) \
844      JSON_HEDLEY_DIAGNOSTIC_POP
845  #  else
846  #    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
847  #  endif
848  #else
849  #  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
850  #endif
851  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
852      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
853  #endif
854  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wdeprecated-declarations&quot;)
855      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;clang diagnostic ignored \&quot;-Wdeprecated-declarations\&quot;&quot;)
856  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
857      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;warning(disable:1478 1786)&quot;)
858  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
859      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))
860  #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
861      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress 1215,1216,1444,1445&quot;)
862  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
863      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress 1215,1444&quot;)
864  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
865      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;GCC diagnostic ignored \&quot;-Wdeprecated-declarations\&quot;&quot;)
866  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
867      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
868  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
869      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress 1215,1444&quot;)
870  #elif \
871      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
872      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
873      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
874      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
875      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
876      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
877      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
878      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
879      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
880      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
881      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
882      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress 1291,1718&quot;)
883  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) &amp;&amp; !defined(__cplusplus)
884      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)&quot;)
885  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) &amp;&amp; defined(__cplusplus)
886      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;error_messages(off,symdeprecated,symdeprecated2)&quot;)
887  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
888      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress=Pe1444,Pe1215&quot;)
889  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
890      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;warn(disable:2241)&quot;)
891  #else
892      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
893  #endif
894  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
895      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
896  #endif
897  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunknown-pragmas&quot;)
898      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;clang diagnostic ignored \&quot;-Wunknown-pragmas\&quot;&quot;)
899  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
900      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;warning(disable:161)&quot;)
901  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
902      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))
903  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
904      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress 1675&quot;)
905  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
906      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;GCC diagnostic ignored \&quot;-Wunknown-pragmas\&quot;&quot;)
907  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
908      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
909  #elif \
910      JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
911      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
912      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
913      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
914      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress 163&quot;)
915  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
916      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress 163&quot;)
917  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
918      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress=Pe161&quot;)
919  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
920      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress 161&quot;)
921  #else
922      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
923  #endif
924  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
925      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
926  #endif
927  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunknown-attributes&quot;)
928      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;clang diagnostic ignored \&quot;-Wunknown-attributes\&quot;&quot;)
929  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
930      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;GCC diagnostic ignored \&quot;-Wdeprecated-declarations\&quot;&quot;)
931  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
932      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;warning(disable:1292)&quot;)
933  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
934      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))
935  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
936      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
937  #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
938      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress 1097,1098&quot;)
939  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
940      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress 1097&quot;)
941  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) &amp;&amp; defined(__cplusplus)
942      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;error_messages(off,attrskipunsup)&quot;)
943  #elif \
944      JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
945      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
946      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
947      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress 1173&quot;)
948  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
949      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress=Pe1097&quot;)
950  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
951      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress 1097&quot;)
952  #else
953      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
954  #endif
955  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
956      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
957  #endif
958  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wcast-qual&quot;)
959      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(&quot;clang diagnostic ignored \&quot;-Wcast-qual\&quot;&quot;)
960  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
961      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(&quot;warning(disable:2203 2331)&quot;)
962  #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
963      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(&quot;GCC diagnostic ignored \&quot;-Wcast-qual\&quot;&quot;)
964  #else
965      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
966  #endif
967  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)
968      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
969  #endif
970  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunused-function&quot;)
971      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(&quot;clang diagnostic ignored \&quot;-Wunused-function\&quot;&quot;)
972  #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)
973      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(&quot;GCC diagnostic ignored \&quot;-Wunused-function\&quot;&quot;)
974  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)
975      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))
976  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
977      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(&quot;diag_suppress 3142&quot;)
978  #else
979      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
980  #endif
981  #if defined(JSON_HEDLEY_DEPRECATED)
982      #undef JSON_HEDLEY_DEPRECATED
983  #endif
984  #if defined(JSON_HEDLEY_DEPRECATED_FOR)
985      #undef JSON_HEDLEY_DEPRECATED_FOR
986  #endif
987  #if \
988      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
989      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
990      #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated(&quot;Since &quot; # since))
991      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated(&quot;Since &quot; #since &quot;; use &quot; #replacement))
992  #elif \
993      (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) &amp;&amp; !defined(JSON_HEDLEY_IAR_VERSION)) || \
994      JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
995      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
996      JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
997      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
998      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
999      JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
1000      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
1001      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
1002      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1003      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \
1004      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1005      #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__(&quot;Since &quot; #since)))
1006      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__(&quot;Since &quot; #since &quot;; use &quot; #replacement)))
1007  #elif defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201402L)
1008      #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated(&quot;Since &quot; #since)]])
1009      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated(&quot;Since &quot; #since &quot;; use &quot; #replacement)]])
1010  #elif \
1011      JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
1012      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1013      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1014      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1015      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1016      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1017      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1018      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1019      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1020      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1021      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1022      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1023      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1024      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1025      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1026      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1027      #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
1028      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
1029  #elif \
1030      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1031      JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \
1032      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1033      #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
1034      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
1035  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1036      #define JSON_HEDLEY_DEPRECATED(since) _Pragma(&quot;deprecated&quot;)
1037      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma(&quot;deprecated&quot;)
1038  #else
1039      #define JSON_HEDLEY_DEPRECATED(since)
1040      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
1041  #endif
1042  #if defined(JSON_HEDLEY_UNAVAILABLE)
1043      #undef JSON_HEDLEY_UNAVAILABLE
1044  #endif
1045  #if \
1046      JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
1047      JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
1048      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1049      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1050      #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__(&quot;Not available until &quot; #available_since)))
1051  #else
1052      #define JSON_HEDLEY_UNAVAILABLE(available_since)
1053  #endif
1054  #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
1055      #undef JSON_HEDLEY_WARN_UNUSED_RESULT
1056  #endif
1057  #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
1058      #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
1059  #endif
1060  #if \
1061      JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
1062      JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1063      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1064      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1065      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1066      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1067      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1068      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1069      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1070      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1071      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1072      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1073      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1074      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1075      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) &amp;&amp; defined(__cplusplus)) || \
1076      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1077      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1078      #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
1079      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
1080  #elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) &gt;= 201907L)
1081      #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1082      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
1083  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
1084      #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1085      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1086  #elif defined(_Check_return_) &amp;bsol;* SAL */
1087      #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
1088      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
1089  #else
1090      #define JSON_HEDLEY_WARN_UNUSED_RESULT
1091      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
1092  #endif
1093  #if defined(JSON_HEDLEY_SENTINEL)
1094      #undef JSON_HEDLEY_SENTINEL
1095  #endif
1096  #if \
1097      JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
1098      JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1099      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1100      JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
1101      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1102      #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
1103  #else
1104      #define JSON_HEDLEY_SENTINEL(position)
1105  #endif
1106  #if defined(JSON_HEDLEY_NO_RETURN)
1107      #undef JSON_HEDLEY_NO_RETURN
1108  #endif
1109  #if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1110      #define JSON_HEDLEY_NO_RETURN __noreturn
1111  #elif \
1112      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1113      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1114      #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
1115  #elif defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 201112L
1116      #define JSON_HEDLEY_NO_RETURN _Noreturn
1117  #elif defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L)
1118      #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
1119  #elif \
1120      JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
1121      JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
1122      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1123      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1124      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1125      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1126      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1127      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1128      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1129      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1130      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1131      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1132      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1133      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1134      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1135      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1136      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1137      #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
1138  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1139      #define JSON_HEDLEY_NO_RETURN _Pragma(&quot;does_not_return&quot;)
1140  #elif \
1141      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1142      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1143      #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
1144  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) &amp;&amp; defined(__cplusplus)
1145      #define JSON_HEDLEY_NO_RETURN _Pragma(&quot;FUNC_NEVER_RETURNS;&quot;)
1146  #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
1147      #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
1148  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
1149      #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
1150  #else
1151      #define JSON_HEDLEY_NO_RETURN
1152  #endif
1153  #if defined(JSON_HEDLEY_NO_ESCAPE)
1154      #undef JSON_HEDLEY_NO_ESCAPE
1155  #endif
1156  #if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
1157      #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
1158  #else
1159      #define JSON_HEDLEY_NO_ESCAPE
1160  #endif
1161  #if defined(JSON_HEDLEY_UNREACHABLE)
1162      #undef JSON_HEDLEY_UNREACHABLE
1163  #endif
1164  #if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
1165      #undef JSON_HEDLEY_UNREACHABLE_RETURN
1166  #endif
1167  #if defined(JSON_HEDLEY_ASSUME)
1168      #undef JSON_HEDLEY_ASSUME
1169  #endif
1170  #if \
1171      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1172      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1173      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1174      #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
1175  #elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
1176      #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
1177  #elif \
1178      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1179      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
1180      #if defined(__cplusplus)
1181          #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
1182      #else
1183          #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
1184      #endif
1185  #endif
1186  #if \
1187      (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) &amp;&amp; (!defined(JSON_HEDLEY_ARM_VERSION))) || \
1188      JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
1189      JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
1190      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1191      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \
1192      JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \
1193      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1194      #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
1195  #elif defined(JSON_HEDLEY_ASSUME)
1196      #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
1197  #endif
1198  #if !defined(JSON_HEDLEY_ASSUME)
1199      #if defined(JSON_HEDLEY_UNREACHABLE)
1200          #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
1201      #else
1202          #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
1203      #endif
1204  #endif
1205  #if defined(JSON_HEDLEY_UNREACHABLE)
1206      #if  \
1207          JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1208          JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
1209          #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
1210      #else
1211          #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
1212      #endif
1213  #else
1214      #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
1215  #endif
1216  #if !defined(JSON_HEDLEY_UNREACHABLE)
1217      #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
1218  #endif
1219  JSON_HEDLEY_DIAGNOSTIC_PUSH
1220  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wpedantic&quot;)
1221      #pragma clang diagnostic ignored &quot;-Wpedantic&quot;
1222  #endif
1223  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wc++98-compat-pedantic&quot;) &amp;&amp; defined(__cplusplus)
1224      #pragma clang diagnostic ignored &quot;-Wc++98-compat-pedantic&quot;
1225  #endif
1226  #if JSON_HEDLEY_GCC_HAS_WARNING(&quot;-Wvariadic-macros&quot;,4,0,0)
1227      #if defined(__clang__)
1228          #pragma clang diagnostic ignored &quot;-Wvariadic-macros&quot;
1229      #elif defined(JSON_HEDLEY_GCC_VERSION)
1230          #pragma GCC diagnostic ignored &quot;-Wvariadic-macros&quot;
1231      #endif
1232  #endif
1233  #if defined(JSON_HEDLEY_NON_NULL)
1234      #undef JSON_HEDLEY_NON_NULL
1235  #endif
1236  #if \
1237      JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
1238      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1239      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1240      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
1241      #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
1242  #else
1243      #define JSON_HEDLEY_NON_NULL(...)
1244  #endif
1245  JSON_HEDLEY_DIAGNOSTIC_POP
1246  #if defined(JSON_HEDLEY_PRINTF_FORMAT)
1247      #undef JSON_HEDLEY_PRINTF_FORMAT
1248  #endif
1249  #if defined(__MINGW32__) &amp;&amp; JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) &amp;&amp; !defined(__USE_MINGW_ANSI_STDIO)
1250      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
1251  #elif defined(__MINGW32__) &amp;&amp; JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) &amp;&amp; defined(__USE_MINGW_ANSI_STDIO)
1252      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
1253  #elif \
1254      JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
1255      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1256      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1257      JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
1258      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1259      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1260      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1261      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1262      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1263      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1264      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1265      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1266      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1267      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1268      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1269      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1270      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1271      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
1272  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
1273      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
1274  #else
1275      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
1276  #endif
1277  #if defined(JSON_HEDLEY_CONSTEXPR)
1278      #undef JSON_HEDLEY_CONSTEXPR
1279  #endif
1280  #if defined(__cplusplus)
1281      #if __cplusplus &gt;= 201103L
1282          #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
1283      #endif
1284  #endif
1285  #if !defined(JSON_HEDLEY_CONSTEXPR)
1286      #define JSON_HEDLEY_CONSTEXPR
1287  #endif
1288  #if defined(JSON_HEDLEY_PREDICT)
1289      #undef JSON_HEDLEY_PREDICT
1290  #endif
1291  #if defined(JSON_HEDLEY_LIKELY)
1292      #undef JSON_HEDLEY_LIKELY
1293  #endif
1294  #if defined(JSON_HEDLEY_UNLIKELY)
1295      #undef JSON_HEDLEY_UNLIKELY
1296  #endif
1297  #if defined(JSON_HEDLEY_UNPREDICTABLE)
1298      #undef JSON_HEDLEY_UNPREDICTABLE
1299  #endif
1300  #if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
1301      #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
1302  #endif
1303  #if \
1304    (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) &amp;&amp; !defined(JSON_HEDLEY_PGI_VERSION)) || \
1305    JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \
1306    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1307  #  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
1308  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
1309  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
1310  #  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
1311  #  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
1312  #elif \
1313    (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) &amp;&amp; !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
1314    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
1315    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1316    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) &amp;&amp; defined(__cplusplus)) || \
1317    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1318    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1319    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1320    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
1321    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
1322    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
1323    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1324    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1325    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1326    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
1327    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1328    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1329  #  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
1330      (((probability) &gt;= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
1331  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
1332      (__extension__ ({ \
1333          double hedley_probability_ = (probability); \
1334          ((hedley_probability_ &gt;= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ &lt;= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
1335      }))
1336  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
1337      (__extension__ ({ \
1338          double hedley_probability_ = (probability); \
1339          ((hedley_probability_ &gt;= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ &lt;= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
1340      }))
1341  #  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
1342  #  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
1343  #else
1344  #  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
1345  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
1346  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
1347  #  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
1348  #  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
1349  #endif
1350  #if !defined(JSON_HEDLEY_UNPREDICTABLE)
1351      #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
1352  #endif
1353  #if defined(JSON_HEDLEY_MALLOC)
1354      #undef JSON_HEDLEY_MALLOC
1355  #endif
1356  #if \
1357      JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
1358      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1359      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1360      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1361      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1362      JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
1363      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1364      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1365      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1366      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1367      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1368      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1369      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1370      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1371      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1372      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1373      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1374      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1375      #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
1376  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1377      #define JSON_HEDLEY_MALLOC _Pragma(&quot;returns_new_memory&quot;)
1378  #elif \
1379      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1380      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1381      #define JSON_HEDLEY_MALLOC __declspec(restrict)
1382  #else
1383      #define JSON_HEDLEY_MALLOC
1384  #endif
1385  #if defined(JSON_HEDLEY_PURE)
1386      #undef JSON_HEDLEY_PURE
1387  #endif
1388  #if \
1389    JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
1390    JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
1391    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1392    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1393    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1394    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1395    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1396    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1397    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1398    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1399    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1400    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1401    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1402    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1403    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1404    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1405    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1406    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1407    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1408  #  define JSON_HEDLEY_PURE __attribute__((__pure__))
1409  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1410  #  define JSON_HEDLEY_PURE _Pragma(&quot;does_not_write_global_data&quot;)
1411  #elif defined(__cplusplus) &amp;&amp; \
1412      ( \
1413        JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
1414        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
1415        JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
1416      )
1417  #  define JSON_HEDLEY_PURE _Pragma(&quot;FUNC_IS_PURE;&quot;)
1418  #else
1419  #  define JSON_HEDLEY_PURE
1420  #endif
1421  #if defined(JSON_HEDLEY_CONST)
1422      #undef JSON_HEDLEY_CONST
1423  #endif
1424  #if \
1425      JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
1426      JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
1427      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1428      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1429      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1430      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1431      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1432      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1433      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1434      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1435      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1436      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1437      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1438      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1439      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1440      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1441      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1442      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1443      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1444      #define JSON_HEDLEY_CONST __attribute__((__const__))
1445  #elif \
1446      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1447      #define JSON_HEDLEY_CONST _Pragma(&quot;no_side_effect&quot;)
1448  #else
1449      #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
1450  #endif
1451  #if defined(JSON_HEDLEY_RESTRICT)
1452      #undef JSON_HEDLEY_RESTRICT
1453  #endif
1454  #if defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L) &amp;&amp; !defined(__cplusplus)
1455      #define JSON_HEDLEY_RESTRICT restrict
1456  #elif \
1457      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1458      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1459      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1460      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1461      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1462      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1463      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1464      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1465      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
1466      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
1467      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1468      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) &amp;&amp; defined(__cplusplus)) || \
1469      JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
1470      defined(__clang__) || \
1471      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1472      #define JSON_HEDLEY_RESTRICT __restrict
1473  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) &amp;&amp; !defined(__cplusplus)
1474      #define JSON_HEDLEY_RESTRICT _Restrict
1475  #else
1476      #define JSON_HEDLEY_RESTRICT
1477  #endif
1478  #if defined(JSON_HEDLEY_INLINE)
1479      #undef JSON_HEDLEY_INLINE
1480  #endif
1481  #if \
1482      (defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L)) || \
1483      (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 199711L))
1484      #define JSON_HEDLEY_INLINE inline
1485  #elif \
1486      defined(JSON_HEDLEY_GCC_VERSION) || \
1487      JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
1488      #define JSON_HEDLEY_INLINE __inline__
1489  #elif \
1490      JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
1491      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1492      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1493      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
1494      JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
1495      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1496      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
1497      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1498      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1499      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1500      #define JSON_HEDLEY_INLINE __inline
1501  #else
1502      #define JSON_HEDLEY_INLINE
1503  #endif
1504  #if defined(JSON_HEDLEY_ALWAYS_INLINE)
1505      #undef JSON_HEDLEY_ALWAYS_INLINE
1506  #endif
1507  #if \
1508    JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
1509    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1510    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1511    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1512    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1513    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1514    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1515    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1516    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1517    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1518    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1519    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1520    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1521    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1522    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1523    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1524    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1525    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1526    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1527  #  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
1528  #elif \
1529    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
1530    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1531  #  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
1532  #elif defined(__cplusplus) &amp;&amp; \
1533      ( \
1534        JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1535        JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1536        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1537        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1538        JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1539        JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
1540      )
1541  #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma(&quot;FUNC_ALWAYS_INLINE;&quot;)
1542  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1543  #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma(&quot;inline=forced&quot;)
1544  #else
1545  #  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
1546  #endif
1547  #if defined(JSON_HEDLEY_NEVER_INLINE)
1548      #undef JSON_HEDLEY_NEVER_INLINE
1549  #endif
1550  #if \
1551      JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
1552      JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1553      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1554      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1555      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1556      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1557      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1558      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1559      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1560      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1561      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1562      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1563      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1564      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1565      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1566      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1567      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1568      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1569      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1570      #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
1571  #elif \
1572      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1573      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1574      #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
1575  #elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
1576      #define JSON_HEDLEY_NEVER_INLINE _Pragma(&quot;noinline&quot;)
1577  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) &amp;&amp; defined(__cplusplus)
1578      #define JSON_HEDLEY_NEVER_INLINE _Pragma(&quot;FUNC_CANNOT_INLINE;&quot;)
1579  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1580      #define JSON_HEDLEY_NEVER_INLINE _Pragma(&quot;inline=never&quot;)
1581  #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
1582      #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
1583  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
1584      #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
1585  #else
1586      #define JSON_HEDLEY_NEVER_INLINE
1587  #endif
1588  #if defined(JSON_HEDLEY_PRIVATE)
1589      #undef JSON_HEDLEY_PRIVATE
1590  #endif
1591  #if defined(JSON_HEDLEY_PUBLIC)
1592      #undef JSON_HEDLEY_PUBLIC
1593  #endif
1594  #if defined(JSON_HEDLEY_IMPORT)
1595      #undef JSON_HEDLEY_IMPORT
1596  #endif
1597  #if defined(_WIN32) || defined(__CYGWIN__)
1598  #  define JSON_HEDLEY_PRIVATE
1599  #  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
1600  #  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
1601  #else
1602  #  if \
1603      JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
1604      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1605      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1606      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1607      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1608      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1609      ( \
1610        defined(__TI_EABI__) &amp;&amp; \
1611        ( \
1612          (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1613          JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
1614        ) \
1615      ) || \
1616      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1617  #    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__(&quot;hidden&quot;)))
1618  #    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__(&quot;default&quot;)))
1619  #  else
1620  #    define JSON_HEDLEY_PRIVATE
1621  #    define JSON_HEDLEY_PUBLIC
1622  #  endif
1623  #  define JSON_HEDLEY_IMPORT    extern
1624  #endif
1625  #if defined(JSON_HEDLEY_NO_THROW)
1626      #undef JSON_HEDLEY_NO_THROW
1627  #endif
1628  #if \
1629      JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
1630      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1631      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1632      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1633      #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
1634  #elif \
1635      JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
1636      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1637      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
1638      #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
1639  #else
1640      #define JSON_HEDLEY_NO_THROW
1641  #endif
1642  #if defined(JSON_HEDLEY_FALL_THROUGH)
1643      #undef JSON_HEDLEY_FALL_THROUGH
1644  #endif
1645  #if \
1646      JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
1647      JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \
1648      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1649      #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
1650  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
1651      #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
1652  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
1653      #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
1654  #elif defined(__fallthrough) &amp;bsol;* SAL */
1655      #define JSON_HEDLEY_FALL_THROUGH __fallthrough
1656  #else
1657      #define JSON_HEDLEY_FALL_THROUGH
1658  #endif
1659  #if defined(JSON_HEDLEY_RETURNS_NON_NULL)
1660      #undef JSON_HEDLEY_RETURNS_NON_NULL
1661  #endif
1662  #if \
1663      JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
1664      JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
1665      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1666      #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
1667  #elif defined(_Ret_notnull_) &amp;bsol;* SAL */
1668      #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
1669  #else
1670      #define JSON_HEDLEY_RETURNS_NON_NULL
1671  #endif
1672  #if defined(JSON_HEDLEY_ARRAY_PARAM)
1673      #undef JSON_HEDLEY_ARRAY_PARAM
1674  #endif
1675  #if \
1676      defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L) &amp;&amp; \
1677      !defined(__STDC_NO_VLA__) &amp;&amp; \
1678      !defined(__cplusplus) &amp;&amp; \
1679      !defined(JSON_HEDLEY_PGI_VERSION) &amp;&amp; \
1680      !defined(JSON_HEDLEY_TINYC_VERSION)
1681      #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
1682  #else
1683      #define JSON_HEDLEY_ARRAY_PARAM(name)
1684  #endif
1685  #if defined(JSON_HEDLEY_IS_CONSTANT)
1686      #undef JSON_HEDLEY_IS_CONSTANT
1687  #endif
1688  #if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
1689      #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
1690  #endif
1691  #if defined(JSON_HEDLEY_IS_CONSTEXPR_)
1692      #undef JSON_HEDLEY_IS_CONSTEXPR_
1693  #endif
1694  #if \
1695      JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
1696      JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1697      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1698      JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
1699      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1700      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1701      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1702      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) &amp;&amp; !defined(__cplusplus)) || \
1703      JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1704      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1705      #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
1706  #endif
1707  #if !defined(__cplusplus)
1708  #  if \
1709         JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
1710         JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1711         JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1712         JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1713         JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1714         JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
1715         JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
1716  #if defined(__INTPTR_TYPE__)
1717      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
1718  #else
1719      #include &lt;stdint.h&gt;
1720      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
1721  #endif
1722  #  elif \
1723         ( \
1724            defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 201112L) &amp;&amp; \
1725            !defined(JSON_HEDLEY_SUNPRO_VERSION) &amp;&amp; \
1726            !defined(JSON_HEDLEY_PGI_VERSION) &amp;&amp; \
1727            !defined(JSON_HEDLEY_IAR_VERSION)) || \
1728         (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) &amp;&amp; !defined(JSON_HEDLEY_IAR_VERSION)) || \
1729         JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
1730         JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
1731         JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
1732         JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
1733  #if defined(__INTPTR_TYPE__)
1734      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
1735  #else
1736      #include &lt;stdint.h&gt;
1737      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
1738  #endif
1739  #  elif \
1740         defined(JSON_HEDLEY_GCC_VERSION) || \
1741         defined(JSON_HEDLEY_INTEL_VERSION) || \
1742         defined(JSON_HEDLEY_TINYC_VERSION) || \
1743         defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
1744         JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
1745         defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
1746         defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
1747         defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
1748         defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
1749         defined(__clang__)
1750  #    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
1751          sizeof(void) != \
1752          sizeof(*( \
1753                    1 ? \
1754                    ((void*) ((expr) * 0L) ) : \
1755  ((struct { char v[sizeof(void) * 2]; } *) 1) \
1756                  ) \
1757                ) \
1758                                              )
1759  #  endif
1760  #endif
1761  #if defined(JSON_HEDLEY_IS_CONSTEXPR_)
1762      #if !defined(JSON_HEDLEY_IS_CONSTANT)
1763          #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
1764      #endif
1765      #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
1766  #else
1767      #if !defined(JSON_HEDLEY_IS_CONSTANT)
1768          #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
1769      #endif
1770      #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
1771  #endif
1772  #if defined(JSON_HEDLEY_BEGIN_C_DECLS)
1773      #undef JSON_HEDLEY_BEGIN_C_DECLS
1774  #endif
1775  #if defined(JSON_HEDLEY_END_C_DECLS)
1776      #undef JSON_HEDLEY_END_C_DECLS
1777  #endif
1778  #if defined(JSON_HEDLEY_C_DECL)
1779      #undef JSON_HEDLEY_C_DECL
1780  #endif
1781  #if defined(__cplusplus)
1782      #define JSON_HEDLEY_BEGIN_C_DECLS extern &quot;C&quot; {
1783      #define JSON_HEDLEY_END_C_DECLS }
1784      #define JSON_HEDLEY_C_DECL extern &quot;C&quot;
1785  #else
1786      #define JSON_HEDLEY_BEGIN_C_DECLS
1787      #define JSON_HEDLEY_END_C_DECLS
1788      #define JSON_HEDLEY_C_DECL
1789  #endif
1790  #if defined(JSON_HEDLEY_STATIC_ASSERT)
1791      #undef JSON_HEDLEY_STATIC_ASSERT
1792  #endif
1793  #if \
1794    !defined(__cplusplus) &amp;&amp; ( \
1795        (defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 201112L)) || \
1796        (JSON_HEDLEY_HAS_FEATURE(c_static_assert) &amp;&amp; !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
1797        JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
1798        JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1799        defined(_Static_assert) \
1800      )
1801  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
1802  #elif \
1803    (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L)) || \
1804    JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
1805    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1806  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
1807  #else
1808  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
1809  #endif
1810  #if defined(JSON_HEDLEY_NULL)
1811      #undef JSON_HEDLEY_NULL
1812  #endif
1813  #if defined(__cplusplus)
1814      #if __cplusplus &gt;= 201103L
1815          #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
1816      #elif defined(NULL)
1817          #define JSON_HEDLEY_NULL NULL
1818      #else
1819          #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
1820      #endif
1821  #elif defined(NULL)
1822      #define JSON_HEDLEY_NULL NULL
1823  #else
1824      #define JSON_HEDLEY_NULL ((void*) 0)
1825  #endif
1826  #if defined(JSON_HEDLEY_MESSAGE)
1827      #undef JSON_HEDLEY_MESSAGE
1828  #endif
1829  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunknown-pragmas&quot;)
1830  #  define JSON_HEDLEY_MESSAGE(msg) \
1831      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1832      JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
1833      JSON_HEDLEY_PRAGMA(message msg) \
1834      JSON_HEDLEY_DIAGNOSTIC_POP
1835  #elif \
1836    JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
1837    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1838  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
1839  #elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
1840  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
1841  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1842  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
1843  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
1844  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
1845  #else
1846  #  define JSON_HEDLEY_MESSAGE(msg)
1847  #endif
1848  #if defined(JSON_HEDLEY_WARNING)
1849      #undef JSON_HEDLEY_WARNING
1850  #endif
1851  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunknown-pragmas&quot;)
1852  #  define JSON_HEDLEY_WARNING(msg) \
1853      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1854      JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
1855      JSON_HEDLEY_PRAGMA(clang warning msg) \
1856      JSON_HEDLEY_DIAGNOSTIC_POP
1857  #elif \
1858    JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
1859    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
1860    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1861  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
1862  #elif \
1863    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
1864    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1865  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
1866  #else
1867  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
1868  #endif
1869  #if defined(JSON_HEDLEY_REQUIRE)
1870      #undef JSON_HEDLEY_REQUIRE
1871  #endif
1872  #if defined(JSON_HEDLEY_REQUIRE_MSG)
1873      #undef JSON_HEDLEY_REQUIRE_MSG
1874  #endif
1875  #if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
1876  #  if JSON_HEDLEY_HAS_WARNING(&quot;-Wgcc-compat&quot;)
1877  #    define JSON_HEDLEY_REQUIRE(expr) \
1878      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1879      _Pragma(&quot;clang diagnostic ignored \&quot;-Wgcc-compat\&quot;&quot;) \
1880      __attribute__((diagnose_if(!(expr), #expr, &quot;error&quot;))) \
1881      JSON_HEDLEY_DIAGNOSTIC_POP
1882  #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
1883      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1884      _Pragma(&quot;clang diagnostic ignored \&quot;-Wgcc-compat\&quot;&quot;) \
1885      __attribute__((diagnose_if(!(expr), msg, &quot;error&quot;))) \
1886      JSON_HEDLEY_DIAGNOSTIC_POP
1887  #  else
1888  #    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, &quot;error&quot;)))
1889  #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, &quot;error&quot;)))
1890  #  endif
1891  #else
1892  #  define JSON_HEDLEY_REQUIRE(expr)
1893  #  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
1894  #endif
1895  #if defined(JSON_HEDLEY_FLAGS)
1896      #undef JSON_HEDLEY_FLAGS
1897  #endif
1898  #if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) &amp;&amp; (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING(&quot;-Wbitfield-enum-conversion&quot;))
1899      #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
1900  #else
1901      #define JSON_HEDLEY_FLAGS
1902  #endif
1903  #if defined(JSON_HEDLEY_FLAGS_CAST)
1904      #undef JSON_HEDLEY_FLAGS_CAST
1905  #endif
1906  #if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
1907  #  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
1908          JSON_HEDLEY_DIAGNOSTIC_PUSH \
1909          _Pragma(&quot;warning(disable:188)&quot;) \
1910          ((T) (expr)); \
1911          JSON_HEDLEY_DIAGNOSTIC_POP \
1912      }))
1913  #else
1914  #  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
1915  #endif
1916  #if defined(JSON_HEDLEY_EMPTY_BASES)
1917      #undef JSON_HEDLEY_EMPTY_BASES
1918  #endif
1919  #if \
1920      (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) &amp;&amp; !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \
1921      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1922      #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
1923  #else
1924      #define JSON_HEDLEY_EMPTY_BASES
1925  #endif
1926  #if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
1927      #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
1928  #endif
1929  #if defined(__clang__)
1930      #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
1931  #else
1932      #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
1933  #endif
1934  #if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
1935      #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
1936  #endif
1937  #define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
1938  #if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
1939      #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
1940  #endif
1941  #define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)
1942  #if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
1943      #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
1944  #endif
1945  #define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)
1946  #if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
1947      #undef JSON_HEDLEY_CLANG_HAS_FEATURE
1948  #endif
1949  #define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)
1950  #if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
1951      #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
1952  #endif
1953  #define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)
1954  #if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
1955      #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
1956  #endif
1957  #define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)
1958  #if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
1959      #undef JSON_HEDLEY_CLANG_HAS_WARNING
1960  #endif
1961  #define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)
1962  #endif &amp;bsol;* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION &lt; X) */
1963  #if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
1964      #if defined(__clang__)
1965          #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) &lt; 30400
1966              #error &quot;unsupported Clang version - see https:&amp;bsol;&amp;bsol;github.com/nlohmann/json#supported-compilers&quot;
1967          #endif
1968      #elif defined(__GNUC__) &amp;&amp; !(defined(__ICC) || defined(__INTEL_COMPILER))
1969          #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) &lt; 40800
1970              #error &quot;unsupported GCC version - see https:&amp;bsol;&amp;bsol;github.com/nlohmann/json#supported-compilers&quot;
1971          #endif
1972      #endif
1973  #endif
1974  #if !defined(JSON_HAS_CPP_20) &amp;&amp; !defined(JSON_HAS_CPP_17) &amp;&amp; !defined(JSON_HAS_CPP_14) &amp;&amp; !defined(JSON_HAS_CPP_11)
1975      #if (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 202002L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 202002L)
1976          #define JSON_HAS_CPP_20
1977          #define JSON_HAS_CPP_17
1978          #define JSON_HAS_CPP_14
1979      #elif (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201703L) || (defined(_HAS_CXX17) &amp;&amp; _HAS_CXX17 == 1) 
1980          #define JSON_HAS_CPP_17
1981          #define JSON_HAS_CPP_14
1982      #elif (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201402L) || (defined(_HAS_CXX14) &amp;&amp; _HAS_CXX14 == 1)
1983          #define JSON_HAS_CPP_14
1984      #endif
1985      #define JSON_HAS_CPP_11
1986  #endif
1987  #if defined(__clang__)
1988      #pragma clang diagnostic push
1989      #pragma clang diagnostic ignored &quot;-Wdocumentation&quot;
1990      #pragma clang diagnostic ignored &quot;-Wdocumentation-unknown-command&quot;
1991  #endif
1992  #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) &amp;&amp; !defined(JSON_NOEXCEPTION)
1993      #define JSON_THROW(exception) throw exception
1994      #define JSON_TRY try
1995      #define JSON_CATCH(exception) catch(exception)
1996      #define JSON_INTERNAL_CATCH(exception) catch(exception)
1997  #else
1998      #include &lt;cstdlib&gt;
1999      #define JSON_THROW(exception) std::abort()
2000      #define JSON_TRY if(true)
2001      #define JSON_CATCH(exception) if(false)
2002      #define JSON_INTERNAL_CATCH(exception) if(false)
2003  #endif
2004  #if defined(JSON_THROW_USER)
2005      #undef JSON_THROW
2006      #define JSON_THROW JSON_THROW_USER
2007  #endif
2008  #if defined(JSON_TRY_USER)
2009      #undef JSON_TRY
2010      #define JSON_TRY JSON_TRY_USER
2011  #endif
2012  #if defined(JSON_CATCH_USER)
2013      #undef JSON_CATCH
2014      #define JSON_CATCH JSON_CATCH_USER
2015      #undef JSON_INTERNAL_CATCH
2016      #define JSON_INTERNAL_CATCH JSON_CATCH_USER
2017  #endif
2018  #if defined(JSON_INTERNAL_CATCH_USER)
2019      #undef JSON_INTERNAL_CATCH
2020      #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
2021  #endif
2022  #if !defined(JSON_ASSERT)
2023      #include &lt;cassert&gt; 
2024      #define JSON_ASSERT(x) assert(x)
2025  #endif
2026  #if defined(JSON_TESTS_PRIVATE)
2027      #define JSON_PRIVATE_UNLESS_TESTED public
2028  #else
2029      #define JSON_PRIVATE_UNLESS_TESTED private
2030  #endif
2031  #define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
2032      template&lt;typename BasicJsonType&gt;                                                            \
2033      inline void to_json(BasicJsonType&amp; j, const ENUM_TYPE&amp; e)                                   \
2034      {                                                                                           \
2035          static_assert(std::is_enum&lt;ENUM_TYPE&gt;::value, #ENUM_TYPE &quot; must be an enum!&quot;);          \
2036          static const std::pair&lt;ENUM_TYPE, BasicJsonType&gt; m[] = __VA_ARGS__;                     \
2037          auto it = std::find_if(std::begin(m), std::end(m),                                      \
2038                                 [e](const std::pair&lt;ENUM_TYPE, BasicJsonType&gt;&amp; ej_pair) -&gt; bool  \
2039          {                                                                                       \
2040              return ej_pair.first == e;                                                          \
2041          });                                                                                     \
2042          j = ((it != std::end(m)) ? it : std::begin(m))-&gt;second;                                 \
2043      }                                                                                           \
2044      template&lt;typename BasicJsonType&gt;                                                            \
2045      inline void from_json(const BasicJsonType&amp; j, ENUM_TYPE&amp; e)                                 \
2046      {                                                                                           \
2047          static_assert(std::is_enum&lt;ENUM_TYPE&gt;::value, #ENUM_TYPE &quot; must be an enum!&quot;);          \
2048          static const std::pair&lt;ENUM_TYPE, BasicJsonType&gt; m[] = __VA_ARGS__;                     \
2049          auto it = std::find_if(std::begin(m), std::end(m),                                      \
2050                                 [&amp;j](const std::pair&lt;ENUM_TYPE, BasicJsonType&gt;&amp; ej_pair) -&gt; bool \
2051          {                                                                                       \
2052              return ej_pair.second == j;                                                         \
2053          });                                                                                     \
2054          e = ((it != std::end(m)) ? it : std::begin(m))-&gt;first;                                  \
2055      }
2056  #define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
2057      template&lt;template&lt;typename, typename, typename...&gt; class ObjectType,   \
2058               template&lt;typename, typename...&gt; class ArrayType,              \
2059               class StringType, class BooleanType, class NumberIntegerType, \
2060               class NumberUnsignedType, class NumberFloatType,              \
2061               template&lt;typename&gt; class AllocatorType,                       \
2062               template&lt;typename, typename = void&gt; class JSONSerializer,     \
2063               class BinaryType&gt;
2064  #define NLOHMANN_BASIC_JSON_TPL                                            \
2065      basic_json&lt;ObjectType, ArrayType, StringType, BooleanType,             \
2066      NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
2067      AllocatorType, JSONSerializer, BinaryType&gt;
2068  #define NLOHMANN_JSON_EXPAND( x ) x
2069  #define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
2070  #define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
2071          NLOHMANN_JSON_PASTE64, \
2072          NLOHMANN_JSON_PASTE63, \
2073          NLOHMANN_JSON_PASTE62, \
2074          NLOHMANN_JSON_PASTE61, \
2075          NLOHMANN_JSON_PASTE60, \
2076          NLOHMANN_JSON_PASTE59, \
2077          NLOHMANN_JSON_PASTE58, \
2078          NLOHMANN_JSON_PASTE57, \
2079          NLOHMANN_JSON_PASTE56, \
2080          NLOHMANN_JSON_PASTE55, \
2081          NLOHMANN_JSON_PASTE54, \
2082          NLOHMANN_JSON_PASTE53, \
2083          NLOHMANN_JSON_PASTE52, \
2084          NLOHMANN_JSON_PASTE51, \
2085          NLOHMANN_JSON_PASTE50, \
2086          NLOHMANN_JSON_PASTE49, \
2087          NLOHMANN_JSON_PASTE48, \
2088          NLOHMANN_JSON_PASTE47, \
2089          NLOHMANN_JSON_PASTE46, \
2090          NLOHMANN_JSON_PASTE45, \
2091          NLOHMANN_JSON_PASTE44, \
2092          NLOHMANN_JSON_PASTE43, \
2093          NLOHMANN_JSON_PASTE42, \
2094          NLOHMANN_JSON_PASTE41, \
2095          NLOHMANN_JSON_PASTE40, \
2096          NLOHMANN_JSON_PASTE39, \
2097          NLOHMANN_JSON_PASTE38, \
2098          NLOHMANN_JSON_PASTE37, \
2099          NLOHMANN_JSON_PASTE36, \
2100          NLOHMANN_JSON_PASTE35, \
2101          NLOHMANN_JSON_PASTE34, \
2102          NLOHMANN_JSON_PASTE33, \
2103          NLOHMANN_JSON_PASTE32, \
2104          NLOHMANN_JSON_PASTE31, \
2105          NLOHMANN_JSON_PASTE30, \
2106          NLOHMANN_JSON_PASTE29, \
2107          NLOHMANN_JSON_PASTE28, \
2108          NLOHMANN_JSON_PASTE27, \
2109          NLOHMANN_JSON_PASTE26, \
2110          NLOHMANN_JSON_PASTE25, \
2111          NLOHMANN_JSON_PASTE24, \
2112          NLOHMANN_JSON_PASTE23, \
2113          NLOHMANN_JSON_PASTE22, \
2114          NLOHMANN_JSON_PASTE21, \
2115          NLOHMANN_JSON_PASTE20, \
2116          NLOHMANN_JSON_PASTE19, \
2117          NLOHMANN_JSON_PASTE18, \
2118          NLOHMANN_JSON_PASTE17, \
2119          NLOHMANN_JSON_PASTE16, \
2120          NLOHMANN_JSON_PASTE15, \
2121          NLOHMANN_JSON_PASTE14, \
2122          NLOHMANN_JSON_PASTE13, \
2123          NLOHMANN_JSON_PASTE12, \
2124          NLOHMANN_JSON_PASTE11, \
2125          NLOHMANN_JSON_PASTE10, \
2126          NLOHMANN_JSON_PASTE9, \
2127          NLOHMANN_JSON_PASTE8, \
2128          NLOHMANN_JSON_PASTE7, \
2129          NLOHMANN_JSON_PASTE6, \
2130          NLOHMANN_JSON_PASTE5, \
2131          NLOHMANN_JSON_PASTE4, \
2132          NLOHMANN_JSON_PASTE3, \
2133          NLOHMANN_JSON_PASTE2, \
2134          NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
2135  #define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
2136  #define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
2137  #define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
2138  #define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
2139  #define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
2140  #define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
2141  #define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
2142  #define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
2143  #define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
2144  #define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
2145  #define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
2146  #define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
2147  #define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
2148  #define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
2149  #define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
2150  #define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
2151  #define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
2152  #define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
2153  #define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
2154  #define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
2155  #define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
2156  #define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
2157  #define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
2158  #define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
2159  #define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
2160  #define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
2161  #define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
2162  #define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
2163  #define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
2164  #define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
2165  #define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
2166  #define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
2167  #define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
2168  #define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
2169  #define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
2170  #define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
2171  #define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
2172  #define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
2173  #define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
2174  #define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
2175  #define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
2176  #define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
2177  #define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
2178  #define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
2179  #define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
2180  #define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
2181  #define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
2182  #define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
2183  #define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
2184  #define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
2185  #define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
2186  #define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
2187  #define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
2188  #define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
2189  #define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
2190  #define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
2191  #define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
2192  #define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
2193  #define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
2194  #define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
2195  #define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
2196  #define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
2197  #define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)
2198  #define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
2199  #define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);
2200  #define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
2201      friend void to_json(nlohmann::json&amp; nlohmann_json_j, const Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2202      friend void from_json(const nlohmann::json&amp; nlohmann_json_j, Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
2203  #define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
2204      inline void to_json(nlohmann::json&amp; nlohmann_json_j, const Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2205      inline void from_json(const nlohmann::json&amp; nlohmann_json_j, Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
2206  #ifndef JSON_USE_IMPLICIT_CONVERSIONS
2207      #define JSON_USE_IMPLICIT_CONVERSIONS 1
2208  #endif
2209  #if JSON_USE_IMPLICIT_CONVERSIONS
2210      #define JSON_EXPLICIT
2211  #else
2212      #define JSON_EXPLICIT explicit
2213  #endif
2214  #ifndef JSON_DIAGNOSTICS
2215      #define JSON_DIAGNOSTICS 0
2216  #endif
2217  namespace nlohmann
2218  {
2219  namespace detail
2220  {
2221  inline void replace_substring(std::string&amp; s, const std::string&amp; f,
2222                                const std::string&amp; t)
2223  {
2224      JSON_ASSERT(!f.empty());
2225      for (auto pos = s.find(f);                
2226              pos != std::string::npos;         
2227              s.replace(pos, f.size(), t),      
2228              pos = s.find(f, pos + t.size()))  
2229      {}
2230  }
2231  inline std::string escape(std::string s)
2232  {
2233      replace_substring(s, &quot;~&quot;, &quot;~0&quot;);
2234      replace_substring(s, &quot;/&quot;, &quot;~1&quot;);
2235      return s;
2236  }
2237  static void unescape(std::string&amp; s)
2238  {
2239      replace_substring(s, &quot;~1&quot;, &quot;/&quot;);
2240      replace_substring(s, &quot;~0&quot;, &quot;~&quot;);
2241  }
2242  } 
2243  } 
2244  #include &lt;cstddef&gt; 
2245  namespace nlohmann
2246  {
2247  namespace detail
2248  {
2249  struct position_t
2250  {
2251      std::size_t chars_read_total = 0;
2252      std::size_t chars_read_current_line = 0;
2253      std::size_t lines_read = 0;
2254      constexpr operator size_t() const
2255      {
2256          return chars_read_total;
2257      }
2258  };
2259  } 
2260  } 
2261  namespace nlohmann
2262  {
2263  namespace detail
2264  {
2265  class exception : public std::exception
2266  {
2267    public:
2268      const char* what() const noexcept override
2269      {
2270          return m.what();
2271      }
2272      const int id; 
2273    protected:
2274      JSON_HEDLEY_NON_NULL(3)
2275      exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}
2276      static std::string name(const std::string&amp; ename, int id_)
2277      {
2278          return &quot;[json.exception.&quot; + ename + &quot;.&quot; + std::to_string(id_) + &quot;] &quot;;
2279      }
2280      template&lt;typename BasicJsonType&gt;
2281      static std::string diagnostics(const BasicJsonType&amp; leaf_element)
2282      {
2283  #if JSON_DIAGNOSTICS
2284          std::vector&lt;std::string&gt; tokens;
2285          for (const auto* current = &amp;leaf_element; current-&gt;m_parent != nullptr; current = current-&gt;m_parent)
2286          {
2287              switch (current-&gt;m_parent-&gt;type())
2288              {
2289                  case value_t::array:
2290                  {
2291                      for (std::size_t i = 0; i &lt; current-&gt;m_parent-&gt;m_value.array-&gt;size(); ++i)
2292                      {
2293                          if (&amp;current-&gt;m_parent-&gt;m_value.array-&gt;operator[](i) == current)
2294                          {
2295                              tokens.emplace_back(std::to_string(i));
2296                              break;
2297                          }
2298                      }
2299                      break;
2300                  }
2301                  case value_t::object:
2302                  {
2303                      for (const auto&amp; element : *current-&gt;m_parent-&gt;m_value.object)
2304                      {
2305                          if (&amp;element.second == current)
2306                          {
2307                              tokens.emplace_back(element.first.c_str());
2308                              break;
2309                          }
2310                      }
2311                      break;
2312                  }
2313                  case value_t::null: 
2314                  case value_t::string: 
2315                  case value_t::boolean: 
2316                  case value_t::number_integer: 
2317                  case value_t::number_unsigned: 
2318                  case value_t::number_float: 
2319                  case value_t::binary: 
2320                  case value_t::discarded: 
2321                  default:   
2322                      break; 
2323              }
2324          }
2325          if (tokens.empty())
2326          {
2327              return &quot;&quot;;
2328          }
2329          return &quot;(&quot; + std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},
2330                                       [](const std::string &amp; a, const std::string &amp; b)
2331          {
2332              return a + &quot;/&quot; + detail::escape(b);
2333          }) + &quot;) &quot;;
2334  #else
2335          static_cast&lt;void&gt;(leaf_element);
2336          return &quot;&quot;;
2337  #endif
2338      }
2339    private:
2340      std::runtime_error m;
2341  };
2342  class parse_error : public exception
2343  {
2344    public:
2345      template&lt;typename BasicJsonType&gt;
2346      static parse_error create(int id_, const position_t&amp; pos, const std::string&amp; what_arg, const BasicJsonType&amp; context)
2347      {
2348          std::string w = exception::name(&quot;parse_error&quot;, id_) + &quot;parse error&quot; +
2349                          position_string(pos) + &quot;: &quot; + exception::diagnostics(context) + what_arg;
2350          return parse_error(id_, pos.chars_read_total, w.c_str());
2351      }
2352      template&lt;typename BasicJsonType&gt;
2353      static parse_error create(int id_, std::size_t byte_, const std::string&amp; what_arg, const BasicJsonType&amp; context)
2354      {
2355          std::string w = exception::name(&quot;parse_error&quot;, id_) + &quot;parse error&quot; +
2356                          (byte_ != 0 ? (&quot; at byte &quot; + std::to_string(byte_)) : &quot;&quot;) +
2357                          &quot;: &quot; + exception::diagnostics(context) + what_arg;
2358          return parse_error(id_, byte_, w.c_str());
2359      }
2360      const std::size_t byte;
2361    private:
2362      parse_error(int id_, std::size_t byte_, const char* what_arg)
2363          : exception(id_, what_arg), byte(byte_) {}
2364      static std::string position_string(const position_t&amp; pos)
2365      {
2366          return &quot; at line &quot; + std::to_string(pos.lines_read + 1) +
2367                 &quot;, column &quot; + std::to_string(pos.chars_read_current_line);
2368      }
2369  };
2370  class invalid_iterator : public exception
2371  {
2372    public:
2373      template&lt;typename BasicJsonType&gt;
2374      static invalid_iterator create(int id_, const std::string&amp; what_arg, const BasicJsonType&amp; context)
2375      {
2376          std::string w = exception::name(&quot;invalid_iterator&quot;, id_) + exception::diagnostics(context) + what_arg;
2377          return invalid_iterator(id_, w.c_str());
2378      }
2379    private:
2380      JSON_HEDLEY_NON_NULL(3)
2381      invalid_iterator(int id_, const char* what_arg)
2382          : exception(id_, what_arg) {}
2383  };
2384  class type_error : public exception
2385  {
2386    public:
2387      template&lt;typename BasicJsonType&gt;
2388      static type_error create(int id_, const std::string&amp; what_arg, const BasicJsonType&amp; context)
2389      {
2390          std::string w = exception::name(&quot;type_error&quot;, id_) + exception::diagnostics(context) + what_arg;
2391          return type_error(id_, w.c_str());
2392      }
2393    private:
2394      JSON_HEDLEY_NON_NULL(3)
2395      type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
2396  };
2397  class out_of_range : public exception
2398  {
2399    public:
2400      template&lt;typename BasicJsonType&gt;
2401      static out_of_range create(int id_, const std::string&amp; what_arg, const BasicJsonType&amp; context)
2402      {
2403          std::string w = exception::name(&quot;out_of_range&quot;, id_) + exception::diagnostics(context) + what_arg;
2404          return out_of_range(id_, w.c_str());
2405      }
2406    private:
2407      JSON_HEDLEY_NON_NULL(3)
2408      out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
2409  };
2410  class other_error : public exception
2411  {
2412    public:
2413      template&lt;typename BasicJsonType&gt;
2414      static other_error create(int id_, const std::string&amp; what_arg, const BasicJsonType&amp; context)
2415      {
2416          std::string w = exception::name(&quot;other_error&quot;, id_) + exception::diagnostics(context) + what_arg;
2417          return other_error(id_, w.c_str());
2418      }
2419    private:
2420      JSON_HEDLEY_NON_NULL(3)
2421      other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
2422  };
2423  }  
2424  }  
2425  #include &lt;cstddef&gt; 
2426  #include &lt;type_traits&gt; 
2427  #include &lt;utility&gt; 
2428  namespace nlohmann
2429  {
2430  namespace detail
2431  {
2432  template&lt;typename T&gt;
2433  using uncvref_t = typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type;
2434  #ifdef JSON_HAS_CPP_14
2435  using std::enable_if_t;
2436  using std::index_sequence;
2437  using std::make_index_sequence;
2438  using std::index_sequence_for;
2439  #else
2440  template&lt;bool B, typename T = void&gt;
2441  using enable_if_t = typename std::enable_if&lt;B, T&gt;::type;
2442  template &lt;typename T, T... Ints&gt;
2443  struct integer_sequence
2444  {
2445      using value_type = T;
2446      static constexpr std::size_t size() noexcept
2447      {
2448          return sizeof...(Ints);
2449      }
2450  };
2451  template &lt;size_t... Ints&gt;
2452  using index_sequence = integer_sequence&lt;size_t, Ints...&gt;;
2453  namespace utility_internal
2454  {
2455  template &lt;typename Seq, size_t SeqSize, size_t Rem&gt;
2456  struct Extend;
2457  template &lt;typename T, T... Ints, size_t SeqSize&gt;
2458  struct Extend&lt;integer_sequence&lt;T, Ints...&gt;, SeqSize, 0&gt;
2459  {
2460      using type = integer_sequence &lt; T, Ints..., (Ints + SeqSize)... &gt;;
2461  };
2462  template &lt;typename T, T... Ints, size_t SeqSize&gt;
2463  struct Extend&lt;integer_sequence&lt;T, Ints...&gt;, SeqSize, 1&gt;
2464  {
2465      using type = integer_sequence &lt; T, Ints..., (Ints + SeqSize)..., 2 * SeqSize &gt;;
2466  };
2467  template &lt;typename T, size_t N&gt;
2468  struct Gen
2469  {
2470      using type =
2471          typename Extend &lt; typename Gen &lt; T, N / 2 &gt;::type, N / 2, N % 2 &gt;::type;
2472  };
2473  template &lt;typename T&gt;
2474  struct Gen&lt;T, 0&gt;
2475  {
2476      using type = integer_sequence&lt;T&gt;;
2477  };
2478  }  
2479  template &lt;typename T, T N&gt;
2480  using make_integer_sequence = typename utility_internal::Gen&lt;T, N&gt;::type;
2481  template &lt;size_t N&gt;
2482  using make_index_sequence = make_integer_sequence&lt;size_t, N&gt;;
2483  template &lt;typename... Ts&gt;
2484  using index_sequence_for = make_index_sequence&lt;sizeof...(Ts)&gt;;
2485  #endif
2486  template&lt;unsigned N&gt; struct priority_tag : priority_tag &lt; N - 1 &gt; {};
2487  template&lt;&gt; struct priority_tag&lt;0&gt; {};
2488  template&lt;typename T&gt;
2489  struct static_const
2490  {
2491      static constexpr T value{};
2492  };
2493  template&lt;typename T&gt;
2494  constexpr T static_const&lt;T&gt;::value;
2495  }  
2496  }  
2497  namespace nlohmann
2498  {
2499  namespace detail
2500  {
2501  template &lt;class T&gt; struct identity_tag {};
2502  }  
2503  }  
2504  #include &lt;limits&gt; 
2505  #include &lt;type_traits&gt; 
2506  #include &lt;utility&gt; 
2507  #include &lt;tuple&gt; 
2508  #include &lt;iterator&gt; 
2509  namespace nlohmann
2510  {
2511  namespace detail
2512  {
2513  template&lt;typename ...Ts&gt; struct make_void
2514  {
2515      using type = void;
2516  };
2517  template&lt;typename ...Ts&gt; using void_t = typename make_void&lt;Ts...&gt;::type;
2518  } 
2519  }  
2520  namespace nlohmann
2521  {
2522  namespace detail
2523  {
2524  template&lt;typename It, typename = void&gt;
2525  struct iterator_types {};
2526  template&lt;typename It&gt;
2527  struct iterator_types &lt;
2528      It,
2529      void_t&lt;typename It::difference_type, typename It::value_type, typename It::pointer,
2530      typename It::reference, typename It::iterator_category &gt;&gt;
2531  {
2532      using difference_type = typename It::difference_type;
2533      using value_type = typename It::value_type;
2534      using pointer = typename It::pointer;
2535      using reference = typename It::reference;
2536      using iterator_category = typename It::iterator_category;
2537  };
2538  template&lt;typename T, typename = void&gt;
2539  struct iterator_traits
2540  {
2541  };
2542  template&lt;typename T&gt;
2543  struct iterator_traits &lt; T, enable_if_t &lt; !std::is_pointer&lt;T&gt;::value &gt;&gt;
2544              : iterator_types&lt;T&gt;
2545  {
2546  };
2547  template&lt;typename T&gt;
2548  struct iterator_traits&lt;T*, enable_if_t&lt;std::is_object&lt;T&gt;::value&gt;&gt;
2549  {
2550      using iterator_category = std::random_access_iterator_tag;
2551      using value_type = T;
2552      using difference_type = ptrdiff_t;
2553      using pointer = T*;
2554      using reference = T&amp;;
2555  };
2556  } 
2557  } 
2558  #include &lt;type_traits&gt;
2559  namespace nlohmann
2560  {
2561  namespace detail
2562  {
2563  struct nonesuch
2564  {
2565      nonesuch() = delete;
2566      ~nonesuch() = delete;
2567      nonesuch(nonesuch const&amp;) = delete;
2568      nonesuch(nonesuch const&amp;&amp;) = delete;
2569      void operator=(nonesuch const&amp;) = delete;
2570      void operator=(nonesuch&amp;&amp;) = delete;
2571  };
2572  template&lt;class Default,
2573           class AlwaysVoid,
2574           template&lt;class...&gt; class Op,
2575           class... Args&gt;
2576  struct detector
2577  {
2578      using value_t = std::false_type;
2579      using type = Default;
2580  };
2581  template&lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
2582  struct detector&lt;Default, void_t&lt;Op&lt;Args...&gt;&gt;, Op, Args...&gt;
2583  {
2584      using value_t = std::true_type;
2585      using type = Op&lt;Args...&gt;;
2586  };
2587  template&lt;template&lt;class...&gt; class Op, class... Args&gt;
2588  using is_detected = typename detector&lt;nonesuch, void, Op, Args...&gt;::value_t;
2589  template&lt;template&lt;class...&gt; class Op, class... Args&gt;
2590  struct is_detected_lazy : is_detected&lt;Op, Args...&gt; { };
2591  template&lt;template&lt;class...&gt; class Op, class... Args&gt;
2592  using detected_t = typename detector&lt;nonesuch, void, Op, Args...&gt;::type;
2593  template&lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
2594  using detected_or = detector&lt;Default, void, Op, Args...&gt;;
2595  template&lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
2596  using detected_or_t = typename detected_or&lt;Default, Op, Args...&gt;::type;
2597  template&lt;class Expected, template&lt;class...&gt; class Op, class... Args&gt;
2598  using is_detected_exact = std::is_same&lt;Expected, detected_t&lt;Op, Args...&gt;&gt;;
2599  template&lt;class To, template&lt;class...&gt; class Op, class... Args&gt;
2600  using is_detected_convertible =
2601      std::is_convertible&lt;detected_t&lt;Op, Args...&gt;, To&gt;;
2602  }  
2603  }  
2604  #ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
2605  #define INCLUDE_NLOHMANN_JSON_FWD_HPP_
2606  #include &lt;cstdint&gt; 
2607  #include &lt;map&gt; 
2608  #include &lt;memory&gt; 
2609  #include &lt;string&gt; 
2610  #include &lt;vector&gt; 
2611  namespace nlohmann
2612  {
2613  template&lt;typename T = void, typename SFINAE = void&gt;
2614  struct adl_serializer;
2615  template&lt;template&lt;typename U, typename V, typename... Args&gt; class ObjectType =
2616           std::map,
2617           template&lt;typename U, typename... Args&gt; class ArrayType = std::vector,
2618           class StringType = std::string, class BooleanType = bool,
2619           class NumberIntegerType = std::int64_t,
2620           class NumberUnsignedType = std::uint64_t,
2621           class NumberFloatType = double,
2622           template&lt;typename U&gt; class AllocatorType = std::allocator,
2623           template&lt;typename T, typename SFINAE = void&gt; class JSONSerializer =
2624           adl_serializer,
2625           class BinaryType = std::vector&lt;std::uint8_t&gt;&gt;
2626  class basic_json;
2627  template&lt;typename BasicJsonType&gt;
2628  class json_pointer;
2629  using json = basic_json&lt;&gt;;
2630  template&lt;class Key, class T, class IgnoredLess, class Allocator&gt;
2631  struct ordered_map;
2632  using ordered_json = basic_json&lt;nlohmann::ordered_map&gt;;
2633  }  
2634  #endif  
2635  namespace nlohmann
2636  {
2637  namespace detail
2638  {
2639  template&lt;typename&gt; struct is_basic_json : std::false_type {};
2640  NLOHMANN_BASIC_JSON_TPL_DECLARATION
2641  struct is_basic_json&lt;NLOHMANN_BASIC_JSON_TPL&gt; : std::true_type {};
2642  template&lt;typename&gt;
2643  class json_ref;
2644  template&lt;typename&gt;
2645  struct is_json_ref : std::false_type {};
2646  template&lt;typename T&gt;
2647  struct is_json_ref&lt;json_ref&lt;T&gt;&gt; : std::true_type {};
2648  template&lt;typename T&gt;
2649  using mapped_type_t = typename T::mapped_type;
2650  template&lt;typename T&gt;
2651  using key_type_t = typename T::key_type;
2652  template&lt;typename T&gt;
2653  using value_type_t = typename T::value_type;
2654  template&lt;typename T&gt;
2655  using difference_type_t = typename T::difference_type;
2656  template&lt;typename T&gt;
2657  using pointer_t = typename T::pointer;
2658  template&lt;typename T&gt;
2659  using reference_t = typename T::reference;
2660  template&lt;typename T&gt;
2661  using iterator_category_t = typename T::iterator_category;
2662  template&lt;typename T&gt;
2663  using iterator_t = typename T::iterator;
2664  template&lt;typename T, typename... Args&gt;
2665  using to_json_function = decltype(T::to_json(std::declval&lt;Args&gt;()...));
2666  template&lt;typename T, typename... Args&gt;
2667  using from_json_function = decltype(T::from_json(std::declval&lt;Args&gt;()...));
2668  template&lt;typename T, typename U&gt;
2669  using get_template_function = decltype(std::declval&lt;T&gt;().template get&lt;U&gt;());
2670  template&lt;typename BasicJsonType, typename T, typename = void&gt;
2671  struct has_from_json : std::false_type {};
2672  template &lt;typename BasicJsonType, typename T&gt;
2673  struct is_getable
2674  {
2675      static constexpr bool value = is_detected&lt;get_template_function, const BasicJsonType&amp;, T&gt;::value;
2676  };
2677  template&lt;typename BasicJsonType, typename T&gt;
2678  struct has_from_json &lt; BasicJsonType, T, enable_if_t &lt; !is_basic_json&lt;T&gt;::value &gt;&gt;
2679  {
2680      using serializer = typename BasicJsonType::template json_serializer&lt;T, void&gt;;
2681      static constexpr bool value =
2682          is_detected_exact&lt;void, from_json_function, serializer,
2683          const BasicJsonType&amp;, T&amp;&gt;::value;
2684  };
2685  template&lt;typename BasicJsonType, typename T, typename = void&gt;
2686  struct has_non_default_from_json : std::false_type {};
2687  template&lt;typename BasicJsonType, typename T&gt;
2688  struct has_non_default_from_json &lt; BasicJsonType, T, enable_if_t &lt; !is_basic_json&lt;T&gt;::value &gt;&gt;
2689  {
2690      using serializer = typename BasicJsonType::template json_serializer&lt;T, void&gt;;
2691      static constexpr bool value =
2692          is_detected_exact&lt;T, from_json_function, serializer,
2693          const BasicJsonType&amp;&gt;::value;
2694  };
2695  template&lt;typename BasicJsonType, typename T, typename = void&gt;
2696  struct has_to_json : std::false_type {};
2697  template&lt;typename BasicJsonType, typename T&gt;
2698  struct has_to_json &lt; BasicJsonType, T, enable_if_t &lt; !is_basic_json&lt;T&gt;::value &gt;&gt;
2699  {
2700      using serializer = typename BasicJsonType::template json_serializer&lt;T, void&gt;;
2701      static constexpr bool value =
2702          is_detected_exact&lt;void, to_json_function, serializer, BasicJsonType&amp;,
2703          T&gt;::value;
2704  };
2705  template&lt;class...&gt; struct conjunction : std::true_type { };
2706  template&lt;class B1&gt; struct conjunction&lt;B1&gt; : B1 { };
2707  template&lt;class B1, class... Bn&gt;
2708  struct conjunction&lt;B1, Bn...&gt;
2709  : std::conditional&lt;bool(B1::value), conjunction&lt;Bn...&gt;, B1&gt;::type {};
2710  template&lt;class B&gt; struct negation : std::integral_constant &lt; bool, !B::value &gt; { };
2711  template &lt;typename T&gt;
2712  struct is_default_constructible : std::is_default_constructible&lt;T&gt; {};
2713  template &lt;typename T1, typename T2&gt;
2714  struct is_default_constructible&lt;std::pair&lt;T1, T2&gt;&gt;
2715              : conjunction&lt;is_default_constructible&lt;T1&gt;, is_default_constructible&lt;T2&gt;&gt; {};
2716  template &lt;typename T1, typename T2&gt;
2717  struct is_default_constructible&lt;const std::pair&lt;T1, T2&gt;&gt;
2718              : conjunction&lt;is_default_constructible&lt;T1&gt;, is_default_constructible&lt;T2&gt;&gt; {};
2719  template &lt;typename... Ts&gt;
2720  struct is_default_constructible&lt;std::tuple&lt;Ts...&gt;&gt;
2721              : conjunction&lt;is_default_constructible&lt;Ts&gt;...&gt; {};
2722  template &lt;typename... Ts&gt;
2723  struct is_default_constructible&lt;const std::tuple&lt;Ts...&gt;&gt;
2724              : conjunction&lt;is_default_constructible&lt;Ts&gt;...&gt; {};
2725  template &lt;typename T, typename... Args&gt;
2726  struct is_constructible : std::is_constructible&lt;T, Args...&gt; {};
2727  template &lt;typename T1, typename T2&gt;
2728  struct is_constructible&lt;std::pair&lt;T1, T2&gt;&gt; : is_default_constructible&lt;std::pair&lt;T1, T2&gt;&gt; {};
2729  template &lt;typename T1, typename T2&gt;
2730  struct is_constructible&lt;const std::pair&lt;T1, T2&gt;&gt; : is_default_constructible&lt;const std::pair&lt;T1, T2&gt;&gt; {};
2731  template &lt;typename... Ts&gt;
2732  struct is_constructible&lt;std::tuple&lt;Ts...&gt;&gt; : is_default_constructible&lt;std::tuple&lt;Ts...&gt;&gt; {};
2733  template &lt;typename... Ts&gt;
2734  struct is_constructible&lt;const std::tuple&lt;Ts...&gt;&gt; : is_default_constructible&lt;const std::tuple&lt;Ts...&gt;&gt; {};
2735  template&lt;typename T, typename = void&gt;
2736  struct is_iterator_traits : std::false_type {};
2737  template&lt;typename T&gt;
2738  struct is_iterator_traits&lt;iterator_traits&lt;T&gt;&gt;
2739  {
2740    private:
2741      using traits = iterator_traits&lt;T&gt;;
2742    public:
2743      static constexpr auto value =
2744          is_detected&lt;value_type_t, traits&gt;::value &amp;&amp;
2745          is_detected&lt;difference_type_t, traits&gt;::value &amp;&amp;
2746          is_detected&lt;pointer_t, traits&gt;::value &amp;&amp;
2747          is_detected&lt;iterator_category_t, traits&gt;::value &amp;&amp;
2748          is_detected&lt;reference_t, traits&gt;::value;
2749  };
2750  template&lt;typename T, typename = void&gt;
2751  struct is_complete_type : std::false_type {};
2752  template&lt;typename T&gt;
2753  struct is_complete_type&lt;T, decltype(void(sizeof(T)))&gt; : std::true_type {};
2754  template&lt;typename BasicJsonType, typename CompatibleObjectType,
2755           typename = void&gt;
2756  struct is_compatible_object_type_impl : std::false_type {};
2757  template&lt;typename BasicJsonType, typename CompatibleObjectType&gt;
2758  struct is_compatible_object_type_impl &lt;
2759      BasicJsonType, CompatibleObjectType,
2760      enable_if_t &lt; is_detected&lt;mapped_type_t, CompatibleObjectType&gt;::value&amp;&amp;
2761      is_detected&lt;key_type_t, CompatibleObjectType&gt;::value &gt;&gt;
2762  {
2763      using object_t = typename BasicJsonType::object_t;
2764      static constexpr bool value =
2765          is_constructible&lt;typename object_t::key_type,
2766          typename CompatibleObjectType::key_type&gt;::value &amp;&amp;
2767          is_constructible&lt;typename object_t::mapped_type,
2768          typename CompatibleObjectType::mapped_type&gt;::value;
2769  };
2770  template&lt;typename BasicJsonType, typename CompatibleObjectType&gt;
2771  struct is_compatible_object_type
2772      : is_compatible_object_type_impl&lt;BasicJsonType, CompatibleObjectType&gt; {};
2773  template&lt;typename BasicJsonType, typename ConstructibleObjectType,
2774           typename = void&gt;
2775  struct is_constructible_object_type_impl : std::false_type {};
2776  template&lt;typename BasicJsonType, typename ConstructibleObjectType&gt;
2777  struct is_constructible_object_type_impl &lt;
2778      BasicJsonType, ConstructibleObjectType,
2779      enable_if_t &lt; is_detected&lt;mapped_type_t, ConstructibleObjectType&gt;::value&amp;&amp;
2780      is_detected&lt;key_type_t, ConstructibleObjectType&gt;::value &gt;&gt;
2781  {
2782      using object_t = typename BasicJsonType::object_t;
2783      static constexpr bool value =
2784          (is_default_constructible&lt;ConstructibleObjectType&gt;::value &amp;&amp;
2785           (std::is_move_assignable&lt;ConstructibleObjectType&gt;::value ||
2786            std::is_copy_assignable&lt;ConstructibleObjectType&gt;::value) &amp;&amp;
2787           (is_constructible&lt;typename ConstructibleObjectType::key_type,
2788            typename object_t::key_type&gt;::value &amp;&amp;
2789            std::is_same &lt;
2790            typename object_t::mapped_type,
2791            typename ConstructibleObjectType::mapped_type &gt;::value)) ||
2792          (has_from_json&lt;BasicJsonType,
2793           typename ConstructibleObjectType::mapped_type&gt;::value ||
2794           has_non_default_from_json &lt;
2795           BasicJsonType,
2796           typename ConstructibleObjectType::mapped_type &gt;::value);
2797  };
2798  template&lt;typename BasicJsonType, typename ConstructibleObjectType&gt;
2799  struct is_constructible_object_type
2800      : is_constructible_object_type_impl&lt;BasicJsonType,
2801        ConstructibleObjectType&gt; {};
2802  template&lt;typename BasicJsonType, typename CompatibleStringType,
2803           typename = void&gt;
2804  struct is_compatible_string_type_impl : std::false_type {};
2805  template&lt;typename BasicJsonType, typename CompatibleStringType&gt;
2806  struct is_compatible_string_type_impl &lt;
2807      BasicJsonType, CompatibleStringType,
2808      enable_if_t&lt;is_detected_exact&lt;typename BasicJsonType::string_t::value_type,
2809      value_type_t, CompatibleStringType&gt;::value &gt;&gt;
2810  {
2811      static constexpr auto value =
2812          is_constructible&lt;typename BasicJsonType::string_t, CompatibleStringType&gt;::value;
2813  };
2814  template&lt;typename BasicJsonType, typename ConstructibleStringType&gt;
2815  struct is_compatible_string_type
2816      : is_compatible_string_type_impl&lt;BasicJsonType, ConstructibleStringType&gt; {};
2817  template&lt;typename BasicJsonType, typename ConstructibleStringType,
2818           typename = void&gt;
2819  struct is_constructible_string_type_impl : std::false_type {};
2820  template&lt;typename BasicJsonType, typename ConstructibleStringType&gt;
2821  struct is_constructible_string_type_impl &lt;
2822      BasicJsonType, ConstructibleStringType,
2823      enable_if_t&lt;is_detected_exact&lt;typename BasicJsonType::string_t::value_type,
2824      value_type_t, ConstructibleStringType&gt;::value &gt;&gt;
2825  {
2826      static constexpr auto value =
2827          is_constructible&lt;ConstructibleStringType,
2828          typename BasicJsonType::string_t&gt;::value;
2829  };
2830  template&lt;typename BasicJsonType, typename ConstructibleStringType&gt;
2831  struct is_constructible_string_type
2832      : is_constructible_string_type_impl&lt;BasicJsonType, ConstructibleStringType&gt; {};
2833  template&lt;typename BasicJsonType, typename CompatibleArrayType, typename = void&gt;
2834  struct is_compatible_array_type_impl : std::false_type {};
2835  template&lt;typename BasicJsonType, typename CompatibleArrayType&gt;
2836  struct is_compatible_array_type_impl &lt;
2837      BasicJsonType, CompatibleArrayType,
2838      enable_if_t &lt; is_detected&lt;value_type_t, CompatibleArrayType&gt;::value&amp;&amp;
2839      is_detected&lt;iterator_t, CompatibleArrayType&gt;::value&amp;&amp;
2840      !is_iterator_traits &lt;
2841      iterator_traits&lt;CompatibleArrayType &gt;&gt;::value &gt;&gt;
2842  {
2843      static constexpr bool value =
2844          is_constructible&lt;BasicJsonType,
2845          typename CompatibleArrayType::value_type&gt;::value;
2846  };
2847  template&lt;typename BasicJsonType, typename CompatibleArrayType&gt;
2848  struct is_compatible_array_type
2849      : is_compatible_array_type_impl&lt;BasicJsonType, CompatibleArrayType&gt; {};
2850  template&lt;typename BasicJsonType, typename ConstructibleArrayType, typename = void&gt;
2851  struct is_constructible_array_type_impl : std::false_type {};
2852  template&lt;typename BasicJsonType, typename ConstructibleArrayType&gt;
2853  struct is_constructible_array_type_impl &lt;
2854      BasicJsonType, ConstructibleArrayType,
2855      enable_if_t&lt;std::is_same&lt;ConstructibleArrayType,
2856      typename BasicJsonType::value_type&gt;::value &gt;&gt;
2857              : std::true_type {};
2858  template&lt;typename BasicJsonType, typename ConstructibleArrayType&gt;
2859  struct is_constructible_array_type_impl &lt;
2860      BasicJsonType, ConstructibleArrayType,
2861      enable_if_t &lt; !std::is_same&lt;ConstructibleArrayType,
2862      typename BasicJsonType::value_type&gt;::value&amp;&amp;
2863      is_default_constructible&lt;ConstructibleArrayType&gt;::value&amp;&amp;
2864  (std::is_move_assignable&lt;ConstructibleArrayType&gt;::value ||
2865   std::is_copy_assignable&lt;ConstructibleArrayType&gt;::value)&amp;&amp;
2866  is_detected&lt;value_type_t, ConstructibleArrayType&gt;::value&amp;&amp;
2867  is_detected&lt;iterator_t, ConstructibleArrayType&gt;::value&amp;&amp;
2868  is_complete_type &lt;
2869  detected_t&lt;value_type_t, ConstructibleArrayType &gt;&gt;::value &gt;&gt;
2870  {
2871      static constexpr bool value =
2872          !is_iterator_traits&lt;iterator_traits&lt;ConstructibleArrayType&gt;&gt;::value &amp;&amp;
2873          (std::is_same&lt;typename ConstructibleArrayType::value_type,
2874           typename BasicJsonType::array_t::value_type&gt;::value ||
2875           has_from_json&lt;BasicJsonType,
2876           typename ConstructibleArrayType::value_type&gt;::value ||
2877           has_non_default_from_json &lt;
2878           BasicJsonType, typename ConstructibleArrayType::value_type &gt;::value);
2879  };
2880  template&lt;typename BasicJsonType, typename ConstructibleArrayType&gt;
2881  struct is_constructible_array_type
2882      : is_constructible_array_type_impl&lt;BasicJsonType, ConstructibleArrayType&gt; {};
2883  template&lt;typename RealIntegerType, typename CompatibleNumberIntegerType,
2884           typename = void&gt;
2885  struct is_compatible_integer_type_impl : std::false_type {};
2886  template&lt;typename RealIntegerType, typename CompatibleNumberIntegerType&gt;
2887  struct is_compatible_integer_type_impl &lt;
2888      RealIntegerType, CompatibleNumberIntegerType,
2889      enable_if_t &lt; std::is_integral&lt;RealIntegerType&gt;::value&amp;&amp;
2890      std::is_integral&lt;CompatibleNumberIntegerType&gt;::value&amp;&amp;
2891      !std::is_same&lt;bool, CompatibleNumberIntegerType&gt;::value &gt;&gt;
2892  {
2893      using RealLimits = std::numeric_limits&lt;RealIntegerType&gt;;
2894      using CompatibleLimits = std::numeric_limits&lt;CompatibleNumberIntegerType&gt;;
2895      static constexpr auto value =
2896          is_constructible&lt;RealIntegerType,
2897          CompatibleNumberIntegerType&gt;::value &amp;&amp;
2898          CompatibleLimits::is_integer &amp;&amp;
2899          RealLimits::is_signed == CompatibleLimits::is_signed;
2900  };
2901  template&lt;typename RealIntegerType, typename CompatibleNumberIntegerType&gt;
2902  struct is_compatible_integer_type
2903      : is_compatible_integer_type_impl&lt;RealIntegerType,
2904        CompatibleNumberIntegerType&gt; {};
2905  template&lt;typename BasicJsonType, typename CompatibleType, typename = void&gt;
2906  struct is_compatible_type_impl: std::false_type {};
2907  template&lt;typename BasicJsonType, typename CompatibleType&gt;
2908  struct is_compatible_type_impl &lt;
2909      BasicJsonType, CompatibleType,
2910      enable_if_t&lt;is_complete_type&lt;CompatibleType&gt;::value &gt;&gt;
2911  {
2912      static constexpr bool value =
2913          has_to_json&lt;BasicJsonType, CompatibleType&gt;::value;
2914  };
2915  template&lt;typename BasicJsonType, typename CompatibleType&gt;
2916  struct is_compatible_type
2917      : is_compatible_type_impl&lt;BasicJsonType, CompatibleType&gt; {};
2918  template&lt;typename T1, typename T2&gt;
2919  struct is_constructible_tuple : std::false_type {};
2920  template&lt;typename T1, typename... Args&gt;
2921  struct is_constructible_tuple&lt;T1, std::tuple&lt;Args...&gt;&gt; : conjunction&lt;is_constructible&lt;T1, Args&gt;...&gt; {};
2922  template &lt;typename T&gt;
2923  struct is_ordered_map
2924  {
2925      using one = char;
2926      struct two
2927      {
2928          char x[2]; 
2929      };
2930      template &lt;typename C&gt; static one test( decltype(&amp;C::capacity) ) ;
2931      template &lt;typename C&gt; static two test(...);
2932      enum { value = sizeof(test&lt;T&gt;(nullptr)) == sizeof(char) }; 
2933  };
2934  template &lt; typename T, typename U, enable_if_t &lt; !std::is_same&lt;T, U&gt;::value, int &gt; = 0 &gt;
2935  T conditional_static_cast(U value)
2936  {
2937      return static_cast&lt;T&gt;(value);
2938  }
2939  template&lt;typename T, typename U, enable_if_t&lt;std::is_same&lt;T, U&gt;::value, int&gt; = 0&gt;
2940  T conditional_static_cast(U value)
2941  {
2942      return value;
2943  }
2944  }  
2945  }  
2946  namespace nlohmann
2947  {
2948  namespace detail
2949  {
2950  template&lt;typename BasicJsonType&gt;
2951  void from_json(const BasicJsonType&amp; j, typename std::nullptr_t&amp; n)
2952  {
2953      if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
2954      {
2955          JSON_THROW(type_error::create(302, &quot;type must be null, but is &quot; + std::string(j.type_name()), j));
2956      }
2957      n = nullptr;
2958  }
2959  template &lt; typename BasicJsonType, typename ArithmeticType,
2960             enable_if_t &lt; std::is_arithmetic&lt;ArithmeticType&gt;::value&amp;&amp;
2961                           !std::is_same&lt;ArithmeticType, typename BasicJsonType::boolean_t&gt;::value,
2962                           int &gt; = 0 &gt;
2963  void get_arithmetic_value(const BasicJsonType&amp; j, ArithmeticType&amp; val)
2964  {
2965      switch (static_cast&lt;value_t&gt;(j))
2966      {
2967          case value_t::number_unsigned:
2968          {
2969              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_unsigned_t*&gt;());
2970              break;
2971          }
2972          case value_t::number_integer:
2973          {
2974              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_integer_t*&gt;());
2975              break;
2976          }
2977          case value_t::number_float:
2978          {
2979              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_float_t*&gt;());
2980              break;
2981          }
2982          case value_t::null:
2983          case value_t::object:
2984          case value_t::array:
2985          case value_t::string:
2986          case value_t::boolean:
2987          case value_t::binary:
2988          case value_t::discarded:
2989          default:
2990              JSON_THROW(type_error::create(302, &quot;type must be number, but is &quot; + std::string(j.type_name()), j));
2991      }
2992  }
2993  template&lt;typename BasicJsonType&gt;
2994  void from_json(const BasicJsonType&amp; j, typename BasicJsonType::boolean_t&amp; b)
2995  {
2996      if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
2997      {
2998          JSON_THROW(type_error::create(302, &quot;type must be boolean, but is &quot; + std::string(j.type_name()), j));
2999      }
3000      b = *j.template get_ptr&lt;const typename BasicJsonType::boolean_t*&gt;();
3001  }
3002  template&lt;typename BasicJsonType&gt;
3003  void from_json(const BasicJsonType&amp; j, typename BasicJsonType::string_t&amp; s)
3004  {
3005      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3006      {
3007          JSON_THROW(type_error::create(302, &quot;type must be string, but is &quot; + std::string(j.type_name()), j));
3008      }
3009      s = *j.template get_ptr&lt;const typename BasicJsonType::string_t*&gt;();
3010  }
3011  template &lt;
3012      typename BasicJsonType, typename ConstructibleStringType,
3013      enable_if_t &lt;
3014          is_constructible_string_type&lt;BasicJsonType, ConstructibleStringType&gt;::value&amp;&amp;
3015          !std::is_same&lt;typename BasicJsonType::string_t,
3016                        ConstructibleStringType&gt;::value,
3017          int &gt; = 0 &gt;
3018  void from_json(const BasicJsonType&amp; j, ConstructibleStringType&amp; s)
3019  {
3020      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3021      {
3022          JSON_THROW(type_error::create(302, &quot;type must be string, but is &quot; + std::string(j.type_name()), j));
3023      }
3024      s = *j.template get_ptr&lt;const typename BasicJsonType::string_t*&gt;();
3025  }
3026  template&lt;typename BasicJsonType&gt;
3027  void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_float_t&amp; val)
3028  {
3029      get_arithmetic_value(j, val);
3030  }
3031  template&lt;typename BasicJsonType&gt;
3032  void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_unsigned_t&amp; val)
3033  {
3034      get_arithmetic_value(j, val);
3035  }
3036  template&lt;typename BasicJsonType&gt;
3037  void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_integer_t&amp; val)
3038  {
3039      get_arithmetic_value(j, val);
3040  }
3041  template&lt;typename BasicJsonType, typename EnumType,
3042           enable_if_t&lt;std::is_enum&lt;EnumType&gt;::value, int&gt; = 0&gt;
3043  void from_json(const BasicJsonType&amp; j, EnumType&amp; e)
3044  {
3045      typename std::underlying_type&lt;EnumType&gt;::type val;
3046      get_arithmetic_value(j, val);
3047      e = static_cast&lt;EnumType&gt;(val);
3048  }
3049  template&lt;typename BasicJsonType, typename T, typename Allocator,
3050           enable_if_t&lt;is_getable&lt;BasicJsonType, T&gt;::value, int&gt; = 0&gt;
3051  void from_json(const BasicJsonType&amp; j, std::forward_list&lt;T, Allocator&gt;&amp; l)
3052  {
3053      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3054      {
3055          JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name()), j));
3056      }
3057      l.clear();
3058      std::transform(j.rbegin(), j.rend(),
3059                     std::front_inserter(l), [](const BasicJsonType &amp; i)
3060      {
3061          return i.template get&lt;T&gt;();
3062      });
3063  }
3064  template&lt;typename BasicJsonType, typename T,
3065           enable_if_t&lt;is_getable&lt;BasicJsonType, T&gt;::value, int&gt; = 0&gt;
3066  void from_json(const BasicJsonType&amp; j, std::valarray&lt;T&gt;&amp; l)
3067  {
3068      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3069      {
3070          JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name()), j));
3071      }
3072      l.resize(j.size());
3073      std::transform(j.begin(), j.end(), std::begin(l),
3074                     [](const BasicJsonType &amp; elem)
3075      {
3076          return elem.template get&lt;T&gt;();
3077      });
3078  }
3079  template&lt;typename BasicJsonType, typename T, std::size_t N&gt;
3080  auto from_json(const BasicJsonType&amp; j, T (&amp;arr)[N]) 
3081  -&gt; decltype(j.template get&lt;T&gt;(), void())
3082  {
3083      for (std::size_t i = 0; i &lt; N; ++i)
3084      {
3085          arr[i] = j.at(i).template get&lt;T&gt;();
3086      }
3087  }
3088  template&lt;typename BasicJsonType&gt;
3089  void from_json_array_impl(const BasicJsonType&amp; j, typename BasicJsonType::array_t&amp; arr, priority_tag&lt;3&gt; &amp;bsol;*unused*/)
3090  {
3091      arr = *j.template get_ptr&lt;const typename BasicJsonType::array_t*&gt;();
3092  }
3093  template&lt;typename BasicJsonType, typename T, std::size_t N&gt;
3094  auto from_json_array_impl(const BasicJsonType&amp; j, std::array&lt;T, N&gt;&amp; arr,
3095                            priority_tag&lt;2&gt; &amp;bsol;*unused*/)
3096  -&gt; decltype(j.template get&lt;T&gt;(), void())
3097  {
3098      for (std::size_t i = 0; i &lt; N; ++i)
3099      {
3100          arr[i] = j.at(i).template get&lt;T&gt;();
3101      }
3102  }
3103  template&lt;typename BasicJsonType, typename ConstructibleArrayType,
3104           enable_if_t&lt;
3105               std::is_assignable&lt;ConstructibleArrayType&amp;, ConstructibleArrayType&gt;::value,
3106               int&gt; = 0&gt;
3107  auto from_json_array_impl(const BasicJsonType&amp; j, ConstructibleArrayType&amp; arr, priority_tag&lt;1&gt; &amp;bsol;*unused*/)
3108  -&gt; decltype(
3109      arr.reserve(std::declval&lt;typename ConstructibleArrayType::size_type&gt;()),
3110      j.template get&lt;typename ConstructibleArrayType::value_type&gt;(),
3111      void())
3112  {
3113      using std::end;
3114      ConstructibleArrayType ret;
3115      ret.reserve(j.size());
3116      std::transform(j.begin(), j.end(),
3117                     std::inserter(ret, end(ret)), [](const BasicJsonType &amp; i)
3118      {
3119          return i.template get&lt;typename ConstructibleArrayType::value_type&gt;();
3120      });
3121      arr = std::move(ret);
3122  }
3123  template&lt;typename BasicJsonType, typename ConstructibleArrayType,
3124           enable_if_t&lt;
3125               std::is_assignable&lt;ConstructibleArrayType&amp;, ConstructibleArrayType&gt;::value,
3126               int&gt; = 0&gt;
3127  void from_json_array_impl(const BasicJsonType&amp; j, ConstructibleArrayType&amp; arr,
3128                            priority_tag&lt;0&gt; &amp;bsol;*unused*/)
3129  {
3130      using std::end;
3131      ConstructibleArrayType ret;
3132      std::transform(
3133          j.begin(), j.end(), std::inserter(ret, end(ret)),
3134          [](const BasicJsonType &amp; i)
3135      {
3136          return i.template get&lt;typename ConstructibleArrayType::value_type&gt;();
3137      });
3138      arr = std::move(ret);
3139  }
3140  template &lt; typename BasicJsonType, typename ConstructibleArrayType,
3141             enable_if_t &lt;
3142                 is_constructible_array_type&lt;BasicJsonType, ConstructibleArrayType&gt;::value&amp;&amp;
3143                 !is_constructible_object_type&lt;BasicJsonType, ConstructibleArrayType&gt;::value&amp;&amp;
3144                 !is_constructible_string_type&lt;BasicJsonType, ConstructibleArrayType&gt;::value&amp;&amp;
3145                 !std::is_same&lt;ConstructibleArrayType, typename BasicJsonType::binary_t&gt;::value&amp;&amp;
3146                 !is_basic_json&lt;ConstructibleArrayType&gt;::value,
3147                 int &gt; = 0 &gt;
3148  auto from_json(const BasicJsonType&amp; j, ConstructibleArrayType&amp; arr)
3149  -&gt; decltype(from_json_array_impl(j, arr, priority_tag&lt;3&gt; {}),
3150  j.template get&lt;typename ConstructibleArrayType::value_type&gt;(),
3151  void())
3152  {
3153      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3154      {
3155          JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name()), j));
3156      }
3157      from_json_array_impl(j, arr, priority_tag&lt;3&gt; {});
3158  }
3159  template &lt; typename BasicJsonType, typename T, std::size_t... Idx &gt;
3160  std::array&lt;T, sizeof...(Idx)&gt; from_json_inplace_array_impl(BasicJsonType&amp;&amp; j,
3161          identity_tag&lt;std::array&lt;T, sizeof...(Idx)&gt;&gt; &amp;bsol;*unused*/, index_sequence&lt;Idx...&gt; &amp;bsol;*unused*/)
3162  {
3163      return { { std::forward&lt;BasicJsonType&gt;(j).at(Idx).template get&lt;T&gt;()... } };
3164  }
3165  template &lt; typename BasicJsonType, typename T, std::size_t N &gt;
3166  auto from_json(BasicJsonType&amp;&amp; j, identity_tag&lt;std::array&lt;T, N&gt;&gt; tag)
3167  -&gt; decltype(from_json_inplace_array_impl(std::forward&lt;BasicJsonType&gt;(j), tag, make_index_sequence&lt;N&gt; {}))
3168  {
3169      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3170      {
3171          JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name()), j));
3172      }
3173      return from_json_inplace_array_impl(std::forward&lt;BasicJsonType&gt;(j), tag, make_index_sequence&lt;N&gt; {});
3174  }
3175  template&lt;typename BasicJsonType&gt;
3176  void from_json(const BasicJsonType&amp; j, typename BasicJsonType::binary_t&amp; bin)
3177  {
3178      if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
3179      {
3180          JSON_THROW(type_error::create(302, &quot;type must be binary, but is &quot; + std::string(j.type_name()), j));
3181      }
3182      bin = *j.template get_ptr&lt;const typename BasicJsonType::binary_t*&gt;();
3183  }
3184  template&lt;typename BasicJsonType, typename ConstructibleObjectType,
3185           enable_if_t&lt;is_constructible_object_type&lt;BasicJsonType, ConstructibleObjectType&gt;::value, int&gt; = 0&gt;
3186  void from_json(const BasicJsonType&amp; j, ConstructibleObjectType&amp; obj)
3187  {
3188      if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
3189      {
3190          JSON_THROW(type_error::create(302, &quot;type must be object, but is &quot; + std::string(j.type_name()), j));
3191      }
3192      ConstructibleObjectType ret;
3193      const auto* inner_object = j.template get_ptr&lt;const typename BasicJsonType::object_t*&gt;();
3194      using value_type = typename ConstructibleObjectType::value_type;
3195      std::transform(
3196          inner_object-&gt;begin(), inner_object-&gt;end(),
3197          std::inserter(ret, ret.begin()),
3198          [](typename BasicJsonType::object_t::value_type const &amp; p)
3199      {
3200          return value_type(p.first, p.second.template get&lt;typename ConstructibleObjectType::mapped_type&gt;());
3201      });
3202      obj = std::move(ret);
3203  }
3204  template &lt; typename BasicJsonType, typename ArithmeticType,
3205             enable_if_t &lt;
3206                 std::is_arithmetic&lt;ArithmeticType&gt;::value&amp;&amp;
3207                 !std::is_same&lt;ArithmeticType, typename BasicJsonType::number_unsigned_t&gt;::value&amp;&amp;
3208                 !std::is_same&lt;ArithmeticType, typename BasicJsonType::number_integer_t&gt;::value&amp;&amp;
3209                 !std::is_same&lt;ArithmeticType, typename BasicJsonType::number_float_t&gt;::value&amp;&amp;
3210                 !std::is_same&lt;ArithmeticType, typename BasicJsonType::boolean_t&gt;::value,
3211                 int &gt; = 0 &gt;
3212  void from_json(const BasicJsonType&amp; j, ArithmeticType&amp; val)
3213  {
3214      switch (static_cast&lt;value_t&gt;(j))
3215      {
3216          case value_t::number_unsigned:
3217          {
3218              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_unsigned_t*&gt;());
3219              break;
3220          }
3221          case value_t::number_integer:
3222          {
3223              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_integer_t*&gt;());
3224              break;
3225          }
3226          case value_t::number_float:
3227          {
3228              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_float_t*&gt;());
3229              break;
3230          }
3231          case value_t::boolean:
3232          {
3233              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::boolean_t*&gt;());
3234              break;
3235          }
3236          case value_t::null:
3237          case value_t::object:
3238          case value_t::array:
3239          case value_t::string:
3240          case value_t::binary:
3241          case value_t::discarded:
3242          default:
3243              JSON_THROW(type_error::create(302, &quot;type must be number, but is &quot; + std::string(j.type_name()), j));
3244      }
3245  }
3246  template&lt;typename BasicJsonType, typename... Args, std::size_t... Idx&gt;
3247  std::tuple&lt;Args...&gt; from_json_tuple_impl_base(BasicJsonType&amp;&amp; j, index_sequence&lt;Idx...&gt; &amp;bsol;*unused*/)
3248  {
3249      return std::make_tuple(std::forward&lt;BasicJsonType&gt;(j).at(Idx).template get&lt;Args&gt;()...);
3250  }
3251  template &lt; typename BasicJsonType, class A1, class A2 &gt;
3252  std::pair&lt;A1, A2&gt; from_json_tuple_impl(BasicJsonType&amp;&amp; j, identity_tag&lt;std::pair&lt;A1, A2&gt;&gt; &amp;bsol;*unused*/, priority_tag&lt;0&gt; &amp;bsol;*unused*/)
3253  {
3254      return {std::forward&lt;BasicJsonType&gt;(j).at(0).template get&lt;A1&gt;(),
3255              std::forward&lt;BasicJsonType&gt;(j).at(1).template get&lt;A2&gt;()};
3256  }
3257  template&lt;typename BasicJsonType, typename A1, typename A2&gt;
3258  void from_json_tuple_impl(BasicJsonType&amp;&amp; j, std::pair&lt;A1, A2&gt;&amp; p, priority_tag&lt;1&gt; &amp;bsol;*unused*/)
3259  {
3260      p = from_json_tuple_impl(std::forward&lt;BasicJsonType&gt;(j), identity_tag&lt;std::pair&lt;A1, A2&gt;&gt; {}, priority_tag&lt;0&gt; {});
3261  }
3262  template&lt;typename BasicJsonType, typename... Args&gt;
3263  std::tuple&lt;Args...&gt; from_json_tuple_impl(BasicJsonType&amp;&amp; j, identity_tag&lt;std::tuple&lt;Args...&gt;&gt; &amp;bsol;*unused*/, priority_tag&lt;2&gt; &amp;bsol;*unused*/)
3264  {
3265      return from_json_tuple_impl_base&lt;BasicJsonType, Args...&gt;(std::forward&lt;BasicJsonType&gt;(j), index_sequence_for&lt;Args...&gt; {});
3266  }
3267  template&lt;typename BasicJsonType, typename... Args&gt;
3268  void from_json_tuple_impl(BasicJsonType&amp;&amp; j, std::tuple&lt;Args...&gt;&amp; t, priority_tag&lt;3&gt; &amp;bsol;*unused*/)
3269  {
3270      t = from_json_tuple_impl_base&lt;BasicJsonType, Args...&gt;(std::forward&lt;BasicJsonType&gt;(j), index_sequence_for&lt;Args...&gt; {});
3271  }
3272  template&lt;typename BasicJsonType, typename TupleRelated&gt;
3273  auto from_json(BasicJsonType&amp;&amp; j, TupleRelated&amp;&amp; t)
3274  -&gt; decltype(from_json_tuple_impl(std::forward&lt;BasicJsonType&gt;(j), std::forward&lt;TupleRelated&gt;(t), priority_tag&lt;3&gt; {}))
3275  {
3276      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3277      {
3278          JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name()), j));
3279      }
3280      return from_json_tuple_impl(std::forward&lt;BasicJsonType&gt;(j), std::forward&lt;TupleRelated&gt;(t), priority_tag&lt;3&gt; {});
3281  }
3282  template &lt; typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
3283             typename = enable_if_t &lt; !std::is_constructible &lt;
3284                                          typename BasicJsonType::string_t, Key &gt;::value &gt;&gt;
3285  void from_json(const BasicJsonType&amp; j, std::map&lt;Key, Value, Compare, Allocator&gt;&amp; m)
3286  {
3287      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3288      {
3289          JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name()), j));
3290      }
3291      m.clear();
3292      for (const auto&amp; p : j)
3293      {
3294          if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
3295          {
3296              JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(p.type_name()), j));
3297          }
3298          m.emplace(p.at(0).template get&lt;Key&gt;(), p.at(1).template get&lt;Value&gt;());
3299      }
3300  }
3301  template &lt; typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
3302             typename = enable_if_t &lt; !std::is_constructible &lt;
3303                                          typename BasicJsonType::string_t, Key &gt;::value &gt;&gt;
3304  void from_json(const BasicJsonType&amp; j, std::unordered_map&lt;Key, Value, Hash, KeyEqual, Allocator&gt;&amp; m)
3305  {
3306      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3307      {
3308          JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name()), j));
3309      }
3310      m.clear();
3311      for (const auto&amp; p : j)
3312      {
3313          if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
3314          {
3315              JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(p.type_name()), j));
3316          }
3317          m.emplace(p.at(0).template get&lt;Key&gt;(), p.at(1).template get&lt;Value&gt;());
3318      }
3319  }
3320  struct from_json_fn
3321  {
3322      template&lt;typename BasicJsonType, typename T&gt;
3323      auto operator()(const BasicJsonType&amp; j, T&amp;&amp; val) const
3324      noexcept(noexcept(from_json(j, std::forward&lt;T&gt;(val))))
3325      -&gt; decltype(from_json(j, std::forward&lt;T&gt;(val)))
3326      {
3327          return from_json(j, std::forward&lt;T&gt;(val));
3328      }
3329  };
3330  }  
3331  namespace 
3332  {
3333  constexpr const auto&amp; from_json = detail::static_const&lt;detail::from_json_fn&gt;::value; 
3334  } 
3335  } 
3336  #include &lt;algorithm&gt; 
3337  #include &lt;iterator&gt; 
3338  #include &lt;string&gt; 
3339  #include &lt;tuple&gt; 
3340  #include &lt;type_traits&gt; 
3341  #include &lt;utility&gt; 
3342  #include &lt;valarray&gt; 
3343  #include &lt;vector&gt; 
3344  #include &lt;cstddef&gt; 
3345  #include &lt;iterator&gt; 
3346  #include &lt;string&gt; 
3347  #include &lt;tuple&gt; 
3348  #include &lt;utility&gt; 
3349  namespace nlohmann
3350  {
3351  namespace detail
3352  {
3353  template&lt;typename string_type&gt;
3354  void int_to_string( string_type&amp; target, std::size_t value )
3355  {
3356      using std::to_string;
3357      target = to_string(value);
3358  }
3359  template&lt;typename IteratorType&gt; class iteration_proxy_value
3360  {
3361    public:
3362      using difference_type = std::ptrdiff_t;
3363      using value_type = iteration_proxy_value;
3364      using pointer = value_type * ;
3365      using reference = value_type &amp; ;
3366      using iterator_category = std::input_iterator_tag;
3367      using string_type = typename std::remove_cv&lt; typename std::remove_reference&lt;decltype( std::declval&lt;IteratorType&gt;().key() ) &gt;::type &gt;::type;
3368    private:
3369      IteratorType anchor;
3370      std::size_t array_index = 0;
3371      mutable std::size_t array_index_last = 0;
3372      mutable string_type array_index_str = &quot;0&quot;;
3373      const string_type empty_str{};
3374    public:
3375      explicit iteration_proxy_value(IteratorType it) noexcept
3376          : anchor(std::move(it))
3377      {}
3378      iteration_proxy_value&amp; operator*()
3379      {
3380          return *this;
3381      }
3382      iteration_proxy_value&amp; operator++()
3383      {
3384          ++anchor;
3385          ++array_index;
3386          return *this;
3387      }
3388      bool operator==(const iteration_proxy_value&amp; o) const
3389      {
3390          return anchor == o.anchor;
3391      }
3392      bool operator!=(const iteration_proxy_value&amp; o) const
3393      {
3394          return anchor != o.anchor;
3395      }
3396      const string_type&amp; key() const
3397      {
3398          JSON_ASSERT(anchor.m_object != nullptr);
3399          switch (anchor.m_object-&gt;type())
3400          {
3401              case value_t::array:
3402              {
3403                  if (array_index != array_index_last)
3404                  {
3405                      int_to_string( array_index_str, array_index );
3406                      array_index_last = array_index;
3407                  }
3408                  return array_index_str;
3409              }
3410              case value_t::object:
3411                  return anchor.key();
3412              case value_t::null:
3413              case value_t::string:
3414              case value_t::boolean:
3415              case value_t::number_integer:
3416              case value_t::number_unsigned:
3417              case value_t::number_float:
3418              case value_t::binary:
3419              case value_t::discarded:
3420              default:
3421                  return empty_str;
3422          }
3423      }
3424      typename IteratorType::reference value() const
3425      {
3426          return anchor.value();
3427      }
3428  };
3429  template&lt;typename IteratorType&gt; class iteration_proxy
3430  {
3431    private:
3432      typename IteratorType::reference container;
3433    public:
3434      explicit iteration_proxy(typename IteratorType::reference cont) noexcept
3435          : container(cont) {}
3436      iteration_proxy_value&lt;IteratorType&gt; begin() noexcept
3437      {
3438          return iteration_proxy_value&lt;IteratorType&gt;(container.begin());
3439      }
3440      iteration_proxy_value&lt;IteratorType&gt; end() noexcept
3441      {
3442          return iteration_proxy_value&lt;IteratorType&gt;(container.end());
3443      }
3444  };
3445  template&lt;std::size_t N, typename IteratorType, enable_if_t&lt;N == 0, int&gt; = 0&gt;
3446  auto get(const nlohmann::detail::iteration_proxy_value&lt;IteratorType&gt;&amp; i) -&gt; decltype(i.key())
3447  {
3448      return i.key();
3449  }
3450  template&lt;std::size_t N, typename IteratorType, enable_if_t&lt;N == 1, int&gt; = 0&gt;
3451  auto get(const nlohmann::detail::iteration_proxy_value&lt;IteratorType&gt;&amp; i) -&gt; decltype(i.value())
3452  {
3453      return i.value();
3454  }
3455  }  
3456  }  
3457  namespace std
3458  {
3459  #if defined(__clang__)
3460      #pragma clang diagnostic push
3461      #pragma clang diagnostic ignored &quot;-Wmismatched-tags&quot;
3462  #endif
3463  template&lt;typename IteratorType&gt;
3464  class tuple_size&lt;::nlohmann::detail::iteration_proxy_value&lt;IteratorType&gt;&gt;
3465              : public std::integral_constant&lt;std::size_t, 2&gt; {};
3466  template&lt;std::size_t N, typename IteratorType&gt;
3467  class tuple_element&lt;N, ::nlohmann::detail::iteration_proxy_value&lt;IteratorType &gt;&gt;
3468  {
3469    public:
3470      using type = decltype(
3471                       get&lt;N&gt;(std::declval &lt;
3472                              ::nlohmann::detail::iteration_proxy_value&lt;IteratorType &gt;&gt; ()));
3473  };
3474  #if defined(__clang__)
3475      #pragma clang diagnostic pop
3476  #endif
3477  } 
3478  namespace nlohmann
3479  {
3480  namespace detail
3481  {
3482  template&lt;value_t&gt; struct external_constructor;
3483  template&lt;&gt;
3484  struct external_constructor&lt;value_t::boolean&gt;
3485  {
3486      template&lt;typename BasicJsonType&gt;
3487      static void construct(BasicJsonType&amp; j, typename BasicJsonType::boolean_t b) noexcept
3488      {
3489          j.m_value.destroy(j.m_type);
3490          j.m_type = value_t::boolean;
3491          j.m_value = b;
3492          j.assert_invariant();
3493      }
3494  };
3495  template&lt;&gt;
3496  struct external_constructor&lt;value_t::string&gt;
3497  {
3498      template&lt;typename BasicJsonType&gt;
3499      static void construct(BasicJsonType&amp; j, const typename BasicJsonType::string_t&amp; s)
3500      {
3501          j.m_value.destroy(j.m_type);
3502          j.m_type = value_t::string;
3503          j.m_value = s;
3504          j.assert_invariant();
3505      }
3506      template&lt;typename BasicJsonType&gt;
3507      static void construct(BasicJsonType&amp; j, typename BasicJsonType::string_t&amp;&amp; s)
3508      {
3509          j.m_value.destroy(j.m_type);
3510          j.m_type = value_t::string;
3511          j.m_value = std::move(s);
3512          j.assert_invariant();
3513      }
3514      template &lt; typename BasicJsonType, typename CompatibleStringType,
3515                 enable_if_t &lt; !std::is_same&lt;CompatibleStringType, typename BasicJsonType::string_t&gt;::value,
3516                               int &gt; = 0 &gt;
3517      static void construct(BasicJsonType&amp; j, const CompatibleStringType&amp; str)
3518      {
3519          j.m_value.destroy(j.m_type);
3520          j.m_type = value_t::string;
3521          j.m_value.string = j.template create&lt;typename BasicJsonType::string_t&gt;(str);
3522          j.assert_invariant();
3523      }
3524  };
3525  template&lt;&gt;
3526  struct external_constructor&lt;value_t::binary&gt;
3527  {
3528      template&lt;typename BasicJsonType&gt;
3529      static void construct(BasicJsonType&amp; j, const typename BasicJsonType::binary_t&amp; b)
3530      {
3531          j.m_value.destroy(j.m_type);
3532          j.m_type = value_t::binary;
3533          j.m_value = typename BasicJsonType::binary_t(b);
3534          j.assert_invariant();
3535      }
3536      template&lt;typename BasicJsonType&gt;
3537      static void construct(BasicJsonType&amp; j, typename BasicJsonType::binary_t&amp;&amp; b)
3538      {
3539          j.m_value.destroy(j.m_type);
3540          j.m_type = value_t::binary;
3541          j.m_value = typename BasicJsonType::binary_t(std::move(b));
3542          j.assert_invariant();
3543      }
3544  };
3545  template&lt;&gt;
3546  struct external_constructor&lt;value_t::number_float&gt;
3547  {
3548      template&lt;typename BasicJsonType&gt;
3549      static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_float_t val) noexcept
3550      {
3551          j.m_value.destroy(j.m_type);
3552          j.m_type = value_t::number_float;
3553          j.m_value = val;
3554          j.assert_invariant();
3555      }
3556  };
3557  template&lt;&gt;
3558  struct external_constructor&lt;value_t::number_unsigned&gt;
3559  {
3560      template&lt;typename BasicJsonType&gt;
3561      static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_unsigned_t val) noexcept
3562      {
3563          j.m_value.destroy(j.m_type);
3564          j.m_type = value_t::number_unsigned;
3565          j.m_value = val;
3566          j.assert_invariant();
3567      }
3568  };
3569  template&lt;&gt;
3570  struct external_constructor&lt;value_t::number_integer&gt;
3571  {
3572      template&lt;typename BasicJsonType&gt;
3573      static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_integer_t val) noexcept
3574      {
3575          j.m_value.destroy(j.m_type);
3576          j.m_type = value_t::number_integer;
3577          j.m_value = val;
3578          j.assert_invariant();
3579      }
3580  };
3581  template&lt;&gt;
3582  struct external_constructor&lt;value_t::array&gt;
3583  {
3584      template&lt;typename BasicJsonType&gt;
3585      static void construct(BasicJsonType&amp; j, const typename BasicJsonType::array_t&amp; arr)
3586      {
3587          j.m_value.destroy(j.m_type);
3588          j.m_type = value_t::array;
3589          j.m_value = arr;
3590          j.set_parents();
3591          j.assert_invariant();
3592      }
3593      template&lt;typename BasicJsonType&gt;
3594      static void construct(BasicJsonType&amp; j, typename BasicJsonType::array_t&amp;&amp; arr)
3595      {
3596          j.m_value.destroy(j.m_type);
3597          j.m_type = value_t::array;
3598          j.m_value = std::move(arr);
3599          j.set_parents();
3600          j.assert_invariant();
3601      }
3602      template &lt; typename BasicJsonType, typename CompatibleArrayType,
3603                 enable_if_t &lt; !std::is_same&lt;CompatibleArrayType, typename BasicJsonType::array_t&gt;::value,
3604                               int &gt; = 0 &gt;
3605      static void construct(BasicJsonType&amp; j, const CompatibleArrayType&amp; arr)
3606      {
3607          using std::begin;
3608          using std::end;
3609          j.m_value.destroy(j.m_type);
3610          j.m_type = value_t::array;
3611          j.m_value.array = j.template create&lt;typename BasicJsonType::array_t&gt;(begin(arr), end(arr));
3612          j.set_parents();
3613          j.assert_invariant();
3614      }
3615      template&lt;typename BasicJsonType&gt;
3616      static void construct(BasicJsonType&amp; j, const std::vector&lt;bool&gt;&amp; arr)
3617      {
3618          j.m_value.destroy(j.m_type);
3619          j.m_type = value_t::array;
3620          j.m_value = value_t::array;
3621          j.m_value.array-&gt;reserve(arr.size());
3622          for (const bool x : arr)
3623          {
3624              j.m_value.array-&gt;push_back(x);
3625              j.set_parent(j.m_value.array-&gt;back());
3626          }
3627          j.assert_invariant();
3628      }
3629      template&lt;typename BasicJsonType, typename T,
3630               enable_if_t&lt;std::is_convertible&lt;T, BasicJsonType&gt;::value, int&gt; = 0&gt;
3631      static void construct(BasicJsonType&amp; j, const std::valarray&lt;T&gt;&amp; arr)
3632      {
3633          j.m_value.destroy(j.m_type);
3634          j.m_type = value_t::array;
3635          j.m_value = value_t::array;
3636          j.m_value.array-&gt;resize(arr.size());
3637          if (arr.size() &gt; 0)
3638          {
3639              std::copy(std::begin(arr), std::end(arr), j.m_value.array-&gt;begin());
3640          }
3641          j.set_parents();
3642          j.assert_invariant();
3643      }
3644  };
3645  template&lt;&gt;
3646  struct external_constructor&lt;value_t::object&gt;
3647  {
3648      template&lt;typename BasicJsonType&gt;
3649      static void construct(BasicJsonType&amp; j, const typename BasicJsonType::object_t&amp; obj)
3650      {
3651          j.m_value.destroy(j.m_type);
3652          j.m_type = value_t::object;
3653          j.m_value = obj;
3654          j.set_parents();
3655          j.assert_invariant();
3656      }
3657      template&lt;typename BasicJsonType&gt;
3658      static void construct(BasicJsonType&amp; j, typename BasicJsonType::object_t&amp;&amp; obj)
3659      {
3660          j.m_value.destroy(j.m_type);
3661          j.m_type = value_t::object;
3662          j.m_value = std::move(obj);
3663          j.set_parents();
3664          j.assert_invariant();
3665      }
3666      template &lt; typename BasicJsonType, typename CompatibleObjectType,
3667                 enable_if_t &lt; !std::is_same&lt;CompatibleObjectType, typename BasicJsonType::object_t&gt;::value, int &gt; = 0 &gt;
3668      static void construct(BasicJsonType&amp; j, const CompatibleObjectType&amp; obj)
3669      {
3670          using std::begin;
3671          using std::end;
3672          j.m_value.destroy(j.m_type);
3673          j.m_type = value_t::object;
3674          j.m_value.object = j.template create&lt;typename BasicJsonType::object_t&gt;(begin(obj), end(obj));
3675          j.set_parents();
3676          j.assert_invariant();
3677      }
3678  };
3679  template&lt;typename BasicJsonType, typename T,
3680           enable_if_t&lt;std::is_same&lt;T, typename BasicJsonType::boolean_t&gt;::value, int&gt; = 0&gt;
3681  void to_json(BasicJsonType&amp; j, T b) noexcept
3682  {
3683      external_constructor&lt;value_t::boolean&gt;::construct(j, b);
3684  }
3685  template&lt;typename BasicJsonType, typename CompatibleString,
3686           enable_if_t&lt;std::is_constructible&lt;typename BasicJsonType::string_t, CompatibleString&gt;::value, int&gt; = 0&gt;
3687  void to_json(BasicJsonType&amp; j, const CompatibleString&amp; s)
3688  {
3689      external_constructor&lt;value_t::string&gt;::construct(j, s);
3690  }
3691  template&lt;typename BasicJsonType&gt;
3692  void to_json(BasicJsonType&amp; j, typename BasicJsonType::string_t&amp;&amp; s)
3693  {
3694      external_constructor&lt;value_t::string&gt;::construct(j, std::move(s));
3695  }
3696  template&lt;typename BasicJsonType, typename FloatType,
3697           enable_if_t&lt;std::is_floating_point&lt;FloatType&gt;::value, int&gt; = 0&gt;
3698  void to_json(BasicJsonType&amp; j, FloatType val) noexcept
3699  {
3700      external_constructor&lt;value_t::number_float&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_float_t&gt;(val));
3701  }
3702  template&lt;typename BasicJsonType, typename CompatibleNumberUnsignedType,
3703           enable_if_t&lt;is_compatible_integer_type&lt;typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType&gt;::value, int&gt; = 0&gt;
3704  void to_json(BasicJsonType&amp; j, CompatibleNumberUnsignedType val) noexcept
3705  {
3706      external_constructor&lt;value_t::number_unsigned&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_unsigned_t&gt;(val));
3707  }
3708  template&lt;typename BasicJsonType, typename CompatibleNumberIntegerType,
3709           enable_if_t&lt;is_compatible_integer_type&lt;typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType&gt;::value, int&gt; = 0&gt;
3710  void to_json(BasicJsonType&amp; j, CompatibleNumberIntegerType val) noexcept
3711  {
3712      external_constructor&lt;value_t::number_integer&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_integer_t&gt;(val));
3713  }
3714  template&lt;typename BasicJsonType, typename EnumType,
3715           enable_if_t&lt;std::is_enum&lt;EnumType&gt;::value, int&gt; = 0&gt;
3716  void to_json(BasicJsonType&amp; j, EnumType e) noexcept
3717  {
3718      using underlying_type = typename std::underlying_type&lt;EnumType&gt;::type;
3719      external_constructor&lt;value_t::number_integer&gt;::construct(j, static_cast&lt;underlying_type&gt;(e));
3720  }
3721  template&lt;typename BasicJsonType&gt;
3722  void to_json(BasicJsonType&amp; j, const std::vector&lt;bool&gt;&amp; e)
3723  {
3724      external_constructor&lt;value_t::array&gt;::construct(j, e);
3725  }
3726  template &lt; typename BasicJsonType, typename CompatibleArrayType,
3727             enable_if_t &lt; is_compatible_array_type&lt;BasicJsonType,
3728                           CompatibleArrayType&gt;::value&amp;&amp;
3729                           !is_compatible_object_type&lt;BasicJsonType, CompatibleArrayType&gt;::value&amp;&amp;
3730                           !is_compatible_string_type&lt;BasicJsonType, CompatibleArrayType&gt;::value&amp;&amp;
3731                           !std::is_same&lt;typename BasicJsonType::binary_t, CompatibleArrayType&gt;::value&amp;&amp;
3732                           !is_basic_json&lt;CompatibleArrayType&gt;::value,
3733                           int &gt; = 0 &gt;
3734  void to_json(BasicJsonType&amp; j, const CompatibleArrayType&amp; arr)
3735  {
3736      external_constructor&lt;value_t::array&gt;::construct(j, arr);
3737  }
3738  template&lt;typename BasicJsonType&gt;
3739  void to_json(BasicJsonType&amp; j, const typename BasicJsonType::binary_t&amp; bin)
3740  {
3741      external_constructor&lt;value_t::binary&gt;::construct(j, bin);
3742  }
3743  template&lt;typename BasicJsonType, typename T,
3744           enable_if_t&lt;std::is_convertible&lt;T, BasicJsonType&gt;::value, int&gt; = 0&gt;
3745  void to_json(BasicJsonType&amp; j, const std::valarray&lt;T&gt;&amp; arr)
3746  {
3747      external_constructor&lt;value_t::array&gt;::construct(j, std::move(arr));
3748  }
3749  template&lt;typename BasicJsonType&gt;
3750  void to_json(BasicJsonType&amp; j, typename BasicJsonType::array_t&amp;&amp; arr)
3751  {
3752      external_constructor&lt;value_t::array&gt;::construct(j, std::move(arr));
3753  }
3754  template &lt; typename BasicJsonType, typename CompatibleObjectType,
3755             enable_if_t &lt; is_compatible_object_type&lt;BasicJsonType, CompatibleObjectType&gt;::value&amp;&amp; !is_basic_json&lt;CompatibleObjectType&gt;::value, int &gt; = 0 &gt;
3756  void to_json(BasicJsonType&amp; j, const CompatibleObjectType&amp; obj)
3757  {
3758      external_constructor&lt;value_t::object&gt;::construct(j, obj);
3759  }
3760  template&lt;typename BasicJsonType&gt;
3761  void to_json(BasicJsonType&amp; j, typename BasicJsonType::object_t&amp;&amp; obj)
3762  {
3763      external_constructor&lt;value_t::object&gt;::construct(j, std::move(obj));
3764  }
3765  template &lt;
3766      typename BasicJsonType, typename T, std::size_t N,
3767      enable_if_t &lt; !std::is_constructible&lt;typename BasicJsonType::string_t,
3768                    const T(&amp;)[N]&gt;::value, 
3769                    int &gt; = 0 &gt;
3770  void to_json(BasicJsonType&amp; j, const T(&amp;arr)[N]) 
3771  {
3772      external_constructor&lt;value_t::array&gt;::construct(j, arr);
3773  }
3774  template &lt; typename BasicJsonType, typename T1, typename T2, enable_if_t &lt; std::is_constructible&lt;BasicJsonType, T1&gt;::value&amp;&amp; std::is_constructible&lt;BasicJsonType, T2&gt;::value, int &gt; = 0 &gt;
3775  void to_json(BasicJsonType&amp; j, const std::pair&lt;T1, T2&gt;&amp; p)
3776  {
3777      j = { p.first, p.second };
3778  }
3779  template&lt;typename BasicJsonType, typename T,
3780           enable_if_t&lt;std::is_same&lt;T, iteration_proxy_value&lt;typename BasicJsonType::iterator&gt;&gt;::value, int&gt; = 0&gt;
3781  void to_json(BasicJsonType&amp; j, const T&amp; b)
3782  {
3783      j = { {b.key(), b.value()} };
3784  }
3785  template&lt;typename BasicJsonType, typename Tuple, std::size_t... Idx&gt;
3786  void to_json_tuple_impl(BasicJsonType&amp; j, const Tuple&amp; t, index_sequence&lt;Idx...&gt; &amp;bsol;*unused*/)
3787  {
3788      j = { std::get&lt;Idx&gt;(t)... };
3789  }
3790  template&lt;typename BasicJsonType, typename T, enable_if_t&lt;is_constructible_tuple&lt;BasicJsonType, T&gt;::value, int &gt; = 0&gt;
3791  void to_json(BasicJsonType&amp; j, const T&amp; t)
3792  {
3793      to_json_tuple_impl(j, t, make_index_sequence&lt;std::tuple_size&lt;T&gt;::value&gt; {});
3794  }
3795  struct to_json_fn
3796  {
3797      template&lt;typename BasicJsonType, typename T&gt;
3798      auto operator()(BasicJsonType&amp; j, T&amp;&amp; val) const noexcept(noexcept(to_json(j, std::forward&lt;T&gt;(val))))
3799      -&gt; decltype(to_json(j, std::forward&lt;T&gt;(val)), void())
3800      {
3801          return to_json(j, std::forward&lt;T&gt;(val));
3802      }
3803  };
3804  }  
3805  namespace 
3806  {
3807  constexpr const auto&amp; to_json = detail::static_const&lt;detail::to_json_fn&gt;::value; 
3808  } 
3809  } 
3810  namespace nlohmann
3811  {
3812  template&lt;typename ValueType, typename&gt;
3813  struct adl_serializer
3814  {
3815      template&lt;typename BasicJsonType, typename TargetType = ValueType&gt;
3816      static auto from_json(BasicJsonType &amp;&amp; j, TargetType&amp; val) noexcept(
3817          noexcept(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val)))
3818      -&gt; decltype(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val), void())
3819      {
3820          ::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val);
3821      }
3822      template&lt;typename BasicJsonType, typename TargetType = ValueType&gt;
3823      static auto from_json(BasicJsonType &amp;&amp; j) noexcept(
3824      noexcept(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), detail::identity_tag&lt;TargetType&gt; {})))
3825      -&gt; decltype(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), detail::identity_tag&lt;TargetType&gt; {}))
3826      {
3827          return ::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), detail::identity_tag&lt;TargetType&gt; {});
3828      }
3829      template&lt;typename BasicJsonType, typename TargetType = ValueType&gt;
3830      static auto to_json(BasicJsonType&amp; j, TargetType &amp;&amp; val) noexcept(
3831          noexcept(::nlohmann::to_json(j, std::forward&lt;TargetType&gt;(val))))
3832      -&gt; decltype(::nlohmann::to_json(j, std::forward&lt;TargetType&gt;(val)), void())
3833      {
3834          ::nlohmann::to_json(j, std::forward&lt;TargetType&gt;(val));
3835      }
3836  };
3837  }  
3838  #include &lt;cstdint&gt; 
3839  #include &lt;tuple&gt; 
3840  #include &lt;utility&gt; 
3841  namespace nlohmann
3842  {
3843  template&lt;typename BinaryType&gt;
3844  class byte_container_with_subtype : public BinaryType
3845  {
3846    public:
3847      using container_type = BinaryType;
3848      using subtype_type = std::uint64_t;
3849      byte_container_with_subtype() noexcept(noexcept(container_type()))
3850          : container_type()
3851      {}
3852      byte_container_with_subtype(const container_type&amp; b) noexcept(noexcept(container_type(b)))
3853          : container_type(b)
3854      {}
3855      byte_container_with_subtype(container_type&amp;&amp; b) noexcept(noexcept(container_type(std::move(b))))
3856          : container_type(std::move(b))
3857      {}
3858      byte_container_with_subtype(const container_type&amp; b, subtype_type subtype_) noexcept(noexcept(container_type(b)))
3859          : container_type(b)
3860          , m_subtype(subtype_)
3861          , m_has_subtype(true)
3862      {}
3863      byte_container_with_subtype(container_type&amp;&amp; b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))
3864          : container_type(std::move(b))
3865          , m_subtype(subtype_)
3866          , m_has_subtype(true)
3867      {}
3868      bool operator==(const byte_container_with_subtype&amp; rhs) const
3869      {
3870          return std::tie(static_cast&lt;const BinaryType&amp;&gt;(*this), m_subtype, m_has_subtype) ==
3871                 std::tie(static_cast&lt;const BinaryType&amp;&gt;(rhs), rhs.m_subtype, rhs.m_has_subtype);
3872      }
3873      bool operator!=(const byte_container_with_subtype&amp; rhs) const
3874      {
3875          return !(rhs == *this);
3876      }
3877      void set_subtype(subtype_type subtype_) noexcept
3878      {
3879          m_subtype = subtype_;
3880          m_has_subtype = true;
3881      }
3882      constexpr subtype_type subtype() const noexcept
3883      {
3884          return m_has_subtype ? m_subtype : subtype_type(-1);
3885      }
3886      constexpr bool has_subtype() const noexcept
3887      {
3888          return m_has_subtype;
3889      }
3890      void clear_subtype() noexcept
3891      {
3892          m_subtype = 0;
3893          m_has_subtype = false;
3894      }
3895    private:
3896      subtype_type m_subtype = 0;
3897      bool m_has_subtype = false;
3898  };
3899  }  
3900  #include &lt;cstdint&gt; 
3901  #include &lt;cstddef&gt; 
3902  #include &lt;functional&gt; 
3903  namespace nlohmann
3904  {
3905  namespace detail
3906  {
3907  inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
3908  {
3909      seed ^= h + 0x9e3779b9 + (seed &lt;&lt; 6U) + (seed &gt;&gt; 2U);
3910      return seed;
3911  }
3912  template&lt;typename BasicJsonType&gt;
3913  std::size_t hash(const BasicJsonType&amp; j)
3914  {
3915      using string_t = typename BasicJsonType::string_t;
3916      using number_integer_t = typename BasicJsonType::number_integer_t;
3917      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
3918      using number_float_t = typename BasicJsonType::number_float_t;
3919      const auto type = static_cast&lt;std::size_t&gt;(j.type());
3920      switch (j.type())
3921      {
3922          case BasicJsonType::value_t::null:
3923          case BasicJsonType::value_t::discarded:
3924          {
3925              return combine(type, 0);
3926          }
3927          case BasicJsonType::value_t::object:
3928          {
3929              auto seed = combine(type, j.size());
3930              for (const auto&amp; element : j.items())
3931              {
3932                  const auto h = std::hash&lt;string_t&gt; {}(element.key());
3933                  seed = combine(seed, h);
3934                  seed = combine(seed, hash(element.value()));
3935              }
3936              return seed;
3937          }
3938          case BasicJsonType::value_t::array:
3939          {
3940              auto seed = combine(type, j.size());
3941              for (const auto&amp; element : j)
3942              {
3943                  seed = combine(seed, hash(element));
3944              }
3945              return seed;
3946          }
3947          case BasicJsonType::value_t::string:
3948          {
3949              const auto h = std::hash&lt;string_t&gt; {}(j.template get_ref&lt;const string_t&amp;&gt;());
3950              return combine(type, h);
3951          }
3952          case BasicJsonType::value_t::boolean:
3953          {
3954              const auto h = std::hash&lt;bool&gt; {}(j.template get&lt;bool&gt;());
3955              return combine(type, h);
3956          }
3957          case BasicJsonType::value_t::number_integer:
3958          {
3959              const auto h = std::hash&lt;number_integer_t&gt; {}(j.template get&lt;number_integer_t&gt;());
3960              return combine(type, h);
3961          }
3962          case BasicJsonType::value_t::number_unsigned:
3963          {
3964              const auto h = std::hash&lt;number_unsigned_t&gt; {}(j.template get&lt;number_unsigned_t&gt;());
3965              return combine(type, h);
3966          }
3967          case BasicJsonType::value_t::number_float:
3968          {
3969              const auto h = std::hash&lt;number_float_t&gt; {}(j.template get&lt;number_float_t&gt;());
3970              return combine(type, h);
3971          }
3972          case BasicJsonType::value_t::binary:
3973          {
3974              auto seed = combine(type, j.get_binary().size());
3975              const auto h = std::hash&lt;bool&gt; {}(j.get_binary().has_subtype());
3976              seed = combine(seed, h);
3977              seed = combine(seed, static_cast&lt;std::size_t&gt;(j.get_binary().subtype()));
3978              for (const auto byte : j.get_binary())
3979              {
3980                  seed = combine(seed, std::hash&lt;std::uint8_t&gt; {}(byte));
3981              }
3982              return seed;
3983          }
3984          default:                   
3985              JSON_ASSERT(false); 
3986              return 0;              
3987      }
3988  }
3989  }  
3990  }  
3991  #include &lt;algorithm&gt; 
3992  #include &lt;array&gt; 
3993  #include &lt;cmath&gt; 
3994  #include &lt;cstddef&gt; 
3995  #include &lt;cstdint&gt; 
3996  #include &lt;cstdio&gt; 
3997  #include &lt;cstring&gt; 
3998  #include &lt;iterator&gt; 
3999  #include &lt;limits&gt; 
4000  #include &lt;string&gt; 
4001  #include &lt;utility&gt; 
4002  #include &lt;vector&gt; 
4003  #include &lt;array&gt; 
4004  #include &lt;cstddef&gt; 
4005  #include &lt;cstring&gt; 
4006  #include &lt;iterator&gt; 
4007  #include &lt;memory&gt; 
4008  #include &lt;numeric&gt; 
4009  #include &lt;string&gt; 
4010  #include &lt;type_traits&gt; 
4011  #include &lt;utility&gt; 
4012  #ifndef JSON_NO_IO
4013      #include &lt;cstdio&gt;   
4014      #include &lt;istream&gt;  
4015  #endif                  
4016  namespace nlohmann
4017  {
4018  namespace detail
4019  {
4020  enum class input_format_t { json, cbor, msgpack, ubjson, bson };
4021  #ifndef JSON_NO_IO
4022  class file_input_adapter
4023  {
4024    public:
4025      using char_type = char;
4026      JSON_HEDLEY_NON_NULL(2)
4027      explicit file_input_adapter(std::FILE* f) noexcept
4028          : m_file(f)
4029      {}
4030      file_input_adapter(const file_input_adapter&amp;) = delete;
4031      file_input_adapter(file_input_adapter&amp;&amp;) noexcept = default;
4032      file_input_adapter&amp; operator=(const file_input_adapter&amp;) = delete;
4033      file_input_adapter&amp; operator=(file_input_adapter&amp;&amp;) = delete;
4034      ~file_input_adapter() = default;
4035      std::char_traits&lt;char&gt;::int_type get_character() noexcept
4036      {
4037          return std::fgetc(m_file);
4038      }
4039    private:
4040      std::FILE* m_file;
4041  };
4042  class input_stream_adapter
4043  {
4044    public:
4045      using char_type = char;
4046      ~input_stream_adapter()
4047      {
4048          if (is != nullptr)
4049          {
4050              is-&gt;clear(is-&gt;rdstate() &amp; std::ios::eofbit);
4051          }
4052      }
4053      explicit input_stream_adapter(std::istream&amp; i)
4054          : is(&amp;i), sb(i.rdbuf())
4055      {}
4056      input_stream_adapter(const input_stream_adapter&amp;) = delete;
4057      input_stream_adapter&amp; operator=(input_stream_adapter&amp;) = delete;
4058      input_stream_adapter&amp; operator=(input_stream_adapter&amp;&amp;) = delete;
4059      input_stream_adapter(input_stream_adapter&amp;&amp; rhs) noexcept
4060          : is(rhs.is), sb(rhs.sb)
4061      {
4062          rhs.is = nullptr;
4063          rhs.sb = nullptr;
4064      }
4065      std::char_traits&lt;char&gt;::int_type get_character()
4066      {
4067          auto res = sb-&gt;sbumpc();
4068          if (JSON_HEDLEY_UNLIKELY(res == std::char_traits&lt;char&gt;::eof()))
4069          {
4070              is-&gt;clear(is-&gt;rdstate() | std::ios::eofbit);
4071          }
4072          return res;
4073      }
4074    private:
4075      std::istream* is = nullptr;
4076      std::streambuf* sb = nullptr;
4077  };
4078  #endif  
4079  template&lt;typename IteratorType&gt;
4080  class iterator_input_adapter
4081  {
4082    public:
4083      using char_type = typename std::iterator_traits&lt;IteratorType&gt;::value_type;
4084      iterator_input_adapter(IteratorType first, IteratorType last)
4085          : current(std::move(first)), end(std::move(last))
4086      {}
4087      typename std::char_traits&lt;char_type&gt;::int_type get_character()
4088      {
4089          if (JSON_HEDLEY_LIKELY(current != end))
4090          {
4091              auto result = std::char_traits&lt;char_type&gt;::to_int_type(*current);
4092              std::advance(current, 1);
4093              return result;
4094          }
4095          return std::char_traits&lt;char_type&gt;::eof();
4096      }
4097    private:
4098      IteratorType current;
4099      IteratorType end;
4100      template&lt;typename BaseInputAdapter, size_t T&gt;
4101      friend struct wide_string_input_helper;
4102      bool empty() const
4103      {
4104          return current == end;
4105      }
4106  };
4107  template&lt;typename BaseInputAdapter, size_t T&gt;
4108  struct wide_string_input_helper;
4109  template&lt;typename BaseInputAdapter&gt;
4110  struct wide_string_input_helper&lt;BaseInputAdapter, 4&gt;
4111  {
4112      static void fill_buffer(BaseInputAdapter&amp; input,
4113                              std::array&lt;std::char_traits&lt;char&gt;::int_type, 4&gt;&amp; utf8_bytes,
4114                              size_t&amp; utf8_bytes_index,
4115                              size_t&amp; utf8_bytes_filled)
4116      {
4117          utf8_bytes_index = 0;
4118          if (JSON_HEDLEY_UNLIKELY(input.empty()))
4119          {
4120              utf8_bytes[0] = std::char_traits&lt;char&gt;::eof();
4121              utf8_bytes_filled = 1;
4122          }
4123          else
4124          {
4125              const auto wc = input.get_character();
4126              if (wc &lt; 0x80)
4127              {
4128                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(wc);
4129                  utf8_bytes_filled = 1;
4130              }
4131              else if (wc &lt;= 0x7FF)
4132              {
4133                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xC0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u) &amp; 0x1Fu));
4134                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4135                  utf8_bytes_filled = 2;
4136              }
4137              else if (wc &lt;= 0xFFFF)
4138              {
4139                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xE0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 12u) &amp; 0x0Fu));
4140                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u) &amp; 0x3Fu));
4141                  utf8_bytes[2] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4142                  utf8_bytes_filled = 3;
4143              }
4144              else if (wc &lt;= 0x10FFFF)
4145              {
4146                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xF0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 18u) &amp; 0x07u));
4147                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 12u) &amp; 0x3Fu));
4148                  utf8_bytes[2] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u) &amp; 0x3Fu));
4149                  utf8_bytes[3] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4150                  utf8_bytes_filled = 4;
4151              }
4152              else
4153              {
4154                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(wc);
4155                  utf8_bytes_filled = 1;
4156              }
4157          }
4158      }
4159  };
4160  template&lt;typename BaseInputAdapter&gt;
4161  struct wide_string_input_helper&lt;BaseInputAdapter, 2&gt;
4162  {
4163      static void fill_buffer(BaseInputAdapter&amp; input,
4164                              std::array&lt;std::char_traits&lt;char&gt;::int_type, 4&gt;&amp; utf8_bytes,
4165                              size_t&amp; utf8_bytes_index,
4166                              size_t&amp; utf8_bytes_filled)
4167      {
4168          utf8_bytes_index = 0;
4169          if (JSON_HEDLEY_UNLIKELY(input.empty()))
4170          {
4171              utf8_bytes[0] = std::char_traits&lt;char&gt;::eof();
4172              utf8_bytes_filled = 1;
4173          }
4174          else
4175          {
4176              const auto wc = input.get_character();
4177              if (wc &lt; 0x80)
4178              {
4179                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(wc);
4180                  utf8_bytes_filled = 1;
4181              }
4182              else if (wc &lt;= 0x7FF)
4183              {
4184                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xC0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u)));
4185                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4186                  utf8_bytes_filled = 2;
4187              }
4188              else if (0xD800 &gt; wc || wc &gt;= 0xE000)
4189              {
4190                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xE0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 12u)));
4191                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u) &amp; 0x3Fu));
4192                  utf8_bytes[2] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4193                  utf8_bytes_filled = 3;
4194              }
4195              else
4196              {
4197                  if (JSON_HEDLEY_UNLIKELY(!input.empty()))
4198                  {
4199                      const auto wc2 = static_cast&lt;unsigned int&gt;(input.get_character());
4200                      const auto charcode = 0x10000u + (((static_cast&lt;unsigned int&gt;(wc) &amp; 0x3FFu) &lt;&lt; 10u) | (wc2 &amp; 0x3FFu));
4201                      utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xF0u | (charcode &gt;&gt; 18u));
4202                      utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((charcode &gt;&gt; 12u) &amp; 0x3Fu));
4203                      utf8_bytes[2] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((charcode &gt;&gt; 6u) &amp; 0x3Fu));
4204                      utf8_bytes[3] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (charcode &amp; 0x3Fu));
4205                      utf8_bytes_filled = 4;
4206                  }
4207                  else
4208                  {
4209                      utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(wc);
4210                      utf8_bytes_filled = 1;
4211                  }
4212              }
4213          }
4214      }
4215  };
4216  template&lt;typename BaseInputAdapter, typename WideCharType&gt;
4217  class wide_string_input_adapter
4218  {
4219    public:
4220      using char_type = char;
4221      wide_string_input_adapter(BaseInputAdapter base)
4222          : base_adapter(base) {}
4223      typename std::char_traits&lt;char&gt;::int_type get_character() noexcept
4224      {
4225          if (utf8_bytes_index == utf8_bytes_filled)
4226          {
4227              fill_buffer&lt;sizeof(WideCharType)&gt;();
4228              JSON_ASSERT(utf8_bytes_filled &gt; 0);
4229              JSON_ASSERT(utf8_bytes_index == 0);
4230          }
4231          JSON_ASSERT(utf8_bytes_filled &gt; 0);
4232          JSON_ASSERT(utf8_bytes_index &lt; utf8_bytes_filled);
4233          return utf8_bytes[utf8_bytes_index++];
4234      }
4235    private:
4236      BaseInputAdapter base_adapter;
4237      template&lt;size_t T&gt;
4238      void fill_buffer()
4239      {
4240          wide_string_input_helper&lt;BaseInputAdapter, T&gt;::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
4241      }
4242      std::array&lt;std::char_traits&lt;char&gt;::int_type, 4&gt; utf8_bytes = {{0, 0, 0, 0}};
4243      std::size_t utf8_bytes_index = 0;
4244      std::size_t utf8_bytes_filled = 0;
4245  };
4246  template&lt;typename IteratorType, typename Enable = void&gt;
4247  struct iterator_input_adapter_factory
4248  {
4249      using iterator_type = IteratorType;
4250      using char_type = typename std::iterator_traits&lt;iterator_type&gt;::value_type;
<span onclick='openModal()' class='match'>4251      using adapter_type = iterator_input_adapter&lt;iterator_type&gt;;
4252      static adapter_type create(IteratorType first, IteratorType last)
4253      {
4254          return adapter_type(std::move(first), std::move(last));
4255      }
4256  };
4257  template&lt;typename T&gt;
4258  struct is_iterator_of_multibyte
4259  {
4260      using value_type = typename std::iterator_traits&lt;T&gt;::value_type;
4261      enum
4262      {
4263          value = sizeof(value_type) &gt; 1
4264      };
4265  };
4266  template&lt;typename IteratorType&gt;
4267  struct iterator_input_adapter_factory&lt;IteratorType, enable_if_t&lt;is_iterator_of_multibyte&lt;IteratorType&gt;::value&gt;&gt;
4268  {
4269      using iterator_type = IteratorType;
4270      using char_type = typename std::iterator_traits&lt;iterator_type&gt;::value_type;
4271      using base_adapter_type = iterator_input_adapter&lt;iterator_type&gt;;
4272      using adapter_type = wide_string_input_adapter&lt;base_adapter_type, char_type&gt;;
4273      static adapter_type create(IteratorType first, IteratorType last)
4274      {
4275          return adapter_type(base_adapter_type(std::move(first), std::move(last)));
4276      }
4277  };
4278  template&lt;typename IteratorType&gt;
4279  typename iterator_input_adapter_factory&lt;IteratorType&gt;::adapter_type input_adapter(IteratorType first, IteratorType last)
4280  {
4281      using factory_type = iterator_input_adapter_factory&lt;IteratorType&gt;;
4282      return factory_type::create(first, last);
4283  }
4284  namespace container_input_adapter_factory_impl
4285  {
4286  using std::begin;
4287  using std::end;
4288  template&lt;typename ContainerType, typename Enable = void&gt;
4289  struct container_input_adapter_factory {};
4290  template&lt;typename ContainerType&gt;
4291  struct container_input_adapter_factory&lt; ContainerType,
4292         void_t&lt;decltype(begin(std::declval&lt;ContainerType&gt;()), end(std::declval&lt;ContainerType&gt;()))&gt;&gt;
4293         {
4294             using adapter_type = decltype(input_adapter(begin(std::declval&lt;ContainerType&gt;()), end(std::declval&lt;ContainerType&gt;())));
4295             static adapter_type create(const ContainerType&amp; container)
4296  {
4297      return input_adapter(begin(container), end(container));
4298  }
4299         };
4300  } 
4301  template&lt;typename ContainerType&gt;
4302  typename container_input_adapter_factory_impl::container_input_adapter_factory&lt;ContainerType&gt;::adapter_type input_adapter(const ContainerType&amp; container)
4303  {
4304      return container_input_adapter_factory_impl::container_input_adapter_factory&lt;ContainerType&gt;::create(container);
4305  }
4306  #ifndef JSON_NO_IO
4307  inline file_input_adapter input_adapter(std::FILE* file)
4308  {
4309      return file_input_adapter(file);
4310  }
4311  inline input_stream_adapter input_adapter(std::istream&amp; stream)
4312  {
4313      return input_stream_adapter(stream);
4314  }
4315  inline input_stream_adapter input_adapter(std::istream&amp;&amp; stream)
4316  {
4317      return input_stream_adapter(stream);
4318  }
4319  #endif  
4320  using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval&lt;const char*&gt;(), std::declval&lt;const char*&gt;()));
4321  template &lt; typename CharT,
4322             typename std::enable_if &lt;
4323                 std::is_pointer&lt;CharT&gt;::value&amp;&amp;
4324                 !std::is_array&lt;CharT&gt;::value&amp;&amp;
4325                 std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value&amp;&amp;
4326                 sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
4327                 int &gt;::type = 0 &gt;
4328  contiguous_bytes_input_adapter input_adapter(CharT b)
4329  {
4330      auto length = std::strlen(reinterpret_cast&lt;const char*&gt;(b));
4331      const auto* ptr = reinterpret_cast&lt;const char*&gt;(b);
4332      return input_adapter(ptr, ptr + length);
4333  }
4334  template&lt;typename T, std::size_t N&gt;
4335  auto input_adapter(T (&amp;array)[N]) -&gt; decltype(input_adapter(array, array + N)) 
4336  {
4337      return input_adapter(array, array + N);
4338  }
4339  class span_input_adapter
4340  {
4341    public:
4342      template &lt; typename CharT,
4343                 typename std::enable_if &lt;
4344                     std::is_pointer&lt;CharT&gt;::value&amp;&amp;
4345                     std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value&amp;&amp;
4346                     sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
4347                     int &gt;::type = 0 &gt;
4348      span_input_adapter(CharT b, std::size_t l)
4349          : ia(reinterpret_cast&lt;const char*&gt;(b), reinterpret_cast&lt;const char*&gt;(b) + l) {}
4350      template&lt;class IteratorType,
4351               typename std::enable_if&lt;
4352                   std::is_same&lt;typename iterator_traits&lt;IteratorType&gt;::iterator_category, std::random_access_iterator_tag&gt;::value,
4353                   int&gt;::type = 0&gt;
4354      span_input_adapter(IteratorType first, IteratorType last)
4355          : ia(input_adapter(first, last)) {}
4356      contiguous_bytes_input_adapter&amp;&amp; get()
4357      {
4358          return std::move(ia); 
4359      }
4360    private:
4361      contiguous_bytes_input_adapter ia;
4362  };
4363  }  
4364  }  
</span>4365  #include &lt;cstddef&gt;
4366  #include &lt;string&gt; 
4367  #include &lt;utility&gt; 
4368  #include &lt;vector&gt; 
4369  namespace nlohmann
4370  {
4371  template&lt;typename BasicJsonType&gt;
4372  struct json_sax
4373  {
4374      using number_integer_t = typename BasicJsonType::number_integer_t;
4375      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4376      using number_float_t = typename BasicJsonType::number_float_t;
4377      using string_t = typename BasicJsonType::string_t;
4378      using binary_t = typename BasicJsonType::binary_t;
4379      virtual bool null() = 0;
4380      virtual bool boolean(bool val) = 0;
4381      virtual bool number_integer(number_integer_t val) = 0;
4382      virtual bool number_unsigned(number_unsigned_t val) = 0;
4383      virtual bool number_float(number_float_t val, const string_t&amp; s) = 0;
4384      virtual bool string(string_t&amp; val) = 0;
4385      virtual bool binary(binary_t&amp; val) = 0;
4386      virtual bool start_object(std::size_t elements) = 0;
4387      virtual bool key(string_t&amp; val) = 0;
4388      virtual bool end_object() = 0;
4389      virtual bool start_array(std::size_t elements) = 0;
4390      virtual bool end_array() = 0;
4391      virtual bool parse_error(std::size_t position,
4392                               const std::string&amp; last_token,
4393                               const detail::exception&amp; ex) = 0;
4394      json_sax() = default;
4395      json_sax(const json_sax&amp;) = default;
4396      json_sax(json_sax&amp;&amp;) noexcept = default;
4397      json_sax&amp; operator=(const json_sax&amp;) = default;
4398      json_sax&amp; operator=(json_sax&amp;&amp;) noexcept = default;
4399      virtual ~json_sax() = default;
4400  };
4401  namespace detail
4402  {
4403  template&lt;typename BasicJsonType&gt;
4404  class json_sax_dom_parser
4405  {
4406    public:
4407      using number_integer_t = typename BasicJsonType::number_integer_t;
4408      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4409      using number_float_t = typename BasicJsonType::number_float_t;
4410      using string_t = typename BasicJsonType::string_t;
4411      using binary_t = typename BasicJsonType::binary_t;
4412      explicit json_sax_dom_parser(BasicJsonType&amp; r, const bool allow_exceptions_ = true)
4413          : root(r), allow_exceptions(allow_exceptions_)
4414      {}
4415      json_sax_dom_parser(const json_sax_dom_parser&amp;) = delete;
4416      json_sax_dom_parser(json_sax_dom_parser&amp;&amp;) = default; 
4417      json_sax_dom_parser&amp; operator=(const json_sax_dom_parser&amp;) = delete;
4418      json_sax_dom_parser&amp; operator=(json_sax_dom_parser&amp;&amp;) = default; 
4419      ~json_sax_dom_parser() = default;
4420      bool null()
4421      {
4422          handle_value(nullptr);
4423          return true;
4424      }
4425      bool boolean(bool val)
4426      {
4427          handle_value(val);
4428          return true;
4429      }
4430      bool number_integer(number_integer_t val)
4431      {
4432          handle_value(val);
4433          return true;
4434      }
4435      bool number_unsigned(number_unsigned_t val)
4436      {
4437          handle_value(val);
4438          return true;
4439      }
4440      bool number_float(number_float_t val, const string_t&amp; &amp;bsol;*unused*/)
4441      {
4442          handle_value(val);
4443          return true;
4444      }
4445      bool string(string_t&amp; val)
4446      {
4447          handle_value(val);
4448          return true;
4449      }
4450      bool binary(binary_t&amp; val)
4451      {
4452          handle_value(std::move(val));
4453          return true;
4454      }
4455      bool start_object(std::size_t len)
4456      {
4457          ref_stack.push_back(handle_value(BasicJsonType::value_t::object));
4458          if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) &amp;&amp; len &gt; ref_stack.back()-&gt;max_size()))
4459          {
4460              JSON_THROW(out_of_range::create(408, &quot;excessive object size: &quot; + std::to_string(len), *ref_stack.back()));
4461          }
4462          return true;
4463      }
4464      bool key(string_t&amp; val)
4465      {
4466          object_element = &amp;(ref_stack.back()-&gt;m_value.object-&gt;operator[](val));
4467          return true;
4468      }
4469      bool end_object()
4470      {
4471          ref_stack.back()-&gt;set_parents();
4472          ref_stack.pop_back();
4473          return true;
4474      }
4475      bool start_array(std::size_t len)
4476      {
4477          ref_stack.push_back(handle_value(BasicJsonType::value_t::array));
4478          if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) &amp;&amp; len &gt; ref_stack.back()-&gt;max_size()))
4479          {
4480              JSON_THROW(out_of_range::create(408, &quot;excessive array size: &quot; + std::to_string(len), *ref_stack.back()));
4481          }
4482          return true;
4483      }
4484      bool end_array()
4485      {
4486          ref_stack.back()-&gt;set_parents();
4487          ref_stack.pop_back();
4488          return true;
4489      }
4490      template&lt;class Exception&gt;
4491      bool parse_error(std::size_t &amp;bsol;*unused*/, const std::string&amp; &amp;bsol;*unused*/,
4492                       const Exception&amp; ex)
4493      {
4494          errored = true;
4495          static_cast&lt;void&gt;(ex);
4496          if (allow_exceptions)
4497          {
4498              JSON_THROW(ex);
4499          }
4500          return false;
4501      }
4502      constexpr bool is_errored() const
4503      {
4504          return errored;
4505      }
4506    private:
4507      template&lt;typename Value&gt;
4508      JSON_HEDLEY_RETURNS_NON_NULL
4509      BasicJsonType* handle_value(Value&amp;&amp; v)
4510      {
4511          if (ref_stack.empty())
4512          {
4513              root = BasicJsonType(std::forward&lt;Value&gt;(v));
4514              return &amp;root;
4515          }
4516          JSON_ASSERT(ref_stack.back()-&gt;is_array() || ref_stack.back()-&gt;is_object());
4517          if (ref_stack.back()-&gt;is_array())
4518          {
4519              ref_stack.back()-&gt;m_value.array-&gt;emplace_back(std::forward&lt;Value&gt;(v));
4520              return &amp;(ref_stack.back()-&gt;m_value.array-&gt;back());
4521          }
4522          JSON_ASSERT(ref_stack.back()-&gt;is_object());
4523          JSON_ASSERT(object_element);
4524          *object_element = BasicJsonType(std::forward&lt;Value&gt;(v));
4525          return object_element;
4526      }
4527      BasicJsonType&amp; root;
4528      std::vector&lt;BasicJsonType*&gt; ref_stack {};
4529      BasicJsonType* object_element = nullptr;
4530      bool errored = false;
4531      const bool allow_exceptions = true;
4532  };
4533  template&lt;typename BasicJsonType&gt;
4534  class json_sax_dom_callback_parser
4535  {
4536    public:
4537      using number_integer_t = typename BasicJsonType::number_integer_t;
4538      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4539      using number_float_t = typename BasicJsonType::number_float_t;
4540      using string_t = typename BasicJsonType::string_t;
4541      using binary_t = typename BasicJsonType::binary_t;
4542      using parser_callback_t = typename BasicJsonType::parser_callback_t;
4543      using parse_event_t = typename BasicJsonType::parse_event_t;
4544      json_sax_dom_callback_parser(BasicJsonType&amp; r,
4545                                   const parser_callback_t cb,
4546                                   const bool allow_exceptions_ = true)
4547          : root(r), callback(cb), allow_exceptions(allow_exceptions_)
4548      {
4549          keep_stack.push_back(true);
4550      }
4551      json_sax_dom_callback_parser(const json_sax_dom_callback_parser&amp;) = delete;
4552      json_sax_dom_callback_parser(json_sax_dom_callback_parser&amp;&amp;) = default; 
4553      json_sax_dom_callback_parser&amp; operator=(const json_sax_dom_callback_parser&amp;) = delete;
4554      json_sax_dom_callback_parser&amp; operator=(json_sax_dom_callback_parser&amp;&amp;) = default; 
4555      ~json_sax_dom_callback_parser() = default;
4556      bool null()
4557      {
4558          handle_value(nullptr);
4559          return true;
4560      }
4561      bool boolean(bool val)
4562      {
4563          handle_value(val);
4564          return true;
4565      }
4566      bool number_integer(number_integer_t val)
4567      {
4568          handle_value(val);
4569          return true;
4570      }
4571      bool number_unsigned(number_unsigned_t val)
4572      {
4573          handle_value(val);
4574          return true;
4575      }
4576      bool number_float(number_float_t val, const string_t&amp; &amp;bsol;*unused*/)
4577      {
4578          handle_value(val);
4579          return true;
4580      }
4581      bool string(string_t&amp; val)
4582      {
4583          handle_value(val);
4584          return true;
4585      }
4586      bool binary(binary_t&amp; val)
4587      {
4588          handle_value(std::move(val));
4589          return true;
4590      }
4591      bool start_object(std::size_t len)
4592      {
4593          const bool keep = callback(static_cast&lt;int&gt;(ref_stack.size()), parse_event_t::object_start, discarded);
4594          keep_stack.push_back(keep);
4595          auto val = handle_value(BasicJsonType::value_t::object, true);
4596          ref_stack.push_back(val.second);
4597          if (ref_stack.back() &amp;&amp; JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) &amp;&amp; len &gt; ref_stack.back()-&gt;max_size()))
4598          {
4599              JSON_THROW(out_of_range::create(408, &quot;excessive object size: &quot; + std::to_string(len), *ref_stack.back()));
4600          }
4601          return true;
4602      }
4603      bool key(string_t&amp; val)
4604      {
4605          BasicJsonType k = BasicJsonType(val);
4606          const bool keep = callback(static_cast&lt;int&gt;(ref_stack.size()), parse_event_t::key, k);
4607          key_keep_stack.push_back(keep);
4608          if (keep &amp;&amp; ref_stack.back())
4609          {
4610              object_element = &amp;(ref_stack.back()-&gt;m_value.object-&gt;operator[](val) = discarded);
4611          }
4612          return true;
4613      }
4614      bool end_object()
4615      {
4616          if (ref_stack.back())
4617          {
4618              if (!callback(static_cast&lt;int&gt;(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
4619              {
4620                  *ref_stack.back() = discarded;
4621              }
4622              else
4623              {
4624                  ref_stack.back()-&gt;set_parents();
4625              }
4626          }
4627          JSON_ASSERT(!ref_stack.empty());
4628          JSON_ASSERT(!keep_stack.empty());
4629          ref_stack.pop_back();
4630          keep_stack.pop_back();
4631          if (!ref_stack.empty() &amp;&amp; ref_stack.back() &amp;&amp; ref_stack.back()-&gt;is_structured())
4632          {
4633              for (auto it = ref_stack.back()-&gt;begin(); it != ref_stack.back()-&gt;end(); ++it)
4634              {
4635                  if (it-&gt;is_discarded())
4636                  {
4637                      ref_stack.back()-&gt;erase(it);
4638                      break;
4639                  }
4640              }
4641          }
4642          return true;
4643      }
4644      bool start_array(std::size_t len)
4645      {
4646          const bool keep = callback(static_cast&lt;int&gt;(ref_stack.size()), parse_event_t::array_start, discarded);
4647          keep_stack.push_back(keep);
4648          auto val = handle_value(BasicJsonType::value_t::array, true);
4649          ref_stack.push_back(val.second);
4650          if (ref_stack.back() &amp;&amp; JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) &amp;&amp; len &gt; ref_stack.back()-&gt;max_size()))
4651          {
4652              JSON_THROW(out_of_range::create(408, &quot;excessive array size: &quot; + std::to_string(len), *ref_stack.back()));
4653          }
4654          return true;
4655      }
4656      bool end_array()
4657      {
4658          bool keep = true;
4659          if (ref_stack.back())
4660          {
4661              keep = callback(static_cast&lt;int&gt;(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
4662              if (keep)
4663              {
4664                  ref_stack.back()-&gt;set_parents();
4665              }
4666              else
4667              {
4668                  *ref_stack.back() = discarded;
4669              }
4670          }
4671          JSON_ASSERT(!ref_stack.empty());
4672          JSON_ASSERT(!keep_stack.empty());
4673          ref_stack.pop_back();
4674          keep_stack.pop_back();
4675          if (!keep &amp;&amp; !ref_stack.empty() &amp;&amp; ref_stack.back()-&gt;is_array())
4676          {
4677              ref_stack.back()-&gt;m_value.array-&gt;pop_back();
4678          }
4679          return true;
4680      }
4681      template&lt;class Exception&gt;
4682      bool parse_error(std::size_t &amp;bsol;*unused*/, const std::string&amp; &amp;bsol;*unused*/,
4683                       const Exception&amp; ex)
4684      {
4685          errored = true;
4686          static_cast&lt;void&gt;(ex);
4687          if (allow_exceptions)
4688          {
4689              JSON_THROW(ex);
4690          }
4691          return false;
4692      }
4693      constexpr bool is_errored() const
4694      {
4695          return errored;
4696      }
4697    private:
4698      template&lt;typename Value&gt;
4699      std::pair&lt;bool, BasicJsonType*&gt; handle_value(Value&amp;&amp; v, const bool skip_callback = false)
4700      {
4701          JSON_ASSERT(!keep_stack.empty());
4702          if (!keep_stack.back())
4703          {
4704              return {false, nullptr};
4705          }
4706          auto value = BasicJsonType(std::forward&lt;Value&gt;(v));
4707          const bool keep = skip_callback || callback(static_cast&lt;int&gt;(ref_stack.size()), parse_event_t::value, value);
4708          if (!keep)
4709          {
4710              return {false, nullptr};
4711          }
4712          if (ref_stack.empty())
4713          {
4714              root = std::move(value);
4715              return {true, &amp;root};
4716          }
4717          if (!ref_stack.back())
4718          {
4719              return {false, nullptr};
4720          }
4721          JSON_ASSERT(ref_stack.back()-&gt;is_array() || ref_stack.back()-&gt;is_object());
4722          if (ref_stack.back()-&gt;is_array())
4723          {
4724              ref_stack.back()-&gt;m_value.array-&gt;emplace_back(std::move(value));
4725              return {true, &amp;(ref_stack.back()-&gt;m_value.array-&gt;back())};
4726          }
4727          JSON_ASSERT(ref_stack.back()-&gt;is_object());
4728          JSON_ASSERT(!key_keep_stack.empty());
4729          const bool store_element = key_keep_stack.back();
4730          key_keep_stack.pop_back();
4731          if (!store_element)
4732          {
4733              return {false, nullptr};
4734          }
4735          JSON_ASSERT(object_element);
4736          *object_element = std::move(value);
4737          return {true, object_element};
4738      }
4739      BasicJsonType&amp; root;
4740      std::vector&lt;BasicJsonType*&gt; ref_stack {};
4741      std::vector&lt;bool&gt; keep_stack {};
4742      std::vector&lt;bool&gt; key_keep_stack {};
4743      BasicJsonType* object_element = nullptr;
4744      bool errored = false;
4745      const parser_callback_t callback = nullptr;
4746      const bool allow_exceptions = true;
4747      BasicJsonType discarded = BasicJsonType::value_t::discarded;
4748  };
4749  template&lt;typename BasicJsonType&gt;
4750  class json_sax_acceptor
4751  {
4752    public:
4753      using number_integer_t = typename BasicJsonType::number_integer_t;
4754      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4755      using number_float_t = typename BasicJsonType::number_float_t;
4756      using string_t = typename BasicJsonType::string_t;
4757      using binary_t = typename BasicJsonType::binary_t;
4758      bool null()
4759      {
4760          return true;
4761      }
4762      bool boolean(bool &amp;bsol;*unused*/)
4763      {
4764          return true;
4765      }
4766      bool number_integer(number_integer_t &amp;bsol;*unused*/)
4767      {
4768          return true;
4769      }
4770      bool number_unsigned(number_unsigned_t &amp;bsol;*unused*/)
4771      {
4772          return true;
4773      }
4774      bool number_float(number_float_t &amp;bsol;*unused*/, const string_t&amp; &amp;bsol;*unused*/)
4775      {
4776          return true;
4777      }
4778      bool string(string_t&amp; &amp;bsol;*unused*/)
4779      {
4780          return true;
4781      }
4782      bool binary(binary_t&amp; &amp;bsol;*unused*/)
4783      {
4784          return true;
4785      }
4786      bool start_object(std::size_t &amp;bsol;*unused*/ = std::size_t(-1))
4787      {
4788          return true;
4789      }
4790      bool key(string_t&amp; &amp;bsol;*unused*/)
4791      {
4792          return true;
4793      }
4794      bool end_object()
4795      {
4796          return true;
4797      }
4798      bool start_array(std::size_t &amp;bsol;*unused*/ = std::size_t(-1))
4799      {
4800          return true;
4801      }
4802      bool end_array()
4803      {
4804          return true;
4805      }
4806      bool parse_error(std::size_t &amp;bsol;*unused*/, const std::string&amp; &amp;bsol;*unused*/, const detail::exception&amp; &amp;bsol;*unused*/)
4807      {
4808          return false;
4809      }
4810  };
4811  }  
4812  }  
4813  #include &lt;array&gt; 
4814  #include &lt;clocale&gt; 
4815  #include &lt;cstddef&gt; 
4816  #include &lt;cstdio&gt; 
4817  #include &lt;cstdlib&gt; 
4818  #include &lt;initializer_list&gt; 
4819  #include &lt;string&gt; 
4820  #include &lt;utility&gt; 
4821  #include &lt;vector&gt; 
4822  namespace nlohmann
4823  {
4824  namespace detail
4825  {
4826  template&lt;typename BasicJsonType&gt;
4827  class lexer_base
4828  {
4829    public:
4830      enum class token_type
4831      {
4832          uninitialized,    
4833          literal_true,     
4834          literal_false,    
4835          literal_null,     
4836          value_string,     
4837          value_unsigned,   
4838          value_integer,    
4839          value_float,      
4840          begin_array,      
4841          begin_object,     
4842          end_array,        
4843          end_object,       
4844          name_separator,   
4845          value_separator,  
4846          parse_error,      
4847          end_of_input,     
4848          literal_or_value  
4849      };
4850      JSON_HEDLEY_RETURNS_NON_NULL
4851      JSON_HEDLEY_CONST
4852      static const char* token_type_name(const token_type t) noexcept
4853      {
4854          switch (t)
4855          {
4856              case token_type::uninitialized:
4857                  return &quot;&lt;uninitialized&gt;&quot;;
4858              case token_type::literal_true:
4859                  return &quot;true literal&quot;;
4860              case token_type::literal_false:
4861                  return &quot;false literal&quot;;
4862              case token_type::literal_null:
4863                  return &quot;null literal&quot;;
4864              case token_type::value_string:
4865                  return &quot;string literal&quot;;
4866              case token_type::value_unsigned:
4867              case token_type::value_integer:
4868              case token_type::value_float:
4869                  return &quot;number literal&quot;;
4870              case token_type::begin_array:
4871                  return &quot;&#x27;[&#x27;&quot;;
4872              case token_type::begin_object:
4873                  return &quot;&#x27;{&#x27;&quot;;
4874              case token_type::end_array:
4875                  return &quot;&#x27;]&#x27;&quot;;
4876              case token_type::end_object:
4877                  return &quot;&#x27;}&#x27;&quot;;
4878              case token_type::name_separator:
4879                  return &quot;&#x27;:&#x27;&quot;;
4880              case token_type::value_separator:
4881                  return &quot;&#x27;,&#x27;&quot;;
4882              case token_type::parse_error:
4883                  return &quot;&lt;parse error&gt;&quot;;
4884              case token_type::end_of_input:
4885                  return &quot;end of input&quot;;
4886              case token_type::literal_or_value:
4887                  return &quot;&#x27;[&#x27;, &#x27;{&#x27;, or a literal&quot;;
4888              default: 
4889                  return &quot;unknown token&quot;;
4890          }
4891      }
4892  };
4893  template&lt;typename BasicJsonType, typename InputAdapterType&gt;
4894  class lexer : public lexer_base&lt;BasicJsonType&gt;
4895  {
4896      using number_integer_t = typename BasicJsonType::number_integer_t;
4897      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4898      using number_float_t = typename BasicJsonType::number_float_t;
4899      using string_t = typename BasicJsonType::string_t;
4900      using char_type = typename InputAdapterType::char_type;
4901      using char_int_type = typename std::char_traits&lt;char_type&gt;::int_type;
4902    public:
4903      using token_type = typename lexer_base&lt;BasicJsonType&gt;::token_type;
4904      explicit lexer(InputAdapterType&amp;&amp; adapter, bool ignore_comments_ = false) noexcept
4905          : ia(std::move(adapter))
4906          , ignore_comments(ignore_comments_)
4907          , decimal_point_char(static_cast&lt;char_int_type&gt;(get_decimal_point()))
4908      {}
4909      lexer(const lexer&amp;) = delete;
4910      lexer(lexer&amp;&amp;) = default; 
4911      lexer&amp; operator=(lexer&amp;) = delete;
4912      lexer&amp; operator=(lexer&amp;&amp;) = default; 
4913      ~lexer() = default;
4914    private:
4915      JSON_HEDLEY_PURE
4916      static char get_decimal_point() noexcept
4917      {
4918          const auto* loc = localeconv();
4919          JSON_ASSERT(loc != nullptr);
4920          return (loc-&gt;decimal_point == nullptr) ? &#x27;.&#x27; : *(loc-&gt;decimal_point);
4921      }
4922      int get_codepoint()
4923      {
4924          JSON_ASSERT(current == &#x27;u&#x27;);
4925          int codepoint = 0;
4926          const auto factors = { 12u, 8u, 4u, 0u };
4927          for (const auto factor : factors)
4928          {
4929              get();
4930              if (current &gt;= &#x27;0&#x27; &amp;&amp; current &lt;= &#x27;9&#x27;)
4931              {
4932                  codepoint += static_cast&lt;int&gt;((static_cast&lt;unsigned int&gt;(current) - 0x30u) &lt;&lt; factor);
4933              }
4934              else if (current &gt;= &#x27;A&#x27; &amp;&amp; current &lt;= &#x27;F&#x27;)
4935              {
4936                  codepoint += static_cast&lt;int&gt;((static_cast&lt;unsigned int&gt;(current) - 0x37u) &lt;&lt; factor);
4937              }
4938              else if (current &gt;= &#x27;a&#x27; &amp;&amp; current &lt;= &#x27;f&#x27;)
4939              {
4940                  codepoint += static_cast&lt;int&gt;((static_cast&lt;unsigned int&gt;(current) - 0x57u) &lt;&lt; factor);
4941              }
4942              else
4943              {
4944                  return -1;
4945              }
4946          }
4947          JSON_ASSERT(0x0000 &lt;= codepoint &amp;&amp; codepoint &lt;= 0xFFFF);
4948          return codepoint;
4949      }
4950      bool next_byte_in_range(std::initializer_list&lt;char_int_type&gt; ranges)
4951      {
4952          JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
4953          add(current);
4954          for (auto range = ranges.begin(); range != ranges.end(); ++range)
4955          {
4956              get();
4957              if (JSON_HEDLEY_LIKELY(*range &lt;= current &amp;&amp; current &lt;= *(++range)))
4958              {
4959                  add(current);
4960              }
4961              else
4962              {
4963                  error_message = &quot;invalid string: ill-formed UTF-8 byte&quot;;
4964                  return false;
4965              }
4966          }
4967          return true;
4968      }
4969      token_type scan_string()
4970      {
4971          reset();
4972          JSON_ASSERT(current == &#x27;\&quot;&#x27;);
4973          while (true)
4974          {
4975              switch (get())
4976              {
4977                  case std::char_traits&lt;char_type&gt;::eof():
4978                  {
4979                      error_message = &quot;invalid string: missing closing quote&quot;;
4980                      return token_type::parse_error;
4981                  }
4982                  case &#x27;\&quot;&#x27;:
4983                  {
4984                      return token_type::value_string;
4985                  }
4986                  case &#x27;\\&#x27;:
4987                  {
4988                      switch (get())
4989                      {
4990                          case &#x27;\&quot;&#x27;:
4991                              add(&#x27;\&quot;&#x27;);
4992                              break;
4993                          case &#x27;\\&#x27;:
4994                              add(&#x27;\\&#x27;);
4995                              break;
4996                          case &#x27;/&#x27;:
4997                              add(&#x27;/&#x27;);
4998                              break;
4999                          case &#x27;b&#x27;:
5000                              add(&#x27;\b&#x27;);
5001                              break;
5002                          case &#x27;f&#x27;:
5003                              add(&#x27;\f&#x27;);
5004                              break;
5005                          case &#x27;n&#x27;:
5006                              add(&#x27;\n&#x27;);
5007                              break;
5008                          case &#x27;r&#x27;:
5009                              add(&#x27;\r&#x27;);
5010                              break;
5011                          case &#x27;t&#x27;:
5012                              add(&#x27;\t&#x27;);
5013                              break;
5014                          case &#x27;u&#x27;:
5015                          {
5016                              const int codepoint1 = get_codepoint();
5017                              int codepoint = codepoint1; 
5018                              if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
5019                              {
5020                                  error_message = &quot;invalid string: &#x27;\\u&#x27; must be followed by 4 hex digits&quot;;
5021                                  return token_type::parse_error;
5022                              }
5023                              if (0xD800 &lt;= codepoint1 &amp;&amp; codepoint1 &lt;= 0xDBFF)
5024                              {
5025                                  if (JSON_HEDLEY_LIKELY(get() == &#x27;\\&#x27; &amp;&amp; get() == &#x27;u&#x27;))
5026                                  {
5027                                      const int codepoint2 = get_codepoint();
5028                                      if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
5029                                      {
5030                                          error_message = &quot;invalid string: &#x27;\\u&#x27; must be followed by 4 hex digits&quot;;
5031                                          return token_type::parse_error;
5032                                      }
5033                                      if (JSON_HEDLEY_LIKELY(0xDC00 &lt;= codepoint2 &amp;&amp; codepoint2 &lt;= 0xDFFF))
5034                                      {
5035                                          codepoint = static_cast&lt;int&gt;(
5036                                                          (static_cast&lt;unsigned int&gt;(codepoint1) &lt;&lt; 10u)
5037                                                          + static_cast&lt;unsigned int&gt;(codepoint2)
5038                                                          - 0x35FDC00u);
5039                                      }
5040                                      else
5041                                      {
5042                                          error_message = &quot;invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF&quot;;
5043                                          return token_type::parse_error;
5044                                      }
5045                                  }
5046                                  else
5047                                  {
5048                                      error_message = &quot;invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF&quot;;
5049                                      return token_type::parse_error;
5050                                  }
5051                              }
5052                              else
5053                              {
5054                                  if (JSON_HEDLEY_UNLIKELY(0xDC00 &lt;= codepoint1 &amp;&amp; codepoint1 &lt;= 0xDFFF))
5055                                  {
5056                                      error_message = &quot;invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF&quot;;
5057                                      return token_type::parse_error;
5058                                  }
5059                              }
5060                              JSON_ASSERT(0x00 &lt;= codepoint &amp;&amp; codepoint &lt;= 0x10FFFF);
5061                              if (codepoint &lt; 0x80)
5062                              {
5063                                  add(static_cast&lt;char_int_type&gt;(codepoint));
5064                              }
5065                              else if (codepoint &lt;= 0x7FF)
5066                              {
5067                                  add(static_cast&lt;char_int_type&gt;(0xC0u | (static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 6u)));
5068                                  add(static_cast&lt;char_int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(codepoint) &amp; 0x3Fu)));
5069                              }
5070                              else if (codepoint &lt;= 0xFFFF)
5071                              {
5072                                  add(static_cast&lt;char_int_type&gt;(0xE0u | (static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 12u)));
5073                                  add(static_cast&lt;char_int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 6u) &amp; 0x3Fu)));
5074                                  add(static_cast&lt;char_int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(codepoint) &amp; 0x3Fu)));
5075                              }
5076                              else
5077                              {
5078                                  add(static_cast&lt;char_int_type&gt;(0xF0u | (static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 18u)));
5079                                  add(static_cast&lt;char_int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 12u) &amp; 0x3Fu)));
5080                                  add(static_cast&lt;char_int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 6u) &amp; 0x3Fu)));
5081                                  add(static_cast&lt;char_int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(codepoint) &amp; 0x3Fu)));
5082                              }
5083                              break;
5084                          }
5085                          default:
5086                              error_message = &quot;invalid string: forbidden character after backslash&quot;;
5087                              return token_type::parse_error;
5088                      }
5089                      break;
5090                  }
5091                  case 0x00:
5092                  {
5093                      error_message = &quot;invalid string: control character U+0000 (NUL) must be escaped to \\u0000&quot;;
5094                      return token_type::parse_error;
5095                  }
5096                  case 0x01:
5097                  {
5098                      error_message = &quot;invalid string: control character U+0001 (SOH) must be escaped to \\u0001&quot;;
5099                      return token_type::parse_error;
5100                  }
5101                  case 0x02:
5102                  {
5103                      error_message = &quot;invalid string: control character U+0002 (STX) must be escaped to \\u0002&quot;;
5104                      return token_type::parse_error;
5105                  }
5106                  case 0x03:
5107                  {
5108                      error_message = &quot;invalid string: control character U+0003 (ETX) must be escaped to \\u0003&quot;;
5109                      return token_type::parse_error;
5110                  }
5111                  case 0x04:
5112                  {
5113                      error_message = &quot;invalid string: control character U+0004 (EOT) must be escaped to \\u0004&quot;;
5114                      return token_type::parse_error;
5115                  }
5116                  case 0x05:
5117                  {
5118                      error_message = &quot;invalid string: control character U+0005 (ENQ) must be escaped to \\u0005&quot;;
5119                      return token_type::parse_error;
5120                  }
5121                  case 0x06:
5122                  {
5123                      error_message = &quot;invalid string: control character U+0006 (ACK) must be escaped to \\u0006&quot;;
5124                      return token_type::parse_error;
5125                  }
5126                  case 0x07:
5127                  {
5128                      error_message = &quot;invalid string: control character U+0007 (BEL) must be escaped to \\u0007&quot;;
5129                      return token_type::parse_error;
5130                  }
5131                  case 0x08:
5132                  {
5133                      error_message = &quot;invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b&quot;;
5134                      return token_type::parse_error;
5135                  }
5136                  case 0x09:
5137                  {
5138                      error_message = &quot;invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t&quot;;
5139                      return token_type::parse_error;
5140                  }
5141                  case 0x0A:
5142                  {
5143                      error_message = &quot;invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n&quot;;
5144                      return token_type::parse_error;
5145                  }
5146                  case 0x0B:
5147                  {
5148                      error_message = &quot;invalid string: control character U+000B (VT) must be escaped to \\u000B&quot;;
5149                      return token_type::parse_error;
5150                  }
5151                  case 0x0C:
5152                  {
5153                      error_message = &quot;invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f&quot;;
5154                      return token_type::parse_error;
5155                  }
5156                  case 0x0D:
5157                  {
5158                      error_message = &quot;invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r&quot;;
5159                      return token_type::parse_error;
5160                  }
5161                  case 0x0E:
5162                  {
5163                      error_message = &quot;invalid string: control character U+000E (SO) must be escaped to \\u000E&quot;;
5164                      return token_type::parse_error;
5165                  }
5166                  case 0x0F:
5167                  {
5168                      error_message = &quot;invalid string: control character U+000F (SI) must be escaped to \\u000F&quot;;
5169                      return token_type::parse_error;
5170                  }
5171                  case 0x10:
5172                  {
5173                      error_message = &quot;invalid string: control character U+0010 (DLE) must be escaped to \\u0010&quot;;
5174                      return token_type::parse_error;
5175                  }
5176                  case 0x11:
5177                  {
5178                      error_message = &quot;invalid string: control character U+0011 (DC1) must be escaped to \\u0011&quot;;
5179                      return token_type::parse_error;
5180                  }
5181                  case 0x12:
5182                  {
5183                      error_message = &quot;invalid string: control character U+0012 (DC2) must be escaped to \\u0012&quot;;
5184                      return token_type::parse_error;
5185                  }
5186                  case 0x13:
5187                  {
5188                      error_message = &quot;invalid string: control character U+0013 (DC3) must be escaped to \\u0013&quot;;
5189                      return token_type::parse_error;
5190                  }
5191                  case 0x14:
5192                  {
5193                      error_message = &quot;invalid string: control character U+0014 (DC4) must be escaped to \\u0014&quot;;
5194                      return token_type::parse_error;
5195                  }
5196                  case 0x15:
5197                  {
5198                      error_message = &quot;invalid string: control character U+0015 (NAK) must be escaped to \\u0015&quot;;
5199                      return token_type::parse_error;
5200                  }
5201                  case 0x16:
5202                  {
5203                      error_message = &quot;invalid string: control character U+0016 (SYN) must be escaped to \\u0016&quot;;
5204                      return token_type::parse_error;
5205                  }
5206                  case 0x17:
5207                  {
5208                      error_message = &quot;invalid string: control character U+0017 (ETB) must be escaped to \\u0017&quot;;
5209                      return token_type::parse_error;
5210                  }
5211                  case 0x18:
5212                  {
5213                      error_message = &quot;invalid string: control character U+0018 (CAN) must be escaped to \\u0018&quot;;
5214                      return token_type::parse_error;
5215                  }
5216                  case 0x19:
5217                  {
5218                      error_message = &quot;invalid string: control character U+0019 (EM) must be escaped to \\u0019&quot;;
5219                      return token_type::parse_error;
5220                  }
5221                  case 0x1A:
5222                  {
5223                      error_message = &quot;invalid string: control character U+001A (SUB) must be escaped to \\u001A&quot;;
5224                      return token_type::parse_error;
5225                  }
5226                  case 0x1B:
5227                  {
5228                      error_message = &quot;invalid string: control character U+001B (ESC) must be escaped to \\u001B&quot;;
5229                      return token_type::parse_error;
5230                  }
5231                  case 0x1C:
5232                  {
5233                      error_message = &quot;invalid string: control character U+001C (FS) must be escaped to \\u001C&quot;;
5234                      return token_type::parse_error;
5235                  }
5236                  case 0x1D:
5237                  {
5238                      error_message = &quot;invalid string: control character U+001D (GS) must be escaped to \\u001D&quot;;
5239                      return token_type::parse_error;
5240                  }
5241                  case 0x1E:
5242                  {
5243                      error_message = &quot;invalid string: control character U+001E (RS) must be escaped to \\u001E&quot;;
5244                      return token_type::parse_error;
5245                  }
5246                  case 0x1F:
5247                  {
5248                      error_message = &quot;invalid string: control character U+001F (US) must be escaped to \\u001F&quot;;
5249                      return token_type::parse_error;
5250                  }
5251                  case 0x20:
5252                  case 0x21:
5253                  case 0x23:
5254                  case 0x24:
5255                  case 0x25:
5256                  case 0x26:
5257                  case 0x27:
5258                  case 0x28:
5259                  case 0x29:
5260                  case 0x2A:
5261                  case 0x2B:
5262                  case 0x2C:
5263                  case 0x2D:
5264                  case 0x2E:
5265                  case 0x2F:
5266                  case 0x30:
5267                  case 0x31:
5268                  case 0x32:
5269                  case 0x33:
5270                  case 0x34:
5271                  case 0x35:
5272                  case 0x36:
5273                  case 0x37:
5274                  case 0x38:
5275                  case 0x39:
5276                  case 0x3A:
5277                  case 0x3B:
5278                  case 0x3C:
5279                  case 0x3D:
5280                  case 0x3E:
5281                  case 0x3F:
5282                  case 0x40:
5283                  case 0x41:
5284                  case 0x42:
5285                  case 0x43:
5286                  case 0x44:
5287                  case 0x45:
5288                  case 0x46:
5289                  case 0x47:
5290                  case 0x48:
5291                  case 0x49:
5292                  case 0x4A:
5293                  case 0x4B:
5294                  case 0x4C:
5295                  case 0x4D:
5296                  case 0x4E:
5297                  case 0x4F:
5298                  case 0x50:
5299                  case 0x51:
5300                  case 0x52:
5301                  case 0x53:
5302                  case 0x54:
5303                  case 0x55:
5304                  case 0x56:
5305                  case 0x57:
5306                  case 0x58:
5307                  case 0x59:
5308                  case 0x5A:
5309                  case 0x5B:
5310                  case 0x5D:
5311                  case 0x5E:
5312                  case 0x5F:
5313                  case 0x60:
5314                  case 0x61:
5315                  case 0x62:
5316                  case 0x63:
5317                  case 0x64:
5318                  case 0x65:
5319                  case 0x66:
5320                  case 0x67:
5321                  case 0x68:
5322                  case 0x69:
5323                  case 0x6A:
5324                  case 0x6B:
5325                  case 0x6C:
5326                  case 0x6D:
5327                  case 0x6E:
5328                  case 0x6F:
5329                  case 0x70:
5330                  case 0x71:
5331                  case 0x72:
5332                  case 0x73:
5333                  case 0x74:
5334                  case 0x75:
5335                  case 0x76:
5336                  case 0x77:
5337                  case 0x78:
5338                  case 0x79:
5339                  case 0x7A:
5340                  case 0x7B:
5341                  case 0x7C:
5342                  case 0x7D:
5343                  case 0x7E:
5344                  case 0x7F:
5345                  {
5346                      add(current);
5347                      break;
5348                  }
5349                  case 0xC2:
5350                  case 0xC3:
5351                  case 0xC4:
5352                  case 0xC5:
5353                  case 0xC6:
5354                  case 0xC7:
5355                  case 0xC8:
5356                  case 0xC9:
5357                  case 0xCA:
5358                  case 0xCB:
5359                  case 0xCC:
5360                  case 0xCD:
5361                  case 0xCE:
5362                  case 0xCF:
5363                  case 0xD0:
5364                  case 0xD1:
5365                  case 0xD2:
5366                  case 0xD3:
5367                  case 0xD4:
5368                  case 0xD5:
5369                  case 0xD6:
5370                  case 0xD7:
5371                  case 0xD8:
5372                  case 0xD9:
5373                  case 0xDA:
5374                  case 0xDB:
5375                  case 0xDC:
5376                  case 0xDD:
5377                  case 0xDE:
5378                  case 0xDF:
5379                  {
5380                      if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
5381                      {
5382                          return token_type::parse_error;
5383                      }
5384                      break;
5385                  }
5386                  case 0xE0:
5387                  {
5388                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
5389                      {
5390                          return token_type::parse_error;
5391                      }
5392                      break;
5393                  }
5394                  case 0xE1:
5395                  case 0xE2:
5396                  case 0xE3:
5397                  case 0xE4:
5398                  case 0xE5:
5399                  case 0xE6:
5400                  case 0xE7:
5401                  case 0xE8:
5402                  case 0xE9:
5403                  case 0xEA:
5404                  case 0xEB:
5405                  case 0xEC:
5406                  case 0xEE:
5407                  case 0xEF:
5408                  {
5409                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
5410                      {
5411                          return token_type::parse_error;
5412                      }
5413                      break;
5414                  }
5415                  case 0xED:
5416                  {
5417                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
5418                      {
5419                          return token_type::parse_error;
5420                      }
5421                      break;
5422                  }
5423                  case 0xF0:
5424                  {
5425                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
5426                      {
5427                          return token_type::parse_error;
5428                      }
5429                      break;
5430                  }
5431                  case 0xF1:
5432                  case 0xF2:
5433                  case 0xF3:
5434                  {
5435                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
5436                      {
5437                          return token_type::parse_error;
5438                      }
5439                      break;
5440                  }
5441                  case 0xF4:
5442                  {
5443                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
5444                      {
5445                          return token_type::parse_error;
5446                      }
5447                      break;
5448                  }
5449                  default:
5450                  {
5451                      error_message = &quot;invalid string: ill-formed UTF-8 byte&quot;;
5452                      return token_type::parse_error;
5453                  }
5454              }
5455          }
5456      }
5457      bool scan_comment()
5458      {
5459          switch (get())
5460          {
5461              case &#x27;/&#x27;:
5462              {
5463                  while (true)
5464                  {
5465                      switch (get())
5466                      {
5467                          case &#x27;\n&#x27;:
5468                          case &#x27;\r&#x27;:
5469                          case std::char_traits&lt;char_type&gt;::eof():
5470                          case &#x27;\0&#x27;:
5471                              return true;
5472                          default:
5473                              break;
5474                      }
5475                  }
5476              }
5477              case &#x27;*&#x27;:
5478              {
5479                  while (true)
5480                  {
5481                      switch (get())
5482                      {
5483                          case std::char_traits&lt;char_type&gt;::eof():
5484                          case &#x27;\0&#x27;:
5485                          {
5486                              error_message = &quot;invalid comment; missing closing &#x27;*/&#x27;&quot;;
5487                              return false;
5488                          }
5489                          case &#x27;*&#x27;:
5490                          {
5491                              switch (get())
5492                              {
5493                                  case &#x27;/&#x27;:
5494                                      return true;
5495                                  default:
5496                                  {
5497                                      unget();
5498                                      continue;
5499                                  }
5500                              }
5501                          }
5502                          default:
5503                              continue;
5504                      }
5505                  }
5506              }
5507              default:
5508              {
5509                  error_message = &quot;invalid comment; expecting &#x27;/&#x27; or &#x27;*&#x27; after &#x27;/&#x27;&quot;;
5510                  return false;
5511              }
5512          }
5513      }
5514      JSON_HEDLEY_NON_NULL(2)
5515      static void strtof(float&amp; f, const char* str, char** endptr) noexcept
5516      {
5517          f = std::strtof(str, endptr);
5518      }
5519      JSON_HEDLEY_NON_NULL(2)
5520      static void strtof(double&amp; f, const char* str, char** endptr) noexcept
5521      {
5522          f = std::strtod(str, endptr);
5523      }
5524      JSON_HEDLEY_NON_NULL(2)
5525      static void strtof(long double&amp; f, const char* str, char** endptr) noexcept
5526      {
5527          f = std::strtold(str, endptr);
5528      }
5529      token_type scan_number()  
5530      {
5531          reset();
5532          token_type number_type = token_type::value_unsigned;
5533          switch (current)
5534          {
5535              case &#x27;-&#x27;:
5536              {
5537                  add(current);
5538                  goto scan_number_minus;
5539              }
5540              case &#x27;0&#x27;:
5541              {
5542                  add(current);
5543                  goto scan_number_zero;
5544              }
5545              case &#x27;1&#x27;:
5546              case &#x27;2&#x27;:
5547              case &#x27;3&#x27;:
5548              case &#x27;4&#x27;:
5549              case &#x27;5&#x27;:
5550              case &#x27;6&#x27;:
5551              case &#x27;7&#x27;:
5552              case &#x27;8&#x27;:
5553              case &#x27;9&#x27;:
5554              {
5555                  add(current);
5556                  goto scan_number_any1;
5557              }
5558              default:            
5559                  JSON_ASSERT(false); 
5560          }
5561  scan_number_minus:
5562          number_type = token_type::value_integer;
5563          switch (get())
5564          {
5565              case &#x27;0&#x27;:
5566              {
5567                  add(current);
5568                  goto scan_number_zero;
5569              }
5570              case &#x27;1&#x27;:
5571              case &#x27;2&#x27;:
5572              case &#x27;3&#x27;:
5573              case &#x27;4&#x27;:
5574              case &#x27;5&#x27;:
5575              case &#x27;6&#x27;:
5576              case &#x27;7&#x27;:
5577              case &#x27;8&#x27;:
5578              case &#x27;9&#x27;:
5579              {
5580                  add(current);
5581                  goto scan_number_any1;
5582              }
5583              default:
5584              {
5585                  error_message = &quot;invalid number; expected digit after &#x27;-&#x27;&quot;;
5586                  return token_type::parse_error;
5587              }
5588          }
5589  scan_number_zero:
5590          switch (get())
5591          {
5592              case &#x27;.&#x27;:
5593              {
5594                  add(decimal_point_char);
5595                  goto scan_number_decimal1;
5596              }
5597              case &#x27;e&#x27;:
5598              case &#x27;E&#x27;:
5599              {
5600                  add(current);
5601                  goto scan_number_exponent;
5602              }
5603              default:
5604                  goto scan_number_done;
5605          }
5606  scan_number_any1:
5607          switch (get())
5608          {
5609              case &#x27;0&#x27;:
5610              case &#x27;1&#x27;:
5611              case &#x27;2&#x27;:
5612              case &#x27;3&#x27;:
5613              case &#x27;4&#x27;:
5614              case &#x27;5&#x27;:
5615              case &#x27;6&#x27;:
5616              case &#x27;7&#x27;:
5617              case &#x27;8&#x27;:
5618              case &#x27;9&#x27;:
5619              {
5620                  add(current);
5621                  goto scan_number_any1;
5622              }
5623              case &#x27;.&#x27;:
5624              {
5625                  add(decimal_point_char);
5626                  goto scan_number_decimal1;
5627              }
5628              case &#x27;e&#x27;:
5629              case &#x27;E&#x27;:
5630              {
5631                  add(current);
5632                  goto scan_number_exponent;
5633              }
5634              default:
5635                  goto scan_number_done;
5636          }
5637  scan_number_decimal1:
5638          number_type = token_type::value_float;
5639          switch (get())
5640          {
5641              case &#x27;0&#x27;:
5642              case &#x27;1&#x27;:
5643              case &#x27;2&#x27;:
5644              case &#x27;3&#x27;:
5645              case &#x27;4&#x27;:
5646              case &#x27;5&#x27;:
5647              case &#x27;6&#x27;:
5648              case &#x27;7&#x27;:
5649              case &#x27;8&#x27;:
5650              case &#x27;9&#x27;:
5651              {
5652                  add(current);
5653                  goto scan_number_decimal2;
5654              }
5655              default:
5656              {
5657                  error_message = &quot;invalid number; expected digit after &#x27;.&#x27;&quot;;
5658                  return token_type::parse_error;
5659              }
5660          }
5661  scan_number_decimal2:
5662          switch (get())
5663          {
5664              case &#x27;0&#x27;:
5665              case &#x27;1&#x27;:
5666              case &#x27;2&#x27;:
5667              case &#x27;3&#x27;:
5668              case &#x27;4&#x27;:
5669              case &#x27;5&#x27;:
5670              case &#x27;6&#x27;:
5671              case &#x27;7&#x27;:
5672              case &#x27;8&#x27;:
5673              case &#x27;9&#x27;:
5674              {
5675                  add(current);
5676                  goto scan_number_decimal2;
5677              }
5678              case &#x27;e&#x27;:
5679              case &#x27;E&#x27;:
5680              {
5681                  add(current);
5682                  goto scan_number_exponent;
5683              }
5684              default:
5685                  goto scan_number_done;
5686          }
5687  scan_number_exponent:
5688          number_type = token_type::value_float;
5689          switch (get())
5690          {
5691              case &#x27;+&#x27;:
5692              case &#x27;-&#x27;:
5693              {
5694                  add(current);
5695                  goto scan_number_sign;
5696              }
5697              case &#x27;0&#x27;:
5698              case &#x27;1&#x27;:
5699              case &#x27;2&#x27;:
5700              case &#x27;3&#x27;:
5701              case &#x27;4&#x27;:
5702              case &#x27;5&#x27;:
5703              case &#x27;6&#x27;:
5704              case &#x27;7&#x27;:
5705              case &#x27;8&#x27;:
5706              case &#x27;9&#x27;:
5707              {
5708                  add(current);
5709                  goto scan_number_any2;
5710              }
5711              default:
5712              {
5713                  error_message =
5714                      &quot;invalid number; expected &#x27;+&#x27;, &#x27;-&#x27;, or digit after exponent&quot;;
5715                  return token_type::parse_error;
5716              }
5717          }
5718  scan_number_sign:
5719          switch (get())
5720          {
5721              case &#x27;0&#x27;:
5722              case &#x27;1&#x27;:
5723              case &#x27;2&#x27;:
5724              case &#x27;3&#x27;:
5725              case &#x27;4&#x27;:
5726              case &#x27;5&#x27;:
5727              case &#x27;6&#x27;:
5728              case &#x27;7&#x27;:
5729              case &#x27;8&#x27;:
5730              case &#x27;9&#x27;:
5731              {
5732                  add(current);
5733                  goto scan_number_any2;
5734              }
5735              default:
5736              {
5737                  error_message = &quot;invalid number; expected digit after exponent sign&quot;;
5738                  return token_type::parse_error;
5739              }
5740          }
5741  scan_number_any2:
5742          switch (get())
5743          {
5744              case &#x27;0&#x27;:
5745              case &#x27;1&#x27;:
5746              case &#x27;2&#x27;:
5747              case &#x27;3&#x27;:
5748              case &#x27;4&#x27;:
5749              case &#x27;5&#x27;:
5750              case &#x27;6&#x27;:
5751              case &#x27;7&#x27;:
5752              case &#x27;8&#x27;:
5753              case &#x27;9&#x27;:
5754              {
5755                  add(current);
5756                  goto scan_number_any2;
5757              }
5758              default:
5759                  goto scan_number_done;
5760          }
5761  scan_number_done:
5762          unget();
5763          char* endptr = nullptr; 
5764          errno = 0;
5765          if (number_type == token_type::value_unsigned)
5766          {
5767              const auto x = std::strtoull(token_buffer.data(), &amp;endptr, 10);
5768              JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
5769              if (errno == 0)
5770              {
5771                  value_unsigned = static_cast&lt;number_unsigned_t&gt;(x);
5772                  if (value_unsigned == x)
5773                  {
5774                      return token_type::value_unsigned;
5775                  }
5776              }
5777          }
5778          else if (number_type == token_type::value_integer)
5779          {
5780              const auto x = std::strtoll(token_buffer.data(), &amp;endptr, 10);
5781              JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
5782              if (errno == 0)
5783              {
5784                  value_integer = static_cast&lt;number_integer_t&gt;(x);
5785                  if (value_integer == x)
5786                  {
5787                      return token_type::value_integer;
5788                  }
5789              }
5790          }
5791          strtof(value_float, token_buffer.data(), &amp;endptr);
5792          JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
5793          return token_type::value_float;
5794      }
5795      JSON_HEDLEY_NON_NULL(2)
5796      token_type scan_literal(const char_type* literal_text, const std::size_t length,
5797                              token_type return_type)
5798      {
5799          JSON_ASSERT(std::char_traits&lt;char_type&gt;::to_char_type(current) == literal_text[0]);
5800          for (std::size_t i = 1; i &lt; length; ++i)
5801          {
5802              if (JSON_HEDLEY_UNLIKELY(std::char_traits&lt;char_type&gt;::to_char_type(get()) != literal_text[i]))
5803              {
5804                  error_message = &quot;invalid literal&quot;;
5805                  return token_type::parse_error;
5806              }
5807          }
5808          return return_type;
5809      }
5810      void reset() noexcept
5811      {
5812          token_buffer.clear();
5813          token_string.clear();
5814          token_string.push_back(std::char_traits&lt;char_type&gt;::to_char_type(current));
5815      }
5816      char_int_type get()
5817      {
5818          ++position.chars_read_total;
5819          ++position.chars_read_current_line;
5820          if (next_unget)
5821          {
5822              next_unget = false;
5823          }
5824          else
5825          {
5826              current = ia.get_character();
5827          }
5828          if (JSON_HEDLEY_LIKELY(current != std::char_traits&lt;char_type&gt;::eof()))
5829          {
5830              token_string.push_back(std::char_traits&lt;char_type&gt;::to_char_type(current));
5831          }
5832          if (current == &#x27;\n&#x27;)
5833          {
5834              ++position.lines_read;
5835              position.chars_read_current_line = 0;
5836          }
5837          return current;
5838      }
5839      void unget()
5840      {
5841          next_unget = true;
5842          --position.chars_read_total;
5843          if (position.chars_read_current_line == 0)
5844          {
5845              if (position.lines_read &gt; 0)
5846              {
5847                  --position.lines_read;
5848              }
5849          }
5850          else
5851          {
5852              --position.chars_read_current_line;
5853          }
5854          if (JSON_HEDLEY_LIKELY(current != std::char_traits&lt;char_type&gt;::eof()))
5855          {
5856              JSON_ASSERT(!token_string.empty());
5857              token_string.pop_back();
5858          }
5859      }
5860      void add(char_int_type c)
5861      {
5862          token_buffer.push_back(static_cast&lt;typename string_t::value_type&gt;(c));
5863      }
5864    public:
5865      constexpr number_integer_t get_number_integer() const noexcept
5866      {
5867          return value_integer;
5868      }
5869      constexpr number_unsigned_t get_number_unsigned() const noexcept
5870      {
5871          return value_unsigned;
5872      }
5873      constexpr number_float_t get_number_float() const noexcept
5874      {
5875          return value_float;
5876      }
5877      string_t&amp; get_string()
5878      {
5879          return token_buffer;
5880      }
5881      constexpr position_t get_position() const noexcept
5882      {
5883          return position;
5884      }
5885      std::string get_token_string() const
5886      {
5887          std::string result;
5888          for (const auto c : token_string)
5889          {
5890              if (static_cast&lt;unsigned char&gt;(c) &lt;= &#x27;\x1F&#x27;)
5891              {
5892                  std::array&lt;char, 9&gt; cs{{}};
5893                  (std::snprintf)(cs.data(), cs.size(), &quot;&lt;U+%.4X&gt;&quot;, static_cast&lt;unsigned char&gt;(c)); 
5894                  result += cs.data();
5895              }
5896              else
5897              {
5898                  result.push_back(static_cast&lt;std::string::value_type&gt;(c));
5899              }
5900          }
5901          return result;
5902      }
5903      JSON_HEDLEY_RETURNS_NON_NULL
5904      constexpr const char* get_error_message() const noexcept
5905      {
5906          return error_message;
5907      }
5908      bool skip_bom()
5909      {
5910          if (get() == 0xEF)
5911          {
5912              return get() == 0xBB &amp;&amp; get() == 0xBF;
5913          }
5914          unget();
5915          return true;
5916      }
5917      void skip_whitespace()
5918      {
5919          do
5920          {
5921              get();
5922          }
5923          while (current == &#x27; &#x27; || current == &#x27;\t&#x27; || current == &#x27;\n&#x27; || current == &#x27;\r&#x27;);
5924      }
5925      token_type scan()
5926      {
5927          if (position.chars_read_total == 0 &amp;&amp; !skip_bom())
5928          {
5929              error_message = &quot;invalid BOM; must be 0xEF 0xBB 0xBF if given&quot;;
5930              return token_type::parse_error;
5931          }
5932          skip_whitespace();
5933          while (ignore_comments &amp;&amp; current == &#x27;/&#x27;)
5934          {
5935              if (!scan_comment())
5936              {
5937                  return token_type::parse_error;
5938              }
5939              skip_whitespace();
5940          }
5941          switch (current)
5942          {
5943              case &#x27;[&#x27;:
5944                  return token_type::begin_array;
5945              case &#x27;]&#x27;:
5946                  return token_type::end_array;
5947              case &#x27;{&#x27;:
5948                  return token_type::begin_object;
5949              case &#x27;}&#x27;:
5950                  return token_type::end_object;
5951              case &#x27;:&#x27;:
5952                  return token_type::name_separator;
5953              case &#x27;,&#x27;:
5954                  return token_type::value_separator;
5955              case &#x27;t&#x27;:
5956              {
5957                  std::array&lt;char_type, 4&gt; true_literal = {{char_type(&#x27;t&#x27;), char_type(&#x27;r&#x27;), char_type(&#x27;u&#x27;), char_type(&#x27;e&#x27;)}};
5958                  return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
5959              }
5960              case &#x27;f&#x27;:
5961              {
5962                  std::array&lt;char_type, 5&gt; false_literal = {{char_type(&#x27;f&#x27;), char_type(&#x27;a&#x27;), char_type(&#x27;l&#x27;), char_type(&#x27;s&#x27;), char_type(&#x27;e&#x27;)}};
5963                  return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
5964              }
5965              case &#x27;n&#x27;:
5966              {
5967                  std::array&lt;char_type, 4&gt; null_literal = {{char_type(&#x27;n&#x27;), char_type(&#x27;u&#x27;), char_type(&#x27;l&#x27;), char_type(&#x27;l&#x27;)}};
5968                  return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
5969              }
5970              case &#x27;\&quot;&#x27;:
5971                  return scan_string();
5972              case &#x27;-&#x27;:
5973              case &#x27;0&#x27;:
5974              case &#x27;1&#x27;:
5975              case &#x27;2&#x27;:
5976              case &#x27;3&#x27;:
5977              case &#x27;4&#x27;:
5978              case &#x27;5&#x27;:
5979              case &#x27;6&#x27;:
5980              case &#x27;7&#x27;:
5981              case &#x27;8&#x27;:
5982              case &#x27;9&#x27;:
5983                  return scan_number();
5984              case &#x27;\0&#x27;:
5985              case std::char_traits&lt;char_type&gt;::eof():
5986                  return token_type::end_of_input;
5987              default:
5988                  error_message = &quot;invalid literal&quot;;
5989                  return token_type::parse_error;
5990          }
5991      }
5992    private:
5993      InputAdapterType ia;
5994      const bool ignore_comments = false;
5995      char_int_type current = std::char_traits&lt;char_type&gt;::eof();
5996      bool next_unget = false;
5997      position_t position {};
5998      std::vector&lt;char_type&gt; token_string {};
5999      string_t token_buffer {};
6000      const char* error_message = &quot;&quot;;
6001      number_integer_t value_integer = 0;
6002      number_unsigned_t value_unsigned = 0;
6003      number_float_t value_float = 0;
6004      const char_int_type decimal_point_char = &#x27;.&#x27;;
6005  };
6006  }  
6007  }  
6008  #include &lt;cstdint&gt; 
6009  #include &lt;utility&gt; 
6010  #include &lt;string&gt; 
6011  namespace nlohmann
6012  {
6013  namespace detail
6014  {
6015  template&lt;typename T&gt;
6016  using null_function_t = decltype(std::declval&lt;T&amp;&gt;().null());
6017  template&lt;typename T&gt;
6018  using boolean_function_t =
6019      decltype(std::declval&lt;T&amp;&gt;().boolean(std::declval&lt;bool&gt;()));
6020  template&lt;typename T, typename Integer&gt;
6021  using number_integer_function_t =
6022      decltype(std::declval&lt;T&amp;&gt;().number_integer(std::declval&lt;Integer&gt;()));
6023  template&lt;typename T, typename Unsigned&gt;
6024  using number_unsigned_function_t =
6025      decltype(std::declval&lt;T&amp;&gt;().number_unsigned(std::declval&lt;Unsigned&gt;()));
6026  template&lt;typename T, typename Float, typename String&gt;
6027  using number_float_function_t = decltype(std::declval&lt;T&amp;&gt;().number_float(
6028                                      std::declval&lt;Float&gt;(), std::declval&lt;const String&amp;&gt;()));
6029  template&lt;typename T, typename String&gt;
6030  using string_function_t =
6031      decltype(std::declval&lt;T&amp;&gt;().string(std::declval&lt;String&amp;&gt;()));
6032  template&lt;typename T, typename Binary&gt;
6033  using binary_function_t =
6034      decltype(std::declval&lt;T&amp;&gt;().binary(std::declval&lt;Binary&amp;&gt;()));
6035  template&lt;typename T&gt;
6036  using start_object_function_t =
6037      decltype(std::declval&lt;T&amp;&gt;().start_object(std::declval&lt;std::size_t&gt;()));
6038  template&lt;typename T, typename String&gt;
6039  using key_function_t =
6040      decltype(std::declval&lt;T&amp;&gt;().key(std::declval&lt;String&amp;&gt;()));
6041  template&lt;typename T&gt;
6042  using end_object_function_t = decltype(std::declval&lt;T&amp;&gt;().end_object());
6043  template&lt;typename T&gt;
6044  using start_array_function_t =
6045      decltype(std::declval&lt;T&amp;&gt;().start_array(std::declval&lt;std::size_t&gt;()));
6046  template&lt;typename T&gt;
6047  using end_array_function_t = decltype(std::declval&lt;T&amp;&gt;().end_array());
6048  template&lt;typename T, typename Exception&gt;
6049  using parse_error_function_t = decltype(std::declval&lt;T&amp;&gt;().parse_error(
6050          std::declval&lt;std::size_t&gt;(), std::declval&lt;const std::string&amp;&gt;(),
6051          std::declval&lt;const Exception&amp;&gt;()));
6052  template&lt;typename SAX, typename BasicJsonType&gt;
6053  struct is_sax
6054  {
6055    private:
6056      static_assert(is_basic_json&lt;BasicJsonType&gt;::value,
6057                    &quot;BasicJsonType must be of type basic_json&lt;...&gt;&quot;);
6058      using number_integer_t = typename BasicJsonType::number_integer_t;
6059      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6060      using number_float_t = typename BasicJsonType::number_float_t;
6061      using string_t = typename BasicJsonType::string_t;
6062      using binary_t = typename BasicJsonType::binary_t;
6063      using exception_t = typename BasicJsonType::exception;
6064    public:
6065      static constexpr bool value =
6066          is_detected_exact&lt;bool, null_function_t, SAX&gt;::value &amp;&amp;
6067          is_detected_exact&lt;bool, boolean_function_t, SAX&gt;::value &amp;&amp;
6068          is_detected_exact&lt;bool, number_integer_function_t, SAX, number_integer_t&gt;::value &amp;&amp;
6069          is_detected_exact&lt;bool, number_unsigned_function_t, SAX, number_unsigned_t&gt;::value &amp;&amp;
6070          is_detected_exact&lt;bool, number_float_function_t, SAX, number_float_t, string_t&gt;::value &amp;&amp;
6071          is_detected_exact&lt;bool, string_function_t, SAX, string_t&gt;::value &amp;&amp;
6072          is_detected_exact&lt;bool, binary_function_t, SAX, binary_t&gt;::value &amp;&amp;
6073          is_detected_exact&lt;bool, start_object_function_t, SAX&gt;::value &amp;&amp;
6074          is_detected_exact&lt;bool, key_function_t, SAX, string_t&gt;::value &amp;&amp;
6075          is_detected_exact&lt;bool, end_object_function_t, SAX&gt;::value &amp;&amp;
6076          is_detected_exact&lt;bool, start_array_function_t, SAX&gt;::value &amp;&amp;
6077          is_detected_exact&lt;bool, end_array_function_t, SAX&gt;::value &amp;&amp;
6078          is_detected_exact&lt;bool, parse_error_function_t, SAX, exception_t&gt;::value;
6079  };
6080  template&lt;typename SAX, typename BasicJsonType&gt;
6081  struct is_sax_static_asserts
6082  {
6083    private:
6084      static_assert(is_basic_json&lt;BasicJsonType&gt;::value,
6085                    &quot;BasicJsonType must be of type basic_json&lt;...&gt;&quot;);
6086      using number_integer_t = typename BasicJsonType::number_integer_t;
6087      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6088      using number_float_t = typename BasicJsonType::number_float_t;
6089      using string_t = typename BasicJsonType::string_t;
6090      using binary_t = typename BasicJsonType::binary_t;
6091      using exception_t = typename BasicJsonType::exception;
6092    public:
6093      static_assert(is_detected_exact&lt;bool, null_function_t, SAX&gt;::value,
6094                    &quot;Missing/invalid function: bool null()&quot;);
6095      static_assert(is_detected_exact&lt;bool, boolean_function_t, SAX&gt;::value,
6096                    &quot;Missing/invalid function: bool boolean(bool)&quot;);
6097      static_assert(is_detected_exact&lt;bool, boolean_function_t, SAX&gt;::value,
6098                    &quot;Missing/invalid function: bool boolean(bool)&quot;);
6099      static_assert(
6100          is_detected_exact&lt;bool, number_integer_function_t, SAX,
6101          number_integer_t&gt;::value,
6102          &quot;Missing/invalid function: bool number_integer(number_integer_t)&quot;);
6103      static_assert(
6104          is_detected_exact&lt;bool, number_unsigned_function_t, SAX,
6105          number_unsigned_t&gt;::value,
6106          &quot;Missing/invalid function: bool number_unsigned(number_unsigned_t)&quot;);
6107      static_assert(is_detected_exact&lt;bool, number_float_function_t, SAX,
6108                    number_float_t, string_t&gt;::value,
6109                    &quot;Missing/invalid function: bool number_float(number_float_t, const string_t&amp;)&quot;);
6110      static_assert(
6111          is_detected_exact&lt;bool, string_function_t, SAX, string_t&gt;::value,
6112          &quot;Missing/invalid function: bool string(string_t&amp;)&quot;);
6113      static_assert(
6114          is_detected_exact&lt;bool, binary_function_t, SAX, binary_t&gt;::value,
6115          &quot;Missing/invalid function: bool binary(binary_t&amp;)&quot;);
6116      static_assert(is_detected_exact&lt;bool, start_object_function_t, SAX&gt;::value,
6117                    &quot;Missing/invalid function: bool start_object(std::size_t)&quot;);
6118      static_assert(is_detected_exact&lt;bool, key_function_t, SAX, string_t&gt;::value,
6119                    &quot;Missing/invalid function: bool key(string_t&amp;)&quot;);
6120      static_assert(is_detected_exact&lt;bool, end_object_function_t, SAX&gt;::value,
6121                    &quot;Missing/invalid function: bool end_object()&quot;);
6122      static_assert(is_detected_exact&lt;bool, start_array_function_t, SAX&gt;::value,
6123                    &quot;Missing/invalid function: bool start_array(std::size_t)&quot;);
6124      static_assert(is_detected_exact&lt;bool, end_array_function_t, SAX&gt;::value,
6125                    &quot;Missing/invalid function: bool end_array()&quot;);
6126      static_assert(
6127          is_detected_exact&lt;bool, parse_error_function_t, SAX, exception_t&gt;::value,
6128          &quot;Missing/invalid function: bool parse_error(std::size_t, const &quot;
6129          &quot;std::string&amp;, const exception&amp;)&quot;);
6130  };
6131  }  
6132  }  
6133  namespace nlohmann
6134  {
6135  namespace detail
6136  {
6137  enum class cbor_tag_handler_t
6138  {
6139      error,   
6140      ignore,  
6141      store    
6142  };
6143  static inline bool little_endianess(int num = 1) noexcept
6144  {
6145      return *reinterpret_cast&lt;char*&gt;(&amp;num) == 1;
6146  }
6147  template&lt;typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser&lt;BasicJsonType&gt;&gt;
6148  class binary_reader
6149  {
6150      using number_integer_t = typename BasicJsonType::number_integer_t;
6151      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6152      using number_float_t = typename BasicJsonType::number_float_t;
6153      using string_t = typename BasicJsonType::string_t;
6154      using binary_t = typename BasicJsonType::binary_t;
6155      using json_sax_t = SAX;
6156      using char_type = typename InputAdapterType::char_type;
6157      using char_int_type = typename std::char_traits&lt;char_type&gt;::int_type;
6158    public:
6159      explicit binary_reader(InputAdapterType&amp;&amp; adapter) noexcept : ia(std::move(adapter))
6160      {
6161          (void)detail::is_sax_static_asserts&lt;SAX, BasicJsonType&gt; {};
6162      }
6163      binary_reader(const binary_reader&amp;) = delete;
6164      binary_reader(binary_reader&amp;&amp;) = default; 
6165      binary_reader&amp; operator=(const binary_reader&amp;) = delete;
6166      binary_reader&amp; operator=(binary_reader&amp;&amp;) = default; 
6167      ~binary_reader() = default;
6168      JSON_HEDLEY_NON_NULL(3)
6169      bool sax_parse(const input_format_t format,
6170                     json_sax_t* sax_,
6171                     const bool strict = true,
6172                     const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
6173      {
6174          sax = sax_;
6175          bool result = false;
6176          switch (format)
6177          {
6178              case input_format_t::bson:
6179                  result = parse_bson_internal();
6180                  break;
6181              case input_format_t::cbor:
6182                  result = parse_cbor_internal(true, tag_handler);
6183                  break;
6184              case input_format_t::msgpack:
6185                  result = parse_msgpack_internal();
6186                  break;
6187              case input_format_t::ubjson:
6188                  result = parse_ubjson_internal();
6189                  break;
6190              case input_format_t::json: 
6191              default:            
6192                  JSON_ASSERT(false); 
6193          }
6194          if (result &amp;&amp; strict)
6195          {
6196              if (format == input_format_t::ubjson)
6197              {
6198                  get_ignore_noop();
6199              }
6200              else
6201              {
6202                  get();
6203              }
6204              if (JSON_HEDLEY_UNLIKELY(current != std::char_traits&lt;char_type&gt;::eof()))
6205              {
6206                  return sax-&gt;parse_error(chars_read, get_token_string(),
6207                                          parse_error::create(110, chars_read, exception_message(format, &quot;expected end of input; last byte: 0x&quot; + get_token_string(), &quot;value&quot;), BasicJsonType()));
6208              }
6209          }
6210          return result;
6211      }
6212    private:
6213      bool parse_bson_internal()
6214      {
6215          std::int32_t document_size{};
6216          get_number&lt;std::int32_t, true&gt;(input_format_t::bson, document_size);
6217          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(std::size_t(-1))))
6218          {
6219              return false;
6220          }
6221          if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(&amp;bsol;*is_array*/false)))
6222          {
6223              return false;
6224          }
6225          return sax-&gt;end_object();
6226      }
6227      bool get_bson_cstr(string_t&amp; result)
6228      {
6229          auto out = std::back_inserter(result);
6230          while (true)
6231          {
6232              get();
6233              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, &quot;cstring&quot;)))
6234              {
6235                  return false;
6236              }
6237              if (current == 0x00)
6238              {
6239                  return true;
6240              }
6241              *out++ = static_cast&lt;typename string_t::value_type&gt;(current);
6242          }
6243      }
6244      template&lt;typename NumberType&gt;
6245      bool get_bson_string(const NumberType len, string_t&amp; result)
6246      {
6247          if (JSON_HEDLEY_UNLIKELY(len &lt; 1))
6248          {
6249              auto last_token = get_token_string();
6250              return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, &quot;string length must be at least 1, is &quot; + std::to_string(len), &quot;string&quot;), BasicJsonType()));
6251          }
6252          return get_string(input_format_t::bson, len - static_cast&lt;NumberType&gt;(1), result) &amp;&amp; get() != std::char_traits&lt;char_type&gt;::eof();
6253      }
6254      template&lt;typename NumberType&gt;
6255      bool get_bson_binary(const NumberType len, binary_t&amp; result)
6256      {
6257          if (JSON_HEDLEY_UNLIKELY(len &lt; 0))
6258          {
6259              auto last_token = get_token_string();
6260              return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, &quot;byte array length cannot be negative, is &quot; + std::to_string(len), &quot;binary&quot;), BasicJsonType()));
6261          }
6262          std::uint8_t subtype{};
6263          get_number&lt;std::uint8_t&gt;(input_format_t::bson, subtype);
6264          result.set_subtype(subtype);
6265          return get_binary(input_format_t::bson, len, result);
6266      }
6267      bool parse_bson_element_internal(const char_int_type element_type,
6268                                       const std::size_t element_type_parse_position)
6269      {
6270          switch (element_type)
6271          {
6272              case 0x01: 
6273              {
6274                  double number{};
6275                  return get_number&lt;double, true&gt;(input_format_t::bson, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
6276              }
6277              case 0x02: 
6278              {
6279                  std::int32_t len{};
6280                  string_t value;
6281                  return get_number&lt;std::int32_t, true&gt;(input_format_t::bson, len) &amp;&amp; get_bson_string(len, value) &amp;&amp; sax-&gt;string(value);
6282              }
6283              case 0x03: 
6284              {
6285                  return parse_bson_internal();
6286              }
6287              case 0x04: 
6288              {
6289                  return parse_bson_array();
6290              }
6291              case 0x05: 
6292              {
6293                  std::int32_t len{};
6294                  binary_t value;
6295                  return get_number&lt;std::int32_t, true&gt;(input_format_t::bson, len) &amp;&amp; get_bson_binary(len, value) &amp;&amp; sax-&gt;binary(value);
6296              }
6297              case 0x08: 
6298              {
6299                  return sax-&gt;boolean(get() != 0);
6300              }
6301              case 0x0A: 
6302              {
6303                  return sax-&gt;null();
6304              }
6305              case 0x10: 
6306              {
6307                  std::int32_t value{};
6308                  return get_number&lt;std::int32_t, true&gt;(input_format_t::bson, value) &amp;&amp; sax-&gt;number_integer(value);
6309              }
6310              case 0x12: 
6311              {
6312                  std::int64_t value{};
6313                  return get_number&lt;std::int64_t, true&gt;(input_format_t::bson, value) &amp;&amp; sax-&gt;number_integer(value);
6314              }
6315              default: 
6316              {
6317                  std::array&lt;char, 3&gt; cr{{}};
6318                  (std::snprintf)(cr.data(), cr.size(), &quot;%.2hhX&quot;, static_cast&lt;unsigned char&gt;(element_type)); 
6319                  return sax-&gt;parse_error(element_type_parse_position, std::string(cr.data()), parse_error::create(114, element_type_parse_position, &quot;Unsupported BSON record type 0x&quot; + std::string(cr.data()), BasicJsonType()));
6320              }
6321          }
6322      }
6323      bool parse_bson_element_list(const bool is_array)
6324      {
6325          string_t key;
6326          while (auto element_type = get())
6327          {
6328              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, &quot;element list&quot;)))
6329              {
6330                  return false;
6331              }
6332              const std::size_t element_type_parse_position = chars_read;
6333              if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
6334              {
6335                  return false;
6336              }
6337              if (!is_array &amp;&amp; !sax-&gt;key(key))
6338              {
6339                  return false;
6340              }
6341              if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
6342              {
6343                  return false;
6344              }
6345              key.clear();
6346          }
6347          return true;
6348      }
6349      bool parse_bson_array()
6350      {
6351          std::int32_t document_size{};
6352          get_number&lt;std::int32_t, true&gt;(input_format_t::bson, document_size);
6353          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(std::size_t(-1))))
6354          {
6355              return false;
6356          }
6357          if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(&amp;bsol;*is_array*/true)))
6358          {
6359              return false;
6360          }
6361          return sax-&gt;end_array();
6362      }
6363      bool parse_cbor_internal(const bool get_char,
6364                               const cbor_tag_handler_t tag_handler)
6365      {
6366          switch (get_char ? get() : current)
6367          {
6368              case std::char_traits&lt;char_type&gt;::eof():
6369                  return unexpect_eof(input_format_t::cbor, &quot;value&quot;);
6370              case 0x00:
6371              case 0x01:
6372              case 0x02:
6373              case 0x03:
6374              case 0x04:
6375              case 0x05:
6376              case 0x06:
6377              case 0x07:
6378              case 0x08:
6379              case 0x09:
6380              case 0x0A:
6381              case 0x0B:
6382              case 0x0C:
6383              case 0x0D:
6384              case 0x0E:
6385              case 0x0F:
6386              case 0x10:
6387              case 0x11:
6388              case 0x12:
6389              case 0x13:
6390              case 0x14:
6391              case 0x15:
6392              case 0x16:
6393              case 0x17:
6394                  return sax-&gt;number_unsigned(static_cast&lt;number_unsigned_t&gt;(current));
6395              case 0x18: 
6396              {
6397                  std::uint8_t number{};
6398                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_unsigned(number);
6399              }
6400              case 0x19: 
6401              {
6402                  std::uint16_t number{};
6403                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_unsigned(number);
6404              }
6405              case 0x1A: 
6406              {
6407                  std::uint32_t number{};
6408                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_unsigned(number);
6409              }
6410              case 0x1B: 
6411              {
6412                  std::uint64_t number{};
6413                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_unsigned(number);
6414              }
6415              case 0x20:
6416              case 0x21:
6417              case 0x22:
6418              case 0x23:
6419              case 0x24:
6420              case 0x25:
6421              case 0x26:
6422              case 0x27:
6423              case 0x28:
6424              case 0x29:
6425              case 0x2A:
6426              case 0x2B:
6427              case 0x2C:
6428              case 0x2D:
6429              case 0x2E:
6430              case 0x2F:
6431              case 0x30:
6432              case 0x31:
6433              case 0x32:
6434              case 0x33:
6435              case 0x34:
6436              case 0x35:
6437              case 0x36:
6438              case 0x37:
6439                  return sax-&gt;number_integer(static_cast&lt;std::int8_t&gt;(0x20 - 1 - current));
6440              case 0x38: 
6441              {
6442                  std::uint8_t number{};
6443                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_integer(static_cast&lt;number_integer_t&gt;(-1) - number);
6444              }
6445              case 0x39: 
6446              {
6447                  std::uint16_t number{};
6448                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_integer(static_cast&lt;number_integer_t&gt;(-1) - number);
6449              }
6450              case 0x3A: 
6451              {
6452                  std::uint32_t number{};
6453                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_integer(static_cast&lt;number_integer_t&gt;(-1) - number);
6454              }
6455              case 0x3B: 
6456              {
6457                  std::uint64_t number{};
6458                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_integer(static_cast&lt;number_integer_t&gt;(-1)
6459                          - static_cast&lt;number_integer_t&gt;(number));
6460              }
6461              case 0x40:
6462              case 0x41:
6463              case 0x42:
6464              case 0x43:
6465              case 0x44:
6466              case 0x45:
6467              case 0x46:
6468              case 0x47:
6469              case 0x48:
6470              case 0x49:
6471              case 0x4A:
6472              case 0x4B:
6473              case 0x4C:
6474              case 0x4D:
6475              case 0x4E:
6476              case 0x4F:
6477              case 0x50:
6478              case 0x51:
6479              case 0x52:
6480              case 0x53:
6481              case 0x54:
6482              case 0x55:
6483              case 0x56:
6484              case 0x57:
6485              case 0x58: 
6486              case 0x59: 
6487              case 0x5A: 
6488              case 0x5B: 
6489              case 0x5F: 
6490              {
6491                  binary_t b;
6492                  return get_cbor_binary(b) &amp;&amp; sax-&gt;binary(b);
6493              }
6494              case 0x60:
6495              case 0x61:
6496              case 0x62:
6497              case 0x63:
6498              case 0x64:
6499              case 0x65:
6500              case 0x66:
6501              case 0x67:
6502              case 0x68:
6503              case 0x69:
6504              case 0x6A:
6505              case 0x6B:
6506              case 0x6C:
6507              case 0x6D:
6508              case 0x6E:
6509              case 0x6F:
6510              case 0x70:
6511              case 0x71:
6512              case 0x72:
6513              case 0x73:
6514              case 0x74:
6515              case 0x75:
6516              case 0x76:
6517              case 0x77:
6518              case 0x78: 
6519              case 0x79: 
6520              case 0x7A: 
6521              case 0x7B: 
6522              case 0x7F: 
6523              {
6524                  string_t s;
6525                  return get_cbor_string(s) &amp;&amp; sax-&gt;string(s);
6526              }
6527              case 0x80:
6528              case 0x81:
6529              case 0x82:
6530              case 0x83:
6531              case 0x84:
6532              case 0x85:
6533              case 0x86:
6534              case 0x87:
6535              case 0x88:
6536              case 0x89:
6537              case 0x8A:
6538              case 0x8B:
6539              case 0x8C:
6540              case 0x8D:
6541              case 0x8E:
6542              case 0x8F:
6543              case 0x90:
6544              case 0x91:
6545              case 0x92:
6546              case 0x93:
6547              case 0x94:
6548              case 0x95:
6549              case 0x96:
6550              case 0x97:
6551                  return get_cbor_array(static_cast&lt;std::size_t&gt;(static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu), tag_handler);
6552              case 0x98: 
6553              {
6554                  std::uint8_t len{};
6555                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_array(static_cast&lt;std::size_t&gt;(len), tag_handler);
6556              }
6557              case 0x99: 
6558              {
6559                  std::uint16_t len{};
6560                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_array(static_cast&lt;std::size_t&gt;(len), tag_handler);
6561              }
6562              case 0x9A: 
6563              {
6564                  std::uint32_t len{};
6565                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_array(static_cast&lt;std::size_t&gt;(len), tag_handler);
6566              }
6567              case 0x9B: 
6568              {
6569                  std::uint64_t len{};
6570                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_array(detail::conditional_static_cast&lt;std::size_t&gt;(len), tag_handler);
6571              }
6572              case 0x9F: 
6573                  return get_cbor_array(std::size_t(-1), tag_handler);
6574              case 0xA0:
6575              case 0xA1:
6576              case 0xA2:
6577              case 0xA3:
6578              case 0xA4:
6579              case 0xA5:
6580              case 0xA6:
6581              case 0xA7:
6582              case 0xA8:
6583              case 0xA9:
6584              case 0xAA:
6585              case 0xAB:
6586              case 0xAC:
6587              case 0xAD:
6588              case 0xAE:
6589              case 0xAF:
6590              case 0xB0:
6591              case 0xB1:
6592              case 0xB2:
6593              case 0xB3:
6594              case 0xB4:
6595              case 0xB5:
6596              case 0xB6:
6597              case 0xB7:
6598                  return get_cbor_object(static_cast&lt;std::size_t&gt;(static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu), tag_handler);
6599              case 0xB8: 
6600              {
6601                  std::uint8_t len{};
6602                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_object(static_cast&lt;std::size_t&gt;(len), tag_handler);
6603              }
6604              case 0xB9: 
6605              {
6606                  std::uint16_t len{};
6607                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_object(static_cast&lt;std::size_t&gt;(len), tag_handler);
6608              }
6609              case 0xBA: 
6610              {
6611                  std::uint32_t len{};
6612                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_object(static_cast&lt;std::size_t&gt;(len), tag_handler);
6613              }
6614              case 0xBB: 
6615              {
6616                  std::uint64_t len{};
6617                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_object(detail::conditional_static_cast&lt;std::size_t&gt;(len), tag_handler);
6618              }
6619              case 0xBF: 
6620                  return get_cbor_object(std::size_t(-1), tag_handler);
6621              case 0xC6: 
6622              case 0xC7:
6623              case 0xC8:
6624              case 0xC9:
6625              case 0xCA:
6626              case 0xCB:
6627              case 0xCC:
6628              case 0xCD:
6629              case 0xCE:
6630              case 0xCF:
6631              case 0xD0:
6632              case 0xD1:
6633              case 0xD2:
6634              case 0xD3:
6635              case 0xD4:
6636              case 0xD8: 
6637              case 0xD9: 
6638              case 0xDA: 
6639              case 0xDB: 
6640              {
6641                  switch (tag_handler)
6642                  {
6643                      case cbor_tag_handler_t::error:
6644                      {
6645                          auto last_token = get_token_string();
6646                          return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, &quot;invalid byte: 0x&quot; + last_token, &quot;value&quot;), BasicJsonType()));
6647                      }
6648                      case cbor_tag_handler_t::ignore:
6649                      {
6650                          switch (current)
6651                          {
6652                              case 0xD8:
6653                              {
6654                                  std::uint8_t subtype_to_ignore{};
6655                                  get_number(input_format_t::cbor, subtype_to_ignore);
6656                                  break;
6657                              }
6658                              case 0xD9:
6659                              {
6660                                  std::uint16_t subtype_to_ignore{};
6661                                  get_number(input_format_t::cbor, subtype_to_ignore);
6662                                  break;
6663                              }
6664                              case 0xDA:
6665                              {
6666                                  std::uint32_t subtype_to_ignore{};
6667                                  get_number(input_format_t::cbor, subtype_to_ignore);
6668                                  break;
6669                              }
6670                              case 0xDB:
6671                              {
6672                                  std::uint64_t subtype_to_ignore{};
6673                                  get_number(input_format_t::cbor, subtype_to_ignore);
6674                                  break;
6675                              }
6676                              default:
6677                                  break;
6678                          }
6679                          return parse_cbor_internal(true, tag_handler);
6680                      }
6681                      case cbor_tag_handler_t::store:
6682                      {
6683                          binary_t b;
6684                          switch (current)
6685                          {
6686                              case 0xD8:
6687                              {
6688                                  std::uint8_t subtype{};
6689                                  get_number(input_format_t::cbor, subtype);
6690                                  b.set_subtype(detail::conditional_static_cast&lt;typename binary_t::subtype_type&gt;(subtype));
6691                                  break;
6692                              }
6693                              case 0xD9:
6694                              {
6695                                  std::uint16_t subtype{};
6696                                  get_number(input_format_t::cbor, subtype);
6697                                  b.set_subtype(detail::conditional_static_cast&lt;typename binary_t::subtype_type&gt;(subtype));
6698                                  break;
6699                              }
6700                              case 0xDA:
6701                              {
6702                                  std::uint32_t subtype{};
6703                                  get_number(input_format_t::cbor, subtype);
6704                                  b.set_subtype(detail::conditional_static_cast&lt;typename binary_t::subtype_type&gt;(subtype));
6705                                  break;
6706                              }
6707                              case 0xDB:
6708                              {
6709                                  std::uint64_t subtype{};
6710                                  get_number(input_format_t::cbor, subtype);
6711                                  b.set_subtype(detail::conditional_static_cast&lt;typename binary_t::subtype_type&gt;(subtype));
6712                                  break;
6713                              }
6714                              default:
6715                                  return parse_cbor_internal(true, tag_handler);
6716                          }
6717                          get();
6718                          return get_cbor_binary(b) &amp;&amp; sax-&gt;binary(b);
6719                      }
6720                      default:                 
6721                          JSON_ASSERT(false); 
6722                          return false;        
6723                  }
6724              }
6725              case 0xF4: 
6726                  return sax-&gt;boolean(false);
6727              case 0xF5: 
6728                  return sax-&gt;boolean(true);
6729              case 0xF6: 
6730                  return sax-&gt;null();
6731              case 0xF9: 
6732              {
6733                  const auto byte1_raw = get();
6734                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, &quot;number&quot;)))
6735                  {
6736                      return false;
6737                  }
6738                  const auto byte2_raw = get();
6739                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, &quot;number&quot;)))
6740                  {
6741                      return false;
6742                  }
6743                  const auto byte1 = static_cast&lt;unsigned char&gt;(byte1_raw);
6744                  const auto byte2 = static_cast&lt;unsigned char&gt;(byte2_raw);
6745                  const auto half = static_cast&lt;unsigned int&gt;((byte1 &lt;&lt; 8u) + byte2);
6746                  const double val = [&amp;half]
6747                  {
6748                      const int exp = (half &gt;&gt; 10u) &amp; 0x1Fu;
6749                      const unsigned int mant = half &amp; 0x3FFu;
6750                      JSON_ASSERT(0 &lt;= exp&amp;&amp; exp &lt;= 32);
6751                      JSON_ASSERT(mant &lt;= 1024);
6752                      switch (exp)
6753                      {
6754                          case 0:
6755                              return std::ldexp(mant, -24);
6756                          case 31:
6757                              return (mant == 0)
6758                              ? std::numeric_limits&lt;double&gt;::infinity()
6759                              : std::numeric_limits&lt;double&gt;::quiet_NaN();
6760                          default:
6761                              return std::ldexp(mant + 1024, exp - 25);
6762                      }
6763                  }();
6764                  return sax-&gt;number_float((half &amp; 0x8000u) != 0
6765                                           ? static_cast&lt;number_float_t&gt;(-val)
6766                                           : static_cast&lt;number_float_t&gt;(val), &quot;&quot;);
6767              }
6768              case 0xFA: 
6769              {
6770                  float number{};
6771                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
6772              }
6773              case 0xFB: 
6774              {
6775                  double number{};
6776                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
6777              }
6778              default: 
6779              {
6780                  auto last_token = get_token_string();
6781                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, &quot;invalid byte: 0x&quot; + last_token, &quot;value&quot;), BasicJsonType()));
6782              }
6783          }
6784      }
6785      bool get_cbor_string(string_t&amp; result)
6786      {
6787          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, &quot;string&quot;)))
6788          {
6789              return false;
6790          }
6791          switch (current)
6792          {
6793              case 0x60:
6794              case 0x61:
6795              case 0x62:
6796              case 0x63:
6797              case 0x64:
6798              case 0x65:
6799              case 0x66:
6800              case 0x67:
6801              case 0x68:
6802              case 0x69:
6803              case 0x6A:
6804              case 0x6B:
6805              case 0x6C:
6806              case 0x6D:
6807              case 0x6E:
6808              case 0x6F:
6809              case 0x70:
6810              case 0x71:
6811              case 0x72:
6812              case 0x73:
6813              case 0x74:
6814              case 0x75:
6815              case 0x76:
6816              case 0x77:
6817              {
6818                  return get_string(input_format_t::cbor, static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu, result);
6819              }
6820              case 0x78: 
6821              {
6822                  std::uint8_t len{};
6823                  return get_number(input_format_t::cbor, len) &amp;&amp; get_string(input_format_t::cbor, len, result);
6824              }
6825              case 0x79: 
6826              {
6827                  std::uint16_t len{};
6828                  return get_number(input_format_t::cbor, len) &amp;&amp; get_string(input_format_t::cbor, len, result);
6829              }
6830              case 0x7A: 
6831              {
6832                  std::uint32_t len{};
6833                  return get_number(input_format_t::cbor, len) &amp;&amp; get_string(input_format_t::cbor, len, result);
6834              }
6835              case 0x7B: 
6836              {
6837                  std::uint64_t len{};
6838                  return get_number(input_format_t::cbor, len) &amp;&amp; get_string(input_format_t::cbor, len, result);
6839              }
6840              case 0x7F: 
6841              {
6842                  while (get() != 0xFF)
6843                  {
6844                      string_t chunk;
6845                      if (!get_cbor_string(chunk))
6846                      {
6847                          return false;
6848                      }
6849                      result.append(chunk);
6850                  }
6851                  return true;
6852              }
6853              default:
6854              {
6855                  auto last_token = get_token_string();
6856                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, &quot;expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x&quot; + last_token, &quot;string&quot;), BasicJsonType()));
6857              }
6858          }
6859      }
6860      bool get_cbor_binary(binary_t&amp; result)
6861      {
6862          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, &quot;binary&quot;)))
6863          {
6864              return false;
6865          }
6866          switch (current)
6867          {
6868              case 0x40:
6869              case 0x41:
6870              case 0x42:
6871              case 0x43:
6872              case 0x44:
6873              case 0x45:
6874              case 0x46:
6875              case 0x47:
6876              case 0x48:
6877              case 0x49:
6878              case 0x4A:
6879              case 0x4B:
6880              case 0x4C:
6881              case 0x4D:
6882              case 0x4E:
6883              case 0x4F:
6884              case 0x50:
6885              case 0x51:
6886              case 0x52:
6887              case 0x53:
6888              case 0x54:
6889              case 0x55:
6890              case 0x56:
6891              case 0x57:
6892              {
6893                  return get_binary(input_format_t::cbor, static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu, result);
6894              }
6895              case 0x58: 
6896              {
6897                  std::uint8_t len{};
6898                  return get_number(input_format_t::cbor, len) &amp;&amp;
6899                         get_binary(input_format_t::cbor, len, result);
6900              }
6901              case 0x59: 
6902              {
6903                  std::uint16_t len{};
6904                  return get_number(input_format_t::cbor, len) &amp;&amp;
6905                         get_binary(input_format_t::cbor, len, result);
6906              }
6907              case 0x5A: 
6908              {
6909                  std::uint32_t len{};
6910                  return get_number(input_format_t::cbor, len) &amp;&amp;
6911                         get_binary(input_format_t::cbor, len, result);
6912              }
6913              case 0x5B: 
6914              {
6915                  std::uint64_t len{};
6916                  return get_number(input_format_t::cbor, len) &amp;&amp;
6917                         get_binary(input_format_t::cbor, len, result);
6918              }
6919              case 0x5F: 
6920              {
6921                  while (get() != 0xFF)
6922                  {
6923                      binary_t chunk;
6924                      if (!get_cbor_binary(chunk))
6925                      {
6926                          return false;
6927                      }
6928                      result.insert(result.end(), chunk.begin(), chunk.end());
6929                  }
6930                  return true;
6931              }
6932              default:
6933              {
6934                  auto last_token = get_token_string();
6935                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, &quot;expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x&quot; + last_token, &quot;binary&quot;), BasicJsonType()));
6936              }
6937          }
6938      }
6939      bool get_cbor_array(const std::size_t len,
6940                          const cbor_tag_handler_t tag_handler)
6941      {
6942          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(len)))
6943          {
6944              return false;
6945          }
6946          if (len != std::size_t(-1))
6947          {
6948              for (std::size_t i = 0; i &lt; len; ++i)
6949              {
6950                  if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
6951                  {
6952                      return false;
6953                  }
6954              }
6955          }
6956          else
6957          {
6958              while (get() != 0xFF)
6959              {
6960                  if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
6961                  {
6962                      return false;
6963                  }
6964              }
6965          }
6966          return sax-&gt;end_array();
6967      }
6968      bool get_cbor_object(const std::size_t len,
6969                           const cbor_tag_handler_t tag_handler)
6970      {
6971          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(len)))
6972          {
6973              return false;
6974          }
6975          if (len != 0)
6976          {
6977              string_t key;
6978              if (len != std::size_t(-1))
6979              {
6980                  for (std::size_t i = 0; i &lt; len; ++i)
6981                  {
6982                      get();
6983                      if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax-&gt;key(key)))
6984                      {
6985                          return false;
6986                      }
6987                      if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
6988                      {
6989                          return false;
6990                      }
6991                      key.clear();
6992                  }
6993              }
6994              else
6995              {
6996                  while (get() != 0xFF)
6997                  {
6998                      if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax-&gt;key(key)))
6999                      {
7000                          return false;
7001                      }
7002                      if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
7003                      {
7004                          return false;
7005                      }
7006                      key.clear();
7007                  }
7008              }
7009          }
7010          return sax-&gt;end_object();
7011      }
7012      bool parse_msgpack_internal()
7013      {
7014          switch (get())
7015          {
7016              case std::char_traits&lt;char_type&gt;::eof():
7017                  return unexpect_eof(input_format_t::msgpack, &quot;value&quot;);
7018              case 0x00:
7019              case 0x01:
7020              case 0x02:
7021              case 0x03:
7022              case 0x04:
7023              case 0x05:
7024              case 0x06:
7025              case 0x07:
7026              case 0x08:
7027              case 0x09:
7028              case 0x0A:
7029              case 0x0B:
7030              case 0x0C:
7031              case 0x0D:
7032              case 0x0E:
7033              case 0x0F:
7034              case 0x10:
7035              case 0x11:
7036              case 0x12:
7037              case 0x13:
7038              case 0x14:
7039              case 0x15:
7040              case 0x16:
7041              case 0x17:
7042              case 0x18:
7043              case 0x19:
7044              case 0x1A:
7045              case 0x1B:
7046              case 0x1C:
7047              case 0x1D:
7048              case 0x1E:
7049              case 0x1F:
7050              case 0x20:
7051              case 0x21:
7052              case 0x22:
7053              case 0x23:
7054              case 0x24:
7055              case 0x25:
7056              case 0x26:
7057              case 0x27:
7058              case 0x28:
7059              case 0x29:
7060              case 0x2A:
7061              case 0x2B:
7062              case 0x2C:
7063              case 0x2D:
7064              case 0x2E:
7065              case 0x2F:
7066              case 0x30:
7067              case 0x31:
7068              case 0x32:
7069              case 0x33:
7070              case 0x34:
7071              case 0x35:
7072              case 0x36:
7073              case 0x37:
7074              case 0x38:
7075              case 0x39:
7076              case 0x3A:
7077              case 0x3B:
7078              case 0x3C:
7079              case 0x3D:
7080              case 0x3E:
7081              case 0x3F:
7082              case 0x40:
7083              case 0x41:
7084              case 0x42:
7085              case 0x43:
7086              case 0x44:
7087              case 0x45:
7088              case 0x46:
7089              case 0x47:
7090              case 0x48:
7091              case 0x49:
7092              case 0x4A:
7093              case 0x4B:
7094              case 0x4C:
7095              case 0x4D:
7096              case 0x4E:
7097              case 0x4F:
7098              case 0x50:
7099              case 0x51:
7100              case 0x52:
7101              case 0x53:
7102              case 0x54:
7103              case 0x55:
7104              case 0x56:
7105              case 0x57:
7106              case 0x58:
7107              case 0x59:
7108              case 0x5A:
7109              case 0x5B:
7110              case 0x5C:
7111              case 0x5D:
7112              case 0x5E:
7113              case 0x5F:
7114              case 0x60:
7115              case 0x61:
7116              case 0x62:
7117              case 0x63:
7118              case 0x64:
7119              case 0x65:
7120              case 0x66:
7121              case 0x67:
7122              case 0x68:
7123              case 0x69:
7124              case 0x6A:
7125              case 0x6B:
7126              case 0x6C:
7127              case 0x6D:
7128              case 0x6E:
7129              case 0x6F:
7130              case 0x70:
7131              case 0x71:
7132              case 0x72:
7133              case 0x73:
7134              case 0x74:
7135              case 0x75:
7136              case 0x76:
7137              case 0x77:
7138              case 0x78:
7139              case 0x79:
7140              case 0x7A:
7141              case 0x7B:
7142              case 0x7C:
7143              case 0x7D:
7144              case 0x7E:
7145              case 0x7F:
7146                  return sax-&gt;number_unsigned(static_cast&lt;number_unsigned_t&gt;(current));
7147              case 0x80:
7148              case 0x81:
7149              case 0x82:
7150              case 0x83:
7151              case 0x84:
7152              case 0x85:
7153              case 0x86:
7154              case 0x87:
7155              case 0x88:
7156              case 0x89:
7157              case 0x8A:
7158              case 0x8B:
7159              case 0x8C:
7160              case 0x8D:
7161              case 0x8E:
7162              case 0x8F:
7163                  return get_msgpack_object(static_cast&lt;std::size_t&gt;(static_cast&lt;unsigned int&gt;(current) &amp; 0x0Fu));
7164              case 0x90:
7165              case 0x91:
7166              case 0x92:
7167              case 0x93:
7168              case 0x94:
7169              case 0x95:
7170              case 0x96:
7171              case 0x97:
7172              case 0x98:
7173              case 0x99:
7174              case 0x9A:
7175              case 0x9B:
7176              case 0x9C:
7177              case 0x9D:
7178              case 0x9E:
7179              case 0x9F:
7180                  return get_msgpack_array(static_cast&lt;std::size_t&gt;(static_cast&lt;unsigned int&gt;(current) &amp; 0x0Fu));
7181              case 0xA0:
7182              case 0xA1:
7183              case 0xA2:
7184              case 0xA3:
7185              case 0xA4:
7186              case 0xA5:
7187              case 0xA6:
7188              case 0xA7:
7189              case 0xA8:
7190              case 0xA9:
7191              case 0xAA:
7192              case 0xAB:
7193              case 0xAC:
7194              case 0xAD:
7195              case 0xAE:
7196              case 0xAF:
7197              case 0xB0:
7198              case 0xB1:
7199              case 0xB2:
7200              case 0xB3:
7201              case 0xB4:
7202              case 0xB5:
7203              case 0xB6:
7204              case 0xB7:
7205              case 0xB8:
7206              case 0xB9:
7207              case 0xBA:
7208              case 0xBB:
7209              case 0xBC:
7210              case 0xBD:
7211              case 0xBE:
7212              case 0xBF:
7213              case 0xD9: 
7214              case 0xDA: 
7215              case 0xDB: 
7216              {
7217                  string_t s;
7218                  return get_msgpack_string(s) &amp;&amp; sax-&gt;string(s);
7219              }
7220              case 0xC0: 
7221                  return sax-&gt;null();
7222              case 0xC2: 
7223                  return sax-&gt;boolean(false);
7224              case 0xC3: 
7225                  return sax-&gt;boolean(true);
7226              case 0xC4: 
7227              case 0xC5: 
7228              case 0xC6: 
7229              case 0xC7: 
7230              case 0xC8: 
7231              case 0xC9: 
7232              case 0xD4: 
7233              case 0xD5: 
7234              case 0xD6: 
7235              case 0xD7: 
7236              case 0xD8: 
7237              {
7238                  binary_t b;
7239                  return get_msgpack_binary(b) &amp;&amp; sax-&gt;binary(b);
7240              }
7241              case 0xCA: 
7242              {
7243                  float number{};
7244                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
7245              }
7246              case 0xCB: 
7247              {
7248                  double number{};
7249                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
7250              }
7251              case 0xCC: 
7252              {
7253                  std::uint8_t number{};
7254                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_unsigned(number);
7255              }
7256              case 0xCD: 
7257              {
7258                  std::uint16_t number{};
7259                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_unsigned(number);
7260              }
7261              case 0xCE: 
7262              {
7263                  std::uint32_t number{};
7264                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_unsigned(number);
7265              }
7266              case 0xCF: 
7267              {
7268                  std::uint64_t number{};
7269                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_unsigned(number);
7270              }
7271              case 0xD0: 
7272              {
7273                  std::int8_t number{};
7274                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_integer(number);
7275              }
7276              case 0xD1: 
7277              {
7278                  std::int16_t number{};
7279                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_integer(number);
7280              }
7281              case 0xD2: 
7282              {
7283                  std::int32_t number{};
7284                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_integer(number);
7285              }
7286              case 0xD3: 
7287              {
7288                  std::int64_t number{};
7289                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_integer(number);
7290              }
7291              case 0xDC: 
7292              {
7293                  std::uint16_t len{};
7294                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_msgpack_array(static_cast&lt;std::size_t&gt;(len));
7295              }
7296              case 0xDD: 
7297              {
7298                  std::uint32_t len{};
7299                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_msgpack_array(static_cast&lt;std::size_t&gt;(len));
7300              }
7301              case 0xDE: 
7302              {
7303                  std::uint16_t len{};
7304                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_msgpack_object(static_cast&lt;std::size_t&gt;(len));
7305              }
7306              case 0xDF: 
7307              {
7308                  std::uint32_t len{};
7309                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_msgpack_object(static_cast&lt;std::size_t&gt;(len));
7310              }
7311              case 0xE0:
7312              case 0xE1:
7313              case 0xE2:
7314              case 0xE3:
7315              case 0xE4:
7316              case 0xE5:
7317              case 0xE6:
7318              case 0xE7:
7319              case 0xE8:
7320              case 0xE9:
7321              case 0xEA:
7322              case 0xEB:
7323              case 0xEC:
7324              case 0xED:
7325              case 0xEE:
7326              case 0xEF:
7327              case 0xF0:
7328              case 0xF1:
7329              case 0xF2:
7330              case 0xF3:
7331              case 0xF4:
7332              case 0xF5:
7333              case 0xF6:
7334              case 0xF7:
7335              case 0xF8:
7336              case 0xF9:
7337              case 0xFA:
7338              case 0xFB:
7339              case 0xFC:
7340              case 0xFD:
7341              case 0xFE:
7342              case 0xFF:
7343                  return sax-&gt;number_integer(static_cast&lt;std::int8_t&gt;(current));
7344              default: 
7345              {
7346                  auto last_token = get_token_string();
7347                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::msgpack, &quot;invalid byte: 0x&quot; + last_token, &quot;value&quot;), BasicJsonType()));
7348              }
7349          }
7350      }
7351      bool get_msgpack_string(string_t&amp; result)
7352      {
7353          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, &quot;string&quot;)))
7354          {
7355              return false;
7356          }
7357          switch (current)
7358          {
7359              case 0xA0:
7360              case 0xA1:
7361              case 0xA2:
7362              case 0xA3:
7363              case 0xA4:
7364              case 0xA5:
7365              case 0xA6:
7366              case 0xA7:
7367              case 0xA8:
7368              case 0xA9:
7369              case 0xAA:
7370              case 0xAB:
7371              case 0xAC:
7372              case 0xAD:
7373              case 0xAE:
7374              case 0xAF:
7375              case 0xB0:
7376              case 0xB1:
7377              case 0xB2:
7378              case 0xB3:
7379              case 0xB4:
7380              case 0xB5:
7381              case 0xB6:
7382              case 0xB7:
7383              case 0xB8:
7384              case 0xB9:
7385              case 0xBA:
7386              case 0xBB:
7387              case 0xBC:
7388              case 0xBD:
7389              case 0xBE:
7390              case 0xBF:
7391              {
7392                  return get_string(input_format_t::msgpack, static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu, result);
7393              }
7394              case 0xD9: 
7395              {
7396                  std::uint8_t len{};
7397                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_string(input_format_t::msgpack, len, result);
7398              }
7399              case 0xDA: 
7400              {
7401                  std::uint16_t len{};
7402                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_string(input_format_t::msgpack, len, result);
7403              }
7404              case 0xDB: 
7405              {
7406                  std::uint32_t len{};
7407                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_string(input_format_t::msgpack, len, result);
7408              }
7409              default:
7410              {
7411                  auto last_token = get_token_string();
7412                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::msgpack, &quot;expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x&quot; + last_token, &quot;string&quot;), BasicJsonType()));
7413              }
7414          }
7415      }
7416      bool get_msgpack_binary(binary_t&amp; result)
7417      {
7418          auto assign_and_return_true = [&amp;result](std::int8_t subtype)
7419          {
7420              result.set_subtype(static_cast&lt;std::uint8_t&gt;(subtype));
7421              return true;
7422          };
7423          switch (current)
7424          {
7425              case 0xC4: 
7426              {
7427                  std::uint8_t len{};
7428                  return get_number(input_format_t::msgpack, len) &amp;&amp;
7429                         get_binary(input_format_t::msgpack, len, result);
7430              }
7431              case 0xC5: 
7432              {
7433                  std::uint16_t len{};
7434                  return get_number(input_format_t::msgpack, len) &amp;&amp;
7435                         get_binary(input_format_t::msgpack, len, result);
7436              }
7437              case 0xC6: 
7438              {
7439                  std::uint32_t len{};
7440                  return get_number(input_format_t::msgpack, len) &amp;&amp;
7441                         get_binary(input_format_t::msgpack, len, result);
7442              }
7443              case 0xC7: 
7444              {
7445                  std::uint8_t len{};
7446                  std::int8_t subtype{};
7447                  return get_number(input_format_t::msgpack, len) &amp;&amp;
7448                         get_number(input_format_t::msgpack, subtype) &amp;&amp;
7449                         get_binary(input_format_t::msgpack, len, result) &amp;&amp;
7450                         assign_and_return_true(subtype);
7451              }
7452              case 0xC8: 
7453              {
7454                  std::uint16_t len{};
7455                  std::int8_t subtype{};
7456                  return get_number(input_format_t::msgpack, len) &amp;&amp;
7457                         get_number(input_format_t::msgpack, subtype) &amp;&amp;
7458                         get_binary(input_format_t::msgpack, len, result) &amp;&amp;
7459                         assign_and_return_true(subtype);
7460              }
7461              case 0xC9: 
7462              {
7463                  std::uint32_t len{};
7464                  std::int8_t subtype{};
7465                  return get_number(input_format_t::msgpack, len) &amp;&amp;
7466                         get_number(input_format_t::msgpack, subtype) &amp;&amp;
7467                         get_binary(input_format_t::msgpack, len, result) &amp;&amp;
7468                         assign_and_return_true(subtype);
7469              }
7470              case 0xD4: 
7471              {
7472                  std::int8_t subtype{};
7473                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
7474                         get_binary(input_format_t::msgpack, 1, result) &amp;&amp;
7475                         assign_and_return_true(subtype);
7476              }
7477              case 0xD5: 
7478              {
7479                  std::int8_t subtype{};
7480                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
7481                         get_binary(input_format_t::msgpack, 2, result) &amp;&amp;
7482                         assign_and_return_true(subtype);
7483              }
7484              case 0xD6: 
7485              {
7486                  std::int8_t subtype{};
7487                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
7488                         get_binary(input_format_t::msgpack, 4, result) &amp;&amp;
7489                         assign_and_return_true(subtype);
7490              }
7491              case 0xD7: 
7492              {
7493                  std::int8_t subtype{};
7494                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
7495                         get_binary(input_format_t::msgpack, 8, result) &amp;&amp;
7496                         assign_and_return_true(subtype);
7497              }
7498              case 0xD8: 
7499              {
7500                  std::int8_t subtype{};
7501                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
7502                         get_binary(input_format_t::msgpack, 16, result) &amp;&amp;
7503                         assign_and_return_true(subtype);
7504              }
7505              default:           
7506                  return false;  
7507          }
7508      }
7509      bool get_msgpack_array(const std::size_t len)
7510      {
7511          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(len)))
7512          {
7513              return false;
7514          }
7515          for (std::size_t i = 0; i &lt; len; ++i)
7516          {
7517              if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
7518              {
7519                  return false;
7520              }
7521          }
7522          return sax-&gt;end_array();
7523      }
7524      bool get_msgpack_object(const std::size_t len)
7525      {
7526          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(len)))
7527          {
7528              return false;
7529          }
7530          string_t key;
7531          for (std::size_t i = 0; i &lt; len; ++i)
7532          {
7533              get();
7534              if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax-&gt;key(key)))
7535              {
7536                  return false;
7537              }
7538              if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
7539              {
7540                  return false;
7541              }
7542              key.clear();
7543          }
7544          return sax-&gt;end_object();
7545      }
7546      bool parse_ubjson_internal(const bool get_char = true)
7547      {
7548          return get_ubjson_value(get_char ? get_ignore_noop() : current);
7549      }
7550      bool get_ubjson_string(string_t&amp; result, const bool get_char = true)
7551      {
7552          if (get_char)
7553          {
7554              get();  
7555          }
7556          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, &quot;value&quot;)))
7557          {
7558              return false;
7559          }
7560          switch (current)
7561          {
7562              case &#x27;U&#x27;:
7563              {
7564                  std::uint8_t len{};
7565                  return get_number(input_format_t::ubjson, len) &amp;&amp; get_string(input_format_t::ubjson, len, result);
7566              }
7567              case &#x27;i&#x27;:
7568              {
7569                  std::int8_t len{};
7570                  return get_number(input_format_t::ubjson, len) &amp;&amp; get_string(input_format_t::ubjson, len, result);
7571              }
7572              case &#x27;I&#x27;:
7573              {
7574                  std::int16_t len{};
7575                  return get_number(input_format_t::ubjson, len) &amp;&amp; get_string(input_format_t::ubjson, len, result);
7576              }
7577              case &#x27;l&#x27;:
7578              {
7579                  std::int32_t len{};
7580                  return get_number(input_format_t::ubjson, len) &amp;&amp; get_string(input_format_t::ubjson, len, result);
7581              }
7582              case &#x27;L&#x27;:
7583              {
7584                  std::int64_t len{};
7585                  return get_number(input_format_t::ubjson, len) &amp;&amp; get_string(input_format_t::ubjson, len, result);
7586              }
7587              default:
7588                  auto last_token = get_token_string();
7589                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, &quot;expected length type specification (U, i, I, l, L); last byte: 0x&quot; + last_token, &quot;string&quot;), BasicJsonType()));
7590          }
7591      }
7592      bool get_ubjson_size_value(std::size_t&amp; result)
7593      {
7594          switch (get_ignore_noop())
7595          {
7596              case &#x27;U&#x27;:
7597              {
7598                  std::uint8_t number{};
7599                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7600                  {
7601                      return false;
7602                  }
7603                  result = static_cast&lt;std::size_t&gt;(number);
7604                  return true;
7605              }
7606              case &#x27;i&#x27;:
7607              {
7608                  std::int8_t number{};
7609                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7610                  {
7611                      return false;
7612                  }
7613                  result = static_cast&lt;std::size_t&gt;(number); 
7614                  return true;
7615              }
7616              case &#x27;I&#x27;:
7617              {
7618                  std::int16_t number{};
7619                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7620                  {
7621                      return false;
7622                  }
7623                  result = static_cast&lt;std::size_t&gt;(number);
7624                  return true;
7625              }
7626              case &#x27;l&#x27;:
7627              {
7628                  std::int32_t number{};
7629                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7630                  {
7631                      return false;
7632                  }
7633                  result = static_cast&lt;std::size_t&gt;(number);
7634                  return true;
7635              }
7636              case &#x27;L&#x27;:
7637              {
7638                  std::int64_t number{};
7639                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7640                  {
7641                      return false;
7642                  }
7643                  result = static_cast&lt;std::size_t&gt;(number);
7644                  return true;
7645              }
7646              default:
7647              {
7648                  auto last_token = get_token_string();
7649                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, &quot;expected length type specification (U, i, I, l, L) after &#x27;#&#x27;; last byte: 0x&quot; + last_token, &quot;size&quot;), BasicJsonType()));
7650              }
7651          }
7652      }
7653      bool get_ubjson_size_type(std::pair&lt;std::size_t, char_int_type&gt;&amp; result)
7654      {
7655          result.first = string_t::npos; 
7656          result.second = 0; 
7657          get_ignore_noop();
7658          if (current == &#x27;$&#x27;)
7659          {
7660              result.second = get();  
7661              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, &quot;type&quot;)))
7662              {
7663                  return false;
7664              }
7665              get_ignore_noop();
7666              if (JSON_HEDLEY_UNLIKELY(current != &#x27;#&#x27;))
7667              {
7668                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, &quot;value&quot;)))
7669                  {
7670                      return false;
7671                  }
7672                  auto last_token = get_token_string();
7673                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, &quot;expected &#x27;#&#x27; after type information; last byte: 0x&quot; + last_token, &quot;size&quot;), BasicJsonType()));
7674              }
7675              return get_ubjson_size_value(result.first);
7676          }
7677          if (current == &#x27;#&#x27;)
7678          {
7679              return get_ubjson_size_value(result.first);
7680          }
7681          return true;
7682      }
7683      bool get_ubjson_value(const char_int_type prefix)
7684      {
7685          switch (prefix)
7686          {
7687              case std::char_traits&lt;char_type&gt;::eof():  
7688                  return unexpect_eof(input_format_t::ubjson, &quot;value&quot;);
7689              case &#x27;T&#x27;:  
7690                  return sax-&gt;boolean(true);
7691              case &#x27;F&#x27;:  
7692                  return sax-&gt;boolean(false);
7693              case &#x27;Z&#x27;:  
7694                  return sax-&gt;null();
7695              case &#x27;U&#x27;:
7696              {
7697                  std::uint8_t number{};
7698                  return get_number(input_format_t::ubjson, number) &amp;&amp; sax-&gt;number_unsigned(number);
7699              }
7700              case &#x27;i&#x27;:
7701              {
7702                  std::int8_t number{};
7703                  return get_number(input_format_t::ubjson, number) &amp;&amp; sax-&gt;number_integer(number);
7704              }
7705              case &#x27;I&#x27;:
7706              {
7707                  std::int16_t number{};
7708                  return get_number(input_format_t::ubjson, number) &amp;&amp; sax-&gt;number_integer(number);
7709              }
7710              case &#x27;l&#x27;:
7711              {
7712                  std::int32_t number{};
7713                  return get_number(input_format_t::ubjson, number) &amp;&amp; sax-&gt;number_integer(number);
7714              }
7715              case &#x27;L&#x27;:
7716              {
7717                  std::int64_t number{};
7718                  return get_number(input_format_t::ubjson, number) &amp;&amp; sax-&gt;number_integer(number);
7719              }
7720              case &#x27;d&#x27;:
7721              {
7722                  float number{};
7723                  return get_number(input_format_t::ubjson, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
7724              }
7725              case &#x27;D&#x27;:
7726              {
7727                  double number{};
7728                  return get_number(input_format_t::ubjson, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
7729              }
7730              case &#x27;H&#x27;:
7731              {
7732                  return get_ubjson_high_precision_number();
7733              }
7734              case &#x27;C&#x27;:  
7735              {
7736                  get();
7737                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, &quot;char&quot;)))
7738                  {
7739                      return false;
7740                  }
7741                  if (JSON_HEDLEY_UNLIKELY(current &gt; 127))
7742                  {
7743                      auto last_token = get_token_string();
7744                      return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, &quot;byte after &#x27;C&#x27; must be in range 0x00..0x7F; last byte: 0x&quot; + last_token, &quot;char&quot;), BasicJsonType()));
7745                  }
7746                  string_t s(1, static_cast&lt;typename string_t::value_type&gt;(current));
7747                  return sax-&gt;string(s);
7748              }
7749              case &#x27;S&#x27;:  
7750              {
7751                  string_t s;
7752                  return get_ubjson_string(s) &amp;&amp; sax-&gt;string(s);
7753              }
7754              case &#x27;[&#x27;:  
7755                  return get_ubjson_array();
7756              case &#x27;{&#x27;:  
7757                  return get_ubjson_object();
7758              default: 
7759              {
7760                  auto last_token = get_token_string();
7761                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, &quot;invalid byte: 0x&quot; + last_token, &quot;value&quot;), BasicJsonType()));
7762              }
7763          }
7764      }
7765      bool get_ubjson_array()
7766      {
7767          std::pair&lt;std::size_t, char_int_type&gt; size_and_type;
7768          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
7769          {
7770              return false;
7771          }
7772          if (size_and_type.first != string_t::npos)
7773          {
7774              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(size_and_type.first)))
7775              {
7776                  return false;
7777              }
7778              if (size_and_type.second != 0)
7779              {
7780                  if (size_and_type.second != &#x27;N&#x27;)
7781                  {
7782                      for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
7783                      {
7784                          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
7785                          {
7786                              return false;
7787                          }
7788                      }
7789                  }
7790              }
7791              else
7792              {
7793                  for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
7794                  {
7795                      if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
7796                      {
7797                          return false;
7798                      }
7799                  }
7800              }
7801          }
7802          else
7803          {
7804              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(std::size_t(-1))))
7805              {
7806                  return false;
7807              }
7808              while (current != &#x27;]&#x27;)
7809              {
7810                  if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
7811                  {
7812                      return false;
7813                  }
7814                  get_ignore_noop();
7815              }
7816          }
7817          return sax-&gt;end_array();
7818      }
7819      bool get_ubjson_object()
7820      {
7821          std::pair&lt;std::size_t, char_int_type&gt; size_and_type;
7822          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
7823          {
7824              return false;
7825          }
7826          string_t key;
7827          if (size_and_type.first != string_t::npos)
7828          {
7829              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(size_and_type.first)))
7830              {
7831                  return false;
7832              }
7833              if (size_and_type.second != 0)
7834              {
7835                  for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
7836                  {
7837                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax-&gt;key(key)))
7838                      {
7839                          return false;
7840                      }
7841                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
7842                      {
7843                          return false;
7844                      }
7845                      key.clear();
7846                  }
7847              }
7848              else
7849              {
7850                  for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
7851                  {
7852                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax-&gt;key(key)))
7853                      {
7854                          return false;
7855                      }
7856                      if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
7857                      {
7858                          return false;
7859                      }
7860                      key.clear();
7861                  }
7862              }
7863          }
7864          else
7865          {
7866              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(std::size_t(-1))))
7867              {
7868                  return false;
7869              }
7870              while (current != &#x27;}&#x27;)
7871              {
7872                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax-&gt;key(key)))
7873                  {
7874                      return false;
7875                  }
7876                  if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
7877                  {
7878                      return false;
7879                  }
7880                  get_ignore_noop();
7881                  key.clear();
7882              }
7883          }
7884          return sax-&gt;end_object();
7885      }
7886      bool get_ubjson_high_precision_number()
7887      {
7888          std::size_t size{};
7889          auto res = get_ubjson_size_value(size);
7890          if (JSON_HEDLEY_UNLIKELY(!res))
7891          {
7892              return res;
7893          }
7894          std::vector&lt;char&gt; number_vector;
7895          for (std::size_t i = 0; i &lt; size; ++i)
7896          {
7897              get();
7898              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, &quot;number&quot;)))
7899              {
7900                  return false;
7901              }
7902              number_vector.push_back(static_cast&lt;char&gt;(current));
7903          }
7904          using ia_type = decltype(detail::input_adapter(number_vector));
7905          auto number_lexer = detail::lexer&lt;BasicJsonType, ia_type&gt;(detail::input_adapter(number_vector), false);
7906          const auto result_number = number_lexer.scan();
7907          const auto number_string = number_lexer.get_token_string();
7908          const auto result_remainder = number_lexer.scan();
7909          using token_type = typename detail::lexer_base&lt;BasicJsonType&gt;::token_type;
7910          if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
7911          {
7912              return sax-&gt;parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, &quot;invalid number text: &quot; + number_lexer.get_token_string(), &quot;high-precision number&quot;), BasicJsonType()));
7913          }
7914          switch (result_number)
7915          {
7916              case token_type::value_integer:
7917                  return sax-&gt;number_integer(number_lexer.get_number_integer());
7918              case token_type::value_unsigned:
7919                  return sax-&gt;number_unsigned(number_lexer.get_number_unsigned());
7920              case token_type::value_float:
7921                  return sax-&gt;number_float(number_lexer.get_number_float(), std::move(number_string));
7922              case token_type::uninitialized:
7923              case token_type::literal_true:
7924              case token_type::literal_false:
7925              case token_type::literal_null:
7926              case token_type::value_string:
7927              case token_type::begin_array:
7928              case token_type::begin_object:
7929              case token_type::end_array:
7930              case token_type::end_object:
7931              case token_type::name_separator:
7932              case token_type::value_separator:
7933              case token_type::parse_error:
7934              case token_type::end_of_input:
7935              case token_type::literal_or_value:
7936              default:
7937                  return sax-&gt;parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, &quot;invalid number text: &quot; + number_lexer.get_token_string(), &quot;high-precision number&quot;), BasicJsonType()));
7938          }
7939      }
7940      char_int_type get()
7941      {
7942          ++chars_read;
7943          return current = ia.get_character();
7944      }
7945      char_int_type get_ignore_noop()
7946      {
7947          do
7948          {
7949              get();
7950          }
7951          while (current == &#x27;N&#x27;);
7952          return current;
7953      }
7954      template&lt;typename NumberType, bool InputIsLittleEndian = false&gt;
7955      bool get_number(const input_format_t format, NumberType&amp; result)
7956      {
7957          std::array&lt;std::uint8_t, sizeof(NumberType)&gt; vec{};
7958          for (std::size_t i = 0; i &lt; sizeof(NumberType); ++i)
7959          {
7960              get();
7961              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, &quot;number&quot;)))
7962              {
7963                  return false;
7964              }
7965              if (is_little_endian != InputIsLittleEndian)
7966              {
7967                  vec[sizeof(NumberType) - i - 1] = static_cast&lt;std::uint8_t&gt;(current);
7968              }
7969              else
7970              {
7971                  vec[i] = static_cast&lt;std::uint8_t&gt;(current); 
7972              }
7973          }
7974          std::memcpy(&amp;result, vec.data(), sizeof(NumberType));
7975          return true;
7976      }
7977      template&lt;typename NumberType&gt;
7978      bool get_string(const input_format_t format,
7979                      const NumberType len,
7980                      string_t&amp; result)
7981      {
7982          bool success = true;
7983          for (NumberType i = 0; i &lt; len; i++)
7984          {
7985              get();
7986              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, &quot;string&quot;)))
7987              {
7988                  success = false;
7989                  break;
7990              }
7991              result.push_back(static_cast&lt;typename string_t::value_type&gt;(current));
7992          }
7993          return success;
7994      }
7995      template&lt;typename NumberType&gt;
7996      bool get_binary(const input_format_t format,
7997                      const NumberType len,
7998                      binary_t&amp; result)
7999      {
8000          bool success = true;
8001          for (NumberType i = 0; i &lt; len; i++)
8002          {
8003              get();
8004              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, &quot;binary&quot;)))
8005              {
8006                  success = false;
8007                  break;
8008              }
8009              result.push_back(static_cast&lt;std::uint8_t&gt;(current));
8010          }
8011          return success;
8012      }
8013      JSON_HEDLEY_NON_NULL(3)
8014      bool unexpect_eof(const input_format_t format, const char* context) const
8015      {
8016          if (JSON_HEDLEY_UNLIKELY(current == std::char_traits&lt;char_type&gt;::eof()))
8017          {
8018              return sax-&gt;parse_error(chars_read, &quot;&lt;end of file&gt;&quot;,
8019                                      parse_error::create(110, chars_read, exception_message(format, &quot;unexpected end of input&quot;, context), BasicJsonType()));
8020          }
8021          return true;
8022      }
8023      std::string get_token_string() const
8024      {
8025          std::array&lt;char, 3&gt; cr{{}};
8026          (std::snprintf)(cr.data(), cr.size(), &quot;%.2hhX&quot;, static_cast&lt;unsigned char&gt;(current)); 
8027          return std::string{cr.data()};
8028      }
8029      std::string exception_message(const input_format_t format,
8030                                    const std::string&amp; detail,
8031                                    const std::string&amp; context) const
8032      {
8033          std::string error_msg = &quot;syntax error while parsing &quot;;
8034          switch (format)
8035          {
8036              case input_format_t::cbor:
8037                  error_msg += &quot;CBOR&quot;;
8038                  break;
8039              case input_format_t::msgpack:
8040                  error_msg += &quot;MessagePack&quot;;
8041                  break;
8042              case input_format_t::ubjson:
8043                  error_msg += &quot;UBJSON&quot;;
8044                  break;
8045              case input_format_t::bson:
8046                  error_msg += &quot;BSON&quot;;
8047                  break;
8048              case input_format_t::json: 
8049              default:            
8050                  JSON_ASSERT(false); 
8051          }
8052          return error_msg + &quot; &quot; + context + &quot;: &quot; + detail;
8053      }
8054    private:
8055      InputAdapterType ia;
8056      char_int_type current = std::char_traits&lt;char_type&gt;::eof();
8057      std::size_t chars_read = 0;
8058      const bool is_little_endian = little_endianess();
8059      json_sax_t* sax = nullptr;
8060  };
8061  }  
8062  }  
8063  #include &lt;cmath&gt; 
8064  #include &lt;cstdint&gt; 
8065  #include &lt;functional&gt; 
8066  #include &lt;string&gt; 
8067  #include &lt;utility&gt; 
8068  #include &lt;vector&gt; 
8069  namespace nlohmann
8070  {
8071  namespace detail
8072  {
8073  enum class parse_event_t : std::uint8_t
8074  {
8075      object_start,
8076      object_end,
8077      array_start,
8078      array_end,
8079      key,
8080      value
8081  };
8082  template&lt;typename BasicJsonType&gt;
8083  using parser_callback_t =
8084      std::function&lt;bool(int &amp;bsol;*depth*/, parse_event_t &amp;bsol;*event*/, BasicJsonType&amp; &amp;bsol;*parsed*/)&gt;;
8085  template&lt;typename BasicJsonType, typename InputAdapterType&gt;
8086  class parser
8087  {
8088      using number_integer_t = typename BasicJsonType::number_integer_t;
8089      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
8090      using number_float_t = typename BasicJsonType::number_float_t;
8091      using string_t = typename BasicJsonType::string_t;
8092      using lexer_t = lexer&lt;BasicJsonType, InputAdapterType&gt;;
8093      using token_type = typename lexer_t::token_type;
8094    public:
8095      explicit parser(InputAdapterType&amp;&amp; adapter,
8096                      const parser_callback_t&lt;BasicJsonType&gt; cb = nullptr,
8097                      const bool allow_exceptions_ = true,
8098                      const bool skip_comments = false)
8099          : callback(cb)
8100          , m_lexer(std::move(adapter), skip_comments)
8101          , allow_exceptions(allow_exceptions_)
8102      {
8103          get_token();
8104      }
8105      void parse(const bool strict, BasicJsonType&amp; result)
8106      {
8107          if (callback)
8108          {
8109              json_sax_dom_callback_parser&lt;BasicJsonType&gt; sdp(result, callback, allow_exceptions);
8110              sax_parse_internal(&amp;sdp);
8111              if (strict &amp;&amp; (get_token() != token_type::end_of_input))
8112              {
8113                  sdp.parse_error(m_lexer.get_position(),
8114                                  m_lexer.get_token_string(),
8115                                  parse_error::create(101, m_lexer.get_position(),
8116                                                      exception_message(token_type::end_of_input, &quot;value&quot;), BasicJsonType()));
8117              }
8118              if (sdp.is_errored())
8119              {
8120                  result = value_t::discarded;
8121                  return;
8122              }
8123              if (result.is_discarded())
8124              {
8125                  result = nullptr;
8126              }
8127          }
8128          else
8129          {
8130              json_sax_dom_parser&lt;BasicJsonType&gt; sdp(result, allow_exceptions);
8131              sax_parse_internal(&amp;sdp);
8132              if (strict &amp;&amp; (get_token() != token_type::end_of_input))
8133              {
8134                  sdp.parse_error(m_lexer.get_position(),
8135                                  m_lexer.get_token_string(),
8136                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, &quot;value&quot;), BasicJsonType()));
8137              }
8138              if (sdp.is_errored())
8139              {
8140                  result = value_t::discarded;
8141                  return;
8142              }
8143          }
8144          result.assert_invariant();
8145      }
8146      bool accept(const bool strict = true)
8147      {
8148          json_sax_acceptor&lt;BasicJsonType&gt; sax_acceptor;
8149          return sax_parse(&amp;sax_acceptor, strict);
8150      }
8151      template&lt;typename SAX&gt;
8152      JSON_HEDLEY_NON_NULL(2)
8153      bool sax_parse(SAX* sax, const bool strict = true)
8154      {
8155          (void)detail::is_sax_static_asserts&lt;SAX, BasicJsonType&gt; {};
8156          const bool result = sax_parse_internal(sax);
8157          if (result &amp;&amp; strict &amp;&amp; (get_token() != token_type::end_of_input))
8158          {
8159              return sax-&gt;parse_error(m_lexer.get_position(),
8160                                      m_lexer.get_token_string(),
8161                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, &quot;value&quot;), BasicJsonType()));
8162          }
8163          return result;
8164      }
8165    private:
8166      template&lt;typename SAX&gt;
8167      JSON_HEDLEY_NON_NULL(2)
8168      bool sax_parse_internal(SAX* sax)
8169      {
8170          std::vector&lt;bool&gt; states;
8171          bool skip_to_state_evaluation = false;
8172          while (true)
8173          {
8174              if (!skip_to_state_evaluation)
8175              {
8176                  switch (last_token)
8177                  {
8178                      case token_type::begin_object:
8179                      {
8180                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(std::size_t(-1))))
8181                          {
8182                              return false;
8183                          }
8184                          if (get_token() == token_type::end_object)
8185                          {
8186                              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_object()))
8187                              {
8188                                  return false;
8189                              }
8190                              break;
8191                          }
8192                          if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
8193                          {
8194                              return sax-&gt;parse_error(m_lexer.get_position(),
8195                                                      m_lexer.get_token_string(),
8196                                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, &quot;object key&quot;), BasicJsonType()));
8197                          }
8198                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;key(m_lexer.get_string())))
8199                          {
8200                              return false;
8201                          }
8202                          if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
8203                          {
8204                              return sax-&gt;parse_error(m_lexer.get_position(),
8205                                                      m_lexer.get_token_string(),
8206                                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, &quot;object separator&quot;), BasicJsonType()));
8207                          }
8208                          states.push_back(false);
8209                          get_token();
8210                          continue;
8211                      }
8212                      case token_type::begin_array:
8213                      {
8214                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(std::size_t(-1))))
8215                          {
8216                              return false;
8217                          }
8218                          if (get_token() == token_type::end_array)
8219                          {
8220                              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_array()))
8221                              {
8222                                  return false;
8223                              }
8224                              break;
8225                          }
8226                          states.push_back(true);
8227                          continue;
8228                      }
8229                      case token_type::value_float:
8230                      {
8231                          const auto res = m_lexer.get_number_float();
8232                          if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
8233                          {
8234                              return sax-&gt;parse_error(m_lexer.get_position(),
8235                                                      m_lexer.get_token_string(),
8236                                                      out_of_range::create(406, &quot;number overflow parsing &#x27;&quot; + m_lexer.get_token_string() + &quot;&#x27;&quot;, BasicJsonType()));
8237                          }
8238                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_float(res, m_lexer.get_string())))
8239                          {
8240                              return false;
8241                          }
8242                          break;
8243                      }
8244                      case token_type::literal_false:
8245                      {
8246                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;boolean(false)))
8247                          {
8248                              return false;
8249                          }
8250                          break;
8251                      }
8252                      case token_type::literal_null:
8253                      {
8254                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;null()))
8255                          {
8256                              return false;
8257                          }
8258                          break;
8259                      }
8260                      case token_type::literal_true:
8261                      {
8262                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;boolean(true)))
8263                          {
8264                              return false;
8265                          }
8266                          break;
8267                      }
8268                      case token_type::value_integer:
8269                      {
8270                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_integer(m_lexer.get_number_integer())))
8271                          {
8272                              return false;
8273                          }
8274                          break;
8275                      }
8276                      case token_type::value_string:
8277                      {
8278                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;string(m_lexer.get_string())))
8279                          {
8280                              return false;
8281                          }
8282                          break;
8283                      }
8284                      case token_type::value_unsigned:
8285                      {
8286                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_unsigned(m_lexer.get_number_unsigned())))
8287                          {
8288                              return false;
8289                          }
8290                          break;
8291                      }
8292                      case token_type::parse_error:
8293                      {
8294                          return sax-&gt;parse_error(m_lexer.get_position(),
8295                                                  m_lexer.get_token_string(),
8296                                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, &quot;value&quot;), BasicJsonType()));
8297                      }
8298                      case token_type::uninitialized:
8299                      case token_type::end_array:
8300                      case token_type::end_object:
8301                      case token_type::name_separator:
8302                      case token_type::value_separator:
8303                      case token_type::end_of_input:
8304                      case token_type::literal_or_value:
8305                      default: 
8306                      {
8307                          return sax-&gt;parse_error(m_lexer.get_position(),
8308                                                  m_lexer.get_token_string(),
8309                                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, &quot;value&quot;), BasicJsonType()));
8310                      }
8311                  }
8312              }
8313              else
8314              {
8315                  skip_to_state_evaluation = false;
8316              }
8317              if (states.empty())
8318              {
8319                  return true;
8320              }
8321              if (states.back())  
8322              {
8323                  if (get_token() == token_type::value_separator)
8324                  {
8325                      get_token();
8326                      continue;
8327                  }
8328                  if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
8329                  {
8330                      if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_array()))
8331                      {
8332                          return false;
8333                      }
8334                      JSON_ASSERT(!states.empty());
8335                      states.pop_back();
8336                      skip_to_state_evaluation = true;
8337                      continue;
8338                  }
8339                  return sax-&gt;parse_error(m_lexer.get_position(),
8340                                          m_lexer.get_token_string(),
8341                                          parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, &quot;array&quot;), BasicJsonType()));
8342              }
8343              if (get_token() == token_type::value_separator)
8344              {
8345                  if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
8346                  {
8347                      return sax-&gt;parse_error(m_lexer.get_position(),
8348                                              m_lexer.get_token_string(),
8349                                              parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, &quot;object key&quot;), BasicJsonType()));
8350                  }
8351                  if (JSON_HEDLEY_UNLIKELY(!sax-&gt;key(m_lexer.get_string())))
8352                  {
8353                      return false;
8354                  }
8355                  if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
8356                  {
8357                      return sax-&gt;parse_error(m_lexer.get_position(),
8358                                              m_lexer.get_token_string(),
8359                                              parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, &quot;object separator&quot;), BasicJsonType()));
8360                  }
8361                  get_token();
8362                  continue;
8363              }
8364              if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
8365              {
8366                  if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_object()))
8367                  {
8368                      return false;
8369                  }
8370                  JSON_ASSERT(!states.empty());
8371                  states.pop_back();
8372                  skip_to_state_evaluation = true;
8373                  continue;
8374              }
8375              return sax-&gt;parse_error(m_lexer.get_position(),
8376                                      m_lexer.get_token_string(),
8377                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, &quot;object&quot;), BasicJsonType()));
8378          }
8379      }
8380      token_type get_token()
8381      {
8382          return last_token = m_lexer.scan();
8383      }
8384      std::string exception_message(const token_type expected, const std::string&amp; context)
8385      {
8386          std::string error_msg = &quot;syntax error &quot;;
8387          if (!context.empty())
8388          {
8389              error_msg += &quot;while parsing &quot; + context + &quot; &quot;;
8390          }
8391          error_msg += &quot;- &quot;;
8392          if (last_token == token_type::parse_error)
8393          {
8394              error_msg += std::string(m_lexer.get_error_message()) + &quot;; last read: &#x27;&quot; +
8395                           m_lexer.get_token_string() + &quot;&#x27;&quot;;
8396          }
8397          else
8398          {
8399              error_msg += &quot;unexpected &quot; + std::string(lexer_t::token_type_name(last_token));
8400          }
8401          if (expected != token_type::uninitialized)
8402          {
8403              error_msg += &quot;; expected &quot; + std::string(lexer_t::token_type_name(expected));
8404          }
8405          return error_msg;
8406      }
8407    private:
8408      const parser_callback_t&lt;BasicJsonType&gt; callback = nullptr;
8409      token_type last_token = token_type::uninitialized;
8410      lexer_t m_lexer;
8411      const bool allow_exceptions = true;
8412  };
8413  }  
8414  }  
8415  #include &lt;cstddef&gt; 
8416  #include &lt;limits&gt;  
8417  namespace nlohmann
8418  {
8419  namespace detail
8420  {
8421  class primitive_iterator_t
8422  {
8423    private:
8424      using difference_type = std::ptrdiff_t;
8425      static constexpr difference_type begin_value = 0;
8426      static constexpr difference_type end_value = begin_value + 1;
8427    JSON_PRIVATE_UNLESS_TESTED:
8428      difference_type m_it = (std::numeric_limits&lt;std::ptrdiff_t&gt;::min)();
8429    public:
8430      constexpr difference_type get_value() const noexcept
8431      {
8432          return m_it;
8433      }
8434      void set_begin() noexcept
8435      {
8436          m_it = begin_value;
8437      }
8438      void set_end() noexcept
8439      {
8440          m_it = end_value;
8441      }
8442      constexpr bool is_begin() const noexcept
8443      {
8444          return m_it == begin_value;
8445      }
8446      constexpr bool is_end() const noexcept
8447      {
8448          return m_it == end_value;
8449      }
8450      friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
8451      {
8452          return lhs.m_it == rhs.m_it;
8453      }
8454      friend constexpr bool operator&lt;(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
8455      {
8456          return lhs.m_it &lt; rhs.m_it;
8457      }
8458      primitive_iterator_t operator+(difference_type n) noexcept
8459      {
8460          auto result = *this;
8461          result += n;
8462          return result;
8463      }
8464      friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
8465      {
8466          return lhs.m_it - rhs.m_it;
8467      }
8468      primitive_iterator_t&amp; operator++() noexcept
8469      {
8470          ++m_it;
8471          return *this;
8472      }
8473      primitive_iterator_t const operator++(int) noexcept 
8474      {
8475          auto result = *this;
8476          ++m_it;
8477          return result;
8478      }
8479      primitive_iterator_t&amp; operator--() noexcept
8480      {
8481          --m_it;
8482          return *this;
8483      }
8484      primitive_iterator_t const operator--(int) noexcept 
8485      {
8486          auto result = *this;
8487          --m_it;
8488          return result;
8489      }
8490      primitive_iterator_t&amp; operator+=(difference_type n) noexcept
8491      {
8492          m_it += n;
8493          return *this;
8494      }
8495      primitive_iterator_t&amp; operator-=(difference_type n) noexcept
8496      {
8497          m_it -= n;
8498          return *this;
8499      }
8500  };
8501  }  
8502  }  
8503  namespace nlohmann
8504  {
8505  namespace detail
8506  {
8507  template&lt;typename BasicJsonType&gt; struct internal_iterator
8508  {
8509      typename BasicJsonType::object_t::iterator object_iterator {};
8510      typename BasicJsonType::array_t::iterator array_iterator {};
8511      primitive_iterator_t primitive_iterator {};
8512  };
8513  }  
8514  }  
8515  #include &lt;iterator&gt; 
8516  #include &lt;type_traits&gt; 
8517  namespace nlohmann
8518  {
8519  namespace detail
8520  {
8521  template&lt;typename IteratorType&gt; class iteration_proxy;
8522  template&lt;typename IteratorType&gt; class iteration_proxy_value;
8523  template&lt;typename BasicJsonType&gt;
8524  class iter_impl
8525  {
8526      using other_iter_impl = iter_impl&lt;typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value, typename std::remove_const&lt;BasicJsonType&gt;::type, const BasicJsonType&gt;::type&gt;;
8527      friend other_iter_impl;
8528      friend BasicJsonType;
8529      friend iteration_proxy&lt;iter_impl&gt;;
8530      friend iteration_proxy_value&lt;iter_impl&gt;;
8531      using object_t = typename BasicJsonType::object_t;
8532      using array_t = typename BasicJsonType::array_t;
8533      static_assert(is_basic_json&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;::value,
8534                    &quot;iter_impl only accepts (const) basic_json&quot;);
8535    public:
8536      using iterator_category = std::bidirectional_iterator_tag;
8537      using value_type = typename BasicJsonType::value_type;
8538      using difference_type = typename BasicJsonType::difference_type;
8539      using pointer = typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value,
8540            typename BasicJsonType::const_pointer,
8541            typename BasicJsonType::pointer&gt;::type;
8542      using reference =
8543          typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value,
8544          typename BasicJsonType::const_reference,
8545          typename BasicJsonType::reference&gt;::type;
8546      iter_impl() = default;
8547      ~iter_impl() = default;
8548      iter_impl(iter_impl&amp;&amp;) noexcept = default;
8549      iter_impl&amp; operator=(iter_impl&amp;&amp;) noexcept = default;
8550      explicit iter_impl(pointer object) noexcept : m_object(object)
8551      {
8552          JSON_ASSERT(m_object != nullptr);
8553          switch (m_object-&gt;m_type)
8554          {
8555              case value_t::object:
8556              {
8557                  m_it.object_iterator = typename object_t::iterator();
8558                  break;
8559              }
8560              case value_t::array:
8561              {
8562                  m_it.array_iterator = typename array_t::iterator();
8563                  break;
8564              }
8565              case value_t::null:
8566              case value_t::string:
8567              case value_t::boolean:
8568              case value_t::number_integer:
8569              case value_t::number_unsigned:
8570              case value_t::number_float:
8571              case value_t::binary:
8572              case value_t::discarded:
8573              default:
8574              {
8575                  m_it.primitive_iterator = primitive_iterator_t();
8576                  break;
8577              }
8578          }
8579      }
8580      iter_impl(const iter_impl&lt;const BasicJsonType&gt;&amp; other) noexcept
8581          : m_object(other.m_object), m_it(other.m_it)
8582      {}
8583      iter_impl&amp; operator=(const iter_impl&lt;const BasicJsonType&gt;&amp; other) noexcept
8584      {
8585          if (&amp;other != this)
8586          {
8587              m_object = other.m_object;
8588              m_it = other.m_it;
8589          }
8590          return *this;
8591      }
8592      iter_impl(const iter_impl&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;&amp; other) noexcept
8593          : m_object(other.m_object), m_it(other.m_it)
8594      {}
8595      iter_impl&amp; operator=(const iter_impl&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;&amp; other) noexcept 
8596      {
8597          m_object = other.m_object;
8598          m_it = other.m_it;
8599          return *this;
8600      }
8601    JSON_PRIVATE_UNLESS_TESTED:
8602      void set_begin() noexcept
8603      {
8604          JSON_ASSERT(m_object != nullptr);
8605          switch (m_object-&gt;m_type)
8606          {
8607              case value_t::object:
8608              {
8609                  m_it.object_iterator = m_object-&gt;m_value.object-&gt;begin();
8610                  break;
8611              }
8612              case value_t::array:
8613              {
8614                  m_it.array_iterator = m_object-&gt;m_value.array-&gt;begin();
8615                  break;
8616              }
8617              case value_t::null:
8618              {
8619                  m_it.primitive_iterator.set_end();
8620                  break;
8621              }
8622              case value_t::string:
8623              case value_t::boolean:
8624              case value_t::number_integer:
8625              case value_t::number_unsigned:
8626              case value_t::number_float:
8627              case value_t::binary:
8628              case value_t::discarded:
8629              default:
8630              {
8631                  m_it.primitive_iterator.set_begin();
8632                  break;
8633              }
8634          }
8635      }
8636      void set_end() noexcept
8637      {
8638          JSON_ASSERT(m_object != nullptr);
8639          switch (m_object-&gt;m_type)
8640          {
8641              case value_t::object:
8642              {
8643                  m_it.object_iterator = m_object-&gt;m_value.object-&gt;end();
8644                  break;
8645              }
8646              case value_t::array:
8647              {
8648                  m_it.array_iterator = m_object-&gt;m_value.array-&gt;end();
8649                  break;
8650              }
8651              case value_t::null:
8652              case value_t::string:
8653              case value_t::boolean:
8654              case value_t::number_integer:
8655              case value_t::number_unsigned:
8656              case value_t::number_float:
8657              case value_t::binary:
8658              case value_t::discarded:
8659              default:
8660              {
8661                  m_it.primitive_iterator.set_end();
8662                  break;
8663              }
8664          }
8665      }
8666    public:
8667      reference operator*() const
8668      {
8669          JSON_ASSERT(m_object != nullptr);
8670          switch (m_object-&gt;m_type)
8671          {
8672              case value_t::object:
8673              {
8674                  JSON_ASSERT(m_it.object_iterator != m_object-&gt;m_value.object-&gt;end());
8675                  return m_it.object_iterator-&gt;second;
8676              }
8677              case value_t::array:
8678              {
8679                  JSON_ASSERT(m_it.array_iterator != m_object-&gt;m_value.array-&gt;end());
8680                  return *m_it.array_iterator;
8681              }
8682              case value_t::null:
8683                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, *m_object));
8684              case value_t::string:
8685              case value_t::boolean:
8686              case value_t::number_integer:
8687              case value_t::number_unsigned:
8688              case value_t::number_float:
8689              case value_t::binary:
8690              case value_t::discarded:
8691              default:
8692              {
8693                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
8694                  {
8695                      return *m_object;
8696                  }
8697                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, *m_object));
8698              }
8699          }
8700      }
8701      pointer operator-&gt;() const
8702      {
8703          JSON_ASSERT(m_object != nullptr);
8704          switch (m_object-&gt;m_type)
8705          {
8706              case value_t::object:
8707              {
8708                  JSON_ASSERT(m_it.object_iterator != m_object-&gt;m_value.object-&gt;end());
8709                  return &amp;(m_it.object_iterator-&gt;second);
8710              }
8711              case value_t::array:
8712              {
8713                  JSON_ASSERT(m_it.array_iterator != m_object-&gt;m_value.array-&gt;end());
8714                  return &amp;*m_it.array_iterator;
8715              }
8716              case value_t::null:
8717              case value_t::string:
8718              case value_t::boolean:
8719              case value_t::number_integer:
8720              case value_t::number_unsigned:
8721              case value_t::number_float:
8722              case value_t::binary:
8723              case value_t::discarded:
8724              default:
8725              {
8726                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
8727                  {
8728                      return m_object;
8729                  }
8730                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, *m_object));
8731              }
8732          }
8733      }
8734      iter_impl const operator++(int) 
8735      {
8736          auto result = *this;
8737          ++(*this);
8738          return result;
8739      }
8740      iter_impl&amp; operator++()
8741      {
8742          JSON_ASSERT(m_object != nullptr);
8743          switch (m_object-&gt;m_type)
8744          {
8745              case value_t::object:
8746              {
8747                  std::advance(m_it.object_iterator, 1);
8748                  break;
8749              }
8750              case value_t::array:
8751              {
8752                  std::advance(m_it.array_iterator, 1);
8753                  break;
8754              }
8755              case value_t::null:
8756              case value_t::string:
8757              case value_t::boolean:
8758              case value_t::number_integer:
8759              case value_t::number_unsigned:
8760              case value_t::number_float:
8761              case value_t::binary:
8762              case value_t::discarded:
8763              default:
8764              {
8765                  ++m_it.primitive_iterator;
8766                  break;
8767              }
8768          }
8769          return *this;
8770      }
8771      iter_impl const operator--(int) 
8772      {
8773          auto result = *this;
8774          --(*this);
8775          return result;
8776      }
8777      iter_impl&amp; operator--()
8778      {
8779          JSON_ASSERT(m_object != nullptr);
8780          switch (m_object-&gt;m_type)
8781          {
8782              case value_t::object:
8783              {
8784                  std::advance(m_it.object_iterator, -1);
8785                  break;
8786              }
8787              case value_t::array:
8788              {
8789                  std::advance(m_it.array_iterator, -1);
8790                  break;
8791              }
8792              case value_t::null:
8793              case value_t::string:
8794              case value_t::boolean:
8795              case value_t::number_integer:
8796              case value_t::number_unsigned:
8797              case value_t::number_float:
8798              case value_t::binary:
8799              case value_t::discarded:
8800              default:
8801              {
8802                  --m_it.primitive_iterator;
8803                  break;
8804              }
8805          }
8806          return *this;
8807      }
8808      template &lt; typename IterImpl, detail::enable_if_t &lt; (std::is_same&lt;IterImpl, iter_impl&gt;::value || std::is_same&lt;IterImpl, other_iter_impl&gt;::value), std::nullptr_t &gt; = nullptr &gt;
8809      bool operator==(const IterImpl&amp; other) const
8810      {
8811          if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
8812          {
8813              JSON_THROW(invalid_iterator::create(212, &quot;cannot compare iterators of different containers&quot;, *m_object));
8814          }
8815          JSON_ASSERT(m_object != nullptr);
8816          switch (m_object-&gt;m_type)
8817          {
8818              case value_t::object:
8819                  return (m_it.object_iterator == other.m_it.object_iterator);
8820              case value_t::array:
8821                  return (m_it.array_iterator == other.m_it.array_iterator);
8822              case value_t::null:
8823              case value_t::string:
8824              case value_t::boolean:
8825              case value_t::number_integer:
8826              case value_t::number_unsigned:
8827              case value_t::number_float:
8828              case value_t::binary:
8829              case value_t::discarded:
8830              default:
8831                  return (m_it.primitive_iterator == other.m_it.primitive_iterator);
8832          }
8833      }
8834      template &lt; typename IterImpl, detail::enable_if_t &lt; (std::is_same&lt;IterImpl, iter_impl&gt;::value || std::is_same&lt;IterImpl, other_iter_impl&gt;::value), std::nullptr_t &gt; = nullptr &gt;
8835      bool operator!=(const IterImpl&amp; other) const
8836      {
8837          return !operator==(other);
8838      }
8839      bool operator&lt;(const iter_impl&amp; other) const
8840      {
8841          if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
8842          {
8843              JSON_THROW(invalid_iterator::create(212, &quot;cannot compare iterators of different containers&quot;, *m_object));
8844          }
8845          JSON_ASSERT(m_object != nullptr);
8846          switch (m_object-&gt;m_type)
8847          {
8848              case value_t::object:
8849                  JSON_THROW(invalid_iterator::create(213, &quot;cannot compare order of object iterators&quot;, *m_object));
8850              case value_t::array:
8851                  return (m_it.array_iterator &lt; other.m_it.array_iterator);
8852              case value_t::null:
8853              case value_t::string:
8854              case value_t::boolean:
8855              case value_t::number_integer:
8856              case value_t::number_unsigned:
8857              case value_t::number_float:
8858              case value_t::binary:
8859              case value_t::discarded:
8860              default:
8861                  return (m_it.primitive_iterator &lt; other.m_it.primitive_iterator);
8862          }
8863      }
8864      bool operator&lt;=(const iter_impl&amp; other) const
8865      {
8866          return !other.operator &lt; (*this);
8867      }
8868      bool operator&gt;(const iter_impl&amp; other) const
8869      {
8870          return !operator&lt;=(other);
8871      }
8872      bool operator&gt;=(const iter_impl&amp; other) const
8873      {
8874          return !operator&lt;(other);
8875      }
8876      iter_impl&amp; operator+=(difference_type i)
8877      {
8878          JSON_ASSERT(m_object != nullptr);
8879          switch (m_object-&gt;m_type)
8880          {
8881              case value_t::object:
8882                  JSON_THROW(invalid_iterator::create(209, &quot;cannot use offsets with object iterators&quot;, *m_object));
8883              case value_t::array:
8884              {
8885                  std::advance(m_it.array_iterator, i);
8886                  break;
8887              }
8888              case value_t::null:
8889              case value_t::string:
8890              case value_t::boolean:
8891              case value_t::number_integer:
8892              case value_t::number_unsigned:
8893              case value_t::number_float:
8894              case value_t::binary:
8895              case value_t::discarded:
8896              default:
8897              {
8898                  m_it.primitive_iterator += i;
8899                  break;
8900              }
8901          }
8902          return *this;
8903      }
8904      iter_impl&amp; operator-=(difference_type i)
8905      {
8906          return operator+=(-i);
8907      }
8908      iter_impl operator+(difference_type i) const
8909      {
8910          auto result = *this;
8911          result += i;
8912          return result;
8913      }
8914      friend iter_impl operator+(difference_type i, const iter_impl&amp; it)
8915      {
8916          auto result = it;
8917          result += i;
8918          return result;
8919      }
8920      iter_impl operator-(difference_type i) const
8921      {
8922          auto result = *this;
8923          result -= i;
8924          return result;
8925      }
8926      difference_type operator-(const iter_impl&amp; other) const
8927      {
8928          JSON_ASSERT(m_object != nullptr);
8929          switch (m_object-&gt;m_type)
8930          {
8931              case value_t::object:
8932                  JSON_THROW(invalid_iterator::create(209, &quot;cannot use offsets with object iterators&quot;, *m_object));
8933              case value_t::array:
8934                  return m_it.array_iterator - other.m_it.array_iterator;
8935              case value_t::null:
8936              case value_t::string:
8937              case value_t::boolean:
8938              case value_t::number_integer:
8939              case value_t::number_unsigned:
8940              case value_t::number_float:
8941              case value_t::binary:
8942              case value_t::discarded:
8943              default:
8944                  return m_it.primitive_iterator - other.m_it.primitive_iterator;
8945          }
8946      }
8947      reference operator[](difference_type n) const
8948      {
8949          JSON_ASSERT(m_object != nullptr);
8950          switch (m_object-&gt;m_type)
8951          {
8952              case value_t::object:
8953                  JSON_THROW(invalid_iterator::create(208, &quot;cannot use operator[] for object iterators&quot;, *m_object));
8954              case value_t::array:
8955                  return *std::next(m_it.array_iterator, n);
8956              case value_t::null:
8957                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, *m_object));
8958              case value_t::string:
8959              case value_t::boolean:
8960              case value_t::number_integer:
8961              case value_t::number_unsigned:
8962              case value_t::number_float:
8963              case value_t::binary:
8964              case value_t::discarded:
8965              default:
8966              {
8967                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
8968                  {
8969                      return *m_object;
8970                  }
8971                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, *m_object));
8972              }
8973          }
8974      }
8975      const typename object_t::key_type&amp; key() const
8976      {
8977          JSON_ASSERT(m_object != nullptr);
8978          if (JSON_HEDLEY_LIKELY(m_object-&gt;is_object()))
8979          {
8980              return m_it.object_iterator-&gt;first;
8981          }
8982          JSON_THROW(invalid_iterator::create(207, &quot;cannot use key() for non-object iterators&quot;, *m_object));
8983      }
8984      reference value() const
8985      {
8986          return operator*();
8987      }
8988    JSON_PRIVATE_UNLESS_TESTED:
8989      pointer m_object = nullptr;
8990      internal_iterator&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt; m_it {};
8991  };
8992  } 
8993  } 
8994  #include &lt;cstddef&gt; 
8995  #include &lt;iterator&gt; 
8996  #include &lt;utility&gt; 
8997  namespace nlohmann
8998  {
8999  namespace detail
9000  {
9001  template&lt;typename Base&gt;
9002  class json_reverse_iterator : public std::reverse_iterator&lt;Base&gt;
9003  {
9004    public:
9005      using difference_type = std::ptrdiff_t;
9006      using base_iterator = std::reverse_iterator&lt;Base&gt;;
9007      using reference = typename Base::reference;
9008      explicit json_reverse_iterator(const typename base_iterator::iterator_type&amp; it) noexcept
9009          : base_iterator(it) {}
9010      explicit json_reverse_iterator(const base_iterator&amp; it) noexcept : base_iterator(it) {}
9011      json_reverse_iterator const operator++(int) 
9012      {
9013          return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator++(1));
9014      }
9015      json_reverse_iterator&amp; operator++()
9016      {
9017          return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator++());
9018      }
9019      json_reverse_iterator const operator--(int) 
9020      {
9021          return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator--(1));
9022      }
9023      json_reverse_iterator&amp; operator--()
9024      {
9025          return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator--());
9026      }
9027      json_reverse_iterator&amp; operator+=(difference_type i)
9028      {
9029          return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator+=(i));
9030      }
9031      json_reverse_iterator operator+(difference_type i) const
9032      {
9033          return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator+(i));
9034      }
9035      json_reverse_iterator operator-(difference_type i) const
9036      {
9037          return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator-(i));
9038      }
9039      difference_type operator-(const json_reverse_iterator&amp; other) const
9040      {
9041          return base_iterator(*this) - base_iterator(other);
9042      }
9043      reference operator[](difference_type n) const
9044      {
9045          return *(this-&gt;operator+(n));
9046      }
9047      auto key() const -&gt; decltype(std::declval&lt;Base&gt;().key())
9048      {
9049          auto it = --this-&gt;base();
9050          return it.key();
9051      }
9052      reference value() const
9053      {
9054          auto it = --this-&gt;base();
9055          return it.operator * ();
9056      }
9057  };
9058  }  
9059  }  
9060  #include &lt;algorithm&gt; 
9061  #include &lt;cctype&gt; 
9062  #include &lt;limits&gt; 
9063  #include &lt;numeric&gt; 
9064  #include &lt;string&gt; 
9065  #include &lt;utility&gt; 
9066  #include &lt;vector&gt; 
9067  namespace nlohmann
9068  {
9069  template&lt;typename BasicJsonType&gt;
9070  class json_pointer
9071  {
9072      NLOHMANN_BASIC_JSON_TPL_DECLARATION
9073      friend class basic_json;
9074    public:
9075      explicit json_pointer(const std::string&amp; s = &quot;&quot;)
9076          : reference_tokens(split(s))
9077      {}
9078      std::string to_string() const
9079      {
9080          return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
9081                                 std::string{},
9082                                 [](const std::string &amp; a, const std::string &amp; b)
9083          {
9084              return a + &quot;/&quot; + detail::escape(b);
9085          });
9086      }
9087      operator std::string() const
9088      {
9089          return to_string();
9090      }
9091      json_pointer&amp; operator/=(const json_pointer&amp; ptr)
9092      {
9093          reference_tokens.insert(reference_tokens.end(),
9094                                  ptr.reference_tokens.begin(),
9095                                  ptr.reference_tokens.end());
9096          return *this;
9097      }
9098      json_pointer&amp; operator/=(std::string token)
9099      {
9100          push_back(std::move(token));
9101          return *this;
9102      }
9103      json_pointer&amp; operator/=(std::size_t array_idx)
9104      {
9105          return *this /= std::to_string(array_idx);
9106      }
9107      friend json_pointer operator/(const json_pointer&amp; lhs,
9108                                    const json_pointer&amp; rhs)
9109      {
9110          return json_pointer(lhs) /= rhs;
9111      }
9112      friend json_pointer operator/(const json_pointer&amp; ptr, std::string token) 
9113      {
9114          return json_pointer(ptr) /= std::move(token);
9115      }
9116      friend json_pointer operator/(const json_pointer&amp; ptr, std::size_t array_idx)
9117      {
9118          return json_pointer(ptr) /= array_idx;
9119      }
9120      json_pointer parent_pointer() const
9121      {
9122          if (empty())
9123          {
9124              return *this;
9125          }
9126          json_pointer res = *this;
9127          res.pop_back();
9128          return res;
9129      }
9130      void pop_back()
9131      {
9132          if (JSON_HEDLEY_UNLIKELY(empty()))
9133          {
9134              JSON_THROW(detail::out_of_range::create(405, &quot;JSON pointer has no parent&quot;, BasicJsonType()));
9135          }
9136          reference_tokens.pop_back();
9137      }
9138      const std::string&amp; back() const
9139      {
9140          if (JSON_HEDLEY_UNLIKELY(empty()))
9141          {
9142              JSON_THROW(detail::out_of_range::create(405, &quot;JSON pointer has no parent&quot;, BasicJsonType()));
9143          }
9144          return reference_tokens.back();
9145      }
9146      void push_back(const std::string&amp; token)
9147      {
9148          reference_tokens.push_back(token);
9149      }
9150      void push_back(std::string&amp;&amp; token)
9151      {
9152          reference_tokens.push_back(std::move(token));
9153      }
9154      bool empty() const noexcept
9155      {
9156          return reference_tokens.empty();
9157      }
9158    private:
9159      static typename BasicJsonType::size_type array_index(const std::string&amp; s)
9160      {
9161          using size_type = typename BasicJsonType::size_type;
9162          if (JSON_HEDLEY_UNLIKELY(s.size() &gt; 1 &amp;&amp; s[0] == &#x27;0&#x27;))
9163          {
9164              JSON_THROW(detail::parse_error::create(106, 0, &quot;array index &#x27;&quot; + s + &quot;&#x27; must not begin with &#x27;0&#x27;&quot;, BasicJsonType()));
9165          }
9166          if (JSON_HEDLEY_UNLIKELY(s.size() &gt; 1 &amp;&amp; !(s[0] &gt;= &#x27;1&#x27; &amp;&amp; s[0] &lt;= &#x27;9&#x27;)))
9167          {
9168              JSON_THROW(detail::parse_error::create(109, 0, &quot;array index &#x27;&quot; + s + &quot;&#x27; is not a number&quot;, BasicJsonType()));
9169          }
9170          std::size_t processed_chars = 0;
9171          unsigned long long res = 0;  
9172          JSON_TRY
9173          {
9174              res = std::stoull(s, &amp;processed_chars);
9175          }
9176          JSON_CATCH(std::out_of_range&amp;)
9177          {
9178              JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token &#x27;&quot; + s + &quot;&#x27;&quot;, BasicJsonType()));
9179          }
9180          if (JSON_HEDLEY_UNLIKELY(processed_chars != s.size()))
9181          {
9182              JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token &#x27;&quot; + s + &quot;&#x27;&quot;, BasicJsonType()));
9183          }
9184          if (res &gt;= static_cast&lt;unsigned long long&gt;((std::numeric_limits&lt;size_type&gt;::max)()))  
9185          {
9186              JSON_THROW(detail::out_of_range::create(410, &quot;array index &quot; + s + &quot; exceeds size_type&quot;, BasicJsonType())); 
9187          }
9188          return static_cast&lt;size_type&gt;(res);
9189      }
9190    JSON_PRIVATE_UNLESS_TESTED:
9191      json_pointer top() const
9192      {
9193          if (JSON_HEDLEY_UNLIKELY(empty()))
9194          {
9195              JSON_THROW(detail::out_of_range::create(405, &quot;JSON pointer has no parent&quot;, BasicJsonType()));
9196          }
9197          json_pointer result = *this;
9198          result.reference_tokens = {reference_tokens[0]};
9199          return result;
9200      }
9201    private:
9202      BasicJsonType&amp; get_and_create(BasicJsonType&amp; j) const
9203      {
9204          auto* result = &amp;j;
9205          for (const auto&amp; reference_token : reference_tokens)
9206          {
9207              switch (result-&gt;type())
9208              {
9209                  case detail::value_t::null:
9210                  {
9211                      if (reference_token == &quot;0&quot;)
9212                      {
9213                          result = &amp;result-&gt;operator[](0);
9214                      }
9215                      else
9216                      {
9217                          result = &amp;result-&gt;operator[](reference_token);
9218                      }
9219                      break;
9220                  }
9221                  case detail::value_t::object:
9222                  {
9223                      result = &amp;result-&gt;operator[](reference_token);
9224                      break;
9225                  }
9226                  case detail::value_t::array:
9227                  {
9228                      result = &amp;result-&gt;operator[](array_index(reference_token));
9229                      break;
9230                  }
9231                  case detail::value_t::string:
9232                  case detail::value_t::boolean:
9233                  case detail::value_t::number_integer:
9234                  case detail::value_t::number_unsigned:
9235                  case detail::value_t::number_float:
9236                  case detail::value_t::binary:
9237                  case detail::value_t::discarded:
9238                  default:
9239                      JSON_THROW(detail::type_error::create(313, &quot;invalid value to unflatten&quot;, j));
9240              }
9241          }
9242          return *result;
9243      }
9244      BasicJsonType&amp; get_unchecked(BasicJsonType* ptr) const
9245      {
9246          for (const auto&amp; reference_token : reference_tokens)
9247          {
9248              if (ptr-&gt;is_null())
9249              {
9250                  const bool nums =
9251                      std::all_of(reference_token.begin(), reference_token.end(),
9252                                  [](const unsigned char x)
9253                  {
9254                      return std::isdigit(x);
9255                  });
9256                  *ptr = (nums || reference_token == &quot;-&quot;)
9257                         ? detail::value_t::array
9258                         : detail::value_t::object;
9259              }
9260              switch (ptr-&gt;type())
9261              {
9262                  case detail::value_t::object:
9263                  {
9264                      ptr = &amp;ptr-&gt;operator[](reference_token);
9265                      break;
9266                  }
9267                  case detail::value_t::array:
9268                  {
9269                      if (reference_token == &quot;-&quot;)
9270                      {
9271                          ptr = &amp;ptr-&gt;operator[](ptr-&gt;m_value.array-&gt;size());
9272                      }
9273                      else
9274                      {
9275                          ptr = &amp;ptr-&gt;operator[](array_index(reference_token));
9276                      }
9277                      break;
9278                  }
9279                  case detail::value_t::null:
9280                  case detail::value_t::string:
9281                  case detail::value_t::boolean:
9282                  case detail::value_t::number_integer:
9283                  case detail::value_t::number_unsigned:
9284                  case detail::value_t::number_float:
9285                  case detail::value_t::binary:
9286                  case detail::value_t::discarded:
9287                  default:
9288                      JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token &#x27;&quot; + reference_token + &quot;&#x27;&quot;, *ptr));
9289              }
9290          }
9291          return *ptr;
9292      }
9293      BasicJsonType&amp; get_checked(BasicJsonType* ptr) const
9294      {
9295          for (const auto&amp; reference_token : reference_tokens)
9296          {
9297              switch (ptr-&gt;type())
9298              {
9299                  case detail::value_t::object:
9300                  {
9301                      ptr = &amp;ptr-&gt;at(reference_token);
9302                      break;
9303                  }
9304                  case detail::value_t::array:
9305                  {
9306                      if (JSON_HEDLEY_UNLIKELY(reference_token == &quot;-&quot;))
9307                      {
9308                          JSON_THROW(detail::out_of_range::create(402,
9309                                                                  &quot;array index &#x27;-&#x27; (&quot; + std::to_string(ptr-&gt;m_value.array-&gt;size()) +
9310                                                                  &quot;) is out of range&quot;, *ptr));
9311                      }
9312                      ptr = &amp;ptr-&gt;at(array_index(reference_token));
9313                      break;
9314                  }
9315                  case detail::value_t::null:
9316                  case detail::value_t::string:
9317                  case detail::value_t::boolean:
9318                  case detail::value_t::number_integer:
9319                  case detail::value_t::number_unsigned:
9320                  case detail::value_t::number_float:
9321                  case detail::value_t::binary:
9322                  case detail::value_t::discarded:
9323                  default:
9324                      JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token &#x27;&quot; + reference_token + &quot;&#x27;&quot;, *ptr));
9325              }
9326          }
9327          return *ptr;
9328      }
9329      const BasicJsonType&amp; get_unchecked(const BasicJsonType* ptr) const
9330      {
9331          for (const auto&amp; reference_token : reference_tokens)
9332          {
9333              switch (ptr-&gt;type())
9334              {
9335                  case detail::value_t::object:
9336                  {
9337                      ptr = &amp;ptr-&gt;operator[](reference_token);
9338                      break;
9339                  }
9340                  case detail::value_t::array:
9341                  {
9342                      if (JSON_HEDLEY_UNLIKELY(reference_token == &quot;-&quot;))
9343                      {
9344                          JSON_THROW(detail::out_of_range::create(402, &quot;array index &#x27;-&#x27; (&quot; + std::to_string(ptr-&gt;m_value.array-&gt;size()) + &quot;) is out of range&quot;, *ptr));
9345                      }
9346                      ptr = &amp;ptr-&gt;operator[](array_index(reference_token));
9347                      break;
9348                  }
9349                  case detail::value_t::null:
9350                  case detail::value_t::string:
9351                  case detail::value_t::boolean:
9352                  case detail::value_t::number_integer:
9353                  case detail::value_t::number_unsigned:
9354                  case detail::value_t::number_float:
9355                  case detail::value_t::binary:
9356                  case detail::value_t::discarded:
9357                  default:
9358                      JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token &#x27;&quot; + reference_token + &quot;&#x27;&quot;, *ptr));
9359              }
9360          }
9361          return *ptr;
9362      }
9363      const BasicJsonType&amp; get_checked(const BasicJsonType* ptr) const
9364      {
9365          for (const auto&amp; reference_token : reference_tokens)
9366          {
9367              switch (ptr-&gt;type())
9368              {
9369                  case detail::value_t::object:
9370                  {
9371                      ptr = &amp;ptr-&gt;at(reference_token);
9372                      break;
9373                  }
9374                  case detail::value_t::array:
9375                  {
9376                      if (JSON_HEDLEY_UNLIKELY(reference_token == &quot;-&quot;))
9377                      {
9378                          JSON_THROW(detail::out_of_range::create(402,
9379                                                                  &quot;array index &#x27;-&#x27; (&quot; + std::to_string(ptr-&gt;m_value.array-&gt;size()) +
9380                                                                  &quot;) is out of range&quot;, *ptr));
9381                      }
9382                      ptr = &amp;ptr-&gt;at(array_index(reference_token));
9383                      break;
9384                  }
9385                  case detail::value_t::null:
9386                  case detail::value_t::string:
9387                  case detail::value_t::boolean:
9388                  case detail::value_t::number_integer:
9389                  case detail::value_t::number_unsigned:
9390                  case detail::value_t::number_float:
9391                  case detail::value_t::binary:
9392                  case detail::value_t::discarded:
9393                  default:
9394                      JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token &#x27;&quot; + reference_token + &quot;&#x27;&quot;, *ptr));
9395              }
9396          }
9397          return *ptr;
9398      }
9399      bool contains(const BasicJsonType* ptr) const
9400      {
9401          for (const auto&amp; reference_token : reference_tokens)
9402          {
9403              switch (ptr-&gt;type())
9404              {
9405                  case detail::value_t::object:
9406                  {
9407                      if (!ptr-&gt;contains(reference_token))
9408                      {
9409                          return false;
9410                      }
9411                      ptr = &amp;ptr-&gt;operator[](reference_token);
9412                      break;
9413                  }
9414                  case detail::value_t::array:
9415                  {
9416                      if (JSON_HEDLEY_UNLIKELY(reference_token == &quot;-&quot;))
9417                      {
9418                          return false;
9419                      }
9420                      if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 &amp;&amp; !(&quot;0&quot; &lt;= reference_token &amp;&amp; reference_token &lt;= &quot;9&quot;)))
9421                      {
9422                          return false;
9423                      }
9424                      if (JSON_HEDLEY_UNLIKELY(reference_token.size() &gt; 1))
9425                      {
9426                          if (JSON_HEDLEY_UNLIKELY(!(&#x27;1&#x27; &lt;= reference_token[0] &amp;&amp; reference_token[0] &lt;= &#x27;9&#x27;)))
9427                          {
9428                              return false;
9429                          }
9430                          for (std::size_t i = 1; i &lt; reference_token.size(); i++)
9431                          {
9432                              if (JSON_HEDLEY_UNLIKELY(!(&#x27;0&#x27; &lt;= reference_token[i] &amp;&amp; reference_token[i] &lt;= &#x27;9&#x27;)))
9433                              {
9434                                  return false;
9435                              }
9436                          }
9437                      }
9438                      const auto idx = array_index(reference_token);
9439                      if (idx &gt;= ptr-&gt;size())
9440                      {
9441                          return false;
9442                      }
9443                      ptr = &amp;ptr-&gt;operator[](idx);
9444                      break;
9445                  }
9446                  case detail::value_t::null:
9447                  case detail::value_t::string:
9448                  case detail::value_t::boolean:
9449                  case detail::value_t::number_integer:
9450                  case detail::value_t::number_unsigned:
9451                  case detail::value_t::number_float:
9452                  case detail::value_t::binary:
9453                  case detail::value_t::discarded:
9454                  default:
9455                  {
9456                      return false;
9457                  }
9458              }
9459          }
9460          return true;
9461      }
9462      static std::vector&lt;std::string&gt; split(const std::string&amp; reference_string)
9463      {
9464          std::vector&lt;std::string&gt; result;
9465          if (reference_string.empty())
9466          {
9467              return result;
9468          }
9469          if (JSON_HEDLEY_UNLIKELY(reference_string[0] != &#x27;/&#x27;))
9470          {
9471              JSON_THROW(detail::parse_error::create(107, 1, &quot;JSON pointer must be empty or begin with &#x27;/&#x27; - was: &#x27;&quot; + reference_string + &quot;&#x27;&quot;, BasicJsonType()));
9472          }
9473          for (
9474              std::size_t slash = reference_string.find_first_of(&#x27;/&#x27;, 1),
9475              start = 1;
9476              start != 0;
9477              start = (slash == std::string::npos) ? 0 : slash + 1,
9478              slash = reference_string.find_first_of(&#x27;/&#x27;, start))
9479          {
9480              auto reference_token = reference_string.substr(start, slash - start);
9481              for (std::size_t pos = reference_token.find_first_of(&#x27;~&#x27;);
9482                      pos != std::string::npos;
9483                      pos = reference_token.find_first_of(&#x27;~&#x27;, pos + 1))
9484              {
9485                  JSON_ASSERT(reference_token[pos] == &#x27;~&#x27;);
9486                  if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
9487                                           (reference_token[pos + 1] != &#x27;0&#x27; &amp;&amp;
9488                                            reference_token[pos + 1] != &#x27;1&#x27;)))
9489                  {
9490                      JSON_THROW(detail::parse_error::create(108, 0, &quot;escape character &#x27;~&#x27; must be followed with &#x27;0&#x27; or &#x27;1&#x27;&quot;, BasicJsonType()));
9491                  }
9492              }
9493              detail::unescape(reference_token);
9494              result.push_back(reference_token);
9495          }
9496          return result;
9497      }
9498    private:
9499      static void flatten(const std::string&amp; reference_string,
9500                          const BasicJsonType&amp; value,
9501                          BasicJsonType&amp; result)
9502      {
9503          switch (value.type())
9504          {
9505              case detail::value_t::array:
9506              {
9507                  if (value.m_value.array-&gt;empty())
9508                  {
9509                      result[reference_string] = nullptr;
9510                  }
9511                  else
9512                  {
9513                      for (std::size_t i = 0; i &lt; value.m_value.array-&gt;size(); ++i)
9514                      {
9515                          flatten(reference_string + &quot;/&quot; + std::to_string(i),
9516                                  value.m_value.array-&gt;operator[](i), result);
9517                      }
9518                  }
9519                  break;
9520              }
9521              case detail::value_t::object:
9522              {
9523                  if (value.m_value.object-&gt;empty())
9524                  {
9525                      result[reference_string] = nullptr;
9526                  }
9527                  else
9528                  {
9529                      for (const auto&amp; element : *value.m_value.object)
9530                      {
9531                          flatten(reference_string + &quot;/&quot; + detail::escape(element.first), element.second, result);
9532                      }
9533                  }
9534                  break;
9535              }
9536              case detail::value_t::null:
9537              case detail::value_t::string:
9538              case detail::value_t::boolean:
9539              case detail::value_t::number_integer:
9540              case detail::value_t::number_unsigned:
9541              case detail::value_t::number_float:
9542              case detail::value_t::binary:
9543              case detail::value_t::discarded:
9544              default:
9545              {
9546                  result[reference_string] = value;
9547                  break;
9548              }
9549          }
9550      }
9551      static BasicJsonType
9552      unflatten(const BasicJsonType&amp; value)
9553      {
9554          if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
9555          {
9556              JSON_THROW(detail::type_error::create(314, &quot;only objects can be unflattened&quot;, value));
9557          }
9558          BasicJsonType result;
9559          for (const auto&amp; element : *value.m_value.object)
9560          {
9561              if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
9562              {
9563                  JSON_THROW(detail::type_error::create(315, &quot;values in object must be primitive&quot;, element.second));
9564              }
9565              json_pointer(element.first).get_and_create(result) = element.second;
9566          }
9567          return result;
9568      }
9569      friend bool operator==(json_pointer const&amp; lhs,
9570                             json_pointer const&amp; rhs) noexcept
9571      {
9572          return lhs.reference_tokens == rhs.reference_tokens;
9573      }
9574      friend bool operator!=(json_pointer const&amp; lhs,
9575                             json_pointer const&amp; rhs) noexcept
9576      {
9577          return !(lhs == rhs);
9578      }
9579      std::vector&lt;std::string&gt; reference_tokens;
9580  };
9581  }  
9582  #include &lt;initializer_list&gt;
9583  #include &lt;utility&gt;
9584  namespace nlohmann
9585  {
9586  namespace detail
9587  {
9588  template&lt;typename BasicJsonType&gt;
9589  class json_ref
9590  {
9591    public:
9592      using value_type = BasicJsonType;
9593      json_ref(value_type&amp;&amp; value)
9594          : owned_value(std::move(value))
9595      {}
9596      json_ref(const value_type&amp; value)
9597          : value_ref(&amp;value)
9598      {}
9599      json_ref(std::initializer_list&lt;json_ref&gt; init)
9600          : owned_value(init)
9601      {}
9602      template &lt;
9603          class... Args,
9604          enable_if_t&lt;std::is_constructible&lt;value_type, Args...&gt;::value, int&gt; = 0 &gt;
9605      json_ref(Args &amp;&amp; ... args)
9606          : owned_value(std::forward&lt;Args&gt;(args)...)
9607      {}
9608      json_ref(json_ref&amp;&amp;) noexcept = default;
9609      json_ref(const json_ref&amp;) = delete;
9610      json_ref&amp; operator=(const json_ref&amp;) = delete;
9611      json_ref&amp; operator=(json_ref&amp;&amp;) = delete;
9612      ~json_ref() = default;
9613      value_type moved_or_copied() const
9614      {
9615          if (value_ref == nullptr)
9616          {
9617              return std::move(owned_value);
9618          }
9619          return *value_ref;
9620      }
9621      value_type const&amp; operator*() const
9622      {
9623          return value_ref ? *value_ref : owned_value;
9624      }
9625      value_type const* operator-&gt;() const
9626      {
9627          return &amp;** this;
9628      }
9629    private:
9630      mutable value_type owned_value = nullptr;
9631      value_type const* value_ref = nullptr;
9632  };
9633  }  
9634  }  
9635  #include &lt;algorithm&gt; 
9636  #include &lt;array&gt; 
9637  #include &lt;cmath&gt; 
9638  #include &lt;cstdint&gt; 
9639  #include &lt;cstring&gt; 
9640  #include &lt;limits&gt; 
9641  #include &lt;string&gt; 
9642  #include &lt;utility&gt; 
9643  #include &lt;algorithm&gt; 
9644  #include &lt;cstddef&gt; 
9645  #include &lt;iterator&gt; 
9646  #include &lt;memory&gt; 
9647  #include &lt;string&gt; 
9648  #include &lt;vector&gt; 
9649  #ifndef JSON_NO_IO
9650      #include &lt;ios&gt;      
9651      #include &lt;ostream&gt;  
9652  #endif  
9653  namespace nlohmann
9654  {
9655  namespace detail
9656  {
9657  template&lt;typename CharType&gt; struct output_adapter_protocol
9658  {
9659      virtual void write_character(CharType c) = 0;
9660      virtual void write_characters(const CharType* s, std::size_t length) = 0;
9661      virtual ~output_adapter_protocol() = default;
9662      output_adapter_protocol() = default;
9663      output_adapter_protocol(const output_adapter_protocol&amp;) = default;
9664      output_adapter_protocol(output_adapter_protocol&amp;&amp;) noexcept = default;
9665      output_adapter_protocol&amp; operator=(const output_adapter_protocol&amp;) = default;
9666      output_adapter_protocol&amp; operator=(output_adapter_protocol&amp;&amp;) noexcept = default;
9667  };
9668  template&lt;typename CharType&gt;
9669  using output_adapter_t = std::shared_ptr&lt;output_adapter_protocol&lt;CharType&gt;&gt;;
9670  template&lt;typename CharType&gt;
9671  class output_vector_adapter : public output_adapter_protocol&lt;CharType&gt;
9672  {
9673    public:
9674      explicit output_vector_adapter(std::vector&lt;CharType&gt;&amp; vec) noexcept
9675          : v(vec)
9676      {}
9677      void write_character(CharType c) override
9678      {
9679          v.push_back(c);
9680      }
9681      JSON_HEDLEY_NON_NULL(2)
9682      void write_characters(const CharType* s, std::size_t length) override
9683      {
9684          std::copy(s, s + length, std::back_inserter(v));
9685      }
9686    private:
9687      std::vector&lt;CharType&gt;&amp; v;
9688  };
9689  #ifndef JSON_NO_IO
9690  template&lt;typename CharType&gt;
9691  class output_stream_adapter : public output_adapter_protocol&lt;CharType&gt;
9692  {
9693    public:
9694      explicit output_stream_adapter(std::basic_ostream&lt;CharType&gt;&amp; s) noexcept
9695          : stream(s)
9696      {}
9697      void write_character(CharType c) override
9698      {
9699          stream.put(c);
9700      }
9701      JSON_HEDLEY_NON_NULL(2)
9702      void write_characters(const CharType* s, std::size_t length) override
9703      {
9704          stream.write(s, static_cast&lt;std::streamsize&gt;(length));
9705      }
9706    private:
9707      std::basic_ostream&lt;CharType&gt;&amp; stream;
9708  };
9709  #endif  
9710  template&lt;typename CharType, typename StringType = std::basic_string&lt;CharType&gt;&gt;
9711  class output_string_adapter : public output_adapter_protocol&lt;CharType&gt;
9712  {
9713    public:
9714      explicit output_string_adapter(StringType&amp; s) noexcept
9715          : str(s)
9716      {}
9717      void write_character(CharType c) override
9718      {
9719          str.push_back(c);
9720      }
9721      JSON_HEDLEY_NON_NULL(2)
9722      void write_characters(const CharType* s, std::size_t length) override
9723      {
9724          str.append(s, length);
9725      }
9726    private:
9727      StringType&amp; str;
9728  };
9729  template&lt;typename CharType, typename StringType = std::basic_string&lt;CharType&gt;&gt;
9730  class output_adapter
9731  {
9732    public:
9733      output_adapter(std::vector&lt;CharType&gt;&amp; vec)
9734          : oa(std::make_shared&lt;output_vector_adapter&lt;CharType&gt;&gt;(vec)) {}
9735  #ifndef JSON_NO_IO
9736      output_adapter(std::basic_ostream&lt;CharType&gt;&amp; s)
9737          : oa(std::make_shared&lt;output_stream_adapter&lt;CharType&gt;&gt;(s)) {}
9738  #endif  
9739      output_adapter(StringType&amp; s)
9740          : oa(std::make_shared&lt;output_string_adapter&lt;CharType, StringType&gt;&gt;(s)) {}
9741      operator output_adapter_t&lt;CharType&gt;()
9742      {
9743          return oa;
9744      }
9745    private:
9746      output_adapter_t&lt;CharType&gt; oa = nullptr;
9747  };
9748  }  
9749  }  
9750  namespace nlohmann
9751  {
9752  namespace detail
9753  {
9754  template&lt;typename BasicJsonType, typename CharType&gt;
9755  class binary_writer
9756  {
9757      using string_t = typename BasicJsonType::string_t;
9758      using binary_t = typename BasicJsonType::binary_t;
9759      using number_float_t = typename BasicJsonType::number_float_t;
9760    public:
9761      explicit binary_writer(output_adapter_t&lt;CharType&gt; adapter) : oa(std::move(adapter))
9762      {
9763          JSON_ASSERT(oa);
9764      }
9765      void write_bson(const BasicJsonType&amp; j)
9766      {
9767          switch (j.type())
9768          {
9769              case value_t::object:
9770              {
9771                  write_bson_object(*j.m_value.object);
9772                  break;
9773              }
9774              case value_t::null:
9775              case value_t::array:
9776              case value_t::string:
9777              case value_t::boolean:
9778              case value_t::number_integer:
9779              case value_t::number_unsigned:
9780              case value_t::number_float:
9781              case value_t::binary:
9782              case value_t::discarded:
9783              default:
9784              {
9785                  JSON_THROW(type_error::create(317, &quot;to serialize to BSON, top-level type must be object, but is &quot; + std::string(j.type_name()), j));
9786              }
9787          }
9788      }
9789      void write_cbor(const BasicJsonType&amp; j)
9790      {
9791          switch (j.type())
9792          {
9793              case value_t::null:
9794              {
9795                  oa-&gt;write_character(to_char_type(0xF6));
9796                  break;
9797              }
9798              case value_t::boolean:
9799              {
9800                  oa-&gt;write_character(j.m_value.boolean
9801                                      ? to_char_type(0xF5)
9802                                      : to_char_type(0xF4));
9803                  break;
9804              }
9805              case value_t::number_integer:
9806              {
9807                  if (j.m_value.number_integer &gt;= 0)
9808                  {
9809                      if (j.m_value.number_integer &lt;= 0x17)
9810                      {
9811                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
9812                      }
9813                      else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
9814                      {
9815                          oa-&gt;write_character(to_char_type(0x18));
9816                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
9817                      }
9818                      else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
9819                      {
9820                          oa-&gt;write_character(to_char_type(0x19));
9821                          write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.number_integer));
9822                      }
9823                      else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
9824                      {
9825                          oa-&gt;write_character(to_char_type(0x1A));
9826                          write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.number_integer));
9827                      }
9828                      else
9829                      {
9830                          oa-&gt;write_character(to_char_type(0x1B));
9831                          write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.number_integer));
9832                      }
9833                  }
9834                  else
9835                  {
9836                      const auto positive_number = -1 - j.m_value.number_integer;
9837                      if (j.m_value.number_integer &gt;= -24)
9838                      {
9839                          write_number(static_cast&lt;std::uint8_t&gt;(0x20 + positive_number));
9840                      }
9841                      else if (positive_number &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
9842                      {
9843                          oa-&gt;write_character(to_char_type(0x38));
9844                          write_number(static_cast&lt;std::uint8_t&gt;(positive_number));
9845                      }
9846                      else if (positive_number &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
9847                      {
9848                          oa-&gt;write_character(to_char_type(0x39));
9849                          write_number(static_cast&lt;std::uint16_t&gt;(positive_number));
9850                      }
9851                      else if (positive_number &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
9852                      {
9853                          oa-&gt;write_character(to_char_type(0x3A));
9854                          write_number(static_cast&lt;std::uint32_t&gt;(positive_number));
9855                      }
9856                      else
9857                      {
9858                          oa-&gt;write_character(to_char_type(0x3B));
9859                          write_number(static_cast&lt;std::uint64_t&gt;(positive_number));
9860                      }
9861                  }
9862                  break;
9863              }
9864              case value_t::number_unsigned:
9865              {
9866                  if (j.m_value.number_unsigned &lt;= 0x17)
9867                  {
9868                      write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_unsigned));
9869                  }
9870                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
9871                  {
9872                      oa-&gt;write_character(to_char_type(0x18));
9873                      write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_unsigned));
9874                  }
9875                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
9876                  {
9877                      oa-&gt;write_character(to_char_type(0x19));
9878                      write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.number_unsigned));
9879                  }
9880                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
9881                  {
9882                      oa-&gt;write_character(to_char_type(0x1A));
9883                      write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.number_unsigned));
9884                  }
9885                  else
9886                  {
9887                      oa-&gt;write_character(to_char_type(0x1B));
9888                      write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.number_unsigned));
9889                  }
9890                  break;
9891              }
9892              case value_t::number_float:
9893              {
9894                  if (std::isnan(j.m_value.number_float))
9895                  {
9896                      oa-&gt;write_character(to_char_type(0xF9));
9897                      oa-&gt;write_character(to_char_type(0x7E));
9898                      oa-&gt;write_character(to_char_type(0x00));
9899                  }
9900                  else if (std::isinf(j.m_value.number_float))
9901                  {
9902                      oa-&gt;write_character(to_char_type(0xf9));
9903                      oa-&gt;write_character(j.m_value.number_float &gt; 0 ? to_char_type(0x7C) : to_char_type(0xFC));
9904                      oa-&gt;write_character(to_char_type(0x00));
9905                  }
9906                  else
9907                  {
9908                      write_compact_float(j.m_value.number_float, detail::input_format_t::cbor);
9909                  }
9910                  break;
9911              }
9912              case value_t::string:
9913              {
9914                  const auto N = j.m_value.string-&gt;size();
9915                  if (N &lt;= 0x17)
9916                  {
9917                      write_number(static_cast&lt;std::uint8_t&gt;(0x60 + N));
9918                  }
9919                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
9920                  {
9921                      oa-&gt;write_character(to_char_type(0x78));
9922                      write_number(static_cast&lt;std::uint8_t&gt;(N));
9923                  }
9924                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
9925                  {
9926                      oa-&gt;write_character(to_char_type(0x79));
9927                      write_number(static_cast&lt;std::uint16_t&gt;(N));
9928                  }
9929                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
9930                  {
9931                      oa-&gt;write_character(to_char_type(0x7A));
9932                      write_number(static_cast&lt;std::uint32_t&gt;(N));
9933                  }
9934                  else if (N &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
9935                  {
9936                      oa-&gt;write_character(to_char_type(0x7B));
9937                      write_number(static_cast&lt;std::uint64_t&gt;(N));
9938                  }
9939                  oa-&gt;write_characters(
9940                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
9941                      j.m_value.string-&gt;size());
9942                  break;
9943              }
9944              case value_t::array:
9945              {
9946                  const auto N = j.m_value.array-&gt;size();
9947                  if (N &lt;= 0x17)
9948                  {
9949                      write_number(static_cast&lt;std::uint8_t&gt;(0x80 + N));
9950                  }
9951                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
9952                  {
9953                      oa-&gt;write_character(to_char_type(0x98));
9954                      write_number(static_cast&lt;std::uint8_t&gt;(N));
9955                  }
9956                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
9957                  {
9958                      oa-&gt;write_character(to_char_type(0x99));
9959                      write_number(static_cast&lt;std::uint16_t&gt;(N));
9960                  }
9961                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
9962                  {
9963                      oa-&gt;write_character(to_char_type(0x9A));
9964                      write_number(static_cast&lt;std::uint32_t&gt;(N));
9965                  }
9966                  else if (N &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
9967                  {
9968                      oa-&gt;write_character(to_char_type(0x9B));
9969                      write_number(static_cast&lt;std::uint64_t&gt;(N));
9970                  }
9971                  for (const auto&amp; el : *j.m_value.array)
9972                  {
9973                      write_cbor(el);
9974                  }
9975                  break;
9976              }
9977              case value_t::binary:
9978              {
9979                  if (j.m_value.binary-&gt;has_subtype())
9980                  {
9981                      if (j.m_value.binary-&gt;subtype() &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
9982                      {
9983                          write_number(static_cast&lt;std::uint8_t&gt;(0xd8));
9984                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.binary-&gt;subtype()));
9985                      }
9986                      else if (j.m_value.binary-&gt;subtype() &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
9987                      {
9988                          write_number(static_cast&lt;std::uint8_t&gt;(0xd9));
9989                          write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.binary-&gt;subtype()));
9990                      }
9991                      else if (j.m_value.binary-&gt;subtype() &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
9992                      {
9993                          write_number(static_cast&lt;std::uint8_t&gt;(0xda));
9994                          write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.binary-&gt;subtype()));
9995                      }
9996                      else if (j.m_value.binary-&gt;subtype() &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
9997                      {
9998                          write_number(static_cast&lt;std::uint8_t&gt;(0xdb));
9999                          write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.binary-&gt;subtype()));
10000                      }
10001                  }
10002                  const auto N = j.m_value.binary-&gt;size();
10003                  if (N &lt;= 0x17)
10004                  {
10005                      write_number(static_cast&lt;std::uint8_t&gt;(0x40 + N));
10006                  }
10007                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10008                  {
10009                      oa-&gt;write_character(to_char_type(0x58));
10010                      write_number(static_cast&lt;std::uint8_t&gt;(N));
10011                  }
10012                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10013                  {
10014                      oa-&gt;write_character(to_char_type(0x59));
10015                      write_number(static_cast&lt;std::uint16_t&gt;(N));
10016                  }
10017                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10018                  {
10019                      oa-&gt;write_character(to_char_type(0x5A));
10020                      write_number(static_cast&lt;std::uint32_t&gt;(N));
10021                  }
10022                  else if (N &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
10023                  {
10024                      oa-&gt;write_character(to_char_type(0x5B));
10025                      write_number(static_cast&lt;std::uint64_t&gt;(N));
10026                  }
10027                  oa-&gt;write_characters(
10028                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.binary-&gt;data()),
10029                      N);
10030                  break;
10031              }
10032              case value_t::object:
10033              {
10034                  const auto N = j.m_value.object-&gt;size();
10035                  if (N &lt;= 0x17)
10036                  {
10037                      write_number(static_cast&lt;std::uint8_t&gt;(0xA0 + N));
10038                  }
10039                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10040                  {
10041                      oa-&gt;write_character(to_char_type(0xB8));
10042                      write_number(static_cast&lt;std::uint8_t&gt;(N));
10043                  }
10044                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10045                  {
10046                      oa-&gt;write_character(to_char_type(0xB9));
10047                      write_number(static_cast&lt;std::uint16_t&gt;(N));
10048                  }
10049                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10050                  {
10051                      oa-&gt;write_character(to_char_type(0xBA));
10052                      write_number(static_cast&lt;std::uint32_t&gt;(N));
10053                  }
10054                  else if (N &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
10055                  {
10056                      oa-&gt;write_character(to_char_type(0xBB));
10057                      write_number(static_cast&lt;std::uint64_t&gt;(N));
10058                  }
10059                  for (const auto&amp; el : *j.m_value.object)
10060                  {
10061                      write_cbor(el.first);
10062                      write_cbor(el.second);
10063                  }
10064                  break;
10065              }
10066              case value_t::discarded:
10067              default:
10068                  break;
10069          }
10070      }
10071      void write_msgpack(const BasicJsonType&amp; j)
10072      {
10073          switch (j.type())
10074          {
10075              case value_t::null: 
10076              {
10077                  oa-&gt;write_character(to_char_type(0xC0));
10078                  break;
10079              }
10080              case value_t::boolean: 
10081              {
10082                  oa-&gt;write_character(j.m_value.boolean
10083                                      ? to_char_type(0xC3)
10084                                      : to_char_type(0xC2));
10085                  break;
10086              }
10087              case value_t::number_integer:
10088              {
10089                  if (j.m_value.number_integer &gt;= 0)
10090                  {
10091                      if (j.m_value.number_unsigned &lt; 128)
10092                      {
10093                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
10094                      }
10095                      else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10096                      {
10097                          oa-&gt;write_character(to_char_type(0xCC));
10098                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
10099                      }
10100                      else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10101                      {
10102                          oa-&gt;write_character(to_char_type(0xCD));
10103                          write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.number_integer));
10104                      }
10105                      else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10106                      {
10107                          oa-&gt;write_character(to_char_type(0xCE));
10108                          write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.number_integer));
10109                      }
10110                      else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
10111                      {
10112                          oa-&gt;write_character(to_char_type(0xCF));
10113                          write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.number_integer));
10114                      }
10115                  }
10116                  else
10117                  {
10118                      if (j.m_value.number_integer &gt;= -32)
10119                      {
10120                          write_number(static_cast&lt;std::int8_t&gt;(j.m_value.number_integer));
10121                      }
10122                      else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;std::int8_t&gt;::min)() &amp;&amp;
10123                               j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int8_t&gt;::max)())
10124                      {
10125                          oa-&gt;write_character(to_char_type(0xD0));
10126                          write_number(static_cast&lt;std::int8_t&gt;(j.m_value.number_integer));
10127                      }
10128                      else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;std::int16_t&gt;::min)() &amp;&amp;
10129                               j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int16_t&gt;::max)())
10130                      {
10131                          oa-&gt;write_character(to_char_type(0xD1));
10132                          write_number(static_cast&lt;std::int16_t&gt;(j.m_value.number_integer));
10133                      }
10134                      else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;std::int32_t&gt;::min)() &amp;&amp;
10135                               j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)())
10136                      {
10137                          oa-&gt;write_character(to_char_type(0xD2));
10138                          write_number(static_cast&lt;std::int32_t&gt;(j.m_value.number_integer));
10139                      }
10140                      else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;std::int64_t&gt;::min)() &amp;&amp;
10141                               j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int64_t&gt;::max)())
10142                      {
10143                          oa-&gt;write_character(to_char_type(0xD3));
10144                          write_number(static_cast&lt;std::int64_t&gt;(j.m_value.number_integer));
10145                      }
10146                  }
10147                  break;
10148              }
10149              case value_t::number_unsigned:
10150              {
10151                  if (j.m_value.number_unsigned &lt; 128)
10152                  {
10153                      write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
10154                  }
10155                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10156                  {
10157                      oa-&gt;write_character(to_char_type(0xCC));
10158                      write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
10159                  }
10160                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10161                  {
10162                      oa-&gt;write_character(to_char_type(0xCD));
10163                      write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.number_integer));
10164                  }
10165                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10166                  {
10167                      oa-&gt;write_character(to_char_type(0xCE));
10168                      write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.number_integer));
10169                  }
10170                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
10171                  {
10172                      oa-&gt;write_character(to_char_type(0xCF));
10173                      write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.number_integer));
10174                  }
10175                  break;
10176              }
10177              case value_t::number_float:
10178              {
10179                  write_compact_float(j.m_value.number_float, detail::input_format_t::msgpack);
10180                  break;
10181              }
10182              case value_t::string:
10183              {
10184                  const auto N = j.m_value.string-&gt;size();
10185                  if (N &lt;= 31)
10186                  {
10187                      write_number(static_cast&lt;std::uint8_t&gt;(0xA0 | N));
10188                  }
10189                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10190                  {
10191                      oa-&gt;write_character(to_char_type(0xD9));
10192                      write_number(static_cast&lt;std::uint8_t&gt;(N));
10193                  }
10194                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10195                  {
10196                      oa-&gt;write_character(to_char_type(0xDA));
10197                      write_number(static_cast&lt;std::uint16_t&gt;(N));
10198                  }
10199                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10200                  {
10201                      oa-&gt;write_character(to_char_type(0xDB));
10202                      write_number(static_cast&lt;std::uint32_t&gt;(N));
10203                  }
10204                  oa-&gt;write_characters(
10205                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
10206                      j.m_value.string-&gt;size());
10207                  break;
10208              }
10209              case value_t::array:
10210              {
10211                  const auto N = j.m_value.array-&gt;size();
10212                  if (N &lt;= 15)
10213                  {
10214                      write_number(static_cast&lt;std::uint8_t&gt;(0x90 | N));
10215                  }
10216                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10217                  {
10218                      oa-&gt;write_character(to_char_type(0xDC));
10219                      write_number(static_cast&lt;std::uint16_t&gt;(N));
10220                  }
10221                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10222                  {
10223                      oa-&gt;write_character(to_char_type(0xDD));
10224                      write_number(static_cast&lt;std::uint32_t&gt;(N));
10225                  }
10226                  for (const auto&amp; el : *j.m_value.array)
10227                  {
10228                      write_msgpack(el);
10229                  }
10230                  break;
10231              }
10232              case value_t::binary:
10233              {
10234                  const bool use_ext = j.m_value.binary-&gt;has_subtype();
10235                  const auto N = j.m_value.binary-&gt;size();
10236                  if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10237                  {
10238                      std::uint8_t output_type{};
10239                      bool fixed = true;
10240                      if (use_ext)
10241                      {
10242                          switch (N)
10243                          {
10244                              case 1:
10245                                  output_type = 0xD4; 
10246                                  break;
10247                              case 2:
10248                                  output_type = 0xD5; 
10249                                  break;
10250                              case 4:
10251                                  output_type = 0xD6; 
10252                                  break;
10253                              case 8:
10254                                  output_type = 0xD7; 
10255                                  break;
10256                              case 16:
10257                                  output_type = 0xD8; 
10258                                  break;
10259                              default:
10260                                  output_type = 0xC7; 
10261                                  fixed = false;
10262                                  break;
10263                          }
10264                      }
10265                      else
10266                      {
10267                          output_type = 0xC4; 
10268                          fixed = false;
10269                      }
10270                      oa-&gt;write_character(to_char_type(output_type));
10271                      if (!fixed)
10272                      {
10273                          write_number(static_cast&lt;std::uint8_t&gt;(N));
10274                      }
10275                  }
10276                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10277                  {
10278                      std::uint8_t output_type = use_ext
10279                                                 ? 0xC8 
10280                                                 : 0xC5; 
10281                      oa-&gt;write_character(to_char_type(output_type));
10282                      write_number(static_cast&lt;std::uint16_t&gt;(N));
10283                  }
10284                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10285                  {
10286                      std::uint8_t output_type = use_ext
10287                                                 ? 0xC9 
10288                                                 : 0xC6; 
10289                      oa-&gt;write_character(to_char_type(output_type));
10290                      write_number(static_cast&lt;std::uint32_t&gt;(N));
10291                  }
10292                  if (use_ext)
10293                  {
10294                      write_number(static_cast&lt;std::int8_t&gt;(j.m_value.binary-&gt;subtype()));
10295                  }
10296                  oa-&gt;write_characters(
10297                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.binary-&gt;data()),
10298                      N);
10299                  break;
10300              }
10301              case value_t::object:
10302              {
10303                  const auto N = j.m_value.object-&gt;size();
10304                  if (N &lt;= 15)
10305                  {
10306                      write_number(static_cast&lt;std::uint8_t&gt;(0x80 | (N &amp; 0xF)));
10307                  }
10308                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10309                  {
10310                      oa-&gt;write_character(to_char_type(0xDE));
10311                      write_number(static_cast&lt;std::uint16_t&gt;(N));
10312                  }
10313                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10314                  {
10315                      oa-&gt;write_character(to_char_type(0xDF));
10316                      write_number(static_cast&lt;std::uint32_t&gt;(N));
10317                  }
10318                  for (const auto&amp; el : *j.m_value.object)
10319                  {
10320                      write_msgpack(el.first);
10321                      write_msgpack(el.second);
10322                  }
10323                  break;
10324              }
10325              case value_t::discarded:
10326              default:
10327                  break;
10328          }
10329      }
10330      void write_ubjson(const BasicJsonType&amp; j, const bool use_count,
10331                        const bool use_type, const bool add_prefix = true)
10332      {
10333          switch (j.type())
10334          {
10335              case value_t::null:
10336              {
10337                  if (add_prefix)
10338                  {
10339                      oa-&gt;write_character(to_char_type(&#x27;Z&#x27;));
10340                  }
10341                  break;
10342              }
10343              case value_t::boolean:
10344              {
10345                  if (add_prefix)
10346                  {
10347                      oa-&gt;write_character(j.m_value.boolean
10348                                          ? to_char_type(&#x27;T&#x27;)
10349                                          : to_char_type(&#x27;F&#x27;));
10350                  }
10351                  break;
10352              }
10353              case value_t::number_integer:
10354              {
10355                  write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
10356                  break;
10357              }
10358              case value_t::number_unsigned:
10359              {
10360                  write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
10361                  break;
10362              }
10363              case value_t::number_float:
10364              {
10365                  write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
10366                  break;
10367              }
10368              case value_t::string:
10369              {
10370                  if (add_prefix)
10371                  {
10372                      oa-&gt;write_character(to_char_type(&#x27;S&#x27;));
10373                  }
10374                  write_number_with_ubjson_prefix(j.m_value.string-&gt;size(), true);
10375                  oa-&gt;write_characters(
10376                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
10377                      j.m_value.string-&gt;size());
10378                  break;
10379              }
10380              case value_t::array:
10381              {
10382                  if (add_prefix)
10383                  {
10384                      oa-&gt;write_character(to_char_type(&#x27;[&#x27;));
10385                  }
10386                  bool prefix_required = true;
10387                  if (use_type &amp;&amp; !j.m_value.array-&gt;empty())
10388                  {
10389                      JSON_ASSERT(use_count);
10390                      const CharType first_prefix = ubjson_prefix(j.front());
10391                      const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
10392                                                           [this, first_prefix](const BasicJsonType &amp; v)
10393                      {
10394                          return ubjson_prefix(v) == first_prefix;
10395                      });
10396                      if (same_prefix)
10397                      {
10398                          prefix_required = false;
10399                          oa-&gt;write_character(to_char_type(&#x27;$&#x27;));
10400                          oa-&gt;write_character(first_prefix);
10401                      }
10402                  }
10403                  if (use_count)
10404                  {
10405                      oa-&gt;write_character(to_char_type(&#x27;#&#x27;));
10406                      write_number_with_ubjson_prefix(j.m_value.array-&gt;size(), true);
10407                  }
10408                  for (const auto&amp; el : *j.m_value.array)
10409                  {
10410                      write_ubjson(el, use_count, use_type, prefix_required);
10411                  }
10412                  if (!use_count)
10413                  {
10414                      oa-&gt;write_character(to_char_type(&#x27;]&#x27;));
10415                  }
10416                  break;
10417              }
10418              case value_t::binary:
10419              {
10420                  if (add_prefix)
10421                  {
10422                      oa-&gt;write_character(to_char_type(&#x27;[&#x27;));
10423                  }
10424                  if (use_type &amp;&amp; !j.m_value.binary-&gt;empty())
10425                  {
10426                      JSON_ASSERT(use_count);
10427                      oa-&gt;write_character(to_char_type(&#x27;$&#x27;));
10428                      oa-&gt;write_character(&#x27;U&#x27;);
10429                  }
10430                  if (use_count)
10431                  {
10432                      oa-&gt;write_character(to_char_type(&#x27;#&#x27;));
10433                      write_number_with_ubjson_prefix(j.m_value.binary-&gt;size(), true);
10434                  }
10435                  if (use_type)
10436                  {
10437                      oa-&gt;write_characters(
10438                          reinterpret_cast&lt;const CharType*&gt;(j.m_value.binary-&gt;data()),
10439                          j.m_value.binary-&gt;size());
10440                  }
10441                  else
10442                  {
10443                      for (size_t i = 0; i &lt; j.m_value.binary-&gt;size(); ++i)
10444                      {
10445                          oa-&gt;write_character(to_char_type(&#x27;U&#x27;));
10446                          oa-&gt;write_character(j.m_value.binary-&gt;data()[i]);
10447                      }
10448                  }
10449                  if (!use_count)
10450                  {
10451                      oa-&gt;write_character(to_char_type(&#x27;]&#x27;));
10452                  }
10453                  break;
10454              }
10455              case value_t::object:
10456              {
10457                  if (add_prefix)
10458                  {
10459                      oa-&gt;write_character(to_char_type(&#x27;{&#x27;));
10460                  }
10461                  bool prefix_required = true;
10462                  if (use_type &amp;&amp; !j.m_value.object-&gt;empty())
10463                  {
10464                      JSON_ASSERT(use_count);
10465                      const CharType first_prefix = ubjson_prefix(j.front());
10466                      const bool same_prefix = std::all_of(j.begin(), j.end(),
10467                                                           [this, first_prefix](const BasicJsonType &amp; v)
10468                      {
10469                          return ubjson_prefix(v) == first_prefix;
10470                      });
10471                      if (same_prefix)
10472                      {
10473                          prefix_required = false;
10474                          oa-&gt;write_character(to_char_type(&#x27;$&#x27;));
10475                          oa-&gt;write_character(first_prefix);
10476                      }
10477                  }
10478                  if (use_count)
10479                  {
10480                      oa-&gt;write_character(to_char_type(&#x27;#&#x27;));
10481                      write_number_with_ubjson_prefix(j.m_value.object-&gt;size(), true);
10482                  }
10483                  for (const auto&amp; el : *j.m_value.object)
10484                  {
10485                      write_number_with_ubjson_prefix(el.first.size(), true);
10486                      oa-&gt;write_characters(
10487                          reinterpret_cast&lt;const CharType*&gt;(el.first.c_str()),
10488                          el.first.size());
10489                      write_ubjson(el.second, use_count, use_type, prefix_required);
10490                  }
10491                  if (!use_count)
10492                  {
10493                      oa-&gt;write_character(to_char_type(&#x27;}&#x27;));
10494                  }
10495                  break;
10496              }
10497              case value_t::discarded:
10498              default:
10499                  break;
10500          }
10501      }
10502    private:
10503      static std::size_t calc_bson_entry_header_size(const string_t&amp; name, const BasicJsonType&amp; j)
10504      {
10505          const auto it = name.find(static_cast&lt;typename string_t::value_type&gt;(0));
10506          if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
10507          {
10508              JSON_THROW(out_of_range::create(409, &quot;BSON key cannot contain code point U+0000 (at byte &quot; + std::to_string(it) + &quot;)&quot;, j));
10509              static_cast&lt;void&gt;(j);
10510          }
10511          return &amp;bsol;*id*/ 1ul + name.size() + &amp;bsol;*zero-terminator*/1u;
10512      }
10513      void write_bson_entry_header(const string_t&amp; name,
10514                                   const std::uint8_t element_type)
10515      {
10516          oa-&gt;write_character(to_char_type(element_type)); 
10517          oa-&gt;write_characters(
10518              reinterpret_cast&lt;const CharType*&gt;(name.c_str()),
10519              name.size() + 1u);
10520      }
10521      void write_bson_boolean(const string_t&amp; name,
10522                              const bool value)
10523      {
10524          write_bson_entry_header(name, 0x08);
10525          oa-&gt;write_character(value ? to_char_type(0x01) : to_char_type(0x00));
10526      }
10527      void write_bson_double(const string_t&amp; name,
10528                             const double value)
10529      {
10530          write_bson_entry_header(name, 0x01);
10531          write_number&lt;double, true&gt;(value);
10532      }
10533      static std::size_t calc_bson_string_size(const string_t&amp; value)
10534      {
10535          return sizeof(std::int32_t) + value.size() + 1ul;
10536      }
10537      void write_bson_string(const string_t&amp; name,
10538                             const string_t&amp; value)
10539      {
10540          write_bson_entry_header(name, 0x02);
10541          write_number&lt;std::int32_t, true&gt;(static_cast&lt;std::int32_t&gt;(value.size() + 1ul));
10542          oa-&gt;write_characters(
10543              reinterpret_cast&lt;const CharType*&gt;(value.c_str()),
10544              value.size() + 1);
10545      }
10546      void write_bson_null(const string_t&amp; name)
10547      {
10548          write_bson_entry_header(name, 0x0A);
10549      }
10550      static std::size_t calc_bson_integer_size(const std::int64_t value)
10551      {
10552          return (std::numeric_limits&lt;std::int32_t&gt;::min)() &lt;= value &amp;&amp; value &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)()
10553                 ? sizeof(std::int32_t)
10554                 : sizeof(std::int64_t);
10555      }
10556      void write_bson_integer(const string_t&amp; name,
10557                              const std::int64_t value)
10558      {
10559          if ((std::numeric_limits&lt;std::int32_t&gt;::min)() &lt;= value &amp;&amp; value &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)())
10560          {
10561              write_bson_entry_header(name, 0x10); 
10562              write_number&lt;std::int32_t, true&gt;(static_cast&lt;std::int32_t&gt;(value));
10563          }
10564          else
10565          {
10566              write_bson_entry_header(name, 0x12); 
10567              write_number&lt;std::int64_t, true&gt;(static_cast&lt;std::int64_t&gt;(value));
10568          }
10569      }
10570      static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
10571      {
10572          return (value &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int32_t&gt;::max)()))
10573                 ? sizeof(std::int32_t)
10574                 : sizeof(std::int64_t);
10575      }
10576      void write_bson_unsigned(const string_t&amp; name,
10577                               const BasicJsonType&amp; j)
10578      {
10579          if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int32_t&gt;::max)()))
10580          {
10581              write_bson_entry_header(name, 0x10 &amp;bsol;* int32 */);
10582              write_number&lt;std::int32_t, true&gt;(static_cast&lt;std::int32_t&gt;(j.m_value.number_unsigned));
10583          }
10584          else if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int64_t&gt;::max)()))
10585          {
10586              write_bson_entry_header(name, 0x12 &amp;bsol;* int64 */);
10587              write_number&lt;std::int64_t, true&gt;(static_cast&lt;std::int64_t&gt;(j.m_value.number_unsigned));
10588          }
10589          else
10590          {
10591              JSON_THROW(out_of_range::create(407, &quot;integer number &quot; + std::to_string(j.m_value.number_unsigned) + &quot; cannot be represented by BSON as it does not fit int64&quot;, j));
10592          }
10593      }
10594      void write_bson_object_entry(const string_t&amp; name,
10595                                   const typename BasicJsonType::object_t&amp; value)
10596      {
10597          write_bson_entry_header(name, 0x03); 
10598          write_bson_object(value);
10599      }
10600      static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t&amp; value)
10601      {
10602          std::size_t array_index = 0ul;
10603          const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), std::size_t(0), [&amp;array_index](std::size_t result, const typename BasicJsonType::array_t::value_type &amp; el)
10604          {
10605              return result + calc_bson_element_size(std::to_string(array_index++), el);
10606          });
10607          return sizeof(std::int32_t) + embedded_document_size + 1ul;
10608      }
10609      static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t&amp; value)
10610      {
10611          return sizeof(std::int32_t) + value.size() + 1ul;
10612      }
10613      void write_bson_array(const string_t&amp; name,
10614                            const typename BasicJsonType::array_t&amp; value)
10615      {
10616          write_bson_entry_header(name, 0x04); 
10617          write_number&lt;std::int32_t, true&gt;(static_cast&lt;std::int32_t&gt;(calc_bson_array_size(value)));
10618          std::size_t array_index = 0ul;
10619          for (const auto&amp; el : value)
10620          {
10621              write_bson_element(std::to_string(array_index++), el);
10622          }
10623          oa-&gt;write_character(to_char_type(0x00));
10624      }
10625      void write_bson_binary(const string_t&amp; name,
10626                             const binary_t&amp; value)
10627      {
10628          write_bson_entry_header(name, 0x05);
10629          write_number&lt;std::int32_t, true&gt;(static_cast&lt;std::int32_t&gt;(value.size()));
10630          write_number(value.has_subtype() ? static_cast&lt;std::uint8_t&gt;(value.subtype()) : std::uint8_t(0x00));
10631          oa-&gt;write_characters(reinterpret_cast&lt;const CharType*&gt;(value.data()), value.size());
10632      }
10633      static std::size_t calc_bson_element_size(const string_t&amp; name,
10634              const BasicJsonType&amp; j)
10635      {
10636          const auto header_size = calc_bson_entry_header_size(name, j);
10637          switch (j.type())
10638          {
10639              case value_t::object:
10640                  return header_size + calc_bson_object_size(*j.m_value.object);
10641              case value_t::array:
10642                  return header_size + calc_bson_array_size(*j.m_value.array);
10643              case value_t::binary:
10644                  return header_size + calc_bson_binary_size(*j.m_value.binary);
10645              case value_t::boolean:
10646                  return header_size + 1ul;
10647              case value_t::number_float:
10648                  return header_size + 8ul;
10649              case value_t::number_integer:
10650                  return header_size + calc_bson_integer_size(j.m_value.number_integer);
10651              case value_t::number_unsigned:
10652                  return header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);
10653              case value_t::string:
10654                  return header_size + calc_bson_string_size(*j.m_value.string);
10655              case value_t::null:
10656                  return header_size + 0ul;
10657              case value_t::discarded:
10658              default:
10659                  JSON_ASSERT(false); 
10660                  return 0ul;
10661          }
10662      }
10663      void write_bson_element(const string_t&amp; name,
10664                              const BasicJsonType&amp; j)
10665      {
10666          switch (j.type())
10667          {
10668              case value_t::object:
10669                  return write_bson_object_entry(name, *j.m_value.object);
10670              case value_t::array:
10671                  return write_bson_array(name, *j.m_value.array);
10672              case value_t::binary:
10673                  return write_bson_binary(name, *j.m_value.binary);
10674              case value_t::boolean:
10675                  return write_bson_boolean(name, j.m_value.boolean);
10676              case value_t::number_float:
10677                  return write_bson_double(name, j.m_value.number_float);
10678              case value_t::number_integer:
10679                  return write_bson_integer(name, j.m_value.number_integer);
10680              case value_t::number_unsigned:
10681                  return write_bson_unsigned(name, j);
10682              case value_t::string:
10683                  return write_bson_string(name, *j.m_value.string);
10684              case value_t::null:
10685                  return write_bson_null(name);
10686              case value_t::discarded:
10687              default:
10688                  JSON_ASSERT(false); 
10689                  return;
10690          }
10691      }
10692      static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t&amp; value)
10693      {
10694          std::size_t document_size = std::accumulate(value.begin(), value.end(), std::size_t(0),
10695                                      [](size_t result, const typename BasicJsonType::object_t::value_type &amp; el)
10696          {
10697              return result += calc_bson_element_size(el.first, el.second);
10698          });
10699          return sizeof(std::int32_t) + document_size + 1ul;
10700      }
10701      void write_bson_object(const typename BasicJsonType::object_t&amp; value)
10702      {
10703          write_number&lt;std::int32_t, true&gt;(static_cast&lt;std::int32_t&gt;(calc_bson_object_size(value)));
10704          for (const auto&amp; el : value)
10705          {
10706              write_bson_element(el.first, el.second);
10707          }
10708          oa-&gt;write_character(to_char_type(0x00));
10709      }
10710      static constexpr CharType get_cbor_float_prefix(float &amp;bsol;*unused*/)
10711      {
10712          return to_char_type(0xFA);  
10713      }
10714      static constexpr CharType get_cbor_float_prefix(double &amp;bsol;*unused*/)
10715      {
10716          return to_char_type(0xFB);  
10717      }
10718      static constexpr CharType get_msgpack_float_prefix(float &amp;bsol;*unused*/)
10719      {
10720          return to_char_type(0xCA);  
10721      }
10722      static constexpr CharType get_msgpack_float_prefix(double &amp;bsol;*unused*/)
10723      {
10724          return to_char_type(0xCB);  
10725      }
10726      template&lt;typename NumberType, typename std::enable_if&lt;
10727                   std::is_floating_point&lt;NumberType&gt;::value, int&gt;::type = 0&gt;
10728      void write_number_with_ubjson_prefix(const NumberType n,
10729                                           const bool add_prefix)
10730      {
10731          if (add_prefix)
10732          {
10733              oa-&gt;write_character(get_ubjson_float_prefix(n));
10734          }
10735          write_number(n);
10736      }
10737      template&lt;typename NumberType, typename std::enable_if&lt;
10738                   std::is_unsigned&lt;NumberType&gt;::value, int&gt;::type = 0&gt;
10739      void write_number_with_ubjson_prefix(const NumberType n,
10740                                           const bool add_prefix)
10741      {
10742          if (n &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int8_t&gt;::max)()))
10743          {
10744              if (add_prefix)
10745              {
10746                  oa-&gt;write_character(to_char_type(&#x27;i&#x27;));  
10747              }
10748              write_number(static_cast&lt;std::uint8_t&gt;(n));
10749          }
10750          else if (n &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10751          {
10752              if (add_prefix)
10753              {
10754                  oa-&gt;write_character(to_char_type(&#x27;U&#x27;));  
10755              }
10756              write_number(static_cast&lt;std::uint8_t&gt;(n));
10757          }
10758          else if (n &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int16_t&gt;::max)()))
10759          {
10760              if (add_prefix)
10761              {
10762                  oa-&gt;write_character(to_char_type(&#x27;I&#x27;));  
10763              }
10764              write_number(static_cast&lt;std::int16_t&gt;(n));
10765          }
10766          else if (n &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int32_t&gt;::max)()))
10767          {
10768              if (add_prefix)
10769              {
10770                  oa-&gt;write_character(to_char_type(&#x27;l&#x27;));  
10771              }
10772              write_number(static_cast&lt;std::int32_t&gt;(n));
10773          }
10774          else if (n &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int64_t&gt;::max)()))
10775          {
10776              if (add_prefix)
10777              {
10778                  oa-&gt;write_character(to_char_type(&#x27;L&#x27;));  
10779              }
10780              write_number(static_cast&lt;std::int64_t&gt;(n));
10781          }
10782          else
10783          {
10784              if (add_prefix)
10785              {
10786                  oa-&gt;write_character(to_char_type(&#x27;H&#x27;));  
10787              }
10788              const auto number = BasicJsonType(n).dump();
10789              write_number_with_ubjson_prefix(number.size(), true);
10790              for (std::size_t i = 0; i &lt; number.size(); ++i)
10791              {
10792                  oa-&gt;write_character(to_char_type(static_cast&lt;std::uint8_t&gt;(number[i])));
10793              }
10794          }
10795      }
10796      template &lt; typename NumberType, typename std::enable_if &lt;
10797                     std::is_signed&lt;NumberType&gt;::value&amp;&amp;
10798                     !std::is_floating_point&lt;NumberType&gt;::value, int &gt;::type = 0 &gt;
10799      void write_number_with_ubjson_prefix(const NumberType n,
10800                                           const bool add_prefix)
10801      {
10802          if ((std::numeric_limits&lt;std::int8_t&gt;::min)() &lt;= n &amp;&amp; n &lt;= (std::numeric_limits&lt;std::int8_t&gt;::max)())
10803          {
10804              if (add_prefix)
10805              {
10806                  oa-&gt;write_character(to_char_type(&#x27;i&#x27;));  
10807              }
10808              write_number(static_cast&lt;std::int8_t&gt;(n));
10809          }
10810          else if (static_cast&lt;std::int64_t&gt;((std::numeric_limits&lt;std::uint8_t&gt;::min)()) &lt;= n &amp;&amp; n &lt;= static_cast&lt;std::int64_t&gt;((std::numeric_limits&lt;std::uint8_t&gt;::max)()))
10811          {
10812              if (add_prefix)
10813              {
10814                  oa-&gt;write_character(to_char_type(&#x27;U&#x27;));  
10815              }
10816              write_number(static_cast&lt;std::uint8_t&gt;(n));
10817          }
10818          else if ((std::numeric_limits&lt;std::int16_t&gt;::min)() &lt;= n &amp;&amp; n &lt;= (std::numeric_limits&lt;std::int16_t&gt;::max)())
10819          {
10820              if (add_prefix)
10821              {
10822                  oa-&gt;write_character(to_char_type(&#x27;I&#x27;));  
10823              }
10824              write_number(static_cast&lt;std::int16_t&gt;(n));
10825          }
10826          else if ((std::numeric_limits&lt;std::int32_t&gt;::min)() &lt;= n &amp;&amp; n &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)())
10827          {
10828              if (add_prefix)
10829              {
10830                  oa-&gt;write_character(to_char_type(&#x27;l&#x27;));  
10831              }
10832              write_number(static_cast&lt;std::int32_t&gt;(n));
10833          }
10834          else if ((std::numeric_limits&lt;std::int64_t&gt;::min)() &lt;= n &amp;&amp; n &lt;= (std::numeric_limits&lt;std::int64_t&gt;::max)())
10835          {
10836              if (add_prefix)
10837              {
10838                  oa-&gt;write_character(to_char_type(&#x27;L&#x27;));  
10839              }
10840              write_number(static_cast&lt;std::int64_t&gt;(n));
10841          }
10842          else
10843          {
10844              if (add_prefix)
10845              {
10846                  oa-&gt;write_character(to_char_type(&#x27;H&#x27;));  
10847              }
10848              const auto number = BasicJsonType(n).dump();
10849              write_number_with_ubjson_prefix(number.size(), true);
10850              for (std::size_t i = 0; i &lt; number.size(); ++i)
10851              {
10852                  oa-&gt;write_character(to_char_type(static_cast&lt;std::uint8_t&gt;(number[i])));
10853              }
10854          }
10855      }
10856      CharType ubjson_prefix(const BasicJsonType&amp; j) const noexcept
10857      {
10858          switch (j.type())
10859          {
10860              case value_t::null:
10861                  return &#x27;Z&#x27;;
10862              case value_t::boolean:
10863                  return j.m_value.boolean ? &#x27;T&#x27; : &#x27;F&#x27;;
10864              case value_t::number_integer:
10865              {
10866                  if ((std::numeric_limits&lt;std::int8_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int8_t&gt;::max)())
10867                  {
10868                      return &#x27;i&#x27;;
10869                  }
10870                  if ((std::numeric_limits&lt;std::uint8_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10871                  {
10872                      return &#x27;U&#x27;;
10873                  }
10874                  if ((std::numeric_limits&lt;std::int16_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int16_t&gt;::max)())
10875                  {
10876                      return &#x27;I&#x27;;
10877                  }
10878                  if ((std::numeric_limits&lt;std::int32_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)())
10879                  {
10880                      return &#x27;l&#x27;;
10881                  }
10882                  if ((std::numeric_limits&lt;std::int64_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int64_t&gt;::max)())
10883                  {
10884                      return &#x27;L&#x27;;
10885                  }
10886                  return &#x27;H&#x27;; 
10887              }
10888              case value_t::number_unsigned:
10889              {
10890                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int8_t&gt;::max)()))
10891                  {
10892                      return &#x27;i&#x27;;
10893                  }
10894                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::uint8_t&gt;::max)()))
10895                  {
10896                      return &#x27;U&#x27;;
10897                  }
10898                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int16_t&gt;::max)()))
10899                  {
10900                      return &#x27;I&#x27;;
10901                  }
10902                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int32_t&gt;::max)()))
10903                  {
10904                      return &#x27;l&#x27;;
10905                  }
10906                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int64_t&gt;::max)()))
10907                  {
10908                      return &#x27;L&#x27;;
10909                  }
10910                  return &#x27;H&#x27;; 
10911              }
10912              case value_t::number_float:
10913                  return get_ubjson_float_prefix(j.m_value.number_float);
10914              case value_t::string:
10915                  return &#x27;S&#x27;;
10916              case value_t::array: 
10917              case value_t::binary:
10918                  return &#x27;[&#x27;;
10919              case value_t::object:
10920                  return &#x27;{&#x27;;
10921              case value_t::discarded:
10922              default:  
10923                  return &#x27;N&#x27;;
10924          }
10925      }
10926      static constexpr CharType get_ubjson_float_prefix(float &amp;bsol;*unused*/)
10927      {
10928          return &#x27;d&#x27;;  
10929      }
10930      static constexpr CharType get_ubjson_float_prefix(double &amp;bsol;*unused*/)
10931      {
10932          return &#x27;D&#x27;;  
10933      }
10934      template&lt;typename NumberType, bool OutputIsLittleEndian = false&gt;
10935      void write_number(const NumberType n)
10936      {
10937          std::array&lt;CharType, sizeof(NumberType)&gt; vec{};
10938          std::memcpy(vec.data(), &amp;n, sizeof(NumberType));
10939          if (is_little_endian != OutputIsLittleEndian)
10940          {
10941              std::reverse(vec.begin(), vec.end());
10942          }
10943          oa-&gt;write_characters(vec.data(), sizeof(NumberType));
10944      }
10945      void write_compact_float(const number_float_t n, detail::input_format_t format)
10946      {
10947  #ifdef __GNUC__
10948  #pragma GCC diagnostic push
10949  #pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;
10950  #endif
10951          if (static_cast&lt;double&gt;(n) &gt;= static_cast&lt;double&gt;(std::numeric_limits&lt;float&gt;::lowest()) &amp;&amp;
10952                  static_cast&lt;double&gt;(n) &lt;= static_cast&lt;double&gt;((std::numeric_limits&lt;float&gt;::max)()) &amp;&amp;
10953                  static_cast&lt;double&gt;(static_cast&lt;float&gt;(n)) == static_cast&lt;double&gt;(n))
10954          {
10955              oa-&gt;write_character(format == detail::input_format_t::cbor
10956                                  ? get_cbor_float_prefix(static_cast&lt;float&gt;(n))
10957                                  : get_msgpack_float_prefix(static_cast&lt;float&gt;(n)));
10958              write_number(static_cast&lt;float&gt;(n));
10959          }
10960          else
10961          {
10962              oa-&gt;write_character(format == detail::input_format_t::cbor
10963                                  ? get_cbor_float_prefix(n)
10964                                  : get_msgpack_float_prefix(n));
10965              write_number(n);
10966          }
10967  #ifdef __GNUC__
10968  #pragma GCC diagnostic pop
10969  #endif
10970      }
10971    public:
10972      template &lt; typename C = CharType,
10973                 enable_if_t &lt; std::is_signed&lt;C&gt;::value &amp;&amp; std::is_signed&lt;char&gt;::value &gt; * = nullptr &gt;
10974      static constexpr CharType to_char_type(std::uint8_t x) noexcept
10975      {
10976          return *reinterpret_cast&lt;char*&gt;(&amp;x);
10977      }
10978      template &lt; typename C = CharType,
10979                 enable_if_t &lt; std::is_signed&lt;C&gt;::value &amp;&amp; std::is_unsigned&lt;char&gt;::value &gt; * = nullptr &gt;
10980      static CharType to_char_type(std::uint8_t x) noexcept
10981      {
10982          static_assert(sizeof(std::uint8_t) == sizeof(CharType), &quot;size of CharType must be equal to std::uint8_t&quot;);
10983          static_assert(std::is_trivial&lt;CharType&gt;::value, &quot;CharType must be trivial&quot;);
10984          CharType result;
10985          std::memcpy(&amp;result, &amp;x, sizeof(x));
10986          return result;
10987      }
10988      template&lt;typename C = CharType,
10989               enable_if_t&lt;std::is_unsigned&lt;C&gt;::value&gt;* = nullptr&gt;
10990      static constexpr CharType to_char_type(std::uint8_t x) noexcept
10991      {
10992          return x;
10993      }
10994      template &lt; typename InputCharType, typename C = CharType,
10995                 enable_if_t &lt;
10996                     std::is_signed&lt;C&gt;::value &amp;&amp;
10997                     std::is_signed&lt;char&gt;::value &amp;&amp;
10998                     std::is_same&lt;char, typename std::remove_cv&lt;InputCharType&gt;::type&gt;::value
10999                     &gt; * = nullptr &gt;
11000      static constexpr CharType to_char_type(InputCharType x) noexcept
11001      {
11002          return x;
11003      }
11004    private:
11005      const bool is_little_endian = little_endianess();
11006      output_adapter_t&lt;CharType&gt; oa = nullptr;
11007  };
11008  }  
11009  }  
11010  #include &lt;algorithm&gt; 
11011  #include &lt;array&gt; 
11012  #include &lt;clocale&gt; 
11013  #include &lt;cmath&gt; 
11014  #include &lt;cstddef&gt; 
11015  #include &lt;cstdint&gt; 
11016  #include &lt;cstdio&gt; 
11017  #include &lt;limits&gt; 
11018  #include &lt;string&gt; 
11019  #include &lt;type_traits&gt; 
11020  #include &lt;utility&gt; 
11021  #include &lt;array&gt; 
11022  #include &lt;cmath&gt;   
11023  #include &lt;cstdint&gt; 
11024  #include &lt;cstring&gt; 
11025  #include &lt;limits&gt; 
11026  #include &lt;type_traits&gt; 
11027  namespace nlohmann
11028  {
11029  namespace detail
11030  {
11031  namespace dtoa_impl
11032  {
11033  template&lt;typename Target, typename Source&gt;
11034  Target reinterpret_bits(const Source source)
11035  {
11036      static_assert(sizeof(Target) == sizeof(Source), &quot;size mismatch&quot;);
11037      Target target;
11038      std::memcpy(&amp;target, &amp;source, sizeof(Source));
11039      return target;
11040  }
11041  struct diyfp 
11042  {
11043      static constexpr int kPrecision = 64; 
11044      std::uint64_t f = 0;
11045      int e = 0;
11046      constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}
11047      static diyfp sub(const diyfp&amp; x, const diyfp&amp; y) noexcept
11048      {
11049          JSON_ASSERT(x.e == y.e);
11050          JSON_ASSERT(x.f &gt;= y.f);
11051          return {x.f - y.f, x.e};
11052      }
11053      static diyfp mul(const diyfp&amp; x, const diyfp&amp; y) noexcept
11054      {
11055          static_assert(kPrecision == 64, &quot;internal error&quot;);
11056          const std::uint64_t u_lo = x.f &amp; 0xFFFFFFFFu;
11057          const std::uint64_t u_hi = x.f &gt;&gt; 32u;
11058          const std::uint64_t v_lo = y.f &amp; 0xFFFFFFFFu;
11059          const std::uint64_t v_hi = y.f &gt;&gt; 32u;
11060          const std::uint64_t p0 = u_lo * v_lo;
11061          const std::uint64_t p1 = u_lo * v_hi;
11062          const std::uint64_t p2 = u_hi * v_lo;
11063          const std::uint64_t p3 = u_hi * v_hi;
11064          const std::uint64_t p0_hi = p0 &gt;&gt; 32u;
11065          const std::uint64_t p1_lo = p1 &amp; 0xFFFFFFFFu;
11066          const std::uint64_t p1_hi = p1 &gt;&gt; 32u;
11067          const std::uint64_t p2_lo = p2 &amp; 0xFFFFFFFFu;
11068          const std::uint64_t p2_hi = p2 &gt;&gt; 32u;
11069          std::uint64_t Q = p0_hi + p1_lo + p2_lo;
11070          Q += std::uint64_t{1} &lt;&lt; (64u - 32u - 1u); 
11071          const std::uint64_t h = p3 + p2_hi + p1_hi + (Q &gt;&gt; 32u);
11072          return {h, x.e + y.e + 64};
11073      }
11074      static diyfp normalize(diyfp x) noexcept
11075      {
11076          JSON_ASSERT(x.f != 0);
11077          while ((x.f &gt;&gt; 63u) == 0)
11078          {
11079              x.f &lt;&lt;= 1u;
11080              x.e--;
11081          }
11082          return x;
11083      }
11084      static diyfp normalize_to(const diyfp&amp; x, const int target_exponent) noexcept
11085      {
11086          const int delta = x.e - target_exponent;
11087          JSON_ASSERT(delta &gt;= 0);
11088          JSON_ASSERT(((x.f &lt;&lt; delta) &gt;&gt; delta) == x.f);
11089          return {x.f &lt;&lt; delta, target_exponent};
11090      }
11091  };
11092  struct boundaries
11093  {
11094      diyfp w;
11095      diyfp minus;
11096      diyfp plus;
11097  };
11098  template&lt;typename FloatType&gt;
11099  boundaries compute_boundaries(FloatType value)
11100  {
11101      JSON_ASSERT(std::isfinite(value));
11102      JSON_ASSERT(value &gt; 0);
11103      static_assert(std::numeric_limits&lt;FloatType&gt;::is_iec559,
11104                    &quot;internal error: dtoa_short requires an IEEE-754 floating-point implementation&quot;);
11105      constexpr int      kPrecision = std::numeric_limits&lt;FloatType&gt;::digits; 
11106      constexpr int      kBias      = std::numeric_limits&lt;FloatType&gt;::max_exponent - 1 + (kPrecision - 1);
11107      constexpr int      kMinExp    = 1 - kBias;
11108      constexpr std::uint64_t kHiddenBit = std::uint64_t{1} &lt;&lt; (kPrecision - 1); 
11109      using bits_type = typename std::conditional&lt;kPrecision == 24, std::uint32_t, std::uint64_t &gt;::type;
11110      const auto bits = static_cast&lt;std::uint64_t&gt;(reinterpret_bits&lt;bits_type&gt;(value));
11111      const std::uint64_t E = bits &gt;&gt; (kPrecision - 1);
11112      const std::uint64_t F = bits &amp; (kHiddenBit - 1);
11113      const bool is_denormal = E == 0;
11114      const diyfp v = is_denormal
11115                      ? diyfp(F, kMinExp)
11116                      : diyfp(F + kHiddenBit, static_cast&lt;int&gt;(E) - kBias);
11117      const bool lower_boundary_is_closer = F == 0 &amp;&amp; E &gt; 1;
11118      const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
11119      const diyfp m_minus = lower_boundary_is_closer
11120                            ? diyfp(4 * v.f - 1, v.e - 2)  
11121                            : diyfp(2 * v.f - 1, v.e - 1); 
11122      const diyfp w_plus = diyfp::normalize(m_plus);
11123      const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);
11124      return {diyfp::normalize(v), w_minus, w_plus};
11125  }
11126  constexpr int kAlpha = -60;
11127  constexpr int kGamma = -32;
11128  struct cached_power 
11129  {
11130      std::uint64_t f;
11131      int e;
11132      int k;
11133  };
11134  inline cached_power get_cached_power_for_binary_exponent(int e)
11135  {
11136      constexpr int kCachedPowersMinDecExp = -300;
11137      constexpr int kCachedPowersDecStep = 8;
11138      static constexpr std::array&lt;cached_power, 79&gt; kCachedPowers =
11139      {
11140          {
11141              { 0xAB70FE17C79AC6CA, -1060, -300 },
11142              { 0xFF77B1FCBEBCDC4F, -1034, -292 },
11143              { 0xBE5691EF416BD60C, -1007, -284 },
11144              { 0x8DD01FAD907FFC3C,  -980, -276 },
11145              { 0xD3515C2831559A83,  -954, -268 },
11146              { 0x9D71AC8FADA6C9B5,  -927, -260 },
11147              { 0xEA9C227723EE8BCB,  -901, -252 },
11148              { 0xAECC49914078536D,  -874, -244 },
11149              { 0x823C12795DB6CE57,  -847, -236 },
11150              { 0xC21094364DFB5637,  -821, -228 },
11151              { 0x9096EA6F3848984F,  -794, -220 },
11152              { 0xD77485CB25823AC7,  -768, -212 },
11153              { 0xA086CFCD97BF97F4,  -741, -204 },
11154              { 0xEF340A98172AACE5,  -715, -196 },
11155              { 0xB23867FB2A35B28E,  -688, -188 },
11156              { 0x84C8D4DFD2C63F3B,  -661, -180 },
11157              { 0xC5DD44271AD3CDBA,  -635, -172 },
11158              { 0x936B9FCEBB25C996,  -608, -164 },
11159              { 0xDBAC6C247D62A584,  -582, -156 },
11160              { 0xA3AB66580D5FDAF6,  -555, -148 },
11161              { 0xF3E2F893DEC3F126,  -529, -140 },
11162              { 0xB5B5ADA8AAFF80B8,  -502, -132 },
11163              { 0x87625F056C7C4A8B,  -475, -124 },
11164              { 0xC9BCFF6034C13053,  -449, -116 },
11165              { 0x964E858C91BA2655,  -422, -108 },
11166              { 0xDFF9772470297EBD,  -396, -100 },
11167              { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
11168              { 0xF8A95FCF88747D94,  -343,  -84 },
11169              { 0xB94470938FA89BCF,  -316,  -76 },
11170              { 0x8A08F0F8BF0F156B,  -289,  -68 },
11171              { 0xCDB02555653131B6,  -263,  -60 },
11172              { 0x993FE2C6D07B7FAC,  -236,  -52 },
11173              { 0xE45C10C42A2B3B06,  -210,  -44 },
11174              { 0xAA242499697392D3,  -183,  -36 },
11175              { 0xFD87B5F28300CA0E,  -157,  -28 },
11176              { 0xBCE5086492111AEB,  -130,  -20 },
11177              { 0x8CBCCC096F5088CC,  -103,  -12 },
11178              { 0xD1B71758E219652C,   -77,   -4 },
11179              { 0x9C40000000000000,   -50,    4 },
11180              { 0xE8D4A51000000000,   -24,   12 },
11181              { 0xAD78EBC5AC620000,     3,   20 },
11182              { 0x813F3978F8940984,    30,   28 },
11183              { 0xC097CE7BC90715B3,    56,   36 },
11184              { 0x8F7E32CE7BEA5C70,    83,   44 },
11185              { 0xD5D238A4ABE98068,   109,   52 },
11186              { 0x9F4F2726179A2245,   136,   60 },
11187              { 0xED63A231D4C4FB27,   162,   68 },
11188              { 0xB0DE65388CC8ADA8,   189,   76 },
11189              { 0x83C7088E1AAB65DB,   216,   84 },
11190              { 0xC45D1DF942711D9A,   242,   92 },
11191              { 0x924D692CA61BE758,   269,  100 },
11192              { 0xDA01EE641A708DEA,   295,  108 },
11193              { 0xA26DA3999AEF774A,   322,  116 },
11194              { 0xF209787BB47D6B85,   348,  124 },
11195              { 0xB454E4A179DD1877,   375,  132 },
11196              { 0x865B86925B9BC5C2,   402,  140 },
11197              { 0xC83553C5C8965D3D,   428,  148 },
11198              { 0x952AB45CFA97A0B3,   455,  156 },
11199              { 0xDE469FBD99A05FE3,   481,  164 },
11200              { 0xA59BC234DB398C25,   508,  172 },
11201              { 0xF6C69A72A3989F5C,   534,  180 },
11202              { 0xB7DCBF5354E9BECE,   561,  188 },
11203              { 0x88FCF317F22241E2,   588,  196 },
11204              { 0xCC20CE9BD35C78A5,   614,  204 },
11205              { 0x98165AF37B2153DF,   641,  212 },
11206              { 0xE2A0B5DC971F303A,   667,  220 },
11207              { 0xA8D9D1535CE3B396,   694,  228 },
11208              { 0xFB9B7CD9A4A7443C,   720,  236 },
11209              { 0xBB764C4CA7A44410,   747,  244 },
11210              { 0x8BAB8EEFB6409C1A,   774,  252 },
11211              { 0xD01FEF10A657842C,   800,  260 },
11212              { 0x9B10A4E5E9913129,   827,  268 },
11213              { 0xE7109BFBA19C0C9D,   853,  276 },
11214              { 0xAC2820D9623BF429,   880,  284 },
11215              { 0x80444B5E7AA7CF85,   907,  292 },
11216              { 0xBF21E44003ACDD2D,   933,  300 },
11217              { 0x8E679C2F5E44FF8F,   960,  308 },
11218              { 0xD433179D9C8CB841,   986,  316 },
11219              { 0x9E19DB92B4E31BA9,  1013,  324 },
11220          }
11221      };
11222      JSON_ASSERT(e &gt;= -1500);
11223      JSON_ASSERT(e &lt;=  1500);
11224      const int f = kAlpha - e - 1;
11225      const int k = (f * 78913) / (1 &lt;&lt; 18) + static_cast&lt;int&gt;(f &gt; 0);
11226      const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
11227      JSON_ASSERT(index &gt;= 0);
11228      JSON_ASSERT(static_cast&lt;std::size_t&gt;(index) &lt; kCachedPowers.size());
11229      const cached_power cached = kCachedPowers[static_cast&lt;std::size_t&gt;(index)];
11230      JSON_ASSERT(kAlpha &lt;= cached.e + e + 64);
11231      JSON_ASSERT(kGamma &gt;= cached.e + e + 64);
11232      return cached;
11233  }
11234  inline int find_largest_pow10(const std::uint32_t n, std::uint32_t&amp; pow10)
11235  {
11236      if (n &gt;= 1000000000)
11237      {
11238          pow10 = 1000000000;
11239          return 10;
11240      }
11241      if (n &gt;= 100000000)
11242      {
11243          pow10 = 100000000;
11244          return  9;
11245      }
11246      if (n &gt;= 10000000)
11247      {
11248          pow10 = 10000000;
11249          return  8;
11250      }
11251      if (n &gt;= 1000000)
11252      {
11253          pow10 = 1000000;
11254          return  7;
11255      }
11256      if (n &gt;= 100000)
11257      {
11258          pow10 = 100000;
11259          return  6;
11260      }
11261      if (n &gt;= 10000)
11262      {
11263          pow10 = 10000;
11264          return  5;
11265      }
11266      if (n &gt;= 1000)
11267      {
11268          pow10 = 1000;
11269          return  4;
11270      }
11271      if (n &gt;= 100)
11272      {
11273          pow10 = 100;
11274          return  3;
11275      }
11276      if (n &gt;= 10)
11277      {
11278          pow10 = 10;
11279          return  2;
11280      }
11281      pow10 = 1;
11282      return 1;
11283  }
11284  inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
11285                           std::uint64_t rest, std::uint64_t ten_k)
11286  {
11287      JSON_ASSERT(len &gt;= 1);
11288      JSON_ASSERT(dist &lt;= delta);
11289      JSON_ASSERT(rest &lt;= delta);
11290      JSON_ASSERT(ten_k &gt; 0);
11291      while (rest &lt; dist
11292              &amp;&amp; delta - rest &gt;= ten_k
11293              &amp;&amp; (rest + ten_k &lt; dist || dist - rest &gt; rest + ten_k - dist))
11294      {
11295          JSON_ASSERT(buf[len - 1] != &#x27;0&#x27;);
11296          buf[len - 1]--;
11297          rest += ten_k;
11298      }
11299  }
11300  inline void grisu2_digit_gen(char* buffer, int&amp; length, int&amp; decimal_exponent,
11301                               diyfp M_minus, diyfp w, diyfp M_plus)
11302  {
11303      static_assert(kAlpha &gt;= -60, &quot;internal error&quot;);
11304      static_assert(kGamma &lt;= -32, &quot;internal error&quot;);
11305      JSON_ASSERT(M_plus.e &gt;= kAlpha);
11306      JSON_ASSERT(M_plus.e &lt;= kGamma);
11307      std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; 
11308      std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; 
11309      const diyfp one(std::uint64_t{1} &lt;&lt; -M_plus.e, M_plus.e);
11310      auto p1 = static_cast&lt;std::uint32_t&gt;(M_plus.f &gt;&gt; -one.e); 
11311      std::uint64_t p2 = M_plus.f &amp; (one.f - 1);                    
11312      JSON_ASSERT(p1 &gt; 0);
11313      std::uint32_t pow10{};
11314      const int k = find_largest_pow10(p1, pow10);
11315      int n = k;
11316      while (n &gt; 0)
11317      {
11318          const std::uint32_t d = p1 / pow10;  
11319          const std::uint32_t r = p1 % pow10;  
11320          JSON_ASSERT(d &lt;= 9);
11321          buffer[length++] = static_cast&lt;char&gt;(&#x27;0&#x27; + d); 
11322          p1 = r;
11323          n--;
11324          const std::uint64_t rest = (std::uint64_t{p1} &lt;&lt; -one.e) + p2;
11325          if (rest &lt;= delta)
11326          {
11327              decimal_exponent += n;
11328              const std::uint64_t ten_n = std::uint64_t{pow10} &lt;&lt; -one.e;
11329              grisu2_round(buffer, length, dist, delta, rest, ten_n);
11330              return;
11331          }
11332          pow10 /= 10;
11333      }
11334      JSON_ASSERT(p2 &gt; delta);
11335      int m = 0;
11336      for (;;)
11337      {
11338          JSON_ASSERT(p2 &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)() / 10);
11339          p2 *= 10;
11340          const std::uint64_t d = p2 &gt;&gt; -one.e;     
11341          const std::uint64_t r = p2 &amp; (one.f - 1); 
11342          JSON_ASSERT(d &lt;= 9);
11343          buffer[length++] = static_cast&lt;char&gt;(&#x27;0&#x27; + d); 
11344          p2 = r;
11345          m++;
11346          delta *= 10;
11347          dist  *= 10;
11348          if (p2 &lt;= delta)
11349          {
11350              break;
11351          }
11352      }
11353      decimal_exponent -= m;
11354      const std::uint64_t ten_m = one.f;
11355      grisu2_round(buffer, length, dist, delta, p2, ten_m);
11356  }
11357  JSON_HEDLEY_NON_NULL(1)
11358  inline void grisu2(char* buf, int&amp; len, int&amp; decimal_exponent,
11359                     diyfp m_minus, diyfp v, diyfp m_plus)
11360  {
11361      JSON_ASSERT(m_plus.e == m_minus.e);
11362      JSON_ASSERT(m_plus.e == v.e);
11363      const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);
11364      const diyfp c_minus_k(cached.f, cached.e); 
11365      const diyfp w       = diyfp::mul(v,       c_minus_k);
11366      const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
11367      const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);
11368      const diyfp M_minus(w_minus.f + 1, w_minus.e);
11369      const diyfp M_plus (w_plus.f  - 1, w_plus.e );
11370      decimal_exponent = -cached.k; 
11371      grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
11372  }
11373  template&lt;typename FloatType&gt;
11374  JSON_HEDLEY_NON_NULL(1)
11375  void grisu2(char* buf, int&amp; len, int&amp; decimal_exponent, FloatType value)
11376  {
11377      static_assert(diyfp::kPrecision &gt;= std::numeric_limits&lt;FloatType&gt;::digits + 3,
11378                    &quot;internal error: not enough precision&quot;);
11379      JSON_ASSERT(std::isfinite(value));
11380      JSON_ASSERT(value &gt; 0);
11381  #if 0
11382      const boundaries w = compute_boundaries(static_cast&lt;double&gt;(value));
11383  #else
11384      const boundaries w = compute_boundaries(value);
11385  #endif
11386      grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
11387  }
11388  JSON_HEDLEY_NON_NULL(1)
11389  JSON_HEDLEY_RETURNS_NON_NULL
11390  inline char* append_exponent(char* buf, int e)
11391  {
11392      JSON_ASSERT(e &gt; -1000);
11393      JSON_ASSERT(e &lt;  1000);
11394      if (e &lt; 0)
11395      {
11396          e = -e;
11397          *buf++ = &#x27;-&#x27;;
11398      }
11399      else
11400      {
11401          *buf++ = &#x27;+&#x27;;
11402      }
11403      auto k = static_cast&lt;std::uint32_t&gt;(e);
11404      if (k &lt; 10)
11405      {
11406          *buf++ = &#x27;0&#x27;;
11407          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k);
11408      }
11409      else if (k &lt; 100)
11410      {
11411          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k / 10);
11412          k %= 10;
11413          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k);
11414      }
11415      else
11416      {
11417          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k / 100);
11418          k %= 100;
11419          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k / 10);
11420          k %= 10;
11421          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k);
11422      }
11423      return buf;
11424  }
11425  JSON_HEDLEY_NON_NULL(1)
11426  JSON_HEDLEY_RETURNS_NON_NULL
11427  inline char* format_buffer(char* buf, int len, int decimal_exponent,
11428                             int min_exp, int max_exp)
11429  {
11430      JSON_ASSERT(min_exp &lt; 0);
11431      JSON_ASSERT(max_exp &gt; 0);
11432      const int k = len;
11433      const int n = len + decimal_exponent;
11434      if (k &lt;= n &amp;&amp; n &lt;= max_exp)
11435      {
11436          std::memset(buf + k, &#x27;0&#x27;, static_cast&lt;size_t&gt;(n) - static_cast&lt;size_t&gt;(k));
11437          buf[n + 0] = &#x27;.&#x27;;
11438          buf[n + 1] = &#x27;0&#x27;;
11439          return buf + (static_cast&lt;size_t&gt;(n) + 2);
11440      }
11441      if (0 &lt; n &amp;&amp; n &lt;= max_exp)
11442      {
11443          JSON_ASSERT(k &gt; n);
11444          std::memmove(buf + (static_cast&lt;size_t&gt;(n) + 1), buf + n, static_cast&lt;size_t&gt;(k) - static_cast&lt;size_t&gt;(n));
11445          buf[n] = &#x27;.&#x27;;
11446          return buf + (static_cast&lt;size_t&gt;(k) + 1U);
11447      }
11448      if (min_exp &lt; n &amp;&amp; n &lt;= 0)
11449      {
11450          std::memmove(buf + (2 + static_cast&lt;size_t&gt;(-n)), buf, static_cast&lt;size_t&gt;(k));
11451          buf[0] = &#x27;0&#x27;;
11452          buf[1] = &#x27;.&#x27;;
11453          std::memset(buf + 2, &#x27;0&#x27;, static_cast&lt;size_t&gt;(-n));
11454          return buf + (2U + static_cast&lt;size_t&gt;(-n) + static_cast&lt;size_t&gt;(k));
11455      }
11456      if (k == 1)
11457      {
11458          buf += 1;
11459      }
11460      else
11461      {
11462          std::memmove(buf + 2, buf + 1, static_cast&lt;size_t&gt;(k) - 1);
11463          buf[1] = &#x27;.&#x27;;
11464          buf += 1 + static_cast&lt;size_t&gt;(k);
11465      }
11466      *buf++ = &#x27;e&#x27;;
11467      return append_exponent(buf, n - 1);
11468  }
11469  } 
11470  template&lt;typename FloatType&gt;
11471  JSON_HEDLEY_NON_NULL(1, 2)
11472  JSON_HEDLEY_RETURNS_NON_NULL
11473  char* to_chars(char* first, const char* last, FloatType value)
11474  {
11475      static_cast&lt;void&gt;(last); 
11476      JSON_ASSERT(std::isfinite(value));
11477      if (std::signbit(value))
11478      {
11479          value = -value;
11480          *first++ = &#x27;-&#x27;;
11481      }
11482  #ifdef __GNUC__
11483  #pragma GCC diagnostic push
11484  #pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;
11485  #endif
11486      if (value == 0) 
11487      {
11488          *first++ = &#x27;0&#x27;;
11489          *first++ = &#x27;.&#x27;;
11490          *first++ = &#x27;0&#x27;;
11491          return first;
11492      }
11493  #ifdef __GNUC__
11494  #pragma GCC diagnostic pop
11495  #endif
11496      JSON_ASSERT(last - first &gt;= std::numeric_limits&lt;FloatType&gt;::max_digits10);
11497      int len = 0;
11498      int decimal_exponent = 0;
11499      dtoa_impl::grisu2(first, len, decimal_exponent, value);
11500      JSON_ASSERT(len &lt;= std::numeric_limits&lt;FloatType&gt;::max_digits10);
11501      constexpr int kMinExp = -4;
11502      constexpr int kMaxExp = std::numeric_limits&lt;FloatType&gt;::digits10;
11503      JSON_ASSERT(last - first &gt;= kMaxExp + 2);
11504      JSON_ASSERT(last - first &gt;= 2 + (-kMinExp - 1) + std::numeric_limits&lt;FloatType&gt;::max_digits10);
11505      JSON_ASSERT(last - first &gt;= std::numeric_limits&lt;FloatType&gt;::max_digits10 + 6);
11506      return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
11507  }
11508  } 
11509  } 
11510  namespace nlohmann
11511  {
11512  namespace detail
11513  {
11514  enum class error_handler_t
11515  {
11516      strict,  
11517      replace, 
11518      ignore   
11519  };
11520  template&lt;typename BasicJsonType&gt;
11521  class serializer
11522  {
11523      using string_t = typename BasicJsonType::string_t;
11524      using number_float_t = typename BasicJsonType::number_float_t;
11525      using number_integer_t = typename BasicJsonType::number_integer_t;
11526      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
11527      using binary_char_t = typename BasicJsonType::binary_t::value_type;
11528      static constexpr std::uint8_t UTF8_ACCEPT = 0;
11529      static constexpr std::uint8_t UTF8_REJECT = 1;
11530    public:
11531      serializer(output_adapter_t&lt;char&gt; s, const char ichar,
11532                 error_handler_t error_handler_ = error_handler_t::strict)
11533          : o(std::move(s))
11534          , loc(std::localeconv())
11535          , thousands_sep(loc-&gt;thousands_sep == nullptr ? &#x27;\0&#x27; : std::char_traits&lt;char&gt;::to_char_type(* (loc-&gt;thousands_sep)))
11536          , decimal_point(loc-&gt;decimal_point == nullptr ? &#x27;\0&#x27; : std::char_traits&lt;char&gt;::to_char_type(* (loc-&gt;decimal_point)))
11537          , indent_char(ichar)
11538          , indent_string(512, indent_char)
11539          , error_handler(error_handler_)
11540      {}
11541      serializer(const serializer&amp;) = delete;
11542      serializer&amp; operator=(const serializer&amp;) = delete;
11543      serializer(serializer&amp;&amp;) = delete;
11544      serializer&amp; operator=(serializer&amp;&amp;) = delete;
11545      ~serializer() = default;
11546      void dump(const BasicJsonType&amp; val,
11547                const bool pretty_print,
11548                const bool ensure_ascii,
11549                const unsigned int indent_step,
11550                const unsigned int current_indent = 0)
11551      {
11552          switch (val.m_type)
11553          {
11554              case value_t::object:
11555              {
11556                  if (val.m_value.object-&gt;empty())
11557                  {
11558                      o-&gt;write_characters(&quot;{}&quot;, 2);
11559                      return;
11560                  }
11561                  if (pretty_print)
11562                  {
11563                      o-&gt;write_characters(&quot;{\n&quot;, 2);
11564                      const auto new_indent = current_indent + indent_step;
11565                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() &lt; new_indent))
11566                      {
11567                          indent_string.resize(indent_string.size() * 2, &#x27; &#x27;);
11568                      }
11569                      auto i = val.m_value.object-&gt;cbegin();
11570                      for (std::size_t cnt = 0; cnt &lt; val.m_value.object-&gt;size() - 1; ++cnt, ++i)
11571                      {
11572                          o-&gt;write_characters(indent_string.c_str(), new_indent);
11573                          o-&gt;write_character(&#x27;\&quot;&#x27;);
11574                          dump_escaped(i-&gt;first, ensure_ascii);
11575                          o-&gt;write_characters(&quot;\&quot;: &quot;, 3);
11576                          dump(i-&gt;second, true, ensure_ascii, indent_step, new_indent);
11577                          o-&gt;write_characters(&quot;,\n&quot;, 2);
11578                      }
11579                      JSON_ASSERT(i != val.m_value.object-&gt;cend());
11580                      JSON_ASSERT(std::next(i) == val.m_value.object-&gt;cend());
11581                      o-&gt;write_characters(indent_string.c_str(), new_indent);
11582                      o-&gt;write_character(&#x27;\&quot;&#x27;);
11583                      dump_escaped(i-&gt;first, ensure_ascii);
11584                      o-&gt;write_characters(&quot;\&quot;: &quot;, 3);
11585                      dump(i-&gt;second, true, ensure_ascii, indent_step, new_indent);
11586                      o-&gt;write_character(&#x27;\n&#x27;);
11587                      o-&gt;write_characters(indent_string.c_str(), current_indent);
11588                      o-&gt;write_character(&#x27;}&#x27;);
11589                  }
11590                  else
11591                  {
11592                      o-&gt;write_character(&#x27;{&#x27;);
11593                      auto i = val.m_value.object-&gt;cbegin();
11594                      for (std::size_t cnt = 0; cnt &lt; val.m_value.object-&gt;size() - 1; ++cnt, ++i)
11595                      {
11596                          o-&gt;write_character(&#x27;\&quot;&#x27;);
11597                          dump_escaped(i-&gt;first, ensure_ascii);
11598                          o-&gt;write_characters(&quot;\&quot;:&quot;, 2);
11599                          dump(i-&gt;second, false, ensure_ascii, indent_step, current_indent);
11600                          o-&gt;write_character(&#x27;,&#x27;);
11601                      }
11602                      JSON_ASSERT(i != val.m_value.object-&gt;cend());
11603                      JSON_ASSERT(std::next(i) == val.m_value.object-&gt;cend());
11604                      o-&gt;write_character(&#x27;\&quot;&#x27;);
11605                      dump_escaped(i-&gt;first, ensure_ascii);
11606                      o-&gt;write_characters(&quot;\&quot;:&quot;, 2);
11607                      dump(i-&gt;second, false, ensure_ascii, indent_step, current_indent);
11608                      o-&gt;write_character(&#x27;}&#x27;);
11609                  }
11610                  return;
11611              }
11612              case value_t::array:
11613              {
11614                  if (val.m_value.array-&gt;empty())
11615                  {
11616                      o-&gt;write_characters(&quot;[]&quot;, 2);
11617                      return;
11618                  }
11619                  if (pretty_print)
11620                  {
11621                      o-&gt;write_characters(&quot;[\n&quot;, 2);
11622                      const auto new_indent = current_indent + indent_step;
11623                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() &lt; new_indent))
11624                      {
11625                          indent_string.resize(indent_string.size() * 2, &#x27; &#x27;);
11626                      }
11627                      for (auto i = val.m_value.array-&gt;cbegin();
11628                              i != val.m_value.array-&gt;cend() - 1; ++i)
11629                      {
11630                          o-&gt;write_characters(indent_string.c_str(), new_indent);
11631                          dump(*i, true, ensure_ascii, indent_step, new_indent);
11632                          o-&gt;write_characters(&quot;,\n&quot;, 2);
11633                      }
11634                      JSON_ASSERT(!val.m_value.array-&gt;empty());
11635                      o-&gt;write_characters(indent_string.c_str(), new_indent);
11636                      dump(val.m_value.array-&gt;back(), true, ensure_ascii, indent_step, new_indent);
11637                      o-&gt;write_character(&#x27;\n&#x27;);
11638                      o-&gt;write_characters(indent_string.c_str(), current_indent);
11639                      o-&gt;write_character(&#x27;]&#x27;);
11640                  }
11641                  else
11642                  {
11643                      o-&gt;write_character(&#x27;[&#x27;);
11644                      for (auto i = val.m_value.array-&gt;cbegin();
11645                              i != val.m_value.array-&gt;cend() - 1; ++i)
11646                      {
11647                          dump(*i, false, ensure_ascii, indent_step, current_indent);
11648                          o-&gt;write_character(&#x27;,&#x27;);
11649                      }
11650                      JSON_ASSERT(!val.m_value.array-&gt;empty());
11651                      dump(val.m_value.array-&gt;back(), false, ensure_ascii, indent_step, current_indent);
11652                      o-&gt;write_character(&#x27;]&#x27;);
11653                  }
11654                  return;
11655              }
11656              case value_t::string:
11657              {
11658                  o-&gt;write_character(&#x27;\&quot;&#x27;);
11659                  dump_escaped(*val.m_value.string, ensure_ascii);
11660                  o-&gt;write_character(&#x27;\&quot;&#x27;);
11661                  return;
11662              }
11663              case value_t::binary:
11664              {
11665                  if (pretty_print)
11666                  {
11667                      o-&gt;write_characters(&quot;{\n&quot;, 2);
11668                      const auto new_indent = current_indent + indent_step;
11669                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() &lt; new_indent))
11670                      {
11671                          indent_string.resize(indent_string.size() * 2, &#x27; &#x27;);
11672                      }
11673                      o-&gt;write_characters(indent_string.c_str(), new_indent);
11674                      o-&gt;write_characters(&quot;\&quot;bytes\&quot;: [&quot;, 10);
11675                      if (!val.m_value.binary-&gt;empty())
11676                      {
11677                          for (auto i = val.m_value.binary-&gt;cbegin();
11678                                  i != val.m_value.binary-&gt;cend() - 1; ++i)
11679                          {
11680                              dump_integer(*i);
11681                              o-&gt;write_characters(&quot;, &quot;, 2);
11682                          }
11683                          dump_integer(val.m_value.binary-&gt;back());
11684                      }
11685                      o-&gt;write_characters(&quot;],\n&quot;, 3);
11686                      o-&gt;write_characters(indent_string.c_str(), new_indent);
11687                      o-&gt;write_characters(&quot;\&quot;subtype\&quot;: &quot;, 11);
11688                      if (val.m_value.binary-&gt;has_subtype())
11689                      {
11690                          dump_integer(val.m_value.binary-&gt;subtype());
11691                      }
11692                      else
11693                      {
11694                          o-&gt;write_characters(&quot;null&quot;, 4);
11695                      }
11696                      o-&gt;write_character(&#x27;\n&#x27;);
11697                      o-&gt;write_characters(indent_string.c_str(), current_indent);
11698                      o-&gt;write_character(&#x27;}&#x27;);
11699                  }
11700                  else
11701                  {
11702                      o-&gt;write_characters(&quot;{\&quot;bytes\&quot;:[&quot;, 10);
11703                      if (!val.m_value.binary-&gt;empty())
11704                      {
11705                          for (auto i = val.m_value.binary-&gt;cbegin();
11706                                  i != val.m_value.binary-&gt;cend() - 1; ++i)
11707                          {
11708                              dump_integer(*i);
11709                              o-&gt;write_character(&#x27;,&#x27;);
11710                          }
11711                          dump_integer(val.m_value.binary-&gt;back());
11712                      }
11713                      o-&gt;write_characters(&quot;],\&quot;subtype\&quot;:&quot;, 12);
11714                      if (val.m_value.binary-&gt;has_subtype())
11715                      {
11716                          dump_integer(val.m_value.binary-&gt;subtype());
11717                          o-&gt;write_character(&#x27;}&#x27;);
11718                      }
11719                      else
11720                      {
11721                          o-&gt;write_characters(&quot;null}&quot;, 5);
11722                      }
11723                  }
11724                  return;
11725              }
11726              case value_t::boolean:
11727              {
11728                  if (val.m_value.boolean)
11729                  {
11730                      o-&gt;write_characters(&quot;true&quot;, 4);
11731                  }
11732                  else
11733                  {
11734                      o-&gt;write_characters(&quot;false&quot;, 5);
11735                  }
11736                  return;
11737              }
11738              case value_t::number_integer:
11739              {
11740                  dump_integer(val.m_value.number_integer);
11741                  return;
11742              }
11743              case value_t::number_unsigned:
11744              {
11745                  dump_integer(val.m_value.number_unsigned);
11746                  return;
11747              }
11748              case value_t::number_float:
11749              {
11750                  dump_float(val.m_value.number_float);
11751                  return;
11752              }
11753              case value_t::discarded:
11754              {
11755                  o-&gt;write_characters(&quot;&lt;discarded&gt;&quot;, 11);
11756                  return;
11757              }
11758              case value_t::null:
11759              {
11760                  o-&gt;write_characters(&quot;null&quot;, 4);
11761                  return;
11762              }
11763              default:            
11764                  JSON_ASSERT(false); 
11765          }
11766      }
11767    JSON_PRIVATE_UNLESS_TESTED:
11768      void dump_escaped(const string_t&amp; s, const bool ensure_ascii)
11769      {
11770          std::uint32_t codepoint{};
11771          std::uint8_t state = UTF8_ACCEPT;
11772          std::size_t bytes = 0;  
11773          std::size_t bytes_after_last_accept = 0;
11774          std::size_t undumped_chars = 0;
11775          for (std::size_t i = 0; i &lt; s.size(); ++i)
11776          {
11777              const auto byte = static_cast&lt;std::uint8_t&gt;(s[i]);
11778              switch (decode(state, codepoint, byte))
11779              {
11780                  case UTF8_ACCEPT:  
11781                  {
11782                      switch (codepoint)
11783                      {
11784                          case 0x08: 
11785                          {
11786                              string_buffer[bytes++] = &#x27;\\&#x27;;
11787                              string_buffer[bytes++] = &#x27;b&#x27;;
11788                              break;
11789                          }
11790                          case 0x09: 
11791                          {
11792                              string_buffer[bytes++] = &#x27;\\&#x27;;
11793                              string_buffer[bytes++] = &#x27;t&#x27;;
11794                              break;
11795                          }
11796                          case 0x0A: 
11797                          {
11798                              string_buffer[bytes++] = &#x27;\\&#x27;;
11799                              string_buffer[bytes++] = &#x27;n&#x27;;
11800                              break;
11801                          }
11802                          case 0x0C: 
11803                          {
11804                              string_buffer[bytes++] = &#x27;\\&#x27;;
11805                              string_buffer[bytes++] = &#x27;f&#x27;;
11806                              break;
11807                          }
11808                          case 0x0D: 
11809                          {
11810                              string_buffer[bytes++] = &#x27;\\&#x27;;
11811                              string_buffer[bytes++] = &#x27;r&#x27;;
11812                              break;
11813                          }
11814                          case 0x22: 
11815                          {
11816                              string_buffer[bytes++] = &#x27;\\&#x27;;
11817                              string_buffer[bytes++] = &#x27;\&quot;&#x27;;
11818                              break;
11819                          }
11820                          case 0x5C: 
11821                          {
11822                              string_buffer[bytes++] = &#x27;\\&#x27;;
11823                              string_buffer[bytes++] = &#x27;\\&#x27;;
11824                              break;
11825                          }
11826                          default:
11827                          {
11828                              if ((codepoint &lt;= 0x1F) || (ensure_ascii &amp;&amp; (codepoint &gt;= 0x7F)))
11829                              {
11830                                  if (codepoint &lt;= 0xFFFF)
11831                                  {
11832                                      (std::snprintf)(string_buffer.data() + bytes, 7, &quot;\\u%04x&quot;,
11833                                                      static_cast&lt;std::uint16_t&gt;(codepoint));
11834                                      bytes += 6;
11835                                  }
11836                                  else
11837                                  {
11838                                      (std::snprintf)(string_buffer.data() + bytes, 13, &quot;\\u%04x\\u%04x&quot;,
11839                                                      static_cast&lt;std::uint16_t&gt;(0xD7C0u + (codepoint &gt;&gt; 10u)),
11840                                                      static_cast&lt;std::uint16_t&gt;(0xDC00u + (codepoint &amp; 0x3FFu)));
11841                                      bytes += 12;
11842                                  }
11843                              }
11844                              else
11845                              {
11846                                  string_buffer[bytes++] = s[i];
11847                              }
11848                              break;
11849                          }
11850                      }
11851                      if (string_buffer.size() - bytes &lt; 13)
11852                      {
11853                          o-&gt;write_characters(string_buffer.data(), bytes);
11854                          bytes = 0;
11855                      }
11856                      bytes_after_last_accept = bytes;
11857                      undumped_chars = 0;
11858                      break;
11859                  }
11860                  case UTF8_REJECT:  
11861                  {
11862                      switch (error_handler)
11863                      {
11864                          case error_handler_t::strict:
11865                          {
11866                              std::string sn(9, &#x27;\0&#x27;);
11867                              (std::snprintf)(&amp;sn[0], sn.size(), &quot;%.2X&quot;, byte);
11868                              JSON_THROW(type_error::create(316, &quot;invalid UTF-8 byte at index &quot; + std::to_string(i) + &quot;: 0x&quot; + sn, BasicJsonType()));
11869                          }
11870                          case error_handler_t::ignore:
11871                          case error_handler_t::replace:
11872                          {
11873                              if (undumped_chars &gt; 0)
11874                              {
11875                                  --i;
11876                              }
11877                              bytes = bytes_after_last_accept;
11878                              if (error_handler == error_handler_t::replace)
11879                              {
11880                                  if (ensure_ascii)
11881                                  {
11882                                      string_buffer[bytes++] = &#x27;\\&#x27;;
11883                                      string_buffer[bytes++] = &#x27;u&#x27;;
11884                                      string_buffer[bytes++] = &#x27;f&#x27;;
11885                                      string_buffer[bytes++] = &#x27;f&#x27;;
11886                                      string_buffer[bytes++] = &#x27;f&#x27;;
11887                                      string_buffer[bytes++] = &#x27;d&#x27;;
11888                                  }
11889                                  else
11890                                  {
11891                                      string_buffer[bytes++] = detail::binary_writer&lt;BasicJsonType, char&gt;::to_char_type(&#x27;\xEF&#x27;);
11892                                      string_buffer[bytes++] = detail::binary_writer&lt;BasicJsonType, char&gt;::to_char_type(&#x27;\xBF&#x27;);
11893                                      string_buffer[bytes++] = detail::binary_writer&lt;BasicJsonType, char&gt;::to_char_type(&#x27;\xBD&#x27;);
11894                                  }
11895                                  if (string_buffer.size() - bytes &lt; 13)
11896                                  {
11897                                      o-&gt;write_characters(string_buffer.data(), bytes);
11898                                      bytes = 0;
11899                                  }
11900                                  bytes_after_last_accept = bytes;
11901                              }
11902                              undumped_chars = 0;
11903                              state = UTF8_ACCEPT;
11904                              break;
11905                          }
11906                          default:            
11907                              JSON_ASSERT(false); 
11908                      }
11909                      break;
11910                  }
11911                  default:  
11912                  {
11913                      if (!ensure_ascii)
11914                      {
11915                          string_buffer[bytes++] = s[i];
11916                      }
11917                      ++undumped_chars;
11918                      break;
11919                  }
11920              }
11921          }
11922          if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
11923          {
11924              if (bytes &gt; 0)
11925              {
11926                  o-&gt;write_characters(string_buffer.data(), bytes);
11927              }
11928          }
11929          else
11930          {
11931              switch (error_handler)
11932              {
11933                  case error_handler_t::strict:
11934                  {
11935                      std::string sn(9, &#x27;\0&#x27;);
11936                      (std::snprintf)(&amp;sn[0], sn.size(), &quot;%.2X&quot;, static_cast&lt;std::uint8_t&gt;(s.back()));
11937                      JSON_THROW(type_error::create(316, &quot;incomplete UTF-8 string; last byte: 0x&quot; + sn, BasicJsonType()));
11938                  }
11939                  case error_handler_t::ignore:
11940                  {
11941                      o-&gt;write_characters(string_buffer.data(), bytes_after_last_accept);
11942                      break;
11943                  }
11944                  case error_handler_t::replace:
11945                  {
11946                      o-&gt;write_characters(string_buffer.data(), bytes_after_last_accept);
11947                      if (ensure_ascii)
11948                      {
11949                          o-&gt;write_characters(&quot;\\ufffd&quot;, 6);
11950                      }
11951                      else
11952                      {
11953                          o-&gt;write_characters(&quot;\xEF\xBF\xBD&quot;, 3);
11954                      }
11955                      break;
11956                  }
11957                  default:            
11958                      JSON_ASSERT(false); 
11959              }
11960          }
11961      }
11962    private:
11963      inline unsigned int count_digits(number_unsigned_t x) noexcept
11964      {
11965          unsigned int n_digits = 1;
11966          for (;;)
11967          {
11968              if (x &lt; 10)
11969              {
11970                  return n_digits;
11971              }
11972              if (x &lt; 100)
11973              {
11974                  return n_digits + 1;
11975              }
11976              if (x &lt; 1000)
11977              {
11978                  return n_digits + 2;
11979              }
11980              if (x &lt; 10000)
11981              {
11982                  return n_digits + 3;
11983              }
11984              x = x / 10000u;
11985              n_digits += 4;
11986          }
11987      }
11988      template &lt; typename NumberType, detail::enable_if_t &lt;
11989                     std::is_integral&lt;NumberType&gt;::value ||
11990                     std::is_same&lt;NumberType, number_unsigned_t&gt;::value ||
11991                     std::is_same&lt;NumberType, number_integer_t&gt;::value ||
11992                     std::is_same&lt;NumberType, binary_char_t&gt;::value,
11993                     int &gt; = 0 &gt;
11994      void dump_integer(NumberType x)
11995      {
11996          static constexpr std::array&lt;std::array&lt;char, 2&gt;, 100&gt; digits_to_99
11997          {
11998              {
11999                  {{&#x27;0&#x27;, &#x27;0&#x27;}}, {{&#x27;0&#x27;, &#x27;1&#x27;}}, {{&#x27;0&#x27;, &#x27;2&#x27;}}, {{&#x27;0&#x27;, &#x27;3&#x27;}}, {{&#x27;0&#x27;, &#x27;4&#x27;}}, {{&#x27;0&#x27;, &#x27;5&#x27;}}, {{&#x27;0&#x27;, &#x27;6&#x27;}}, {{&#x27;0&#x27;, &#x27;7&#x27;}}, {{&#x27;0&#x27;, &#x27;8&#x27;}}, {{&#x27;0&#x27;, &#x27;9&#x27;}},
12000                  {{&#x27;1&#x27;, &#x27;0&#x27;}}, {{&#x27;1&#x27;, &#x27;1&#x27;}}, {{&#x27;1&#x27;, &#x27;2&#x27;}}, {{&#x27;1&#x27;, &#x27;3&#x27;}}, {{&#x27;1&#x27;, &#x27;4&#x27;}}, {{&#x27;1&#x27;, &#x27;5&#x27;}}, {{&#x27;1&#x27;, &#x27;6&#x27;}}, {{&#x27;1&#x27;, &#x27;7&#x27;}}, {{&#x27;1&#x27;, &#x27;8&#x27;}}, {{&#x27;1&#x27;, &#x27;9&#x27;}},
12001                  {{&#x27;2&#x27;, &#x27;0&#x27;}}, {{&#x27;2&#x27;, &#x27;1&#x27;}}, {{&#x27;2&#x27;, &#x27;2&#x27;}}, {{&#x27;2&#x27;, &#x27;3&#x27;}}, {{&#x27;2&#x27;, &#x27;4&#x27;}}, {{&#x27;2&#x27;, &#x27;5&#x27;}}, {{&#x27;2&#x27;, &#x27;6&#x27;}}, {{&#x27;2&#x27;, &#x27;7&#x27;}}, {{&#x27;2&#x27;, &#x27;8&#x27;}}, {{&#x27;2&#x27;, &#x27;9&#x27;}},
12002                  {{&#x27;3&#x27;, &#x27;0&#x27;}}, {{&#x27;3&#x27;, &#x27;1&#x27;}}, {{&#x27;3&#x27;, &#x27;2&#x27;}}, {{&#x27;3&#x27;, &#x27;3&#x27;}}, {{&#x27;3&#x27;, &#x27;4&#x27;}}, {{&#x27;3&#x27;, &#x27;5&#x27;}}, {{&#x27;3&#x27;, &#x27;6&#x27;}}, {{&#x27;3&#x27;, &#x27;7&#x27;}}, {{&#x27;3&#x27;, &#x27;8&#x27;}}, {{&#x27;3&#x27;, &#x27;9&#x27;}},
12003                  {{&#x27;4&#x27;, &#x27;0&#x27;}}, {{&#x27;4&#x27;, &#x27;1&#x27;}}, {{&#x27;4&#x27;, &#x27;2&#x27;}}, {{&#x27;4&#x27;, &#x27;3&#x27;}}, {{&#x27;4&#x27;, &#x27;4&#x27;}}, {{&#x27;4&#x27;, &#x27;5&#x27;}}, {{&#x27;4&#x27;, &#x27;6&#x27;}}, {{&#x27;4&#x27;, &#x27;7&#x27;}}, {{&#x27;4&#x27;, &#x27;8&#x27;}}, {{&#x27;4&#x27;, &#x27;9&#x27;}},
12004                  {{&#x27;5&#x27;, &#x27;0&#x27;}}, {{&#x27;5&#x27;, &#x27;1&#x27;}}, {{&#x27;5&#x27;, &#x27;2&#x27;}}, {{&#x27;5&#x27;, &#x27;3&#x27;}}, {{&#x27;5&#x27;, &#x27;4&#x27;}}, {{&#x27;5&#x27;, &#x27;5&#x27;}}, {{&#x27;5&#x27;, &#x27;6&#x27;}}, {{&#x27;5&#x27;, &#x27;7&#x27;}}, {{&#x27;5&#x27;, &#x27;8&#x27;}}, {{&#x27;5&#x27;, &#x27;9&#x27;}},
12005                  {{&#x27;6&#x27;, &#x27;0&#x27;}}, {{&#x27;6&#x27;, &#x27;1&#x27;}}, {{&#x27;6&#x27;, &#x27;2&#x27;}}, {{&#x27;6&#x27;, &#x27;3&#x27;}}, {{&#x27;6&#x27;, &#x27;4&#x27;}}, {{&#x27;6&#x27;, &#x27;5&#x27;}}, {{&#x27;6&#x27;, &#x27;6&#x27;}}, {{&#x27;6&#x27;, &#x27;7&#x27;}}, {{&#x27;6&#x27;, &#x27;8&#x27;}}, {{&#x27;6&#x27;, &#x27;9&#x27;}},
12006                  {{&#x27;7&#x27;, &#x27;0&#x27;}}, {{&#x27;7&#x27;, &#x27;1&#x27;}}, {{&#x27;7&#x27;, &#x27;2&#x27;}}, {{&#x27;7&#x27;, &#x27;3&#x27;}}, {{&#x27;7&#x27;, &#x27;4&#x27;}}, {{&#x27;7&#x27;, &#x27;5&#x27;}}, {{&#x27;7&#x27;, &#x27;6&#x27;}}, {{&#x27;7&#x27;, &#x27;7&#x27;}}, {{&#x27;7&#x27;, &#x27;8&#x27;}}, {{&#x27;7&#x27;, &#x27;9&#x27;}},
12007                  {{&#x27;8&#x27;, &#x27;0&#x27;}}, {{&#x27;8&#x27;, &#x27;1&#x27;}}, {{&#x27;8&#x27;, &#x27;2&#x27;}}, {{&#x27;8&#x27;, &#x27;3&#x27;}}, {{&#x27;8&#x27;, &#x27;4&#x27;}}, {{&#x27;8&#x27;, &#x27;5&#x27;}}, {{&#x27;8&#x27;, &#x27;6&#x27;}}, {{&#x27;8&#x27;, &#x27;7&#x27;}}, {{&#x27;8&#x27;, &#x27;8&#x27;}}, {{&#x27;8&#x27;, &#x27;9&#x27;}},
12008                  {{&#x27;9&#x27;, &#x27;0&#x27;}}, {{&#x27;9&#x27;, &#x27;1&#x27;}}, {{&#x27;9&#x27;, &#x27;2&#x27;}}, {{&#x27;9&#x27;, &#x27;3&#x27;}}, {{&#x27;9&#x27;, &#x27;4&#x27;}}, {{&#x27;9&#x27;, &#x27;5&#x27;}}, {{&#x27;9&#x27;, &#x27;6&#x27;}}, {{&#x27;9&#x27;, &#x27;7&#x27;}}, {{&#x27;9&#x27;, &#x27;8&#x27;}}, {{&#x27;9&#x27;, &#x27;9&#x27;}},
12009              }
12010          };
12011          if (x == 0)
12012          {
12013              o-&gt;write_character(&#x27;0&#x27;);
12014              return;
12015          }
12016          auto buffer_ptr = number_buffer.begin(); 
12017          const bool is_negative = std::is_signed&lt;NumberType&gt;::value &amp;&amp; !(x &gt;= 0); 
12018          number_unsigned_t abs_value;
12019          unsigned int n_chars{};
12020          if (is_negative)
12021          {
12022              *buffer_ptr = &#x27;-&#x27;;
12023              abs_value = remove_sign(static_cast&lt;number_integer_t&gt;(x));
12024              n_chars = 1 + count_digits(abs_value);
12025          }
12026          else
12027          {
12028              abs_value = static_cast&lt;number_unsigned_t&gt;(x);
12029              n_chars = count_digits(abs_value);
12030          }
12031          JSON_ASSERT(n_chars &lt; number_buffer.size() - 1);
12032          buffer_ptr += n_chars;
12033          while (abs_value &gt;= 100)
12034          {
12035              const auto digits_index = static_cast&lt;unsigned&gt;((abs_value % 100));
12036              abs_value /= 100;
12037              *(--buffer_ptr) = digits_to_99[digits_index][1];
12038              *(--buffer_ptr) = digits_to_99[digits_index][0];
12039          }
12040          if (abs_value &gt;= 10)
12041          {
12042              const auto digits_index = static_cast&lt;unsigned&gt;(abs_value);
12043              *(--buffer_ptr) = digits_to_99[digits_index][1];
12044              *(--buffer_ptr) = digits_to_99[digits_index][0];
12045          }
12046          else
12047          {
12048              *(--buffer_ptr) = static_cast&lt;char&gt;(&#x27;0&#x27; + abs_value);
12049          }
12050          o-&gt;write_characters(number_buffer.data(), n_chars);
12051      }
12052      void dump_float(number_float_t x)
12053      {
12054          if (!std::isfinite(x))
12055          {
12056              o-&gt;write_characters(&quot;null&quot;, 4);
12057              return;
12058          }
12059          static constexpr bool is_ieee_single_or_double
12060              = (std::numeric_limits&lt;number_float_t&gt;::is_iec559 &amp;&amp; std::numeric_limits&lt;number_float_t&gt;::digits == 24 &amp;&amp; std::numeric_limits&lt;number_float_t&gt;::max_exponent == 128) ||
12061                (std::numeric_limits&lt;number_float_t&gt;::is_iec559 &amp;&amp; std::numeric_limits&lt;number_float_t&gt;::digits == 53 &amp;&amp; std::numeric_limits&lt;number_float_t&gt;::max_exponent == 1024);
12062          dump_float(x, std::integral_constant&lt;bool, is_ieee_single_or_double&gt;());
12063      }
12064      void dump_float(number_float_t x, std::true_type &amp;bsol;*is_ieee_single_or_double*/)
12065      {
12066          auto* begin = number_buffer.data();
12067          auto* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);
12068          o-&gt;write_characters(begin, static_cast&lt;size_t&gt;(end - begin));
12069      }
12070      void dump_float(number_float_t x, std::false_type &amp;bsol;*is_ieee_single_or_double*/)
12071      {
12072          static constexpr auto d = std::numeric_limits&lt;number_float_t&gt;::max_digits10;
12073          std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), &quot;%.*g&quot;, d, x);
12074          JSON_ASSERT(len &gt; 0);
12075          JSON_ASSERT(static_cast&lt;std::size_t&gt;(len) &lt; number_buffer.size());
12076          if (thousands_sep != &#x27;\0&#x27;)
12077          {
12078              auto* const end = std::remove(number_buffer.begin(),
12079                                            number_buffer.begin() + len, thousands_sep);
12080              std::fill(end, number_buffer.end(), &#x27;\0&#x27;);
12081              JSON_ASSERT((end - number_buffer.begin()) &lt;= len);
12082              len = (end - number_buffer.begin());
12083          }
12084          if (decimal_point != &#x27;\0&#x27; &amp;&amp; decimal_point != &#x27;.&#x27;)
12085          {
12086              auto* const dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
12087              if (dec_pos != number_buffer.end())
12088              {
12089                  *dec_pos = &#x27;.&#x27;;
12090              }
12091          }
12092          o-&gt;write_characters(number_buffer.data(), static_cast&lt;std::size_t&gt;(len));
12093          const bool value_is_int_like =
12094              std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
12095                           [](char c)
12096          {
12097              return c == &#x27;.&#x27; || c == &#x27;e&#x27;;
12098          });
12099          if (value_is_int_like)
12100          {
12101              o-&gt;write_characters(&quot;.0&quot;, 2);
12102          }
12103      }
12104      static std::uint8_t decode(std::uint8_t&amp; state, std::uint32_t&amp; codep, const std::uint8_t byte) noexcept
12105      {
12106          static const std::array&lt;std::uint8_t, 400&gt; utf8d =
12107          {
12108              {
12109                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
12110                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
12111                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
12112                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
12113                  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
12114                  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
12115                  8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
12116                  0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, 
12117                  0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 
12118                  0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, 
12119                  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 
12120                  1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 
12121                  1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 
12122                  1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 
12123              }
12124          };
12125          JSON_ASSERT(byte &lt; utf8d.size());
12126          const std::uint8_t type = utf8d[byte];
12127          codep = (state != UTF8_ACCEPT)
12128                  ? (byte &amp; 0x3fu) | (codep &lt;&lt; 6u)
12129                  : (0xFFu &gt;&gt; type) &amp; (byte);
12130          std::size_t index = 256u + static_cast&lt;size_t&gt;(state) * 16u + static_cast&lt;size_t&gt;(type);
12131          JSON_ASSERT(index &lt; 400);
12132          state = utf8d[index];
12133          return state;
12134      }
12135      number_unsigned_t remove_sign(number_unsigned_t x)
12136      {
12137          JSON_ASSERT(false); 
12138          return x; 
12139      }
12140      inline number_unsigned_t remove_sign(number_integer_t x) noexcept
12141      {
12142          JSON_ASSERT(x &lt; 0 &amp;&amp; x &lt; (std::numeric_limits&lt;number_integer_t&gt;::max)()); 
12143          return static_cast&lt;number_unsigned_t&gt;(-(x + 1)) + 1;
12144      }
12145    private:
12146      output_adapter_t&lt;char&gt; o = nullptr;
12147      std::array&lt;char, 64&gt; number_buffer{{}};
12148      const std::lconv* loc = nullptr;
12149      const char thousands_sep = &#x27;\0&#x27;;
12150      const char decimal_point = &#x27;\0&#x27;;
12151      std::array&lt;char, 512&gt; string_buffer{{}};
12152      const char indent_char;
12153      string_t indent_string;
12154      const error_handler_t error_handler;
12155  };
12156  }  
12157  }  
12158  #include &lt;functional&gt; 
12159  #include &lt;initializer_list&gt; 
12160  #include &lt;iterator&gt; 
12161  #include &lt;memory&gt; 
12162  #include &lt;stdexcept&gt; 
12163  #include &lt;type_traits&gt; 
12164  #include &lt;utility&gt; 
12165  #include &lt;vector&gt; 
12166  namespace nlohmann
12167  {
12168  template &lt;class Key, class T, class IgnoredLess = std::less&lt;Key&gt;,
12169            class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
12170                    struct ordered_map : std::vector&lt;std::pair&lt;const Key, T&gt;, Allocator&gt;
12171  {
12172      using key_type = Key;
12173      using mapped_type = T;
12174      using Container = std::vector&lt;std::pair&lt;const Key, T&gt;, Allocator&gt;;
12175      using typename Container::iterator;
12176      using typename Container::const_iterator;
12177      using typename Container::size_type;
12178      using typename Container::value_type;
12179      ordered_map(const Allocator&amp; alloc = Allocator()) : Container{alloc} {}
12180      template &lt;class It&gt;
12181      ordered_map(It first, It last, const Allocator&amp; alloc = Allocator())
12182          : Container{first, last, alloc} {}
12183      ordered_map(std::initializer_list&lt;T&gt; init, const Allocator&amp; alloc = Allocator() )
12184          : Container{init, alloc} {}
12185      std::pair&lt;iterator, bool&gt; emplace(const key_type&amp; key, T&amp;&amp; t)
12186      {
12187          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
12188          {
12189              if (it-&gt;first == key)
12190              {
12191                  return {it, false};
12192              }
12193          }
12194          Container::emplace_back(key, t);
12195          return {--this-&gt;end(), true};
12196      }
12197      T&amp; operator[](const Key&amp; key)
12198      {
12199          return emplace(key, T{}).first-&gt;second;
12200      }
12201      const T&amp; operator[](const Key&amp; key) const
12202      {
12203          return at(key);
12204      }
12205      T&amp; at(const Key&amp; key)
12206      {
12207          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
12208          {
12209              if (it-&gt;first == key)
12210              {
12211                  return it-&gt;second;
12212              }
12213          }
12214          JSON_THROW(std::out_of_range(&quot;key not found&quot;));
12215      }
12216      const T&amp; at(const Key&amp; key) const
12217      {
12218          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
12219          {
12220              if (it-&gt;first == key)
12221              {
12222                  return it-&gt;second;
12223              }
12224          }
12225          JSON_THROW(std::out_of_range(&quot;key not found&quot;));
12226      }
12227      size_type erase(const Key&amp; key)
12228      {
12229          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
12230          {
12231              if (it-&gt;first == key)
12232              {
12233                  for (auto next = it; ++next != this-&gt;end(); ++it)
12234                  {
12235                      it-&gt;~value_type(); 
12236                      new (&amp;*it) value_type{std::move(*next)};
12237                  }
12238                  Container::pop_back();
12239                  return 1;
12240              }
12241          }
12242          return 0;
12243      }
12244      iterator erase(iterator pos)
12245      {
12246          auto it = pos;
12247          for (auto next = it; ++next != this-&gt;end(); ++it)
12248          {
12249              it-&gt;~value_type(); 
12250              new (&amp;*it) value_type{std::move(*next)};
12251          }
12252          Container::pop_back();
12253          return pos;
12254      }
12255      size_type count(const Key&amp; key) const
12256      {
12257          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
12258          {
12259              if (it-&gt;first == key)
12260              {
12261                  return 1;
12262              }
12263          }
12264          return 0;
12265      }
12266      iterator find(const Key&amp; key)
12267      {
12268          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
12269          {
12270              if (it-&gt;first == key)
12271              {
12272                  return it;
12273              }
12274          }
12275          return Container::end();
12276      }
12277      const_iterator find(const Key&amp; key) const
12278      {
12279          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
12280          {
12281              if (it-&gt;first == key)
12282              {
12283                  return it;
12284              }
12285          }
12286          return Container::end();
12287      }
12288      std::pair&lt;iterator, bool&gt; insert( value_type&amp;&amp; value )
12289      {
12290          return emplace(value.first, std::move(value.second));
12291      }
12292      std::pair&lt;iterator, bool&gt; insert( const value_type&amp; value )
12293      {
12294          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
12295          {
12296              if (it-&gt;first == value.first)
12297              {
12298                  return {it, false};
12299              }
12300          }
12301          Container::push_back(value);
12302          return {--this-&gt;end(), true};
12303      }
12304      template&lt;typename InputIt&gt;
12305      using require_input_iter = typename std::enable_if&lt;std::is_convertible&lt;typename std::iterator_traits&lt;InputIt&gt;::iterator_category,
12306              std::input_iterator_tag&gt;::value&gt;::type;
12307      template&lt;typename InputIt, typename = require_input_iter&lt;InputIt&gt;&gt;
12308      void insert(InputIt first, InputIt last)
12309      {
12310          for (auto it = first; it != last; ++it)
12311          {
12312              insert(*it);
12313          }
12314      }
12315  };
12316  }  
12317  #if defined(JSON_HAS_CPP_17)
12318      #include &lt;string_view&gt;
12319  #endif
12320  namespace nlohmann
12321  {
12322  NLOHMANN_BASIC_JSON_TPL_DECLARATION
12323  class basic_json 
12324  {
12325    private:
12326      template&lt;detail::value_t&gt; friend struct detail::external_constructor;
12327      friend ::nlohmann::json_pointer&lt;basic_json&gt;;
12328      template&lt;typename BasicJsonType, typename InputType&gt;
12329      friend class ::nlohmann::detail::parser;
12330      friend ::nlohmann::detail::serializer&lt;basic_json&gt;;
12331      template&lt;typename BasicJsonType&gt;
12332      friend class ::nlohmann::detail::iter_impl;
12333      template&lt;typename BasicJsonType, typename CharType&gt;
12334      friend class ::nlohmann::detail::binary_writer;
12335      template&lt;typename BasicJsonType, typename InputType, typename SAX&gt;
12336      friend class ::nlohmann::detail::binary_reader;
12337      template&lt;typename BasicJsonType&gt;
12338      friend class ::nlohmann::detail::json_sax_dom_parser;
12339      template&lt;typename BasicJsonType&gt;
12340      friend class ::nlohmann::detail::json_sax_dom_callback_parser;
12341      friend class ::nlohmann::detail::exception;
12342      using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
12343    JSON_PRIVATE_UNLESS_TESTED:
12344      using lexer = ::nlohmann::detail::lexer_base&lt;basic_json&gt;;
12345      template&lt;typename InputAdapterType&gt;
12346      static ::nlohmann::detail::parser&lt;basic_json, InputAdapterType&gt; parser(
12347          InputAdapterType adapter,
12348          detail::parser_callback_t&lt;basic_json&gt;cb = nullptr,
12349          const bool allow_exceptions = true,
12350          const bool ignore_comments = false
12351                                   )
12352      {
12353          return ::nlohmann::detail::parser&lt;basic_json, InputAdapterType&gt;(std::move(adapter),
12354                  std::move(cb), allow_exceptions, ignore_comments);
12355      }
12356    private:
12357      using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
12358      template&lt;typename BasicJsonType&gt;
12359      using internal_iterator = ::nlohmann::detail::internal_iterator&lt;BasicJsonType&gt;;
12360      template&lt;typename BasicJsonType&gt;
12361      using iter_impl = ::nlohmann::detail::iter_impl&lt;BasicJsonType&gt;;
12362      template&lt;typename Iterator&gt;
12363      using iteration_proxy = ::nlohmann::detail::iteration_proxy&lt;Iterator&gt;;
12364      template&lt;typename Base&gt; using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator&lt;Base&gt;;
12365      template&lt;typename CharType&gt;
12366      using output_adapter_t = ::nlohmann::detail::output_adapter_t&lt;CharType&gt;;
12367      template&lt;typename InputType&gt;
12368      using binary_reader = ::nlohmann::detail::binary_reader&lt;basic_json, InputType&gt;;
12369      template&lt;typename CharType&gt; using binary_writer = ::nlohmann::detail::binary_writer&lt;basic_json, CharType&gt;;
12370    JSON_PRIVATE_UNLESS_TESTED:
12371      using serializer = ::nlohmann::detail::serializer&lt;basic_json&gt;;
12372    public:
12373      using value_t = detail::value_t;
12374      using json_pointer = ::nlohmann::json_pointer&lt;basic_json&gt;;
12375      template&lt;typename T, typename SFINAE&gt;
12376      using json_serializer = JSONSerializer&lt;T, SFINAE&gt;;
12377      using error_handler_t = detail::error_handler_t;
12378      using cbor_tag_handler_t = detail::cbor_tag_handler_t;
12379      using initializer_list_t = std::initializer_list&lt;detail::json_ref&lt;basic_json&gt;&gt;;
12380      using input_format_t = detail::input_format_t;
12381      using json_sax_t = json_sax&lt;basic_json&gt;;
12382      using exception = detail::exception;
12383      using parse_error = detail::parse_error;
12384      using invalid_iterator = detail::invalid_iterator;
12385      using type_error = detail::type_error;
12386      using out_of_range = detail::out_of_range;
12387      using other_error = detail::other_error;
12388      using value_type = basic_json;
12389      using reference = value_type&amp;;
12390      using const_reference = const value_type&amp;;
12391      using difference_type = std::ptrdiff_t;
12392      using size_type = std::size_t;
12393      using allocator_type = AllocatorType&lt;basic_json&gt;;
12394      using pointer = typename std::allocator_traits&lt;allocator_type&gt;::pointer;
12395      using const_pointer = typename std::allocator_traits&lt;allocator_type&gt;::const_pointer;
12396      using iterator = iter_impl&lt;basic_json&gt;;
12397      using const_iterator = iter_impl&lt;const basic_json&gt;;
12398      using reverse_iterator = json_reverse_iterator&lt;typename basic_json::iterator&gt;;
12399      using const_reverse_iterator = json_reverse_iterator&lt;typename basic_json::const_iterator&gt;;
12400      static allocator_type get_allocator()
12401      {
12402          return allocator_type();
12403      }
12404      JSON_HEDLEY_WARN_UNUSED_RESULT
12405      static basic_json meta()
12406      {
12407          basic_json result;
12408          result[&quot;copyright&quot;] = &quot;(C) 2013-2021 Niels Lohmann&quot;;
12409          result[&quot;name&quot;] = &quot;JSON for Modern C++&quot;;
12410          result[&quot;url&quot;] = &quot;https:&amp;bsol;&amp;bsol;github.com/nlohmann/json&quot;;
12411          result[&quot;version&quot;][&quot;string&quot;] =
12412              std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + &quot;.&quot; +
12413              std::to_string(NLOHMANN_JSON_VERSION_MINOR) + &quot;.&quot; +
12414              std::to_string(NLOHMANN_JSON_VERSION_PATCH);
12415          result[&quot;version&quot;][&quot;major&quot;] = NLOHMANN_JSON_VERSION_MAJOR;
12416          result[&quot;version&quot;][&quot;minor&quot;] = NLOHMANN_JSON_VERSION_MINOR;
12417          result[&quot;version&quot;][&quot;patch&quot;] = NLOHMANN_JSON_VERSION_PATCH;
12418  #ifdef _WIN32
12419          result[&quot;platform&quot;] = &quot;win32&quot;;
12420  #elif defined __linux__
12421          result[&quot;platform&quot;] = &quot;linux&quot;;
12422  #elif defined __APPLE__
12423          result[&quot;platform&quot;] = &quot;apple&quot;;
12424  #elif defined __unix__
12425          result[&quot;platform&quot;] = &quot;unix&quot;;
12426  #else
12427          result[&quot;platform&quot;] = &quot;unknown&quot;;
12428  #endif
12429  #if defined(__ICC) || defined(__INTEL_COMPILER)
12430          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;icc&quot;}, {&quot;version&quot;, __INTEL_COMPILER}};
12431  #elif defined(__clang__)
12432          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;clang&quot;}, {&quot;version&quot;, __clang_version__}};
12433  #elif defined(__GNUC__) || defined(__GNUG__)
12434          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;gcc&quot;}, {&quot;version&quot;, std::to_string(__GNUC__) + &quot;.&quot; + std::to_string(__GNUC_MINOR__) + &quot;.&quot; + std::to_string(__GNUC_PATCHLEVEL__)}};
12435  #elif defined(__HP_cc) || defined(__HP_aCC)
12436          result[&quot;compiler&quot;] = &quot;hp&quot;
12437  #elif defined(__IBMCPP__)
12438          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;ilecpp&quot;}, {&quot;version&quot;, __IBMCPP__}};
12439  #elif defined(_MSC_VER)
12440          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;msvc&quot;}, {&quot;version&quot;, _MSC_VER}};
12441  #elif defined(__PGI)
12442          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;pgcpp&quot;}, {&quot;version&quot;, __PGI}};
12443  #elif defined(__SUNPRO_CC)
12444          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;sunpro&quot;}, {&quot;version&quot;, __SUNPRO_CC}};
12445  #else
12446          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;unknown&quot;}, {&quot;version&quot;, &quot;unknown&quot;}};
12447  #endif
12448  #ifdef __cplusplus
12449          result[&quot;compiler&quot;][&quot;c++&quot;] = std::to_string(__cplusplus);
12450  #else
12451          result[&quot;compiler&quot;][&quot;c++&quot;] = &quot;unknown&quot;;
12452  #endif
12453          return result;
12454      }
12455  #if defined(JSON_HAS_CPP_14)
12456      using object_comparator_t = std::less&lt;&gt;;
12457  #else
12458      using object_comparator_t = std::less&lt;StringType&gt;;
12459  #endif
12460      using object_t = ObjectType&lt;StringType,
12461            basic_json,
12462            object_comparator_t,
12463            AllocatorType&lt;std::pair&lt;const StringType,
12464            basic_json&gt;&gt;&gt;;
12465      using array_t = ArrayType&lt;basic_json, AllocatorType&lt;basic_json&gt;&gt;;
12466      using string_t = StringType;
12467      using boolean_t = BooleanType;
12468      using number_integer_t = NumberIntegerType;
12469      using number_unsigned_t = NumberUnsignedType;
12470      using number_float_t = NumberFloatType;
12471      using binary_t = nlohmann::byte_container_with_subtype&lt;BinaryType&gt;;
12472    private:
12473      template&lt;typename T, typename... Args&gt;
12474      JSON_HEDLEY_RETURNS_NON_NULL
12475      static T* create(Args&amp;&amp; ... args)
12476      {
12477          AllocatorType&lt;T&gt; alloc;
12478          using AllocatorTraits = std::allocator_traits&lt;AllocatorType&lt;T&gt;&gt;;
12479          auto deleter = [&amp;](T * obj)
12480          {
12481              AllocatorTraits::deallocate(alloc, obj, 1);
12482          };
12483          std::unique_ptr&lt;T, decltype(deleter)&gt; obj(AllocatorTraits::allocate(alloc, 1), deleter);
12484          AllocatorTraits::construct(alloc, obj.get(), std::forward&lt;Args&gt;(args)...);
12485          JSON_ASSERT(obj != nullptr);
12486          return obj.release();
12487      }
12488    JSON_PRIVATE_UNLESS_TESTED:
12489      union json_value
12490      {
12491          object_t* object;
12492          array_t* array;
12493          string_t* string;
12494          binary_t* binary;
12495          boolean_t boolean;
12496          number_integer_t number_integer;
12497          number_unsigned_t number_unsigned;
12498          number_float_t number_float;
12499          json_value() = default;
12500          json_value(boolean_t v) noexcept : boolean(v) {}
12501          json_value(number_integer_t v) noexcept : number_integer(v) {}
12502          json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
12503          json_value(number_float_t v) noexcept : number_float(v) {}
12504          json_value(value_t t)
12505          {
12506              switch (t)
12507              {
12508                  case value_t::object:
12509                  {
12510                      object = create&lt;object_t&gt;();
12511                      break;
12512                  }
12513                  case value_t::array:
12514                  {
12515                      array = create&lt;array_t&gt;();
12516                      break;
12517                  }
12518                  case value_t::string:
12519                  {
12520                      string = create&lt;string_t&gt;(&quot;&quot;);
12521                      break;
12522                  }
12523                  case value_t::binary:
12524                  {
12525                      binary = create&lt;binary_t&gt;();
12526                      break;
12527                  }
12528                  case value_t::boolean:
12529                  {
12530                      boolean = boolean_t(false);
12531                      break;
12532                  }
12533                  case value_t::number_integer:
12534                  {
12535                      number_integer = number_integer_t(0);
12536                      break;
12537                  }
12538                  case value_t::number_unsigned:
12539                  {
12540                      number_unsigned = number_unsigned_t(0);
12541                      break;
12542                  }
12543                  case value_t::number_float:
12544                  {
12545                      number_float = number_float_t(0.0);
12546                      break;
12547                  }
12548                  case value_t::null:
12549                  {
12550                      object = nullptr;  
12551                      break;
12552                  }
12553                  case value_t::discarded:
12554                  default:
12555                  {
12556                      object = nullptr;  
12557                      if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
12558                      {
12559                          JSON_THROW(other_error::create(500, &quot;961c151d2e87f2686a955a9be24d316f1362bf21 3.10.2&quot;, basic_json())); 
12560                      }
12561                      break;
12562                  }
12563              }
12564          }
12565          json_value(const string_t&amp; value)
12566          {
12567              string = create&lt;string_t&gt;(value);
12568          }
12569          json_value(string_t&amp;&amp; value)
12570          {
12571              string = create&lt;string_t&gt;(std::move(value));
12572          }
12573          json_value(const object_t&amp; value)
12574          {
12575              object = create&lt;object_t&gt;(value);
12576          }
12577          json_value(object_t&amp;&amp; value)
12578          {
12579              object = create&lt;object_t&gt;(std::move(value));
12580          }
12581          json_value(const array_t&amp; value)
12582          {
12583              array = create&lt;array_t&gt;(value);
12584          }
12585          json_value(array_t&amp;&amp; value)
12586          {
12587              array = create&lt;array_t&gt;(std::move(value));
12588          }
12589          json_value(const typename binary_t::container_type&amp; value)
12590          {
12591              binary = create&lt;binary_t&gt;(value);
12592          }
12593          json_value(typename binary_t::container_type&amp;&amp; value)
12594          {
12595              binary = create&lt;binary_t&gt;(std::move(value));
12596          }
12597          json_value(const binary_t&amp; value)
12598          {
12599              binary = create&lt;binary_t&gt;(value);
12600          }
12601          json_value(binary_t&amp;&amp; value)
12602          {
12603              binary = create&lt;binary_t&gt;(std::move(value));
12604          }
12605          void destroy(value_t t)
12606          {
12607              if (t == value_t::array || t == value_t::object)
12608              {
12609                  std::vector&lt;basic_json&gt; stack;
12610                  if (t == value_t::array)
12611                  {
12612                      stack.reserve(array-&gt;size());
12613                      std::move(array-&gt;begin(), array-&gt;end(), std::back_inserter(stack));
12614                  }
12615                  else
12616                  {
12617                      stack.reserve(object-&gt;size());
12618                      for (auto&amp;&amp; it : *object)
12619                      {
12620                          stack.push_back(std::move(it.second));
12621                      }
12622                  }
12623                  while (!stack.empty())
12624                  {
12625                      basic_json current_item(std::move(stack.back()));
12626                      stack.pop_back();
12627                      if (current_item.is_array())
12628                      {
12629                          std::move(current_item.m_value.array-&gt;begin(), current_item.m_value.array-&gt;end(), std::back_inserter(stack));
12630                          current_item.m_value.array-&gt;clear();
12631                      }
12632                      else if (current_item.is_object())
12633                      {
12634                          for (auto&amp;&amp; it : *current_item.m_value.object)
12635                          {
12636                              stack.push_back(std::move(it.second));
12637                          }
12638                          current_item.m_value.object-&gt;clear();
12639                      }
12640                  }
12641              }
12642              switch (t)
12643              {
12644                  case value_t::object:
12645                  {
12646                      AllocatorType&lt;object_t&gt; alloc;
12647                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, object);
12648                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, object, 1);
12649                      break;
12650                  }
12651                  case value_t::array:
12652                  {
12653                      AllocatorType&lt;array_t&gt; alloc;
12654                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, array);
12655                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, array, 1);
12656                      break;
12657                  }
12658                  case value_t::string:
12659                  {
12660                      AllocatorType&lt;string_t&gt; alloc;
12661                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, string);
12662                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, string, 1);
12663                      break;
12664                  }
12665                  case value_t::binary:
12666                  {
12667                      AllocatorType&lt;binary_t&gt; alloc;
12668                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, binary);
12669                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, binary, 1);
12670                      break;
12671                  }
12672                  case value_t::null:
12673                  case value_t::boolean:
12674                  case value_t::number_integer:
12675                  case value_t::number_unsigned:
12676                  case value_t::number_float:
12677                  case value_t::discarded:
12678                  default:
12679                  {
12680                      break;
12681                  }
12682              }
12683          }
12684      };
12685    private:
12686      void assert_invariant(bool check_parents = true) const noexcept
12687      {
12688          JSON_ASSERT(m_type != value_t::object || m_value.object != nullptr);
12689          JSON_ASSERT(m_type != value_t::array || m_value.array != nullptr);
12690          JSON_ASSERT(m_type != value_t::string || m_value.string != nullptr);
12691          JSON_ASSERT(m_type != value_t::binary || m_value.binary != nullptr);
12692  #if JSON_DIAGNOSTICS
12693          JSON_TRY
12694          {
12695              JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [this](const basic_json &amp; j)
12696              {
12697                  return j.m_parent == this;
12698              }));
12699          }
12700          JSON_CATCH(...) {} 
12701  #endif
12702          static_cast&lt;void&gt;(check_parents);
12703      }
12704      void set_parents()
12705      {
12706  #if JSON_DIAGNOSTICS
12707          switch (m_type)
12708          {
12709              case value_t::array:
12710              {
12711                  for (auto&amp; element : *m_value.array)
12712                  {
12713                      element.m_parent = this;
12714                  }
12715                  break;
12716              }
12717              case value_t::object:
12718              {
12719                  for (auto&amp; element : *m_value.object)
12720                  {
12721                      element.second.m_parent = this;
12722                  }
12723                  break;
12724              }
12725              case value_t::null:
12726              case value_t::string:
12727              case value_t::boolean:
12728              case value_t::number_integer:
12729              case value_t::number_unsigned:
12730              case value_t::number_float:
12731              case value_t::binary:
12732              case value_t::discarded:
12733              default:
12734                  break;
12735          }
12736  #endif
12737      }
12738      iterator set_parents(iterator it, typename iterator::difference_type count)
12739      {
12740  #if JSON_DIAGNOSTICS
12741          for (typename iterator::difference_type i = 0; i &lt; count; ++i)
12742          {
12743              (it + i)-&gt;m_parent = this;
12744          }
12745  #else
12746          static_cast&lt;void&gt;(count);
12747  #endif
12748          return it;
12749      }
12750      reference set_parent(reference j, std::size_t old_capacity = std::size_t(-1))
12751      {
12752  #if JSON_DIAGNOSTICS
12753          if (old_capacity != std::size_t(-1))
12754          {
12755              JSON_ASSERT(type() == value_t::array);
12756              if (JSON_HEDLEY_UNLIKELY(m_value.array-&gt;capacity() != old_capacity))
12757              {
12758                  set_parents();
12759                  return j;
12760              }
12761          }
12762  #ifdef JSON_HEDLEY_MSVC_VERSION
12763  #pragma warning(push )
12764  #pragma warning(disable : 4127) 
12765  #endif
12766          if (detail::is_ordered_map&lt;object_t&gt;::value)
12767          {
12768              set_parents();
12769              return j;
12770          }
12771  #ifdef JSON_HEDLEY_MSVC_VERSION
12772  #pragma warning( pop )
12773  #endif
12774          j.m_parent = this;
12775  #else
12776          static_cast&lt;void&gt;(j);
12777          static_cast&lt;void&gt;(old_capacity);
12778  #endif
12779          return j;
12780      }
12781    public:
12782      using parse_event_t = detail::parse_event_t;
12783      using parser_callback_t = detail::parser_callback_t&lt;basic_json&gt;;
12784      basic_json(const value_t v)
12785          : m_type(v), m_value(v)
12786      {
12787          assert_invariant();
12788      }
12789      basic_json(std::nullptr_t = nullptr) noexcept
12790          : basic_json(value_t::null)
12791      {
12792          assert_invariant();
12793      }
12794      template &lt; typename CompatibleType,
12795                 typename U = detail::uncvref_t&lt;CompatibleType&gt;,
12796                 detail::enable_if_t &lt;
12797                     !detail::is_basic_json&lt;U&gt;::value &amp;&amp; detail::is_compatible_type&lt;basic_json_t, U&gt;::value, int &gt; = 0 &gt;
12798      basic_json(CompatibleType &amp;&amp; val) noexcept(noexcept( 
12799                  JSONSerializer&lt;U&gt;::to_json(std::declval&lt;basic_json_t&amp;&gt;(),
12800                                             std::forward&lt;CompatibleType&gt;(val))))
12801      {
12802          JSONSerializer&lt;U&gt;::to_json(*this, std::forward&lt;CompatibleType&gt;(val));
12803          set_parents();
12804          assert_invariant();
12805      }
12806      template &lt; typename BasicJsonType,
12807                 detail::enable_if_t &lt;
12808                     detail::is_basic_json&lt;BasicJsonType&gt;::value&amp;&amp; !std::is_same&lt;basic_json, BasicJsonType&gt;::value, int &gt; = 0 &gt;
12809      basic_json(const BasicJsonType&amp; val)
12810      {
12811          using other_boolean_t = typename BasicJsonType::boolean_t;
12812          using other_number_float_t = typename BasicJsonType::number_float_t;
12813          using other_number_integer_t = typename BasicJsonType::number_integer_t;
12814          using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
12815          using other_string_t = typename BasicJsonType::string_t;
12816          using other_object_t = typename BasicJsonType::object_t;
12817          using other_array_t = typename BasicJsonType::array_t;
12818          using other_binary_t = typename BasicJsonType::binary_t;
12819          switch (val.type())
12820          {
12821              case value_t::boolean:
12822                  JSONSerializer&lt;other_boolean_t&gt;::to_json(*this, val.template get&lt;other_boolean_t&gt;());
12823                  break;
12824              case value_t::number_float:
12825                  JSONSerializer&lt;other_number_float_t&gt;::to_json(*this, val.template get&lt;other_number_float_t&gt;());
12826                  break;
12827              case value_t::number_integer:
12828                  JSONSerializer&lt;other_number_integer_t&gt;::to_json(*this, val.template get&lt;other_number_integer_t&gt;());
12829                  break;
12830              case value_t::number_unsigned:
12831                  JSONSerializer&lt;other_number_unsigned_t&gt;::to_json(*this, val.template get&lt;other_number_unsigned_t&gt;());
12832                  break;
12833              case value_t::string:
12834                  JSONSerializer&lt;other_string_t&gt;::to_json(*this, val.template get_ref&lt;const other_string_t&amp;&gt;());
12835                  break;
12836              case value_t::object:
12837                  JSONSerializer&lt;other_object_t&gt;::to_json(*this, val.template get_ref&lt;const other_object_t&amp;&gt;());
12838                  break;
12839              case value_t::array:
12840                  JSONSerializer&lt;other_array_t&gt;::to_json(*this, val.template get_ref&lt;const other_array_t&amp;&gt;());
12841                  break;
12842              case value_t::binary:
12843                  JSONSerializer&lt;other_binary_t&gt;::to_json(*this, val.template get_ref&lt;const other_binary_t&amp;&gt;());
12844                  break;
12845              case value_t::null:
12846                  *this = nullptr;
12847                  break;
12848              case value_t::discarded:
12849                  m_type = value_t::discarded;
12850                  break;
12851              default:            
12852                  JSON_ASSERT(false); 
12853          }
12854          set_parents();
12855          assert_invariant();
12856      }
12857      basic_json(initializer_list_t init,
12858                 bool type_deduction = true,
12859                 value_t manual_type = value_t::array)
12860      {
12861          bool is_an_object = std::all_of(init.begin(), init.end(),
12862                                          [](const detail::json_ref&lt;basic_json&gt;&amp; element_ref)
12863          {
12864              return element_ref-&gt;is_array() &amp;&amp; element_ref-&gt;size() == 2 &amp;&amp; (*element_ref)[0].is_string();
12865          });
12866          if (!type_deduction)
12867          {
12868              if (manual_type == value_t::array)
12869              {
12870                  is_an_object = false;
12871              }
12872              if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object &amp;&amp; !is_an_object))
12873              {
12874                  JSON_THROW(type_error::create(301, &quot;cannot create object from initializer list&quot;, basic_json()));
12875              }
12876          }
12877          if (is_an_object)
12878          {
12879              m_type = value_t::object;
12880              m_value = value_t::object;
12881              for (auto&amp; element_ref : init)
12882              {
12883                  auto element = element_ref.moved_or_copied();
12884                  m_value.object-&gt;emplace(
12885                      std::move(*((*element.m_value.array)[0].m_value.string)),
12886                      std::move((*element.m_value.array)[1]));
12887              }
12888          }
12889          else
12890          {
12891              m_type = value_t::array;
12892              m_value.array = create&lt;array_t&gt;(init.begin(), init.end());
12893          }
12894          set_parents();
12895          assert_invariant();
12896      }
12897      JSON_HEDLEY_WARN_UNUSED_RESULT
12898      static basic_json binary(const typename binary_t::container_type&amp; init)
12899      {
12900          auto res = basic_json();
12901          res.m_type = value_t::binary;
12902          res.m_value = init;
12903          return res;
12904      }
12905      JSON_HEDLEY_WARN_UNUSED_RESULT
12906      static basic_json binary(const typename binary_t::container_type&amp; init, typename binary_t::subtype_type subtype)
12907      {
12908          auto res = basic_json();
12909          res.m_type = value_t::binary;
12910          res.m_value = binary_t(init, subtype);
12911          return res;
12912      }
12913      JSON_HEDLEY_WARN_UNUSED_RESULT
12914      static basic_json binary(typename binary_t::container_type&amp;&amp; init)
12915      {
12916          auto res = basic_json();
12917          res.m_type = value_t::binary;
12918          res.m_value = std::move(init);
12919          return res;
12920      }
12921      JSON_HEDLEY_WARN_UNUSED_RESULT
12922      static basic_json binary(typename binary_t::container_type&amp;&amp; init, typename binary_t::subtype_type subtype)
12923      {
12924          auto res = basic_json();
12925          res.m_type = value_t::binary;
12926          res.m_value = binary_t(std::move(init), subtype);
12927          return res;
12928      }
12929      JSON_HEDLEY_WARN_UNUSED_RESULT
12930      static basic_json array(initializer_list_t init = {})
12931      {
12932          return basic_json(init, false, value_t::array);
12933      }
12934      JSON_HEDLEY_WARN_UNUSED_RESULT
12935      static basic_json object(initializer_list_t init = {})
12936      {
12937          return basic_json(init, false, value_t::object);
12938      }
12939      basic_json(size_type cnt, const basic_json&amp; val)
12940          : m_type(value_t::array)
12941      {
12942          m_value.array = create&lt;array_t&gt;(cnt, val);
12943          set_parents();
12944          assert_invariant();
12945      }
12946      template &lt; class InputIT, typename std::enable_if &lt;
12947                     std::is_same&lt;InputIT, typename basic_json_t::iterator&gt;::value ||
12948                     std::is_same&lt;InputIT, typename basic_json_t::const_iterator&gt;::value, int &gt;::type = 0 &gt;
12949      basic_json(InputIT first, InputIT last)
12950      {
12951          JSON_ASSERT(first.m_object != nullptr);
12952          JSON_ASSERT(last.m_object != nullptr);
12953          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
12954          {
12955              JSON_THROW(invalid_iterator::create(201, &quot;iterators are not compatible&quot;, basic_json()));
12956          }
12957          m_type = first.m_object-&gt;m_type;
12958          switch (m_type)
12959          {
12960              case value_t::boolean:
12961              case value_t::number_float:
12962              case value_t::number_integer:
12963              case value_t::number_unsigned:
12964              case value_t::string:
12965              {
12966                  if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
12967                                           || !last.m_it.primitive_iterator.is_end()))
12968                  {
12969                      JSON_THROW(invalid_iterator::create(204, &quot;iterators out of range&quot;, *first.m_object));
12970                  }
12971                  break;
12972              }
12973              case value_t::null:
12974              case value_t::object:
12975              case value_t::array:
12976              case value_t::binary:
12977              case value_t::discarded:
12978              default:
12979                  break;
12980          }
12981          switch (m_type)
12982          {
12983              case value_t::number_integer:
12984              {
12985                  m_value.number_integer = first.m_object-&gt;m_value.number_integer;
12986                  break;
12987              }
12988              case value_t::number_unsigned:
12989              {
12990                  m_value.number_unsigned = first.m_object-&gt;m_value.number_unsigned;
12991                  break;
12992              }
12993              case value_t::number_float:
12994              {
12995                  m_value.number_float = first.m_object-&gt;m_value.number_float;
12996                  break;
12997              }
12998              case value_t::boolean:
12999              {
13000                  m_value.boolean = first.m_object-&gt;m_value.boolean;
13001                  break;
13002              }
13003              case value_t::string:
13004              {
13005                  m_value = *first.m_object-&gt;m_value.string;
13006                  break;
13007              }
13008              case value_t::object:
13009              {
13010                  m_value.object = create&lt;object_t&gt;(first.m_it.object_iterator,
13011                                                    last.m_it.object_iterator);
13012                  break;
13013              }
13014              case value_t::array:
13015              {
13016                  m_value.array = create&lt;array_t&gt;(first.m_it.array_iterator,
13017                                                  last.m_it.array_iterator);
13018                  break;
13019              }
13020              case value_t::binary:
13021              {
13022                  m_value = *first.m_object-&gt;m_value.binary;
13023                  break;
13024              }
13025              case value_t::null:
13026              case value_t::discarded:
13027              default:
13028                  JSON_THROW(invalid_iterator::create(206, &quot;cannot construct with iterators from &quot; + std::string(first.m_object-&gt;type_name()), *first.m_object));
13029          }
13030          set_parents();
13031          assert_invariant();
13032      }
13033      template&lt;typename JsonRef,
13034               detail::enable_if_t&lt;detail::conjunction&lt;detail::is_json_ref&lt;JsonRef&gt;,
13035                                   std::is_same&lt;typename JsonRef::value_type, basic_json&gt;&gt;::value, int&gt; = 0 &gt;
13036      basic_json(const JsonRef&amp; ref) : basic_json(ref.moved_or_copied()) {}
13037      basic_json(const basic_json&amp; other)
13038          : m_type(other.m_type)
13039      {
13040          other.assert_invariant();
13041          switch (m_type)
13042          {
13043              case value_t::object:
13044              {
13045                  m_value = *other.m_value.object;
13046                  break;
13047              }
13048              case value_t::array:
13049              {
13050                  m_value = *other.m_value.array;
13051                  break;
13052              }
13053              case value_t::string:
13054              {
13055                  m_value = *other.m_value.string;
13056                  break;
13057              }
13058              case value_t::boolean:
13059              {
13060                  m_value = other.m_value.boolean;
13061                  break;
13062              }
13063              case value_t::number_integer:
13064              {
13065                  m_value = other.m_value.number_integer;
13066                  break;
13067              }
13068              case value_t::number_unsigned:
13069              {
13070                  m_value = other.m_value.number_unsigned;
13071                  break;
13072              }
13073              case value_t::number_float:
13074              {
13075                  m_value = other.m_value.number_float;
13076                  break;
13077              }
13078              case value_t::binary:
13079              {
13080                  m_value = *other.m_value.binary;
13081                  break;
13082              }
13083              case value_t::null:
13084              case value_t::discarded:
13085              default:
13086                  break;
13087          }
13088          set_parents();
13089          assert_invariant();
13090      }
13091      basic_json(basic_json&amp;&amp; other) noexcept
13092          : m_type(std::move(other.m_type)),
13093            m_value(std::move(other.m_value))
13094      {
13095          other.assert_invariant(false);
13096          other.m_type = value_t::null;
13097          other.m_value = {};
13098          set_parents();
13099          assert_invariant();
13100      }
13101      basic_json&amp; operator=(basic_json other) noexcept (
13102          std::is_nothrow_move_constructible&lt;value_t&gt;::value&amp;&amp;
13103          std::is_nothrow_move_assignable&lt;value_t&gt;::value&amp;&amp;
13104          std::is_nothrow_move_constructible&lt;json_value&gt;::value&amp;&amp;
13105          std::is_nothrow_move_assignable&lt;json_value&gt;::value
13106      )
13107      {
13108          other.assert_invariant();
13109          using std::swap;
13110          swap(m_type, other.m_type);
13111          swap(m_value, other.m_value);
13112          set_parents();
13113          assert_invariant();
13114          return *this;
13115      }
13116      ~basic_json() noexcept
13117      {
13118          assert_invariant(false);
13119          m_value.destroy(m_type);
13120      }
13121    public:
13122      string_t dump(const int indent = -1,
13123                    const char indent_char = &#x27; &#x27;,
13124                    const bool ensure_ascii = false,
13125                    const error_handler_t error_handler = error_handler_t::strict) const
13126      {
13127          string_t result;
13128          serializer s(detail::output_adapter&lt;char, string_t&gt;(result), indent_char, error_handler);
13129          if (indent &gt;= 0)
13130          {
13131              s.dump(*this, true, ensure_ascii, static_cast&lt;unsigned int&gt;(indent));
13132          }
13133          else
13134          {
13135              s.dump(*this, false, ensure_ascii, 0);
13136          }
13137          return result;
13138      }
13139      constexpr value_t type() const noexcept
13140      {
13141          return m_type;
13142      }
13143      constexpr bool is_primitive() const noexcept
13144      {
13145          return is_null() || is_string() || is_boolean() || is_number() || is_binary();
13146      }
13147      constexpr bool is_structured() const noexcept
13148      {
13149          return is_array() || is_object();
13150      }
13151      constexpr bool is_null() const noexcept
13152      {
13153          return m_type == value_t::null;
13154      }
13155      constexpr bool is_boolean() const noexcept
13156      {
13157          return m_type == value_t::boolean;
13158      }
13159      constexpr bool is_number() const noexcept
13160      {
13161          return is_number_integer() || is_number_float();
13162      }
13163      constexpr bool is_number_integer() const noexcept
13164      {
13165          return m_type == value_t::number_integer || m_type == value_t::number_unsigned;
13166      }
13167      constexpr bool is_number_unsigned() const noexcept
13168      {
13169          return m_type == value_t::number_unsigned;
13170      }
13171      constexpr bool is_number_float() const noexcept
13172      {
13173          return m_type == value_t::number_float;
13174      }
13175      constexpr bool is_object() const noexcept
13176      {
13177          return m_type == value_t::object;
13178      }
13179      constexpr bool is_array() const noexcept
13180      {
13181          return m_type == value_t::array;
13182      }
13183      constexpr bool is_string() const noexcept
13184      {
13185          return m_type == value_t::string;
13186      }
13187      constexpr bool is_binary() const noexcept
13188      {
13189          return m_type == value_t::binary;
13190      }
13191      constexpr bool is_discarded() const noexcept
13192      {
13193          return m_type == value_t::discarded;
13194      }
13195      constexpr operator value_t() const noexcept
13196      {
13197          return m_type;
13198      }
13199    private:
13200      boolean_t get_impl(boolean_t* &amp;bsol;*unused*/) const
13201      {
13202          if (JSON_HEDLEY_LIKELY(is_boolean()))
13203          {
13204              return m_value.boolean;
13205          }
13206          JSON_THROW(type_error::create(302, &quot;type must be boolean, but is &quot; + std::string(type_name()), *this));
13207      }
13208      object_t* get_impl_ptr(object_t* &amp;bsol;*unused*/) noexcept
13209      {
13210          return is_object() ? m_value.object : nullptr;
13211      }
13212      constexpr const object_t* get_impl_ptr(const object_t* &amp;bsol;*unused*/) const noexcept
13213      {
13214          return is_object() ? m_value.object : nullptr;
13215      }
13216      array_t* get_impl_ptr(array_t* &amp;bsol;*unused*/) noexcept
13217      {
13218          return is_array() ? m_value.array : nullptr;
13219      }
13220      constexpr const array_t* get_impl_ptr(const array_t* &amp;bsol;*unused*/) const noexcept
13221      {
13222          return is_array() ? m_value.array : nullptr;
13223      }
13224      string_t* get_impl_ptr(string_t* &amp;bsol;*unused*/) noexcept
13225      {
13226          return is_string() ? m_value.string : nullptr;
13227      }
13228      constexpr const string_t* get_impl_ptr(const string_t* &amp;bsol;*unused*/) const noexcept
13229      {
13230          return is_string() ? m_value.string : nullptr;
13231      }
13232      boolean_t* get_impl_ptr(boolean_t* &amp;bsol;*unused*/) noexcept
13233      {
13234          return is_boolean() ? &amp;m_value.boolean : nullptr;
13235      }
13236      constexpr const boolean_t* get_impl_ptr(const boolean_t* &amp;bsol;*unused*/) const noexcept
13237      {
13238          return is_boolean() ? &amp;m_value.boolean : nullptr;
13239      }
13240      number_integer_t* get_impl_ptr(number_integer_t* &amp;bsol;*unused*/) noexcept
13241      {
13242          return is_number_integer() ? &amp;m_value.number_integer : nullptr;
13243      }
13244      constexpr const number_integer_t* get_impl_ptr(const number_integer_t* &amp;bsol;*unused*/) const noexcept
13245      {
13246          return is_number_integer() ? &amp;m_value.number_integer : nullptr;
13247      }
13248      number_unsigned_t* get_impl_ptr(number_unsigned_t* &amp;bsol;*unused*/) noexcept
13249      {
13250          return is_number_unsigned() ? &amp;m_value.number_unsigned : nullptr;
13251      }
13252      constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* &amp;bsol;*unused*/) const noexcept
13253      {
13254          return is_number_unsigned() ? &amp;m_value.number_unsigned : nullptr;
13255      }
13256      number_float_t* get_impl_ptr(number_float_t* &amp;bsol;*unused*/) noexcept
13257      {
13258          return is_number_float() ? &amp;m_value.number_float : nullptr;
13259      }
13260      constexpr const number_float_t* get_impl_ptr(const number_float_t* &amp;bsol;*unused*/) const noexcept
13261      {
13262          return is_number_float() ? &amp;m_value.number_float : nullptr;
13263      }
13264      binary_t* get_impl_ptr(binary_t* &amp;bsol;*unused*/) noexcept
13265      {
13266          return is_binary() ? m_value.binary : nullptr;
13267      }
13268      constexpr const binary_t* get_impl_ptr(const binary_t* &amp;bsol;*unused*/) const noexcept
13269      {
13270          return is_binary() ? m_value.binary : nullptr;
13271      }
13272      template&lt;typename ReferenceType, typename ThisType&gt;
13273      static ReferenceType get_ref_impl(ThisType&amp; obj)
13274      {
13275          auto* ptr = obj.template get_ptr&lt;typename std::add_pointer&lt;ReferenceType&gt;::type&gt;();
13276          if (JSON_HEDLEY_LIKELY(ptr != nullptr))
13277          {
13278              return *ptr;
13279          }
13280          JSON_THROW(type_error::create(303, &quot;incompatible ReferenceType for get_ref, actual type is &quot; + std::string(obj.type_name()), obj));
13281      }
13282    public:
13283      template&lt;typename PointerType, typename std::enable_if&lt;
13284                   std::is_pointer&lt;PointerType&gt;::value, int&gt;::type = 0&gt;
13285      auto get_ptr() noexcept -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
13286      {
13287          return get_impl_ptr(static_cast&lt;PointerType&gt;(nullptr));
13288      }
13289      template &lt; typename PointerType, typename std::enable_if &lt;
13290                     std::is_pointer&lt;PointerType&gt;::value&amp;&amp;
13291                     std::is_const&lt;typename std::remove_pointer&lt;PointerType&gt;::type&gt;::value, int &gt;::type = 0 &gt;
13292      constexpr auto get_ptr() const noexcept -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
13293      {
13294          return get_impl_ptr(static_cast&lt;PointerType&gt;(nullptr));
13295      }
13296    private:
13297      template &lt; typename ValueType,
13298                 detail::enable_if_t &lt;
13299                     detail::is_default_constructible&lt;ValueType&gt;::value&amp;&amp;
13300                     detail::has_from_json&lt;basic_json_t, ValueType&gt;::value,
13301                     int &gt; = 0 &gt;
13302      ValueType get_impl(detail::priority_tag&lt;0&gt; &amp;bsol;*unused*/) const noexcept(noexcept(
13303                  JSONSerializer&lt;ValueType&gt;::from_json(std::declval&lt;const basic_json_t&amp;&gt;(), std::declval&lt;ValueType&amp;&gt;())))
13304      {
13305          ValueType ret{};
13306          JSONSerializer&lt;ValueType&gt;::from_json(*this, ret);
13307          return ret;
13308      }
13309      template &lt; typename ValueType,
13310                 detail::enable_if_t &lt;
13311                     detail::has_non_default_from_json&lt;basic_json_t, ValueType&gt;::value,
13312                     int &gt; = 0 &gt;
13313      ValueType get_impl(detail::priority_tag&lt;1&gt; &amp;bsol;*unused*/) const noexcept(noexcept(
13314                  JSONSerializer&lt;ValueType&gt;::from_json(std::declval&lt;const basic_json_t&amp;&gt;())))
13315      {
13316          return JSONSerializer&lt;ValueType&gt;::from_json(*this);
13317      }
13318      template &lt; typename BasicJsonType,
13319                 detail::enable_if_t &lt;
13320                     detail::is_basic_json&lt;BasicJsonType&gt;::value,
13321                     int &gt; = 0 &gt;
13322      BasicJsonType get_impl(detail::priority_tag&lt;2&gt; &amp;bsol;*unused*/) const
13323      {
13324          return *this;
13325      }
13326      template&lt;typename BasicJsonType,
13327               detail::enable_if_t&lt;
13328                   std::is_same&lt;BasicJsonType, basic_json_t&gt;::value,
13329                   int&gt; = 0&gt;
13330      basic_json get_impl(detail::priority_tag&lt;3&gt; &amp;bsol;*unused*/) const
13331      {
13332          return *this;
13333      }
13334      template&lt;typename PointerType,
13335               detail::enable_if_t&lt;
13336                   std::is_pointer&lt;PointerType&gt;::value,
13337                   int&gt; = 0&gt;
13338      constexpr auto get_impl(detail::priority_tag&lt;4&gt; &amp;bsol;*unused*/) const noexcept
13339      -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().template get_ptr&lt;PointerType&gt;())
13340      {
13341          return get_ptr&lt;PointerType&gt;();
13342      }
13343    public:
13344      template &lt; typename ValueTypeCV, typename ValueType = detail::uncvref_t&lt;ValueTypeCV&gt;&gt;
13345  #if defined(JSON_HAS_CPP_14)
13346      constexpr
13347  #endif
13348      auto get() const noexcept(
13349      noexcept(std::declval&lt;const basic_json_t&amp;&gt;().template get_impl&lt;ValueType&gt;(detail::priority_tag&lt;4&gt; {})))
13350      -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().template get_impl&lt;ValueType&gt;(detail::priority_tag&lt;4&gt; {}))
13351      {
13352          static_assert(!std::is_reference&lt;ValueTypeCV&gt;::value,
13353                        &quot;get() cannot be used with reference types, you might want to use get_ref()&quot;);
13354          return get_impl&lt;ValueType&gt;(detail::priority_tag&lt;4&gt; {});
13355      }
13356      template&lt;typename PointerType, typename std::enable_if&lt;
13357                   std::is_pointer&lt;PointerType&gt;::value, int&gt;::type = 0&gt;
13358      auto get() noexcept -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().template get_ptr&lt;PointerType&gt;())
13359      {
13360          return get_ptr&lt;PointerType&gt;();
13361      }
13362      template &lt; typename ValueType,
13363                 detail::enable_if_t &lt;
13364                     !detail::is_basic_json&lt;ValueType&gt;::value&amp;&amp;
13365                     detail::has_from_json&lt;basic_json_t, ValueType&gt;::value,
13366                     int &gt; = 0 &gt;
13367      ValueType &amp; get_to(ValueType&amp; v) const noexcept(noexcept(
13368                  JSONSerializer&lt;ValueType&gt;::from_json(std::declval&lt;const basic_json_t&amp;&gt;(), v)))
13369      {
13370          JSONSerializer&lt;ValueType&gt;::from_json(*this, v);
13371          return v;
13372      }
13373      template&lt;typename ValueType,
13374               detail::enable_if_t &lt;
13375                   detail::is_basic_json&lt;ValueType&gt;::value,
13376                   int&gt; = 0&gt;
13377      ValueType &amp; get_to(ValueType&amp; v) const
13378      {
13379          v = *this;
13380          return v;
13381      }
13382      template &lt;
13383          typename T, std::size_t N,
13384          typename Array = T (&amp;)[N], 
13385          detail::enable_if_t &lt;
13386              detail::has_from_json&lt;basic_json_t, Array&gt;::value, int &gt; = 0 &gt;
13387      Array get_to(T (&amp;v)[N]) const 
13388      noexcept(noexcept(JSONSerializer&lt;Array&gt;::from_json(
13389                            std::declval&lt;const basic_json_t&amp;&gt;(), v)))
13390      {
13391          JSONSerializer&lt;Array&gt;::from_json(*this, v);
13392          return v;
13393      }
13394      template&lt;typename ReferenceType, typename std::enable_if&lt;
13395                   std::is_reference&lt;ReferenceType&gt;::value, int&gt;::type = 0&gt;
13396      ReferenceType get_ref()
13397      {
13398          return get_ref_impl&lt;ReferenceType&gt;(*this);
13399      }
13400      template &lt; typename ReferenceType, typename std::enable_if &lt;
13401                     std::is_reference&lt;ReferenceType&gt;::value&amp;&amp;
13402                     std::is_const&lt;typename std::remove_reference&lt;ReferenceType&gt;::type&gt;::value, int &gt;::type = 0 &gt;
13403      ReferenceType get_ref() const
13404      {
13405          return get_ref_impl&lt;ReferenceType&gt;(*this);
13406      }
13407      template &lt; typename ValueType, typename std::enable_if &lt;
13408                     detail::conjunction &lt;
13409                         detail::negation&lt;std::is_pointer&lt;ValueType&gt;&gt;,
13410                         detail::negation&lt;std::is_same&lt;ValueType, detail::json_ref&lt;basic_json&gt;&gt;&gt;,
13411                                          detail::negation&lt;std::is_same&lt;ValueType, typename string_t::value_type&gt;&gt;,
13412                                          detail::negation&lt;detail::is_basic_json&lt;ValueType&gt;&gt;,
13413                                          detail::negation&lt;std::is_same&lt;ValueType, std::initializer_list&lt;typename string_t::value_type&gt;&gt;&gt;,
13414  #if defined(JSON_HAS_CPP_17) &amp;&amp; (defined(__GNUC__) || (defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1910 &amp;&amp; _MSC_VER &lt;= 1914))
13415                                                  detail::negation&lt;std::is_same&lt;ValueType, std::string_view&gt;&gt;,
13416  #endif
13417                                                  detail::is_detected_lazy&lt;detail::get_template_function, const basic_json_t&amp;, ValueType&gt;
13418                                                  &gt;::value, int &gt;::type = 0 &gt;
13419                                          JSON_EXPLICIT operator ValueType() const
13420      {
13421          return get&lt;ValueType&gt;();
13422      }
13423      binary_t&amp; get_binary()
13424      {
13425          if (!is_binary())
13426          {
13427              JSON_THROW(type_error::create(302, &quot;type must be binary, but is &quot; + std::string(type_name()), *this));
13428          }
13429          return *get_ptr&lt;binary_t*&gt;();
13430      }
13431      const binary_t&amp; get_binary() const
13432      {
13433          if (!is_binary())
13434          {
13435              JSON_THROW(type_error::create(302, &quot;type must be binary, but is &quot; + std::string(type_name()), *this));
13436          }
13437          return *get_ptr&lt;const binary_t*&gt;();
13438      }
13439      reference at(size_type idx)
13440      {
13441          if (JSON_HEDLEY_LIKELY(is_array()))
13442          {
13443              JSON_TRY
13444              {
13445                  return set_parent(m_value.array-&gt;at(idx));
13446              }
13447              JSON_CATCH (std::out_of_range&amp;)
13448              {
13449                  JSON_THROW(out_of_range::create(401, &quot;array index &quot; + std::to_string(idx) + &quot; is out of range&quot;, *this));
13450              }
13451          }
13452          else
13453          {
13454              JSON_THROW(type_error::create(304, &quot;cannot use at() with &quot; + std::string(type_name()), *this));
13455          }
13456      }
13457      const_reference at(size_type idx) const
13458      {
13459          if (JSON_HEDLEY_LIKELY(is_array()))
13460          {
13461              JSON_TRY
13462              {
13463                  return m_value.array-&gt;at(idx);
13464              }
13465              JSON_CATCH (std::out_of_range&amp;)
13466              {
13467                  JSON_THROW(out_of_range::create(401, &quot;array index &quot; + std::to_string(idx) + &quot; is out of range&quot;, *this));
13468              }
13469          }
13470          else
13471          {
13472              JSON_THROW(type_error::create(304, &quot;cannot use at() with &quot; + std::string(type_name()), *this));
13473          }
13474      }
13475      reference at(const typename object_t::key_type&amp; key)
13476      {
13477          if (JSON_HEDLEY_LIKELY(is_object()))
13478          {
13479              JSON_TRY
13480              {
13481                  return set_parent(m_value.object-&gt;at(key));
13482              }
13483              JSON_CATCH (std::out_of_range&amp;)
13484              {
13485                  JSON_THROW(out_of_range::create(403, &quot;key &#x27;&quot; + key + &quot;&#x27; not found&quot;, *this));
13486              }
13487          }
13488          else
13489          {
13490              JSON_THROW(type_error::create(304, &quot;cannot use at() with &quot; + std::string(type_name()), *this));
13491          }
13492      }
13493      const_reference at(const typename object_t::key_type&amp; key) const
13494      {
13495          if (JSON_HEDLEY_LIKELY(is_object()))
13496          {
13497              JSON_TRY
13498              {
13499                  return m_value.object-&gt;at(key);
13500              }
13501              JSON_CATCH (std::out_of_range&amp;)
13502              {
13503                  JSON_THROW(out_of_range::create(403, &quot;key &#x27;&quot; + key + &quot;&#x27; not found&quot;, *this));
13504              }
13505          }
13506          else
13507          {
13508              JSON_THROW(type_error::create(304, &quot;cannot use at() with &quot; + std::string(type_name()), *this));
13509          }
13510      }
13511      reference operator[](size_type idx)
13512      {
13513          if (is_null())
13514          {
13515              m_type = value_t::array;
13516              m_value.array = create&lt;array_t&gt;();
13517              assert_invariant();
13518          }
13519          if (JSON_HEDLEY_LIKELY(is_array()))
13520          {
13521              if (idx &gt;= m_value.array-&gt;size())
13522              {
13523  #if JSON_DIAGNOSTICS
13524                  const auto previous_size = m_value.array-&gt;size();
13525  #endif
13526                  m_value.array-&gt;resize(idx + 1);
13527  #if JSON_DIAGNOSTICS
13528                  set_parents(begin() + static_cast&lt;typename iterator::difference_type&gt;(previous_size), static_cast&lt;typename iterator::difference_type&gt;(idx + 1 - previous_size));
13529  #endif
13530              }
13531              return m_value.array-&gt;operator[](idx);
13532          }
13533          JSON_THROW(type_error::create(305, &quot;cannot use operator[] with a numeric argument with &quot; + std::string(type_name()), *this));
13534      }
13535      const_reference operator[](size_type idx) const
13536      {
13537          if (JSON_HEDLEY_LIKELY(is_array()))
13538          {
13539              return m_value.array-&gt;operator[](idx);
13540          }
13541          JSON_THROW(type_error::create(305, &quot;cannot use operator[] with a numeric argument with &quot; + std::string(type_name()), *this));
13542      }
13543      reference operator[](const typename object_t::key_type&amp; key)
13544      {
13545          if (is_null())
13546          {
13547              m_type = value_t::object;
13548              m_value.object = create&lt;object_t&gt;();
13549              assert_invariant();
13550          }
13551          if (JSON_HEDLEY_LIKELY(is_object()))
13552          {
13553              return set_parent(m_value.object-&gt;operator[](key));
13554          }
13555          JSON_THROW(type_error::create(305, &quot;cannot use operator[] with a string argument with &quot; + std::string(type_name()), *this));
13556      }
13557      const_reference operator[](const typename object_t::key_type&amp; key) const
13558      {
13559          if (JSON_HEDLEY_LIKELY(is_object()))
13560          {
13561              JSON_ASSERT(m_value.object-&gt;find(key) != m_value.object-&gt;end());
13562              return m_value.object-&gt;find(key)-&gt;second;
13563          }
13564          JSON_THROW(type_error::create(305, &quot;cannot use operator[] with a string argument with &quot; + std::string(type_name()), *this));
13565      }
13566      template&lt;typename T&gt;
13567      JSON_HEDLEY_NON_NULL(2)
13568      reference operator[](T* key)
13569      {
13570          if (is_null())
13571          {
13572              m_type = value_t::object;
13573              m_value = value_t::object;
13574              assert_invariant();
13575          }
13576          if (JSON_HEDLEY_LIKELY(is_object()))
13577          {
13578              return set_parent(m_value.object-&gt;operator[](key));
13579          }
13580          JSON_THROW(type_error::create(305, &quot;cannot use operator[] with a string argument with &quot; + std::string(type_name()), *this));
13581      }
13582      template&lt;typename T&gt;
13583      JSON_HEDLEY_NON_NULL(2)
13584      const_reference operator[](T* key) const
13585      {
13586          if (JSON_HEDLEY_LIKELY(is_object()))
13587          {
13588              JSON_ASSERT(m_value.object-&gt;find(key) != m_value.object-&gt;end());
13589              return m_value.object-&gt;find(key)-&gt;second;
13590          }
13591          JSON_THROW(type_error::create(305, &quot;cannot use operator[] with a string argument with &quot; + std::string(type_name()), *this));
13592      }
13593      template &lt; class ValueType, typename std::enable_if &lt;
13594                     detail::is_getable&lt;basic_json_t, ValueType&gt;::value
13595                     &amp;&amp; !std::is_same&lt;value_t, ValueType&gt;::value, int &gt;::type = 0 &gt;
13596      ValueType value(const typename object_t::key_type&amp; key, const ValueType&amp; default_value) const
13597      {
13598          if (JSON_HEDLEY_LIKELY(is_object()))
13599          {
13600              const auto it = find(key);
13601              if (it != end())
13602              {
13603                  return it-&gt;template get&lt;ValueType&gt;();
13604              }
13605              return default_value;
13606          }
13607          JSON_THROW(type_error::create(306, &quot;cannot use value() with &quot; + std::string(type_name()), *this));
13608      }
13609      string_t value(const typename object_t::key_type&amp; key, const char* default_value) const
13610      {
13611          return value(key, string_t(default_value));
13612      }
13613      template&lt;class ValueType, typename std::enable_if&lt;
13614                   detail::is_getable&lt;basic_json_t, ValueType&gt;::value, int&gt;::type = 0&gt;
13615      ValueType value(const json_pointer&amp; ptr, const ValueType&amp; default_value) const
13616      {
13617          if (JSON_HEDLEY_LIKELY(is_object()))
13618          {
13619              JSON_TRY
13620              {
13621                  return ptr.get_checked(this).template get&lt;ValueType&gt;();
13622              }
13623              JSON_INTERNAL_CATCH (out_of_range&amp;)
13624              {
13625                  return default_value;
13626              }
13627          }
13628          JSON_THROW(type_error::create(306, &quot;cannot use value() with &quot; + std::string(type_name()), *this));
13629      }
13630      JSON_HEDLEY_NON_NULL(3)
13631      string_t value(const json_pointer&amp; ptr, const char* default_value) const
13632      {
13633          return value(ptr, string_t(default_value));
13634      }
13635      reference front()
13636      {
13637          return *begin();
13638      }
13639      const_reference front() const
13640      {
13641          return *cbegin();
13642      }
13643      reference back()
13644      {
13645          auto tmp = end();
13646          --tmp;
13647          return *tmp;
13648      }
13649      const_reference back() const
13650      {
13651          auto tmp = cend();
13652          --tmp;
13653          return *tmp;
13654      }
13655      template &lt; class IteratorType, typename std::enable_if &lt;
13656                     std::is_same&lt;IteratorType, typename basic_json_t::iterator&gt;::value ||
13657                     std::is_same&lt;IteratorType, typename basic_json_t::const_iterator&gt;::value, int &gt;::type
13658                 = 0 &gt;
13659      IteratorType erase(IteratorType pos)
13660      {
13661          if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
13662          {
13663              JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, *this));
13664          }
13665          IteratorType result = end();
13666          switch (m_type)
13667          {
13668              case value_t::boolean:
13669              case value_t::number_float:
13670              case value_t::number_integer:
13671              case value_t::number_unsigned:
13672              case value_t::string:
13673              case value_t::binary:
13674              {
13675                  if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
13676                  {
13677                      JSON_THROW(invalid_iterator::create(205, &quot;iterator out of range&quot;, *this));
13678                  }
13679                  if (is_string())
13680                  {
13681                      AllocatorType&lt;string_t&gt; alloc;
13682                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.string);
13683                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.string, 1);
13684                      m_value.string = nullptr;
13685                  }
13686                  else if (is_binary())
13687                  {
13688                      AllocatorType&lt;binary_t&gt; alloc;
13689                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.binary);
13690                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.binary, 1);
13691                      m_value.binary = nullptr;
13692                  }
13693                  m_type = value_t::null;
13694                  assert_invariant();
13695                  break;
13696              }
13697              case value_t::object:
13698              {
13699                  result.m_it.object_iterator = m_value.object-&gt;erase(pos.m_it.object_iterator);
13700                  break;
13701              }
13702              case value_t::array:
13703              {
13704                  result.m_it.array_iterator = m_value.array-&gt;erase(pos.m_it.array_iterator);
13705                  break;
13706              }
13707              case value_t::null:
13708              case value_t::discarded:
13709              default:
13710                  JSON_THROW(type_error::create(307, &quot;cannot use erase() with &quot; + std::string(type_name()), *this));
13711          }
13712          return result;
13713      }
13714      template &lt; class IteratorType, typename std::enable_if &lt;
13715                     std::is_same&lt;IteratorType, typename basic_json_t::iterator&gt;::value ||
13716                     std::is_same&lt;IteratorType, typename basic_json_t::const_iterator&gt;::value, int &gt;::type
13717                 = 0 &gt;
13718      IteratorType erase(IteratorType first, IteratorType last)
13719      {
13720          if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
13721          {
13722              JSON_THROW(invalid_iterator::create(203, &quot;iterators do not fit current value&quot;, *this));
13723          }
13724          IteratorType result = end();
13725          switch (m_type)
13726          {
13727              case value_t::boolean:
13728              case value_t::number_float:
13729              case value_t::number_integer:
13730              case value_t::number_unsigned:
13731              case value_t::string:
13732              case value_t::binary:
13733              {
13734                  if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
13735                                         || !last.m_it.primitive_iterator.is_end()))
13736                  {
13737                      JSON_THROW(invalid_iterator::create(204, &quot;iterators out of range&quot;, *this));
13738                  }
13739                  if (is_string())
13740                  {
13741                      AllocatorType&lt;string_t&gt; alloc;
13742                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.string);
13743                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.string, 1);
13744                      m_value.string = nullptr;
13745                  }
13746                  else if (is_binary())
13747                  {
13748                      AllocatorType&lt;binary_t&gt; alloc;
13749                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.binary);
13750                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.binary, 1);
13751                      m_value.binary = nullptr;
13752                  }
13753                  m_type = value_t::null;
13754                  assert_invariant();
13755                  break;
13756              }
13757              case value_t::object:
13758              {
13759                  result.m_it.object_iterator = m_value.object-&gt;erase(first.m_it.object_iterator,
13760                                                last.m_it.object_iterator);
13761                  break;
13762              }
13763              case value_t::array:
13764              {
13765                  result.m_it.array_iterator = m_value.array-&gt;erase(first.m_it.array_iterator,
13766                                               last.m_it.array_iterator);
13767                  break;
13768              }
13769              case value_t::null:
13770              case value_t::discarded:
13771              default:
13772                  JSON_THROW(type_error::create(307, &quot;cannot use erase() with &quot; + std::string(type_name()), *this));
13773          }
13774          return result;
13775      }
13776      size_type erase(const typename object_t::key_type&amp; key)
13777      {
13778          if (JSON_HEDLEY_LIKELY(is_object()))
13779          {
13780              return m_value.object-&gt;erase(key);
13781          }
13782          JSON_THROW(type_error::create(307, &quot;cannot use erase() with &quot; + std::string(type_name()), *this));
13783      }
13784      void erase(const size_type idx)
13785      {
13786          if (JSON_HEDLEY_LIKELY(is_array()))
13787          {
13788              if (JSON_HEDLEY_UNLIKELY(idx &gt;= size()))
13789              {
13790                  JSON_THROW(out_of_range::create(401, &quot;array index &quot; + std::to_string(idx) + &quot; is out of range&quot;, *this));
13791              }
13792              m_value.array-&gt;erase(m_value.array-&gt;begin() + static_cast&lt;difference_type&gt;(idx));
13793          }
13794          else
13795          {
13796              JSON_THROW(type_error::create(307, &quot;cannot use erase() with &quot; + std::string(type_name()), *this));
13797          }
13798      }
13799      template&lt;typename KeyT&gt;
13800      iterator find(KeyT&amp;&amp; key)
13801      {
13802          auto result = end();
13803          if (is_object())
13804          {
13805              result.m_it.object_iterator = m_value.object-&gt;find(std::forward&lt;KeyT&gt;(key));
13806          }
13807          return result;
13808      }
13809      template&lt;typename KeyT&gt;
13810      const_iterator find(KeyT&amp;&amp; key) const
13811      {
13812          auto result = cend();
13813          if (is_object())
13814          {
13815              result.m_it.object_iterator = m_value.object-&gt;find(std::forward&lt;KeyT&gt;(key));
13816          }
13817          return result;
13818      }
13819      template&lt;typename KeyT&gt;
13820      size_type count(KeyT&amp;&amp; key) const
13821      {
13822          return is_object() ? m_value.object-&gt;count(std::forward&lt;KeyT&gt;(key)) : 0;
13823      }
13824      template &lt; typename KeyT, typename std::enable_if &lt;
13825                     !std::is_same&lt;typename std::decay&lt;KeyT&gt;::type, json_pointer&gt;::value, int &gt;::type = 0 &gt;
13826      bool contains(KeyT &amp;&amp; key) const
13827      {
13828          return is_object() &amp;&amp; m_value.object-&gt;find(std::forward&lt;KeyT&gt;(key)) != m_value.object-&gt;end();
13829      }
13830      bool contains(const json_pointer&amp; ptr) const
13831      {
13832          return ptr.contains(this);
13833      }
13834      iterator begin() noexcept
13835      {
13836          iterator result(this);
13837          result.set_begin();
13838          return result;
13839      }
13840      const_iterator begin() const noexcept
13841      {
13842          return cbegin();
13843      }
13844      const_iterator cbegin() const noexcept
13845      {
13846          const_iterator result(this);
13847          result.set_begin();
13848          return result;
13849      }
13850      iterator end() noexcept
13851      {
13852          iterator result(this);
13853          result.set_end();
13854          return result;
13855      }
13856      const_iterator end() const noexcept
13857      {
13858          return cend();
13859      }
13860      const_iterator cend() const noexcept
13861      {
13862          const_iterator result(this);
13863          result.set_end();
13864          return result;
13865      }
13866      reverse_iterator rbegin() noexcept
13867      {
13868          return reverse_iterator(end());
13869      }
13870      const_reverse_iterator rbegin() const noexcept
13871      {
13872          return crbegin();
13873      }
13874      reverse_iterator rend() noexcept
13875      {
13876          return reverse_iterator(begin());
13877      }
13878      const_reverse_iterator rend() const noexcept
13879      {
13880          return crend();
13881      }
13882      const_reverse_iterator crbegin() const noexcept
13883      {
13884          return const_reverse_iterator(cend());
13885      }
13886      const_reverse_iterator crend() const noexcept
13887      {
13888          return const_reverse_iterator(cbegin());
13889      }
13890    public:
13891      JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
13892      static iteration_proxy&lt;iterator&gt; iterator_wrapper(reference ref) noexcept
13893      {
13894          return ref.items();
13895      }
13896      JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
13897      static iteration_proxy&lt;const_iterator&gt; iterator_wrapper(const_reference ref) noexcept
13898      {
13899          return ref.items();
13900      }
13901      iteration_proxy&lt;iterator&gt; items() noexcept
13902      {
13903          return iteration_proxy&lt;iterator&gt;(*this);
13904      }
13905      iteration_proxy&lt;const_iterator&gt; items() const noexcept
13906      {
13907          return iteration_proxy&lt;const_iterator&gt;(*this);
13908      }
13909      bool empty() const noexcept
13910      {
13911          switch (m_type)
13912          {
13913              case value_t::null:
13914              {
13915                  return true;
13916              }
13917              case value_t::array:
13918              {
13919                  return m_value.array-&gt;empty();
13920              }
13921              case value_t::object:
13922              {
13923                  return m_value.object-&gt;empty();
13924              }
13925              case value_t::string:
13926              case value_t::boolean:
13927              case value_t::number_integer:
13928              case value_t::number_unsigned:
13929              case value_t::number_float:
13930              case value_t::binary:
13931              case value_t::discarded:
13932              default:
13933              {
13934                  return false;
13935              }
13936          }
13937      }
13938      size_type size() const noexcept
13939      {
13940          switch (m_type)
13941          {
13942              case value_t::null:
13943              {
13944                  return 0;
13945              }
13946              case value_t::array:
13947              {
13948                  return m_value.array-&gt;size();
13949              }
13950              case value_t::object:
13951              {
13952                  return m_value.object-&gt;size();
13953              }
13954              case value_t::string:
13955              case value_t::boolean:
13956              case value_t::number_integer:
13957              case value_t::number_unsigned:
13958              case value_t::number_float:
13959              case value_t::binary:
13960              case value_t::discarded:
13961              default:
13962              {
13963                  return 1;
13964              }
13965          }
13966      }
13967      size_type max_size() const noexcept
13968      {
13969          switch (m_type)
13970          {
13971              case value_t::array:
13972              {
13973                  return m_value.array-&gt;max_size();
13974              }
13975              case value_t::object:
13976              {
13977                  return m_value.object-&gt;max_size();
13978              }
13979              case value_t::null:
13980              case value_t::string:
13981              case value_t::boolean:
13982              case value_t::number_integer:
13983              case value_t::number_unsigned:
13984              case value_t::number_float:
13985              case value_t::binary:
13986              case value_t::discarded:
13987              default:
13988              {
13989                  return size();
13990              }
13991          }
13992      }
13993      void clear() noexcept
13994      {
13995          switch (m_type)
13996          {
13997              case value_t::number_integer:
13998              {
13999                  m_value.number_integer = 0;
14000                  break;
14001              }
14002              case value_t::number_unsigned:
14003              {
14004                  m_value.number_unsigned = 0;
14005                  break;
14006              }
14007              case value_t::number_float:
14008              {
14009                  m_value.number_float = 0.0;
14010                  break;
14011              }
14012              case value_t::boolean:
14013              {
14014                  m_value.boolean = false;
14015                  break;
14016              }
14017              case value_t::string:
14018              {
14019                  m_value.string-&gt;clear();
14020                  break;
14021              }
14022              case value_t::binary:
14023              {
14024                  m_value.binary-&gt;clear();
14025                  break;
14026              }
14027              case value_t::array:
14028              {
14029                  m_value.array-&gt;clear();
14030                  break;
14031              }
14032              case value_t::object:
14033              {
14034                  m_value.object-&gt;clear();
14035                  break;
14036              }
14037              case value_t::null:
14038              case value_t::discarded:
14039              default:
14040                  break;
14041          }
14042      }
14043      void push_back(basic_json&amp;&amp; val)
14044      {
14045          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
14046          {
14047              JSON_THROW(type_error::create(308, &quot;cannot use push_back() with &quot; + std::string(type_name()), *this));
14048          }
14049          if (is_null())
14050          {
14051              m_type = value_t::array;
14052              m_value = value_t::array;
14053              assert_invariant();
14054          }
14055          const auto old_capacity = m_value.array-&gt;capacity();
14056          m_value.array-&gt;push_back(std::move(val));
14057          set_parent(m_value.array-&gt;back(), old_capacity);
14058      }
14059      reference operator+=(basic_json&amp;&amp; val)
14060      {
14061          push_back(std::move(val));
14062          return *this;
14063      }
14064      void push_back(const basic_json&amp; val)
14065      {
14066          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
14067          {
14068              JSON_THROW(type_error::create(308, &quot;cannot use push_back() with &quot; + std::string(type_name()), *this));
14069          }
14070          if (is_null())
14071          {
14072              m_type = value_t::array;
14073              m_value = value_t::array;
14074              assert_invariant();
14075          }
14076          const auto old_capacity = m_value.array-&gt;capacity();
14077          m_value.array-&gt;push_back(val);
14078          set_parent(m_value.array-&gt;back(), old_capacity);
14079      }
14080      reference operator+=(const basic_json&amp; val)
14081      {
14082          push_back(val);
14083          return *this;
14084      }
14085      void push_back(const typename object_t::value_type&amp; val)
14086      {
14087          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
14088          {
14089              JSON_THROW(type_error::create(308, &quot;cannot use push_back() with &quot; + std::string(type_name()), *this));
14090          }
14091          if (is_null())
14092          {
14093              m_type = value_t::object;
14094              m_value = value_t::object;
14095              assert_invariant();
14096          }
14097          auto res = m_value.object-&gt;insert(val);
14098          set_parent(res.first-&gt;second);
14099      }
14100      reference operator+=(const typename object_t::value_type&amp; val)
14101      {
14102          push_back(val);
14103          return *this;
14104      }
14105      void push_back(initializer_list_t init)
14106      {
14107          if (is_object() &amp;&amp; init.size() == 2 &amp;&amp; (*init.begin())-&gt;is_string())
14108          {
14109              basic_json&amp;&amp; key = init.begin()-&gt;moved_or_copied();
14110              push_back(typename object_t::value_type(
14111                            std::move(key.get_ref&lt;string_t&amp;&gt;()), (init.begin() + 1)-&gt;moved_or_copied()));
14112          }
14113          else
14114          {
14115              push_back(basic_json(init));
14116          }
14117      }
14118      reference operator+=(initializer_list_t init)
14119      {
14120          push_back(init);
14121          return *this;
14122      }
14123      template&lt;class... Args&gt;
14124      reference emplace_back(Args&amp;&amp; ... args)
14125      {
14126          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
14127          {
14128              JSON_THROW(type_error::create(311, &quot;cannot use emplace_back() with &quot; + std::string(type_name()), *this));
14129          }
14130          if (is_null())
14131          {
14132              m_type = value_t::array;
14133              m_value = value_t::array;
14134              assert_invariant();
14135          }
14136          const auto old_capacity = m_value.array-&gt;capacity();
14137          m_value.array-&gt;emplace_back(std::forward&lt;Args&gt;(args)...);
14138          return set_parent(m_value.array-&gt;back(), old_capacity);
14139      }
14140      template&lt;class... Args&gt;
14141      std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp; ... args)
14142      {
14143          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
14144          {
14145              JSON_THROW(type_error::create(311, &quot;cannot use emplace() with &quot; + std::string(type_name()), *this));
14146          }
14147          if (is_null())
14148          {
14149              m_type = value_t::object;
14150              m_value = value_t::object;
14151              assert_invariant();
14152          }
14153          auto res = m_value.object-&gt;emplace(std::forward&lt;Args&gt;(args)...);
14154          set_parent(res.first-&gt;second);
14155          auto it = begin();
14156          it.m_it.object_iterator = res.first;
14157          return {it, res.second};
14158      }
14159      template&lt;typename... Args&gt;
14160      iterator insert_iterator(const_iterator pos, Args&amp;&amp; ... args)
14161      {
14162          iterator result(this);
14163          JSON_ASSERT(m_value.array != nullptr);
14164          auto insert_pos = std::distance(m_value.array-&gt;begin(), pos.m_it.array_iterator);
14165          m_value.array-&gt;insert(pos.m_it.array_iterator, std::forward&lt;Args&gt;(args)...);
14166          result.m_it.array_iterator = m_value.array-&gt;begin() + insert_pos;
14167          set_parents();
14168          return result;
14169      }
14170      iterator insert(const_iterator pos, const basic_json&amp; val)
14171      {
14172          if (JSON_HEDLEY_LIKELY(is_array()))
14173          {
14174              if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
14175              {
14176                  JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, *this));
14177              }
14178              return insert_iterator(pos, val);
14179          }
14180          JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name()), *this));
14181      }
14182      iterator insert(const_iterator pos, basic_json&amp;&amp; val)
14183      {
14184          return insert(pos, val);
14185      }
14186      iterator insert(const_iterator pos, size_type cnt, const basic_json&amp; val)
14187      {
14188          if (JSON_HEDLEY_LIKELY(is_array()))
14189          {
14190              if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
14191              {
14192                  JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, *this));
14193              }
14194              return insert_iterator(pos, cnt, val);
14195          }
14196          JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name()), *this));
14197      }
14198      iterator insert(const_iterator pos, const_iterator first, const_iterator last)
14199      {
14200          if (JSON_HEDLEY_UNLIKELY(!is_array()))
14201          {
14202              JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name()), *this));
14203          }
14204          if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
14205          {
14206              JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, *this));
14207          }
14208          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
14209          {
14210              JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;, *this));
14211          }
14212          if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
14213          {
14214              JSON_THROW(invalid_iterator::create(211, &quot;passed iterators may not belong to container&quot;, *this));
14215          }
14216          return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
14217      }
14218      iterator insert(const_iterator pos, initializer_list_t ilist)
14219      {
14220          if (JSON_HEDLEY_UNLIKELY(!is_array()))
14221          {
14222              JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name()), *this));
14223          }
14224          if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
14225          {
14226              JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, *this));
14227          }
14228          return insert_iterator(pos, ilist.begin(), ilist.end());
14229      }
14230      void insert(const_iterator first, const_iterator last)
14231      {
14232          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14233          {
14234              JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name()), *this));
14235          }
14236          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
14237          {
14238              JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;, *this));
14239          }
14240          if (JSON_HEDLEY_UNLIKELY(!first.m_object-&gt;is_object()))
14241          {
14242              JSON_THROW(invalid_iterator::create(202, &quot;iterators first and last must point to objects&quot;, *this));
14243          }
14244          m_value.object-&gt;insert(first.m_it.object_iterator, last.m_it.object_iterator);
14245      }
14246      void update(const_reference j)
14247      {
14248          if (is_null())
14249          {
14250              m_type = value_t::object;
14251              m_value.object = create&lt;object_t&gt;();
14252              assert_invariant();
14253          }
14254          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14255          {
14256              JSON_THROW(type_error::create(312, &quot;cannot use update() with &quot; + std::string(type_name()), *this));
14257          }
14258          if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
14259          {
14260              JSON_THROW(type_error::create(312, &quot;cannot use update() with &quot; + std::string(j.type_name()), *this));
14261          }
14262          for (auto it = j.cbegin(); it != j.cend(); ++it)
14263          {
14264              m_value.object-&gt;operator[](it.key()) = it.value();
14265          }
14266      }
14267      void update(const_iterator first, const_iterator last)
14268      {
14269          if (is_null())
14270          {
14271              m_type = value_t::object;
14272              m_value.object = create&lt;object_t&gt;();
14273              assert_invariant();
14274          }
14275          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14276          {
14277              JSON_THROW(type_error::create(312, &quot;cannot use update() with &quot; + std::string(type_name()), *this));
14278          }
14279          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
14280          {
14281              JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;, *this));
14282          }
14283          if (JSON_HEDLEY_UNLIKELY(!first.m_object-&gt;is_object()
14284                                   || !last.m_object-&gt;is_object()))
14285          {
14286              JSON_THROW(invalid_iterator::create(202, &quot;iterators first and last must point to objects&quot;, *this));
14287          }
14288          for (auto it = first; it != last; ++it)
14289          {
14290              m_value.object-&gt;operator[](it.key()) = it.value();
14291          }
14292      }
14293      void swap(reference other) noexcept (
14294          std::is_nothrow_move_constructible&lt;value_t&gt;::value&amp;&amp;
14295          std::is_nothrow_move_assignable&lt;value_t&gt;::value&amp;&amp;
14296          std::is_nothrow_move_constructible&lt;json_value&gt;::value&amp;&amp;
14297          std::is_nothrow_move_assignable&lt;json_value&gt;::value
14298      )
14299      {
14300          std::swap(m_type, other.m_type);
14301          std::swap(m_value, other.m_value);
14302          set_parents();
14303          other.set_parents();
14304          assert_invariant();
14305      }
14306      friend void swap(reference left, reference right) noexcept (
14307          std::is_nothrow_move_constructible&lt;value_t&gt;::value&amp;&amp;
14308          std::is_nothrow_move_assignable&lt;value_t&gt;::value&amp;&amp;
14309          std::is_nothrow_move_constructible&lt;json_value&gt;::value&amp;&amp;
14310          std::is_nothrow_move_assignable&lt;json_value&gt;::value
14311      )
14312      {
14313          left.swap(right);
14314      }
14315      void swap(array_t&amp; other) 
14316      {
14317          if (JSON_HEDLEY_LIKELY(is_array()))
14318          {
14319              std::swap(*(m_value.array), other);
14320          }
14321          else
14322          {
14323              JSON_THROW(type_error::create(310, &quot;cannot use swap() with &quot; + std::string(type_name()), *this));
14324          }
14325      }
14326      void swap(object_t&amp; other) 
14327      {
14328          if (JSON_HEDLEY_LIKELY(is_object()))
14329          {
14330              std::swap(*(m_value.object), other);
14331          }
14332          else
14333          {
14334              JSON_THROW(type_error::create(310, &quot;cannot use swap() with &quot; + std::string(type_name()), *this));
14335          }
14336      }
14337      void swap(string_t&amp; other) 
14338      {
14339          if (JSON_HEDLEY_LIKELY(is_string()))
14340          {
14341              std::swap(*(m_value.string), other);
14342          }
14343          else
14344          {
14345              JSON_THROW(type_error::create(310, &quot;cannot use swap() with &quot; + std::string(type_name()), *this));
14346          }
14347      }
14348      void swap(binary_t&amp; other) 
14349      {
14350          if (JSON_HEDLEY_LIKELY(is_binary()))
14351          {
14352              std::swap(*(m_value.binary), other);
14353          }
14354          else
14355          {
14356              JSON_THROW(type_error::create(310, &quot;cannot use swap() with &quot; + std::string(type_name()), *this));
14357          }
14358      }
14359      void swap(typename binary_t::container_type&amp; other) 
14360      {
14361          if (JSON_HEDLEY_LIKELY(is_binary()))
14362          {
14363              std::swap(*(m_value.binary), other);
14364          }
14365          else
14366          {
14367              JSON_THROW(type_error::create(310, &quot;cannot use swap() with &quot; + std::string(type_name()), *this));
14368          }
14369      }
14370    public:
14371      friend bool operator==(const_reference lhs, const_reference rhs) noexcept
14372      {
14373  #ifdef __GNUC__
14374  #pragma GCC diagnostic push
14375  #pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;
14376  #endif
14377          const auto lhs_type = lhs.type();
14378          const auto rhs_type = rhs.type();
14379          if (lhs_type == rhs_type)
14380          {
14381              switch (lhs_type)
14382              {
14383                  case value_t::array:
14384                      return *lhs.m_value.array == *rhs.m_value.array;
14385                  case value_t::object:
14386                      return *lhs.m_value.object == *rhs.m_value.object;
14387                  case value_t::null:
14388                      return true;
14389                  case value_t::string:
14390                      return *lhs.m_value.string == *rhs.m_value.string;
14391                  case value_t::boolean:
14392                      return lhs.m_value.boolean == rhs.m_value.boolean;
14393                  case value_t::number_integer:
14394                      return lhs.m_value.number_integer == rhs.m_value.number_integer;
14395                  case value_t::number_unsigned:
14396                      return lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;
14397                  case value_t::number_float:
14398                      return lhs.m_value.number_float == rhs.m_value.number_float;
14399                  case value_t::binary:
14400                      return *lhs.m_value.binary == *rhs.m_value.binary;
14401                  case value_t::discarded:
14402                  default:
14403                      return false;
14404              }
14405          }
14406          else if (lhs_type == value_t::number_integer &amp;&amp; rhs_type == value_t::number_float)
14407          {
14408              return static_cast&lt;number_float_t&gt;(lhs.m_value.number_integer) == rhs.m_value.number_float;
14409          }
14410          else if (lhs_type == value_t::number_float &amp;&amp; rhs_type == value_t::number_integer)
14411          {
14412              return lhs.m_value.number_float == static_cast&lt;number_float_t&gt;(rhs.m_value.number_integer);
14413          }
14414          else if (lhs_type == value_t::number_unsigned &amp;&amp; rhs_type == value_t::number_float)
14415          {
14416              return static_cast&lt;number_float_t&gt;(lhs.m_value.number_unsigned) == rhs.m_value.number_float;
14417          }
14418          else if (lhs_type == value_t::number_float &amp;&amp; rhs_type == value_t::number_unsigned)
14419          {
14420              return lhs.m_value.number_float == static_cast&lt;number_float_t&gt;(rhs.m_value.number_unsigned);
14421          }
14422          else if (lhs_type == value_t::number_unsigned &amp;&amp; rhs_type == value_t::number_integer)
14423          {
14424              return static_cast&lt;number_integer_t&gt;(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;
14425          }
14426          else if (lhs_type == value_t::number_integer &amp;&amp; rhs_type == value_t::number_unsigned)
14427          {
14428              return lhs.m_value.number_integer == static_cast&lt;number_integer_t&gt;(rhs.m_value.number_unsigned);
14429          }
14430          return false;
14431  #ifdef __GNUC__
14432  #pragma GCC diagnostic pop
14433  #endif
14434      }
14435      template&lt;typename ScalarType, typename std::enable_if&lt;
14436                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14437      friend bool operator==(const_reference lhs, ScalarType rhs) noexcept
14438      {
14439          return lhs == basic_json(rhs);
14440      }
14441      template&lt;typename ScalarType, typename std::enable_if&lt;
14442                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14443      friend bool operator==(ScalarType lhs, const_reference rhs) noexcept
14444      {
14445          return basic_json(lhs) == rhs;
14446      }
14447      friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
14448      {
14449          return !(lhs == rhs);
14450      }
14451      template&lt;typename ScalarType, typename std::enable_if&lt;
14452                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14453      friend bool operator!=(const_reference lhs, ScalarType rhs) noexcept
14454      {
14455          return lhs != basic_json(rhs);
14456      }
14457      template&lt;typename ScalarType, typename std::enable_if&lt;
14458                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14459      friend bool operator!=(ScalarType lhs, const_reference rhs) noexcept
14460      {
14461          return basic_json(lhs) != rhs;
14462      }
14463      friend bool operator&lt;(const_reference lhs, const_reference rhs) noexcept
14464      {
14465          const auto lhs_type = lhs.type();
14466          const auto rhs_type = rhs.type();
14467          if (lhs_type == rhs_type)
14468          {
14469              switch (lhs_type)
14470              {
14471                  case value_t::array:
14472                      return (*lhs.m_value.array) &lt; (*rhs.m_value.array);
14473                  case value_t::object:
14474                      return (*lhs.m_value.object) &lt; (*rhs.m_value.object);
14475                  case value_t::null:
14476                      return false;
14477                  case value_t::string:
14478                      return (*lhs.m_value.string) &lt; (*rhs.m_value.string);
14479                  case value_t::boolean:
14480                      return (lhs.m_value.boolean) &lt; (rhs.m_value.boolean);
14481                  case value_t::number_integer:
14482                      return (lhs.m_value.number_integer) &lt; (rhs.m_value.number_integer);
14483                  case value_t::number_unsigned:
14484                      return (lhs.m_value.number_unsigned) &lt; (rhs.m_value.number_unsigned);
14485                  case value_t::number_float:
14486                      return (lhs.m_value.number_float) &lt; (rhs.m_value.number_float);
14487                  case value_t::binary:
14488                      return (*lhs.m_value.binary) &lt; (*rhs.m_value.binary);
14489                  case value_t::discarded:
14490                  default:
14491                      return false;
14492              }
14493          }
14494          else if (lhs_type == value_t::number_integer &amp;&amp; rhs_type == value_t::number_float)
14495          {
14496              return static_cast&lt;number_float_t&gt;(lhs.m_value.number_integer) &lt; rhs.m_value.number_float;
14497          }
14498          else if (lhs_type == value_t::number_float &amp;&amp; rhs_type == value_t::number_integer)
14499          {
14500              return lhs.m_value.number_float &lt; static_cast&lt;number_float_t&gt;(rhs.m_value.number_integer);
14501          }
14502          else if (lhs_type == value_t::number_unsigned &amp;&amp; rhs_type == value_t::number_float)
14503          {
14504              return static_cast&lt;number_float_t&gt;(lhs.m_value.number_unsigned) &lt; rhs.m_value.number_float;
14505          }
14506          else if (lhs_type == value_t::number_float &amp;&amp; rhs_type == value_t::number_unsigned)
14507          {
14508              return lhs.m_value.number_float &lt; static_cast&lt;number_float_t&gt;(rhs.m_value.number_unsigned);
14509          }
14510          else if (lhs_type == value_t::number_integer &amp;&amp; rhs_type == value_t::number_unsigned)
14511          {
14512              return lhs.m_value.number_integer &lt; static_cast&lt;number_integer_t&gt;(rhs.m_value.number_unsigned);
14513          }
14514          else if (lhs_type == value_t::number_unsigned &amp;&amp; rhs_type == value_t::number_integer)
14515          {
14516              return static_cast&lt;number_integer_t&gt;(lhs.m_value.number_unsigned) &lt; rhs.m_value.number_integer;
14517          }
14518          return operator&lt;(lhs_type, rhs_type);
14519      }
14520      template&lt;typename ScalarType, typename std::enable_if&lt;
14521                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14522      friend bool operator&lt;(const_reference lhs, ScalarType rhs) noexcept
14523      {
14524          return lhs &lt; basic_json(rhs);
14525      }
14526      template&lt;typename ScalarType, typename std::enable_if&lt;
14527                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14528      friend bool operator&lt;(ScalarType lhs, const_reference rhs) noexcept
14529      {
14530          return basic_json(lhs) &lt; rhs;
14531      }
14532      friend bool operator&lt;=(const_reference lhs, const_reference rhs) noexcept
14533      {
14534          return !(rhs &lt; lhs);
14535      }
14536      template&lt;typename ScalarType, typename std::enable_if&lt;
14537                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14538      friend bool operator&lt;=(const_reference lhs, ScalarType rhs) noexcept
14539      {
14540          return lhs &lt;= basic_json(rhs);
14541      }
14542      template&lt;typename ScalarType, typename std::enable_if&lt;
14543                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14544      friend bool operator&lt;=(ScalarType lhs, const_reference rhs) noexcept
14545      {
14546          return basic_json(lhs) &lt;= rhs;
14547      }
14548      friend bool operator&gt;(const_reference lhs, const_reference rhs) noexcept
14549      {
14550          return !(lhs &lt;= rhs);
14551      }
14552      template&lt;typename ScalarType, typename std::enable_if&lt;
14553                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14554      friend bool operator&gt;(const_reference lhs, ScalarType rhs) noexcept
14555      {
14556          return lhs &gt; basic_json(rhs);
14557      }
14558      template&lt;typename ScalarType, typename std::enable_if&lt;
14559                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14560      friend bool operator&gt;(ScalarType lhs, const_reference rhs) noexcept
14561      {
14562          return basic_json(lhs) &gt; rhs;
14563      }
14564      friend bool operator&gt;=(const_reference lhs, const_reference rhs) noexcept
14565      {
14566          return !(lhs &lt; rhs);
14567      }
14568      template&lt;typename ScalarType, typename std::enable_if&lt;
14569                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14570      friend bool operator&gt;=(const_reference lhs, ScalarType rhs) noexcept
14571      {
14572          return lhs &gt;= basic_json(rhs);
14573      }
14574      template&lt;typename ScalarType, typename std::enable_if&lt;
14575                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
14576      friend bool operator&gt;=(ScalarType lhs, const_reference rhs) noexcept
14577      {
14578          return basic_json(lhs) &gt;= rhs;
14579      }
14580  #ifndef JSON_NO_IO
14581      friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const basic_json&amp; j)
14582      {
14583          const bool pretty_print = o.width() &gt; 0;
14584          const auto indentation = pretty_print ? o.width() : 0;
14585          o.width(0);
14586          serializer s(detail::output_adapter&lt;char&gt;(o), o.fill());
14587          s.dump(j, pretty_print, false, static_cast&lt;unsigned int&gt;(indentation));
14588          return o;
14589      }
14590      JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;))
14591      friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp; j, std::ostream&amp; o)
14592      {
14593          return o &lt;&lt; j;
14594      }
14595  #endif  
14596      template&lt;typename InputType&gt;
14597      JSON_HEDLEY_WARN_UNUSED_RESULT
14598      static basic_json parse(InputType&amp;&amp; i,
14599                              const parser_callback_t cb = nullptr,
14600                              const bool allow_exceptions = true,
14601                              const bool ignore_comments = false)
14602      {
14603          basic_json result;
14604          parser(detail::input_adapter(std::forward&lt;InputType&gt;(i)), cb, allow_exceptions, ignore_comments).parse(true, result);
14605          return result;
14606      }
14607      template&lt;typename IteratorType&gt;
14608      JSON_HEDLEY_WARN_UNUSED_RESULT
14609      static basic_json parse(IteratorType first,
14610                              IteratorType last,
14611                              const parser_callback_t cb = nullptr,
14612                              const bool allow_exceptions = true,
14613                              const bool ignore_comments = false)
14614      {
14615          basic_json result;
14616          parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(true, result);
14617          return result;
14618      }
14619      JSON_HEDLEY_WARN_UNUSED_RESULT
14620      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
14621      static basic_json parse(detail::span_input_adapter&amp;&amp; i,
14622                              const parser_callback_t cb = nullptr,
14623                              const bool allow_exceptions = true,
14624                              const bool ignore_comments = false)
14625      {
14626          basic_json result;
14627          parser(i.get(), cb, allow_exceptions, ignore_comments).parse(true, result);
14628          return result;
14629      }
14630      template&lt;typename InputType&gt;
14631      static bool accept(InputType&amp;&amp; i,
14632                         const bool ignore_comments = false)
14633      {
14634          return parser(detail::input_adapter(std::forward&lt;InputType&gt;(i)), nullptr, false, ignore_comments).accept(true);
14635      }
14636      template&lt;typename IteratorType&gt;
14637      static bool accept(IteratorType first, IteratorType last,
14638                         const bool ignore_comments = false)
14639      {
14640          return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
14641      }
14642      JSON_HEDLEY_WARN_UNUSED_RESULT
14643      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
14644      static bool accept(detail::span_input_adapter&amp;&amp; i,
14645                         const bool ignore_comments = false)
14646      {
14647          return parser(i.get(), nullptr, false, ignore_comments).accept(true);
14648      }
14649      template &lt;typename InputType, typename SAX&gt;
14650      JSON_HEDLEY_NON_NULL(2)
14651      static bool sax_parse(InputType&amp;&amp; i, SAX* sax,
14652                            input_format_t format = input_format_t::json,
14653                            const bool strict = true,
14654                            const bool ignore_comments = false)
14655      {
14656          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
14657          return format == input_format_t::json
14658                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
14659                 : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia)).sax_parse(format, sax, strict);
14660      }
14661      template&lt;class IteratorType, class SAX&gt;
14662      JSON_HEDLEY_NON_NULL(3)
14663      static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
14664                            input_format_t format = input_format_t::json,
14665                            const bool strict = true,
14666                            const bool ignore_comments = false)
14667      {
14668          auto ia = detail::input_adapter(std::move(first), std::move(last));
14669          return format == input_format_t::json
14670                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
14671                 : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia)).sax_parse(format, sax, strict);
14672      }
14673      template &lt;typename SAX&gt;
14674      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
14675      JSON_HEDLEY_NON_NULL(2)
14676      static bool sax_parse(detail::span_input_adapter&amp;&amp; i, SAX* sax,
14677                            input_format_t format = input_format_t::json,
14678                            const bool strict = true,
14679                            const bool ignore_comments = false)
14680      {
14681          auto ia = i.get();
14682          return format == input_format_t::json
14683                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
14684                 : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia)).sax_parse(format, sax, strict);
14685      }
14686  #ifndef JSON_NO_IO
14687      JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator&gt;&gt;(std::istream&amp;, basic_json&amp;))
14688      friend std::istream&amp; operator&lt;&lt;(basic_json&amp; j, std::istream&amp; i)
14689      {
14690          return operator&gt;&gt;(i, j);
14691      }
14692      friend std::istream&amp; operator&gt;&gt;(std::istream&amp; i, basic_json&amp; j)
14693      {
14694          parser(detail::input_adapter(i)).parse(false, j);
14695          return i;
14696      }
14697  #endif  
14698      JSON_HEDLEY_RETURNS_NON_NULL
14699      const char* type_name() const noexcept
14700      {
14701          {
14702              switch (m_type)
14703              {
14704                  case value_t::null:
14705                      return &quot;null&quot;;
14706                  case value_t::object:
14707                      return &quot;object&quot;;
14708                  case value_t::array:
14709                      return &quot;array&quot;;
14710                  case value_t::string:
14711                      return &quot;string&quot;;
14712                  case value_t::boolean:
14713                      return &quot;boolean&quot;;
14714                  case value_t::binary:
14715                      return &quot;binary&quot;;
14716                  case value_t::discarded:
14717                      return &quot;discarded&quot;;
14718                  case value_t::number_integer:
14719                  case value_t::number_unsigned:
14720                  case value_t::number_float:
14721                  default:
14722                      return &quot;number&quot;;
14723              }
14724          }
14725      }
14726    JSON_PRIVATE_UNLESS_TESTED:
14727      value_t m_type = value_t::null;
14728      json_value m_value = {};
14729  #if JSON_DIAGNOSTICS
14730      basic_json* m_parent = nullptr;
14731  #endif
14732    public:
14733      static std::vector&lt;std::uint8_t&gt; to_cbor(const basic_json&amp; j)
14734      {
14735          std::vector&lt;std::uint8_t&gt; result;
14736          to_cbor(j, result);
14737          return result;
14738      }
14739      static void to_cbor(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o)
14740      {
14741          binary_writer&lt;std::uint8_t&gt;(o).write_cbor(j);
14742      }
14743      static void to_cbor(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o)
14744      {
14745          binary_writer&lt;char&gt;(o).write_cbor(j);
14746      }
14747      static std::vector&lt;std::uint8_t&gt; to_msgpack(const basic_json&amp; j)
14748      {
14749          std::vector&lt;std::uint8_t&gt; result;
14750          to_msgpack(j, result);
14751          return result;
14752      }
14753      static void to_msgpack(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o)
14754      {
14755          binary_writer&lt;std::uint8_t&gt;(o).write_msgpack(j);
14756      }
14757      static void to_msgpack(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o)
14758      {
14759          binary_writer&lt;char&gt;(o).write_msgpack(j);
14760      }
14761      static std::vector&lt;std::uint8_t&gt; to_ubjson(const basic_json&amp; j,
14762              const bool use_size = false,
14763              const bool use_type = false)
14764      {
14765          std::vector&lt;std::uint8_t&gt; result;
14766          to_ubjson(j, result, use_size, use_type);
14767          return result;
14768      }
14769      static void to_ubjson(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o,
14770                            const bool use_size = false, const bool use_type = false)
14771      {
14772          binary_writer&lt;std::uint8_t&gt;(o).write_ubjson(j, use_size, use_type);
14773      }
14774      static void to_ubjson(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o,
14775                            const bool use_size = false, const bool use_type = false)
14776      {
14777          binary_writer&lt;char&gt;(o).write_ubjson(j, use_size, use_type);
14778      }
14779      static std::vector&lt;std::uint8_t&gt; to_bson(const basic_json&amp; j)
14780      {
14781          std::vector&lt;std::uint8_t&gt; result;
14782          to_bson(j, result);
14783          return result;
14784      }
14785      static void to_bson(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o)
14786      {
14787          binary_writer&lt;std::uint8_t&gt;(o).write_bson(j);
14788      }
14789      static void to_bson(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o)
14790      {
14791          binary_writer&lt;char&gt;(o).write_bson(j);
14792      }
14793      template&lt;typename InputType&gt;
14794      JSON_HEDLEY_WARN_UNUSED_RESULT
14795      static basic_json from_cbor(InputType&amp;&amp; i,
14796                                  const bool strict = true,
14797                                  const bool allow_exceptions = true,
14798                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
14799      {
14800          basic_json result;
14801          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14802          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
14803          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);
14804          return res ? result : basic_json(value_t::discarded);
14805      }
14806      template&lt;typename IteratorType&gt;
14807      JSON_HEDLEY_WARN_UNUSED_RESULT
14808      static basic_json from_cbor(IteratorType first, IteratorType last,
14809                                  const bool strict = true,
14810                                  const bool allow_exceptions = true,
14811                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
14812      {
14813          basic_json result;
14814          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14815          auto ia = detail::input_adapter(std::move(first), std::move(last));
14816          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);
14817          return res ? result : basic_json(value_t::discarded);
14818      }
14819      template&lt;typename T&gt;
14820      JSON_HEDLEY_WARN_UNUSED_RESULT
14821      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
14822      static basic_json from_cbor(const T* ptr, std::size_t len,
14823                                  const bool strict = true,
14824                                  const bool allow_exceptions = true,
14825                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
14826      {
14827          return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
14828      }
14829      JSON_HEDLEY_WARN_UNUSED_RESULT
14830      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
14831      static basic_json from_cbor(detail::span_input_adapter&amp;&amp; i,
14832                                  const bool strict = true,
14833                                  const bool allow_exceptions = true,
14834                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
14835      {
14836          basic_json result;
14837          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14838          auto ia = i.get();
14839          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);
14840          return res ? result : basic_json(value_t::discarded);
14841      }
14842      template&lt;typename InputType&gt;
14843      JSON_HEDLEY_WARN_UNUSED_RESULT
14844      static basic_json from_msgpack(InputType&amp;&amp; i,
14845                                     const bool strict = true,
14846                                     const bool allow_exceptions = true)
14847      {
14848          basic_json result;
14849          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14850          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
14851          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::msgpack, &amp;sdp, strict);
14852          return res ? result : basic_json(value_t::discarded);
14853      }
14854      template&lt;typename IteratorType&gt;
14855      JSON_HEDLEY_WARN_UNUSED_RESULT
14856      static basic_json from_msgpack(IteratorType first, IteratorType last,
14857                                     const bool strict = true,
14858                                     const bool allow_exceptions = true)
14859      {
14860          basic_json result;
14861          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14862          auto ia = detail::input_adapter(std::move(first), std::move(last));
14863          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::msgpack, &amp;sdp, strict);
14864          return res ? result : basic_json(value_t::discarded);
14865      }
14866      template&lt;typename T&gt;
14867      JSON_HEDLEY_WARN_UNUSED_RESULT
14868      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
14869      static basic_json from_msgpack(const T* ptr, std::size_t len,
14870                                     const bool strict = true,
14871                                     const bool allow_exceptions = true)
14872      {
14873          return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
14874      }
14875      JSON_HEDLEY_WARN_UNUSED_RESULT
14876      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
14877      static basic_json from_msgpack(detail::span_input_adapter&amp;&amp; i,
14878                                     const bool strict = true,
14879                                     const bool allow_exceptions = true)
14880      {
14881          basic_json result;
14882          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14883          auto ia = i.get();
14884          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::msgpack, &amp;sdp, strict);
14885          return res ? result : basic_json(value_t::discarded);
14886      }
14887      template&lt;typename InputType&gt;
14888      JSON_HEDLEY_WARN_UNUSED_RESULT
14889      static basic_json from_ubjson(InputType&amp;&amp; i,
14890                                    const bool strict = true,
14891                                    const bool allow_exceptions = true)
14892      {
14893          basic_json result;
14894          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14895          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
14896          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::ubjson, &amp;sdp, strict);
14897          return res ? result : basic_json(value_t::discarded);
14898      }
14899      template&lt;typename IteratorType&gt;
14900      JSON_HEDLEY_WARN_UNUSED_RESULT
14901      static basic_json from_ubjson(IteratorType first, IteratorType last,
14902                                    const bool strict = true,
14903                                    const bool allow_exceptions = true)
14904      {
14905          basic_json result;
14906          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14907          auto ia = detail::input_adapter(std::move(first), std::move(last));
14908          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::ubjson, &amp;sdp, strict);
14909          return res ? result : basic_json(value_t::discarded);
14910      }
14911      template&lt;typename T&gt;
14912      JSON_HEDLEY_WARN_UNUSED_RESULT
14913      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
14914      static basic_json from_ubjson(const T* ptr, std::size_t len,
14915                                    const bool strict = true,
14916                                    const bool allow_exceptions = true)
14917      {
14918          return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
14919      }
14920      JSON_HEDLEY_WARN_UNUSED_RESULT
14921      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
14922      static basic_json from_ubjson(detail::span_input_adapter&amp;&amp; i,
14923                                    const bool strict = true,
14924                                    const bool allow_exceptions = true)
14925      {
14926          basic_json result;
14927          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14928          auto ia = i.get();
14929          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::ubjson, &amp;sdp, strict);
14930          return res ? result : basic_json(value_t::discarded);
14931      }
14932      template&lt;typename InputType&gt;
14933      JSON_HEDLEY_WARN_UNUSED_RESULT
14934      static basic_json from_bson(InputType&amp;&amp; i,
14935                                  const bool strict = true,
14936                                  const bool allow_exceptions = true)
14937      {
14938          basic_json result;
14939          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14940          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
14941          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::bson, &amp;sdp, strict);
14942          return res ? result : basic_json(value_t::discarded);
14943      }
14944      template&lt;typename IteratorType&gt;
14945      JSON_HEDLEY_WARN_UNUSED_RESULT
14946      static basic_json from_bson(IteratorType first, IteratorType last,
14947                                  const bool strict = true,
14948                                  const bool allow_exceptions = true)
14949      {
14950          basic_json result;
14951          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14952          auto ia = detail::input_adapter(std::move(first), std::move(last));
14953          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::bson, &amp;sdp, strict);
14954          return res ? result : basic_json(value_t::discarded);
14955      }
14956      template&lt;typename T&gt;
14957      JSON_HEDLEY_WARN_UNUSED_RESULT
14958      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
14959      static basic_json from_bson(const T* ptr, std::size_t len,
14960                                  const bool strict = true,
14961                                  const bool allow_exceptions = true)
14962      {
14963          return from_bson(ptr, ptr + len, strict, allow_exceptions);
14964      }
14965      JSON_HEDLEY_WARN_UNUSED_RESULT
14966      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
14967      static basic_json from_bson(detail::span_input_adapter&amp;&amp; i,
14968                                  const bool strict = true,
14969                                  const bool allow_exceptions = true)
14970      {
14971          basic_json result;
14972          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
14973          auto ia = i.get();
14974          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::bson, &amp;sdp, strict);
14975          return res ? result : basic_json(value_t::discarded);
14976      }
14977      reference operator[](const json_pointer&amp; ptr)
14978      {
14979          return ptr.get_unchecked(this);
14980      }
14981      const_reference operator[](const json_pointer&amp; ptr) const
14982      {
14983          return ptr.get_unchecked(this);
14984      }
14985      reference at(const json_pointer&amp; ptr)
14986      {
14987          return ptr.get_checked(this);
14988      }
14989      const_reference at(const json_pointer&amp; ptr) const
14990      {
14991          return ptr.get_checked(this);
14992      }
14993      basic_json flatten() const
14994      {
14995          basic_json result(value_t::object);
14996          json_pointer::flatten(&quot;&quot;, *this, result);
14997          return result;
14998      }
14999      basic_json unflatten() const
15000      {
15001          return json_pointer::unflatten(*this);
15002      }
15003      basic_json patch(const basic_json&amp; json_patch) const
15004      {
15005          basic_json result = *this;
15006          enum class patch_operations {add, remove, replace, move, copy, test, invalid};
15007          const auto get_op = [](const std::string &amp; op)
15008          {
15009              if (op == &quot;add&quot;)
15010              {
15011                  return patch_operations::add;
15012              }
15013              if (op == &quot;remove&quot;)
15014              {
15015                  return patch_operations::remove;
15016              }
15017              if (op == &quot;replace&quot;)
15018              {
15019                  return patch_operations::replace;
15020              }
15021              if (op == &quot;move&quot;)
15022              {
15023                  return patch_operations::move;
15024              }
15025              if (op == &quot;copy&quot;)
15026              {
15027                  return patch_operations::copy;
15028              }
15029              if (op == &quot;test&quot;)
15030              {
15031                  return patch_operations::test;
15032              }
15033              return patch_operations::invalid;
15034          };
15035          const auto operation_add = [&amp;result](json_pointer &amp; ptr, basic_json val)
15036          {
15037              if (ptr.empty())
15038              {
15039                  result = val;
15040                  return;
15041              }
15042              json_pointer top_pointer = ptr.top();
15043              if (top_pointer != ptr)
15044              {
15045                  result.at(top_pointer);
15046              }
15047              const auto last_path = ptr.back();
15048              ptr.pop_back();
15049              basic_json&amp; parent = result[ptr];
15050              switch (parent.m_type)
15051              {
15052                  case value_t::null:
15053                  case value_t::object:
15054                  {
15055                      parent[last_path] = val;
15056                      break;
15057                  }
15058                  case value_t::array:
15059                  {
15060                      if (last_path == &quot;-&quot;)
15061                      {
15062                          parent.push_back(val);
15063                      }
15064                      else
15065                      {
15066                          const auto idx = json_pointer::array_index(last_path);
15067                          if (JSON_HEDLEY_UNLIKELY(idx &gt; parent.size()))
15068                          {
15069                              JSON_THROW(out_of_range::create(401, &quot;array index &quot; + std::to_string(idx) + &quot; is out of range&quot;, parent));
15070                          }
15071                          parent.insert(parent.begin() + static_cast&lt;difference_type&gt;(idx), val);
15072                      }
15073                      break;
15074                  }
15075                  case value_t::string: 
15076                  case value_t::boolean: 
15077                  case value_t::number_integer: 
15078                  case value_t::number_unsigned: 
15079                  case value_t::number_float: 
15080                  case value_t::binary: 
15081                  case value_t::discarded: 
15082                  default:            
15083                      JSON_ASSERT(false); 
15084              }
15085          };
15086          const auto operation_remove = [this, &amp;result](json_pointer &amp; ptr)
15087          {
15088              const auto last_path = ptr.back();
15089              ptr.pop_back();
15090              basic_json&amp; parent = result.at(ptr);
15091              if (parent.is_object())
15092              {
15093                  auto it = parent.find(last_path);
15094                  if (JSON_HEDLEY_LIKELY(it != parent.end()))
15095                  {
15096                      parent.erase(it);
15097                  }
15098                  else
15099                  {
15100                      JSON_THROW(out_of_range::create(403, &quot;key &#x27;&quot; + last_path + &quot;&#x27; not found&quot;, *this));
15101                  }
15102              }
15103              else if (parent.is_array())
15104              {
15105                  parent.erase(json_pointer::array_index(last_path));
15106              }
15107          };
15108          if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
15109          {
15110              JSON_THROW(parse_error::create(104, 0, &quot;JSON patch must be an array of objects&quot;, json_patch));
15111          }
15112          for (const auto&amp; val : json_patch)
15113          {
15114              const auto get_value = [&amp;val](const std::string &amp; op,
15115                                            const std::string &amp; member,
15116                                            bool string_type) -&gt; basic_json &amp;
15117              {
15118                  auto it = val.m_value.object-&gt;find(member);
15119                  const auto error_msg = (op == &quot;op&quot;) ? &quot;operation&quot; : &quot;operation &#x27;&quot; + op + &quot;&#x27;&quot;;
15120                  if (JSON_HEDLEY_UNLIKELY(it == val.m_value.object-&gt;end()))
15121                  {
15122                      JSON_THROW(parse_error::create(105, 0, error_msg + &quot; must have member &#x27;&quot; + member + &quot;&#x27;&quot;, val));
15123                  }
15124                  if (JSON_HEDLEY_UNLIKELY(string_type &amp;&amp; !it-&gt;second.is_string()))
15125                  {
15126                      JSON_THROW(parse_error::create(105, 0, error_msg + &quot; must have string member &#x27;&quot; + member + &quot;&#x27;&quot;, val));
15127                  }
15128                  return it-&gt;second;
15129              };
15130              if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
15131              {
15132                  JSON_THROW(parse_error::create(104, 0, &quot;JSON patch must be an array of objects&quot;, val));
15133              }
15134              const auto op = get_value(&quot;op&quot;, &quot;op&quot;, true).template get&lt;std::string&gt;();
15135              const auto path = get_value(op, &quot;path&quot;, true).template get&lt;std::string&gt;();
15136              json_pointer ptr(path);
15137              switch (get_op(op))
15138              {
15139                  case patch_operations::add:
15140                  {
15141                      operation_add(ptr, get_value(&quot;add&quot;, &quot;value&quot;, false));
15142                      break;
15143                  }
15144                  case patch_operations::remove:
15145                  {
15146                      operation_remove(ptr);
15147                      break;
15148                  }
15149                  case patch_operations::replace:
15150                  {
15151                      result.at(ptr) = get_value(&quot;replace&quot;, &quot;value&quot;, false);
15152                      break;
15153                  }
15154                  case patch_operations::move:
15155                  {
15156                      const auto from_path = get_value(&quot;move&quot;, &quot;from&quot;, true).template get&lt;std::string&gt;();
15157                      json_pointer from_ptr(from_path);
15158                      basic_json v = result.at(from_ptr);
15159                      operation_remove(from_ptr);
15160                      operation_add(ptr, v);
15161                      break;
15162                  }
15163                  case patch_operations::copy:
15164                  {
15165                      const auto from_path = get_value(&quot;copy&quot;, &quot;from&quot;, true).template get&lt;std::string&gt;();
15166                      const json_pointer from_ptr(from_path);
15167                      basic_json v = result.at(from_ptr);
15168                      operation_add(ptr, v);
15169                      break;
15170                  }
15171                  case patch_operations::test:
15172                  {
15173                      bool success = false;
15174                      JSON_TRY
15175                      {
15176                          success = (result.at(ptr) == get_value(&quot;test&quot;, &quot;value&quot;, false));
15177                      }
15178                      JSON_INTERNAL_CATCH (out_of_range&amp;)
15179                      {
15180                      }
15181                      if (JSON_HEDLEY_UNLIKELY(!success))
15182                      {
15183                          JSON_THROW(other_error::create(501, &quot;unsuccessful: &quot; + val.dump(), val));
15184                      }
15185                      break;
15186                  }
15187                  case patch_operations::invalid:
15188                  default:
15189                  {
15190                      JSON_THROW(parse_error::create(105, 0, &quot;operation value &#x27;&quot; + op + &quot;&#x27; is invalid&quot;, val));
15191                  }
15192              }
15193          }
15194          return result;
15195      }
15196      JSON_HEDLEY_WARN_UNUSED_RESULT
15197      static basic_json diff(const basic_json&amp; source, const basic_json&amp; target,
15198                             const std::string&amp; path = &quot;&quot;)
15199      {
15200          basic_json result(value_t::array);
15201          if (source == target)
15202          {
15203              return result;
15204          }
15205          if (source.type() != target.type())
15206          {
15207              result.push_back(
15208              {
15209                  {&quot;op&quot;, &quot;replace&quot;}, {&quot;path&quot;, path}, {&quot;value&quot;, target}
15210              });
15211              return result;
15212          }
15213          switch (source.type())
15214          {
15215              case value_t::array:
15216              {
15217                  std::size_t i = 0;
15218                  while (i &lt; source.size() &amp;&amp; i &lt; target.size())
15219                  {
15220                      auto temp_diff = diff(source[i], target[i], path + &quot;/&quot; + std::to_string(i));
15221                      result.insert(result.end(), temp_diff.begin(), temp_diff.end());
15222                      ++i;
15223                  }
15224                  const auto end_index = static_cast&lt;difference_type&gt;(result.size());
15225                  while (i &lt; source.size())
15226                  {
15227                      result.insert(result.begin() + end_index, object(
15228                      {
15229                          {&quot;op&quot;, &quot;remove&quot;},
15230                          {&quot;path&quot;, path + &quot;/&quot; + std::to_string(i)}
15231                      }));
15232                      ++i;
15233                  }
15234                  while (i &lt; target.size())
15235                  {
15236                      result.push_back(
15237                      {
15238                          {&quot;op&quot;, &quot;add&quot;},
15239                          {&quot;path&quot;, path + &quot;/-&quot;},
15240                          {&quot;value&quot;, target[i]}
15241                      });
15242                      ++i;
15243                  }
15244                  break;
15245              }
15246              case value_t::object:
15247              {
15248                  for (auto it = source.cbegin(); it != source.cend(); ++it)
15249                  {
15250                      const auto path_key = path + &quot;/&quot; + detail::escape(it.key());
15251                      if (target.find(it.key()) != target.end())
15252                      {
15253                          auto temp_diff = diff(it.value(), target[it.key()], path_key);
15254                          result.insert(result.end(), temp_diff.begin(), temp_diff.end());
15255                      }
15256                      else
15257                      {
15258                          result.push_back(object(
15259                          {
15260                              {&quot;op&quot;, &quot;remove&quot;}, {&quot;path&quot;, path_key}
15261                          }));
15262                      }
15263                  }
15264                  for (auto it = target.cbegin(); it != target.cend(); ++it)
15265                  {
15266                      if (source.find(it.key()) == source.end())
15267                      {
15268                          const auto path_key = path + &quot;/&quot; + detail::escape(it.key());
15269                          result.push_back(
15270                          {
15271                              {&quot;op&quot;, &quot;add&quot;}, {&quot;path&quot;, path_key},
15272                              {&quot;value&quot;, it.value()}
15273                          });
15274                      }
15275                  }
15276                  break;
15277              }
15278              case value_t::null:
15279              case value_t::string:
15280              case value_t::boolean:
15281              case value_t::number_integer:
15282              case value_t::number_unsigned:
15283              case value_t::number_float:
15284              case value_t::binary:
15285              case value_t::discarded:
15286              default:
15287              {
15288                  result.push_back(
15289                  {
15290                      {&quot;op&quot;, &quot;replace&quot;}, {&quot;path&quot;, path}, {&quot;value&quot;, target}
15291                  });
15292                  break;
15293              }
15294          }
15295          return result;
15296      }
15297      void merge_patch(const basic_json&amp; apply_patch)
15298      {
15299          if (apply_patch.is_object())
15300          {
15301              if (!is_object())
15302              {
15303                  *this = object();
15304              }
15305              for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
15306              {
15307                  if (it.value().is_null())
15308                  {
15309                      erase(it.key());
15310                  }
15311                  else
15312                  {
15313                      operator[](it.key()).merge_patch(it.value());
15314                  }
15315              }
15316          }
15317          else
15318          {
15319              *this = apply_patch;
15320          }
15321      }
15322  };
15323  NLOHMANN_BASIC_JSON_TPL_DECLARATION
15324  std::string to_string(const NLOHMANN_BASIC_JSON_TPL&amp; j)
15325  {
15326      return j.dump();
15327  }
15328  } 
15329  namespace std
15330  {
15331  template&lt;&gt;
15332  struct hash&lt;nlohmann::json&gt;
15333  {
15334      std::size_t operator()(const nlohmann::json&amp; j) const
15335      {
15336          return nlohmann::detail::hash(j);
15337      }
15338  };
15339  template&lt;&gt;
15340  struct less&lt;::nlohmann::detail::value_t&gt;
15341  {
15342      bool operator()(nlohmann::detail::value_t lhs,
15343                      nlohmann::detail::value_t rhs) const noexcept
15344      {
15345          return nlohmann::detail::operator&lt;(lhs, rhs);
15346      }
15347  };
15348  #ifndef JSON_HAS_CPP_20
15349  template&lt;&gt;
15350  inline void swap&lt;nlohmann::json&gt;(nlohmann::json&amp; j1, nlohmann::json&amp; j2) noexcept( 
15351      is_nothrow_move_constructible&lt;nlohmann::json&gt;::value&amp;&amp;  
15352      is_nothrow_move_assignable&lt;nlohmann::json&gt;::value
15353                                )
15354  {
15355      j1.swap(j2);
15356  }
15357  #endif
15358  } 
15359  JSON_HEDLEY_NON_NULL(1)
15360  inline nlohmann::json operator &quot;&quot; _json(const char* s, std::size_t n)
15361  {
15362      return nlohmann::json::parse(s, s + n);
15363  }
15364  JSON_HEDLEY_NON_NULL(1)
15365  inline nlohmann::json::json_pointer operator &quot;&quot; _json_pointer(const char* s, std::size_t n)
15366  {
15367      return nlohmann::json::json_pointer(std::string(s, n));
15368  }
15369  #if defined(__clang__)
15370      #pragma clang diagnostic pop
15371  #endif
15372  #undef JSON_ASSERT
15373  #undef JSON_INTERNAL_CATCH
15374  #undef JSON_CATCH
15375  #undef JSON_THROW
15376  #undef JSON_TRY
15377  #undef JSON_PRIVATE_UNLESS_TESTED
15378  #undef JSON_HAS_CPP_11
15379  #undef JSON_HAS_CPP_14
15380  #undef JSON_HAS_CPP_17
15381  #undef JSON_HAS_CPP_20
15382  #undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
15383  #undef NLOHMANN_BASIC_JSON_TPL
15384  #undef JSON_EXPLICIT
15385  #undef JSON_HEDLEY_ALWAYS_INLINE
15386  #undef JSON_HEDLEY_ARM_VERSION
15387  #undef JSON_HEDLEY_ARM_VERSION_CHECK
15388  #undef JSON_HEDLEY_ARRAY_PARAM
15389  #undef JSON_HEDLEY_ASSUME
15390  #undef JSON_HEDLEY_BEGIN_C_DECLS
15391  #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
15392  #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
15393  #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
15394  #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
15395  #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
15396  #undef JSON_HEDLEY_CLANG_HAS_FEATURE
15397  #undef JSON_HEDLEY_CLANG_HAS_WARNING
15398  #undef JSON_HEDLEY_COMPCERT_VERSION
15399  #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
15400  #undef JSON_HEDLEY_CONCAT
15401  #undef JSON_HEDLEY_CONCAT3
15402  #undef JSON_HEDLEY_CONCAT3_EX
15403  #undef JSON_HEDLEY_CONCAT_EX
15404  #undef JSON_HEDLEY_CONST
15405  #undef JSON_HEDLEY_CONSTEXPR
15406  #undef JSON_HEDLEY_CONST_CAST
15407  #undef JSON_HEDLEY_CPP_CAST
15408  #undef JSON_HEDLEY_CRAY_VERSION
15409  #undef JSON_HEDLEY_CRAY_VERSION_CHECK
15410  #undef JSON_HEDLEY_C_DECL
15411  #undef JSON_HEDLEY_DEPRECATED
15412  #undef JSON_HEDLEY_DEPRECATED_FOR
15413  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
15414  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
15415  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
15416  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
15417  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
15418  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
15419  #undef JSON_HEDLEY_DIAGNOSTIC_POP
15420  #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
15421  #undef JSON_HEDLEY_DMC_VERSION
15422  #undef JSON_HEDLEY_DMC_VERSION_CHECK
15423  #undef JSON_HEDLEY_EMPTY_BASES
15424  #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
15425  #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
15426  #undef JSON_HEDLEY_END_C_DECLS
15427  #undef JSON_HEDLEY_FLAGS
15428  #undef JSON_HEDLEY_FLAGS_CAST
15429  #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
15430  #undef JSON_HEDLEY_GCC_HAS_BUILTIN
15431  #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
15432  #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
15433  #undef JSON_HEDLEY_GCC_HAS_EXTENSION
15434  #undef JSON_HEDLEY_GCC_HAS_FEATURE
15435  #undef JSON_HEDLEY_GCC_HAS_WARNING
15436  #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
15437  #undef JSON_HEDLEY_GCC_VERSION
15438  #undef JSON_HEDLEY_GCC_VERSION_CHECK
15439  #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
15440  #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
15441  #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
15442  #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
15443  #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
15444  #undef JSON_HEDLEY_GNUC_HAS_FEATURE
15445  #undef JSON_HEDLEY_GNUC_HAS_WARNING
15446  #undef JSON_HEDLEY_GNUC_VERSION
15447  #undef JSON_HEDLEY_GNUC_VERSION_CHECK
15448  #undef JSON_HEDLEY_HAS_ATTRIBUTE
15449  #undef JSON_HEDLEY_HAS_BUILTIN
15450  #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
15451  #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
15452  #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
15453  #undef JSON_HEDLEY_HAS_EXTENSION
15454  #undef JSON_HEDLEY_HAS_FEATURE
15455  #undef JSON_HEDLEY_HAS_WARNING
15456  #undef JSON_HEDLEY_IAR_VERSION
15457  #undef JSON_HEDLEY_IAR_VERSION_CHECK
15458  #undef JSON_HEDLEY_IBM_VERSION
15459  #undef JSON_HEDLEY_IBM_VERSION_CHECK
15460  #undef JSON_HEDLEY_IMPORT
15461  #undef JSON_HEDLEY_INLINE
15462  #undef JSON_HEDLEY_INTEL_CL_VERSION
15463  #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
15464  #undef JSON_HEDLEY_INTEL_VERSION
15465  #undef JSON_HEDLEY_INTEL_VERSION_CHECK
15466  #undef JSON_HEDLEY_IS_CONSTANT
15467  #undef JSON_HEDLEY_IS_CONSTEXPR_
15468  #undef JSON_HEDLEY_LIKELY
15469  #undef JSON_HEDLEY_MALLOC
15470  #undef JSON_HEDLEY_MCST_LCC_VERSION
15471  #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
15472  #undef JSON_HEDLEY_MESSAGE
15473  #undef JSON_HEDLEY_MSVC_VERSION
15474  #undef JSON_HEDLEY_MSVC_VERSION_CHECK
15475  #undef JSON_HEDLEY_NEVER_INLINE
15476  #undef JSON_HEDLEY_NON_NULL
15477  #undef JSON_HEDLEY_NO_ESCAPE
15478  #undef JSON_HEDLEY_NO_RETURN
15479  #undef JSON_HEDLEY_NO_THROW
15480  #undef JSON_HEDLEY_NULL
15481  #undef JSON_HEDLEY_PELLES_VERSION
15482  #undef JSON_HEDLEY_PELLES_VERSION_CHECK
15483  #undef JSON_HEDLEY_PGI_VERSION
15484  #undef JSON_HEDLEY_PGI_VERSION_CHECK
15485  #undef JSON_HEDLEY_PREDICT
15486  #undef JSON_HEDLEY_PRINTF_FORMAT
15487  #undef JSON_HEDLEY_PRIVATE
15488  #undef JSON_HEDLEY_PUBLIC
15489  #undef JSON_HEDLEY_PURE
15490  #undef JSON_HEDLEY_REINTERPRET_CAST
15491  #undef JSON_HEDLEY_REQUIRE
15492  #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
15493  #undef JSON_HEDLEY_REQUIRE_MSG
15494  #undef JSON_HEDLEY_RESTRICT
15495  #undef JSON_HEDLEY_RETURNS_NON_NULL
15496  #undef JSON_HEDLEY_SENTINEL
15497  #undef JSON_HEDLEY_STATIC_ASSERT
15498  #undef JSON_HEDLEY_STATIC_CAST
15499  #undef JSON_HEDLEY_STRINGIFY
15500  #undef JSON_HEDLEY_STRINGIFY_EX
15501  #undef JSON_HEDLEY_SUNPRO_VERSION
15502  #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
15503  #undef JSON_HEDLEY_TINYC_VERSION
15504  #undef JSON_HEDLEY_TINYC_VERSION_CHECK
15505  #undef JSON_HEDLEY_TI_ARMCL_VERSION
15506  #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
15507  #undef JSON_HEDLEY_TI_CL2000_VERSION
15508  #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
15509  #undef JSON_HEDLEY_TI_CL430_VERSION
15510  #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
15511  #undef JSON_HEDLEY_TI_CL6X_VERSION
15512  #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
15513  #undef JSON_HEDLEY_TI_CL7X_VERSION
15514  #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
15515  #undef JSON_HEDLEY_TI_CLPRU_VERSION
15516  #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
15517  #undef JSON_HEDLEY_TI_VERSION
15518  #undef JSON_HEDLEY_TI_VERSION_CHECK
15519  #undef JSON_HEDLEY_UNAVAILABLE
15520  #undef JSON_HEDLEY_UNLIKELY
15521  #undef JSON_HEDLEY_UNPREDICTABLE
15522  #undef JSON_HEDLEY_UNREACHABLE
15523  #undef JSON_HEDLEY_UNREACHABLE_RETURN
15524  #undef JSON_HEDLEY_VERSION
15525  #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
15526  #undef JSON_HEDLEY_VERSION_DECODE_MINOR
15527  #undef JSON_HEDLEY_VERSION_DECODE_REVISION
15528  #undef JSON_HEDLEY_VERSION_ENCODE
15529  #undef JSON_HEDLEY_WARNING
15530  #undef JSON_HEDLEY_WARN_UNUSED_RESULT
15531  #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
15532  #undef JSON_HEDLEY_FALL_THROUGH
15533  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-json.hpp</h3>
            <pre><code>1  #ifndef INCLUDE_NLOHMANN_JSON_HPP_
2  #define INCLUDE_NLOHMANN_JSON_HPP_
3  #include &lt;algorithm&gt; 
4  #include &lt;cstddef&gt; 
5  #include &lt;functional&gt; 
6  #include &lt;initializer_list&gt; 
7  #ifndef JSON_NO_IO
8      #include &lt;iosfwd&gt; 
9  #endif  
10  #include &lt;iterator&gt; 
11  #include &lt;memory&gt; 
12  #include &lt;numeric&gt; 
13  #include &lt;string&gt; 
14  #include &lt;utility&gt; 
15  #include &lt;vector&gt; 
16  #include &lt;utility&gt;
17  #ifndef JSON_SKIP_LIBRARY_VERSION_CHECK
18      #if defined(NLOHMANN_JSON_VERSION_MAJOR) &amp;&amp; defined(NLOHMANN_JSON_VERSION_MINOR) &amp;&amp; defined(NLOHMANN_JSON_VERSION_PATCH)
19          #if NLOHMANN_JSON_VERSION_MAJOR != 3 || NLOHMANN_JSON_VERSION_MINOR != 11 || NLOHMANN_JSON_VERSION_PATCH != 2
20              #warning &quot;Already included a different version of the library!&quot;
21          #endif
22      #endif
23  #endif
24  #define NLOHMANN_JSON_VERSION_MAJOR 3   
25  #define NLOHMANN_JSON_VERSION_MINOR 11  
26  #define NLOHMANN_JSON_VERSION_PATCH 2   
27  #ifndef JSON_DIAGNOSTICS
28      #define JSON_DIAGNOSTICS 0
29  #endif
30  #ifndef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
31      #define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0
32  #endif
33  #if JSON_DIAGNOSTICS
34      #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS _diag
35  #else
36      #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS
37  #endif
38  #if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
39      #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON _ldvcmp
40  #else
41      #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON
42  #endif
43  #ifndef NLOHMANN_JSON_NAMESPACE_NO_VERSION
44      #define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0
45  #endif
46  #define NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b) json_abi ## a ## b
47  #define NLOHMANN_JSON_ABI_TAGS_CONCAT(a, b) \
48      NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b)
49  #define NLOHMANN_JSON_ABI_TAGS                                       \
50      NLOHMANN_JSON_ABI_TAGS_CONCAT(                                   \
51              NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS,                       \
52              NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON)
53  #define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch) \
54      _v ## major ## _ ## minor ## _ ## patch
55  #define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(major, minor, patch) \
56      NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch)
57  #if NLOHMANN_JSON_NAMESPACE_NO_VERSION
58  #define NLOHMANN_JSON_NAMESPACE_VERSION
59  #else
60  #define NLOHMANN_JSON_NAMESPACE_VERSION                                 \
61      NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(NLOHMANN_JSON_VERSION_MAJOR, \
62                                             NLOHMANN_JSON_VERSION_MINOR, \
63                                             NLOHMANN_JSON_VERSION_PATCH)
64  #endif
65  #define NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b) a ## b
66  #define NLOHMANN_JSON_NAMESPACE_CONCAT(a, b) \
67      NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b)
68  #ifndef NLOHMANN_JSON_NAMESPACE
69  #define NLOHMANN_JSON_NAMESPACE               \
70      nlohmann::NLOHMANN_JSON_NAMESPACE_CONCAT( \
71              NLOHMANN_JSON_ABI_TAGS,           \
72              NLOHMANN_JSON_NAMESPACE_VERSION)
73  #endif
74  #ifndef NLOHMANN_JSON_NAMESPACE_BEGIN
75  #define NLOHMANN_JSON_NAMESPACE_BEGIN                \
76      namespace nlohmann                               \
77      {                                                \
78      inline namespace NLOHMANN_JSON_NAMESPACE_CONCAT( \
79                  NLOHMANN_JSON_ABI_TAGS,              \
80                  NLOHMANN_JSON_NAMESPACE_VERSION)     \
81      {
82  #endif
83  #ifndef NLOHMANN_JSON_NAMESPACE_END
84  #define NLOHMANN_JSON_NAMESPACE_END                                     \
85      }  &amp;bsol;* namespace (inline namespace) NOLINT(readability/namespace) */ \
86      }  
87  #endif
88  #include &lt;algorithm&gt; 
89  #include &lt;array&gt; 
90  #include &lt;forward_list&gt; 
91  #include &lt;iterator&gt; 
92  #include &lt;map&gt; 
93  #include &lt;string&gt; 
94  #include &lt;tuple&gt; 
95  #include &lt;type_traits&gt; 
96  #include &lt;unordered_map&gt; 
97  #include &lt;utility&gt; 
98  #include &lt;valarray&gt; 
99  #include &lt;cstddef&gt; 
100  #include &lt;exception&gt; 
101  #include &lt;stdexcept&gt; 
102  #include &lt;string&gt; 
103  #include &lt;vector&gt; 
104  #include &lt;array&gt; 
105  #include &lt;cstddef&gt; 
106  #include &lt;cstdint&gt; 
107  #include &lt;string&gt; 
108  #include &lt;utility&gt; 
109  #include &lt;type_traits&gt;
110  NLOHMANN_JSON_NAMESPACE_BEGIN
111  namespace detail
112  {
113  template&lt;typename ...Ts&gt; struct make_void
114  {
115      using type = void;
116  };
117  template&lt;typename ...Ts&gt; using void_t = typename make_void&lt;Ts...&gt;::type;
118  }  
119  NLOHMANN_JSON_NAMESPACE_END
120  NLOHMANN_JSON_NAMESPACE_BEGIN
121  namespace detail
122  {
123  struct nonesuch
124  {
125      nonesuch() = delete;
126      ~nonesuch() = delete;
127      nonesuch(nonesuch const&amp;) = delete;
128      nonesuch(nonesuch const&amp;&amp;) = delete;
129      void operator=(nonesuch const&amp;) = delete;
130      void operator=(nonesuch&amp;&amp;) = delete;
131  };
132  template&lt;class Default,
133           class AlwaysVoid,
134           template&lt;class...&gt; class Op,
135           class... Args&gt;
136  struct detector
137  {
138      using value_t = std::false_type;
139      using type = Default;
140  };
141  template&lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
142  struct detector&lt;Default, void_t&lt;Op&lt;Args...&gt;&gt;, Op, Args...&gt;
143  {
144      using value_t = std::true_type;
145      using type = Op&lt;Args...&gt;;
146  };
147  template&lt;template&lt;class...&gt; class Op, class... Args&gt;
148  using is_detected = typename detector&lt;nonesuch, void, Op, Args...&gt;::value_t;
149  template&lt;template&lt;class...&gt; class Op, class... Args&gt;
150  struct is_detected_lazy : is_detected&lt;Op, Args...&gt; { };
151  template&lt;template&lt;class...&gt; class Op, class... Args&gt;
152  using detected_t = typename detector&lt;nonesuch, void, Op, Args...&gt;::type;
153  template&lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
154  using detected_or = detector&lt;Default, void, Op, Args...&gt;;
155  template&lt;class Default, template&lt;class...&gt; class Op, class... Args&gt;
156  using detected_or_t = typename detected_or&lt;Default, Op, Args...&gt;::type;
157  template&lt;class Expected, template&lt;class...&gt; class Op, class... Args&gt;
158  using is_detected_exact = std::is_same&lt;Expected, detected_t&lt;Op, Args...&gt;&gt;;
159  template&lt;class To, template&lt;class...&gt; class Op, class... Args&gt;
160  using is_detected_convertible =
161      std::is_convertible&lt;detected_t&lt;Op, Args...&gt;, To&gt;;
162  }  
163  NLOHMANN_JSON_NAMESPACE_END
164  #if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION &lt; 15)
165  #if defined(JSON_HEDLEY_VERSION)
166      #undef JSON_HEDLEY_VERSION
167  #endif
168  #define JSON_HEDLEY_VERSION 15
169  #if defined(JSON_HEDLEY_STRINGIFY_EX)
170      #undef JSON_HEDLEY_STRINGIFY_EX
171  #endif
172  #define JSON_HEDLEY_STRINGIFY_EX(x) #x
173  #if defined(JSON_HEDLEY_STRINGIFY)
174      #undef JSON_HEDLEY_STRINGIFY
175  #endif
176  #define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)
177  #if defined(JSON_HEDLEY_CONCAT_EX)
178      #undef JSON_HEDLEY_CONCAT_EX
179  #endif
180  #define JSON_HEDLEY_CONCAT_EX(a,b) a##b
181  #if defined(JSON_HEDLEY_CONCAT)
182      #undef JSON_HEDLEY_CONCAT
183  #endif
184  #define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)
185  #if defined(JSON_HEDLEY_CONCAT3_EX)
186      #undef JSON_HEDLEY_CONCAT3_EX
187  #endif
188  #define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c
189  #if defined(JSON_HEDLEY_CONCAT3)
190      #undef JSON_HEDLEY_CONCAT3
191  #endif
192  #define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)
193  #if defined(JSON_HEDLEY_VERSION_ENCODE)
194      #undef JSON_HEDLEY_VERSION_ENCODE
195  #endif
196  #define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))
197  #if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
198      #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
199  #endif
200  #define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)
201  #if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
202      #undef JSON_HEDLEY_VERSION_DECODE_MINOR
203  #endif
204  #define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)
205  #if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
206      #undef JSON_HEDLEY_VERSION_DECODE_REVISION
207  #endif
208  #define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)
209  #if defined(JSON_HEDLEY_GNUC_VERSION)
210      #undef JSON_HEDLEY_GNUC_VERSION
211  #endif
212  #if defined(__GNUC__) &amp;&amp; defined(__GNUC_PATCHLEVEL__)
213      #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
214  #elif defined(__GNUC__)
215      #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
216  #endif
217  #if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
218      #undef JSON_HEDLEY_GNUC_VERSION_CHECK
219  #endif
220  #if defined(JSON_HEDLEY_GNUC_VERSION)
221      #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
222  #else
223      #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
224  #endif
225  #if defined(JSON_HEDLEY_MSVC_VERSION)
226      #undef JSON_HEDLEY_MSVC_VERSION
227  #endif
228  #if defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 140000000) &amp;&amp; !defined(__ICL)
229      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
230  #elif defined(_MSC_FULL_VER) &amp;&amp; !defined(__ICL)
231      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
232  #elif defined(_MSC_VER) &amp;&amp; !defined(__ICL)
233      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
234  #endif
235  #if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
236      #undef JSON_HEDLEY_MSVC_VERSION_CHECK
237  #endif
238  #if !defined(JSON_HEDLEY_MSVC_VERSION)
239      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
240  #elif defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400)
241      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER &gt;= ((major * 10000000) + (minor * 100000) + (patch)))
242  #elif defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
243      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER &gt;= ((major * 1000000) + (minor * 10000) + (patch)))
244  #else
245      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER &gt;= ((major * 100) + (minor)))
246  #endif
247  #if defined(JSON_HEDLEY_INTEL_VERSION)
248      #undef JSON_HEDLEY_INTEL_VERSION
249  #endif
250  #if defined(__INTEL_COMPILER) &amp;&amp; defined(__INTEL_COMPILER_UPDATE) &amp;&amp; !defined(__ICL)
251      #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
252  #elif defined(__INTEL_COMPILER) &amp;&amp; !defined(__ICL)
253      #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
254  #endif
255  #if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
256      #undef JSON_HEDLEY_INTEL_VERSION_CHECK
257  #endif
258  #if defined(JSON_HEDLEY_INTEL_VERSION)
259      #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
260  #else
261      #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
262  #endif
263  #if defined(JSON_HEDLEY_INTEL_CL_VERSION)
264      #undef JSON_HEDLEY_INTEL_CL_VERSION
265  #endif
266  #if defined(__INTEL_COMPILER) &amp;&amp; defined(__INTEL_COMPILER_UPDATE) &amp;&amp; defined(__ICL)
267      #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
268  #endif
269  #if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)
270      #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
271  #endif
272  #if defined(JSON_HEDLEY_INTEL_CL_VERSION)
273      #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
274  #else
275      #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)
276  #endif
277  #if defined(JSON_HEDLEY_PGI_VERSION)
278      #undef JSON_HEDLEY_PGI_VERSION
279  #endif
280  #if defined(__PGI) &amp;&amp; defined(__PGIC__) &amp;&amp; defined(__PGIC_MINOR__) &amp;&amp; defined(__PGIC_PATCHLEVEL__)
281      #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
282  #endif
283  #if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
284      #undef JSON_HEDLEY_PGI_VERSION_CHECK
285  #endif
286  #if defined(JSON_HEDLEY_PGI_VERSION)
287      #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
288  #else
289      #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
290  #endif
291  #if defined(JSON_HEDLEY_SUNPRO_VERSION)
292      #undef JSON_HEDLEY_SUNPRO_VERSION
293  #endif
294  #if defined(__SUNPRO_C) &amp;&amp; (__SUNPRO_C &gt; 0x1000)
295      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C &gt;&gt; 16) &amp; 0xf) * 10) + ((__SUNPRO_C &gt;&gt; 12) &amp; 0xf), (((__SUNPRO_C &gt;&gt; 8) &amp; 0xf) * 10) + ((__SUNPRO_C &gt;&gt; 4) &amp; 0xf), (__SUNPRO_C &amp; 0xf) * 10)
296  #elif defined(__SUNPRO_C)
297      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C &gt;&gt; 8) &amp; 0xf, (__SUNPRO_C &gt;&gt; 4) &amp; 0xf, (__SUNPRO_C) &amp; 0xf)
298  #elif defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &gt; 0x1000)
299      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC &gt;&gt; 16) &amp; 0xf) * 10) + ((__SUNPRO_CC &gt;&gt; 12) &amp; 0xf), (((__SUNPRO_CC &gt;&gt; 8) &amp; 0xf) * 10) + ((__SUNPRO_CC &gt;&gt; 4) &amp; 0xf), (__SUNPRO_CC &amp; 0xf) * 10)
300  #elif defined(__SUNPRO_CC)
301      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC &gt;&gt; 8) &amp; 0xf, (__SUNPRO_CC &gt;&gt; 4) &amp; 0xf, (__SUNPRO_CC) &amp; 0xf)
302  #endif
303  #if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
304      #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
305  #endif
306  #if defined(JSON_HEDLEY_SUNPRO_VERSION)
307      #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
308  #else
309      #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
310  #endif
311  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
312      #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
313  #endif
314  #if defined(__EMSCRIPTEN__)
315      #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
316  #endif
317  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
318      #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
319  #endif
320  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
321      #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
322  #else
323      #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
324  #endif
325  #if defined(JSON_HEDLEY_ARM_VERSION)
326      #undef JSON_HEDLEY_ARM_VERSION
327  #endif
328  #if defined(__CC_ARM) &amp;&amp; defined(__ARMCOMPILER_VERSION)
329      #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
330  #elif defined(__CC_ARM) &amp;&amp; defined(__ARMCC_VERSION)
331      #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
332  #endif
333  #if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
334      #undef JSON_HEDLEY_ARM_VERSION_CHECK
335  #endif
336  #if defined(JSON_HEDLEY_ARM_VERSION)
337      #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
338  #else
339      #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
340  #endif
341  #if defined(JSON_HEDLEY_IBM_VERSION)
342      #undef JSON_HEDLEY_IBM_VERSION
343  #endif
344  #if defined(__ibmxl__)
345      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
346  #elif defined(__xlC__) &amp;&amp; defined(__xlC_ver__)
347      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ &gt;&gt; 8, __xlC__ &amp; 0xff, (__xlC_ver__ &gt;&gt; 8) &amp; 0xff)
348  #elif defined(__xlC__)
349      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ &gt;&gt; 8, __xlC__ &amp; 0xff, 0)
350  #endif
351  #if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
352      #undef JSON_HEDLEY_IBM_VERSION_CHECK
353  #endif
354  #if defined(JSON_HEDLEY_IBM_VERSION)
355      #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
356  #else
357      #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
358  #endif
359  #if defined(JSON_HEDLEY_TI_VERSION)
360      #undef JSON_HEDLEY_TI_VERSION
361  #endif
362  #if \
363      defined(__TI_COMPILER_VERSION__) &amp;&amp; \
364      ( \
365        defined(__TMS470__) || defined(__TI_ARM__) || \
366        defined(__MSP430__) || \
367        defined(__TMS320C2000__) \
368      )
369  #if (__TI_COMPILER_VERSION__ &gt;= 16000000)
370      #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
371  #endif
372  #endif
373  #if defined(JSON_HEDLEY_TI_VERSION_CHECK)
374      #undef JSON_HEDLEY_TI_VERSION_CHECK
375  #endif
376  #if defined(JSON_HEDLEY_TI_VERSION)
377      #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
378  #else
379      #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
380  #endif
381  #if defined(JSON_HEDLEY_TI_CL2000_VERSION)
382      #undef JSON_HEDLEY_TI_CL2000_VERSION
383  #endif
384  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__TMS320C2000__)
385      #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
386  #endif
387  #if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
388      #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
389  #endif
390  #if defined(JSON_HEDLEY_TI_CL2000_VERSION)
391      #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
392  #else
393      #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
394  #endif
395  #if defined(JSON_HEDLEY_TI_CL430_VERSION)
396      #undef JSON_HEDLEY_TI_CL430_VERSION
397  #endif
398  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__MSP430__)
399      #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
400  #endif
401  #if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
402      #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
403  #endif
404  #if defined(JSON_HEDLEY_TI_CL430_VERSION)
405      #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
406  #else
407      #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
408  #endif
409  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
410      #undef JSON_HEDLEY_TI_ARMCL_VERSION
411  #endif
412  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; (defined(__TMS470__) || defined(__TI_ARM__))
413      #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
414  #endif
415  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
416      #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
417  #endif
418  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
419      #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
420  #else
421      #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
422  #endif
423  #if defined(JSON_HEDLEY_TI_CL6X_VERSION)
424      #undef JSON_HEDLEY_TI_CL6X_VERSION
425  #endif
426  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__TMS320C6X__)
427      #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
428  #endif
429  #if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
430      #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
431  #endif
432  #if defined(JSON_HEDLEY_TI_CL6X_VERSION)
433      #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
434  #else
435      #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
436  #endif
437  #if defined(JSON_HEDLEY_TI_CL7X_VERSION)
438      #undef JSON_HEDLEY_TI_CL7X_VERSION
439  #endif
440  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__C7000__)
441      #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
442  #endif
443  #if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
444      #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
445  #endif
446  #if defined(JSON_HEDLEY_TI_CL7X_VERSION)
447      #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
448  #else
449      #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
450  #endif
451  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
452      #undef JSON_HEDLEY_TI_CLPRU_VERSION
453  #endif
454  #if defined(__TI_COMPILER_VERSION__) &amp;&amp; defined(__PRU__)
455      #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
456  #endif
457  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
458      #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
459  #endif
460  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
461      #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
462  #else
463      #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
464  #endif
465  #if defined(JSON_HEDLEY_CRAY_VERSION)
466      #undef JSON_HEDLEY_CRAY_VERSION
467  #endif
468  #if defined(_CRAYC)
469      #if defined(_RELEASE_PATCHLEVEL)
470          #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
471      #else
472          #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
473      #endif
474  #endif
475  #if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
476      #undef JSON_HEDLEY_CRAY_VERSION_CHECK
477  #endif
478  #if defined(JSON_HEDLEY_CRAY_VERSION)
479      #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
480  #else
481      #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
482  #endif
483  #if defined(JSON_HEDLEY_IAR_VERSION)
484      #undef JSON_HEDLEY_IAR_VERSION
485  #endif
486  #if defined(__IAR_SYSTEMS_ICC__)
487      #if __VER__ &gt; 1000
488          #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
489      #else
490          #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)
491      #endif
492  #endif
493  #if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
494      #undef JSON_HEDLEY_IAR_VERSION_CHECK
495  #endif
496  #if defined(JSON_HEDLEY_IAR_VERSION)
497      #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
498  #else
499      #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
500  #endif
501  #if defined(JSON_HEDLEY_TINYC_VERSION)
502      #undef JSON_HEDLEY_TINYC_VERSION
503  #endif
504  #if defined(__TINYC__)
505      #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
506  #endif
507  #if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
508      #undef JSON_HEDLEY_TINYC_VERSION_CHECK
509  #endif
510  #if defined(JSON_HEDLEY_TINYC_VERSION)
511      #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
512  #else
513      #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
514  #endif
515  #if defined(JSON_HEDLEY_DMC_VERSION)
516      #undef JSON_HEDLEY_DMC_VERSION
517  #endif
518  #if defined(__DMC__)
519      #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ &gt;&gt; 8, (__DMC__ &gt;&gt; 4) &amp; 0xf, __DMC__ &amp; 0xf)
520  #endif
521  #if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
522      #undef JSON_HEDLEY_DMC_VERSION_CHECK
523  #endif
524  #if defined(JSON_HEDLEY_DMC_VERSION)
525      #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
526  #else
527      #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
528  #endif
529  #if defined(JSON_HEDLEY_COMPCERT_VERSION)
530      #undef JSON_HEDLEY_COMPCERT_VERSION
531  #endif
532  #if defined(__COMPCERT_VERSION__)
533      #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
534  #endif
535  #if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
536      #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
537  #endif
538  #if defined(JSON_HEDLEY_COMPCERT_VERSION)
539      #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
540  #else
541      #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
542  #endif
543  #if defined(JSON_HEDLEY_PELLES_VERSION)
544      #undef JSON_HEDLEY_PELLES_VERSION
545  #endif
546  #if defined(__POCC__)
547      #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
548  #endif
549  #if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
550      #undef JSON_HEDLEY_PELLES_VERSION_CHECK
551  #endif
552  #if defined(JSON_HEDLEY_PELLES_VERSION)
553      #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
554  #else
555      #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
556  #endif
557  #if defined(JSON_HEDLEY_MCST_LCC_VERSION)
558      #undef JSON_HEDLEY_MCST_LCC_VERSION
559  #endif
560  #if defined(__LCC__) &amp;&amp; defined(__LCC_MINOR__)
561      #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)
562  #endif
563  #if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)
564      #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
565  #endif
566  #if defined(JSON_HEDLEY_MCST_LCC_VERSION)
567      #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
568  #else
569      #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)
570  #endif
571  #if defined(JSON_HEDLEY_GCC_VERSION)
572      #undef JSON_HEDLEY_GCC_VERSION
573  #endif
574  #if \
575      defined(JSON_HEDLEY_GNUC_VERSION) &amp;&amp; \
576      !defined(__clang__) &amp;&amp; \
577      !defined(JSON_HEDLEY_INTEL_VERSION) &amp;&amp; \
578      !defined(JSON_HEDLEY_PGI_VERSION) &amp;&amp; \
579      !defined(JSON_HEDLEY_ARM_VERSION) &amp;&amp; \
580      !defined(JSON_HEDLEY_CRAY_VERSION) &amp;&amp; \
581      !defined(JSON_HEDLEY_TI_VERSION) &amp;&amp; \
582      !defined(JSON_HEDLEY_TI_ARMCL_VERSION) &amp;&amp; \
583      !defined(JSON_HEDLEY_TI_CL430_VERSION) &amp;&amp; \
584      !defined(JSON_HEDLEY_TI_CL2000_VERSION) &amp;&amp; \
585      !defined(JSON_HEDLEY_TI_CL6X_VERSION) &amp;&amp; \
586      !defined(JSON_HEDLEY_TI_CL7X_VERSION) &amp;&amp; \
587      !defined(JSON_HEDLEY_TI_CLPRU_VERSION) &amp;&amp; \
588      !defined(__COMPCERT__) &amp;&amp; \
589      !defined(JSON_HEDLEY_MCST_LCC_VERSION)
590      #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
591  #endif
592  #if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
593      #undef JSON_HEDLEY_GCC_VERSION_CHECK
594  #endif
595  #if defined(JSON_HEDLEY_GCC_VERSION)
596      #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION &gt;= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
597  #else
598      #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
599  #endif
600  #if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
601      #undef JSON_HEDLEY_HAS_ATTRIBUTE
602  #endif
603  #if \
604    defined(__has_attribute) &amp;&amp; \
605    ( \
606      (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \
607    )
608  #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
609  #else
610  #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
611  #endif
612  #if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
613      #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
614  #endif
615  #if defined(__has_attribute)
616      #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
617  #else
618      #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
619  #endif
620  #if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
621      #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
622  #endif
623  #if defined(__has_attribute)
624      #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
625  #else
626      #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
627  #endif
628  #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
629      #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
630  #endif
631  #if \
632      defined(__has_cpp_attribute) &amp;&amp; \
633      defined(__cplusplus) &amp;&amp; \
634      (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
635      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
636  #else
637      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
638  #endif
639  #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
640      #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
641  #endif
642  #if !defined(__cplusplus) || !defined(__has_cpp_attribute)
643      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
644  #elif \
645      !defined(JSON_HEDLEY_PGI_VERSION) &amp;&amp; \
646      !defined(JSON_HEDLEY_IAR_VERSION) &amp;&amp; \
647      (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) &amp;&amp; \
648      (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
649      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
650  #else
651      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
652  #endif
653  #if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
654      #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
655  #endif
656  #if defined(__has_cpp_attribute) &amp;&amp; defined(__cplusplus)
657      #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
658  #else
659      #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
660  #endif
661  #if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
662      #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
663  #endif
664  #if defined(__has_cpp_attribute) &amp;&amp; defined(__cplusplus)
665      #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
666  #else
667      #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
668  #endif
669  #if defined(JSON_HEDLEY_HAS_BUILTIN)
670      #undef JSON_HEDLEY_HAS_BUILTIN
671  #endif
672  #if defined(__has_builtin)
673      #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
674  #else
675      #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
676  #endif
677  #if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
678      #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
679  #endif
680  #if defined(__has_builtin)
681      #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
682  #else
683      #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
684  #endif
685  #if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
686      #undef JSON_HEDLEY_GCC_HAS_BUILTIN
687  #endif
688  #if defined(__has_builtin)
689      #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
690  #else
691      #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
692  #endif
693  #if defined(JSON_HEDLEY_HAS_FEATURE)
694      #undef JSON_HEDLEY_HAS_FEATURE
695  #endif
696  #if defined(__has_feature)
697      #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
698  #else
699      #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
700  #endif
701  #if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
702      #undef JSON_HEDLEY_GNUC_HAS_FEATURE
703  #endif
704  #if defined(__has_feature)
705      #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
706  #else
707      #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
708  #endif
709  #if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
710      #undef JSON_HEDLEY_GCC_HAS_FEATURE
711  #endif
712  #if defined(__has_feature)
713      #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
714  #else
715      #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
716  #endif
717  #if defined(JSON_HEDLEY_HAS_EXTENSION)
718      #undef JSON_HEDLEY_HAS_EXTENSION
719  #endif
720  #if defined(__has_extension)
721      #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
722  #else
723      #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
724  #endif
725  #if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
726      #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
727  #endif
728  #if defined(__has_extension)
729      #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
730  #else
731      #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
732  #endif
733  #if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
734      #undef JSON_HEDLEY_GCC_HAS_EXTENSION
735  #endif
736  #if defined(__has_extension)
737      #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
738  #else
739      #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
740  #endif
741  #if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
742      #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
743  #endif
744  #if defined(__has_declspec_attribute)
745      #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
746  #else
747      #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
748  #endif
749  #if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
750      #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
751  #endif
752  #if defined(__has_declspec_attribute)
753      #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
754  #else
755      #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
756  #endif
757  #if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
758      #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
759  #endif
760  #if defined(__has_declspec_attribute)
761      #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
762  #else
763      #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
764  #endif
765  #if defined(JSON_HEDLEY_HAS_WARNING)
766      #undef JSON_HEDLEY_HAS_WARNING
767  #endif
768  #if defined(__has_warning)
769      #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
770  #else
771      #define JSON_HEDLEY_HAS_WARNING(warning) (0)
772  #endif
773  #if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
774      #undef JSON_HEDLEY_GNUC_HAS_WARNING
775  #endif
776  #if defined(__has_warning)
777      #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
778  #else
779      #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
780  #endif
781  #if defined(JSON_HEDLEY_GCC_HAS_WARNING)
782      #undef JSON_HEDLEY_GCC_HAS_WARNING
783  #endif
784  #if defined(__has_warning)
785      #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
786  #else
787      #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
788  #endif
789  #if \
790      (defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L)) || \
791      defined(__clang__) || \
792      JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
793      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
794      JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
795      JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
796      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
797      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
798      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
799      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
800      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
801      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
802      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
803      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
804      JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
805      JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
806      JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
807      (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) &amp;&amp; defined(__C99_PRAGMA_OPERATOR))
808      #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
809  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
810      #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
811  #else
812      #define JSON_HEDLEY_PRAGMA(value)
813  #endif
814  #if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
815      #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
816  #endif
817  #if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
818      #undef JSON_HEDLEY_DIAGNOSTIC_POP
819  #endif
820  #if defined(__clang__)
821      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;clang diagnostic push&quot;)
822      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;clang diagnostic pop&quot;)
823  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
824      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;warning(push)&quot;)
825      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;warning(pop)&quot;)
826  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
827      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;GCC diagnostic push&quot;)
828      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;GCC diagnostic pop&quot;)
829  #elif \
830      JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
831      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
832      #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
833      #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
834  #elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
835      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;push&quot;)
836      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;pop&quot;)
837  #elif \
838      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
839      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
840      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
841      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
842      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
843      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
844      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;diag_push&quot;)
845      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;diag_pop&quot;)
846  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
847      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma(&quot;warning(push)&quot;)
848      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma(&quot;warning(pop)&quot;)
849  #else
850      #define JSON_HEDLEY_DIAGNOSTIC_PUSH
851      #define JSON_HEDLEY_DIAGNOSTIC_POP
852  #endif
853  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
854      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
855  #endif
856  #if defined(__cplusplus)
857  #  if JSON_HEDLEY_HAS_WARNING(&quot;-Wc++98-compat&quot;)
858  #    if JSON_HEDLEY_HAS_WARNING(&quot;-Wc++17-extensions&quot;)
859  #      if JSON_HEDLEY_HAS_WARNING(&quot;-Wc++1z-extensions&quot;)
860  #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
861      JSON_HEDLEY_DIAGNOSTIC_PUSH \
862      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++98-compat\&quot;&quot;) \
863      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++17-extensions\&quot;&quot;) \
864      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++1z-extensions\&quot;&quot;) \
865      xpr \
866      JSON_HEDLEY_DIAGNOSTIC_POP
867  #      else
868  #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
869      JSON_HEDLEY_DIAGNOSTIC_PUSH \
870      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++98-compat\&quot;&quot;) \
871      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++17-extensions\&quot;&quot;) \
872      xpr \
873      JSON_HEDLEY_DIAGNOSTIC_POP
874  #      endif
875  #    else
876  #      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
877      JSON_HEDLEY_DIAGNOSTIC_PUSH \
878      _Pragma(&quot;clang diagnostic ignored \&quot;-Wc++98-compat\&quot;&quot;) \
879      xpr \
880      JSON_HEDLEY_DIAGNOSTIC_POP
881  #    endif
882  #  endif
883  #endif
884  #if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
885      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
886  #endif
887  #if defined(JSON_HEDLEY_CONST_CAST)
888      #undef JSON_HEDLEY_CONST_CAST
889  #endif
890  #if defined(__cplusplus)
891  #  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast&lt;T&gt;(expr))
892  #elif \
893    JSON_HEDLEY_HAS_WARNING(&quot;-Wcast-qual&quot;) || \
894    JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
895    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
896  #  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
897          JSON_HEDLEY_DIAGNOSTIC_PUSH \
898          JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
899          ((T) (expr)); \
900          JSON_HEDLEY_DIAGNOSTIC_POP \
901      }))
902  #else
903  #  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
904  #endif
905  #if defined(JSON_HEDLEY_REINTERPRET_CAST)
906      #undef JSON_HEDLEY_REINTERPRET_CAST
907  #endif
908  #if defined(__cplusplus)
909      #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast&lt;T&gt;(expr))
910  #else
911      #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
912  #endif
913  #if defined(JSON_HEDLEY_STATIC_CAST)
914      #undef JSON_HEDLEY_STATIC_CAST
915  #endif
916  #if defined(__cplusplus)
917      #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast&lt;T&gt;(expr))
918  #else
919      #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
920  #endif
921  #if defined(JSON_HEDLEY_CPP_CAST)
922      #undef JSON_HEDLEY_CPP_CAST
923  #endif
924  #if defined(__cplusplus)
925  #  if JSON_HEDLEY_HAS_WARNING(&quot;-Wold-style-cast&quot;)
926  #    define JSON_HEDLEY_CPP_CAST(T, expr) \
927      JSON_HEDLEY_DIAGNOSTIC_PUSH \
928      _Pragma(&quot;clang diagnostic ignored \&quot;-Wold-style-cast\&quot;&quot;) \
929      ((T) (expr)) \
930      JSON_HEDLEY_DIAGNOSTIC_POP
931  #  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
932  #    define JSON_HEDLEY_CPP_CAST(T, expr) \
933      JSON_HEDLEY_DIAGNOSTIC_PUSH \
934      _Pragma(&quot;diag_suppress=Pe137&quot;) \
935      JSON_HEDLEY_DIAGNOSTIC_POP
936  #  else
937  #    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
938  #  endif
939  #else
940  #  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
941  #endif
942  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
943      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
944  #endif
945  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wdeprecated-declarations&quot;)
946      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;clang diagnostic ignored \&quot;-Wdeprecated-declarations\&quot;&quot;)
947  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
948      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;warning(disable:1478 1786)&quot;)
949  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
950      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))
951  #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
952      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress 1215,1216,1444,1445&quot;)
953  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
954      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress 1215,1444&quot;)
955  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
956      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;GCC diagnostic ignored \&quot;-Wdeprecated-declarations\&quot;&quot;)
957  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
958      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
959  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
960      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress 1215,1444&quot;)
961  #elif \
962      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
963      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
964      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
965      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
966      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
967      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
968      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
969      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
970      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
971      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
972      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
973      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress 1291,1718&quot;)
974  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) &amp;&amp; !defined(__cplusplus)
975      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)&quot;)
976  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) &amp;&amp; defined(__cplusplus)
977      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;error_messages(off,symdeprecated,symdeprecated2)&quot;)
978  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
979      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;diag_suppress=Pe1444,Pe1215&quot;)
980  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
981      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma(&quot;warn(disable:2241)&quot;)
982  #else
983      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
984  #endif
985  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
986      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
987  #endif
988  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunknown-pragmas&quot;)
989      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;clang diagnostic ignored \&quot;-Wunknown-pragmas\&quot;&quot;)
990  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
991      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;warning(disable:161)&quot;)
992  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
993      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))
994  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
995      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress 1675&quot;)
996  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
997      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;GCC diagnostic ignored \&quot;-Wunknown-pragmas\&quot;&quot;)
998  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
999      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
1000  #elif \
1001      JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
1002      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
1003      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1004      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
1005      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress 163&quot;)
1006  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
1007      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress 163&quot;)
1008  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1009      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress=Pe161&quot;)
1010  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1011      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma(&quot;diag_suppress 161&quot;)
1012  #else
1013      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
1014  #endif
1015  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
1016      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
1017  #endif
1018  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunknown-attributes&quot;)
1019      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;clang diagnostic ignored \&quot;-Wunknown-attributes\&quot;&quot;)
1020  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
1021      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;GCC diagnostic ignored \&quot;-Wdeprecated-declarations\&quot;&quot;)
1022  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
1023      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;warning(disable:1292)&quot;)
1024  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1025      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))
1026  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
1027      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
1028  #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
1029      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress 1097,1098&quot;)
1030  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
1031      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress 1097&quot;)
1032  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) &amp;&amp; defined(__cplusplus)
1033      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;error_messages(off,attrskipunsup)&quot;)
1034  #elif \
1035      JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
1036      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
1037      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
1038      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress 1173&quot;)
1039  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1040      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress=Pe1097&quot;)
1041  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1042      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma(&quot;diag_suppress 1097&quot;)
1043  #else
1044      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
1045  #endif
1046  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
1047      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
1048  #endif
1049  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wcast-qual&quot;)
1050      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(&quot;clang diagnostic ignored \&quot;-Wcast-qual\&quot;&quot;)
1051  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1052      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(&quot;warning(disable:2203 2331)&quot;)
1053  #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
1054      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma(&quot;GCC diagnostic ignored \&quot;-Wcast-qual\&quot;&quot;)
1055  #else
1056      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
1057  #endif
1058  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)
1059      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
1060  #endif
1061  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunused-function&quot;)
1062      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(&quot;clang diagnostic ignored \&quot;-Wunused-function\&quot;&quot;)
1063  #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)
1064      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(&quot;GCC diagnostic ignored \&quot;-Wunused-function\&quot;&quot;)
1065  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)
1066      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))
1067  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1068      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma(&quot;diag_suppress 3142&quot;)
1069  #else
1070      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
1071  #endif
1072  #if defined(JSON_HEDLEY_DEPRECATED)
1073      #undef JSON_HEDLEY_DEPRECATED
1074  #endif
1075  #if defined(JSON_HEDLEY_DEPRECATED_FOR)
1076      #undef JSON_HEDLEY_DEPRECATED_FOR
1077  #endif
1078  #if \
1079      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1080      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1081      #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated(&quot;Since &quot; # since))
1082      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated(&quot;Since &quot; #since &quot;; use &quot; #replacement))
1083  #elif \
1084      (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) &amp;&amp; !defined(JSON_HEDLEY_IAR_VERSION)) || \
1085      JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
1086      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1087      JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
1088      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
1089      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1090      JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
1091      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
1092      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
1093      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1094      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \
1095      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1096      #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__(&quot;Since &quot; #since)))
1097      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__(&quot;Since &quot; #since &quot;; use &quot; #replacement)))
1098  #elif defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201402L)
1099      #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated(&quot;Since &quot; #since)]])
1100      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated(&quot;Since &quot; #since &quot;; use &quot; #replacement)]])
1101  #elif \
1102      JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
1103      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1104      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1105      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1106      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1107      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1108      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1109      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1110      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1111      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1112      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1113      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1114      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1115      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1116      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1117      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1118      #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
1119      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
1120  #elif \
1121      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1122      JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \
1123      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1124      #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
1125      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
1126  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1127      #define JSON_HEDLEY_DEPRECATED(since) _Pragma(&quot;deprecated&quot;)
1128      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma(&quot;deprecated&quot;)
1129  #else
1130      #define JSON_HEDLEY_DEPRECATED(since)
1131      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
1132  #endif
1133  #if defined(JSON_HEDLEY_UNAVAILABLE)
1134      #undef JSON_HEDLEY_UNAVAILABLE
1135  #endif
1136  #if \
1137      JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
1138      JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
1139      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1140      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1141      #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__(&quot;Not available until &quot; #available_since)))
1142  #else
1143      #define JSON_HEDLEY_UNAVAILABLE(available_since)
1144  #endif
1145  #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
1146      #undef JSON_HEDLEY_WARN_UNUSED_RESULT
1147  #endif
1148  #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
1149      #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
1150  #endif
1151  #if \
1152      JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
1153      JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1154      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1155      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1156      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1157      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1158      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1159      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1160      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1161      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1162      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1163      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1164      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1165      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1166      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) &amp;&amp; defined(__cplusplus)) || \
1167      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1168      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1169      #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
1170      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
1171  #elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) &gt;= 201907L)
1172      #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1173      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
1174  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
1175      #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1176      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1177  #elif defined(_Check_return_) &amp;bsol;* SAL */
1178      #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
1179      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
1180  #else
1181      #define JSON_HEDLEY_WARN_UNUSED_RESULT
1182      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
1183  #endif
1184  #if defined(JSON_HEDLEY_SENTINEL)
1185      #undef JSON_HEDLEY_SENTINEL
1186  #endif
1187  #if \
1188      JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
1189      JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1190      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1191      JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
1192      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1193      #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
1194  #else
1195      #define JSON_HEDLEY_SENTINEL(position)
1196  #endif
1197  #if defined(JSON_HEDLEY_NO_RETURN)
1198      #undef JSON_HEDLEY_NO_RETURN
1199  #endif
1200  #if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1201      #define JSON_HEDLEY_NO_RETURN __noreturn
1202  #elif \
1203      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1204      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1205      #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
1206  #elif defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 201112L
1207      #define JSON_HEDLEY_NO_RETURN _Noreturn
1208  #elif defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L)
1209      #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
1210  #elif \
1211      JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
1212      JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
1213      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1214      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1215      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1216      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1217      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1218      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1219      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1220      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1221      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1222      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1223      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1224      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1225      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1226      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1227      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1228      #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
1229  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1230      #define JSON_HEDLEY_NO_RETURN _Pragma(&quot;does_not_return&quot;)
1231  #elif \
1232      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1233      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1234      #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
1235  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) &amp;&amp; defined(__cplusplus)
1236      #define JSON_HEDLEY_NO_RETURN _Pragma(&quot;FUNC_NEVER_RETURNS;&quot;)
1237  #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
1238      #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
1239  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
1240      #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
1241  #else
1242      #define JSON_HEDLEY_NO_RETURN
1243  #endif
1244  #if defined(JSON_HEDLEY_NO_ESCAPE)
1245      #undef JSON_HEDLEY_NO_ESCAPE
1246  #endif
1247  #if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
1248      #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
1249  #else
1250      #define JSON_HEDLEY_NO_ESCAPE
1251  #endif
1252  #if defined(JSON_HEDLEY_UNREACHABLE)
1253      #undef JSON_HEDLEY_UNREACHABLE
1254  #endif
1255  #if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
1256      #undef JSON_HEDLEY_UNREACHABLE_RETURN
1257  #endif
1258  #if defined(JSON_HEDLEY_ASSUME)
1259      #undef JSON_HEDLEY_ASSUME
1260  #endif
1261  #if \
1262      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1263      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1264      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1265      #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
1266  #elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
1267      #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
1268  #elif \
1269      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1270      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
1271      #if defined(__cplusplus)
1272          #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
1273      #else
1274          #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
1275      #endif
1276  #endif
1277  #if \
1278      (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) &amp;&amp; (!defined(JSON_HEDLEY_ARM_VERSION))) || \
1279      JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
1280      JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
1281      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1282      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \
1283      JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \
1284      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1285      #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
1286  #elif defined(JSON_HEDLEY_ASSUME)
1287      #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
1288  #endif
1289  #if !defined(JSON_HEDLEY_ASSUME)
1290      #if defined(JSON_HEDLEY_UNREACHABLE)
1291          #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
1292      #else
1293          #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
1294      #endif
1295  #endif
1296  #if defined(JSON_HEDLEY_UNREACHABLE)
1297      #if  \
1298          JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1299          JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
1300          #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
1301      #else
1302          #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
1303      #endif
1304  #else
1305      #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
1306  #endif
1307  #if !defined(JSON_HEDLEY_UNREACHABLE)
1308      #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
1309  #endif
1310  JSON_HEDLEY_DIAGNOSTIC_PUSH
1311  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wpedantic&quot;)
1312      #pragma clang diagnostic ignored &quot;-Wpedantic&quot;
1313  #endif
1314  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wc++98-compat-pedantic&quot;) &amp;&amp; defined(__cplusplus)
1315      #pragma clang diagnostic ignored &quot;-Wc++98-compat-pedantic&quot;
1316  #endif
1317  #if JSON_HEDLEY_GCC_HAS_WARNING(&quot;-Wvariadic-macros&quot;,4,0,0)
1318      #if defined(__clang__)
1319          #pragma clang diagnostic ignored &quot;-Wvariadic-macros&quot;
1320      #elif defined(JSON_HEDLEY_GCC_VERSION)
1321          #pragma GCC diagnostic ignored &quot;-Wvariadic-macros&quot;
1322      #endif
1323  #endif
1324  #if defined(JSON_HEDLEY_NON_NULL)
1325      #undef JSON_HEDLEY_NON_NULL
1326  #endif
1327  #if \
1328      JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
1329      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1330      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1331      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
1332      #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
1333  #else
1334      #define JSON_HEDLEY_NON_NULL(...)
1335  #endif
1336  JSON_HEDLEY_DIAGNOSTIC_POP
1337  #if defined(JSON_HEDLEY_PRINTF_FORMAT)
1338      #undef JSON_HEDLEY_PRINTF_FORMAT
1339  #endif
1340  #if defined(__MINGW32__) &amp;&amp; JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) &amp;&amp; !defined(__USE_MINGW_ANSI_STDIO)
1341      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
1342  #elif defined(__MINGW32__) &amp;&amp; JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) &amp;&amp; defined(__USE_MINGW_ANSI_STDIO)
1343      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
1344  #elif \
1345      JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
1346      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1347      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1348      JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
1349      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1350      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1351      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1352      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1353      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1354      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1355      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1356      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1357      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1358      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1359      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1360      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1361      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1362      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
1363  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
1364      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
1365  #else
1366      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
1367  #endif
1368  #if defined(JSON_HEDLEY_CONSTEXPR)
1369      #undef JSON_HEDLEY_CONSTEXPR
1370  #endif
1371  #if defined(__cplusplus)
1372      #if __cplusplus &gt;= 201103L
1373          #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
1374      #endif
1375  #endif
1376  #if !defined(JSON_HEDLEY_CONSTEXPR)
1377      #define JSON_HEDLEY_CONSTEXPR
1378  #endif
1379  #if defined(JSON_HEDLEY_PREDICT)
1380      #undef JSON_HEDLEY_PREDICT
1381  #endif
1382  #if defined(JSON_HEDLEY_LIKELY)
1383      #undef JSON_HEDLEY_LIKELY
1384  #endif
1385  #if defined(JSON_HEDLEY_UNLIKELY)
1386      #undef JSON_HEDLEY_UNLIKELY
1387  #endif
1388  #if defined(JSON_HEDLEY_UNPREDICTABLE)
1389      #undef JSON_HEDLEY_UNPREDICTABLE
1390  #endif
1391  #if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
1392      #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
1393  #endif
1394  #if \
1395    (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) &amp;&amp; !defined(JSON_HEDLEY_PGI_VERSION)) || \
1396    JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \
1397    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1398  #  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
1399  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
1400  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
1401  #  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
1402  #  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
1403  #elif \
1404    (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) &amp;&amp; !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
1405    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
1406    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1407    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) &amp;&amp; defined(__cplusplus)) || \
1408    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1409    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1410    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1411    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
1412    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
1413    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
1414    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1415    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1416    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1417    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
1418    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1419    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1420  #  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
1421      (((probability) &gt;= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
1422  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
1423      (__extension__ ({ \
1424          double hedley_probability_ = (probability); \
1425          ((hedley_probability_ &gt;= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ &lt;= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
1426      }))
1427  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
1428      (__extension__ ({ \
1429          double hedley_probability_ = (probability); \
1430          ((hedley_probability_ &gt;= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ &lt;= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
1431      }))
1432  #  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
1433  #  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
1434  #else
1435  #  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
1436  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
1437  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
1438  #  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
1439  #  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
1440  #endif
1441  #if !defined(JSON_HEDLEY_UNPREDICTABLE)
1442      #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
1443  #endif
1444  #if defined(JSON_HEDLEY_MALLOC)
1445      #undef JSON_HEDLEY_MALLOC
1446  #endif
1447  #if \
1448      JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
1449      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1450      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1451      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1452      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1453      JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
1454      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1455      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1456      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1457      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1458      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1459      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1460      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1461      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1462      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1463      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1464      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1465      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1466      #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
1467  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1468      #define JSON_HEDLEY_MALLOC _Pragma(&quot;returns_new_memory&quot;)
1469  #elif \
1470      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1471      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1472      #define JSON_HEDLEY_MALLOC __declspec(restrict)
1473  #else
1474      #define JSON_HEDLEY_MALLOC
1475  #endif
1476  #if defined(JSON_HEDLEY_PURE)
1477      #undef JSON_HEDLEY_PURE
1478  #endif
1479  #if \
1480    JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
1481    JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
1482    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1483    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1484    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1485    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1486    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1487    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1488    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1489    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1490    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1491    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1492    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1493    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1494    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1495    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1496    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1497    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1498    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1499  #  define JSON_HEDLEY_PURE __attribute__((__pure__))
1500  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1501  #  define JSON_HEDLEY_PURE _Pragma(&quot;does_not_write_global_data&quot;)
1502  #elif defined(__cplusplus) &amp;&amp; \
1503      ( \
1504        JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
1505        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
1506        JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
1507      )
1508  #  define JSON_HEDLEY_PURE _Pragma(&quot;FUNC_IS_PURE;&quot;)
1509  #else
1510  #  define JSON_HEDLEY_PURE
1511  #endif
1512  #if defined(JSON_HEDLEY_CONST)
1513      #undef JSON_HEDLEY_CONST
1514  #endif
1515  #if \
1516      JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
1517      JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
1518      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1519      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1520      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1521      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1522      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1523      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1524      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1525      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1526      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1527      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1528      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1529      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1530      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1531      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1532      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1533      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1534      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1535      #define JSON_HEDLEY_CONST __attribute__((__const__))
1536  #elif \
1537      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1538      #define JSON_HEDLEY_CONST _Pragma(&quot;no_side_effect&quot;)
1539  #else
1540      #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
1541  #endif
1542  #if defined(JSON_HEDLEY_RESTRICT)
1543      #undef JSON_HEDLEY_RESTRICT
1544  #endif
1545  #if defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L) &amp;&amp; !defined(__cplusplus)
1546      #define JSON_HEDLEY_RESTRICT restrict
1547  #elif \
1548      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1549      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1550      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1551      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1552      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1553      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1554      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1555      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1556      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
1557      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
1558      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1559      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) &amp;&amp; defined(__cplusplus)) || \
1560      JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
1561      defined(__clang__) || \
1562      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1563      #define JSON_HEDLEY_RESTRICT __restrict
1564  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) &amp;&amp; !defined(__cplusplus)
1565      #define JSON_HEDLEY_RESTRICT _Restrict
1566  #else
1567      #define JSON_HEDLEY_RESTRICT
1568  #endif
1569  #if defined(JSON_HEDLEY_INLINE)
1570      #undef JSON_HEDLEY_INLINE
1571  #endif
1572  #if \
1573      (defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L)) || \
1574      (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 199711L))
1575      #define JSON_HEDLEY_INLINE inline
1576  #elif \
1577      defined(JSON_HEDLEY_GCC_VERSION) || \
1578      JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
1579      #define JSON_HEDLEY_INLINE __inline__
1580  #elif \
1581      JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
1582      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1583      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1584      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
1585      JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
1586      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1587      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
1588      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1589      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1590      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1591      #define JSON_HEDLEY_INLINE __inline
1592  #else
1593      #define JSON_HEDLEY_INLINE
1594  #endif
1595  #if defined(JSON_HEDLEY_ALWAYS_INLINE)
1596      #undef JSON_HEDLEY_ALWAYS_INLINE
1597  #endif
1598  #if \
1599    JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
1600    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1601    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1602    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1603    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1604    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1605    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1606    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1607    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1608    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1609    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1610    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1611    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1612    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1613    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1614    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1615    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1616    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1617    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1618  #  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
1619  #elif \
1620    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
1621    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1622  #  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
1623  #elif defined(__cplusplus) &amp;&amp; \
1624      ( \
1625        JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1626        JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1627        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1628        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1629        JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1630        JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
1631      )
1632  #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma(&quot;FUNC_ALWAYS_INLINE;&quot;)
1633  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1634  #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma(&quot;inline=forced&quot;)
1635  #else
1636  #  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
1637  #endif
1638  #if defined(JSON_HEDLEY_NEVER_INLINE)
1639      #undef JSON_HEDLEY_NEVER_INLINE
1640  #endif
1641  #if \
1642      JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
1643      JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1644      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1645      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1646      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1647      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1648      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1649      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1650      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1651      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1652      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1653      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1654      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1655      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1656      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1657      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1658      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1659      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1660      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1661      #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
1662  #elif \
1663      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1664      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1665      #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
1666  #elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
1667      #define JSON_HEDLEY_NEVER_INLINE _Pragma(&quot;noinline&quot;)
1668  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) &amp;&amp; defined(__cplusplus)
1669      #define JSON_HEDLEY_NEVER_INLINE _Pragma(&quot;FUNC_CANNOT_INLINE;&quot;)
1670  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1671      #define JSON_HEDLEY_NEVER_INLINE _Pragma(&quot;inline=never&quot;)
1672  #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
1673      #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
1674  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
1675      #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
1676  #else
1677      #define JSON_HEDLEY_NEVER_INLINE
1678  #endif
1679  #if defined(JSON_HEDLEY_PRIVATE)
1680      #undef JSON_HEDLEY_PRIVATE
1681  #endif
1682  #if defined(JSON_HEDLEY_PUBLIC)
1683      #undef JSON_HEDLEY_PUBLIC
1684  #endif
1685  #if defined(JSON_HEDLEY_IMPORT)
1686      #undef JSON_HEDLEY_IMPORT
1687  #endif
1688  #if defined(_WIN32) || defined(__CYGWIN__)
1689  #  define JSON_HEDLEY_PRIVATE
1690  #  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
1691  #  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
1692  #else
1693  #  if \
1694      JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
1695      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1696      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1697      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1698      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1699      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1700      ( \
1701        defined(__TI_EABI__) &amp;&amp; \
1702        ( \
1703          (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) &amp;&amp; defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1704          JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
1705        ) \
1706      ) || \
1707      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1708  #    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__(&quot;hidden&quot;)))
1709  #    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__(&quot;default&quot;)))
1710  #  else
1711  #    define JSON_HEDLEY_PRIVATE
1712  #    define JSON_HEDLEY_PUBLIC
1713  #  endif
1714  #  define JSON_HEDLEY_IMPORT    extern
1715  #endif
1716  #if defined(JSON_HEDLEY_NO_THROW)
1717      #undef JSON_HEDLEY_NO_THROW
1718  #endif
1719  #if \
1720      JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
1721      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1722      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1723      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1724      #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
1725  #elif \
1726      JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
1727      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1728      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
1729      #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
1730  #else
1731      #define JSON_HEDLEY_NO_THROW
1732  #endif
1733  #if defined(JSON_HEDLEY_FALL_THROUGH)
1734      #undef JSON_HEDLEY_FALL_THROUGH
1735  #endif
1736  #if \
1737      JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
1738      JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \
1739      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1740      #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
1741  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
1742      #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
1743  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
1744      #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
1745  #elif defined(__fallthrough) &amp;bsol;* SAL */
1746      #define JSON_HEDLEY_FALL_THROUGH __fallthrough
1747  #else
1748      #define JSON_HEDLEY_FALL_THROUGH
1749  #endif
1750  #if defined(JSON_HEDLEY_RETURNS_NON_NULL)
1751      #undef JSON_HEDLEY_RETURNS_NON_NULL
1752  #endif
1753  #if \
1754      JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
1755      JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
1756      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1757      #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
1758  #elif defined(_Ret_notnull_) &amp;bsol;* SAL */
1759      #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
1760  #else
1761      #define JSON_HEDLEY_RETURNS_NON_NULL
1762  #endif
1763  #if defined(JSON_HEDLEY_ARRAY_PARAM)
1764      #undef JSON_HEDLEY_ARRAY_PARAM
1765  #endif
1766  #if \
1767      defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L) &amp;&amp; \
1768      !defined(__STDC_NO_VLA__) &amp;&amp; \
1769      !defined(__cplusplus) &amp;&amp; \
1770      !defined(JSON_HEDLEY_PGI_VERSION) &amp;&amp; \
1771      !defined(JSON_HEDLEY_TINYC_VERSION)
1772      #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
1773  #else
1774      #define JSON_HEDLEY_ARRAY_PARAM(name)
1775  #endif
1776  #if defined(JSON_HEDLEY_IS_CONSTANT)
1777      #undef JSON_HEDLEY_IS_CONSTANT
1778  #endif
1779  #if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
1780      #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
1781  #endif
1782  #if defined(JSON_HEDLEY_IS_CONSTEXPR_)
1783      #undef JSON_HEDLEY_IS_CONSTEXPR_
1784  #endif
1785  #if \
1786      JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
1787      JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1788      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1789      JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
1790      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1791      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1792      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1793      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) &amp;&amp; !defined(__cplusplus)) || \
1794      JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1795      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1796      #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
1797  #endif
1798  #if !defined(__cplusplus)
1799  #  if \
1800         JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
1801         JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1802         JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1803         JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1804         JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1805         JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
1806         JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
1807  #if defined(__INTPTR_TYPE__)
1808      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
1809  #else
1810      #include &lt;stdint.h&gt;
1811      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
1812  #endif
1813  #  elif \
1814         ( \
1815            defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 201112L) &amp;&amp; \
1816            !defined(JSON_HEDLEY_SUNPRO_VERSION) &amp;&amp; \
1817            !defined(JSON_HEDLEY_PGI_VERSION) &amp;&amp; \
1818            !defined(JSON_HEDLEY_IAR_VERSION)) || \
1819         (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) &amp;&amp; !defined(JSON_HEDLEY_IAR_VERSION)) || \
1820         JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
1821         JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
1822         JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
1823         JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
1824  #if defined(__INTPTR_TYPE__)
1825      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
1826  #else
1827      #include &lt;stdint.h&gt;
1828      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
1829  #endif
1830  #  elif \
1831         defined(JSON_HEDLEY_GCC_VERSION) || \
1832         defined(JSON_HEDLEY_INTEL_VERSION) || \
1833         defined(JSON_HEDLEY_TINYC_VERSION) || \
1834         defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
1835         JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
1836         defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
1837         defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
1838         defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
1839         defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
1840         defined(__clang__)
1841  #    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
1842          sizeof(void) != \
1843          sizeof(*( \
1844                    1 ? \
1845                    ((void*) ((expr) * 0L) ) : \
1846  ((struct { char v[sizeof(void) * 2]; } *) 1) \
1847                  ) \
1848                ) \
1849                                              )
1850  #  endif
1851  #endif
1852  #if defined(JSON_HEDLEY_IS_CONSTEXPR_)
1853      #if !defined(JSON_HEDLEY_IS_CONSTANT)
1854          #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
1855      #endif
1856      #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
1857  #else
1858      #if !defined(JSON_HEDLEY_IS_CONSTANT)
1859          #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
1860      #endif
1861      #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
1862  #endif
1863  #if defined(JSON_HEDLEY_BEGIN_C_DECLS)
1864      #undef JSON_HEDLEY_BEGIN_C_DECLS
1865  #endif
1866  #if defined(JSON_HEDLEY_END_C_DECLS)
1867      #undef JSON_HEDLEY_END_C_DECLS
1868  #endif
1869  #if defined(JSON_HEDLEY_C_DECL)
1870      #undef JSON_HEDLEY_C_DECL
1871  #endif
1872  #if defined(__cplusplus)
1873      #define JSON_HEDLEY_BEGIN_C_DECLS extern &quot;C&quot; {
1874      #define JSON_HEDLEY_END_C_DECLS }
1875      #define JSON_HEDLEY_C_DECL extern &quot;C&quot;
1876  #else
1877      #define JSON_HEDLEY_BEGIN_C_DECLS
1878      #define JSON_HEDLEY_END_C_DECLS
1879      #define JSON_HEDLEY_C_DECL
1880  #endif
1881  #if defined(JSON_HEDLEY_STATIC_ASSERT)
1882      #undef JSON_HEDLEY_STATIC_ASSERT
1883  #endif
1884  #if \
1885    !defined(__cplusplus) &amp;&amp; ( \
1886        (defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 201112L)) || \
1887        (JSON_HEDLEY_HAS_FEATURE(c_static_assert) &amp;&amp; !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
1888        JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
1889        JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1890        defined(_Static_assert) \
1891      )
1892  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
1893  #elif \
1894    (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L)) || \
1895    JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
1896    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1897  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
1898  #else
1899  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
1900  #endif
1901  #if defined(JSON_HEDLEY_NULL)
1902      #undef JSON_HEDLEY_NULL
1903  #endif
1904  #if defined(__cplusplus)
1905      #if __cplusplus &gt;= 201103L
1906          #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
1907      #elif defined(NULL)
1908          #define JSON_HEDLEY_NULL NULL
1909      #else
1910          #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
1911      #endif
1912  #elif defined(NULL)
1913      #define JSON_HEDLEY_NULL NULL
1914  #else
1915      #define JSON_HEDLEY_NULL ((void*) 0)
1916  #endif
1917  #if defined(JSON_HEDLEY_MESSAGE)
1918      #undef JSON_HEDLEY_MESSAGE
1919  #endif
1920  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunknown-pragmas&quot;)
1921  #  define JSON_HEDLEY_MESSAGE(msg) \
1922      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1923      JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
1924      JSON_HEDLEY_PRAGMA(message msg) \
1925      JSON_HEDLEY_DIAGNOSTIC_POP
1926  #elif \
1927    JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
1928    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1929  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
1930  #elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
1931  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
1932  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1933  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
1934  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
1935  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
1936  #else
1937  #  define JSON_HEDLEY_MESSAGE(msg)
1938  #endif
1939  #if defined(JSON_HEDLEY_WARNING)
1940      #undef JSON_HEDLEY_WARNING
1941  #endif
1942  #if JSON_HEDLEY_HAS_WARNING(&quot;-Wunknown-pragmas&quot;)
1943  #  define JSON_HEDLEY_WARNING(msg) \
1944      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1945      JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
1946      JSON_HEDLEY_PRAGMA(clang warning msg) \
1947      JSON_HEDLEY_DIAGNOSTIC_POP
1948  #elif \
1949    JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
1950    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
1951    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1952  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
1953  #elif \
1954    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
1955    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1956  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
1957  #else
1958  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
1959  #endif
1960  #if defined(JSON_HEDLEY_REQUIRE)
1961      #undef JSON_HEDLEY_REQUIRE
1962  #endif
1963  #if defined(JSON_HEDLEY_REQUIRE_MSG)
1964      #undef JSON_HEDLEY_REQUIRE_MSG
1965  #endif
1966  #if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
1967  #  if JSON_HEDLEY_HAS_WARNING(&quot;-Wgcc-compat&quot;)
1968  #    define JSON_HEDLEY_REQUIRE(expr) \
1969      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1970      _Pragma(&quot;clang diagnostic ignored \&quot;-Wgcc-compat\&quot;&quot;) \
1971      __attribute__((diagnose_if(!(expr), #expr, &quot;error&quot;))) \
1972      JSON_HEDLEY_DIAGNOSTIC_POP
1973  #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
1974      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1975      _Pragma(&quot;clang diagnostic ignored \&quot;-Wgcc-compat\&quot;&quot;) \
1976      __attribute__((diagnose_if(!(expr), msg, &quot;error&quot;))) \
1977      JSON_HEDLEY_DIAGNOSTIC_POP
1978  #  else
1979  #    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, &quot;error&quot;)))
1980  #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, &quot;error&quot;)))
1981  #  endif
1982  #else
1983  #  define JSON_HEDLEY_REQUIRE(expr)
1984  #  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
1985  #endif
1986  #if defined(JSON_HEDLEY_FLAGS)
1987      #undef JSON_HEDLEY_FLAGS
1988  #endif
1989  #if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) &amp;&amp; (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING(&quot;-Wbitfield-enum-conversion&quot;))
1990      #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
1991  #else
1992      #define JSON_HEDLEY_FLAGS
1993  #endif
1994  #if defined(JSON_HEDLEY_FLAGS_CAST)
1995      #undef JSON_HEDLEY_FLAGS_CAST
1996  #endif
1997  #if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
1998  #  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
1999          JSON_HEDLEY_DIAGNOSTIC_PUSH \
2000          _Pragma(&quot;warning(disable:188)&quot;) \
2001          ((T) (expr)); \
2002          JSON_HEDLEY_DIAGNOSTIC_POP \
2003      }))
2004  #else
2005  #  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
2006  #endif
2007  #if defined(JSON_HEDLEY_EMPTY_BASES)
2008      #undef JSON_HEDLEY_EMPTY_BASES
2009  #endif
2010  #if \
2011      (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) &amp;&amp; !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \
2012      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
2013      #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
2014  #else
2015      #define JSON_HEDLEY_EMPTY_BASES
2016  #endif
2017  #if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
2018      #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
2019  #endif
2020  #if defined(__clang__)
2021      #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
2022  #else
2023      #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
2024  #endif
2025  #if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
2026      #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
2027  #endif
2028  #define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
2029  #if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
2030      #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
2031  #endif
2032  #define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)
2033  #if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
2034      #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
2035  #endif
2036  #define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)
2037  #if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
2038      #undef JSON_HEDLEY_CLANG_HAS_FEATURE
2039  #endif
2040  #define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)
2041  #if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
2042      #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
2043  #endif
2044  #define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)
2045  #if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
2046      #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
2047  #endif
2048  #define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)
2049  #if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
2050      #undef JSON_HEDLEY_CLANG_HAS_WARNING
2051  #endif
2052  #define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)
2053  #endif &amp;bsol;* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION &lt; X) */
2054  #if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
2055      #if defined(__clang__)
2056          #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) &lt; 30400
2057              #error &quot;unsupported Clang version - see https:&amp;bsol;&amp;bsol;github.com/nlohmann/json#supported-compilers&quot;
2058          #endif
2059      #elif defined(__GNUC__) &amp;&amp; !(defined(__ICC) || defined(__INTEL_COMPILER))
2060          #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) &lt; 40800
2061              #error &quot;unsupported GCC version - see https:&amp;bsol;&amp;bsol;github.com/nlohmann/json#supported-compilers&quot;
2062          #endif
2063      #endif
2064  #endif
2065  #if !defined(JSON_HAS_CPP_20) &amp;&amp; !defined(JSON_HAS_CPP_17) &amp;&amp; !defined(JSON_HAS_CPP_14) &amp;&amp; !defined(JSON_HAS_CPP_11)
2066      #if (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 202002L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 202002L)
2067          #define JSON_HAS_CPP_20
2068          #define JSON_HAS_CPP_17
2069          #define JSON_HAS_CPP_14
2070      #elif (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201703L) || (defined(_HAS_CXX17) &amp;&amp; _HAS_CXX17 == 1) 
2071          #define JSON_HAS_CPP_17
2072          #define JSON_HAS_CPP_14
2073      #elif (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201402L) || (defined(_HAS_CXX14) &amp;&amp; _HAS_CXX14 == 1)
2074          #define JSON_HAS_CPP_14
2075      #endif
2076      #define JSON_HAS_CPP_11
2077  #endif
2078  #ifdef __has_include
2079      #if __has_include(&lt;version&gt;)
2080          #include &lt;version&gt;
2081      #endif
2082  #endif
2083  #if !defined(JSON_HAS_FILESYSTEM) &amp;&amp; !defined(JSON_HAS_EXPERIMENTAL_FILESYSTEM)
2084      #ifdef JSON_HAS_CPP_17
2085          #if defined(__cpp_lib_filesystem)
2086              #define JSON_HAS_FILESYSTEM 1
2087          #elif defined(__cpp_lib_experimental_filesystem)
2088              #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
2089          #elif !defined(__has_include)
2090              #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
2091          #elif __has_include(&lt;filesystem&gt;)
2092              #define JSON_HAS_FILESYSTEM 1
2093          #elif __has_include(&lt;experimental/filesystem&gt;)
2094              #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
2095          #endif
2096          #if defined(__MINGW32__) &amp;&amp; defined(__GNUC__) &amp;&amp; __GNUC__ == 8
2097              #undef JSON_HAS_FILESYSTEM
2098              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2099          #endif
2100          #if defined(__GNUC__) &amp;&amp; !defined(__clang__) &amp;&amp; __GNUC__ &lt; 8
2101              #undef JSON_HAS_FILESYSTEM
2102              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2103          #endif
2104          #if defined(__clang_major__) &amp;&amp; __clang_major__ &lt; 7
2105              #undef JSON_HAS_FILESYSTEM
2106              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2107          #endif
2108          #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1914
2109              #undef JSON_HAS_FILESYSTEM
2110              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2111          #endif
2112          #if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 130000
2113              #undef JSON_HAS_FILESYSTEM
2114              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2115          #endif
2116          #if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &lt; 101500
2117              #undef JSON_HAS_FILESYSTEM
2118              #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2119          #endif
2120      #endif
2121  #endif
2122  #ifndef JSON_HAS_EXPERIMENTAL_FILESYSTEM
2123      #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 0
2124  #endif
2125  #ifndef JSON_HAS_FILESYSTEM
2126      #define JSON_HAS_FILESYSTEM 0
2127  #endif
2128  #ifndef JSON_HAS_THREE_WAY_COMPARISON
2129      #if defined(__cpp_impl_three_way_comparison) &amp;&amp; __cpp_impl_three_way_comparison &gt;= 201907L \
2130          &amp;&amp; defined(__cpp_lib_three_way_comparison) &amp;&amp; __cpp_lib_three_way_comparison &gt;= 201907L
2131          #define JSON_HAS_THREE_WAY_COMPARISON 1
2132      #else
2133          #define JSON_HAS_THREE_WAY_COMPARISON 0
2134      #endif
2135  #endif
2136  #ifndef JSON_HAS_RANGES
2137      #if defined(__GLIBCXX__) &amp;&amp; __GLIBCXX__ == 20210427
2138          #define JSON_HAS_RANGES 0
2139      #elif defined(__cpp_lib_ranges)
2140          #define JSON_HAS_RANGES 1
2141      #else
2142          #define JSON_HAS_RANGES 0
2143      #endif
2144  #endif
2145  #ifdef JSON_HAS_CPP_17
2146      #define JSON_INLINE_VARIABLE inline
2147  #else
2148      #define JSON_INLINE_VARIABLE
2149  #endif
2150  #if JSON_HEDLEY_HAS_ATTRIBUTE(no_unique_address)
2151      #define JSON_NO_UNIQUE_ADDRESS [[no_unique_address]]
2152  #else
2153      #define JSON_NO_UNIQUE_ADDRESS
2154  #endif
2155  #if defined(__clang__)
2156      #pragma clang diagnostic push
2157      #pragma clang diagnostic ignored &quot;-Wdocumentation&quot;
2158      #pragma clang diagnostic ignored &quot;-Wdocumentation-unknown-command&quot;
2159  #endif
2160  #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) &amp;&amp; !defined(JSON_NOEXCEPTION)
2161      #define JSON_THROW(exception) throw exception
2162      #define JSON_TRY try
2163      #define JSON_CATCH(exception) catch(exception)
2164      #define JSON_INTERNAL_CATCH(exception) catch(exception)
2165  #else
2166      #include &lt;cstdlib&gt;
2167      #define JSON_THROW(exception) std::abort()
2168      #define JSON_TRY if(true)
2169      #define JSON_CATCH(exception) if(false)
2170      #define JSON_INTERNAL_CATCH(exception) if(false)
2171  #endif
2172  #if defined(JSON_THROW_USER)
2173      #undef JSON_THROW
2174      #define JSON_THROW JSON_THROW_USER
2175  #endif
2176  #if defined(JSON_TRY_USER)
2177      #undef JSON_TRY
2178      #define JSON_TRY JSON_TRY_USER
2179  #endif
2180  #if defined(JSON_CATCH_USER)
2181      #undef JSON_CATCH
2182      #define JSON_CATCH JSON_CATCH_USER
2183      #undef JSON_INTERNAL_CATCH
2184      #define JSON_INTERNAL_CATCH JSON_CATCH_USER
2185  #endif
2186  #if defined(JSON_INTERNAL_CATCH_USER)
2187      #undef JSON_INTERNAL_CATCH
2188      #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
2189  #endif
2190  #if !defined(JSON_ASSERT)
2191      #include &lt;cassert&gt; 
2192      #define JSON_ASSERT(x) assert(x)
2193  #endif
2194  #if defined(JSON_TESTS_PRIVATE)
2195      #define JSON_PRIVATE_UNLESS_TESTED public
2196  #else
2197      #define JSON_PRIVATE_UNLESS_TESTED private
2198  #endif
2199  #define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
2200      template&lt;typename BasicJsonType&gt;                                                            \
2201      inline void to_json(BasicJsonType&amp; j, const ENUM_TYPE&amp; e)                                   \
2202      {                                                                                           \
2203          static_assert(std::is_enum&lt;ENUM_TYPE&gt;::value, #ENUM_TYPE &quot; must be an enum!&quot;);          \
2204          static const std::pair&lt;ENUM_TYPE, BasicJsonType&gt; m[] = __VA_ARGS__;                     \
2205          auto it = std::find_if(std::begin(m), std::end(m),                                      \
2206                                 [e](const std::pair&lt;ENUM_TYPE, BasicJsonType&gt;&amp; ej_pair) -&gt; bool  \
2207          {                                                                                       \
2208              return ej_pair.first == e;                                                          \
2209          });                                                                                     \
2210          j = ((it != std::end(m)) ? it : std::begin(m))-&gt;second;                                 \
2211      }                                                                                           \
2212      template&lt;typename BasicJsonType&gt;                                                            \
2213      inline void from_json(const BasicJsonType&amp; j, ENUM_TYPE&amp; e)                                 \
2214      {                                                                                           \
2215          static_assert(std::is_enum&lt;ENUM_TYPE&gt;::value, #ENUM_TYPE &quot; must be an enum!&quot;);          \
2216          static const std::pair&lt;ENUM_TYPE, BasicJsonType&gt; m[] = __VA_ARGS__;                     \
2217          auto it = std::find_if(std::begin(m), std::end(m),                                      \
2218                                 [&amp;j](const std::pair&lt;ENUM_TYPE, BasicJsonType&gt;&amp; ej_pair) -&gt; bool \
2219          {                                                                                       \
2220              return ej_pair.second == j;                                                         \
2221          });                                                                                     \
2222          e = ((it != std::end(m)) ? it : std::begin(m))-&gt;first;                                  \
2223      }
2224  #define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
2225      template&lt;template&lt;typename, typename, typename...&gt; class ObjectType,   \
2226               template&lt;typename, typename...&gt; class ArrayType,              \
2227               class StringType, class BooleanType, class NumberIntegerType, \
2228               class NumberUnsignedType, class NumberFloatType,              \
2229               template&lt;typename&gt; class AllocatorType,                       \
2230               template&lt;typename, typename = void&gt; class JSONSerializer,     \
2231               class BinaryType&gt;
2232  #define NLOHMANN_BASIC_JSON_TPL                                            \
2233      basic_json&lt;ObjectType, ArrayType, StringType, BooleanType,             \
2234      NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
2235      AllocatorType, JSONSerializer, BinaryType&gt;
2236  #define NLOHMANN_JSON_EXPAND( x ) x
2237  #define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
2238  #define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
2239          NLOHMANN_JSON_PASTE64, \
2240          NLOHMANN_JSON_PASTE63, \
2241          NLOHMANN_JSON_PASTE62, \
2242          NLOHMANN_JSON_PASTE61, \
2243          NLOHMANN_JSON_PASTE60, \
2244          NLOHMANN_JSON_PASTE59, \
2245          NLOHMANN_JSON_PASTE58, \
2246          NLOHMANN_JSON_PASTE57, \
2247          NLOHMANN_JSON_PASTE56, \
2248          NLOHMANN_JSON_PASTE55, \
2249          NLOHMANN_JSON_PASTE54, \
2250          NLOHMANN_JSON_PASTE53, \
2251          NLOHMANN_JSON_PASTE52, \
2252          NLOHMANN_JSON_PASTE51, \
2253          NLOHMANN_JSON_PASTE50, \
2254          NLOHMANN_JSON_PASTE49, \
2255          NLOHMANN_JSON_PASTE48, \
2256          NLOHMANN_JSON_PASTE47, \
2257          NLOHMANN_JSON_PASTE46, \
2258          NLOHMANN_JSON_PASTE45, \
2259          NLOHMANN_JSON_PASTE44, \
2260          NLOHMANN_JSON_PASTE43, \
2261          NLOHMANN_JSON_PASTE42, \
2262          NLOHMANN_JSON_PASTE41, \
2263          NLOHMANN_JSON_PASTE40, \
2264          NLOHMANN_JSON_PASTE39, \
2265          NLOHMANN_JSON_PASTE38, \
2266          NLOHMANN_JSON_PASTE37, \
2267          NLOHMANN_JSON_PASTE36, \
2268          NLOHMANN_JSON_PASTE35, \
2269          NLOHMANN_JSON_PASTE34, \
2270          NLOHMANN_JSON_PASTE33, \
2271          NLOHMANN_JSON_PASTE32, \
2272          NLOHMANN_JSON_PASTE31, \
2273          NLOHMANN_JSON_PASTE30, \
2274          NLOHMANN_JSON_PASTE29, \
2275          NLOHMANN_JSON_PASTE28, \
2276          NLOHMANN_JSON_PASTE27, \
2277          NLOHMANN_JSON_PASTE26, \
2278          NLOHMANN_JSON_PASTE25, \
2279          NLOHMANN_JSON_PASTE24, \
2280          NLOHMANN_JSON_PASTE23, \
2281          NLOHMANN_JSON_PASTE22, \
2282          NLOHMANN_JSON_PASTE21, \
2283          NLOHMANN_JSON_PASTE20, \
2284          NLOHMANN_JSON_PASTE19, \
2285          NLOHMANN_JSON_PASTE18, \
2286          NLOHMANN_JSON_PASTE17, \
2287          NLOHMANN_JSON_PASTE16, \
2288          NLOHMANN_JSON_PASTE15, \
2289          NLOHMANN_JSON_PASTE14, \
2290          NLOHMANN_JSON_PASTE13, \
2291          NLOHMANN_JSON_PASTE12, \
2292          NLOHMANN_JSON_PASTE11, \
2293          NLOHMANN_JSON_PASTE10, \
2294          NLOHMANN_JSON_PASTE9, \
2295          NLOHMANN_JSON_PASTE8, \
2296          NLOHMANN_JSON_PASTE7, \
2297          NLOHMANN_JSON_PASTE6, \
2298          NLOHMANN_JSON_PASTE5, \
2299          NLOHMANN_JSON_PASTE4, \
2300          NLOHMANN_JSON_PASTE3, \
2301          NLOHMANN_JSON_PASTE2, \
2302          NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
2303  #define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
2304  #define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
2305  #define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
2306  #define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
2307  #define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
2308  #define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
2309  #define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
2310  #define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
2311  #define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
2312  #define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
2313  #define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
2314  #define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
2315  #define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
2316  #define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
2317  #define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
2318  #define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
2319  #define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
2320  #define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
2321  #define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
2322  #define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
2323  #define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
2324  #define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
2325  #define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
2326  #define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
2327  #define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
2328  #define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
2329  #define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
2330  #define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
2331  #define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
2332  #define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
2333  #define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
2334  #define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
2335  #define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
2336  #define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
2337  #define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
2338  #define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
2339  #define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
2340  #define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
2341  #define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
2342  #define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
2343  #define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
2344  #define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
2345  #define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
2346  #define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
2347  #define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
2348  #define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
2349  #define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
2350  #define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
2351  #define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
2352  #define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
2353  #define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
2354  #define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
2355  #define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
2356  #define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
2357  #define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
2358  #define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
2359  #define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
2360  #define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
2361  #define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
2362  #define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
2363  #define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
2364  #define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
2365  #define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)
2366  #define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
2367  #define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);
2368  #define NLOHMANN_JSON_FROM_WITH_DEFAULT(v1) nlohmann_json_t.v1 = nlohmann_json_j.value(#v1, nlohmann_json_default_obj.v1);
2369  #define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
2370      friend void to_json(nlohmann::json&amp; nlohmann_json_j, const Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2371      friend void from_json(const nlohmann::json&amp; nlohmann_json_j, Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
2372  #define NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
2373      friend void to_json(nlohmann::json&amp; nlohmann_json_j, const Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2374      friend void from_json(const nlohmann::json&amp; nlohmann_json_j, Type&amp; nlohmann_json_t) { Type nlohmann_json_default_obj; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }
2375  #define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
2376      inline void to_json(nlohmann::json&amp; nlohmann_json_j, const Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2377      inline void from_json(const nlohmann::json&amp; nlohmann_json_j, Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
2378  #define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
2379      inline void to_json(nlohmann::json&amp; nlohmann_json_j, const Type&amp; nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2380      inline void from_json(const nlohmann::json&amp; nlohmann_json_j, Type&amp; nlohmann_json_t) { Type nlohmann_json_default_obj; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }
2381  #define NLOHMANN_CAN_CALL_STD_FUNC_IMPL(std_name)                                 \
2382      namespace detail {                                                            \
2383      using std::std_name;                                                          \
2384      \
2385      template&lt;typename... T&gt;                                                       \
2386      using result_of_##std_name = decltype(std_name(std::declval&lt;T&gt;()...));        \
2387      }                                                                             \
2388      \
2389      namespace detail2 {                                                           \
2390      struct std_name##_tag                                                         \
2391      {                                                                             \
2392      };                                                                            \
2393      \
2394      template&lt;typename... T&gt;                                                       \
2395      std_name##_tag std_name(T&amp;&amp;...);                                              \
2396      \
2397      template&lt;typename... T&gt;                                                       \
2398      using result_of_##std_name = decltype(std_name(std::declval&lt;T&gt;()...));        \
2399      \
2400      template&lt;typename... T&gt;                                                       \
2401      struct would_call_std_##std_name                                              \
2402      {                                                                             \
2403          static constexpr auto const value = ::nlohmann::detail::                  \
2404                                              is_detected_exact&lt;std_name##_tag, result_of_##std_name, T...&gt;::value; \
2405      };                                                                            \
2406      } &amp;bsol;* namespace detail2 */ \
2407      \
2408      template&lt;typename... T&gt;                                                       \
2409      struct would_call_std_##std_name : detail2::would_call_std_##std_name&lt;T...&gt;   \
2410      {                                                                             \
2411      }
2412  #ifndef JSON_USE_IMPLICIT_CONVERSIONS
2413      #define JSON_USE_IMPLICIT_CONVERSIONS 1
2414  #endif
2415  #if JSON_USE_IMPLICIT_CONVERSIONS
2416      #define JSON_EXPLICIT
2417  #else
2418      #define JSON_EXPLICIT explicit
2419  #endif
2420  #ifndef JSON_DISABLE_ENUM_SERIALIZATION
2421      #define JSON_DISABLE_ENUM_SERIALIZATION 0
2422  #endif
2423  #ifndef JSON_USE_GLOBAL_UDLS
2424      #define JSON_USE_GLOBAL_UDLS 1
2425  #endif
2426  #if JSON_HAS_THREE_WAY_COMPARISON
2427      #include &lt;compare&gt; 
2428  #endif
2429  NLOHMANN_JSON_NAMESPACE_BEGIN
2430  namespace detail
2431  {
2432  enum class value_t : std::uint8_t
2433  {
2434      null,             
2435      object,           
2436      array,            
2437      string,           
2438      boolean,          
2439      number_integer,   
2440      number_unsigned,  
2441      number_float,     
2442      binary,           
2443      discarded         
2444  };
2445  #if JSON_HAS_THREE_WAY_COMPARISON
2446      inline std::partial_ordering operator&lt;=&gt;(const value_t lhs, const value_t rhs) noexcept 
2447  #else
2448      inline bool operator&lt;(const value_t lhs, const value_t rhs) noexcept
2449  #endif
2450  {
2451      static constexpr std::array&lt;std::uint8_t, 9&gt; order = {{
2452              0 &amp;bsol;* null */, 3 &amp;bsol;* object */, 4 &amp;bsol;* array */, 5 &amp;bsol;* string */,
2453              1 &amp;bsol;* boolean */, 2 &amp;bsol;* integer */, 2 &amp;bsol;* unsigned */, 2 &amp;bsol;* float */,
2454              6 &amp;bsol;* binary */
2455          }
2456      };
2457      const auto l_index = static_cast&lt;std::size_t&gt;(lhs);
2458      const auto r_index = static_cast&lt;std::size_t&gt;(rhs);
2459  #if JSON_HAS_THREE_WAY_COMPARISON
2460      if (l_index &lt; order.size() &amp;&amp; r_index &lt; order.size())
2461      {
2462          return order[l_index] &lt;=&gt; order[r_index]; 
2463      }
2464      return std::partial_ordering::unordered;
2465  #else
2466      return l_index &lt; order.size() &amp;&amp; r_index &lt; order.size() &amp;&amp; order[l_index] &lt; order[r_index];
2467  #endif
2468  }
2469  #if JSON_HAS_THREE_WAY_COMPARISON &amp;&amp; defined(__GNUC__)
2470  inline bool operator&lt;(const value_t lhs, const value_t rhs) noexcept
2471  {
2472      return std::is_lt(lhs &lt;=&gt; rhs); 
2473  }
2474  #endif
2475  }  
2476  NLOHMANN_JSON_NAMESPACE_END
2477  NLOHMANN_JSON_NAMESPACE_BEGIN
2478  namespace detail
2479  {
2480  template&lt;typename StringType&gt;
2481  inline void replace_substring(StringType&amp; s, const StringType&amp; f,
2482                                const StringType&amp; t)
2483  {
2484      JSON_ASSERT(!f.empty());
2485      for (auto pos = s.find(f);                
2486              pos != StringType::npos;          
2487              s.replace(pos, f.size(), t),      
2488              pos = s.find(f, pos + t.size()))  
2489      {}
2490  }
2491  template&lt;typename StringType&gt;
2492  inline StringType escape(StringType s)
2493  {
2494      replace_substring(s, StringType{&quot;~&quot;}, StringType{&quot;~0&quot;});
2495      replace_substring(s, StringType{&quot;/&quot;}, StringType{&quot;~1&quot;});
2496      return s;
2497  }
2498  template&lt;typename StringType&gt;
2499  static void unescape(StringType&amp; s)
2500  {
2501      replace_substring(s, StringType{&quot;~1&quot;}, StringType{&quot;/&quot;});
2502      replace_substring(s, StringType{&quot;~0&quot;}, StringType{&quot;~&quot;});
2503  }
2504  }  
2505  NLOHMANN_JSON_NAMESPACE_END
2506  #include &lt;cstddef&gt; 
2507  NLOHMANN_JSON_NAMESPACE_BEGIN
2508  namespace detail
2509  {
2510  struct position_t
2511  {
2512      std::size_t chars_read_total = 0;
2513      std::size_t chars_read_current_line = 0;
2514      std::size_t lines_read = 0;
2515      constexpr operator size_t() const
2516      {
2517          return chars_read_total;
2518      }
2519  };
2520  }  
2521  NLOHMANN_JSON_NAMESPACE_END
2522  #include &lt;array&gt; 
2523  #include &lt;cstddef&gt; 
2524  #include &lt;type_traits&gt; 
2525  #include &lt;utility&gt; 
2526  NLOHMANN_JSON_NAMESPACE_BEGIN
2527  namespace detail
2528  {
2529  template&lt;typename T&gt;
2530  using uncvref_t = typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type;
2531  #ifdef JSON_HAS_CPP_14
2532  using std::enable_if_t;
2533  using std::index_sequence;
2534  using std::make_index_sequence;
2535  using std::index_sequence_for;
2536  #else
2537  template&lt;bool B, typename T = void&gt;
2538  using enable_if_t = typename std::enable_if&lt;B, T&gt;::type;
2539  template &lt;typename T, T... Ints&gt;
2540  struct integer_sequence
2541  {
2542      using value_type = T;
2543      static constexpr std::size_t size() noexcept
2544      {
2545          return sizeof...(Ints);
2546      }
2547  };
2548  template &lt;size_t... Ints&gt;
2549  using index_sequence = integer_sequence&lt;size_t, Ints...&gt;;
2550  namespace utility_internal
2551  {
2552  template &lt;typename Seq, size_t SeqSize, size_t Rem&gt;
2553  struct Extend;
2554  template &lt;typename T, T... Ints, size_t SeqSize&gt;
2555  struct Extend&lt;integer_sequence&lt;T, Ints...&gt;, SeqSize, 0&gt;
2556  {
2557      using type = integer_sequence &lt; T, Ints..., (Ints + SeqSize)... &gt;;
2558  };
2559  template &lt;typename T, T... Ints, size_t SeqSize&gt;
2560  struct Extend&lt;integer_sequence&lt;T, Ints...&gt;, SeqSize, 1&gt;
2561  {
2562      using type = integer_sequence &lt; T, Ints..., (Ints + SeqSize)..., 2 * SeqSize &gt;;
2563  };
2564  template &lt;typename T, size_t N&gt;
2565  struct Gen
2566  {
2567      using type =
2568          typename Extend &lt; typename Gen &lt; T, N / 2 &gt;::type, N / 2, N % 2 &gt;::type;
2569  };
2570  template &lt;typename T&gt;
2571  struct Gen&lt;T, 0&gt;
2572  {
2573      using type = integer_sequence&lt;T&gt;;
2574  };
2575  }  
2576  template &lt;typename T, T N&gt;
2577  using make_integer_sequence = typename utility_internal::Gen&lt;T, N&gt;::type;
2578  template &lt;size_t N&gt;
2579  using make_index_sequence = make_integer_sequence&lt;size_t, N&gt;;
2580  template &lt;typename... Ts&gt;
2581  using index_sequence_for = make_index_sequence&lt;sizeof...(Ts)&gt;;
2582  #endif
2583  template&lt;unsigned N&gt; struct priority_tag : priority_tag &lt; N - 1 &gt; {};
2584  template&lt;&gt; struct priority_tag&lt;0&gt; {};
2585  template&lt;typename T&gt;
2586  struct static_const
2587  {
2588      static JSON_INLINE_VARIABLE constexpr T value{};
2589  };
2590  #ifndef JSON_HAS_CPP_17
2591      template&lt;typename T&gt;
2592      constexpr T static_const&lt;T&gt;::value;
2593  #endif
2594  template&lt;typename T, typename... Args&gt;
2595  inline constexpr std::array&lt;T, sizeof...(Args)&gt; make_array(Args&amp;&amp; ... args)
2596  {
2597      return std::array&lt;T, sizeof...(Args)&gt; {{static_cast&lt;T&gt;(std::forward&lt;Args&gt;(args))...}};
2598  }
2599  }  
2600  NLOHMANN_JSON_NAMESPACE_END
2601  #include &lt;limits&gt; 
2602  #include &lt;type_traits&gt; 
2603  #include &lt;utility&gt; 
2604  #include &lt;tuple&gt; 
2605  #include &lt;iterator&gt; 
2606  NLOHMANN_JSON_NAMESPACE_BEGIN
2607  namespace detail
2608  {
2609  template&lt;typename It, typename = void&gt;
2610  struct iterator_types {};
2611  template&lt;typename It&gt;
2612  struct iterator_types &lt;
2613      It,
2614      void_t&lt;typename It::difference_type, typename It::value_type, typename It::pointer,
2615      typename It::reference, typename It::iterator_category &gt;&gt;
2616  {
2617      using difference_type = typename It::difference_type;
2618      using value_type = typename It::value_type;
2619      using pointer = typename It::pointer;
2620      using reference = typename It::reference;
2621      using iterator_category = typename It::iterator_category;
2622  };
2623  template&lt;typename T, typename = void&gt;
2624  struct iterator_traits
2625  {
2626  };
2627  template&lt;typename T&gt;
2628  struct iterator_traits &lt; T, enable_if_t &lt; !std::is_pointer&lt;T&gt;::value &gt;&gt;
2629              : iterator_types&lt;T&gt;
2630  {
2631  };
2632  template&lt;typename T&gt;
2633  struct iterator_traits&lt;T*, enable_if_t&lt;std::is_object&lt;T&gt;::value&gt;&gt;
2634  {
2635      using iterator_category = std::random_access_iterator_tag;
2636      using value_type = T;
2637      using difference_type = ptrdiff_t;
2638      using pointer = T*;
2639      using reference = T&amp;;
2640  };
2641  }  
2642  NLOHMANN_JSON_NAMESPACE_END
2643  NLOHMANN_JSON_NAMESPACE_BEGIN
2644  NLOHMANN_CAN_CALL_STD_FUNC_IMPL(begin);
2645  NLOHMANN_JSON_NAMESPACE_END
2646  NLOHMANN_JSON_NAMESPACE_BEGIN
2647  NLOHMANN_CAN_CALL_STD_FUNC_IMPL(end);
2648  NLOHMANN_JSON_NAMESPACE_END
2649  #ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
2650      #define INCLUDE_NLOHMANN_JSON_FWD_HPP_
2651      #include &lt;cstdint&gt; 
2652      #include &lt;map&gt; 
2653      #include &lt;memory&gt; 
2654      #include &lt;string&gt; 
2655      #include &lt;vector&gt; 
2656      NLOHMANN_JSON_NAMESPACE_BEGIN
2657      template&lt;typename T = void, typename SFINAE = void&gt;
2658      struct adl_serializer;
2659      template&lt;template&lt;typename U, typename V, typename... Args&gt; class ObjectType =
2660      std::map,
2661      template&lt;typename U, typename... Args&gt; class ArrayType = std::vector,
2662      class StringType = std::string, class BooleanType = bool,
2663      class NumberIntegerType = std::int64_t,
2664      class NumberUnsignedType = std::uint64_t,
2665      class NumberFloatType = double,
2666      template&lt;typename U&gt; class AllocatorType = std::allocator,
2667      template&lt;typename T, typename SFINAE = void&gt; class JSONSerializer =
2668      adl_serializer,
2669      class BinaryType = std::vector&lt;std::uint8_t&gt;&gt;
2670      class basic_json;
2671      template&lt;typename RefStringType&gt;
2672      class json_pointer;
2673      using json = basic_json&lt;&gt;;
2674      template&lt;class Key, class T, class IgnoredLess, class Allocator&gt;
2675      struct ordered_map;
2676      using ordered_json = basic_json&lt;nlohmann::ordered_map&gt;;
2677      NLOHMANN_JSON_NAMESPACE_END
2678  #endif  
2679  NLOHMANN_JSON_NAMESPACE_BEGIN
2680  namespace detail
2681  {
2682  template&lt;typename&gt; struct is_basic_json : std::false_type {};
2683  NLOHMANN_BASIC_JSON_TPL_DECLARATION
2684  struct is_basic_json&lt;NLOHMANN_BASIC_JSON_TPL&gt; : std::true_type {};
2685  template&lt;typename BasicJsonContext&gt;
2686  struct is_basic_json_context :
2687      std::integral_constant &lt; bool,
2688      is_basic_json&lt;typename std::remove_cv&lt;typename std::remove_pointer&lt;BasicJsonContext&gt;::type&gt;::type&gt;::value
2689      || std::is_same&lt;BasicJsonContext, std::nullptr_t&gt;::value &gt;
2690  {};
2691  template&lt;typename&gt;
2692  class json_ref;
2693  template&lt;typename&gt;
2694  struct is_json_ref : std::false_type {};
2695  template&lt;typename T&gt;
2696  struct is_json_ref&lt;json_ref&lt;T&gt;&gt; : std::true_type {};
2697  template&lt;typename T&gt;
2698  using mapped_type_t = typename T::mapped_type;
2699  template&lt;typename T&gt;
2700  using key_type_t = typename T::key_type;
2701  template&lt;typename T&gt;
2702  using value_type_t = typename T::value_type;
2703  template&lt;typename T&gt;
2704  using difference_type_t = typename T::difference_type;
2705  template&lt;typename T&gt;
2706  using pointer_t = typename T::pointer;
2707  template&lt;typename T&gt;
2708  using reference_t = typename T::reference;
2709  template&lt;typename T&gt;
2710  using iterator_category_t = typename T::iterator_category;
2711  template&lt;typename T, typename... Args&gt;
2712  using to_json_function = decltype(T::to_json(std::declval&lt;Args&gt;()...));
2713  template&lt;typename T, typename... Args&gt;
2714  using from_json_function = decltype(T::from_json(std::declval&lt;Args&gt;()...));
2715  template&lt;typename T, typename U&gt;
2716  using get_template_function = decltype(std::declval&lt;T&gt;().template get&lt;U&gt;());
2717  template&lt;typename BasicJsonType, typename T, typename = void&gt;
2718  struct has_from_json : std::false_type {};
2719  template &lt;typename BasicJsonType, typename T&gt;
2720  struct is_getable
2721  {
2722      static constexpr bool value = is_detected&lt;get_template_function, const BasicJsonType&amp;, T&gt;::value;
2723  };
2724  template&lt;typename BasicJsonType, typename T&gt;
2725  struct has_from_json &lt; BasicJsonType, T, enable_if_t &lt; !is_basic_json&lt;T&gt;::value &gt;&gt;
2726  {
2727      using serializer = typename BasicJsonType::template json_serializer&lt;T, void&gt;;
2728      static constexpr bool value =
2729          is_detected_exact&lt;void, from_json_function, serializer,
2730          const BasicJsonType&amp;, T&amp;&gt;::value;
2731  };
2732  template&lt;typename BasicJsonType, typename T, typename = void&gt;
2733  struct has_non_default_from_json : std::false_type {};
2734  template&lt;typename BasicJsonType, typename T&gt;
2735  struct has_non_default_from_json &lt; BasicJsonType, T, enable_if_t &lt; !is_basic_json&lt;T&gt;::value &gt;&gt;
2736  {
2737      using serializer = typename BasicJsonType::template json_serializer&lt;T, void&gt;;
2738      static constexpr bool value =
2739          is_detected_exact&lt;T, from_json_function, serializer,
2740          const BasicJsonType&amp;&gt;::value;
2741  };
2742  template&lt;typename BasicJsonType, typename T, typename = void&gt;
2743  struct has_to_json : std::false_type {};
2744  template&lt;typename BasicJsonType, typename T&gt;
2745  struct has_to_json &lt; BasicJsonType, T, enable_if_t &lt; !is_basic_json&lt;T&gt;::value &gt;&gt;
2746  {
2747      using serializer = typename BasicJsonType::template json_serializer&lt;T, void&gt;;
2748      static constexpr bool value =
2749          is_detected_exact&lt;void, to_json_function, serializer, BasicJsonType&amp;,
2750          T&gt;::value;
2751  };
2752  template&lt;typename T&gt;
2753  using detect_key_compare = typename T::key_compare;
2754  template&lt;typename T&gt;
2755  struct has_key_compare : std::integral_constant&lt;bool, is_detected&lt;detect_key_compare, T&gt;::value&gt; {};
2756  template&lt;typename BasicJsonType&gt;
2757  struct actual_object_comparator
2758  {
2759      using object_t = typename BasicJsonType::object_t;
2760      using object_comparator_t = typename BasicJsonType::default_object_comparator_t;
2761      using type = typename std::conditional &lt; has_key_compare&lt;object_t&gt;::value,
2762            typename object_t::key_compare, object_comparator_t&gt;::type;
2763  };
2764  template&lt;typename BasicJsonType&gt;
2765  using actual_object_comparator_t = typename actual_object_comparator&lt;BasicJsonType&gt;::type;
2766  template&lt;class...&gt; struct conjunction : std::true_type { };
2767  template&lt;class B&gt; struct conjunction&lt;B&gt; : B { };
2768  template&lt;class B, class... Bn&gt;
2769  struct conjunction&lt;B, Bn...&gt;
2770  : std::conditional&lt;static_cast&lt;bool&gt;(B::value), conjunction&lt;Bn...&gt;, B&gt;::type {};
2771  template&lt;class B&gt; struct negation : std::integral_constant &lt; bool, !B::value &gt; { };
2772  template &lt;typename T&gt;
2773  struct is_default_constructible : std::is_default_constructible&lt;T&gt; {};
2774  template &lt;typename T1, typename T2&gt;
2775  struct is_default_constructible&lt;std::pair&lt;T1, T2&gt;&gt;
2776              : conjunction&lt;is_default_constructible&lt;T1&gt;, is_default_constructible&lt;T2&gt;&gt; {};
2777  template &lt;typename T1, typename T2&gt;
2778  struct is_default_constructible&lt;const std::pair&lt;T1, T2&gt;&gt;
2779              : conjunction&lt;is_default_constructible&lt;T1&gt;, is_default_constructible&lt;T2&gt;&gt; {};
2780  template &lt;typename... Ts&gt;
2781  struct is_default_constructible&lt;std::tuple&lt;Ts...&gt;&gt;
2782              : conjunction&lt;is_default_constructible&lt;Ts&gt;...&gt; {};
2783  template &lt;typename... Ts&gt;
2784  struct is_default_constructible&lt;const std::tuple&lt;Ts...&gt;&gt;
2785              : conjunction&lt;is_default_constructible&lt;Ts&gt;...&gt; {};
2786  template &lt;typename T, typename... Args&gt;
2787  struct is_constructible : std::is_constructible&lt;T, Args...&gt; {};
2788  template &lt;typename T1, typename T2&gt;
2789  struct is_constructible&lt;std::pair&lt;T1, T2&gt;&gt; : is_default_constructible&lt;std::pair&lt;T1, T2&gt;&gt; {};
2790  template &lt;typename T1, typename T2&gt;
2791  struct is_constructible&lt;const std::pair&lt;T1, T2&gt;&gt; : is_default_constructible&lt;const std::pair&lt;T1, T2&gt;&gt; {};
2792  template &lt;typename... Ts&gt;
2793  struct is_constructible&lt;std::tuple&lt;Ts...&gt;&gt; : is_default_constructible&lt;std::tuple&lt;Ts...&gt;&gt; {};
2794  template &lt;typename... Ts&gt;
2795  struct is_constructible&lt;const std::tuple&lt;Ts...&gt;&gt; : is_default_constructible&lt;const std::tuple&lt;Ts...&gt;&gt; {};
2796  template&lt;typename T, typename = void&gt;
2797  struct is_iterator_traits : std::false_type {};
2798  template&lt;typename T&gt;
2799  struct is_iterator_traits&lt;iterator_traits&lt;T&gt;&gt;
2800  {
2801    private:
2802      using traits = iterator_traits&lt;T&gt;;
2803    public:
2804      static constexpr auto value =
2805          is_detected&lt;value_type_t, traits&gt;::value &amp;&amp;
2806          is_detected&lt;difference_type_t, traits&gt;::value &amp;&amp;
2807          is_detected&lt;pointer_t, traits&gt;::value &amp;&amp;
2808          is_detected&lt;iterator_category_t, traits&gt;::value &amp;&amp;
2809          is_detected&lt;reference_t, traits&gt;::value;
2810  };
2811  template&lt;typename T&gt;
2812  struct is_range
2813  {
2814    private:
2815      using t_ref = typename std::add_lvalue_reference&lt;T&gt;::type;
2816      using iterator = detected_t&lt;result_of_begin, t_ref&gt;;
2817      using sentinel = detected_t&lt;result_of_end, t_ref&gt;;
2818      static constexpr auto is_iterator_begin =
2819          is_iterator_traits&lt;iterator_traits&lt;iterator&gt;&gt;::value;
2820    public:
2821      static constexpr bool value = !std::is_same&lt;iterator, nonesuch&gt;::value &amp;&amp; !std::is_same&lt;sentinel, nonesuch&gt;::value &amp;&amp; is_iterator_begin;
2822  };
2823  template&lt;typename R&gt;
2824  using iterator_t = enable_if_t&lt;is_range&lt;R&gt;::value, result_of_begin&lt;decltype(std::declval&lt;R&amp;&gt;())&gt;&gt;;
2825  template&lt;typename T&gt;
2826  using range_value_t = value_type_t&lt;iterator_traits&lt;iterator_t&lt;T&gt;&gt;&gt;;
2827  template&lt;typename T, typename = void&gt;
2828  struct is_complete_type : std::false_type {};
2829  template&lt;typename T&gt;
2830  struct is_complete_type&lt;T, decltype(void(sizeof(T)))&gt; : std::true_type {};
2831  template&lt;typename BasicJsonType, typename CompatibleObjectType,
2832           typename = void&gt;
2833  struct is_compatible_object_type_impl : std::false_type {};
2834  template&lt;typename BasicJsonType, typename CompatibleObjectType&gt;
2835  struct is_compatible_object_type_impl &lt;
2836      BasicJsonType, CompatibleObjectType,
2837      enable_if_t &lt; is_detected&lt;mapped_type_t, CompatibleObjectType&gt;::value&amp;&amp;
2838      is_detected&lt;key_type_t, CompatibleObjectType&gt;::value &gt;&gt;
2839  {
2840      using object_t = typename BasicJsonType::object_t;
2841      static constexpr bool value =
2842          is_constructible&lt;typename object_t::key_type,
2843          typename CompatibleObjectType::key_type&gt;::value &amp;&amp;
2844          is_constructible&lt;typename object_t::mapped_type,
2845          typename CompatibleObjectType::mapped_type&gt;::value;
2846  };
2847  template&lt;typename BasicJsonType, typename CompatibleObjectType&gt;
2848  struct is_compatible_object_type
2849      : is_compatible_object_type_impl&lt;BasicJsonType, CompatibleObjectType&gt; {};
2850  template&lt;typename BasicJsonType, typename ConstructibleObjectType,
2851           typename = void&gt;
2852  struct is_constructible_object_type_impl : std::false_type {};
2853  template&lt;typename BasicJsonType, typename ConstructibleObjectType&gt;
2854  struct is_constructible_object_type_impl &lt;
2855      BasicJsonType, ConstructibleObjectType,
2856      enable_if_t &lt; is_detected&lt;mapped_type_t, ConstructibleObjectType&gt;::value&amp;&amp;
2857      is_detected&lt;key_type_t, ConstructibleObjectType&gt;::value &gt;&gt;
2858  {
2859      using object_t = typename BasicJsonType::object_t;
2860      static constexpr bool value =
2861          (is_default_constructible&lt;ConstructibleObjectType&gt;::value &amp;&amp;
2862           (std::is_move_assignable&lt;ConstructibleObjectType&gt;::value ||
2863            std::is_copy_assignable&lt;ConstructibleObjectType&gt;::value) &amp;&amp;
2864           (is_constructible&lt;typename ConstructibleObjectType::key_type,
2865            typename object_t::key_type&gt;::value &amp;&amp;
2866            std::is_same &lt;
2867            typename object_t::mapped_type,
2868            typename ConstructibleObjectType::mapped_type &gt;::value)) ||
2869          (has_from_json&lt;BasicJsonType,
2870           typename ConstructibleObjectType::mapped_type&gt;::value ||
2871           has_non_default_from_json &lt;
2872           BasicJsonType,
2873           typename ConstructibleObjectType::mapped_type &gt;::value);
2874  };
2875  template&lt;typename BasicJsonType, typename ConstructibleObjectType&gt;
2876  struct is_constructible_object_type
2877      : is_constructible_object_type_impl&lt;BasicJsonType,
2878        ConstructibleObjectType&gt; {};
2879  template&lt;typename BasicJsonType, typename CompatibleStringType&gt;
2880  struct is_compatible_string_type
2881  {
2882      static constexpr auto value =
2883          is_constructible&lt;typename BasicJsonType::string_t, CompatibleStringType&gt;::value;
2884  };
2885  template&lt;typename BasicJsonType, typename ConstructibleStringType&gt;
2886  struct is_constructible_string_type
2887  {
2888  #ifdef __INTEL_COMPILER
2889      using laundered_type = decltype(std::declval&lt;ConstructibleStringType&gt;());
2890  #else
2891      using laundered_type = ConstructibleStringType;
2892  #endif
2893      static constexpr auto value =
2894          conjunction &lt;
2895          is_constructible&lt;laundered_type, typename BasicJsonType::string_t&gt;,
2896          is_detected_exact&lt;typename BasicJsonType::string_t::value_type,
2897          value_type_t, laundered_type &gt;&gt;::value;
2898  };
2899  template&lt;typename BasicJsonType, typename CompatibleArrayType, typename = void&gt;
2900  struct is_compatible_array_type_impl : std::false_type {};
2901  template&lt;typename BasicJsonType, typename CompatibleArrayType&gt;
2902  struct is_compatible_array_type_impl &lt;
2903      BasicJsonType, CompatibleArrayType,
2904      enable_if_t &lt;
2905      is_detected&lt;iterator_t, CompatibleArrayType&gt;::value&amp;&amp;
2906      is_iterator_traits&lt;iterator_traits&lt;detected_t&lt;iterator_t, CompatibleArrayType&gt;&gt;&gt;::value&amp;&amp;
2907      !std::is_same&lt;CompatibleArrayType, detected_t&lt;range_value_t, CompatibleArrayType&gt;&gt;::value &gt;&gt;
2908  {
2909      static constexpr bool value =
2910          is_constructible&lt;BasicJsonType,
2911          range_value_t&lt;CompatibleArrayType&gt;&gt;::value;
2912  };
2913  template&lt;typename BasicJsonType, typename CompatibleArrayType&gt;
2914  struct is_compatible_array_type
2915      : is_compatible_array_type_impl&lt;BasicJsonType, CompatibleArrayType&gt; {};
2916  template&lt;typename BasicJsonType, typename ConstructibleArrayType, typename = void&gt;
2917  struct is_constructible_array_type_impl : std::false_type {};
2918  template&lt;typename BasicJsonType, typename ConstructibleArrayType&gt;
2919  struct is_constructible_array_type_impl &lt;
2920      BasicJsonType, ConstructibleArrayType,
2921      enable_if_t&lt;std::is_same&lt;ConstructibleArrayType,
2922      typename BasicJsonType::value_type&gt;::value &gt;&gt;
2923              : std::true_type {};
2924  template&lt;typename BasicJsonType, typename ConstructibleArrayType&gt;
2925  struct is_constructible_array_type_impl &lt;
2926      BasicJsonType, ConstructibleArrayType,
2927      enable_if_t &lt; !std::is_same&lt;ConstructibleArrayType,
2928      typename BasicJsonType::value_type&gt;::value&amp;&amp;
2929      !is_compatible_string_type&lt;BasicJsonType, ConstructibleArrayType&gt;::value&amp;&amp;
2930      is_default_constructible&lt;ConstructibleArrayType&gt;::value&amp;&amp;
2931  (std::is_move_assignable&lt;ConstructibleArrayType&gt;::value ||
2932   std::is_copy_assignable&lt;ConstructibleArrayType&gt;::value)&amp;&amp;
2933  is_detected&lt;iterator_t, ConstructibleArrayType&gt;::value&amp;&amp;
2934  is_iterator_traits&lt;iterator_traits&lt;detected_t&lt;iterator_t, ConstructibleArrayType&gt;&gt;&gt;::value&amp;&amp;
2935  is_detected&lt;range_value_t, ConstructibleArrayType&gt;::value&amp;&amp;
2936  !std::is_same&lt;ConstructibleArrayType, detected_t&lt;range_value_t, ConstructibleArrayType&gt;&gt;::value&amp;&amp;
2937          is_complete_type &lt;
2938          detected_t&lt;range_value_t, ConstructibleArrayType &gt;&gt;::value &gt;&gt;
2939  {
2940      using value_type = range_value_t&lt;ConstructibleArrayType&gt;;
2941      static constexpr bool value =
2942          std::is_same&lt;value_type,
2943          typename BasicJsonType::array_t::value_type&gt;::value ||
2944          has_from_json&lt;BasicJsonType,
2945          value_type&gt;::value ||
2946          has_non_default_from_json &lt;
2947          BasicJsonType,
2948          value_type &gt;::value;
2949  };
2950  template&lt;typename BasicJsonType, typename ConstructibleArrayType&gt;
2951  struct is_constructible_array_type
2952      : is_constructible_array_type_impl&lt;BasicJsonType, ConstructibleArrayType&gt; {};
2953  template&lt;typename RealIntegerType, typename CompatibleNumberIntegerType,
2954           typename = void&gt;
2955  struct is_compatible_integer_type_impl : std::false_type {};
2956  template&lt;typename RealIntegerType, typename CompatibleNumberIntegerType&gt;
2957  struct is_compatible_integer_type_impl &lt;
2958      RealIntegerType, CompatibleNumberIntegerType,
2959      enable_if_t &lt; std::is_integral&lt;RealIntegerType&gt;::value&amp;&amp;
2960      std::is_integral&lt;CompatibleNumberIntegerType&gt;::value&amp;&amp;
2961      !std::is_same&lt;bool, CompatibleNumberIntegerType&gt;::value &gt;&gt;
2962  {
2963      using RealLimits = std::numeric_limits&lt;RealIntegerType&gt;;
2964      using CompatibleLimits = std::numeric_limits&lt;CompatibleNumberIntegerType&gt;;
2965      static constexpr auto value =
2966          is_constructible&lt;RealIntegerType,
2967          CompatibleNumberIntegerType&gt;::value &amp;&amp;
2968          CompatibleLimits::is_integer &amp;&amp;
2969          RealLimits::is_signed == CompatibleLimits::is_signed;
2970  };
2971  template&lt;typename RealIntegerType, typename CompatibleNumberIntegerType&gt;
2972  struct is_compatible_integer_type
2973      : is_compatible_integer_type_impl&lt;RealIntegerType,
2974        CompatibleNumberIntegerType&gt; {};
2975  template&lt;typename BasicJsonType, typename CompatibleType, typename = void&gt;
2976  struct is_compatible_type_impl: std::false_type {};
2977  template&lt;typename BasicJsonType, typename CompatibleType&gt;
2978  struct is_compatible_type_impl &lt;
2979      BasicJsonType, CompatibleType,
2980      enable_if_t&lt;is_complete_type&lt;CompatibleType&gt;::value &gt;&gt;
2981  {
2982      static constexpr bool value =
2983          has_to_json&lt;BasicJsonType, CompatibleType&gt;::value;
2984  };
2985  template&lt;typename BasicJsonType, typename CompatibleType&gt;
2986  struct is_compatible_type
2987      : is_compatible_type_impl&lt;BasicJsonType, CompatibleType&gt; {};
2988  template&lt;typename T1, typename T2&gt;
2989  struct is_constructible_tuple : std::false_type {};
2990  template&lt;typename T1, typename... Args&gt;
2991  struct is_constructible_tuple&lt;T1, std::tuple&lt;Args...&gt;&gt; : conjunction&lt;is_constructible&lt;T1, Args&gt;...&gt; {};
2992  template&lt;typename BasicJsonType, typename T&gt;
2993  struct is_json_iterator_of : std::false_type {};
2994  template&lt;typename BasicJsonType&gt;
2995  struct is_json_iterator_of&lt;BasicJsonType, typename BasicJsonType::iterator&gt; : std::true_type {};
2996  template&lt;typename BasicJsonType&gt;
2997  struct is_json_iterator_of&lt;BasicJsonType, typename BasicJsonType::const_iterator&gt; : std::true_type
2998  {};
2999  template&lt;template &lt;typename...&gt; class Primary, typename T&gt;
3000  struct is_specialization_of : std::false_type {};
3001  template&lt;template &lt;typename...&gt; class Primary, typename... Args&gt;
3002  struct is_specialization_of&lt;Primary, Primary&lt;Args...&gt;&gt; : std::true_type {};
3003  template&lt;typename T&gt;
3004  using is_json_pointer = is_specialization_of&lt;::nlohmann::json_pointer, uncvref_t&lt;T&gt;&gt;;
3005  template&lt;typename Compare, typename A, typename B, typename = void&gt;
3006  struct is_comparable : std::false_type {};
3007  template&lt;typename Compare, typename A, typename B&gt;
3008  struct is_comparable&lt;Compare, A, B, void_t&lt;
3009  decltype(std::declval&lt;Compare&gt;()(std::declval&lt;A&gt;(), std::declval&lt;B&gt;())),
3010  decltype(std::declval&lt;Compare&gt;()(std::declval&lt;B&gt;(), std::declval&lt;A&gt;()))
3011  &gt;&gt; : std::true_type {};
3012  template&lt;typename T&gt;
3013  using detect_is_transparent = typename T::is_transparent;
3014  template&lt;typename Comparator, typename ObjectKeyType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
3015           bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t&lt;KeyTypeCVRef&gt;&gt;
3016  using is_usable_as_key_type = typename std::conditional &lt;
3017                                is_comparable&lt;Comparator, ObjectKeyType, KeyTypeCVRef&gt;::value
3018                                &amp;&amp; !(ExcludeObjectKeyType &amp;&amp; std::is_same&lt;KeyType,
3019                                     ObjectKeyType&gt;::value)
3020                                &amp;&amp; (!RequireTransparentComparator
3021                                    || is_detected &lt;detect_is_transparent, Comparator&gt;::value)
3022                                &amp;&amp; !is_json_pointer&lt;KeyType&gt;::value,
3023                                std::true_type,
3024                                std::false_type &gt;::type;
3025  template&lt;typename BasicJsonType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
3026           bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t&lt;KeyTypeCVRef&gt;&gt;
3027  using is_usable_as_basic_json_key_type = typename std::conditional &lt;
3028          is_usable_as_key_type&lt;typename BasicJsonType::object_comparator_t,
3029          typename BasicJsonType::object_t::key_type, KeyTypeCVRef,
3030          RequireTransparentComparator, ExcludeObjectKeyType&gt;::value
3031          &amp;&amp; !is_json_iterator_of&lt;BasicJsonType, KeyType&gt;::value,
3032          std::true_type,
3033          std::false_type &gt;::type;
3034  template&lt;typename ObjectType, typename KeyType&gt;
3035  using detect_erase_with_key_type = decltype(std::declval&lt;ObjectType&amp;&gt;().erase(std::declval&lt;KeyType&gt;()));
3036  template&lt;typename BasicJsonType, typename KeyType&gt;
3037  using has_erase_with_key_type = typename std::conditional &lt;
3038                                  is_detected &lt;
3039                                  detect_erase_with_key_type,
3040                                  typename BasicJsonType::object_t, KeyType &gt;::value,
3041                                  std::true_type,
3042                                  std::false_type &gt;::type;
3043  template &lt;typename T&gt;
3044  struct is_ordered_map
3045  {
3046      using one = char;
3047      struct two
3048      {
3049          char x[2]; 
3050      };
3051      template &lt;typename C&gt; static one test( decltype(&amp;C::capacity) ) ;
3052      template &lt;typename C&gt; static two test(...);
3053      enum { value = sizeof(test&lt;T&gt;(nullptr)) == sizeof(char) }; 
3054  };
3055  template &lt; typename T, typename U, enable_if_t &lt; !std::is_same&lt;T, U&gt;::value, int &gt; = 0 &gt;
3056  T conditional_static_cast(U value)
3057  {
3058      return static_cast&lt;T&gt;(value);
3059  }
3060  template&lt;typename T, typename U, enable_if_t&lt;std::is_same&lt;T, U&gt;::value, int&gt; = 0&gt;
3061  T conditional_static_cast(U value)
3062  {
3063      return value;
3064  }
3065  template&lt;typename... Types&gt;
3066  using all_integral = conjunction&lt;std::is_integral&lt;Types&gt;...&gt;;
3067  template&lt;typename... Types&gt;
3068  using all_signed = conjunction&lt;std::is_signed&lt;Types&gt;...&gt;;
3069  template&lt;typename... Types&gt;
3070  using all_unsigned = conjunction&lt;std::is_unsigned&lt;Types&gt;...&gt;;
3071  template&lt;typename... Types&gt;
3072  using same_sign = std::integral_constant &lt; bool,
3073        all_signed&lt;Types...&gt;::value || all_unsigned&lt;Types...&gt;::value &gt;;
3074  template&lt;typename OfType, typename T&gt;
3075  using never_out_of_range = std::integral_constant &lt; bool,
3076        (std::is_signed&lt;OfType&gt;::value &amp;&amp; (sizeof(T) &lt; sizeof(OfType)))
3077        || (same_sign&lt;OfType, T&gt;::value &amp;&amp; sizeof(OfType) == sizeof(T)) &gt;;
3078  template&lt;typename OfType, typename T,
3079           bool OfTypeSigned = std::is_signed&lt;OfType&gt;::value,
3080           bool TSigned = std::is_signed&lt;T&gt;::value&gt;
3081  struct value_in_range_of_impl2;
3082  template&lt;typename OfType, typename T&gt;
3083  struct value_in_range_of_impl2&lt;OfType, T, false, false&gt;
3084  {
3085      static constexpr bool test(T val)
3086      {
3087          using CommonType = typename std::common_type&lt;OfType, T&gt;::type;
3088          return static_cast&lt;CommonType&gt;(val) &lt;= static_cast&lt;CommonType&gt;((std::numeric_limits&lt;OfType&gt;::max)());
3089      }
3090  };
3091  template&lt;typename OfType, typename T&gt;
3092  struct value_in_range_of_impl2&lt;OfType, T, true, false&gt;
3093  {
3094      static constexpr bool test(T val)
3095      {
3096          using CommonType = typename std::common_type&lt;OfType, T&gt;::type;
3097          return static_cast&lt;CommonType&gt;(val) &lt;= static_cast&lt;CommonType&gt;((std::numeric_limits&lt;OfType&gt;::max)());
3098      }
3099  };
3100  template&lt;typename OfType, typename T&gt;
3101  struct value_in_range_of_impl2&lt;OfType, T, false, true&gt;
3102  {
3103      static constexpr bool test(T val)
3104      {
3105          using CommonType = typename std::common_type&lt;OfType, T&gt;::type;
3106          return val &gt;= 0 &amp;&amp; static_cast&lt;CommonType&gt;(val) &lt;= static_cast&lt;CommonType&gt;((std::numeric_limits&lt;OfType&gt;::max)());
3107      }
3108  };
3109  template&lt;typename OfType, typename T&gt;
3110  struct value_in_range_of_impl2&lt;OfType, T, true, true&gt;
3111  {
3112      static constexpr bool test(T val)
3113      {
3114          using CommonType = typename std::common_type&lt;OfType, T&gt;::type;
3115          return static_cast&lt;CommonType&gt;(val) &gt;= static_cast&lt;CommonType&gt;((std::numeric_limits&lt;OfType&gt;::min)())
3116                 &amp;&amp; static_cast&lt;CommonType&gt;(val) &lt;= static_cast&lt;CommonType&gt;((std::numeric_limits&lt;OfType&gt;::max)());
3117      }
3118  };
3119  template&lt;typename OfType, typename T,
3120           bool NeverOutOfRange = never_out_of_range&lt;OfType, T&gt;::value,
3121           typename = detail::enable_if_t&lt;all_integral&lt;OfType, T&gt;::value&gt;&gt;
3122  struct value_in_range_of_impl1;
3123  template&lt;typename OfType, typename T&gt;
3124  struct value_in_range_of_impl1&lt;OfType, T, false&gt;
3125  {
3126      static constexpr bool test(T val)
3127      {
3128          return value_in_range_of_impl2&lt;OfType, T&gt;::test(val);
3129      }
3130  };
3131  template&lt;typename OfType, typename T&gt;
3132  struct value_in_range_of_impl1&lt;OfType, T, true&gt;
3133  {
3134      static constexpr bool test(T &amp;bsol;*val*/)
3135      {
3136          return true;
3137      }
3138  };
3139  template&lt;typename OfType, typename T&gt;
3140  inline constexpr bool value_in_range_of(T val)
3141  {
3142      return value_in_range_of_impl1&lt;OfType, T&gt;::test(val);
3143  }
3144  template&lt;bool Value&gt;
3145  using bool_constant = std::integral_constant&lt;bool, Value&gt;;
3146  namespace impl
3147  {
3148  template&lt;typename T&gt;
3149  inline constexpr bool is_c_string()
3150  {
3151      using TUnExt = typename std::remove_extent&lt;T&gt;::type;
3152      using TUnCVExt = typename std::remove_cv&lt;TUnExt&gt;::type;
3153      using TUnPtr = typename std::remove_pointer&lt;T&gt;::type;
3154      using TUnCVPtr = typename std::remove_cv&lt;TUnPtr&gt;::type;
3155      return
3156          (std::is_array&lt;T&gt;::value &amp;&amp; std::is_same&lt;TUnCVExt, char&gt;::value)
3157          || (std::is_pointer&lt;T&gt;::value &amp;&amp; std::is_same&lt;TUnCVPtr, char&gt;::value);
3158  }
3159  }  
3160  template&lt;typename T&gt;
3161  struct is_c_string : bool_constant&lt;impl::is_c_string&lt;T&gt;()&gt; {};
3162  template&lt;typename T&gt;
3163  using is_c_string_uncvref = is_c_string&lt;uncvref_t&lt;T&gt;&gt;;
3164  namespace impl
3165  {
3166  template&lt;typename T&gt;
3167  inline constexpr bool is_transparent()
3168  {
3169      return is_detected&lt;detect_is_transparent, T&gt;::value;
3170  }
3171  }  
3172  template&lt;typename T&gt;
3173  struct is_transparent : bool_constant&lt;impl::is_transparent&lt;T&gt;()&gt; {};
3174  }  
3175  NLOHMANN_JSON_NAMESPACE_END
3176  #include &lt;cstring&gt; 
3177  #include &lt;string&gt; 
3178  #include &lt;utility&gt; 
3179  NLOHMANN_JSON_NAMESPACE_BEGIN
3180  namespace detail
3181  {
3182  inline std::size_t concat_length()
3183  {
3184      return 0;
3185  }
3186  template&lt;typename... Args&gt;
3187  inline std::size_t concat_length(const char* cstr, Args&amp;&amp; ... rest);
3188  template&lt;typename StringType, typename... Args&gt;
3189  inline std::size_t concat_length(const StringType&amp; str, Args&amp;&amp; ... rest);
3190  template&lt;typename... Args&gt;
3191  inline std::size_t concat_length(const char &amp;bsol;*c*/, Args&amp;&amp; ... rest)
3192  {
3193      return 1 + concat_length(std::forward&lt;Args&gt;(rest)...);
3194  }
3195  template&lt;typename... Args&gt;
3196  inline std::size_t concat_length(const char* cstr, Args&amp;&amp; ... rest)
3197  {
3198      return ::strlen(cstr) + concat_length(std::forward&lt;Args&gt;(rest)...);
3199  }
3200  template&lt;typename StringType, typename... Args&gt;
3201  inline std::size_t concat_length(const StringType&amp; str, Args&amp;&amp; ... rest)
3202  {
3203      return str.size() + concat_length(std::forward&lt;Args&gt;(rest)...);
3204  }
3205  template&lt;typename OutStringType&gt;
3206  inline void concat_into(OutStringType&amp; &amp;bsol;*out*/)
3207  {}
3208  template&lt;typename StringType, typename Arg&gt;
3209  using string_can_append = decltype(std::declval&lt;StringType&amp;&gt;().append(std::declval &lt; Arg &amp;&amp; &gt; ()));
3210  template&lt;typename StringType, typename Arg&gt;
3211  using detect_string_can_append = is_detected&lt;string_can_append, StringType, Arg&gt;;
3212  template&lt;typename StringType, typename Arg&gt;
3213  using string_can_append_op = decltype(std::declval&lt;StringType&amp;&gt;() += std::declval &lt; Arg &amp;&amp; &gt; ());
3214  template&lt;typename StringType, typename Arg&gt;
3215  using detect_string_can_append_op = is_detected&lt;string_can_append_op, StringType, Arg&gt;;
3216  template&lt;typename StringType, typename Arg&gt;
3217  using string_can_append_iter = decltype(std::declval&lt;StringType&amp;&gt;().append(std::declval&lt;const Arg&amp;&gt;().begin(), std::declval&lt;const Arg&amp;&gt;().end()));
3218  template&lt;typename StringType, typename Arg&gt;
3219  using detect_string_can_append_iter = is_detected&lt;string_can_append_iter, StringType, Arg&gt;;
3220  template&lt;typename StringType, typename Arg&gt;
3221  using string_can_append_data = decltype(std::declval&lt;StringType&amp;&gt;().append(std::declval&lt;const Arg&amp;&gt;().data(), std::declval&lt;const Arg&amp;&gt;().size()));
3222  template&lt;typename StringType, typename Arg&gt;
3223  using detect_string_can_append_data = is_detected&lt;string_can_append_data, StringType, Arg&gt;;
3224  template &lt; typename OutStringType, typename Arg, typename... Args,
3225             enable_if_t &lt; !detect_string_can_append&lt;OutStringType, Arg&gt;::value
3226                           &amp;&amp; detect_string_can_append_op&lt;OutStringType, Arg&gt;::value, int &gt; = 0 &gt;
3227  inline void concat_into(OutStringType&amp; out, Arg &amp;&amp; arg, Args &amp;&amp; ... rest);
3228  template &lt; typename OutStringType, typename Arg, typename... Args,
3229             enable_if_t &lt; !detect_string_can_append&lt;OutStringType, Arg&gt;::value
3230                           &amp;&amp; !detect_string_can_append_op&lt;OutStringType, Arg&gt;::value
3231                           &amp;&amp; detect_string_can_append_iter&lt;OutStringType, Arg&gt;::value, int &gt; = 0 &gt;
3232  inline void concat_into(OutStringType&amp; out, const Arg&amp; arg, Args &amp;&amp; ... rest);
3233  template &lt; typename OutStringType, typename Arg, typename... Args,
3234             enable_if_t &lt; !detect_string_can_append&lt;OutStringType, Arg&gt;::value
3235                           &amp;&amp; !detect_string_can_append_op&lt;OutStringType, Arg&gt;::value
3236                           &amp;&amp; !detect_string_can_append_iter&lt;OutStringType, Arg&gt;::value
3237                           &amp;&amp; detect_string_can_append_data&lt;OutStringType, Arg&gt;::value, int &gt; = 0 &gt;
3238  inline void concat_into(OutStringType&amp; out, const Arg&amp; arg, Args &amp;&amp; ... rest);
3239  template&lt;typename OutStringType, typename Arg, typename... Args,
3240           enable_if_t&lt;detect_string_can_append&lt;OutStringType, Arg&gt;::value, int&gt; = 0&gt;
3241  inline void concat_into(OutStringType&amp; out, Arg &amp;&amp; arg, Args &amp;&amp; ... rest)
3242  {
3243      out.append(std::forward&lt;Arg&gt;(arg));
3244      concat_into(out, std::forward&lt;Args&gt;(rest)...);
3245  }
3246  template &lt; typename OutStringType, typename Arg, typename... Args,
3247             enable_if_t &lt; !detect_string_can_append&lt;OutStringType, Arg&gt;::value
3248                           &amp;&amp; detect_string_can_append_op&lt;OutStringType, Arg&gt;::value, int &gt; &gt;
3249  inline void concat_into(OutStringType&amp; out, Arg&amp;&amp; arg, Args&amp;&amp; ... rest)
3250  {
3251      out += std::forward&lt;Arg&gt;(arg);
3252      concat_into(out, std::forward&lt;Args&gt;(rest)...);
3253  }
3254  template &lt; typename OutStringType, typename Arg, typename... Args,
3255             enable_if_t &lt; !detect_string_can_append&lt;OutStringType, Arg&gt;::value
3256                           &amp;&amp; !detect_string_can_append_op&lt;OutStringType, Arg&gt;::value
3257                           &amp;&amp; detect_string_can_append_iter&lt;OutStringType, Arg&gt;::value, int &gt; &gt;
3258  inline void concat_into(OutStringType&amp; out, const Arg&amp; arg, Args&amp;&amp; ... rest)
3259  {
3260      out.append(arg.begin(), arg.end());
3261      concat_into(out, std::forward&lt;Args&gt;(rest)...);
3262  }
3263  template &lt; typename OutStringType, typename Arg, typename... Args,
3264             enable_if_t &lt; !detect_string_can_append&lt;OutStringType, Arg&gt;::value
3265                           &amp;&amp; !detect_string_can_append_op&lt;OutStringType, Arg&gt;::value
3266                           &amp;&amp; !detect_string_can_append_iter&lt;OutStringType, Arg&gt;::value
3267                           &amp;&amp; detect_string_can_append_data&lt;OutStringType, Arg&gt;::value, int &gt; &gt;
3268  inline void concat_into(OutStringType&amp; out, const Arg&amp; arg, Args&amp;&amp; ... rest)
3269  {
3270      out.append(arg.data(), arg.size());
3271      concat_into(out, std::forward&lt;Args&gt;(rest)...);
3272  }
3273  template&lt;typename OutStringType = std::string, typename... Args&gt;
3274  inline OutStringType concat(Args &amp;&amp; ... args)
3275  {
3276      OutStringType str;
3277      str.reserve(concat_length(std::forward&lt;Args&gt;(args)...));
3278      concat_into(str, std::forward&lt;Args&gt;(args)...);
3279      return str;
3280  }
3281  }  
3282  NLOHMANN_JSON_NAMESPACE_END
3283  NLOHMANN_JSON_NAMESPACE_BEGIN
3284  namespace detail
3285  {
3286  class exception : public std::exception
3287  {
3288    public:
3289      const char* what() const noexcept override
3290      {
3291          return m.what();
3292      }
3293      const int id; 
3294    protected:
3295      JSON_HEDLEY_NON_NULL(3)
3296      exception(int id_, const char* what_arg) : id(id_), m(what_arg) {} 
3297      static std::string name(const std::string&amp; ename, int id_)
3298      {
3299          return concat(&quot;[json.exception.&quot;, ename, &#x27;.&#x27;, std::to_string(id_), &quot;] &quot;);
3300      }
3301      static std::string diagnostics(std::nullptr_t &amp;bsol;*leaf_element*/)
3302      {
3303          return &quot;&quot;;
3304      }
3305      template&lt;typename BasicJsonType&gt;
3306      static std::string diagnostics(const BasicJsonType* leaf_element)
3307      {
3308  #if JSON_DIAGNOSTICS
3309          std::vector&lt;std::string&gt; tokens;
3310          for (const auto* current = leaf_element; current != nullptr &amp;&amp; current-&gt;m_parent != nullptr; current = current-&gt;m_parent)
3311          {
3312              switch (current-&gt;m_parent-&gt;type())
3313              {
3314                  case value_t::array:
3315                  {
3316                      for (std::size_t i = 0; i &lt; current-&gt;m_parent-&gt;m_value.array-&gt;size(); ++i)
3317                      {
3318                          if (&amp;current-&gt;m_parent-&gt;m_value.array-&gt;operator[](i) == current)
3319                          {
3320                              tokens.emplace_back(std::to_string(i));
3321                              break;
3322                          }
3323                      }
3324                      break;
3325                  }
3326                  case value_t::object:
3327                  {
3328                      for (const auto&amp; element : *current-&gt;m_parent-&gt;m_value.object)
3329                      {
3330                          if (&amp;element.second == current)
3331                          {
3332                              tokens.emplace_back(element.first.c_str());
3333                              break;
3334                          }
3335                      }
3336                      break;
3337                  }
3338                  case value_t::null: 
3339                  case value_t::string: 
3340                  case value_t::boolean: 
3341                  case value_t::number_integer: 
3342                  case value_t::number_unsigned: 
3343                  case value_t::number_float: 
3344                  case value_t::binary: 
3345                  case value_t::discarded: 
3346                  default:   
3347                      break; 
3348              }
3349          }
3350          if (tokens.empty())
3351          {
3352              return &quot;&quot;;
3353          }
3354          auto str = std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},
3355                                     [](const std::string &amp; a, const std::string &amp; b)
3356          {
3357              return concat(a, &#x27;/&#x27;, detail::escape(b));
3358          });
3359          return concat(&#x27;(&#x27;, str, &quot;) &quot;);
3360  #else
3361          static_cast&lt;void&gt;(leaf_element);
3362          return &quot;&quot;;
3363  #endif
3364      }
3365    private:
3366      std::runtime_error m;
3367  };
3368  class parse_error : public exception
3369  {
3370    public:
3371      template&lt;typename BasicJsonContext, enable_if_t&lt;is_basic_json_context&lt;BasicJsonContext&gt;::value, int&gt; = 0&gt;
3372      static parse_error create(int id_, const position_t&amp; pos, const std::string&amp; what_arg, BasicJsonContext context)
3373      {
3374          std::string w = concat(exception::name(&quot;parse_error&quot;, id_), &quot;parse error&quot;,
3375                                 position_string(pos), &quot;: &quot;, exception::diagnostics(context), what_arg);
3376          return {id_, pos.chars_read_total, w.c_str()};
3377      }
3378      template&lt;typename BasicJsonContext, enable_if_t&lt;is_basic_json_context&lt;BasicJsonContext&gt;::value, int&gt; = 0&gt;
3379      static parse_error create(int id_, std::size_t byte_, const std::string&amp; what_arg, BasicJsonContext context)
3380      {
3381          std::string w = concat(exception::name(&quot;parse_error&quot;, id_), &quot;parse error&quot;,
3382                                 (byte_ != 0 ? (concat(&quot; at byte &quot;, std::to_string(byte_))) : &quot;&quot;),
3383                                 &quot;: &quot;, exception::diagnostics(context), what_arg);
3384          return {id_, byte_, w.c_str()};
3385      }
3386      const std::size_t byte;
3387    private:
3388      parse_error(int id_, std::size_t byte_, const char* what_arg)
3389          : exception(id_, what_arg), byte(byte_) {}
3390      static std::string position_string(const position_t&amp; pos)
3391      {
3392          return concat(&quot; at line &quot;, std::to_string(pos.lines_read + 1),
3393                        &quot;, column &quot;, std::to_string(pos.chars_read_current_line));
3394      }
3395  };
3396  class invalid_iterator : public exception
3397  {
3398    public:
3399      template&lt;typename BasicJsonContext, enable_if_t&lt;is_basic_json_context&lt;BasicJsonContext&gt;::value, int&gt; = 0&gt;
3400      static invalid_iterator create(int id_, const std::string&amp; what_arg, BasicJsonContext context)
3401      {
3402          std::string w = concat(exception::name(&quot;invalid_iterator&quot;, id_), exception::diagnostics(context), what_arg);
3403          return {id_, w.c_str()};
3404      }
3405    private:
3406      JSON_HEDLEY_NON_NULL(3)
3407      invalid_iterator(int id_, const char* what_arg)
3408          : exception(id_, what_arg) {}
3409  };
3410  class type_error : public exception
3411  {
3412    public:
3413      template&lt;typename BasicJsonContext, enable_if_t&lt;is_basic_json_context&lt;BasicJsonContext&gt;::value, int&gt; = 0&gt;
3414      static type_error create(int id_, const std::string&amp; what_arg, BasicJsonContext context)
3415      {
3416          std::string w = concat(exception::name(&quot;type_error&quot;, id_), exception::diagnostics(context), what_arg);
3417          return {id_, w.c_str()};
3418      }
3419    private:
3420      JSON_HEDLEY_NON_NULL(3)
3421      type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
3422  };
3423  class out_of_range : public exception
3424  {
3425    public:
3426      template&lt;typename BasicJsonContext, enable_if_t&lt;is_basic_json_context&lt;BasicJsonContext&gt;::value, int&gt; = 0&gt;
3427      static out_of_range create(int id_, const std::string&amp; what_arg, BasicJsonContext context)
3428      {
3429          std::string w = concat(exception::name(&quot;out_of_range&quot;, id_), exception::diagnostics(context), what_arg);
3430          return {id_, w.c_str()};
3431      }
3432    private:
3433      JSON_HEDLEY_NON_NULL(3)
3434      out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
3435  };
3436  class other_error : public exception
3437  {
3438    public:
3439      template&lt;typename BasicJsonContext, enable_if_t&lt;is_basic_json_context&lt;BasicJsonContext&gt;::value, int&gt; = 0&gt;
3440      static other_error create(int id_, const std::string&amp; what_arg, BasicJsonContext context)
3441      {
3442          std::string w = concat(exception::name(&quot;other_error&quot;, id_), exception::diagnostics(context), what_arg);
3443          return {id_, w.c_str()};
3444      }
3445    private:
3446      JSON_HEDLEY_NON_NULL(3)
3447      other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
3448  };
3449  }  
3450  NLOHMANN_JSON_NAMESPACE_END
3451  NLOHMANN_JSON_NAMESPACE_BEGIN
3452  namespace detail
3453  {
3454  template &lt;class T&gt; struct identity_tag {};
3455  }  
3456  NLOHMANN_JSON_NAMESPACE_END
3457  #if JSON_HAS_EXPERIMENTAL_FILESYSTEM
3458  #include &lt;experimental/filesystem&gt;
3459  NLOHMANN_JSON_NAMESPACE_BEGIN
3460  namespace detail
3461  {
3462  namespace std_fs = std::experimental::filesystem;
3463  }  
3464  NLOHMANN_JSON_NAMESPACE_END
3465  #elif JSON_HAS_FILESYSTEM
3466  #include &lt;filesystem&gt;
3467  NLOHMANN_JSON_NAMESPACE_BEGIN
3468  namespace detail
3469  {
3470  namespace std_fs = std::filesystem;
3471  }  
3472  NLOHMANN_JSON_NAMESPACE_END
3473  #endif
3474  NLOHMANN_JSON_NAMESPACE_BEGIN
3475  namespace detail
3476  {
3477  template&lt;typename BasicJsonType&gt;
3478  inline void from_json(const BasicJsonType&amp; j, typename std::nullptr_t&amp; n)
3479  {
3480      if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
3481      {
3482          JSON_THROW(type_error::create(302, concat(&quot;type must be null, but is &quot;, j.type_name()), &amp;j));
3483      }
3484      n = nullptr;
3485  }
3486  template &lt; typename BasicJsonType, typename ArithmeticType,
3487             enable_if_t &lt; std::is_arithmetic&lt;ArithmeticType&gt;::value&amp;&amp;
3488                           !std::is_same&lt;ArithmeticType, typename BasicJsonType::boolean_t&gt;::value,
3489                           int &gt; = 0 &gt;
3490  void get_arithmetic_value(const BasicJsonType&amp; j, ArithmeticType&amp; val)
3491  {
3492      switch (static_cast&lt;value_t&gt;(j))
3493      {
3494          case value_t::number_unsigned:
3495          {
3496              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_unsigned_t*&gt;());
3497              break;
3498          }
3499          case value_t::number_integer:
3500          {
3501              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_integer_t*&gt;());
3502              break;
3503          }
3504          case value_t::number_float:
3505          {
3506              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_float_t*&gt;());
3507              break;
3508          }
3509          case value_t::null:
3510          case value_t::object:
3511          case value_t::array:
3512          case value_t::string:
3513          case value_t::boolean:
3514          case value_t::binary:
3515          case value_t::discarded:
3516          default:
3517              JSON_THROW(type_error::create(302, concat(&quot;type must be number, but is &quot;, j.type_name()), &amp;j));
3518      }
3519  }
3520  template&lt;typename BasicJsonType&gt;
3521  inline void from_json(const BasicJsonType&amp; j, typename BasicJsonType::boolean_t&amp; b)
3522  {
3523      if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
3524      {
3525          JSON_THROW(type_error::create(302, concat(&quot;type must be boolean, but is &quot;, j.type_name()), &amp;j));
3526      }
3527      b = *j.template get_ptr&lt;const typename BasicJsonType::boolean_t*&gt;();
3528  }
3529  template&lt;typename BasicJsonType&gt;
3530  inline void from_json(const BasicJsonType&amp; j, typename BasicJsonType::string_t&amp; s)
3531  {
3532      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3533      {
3534          JSON_THROW(type_error::create(302, concat(&quot;type must be string, but is &quot;, j.type_name()), &amp;j));
3535      }
3536      s = *j.template get_ptr&lt;const typename BasicJsonType::string_t*&gt;();
3537  }
3538  template &lt;
3539      typename BasicJsonType, typename StringType,
3540      enable_if_t &lt;
3541          std::is_assignable&lt;StringType&amp;, const typename BasicJsonType::string_t&gt;::value
3542          &amp;&amp; is_detected_exact&lt;typename BasicJsonType::string_t::value_type, value_type_t, StringType&gt;::value
3543          &amp;&amp; !std::is_same&lt;typename BasicJsonType::string_t, StringType&gt;::value
3544          &amp;&amp; !is_json_ref&lt;StringType&gt;::value, int &gt; = 0 &gt;
3545  inline void from_json(const BasicJsonType&amp; j, StringType&amp; s)
3546  {
3547      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3548      {
3549          JSON_THROW(type_error::create(302, concat(&quot;type must be string, but is &quot;, j.type_name()), &amp;j));
3550      }
3551      s = *j.template get_ptr&lt;const typename BasicJsonType::string_t*&gt;();
3552  }
3553  template&lt;typename BasicJsonType&gt;
3554  inline void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_float_t&amp; val)
3555  {
3556      get_arithmetic_value(j, val);
3557  }
3558  template&lt;typename BasicJsonType&gt;
3559  inline void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_unsigned_t&amp; val)
3560  {
3561      get_arithmetic_value(j, val);
3562  }
3563  template&lt;typename BasicJsonType&gt;
3564  inline void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_integer_t&amp; val)
3565  {
3566      get_arithmetic_value(j, val);
3567  }
3568  #if !JSON_DISABLE_ENUM_SERIALIZATION
3569  template&lt;typename BasicJsonType, typename EnumType,
3570           enable_if_t&lt;std::is_enum&lt;EnumType&gt;::value, int&gt; = 0&gt;
3571  inline void from_json(const BasicJsonType&amp; j, EnumType&amp; e)
3572  {
3573      typename std::underlying_type&lt;EnumType&gt;::type val;
3574      get_arithmetic_value(j, val);
3575      e = static_cast&lt;EnumType&gt;(val);
3576  }
3577  #endif  
3578  template&lt;typename BasicJsonType, typename T, typename Allocator,
3579           enable_if_t&lt;is_getable&lt;BasicJsonType, T&gt;::value, int&gt; = 0&gt;
3580  inline void from_json(const BasicJsonType&amp; j, std::forward_list&lt;T, Allocator&gt;&amp; l)
3581  {
3582      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3583      {
3584          JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, j.type_name()), &amp;j));
3585      }
3586      l.clear();
3587      std::transform(j.rbegin(), j.rend(),
3588                     std::front_inserter(l), [](const BasicJsonType &amp; i)
3589      {
3590          return i.template get&lt;T&gt;();
3591      });
3592  }
3593  template&lt;typename BasicJsonType, typename T,
3594           enable_if_t&lt;is_getable&lt;BasicJsonType, T&gt;::value, int&gt; = 0&gt;
3595  inline void from_json(const BasicJsonType&amp; j, std::valarray&lt;T&gt;&amp; l)
3596  {
3597      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3598      {
3599          JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, j.type_name()), &amp;j));
3600      }
3601      l.resize(j.size());
3602      std::transform(j.begin(), j.end(), std::begin(l),
3603                     [](const BasicJsonType &amp; elem)
3604      {
3605          return elem.template get&lt;T&gt;();
3606      });
3607  }
3608  template&lt;typename BasicJsonType, typename T, std::size_t N&gt;
3609  auto from_json(const BasicJsonType&amp; j, T (&amp;arr)[N])  
3610  -&gt; decltype(j.template get&lt;T&gt;(), void())
3611  {
3612      for (std::size_t i = 0; i &lt; N; ++i)
3613      {
3614          arr[i] = j.at(i).template get&lt;T&gt;();
3615      }
3616  }
3617  template&lt;typename BasicJsonType&gt;
3618  inline void from_json_array_impl(const BasicJsonType&amp; j, typename BasicJsonType::array_t&amp; arr, priority_tag&lt;3&gt; &amp;bsol;*unused*/)
3619  {
3620      arr = *j.template get_ptr&lt;const typename BasicJsonType::array_t*&gt;();
3621  }
3622  template&lt;typename BasicJsonType, typename T, std::size_t N&gt;
3623  auto from_json_array_impl(const BasicJsonType&amp; j, std::array&lt;T, N&gt;&amp; arr,
3624                            priority_tag&lt;2&gt; &amp;bsol;*unused*/)
3625  -&gt; decltype(j.template get&lt;T&gt;(), void())
3626  {
3627      for (std::size_t i = 0; i &lt; N; ++i)
3628      {
3629          arr[i] = j.at(i).template get&lt;T&gt;();
3630      }
3631  }
3632  template&lt;typename BasicJsonType, typename ConstructibleArrayType,
3633           enable_if_t&lt;
3634               std::is_assignable&lt;ConstructibleArrayType&amp;, ConstructibleArrayType&gt;::value,
3635               int&gt; = 0&gt;
3636  auto from_json_array_impl(const BasicJsonType&amp; j, ConstructibleArrayType&amp; arr, priority_tag&lt;1&gt; &amp;bsol;*unused*/)
3637  -&gt; decltype(
3638      arr.reserve(std::declval&lt;typename ConstructibleArrayType::size_type&gt;()),
3639      j.template get&lt;typename ConstructibleArrayType::value_type&gt;(),
3640      void())
3641  {
3642      using std::end;
3643      ConstructibleArrayType ret;
3644      ret.reserve(j.size());
3645      std::transform(j.begin(), j.end(),
3646                     std::inserter(ret, end(ret)), [](const BasicJsonType &amp; i)
3647      {
3648          return i.template get&lt;typename ConstructibleArrayType::value_type&gt;();
3649      });
3650      arr = std::move(ret);
3651  }
3652  template&lt;typename BasicJsonType, typename ConstructibleArrayType,
3653           enable_if_t&lt;
3654               std::is_assignable&lt;ConstructibleArrayType&amp;, ConstructibleArrayType&gt;::value,
3655               int&gt; = 0&gt;
3656  inline void from_json_array_impl(const BasicJsonType&amp; j, ConstructibleArrayType&amp; arr,
3657                                   priority_tag&lt;0&gt; &amp;bsol;*unused*/)
3658  {
3659      using std::end;
3660      ConstructibleArrayType ret;
3661      std::transform(
3662          j.begin(), j.end(), std::inserter(ret, end(ret)),
3663          [](const BasicJsonType &amp; i)
3664      {
3665          return i.template get&lt;typename ConstructibleArrayType::value_type&gt;();
3666      });
3667      arr = std::move(ret);
3668  }
3669  template &lt; typename BasicJsonType, typename ConstructibleArrayType,
3670             enable_if_t &lt;
3671                 is_constructible_array_type&lt;BasicJsonType, ConstructibleArrayType&gt;::value&amp;&amp;
3672                 !is_constructible_object_type&lt;BasicJsonType, ConstructibleArrayType&gt;::value&amp;&amp;
3673                 !is_constructible_string_type&lt;BasicJsonType, ConstructibleArrayType&gt;::value&amp;&amp;
3674                 !std::is_same&lt;ConstructibleArrayType, typename BasicJsonType::binary_t&gt;::value&amp;&amp;
3675                 !is_basic_json&lt;ConstructibleArrayType&gt;::value,
3676                 int &gt; = 0 &gt;
3677  auto from_json(const BasicJsonType&amp; j, ConstructibleArrayType&amp; arr)
3678  -&gt; decltype(from_json_array_impl(j, arr, priority_tag&lt;3&gt; {}),
3679  j.template get&lt;typename ConstructibleArrayType::value_type&gt;(),
3680  void())
3681  {
3682      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3683      {
3684          JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, j.type_name()), &amp;j));
3685      }
3686      from_json_array_impl(j, arr, priority_tag&lt;3&gt; {});
3687  }
3688  template &lt; typename BasicJsonType, typename T, std::size_t... Idx &gt;
3689  std::array&lt;T, sizeof...(Idx)&gt; from_json_inplace_array_impl(BasicJsonType&amp;&amp; j,
3690          identity_tag&lt;std::array&lt;T, sizeof...(Idx)&gt;&gt; &amp;bsol;*unused*/, index_sequence&lt;Idx...&gt; &amp;bsol;*unused*/)
3691  {
3692      return { { std::forward&lt;BasicJsonType&gt;(j).at(Idx).template get&lt;T&gt;()... } };
3693  }
3694  template &lt; typename BasicJsonType, typename T, std::size_t N &gt;
3695  auto from_json(BasicJsonType&amp;&amp; j, identity_tag&lt;std::array&lt;T, N&gt;&gt; tag)
3696  -&gt; decltype(from_json_inplace_array_impl(std::forward&lt;BasicJsonType&gt;(j), tag, make_index_sequence&lt;N&gt; {}))
3697  {
3698      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3699      {
3700          JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, j.type_name()), &amp;j));
3701      }
3702      return from_json_inplace_array_impl(std::forward&lt;BasicJsonType&gt;(j), tag, make_index_sequence&lt;N&gt; {});
3703  }
3704  template&lt;typename BasicJsonType&gt;
3705  inline void from_json(const BasicJsonType&amp; j, typename BasicJsonType::binary_t&amp; bin)
3706  {
3707      if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
3708      {
3709          JSON_THROW(type_error::create(302, concat(&quot;type must be binary, but is &quot;, j.type_name()), &amp;j));
3710      }
3711      bin = *j.template get_ptr&lt;const typename BasicJsonType::binary_t*&gt;();
3712  }
3713  template&lt;typename BasicJsonType, typename ConstructibleObjectType,
3714           enable_if_t&lt;is_constructible_object_type&lt;BasicJsonType, ConstructibleObjectType&gt;::value, int&gt; = 0&gt;
3715  inline void from_json(const BasicJsonType&amp; j, ConstructibleObjectType&amp; obj)
3716  {
3717      if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
3718      {
3719          JSON_THROW(type_error::create(302, concat(&quot;type must be object, but is &quot;, j.type_name()), &amp;j));
3720      }
3721      ConstructibleObjectType ret;
3722      const auto* inner_object = j.template get_ptr&lt;const typename BasicJsonType::object_t*&gt;();
3723      using value_type = typename ConstructibleObjectType::value_type;
3724      std::transform(
3725          inner_object-&gt;begin(), inner_object-&gt;end(),
3726          std::inserter(ret, ret.begin()),
3727          [](typename BasicJsonType::object_t::value_type const &amp; p)
3728      {
3729          return value_type(p.first, p.second.template get&lt;typename ConstructibleObjectType::mapped_type&gt;());
3730      });
3731      obj = std::move(ret);
3732  }
3733  template &lt; typename BasicJsonType, typename ArithmeticType,
3734             enable_if_t &lt;
3735                 std::is_arithmetic&lt;ArithmeticType&gt;::value&amp;&amp;
3736                 !std::is_same&lt;ArithmeticType, typename BasicJsonType::number_unsigned_t&gt;::value&amp;&amp;
3737                 !std::is_same&lt;ArithmeticType, typename BasicJsonType::number_integer_t&gt;::value&amp;&amp;
3738                 !std::is_same&lt;ArithmeticType, typename BasicJsonType::number_float_t&gt;::value&amp;&amp;
3739                 !std::is_same&lt;ArithmeticType, typename BasicJsonType::boolean_t&gt;::value,
3740                 int &gt; = 0 &gt;
3741  inline void from_json(const BasicJsonType&amp; j, ArithmeticType&amp; val)
3742  {
3743      switch (static_cast&lt;value_t&gt;(j))
3744      {
3745          case value_t::number_unsigned:
3746          {
3747              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_unsigned_t*&gt;());
3748              break;
3749          }
3750          case value_t::number_integer:
3751          {
3752              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_integer_t*&gt;());
3753              break;
3754          }
3755          case value_t::number_float:
3756          {
3757              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_float_t*&gt;());
3758              break;
3759          }
3760          case value_t::boolean:
3761          {
3762              val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::boolean_t*&gt;());
3763              break;
3764          }
3765          case value_t::null:
3766          case value_t::object:
3767          case value_t::array:
3768          case value_t::string:
3769          case value_t::binary:
3770          case value_t::discarded:
3771          default:
3772              JSON_THROW(type_error::create(302, concat(&quot;type must be number, but is &quot;, j.type_name()), &amp;j));
3773      }
3774  }
3775  template&lt;typename BasicJsonType, typename... Args, std::size_t... Idx&gt;
3776  std::tuple&lt;Args...&gt; from_json_tuple_impl_base(BasicJsonType&amp;&amp; j, index_sequence&lt;Idx...&gt; &amp;bsol;*unused*/)
3777  {
3778      return std::make_tuple(std::forward&lt;BasicJsonType&gt;(j).at(Idx).template get&lt;Args&gt;()...);
3779  }
3780  template &lt; typename BasicJsonType, class A1, class A2 &gt;
3781  std::pair&lt;A1, A2&gt; from_json_tuple_impl(BasicJsonType&amp;&amp; j, identity_tag&lt;std::pair&lt;A1, A2&gt;&gt; &amp;bsol;*unused*/, priority_tag&lt;0&gt; &amp;bsol;*unused*/)
3782  {
3783      return {std::forward&lt;BasicJsonType&gt;(j).at(0).template get&lt;A1&gt;(),
3784              std::forward&lt;BasicJsonType&gt;(j).at(1).template get&lt;A2&gt;()};
3785  }
3786  template&lt;typename BasicJsonType, typename A1, typename A2&gt;
3787  inline void from_json_tuple_impl(BasicJsonType&amp;&amp; j, std::pair&lt;A1, A2&gt;&amp; p, priority_tag&lt;1&gt; &amp;bsol;*unused*/)
3788  {
3789      p = from_json_tuple_impl(std::forward&lt;BasicJsonType&gt;(j), identity_tag&lt;std::pair&lt;A1, A2&gt;&gt; {}, priority_tag&lt;0&gt; {});
3790  }
3791  template&lt;typename BasicJsonType, typename... Args&gt;
3792  std::tuple&lt;Args...&gt; from_json_tuple_impl(BasicJsonType&amp;&amp; j, identity_tag&lt;std::tuple&lt;Args...&gt;&gt; &amp;bsol;*unused*/, priority_tag&lt;2&gt; &amp;bsol;*unused*/)
3793  {
3794      return from_json_tuple_impl_base&lt;BasicJsonType, Args...&gt;(std::forward&lt;BasicJsonType&gt;(j), index_sequence_for&lt;Args...&gt; {});
3795  }
3796  template&lt;typename BasicJsonType, typename... Args&gt;
3797  inline void from_json_tuple_impl(BasicJsonType&amp;&amp; j, std::tuple&lt;Args...&gt;&amp; t, priority_tag&lt;3&gt; &amp;bsol;*unused*/)
3798  {
3799      t = from_json_tuple_impl_base&lt;BasicJsonType, Args...&gt;(std::forward&lt;BasicJsonType&gt;(j), index_sequence_for&lt;Args...&gt; {});
3800  }
3801  template&lt;typename BasicJsonType, typename TupleRelated&gt;
3802  auto from_json(BasicJsonType&amp;&amp; j, TupleRelated&amp;&amp; t)
3803  -&gt; decltype(from_json_tuple_impl(std::forward&lt;BasicJsonType&gt;(j), std::forward&lt;TupleRelated&gt;(t), priority_tag&lt;3&gt; {}))
3804  {
3805      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3806      {
3807          JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, j.type_name()), &amp;j));
3808      }
3809      return from_json_tuple_impl(std::forward&lt;BasicJsonType&gt;(j), std::forward&lt;TupleRelated&gt;(t), priority_tag&lt;3&gt; {});
3810  }
3811  template &lt; typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
3812             typename = enable_if_t &lt; !std::is_constructible &lt;
3813                                          typename BasicJsonType::string_t, Key &gt;::value &gt;&gt;
3814  inline void from_json(const BasicJsonType&amp; j, std::map&lt;Key, Value, Compare, Allocator&gt;&amp; m)
3815  {
3816      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3817      {
3818          JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, j.type_name()), &amp;j));
3819      }
3820      m.clear();
3821      for (const auto&amp; p : j)
3822      {
3823          if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
3824          {
3825              JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, p.type_name()), &amp;j));
3826          }
3827          m.emplace(p.at(0).template get&lt;Key&gt;(), p.at(1).template get&lt;Value&gt;());
3828      }
3829  }
3830  template &lt; typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
3831             typename = enable_if_t &lt; !std::is_constructible &lt;
3832                                          typename BasicJsonType::string_t, Key &gt;::value &gt;&gt;
3833  inline void from_json(const BasicJsonType&amp; j, std::unordered_map&lt;Key, Value, Hash, KeyEqual, Allocator&gt;&amp; m)
3834  {
3835      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3836      {
3837          JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, j.type_name()), &amp;j));
3838      }
3839      m.clear();
3840      for (const auto&amp; p : j)
3841      {
3842          if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
3843          {
3844              JSON_THROW(type_error::create(302, concat(&quot;type must be array, but is &quot;, p.type_name()), &amp;j));
3845          }
3846          m.emplace(p.at(0).template get&lt;Key&gt;(), p.at(1).template get&lt;Value&gt;());
3847      }
3848  }
3849  #if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
3850  template&lt;typename BasicJsonType&gt;
3851  inline void from_json(const BasicJsonType&amp; j, std_fs::path&amp; p)
3852  {
3853      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3854      {
3855          JSON_THROW(type_error::create(302, concat(&quot;type must be string, but is &quot;, j.type_name()), &amp;j));
3856      }
3857      p = *j.template get_ptr&lt;const typename BasicJsonType::string_t*&gt;();
3858  }
3859  #endif
3860  struct from_json_fn
3861  {
3862      template&lt;typename BasicJsonType, typename T&gt;
3863      auto operator()(const BasicJsonType&amp; j, T&amp;&amp; val) const
3864      noexcept(noexcept(from_json(j, std::forward&lt;T&gt;(val))))
3865      -&gt; decltype(from_json(j, std::forward&lt;T&gt;(val)))
3866      {
3867          return from_json(j, std::forward&lt;T&gt;(val));
3868      }
3869  };
3870  }  
3871  #ifndef JSON_HAS_CPP_17
3872  namespace 
3873  {
3874  #endif
3875  JSON_INLINE_VARIABLE constexpr const auto&amp; from_json = 
3876      detail::static_const&lt;detail::from_json_fn&gt;::value;
3877  #ifndef JSON_HAS_CPP_17
3878  }  
3879  #endif
3880  NLOHMANN_JSON_NAMESPACE_END
3881  #include &lt;algorithm&gt; 
3882  #include &lt;iterator&gt; 
3883  #include &lt;string&gt; 
3884  #include &lt;tuple&gt; 
3885  #include &lt;type_traits&gt; 
3886  #include &lt;utility&gt; 
3887  #include &lt;valarray&gt; 
3888  #include &lt;vector&gt; 
3889  #include &lt;cstddef&gt; 
3890  #include &lt;iterator&gt; 
3891  #include &lt;string&gt; 
3892  #include &lt;tuple&gt; 
3893  #include &lt;utility&gt; 
3894  #if JSON_HAS_RANGES
3895      #include &lt;ranges&gt; 
3896  #endif
3897  NLOHMANN_JSON_NAMESPACE_BEGIN
3898  namespace detail
3899  {
3900  template&lt;typename string_type&gt;
3901  void int_to_string( string_type&amp; target, std::size_t value )
3902  {
3903      using std::to_string;
3904      target = to_string(value);
3905  }
3906  template&lt;typename IteratorType&gt; class iteration_proxy_value
3907  {
3908    public:
3909      using difference_type = std::ptrdiff_t;
3910      using value_type = iteration_proxy_value;
3911      using pointer = value_type *;
3912      using reference = value_type &amp;;
3913      using iterator_category = std::input_iterator_tag;
3914      using string_type = typename std::remove_cv&lt; typename std::remove_reference&lt;decltype( std::declval&lt;IteratorType&gt;().key() ) &gt;::type &gt;::type;
3915    private:
3916      IteratorType anchor{};
3917      std::size_t array_index = 0;
3918      mutable std::size_t array_index_last = 0;
3919      mutable string_type array_index_str = &quot;0&quot;;
3920      string_type empty_str{};
3921    public:
3922      explicit iteration_proxy_value() = default;
3923      explicit iteration_proxy_value(IteratorType it, std::size_t array_index_ = 0)
3924      noexcept(std::is_nothrow_move_constructible&lt;IteratorType&gt;::value
3925               &amp;&amp; std::is_nothrow_default_constructible&lt;string_type&gt;::value)
3926          : anchor(std::move(it))
3927          , array_index(array_index_)
3928      {}
3929      iteration_proxy_value(iteration_proxy_value const&amp;) = default;
3930      iteration_proxy_value&amp; operator=(iteration_proxy_value const&amp;) = default;
3931      iteration_proxy_value(iteration_proxy_value&amp;&amp;)
3932      noexcept(std::is_nothrow_move_constructible&lt;IteratorType&gt;::value
3933               &amp;&amp; std::is_nothrow_move_constructible&lt;string_type&gt;::value) = default;
3934      iteration_proxy_value&amp; operator=(iteration_proxy_value&amp;&amp;)
3935      noexcept(std::is_nothrow_move_assignable&lt;IteratorType&gt;::value
3936               &amp;&amp; std::is_nothrow_move_assignable&lt;string_type&gt;::value) = default;
3937      ~iteration_proxy_value() = default;
3938      const iteration_proxy_value&amp; operator*() const
3939      {
3940          return *this;
3941      }
3942      iteration_proxy_value&amp; operator++()
3943      {
3944          ++anchor;
3945          ++array_index;
3946          return *this;
3947      }
3948      iteration_proxy_value operator++(int)&amp; 
3949      {
3950          auto tmp = iteration_proxy_value(anchor, array_index);
3951          ++anchor;
3952          ++array_index;
3953          return tmp;
3954      }
3955      bool operator==(const iteration_proxy_value&amp; o) const
3956      {
3957          return anchor == o.anchor;
3958      }
3959      bool operator!=(const iteration_proxy_value&amp; o) const
3960      {
3961          return anchor != o.anchor;
3962      }
3963      const string_type&amp; key() const
3964      {
3965          JSON_ASSERT(anchor.m_object != nullptr);
3966          switch (anchor.m_object-&gt;type())
3967          {
3968              case value_t::array:
3969              {
3970                  if (array_index != array_index_last)
3971                  {
3972                      int_to_string( array_index_str, array_index );
3973                      array_index_last = array_index;
3974                  }
3975                  return array_index_str;
3976              }
3977              case value_t::object:
3978                  return anchor.key();
3979              case value_t::null:
3980              case value_t::string:
3981              case value_t::boolean:
3982              case value_t::number_integer:
3983              case value_t::number_unsigned:
3984              case value_t::number_float:
3985              case value_t::binary:
3986              case value_t::discarded:
3987              default:
3988                  return empty_str;
3989          }
3990      }
3991      typename IteratorType::reference value() const
3992      {
3993          return anchor.value();
3994      }
3995  };
3996  template&lt;typename IteratorType&gt; class iteration_proxy
3997  {
3998    private:
3999      typename IteratorType::pointer container = nullptr;
4000    public:
4001      explicit iteration_proxy() = default;
4002      explicit iteration_proxy(typename IteratorType::reference cont) noexcept
4003          : container(&amp;cont) {}
4004      iteration_proxy(iteration_proxy const&amp;) = default;
4005      iteration_proxy&amp; operator=(iteration_proxy const&amp;) = default;
4006      iteration_proxy(iteration_proxy&amp;&amp;) noexcept = default;
4007      iteration_proxy&amp; operator=(iteration_proxy&amp;&amp;) noexcept = default;
4008      ~iteration_proxy() = default;
4009      iteration_proxy_value&lt;IteratorType&gt; begin() const noexcept
4010      {
4011          return iteration_proxy_value&lt;IteratorType&gt;(container-&gt;begin());
4012      }
4013      iteration_proxy_value&lt;IteratorType&gt; end() const noexcept
4014      {
4015          return iteration_proxy_value&lt;IteratorType&gt;(container-&gt;end());
4016      }
4017  };
4018  template&lt;std::size_t N, typename IteratorType, enable_if_t&lt;N == 0, int&gt; = 0&gt;
4019  auto get(const nlohmann::detail::iteration_proxy_value&lt;IteratorType&gt;&amp; i) -&gt; decltype(i.key())
4020  {
4021      return i.key();
4022  }
4023  template&lt;std::size_t N, typename IteratorType, enable_if_t&lt;N == 1, int&gt; = 0&gt;
4024  auto get(const nlohmann::detail::iteration_proxy_value&lt;IteratorType&gt;&amp; i) -&gt; decltype(i.value())
4025  {
4026      return i.value();
4027  }
4028  }  
4029  NLOHMANN_JSON_NAMESPACE_END
4030  namespace std
4031  {
4032  #if defined(__clang__)
4033      #pragma clang diagnostic push
4034      #pragma clang diagnostic ignored &quot;-Wmismatched-tags&quot;
4035  #endif
4036  template&lt;typename IteratorType&gt;
4037  class tuple_size&lt;::nlohmann::detail::iteration_proxy_value&lt;IteratorType&gt;&gt;
4038              : public std::integral_constant&lt;std::size_t, 2&gt; {};
4039  template&lt;std::size_t N, typename IteratorType&gt;
4040  class tuple_element&lt;N, ::nlohmann::detail::iteration_proxy_value&lt;IteratorType &gt;&gt;
4041  {
4042    public:
4043      using type = decltype(
4044                       get&lt;N&gt;(std::declval &lt;
4045                              ::nlohmann::detail::iteration_proxy_value&lt;IteratorType &gt;&gt; ()));
4046  };
4047  #if defined(__clang__)
4048      #pragma clang diagnostic pop
4049  #endif
4050  }  
4051  #if JSON_HAS_RANGES
4052      template &lt;typename IteratorType&gt;
4053      inline constexpr bool ::std::ranges::enable_borrowed_range&lt;::nlohmann::detail::iteration_proxy&lt;IteratorType&gt;&gt; = true;
4054  #endif
4055  NLOHMANN_JSON_NAMESPACE_BEGIN
4056  namespace detail
4057  {
4058  template&lt;value_t&gt; struct external_constructor;
4059  template&lt;&gt;
4060  struct external_constructor&lt;value_t::boolean&gt;
4061  {
4062      template&lt;typename BasicJsonType&gt;
4063      static void construct(BasicJsonType&amp; j, typename BasicJsonType::boolean_t b) noexcept
4064      {
4065          j.m_value.destroy(j.m_type);
4066          j.m_type = value_t::boolean;
4067          j.m_value = b;
4068          j.assert_invariant();
4069      }
4070  };
4071  template&lt;&gt;
4072  struct external_constructor&lt;value_t::string&gt;
4073  {
4074      template&lt;typename BasicJsonType&gt;
4075      static void construct(BasicJsonType&amp; j, const typename BasicJsonType::string_t&amp; s)
4076      {
4077          j.m_value.destroy(j.m_type);
4078          j.m_type = value_t::string;
4079          j.m_value = s;
4080          j.assert_invariant();
4081      }
4082      template&lt;typename BasicJsonType&gt;
4083      static void construct(BasicJsonType&amp; j, typename BasicJsonType::string_t&amp;&amp; s)
4084      {
4085          j.m_value.destroy(j.m_type);
4086          j.m_type = value_t::string;
4087          j.m_value = std::move(s);
4088          j.assert_invariant();
4089      }
4090      template &lt; typename BasicJsonType, typename CompatibleStringType,
4091                 enable_if_t &lt; !std::is_same&lt;CompatibleStringType, typename BasicJsonType::string_t&gt;::value,
4092                               int &gt; = 0 &gt;
4093      static void construct(BasicJsonType&amp; j, const CompatibleStringType&amp; str)
4094      {
4095          j.m_value.destroy(j.m_type);
4096          j.m_type = value_t::string;
4097          j.m_value.string = j.template create&lt;typename BasicJsonType::string_t&gt;(str);
4098          j.assert_invariant();
4099      }
4100  };
4101  template&lt;&gt;
4102  struct external_constructor&lt;value_t::binary&gt;
4103  {
4104      template&lt;typename BasicJsonType&gt;
4105      static void construct(BasicJsonType&amp; j, const typename BasicJsonType::binary_t&amp; b)
4106      {
4107          j.m_value.destroy(j.m_type);
4108          j.m_type = value_t::binary;
4109          j.m_value = typename BasicJsonType::binary_t(b);
4110          j.assert_invariant();
4111      }
4112      template&lt;typename BasicJsonType&gt;
4113      static void construct(BasicJsonType&amp; j, typename BasicJsonType::binary_t&amp;&amp; b)
4114      {
4115          j.m_value.destroy(j.m_type);
4116          j.m_type = value_t::binary;
4117          j.m_value = typename BasicJsonType::binary_t(std::move(b));
4118          j.assert_invariant();
4119      }
4120  };
4121  template&lt;&gt;
4122  struct external_constructor&lt;value_t::number_float&gt;
4123  {
4124      template&lt;typename BasicJsonType&gt;
4125      static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_float_t val) noexcept
4126      {
4127          j.m_value.destroy(j.m_type);
4128          j.m_type = value_t::number_float;
4129          j.m_value = val;
4130          j.assert_invariant();
4131      }
4132  };
4133  template&lt;&gt;
4134  struct external_constructor&lt;value_t::number_unsigned&gt;
4135  {
4136      template&lt;typename BasicJsonType&gt;
4137      static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_unsigned_t val) noexcept
4138      {
4139          j.m_value.destroy(j.m_type);
4140          j.m_type = value_t::number_unsigned;
4141          j.m_value = val;
4142          j.assert_invariant();
4143      }
4144  };
4145  template&lt;&gt;
4146  struct external_constructor&lt;value_t::number_integer&gt;
4147  {
4148      template&lt;typename BasicJsonType&gt;
4149      static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_integer_t val) noexcept
4150      {
4151          j.m_value.destroy(j.m_type);
4152          j.m_type = value_t::number_integer;
4153          j.m_value = val;
4154          j.assert_invariant();
4155      }
4156  };
4157  template&lt;&gt;
4158  struct external_constructor&lt;value_t::array&gt;
4159  {
4160      template&lt;typename BasicJsonType&gt;
4161      static void construct(BasicJsonType&amp; j, const typename BasicJsonType::array_t&amp; arr)
4162      {
4163          j.m_value.destroy(j.m_type);
4164          j.m_type = value_t::array;
4165          j.m_value = arr;
4166          j.set_parents();
4167          j.assert_invariant();
4168      }
4169      template&lt;typename BasicJsonType&gt;
4170      static void construct(BasicJsonType&amp; j, typename BasicJsonType::array_t&amp;&amp; arr)
4171      {
4172          j.m_value.destroy(j.m_type);
4173          j.m_type = value_t::array;
4174          j.m_value = std::move(arr);
4175          j.set_parents();
4176          j.assert_invariant();
4177      }
4178      template &lt; typename BasicJsonType, typename CompatibleArrayType,
4179                 enable_if_t &lt; !std::is_same&lt;CompatibleArrayType, typename BasicJsonType::array_t&gt;::value,
4180                               int &gt; = 0 &gt;
4181      static void construct(BasicJsonType&amp; j, const CompatibleArrayType&amp; arr)
4182      {
4183          using std::begin;
4184          using std::end;
4185          j.m_value.destroy(j.m_type);
4186          j.m_type = value_t::array;
4187          j.m_value.array = j.template create&lt;typename BasicJsonType::array_t&gt;(begin(arr), end(arr));
4188          j.set_parents();
4189          j.assert_invariant();
4190      }
4191      template&lt;typename BasicJsonType&gt;
4192      static void construct(BasicJsonType&amp; j, const std::vector&lt;bool&gt;&amp; arr)
4193      {
4194          j.m_value.destroy(j.m_type);
4195          j.m_type = value_t::array;
4196          j.m_value = value_t::array;
4197          j.m_value.array-&gt;reserve(arr.size());
4198          for (const bool x : arr)
4199          {
4200              j.m_value.array-&gt;push_back(x);
4201              j.set_parent(j.m_value.array-&gt;back());
4202          }
4203          j.assert_invariant();
4204      }
4205      template&lt;typename BasicJsonType, typename T,
4206               enable_if_t&lt;std::is_convertible&lt;T, BasicJsonType&gt;::value, int&gt; = 0&gt;
4207      static void construct(BasicJsonType&amp; j, const std::valarray&lt;T&gt;&amp; arr)
4208      {
4209          j.m_value.destroy(j.m_type);
4210          j.m_type = value_t::array;
4211          j.m_value = value_t::array;
4212          j.m_value.array-&gt;resize(arr.size());
4213          if (arr.size() &gt; 0)
4214          {
4215              std::copy(std::begin(arr), std::end(arr), j.m_value.array-&gt;begin());
4216          }
4217          j.set_parents();
4218          j.assert_invariant();
4219      }
4220  };
4221  template&lt;&gt;
4222  struct external_constructor&lt;value_t::object&gt;
4223  {
4224      template&lt;typename BasicJsonType&gt;
4225      static void construct(BasicJsonType&amp; j, const typename BasicJsonType::object_t&amp; obj)
4226      {
4227          j.m_value.destroy(j.m_type);
4228          j.m_type = value_t::object;
4229          j.m_value = obj;
4230          j.set_parents();
4231          j.assert_invariant();
4232      }
4233      template&lt;typename BasicJsonType&gt;
4234      static void construct(BasicJsonType&amp; j, typename BasicJsonType::object_t&amp;&amp; obj)
4235      {
4236          j.m_value.destroy(j.m_type);
4237          j.m_type = value_t::object;
4238          j.m_value = std::move(obj);
4239          j.set_parents();
4240          j.assert_invariant();
4241      }
4242      template &lt; typename BasicJsonType, typename CompatibleObjectType,
4243                 enable_if_t &lt; !std::is_same&lt;CompatibleObjectType, typename BasicJsonType::object_t&gt;::value, int &gt; = 0 &gt;
4244      static void construct(BasicJsonType&amp; j, const CompatibleObjectType&amp; obj)
4245      {
4246          using std::begin;
4247          using std::end;
4248          j.m_value.destroy(j.m_type);
4249          j.m_type = value_t::object;
4250          j.m_value.object = j.template create&lt;typename BasicJsonType::object_t&gt;(begin(obj), end(obj));
4251          j.set_parents();
4252          j.assert_invariant();
4253      }
4254  };
4255  template&lt;typename BasicJsonType, typename T,
4256           enable_if_t&lt;std::is_same&lt;T, typename BasicJsonType::boolean_t&gt;::value, int&gt; = 0&gt;
4257  inline void to_json(BasicJsonType&amp; j, T b) noexcept
4258  {
4259      external_constructor&lt;value_t::boolean&gt;::construct(j, b);
4260  }
4261  template &lt; typename BasicJsonType, typename BoolRef,
4262             enable_if_t &lt;
4263                 ((std::is_same&lt;std::vector&lt;bool&gt;::reference, BoolRef&gt;::value
4264                   &amp;&amp; !std::is_same &lt;std::vector&lt;bool&gt;::reference, typename BasicJsonType::boolean_t&amp;&gt;::value)
4265                  || (std::is_same&lt;std::vector&lt;bool&gt;::const_reference, BoolRef&gt;::value
4266                      &amp;&amp; !std::is_same &lt;detail::uncvref_t&lt;std::vector&lt;bool&gt;::const_reference&gt;,
4267                                        typename BasicJsonType::boolean_t &gt;::value))
4268                 &amp;&amp; std::is_convertible&lt;const BoolRef&amp;, typename BasicJsonType::boolean_t&gt;::value, int &gt; = 0 &gt;
4269  inline void to_json(BasicJsonType&amp; j, const BoolRef&amp; b) noexcept
4270  {
4271      external_constructor&lt;value_t::boolean&gt;::construct(j, static_cast&lt;typename BasicJsonType::boolean_t&gt;(b));
4272  }
4273  template&lt;typename BasicJsonType, typename CompatibleString,
4274           enable_if_t&lt;std::is_constructible&lt;typename BasicJsonType::string_t, CompatibleString&gt;::value, int&gt; = 0&gt;
4275  inline void to_json(BasicJsonType&amp; j, const CompatibleString&amp; s)
4276  {
4277      external_constructor&lt;value_t::string&gt;::construct(j, s);
4278  }
4279  template&lt;typename BasicJsonType&gt;
4280  inline void to_json(BasicJsonType&amp; j, typename BasicJsonType::string_t&amp;&amp; s)
4281  {
4282      external_constructor&lt;value_t::string&gt;::construct(j, std::move(s));
4283  }
4284  template&lt;typename BasicJsonType, typename FloatType,
4285           enable_if_t&lt;std::is_floating_point&lt;FloatType&gt;::value, int&gt; = 0&gt;
4286  inline void to_json(BasicJsonType&amp; j, FloatType val) noexcept
4287  {
4288      external_constructor&lt;value_t::number_float&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_float_t&gt;(val));
4289  }
4290  template&lt;typename BasicJsonType, typename CompatibleNumberUnsignedType,
4291           enable_if_t&lt;is_compatible_integer_type&lt;typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType&gt;::value, int&gt; = 0&gt;
4292  inline void to_json(BasicJsonType&amp; j, CompatibleNumberUnsignedType val) noexcept
4293  {
4294      external_constructor&lt;value_t::number_unsigned&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_unsigned_t&gt;(val));
4295  }
4296  template&lt;typename BasicJsonType, typename CompatibleNumberIntegerType,
4297           enable_if_t&lt;is_compatible_integer_type&lt;typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType&gt;::value, int&gt; = 0&gt;
4298  inline void to_json(BasicJsonType&amp; j, CompatibleNumberIntegerType val) noexcept
4299  {
4300      external_constructor&lt;value_t::number_integer&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_integer_t&gt;(val));
4301  }
4302  #if !JSON_DISABLE_ENUM_SERIALIZATION
4303  template&lt;typename BasicJsonType, typename EnumType,
4304           enable_if_t&lt;std::is_enum&lt;EnumType&gt;::value, int&gt; = 0&gt;
4305  inline void to_json(BasicJsonType&amp; j, EnumType e) noexcept
4306  {
4307      using underlying_type = typename std::underlying_type&lt;EnumType&gt;::type;
4308      external_constructor&lt;value_t::number_integer&gt;::construct(j, static_cast&lt;underlying_type&gt;(e));
4309  }
4310  #endif  
4311  template&lt;typename BasicJsonType&gt;
4312  inline void to_json(BasicJsonType&amp; j, const std::vector&lt;bool&gt;&amp; e)
4313  {
4314      external_constructor&lt;value_t::array&gt;::construct(j, e);
4315  }
4316  template &lt; typename BasicJsonType, typename CompatibleArrayType,
4317             enable_if_t &lt; is_compatible_array_type&lt;BasicJsonType,
4318                           CompatibleArrayType&gt;::value&amp;&amp;
4319                           !is_compatible_object_type&lt;BasicJsonType, CompatibleArrayType&gt;::value&amp;&amp;
4320                           !is_compatible_string_type&lt;BasicJsonType, CompatibleArrayType&gt;::value&amp;&amp;
4321                           !std::is_same&lt;typename BasicJsonType::binary_t, CompatibleArrayType&gt;::value&amp;&amp;
4322                           !is_basic_json&lt;CompatibleArrayType&gt;::value,
4323                           int &gt; = 0 &gt;
4324  inline void to_json(BasicJsonType&amp; j, const CompatibleArrayType&amp; arr)
4325  {
4326      external_constructor&lt;value_t::array&gt;::construct(j, arr);
4327  }
4328  template&lt;typename BasicJsonType&gt;
4329  inline void to_json(BasicJsonType&amp; j, const typename BasicJsonType::binary_t&amp; bin)
4330  {
4331      external_constructor&lt;value_t::binary&gt;::construct(j, bin);
4332  }
4333  template&lt;typename BasicJsonType, typename T,
4334           enable_if_t&lt;std::is_convertible&lt;T, BasicJsonType&gt;::value, int&gt; = 0&gt;
4335  inline void to_json(BasicJsonType&amp; j, const std::valarray&lt;T&gt;&amp; arr)
4336  {
4337      external_constructor&lt;value_t::array&gt;::construct(j, std::move(arr));
4338  }
4339  template&lt;typename BasicJsonType&gt;
4340  inline void to_json(BasicJsonType&amp; j, typename BasicJsonType::array_t&amp;&amp; arr)
4341  {
4342      external_constructor&lt;value_t::array&gt;::construct(j, std::move(arr));
4343  }
4344  template &lt; typename BasicJsonType, typename CompatibleObjectType,
4345             enable_if_t &lt; is_compatible_object_type&lt;BasicJsonType, CompatibleObjectType&gt;::value&amp;&amp; !is_basic_json&lt;CompatibleObjectType&gt;::value, int &gt; = 0 &gt;
4346  inline void to_json(BasicJsonType&amp; j, const CompatibleObjectType&amp; obj)
4347  {
4348      external_constructor&lt;value_t::object&gt;::construct(j, obj);
4349  }
4350  template&lt;typename BasicJsonType&gt;
4351  inline void to_json(BasicJsonType&amp; j, typename BasicJsonType::object_t&amp;&amp; obj)
4352  {
4353      external_constructor&lt;value_t::object&gt;::construct(j, std::move(obj));
4354  }
4355  template &lt;
4356      typename BasicJsonType, typename T, std::size_t N,
4357      enable_if_t &lt; !std::is_constructible&lt;typename BasicJsonType::string_t,
4358                    const T(&amp;)[N]&gt;::value, 
4359                    int &gt; = 0 &gt;
4360  inline void to_json(BasicJsonType&amp; j, const T(&amp;arr)[N]) 
4361  {
4362      external_constructor&lt;value_t::array&gt;::construct(j, arr);
4363  }
4364  template &lt; typename BasicJsonType, typename T1, typename T2, enable_if_t &lt; std::is_constructible&lt;BasicJsonType, T1&gt;::value&amp;&amp; std::is_constructible&lt;BasicJsonType, T2&gt;::value, int &gt; = 0 &gt;
4365  inline void to_json(BasicJsonType&amp; j, const std::pair&lt;T1, T2&gt;&amp; p)
4366  {
4367      j = { p.first, p.second };
4368  }
4369  template&lt;typename BasicJsonType, typename T,
4370           enable_if_t&lt;std::is_same&lt;T, iteration_proxy_value&lt;typename BasicJsonType::iterator&gt;&gt;::value, int&gt; = 0&gt;
4371  inline void to_json(BasicJsonType&amp; j, const T&amp; b)
4372  {
4373      j = { {b.key(), b.value()} };
4374  }
4375  template&lt;typename BasicJsonType, typename Tuple, std::size_t... Idx&gt;
4376  inline void to_json_tuple_impl(BasicJsonType&amp; j, const Tuple&amp; t, index_sequence&lt;Idx...&gt; &amp;bsol;*unused*/)
4377  {
4378      j = { std::get&lt;Idx&gt;(t)... };
4379  }
4380  template&lt;typename BasicJsonType, typename T, enable_if_t&lt;is_constructible_tuple&lt;BasicJsonType, T&gt;::value, int &gt; = 0&gt;
4381  inline void to_json(BasicJsonType&amp; j, const T&amp; t)
4382  {
4383      to_json_tuple_impl(j, t, make_index_sequence&lt;std::tuple_size&lt;T&gt;::value&gt; {});
4384  }
4385  #if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
4386  template&lt;typename BasicJsonType&gt;
4387  inline void to_json(BasicJsonType&amp; j, const std_fs::path&amp; p)
4388  {
4389      j = p.string();
4390  }
4391  #endif
4392  struct to_json_fn
4393  {
4394      template&lt;typename BasicJsonType, typename T&gt;
4395      auto operator()(BasicJsonType&amp; j, T&amp;&amp; val) const noexcept(noexcept(to_json(j, std::forward&lt;T&gt;(val))))
4396      -&gt; decltype(to_json(j, std::forward&lt;T&gt;(val)), void())
4397      {
4398          return to_json(j, std::forward&lt;T&gt;(val));
4399      }
4400  };
4401  }  
4402  #ifndef JSON_HAS_CPP_17
4403  namespace 
4404  {
4405  #endif
4406  JSON_INLINE_VARIABLE constexpr const auto&amp; to_json = 
4407      detail::static_const&lt;detail::to_json_fn&gt;::value;
4408  #ifndef JSON_HAS_CPP_17
4409  }  
4410  #endif
4411  NLOHMANN_JSON_NAMESPACE_END
4412  NLOHMANN_JSON_NAMESPACE_BEGIN
4413  template&lt;typename ValueType, typename&gt;
4414  struct adl_serializer
4415  {
4416      template&lt;typename BasicJsonType, typename TargetType = ValueType&gt;
4417      static auto from_json(BasicJsonType &amp;&amp; j, TargetType&amp; val) noexcept(
4418          noexcept(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val)))
4419      -&gt; decltype(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val), void())
4420      {
4421          ::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val);
4422      }
4423      template&lt;typename BasicJsonType, typename TargetType = ValueType&gt;
4424      static auto from_json(BasicJsonType &amp;&amp; j) noexcept(
4425      noexcept(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), detail::identity_tag&lt;TargetType&gt; {})))
4426      -&gt; decltype(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), detail::identity_tag&lt;TargetType&gt; {}))
4427      {
4428          return ::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), detail::identity_tag&lt;TargetType&gt; {});
4429      }
4430      template&lt;typename BasicJsonType, typename TargetType = ValueType&gt;
4431      static auto to_json(BasicJsonType&amp; j, TargetType &amp;&amp; val) noexcept(
4432          noexcept(::nlohmann::to_json(j, std::forward&lt;TargetType&gt;(val))))
4433      -&gt; decltype(::nlohmann::to_json(j, std::forward&lt;TargetType&gt;(val)), void())
4434      {
4435          ::nlohmann::to_json(j, std::forward&lt;TargetType&gt;(val));
4436      }
4437  };
4438  NLOHMANN_JSON_NAMESPACE_END
4439  #include &lt;cstdint&gt; 
4440  #include &lt;tuple&gt; 
4441  #include &lt;utility&gt; 
4442  NLOHMANN_JSON_NAMESPACE_BEGIN
4443  template&lt;typename BinaryType&gt;
4444  class byte_container_with_subtype : public BinaryType
4445  {
4446    public:
4447      using container_type = BinaryType;
4448      using subtype_type = std::uint64_t;
4449      byte_container_with_subtype() noexcept(noexcept(container_type()))
4450          : container_type()
4451      {}
4452      byte_container_with_subtype(const container_type&amp; b) noexcept(noexcept(container_type(b)))
4453          : container_type(b)
4454      {}
4455      byte_container_with_subtype(container_type&amp;&amp; b) noexcept(noexcept(container_type(std::move(b))))
4456          : container_type(std::move(b))
4457      {}
4458      byte_container_with_subtype(const container_type&amp; b, subtype_type subtype_) noexcept(noexcept(container_type(b)))
4459          : container_type(b)
4460          , m_subtype(subtype_)
4461          , m_has_subtype(true)
4462      {}
4463      byte_container_with_subtype(container_type&amp;&amp; b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))
4464          : container_type(std::move(b))
4465          , m_subtype(subtype_)
4466          , m_has_subtype(true)
4467      {}
4468      bool operator==(const byte_container_with_subtype&amp; rhs) const
4469      {
4470          return std::tie(static_cast&lt;const BinaryType&amp;&gt;(*this), m_subtype, m_has_subtype) ==
4471                 std::tie(static_cast&lt;const BinaryType&amp;&gt;(rhs), rhs.m_subtype, rhs.m_has_subtype);
4472      }
4473      bool operator!=(const byte_container_with_subtype&amp; rhs) const
4474      {
4475          return !(rhs == *this);
4476      }
4477      void set_subtype(subtype_type subtype_) noexcept
4478      {
4479          m_subtype = subtype_;
4480          m_has_subtype = true;
4481      }
4482      constexpr subtype_type subtype() const noexcept
4483      {
4484          return m_has_subtype ? m_subtype : static_cast&lt;subtype_type&gt;(-1);
4485      }
4486      constexpr bool has_subtype() const noexcept
4487      {
4488          return m_has_subtype;
4489      }
4490      void clear_subtype() noexcept
4491      {
4492          m_subtype = 0;
4493          m_has_subtype = false;
4494      }
4495    private:
4496      subtype_type m_subtype = 0;
4497      bool m_has_subtype = false;
4498  };
4499  NLOHMANN_JSON_NAMESPACE_END
4500  #include &lt;cstdint&gt; 
4501  #include &lt;cstddef&gt; 
4502  #include &lt;functional&gt; 
4503  NLOHMANN_JSON_NAMESPACE_BEGIN
4504  namespace detail
4505  {
4506  inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
4507  {
4508      seed ^= h + 0x9e3779b9 + (seed &lt;&lt; 6U) + (seed &gt;&gt; 2U);
4509      return seed;
4510  }
4511  template&lt;typename BasicJsonType&gt;
4512  std::size_t hash(const BasicJsonType&amp; j)
4513  {
4514      using string_t = typename BasicJsonType::string_t;
4515      using number_integer_t = typename BasicJsonType::number_integer_t;
4516      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4517      using number_float_t = typename BasicJsonType::number_float_t;
4518      const auto type = static_cast&lt;std::size_t&gt;(j.type());
4519      switch (j.type())
4520      {
4521          case BasicJsonType::value_t::null:
4522          case BasicJsonType::value_t::discarded:
4523          {
4524              return combine(type, 0);
4525          }
4526          case BasicJsonType::value_t::object:
4527          {
4528              auto seed = combine(type, j.size());
4529              for (const auto&amp; element : j.items())
4530              {
4531                  const auto h = std::hash&lt;string_t&gt; {}(element.key());
4532                  seed = combine(seed, h);
4533                  seed = combine(seed, hash(element.value()));
4534              }
4535              return seed;
4536          }
4537          case BasicJsonType::value_t::array:
4538          {
4539              auto seed = combine(type, j.size());
4540              for (const auto&amp; element : j)
4541              {
4542                  seed = combine(seed, hash(element));
4543              }
4544              return seed;
4545          }
4546          case BasicJsonType::value_t::string:
4547          {
4548              const auto h = std::hash&lt;string_t&gt; {}(j.template get_ref&lt;const string_t&amp;&gt;());
4549              return combine(type, h);
4550          }
4551          case BasicJsonType::value_t::boolean:
4552          {
4553              const auto h = std::hash&lt;bool&gt; {}(j.template get&lt;bool&gt;());
4554              return combine(type, h);
4555          }
4556          case BasicJsonType::value_t::number_integer:
4557          {
4558              const auto h = std::hash&lt;number_integer_t&gt; {}(j.template get&lt;number_integer_t&gt;());
4559              return combine(type, h);
4560          }
4561          case BasicJsonType::value_t::number_unsigned:
4562          {
4563              const auto h = std::hash&lt;number_unsigned_t&gt; {}(j.template get&lt;number_unsigned_t&gt;());
4564              return combine(type, h);
4565          }
4566          case BasicJsonType::value_t::number_float:
4567          {
4568              const auto h = std::hash&lt;number_float_t&gt; {}(j.template get&lt;number_float_t&gt;());
4569              return combine(type, h);
4570          }
4571          case BasicJsonType::value_t::binary:
4572          {
4573              auto seed = combine(type, j.get_binary().size());
4574              const auto h = std::hash&lt;bool&gt; {}(j.get_binary().has_subtype());
4575              seed = combine(seed, h);
4576              seed = combine(seed, static_cast&lt;std::size_t&gt;(j.get_binary().subtype()));
4577              for (const auto byte : j.get_binary())
4578              {
4579                  seed = combine(seed, std::hash&lt;std::uint8_t&gt; {}(byte));
4580              }
4581              return seed;
4582          }
4583          default:                   
4584              JSON_ASSERT(false); 
4585              return 0;              
4586      }
4587  }
4588  }  
4589  NLOHMANN_JSON_NAMESPACE_END
4590  #include &lt;algorithm&gt; 
4591  #include &lt;array&gt; 
4592  #include &lt;cmath&gt; 
4593  #include &lt;cstddef&gt; 
4594  #include &lt;cstdint&gt; 
4595  #include &lt;cstdio&gt; 
4596  #include &lt;cstring&gt; 
4597  #include &lt;iterator&gt; 
4598  #include &lt;limits&gt; 
4599  #include &lt;string&gt; 
4600  #include &lt;utility&gt; 
4601  #include &lt;vector&gt; 
4602  #include &lt;array&gt; 
4603  #include &lt;cstddef&gt; 
4604  #include &lt;cstring&gt; 
4605  #include &lt;iterator&gt; 
4606  #include &lt;memory&gt; 
4607  #include &lt;numeric&gt; 
4608  #include &lt;string&gt; 
4609  #include &lt;type_traits&gt; 
4610  #include &lt;utility&gt; 
4611  #ifndef JSON_NO_IO
4612      #include &lt;cstdio&gt;   
4613      #include &lt;istream&gt;  
4614  #endif                  
4615  NLOHMANN_JSON_NAMESPACE_BEGIN
4616  namespace detail
4617  {
4618  enum class input_format_t { json, cbor, msgpack, ubjson, bson, bjdata };
4619  #ifndef JSON_NO_IO
4620  class file_input_adapter
4621  {
4622    public:
4623      using char_type = char;
4624      JSON_HEDLEY_NON_NULL(2)
4625      explicit file_input_adapter(std::FILE* f) noexcept
4626          : m_file(f)
4627      {
4628          JSON_ASSERT(m_file != nullptr);
4629      }
4630      file_input_adapter(const file_input_adapter&amp;) = delete;
4631      file_input_adapter(file_input_adapter&amp;&amp;) noexcept = default;
4632      file_input_adapter&amp; operator=(const file_input_adapter&amp;) = delete;
4633      file_input_adapter&amp; operator=(file_input_adapter&amp;&amp;) = delete;
4634      ~file_input_adapter() = default;
4635      std::char_traits&lt;char&gt;::int_type get_character() noexcept
4636      {
4637          return std::fgetc(m_file);
4638      }
4639    private:
4640      std::FILE* m_file;
4641  };
4642  class input_stream_adapter
4643  {
4644    public:
4645      using char_type = char;
4646      ~input_stream_adapter()
4647      {
4648          if (is != nullptr)
4649          {
4650              is-&gt;clear(is-&gt;rdstate() &amp; std::ios::eofbit);
4651          }
4652      }
4653      explicit input_stream_adapter(std::istream&amp; i)
4654          : is(&amp;i), sb(i.rdbuf())
4655      {}
4656      input_stream_adapter(const input_stream_adapter&amp;) = delete;
4657      input_stream_adapter&amp; operator=(input_stream_adapter&amp;) = delete;
4658      input_stream_adapter&amp; operator=(input_stream_adapter&amp;&amp;) = delete;
4659      input_stream_adapter(input_stream_adapter&amp;&amp; rhs) noexcept
4660          : is(rhs.is), sb(rhs.sb)
4661      {
4662          rhs.is = nullptr;
4663          rhs.sb = nullptr;
4664      }
4665      std::char_traits&lt;char&gt;::int_type get_character()
4666      {
4667          auto res = sb-&gt;sbumpc();
4668          if (JSON_HEDLEY_UNLIKELY(res == std::char_traits&lt;char&gt;::eof()))
4669          {
4670              is-&gt;clear(is-&gt;rdstate() | std::ios::eofbit);
4671          }
4672          return res;
4673      }
4674    private:
4675      std::istream* is = nullptr;
4676      std::streambuf* sb = nullptr;
4677  };
4678  #endif  
4679  template&lt;typename IteratorType&gt;
4680  class iterator_input_adapter
4681  {
4682    public:
4683      using char_type = typename std::iterator_traits&lt;IteratorType&gt;::value_type;
4684      iterator_input_adapter(IteratorType first, IteratorType last)
4685          : current(std::move(first)), end(std::move(last))
4686      {}
4687      typename std::char_traits&lt;char_type&gt;::int_type get_character()
4688      {
4689          if (JSON_HEDLEY_LIKELY(current != end))
4690          {
4691              auto result = std::char_traits&lt;char_type&gt;::to_int_type(*current);
4692              std::advance(current, 1);
4693              return result;
4694          }
4695          return std::char_traits&lt;char_type&gt;::eof();
4696      }
4697    private:
4698      IteratorType current;
4699      IteratorType end;
4700      template&lt;typename BaseInputAdapter, size_t T&gt;
4701      friend struct wide_string_input_helper;
4702      bool empty() const
4703      {
4704          return current == end;
4705      }
4706  };
4707  template&lt;typename BaseInputAdapter, size_t T&gt;
4708  struct wide_string_input_helper;
4709  template&lt;typename BaseInputAdapter&gt;
4710  struct wide_string_input_helper&lt;BaseInputAdapter, 4&gt;
4711  {
4712      static void fill_buffer(BaseInputAdapter&amp; input,
4713                              std::array&lt;std::char_traits&lt;char&gt;::int_type, 4&gt;&amp; utf8_bytes,
4714                              size_t&amp; utf8_bytes_index,
4715                              size_t&amp; utf8_bytes_filled)
4716      {
4717          utf8_bytes_index = 0;
4718          if (JSON_HEDLEY_UNLIKELY(input.empty()))
4719          {
4720              utf8_bytes[0] = std::char_traits&lt;char&gt;::eof();
4721              utf8_bytes_filled = 1;
4722          }
4723          else
4724          {
4725              const auto wc = input.get_character();
4726              if (wc &lt; 0x80)
4727              {
4728                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(wc);
4729                  utf8_bytes_filled = 1;
4730              }
4731              else if (wc &lt;= 0x7FF)
4732              {
4733                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xC0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u) &amp; 0x1Fu));
4734                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4735                  utf8_bytes_filled = 2;
4736              }
4737              else if (wc &lt;= 0xFFFF)
4738              {
4739                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xE0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 12u) &amp; 0x0Fu));
4740                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u) &amp; 0x3Fu));
4741                  utf8_bytes[2] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4742                  utf8_bytes_filled = 3;
4743              }
4744              else if (wc &lt;= 0x10FFFF)
4745              {
4746                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xF0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 18u) &amp; 0x07u));
4747                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 12u) &amp; 0x3Fu));
4748                  utf8_bytes[2] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u) &amp; 0x3Fu));
4749                  utf8_bytes[3] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4750                  utf8_bytes_filled = 4;
4751              }
4752              else
4753              {
4754                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(wc);
4755                  utf8_bytes_filled = 1;
4756              }
4757          }
4758      }
4759  };
4760  template&lt;typename BaseInputAdapter&gt;
4761  struct wide_string_input_helper&lt;BaseInputAdapter, 2&gt;
4762  {
4763      static void fill_buffer(BaseInputAdapter&amp; input,
4764                              std::array&lt;std::char_traits&lt;char&gt;::int_type, 4&gt;&amp; utf8_bytes,
4765                              size_t&amp; utf8_bytes_index,
4766                              size_t&amp; utf8_bytes_filled)
4767      {
4768          utf8_bytes_index = 0;
4769          if (JSON_HEDLEY_UNLIKELY(input.empty()))
4770          {
4771              utf8_bytes[0] = std::char_traits&lt;char&gt;::eof();
4772              utf8_bytes_filled = 1;
4773          }
4774          else
4775          {
4776              const auto wc = input.get_character();
4777              if (wc &lt; 0x80)
4778              {
4779                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(wc);
4780                  utf8_bytes_filled = 1;
4781              }
4782              else if (wc &lt;= 0x7FF)
4783              {
4784                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xC0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u)));
4785                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4786                  utf8_bytes_filled = 2;
4787              }
4788              else if (0xD800 &gt; wc || wc &gt;= 0xE000)
4789              {
4790                  utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xE0u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 12u)));
4791                  utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(wc) &gt;&gt; 6u) &amp; 0x3Fu));
4792                  utf8_bytes[2] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(wc) &amp; 0x3Fu));
4793                  utf8_bytes_filled = 3;
4794              }
4795              else
4796              {
4797                  if (JSON_HEDLEY_UNLIKELY(!input.empty()))
4798                  {
4799                      const auto wc2 = static_cast&lt;unsigned int&gt;(input.get_character());
4800                      const auto charcode = 0x10000u + (((static_cast&lt;unsigned int&gt;(wc) &amp; 0x3FFu) &lt;&lt; 10u) | (wc2 &amp; 0x3FFu));
4801                      utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0xF0u | (charcode &gt;&gt; 18u));
4802                      utf8_bytes[1] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((charcode &gt;&gt; 12u) &amp; 0x3Fu));
4803                      utf8_bytes[2] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | ((charcode &gt;&gt; 6u) &amp; 0x3Fu));
4804                      utf8_bytes[3] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(0x80u | (charcode &amp; 0x3Fu));
4805                      utf8_bytes_filled = 4;
4806                  }
4807                  else
4808                  {
4809                      utf8_bytes[0] = static_cast&lt;std::char_traits&lt;char&gt;::int_type&gt;(wc);
4810                      utf8_bytes_filled = 1;
4811                  }
4812              }
4813          }
4814      }
4815  };
4816  template&lt;typename BaseInputAdapter, typename WideCharType&gt;
4817  class wide_string_input_adapter
4818  {
4819    public:
4820      using char_type = char;
4821      wide_string_input_adapter(BaseInputAdapter base)
4822          : base_adapter(base) {}
4823      typename std::char_traits&lt;char&gt;::int_type get_character() noexcept
4824      {
4825          if (utf8_bytes_index == utf8_bytes_filled)
4826          {
4827              fill_buffer&lt;sizeof(WideCharType)&gt;();
4828              JSON_ASSERT(utf8_bytes_filled &gt; 0);
4829              JSON_ASSERT(utf8_bytes_index == 0);
4830          }
4831          JSON_ASSERT(utf8_bytes_filled &gt; 0);
4832          JSON_ASSERT(utf8_bytes_index &lt; utf8_bytes_filled);
4833          return utf8_bytes[utf8_bytes_index++];
4834      }
4835    private:
4836      BaseInputAdapter base_adapter;
4837      template&lt;size_t T&gt;
4838      void fill_buffer()
4839      {
4840          wide_string_input_helper&lt;BaseInputAdapter, T&gt;::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
4841      }
4842      std::array&lt;std::char_traits&lt;char&gt;::int_type, 4&gt; utf8_bytes = {{0, 0, 0, 0}};
4843      std::size_t utf8_bytes_index = 0;
4844      std::size_t utf8_bytes_filled = 0;
4845  };
4846  template&lt;typename IteratorType, typename Enable = void&gt;
4847  struct iterator_input_adapter_factory
4848  {
4849      using iterator_type = IteratorType;
4850      using char_type = typename std::iterator_traits&lt;iterator_type&gt;::value_type;
<span onclick='openModal()' class='match'>4851      using adapter_type = iterator_input_adapter&lt;iterator_type&gt;;
4852      static adapter_type create(IteratorType first, IteratorType last)
4853      {
4854          return adapter_type(std::move(first), std::move(last));
4855      }
4856  };
4857  template&lt;typename T&gt;
4858  struct is_iterator_of_multibyte
4859  {
4860      using value_type = typename std::iterator_traits&lt;T&gt;::value_type;
4861      enum
4862      {
4863          value = sizeof(value_type) &gt; 1
4864      };
4865  };
4866  template&lt;typename IteratorType&gt;
4867  struct iterator_input_adapter_factory&lt;IteratorType, enable_if_t&lt;is_iterator_of_multibyte&lt;IteratorType&gt;::value&gt;&gt;
4868  {
4869      using iterator_type = IteratorType;
4870      using char_type = typename std::iterator_traits&lt;iterator_type&gt;::value_type;
4871      using base_adapter_type = iterator_input_adapter&lt;iterator_type&gt;;
4872      using adapter_type = wide_string_input_adapter&lt;base_adapter_type, char_type&gt;;
4873      static adapter_type create(IteratorType first, IteratorType last)
4874      {
4875          return adapter_type(base_adapter_type(std::move(first), std::move(last)));
4876      }
4877  };
4878  template&lt;typename IteratorType&gt;
4879  typename iterator_input_adapter_factory&lt;IteratorType&gt;::adapter_type input_adapter(IteratorType first, IteratorType last)
4880  {
4881      using factory_type = iterator_input_adapter_factory&lt;IteratorType&gt;;
4882      return factory_type::create(first, last);
4883  }
4884  namespace container_input_adapter_factory_impl
4885  {
4886  using std::begin;
4887  using std::end;
4888  template&lt;typename ContainerType, typename Enable = void&gt;
4889  struct container_input_adapter_factory {};
4890  template&lt;typename ContainerType&gt;
4891  struct container_input_adapter_factory&lt; ContainerType,
4892         void_t&lt;decltype(begin(std::declval&lt;ContainerType&gt;()), end(std::declval&lt;ContainerType&gt;()))&gt;&gt;
4893         {
4894             using adapter_type = decltype(input_adapter(begin(std::declval&lt;ContainerType&gt;()), end(std::declval&lt;ContainerType&gt;())));
4895             static adapter_type create(const ContainerType&amp; container)
4896  {
4897      return input_adapter(begin(container), end(container));
4898  }
4899         };
4900  }  
4901  template&lt;typename ContainerType&gt;
4902  typename container_input_adapter_factory_impl::container_input_adapter_factory&lt;ContainerType&gt;::adapter_type input_adapter(const ContainerType&amp; container)
4903  {
4904      return container_input_adapter_factory_impl::container_input_adapter_factory&lt;ContainerType&gt;::create(container);
4905  }
4906  #ifndef JSON_NO_IO
4907  inline file_input_adapter input_adapter(std::FILE* file)
4908  {
4909      return file_input_adapter(file);
4910  }
4911  inline input_stream_adapter input_adapter(std::istream&amp; stream)
4912  {
4913      return input_stream_adapter(stream);
4914  }
4915  inline input_stream_adapter input_adapter(std::istream&amp;&amp; stream)
4916  {
4917      return input_stream_adapter(stream);
4918  }
4919  #endif  
4920  using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval&lt;const char*&gt;(), std::declval&lt;const char*&gt;()));
4921  template &lt; typename CharT,
4922             typename std::enable_if &lt;
4923                 std::is_pointer&lt;CharT&gt;::value&amp;&amp;
4924                 !std::is_array&lt;CharT&gt;::value&amp;&amp;
4925                 std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value&amp;&amp;
4926                 sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
4927                 int &gt;::type = 0 &gt;
4928  contiguous_bytes_input_adapter input_adapter(CharT b)
4929  {
4930      auto length = std::strlen(reinterpret_cast&lt;const char*&gt;(b));
4931      const auto* ptr = reinterpret_cast&lt;const char*&gt;(b);
4932      return input_adapter(ptr, ptr + length);
4933  }
4934  template&lt;typename T, std::size_t N&gt;
4935  auto input_adapter(T (&amp;array)[N]) -&gt; decltype(input_adapter(array, array + N)) 
4936  {
4937      return input_adapter(array, array + N);
4938  }
4939  class span_input_adapter
4940  {
4941    public:
4942      template &lt; typename CharT,
4943                 typename std::enable_if &lt;
4944                     std::is_pointer&lt;CharT&gt;::value&amp;&amp;
4945                     std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value&amp;&amp;
4946                     sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
4947                     int &gt;::type = 0 &gt;
4948      span_input_adapter(CharT b, std::size_t l)
4949          : ia(reinterpret_cast&lt;const char*&gt;(b), reinterpret_cast&lt;const char*&gt;(b) + l) {}
4950      template&lt;class IteratorType,
4951               typename std::enable_if&lt;
4952                   std::is_same&lt;typename iterator_traits&lt;IteratorType&gt;::iterator_category, std::random_access_iterator_tag&gt;::value,
4953                   int&gt;::type = 0&gt;
4954      span_input_adapter(IteratorType first, IteratorType last)
4955          : ia(input_adapter(first, last)) {}
4956      contiguous_bytes_input_adapter&amp;&amp; get()
4957      {
4958          return std::move(ia); 
4959      }
4960    private:
4961      contiguous_bytes_input_adapter ia;
4962  };
4963  }  
4964  NLOHMANN_JSON_NAMESPACE_END
</span>4965  #include &lt;cstddef&gt;
4966  #include &lt;string&gt; 
4967  #include &lt;utility&gt; 
4968  #include &lt;vector&gt; 
4969  NLOHMANN_JSON_NAMESPACE_BEGIN
4970  template&lt;typename BasicJsonType&gt;
4971  struct json_sax
4972  {
4973      using number_integer_t = typename BasicJsonType::number_integer_t;
4974      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4975      using number_float_t = typename BasicJsonType::number_float_t;
4976      using string_t = typename BasicJsonType::string_t;
4977      using binary_t = typename BasicJsonType::binary_t;
4978      virtual bool null() = 0;
4979      virtual bool boolean(bool val) = 0;
4980      virtual bool number_integer(number_integer_t val) = 0;
4981      virtual bool number_unsigned(number_unsigned_t val) = 0;
4982      virtual bool number_float(number_float_t val, const string_t&amp; s) = 0;
4983      virtual bool string(string_t&amp; val) = 0;
4984      virtual bool binary(binary_t&amp; val) = 0;
4985      virtual bool start_object(std::size_t elements) = 0;
4986      virtual bool key(string_t&amp; val) = 0;
4987      virtual bool end_object() = 0;
4988      virtual bool start_array(std::size_t elements) = 0;
4989      virtual bool end_array() = 0;
4990      virtual bool parse_error(std::size_t position,
4991                               const std::string&amp; last_token,
4992                               const detail::exception&amp; ex) = 0;
4993      json_sax() = default;
4994      json_sax(const json_sax&amp;) = default;
4995      json_sax(json_sax&amp;&amp;) noexcept = default;
4996      json_sax&amp; operator=(const json_sax&amp;) = default;
4997      json_sax&amp; operator=(json_sax&amp;&amp;) noexcept = default;
4998      virtual ~json_sax() = default;
4999  };
5000  namespace detail
5001  {
5002  template&lt;typename BasicJsonType&gt;
5003  class json_sax_dom_parser
5004  {
5005    public:
5006      using number_integer_t = typename BasicJsonType::number_integer_t;
5007      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
5008      using number_float_t = typename BasicJsonType::number_float_t;
5009      using string_t = typename BasicJsonType::string_t;
5010      using binary_t = typename BasicJsonType::binary_t;
5011      explicit json_sax_dom_parser(BasicJsonType&amp; r, const bool allow_exceptions_ = true)
5012          : root(r), allow_exceptions(allow_exceptions_)
5013      {}
5014      json_sax_dom_parser(const json_sax_dom_parser&amp;) = delete;
5015      json_sax_dom_parser(json_sax_dom_parser&amp;&amp;) = default; 
5016      json_sax_dom_parser&amp; operator=(const json_sax_dom_parser&amp;) = delete;
5017      json_sax_dom_parser&amp; operator=(json_sax_dom_parser&amp;&amp;) = default; 
5018      ~json_sax_dom_parser() = default;
5019      bool null()
5020      {
5021          handle_value(nullptr);
5022          return true;
5023      }
5024      bool boolean(bool val)
5025      {
5026          handle_value(val);
5027          return true;
5028      }
5029      bool number_integer(number_integer_t val)
5030      {
5031          handle_value(val);
5032          return true;
5033      }
5034      bool number_unsigned(number_unsigned_t val)
5035      {
5036          handle_value(val);
5037          return true;
5038      }
5039      bool number_float(number_float_t val, const string_t&amp; &amp;bsol;*unused*/)
5040      {
5041          handle_value(val);
5042          return true;
5043      }
5044      bool string(string_t&amp; val)
5045      {
5046          handle_value(val);
5047          return true;
5048      }
5049      bool binary(binary_t&amp; val)
5050      {
5051          handle_value(std::move(val));
5052          return true;
5053      }
5054      bool start_object(std::size_t len)
5055      {
5056          ref_stack.push_back(handle_value(BasicJsonType::value_t::object));
5057          if (JSON_HEDLEY_UNLIKELY(len != static_cast&lt;std::size_t&gt;(-1) &amp;&amp; len &gt; ref_stack.back()-&gt;max_size()))
5058          {
5059              JSON_THROW(out_of_range::create(408, concat(&quot;excessive object size: &quot;, std::to_string(len)), ref_stack.back()));
5060          }
5061          return true;
5062      }
5063      bool key(string_t&amp; val)
5064      {
5065          JSON_ASSERT(!ref_stack.empty());
5066          JSON_ASSERT(ref_stack.back()-&gt;is_object());
5067          object_element = &amp;(ref_stack.back()-&gt;m_value.object-&gt;operator[](val));
5068          return true;
5069      }
5070      bool end_object()
5071      {
5072          JSON_ASSERT(!ref_stack.empty());
5073          JSON_ASSERT(ref_stack.back()-&gt;is_object());
5074          ref_stack.back()-&gt;set_parents();
5075          ref_stack.pop_back();
5076          return true;
5077      }
5078      bool start_array(std::size_t len)
5079      {
5080          ref_stack.push_back(handle_value(BasicJsonType::value_t::array));
5081          if (JSON_HEDLEY_UNLIKELY(len != static_cast&lt;std::size_t&gt;(-1) &amp;&amp; len &gt; ref_stack.back()-&gt;max_size()))
5082          {
5083              JSON_THROW(out_of_range::create(408, concat(&quot;excessive array size: &quot;, std::to_string(len)), ref_stack.back()));
5084          }
5085          return true;
5086      }
5087      bool end_array()
5088      {
5089          JSON_ASSERT(!ref_stack.empty());
5090          JSON_ASSERT(ref_stack.back()-&gt;is_array());
5091          ref_stack.back()-&gt;set_parents();
5092          ref_stack.pop_back();
5093          return true;
5094      }
5095      template&lt;class Exception&gt;
5096      bool parse_error(std::size_t &amp;bsol;*unused*/, const std::string&amp; &amp;bsol;*unused*/,
5097                       const Exception&amp; ex)
5098      {
5099          errored = true;
5100          static_cast&lt;void&gt;(ex);
5101          if (allow_exceptions)
5102          {
5103              JSON_THROW(ex);
5104          }
5105          return false;
5106      }
5107      constexpr bool is_errored() const
5108      {
5109          return errored;
5110      }
5111    private:
5112      template&lt;typename Value&gt;
5113      JSON_HEDLEY_RETURNS_NON_NULL
5114      BasicJsonType* handle_value(Value&amp;&amp; v)
5115      {
5116          if (ref_stack.empty())
5117          {
5118              root = BasicJsonType(std::forward&lt;Value&gt;(v));
5119              return &amp;root;
5120          }
5121          JSON_ASSERT(ref_stack.back()-&gt;is_array() || ref_stack.back()-&gt;is_object());
5122          if (ref_stack.back()-&gt;is_array())
5123          {
5124              ref_stack.back()-&gt;m_value.array-&gt;emplace_back(std::forward&lt;Value&gt;(v));
5125              return &amp;(ref_stack.back()-&gt;m_value.array-&gt;back());
5126          }
5127          JSON_ASSERT(ref_stack.back()-&gt;is_object());
5128          JSON_ASSERT(object_element);
5129          *object_element = BasicJsonType(std::forward&lt;Value&gt;(v));
5130          return object_element;
5131      }
5132      BasicJsonType&amp; root;
5133      std::vector&lt;BasicJsonType*&gt; ref_stack {};
5134      BasicJsonType* object_element = nullptr;
5135      bool errored = false;
5136      const bool allow_exceptions = true;
5137  };
5138  template&lt;typename BasicJsonType&gt;
5139  class json_sax_dom_callback_parser
5140  {
5141    public:
5142      using number_integer_t = typename BasicJsonType::number_integer_t;
5143      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
5144      using number_float_t = typename BasicJsonType::number_float_t;
5145      using string_t = typename BasicJsonType::string_t;
5146      using binary_t = typename BasicJsonType::binary_t;
5147      using parser_callback_t = typename BasicJsonType::parser_callback_t;
5148      using parse_event_t = typename BasicJsonType::parse_event_t;
5149      json_sax_dom_callback_parser(BasicJsonType&amp; r,
5150                                   const parser_callback_t cb,
5151                                   const bool allow_exceptions_ = true)
5152          : root(r), callback(cb), allow_exceptions(allow_exceptions_)
5153      {
5154          keep_stack.push_back(true);
5155      }
5156      json_sax_dom_callback_parser(const json_sax_dom_callback_parser&amp;) = delete;
5157      json_sax_dom_callback_parser(json_sax_dom_callback_parser&amp;&amp;) = default; 
5158      json_sax_dom_callback_parser&amp; operator=(const json_sax_dom_callback_parser&amp;) = delete;
5159      json_sax_dom_callback_parser&amp; operator=(json_sax_dom_callback_parser&amp;&amp;) = default; 
5160      ~json_sax_dom_callback_parser() = default;
5161      bool null()
5162      {
5163          handle_value(nullptr);
5164          return true;
5165      }
5166      bool boolean(bool val)
5167      {
5168          handle_value(val);
5169          return true;
5170      }
5171      bool number_integer(number_integer_t val)
5172      {
5173          handle_value(val);
5174          return true;
5175      }
5176      bool number_unsigned(number_unsigned_t val)
5177      {
5178          handle_value(val);
5179          return true;
5180      }
5181      bool number_float(number_float_t val, const string_t&amp; &amp;bsol;*unused*/)
5182      {
5183          handle_value(val);
5184          return true;
5185      }
5186      bool string(string_t&amp; val)
5187      {
5188          handle_value(val);
5189          return true;
5190      }
5191      bool binary(binary_t&amp; val)
5192      {
5193          handle_value(std::move(val));
5194          return true;
5195      }
5196      bool start_object(std::size_t len)
5197      {
5198          const bool keep = callback(static_cast&lt;int&gt;(ref_stack.size()), parse_event_t::object_start, discarded);
5199          keep_stack.push_back(keep);
5200          auto val = handle_value(BasicJsonType::value_t::object, true);
5201          ref_stack.push_back(val.second);
5202          if (ref_stack.back() &amp;&amp; JSON_HEDLEY_UNLIKELY(len != static_cast&lt;std::size_t&gt;(-1) &amp;&amp; len &gt; ref_stack.back()-&gt;max_size()))
5203          {
5204              JSON_THROW(out_of_range::create(408, concat(&quot;excessive object size: &quot;, std::to_string(len)), ref_stack.back()));
5205          }
5206          return true;
5207      }
5208      bool key(string_t&amp; val)
5209      {
5210          BasicJsonType k = BasicJsonType(val);
5211          const bool keep = callback(static_cast&lt;int&gt;(ref_stack.size()), parse_event_t::key, k);
5212          key_keep_stack.push_back(keep);
5213          if (keep &amp;&amp; ref_stack.back())
5214          {
5215              object_element = &amp;(ref_stack.back()-&gt;m_value.object-&gt;operator[](val) = discarded);
5216          }
5217          return true;
5218      }
5219      bool end_object()
5220      {
5221          if (ref_stack.back())
5222          {
5223              if (!callback(static_cast&lt;int&gt;(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
5224              {
5225                  *ref_stack.back() = discarded;
5226              }
5227              else
5228              {
5229                  ref_stack.back()-&gt;set_parents();
5230              }
5231          }
5232          JSON_ASSERT(!ref_stack.empty());
5233          JSON_ASSERT(!keep_stack.empty());
5234          ref_stack.pop_back();
5235          keep_stack.pop_back();
5236          if (!ref_stack.empty() &amp;&amp; ref_stack.back() &amp;&amp; ref_stack.back()-&gt;is_structured())
5237          {
5238              for (auto it = ref_stack.back()-&gt;begin(); it != ref_stack.back()-&gt;end(); ++it)
5239              {
5240                  if (it-&gt;is_discarded())
5241                  {
5242                      ref_stack.back()-&gt;erase(it);
5243                      break;
5244                  }
5245              }
5246          }
5247          return true;
5248      }
5249      bool start_array(std::size_t len)
5250      {
5251          const bool keep = callback(static_cast&lt;int&gt;(ref_stack.size()), parse_event_t::array_start, discarded);
5252          keep_stack.push_back(keep);
5253          auto val = handle_value(BasicJsonType::value_t::array, true);
5254          ref_stack.push_back(val.second);
5255          if (ref_stack.back() &amp;&amp; JSON_HEDLEY_UNLIKELY(len != static_cast&lt;std::size_t&gt;(-1) &amp;&amp; len &gt; ref_stack.back()-&gt;max_size()))
5256          {
5257              JSON_THROW(out_of_range::create(408, concat(&quot;excessive array size: &quot;, std::to_string(len)), ref_stack.back()));
5258          }
5259          return true;
5260      }
5261      bool end_array()
5262      {
5263          bool keep = true;
5264          if (ref_stack.back())
5265          {
5266              keep = callback(static_cast&lt;int&gt;(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
5267              if (keep)
5268              {
5269                  ref_stack.back()-&gt;set_parents();
5270              }
5271              else
5272              {
5273                  *ref_stack.back() = discarded;
5274              }
5275          }
5276          JSON_ASSERT(!ref_stack.empty());
5277          JSON_ASSERT(!keep_stack.empty());
5278          ref_stack.pop_back();
5279          keep_stack.pop_back();
5280          if (!keep &amp;&amp; !ref_stack.empty() &amp;&amp; ref_stack.back()-&gt;is_array())
5281          {
5282              ref_stack.back()-&gt;m_value.array-&gt;pop_back();
5283          }
5284          return true;
5285      }
5286      template&lt;class Exception&gt;
5287      bool parse_error(std::size_t &amp;bsol;*unused*/, const std::string&amp; &amp;bsol;*unused*/,
5288                       const Exception&amp; ex)
5289      {
5290          errored = true;
5291          static_cast&lt;void&gt;(ex);
5292          if (allow_exceptions)
5293          {
5294              JSON_THROW(ex);
5295          }
5296          return false;
5297      }
5298      constexpr bool is_errored() const
5299      {
5300          return errored;
5301      }
5302    private:
5303      template&lt;typename Value&gt;
5304      std::pair&lt;bool, BasicJsonType*&gt; handle_value(Value&amp;&amp; v, const bool skip_callback = false)
5305      {
5306          JSON_ASSERT(!keep_stack.empty());
5307          if (!keep_stack.back())
5308          {
5309              return {false, nullptr};
5310          }
5311          auto value = BasicJsonType(std::forward&lt;Value&gt;(v));
5312          const bool keep = skip_callback || callback(static_cast&lt;int&gt;(ref_stack.size()), parse_event_t::value, value);
5313          if (!keep)
5314          {
5315              return {false, nullptr};
5316          }
5317          if (ref_stack.empty())
5318          {
5319              root = std::move(value);
5320              return {true, &amp;root};
5321          }
5322          if (!ref_stack.back())
5323          {
5324              return {false, nullptr};
5325          }
5326          JSON_ASSERT(ref_stack.back()-&gt;is_array() || ref_stack.back()-&gt;is_object());
5327          if (ref_stack.back()-&gt;is_array())
5328          {
5329              ref_stack.back()-&gt;m_value.array-&gt;emplace_back(std::move(value));
5330              return {true, &amp;(ref_stack.back()-&gt;m_value.array-&gt;back())};
5331          }
5332          JSON_ASSERT(ref_stack.back()-&gt;is_object());
5333          JSON_ASSERT(!key_keep_stack.empty());
5334          const bool store_element = key_keep_stack.back();
5335          key_keep_stack.pop_back();
5336          if (!store_element)
5337          {
5338              return {false, nullptr};
5339          }
5340          JSON_ASSERT(object_element);
5341          *object_element = std::move(value);
5342          return {true, object_element};
5343      }
5344      BasicJsonType&amp; root;
5345      std::vector&lt;BasicJsonType*&gt; ref_stack {};
5346      std::vector&lt;bool&gt; keep_stack {};
5347      std::vector&lt;bool&gt; key_keep_stack {};
5348      BasicJsonType* object_element = nullptr;
5349      bool errored = false;
5350      const parser_callback_t callback = nullptr;
5351      const bool allow_exceptions = true;
5352      BasicJsonType discarded = BasicJsonType::value_t::discarded;
5353  };
5354  template&lt;typename BasicJsonType&gt;
5355  class json_sax_acceptor
5356  {
5357    public:
5358      using number_integer_t = typename BasicJsonType::number_integer_t;
5359      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
5360      using number_float_t = typename BasicJsonType::number_float_t;
5361      using string_t = typename BasicJsonType::string_t;
5362      using binary_t = typename BasicJsonType::binary_t;
5363      bool null()
5364      {
5365          return true;
5366      }
5367      bool boolean(bool &amp;bsol;*unused*/)
5368      {
5369          return true;
5370      }
5371      bool number_integer(number_integer_t &amp;bsol;*unused*/)
5372      {
5373          return true;
5374      }
5375      bool number_unsigned(number_unsigned_t &amp;bsol;*unused*/)
5376      {
5377          return true;
5378      }
5379      bool number_float(number_float_t &amp;bsol;*unused*/, const string_t&amp; &amp;bsol;*unused*/)
5380      {
5381          return true;
5382      }
5383      bool string(string_t&amp; &amp;bsol;*unused*/)
5384      {
5385          return true;
5386      }
5387      bool binary(binary_t&amp; &amp;bsol;*unused*/)
5388      {
5389          return true;
5390      }
5391      bool start_object(std::size_t &amp;bsol;*unused*/ = static_cast&lt;std::size_t&gt;(-1))
5392      {
5393          return true;
5394      }
5395      bool key(string_t&amp; &amp;bsol;*unused*/)
5396      {
5397          return true;
5398      }
5399      bool end_object()
5400      {
5401          return true;
5402      }
5403      bool start_array(std::size_t &amp;bsol;*unused*/ = static_cast&lt;std::size_t&gt;(-1))
5404      {
5405          return true;
5406      }
5407      bool end_array()
5408      {
5409          return true;
5410      }
5411      bool parse_error(std::size_t &amp;bsol;*unused*/, const std::string&amp; &amp;bsol;*unused*/, const detail::exception&amp; &amp;bsol;*unused*/)
5412      {
5413          return false;
5414      }
5415  };
5416  }  
5417  NLOHMANN_JSON_NAMESPACE_END
5418  #include &lt;array&gt; 
5419  #include &lt;clocale&gt; 
5420  #include &lt;cstddef&gt; 
5421  #include &lt;cstdio&gt; 
5422  #include &lt;cstdlib&gt; 
5423  #include &lt;initializer_list&gt; 
5424  #include &lt;string&gt; 
5425  #include &lt;utility&gt; 
5426  #include &lt;vector&gt; 
5427  NLOHMANN_JSON_NAMESPACE_BEGIN
5428  namespace detail
5429  {
5430  template&lt;typename BasicJsonType&gt;
5431  class lexer_base
5432  {
5433    public:
5434      enum class token_type
5435      {
5436          uninitialized,    
5437          literal_true,     
5438          literal_false,    
5439          literal_null,     
5440          value_string,     
5441          value_unsigned,   
5442          value_integer,    
5443          value_float,      
5444          begin_array,      
5445          begin_object,     
5446          end_array,        
5447          end_object,       
5448          name_separator,   
5449          value_separator,  
5450          parse_error,      
5451          end_of_input,     
5452          literal_or_value  
5453      };
5454      JSON_HEDLEY_RETURNS_NON_NULL
5455      JSON_HEDLEY_CONST
5456      static const char* token_type_name(const token_type t) noexcept
5457      {
5458          switch (t)
5459          {
5460              case token_type::uninitialized:
5461                  return &quot;&lt;uninitialized&gt;&quot;;
5462              case token_type::literal_true:
5463                  return &quot;true literal&quot;;
5464              case token_type::literal_false:
5465                  return &quot;false literal&quot;;
5466              case token_type::literal_null:
5467                  return &quot;null literal&quot;;
5468              case token_type::value_string:
5469                  return &quot;string literal&quot;;
5470              case token_type::value_unsigned:
5471              case token_type::value_integer:
5472              case token_type::value_float:
5473                  return &quot;number literal&quot;;
5474              case token_type::begin_array:
5475                  return &quot;&#x27;[&#x27;&quot;;
5476              case token_type::begin_object:
5477                  return &quot;&#x27;{&#x27;&quot;;
5478              case token_type::end_array:
5479                  return &quot;&#x27;]&#x27;&quot;;
5480              case token_type::end_object:
5481                  return &quot;&#x27;}&#x27;&quot;;
5482              case token_type::name_separator:
5483                  return &quot;&#x27;:&#x27;&quot;;
5484              case token_type::value_separator:
5485                  return &quot;&#x27;,&#x27;&quot;;
5486              case token_type::parse_error:
5487                  return &quot;&lt;parse error&gt;&quot;;
5488              case token_type::end_of_input:
5489                  return &quot;end of input&quot;;
5490              case token_type::literal_or_value:
5491                  return &quot;&#x27;[&#x27;, &#x27;{&#x27;, or a literal&quot;;
5492              default: 
5493                  return &quot;unknown token&quot;;
5494          }
5495      }
5496  };
5497  template&lt;typename BasicJsonType, typename InputAdapterType&gt;
5498  class lexer : public lexer_base&lt;BasicJsonType&gt;
5499  {
5500      using number_integer_t = typename BasicJsonType::number_integer_t;
5501      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
5502      using number_float_t = typename BasicJsonType::number_float_t;
5503      using string_t = typename BasicJsonType::string_t;
5504      using char_type = typename InputAdapterType::char_type;
5505      using char_int_type = typename std::char_traits&lt;char_type&gt;::int_type;
5506    public:
5507      using token_type = typename lexer_base&lt;BasicJsonType&gt;::token_type;
5508      explicit lexer(InputAdapterType&amp;&amp; adapter, bool ignore_comments_ = false) noexcept
5509          : ia(std::move(adapter))
5510          , ignore_comments(ignore_comments_)
5511          , decimal_point_char(static_cast&lt;char_int_type&gt;(get_decimal_point()))
5512      {}
5513      lexer(const lexer&amp;) = delete;
5514      lexer(lexer&amp;&amp;) = default; 
5515      lexer&amp; operator=(lexer&amp;) = delete;
5516      lexer&amp; operator=(lexer&amp;&amp;) = default; 
5517      ~lexer() = default;
5518    private:
5519      JSON_HEDLEY_PURE
5520      static char get_decimal_point() noexcept
5521      {
5522          const auto* loc = localeconv();
5523          JSON_ASSERT(loc != nullptr);
5524          return (loc-&gt;decimal_point == nullptr) ? &#x27;.&#x27; : *(loc-&gt;decimal_point);
5525      }
5526      int get_codepoint()
5527      {
5528          JSON_ASSERT(current == &#x27;u&#x27;);
5529          int codepoint = 0;
5530          const auto factors = { 12u, 8u, 4u, 0u };
5531          for (const auto factor : factors)
5532          {
5533              get();
5534              if (current &gt;= &#x27;0&#x27; &amp;&amp; current &lt;= &#x27;9&#x27;)
5535              {
5536                  codepoint += static_cast&lt;int&gt;((static_cast&lt;unsigned int&gt;(current) - 0x30u) &lt;&lt; factor);
5537              }
5538              else if (current &gt;= &#x27;A&#x27; &amp;&amp; current &lt;= &#x27;F&#x27;)
5539              {
5540                  codepoint += static_cast&lt;int&gt;((static_cast&lt;unsigned int&gt;(current) - 0x37u) &lt;&lt; factor);
5541              }
5542              else if (current &gt;= &#x27;a&#x27; &amp;&amp; current &lt;= &#x27;f&#x27;)
5543              {
5544                  codepoint += static_cast&lt;int&gt;((static_cast&lt;unsigned int&gt;(current) - 0x57u) &lt;&lt; factor);
5545              }
5546              else
5547              {
5548                  return -1;
5549              }
5550          }
5551          JSON_ASSERT(0x0000 &lt;= codepoint &amp;&amp; codepoint &lt;= 0xFFFF);
5552          return codepoint;
5553      }
5554      bool next_byte_in_range(std::initializer_list&lt;char_int_type&gt; ranges)
5555      {
5556          JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
5557          add(current);
5558          for (auto range = ranges.begin(); range != ranges.end(); ++range)
5559          {
5560              get();
5561              if (JSON_HEDLEY_LIKELY(*range &lt;= current &amp;&amp; current &lt;= *(++range)))
5562              {
5563                  add(current);
5564              }
5565              else
5566              {
5567                  error_message = &quot;invalid string: ill-formed UTF-8 byte&quot;;
5568                  return false;
5569              }
5570          }
5571          return true;
5572      }
5573      token_type scan_string()
5574      {
5575          reset();
5576          JSON_ASSERT(current == &#x27;\&quot;&#x27;);
5577          while (true)
5578          {
5579              switch (get())
5580              {
5581                  case std::char_traits&lt;char_type&gt;::eof():
5582                  {
5583                      error_message = &quot;invalid string: missing closing quote&quot;;
5584                      return token_type::parse_error;
5585                  }
5586                  case &#x27;\&quot;&#x27;:
5587                  {
5588                      return token_type::value_string;
5589                  }
5590                  case &#x27;\\&#x27;:
5591                  {
5592                      switch (get())
5593                      {
5594                          case &#x27;\&quot;&#x27;:
5595                              add(&#x27;\&quot;&#x27;);
5596                              break;
5597                          case &#x27;\\&#x27;:
5598                              add(&#x27;\\&#x27;);
5599                              break;
5600                          case &#x27;/&#x27;:
5601                              add(&#x27;/&#x27;);
5602                              break;
5603                          case &#x27;b&#x27;:
5604                              add(&#x27;\b&#x27;);
5605                              break;
5606                          case &#x27;f&#x27;:
5607                              add(&#x27;\f&#x27;);
5608                              break;
5609                          case &#x27;n&#x27;:
5610                              add(&#x27;\n&#x27;);
5611                              break;
5612                          case &#x27;r&#x27;:
5613                              add(&#x27;\r&#x27;);
5614                              break;
5615                          case &#x27;t&#x27;:
5616                              add(&#x27;\t&#x27;);
5617                              break;
5618                          case &#x27;u&#x27;:
5619                          {
5620                              const int codepoint1 = get_codepoint();
5621                              int codepoint = codepoint1; 
5622                              if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
5623                              {
5624                                  error_message = &quot;invalid string: &#x27;\\u&#x27; must be followed by 4 hex digits&quot;;
5625                                  return token_type::parse_error;
5626                              }
5627                              if (0xD800 &lt;= codepoint1 &amp;&amp; codepoint1 &lt;= 0xDBFF)
5628                              {
5629                                  if (JSON_HEDLEY_LIKELY(get() == &#x27;\\&#x27; &amp;&amp; get() == &#x27;u&#x27;))
5630                                  {
5631                                      const int codepoint2 = get_codepoint();
5632                                      if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
5633                                      {
5634                                          error_message = &quot;invalid string: &#x27;\\u&#x27; must be followed by 4 hex digits&quot;;
5635                                          return token_type::parse_error;
5636                                      }
5637                                      if (JSON_HEDLEY_LIKELY(0xDC00 &lt;= codepoint2 &amp;&amp; codepoint2 &lt;= 0xDFFF))
5638                                      {
5639                                          codepoint = static_cast&lt;int&gt;(
5640                                                          (static_cast&lt;unsigned int&gt;(codepoint1) &lt;&lt; 10u)
5641                                                          + static_cast&lt;unsigned int&gt;(codepoint2)
5642                                                          - 0x35FDC00u);
5643                                      }
5644                                      else
5645                                      {
5646                                          error_message = &quot;invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF&quot;;
5647                                          return token_type::parse_error;
5648                                      }
5649                                  }
5650                                  else
5651                                  {
5652                                      error_message = &quot;invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF&quot;;
5653                                      return token_type::parse_error;
5654                                  }
5655                              }
5656                              else
5657                              {
5658                                  if (JSON_HEDLEY_UNLIKELY(0xDC00 &lt;= codepoint1 &amp;&amp; codepoint1 &lt;= 0xDFFF))
5659                                  {
5660                                      error_message = &quot;invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF&quot;;
5661                                      return token_type::parse_error;
5662                                  }
5663                              }
5664                              JSON_ASSERT(0x00 &lt;= codepoint &amp;&amp; codepoint &lt;= 0x10FFFF);
5665                              if (codepoint &lt; 0x80)
5666                              {
5667                                  add(static_cast&lt;char_int_type&gt;(codepoint));
5668                              }
5669                              else if (codepoint &lt;= 0x7FF)
5670                              {
5671                                  add(static_cast&lt;char_int_type&gt;(0xC0u | (static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 6u)));
5672                                  add(static_cast&lt;char_int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(codepoint) &amp; 0x3Fu)));
5673                              }
5674                              else if (codepoint &lt;= 0xFFFF)
5675                              {
5676                                  add(static_cast&lt;char_int_type&gt;(0xE0u | (static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 12u)));
5677                                  add(static_cast&lt;char_int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 6u) &amp; 0x3Fu)));
5678                                  add(static_cast&lt;char_int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(codepoint) &amp; 0x3Fu)));
5679                              }
5680                              else
5681                              {
5682                                  add(static_cast&lt;char_int_type&gt;(0xF0u | (static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 18u)));
5683                                  add(static_cast&lt;char_int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 12u) &amp; 0x3Fu)));
5684                                  add(static_cast&lt;char_int_type&gt;(0x80u | ((static_cast&lt;unsigned int&gt;(codepoint) &gt;&gt; 6u) &amp; 0x3Fu)));
5685                                  add(static_cast&lt;char_int_type&gt;(0x80u | (static_cast&lt;unsigned int&gt;(codepoint) &amp; 0x3Fu)));
5686                              }
5687                              break;
5688                          }
5689                          default:
5690                              error_message = &quot;invalid string: forbidden character after backslash&quot;;
5691                              return token_type::parse_error;
5692                      }
5693                      break;
5694                  }
5695                  case 0x00:
5696                  {
5697                      error_message = &quot;invalid string: control character U+0000 (NUL) must be escaped to \\u0000&quot;;
5698                      return token_type::parse_error;
5699                  }
5700                  case 0x01:
5701                  {
5702                      error_message = &quot;invalid string: control character U+0001 (SOH) must be escaped to \\u0001&quot;;
5703                      return token_type::parse_error;
5704                  }
5705                  case 0x02:
5706                  {
5707                      error_message = &quot;invalid string: control character U+0002 (STX) must be escaped to \\u0002&quot;;
5708                      return token_type::parse_error;
5709                  }
5710                  case 0x03:
5711                  {
5712                      error_message = &quot;invalid string: control character U+0003 (ETX) must be escaped to \\u0003&quot;;
5713                      return token_type::parse_error;
5714                  }
5715                  case 0x04:
5716                  {
5717                      error_message = &quot;invalid string: control character U+0004 (EOT) must be escaped to \\u0004&quot;;
5718                      return token_type::parse_error;
5719                  }
5720                  case 0x05:
5721                  {
5722                      error_message = &quot;invalid string: control character U+0005 (ENQ) must be escaped to \\u0005&quot;;
5723                      return token_type::parse_error;
5724                  }
5725                  case 0x06:
5726                  {
5727                      error_message = &quot;invalid string: control character U+0006 (ACK) must be escaped to \\u0006&quot;;
5728                      return token_type::parse_error;
5729                  }
5730                  case 0x07:
5731                  {
5732                      error_message = &quot;invalid string: control character U+0007 (BEL) must be escaped to \\u0007&quot;;
5733                      return token_type::parse_error;
5734                  }
5735                  case 0x08:
5736                  {
5737                      error_message = &quot;invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b&quot;;
5738                      return token_type::parse_error;
5739                  }
5740                  case 0x09:
5741                  {
5742                      error_message = &quot;invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t&quot;;
5743                      return token_type::parse_error;
5744                  }
5745                  case 0x0A:
5746                  {
5747                      error_message = &quot;invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n&quot;;
5748                      return token_type::parse_error;
5749                  }
5750                  case 0x0B:
5751                  {
5752                      error_message = &quot;invalid string: control character U+000B (VT) must be escaped to \\u000B&quot;;
5753                      return token_type::parse_error;
5754                  }
5755                  case 0x0C:
5756                  {
5757                      error_message = &quot;invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f&quot;;
5758                      return token_type::parse_error;
5759                  }
5760                  case 0x0D:
5761                  {
5762                      error_message = &quot;invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r&quot;;
5763                      return token_type::parse_error;
5764                  }
5765                  case 0x0E:
5766                  {
5767                      error_message = &quot;invalid string: control character U+000E (SO) must be escaped to \\u000E&quot;;
5768                      return token_type::parse_error;
5769                  }
5770                  case 0x0F:
5771                  {
5772                      error_message = &quot;invalid string: control character U+000F (SI) must be escaped to \\u000F&quot;;
5773                      return token_type::parse_error;
5774                  }
5775                  case 0x10:
5776                  {
5777                      error_message = &quot;invalid string: control character U+0010 (DLE) must be escaped to \\u0010&quot;;
5778                      return token_type::parse_error;
5779                  }
5780                  case 0x11:
5781                  {
5782                      error_message = &quot;invalid string: control character U+0011 (DC1) must be escaped to \\u0011&quot;;
5783                      return token_type::parse_error;
5784                  }
5785                  case 0x12:
5786                  {
5787                      error_message = &quot;invalid string: control character U+0012 (DC2) must be escaped to \\u0012&quot;;
5788                      return token_type::parse_error;
5789                  }
5790                  case 0x13:
5791                  {
5792                      error_message = &quot;invalid string: control character U+0013 (DC3) must be escaped to \\u0013&quot;;
5793                      return token_type::parse_error;
5794                  }
5795                  case 0x14:
5796                  {
5797                      error_message = &quot;invalid string: control character U+0014 (DC4) must be escaped to \\u0014&quot;;
5798                      return token_type::parse_error;
5799                  }
5800                  case 0x15:
5801                  {
5802                      error_message = &quot;invalid string: control character U+0015 (NAK) must be escaped to \\u0015&quot;;
5803                      return token_type::parse_error;
5804                  }
5805                  case 0x16:
5806                  {
5807                      error_message = &quot;invalid string: control character U+0016 (SYN) must be escaped to \\u0016&quot;;
5808                      return token_type::parse_error;
5809                  }
5810                  case 0x17:
5811                  {
5812                      error_message = &quot;invalid string: control character U+0017 (ETB) must be escaped to \\u0017&quot;;
5813                      return token_type::parse_error;
5814                  }
5815                  case 0x18:
5816                  {
5817                      error_message = &quot;invalid string: control character U+0018 (CAN) must be escaped to \\u0018&quot;;
5818                      return token_type::parse_error;
5819                  }
5820                  case 0x19:
5821                  {
5822                      error_message = &quot;invalid string: control character U+0019 (EM) must be escaped to \\u0019&quot;;
5823                      return token_type::parse_error;
5824                  }
5825                  case 0x1A:
5826                  {
5827                      error_message = &quot;invalid string: control character U+001A (SUB) must be escaped to \\u001A&quot;;
5828                      return token_type::parse_error;
5829                  }
5830                  case 0x1B:
5831                  {
5832                      error_message = &quot;invalid string: control character U+001B (ESC) must be escaped to \\u001B&quot;;
5833                      return token_type::parse_error;
5834                  }
5835                  case 0x1C:
5836                  {
5837                      error_message = &quot;invalid string: control character U+001C (FS) must be escaped to \\u001C&quot;;
5838                      return token_type::parse_error;
5839                  }
5840                  case 0x1D:
5841                  {
5842                      error_message = &quot;invalid string: control character U+001D (GS) must be escaped to \\u001D&quot;;
5843                      return token_type::parse_error;
5844                  }
5845                  case 0x1E:
5846                  {
5847                      error_message = &quot;invalid string: control character U+001E (RS) must be escaped to \\u001E&quot;;
5848                      return token_type::parse_error;
5849                  }
5850                  case 0x1F:
5851                  {
5852                      error_message = &quot;invalid string: control character U+001F (US) must be escaped to \\u001F&quot;;
5853                      return token_type::parse_error;
5854                  }
5855                  case 0x20:
5856                  case 0x21:
5857                  case 0x23:
5858                  case 0x24:
5859                  case 0x25:
5860                  case 0x26:
5861                  case 0x27:
5862                  case 0x28:
5863                  case 0x29:
5864                  case 0x2A:
5865                  case 0x2B:
5866                  case 0x2C:
5867                  case 0x2D:
5868                  case 0x2E:
5869                  case 0x2F:
5870                  case 0x30:
5871                  case 0x31:
5872                  case 0x32:
5873                  case 0x33:
5874                  case 0x34:
5875                  case 0x35:
5876                  case 0x36:
5877                  case 0x37:
5878                  case 0x38:
5879                  case 0x39:
5880                  case 0x3A:
5881                  case 0x3B:
5882                  case 0x3C:
5883                  case 0x3D:
5884                  case 0x3E:
5885                  case 0x3F:
5886                  case 0x40:
5887                  case 0x41:
5888                  case 0x42:
5889                  case 0x43:
5890                  case 0x44:
5891                  case 0x45:
5892                  case 0x46:
5893                  case 0x47:
5894                  case 0x48:
5895                  case 0x49:
5896                  case 0x4A:
5897                  case 0x4B:
5898                  case 0x4C:
5899                  case 0x4D:
5900                  case 0x4E:
5901                  case 0x4F:
5902                  case 0x50:
5903                  case 0x51:
5904                  case 0x52:
5905                  case 0x53:
5906                  case 0x54:
5907                  case 0x55:
5908                  case 0x56:
5909                  case 0x57:
5910                  case 0x58:
5911                  case 0x59:
5912                  case 0x5A:
5913                  case 0x5B:
5914                  case 0x5D:
5915                  case 0x5E:
5916                  case 0x5F:
5917                  case 0x60:
5918                  case 0x61:
5919                  case 0x62:
5920                  case 0x63:
5921                  case 0x64:
5922                  case 0x65:
5923                  case 0x66:
5924                  case 0x67:
5925                  case 0x68:
5926                  case 0x69:
5927                  case 0x6A:
5928                  case 0x6B:
5929                  case 0x6C:
5930                  case 0x6D:
5931                  case 0x6E:
5932                  case 0x6F:
5933                  case 0x70:
5934                  case 0x71:
5935                  case 0x72:
5936                  case 0x73:
5937                  case 0x74:
5938                  case 0x75:
5939                  case 0x76:
5940                  case 0x77:
5941                  case 0x78:
5942                  case 0x79:
5943                  case 0x7A:
5944                  case 0x7B:
5945                  case 0x7C:
5946                  case 0x7D:
5947                  case 0x7E:
5948                  case 0x7F:
5949                  {
5950                      add(current);
5951                      break;
5952                  }
5953                  case 0xC2:
5954                  case 0xC3:
5955                  case 0xC4:
5956                  case 0xC5:
5957                  case 0xC6:
5958                  case 0xC7:
5959                  case 0xC8:
5960                  case 0xC9:
5961                  case 0xCA:
5962                  case 0xCB:
5963                  case 0xCC:
5964                  case 0xCD:
5965                  case 0xCE:
5966                  case 0xCF:
5967                  case 0xD0:
5968                  case 0xD1:
5969                  case 0xD2:
5970                  case 0xD3:
5971                  case 0xD4:
5972                  case 0xD5:
5973                  case 0xD6:
5974                  case 0xD7:
5975                  case 0xD8:
5976                  case 0xD9:
5977                  case 0xDA:
5978                  case 0xDB:
5979                  case 0xDC:
5980                  case 0xDD:
5981                  case 0xDE:
5982                  case 0xDF:
5983                  {
5984                      if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
5985                      {
5986                          return token_type::parse_error;
5987                      }
5988                      break;
5989                  }
5990                  case 0xE0:
5991                  {
5992                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
5993                      {
5994                          return token_type::parse_error;
5995                      }
5996                      break;
5997                  }
5998                  case 0xE1:
5999                  case 0xE2:
6000                  case 0xE3:
6001                  case 0xE4:
6002                  case 0xE5:
6003                  case 0xE6:
6004                  case 0xE7:
6005                  case 0xE8:
6006                  case 0xE9:
6007                  case 0xEA:
6008                  case 0xEB:
6009                  case 0xEC:
6010                  case 0xEE:
6011                  case 0xEF:
6012                  {
6013                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
6014                      {
6015                          return token_type::parse_error;
6016                      }
6017                      break;
6018                  }
6019                  case 0xED:
6020                  {
6021                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
6022                      {
6023                          return token_type::parse_error;
6024                      }
6025                      break;
6026                  }
6027                  case 0xF0:
6028                  {
6029                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
6030                      {
6031                          return token_type::parse_error;
6032                      }
6033                      break;
6034                  }
6035                  case 0xF1:
6036                  case 0xF2:
6037                  case 0xF3:
6038                  {
6039                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
6040                      {
6041                          return token_type::parse_error;
6042                      }
6043                      break;
6044                  }
6045                  case 0xF4:
6046                  {
6047                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
6048                      {
6049                          return token_type::parse_error;
6050                      }
6051                      break;
6052                  }
6053                  default:
6054                  {
6055                      error_message = &quot;invalid string: ill-formed UTF-8 byte&quot;;
6056                      return token_type::parse_error;
6057                  }
6058              }
6059          }
6060      }
6061      bool scan_comment()
6062      {
6063          switch (get())
6064          {
6065              case &#x27;/&#x27;:
6066              {
6067                  while (true)
6068                  {
6069                      switch (get())
6070                      {
6071                          case &#x27;\n&#x27;:
6072                          case &#x27;\r&#x27;:
6073                          case std::char_traits&lt;char_type&gt;::eof():
6074                          case &#x27;\0&#x27;:
6075                              return true;
6076                          default:
6077                              break;
6078                      }
6079                  }
6080              }
6081              case &#x27;*&#x27;:
6082              {
6083                  while (true)
6084                  {
6085                      switch (get())
6086                      {
6087                          case std::char_traits&lt;char_type&gt;::eof():
6088                          case &#x27;\0&#x27;:
6089                          {
6090                              error_message = &quot;invalid comment; missing closing &#x27;*/&#x27;&quot;;
6091                              return false;
6092                          }
6093                          case &#x27;*&#x27;:
6094                          {
6095                              switch (get())
6096                              {
6097                                  case &#x27;/&#x27;:
6098                                      return true;
6099                                  default:
6100                                  {
6101                                      unget();
6102                                      continue;
6103                                  }
6104                              }
6105                          }
6106                          default:
6107                              continue;
6108                      }
6109                  }
6110              }
6111              default:
6112              {
6113                  error_message = &quot;invalid comment; expecting &#x27;/&#x27; or &#x27;*&#x27; after &#x27;/&#x27;&quot;;
6114                  return false;
6115              }
6116          }
6117      }
6118      JSON_HEDLEY_NON_NULL(2)
6119      static void strtof(float&amp; f, const char* str, char** endptr) noexcept
6120      {
6121          f = std::strtof(str, endptr);
6122      }
6123      JSON_HEDLEY_NON_NULL(2)
6124      static void strtof(double&amp; f, const char* str, char** endptr) noexcept
6125      {
6126          f = std::strtod(str, endptr);
6127      }
6128      JSON_HEDLEY_NON_NULL(2)
6129      static void strtof(long double&amp; f, const char* str, char** endptr) noexcept
6130      {
6131          f = std::strtold(str, endptr);
6132      }
6133      token_type scan_number()  
6134      {
6135          reset();
6136          token_type number_type = token_type::value_unsigned;
6137          switch (current)
6138          {
6139              case &#x27;-&#x27;:
6140              {
6141                  add(current);
6142                  goto scan_number_minus;
6143              }
6144              case &#x27;0&#x27;:
6145              {
6146                  add(current);
6147                  goto scan_number_zero;
6148              }
6149              case &#x27;1&#x27;:
6150              case &#x27;2&#x27;:
6151              case &#x27;3&#x27;:
6152              case &#x27;4&#x27;:
6153              case &#x27;5&#x27;:
6154              case &#x27;6&#x27;:
6155              case &#x27;7&#x27;:
6156              case &#x27;8&#x27;:
6157              case &#x27;9&#x27;:
6158              {
6159                  add(current);
6160                  goto scan_number_any1;
6161              }
6162              default:            
6163                  JSON_ASSERT(false); 
6164          }
6165  scan_number_minus:
6166          number_type = token_type::value_integer;
6167          switch (get())
6168          {
6169              case &#x27;0&#x27;:
6170              {
6171                  add(current);
6172                  goto scan_number_zero;
6173              }
6174              case &#x27;1&#x27;:
6175              case &#x27;2&#x27;:
6176              case &#x27;3&#x27;:
6177              case &#x27;4&#x27;:
6178              case &#x27;5&#x27;:
6179              case &#x27;6&#x27;:
6180              case &#x27;7&#x27;:
6181              case &#x27;8&#x27;:
6182              case &#x27;9&#x27;:
6183              {
6184                  add(current);
6185                  goto scan_number_any1;
6186              }
6187              default:
6188              {
6189                  error_message = &quot;invalid number; expected digit after &#x27;-&#x27;&quot;;
6190                  return token_type::parse_error;
6191              }
6192          }
6193  scan_number_zero:
6194          switch (get())
6195          {
6196              case &#x27;.&#x27;:
6197              {
6198                  add(decimal_point_char);
6199                  goto scan_number_decimal1;
6200              }
6201              case &#x27;e&#x27;:
6202              case &#x27;E&#x27;:
6203              {
6204                  add(current);
6205                  goto scan_number_exponent;
6206              }
6207              default:
6208                  goto scan_number_done;
6209          }
6210  scan_number_any1:
6211          switch (get())
6212          {
6213              case &#x27;0&#x27;:
6214              case &#x27;1&#x27;:
6215              case &#x27;2&#x27;:
6216              case &#x27;3&#x27;:
6217              case &#x27;4&#x27;:
6218              case &#x27;5&#x27;:
6219              case &#x27;6&#x27;:
6220              case &#x27;7&#x27;:
6221              case &#x27;8&#x27;:
6222              case &#x27;9&#x27;:
6223              {
6224                  add(current);
6225                  goto scan_number_any1;
6226              }
6227              case &#x27;.&#x27;:
6228              {
6229                  add(decimal_point_char);
6230                  goto scan_number_decimal1;
6231              }
6232              case &#x27;e&#x27;:
6233              case &#x27;E&#x27;:
6234              {
6235                  add(current);
6236                  goto scan_number_exponent;
6237              }
6238              default:
6239                  goto scan_number_done;
6240          }
6241  scan_number_decimal1:
6242          number_type = token_type::value_float;
6243          switch (get())
6244          {
6245              case &#x27;0&#x27;:
6246              case &#x27;1&#x27;:
6247              case &#x27;2&#x27;:
6248              case &#x27;3&#x27;:
6249              case &#x27;4&#x27;:
6250              case &#x27;5&#x27;:
6251              case &#x27;6&#x27;:
6252              case &#x27;7&#x27;:
6253              case &#x27;8&#x27;:
6254              case &#x27;9&#x27;:
6255              {
6256                  add(current);
6257                  goto scan_number_decimal2;
6258              }
6259              default:
6260              {
6261                  error_message = &quot;invalid number; expected digit after &#x27;.&#x27;&quot;;
6262                  return token_type::parse_error;
6263              }
6264          }
6265  scan_number_decimal2:
6266          switch (get())
6267          {
6268              case &#x27;0&#x27;:
6269              case &#x27;1&#x27;:
6270              case &#x27;2&#x27;:
6271              case &#x27;3&#x27;:
6272              case &#x27;4&#x27;:
6273              case &#x27;5&#x27;:
6274              case &#x27;6&#x27;:
6275              case &#x27;7&#x27;:
6276              case &#x27;8&#x27;:
6277              case &#x27;9&#x27;:
6278              {
6279                  add(current);
6280                  goto scan_number_decimal2;
6281              }
6282              case &#x27;e&#x27;:
6283              case &#x27;E&#x27;:
6284              {
6285                  add(current);
6286                  goto scan_number_exponent;
6287              }
6288              default:
6289                  goto scan_number_done;
6290          }
6291  scan_number_exponent:
6292          number_type = token_type::value_float;
6293          switch (get())
6294          {
6295              case &#x27;+&#x27;:
6296              case &#x27;-&#x27;:
6297              {
6298                  add(current);
6299                  goto scan_number_sign;
6300              }
6301              case &#x27;0&#x27;:
6302              case &#x27;1&#x27;:
6303              case &#x27;2&#x27;:
6304              case &#x27;3&#x27;:
6305              case &#x27;4&#x27;:
6306              case &#x27;5&#x27;:
6307              case &#x27;6&#x27;:
6308              case &#x27;7&#x27;:
6309              case &#x27;8&#x27;:
6310              case &#x27;9&#x27;:
6311              {
6312                  add(current);
6313                  goto scan_number_any2;
6314              }
6315              default:
6316              {
6317                  error_message =
6318                      &quot;invalid number; expected &#x27;+&#x27;, &#x27;-&#x27;, or digit after exponent&quot;;
6319                  return token_type::parse_error;
6320              }
6321          }
6322  scan_number_sign:
6323          switch (get())
6324          {
6325              case &#x27;0&#x27;:
6326              case &#x27;1&#x27;:
6327              case &#x27;2&#x27;:
6328              case &#x27;3&#x27;:
6329              case &#x27;4&#x27;:
6330              case &#x27;5&#x27;:
6331              case &#x27;6&#x27;:
6332              case &#x27;7&#x27;:
6333              case &#x27;8&#x27;:
6334              case &#x27;9&#x27;:
6335              {
6336                  add(current);
6337                  goto scan_number_any2;
6338              }
6339              default:
6340              {
6341                  error_message = &quot;invalid number; expected digit after exponent sign&quot;;
6342                  return token_type::parse_error;
6343              }
6344          }
6345  scan_number_any2:
6346          switch (get())
6347          {
6348              case &#x27;0&#x27;:
6349              case &#x27;1&#x27;:
6350              case &#x27;2&#x27;:
6351              case &#x27;3&#x27;:
6352              case &#x27;4&#x27;:
6353              case &#x27;5&#x27;:
6354              case &#x27;6&#x27;:
6355              case &#x27;7&#x27;:
6356              case &#x27;8&#x27;:
6357              case &#x27;9&#x27;:
6358              {
6359                  add(current);
6360                  goto scan_number_any2;
6361              }
6362              default:
6363                  goto scan_number_done;
6364          }
6365  scan_number_done:
6366          unget();
6367          char* endptr = nullptr; 
6368          errno = 0;
6369          if (number_type == token_type::value_unsigned)
6370          {
6371              const auto x = std::strtoull(token_buffer.data(), &amp;endptr, 10);
6372              JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
6373              if (errno == 0)
6374              {
6375                  value_unsigned = static_cast&lt;number_unsigned_t&gt;(x);
6376                  if (value_unsigned == x)
6377                  {
6378                      return token_type::value_unsigned;
6379                  }
6380              }
6381          }
6382          else if (number_type == token_type::value_integer)
6383          {
6384              const auto x = std::strtoll(token_buffer.data(), &amp;endptr, 10);
6385              JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
6386              if (errno == 0)
6387              {
6388                  value_integer = static_cast&lt;number_integer_t&gt;(x);
6389                  if (value_integer == x)
6390                  {
6391                      return token_type::value_integer;
6392                  }
6393              }
6394          }
6395          strtof(value_float, token_buffer.data(), &amp;endptr);
6396          JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
6397          return token_type::value_float;
6398      }
6399      JSON_HEDLEY_NON_NULL(2)
6400      token_type scan_literal(const char_type* literal_text, const std::size_t length,
6401                              token_type return_type)
6402      {
6403          JSON_ASSERT(std::char_traits&lt;char_type&gt;::to_char_type(current) == literal_text[0]);
6404          for (std::size_t i = 1; i &lt; length; ++i)
6405          {
6406              if (JSON_HEDLEY_UNLIKELY(std::char_traits&lt;char_type&gt;::to_char_type(get()) != literal_text[i]))
6407              {
6408                  error_message = &quot;invalid literal&quot;;
6409                  return token_type::parse_error;
6410              }
6411          }
6412          return return_type;
6413      }
6414      void reset() noexcept
6415      {
6416          token_buffer.clear();
6417          token_string.clear();
6418          token_string.push_back(std::char_traits&lt;char_type&gt;::to_char_type(current));
6419      }
6420      char_int_type get()
6421      {
6422          ++position.chars_read_total;
6423          ++position.chars_read_current_line;
6424          if (next_unget)
6425          {
6426              next_unget = false;
6427          }
6428          else
6429          {
6430              current = ia.get_character();
6431          }
6432          if (JSON_HEDLEY_LIKELY(current != std::char_traits&lt;char_type&gt;::eof()))
6433          {
6434              token_string.push_back(std::char_traits&lt;char_type&gt;::to_char_type(current));
6435          }
6436          if (current == &#x27;\n&#x27;)
6437          {
6438              ++position.lines_read;
6439              position.chars_read_current_line = 0;
6440          }
6441          return current;
6442      }
6443      void unget()
6444      {
6445          next_unget = true;
6446          --position.chars_read_total;
6447          if (position.chars_read_current_line == 0)
6448          {
6449              if (position.lines_read &gt; 0)
6450              {
6451                  --position.lines_read;
6452              }
6453          }
6454          else
6455          {
6456              --position.chars_read_current_line;
6457          }
6458          if (JSON_HEDLEY_LIKELY(current != std::char_traits&lt;char_type&gt;::eof()))
6459          {
6460              JSON_ASSERT(!token_string.empty());
6461              token_string.pop_back();
6462          }
6463      }
6464      void add(char_int_type c)
6465      {
6466          token_buffer.push_back(static_cast&lt;typename string_t::value_type&gt;(c));
6467      }
6468    public:
6469      constexpr number_integer_t get_number_integer() const noexcept
6470      {
6471          return value_integer;
6472      }
6473      constexpr number_unsigned_t get_number_unsigned() const noexcept
6474      {
6475          return value_unsigned;
6476      }
6477      constexpr number_float_t get_number_float() const noexcept
6478      {
6479          return value_float;
6480      }
6481      string_t&amp; get_string()
6482      {
6483          return token_buffer;
6484      }
6485      constexpr position_t get_position() const noexcept
6486      {
6487          return position;
6488      }
6489      std::string get_token_string() const
6490      {
6491          std::string result;
6492          for (const auto c : token_string)
6493          {
6494              if (static_cast&lt;unsigned char&gt;(c) &lt;= &#x27;\x1F&#x27;)
6495              {
6496                  std::array&lt;char, 9&gt; cs{{}};
6497                  static_cast&lt;void&gt;((std::snprintf)(cs.data(), cs.size(), &quot;&lt;U+%.4X&gt;&quot;, static_cast&lt;unsigned char&gt;(c))); 
6498                  result += cs.data();
6499              }
6500              else
6501              {
6502                  result.push_back(static_cast&lt;std::string::value_type&gt;(c));
6503              }
6504          }
6505          return result;
6506      }
6507      JSON_HEDLEY_RETURNS_NON_NULL
6508      constexpr const char* get_error_message() const noexcept
6509      {
6510          return error_message;
6511      }
6512      bool skip_bom()
6513      {
6514          if (get() == 0xEF)
6515          {
6516              return get() == 0xBB &amp;&amp; get() == 0xBF;
6517          }
6518          unget();
6519          return true;
6520      }
6521      void skip_whitespace()
6522      {
6523          do
6524          {
6525              get();
6526          }
6527          while (current == &#x27; &#x27; || current == &#x27;\t&#x27; || current == &#x27;\n&#x27; || current == &#x27;\r&#x27;);
6528      }
6529      token_type scan()
6530      {
6531          if (position.chars_read_total == 0 &amp;&amp; !skip_bom())
6532          {
6533              error_message = &quot;invalid BOM; must be 0xEF 0xBB 0xBF if given&quot;;
6534              return token_type::parse_error;
6535          }
6536          skip_whitespace();
6537          while (ignore_comments &amp;&amp; current == &#x27;/&#x27;)
6538          {
6539              if (!scan_comment())
6540              {
6541                  return token_type::parse_error;
6542              }
6543              skip_whitespace();
6544          }
6545          switch (current)
6546          {
6547              case &#x27;[&#x27;:
6548                  return token_type::begin_array;
6549              case &#x27;]&#x27;:
6550                  return token_type::end_array;
6551              case &#x27;{&#x27;:
6552                  return token_type::begin_object;
6553              case &#x27;}&#x27;:
6554                  return token_type::end_object;
6555              case &#x27;:&#x27;:
6556                  return token_type::name_separator;
6557              case &#x27;,&#x27;:
6558                  return token_type::value_separator;
6559              case &#x27;t&#x27;:
6560              {
6561                  std::array&lt;char_type, 4&gt; true_literal = {{static_cast&lt;char_type&gt;(&#x27;t&#x27;), static_cast&lt;char_type&gt;(&#x27;r&#x27;), static_cast&lt;char_type&gt;(&#x27;u&#x27;), static_cast&lt;char_type&gt;(&#x27;e&#x27;)}};
6562                  return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
6563              }
6564              case &#x27;f&#x27;:
6565              {
6566                  std::array&lt;char_type, 5&gt; false_literal = {{static_cast&lt;char_type&gt;(&#x27;f&#x27;), static_cast&lt;char_type&gt;(&#x27;a&#x27;), static_cast&lt;char_type&gt;(&#x27;l&#x27;), static_cast&lt;char_type&gt;(&#x27;s&#x27;), static_cast&lt;char_type&gt;(&#x27;e&#x27;)}};
6567                  return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
6568              }
6569              case &#x27;n&#x27;:
6570              {
6571                  std::array&lt;char_type, 4&gt; null_literal = {{static_cast&lt;char_type&gt;(&#x27;n&#x27;), static_cast&lt;char_type&gt;(&#x27;u&#x27;), static_cast&lt;char_type&gt;(&#x27;l&#x27;), static_cast&lt;char_type&gt;(&#x27;l&#x27;)}};
6572                  return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
6573              }
6574              case &#x27;\&quot;&#x27;:
6575                  return scan_string();
6576              case &#x27;-&#x27;:
6577              case &#x27;0&#x27;:
6578              case &#x27;1&#x27;:
6579              case &#x27;2&#x27;:
6580              case &#x27;3&#x27;:
6581              case &#x27;4&#x27;:
6582              case &#x27;5&#x27;:
6583              case &#x27;6&#x27;:
6584              case &#x27;7&#x27;:
6585              case &#x27;8&#x27;:
6586              case &#x27;9&#x27;:
6587                  return scan_number();
6588              case &#x27;\0&#x27;:
6589              case std::char_traits&lt;char_type&gt;::eof():
6590                  return token_type::end_of_input;
6591              default:
6592                  error_message = &quot;invalid literal&quot;;
6593                  return token_type::parse_error;
6594          }
6595      }
6596    private:
6597      InputAdapterType ia;
6598      const bool ignore_comments = false;
6599      char_int_type current = std::char_traits&lt;char_type&gt;::eof();
6600      bool next_unget = false;
6601      position_t position {};
6602      std::vector&lt;char_type&gt; token_string {};
6603      string_t token_buffer {};
6604      const char* error_message = &quot;&quot;;
6605      number_integer_t value_integer = 0;
6606      number_unsigned_t value_unsigned = 0;
6607      number_float_t value_float = 0;
6608      const char_int_type decimal_point_char = &#x27;.&#x27;;
6609  };
6610  }  
6611  NLOHMANN_JSON_NAMESPACE_END
6612  #include &lt;cstdint&gt; 
6613  #include &lt;utility&gt; 
6614  #include &lt;string&gt; 
6615  NLOHMANN_JSON_NAMESPACE_BEGIN
6616  namespace detail
6617  {
6618  template&lt;typename T&gt;
6619  using null_function_t = decltype(std::declval&lt;T&amp;&gt;().null());
6620  template&lt;typename T&gt;
6621  using boolean_function_t =
6622      decltype(std::declval&lt;T&amp;&gt;().boolean(std::declval&lt;bool&gt;()));
6623  template&lt;typename T, typename Integer&gt;
6624  using number_integer_function_t =
6625      decltype(std::declval&lt;T&amp;&gt;().number_integer(std::declval&lt;Integer&gt;()));
6626  template&lt;typename T, typename Unsigned&gt;
6627  using number_unsigned_function_t =
6628      decltype(std::declval&lt;T&amp;&gt;().number_unsigned(std::declval&lt;Unsigned&gt;()));
6629  template&lt;typename T, typename Float, typename String&gt;
6630  using number_float_function_t = decltype(std::declval&lt;T&amp;&gt;().number_float(
6631                                      std::declval&lt;Float&gt;(), std::declval&lt;const String&amp;&gt;()));
6632  template&lt;typename T, typename String&gt;
6633  using string_function_t =
6634      decltype(std::declval&lt;T&amp;&gt;().string(std::declval&lt;String&amp;&gt;()));
6635  template&lt;typename T, typename Binary&gt;
6636  using binary_function_t =
6637      decltype(std::declval&lt;T&amp;&gt;().binary(std::declval&lt;Binary&amp;&gt;()));
6638  template&lt;typename T&gt;
6639  using start_object_function_t =
6640      decltype(std::declval&lt;T&amp;&gt;().start_object(std::declval&lt;std::size_t&gt;()));
6641  template&lt;typename T, typename String&gt;
6642  using key_function_t =
6643      decltype(std::declval&lt;T&amp;&gt;().key(std::declval&lt;String&amp;&gt;()));
6644  template&lt;typename T&gt;
6645  using end_object_function_t = decltype(std::declval&lt;T&amp;&gt;().end_object());
6646  template&lt;typename T&gt;
6647  using start_array_function_t =
6648      decltype(std::declval&lt;T&amp;&gt;().start_array(std::declval&lt;std::size_t&gt;()));
6649  template&lt;typename T&gt;
6650  using end_array_function_t = decltype(std::declval&lt;T&amp;&gt;().end_array());
6651  template&lt;typename T, typename Exception&gt;
6652  using parse_error_function_t = decltype(std::declval&lt;T&amp;&gt;().parse_error(
6653          std::declval&lt;std::size_t&gt;(), std::declval&lt;const std::string&amp;&gt;(),
6654          std::declval&lt;const Exception&amp;&gt;()));
6655  template&lt;typename SAX, typename BasicJsonType&gt;
6656  struct is_sax
6657  {
6658    private:
6659      static_assert(is_basic_json&lt;BasicJsonType&gt;::value,
6660                    &quot;BasicJsonType must be of type basic_json&lt;...&gt;&quot;);
6661      using number_integer_t = typename BasicJsonType::number_integer_t;
6662      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6663      using number_float_t = typename BasicJsonType::number_float_t;
6664      using string_t = typename BasicJsonType::string_t;
6665      using binary_t = typename BasicJsonType::binary_t;
6666      using exception_t = typename BasicJsonType::exception;
6667    public:
6668      static constexpr bool value =
6669          is_detected_exact&lt;bool, null_function_t, SAX&gt;::value &amp;&amp;
6670          is_detected_exact&lt;bool, boolean_function_t, SAX&gt;::value &amp;&amp;
6671          is_detected_exact&lt;bool, number_integer_function_t, SAX, number_integer_t&gt;::value &amp;&amp;
6672          is_detected_exact&lt;bool, number_unsigned_function_t, SAX, number_unsigned_t&gt;::value &amp;&amp;
6673          is_detected_exact&lt;bool, number_float_function_t, SAX, number_float_t, string_t&gt;::value &amp;&amp;
6674          is_detected_exact&lt;bool, string_function_t, SAX, string_t&gt;::value &amp;&amp;
6675          is_detected_exact&lt;bool, binary_function_t, SAX, binary_t&gt;::value &amp;&amp;
6676          is_detected_exact&lt;bool, start_object_function_t, SAX&gt;::value &amp;&amp;
6677          is_detected_exact&lt;bool, key_function_t, SAX, string_t&gt;::value &amp;&amp;
6678          is_detected_exact&lt;bool, end_object_function_t, SAX&gt;::value &amp;&amp;
6679          is_detected_exact&lt;bool, start_array_function_t, SAX&gt;::value &amp;&amp;
6680          is_detected_exact&lt;bool, end_array_function_t, SAX&gt;::value &amp;&amp;
6681          is_detected_exact&lt;bool, parse_error_function_t, SAX, exception_t&gt;::value;
6682  };
6683  template&lt;typename SAX, typename BasicJsonType&gt;
6684  struct is_sax_static_asserts
6685  {
6686    private:
6687      static_assert(is_basic_json&lt;BasicJsonType&gt;::value,
6688                    &quot;BasicJsonType must be of type basic_json&lt;...&gt;&quot;);
6689      using number_integer_t = typename BasicJsonType::number_integer_t;
6690      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6691      using number_float_t = typename BasicJsonType::number_float_t;
6692      using string_t = typename BasicJsonType::string_t;
6693      using binary_t = typename BasicJsonType::binary_t;
6694      using exception_t = typename BasicJsonType::exception;
6695    public:
6696      static_assert(is_detected_exact&lt;bool, null_function_t, SAX&gt;::value,
6697                    &quot;Missing/invalid function: bool null()&quot;);
6698      static_assert(is_detected_exact&lt;bool, boolean_function_t, SAX&gt;::value,
6699                    &quot;Missing/invalid function: bool boolean(bool)&quot;);
6700      static_assert(is_detected_exact&lt;bool, boolean_function_t, SAX&gt;::value,
6701                    &quot;Missing/invalid function: bool boolean(bool)&quot;);
6702      static_assert(
6703          is_detected_exact&lt;bool, number_integer_function_t, SAX,
6704          number_integer_t&gt;::value,
6705          &quot;Missing/invalid function: bool number_integer(number_integer_t)&quot;);
6706      static_assert(
6707          is_detected_exact&lt;bool, number_unsigned_function_t, SAX,
6708          number_unsigned_t&gt;::value,
6709          &quot;Missing/invalid function: bool number_unsigned(number_unsigned_t)&quot;);
6710      static_assert(is_detected_exact&lt;bool, number_float_function_t, SAX,
6711                    number_float_t, string_t&gt;::value,
6712                    &quot;Missing/invalid function: bool number_float(number_float_t, const string_t&amp;)&quot;);
6713      static_assert(
6714          is_detected_exact&lt;bool, string_function_t, SAX, string_t&gt;::value,
6715          &quot;Missing/invalid function: bool string(string_t&amp;)&quot;);
6716      static_assert(
6717          is_detected_exact&lt;bool, binary_function_t, SAX, binary_t&gt;::value,
6718          &quot;Missing/invalid function: bool binary(binary_t&amp;)&quot;);
6719      static_assert(is_detected_exact&lt;bool, start_object_function_t, SAX&gt;::value,
6720                    &quot;Missing/invalid function: bool start_object(std::size_t)&quot;);
6721      static_assert(is_detected_exact&lt;bool, key_function_t, SAX, string_t&gt;::value,
6722                    &quot;Missing/invalid function: bool key(string_t&amp;)&quot;);
6723      static_assert(is_detected_exact&lt;bool, end_object_function_t, SAX&gt;::value,
6724                    &quot;Missing/invalid function: bool end_object()&quot;);
6725      static_assert(is_detected_exact&lt;bool, start_array_function_t, SAX&gt;::value,
6726                    &quot;Missing/invalid function: bool start_array(std::size_t)&quot;);
6727      static_assert(is_detected_exact&lt;bool, end_array_function_t, SAX&gt;::value,
6728                    &quot;Missing/invalid function: bool end_array()&quot;);
6729      static_assert(
6730          is_detected_exact&lt;bool, parse_error_function_t, SAX, exception_t&gt;::value,
6731          &quot;Missing/invalid function: bool parse_error(std::size_t, const &quot;
6732          &quot;std::string&amp;, const exception&amp;)&quot;);
6733  };
6734  }  
6735  NLOHMANN_JSON_NAMESPACE_END
6736  NLOHMANN_JSON_NAMESPACE_BEGIN
6737  namespace detail
6738  {
6739  enum class cbor_tag_handler_t
6740  {
6741      error,   
6742      ignore,  
6743      store    
6744  };
6745  static inline bool little_endianness(int num = 1) noexcept
6746  {
6747      return *reinterpret_cast&lt;char*&gt;(&amp;num) == 1;
6748  }
6749  template&lt;typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser&lt;BasicJsonType&gt;&gt;
6750  class binary_reader
6751  {
6752      using number_integer_t = typename BasicJsonType::number_integer_t;
6753      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6754      using number_float_t = typename BasicJsonType::number_float_t;
6755      using string_t = typename BasicJsonType::string_t;
6756      using binary_t = typename BasicJsonType::binary_t;
6757      using json_sax_t = SAX;
6758      using char_type = typename InputAdapterType::char_type;
6759      using char_int_type = typename std::char_traits&lt;char_type&gt;::int_type;
6760    public:
6761      explicit binary_reader(InputAdapterType&amp;&amp; adapter, const input_format_t format = input_format_t::json) noexcept : ia(std::move(adapter)), input_format(format)
6762      {
6763          (void)detail::is_sax_static_asserts&lt;SAX, BasicJsonType&gt; {};
6764      }
6765      binary_reader(const binary_reader&amp;) = delete;
6766      binary_reader(binary_reader&amp;&amp;) = default; 
6767      binary_reader&amp; operator=(const binary_reader&amp;) = delete;
6768      binary_reader&amp; operator=(binary_reader&amp;&amp;) = default; 
6769      ~binary_reader() = default;
6770      JSON_HEDLEY_NON_NULL(3)
6771      bool sax_parse(const input_format_t format,
6772                     json_sax_t* sax_,
6773                     const bool strict = true,
6774                     const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
6775      {
6776          sax = sax_;
6777          bool result = false;
6778          switch (format)
6779          {
6780              case input_format_t::bson:
6781                  result = parse_bson_internal();
6782                  break;
6783              case input_format_t::cbor:
6784                  result = parse_cbor_internal(true, tag_handler);
6785                  break;
6786              case input_format_t::msgpack:
6787                  result = parse_msgpack_internal();
6788                  break;
6789              case input_format_t::ubjson:
6790              case input_format_t::bjdata:
6791                  result = parse_ubjson_internal();
6792                  break;
6793              case input_format_t::json: 
6794              default:            
6795                  JSON_ASSERT(false); 
6796          }
6797          if (result &amp;&amp; strict)
6798          {
6799              if (input_format == input_format_t::ubjson || input_format == input_format_t::bjdata)
6800              {
6801                  get_ignore_noop();
6802              }
6803              else
6804              {
6805                  get();
6806              }
6807              if (JSON_HEDLEY_UNLIKELY(current != std::char_traits&lt;char_type&gt;::eof()))
6808              {
6809                  return sax-&gt;parse_error(chars_read, get_token_string(), parse_error::create(110, chars_read,
6810                                          exception_message(input_format, concat(&quot;expected end of input; last byte: 0x&quot;, get_token_string()), &quot;value&quot;), nullptr));
6811              }
6812          }
6813          return result;
6814      }
6815    private:
6816      bool parse_bson_internal()
6817      {
6818          std::int32_t document_size{};
6819          get_number&lt;std::int32_t, true&gt;(input_format_t::bson, document_size);
6820          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(static_cast&lt;std::size_t&gt;(-1))))
6821          {
6822              return false;
6823          }
6824          if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(&amp;bsol;*is_array*/false)))
6825          {
6826              return false;
6827          }
6828          return sax-&gt;end_object();
6829      }
6830      bool get_bson_cstr(string_t&amp; result)
6831      {
6832          auto out = std::back_inserter(result);
6833          while (true)
6834          {
6835              get();
6836              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, &quot;cstring&quot;)))
6837              {
6838                  return false;
6839              }
6840              if (current == 0x00)
6841              {
6842                  return true;
6843              }
6844              *out++ = static_cast&lt;typename string_t::value_type&gt;(current);
6845          }
6846      }
6847      template&lt;typename NumberType&gt;
6848      bool get_bson_string(const NumberType len, string_t&amp; result)
6849      {
6850          if (JSON_HEDLEY_UNLIKELY(len &lt; 1))
6851          {
6852              auto last_token = get_token_string();
6853              return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
6854                                      exception_message(input_format_t::bson, concat(&quot;string length must be at least 1, is &quot;, std::to_string(len)), &quot;string&quot;), nullptr));
6855          }
6856          return get_string(input_format_t::bson, len - static_cast&lt;NumberType&gt;(1), result) &amp;&amp; get() != std::char_traits&lt;char_type&gt;::eof();
6857      }
6858      template&lt;typename NumberType&gt;
6859      bool get_bson_binary(const NumberType len, binary_t&amp; result)
6860      {
6861          if (JSON_HEDLEY_UNLIKELY(len &lt; 0))
6862          {
6863              auto last_token = get_token_string();
6864              return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
6865                                      exception_message(input_format_t::bson, concat(&quot;byte array length cannot be negative, is &quot;, std::to_string(len)), &quot;binary&quot;), nullptr));
6866          }
6867          std::uint8_t subtype{};
6868          get_number&lt;std::uint8_t&gt;(input_format_t::bson, subtype);
6869          result.set_subtype(subtype);
6870          return get_binary(input_format_t::bson, len, result);
6871      }
6872      bool parse_bson_element_internal(const char_int_type element_type,
6873                                       const std::size_t element_type_parse_position)
6874      {
6875          switch (element_type)
6876          {
6877              case 0x01: 
6878              {
6879                  double number{};
6880                  return get_number&lt;double, true&gt;(input_format_t::bson, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
6881              }
6882              case 0x02: 
6883              {
6884                  std::int32_t len{};
6885                  string_t value;
6886                  return get_number&lt;std::int32_t, true&gt;(input_format_t::bson, len) &amp;&amp; get_bson_string(len, value) &amp;&amp; sax-&gt;string(value);
6887              }
6888              case 0x03: 
6889              {
6890                  return parse_bson_internal();
6891              }
6892              case 0x04: 
6893              {
6894                  return parse_bson_array();
6895              }
6896              case 0x05: 
6897              {
6898                  std::int32_t len{};
6899                  binary_t value;
6900                  return get_number&lt;std::int32_t, true&gt;(input_format_t::bson, len) &amp;&amp; get_bson_binary(len, value) &amp;&amp; sax-&gt;binary(value);
6901              }
6902              case 0x08: 
6903              {
6904                  return sax-&gt;boolean(get() != 0);
6905              }
6906              case 0x0A: 
6907              {
6908                  return sax-&gt;null();
6909              }
6910              case 0x10: 
6911              {
6912                  std::int32_t value{};
6913                  return get_number&lt;std::int32_t, true&gt;(input_format_t::bson, value) &amp;&amp; sax-&gt;number_integer(value);
6914              }
6915              case 0x12: 
6916              {
6917                  std::int64_t value{};
6918                  return get_number&lt;std::int64_t, true&gt;(input_format_t::bson, value) &amp;&amp; sax-&gt;number_integer(value);
6919              }
6920              default: 
6921              {
6922                  std::array&lt;char, 3&gt; cr{{}};
6923                  static_cast&lt;void&gt;((std::snprintf)(cr.data(), cr.size(), &quot;%.2hhX&quot;, static_cast&lt;unsigned char&gt;(element_type))); 
6924                  std::string cr_str{cr.data()};
6925                  return sax-&gt;parse_error(element_type_parse_position, cr_str,
6926                                          parse_error::create(114, element_type_parse_position, concat(&quot;Unsupported BSON record type 0x&quot;, cr_str), nullptr));
6927              }
6928          }
6929      }
6930      bool parse_bson_element_list(const bool is_array)
6931      {
6932          string_t key;
6933          while (auto element_type = get())
6934          {
6935              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, &quot;element list&quot;)))
6936              {
6937                  return false;
6938              }
6939              const std::size_t element_type_parse_position = chars_read;
6940              if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
6941              {
6942                  return false;
6943              }
6944              if (!is_array &amp;&amp; !sax-&gt;key(key))
6945              {
6946                  return false;
6947              }
6948              if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
6949              {
6950                  return false;
6951              }
6952              key.clear();
6953          }
6954          return true;
6955      }
6956      bool parse_bson_array()
6957      {
6958          std::int32_t document_size{};
6959          get_number&lt;std::int32_t, true&gt;(input_format_t::bson, document_size);
6960          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(static_cast&lt;std::size_t&gt;(-1))))
6961          {
6962              return false;
6963          }
6964          if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(&amp;bsol;*is_array*/true)))
6965          {
6966              return false;
6967          }
6968          return sax-&gt;end_array();
6969      }
6970      bool parse_cbor_internal(const bool get_char,
6971                               const cbor_tag_handler_t tag_handler)
6972      {
6973          switch (get_char ? get() : current)
6974          {
6975              case std::char_traits&lt;char_type&gt;::eof():
6976                  return unexpect_eof(input_format_t::cbor, &quot;value&quot;);
6977              case 0x00:
6978              case 0x01:
6979              case 0x02:
6980              case 0x03:
6981              case 0x04:
6982              case 0x05:
6983              case 0x06:
6984              case 0x07:
6985              case 0x08:
6986              case 0x09:
6987              case 0x0A:
6988              case 0x0B:
6989              case 0x0C:
6990              case 0x0D:
6991              case 0x0E:
6992              case 0x0F:
6993              case 0x10:
6994              case 0x11:
6995              case 0x12:
6996              case 0x13:
6997              case 0x14:
6998              case 0x15:
6999              case 0x16:
7000              case 0x17:
7001                  return sax-&gt;number_unsigned(static_cast&lt;number_unsigned_t&gt;(current));
7002              case 0x18: 
7003              {
7004                  std::uint8_t number{};
7005                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_unsigned(number);
7006              }
7007              case 0x19: 
7008              {
7009                  std::uint16_t number{};
7010                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_unsigned(number);
7011              }
7012              case 0x1A: 
7013              {
7014                  std::uint32_t number{};
7015                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_unsigned(number);
7016              }
7017              case 0x1B: 
7018              {
7019                  std::uint64_t number{};
7020                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_unsigned(number);
7021              }
7022              case 0x20:
7023              case 0x21:
7024              case 0x22:
7025              case 0x23:
7026              case 0x24:
7027              case 0x25:
7028              case 0x26:
7029              case 0x27:
7030              case 0x28:
7031              case 0x29:
7032              case 0x2A:
7033              case 0x2B:
7034              case 0x2C:
7035              case 0x2D:
7036              case 0x2E:
7037              case 0x2F:
7038              case 0x30:
7039              case 0x31:
7040              case 0x32:
7041              case 0x33:
7042              case 0x34:
7043              case 0x35:
7044              case 0x36:
7045              case 0x37:
7046                  return sax-&gt;number_integer(static_cast&lt;std::int8_t&gt;(0x20 - 1 - current));
7047              case 0x38: 
7048              {
7049                  std::uint8_t number{};
7050                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_integer(static_cast&lt;number_integer_t&gt;(-1) - number);
7051              }
7052              case 0x39: 
7053              {
7054                  std::uint16_t number{};
7055                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_integer(static_cast&lt;number_integer_t&gt;(-1) - number);
7056              }
7057              case 0x3A: 
7058              {
7059                  std::uint32_t number{};
7060                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_integer(static_cast&lt;number_integer_t&gt;(-1) - number);
7061              }
7062              case 0x3B: 
7063              {
7064                  std::uint64_t number{};
7065                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_integer(static_cast&lt;number_integer_t&gt;(-1)
7066                          - static_cast&lt;number_integer_t&gt;(number));
7067              }
7068              case 0x40:
7069              case 0x41:
7070              case 0x42:
7071              case 0x43:
7072              case 0x44:
7073              case 0x45:
7074              case 0x46:
7075              case 0x47:
7076              case 0x48:
7077              case 0x49:
7078              case 0x4A:
7079              case 0x4B:
7080              case 0x4C:
7081              case 0x4D:
7082              case 0x4E:
7083              case 0x4F:
7084              case 0x50:
7085              case 0x51:
7086              case 0x52:
7087              case 0x53:
7088              case 0x54:
7089              case 0x55:
7090              case 0x56:
7091              case 0x57:
7092              case 0x58: 
7093              case 0x59: 
7094              case 0x5A: 
7095              case 0x5B: 
7096              case 0x5F: 
7097              {
7098                  binary_t b;
7099                  return get_cbor_binary(b) &amp;&amp; sax-&gt;binary(b);
7100              }
7101              case 0x60:
7102              case 0x61:
7103              case 0x62:
7104              case 0x63:
7105              case 0x64:
7106              case 0x65:
7107              case 0x66:
7108              case 0x67:
7109              case 0x68:
7110              case 0x69:
7111              case 0x6A:
7112              case 0x6B:
7113              case 0x6C:
7114              case 0x6D:
7115              case 0x6E:
7116              case 0x6F:
7117              case 0x70:
7118              case 0x71:
7119              case 0x72:
7120              case 0x73:
7121              case 0x74:
7122              case 0x75:
7123              case 0x76:
7124              case 0x77:
7125              case 0x78: 
7126              case 0x79: 
7127              case 0x7A: 
7128              case 0x7B: 
7129              case 0x7F: 
7130              {
7131                  string_t s;
7132                  return get_cbor_string(s) &amp;&amp; sax-&gt;string(s);
7133              }
7134              case 0x80:
7135              case 0x81:
7136              case 0x82:
7137              case 0x83:
7138              case 0x84:
7139              case 0x85:
7140              case 0x86:
7141              case 0x87:
7142              case 0x88:
7143              case 0x89:
7144              case 0x8A:
7145              case 0x8B:
7146              case 0x8C:
7147              case 0x8D:
7148              case 0x8E:
7149              case 0x8F:
7150              case 0x90:
7151              case 0x91:
7152              case 0x92:
7153              case 0x93:
7154              case 0x94:
7155              case 0x95:
7156              case 0x96:
7157              case 0x97:
7158                  return get_cbor_array(
7159                             conditional_static_cast&lt;std::size_t&gt;(static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu), tag_handler);
7160              case 0x98: 
7161              {
7162                  std::uint8_t len{};
7163                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_array(static_cast&lt;std::size_t&gt;(len), tag_handler);
7164              }
7165              case 0x99: 
7166              {
7167                  std::uint16_t len{};
7168                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_array(static_cast&lt;std::size_t&gt;(len), tag_handler);
7169              }
7170              case 0x9A: 
7171              {
7172                  std::uint32_t len{};
7173                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_array(conditional_static_cast&lt;std::size_t&gt;(len), tag_handler);
7174              }
7175              case 0x9B: 
7176              {
7177                  std::uint64_t len{};
7178                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_array(conditional_static_cast&lt;std::size_t&gt;(len), tag_handler);
7179              }
7180              case 0x9F: 
7181                  return get_cbor_array(static_cast&lt;std::size_t&gt;(-1), tag_handler);
7182              case 0xA0:
7183              case 0xA1:
7184              case 0xA2:
7185              case 0xA3:
7186              case 0xA4:
7187              case 0xA5:
7188              case 0xA6:
7189              case 0xA7:
7190              case 0xA8:
7191              case 0xA9:
7192              case 0xAA:
7193              case 0xAB:
7194              case 0xAC:
7195              case 0xAD:
7196              case 0xAE:
7197              case 0xAF:
7198              case 0xB0:
7199              case 0xB1:
7200              case 0xB2:
7201              case 0xB3:
7202              case 0xB4:
7203              case 0xB5:
7204              case 0xB6:
7205              case 0xB7:
7206                  return get_cbor_object(conditional_static_cast&lt;std::size_t&gt;(static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu), tag_handler);
7207              case 0xB8: 
7208              {
7209                  std::uint8_t len{};
7210                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_object(static_cast&lt;std::size_t&gt;(len), tag_handler);
7211              }
7212              case 0xB9: 
7213              {
7214                  std::uint16_t len{};
7215                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_object(static_cast&lt;std::size_t&gt;(len), tag_handler);
7216              }
7217              case 0xBA: 
7218              {
7219                  std::uint32_t len{};
7220                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_object(conditional_static_cast&lt;std::size_t&gt;(len), tag_handler);
7221              }
7222              case 0xBB: 
7223              {
7224                  std::uint64_t len{};
7225                  return get_number(input_format_t::cbor, len) &amp;&amp; get_cbor_object(conditional_static_cast&lt;std::size_t&gt;(len), tag_handler);
7226              }
7227              case 0xBF: 
7228                  return get_cbor_object(static_cast&lt;std::size_t&gt;(-1), tag_handler);
7229              case 0xC6: 
7230              case 0xC7:
7231              case 0xC8:
7232              case 0xC9:
7233              case 0xCA:
7234              case 0xCB:
7235              case 0xCC:
7236              case 0xCD:
7237              case 0xCE:
7238              case 0xCF:
7239              case 0xD0:
7240              case 0xD1:
7241              case 0xD2:
7242              case 0xD3:
7243              case 0xD4:
7244              case 0xD8: 
7245              case 0xD9: 
7246              case 0xDA: 
7247              case 0xDB: 
7248              {
7249                  switch (tag_handler)
7250                  {
7251                      case cbor_tag_handler_t::error:
7252                      {
7253                          auto last_token = get_token_string();
7254                          return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
7255                                                  exception_message(input_format_t::cbor, concat(&quot;invalid byte: 0x&quot;, last_token), &quot;value&quot;), nullptr));
7256                      }
7257                      case cbor_tag_handler_t::ignore:
7258                      {
7259                          switch (current)
7260                          {
7261                              case 0xD8:
7262                              {
7263                                  std::uint8_t subtype_to_ignore{};
7264                                  get_number(input_format_t::cbor, subtype_to_ignore);
7265                                  break;
7266                              }
7267                              case 0xD9:
7268                              {
7269                                  std::uint16_t subtype_to_ignore{};
7270                                  get_number(input_format_t::cbor, subtype_to_ignore);
7271                                  break;
7272                              }
7273                              case 0xDA:
7274                              {
7275                                  std::uint32_t subtype_to_ignore{};
7276                                  get_number(input_format_t::cbor, subtype_to_ignore);
7277                                  break;
7278                              }
7279                              case 0xDB:
7280                              {
7281                                  std::uint64_t subtype_to_ignore{};
7282                                  get_number(input_format_t::cbor, subtype_to_ignore);
7283                                  break;
7284                              }
7285                              default:
7286                                  break;
7287                          }
7288                          return parse_cbor_internal(true, tag_handler);
7289                      }
7290                      case cbor_tag_handler_t::store:
7291                      {
7292                          binary_t b;
7293                          switch (current)
7294                          {
7295                              case 0xD8:
7296                              {
7297                                  std::uint8_t subtype{};
7298                                  get_number(input_format_t::cbor, subtype);
7299                                  b.set_subtype(detail::conditional_static_cast&lt;typename binary_t::subtype_type&gt;(subtype));
7300                                  break;
7301                              }
7302                              case 0xD9:
7303                              {
7304                                  std::uint16_t subtype{};
7305                                  get_number(input_format_t::cbor, subtype);
7306                                  b.set_subtype(detail::conditional_static_cast&lt;typename binary_t::subtype_type&gt;(subtype));
7307                                  break;
7308                              }
7309                              case 0xDA:
7310                              {
7311                                  std::uint32_t subtype{};
7312                                  get_number(input_format_t::cbor, subtype);
7313                                  b.set_subtype(detail::conditional_static_cast&lt;typename binary_t::subtype_type&gt;(subtype));
7314                                  break;
7315                              }
7316                              case 0xDB:
7317                              {
7318                                  std::uint64_t subtype{};
7319                                  get_number(input_format_t::cbor, subtype);
7320                                  b.set_subtype(detail::conditional_static_cast&lt;typename binary_t::subtype_type&gt;(subtype));
7321                                  break;
7322                              }
7323                              default:
7324                                  return parse_cbor_internal(true, tag_handler);
7325                          }
7326                          get();
7327                          return get_cbor_binary(b) &amp;&amp; sax-&gt;binary(b);
7328                      }
7329                      default:                 
7330                          JSON_ASSERT(false); 
7331                          return false;        
7332                  }
7333              }
7334              case 0xF4: 
7335                  return sax-&gt;boolean(false);
7336              case 0xF5: 
7337                  return sax-&gt;boolean(true);
7338              case 0xF6: 
7339                  return sax-&gt;null();
7340              case 0xF9: 
7341              {
7342                  const auto byte1_raw = get();
7343                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, &quot;number&quot;)))
7344                  {
7345                      return false;
7346                  }
7347                  const auto byte2_raw = get();
7348                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, &quot;number&quot;)))
7349                  {
7350                      return false;
7351                  }
7352                  const auto byte1 = static_cast&lt;unsigned char&gt;(byte1_raw);
7353                  const auto byte2 = static_cast&lt;unsigned char&gt;(byte2_raw);
7354                  const auto half = static_cast&lt;unsigned int&gt;((byte1 &lt;&lt; 8u) + byte2);
7355                  const double val = [&amp;half]
7356                  {
7357                      const int exp = (half &gt;&gt; 10u) &amp; 0x1Fu;
7358                      const unsigned int mant = half &amp; 0x3FFu;
7359                      JSON_ASSERT(0 &lt;= exp&amp;&amp; exp &lt;= 32);
7360                      JSON_ASSERT(mant &lt;= 1024);
7361                      switch (exp)
7362                      {
7363                          case 0:
7364                              return std::ldexp(mant, -24);
7365                          case 31:
7366                              return (mant == 0)
7367                              ? std::numeric_limits&lt;double&gt;::infinity()
7368                              : std::numeric_limits&lt;double&gt;::quiet_NaN();
7369                          default:
7370                              return std::ldexp(mant + 1024, exp - 25);
7371                      }
7372                  }();
7373                  return sax-&gt;number_float((half &amp; 0x8000u) != 0
7374                                           ? static_cast&lt;number_float_t&gt;(-val)
7375                                           : static_cast&lt;number_float_t&gt;(val), &quot;&quot;);
7376              }
7377              case 0xFA: 
7378              {
7379                  float number{};
7380                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
7381              }
7382              case 0xFB: 
7383              {
7384                  double number{};
7385                  return get_number(input_format_t::cbor, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
7386              }
7387              default: 
7388              {
7389                  auto last_token = get_token_string();
7390                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
7391                                          exception_message(input_format_t::cbor, concat(&quot;invalid byte: 0x&quot;, last_token), &quot;value&quot;), nullptr));
7392              }
7393          }
7394      }
7395      bool get_cbor_string(string_t&amp; result)
7396      {
7397          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, &quot;string&quot;)))
7398          {
7399              return false;
7400          }
7401          switch (current)
7402          {
7403              case 0x60:
7404              case 0x61:
7405              case 0x62:
7406              case 0x63:
7407              case 0x64:
7408              case 0x65:
7409              case 0x66:
7410              case 0x67:
7411              case 0x68:
7412              case 0x69:
7413              case 0x6A:
7414              case 0x6B:
7415              case 0x6C:
7416              case 0x6D:
7417              case 0x6E:
7418              case 0x6F:
7419              case 0x70:
7420              case 0x71:
7421              case 0x72:
7422              case 0x73:
7423              case 0x74:
7424              case 0x75:
7425              case 0x76:
7426              case 0x77:
7427              {
7428                  return get_string(input_format_t::cbor, static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu, result);
7429              }
7430              case 0x78: 
7431              {
7432                  std::uint8_t len{};
7433                  return get_number(input_format_t::cbor, len) &amp;&amp; get_string(input_format_t::cbor, len, result);
7434              }
7435              case 0x79: 
7436              {
7437                  std::uint16_t len{};
7438                  return get_number(input_format_t::cbor, len) &amp;&amp; get_string(input_format_t::cbor, len, result);
7439              }
7440              case 0x7A: 
7441              {
7442                  std::uint32_t len{};
7443                  return get_number(input_format_t::cbor, len) &amp;&amp; get_string(input_format_t::cbor, len, result);
7444              }
7445              case 0x7B: 
7446              {
7447                  std::uint64_t len{};
7448                  return get_number(input_format_t::cbor, len) &amp;&amp; get_string(input_format_t::cbor, len, result);
7449              }
7450              case 0x7F: 
7451              {
7452                  while (get() != 0xFF)
7453                  {
7454                      string_t chunk;
7455                      if (!get_cbor_string(chunk))
7456                      {
7457                          return false;
7458                      }
7459                      result.append(chunk);
7460                  }
7461                  return true;
7462              }
7463              default:
7464              {
7465                  auto last_token = get_token_string();
7466                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read,
7467                                          exception_message(input_format_t::cbor, concat(&quot;expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x&quot;, last_token), &quot;string&quot;), nullptr));
7468              }
7469          }
7470      }
7471      bool get_cbor_binary(binary_t&amp; result)
7472      {
7473          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, &quot;binary&quot;)))
7474          {
7475              return false;
7476          }
7477          switch (current)
7478          {
7479              case 0x40:
7480              case 0x41:
7481              case 0x42:
7482              case 0x43:
7483              case 0x44:
7484              case 0x45:
7485              case 0x46:
7486              case 0x47:
7487              case 0x48:
7488              case 0x49:
7489              case 0x4A:
7490              case 0x4B:
7491              case 0x4C:
7492              case 0x4D:
7493              case 0x4E:
7494              case 0x4F:
7495              case 0x50:
7496              case 0x51:
7497              case 0x52:
7498              case 0x53:
7499              case 0x54:
7500              case 0x55:
7501              case 0x56:
7502              case 0x57:
7503              {
7504                  return get_binary(input_format_t::cbor, static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu, result);
7505              }
7506              case 0x58: 
7507              {
7508                  std::uint8_t len{};
7509                  return get_number(input_format_t::cbor, len) &amp;&amp;
7510                         get_binary(input_format_t::cbor, len, result);
7511              }
7512              case 0x59: 
7513              {
7514                  std::uint16_t len{};
7515                  return get_number(input_format_t::cbor, len) &amp;&amp;
7516                         get_binary(input_format_t::cbor, len, result);
7517              }
7518              case 0x5A: 
7519              {
7520                  std::uint32_t len{};
7521                  return get_number(input_format_t::cbor, len) &amp;&amp;
7522                         get_binary(input_format_t::cbor, len, result);
7523              }
7524              case 0x5B: 
7525              {
7526                  std::uint64_t len{};
7527                  return get_number(input_format_t::cbor, len) &amp;&amp;
7528                         get_binary(input_format_t::cbor, len, result);
7529              }
7530              case 0x5F: 
7531              {
7532                  while (get() != 0xFF)
7533                  {
7534                      binary_t chunk;
7535                      if (!get_cbor_binary(chunk))
7536                      {
7537                          return false;
7538                      }
7539                      result.insert(result.end(), chunk.begin(), chunk.end());
7540                  }
7541                  return true;
7542              }
7543              default:
7544              {
7545                  auto last_token = get_token_string();
7546                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read,
7547                                          exception_message(input_format_t::cbor, concat(&quot;expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x&quot;, last_token), &quot;binary&quot;), nullptr));
7548              }
7549          }
7550      }
7551      bool get_cbor_array(const std::size_t len,
7552                          const cbor_tag_handler_t tag_handler)
7553      {
7554          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(len)))
7555          {
7556              return false;
7557          }
7558          if (len != static_cast&lt;std::size_t&gt;(-1))
7559          {
7560              for (std::size_t i = 0; i &lt; len; ++i)
7561              {
7562                  if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
7563                  {
7564                      return false;
7565                  }
7566              }
7567          }
7568          else
7569          {
7570              while (get() != 0xFF)
7571              {
7572                  if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
7573                  {
7574                      return false;
7575                  }
7576              }
7577          }
7578          return sax-&gt;end_array();
7579      }
7580      bool get_cbor_object(const std::size_t len,
7581                           const cbor_tag_handler_t tag_handler)
7582      {
7583          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(len)))
7584          {
7585              return false;
7586          }
7587          if (len != 0)
7588          {
7589              string_t key;
7590              if (len != static_cast&lt;std::size_t&gt;(-1))
7591              {
7592                  for (std::size_t i = 0; i &lt; len; ++i)
7593                  {
7594                      get();
7595                      if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax-&gt;key(key)))
7596                      {
7597                          return false;
7598                      }
7599                      if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
7600                      {
7601                          return false;
7602                      }
7603                      key.clear();
7604                  }
7605              }
7606              else
7607              {
7608                  while (get() != 0xFF)
7609                  {
7610                      if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax-&gt;key(key)))
7611                      {
7612                          return false;
7613                      }
7614                      if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
7615                      {
7616                          return false;
7617                      }
7618                      key.clear();
7619                  }
7620              }
7621          }
7622          return sax-&gt;end_object();
7623      }
7624      bool parse_msgpack_internal()
7625      {
7626          switch (get())
7627          {
7628              case std::char_traits&lt;char_type&gt;::eof():
7629                  return unexpect_eof(input_format_t::msgpack, &quot;value&quot;);
7630              case 0x00:
7631              case 0x01:
7632              case 0x02:
7633              case 0x03:
7634              case 0x04:
7635              case 0x05:
7636              case 0x06:
7637              case 0x07:
7638              case 0x08:
7639              case 0x09:
7640              case 0x0A:
7641              case 0x0B:
7642              case 0x0C:
7643              case 0x0D:
7644              case 0x0E:
7645              case 0x0F:
7646              case 0x10:
7647              case 0x11:
7648              case 0x12:
7649              case 0x13:
7650              case 0x14:
7651              case 0x15:
7652              case 0x16:
7653              case 0x17:
7654              case 0x18:
7655              case 0x19:
7656              case 0x1A:
7657              case 0x1B:
7658              case 0x1C:
7659              case 0x1D:
7660              case 0x1E:
7661              case 0x1F:
7662              case 0x20:
7663              case 0x21:
7664              case 0x22:
7665              case 0x23:
7666              case 0x24:
7667              case 0x25:
7668              case 0x26:
7669              case 0x27:
7670              case 0x28:
7671              case 0x29:
7672              case 0x2A:
7673              case 0x2B:
7674              case 0x2C:
7675              case 0x2D:
7676              case 0x2E:
7677              case 0x2F:
7678              case 0x30:
7679              case 0x31:
7680              case 0x32:
7681              case 0x33:
7682              case 0x34:
7683              case 0x35:
7684              case 0x36:
7685              case 0x37:
7686              case 0x38:
7687              case 0x39:
7688              case 0x3A:
7689              case 0x3B:
7690              case 0x3C:
7691              case 0x3D:
7692              case 0x3E:
7693              case 0x3F:
7694              case 0x40:
7695              case 0x41:
7696              case 0x42:
7697              case 0x43:
7698              case 0x44:
7699              case 0x45:
7700              case 0x46:
7701              case 0x47:
7702              case 0x48:
7703              case 0x49:
7704              case 0x4A:
7705              case 0x4B:
7706              case 0x4C:
7707              case 0x4D:
7708              case 0x4E:
7709              case 0x4F:
7710              case 0x50:
7711              case 0x51:
7712              case 0x52:
7713              case 0x53:
7714              case 0x54:
7715              case 0x55:
7716              case 0x56:
7717              case 0x57:
7718              case 0x58:
7719              case 0x59:
7720              case 0x5A:
7721              case 0x5B:
7722              case 0x5C:
7723              case 0x5D:
7724              case 0x5E:
7725              case 0x5F:
7726              case 0x60:
7727              case 0x61:
7728              case 0x62:
7729              case 0x63:
7730              case 0x64:
7731              case 0x65:
7732              case 0x66:
7733              case 0x67:
7734              case 0x68:
7735              case 0x69:
7736              case 0x6A:
7737              case 0x6B:
7738              case 0x6C:
7739              case 0x6D:
7740              case 0x6E:
7741              case 0x6F:
7742              case 0x70:
7743              case 0x71:
7744              case 0x72:
7745              case 0x73:
7746              case 0x74:
7747              case 0x75:
7748              case 0x76:
7749              case 0x77:
7750              case 0x78:
7751              case 0x79:
7752              case 0x7A:
7753              case 0x7B:
7754              case 0x7C:
7755              case 0x7D:
7756              case 0x7E:
7757              case 0x7F:
7758                  return sax-&gt;number_unsigned(static_cast&lt;number_unsigned_t&gt;(current));
7759              case 0x80:
7760              case 0x81:
7761              case 0x82:
7762              case 0x83:
7763              case 0x84:
7764              case 0x85:
7765              case 0x86:
7766              case 0x87:
7767              case 0x88:
7768              case 0x89:
7769              case 0x8A:
7770              case 0x8B:
7771              case 0x8C:
7772              case 0x8D:
7773              case 0x8E:
7774              case 0x8F:
7775                  return get_msgpack_object(conditional_static_cast&lt;std::size_t&gt;(static_cast&lt;unsigned int&gt;(current) &amp; 0x0Fu));
7776              case 0x90:
7777              case 0x91:
7778              case 0x92:
7779              case 0x93:
7780              case 0x94:
7781              case 0x95:
7782              case 0x96:
7783              case 0x97:
7784              case 0x98:
7785              case 0x99:
7786              case 0x9A:
7787              case 0x9B:
7788              case 0x9C:
7789              case 0x9D:
7790              case 0x9E:
7791              case 0x9F:
7792                  return get_msgpack_array(conditional_static_cast&lt;std::size_t&gt;(static_cast&lt;unsigned int&gt;(current) &amp; 0x0Fu));
7793              case 0xA0:
7794              case 0xA1:
7795              case 0xA2:
7796              case 0xA3:
7797              case 0xA4:
7798              case 0xA5:
7799              case 0xA6:
7800              case 0xA7:
7801              case 0xA8:
7802              case 0xA9:
7803              case 0xAA:
7804              case 0xAB:
7805              case 0xAC:
7806              case 0xAD:
7807              case 0xAE:
7808              case 0xAF:
7809              case 0xB0:
7810              case 0xB1:
7811              case 0xB2:
7812              case 0xB3:
7813              case 0xB4:
7814              case 0xB5:
7815              case 0xB6:
7816              case 0xB7:
7817              case 0xB8:
7818              case 0xB9:
7819              case 0xBA:
7820              case 0xBB:
7821              case 0xBC:
7822              case 0xBD:
7823              case 0xBE:
7824              case 0xBF:
7825              case 0xD9: 
7826              case 0xDA: 
7827              case 0xDB: 
7828              {
7829                  string_t s;
7830                  return get_msgpack_string(s) &amp;&amp; sax-&gt;string(s);
7831              }
7832              case 0xC0: 
7833                  return sax-&gt;null();
7834              case 0xC2: 
7835                  return sax-&gt;boolean(false);
7836              case 0xC3: 
7837                  return sax-&gt;boolean(true);
7838              case 0xC4: 
7839              case 0xC5: 
7840              case 0xC6: 
7841              case 0xC7: 
7842              case 0xC8: 
7843              case 0xC9: 
7844              case 0xD4: 
7845              case 0xD5: 
7846              case 0xD6: 
7847              case 0xD7: 
7848              case 0xD8: 
7849              {
7850                  binary_t b;
7851                  return get_msgpack_binary(b) &amp;&amp; sax-&gt;binary(b);
7852              }
7853              case 0xCA: 
7854              {
7855                  float number{};
7856                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
7857              }
7858              case 0xCB: 
7859              {
7860                  double number{};
7861                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
7862              }
7863              case 0xCC: 
7864              {
7865                  std::uint8_t number{};
7866                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_unsigned(number);
7867              }
7868              case 0xCD: 
7869              {
7870                  std::uint16_t number{};
7871                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_unsigned(number);
7872              }
7873              case 0xCE: 
7874              {
7875                  std::uint32_t number{};
7876                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_unsigned(number);
7877              }
7878              case 0xCF: 
7879              {
7880                  std::uint64_t number{};
7881                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_unsigned(number);
7882              }
7883              case 0xD0: 
7884              {
7885                  std::int8_t number{};
7886                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_integer(number);
7887              }
7888              case 0xD1: 
7889              {
7890                  std::int16_t number{};
7891                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_integer(number);
7892              }
7893              case 0xD2: 
7894              {
7895                  std::int32_t number{};
7896                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_integer(number);
7897              }
7898              case 0xD3: 
7899              {
7900                  std::int64_t number{};
7901                  return get_number(input_format_t::msgpack, number) &amp;&amp; sax-&gt;number_integer(number);
7902              }
7903              case 0xDC: 
7904              {
7905                  std::uint16_t len{};
7906                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_msgpack_array(static_cast&lt;std::size_t&gt;(len));
7907              }
7908              case 0xDD: 
7909              {
7910                  std::uint32_t len{};
7911                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_msgpack_array(conditional_static_cast&lt;std::size_t&gt;(len));
7912              }
7913              case 0xDE: 
7914              {
7915                  std::uint16_t len{};
7916                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_msgpack_object(static_cast&lt;std::size_t&gt;(len));
7917              }
7918              case 0xDF: 
7919              {
7920                  std::uint32_t len{};
7921                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_msgpack_object(conditional_static_cast&lt;std::size_t&gt;(len));
7922              }
7923              case 0xE0:
7924              case 0xE1:
7925              case 0xE2:
7926              case 0xE3:
7927              case 0xE4:
7928              case 0xE5:
7929              case 0xE6:
7930              case 0xE7:
7931              case 0xE8:
7932              case 0xE9:
7933              case 0xEA:
7934              case 0xEB:
7935              case 0xEC:
7936              case 0xED:
7937              case 0xEE:
7938              case 0xEF:
7939              case 0xF0:
7940              case 0xF1:
7941              case 0xF2:
7942              case 0xF3:
7943              case 0xF4:
7944              case 0xF5:
7945              case 0xF6:
7946              case 0xF7:
7947              case 0xF8:
7948              case 0xF9:
7949              case 0xFA:
7950              case 0xFB:
7951              case 0xFC:
7952              case 0xFD:
7953              case 0xFE:
7954              case 0xFF:
7955                  return sax-&gt;number_integer(static_cast&lt;std::int8_t&gt;(current));
7956              default: 
7957              {
7958                  auto last_token = get_token_string();
7959                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
7960                                          exception_message(input_format_t::msgpack, concat(&quot;invalid byte: 0x&quot;, last_token), &quot;value&quot;), nullptr));
7961              }
7962          }
7963      }
7964      bool get_msgpack_string(string_t&amp; result)
7965      {
7966          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, &quot;string&quot;)))
7967          {
7968              return false;
7969          }
7970          switch (current)
7971          {
7972              case 0xA0:
7973              case 0xA1:
7974              case 0xA2:
7975              case 0xA3:
7976              case 0xA4:
7977              case 0xA5:
7978              case 0xA6:
7979              case 0xA7:
7980              case 0xA8:
7981              case 0xA9:
7982              case 0xAA:
7983              case 0xAB:
7984              case 0xAC:
7985              case 0xAD:
7986              case 0xAE:
7987              case 0xAF:
7988              case 0xB0:
7989              case 0xB1:
7990              case 0xB2:
7991              case 0xB3:
7992              case 0xB4:
7993              case 0xB5:
7994              case 0xB6:
7995              case 0xB7:
7996              case 0xB8:
7997              case 0xB9:
7998              case 0xBA:
7999              case 0xBB:
8000              case 0xBC:
8001              case 0xBD:
8002              case 0xBE:
8003              case 0xBF:
8004              {
8005                  return get_string(input_format_t::msgpack, static_cast&lt;unsigned int&gt;(current) &amp; 0x1Fu, result);
8006              }
8007              case 0xD9: 
8008              {
8009                  std::uint8_t len{};
8010                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_string(input_format_t::msgpack, len, result);
8011              }
8012              case 0xDA: 
8013              {
8014                  std::uint16_t len{};
8015                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_string(input_format_t::msgpack, len, result);
8016              }
8017              case 0xDB: 
8018              {
8019                  std::uint32_t len{};
8020                  return get_number(input_format_t::msgpack, len) &amp;&amp; get_string(input_format_t::msgpack, len, result);
8021              }
8022              default:
8023              {
8024                  auto last_token = get_token_string();
8025                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read,
8026                                          exception_message(input_format_t::msgpack, concat(&quot;expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x&quot;, last_token), &quot;string&quot;), nullptr));
8027              }
8028          }
8029      }
8030      bool get_msgpack_binary(binary_t&amp; result)
8031      {
8032          auto assign_and_return_true = [&amp;result](std::int8_t subtype)
8033          {
8034              result.set_subtype(static_cast&lt;std::uint8_t&gt;(subtype));
8035              return true;
8036          };
8037          switch (current)
8038          {
8039              case 0xC4: 
8040              {
8041                  std::uint8_t len{};
8042                  return get_number(input_format_t::msgpack, len) &amp;&amp;
8043                         get_binary(input_format_t::msgpack, len, result);
8044              }
8045              case 0xC5: 
8046              {
8047                  std::uint16_t len{};
8048                  return get_number(input_format_t::msgpack, len) &amp;&amp;
8049                         get_binary(input_format_t::msgpack, len, result);
8050              }
8051              case 0xC6: 
8052              {
8053                  std::uint32_t len{};
8054                  return get_number(input_format_t::msgpack, len) &amp;&amp;
8055                         get_binary(input_format_t::msgpack, len, result);
8056              }
8057              case 0xC7: 
8058              {
8059                  std::uint8_t len{};
8060                  std::int8_t subtype{};
8061                  return get_number(input_format_t::msgpack, len) &amp;&amp;
8062                         get_number(input_format_t::msgpack, subtype) &amp;&amp;
8063                         get_binary(input_format_t::msgpack, len, result) &amp;&amp;
8064                         assign_and_return_true(subtype);
8065              }
8066              case 0xC8: 
8067              {
8068                  std::uint16_t len{};
8069                  std::int8_t subtype{};
8070                  return get_number(input_format_t::msgpack, len) &amp;&amp;
8071                         get_number(input_format_t::msgpack, subtype) &amp;&amp;
8072                         get_binary(input_format_t::msgpack, len, result) &amp;&amp;
8073                         assign_and_return_true(subtype);
8074              }
8075              case 0xC9: 
8076              {
8077                  std::uint32_t len{};
8078                  std::int8_t subtype{};
8079                  return get_number(input_format_t::msgpack, len) &amp;&amp;
8080                         get_number(input_format_t::msgpack, subtype) &amp;&amp;
8081                         get_binary(input_format_t::msgpack, len, result) &amp;&amp;
8082                         assign_and_return_true(subtype);
8083              }
8084              case 0xD4: 
8085              {
8086                  std::int8_t subtype{};
8087                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
8088                         get_binary(input_format_t::msgpack, 1, result) &amp;&amp;
8089                         assign_and_return_true(subtype);
8090              }
8091              case 0xD5: 
8092              {
8093                  std::int8_t subtype{};
8094                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
8095                         get_binary(input_format_t::msgpack, 2, result) &amp;&amp;
8096                         assign_and_return_true(subtype);
8097              }
8098              case 0xD6: 
8099              {
8100                  std::int8_t subtype{};
8101                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
8102                         get_binary(input_format_t::msgpack, 4, result) &amp;&amp;
8103                         assign_and_return_true(subtype);
8104              }
8105              case 0xD7: 
8106              {
8107                  std::int8_t subtype{};
8108                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
8109                         get_binary(input_format_t::msgpack, 8, result) &amp;&amp;
8110                         assign_and_return_true(subtype);
8111              }
8112              case 0xD8: 
8113              {
8114                  std::int8_t subtype{};
8115                  return get_number(input_format_t::msgpack, subtype) &amp;&amp;
8116                         get_binary(input_format_t::msgpack, 16, result) &amp;&amp;
8117                         assign_and_return_true(subtype);
8118              }
8119              default:           
8120                  return false;  
8121          }
8122      }
8123      bool get_msgpack_array(const std::size_t len)
8124      {
8125          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(len)))
8126          {
8127              return false;
8128          }
8129          for (std::size_t i = 0; i &lt; len; ++i)
8130          {
8131              if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
8132              {
8133                  return false;
8134              }
8135          }
8136          return sax-&gt;end_array();
8137      }
8138      bool get_msgpack_object(const std::size_t len)
8139      {
8140          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(len)))
8141          {
8142              return false;
8143          }
8144          string_t key;
8145          for (std::size_t i = 0; i &lt; len; ++i)
8146          {
8147              get();
8148              if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax-&gt;key(key)))
8149              {
8150                  return false;
8151              }
8152              if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
8153              {
8154                  return false;
8155              }
8156              key.clear();
8157          }
8158          return sax-&gt;end_object();
8159      }
8160      bool parse_ubjson_internal(const bool get_char = true)
8161      {
8162          return get_ubjson_value(get_char ? get_ignore_noop() : current);
8163      }
8164      bool get_ubjson_string(string_t&amp; result, const bool get_char = true)
8165      {
8166          if (get_char)
8167          {
8168              get();  
8169          }
8170          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, &quot;value&quot;)))
8171          {
8172              return false;
8173          }
8174          switch (current)
8175          {
8176              case &#x27;U&#x27;:
8177              {
8178                  std::uint8_t len{};
8179                  return get_number(input_format, len) &amp;&amp; get_string(input_format, len, result);
8180              }
8181              case &#x27;i&#x27;:
8182              {
8183                  std::int8_t len{};
8184                  return get_number(input_format, len) &amp;&amp; get_string(input_format, len, result);
8185              }
8186              case &#x27;I&#x27;:
8187              {
8188                  std::int16_t len{};
8189                  return get_number(input_format, len) &amp;&amp; get_string(input_format, len, result);
8190              }
8191              case &#x27;l&#x27;:
8192              {
8193                  std::int32_t len{};
8194                  return get_number(input_format, len) &amp;&amp; get_string(input_format, len, result);
8195              }
8196              case &#x27;L&#x27;:
8197              {
8198                  std::int64_t len{};
8199                  return get_number(input_format, len) &amp;&amp; get_string(input_format, len, result);
8200              }
8201              case &#x27;u&#x27;:
8202              {
8203                  if (input_format != input_format_t::bjdata)
8204                  {
8205                      break;
8206                  }
8207                  std::uint16_t len{};
8208                  return get_number(input_format, len) &amp;&amp; get_string(input_format, len, result);
8209              }
8210              case &#x27;m&#x27;:
8211              {
8212                  if (input_format != input_format_t::bjdata)
8213                  {
8214                      break;
8215                  }
8216                  std::uint32_t len{};
8217                  return get_number(input_format, len) &amp;&amp; get_string(input_format, len, result);
8218              }
8219              case &#x27;M&#x27;:
8220              {
8221                  if (input_format != input_format_t::bjdata)
8222                  {
8223                      break;
8224                  }
8225                  std::uint64_t len{};
8226                  return get_number(input_format, len) &amp;&amp; get_string(input_format, len, result);
8227              }
8228              default:
8229                  break;
8230          }
8231          auto last_token = get_token_string();
8232          std::string message;
8233          if (input_format != input_format_t::bjdata)
8234          {
8235              message = &quot;expected length type specification (U, i, I, l, L); last byte: 0x&quot; + last_token;
8236          }
8237          else
8238          {
8239              message = &quot;expected length type specification (U, i, u, I, m, l, M, L); last byte: 0x&quot; + last_token;
8240          }
8241          return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, &quot;string&quot;), nullptr));
8242      }
8243      bool get_ubjson_ndarray_size(std::vector&lt;size_t&gt;&amp; dim)
8244      {
8245          std::pair&lt;std::size_t, char_int_type&gt; size_and_type;
8246          size_t dimlen = 0;
8247          bool no_ndarray = true;
8248          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type, no_ndarray)))
8249          {
8250              return false;
8251          }
8252          if (size_and_type.first != npos)
8253          {
8254              if (size_and_type.second != 0)
8255              {
8256                  if (size_and_type.second != &#x27;N&#x27;)
8257                  {
8258                      for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
8259                      {
8260                          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, size_and_type.second)))
8261                          {
8262                              return false;
8263                          }
8264                          dim.push_back(dimlen);
8265                      }
8266                  }
8267              }
8268              else
8269              {
8270                  for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
8271                  {
8272                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray)))
8273                      {
8274                          return false;
8275                      }
8276                      dim.push_back(dimlen);
8277                  }
8278              }
8279          }
8280          else
8281          {
8282              while (current != &#x27;]&#x27;)
8283              {
8284                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, current)))
8285                  {
8286                      return false;
8287                  }
8288                  dim.push_back(dimlen);
8289                  get_ignore_noop();
8290              }
8291          }
8292          return true;
8293      }
8294      bool get_ubjson_size_value(std::size_t&amp; result, bool&amp; is_ndarray, char_int_type prefix = 0)
8295      {
8296          if (prefix == 0)
8297          {
8298              prefix = get_ignore_noop();
8299          }
8300          switch (prefix)
8301          {
8302              case &#x27;U&#x27;:
8303              {
8304                  std::uint8_t number{};
8305                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8306                  {
8307                      return false;
8308                  }
8309                  result = static_cast&lt;std::size_t&gt;(number);
8310                  return true;
8311              }
8312              case &#x27;i&#x27;:
8313              {
8314                  std::int8_t number{};
8315                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8316                  {
8317                      return false;
8318                  }
8319                  if (number &lt; 0)
8320                  {
8321                      return sax-&gt;parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
8322                                              exception_message(input_format, &quot;count in an optimized container must be positive&quot;, &quot;size&quot;), nullptr));
8323                  }
8324                  result = static_cast&lt;std::size_t&gt;(number); 
8325                  return true;
8326              }
8327              case &#x27;I&#x27;:
8328              {
8329                  std::int16_t number{};
8330                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8331                  {
8332                      return false;
8333                  }
8334                  if (number &lt; 0)
8335                  {
8336                      return sax-&gt;parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
8337                                              exception_message(input_format, &quot;count in an optimized container must be positive&quot;, &quot;size&quot;), nullptr));
8338                  }
8339                  result = static_cast&lt;std::size_t&gt;(number);
8340                  return true;
8341              }
8342              case &#x27;l&#x27;:
8343              {
8344                  std::int32_t number{};
8345                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8346                  {
8347                      return false;
8348                  }
8349                  if (number &lt; 0)
8350                  {
8351                      return sax-&gt;parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
8352                                              exception_message(input_format, &quot;count in an optimized container must be positive&quot;, &quot;size&quot;), nullptr));
8353                  }
8354                  result = static_cast&lt;std::size_t&gt;(number);
8355                  return true;
8356              }
8357              case &#x27;L&#x27;:
8358              {
8359                  std::int64_t number{};
8360                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8361                  {
8362                      return false;
8363                  }
8364                  if (number &lt; 0)
8365                  {
8366                      return sax-&gt;parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
8367                                              exception_message(input_format, &quot;count in an optimized container must be positive&quot;, &quot;size&quot;), nullptr));
8368                  }
8369                  if (!value_in_range_of&lt;std::size_t&gt;(number))
8370                  {
8371                      return sax-&gt;parse_error(chars_read, get_token_string(), out_of_range::create(408,
8372                                              exception_message(input_format, &quot;integer value overflow&quot;, &quot;size&quot;), nullptr));
8373                  }
8374                  result = static_cast&lt;std::size_t&gt;(number);
8375                  return true;
8376              }
8377              case &#x27;u&#x27;:
8378              {
8379                  if (input_format != input_format_t::bjdata)
8380                  {
8381                      break;
8382                  }
8383                  std::uint16_t number{};
8384                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8385                  {
8386                      return false;
8387                  }
8388                  result = static_cast&lt;std::size_t&gt;(number);
8389                  return true;
8390              }
8391              case &#x27;m&#x27;:
8392              {
8393                  if (input_format != input_format_t::bjdata)
8394                  {
8395                      break;
8396                  }
8397                  std::uint32_t number{};
8398                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8399                  {
8400                      return false;
8401                  }
8402                  result = conditional_static_cast&lt;std::size_t&gt;(number);
8403                  return true;
8404              }
8405              case &#x27;M&#x27;:
8406              {
8407                  if (input_format != input_format_t::bjdata)
8408                  {
8409                      break;
8410                  }
8411                  std::uint64_t number{};
8412                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
8413                  {
8414                      return false;
8415                  }
8416                  if (!value_in_range_of&lt;std::size_t&gt;(number))
8417                  {
8418                      return sax-&gt;parse_error(chars_read, get_token_string(), out_of_range::create(408,
8419                                              exception_message(input_format, &quot;integer value overflow&quot;, &quot;size&quot;), nullptr));
8420                  }
8421                  result = detail::conditional_static_cast&lt;std::size_t&gt;(number);
8422                  return true;
8423              }
8424              case &#x27;[&#x27;:
8425              {
8426                  if (input_format != input_format_t::bjdata)
8427                  {
8428                      break;
8429                  }
8430                  if (is_ndarray) 
8431                  {
8432                      return sax-&gt;parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read, exception_message(input_format, &quot;ndarray dimentional vector is not allowed&quot;, &quot;size&quot;), nullptr));
8433                  }
8434                  std::vector&lt;size_t&gt; dim;
8435                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_ndarray_size(dim)))
8436                  {
8437                      return false;
8438                  }
8439                  if (dim.size() == 1 || (dim.size() == 2 &amp;&amp; dim.at(0) == 1)) 
8440                  {
8441                      result = dim.at(dim.size() - 1);
8442                      return true;
8443                  }
8444                  if (!dim.empty())  
8445                  {
8446                      for (auto i : dim) 
8447                      {
8448                          if ( i == 0 )
8449                          {
8450                              result = 0;
8451                              return true;
8452                          }
8453                      }
8454                      string_t key = &quot;_ArraySize_&quot;;
8455                      if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(3) || !sax-&gt;key(key) || !sax-&gt;start_array(dim.size())))
8456                      {
8457                          return false;
8458                      }
8459                      result = 1;
8460                      for (auto i : dim)
8461                      {
8462                          result *= i;
8463                          if (result == 0 || result == npos) 
8464                          {
8465                              return sax-&gt;parse_error(chars_read, get_token_string(), out_of_range::create(408, exception_message(input_format, &quot;excessive ndarray size caused overflow&quot;, &quot;size&quot;), nullptr));
8466                          }
8467                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_unsigned(static_cast&lt;number_unsigned_t&gt;(i))))
8468                          {
8469                              return false;
8470                          }
8471                      }
8472                      is_ndarray = true;
8473                      return sax-&gt;end_array();
8474                  }
8475                  result = 0;
8476                  return true;
8477              }
8478              default:
8479                  break;
8480          }
8481          auto last_token = get_token_string();
8482          std::string message;
8483          if (input_format != input_format_t::bjdata)
8484          {
8485              message = &quot;expected length type specification (U, i, I, l, L) after &#x27;#&#x27;; last byte: 0x&quot; + last_token;
8486          }
8487          else
8488          {
8489              message = &quot;expected length type specification (U, i, u, I, m, l, M, L) after &#x27;#&#x27;; last byte: 0x&quot; + last_token;
8490          }
8491          return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, &quot;size&quot;), nullptr));
8492      }
8493      bool get_ubjson_size_type(std::pair&lt;std::size_t, char_int_type&gt;&amp; result, bool inside_ndarray = false)
8494      {
8495          result.first = npos; 
8496          result.second = 0; 
8497          bool is_ndarray = false;
8498          get_ignore_noop();
8499          if (current == &#x27;$&#x27;)
8500          {
8501              result.second = get();  
8502              if (input_format == input_format_t::bjdata
8503                      &amp;&amp; JSON_HEDLEY_UNLIKELY(std::binary_search(bjd_optimized_type_markers.begin(), bjd_optimized_type_markers.end(), result.second)))
8504              {
8505                  auto last_token = get_token_string();
8506                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
8507                                          exception_message(input_format, concat(&quot;marker 0x&quot;, last_token, &quot; is not a permitted optimized array type&quot;), &quot;type&quot;), nullptr));
8508              }
8509              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, &quot;type&quot;)))
8510              {
8511                  return false;
8512              }
8513              get_ignore_noop();
8514              if (JSON_HEDLEY_UNLIKELY(current != &#x27;#&#x27;))
8515              {
8516                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, &quot;value&quot;)))
8517                  {
8518                      return false;
8519                  }
8520                  auto last_token = get_token_string();
8521                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
8522                                          exception_message(input_format, concat(&quot;expected &#x27;#&#x27; after type information; last byte: 0x&quot;, last_token), &quot;size&quot;), nullptr));
8523              }
8524              bool is_error = get_ubjson_size_value(result.first, is_ndarray);
8525              if (input_format == input_format_t::bjdata &amp;&amp; is_ndarray)
8526              {
8527                  if (inside_ndarray)
8528                  {
8529                      return sax-&gt;parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
8530                                              exception_message(input_format, &quot;ndarray can not be recursive&quot;, &quot;size&quot;), nullptr));
8531                  }
8532                  result.second |= (1 &lt;&lt; 8); 
8533              }
8534              return is_error;
8535          }
8536          if (current == &#x27;#&#x27;)
8537          {
8538              bool is_error = get_ubjson_size_value(result.first, is_ndarray);
8539              if (input_format == input_format_t::bjdata &amp;&amp; is_ndarray)
8540              {
8541                  return sax-&gt;parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
8542                                          exception_message(input_format, &quot;ndarray requires both type and size&quot;, &quot;size&quot;), nullptr));
8543              }
8544              return is_error;
8545          }
8546          return true;
8547      }
8548      bool get_ubjson_value(const char_int_type prefix)
8549      {
8550          switch (prefix)
8551          {
8552              case std::char_traits&lt;char_type&gt;::eof():  
8553                  return unexpect_eof(input_format, &quot;value&quot;);
8554              case &#x27;T&#x27;:  
8555                  return sax-&gt;boolean(true);
8556              case &#x27;F&#x27;:  
8557                  return sax-&gt;boolean(false);
8558              case &#x27;Z&#x27;:  
8559                  return sax-&gt;null();
8560              case &#x27;U&#x27;:
8561              {
8562                  std::uint8_t number{};
8563                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_unsigned(number);
8564              }
8565              case &#x27;i&#x27;:
8566              {
8567                  std::int8_t number{};
8568                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_integer(number);
8569              }
8570              case &#x27;I&#x27;:
8571              {
8572                  std::int16_t number{};
8573                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_integer(number);
8574              }
8575              case &#x27;l&#x27;:
8576              {
8577                  std::int32_t number{};
8578                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_integer(number);
8579              }
8580              case &#x27;L&#x27;:
8581              {
8582                  std::int64_t number{};
8583                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_integer(number);
8584              }
8585              case &#x27;u&#x27;:
8586              {
8587                  if (input_format != input_format_t::bjdata)
8588                  {
8589                      break;
8590                  }
8591                  std::uint16_t number{};
8592                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_unsigned(number);
8593              }
8594              case &#x27;m&#x27;:
8595              {
8596                  if (input_format != input_format_t::bjdata)
8597                  {
8598                      break;
8599                  }
8600                  std::uint32_t number{};
8601                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_unsigned(number);
8602              }
8603              case &#x27;M&#x27;:
8604              {
8605                  if (input_format != input_format_t::bjdata)
8606                  {
8607                      break;
8608                  }
8609                  std::uint64_t number{};
8610                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_unsigned(number);
8611              }
8612              case &#x27;h&#x27;:
8613              {
8614                  if (input_format != input_format_t::bjdata)
8615                  {
8616                      break;
8617                  }
8618                  const auto byte1_raw = get();
8619                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, &quot;number&quot;)))
8620                  {
8621                      return false;
8622                  }
8623                  const auto byte2_raw = get();
8624                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, &quot;number&quot;)))
8625                  {
8626                      return false;
8627                  }
8628                  const auto byte1 = static_cast&lt;unsigned char&gt;(byte1_raw);
8629                  const auto byte2 = static_cast&lt;unsigned char&gt;(byte2_raw);
8630                  const auto half = static_cast&lt;unsigned int&gt;((byte2 &lt;&lt; 8u) + byte1);
8631                  const double val = [&amp;half]
8632                  {
8633                      const int exp = (half &gt;&gt; 10u) &amp; 0x1Fu;
8634                      const unsigned int mant = half &amp; 0x3FFu;
8635                      JSON_ASSERT(0 &lt;= exp&amp;&amp; exp &lt;= 32);
8636                      JSON_ASSERT(mant &lt;= 1024);
8637                      switch (exp)
8638                      {
8639                          case 0:
8640                              return std::ldexp(mant, -24);
8641                          case 31:
8642                              return (mant == 0)
8643                              ? std::numeric_limits&lt;double&gt;::infinity()
8644                              : std::numeric_limits&lt;double&gt;::quiet_NaN();
8645                          default:
8646                              return std::ldexp(mant + 1024, exp - 25);
8647                      }
8648                  }();
8649                  return sax-&gt;number_float((half &amp; 0x8000u) != 0
8650                                           ? static_cast&lt;number_float_t&gt;(-val)
8651                                           : static_cast&lt;number_float_t&gt;(val), &quot;&quot;);
8652              }
8653              case &#x27;d&#x27;:
8654              {
8655                  float number{};
8656                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
8657              }
8658              case &#x27;D&#x27;:
8659              {
8660                  double number{};
8661                  return get_number(input_format, number) &amp;&amp; sax-&gt;number_float(static_cast&lt;number_float_t&gt;(number), &quot;&quot;);
8662              }
8663              case &#x27;H&#x27;:
8664              {
8665                  return get_ubjson_high_precision_number();
8666              }
8667              case &#x27;C&#x27;:  
8668              {
8669                  get();
8670                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, &quot;char&quot;)))
8671                  {
8672                      return false;
8673                  }
8674                  if (JSON_HEDLEY_UNLIKELY(current &gt; 127))
8675                  {
8676                      auto last_token = get_token_string();
8677                      return sax-&gt;parse_error(chars_read, last_token, parse_error::create(113, chars_read,
8678                                              exception_message(input_format, concat(&quot;byte after &#x27;C&#x27; must be in range 0x00..0x7F; last byte: 0x&quot;, last_token), &quot;char&quot;), nullptr));
8679                  }
8680                  string_t s(1, static_cast&lt;typename string_t::value_type&gt;(current));
8681                  return sax-&gt;string(s);
8682              }
8683              case &#x27;S&#x27;:  
8684              {
8685                  string_t s;
8686                  return get_ubjson_string(s) &amp;&amp; sax-&gt;string(s);
8687              }
8688              case &#x27;[&#x27;:  
8689                  return get_ubjson_array();
8690              case &#x27;{&#x27;:  
8691                  return get_ubjson_object();
8692              default: 
8693                  break;
8694          }
8695          auto last_token = get_token_string();
8696          return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format, &quot;invalid byte: 0x&quot; + last_token, &quot;value&quot;), nullptr));
8697      }
8698      bool get_ubjson_array()
8699      {
8700          std::pair&lt;std::size_t, char_int_type&gt; size_and_type;
8701          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
8702          {
8703              return false;
8704          }
8705          if (input_format == input_format_t::bjdata &amp;&amp; size_and_type.first != npos &amp;&amp; (size_and_type.second &amp; (1 &lt;&lt; 8)) != 0)
8706          {
8707              size_and_type.second &amp;= ~(static_cast&lt;char_int_type&gt;(1) &lt;&lt; 8);  
8708              auto it = std::lower_bound(bjd_types_map.begin(), bjd_types_map.end(), size_and_type.second, [](const bjd_type &amp; p, char_int_type t)
8709              {
8710                  return p.first &lt; t;
8711              });
8712              string_t key = &quot;_ArrayType_&quot;;
8713              if (JSON_HEDLEY_UNLIKELY(it == bjd_types_map.end() || it-&gt;first != size_and_type.second))
8714              {
8715                  auto last_token = get_token_string();
8716                  return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
8717                                          exception_message(input_format, &quot;invalid byte: 0x&quot; + last_token, &quot;type&quot;), nullptr));
8718              }
8719              string_t type = it-&gt;second; 
8720              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;key(key) || !sax-&gt;string(type)))
8721              {
8722                  return false;
8723              }
8724              if (size_and_type.second == &#x27;C&#x27;)
8725              {
8726                  size_and_type.second = &#x27;U&#x27;;
8727              }
8728              key = &quot;_ArrayData_&quot;;
8729              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;key(key) || !sax-&gt;start_array(size_and_type.first) ))
8730              {
8731                  return false;
8732              }
8733              for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
8734              {
8735                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
8736                  {
8737                      return false;
8738                  }
8739              }
8740              return (sax-&gt;end_array() &amp;&amp; sax-&gt;end_object());
8741          }
8742          if (size_and_type.first != npos)
8743          {
8744              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(size_and_type.first)))
8745              {
8746                  return false;
8747              }
8748              if (size_and_type.second != 0)
8749              {
8750                  if (size_and_type.second != &#x27;N&#x27;)
8751                  {
8752                      for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
8753                      {
8754                          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
8755                          {
8756                              return false;
8757                          }
8758                      }
8759                  }
8760              }
8761              else
8762              {
8763                  for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
8764                  {
8765                      if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
8766                      {
8767                          return false;
8768                      }
8769                  }
8770              }
8771          }
8772          else
8773          {
8774              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(static_cast&lt;std::size_t&gt;(-1))))
8775              {
8776                  return false;
8777              }
8778              while (current != &#x27;]&#x27;)
8779              {
8780                  if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
8781                  {
8782                      return false;
8783                  }
8784                  get_ignore_noop();
8785              }
8786          }
8787          return sax-&gt;end_array();
8788      }
8789      bool get_ubjson_object()
8790      {
8791          std::pair&lt;std::size_t, char_int_type&gt; size_and_type;
8792          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
8793          {
8794              return false;
8795          }
8796          if (input_format == input_format_t::bjdata &amp;&amp; size_and_type.first != npos &amp;&amp; (size_and_type.second &amp; (1 &lt;&lt; 8)) != 0)
8797          {
8798              auto last_token = get_token_string();
8799              return sax-&gt;parse_error(chars_read, last_token, parse_error::create(112, chars_read,
8800                                      exception_message(input_format, &quot;BJData object does not support ND-array size in optimized format&quot;, &quot;object&quot;), nullptr));
8801          }
8802          string_t key;
8803          if (size_and_type.first != npos)
8804          {
8805              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(size_and_type.first)))
8806              {
8807                  return false;
8808              }
8809              if (size_and_type.second != 0)
8810              {
8811                  for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
8812                  {
8813                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax-&gt;key(key)))
8814                      {
8815                          return false;
8816                      }
8817                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
8818                      {
8819                          return false;
8820                      }
8821                      key.clear();
8822                  }
8823              }
8824              else
8825              {
8826                  for (std::size_t i = 0; i &lt; size_and_type.first; ++i)
8827                  {
8828                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax-&gt;key(key)))
8829                      {
8830                          return false;
8831                      }
8832                      if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
8833                      {
8834                          return false;
8835                      }
8836                      key.clear();
8837                  }
8838              }
8839          }
8840          else
8841          {
8842              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(static_cast&lt;std::size_t&gt;(-1))))
8843              {
8844                  return false;
8845              }
8846              while (current != &#x27;}&#x27;)
8847              {
8848                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax-&gt;key(key)))
8849                  {
8850                      return false;
8851                  }
8852                  if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
8853                  {
8854                      return false;
8855                  }
8856                  get_ignore_noop();
8857                  key.clear();
8858              }
8859          }
8860          return sax-&gt;end_object();
8861      }
8862      bool get_ubjson_high_precision_number()
8863      {
8864          std::size_t size{};
8865          bool no_ndarray = true;
8866          auto res = get_ubjson_size_value(size, no_ndarray);
8867          if (JSON_HEDLEY_UNLIKELY(!res))
8868          {
8869              return res;
8870          }
8871          std::vector&lt;char&gt; number_vector;
8872          for (std::size_t i = 0; i &lt; size; ++i)
8873          {
8874              get();
8875              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, &quot;number&quot;)))
8876              {
8877                  return false;
8878              }
8879              number_vector.push_back(static_cast&lt;char&gt;(current));
8880          }
8881          using ia_type = decltype(detail::input_adapter(number_vector));
8882          auto number_lexer = detail::lexer&lt;BasicJsonType, ia_type&gt;(detail::input_adapter(number_vector), false);
8883          const auto result_number = number_lexer.scan();
8884          const auto number_string = number_lexer.get_token_string();
8885          const auto result_remainder = number_lexer.scan();
8886          using token_type = typename detail::lexer_base&lt;BasicJsonType&gt;::token_type;
8887          if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
8888          {
8889              return sax-&gt;parse_error(chars_read, number_string, parse_error::create(115, chars_read,
8890                                      exception_message(input_format, concat(&quot;invalid number text: &quot;, number_lexer.get_token_string()), &quot;high-precision number&quot;), nullptr));
8891          }
8892          switch (result_number)
8893          {
8894              case token_type::value_integer:
8895                  return sax-&gt;number_integer(number_lexer.get_number_integer());
8896              case token_type::value_unsigned:
8897                  return sax-&gt;number_unsigned(number_lexer.get_number_unsigned());
8898              case token_type::value_float:
8899                  return sax-&gt;number_float(number_lexer.get_number_float(), std::move(number_string));
8900              case token_type::uninitialized:
8901              case token_type::literal_true:
8902              case token_type::literal_false:
8903              case token_type::literal_null:
8904              case token_type::value_string:
8905              case token_type::begin_array:
8906              case token_type::begin_object:
8907              case token_type::end_array:
8908              case token_type::end_object:
8909              case token_type::name_separator:
8910              case token_type::value_separator:
8911              case token_type::parse_error:
8912              case token_type::end_of_input:
8913              case token_type::literal_or_value:
8914              default:
8915                  return sax-&gt;parse_error(chars_read, number_string, parse_error::create(115, chars_read,
8916                                          exception_message(input_format, concat(&quot;invalid number text: &quot;, number_lexer.get_token_string()), &quot;high-precision number&quot;), nullptr));
8917          }
8918      }
8919      char_int_type get()
8920      {
8921          ++chars_read;
8922          return current = ia.get_character();
8923      }
8924      char_int_type get_ignore_noop()
8925      {
8926          do
8927          {
8928              get();
8929          }
8930          while (current == &#x27;N&#x27;);
8931          return current;
8932      }
8933      template&lt;typename NumberType, bool InputIsLittleEndian = false&gt;
8934      bool get_number(const input_format_t format, NumberType&amp; result)
8935      {
8936          std::array&lt;std::uint8_t, sizeof(NumberType)&gt; vec{};
8937          for (std::size_t i = 0; i &lt; sizeof(NumberType); ++i)
8938          {
8939              get();
8940              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, &quot;number&quot;)))
8941              {
8942                  return false;
8943              }
8944              if (is_little_endian != (InputIsLittleEndian || format == input_format_t::bjdata))
8945              {
8946                  vec[sizeof(NumberType) - i - 1] = static_cast&lt;std::uint8_t&gt;(current);
8947              }
8948              else
8949              {
8950                  vec[i] = static_cast&lt;std::uint8_t&gt;(current); 
8951              }
8952          }
8953          std::memcpy(&amp;result, vec.data(), sizeof(NumberType));
8954          return true;
8955      }
8956      template&lt;typename NumberType&gt;
8957      bool get_string(const input_format_t format,
8958                      const NumberType len,
8959                      string_t&amp; result)
8960      {
8961          bool success = true;
8962          for (NumberType i = 0; i &lt; len; i++)
8963          {
8964              get();
8965              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, &quot;string&quot;)))
8966              {
8967                  success = false;
8968                  break;
8969              }
8970              result.push_back(static_cast&lt;typename string_t::value_type&gt;(current));
8971          }
8972          return success;
8973      }
8974      template&lt;typename NumberType&gt;
8975      bool get_binary(const input_format_t format,
8976                      const NumberType len,
8977                      binary_t&amp; result)
8978      {
8979          bool success = true;
8980          for (NumberType i = 0; i &lt; len; i++)
8981          {
8982              get();
8983              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, &quot;binary&quot;)))
8984              {
8985                  success = false;
8986                  break;
8987              }
8988              result.push_back(static_cast&lt;std::uint8_t&gt;(current));
8989          }
8990          return success;
8991      }
8992      JSON_HEDLEY_NON_NULL(3)
8993      bool unexpect_eof(const input_format_t format, const char* context) const
8994      {
8995          if (JSON_HEDLEY_UNLIKELY(current == std::char_traits&lt;char_type&gt;::eof()))
8996          {
8997              return sax-&gt;parse_error(chars_read, &quot;&lt;end of file&gt;&quot;,
8998                                      parse_error::create(110, chars_read, exception_message(format, &quot;unexpected end of input&quot;, context), nullptr));
8999          }
9000          return true;
9001      }
9002      std::string get_token_string() const
9003      {
9004          std::array&lt;char, 3&gt; cr{{}};
9005          static_cast&lt;void&gt;((std::snprintf)(cr.data(), cr.size(), &quot;%.2hhX&quot;, static_cast&lt;unsigned char&gt;(current))); 
9006          return std::string{cr.data()};
9007      }
9008      std::string exception_message(const input_format_t format,
9009                                    const std::string&amp; detail,
9010                                    const std::string&amp; context) const
9011      {
9012          std::string error_msg = &quot;syntax error while parsing &quot;;
9013          switch (format)
9014          {
9015              case input_format_t::cbor:
9016                  error_msg += &quot;CBOR&quot;;
9017                  break;
9018              case input_format_t::msgpack:
9019                  error_msg += &quot;MessagePack&quot;;
9020                  break;
9021              case input_format_t::ubjson:
9022                  error_msg += &quot;UBJSON&quot;;
9023                  break;
9024              case input_format_t::bson:
9025                  error_msg += &quot;BSON&quot;;
9026                  break;
9027              case input_format_t::bjdata:
9028                  error_msg += &quot;BJData&quot;;
9029                  break;
9030              case input_format_t::json: 
9031              default:            
9032                  JSON_ASSERT(false); 
9033          }
9034          return concat(error_msg, &#x27; &#x27;, context, &quot;: &quot;, detail);
9035      }
9036    private:
9037      static JSON_INLINE_VARIABLE constexpr std::size_t npos = static_cast&lt;std::size_t&gt;(-1);
9038      InputAdapterType ia;
9039      char_int_type current = std::char_traits&lt;char_type&gt;::eof();
9040      std::size_t chars_read = 0;
9041      const bool is_little_endian = little_endianness();
9042      const input_format_t input_format = input_format_t::json;
9043      json_sax_t* sax = nullptr;
9044  #define JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_ \
9045      make_array&lt;char_int_type&gt;(&#x27;F&#x27;, &#x27;H&#x27;, &#x27;N&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;Z&#x27;, &#x27;[&#x27;, &#x27;{&#x27;)
9046  #define JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_ \
9047      make_array&lt;bjd_type&gt;(                      \
9048      bjd_type{&#x27;C&#x27;, &quot;char&quot;},                     \
9049      bjd_type{&#x27;D&#x27;, &quot;double&quot;},                   \
9050      bjd_type{&#x27;I&#x27;, &quot;int16&quot;},                    \
9051      bjd_type{&#x27;L&#x27;, &quot;int64&quot;},                    \
9052      bjd_type{&#x27;M&#x27;, &quot;uint64&quot;},                   \
9053      bjd_type{&#x27;U&#x27;, &quot;uint8&quot;},                    \
9054      bjd_type{&#x27;d&#x27;, &quot;single&quot;},                   \
9055      bjd_type{&#x27;i&#x27;, &quot;int8&quot;},                     \
9056      bjd_type{&#x27;l&#x27;, &quot;int32&quot;},                    \
9057      bjd_type{&#x27;m&#x27;, &quot;uint32&quot;},                   \
9058      bjd_type{&#x27;u&#x27;, &quot;uint16&quot;})
9059    JSON_PRIVATE_UNLESS_TESTED:
9060      const decltype(JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_) bjd_optimized_type_markers =
9061          JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_;
9062      using bjd_type = std::pair&lt;char_int_type, string_t&gt;;
9063      const decltype(JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_) bjd_types_map =
9064          JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_;
9065  #undef JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_
9066  #undef JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_
9067  };
9068  #ifndef JSON_HAS_CPP_17
9069      template&lt;typename BasicJsonType, typename InputAdapterType, typename SAX&gt;
9070      constexpr std::size_t binary_reader&lt;BasicJsonType, InputAdapterType, SAX&gt;::npos;
9071  #endif
9072  }  
9073  NLOHMANN_JSON_NAMESPACE_END
9074  #include &lt;cmath&gt; 
9075  #include &lt;cstdint&gt; 
9076  #include &lt;functional&gt; 
9077  #include &lt;string&gt; 
9078  #include &lt;utility&gt; 
9079  #include &lt;vector&gt; 
9080  NLOHMANN_JSON_NAMESPACE_BEGIN
9081  namespace detail
9082  {
9083  enum class parse_event_t : std::uint8_t
9084  {
9085      object_start,
9086      object_end,
9087      array_start,
9088      array_end,
9089      key,
9090      value
9091  };
9092  template&lt;typename BasicJsonType&gt;
9093  using parser_callback_t =
9094      std::function&lt;bool(int &amp;bsol;*depth*/, parse_event_t &amp;bsol;*event*/, BasicJsonType&amp; &amp;bsol;*parsed*/)&gt;;
9095  template&lt;typename BasicJsonType, typename InputAdapterType&gt;
9096  class parser
9097  {
9098      using number_integer_t = typename BasicJsonType::number_integer_t;
9099      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
9100      using number_float_t = typename BasicJsonType::number_float_t;
9101      using string_t = typename BasicJsonType::string_t;
9102      using lexer_t = lexer&lt;BasicJsonType, InputAdapterType&gt;;
9103      using token_type = typename lexer_t::token_type;
9104    public:
9105      explicit parser(InputAdapterType&amp;&amp; adapter,
9106                      const parser_callback_t&lt;BasicJsonType&gt; cb = nullptr,
9107                      const bool allow_exceptions_ = true,
9108                      const bool skip_comments = false)
9109          : callback(cb)
9110          , m_lexer(std::move(adapter), skip_comments)
9111          , allow_exceptions(allow_exceptions_)
9112      {
9113          get_token();
9114      }
9115      void parse(const bool strict, BasicJsonType&amp; result)
9116      {
9117          if (callback)
9118          {
9119              json_sax_dom_callback_parser&lt;BasicJsonType&gt; sdp(result, callback, allow_exceptions);
9120              sax_parse_internal(&amp;sdp);
9121              if (strict &amp;&amp; (get_token() != token_type::end_of_input))
9122              {
9123                  sdp.parse_error(m_lexer.get_position(),
9124                                  m_lexer.get_token_string(),
9125                                  parse_error::create(101, m_lexer.get_position(),
9126                                                      exception_message(token_type::end_of_input, &quot;value&quot;), nullptr));
9127              }
9128              if (sdp.is_errored())
9129              {
9130                  result = value_t::discarded;
9131                  return;
9132              }
9133              if (result.is_discarded())
9134              {
9135                  result = nullptr;
9136              }
9137          }
9138          else
9139          {
9140              json_sax_dom_parser&lt;BasicJsonType&gt; sdp(result, allow_exceptions);
9141              sax_parse_internal(&amp;sdp);
9142              if (strict &amp;&amp; (get_token() != token_type::end_of_input))
9143              {
9144                  sdp.parse_error(m_lexer.get_position(),
9145                                  m_lexer.get_token_string(),
9146                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, &quot;value&quot;), nullptr));
9147              }
9148              if (sdp.is_errored())
9149              {
9150                  result = value_t::discarded;
9151                  return;
9152              }
9153          }
9154          result.assert_invariant();
9155      }
9156      bool accept(const bool strict = true)
9157      {
9158          json_sax_acceptor&lt;BasicJsonType&gt; sax_acceptor;
9159          return sax_parse(&amp;sax_acceptor, strict);
9160      }
9161      template&lt;typename SAX&gt;
9162      JSON_HEDLEY_NON_NULL(2)
9163      bool sax_parse(SAX* sax, const bool strict = true)
9164      {
9165          (void)detail::is_sax_static_asserts&lt;SAX, BasicJsonType&gt; {};
9166          const bool result = sax_parse_internal(sax);
9167          if (result &amp;&amp; strict &amp;&amp; (get_token() != token_type::end_of_input))
9168          {
9169              return sax-&gt;parse_error(m_lexer.get_position(),
9170                                      m_lexer.get_token_string(),
9171                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, &quot;value&quot;), nullptr));
9172          }
9173          return result;
9174      }
9175    private:
9176      template&lt;typename SAX&gt;
9177      JSON_HEDLEY_NON_NULL(2)
9178      bool sax_parse_internal(SAX* sax)
9179      {
9180          std::vector&lt;bool&gt; states;
9181          bool skip_to_state_evaluation = false;
9182          while (true)
9183          {
9184              if (!skip_to_state_evaluation)
9185              {
9186                  switch (last_token)
9187                  {
9188                      case token_type::begin_object:
9189                      {
9190                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(static_cast&lt;std::size_t&gt;(-1))))
9191                          {
9192                              return false;
9193                          }
9194                          if (get_token() == token_type::end_object)
9195                          {
9196                              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_object()))
9197                              {
9198                                  return false;
9199                              }
9200                              break;
9201                          }
9202                          if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
9203                          {
9204                              return sax-&gt;parse_error(m_lexer.get_position(),
9205                                                      m_lexer.get_token_string(),
9206                                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, &quot;object key&quot;), nullptr));
9207                          }
9208                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;key(m_lexer.get_string())))
9209                          {
9210                              return false;
9211                          }
9212                          if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
9213                          {
9214                              return sax-&gt;parse_error(m_lexer.get_position(),
9215                                                      m_lexer.get_token_string(),
9216                                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, &quot;object separator&quot;), nullptr));
9217                          }
9218                          states.push_back(false);
9219                          get_token();
9220                          continue;
9221                      }
9222                      case token_type::begin_array:
9223                      {
9224                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(static_cast&lt;std::size_t&gt;(-1))))
9225                          {
9226                              return false;
9227                          }
9228                          if (get_token() == token_type::end_array)
9229                          {
9230                              if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_array()))
9231                              {
9232                                  return false;
9233                              }
9234                              break;
9235                          }
9236                          states.push_back(true);
9237                          continue;
9238                      }
9239                      case token_type::value_float:
9240                      {
9241                          const auto res = m_lexer.get_number_float();
9242                          if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
9243                          {
9244                              return sax-&gt;parse_error(m_lexer.get_position(),
9245                                                      m_lexer.get_token_string(),
9246                                                      out_of_range::create(406, concat(&quot;number overflow parsing &#x27;&quot;, m_lexer.get_token_string(), &#x27;\&#x27;&#x27;), nullptr));
9247                          }
9248                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_float(res, m_lexer.get_string())))
9249                          {
9250                              return false;
9251                          }
9252                          break;
9253                      }
9254                      case token_type::literal_false:
9255                      {
9256                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;boolean(false)))
9257                          {
9258                              return false;
9259                          }
9260                          break;
9261                      }
9262                      case token_type::literal_null:
9263                      {
9264                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;null()))
9265                          {
9266                              return false;
9267                          }
9268                          break;
9269                      }
9270                      case token_type::literal_true:
9271                      {
9272                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;boolean(true)))
9273                          {
9274                              return false;
9275                          }
9276                          break;
9277                      }
9278                      case token_type::value_integer:
9279                      {
9280                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_integer(m_lexer.get_number_integer())))
9281                          {
9282                              return false;
9283                          }
9284                          break;
9285                      }
9286                      case token_type::value_string:
9287                      {
9288                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;string(m_lexer.get_string())))
9289                          {
9290                              return false;
9291                          }
9292                          break;
9293                      }
9294                      case token_type::value_unsigned:
9295                      {
9296                          if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_unsigned(m_lexer.get_number_unsigned())))
9297                          {
9298                              return false;
9299                          }
9300                          break;
9301                      }
9302                      case token_type::parse_error:
9303                      {
9304                          return sax-&gt;parse_error(m_lexer.get_position(),
9305                                                  m_lexer.get_token_string(),
9306                                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, &quot;value&quot;), nullptr));
9307                      }
9308                      case token_type::uninitialized:
9309                      case token_type::end_array:
9310                      case token_type::end_object:
9311                      case token_type::name_separator:
9312                      case token_type::value_separator:
9313                      case token_type::end_of_input:
9314                      case token_type::literal_or_value:
9315                      default: 
9316                      {
9317                          return sax-&gt;parse_error(m_lexer.get_position(),
9318                                                  m_lexer.get_token_string(),
9319                                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, &quot;value&quot;), nullptr));
9320                      }
9321                  }
9322              }
9323              else
9324              {
9325                  skip_to_state_evaluation = false;
9326              }
9327              if (states.empty())
9328              {
9329                  return true;
9330              }
9331              if (states.back())  
9332              {
9333                  if (get_token() == token_type::value_separator)
9334                  {
9335                      get_token();
9336                      continue;
9337                  }
9338                  if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
9339                  {
9340                      if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_array()))
9341                      {
9342                          return false;
9343                      }
9344                      JSON_ASSERT(!states.empty());
9345                      states.pop_back();
9346                      skip_to_state_evaluation = true;
9347                      continue;
9348                  }
9349                  return sax-&gt;parse_error(m_lexer.get_position(),
9350                                          m_lexer.get_token_string(),
9351                                          parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, &quot;array&quot;), nullptr));
9352              }
9353              if (get_token() == token_type::value_separator)
9354              {
9355                  if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
9356                  {
9357                      return sax-&gt;parse_error(m_lexer.get_position(),
9358                                              m_lexer.get_token_string(),
9359                                              parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, &quot;object key&quot;), nullptr));
9360                  }
9361                  if (JSON_HEDLEY_UNLIKELY(!sax-&gt;key(m_lexer.get_string())))
9362                  {
9363                      return false;
9364                  }
9365                  if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
9366                  {
9367                      return sax-&gt;parse_error(m_lexer.get_position(),
9368                                              m_lexer.get_token_string(),
9369                                              parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, &quot;object separator&quot;), nullptr));
9370                  }
9371                  get_token();
9372                  continue;
9373              }
9374              if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
9375              {
9376                  if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_object()))
9377                  {
9378                      return false;
9379                  }
9380                  JSON_ASSERT(!states.empty());
9381                  states.pop_back();
9382                  skip_to_state_evaluation = true;
9383                  continue;
9384              }
9385              return sax-&gt;parse_error(m_lexer.get_position(),
9386                                      m_lexer.get_token_string(),
9387                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, &quot;object&quot;), nullptr));
9388          }
9389      }
9390      token_type get_token()
9391      {
9392          return last_token = m_lexer.scan();
9393      }
9394      std::string exception_message(const token_type expected, const std::string&amp; context)
9395      {
9396          std::string error_msg = &quot;syntax error &quot;;
9397          if (!context.empty())
9398          {
9399              error_msg += concat(&quot;while parsing &quot;, context, &#x27; &#x27;);
9400          }
9401          error_msg += &quot;- &quot;;
9402          if (last_token == token_type::parse_error)
9403          {
9404              error_msg += concat(m_lexer.get_error_message(), &quot;; last read: &#x27;&quot;,
9405                                  m_lexer.get_token_string(), &#x27;\&#x27;&#x27;);
9406          }
9407          else
9408          {
9409              error_msg += concat(&quot;unexpected &quot;, lexer_t::token_type_name(last_token));
9410          }
9411          if (expected != token_type::uninitialized)
9412          {
9413              error_msg += concat(&quot;; expected &quot;, lexer_t::token_type_name(expected));
9414          }
9415          return error_msg;
9416      }
9417    private:
9418      const parser_callback_t&lt;BasicJsonType&gt; callback = nullptr;
9419      token_type last_token = token_type::uninitialized;
9420      lexer_t m_lexer;
9421      const bool allow_exceptions = true;
9422  };
9423  }  
9424  NLOHMANN_JSON_NAMESPACE_END
9425  #include &lt;cstddef&gt; 
9426  #include &lt;limits&gt;  
9427  NLOHMANN_JSON_NAMESPACE_BEGIN
9428  namespace detail
9429  {
9430  class primitive_iterator_t
9431  {
9432    private:
9433      using difference_type = std::ptrdiff_t;
9434      static constexpr difference_type begin_value = 0;
9435      static constexpr difference_type end_value = begin_value + 1;
9436    JSON_PRIVATE_UNLESS_TESTED:
9437      difference_type m_it = (std::numeric_limits&lt;std::ptrdiff_t&gt;::min)();
9438    public:
9439      constexpr difference_type get_value() const noexcept
9440      {
9441          return m_it;
9442      }
9443      void set_begin() noexcept
9444      {
9445          m_it = begin_value;
9446      }
9447      void set_end() noexcept
9448      {
9449          m_it = end_value;
9450      }
9451      constexpr bool is_begin() const noexcept
9452      {
9453          return m_it == begin_value;
9454      }
9455      constexpr bool is_end() const noexcept
9456      {
9457          return m_it == end_value;
9458      }
9459      friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
9460      {
9461          return lhs.m_it == rhs.m_it;
9462      }
9463      friend constexpr bool operator&lt;(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
9464      {
9465          return lhs.m_it &lt; rhs.m_it;
9466      }
9467      primitive_iterator_t operator+(difference_type n) noexcept
9468      {
9469          auto result = *this;
9470          result += n;
9471          return result;
9472      }
9473      friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
9474      {
9475          return lhs.m_it - rhs.m_it;
9476      }
9477      primitive_iterator_t&amp; operator++() noexcept
9478      {
9479          ++m_it;
9480          return *this;
9481      }
9482      primitive_iterator_t operator++(int)&amp; noexcept 
9483      {
9484          auto result = *this;
9485          ++m_it;
9486          return result;
9487      }
9488      primitive_iterator_t&amp; operator--() noexcept
9489      {
9490          --m_it;
9491          return *this;
9492      }
9493      primitive_iterator_t operator--(int)&amp; noexcept 
9494      {
9495          auto result = *this;
9496          --m_it;
9497          return result;
9498      }
9499      primitive_iterator_t&amp; operator+=(difference_type n) noexcept
9500      {
9501          m_it += n;
9502          return *this;
9503      }
9504      primitive_iterator_t&amp; operator-=(difference_type n) noexcept
9505      {
9506          m_it -= n;
9507          return *this;
9508      }
9509  };
9510  }  
9511  NLOHMANN_JSON_NAMESPACE_END
9512  NLOHMANN_JSON_NAMESPACE_BEGIN
9513  namespace detail
9514  {
9515  template&lt;typename BasicJsonType&gt; struct internal_iterator
9516  {
9517      typename BasicJsonType::object_t::iterator object_iterator {};
9518      typename BasicJsonType::array_t::iterator array_iterator {};
9519      primitive_iterator_t primitive_iterator {};
9520  };
9521  }  
9522  NLOHMANN_JSON_NAMESPACE_END
9523  #include &lt;iterator&gt; 
9524  #include &lt;type_traits&gt; 
9525  NLOHMANN_JSON_NAMESPACE_BEGIN
9526  namespace detail
9527  {
9528  template&lt;typename IteratorType&gt; class iteration_proxy;
9529  template&lt;typename IteratorType&gt; class iteration_proxy_value;
9530  template&lt;typename BasicJsonType&gt;
9531  class iter_impl 
9532  {
9533      using other_iter_impl = iter_impl&lt;typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value, typename std::remove_const&lt;BasicJsonType&gt;::type, const BasicJsonType&gt;::type&gt;;
9534      friend other_iter_impl;
9535      friend BasicJsonType;
9536      friend iteration_proxy&lt;iter_impl&gt;;
9537      friend iteration_proxy_value&lt;iter_impl&gt;;
9538      using object_t = typename BasicJsonType::object_t;
9539      using array_t = typename BasicJsonType::array_t;
9540      static_assert(is_basic_json&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;::value,
9541                    &quot;iter_impl only accepts (const) basic_json&quot;);
9542      static_assert(std::is_base_of&lt;std::bidirectional_iterator_tag, std::bidirectional_iterator_tag&gt;::value
9543                    &amp;&amp;  std::is_base_of&lt;std::bidirectional_iterator_tag, typename std::iterator_traits&lt;typename array_t::iterator&gt;::iterator_category&gt;::value,
9544                    &quot;basic_json iterator assumes array and object type iterators satisfy the LegacyBidirectionalIterator named requirement.&quot;);
9545    public:
9546      using iterator_category = std::bidirectional_iterator_tag;
9547      using value_type = typename BasicJsonType::value_type;
9548      using difference_type = typename BasicJsonType::difference_type;
9549      using pointer = typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value,
9550            typename BasicJsonType::const_pointer,
9551            typename BasicJsonType::pointer&gt;::type;
9552      using reference =
9553          typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value,
9554          typename BasicJsonType::const_reference,
9555          typename BasicJsonType::reference&gt;::type;
9556      iter_impl() = default;
9557      ~iter_impl() = default;
9558      iter_impl(iter_impl&amp;&amp;) noexcept = default;
9559      iter_impl&amp; operator=(iter_impl&amp;&amp;) noexcept = default;
9560      explicit iter_impl(pointer object) noexcept : m_object(object)
9561      {
9562          JSON_ASSERT(m_object != nullptr);
9563          switch (m_object-&gt;m_type)
9564          {
9565              case value_t::object:
9566              {
9567                  m_it.object_iterator = typename object_t::iterator();
9568                  break;
9569              }
9570              case value_t::array:
9571              {
9572                  m_it.array_iterator = typename array_t::iterator();
9573                  break;
9574              }
9575              case value_t::null:
9576              case value_t::string:
9577              case value_t::boolean:
9578              case value_t::number_integer:
9579              case value_t::number_unsigned:
9580              case value_t::number_float:
9581              case value_t::binary:
9582              case value_t::discarded:
9583              default:
9584              {
9585                  m_it.primitive_iterator = primitive_iterator_t();
9586                  break;
9587              }
9588          }
9589      }
9590      iter_impl(const iter_impl&lt;const BasicJsonType&gt;&amp; other) noexcept
9591          : m_object(other.m_object), m_it(other.m_it)
9592      {}
9593      iter_impl&amp; operator=(const iter_impl&lt;const BasicJsonType&gt;&amp; other) noexcept
9594      {
9595          if (&amp;other != this)
9596          {
9597              m_object = other.m_object;
9598              m_it = other.m_it;
9599          }
9600          return *this;
9601      }
9602      iter_impl(const iter_impl&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;&amp; other) noexcept
9603          : m_object(other.m_object), m_it(other.m_it)
9604      {}
9605      iter_impl&amp; operator=(const iter_impl&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;&amp; other) noexcept 
9606      {
9607          m_object = other.m_object;
9608          m_it = other.m_it;
9609          return *this;
9610      }
9611    JSON_PRIVATE_UNLESS_TESTED:
9612      void set_begin() noexcept
9613      {
9614          JSON_ASSERT(m_object != nullptr);
9615          switch (m_object-&gt;m_type)
9616          {
9617              case value_t::object:
9618              {
9619                  m_it.object_iterator = m_object-&gt;m_value.object-&gt;begin();
9620                  break;
9621              }
9622              case value_t::array:
9623              {
9624                  m_it.array_iterator = m_object-&gt;m_value.array-&gt;begin();
9625                  break;
9626              }
9627              case value_t::null:
9628              {
9629                  m_it.primitive_iterator.set_end();
9630                  break;
9631              }
9632              case value_t::string:
9633              case value_t::boolean:
9634              case value_t::number_integer:
9635              case value_t::number_unsigned:
9636              case value_t::number_float:
9637              case value_t::binary:
9638              case value_t::discarded:
9639              default:
9640              {
9641                  m_it.primitive_iterator.set_begin();
9642                  break;
9643              }
9644          }
9645      }
9646      void set_end() noexcept
9647      {
9648          JSON_ASSERT(m_object != nullptr);
9649          switch (m_object-&gt;m_type)
9650          {
9651              case value_t::object:
9652              {
9653                  m_it.object_iterator = m_object-&gt;m_value.object-&gt;end();
9654                  break;
9655              }
9656              case value_t::array:
9657              {
9658                  m_it.array_iterator = m_object-&gt;m_value.array-&gt;end();
9659                  break;
9660              }
9661              case value_t::null:
9662              case value_t::string:
9663              case value_t::boolean:
9664              case value_t::number_integer:
9665              case value_t::number_unsigned:
9666              case value_t::number_float:
9667              case value_t::binary:
9668              case value_t::discarded:
9669              default:
9670              {
9671                  m_it.primitive_iterator.set_end();
9672                  break;
9673              }
9674          }
9675      }
9676    public:
9677      reference operator*() const
9678      {
9679          JSON_ASSERT(m_object != nullptr);
9680          switch (m_object-&gt;m_type)
9681          {
9682              case value_t::object:
9683              {
9684                  JSON_ASSERT(m_it.object_iterator != m_object-&gt;m_value.object-&gt;end());
9685                  return m_it.object_iterator-&gt;second;
9686              }
9687              case value_t::array:
9688              {
9689                  JSON_ASSERT(m_it.array_iterator != m_object-&gt;m_value.array-&gt;end());
9690                  return *m_it.array_iterator;
9691              }
9692              case value_t::null:
9693                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, m_object));
9694              case value_t::string:
9695              case value_t::boolean:
9696              case value_t::number_integer:
9697              case value_t::number_unsigned:
9698              case value_t::number_float:
9699              case value_t::binary:
9700              case value_t::discarded:
9701              default:
9702              {
9703                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
9704                  {
9705                      return *m_object;
9706                  }
9707                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, m_object));
9708              }
9709          }
9710      }
9711      pointer operator-&gt;() const
9712      {
9713          JSON_ASSERT(m_object != nullptr);
9714          switch (m_object-&gt;m_type)
9715          {
9716              case value_t::object:
9717              {
9718                  JSON_ASSERT(m_it.object_iterator != m_object-&gt;m_value.object-&gt;end());
9719                  return &amp;(m_it.object_iterator-&gt;second);
9720              }
9721              case value_t::array:
9722              {
9723                  JSON_ASSERT(m_it.array_iterator != m_object-&gt;m_value.array-&gt;end());
9724                  return &amp;*m_it.array_iterator;
9725              }
9726              case value_t::null:
9727              case value_t::string:
9728              case value_t::boolean:
9729              case value_t::number_integer:
9730              case value_t::number_unsigned:
9731              case value_t::number_float:
9732              case value_t::binary:
9733              case value_t::discarded:
9734              default:
9735              {
9736                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
9737                  {
9738                      return m_object;
9739                  }
9740                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, m_object));
9741              }
9742          }
9743      }
9744      iter_impl operator++(int)&amp; 
9745      {
9746          auto result = *this;
9747          ++(*this);
9748          return result;
9749      }
9750      iter_impl&amp; operator++()
9751      {
9752          JSON_ASSERT(m_object != nullptr);
9753          switch (m_object-&gt;m_type)
9754          {
9755              case value_t::object:
9756              {
9757                  std::advance(m_it.object_iterator, 1);
9758                  break;
9759              }
9760              case value_t::array:
9761              {
9762                  std::advance(m_it.array_iterator, 1);
9763                  break;
9764              }
9765              case value_t::null:
9766              case value_t::string:
9767              case value_t::boolean:
9768              case value_t::number_integer:
9769              case value_t::number_unsigned:
9770              case value_t::number_float:
9771              case value_t::binary:
9772              case value_t::discarded:
9773              default:
9774              {
9775                  ++m_it.primitive_iterator;
9776                  break;
9777              }
9778          }
9779          return *this;
9780      }
9781      iter_impl operator--(int)&amp; 
9782      {
9783          auto result = *this;
9784          --(*this);
9785          return result;
9786      }
9787      iter_impl&amp; operator--()
9788      {
9789          JSON_ASSERT(m_object != nullptr);
9790          switch (m_object-&gt;m_type)
9791          {
9792              case value_t::object:
9793              {
9794                  std::advance(m_it.object_iterator, -1);
9795                  break;
9796              }
9797              case value_t::array:
9798              {
9799                  std::advance(m_it.array_iterator, -1);
9800                  break;
9801              }
9802              case value_t::null:
9803              case value_t::string:
9804              case value_t::boolean:
9805              case value_t::number_integer:
9806              case value_t::number_unsigned:
9807              case value_t::number_float:
9808              case value_t::binary:
9809              case value_t::discarded:
9810              default:
9811              {
9812                  --m_it.primitive_iterator;
9813                  break;
9814              }
9815          }
9816          return *this;
9817      }
9818      template &lt; typename IterImpl, detail::enable_if_t &lt; (std::is_same&lt;IterImpl, iter_impl&gt;::value || std::is_same&lt;IterImpl, other_iter_impl&gt;::value), std::nullptr_t &gt; = nullptr &gt;
9819      bool operator==(const IterImpl&amp; other) const
9820      {
9821          if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
9822          {
9823              JSON_THROW(invalid_iterator::create(212, &quot;cannot compare iterators of different containers&quot;, m_object));
9824          }
9825          JSON_ASSERT(m_object != nullptr);
9826          switch (m_object-&gt;m_type)
9827          {
9828              case value_t::object:
9829                  return (m_it.object_iterator == other.m_it.object_iterator);
9830              case value_t::array:
9831                  return (m_it.array_iterator == other.m_it.array_iterator);
9832              case value_t::null:
9833              case value_t::string:
9834              case value_t::boolean:
9835              case value_t::number_integer:
9836              case value_t::number_unsigned:
9837              case value_t::number_float:
9838              case value_t::binary:
9839              case value_t::discarded:
9840              default:
9841                  return (m_it.primitive_iterator == other.m_it.primitive_iterator);
9842          }
9843      }
9844      template &lt; typename IterImpl, detail::enable_if_t &lt; (std::is_same&lt;IterImpl, iter_impl&gt;::value || std::is_same&lt;IterImpl, other_iter_impl&gt;::value), std::nullptr_t &gt; = nullptr &gt;
9845      bool operator!=(const IterImpl&amp; other) const
9846      {
9847          return !operator==(other);
9848      }
9849      bool operator&lt;(const iter_impl&amp; other) const
9850      {
9851          if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
9852          {
9853              JSON_THROW(invalid_iterator::create(212, &quot;cannot compare iterators of different containers&quot;, m_object));
9854          }
9855          JSON_ASSERT(m_object != nullptr);
9856          switch (m_object-&gt;m_type)
9857          {
9858              case value_t::object:
9859                  JSON_THROW(invalid_iterator::create(213, &quot;cannot compare order of object iterators&quot;, m_object));
9860              case value_t::array:
9861                  return (m_it.array_iterator &lt; other.m_it.array_iterator);
9862              case value_t::null:
9863              case value_t::string:
9864              case value_t::boolean:
9865              case value_t::number_integer:
9866              case value_t::number_unsigned:
9867              case value_t::number_float:
9868              case value_t::binary:
9869              case value_t::discarded:
9870              default:
9871                  return (m_it.primitive_iterator &lt; other.m_it.primitive_iterator);
9872          }
9873      }
9874      bool operator&lt;=(const iter_impl&amp; other) const
9875      {
9876          return !other.operator &lt; (*this);
9877      }
9878      bool operator&gt;(const iter_impl&amp; other) const
9879      {
9880          return !operator&lt;=(other);
9881      }
9882      bool operator&gt;=(const iter_impl&amp; other) const
9883      {
9884          return !operator&lt;(other);
9885      }
9886      iter_impl&amp; operator+=(difference_type i)
9887      {
9888          JSON_ASSERT(m_object != nullptr);
9889          switch (m_object-&gt;m_type)
9890          {
9891              case value_t::object:
9892                  JSON_THROW(invalid_iterator::create(209, &quot;cannot use offsets with object iterators&quot;, m_object));
9893              case value_t::array:
9894              {
9895                  std::advance(m_it.array_iterator, i);
9896                  break;
9897              }
9898              case value_t::null:
9899              case value_t::string:
9900              case value_t::boolean:
9901              case value_t::number_integer:
9902              case value_t::number_unsigned:
9903              case value_t::number_float:
9904              case value_t::binary:
9905              case value_t::discarded:
9906              default:
9907              {
9908                  m_it.primitive_iterator += i;
9909                  break;
9910              }
9911          }
9912          return *this;
9913      }
9914      iter_impl&amp; operator-=(difference_type i)
9915      {
9916          return operator+=(-i);
9917      }
9918      iter_impl operator+(difference_type i) const
9919      {
9920          auto result = *this;
9921          result += i;
9922          return result;
9923      }
9924      friend iter_impl operator+(difference_type i, const iter_impl&amp; it)
9925      {
9926          auto result = it;
9927          result += i;
9928          return result;
9929      }
9930      iter_impl operator-(difference_type i) const
9931      {
9932          auto result = *this;
9933          result -= i;
9934          return result;
9935      }
9936      difference_type operator-(const iter_impl&amp; other) const
9937      {
9938          JSON_ASSERT(m_object != nullptr);
9939          switch (m_object-&gt;m_type)
9940          {
9941              case value_t::object:
9942                  JSON_THROW(invalid_iterator::create(209, &quot;cannot use offsets with object iterators&quot;, m_object));
9943              case value_t::array:
9944                  return m_it.array_iterator - other.m_it.array_iterator;
9945              case value_t::null:
9946              case value_t::string:
9947              case value_t::boolean:
9948              case value_t::number_integer:
9949              case value_t::number_unsigned:
9950              case value_t::number_float:
9951              case value_t::binary:
9952              case value_t::discarded:
9953              default:
9954                  return m_it.primitive_iterator - other.m_it.primitive_iterator;
9955          }
9956      }
9957      reference operator[](difference_type n) const
9958      {
9959          JSON_ASSERT(m_object != nullptr);
9960          switch (m_object-&gt;m_type)
9961          {
9962              case value_t::object:
9963                  JSON_THROW(invalid_iterator::create(208, &quot;cannot use operator[] for object iterators&quot;, m_object));
9964              case value_t::array:
9965                  return *std::next(m_it.array_iterator, n);
9966              case value_t::null:
9967                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, m_object));
9968              case value_t::string:
9969              case value_t::boolean:
9970              case value_t::number_integer:
9971              case value_t::number_unsigned:
9972              case value_t::number_float:
9973              case value_t::binary:
9974              case value_t::discarded:
9975              default:
9976              {
9977                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
9978                  {
9979                      return *m_object;
9980                  }
9981                  JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;, m_object));
9982              }
9983          }
9984      }
9985      const typename object_t::key_type&amp; key() const
9986      {
9987          JSON_ASSERT(m_object != nullptr);
9988          if (JSON_HEDLEY_LIKELY(m_object-&gt;is_object()))
9989          {
9990              return m_it.object_iterator-&gt;first;
9991          }
9992          JSON_THROW(invalid_iterator::create(207, &quot;cannot use key() for non-object iterators&quot;, m_object));
9993      }
9994      reference value() const
9995      {
9996          return operator*();
9997      }
9998    JSON_PRIVATE_UNLESS_TESTED:
9999      pointer m_object = nullptr;
10000      internal_iterator&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt; m_it {};
10001  };
10002  }  
10003  NLOHMANN_JSON_NAMESPACE_END
10004  #include &lt;cstddef&gt; 
10005  #include &lt;iterator&gt; 
10006  #include &lt;utility&gt; 
10007  NLOHMANN_JSON_NAMESPACE_BEGIN
10008  namespace detail
10009  {
10010  template&lt;typename Base&gt;
10011  class json_reverse_iterator : public std::reverse_iterator&lt;Base&gt;
10012  {
10013    public:
10014      using difference_type = std::ptrdiff_t;
10015      using base_iterator = std::reverse_iterator&lt;Base&gt;;
10016      using reference = typename Base::reference;
10017      explicit json_reverse_iterator(const typename base_iterator::iterator_type&amp; it) noexcept
10018          : base_iterator(it) {}
10019      explicit json_reverse_iterator(const base_iterator&amp; it) noexcept : base_iterator(it) {}
10020      json_reverse_iterator operator++(int)&amp; 
10021      {
10022          return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator++(1));
10023      }
10024      json_reverse_iterator&amp; operator++()
10025      {
10026          return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator++());
10027      }
10028      json_reverse_iterator operator--(int)&amp; 
10029      {
10030          return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator--(1));
10031      }
10032      json_reverse_iterator&amp; operator--()
10033      {
10034          return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator--());
10035      }
10036      json_reverse_iterator&amp; operator+=(difference_type i)
10037      {
10038          return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator+=(i));
10039      }
10040      json_reverse_iterator operator+(difference_type i) const
10041      {
10042          return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator+(i));
10043      }
10044      json_reverse_iterator operator-(difference_type i) const
10045      {
10046          return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator-(i));
10047      }
10048      difference_type operator-(const json_reverse_iterator&amp; other) const
10049      {
10050          return base_iterator(*this) - base_iterator(other);
10051      }
10052      reference operator[](difference_type n) const
10053      {
10054          return *(this-&gt;operator+(n));
10055      }
10056      auto key() const -&gt; decltype(std::declval&lt;Base&gt;().key())
10057      {
10058          auto it = --this-&gt;base();
10059          return it.key();
10060      }
10061      reference value() const
10062      {
10063          auto it = --this-&gt;base();
10064          return it.operator * ();
10065      }
10066  };
10067  }  
10068  NLOHMANN_JSON_NAMESPACE_END
10069  #include &lt;algorithm&gt; 
10070  #include &lt;cctype&gt; 
10071  #include &lt;cerrno&gt; 
10072  #include &lt;cstdlib&gt; 
10073  #ifndef JSON_NO_IO
10074      #include &lt;iosfwd&gt; 
10075  #endif  
10076  #include &lt;limits&gt; 
10077  #include &lt;numeric&gt; 
10078  #include &lt;string&gt; 
10079  #include &lt;utility&gt; 
10080  #include &lt;vector&gt; 
10081  NLOHMANN_JSON_NAMESPACE_BEGIN
10082  template&lt;typename RefStringType&gt;
10083  class json_pointer
10084  {
10085      NLOHMANN_BASIC_JSON_TPL_DECLARATION
10086      friend class basic_json;
10087      template&lt;typename&gt;
10088      friend class json_pointer;
10089      template&lt;typename T&gt;
10090      struct string_t_helper
10091      {
10092          using type = T;
10093      };
10094      NLOHMANN_BASIC_JSON_TPL_DECLARATION
10095      struct string_t_helper&lt;NLOHMANN_BASIC_JSON_TPL&gt;
10096      {
10097          using type = StringType;
10098      };
10099    public:
10100      using string_t = typename string_t_helper&lt;RefStringType&gt;::type;
10101      explicit json_pointer(const string_t&amp; s = &quot;&quot;)
10102          : reference_tokens(split(s))
10103      {}
10104      string_t to_string() const
10105      {
10106          return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
10107                                 string_t{},
10108                                 [](const string_t&amp; a, const string_t&amp; b)
10109          {
10110              return detail::concat(a, &#x27;/&#x27;, detail::escape(b));
10111          });
10112      }
10113      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, to_string())
10114      operator string_t() const
10115      {
10116          return to_string();
10117      }
10118  #ifndef JSON_NO_IO
10119      friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const json_pointer&amp; ptr)
10120      {
10121          o &lt;&lt; ptr.to_string();
10122          return o;
10123      }
10124  #endif
10125      json_pointer&amp; operator/=(const json_pointer&amp; ptr)
10126      {
10127          reference_tokens.insert(reference_tokens.end(),
10128                                  ptr.reference_tokens.begin(),
10129                                  ptr.reference_tokens.end());
10130          return *this;
10131      }
10132      json_pointer&amp; operator/=(string_t token)
10133      {
10134          push_back(std::move(token));
10135          return *this;
10136      }
10137      json_pointer&amp; operator/=(std::size_t array_idx)
10138      {
10139          return *this /= std::to_string(array_idx);
10140      }
10141      friend json_pointer operator/(const json_pointer&amp; lhs,
10142                                    const json_pointer&amp; rhs)
10143      {
10144          return json_pointer(lhs) /= rhs;
10145      }
10146      friend json_pointer operator/(const json_pointer&amp; lhs, string_t token) 
10147      {
10148          return json_pointer(lhs) /= std::move(token);
10149      }
10150      friend json_pointer operator/(const json_pointer&amp; lhs, std::size_t array_idx)
10151      {
10152          return json_pointer(lhs) /= array_idx;
10153      }
10154      json_pointer parent_pointer() const
10155      {
10156          if (empty())
10157          {
10158              return *this;
10159          }
10160          json_pointer res = *this;
10161          res.pop_back();
10162          return res;
10163      }
10164      void pop_back()
10165      {
10166          if (JSON_HEDLEY_UNLIKELY(empty()))
10167          {
10168              JSON_THROW(detail::out_of_range::create(405, &quot;JSON pointer has no parent&quot;, nullptr));
10169          }
10170          reference_tokens.pop_back();
10171      }
10172      const string_t&amp; back() const
10173      {
10174          if (JSON_HEDLEY_UNLIKELY(empty()))
10175          {
10176              JSON_THROW(detail::out_of_range::create(405, &quot;JSON pointer has no parent&quot;, nullptr));
10177          }
10178          return reference_tokens.back();
10179      }
10180      void push_back(const string_t&amp; token)
10181      {
10182          reference_tokens.push_back(token);
10183      }
10184      void push_back(string_t&amp;&amp; token)
10185      {
10186          reference_tokens.push_back(std::move(token));
10187      }
10188      bool empty() const noexcept
10189      {
10190          return reference_tokens.empty();
10191      }
10192    private:
10193      template&lt;typename BasicJsonType&gt;
10194      static typename BasicJsonType::size_type array_index(const string_t&amp; s)
10195      {
10196          using size_type = typename BasicJsonType::size_type;
10197          if (JSON_HEDLEY_UNLIKELY(s.size() &gt; 1 &amp;&amp; s[0] == &#x27;0&#x27;))
10198          {
10199              JSON_THROW(detail::parse_error::create(106, 0, detail::concat(&quot;array index &#x27;&quot;, s, &quot;&#x27; must not begin with &#x27;0&#x27;&quot;), nullptr));
10200          }
10201          if (JSON_HEDLEY_UNLIKELY(s.size() &gt; 1 &amp;&amp; !(s[0] &gt;= &#x27;1&#x27; &amp;&amp; s[0] &lt;= &#x27;9&#x27;)))
10202          {
10203              JSON_THROW(detail::parse_error::create(109, 0, detail::concat(&quot;array index &#x27;&quot;, s, &quot;&#x27; is not a number&quot;), nullptr));
10204          }
10205          const char* p = s.c_str();
10206          char* p_end = nullptr;
10207          errno = 0; 
10208          unsigned long long res = std::strtoull(p, &amp;p_end, 10); 
10209          if (p == p_end 
10210                  || errno == ERANGE 
10211                  || JSON_HEDLEY_UNLIKELY(static_cast&lt;std::size_t&gt;(p_end - p) != s.size())) 
10212          {
10213              JSON_THROW(detail::out_of_range::create(404, detail::concat(&quot;unresolved reference token &#x27;&quot;, s, &quot;&#x27;&quot;), nullptr));
10214          }
10215          if (res &gt;= static_cast&lt;unsigned long long&gt;((std::numeric_limits&lt;size_type&gt;::max)()))  
10216          {
10217              JSON_THROW(detail::out_of_range::create(410, detail::concat(&quot;array index &quot;, s, &quot; exceeds size_type&quot;), nullptr));   
10218          }
10219          return static_cast&lt;size_type&gt;(res);
10220      }
10221    JSON_PRIVATE_UNLESS_TESTED:
10222      json_pointer top() const
10223      {
10224          if (JSON_HEDLEY_UNLIKELY(empty()))
10225          {
10226              JSON_THROW(detail::out_of_range::create(405, &quot;JSON pointer has no parent&quot;, nullptr));
10227          }
10228          json_pointer result = *this;
10229          result.reference_tokens = {reference_tokens[0]};
10230          return result;
10231      }
10232    private:
10233      template&lt;typename BasicJsonType&gt;
10234      BasicJsonType&amp; get_and_create(BasicJsonType&amp; j) const
10235      {
10236          auto* result = &amp;j;
10237          for (const auto&amp; reference_token : reference_tokens)
10238          {
10239              switch (result-&gt;type())
10240              {
10241                  case detail::value_t::null:
10242                  {
10243                      if (reference_token == &quot;0&quot;)
10244                      {
10245                          result = &amp;result-&gt;operator[](0);
10246                      }
10247                      else
10248                      {
10249                          result = &amp;result-&gt;operator[](reference_token);
10250                      }
10251                      break;
10252                  }
10253                  case detail::value_t::object:
10254                  {
10255                      result = &amp;result-&gt;operator[](reference_token);
10256                      break;
10257                  }
10258                  case detail::value_t::array:
10259                  {
10260                      result = &amp;result-&gt;operator[](array_index&lt;BasicJsonType&gt;(reference_token));
10261                      break;
10262                  }
10263                  case detail::value_t::string:
10264                  case detail::value_t::boolean:
10265                  case detail::value_t::number_integer:
10266                  case detail::value_t::number_unsigned:
10267                  case detail::value_t::number_float:
10268                  case detail::value_t::binary:
10269                  case detail::value_t::discarded:
10270                  default:
10271                      JSON_THROW(detail::type_error::create(313, &quot;invalid value to unflatten&quot;, &amp;j));
10272              }
10273          }
10274          return *result;
10275      }
10276      template&lt;typename BasicJsonType&gt;
10277      BasicJsonType&amp; get_unchecked(BasicJsonType* ptr) const
10278      {
10279          for (const auto&amp; reference_token : reference_tokens)
10280          {
10281              if (ptr-&gt;is_null())
10282              {
10283                  const bool nums =
10284                      std::all_of(reference_token.begin(), reference_token.end(),
10285                                  [](const unsigned char x)
10286                  {
10287                      return std::isdigit(x);
10288                  });
10289                  *ptr = (nums || reference_token == &quot;-&quot;)
10290                         ? detail::value_t::array
10291                         : detail::value_t::object;
10292              }
10293              switch (ptr-&gt;type())
10294              {
10295                  case detail::value_t::object:
10296                  {
10297                      ptr = &amp;ptr-&gt;operator[](reference_token);
10298                      break;
10299                  }
10300                  case detail::value_t::array:
10301                  {
10302                      if (reference_token == &quot;-&quot;)
10303                      {
10304                          ptr = &amp;ptr-&gt;operator[](ptr-&gt;m_value.array-&gt;size());
10305                      }
10306                      else
10307                      {
10308                          ptr = &amp;ptr-&gt;operator[](array_index&lt;BasicJsonType&gt;(reference_token));
10309                      }
10310                      break;
10311                  }
10312                  case detail::value_t::null:
10313                  case detail::value_t::string:
10314                  case detail::value_t::boolean:
10315                  case detail::value_t::number_integer:
10316                  case detail::value_t::number_unsigned:
10317                  case detail::value_t::number_float:
10318                  case detail::value_t::binary:
10319                  case detail::value_t::discarded:
10320                  default:
10321                      JSON_THROW(detail::out_of_range::create(404, detail::concat(&quot;unresolved reference token &#x27;&quot;, reference_token, &quot;&#x27;&quot;), ptr));
10322              }
10323          }
10324          return *ptr;
10325      }
10326      template&lt;typename BasicJsonType&gt;
10327      BasicJsonType&amp; get_checked(BasicJsonType* ptr) const
10328      {
10329          for (const auto&amp; reference_token : reference_tokens)
10330          {
10331              switch (ptr-&gt;type())
10332              {
10333                  case detail::value_t::object:
10334                  {
10335                      ptr = &amp;ptr-&gt;at(reference_token);
10336                      break;
10337                  }
10338                  case detail::value_t::array:
10339                  {
10340                      if (JSON_HEDLEY_UNLIKELY(reference_token == &quot;-&quot;))
10341                      {
10342                          JSON_THROW(detail::out_of_range::create(402, detail::concat(
10343                                  &quot;array index &#x27;-&#x27; (&quot;, std::to_string(ptr-&gt;m_value.array-&gt;size()),
10344                                  &quot;) is out of range&quot;), ptr));
10345                      }
10346                      ptr = &amp;ptr-&gt;at(array_index&lt;BasicJsonType&gt;(reference_token));
10347                      break;
10348                  }
10349                  case detail::value_t::null:
10350                  case detail::value_t::string:
10351                  case detail::value_t::boolean:
10352                  case detail::value_t::number_integer:
10353                  case detail::value_t::number_unsigned:
10354                  case detail::value_t::number_float:
10355                  case detail::value_t::binary:
10356                  case detail::value_t::discarded:
10357                  default:
10358                      JSON_THROW(detail::out_of_range::create(404, detail::concat(&quot;unresolved reference token &#x27;&quot;, reference_token, &quot;&#x27;&quot;), ptr));
10359              }
10360          }
10361          return *ptr;
10362      }
10363      template&lt;typename BasicJsonType&gt;
10364      const BasicJsonType&amp; get_unchecked(const BasicJsonType* ptr) const
10365      {
10366          for (const auto&amp; reference_token : reference_tokens)
10367          {
10368              switch (ptr-&gt;type())
10369              {
10370                  case detail::value_t::object:
10371                  {
10372                      ptr = &amp;ptr-&gt;operator[](reference_token);
10373                      break;
10374                  }
10375                  case detail::value_t::array:
10376                  {
10377                      if (JSON_HEDLEY_UNLIKELY(reference_token == &quot;-&quot;))
10378                      {
10379                          JSON_THROW(detail::out_of_range::create(402, detail::concat(&quot;array index &#x27;-&#x27; (&quot;, std::to_string(ptr-&gt;m_value.array-&gt;size()), &quot;) is out of range&quot;), ptr));
10380                      }
10381                      ptr = &amp;ptr-&gt;operator[](array_index&lt;BasicJsonType&gt;(reference_token));
10382                      break;
10383                  }
10384                  case detail::value_t::null:
10385                  case detail::value_t::string:
10386                  case detail::value_t::boolean:
10387                  case detail::value_t::number_integer:
10388                  case detail::value_t::number_unsigned:
10389                  case detail::value_t::number_float:
10390                  case detail::value_t::binary:
10391                  case detail::value_t::discarded:
10392                  default:
10393                      JSON_THROW(detail::out_of_range::create(404, detail::concat(&quot;unresolved reference token &#x27;&quot;, reference_token, &quot;&#x27;&quot;), ptr));
10394              }
10395          }
10396          return *ptr;
10397      }
10398      template&lt;typename BasicJsonType&gt;
10399      const BasicJsonType&amp; get_checked(const BasicJsonType* ptr) const
10400      {
10401          for (const auto&amp; reference_token : reference_tokens)
10402          {
10403              switch (ptr-&gt;type())
10404              {
10405                  case detail::value_t::object:
10406                  {
10407                      ptr = &amp;ptr-&gt;at(reference_token);
10408                      break;
10409                  }
10410                  case detail::value_t::array:
10411                  {
10412                      if (JSON_HEDLEY_UNLIKELY(reference_token == &quot;-&quot;))
10413                      {
10414                          JSON_THROW(detail::out_of_range::create(402, detail::concat(
10415                                  &quot;array index &#x27;-&#x27; (&quot;, std::to_string(ptr-&gt;m_value.array-&gt;size()),
10416                                  &quot;) is out of range&quot;), ptr));
10417                      }
10418                      ptr = &amp;ptr-&gt;at(array_index&lt;BasicJsonType&gt;(reference_token));
10419                      break;
10420                  }
10421                  case detail::value_t::null:
10422                  case detail::value_t::string:
10423                  case detail::value_t::boolean:
10424                  case detail::value_t::number_integer:
10425                  case detail::value_t::number_unsigned:
10426                  case detail::value_t::number_float:
10427                  case detail::value_t::binary:
10428                  case detail::value_t::discarded:
10429                  default:
10430                      JSON_THROW(detail::out_of_range::create(404, detail::concat(&quot;unresolved reference token &#x27;&quot;, reference_token, &quot;&#x27;&quot;), ptr));
10431              }
10432          }
10433          return *ptr;
10434      }
10435      template&lt;typename BasicJsonType&gt;
10436      bool contains(const BasicJsonType* ptr) const
10437      {
10438          for (const auto&amp; reference_token : reference_tokens)
10439          {
10440              switch (ptr-&gt;type())
10441              {
10442                  case detail::value_t::object:
10443                  {
10444                      if (!ptr-&gt;contains(reference_token))
10445                      {
10446                          return false;
10447                      }
10448                      ptr = &amp;ptr-&gt;operator[](reference_token);
10449                      break;
10450                  }
10451                  case detail::value_t::array:
10452                  {
10453                      if (JSON_HEDLEY_UNLIKELY(reference_token == &quot;-&quot;))
10454                      {
10455                          return false;
10456                      }
10457                      if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 &amp;&amp; !(&quot;0&quot; &lt;= reference_token &amp;&amp; reference_token &lt;= &quot;9&quot;)))
10458                      {
10459                          return false;
10460                      }
10461                      if (JSON_HEDLEY_UNLIKELY(reference_token.size() &gt; 1))
10462                      {
10463                          if (JSON_HEDLEY_UNLIKELY(!(&#x27;1&#x27; &lt;= reference_token[0] &amp;&amp; reference_token[0] &lt;= &#x27;9&#x27;)))
10464                          {
10465                              return false;
10466                          }
10467                          for (std::size_t i = 1; i &lt; reference_token.size(); i++)
10468                          {
10469                              if (JSON_HEDLEY_UNLIKELY(!(&#x27;0&#x27; &lt;= reference_token[i] &amp;&amp; reference_token[i] &lt;= &#x27;9&#x27;)))
10470                              {
10471                                  return false;
10472                              }
10473                          }
10474                      }
10475                      const auto idx = array_index&lt;BasicJsonType&gt;(reference_token);
10476                      if (idx &gt;= ptr-&gt;size())
10477                      {
10478                          return false;
10479                      }
10480                      ptr = &amp;ptr-&gt;operator[](idx);
10481                      break;
10482                  }
10483                  case detail::value_t::null:
10484                  case detail::value_t::string:
10485                  case detail::value_t::boolean:
10486                  case detail::value_t::number_integer:
10487                  case detail::value_t::number_unsigned:
10488                  case detail::value_t::number_float:
10489                  case detail::value_t::binary:
10490                  case detail::value_t::discarded:
10491                  default:
10492                  {
10493                      return false;
10494                  }
10495              }
10496          }
10497          return true;
10498      }
10499      static std::vector&lt;string_t&gt; split(const string_t&amp; reference_string)
10500      {
10501          std::vector&lt;string_t&gt; result;
10502          if (reference_string.empty())
10503          {
10504              return result;
10505          }
10506          if (JSON_HEDLEY_UNLIKELY(reference_string[0] != &#x27;/&#x27;))
10507          {
10508              JSON_THROW(detail::parse_error::create(107, 1, detail::concat(&quot;JSON pointer must be empty or begin with &#x27;/&#x27; - was: &#x27;&quot;, reference_string, &quot;&#x27;&quot;), nullptr));
10509          }
10510          for (
10511              std::size_t slash = reference_string.find_first_of(&#x27;/&#x27;, 1),
10512              start = 1;
10513              start != 0;
10514              start = (slash == string_t::npos) ? 0 : slash + 1,
10515              slash = reference_string.find_first_of(&#x27;/&#x27;, start))
10516          {
10517              auto reference_token = reference_string.substr(start, slash - start);
10518              for (std::size_t pos = reference_token.find_first_of(&#x27;~&#x27;);
10519                      pos != string_t::npos;
10520                      pos = reference_token.find_first_of(&#x27;~&#x27;, pos + 1))
10521              {
10522                  JSON_ASSERT(reference_token[pos] == &#x27;~&#x27;);
10523                  if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
10524                                           (reference_token[pos + 1] != &#x27;0&#x27; &amp;&amp;
10525                                            reference_token[pos + 1] != &#x27;1&#x27;)))
10526                  {
10527                      JSON_THROW(detail::parse_error::create(108, 0, &quot;escape character &#x27;~&#x27; must be followed with &#x27;0&#x27; or &#x27;1&#x27;&quot;, nullptr));
10528                  }
10529              }
10530              detail::unescape(reference_token);
10531              result.push_back(reference_token);
10532          }
10533          return result;
10534      }
10535    private:
10536      template&lt;typename BasicJsonType&gt;
10537      static void flatten(const string_t&amp; reference_string,
10538                          const BasicJsonType&amp; value,
10539                          BasicJsonType&amp; result)
10540      {
10541          switch (value.type())
10542          {
10543              case detail::value_t::array:
10544              {
10545                  if (value.m_value.array-&gt;empty())
10546                  {
10547                      result[reference_string] = nullptr;
10548                  }
10549                  else
10550                  {
10551                      for (std::size_t i = 0; i &lt; value.m_value.array-&gt;size(); ++i)
10552                      {
10553                          flatten(detail::concat(reference_string, &#x27;/&#x27;, std::to_string(i)),
10554                                  value.m_value.array-&gt;operator[](i), result);
10555                      }
10556                  }
10557                  break;
10558              }
10559              case detail::value_t::object:
10560              {
10561                  if (value.m_value.object-&gt;empty())
10562                  {
10563                      result[reference_string] = nullptr;
10564                  }
10565                  else
10566                  {
10567                      for (const auto&amp; element : *value.m_value.object)
10568                      {
10569                          flatten(detail::concat(reference_string, &#x27;/&#x27;, detail::escape(element.first)), element.second, result);
10570                      }
10571                  }
10572                  break;
10573              }
10574              case detail::value_t::null:
10575              case detail::value_t::string:
10576              case detail::value_t::boolean:
10577              case detail::value_t::number_integer:
10578              case detail::value_t::number_unsigned:
10579              case detail::value_t::number_float:
10580              case detail::value_t::binary:
10581              case detail::value_t::discarded:
10582              default:
10583              {
10584                  result[reference_string] = value;
10585                  break;
10586              }
10587          }
10588      }
10589      template&lt;typename BasicJsonType&gt;
10590      static BasicJsonType
10591      unflatten(const BasicJsonType&amp; value)
10592      {
10593          if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
10594          {
10595              JSON_THROW(detail::type_error::create(314, &quot;only objects can be unflattened&quot;, &amp;value));
10596          }
10597          BasicJsonType result;
10598          for (const auto&amp; element : *value.m_value.object)
10599          {
10600              if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
10601              {
10602                  JSON_THROW(detail::type_error::create(315, &quot;values in object must be primitive&quot;, &amp;element.second));
10603              }
10604              json_pointer(element.first).get_and_create(result) = element.second;
10605          }
10606          return result;
10607      }
10608      json_pointer&lt;string_t&gt; convert() const&amp;
10609      {
10610          json_pointer&lt;string_t&gt; result;
10611          result.reference_tokens = reference_tokens;
10612          return result;
10613      }
10614      json_pointer&lt;string_t&gt; convert()&amp;&amp;
10615      {
10616          json_pointer&lt;string_t&gt; result;
10617          result.reference_tokens = std::move(reference_tokens);
10618          return result;
10619      }
10620    public:
10621  #if JSON_HAS_THREE_WAY_COMPARISON
10622      template&lt;typename RefStringTypeRhs&gt;
10623      bool operator==(const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) const noexcept
10624      {
10625          return reference_tokens == rhs.reference_tokens;
10626      }
10627      JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer))
10628      bool operator==(const string_t&amp; rhs) const
10629      {
10630          return *this == json_pointer(rhs);
10631      }
10632      template&lt;typename RefStringTypeRhs&gt;
10633      std::strong_ordering operator&lt;=&gt;(const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) const noexcept 
10634      {
10635          return  reference_tokens &lt;=&gt; rhs.reference_tokens; 
10636      }
10637  #else
10638      template&lt;typename RefStringTypeLhs, typename RefStringTypeRhs&gt;
10639      friend bool operator==(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10640                             const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) noexcept;
10641      template&lt;typename RefStringTypeLhs, typename StringType&gt;
10642      friend bool operator==(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10643                             const StringType&amp; rhs);
10644      template&lt;typename RefStringTypeRhs, typename StringType&gt;
10645      friend bool operator==(const StringType&amp; lhs,
10646                             const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs);
10647      template&lt;typename RefStringTypeLhs, typename RefStringTypeRhs&gt;
10648      friend bool operator!=(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10649                             const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) noexcept;
10650      template&lt;typename RefStringTypeLhs, typename StringType&gt;
10651      friend bool operator!=(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10652                             const StringType&amp; rhs);
10653      template&lt;typename RefStringTypeRhs, typename StringType&gt;
10654      friend bool operator!=(const StringType&amp; lhs,
10655                             const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs);
10656      template&lt;typename RefStringTypeLhs, typename RefStringTypeRhs&gt;
10657      friend bool operator&lt;(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10658                            const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) noexcept;
10659  #endif
10660    private:
10661      std::vector&lt;string_t&gt; reference_tokens;
10662  };
10663  #if !JSON_HAS_THREE_WAY_COMPARISON
10664  template&lt;typename RefStringTypeLhs, typename RefStringTypeRhs&gt;
10665  inline bool operator==(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10666                         const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) noexcept
10667  {
10668      return lhs.reference_tokens == rhs.reference_tokens;
10669  }
10670  template&lt;typename RefStringTypeLhs,
10671           typename StringType = typename json_pointer&lt;RefStringTypeLhs&gt;::string_t&gt;
10672  JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
10673  inline bool operator==(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10674                         const StringType&amp; rhs)
10675  {
10676      return lhs == json_pointer&lt;RefStringTypeLhs&gt;(rhs);
10677  }
10678  template&lt;typename RefStringTypeRhs,
10679           typename StringType = typename json_pointer&lt;RefStringTypeRhs&gt;::string_t&gt;
10680  JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
10681  inline bool operator==(const StringType&amp; lhs,
10682                         const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs)
10683  {
10684      return json_pointer&lt;RefStringTypeRhs&gt;(lhs) == rhs;
10685  }
10686  template&lt;typename RefStringTypeLhs, typename RefStringTypeRhs&gt;
10687  inline bool operator!=(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10688                         const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) noexcept
10689  {
10690      return !(lhs == rhs);
10691  }
10692  template&lt;typename RefStringTypeLhs,
10693           typename StringType = typename json_pointer&lt;RefStringTypeLhs&gt;::string_t&gt;
10694  JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
10695  inline bool operator!=(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10696                         const StringType&amp; rhs)
10697  {
10698      return !(lhs == rhs);
10699  }
10700  template&lt;typename RefStringTypeRhs,
10701           typename StringType = typename json_pointer&lt;RefStringTypeRhs&gt;::string_t&gt;
10702  JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
10703  inline bool operator!=(const StringType&amp; lhs,
10704                         const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs)
10705  {
10706      return !(lhs == rhs);
10707  }
10708  template&lt;typename RefStringTypeLhs, typename RefStringTypeRhs&gt;
10709  inline bool operator&lt;(const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,
10710                        const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) noexcept
10711  {
10712      return lhs.reference_tokens &lt; rhs.reference_tokens;
10713  }
10714  #endif
10715  NLOHMANN_JSON_NAMESPACE_END
10716  #include &lt;initializer_list&gt;
10717  #include &lt;utility&gt;
10718  NLOHMANN_JSON_NAMESPACE_BEGIN
10719  namespace detail
10720  {
10721  template&lt;typename BasicJsonType&gt;
10722  class json_ref
10723  {
10724    public:
10725      using value_type = BasicJsonType;
10726      json_ref(value_type&amp;&amp; value)
10727          : owned_value(std::move(value))
10728      {}
10729      json_ref(const value_type&amp; value)
10730          : value_ref(&amp;value)
10731      {}
10732      json_ref(std::initializer_list&lt;json_ref&gt; init)
10733          : owned_value(init)
10734      {}
10735      template &lt;
10736          class... Args,
10737          enable_if_t&lt;std::is_constructible&lt;value_type, Args...&gt;::value, int&gt; = 0 &gt;
10738      json_ref(Args &amp;&amp; ... args)
10739          : owned_value(std::forward&lt;Args&gt;(args)...)
10740      {}
10741      json_ref(json_ref&amp;&amp;) noexcept = default;
10742      json_ref(const json_ref&amp;) = delete;
10743      json_ref&amp; operator=(const json_ref&amp;) = delete;
10744      json_ref&amp; operator=(json_ref&amp;&amp;) = delete;
10745      ~json_ref() = default;
10746      value_type moved_or_copied() const
10747      {
10748          if (value_ref == nullptr)
10749          {
10750              return std::move(owned_value);
10751          }
10752          return *value_ref;
10753      }
10754      value_type const&amp; operator*() const
10755      {
10756          return value_ref ? *value_ref : owned_value;
10757      }
10758      value_type const* operator-&gt;() const
10759      {
10760          return &amp;** this;
10761      }
10762    private:
10763      mutable value_type owned_value = nullptr;
10764      value_type const* value_ref = nullptr;
10765  };
10766  }  
10767  NLOHMANN_JSON_NAMESPACE_END
10768  #include &lt;algorithm&gt; 
10769  #include &lt;array&gt; 
10770  #include &lt;map&gt; 
10771  #include &lt;cmath&gt; 
10772  #include &lt;cstdint&gt; 
10773  #include &lt;cstring&gt; 
10774  #include &lt;limits&gt; 
10775  #include &lt;string&gt; 
10776  #include &lt;utility&gt; 
10777  #include &lt;vector&gt; 
10778  #include &lt;algorithm&gt; 
10779  #include &lt;cstddef&gt; 
10780  #include &lt;iterator&gt; 
10781  #include &lt;memory&gt; 
10782  #include &lt;string&gt; 
10783  #include &lt;vector&gt; 
10784  #ifndef JSON_NO_IO
10785      #include &lt;ios&gt;      
10786      #include &lt;ostream&gt;  
10787  #endif  
10788  NLOHMANN_JSON_NAMESPACE_BEGIN
10789  namespace detail
10790  {
10791  template&lt;typename CharType&gt; struct output_adapter_protocol
10792  {
10793      virtual void write_character(CharType c) = 0;
10794      virtual void write_characters(const CharType* s, std::size_t length) = 0;
10795      virtual ~output_adapter_protocol() = default;
10796      output_adapter_protocol() = default;
10797      output_adapter_protocol(const output_adapter_protocol&amp;) = default;
10798      output_adapter_protocol(output_adapter_protocol&amp;&amp;) noexcept = default;
10799      output_adapter_protocol&amp; operator=(const output_adapter_protocol&amp;) = default;
10800      output_adapter_protocol&amp; operator=(output_adapter_protocol&amp;&amp;) noexcept = default;
10801  };
10802  template&lt;typename CharType&gt;
10803  using output_adapter_t = std::shared_ptr&lt;output_adapter_protocol&lt;CharType&gt;&gt;;
10804  template&lt;typename CharType, typename AllocatorType = std::allocator&lt;CharType&gt;&gt;
10805  class output_vector_adapter : public output_adapter_protocol&lt;CharType&gt;
10806  {
10807    public:
10808      explicit output_vector_adapter(std::vector&lt;CharType, AllocatorType&gt;&amp; vec) noexcept
10809          : v(vec)
10810      {}
10811      void write_character(CharType c) override
10812      {
10813          v.push_back(c);
10814      }
10815      JSON_HEDLEY_NON_NULL(2)
10816      void write_characters(const CharType* s, std::size_t length) override
10817      {
10818          v.insert(v.end(), s, s + length);
10819      }
10820    private:
10821      std::vector&lt;CharType, AllocatorType&gt;&amp; v;
10822  };
10823  #ifndef JSON_NO_IO
10824  template&lt;typename CharType&gt;
10825  class output_stream_adapter : public output_adapter_protocol&lt;CharType&gt;
10826  {
10827    public:
10828      explicit output_stream_adapter(std::basic_ostream&lt;CharType&gt;&amp; s) noexcept
10829          : stream(s)
10830      {}
10831      void write_character(CharType c) override
10832      {
10833          stream.put(c);
10834      }
10835      JSON_HEDLEY_NON_NULL(2)
10836      void write_characters(const CharType* s, std::size_t length) override
10837      {
10838          stream.write(s, static_cast&lt;std::streamsize&gt;(length));
10839      }
10840    private:
10841      std::basic_ostream&lt;CharType&gt;&amp; stream;
10842  };
10843  #endif  
10844  template&lt;typename CharType, typename StringType = std::basic_string&lt;CharType&gt;&gt;
10845  class output_string_adapter : public output_adapter_protocol&lt;CharType&gt;
10846  {
10847    public:
10848      explicit output_string_adapter(StringType&amp; s) noexcept
10849          : str(s)
10850      {}
10851      void write_character(CharType c) override
10852      {
10853          str.push_back(c);
10854      }
10855      JSON_HEDLEY_NON_NULL(2)
10856      void write_characters(const CharType* s, std::size_t length) override
10857      {
10858          str.append(s, length);
10859      }
10860    private:
10861      StringType&amp; str;
10862  };
10863  template&lt;typename CharType, typename StringType = std::basic_string&lt;CharType&gt;&gt;
10864  class output_adapter
10865  {
10866    public:
10867      template&lt;typename AllocatorType = std::allocator&lt;CharType&gt;&gt;
10868      output_adapter(std::vector&lt;CharType, AllocatorType&gt;&amp; vec)
10869          : oa(std::make_shared&lt;output_vector_adapter&lt;CharType, AllocatorType&gt;&gt;(vec)) {}
10870  #ifndef JSON_NO_IO
10871      output_adapter(std::basic_ostream&lt;CharType&gt;&amp; s)
10872          : oa(std::make_shared&lt;output_stream_adapter&lt;CharType&gt;&gt;(s)) {}
10873  #endif  
10874      output_adapter(StringType&amp; s)
10875          : oa(std::make_shared&lt;output_string_adapter&lt;CharType, StringType&gt;&gt;(s)) {}
10876      operator output_adapter_t&lt;CharType&gt;()
10877      {
10878          return oa;
10879      }
10880    private:
10881      output_adapter_t&lt;CharType&gt; oa = nullptr;
10882  };
10883  }  
10884  NLOHMANN_JSON_NAMESPACE_END
10885  NLOHMANN_JSON_NAMESPACE_BEGIN
10886  namespace detail
10887  {
10888  template&lt;typename BasicJsonType, typename CharType&gt;
10889  class binary_writer
10890  {
10891      using string_t = typename BasicJsonType::string_t;
10892      using binary_t = typename BasicJsonType::binary_t;
10893      using number_float_t = typename BasicJsonType::number_float_t;
10894    public:
10895      explicit binary_writer(output_adapter_t&lt;CharType&gt; adapter) : oa(std::move(adapter))
10896      {
10897          JSON_ASSERT(oa);
10898      }
10899      void write_bson(const BasicJsonType&amp; j)
10900      {
10901          switch (j.type())
10902          {
10903              case value_t::object:
10904              {
10905                  write_bson_object(*j.m_value.object);
10906                  break;
10907              }
10908              case value_t::null:
10909              case value_t::array:
10910              case value_t::string:
10911              case value_t::boolean:
10912              case value_t::number_integer:
10913              case value_t::number_unsigned:
10914              case value_t::number_float:
10915              case value_t::binary:
10916              case value_t::discarded:
10917              default:
10918              {
10919                  JSON_THROW(type_error::create(317, concat(&quot;to serialize to BSON, top-level type must be object, but is &quot;, j.type_name()), &amp;j));
10920              }
10921          }
10922      }
10923      void write_cbor(const BasicJsonType&amp; j)
10924      {
10925          switch (j.type())
10926          {
10927              case value_t::null:
10928              {
10929                  oa-&gt;write_character(to_char_type(0xF6));
10930                  break;
10931              }
10932              case value_t::boolean:
10933              {
10934                  oa-&gt;write_character(j.m_value.boolean
10935                                      ? to_char_type(0xF5)
10936                                      : to_char_type(0xF4));
10937                  break;
10938              }
10939              case value_t::number_integer:
10940              {
10941                  if (j.m_value.number_integer &gt;= 0)
10942                  {
10943                      if (j.m_value.number_integer &lt;= 0x17)
10944                      {
10945                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
10946                      }
10947                      else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10948                      {
10949                          oa-&gt;write_character(to_char_type(0x18));
10950                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
10951                      }
10952                      else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10953                      {
10954                          oa-&gt;write_character(to_char_type(0x19));
10955                          write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.number_integer));
10956                      }
10957                      else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10958                      {
10959                          oa-&gt;write_character(to_char_type(0x1A));
10960                          write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.number_integer));
10961                      }
10962                      else
10963                      {
10964                          oa-&gt;write_character(to_char_type(0x1B));
10965                          write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.number_integer));
10966                      }
10967                  }
10968                  else
10969                  {
10970                      const auto positive_number = -1 - j.m_value.number_integer;
10971                      if (j.m_value.number_integer &gt;= -24)
10972                      {
10973                          write_number(static_cast&lt;std::uint8_t&gt;(0x20 + positive_number));
10974                      }
10975                      else if (positive_number &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
10976                      {
10977                          oa-&gt;write_character(to_char_type(0x38));
10978                          write_number(static_cast&lt;std::uint8_t&gt;(positive_number));
10979                      }
10980                      else if (positive_number &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
10981                      {
10982                          oa-&gt;write_character(to_char_type(0x39));
10983                          write_number(static_cast&lt;std::uint16_t&gt;(positive_number));
10984                      }
10985                      else if (positive_number &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
10986                      {
10987                          oa-&gt;write_character(to_char_type(0x3A));
10988                          write_number(static_cast&lt;std::uint32_t&gt;(positive_number));
10989                      }
10990                      else
10991                      {
10992                          oa-&gt;write_character(to_char_type(0x3B));
10993                          write_number(static_cast&lt;std::uint64_t&gt;(positive_number));
10994                      }
10995                  }
10996                  break;
10997              }
10998              case value_t::number_unsigned:
10999              {
11000                  if (j.m_value.number_unsigned &lt;= 0x17)
11001                  {
11002                      write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_unsigned));
11003                  }
11004                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11005                  {
11006                      oa-&gt;write_character(to_char_type(0x18));
11007                      write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_unsigned));
11008                  }
11009                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11010                  {
11011                      oa-&gt;write_character(to_char_type(0x19));
11012                      write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.number_unsigned));
11013                  }
11014                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11015                  {
11016                      oa-&gt;write_character(to_char_type(0x1A));
11017                      write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.number_unsigned));
11018                  }
11019                  else
11020                  {
11021                      oa-&gt;write_character(to_char_type(0x1B));
11022                      write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.number_unsigned));
11023                  }
11024                  break;
11025              }
11026              case value_t::number_float:
11027              {
11028                  if (std::isnan(j.m_value.number_float))
11029                  {
11030                      oa-&gt;write_character(to_char_type(0xF9));
11031                      oa-&gt;write_character(to_char_type(0x7E));
11032                      oa-&gt;write_character(to_char_type(0x00));
11033                  }
11034                  else if (std::isinf(j.m_value.number_float))
11035                  {
11036                      oa-&gt;write_character(to_char_type(0xf9));
11037                      oa-&gt;write_character(j.m_value.number_float &gt; 0 ? to_char_type(0x7C) : to_char_type(0xFC));
11038                      oa-&gt;write_character(to_char_type(0x00));
11039                  }
11040                  else
11041                  {
11042                      write_compact_float(j.m_value.number_float, detail::input_format_t::cbor);
11043                  }
11044                  break;
11045              }
11046              case value_t::string:
11047              {
11048                  const auto N = j.m_value.string-&gt;size();
11049                  if (N &lt;= 0x17)
11050                  {
11051                      write_number(static_cast&lt;std::uint8_t&gt;(0x60 + N));
11052                  }
11053                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11054                  {
11055                      oa-&gt;write_character(to_char_type(0x78));
11056                      write_number(static_cast&lt;std::uint8_t&gt;(N));
11057                  }
11058                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11059                  {
11060                      oa-&gt;write_character(to_char_type(0x79));
11061                      write_number(static_cast&lt;std::uint16_t&gt;(N));
11062                  }
11063                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11064                  {
11065                      oa-&gt;write_character(to_char_type(0x7A));
11066                      write_number(static_cast&lt;std::uint32_t&gt;(N));
11067                  }
11068                  else if (N &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
11069                  {
11070                      oa-&gt;write_character(to_char_type(0x7B));
11071                      write_number(static_cast&lt;std::uint64_t&gt;(N));
11072                  }
11073                  oa-&gt;write_characters(
11074                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
11075                      j.m_value.string-&gt;size());
11076                  break;
11077              }
11078              case value_t::array:
11079              {
11080                  const auto N = j.m_value.array-&gt;size();
11081                  if (N &lt;= 0x17)
11082                  {
11083                      write_number(static_cast&lt;std::uint8_t&gt;(0x80 + N));
11084                  }
11085                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11086                  {
11087                      oa-&gt;write_character(to_char_type(0x98));
11088                      write_number(static_cast&lt;std::uint8_t&gt;(N));
11089                  }
11090                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11091                  {
11092                      oa-&gt;write_character(to_char_type(0x99));
11093                      write_number(static_cast&lt;std::uint16_t&gt;(N));
11094                  }
11095                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11096                  {
11097                      oa-&gt;write_character(to_char_type(0x9A));
11098                      write_number(static_cast&lt;std::uint32_t&gt;(N));
11099                  }
11100                  else if (N &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
11101                  {
11102                      oa-&gt;write_character(to_char_type(0x9B));
11103                      write_number(static_cast&lt;std::uint64_t&gt;(N));
11104                  }
11105                  for (const auto&amp; el : *j.m_value.array)
11106                  {
11107                      write_cbor(el);
11108                  }
11109                  break;
11110              }
11111              case value_t::binary:
11112              {
11113                  if (j.m_value.binary-&gt;has_subtype())
11114                  {
11115                      if (j.m_value.binary-&gt;subtype() &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11116                      {
11117                          write_number(static_cast&lt;std::uint8_t&gt;(0xd8));
11118                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.binary-&gt;subtype()));
11119                      }
11120                      else if (j.m_value.binary-&gt;subtype() &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11121                      {
11122                          write_number(static_cast&lt;std::uint8_t&gt;(0xd9));
11123                          write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.binary-&gt;subtype()));
11124                      }
11125                      else if (j.m_value.binary-&gt;subtype() &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11126                      {
11127                          write_number(static_cast&lt;std::uint8_t&gt;(0xda));
11128                          write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.binary-&gt;subtype()));
11129                      }
11130                      else if (j.m_value.binary-&gt;subtype() &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
11131                      {
11132                          write_number(static_cast&lt;std::uint8_t&gt;(0xdb));
11133                          write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.binary-&gt;subtype()));
11134                      }
11135                  }
11136                  const auto N = j.m_value.binary-&gt;size();
11137                  if (N &lt;= 0x17)
11138                  {
11139                      write_number(static_cast&lt;std::uint8_t&gt;(0x40 + N));
11140                  }
11141                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11142                  {
11143                      oa-&gt;write_character(to_char_type(0x58));
11144                      write_number(static_cast&lt;std::uint8_t&gt;(N));
11145                  }
11146                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11147                  {
11148                      oa-&gt;write_character(to_char_type(0x59));
11149                      write_number(static_cast&lt;std::uint16_t&gt;(N));
11150                  }
11151                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11152                  {
11153                      oa-&gt;write_character(to_char_type(0x5A));
11154                      write_number(static_cast&lt;std::uint32_t&gt;(N));
11155                  }
11156                  else if (N &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
11157                  {
11158                      oa-&gt;write_character(to_char_type(0x5B));
11159                      write_number(static_cast&lt;std::uint64_t&gt;(N));
11160                  }
11161                  oa-&gt;write_characters(
11162                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.binary-&gt;data()),
11163                      N);
11164                  break;
11165              }
11166              case value_t::object:
11167              {
11168                  const auto N = j.m_value.object-&gt;size();
11169                  if (N &lt;= 0x17)
11170                  {
11171                      write_number(static_cast&lt;std::uint8_t&gt;(0xA0 + N));
11172                  }
11173                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11174                  {
11175                      oa-&gt;write_character(to_char_type(0xB8));
11176                      write_number(static_cast&lt;std::uint8_t&gt;(N));
11177                  }
11178                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11179                  {
11180                      oa-&gt;write_character(to_char_type(0xB9));
11181                      write_number(static_cast&lt;std::uint16_t&gt;(N));
11182                  }
11183                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11184                  {
11185                      oa-&gt;write_character(to_char_type(0xBA));
11186                      write_number(static_cast&lt;std::uint32_t&gt;(N));
11187                  }
11188                  else if (N &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
11189                  {
11190                      oa-&gt;write_character(to_char_type(0xBB));
11191                      write_number(static_cast&lt;std::uint64_t&gt;(N));
11192                  }
11193                  for (const auto&amp; el : *j.m_value.object)
11194                  {
11195                      write_cbor(el.first);
11196                      write_cbor(el.second);
11197                  }
11198                  break;
11199              }
11200              case value_t::discarded:
11201              default:
11202                  break;
11203          }
11204      }
11205      void write_msgpack(const BasicJsonType&amp; j)
11206      {
11207          switch (j.type())
11208          {
11209              case value_t::null: 
11210              {
11211                  oa-&gt;write_character(to_char_type(0xC0));
11212                  break;
11213              }
11214              case value_t::boolean: 
11215              {
11216                  oa-&gt;write_character(j.m_value.boolean
11217                                      ? to_char_type(0xC3)
11218                                      : to_char_type(0xC2));
11219                  break;
11220              }
11221              case value_t::number_integer:
11222              {
11223                  if (j.m_value.number_integer &gt;= 0)
11224                  {
11225                      if (j.m_value.number_unsigned &lt; 128)
11226                      {
11227                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
11228                      }
11229                      else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11230                      {
11231                          oa-&gt;write_character(to_char_type(0xCC));
11232                          write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
11233                      }
11234                      else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11235                      {
11236                          oa-&gt;write_character(to_char_type(0xCD));
11237                          write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.number_integer));
11238                      }
11239                      else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11240                      {
11241                          oa-&gt;write_character(to_char_type(0xCE));
11242                          write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.number_integer));
11243                      }
11244                      else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
11245                      {
11246                          oa-&gt;write_character(to_char_type(0xCF));
11247                          write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.number_integer));
11248                      }
11249                  }
11250                  else
11251                  {
11252                      if (j.m_value.number_integer &gt;= -32)
11253                      {
11254                          write_number(static_cast&lt;std::int8_t&gt;(j.m_value.number_integer));
11255                      }
11256                      else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;std::int8_t&gt;::min)() &amp;&amp;
11257                               j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int8_t&gt;::max)())
11258                      {
11259                          oa-&gt;write_character(to_char_type(0xD0));
11260                          write_number(static_cast&lt;std::int8_t&gt;(j.m_value.number_integer));
11261                      }
11262                      else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;std::int16_t&gt;::min)() &amp;&amp;
11263                               j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int16_t&gt;::max)())
11264                      {
11265                          oa-&gt;write_character(to_char_type(0xD1));
11266                          write_number(static_cast&lt;std::int16_t&gt;(j.m_value.number_integer));
11267                      }
11268                      else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;std::int32_t&gt;::min)() &amp;&amp;
11269                               j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)())
11270                      {
11271                          oa-&gt;write_character(to_char_type(0xD2));
11272                          write_number(static_cast&lt;std::int32_t&gt;(j.m_value.number_integer));
11273                      }
11274                      else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;std::int64_t&gt;::min)() &amp;&amp;
11275                               j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int64_t&gt;::max)())
11276                      {
11277                          oa-&gt;write_character(to_char_type(0xD3));
11278                          write_number(static_cast&lt;std::int64_t&gt;(j.m_value.number_integer));
11279                      }
11280                  }
11281                  break;
11282              }
11283              case value_t::number_unsigned:
11284              {
11285                  if (j.m_value.number_unsigned &lt; 128)
11286                  {
11287                      write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
11288                  }
11289                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11290                  {
11291                      oa-&gt;write_character(to_char_type(0xCC));
11292                      write_number(static_cast&lt;std::uint8_t&gt;(j.m_value.number_integer));
11293                  }
11294                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11295                  {
11296                      oa-&gt;write_character(to_char_type(0xCD));
11297                      write_number(static_cast&lt;std::uint16_t&gt;(j.m_value.number_integer));
11298                  }
11299                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11300                  {
11301                      oa-&gt;write_character(to_char_type(0xCE));
11302                      write_number(static_cast&lt;std::uint32_t&gt;(j.m_value.number_integer));
11303                  }
11304                  else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
11305                  {
11306                      oa-&gt;write_character(to_char_type(0xCF));
11307                      write_number(static_cast&lt;std::uint64_t&gt;(j.m_value.number_integer));
11308                  }
11309                  break;
11310              }
11311              case value_t::number_float:
11312              {
11313                  write_compact_float(j.m_value.number_float, detail::input_format_t::msgpack);
11314                  break;
11315              }
11316              case value_t::string:
11317              {
11318                  const auto N = j.m_value.string-&gt;size();
11319                  if (N &lt;= 31)
11320                  {
11321                      write_number(static_cast&lt;std::uint8_t&gt;(0xA0 | N));
11322                  }
11323                  else if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11324                  {
11325                      oa-&gt;write_character(to_char_type(0xD9));
11326                      write_number(static_cast&lt;std::uint8_t&gt;(N));
11327                  }
11328                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11329                  {
11330                      oa-&gt;write_character(to_char_type(0xDA));
11331                      write_number(static_cast&lt;std::uint16_t&gt;(N));
11332                  }
11333                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11334                  {
11335                      oa-&gt;write_character(to_char_type(0xDB));
11336                      write_number(static_cast&lt;std::uint32_t&gt;(N));
11337                  }
11338                  oa-&gt;write_characters(
11339                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
11340                      j.m_value.string-&gt;size());
11341                  break;
11342              }
11343              case value_t::array:
11344              {
11345                  const auto N = j.m_value.array-&gt;size();
11346                  if (N &lt;= 15)
11347                  {
11348                      write_number(static_cast&lt;std::uint8_t&gt;(0x90 | N));
11349                  }
11350                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11351                  {
11352                      oa-&gt;write_character(to_char_type(0xDC));
11353                      write_number(static_cast&lt;std::uint16_t&gt;(N));
11354                  }
11355                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11356                  {
11357                      oa-&gt;write_character(to_char_type(0xDD));
11358                      write_number(static_cast&lt;std::uint32_t&gt;(N));
11359                  }
11360                  for (const auto&amp; el : *j.m_value.array)
11361                  {
11362                      write_msgpack(el);
11363                  }
11364                  break;
11365              }
11366              case value_t::binary:
11367              {
11368                  const bool use_ext = j.m_value.binary-&gt;has_subtype();
11369                  const auto N = j.m_value.binary-&gt;size();
11370                  if (N &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11371                  {
11372                      std::uint8_t output_type{};
11373                      bool fixed = true;
11374                      if (use_ext)
11375                      {
11376                          switch (N)
11377                          {
11378                              case 1:
11379                                  output_type = 0xD4; 
11380                                  break;
11381                              case 2:
11382                                  output_type = 0xD5; 
11383                                  break;
11384                              case 4:
11385                                  output_type = 0xD6; 
11386                                  break;
11387                              case 8:
11388                                  output_type = 0xD7; 
11389                                  break;
11390                              case 16:
11391                                  output_type = 0xD8; 
11392                                  break;
11393                              default:
11394                                  output_type = 0xC7; 
11395                                  fixed = false;
11396                                  break;
11397                          }
11398                      }
11399                      else
11400                      {
11401                          output_type = 0xC4; 
11402                          fixed = false;
11403                      }
11404                      oa-&gt;write_character(to_char_type(output_type));
11405                      if (!fixed)
11406                      {
11407                          write_number(static_cast&lt;std::uint8_t&gt;(N));
11408                      }
11409                  }
11410                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11411                  {
11412                      std::uint8_t output_type = use_ext
11413                                                 ? 0xC8 
11414                                                 : 0xC5; 
11415                      oa-&gt;write_character(to_char_type(output_type));
11416                      write_number(static_cast&lt;std::uint16_t&gt;(N));
11417                  }
11418                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11419                  {
11420                      std::uint8_t output_type = use_ext
11421                                                 ? 0xC9 
11422                                                 : 0xC6; 
11423                      oa-&gt;write_character(to_char_type(output_type));
11424                      write_number(static_cast&lt;std::uint32_t&gt;(N));
11425                  }
11426                  if (use_ext)
11427                  {
11428                      write_number(static_cast&lt;std::int8_t&gt;(j.m_value.binary-&gt;subtype()));
11429                  }
11430                  oa-&gt;write_characters(
11431                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.binary-&gt;data()),
11432                      N);
11433                  break;
11434              }
11435              case value_t::object:
11436              {
11437                  const auto N = j.m_value.object-&gt;size();
11438                  if (N &lt;= 15)
11439                  {
11440                      write_number(static_cast&lt;std::uint8_t&gt;(0x80 | (N &amp; 0xF)));
11441                  }
11442                  else if (N &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)())
11443                  {
11444                      oa-&gt;write_character(to_char_type(0xDE));
11445                      write_number(static_cast&lt;std::uint16_t&gt;(N));
11446                  }
11447                  else if (N &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)())
11448                  {
11449                      oa-&gt;write_character(to_char_type(0xDF));
11450                      write_number(static_cast&lt;std::uint32_t&gt;(N));
11451                  }
11452                  for (const auto&amp; el : *j.m_value.object)
11453                  {
11454                      write_msgpack(el.first);
11455                      write_msgpack(el.second);
11456                  }
11457                  break;
11458              }
11459              case value_t::discarded:
11460              default:
11461                  break;
11462          }
11463      }
11464      void write_ubjson(const BasicJsonType&amp; j, const bool use_count,
11465                        const bool use_type, const bool add_prefix = true,
11466                        const bool use_bjdata = false)
11467      {
11468          switch (j.type())
11469          {
11470              case value_t::null:
11471              {
11472                  if (add_prefix)
11473                  {
11474                      oa-&gt;write_character(to_char_type(&#x27;Z&#x27;));
11475                  }
11476                  break;
11477              }
11478              case value_t::boolean:
11479              {
11480                  if (add_prefix)
11481                  {
11482                      oa-&gt;write_character(j.m_value.boolean
11483                                          ? to_char_type(&#x27;T&#x27;)
11484                                          : to_char_type(&#x27;F&#x27;));
11485                  }
11486                  break;
11487              }
11488              case value_t::number_integer:
11489              {
11490                  write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix, use_bjdata);
11491                  break;
11492              }
11493              case value_t::number_unsigned:
11494              {
11495                  write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix, use_bjdata);
11496                  break;
11497              }
11498              case value_t::number_float:
11499              {
11500                  write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix, use_bjdata);
11501                  break;
11502              }
11503              case value_t::string:
11504              {
11505                  if (add_prefix)
11506                  {
11507                      oa-&gt;write_character(to_char_type(&#x27;S&#x27;));
11508                  }
11509                  write_number_with_ubjson_prefix(j.m_value.string-&gt;size(), true, use_bjdata);
11510                  oa-&gt;write_characters(
11511                      reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
11512                      j.m_value.string-&gt;size());
11513                  break;
11514              }
11515              case value_t::array:
11516              {
11517                  if (add_prefix)
11518                  {
11519                      oa-&gt;write_character(to_char_type(&#x27;[&#x27;));
11520                  }
11521                  bool prefix_required = true;
11522                  if (use_type &amp;&amp; !j.m_value.array-&gt;empty())
11523                  {
11524                      JSON_ASSERT(use_count);
11525                      const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
11526                      const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
11527                                                           [this, first_prefix, use_bjdata](const BasicJsonType &amp; v)
11528                      {
11529                          return ubjson_prefix(v, use_bjdata) == first_prefix;
11530                      });
11531                      std::vector&lt;CharType&gt; bjdx = {&#x27;[&#x27;, &#x27;{&#x27;, &#x27;S&#x27;, &#x27;H&#x27;, &#x27;T&#x27;, &#x27;F&#x27;, &#x27;N&#x27;, &#x27;Z&#x27;}; 
11532                      if (same_prefix &amp;&amp; !(use_bjdata &amp;&amp; std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
11533                      {
11534                          prefix_required = false;
11535                          oa-&gt;write_character(to_char_type(&#x27;$&#x27;));
11536                          oa-&gt;write_character(first_prefix);
11537                      }
11538                  }
11539                  if (use_count)
11540                  {
11541                      oa-&gt;write_character(to_char_type(&#x27;#&#x27;));
11542                      write_number_with_ubjson_prefix(j.m_value.array-&gt;size(), true, use_bjdata);
11543                  }
11544                  for (const auto&amp; el : *j.m_value.array)
11545                  {
11546                      write_ubjson(el, use_count, use_type, prefix_required, use_bjdata);
11547                  }
11548                  if (!use_count)
11549                  {
11550                      oa-&gt;write_character(to_char_type(&#x27;]&#x27;));
11551                  }
11552                  break;
11553              }
11554              case value_t::binary:
11555              {
11556                  if (add_prefix)
11557                  {
11558                      oa-&gt;write_character(to_char_type(&#x27;[&#x27;));
11559                  }
11560                  if (use_type &amp;&amp; !j.m_value.binary-&gt;empty())
11561                  {
11562                      JSON_ASSERT(use_count);
11563                      oa-&gt;write_character(to_char_type(&#x27;$&#x27;));
11564                      oa-&gt;write_character(&#x27;U&#x27;);
11565                  }
11566                  if (use_count)
11567                  {
11568                      oa-&gt;write_character(to_char_type(&#x27;#&#x27;));
11569                      write_number_with_ubjson_prefix(j.m_value.binary-&gt;size(), true, use_bjdata);
11570                  }
11571                  if (use_type)
11572                  {
11573                      oa-&gt;write_characters(
11574                          reinterpret_cast&lt;const CharType*&gt;(j.m_value.binary-&gt;data()),
11575                          j.m_value.binary-&gt;size());
11576                  }
11577                  else
11578                  {
11579                      for (size_t i = 0; i &lt; j.m_value.binary-&gt;size(); ++i)
11580                      {
11581                          oa-&gt;write_character(to_char_type(&#x27;U&#x27;));
11582                          oa-&gt;write_character(j.m_value.binary-&gt;data()[i]);
11583                      }
11584                  }
11585                  if (!use_count)
11586                  {
11587                      oa-&gt;write_character(to_char_type(&#x27;]&#x27;));
11588                  }
11589                  break;
11590              }
11591              case value_t::object:
11592              {
11593                  if (use_bjdata &amp;&amp; j.m_value.object-&gt;size() == 3 &amp;&amp; j.m_value.object-&gt;find(&quot;_ArrayType_&quot;) != j.m_value.object-&gt;end() &amp;&amp; j.m_value.object-&gt;find(&quot;_ArraySize_&quot;) != j.m_value.object-&gt;end() &amp;&amp; j.m_value.object-&gt;find(&quot;_ArrayData_&quot;) != j.m_value.object-&gt;end())
11594                  {
11595                      if (!write_bjdata_ndarray(*j.m_value.object, use_count, use_type))  
11596                      {
11597                          break;
11598                      }
11599                  }
11600                  if (add_prefix)
11601                  {
11602                      oa-&gt;write_character(to_char_type(&#x27;{&#x27;));
11603                  }
11604                  bool prefix_required = true;
11605                  if (use_type &amp;&amp; !j.m_value.object-&gt;empty())
11606                  {
11607                      JSON_ASSERT(use_count);
11608                      const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
11609                      const bool same_prefix = std::all_of(j.begin(), j.end(),
11610                                                           [this, first_prefix, use_bjdata](const BasicJsonType &amp; v)
11611                      {
11612                          return ubjson_prefix(v, use_bjdata) == first_prefix;
11613                      });
11614                      std::vector&lt;CharType&gt; bjdx = {&#x27;[&#x27;, &#x27;{&#x27;, &#x27;S&#x27;, &#x27;H&#x27;, &#x27;T&#x27;, &#x27;F&#x27;, &#x27;N&#x27;, &#x27;Z&#x27;}; 
11615                      if (same_prefix &amp;&amp; !(use_bjdata &amp;&amp; std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
11616                      {
11617                          prefix_required = false;
11618                          oa-&gt;write_character(to_char_type(&#x27;$&#x27;));
11619                          oa-&gt;write_character(first_prefix);
11620                      }
11621                  }
11622                  if (use_count)
11623                  {
11624                      oa-&gt;write_character(to_char_type(&#x27;#&#x27;));
11625                      write_number_with_ubjson_prefix(j.m_value.object-&gt;size(), true, use_bjdata);
11626                  }
11627                  for (const auto&amp; el : *j.m_value.object)
11628                  {
11629                      write_number_with_ubjson_prefix(el.first.size(), true, use_bjdata);
11630                      oa-&gt;write_characters(
11631                          reinterpret_cast&lt;const CharType*&gt;(el.first.c_str()),
11632                          el.first.size());
11633                      write_ubjson(el.second, use_count, use_type, prefix_required, use_bjdata);
11634                  }
11635                  if (!use_count)
11636                  {
11637                      oa-&gt;write_character(to_char_type(&#x27;}&#x27;));
11638                  }
11639                  break;
11640              }
11641              case value_t::discarded:
11642              default:
11643                  break;
11644          }
11645      }
11646    private:
11647      static std::size_t calc_bson_entry_header_size(const string_t&amp; name, const BasicJsonType&amp; j)
11648      {
11649          const auto it = name.find(static_cast&lt;typename string_t::value_type&gt;(0));
11650          if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
11651          {
11652              JSON_THROW(out_of_range::create(409, concat(&quot;BSON key cannot contain code point U+0000 (at byte &quot;, std::to_string(it), &quot;)&quot;), &amp;j));
11653              static_cast&lt;void&gt;(j);
11654          }
11655          return &amp;bsol;*id*/ 1ul + name.size() + &amp;bsol;*zero-terminator*/1u;
11656      }
11657      void write_bson_entry_header(const string_t&amp; name,
11658                                   const std::uint8_t element_type)
11659      {
11660          oa-&gt;write_character(to_char_type(element_type)); 
11661          oa-&gt;write_characters(
11662              reinterpret_cast&lt;const CharType*&gt;(name.c_str()),
11663              name.size() + 1u);
11664      }
11665      void write_bson_boolean(const string_t&amp; name,
11666                              const bool value)
11667      {
11668          write_bson_entry_header(name, 0x08);
11669          oa-&gt;write_character(value ? to_char_type(0x01) : to_char_type(0x00));
11670      }
11671      void write_bson_double(const string_t&amp; name,
11672                             const double value)
11673      {
11674          write_bson_entry_header(name, 0x01);
11675          write_number&lt;double&gt;(value, true);
11676      }
11677      static std::size_t calc_bson_string_size(const string_t&amp; value)
11678      {
11679          return sizeof(std::int32_t) + value.size() + 1ul;
11680      }
11681      void write_bson_string(const string_t&amp; name,
11682                             const string_t&amp; value)
11683      {
11684          write_bson_entry_header(name, 0x02);
11685          write_number&lt;std::int32_t&gt;(static_cast&lt;std::int32_t&gt;(value.size() + 1ul), true);
11686          oa-&gt;write_characters(
11687              reinterpret_cast&lt;const CharType*&gt;(value.c_str()),
11688              value.size() + 1);
11689      }
11690      void write_bson_null(const string_t&amp; name)
11691      {
11692          write_bson_entry_header(name, 0x0A);
11693      }
11694      static std::size_t calc_bson_integer_size(const std::int64_t value)
11695      {
11696          return (std::numeric_limits&lt;std::int32_t&gt;::min)() &lt;= value &amp;&amp; value &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)()
11697                 ? sizeof(std::int32_t)
11698                 : sizeof(std::int64_t);
11699      }
11700      void write_bson_integer(const string_t&amp; name,
11701                              const std::int64_t value)
11702      {
11703          if ((std::numeric_limits&lt;std::int32_t&gt;::min)() &lt;= value &amp;&amp; value &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)())
11704          {
11705              write_bson_entry_header(name, 0x10); 
11706              write_number&lt;std::int32_t&gt;(static_cast&lt;std::int32_t&gt;(value), true);
11707          }
11708          else
11709          {
11710              write_bson_entry_header(name, 0x12); 
11711              write_number&lt;std::int64_t&gt;(static_cast&lt;std::int64_t&gt;(value), true);
11712          }
11713      }
11714      static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
11715      {
11716          return (value &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int32_t&gt;::max)()))
11717                 ? sizeof(std::int32_t)
11718                 : sizeof(std::int64_t);
11719      }
11720      void write_bson_unsigned(const string_t&amp; name,
11721                               const BasicJsonType&amp; j)
11722      {
11723          if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int32_t&gt;::max)()))
11724          {
11725              write_bson_entry_header(name, 0x10 &amp;bsol;* int32 */);
11726              write_number&lt;std::int32_t&gt;(static_cast&lt;std::int32_t&gt;(j.m_value.number_unsigned), true);
11727          }
11728          else if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int64_t&gt;::max)()))
11729          {
11730              write_bson_entry_header(name, 0x12 &amp;bsol;* int64 */);
11731              write_number&lt;std::int64_t&gt;(static_cast&lt;std::int64_t&gt;(j.m_value.number_unsigned), true);
11732          }
11733          else
11734          {
11735              JSON_THROW(out_of_range::create(407, concat(&quot;integer number &quot;, std::to_string(j.m_value.number_unsigned), &quot; cannot be represented by BSON as it does not fit int64&quot;), &amp;j));
11736          }
11737      }
11738      void write_bson_object_entry(const string_t&amp; name,
11739                                   const typename BasicJsonType::object_t&amp; value)
11740      {
11741          write_bson_entry_header(name, 0x03); 
11742          write_bson_object(value);
11743      }
11744      static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t&amp; value)
11745      {
11746          std::size_t array_index = 0ul;
11747          const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), static_cast&lt;std::size_t&gt;(0), [&amp;array_index](std::size_t result, const typename BasicJsonType::array_t::value_type &amp; el)
11748          {
11749              return result + calc_bson_element_size(std::to_string(array_index++), el);
11750          });
11751          return sizeof(std::int32_t) + embedded_document_size + 1ul;
11752      }
11753      static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t&amp; value)
11754      {
11755          return sizeof(std::int32_t) + value.size() + 1ul;
11756      }
11757      void write_bson_array(const string_t&amp; name,
11758                            const typename BasicJsonType::array_t&amp; value)
11759      {
11760          write_bson_entry_header(name, 0x04); 
11761          write_number&lt;std::int32_t&gt;(static_cast&lt;std::int32_t&gt;(calc_bson_array_size(value)), true);
11762          std::size_t array_index = 0ul;
11763          for (const auto&amp; el : value)
11764          {
11765              write_bson_element(std::to_string(array_index++), el);
11766          }
11767          oa-&gt;write_character(to_char_type(0x00));
11768      }
11769      void write_bson_binary(const string_t&amp; name,
11770                             const binary_t&amp; value)
11771      {
11772          write_bson_entry_header(name, 0x05);
11773          write_number&lt;std::int32_t&gt;(static_cast&lt;std::int32_t&gt;(value.size()), true);
11774          write_number(value.has_subtype() ? static_cast&lt;std::uint8_t&gt;(value.subtype()) : static_cast&lt;std::uint8_t&gt;(0x00));
11775          oa-&gt;write_characters(reinterpret_cast&lt;const CharType*&gt;(value.data()), value.size());
11776      }
11777      static std::size_t calc_bson_element_size(const string_t&amp; name,
11778              const BasicJsonType&amp; j)
11779      {
11780          const auto header_size = calc_bson_entry_header_size(name, j);
11781          switch (j.type())
11782          {
11783              case value_t::object:
11784                  return header_size + calc_bson_object_size(*j.m_value.object);
11785              case value_t::array:
11786                  return header_size + calc_bson_array_size(*j.m_value.array);
11787              case value_t::binary:
11788                  return header_size + calc_bson_binary_size(*j.m_value.binary);
11789              case value_t::boolean:
11790                  return header_size + 1ul;
11791              case value_t::number_float:
11792                  return header_size + 8ul;
11793              case value_t::number_integer:
11794                  return header_size + calc_bson_integer_size(j.m_value.number_integer);
11795              case value_t::number_unsigned:
11796                  return header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);
11797              case value_t::string:
11798                  return header_size + calc_bson_string_size(*j.m_value.string);
11799              case value_t::null:
11800                  return header_size + 0ul;
11801              case value_t::discarded:
11802              default:
11803                  JSON_ASSERT(false); 
11804                  return 0ul;
11805          }
11806      }
11807      void write_bson_element(const string_t&amp; name,
11808                              const BasicJsonType&amp; j)
11809      {
11810          switch (j.type())
11811          {
11812              case value_t::object:
11813                  return write_bson_object_entry(name, *j.m_value.object);
11814              case value_t::array:
11815                  return write_bson_array(name, *j.m_value.array);
11816              case value_t::binary:
11817                  return write_bson_binary(name, *j.m_value.binary);
11818              case value_t::boolean:
11819                  return write_bson_boolean(name, j.m_value.boolean);
11820              case value_t::number_float:
11821                  return write_bson_double(name, j.m_value.number_float);
11822              case value_t::number_integer:
11823                  return write_bson_integer(name, j.m_value.number_integer);
11824              case value_t::number_unsigned:
11825                  return write_bson_unsigned(name, j);
11826              case value_t::string:
11827                  return write_bson_string(name, *j.m_value.string);
11828              case value_t::null:
11829                  return write_bson_null(name);
11830              case value_t::discarded:
11831              default:
11832                  JSON_ASSERT(false); 
11833                  return;
11834          }
11835      }
11836      static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t&amp; value)
11837      {
11838          std::size_t document_size = std::accumulate(value.begin(), value.end(), static_cast&lt;std::size_t&gt;(0),
11839                                      [](size_t result, const typename BasicJsonType::object_t::value_type &amp; el)
11840          {
11841              return result += calc_bson_element_size(el.first, el.second);
11842          });
11843          return sizeof(std::int32_t) + document_size + 1ul;
11844      }
11845      void write_bson_object(const typename BasicJsonType::object_t&amp; value)
11846      {
11847          write_number&lt;std::int32_t&gt;(static_cast&lt;std::int32_t&gt;(calc_bson_object_size(value)), true);
11848          for (const auto&amp; el : value)
11849          {
11850              write_bson_element(el.first, el.second);
11851          }
11852          oa-&gt;write_character(to_char_type(0x00));
11853      }
11854      static constexpr CharType get_cbor_float_prefix(float &amp;bsol;*unused*/)
11855      {
11856          return to_char_type(0xFA);  
11857      }
11858      static constexpr CharType get_cbor_float_prefix(double &amp;bsol;*unused*/)
11859      {
11860          return to_char_type(0xFB);  
11861      }
11862      static constexpr CharType get_msgpack_float_prefix(float &amp;bsol;*unused*/)
11863      {
11864          return to_char_type(0xCA);  
11865      }
11866      static constexpr CharType get_msgpack_float_prefix(double &amp;bsol;*unused*/)
11867      {
11868          return to_char_type(0xCB);  
11869      }
11870      template&lt;typename NumberType, typename std::enable_if&lt;
11871                   std::is_floating_point&lt;NumberType&gt;::value, int&gt;::type = 0&gt;
11872      void write_number_with_ubjson_prefix(const NumberType n,
11873                                           const bool add_prefix,
11874                                           const bool use_bjdata)
11875      {
11876          if (add_prefix)
11877          {
11878              oa-&gt;write_character(get_ubjson_float_prefix(n));
11879          }
11880          write_number(n, use_bjdata);
11881      }
11882      template&lt;typename NumberType, typename std::enable_if&lt;
11883                   std::is_unsigned&lt;NumberType&gt;::value, int&gt;::type = 0&gt;
11884      void write_number_with_ubjson_prefix(const NumberType n,
11885                                           const bool add_prefix,
11886                                           const bool use_bjdata)
11887      {
11888          if (n &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int8_t&gt;::max)()))
11889          {
11890              if (add_prefix)
11891              {
11892                  oa-&gt;write_character(to_char_type(&#x27;i&#x27;));  
11893              }
11894              write_number(static_cast&lt;std::uint8_t&gt;(n), use_bjdata);
11895          }
11896          else if (n &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
11897          {
11898              if (add_prefix)
11899              {
11900                  oa-&gt;write_character(to_char_type(&#x27;U&#x27;));  
11901              }
11902              write_number(static_cast&lt;std::uint8_t&gt;(n), use_bjdata);
11903          }
11904          else if (n &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int16_t&gt;::max)()))
11905          {
11906              if (add_prefix)
11907              {
11908                  oa-&gt;write_character(to_char_type(&#x27;I&#x27;));  
11909              }
11910              write_number(static_cast&lt;std::int16_t&gt;(n), use_bjdata);
11911          }
11912          else if (use_bjdata &amp;&amp; n &lt;= static_cast&lt;uint64_t&gt;((std::numeric_limits&lt;uint16_t&gt;::max)()))
11913          {
11914              if (add_prefix)
11915              {
11916                  oa-&gt;write_character(to_char_type(&#x27;u&#x27;));  
11917              }
11918              write_number(static_cast&lt;std::uint16_t&gt;(n), use_bjdata);
11919          }
11920          else if (n &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int32_t&gt;::max)()))
11921          {
11922              if (add_prefix)
11923              {
11924                  oa-&gt;write_character(to_char_type(&#x27;l&#x27;));  
11925              }
11926              write_number(static_cast&lt;std::int32_t&gt;(n), use_bjdata);
11927          }
11928          else if (use_bjdata &amp;&amp; n &lt;= static_cast&lt;uint64_t&gt;((std::numeric_limits&lt;uint32_t&gt;::max)()))
11929          {
11930              if (add_prefix)
11931              {
11932                  oa-&gt;write_character(to_char_type(&#x27;m&#x27;));  
11933              }
11934              write_number(static_cast&lt;std::uint32_t&gt;(n), use_bjdata);
11935          }
11936          else if (n &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int64_t&gt;::max)()))
11937          {
11938              if (add_prefix)
11939              {
11940                  oa-&gt;write_character(to_char_type(&#x27;L&#x27;));  
11941              }
11942              write_number(static_cast&lt;std::int64_t&gt;(n), use_bjdata);
11943          }
11944          else if (use_bjdata &amp;&amp; n &lt;= (std::numeric_limits&lt;uint64_t&gt;::max)())
11945          {
11946              if (add_prefix)
11947              {
11948                  oa-&gt;write_character(to_char_type(&#x27;M&#x27;));  
11949              }
11950              write_number(static_cast&lt;std::uint64_t&gt;(n), use_bjdata);
11951          }
11952          else
11953          {
11954              if (add_prefix)
11955              {
11956                  oa-&gt;write_character(to_char_type(&#x27;H&#x27;));  
11957              }
11958              const auto number = BasicJsonType(n).dump();
11959              write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
11960              for (std::size_t i = 0; i &lt; number.size(); ++i)
11961              {
11962                  oa-&gt;write_character(to_char_type(static_cast&lt;std::uint8_t&gt;(number[i])));
11963              }
11964          }
11965      }
11966      template &lt; typename NumberType, typename std::enable_if &lt;
11967                     std::is_signed&lt;NumberType&gt;::value&amp;&amp;
11968                     !std::is_floating_point&lt;NumberType&gt;::value, int &gt;::type = 0 &gt;
11969      void write_number_with_ubjson_prefix(const NumberType n,
11970                                           const bool add_prefix,
11971                                           const bool use_bjdata)
11972      {
11973          if ((std::numeric_limits&lt;std::int8_t&gt;::min)() &lt;= n &amp;&amp; n &lt;= (std::numeric_limits&lt;std::int8_t&gt;::max)())
11974          {
11975              if (add_prefix)
11976              {
11977                  oa-&gt;write_character(to_char_type(&#x27;i&#x27;));  
11978              }
11979              write_number(static_cast&lt;std::int8_t&gt;(n), use_bjdata);
11980          }
11981          else if (static_cast&lt;std::int64_t&gt;((std::numeric_limits&lt;std::uint8_t&gt;::min)()) &lt;= n &amp;&amp; n &lt;= static_cast&lt;std::int64_t&gt;((std::numeric_limits&lt;std::uint8_t&gt;::max)()))
11982          {
11983              if (add_prefix)
11984              {
11985                  oa-&gt;write_character(to_char_type(&#x27;U&#x27;));  
11986              }
11987              write_number(static_cast&lt;std::uint8_t&gt;(n), use_bjdata);
11988          }
11989          else if ((std::numeric_limits&lt;std::int16_t&gt;::min)() &lt;= n &amp;&amp; n &lt;= (std::numeric_limits&lt;std::int16_t&gt;::max)())
11990          {
11991              if (add_prefix)
11992              {
11993                  oa-&gt;write_character(to_char_type(&#x27;I&#x27;));  
11994              }
11995              write_number(static_cast&lt;std::int16_t&gt;(n), use_bjdata);
11996          }
11997          else if (use_bjdata &amp;&amp; (static_cast&lt;std::int64_t&gt;((std::numeric_limits&lt;std::uint16_t&gt;::min)()) &lt;= n &amp;&amp; n &lt;= static_cast&lt;std::int64_t&gt;((std::numeric_limits&lt;std::uint16_t&gt;::max)())))
11998          {
11999              if (add_prefix)
12000              {
12001                  oa-&gt;write_character(to_char_type(&#x27;u&#x27;));  
12002              }
12003              write_number(static_cast&lt;uint16_t&gt;(n), use_bjdata);
12004          }
12005          else if ((std::numeric_limits&lt;std::int32_t&gt;::min)() &lt;= n &amp;&amp; n &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)())
12006          {
12007              if (add_prefix)
12008              {
12009                  oa-&gt;write_character(to_char_type(&#x27;l&#x27;));  
12010              }
12011              write_number(static_cast&lt;std::int32_t&gt;(n), use_bjdata);
12012          }
12013          else if (use_bjdata &amp;&amp; (static_cast&lt;std::int64_t&gt;((std::numeric_limits&lt;std::uint32_t&gt;::min)()) &lt;= n &amp;&amp; n &lt;= static_cast&lt;std::int64_t&gt;((std::numeric_limits&lt;std::uint32_t&gt;::max)())))
12014          {
12015              if (add_prefix)
12016              {
12017                  oa-&gt;write_character(to_char_type(&#x27;m&#x27;));  
12018              }
12019              write_number(static_cast&lt;uint32_t&gt;(n), use_bjdata);
12020          }
12021          else if ((std::numeric_limits&lt;std::int64_t&gt;::min)() &lt;= n &amp;&amp; n &lt;= (std::numeric_limits&lt;std::int64_t&gt;::max)())
12022          {
12023              if (add_prefix)
12024              {
12025                  oa-&gt;write_character(to_char_type(&#x27;L&#x27;));  
12026              }
12027              write_number(static_cast&lt;std::int64_t&gt;(n), use_bjdata);
12028          }
12029          else
12030          {
12031              if (add_prefix)
12032              {
12033                  oa-&gt;write_character(to_char_type(&#x27;H&#x27;));  
12034              }
12035              const auto number = BasicJsonType(n).dump();
12036              write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
12037              for (std::size_t i = 0; i &lt; number.size(); ++i)
12038              {
12039                  oa-&gt;write_character(to_char_type(static_cast&lt;std::uint8_t&gt;(number[i])));
12040              }
12041          }
12042      }
12043      CharType ubjson_prefix(const BasicJsonType&amp; j, const bool use_bjdata) const noexcept
12044      {
12045          switch (j.type())
12046          {
12047              case value_t::null:
12048                  return &#x27;Z&#x27;;
12049              case value_t::boolean:
12050                  return j.m_value.boolean ? &#x27;T&#x27; : &#x27;F&#x27;;
12051              case value_t::number_integer:
12052              {
12053                  if ((std::numeric_limits&lt;std::int8_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int8_t&gt;::max)())
12054                  {
12055                      return &#x27;i&#x27;;
12056                  }
12057                  if ((std::numeric_limits&lt;std::uint8_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint8_t&gt;::max)())
12058                  {
12059                      return &#x27;U&#x27;;
12060                  }
12061                  if ((std::numeric_limits&lt;std::int16_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int16_t&gt;::max)())
12062                  {
12063                      return &#x27;I&#x27;;
12064                  }
12065                  if (use_bjdata &amp;&amp; ((std::numeric_limits&lt;std::uint16_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint16_t&gt;::max)()))
12066                  {
12067                      return &#x27;u&#x27;;
12068                  }
12069                  if ((std::numeric_limits&lt;std::int32_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int32_t&gt;::max)())
12070                  {
12071                      return &#x27;l&#x27;;
12072                  }
12073                  if (use_bjdata &amp;&amp; ((std::numeric_limits&lt;std::uint32_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::uint32_t&gt;::max)()))
12074                  {
12075                      return &#x27;m&#x27;;
12076                  }
12077                  if ((std::numeric_limits&lt;std::int64_t&gt;::min)() &lt;= j.m_value.number_integer &amp;&amp; j.m_value.number_integer &lt;= (std::numeric_limits&lt;std::int64_t&gt;::max)())
12078                  {
12079                      return &#x27;L&#x27;;
12080                  }
12081                  return &#x27;H&#x27;; 
12082              }
12083              case value_t::number_unsigned:
12084              {
12085                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int8_t&gt;::max)()))
12086                  {
12087                      return &#x27;i&#x27;;
12088                  }
12089                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::uint8_t&gt;::max)()))
12090                  {
12091                      return &#x27;U&#x27;;
12092                  }
12093                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int16_t&gt;::max)()))
12094                  {
12095                      return &#x27;I&#x27;;
12096                  }
12097                  if (use_bjdata &amp;&amp; j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::uint16_t&gt;::max)()))
12098                  {
12099                      return &#x27;u&#x27;;
12100                  }
12101                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int32_t&gt;::max)()))
12102                  {
12103                      return &#x27;l&#x27;;
12104                  }
12105                  if (use_bjdata &amp;&amp; j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::uint32_t&gt;::max)()))
12106                  {
12107                      return &#x27;m&#x27;;
12108                  }
12109                  if (j.m_value.number_unsigned &lt;= static_cast&lt;std::uint64_t&gt;((std::numeric_limits&lt;std::int64_t&gt;::max)()))
12110                  {
12111                      return &#x27;L&#x27;;
12112                  }
12113                  if (use_bjdata &amp;&amp; j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)())
12114                  {
12115                      return &#x27;M&#x27;;
12116                  }
12117                  return &#x27;H&#x27;; 
12118              }
12119              case value_t::number_float:
12120                  return get_ubjson_float_prefix(j.m_value.number_float);
12121              case value_t::string:
12122                  return &#x27;S&#x27;;
12123              case value_t::array: 
12124              case value_t::binary:
12125                  return &#x27;[&#x27;;
12126              case value_t::object:
12127                  return &#x27;{&#x27;;
12128              case value_t::discarded:
12129              default:  
12130                  return &#x27;N&#x27;;
12131          }
12132      }
12133      static constexpr CharType get_ubjson_float_prefix(float &amp;bsol;*unused*/)
12134      {
12135          return &#x27;d&#x27;;  
12136      }
12137      static constexpr CharType get_ubjson_float_prefix(double &amp;bsol;*unused*/)
12138      {
12139          return &#x27;D&#x27;;  
12140      }
12141      bool write_bjdata_ndarray(const typename BasicJsonType::object_t&amp; value, const bool use_count, const bool use_type)
12142      {
12143          std::map&lt;string_t, CharType&gt; bjdtype = {{&quot;uint8&quot;, &#x27;U&#x27;},  {&quot;int8&quot;, &#x27;i&#x27;},  {&quot;uint16&quot;, &#x27;u&#x27;}, {&quot;int16&quot;, &#x27;I&#x27;},
12144              {&quot;uint32&quot;, &#x27;m&#x27;}, {&quot;int32&quot;, &#x27;l&#x27;}, {&quot;uint64&quot;, &#x27;M&#x27;}, {&quot;int64&quot;, &#x27;L&#x27;}, {&quot;single&quot;, &#x27;d&#x27;}, {&quot;double&quot;, &#x27;D&#x27;}, {&quot;char&quot;, &#x27;C&#x27;}
12145          };
12146          string_t key = &quot;_ArrayType_&quot;;
12147          auto it = bjdtype.find(static_cast&lt;string_t&gt;(value.at(key)));
12148          if (it == bjdtype.end())
12149          {
12150              return true;
12151          }
12152          CharType dtype = it-&gt;second;
12153          key = &quot;_ArraySize_&quot;;
12154          std::size_t len = (value.at(key).empty() ? 0 : 1);
12155          for (const auto&amp; el : value.at(key))
12156          {
12157              len *= static_cast&lt;std::size_t&gt;(el.m_value.number_unsigned);
12158          }
12159          key = &quot;_ArrayData_&quot;;
12160          if (value.at(key).size() != len)
12161          {
12162              return true;
12163          }
12164          oa-&gt;write_character(&#x27;[&#x27;);
12165          oa-&gt;write_character(&#x27;$&#x27;);
12166          oa-&gt;write_character(dtype);
12167          oa-&gt;write_character(&#x27;#&#x27;);
12168          key = &quot;_ArraySize_&quot;;
12169          write_ubjson(value.at(key), use_count, use_type, true,  true);
12170          key = &quot;_ArrayData_&quot;;
12171          if (dtype == &#x27;U&#x27; || dtype == &#x27;C&#x27;)
12172          {
12173              for (const auto&amp; el : value.at(key))
12174              {
12175                  write_number(static_cast&lt;std::uint8_t&gt;(el.m_value.number_unsigned), true);
12176              }
12177          }
12178          else if (dtype == &#x27;i&#x27;)
12179          {
12180              for (const auto&amp; el : value.at(key))
12181              {
12182                  write_number(static_cast&lt;std::int8_t&gt;(el.m_value.number_integer), true);
12183              }
12184          }
12185          else if (dtype == &#x27;u&#x27;)
12186          {
12187              for (const auto&amp; el : value.at(key))
12188              {
12189                  write_number(static_cast&lt;std::uint16_t&gt;(el.m_value.number_unsigned), true);
12190              }
12191          }
12192          else if (dtype == &#x27;I&#x27;)
12193          {
12194              for (const auto&amp; el : value.at(key))
12195              {
12196                  write_number(static_cast&lt;std::int16_t&gt;(el.m_value.number_integer), true);
12197              }
12198          }
12199          else if (dtype == &#x27;m&#x27;)
12200          {
12201              for (const auto&amp; el : value.at(key))
12202              {
12203                  write_number(static_cast&lt;std::uint32_t&gt;(el.m_value.number_unsigned), true);
12204              }
12205          }
12206          else if (dtype == &#x27;l&#x27;)
12207          {
12208              for (const auto&amp; el : value.at(key))
12209              {
12210                  write_number(static_cast&lt;std::int32_t&gt;(el.m_value.number_integer), true);
12211              }
12212          }
12213          else if (dtype == &#x27;M&#x27;)
12214          {
12215              for (const auto&amp; el : value.at(key))
12216              {
12217                  write_number(static_cast&lt;std::uint64_t&gt;(el.m_value.number_unsigned), true);
12218              }
12219          }
12220          else if (dtype == &#x27;L&#x27;)
12221          {
12222              for (const auto&amp; el : value.at(key))
12223              {
12224                  write_number(static_cast&lt;std::int64_t&gt;(el.m_value.number_integer), true);
12225              }
12226          }
12227          else if (dtype == &#x27;d&#x27;)
12228          {
12229              for (const auto&amp; el : value.at(key))
12230              {
12231                  write_number(static_cast&lt;float&gt;(el.m_value.number_float), true);
12232              }
12233          }
12234          else if (dtype == &#x27;D&#x27;)
12235          {
12236              for (const auto&amp; el : value.at(key))
12237              {
12238                  write_number(static_cast&lt;double&gt;(el.m_value.number_float), true);
12239              }
12240          }
12241          return false;
12242      }
12243      template&lt;typename NumberType&gt;
12244      void write_number(const NumberType n, const bool OutputIsLittleEndian = false)
12245      {
12246          std::array&lt;CharType, sizeof(NumberType)&gt; vec{};
12247          std::memcpy(vec.data(), &amp;n, sizeof(NumberType));
12248          if (is_little_endian != OutputIsLittleEndian)
12249          {
12250              std::reverse(vec.begin(), vec.end());
12251          }
12252          oa-&gt;write_characters(vec.data(), sizeof(NumberType));
12253      }
12254      void write_compact_float(const number_float_t n, detail::input_format_t format)
12255      {
12256  #ifdef __GNUC__
12257  #pragma GCC diagnostic push
12258  #pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;
12259  #endif
12260          if (static_cast&lt;double&gt;(n) &gt;= static_cast&lt;double&gt;(std::numeric_limits&lt;float&gt;::lowest()) &amp;&amp;
12261                  static_cast&lt;double&gt;(n) &lt;= static_cast&lt;double&gt;((std::numeric_limits&lt;float&gt;::max)()) &amp;&amp;
12262                  static_cast&lt;double&gt;(static_cast&lt;float&gt;(n)) == static_cast&lt;double&gt;(n))
12263          {
12264              oa-&gt;write_character(format == detail::input_format_t::cbor
12265                                  ? get_cbor_float_prefix(static_cast&lt;float&gt;(n))
12266                                  : get_msgpack_float_prefix(static_cast&lt;float&gt;(n)));
12267              write_number(static_cast&lt;float&gt;(n));
12268          }
12269          else
12270          {
12271              oa-&gt;write_character(format == detail::input_format_t::cbor
12272                                  ? get_cbor_float_prefix(n)
12273                                  : get_msgpack_float_prefix(n));
12274              write_number(n);
12275          }
12276  #ifdef __GNUC__
12277  #pragma GCC diagnostic pop
12278  #endif
12279      }
12280    public:
12281      template &lt; typename C = CharType,
12282                 enable_if_t &lt; std::is_signed&lt;C&gt;::value &amp;&amp; std::is_signed&lt;char&gt;::value &gt; * = nullptr &gt;
12283      static constexpr CharType to_char_type(std::uint8_t x) noexcept
12284      {
12285          return *reinterpret_cast&lt;char*&gt;(&amp;x);
12286      }
12287      template &lt; typename C = CharType,
12288                 enable_if_t &lt; std::is_signed&lt;C&gt;::value &amp;&amp; std::is_unsigned&lt;char&gt;::value &gt; * = nullptr &gt;
12289      static CharType to_char_type(std::uint8_t x) noexcept
12290      {
12291          static_assert(sizeof(std::uint8_t) == sizeof(CharType), &quot;size of CharType must be equal to std::uint8_t&quot;);
12292          static_assert(std::is_trivial&lt;CharType&gt;::value, &quot;CharType must be trivial&quot;);
12293          CharType result;
12294          std::memcpy(&amp;result, &amp;x, sizeof(x));
12295          return result;
12296      }
12297      template&lt;typename C = CharType,
12298               enable_if_t&lt;std::is_unsigned&lt;C&gt;::value&gt;* = nullptr&gt;
12299      static constexpr CharType to_char_type(std::uint8_t x) noexcept
12300      {
12301          return x;
12302      }
12303      template &lt; typename InputCharType, typename C = CharType,
12304                 enable_if_t &lt;
12305                     std::is_signed&lt;C&gt;::value &amp;&amp;
12306                     std::is_signed&lt;char&gt;::value &amp;&amp;
12307                     std::is_same&lt;char, typename std::remove_cv&lt;InputCharType&gt;::type&gt;::value
12308                     &gt; * = nullptr &gt;
12309      static constexpr CharType to_char_type(InputCharType x) noexcept
12310      {
12311          return x;
12312      }
12313    private:
12314      const bool is_little_endian = little_endianness();
12315      output_adapter_t&lt;CharType&gt; oa = nullptr;
12316  };
12317  }  
12318  NLOHMANN_JSON_NAMESPACE_END
12319  #include &lt;algorithm&gt; 
12320  #include &lt;array&gt; 
12321  #include &lt;clocale&gt; 
12322  #include &lt;cmath&gt; 
12323  #include &lt;cstddef&gt; 
12324  #include &lt;cstdint&gt; 
12325  #include &lt;cstdio&gt; 
12326  #include &lt;limits&gt; 
12327  #include &lt;string&gt; 
12328  #include &lt;iomanip&gt; 
12329  #include &lt;type_traits&gt; 
12330  #include &lt;utility&gt; 
12331  #include &lt;array&gt; 
12332  #include &lt;cmath&gt;   
12333  #include &lt;cstdint&gt; 
12334  #include &lt;cstring&gt; 
12335  #include &lt;limits&gt; 
12336  #include &lt;type_traits&gt; 
12337  NLOHMANN_JSON_NAMESPACE_BEGIN
12338  namespace detail
12339  {
12340  namespace dtoa_impl
12341  {
12342  template&lt;typename Target, typename Source&gt;
12343  Target reinterpret_bits(const Source source)
12344  {
12345      static_assert(sizeof(Target) == sizeof(Source), &quot;size mismatch&quot;);
12346      Target target;
12347      std::memcpy(&amp;target, &amp;source, sizeof(Source));
12348      return target;
12349  }
12350  struct diyfp 
12351  {
12352      static constexpr int kPrecision = 64; 
12353      std::uint64_t f = 0;
12354      int e = 0;
12355      constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}
12356      static diyfp sub(const diyfp&amp; x, const diyfp&amp; y) noexcept
12357      {
12358          JSON_ASSERT(x.e == y.e);
12359          JSON_ASSERT(x.f &gt;= y.f);
12360          return {x.f - y.f, x.e};
12361      }
12362      static diyfp mul(const diyfp&amp; x, const diyfp&amp; y) noexcept
12363      {
12364          static_assert(kPrecision == 64, &quot;internal error&quot;);
12365          const std::uint64_t u_lo = x.f &amp; 0xFFFFFFFFu;
12366          const std::uint64_t u_hi = x.f &gt;&gt; 32u;
12367          const std::uint64_t v_lo = y.f &amp; 0xFFFFFFFFu;
12368          const std::uint64_t v_hi = y.f &gt;&gt; 32u;
12369          const std::uint64_t p0 = u_lo * v_lo;
12370          const std::uint64_t p1 = u_lo * v_hi;
12371          const std::uint64_t p2 = u_hi * v_lo;
12372          const std::uint64_t p3 = u_hi * v_hi;
12373          const std::uint64_t p0_hi = p0 &gt;&gt; 32u;
12374          const std::uint64_t p1_lo = p1 &amp; 0xFFFFFFFFu;
12375          const std::uint64_t p1_hi = p1 &gt;&gt; 32u;
12376          const std::uint64_t p2_lo = p2 &amp; 0xFFFFFFFFu;
12377          const std::uint64_t p2_hi = p2 &gt;&gt; 32u;
12378          std::uint64_t Q = p0_hi + p1_lo + p2_lo;
12379          Q += std::uint64_t{1} &lt;&lt; (64u - 32u - 1u); 
12380          const std::uint64_t h = p3 + p2_hi + p1_hi + (Q &gt;&gt; 32u);
12381          return {h, x.e + y.e + 64};
12382      }
12383      static diyfp normalize(diyfp x) noexcept
12384      {
12385          JSON_ASSERT(x.f != 0);
12386          while ((x.f &gt;&gt; 63u) == 0)
12387          {
12388              x.f &lt;&lt;= 1u;
12389              x.e--;
12390          }
12391          return x;
12392      }
12393      static diyfp normalize_to(const diyfp&amp; x, const int target_exponent) noexcept
12394      {
12395          const int delta = x.e - target_exponent;
12396          JSON_ASSERT(delta &gt;= 0);
12397          JSON_ASSERT(((x.f &lt;&lt; delta) &gt;&gt; delta) == x.f);
12398          return {x.f &lt;&lt; delta, target_exponent};
12399      }
12400  };
12401  struct boundaries
12402  {
12403      diyfp w;
12404      diyfp minus;
12405      diyfp plus;
12406  };
12407  template&lt;typename FloatType&gt;
12408  boundaries compute_boundaries(FloatType value)
12409  {
12410      JSON_ASSERT(std::isfinite(value));
12411      JSON_ASSERT(value &gt; 0);
12412      static_assert(std::numeric_limits&lt;FloatType&gt;::is_iec559,
12413                    &quot;internal error: dtoa_short requires an IEEE-754 floating-point implementation&quot;);
12414      constexpr int      kPrecision = std::numeric_limits&lt;FloatType&gt;::digits; 
12415      constexpr int      kBias      = std::numeric_limits&lt;FloatType&gt;::max_exponent - 1 + (kPrecision - 1);
12416      constexpr int      kMinExp    = 1 - kBias;
12417      constexpr std::uint64_t kHiddenBit = std::uint64_t{1} &lt;&lt; (kPrecision - 1); 
12418      using bits_type = typename std::conditional&lt;kPrecision == 24, std::uint32_t, std::uint64_t &gt;::type;
12419      const auto bits = static_cast&lt;std::uint64_t&gt;(reinterpret_bits&lt;bits_type&gt;(value));
12420      const std::uint64_t E = bits &gt;&gt; (kPrecision - 1);
12421      const std::uint64_t F = bits &amp; (kHiddenBit - 1);
12422      const bool is_denormal = E == 0;
12423      const diyfp v = is_denormal
12424                      ? diyfp(F, kMinExp)
12425                      : diyfp(F + kHiddenBit, static_cast&lt;int&gt;(E) - kBias);
12426      const bool lower_boundary_is_closer = F == 0 &amp;&amp; E &gt; 1;
12427      const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
12428      const diyfp m_minus = lower_boundary_is_closer
12429                            ? diyfp(4 * v.f - 1, v.e - 2)  
12430                            : diyfp(2 * v.f - 1, v.e - 1); 
12431      const diyfp w_plus = diyfp::normalize(m_plus);
12432      const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);
12433      return {diyfp::normalize(v), w_minus, w_plus};
12434  }
12435  constexpr int kAlpha = -60;
12436  constexpr int kGamma = -32;
12437  struct cached_power 
12438  {
12439      std::uint64_t f;
12440      int e;
12441      int k;
12442  };
12443  inline cached_power get_cached_power_for_binary_exponent(int e)
12444  {
12445      constexpr int kCachedPowersMinDecExp = -300;
12446      constexpr int kCachedPowersDecStep = 8;
12447      static constexpr std::array&lt;cached_power, 79&gt; kCachedPowers =
12448      {
12449          {
12450              { 0xAB70FE17C79AC6CA, -1060, -300 },
12451              { 0xFF77B1FCBEBCDC4F, -1034, -292 },
12452              { 0xBE5691EF416BD60C, -1007, -284 },
12453              { 0x8DD01FAD907FFC3C,  -980, -276 },
12454              { 0xD3515C2831559A83,  -954, -268 },
12455              { 0x9D71AC8FADA6C9B5,  -927, -260 },
12456              { 0xEA9C227723EE8BCB,  -901, -252 },
12457              { 0xAECC49914078536D,  -874, -244 },
12458              { 0x823C12795DB6CE57,  -847, -236 },
12459              { 0xC21094364DFB5637,  -821, -228 },
12460              { 0x9096EA6F3848984F,  -794, -220 },
12461              { 0xD77485CB25823AC7,  -768, -212 },
12462              { 0xA086CFCD97BF97F4,  -741, -204 },
12463              { 0xEF340A98172AACE5,  -715, -196 },
12464              { 0xB23867FB2A35B28E,  -688, -188 },
12465              { 0x84C8D4DFD2C63F3B,  -661, -180 },
12466              { 0xC5DD44271AD3CDBA,  -635, -172 },
12467              { 0x936B9FCEBB25C996,  -608, -164 },
12468              { 0xDBAC6C247D62A584,  -582, -156 },
12469              { 0xA3AB66580D5FDAF6,  -555, -148 },
12470              { 0xF3E2F893DEC3F126,  -529, -140 },
12471              { 0xB5B5ADA8AAFF80B8,  -502, -132 },
12472              { 0x87625F056C7C4A8B,  -475, -124 },
12473              { 0xC9BCFF6034C13053,  -449, -116 },
12474              { 0x964E858C91BA2655,  -422, -108 },
12475              { 0xDFF9772470297EBD,  -396, -100 },
12476              { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
12477              { 0xF8A95FCF88747D94,  -343,  -84 },
12478              { 0xB94470938FA89BCF,  -316,  -76 },
12479              { 0x8A08F0F8BF0F156B,  -289,  -68 },
12480              { 0xCDB02555653131B6,  -263,  -60 },
12481              { 0x993FE2C6D07B7FAC,  -236,  -52 },
12482              { 0xE45C10C42A2B3B06,  -210,  -44 },
12483              { 0xAA242499697392D3,  -183,  -36 },
12484              { 0xFD87B5F28300CA0E,  -157,  -28 },
12485              { 0xBCE5086492111AEB,  -130,  -20 },
12486              { 0x8CBCCC096F5088CC,  -103,  -12 },
12487              { 0xD1B71758E219652C,   -77,   -4 },
12488              { 0x9C40000000000000,   -50,    4 },
12489              { 0xE8D4A51000000000,   -24,   12 },
12490              { 0xAD78EBC5AC620000,     3,   20 },
12491              { 0x813F3978F8940984,    30,   28 },
12492              { 0xC097CE7BC90715B3,    56,   36 },
12493              { 0x8F7E32CE7BEA5C70,    83,   44 },
12494              { 0xD5D238A4ABE98068,   109,   52 },
12495              { 0x9F4F2726179A2245,   136,   60 },
12496              { 0xED63A231D4C4FB27,   162,   68 },
12497              { 0xB0DE65388CC8ADA8,   189,   76 },
12498              { 0x83C7088E1AAB65DB,   216,   84 },
12499              { 0xC45D1DF942711D9A,   242,   92 },
12500              { 0x924D692CA61BE758,   269,  100 },
12501              { 0xDA01EE641A708DEA,   295,  108 },
12502              { 0xA26DA3999AEF774A,   322,  116 },
12503              { 0xF209787BB47D6B85,   348,  124 },
12504              { 0xB454E4A179DD1877,   375,  132 },
12505              { 0x865B86925B9BC5C2,   402,  140 },
12506              { 0xC83553C5C8965D3D,   428,  148 },
12507              { 0x952AB45CFA97A0B3,   455,  156 },
12508              { 0xDE469FBD99A05FE3,   481,  164 },
12509              { 0xA59BC234DB398C25,   508,  172 },
12510              { 0xF6C69A72A3989F5C,   534,  180 },
12511              { 0xB7DCBF5354E9BECE,   561,  188 },
12512              { 0x88FCF317F22241E2,   588,  196 },
12513              { 0xCC20CE9BD35C78A5,   614,  204 },
12514              { 0x98165AF37B2153DF,   641,  212 },
12515              { 0xE2A0B5DC971F303A,   667,  220 },
12516              { 0xA8D9D1535CE3B396,   694,  228 },
12517              { 0xFB9B7CD9A4A7443C,   720,  236 },
12518              { 0xBB764C4CA7A44410,   747,  244 },
12519              { 0x8BAB8EEFB6409C1A,   774,  252 },
12520              { 0xD01FEF10A657842C,   800,  260 },
12521              { 0x9B10A4E5E9913129,   827,  268 },
12522              { 0xE7109BFBA19C0C9D,   853,  276 },
12523              { 0xAC2820D9623BF429,   880,  284 },
12524              { 0x80444B5E7AA7CF85,   907,  292 },
12525              { 0xBF21E44003ACDD2D,   933,  300 },
12526              { 0x8E679C2F5E44FF8F,   960,  308 },
12527              { 0xD433179D9C8CB841,   986,  316 },
12528              { 0x9E19DB92B4E31BA9,  1013,  324 },
12529          }
12530      };
12531      JSON_ASSERT(e &gt;= -1500);
12532      JSON_ASSERT(e &lt;=  1500);
12533      const int f = kAlpha - e - 1;
12534      const int k = (f * 78913) / (1 &lt;&lt; 18) + static_cast&lt;int&gt;(f &gt; 0);
12535      const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
12536      JSON_ASSERT(index &gt;= 0);
12537      JSON_ASSERT(static_cast&lt;std::size_t&gt;(index) &lt; kCachedPowers.size());
12538      const cached_power cached = kCachedPowers[static_cast&lt;std::size_t&gt;(index)];
12539      JSON_ASSERT(kAlpha &lt;= cached.e + e + 64);
12540      JSON_ASSERT(kGamma &gt;= cached.e + e + 64);
12541      return cached;
12542  }
12543  inline int find_largest_pow10(const std::uint32_t n, std::uint32_t&amp; pow10)
12544  {
12545      if (n &gt;= 1000000000)
12546      {
12547          pow10 = 1000000000;
12548          return 10;
12549      }
12550      if (n &gt;= 100000000)
12551      {
12552          pow10 = 100000000;
12553          return  9;
12554      }
12555      if (n &gt;= 10000000)
12556      {
12557          pow10 = 10000000;
12558          return  8;
12559      }
12560      if (n &gt;= 1000000)
12561      {
12562          pow10 = 1000000;
12563          return  7;
12564      }
12565      if (n &gt;= 100000)
12566      {
12567          pow10 = 100000;
12568          return  6;
12569      }
12570      if (n &gt;= 10000)
12571      {
12572          pow10 = 10000;
12573          return  5;
12574      }
12575      if (n &gt;= 1000)
12576      {
12577          pow10 = 1000;
12578          return  4;
12579      }
12580      if (n &gt;= 100)
12581      {
12582          pow10 = 100;
12583          return  3;
12584      }
12585      if (n &gt;= 10)
12586      {
12587          pow10 = 10;
12588          return  2;
12589      }
12590      pow10 = 1;
12591      return 1;
12592  }
12593  inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
12594                           std::uint64_t rest, std::uint64_t ten_k)
12595  {
12596      JSON_ASSERT(len &gt;= 1);
12597      JSON_ASSERT(dist &lt;= delta);
12598      JSON_ASSERT(rest &lt;= delta);
12599      JSON_ASSERT(ten_k &gt; 0);
12600      while (rest &lt; dist
12601              &amp;&amp; delta - rest &gt;= ten_k
12602              &amp;&amp; (rest + ten_k &lt; dist || dist - rest &gt; rest + ten_k - dist))
12603      {
12604          JSON_ASSERT(buf[len - 1] != &#x27;0&#x27;);
12605          buf[len - 1]--;
12606          rest += ten_k;
12607      }
12608  }
12609  inline void grisu2_digit_gen(char* buffer, int&amp; length, int&amp; decimal_exponent,
12610                               diyfp M_minus, diyfp w, diyfp M_plus)
12611  {
12612      static_assert(kAlpha &gt;= -60, &quot;internal error&quot;);
12613      static_assert(kGamma &lt;= -32, &quot;internal error&quot;);
12614      JSON_ASSERT(M_plus.e &gt;= kAlpha);
12615      JSON_ASSERT(M_plus.e &lt;= kGamma);
12616      std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; 
12617      std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; 
12618      const diyfp one(std::uint64_t{1} &lt;&lt; -M_plus.e, M_plus.e);
12619      auto p1 = static_cast&lt;std::uint32_t&gt;(M_plus.f &gt;&gt; -one.e); 
12620      std::uint64_t p2 = M_plus.f &amp; (one.f - 1);                    
12621      JSON_ASSERT(p1 &gt; 0);
12622      std::uint32_t pow10{};
12623      const int k = find_largest_pow10(p1, pow10);
12624      int n = k;
12625      while (n &gt; 0)
12626      {
12627          const std::uint32_t d = p1 / pow10;  
12628          const std::uint32_t r = p1 % pow10;  
12629          JSON_ASSERT(d &lt;= 9);
12630          buffer[length++] = static_cast&lt;char&gt;(&#x27;0&#x27; + d); 
12631          p1 = r;
12632          n--;
12633          const std::uint64_t rest = (std::uint64_t{p1} &lt;&lt; -one.e) + p2;
12634          if (rest &lt;= delta)
12635          {
12636              decimal_exponent += n;
12637              const std::uint64_t ten_n = std::uint64_t{pow10} &lt;&lt; -one.e;
12638              grisu2_round(buffer, length, dist, delta, rest, ten_n);
12639              return;
12640          }
12641          pow10 /= 10;
12642      }
12643      JSON_ASSERT(p2 &gt; delta);
12644      int m = 0;
12645      for (;;)
12646      {
12647          JSON_ASSERT(p2 &lt;= (std::numeric_limits&lt;std::uint64_t&gt;::max)() / 10);
12648          p2 *= 10;
12649          const std::uint64_t d = p2 &gt;&gt; -one.e;     
12650          const std::uint64_t r = p2 &amp; (one.f - 1); 
12651          JSON_ASSERT(d &lt;= 9);
12652          buffer[length++] = static_cast&lt;char&gt;(&#x27;0&#x27; + d); 
12653          p2 = r;
12654          m++;
12655          delta *= 10;
12656          dist  *= 10;
12657          if (p2 &lt;= delta)
12658          {
12659              break;
12660          }
12661      }
12662      decimal_exponent -= m;
12663      const std::uint64_t ten_m = one.f;
12664      grisu2_round(buffer, length, dist, delta, p2, ten_m);
12665  }
12666  JSON_HEDLEY_NON_NULL(1)
12667  inline void grisu2(char* buf, int&amp; len, int&amp; decimal_exponent,
12668                     diyfp m_minus, diyfp v, diyfp m_plus)
12669  {
12670      JSON_ASSERT(m_plus.e == m_minus.e);
12671      JSON_ASSERT(m_plus.e == v.e);
12672      const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);
12673      const diyfp c_minus_k(cached.f, cached.e); 
12674      const diyfp w       = diyfp::mul(v,       c_minus_k);
12675      const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
12676      const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);
12677      const diyfp M_minus(w_minus.f + 1, w_minus.e);
12678      const diyfp M_plus (w_plus.f  - 1, w_plus.e );
12679      decimal_exponent = -cached.k; 
12680      grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
12681  }
12682  template&lt;typename FloatType&gt;
12683  JSON_HEDLEY_NON_NULL(1)
12684  void grisu2(char* buf, int&amp; len, int&amp; decimal_exponent, FloatType value)
12685  {
12686      static_assert(diyfp::kPrecision &gt;= std::numeric_limits&lt;FloatType&gt;::digits + 3,
12687                    &quot;internal error: not enough precision&quot;);
12688      JSON_ASSERT(std::isfinite(value));
12689      JSON_ASSERT(value &gt; 0);
12690  #if 0
12691      const boundaries w = compute_boundaries(static_cast&lt;double&gt;(value));
12692  #else
12693      const boundaries w = compute_boundaries(value);
12694  #endif
12695      grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
12696  }
12697  JSON_HEDLEY_NON_NULL(1)
12698  JSON_HEDLEY_RETURNS_NON_NULL
12699  inline char* append_exponent(char* buf, int e)
12700  {
12701      JSON_ASSERT(e &gt; -1000);
12702      JSON_ASSERT(e &lt;  1000);
12703      if (e &lt; 0)
12704      {
12705          e = -e;
12706          *buf++ = &#x27;-&#x27;;
12707      }
12708      else
12709      {
12710          *buf++ = &#x27;+&#x27;;
12711      }
12712      auto k = static_cast&lt;std::uint32_t&gt;(e);
12713      if (k &lt; 10)
12714      {
12715          *buf++ = &#x27;0&#x27;;
12716          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k);
12717      }
12718      else if (k &lt; 100)
12719      {
12720          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k / 10);
12721          k %= 10;
12722          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k);
12723      }
12724      else
12725      {
12726          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k / 100);
12727          k %= 100;
12728          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k / 10);
12729          k %= 10;
12730          *buf++ = static_cast&lt;char&gt;(&#x27;0&#x27; + k);
12731      }
12732      return buf;
12733  }
12734  JSON_HEDLEY_NON_NULL(1)
12735  JSON_HEDLEY_RETURNS_NON_NULL
12736  inline char* format_buffer(char* buf, int len, int decimal_exponent,
12737                             int min_exp, int max_exp)
12738  {
12739      JSON_ASSERT(min_exp &lt; 0);
12740      JSON_ASSERT(max_exp &gt; 0);
12741      const int k = len;
12742      const int n = len + decimal_exponent;
12743      if (k &lt;= n &amp;&amp; n &lt;= max_exp)
12744      {
12745          std::memset(buf + k, &#x27;0&#x27;, static_cast&lt;size_t&gt;(n) - static_cast&lt;size_t&gt;(k));
12746          buf[n + 0] = &#x27;.&#x27;;
12747          buf[n + 1] = &#x27;0&#x27;;
12748          return buf + (static_cast&lt;size_t&gt;(n) + 2);
12749      }
12750      if (0 &lt; n &amp;&amp; n &lt;= max_exp)
12751      {
12752          JSON_ASSERT(k &gt; n);
12753          std::memmove(buf + (static_cast&lt;size_t&gt;(n) + 1), buf + n, static_cast&lt;size_t&gt;(k) - static_cast&lt;size_t&gt;(n));
12754          buf[n] = &#x27;.&#x27;;
12755          return buf + (static_cast&lt;size_t&gt;(k) + 1U);
12756      }
12757      if (min_exp &lt; n &amp;&amp; n &lt;= 0)
12758      {
12759          std::memmove(buf + (2 + static_cast&lt;size_t&gt;(-n)), buf, static_cast&lt;size_t&gt;(k));
12760          buf[0] = &#x27;0&#x27;;
12761          buf[1] = &#x27;.&#x27;;
12762          std::memset(buf + 2, &#x27;0&#x27;, static_cast&lt;size_t&gt;(-n));
12763          return buf + (2U + static_cast&lt;size_t&gt;(-n) + static_cast&lt;size_t&gt;(k));
12764      }
12765      if (k == 1)
12766      {
12767          buf += 1;
12768      }
12769      else
12770      {
12771          std::memmove(buf + 2, buf + 1, static_cast&lt;size_t&gt;(k) - 1);
12772          buf[1] = &#x27;.&#x27;;
12773          buf += 1 + static_cast&lt;size_t&gt;(k);
12774      }
12775      *buf++ = &#x27;e&#x27;;
12776      return append_exponent(buf, n - 1);
12777  }
12778  }  
12779  template&lt;typename FloatType&gt;
12780  JSON_HEDLEY_NON_NULL(1, 2)
12781  JSON_HEDLEY_RETURNS_NON_NULL
12782  char* to_chars(char* first, const char* last, FloatType value)
12783  {
12784      static_cast&lt;void&gt;(last); 
12785      JSON_ASSERT(std::isfinite(value));
12786      if (std::signbit(value))
12787      {
12788          value = -value;
12789          *first++ = &#x27;-&#x27;;
12790      }
12791  #ifdef __GNUC__
12792  #pragma GCC diagnostic push
12793  #pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;
12794  #endif
12795      if (value == 0) 
12796      {
12797          *first++ = &#x27;0&#x27;;
12798          *first++ = &#x27;.&#x27;;
12799          *first++ = &#x27;0&#x27;;
12800          return first;
12801      }
12802  #ifdef __GNUC__
12803  #pragma GCC diagnostic pop
12804  #endif
12805      JSON_ASSERT(last - first &gt;= std::numeric_limits&lt;FloatType&gt;::max_digits10);
12806      int len = 0;
12807      int decimal_exponent = 0;
12808      dtoa_impl::grisu2(first, len, decimal_exponent, value);
12809      JSON_ASSERT(len &lt;= std::numeric_limits&lt;FloatType&gt;::max_digits10);
12810      constexpr int kMinExp = -4;
12811      constexpr int kMaxExp = std::numeric_limits&lt;FloatType&gt;::digits10;
12812      JSON_ASSERT(last - first &gt;= kMaxExp + 2);
12813      JSON_ASSERT(last - first &gt;= 2 + (-kMinExp - 1) + std::numeric_limits&lt;FloatType&gt;::max_digits10);
12814      JSON_ASSERT(last - first &gt;= std::numeric_limits&lt;FloatType&gt;::max_digits10 + 6);
12815      return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
12816  }
12817  }  
12818  NLOHMANN_JSON_NAMESPACE_END
12819  NLOHMANN_JSON_NAMESPACE_BEGIN
12820  namespace detail
12821  {
12822  enum class error_handler_t
12823  {
12824      strict,  
12825      replace, 
12826      ignore   
12827  };
12828  template&lt;typename BasicJsonType&gt;
12829  class serializer
12830  {
12831      using string_t = typename BasicJsonType::string_t;
12832      using number_float_t = typename BasicJsonType::number_float_t;
12833      using number_integer_t = typename BasicJsonType::number_integer_t;
12834      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
12835      using binary_char_t = typename BasicJsonType::binary_t::value_type;
12836      static constexpr std::uint8_t UTF8_ACCEPT = 0;
12837      static constexpr std::uint8_t UTF8_REJECT = 1;
12838    public:
12839      serializer(output_adapter_t&lt;char&gt; s, const char ichar,
12840                 error_handler_t error_handler_ = error_handler_t::strict)
12841          : o(std::move(s))
12842          , loc(std::localeconv())
12843          , thousands_sep(loc-&gt;thousands_sep == nullptr ? &#x27;\0&#x27; : std::char_traits&lt;char&gt;::to_char_type(* (loc-&gt;thousands_sep)))
12844          , decimal_point(loc-&gt;decimal_point == nullptr ? &#x27;\0&#x27; : std::char_traits&lt;char&gt;::to_char_type(* (loc-&gt;decimal_point)))
12845          , indent_char(ichar)
12846          , indent_string(512, indent_char)
12847          , error_handler(error_handler_)
12848      {}
12849      serializer(const serializer&amp;) = delete;
12850      serializer&amp; operator=(const serializer&amp;) = delete;
12851      serializer(serializer&amp;&amp;) = delete;
12852      serializer&amp; operator=(serializer&amp;&amp;) = delete;
12853      ~serializer() = default;
12854      void dump(const BasicJsonType&amp; val,
12855                const bool pretty_print,
12856                const bool ensure_ascii,
12857                const unsigned int indent_step,
12858                const unsigned int current_indent = 0)
12859      {
12860          switch (val.m_type)
12861          {
12862              case value_t::object:
12863              {
12864                  if (val.m_value.object-&gt;empty())
12865                  {
12866                      o-&gt;write_characters(&quot;{}&quot;, 2);
12867                      return;
12868                  }
12869                  if (pretty_print)
12870                  {
12871                      o-&gt;write_characters(&quot;{\n&quot;, 2);
12872                      const auto new_indent = current_indent + indent_step;
12873                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() &lt; new_indent))
12874                      {
12875                          indent_string.resize(indent_string.size() * 2, &#x27; &#x27;);
12876                      }
12877                      auto i = val.m_value.object-&gt;cbegin();
12878                      for (std::size_t cnt = 0; cnt &lt; val.m_value.object-&gt;size() - 1; ++cnt, ++i)
12879                      {
12880                          o-&gt;write_characters(indent_string.c_str(), new_indent);
12881                          o-&gt;write_character(&#x27;\&quot;&#x27;);
12882                          dump_escaped(i-&gt;first, ensure_ascii);
12883                          o-&gt;write_characters(&quot;\&quot;: &quot;, 3);
12884                          dump(i-&gt;second, true, ensure_ascii, indent_step, new_indent);
12885                          o-&gt;write_characters(&quot;,\n&quot;, 2);
12886                      }
12887                      JSON_ASSERT(i != val.m_value.object-&gt;cend());
12888                      JSON_ASSERT(std::next(i) == val.m_value.object-&gt;cend());
12889                      o-&gt;write_characters(indent_string.c_str(), new_indent);
12890                      o-&gt;write_character(&#x27;\&quot;&#x27;);
12891                      dump_escaped(i-&gt;first, ensure_ascii);
12892                      o-&gt;write_characters(&quot;\&quot;: &quot;, 3);
12893                      dump(i-&gt;second, true, ensure_ascii, indent_step, new_indent);
12894                      o-&gt;write_character(&#x27;\n&#x27;);
12895                      o-&gt;write_characters(indent_string.c_str(), current_indent);
12896                      o-&gt;write_character(&#x27;}&#x27;);
12897                  }
12898                  else
12899                  {
12900                      o-&gt;write_character(&#x27;{&#x27;);
12901                      auto i = val.m_value.object-&gt;cbegin();
12902                      for (std::size_t cnt = 0; cnt &lt; val.m_value.object-&gt;size() - 1; ++cnt, ++i)
12903                      {
12904                          o-&gt;write_character(&#x27;\&quot;&#x27;);
12905                          dump_escaped(i-&gt;first, ensure_ascii);
12906                          o-&gt;write_characters(&quot;\&quot;:&quot;, 2);
12907                          dump(i-&gt;second, false, ensure_ascii, indent_step, current_indent);
12908                          o-&gt;write_character(&#x27;,&#x27;);
12909                      }
12910                      JSON_ASSERT(i != val.m_value.object-&gt;cend());
12911                      JSON_ASSERT(std::next(i) == val.m_value.object-&gt;cend());
12912                      o-&gt;write_character(&#x27;\&quot;&#x27;);
12913                      dump_escaped(i-&gt;first, ensure_ascii);
12914                      o-&gt;write_characters(&quot;\&quot;:&quot;, 2);
12915                      dump(i-&gt;second, false, ensure_ascii, indent_step, current_indent);
12916                      o-&gt;write_character(&#x27;}&#x27;);
12917                  }
12918                  return;
12919              }
12920              case value_t::array:
12921              {
12922                  if (val.m_value.array-&gt;empty())
12923                  {
12924                      o-&gt;write_characters(&quot;[]&quot;, 2);
12925                      return;
12926                  }
12927                  if (pretty_print)
12928                  {
12929                      o-&gt;write_characters(&quot;[\n&quot;, 2);
12930                      const auto new_indent = current_indent + indent_step;
12931                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() &lt; new_indent))
12932                      {
12933                          indent_string.resize(indent_string.size() * 2, &#x27; &#x27;);
12934                      }
12935                      for (auto i = val.m_value.array-&gt;cbegin();
12936                              i != val.m_value.array-&gt;cend() - 1; ++i)
12937                      {
12938                          o-&gt;write_characters(indent_string.c_str(), new_indent);
12939                          dump(*i, true, ensure_ascii, indent_step, new_indent);
12940                          o-&gt;write_characters(&quot;,\n&quot;, 2);
12941                      }
12942                      JSON_ASSERT(!val.m_value.array-&gt;empty());
12943                      o-&gt;write_characters(indent_string.c_str(), new_indent);
12944                      dump(val.m_value.array-&gt;back(), true, ensure_ascii, indent_step, new_indent);
12945                      o-&gt;write_character(&#x27;\n&#x27;);
12946                      o-&gt;write_characters(indent_string.c_str(), current_indent);
12947                      o-&gt;write_character(&#x27;]&#x27;);
12948                  }
12949                  else
12950                  {
12951                      o-&gt;write_character(&#x27;[&#x27;);
12952                      for (auto i = val.m_value.array-&gt;cbegin();
12953                              i != val.m_value.array-&gt;cend() - 1; ++i)
12954                      {
12955                          dump(*i, false, ensure_ascii, indent_step, current_indent);
12956                          o-&gt;write_character(&#x27;,&#x27;);
12957                      }
12958                      JSON_ASSERT(!val.m_value.array-&gt;empty());
12959                      dump(val.m_value.array-&gt;back(), false, ensure_ascii, indent_step, current_indent);
12960                      o-&gt;write_character(&#x27;]&#x27;);
12961                  }
12962                  return;
12963              }
12964              case value_t::string:
12965              {
12966                  o-&gt;write_character(&#x27;\&quot;&#x27;);
12967                  dump_escaped(*val.m_value.string, ensure_ascii);
12968                  o-&gt;write_character(&#x27;\&quot;&#x27;);
12969                  return;
12970              }
12971              case value_t::binary:
12972              {
12973                  if (pretty_print)
12974                  {
12975                      o-&gt;write_characters(&quot;{\n&quot;, 2);
12976                      const auto new_indent = current_indent + indent_step;
12977                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() &lt; new_indent))
12978                      {
12979                          indent_string.resize(indent_string.size() * 2, &#x27; &#x27;);
12980                      }
12981                      o-&gt;write_characters(indent_string.c_str(), new_indent);
12982                      o-&gt;write_characters(&quot;\&quot;bytes\&quot;: [&quot;, 10);
12983                      if (!val.m_value.binary-&gt;empty())
12984                      {
12985                          for (auto i = val.m_value.binary-&gt;cbegin();
12986                                  i != val.m_value.binary-&gt;cend() - 1; ++i)
12987                          {
12988                              dump_integer(*i);
12989                              o-&gt;write_characters(&quot;, &quot;, 2);
12990                          }
12991                          dump_integer(val.m_value.binary-&gt;back());
12992                      }
12993                      o-&gt;write_characters(&quot;],\n&quot;, 3);
12994                      o-&gt;write_characters(indent_string.c_str(), new_indent);
12995                      o-&gt;write_characters(&quot;\&quot;subtype\&quot;: &quot;, 11);
12996                      if (val.m_value.binary-&gt;has_subtype())
12997                      {
12998                          dump_integer(val.m_value.binary-&gt;subtype());
12999                      }
13000                      else
13001                      {
13002                          o-&gt;write_characters(&quot;null&quot;, 4);
13003                      }
13004                      o-&gt;write_character(&#x27;\n&#x27;);
13005                      o-&gt;write_characters(indent_string.c_str(), current_indent);
13006                      o-&gt;write_character(&#x27;}&#x27;);
13007                  }
13008                  else
13009                  {
13010                      o-&gt;write_characters(&quot;{\&quot;bytes\&quot;:[&quot;, 10);
13011                      if (!val.m_value.binary-&gt;empty())
13012                      {
13013                          for (auto i = val.m_value.binary-&gt;cbegin();
13014                                  i != val.m_value.binary-&gt;cend() - 1; ++i)
13015                          {
13016                              dump_integer(*i);
13017                              o-&gt;write_character(&#x27;,&#x27;);
13018                          }
13019                          dump_integer(val.m_value.binary-&gt;back());
13020                      }
13021                      o-&gt;write_characters(&quot;],\&quot;subtype\&quot;:&quot;, 12);
13022                      if (val.m_value.binary-&gt;has_subtype())
13023                      {
13024                          dump_integer(val.m_value.binary-&gt;subtype());
13025                          o-&gt;write_character(&#x27;}&#x27;);
13026                      }
13027                      else
13028                      {
13029                          o-&gt;write_characters(&quot;null}&quot;, 5);
13030                      }
13031                  }
13032                  return;
13033              }
13034              case value_t::boolean:
13035              {
13036                  if (val.m_value.boolean)
13037                  {
13038                      o-&gt;write_characters(&quot;true&quot;, 4);
13039                  }
13040                  else
13041                  {
13042                      o-&gt;write_characters(&quot;false&quot;, 5);
13043                  }
13044                  return;
13045              }
13046              case value_t::number_integer:
13047              {
13048                  dump_integer(val.m_value.number_integer);
13049                  return;
13050              }
13051              case value_t::number_unsigned:
13052              {
13053                  dump_integer(val.m_value.number_unsigned);
13054                  return;
13055              }
13056              case value_t::number_float:
13057              {
13058                  dump_float(val.m_value.number_float);
13059                  return;
13060              }
13061              case value_t::discarded:
13062              {
13063                  o-&gt;write_characters(&quot;&lt;discarded&gt;&quot;, 11);
13064                  return;
13065              }
13066              case value_t::null:
13067              {
13068                  o-&gt;write_characters(&quot;null&quot;, 4);
13069                  return;
13070              }
13071              default:            
13072                  JSON_ASSERT(false); 
13073          }
13074      }
13075    JSON_PRIVATE_UNLESS_TESTED:
13076      void dump_escaped(const string_t&amp; s, const bool ensure_ascii)
13077      {
13078          std::uint32_t codepoint{};
13079          std::uint8_t state = UTF8_ACCEPT;
13080          std::size_t bytes = 0;  
13081          std::size_t bytes_after_last_accept = 0;
13082          std::size_t undumped_chars = 0;
13083          for (std::size_t i = 0; i &lt; s.size(); ++i)
13084          {
13085              const auto byte = static_cast&lt;std::uint8_t&gt;(s[i]);
13086              switch (decode(state, codepoint, byte))
13087              {
13088                  case UTF8_ACCEPT:  
13089                  {
13090                      switch (codepoint)
13091                      {
13092                          case 0x08: 
13093                          {
13094                              string_buffer[bytes++] = &#x27;\\&#x27;;
13095                              string_buffer[bytes++] = &#x27;b&#x27;;
13096                              break;
13097                          }
13098                          case 0x09: 
13099                          {
13100                              string_buffer[bytes++] = &#x27;\\&#x27;;
13101                              string_buffer[bytes++] = &#x27;t&#x27;;
13102                              break;
13103                          }
13104                          case 0x0A: 
13105                          {
13106                              string_buffer[bytes++] = &#x27;\\&#x27;;
13107                              string_buffer[bytes++] = &#x27;n&#x27;;
13108                              break;
13109                          }
13110                          case 0x0C: 
13111                          {
13112                              string_buffer[bytes++] = &#x27;\\&#x27;;
13113                              string_buffer[bytes++] = &#x27;f&#x27;;
13114                              break;
13115                          }
13116                          case 0x0D: 
13117                          {
13118                              string_buffer[bytes++] = &#x27;\\&#x27;;
13119                              string_buffer[bytes++] = &#x27;r&#x27;;
13120                              break;
13121                          }
13122                          case 0x22: 
13123                          {
13124                              string_buffer[bytes++] = &#x27;\\&#x27;;
13125                              string_buffer[bytes++] = &#x27;\&quot;&#x27;;
13126                              break;
13127                          }
13128                          case 0x5C: 
13129                          {
13130                              string_buffer[bytes++] = &#x27;\\&#x27;;
13131                              string_buffer[bytes++] = &#x27;\\&#x27;;
13132                              break;
13133                          }
13134                          default:
13135                          {
13136                              if ((codepoint &lt;= 0x1F) || (ensure_ascii &amp;&amp; (codepoint &gt;= 0x7F)))
13137                              {
13138                                  if (codepoint &lt;= 0xFFFF)
13139                                  {
13140                                      static_cast&lt;void&gt;((std::snprintf)(string_buffer.data() + bytes, 7, &quot;\\u%04x&quot;,
13141                                                                        static_cast&lt;std::uint16_t&gt;(codepoint)));
13142                                      bytes += 6;
13143                                  }
13144                                  else
13145                                  {
13146                                      static_cast&lt;void&gt;((std::snprintf)(string_buffer.data() + bytes, 13, &quot;\\u%04x\\u%04x&quot;,
13147                                                                        static_cast&lt;std::uint16_t&gt;(0xD7C0u + (codepoint &gt;&gt; 10u)),
13148                                                                        static_cast&lt;std::uint16_t&gt;(0xDC00u + (codepoint &amp; 0x3FFu))));
13149                                      bytes += 12;
13150                                  }
13151                              }
13152                              else
13153                              {
13154                                  string_buffer[bytes++] = s[i];
13155                              }
13156                              break;
13157                          }
13158                      }
13159                      if (string_buffer.size() - bytes &lt; 13)
13160                      {
13161                          o-&gt;write_characters(string_buffer.data(), bytes);
13162                          bytes = 0;
13163                      }
13164                      bytes_after_last_accept = bytes;
13165                      undumped_chars = 0;
13166                      break;
13167                  }
13168                  case UTF8_REJECT:  
13169                  {
13170                      switch (error_handler)
13171                      {
13172                          case error_handler_t::strict:
13173                          {
13174                              JSON_THROW(type_error::create(316, concat(&quot;invalid UTF-8 byte at index &quot;, std::to_string(i), &quot;: 0x&quot;, hex_bytes(byte | 0)), nullptr));
13175                          }
13176                          case error_handler_t::ignore:
13177                          case error_handler_t::replace:
13178                          {
13179                              if (undumped_chars &gt; 0)
13180                              {
13181                                  --i;
13182                              }
13183                              bytes = bytes_after_last_accept;
13184                              if (error_handler == error_handler_t::replace)
13185                              {
13186                                  if (ensure_ascii)
13187                                  {
13188                                      string_buffer[bytes++] = &#x27;\\&#x27;;
13189                                      string_buffer[bytes++] = &#x27;u&#x27;;
13190                                      string_buffer[bytes++] = &#x27;f&#x27;;
13191                                      string_buffer[bytes++] = &#x27;f&#x27;;
13192                                      string_buffer[bytes++] = &#x27;f&#x27;;
13193                                      string_buffer[bytes++] = &#x27;d&#x27;;
13194                                  }
13195                                  else
13196                                  {
13197                                      string_buffer[bytes++] = detail::binary_writer&lt;BasicJsonType, char&gt;::to_char_type(&#x27;\xEF&#x27;);
13198                                      string_buffer[bytes++] = detail::binary_writer&lt;BasicJsonType, char&gt;::to_char_type(&#x27;\xBF&#x27;);
13199                                      string_buffer[bytes++] = detail::binary_writer&lt;BasicJsonType, char&gt;::to_char_type(&#x27;\xBD&#x27;);
13200                                  }
13201                                  if (string_buffer.size() - bytes &lt; 13)
13202                                  {
13203                                      o-&gt;write_characters(string_buffer.data(), bytes);
13204                                      bytes = 0;
13205                                  }
13206                                  bytes_after_last_accept = bytes;
13207                              }
13208                              undumped_chars = 0;
13209                              state = UTF8_ACCEPT;
13210                              break;
13211                          }
13212                          default:            
13213                              JSON_ASSERT(false); 
13214                      }
13215                      break;
13216                  }
13217                  default:  
13218                  {
13219                      if (!ensure_ascii)
13220                      {
13221                          string_buffer[bytes++] = s[i];
13222                      }
13223                      ++undumped_chars;
13224                      break;
13225                  }
13226              }
13227          }
13228          if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
13229          {
13230              if (bytes &gt; 0)
13231              {
13232                  o-&gt;write_characters(string_buffer.data(), bytes);
13233              }
13234          }
13235          else
13236          {
13237              switch (error_handler)
13238              {
13239                  case error_handler_t::strict:
13240                  {
13241                      JSON_THROW(type_error::create(316, concat(&quot;incomplete UTF-8 string; last byte: 0x&quot;, hex_bytes(static_cast&lt;std::uint8_t&gt;(s.back() | 0))), nullptr));
13242                  }
13243                  case error_handler_t::ignore:
13244                  {
13245                      o-&gt;write_characters(string_buffer.data(), bytes_after_last_accept);
13246                      break;
13247                  }
13248                  case error_handler_t::replace:
13249                  {
13250                      o-&gt;write_characters(string_buffer.data(), bytes_after_last_accept);
13251                      if (ensure_ascii)
13252                      {
13253                          o-&gt;write_characters(&quot;\\ufffd&quot;, 6);
13254                      }
13255                      else
13256                      {
13257                          o-&gt;write_characters(&quot;\xEF\xBF\xBD&quot;, 3);
13258                      }
13259                      break;
13260                  }
13261                  default:            
13262                      JSON_ASSERT(false); 
13263              }
13264          }
13265      }
13266    private:
13267      inline unsigned int count_digits(number_unsigned_t x) noexcept
13268      {
13269          unsigned int n_digits = 1;
13270          for (;;)
13271          {
13272              if (x &lt; 10)
13273              {
13274                  return n_digits;
13275              }
13276              if (x &lt; 100)
13277              {
13278                  return n_digits + 1;
13279              }
13280              if (x &lt; 1000)
13281              {
13282                  return n_digits + 2;
13283              }
13284              if (x &lt; 10000)
13285              {
13286                  return n_digits + 3;
13287              }
13288              x = x / 10000u;
13289              n_digits += 4;
13290          }
13291      }
13292      static std::string hex_bytes(std::uint8_t byte)
13293      {
13294          std::string result = &quot;FF&quot;;
13295          constexpr const char* nibble_to_hex = &quot;0123456789ABCDEF&quot;;
13296          result[0] = nibble_to_hex[byte / 16];
13297          result[1] = nibble_to_hex[byte % 16];
13298          return result;
13299      }
13300      template &lt;typename NumberType, enable_if_t&lt;std::is_signed&lt;NumberType&gt;::value, int&gt; = 0&gt;
13301      bool is_negative_number(NumberType x)
13302      {
13303          return x &lt; 0;
13304      }
13305      template &lt; typename NumberType, enable_if_t &lt;std::is_unsigned&lt;NumberType&gt;::value, int &gt; = 0 &gt;
13306      bool is_negative_number(NumberType &amp;bsol;*unused*/)
13307      {
13308          return false;
13309      }
13310      template &lt; typename NumberType, detail::enable_if_t &lt;
13311                     std::is_integral&lt;NumberType&gt;::value ||
13312                     std::is_same&lt;NumberType, number_unsigned_t&gt;::value ||
13313                     std::is_same&lt;NumberType, number_integer_t&gt;::value ||
13314                     std::is_same&lt;NumberType, binary_char_t&gt;::value,
13315                     int &gt; = 0 &gt;
13316      void dump_integer(NumberType x)
13317      {
13318          static constexpr std::array&lt;std::array&lt;char, 2&gt;, 100&gt; digits_to_99
13319          {
13320              {
13321                  {{&#x27;0&#x27;, &#x27;0&#x27;}}, {{&#x27;0&#x27;, &#x27;1&#x27;}}, {{&#x27;0&#x27;, &#x27;2&#x27;}}, {{&#x27;0&#x27;, &#x27;3&#x27;}}, {{&#x27;0&#x27;, &#x27;4&#x27;}}, {{&#x27;0&#x27;, &#x27;5&#x27;}}, {{&#x27;0&#x27;, &#x27;6&#x27;}}, {{&#x27;0&#x27;, &#x27;7&#x27;}}, {{&#x27;0&#x27;, &#x27;8&#x27;}}, {{&#x27;0&#x27;, &#x27;9&#x27;}},
13322                  {{&#x27;1&#x27;, &#x27;0&#x27;}}, {{&#x27;1&#x27;, &#x27;1&#x27;}}, {{&#x27;1&#x27;, &#x27;2&#x27;}}, {{&#x27;1&#x27;, &#x27;3&#x27;}}, {{&#x27;1&#x27;, &#x27;4&#x27;}}, {{&#x27;1&#x27;, &#x27;5&#x27;}}, {{&#x27;1&#x27;, &#x27;6&#x27;}}, {{&#x27;1&#x27;, &#x27;7&#x27;}}, {{&#x27;1&#x27;, &#x27;8&#x27;}}, {{&#x27;1&#x27;, &#x27;9&#x27;}},
13323                  {{&#x27;2&#x27;, &#x27;0&#x27;}}, {{&#x27;2&#x27;, &#x27;1&#x27;}}, {{&#x27;2&#x27;, &#x27;2&#x27;}}, {{&#x27;2&#x27;, &#x27;3&#x27;}}, {{&#x27;2&#x27;, &#x27;4&#x27;}}, {{&#x27;2&#x27;, &#x27;5&#x27;}}, {{&#x27;2&#x27;, &#x27;6&#x27;}}, {{&#x27;2&#x27;, &#x27;7&#x27;}}, {{&#x27;2&#x27;, &#x27;8&#x27;}}, {{&#x27;2&#x27;, &#x27;9&#x27;}},
13324                  {{&#x27;3&#x27;, &#x27;0&#x27;}}, {{&#x27;3&#x27;, &#x27;1&#x27;}}, {{&#x27;3&#x27;, &#x27;2&#x27;}}, {{&#x27;3&#x27;, &#x27;3&#x27;}}, {{&#x27;3&#x27;, &#x27;4&#x27;}}, {{&#x27;3&#x27;, &#x27;5&#x27;}}, {{&#x27;3&#x27;, &#x27;6&#x27;}}, {{&#x27;3&#x27;, &#x27;7&#x27;}}, {{&#x27;3&#x27;, &#x27;8&#x27;}}, {{&#x27;3&#x27;, &#x27;9&#x27;}},
13325                  {{&#x27;4&#x27;, &#x27;0&#x27;}}, {{&#x27;4&#x27;, &#x27;1&#x27;}}, {{&#x27;4&#x27;, &#x27;2&#x27;}}, {{&#x27;4&#x27;, &#x27;3&#x27;}}, {{&#x27;4&#x27;, &#x27;4&#x27;}}, {{&#x27;4&#x27;, &#x27;5&#x27;}}, {{&#x27;4&#x27;, &#x27;6&#x27;}}, {{&#x27;4&#x27;, &#x27;7&#x27;}}, {{&#x27;4&#x27;, &#x27;8&#x27;}}, {{&#x27;4&#x27;, &#x27;9&#x27;}},
13326                  {{&#x27;5&#x27;, &#x27;0&#x27;}}, {{&#x27;5&#x27;, &#x27;1&#x27;}}, {{&#x27;5&#x27;, &#x27;2&#x27;}}, {{&#x27;5&#x27;, &#x27;3&#x27;}}, {{&#x27;5&#x27;, &#x27;4&#x27;}}, {{&#x27;5&#x27;, &#x27;5&#x27;}}, {{&#x27;5&#x27;, &#x27;6&#x27;}}, {{&#x27;5&#x27;, &#x27;7&#x27;}}, {{&#x27;5&#x27;, &#x27;8&#x27;}}, {{&#x27;5&#x27;, &#x27;9&#x27;}},
13327                  {{&#x27;6&#x27;, &#x27;0&#x27;}}, {{&#x27;6&#x27;, &#x27;1&#x27;}}, {{&#x27;6&#x27;, &#x27;2&#x27;}}, {{&#x27;6&#x27;, &#x27;3&#x27;}}, {{&#x27;6&#x27;, &#x27;4&#x27;}}, {{&#x27;6&#x27;, &#x27;5&#x27;}}, {{&#x27;6&#x27;, &#x27;6&#x27;}}, {{&#x27;6&#x27;, &#x27;7&#x27;}}, {{&#x27;6&#x27;, &#x27;8&#x27;}}, {{&#x27;6&#x27;, &#x27;9&#x27;}},
13328                  {{&#x27;7&#x27;, &#x27;0&#x27;}}, {{&#x27;7&#x27;, &#x27;1&#x27;}}, {{&#x27;7&#x27;, &#x27;2&#x27;}}, {{&#x27;7&#x27;, &#x27;3&#x27;}}, {{&#x27;7&#x27;, &#x27;4&#x27;}}, {{&#x27;7&#x27;, &#x27;5&#x27;}}, {{&#x27;7&#x27;, &#x27;6&#x27;}}, {{&#x27;7&#x27;, &#x27;7&#x27;}}, {{&#x27;7&#x27;, &#x27;8&#x27;}}, {{&#x27;7&#x27;, &#x27;9&#x27;}},
13329                  {{&#x27;8&#x27;, &#x27;0&#x27;}}, {{&#x27;8&#x27;, &#x27;1&#x27;}}, {{&#x27;8&#x27;, &#x27;2&#x27;}}, {{&#x27;8&#x27;, &#x27;3&#x27;}}, {{&#x27;8&#x27;, &#x27;4&#x27;}}, {{&#x27;8&#x27;, &#x27;5&#x27;}}, {{&#x27;8&#x27;, &#x27;6&#x27;}}, {{&#x27;8&#x27;, &#x27;7&#x27;}}, {{&#x27;8&#x27;, &#x27;8&#x27;}}, {{&#x27;8&#x27;, &#x27;9&#x27;}},
13330                  {{&#x27;9&#x27;, &#x27;0&#x27;}}, {{&#x27;9&#x27;, &#x27;1&#x27;}}, {{&#x27;9&#x27;, &#x27;2&#x27;}}, {{&#x27;9&#x27;, &#x27;3&#x27;}}, {{&#x27;9&#x27;, &#x27;4&#x27;}}, {{&#x27;9&#x27;, &#x27;5&#x27;}}, {{&#x27;9&#x27;, &#x27;6&#x27;}}, {{&#x27;9&#x27;, &#x27;7&#x27;}}, {{&#x27;9&#x27;, &#x27;8&#x27;}}, {{&#x27;9&#x27;, &#x27;9&#x27;}},
13331              }
13332          };
13333          if (x == 0)
13334          {
13335              o-&gt;write_character(&#x27;0&#x27;);
13336              return;
13337          }
13338          auto buffer_ptr = number_buffer.begin(); 
13339          number_unsigned_t abs_value;
13340          unsigned int n_chars{};
13341          if (is_negative_number(x))
13342          {
13343              *buffer_ptr = &#x27;-&#x27;;
13344              abs_value = remove_sign(static_cast&lt;number_integer_t&gt;(x));
13345              n_chars = 1 + count_digits(abs_value);
13346          }
13347          else
13348          {
13349              abs_value = static_cast&lt;number_unsigned_t&gt;(x);
13350              n_chars = count_digits(abs_value);
13351          }
13352          JSON_ASSERT(n_chars &lt; number_buffer.size() - 1);
13353          buffer_ptr += n_chars;
13354          while (abs_value &gt;= 100)
13355          {
13356              const auto digits_index = static_cast&lt;unsigned&gt;((abs_value % 100));
13357              abs_value /= 100;
13358              *(--buffer_ptr) = digits_to_99[digits_index][1];
13359              *(--buffer_ptr) = digits_to_99[digits_index][0];
13360          }
13361          if (abs_value &gt;= 10)
13362          {
13363              const auto digits_index = static_cast&lt;unsigned&gt;(abs_value);
13364              *(--buffer_ptr) = digits_to_99[digits_index][1];
13365              *(--buffer_ptr) = digits_to_99[digits_index][0];
13366          }
13367          else
13368          {
13369              *(--buffer_ptr) = static_cast&lt;char&gt;(&#x27;0&#x27; + abs_value);
13370          }
13371          o-&gt;write_characters(number_buffer.data(), n_chars);
13372      }
13373      void dump_float(number_float_t x)
13374      {
13375          if (!std::isfinite(x))
13376          {
13377              o-&gt;write_characters(&quot;null&quot;, 4);
13378              return;
13379          }
13380          static constexpr bool is_ieee_single_or_double
13381              = (std::numeric_limits&lt;number_float_t&gt;::is_iec559 &amp;&amp; std::numeric_limits&lt;number_float_t&gt;::digits == 24 &amp;&amp; std::numeric_limits&lt;number_float_t&gt;::max_exponent == 128) ||
13382                (std::numeric_limits&lt;number_float_t&gt;::is_iec559 &amp;&amp; std::numeric_limits&lt;number_float_t&gt;::digits == 53 &amp;&amp; std::numeric_limits&lt;number_float_t&gt;::max_exponent == 1024);
13383          dump_float(x, std::integral_constant&lt;bool, is_ieee_single_or_double&gt;());
13384      }
13385      void dump_float(number_float_t x, std::true_type &amp;bsol;*is_ieee_single_or_double*/)
13386      {
13387          auto* begin = number_buffer.data();
13388          auto* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);
13389          o-&gt;write_characters(begin, static_cast&lt;size_t&gt;(end - begin));
13390      }
13391      void dump_float(number_float_t x, std::false_type &amp;bsol;*is_ieee_single_or_double*/)
13392      {
13393          static constexpr auto d = std::numeric_limits&lt;number_float_t&gt;::max_digits10;
13394          std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), &quot;%.*g&quot;, d, x);
13395          JSON_ASSERT(len &gt; 0);
13396          JSON_ASSERT(static_cast&lt;std::size_t&gt;(len) &lt; number_buffer.size());
13397          if (thousands_sep != &#x27;\0&#x27;)
13398          {
13399              const auto end = std::remove(number_buffer.begin(), number_buffer.begin() + len, thousands_sep);
13400              std::fill(end, number_buffer.end(), &#x27;\0&#x27;);
13401              JSON_ASSERT((end - number_buffer.begin()) &lt;= len);
13402              len = (end - number_buffer.begin());
13403          }
13404          if (decimal_point != &#x27;\0&#x27; &amp;&amp; decimal_point != &#x27;.&#x27;)
13405          {
13406              const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
13407              if (dec_pos != number_buffer.end())
13408              {
13409                  *dec_pos = &#x27;.&#x27;;
13410              }
13411          }
13412          o-&gt;write_characters(number_buffer.data(), static_cast&lt;std::size_t&gt;(len));
13413          const bool value_is_int_like =
13414              std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
13415                           [](char c)
13416          {
13417              return c == &#x27;.&#x27; || c == &#x27;e&#x27;;
13418          });
13419          if (value_is_int_like)
13420          {
13421              o-&gt;write_characters(&quot;.0&quot;, 2);
13422          }
13423      }
13424      static std::uint8_t decode(std::uint8_t&amp; state, std::uint32_t&amp; codep, const std::uint8_t byte) noexcept
13425      {
13426          static const std::array&lt;std::uint8_t, 400&gt; utf8d =
13427          {
13428              {
13429                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
13430                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
13431                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
13432                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
13433                  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
13434                  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
13435                  8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
13436                  0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, 
13437                  0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 
13438                  0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, 
13439                  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 
13440                  1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 
13441                  1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 
13442                  1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 
13443              }
13444          };
13445          JSON_ASSERT(byte &lt; utf8d.size());
13446          const std::uint8_t type = utf8d[byte];
13447          codep = (state != UTF8_ACCEPT)
13448                  ? (byte &amp; 0x3fu) | (codep &lt;&lt; 6u)
13449                  : (0xFFu &gt;&gt; type) &amp; (byte);
13450          std::size_t index = 256u + static_cast&lt;size_t&gt;(state) * 16u + static_cast&lt;size_t&gt;(type);
13451          JSON_ASSERT(index &lt; 400);
13452          state = utf8d[index];
13453          return state;
13454      }
13455      number_unsigned_t remove_sign(number_unsigned_t x)
13456      {
13457          JSON_ASSERT(false); 
13458          return x; 
13459      }
13460      inline number_unsigned_t remove_sign(number_integer_t x) noexcept
13461      {
13462          JSON_ASSERT(x &lt; 0 &amp;&amp; x &lt; (std::numeric_limits&lt;number_integer_t&gt;::max)()); 
13463          return static_cast&lt;number_unsigned_t&gt;(-(x + 1)) + 1;
13464      }
13465    private:
13466      output_adapter_t&lt;char&gt; o = nullptr;
13467      std::array&lt;char, 64&gt; number_buffer{{}};
13468      const std::lconv* loc = nullptr;
13469      const char thousands_sep = &#x27;\0&#x27;;
13470      const char decimal_point = &#x27;\0&#x27;;
13471      std::array&lt;char, 512&gt; string_buffer{{}};
13472      const char indent_char;
13473      string_t indent_string;
13474      const error_handler_t error_handler;
13475  };
13476  }  
13477  NLOHMANN_JSON_NAMESPACE_END
13478  #include &lt;functional&gt; 
13479  #include &lt;initializer_list&gt; 
13480  #include &lt;iterator&gt; 
13481  #include &lt;memory&gt; 
13482  #include &lt;stdexcept&gt; 
13483  #include &lt;type_traits&gt; 
13484  #include &lt;utility&gt; 
13485  #include &lt;vector&gt; 
13486  NLOHMANN_JSON_NAMESPACE_BEGIN
13487  template &lt;class Key, class T, class IgnoredLess = std::less&lt;Key&gt;,
13488            class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
13489                    struct ordered_map : std::vector&lt;std::pair&lt;const Key, T&gt;, Allocator&gt;
13490  {
13491      using key_type = Key;
13492      using mapped_type = T;
13493      using Container = std::vector&lt;std::pair&lt;const Key, T&gt;, Allocator&gt;;
13494      using iterator = typename Container::iterator;
13495      using const_iterator = typename Container::const_iterator;
13496      using size_type = typename Container::size_type;
13497      using value_type = typename Container::value_type;
13498  #ifdef JSON_HAS_CPP_14
13499      using key_compare = std::equal_to&lt;&gt;;
13500  #else
13501      using key_compare = std::equal_to&lt;Key&gt;;
13502  #endif
13503      ordered_map() noexcept(noexcept(Container())) : Container{} {}
13504      explicit ordered_map(const Allocator&amp; alloc) noexcept(noexcept(Container(alloc))) : Container{alloc} {}
13505      template &lt;class It&gt;
13506      ordered_map(It first, It last, const Allocator&amp; alloc = Allocator())
13507          : Container{first, last, alloc} {}
13508      ordered_map(std::initializer_list&lt;value_type&gt; init, const Allocator&amp; alloc = Allocator() )
13509          : Container{init, alloc} {}
13510      std::pair&lt;iterator, bool&gt; emplace(const key_type&amp; key, T&amp;&amp; t)
13511      {
13512          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13513          {
13514              if (m_compare(it-&gt;first, key))
13515              {
13516                  return {it, false};
13517              }
13518          }
13519          Container::emplace_back(key, std::forward&lt;T&gt;(t));
13520          return {std::prev(this-&gt;end()), true};
13521      }
13522      template&lt;class KeyType, detail::enable_if_t&lt;
13523                   detail::is_usable_as_key_type&lt;key_compare, key_type, KeyType&gt;::value, int&gt; = 0&gt;
13524      std::pair&lt;iterator, bool&gt; emplace(KeyType &amp;&amp; key, T &amp;&amp; t)
13525      {
13526          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13527          {
13528              if (m_compare(it-&gt;first, key))
13529              {
13530                  return {it, false};
13531              }
13532          }
13533          Container::emplace_back(std::forward&lt;KeyType&gt;(key), std::forward&lt;T&gt;(t));
13534          return {std::prev(this-&gt;end()), true};
13535      }
13536      T&amp; operator[](const key_type&amp; key)
13537      {
13538          return emplace(key, T{}).first-&gt;second;
13539      }
13540      template&lt;class KeyType, detail::enable_if_t&lt;
13541                   detail::is_usable_as_key_type&lt;key_compare, key_type, KeyType&gt;::value, int&gt; = 0&gt;
13542      T &amp; operator[](KeyType &amp;&amp; key)
13543      {
13544          return emplace(std::forward&lt;KeyType&gt;(key), T{}).first-&gt;second;
13545      }
13546      const T&amp; operator[](const key_type&amp; key) const
13547      {
13548          return at(key);
13549      }
13550      template&lt;class KeyType, detail::enable_if_t&lt;
13551                   detail::is_usable_as_key_type&lt;key_compare, key_type, KeyType&gt;::value, int&gt; = 0&gt;
13552      const T &amp; operator[](KeyType &amp;&amp; key) const
13553      {
13554          return at(std::forward&lt;KeyType&gt;(key));
13555      }
13556      T&amp; at(const key_type&amp; key)
13557      {
13558          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13559          {
13560              if (m_compare(it-&gt;first, key))
13561              {
13562                  return it-&gt;second;
13563              }
13564          }
13565          JSON_THROW(std::out_of_range(&quot;key not found&quot;));
13566      }
13567      template&lt;class KeyType, detail::enable_if_t&lt;
13568                   detail::is_usable_as_key_type&lt;key_compare, key_type, KeyType&gt;::value, int&gt; = 0&gt;
13569      T &amp; at(KeyType &amp;&amp; key)
13570      {
13571          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13572          {
13573              if (m_compare(it-&gt;first, key))
13574              {
13575                  return it-&gt;second;
13576              }
13577          }
13578          JSON_THROW(std::out_of_range(&quot;key not found&quot;));
13579      }
13580      const T&amp; at(const key_type&amp; key) const
13581      {
13582          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13583          {
13584              if (m_compare(it-&gt;first, key))
13585              {
13586                  return it-&gt;second;
13587              }
13588          }
13589          JSON_THROW(std::out_of_range(&quot;key not found&quot;));
13590      }
13591      template&lt;class KeyType, detail::enable_if_t&lt;
13592                   detail::is_usable_as_key_type&lt;key_compare, key_type, KeyType&gt;::value, int&gt; = 0&gt;
13593      const T &amp; at(KeyType &amp;&amp; key) const
13594      {
13595          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13596          {
13597              if (m_compare(it-&gt;first, key))
13598              {
13599                  return it-&gt;second;
13600              }
13601          }
13602          JSON_THROW(std::out_of_range(&quot;key not found&quot;));
13603      }
13604      size_type erase(const key_type&amp; key)
13605      {
13606          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13607          {
13608              if (m_compare(it-&gt;first, key))
13609              {
13610                  for (auto next = it; ++next != this-&gt;end(); ++it)
13611                  {
13612                      it-&gt;~value_type(); 
13613                      new (&amp;*it) value_type{std::move(*next)};
13614                  }
13615                  Container::pop_back();
13616                  return 1;
13617              }
13618          }
13619          return 0;
13620      }
13621      template&lt;class KeyType, detail::enable_if_t&lt;
13622                   detail::is_usable_as_key_type&lt;key_compare, key_type, KeyType&gt;::value, int&gt; = 0&gt;
13623      size_type erase(KeyType &amp;&amp; key)
13624      {
13625          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13626          {
13627              if (m_compare(it-&gt;first, key))
13628              {
13629                  for (auto next = it; ++next != this-&gt;end(); ++it)
13630                  {
13631                      it-&gt;~value_type(); 
13632                      new (&amp;*it) value_type{std::move(*next)};
13633                  }
13634                  Container::pop_back();
13635                  return 1;
13636              }
13637          }
13638          return 0;
13639      }
13640      iterator erase(iterator pos)
13641      {
13642          return erase(pos, std::next(pos));
13643      }
13644      iterator erase(iterator first, iterator last)
13645      {
13646          if (first == last)
13647          {
13648              return first;
13649          }
13650          const auto elements_affected = std::distance(first, last);
13651          const auto offset = std::distance(Container::begin(), first);
13652          for (auto it = first; std::next(it, elements_affected) != Container::end(); ++it)
13653          {
13654              it-&gt;~value_type(); 
13655              new (&amp;*it) value_type{std::move(*std::next(it, elements_affected))}; 
13656          }
13657          Container::resize(this-&gt;size() - static_cast&lt;size_type&gt;(elements_affected));
13658          return Container::begin() + offset;
13659      }
13660      size_type count(const key_type&amp; key) const
13661      {
13662          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13663          {
13664              if (m_compare(it-&gt;first, key))
13665              {
13666                  return 1;
13667              }
13668          }
13669          return 0;
13670      }
13671      template&lt;class KeyType, detail::enable_if_t&lt;
13672                   detail::is_usable_as_key_type&lt;key_compare, key_type, KeyType&gt;::value, int&gt; = 0&gt;
13673      size_type count(KeyType &amp;&amp; key) const
13674      {
13675          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13676          {
13677              if (m_compare(it-&gt;first, key))
13678              {
13679                  return 1;
13680              }
13681          }
13682          return 0;
13683      }
13684      iterator find(const key_type&amp; key)
13685      {
13686          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13687          {
13688              if (m_compare(it-&gt;first, key))
13689              {
13690                  return it;
13691              }
13692          }
13693          return Container::end();
13694      }
13695      template&lt;class KeyType, detail::enable_if_t&lt;
13696                   detail::is_usable_as_key_type&lt;key_compare, key_type, KeyType&gt;::value, int&gt; = 0&gt;
13697      iterator find(KeyType &amp;&amp; key)
13698      {
13699          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13700          {
13701              if (m_compare(it-&gt;first, key))
13702              {
13703                  return it;
13704              }
13705          }
13706          return Container::end();
13707      }
13708      const_iterator find(const key_type&amp; key) const
13709      {
13710          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13711          {
13712              if (m_compare(it-&gt;first, key))
13713              {
13714                  return it;
13715              }
13716          }
13717          return Container::end();
13718      }
13719      std::pair&lt;iterator, bool&gt; insert( value_type&amp;&amp; value )
13720      {
13721          return emplace(value.first, std::move(value.second));
13722      }
13723      std::pair&lt;iterator, bool&gt; insert( const value_type&amp; value )
13724      {
13725          for (auto it = this-&gt;begin(); it != this-&gt;end(); ++it)
13726          {
13727              if (m_compare(it-&gt;first, value.first))
13728              {
13729                  return {it, false};
13730              }
13731          }
13732          Container::push_back(value);
13733          return {--this-&gt;end(), true};
13734      }
13735      template&lt;typename InputIt&gt;
13736      using require_input_iter = typename std::enable_if&lt;std::is_convertible&lt;typename std::iterator_traits&lt;InputIt&gt;::iterator_category,
13737              std::input_iterator_tag&gt;::value&gt;::type;
13738      template&lt;typename InputIt, typename = require_input_iter&lt;InputIt&gt;&gt;
13739      void insert(InputIt first, InputIt last)
13740      {
13741          for (auto it = first; it != last; ++it)
13742          {
13743              insert(*it);
13744          }
13745      }
13746  private:
13747      JSON_NO_UNIQUE_ADDRESS key_compare m_compare = key_compare();
13748  };
13749  NLOHMANN_JSON_NAMESPACE_END
13750  #if defined(JSON_HAS_CPP_17)
13751      #include &lt;any&gt;
13752      #include &lt;string_view&gt;
13753  #endif
13754  NLOHMANN_JSON_NAMESPACE_BEGIN
13755  NLOHMANN_BASIC_JSON_TPL_DECLARATION
13756  class basic_json 
13757  {
13758    private:
13759      template&lt;detail::value_t&gt; friend struct detail::external_constructor;
13760      template&lt;typename&gt;
13761      friend class ::nlohmann::json_pointer;
13762      template&lt;typename BasicJsonType, typename InputType&gt;
13763      friend class ::nlohmann::detail::parser;
13764      friend ::nlohmann::detail::serializer&lt;basic_json&gt;;
13765      template&lt;typename BasicJsonType&gt;
13766      friend class ::nlohmann::detail::iter_impl;
13767      template&lt;typename BasicJsonType, typename CharType&gt;
13768      friend class ::nlohmann::detail::binary_writer;
13769      template&lt;typename BasicJsonType, typename InputType, typename SAX&gt;
13770      friend class ::nlohmann::detail::binary_reader;
13771      template&lt;typename BasicJsonType&gt;
13772      friend class ::nlohmann::detail::json_sax_dom_parser;
13773      template&lt;typename BasicJsonType&gt;
13774      friend class ::nlohmann::detail::json_sax_dom_callback_parser;
13775      friend class ::nlohmann::detail::exception;
13776      using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
13777    JSON_PRIVATE_UNLESS_TESTED:
13778      using lexer = ::nlohmann::detail::lexer_base&lt;basic_json&gt;;
13779      template&lt;typename InputAdapterType&gt;
13780      static ::nlohmann::detail::parser&lt;basic_json, InputAdapterType&gt; parser(
13781          InputAdapterType adapter,
13782          detail::parser_callback_t&lt;basic_json&gt;cb = nullptr,
13783          const bool allow_exceptions = true,
13784          const bool ignore_comments = false
13785                                   )
13786      {
13787          return ::nlohmann::detail::parser&lt;basic_json, InputAdapterType&gt;(std::move(adapter),
13788                  std::move(cb), allow_exceptions, ignore_comments);
13789      }
13790    private:
13791      using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
13792      template&lt;typename BasicJsonType&gt;
13793      using internal_iterator = ::nlohmann::detail::internal_iterator&lt;BasicJsonType&gt;;
13794      template&lt;typename BasicJsonType&gt;
13795      using iter_impl = ::nlohmann::detail::iter_impl&lt;BasicJsonType&gt;;
13796      template&lt;typename Iterator&gt;
13797      using iteration_proxy = ::nlohmann::detail::iteration_proxy&lt;Iterator&gt;;
13798      template&lt;typename Base&gt; using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator&lt;Base&gt;;
13799      template&lt;typename CharType&gt;
13800      using output_adapter_t = ::nlohmann::detail::output_adapter_t&lt;CharType&gt;;
13801      template&lt;typename InputType&gt;
13802      using binary_reader = ::nlohmann::detail::binary_reader&lt;basic_json, InputType&gt;;
13803      template&lt;typename CharType&gt; using binary_writer = ::nlohmann::detail::binary_writer&lt;basic_json, CharType&gt;;
13804    JSON_PRIVATE_UNLESS_TESTED:
13805      using serializer = ::nlohmann::detail::serializer&lt;basic_json&gt;;
13806    public:
13807      using value_t = detail::value_t;
13808      using json_pointer = ::nlohmann::json_pointer&lt;StringType&gt;;
13809      template&lt;typename T, typename SFINAE&gt;
13810      using json_serializer = JSONSerializer&lt;T, SFINAE&gt;;
13811      using error_handler_t = detail::error_handler_t;
13812      using cbor_tag_handler_t = detail::cbor_tag_handler_t;
13813      using initializer_list_t = std::initializer_list&lt;detail::json_ref&lt;basic_json&gt;&gt;;
13814      using input_format_t = detail::input_format_t;
13815      using json_sax_t = json_sax&lt;basic_json&gt;;
13816      using exception = detail::exception;
13817      using parse_error = detail::parse_error;
13818      using invalid_iterator = detail::invalid_iterator;
13819      using type_error = detail::type_error;
13820      using out_of_range = detail::out_of_range;
13821      using other_error = detail::other_error;
13822      using value_type = basic_json;
13823      using reference = value_type&amp;;
13824      using const_reference = const value_type&amp;;
13825      using difference_type = std::ptrdiff_t;
13826      using size_type = std::size_t;
13827      using allocator_type = AllocatorType&lt;basic_json&gt;;
13828      using pointer = typename std::allocator_traits&lt;allocator_type&gt;::pointer;
13829      using const_pointer = typename std::allocator_traits&lt;allocator_type&gt;::const_pointer;
13830      using iterator = iter_impl&lt;basic_json&gt;;
13831      using const_iterator = iter_impl&lt;const basic_json&gt;;
13832      using reverse_iterator = json_reverse_iterator&lt;typename basic_json::iterator&gt;;
13833      using const_reverse_iterator = json_reverse_iterator&lt;typename basic_json::const_iterator&gt;;
13834      static allocator_type get_allocator()
13835      {
13836          return allocator_type();
13837      }
13838      JSON_HEDLEY_WARN_UNUSED_RESULT
13839      static basic_json meta()
13840      {
13841          basic_json result;
13842          result[&quot;copyright&quot;] = &quot;(C) 2013-2022 Niels Lohmann&quot;;
13843          result[&quot;name&quot;] = &quot;JSON for Modern C++&quot;;
13844          result[&quot;url&quot;] = &quot;https:&amp;bsol;&amp;bsol;github.com/nlohmann/json&quot;;
13845          result[&quot;version&quot;][&quot;string&quot;] =
13846              detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), &#x27;.&#x27;,
13847                             std::to_string(NLOHMANN_JSON_VERSION_MINOR), &#x27;.&#x27;,
13848                             std::to_string(NLOHMANN_JSON_VERSION_PATCH));
13849          result[&quot;version&quot;][&quot;major&quot;] = NLOHMANN_JSON_VERSION_MAJOR;
13850          result[&quot;version&quot;][&quot;minor&quot;] = NLOHMANN_JSON_VERSION_MINOR;
13851          result[&quot;version&quot;][&quot;patch&quot;] = NLOHMANN_JSON_VERSION_PATCH;
13852  #ifdef _WIN32
13853          result[&quot;platform&quot;] = &quot;win32&quot;;
13854  #elif defined __linux__
13855          result[&quot;platform&quot;] = &quot;linux&quot;;
13856  #elif defined __APPLE__
13857          result[&quot;platform&quot;] = &quot;apple&quot;;
13858  #elif defined __unix__
13859          result[&quot;platform&quot;] = &quot;unix&quot;;
13860  #else
13861          result[&quot;platform&quot;] = &quot;unknown&quot;;
13862  #endif
13863  #if defined(__ICC) || defined(__INTEL_COMPILER)
13864          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;icc&quot;}, {&quot;version&quot;, __INTEL_COMPILER}};
13865  #elif defined(__clang__)
13866          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;clang&quot;}, {&quot;version&quot;, __clang_version__}};
13867  #elif defined(__GNUC__) || defined(__GNUG__)
13868          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;gcc&quot;}, {&quot;version&quot;, detail::concat(
13869                      std::to_string(__GNUC__), &#x27;.&#x27;,
13870                      std::to_string(__GNUC_MINOR__), &#x27;.&#x27;,
13871                      std::to_string(__GNUC_PATCHLEVEL__))
13872              }
13873          };
13874  #elif defined(__HP_cc) || defined(__HP_aCC)
13875          result[&quot;compiler&quot;] = &quot;hp&quot;
13876  #elif defined(__IBMCPP__)
13877          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;ilecpp&quot;}, {&quot;version&quot;, __IBMCPP__}};
13878  #elif defined(_MSC_VER)
13879          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;msvc&quot;}, {&quot;version&quot;, _MSC_VER}};
13880  #elif defined(__PGI)
13881          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;pgcpp&quot;}, {&quot;version&quot;, __PGI}};
13882  #elif defined(__SUNPRO_CC)
13883          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;sunpro&quot;}, {&quot;version&quot;, __SUNPRO_CC}};
13884  #else
13885          result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;unknown&quot;}, {&quot;version&quot;, &quot;unknown&quot;}};
13886  #endif
13887  #if defined(_MSVC_LANG)
13888          result[&quot;compiler&quot;][&quot;c++&quot;] = std::to_string(_MSVC_LANG);
13889  #elif defined(__cplusplus)
13890          result[&quot;compiler&quot;][&quot;c++&quot;] = std::to_string(__cplusplus);
13891  #else
13892          result[&quot;compiler&quot;][&quot;c++&quot;] = &quot;unknown&quot;;
13893  #endif
13894          return result;
13895      }
13896  #if defined(JSON_HAS_CPP_14)
13897      using default_object_comparator_t = std::less&lt;&gt;;
13898  #else
13899      using default_object_comparator_t = std::less&lt;StringType&gt;;
13900  #endif
13901      using object_t = ObjectType&lt;StringType,
13902            basic_json,
13903            default_object_comparator_t,
13904            AllocatorType&lt;std::pair&lt;const StringType,
13905            basic_json&gt;&gt;&gt;;
13906      using array_t = ArrayType&lt;basic_json, AllocatorType&lt;basic_json&gt;&gt;;
13907      using string_t = StringType;
13908      using boolean_t = BooleanType;
13909      using number_integer_t = NumberIntegerType;
13910      using number_unsigned_t = NumberUnsignedType;
13911      using number_float_t = NumberFloatType;
13912      using binary_t = nlohmann::byte_container_with_subtype&lt;BinaryType&gt;;
13913      using object_comparator_t = detail::actual_object_comparator_t&lt;basic_json&gt;;
13914    private:
13915      template&lt;typename T, typename... Args&gt;
13916      JSON_HEDLEY_RETURNS_NON_NULL
13917      static T* create(Args&amp;&amp; ... args)
13918      {
13919          AllocatorType&lt;T&gt; alloc;
13920          using AllocatorTraits = std::allocator_traits&lt;AllocatorType&lt;T&gt;&gt;;
13921          auto deleter = [&amp;](T * obj)
13922          {
13923              AllocatorTraits::deallocate(alloc, obj, 1);
13924          };
13925          std::unique_ptr&lt;T, decltype(deleter)&gt; obj(AllocatorTraits::allocate(alloc, 1), deleter);
13926          AllocatorTraits::construct(alloc, obj.get(), std::forward&lt;Args&gt;(args)...);
13927          JSON_ASSERT(obj != nullptr);
13928          return obj.release();
13929      }
13930    JSON_PRIVATE_UNLESS_TESTED:
13931      union json_value
13932      {
13933          object_t* object;
13934          array_t* array;
13935          string_t* string;
13936          binary_t* binary;
13937          boolean_t boolean;
13938          number_integer_t number_integer;
13939          number_unsigned_t number_unsigned;
13940          number_float_t number_float;
13941          json_value() = default;
13942          json_value(boolean_t v) noexcept : boolean(v) {}
13943          json_value(number_integer_t v) noexcept : number_integer(v) {}
13944          json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
13945          json_value(number_float_t v) noexcept : number_float(v) {}
13946          json_value(value_t t)
13947          {
13948              switch (t)
13949              {
13950                  case value_t::object:
13951                  {
13952                      object = create&lt;object_t&gt;();
13953                      break;
13954                  }
13955                  case value_t::array:
13956                  {
13957                      array = create&lt;array_t&gt;();
13958                      break;
13959                  }
13960                  case value_t::string:
13961                  {
13962                      string = create&lt;string_t&gt;(&quot;&quot;);
13963                      break;
13964                  }
13965                  case value_t::binary:
13966                  {
13967                      binary = create&lt;binary_t&gt;();
13968                      break;
13969                  }
13970                  case value_t::boolean:
13971                  {
13972                      boolean = static_cast&lt;boolean_t&gt;(false);
13973                      break;
13974                  }
13975                  case value_t::number_integer:
13976                  {
13977                      number_integer = static_cast&lt;number_integer_t&gt;(0);
13978                      break;
13979                  }
13980                  case value_t::number_unsigned:
13981                  {
13982                      number_unsigned = static_cast&lt;number_unsigned_t&gt;(0);
13983                      break;
13984                  }
13985                  case value_t::number_float:
13986                  {
13987                      number_float = static_cast&lt;number_float_t&gt;(0.0);
13988                      break;
13989                  }
13990                  case value_t::null:
13991                  {
13992                      object = nullptr;  
13993                      break;
13994                  }
13995                  case value_t::discarded:
13996                  default:
13997                  {
13998                      object = nullptr;  
13999                      if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
14000                      {
14001                          JSON_THROW(other_error::create(500, &quot;961c151d2e87f2686a955a9be24d316f1362bf21 3.11.2&quot;, nullptr)); 
14002                      }
14003                      break;
14004                  }
14005              }
14006          }
14007          json_value(const string_t&amp; value) : string(create&lt;string_t&gt;(value)) {}
14008          json_value(string_t&amp;&amp; value) : string(create&lt;string_t&gt;(std::move(value))) {}
14009          json_value(const object_t&amp; value) : object(create&lt;object_t&gt;(value)) {}
14010          json_value(object_t&amp;&amp; value) : object(create&lt;object_t&gt;(std::move(value))) {}
14011          json_value(const array_t&amp; value) : array(create&lt;array_t&gt;(value)) {}
14012          json_value(array_t&amp;&amp; value) : array(create&lt;array_t&gt;(std::move(value))) {}
14013          json_value(const typename binary_t::container_type&amp; value) : binary(create&lt;binary_t&gt;(value)) {}
14014          json_value(typename binary_t::container_type&amp;&amp; value) : binary(create&lt;binary_t&gt;(std::move(value))) {}
14015          json_value(const binary_t&amp; value) : binary(create&lt;binary_t&gt;(value)) {}
14016          json_value(binary_t&amp;&amp; value) : binary(create&lt;binary_t&gt;(std::move(value))) {}
14017          void destroy(value_t t)
14018          {
14019              if (t == value_t::array || t == value_t::object)
14020              {
14021                  std::vector&lt;basic_json&gt; stack;
14022                  if (t == value_t::array)
14023                  {
14024                      stack.reserve(array-&gt;size());
14025                      std::move(array-&gt;begin(), array-&gt;end(), std::back_inserter(stack));
14026                  }
14027                  else
14028                  {
14029                      stack.reserve(object-&gt;size());
14030                      for (auto&amp;&amp; it : *object)
14031                      {
14032                          stack.push_back(std::move(it.second));
14033                      }
14034                  }
14035                  while (!stack.empty())
14036                  {
14037                      basic_json current_item(std::move(stack.back()));
14038                      stack.pop_back();
14039                      if (current_item.is_array())
14040                      {
14041                          std::move(current_item.m_value.array-&gt;begin(), current_item.m_value.array-&gt;end(), std::back_inserter(stack));
14042                          current_item.m_value.array-&gt;clear();
14043                      }
14044                      else if (current_item.is_object())
14045                      {
14046                          for (auto&amp;&amp; it : *current_item.m_value.object)
14047                          {
14048                              stack.push_back(std::move(it.second));
14049                          }
14050                          current_item.m_value.object-&gt;clear();
14051                      }
14052                  }
14053              }
14054              switch (t)
14055              {
14056                  case value_t::object:
14057                  {
14058                      AllocatorType&lt;object_t&gt; alloc;
14059                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, object);
14060                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, object, 1);
14061                      break;
14062                  }
14063                  case value_t::array:
14064                  {
14065                      AllocatorType&lt;array_t&gt; alloc;
14066                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, array);
14067                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, array, 1);
14068                      break;
14069                  }
14070                  case value_t::string:
14071                  {
14072                      AllocatorType&lt;string_t&gt; alloc;
14073                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, string);
14074                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, string, 1);
14075                      break;
14076                  }
14077                  case value_t::binary:
14078                  {
14079                      AllocatorType&lt;binary_t&gt; alloc;
14080                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, binary);
14081                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, binary, 1);
14082                      break;
14083                  }
14084                  case value_t::null:
14085                  case value_t::boolean:
14086                  case value_t::number_integer:
14087                  case value_t::number_unsigned:
14088                  case value_t::number_float:
14089                  case value_t::discarded:
14090                  default:
14091                  {
14092                      break;
14093                  }
14094              }
14095          }
14096      };
14097    private:
14098      void assert_invariant(bool check_parents = true) const noexcept
14099      {
14100          JSON_ASSERT(m_type != value_t::object || m_value.object != nullptr);
14101          JSON_ASSERT(m_type != value_t::array || m_value.array != nullptr);
14102          JSON_ASSERT(m_type != value_t::string || m_value.string != nullptr);
14103          JSON_ASSERT(m_type != value_t::binary || m_value.binary != nullptr);
14104  #if JSON_DIAGNOSTICS
14105          JSON_TRY
14106          {
14107              JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [this](const basic_json &amp; j)
14108              {
14109                  return j.m_parent == this;
14110              }));
14111          }
14112          JSON_CATCH(...) {} 
14113  #endif
14114          static_cast&lt;void&gt;(check_parents);
14115      }
14116      void set_parents()
14117      {
14118  #if JSON_DIAGNOSTICS
14119          switch (m_type)
14120          {
14121              case value_t::array:
14122              {
14123                  for (auto&amp; element : *m_value.array)
14124                  {
14125                      element.m_parent = this;
14126                  }
14127                  break;
14128              }
14129              case value_t::object:
14130              {
14131                  for (auto&amp; element : *m_value.object)
14132                  {
14133                      element.second.m_parent = this;
14134                  }
14135                  break;
14136              }
14137              case value_t::null:
14138              case value_t::string:
14139              case value_t::boolean:
14140              case value_t::number_integer:
14141              case value_t::number_unsigned:
14142              case value_t::number_float:
14143              case value_t::binary:
14144              case value_t::discarded:
14145              default:
14146                  break;
14147          }
14148  #endif
14149      }
14150      iterator set_parents(iterator it, typename iterator::difference_type count_set_parents)
14151      {
14152  #if JSON_DIAGNOSTICS
14153          for (typename iterator::difference_type i = 0; i &lt; count_set_parents; ++i)
14154          {
14155              (it + i)-&gt;m_parent = this;
14156          }
14157  #else
14158          static_cast&lt;void&gt;(count_set_parents);
14159  #endif
14160          return it;
14161      }
14162      reference set_parent(reference j, std::size_t old_capacity = static_cast&lt;std::size_t&gt;(-1))
14163      {
14164  #if JSON_DIAGNOSTICS
14165          if (old_capacity != static_cast&lt;std::size_t&gt;(-1))
14166          {
14167              JSON_ASSERT(type() == value_t::array);
14168              if (JSON_HEDLEY_UNLIKELY(m_value.array-&gt;capacity() != old_capacity))
14169              {
14170                  set_parents();
14171                  return j;
14172              }
14173          }
14174  #ifdef JSON_HEDLEY_MSVC_VERSION
14175  #pragma warning(push )
14176  #pragma warning(disable : 4127) 
14177  #endif
14178          if (detail::is_ordered_map&lt;object_t&gt;::value)
14179          {
14180              set_parents();
14181              return j;
14182          }
14183  #ifdef JSON_HEDLEY_MSVC_VERSION
14184  #pragma warning( pop )
14185  #endif
14186          j.m_parent = this;
14187  #else
14188          static_cast&lt;void&gt;(j);
14189          static_cast&lt;void&gt;(old_capacity);
14190  #endif
14191          return j;
14192      }
14193    public:
14194      using parse_event_t = detail::parse_event_t;
14195      using parser_callback_t = detail::parser_callback_t&lt;basic_json&gt;;
14196      basic_json(const value_t v)
14197          : m_type(v), m_value(v)
14198      {
14199          assert_invariant();
14200      }
14201      basic_json(std::nullptr_t = nullptr) noexcept 
14202          : basic_json(value_t::null)
14203      {
14204          assert_invariant();
14205      }
14206      template &lt; typename CompatibleType,
14207                 typename U = detail::uncvref_t&lt;CompatibleType&gt;,
14208                 detail::enable_if_t &lt;
14209                     !detail::is_basic_json&lt;U&gt;::value &amp;&amp; detail::is_compatible_type&lt;basic_json_t, U&gt;::value, int &gt; = 0 &gt;
14210      basic_json(CompatibleType &amp;&amp; val) noexcept(noexcept( 
14211                  JSONSerializer&lt;U&gt;::to_json(std::declval&lt;basic_json_t&amp;&gt;(),
14212                                             std::forward&lt;CompatibleType&gt;(val))))
14213      {
14214          JSONSerializer&lt;U&gt;::to_json(*this, std::forward&lt;CompatibleType&gt;(val));
14215          set_parents();
14216          assert_invariant();
14217      }
14218      template &lt; typename BasicJsonType,
14219                 detail::enable_if_t &lt;
14220                     detail::is_basic_json&lt;BasicJsonType&gt;::value&amp;&amp; !std::is_same&lt;basic_json, BasicJsonType&gt;::value, int &gt; = 0 &gt;
14221      basic_json(const BasicJsonType&amp; val)
14222      {
14223          using other_boolean_t = typename BasicJsonType::boolean_t;
14224          using other_number_float_t = typename BasicJsonType::number_float_t;
14225          using other_number_integer_t = typename BasicJsonType::number_integer_t;
14226          using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
14227          using other_string_t = typename BasicJsonType::string_t;
14228          using other_object_t = typename BasicJsonType::object_t;
14229          using other_array_t = typename BasicJsonType::array_t;
14230          using other_binary_t = typename BasicJsonType::binary_t;
14231          switch (val.type())
14232          {
14233              case value_t::boolean:
14234                  JSONSerializer&lt;other_boolean_t&gt;::to_json(*this, val.template get&lt;other_boolean_t&gt;());
14235                  break;
14236              case value_t::number_float:
14237                  JSONSerializer&lt;other_number_float_t&gt;::to_json(*this, val.template get&lt;other_number_float_t&gt;());
14238                  break;
14239              case value_t::number_integer:
14240                  JSONSerializer&lt;other_number_integer_t&gt;::to_json(*this, val.template get&lt;other_number_integer_t&gt;());
14241                  break;
14242              case value_t::number_unsigned:
14243                  JSONSerializer&lt;other_number_unsigned_t&gt;::to_json(*this, val.template get&lt;other_number_unsigned_t&gt;());
14244                  break;
14245              case value_t::string:
14246                  JSONSerializer&lt;other_string_t&gt;::to_json(*this, val.template get_ref&lt;const other_string_t&amp;&gt;());
14247                  break;
14248              case value_t::object:
14249                  JSONSerializer&lt;other_object_t&gt;::to_json(*this, val.template get_ref&lt;const other_object_t&amp;&gt;());
14250                  break;
14251              case value_t::array:
14252                  JSONSerializer&lt;other_array_t&gt;::to_json(*this, val.template get_ref&lt;const other_array_t&amp;&gt;());
14253                  break;
14254              case value_t::binary:
14255                  JSONSerializer&lt;other_binary_t&gt;::to_json(*this, val.template get_ref&lt;const other_binary_t&amp;&gt;());
14256                  break;
14257              case value_t::null:
14258                  *this = nullptr;
14259                  break;
14260              case value_t::discarded:
14261                  m_type = value_t::discarded;
14262                  break;
14263              default:            
14264                  JSON_ASSERT(false); 
14265          }
14266          JSON_ASSERT(m_type == val.type());
14267          set_parents();
14268          assert_invariant();
14269      }
14270      basic_json(initializer_list_t init,
14271                 bool type_deduction = true,
14272                 value_t manual_type = value_t::array)
14273      {
14274          bool is_an_object = std::all_of(init.begin(), init.end(),
14275                                          [](const detail::json_ref&lt;basic_json&gt;&amp; element_ref)
14276          {
14277              return element_ref-&gt;is_array() &amp;&amp; element_ref-&gt;size() == 2 &amp;&amp; (*element_ref)[0].is_string();
14278          });
14279          if (!type_deduction)
14280          {
14281              if (manual_type == value_t::array)
14282              {
14283                  is_an_object = false;
14284              }
14285              if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object &amp;&amp; !is_an_object))
14286              {
14287                  JSON_THROW(type_error::create(301, &quot;cannot create object from initializer list&quot;, nullptr));
14288              }
14289          }
14290          if (is_an_object)
14291          {
14292              m_type = value_t::object;
14293              m_value = value_t::object;
14294              for (auto&amp; element_ref : init)
14295              {
14296                  auto element = element_ref.moved_or_copied();
14297                  m_value.object-&gt;emplace(
14298                      std::move(*((*element.m_value.array)[0].m_value.string)),
14299                      std::move((*element.m_value.array)[1]));
14300              }
14301          }
14302          else
14303          {
14304              m_type = value_t::array;
14305              m_value.array = create&lt;array_t&gt;(init.begin(), init.end());
14306          }
14307          set_parents();
14308          assert_invariant();
14309      }
14310      JSON_HEDLEY_WARN_UNUSED_RESULT
14311      static basic_json binary(const typename binary_t::container_type&amp; init)
14312      {
14313          auto res = basic_json();
14314          res.m_type = value_t::binary;
14315          res.m_value = init;
14316          return res;
14317      }
14318      JSON_HEDLEY_WARN_UNUSED_RESULT
14319      static basic_json binary(const typename binary_t::container_type&amp; init, typename binary_t::subtype_type subtype)
14320      {
14321          auto res = basic_json();
14322          res.m_type = value_t::binary;
14323          res.m_value = binary_t(init, subtype);
14324          return res;
14325      }
14326      JSON_HEDLEY_WARN_UNUSED_RESULT
14327      static basic_json binary(typename binary_t::container_type&amp;&amp; init)
14328      {
14329          auto res = basic_json();
14330          res.m_type = value_t::binary;
14331          res.m_value = std::move(init);
14332          return res;
14333      }
14334      JSON_HEDLEY_WARN_UNUSED_RESULT
14335      static basic_json binary(typename binary_t::container_type&amp;&amp; init, typename binary_t::subtype_type subtype)
14336      {
14337          auto res = basic_json();
14338          res.m_type = value_t::binary;
14339          res.m_value = binary_t(std::move(init), subtype);
14340          return res;
14341      }
14342      JSON_HEDLEY_WARN_UNUSED_RESULT
14343      static basic_json array(initializer_list_t init = {})
14344      {
14345          return basic_json(init, false, value_t::array);
14346      }
14347      JSON_HEDLEY_WARN_UNUSED_RESULT
14348      static basic_json object(initializer_list_t init = {})
14349      {
14350          return basic_json(init, false, value_t::object);
14351      }
14352      basic_json(size_type cnt, const basic_json&amp; val)
14353          : m_type(value_t::array)
14354      {
14355          m_value.array = create&lt;array_t&gt;(cnt, val);
14356          set_parents();
14357          assert_invariant();
14358      }
14359      template &lt; class InputIT, typename std::enable_if &lt;
14360                     std::is_same&lt;InputIT, typename basic_json_t::iterator&gt;::value ||
14361                     std::is_same&lt;InputIT, typename basic_json_t::const_iterator&gt;::value, int &gt;::type = 0 &gt;
14362      basic_json(InputIT first, InputIT last)
14363      {
14364          JSON_ASSERT(first.m_object != nullptr);
14365          JSON_ASSERT(last.m_object != nullptr);
14366          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
14367          {
14368              JSON_THROW(invalid_iterator::create(201, &quot;iterators are not compatible&quot;, nullptr));
14369          }
14370          m_type = first.m_object-&gt;m_type;
14371          switch (m_type)
14372          {
14373              case value_t::boolean:
14374              case value_t::number_float:
14375              case value_t::number_integer:
14376              case value_t::number_unsigned:
14377              case value_t::string:
14378              {
14379                  if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
14380                                           || !last.m_it.primitive_iterator.is_end()))
14381                  {
14382                      JSON_THROW(invalid_iterator::create(204, &quot;iterators out of range&quot;, first.m_object));
14383                  }
14384                  break;
14385              }
14386              case value_t::null:
14387              case value_t::object:
14388              case value_t::array:
14389              case value_t::binary:
14390              case value_t::discarded:
14391              default:
14392                  break;
14393          }
14394          switch (m_type)
14395          {
14396              case value_t::number_integer:
14397              {
14398                  m_value.number_integer = first.m_object-&gt;m_value.number_integer;
14399                  break;
14400              }
14401              case value_t::number_unsigned:
14402              {
14403                  m_value.number_unsigned = first.m_object-&gt;m_value.number_unsigned;
14404                  break;
14405              }
14406              case value_t::number_float:
14407              {
14408                  m_value.number_float = first.m_object-&gt;m_value.number_float;
14409                  break;
14410              }
14411              case value_t::boolean:
14412              {
14413                  m_value.boolean = first.m_object-&gt;m_value.boolean;
14414                  break;
14415              }
14416              case value_t::string:
14417              {
14418                  m_value = *first.m_object-&gt;m_value.string;
14419                  break;
14420              }
14421              case value_t::object:
14422              {
14423                  m_value.object = create&lt;object_t&gt;(first.m_it.object_iterator,
14424                                                    last.m_it.object_iterator);
14425                  break;
14426              }
14427              case value_t::array:
14428              {
14429                  m_value.array = create&lt;array_t&gt;(first.m_it.array_iterator,
14430                                                  last.m_it.array_iterator);
14431                  break;
14432              }
14433              case value_t::binary:
14434              {
14435                  m_value = *first.m_object-&gt;m_value.binary;
14436                  break;
14437              }
14438              case value_t::null:
14439              case value_t::discarded:
14440              default:
14441                  JSON_THROW(invalid_iterator::create(206, detail::concat(&quot;cannot construct with iterators from &quot;, first.m_object-&gt;type_name()), first.m_object));
14442          }
14443          set_parents();
14444          assert_invariant();
14445      }
14446      template&lt;typename JsonRef,
14447               detail::enable_if_t&lt;detail::conjunction&lt;detail::is_json_ref&lt;JsonRef&gt;,
14448                                   std::is_same&lt;typename JsonRef::value_type, basic_json&gt;&gt;::value, int&gt; = 0 &gt;
14449      basic_json(const JsonRef&amp; ref) : basic_json(ref.moved_or_copied()) {}
14450      basic_json(const basic_json&amp; other)
14451          : m_type(other.m_type)
14452      {
14453          other.assert_invariant();
14454          switch (m_type)
14455          {
14456              case value_t::object:
14457              {
14458                  m_value = *other.m_value.object;
14459                  break;
14460              }
14461              case value_t::array:
14462              {
14463                  m_value = *other.m_value.array;
14464                  break;
14465              }
14466              case value_t::string:
14467              {
14468                  m_value = *other.m_value.string;
14469                  break;
14470              }
14471              case value_t::boolean:
14472              {
14473                  m_value = other.m_value.boolean;
14474                  break;
14475              }
14476              case value_t::number_integer:
14477              {
14478                  m_value = other.m_value.number_integer;
14479                  break;
14480              }
14481              case value_t::number_unsigned:
14482              {
14483                  m_value = other.m_value.number_unsigned;
14484                  break;
14485              }
14486              case value_t::number_float:
14487              {
14488                  m_value = other.m_value.number_float;
14489                  break;
14490              }
14491              case value_t::binary:
14492              {
14493                  m_value = *other.m_value.binary;
14494                  break;
14495              }
14496              case value_t::null:
14497              case value_t::discarded:
14498              default:
14499                  break;
14500          }
14501          set_parents();
14502          assert_invariant();
14503      }
14504      basic_json(basic_json&amp;&amp; other) noexcept
14505          : m_type(std::move(other.m_type)),
14506            m_value(std::move(other.m_value))
14507      {
14508          other.assert_invariant(false);
14509          other.m_type = value_t::null;
14510          other.m_value = {};
14511          set_parents();
14512          assert_invariant();
14513      }
14514      basic_json&amp; operator=(basic_json other) noexcept (
14515          std::is_nothrow_move_constructible&lt;value_t&gt;::value&amp;&amp;
14516          std::is_nothrow_move_assignable&lt;value_t&gt;::value&amp;&amp;
14517          std::is_nothrow_move_constructible&lt;json_value&gt;::value&amp;&amp;
14518          std::is_nothrow_move_assignable&lt;json_value&gt;::value
14519      )
14520      {
14521          other.assert_invariant();
14522          using std::swap;
14523          swap(m_type, other.m_type);
14524          swap(m_value, other.m_value);
14525          set_parents();
14526          assert_invariant();
14527          return *this;
14528      }
14529      ~basic_json() noexcept
14530      {
14531          assert_invariant(false);
14532          m_value.destroy(m_type);
14533      }
14534    public:
14535      string_t dump(const int indent = -1,
14536                    const char indent_char = &#x27; &#x27;,
14537                    const bool ensure_ascii = false,
14538                    const error_handler_t error_handler = error_handler_t::strict) const
14539      {
14540          string_t result;
14541          serializer s(detail::output_adapter&lt;char, string_t&gt;(result), indent_char, error_handler);
14542          if (indent &gt;= 0)
14543          {
14544              s.dump(*this, true, ensure_ascii, static_cast&lt;unsigned int&gt;(indent));
14545          }
14546          else
14547          {
14548              s.dump(*this, false, ensure_ascii, 0);
14549          }
14550          return result;
14551      }
14552      constexpr value_t type() const noexcept
14553      {
14554          return m_type;
14555      }
14556      constexpr bool is_primitive() const noexcept
14557      {
14558          return is_null() || is_string() || is_boolean() || is_number() || is_binary();
14559      }
14560      constexpr bool is_structured() const noexcept
14561      {
14562          return is_array() || is_object();
14563      }
14564      constexpr bool is_null() const noexcept
14565      {
14566          return m_type == value_t::null;
14567      }
14568      constexpr bool is_boolean() const noexcept
14569      {
14570          return m_type == value_t::boolean;
14571      }
14572      constexpr bool is_number() const noexcept
14573      {
14574          return is_number_integer() || is_number_float();
14575      }
14576      constexpr bool is_number_integer() const noexcept
14577      {
14578          return m_type == value_t::number_integer || m_type == value_t::number_unsigned;
14579      }
14580      constexpr bool is_number_unsigned() const noexcept
14581      {
14582          return m_type == value_t::number_unsigned;
14583      }
14584      constexpr bool is_number_float() const noexcept
14585      {
14586          return m_type == value_t::number_float;
14587      }
14588      constexpr bool is_object() const noexcept
14589      {
14590          return m_type == value_t::object;
14591      }
14592      constexpr bool is_array() const noexcept
14593      {
14594          return m_type == value_t::array;
14595      }
14596      constexpr bool is_string() const noexcept
14597      {
14598          return m_type == value_t::string;
14599      }
14600      constexpr bool is_binary() const noexcept
14601      {
14602          return m_type == value_t::binary;
14603      }
14604      constexpr bool is_discarded() const noexcept
14605      {
14606          return m_type == value_t::discarded;
14607      }
14608      constexpr operator value_t() const noexcept
14609      {
14610          return m_type;
14611      }
14612    private:
14613      boolean_t get_impl(boolean_t* &amp;bsol;*unused*/) const
14614      {
14615          if (JSON_HEDLEY_LIKELY(is_boolean()))
14616          {
14617              return m_value.boolean;
14618          }
14619          JSON_THROW(type_error::create(302, detail::concat(&quot;type must be boolean, but is &quot;, type_name()), this));
14620      }
14621      object_t* get_impl_ptr(object_t* &amp;bsol;*unused*/) noexcept
14622      {
14623          return is_object() ? m_value.object : nullptr;
14624      }
14625      constexpr const object_t* get_impl_ptr(const object_t* &amp;bsol;*unused*/) const noexcept
14626      {
14627          return is_object() ? m_value.object : nullptr;
14628      }
14629      array_t* get_impl_ptr(array_t* &amp;bsol;*unused*/) noexcept
14630      {
14631          return is_array() ? m_value.array : nullptr;
14632      }
14633      constexpr const array_t* get_impl_ptr(const array_t* &amp;bsol;*unused*/) const noexcept
14634      {
14635          return is_array() ? m_value.array : nullptr;
14636      }
14637      string_t* get_impl_ptr(string_t* &amp;bsol;*unused*/) noexcept
14638      {
14639          return is_string() ? m_value.string : nullptr;
14640      }
14641      constexpr const string_t* get_impl_ptr(const string_t* &amp;bsol;*unused*/) const noexcept
14642      {
14643          return is_string() ? m_value.string : nullptr;
14644      }
14645      boolean_t* get_impl_ptr(boolean_t* &amp;bsol;*unused*/) noexcept
14646      {
14647          return is_boolean() ? &amp;m_value.boolean : nullptr;
14648      }
14649      constexpr const boolean_t* get_impl_ptr(const boolean_t* &amp;bsol;*unused*/) const noexcept
14650      {
14651          return is_boolean() ? &amp;m_value.boolean : nullptr;
14652      }
14653      number_integer_t* get_impl_ptr(number_integer_t* &amp;bsol;*unused*/) noexcept
14654      {
14655          return is_number_integer() ? &amp;m_value.number_integer : nullptr;
14656      }
14657      constexpr const number_integer_t* get_impl_ptr(const number_integer_t* &amp;bsol;*unused*/) const noexcept
14658      {
14659          return is_number_integer() ? &amp;m_value.number_integer : nullptr;
14660      }
14661      number_unsigned_t* get_impl_ptr(number_unsigned_t* &amp;bsol;*unused*/) noexcept
14662      {
14663          return is_number_unsigned() ? &amp;m_value.number_unsigned : nullptr;
14664      }
14665      constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* &amp;bsol;*unused*/) const noexcept
14666      {
14667          return is_number_unsigned() ? &amp;m_value.number_unsigned : nullptr;
14668      }
14669      number_float_t* get_impl_ptr(number_float_t* &amp;bsol;*unused*/) noexcept
14670      {
14671          return is_number_float() ? &amp;m_value.number_float : nullptr;
14672      }
14673      constexpr const number_float_t* get_impl_ptr(const number_float_t* &amp;bsol;*unused*/) const noexcept
14674      {
14675          return is_number_float() ? &amp;m_value.number_float : nullptr;
14676      }
14677      binary_t* get_impl_ptr(binary_t* &amp;bsol;*unused*/) noexcept
14678      {
14679          return is_binary() ? m_value.binary : nullptr;
14680      }
14681      constexpr const binary_t* get_impl_ptr(const binary_t* &amp;bsol;*unused*/) const noexcept
14682      {
14683          return is_binary() ? m_value.binary : nullptr;
14684      }
14685      template&lt;typename ReferenceType, typename ThisType&gt;
14686      static ReferenceType get_ref_impl(ThisType&amp; obj)
14687      {
14688          auto* ptr = obj.template get_ptr&lt;typename std::add_pointer&lt;ReferenceType&gt;::type&gt;();
14689          if (JSON_HEDLEY_LIKELY(ptr != nullptr))
14690          {
14691              return *ptr;
14692          }
14693          JSON_THROW(type_error::create(303, detail::concat(&quot;incompatible ReferenceType for get_ref, actual type is &quot;, obj.type_name()), &amp;obj));
14694      }
14695    public:
14696      template&lt;typename PointerType, typename std::enable_if&lt;
14697                   std::is_pointer&lt;PointerType&gt;::value, int&gt;::type = 0&gt;
14698      auto get_ptr() noexcept -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
14699      {
14700          return get_impl_ptr(static_cast&lt;PointerType&gt;(nullptr));
14701      }
14702      template &lt; typename PointerType, typename std::enable_if &lt;
14703                     std::is_pointer&lt;PointerType&gt;::value&amp;&amp;
14704                     std::is_const&lt;typename std::remove_pointer&lt;PointerType&gt;::type&gt;::value, int &gt;::type = 0 &gt;
14705      constexpr auto get_ptr() const noexcept -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
14706      {
14707          return get_impl_ptr(static_cast&lt;PointerType&gt;(nullptr));
14708      }
14709    private:
14710      template &lt; typename ValueType,
14711                 detail::enable_if_t &lt;
14712                     detail::is_default_constructible&lt;ValueType&gt;::value&amp;&amp;
14713                     detail::has_from_json&lt;basic_json_t, ValueType&gt;::value,
14714                     int &gt; = 0 &gt;
14715      ValueType get_impl(detail::priority_tag&lt;0&gt; &amp;bsol;*unused*/) const noexcept(noexcept(
14716                  JSONSerializer&lt;ValueType&gt;::from_json(std::declval&lt;const basic_json_t&amp;&gt;(), std::declval&lt;ValueType&amp;&gt;())))
14717      {
14718          auto ret = ValueType();
14719          JSONSerializer&lt;ValueType&gt;::from_json(*this, ret);
14720          return ret;
14721      }
14722      template &lt; typename ValueType,
14723                 detail::enable_if_t &lt;
14724                     detail::has_non_default_from_json&lt;basic_json_t, ValueType&gt;::value,
14725                     int &gt; = 0 &gt;
14726      ValueType get_impl(detail::priority_tag&lt;1&gt; &amp;bsol;*unused*/) const noexcept(noexcept(
14727                  JSONSerializer&lt;ValueType&gt;::from_json(std::declval&lt;const basic_json_t&amp;&gt;())))
14728      {
14729          return JSONSerializer&lt;ValueType&gt;::from_json(*this);
14730      }
14731      template &lt; typename BasicJsonType,
14732                 detail::enable_if_t &lt;
14733                     detail::is_basic_json&lt;BasicJsonType&gt;::value,
14734                     int &gt; = 0 &gt;
14735      BasicJsonType get_impl(detail::priority_tag&lt;2&gt; &amp;bsol;*unused*/) const
14736      {
14737          return *this;
14738      }
14739      template&lt;typename BasicJsonType,
14740               detail::enable_if_t&lt;
14741                   std::is_same&lt;BasicJsonType, basic_json_t&gt;::value,
14742                   int&gt; = 0&gt;
14743      basic_json get_impl(detail::priority_tag&lt;3&gt; &amp;bsol;*unused*/) const
14744      {
14745          return *this;
14746      }
14747      template&lt;typename PointerType,
14748               detail::enable_if_t&lt;
14749                   std::is_pointer&lt;PointerType&gt;::value,
14750                   int&gt; = 0&gt;
14751      constexpr auto get_impl(detail::priority_tag&lt;4&gt; &amp;bsol;*unused*/) const noexcept
14752      -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().template get_ptr&lt;PointerType&gt;())
14753      {
14754          return get_ptr&lt;PointerType&gt;();
14755      }
14756    public:
14757      template &lt; typename ValueTypeCV, typename ValueType = detail::uncvref_t&lt;ValueTypeCV&gt;&gt;
14758  #if defined(JSON_HAS_CPP_14)
14759      constexpr
14760  #endif
14761      auto get() const noexcept(
14762      noexcept(std::declval&lt;const basic_json_t&amp;&gt;().template get_impl&lt;ValueType&gt;(detail::priority_tag&lt;4&gt; {})))
14763      -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().template get_impl&lt;ValueType&gt;(detail::priority_tag&lt;4&gt; {}))
14764      {
14765          static_assert(!std::is_reference&lt;ValueTypeCV&gt;::value,
14766                        &quot;get() cannot be used with reference types, you might want to use get_ref()&quot;);
14767          return get_impl&lt;ValueType&gt;(detail::priority_tag&lt;4&gt; {});
14768      }
14769      template&lt;typename PointerType, typename std::enable_if&lt;
14770                   std::is_pointer&lt;PointerType&gt;::value, int&gt;::type = 0&gt;
14771      auto get() noexcept -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().template get_ptr&lt;PointerType&gt;())
14772      {
14773          return get_ptr&lt;PointerType&gt;();
14774      }
14775      template &lt; typename ValueType,
14776                 detail::enable_if_t &lt;
14777                     !detail::is_basic_json&lt;ValueType&gt;::value&amp;&amp;
14778                     detail::has_from_json&lt;basic_json_t, ValueType&gt;::value,
14779                     int &gt; = 0 &gt;
14780      ValueType &amp; get_to(ValueType&amp; v) const noexcept(noexcept(
14781                  JSONSerializer&lt;ValueType&gt;::from_json(std::declval&lt;const basic_json_t&amp;&gt;(), v)))
14782      {
14783          JSONSerializer&lt;ValueType&gt;::from_json(*this, v);
14784          return v;
14785      }
14786      template&lt;typename ValueType,
14787               detail::enable_if_t &lt;
14788                   detail::is_basic_json&lt;ValueType&gt;::value,
14789                   int&gt; = 0&gt;
14790      ValueType &amp; get_to(ValueType&amp; v) const
14791      {
14792          v = *this;
14793          return v;
14794      }
14795      template &lt;
14796          typename T, std::size_t N,
14797          typename Array = T (&amp;)[N], 
14798          detail::enable_if_t &lt;
14799              detail::has_from_json&lt;basic_json_t, Array&gt;::value, int &gt; = 0 &gt;
14800      Array get_to(T (&amp;v)[N]) const 
14801      noexcept(noexcept(JSONSerializer&lt;Array&gt;::from_json(
14802                            std::declval&lt;const basic_json_t&amp;&gt;(), v)))
14803      {
14804          JSONSerializer&lt;Array&gt;::from_json(*this, v);
14805          return v;
14806      }
14807      template&lt;typename ReferenceType, typename std::enable_if&lt;
14808                   std::is_reference&lt;ReferenceType&gt;::value, int&gt;::type = 0&gt;
14809      ReferenceType get_ref()
14810      {
14811          return get_ref_impl&lt;ReferenceType&gt;(*this);
14812      }
14813      template &lt; typename ReferenceType, typename std::enable_if &lt;
14814                     std::is_reference&lt;ReferenceType&gt;::value&amp;&amp;
14815                     std::is_const&lt;typename std::remove_reference&lt;ReferenceType&gt;::type&gt;::value, int &gt;::type = 0 &gt;
14816      ReferenceType get_ref() const
14817      {
14818          return get_ref_impl&lt;ReferenceType&gt;(*this);
14819      }
14820      template &lt; typename ValueType, typename std::enable_if &lt;
14821                     detail::conjunction &lt;
14822                         detail::negation&lt;std::is_pointer&lt;ValueType&gt;&gt;,
14823                         detail::negation&lt;std::is_same&lt;ValueType, std::nullptr_t&gt;&gt;,
14824                         detail::negation&lt;std::is_same&lt;ValueType, detail::json_ref&lt;basic_json&gt;&gt;&gt;,
14825                                          detail::negation&lt;std::is_same&lt;ValueType, typename string_t::value_type&gt;&gt;,
14826                                          detail::negation&lt;detail::is_basic_json&lt;ValueType&gt;&gt;,
14827                                          detail::negation&lt;std::is_same&lt;ValueType, std::initializer_list&lt;typename string_t::value_type&gt;&gt;&gt;,
14828  #if defined(JSON_HAS_CPP_17) &amp;&amp; (defined(__GNUC__) || (defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1910 &amp;&amp; _MSC_VER &lt;= 1914))
14829                                                  detail::negation&lt;std::is_same&lt;ValueType, std::string_view&gt;&gt;,
14830  #endif
14831  #if defined(JSON_HAS_CPP_17)
14832                                                  detail::negation&lt;std::is_same&lt;ValueType, std::any&gt;&gt;,
14833  #endif
14834                                                  detail::is_detected_lazy&lt;detail::get_template_function, const basic_json_t&amp;, ValueType&gt;
14835                                                  &gt;::value, int &gt;::type = 0 &gt;
14836                                          JSON_EXPLICIT operator ValueType() const
14837      {
14838          return get&lt;ValueType&gt;();
14839      }
14840      binary_t&amp; get_binary()
14841      {
14842          if (!is_binary())
14843          {
14844              JSON_THROW(type_error::create(302, detail::concat(&quot;type must be binary, but is &quot;, type_name()), this));
14845          }
14846          return *get_ptr&lt;binary_t*&gt;();
14847      }
14848      const binary_t&amp; get_binary() const
14849      {
14850          if (!is_binary())
14851          {
14852              JSON_THROW(type_error::create(302, detail::concat(&quot;type must be binary, but is &quot;, type_name()), this));
14853          }
14854          return *get_ptr&lt;const binary_t*&gt;();
14855      }
14856      reference at(size_type idx)
14857      {
14858          if (JSON_HEDLEY_LIKELY(is_array()))
14859          {
14860              JSON_TRY
14861              {
14862                  return set_parent(m_value.array-&gt;at(idx));
14863              }
14864              JSON_CATCH (std::out_of_range&amp;)
14865              {
14866                  JSON_THROW(out_of_range::create(401, detail::concat(&quot;array index &quot;, std::to_string(idx), &quot; is out of range&quot;), this));
14867              }
14868          }
14869          else
14870          {
14871              JSON_THROW(type_error::create(304, detail::concat(&quot;cannot use at() with &quot;, type_name()), this));
14872          }
14873      }
14874      const_reference at(size_type idx) const
14875      {
14876          if (JSON_HEDLEY_LIKELY(is_array()))
14877          {
14878              JSON_TRY
14879              {
14880                  return m_value.array-&gt;at(idx);
14881              }
14882              JSON_CATCH (std::out_of_range&amp;)
14883              {
14884                  JSON_THROW(out_of_range::create(401, detail::concat(&quot;array index &quot;, std::to_string(idx), &quot; is out of range&quot;), this));
14885              }
14886          }
14887          else
14888          {
14889              JSON_THROW(type_error::create(304, detail::concat(&quot;cannot use at() with &quot;, type_name()), this));
14890          }
14891      }
14892      reference at(const typename object_t::key_type&amp; key)
14893      {
14894          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14895          {
14896              JSON_THROW(type_error::create(304, detail::concat(&quot;cannot use at() with &quot;, type_name()), this));
14897          }
14898          auto it = m_value.object-&gt;find(key);
14899          if (it == m_value.object-&gt;end())
14900          {
14901              JSON_THROW(out_of_range::create(403, detail::concat(&quot;key &#x27;&quot;, key, &quot;&#x27; not found&quot;), this));
14902          }
14903          return set_parent(it-&gt;second);
14904      }
14905      template&lt;class KeyType, detail::enable_if_t&lt;
14906                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int&gt; = 0&gt;
14907      reference at(KeyType &amp;&amp; key)
14908      {
14909          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14910          {
14911              JSON_THROW(type_error::create(304, detail::concat(&quot;cannot use at() with &quot;, type_name()), this));
14912          }
14913          auto it = m_value.object-&gt;find(std::forward&lt;KeyType&gt;(key));
14914          if (it == m_value.object-&gt;end())
14915          {
14916              JSON_THROW(out_of_range::create(403, detail::concat(&quot;key &#x27;&quot;, string_t(std::forward&lt;KeyType&gt;(key)), &quot;&#x27; not found&quot;), this));
14917          }
14918          return set_parent(it-&gt;second);
14919      }
14920      const_reference at(const typename object_t::key_type&amp; key) const
14921      {
14922          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14923          {
14924              JSON_THROW(type_error::create(304, detail::concat(&quot;cannot use at() with &quot;, type_name()), this));
14925          }
14926          auto it = m_value.object-&gt;find(key);
14927          if (it == m_value.object-&gt;end())
14928          {
14929              JSON_THROW(out_of_range::create(403, detail::concat(&quot;key &#x27;&quot;, key, &quot;&#x27; not found&quot;), this));
14930          }
14931          return it-&gt;second;
14932      }
14933      template&lt;class KeyType, detail::enable_if_t&lt;
14934                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int&gt; = 0&gt;
14935      const_reference at(KeyType &amp;&amp; key) const
14936      {
14937          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14938          {
14939              JSON_THROW(type_error::create(304, detail::concat(&quot;cannot use at() with &quot;, type_name()), this));
14940          }
14941          auto it = m_value.object-&gt;find(std::forward&lt;KeyType&gt;(key));
14942          if (it == m_value.object-&gt;end())
14943          {
14944              JSON_THROW(out_of_range::create(403, detail::concat(&quot;key &#x27;&quot;, string_t(std::forward&lt;KeyType&gt;(key)), &quot;&#x27; not found&quot;), this));
14945          }
14946          return it-&gt;second;
14947      }
14948      reference operator[](size_type idx)
14949      {
14950          if (is_null())
14951          {
14952              m_type = value_t::array;
14953              m_value.array = create&lt;array_t&gt;();
14954              assert_invariant();
14955          }
14956          if (JSON_HEDLEY_LIKELY(is_array()))
14957          {
14958              if (idx &gt;= m_value.array-&gt;size())
14959              {
14960  #if JSON_DIAGNOSTICS
14961                  const auto old_size = m_value.array-&gt;size();
14962                  const auto old_capacity = m_value.array-&gt;capacity();
14963  #endif
14964                  m_value.array-&gt;resize(idx + 1);
14965  #if JSON_DIAGNOSTICS
14966                  if (JSON_HEDLEY_UNLIKELY(m_value.array-&gt;capacity() != old_capacity))
14967                  {
14968                      set_parents();
14969                  }
14970                  else
14971                  {
14972                      set_parents(begin() + static_cast&lt;typename iterator::difference_type&gt;(old_size), static_cast&lt;typename iterator::difference_type&gt;(idx + 1 - old_size));
14973                  }
14974  #endif
14975                  assert_invariant();
14976              }
14977              return m_value.array-&gt;operator[](idx);
14978          }
14979          JSON_THROW(type_error::create(305, detail::concat(&quot;cannot use operator[] with a numeric argument with &quot;, type_name()), this));
14980      }
14981      const_reference operator[](size_type idx) const
14982      {
14983          if (JSON_HEDLEY_LIKELY(is_array()))
14984          {
14985              return m_value.array-&gt;operator[](idx);
14986          }
14987          JSON_THROW(type_error::create(305, detail::concat(&quot;cannot use operator[] with a numeric argument with &quot;, type_name()), this));
14988      }
14989      reference operator[](typename object_t::key_type key)
14990      {
14991          if (is_null())
14992          {
14993              m_type = value_t::object;
14994              m_value.object = create&lt;object_t&gt;();
14995              assert_invariant();
14996          }
14997          if (JSON_HEDLEY_LIKELY(is_object()))
14998          {
14999              auto result = m_value.object-&gt;emplace(std::move(key), nullptr);
15000              return set_parent(result.first-&gt;second);
15001          }
15002          JSON_THROW(type_error::create(305, detail::concat(&quot;cannot use operator[] with a string argument with &quot;, type_name()), this));
15003      }
15004      const_reference operator[](const typename object_t::key_type&amp; key) const
15005      {
15006          if (JSON_HEDLEY_LIKELY(is_object()))
15007          {
15008              auto it = m_value.object-&gt;find(key);
15009              JSON_ASSERT(it != m_value.object-&gt;end());
15010              return it-&gt;second;
15011          }
15012          JSON_THROW(type_error::create(305, detail::concat(&quot;cannot use operator[] with a string argument with &quot;, type_name()), this));
15013      }
15014      template&lt;typename T&gt;
15015      reference operator[](T* key)
15016      {
15017          return operator[](typename object_t::key_type(key));
15018      }
15019      template&lt;typename T&gt;
15020      const_reference operator[](T* key) const
15021      {
15022          return operator[](typename object_t::key_type(key));
15023      }
15024      template&lt;class KeyType, detail::enable_if_t&lt;
15025                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int &gt; = 0 &gt;
15026      reference operator[](KeyType &amp;&amp; key)
15027      {
15028          if (is_null())
15029          {
15030              m_type = value_t::object;
15031              m_value.object = create&lt;object_t&gt;();
15032              assert_invariant();
15033          }
15034          if (JSON_HEDLEY_LIKELY(is_object()))
15035          {
15036              auto result = m_value.object-&gt;emplace(std::forward&lt;KeyType&gt;(key), nullptr);
15037              return set_parent(result.first-&gt;second);
15038          }
15039          JSON_THROW(type_error::create(305, detail::concat(&quot;cannot use operator[] with a string argument with &quot;, type_name()), this));
15040      }
15041      template&lt;class KeyType, detail::enable_if_t&lt;
15042                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int &gt; = 0 &gt;
15043      const_reference operator[](KeyType &amp;&amp; key) const
15044      {
15045          if (JSON_HEDLEY_LIKELY(is_object()))
15046          {
15047              auto it = m_value.object-&gt;find(std::forward&lt;KeyType&gt;(key));
15048              JSON_ASSERT(it != m_value.object-&gt;end());
15049              return it-&gt;second;
15050          }
15051          JSON_THROW(type_error::create(305, detail::concat(&quot;cannot use operator[] with a string argument with &quot;, type_name()), this));
15052      }
15053    private:
15054      template&lt;typename KeyType&gt;
15055      using is_comparable_with_object_key = detail::is_comparable &lt;
15056          object_comparator_t, const typename object_t::key_type&amp;, KeyType &gt;;
15057      template&lt;typename ValueType&gt;
15058      using value_return_type = std::conditional &lt;
15059          detail::is_c_string_uncvref&lt;ValueType&gt;::value,
15060          string_t, typename std::decay&lt;ValueType&gt;::type &gt;;
15061    public:
15062      template &lt; class ValueType, detail::enable_if_t &lt;
15063                     !detail::is_transparent&lt;object_comparator_t&gt;::value
15064                     &amp;&amp; detail::is_getable&lt;basic_json_t, ValueType&gt;::value
15065                     &amp;&amp; !std::is_same&lt;value_t, detail::uncvref_t&lt;ValueType&gt;&gt;::value, int &gt; = 0 &gt;
15066      ValueType value(const typename object_t::key_type&amp; key, const ValueType&amp; default_value) const
15067      {
15068          if (JSON_HEDLEY_LIKELY(is_object()))
15069          {
15070              const auto it = find(key);
15071              if (it != end())
15072              {
15073                  return it-&gt;template get&lt;ValueType&gt;();
15074              }
15075              return default_value;
15076          }
15077          JSON_THROW(type_error::create(306, detail::concat(&quot;cannot use value() with &quot;, type_name()), this));
15078      }
15079      template &lt; class ValueType, class ReturnType = typename value_return_type&lt;ValueType&gt;::type,
15080                 detail::enable_if_t &lt;
15081                     !detail::is_transparent&lt;object_comparator_t&gt;::value
15082                     &amp;&amp; detail::is_getable&lt;basic_json_t, ReturnType&gt;::value
15083                     &amp;&amp; !std::is_same&lt;value_t, detail::uncvref_t&lt;ValueType&gt;&gt;::value, int &gt; = 0 &gt;
15084      ReturnType value(const typename object_t::key_type&amp; key, ValueType &amp;&amp; default_value) const
15085      {
15086          if (JSON_HEDLEY_LIKELY(is_object()))
15087          {
15088              const auto it = find(key);
15089              if (it != end())
15090              {
15091                  return it-&gt;template get&lt;ReturnType&gt;();
15092              }
15093              return std::forward&lt;ValueType&gt;(default_value);
15094          }
15095          JSON_THROW(type_error::create(306, detail::concat(&quot;cannot use value() with &quot;, type_name()), this));
15096      }
15097      template &lt; class ValueType, class KeyType, detail::enable_if_t &lt;
15098                     detail::is_transparent&lt;object_comparator_t&gt;::value
15099                     &amp;&amp; !detail::is_json_pointer&lt;KeyType&gt;::value
15100                     &amp;&amp; is_comparable_with_object_key&lt;KeyType&gt;::value
15101                     &amp;&amp; detail::is_getable&lt;basic_json_t, ValueType&gt;::value
15102                     &amp;&amp; !std::is_same&lt;value_t, detail::uncvref_t&lt;ValueType&gt;&gt;::value, int &gt; = 0 &gt;
15103      ValueType value(KeyType &amp;&amp; key, const ValueType&amp; default_value) const
15104      {
15105          if (JSON_HEDLEY_LIKELY(is_object()))
15106          {
15107              const auto it = find(std::forward&lt;KeyType&gt;(key));
15108              if (it != end())
15109              {
15110                  return it-&gt;template get&lt;ValueType&gt;();
15111              }
15112              return default_value;
15113          }
15114          JSON_THROW(type_error::create(306, detail::concat(&quot;cannot use value() with &quot;, type_name()), this));
15115      }
15116      template &lt; class ValueType, class KeyType, class ReturnType = typename value_return_type&lt;ValueType&gt;::type,
15117                 detail::enable_if_t &lt;
15118                     detail::is_transparent&lt;object_comparator_t&gt;::value
15119                     &amp;&amp; !detail::is_json_pointer&lt;KeyType&gt;::value
15120                     &amp;&amp; is_comparable_with_object_key&lt;KeyType&gt;::value
15121                     &amp;&amp; detail::is_getable&lt;basic_json_t, ReturnType&gt;::value
15122                     &amp;&amp; !std::is_same&lt;value_t, detail::uncvref_t&lt;ValueType&gt;&gt;::value, int &gt; = 0 &gt;
15123      ReturnType value(KeyType &amp;&amp; key, ValueType &amp;&amp; default_value) const
15124      {
15125          if (JSON_HEDLEY_LIKELY(is_object()))
15126          {
15127              const auto it = find(std::forward&lt;KeyType&gt;(key));
15128              if (it != end())
15129              {
15130                  return it-&gt;template get&lt;ReturnType&gt;();
15131              }
15132              return std::forward&lt;ValueType&gt;(default_value);
15133          }
15134          JSON_THROW(type_error::create(306, detail::concat(&quot;cannot use value() with &quot;, type_name()), this));
15135      }
15136      template &lt; class ValueType, detail::enable_if_t &lt;
15137                     detail::is_getable&lt;basic_json_t, ValueType&gt;::value
15138                     &amp;&amp; !std::is_same&lt;value_t, detail::uncvref_t&lt;ValueType&gt;&gt;::value, int &gt; = 0 &gt;
15139      ValueType value(const json_pointer&amp; ptr, const ValueType&amp; default_value) const
15140      {
15141          if (JSON_HEDLEY_LIKELY(is_object()))
15142          {
15143              JSON_TRY
15144              {
15145                  return ptr.get_checked(this).template get&lt;ValueType&gt;();
15146              }
15147              JSON_INTERNAL_CATCH (out_of_range&amp;)
15148              {
15149                  return default_value;
15150              }
15151          }
15152          JSON_THROW(type_error::create(306, detail::concat(&quot;cannot use value() with &quot;, type_name()), this));
15153      }
15154      template &lt; class ValueType, class ReturnType = typename value_return_type&lt;ValueType&gt;::type,
15155                 detail::enable_if_t &lt;
15156                     detail::is_getable&lt;basic_json_t, ReturnType&gt;::value
15157                     &amp;&amp; !std::is_same&lt;value_t, detail::uncvref_t&lt;ValueType&gt;&gt;::value, int &gt; = 0 &gt;
15158      ReturnType value(const json_pointer&amp; ptr, ValueType &amp;&amp; default_value) const
15159      {
15160          if (JSON_HEDLEY_LIKELY(is_object()))
15161          {
15162              JSON_TRY
15163              {
15164                  return ptr.get_checked(this).template get&lt;ReturnType&gt;();
15165              }
15166              JSON_INTERNAL_CATCH (out_of_range&amp;)
15167              {
15168                  return std::forward&lt;ValueType&gt;(default_value);
15169              }
15170          }
15171          JSON_THROW(type_error::create(306, detail::concat(&quot;cannot use value() with &quot;, type_name()), this));
15172      }
15173      template &lt; class ValueType, class BasicJsonType, detail::enable_if_t &lt;
15174                     detail::is_basic_json&lt;BasicJsonType&gt;::value
15175                     &amp;&amp; detail::is_getable&lt;basic_json_t, ValueType&gt;::value
15176                     &amp;&amp; !std::is_same&lt;value_t, detail::uncvref_t&lt;ValueType&gt;&gt;::value, int &gt; = 0 &gt;
15177      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer&lt;basic_json::string_t&gt;) 
15178      ValueType value(const ::nlohmann::json_pointer&lt;BasicJsonType&gt;&amp; ptr, const ValueType&amp; default_value) const
15179      {
15180          return value(ptr.convert(), default_value);
15181      }
15182      template &lt; class ValueType, class BasicJsonType, class ReturnType = typename value_return_type&lt;ValueType&gt;::type,
15183                 detail::enable_if_t &lt;
15184                     detail::is_basic_json&lt;BasicJsonType&gt;::value
15185                     &amp;&amp; detail::is_getable&lt;basic_json_t, ReturnType&gt;::value
15186                     &amp;&amp; !std::is_same&lt;value_t, detail::uncvref_t&lt;ValueType&gt;&gt;::value, int &gt; = 0 &gt;
15187      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer&lt;basic_json::string_t&gt;) 
15188      ReturnType value(const ::nlohmann::json_pointer&lt;BasicJsonType&gt;&amp; ptr, ValueType &amp;&amp; default_value) const
15189      {
15190          return value(ptr.convert(), std::forward&lt;ValueType&gt;(default_value));
15191      }
15192      reference front()
15193      {
15194          return *begin();
15195      }
15196      const_reference front() const
15197      {
15198          return *cbegin();
15199      }
15200      reference back()
15201      {
15202          auto tmp = end();
15203          --tmp;
15204          return *tmp;
15205      }
15206      const_reference back() const
15207      {
15208          auto tmp = cend();
15209          --tmp;
15210          return *tmp;
15211      }
15212      template &lt; class IteratorType, detail::enable_if_t &lt;
15213                     std::is_same&lt;IteratorType, typename basic_json_t::iterator&gt;::value ||
15214                     std::is_same&lt;IteratorType, typename basic_json_t::const_iterator&gt;::value, int &gt; = 0 &gt;
15215      IteratorType erase(IteratorType pos)
15216      {
15217          if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
15218          {
15219              JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, this));
15220          }
15221          IteratorType result = end();
15222          switch (m_type)
15223          {
15224              case value_t::boolean:
15225              case value_t::number_float:
15226              case value_t::number_integer:
15227              case value_t::number_unsigned:
15228              case value_t::string:
15229              case value_t::binary:
15230              {
15231                  if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
15232                  {
15233                      JSON_THROW(invalid_iterator::create(205, &quot;iterator out of range&quot;, this));
15234                  }
15235                  if (is_string())
15236                  {
15237                      AllocatorType&lt;string_t&gt; alloc;
15238                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.string);
15239                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.string, 1);
15240                      m_value.string = nullptr;
15241                  }
15242                  else if (is_binary())
15243                  {
15244                      AllocatorType&lt;binary_t&gt; alloc;
15245                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.binary);
15246                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.binary, 1);
15247                      m_value.binary = nullptr;
15248                  }
15249                  m_type = value_t::null;
15250                  assert_invariant();
15251                  break;
15252              }
15253              case value_t::object:
15254              {
15255                  result.m_it.object_iterator = m_value.object-&gt;erase(pos.m_it.object_iterator);
15256                  break;
15257              }
15258              case value_t::array:
15259              {
15260                  result.m_it.array_iterator = m_value.array-&gt;erase(pos.m_it.array_iterator);
15261                  break;
15262              }
15263              case value_t::null:
15264              case value_t::discarded:
15265              default:
15266                  JSON_THROW(type_error::create(307, detail::concat(&quot;cannot use erase() with &quot;, type_name()), this));
15267          }
15268          return result;
15269      }
15270      template &lt; class IteratorType, detail::enable_if_t &lt;
15271                     std::is_same&lt;IteratorType, typename basic_json_t::iterator&gt;::value ||
15272                     std::is_same&lt;IteratorType, typename basic_json_t::const_iterator&gt;::value, int &gt; = 0 &gt;
15273      IteratorType erase(IteratorType first, IteratorType last)
15274      {
15275          if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
15276          {
15277              JSON_THROW(invalid_iterator::create(203, &quot;iterators do not fit current value&quot;, this));
15278          }
15279          IteratorType result = end();
15280          switch (m_type)
15281          {
15282              case value_t::boolean:
15283              case value_t::number_float:
15284              case value_t::number_integer:
15285              case value_t::number_unsigned:
15286              case value_t::string:
15287              case value_t::binary:
15288              {
15289                  if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
15290                                         || !last.m_it.primitive_iterator.is_end()))
15291                  {
15292                      JSON_THROW(invalid_iterator::create(204, &quot;iterators out of range&quot;, this));
15293                  }
15294                  if (is_string())
15295                  {
15296                      AllocatorType&lt;string_t&gt; alloc;
15297                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.string);
15298                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.string, 1);
15299                      m_value.string = nullptr;
15300                  }
15301                  else if (is_binary())
15302                  {
15303                      AllocatorType&lt;binary_t&gt; alloc;
15304                      std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.binary);
15305                      std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.binary, 1);
15306                      m_value.binary = nullptr;
15307                  }
15308                  m_type = value_t::null;
15309                  assert_invariant();
15310                  break;
15311              }
15312              case value_t::object:
15313              {
15314                  result.m_it.object_iterator = m_value.object-&gt;erase(first.m_it.object_iterator,
15315                                                last.m_it.object_iterator);
15316                  break;
15317              }
15318              case value_t::array:
15319              {
15320                  result.m_it.array_iterator = m_value.array-&gt;erase(first.m_it.array_iterator,
15321                                               last.m_it.array_iterator);
15322                  break;
15323              }
15324              case value_t::null:
15325              case value_t::discarded:
15326              default:
15327                  JSON_THROW(type_error::create(307, detail::concat(&quot;cannot use erase() with &quot;, type_name()), this));
15328          }
15329          return result;
15330      }
15331    private:
15332      template &lt; typename KeyType, detail::enable_if_t &lt;
15333                     detail::has_erase_with_key_type&lt;basic_json_t, KeyType&gt;::value, int &gt; = 0 &gt;
15334      size_type erase_internal(KeyType &amp;&amp; key)
15335      {
15336          if (JSON_HEDLEY_UNLIKELY(!is_object()))
15337          {
15338              JSON_THROW(type_error::create(307, detail::concat(&quot;cannot use erase() with &quot;, type_name()), this));
15339          }
15340          return m_value.object-&gt;erase(std::forward&lt;KeyType&gt;(key));
15341      }
15342      template &lt; typename KeyType, detail::enable_if_t &lt;
15343                     !detail::has_erase_with_key_type&lt;basic_json_t, KeyType&gt;::value, int &gt; = 0 &gt;
15344      size_type erase_internal(KeyType &amp;&amp; key)
15345      {
15346          if (JSON_HEDLEY_UNLIKELY(!is_object()))
15347          {
15348              JSON_THROW(type_error::create(307, detail::concat(&quot;cannot use erase() with &quot;, type_name()), this));
15349          }
15350          const auto it = m_value.object-&gt;find(std::forward&lt;KeyType&gt;(key));
15351          if (it != m_value.object-&gt;end())
15352          {
15353              m_value.object-&gt;erase(it);
15354              return 1;
15355          }
15356          return 0;
15357      }
15358    public:
15359      size_type erase(const typename object_t::key_type&amp; key)
15360      {
15361          return erase_internal(key);
15362      }
15363      template&lt;class KeyType, detail::enable_if_t&lt;
15364                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int&gt; = 0&gt;
15365      size_type erase(KeyType &amp;&amp; key)
15366      {
15367          return erase_internal(std::forward&lt;KeyType&gt;(key));
15368      }
15369      void erase(const size_type idx)
15370      {
15371          if (JSON_HEDLEY_LIKELY(is_array()))
15372          {
15373              if (JSON_HEDLEY_UNLIKELY(idx &gt;= size()))
15374              {
15375                  JSON_THROW(out_of_range::create(401, detail::concat(&quot;array index &quot;, std::to_string(idx), &quot; is out of range&quot;), this));
15376              }
15377              m_value.array-&gt;erase(m_value.array-&gt;begin() + static_cast&lt;difference_type&gt;(idx));
15378          }
15379          else
15380          {
15381              JSON_THROW(type_error::create(307, detail::concat(&quot;cannot use erase() with &quot;, type_name()), this));
15382          }
15383      }
15384      iterator find(const typename object_t::key_type&amp; key)
15385      {
15386          auto result = end();
15387          if (is_object())
15388          {
15389              result.m_it.object_iterator = m_value.object-&gt;find(key);
15390          }
15391          return result;
15392      }
15393      const_iterator find(const typename object_t::key_type&amp; key) const
15394      {
15395          auto result = cend();
15396          if (is_object())
15397          {
15398              result.m_it.object_iterator = m_value.object-&gt;find(key);
15399          }
15400          return result;
15401      }
15402      template&lt;class KeyType, detail::enable_if_t&lt;
15403                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int&gt; = 0&gt;
15404      iterator find(KeyType &amp;&amp; key)
15405      {
15406          auto result = end();
15407          if (is_object())
15408          {
15409              result.m_it.object_iterator = m_value.object-&gt;find(std::forward&lt;KeyType&gt;(key));
15410          }
15411          return result;
15412      }
15413      template&lt;class KeyType, detail::enable_if_t&lt;
15414                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int&gt; = 0&gt;
15415      const_iterator find(KeyType &amp;&amp; key) const
15416      {
15417          auto result = cend();
15418          if (is_object())
15419          {
15420              result.m_it.object_iterator = m_value.object-&gt;find(std::forward&lt;KeyType&gt;(key));
15421          }
15422          return result;
15423      }
15424      size_type count(const typename object_t::key_type&amp; key) const
15425      {
15426          return is_object() ? m_value.object-&gt;count(key) : 0;
15427      }
15428      template&lt;class KeyType, detail::enable_if_t&lt;
15429                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int&gt; = 0&gt;
15430      size_type count(KeyType &amp;&amp; key) const
15431      {
15432          return is_object() ? m_value.object-&gt;count(std::forward&lt;KeyType&gt;(key)) : 0;
15433      }
15434      bool contains(const typename object_t::key_type&amp; key) const
15435      {
15436          return is_object() &amp;&amp; m_value.object-&gt;find(key) != m_value.object-&gt;end();
15437      }
15438      template&lt;class KeyType, detail::enable_if_t&lt;
15439                   detail::is_usable_as_basic_json_key_type&lt;basic_json_t, KeyType&gt;::value, int&gt; = 0&gt;
15440      bool contains(KeyType &amp;&amp; key) const
15441      {
15442          return is_object() &amp;&amp; m_value.object-&gt;find(std::forward&lt;KeyType&gt;(key)) != m_value.object-&gt;end();
15443      }
15444      bool contains(const json_pointer&amp; ptr) const
15445      {
15446          return ptr.contains(this);
15447      }
15448      template&lt;typename BasicJsonType, detail::enable_if_t&lt;detail::is_basic_json&lt;BasicJsonType&gt;::value, int&gt; = 0&gt;
15449      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer&lt;basic_json::string_t&gt;) 
15450      bool contains(const typename ::nlohmann::json_pointer&lt;BasicJsonType&gt;&amp; ptr) const
15451      {
15452          return ptr.contains(this);
15453      }
15454      iterator begin() noexcept
15455      {
15456          iterator result(this);
15457          result.set_begin();
15458          return result;
15459      }
15460      const_iterator begin() const noexcept
15461      {
15462          return cbegin();
15463      }
15464      const_iterator cbegin() const noexcept
15465      {
15466          const_iterator result(this);
15467          result.set_begin();
15468          return result;
15469      }
15470      iterator end() noexcept
15471      {
15472          iterator result(this);
15473          result.set_end();
15474          return result;
15475      }
15476      const_iterator end() const noexcept
15477      {
15478          return cend();
15479      }
15480      const_iterator cend() const noexcept
15481      {
15482          const_iterator result(this);
15483          result.set_end();
15484          return result;
15485      }
15486      reverse_iterator rbegin() noexcept
15487      {
15488          return reverse_iterator(end());
15489      }
15490      const_reverse_iterator rbegin() const noexcept
15491      {
15492          return crbegin();
15493      }
15494      reverse_iterator rend() noexcept
15495      {
15496          return reverse_iterator(begin());
15497      }
15498      const_reverse_iterator rend() const noexcept
15499      {
15500          return crend();
15501      }
15502      const_reverse_iterator crbegin() const noexcept
15503      {
15504          return const_reverse_iterator(cend());
15505      }
15506      const_reverse_iterator crend() const noexcept
15507      {
15508          return const_reverse_iterator(cbegin());
15509      }
15510    public:
15511      JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
15512      static iteration_proxy&lt;iterator&gt; iterator_wrapper(reference ref) noexcept
15513      {
15514          return ref.items();
15515      }
15516      JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
15517      static iteration_proxy&lt;const_iterator&gt; iterator_wrapper(const_reference ref) noexcept
15518      {
15519          return ref.items();
15520      }
15521      iteration_proxy&lt;iterator&gt; items() noexcept
15522      {
15523          return iteration_proxy&lt;iterator&gt;(*this);
15524      }
15525      iteration_proxy&lt;const_iterator&gt; items() const noexcept
15526      {
15527          return iteration_proxy&lt;const_iterator&gt;(*this);
15528      }
15529      bool empty() const noexcept
15530      {
15531          switch (m_type)
15532          {
15533              case value_t::null:
15534              {
15535                  return true;
15536              }
15537              case value_t::array:
15538              {
15539                  return m_value.array-&gt;empty();
15540              }
15541              case value_t::object:
15542              {
15543                  return m_value.object-&gt;empty();
15544              }
15545              case value_t::string:
15546              case value_t::boolean:
15547              case value_t::number_integer:
15548              case value_t::number_unsigned:
15549              case value_t::number_float:
15550              case value_t::binary:
15551              case value_t::discarded:
15552              default:
15553              {
15554                  return false;
15555              }
15556          }
15557      }
15558      size_type size() const noexcept
15559      {
15560          switch (m_type)
15561          {
15562              case value_t::null:
15563              {
15564                  return 0;
15565              }
15566              case value_t::array:
15567              {
15568                  return m_value.array-&gt;size();
15569              }
15570              case value_t::object:
15571              {
15572                  return m_value.object-&gt;size();
15573              }
15574              case value_t::string:
15575              case value_t::boolean:
15576              case value_t::number_integer:
15577              case value_t::number_unsigned:
15578              case value_t::number_float:
15579              case value_t::binary:
15580              case value_t::discarded:
15581              default:
15582              {
15583                  return 1;
15584              }
15585          }
15586      }
15587      size_type max_size() const noexcept
15588      {
15589          switch (m_type)
15590          {
15591              case value_t::array:
15592              {
15593                  return m_value.array-&gt;max_size();
15594              }
15595              case value_t::object:
15596              {
15597                  return m_value.object-&gt;max_size();
15598              }
15599              case value_t::null:
15600              case value_t::string:
15601              case value_t::boolean:
15602              case value_t::number_integer:
15603              case value_t::number_unsigned:
15604              case value_t::number_float:
15605              case value_t::binary:
15606              case value_t::discarded:
15607              default:
15608              {
15609                  return size();
15610              }
15611          }
15612      }
15613      void clear() noexcept
15614      {
15615          switch (m_type)
15616          {
15617              case value_t::number_integer:
15618              {
15619                  m_value.number_integer = 0;
15620                  break;
15621              }
15622              case value_t::number_unsigned:
15623              {
15624                  m_value.number_unsigned = 0;
15625                  break;
15626              }
15627              case value_t::number_float:
15628              {
15629                  m_value.number_float = 0.0;
15630                  break;
15631              }
15632              case value_t::boolean:
15633              {
15634                  m_value.boolean = false;
15635                  break;
15636              }
15637              case value_t::string:
15638              {
15639                  m_value.string-&gt;clear();
15640                  break;
15641              }
15642              case value_t::binary:
15643              {
15644                  m_value.binary-&gt;clear();
15645                  break;
15646              }
15647              case value_t::array:
15648              {
15649                  m_value.array-&gt;clear();
15650                  break;
15651              }
15652              case value_t::object:
15653              {
15654                  m_value.object-&gt;clear();
15655                  break;
15656              }
15657              case value_t::null:
15658              case value_t::discarded:
15659              default:
15660                  break;
15661          }
15662      }
15663      void push_back(basic_json&amp;&amp; val)
15664      {
15665          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
15666          {
15667              JSON_THROW(type_error::create(308, detail::concat(&quot;cannot use push_back() with &quot;, type_name()), this));
15668          }
15669          if (is_null())
15670          {
15671              m_type = value_t::array;
15672              m_value = value_t::array;
15673              assert_invariant();
15674          }
15675          const auto old_capacity = m_value.array-&gt;capacity();
15676          m_value.array-&gt;push_back(std::move(val));
15677          set_parent(m_value.array-&gt;back(), old_capacity);
15678      }
15679      reference operator+=(basic_json&amp;&amp; val)
15680      {
15681          push_back(std::move(val));
15682          return *this;
15683      }
15684      void push_back(const basic_json&amp; val)
15685      {
15686          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
15687          {
15688              JSON_THROW(type_error::create(308, detail::concat(&quot;cannot use push_back() with &quot;, type_name()), this));
15689          }
15690          if (is_null())
15691          {
15692              m_type = value_t::array;
15693              m_value = value_t::array;
15694              assert_invariant();
15695          }
15696          const auto old_capacity = m_value.array-&gt;capacity();
15697          m_value.array-&gt;push_back(val);
15698          set_parent(m_value.array-&gt;back(), old_capacity);
15699      }
15700      reference operator+=(const basic_json&amp; val)
15701      {
15702          push_back(val);
15703          return *this;
15704      }
15705      void push_back(const typename object_t::value_type&amp; val)
15706      {
15707          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
15708          {
15709              JSON_THROW(type_error::create(308, detail::concat(&quot;cannot use push_back() with &quot;, type_name()), this));
15710          }
15711          if (is_null())
15712          {
15713              m_type = value_t::object;
15714              m_value = value_t::object;
15715              assert_invariant();
15716          }
15717          auto res = m_value.object-&gt;insert(val);
15718          set_parent(res.first-&gt;second);
15719      }
15720      reference operator+=(const typename object_t::value_type&amp; val)
15721      {
15722          push_back(val);
15723          return *this;
15724      }
15725      void push_back(initializer_list_t init)
15726      {
15727          if (is_object() &amp;&amp; init.size() == 2 &amp;&amp; (*init.begin())-&gt;is_string())
15728          {
15729              basic_json&amp;&amp; key = init.begin()-&gt;moved_or_copied();
15730              push_back(typename object_t::value_type(
15731                            std::move(key.get_ref&lt;string_t&amp;&gt;()), (init.begin() + 1)-&gt;moved_or_copied()));
15732          }
15733          else
15734          {
15735              push_back(basic_json(init));
15736          }
15737      }
15738      reference operator+=(initializer_list_t init)
15739      {
15740          push_back(init);
15741          return *this;
15742      }
15743      template&lt;class... Args&gt;
15744      reference emplace_back(Args&amp;&amp; ... args)
15745      {
15746          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
15747          {
15748              JSON_THROW(type_error::create(311, detail::concat(&quot;cannot use emplace_back() with &quot;, type_name()), this));
15749          }
15750          if (is_null())
15751          {
15752              m_type = value_t::array;
15753              m_value = value_t::array;
15754              assert_invariant();
15755          }
15756          const auto old_capacity = m_value.array-&gt;capacity();
15757          m_value.array-&gt;emplace_back(std::forward&lt;Args&gt;(args)...);
15758          return set_parent(m_value.array-&gt;back(), old_capacity);
15759      }
15760      template&lt;class... Args&gt;
15761      std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp; ... args)
15762      {
15763          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
15764          {
15765              JSON_THROW(type_error::create(311, detail::concat(&quot;cannot use emplace() with &quot;, type_name()), this));
15766          }
15767          if (is_null())
15768          {
15769              m_type = value_t::object;
15770              m_value = value_t::object;
15771              assert_invariant();
15772          }
15773          auto res = m_value.object-&gt;emplace(std::forward&lt;Args&gt;(args)...);
15774          set_parent(res.first-&gt;second);
15775          auto it = begin();
15776          it.m_it.object_iterator = res.first;
15777          return {it, res.second};
15778      }
15779      template&lt;typename... Args&gt;
15780      iterator insert_iterator(const_iterator pos, Args&amp;&amp; ... args)
15781      {
15782          iterator result(this);
15783          JSON_ASSERT(m_value.array != nullptr);
15784          auto insert_pos = std::distance(m_value.array-&gt;begin(), pos.m_it.array_iterator);
15785          m_value.array-&gt;insert(pos.m_it.array_iterator, std::forward&lt;Args&gt;(args)...);
15786          result.m_it.array_iterator = m_value.array-&gt;begin() + insert_pos;
15787          set_parents();
15788          return result;
15789      }
15790      iterator insert(const_iterator pos, const basic_json&amp; val)
15791      {
15792          if (JSON_HEDLEY_LIKELY(is_array()))
15793          {
15794              if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
15795              {
15796                  JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, this));
15797              }
15798              return insert_iterator(pos, val);
15799          }
15800          JSON_THROW(type_error::create(309, detail::concat(&quot;cannot use insert() with &quot;, type_name()), this));
15801      }
15802      iterator insert(const_iterator pos, basic_json&amp;&amp; val)
15803      {
15804          return insert(pos, val);
15805      }
15806      iterator insert(const_iterator pos, size_type cnt, const basic_json&amp; val)
15807      {
15808          if (JSON_HEDLEY_LIKELY(is_array()))
15809          {
15810              if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
15811              {
15812                  JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, this));
15813              }
15814              return insert_iterator(pos, cnt, val);
15815          }
15816          JSON_THROW(type_error::create(309, detail::concat(&quot;cannot use insert() with &quot;, type_name()), this));
15817      }
15818      iterator insert(const_iterator pos, const_iterator first, const_iterator last)
15819      {
15820          if (JSON_HEDLEY_UNLIKELY(!is_array()))
15821          {
15822              JSON_THROW(type_error::create(309, detail::concat(&quot;cannot use insert() with &quot;, type_name()), this));
15823          }
15824          if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
15825          {
15826              JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, this));
15827          }
15828          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
15829          {
15830              JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;, this));
15831          }
15832          if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
15833          {
15834              JSON_THROW(invalid_iterator::create(211, &quot;passed iterators may not belong to container&quot;, this));
15835          }
15836          return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
15837      }
15838      iterator insert(const_iterator pos, initializer_list_t ilist)
15839      {
15840          if (JSON_HEDLEY_UNLIKELY(!is_array()))
15841          {
15842              JSON_THROW(type_error::create(309, detail::concat(&quot;cannot use insert() with &quot;, type_name()), this));
15843          }
15844          if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
15845          {
15846              JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;, this));
15847          }
15848          return insert_iterator(pos, ilist.begin(), ilist.end());
15849      }
15850      void insert(const_iterator first, const_iterator last)
15851      {
15852          if (JSON_HEDLEY_UNLIKELY(!is_object()))
15853          {
15854              JSON_THROW(type_error::create(309, detail::concat(&quot;cannot use insert() with &quot;, type_name()), this));
15855          }
15856          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
15857          {
15858              JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;, this));
15859          }
15860          if (JSON_HEDLEY_UNLIKELY(!first.m_object-&gt;is_object()))
15861          {
15862              JSON_THROW(invalid_iterator::create(202, &quot;iterators first and last must point to objects&quot;, this));
15863          }
15864          m_value.object-&gt;insert(first.m_it.object_iterator, last.m_it.object_iterator);
15865      }
15866      void update(const_reference j, bool merge_objects = false)
15867      {
15868          update(j.begin(), j.end(), merge_objects);
15869      }
15870      void update(const_iterator first, const_iterator last, bool merge_objects = false)
15871      {
15872          if (is_null())
15873          {
15874              m_type = value_t::object;
15875              m_value.object = create&lt;object_t&gt;();
15876              assert_invariant();
15877          }
15878          if (JSON_HEDLEY_UNLIKELY(!is_object()))
15879          {
15880              JSON_THROW(type_error::create(312, detail::concat(&quot;cannot use update() with &quot;, type_name()), this));
15881          }
15882          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
15883          {
15884              JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;, this));
15885          }
15886          if (JSON_HEDLEY_UNLIKELY(!first.m_object-&gt;is_object()))
15887          {
15888              JSON_THROW(type_error::create(312, detail::concat(&quot;cannot use update() with &quot;, first.m_object-&gt;type_name()), first.m_object));
15889          }
15890          for (auto it = first; it != last; ++it)
15891          {
15892              if (merge_objects &amp;&amp; it.value().is_object())
15893              {
15894                  auto it2 = m_value.object-&gt;find(it.key());
15895                  if (it2 != m_value.object-&gt;end())
15896                  {
15897                      it2-&gt;second.update(it.value(), true);
15898                      continue;
15899                  }
15900              }
15901              m_value.object-&gt;operator[](it.key()) = it.value();
15902  #if JSON_DIAGNOSTICS
15903              m_value.object-&gt;operator[](it.key()).m_parent = this;
15904  #endif
15905          }
15906      }
15907      void swap(reference other) noexcept (
15908          std::is_nothrow_move_constructible&lt;value_t&gt;::value&amp;&amp;
15909          std::is_nothrow_move_assignable&lt;value_t&gt;::value&amp;&amp;
15910          std::is_nothrow_move_constructible&lt;json_value&gt;::value&amp;&amp;
15911          std::is_nothrow_move_assignable&lt;json_value&gt;::value
15912      )
15913      {
15914          std::swap(m_type, other.m_type);
15915          std::swap(m_value, other.m_value);
15916          set_parents();
15917          other.set_parents();
15918          assert_invariant();
15919      }
15920      friend void swap(reference left, reference right) noexcept (
15921          std::is_nothrow_move_constructible&lt;value_t&gt;::value&amp;&amp;
15922          std::is_nothrow_move_assignable&lt;value_t&gt;::value&amp;&amp;
15923          std::is_nothrow_move_constructible&lt;json_value&gt;::value&amp;&amp;
15924          std::is_nothrow_move_assignable&lt;json_value&gt;::value
15925      )
15926      {
15927          left.swap(right);
15928      }
15929      void swap(array_t&amp; other) 
15930      {
15931          if (JSON_HEDLEY_LIKELY(is_array()))
15932          {
15933              using std::swap;
15934              swap(*(m_value.array), other);
15935          }
15936          else
15937          {
15938              JSON_THROW(type_error::create(310, detail::concat(&quot;cannot use swap(array_t&amp;) with &quot;, type_name()), this));
15939          }
15940      }
15941      void swap(object_t&amp; other) 
15942      {
15943          if (JSON_HEDLEY_LIKELY(is_object()))
15944          {
15945              using std::swap;
15946              swap(*(m_value.object), other);
15947          }
15948          else
15949          {
15950              JSON_THROW(type_error::create(310, detail::concat(&quot;cannot use swap(object_t&amp;) with &quot;, type_name()), this));
15951          }
15952      }
15953      void swap(string_t&amp; other) 
15954      {
15955          if (JSON_HEDLEY_LIKELY(is_string()))
15956          {
15957              using std::swap;
15958              swap(*(m_value.string), other);
15959          }
15960          else
15961          {
15962              JSON_THROW(type_error::create(310, detail::concat(&quot;cannot use swap(string_t&amp;) with &quot;, type_name()), this));
15963          }
15964      }
15965      void swap(binary_t&amp; other) 
15966      {
15967          if (JSON_HEDLEY_LIKELY(is_binary()))
15968          {
15969              using std::swap;
15970              swap(*(m_value.binary), other);
15971          }
15972          else
15973          {
15974              JSON_THROW(type_error::create(310, detail::concat(&quot;cannot use swap(binary_t&amp;) with &quot;, type_name()), this));
15975          }
15976      }
15977      void swap(typename binary_t::container_type&amp; other) 
15978      {
15979          if (JSON_HEDLEY_LIKELY(is_binary()))
15980          {
15981              using std::swap;
15982              swap(*(m_value.binary), other);
15983          }
15984          else
15985          {
15986              JSON_THROW(type_error::create(310, detail::concat(&quot;cannot use swap(binary_t::container_type&amp;) with &quot;, type_name()), this));
15987          }
15988      }
15989  #define JSON_IMPLEMENT_OPERATOR(op, null_result, unordered_result, default_result)                       \
15990      const auto lhs_type = lhs.type();                                                                    \
15991      const auto rhs_type = rhs.type();                                                                    \
15992      \
15993      if (lhs_type == rhs_type) &amp;bsol;* NOLINT(readability/braces) */                                           \
15994      {                                                                                                    \
15995          switch (lhs_type)                                                                                \
15996          {                                                                                                \
15997              case value_t::array:                                                                         \
15998                  return (*lhs.m_value.array) op (*rhs.m_value.array);                                     \
15999                  \
16000              case value_t::object:                                                                        \
16001                  return (*lhs.m_value.object) op (*rhs.m_value.object);                                   \
16002                  \
16003              case value_t::null:                                                                          \
16004                  return (null_result);                                                                    \
16005                  \
16006              case value_t::string:                                                                        \
16007                  return (*lhs.m_value.string) op (*rhs.m_value.string);                                   \
16008                  \
16009              case value_t::boolean:                                                                       \
16010                  return (lhs.m_value.boolean) op (rhs.m_value.boolean);                                   \
16011                  \
16012              case value_t::number_integer:                                                                \
16013                  return (lhs.m_value.number_integer) op (rhs.m_value.number_integer);                     \
16014                  \
16015              case value_t::number_unsigned:                                                               \
16016                  return (lhs.m_value.number_unsigned) op (rhs.m_value.number_unsigned);                   \
16017                  \
16018              case value_t::number_float:                                                                  \
16019                  return (lhs.m_value.number_float) op (rhs.m_value.number_float);                         \
16020                  \
16021              case value_t::binary:                                                                        \
16022                  return (*lhs.m_value.binary) op (*rhs.m_value.binary);                                   \
16023                  \
16024              case value_t::discarded:                                                                     \
16025              default:                                                                                     \
16026                  return (unordered_result);                                                               \
16027          }                                                                                                \
16028      }                                                                                                    \
16029      else if (lhs_type == value_t::number_integer &amp;&amp; rhs_type == value_t::number_float)                   \
16030      {                                                                                                    \
16031          return static_cast&lt;number_float_t&gt;(lhs.m_value.number_integer) op rhs.m_value.number_float;      \
16032      }                                                                                                    \
16033      else if (lhs_type == value_t::number_float &amp;&amp; rhs_type == value_t::number_integer)                   \
16034      {                                                                                                    \
16035          return lhs.m_value.number_float op static_cast&lt;number_float_t&gt;(rhs.m_value.number_integer);      \
16036      }                                                                                                    \
16037      else if (lhs_type == value_t::number_unsigned &amp;&amp; rhs_type == value_t::number_float)                  \
16038      {                                                                                                    \
16039          return static_cast&lt;number_float_t&gt;(lhs.m_value.number_unsigned) op rhs.m_value.number_float;     \
16040      }                                                                                                    \
16041      else if (lhs_type == value_t::number_float &amp;&amp; rhs_type == value_t::number_unsigned)                  \
16042      {                                                                                                    \
16043          return lhs.m_value.number_float op static_cast&lt;number_float_t&gt;(rhs.m_value.number_unsigned);     \
16044      }                                                                                                    \
16045      else if (lhs_type == value_t::number_unsigned &amp;&amp; rhs_type == value_t::number_integer)                \
16046      {                                                                                                    \
16047          return static_cast&lt;number_integer_t&gt;(lhs.m_value.number_unsigned) op rhs.m_value.number_integer; \
16048      }                                                                                                    \
16049      else if (lhs_type == value_t::number_integer &amp;&amp; rhs_type == value_t::number_unsigned)                \
16050      {                                                                                                    \
16051          return lhs.m_value.number_integer op static_cast&lt;number_integer_t&gt;(rhs.m_value.number_unsigned); \
16052      }                                                                                                    \
16053      else if(compares_unordered(lhs, rhs))\
16054      {\
16055          return (unordered_result);\
16056      }\
16057      \
16058      return (default_result);
16059    JSON_PRIVATE_UNLESS_TESTED:
16060      static bool compares_unordered(const_reference lhs, const_reference rhs, bool inverse = false) noexcept
16061      {
16062          if ((lhs.is_number_float() &amp;&amp; std::isnan(lhs.m_value.number_float) &amp;&amp; rhs.is_number())
16063                  || (rhs.is_number_float() &amp;&amp; std::isnan(rhs.m_value.number_float) &amp;&amp; lhs.is_number()))
16064          {
16065              return true;
16066          }
16067  #if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
16068          return (lhs.is_discarded() || rhs.is_discarded()) &amp;&amp; !inverse;
16069  #else
16070          static_cast&lt;void&gt;(inverse);
16071          return lhs.is_discarded() || rhs.is_discarded();
16072  #endif
16073      }
16074    private:
16075      bool compares_unordered(const_reference rhs, bool inverse = false) const noexcept
16076      {
16077          return compares_unordered(*this, rhs, inverse);
16078      }
16079    public:
16080  #if JSON_HAS_THREE_WAY_COMPARISON
16081      bool operator==(const_reference rhs) const noexcept
16082      {
16083  #ifdef __GNUC__
16084  #pragma GCC diagnostic push
16085  #pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;
16086  #endif
16087          const_reference lhs = *this;
16088          JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
16089  #ifdef __GNUC__
16090  #pragma GCC diagnostic pop
16091  #endif
16092      }
16093      template&lt;typename ScalarType&gt;
16094      requires std::is_scalar_v&lt;ScalarType&gt;
16095      bool operator==(ScalarType rhs) const noexcept
16096      {
16097          return *this == basic_json(rhs);
16098      }
16099      bool operator!=(const_reference rhs) const noexcept
16100      {
16101          if (compares_unordered(rhs, true))
16102          {
16103              return false;
16104          }
16105          return !operator==(rhs);
16106      }
16107      std::partial_ordering operator&lt;=&gt;(const_reference rhs) const noexcept 
16108      {
16109          const_reference lhs = *this;
16110          JSON_IMPLEMENT_OPERATOR(&lt;=&gt;, 
16111                                  std::partial_ordering::equivalent,
16112                                  std::partial_ordering::unordered,
16113                                  lhs_type &lt;=&gt; rhs_type) 
16114      }
16115      template&lt;typename ScalarType&gt;
16116      requires std::is_scalar_v&lt;ScalarType&gt;
16117      std::partial_ordering operator&lt;=&gt;(ScalarType rhs) const noexcept 
16118      {
16119          return *this &lt;=&gt; basic_json(rhs); 
16120      }
16121  #if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
16122      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
16123      bool operator&lt;=(const_reference rhs) const noexcept
16124      {
16125          if (compares_unordered(rhs, true))
16126          {
16127              return false;
16128          }
16129          return !(rhs &lt; *this);
16130      }
16131      template&lt;typename ScalarType&gt;
16132      requires std::is_scalar_v&lt;ScalarType&gt;
16133      bool operator&lt;=(ScalarType rhs) const noexcept
16134      {
16135          return *this &lt;= basic_json(rhs);
16136      }
16137      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
16138      bool operator&gt;=(const_reference rhs) const noexcept
16139      {
16140          if (compares_unordered(rhs, true))
16141          {
16142              return false;
16143          }
16144          return !(*this &lt; rhs);
16145      }
16146      template&lt;typename ScalarType&gt;
16147      requires std::is_scalar_v&lt;ScalarType&gt;
16148      bool operator&gt;=(ScalarType rhs) const noexcept
16149      {
16150          return *this &gt;= basic_json(rhs);
16151      }
16152  #endif
16153  #else
16154      friend bool operator==(const_reference lhs, const_reference rhs) noexcept
16155      {
16156  #ifdef __GNUC__
16157  #pragma GCC diagnostic push
16158  #pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;
16159  #endif
16160          JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
16161  #ifdef __GNUC__
16162  #pragma GCC diagnostic pop
16163  #endif
16164      }
16165      template&lt;typename ScalarType, typename std::enable_if&lt;
16166                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16167      friend bool operator==(const_reference lhs, ScalarType rhs) noexcept
16168      {
16169          return lhs == basic_json(rhs);
16170      }
16171      template&lt;typename ScalarType, typename std::enable_if&lt;
16172                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16173      friend bool operator==(ScalarType lhs, const_reference rhs) noexcept
16174      {
16175          return basic_json(lhs) == rhs;
16176      }
16177      friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
16178      {
16179          if (compares_unordered(lhs, rhs, true))
16180          {
16181              return false;
16182          }
16183          return !(lhs == rhs);
16184      }
16185      template&lt;typename ScalarType, typename std::enable_if&lt;
16186                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16187      friend bool operator!=(const_reference lhs, ScalarType rhs) noexcept
16188      {
16189          return lhs != basic_json(rhs);
16190      }
16191      template&lt;typename ScalarType, typename std::enable_if&lt;
16192                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16193      friend bool operator!=(ScalarType lhs, const_reference rhs) noexcept
16194      {
16195          return basic_json(lhs) != rhs;
16196      }
16197      friend bool operator&lt;(const_reference lhs, const_reference rhs) noexcept
16198      {
16199          JSON_IMPLEMENT_OPERATOR( &lt;, false, false, operator&lt;(lhs_type, rhs_type))
16200      }
16201      template&lt;typename ScalarType, typename std::enable_if&lt;
16202                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16203      friend bool operator&lt;(const_reference lhs, ScalarType rhs) noexcept
16204      {
16205          return lhs &lt; basic_json(rhs);
16206      }
16207      template&lt;typename ScalarType, typename std::enable_if&lt;
16208                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16209      friend bool operator&lt;(ScalarType lhs, const_reference rhs) noexcept
16210      {
16211          return basic_json(lhs) &lt; rhs;
16212      }
16213      friend bool operator&lt;=(const_reference lhs, const_reference rhs) noexcept
16214      {
16215          if (compares_unordered(lhs, rhs, true))
16216          {
16217              return false;
16218          }
16219          return !(rhs &lt; lhs);
16220      }
16221      template&lt;typename ScalarType, typename std::enable_if&lt;
16222                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16223      friend bool operator&lt;=(const_reference lhs, ScalarType rhs) noexcept
16224      {
16225          return lhs &lt;= basic_json(rhs);
16226      }
16227      template&lt;typename ScalarType, typename std::enable_if&lt;
16228                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16229      friend bool operator&lt;=(ScalarType lhs, const_reference rhs) noexcept
16230      {
16231          return basic_json(lhs) &lt;= rhs;
16232      }
16233      friend bool operator&gt;(const_reference lhs, const_reference rhs) noexcept
16234      {
16235          if (compares_unordered(lhs, rhs))
16236          {
16237              return false;
16238          }
16239          return !(lhs &lt;= rhs);
16240      }
16241      template&lt;typename ScalarType, typename std::enable_if&lt;
16242                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16243      friend bool operator&gt;(const_reference lhs, ScalarType rhs) noexcept
16244      {
16245          return lhs &gt; basic_json(rhs);
16246      }
16247      template&lt;typename ScalarType, typename std::enable_if&lt;
16248                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16249      friend bool operator&gt;(ScalarType lhs, const_reference rhs) noexcept
16250      {
16251          return basic_json(lhs) &gt; rhs;
16252      }
16253      friend bool operator&gt;=(const_reference lhs, const_reference rhs) noexcept
16254      {
16255          if (compares_unordered(lhs, rhs, true))
16256          {
16257              return false;
16258          }
16259          return !(lhs &lt; rhs);
16260      }
16261      template&lt;typename ScalarType, typename std::enable_if&lt;
16262                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16263      friend bool operator&gt;=(const_reference lhs, ScalarType rhs) noexcept
16264      {
16265          return lhs &gt;= basic_json(rhs);
16266      }
16267      template&lt;typename ScalarType, typename std::enable_if&lt;
16268                   std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
16269      friend bool operator&gt;=(ScalarType lhs, const_reference rhs) noexcept
16270      {
16271          return basic_json(lhs) &gt;= rhs;
16272      }
16273  #endif
16274  #undef JSON_IMPLEMENT_OPERATOR
16275  #ifndef JSON_NO_IO
16276      friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const basic_json&amp; j)
16277      {
16278          const bool pretty_print = o.width() &gt; 0;
16279          const auto indentation = pretty_print ? o.width() : 0;
16280          o.width(0);
16281          serializer s(detail::output_adapter&lt;char&gt;(o), o.fill());
16282          s.dump(j, pretty_print, false, static_cast&lt;unsigned int&gt;(indentation));
16283          return o;
16284      }
16285      JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;))
16286      friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp; j, std::ostream&amp; o)
16287      {
16288          return o &lt;&lt; j;
16289      }
16290  #endif  
16291      template&lt;typename InputType&gt;
16292      JSON_HEDLEY_WARN_UNUSED_RESULT
16293      static basic_json parse(InputType&amp;&amp; i,
16294                              const parser_callback_t cb = nullptr,
16295                              const bool allow_exceptions = true,
16296                              const bool ignore_comments = false)
16297      {
16298          basic_json result;
16299          parser(detail::input_adapter(std::forward&lt;InputType&gt;(i)), cb, allow_exceptions, ignore_comments).parse(true, result);
16300          return result;
16301      }
16302      template&lt;typename IteratorType&gt;
16303      JSON_HEDLEY_WARN_UNUSED_RESULT
16304      static basic_json parse(IteratorType first,
16305                              IteratorType last,
16306                              const parser_callback_t cb = nullptr,
16307                              const bool allow_exceptions = true,
16308                              const bool ignore_comments = false)
16309      {
16310          basic_json result;
16311          parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(true, result);
16312          return result;
16313      }
16314      JSON_HEDLEY_WARN_UNUSED_RESULT
16315      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
16316      static basic_json parse(detail::span_input_adapter&amp;&amp; i,
16317                              const parser_callback_t cb = nullptr,
16318                              const bool allow_exceptions = true,
16319                              const bool ignore_comments = false)
16320      {
16321          basic_json result;
16322          parser(i.get(), cb, allow_exceptions, ignore_comments).parse(true, result);
16323          return result;
16324      }
16325      template&lt;typename InputType&gt;
16326      static bool accept(InputType&amp;&amp; i,
16327                         const bool ignore_comments = false)
16328      {
16329          return parser(detail::input_adapter(std::forward&lt;InputType&gt;(i)), nullptr, false, ignore_comments).accept(true);
16330      }
16331      template&lt;typename IteratorType&gt;
16332      static bool accept(IteratorType first, IteratorType last,
16333                         const bool ignore_comments = false)
16334      {
16335          return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
16336      }
16337      JSON_HEDLEY_WARN_UNUSED_RESULT
16338      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
16339      static bool accept(detail::span_input_adapter&amp;&amp; i,
16340                         const bool ignore_comments = false)
16341      {
16342          return parser(i.get(), nullptr, false, ignore_comments).accept(true);
16343      }
16344      template &lt;typename InputType, typename SAX&gt;
16345      JSON_HEDLEY_NON_NULL(2)
16346      static bool sax_parse(InputType&amp;&amp; i, SAX* sax,
16347                            input_format_t format = input_format_t::json,
16348                            const bool strict = true,
16349                            const bool ignore_comments = false)
16350      {
16351          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
16352          return format == input_format_t::json
16353                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
16354                 : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia), format).sax_parse(format, sax, strict);
16355      }
16356      template&lt;class IteratorType, class SAX&gt;
16357      JSON_HEDLEY_NON_NULL(3)
16358      static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
16359                            input_format_t format = input_format_t::json,
16360                            const bool strict = true,
16361                            const bool ignore_comments = false)
16362      {
16363          auto ia = detail::input_adapter(std::move(first), std::move(last));
16364          return format == input_format_t::json
16365                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
16366                 : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia), format).sax_parse(format, sax, strict);
16367      }
16368      template &lt;typename SAX&gt;
16369      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
16370      JSON_HEDLEY_NON_NULL(2)
16371      static bool sax_parse(detail::span_input_adapter&amp;&amp; i, SAX* sax,
16372                            input_format_t format = input_format_t::json,
16373                            const bool strict = true,
16374                            const bool ignore_comments = false)
16375      {
16376          auto ia = i.get();
16377          return format == input_format_t::json
16378                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
16379                 : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia), format).sax_parse(format, sax, strict);
16380      }
16381  #ifndef JSON_NO_IO
16382      JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator&gt;&gt;(std::istream&amp;, basic_json&amp;))
16383      friend std::istream&amp; operator&lt;&lt;(basic_json&amp; j, std::istream&amp; i)
16384      {
16385          return operator&gt;&gt;(i, j);
16386      }
16387      friend std::istream&amp; operator&gt;&gt;(std::istream&amp; i, basic_json&amp; j)
16388      {
16389          parser(detail::input_adapter(i)).parse(false, j);
16390          return i;
16391      }
16392  #endif  
16393      JSON_HEDLEY_RETURNS_NON_NULL
16394      const char* type_name() const noexcept
16395      {
16396          switch (m_type)
16397          {
16398              case value_t::null:
16399                  return &quot;null&quot;;
16400              case value_t::object:
16401                  return &quot;object&quot;;
16402              case value_t::array:
16403                  return &quot;array&quot;;
16404              case value_t::string:
16405                  return &quot;string&quot;;
16406              case value_t::boolean:
16407                  return &quot;boolean&quot;;
16408              case value_t::binary:
16409                  return &quot;binary&quot;;
16410              case value_t::discarded:
16411                  return &quot;discarded&quot;;
16412              case value_t::number_integer:
16413              case value_t::number_unsigned:
16414              case value_t::number_float:
16415              default:
16416                  return &quot;number&quot;;
16417          }
16418      }
16419    JSON_PRIVATE_UNLESS_TESTED:
16420      value_t m_type = value_t::null;
16421      json_value m_value = {};
16422  #if JSON_DIAGNOSTICS
16423      basic_json* m_parent = nullptr;
16424  #endif
16425    public:
16426      static std::vector&lt;std::uint8_t&gt; to_cbor(const basic_json&amp; j)
16427      {
16428          std::vector&lt;std::uint8_t&gt; result;
16429          to_cbor(j, result);
16430          return result;
16431      }
16432      static void to_cbor(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o)
16433      {
16434          binary_writer&lt;std::uint8_t&gt;(o).write_cbor(j);
16435      }
16436      static void to_cbor(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o)
16437      {
16438          binary_writer&lt;char&gt;(o).write_cbor(j);
16439      }
16440      static std::vector&lt;std::uint8_t&gt; to_msgpack(const basic_json&amp; j)
16441      {
16442          std::vector&lt;std::uint8_t&gt; result;
16443          to_msgpack(j, result);
16444          return result;
16445      }
16446      static void to_msgpack(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o)
16447      {
16448          binary_writer&lt;std::uint8_t&gt;(o).write_msgpack(j);
16449      }
16450      static void to_msgpack(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o)
16451      {
16452          binary_writer&lt;char&gt;(o).write_msgpack(j);
16453      }
16454      static std::vector&lt;std::uint8_t&gt; to_ubjson(const basic_json&amp; j,
16455              const bool use_size = false,
16456              const bool use_type = false)
16457      {
16458          std::vector&lt;std::uint8_t&gt; result;
16459          to_ubjson(j, result, use_size, use_type);
16460          return result;
16461      }
16462      static void to_ubjson(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o,
16463                            const bool use_size = false, const bool use_type = false)
16464      {
16465          binary_writer&lt;std::uint8_t&gt;(o).write_ubjson(j, use_size, use_type);
16466      }
16467      static void to_ubjson(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o,
16468                            const bool use_size = false, const bool use_type = false)
16469      {
16470          binary_writer&lt;char&gt;(o).write_ubjson(j, use_size, use_type);
16471      }
16472      static std::vector&lt;std::uint8_t&gt; to_bjdata(const basic_json&amp; j,
16473              const bool use_size = false,
16474              const bool use_type = false)
16475      {
16476          std::vector&lt;std::uint8_t&gt; result;
16477          to_bjdata(j, result, use_size, use_type);
16478          return result;
16479      }
16480      static void to_bjdata(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o,
16481                            const bool use_size = false, const bool use_type = false)
16482      {
16483          binary_writer&lt;std::uint8_t&gt;(o).write_ubjson(j, use_size, use_type, true, true);
16484      }
16485      static void to_bjdata(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o,
16486                            const bool use_size = false, const bool use_type = false)
16487      {
16488          binary_writer&lt;char&gt;(o).write_ubjson(j, use_size, use_type, true, true);
16489      }
16490      static std::vector&lt;std::uint8_t&gt; to_bson(const basic_json&amp; j)
16491      {
16492          std::vector&lt;std::uint8_t&gt; result;
16493          to_bson(j, result);
16494          return result;
16495      }
16496      static void to_bson(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o)
16497      {
16498          binary_writer&lt;std::uint8_t&gt;(o).write_bson(j);
16499      }
16500      static void to_bson(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o)
16501      {
16502          binary_writer&lt;char&gt;(o).write_bson(j);
16503      }
16504      template&lt;typename InputType&gt;
16505      JSON_HEDLEY_WARN_UNUSED_RESULT
16506      static basic_json from_cbor(InputType&amp;&amp; i,
16507                                  const bool strict = true,
16508                                  const bool allow_exceptions = true,
16509                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
16510      {
16511          basic_json result;
16512          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16513          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
16514          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);
16515          return res ? result : basic_json(value_t::discarded);
16516      }
16517      template&lt;typename IteratorType&gt;
16518      JSON_HEDLEY_WARN_UNUSED_RESULT
16519      static basic_json from_cbor(IteratorType first, IteratorType last,
16520                                  const bool strict = true,
16521                                  const bool allow_exceptions = true,
16522                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
16523      {
16524          basic_json result;
16525          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16526          auto ia = detail::input_adapter(std::move(first), std::move(last));
16527          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);
16528          return res ? result : basic_json(value_t::discarded);
16529      }
16530      template&lt;typename T&gt;
16531      JSON_HEDLEY_WARN_UNUSED_RESULT
16532      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
16533      static basic_json from_cbor(const T* ptr, std::size_t len,
16534                                  const bool strict = true,
16535                                  const bool allow_exceptions = true,
16536                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
16537      {
16538          return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
16539      }
16540      JSON_HEDLEY_WARN_UNUSED_RESULT
16541      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
16542      static basic_json from_cbor(detail::span_input_adapter&amp;&amp; i,
16543                                  const bool strict = true,
16544                                  const bool allow_exceptions = true,
16545                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
16546      {
16547          basic_json result;
16548          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16549          auto ia = i.get();
16550          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);
16551          return res ? result : basic_json(value_t::discarded);
16552      }
16553      template&lt;typename InputType&gt;
16554      JSON_HEDLEY_WARN_UNUSED_RESULT
16555      static basic_json from_msgpack(InputType&amp;&amp; i,
16556                                     const bool strict = true,
16557                                     const bool allow_exceptions = true)
16558      {
16559          basic_json result;
16560          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16561          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
16562          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &amp;sdp, strict);
16563          return res ? result : basic_json(value_t::discarded);
16564      }
16565      template&lt;typename IteratorType&gt;
16566      JSON_HEDLEY_WARN_UNUSED_RESULT
16567      static basic_json from_msgpack(IteratorType first, IteratorType last,
16568                                     const bool strict = true,
16569                                     const bool allow_exceptions = true)
16570      {
16571          basic_json result;
16572          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16573          auto ia = detail::input_adapter(std::move(first), std::move(last));
16574          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &amp;sdp, strict);
16575          return res ? result : basic_json(value_t::discarded);
16576      }
16577      template&lt;typename T&gt;
16578      JSON_HEDLEY_WARN_UNUSED_RESULT
16579      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
16580      static basic_json from_msgpack(const T* ptr, std::size_t len,
16581                                     const bool strict = true,
16582                                     const bool allow_exceptions = true)
16583      {
16584          return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
16585      }
16586      JSON_HEDLEY_WARN_UNUSED_RESULT
16587      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
16588      static basic_json from_msgpack(detail::span_input_adapter&amp;&amp; i,
16589                                     const bool strict = true,
16590                                     const bool allow_exceptions = true)
16591      {
16592          basic_json result;
16593          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16594          auto ia = i.get();
16595          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &amp;sdp, strict);
16596          return res ? result : basic_json(value_t::discarded);
16597      }
16598      template&lt;typename InputType&gt;
16599      JSON_HEDLEY_WARN_UNUSED_RESULT
16600      static basic_json from_ubjson(InputType&amp;&amp; i,
16601                                    const bool strict = true,
16602                                    const bool allow_exceptions = true)
16603      {
16604          basic_json result;
16605          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16606          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
16607          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &amp;sdp, strict);
16608          return res ? result : basic_json(value_t::discarded);
16609      }
16610      template&lt;typename IteratorType&gt;
16611      JSON_HEDLEY_WARN_UNUSED_RESULT
16612      static basic_json from_ubjson(IteratorType first, IteratorType last,
16613                                    const bool strict = true,
16614                                    const bool allow_exceptions = true)
16615      {
16616          basic_json result;
16617          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16618          auto ia = detail::input_adapter(std::move(first), std::move(last));
16619          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &amp;sdp, strict);
16620          return res ? result : basic_json(value_t::discarded);
16621      }
16622      template&lt;typename T&gt;
16623      JSON_HEDLEY_WARN_UNUSED_RESULT
16624      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
16625      static basic_json from_ubjson(const T* ptr, std::size_t len,
16626                                    const bool strict = true,
16627                                    const bool allow_exceptions = true)
16628      {
16629          return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
16630      }
16631      JSON_HEDLEY_WARN_UNUSED_RESULT
16632      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
16633      static basic_json from_ubjson(detail::span_input_adapter&amp;&amp; i,
16634                                    const bool strict = true,
16635                                    const bool allow_exceptions = true)
16636      {
16637          basic_json result;
16638          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16639          auto ia = i.get();
16640          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &amp;sdp, strict);
16641          return res ? result : basic_json(value_t::discarded);
16642      }
16643      template&lt;typename InputType&gt;
16644      JSON_HEDLEY_WARN_UNUSED_RESULT
16645      static basic_json from_bjdata(InputType&amp;&amp; i,
16646                                    const bool strict = true,
16647                                    const bool allow_exceptions = true)
16648      {
16649          basic_json result;
16650          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16651          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
16652          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &amp;sdp, strict);
16653          return res ? result : basic_json(value_t::discarded);
16654      }
16655      template&lt;typename IteratorType&gt;
16656      JSON_HEDLEY_WARN_UNUSED_RESULT
16657      static basic_json from_bjdata(IteratorType first, IteratorType last,
16658                                    const bool strict = true,
16659                                    const bool allow_exceptions = true)
16660      {
16661          basic_json result;
16662          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16663          auto ia = detail::input_adapter(std::move(first), std::move(last));
16664          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &amp;sdp, strict);
16665          return res ? result : basic_json(value_t::discarded);
16666      }
16667      template&lt;typename InputType&gt;
16668      JSON_HEDLEY_WARN_UNUSED_RESULT
16669      static basic_json from_bson(InputType&amp;&amp; i,
16670                                  const bool strict = true,
16671                                  const bool allow_exceptions = true)
16672      {
16673          basic_json result;
16674          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16675          auto ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));
16676          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &amp;sdp, strict);
16677          return res ? result : basic_json(value_t::discarded);
16678      }
16679      template&lt;typename IteratorType&gt;
16680      JSON_HEDLEY_WARN_UNUSED_RESULT
16681      static basic_json from_bson(IteratorType first, IteratorType last,
16682                                  const bool strict = true,
16683                                  const bool allow_exceptions = true)
16684      {
16685          basic_json result;
16686          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16687          auto ia = detail::input_adapter(std::move(first), std::move(last));
16688          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &amp;sdp, strict);
16689          return res ? result : basic_json(value_t::discarded);
16690      }
16691      template&lt;typename T&gt;
16692      JSON_HEDLEY_WARN_UNUSED_RESULT
16693      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
16694      static basic_json from_bson(const T* ptr, std::size_t len,
16695                                  const bool strict = true,
16696                                  const bool allow_exceptions = true)
16697      {
16698          return from_bson(ptr, ptr + len, strict, allow_exceptions);
16699      }
16700      JSON_HEDLEY_WARN_UNUSED_RESULT
16701      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
16702      static basic_json from_bson(detail::span_input_adapter&amp;&amp; i,
16703                                  const bool strict = true,
16704                                  const bool allow_exceptions = true)
16705      {
16706          basic_json result;
16707          detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);
16708          auto ia = i.get();
16709          const bool res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &amp;sdp, strict);
16710          return res ? result : basic_json(value_t::discarded);
16711      }
16712      reference operator[](const json_pointer&amp; ptr)
16713      {
16714          return ptr.get_unchecked(this);
16715      }
16716      template&lt;typename BasicJsonType, detail::enable_if_t&lt;detail::is_basic_json&lt;BasicJsonType&gt;::value, int&gt; = 0&gt;
16717      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer&lt;basic_json::string_t&gt;) 
16718      reference operator[](const ::nlohmann::json_pointer&lt;BasicJsonType&gt;&amp; ptr)
16719      {
16720          return ptr.get_unchecked(this);
16721      }
16722      const_reference operator[](const json_pointer&amp; ptr) const
16723      {
16724          return ptr.get_unchecked(this);
16725      }
16726      template&lt;typename BasicJsonType, detail::enable_if_t&lt;detail::is_basic_json&lt;BasicJsonType&gt;::value, int&gt; = 0&gt;
16727      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer&lt;basic_json::string_t&gt;) 
16728      const_reference operator[](const ::nlohmann::json_pointer&lt;BasicJsonType&gt;&amp; ptr) const
16729      {
16730          return ptr.get_unchecked(this);
16731      }
16732      reference at(const json_pointer&amp; ptr)
16733      {
16734          return ptr.get_checked(this);
16735      }
16736      template&lt;typename BasicJsonType, detail::enable_if_t&lt;detail::is_basic_json&lt;BasicJsonType&gt;::value, int&gt; = 0&gt;
16737      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer&lt;basic_json::string_t&gt;) 
16738      reference at(const ::nlohmann::json_pointer&lt;BasicJsonType&gt;&amp; ptr)
16739      {
16740          return ptr.get_checked(this);
16741      }
16742      const_reference at(const json_pointer&amp; ptr) const
16743      {
16744          return ptr.get_checked(this);
16745      }
16746      template&lt;typename BasicJsonType, detail::enable_if_t&lt;detail::is_basic_json&lt;BasicJsonType&gt;::value, int&gt; = 0&gt;
16747      JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer&lt;basic_json::string_t&gt;) 
16748      const_reference at(const ::nlohmann::json_pointer&lt;BasicJsonType&gt;&amp; ptr) const
16749      {
16750          return ptr.get_checked(this);
16751      }
16752      basic_json flatten() const
16753      {
16754          basic_json result(value_t::object);
16755          json_pointer::flatten(&quot;&quot;, *this, result);
16756          return result;
16757      }
16758      basic_json unflatten() const
16759      {
16760          return json_pointer::unflatten(*this);
16761      }
16762      void patch_inplace(const basic_json&amp; json_patch)
16763      {
16764          basic_json&amp; result = *this;
16765          enum class patch_operations {add, remove, replace, move, copy, test, invalid};
16766          const auto get_op = [](const std::string &amp; op)
16767          {
16768              if (op == &quot;add&quot;)
16769              {
16770                  return patch_operations::add;
16771              }
16772              if (op == &quot;remove&quot;)
16773              {
16774                  return patch_operations::remove;
16775              }
16776              if (op == &quot;replace&quot;)
16777              {
16778                  return patch_operations::replace;
16779              }
16780              if (op == &quot;move&quot;)
16781              {
16782                  return patch_operations::move;
16783              }
16784              if (op == &quot;copy&quot;)
16785              {
16786                  return patch_operations::copy;
16787              }
16788              if (op == &quot;test&quot;)
16789              {
16790                  return patch_operations::test;
16791              }
16792              return patch_operations::invalid;
16793          };
16794          const auto operation_add = [&amp;result](json_pointer &amp; ptr, basic_json val)
16795          {
16796              if (ptr.empty())
16797              {
16798                  result = val;
16799                  return;
16800              }
16801              json_pointer top_pointer = ptr.top();
16802              if (top_pointer != ptr)
16803              {
16804                  result.at(top_pointer);
16805              }
16806              const auto last_path = ptr.back();
16807              ptr.pop_back();
16808              basic_json&amp; parent = result.at(ptr);
16809              switch (parent.m_type)
16810              {
16811                  case value_t::null:
16812                  case value_t::object:
16813                  {
16814                      parent[last_path] = val;
16815                      break;
16816                  }
16817                  case value_t::array:
16818                  {
16819                      if (last_path == &quot;-&quot;)
16820                      {
16821                          parent.push_back(val);
16822                      }
16823                      else
16824                      {
16825                          const auto idx = json_pointer::template array_index&lt;basic_json_t&gt;(last_path);
16826                          if (JSON_HEDLEY_UNLIKELY(idx &gt; parent.size()))
16827                          {
16828                              JSON_THROW(out_of_range::create(401, detail::concat(&quot;array index &quot;, std::to_string(idx), &quot; is out of range&quot;), &amp;parent));
16829                          }
16830                          parent.insert(parent.begin() + static_cast&lt;difference_type&gt;(idx), val);
16831                      }
16832                      break;
16833                  }
16834                  case value_t::string: 
16835                  case value_t::boolean: 
16836                  case value_t::number_integer: 
16837                  case value_t::number_unsigned: 
16838                  case value_t::number_float: 
16839                  case value_t::binary: 
16840                  case value_t::discarded: 
16841                  default:            
16842                      JSON_ASSERT(false); 
16843              }
16844          };
16845          const auto operation_remove = [this, &amp;result](json_pointer &amp; ptr)
16846          {
16847              const auto last_path = ptr.back();
16848              ptr.pop_back();
16849              basic_json&amp; parent = result.at(ptr);
16850              if (parent.is_object())
16851              {
16852                  auto it = parent.find(last_path);
16853                  if (JSON_HEDLEY_LIKELY(it != parent.end()))
16854                  {
16855                      parent.erase(it);
16856                  }
16857                  else
16858                  {
16859                      JSON_THROW(out_of_range::create(403, detail::concat(&quot;key &#x27;&quot;, last_path, &quot;&#x27; not found&quot;), this));
16860                  }
16861              }
16862              else if (parent.is_array())
16863              {
16864                  parent.erase(json_pointer::template array_index&lt;basic_json_t&gt;(last_path));
16865              }
16866          };
16867          if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
16868          {
16869              JSON_THROW(parse_error::create(104, 0, &quot;JSON patch must be an array of objects&quot;, &amp;json_patch));
16870          }
16871          for (const auto&amp; val : json_patch)
16872          {
16873              const auto get_value = [&amp;val](const std::string &amp; op,
16874                                            const std::string &amp; member,
16875                                            bool string_type) -&gt; basic_json &amp;
16876              {
16877                  auto it = val.m_value.object-&gt;find(member);
16878                  const auto error_msg = (op == &quot;op&quot;) ? &quot;operation&quot; : detail::concat(&quot;operation &#x27;&quot;, op, &#x27;\&#x27;&#x27;);
16879                  if (JSON_HEDLEY_UNLIKELY(it == val.m_value.object-&gt;end()))
16880                  {
16881                      JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, &quot; must have member &#x27;&quot;, member, &quot;&#x27;&quot;), &amp;val));
16882                  }
16883                  if (JSON_HEDLEY_UNLIKELY(string_type &amp;&amp; !it-&gt;second.is_string()))
16884                  {
16885                      JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, &quot; must have string member &#x27;&quot;, member, &quot;&#x27;&quot;), &amp;val));
16886                  }
16887                  return it-&gt;second;
16888              };
16889              if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
16890              {
16891                  JSON_THROW(parse_error::create(104, 0, &quot;JSON patch must be an array of objects&quot;, &amp;val));
16892              }
16893              const auto op = get_value(&quot;op&quot;, &quot;op&quot;, true).template get&lt;std::string&gt;();
16894              const auto path = get_value(op, &quot;path&quot;, true).template get&lt;std::string&gt;();
16895              json_pointer ptr(path);
16896              switch (get_op(op))
16897              {
16898                  case patch_operations::add:
16899                  {
16900                      operation_add(ptr, get_value(&quot;add&quot;, &quot;value&quot;, false));
16901                      break;
16902                  }
16903                  case patch_operations::remove:
16904                  {
16905                      operation_remove(ptr);
16906                      break;
16907                  }
16908                  case patch_operations::replace:
16909                  {
16910                      result.at(ptr) = get_value(&quot;replace&quot;, &quot;value&quot;, false);
16911                      break;
16912                  }
16913                  case patch_operations::move:
16914                  {
16915                      const auto from_path = get_value(&quot;move&quot;, &quot;from&quot;, true).template get&lt;std::string&gt;();
16916                      json_pointer from_ptr(from_path);
16917                      basic_json v = result.at(from_ptr);
16918                      operation_remove(from_ptr);
16919                      operation_add(ptr, v);
16920                      break;
16921                  }
16922                  case patch_operations::copy:
16923                  {
16924                      const auto from_path = get_value(&quot;copy&quot;, &quot;from&quot;, true).template get&lt;std::string&gt;();
16925                      const json_pointer from_ptr(from_path);
16926                      basic_json v = result.at(from_ptr);
16927                      operation_add(ptr, v);
16928                      break;
16929                  }
16930                  case patch_operations::test:
16931                  {
16932                      bool success = false;
16933                      JSON_TRY
16934                      {
16935                          success = (result.at(ptr) == get_value(&quot;test&quot;, &quot;value&quot;, false));
16936                      }
16937                      JSON_INTERNAL_CATCH (out_of_range&amp;)
16938                      {
16939                      }
16940                      if (JSON_HEDLEY_UNLIKELY(!success))
16941                      {
16942                          JSON_THROW(other_error::create(501, detail::concat(&quot;unsuccessful: &quot;, val.dump()), &amp;val));
16943                      }
16944                      break;
16945                  }
16946                  case patch_operations::invalid:
16947                  default:
16948                  {
16949                      JSON_THROW(parse_error::create(105, 0, detail::concat(&quot;operation value &#x27;&quot;, op, &quot;&#x27; is invalid&quot;), &amp;val));
16950                  }
16951              }
16952          }
16953      }
16954      basic_json patch(const basic_json&amp; json_patch) const
16955      {
16956          basic_json result = *this;
16957          result.patch_inplace(json_patch);
16958          return result;
16959      }
16960      JSON_HEDLEY_WARN_UNUSED_RESULT
16961      static basic_json diff(const basic_json&amp; source, const basic_json&amp; target,
16962                             const std::string&amp; path = &quot;&quot;)
16963      {
16964          basic_json result(value_t::array);
16965          if (source == target)
16966          {
16967              return result;
16968          }
16969          if (source.type() != target.type())
16970          {
16971              result.push_back(
16972              {
16973                  {&quot;op&quot;, &quot;replace&quot;}, {&quot;path&quot;, path}, {&quot;value&quot;, target}
16974              });
16975              return result;
16976          }
16977          switch (source.type())
16978          {
16979              case value_t::array:
16980              {
16981                  std::size_t i = 0;
16982                  while (i &lt; source.size() &amp;&amp; i &lt; target.size())
16983                  {
16984                      auto temp_diff = diff(source[i], target[i], detail::concat(path, &#x27;/&#x27;, std::to_string(i)));
16985                      result.insert(result.end(), temp_diff.begin(), temp_diff.end());
16986                      ++i;
16987                  }
16988                  const auto end_index = static_cast&lt;difference_type&gt;(result.size());
16989                  while (i &lt; source.size())
16990                  {
16991                      result.insert(result.begin() + end_index, object(
16992                      {
16993                          {&quot;op&quot;, &quot;remove&quot;},
16994                          {&quot;path&quot;, detail::concat(path, &#x27;/&#x27;, std::to_string(i))}
16995                      }));
16996                      ++i;
16997                  }
16998                  while (i &lt; target.size())
16999                  {
17000                      result.push_back(
17001                      {
17002                          {&quot;op&quot;, &quot;add&quot;},
17003                          {&quot;path&quot;, detail::concat(path, &quot;/-&quot;)},
17004                          {&quot;value&quot;, target[i]}
17005                      });
17006                      ++i;
17007                  }
17008                  break;
17009              }
17010              case value_t::object:
17011              {
17012                  for (auto it = source.cbegin(); it != source.cend(); ++it)
17013                  {
17014                      const auto path_key = detail::concat(path, &#x27;/&#x27;, detail::escape(it.key()));
17015                      if (target.find(it.key()) != target.end())
17016                      {
17017                          auto temp_diff = diff(it.value(), target[it.key()], path_key);
17018                          result.insert(result.end(), temp_diff.begin(), temp_diff.end());
17019                      }
17020                      else
17021                      {
17022                          result.push_back(object(
17023                          {
17024                              {&quot;op&quot;, &quot;remove&quot;}, {&quot;path&quot;, path_key}
17025                          }));
17026                      }
17027                  }
17028                  for (auto it = target.cbegin(); it != target.cend(); ++it)
17029                  {
17030                      if (source.find(it.key()) == source.end())
17031                      {
17032                          const auto path_key = detail::concat(path, &#x27;/&#x27;, detail::escape(it.key()));
17033                          result.push_back(
17034                          {
17035                              {&quot;op&quot;, &quot;add&quot;}, {&quot;path&quot;, path_key},
17036                              {&quot;value&quot;, it.value()}
17037                          });
17038                      }
17039                  }
17040                  break;
17041              }
17042              case value_t::null:
17043              case value_t::string:
17044              case value_t::boolean:
17045              case value_t::number_integer:
17046              case value_t::number_unsigned:
17047              case value_t::number_float:
17048              case value_t::binary:
17049              case value_t::discarded:
17050              default:
17051              {
17052                  result.push_back(
17053                  {
17054                      {&quot;op&quot;, &quot;replace&quot;}, {&quot;path&quot;, path}, {&quot;value&quot;, target}
17055                  });
17056                  break;
17057              }
17058          }
17059          return result;
17060      }
17061      void merge_patch(const basic_json&amp; apply_patch)
17062      {
17063          if (apply_patch.is_object())
17064          {
17065              if (!is_object())
17066              {
17067                  *this = object();
17068              }
17069              for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
17070              {
17071                  if (it.value().is_null())
17072                  {
17073                      erase(it.key());
17074                  }
17075                  else
17076                  {
17077                      operator[](it.key()).merge_patch(it.value());
17078                  }
17079              }
17080          }
17081          else
17082          {
17083              *this = apply_patch;
17084          }
17085      }
17086  };
17087  NLOHMANN_BASIC_JSON_TPL_DECLARATION
17088  std::string to_string(const NLOHMANN_BASIC_JSON_TPL&amp; j)
17089  {
17090      return j.dump();
17091  }
17092  inline namespace literals
17093  {
17094  inline namespace json_literals
17095  {
17096  JSON_HEDLEY_NON_NULL(1)
17097  inline nlohmann::json operator &quot;&quot; _json(const char* s, std::size_t n)
17098  {
17099      return nlohmann::json::parse(s, s + n);
17100  }
17101  JSON_HEDLEY_NON_NULL(1)
17102  inline nlohmann::json::json_pointer operator &quot;&quot; _json_pointer(const char* s, std::size_t n)
17103  {
17104      return nlohmann::json::json_pointer(std::string(s, n));
17105  }
17106  }  
17107  }  
17108  NLOHMANN_JSON_NAMESPACE_END
17109  namespace std 
17110  {
17111  NLOHMANN_BASIC_JSON_TPL_DECLARATION
17112  struct hash&lt;nlohmann::NLOHMANN_BASIC_JSON_TPL&gt;
17113  {
17114      std::size_t operator()(const nlohmann::NLOHMANN_BASIC_JSON_TPL&amp; j) const
17115      {
17116          return nlohmann::detail::hash(j);
17117      }
17118  };
17119  template&lt;&gt;
17120  struct less&lt; ::nlohmann::detail::value_t&gt; 
17121  {
17122      bool operator()(::nlohmann::detail::value_t lhs,
17123                      ::nlohmann::detail::value_t rhs) const noexcept
17124      {
17125  #if JSON_HAS_THREE_WAY_COMPARISON
17126          return std::is_lt(lhs &lt;=&gt; rhs); 
17127  #else
17128          return ::nlohmann::detail::operator&lt;(lhs, rhs);
17129  #endif
17130      }
17131  };
17132  #ifndef JSON_HAS_CPP_20
17133  NLOHMANN_BASIC_JSON_TPL_DECLARATION
17134  inline void swap(nlohmann::NLOHMANN_BASIC_JSON_TPL&amp; j1, nlohmann::NLOHMANN_BASIC_JSON_TPL&amp; j2) noexcept(  
17135      is_nothrow_move_constructible&lt;nlohmann::NLOHMANN_BASIC_JSON_TPL&gt;::value&amp;&amp;                          
17136      is_nothrow_move_assignable&lt;nlohmann::NLOHMANN_BASIC_JSON_TPL&gt;::value)
17137  {
17138      j1.swap(j2);
17139  }
17140  #endif
17141  }  
17142  #if JSON_USE_GLOBAL_UDLS
17143      using nlohmann::literals::json_literals::operator &quot;&quot; _json; 
17144      using nlohmann::literals::json_literals::operator &quot;&quot; _json_pointer; 
17145  #endif
17146  #if defined(__clang__)
17147      #pragma clang diagnostic pop
17148  #endif
17149  #undef JSON_ASSERT
17150  #undef JSON_INTERNAL_CATCH
17151  #undef JSON_THROW
17152  #undef JSON_PRIVATE_UNLESS_TESTED
17153  #undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
17154  #undef NLOHMANN_BASIC_JSON_TPL
17155  #undef JSON_EXPLICIT
17156  #undef NLOHMANN_CAN_CALL_STD_FUNC_IMPL
17157  #undef JSON_INLINE_VARIABLE
17158  #undef JSON_NO_UNIQUE_ADDRESS
17159  #undef JSON_DISABLE_ENUM_SERIALIZATION
17160  #undef JSON_USE_GLOBAL_UDLS
17161  #ifndef JSON_TEST_KEEP_MACROS
17162      #undef JSON_CATCH
17163      #undef JSON_TRY
17164      #undef JSON_HAS_CPP_11
17165      #undef JSON_HAS_CPP_14
17166      #undef JSON_HAS_CPP_17
17167      #undef JSON_HAS_CPP_20
17168      #undef JSON_HAS_FILESYSTEM
17169      #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
17170      #undef JSON_HAS_THREE_WAY_COMPARISON
17171      #undef JSON_HAS_RANGES
17172      #undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
17173  #endif
17174  #undef JSON_HEDLEY_ALWAYS_INLINE
17175  #undef JSON_HEDLEY_ARM_VERSION
17176  #undef JSON_HEDLEY_ARM_VERSION_CHECK
17177  #undef JSON_HEDLEY_ARRAY_PARAM
17178  #undef JSON_HEDLEY_ASSUME
17179  #undef JSON_HEDLEY_BEGIN_C_DECLS
17180  #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
17181  #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
17182  #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
17183  #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
17184  #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
17185  #undef JSON_HEDLEY_CLANG_HAS_FEATURE
17186  #undef JSON_HEDLEY_CLANG_HAS_WARNING
17187  #undef JSON_HEDLEY_COMPCERT_VERSION
17188  #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
17189  #undef JSON_HEDLEY_CONCAT
17190  #undef JSON_HEDLEY_CONCAT3
17191  #undef JSON_HEDLEY_CONCAT3_EX
17192  #undef JSON_HEDLEY_CONCAT_EX
17193  #undef JSON_HEDLEY_CONST
17194  #undef JSON_HEDLEY_CONSTEXPR
17195  #undef JSON_HEDLEY_CONST_CAST
17196  #undef JSON_HEDLEY_CPP_CAST
17197  #undef JSON_HEDLEY_CRAY_VERSION
17198  #undef JSON_HEDLEY_CRAY_VERSION_CHECK
17199  #undef JSON_HEDLEY_C_DECL
17200  #undef JSON_HEDLEY_DEPRECATED
17201  #undef JSON_HEDLEY_DEPRECATED_FOR
17202  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
17203  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
17204  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
17205  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
17206  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
17207  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
17208  #undef JSON_HEDLEY_DIAGNOSTIC_POP
17209  #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
17210  #undef JSON_HEDLEY_DMC_VERSION
17211  #undef JSON_HEDLEY_DMC_VERSION_CHECK
17212  #undef JSON_HEDLEY_EMPTY_BASES
17213  #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
17214  #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
17215  #undef JSON_HEDLEY_END_C_DECLS
17216  #undef JSON_HEDLEY_FLAGS
17217  #undef JSON_HEDLEY_FLAGS_CAST
17218  #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
17219  #undef JSON_HEDLEY_GCC_HAS_BUILTIN
17220  #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
17221  #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
17222  #undef JSON_HEDLEY_GCC_HAS_EXTENSION
17223  #undef JSON_HEDLEY_GCC_HAS_FEATURE
17224  #undef JSON_HEDLEY_GCC_HAS_WARNING
17225  #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
17226  #undef JSON_HEDLEY_GCC_VERSION
17227  #undef JSON_HEDLEY_GCC_VERSION_CHECK
17228  #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
17229  #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
17230  #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
17231  #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
17232  #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
17233  #undef JSON_HEDLEY_GNUC_HAS_FEATURE
17234  #undef JSON_HEDLEY_GNUC_HAS_WARNING
17235  #undef JSON_HEDLEY_GNUC_VERSION
17236  #undef JSON_HEDLEY_GNUC_VERSION_CHECK
17237  #undef JSON_HEDLEY_HAS_ATTRIBUTE
17238  #undef JSON_HEDLEY_HAS_BUILTIN
17239  #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
17240  #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
17241  #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
17242  #undef JSON_HEDLEY_HAS_EXTENSION
17243  #undef JSON_HEDLEY_HAS_FEATURE
17244  #undef JSON_HEDLEY_HAS_WARNING
17245  #undef JSON_HEDLEY_IAR_VERSION
17246  #undef JSON_HEDLEY_IAR_VERSION_CHECK
17247  #undef JSON_HEDLEY_IBM_VERSION
17248  #undef JSON_HEDLEY_IBM_VERSION_CHECK
17249  #undef JSON_HEDLEY_IMPORT
17250  #undef JSON_HEDLEY_INLINE
17251  #undef JSON_HEDLEY_INTEL_CL_VERSION
17252  #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
17253  #undef JSON_HEDLEY_INTEL_VERSION
17254  #undef JSON_HEDLEY_INTEL_VERSION_CHECK
17255  #undef JSON_HEDLEY_IS_CONSTANT
17256  #undef JSON_HEDLEY_IS_CONSTEXPR_
17257  #undef JSON_HEDLEY_LIKELY
17258  #undef JSON_HEDLEY_MALLOC
17259  #undef JSON_HEDLEY_MCST_LCC_VERSION
17260  #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
17261  #undef JSON_HEDLEY_MESSAGE
17262  #undef JSON_HEDLEY_MSVC_VERSION
17263  #undef JSON_HEDLEY_MSVC_VERSION_CHECK
17264  #undef JSON_HEDLEY_NEVER_INLINE
17265  #undef JSON_HEDLEY_NON_NULL
17266  #undef JSON_HEDLEY_NO_ESCAPE
17267  #undef JSON_HEDLEY_NO_RETURN
17268  #undef JSON_HEDLEY_NO_THROW
17269  #undef JSON_HEDLEY_NULL
17270  #undef JSON_HEDLEY_PELLES_VERSION
17271  #undef JSON_HEDLEY_PELLES_VERSION_CHECK
17272  #undef JSON_HEDLEY_PGI_VERSION
17273  #undef JSON_HEDLEY_PGI_VERSION_CHECK
17274  #undef JSON_HEDLEY_PREDICT
17275  #undef JSON_HEDLEY_PRINTF_FORMAT
17276  #undef JSON_HEDLEY_PRIVATE
17277  #undef JSON_HEDLEY_PUBLIC
17278  #undef JSON_HEDLEY_PURE
17279  #undef JSON_HEDLEY_REINTERPRET_CAST
17280  #undef JSON_HEDLEY_REQUIRE
17281  #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
17282  #undef JSON_HEDLEY_REQUIRE_MSG
17283  #undef JSON_HEDLEY_RESTRICT
17284  #undef JSON_HEDLEY_RETURNS_NON_NULL
17285  #undef JSON_HEDLEY_SENTINEL
17286  #undef JSON_HEDLEY_STATIC_ASSERT
17287  #undef JSON_HEDLEY_STATIC_CAST
17288  #undef JSON_HEDLEY_STRINGIFY
17289  #undef JSON_HEDLEY_STRINGIFY_EX
17290  #undef JSON_HEDLEY_SUNPRO_VERSION
17291  #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
17292  #undef JSON_HEDLEY_TINYC_VERSION
17293  #undef JSON_HEDLEY_TINYC_VERSION_CHECK
17294  #undef JSON_HEDLEY_TI_ARMCL_VERSION
17295  #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
17296  #undef JSON_HEDLEY_TI_CL2000_VERSION
17297  #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
17298  #undef JSON_HEDLEY_TI_CL430_VERSION
17299  #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
17300  #undef JSON_HEDLEY_TI_CL6X_VERSION
17301  #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
17302  #undef JSON_HEDLEY_TI_CL7X_VERSION
17303  #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
17304  #undef JSON_HEDLEY_TI_CLPRU_VERSION
17305  #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
17306  #undef JSON_HEDLEY_TI_VERSION
17307  #undef JSON_HEDLEY_TI_VERSION_CHECK
17308  #undef JSON_HEDLEY_UNAVAILABLE
17309  #undef JSON_HEDLEY_UNLIKELY
17310  #undef JSON_HEDLEY_UNPREDICTABLE
17311  #undef JSON_HEDLEY_UNREACHABLE
17312  #undef JSON_HEDLEY_UNREACHABLE_RETURN
17313  #undef JSON_HEDLEY_VERSION
17314  #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
17315  #undef JSON_HEDLEY_VERSION_DECODE_MINOR
17316  #undef JSON_HEDLEY_VERSION_DECODE_REVISION
17317  #undef JSON_HEDLEY_VERSION_ENCODE
17318  #undef JSON_HEDLEY_WARNING
17319  #undef JSON_HEDLEY_WARN_UNUSED_RESULT
17320  #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
17321  #undef JSON_HEDLEY_FALL_THROUGH
17322  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-json.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-json.hpp</div>
                </div>
                <div class="column column_space"><pre><code>4251      using adapter_type = iterator_input_adapter&lt;iterator_type&gt;;
4252      static adapter_type create(IteratorType first, IteratorType last)
4253      {
4254          return adapter_type(std::move(first), std::move(last));
4255      }
4256  };
4257  template&lt;typename T&gt;
4258  struct is_iterator_of_multibyte
4259  {
4260      using value_type = typename std::iterator_traits&lt;T&gt;::value_type;
4261      enum
4262      {
4263          value = sizeof(value_type) &gt; 1
4264      };
4265  };
4266  template&lt;typename IteratorType&gt;
4267  struct iterator_input_adapter_factory&lt;IteratorType, enable_if_t&lt;is_iterator_of_multibyte&lt;IteratorType&gt;::value&gt;&gt;
4268  {
4269      using iterator_type = IteratorType;
4270      using char_type = typename std::iterator_traits&lt;iterator_type&gt;::value_type;
4271      using base_adapter_type = iterator_input_adapter&lt;iterator_type&gt;;
4272      using adapter_type = wide_string_input_adapter&lt;base_adapter_type, char_type&gt;;
4273      static adapter_type create(IteratorType first, IteratorType last)
4274      {
4275          return adapter_type(base_adapter_type(std::move(first), std::move(last)));
4276      }
4277  };
4278  template&lt;typename IteratorType&gt;
4279  typename iterator_input_adapter_factory&lt;IteratorType&gt;::adapter_type input_adapter(IteratorType first, IteratorType last)
4280  {
4281      using factory_type = iterator_input_adapter_factory&lt;IteratorType&gt;;
4282      return factory_type::create(first, last);
4283  }
4284  namespace container_input_adapter_factory_impl
4285  {
4286  using std::begin;
4287  using std::end;
4288  template&lt;typename ContainerType, typename Enable = void&gt;
4289  struct container_input_adapter_factory {};
4290  template&lt;typename ContainerType&gt;
4291  struct container_input_adapter_factory&lt; ContainerType,
4292         void_t&lt;decltype(begin(std::declval&lt;ContainerType&gt;()), end(std::declval&lt;ContainerType&gt;()))&gt;&gt;
4293         {
4294             using adapter_type = decltype(input_adapter(begin(std::declval&lt;ContainerType&gt;()), end(std::declval&lt;ContainerType&gt;())));
4295             static adapter_type create(const ContainerType&amp; container)
4296  {
4297      return input_adapter(begin(container), end(container));
4298  }
4299         };
4300  } 
4301  template&lt;typename ContainerType&gt;
4302  typename container_input_adapter_factory_impl::container_input_adapter_factory&lt;ContainerType&gt;::adapter_type input_adapter(const ContainerType&amp; container)
4303  {
4304      return container_input_adapter_factory_impl::container_input_adapter_factory&lt;ContainerType&gt;::create(container);
4305  }
4306  #ifndef JSON_NO_IO
4307  inline file_input_adapter input_adapter(std::FILE* file)
4308  {
4309      return file_input_adapter(file);
4310  }
4311  inline input_stream_adapter input_adapter(std::istream&amp; stream)
4312  {
4313      return input_stream_adapter(stream);
4314  }
4315  inline input_stream_adapter input_adapter(std::istream&amp;&amp; stream)
4316  {
4317      return input_stream_adapter(stream);
4318  }
4319  #endif  
4320  using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval&lt;const char*&gt;(), std::declval&lt;const char*&gt;()));
4321  template &lt; typename CharT,
4322             typename std::enable_if &lt;
4323                 std::is_pointer&lt;CharT&gt;::value&amp;&amp;
4324                 !std::is_array&lt;CharT&gt;::value&amp;&amp;
4325                 std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value&amp;&amp;
4326                 sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
4327                 int &gt;::type = 0 &gt;
4328  contiguous_bytes_input_adapter input_adapter(CharT b)
4329  {
4330      auto length = std::strlen(reinterpret_cast&lt;const char*&gt;(b));
4331      const auto* ptr = reinterpret_cast&lt;const char*&gt;(b);
4332      return input_adapter(ptr, ptr + length);
4333  }
4334  template&lt;typename T, std::size_t N&gt;
4335  auto input_adapter(T (&amp;array)[N]) -&gt; decltype(input_adapter(array, array + N)) 
4336  {
4337      return input_adapter(array, array + N);
4338  }
4339  class span_input_adapter
4340  {
4341    public:
4342      template &lt; typename CharT,
4343                 typename std::enable_if &lt;
4344                     std::is_pointer&lt;CharT&gt;::value&amp;&amp;
4345                     std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value&amp;&amp;
4346                     sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
4347                     int &gt;::type = 0 &gt;
4348      span_input_adapter(CharT b, std::size_t l)
4349          : ia(reinterpret_cast&lt;const char*&gt;(b), reinterpret_cast&lt;const char*&gt;(b) + l) {}
4350      template&lt;class IteratorType,
4351               typename std::enable_if&lt;
4352                   std::is_same&lt;typename iterator_traits&lt;IteratorType&gt;::iterator_category, std::random_access_iterator_tag&gt;::value,
4353                   int&gt;::type = 0&gt;
4354      span_input_adapter(IteratorType first, IteratorType last)
4355          : ia(input_adapter(first, last)) {}
4356      contiguous_bytes_input_adapter&amp;&amp; get()
4357      {
4358          return std::move(ia); 
4359      }
4360    private:
4361      contiguous_bytes_input_adapter ia;
4362  };
4363  }  
4364  }  
</pre></code></div>
                <div class="column column_space"><pre><code>4851      using adapter_type = iterator_input_adapter&lt;iterator_type&gt;;
4852      static adapter_type create(IteratorType first, IteratorType last)
4853      {
4854          return adapter_type(std::move(first), std::move(last));
4855      }
4856  };
4857  template&lt;typename T&gt;
4858  struct is_iterator_of_multibyte
4859  {
4860      using value_type = typename std::iterator_traits&lt;T&gt;::value_type;
4861      enum
4862      {
4863          value = sizeof(value_type) &gt; 1
4864      };
4865  };
4866  template&lt;typename IteratorType&gt;
4867  struct iterator_input_adapter_factory&lt;IteratorType, enable_if_t&lt;is_iterator_of_multibyte&lt;IteratorType&gt;::value&gt;&gt;
4868  {
4869      using iterator_type = IteratorType;
4870      using char_type = typename std::iterator_traits&lt;iterator_type&gt;::value_type;
4871      using base_adapter_type = iterator_input_adapter&lt;iterator_type&gt;;
4872      using adapter_type = wide_string_input_adapter&lt;base_adapter_type, char_type&gt;;
4873      static adapter_type create(IteratorType first, IteratorType last)
4874      {
4875          return adapter_type(base_adapter_type(std::move(first), std::move(last)));
4876      }
4877  };
4878  template&lt;typename IteratorType&gt;
4879  typename iterator_input_adapter_factory&lt;IteratorType&gt;::adapter_type input_adapter(IteratorType first, IteratorType last)
4880  {
4881      using factory_type = iterator_input_adapter_factory&lt;IteratorType&gt;;
4882      return factory_type::create(first, last);
4883  }
4884  namespace container_input_adapter_factory_impl
4885  {
4886  using std::begin;
4887  using std::end;
4888  template&lt;typename ContainerType, typename Enable = void&gt;
4889  struct container_input_adapter_factory {};
4890  template&lt;typename ContainerType&gt;
4891  struct container_input_adapter_factory&lt; ContainerType,
4892         void_t&lt;decltype(begin(std::declval&lt;ContainerType&gt;()), end(std::declval&lt;ContainerType&gt;()))&gt;&gt;
4893         {
4894             using adapter_type = decltype(input_adapter(begin(std::declval&lt;ContainerType&gt;()), end(std::declval&lt;ContainerType&gt;())));
4895             static adapter_type create(const ContainerType&amp; container)
4896  {
4897      return input_adapter(begin(container), end(container));
4898  }
4899         };
4900  }  
4901  template&lt;typename ContainerType&gt;
4902  typename container_input_adapter_factory_impl::container_input_adapter_factory&lt;ContainerType&gt;::adapter_type input_adapter(const ContainerType&amp; container)
4903  {
4904      return container_input_adapter_factory_impl::container_input_adapter_factory&lt;ContainerType&gt;::create(container);
4905  }
4906  #ifndef JSON_NO_IO
4907  inline file_input_adapter input_adapter(std::FILE* file)
4908  {
4909      return file_input_adapter(file);
4910  }
4911  inline input_stream_adapter input_adapter(std::istream&amp; stream)
4912  {
4913      return input_stream_adapter(stream);
4914  }
4915  inline input_stream_adapter input_adapter(std::istream&amp;&amp; stream)
4916  {
4917      return input_stream_adapter(stream);
4918  }
4919  #endif  
4920  using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval&lt;const char*&gt;(), std::declval&lt;const char*&gt;()));
4921  template &lt; typename CharT,
4922             typename std::enable_if &lt;
4923                 std::is_pointer&lt;CharT&gt;::value&amp;&amp;
4924                 !std::is_array&lt;CharT&gt;::value&amp;&amp;
4925                 std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value&amp;&amp;
4926                 sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
4927                 int &gt;::type = 0 &gt;
4928  contiguous_bytes_input_adapter input_adapter(CharT b)
4929  {
4930      auto length = std::strlen(reinterpret_cast&lt;const char*&gt;(b));
4931      const auto* ptr = reinterpret_cast&lt;const char*&gt;(b);
4932      return input_adapter(ptr, ptr + length);
4933  }
4934  template&lt;typename T, std::size_t N&gt;
4935  auto input_adapter(T (&amp;array)[N]) -&gt; decltype(input_adapter(array, array + N)) 
4936  {
4937      return input_adapter(array, array + N);
4938  }
4939  class span_input_adapter
4940  {
4941    public:
4942      template &lt; typename CharT,
4943                 typename std::enable_if &lt;
4944                     std::is_pointer&lt;CharT&gt;::value&amp;&amp;
4945                     std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value&amp;&amp;
4946                     sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
4947                     int &gt;::type = 0 &gt;
4948      span_input_adapter(CharT b, std::size_t l)
4949          : ia(reinterpret_cast&lt;const char*&gt;(b), reinterpret_cast&lt;const char*&gt;(b) + l) {}
4950      template&lt;class IteratorType,
4951               typename std::enable_if&lt;
4952                   std::is_same&lt;typename iterator_traits&lt;IteratorType&gt;::iterator_category, std::random_access_iterator_tag&gt;::value,
4953                   int&gt;::type = 0&gt;
4954      span_input_adapter(IteratorType first, IteratorType last)
4955          : ia(input_adapter(first, last)) {}
4956      contiguous_bytes_input_adapter&amp;&amp; get()
4957      {
4958          return std::move(ia); 
4959      }
4960    private:
4961      contiguous_bytes_input_adapter ia;
4962  };
4963  }  
4964  NLOHMANN_JSON_NAMESPACE_END
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    