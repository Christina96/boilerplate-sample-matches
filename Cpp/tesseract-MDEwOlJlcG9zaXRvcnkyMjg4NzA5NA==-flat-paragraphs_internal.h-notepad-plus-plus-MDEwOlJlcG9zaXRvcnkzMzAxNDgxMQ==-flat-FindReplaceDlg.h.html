
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.604166666666667%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs_internal.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCMAIN_PARAGRAPHS_INTERNAL_H_
2  #define TESSERACT_CCMAIN_PARAGRAPHS_INTERNAL_H_
3  #include <tesseract/publictypes.h> 
4  #include "paragraphs.h"
5  namespace tesseract {
6  class UNICHARSET;
7  class WERD_CHOICE;
8  TESS_API
9  bool AsciiLikelyListItem(const std::string &word);
10  TESS_API
11  void RightWordAttributes(const UNICHARSET *unicharset, const WERD_CHOICE *werd, const std::string &utf8,
12                           bool *is_list, bool *starts_idea, bool *ends_idea);
13  TESS_API
14  void LeftWordAttributes(const UNICHARSET *unicharset, const WERD_CHOICE *werd, const std::string &utf8,
15                          bool *is_list, bool *starts_idea, bool *ends_idea);
16  enum LineType {
17    LT_START = 'S',    
18    LT_BODY = 'C',     
19    LT_UNKNOWN = 'U',  
20    LT_MULTIPLE = 'M', 
21  };
22  extern const ParagraphModel *kCrownLeft;
23  extern const ParagraphModel *kCrownRight;
24  inline bool StrongModel(const ParagraphModel *model) {
25    return model != nullptr && model != kCrownLeft && model != kCrownRight;
26  }
27  struct LineHypothesis {
28    LineHypothesis() : ty(LT_UNKNOWN), model(nullptr) {}
29    LineHypothesis(LineType line_type, const ParagraphModel *m) : ty(line_type), model(m) {}
30    LineHypothesis(const LineHypothesis &other) = default;
31    LineHypothesis &operator=(const LineHypothesis &other) = default;
32    bool operator==(const LineHypothesis &other) const {
33      return ty == other.ty && model == other.model;
34    }
35    LineType ty;
36    const ParagraphModel *model;
37  };
38  class ParagraphTheory; 
39  using SetOfModels = std::vector<const ParagraphModel *>;
40  class RowScratchRegisters {
41  public:
42    void Init(const RowInfo &row);
43    LineType GetLineType() const;
44    LineType GetLineType(const ParagraphModel *model) const;
45    void SetStartLine();
46    void SetBodyLine();
47    void AddStartLine(const ParagraphModel *model);
48    void AddBodyLine(const ParagraphModel *model);
49    void SetUnknown() {
50      hypotheses_.clear();
51    }
52    void StartHypotheses(SetOfModels *models) const;
53    void StrongHypotheses(SetOfModels *models) const;
54    void NonNullHypotheses(SetOfModels *models) const;
55    void DiscardNonMatchingHypotheses(const SetOfModels &models);
56    const ParagraphModel *UniqueStartHypothesis() const;
57    const ParagraphModel *UniqueBodyHypothesis() const;
58    int OffsideIndent(tesseract::ParagraphJustification just) const {
59      switch (just) {
60        case tesseract::JUSTIFICATION_RIGHT:
61          return lindent_;
62        case tesseract::JUSTIFICATION_LEFT:
63          return rindent_;
64        default:
65          return lindent_ > rindent_ ? lindent_ : rindent_;
66      }
67    }
68    int AlignsideIndent(tesseract::ParagraphJustification just) const {
69      switch (just) {
70        case tesseract::JUSTIFICATION_RIGHT:
71          return rindent_;
72        case tesseract::JUSTIFICATION_LEFT:
73          return lindent_;
74        default:
75          return lindent_ > rindent_ ? lindent_ : rindent_;
76      }
77    }
78    static void AppendDebugHeaderFields(std::vector<std::string> &header);
79    void AppendDebugInfo(const ParagraphTheory &theory, std::vector<std::string> &dbg) const;
80    const RowInfo *ri_;
81    int lmargin_;
82    int lindent_;
83    int rindent_;
84    int rmargin_;
85  private:
86    std::vector<LineHypothesis> hypotheses_;
87  };
88  class ParagraphTheory {
89  public:
90    explicit ParagraphTheory(std::vector<ParagraphModel *> *models) : models_(models) {}
<span onclick='openModal()' class='match'>91    std::vector<ParagraphModel *> &models() {
92      return *models_;
93    }
94    const std::vector<ParagraphModel *> &models() const {
95      return *models_;
96    }
97    const ParagraphModel *AddModel(const ParagraphModel &model);
</span>98    void DiscardUnusedModels(const SetOfModels &used_models);
99    void NonCenteredModels(SetOfModels *models);
100    const ParagraphModel *Fits(const std::vector<RowScratchRegisters> *rows, int start,
101                               int end) const;
102    int IndexOf(const ParagraphModel *model) const;
103  private:
104    std::vector<ParagraphModel *> *models_;
105    std::vector<ParagraphModel *> models_we_added_;
106  };
107  bool ValidFirstLine(const std::vector<RowScratchRegisters> *rows, int row,
108                      const ParagraphModel *model);
109  bool ValidBodyLine(const std::vector<RowScratchRegisters> *rows, int row,
110                     const ParagraphModel *model);
111  bool CrownCompatible(const std::vector<RowScratchRegisters> *rows, int a, int b,
112                       const ParagraphModel *model);
113  class ParagraphModelSmearer {
114  public:
115    ParagraphModelSmearer(std::vector<RowScratchRegisters> *rows, int row_start, int row_end,
116                          ParagraphTheory *theory);
117    void Smear();
118  private:
119    void CalculateOpenModels(int row_start, int row_end);
120    SetOfModels &OpenModels(int row) {
121      return open_models_[row - row_start_ + 1];
122    }
123    ParagraphTheory *theory_;
124    std::vector<RowScratchRegisters> *rows_;
125    int row_start_;
126    int row_end_;
127    std::vector<SetOfModels> open_models_;
128  };
129  void RecomputeMarginsAndClearHypotheses(std::vector<RowScratchRegisters> *rows, int start,
130                                          int end, int percentile);
131  int InterwordSpace(const std::vector<RowScratchRegisters> &rows, int row_start, int row_end);
132  bool FirstWordWouldHaveFit(const RowScratchRegisters &before, const RowScratchRegisters &after,
133                             tesseract::ParagraphJustification justification);
134  bool FirstWordWouldHaveFit(const RowScratchRegisters &before, const RowScratchRegisters &after);
135  bool RowsFitModel(const std::vector<RowScratchRegisters> *rows, int start, int end,
136                    const ParagraphModel *model);
137  void CanonicalizeDetectionResults(std::vector<PARA *> *row_owners, PARA_LIST *paragraphs);
138  } 
139  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-FindReplaceDlg.h</h3>
            <pre><code>1  #pragma once
2  #include <map>
3  #include "FindReplaceDlg_rc.h"
4  #include "ScintillaEditView.h"
5  #include "DockingDlgInterface.h"
6  #include "BoostRegexSearch.h"
7  #include "StatusBar.h"
8  #define FIND_RECURSIVE 1
9  #define FIND_INHIDDENDIR 2
10  #define FINDREPLACE_MAXLENGTH 2048
11  #define FINDREPLACE_INSEL_TEXTSIZE_THRESHOLD 1024
12  #define FINDTEMPSTRING_MAXSIZE 1024*1024
13  enum DIALOG_TYPE {FIND_DLG, REPLACE_DLG, FINDINFILES_DLG, FINDINPROJECTS_DLG, MARK_DLG};
14  #define DIR_DOWN true
15  #define DIR_UP false
16  enum InWhat{ALL_OPEN_DOCS, FILES_IN_DIR, CURRENT_DOC, CURR_DOC_SELECTION, FILES_IN_PROJECTS};
17  struct FoundInfo {
18  	FoundInfo(intptr_t start, intptr_t end, size_t lineNumber, const TCHAR *fullPath)
19  		: _lineNumber(lineNumber), _fullPath(fullPath) {
20  		_ranges.push_back(std::pair<intptr_t, intptr_t>(start, end));
21  	};
22  	std::vector<std::pair<intptr_t, intptr_t>> _ranges;
23  	size_t _lineNumber = 0;
24  	generic_string _fullPath;
25  };
26  struct TargetRange {
27  	int targetStart;
28  	int targetEnd;
29  };
30  enum SearchIncrementalType { NotIncremental, FirstIncremental, NextIncremental };
31  enum SearchType { FindNormal, FindExtended, FindRegex };
32  enum ProcessOperation { ProcessFindAll, ProcessReplaceAll, ProcessCountAll, ProcessMarkAll, ProcessMarkAll_2, ProcessMarkAll_IncSearch, ProcessMarkAllExt, ProcessFindInFinder };
33  struct FindOption
34  {
35  	bool _isWholeWord = true;
36  	bool _isMatchCase = true;
37  	bool _isWrapAround = true;
38  	bool _whichDirection = DIR_DOWN;
39  	SearchIncrementalType _incrementalType = NotIncremental;
40  	SearchType _searchType = FindNormal;
41  	bool _doPurge = false;
42  	bool _doMarkLine = false;
43  	bool _isInSelection = false;
44  	generic_string _str2Search;
45  	generic_string _str4Replace;
46  	generic_string _filters;
47  	generic_string _directory;
48  	bool _isRecursive = true;
49  	bool _isInHiddenDir = false;
50  	bool _isProjectPanel_1 = false;
51  	bool _isProjectPanel_2 = false;
52  	bool _isProjectPanel_3 = false;
53  	bool _dotMatchesNewline = false;
54  	bool _isMatchLineNumber = true; 
55  };
56  class Searching {
57  public:
58  	static int convertExtendedToString(const TCHAR * query, TCHAR * result, int length);
59  	static TargetRange t;
60  	static int buildSearchFlags(const FindOption * option) {
61  		return	(option->_isWholeWord ? SCFIND_WHOLEWORD : 0) |
62  				(option->_isMatchCase ? SCFIND_MATCHCASE : 0) |
63  				(option->_searchType == FindRegex ? SCFIND_REGEXP|SCFIND_POSIX : 0) |
64  				((option->_searchType == FindRegex && option->_dotMatchesNewline) ? SCFIND_REGEXP_DOTMATCHESNL : 0);
65  	};
66  	static void displaySectionCentered(size_t posStart, size_t posEnd, ScintillaEditView * pEditView, bool isDownwards = true);
67  private:
68  	static bool readBase(const TCHAR * str, int * value, int base, int size);
69  };
70  class Finder : public DockingDlgInterface {
71  friend class FindReplaceDlg;
72  public:
73  	Finder() : DockingDlgInterface(IDD_FINDRESULT) {
74  		_markingsStruct._length = 0;
75  		_markingsStruct._markings = NULL;
76  	};
77  	~Finder() {
78  		_scintView.destroy();
79  	}
80  	void init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView) {
81  		DockingDlgInterface::init(hInst, hPere);
82  		_ppEditView = ppEditView;
83  	};
84  	void addSearchLine(const TCHAR *searchName);
85  	void addFileNameTitle(const TCHAR * fileName);
86  	void addFileHitCount(int count);
87  	void addSearchHitCount(int count, int countSearched, bool isMatchLines, bool searchedEntireNotSelection);
88  	const char* foundLine(FoundInfo fi, SearchResultMarkingLine mi, const TCHAR* foundline, size_t totalLineNumber);
89  	void setFinderStyle();
90  	void setFinderStyleForNpc(bool onlyColor = false);
91  	void removeAll();
92  	void openAll();
93  	void wrapLongLinesToggle();
94  	void purgeToggle();
95  	void copy();
96  	void copyPathnames();
97  	void beginNewFilesSearch();
98  	void finishFilesSearch(int count, int searchedCount, bool isMatchLines, bool searchedEntireNotSelection);
99  	void gotoNextFoundResult(int direction);
100  	std::pair<intptr_t, intptr_t> gotoFoundLine(size_t nOccurrence = 0); 
101  	void deleteResult();
102  	std::vector<generic_string> getResultFilePaths() const;
103  	bool canFind(const TCHAR *fileName, size_t lineNumber, size_t* indexToStartFrom) const;
104  	void setVolatiled(bool val) { _canBeVolatiled = val; };
105  	generic_string getHitsString(int count) const;
106  protected :
107  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
108  	bool notify(SCNotification *notification);
109  private:
110  	enum { searchHeaderLevel = SC_FOLDLEVELBASE, fileHeaderLevel, resultLevel };
111  	enum CurrentPosInLineStatus { pos_infront, pos_between, pos_inside, pos_behind };
112  	struct CurrentPosInLineInfo {
113  		CurrentPosInLineStatus _status = pos_infront;
114  		intptr_t auxiliaryInfo = -1; 
115  	};
116  	ScintillaEditView **_ppEditView = nullptr;
117  	std::vector<FoundInfo> _foundInfos1;
118  	std::vector<FoundInfo> _foundInfos2;
119  	std::vector<FoundInfo>* _pMainFoundInfos = &_foundInfos1;
120  	std::vector<SearchResultMarkingLine> _markings1;
121  	std::vector<SearchResultMarkingLine> _markings2;
122  	std::vector<SearchResultMarkingLine>* _pMainMarkings = &_markings1;
123  	SearchResultMarkings _markingsStruct;
124  	intptr_t _previousLineNumber = -1;
125  	ScintillaEditView _scintView;
126  	unsigned int _nbFoundFiles = 0;
127  	intptr_t _lastFileHeaderPos = 0;
128  	intptr_t _lastSearchHeaderPos = 0;
129  	bool _canBeVolatiled = true;
130  	bool _longLinesAreWrapped = false;
131  	bool _purgeBeforeEverySearch = false;
132  	generic_string _prefixLineStr;
133  	void setFinderReadOnly(bool isReadOnly) {
134  		_scintView.execute(SCI_SETREADONLY, isReadOnly);
135  	};
136  	bool isLineActualSearchResult(const generic_string & s) const;
137  	generic_string & prepareStringForClipboard(generic_string & s) const;
138  	static FoundInfo EmptyFoundInfo;
139  	static SearchResultMarkingLine EmptySearchResultMarking;
140  	CurrentPosInLineInfo getCurrentPosInLineInfo(intptr_t currentPosInLine, const SearchResultMarkingLine& markingLine) const;
141  	void anchorWithNoHeaderLines(intptr_t& currentL, intptr_t initL, intptr_t minL, intptr_t maxL, int direction);
142  };
143  enum FindStatus { FSFound, FSNotFound, FSTopReached, FSEndReached, FSMessage, FSNoMessage};
144  enum FindNextType {
145  	FINDNEXTTYPE_FINDNEXT,
146  	FINDNEXTTYPE_REPLACENEXT,
147  	FINDNEXTTYPE_FINDNEXTFORREPLACE
148  };
149  struct FindReplaceInfo
150  {
151  	const TCHAR *_txt2find = nullptr;
152  	const TCHAR *_txt2replace = nullptr;
153  	intptr_t _startRange = -1;
154  	intptr_t _endRange = -1;
155  };
156  struct FindersInfo
157  {
158  	Finder *_pSourceFinder = nullptr;
159  	Finder *_pDestFinder = nullptr;
160  	const TCHAR *_pFileName = nullptr;
161  	FindOption _findOption;
162  };
163  class FindInFinderDlg : public StaticDialog
164  {
165  public:
166  	void doDialog(Finder *launcher, bool isRTL = false);
167  	FindOption & getOption() { return _options; }
168  	FindInFinderDlg() {
169  		_options._isMatchCase = false;
170  		_options._isWholeWord = false;
171  	};
172  private:
173  	Finder  *_pFinder2Search = nullptr;
174  	FindOption _options;
175  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
176  	void initFromOptions();
177  	void writeOptions();
178  };
179  LRESULT run_swapButtonProc(WNDPROC oldEditProc, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
180  class FindReplaceDlg : public StaticDialog
181  {
182  friend class FindIncrementDlg;
183  public :
184  	static FindOption _options;
185  	static FindOption* _env;
186  	FindReplaceDlg() {
187  		_uniFileName = new char[(_fileNameLenMax + 3) * 2];
188  		_winVer = (NppParameters::getInstance()).getWinVersion();
189  		_env = &_options;
190  	};
191  	~FindReplaceDlg();
192  	void init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView) {
193  		Window::init(hInst, hPere);
194  		if (!ppEditView)
195  			throw std::runtime_error("FindIncrementDlg::init : ppEditView is null.");
196  		_ppEditView = ppEditView;
197  	};
198  	void create(int dialogID, bool isRTL = false, bool msgDestParent = true, bool toShow = true);
199  	void initOptionsFromDlg();
200  	void doDialog(DIALOG_TYPE whichType, bool isRTL = false, bool toShow = true);
201  	bool processFindNext(const TCHAR *txt2find, const FindOption *options = NULL, FindStatus *oFindStatus = NULL, FindNextType findNextType = FINDNEXTTYPE_FINDNEXT);
202  	bool processReplace(const TCHAR *txt2find, const TCHAR *txt2replace, const FindOption *options = NULL);
203  	int markAll(const TCHAR *txt2find, int styleID);
204  	int markAllInc(const FindOption *opt);
205  	int processAll(ProcessOperation op, const FindOption *opt, bool isEntire = false, const FindersInfo *pFindersInfo = nullptr, int colourStyleID = -1);
206  	int processRange(ProcessOperation op, FindReplaceInfo & findReplaceInfo, const FindersInfo *pFindersInfo, const FindOption *opt = nullptr, int colourStyleID = -1, ScintillaEditView *view2Process = nullptr);
207  	void replaceAllInOpenedDocs();
208  	void findAllIn(InWhat op);
209  	void setSearchText(TCHAR * txt2find);
210  	void gotoNextFoundResult(int direction = 0) {if (_pFinder) _pFinder->gotoNextFoundResult(direction);};
211  	void putFindResult(int result) {
212  		_findAllResult = result;
213  	};
214  	const TCHAR * getDir2Search() const {return _env->_directory.c_str();};
215  	void getPatterns(std::vector<generic_string> & patternVect);
216  	void getAndValidatePatterns(std::vector<generic_string> & patternVect);
217  	void launchFindInFilesDlg() {
218  		doDialog(FINDINFILES_DLG);
219  	};
220  	void launchFindInProjectsDlg() {
221  		doDialog(FINDINPROJECTS_DLG);
222  	};
223  	void setFindInFilesDirFilter(const TCHAR *dir, const TCHAR *filters);
224  	void setProjectCheckmarks(FindHistory *findHistory, int Msk);
225  	void enableProjectCheckmarks();
<span onclick='openModal()' class='match'>226  	generic_string getText2search() const {
227  		return _env->_str2Search;
228  	};
229  	const generic_string & getFilters() const {return _env->_filters;};
230  	const generic_string & getDirectory() const {return _env->_directory;};
</span>231  	const FindOption & getCurrentOptions() const {return *_env;};
232  	bool isRecursive() const { return _env->_isRecursive; };
233  	bool isInHiddenDir() const { return _env->_isInHiddenDir; };
234  	bool isProjectPanel_1() const { return _env->_isProjectPanel_1; };
235  	bool isProjectPanel_2() const { return _env->_isProjectPanel_2; };
236  	bool isProjectPanel_3() const { return _env->_isProjectPanel_3; };
237  	void saveFindHistory();
238  	void changeTabName(DIALOG_TYPE index, const TCHAR *name2change) {
239  		TCITEM tie{};
240  		tie.mask = TCIF_TEXT;
241  		tie.pszText = (TCHAR *)name2change;
242  		TabCtrl_SetItem(_tab.getHSelf(), index, &tie);
243  		TCHAR label[MAX_PATH]{};
244  		_tab.getCurrentTitle(label, MAX_PATH);
245  		::SetWindowText(_hSelf, label);
246  	}
247  	void beginNewFilesSearch()
248  	{
249  		_pFinder->beginNewFilesSearch();
250  		_pFinder->addSearchLine(getText2search().c_str());
251  	}
252  	void finishFilesSearch(int count, int searchedCount, bool searchedEntireNotSelection)
253  	{
254  		const bool isMatchLines = false;
255  		_pFinder->finishFilesSearch(count, searchedCount, isMatchLines, searchedEntireNotSelection);
256  	}
257  	void focusOnFinder() {
258  		if (_pFinder) 
259  		{
260  			_pFinder->display();
261  			_pFinder->_scintView.getFocus();
262  		}
263  	};
264  	HWND getHFindResults() {
265  		if (_pFinder)
266  			return _pFinder->_scintView.getHSelf();
267  		return NULL;
268  	}
269  	void updateFinderScintilla() {
270  		if (_pFinder && _pFinder->isCreated())
271  		{
272  			_pFinder->setFinderStyle();
273  			if (!_findersOfFinder.empty())
274  			{
275  				for (const auto& finder : _findersOfFinder)
276  				{
277  					finder->setFinderStyle();
278  				}
279  			}
280  		}
281  	};
282  	void updateFinderScintillaForNpc(bool onlyColor = false) {
283  		if (_pFinder && _pFinder->isCreated())
284  		{
285  			_pFinder->setFinderStyleForNpc(onlyColor);
286  			if (!_findersOfFinder.empty())
287  			{
288  				for (const auto& finder : _findersOfFinder)
289  				{
290  					finder->setFinderStyleForNpc();
291  				}
292  			}
293  		}
294  	};
295  	void execSavedCommand(int cmd, uptr_t intValue, const generic_string& stringValue);
296  	void clearMarks(const FindOption& opt);
297  	void setStatusbarMessage(const generic_string & msg, FindStatus staus, char const *pTooltipMsg = NULL);
298  	generic_string getScopeInfoForStatusBar(FindOption const *pFindOpt) const;
299  	Finder * createFinder();
300  	bool removeFinder(Finder *finder2remove);
301  	DIALOG_TYPE getCurrentStatus() {return _currentStatus;};
302  protected :
303  	void resizeDialogElements(LONG newWidth);
304  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
305  	static WNDPROC originalFinderProc;
306  	static WNDPROC originalComboEditProc;
307  	static LRESULT FAR PASCAL comboEditProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
308  	static LRESULT FAR PASCAL finderProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
309      void combo2ExtendedMode(int comboID);
310  private :
311  	RECT _initialWindowRect = {};
312  	LONG _deltaWidth = 0;
313  	LONG _initialClientWidth = 0;
314  	LONG _lesssModeHeight = 0;
315  	DIALOG_TYPE _currentStatus = DIALOG_TYPE::FIND_DLG;
316  	RECT _findClosePos = {};
317  	RECT _replaceClosePos = {};
318  	RECT _findInFilesClosePos = {};
319  	RECT _markClosePos = {};
320  	RECT _countInSelFramePos = {};
321  	RECT _replaceInSelFramePos = {};
322  	RECT _countInSelCheckPos = {};
323  	RECT _replaceInSelCheckPos = {};
324  	RECT _collapseButtonPos = {};
325  	RECT _uncollapseButtonPos = {};
326  	ScintillaEditView **_ppEditView = nullptr;
327  	Finder  *_pFinder = nullptr;
328  	generic_string _findResTitle;
329  	std::vector<Finder*> _findersOfFinder{};
330  	HWND _shiftTrickUpTip = nullptr;
331  	HWND _2ButtonsTip = nullptr;
332  	HWND _filterTip = nullptr;
333  	bool _isRTL = false;
334  	int _findAllResult = 0;
335  	TCHAR _findAllResultStr[1024] = {'\0'};
336  	int _fileNameLenMax = 1024;
337  	char *_uniFileName = nullptr;
338  	TabBar _tab;
339  	winVer _winVer = winVer::WV_UNKNOWN;
340  	StatusBar _statusBar;
341  	FindStatus _statusbarFindStatus;
342  	generic_string _statusbarTooltipMsg;
343  	HWND _statusbarTooltipWnd = nullptr;
344  	HICON _statusbarTooltipIcon = nullptr;
345  	int _statusbarTooltipIconSize = 0;
346  	HFONT _hMonospaceFont = nullptr;
347  	HFONT _hLargerBolderFont = nullptr;
348  	HFONT _hCourrierNewFont = nullptr;
349  	std::map<int, bool> _controlEnableMap;
350  	std::vector<int> _reduce2hide_find = { IDC_IN_SELECTION_CHECK, IDC_REPLACEINSELECTION, IDC_FINDALL_CURRENTFILE };
351  	std::vector<int> _reduce2hide_findReplace = { IDC_IN_SELECTION_CHECK, IDC_REPLACEINSELECTION, IDREPLACEALL };
352  	std::vector<int> _reduce2hide_fif = { IDD_FINDINFILES_FILTERS_STATIC, IDD_FINDINFILES_FILTERS_COMBO, IDCANCEL };
353  	std::vector<int> _reduce2hide_fip = { IDD_FINDINFILES_FILTERS_STATIC, IDD_FINDINFILES_FILTERS_COMBO, IDCANCEL };
354  	std::vector<int> _reduce2hide_mark = { IDC_MARKLINE_CHECK, IDC_PURGE_CHECK, IDC_IN_SELECTION_CHECK, IDC_COPY_MARKED_TEXT };
355  	void enableFindDlgItem(int dlgItemID, bool isEnable = true);
356  	void showFindDlgItem(int dlgItemID, bool isShow = true);
357  	void enableReplaceFunc(bool isEnable);
358  	void enableFindInFilesControls(bool isEnable, bool projectPanels);
359  	void enableFindInFilesFunc();
360  	void enableFindInProjectsFunc();
361  	void enableMarkAllControls(bool isEnable);
362  	void enableMarkFunc();
363  	void hideOrShowCtrl4reduceOrNormalMode(DIALOG_TYPE dlgT);
364  	void setDefaultButton(int nID) {
365  		SendMessage(_hSelf, DM_SETDEFID, nID, 0L);
366  	};
367  	void gotoCorrectTab() {
368  		auto currentIndex = _tab.getCurrentTabIndex();
369  		if (currentIndex != _currentStatus)
370  			_tab.activateAt(_currentStatus);
371  	};
372  	FindStatus getFindStatus() {
373  		return _statusbarFindStatus;
374  	}
375  	void updateCombos();
376  	void updateCombo(int comboID);
377  	void fillFindHistory();
378      void fillComboHistory(int id, const std::vector<generic_string> & strings);
379  	int saveComboHistory(int id, int maxcount, std::vector<generic_string> & strings, bool saveEmpty);
380  	static const int FR_OP_FIND = 1;
381  	static const int FR_OP_REPLACE = 2;
382  	static const int FR_OP_FIF = 4;
383  	static const int FR_OP_GLOBAL = 8;
384  	static const int FR_OP_FIP = 16;
385  	void saveInMacro(size_t cmd, int cmdType);
386  	void drawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
387  	bool replaceInFilesConfirmCheck(generic_string directory, generic_string fileTypes);
388  	bool replaceInProjectsConfirmCheck();
389  	bool replaceInOpenDocsConfirmCheck(void);
390  	ContextMenu _swapPopupMenu;
391  	enum SwapButtonStatus {swap, down, up} _swapButtonStatus = swap;
392  	HWND _hSwapButton = nullptr;
393  	static LRESULT CALLBACK swapButtonProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
394  		const auto dlg = (FindReplaceDlg*)(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
395  		return (run_swapButtonProc(dlg->_oldSwapButtonProc, hwnd, message, wParam, lParam));
396  	};
397  	WNDPROC _oldSwapButtonProc = nullptr;
398  };
399  class FindIncrementDlg : public StaticDialog
400  {
401  public :
402  	FindIncrementDlg() = default;
403  	void init(HINSTANCE hInst, HWND hPere, FindReplaceDlg *pFRDlg, bool isRTL = false);
404  	void destroy() override;
405  	void display(bool toShow = true) const override;
406  	void setSearchText(const TCHAR* txt2find, bool) {
407  		::SendDlgItemMessage(_hSelf, IDC_INCFINDTEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(txt2find));
408  	};
409  	void setFindStatus(FindStatus iStatus, int nbCounted);
410  	FindStatus getFindStatus() {
411  		return _findStatus;
412  	}
413  	void addToRebar(ReBar* rebar);
414  private :
415  	bool _isRTL = false;
416  	FindReplaceDlg *_pFRDlg = nullptr;
417  	FindStatus _findStatus = FSFound;
418  	ReBar* _pRebar = nullptr;
419  	REBARBANDINFO _rbBand{};
420  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
421  	void markSelectedTextInc(bool enable, FindOption *opt = NULL);
422  };
423  class Progress
424  {
425  public:
426  	explicit Progress(HINSTANCE hInst);
427  	~Progress();
428  	Progress(const Progress&) = delete;
429  	const Progress& operator=(const Progress&) = delete;
430  	HWND open(HWND hCallerWnd, const TCHAR* header = NULL);
431  	void close();
432  	bool isCancelled() const
433  	{
434  		if (_hwnd)
435  			return (::WaitForSingleObject(_hActiveState, 0) != WAIT_OBJECT_0);
436  		return false;
437  	}
438  	void setPercent(unsigned percent, const TCHAR* fileName, int nbHitsSoFar) const;
439  	void setInfo(const TCHAR* info, int nbHitsSoFar = -1) const;
440  private:
441  	static const TCHAR cClassName[];
442  	static const TCHAR cDefaultHeader[];
443  	static const int cBackgroundColor;
444  	static const int cPBwidth;
445  	static const int cPBheight;
446  	static const int cBTNwidth;
447  	static const int cBTNheight;
448  	static volatile LONG refCount;
449  	static DWORD WINAPI threadFunc(LPVOID data);
450  	static LRESULT APIENTRY wndProc(HWND hwnd, UINT umsg, WPARAM wparam, LPARAM lparam);
451  	int thread();
452  	int createProgressWindow();
453  	HINSTANCE _hInst = nullptr;
454  	volatile HWND _hwnd = nullptr;
455  	HWND _hCallerWnd = nullptr;
456  	TCHAR _header[128] = {'\0'};
457  	HANDLE _hThread = nullptr;
458  	HANDLE _hActiveState = nullptr;
459  	HWND _hPathText = nullptr;
460  	HWND _hRunningHitsStaticText = nullptr;
461  	HWND _hRunningHitsText = nullptr;
462  	HWND _hPBar = nullptr;
463  	HWND _hBtn = nullptr;
464  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs_internal.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-FindReplaceDlg.h</div>
                <div class="column column_space"><pre><code>91    std::vector<ParagraphModel *> &models() {
92      return *models_;
93    }
94    const std::vector<ParagraphModel *> &models() const {
95      return *models_;
96    }
97    const ParagraphModel *AddModel(const ParagraphModel &model);
</pre></code></div>
                <div class="column column_space"><pre><code>226  	generic_string getText2search() const {
227  		return _env->_str2Search;
228  	};
229  	const generic_string & getFilters() const {return _env->_filters;};
230  	const generic_string & getDirectory() const {return _env->_directory;};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    