
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 71, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-work_pool.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/blocks.hpp>
3  #include <nano/lib/logger_mt.hpp>
4  #include <nano/lib/timer.hpp>
5  #include <nano/lib/work.hpp>
6  #include <nano/node/logging.hpp>
7  #include <nano/node/openclconfig.hpp>
8  #include <nano/node/openclwork.hpp>
9  #include <nano/secure/common.hpp>
10  #include <nano/secure/utility.hpp>
11  #include <gtest/gtest.h>
12  #include <future>
13  TEST (work, one)
14  {
15  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
16  	nano::block_builder builder;
17  	auto block = builder
18  				 .change ()
19  				 .previous (1)
20  				 .representative (1)
21  				 .sign (nano::keypair ().prv, 3)
22  				 .work (4)
23  				 .build ();
24  	block->block_work_set (*pool.generate (block->root ()));
25  	ASSERT_LT (nano::dev::network_params.work.threshold_base (block->work_version ()), nano::dev::network_params.work.difficulty (*block));
26  }
27  TEST (work, disabled)
28  {
29  	nano::work_pool pool{ nano::dev::network_params.network, 0 };
30  	auto result (pool.generate (nano::block_hash ()));
31  	ASSERT_FALSE (result.is_initialized ());
32  }
33  TEST (work, validate)
34  {
35  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
36  	nano::block_builder builder;
37  	auto send_block = builder
38  					  .send ()
39  					  .previous (1)
40  					  .destination (1)
41  					  .balance (2)
42  					  .sign (nano::keypair ().prv, 4)
43  					  .work (6)
44  					  .build ();
45  	ASSERT_LT (nano::dev::network_params.work.difficulty (*send_block), nano::dev::network_params.work.threshold_base (send_block->work_version ()));
46  	send_block->block_work_set (*pool.generate (send_block->root ()));
47  	ASSERT_LT (nano::dev::network_params.work.threshold_base (send_block->work_version ()), nano::dev::network_params.work.difficulty (*send_block));
48  }
49  TEST (work, cancel)
50  {
51  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
52  	auto iterations (0);
53  	auto done (false);
54  	while (!done)
55  	{
56  		nano::root key (1);
57  		pool.generate (
58  		nano::work_version::work_1, key, nano::dev::network_params.work.base, [&done] (boost::optional<uint64_t> work_a) {
59  			done = !work_a;
60  		});
61  		pool.cancel (key);
62  		++iterations;
63  		ASSERT_LT (iterations, 200);
64  	}
65  }
66  TEST (work, cancel_many)
67  {
68  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
69  	nano::root key1 (1);
70  	nano::root key2 (2);
71  	nano::root key3 (1);
72  	nano::root key4 (1);
73  	nano::root key5 (3);
74  	nano::root key6 (1);
75  	pool.generate (nano::work_version::work_1, key1, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
76  	pool.generate (nano::work_version::work_1, key2, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
77  	pool.generate (nano::work_version::work_1, key3, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
78  	pool.generate (nano::work_version::work_1, key4, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
79  	pool.generate (nano::work_version::work_1, key5, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
80  	pool.generate (nano::work_version::work_1, key6, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
81  	pool.cancel (key1);
82  }
83  TEST (work, opencl)
84  {
85  	nano::logging logging;
86  	logging.init (nano::unique_path ());
87  	nano::logger_mt logger;
88  	bool error (false);
89  	nano::opencl_environment environment (error);
90  	ASSERT_TRUE (!error || !nano::opencl_loaded);
91  	if (!environment.platforms.empty () && !environment.platforms.begin ()->devices.empty ())
92  	{
93  		nano::opencl_config config (0, 0, 16 * 1024);
94  		auto opencl (nano::opencl_work::create (true, config, logger, nano::dev::network_params.work));
95  		if (opencl != nullptr)
96  		{
97  			nano::work_pool pool{ nano::dev::network_params.network, 0, std::chrono::nanoseconds (0), [&opencl] (nano::work_version const version_a, nano::root const & root_a, uint64_t difficulty_a, std::atomic<int> & ticket_a) {
98  									 return opencl->generate_work (version_a, root_a, difficulty_a);
99  								 } };
100  			ASSERT_NE (nullptr, pool.opencl);
101  			nano::root root;
102  			uint64_t difficulty (0xff00000000000000);
103  			uint64_t difficulty_add (0x000f000000000000);
104  			for (auto i (0); i < 16; ++i)
105  			{
106  				nano::random_pool::generate_block (root.bytes.data (), root.bytes.size ());
107  				auto result (*pool.generate (nano::work_version::work_1, root, difficulty));
108  				ASSERT_GE (nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, result), difficulty);
109  				difficulty += difficulty_add;
110  			}
111  		}
112  		else
113  		{
114  			std::cerr << "Error starting OpenCL test" << std::endl;
115  		}
116  	}
117  	else
118  	{
119  		std::cout << "Device with OpenCL support not found. Skipping OpenCL test" << std::endl;
120  	}
121  }
122  TEST (work, difficulty)
123  {
124  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
125  	nano::root root (1);
126  	uint64_t difficulty1 (0xff00000000000000);
127  	uint64_t difficulty2 (0xfff0000000000000);
128  	uint64_t difficulty3 (0xffff000000000000);
129  	uint64_t result_difficulty1 (0);
130  	do
131  	{
132  		auto work1 = *pool.generate (nano::work_version::work_1, root, difficulty1);
133  		result_difficulty1 = nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, work1);
134  	} while (result_difficulty1 > difficulty2);
135  	ASSERT_GT (result_difficulty1, difficulty1);
136  	uint64_t result_difficulty2 (0);
137  	do
138  	{
139  		auto work2 = *pool.generate (nano::work_version::work_1, root, difficulty2);
140  		result_difficulty2 = nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, work2);
141  	} while (result_difficulty2 > difficulty3);
142  	ASSERT_GT (result_difficulty2, difficulty2);
143  }
144  TEST (work, eco_pow)
145  {
146  	auto work_func = [] (std::promise<std::chrono::nanoseconds> & promise, std::chrono::nanoseconds interval) {
147  		nano::work_pool pool{ nano::dev::network_params.network, 1, interval };
148  		constexpr auto num_iterations = 5;
149  		nano::timer<std::chrono::nanoseconds> timer;
150  		timer.start ();
151  		for (int i = 0; i < num_iterations; ++i)
152  		{
153  			nano::root root (1);
154  			uint64_t difficulty1 (0xff00000000000000);
<span onclick='openModal()' class='match'>155  			uint64_t difficulty2 (0xfff0000000000000);
156  			uint64_t result_difficulty (0);
157  			do
158  			{
159  				auto work = *pool.generate (nano::work_version::work_1, root, difficulty1);
160  				result_difficulty = nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, work);
161  			} while (result_difficulty > difficulty2);
162  			ASSERT_GT (result_difficulty, difficulty1);
163  		}
</span>164  		promise.set_value_at_thread_exit (timer.stop ());
165  	};
166  	std::promise<std::chrono::nanoseconds> promise1;
167  	std::future<std::chrono::nanoseconds> future1 = promise1.get_future ();
168  	std::promise<std::chrono::nanoseconds> promise2;
169  	std::future<std::chrono::nanoseconds> future2 = promise2.get_future ();
170  	std::thread thread1 (work_func, std::ref (promise1), std::chrono::nanoseconds (0));
171  	std::thread thread2 (work_func, std::ref (promise2), std::chrono::milliseconds (10));
172  	thread1.join ();
173  	thread2.join ();
174  	ASSERT_LT (future1.get (), future2.get ());
175  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-work_pool.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/blocks.hpp>
3  #include <nano/lib/logger_mt.hpp>
4  #include <nano/lib/timer.hpp>
5  #include <nano/lib/work.hpp>
6  #include <nano/node/logging.hpp>
7  #include <nano/node/openclconfig.hpp>
8  #include <nano/node/openclwork.hpp>
9  #include <nano/secure/common.hpp>
10  #include <nano/secure/utility.hpp>
11  #include <gtest/gtest.h>
12  #include <future>
13  TEST (work, one)
14  {
15  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
16  	nano::block_builder builder;
17  	auto block = builder
18  				 .change ()
19  				 .previous (1)
20  				 .representative (1)
21  				 .sign (nano::keypair ().prv, 3)
22  				 .work (4)
23  				 .build ();
24  	block->block_work_set (*pool.generate (block->root ()));
25  	ASSERT_LT (nano::dev::network_params.work.threshold_base (block->work_version ()), nano::dev::network_params.work.difficulty (*block));
26  }
27  TEST (work, disabled)
28  {
29  	nano::work_pool pool{ nano::dev::network_params.network, 0 };
30  	auto result (pool.generate (nano::block_hash ()));
31  	ASSERT_FALSE (result.is_initialized ());
32  }
33  TEST (work, validate)
34  {
35  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
36  	nano::block_builder builder;
37  	auto send_block = builder
38  					  .send ()
39  					  .previous (1)
40  					  .destination (1)
41  					  .balance (2)
42  					  .sign (nano::keypair ().prv, 4)
43  					  .work (6)
44  					  .build ();
45  	ASSERT_LT (nano::dev::network_params.work.difficulty (*send_block), nano::dev::network_params.work.threshold_base (send_block->work_version ()));
46  	send_block->block_work_set (*pool.generate (send_block->root ()));
47  	ASSERT_LT (nano::dev::network_params.work.threshold_base (send_block->work_version ()), nano::dev::network_params.work.difficulty (*send_block));
48  }
49  TEST (work, cancel)
50  {
51  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
52  	auto iterations (0);
53  	auto done (false);
54  	while (!done)
55  	{
56  		nano::root key (1);
57  		pool.generate (
58  		nano::work_version::work_1, key, nano::dev::network_params.work.base, [&done] (boost::optional<uint64_t> work_a) {
59  			done = !work_a;
60  		});
61  		pool.cancel (key);
62  		++iterations;
63  		ASSERT_LT (iterations, 200);
64  	}
65  }
66  TEST (work, cancel_many)
67  {
68  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
69  	nano::root key1 (1);
70  	nano::root key2 (2);
71  	nano::root key3 (1);
72  	nano::root key4 (1);
73  	nano::root key5 (3);
74  	nano::root key6 (1);
75  	pool.generate (nano::work_version::work_1, key1, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
76  	pool.generate (nano::work_version::work_1, key2, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
77  	pool.generate (nano::work_version::work_1, key3, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
78  	pool.generate (nano::work_version::work_1, key4, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
79  	pool.generate (nano::work_version::work_1, key5, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
80  	pool.generate (nano::work_version::work_1, key6, nano::dev::network_params.work.base, [] (boost::optional<uint64_t>) {});
81  	pool.cancel (key1);
82  }
83  TEST (work, opencl)
84  {
85  	nano::logging logging;
86  	logging.init (nano::unique_path ());
87  	nano::logger_mt logger;
88  	bool error (false);
89  	nano::opencl_environment environment (error);
90  	ASSERT_TRUE (!error || !nano::opencl_loaded);
91  	if (!environment.platforms.empty () && !environment.platforms.begin ()->devices.empty ())
92  	{
93  		nano::opencl_config config (0, 0, 16 * 1024);
94  		auto opencl (nano::opencl_work::create (true, config, logger, nano::dev::network_params.work));
95  		if (opencl != nullptr)
96  		{
97  			nano::work_pool pool{ nano::dev::network_params.network, 0, std::chrono::nanoseconds (0), [&opencl] (nano::work_version const version_a, nano::root const & root_a, uint64_t difficulty_a, std::atomic<int> & ticket_a) {
98  									 return opencl->generate_work (version_a, root_a, difficulty_a);
99  								 } };
100  			ASSERT_NE (nullptr, pool.opencl);
101  			nano::root root;
102  			uint64_t difficulty (0xff00000000000000);
103  			uint64_t difficulty_add (0x000f000000000000);
104  			for (auto i (0); i < 16; ++i)
105  			{
106  				nano::random_pool::generate_block (root.bytes.data (), root.bytes.size ());
107  				auto result (*pool.generate (nano::work_version::work_1, root, difficulty));
108  				ASSERT_GE (nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, result), difficulty);
109  				difficulty += difficulty_add;
110  			}
111  		}
112  		else
113  		{
114  			std::cerr << "Error starting OpenCL test" << std::endl;
115  		}
116  	}
117  	else
118  	{
119  		std::cout << "Device with OpenCL support not found. Skipping OpenCL test" << std::endl;
120  	}
121  }
122  TEST (work, difficulty)
123  {
124  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
125  	nano::root root (1);
126  	uint64_t difficulty1 (0xff00000000000000);
127  	uint64_t difficulty2 (0xfff0000000000000);
<span onclick='openModal()' class='match'>128  	uint64_t difficulty3 (0xffff000000000000);
129  	uint64_t result_difficulty1 (0);
130  	do
131  	{
132  		auto work1 = *pool.generate (nano::work_version::work_1, root, difficulty1);
133  		result_difficulty1 = nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, work1);
134  	} while (result_difficulty1 > difficulty2);
135  	ASSERT_GT (result_difficulty1, difficulty1);
136  	uint64_t result_difficulty2 (0);
</span>137  	do
138  	{
139  		auto work2 = *pool.generate (nano::work_version::work_1, root, difficulty2);
140  		result_difficulty2 = nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, work2);
141  	} while (result_difficulty2 > difficulty3);
142  	ASSERT_GT (result_difficulty2, difficulty2);
143  }
144  TEST (work, eco_pow)
145  {
146  	auto work_func = [] (std::promise<std::chrono::nanoseconds> & promise, std::chrono::nanoseconds interval) {
147  		nano::work_pool pool{ nano::dev::network_params.network, 1, interval };
148  		constexpr auto num_iterations = 5;
149  		nano::timer<std::chrono::nanoseconds> timer;
150  		timer.start ();
151  		for (int i = 0; i < num_iterations; ++i)
152  		{
153  			nano::root root (1);
154  			uint64_t difficulty1 (0xff00000000000000);
155  			uint64_t difficulty2 (0xfff0000000000000);
156  			uint64_t result_difficulty (0);
157  			do
158  			{
159  				auto work = *pool.generate (nano::work_version::work_1, root, difficulty1);
160  				result_difficulty = nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, work);
161  			} while (result_difficulty > difficulty2);
162  			ASSERT_GT (result_difficulty, difficulty1);
163  		}
164  		promise.set_value_at_thread_exit (timer.stop ());
165  	};
166  	std::promise<std::chrono::nanoseconds> promise1;
167  	std::future<std::chrono::nanoseconds> future1 = promise1.get_future ();
168  	std::promise<std::chrono::nanoseconds> promise2;
169  	std::future<std::chrono::nanoseconds> future2 = promise2.get_future ();
170  	std::thread thread1 (work_func, std::ref (promise1), std::chrono::nanoseconds (0));
171  	std::thread thread2 (work_func, std::ref (promise2), std::chrono::milliseconds (10));
172  	thread1.join ();
173  	thread2.join ();
174  	ASSERT_LT (future1.get (), future2.get ());
175  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-work_pool.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-work_pool.cpp</div>
                </div>
                <div class="column column_space"><pre><code>155  			uint64_t difficulty2 (0xfff0000000000000);
156  			uint64_t result_difficulty (0);
157  			do
158  			{
159  				auto work = *pool.generate (nano::work_version::work_1, root, difficulty1);
160  				result_difficulty = nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, work);
161  			} while (result_difficulty > difficulty2);
162  			ASSERT_GT (result_difficulty, difficulty1);
163  		}
</pre></code></div>
                <div class="column column_space"><pre><code>128  	uint64_t difficulty3 (0xffff000000000000);
129  	uint64_t result_difficulty1 (0);
130  	do
131  	{
132  		auto work1 = *pool.generate (nano::work_version::work_1, root, difficulty1);
133  		result_difficulty1 = nano::dev::network_params.work.difficulty (nano::work_version::work_1, root, work1);
134  	} while (result_difficulty1 > difficulty2);
135  	ASSERT_GT (result_difficulty1, difficulty1);
136  	uint64_t result_difficulty2 (0);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    