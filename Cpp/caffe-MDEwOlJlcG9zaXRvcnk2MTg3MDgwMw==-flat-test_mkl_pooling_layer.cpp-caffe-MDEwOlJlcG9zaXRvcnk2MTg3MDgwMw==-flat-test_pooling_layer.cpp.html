
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_pooling_layer.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/mkl_layers.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename TypeParam>
12  class MKLPoolingLayerTest : public MultiDeviceTest<TypeParam> {
13    typedef typename TypeParam::Dtype Dtype;
14   protected:
15    MKLPoolingLayerTest()
16        : blob_bottom_(new Blob<Dtype>()),
17          blob_top_(new Blob<Dtype>()),
18          blob_top_mask_(new Blob<size_t>()) {}
19    virtual void SetUp() {
<span onclick='openModal()' class='match'>20      Caffe::set_random_seed(1701);
21      blob_bottom_->Reshape(2, 3, 6, 5);
22      FillerParameter filler_param;
</span>23      GaussianFiller<Dtype> filler(filler_param);
24      filler.Fill(this->blob_bottom_);
25      blob_bottom_vec_.push_back(blob_bottom_);
26      blob_top_vec_.push_back(blob_top_);
27    }
28    virtual ~MKLPoolingLayerTest() {
29      delete blob_bottom_;
30      delete blob_top_;
31      delete blob_top_mask_;
32    }
33    Blob<Dtype>* const blob_bottom_;
34    Blob<Dtype>* const blob_top_;
35    Blob<size_t>* const blob_top_mask_;
36    vector<Blob<Dtype>*> blob_bottom_vec_;
37    vector<Blob<Dtype>*> blob_top_vec_;
38    void TestForwardSquare() {
39      LayerParameter layer_param;
40      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
41      pooling_param->set_kernel_size(2);
42      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
43      const int num = 2;
44      const int channels = 2;
45      blob_bottom_->Reshape(num, channels, 3, 5);
46      for (int i = 0; i < 15 * num * channels; i += 15) {
47        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
48        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
49        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
50        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
51        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
52        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
53        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
54        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
55        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
56        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
57        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
58        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
59        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
60        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
61        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
62      }
63      MKLPoolingLayer<Dtype> layer(layer_param);
64      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
65      EXPECT_EQ(blob_top_->num(), num);
66      EXPECT_EQ(blob_top_->channels(), channels);
67      EXPECT_EQ(blob_top_->height(), 2);
68      EXPECT_EQ(blob_top_->width(), 4);
69      if (blob_top_vec_.size() > 1) {
70        EXPECT_EQ(blob_top_mask_->num(), num);
71        EXPECT_EQ(blob_top_mask_->channels(), channels);
72        EXPECT_EQ(blob_top_mask_->height(), 2);
73        EXPECT_EQ(blob_top_mask_->width(), 4);
74      }
75      layer.Forward(blob_bottom_vec_, blob_top_vec_);
76      for (int i = 0; i < 8 * num * channels; i += 8) {
77        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
78        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
79        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
80        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
81        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
82        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
83        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
84        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
85      }
86      if (blob_top_vec_.size() > 1) {
87        for (int i = 0; i < 8 * num * channels; i += 8) {
88          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 0],  5);
89          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 1],  2);
90          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 2],  2);
91          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 3],  9);
92          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 4],  5);
93          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 5], 12);
94          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 6], 12);
95          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 7],  9);
96        }
97      }
98    }
99    void TestForwardRectHigh() {
100      LayerParameter layer_param;
101      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
102      pooling_param->set_kernel_h(3);
103      pooling_param->set_kernel_w(2);
104      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
105      const int num = 2;
106      const int channels = 2;
107      blob_bottom_->Reshape(num, channels, 6, 6);
108      for (int i = 0; i < 36 * num * channels; i += 36) {
109        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
110        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
111        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
112        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
113        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
114        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
115        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
116        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
117        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
118        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
119        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
120        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
121        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
122        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
123        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
124        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
125        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
126        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
127        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
128        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
129        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
130        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
131        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
132        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
133        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
134        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
135        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
136        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
137        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
138        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
139        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
140        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
141        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
142        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
143        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
144        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
145      }
146      MKLPoolingLayer<Dtype> layer(layer_param);
147      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
148      EXPECT_EQ(blob_top_->num(), num);
149      EXPECT_EQ(blob_top_->channels(), channels);
150      EXPECT_EQ(blob_top_->height(), 4);
151      EXPECT_EQ(blob_top_->width(), 5);
152      if (blob_top_vec_.size() > 1) {
153        EXPECT_EQ(blob_top_mask_->num(), num);
154        EXPECT_EQ(blob_top_mask_->channels(), channels);
155        EXPECT_EQ(blob_top_mask_->height(), 4);
156        EXPECT_EQ(blob_top_mask_->width(), 5);
157      }
158      layer.Forward(blob_bottom_vec_, blob_top_vec_);
159      for (int i = 0; i < 20 * num * channels; i += 20) {
160        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
161        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
162        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
163        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
164        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
165        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
166        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
167        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
168        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
169        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
170        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
171        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
172        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
173        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
174        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
175        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
176        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
177        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
178        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
179        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
180      }
181      if (blob_top_vec_.size() > 1) {
182        for (int i = 0; i < 20 * num * channels; i += 20) {
183          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
184          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
185          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
186          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3], 16);
187          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4], 16);
188          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
189          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 20);
190          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 20);
191          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 16);
192          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 16);
193          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 12);
194          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 26);
195          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
196          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 16);
197          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 16);
198          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 31);
199          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
200          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 26);
201          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 34);
202          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
203        }
204      }
205    }
206    void TestForwardRectWide() {
207      LayerParameter layer_param;
208      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
209      pooling_param->set_kernel_h(2);
210      pooling_param->set_kernel_w(3);
211      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
212      const int num = 2;
213      const int channels = 2;
214      blob_bottom_->Reshape(num, channels, 6, 6);
215      for (int i = 0; i < 36 * num * channels; i += 36) {
216        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
217        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
218        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
219        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
220        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
221        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
222        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
223        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
224        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
225        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
226        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
227        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
228        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
229        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
230        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
231        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
232        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
233        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
234        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
235        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
236        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
237        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
238        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
239        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
240        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
241        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
242        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
243        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
244        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
245        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
246        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
247        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
248        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
249        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
250        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
251        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
252      }
253      MKLPoolingLayer<Dtype> layer(layer_param);
254      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
255      EXPECT_EQ(blob_top_->num(), num);
256      EXPECT_EQ(blob_top_->channels(), channels);
257      EXPECT_EQ(blob_top_->height(), 5);
258      EXPECT_EQ(blob_top_->width(), 4);
259      if (blob_top_vec_.size() > 1) {
260        EXPECT_EQ(blob_top_mask_->num(), num);
261        EXPECT_EQ(blob_top_mask_->channels(), channels);
262        EXPECT_EQ(blob_top_mask_->height(), 5);
263        EXPECT_EQ(blob_top_mask_->width(), 4);
264      }
265      layer.Forward(blob_bottom_vec_, blob_top_vec_);
266      for (int i = 0; i < 20 * num * channels; i += 20) {
267        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
268        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
269        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
270        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
271        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
272        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
273        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
274        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
275        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
276        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
277        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
278        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
279        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
280        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
281        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
282        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
283        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
284        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
285        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
286        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
287      }
288      if (blob_top_vec_.size() > 1) {
289        for (int i = 0; i < 20 * num * channels; i += 20) {
290          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
291          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
292          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
293          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3],  3);
294          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4],  7);
295          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
296          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 16);
297          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 16);
298          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 20);
299          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 20);
300          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 20);
301          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 16);
302          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
303          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 26);
304          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 26);
305          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 21);
306          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
307          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 31);
308          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 26);
309          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
310        }
311      }
312    }
313  };
314  typedef ::testing::Types<CPUDevice<float>,
315                           CPUDevice<double> > TestDtypesCPU;
316  TYPED_TEST_CASE(MKLPoolingLayerTest, TestDtypesCPU);
317  TYPED_TEST(MKLPoolingLayerTest, TestSetup) {
318    typedef typename TypeParam::Dtype Dtype;
319    LayerParameter layer_param;
320    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
321    pooling_param->set_kernel_size(3);
322    pooling_param->set_stride(2);
323    MKLPoolingLayer<Dtype> layer(layer_param);
324    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
325    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
326    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
327    EXPECT_EQ(this->blob_top_->height(), 3);
328    EXPECT_EQ(this->blob_top_->width(), 2);
329  }
330  TYPED_TEST(MKLPoolingLayerTest, TestSetupPadded) {
331    typedef typename TypeParam::Dtype Dtype;
332    LayerParameter layer_param;
333    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
334    pooling_param->set_kernel_size(3);
335    pooling_param->set_stride(2);
336    pooling_param->set_pad(1);
337    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
338    MKLPoolingLayer<Dtype> layer(layer_param);
339    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
340    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
341    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
342    EXPECT_EQ(this->blob_top_->height(), 4);
343    EXPECT_EQ(this->blob_top_->width(), 3);
344  }
345  TYPED_TEST(MKLPoolingLayerTest, TestSetupGlobalPooling) {
346    typedef typename TypeParam::Dtype Dtype;
347    LayerParameter layer_param;
348    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
349    pooling_param->set_global_pooling(true);
350    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
351    MKLPoolingLayer<Dtype> layer(layer_param);
352    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
353    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
354    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
355    EXPECT_EQ(this->blob_top_->height(), 1);
356    EXPECT_EQ(this->blob_top_->width(), 1);
357  }
358  TYPED_TEST(MKLPoolingLayerTest, TestForwardMax) {
359    this->TestForwardSquare();
360    this->TestForwardRectHigh();
361    this->TestForwardRectWide();
362  }
363  TYPED_TEST(MKLPoolingLayerTest, TestForwardMaxTopMask) {
364    typedef typename TypeParam::Dtype Dtype;
365    this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
366            (this->blob_top_mask_));
367    this->TestForwardSquare();
368    this->TestForwardRectHigh();
369    this->TestForwardRectWide();
370  }
371  TYPED_TEST(MKLPoolingLayerTest, TestGradientMax) {
372    typedef typename TypeParam::Dtype Dtype;
373    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
374      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
375        LayerParameter layer_param;
376        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
377        pooling_param->set_kernel_h(kernel_h);
378        pooling_param->set_kernel_w(kernel_w);
379        pooling_param->set_stride(2);
380        pooling_param->set_pad(1);
381        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
382        MKLPoolingLayer<Dtype> layer(layer_param);
383        GradientChecker<Dtype> checker(1e-4, 1e-2);
384        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
385            this->blob_top_vec_);
386      }
387    }
388  }
389  TYPED_TEST(MKLPoolingLayerTest, TestForwardMaxPadded) {
390    typedef typename TypeParam::Dtype Dtype;
391    LayerParameter layer_param;
392    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
393    pooling_param->set_kernel_size(3);
394    pooling_param->set_stride(2);
395    pooling_param->set_pad(2);
396    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
397    this->blob_bottom_->Reshape(1, 1, 3, 3);
398    this->blob_bottom_->mutable_cpu_data()[0] = 1;
399    this->blob_bottom_->mutable_cpu_data()[1] = 2;
400    this->blob_bottom_->mutable_cpu_data()[2] = 4;
401    this->blob_bottom_->mutable_cpu_data()[3] = 2;
402    this->blob_bottom_->mutable_cpu_data()[4] = 3;
403    this->blob_bottom_->mutable_cpu_data()[5] = 2;
404    this->blob_bottom_->mutable_cpu_data()[6] = 4;
405    this->blob_bottom_->mutable_cpu_data()[7] = 2;
406    this->blob_bottom_->mutable_cpu_data()[8] = 1;
407    MKLPoolingLayer<Dtype> layer(layer_param);
408    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
409    EXPECT_EQ(this->blob_top_->num(), 1);
410    EXPECT_EQ(this->blob_top_->channels(), 1);
411    EXPECT_EQ(this->blob_top_->height(), 3);
412    EXPECT_EQ(this->blob_top_->width(), 3);
413    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
414    Dtype epsilon = 1e-8;
415    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
416    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
417    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
418    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
419    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
420    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
421    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
422    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
423    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
424  }
425  #if 0
426  TYPED_TEST(MKLPoolingLayerTest, TestGradientMaxTopMask) {
427    typedef typename TypeParam::Dtype Dtype;
428    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
429      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
430        LayerParameter layer_param;
431        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
432        pooling_param->set_kernel_h(kernel_h);
433        pooling_param->set_kernel_w(kernel_w);
434        pooling_param->set_stride(2);
435        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
436        this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
437                (this->blob_top_mask_));
438        MKLPoolingLayer<Dtype> layer(layer_param);
439        GradientChecker<Dtype> checker(1e-4, 1e-2);
440        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
441            this->blob_top_vec_);
442        this->blob_top_vec_.pop_back();
443      }
444    }
445  }
446  #endif
447  #if 0  
448  TYPED_TEST(MKLPoolingLayerTest, TestForwardAve) {
449    typedef typename TypeParam::Dtype Dtype;
450    LayerParameter layer_param;
451    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
452    pooling_param->set_kernel_size(3);
453    pooling_param->set_stride(1);
454    pooling_param->set_pad(1);
455    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
456    this->blob_bottom_->Reshape(1, 1, 3, 3);
457    FillerParameter filler_param;
458    filler_param.set_value(Dtype(2));
459    ConstantFiller<Dtype> filler(filler_param);
460    filler.Fill(this->blob_bottom_);
461    MKLPoolingLayer<Dtype> layer(layer_param);
462    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
463    EXPECT_EQ(this->blob_top_->num(), 1);
464    EXPECT_EQ(this->blob_top_->channels(), 1);
465    EXPECT_EQ(this->blob_top_->height(), 3);
466    EXPECT_EQ(this->blob_top_->width(), 3);
467    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
468    Dtype epsilon = 1e-5;
469    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 8.0 / 9, epsilon);
470    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4.0 / 3, epsilon);
471    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 8.0 / 9, epsilon);
472    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4.0 / 3, epsilon);
473    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 2.0    , epsilon);
474    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4.0 / 3, epsilon);
475    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 8.0 / 9, epsilon);
476    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4.0 / 3, epsilon);
477    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 8.0 / 9, epsilon);
478  }
479  TYPED_TEST(MKLPoolingLayerTest, TestGradientAve) {
480    typedef typename TypeParam::Dtype Dtype;
481    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
482      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
483        LayerParameter layer_param;
484        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
485        pooling_param->set_kernel_h(kernel_h);
486        pooling_param->set_kernel_w(kernel_w);
487        pooling_param->set_stride(2);
488        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
489        MKLPoolingLayer<Dtype> layer(layer_param);
490        GradientChecker<Dtype> checker(1e-2, 1e-2);
491        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
492            this->blob_top_vec_);
493      }
494    }
495  }
496  TYPED_TEST(MKLPoolingLayerTest, TestGradientAvePadded) {
497    typedef typename TypeParam::Dtype Dtype;
498    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
499      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
500        LayerParameter layer_param;
501        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
502        pooling_param->set_kernel_h(kernel_h);
503        pooling_param->set_kernel_w(kernel_w);
504        pooling_param->set_stride(2);
505        pooling_param->set_pad(2);
506        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
507        MKLPoolingLayer<Dtype> layer(layer_param);
508        GradientChecker<Dtype> checker(1e-2, 1e-2);
509        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
510            this->blob_top_vec_);
511      }
512    }
513  }
514  #endif
515  }  
516  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_pooling_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "gtest/gtest.h"
3  #include "caffe/blob.hpp"
4  #include "caffe/common.hpp"
5  #include "caffe/filler.hpp"
6  #include "caffe/layers/pooling_layer.hpp"
7  #ifdef USE_CUDNN
8  #include "caffe/layers/cudnn_pooling_layer.hpp"
9  #endif
10  #include "caffe/test/test_caffe_main.hpp"
11  #include "caffe/test/test_gradient_check_util.hpp"
12  namespace caffe {
13  template <typename TypeParam>
14  class PoolingLayerTest : public MultiDeviceTest<TypeParam> {
15    typedef typename TypeParam::Dtype Dtype;
16   protected:
17    PoolingLayerTest()
18        : blob_bottom_(new Blob<Dtype>()),
19          blob_top_(new Blob<Dtype>()),
20          blob_top_mask_(new Blob<Dtype>()) {}
21    virtual void SetUp() {
<span onclick='openModal()' class='match'>22      Caffe::set_random_seed(1701);
23      blob_bottom_->Reshape(2, 3, 6, 5);
24      FillerParameter filler_param;
</span>25      GaussianFiller<Dtype> filler(filler_param);
26      filler.Fill(this->blob_bottom_);
27      blob_bottom_vec_.push_back(blob_bottom_);
28      blob_top_vec_.push_back(blob_top_);
29    }
30    virtual ~PoolingLayerTest() {
31      delete blob_bottom_;
32      delete blob_top_;
33      delete blob_top_mask_;
34    }
35    Blob<Dtype>* const blob_bottom_;
36    Blob<Dtype>* const blob_top_;
37    Blob<Dtype>* const blob_top_mask_;
38    vector<Blob<Dtype>*> blob_bottom_vec_;
39    vector<Blob<Dtype>*> blob_top_vec_;
40    void TestForwardSquare() {
41      LayerParameter layer_param;
42      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
43      pooling_param->set_kernel_size(2);
44      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
45      const int num = 2;
46      const int channels = 2;
47      blob_bottom_->Reshape(num, channels, 3, 5);
48      for (int i = 0; i < 15 * num * channels; i += 15) {
49        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
50        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
51        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
52        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
53        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
54        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
55        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
56        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
57        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
58        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
59        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
60        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
61        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
62        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
63        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
64      }
65      PoolingLayer<Dtype> layer(layer_param);
66      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
67      EXPECT_EQ(blob_top_->num(), num);
68      EXPECT_EQ(blob_top_->channels(), channels);
69      EXPECT_EQ(blob_top_->height(), 2);
70      EXPECT_EQ(blob_top_->width(), 4);
71      if (blob_top_vec_.size() > 1) {
72        EXPECT_EQ(blob_top_mask_->num(), num);
73        EXPECT_EQ(blob_top_mask_->channels(), channels);
74        EXPECT_EQ(blob_top_mask_->height(), 2);
75        EXPECT_EQ(blob_top_mask_->width(), 4);
76      }
77      layer.Forward(blob_bottom_vec_, blob_top_vec_);
78      for (int i = 0; i < 8 * num * channels; i += 8) {
79        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
80        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
81        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
82        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
83        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
84        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
85        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
86        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
87      }
88      if (blob_top_vec_.size() > 1) {
89        for (int i = 0; i < 8 * num * channels; i += 8) {
90          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 0],  5);
91          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 1],  2);
92          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 2],  2);
93          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 3],  9);
94          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 4],  5);
95          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 5], 12);
96          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 6], 12);
97          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 7],  9);
98        }
99      }
100    }
101    void TestForwardRectHigh() {
102      LayerParameter layer_param;
103      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
104      pooling_param->set_kernel_h(3);
105      pooling_param->set_kernel_w(2);
106      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
107      const int num = 2;
108      const int channels = 2;
109      blob_bottom_->Reshape(num, channels, 6, 6);
110      for (int i = 0; i < 36 * num * channels; i += 36) {
111        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
112        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
113        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
114        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
115        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
116        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
117        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
118        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
119        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
120        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
121        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
122        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
123        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
124        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
125        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
126        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
127        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
128        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
129        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
130        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
131        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
132        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
133        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
134        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
135        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
136        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
137        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
138        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
139        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
140        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
141        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
142        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
143        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
144        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
145        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
146        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
147      }
148      PoolingLayer<Dtype> layer(layer_param);
149      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
150      EXPECT_EQ(blob_top_->num(), num);
151      EXPECT_EQ(blob_top_->channels(), channels);
152      EXPECT_EQ(blob_top_->height(), 4);
153      EXPECT_EQ(blob_top_->width(), 5);
154      if (blob_top_vec_.size() > 1) {
155        EXPECT_EQ(blob_top_mask_->num(), num);
156        EXPECT_EQ(blob_top_mask_->channels(), channels);
157        EXPECT_EQ(blob_top_mask_->height(), 4);
158        EXPECT_EQ(blob_top_mask_->width(), 5);
159      }
160      layer.Forward(blob_bottom_vec_, blob_top_vec_);
161      for (int i = 0; i < 20 * num * channels; i += 20) {
162        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
163        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
164        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
165        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
166        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
167        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
168        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
169        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
170        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
171        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
172        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
173        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
174        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
175        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
176        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
177        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
178        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
179        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
180        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
181        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
182      }
183      if (blob_top_vec_.size() > 1) {
184        for (int i = 0; i < 20 * num * channels; i += 20) {
185          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
186          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
187          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
188          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3], 16);
189          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4], 16);
190          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
191          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 20);
192          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 20);
193          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 16);
194          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 16);
195          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 12);
196          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 26);
197          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
198          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 16);
199          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 16);
200          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 31);
201          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
202          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 26);
203          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 34);
204          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
205        }
206      }
207    }
208    void TestForwardRectWide() {
209      LayerParameter layer_param;
210      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
211      pooling_param->set_kernel_h(2);
212      pooling_param->set_kernel_w(3);
213      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
214      const int num = 2;
215      const int channels = 2;
216      blob_bottom_->Reshape(num, channels, 6, 6);
217      for (int i = 0; i < 36 * num * channels; i += 36) {
218        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
219        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
220        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
221        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
222        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
223        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
224        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
225        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
226        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
227        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
228        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
229        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
230        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
231        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
232        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
233        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
234        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
235        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
236        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
237        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
238        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
239        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
240        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
241        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
242        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
243        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
244        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
245        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
246        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
247        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
248        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
249        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
250        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
251        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
252        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
253        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
254      }
255      PoolingLayer<Dtype> layer(layer_param);
256      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
257      EXPECT_EQ(blob_top_->num(), num);
258      EXPECT_EQ(blob_top_->channels(), channels);
259      EXPECT_EQ(blob_top_->height(), 5);
260      EXPECT_EQ(blob_top_->width(), 4);
261      if (blob_top_vec_.size() > 1) {
262        EXPECT_EQ(blob_top_mask_->num(), num);
263        EXPECT_EQ(blob_top_mask_->channels(), channels);
264        EXPECT_EQ(blob_top_mask_->height(), 5);
265        EXPECT_EQ(blob_top_mask_->width(), 4);
266      }
267      layer.Forward(blob_bottom_vec_, blob_top_vec_);
268      for (int i = 0; i < 20 * num * channels; i += 20) {
269        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
270        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
271        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
272        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
273        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
274        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
275        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
276        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
277        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
278        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
279        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
280        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
281        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
282        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
283        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
284        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
285        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
286        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
287        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
288        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
289      }
290      if (blob_top_vec_.size() > 1) {
291        for (int i = 0; i < 20 * num * channels; i += 20) {
292          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
293          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
294          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
295          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3],  3);
296          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4],  7);
297          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
298          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 16);
299          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 16);
300          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 20);
301          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 20);
302          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 20);
303          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 16);
304          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
305          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 26);
306          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 26);
307          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 21);
308          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
309          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 31);
310          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 26);
311          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
312        }
313      }
314    }
315  };
316  TYPED_TEST_CASE(PoolingLayerTest, TestDtypesAndDevices);
317  TYPED_TEST(PoolingLayerTest, TestSetup) {
318    typedef typename TypeParam::Dtype Dtype;
319    LayerParameter layer_param;
320    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
321    pooling_param->set_kernel_size(3);
322    pooling_param->set_stride(2);
323    PoolingLayer<Dtype> layer(layer_param);
324    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
325    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
326    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
327    EXPECT_EQ(this->blob_top_->height(), 3);
328    EXPECT_EQ(this->blob_top_->width(), 2);
329  }
330  TYPED_TEST(PoolingLayerTest, TestSetupPadded) {
331    typedef typename TypeParam::Dtype Dtype;
332    LayerParameter layer_param;
333    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
334    pooling_param->set_kernel_size(3);
335    pooling_param->set_stride(2);
336    pooling_param->set_pad(1);
337    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
338    PoolingLayer<Dtype> layer(layer_param);
339    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
340    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
341    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
342    EXPECT_EQ(this->blob_top_->height(), 4);
343    EXPECT_EQ(this->blob_top_->width(), 3);
344  }
345  TYPED_TEST(PoolingLayerTest, TestSetupGlobalPooling) {
346    typedef typename TypeParam::Dtype Dtype;
347    LayerParameter layer_param;
348    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
349    pooling_param->set_global_pooling(true);
350    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
351    PoolingLayer<Dtype> layer(layer_param);
352    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
353    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
354    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
355    EXPECT_EQ(this->blob_top_->height(), 1);
356    EXPECT_EQ(this->blob_top_->width(), 1);
357  }
358  TYPED_TEST(PoolingLayerTest, TestForwardMax) {
359    this->TestForwardSquare();
360    this->TestForwardRectHigh();
361    this->TestForwardRectWide();
362  }
363  TYPED_TEST(PoolingLayerTest, TestForwardMaxTopMask) {
364    this->blob_top_vec_.push_back(this->blob_top_mask_);
365    this->TestForwardSquare();
366    this->TestForwardRectHigh();
367    this->TestForwardRectWide();
368  }
369  TYPED_TEST(PoolingLayerTest, TestGradientMax) {
370    typedef typename TypeParam::Dtype Dtype;
371    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
372      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
373        LayerParameter layer_param;
374        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
375        pooling_param->set_kernel_h(kernel_h);
376        pooling_param->set_kernel_w(kernel_w);
377        pooling_param->set_stride(2);
378        pooling_param->set_pad(1);
379        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
380        PoolingLayer<Dtype> layer(layer_param);
381        GradientChecker<Dtype> checker(1e-4, 1e-2);
382        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
383            this->blob_top_vec_);
384      }
385    }
386  }
387  TYPED_TEST(PoolingLayerTest, TestForwardMaxPadded) {
388    typedef typename TypeParam::Dtype Dtype;
389    LayerParameter layer_param;
390    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
391    pooling_param->set_kernel_size(3);
392    pooling_param->set_stride(2);
393    pooling_param->set_pad(2);
394    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
395    this->blob_bottom_->Reshape(1, 1, 3, 3);
396    this->blob_bottom_->mutable_cpu_data()[0] = 1;
397    this->blob_bottom_->mutable_cpu_data()[1] = 2;
398    this->blob_bottom_->mutable_cpu_data()[2] = 4;
399    this->blob_bottom_->mutable_cpu_data()[3] = 2;
400    this->blob_bottom_->mutable_cpu_data()[4] = 3;
401    this->blob_bottom_->mutable_cpu_data()[5] = 2;
402    this->blob_bottom_->mutable_cpu_data()[6] = 4;
403    this->blob_bottom_->mutable_cpu_data()[7] = 2;
404    this->blob_bottom_->mutable_cpu_data()[8] = 1;
405    PoolingLayer<Dtype> layer(layer_param);
406    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
407    EXPECT_EQ(this->blob_top_->num(), 1);
408    EXPECT_EQ(this->blob_top_->channels(), 1);
409    EXPECT_EQ(this->blob_top_->height(), 3);
410    EXPECT_EQ(this->blob_top_->width(), 3);
411    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
412    Dtype epsilon = 1e-8;
413    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
414    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
415    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
416    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
417    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
418    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
419    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
420    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
421    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
422  }
423  TYPED_TEST(PoolingLayerTest, TestGradientMaxTopMask) {
424    typedef typename TypeParam::Dtype Dtype;
425    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
426      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
427        LayerParameter layer_param;
428        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
429        pooling_param->set_kernel_h(kernel_h);
430        pooling_param->set_kernel_w(kernel_w);
431        pooling_param->set_stride(2);
432        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
433        this->blob_top_vec_.push_back(this->blob_top_mask_);
434        PoolingLayer<Dtype> layer(layer_param);
435        GradientChecker<Dtype> checker(1e-4, 1e-2);
436        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
437            this->blob_top_vec_);
438        this->blob_top_vec_.pop_back();
439      }
440    }
441  }
442  TYPED_TEST(PoolingLayerTest, TestForwardAve) {
443    typedef typename TypeParam::Dtype Dtype;
444    LayerParameter layer_param;
445    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
446    pooling_param->set_kernel_size(3);
447    pooling_param->set_stride(1);
448    pooling_param->set_pad(1);
449    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
450    this->blob_bottom_->Reshape(1, 1, 3, 3);
451    FillerParameter filler_param;
452    filler_param.set_value(Dtype(2));
453    ConstantFiller<Dtype> filler(filler_param);
454    filler.Fill(this->blob_bottom_);
455    PoolingLayer<Dtype> layer(layer_param);
456    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
457    EXPECT_EQ(this->blob_top_->num(), 1);
458    EXPECT_EQ(this->blob_top_->channels(), 1);
459    EXPECT_EQ(this->blob_top_->height(), 3);
460    EXPECT_EQ(this->blob_top_->width(), 3);
461    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
462    Dtype epsilon = 1e-5;
463    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 8.0 / 9, epsilon);
464    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4.0 / 3, epsilon);
465    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 8.0 / 9, epsilon);
466    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4.0 / 3, epsilon);
467    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 2.0    , epsilon);
468    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4.0 / 3, epsilon);
469    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 8.0 / 9, epsilon);
470    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4.0 / 3, epsilon);
471    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 8.0 / 9, epsilon);
472  }
473  TYPED_TEST(PoolingLayerTest, TestGradientAve) {
474    typedef typename TypeParam::Dtype Dtype;
475    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
476      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
477        LayerParameter layer_param;
478        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
479        pooling_param->set_kernel_h(kernel_h);
480        pooling_param->set_kernel_w(kernel_w);
481        pooling_param->set_stride(2);
482        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
483        PoolingLayer<Dtype> layer(layer_param);
484        GradientChecker<Dtype> checker(1e-2, 1e-2);
485        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
486            this->blob_top_vec_);
487      }
488    }
489  }
490  TYPED_TEST(PoolingLayerTest, TestGradientAvePadded) {
491    typedef typename TypeParam::Dtype Dtype;
492    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
493      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
494        LayerParameter layer_param;
495        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
496        pooling_param->set_kernel_h(kernel_h);
497        pooling_param->set_kernel_w(kernel_w);
498        pooling_param->set_stride(2);
499        pooling_param->set_pad(2);
500        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
501        PoolingLayer<Dtype> layer(layer_param);
502        GradientChecker<Dtype> checker(1e-2, 1e-2);
503        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
504            this->blob_top_vec_);
505      }
506    }
507  }
508  #ifdef USE_CUDNN
509  template <typename Dtype>
510  class CuDNNPoolingLayerTest : public GPUDeviceTest<Dtype> {
511   protected:
512    CuDNNPoolingLayerTest()
513        : blob_bottom_(new Blob<Dtype>()),
514          blob_top_(new Blob<Dtype>()),
515          blob_top_mask_(new Blob<Dtype>()) {}
516    virtual void SetUp() {
517      Caffe::set_random_seed(1701);
518      blob_bottom_->Reshape(2, 3, 6, 5);
519      FillerParameter filler_param;
520      GaussianFiller<Dtype> filler(filler_param);
521      filler.Fill(this->blob_bottom_);
522      blob_bottom_vec_.push_back(blob_bottom_);
523      blob_top_vec_.push_back(blob_top_);
524    }
525    virtual ~CuDNNPoolingLayerTest() {
526      delete blob_bottom_;
527      delete blob_top_;
528      delete blob_top_mask_;
529    }
530    Blob<Dtype>* const blob_bottom_;
531    Blob<Dtype>* const blob_top_;
532    Blob<Dtype>* const blob_top_mask_;
533    vector<Blob<Dtype>*> blob_bottom_vec_;
534    vector<Blob<Dtype>*> blob_top_vec_;
535    void TestForwardSquare() {
536      LayerParameter layer_param;
537      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
538      pooling_param->set_kernel_size(2);
539      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
540      const int num = 2;
541      const int channels = 2;
542      blob_bottom_->Reshape(num, channels, 3, 5);
543      for (int i = 0; i < 15 * num * channels; i += 15) {
544        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
545        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
546        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
547        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
548        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
549        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
550        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
551        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
552        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
553        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
554        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
555        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
556        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
557        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
558        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
559      }
560      CuDNNPoolingLayer<Dtype> layer(layer_param);
561      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
562      EXPECT_EQ(blob_top_->num(), num);
563      EXPECT_EQ(blob_top_->channels(), channels);
564      EXPECT_EQ(blob_top_->height(), 2);
565      EXPECT_EQ(blob_top_->width(), 4);
566      if (blob_top_vec_.size() > 1) {
567        EXPECT_EQ(blob_top_mask_->num(), num);
568        EXPECT_EQ(blob_top_mask_->channels(), channels);
569        EXPECT_EQ(blob_top_mask_->height(), 2);
570        EXPECT_EQ(blob_top_mask_->width(), 4);
571      }
572      layer.Forward(blob_bottom_vec_, blob_top_vec_);
573      for (int i = 0; i < 8 * num * channels; i += 8) {
574        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
575        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
576        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
577        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
578        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
579        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
580        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
581        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
582      }
583      if (blob_top_vec_.size() > 1) {
584        for (int i = 0; i < 8 * num * channels; i += 8) {
585          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 0],  5);
586          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 1],  2);
587          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 2],  2);
588          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 3],  9);
589          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 4],  5);
590          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 5], 12);
591          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 6], 12);
592          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 7],  9);
593        }
594      }
595    }
596    void TestForwardRectHigh() {
597      LayerParameter layer_param;
598      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
599      pooling_param->set_kernel_h(3);
600      pooling_param->set_kernel_w(2);
601      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
602      const int num = 2;
603      const int channels = 2;
604      blob_bottom_->Reshape(num, channels, 6, 6);
605      for (int i = 0; i < 36 * num * channels; i += 36) {
606        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
607        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
608        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
609        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
610        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
611        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
612        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
613        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
614        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
615        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
616        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
617        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
618        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
619        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
620        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
621        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
622        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
623        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
624        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
625        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
626        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
627        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
628        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
629        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
630        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
631        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
632        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
633        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
634        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
635        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
636        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
637        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
638        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
639        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
640        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
641        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
642      }
643      CuDNNPoolingLayer<Dtype> layer(layer_param);
644      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
645      EXPECT_EQ(blob_top_->num(), num);
646      EXPECT_EQ(blob_top_->channels(), channels);
647      EXPECT_EQ(blob_top_->height(), 4);
648      EXPECT_EQ(blob_top_->width(), 5);
649      if (blob_top_vec_.size() > 1) {
650        EXPECT_EQ(blob_top_mask_->num(), num);
651        EXPECT_EQ(blob_top_mask_->channels(), channels);
652        EXPECT_EQ(blob_top_mask_->height(), 4);
653        EXPECT_EQ(blob_top_mask_->width(), 5);
654      }
655      layer.Forward(blob_bottom_vec_, blob_top_vec_);
656      for (int i = 0; i < 20 * num * channels; i += 20) {
657        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
658        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
659        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
660        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
661        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
662        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
663        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
664        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
665        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
666        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
667        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
668        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
669        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
670        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
671        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
672        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
673        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
674        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
675        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
676        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
677      }
678      if (blob_top_vec_.size() > 1) {
679        for (int i = 0; i < 20 * num * channels; i += 20) {
680          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
681          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
682          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
683          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3], 16);
684          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4], 16);
685          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
686          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 20);
687          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 20);
688          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 16);
689          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 16);
690          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 12);
691          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 26);
692          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
693          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 16);
694          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 16);
695          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 31);
696          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
697          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 26);
698          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 34);
699          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
700        }
701      }
702    }
703    void TestForwardRectWide() {
704      LayerParameter layer_param;
705      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
706      pooling_param->set_kernel_h(2);
707      pooling_param->set_kernel_w(3);
708      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
709      const int num = 2;
710      const int channels = 2;
711      blob_bottom_->Reshape(num, channels, 6, 6);
712      for (int i = 0; i < 36 * num * channels; i += 36) {
713        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
714        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
715        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
716        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
717        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
718        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
719        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
720        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
721        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
722        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
723        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
724        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
725        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
726        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
727        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
728        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
729        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
730        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
731        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
732        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
733        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
734        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
735        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
736        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
737        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
738        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
739        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
740        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
741        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
742        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
743        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
744        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
745        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
746        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
747        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
748        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
749      }
750      CuDNNPoolingLayer<Dtype> layer(layer_param);
751      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
752      EXPECT_EQ(blob_top_->num(), num);
753      EXPECT_EQ(blob_top_->channels(), channels);
754      EXPECT_EQ(blob_top_->height(), 5);
755      EXPECT_EQ(blob_top_->width(), 4);
756      if (blob_top_vec_.size() > 1) {
757        EXPECT_EQ(blob_top_mask_->num(), num);
758        EXPECT_EQ(blob_top_mask_->channels(), channels);
759        EXPECT_EQ(blob_top_mask_->height(), 5);
760        EXPECT_EQ(blob_top_mask_->width(), 4);
761      }
762      layer.Forward(blob_bottom_vec_, blob_top_vec_);
763      for (int i = 0; i < 20 * num * channels; i += 20) {
764        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
765        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
766        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
767        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
768        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
769        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
770        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
771        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
772        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
773        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
774        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
775        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
776        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
777        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
778        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
779        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
780        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
781        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
782        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
783        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
784      }
785      if (blob_top_vec_.size() > 1) {
786        for (int i = 0; i < 20 * num * channels; i += 20) {
787          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
788          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
789          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
790          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3],  3);
791          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4],  7);
792          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
793          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 16);
794          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 16);
795          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 20);
796          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 20);
797          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 20);
798          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 16);
799          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
800          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 26);
801          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 26);
802          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 21);
803          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
804          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 31);
805          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 26);
806          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
807        }
808      }
809    }
810  };
811  TYPED_TEST_CASE(CuDNNPoolingLayerTest, TestDtypes);
812  TYPED_TEST(CuDNNPoolingLayerTest, TestSetupCuDNN) {
813    LayerParameter layer_param;
814    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
815    pooling_param->set_kernel_size(3);
816    pooling_param->set_stride(2);
817    CuDNNPoolingLayer<TypeParam> layer(layer_param);
818    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
819    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
820    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
821    EXPECT_EQ(this->blob_top_->height(), 3);
822    EXPECT_EQ(this->blob_top_->width(), 2);
823  }
824  TYPED_TEST(CuDNNPoolingLayerTest, TestSetupPaddedCuDNN) {
825    LayerParameter layer_param;
826    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
827    pooling_param->set_kernel_size(3);
828    pooling_param->set_stride(2);
829    pooling_param->set_pad(1);
830    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
831    CuDNNPoolingLayer<TypeParam> layer(layer_param);
832    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
833    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
834    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
835    EXPECT_EQ(this->blob_top_->height(), 4);
836    EXPECT_EQ(this->blob_top_->width(), 3);
837  }
838  TYPED_TEST(CuDNNPoolingLayerTest, TestForwardMaxCuDNN) {
839    this->TestForwardSquare();
840    this->TestForwardRectHigh();
841    this->TestForwardRectWide();
842  }
843  TYPED_TEST(CuDNNPoolingLayerTest, TestGradientMaxCuDNN) {
844    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
845      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
846        LayerParameter layer_param;
847        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
848        pooling_param->set_kernel_h(kernel_h);
849        pooling_param->set_kernel_w(kernel_w);
850        pooling_param->set_stride(2);
851        pooling_param->set_pad(0);
852        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
853        CuDNNPoolingLayer<TypeParam> layer(layer_param);
854        GradientChecker<TypeParam> checker(1e-4, 1e-2);
855        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
856            this->blob_top_vec_);
857      }
858    }
859  }
860  TYPED_TEST(CuDNNPoolingLayerTest, TestForwardMaxPaddedCuDNN) {
861    LayerParameter layer_param;
862    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
863    pooling_param->set_kernel_size(3);
864    pooling_param->set_stride(2);
865    pooling_param->set_pad(2);
866    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
867    this->blob_bottom_->Reshape(1, 1, 3, 3);
868    this->blob_bottom_->mutable_cpu_data()[0] = 1;
869    this->blob_bottom_->mutable_cpu_data()[1] = 2;
870    this->blob_bottom_->mutable_cpu_data()[2] = 4;
871    this->blob_bottom_->mutable_cpu_data()[3] = 2;
872    this->blob_bottom_->mutable_cpu_data()[4] = 3;
873    this->blob_bottom_->mutable_cpu_data()[5] = 2;
874    this->blob_bottom_->mutable_cpu_data()[6] = 4;
875    this->blob_bottom_->mutable_cpu_data()[7] = 2;
876    this->blob_bottom_->mutable_cpu_data()[8] = 1;
877    CuDNNPoolingLayer<TypeParam> layer(layer_param);
878    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
879    EXPECT_EQ(this->blob_top_->num(), 1);
880    EXPECT_EQ(this->blob_top_->channels(), 1);
881    EXPECT_EQ(this->blob_top_->height(), 3);
882    EXPECT_EQ(this->blob_top_->width(), 3);
883    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
884    TypeParam epsilon = 1e-8;
885    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
886    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
887    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
888    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
889    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
890    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
891    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
892    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
893    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
894  }
895  TYPED_TEST(CuDNNPoolingLayerTest, TestForwardAveCuDNN) {
896    LayerParameter layer_param;
897    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
898    pooling_param->set_kernel_size(3);
899    pooling_param->set_stride(1);
900    pooling_param->set_pad(0);
901    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
902    this->blob_bottom_->Reshape(1, 1, 3, 3);
903    FillerParameter filler_param;
904    filler_param.set_value(TypeParam(2));
905    ConstantFiller<TypeParam> filler(filler_param);
906    filler.Fill(this->blob_bottom_);
907    CuDNNPoolingLayer<TypeParam> layer(layer_param);
908    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
909    EXPECT_EQ(this->blob_top_->num(), 1);
910    EXPECT_EQ(this->blob_top_->channels(), 1);
911    EXPECT_EQ(this->blob_top_->height(), 1);
912    EXPECT_EQ(this->blob_top_->width(), 1);
913    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
914    TypeParam epsilon = 1e-5;
915    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 2.0, epsilon);
916  }
917  TYPED_TEST(CuDNNPoolingLayerTest, TestGradientAveCuDNN) {
918    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
919      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
920        LayerParameter layer_param;
921        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
922        pooling_param->set_kernel_h(kernel_h);
923        pooling_param->set_kernel_w(kernel_w);
924        pooling_param->set_stride(2);
925        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
926        CuDNNPoolingLayer<TypeParam> layer(layer_param);
927        GradientChecker<TypeParam> checker(1e-2, 1e-2);
928        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
929            this->blob_top_vec_);
930      }
931    }
932  }
933  TYPED_TEST(CuDNNPoolingLayerTest, TestGradientAvePaddedCuDNN) {
934    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
935      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
936        LayerParameter layer_param;
937        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
938        pooling_param->set_kernel_h(kernel_h);
939        pooling_param->set_kernel_w(kernel_w);
940        pooling_param->set_stride(2);
941        pooling_param->set_pad(2);
942        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
943        CuDNNPoolingLayer<TypeParam> layer(layer_param);
944        GradientChecker<TypeParam> checker(1e-2, 1e-2);
945        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
946            this->blob_top_vec_);
947      }
948    }
949  }
950  #endif
951  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_pooling_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_pooling_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>20      Caffe::set_random_seed(1701);
21      blob_bottom_->Reshape(2, 3, 6, 5);
22      FillerParameter filler_param;
</pre></code></div>
                <div class="column column_space"><pre><code>22      Caffe::set_random_seed(1701);
23      blob_bottom_->Reshape(2, 3, 6, 5);
24      FillerParameter filler_param;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    