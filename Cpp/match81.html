<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_socket.cpp & test_context.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_socket.cpp & test_context.cpp
      </h3>
      <h1 align="center">
        7.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_socket.cpp (3.9577837%)<TH>test_context.cpp (50.0%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match81-0.html#0',2,'match81-1.html#0',3)" NAME="0">(58-74)<TD><A HREF="javascript:ZweiFrames('match81-0.html#0',2,'match81-1.html#0',3)" NAME="0">(29-52)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_socket.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file is part of zmqpp.
 * Copyright (c) 2011-2015 Contributors as noted in the AUTHORS file.
 */

/*
 *  Created on: 8 Aug 2011
 *      Author: @benjamg
 */

#include &lt;array&gt;
#include &lt;list&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

#include &lt;boost/test/unit_test.hpp&gt;

#include &quot;zmqpp/context.hpp&quot;
#include &quot;zmqpp/socket.hpp&quot;
#include &quot;zmqpp/message.hpp&quot;
#include &quot;zmqpp/signal.hpp&quot;

BOOST_AUTO_TEST_SUITE( socket )

const int bubble_poll_timeout = 1;
const int max_poll_timeout = 100;

void bubble_subscriptions(zmqpp::socket&amp; socket)
{
	zmq_pollitem_t item = { socket, 0, ZMQ_POLLIN, 0 };
	int result = zmq_poll(&amp;item, 1, bubble_poll_timeout);
	BOOST_REQUIRE_MESSAGE(0 == result, &quot;polling command failed to timeout during subscription bubble&quot;);
}

void wait_for_socket(zmqpp::socket&amp; socket)
{
	zmq_pollitem_t item = { socket, 0, ZMQ_POLLIN, 0 };
	int result = zmq_poll(&amp;item, 1, max_poll_timeout);
	BOOST_REQUIRE_MESSAGE(result &gt;= 0, &quot;polling command returned without expected value: &quot; &lt;&lt; zmq_strerror(zmq_errno()));
	BOOST_REQUIRE_MESSAGE(0 != result, &quot;polling command returned with timeout after &quot; &lt;&lt; max_poll_timeout &lt;&lt; &quot; milliseconds&quot;);
	BOOST_REQUIRE_MESSAGE(1 == result, &quot;polling command claims &quot; &lt;&lt; result &lt;&lt; &quot; sockets have events but we only gave it one&quot;);
	BOOST_REQUIRE_MESSAGE(item.revents &amp; ZMQ_POLLIN, &quot;events do not match expected POLLIN event: &quot; &lt;&lt; item.revents);
}

BOOST_AUTO_TEST_CASE( socket_creation )
{
	zmqpp::context context;
	zmqpp::socket socket(context, zmqpp::socket_type::pull);
}

<A NAME="0"></A>BOOST_AUTO_TEST_CASE( socket_creation_bad_type )
{
	zmqpp::context context;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match81-1.html#0',3,'match81-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	BOOST_CHECK_THROW(zmqpp::socket socket(context, static_cast&lt;zmqpp::socket_type&gt;(-1)), zmqpp::zmq_internal_exception);
}

BOOST_AUTO_TEST_CASE( valid_socket )
{
	zmqpp::context context;
	zmqpp::socket socket(context, zmqpp::socket_type::pull);
	socket.bind(&quot;inproc://test&quot;);

	zmqpp::message message;
	BOOST_CHECK(!socket.receive(message, true));
}

BOOST_AUTO_TEST_CASE( valid_move_supporting )
{
	zmqpp::context context;
	std::unique_ptr&lt;zmqpp::socket&gt; original(new zmqpp::socket(context, zmqpp::socket_type::pull));</B></FONT>
	original-&gt;bind(&quot;inproc://test&quot;);

	zmqpp::socket clone(std::move(*original));
	//original.reset();

	zmqpp::message message;
	BOOST_CHECK(!clone.receive(message, true));
}

BOOST_AUTO_TEST_CASE( simple_pull_push )
{
	zmqpp::context context;

	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.bind(&quot;inproc://test&quot;);

	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.connect(&quot;inproc://test&quot;);

	BOOST_CHECK(pusher.send(&quot;hello world!&quot;));

	wait_for_socket(puller);

	std::string message;
	BOOST_CHECK(puller.receive(message));

	BOOST_CHECK_EQUAL(&quot;hello world!&quot;, message);
	BOOST_CHECK(!puller.has_more_parts());
}

BOOST_AUTO_TEST_CASE( simple_receive_raw )
{
	zmqpp::context context;
	char buf[64];
	size_t len;

	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.bind(&quot;inproc://test&quot;);

	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.connect(&quot;inproc://test&quot;);

	BOOST_CHECK(pusher.send(&quot;hello world!&quot;));

	wait_for_socket(puller);

	len = sizeof(buf);
	BOOST_CHECK(puller.receive_raw(buf, len));

	std::string message(buf, len);
	BOOST_CHECK_EQUAL(&quot;hello world!&quot;, message);
	BOOST_CHECK(!puller.has_more_parts());
}

BOOST_AUTO_TEST_CASE( simple_receive_raw_short_buf )
{
	zmqpp::context context;
	char buf[64];
	size_t len;

	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.bind(&quot;inproc://test&quot;);

	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.connect(&quot;inproc://test&quot;);

	BOOST_CHECK(pusher.send(&quot;hello world!&quot;));

	wait_for_socket(puller);

	memset(buf, 0xee, sizeof(buf));
	len = 5;
	BOOST_CHECK(puller.receive_raw(buf, len));

	BOOST_CHECK_EQUAL(5, len);
	BOOST_CHECK_EQUAL(0xee, buf[5] &amp; 0xff);
	BOOST_CHECK_EQUAL(0xee, buf[6] &amp; 0xff);
	std::string message(buf, len);
	BOOST_CHECK_EQUAL(&quot;hello&quot;, message);
	BOOST_CHECK(!puller.has_more_parts());
}

BOOST_AUTO_TEST_CASE( multipart_pair )
{
	zmqpp::context context;

	zmqpp::socket alpha(context, zmqpp::socket_type::pair);
	alpha.bind(&quot;inproc://test&quot;);

	zmqpp::socket omega(context, zmqpp::socket_type::pair);
	omega.connect(&quot;inproc://test&quot;);

	BOOST_CHECK(alpha.send(&quot;hello&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(alpha.send(&quot;world&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(alpha.send(&quot;!&quot;));

	wait_for_socket(omega);

	std::string message;

	BOOST_CHECK(omega.receive(message));
	BOOST_CHECK_EQUAL(&quot;hello&quot;, message);
	BOOST_REQUIRE(omega.has_more_parts());

	BOOST_CHECK(omega.receive(message));
	BOOST_CHECK_EQUAL(&quot;world&quot;, message);
	BOOST_REQUIRE(omega.has_more_parts());

	BOOST_CHECK(omega.receive(message));
	BOOST_CHECK_EQUAL(&quot;!&quot;, message);
	BOOST_CHECK(!omega.has_more_parts());
}

BOOST_AUTO_TEST_CASE( subscribe_via_option )
{
	zmqpp::context context;

	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
	publisher.bind(&quot;inproc://test&quot;);

	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
	subscriber.connect(&quot;inproc://test&quot;);
	subscriber.set(zmqpp::socket_option::subscribe, &quot;watch1&quot;);

	BOOST_CHECK(publisher.send(&quot;watch0&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents0&quot;));
	BOOST_CHECK(publisher.send(&quot;watch1&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents1&quot;));

	wait_for_socket(subscriber);

	std::string message;
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;watch1&quot;, message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;contents1&quot;, message);
	BOOST_CHECK(!subscriber.has_more_parts());
}

BOOST_AUTO_TEST_CASE( subscribe_helpers )
{
	zmqpp::context context;

	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
	publisher.bind(&quot;inproc://test&quot;);

	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
	subscriber.connect(&quot;inproc://test&quot;);
	subscriber.subscribe(&quot;watch1&quot;);
	subscriber.subscribe(&quot;watch2&quot;);

	BOOST_CHECK(publisher.send(&quot;watch0&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents0&quot;));
	BOOST_CHECK(publisher.send(&quot;watch1&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents1&quot;));
	BOOST_CHECK(publisher.send(&quot;watch2&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents2&quot;));
	BOOST_CHECK(publisher.send(&quot;watch3&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents3&quot;));

	wait_for_socket(subscriber);

	std::string message;
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;watch1&quot;, message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;contents1&quot;, message);
	BOOST_CHECK(!subscriber.has_more_parts());

	wait_for_socket(subscriber);

	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;watch2&quot;, message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;contents2&quot;, message);
	BOOST_CHECK(!subscriber.has_more_parts());

	subscriber.unsubscribe(&quot;watch1&quot;);
	bubble_subscriptions(subscriber);

	BOOST_CHECK(publisher.send(&quot;watch0&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents0&quot;));
	BOOST_CHECK(publisher.send(&quot;watch1&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents1&quot;));
	BOOST_CHECK(publisher.send(&quot;watch2&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents2&quot;));

	wait_for_socket(subscriber);

	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;watch2&quot;, message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;contents2&quot;, message);
	BOOST_CHECK(!subscriber.has_more_parts());
}

BOOST_AUTO_TEST_CASE( subscribe_helpers_multitopic_method )
{
	std::list&lt;std::string&gt; topics = { &quot;watch1&quot;, &quot;watch2&quot; };

	zmqpp::context context;

	zmqpp::socket publisher(context, zmqpp::socket_type::publish);
	publisher.bind(&quot;inproc://test&quot;);

	zmqpp::socket subscriber(context, zmqpp::socket_type::subscribe);
	subscriber.connect(&quot;inproc://test&quot;);
	subscriber.subscribe(topics.begin(), topics.end());

	BOOST_CHECK(publisher.send(&quot;watch0&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents0&quot;));
	BOOST_CHECK(publisher.send(&quot;watch1&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents1&quot;));
	BOOST_CHECK(publisher.send(&quot;watch2&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents2&quot;));
	BOOST_CHECK(publisher.send(&quot;watch3&quot;, zmqpp::socket::send_more));
	BOOST_CHECK(publisher.send(&quot;contents3&quot;));

	wait_for_socket(subscriber);

	std::string message;
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;watch1&quot;, message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;contents1&quot;, message);
	BOOST_CHECK(!subscriber.has_more_parts());

	wait_for_socket(subscriber);

	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;watch2&quot;, message);
	BOOST_REQUIRE(subscriber.has_more_parts());
	BOOST_CHECK(subscriber.receive(message));
	BOOST_CHECK_EQUAL(&quot;contents2&quot;, message);
	BOOST_CHECK(!subscriber.has_more_parts());
}

BOOST_AUTO_TEST_CASE( sending_messages )
{
	zmqpp::context context;

	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.bind(&quot;inproc://test&quot;);

	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect(&quot;inproc://test&quot;);

	zmqpp::message message;
	std::string part(&quot;another world&quot;);

	message.add(&quot;hello world!&quot;);
	message.add(part);

	pusher.send(message);
	BOOST_CHECK_EQUAL(0, message.parts());

	wait_for_socket(puller);

	BOOST_CHECK(puller.receive(part));
	BOOST_CHECK_EQUAL(&quot;hello world!&quot;, part);
	BOOST_REQUIRE(puller.has_more_parts());
	BOOST_CHECK(puller.receive(part));
	BOOST_CHECK_EQUAL(&quot;another world&quot;, part);
	BOOST_CHECK(!puller.has_more_parts());
}

BOOST_AUTO_TEST_CASE( receiving_messages )
{
	zmqpp::context context;

	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.bind(&quot;inproc://test&quot;);

	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect(&quot;inproc://test&quot;);

	zmqpp::message message;
	std::string part(&quot;another world&quot;);

	message.add(&quot;hello world!&quot;);
	message.add(part);

	pusher.send(message);
	BOOST_CHECK_EQUAL(0, message.parts());

	wait_for_socket(puller);

	BOOST_CHECK(puller.receive(message));
	BOOST_REQUIRE_EQUAL(2, message.parts());
	BOOST_CHECK_EQUAL(&quot;hello world!&quot;, message.get(0));
	BOOST_CHECK_EQUAL(&quot;another world&quot;, message.get(1));
	BOOST_CHECK(!puller.has_more_parts());
}

BOOST_AUTO_TEST_CASE( receive_over_old_messages )
{
	zmqpp::context context;

	zmqpp::socket pusher( context, zmqpp::socket_type::push );
	pusher.bind( &quot;inproc://test&quot; );

	zmqpp::socket puller( context, zmqpp::socket_type::pull );
	puller.connect( &quot;inproc://test&quot;);

	pusher.send( &quot;first message&quot; );
	pusher.send( &quot;second message&quot; );

	wait_for_socket( puller );

	zmqpp::message message;
	BOOST_CHECK( puller.receive( message ) );
	BOOST_REQUIRE_EQUAL( 1, message.parts() );
	BOOST_CHECK_EQUAL( &quot;first message&quot;, message.get(0) );

	BOOST_CHECK( puller.receive( message ) );
	BOOST_REQUIRE_EQUAL( 1, message.parts() );
	BOOST_CHECK_EQUAL( &quot;second message&quot;, message.get(0) );
}

BOOST_AUTO_TEST_CASE( cleanup_safe_with_pending_data )
{
	zmqpp::context context;

	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.bind(&quot;inproc://test&quot;);

	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect(&quot;inproc://test&quot;);

	zmqpp::message message;
	std::string part(&quot;another world&quot;);

	message.add(&quot;hello world!&quot;);
	message.add(part);

	pusher.send(message);
	BOOST_CHECK_EQUAL(0, message.parts());
}

BOOST_AUTO_TEST_CASE( multitarget_puller )
{
	std::vector&lt;std::string&gt; endpoints = { &quot;inproc://test1&quot;, &quot;inproc://test2&quot; };

	zmqpp::context context;

	zmqpp::socket pusher1(context, zmqpp::socket_type::push);
	pusher1.bind(endpoints[0]);

	zmqpp::socket pusher2(context, zmqpp::socket_type::push);
	pusher2.bind(endpoints[1]);

	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect(endpoints.begin(), endpoints.end());

	BOOST_CHECK(pusher1.send(&quot;hello world!&quot;));
	BOOST_CHECK(pusher2.send(&quot;a test message&quot;));

	wait_for_socket(puller);

	std::string message;
	BOOST_CHECK(puller.receive(message));
	BOOST_CHECK_EQUAL(&quot;hello world!&quot;, message);
	BOOST_CHECK(puller.receive(message));
	BOOST_CHECK_EQUAL(&quot;a test message&quot;, message);
}


BOOST_AUTO_TEST_CASE( test_receive_send_signals )
{
    zmqpp::context ctx;
    zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
    zmqpp::socket p2(ctx, zmqpp::socket_type::pair);

    p1.bind(&quot;inproc://test&quot;);
    p2.connect(&quot;inproc://test&quot;);

    p1.send(zmqpp::signal::test);
    p1.send(&quot;....&quot;);
    p1.send(zmqpp::signal::stop);

    zmqpp::signal s;
    std::string str;

    p2.receive(s);
    BOOST_CHECK_EQUAL(zmqpp::signal::test, s);
    p2.receive(str);
    p2.send(zmqpp::signal::test);
    p2.receive(s);
    BOOST_CHECK_EQUAL(zmqpp::signal::stop, s);

    p1.receive(s);
    BOOST_CHECK_EQUAL(zmqpp::signal::test, s);
}

BOOST_AUTO_TEST_CASE( test_wait )
{
    zmqpp::context ctx;
    zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
    zmqpp::socket p2(ctx, zmqpp::socket_type::pair);

    p1.bind(&quot;inproc://test&quot;);
    p2.connect(&quot;inproc://test&quot;);

    p1.send(zmqpp::signal::test);
    p1.send(&quot;....&quot;);
    p1.send(&quot;___&quot;);
    p1.send(zmqpp::signal::stop);

    // test wait(): the non signal message must be discarded.
    BOOST_CHECK_EQUAL(zmqpp::signal::test, p2.wait());
    BOOST_CHECK_EQUAL(zmqpp::signal::stop, p2.wait());
}

BOOST_AUTO_TEST_CASE( test_signal_block_noblock )
{
    zmqpp::context ctx;
    zmqpp::socket p1(ctx, zmqpp::socket_type::pair);
    zmqpp::socket p2(ctx, zmqpp::socket_type::pair);

    p1.bind(&quot;inproc://test&quot;);

    BOOST_CHECK_EQUAL(false, p1.send(zmqpp::signal::test, true)); //noblock
    //p1.send(zmqpp::signal::test); // would block indefinitely
    p2.connect(&quot;inproc://test&quot;);

    zmqpp::signal sig;
    BOOST_CHECK_EQUAL(false, p1.receive(sig, true)); //noblock
    p1.send(zmqpp::signal::test);
    BOOST_CHECK_EQUAL(true, p2.receive(sig, true)); //noblock
}

#if (ZMQ_VERSION_MAJOR &gt;= 4)
BOOST_AUTO_TEST_CASE( simple_stream )
{
	zmqpp::context context;

	zmqpp::socket s1(context, zmqpp::socket_type::stream);
	zmqpp::socket s2(context, zmqpp::socket_type::stream);

	s1.bind(&quot;inproc://test&quot;);
	s2.connect(&quot;inproc://test&quot;);

	std::string identity;
	s2.get(zmqpp::socket_option::identity, identity);
	zmqpp::message request;
	request &lt;&lt; identity;
	request &lt;&lt; &quot;Hello world!&quot;;
	BOOST_CHECK(s2.send(request));

	zmqpp::message response;
	BOOST_CHECK(s1.receive(response));
	BOOST_CHECK(response.parts() == 2);
	BOOST_CHECK(response.get(1) == &quot;Hello world!&quot;);
}
#endif

#ifndef TRAVIS_CI_BUILD //do not run when building on travis-ci (this cause oom error and kill the test process)
BOOST_AUTO_TEST_CASE( sending_large_messages_string )
{
	zmqpp::context context;

	zmqpp::socket pusher(context, zmqpp::socket_type::push);
	pusher.bind(&quot;inproc://test&quot;);

	zmqpp::socket puller(context, zmqpp::socket_type::pull);
	puller.connect(&quot;inproc://test&quot;);

	std::string message;
    const size_t bytes_to_send = static_cast&lt;size_t&gt;(1024 * 1024 * 1024);
    message.reserve(bytes_to_send);
    for (size_t i = 0; i &lt; bytes_to_send; i++)
    {
        message.push_back('A' + (i % 26));
    }

	BOOST_CHECK(pusher.send(message));

	zmq_pollitem_t item = { puller, 0, ZMQ_POLLIN, 0 };
    const int poll_timeout = 1000000;
	int result = zmq_poll(&amp;item, 1, poll_timeout);
	BOOST_REQUIRE_MESSAGE(result &gt;= 0, &quot;polling command returned without expected value: &quot; &lt;&lt; zmq_strerror(zmq_errno()));
	BOOST_REQUIRE_MESSAGE(0 != result, &quot;polling command returned with timeout after &quot; &lt;&lt; poll_timeout &lt;&lt; &quot; milliseconds&quot;);
	BOOST_REQUIRE_MESSAGE(1 == result, &quot;polling command claims &quot; &lt;&lt; result &lt;&lt; &quot; sockets have events but we only gave it one&quot;);
	BOOST_REQUIRE_MESSAGE(item.revents &amp; ZMQ_POLLIN, &quot;events do not match expected POLLIN event: &quot; &lt;&lt; item.revents);

    std::string received_message;

	BOOST_CHECK(puller.receive(received_message));
	BOOST_CHECK_EQUAL(0, message.compare(received_message));
	BOOST_CHECK(!puller.has_more_parts());
}
#endif

#if (ZMQ_VERSION_MAJOR &gt;= 4)
BOOST_AUTO_TEST_CASE( test_simple_monitor )
{
    zmqpp::context ctx;
    zmqpp::socket server(ctx, zmqpp::socket_type::push);
    server.bind(&quot;tcp://*:0&quot;);
    const std::string endpoint = server.get&lt;std::string&gt;(zmqpp::socket_option::last_endpoint);

    server.monitor(&quot;inproc://test_monitor&quot;, zmqpp::event::all);

    zmqpp::socket monitor(ctx, zmqpp::socket_type::pair);
    monitor.connect(&quot;inproc://test_monitor&quot;);

    zmqpp::socket client(ctx, zmqpp::socket_type::pull);
    client.connect(endpoint);

    // Receive event accepted
    {
        zmqpp::message_t message;
        BOOST_CHECK( monitor.receive( message ) );
        BOOST_REQUIRE_EQUAL(2, message.parts());

#if (ZMQ_VERSION_MINOR &gt;= 1)
        const uint8_t *ptr = reinterpret_cast&lt;const uint8_t *&gt;(message.raw_data(0));
        uint16_t ev = *(reinterpret_cast&lt;const uint16_t *&gt;(ptr));
        // uint32_t value = *(reinterpret_cast&lt;const uint32_t *&gt;(ptr + 2));
        BOOST_CHECK_EQUAL( zmqpp::event::accepted, ev );
        BOOST_CHECK_EQUAL(&quot;tcp://0.0.0.0:0&quot;, message.get(1));
        // value is the underlying file descriptor. we cannot check its value against anything meaningful
#else
        zmq_event_t const* event = static_cast&lt;zmq_event_t const*&gt;( message.raw_data(0) );
        BOOST_CHECK_EQUAL( zmqpp::event::accepted, event-&gt;event );
        BOOST_CHECK_EQUAL( 0, event-&gt;value );
        BOOST_CHECK_EQUAL(&quot;tcp://0.0.0.0:0&quot;, message.get(1));
#endif
    }

    server.unmonitor();

    zmqpp::socket client2(ctx, zmqpp::socket_type::pull);
    client2.connect(endpoint);

    // Receive event monitor_stopped
    {
        zmqpp::message_t message;
        BOOST_CHECK( monitor.receive( message ) );
        BOOST_REQUIRE_EQUAL(2, message.parts());

#if (ZMQ_VERSION_MINOR &gt;= 1)
        const uint8_t *ptr = reinterpret_cast&lt;const uint8_t *&gt;(message.raw_data(0));
        uint16_t ev = *(reinterpret_cast&lt;const uint16_t *&gt;(ptr));
        // uint32_t value = *(reinterpret_cast&lt;const uint32_t *&gt;(ptr + 2));
        BOOST_CHECK_EQUAL( zmqpp::event::monitor_stopped, ev );
#else
        zmq_event_t const* event = static_cast&lt;zmq_event_t const*&gt;( message.raw_data(0) );
        BOOST_CHECK_EQUAL( zmqpp::event::monitor_stopped, event-&gt;event );
#endif
    }

    // Receive nothing else
    {
        zmqpp::message_t message;
        BOOST_CHECK( !monitor.receive( message, true ) );
    }

}
#endif

BOOST_AUTO_TEST_SUITE_END()
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_context.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file is part of zmqpp.
 * Copyright (c) 2011-2015 Contributors as noted in the AUTHORS file.
 */

/*
 *  Created on: 9 Aug 2011
 *      Author: @benjamg
 */

#include &lt;boost/test/unit_test.hpp&gt;

#include &quot;zmqpp/context.hpp&quot;

BOOST_AUTO_TEST_SUITE( context )

BOOST_AUTO_TEST_CASE( initialises )
{
	zmqpp::context context;
	BOOST_CHECK(context);
}
<A NAME="0"></A>
BOOST_AUTO_TEST_CASE( move_supporting )
{
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match81-0.html#0',2,'match81-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	zmqpp::context first;
	BOOST_CHECK(first);

	zmqpp::context second( std::move(first) );
	BOOST_CHECK(second);
	BOOST_CHECK(!first);
}

BOOST_AUTO_TEST_CASE( defaults )
{
	zmqpp::context context;
	BOOST_CHECK_GE(context.get(zmqpp::context_option::io_threads), ZMQ_IO_THREADS_DFLT);
	BOOST_CHECK_GE(context.get(zmqpp::context_option::max_sockets), ZMQ_MAX_SOCKETS_DFLT);
}

BOOST_AUTO_TEST_CASE( validaty )
{
	zmqpp::context context;
	BOOST_CHECK(context);

	context.terminate();
	BOOST_CHECK(!context);

	BOOST_CHECK_THROW(context.get(zmqpp::context_option::io_threads), zmqpp::invalid_instance);</B></FONT>
}

BOOST_AUTO_TEST_CASE( throws_exception )
{
#if (ZMQ_VERSION_MAJOR &lt; 3) || ((ZMQ_VERSION_MAJOR == 3) &amp;&amp; (ZMQ_VERSION_MINOR &lt; 2))
	BOOST_CHECK_THROW(new zmqpp::context(-1), zmqpp::zmq_internal_exception);
#else
	zmqpp::context context;
	BOOST_CHECK_THROW(context.set(zmqpp::context_option::io_threads, -1), zmqpp::zmq_internal_exception);
#endif
}

BOOST_AUTO_TEST_SUITE_END()

</PRE>
</div>
  </div>
</body>
</html>
