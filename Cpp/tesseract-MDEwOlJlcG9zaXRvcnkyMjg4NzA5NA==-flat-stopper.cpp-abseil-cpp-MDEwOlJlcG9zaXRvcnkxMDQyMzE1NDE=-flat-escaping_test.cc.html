
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.3588634959851762%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-stopper.cpp</h3>
            <pre><code>1  #include <cctype>
2  #include <cmath>
3  #include <cstdio>
4  #include <cstring>
5  #include "stopper.h"
6  #ifndef DISABLED_LEGACY_ENGINE
7  #  include "ambigs.h"
8  #endif
9  #include <tesseract/unichar.h>
10  #include "ccutil.h"
11  #include "dict.h"
12  #include "helpers.h"
13  #include "matchdefs.h"
14  #include "pageres.h"
15  #include "params.h"
16  #include "ratngs.h"
17  namespace tesseract {
18  bool Dict::AcceptableChoice(const WERD_CHOICE &best_choice,
19                              XHeightConsistencyEnum xheight_consistency) {
20    float CertaintyThreshold = stopper_nondict_certainty_base;
21    int WordSize;
22    if (stopper_no_acceptable_choices) {
23      return false;
24    }
25    if (best_choice.empty()) {
26      return false;
27    }
28    bool no_dang_ambigs = !best_choice.dangerous_ambig_found();
29    bool is_valid_word = valid_word_permuter(best_choice.permuter(), false);
30    bool is_case_ok = case_ok(best_choice);
31    if (stopper_debug_level >= 1) {
32      const char *xht = "UNKNOWN";
<span onclick='openModal()' class='match'>33      switch (xheight_consistency) {
34        case XH_GOOD:
35          xht = "NORMAL";
36          break;
37        case XH_SUBNORMAL:
38          xht = "SUBNORMAL";
39          break;
40        case XH_INCONSISTENT:
41          xht = "INCONSISTENT";
42          break;
</span>43        default:
44          xht = "UNKNOWN";
45      }
46      tprintf("\nStopper:  %s (word=%c, case=%c, xht_ok=%s=[%g,%g])\n",
47              best_choice.unichar_string().c_str(), (is_valid_word ? 'y' : 'n'),
48              (is_case_ok ? 'y' : 'n'), xht, best_choice.min_x_height(), best_choice.max_x_height());
49    }
50    if (reject_offset_ <= 0.0f && !is_valid_word) {
51      return false;
52    }
53    if (is_valid_word && is_case_ok) {
54      WordSize = LengthOfShortestAlphaRun(best_choice);
55      WordSize -= stopper_smallword_size;
56      if (WordSize < 0) {
57        WordSize = 0;
58      }
59      CertaintyThreshold += WordSize * stopper_certainty_per_char;
60    }
61    if (stopper_debug_level >= 1) {
62      tprintf("Stopper:  Rating = %4.1f, Certainty = %4.1f, Threshold = %4.1f\n",
63              best_choice.rating(), best_choice.certainty(), CertaintyThreshold);
64    }
65    if (no_dang_ambigs && best_choice.certainty() > CertaintyThreshold &&
66        xheight_consistency < XH_INCONSISTENT && UniformCertainties(best_choice)) {
67      return true;
68    } else {
69      if (stopper_debug_level >= 1) {
70        tprintf(
71            "AcceptableChoice() returned false"
72            " (no_dang_ambig:%d cert:%.4g thresh:%g uniform:%d)\n",
73            no_dang_ambigs, best_choice.certainty(), CertaintyThreshold,
74            UniformCertainties(best_choice));
75      }
76      return false;
77    }
78  }
79  bool Dict::AcceptableResult(WERD_RES *word) const {
80    if (word->best_choice == nullptr) {
81      return false;
82    }
83    float CertaintyThreshold = stopper_nondict_certainty_base - reject_offset_;
84    int WordSize;
85    if (stopper_debug_level >= 1) {
86      tprintf("\nRejecter: %s (word=%c, case=%c, unambig=%c, multiple=%c)\n",
87              word->best_choice->debug_string().c_str(), (valid_word(*word->best_choice) ? 'y' : 'n'),
88              (case_ok(*word->best_choice) ? 'y' : 'n'),
89              word->best_choice->dangerous_ambig_found() ? 'n' : 'y',
90              word->best_choices.singleton() ? 'n' : 'y');
91    }
92    if (word->best_choice->empty() || !word->best_choices.singleton()) {
93      return false;
94    }
95    if (valid_word(*word->best_choice) && case_ok(*word->best_choice)) {
96      WordSize = LengthOfShortestAlphaRun(*word->best_choice);
97      WordSize -= stopper_smallword_size;
98      if (WordSize < 0) {
99        WordSize = 0;
100      }
101      CertaintyThreshold += WordSize * stopper_certainty_per_char;
102    }
103    if (stopper_debug_level >= 1) {
104      tprintf("Rejecter: Certainty = %4.1f, Threshold = %4.1f   ", word->best_choice->certainty(),
105              CertaintyThreshold);
106    }
107    if (word->best_choice->certainty() > CertaintyThreshold && !stopper_no_acceptable_choices) {
108      if (stopper_debug_level >= 1) {
109        tprintf("ACCEPTED\n");
110      }
111      return true;
112    } else {
113      if (stopper_debug_level >= 1) {
114        tprintf("REJECTED\n");
115      }
116      return false;
117    }
118  }
119  #if !defined(DISABLED_LEGACY_ENGINE)
120  bool Dict::NoDangerousAmbig(WERD_CHOICE *best_choice, DANGERR *fixpt, bool fix_replaceable,
121                              MATRIX *ratings) {
122    if (stopper_debug_level > 2) {
123      tprintf("\nRunning NoDangerousAmbig() for %s\n", best_choice->debug_string().c_str());
124    }
125    BLOB_CHOICE_LIST_VECTOR ambig_blob_choices;
126    bool ambigs_found = false;
127    for (int pass = 0; pass < (fix_replaceable ? 2 : 1); ++pass) {
128      bool replace = (fix_replaceable && pass == 0);
129      const UnicharAmbigsVector &table =
130          replace ? getUnicharAmbigs().replace_ambigs() : getUnicharAmbigs().dang_ambigs();
131      if (!replace) {
132        for (unsigned i = 0; i < best_choice->length(); ++i) {
133          auto *lst = new BLOB_CHOICE_LIST();
134          BLOB_CHOICE_IT lst_it(lst);
135          lst_it.add_to_end(
136              new BLOB_CHOICE(best_choice->unichar_id(i), 0.0, 0.0, -1, 0, 1, 0, BCC_AMBIG));
137          ambig_blob_choices.push_back(lst);
138        }
139      }
140      UNICHAR_ID wrong_ngram[MAX_AMBIG_SIZE + 1];
141      int wrong_ngram_index;
142      int blob_index = 0;
143      for (unsigned i = 0; i < best_choice->length(); blob_index += best_choice->state(i), ++i) {
144        auto curr_unichar_id = best_choice->unichar_id(i);
145        if (stopper_debug_level > 2) {
146          tprintf("Looking for %s ngrams starting with %s:\n", replace ? "replaceable" : "ambiguous",
147                  getUnicharset().debug_str(curr_unichar_id).c_str());
148        }
149        int num_wrong_blobs = best_choice->state(i);
150        wrong_ngram_index = 0;
151        wrong_ngram[wrong_ngram_index] = curr_unichar_id;
152        if (curr_unichar_id == INVALID_UNICHAR_ID || static_cast<size_t>(curr_unichar_id) >= table.size() ||
153            table[curr_unichar_id] == nullptr) {
154          continue; 
155        }
156        AmbigSpec_IT spec_it(table[curr_unichar_id]);
157        for (spec_it.mark_cycle_pt(); !spec_it.cycled_list();) {
158          const AmbigSpec *ambig_spec = spec_it.data();
159          wrong_ngram[wrong_ngram_index + 1] = INVALID_UNICHAR_ID;
160          int compare = UnicharIdArrayUtils::compare(wrong_ngram, ambig_spec->wrong_ngram);
161          if (stopper_debug_level > 2) {
162            tprintf("candidate ngram: ");
163            UnicharIdArrayUtils::print(wrong_ngram, getUnicharset());
164            tprintf("current ngram from spec: ");
165            UnicharIdArrayUtils::print(ambig_spec->wrong_ngram, getUnicharset());
166            tprintf("comparison result: %d\n", compare);
167          }
168          if (compare == 0) {
169            if (fixpt != nullptr) {
170              UNICHAR_ID leftmost_id = ambig_spec->correct_fragments[0];
171              fixpt->push_back(DANGERR_INFO(blob_index, blob_index + num_wrong_blobs, replace,
172                                            getUnicharset().get_isngram(ambig_spec->correct_ngram_id),
173                                            leftmost_id));
174              if (stopper_debug_level > 1) {
175                tprintf("fixpt+=(%d %d %d %d %s)\n", blob_index, blob_index + num_wrong_blobs, false,
176                        getUnicharset().get_isngram(ambig_spec->correct_ngram_id),
177                        getUnicharset().id_to_unichar(leftmost_id));
178              }
179            }
180            if (replace) {
181              if (stopper_debug_level > 2) {
182                tprintf("replace ambiguity with %s : ",
183                        getUnicharset().id_to_unichar(ambig_spec->correct_ngram_id));
184                UnicharIdArrayUtils::print(ambig_spec->correct_fragments, getUnicharset());
185              }
186              ReplaceAmbig(i, ambig_spec->wrong_ngram_size, ambig_spec->correct_ngram_id, best_choice,
187                           ratings);
188            } else if (i > 0 || ambig_spec->type != CASE_AMBIG) {
189              if (stopper_debug_level > 2) {
190                tprintf("found ambiguity: ");
191                UnicharIdArrayUtils::print(ambig_spec->correct_fragments, getUnicharset());
192              }
193              ambigs_found = true;
194              for (int tmp_index = 0; tmp_index <= wrong_ngram_index; ++tmp_index) {
195                BLOB_CHOICE_IT bc_it(ambig_blob_choices[i + tmp_index]);
196                bc_it.add_to_end(new BLOB_CHOICE(ambig_spec->correct_fragments[tmp_index], -1.0, 0.0,
197                                                 -1, 0, 1, 0, BCC_AMBIG));
198              }
199            }
200            spec_it.forward();
201          } else if (compare == -1) {
202            unsigned next_index;
203            if (wrong_ngram_index + 1 < ambig_spec->wrong_ngram_size &&
204                ((next_index = wrong_ngram_index + 1 + i) < best_choice->length())) {
205              wrong_ngram[++wrong_ngram_index] = best_choice->unichar_id(next_index);
206              num_wrong_blobs += best_choice->state(next_index);
207            } else {
208              break; 
209            }
210          } else {
211            spec_it.forward();
212          }
213        } 
214      }   
215    }     
216    if (ambigs_found) {
217      if (stopper_debug_level > 2) {
218        tprintf("\nResulting ambig_blob_choices:\n");
219        for (unsigned i = 0; i < ambig_blob_choices.size(); ++i) {
220          print_ratings_list("", ambig_blob_choices.at(i), getUnicharset());
221          tprintf("\n");
222        }
223      }
224      WERD_CHOICE *alt_word = dawg_permute_and_select(ambig_blob_choices, 0.0);
225      ambigs_found = (alt_word->rating() < 0.0);
226      if (ambigs_found) {
227        if (stopper_debug_level >= 1) {
228          tprintf("Stopper: Possible ambiguous word = %s\n", alt_word->debug_string().c_str());
229        }
230        if (fixpt != nullptr) {
231          int orig_i = 0;
232          for (unsigned i = 0; i < alt_word->length(); ++i) {
233            const UNICHARSET &uchset = getUnicharset();
234            bool replacement_is_ngram = uchset.get_isngram(alt_word->unichar_id(i));
235            UNICHAR_ID leftmost_id = alt_word->unichar_id(i);
236            if (replacement_is_ngram) {
237              const char *str = uchset.id_to_unichar(leftmost_id);
238              int step = uchset.step(str);
239              if (step) {
240                leftmost_id = uchset.unichar_to_id(str, step);
241              }
242            }
243            int end_i = orig_i + alt_word->state(i);
244            if (alt_word->state(i) > 1 || (orig_i + 1 == end_i && replacement_is_ngram)) {
245              int blob_start = 0;
246              for (int j = 0; j < orig_i; ++j) {
247                blob_start += best_choice->state(j);
248              }
249              int blob_end = blob_start;
250              for (int j = orig_i; j < end_i; ++j) {
251                blob_end += best_choice->state(j);
252              }
253              fixpt->push_back(
254                  DANGERR_INFO(blob_start, blob_end, true, replacement_is_ngram, leftmost_id));
255              if (stopper_debug_level > 1) {
256                tprintf("fixpt->dangerous+=(%d %d %d %d %s)\n", orig_i, end_i, true,
257                        replacement_is_ngram, uchset.id_to_unichar(leftmost_id));
258              }
259            }
260            orig_i += alt_word->state(i);
261          }
262        }
263      }
264      delete alt_word;
265    }
266    if (output_ambig_words_file_ != nullptr) {
267      fprintf(output_ambig_words_file_, "\n");
268    }
269    for (auto data : ambig_blob_choices) {
270      delete data;
271    }
272    return !ambigs_found;
273  }
274  void Dict::EndDangerousAmbigs() {}
275  #endif 
276  void Dict::SettupStopperPass1() {
277    reject_offset_ = 0.0;
278  }
279  void Dict::SettupStopperPass2() {
280    reject_offset_ = stopper_phase2_certainty_rejection_offset;
281  }
282  void Dict::ReplaceAmbig(int wrong_ngram_begin_index, int wrong_ngram_size,
283                          UNICHAR_ID correct_ngram_id, WERD_CHOICE *werd_choice, MATRIX *ratings) {
284    int num_blobs_to_replace = 0;
285    int begin_blob_index = 0;
286    int i;
287    float new_rating = 0.0f;
288    float new_certainty = 0.0f;
289    BLOB_CHOICE *old_choice = nullptr;
290    for (i = 0; i < wrong_ngram_begin_index + wrong_ngram_size; ++i) {
291      if (i >= wrong_ngram_begin_index) {
292        int num_blobs = werd_choice->state(i);
293        int col = begin_blob_index + num_blobs_to_replace;
294        int row = col + num_blobs - 1;
295        BLOB_CHOICE_LIST *choices = ratings->get(col, row);
296        ASSERT_HOST(choices != nullptr);
297        old_choice = FindMatchingChoice(werd_choice->unichar_id(i), choices);
298        ASSERT_HOST(old_choice != nullptr);
299        new_rating += old_choice->rating();
300        new_certainty += old_choice->certainty();
301        num_blobs_to_replace += num_blobs;
302      } else {
303        begin_blob_index += werd_choice->state(i);
304      }
305    }
306    new_certainty /= wrong_ngram_size;
307    MATRIX_COORD coord(begin_blob_index, begin_blob_index + num_blobs_to_replace - 1);
308    if (!coord.Valid(*ratings)) {
309      ratings->IncreaseBandSize(coord.row - coord.col + 1);
310    }
311    if (ratings->get(coord.col, coord.row) == nullptr) {
312      ratings->put(coord.col, coord.row, new BLOB_CHOICE_LIST);
313    }
314    BLOB_CHOICE_LIST *new_choices = ratings->get(coord.col, coord.row);
315    BLOB_CHOICE *choice = FindMatchingChoice(correct_ngram_id, new_choices);
316    if (choice != nullptr) {
317      if (new_rating < choice->rating()) {
318        choice->set_rating(new_rating);
319      }
320      if (new_certainty < choice->certainty()) {
321        choice->set_certainty(new_certainty);
322      }
323    } else {
324      choice = new BLOB_CHOICE(*old_choice);
325      choice->set_unichar_id(correct_ngram_id);
326      choice->set_rating(new_rating);
327      choice->set_certainty(new_certainty);
328      choice->set_classifier(BCC_AMBIG);
329      choice->set_matrix_cell(coord.col, coord.row);
330      BLOB_CHOICE_IT it(new_choices);
331      it.add_to_end(choice);
332    }
333    for (int replaced_count = 0; replaced_count < wrong_ngram_size; ++replaced_count) {
334      if (replaced_count + 1 == wrong_ngram_size) {
335        werd_choice->set_blob_choice(wrong_ngram_begin_index, num_blobs_to_replace, choice);
336      } else {
337        werd_choice->remove_unichar_id(wrong_ngram_begin_index + 1);
338      }
339    }
340    if (stopper_debug_level >= 1) {
341      werd_choice->print("ReplaceAmbig() ");
342      tprintf("Modified blob_choices: ");
343      print_ratings_list("\n", new_choices, getUnicharset());
344    }
345  }
346  int Dict::LengthOfShortestAlphaRun(const WERD_CHOICE &WordChoice) const {
347    int shortest = INT32_MAX;
348    int curr_len = 0;
349    for (unsigned w = 0; w < WordChoice.length(); ++w) {
350      if (WordChoice.unicharset()->get_isalpha(WordChoice.unichar_id(w))) {
351        curr_len++;
352      } else if (curr_len > 0) {
353        if (curr_len < shortest) {
354          shortest = curr_len;
355        }
356        curr_len = 0;
357      }
358    }
359    if (curr_len > 0 && curr_len < shortest) {
360      shortest = curr_len;
361    } else if (shortest == INT32_MAX) {
362      shortest = 0;
363    }
364    return shortest;
365  }
366  int Dict::UniformCertainties(const WERD_CHOICE &word) {
367    float Certainty;
368    float WorstCertainty = FLT_MAX;
369    float CertaintyThreshold;
370    double TotalCertainty;
371    double TotalCertaintySquared;
372    double Variance;
373    float Mean, StdDev;
374    int word_length = word.length();
375    if (word_length < 3) {
376      return true;
377    }
378    TotalCertainty = TotalCertaintySquared = 0.0;
379    for (int i = 0; i < word_length; ++i) {
380      Certainty = word.certainty(i);
381      TotalCertainty += Certainty;
382      TotalCertaintySquared += static_cast<double>(Certainty) * Certainty;
383      if (Certainty < WorstCertainty) {
384        WorstCertainty = Certainty;
385      }
386    }
387    word_length--;
388    TotalCertainty -= WorstCertainty;
389    TotalCertaintySquared -= static_cast<double>(WorstCertainty) * WorstCertainty;
390    Mean = TotalCertainty / word_length;
391    Variance = ((word_length * TotalCertaintySquared - TotalCertainty * TotalCertainty) /
392                (word_length * (word_length - 1)));
393    if (Variance < 0.0) {
394      Variance = 0.0;
395    }
396    StdDev = sqrt(Variance);
397    CertaintyThreshold = Mean - stopper_allowable_character_badness * StdDev;
398    if (CertaintyThreshold > stopper_nondict_certainty_base) {
399      CertaintyThreshold = stopper_nondict_certainty_base;
400    }
401    if (word.certainty() < CertaintyThreshold) {
402      if (stopper_debug_level >= 1) {
403        tprintf(
404            "Stopper: Non-uniform certainty = %4.1f"
405            " (m=%4.1f, s=%4.1f, t=%4.1f)\n",
406            word.certainty(), Mean, StdDev, CertaintyThreshold);
407      }
408      return false;
409    } else {
410      return true;
411    }
412  }
413  } 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-escaping_test.cc</h3>
            <pre><code>1  #include "absl/strings/escaping.h"
2  #include <array>
3  #include <cstdio>
4  #include <cstring>
5  #include <memory>
6  #include <vector>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/container/fixed_array.h"
10  #include "absl/strings/str_cat.h"
11  #include "absl/strings/internal/escaping_test_common.h"
12  namespace {
13  struct epair {
14    std::string escaped;
15    std::string unescaped;
16  };
17  TEST(CEscape, EscapeAndUnescape) {
18    const std::string inputs[] = {
19        std::string("foo\nxx\r\b\0023"),
20        std::string(""),
21        std::string("abc"),
22        std::string("\1chad_rules"),
23        std::string("\1arnar_drools"),
24        std::string("xxxx\r\t'\"\\"),
25        std::string("\0xx\0", 4),
26        std::string("\x01\x31"),
27        std::string("abc\xb\x42\141bc"),
28        std::string("123\1\x31\x32\x33"),
29        std::string("\xc1\xca\x1b\x62\x19o\xcc\x04"),
30        std::string(
31            "\\\"\xe8\xb0\xb7\xe6\xad\x8c\\\" is Google\\\'s Chinese name"),
32    };
33    for (int kind = 0; kind < 4; kind++) {
34      for (const std::string& original : inputs) {
35        std::string escaped;
<span onclick='openModal()' class='match'>36        switch (kind) {
37          case 0:
38            escaped = absl::CEscape(original);
39            break;
40          case 1:
41            escaped = absl::CHexEscape(original);
42            break;
43          case 2:
44            escaped = absl::Utf8SafeCEscape(original);
45            break;
</span>46          case 3:
47            escaped = absl::Utf8SafeCHexEscape(original);
48            break;
49        }
50        std::string unescaped_str;
51        EXPECT_TRUE(absl::CUnescape(escaped, &unescaped_str));
52        EXPECT_EQ(unescaped_str, original);
53        unescaped_str.erase();
54        std::string error;
55        EXPECT_TRUE(absl::CUnescape(escaped, &unescaped_str, &error));
56        EXPECT_EQ(error, "");
57        std::string s = escaped;
58        EXPECT_TRUE(absl::CUnescape(s, &s));
59        ASSERT_EQ(s, original);
60      }
61    }
62    for (int char0 = 0; char0 < 256; char0++) {
63      for (int char1 = 0; char1 < 256; char1++) {
64        char chars[2];
65        chars[0] = char0;
66        chars[1] = char1;
67        std::string s(chars, 2);
68        std::string escaped = absl::CHexEscape(s);
69        std::string unescaped;
70        EXPECT_TRUE(absl::CUnescape(escaped, &unescaped));
71        EXPECT_EQ(s, unescaped);
72      }
73    }
74  }
75  TEST(CEscape, BasicEscaping) {
76    epair oct_values[] = {
77        {"foo\\rbar\\nbaz\\t", "foo\rbar\nbaz\t"},
78        {"\\'full of \\\"sound\\\" and \\\"fury\\\"\\'",
79         "'full of \"sound\" and \"fury\"'"},
80        {"signi\\\\fying\\\\ nothing\\\\", "signi\\fying\\ nothing\\"},
81        {"\\010\\t\\n\\013\\014\\r", "\010\011\012\013\014\015"}
82    };
83    epair hex_values[] = {
84        {"ubik\\rubik\\nubik\\t", "ubik\rubik\nubik\t"},
85        {"I\\\'ve just seen a \\\"face\\\"",
86         "I've just seen a \"face\""},
87        {"hel\\\\ter\\\\skel\\\\ter\\\\", "hel\\ter\\skel\\ter\\"},
88        {"\\x08\\t\\n\\x0b\\x0c\\r", "\010\011\012\013\014\015"}
89    };
90    epair utf8_oct_values[] = {
91        {"\xe8\xb0\xb7\xe6\xad\x8c\\r\xe8\xb0\xb7\xe6\xad\x8c\\nbaz\\t",
92         "\xe8\xb0\xb7\xe6\xad\x8c\r\xe8\xb0\xb7\xe6\xad\x8c\nbaz\t"},
93        {"\\\"\xe8\xb0\xb7\xe6\xad\x8c\\\" is Google\\\'s Chinese name",
94         "\"\xe8\xb0\xb7\xe6\xad\x8c\" is Google\'s Chinese name"},
95        {"\xe3\x83\xa1\xe3\x83\xbc\xe3\x83\xab\\\\are\\\\Japanese\\\\chars\\\\",
96         "\xe3\x83\xa1\xe3\x83\xbc\xe3\x83\xab\\are\\Japanese\\chars\\"},
97        {"\xed\x81\xac\xeb\xa1\xac\\010\\t\\n\\013\\014\\r",
98         "\xed\x81\xac\xeb\xa1\xac\010\011\012\013\014\015"}
99    };
100    epair utf8_hex_values[] = {
101        {"\x20\xe4\xbd\xa0\\t\xe5\xa5\xbd,\\r!\\n",
102         "\x20\xe4\xbd\xa0\t\xe5\xa5\xbd,\r!\n"},
103        {"\xe8\xa9\xa6\xe9\xa8\x93\\\' means \\\"test\\\"",
104         "\xe8\xa9\xa6\xe9\xa8\x93\' means \"test\""},
105        {"\\\\\xe6\x88\x91\\\\:\\\\\xe6\x9d\xa8\xe6\xac\xa2\\\\",
106         "\\\xe6\x88\x91\\:\\\xe6\x9d\xa8\xe6\xac\xa2\\"},
107        {"\xed\x81\xac\xeb\xa1\xac\\x08\\t\\n\\x0b\\x0c\\r",
108         "\xed\x81\xac\xeb\xa1\xac\010\011\012\013\014\015"}
109    };
110    for (const epair& val : oct_values) {
111      std::string escaped = absl::CEscape(val.unescaped);
112      EXPECT_EQ(escaped, val.escaped);
113    }
114    for (const epair& val : hex_values) {
115      std::string escaped = absl::CHexEscape(val.unescaped);
116      EXPECT_EQ(escaped, val.escaped);
117    }
118    for (const epair& val : utf8_oct_values) {
119      std::string escaped = absl::Utf8SafeCEscape(val.unescaped);
120      EXPECT_EQ(escaped, val.escaped);
121    }
122    for (const epair& val : utf8_hex_values) {
123      std::string escaped = absl::Utf8SafeCHexEscape(val.unescaped);
124      EXPECT_EQ(escaped, val.escaped);
125    }
126  }
127  TEST(Unescape, BasicFunction) {
128    epair tests[] =
129      {{"", ""},
130       {"\\u0030", "0"},
131       {"\\u00A3", "\xC2\xA3"},
132       {"\\u22FD", "\xE2\x8B\xBD"},
133       {"\\U00010000", "\xF0\x90\x80\x80"},
134       {"\\U0010FFFD", "\xF4\x8F\xBF\xBD"}};
135    for (const epair& val : tests) {
136      std::string out;
137      EXPECT_TRUE(absl::CUnescape(val.escaped, &out));
138      EXPECT_EQ(out, val.unescaped);
139    }
140    std::string bad[] = {"\\u1",         
141                         "\\U1",         
142                         "\\Uffffff",    
143                         "\\U00110000",  
144                         "\\uD835",      
145                         "\\U0000DD04",  
146                         "\\777",        
147                         "\\xABCD"};     
148    for (const std::string& e : bad) {
149      std::string error;
150      std::string out;
151      EXPECT_FALSE(absl::CUnescape(e, &out, &error));
152      EXPECT_FALSE(error.empty());
153      out.erase();
154      EXPECT_FALSE(absl::CUnescape(e, &out));
155    }
156  }
157  class CUnescapeTest : public testing::Test {
158   protected:
159    static const char kStringWithMultipleOctalNulls[];
160    static const char kStringWithMultipleHexNulls[];
161    static const char kStringWithMultipleUnicodeNulls[];
162    std::string result_string_;
163  };
164  const char CUnescapeTest::kStringWithMultipleOctalNulls[] =
165      "\\0\\n"    
166      "0\\n"      
167      "\\00\\12"  
168      "\\000";    
169  const char CUnescapeTest::kStringWithMultipleHexNulls[] =
170      "\\x0\\n"
171      "0\\n"
172      "\\x00\\xa"
173      "\\x000";
174  const char CUnescapeTest::kStringWithMultipleUnicodeNulls[] =
175      "\\u0000\\n"    
176      "0\\n"          
177      "\\U00000000";  
178  TEST_F(CUnescapeTest, Unescapes1CharOctalNull) {
179    std::string original_string = "\\0";
180    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
181    EXPECT_EQ(std::string("\0", 1), result_string_);
182  }
183  TEST_F(CUnescapeTest, Unescapes2CharOctalNull) {
184    std::string original_string = "\\00";
185    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
186    EXPECT_EQ(std::string("\0", 1), result_string_);
187  }
188  TEST_F(CUnescapeTest, Unescapes3CharOctalNull) {
189    std::string original_string = "\\000";
190    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
191    EXPECT_EQ(std::string("\0", 1), result_string_);
192  }
193  TEST_F(CUnescapeTest, Unescapes1CharHexNull) {
194    std::string original_string = "\\x0";
195    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
196    EXPECT_EQ(std::string("\0", 1), result_string_);
197  }
198  TEST_F(CUnescapeTest, Unescapes2CharHexNull) {
199    std::string original_string = "\\x00";
200    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
201    EXPECT_EQ(std::string("\0", 1), result_string_);
202  }
203  TEST_F(CUnescapeTest, Unescapes3CharHexNull) {
204    std::string original_string = "\\x000";
205    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
206    EXPECT_EQ(std::string("\0", 1), result_string_);
207  }
208  TEST_F(CUnescapeTest, Unescapes4CharUnicodeNull) {
209    std::string original_string = "\\u0000";
210    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
211    EXPECT_EQ(std::string("\0", 1), result_string_);
212  }
213  TEST_F(CUnescapeTest, Unescapes8CharUnicodeNull) {
214    std::string original_string = "\\U00000000";
215    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
216    EXPECT_EQ(std::string("\0", 1), result_string_);
217  }
218  TEST_F(CUnescapeTest, UnescapesMultipleOctalNulls) {
219    std::string original_string(kStringWithMultipleOctalNulls);
220    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
221    EXPECT_EQ(std::string("\0\n"
222                          "0\n"
223                          "\0\n"
224                          "\0",
225                          7),
226              result_string_);
227  }
228  TEST_F(CUnescapeTest, UnescapesMultipleHexNulls) {
229    std::string original_string(kStringWithMultipleHexNulls);
230    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
231    EXPECT_EQ(std::string("\0\n"
232                          "0\n"
233                          "\0\n"
234                          "\0",
235                          7),
236              result_string_);
237  }
238  TEST_F(CUnescapeTest, UnescapesMultipleUnicodeNulls) {
239    std::string original_string(kStringWithMultipleUnicodeNulls);
240    EXPECT_TRUE(absl::CUnescape(original_string, &result_string_));
241    EXPECT_EQ(std::string("\0\n"
242                          "0\n"
243                          "\0",
244                          5),
245              result_string_);
246  }
247  static struct {
248    absl::string_view plaintext;
249    absl::string_view cyphertext;
250  } const base64_tests[] = {
251      {{"", 0}, {"", 0}},
252      {{nullptr, 0},
253       {"", 0}},  
254      {{"\000", 1}, "AA=="},
255      {{"\001", 1}, "AQ=="},
256      {{"\002", 1}, "Ag=="},
257      {{"\004", 1}, "BA=="},
258      {{"\010", 1}, "CA=="},
259      {{"\020", 1}, "EA=="},
260      {{"\040", 1}, "IA=="},
261      {{"\100", 1}, "QA=="},
262      {{"\200", 1}, "gA=="},
263      {{"\377", 1}, "/w=="},
264      {{"\376", 1}, "/g=="},
265      {{"\375", 1}, "/Q=="},
266      {{"\373", 1}, "+w=="},
267      {{"\367", 1}, "9w=="},
268      {{"\357", 1}, "7w=="},
269      {{"\337", 1}, "3w=="},
270      {{"\277", 1}, "vw=="},
271      {{"\177", 1}, "fw=="},
272      {{"\000\000", 2}, "AAA="},
273      {{"\000\001", 2}, "AAE="},
274      {{"\000\002", 2}, "AAI="},
275      {{"\000\004", 2}, "AAQ="},
276      {{"\000\010", 2}, "AAg="},
277      {{"\000\020", 2}, "ABA="},
278      {{"\000\040", 2}, "ACA="},
279      {{"\000\100", 2}, "AEA="},
280      {{"\000\200", 2}, "AIA="},
281      {{"\001\000", 2}, "AQA="},
282      {{"\002\000", 2}, "AgA="},
283      {{"\004\000", 2}, "BAA="},
284      {{"\010\000", 2}, "CAA="},
285      {{"\020\000", 2}, "EAA="},
286      {{"\040\000", 2}, "IAA="},
287      {{"\100\000", 2}, "QAA="},
288      {{"\200\000", 2}, "gAA="},
289      {{"\377\377", 2}, "&bsol;&bsol;8="},
290      {{"\377\376", 2}, "&bsol;&bsol;4="},
291      {{"\377\375", 2}, "&bsol;&bsol;0="},
292      {{"\377\373", 2}, "&bsol;&bsol;s="},
293      {{"\377\367", 2}, "&bsol;&bsol;c="},
294      {{"\377\357", 2}, "/+8="},
295      {{"\377\337", 2}, "/98="},
296      {{"\377\277", 2}, "/78="},
297      {{"\377\177", 2}, "/38="},
298      {{"\376\377", 2}, "/v8="},
299      {{"\375\377", 2}, "/f8="},
300      {{"\373\377", 2}, "+/8="},
301      {{"\367\377", 2}, "9/8="},
302      {{"\357\377", 2}, "7/8="},
303      {{"\337\377", 2}, "3/8="},
304      {{"\277\377", 2}, "v/8="},
305      {{"\177\377", 2}, "f/8="},
306      {{"\000\000\000", 3}, "AAAA"},
307      {{"\000\000\001", 3}, "AAAB"},
308      {{"\000\000\002", 3}, "AAAC"},
309      {{"\000\000\004", 3}, "AAAE"},
310      {{"\000\000\010", 3}, "AAAI"},
311      {{"\000\000\020", 3}, "AAAQ"},
312      {{"\000\000\040", 3}, "AAAg"},
313      {{"\000\000\100", 3}, "AABA"},
314      {{"\000\000\200", 3}, "AACA"},
315      {{"\000\001\000", 3}, "AAEA"},
316      {{"\000\002\000", 3}, "AAIA"},
317      {{"\000\004\000", 3}, "AAQA"},
318      {{"\000\010\000", 3}, "AAgA"},
319      {{"\000\020\000", 3}, "ABAA"},
320      {{"\000\040\000", 3}, "ACAA"},
321      {{"\000\100\000", 3}, "AEAA"},
322      {{"\000\200\000", 3}, "AIAA"},
323      {{"\001\000\000", 3}, "AQAA"},
324      {{"\002\000\000", 3}, "AgAA"},
325      {{"\004\000\000", 3}, "BAAA"},
326      {{"\010\000\000", 3}, "CAAA"},
327      {{"\020\000\000", 3}, "EAAA"},
328      {{"\040\000\000", 3}, "IAAA"},
329      {{"\100\000\000", 3}, "QAAA"},
330      {{"\200\000\000", 3}, "gAAA"},
331      {{"\377\377\377", 3}, "&bsol;&bsol;&bsol;&bsol;"},
332      {{"\377\377\376", 3}, "&bsol;&bsol;/+"},
333      {{"\377\377\375", 3}, "&bsol;&bsol;/9"},
334      {{"\377\377\373", 3}, "&bsol;&bsol;/7"},
335      {{"\377\377\367", 3}, "&bsol;&bsol;/3"},
336      {{"\377\377\357", 3}, "&bsol;&bsol;/v"},
337      {{"\377\377\337", 3}, "&bsol;&bsol;/f"},
338      {{"\377\377\277", 3}, "&bsol;&bsol;+/"},
339      {{"\377\377\177", 3}, "&bsol;&bsol;9/"},
340      {{"\377\376\377", 3}, "&bsol;&bsol;7/"},
341      {{"\377\375\377", 3}, "&bsol;&bsol;3/"},
342      {{"\377\373\377", 3}, "&bsol;&bsol;v/"},
343      {{"\377\367\377", 3}, "&bsol;&bsol;f/"},
344      {{"\377\357\377", 3}, "/+
345      {{"\377\337\377", 3}, "/9
346      {{"\377\277\377", 3}, "/7
347      {{"\377\177\377", 3}, "/3
348      {{"\376\377\377", 3}, "/v
349      {{"\375\377\377", 3}, "/f
350      {{"\373\377\377", 3}, "+
351      {{"\367\377\377", 3}, "9
352      {{"\357\377\377", 3}, "7
353      {{"\337\377\377", 3}, "3
354      {{"\277\377\377", 3}, "v
355      {{"\177\377\377", 3}, "f
356      {{"\243\361", 2}, "o/E="},
357      {{"\024\167", 2}, "FHc="},
358      {{"\313\252", 2}, "y6o="},
359      {{"\046\041", 2}, "JiE="},
360      {{"\145\236", 2}, "ZZ4="},
361      {{"\254\325", 2}, "rNU="},
362      {{"\061\330", 2}, "Mdg="},
363      {{"\245\032", 2}, "pRo="},
364      {{"\006\000", 2}, "BgA="},
365      {{"\375\131", 2}, "/Vk="},
366      {{"\303\210", 2}, "w4g="},
367      {{"\040\037", 2}, "IB8="},
368      {{"\261\372", 2}, "sfo="},
369      {{"\335\014", 2}, "3Qw="},
370      {{"\233\217", 2}, "m48="},
371      {{"\373\056", 2}, "+y4="},
372      {{"\247\232", 2}, "p5o="},
373      {{"\107\053", 2}, "Rys="},
374      {{"\204\077", 2}, "hD8="},
375      {{"\276\211", 2}, "vok="},
376      {{"\313\110", 2}, "y0g="},
377      {{"\363\376", 2}, "8/4="},
378      {{"\251\234", 2}, "qZw="},
379      {{"\103\262", 2}, "Q7I="},
380      {{"\142\312", 2}, "Yso="},
381      {{"\067\211", 2}, "N4k="},
382      {{"\220\001", 2}, "kAE="},
383      {{"\152\240", 2}, "aqA="},
384      {{"\367\061", 2}, "9zE="},
385      {{"\133\255", 2}, "W60="},
386      {{"\176\035", 2}, "fh0="},
387      {{"\032\231", 2}, "Gpk="},
388      {{"\013\007\144", 3}, "Cwdk"},
389      {{"\030\112\106", 3}, "GEpG"},
390      {{"\047\325\046", 3}, "J9Um"},
391      {{"\310\160\022", 3}, "yHAS"},
392      {{"\131\100\237", 3}, "WUCf"},
393      {{"\064\342\134", 3}, "NOJc"},
394      {{"\010\177\004", 3}, "CH8E"},
395      {{"\345\147\205", 3}, "5WeF"},
396      {{"\300\343\360", 3}, "wOPw"},
397      {{"\061\240\201", 3}, "MaCB"},
398      {{"\225\333\044", 3}, "ldsk"},
399      {{"\215\137\352", 3}, "jV/q"},
400      {{"\371\147\160", 3}, "+Wdw"},
401      {{"\030\320\051", 3}, "GNAp"},
402      {{"\044\174\241", 3}, "JHyh"},
403      {{"\260\127\037", 3}, "sFcf"},
404      {{"\111\045\033", 3}, "SSUb"},
405      {{"\202\114\107", 3}, "gkxH"},
406      {{"\057\371\042", 3}, "L/ki"},
407      {{"\223\247\244", 3}, "k6ek"},
408      {{"\047\216\144", 3}, "J45k"},
409      {{"\203\070\327", 3}, "gzjX"},
410      {{"\247\140\072", 3}, "p2A6"},
411      {{"\124\115\116", 3}, "VE1O"},
412      {{"\157\162\050", 3}, "b3Io"},
413      {{"\357\223\004", 3}, "75ME"},
414      {{"\052\117\156", 3}, "Kk9u"},
415      {{"\347\154\000", 3}, "52wA"},
416      {{"\303\012\142", 3}, "wwpi"},
417      {{"\060\035\362", 3}, "MB3y"},
418      {{"\130\226\361", 3}, "WJbx"},
419      {{"\173\013\071", 3}, "ews5"},
420      {{"\336\004\027", 3}, "3gQX"},
421      {{"\357\366\234", 3}, "7/ac"},
422      {{"\353\304\111", 3}, "68RJ"},
423      {{"\024\264\131", 3}, "FLRZ"},
424      {{"\075\114\251", 3}, "PUyp"},
425      {{"\315\031\225", 3}, "zRmV"},
426      {{"\154\201\276", 3}, "bIG+"},
427      {{"\200\066\072", 3}, "gDY6"},
428      {{"\142\350\267", 3}, "Yui3"},
429      {{"\033\000\166", 3}, "GwB2"},
430      {{"\210\055\077", 3}, "iC0/"},
431      {{"\341\037\124", 3}, "4R9U"},
432      {{"\161\103\152", 3}, "cUNq"},
433      {{"\270\142\131", 3}, "uGJZ"},
434      {{"\337\076\074", 3}, "3z48"},
435      {{"\375\106\362", 3}, "/Uby"},
436      {{"\227\301\127", 3}, "l8FX"},
437      {{"\340\002\234", 3}, "4AKc"},
438      {{"\121\064\033", 3}, "UTQb"},
439      {{"\157\134\143", 3}, "b1xj"},
440      {{"\247\055\327", 3}, "py3X"},
441      {{"\340\142\005", 3}, "4GIF"},
442      {{"\060\260\143", 3}, "MLBj"},
443      {{"\075\203\170", 3}, "PYN4"},
444      {{"\143\160\016", 3}, "Y3AO"},
445      {{"\313\013\063", 3}, "ywsz"},
446      {{"\174\236\135", 3}, "fJ5d"},
447      {{"\103\047\026", 3}, "QycW"},
448      {{"\365\005\343", 3}, "9QXj"},
449      {{"\271\160\223", 3}, "uXCT"},
450      {{"\362\255\172", 3}, "8q16"},
451      {{"\113\012\015", 3}, "SwoN"},
452      {{"", 0}, {"", 0}},
453      {"a", "YQ=="},
454      {"ab", "YWI="},
455      {"abc", "YWJj"},
456      {"abcd", "YWJjZA=="},
457      {"abcde", "YWJjZGU="},
458      {"abcdef", "YWJjZGVm"},
459      {"abcdefg", "YWJjZGVmZw=="},
460      {"abcdefgh", "YWJjZGVmZ2g="},
461      {"abcdefghi", "YWJjZGVmZ2hp"},
462      {"abcdefghij", "YWJjZGVmZ2hpag=="},
463      {"abcdefghijk", "YWJjZGVmZ2hpams="},
464      {"abcdefghijkl", "YWJjZGVmZ2hpamts"},
465      {"abcdefghijklm", "YWJjZGVmZ2hpamtsbQ=="},
466      {"abcdefghijklmn", "YWJjZGVmZ2hpamtsbW4="},
467      {"abcdefghijklmno", "YWJjZGVmZ2hpamtsbW5v"},
468      {"abcdefghijklmnop", "YWJjZGVmZ2hpamtsbW5vcA=="},
469      {"abcdefghijklmnopq", "YWJjZGVmZ2hpamtsbW5vcHE="},
470      {"abcdefghijklmnopqr", "YWJjZGVmZ2hpamtsbW5vcHFy"},
471      {"abcdefghijklmnopqrs", "YWJjZGVmZ2hpamtsbW5vcHFycw=="},
472      {"abcdefghijklmnopqrst", "YWJjZGVmZ2hpamtsbW5vcHFyc3Q="},
473      {"abcdefghijklmnopqrstu", "YWJjZGVmZ2hpamtsbW5vcHFyc3R1"},
474      {"abcdefghijklmnopqrstuv", "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dg=="},
475      {"abcdefghijklmnopqrstuvw", "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnc="},
476      {"abcdefghijklmnopqrstuvwx", "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4"},
477      {"abcdefghijklmnopqrstuvwxy", "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eQ=="},
478      {"abcdefghijklmnopqrstuvwxyz", "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo="},
479  };
480  template <typename StringType>
481  void TestEscapeAndUnescape() {
482    for (const auto& tc : base64_tests) {
483      StringType encoded("this junk should be ignored");
484      absl::Base64Escape(tc.plaintext, &encoded);
485      EXPECT_EQ(encoded, tc.cyphertext);
486      EXPECT_EQ(absl::Base64Escape(tc.plaintext), tc.cyphertext);
487      StringType decoded("this junk should be ignored");
488      EXPECT_TRUE(absl::Base64Unescape(encoded, &decoded));
489      EXPECT_EQ(decoded, tc.plaintext);
490      StringType websafe_with_padding(tc.cyphertext);
491      for (unsigned int c = 0; c < websafe_with_padding.size(); ++c) {
492        if ('+' == websafe_with_padding[c]) websafe_with_padding[c] = '-';
493        if ('/' == websafe_with_padding[c]) websafe_with_padding[c] = '_';
494      }
495      StringType websafe(websafe_with_padding);
496      for (unsigned int c = 0; c < websafe.size(); ++c) {
497        if ('=' == websafe[c]) {
498          websafe.resize(c);
499          break;
500        }
501      }
502      encoded = "this junk should be ignored";
503      absl::WebSafeBase64Escape(tc.plaintext, &encoded);
504      EXPECT_EQ(encoded, websafe);
505      EXPECT_EQ(absl::WebSafeBase64Escape(tc.plaintext), websafe);
506      decoded = "this junk should be ignored";
507      EXPECT_TRUE(absl::WebSafeBase64Unescape(websafe, &decoded));
508      EXPECT_EQ(decoded, tc.plaintext);
509    }
510    for (const auto& tc : absl::strings_internal::base64_strings()) {
511      StringType buffer;
512      absl::WebSafeBase64Escape(tc.plaintext, &buffer);
513      EXPECT_EQ(tc.cyphertext, buffer);
514      EXPECT_EQ(absl::WebSafeBase64Escape(tc.plaintext), tc.cyphertext);
515    }
516    {
517      absl::string_view data_set[] = {"ab-/", absl::string_view("\0bcd", 4),
518                                      absl::string_view("abc.\0", 5)};
519      for (absl::string_view bad_data : data_set) {
520        StringType buf;
521        EXPECT_FALSE(absl::Base64Unescape(bad_data, &buf));
522        EXPECT_FALSE(absl::WebSafeBase64Unescape(bad_data, &buf));
523        EXPECT_TRUE(buf.empty());
524      }
525    }
526  }
527  TEST(Base64, EscapeAndUnescape) {
528    TestEscapeAndUnescape<std::string>();
529  }
530  TEST(Base64, Padding) {
531    std::initializer_list<absl::string_view> good_padding = {
532      "YQ",
533      "YQ==",
534      "YQ=.",
535      "YQ.=",
536      "YQ..",
537    };
538    for (absl::string_view b64 : good_padding) {
539      std::string decoded;
540      EXPECT_TRUE(absl::Base64Unescape(b64, &decoded));
541      EXPECT_EQ(decoded, "a");
542      std::string websafe_decoded;
543      EXPECT_TRUE(absl::WebSafeBase64Unescape(b64, &websafe_decoded));
544      EXPECT_EQ(websafe_decoded, "a");
545    }
546    std::initializer_list<absl::string_view> bad_padding = {
547      "YQ=",
548      "YQ.",
549      "YQ===",
550      "YQ==.",
551      "YQ=.=",
552      "YQ=..",
553      "YQ.==",
554      "YQ.=.",
555      "YQ..=",
556      "YQ...",
557      "YQ====",
558      "YQ....",
559      "YQ=====",
560      "YQ.....",
561    };
562    for (absl::string_view b64 : bad_padding) {
563      std::string decoded;
564      EXPECT_FALSE(absl::Base64Unescape(b64, &decoded));
565      std::string websafe_decoded;
566      EXPECT_FALSE(absl::WebSafeBase64Unescape(b64, &websafe_decoded));
567    }
568  }
569  TEST(Base64, DISABLED_HugeData) {
570    const size_t kSize = size_t(3) * 1000 * 1000 * 1000;
571    static_assert(kSize % 3 == 0, "kSize must be divisible by 3");
572    const std::string huge(kSize, 'x');
573    std::string escaped;
574    absl::Base64Escape(huge, &escaped);
575    std::string expected_encoding;
576    expected_encoding.reserve(kSize / 3 * 4);
577    for (size_t i = 0; i < kSize / 3; ++i) {
578      expected_encoding.append("eHh4");
579    }
580    EXPECT_EQ(expected_encoding, escaped);
581    std::string unescaped;
582    EXPECT_TRUE(absl::Base64Unescape(escaped, &unescaped));
583    EXPECT_EQ(huge, unescaped);
584  }
585  TEST(HexAndBack, HexStringToBytes_and_BytesToHexString) {
586    std::string hex_mixed = "0123456789abcdefABCDEF";
587    std::string bytes_expected = "\x01\x23\x45\x67\x89\xab\xcd\xef\xAB\xCD\xEF";
588    std::string hex_only_lower = "0123456789abcdefabcdef";
589    std::string bytes_result = absl::HexStringToBytes(hex_mixed);
590    EXPECT_EQ(bytes_expected, bytes_result);
591    std::string prefix_valid = hex_mixed + "?";
592    std::string prefix_valid_result = absl::HexStringToBytes(
593        absl::string_view(prefix_valid.data(), prefix_valid.size() - 1));
594    EXPECT_EQ(bytes_expected, prefix_valid_result);
595    std::string infix_valid = "?" + hex_mixed + "???";
596    std::string infix_valid_result = absl::HexStringToBytes(
597        absl::string_view(infix_valid.data() + 1, hex_mixed.size()));
598    EXPECT_EQ(bytes_expected, infix_valid_result);
599    std::string hex_result = absl::BytesToHexString(bytes_expected);
600    EXPECT_EQ(hex_only_lower, hex_result);
601  }
602  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-stopper.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-escaping_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>33      switch (xheight_consistency) {
34        case XH_GOOD:
35          xht = "NORMAL";
36          break;
37        case XH_SUBNORMAL:
38          xht = "SUBNORMAL";
39          break;
40        case XH_INCONSISTENT:
41          xht = "INCONSISTENT";
42          break;
</pre></code></div>
                <div class="column column_space"><pre><code>36        switch (kind) {
37          case 0:
38            escaped = absl::CEscape(original);
39            break;
40          case 1:
41            escaped = absl::CHexEscape(original);
42            break;
43          case 2:
44            escaped = absl::Utf8SafeCEscape(original);
45            break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    