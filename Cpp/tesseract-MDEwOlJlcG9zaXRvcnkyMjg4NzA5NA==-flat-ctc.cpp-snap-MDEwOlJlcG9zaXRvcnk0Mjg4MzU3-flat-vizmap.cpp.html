
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.398624303963315%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ctc.cpp</h3>
            <pre><code>1  #include "ctc.h"
2  #include "matrix.h"
3  #include "network.h"
4  #include "networkio.h"
5  #include "scrollview.h"
6  #include <algorithm>
7  #include <cfloat> 
8  #include <cmath>
9  #include <memory>
10  namespace tesseract {
11  const float CTC::kMinProb_ = 1e-12;
12  const double CTC::kMaxExpArg_ = 80.0;
13  const double CTC::kMinTotalTimeProb_ = 1e-8;
14  const double CTC::kMinTotalFinalProb_ = 1e-6;
15  bool CTC::ComputeCTCTargets(const std::vector<int> &labels, int null_char,
16                              const GENERIC_2D_ARRAY<float> &outputs, NetworkIO *targets) {
17    std::unique_ptr<CTC> ctc(new CTC(labels, null_char, outputs));
18    if (!ctc->ComputeLabelLimits()) {
19      return false; 
20    }
21    GENERIC_2D_ARRAY<float> simple_targets;
22    ctc->ComputeSimpleTargets(&simple_targets);
23    float bias_fraction = ctc->CalculateBiasFraction();
24    simple_targets *= bias_fraction;
25    ctc->outputs_ += simple_targets;
26    NormalizeProbs(&ctc->outputs_);
27    GENERIC_2D_ARRAY<double> log_alphas, log_betas;
28    ctc->Forward(&log_alphas);
29    ctc->Backward(&log_betas);
30    log_alphas += log_betas;
31    ctc->NormalizeSequence(&log_alphas);
32    ctc->LabelsToClasses(log_alphas, targets);
33    NormalizeProbs(targets);
34    return true;
35  }
36  CTC::CTC(const std::vector<int> &labels, int null_char, const GENERIC_2D_ARRAY<float> &outputs)
37      : labels_(labels), outputs_(outputs), null_char_(null_char) {
38    num_timesteps_ = outputs.dim1();
39    num_classes_ = outputs.dim2();
40    num_labels_ = labels_.size();
41  }
42  bool CTC::ComputeLabelLimits() {
43    min_labels_.clear();
44    min_labels_.resize(num_timesteps_, 0);
45    max_labels_.clear();
46    max_labels_.resize(num_timesteps_, 0);
47    int min_u = num_labels_ - 1;
48    if (labels_[min_u] == null_char_) {
49      --min_u;
50    }
51    for (int t = num_timesteps_ - 1; t >= 0; --t) {
52      min_labels_[t] = min_u;
53      if (min_u > 0) {
54        --min_u;
55        if (labels_[min_u] == null_char_ && min_u > 0 && labels_[min_u + 1] != labels_[min_u - 1]) {
56          --min_u;
57        }
58      }
59    }
60    int max_u = labels_[0] == null_char_;
61    for (int t = 0; t < num_timesteps_; ++t) {
62      max_labels_[t] = max_u;
63      if (max_labels_[t] < min_labels_[t]) {
64        return false; 
65      }
66      if (max_u + 1 < num_labels_) {
67        ++max_u;
68        if (labels_[max_u] == null_char_ && max_u + 1 < num_labels_ &&
69            labels_[max_u + 1] != labels_[max_u - 1]) {
70          ++max_u;
71        }
72      }
73    }
74    return true;
75  }
76  void CTC::ComputeSimpleTargets(GENERIC_2D_ARRAY<float> *targets) const {
77    targets->Resize(num_timesteps_, num_classes_, 0.0f);
78    std::vector<float> half_widths;
79    std::vector<int> means;
80    ComputeWidthsAndMeans(&half_widths, &means);
81    for (int l = 0; l < num_labels_; ++l) {
82      int label = labels_[l];
83      float left_half_width = half_widths[l];
84      float right_half_width = left_half_width;
85      int mean = means[l];
86      if (label == null_char_) {
87        if (!NeededNull(l)) {
88          if ((l > 0 && mean == means[l - 1]) || (l + 1 < num_labels_ && mean == means[l + 1])) {
89            continue; 
90          }
91        }
92        if (l > 0) {
93          left_half_width = mean - means[l - 1];
94        }
95        if (l + 1 < num_labels_) {
96          right_half_width = means[l + 1] - mean;
97        }
98      }
99      if (mean >= 0 && mean < num_timesteps_) {
100        targets->put(mean, label, 1.0f);
101      }
102      for (int offset = 1; offset < left_half_width && mean >= offset; ++offset) {
103        float prob = 1.0f - offset / left_half_width;
104        if (mean - offset < num_timesteps_ && prob > targets->get(mean - offset, label)) {
105          targets->put(mean - offset, label, prob);
106        }
107      }
108      for (int offset = 1; offset < right_half_width && mean + offset < num_timesteps_; ++offset) {
109        float prob = 1.0f - offset / right_half_width;
110        if (mean + offset >= 0 && prob > targets->get(mean + offset, label)) {
111          targets->put(mean + offset, label, prob);
112        }
113      }
114    }
115  }
116  void CTC::ComputeWidthsAndMeans(std::vector<float> *half_widths, std::vector<int> *means) const {
117    int num_plus = 0, num_star = 0;
118    for (int i = 0; i < num_labels_; ++i) {
119      if (labels_[i] != null_char_ || NeededNull(i)) {
120        ++num_plus;
121      } else {
122        ++num_star;
123      }
124    }
125    float plus_size = 1.0f, star_size = 0.0f;
126    float total_floating = num_plus + num_star;
127    if (total_floating <= num_timesteps_) {
128      plus_size = star_size = num_timesteps_ / total_floating;
129    } else if (num_star > 0) {
130      star_size = static_cast<float>(num_timesteps_ - num_plus) / num_star;
131    }
132    float mean_pos = 0.0f;
133    for (int i = 0; i < num_labels_; ++i) {
134      float half_width;
135      if (labels_[i] != null_char_ || NeededNull(i)) {
136        half_width = plus_size / 2.0f;
137      } else {
138        half_width = star_size / 2.0f;
139      }
140      mean_pos += half_width;
141      means->push_back(static_cast<int>(mean_pos));
142      mean_pos += half_width;
143      half_widths->push_back(half_width);
144    }
145  }
146  static int BestLabel(const GENERIC_2D_ARRAY<float> &outputs, int t) {
147    int result = 0;
148    int num_classes = outputs.dim2();
149    const float *outputs_t = outputs[t];
150    for (int c = 1; c < num_classes; ++c) {
151      if (outputs_t[c] > outputs_t[result]) {
152        result = c;
153      }
154    }
155    return result;
156  }
157  float CTC::CalculateBiasFraction() {
158    std::vector<int> output_labels;
159    for (int t = 0; t < num_timesteps_; ++t) {
160      int label = BestLabel(outputs_, t);
161      while (t + 1 < num_timesteps_ && BestLabel(outputs_, t + 1) == label) {
162        ++t;
163      }
164      if (label != null_char_) {
165        output_labels.push_back(label);
166      }
167    }
168    std::vector<int> truth_counts(num_classes_);
169    std::vector<int> output_counts(num_classes_);
170    for (int l = 0; l < num_labels_; ++l) {
171      ++truth_counts[labels_[l]];
172    }
173    for (auto l : output_labels) {
174      ++output_counts[l];
175    }
176    int true_pos = 0, false_pos = 0, total_labels = 0;
177    for (int c = 0; c < num_classes_; ++c) {
178      if (c == null_char_) {
179        continue;
180      }
181      int truth_count = truth_counts[c];
182      int ocr_count = output_counts[c];
183      if (truth_count > 0) {
184        total_labels += truth_count;
185        if (ocr_count > truth_count) {
186          true_pos += truth_count;
187          false_pos += ocr_count - truth_count;
188        } else {
189          true_pos += ocr_count;
190        }
191      }
192    }
193    if (total_labels == 0) {
194      return 0.0f;
195    }
196    return exp(std::max(true_pos - false_pos, 1) * std::log(kMinProb_) / total_labels);
197  }
198  static double LogSumExp(double ln_x, double ln_y) {
<span onclick='openModal()' class='match'>199    if (ln_x >= ln_y) {
200      return ln_x + log1p(exp(ln_y - ln_x));
201    } else {
202      return ln_y + log1p(exp(ln_x - ln_y));
203    }
204  }
205  void CTC::Forward(GENERIC_2D_ARRAY<double> *log_probs) const {
</span>206    log_probs->Resize(num_timesteps_, num_labels_, -FLT_MAX);
207    log_probs->put(0, 0, log(outputs_(0, labels_[0])));
208    if (labels_[0] == null_char_) {
209      log_probs->put(0, 1, log(outputs_(0, labels_[1])));
210    }
211    for (int t = 1; t < num_timesteps_; ++t) {
212      const float *outputs_t = outputs_[t];
213      for (int u = min_labels_[t]; u <= max_labels_[t]; ++u) {
214        double log_sum = log_probs->get(t - 1, u);
215        if (u > 0) {
216          log_sum = LogSumExp(log_sum, log_probs->get(t - 1, u - 1));
217        }
218        if (u >= 2 && labels_[u - 1] == null_char_ && labels_[u] != labels_[u - 2]) {
219          log_sum = LogSumExp(log_sum, log_probs->get(t - 1, u - 2));
220        }
221        double label_prob = outputs_t[labels_[u]];
222        log_sum += log(label_prob);
223        log_probs->put(t, u, log_sum);
224      }
225    }
226  }
227  void CTC::Backward(GENERIC_2D_ARRAY<double> *log_probs) const {
228    log_probs->Resize(num_timesteps_, num_labels_, -FLT_MAX);
229    log_probs->put(num_timesteps_ - 1, num_labels_ - 1, 0.0);
230    if (labels_[num_labels_ - 1] == null_char_) {
231      log_probs->put(num_timesteps_ - 1, num_labels_ - 2, 0.0);
232    }
233    for (int t = num_timesteps_ - 2; t >= 0; --t) {
234      const float *outputs_tp1 = outputs_[t + 1];
235      for (int u = min_labels_[t]; u <= max_labels_[t]; ++u) {
236        double log_sum = log_probs->get(t + 1, u) + std::log(outputs_tp1[labels_[u]]);
237        if (u + 1 < num_labels_) {
238          double prev_prob = outputs_tp1[labels_[u + 1]];
239          log_sum = LogSumExp(log_sum, log_probs->get(t + 1, u + 1) + log(prev_prob));
240        }
241        if (u + 2 < num_labels_ && labels_[u + 1] == null_char_ && labels_[u] != labels_[u + 2]) {
242          double skip_prob = outputs_tp1[labels_[u + 2]];
243          log_sum = LogSumExp(log_sum, log_probs->get(t + 1, u + 2) + log(skip_prob));
244        }
245        log_probs->put(t, u, log_sum);
246      }
247    }
248  }
249  void CTC::NormalizeSequence(GENERIC_2D_ARRAY<double> *probs) const {
250    double max_logprob = probs->Max();
251    for (int u = 0; u < num_labels_; ++u) {
252      double total = 0.0;
253      for (int t = 0; t < num_timesteps_; ++t) {
254        double prob = probs->get(t, u);
255        if (prob > -FLT_MAX) {
256          prob = ClippedExp(prob - max_logprob);
257        } else {
258          prob = 0.0;
259        }
260        total += prob;
261        probs->put(t, u, prob);
262      }
263      if (total < kMinTotalTimeProb_) {
264        total = kMinTotalTimeProb_;
265      }
266      for (int t = 0; t < num_timesteps_; ++t) {
267        probs->put(t, u, probs->get(t, u) / total);
268      }
269    }
270  }
271  void CTC::LabelsToClasses(const GENERIC_2D_ARRAY<double> &probs, NetworkIO *targets) const {
272    for (int t = 0; t < num_timesteps_; ++t) {
273      float *targets_t = targets->f(t);
274      std::vector<double> class_probs(num_classes_);
275      for (int u = 0; u < num_labels_; ++u) {
276        double prob = probs(t, u);
277        if (prob > class_probs[labels_[u]]) {
278          class_probs[labels_[u]] = prob;
279        }
280      }
281      int best_class = 0;
282      for (int c = 0; c < num_classes_; ++c) {
283        targets_t[c] = class_probs[c];
284        if (class_probs[c] > class_probs[best_class]) {
285          best_class = c;
286        }
287      }
288    }
289  }
290  void CTC::NormalizeProbs(GENERIC_2D_ARRAY<float> *probs) {
291    int num_timesteps = probs->dim1();
292    int num_classes = probs->dim2();
293    for (int t = 0; t < num_timesteps; ++t) {
294      float *probs_t = (*probs)[t];
295      double total = 0.0;
296      for (int c = 0; c < num_classes; ++c) {
297        total += probs_t[c];
298      }
299      if (total < kMinTotalFinalProb_) {
300        total = kMinTotalFinalProb_;
301      }
302      double increment = 0.0;
303      for (int c = 0; c < num_classes; ++c) {
304        double prob = probs_t[c] / total;
305        if (prob < kMinProb_) {
306          increment += kMinProb_ - prob;
307        }
308      }
309      total += increment;
310      for (int c = 0; c < num_classes; ++c) {
311        float prob = probs_t[c] / total;
312        probs_t[c] = std::max(prob, kMinProb_);
313      }
314    }
315  }
316  bool CTC::NeededNull(int index) const {
317    return labels_[index] == null_char_ && index > 0 && index + 1 < num_labels_ &&
318           labels_[index + 1] == labels_[index - 1];
319  }
320  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.cpp</h3>
            <pre><code>1  int TVizMapLink::GetPointN(const int& PointN) const {
2      if (SrcPointN == PointN) { return DstPointN; }
3      else if (DstPointN == PointN) { return SrcPointN; }
4      else { return -1; }
5  }
6  TVizMapLandscape::TVizMapLandscape(const TVizMapLandscapeV& CatLandscapeV,
7          const PVizMapLandscape& FullLandscape, const TIntH& CatIdH,
8          const double& MxCover, const double& MnCover, const int& MnCats) {
9      const int Cats = CatLandscapeV.Len();
10      IAssert(Cats > 0); IAssert(Cats < TInt::Mx);
11      const int XDim = CatLandscapeV[0]->GetXDim();
12      const int YDim = CatLandscapeV[0]->GetYDim();
13      IAssert(FullLandscape->GetXDim() == XDim);
14      IAssert(FullLandscape->GetYDim() == YDim);
15      HeightMatrixVV.Gen(XDim, YDim); HeightMatrixVV.PutAll(0.0);
16      for (int XPos = 0; XPos < XDim; XPos++) {
17          for (int YPos = 0; YPos < YDim; YPos++) {
18              HeightMatrixVV(XPos, YPos) = sdouble(FullLandscape->GetHeight(XPos, YPos));
19          }
20      }
21      TIntH CatIdToCountH; TIntH EdgeCatH;
22      forever {
23          const int ActiveCats = CatIdH.Len() - EdgeCatH.Len();
24          if (ActiveCats <= MnCats) { break; }
25          CatIdToCountH.Clr();
26          for (int XPos = 0; XPos < XDim; XPos++) {
27              for (int YPos = 0; YPos < YDim; YPos++) {
28                  double MxHeight = 0.0; int MxCatId = -1;
29                  for (int CatId = 0; CatId < Cats; CatId++) {
30                      if (EdgeCatH.IsKey(CatId)) { continue; }
31                      const double Height = CatLandscapeV[CatId]->GetHeight(XPos, YPos);
32                      if (Height > MxHeight) { MxHeight = Height; MxCatId = CatId; }
33                  }
34                  if (MxCatId != -1) { CatIdToCountH.AddDat(MxCatId)++; }
35              }
36          }
37          int MxCount = 0, MxCatId = -1;
38          int MnCount = XDim * YDim, MnCatId = -1;
39          int CatKeyId = CatIdToCountH.FFirstKeyId();
40          while (CatIdToCountH.FNextKeyId(CatKeyId)) {
41              const int CatId = CatIdToCountH.GetKey(CatKeyId);
42              const int CatCount = CatIdToCountH[CatKeyId];
43              if (CatCount > MxCount) { MxCount = CatCount; MxCatId = CatId; }
44              if (CatCount < MnCount) { MnCount = CatCount; MnCatId = CatId; }
45          }
46          const double TopCover = double(MxCount) / double(XDim * YDim);
47          const double BottomCover = double(MnCount) / double(XDim * YDim);
48          if (TopCover > MxCover && MxCatId != -1) {
49              printf("RemovingT %d (cover: %.4f), Left: %d\n", MxCatId, TopCover, ActiveCats-1);
50              EdgeCatH.AddDat(MxCatId);
51          } else if (BottomCover < MnCover && MnCatId != -1) {
52              printf("RemovingB %d (cover: %.4f), Left: %d\n", MnCatId, BottomCover, ActiveCats-1);
53              EdgeCatH.AddDat(MnCatId);
54          } else {
55              break; 
56          }
57      }
58      TIntV SelCatIdV;
59      for (int CatId = 0; CatId < Cats; CatId++) {
60          if (EdgeCatH.IsKey(CatId)) { continue; }
61          SelCatIdV.Add(CatId);
62      }
63      CatIdToCountH.Clr(); CatIdToCenterH.Clr();
64      CatMatrixVV.Gen(XDim, YDim); CatMatrixVV.PutAll(-1);
65      for (int XPos = 0; XPos < XDim; XPos++) {
66          for (int YPos = 0; YPos < YDim; YPos++) {
67              double MxHeight = 0.0; int MxCatIdN = -1;
68              for (int CatN = 0; CatN < SelCatIdV.Len(); CatN++) {
69                  const int CatIdN = SelCatIdV[CatN];
70                  const double Height = CatLandscapeV[CatIdN]->GetHeight(XPos, YPos);
71                  if (Height > MxHeight) { MxHeight = Height; MxCatIdN = CatIdN; }
72              }
73              if (MxCatIdN != -1) {
74                  const int MxCatId = CatIdH.GetKey(MxCatIdN);
75                  CatMatrixVV(XPos, YPos) = MxCatId;
76                  CatIdToCountH.AddDat(MxCatId)++;
77                  CatIdToCenterH.AddDat(MxCatId).Val1 += double(XPos) / double(XDim - 1);
78                  CatIdToCenterH.AddDat(MxCatId).Val2 += double(YPos) / double(YDim - 1);
79              }
80          }
81      }
82      int CatKeyId = CatIdToCenterH.FFirstKeyId();
83      while (CatIdToCenterH.FNextKeyId(CatKeyId)) {
84          const int CatId = CatIdToCenterH.GetKey(CatKeyId);
85          const double CatCount = double(CatIdToCountH.GetDat(CatId));
86          IAssert(CatCount > 0);
87          CatIdToCenterH[CatKeyId].Val1 = CatIdToCenterH[CatKeyId].Val1 / CatCount;
88          CatIdToCenterH[CatKeyId].Val2 = CatIdToCenterH[CatKeyId].Val2 / CatCount;
89      }
90      LevelV = FullLandscape->GetLevelV();
91  }
92  void TVizMapLandscape::PutCatVV(const TIntVV& _CatMatrixVV) {
93      IAssert(_CatMatrixVV.GetXDim() == GetXDim());
94      IAssert(_CatMatrixVV.GetYDim() == GetYDim());
95      CatMatrixVV = _CatMatrixVV;
96  }
97  int TVizMapLandscape::GetCatFromCoord(const double& X, const double& Y) {
98      const int XPos = TFlt::Round(X * double(GetXDim() - 1));
99      const int YPos = TFlt::Round(Y * double(GetYDim() - 1));
100      return GetCat(XPos, YPos);
101  }
102  void TVizMapLandscape::CalcStart(const int& XDim, const int& YDim, const double& Sigma) {
103      PKernel Kernel = TRadialKernel::New(1/Sigma);
104      CalcMatrixVV.Gen(XDim, YDim);
105      CalcMatrixVV.PutAll(0.0);
106      const double Threshold = 1e-10 * Kernel->Calc(0.0,0.0,0.0);
107      const double w = XDim, h = YDim;
108      int StampWidth = 0, StampHeight = 0;
109      while (Kernel->Calc(0,0,TMath::Sqr(StampWidth/w)) > Threshold) { StampWidth++; }
110      while (Kernel->Calc(0,0,TMath::Sqr(StampHeight/h)) > Threshold) { StampHeight++; }
111      StampWidth = TInt::GetMn(StampWidth, XDim);
112      StampHeight = TInt::GetMn(StampHeight, YDim);
113      CalcStampVV.Gen(StampWidth, StampHeight);
114      for (int x = 0; x < StampWidth; x++) {
115          const double X = x/w;
116          for (int y = 0; y < StampHeight; y++) {
117              const double Y = y/h;
118              CalcStampVV(x,y) = Kernel->Calc(0.0,0.0,X*X+Y*Y);
119          }
120      }
121  }
122  void TVizMapLandscape::CalcPutStamp(const double& PointX,
123          const double& PointY, const double& PointWgt) {
124      const int Width = CalcMatrixVV.GetXDim();
125      const int Height = CalcMatrixVV.GetYDim();
126      const int StampWidth = CalcStampVV.GetXDim();
127      const int StampHeight = CalcStampVV.GetYDim();
128      const int DocX = TFlt::Round(PointX * Width);
129      const int DocY = TFlt::Round(PointY * Height);
130      const int LowX = TInt::GetMx(DocX-StampWidth, -1);
131      const int LowY = TInt::GetMx(DocY-StampHeight, -1);
132      const int HighX = TInt::GetMn(DocX+StampWidth, Width);
133      const int HighY = TInt::GetMn(DocY+StampHeight, Height);
134      for (int x = DocX; x < HighX; x++) {
135          for (int y = DocY; y < HighY; y++) {
136              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
137              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
138              EAssertR(0 <= x-DocX && x-DocX < StampWidth, TInt(x).GetStr());
139              EAssertR(0 <= y-DocY && y-DocY < StampHeight, TInt(y).GetStr());
140              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(x-DocX,y-DocY);
141          }
142      }
143      for (int x = DocX-1; x > LowX; x--) {
144          for (int y = DocY; y < HighY; y++) {
145              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
146              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
147              EAssertR(0 <= DocX-x && DocX-x < StampWidth, TInt(x).GetStr());
148              EAssertR(0 <= y-DocY && y-DocY < StampHeight, TInt(y).GetStr());
149              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(DocX-x,y-DocY);
150          }
151      }
152      for (int x = DocX; x < HighX; x++) {
153          for (int y = DocY-1; y > LowY; y--) {
154              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
155              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
156              EAssertR(0 <= x-DocX && x-DocX < StampWidth, TInt(x).GetStr());
157              EAssertR(0 <= DocY-y && DocY-y < StampHeight, TInt(y).GetStr());
158              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(x-DocX,DocY-y);
159          }
160      }
161      for (int x = DocX-1; x > LowX; x--) {
162          for (int y = DocY-1; y > LowY; y--) {
163              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
164              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
165              EAssertR(0 <= DocX-x && DocX-x < StampWidth, TInt(x).GetStr());
166              EAssertR(0 <= DocY-y && DocY-y < StampHeight, TInt(y).GetStr());
167              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(DocX-x,DocY-y);
168          }
169      }
170  }
171  void TVizMapLandscape::CalcFinish(const double& MxVal, const int& Levels) {
172      const int Width = CalcMatrixVV.GetXDim();
173      const int Height = CalcMatrixVV.GetYDim();
174      double Mn = TFlt::Mx, Mx = 0.0;
175      for (int x = 0; x < Width; x++) {
176          for (int y = 0; y < Height; y++) {
177              Mx = TFlt::GetMx(Mx, CalcMatrixVV(x,y));
178              Mn = TFlt::GetMn(Mn, CalcMatrixVV(x,y));
179          }
180      }
181      double Diff = Mx - Mn; EAssert(Diff > 0.0);
182      HeightMatrixVV.Gen(Width, Height);
183      TSFltV HeightV(Width*Height, 0);
184      for (int x = 0; x < Width; x++) {
185          for (int y = 0; y < Height; y++) {
186              HeightMatrixVV(x,y) = sdouble(MxVal * (CalcMatrixVV(x,y)-Mn)/Diff);
187              HeightV.Add(HeightMatrixVV(x,y));
188          }
189      }
190      CalcMatrixVV.Clr(); CalcStampVV.Clr();
191      HeightV.Sort(); LevelV.Gen(Levels-1, 0);
192      for (int LevelN = 1; LevelN < Levels; LevelN++) {
193          LevelV.Add(LevelN * HeightV[HeightV.Len()/Levels]);
194      }
195  }
196  TVizMapFrame::TVizMapFrame(): PointV(), LinkV(), FrameSortN(-1) {
197  }
198  TVizMapFrame::TVizMapFrame(TSIn& SIn) {
199      PointV.Load(SIn); LinkV.Load(SIn);
200      FrameNmStr.Load(SIn); FrameSortN.Load(SIn);
201      LandscapeV.Load(SIn);
202      QueryLandscape = PVizMapLandscape(SIn);
203      PointBowDocBs = PBowDocBs(SIn);
204      KeyWdBowDocBs = PBowDocBs(SIn);
205      KeyWdSpVV.Load(SIn);
206      LinkBowDocBs = PBowDocBs(SIn);
207      LinkSpVV.Load(SIn);
208      KeyWdPointV.Load(SIn); KeyWdV.Load(SIn);
209      CatNmH.Load(SIn); DId2PointNMap.Load(SIn);
210  }
211  TVizMapFrame::TVizMapFrame(TSIn& SIn, PBowDocBs _PointBowDocBs,
212          PBowDocBs _KeyWdBowDocBs, PBowDocBs _LinkBowDocBs) {
213      PointV.Load(SIn); LinkV.Load(SIn);
214      FrameNmStr.Load(SIn); FrameSortN.Load(SIn);
215      LandscapeV.Load(SIn);
216      QueryLandscape = PVizMapLandscape(SIn);
217      PointBowDocBs = _PointBowDocBs;
218      KeyWdBowDocBs = _KeyWdBowDocBs;
219      KeyWdSpVV.Load(SIn);
220      LinkBowDocBs = _LinkBowDocBs;
221      LinkSpVV.Load(SIn);
222      KeyWdPointV.Load(SIn); KeyWdV.Load(SIn);
223      CatNmH.Load(SIn); DId2PointNMap.Load(SIn);
224  }
225  void TVizMapFrame::Save(TSOut& SOut, const bool& SaveBows) const {
226      PointV.Save(SOut); LinkV.Save(SOut);
227      FrameNmStr.Save(SOut); FrameSortN.Save(SOut);
228      LandscapeV.Save(SOut); QueryLandscape.Save(SOut);
229      if (SaveBows) { PointBowDocBs.Save(SOut); }
230      if (SaveBows) { KeyWdBowDocBs.Save(SOut); } KeyWdSpVV.Save(SOut);
231      if (SaveBows) { LinkBowDocBs.Save(SOut); } LinkSpVV.Save(SOut);
232      KeyWdPointV.Save(SOut); KeyWdV.Save(SOut);
233      CatNmH.Save(SOut); DId2PointNMap.Save(SOut);
234  }
235  int TVizMapFrame::GetPointN(const TFltV& CoordV, const double& Radius) const {
236      const int Points = PointV.Len();
237      int MnPointN = -1; double MnDist = TFlt::Mx;
238      for (int PointN = 0; PointN < Points; PointN++) {
239          const double Dist = TLinAlg::EuclDist2(CoordV, GetPoint(PointN)->GetCoordV());
240          if (MnDist > Dist) {
241              MnPointN = PointN; MnDist = Dist;
242          }
243      }
244      if (sqrt(MnDist) > Radius) { MnPointN = -1; }
245      return MnPointN;
246  }
247  int TVizMapFrame::GetRectPointV(const TFltRect& Rect, TIntV& RectPointV) const {
248      const int Points = PointV.Len(); RectPointV.Clr();
249      for (int PointN = 0; PointN < Points; PointN++) {
250          PVizMapPoint Point = GetPoint(PointN);
251          if (Rect.IsXYIn(Point->GetPointX(), Point->GetPointY())) {
252              RectPointV.Add(PointN);
253          }
254      }
255      return RectPointV.Len();
256  }
257  int TVizMapFrame::AddLink(PVizMapLink VizMapLink) {
258      EAssert(IsPointN(VizMapLink->GetSrcPointN()));
259      EAssert(IsPointN(VizMapLink->GetDstPointN()));
260      int LinkN = LinkV.Add(VizMapLink);
261      PointV[VizMapLink->GetSrcPointN()]->PutLinkN(LinkN);
262      PointV[VizMapLink->GetDstPointN()]->PutLinkN(LinkN);
263      return LinkN;
264  }
265  void TVizMapFrame::AddLandscape(const int& XDim, const int& YDim,
266          const double& Sigma, const bool& PointWgtP) {
267      PVizMapLandscape NewLandscape = TVizMapLandscape::New();
268      NewLandscape->CalcStart(XDim, YDim, Sigma);
269      const int Points = GetPoints();
270      for (int PointN = 0; PointN < Points; PointN++) {
271          const PVizMapPoint VizMapPoint = GetPoint(PointN);
272          const double PointWgt = PointWgtP ? VizMapPoint->GetWgt() : 1.0;
273          NewLandscape->CalcPutStamp(VizMapPoint->GetPointX(),
274              VizMapPoint->GetPointY(), PointWgt);
275      }
276      NewLandscape->CalcFinish(1.0, 3);
277      LandscapeV.Add(NewLandscape);
278  }
279  void TVizMapFrame::AddLandscapeFromLndMrk(const int& XDim,
280          const int& YDim, const double& Sigma,
281          const TVec<TFltV>& LndMrkPointV) {
282      PVizMapLandscape NewLandscape = TVizMapLandscape::New();
283      NewLandscape->CalcStart(XDim, YDim, Sigma);
284      const int LndMrkPoints = LndMrkPointV.Len();
285      for (int LndMrkPointN = 0; LndMrkPointN < LndMrkPoints; LndMrkPointN++) {
286          const TFltV LndMrkPoint = LndMrkPointV[LndMrkPointN];
287          IAssert(LndMrkPoint.Len() == 2);
288          NewLandscape->CalcPutStamp(LndMrkPoint[0], LndMrkPoint[1], 1.0);
289      }
290      NewLandscape->CalcFinish(1.0, 3);
291      LandscapeV.Add(NewLandscape);
292  }
293  void TVizMapFrame::AddLandscapeWithCats(const int& XDim, const int& YDim,
294          const double& Sigma, const bool& PointWgtP) {
295      TIntKdV CountCatIdV;
296      {int CatId = CatNmH.FFirstKeyId();
297      while (CatNmH.FNextKeyId(CatId)) {
298          const int Count = CatNmH[CatId];
299          CountCatIdV.Add(TIntKd(Count, CatId));
300      }}
301      CountCatIdV.Sort(false); const int MxCats = 20;
302      if (CountCatIdV.Len() > MxCats) { CountCatIdV.Trunc(MxCats); }
303      TIntH BigCatIdH;
304      for (int CatN = 0; CatN < CountCatIdV.Len(); CatN++) {
305          BigCatIdH.AddKey(CountCatIdV[CatN].Dat); }
306      const int Cats = BigCatIdH.Len(); IAssert(Cats > 0);
307      TVizMapLandscapeV CatLandscapeV(Cats, 0);
308      for (int CatIdN = 0; CatIdN < Cats; CatIdN++) {
309          PVizMapLandscape CatLandscape = TVizMapLandscape::New();
310          CatLandscape->CalcStart(XDim, YDim, Sigma);
311          CatLandscapeV.Add(CatLandscape);
312      }
313      PVizMapLandscape FullLandscape = TVizMapLandscape::New();
314      FullLandscape->CalcStart(XDim, YDim, Sigma);
315      const int Points = GetPoints();
316      for (int PointN = 0; PointN < Points; PointN++) {
317          const PVizMapPoint VizMapPoint = GetPoint(PointN);
318          const double PointWgt = PointWgtP ? VizMapPoint->GetWgt() : 1.0;
319          for (int CatIdN = 0; CatIdN < VizMapPoint->GetCats(); CatIdN++) {
320              const int CatId = VizMapPoint->GetCatId(CatIdN);
321              if (BigCatIdH.IsKey(CatId)) {
322                  CatLandscapeV[BigCatIdH.GetKeyId(CatId)]->CalcPutStamp(
323                      VizMapPoint->GetPointX(), VizMapPoint->GetPointY(), PointWgt);
324              }
325          }
326          FullLandscape->CalcPutStamp(VizMapPoint->GetPointX(),
327              VizMapPoint->GetPointY(), PointWgt);
328      }
329      for (int CatIdN = 0; CatIdN < Cats; CatIdN++) {
330          const int CatId = BigCatIdH.GetKey(CatIdN);
331          const double MxVal = double(CatNmH[CatId]) / double(Points);
332          CatLandscapeV[CatIdN]->CalcFinish(MxVal, 3);
333      }
334      FullLandscape->CalcFinish(1.0, 3);
335      LandscapeV.Add(TVizMapLandscape::New(CatLandscapeV,
336          FullLandscape, BigCatIdH, 0.6, 0.1, 2));
337  }
338  int TVizMapFrame::GetDocId(const int& PointN) const {
339      if (!IsPointN(PointN)) { return -1; }
340      PVizMapPoint Point = GetPoint(PointN);
341      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return -1; }
342      return Point->GetDocId();
343  }
344  TStr TVizMapFrame::GetDocNm(const int& PointN) const {
345      if (!IsPointN(PointN)) { return ""; }
346      PVizMapPoint Point = GetPoint(PointN);
347      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
348      return PointBowDocBs->GetDocNm(Point->GetDocId());
349  }
350  TStr TVizMapFrame::GetDocBody(const int& PointN) const {
351      if (!IsPointN(PointN)) { return ""; }
352      PVizMapPoint Point = GetPoint(PointN);
353      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
354      return PointBowDocBs->GetDocStr(Point->GetDocId());
355  }
356  TStr TVizMapFrame::GetDocUrl(const int& PointN) const {
357      if (!IsPointN(PointN)) { return ""; }
358      PVizMapPoint Point = GetPoint(PointN);
359      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
360      TStr UrlStr = PointBowDocBs->GetDocDescStr(Point->GetDocId());
<span onclick='openModal()' class='match'>361      if (UrlStr.SearchStr(":&bsol;&bsol;") != -1) { return UrlStr; }
362      else { return ""; }
363  }
364  int TVizMapFrame::GenKeyWd(const TFltV& CoordV, const double& Radius,
</span>365          const int& MxKeyWd, TStrV& KeyWdStrV, const bool& DistWgtP,
366          const bool& PointWgtP, const bool& BackKeyWdP) const {
367      if (KeyWdBowDocBs.Empty() || KeyWdSpVV.Empty()) {
368          KeyWdStrV.Clr(); return 0; }
369      TFltV FullKeyWdStrV(KeyWdBowDocBs->GetWords());
370      FullKeyWdStrV.PutAll(0.0);
371      const TVizMapPointV& _PointV = KeyWdPointV.Empty() ? PointV : KeyWdPointV;
372      const int Points = _PointV.Len(); int UsedPoints = 0, CenterPoints = 0;
373      bool PPQuad = false, PNQuad = false, NPQuad = false, NNQuad = false;
374      const double CoordX = CoordV[0], CoordY = CoordV[1];
375      for (int PointN = 0; PointN < Points; PointN++) {
376          PVizMapPoint Point = _PointV[PointN];
377          const double Dist = TLinAlg::EuclDist(CoordV, Point->GetCoordV());
378          if (Dist < Radius) {
379              PBowSpV DocSpV = KeyWdSpVV[PointN];
380              const double DistWgt = DistWgtP ? (Radius - Dist)/Radius : 1.0;
381              const double PointWgt = PointWgtP ? Point->GetWgt() : 1.0;
382              TBowLinAlg::AddVec(DistWgt*PointWgt, DocSpV, FullKeyWdStrV);
383              UsedPoints++; if (Dist < (Radius/3.0)) { CenterPoints++; }
384              const double DiffX = CoordX - Point->GetPointX();
385              const double DiffY = CoordY - Point->GetPointY();
386              PPQuad = PPQuad || (DiffX > 0 && DiffY > 0);
387              PNQuad = PNQuad || (DiffX > 0 && DiffY < 0);
388              NPQuad = NPQuad || (DiffX < 0 && DiffY > 0);
389              NNQuad = NNQuad || (DiffX < 0 && DiffY < 0);
390          }
391      }
392      if (UsedPoints == 0) { KeyWdStrV.Clr(); return 0; }
393      if (BackKeyWdP) {
394          if (CenterPoints == 5) { KeyWdStrV.Clr(); return 0; }
395          if (!(PPQuad && PNQuad && NPQuad && NNQuad)) { KeyWdStrV.Clr(); return 0; }
396      }
397      TLinAlg::NormalizeL1(FullKeyWdStrV);
398      TFltIntKdV WgtWIdKdV(FullKeyWdStrV.Len(), 0);
399      for (int WId = 0; WId < FullKeyWdStrV.Len(); WId++) {
400          WgtWIdKdV.Add(TFltIntKd(FullKeyWdStrV[WId], WId));
401      }
402      WgtWIdKdV.Sort(false);
403      KeyWdStrV.Gen(MxKeyWd, 0); int WIdN = 0;
404      while (WIdN < MxKeyWd) {
405          if (WIdN >= WgtWIdKdV.Len()) { return UsedPoints; }
406          if (WgtWIdKdV[WIdN].Key.Val < 0.001) { return UsedPoints; }
407          const int WId = WgtWIdKdV[WIdN].Dat;
408          KeyWdStrV.Add(KeyWdBowDocBs->GetWordStr(WId));
409          WIdN++;
410      }
411      return UsedPoints;
412  }
413  void TVizMapFrame::GenKeyWds(const int& KeyWds, const double& Radius,
414          const int& Candidantes, const int& RndSeed, const TFltRect& Rect) {
415      KeyWdV.Gen(KeyWds, 0); TRnd Rnd(RndSeed); TStrV KeyWdStrV;
416      const double MnX = Rect.GetMnX(), MnY = Rect.GetMnY();
417      const double LenX = Rect.GetXLen(), LenY = Rect.GetYLen();
418      for (int KeyWdN = 0; KeyWdN < KeyWds; KeyWdN++) {
419          const double X = MnX + Rnd.GetUniDev() * LenX;
420          const double Y = MnY + Rnd.GetUniDev() * LenY;
421          GenKeyWd(TFltV::GetV(X, Y), Radius, Candidantes, KeyWdStrV, false, false, true);
422          if (!KeyWdStrV.Empty()) {
423              const int KeyWdStrN = Rnd.GetUniDevInt(KeyWdStrV.Len());
424              TStr KeyWdStr = KeyWdStrV[KeyWdStrN];
425              KeyWdV.Add(TVizMapKeyWd::New(TFltV::GetV(X, Y), KeyWdStr));
426          }
427      }
428  }
429  void TVizMapFrame::AddCat(const int& PointN, const int& CatId) {
430      IAssert(IsPointN(PointN)); IAssert(CatNmH.IsKeyId(CatId));
431      CatNmH[CatId]++; GetPoint(PointN)->AddCat(CatId);
432  }
433  void TVizMapFrame::CalcDId2PointNMap() {
434      DId2PointNMap.Clr(); const int Points = GetPoints();
435      for (int PointN = 0; PointN < Points; PointN++) {
436          const PVizMapPoint VizMapPoint = GetPoint(PointN);
437          EAssert(VizMapPoint->IsDocId());
438          DId2PointNMap.AddDat(VizMapPoint->GetDocId(), PointN);
439      }
440  }
441  void TVizMapFrame::SaveVrml(const TStr& VrmlFNm, PVizMapLandscape Landscape,
442          const bool& ShowDocNmP, const bool& ShowDocPtP,
443          const bool& ShowKeyWdP, const double& FontSize,
444          const TStr& SkyColor, const TStr& TerrainColor,
445          const TStr& KeywordColor, const TStr& DocNmColor) {
446      PSOut SOut = TFOut::New(VrmlFNm);
447      TVrml::InsertHeader(SOut, SkyColor);
448      const TSFltVV& Rlf = Landscape->HeightVV(); TFltVV NewRlf;
449      const double Scale = TVrml::InsertEvelationGrid(SOut,
450          Rlf, NewRlf, TerrainColor, 5, 15.0, 0.7);
451      TStr DocSize = TStr::Fmt("%.3f %.3f %.3f",
452        FontSize, FontSize, FontSize);
453      for (int PointN = 0; PointN < GetPoints(); PointN++) {
454          TStr OrgDocNm = TStr::GetFNmStr(GetPoint(PointN)->GetPointNm());
455          const double PosX = GetPoint(PointN)->GetPointX();
456          const double PosY = GetPoint(PointN)->GetPointY();
457          TVrml::InsertBillboard(SOut, NewRlf, OrgDocNm, KeywordColor,
458            DocSize, PosX, PosY, 1.1, Scale, ShowDocNmP, ShowDocPtP);
459      }
460      if (ShowKeyWdP) {
461          TStr KeyWdSize = TStr::Fmt("%.3f %.3f %.3f",
462            0.5*FontSize, 0.5*FontSize, 0.5*FontSize);
463          TRnd Rnd(0);
464          for (int WdC = 0; WdC < 100; WdC++) {
465              const double PosX = Rnd.GetUniDev();
466              const double PosY = Rnd.GetUniDev();
467              TStrV KeyWdV; GenKeyWd(TFltV::GetV(PosX, PosY),
468                  0.3, 4, KeyWdV, false, false, true);
469              if (KeyWdV.Len() > 0) {
470                  TVrml::InsertBillboard(SOut, NewRlf,
471                    KeyWdV[Rnd.GetUniDevInt(KeyWdV.Len())], DocNmColor,
472                    KeyWdSize, PosX, PosY, 2.0, Scale, true, false);
473              }
474          }
475          for (int WdC = 0; WdC < 50; WdC++) {
476              const double PosX = Rnd.GetUniDev();
477              const double PosY = Rnd.GetUniDev();
478              TStrV KeyWdV; GenKeyWd(TFltV::GetV(PosX, PosY),
479                  0.2, 4, KeyWdV, false, false, true);
480              if (KeyWdV.Len() > 0) {
481                  TVrml::InsertBillboard(SOut, NewRlf,
482                    KeyWdV[Rnd.GetUniDevInt(KeyWdV.Len())], DocNmColor,
483                    KeyWdSize, PosX, PosY, 2.0, Scale, true, false);
484              }
485          }
486      }
487  }
488  void TVizMapFrame::SaveLegend(const TStr& TxtFNm, const int& LegendGridWidth,
489          const int& LegendGridHeight) {
490      TFOut FOut(TxtFNm);
491      for (int PointN = 0; PointN < GetPoints(); PointN++) {
492          PVizMapPoint Point = GetPoint(PointN);
493          const int XMark = (int)floor(Point->GetPointX() * LegendGridWidth);
494          const int YMark = (int)floor(Point->GetPointY() * LegendGridHeight) + 1;
495          const char XMarkCh = 'A' + XMark;
496          FOut.PutStrLn(Point->GetPointNm() + "\t" + TStr(XMarkCh) + TInt::GetStr(YMark));
497      }
498      FOut.Flush();
499  }
500  TVizMap::TVizMap(TSIn& SIn) {
501      TBool AllSameP(SIn);
502      if (AllSameP) {
503          PBowDocBs PointBowDocBs(SIn);
504          PBowDocBs KeyWdBowDocBs(SIn);
505          PBowDocBs LinkBowDocBs(SIn);
506          TInt Frames(SIn);
507          VizMapFrameV.Gen(Frames, 0);
508          for (int FrameN = 0; FrameN < Frames; FrameN++) {
509              PVizMapFrame Frame = TVizMapFrame::Load(SIn,
510                  PointBowDocBs, KeyWdBowDocBs, LinkBowDocBs);
511              VizMapFrameV.Add(Frame);
512          }
513      } else {
514          VizMapFrameV.Load(SIn);
515      }
516  }
517  void TVizMap::Save(TSOut& SOut) const {
518      TBool AllSameP = true;
519      for (int FrameN = 1; FrameN < VizMapFrameV.Len(); FrameN++) {
520          PVizMapFrame PrevFrame = VizMapFrameV[FrameN - 1];
521          PVizMapFrame Frame = VizMapFrameV[FrameN];
522          const bool PointBowP =
523              (Frame->GetPointBow().Empty() && PrevFrame->GetPointBow().Empty()) ||
524              (Frame->GetPointBow()->GetSig() == PrevFrame->GetPointBow()->GetSig());
525          const bool KeyWdBowP =
526              (Frame->GetKeyWdBow().Empty() && PrevFrame->GetKeyWdBow().Empty()) ||
527              (Frame->GetKeyWdBow()->GetSig() == PrevFrame->GetKeyWdBow()->GetSig());
528          const bool LinkBowP =
529              (Frame->GetLinkBow().Empty() && PrevFrame->GetLinkBow().Empty()) ||
530              (Frame->GetLinkBow()->GetSig() == PrevFrame->GetLinkBow()->GetSig());
531          AllSameP = PointBowP && KeyWdBowP && LinkBowP;
532          if (!AllSameP) { break; }
533      }
534      AllSameP.Save(SOut);
535      if (AllSameP) {
536          PVizMapFrame Frame = VizMapFrameV[0];
537          Frame->GetPointBow().Save(SOut);
538          Frame->GetKeyWdBow().Save(SOut);
539          Frame->GetLinkBow().Save(SOut);
540          TInt Frames = VizMapFrameV.Len(); Frames.Save(SOut);
541          for (int FrameN = 0; FrameN < Frames; FrameN++) {
542              VizMapFrameV[FrameN]->Save(SOut, false);
543          }
544      } else {
545          VizMapFrameV.Save(SOut);
546      }
547  }
548  void TVizMap::AddVizMapFrame(const PVizMapFrame& VizMapFrame, const bool& SortedP) {
549      if (SortedP) { VizMapFrameV.Add(VizMapFrame); }
550      else { VizMapFrameV.AddSorted(VizMapFrame); }
551  }
552  void TVizMap::SaveXmlDoc(TSOut& SOut, const TStr& Nm, const TStr& Body,
553          const TStr& DisplayBody, const TStrV& CatNmV, const TStrV& AuthorV,
554          const TStr& FrameNm, const int& FrameSortN) {
555      SOut.PutStrLn(" <document>");
556      SOut.PutStrLn("  <name>" + TXmlDoc::GetXmlStr(Nm) + "</name>");
557      SOut.PutStrLn("  <body>" + TXmlDoc::GetXmlStr(Body) + "</body>");
558      if (!DisplayBody.Empty()) {
559          SOut.PutStrLn("  <display_body>" + TXmlDoc::GetXmlStr(DisplayBody) + "</display_body>");
560      }
561      if (!CatNmV.Empty()) {
562          SOut.PutStrLn("  <categories>");
563          for (int CatNmN = 0; CatNmN < CatNmV.Len(); CatNmN++) {
564              SOut.PutStrLn("   <category>" +
565                  TXmlDoc::GetXmlStr(CatNmV[CatNmN]) + "</category>");
566          }
567          SOut.PutStrLn("  </categories>");
568      }
569      if (!AuthorV.Empty()) {
570          SOut.PutStrLn("  <authors>");
571          for (int AuthorN = 0; AuthorN < AuthorV.Len(); AuthorN++) {
572              SOut.PutStrLn("   <author>" +
573                  TXmlDoc::GetXmlStr(AuthorV[AuthorN]) + "</author>");
574          }
575          SOut.PutStrLn("  </authors>");
576      }
577      if (!FrameNm.Empty() && (FrameSortN != -1)) {
578          SOut.PutStrLn(TStr::Fmt("  <frame id=\"%d\">%s</frame>",
579              FrameSortN, TXmlDoc::GetXmlStr(FrameNm).CStr()));
580      }
581      SOut.PutStrLn(" </document>");
582  }
583  int TVizMapXmlDoc::AddToBowDocBs(PVizMapXmlDocBs VizMapXmlDocBs, PBowDocBs BowDocBs) const {
584      TStr DocNm = Nm;
585      if (BowDocBs->IsDocNm(DocNm)) {
586          int Count = 2; TStr NewDocNm;
587          do { NewDocNm = TStr::Fmt("%s (%3d)", DocNm.CStr(), Count++);
588          } while (BowDocBs->IsDocNm(NewDocNm));
589          DocNm = NewDocNm;
590      }
591      TStr DocBody = Body;
592      TStrV CatNmV;
593      for (int CatIdN = 0; CatIdN < CatIdV.Len(); CatIdN++) {
594          const int CatId = CatIdV[CatIdN];
595          CatNmV.Add(VizMapXmlDocBs->CatNmH.GetKey(CatId));
596      }
597      const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, true);
598      TStr AuthorStr;
599      for (int AuthorIdN = 0; AuthorIdN < AuthorIdV.Len(); AuthorIdN++) {
600          const int AuthorId = AuthorIdV[AuthorIdN];
601          if (AuthorIdN > 0) { AuthorStr + ", "; }
602          AuthorStr += VizMapXmlDocBs->AuthorNmH.GetKey(AuthorId);
603      }
604      if (!DisplayBody.Empty()) {
605          TStr DisplayBody = AuthorStr.Empty() ? DisplayBody :
606              AuthorStr + "\r\n" + DisplayBody;
607          BowDocBs->PutDocStr(DId, DisplayBody);
608      } else if (!AuthorStr.Empty()) {
609          BowDocBs->PutDocStr(DId, AuthorStr + "\r\n" + DocBody);
610      }
611      return DId;
612  }
613  TVizMapXmlDocBs::TVizMapXmlDocBs(const TStr& XmlFNm, const PNotify& Notify) {
614      PSIn XmlSIn = TFIn::New(XmlFNm); TXmlDoc::SkipTopTag(XmlSIn);
615      PXmlDoc XmlDoc; int XmlDocs=0;
616      forever {
617          XmlDoc = TXmlDoc::LoadTxt(XmlSIn); XmlDocs++;
618          if (!XmlDoc->IsOk()) { &bsol;*InfoNotify(XmlDoc->GetMsgStr());*/ break; }
619          if (XmlDocs % 10 == 0) { Notify->OnStatus(TStr::Fmt("%d\r", XmlDocs)); }
620          PXmlTok XmlTok = XmlDoc->GetTok();
621          TVizMapXmlDoc VizMapXmlDoc;
622          VizMapXmlDoc.Nm = XmlTok->GetTagVal("name", false);
623          VizMapXmlDoc.Body = XmlTok->GetTagVal("body", false);
624          if (XmlTok->IsTagTok("display_body")) {
625              VizMapXmlDoc.DisplayBody = XmlTok->GetTagVal("display_body", false); }
626          TXmlTokV CatTokV; XmlTok->GetTagTokV("categories|category", CatTokV);
627          for (int CatTokN = 0; CatTokN < CatTokV.Len(); CatTokN++) {
628              TStr CatNm = CatTokV[CatTokN]->GetTokStr(false);
629              int CatId = CatNmH.AddKey(CatNm.GetTrunc());
630              VizMapXmlDoc.CatIdV.Add(CatId);
631          }
632          TXmlTokV AuthorTokV; XmlTok->GetTagTokV("authors|author", AuthorTokV);
633          for (int AuthorTokN = 0; AuthorTokN < AuthorTokV.Len(); AuthorTokN++) {
634              TStr AuthorNm = AuthorTokV[AuthorTokN]->GetTokStr(false);
635              int AuthorId = AuthorNmH.AddKey(AuthorNm.GetTrunc());
636              VizMapXmlDoc.AuthorIdV.Add(AuthorId);
637          }
638          if (XmlTok->IsSubTag("frame")) {
639              TStr FrameNm = XmlTok->GetTagVal("frame", false);
640              const int FrameSortN = XmlTok->GetTagTok("frame")->GetIntArgVal("id", -1);
641              if (FrameNmToSortN.IsKey(FrameNm)) {
642                  IAssert(FrameSortN == FrameNmToSortN(FrameNm));
643              } else {
644                  FrameNmToSortN.AddDat(FrameNm, FrameSortN);
645              }
646              VizMapXmlDoc.FrameNm = FrameNm.GetTrunc();
647              VizMapXmlDoc.FrameSortN = FrameSortN;
648          } else {
649              IAssert(FrameNmToSortN.Empty());
650          }
651          const int DocId = XmlDocV.Add(VizMapXmlDoc);
652          if (!FrameNmToSortN.Empty()) {
653              FrameSortNToDocId.AddDat(VizMapXmlDoc.FrameSortN).Add(DocId);
654          }
655      }
656      Notify->OnStatus(TStr::Fmt("%d", XmlDocs-1));
657  }
658  TVizMapXmlDocBs::TVizMapXmlDocBs(const PWdGixRSet& RSet,
659          const TVizMapXmlDocGrouping& Grouping, const PNotify& Notify) {
660      const int Docs = RSet->GetDocs();
661      for (int DocN = 0; DocN < Docs; DocN++) {
662          TVizMapXmlDoc VizMapXmlDoc;
663          TTm DateTm = RSet->GetDocDateTime(DocN);
664          int FrameSortN = 0; TStr FrameNm = "";
665          if (Grouping == vmxdgDay) {
666              FrameNm = DateTm.GetWebLogDateStr();
667              FrameSortN = TTm::GetDateIntFromTm(DateTm);
668          } else if (Grouping == vmxdgMonth) {
669              FrameNm = TStr::Fmt("%04d-%02d", DateTm.GetYear(), DateTm.GetMonth());
670              FrameSortN = TTm::GetMonthIntFromTm(DateTm);
671          } else if (Grouping == vmxdgYear) {
672              FrameNm = TStr::Fmt("%04d", DateTm.GetYear());
673              FrameSortN = DateTm.GetYear();
674          }
675          if (Grouping == vmxdgNone) {
676              IAssert(FrameNmToSortN.Empty());
677          } else {
678              if (FrameNmToSortN.IsKey(FrameNm)) {
679                  IAssert(FrameSortN == FrameNmToSortN(FrameNm));
680              } else {
681                  FrameNmToSortN.AddDat(FrameNm, FrameSortN);
682              }
683          }
684          VizMapXmlDoc.FrameNm = FrameNm;
685          VizMapXmlDoc.FrameSortN = FrameSortN;
686          PXmlDoc Doc=TXmlDoc::LoadStr(RSet->GetDocStr(DocN));
687          IAssertR(Doc->IsOk(), Doc->GetMsgStr());
688          VizMapXmlDoc.Nm =Doc->GetTagTok("doc|title")->GetTokStr(false);
689          TChA BodyChA; VizMapXmlDoc.AuthorIdV.Clr();
690          TXmlTokV ParTokV; Doc->GetTagTokV("doc|body|p", ParTokV);
691          for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
692              TStr ParStr = ParTokV[ParTokN]->GetTokStr(false);
693              if (!BodyChA.Empty()) { BodyChA += "\r\n"; }
694              BodyChA += ParStr;
695              TXmlTokV NmEnTokV; ParTokV[ParTokN]->GetTagTokV("nmobj", NmEnTokV);
696              for (int NmEnTokN = 0; NmEnTokN < NmEnTokV.Len(); NmEnTokN++) {
697                  TStr NmEnStr = NmEnTokV[NmEnTokN]->GetTokStr(false);
698                  const int NmEnId = AuthorNmH.AddKey(NmEnStr);
699                  VizMapXmlDoc.AuthorIdV.AddMerged(NmEnId);
700              }
701          }
702          VizMapXmlDoc.Body = BodyChA;
703          VizMapXmlDoc.CatIdV.Clr();
704          const TStrV& CatNmV = RSet->GetDocCatNmV(DocN);
705          for (int CatNmN = 0; CatNmN < CatNmV.Len(); CatNmN++) {
706              const TStr& CatNm = CatNmV[CatNmN];
707              const int CatId = CatNmH.AddKey(CatNm); CatNmH[CatId]++;
708              VizMapXmlDoc.CatIdV.AddMerged(CatId);
709          }
710          const int DocId = XmlDocV.Add(VizMapXmlDoc);
711          if (!FrameNmToSortN.Empty()) {
712              FrameSortNToDocId.AddDat(VizMapXmlDoc.FrameSortN).Add(DocId);
713          }
714      }
715  }
716  PBowDocBs TVizMapXmlDocBs::LoadBowDocBs(const TStr& XmlFNm, PSwSet SwSet,
717          PStemmer Stemmer, const int& MxNGramLen, const int& MnNGramFq) {
718      PVizMapXmlDocBs XmlDocBs = TVizMapXmlDocBs::New(XmlFNm);
719      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
720      PNGramBs NGramBs = NULL;
721      if (MxNGramLen > 1) {
722          TStrV DocBodyV(XmlDocV.Len(), 0);
723          for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
724              const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
725              DocBodyV.Add(XmlDoc.Nm + "\n" + XmlDoc.Body);
726          }
727          NGramBs = TNGramBs::GetNGramBsFromHtmlStrV(DocBodyV,
728              MxNGramLen, MnNGramFq, SwSet, Stemmer);
729      }
730      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NGramBs);
731      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
732          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
733          TStr DocNm = XmlDoc.Nm, DocBody = XmlDoc.Body;
734          TStrV CatNmV;
735          for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
736              const int CatId = XmlDoc.CatIdV[CatIdN];
737              CatNmV.Add(XmlDocBs->CatNmH.GetKey(CatId));
738          }
739          TStr AuthorStr;
740          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
741              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
742              if (AuthorIdN > 0) { AuthorStr + ", "; }
743              AuthorStr += XmlDocBs->AuthorNmH.GetKey(AuthorId);
744          }
745          if (AuthorStr.Empty()) { DocBody = DocBody; }
746          else { DocBody = AuthorStr + "\r\n" + DocBody;}
747          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, true);
748          if (!XmlDoc.DisplayBody.Empty()) {
749              TStr DisplayBody = AuthorStr.Empty() ? XmlDoc.DisplayBody :
750                  AuthorStr + "\r\n" + XmlDoc.DisplayBody;
751              BowDocBs->PutDocStr(DId, DisplayBody);
752          }
753      }
754      return BowDocBs;
755  }
756  void TVizMapFactory::CG(const TMatrix& Matrix, const TFltV& b,
757          TFltV& x, PNotify Notify, const int& MaxStep, const double& EpsTer) {
758      int M = x.Len(), R = b.Len(), i;
759      TFltV r(M), p(M), q(M), tmp(R);
760      x.PutAll(0.0);
761      Matrix.MultiplyT(b, r);
762      double nro, ro, alpha, beta;
763      nro = TLinAlg::Norm2(r);
764      int k=1;
765      while (k <= MaxStep && nro > EpsTer && k <= M){
766          if (k == 1) {
767              p = r;
768          } else {
769              beta = nro / ro;
770              for (i = 0; i < M; i++)
771                  p[i] = r[i] + beta*p[i];
772          }
773          Matrix.Multiply(p, tmp);
774          Matrix.MultiplyT(tmp, q);
775          alpha = nro / TLinAlg::DotProduct(p, q);
776          for (i = 0; i < M; i++) {
777              x[i] = x[i] + alpha * p[i];
778              r[i] = r[i] - alpha * q[i];
779          }
780          ro = nro;
781          nro = TLinAlg::Norm2(r);
782          k++;
783      }
784  }
785  void TVizMapFactory::MakeFlat(PSVMTrainSet Set,
786          const TVizDistType& DistType, TVec<TFltV>& DocPointV,
787          const int& MxStep, const int& MxSecs, const double& MnDiff,
788          const bool& RndStartPos, PNotify Notify) {
789      const int Len = Set->Len();
790      const int EqN = (Len*(Len - 1))/2;
791      Notify->OnStatus(TStr::Fmt("matrix size: %d x %d", EqN, 2*Len));
792      TFltV x(Len), y(Len), dxdy(Len + Len);
793      if (RndStartPos) {
794          TRnd Rnd1(1), Rnd2(2);
795          TLAMisc::FillRnd(x, Rnd1); TLAMisc::FillRnd(y, Rnd2);
796      } else {
797          EAssertR(DocPointV.Len() == Len, TStr::Fmt("%d == %d", DocPointV.Len(), Len));
798          for (int PntN = 0; PntN < Len; PntN++) {
799              x[PntN] = DocPointV[PntN][0];
800              y[PntN] = DocPointV[PntN][1];
801          }
802      }
803      TFltV b(EqN), z(2*Len);
804      TSparseRowMatrix B; B.RowN = EqN; B.ColN = 2*Len; B.DocSpVV.Gen(EqN);
805      for (int i = 0; i < B.RowN; i++) B.DocSpVV[i].Gen(4);
806      int Step = 0; TTm StartTm = TTm::GetCurUniTm();
807      int PrevTimeSec = 0;
808      forever {
809          b.PutAll(0.0); z.PutAll(0.0);
810          int k = 0;
811          TVec<TIntFltKdV>& RowVV = B.DocSpVV;
812          for (int i = 0; i < Len; i++) {
813              for (int j = i+1; j < Len; j++) {
814                  TIntFltKdV& RowV = RowVV[k];
815                  RowV[0] = TIntFltKd(i, x[i] - x[j]);
816                  RowV[1] = TIntFltKd(j, x[j] - x[i]);
817                  RowV[2] = TIntFltKd(Len+i, y[i] - y[j]);
818                  RowV[3] = TIntFltKd(Len+j, y[j] - y[i]);
819                  double Dij = 0.0;
820                  switch (DistType) {
821                      case vdtEucl:    Dij = Set->EuclDist(i, j); break;
822                      case vdtCos: Dij = 1.0 - Set->DotProduct(i, j); break;
823                      case vdtSqrtCos: Dij = 1.0 - sqrt(Set->DotProduct(i, j)); break;
824                      default: TExcept::Throw("Wrong DistType!");
825                  }
826                  b[k] = (TMath::Sqr(Dij) - TMath::Sqr(x[j]-x[i]) - TMath::Sqr(y[j]-y[i])) / 2;
827                  k++;
828              }
829          }
830          dxdy.PutAll(0.0);
831          CG(B, b, dxdy, Notify);
832          double Diff = TMath::Mx(TFlt::Abs(dxdy[0]), TFlt::Abs(dxdy[Len]));
833          for (int i = 0; i < Len; i++) {
834              x[i] += dxdy[i]; y[i] += dxdy[Len+i];
835              Diff = TMath::Mx(Diff, TFlt::Abs(dxdy[i]), TFlt::Abs(dxdy[Len+i]));
836          }
837          Step = Step + 1;
838          const int RunTimeSec =
839            int(TTm::GetDiffMSecs(StartTm, TTm::GetCurUniTm()) / 1000);
840          if (PrevTimeSec < RunTimeSec) {
841              PrevTimeSec = RunTimeSec;
842              Notify->OnStatus(TStr::Fmt("[Step:%5d, Time:%4d, Diff %8.5f]\r", Step, RunTimeSec, Diff));
843          }
844          if ((MxStep > 0) && (Step > MxStep))  { break; }
845          if ((MxSecs > 0) && (RunTimeSec > MxSecs))  { break; }
846          if ((Diff >= 0.0) && (Diff < MnDiff))  { break; }
847      }
848      Notify->OnStatus("\n");
849      DocPointV.Gen(Len, 0);
850      for (int i = 0; i < Len; i++) {
851          DocPointV.Add(TFltV::GetV(x[i], y[i]));
852      }
853  }
854  void TVizMapFactory::NormalizePoints(TVec<TFltV>& PointV) {
855      const int Dim = PointV[0].Len();
856      for (int d = 0; d < Dim; d++) {
857          double Min = PointV[0][d];
858          double Max = PointV[0][d];
859          for (int i = 1; i < PointV.Len(); i++) {
860              const double PointVal = PointV[i][d];
861              Min = TFlt::GetMn(Min, PointVal);
862              Max = TFlt::GetMx(Max, PointVal);
863          }
864          double Diff = Max - Min; IAssert(Diff > 0);
865          for (int i = 0; i < PointV.Len(); i++) {
866              const double OldVal = PointV[i][d];
867              const double NewVal = 0.96*(OldVal - Min)/Diff + 0.02;
868              EAssertR(0.0 <= NewVal && NewVal <= 1.0,
869                TStr::Fmt("%d:%d %g %g %g %g %g", i,
870                PointV.Len(), Min, Max, Diff, OldVal, NewVal));
871              PointV[i][d] = NewVal;
872          }
873      }
874  }
875  void TVizMapFactory::LsiMds(TVec<PBowSpV> DocSpV, PSemSpace SemSpace,
876          TVec<TFltV>& DocPointV, const double& SemSpaceThresh,
877          const int& MxStep, const int& MxSecs, const double& MnDiff,
878          PNotify Notify) {
879      double ApproxVal;
880      Notify->OnStatus(TStr::Fmt("Approximating %d docs ...\n", DocSpV.Len()));
881      int SemSpcDim = SemSpace->GetDimNeededForApprox(
882          DocSpV, SemSpaceThresh, ApproxVal, 3);
883      EAssert((SemSpcDim == -1) || (SemSpcDim > 0));
884      if (SemSpcDim == -1) { SemSpcDim = SemSpace->GetVecs(); }
885      Notify->OnStatus(TStr::Fmt("Norm(dim:%d) = [avg: %.3f, mn:%.3f]",
886          SemSpcDim, ApproxVal, SemSpaceThresh));
887      Notify->OnStatus("Multidimensional Scaling:");
888      const int Docs = DocSpV.Len();
889      TVec<PBowSpV> ProjDocSpV(Docs, 0);
890      for (int DocN = 0; DocN < Docs; DocN++) {
891          ProjDocSpV.Add(SemSpace->ProjectSpV(DocSpV[DocN], SemSpcDim, false)); }
892      PSVMTrainSet DocSet = TBowDocBs2TrainSet::NewBowNoCat(ProjDocSpV);
893      MakeFlat(DocSet, vdtEucl, DocPointV, MxStep,
894          MxSecs, MnDiff, DocPointV.Empty(), Notify);
895      NormalizePoints(DocPointV);
896  }
897  PVizMapFrame TVizMapFactory::DocLsiMds(PBowDocWgtBs BowDocWgtBs,
898          PSemSpace SemSpace, const TVec<TFltV>& _DocPointV,
899          const double& SemSpaceThresh, const int& MxStep,
900          const int& MxSecs, const double& MnDiff, PNotify Notify) {
901      const int Docs = BowDocWgtBs->GetDocs();
902      TVec<PBowSpV> DocSpV(Docs, 0);
903      for (int DIdN = 0; DIdN < Docs; DIdN++) {
904          const int DId = BowDocWgtBs->GetDId(DIdN);
905          DocSpV.Add(BowDocWgtBs->GetSpV(DId));
906      }
907      TVec<TFltV> DocPointV = _DocPointV;
908      LsiMds(DocSpV, SemSpace, DocPointV, SemSpaceThresh, MxStep, MxSecs, MnDiff, Notify);
909      PVizMapFrame VizMapFrame = TVizMapFrame::New();
910      for (int DIdN = 0; DIdN < Docs; DIdN++) {
911          const int DId = BowDocWgtBs->GetDId(DIdN);
912          PVizMapPoint DocPoint = TVizMapPoint::New(DocPointV[DIdN]);
913          DocPoint->PutDocId(DId); VizMapFrame->AddPoint(DocPoint);
914      }
915      VizMapFrame->CalcDId2PointNMap();
916      return VizMapFrame;
917  }
918  void TVizMapFactory::AddDocMetadata(PVizMapFrame VizMapFrame,
919          PBowDocBs PointBowDocBs, PBowDocBs KeyWdBowDocBs,
920          PBowDocWgtBs KeyWdBowDocWgtBs, PVizMapLndMrk VizMapLndMrk) {
921      for (int CId = 0; CId < PointBowDocBs->GetCats(); CId++) {
922          TStr CatNm = PointBowDocBs->GetCatNm(CId);
923          const int NewCId = VizMapFrame->AddCatNm(CatNm);
924          IAssert(NewCId == CId);
925      }
926      VizMapFrame->PutPointBow(PointBowDocBs);
927      const int PointDocs = PointBowDocBs->GetDocs();
928      for (int PointDId = 0; PointDId < PointDocs; PointDId++) {
929          if (VizMapFrame->IsInDId(PointDId)) {
930              const int PointN = VizMapFrame->GetPointN(PointDId);
931              VizMapFrame->GetPoint(PointN)->PutPointNm(PointBowDocBs->GetDocNm(PointDId));
932              const int PointCIds = PointBowDocBs->GetDocCIds(PointDId);
933              for (int PointCIdN = 0; PointCIdN < PointCIds; PointCIdN++) {
934                  const int PointCId = PointBowDocBs->GetDocCId(PointDId, PointCIdN);
935                  VizMapFrame->AddCat(PointN, PointCId);
936              }
937          }
938      }
939      if (VizMapLndMrk.Empty()) {
940          TBowSpVV KeyWdSpVV;
941          const int Points = VizMapFrame->GetPoints();
942          for (int PointN = 0; PointN <  Points; PointN++) {
943              const int PointDId = VizMapFrame->GetPoint(PointN)->GetDocId();
944              PBowSpV KeyWdSpV = KeyWdBowDocWgtBs->GetSpV(PointDId);
945              KeyWdSpVV.Add(KeyWdSpV);
946          }
947          VizMapFrame->PutKeyWdBow(KeyWdBowDocBs, KeyWdSpVV);
948      } else {
949          TBowSpVV KeyWdSpVV;
950          const int LndMrks = VizMapLndMrk->GetLndMrks();
951          for (int LndMrkN = 0; LndMrkN < LndMrks; LndMrkN++) {
952              PVizMapPoint KeyWdPoint =
953                  TVizMapPoint::New(VizMapLndMrk->GetLndMrkPointV(LndMrkN));
954              VizMapFrame->AddKeyWdPoint(KeyWdPoint);
955              PBowSpV KeyWdSpV = VizMapLndMrk->GetLndMrkSpV(LndMrkN);
956              KeyWdSpVV.Add(KeyWdSpV);
957          }
958          VizMapFrame->PutKeyWdBow(KeyWdBowDocBs, KeyWdSpVV);
959      }
960  }
961  void TVizMapFactory::LndMrk(PBowDocWgtBs BowDocWgtBs, PBowSim BowSim,
962          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
963          TVec<TFltV>& DocPointV, const int& LinCombNum, PNotify Notify) {
964      const int Clusts = ClustSpV.Len();
965      const int TopClustN = TInt::GetMn(LinCombNum, Clusts);
966      const int Docs = BowDocWgtBs->GetDocs();
967      Notify->OnStatus(TStr::Fmt("Positioning %d documents using %d landmarks:", Docs, Clusts));
968      DocPointV.Gen(Docs, 0);
969      for (int DocN = 0; DocN < Docs; DocN++) {
970          Notify->OnStatus(TStr::Fmt("%d\r", DocN));
971          const int DId = BowDocWgtBs->GetDId(DocN);
972          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
973          TFltIntKdV SimClustV(Clusts, 0);
974          for (int ClustId = 0; ClustId < Clusts; ClustId++) {
975              const double ClustSim = BowSim->GetSim(DocSpV, ClustSpV[ClustId]);
976              SimClustV.Add(TFltIntKd(ClustSim, ClustId));
977          }
978          SimClustV.Sort(false);
979          double SimSum = 0.0;
980          for (int ClustN = 0; ClustN < TopClustN; ClustN++) {
981              SimSum += SimClustV[ClustN].Key; }
982          DocPointV.Add(TFltV::GetV(0.0, 0.0));
983          for (int ClustN = 0; ClustN < TopClustN; ClustN++) {
984              const double SumWgt = (SimSum > 1e-7) ?
985                  SimClustV[ClustN].Key / SimSum : 0.0;
986              const int ClustId = SimClustV[ClustN].Dat;
987              TLinAlg::AddVec(SumWgt, ClustPointV[ClustId],
988                  DocPointV.Last(), DocPointV.Last());
989          }
990      }
991      Notify->OnStatus("");
992  }
993  PVizMapFrame TVizMapFactory::DocLndMrk(PBowDocWgtBs BowDocWgtBs,
994          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
995          const int& LinCombNum, PNotify Notify) {
996      TVec<TFltV> DocPointV;
997      PBowSim BowSim = TBowSim::New(bstCos);
998      LndMrk(BowDocWgtBs, BowSim, ClustSpV, ClustPointV, DocPointV, LinCombNum, Notify);
999      PVizMapFrame VizMapFrame = TVizMapFrame::New();
1000      const int Docs = BowDocWgtBs->GetDocs();
1001      for (int DIdN = 0; DIdN < Docs; DIdN++) {
1002          const int DId = BowDocWgtBs->GetDId(DIdN);
1003          PVizMapPoint DocPoint = TVizMapPoint::New(DocPointV[DIdN]);
1004          DocPoint->PutDocId(DId); VizMapFrame->AddPoint(DocPoint);
1005      }
1006      VizMapFrame->CalcDId2PointNMap();
1007      return VizMapFrame;
1008  }
1009  PVizMapFrame TVizMapFactory::ClustLsiMdsDocLndMrk(PBowDocWgtBs BowDocWgtBs,
1010          PBowDocPart BowDocPart, PSemSpace SemSpace, const int& LinCombNum,
1011          const double& SemSpaceThresh, const int& MxStep, const int& MxSecs,
1012          const double& MnDiff, PNotify Notify) {
1013      const int Clusts = BowDocPart->GetClusts();
1014      TVec<PBowSpV> ClustSpV(Clusts, 0);
1015      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
1016          ClustSpV.Add(BowDocPart->GetClust(ClustN)->GetConceptSpV()); }
1017      TVec<TFltV> ClustPointV; EAssert(ClustPointV.Empty());
1018      LsiMds(ClustSpV, SemSpace, ClustPointV,
1019          SemSpaceThresh, MxStep, MxSecs, MnDiff, Notify);
1020      return DocLndMrk(BowDocWgtBs, ClustSpV, ClustPointV, LinCombNum, Notify);
1021  }
1022  PVizMapFrame TVizMapFactory::NewVizMapFrame(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1023          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs,
1024          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1025          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1026      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV); PVizMapFrame VizMapFrame;
1027      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocBs->GetDocs()));
1028      if (BowDocBs->GetDocs() < ThDocs) {
1029          Notify->OnStatus("Calculating semantic space ... ");
1030          PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(
1031              BowDocWgtBs, AllDIdV, BowDocBs->GetDocs());
1032          Notify->OnStatus("Calculating visualization map ... ");
1033          VizMapFrame = TVizMapFactory::DocLsiMds(BowDocWgtBs, SemSpace,
1034              TVec<TFltV>(), 0.93 * SvdThreshold, 5000, 500, 0.0001, Notify);
1035          Notify->OnStatus("Adding metadata ... ");
1036          TVizMapFactory::AddDocMetadata(VizMapFrame,
1037              KeyWdBowDocBs, KeyWdBowDocBs, KeyWdBowDocWgtBs);
1038          Notify->OnStatus("Calculating background landscapes ... ");
1039          if (CalcLandscapeP && KeyWdBowDocBs->IsCats()) {
1040              VizMapFrame->AddLandscape(400, 400, 0.02, LndPointWgt);
1041          } else if (CalcLandscapeP) {
1042              VizMapFrame->AddLandscape(400, 400, 0.02, LndPointWgt);
1043          }
1044      } else {
1045          Notify->OnStatus("Using large-scale pipeline ...");
1046          PBowSim BowSim = TBowSim::New(bstCos);
1047          TRnd Rnd(1);
1048          PBowDocPart BowDocPart = TBowClust::GetKMeansPartForDocWgtBs(
1049              Notify, BowDocWgtBs, BowDocBs, BowSim, Rnd, Clusts, 1, 10, 1);
1050          Notify->OnStatus("Calculating LSI ...");
1051          const int LndMrks = BowDocPart->GetClusts();
1052          TVec<PBowSpV> LndMrkSpV(LndMrks, 0);
1053          for (int LndMrkN = 0; LndMrkN < LndMrks; LndMrkN++) {
1054              LndMrkSpV.Add(BowDocPart->GetClust(LndMrkN)->GetConceptSpV()); }
1055          PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(LndMrkSpV, LndMrks-1);
1056          Notify->OnStatus("Calculating visualization map ... ");
1057          VizMapFrame = TVizMapFactory::ClustLsiMdsDocLndMrk(BowDocWgtBs, BowDocPart,
1058              SemSpace, 3, SvdThreshold, 5000, 500, 0.0001, Notify);
1059          Notify->OnStatus("Adding metadata ... ");
1060          TVizMapFactory::AddDocMetadata(VizMapFrame,
1061              KeyWdBowDocBs, KeyWdBowDocBs, KeyWdBowDocWgtBs);
1062          Notify->OnStatus("Calculating background landscapes ... ");
1063          double BellSize = 0.02;
1064          if (BowDocBs->GetDocs() > 1500) BellSize *= 0.7;
1065          if (BowDocBs->GetDocs() > 2000) BellSize *= 0.7;
1066          if (BowDocBs->GetDocs() > 3000) BellSize *= 0.5;
1067          if (BowDocBs->GetDocs() > 4000) BellSize *= 0.5;
1068          if (CalcLandscapeP && KeyWdBowDocBs->IsCats()) {
1069              VizMapFrame->AddLandscape(400, 400, BellSize, LndPointWgt);
1070          } else if (CalcLandscapeP) {
1071              VizMapFrame->AddLandscape(400, 400, BellSize, LndPointWgt);
1072          }
1073      }
1074      Notify->OnStatus("Done ... ");
1075      return VizMapFrame;
1076  }
1077  PVizMapFrame TVizMapFactory::NewVizMapFrame(PBowDocBs BowDocBs, const int& ThDocs,
1078          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1079          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1080      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF);
1081      return NewVizMapFrame(BowDocBs, BowDocWgtBs, BowDocBs, BowDocWgtBs,
1082          ThDocs, Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1083  }
1084  PVizMapFrame TVizMapFactory::NewVizMapFrameFromLndMrk(PBowDocBs BowDocBs,
1085          PBowDocWgtBs BowDocWgtBs, PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP,
1086          const bool& LndMrkKeyWdP, const PNotify& Notify) { 
1087      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocWgtBs->GetDocs()));
1088      Notify->OnStatus("Calculating visualization map ... ");
1089      const TBowSpVV& LndMrkSpVV = VizMapLndMrk->GetLndMrkSpVV();
1090      const TVec<TFltV>& LndMrkPointVV = VizMapLndMrk->GetLndMrkPointVV();
1091      PVizMapFrame VizMapFrame = DocLndMrk(BowDocWgtBs,
1092          LndMrkSpVV, LndMrkPointVV, 20, Notify);
1093      Notify->OnStatus("Adding metadata ... ");
1094      if (LndMrkKeyWdP) {
1095          AddDocMetadata(VizMapFrame, BowDocBs, VizMapLndMrk->GetBowDocBs(),
1096              VizMapLndMrk->GetBowDocWgtBs(), VizMapLndMrk);
1097      } else {
1098          AddDocMetadata(VizMapFrame, BowDocBs, BowDocBs, BowDocWgtBs);
1099      }
1100      Notify->OnStatus("Calculating background landscapes ... ");
1101      double BellSize = 0.02;
1102      if (BowDocBs->GetDocs() > 1500) BellSize *= 0.7;
1103      if (BowDocBs->GetDocs() > 2000) BellSize *= 0.7;
1104      if (BowDocBs->GetDocs() > 3000) BellSize *= 0.5;
1105      if (BowDocBs->GetDocs() > 4000) BellSize *= 0.5;
1106      if (!LndMrkLndP && BowDocBs->IsCats()) {
1107          VizMapFrame->AddLandscape(400, 400, BellSize, false);
1108      } else if (!LndMrkLndP) {
1109          VizMapFrame->AddLandscape(400, 400, BellSize, false);
1110      } else {
1111          VizMapFrame->AddLandscapeFromLndMrk(400, 400, BellSize, LndMrkPointVV);
1112      }
1113      Notify->OnStatus("Done ... ");
1114      return VizMapFrame;
1115  }
1116  PVizMap TVizMapFactory::NewVizMap(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1117          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs,
1118          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1119          const bool& LndPointWgtP, const bool& CalcLandscapeP) {
1120      return TVizMap::New(NewVizMapFrame(BowDocBs, BowDocWgtBs, KeyWdBowDocBs,
1121          KeyWdBowDocWgtBs, ThDocs, Clusts, SvdThreshold, Notify, LndPointWgtP,
1122          CalcLandscapeP));
1123  }
1124  PVizMap TVizMapFactory::NewVizMap(PBowDocBs BowDocBs, const int& ThDocs,
1125          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1126          const bool& LndPointWgtP, const bool& CalcLandscapeP) {
1127      return TVizMap::New(NewVizMapFrame(BowDocBs, ThDocs, Clusts,
1128          SvdThreshold, Notify, LndPointWgtP, CalcLandscapeP));
1129  }
1130  PVizMap TVizMapFactory::NewVizMapStaticDoc(const PVizMapXmlDocBs& XmlDocBs,
1131          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1132          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1133          const bool& CalcLandscapeP) {
1134      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1135      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1136      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1137          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1138          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs);
1139          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1140      }
1141      return NewVizMap(BowDocBs, ThDocs, Clusts, SvdThreshold,
1142          Notify, LndPointWgt, CalcLandscapeP);
1143  }
1144  PVizMap TVizMapFactory::NewVizMapDynamicDoc(const PVizMapXmlDocBs& XmlDocBs,
1145          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1146          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1147          const bool& CalcLandscapeP) {
1148      TIntStrH FrameSortNToNmH; TIntIntVH FrameSortNToDIdVH;
1149      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1150      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1151      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1152          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1153          const int FrameSortN = XmlDoc.FrameSortN;
1154          const TStr& FrameNm = XmlDoc.FrameNm;
1155          if (FrameSortNToNmH.IsKey(FrameSortN)) {
1156              IAssertR(FrameSortNToNmH.GetDat(FrameSortN) == FrameNm,
1157                  FrameSortNToNmH.GetDat(FrameSortN) + " != " + FrameNm);
1158          } else {
1159              FrameSortNToNmH.AddDat(FrameSortN, FrameNm);
1160          }
1161          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs);
1162          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1163          FrameSortNToDIdVH.AddDat(FrameSortN).Add(DId);
1164      }
1165      FrameSortNToNmH.SortByKey();
1166      PVizMapLndMrk VizMapLndMrk = TVizMapFactory::NewVizMapLndMrk(
1167          BowDocBs, TIntV(), ThDocs, Clusts, SvdThreshold, Notify);
1168      PVizMap VizMap = TVizMap::New();
1169      Notify->OnStatus(TStr::Fmt("Processing %d frames ... ", FrameSortNToNmH.Len()));
1170      int FrameKeyId = FrameSortNToNmH.FFirstKeyId();
1171      while (FrameSortNToNmH.FNextKeyId(FrameKeyId)) {
1172          const int FrameSortN = FrameSortNToNmH.GetKey(FrameKeyId);
1173          const TIntV& FrameDIdV = FrameSortNToDIdVH.GetDat(FrameSortN);
1174          Notify->OnStatus(TStr::Fmt("Frame %d/%d (%d)... ",
1175              FrameKeyId+1, FrameSortNToNmH.Len(), FrameDIdV.Len()));
1176          PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1177              BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, FrameDIdV);
1178          PVizMapFrame VizMapFrame = NewVizMapFrameFromLndMrk(BowDocBs,
1179              BowDocWgtBs, VizMapLndMrk, false, false, Notify);
1180          Notify->OnStatus("Adding metadata ... ");
1181          VizMapFrame->PutFrameNm(FrameSortNToNmH.GetDat(FrameSortN));
1182          VizMap->AddVizMapFrame(VizMapFrame, true);
1183      }
1184      Notify->OnStatus("Done");
1185      return VizMap;
1186  }
1187  PVizMap TVizMapFactory::NewVizMapStaticAuthor(const PVizMapXmlDocBs& XmlDocBs,
1188          PSwSet SwSet, PStemmer Stemmer, const int& MxAuthors, const int& ThDocs,
1189          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1190          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1191      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1192      TIntH AuthorIdToFqH;
1193      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1194          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1195          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1196              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1197              AuthorIdToFqH.AddDat(AuthorId)++;
1198          }
1199      }
1200      IAssert(!AuthorIdToFqH.Empty()); AuthorIdToFqH.SortByDat(false);
1201      TIntH FqAuthorIdH;
1202      int AuthorKeyId = AuthorIdToFqH.FFirstKeyId();
1203      while (AuthorIdToFqH.FNextKeyId(AuthorKeyId)) {
1204          if (FqAuthorIdH.Len() == MxAuthors) { break; }
1205          const int AuthorId = AuthorIdToFqH.GetKey(AuthorKeyId);
1206          FqAuthorIdH.AddKey(AuthorId);
1207      }
1208      THash<TInt, TChA> AuthorIdToBodyH, AuthorIdToDisplayBodyH;
1209      TIntStrVH AuthorIdToCatNmVH;
1210      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1211          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1212          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1213              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1214              if (!FqAuthorIdH.IsKey(AuthorId)) { continue; }
1215              AuthorIdToBodyH.AddDat(AuthorId) += XmlDoc.Nm + " -- " + XmlDoc.Body + "\r\n";
1216              TStr DisplayBody = XmlDoc.DisplayBody.Empty() ? XmlDoc.Body : XmlDoc.DisplayBody;
1217              AuthorIdToDisplayBodyH.AddDat(AuthorId) += XmlDoc.Nm + " -- " + DisplayBody + "\r\n";
1218              for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
1219                  const int CatId = XmlDoc.CatIdV[CatIdN];
1220                  AuthorIdToCatNmVH.AddDat(AuthorId).Add(
1221                      XmlDocBs->CatNmH.GetKey(CatId));
1222              }
1223          }
1224      }
1225      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1226      TIntH AuthorIdToDIdH; TIntV AuthorDIdV;
1227      AuthorKeyId = AuthorIdToBodyH.FFirstKeyId();
1228      while (AuthorIdToBodyH.FNextKeyId(AuthorKeyId)) {
1229          const int AuthorId = AuthorIdToBodyH.GetKey(AuthorKeyId);
1230          TStr DocNm = XmlDocBs->AuthorNmH.GetKey(AuthorId);
1231          TStr DocBody = AuthorIdToBodyH.GetDat(AuthorId);
1232          const TStrV& CatNmV = AuthorIdToCatNmVH.AddDat(AuthorId);
1233          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, false);
1234          AuthorDIdV.Add(DId);
1235          BowDocBs->PutDocStr(DId, AuthorIdToDisplayBodyH.GetDat(AuthorId));
1236          AuthorIdToDIdH.AddDat(AuthorId, DId);
1237      }
1238      PVizMapFrame VizMapFrame = NewVizMapFrame(BowDocBs, 300, 200, 0.8, Notify, false, true);
1239      const int MxAuthorFq = AuthorIdToFqH[0];
1240      AuthorKeyId = AuthorIdToDIdH.FFirstKeyId();
1241      while (AuthorIdToDIdH.FNextKeyId(AuthorKeyId)) {
1242          const int AuthorId = AuthorIdToDIdH.GetKey(AuthorKeyId);
1243          const int AuthorDId = AuthorIdToDIdH[AuthorKeyId];
1244          const int AuthorFq = AuthorIdToFqH.GetDat(AuthorId);
1245          const double AuthorWgt = double(AuthorFq) / double(MxAuthorFq);
1246          const int PointN = VizMapFrame->GetPointN(AuthorDId);
1247          VizMapFrame->GetPoint(PointN)->PutWgt(AuthorWgt);
1248      }
1249      return TVizMap::New(VizMapFrame);
1250  }
1251  PVizMap TVizMapFactory::NewVizMapDynamicAuthor(const PVizMapXmlDocBs& XmlDocBs,
1252          PSwSet SwSet, PStemmer Stemmer, const int& MxFrames,
1253          const int& MxAuthors, const int& ThDocs,
1254          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1255          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1256      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1257      TIntH AuthorIdToFqH;
1258      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1259          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1260          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1261              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1262              AuthorIdToFqH.AddDat(AuthorId)++;
1263          }
1264      }
1265      IAssert(!AuthorIdToFqH.Empty()); AuthorIdToFqH.SortByDat(false);
1266      TIntH FqAuthorIdH;
1267      int AuthorKeyId = AuthorIdToFqH.FFirstKeyId();
1268      while (AuthorIdToFqH.FNextKeyId(AuthorKeyId)) {
1269          if (FqAuthorIdH.Len() == MxAuthors) { break; }
1270          const int AuthorId = AuthorIdToFqH.GetKey(AuthorKeyId);
1271          FqAuthorIdH.AddKey(AuthorId);
1272      }
1273      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1274      TIntStrH FrameSortNToNmH; TIntIntHH FrameSortNToAuthorIdHH;
1275      THash<TIntPr, TChA> FrameAuthorIdToBodyH, FrameAuthorIdToDisplayBodyH;
1276      TIntPrStrVH FrameAuthorIdToCatNmVH; TIntV DocDIdV;
1277      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1278          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1279          const int FrameSortN = XmlDoc.FrameSortN;
1280          const TStr& FrameNm = XmlDoc.FrameNm;
1281          if (FrameSortNToNmH.IsKey(FrameSortN)) {
1282              IAssertR(FrameSortNToNmH.GetDat(FrameSortN) == FrameNm,
1283                  FrameSortNToNmH.GetDat(FrameSortN) + " != " + FrameNm);
1284          } else {
1285              FrameSortNToNmH.AddDat(FrameSortN, FrameNm);
1286          }
1287          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1288              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1289              if (!FqAuthorIdH.IsKey(AuthorId)) { continue; }
1290              TIntPr FrameAuthorId(FrameSortN, AuthorId);
1291              FrameSortNToAuthorIdHH.AddDat(FrameSortN).AddDat(AuthorId)++;
1292              FrameAuthorIdToBodyH.AddDat(FrameAuthorId) +=
1293                  XmlDoc.Nm + " -- " + XmlDoc.Body + "\r\n";
1294              TStr DisplayBody = XmlDoc.DisplayBody.Empty() ?
1295                  XmlDoc.Body : XmlDoc.DisplayBody;
1296              FrameAuthorIdToDisplayBodyH.AddDat(FrameAuthorId) +=
1297                  XmlDoc.Nm + " -- " + DisplayBody + "\r\n";
1298              for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
1299                  const int CatId = XmlDoc.CatIdV[CatIdN];
1300                  FrameAuthorIdToCatNmVH.AddDat(FrameAuthorId).Add(
1301                      XmlDocBs->CatNmH.GetKey(CatId));
1302              }
1303          }
1304          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs); DocDIdV.Add(DId);
1305          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1306      }
1307      FrameSortNToNmH.SortByKey();
1308      TIntPrIntH FrameAuthorIdToDIdH; TIntIntVH FrameToDIdVH;
1309      int FrameAuthorKeyId = FrameAuthorIdToBodyH.FFirstKeyId();
1310      while (FrameAuthorIdToBodyH.FNextKeyId(FrameAuthorKeyId)) {
1311          const TIntPr& FrameAuthorId = FrameAuthorIdToBodyH.GetKey(FrameAuthorKeyId);
1312          const int FrameSortN = FrameAuthorId.Val1;
1313          const int AuthorId = FrameAuthorId.Val2;
1314          TStr DocNm = TStr::Fmt("%s [[%d]]",
1315              XmlDocBs->AuthorNmH.GetKey(AuthorId).CStr(), FrameSortN);
1316          TStr DocBody = FrameAuthorIdToBodyH.GetDat(FrameAuthorId);
1317          const TStrV& CatNmV = FrameAuthorIdToCatNmVH.GetDat(FrameAuthorId);
1318          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, false);
1319          BowDocBs->PutDocStr(DId, FrameAuthorIdToDisplayBodyH.GetDat(FrameAuthorId));
1320          FrameAuthorIdToDIdH.AddDat(FrameAuthorId, DId);
1321          FrameToDIdVH.AddDat(FrameSortN).Add(DId);
1322      }
1323      PVizMapLndMrk VizMapLndMrk = TVizMapFactory::NewVizMapLndMrk(
1324          BowDocBs, DocDIdV, ThDocs, Clusts, SvdThreshold, Notify);
1325      PVizMap VizMap = TVizMap::New();
1326      Notify->OnStatus(TStr::Fmt("Processing %d frames ... ", FrameSortNToNmH.Len()));
1327      int FrameKeyId = FrameSortNToNmH.FFirstKeyId();
1328      while (FrameSortNToNmH.FNextKeyId(FrameKeyId)) {
1329          const int FrameSortN = FrameSortNToNmH.GetKey(FrameKeyId);
1330          Notify->OnStatus(TStr::Fmt("Frame %d/%d... ",
1331              FrameKeyId+1, FrameSortNToNmH.Len()));
1332          const TIntV& FrameDIdV = FrameToDIdVH.GetDat(FrameSortN);
1333          PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1334              BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, FrameDIdV);
1335          PVizMapFrame VizMapFrame = NewVizMapFrameFromLndMrk(BowDocBs,
1336              BowDocWgtBs, VizMapLndMrk, false, false, Notify);
1337          Notify->OnStatus("Adding metadata ... ");
1338          VizMapFrame->PutFrameNm(FrameSortNToNmH.GetDat(FrameSortN));
1339          const TIntH& AuthorIdH = FrameSortNToAuthorIdHH.GetDat(FrameSortN);
1340          int MxAuthorFq = 1, AuthorKeyId = AuthorIdH.FFirstKeyId();
1341          while (AuthorIdH.FNextKeyId(AuthorKeyId)) {
1342              MxAuthorFq = TInt::GetMx(MxAuthorFq, AuthorIdH[AuthorKeyId]); }
1343          AuthorKeyId = AuthorIdH.FFirstKeyId();
1344          while (AuthorIdH.FNextKeyId(AuthorKeyId)) {
1345              const int AuthorId = AuthorIdH.GetKey(AuthorKeyId);
1346              const int AuthorDId = FrameAuthorIdToDIdH.GetDat(TIntPr(FrameSortN, AuthorId));
1347              const int PointN = VizMapFrame->GetPointN(AuthorDId);
1348              const int AuthorFq = AuthorIdH[AuthorKeyId];
1349              const double AuthorWgt = double(AuthorFq) / double(MxAuthorFq);
1350              VizMapFrame->GetPoint(PointN)->PutWgt(AuthorWgt);
1351          }
1352          VizMap->AddVizMapFrame(VizMapFrame, true);
1353      }
1354      Notify->OnStatus("Done");
1355      return VizMap;
1356  }
1357  PVizMap TVizMapFactory::NewVizMap(const PVizMapXmlDocBs& XmlDocBs,
1358          const TVizXmlMapType& VizXmlMapType, PSwSet SwSet, PStemmer Stemmer,
1359          const int& ThDocs, const int& Clusts, const double& SvdThreshold,
1360          const PNotify& Notify, const bool& LndPointWgt, const bool& CalcLandscapeP) {
1361      if (VizXmlMapType == vxmtStaticDoc) {
1362          return NewVizMapStaticDoc(XmlDocBs, SwSet, Stemmer, ThDocs,
1363              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1364      } else if (VizXmlMapType == vxmtDynamicAuthor) {
1365          return NewVizMapDynamicDoc(XmlDocBs, SwSet, Stemmer, ThDocs,
1366              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1367      } else if (VizXmlMapType == vxmtStaticAuthor) {
1368          return NewVizMapStaticAuthor(XmlDocBs, SwSet, Stemmer, -1, ThDocs,
1369              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1370      } else if (VizXmlMapType == vxmtDynamicAuthor) {
1371          return NewVizMapDynamicAuthor(XmlDocBs, SwSet, Stemmer, -1, -1, ThDocs,
1372              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1373      }
1374      Fail; return NULL;
1375  }
1376  PVizMap TVizMapFactory::NewVizMap(const TStr& XmlFNm, const TVizXmlMapType& VizXmlMapType,
1377          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1378          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1379          const bool& CalcLandscapeP) {
1380      PVizMapXmlDocBs XmlDocBs = TVizMapXmlDocBs::New(XmlFNm, Notify);
1381      return NewVizMap(XmlDocBs, VizXmlMapType, SwSet, Stemmer,
1382          ThDocs, Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1383  }
1384  PVizMapLndMrk TVizMapFactory::NewVizMapLndMrk(PBowDocBs BowDocBs,
1385          PBowDocWgtBs BowDocWgtBs, const int& ThDocs, const int& Clusts,
1386          const double& SvdThreshold, const PNotify& Notify) {
1387      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocWgtBs->GetDocs()));
1388      TVec<PBowSpV> LndMrkSpV;
1389      if (BowDocWgtBs->GetDocs() < ThDocs) {
1390          const int Docs = BowDocWgtBs->GetDocs();
1391          LndMrkSpV.Gen(Docs, 0);
1392          for (int DIdN = 0; DIdN < Docs; DIdN++) {
1393              const int DId = BowDocWgtBs->GetDId(DIdN);
1394              PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
1395              LndMrkSpV.Add(DocSpV);
1396          }
1397      } else {
1398          Notify->OnStatus("Using large-scale pipeline ...");
1399          PBowSim BowSim = TBowSim::New(bstCos);
1400          TRnd Rnd(1);
1401          PBowDocPart BowDocPart = TBowClust::GetKMeansPartForDocWgtBs(
1402              Notify, BowDocWgtBs, BowDocBs, BowSim, Rnd, Clusts, 1, 10, 1);
1403          const int Clusts = BowDocPart->GetClusts();
1404          LndMrkSpV.Gen(Clusts, 0);
1405          for (int ClustN = 0; ClustN < Clusts; ClustN++) {
1406              LndMrkSpV.Add(BowDocPart->GetClust(ClustN)->GetConceptSpV()); }
1407      }
1408      const int LndMrks = LndMrkSpV.Len();
1409      Notify->OnStatus(TStr::Fmt("Calculating LSI on %d landmarks ...", LndMrks));
1410      PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(LndMrkSpV, LndMrks-1);
1411      Notify->OnStatus("Calculating LndMrk map ... ");
1412      TVec<TFltV> LndMrkPointV;
1413      LsiMds(LndMrkSpV, SemSpace, LndMrkPointV, SvdThreshold, 5000, 500, 0.0001, Notify);
1414      Notify->OnStatus("Done ... ");
1415      return TVizMapLndMrk::New(BowDocBs, BowDocWgtBs, LndMrkSpV, LndMrkPointV);
1416  }
1417  PVizMapLndMrk TVizMapFactory::NewVizMapLndMrk(PBowDocBs BowDocBs,
1418          const TIntV& DIdV, const int& ThDocs, const int& Clusts,
1419          const double& SvdThreshold, const PNotify& Notify) {
1420      TIntV NewDIdV;
1421      if (DIdV.Empty()) { BowDocBs->GetAllDIdV(NewDIdV); } else { NewDIdV = DIdV; }
1422      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, NewDIdV);
1423      return NewVizMapLndMrk(BowDocBs, BowDocWgtBs, ThDocs, Clusts, SvdThreshold, Notify);
1424  }
1425  PVizMap TVizMapFactory::NewVizMapFromLndMrk(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1426          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP, const bool& LndMrkKeyWdP,
1427          const PNotify& Notify) {
1428      return TVizMap::New(NewVizMapFrameFromLndMrk(BowDocBs, BowDocWgtBs,
1429          VizMapLndMrk, LndMrkLndP, LndMrkKeyWdP, Notify));
1430  }
1431  PVizMap TVizMapFactory::NewVizMapFromLndMrk(PBowDocBs BowDocBs, const TIntV& DIdV,
1432          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP, const bool& LndMrkKeyWdP,
1433          const TBowWordWgtType& WgtType, const PNotify& Notify) {
1434      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, WgtType, 0, 0, DIdV);
1435      return TVizMap::New(NewVizMapFrameFromLndMrk(BowDocBs, BowDocWgtBs,
1436          VizMapLndMrk, LndMrkLndP, LndMrkKeyWdP, Notify));
1437  }
1438  void TVrml::InsertHeader(PSOut SOut, const TStr& SkyColor) {
1439      SOut->PutStrLn("#VRML V2.0 utf8");
1440      SOut->PutStrLn("WorldInfo {");
1441      SOut->PutStrLn("  title \"Semantic Wonderland\"");
1442      SOut->PutStrLn("  info [\"Spluf\"]");
1443      SOut->PutStrLn("}");
1444      SOut->PutStrLn("Background {");
1445      SOut->PutStrLn("  skyColor [0 0 0 , " + SkyColor + "]");
1446      SOut->PutStrLn("  skyAngle [3.14]");
1447      SOut->PutStrLn("}");
1448      SOut->PutStrLn("PointLight {");
1449      SOut->PutStrLn("  location 0 3.5 1");
1450      SOut->PutStrLn("}");
1451  }
1452  double TVrml::InsertEvelationGrid(PSOut SOut, const TSFltVV& Rlf,
1453          TFltVV& NewRlf, const TStr& TerrainColor, const int& N,
1454          const double& Height, const double& Spacing) {
1455      NewRlf.Gen(Rlf.GetXDim()/N, Rlf.GetYDim()/N);
1456      NewRlf.PutAll(0.0);
1457      for (int x = 0; x < Rlf.GetXDim(); x++) {
1458          for (int y = 0; y < Rlf.GetYDim(); y++) {
1459              NewRlf(x/N,y/N) += double(Rlf(x,y));
1460          }
1461      }
1462      SOut->PutStrLn("Transform {");
1463      SOut->PutStrLn("   translation 0 0 0");
1464      SOut->PutStrLn("   children [");
1465      SOut->PutStrLn("      Shape {");
1466      SOut->PutStrLn("         appearance Appearance {");
1467      SOut->PutStrLn("            material Material {");
1468      SOut->PutStrLn("               diffuseColor " + TerrainColor);
1469      SOut->PutStrLn("            }");
1470      SOut->PutStrLn("         }");
1471      SOut->PutStrLn("         geometry ElevationGrid {");
1472      SOut->PutStrLn("            xDimension " + TInt::GetStr(NewRlf.GetXDim()));
1473      SOut->PutStrLn("            zDimension " + TInt::GetStr(NewRlf.GetYDim()));
1474      SOut->PutStrLn(TStr::Fmt("            xSpacing %.2f", Spacing));
1475      SOut->PutStrLn(TStr::Fmt("            zSpacing %.2f", Spacing));
1476      SOut->PutStrLn("            height [");
1477      for (int x = 0; x < NewRlf.GetXDim(); x++) {
1478          for (int y = 0; y < NewRlf.GetYDim(); y++) {
1479              IAssertR(NewRlf(x,y) <= N*N, TStr::Fmt("%d:%d:%g", x, y, NewRlf(x,y)()));
1480              NewRlf(x,y) = Height * NewRlf(x,y)/(N*N);
1481              SOut->PutStr(TStr::Fmt("%.4f ", NewRlf(x,y)()));
1482          }
1483          SOut->PutLn();
1484      }
1485      SOut->PutStrLn("            ]");
1486      SOut->PutStrLn("         }");
1487      SOut->PutStrLn("      }");
1488      SOut->PutStrLn("   ]");
1489      SOut->PutStrLn("}");
1490      return NewRlf.GetXDim() * Spacing;
1491  }
1492  void TVrml::InsertBillboard(PSOut SOut, const TFltVV& Rlf,
1493          const TStr& Text, const TStr& Color, const TStr& Size,
1494          const double& x, const double& y, const double& Height,
1495          const double& Scale, bool DoText, bool DoPoint) {
1496      const double Spacing = Scale / Rlf.GetXDim();
1497      int PosX = TFlt::Round(Scale*x/Spacing);
1498      int PosY = TFlt::Round(Scale*y/Spacing);
1499      if (PosX < 0) PosX = 0; if (PosY < 0) PosY = 0;
1500      if (PosX >= Rlf.GetXDim()) PosX = Rlf.GetXDim() - 1;
1501      if (PosY >= Rlf.GetYDim()) PosY = Rlf.GetYDim() - 1;
1502      const double z = Rlf(PosX, PosY) + Height;
1503      if (DoText) {
1504          SOut->PutStrLn("Transform {");
1505          SOut->PutStrLn(TStr::Fmt("  translation %.3f %.3f %.3f", Scale*y, z, Scale*x));
1506          SOut->PutStrLn("  scale " + Size);
1507          SOut->PutStrLn("  children Billboard {");
1508        SOut->PutStrLn("  axisOfRotation 0 0 0");
1509        SOut->PutStrLn("  children [");
1510          SOut->PutStrLn("    Shape {");
1511          SOut->PutStrLn("      appearance Appearance { material Material {");
1512          SOut->PutStrLn("                 diffuseColor " + Color + " } }");
1513          SOut->PutStrLn("      geometry Text { fontStyle FontStyle {justify \"MIDDLE\"} string \"" + Text + "\" }");
1514          SOut->PutStrLn("     }]");
1515          SOut->PutStrLn("  }");
1516          SOut->PutStrLn("}");
1517      }
1518      if (DoPoint) {
1519          SOut->PutStrLn("Anchor {");
1520          SOut->PutStrLn("  children [");
1521          SOut->PutStrLn("    Transform {");
1522          SOut->PutStrLn(TStr::Fmt("      translation %.3f %.3f %.3f", Scale*y, z - 0.95*Height, Scale*x));
1523          SOut->PutStrLn("      rotation 0 0 1 0");
1524          SOut->PutStrLn("      children Shape {");
1525          SOut->PutStrLn("        appearance Appearance { material Material { diffuseColor " + Color + "  } }");
1526          SOut->PutStrLn("        geometry Sphere { radius 0.1 }");
1527          SOut->PutStrLn("      }                                     ");
1528          SOut->PutStrLn("    }");
1529          SOut->PutStrLn("  ]");
1530          SOut->PutStrLn("  description \"" + Text + "\"");
1531          SOut->PutStrLn("}");
1532      }
1533  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ctc.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.cpp</div>
                <div class="column column_space"><pre><code>199    if (ln_x >= ln_y) {
200      return ln_x + log1p(exp(ln_y - ln_x));
201    } else {
202      return ln_y + log1p(exp(ln_x - ln_y));
203    }
204  }
205  void CTC::Forward(GENERIC_2D_ARRAY<double> *log_probs) const {
</pre></code></div>
                <div class="column column_space"><pre><code>361      if (UrlStr.SearchStr(":&bsol;&bsol;") != -1) { return UrlStr; }
362      else { return ""; }
363  }
364  int TVizMapFrame::GenKeyWd(const TFltV& CoordV, const double& Radius,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    