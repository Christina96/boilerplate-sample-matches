
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.197183098591549%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-validator.cpp</h3>
            <pre><code>1  #include "validator.h"
2  #include <algorithm>
3  #include <iterator>
4  #include <unordered_map>
5  #include <vector>
6  #include "icuerrorcode.h"
7  #include "unicode/uchar.h"   
8  #include "unicode/uscript.h" 
9  #include "validate_grapheme.h"
10  #include "validate_indic.h"
11  #include "validate_javanese.h"
12  #include "validate_khmer.h"
13  #include "validate_myanmar.h"
14  namespace tesseract {
15  const char32 Validator::kZeroWidthSpace = 0x200B;
16  const char32 Validator::kZeroWidthNonJoiner = 0x200C;
17  const char32 Validator::kZeroWidthJoiner = 0x200D;
18  const char32 Validator::kLeftToRightMark = 0x200E;
19  const char32 Validator::kRightToLeftMark = 0x200F;
20  const char32 Validator::kInvalid = 0xfffd;
21  Validator::~Validator() = default;
22  bool Validator::ValidateCleanAndSegment(GraphemeNormMode g_mode, bool report_errors,
23                                          const std::vector<char32> &src,
24                                          std::vector<std::vector<char32>> *dest) {
25    ValidateGrapheme g_validator(ViramaScript::kNonVirama, report_errors);
26    std::vector<std::vector<char32>> graphemes;
27    ViramaScript script = MostFrequentViramaScript(src);
28    bool success = true;
<span onclick='openModal()' class='match'>29    if (script == ViramaScript::kNonVirama) {
30      if (g_mode == GraphemeNormMode::kCombined) {
31        g_mode = GraphemeNormMode::kGlyphSplit;
32      } else if (g_mode == GraphemeNormMode::kGlyphSplit) {
33        g_mode = GraphemeNormMode::kIndividualUnicodes;
34      }
</span>35      success = g_validator.ValidateCleanAndSegmentInternal(g_mode, src, dest);
36    } else {
37      success =
38          g_validator.ValidateCleanAndSegmentInternal(GraphemeNormMode::kGlyphSplit, src, &graphemes);
39      std::unique_ptr<Validator> validator(ScriptValidator(script, report_errors));
40      for (const auto &grapheme : graphemes) {
41        if (!validator->ValidateCleanAndSegmentInternal(g_mode, grapheme, dest)) {
42          success = false;
43        }
44      }
45    }
46    return success;
47  }
48  std::unique_ptr<Validator> Validator::ScriptValidator(ViramaScript script, bool report_errors) {
49    switch (script) {
50  #define CASE(e, T) case ViramaScript::e: return std::make_unique<T>(script, report_errors)
51      CASE(kNonVirama, ValidateGrapheme);
52      CASE(kJavanese, ValidateJavanese);
53      CASE(kMyanmar, ValidateMyanmar);
54      CASE(kKhmer, ValidateKhmer);
55  #undef CASE
56      default:
57        return std::make_unique<ValidateIndic>(script, report_errors);
58    }
59  }
60  bool Validator::ValidateCleanAndSegmentInternal(GraphemeNormMode g_mode,
61                                                  const std::vector<char32> &src,
62                                                  std::vector<std::vector<char32>> *dest) {
63    Clear();
64    ComputeClassCodes(src);
65    bool success = true;
66    for (codes_used_ = 0; codes_used_ < codes_.size();) {
67      if (!ConsumeGraphemeIfValid()) {
68        success = false;
69        ++codes_used_;
70      }
71    }
72    MoveResultsToDest(g_mode, dest);
73    return success;
74  }
75  void Validator::MoveResultsToDest(GraphemeNormMode g_mode, std::vector<std::vector<char32>> *dest) {
76    if (g_mode == GraphemeNormMode::kIndividualUnicodes) {
77      dest->reserve(dest->size() + output_.size());
78      for (char32 ch : output_) {
79        dest->push_back({ch});
80      }
81    } else if (g_mode == GraphemeNormMode::kGlyphSplit) {
82      std::move(parts_.begin(), parts_.end(), std::back_inserter(*dest));
83    } else if (g_mode == GraphemeNormMode::kCombined || dest->empty()) {
84      dest->push_back(std::vector<char32>());
85      output_.swap(dest->back());
86    } else { 
87      dest->back().insert(dest->back().end(), output_.begin(), output_.end());
88    }
89  }
90  static bool CmpPairSecond(const std::pair<int, int> &p1, const std::pair<int, int> &p2) {
91    return p1.second < p2.second;
92  }
93  ViramaScript Validator::MostFrequentViramaScript(const std::vector<char32> &utf32) {
94    std::unordered_map<int, int> histogram;
95    for (char32 ch : utf32) {
96      int base = ch / kIndicCodePageSize;
97      IcuErrorCode err;
98      UScriptCode script_code = uscript_getScript(ch, err);
99      if ((kMinIndicUnicode <= ch && ch <= kMaxJavaneseUnicode && script_code != USCRIPT_COMMON) ||
100          script_code == USCRIPT_MYANMAR) {
101        if (script_code == USCRIPT_MYANMAR) {
102          base = static_cast<char32>(ViramaScript::kMyanmar) / kIndicCodePageSize;
103        }
104        ++histogram[base];
105      }
106    }
107    if (!histogram.empty()) {
108      int base = std::max_element(histogram.begin(), histogram.end(), CmpPairSecond)->first;
109      auto codebase = static_cast<char32>(base * kIndicCodePageSize);
110      if (codebase == static_cast<char32>(ViramaScript::kMyanmar) ||
111          codebase == static_cast<char32>(ViramaScript::kJavanese) ||
112          codebase == static_cast<char32>(ViramaScript::kKhmer) ||
113          (static_cast<char32>(ViramaScript::kDevanagari) <= codebase &&
114           codebase <= static_cast<char32>(ViramaScript::kSinhala))) {
115        return static_cast<ViramaScript>(codebase);
116      }
117    }
118    return ViramaScript::kNonVirama;
119  }
120  bool Validator::IsVirama(char32 unicode) {
121    return (kMinIndicUnicode <= unicode && unicode <= kMaxSinhalaUnicode &&
122            (unicode & 0x7f) == 0x4d) ||
123           unicode == kSinhalaVirama || unicode == kJavaneseVirama || unicode == kMyanmarVirama ||
124           unicode == kKhmerVirama;
125  }
126  bool Validator::IsVedicAccent(char32 unicode) {
127    return (0x1cd0 <= unicode && unicode < 0x1d00) || (0xa8e0 <= unicode && unicode <= 0xa8f7) ||
128           (0x951 <= unicode && unicode <= 0x954);
129  }
130  bool Validator::IsSubscriptScript() const {
131    return script_ == ViramaScript::kTelugu || script_ == ViramaScript::kKannada ||
132           script_ == ViramaScript::kJavanese || script_ == ViramaScript::kMyanmar ||
133           script_ == ViramaScript::kKhmer;
134  }
135  void Validator::ComputeClassCodes(const std::vector<char32> &text) {
136    codes_.reserve(text.size());
137    for (char32 c : text) {
138      codes_.emplace_back(UnicodeToCharClass(c), c);
139    }
140  }
141  void Validator::Clear() {
142    codes_.clear();
143    parts_.clear();
144    output_.clear();
145    codes_used_ = 0;
146    output_used_ = 0;
147  }
148  } 
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-main.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <string>
3  #include <unistd.h>
4  #include <signal.h>
5  #include <sys/types.h>
6  #include <dirent.h>
7  #include "config/ruleset.h"
8  #include "handler/interfaces.h"
9  #include "handler/webget.h"
10  #include "handler/settings.h"
11  #include "script/cron.h"
12  #include "server/socket.h"
13  #include "server/webserver.h"
14  #include "utils/defer.h"
15  #include "utils/file_extra.h"
16  #include "utils/logger.h"
17  #include "utils/network.h"
18  #include "utils/rapidjson_extra.h"
19  #include "utils/system.h"
20  #include "utils/urlencode.h"
21  #include "version.h"
22  WebServer webServer;
23  #ifndef _WIN32
24  void SetConsoleTitle(const std::string &title)
25  {
26      system(std::string("echo \"\\033]0;" + title + "\\007\\c\"").data());
27  }
28  #endif 
29  void setcd(std::string &file)
30  {
31      char szTemp[1024] = {}, filename[256] = {};
32      std::string path;
33  #ifdef _WIN32
34      char *pname = NULL;
35      DWORD retVal = GetFullPathName(file.data(), 1023, szTemp, &pname);
36      if(!retVal)
37          return;
38      strcpy(filename, pname);
39      strrchr(szTemp, '\\')[1] = '\0';
40  #else
41      char *ret = realpath(file.data(), szTemp);
42      if(ret == NULL)
43          return;
44      ret = strcpy(filename, strrchr(szTemp, '/') + 1);
45      if(ret == NULL)
46          return;
47      strrchr(szTemp, '/')[1] = '\0';
48  #endif 
49      file.assign(filename);
50      path.assign(szTemp);
51      chdir(path.data());
52  }
53  void chkArg(int argc, char *argv[])
54  {
55      for(int i = 1; i < argc; i++)
56      {
57          if(strcmp(argv[i], "-cfw") == 0)
58          {
59              global.CFWChildProcess = true;
60              global.updateRulesetOnRequest = true;
61          }
62          else if(strcmp(argv[i], "-f") == 0 || strcmp(argv[i], "--file") == 0)
63          {
64              if(i < argc - 1)
65                  global.prefPath.assign(argv[++i]);
66          }
67          else if(strcmp(argv[i], "-g") == 0 || strcmp(argv[i], "--gen") == 0)
68          {
69              global.generatorMode = true;
70          }
71          else if(strcmp(argv[i], "--artifact") == 0)
72          {
73              if(i < argc - 1)
74                  global.generateProfiles.assign(argv[++i]);
75          }
76          else if(strcmp(argv[i], "-l") == 0 || strcmp(argv[i], "--log") == 0)
77          {
78              if(i < argc - 1)
79                  if(freopen(argv[++i], "a", stderr) == NULL)
80                      std::cerr<<"Error redirecting output to file.\n";
81          }
82      }
83  }
84  void signal_handler(int sig)
85  {
86      writeLog(0, "Interrupt signal " + std::to_string(sig) + " received. Exiting gracefully...", LOG_LEVEL_FATAL);
87      switch(sig)
88      {
89  #ifndef _WIN32
90      case SIGHUP:
91      case SIGQUIT:
92  #endif 
93      case SIGTERM:
94      case SIGINT:
95          webServer.stop_web_server();
96          break;
97      }
98  }
99  void cron_tick_caller()
100  {
101      if(global.enableCron)
102          cron_tick();
103  }
104  int main(int argc, char *argv[])
105  {
106  #ifndef _DEBUG
107      std::string prgpath = argv[0];
108      setcd(prgpath); 
109  #endif 
110      if(fileExist("pref.toml"))
111          global.prefPath = "pref.toml";
112      else if(fileExist("pref.yml"))
113          global.prefPath = "pref.yml";
<span onclick='openModal()' class='match'>114      else if(!fileExist("pref.ini"))
115      {
116          if(fileExist("pref.example.toml"))
117          {
118              fileCopy("pref.example.toml", "pref.toml");
119              global.prefPath = "pref.toml";
120          }
121          else if(fileExist("pref.example.yml"))
122          {
123              fileCopy("pref.example.yml", "pref.yml");
124              global.prefPath = "pref.yml";
125          }
</span>126          else if(fileExist("pref.example.ini"))
127              fileCopy("pref.example.ini", "pref.ini");
128      }
129      chkArg(argc, argv);
130      setcd(global.prefPath); 
131      writeLog(0, "SubConverter " VERSION " starting up..", LOG_LEVEL_INFO);
132  #ifdef _WIN32
133      WSADATA wsaData;
134      if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)
135      {
136          writeLog(0, "WSAStartup failed.", LOG_LEVEL_FATAL);
137          return 1;
138      }
139      UINT origcp = GetConsoleOutputCP();
140      defer(SetConsoleOutputCP(origcp);)
141      SetConsoleOutputCP(65001);
142  #else
143      signal(SIGPIPE, SIG_IGN);
144      signal(SIGABRT, SIG_IGN);
145      signal(SIGHUP, signal_handler);
146      signal(SIGQUIT, signal_handler);
147  #endif 
148      signal(SIGTERM, signal_handler);
149      signal(SIGINT, signal_handler);
150      SetConsoleTitle("SubConverter " VERSION);
151      readConf();
152      if(!global.updateRulesetOnRequest)
153          refreshRulesets(global.customRulesets, global.rulesetsContent);
154      std::string env_api_mode = getEnv("API_MODE"), env_managed_prefix = getEnv("MANAGED_PREFIX"), env_token = getEnv("API_TOKEN");
155      global.APIMode = tribool().parse(toLower(env_api_mode)).get(global.APIMode);
156      if(env_managed_prefix.size())
157          global.managedConfigPrefix = env_managed_prefix;
158      if(env_token.size())
159          global.accessToken = env_token;
160      if(global.generatorMode)
161          return simpleGenerator();
162      webServer.append_response("GET", "/version", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
163      {
164          return "subconverter " VERSION " backend\n";
165      });
166      webServer.append_response("GET", "/refreshrules", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
167      {
168          if(global.accessToken.size())
169          {
170              std::string token = getUrlArg(request.argument, "token");
171              if(token != global.accessToken)
172              {
173                  response.status_code = 403;
174                  return "Forbidden\n";
175              }
176          }
177          refreshRulesets(global.customRulesets, global.rulesetsContent);
178          return "done\n";
179      });
180      webServer.append_response("GET", "/readconf", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
181      {
182          if(global.accessToken.size())
183          {
184              std::string token = getUrlArg(request.argument, "token");
185              if(token != global.accessToken)
186              {
187                  response.status_code = 403;
188                  return "Forbidden\n";
189              }
190          }
191          readConf();
192          if(!global.updateRulesetOnRequest)
193              refreshRulesets(global.customRulesets, global.rulesetsContent);
194          return "done\n";
195      });
196      webServer.append_response("POST", "/updateconf", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
197      {
198          if(global.accessToken.size())
199          {
200              std::string token = getUrlArg(request.argument, "token");
201              if(token != global.accessToken)
202              {
203                  response.status_code = 403;
204                  return "Forbidden\n";
205              }
206          }
207          std::string type = getUrlArg(request.argument, "type");
208          if(type == "form")
209              fileWrite(global.prefPath, getFormData(request.postdata), true);
210          else if(type == "direct")
211              fileWrite(global.prefPath, request.postdata, true);
212          else
213          {
214              response.status_code = 501;
215              return "Not Implemented\n";
216          }
217          readConf();
218          if(!global.updateRulesetOnRequest)
219              refreshRulesets(global.customRulesets, global.rulesetsContent);
220          return "done\n";
221      });
222      webServer.append_response("GET", "/flushcache", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
223      {
224          if(getUrlArg(request.argument, "token") != global.accessToken)
225          {
226              response.status_code = 403;
227              return "Forbidden";
228          }
229          flushCache();
230          return "done";
231      });
232      webServer.append_response("GET", "/sub", "text/plain;charset=utf-8", subconverter);
233      webServer.append_response("HEAD", "/sub", "text/plain", subconverter);
234      webServer.append_response("GET", "/sub2clashr", "text/plain;charset=utf-8", simpleToClashR);
235      webServer.append_response("GET", "/surge2clash", "text/plain;charset=utf-8", surgeConfToClash);
236      webServer.append_response("GET", "/getruleset", "text/plain;charset=utf-8", getRuleset);
237      webServer.append_response("GET", "/getprofile", "text/plain;charset=utf-8", getProfile);
238      webServer.append_response("GET", "/render", "text/plain;charset=utf-8", renderTemplate);
239      webServer.append_response("GET", "/convert", "text/plain;charset=utf-8", getConvertedRuleset);
240      if(!global.APIMode)
241      {
242          webServer.append_response("GET", "/get", "text/plain;charset=utf-8", [](RESPONSE_CALLBACK_ARGS) -> std::string
243          {
244              std::string url = urlDecode(getUrlArg(request.argument, "url"));
245              return webGet(url, "");
246          });
247          webServer.append_response("GET", "/getlocal", "text/plain;charset=utf-8", [](RESPONSE_CALLBACK_ARGS) -> std::string
248          {
249              return fileGet(urlDecode(getUrlArg(request.argument, "path")));
250          });
251      }
252      std::string env_port = getEnv("PORT");
253      if(env_port.size())
254          global.listenPort = to_int(env_port, global.listenPort);
255      listener_args args = {global.listenAddress, global.listenPort, global.maxPendingConns, global.maxConcurThreads, cron_tick_caller, 200};
256      writeLog(0, "Startup completed. Serving HTTP @ http:&bsol;&bsol;" + global.listenAddress + ":" + std::to_string(global.listenPort), LOG_LEVEL_INFO);
257      webServer.start_web_server_multi(&args);
258  #ifdef _WIN32
259      WSACleanup();
260  #endif 
261      return 0;
262  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-validator.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-main.cpp</div>
                <div class="column column_space"><pre><code>29    if (script == ViramaScript::kNonVirama) {
30      if (g_mode == GraphemeNormMode::kCombined) {
31        g_mode = GraphemeNormMode::kGlyphSplit;
32      } else if (g_mode == GraphemeNormMode::kGlyphSplit) {
33        g_mode = GraphemeNormMode::kIndividualUnicodes;
34      }
</pre></code></div>
                <div class="column column_space"><pre><code>114      else if(!fileExist("pref.ini"))
115      {
116          if(fileExist("pref.example.toml"))
117          {
118              fileCopy("pref.example.toml", "pref.toml");
119              global.prefPath = "pref.toml";
120          }
121          else if(fileExist("pref.example.yml"))
122          {
123              fileCopy("pref.example.yml", "pref.yml");
124              global.prefPath = "pref.yml";
125          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    