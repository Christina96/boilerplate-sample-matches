
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.667444574095683%, Tokens: 11</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cfyres.cpp</h3>
            <pre><code>1  TCfyRes::TCfyRes() {
2      AccMom = TMom::New(); PrecMom = TMom::New(); 
3      RecMom = TMom::New(); F1Mom = TMom::New(); 
4      BreakEvenPointMom = TMom::New(); AvgPrecMom = TMom::New();
5  }
6  TCfyRes::TCfyRes(TCountCfyRes& CfyRes) {
7      PrecMom = TMom::New(); PrecMom->Add(CfyRes.Prec()); PrecMom->Def();
8      RecMom = TMom::New(); RecMom->Add(CfyRes.Rec()); RecMom->Def();
9      F1Mom = TMom::New(); F1Mom->Add(CfyRes.F1()); F1Mom->Def();
10      AccMom = TMom::New(); AccMom->Add(CfyRes.Acc()); AccMom->Def();
11      AvgPrecMom = TMom::New(); AvgPrecMom->Add(CfyRes.AvgPrec());  AvgPrecMom->Def();
12      BreakEvenPointMom = TMom::New();
13      BreakEvenPointMom->Add(CfyRes.BreakEvenPoint());
14      BreakEvenPointMom->Def();
15  }; 
16  void TCfyRes::Add(TCfyRes& CfyRes) {
17      AccMom->Add(CfyRes.Acc()); PrecMom->Add(CfyRes.Prec());
18      RecMom->Add(CfyRes.Rec()); F1Mom->Add(CfyRes.F1());
19      BreakEvenPointMom->Add(CfyRes.BreakEvenPoint());
20      AvgPrecMom->Add(CfyRes.AvgPrec());
21  }
22  void TCfyRes::Def() {
23      AccMom->Def(); PrecMom->Def(); RecMom->Def();
24      F1Mom->Def(); BreakEvenPointMom->Def(); AvgPrecMom->Def();
25  }
26  TStr TCfyRes::GetStatStr(const TStr& Desc) {
27      TStr StatStr = Desc + ":\n";
28      StatStr += TStr::Fmt("prec: [%5.2f%%,%5.2f%%] rec: [%5.2f%%,%5.2f%%] F1:[%5.2f%%,%5.2f%%]\n",
29          100.0*Prec(), 100.0*PrecStDiv(), 100.0*Rec(), 100.0*RecStDiv(), 100.0*F1(), 100.0*F1StDiv());
30      StatStr += TStr::Fmt("acc: [%5.2f%%,%5.2f%%] avgprec: [%5.2f%%,%5.2f%%] BEP:[%5.2f%%,%5.2f%%]",
31          100.0*Acc(), 100.0*AccStDiv(), 100.0*AvgPrec(), 100.0*AvgPrecStDiv(), 100.0*BreakEvenPoint(), 100.0*BreakEvenPointStDiv());
32      return StatStr;
33  }
34  void TCfyRes::PrTabStat(const TStr& StatFNm, const TStr& Nm) {
35      PSOut SOut = TFOut::New(StatFNm);
36      PrTabHeader(SOut);
37      PrTabVals(SOut, Nm);
38  }
39  void TCfyRes::PrTabHeader(PSOut SOut) {
40      SOut->PutStr("Nm\tPrec\t\tRec\t\tF1\t\tAcc\t\tBEP\t");
41      for (int StatN = 0; StatN < GetStats(); StatN++) {
42          SOut->PutStr("\t" + GetStatNm(StatN)); }
43      SOut->PutLn();
44  }
45  void TCfyRes::PrTabVals(PSOut SOut, const TStr& Nm) {
46      SOut->PutStr(Nm + "\t");
47      SOut->PutFlt(Prec()); SOut->PutCh('\t'); SOut->PutFlt(PrecStDiv()); SOut->PutCh('\t');
48      SOut->PutFlt(Rec()); SOut->PutCh('\t'); SOut->PutFlt(RecStDiv()); SOut->PutCh('\t');
49      SOut->PutFlt(F1()); SOut->PutCh('\t'); SOut->PutFlt(F1StDiv()); SOut->PutCh('\t');
50      SOut->PutFlt(Acc()); SOut->PutCh('\t'); SOut->PutFlt(AccStDiv()); SOut->PutCh('\t');
51      SOut->PutFlt(BreakEvenPoint()); SOut->PutCh('\t'); SOut->PutFlt(BreakEvenPointStDiv()); 
52      for (int StatN = 0; StatN < GetStats(); StatN++) {
53          SOut->PutCh('\t'); SOut->PutFlt(GetStatWgt(StatN)); }    
54      SOut->PutCh('\n');
55  }
56  TCfyRes TCountCfyRes::ToMacroTCfyRes(TVec<TCountCfyRes>& CfyResV) {
57      TCfyRes CfyRes;
58      for (int CfyResN = 0; CfyResN < CfyResV.Len(); CfyResN++) {
59          CfyResV[CfyResN].PrepareResultV();
60          Fail;
61      }
62      CfyRes.Def();
63      return CfyRes;
64  }
65  void TCountCfyRes::Add(const double& PredCls, const double& TrueCls) {
66  	ResultV.Add(TFltKd(PredCls, TrueCls));
67  	ResultVSorted = false;
68  	if (TrueCls > 0.0) { 
69          if (PredCls > 0.0) { TPos++; }
70          else { FNeg++; }
71  	} else if (TrueCls < 0.0) { 
72          if (PredCls < 0.0) { TNeg++; }
73          else { FPos++; }
74      } else { Fail; }
75  }
76  double TCountCfyRes::AvgPrec() {
77  	PrepareResultV();
78      int PosN = (TPos+FNeg), PosC = 0, i = 0;
79      double ap = 0.0;
80      while (PosC < PosN) {
81          i++;
82          if (ResultV[i-1].Dat > 0.0) {
83              PosC++;
84              ap += (double)PosC/(double)i;
85          }
86      }
87      if (PosN > 0.0) { ap /= PosN; }
88      return ap;
89  }
90  double TCountCfyRes::BreakEvenPoint() {
91  	PrepareResultV();
92      const int Len = ResultV.Len();
93      int TP = 0, FP = 0, TN = FPos + TNeg, FN = TPos + FNeg;
94      double Prec = 1.0, Rec = 0.0, Diff = 1.0, BEP = 0.0; 
95      for (int i = 0; i < Len; i++) {
96          if (Diff > TFlt::Abs(Prec - Rec) && Prec != 0.0 && Rec != 0.0) {
97              Diff = TFlt::Abs(Prec - Rec);
98              BEP = (Prec + Rec)/2;
99          }
100          if (ResultV[i].Dat > 0.0) {
101              FN--; TP++;
102          } else {
103              TN--; FP++; 
104          }
105          Prec = (double)TP/(TP+FP); 
106          Rec = (double)TP/(TP+FN);
107      }
108      return BEP;
109  }
110  void TCountCfyRes::PrecRec(TFltV& PrecV, TFltV& RecV) {
111  	PrepareResultV();
112      const int Len = ResultV.Len();
113      int TP = 0, FP = 0, TN = FPos + TNeg, FN = TPos + FNeg;
114      double Prec = 1.0, Rec = 0.0; 
115      PrecV.Gen(Len+1, 0); RecV.Gen(Len+1,0);
116      PrecV.Add(Prec); RecV.Add(Rec);
<span onclick='openModal()' class='match'>117      for (int i = 0; i < Len; i++) {
118          if (ResultV[i].Dat > 0.0) { FN--; TP++; }
119          else { TN--; FP++; }
</span>120          Prec = (double)TP/(TP+FP); Rec = (double)TP/(TP+FN);
121          PrecV.Add(Prec); RecV.Add(Rec);
122      }
123  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-strkernel.cpp</h3>
            <pre><code>1  void TStrParser::DocStrToWIdV(const TStr& _DocStr, TIntV& WordIdV, const bool& Stemm) {
2      TStr DocStr = _DocStr.GetUc();  
3      TStrV WordV; DocStr.SplitOnWs(WordV); int WordN = WordV.Len();
4      WordIdV.Reserve(WordN, 0);
5      PStemmer Stemmer = TStemmer::New(stmtPorter);
6      TIntH WordsInDoc;
7      for (int WordC = 0; WordC < WordN; WordC++) {
8          TStr WordStr;
9          if (Stemm) {
10              WordStr = Stemmer->GetStem(WordV[WordC]);
11          } else {
12              WordStr = WordV[WordC];
13          }
14          int WId = GetWId(WordStr);
15          if (WId == -1) {
16              WId = WordToIdH.AddKey(WordStr);
17              WordToIdH[WId] = 0;
18          }
19          WordIdV.Add(WId);
20          if (!WordsInDoc.IsKey(WId)) WordsInDoc.AddKey(WId);
21      }
22      DocsParsed++;
23      for (int i = 0, l = WordsInDoc.Len(); i < l; i++)
24          WordToIdH[WordsInDoc.GetKey(i)]++;
25      Assert(WordV.Len() == WordIdV.Len());
26  }
27  void TStrParser::DocStrToSylIdV(const TStr& _DocStr, TIntV& SyllablesIdV) {
28      TStr DocStr = _DocStr.GetUc();  
29      Fail;
30  }
31  void TStrParser::DocStrToChIdV(const TStr& _DocStr, TIntV& ChIdV) {
32      TStr DocStr = _DocStr.GetUc();  
33      int ChN = DocStr.Len();
34      ChIdV.Reserve(ChN, 0);
35      for (int ChC = 0; ChC < ChN; ChC++) {
36          TStr ChStr = DocStr.GetSubStr(ChC,ChC);
37          int ChId = GetWId(ChStr);
38          if (ChId != -1) {
39              WordToIdH[ChId]++;
40          } else {
41              ChId = WordToIdH.AddKey(ChStr);
42              WordToIdH[ChId] = 1;
43          }
44          ChIdV.Add(ChId);
45      }
46  }
47  void TStrParser::WhoAmI(const TStr& intro) const {
48      switch (Type.Val) {
49          case 0: printf("%s: Words [AlphN = %d]\n", intro.CStr(), GetAlphabetSize()); break;
50          case 1: printf("%s: Syllabels  [AlphN = %d]\n", intro.CStr(), GetAlphabetSize()); break;
51          case 2: 
52              printf("%s: Chararcters [AlphN = %d]\n", intro.CStr(), GetAlphabetSize()); 
53              for (int i = 0; i < WordToIdH.Len(); i++) {
54                  printf("[%s]  ", WordToIdH.GetKey(i).CStr());
55              }
56              printf("\n");
57              break;
58      }
59  }
60  void TStrParser::GetIDFWeightV(TFltV& WeightV) {
61      int AlphN = GetAlphabetSize();
62      WeightV.Gen(AlphN);
63      for (int AlphC = 0; AlphC < AlphN; AlphC++) 
64          WeightV[AlphC] = log((double)DocsParsed / WordToIdH[AlphC]);
65      double MaxVal = WeightV[WeightV.GetMxValN()];
66      for (int AlphC = 0; AlphC < AlphN; AlphC++) 
67          WeightV[AlphC] /= MaxVal;
68  }
69  double *TStringKernel::Buf1 = NULL; 
70  double *TStringKernel::Buf2 = NULL; 
71  int TStringKernel::BufN = 0;
72  int TStringKernel::CountEval = 0;
73  double TStringKernel::KDynamic(const TIntV& s, const TIntV& t, const TFltV& lc, const double& lb) {
74      const int k = lc.Len() + 1;
75      int x,y,i;
76      int ls = s.Len(), lt = t.Len();
77      TVec<double *> Kd(2);
78      if ((ls+1)*(lt+1) > BufN) {
79          if (Buf1 != NULL) delete[] Buf1;
80          if (Buf2 != NULL) delete[] Buf2;
81          BufN = (ls+2)*(lt+2) + 10;
82          Buf1 = new double[BufN];
83          Buf2 = new double[BufN];
84      }
85      Kd[0] = Buf1; Kd[1] = Buf2;
86      double *Kdii, *Kdi; 
87      int MxSize = (ls+1)*(lt+1) + 10;
88      for (i = 0, Kdi = Kd[0]; i < MxSize; i++) Kdi[i] = 1.0;
89      double K = 0.0; 
90      for (i = 1; i < k; i++) {
91          Kdi = Kd[i%2]; Kdii = Kd[(i-1)%2];
92          for (x = 0; x <= ls; x++) Kdi[x*(lt+1) + (i-1)] = 0.0;
93          for (y = 0; y <= lt; y++) Kdi[(i-1)*(lt+1) + y] = 0.0;
94          double Ki = 0.0;
95          for (x = i; x <= ls; x++) {
96              double Kdd = 0.0; int u = s[x-1];
<span onclick='openModal()' class='match'>97              for (y = i; y <= lt; y++) {
98                  if (u == t[y-1]) {
99                      Kdd = lb * (Kdd + lb*Kdii[(x-1)*(lt+1) + (y-1)]);
100                      Ki += lb*lb * Kdi[(x-1)*(lt+1) + (y-1)];
101                  } else {
102                      Kdd *= lb;
</span>103                  }
104                  Kdi[x*(lt+1) + y] = lb*Kdi[(x-1)*(lt+1) + y] + Kdd;
105              }
106          }
107          K += lc[i-1] * Ki;
108      }
109      return K;
110  }
111  double TStringKernel::KDynamicW(const TIntV& s, const TIntV& t, const TFltV& lc, const TFltV& wgt) {
112      int x,y,i;
113      const int k = lc.Len() + 1;
114      int ls = s.Len(), lt = t.Len();
115      TVec<TFltVV> Kd(2);
116      for (i = 0; i < 2; i++) Kd[i].Gen(ls+1, lt+1);
117      for (x = 0; x <= ls; x++) {
118          for (y = 0; y <= lt; y++) {
119              Kd[0](x,y) = 1.0;
120          }
121      }
122      double K = 0.0;
123      for (i = 1; i < k; i++) {
124          for (x = 0; x <=ls; x++) Kd[i%2](x,i-1) = 0.0;
125          for (y = 0; y <=lt; y++) Kd[i%2](i-1,y) = 0.0;
126          double Ki = 0.0;
127          for (x = i; x <= ls; x++) {
128              double Kdd = 0.0; int u = s[x-1];
129              for (y = i; y <= lt; y++) {
130                  double w = wgt[t[y-1]];
131                  if (u == t[y-1]) {
132                      Kdd = w * (Kdd + wgt[u]*Kd[(i-1)%2](x-1,y-1));
133                      Ki += w*w * Kd[i%2](x-1, y-1);
134                  } else {
135                      Kdd *= (1-w); 
136                  }
137                  Kd[i%2](x,y) = wgt[u]*Kd[i%2](x-1, y) + Kdd;
138              }
139          }
140          K += lc[i-1] * Ki;
141      }
142      return K;
143  }
144  double TStringKernel::KTrie(const TIntV& s, const TIntV& t, const double& lb, const int& p, int m, const int& AlphN) {
145      int ls = s.Len(), lt = t.Len();
146      if (ls < p || lt < p) return 0.0;
147      m = TInt::GetMn(m, ls-p, lt-p);
148      TVec<TTrieNodeP> Ls, Lt; TIntV v(p), x(p+m); double Kern = 0.0;
149      TFltV lbV(m+1); lbV[0] = 1;
150      for (int i = 0; i < p; i++) lbV[0] *= lb;
151      for (int i = 1; i <= m; i++) lbV[i] = lb * lbV[i-1];
152      for (int AlphC = 0; AlphC < AlphN; AlphC++) {
153          Ls.Clr(); Lt.Clr();
154          for (int i = 0; i <= ls - p; i++) {
155              if (s[i] == AlphC) {
156                  int j = TInt::GetMn(ls, i+p+m);
157                  Ls.Add(TTrieNodeP(TIntPr(i, j-i), 0, 0)); 
158              }
159          }
160          for (int i = 0; i <= lt - p; i++) {
161              if (t[i] == AlphC) {
162                  int j = TInt::GetMn(lt, i+p+m);
163                  Lt.Add(TTrieNodeP(TIntPr(i, j-i), 0, 0)); 
164              }
165          }
166          v[0] = AlphC; KTrieR(s, t, Ls, Lt, v, 1, Kern, lbV, p, m, AlphN); 
167      }
168      return Kern;
169  }
170  void TStringKernel::KTrieR(const TIntV& s, const TIntV& t, const TVec<TTrieNodeP>& Ls, const TVec<TTrieNodeP>& Lt, 
171          TIntV& v, const int& depth, double& Kern, const TFltV& lbV, const int& p, const int& m, const int& AlphN) {
172      int lls = Ls.Len(), llt = Lt.Len();
173      if (lls == 0 || llt == 0) return;
174      if (depth == p) {
175          double Ks = 0.0, Kt = 0.0;
176          for (int i = 0; i < lls; i++) Ks += lbV[Ls[i].Val3];
177          for (int i = 0; i < llt; i++) Kt += lbV[Lt[i].Val3];
178          Kern = Kern + Ks*Kt;
179      } else {
180          TVec<TTrieNodeP> Lss, Ltt;
181          for (int AlphC = 0; AlphC < AlphN; AlphC++) {
182              Lss.Clr(); Ltt.Clr(); v[depth] = AlphC;
183              for (int n = 0; n < lls; n++) {
184                  const TTrieNodeP& node = Ls[n];
185                  const TIntPr& u = node.Val1; 
186                  const int i = node.Val2, j = node.Val3;
187                  const int ustart = u.Val1, lu = u.Val2;
188                  int lk = TInt::GetMn(m-j, lu-i-2);
189                  for (int k = 0; k <= lk; k++) {
190                      if (s[ustart + i + k + 1] == AlphC)
191                          Lss.Add(TTrieNodeP(u, i+k+1, k+j));
192                  }
193              }
194              for (int n = 0; n < llt; n++) {
195                  const TTrieNodeP& node = Lt[n];
196                  const TIntPr& u = node.Val1;
197                  const int i = node.Val2, j = node.Val3;
198                  const int ustart = u.Val1, lu = u.Val2;
199                  int lk = TInt::GetMn(m-j, lu-i-2);
200                  for (int k = 0; k <= lk; k++) {
201                      if (t[ustart + i + k + 1] == AlphC)
202                          Ltt.Add(TTrieNodeP(u, i+k+1, k+j));
203                  }
204              }
205              KTrieR(s, t, Lss, Ltt, v, depth+1, Kern, lbV, p, m, AlphN);
206          }
207      }
208  }
209  double TStringKernel::KTrie2(const TIntV& s, const TIntV& t, const double& lb, const int& p, int m, const int& AlphN) {
210      int ls = s.Len(), lt = t.Len();
211      if (ls < p || lt < p) return 0.0;
212      m = TInt::GetMn(m, ls-p, lt-p);
213      TVec<TVec<TTrieNodeP> > LsV(AlphN), LtV(AlphN); 
214      TIntV v(p), x(p+m); double Kern = 0.0;
215      TFltV lbV(m+1); lbV[0] = 1;
216      for (int i = 0; i < p; i++) lbV[0] *= lb;
217      for (int i = 1; i <= m; i++) lbV[i] = lb * lbV[i-1];
218      for (int i = 0; i <= ls - p; i++) {
219          int j = TInt::GetMn(ls, i+p+m);
220          LsV[s[i]].Add(TTrieNodeP(TIntPr(i, j-i), 0, 0)); 
221      }
222      for (int i = 0; i <= lt - p; i++) {
223          int j = TInt::GetMn(lt, i+p+m);
224          LtV[t[i]].Add(TTrieNodeP(TIntPr(i, j-i), 0, 0)); 
225      }
226      for (int AlphC = 0; AlphC < AlphN; AlphC++) {
227          v[0] = AlphC; 
228          KTrieR2(s, t, LsV[AlphC], LtV[AlphC], v, 1, Kern, lbV, p, m, AlphN); 
229      }
230      return Kern;
231  }
232  void TStringKernel::KTrieR2(const TIntV& s, const TIntV& t, const TVec<TTrieNodeP>& Ls, const TVec<TTrieNodeP>& Lt, 
233          TIntV& v, const int& depth, double& Kern, const TFltV& lbV, const int& p, const int& m, const int& AlphN) {
234      int lls = Ls.Len(), llt = Lt.Len();
235      if (lls == 0 || llt == 0) return;
236      if (depth == p) {
237          double Ks = 0.0, Kt = 0.0;
238          for (int i = 0; i < lls; i++) Ks += lbV[Ls[i].Val3];
239          for (int i = 0; i < llt; i++) Kt += lbV[Lt[i].Val3];
240          Kern = Kern + Ks*Kt;
241      } else {
242          TVec<TVec<TTrieNodeP> > LssV(AlphN), LttV(AlphN);
243          for (int n = 0; n < lls; n++) {
244              const TTrieNodeP& node = Ls[n];
245              const TIntPr& u = node.Val1; 
246              const int i = node.Val2, j = node.Val3;
247              const int ustart = u.Val1, lu = u.Val2;
248              int lk = TInt::GetMn(m-j, lu-i-2);
249              for (int k = 0; k <= lk; k++) {
250                  LssV[s[ustart + i + k + 1]].Add(TTrieNodeP(u, i+k+1, k+j));
251              }
252          }
253          for (int n = 0; n < llt; n++) {
254              const TTrieNodeP& node = Lt[n];
255              const TIntPr& u = node.Val1;
256              const int i = node.Val2, j = node.Val3;
257              const int ustart = u.Val1, lu = u.Val2;
258              int lk = TInt::GetMn(m-j, lu-i-2);
259              for (int k = 0; k <= lk; k++) {
260                  LttV[t[ustart + i + k + 1]].Add(TTrieNodeP(u, i+k+1, k+j));
261              }
262          }
263          for (int AlphC = 0; AlphC < AlphN; AlphC++) {
264              v[depth] = AlphC;
265              KTrieR2(s, t, LssV[AlphC], LttV[AlphC], v, depth+1, Kern, lbV, p, m, AlphN);
266          }
267      }
268  }
269  TStringKernel::TStringKernel(TSIn& SIn) {
270      KernelType = TInt(SIn); Lambda = TFlt(SIn); SeqLen = TInt(SIn);
271      GapLen = TInt(SIn); AlphN = TInt(SIn);
272      LinCombV.Load(SIn); WeightV.Load(SIn);
273  }
274  void TStringKernel::Save(TSOut& SOut) {
275      KernelType.Save(SOut); Lambda.Save(SOut); SeqLen.Save(SOut);
276      GapLen.Save(SOut); AlphN.Save(SOut);
277      LinCombV.Save(SOut); WeightV.Save(SOut);
278  }
279  double TStringKernel::CalcKernel(const TIntV& Vec1, const TIntV& Vec2) {
280      CountEval++; 
281      switch (KernelType.Val) {
282          case 0: return KDynamic(Vec1, Vec2, LinCombV, Lambda);
283          case 1: return KDynamicW(Vec1, Vec2, LinCombV, WeightV);
284          case 2: return KTrie(Vec1, Vec2, Lambda, SeqLen, GapLen, AlphN);
285          case 3: return KTrie2(Vec1, Vec2, Lambda, SeqLen, GapLen, AlphN);
286      }
287      Fail; return 0.0;
288  }
289  void TStringKernel::WhoAmI(const TStr& intro) const {
290      switch (KernelType.Val) {
291          case 0: printf("%s KDynamic [Lambda=%.3f, LinComb=", intro.CStr(), Lambda());
292                  for (int i = 0; i < LinCombV.Len(); i++) printf(" %d:%g", i+2, LinCombV[i]());
293                  printf("]\n"); break;
294          case 1: printf("%s [KDynamicLCW]: LinComb = ", intro.CStr());
295                  for (int i = 0; i < LinCombV.Len(); i++) printf("%d:%g ", i+2, LinCombV[i]());
296                  printf("\n"); break;
297          case 2: printf("%s KTrie [Lambda = %g, SeqLen = %d, GapLen = %d, AlphN = %d]\n", 
298                      intro.CStr(), Lambda(), SeqLen(), GapLen(), AlphN()); break;
299          case 3: printf("%s KTrie2 [Lambda = %g, SeqLen = %d, GapLen = %d, AlphN = %d]\n", 
300                      intro.CStr(), Lambda(), SeqLen(), GapLen(), AlphN()); break;
301          case 4: printf("%s KDynamicSM+WordNet [Lambda=%.3f LinComb=", intro.CStr(), Lambda());
302                  for (int i = 0; i < LinCombV.Len(); i++) printf(" %d:%g", i+2, LinCombV[i]());
303                  printf("]\n"); break;
304      }
305  }
306  int TStringKernel::GetSeqLen() const {
307      if (KernelType == 1) return LinCombV.Len() + 1;
308      return SeqLen;
309  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cfyres.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-strkernel.cpp</div>
                </div>
                <div class="column column_space"><pre><code>117      for (int i = 0; i < Len; i++) {
118          if (ResultV[i].Dat > 0.0) { FN--; TP++; }
119          else { TN--; FP++; }
</pre></code></div>
                <div class="column column_space"><pre><code>97              for (y = i; y <= lt; y++) {
98                  if (u == t[y-1]) {
99                      Kdd = lb * (Kdd + lb*Kdii[(x-1)*(lt+1) + (y-1)]);
100                      Ki += lb*lb * Kdi[(x-1)*(lt+1) + (y-1)];
101                  } else {
102                      Kdd *= lb;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    