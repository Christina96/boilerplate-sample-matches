<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for recorder.cpp &amp; player.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for recorder.cpp &amp; player.cpp
      </h3>
<h1 align="center">
        3.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>recorder.cpp (3.5809019%)<th>player.cpp (3.0646992%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(259-269)<td><a href="#" name="0">(207-217)</a><td align="center"><font color="#ff0000">27</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>recorder.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "rosbag/recorder.h"
2 #include &lt;sys/stat.h&gt;
3 #include &lt;boost/filesystem.hpp&gt;
4 #if BOOST_FILESYSTEM_VERSION &lt; 3
5   #include &lt;sys/statvfs.h&gt;
6 #endif
7 #include &lt;time.h&gt;
8 #include &lt;queue&gt;
9 #include &lt;set&gt;
10 #include &lt;sstream&gt;
11 #include &lt;string&gt;
12 #include &lt;boost/lexical_cast.hpp&gt;
13 #include &lt;boost/regex.hpp&gt;
14 #include &lt;boost/thread.hpp&gt;
15 #include &lt;boost/thread/xtime.hpp&gt;
16 #include &lt;boost/date_time/local_time/local_time.hpp&gt;
17 #include &lt;ros/ros.h&gt;
18 #include &lt;topic_tools/shape_shifter.h&gt;
19 #include "ros/network.h"
20 #include "ros/xmlrpc_manager.h"
21 #include "xmlrpcpp/XmlRpc.h"
22 using std::cout;
23 using std::endl;
24 using std::set;
25 using std::string;
26 using std::vector;
27 using boost::shared_ptr;
28 using ros::Time;
29 namespace rosbag {
30 OutgoingMessage::OutgoingMessage(string const&amp; _topic, topic_tools::ShapeShifter::ConstPtr _msg, boost::shared_ptr&lt;ros::M_string&gt; _connection_header, Time _time) :
31     topic(_topic), msg(_msg), connection_header(_connection_header), time(_time)
32 {
33 }
34 OutgoingQueue::OutgoingQueue(string const&amp; _filename, std::queue&lt;OutgoingMessage&gt;* _queue, Time _time) :
35     filename(_filename), queue(_queue), time(_time)
36 {
37 }
38 RecorderOptions::RecorderOptions() :
39     trigger(false),
40     record_all(false),
41     regex(false),
42     do_exclude(false),
43     quiet(false),
44     append_date(true),
45     snapshot(false),
46     verbose(false),
47     publish(false),
48     compression(compression::Uncompressed),
49     prefix(""),
50     name(""),
51     exclude_regex(),
52     buffer_size(1048576 * 256),
53     chunk_size(1024 * 768),
54     limit(0),
55     split(false),
56     max_size(0),
57     max_splits(0),
58     max_duration(-1.0),
59     node(""),
60     min_space(1024 * 1024 * 1024),
61     min_space_str("1G")
62 {
63 }
64 Recorder::Recorder(RecorderOptions const&amp; options) :
65     options_(options),
66     num_subscribers_(0),
67     exit_code_(0),
68     queue_size_(0),
69     split_count_(0),
70     writing_enabled_(true)
71 {
72 }
73 int Recorder::run() {
74     if (options_.trigger) {
75         doTrigger();
76         return 0;
77     }
78     if (options_.topics.size() == 0) {
79         if (options_.limit &gt; 0) {
80             fprintf(stderr, "Specifying a count is not valid with automatic topic subscription.\n");
81             return 1;
82         }
83         if (!options_.record_all &amp;&amp; (options_.node == std::string(""))) {
84             fprintf(stderr, "No topics specified.\n");
85             return 1;
86         }
87     }
88     ros::NodeHandle nh;
89     if (!nh.ok())
90         return 0;
91     if (options_.publish)
92     {
93         pub_begin_write = nh.advertise&lt;std_msgs::String&gt;("begin_write", 1, true);
94     }
95     last_buffer_warn_ = Time();
96     queue_ = new std::queue&lt;OutgoingMessage&gt;;
97     if (!options_.regex) {
98     	for (string const&amp; topic : options_.topics)
99             subscribe(topic);
100     }
101     if (!ros::Time::waitForValid(ros::WallDuration(2.0)))
102       ROS_WARN("/use_sim_time set to true and no clock published.  Still waiting for valid time...");
103     ros::Time::waitForValid();
104     start_time_ = ros::Time::now();
105     if (!nh.ok())
106         return 0;
107     ros::Subscriber trigger_sub;
108     boost::thread record_thread;
109     if (options_.snapshot)
110     {
111         record_thread = boost::thread([this]() {
112           try
113           {
114             this-&gt;doRecordSnapshotter();
115           }
116           catch (const rosbag::BagException&amp; ex)
117           {
118             ROS_ERROR_STREAM(ex.what());
119             exit_code_ = 1;
120           }
121           catch (const std::exception&amp; ex)
122           {
123             ROS_ERROR_STREAM(ex.what());
124             exit_code_ = 2;
125           }
126           catch (...)
127           {
128             ROS_ERROR_STREAM("Unknown exception thrown while recording bag, exiting.");
129             exit_code_ = 3;
130           }
131         });
132         trigger_sub = nh.subscribe&lt;std_msgs::Empty&gt;("snapshot_trigger", 100, boost::bind(&amp;Recorder::snapshotTrigger, this, boost::placeholders::_1));
133     }
134     else
135     {
136         record_thread = boost::thread([this]() {
137           try
138           {
139             this-&gt;doRecord();
140           }
141           catch (const rosbag::BagException&amp; ex)
142           {
143             ROS_ERROR_STREAM(ex.what());
144             exit_code_ = 1;
145           }
146           catch (const std::exception&amp; ex)
147           {
148             ROS_ERROR_STREAM(ex.what());
149             exit_code_ = 2;
150           }
151           catch (...)
152           {
153             ROS_ERROR_STREAM("Unknown exception thrown while recording bag, exiting.");
154             exit_code_ = 3;
155           }
156         });
157     }
158     ros::Timer check_master_timer;
159     if (options_.record_all || options_.regex || (options_.node != std::string("")))
160     {
161         doCheckMaster(ros::TimerEvent(), nh);
162         check_master_timer = nh.createTimer(ros::Duration(1.0), boost::bind(&amp;Recorder::doCheckMaster, this, boost::placeholders::_1, boost::ref(nh)));
163     }
164     ros::AsyncSpinner s(10);
165     s.start();
166     record_thread.join();
167     queue_condition_.notify_all();
168     delete queue_;
169     return exit_code_;
170 }
171 shared_ptr&lt;ros::Subscriber&gt; Recorder::subscribe(string const&amp; topic) {
172     ROS_INFO("Subscribing to %s", topic.c_str());
173 <a name="0"></a>
174     ros::NodeHandle nh;
175     shared_ptr&lt;int&gt; count(boost::make_shared&lt;int&gt;(options_.limit));
176 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    shared_ptr&lt;ros::Subscriber&gt; sub(boost::make_shared&lt;ros::Subscriber&gt;());
177     ros::SubscribeOptions ops;
178     ops.topic = topic;
179     ops.queue_size = 100;
180     ops.md5sum = ros::message_traits::md5sum&lt;topic_tools::ShapeShifter&gt;();
181     ops.datatype = ros::message_traits::datatype&lt;topic_tools::ShapeShifter&gt;();
182     ops.helper = boost::make_shared&lt;ros::SubscriptionCallbackHelperT&lt;
183         const ros::MessageEvent&lt;topic_tools::ShapeShifter const&gt; &amp;&gt; &gt;(
184             boost::bind(&amp;Recorder::doQueue, this, boost::placeholders::_1, topic, sub, count));
185     ops.transport_hints = options_.transport_hints;</b></font>
186     *sub = nh.subscribe(ops);
187     currently_recording_.insert(topic);
188     num_subscribers_++;
189     return sub;
190 }
191 bool Recorder::isSubscribed(string const&amp; topic) const {
192     return currently_recording_.find(topic) != currently_recording_.end();
193 }
194 bool Recorder::shouldSubscribeToTopic(std::string const&amp; topic, bool from_node) {
195     if (isSubscribed(topic)) {
196         return false;
197     }
198     if(options_.do_exclude &amp;&amp; boost::regex_match(topic, options_.exclude_regex)) {
199         return false;
200     }
201     if(options_.record_all || from_node) {
202         return true;
203     }
204     if (options_.regex) {
205 	return std::any_of(
206             std::begin(options_.topics), std::end(options_.topics),
207             [&amp;topic] (string const&amp; regex_str){
208                 boost::regex e(regex_str);
209                 boost::smatch what;
210                 return boost::regex_match(topic, what, e, boost::match_extra);
211             });
212     }
213     return std::find(std::begin(options_.topics), std::end(options_.topics), topic)
214 	    != std::end(options_.topics);
215 }
216 template&lt;class T&gt;
217 std::string Recorder::timeToStr(T ros_t)
218 {
219     (void)ros_t;
220     std::stringstream msg;
221     const boost::posix_time::ptime now=
222         boost::posix_time::second_clock::local_time();
223     boost::posix_time::time_facet *const f=
224         new boost::posix_time::time_facet("%Y-%m-%d-%H-%M-%S");
225     msg.imbue(std::locale(msg.getloc(),f));
226     msg &lt;&lt; now;
227     return msg.str();
228 }
229 void Recorder::doQueue(const ros::MessageEvent&lt;topic_tools::ShapeShifter const&gt;&amp; msg_event, string const&amp; topic, shared_ptr&lt;ros::Subscriber&gt; subscriber, shared_ptr&lt;int&gt; count) {
230     Time rectime = Time::now();
231     if (options_.verbose)
232         cout &lt;&lt; "Received message on topic " &lt;&lt; subscriber-&gt;getTopic() &lt;&lt; endl;
233     OutgoingMessage out(topic, msg_event.getMessage(), msg_event.getConnectionHeaderPtr(), rectime);
234     {
235         boost::mutex::scoped_lock lock(queue_mutex_);
236         queue_-&gt;push(out);
237         queue_size_ += out.msg-&gt;size();
238         if (options_.repeat_latched)
239         {
240             ros::M_string::const_iterator it = out.connection_header-&gt;find("latching");
241             if ((it != out.connection_header-&gt;end()) &amp;&amp; (it-&gt;second == "1"))
242             {
243                 ros::M_string::const_iterator it2 = out.connection_header-&gt;find("callerid");
244                 if (it2 != out.connection_header-&gt;end())
245                 {
246                     latched_msgs_.insert({{subscriber-&gt;getTopic(), it2-&gt;second}, out});
247                 }
248             }
249         }
250         while (options_.buffer_size &gt; 0 &amp;&amp; queue_size_ &gt; options_.buffer_size) {
251             OutgoingMessage drop = queue_-&gt;front();
252             queue_-&gt;pop();
253             queue_size_ -= drop.msg-&gt;size();
254             if (!options_.snapshot) {
255                 Time now = Time::now();
256                 if (now &gt; last_buffer_warn_ + ros::Duration(5.0)) {
257                     ROS_WARN("rosbag record buffer exceeded.  Dropping oldest queued message.");
258                     last_buffer_warn_ = now;
259                 }
260             }
261         }
262     }
263     if (!options_.snapshot)
264         queue_condition_.notify_all();
265     if ((*count) &gt; 0) {
266         (*count)--;
267         if ((*count) == 0) {
268             subscriber-&gt;shutdown();
269             num_subscribers_--;
270             if (num_subscribers_ == 0)
271                 ros::shutdown();
272         }
273     }
274 }
275 void Recorder::updateFilenames() {
276     vector&lt;string&gt; parts;
277     std::string prefix = options_.prefix;
278     size_t ind = prefix.rfind(".bag");
279     if (ind != std::string::npos &amp;&amp; ind == prefix.size() - 4)
280     {
281       prefix.erase(ind);
282     }
283     if (prefix.length() &gt; 0)
284         parts.push_back(prefix);
285     if (options_.append_date)
286         parts.push_back(timeToStr(ros::WallTime::now()));
287     if (options_.split)
288         parts.push_back(boost::lexical_cast&lt;string&gt;(split_count_));
289     if (parts.size() == 0)
290     {
291       throw BagException("Bag filename is empty (neither of these was specified: prefix, append_date, split)");
292     }
293     target_filename_ = parts[0];
294     for (unsigned int i = 1; i &lt; parts.size(); i++)
295         target_filename_ += string("_") + parts[i];
296     target_filename_ += string(".bag");
297     write_filename_ = target_filename_ + string(".active");
298 }
299 void Recorder::snapshotTrigger(std_msgs::Empty::ConstPtr trigger) {
300     (void)trigger;
301     updateFilenames();
302     ROS_INFO("Triggered snapshot recording with name '%s'.", target_filename_.c_str());
303     {
304         boost::mutex::scoped_lock lock(queue_mutex_);
305         queue_queue_.push(OutgoingQueue(target_filename_, queue_, Time::now()));
306         queue_      = new std::queue&lt;OutgoingMessage&gt;;
307         queue_size_ = 0;
308     }
309     queue_condition_.notify_all();
310 }
311 void Recorder::startWriting() {
312     bag_.setCompression(options_.compression);
313     bag_.setChunkThreshold(options_.chunk_size);
314     updateFilenames();
315     try {
316         bag_.open(write_filename_, bagmode::Write);
317     }
318     catch (const rosbag::BagException&amp; e) {
319         ROS_ERROR("Error writing: %s", e.what());
320         exit_code_ = 1;
321         ros::shutdown();
322     }
323     ROS_INFO("Recording to '%s'.", target_filename_.c_str());
324     if (options_.repeat_latched)
325     {
326         ros::Time now = ros::Time::now();
327         for (auto const&amp; out : latched_msgs_)
328         {
329             bag_.write(out.second.topic, now, *out.second.msg);
330         }
331     }
332     if (options_.publish)
333     {
334         std_msgs::String msg;
335         msg.data = target_filename_.c_str();
336         pub_begin_write.publish(msg);
337     }
338 }
339 void Recorder::stopWriting() {
340     ROS_INFO("Closing '%s'.", target_filename_.c_str());
341     bag_.close();
342     rename(write_filename_.c_str(), target_filename_.c_str());
343 }
344 void Recorder::checkNumSplits()
345 {
346     if(options_.max_splits&gt;0)
347     {
348         current_files_.push_back(target_filename_);
349         if(current_files_.size()&gt;options_.max_splits)
350         {
351             int err = unlink(current_files_.front().c_str());
352             if(err != 0)
353             {
354                 ROS_ERROR("Unable to remove %s: %s", current_files_.front().c_str(), strerror(errno));
355             }
356             current_files_.pop_front();
357         }
358     }
359 }
360 bool Recorder::checkSize()
361 {
362     if (options_.max_size &gt; 0)
363     {
364         if (bag_.getSize() &gt; options_.max_size)
365         {
366             if (options_.split)
367             {
368                 stopWriting();
369                 split_count_++;
370                 checkNumSplits();
371                 startWriting();
372             } else {
373                 ros::shutdown();
374                 return true;
375             }
376         }
377     }
378     return false;
379 }
380 bool Recorder::checkDuration(const ros::Time&amp; t)
381 {
382     if (options_.max_duration &gt; ros::Duration(0))
383     {
384         if (t - start_time_ &gt; options_.max_duration)
385         {
386             if (options_.split)
387             {
388                 while (start_time_ + options_.max_duration &lt; t)
389                 {
390                     stopWriting();
391                     split_count_++;
392                     checkNumSplits();
393                     start_time_ += options_.max_duration;
394                     startWriting();
395                 }
396             } else {
397                 ros::shutdown();
398                 return true;
399             }
400         }
401     }
402     return false;
403 }
404 void Recorder::doRecord() {
405     startWriting();
406     warn_next_ = ros::WallTime();
407     try
408     {
409         checkDisk();
410     }
411     catch (const rosbag::BagException&amp; ex)
412     {
413         ROS_ERROR_STREAM(ex.what());
414         exit_code_ = 1;
415         stopWriting();
416         return;
417     }
418     check_disk_next_ = ros::WallTime::now() + ros::WallDuration().fromSec(20.0);
419     ros::NodeHandle nh;
420     while (nh.ok() || !queue_-&gt;empty()) {
421         boost::unique_lock&lt;boost::mutex&gt; lock(queue_mutex_);
422         bool finished = false;
423         while (queue_-&gt;empty()) {
424             if (!nh.ok()) {
425                 lock.release()-&gt;unlock();
426                 finished = true;
427                 break;
428             }
429             boost::xtime xt;
430             boost::xtime_get(&amp;xt, boost::TIME_UTC_);
431             xt.nsec += 250000000;
432             queue_condition_.timed_wait(lock, xt);
433             if (checkDuration(ros::Time::now()))
434             {
435                 finished = true;
436                 break;
437             }
438         }
439         if (finished)
440             break;
441         OutgoingMessage out = queue_-&gt;front();
442         queue_-&gt;pop();
443         queue_size_ -= out.msg-&gt;size();
444         lock.release()-&gt;unlock();
445         if (checkSize())
446             break;
447         if (checkDuration(out.time))
448             break;
449         try
450         {
451             if (scheduledCheckDisk() &amp;&amp; checkLogging())
452                 bag_.write(out.topic, out.time, *out.msg, out.connection_header);
453         }
454         catch (const rosbag::BagException&amp; ex)
455         {
456             ROS_ERROR_STREAM(ex.what());
457             exit_code_ = 1;
458             break;
459         }
460     }
461     stopWriting();
462 }
463 void Recorder::doRecordSnapshotter() {
464     ros::NodeHandle nh;
465     while (nh.ok() || !queue_queue_.empty()) {
466         boost::unique_lock&lt;boost::mutex&gt; lock(queue_mutex_);
467         while (queue_queue_.empty()) {
468             if (!nh.ok())
469                 return;
470             queue_condition_.wait(lock);
471         }
472         OutgoingQueue out_queue = queue_queue_.front();
473         queue_queue_.pop();
474         lock.release()-&gt;unlock();
475         string target_filename = out_queue.filename;
476         string write_filename  = target_filename + string(".active");
477         try {
478             bag_.open(write_filename, bagmode::Write);
479         }
480         catch (const rosbag::BagException&amp; ex) {
481             ROS_ERROR("Error writing: %s", ex.what());
482             return;
483         }
484         while (!out_queue.queue-&gt;empty()) {
485             OutgoingMessage out = out_queue.queue-&gt;front();
486             out_queue.queue-&gt;pop();
487             bag_.write(out.topic, out.time, *out.msg);
488         }
489         stopWriting();
490     }
491 }
492 void Recorder::doCheckMaster(ros::TimerEvent const&amp; e, ros::NodeHandle&amp; node_handle) {
493     (void)e;
494     (void)node_handle;
495     ros::master::V_TopicInfo topics;
496     if (ros::master::getTopics(topics)) {
497 	for (ros::master::TopicInfo const&amp; t : topics) {
498 	    if (shouldSubscribeToTopic(t.name))
499 	        subscribe(t.name);
500 	}
501     }
502     if (options_.node != std::string(""))
503     {
504       XmlRpc::XmlRpcValue req;
505       req[0] = ros::this_node::getName();
506       req[1] = options_.node;
507       XmlRpc::XmlRpcValue resp;
508       XmlRpc::XmlRpcValue payload;
509       if (ros::master::execute("lookupNode", req, resp, payload, true))
510       {
511         std::string peer_host;
512         uint32_t peer_port;
513         if (!ros::network::splitURI(static_cast&lt;std::string&gt;(resp[2]), peer_host, peer_port))
514         {
515           ROS_ERROR("Bad xml-rpc URI trying to inspect node at: [%s]", static_cast&lt;std::string&gt;(resp[2]).c_str());
516         } else {
517           XmlRpc::XmlRpcClient c(peer_host.c_str(), peer_port, "/");
518           XmlRpc::XmlRpcValue req2;
519           XmlRpc::XmlRpcValue resp2;
520           req2[0] = ros::this_node::getName();
521           c.execute("getSubscriptions", req2, resp2);
522           if (!c.isFault() &amp;&amp; resp2.valid() &amp;&amp; resp2.size() &gt; 0 &amp;&amp; static_cast&lt;int&gt;(resp2[0]) == 1)
523           {
524             for(int i = 0; i &lt; resp2[2].size(); i++)
525             {
526               if (shouldSubscribeToTopic(resp2[2][i][0], true))
527                 subscribe(resp2[2][i][0]);
528             }
529           } else {
530             ROS_ERROR("Node at: [%s] failed to return subscriptions.", static_cast&lt;std::string&gt;(resp[2]).c_str());
531           }
532         }
533       }
534     }
535 }
536 void Recorder::doTrigger() {
537     ros::NodeHandle nh;
538     ros::Publisher pub = nh.advertise&lt;std_msgs::Empty&gt;("snapshot_trigger", 1, true);
539     pub.publish(std_msgs::Empty());
540     ros::Timer terminate_timer = nh.createTimer(ros::Duration(1.0), boost::bind(&amp;ros::shutdown));
541     ros::spin();
542 }
543 bool Recorder::scheduledCheckDisk() {
544     boost::mutex::scoped_lock lock(check_disk_mutex_);
545     if (ros::WallTime::now() &lt; check_disk_next_)
546         return true;
547     check_disk_next_ += ros::WallDuration().fromSec(20.0);
548     return checkDisk();
549 }
550 bool Recorder::checkDisk() {
551 #if BOOST_FILESYSTEM_VERSION &lt; 3
552     struct statvfs fiData;
553     if ((statvfs(bag_.getFileName().c_str(), &amp;fiData)) &lt; 0)
554     {
555         ROS_WARN("Failed to check filesystem stats.");
556         return true;
557     }
558     unsigned long long free_space = 0;
559     free_space = (unsigned long long) (fiData.f_bsize) * (unsigned long long) (fiData.f_bavail);
560     if (free_space &lt; options_.min_space)
561     {
562         ROS_ERROR("Less than %s of space free on disk with '%s'.  Disabling recording.", options_.min_space_str.c_str(), bag_.getFileName().c_str());
563         writing_enabled_ = false;
564         return false;
565     }
566     else if (free_space &lt; 5 * options_.min_space)
567     {
568         ROS_WARN("Less than 5 x %s of space free on disk with '%s'.", options_.min_space_str.c_str(), bag_.getFileName().c_str());
569     }
570     else
571     {
572         writing_enabled_ = true;
573     }
574 #else
575     boost::filesystem::path p(boost::filesystem::system_complete(bag_.getFileName().c_str()));
576     p = p.parent_path();
577     boost::filesystem::space_info info;
578     try
579     {
580         info = boost::filesystem::space(p);
581     }
582     catch (const boost::filesystem::filesystem_error&amp; e) 
583     { 
584         ROS_WARN("Failed to check filesystem stats [%s].", e.what());
585         writing_enabled_ = false;
586         return false;
587     }
588     if ( info.available &lt; options_.min_space)
589     {
590         writing_enabled_ = false;
591         throw BagException("Less than " + options_.min_space_str + " of space free on disk with " + bag_.getFileName() + ". Disabling recording.");
592     }
593     else if (info.available &lt; 5 * options_.min_space)
594     {
595         ROS_WARN("Less than 5 x %s of space free on disk with '%s'.", options_.min_space_str.c_str(), bag_.getFileName().c_str());
596         writing_enabled_ = true;
597     }
598     else
599     {
600         writing_enabled_ = true;
601     }
602 #endif
603     return true;
604 }
605 bool Recorder::checkLogging() {
606     if (writing_enabled_)
607         return true;
608     ros::WallTime now = ros::WallTime::now();
609     if (now &gt;= warn_next_) {
610         warn_next_ = now + ros::WallDuration().fromSec(5.0);
611         ROS_WARN("Not logging message because logging disabled.  Most likely cause is a full disk.");
612     }
613     return false;
614 }
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>player.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "rosbag/player.h"
2 #include "rosbag/message_instance.h"
3 #include "rosbag/view.h"
4 #if !defined(_MSC_VER)
5   #include &lt;sys/select.h&gt;
6 #endif
7 #include &lt;boost/format.hpp&gt;
8 #include "rosgraph_msgs/Clock.h"
9 #include &lt;set&gt;
10 using std::map;
11 using std::pair;
12 using std::string;
13 using std::vector;
14 using boost::shared_ptr;
15 using ros::Exception;
16 namespace rosbag {
17 bool isLatching(const ConnectionInfo* c)
18 {
19     ros::M_string::const_iterator header_iter = c-&gt;header-&gt;find("latching");
20     return (header_iter != c-&gt;header-&gt;end() &amp;&amp; header_iter-&gt;second == "1");
21 }
22 ros::AdvertiseOptions createAdvertiseOptions(const ConnectionInfo* c, uint32_t queue_size, const std::string&amp; prefix) {
23     ros::AdvertiseOptions opts(prefix + c-&gt;topic, queue_size, c-&gt;md5sum, c-&gt;datatype, c-&gt;msg_def);
24     opts.latch = isLatching(c);
25     return opts;
26 }
27 ros::AdvertiseOptions createAdvertiseOptions(MessageInstance const&amp; m, uint32_t queue_size, const std::string&amp; prefix) {
28     return ros::AdvertiseOptions(prefix + m.getTopic(), queue_size, m.getMD5Sum(), m.getDataType(), m.getMessageDefinition());
29 }
30 PlayerOptions::PlayerOptions() :
31     prefix(""),
32     quiet(false),
33     start_paused(false),
34     at_once(false),
35     bag_time(false),
36     bag_time_frequency(0.0),
37     time_scale(1.0),
38     queue_size(0),
39     advertise_sleep(0.2),
40     try_future(false),
41     has_time(false),
42     loop(false),
43     time(0.0f),
44     has_duration(false),
45     duration(0.0f),
46     keep_alive(false),
47     wait_for_subscribers(false),
48     rate_control_topic(""),
49     rate_control_max_delay(1.0f),
50     skip_empty(ros::DURATION_MAX)
51 {
52 }
53 void PlayerOptions::check() {
54     if (bags.size() == 0)
55         throw Exception("You must specify at least one bag file to play from");
56     if (has_duration &amp;&amp; duration &lt;= 0.0)
57         throw Exception("Invalid duration, must be &gt; 0.0");
58 }
59 Player::Player(PlayerOptions const&amp; options) :
60     options_(options),
61     paused_(options.start_paused),
62     pause_for_topics_(options_.pause_topics.size() &gt; 0),
63     pause_change_requested_(false),
64     requested_pause_state_(false),
65     terminal_modified_(false)
66 {
67   ros::NodeHandle private_node_handle("~");
68   pause_service_ = private_node_handle.advertiseService("pause_playback", &amp;Player::pauseCallback, this);
69 }
70 Player::~Player() {
71     for (shared_ptr&lt;Bag&gt;&amp; bag : bags_)
72         bag-&gt;close();
73     restoreTerminal();
74 }
75 void Player::publish() {
76     options_.check();
77     for (string const&amp; filename : options_.bags) {
78         ROS_INFO("Opening %s", filename.c_str());
79         try
80         {
81             shared_ptr&lt;Bag&gt; bag(boost::make_shared&lt;Bag&gt;());
82             bag-&gt;open(filename, bagmode::Read);
83             bags_.push_back(bag);
84         }
85         catch (const BagUnindexedException&amp; ex) {
86             std::cerr &lt;&lt; "Bag file " &lt;&lt; filename &lt;&lt; " is unindexed.  Run rosbag reindex." &lt;&lt; std::endl;
87             return;
88         }
89     }
90     setupTerminal();
91     if (!node_handle_.ok())
92       return;
93     if (!options_.prefix.empty())
94     {
95       ROS_INFO_STREAM("Using prefix '" &lt;&lt; options_.prefix &lt;&lt; "'' for topics ");
96     }
97     if (!options_.quiet)
98       puts("");
99     View full_view;
100     for (shared_ptr&lt;Bag&gt;&amp; bag : bags_)
101         full_view.addQuery(*bag);
102     const auto full_initial_time = full_view.getBeginTime();
103     const auto initial_time = full_initial_time + ros::Duration(options_.time);
104     ros::Time finish_time = ros::TIME_MAX;
105     if (options_.has_duration)
106     {
107       finish_time = initial_time + ros::Duration(options_.duration);
108     }
109     View view;
110     TopicQuery topics(options_.topics);
111     if (options_.topics.empty())
112     {
113       for (shared_ptr&lt;Bag&gt;&amp; bag : bags_)
114         view.addQuery(*bag, initial_time, finish_time);
115     } else {
116       for (shared_ptr&lt;Bag&gt;&amp; bag : bags_)
117         view.addQuery(*bag, topics, initial_time, finish_time);
118     }
119     if (view.size() == 0)
120     {
121       std::cerr &lt;&lt; "No messages to play on specified topics.  Exiting." &lt;&lt; std::endl;
122       ros::shutdown();
123       return;
124     }
125     for (const ConnectionInfo* c : view.getConnections())
126     {
127         advertise(c);
128     }
129     if (options_.rate_control_topic != "")
130 <a name="0"></a>    {
131         std::cout &lt;&lt; "Creating rate control topic subscriber..." &lt;&lt; std::flush;
132 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        boost::shared_ptr&lt;ros::Subscriber&gt; sub(boost::make_shared&lt;ros::Subscriber&gt;());
133         ros::SubscribeOptions ops;
134         ops.topic = options_.rate_control_topic;
135         ops.queue_size = 10;
136         ops.md5sum = ros::message_traits::md5sum&lt;topic_tools::ShapeShifter&gt;();
137         ops.datatype = ros::message_traits::datatype&lt;topic_tools::ShapeShifter&gt;();
138         ops.helper = boost::make_shared&lt;ros::SubscriptionCallbackHelperT&lt;
139             const ros::MessageEvent&lt;topic_tools::ShapeShifter const&gt; &amp;&gt; &gt;(
140                 boost::bind(&amp;Player::updateRateTopicTime, this, boost::placeholders::_1));
141         rate_control_sub_ = node_handle_.subscribe(ops);</b></font>
142         std::cout &lt;&lt; " done." &lt;&lt; std::endl;
143     }
144     std::cout &lt;&lt; "Waiting " &lt;&lt; options_.advertise_sleep.toSec() &lt;&lt; " seconds after advertising topics..." &lt;&lt; std::flush;
145     options_.advertise_sleep.sleep();
146     std::cout &lt;&lt; " done." &lt;&lt; std::endl;
147     std::cout &lt;&lt; std::endl &lt;&lt; "Hit space to toggle paused, or 's' to step." &lt;&lt; std::endl;
148     if (options_.time &gt; 0.0) {
149         View full_latch_view;
150         if (options_.topics.empty()) {
151             for (const auto&amp; bag : bags_) {
152                 full_latch_view.addQuery(*bag, full_initial_time, initial_time);
153             }
154         } else {
155             for (const auto&amp; bag : bags_) {
156                 full_latch_view.addQuery(*bag, topics, full_initial_time, initial_time);
157             }
158         }
159         std::set&lt;std::pair&lt;std::string, std::string&gt;&gt; latch_topics;
160         for (const auto&amp; c : full_latch_view.getConnections()) {
161             if (isLatching(c)) {
162                 const auto header_iter = c-&gt;header-&gt;find("callerid");
163                 const auto callerid = (header_iter != c-&gt;header-&gt;end() ? header_iter-&gt;second : string(""));
164                 latch_topics.emplace(callerid, c-&gt;topic);
165                 advertise(c);
166             }
167         }
168         if (options_.wait_for_subscribers){
169             waitForSubscribers();
170         }
171         for (const auto&amp; item : latch_topics) {
172             const auto&amp; callerid = item.first;
173             const auto&amp; topic = item.second;
174             View latch_view;
175             for (const auto&amp; bag : bags_) {
176                 latch_view.addQuery(*bag, TopicQuery(topic), full_initial_time, initial_time);
177             }
178             auto last_message = latch_view.end();
179             for (auto iter = latch_view.begin(); iter != latch_view.end(); ++iter) {
180                 if (iter-&gt;getCallerId() == callerid) {
181                     last_message = iter;
182                 }
183             }
184             if (last_message != latch_view.end()) {
185                 const auto publisher = publishers_.find(callerid + topic);
186                 ROS_ASSERT(publisher != publishers_.end());
187                 publisher-&gt;second.publish(*last_message);
188             }
189         }
190     } else if (options_.wait_for_subscribers) {
191         waitForSubscribers();
192     }
193     while (true) {
194         time_translator_.setTimeScale(options_.time_scale);
195         start_time_ = view.begin()-&gt;getTime();
196         time_translator_.setRealStartTime(start_time_);
197         bag_length_ = view.getEndTime() - view.getBeginTime();
198         last_rate_control_ = start_time_;
199         time_publisher_.setTime(start_time_);
200         ros::WallTime now_wt = ros::WallTime::now();
201         time_translator_.setTranslatedStartTime(ros::Time(now_wt.sec, now_wt.nsec));
202         time_publisher_.setTimeScale(options_.time_scale);
203         if (options_.bag_time)
204             time_publisher_.setPublishFrequency(options_.bag_time_frequency);
205         else
206             time_publisher_.setPublishFrequency(-1.0);
207         paused_time_ = now_wt;
208         for (const MessageInstance&amp; m : view) {
209             if (!node_handle_.ok())
210                 break;
211             doPublish(m);
212         }
213         if (options_.keep_alive)
214             while (node_handle_.ok())
215                 doKeepAlive();
216         if (!node_handle_.ok()) {
217             std::cout &lt;&lt; std::endl;
218             break;
219         }
220         if (!options_.loop) {
221             std::cout &lt;&lt; std::endl &lt;&lt; "Done." &lt;&lt; std::endl;
222             break;
223         }
224     }
225     ros::shutdown();
226 }
227 void Player::updateRateTopicTime(const ros::MessageEvent&lt;topic_tools::ShapeShifter const&gt;&amp; msg_event)
228 {
229     boost::shared_ptr&lt;topic_tools::ShapeShifter const&gt; const &amp;ssmsg = msg_event.getConstMessage();
230     std::string def = ssmsg-&gt;getMessageDefinition();
231     size_t length = ros::serialization::serializationLength(*ssmsg);
232     std::istringstream f(def);
233     std::string s;
234     bool flag = false;
235     while(std::getline(f, s, '\n')) {
236         if (!s.empty() &amp;&amp; s.find("#") != 0) {
237             if (s.find("Header ") == 0) {
238                 flag = true;
239             }
240             break;
241         }
242     }
243     if (!flag) {
244         std::cout &lt;&lt; std::endl &lt;&lt; "WARNING: Rate control topic is bad, header is not first. MSG may be malformed." &lt;&lt; std::endl;
245         return;
246     }
247     std::vector&lt;uint8_t&gt; buffer(length);
248     ros::serialization::OStream ostream(&amp;buffer[0], length);
249     ros::serialization::Serializer&lt;topic_tools::ShapeShifter&gt;::write(ostream, *ssmsg);
250     int32_t header_timestamp_sec  = buffer[4] | (uint32_t)buffer[5] &lt;&lt; 8 | (uint32_t)buffer[6] &lt;&lt; 16 | (uint32_t)buffer[7] &lt;&lt; 24;
251     int32_t header_timestamp_nsec = buffer[8] | (uint32_t)buffer[9] &lt;&lt; 8 | (uint32_t)buffer[10] &lt;&lt; 16 | (uint32_t)buffer[11] &lt;&lt; 24;
252     last_rate_control_ = ros::Time(header_timestamp_sec, header_timestamp_nsec);
253 }
254 void Player::printTime()
255 {
256     if (!options_.quiet) {
257         ros::Time current_time = time_publisher_.getTime();
258         ros::Duration d = current_time - start_time_;
259         if (paused_)
260         {
261             printf("\r [PAUSED ]  Bag Time: %13.6f   Duration: %.6f / %.6f               \r", time_publisher_.getTime().toSec(), d.toSec(), bag_length_.toSec());
262         }
263         else if (delayed_)
264         {
265             ros::Duration time_since_rate = std::max(ros::Time::now() - last_rate_control_, ros::Duration(0));
266             printf("\r [DELAYED]  Bag Time: %13.6f   Duration: %.6f / %.6f   Delay: %.2f \r", time_publisher_.getTime().toSec(), d.toSec(), bag_length_.toSec(), time_since_rate.toSec());
267         }
268         else
269         {
270             printf("\r [RUNNING]  Bag Time: %13.6f   Duration: %.6f / %.6f               \r", time_publisher_.getTime().toSec(), d.toSec(), bag_length_.toSec());
271         }
272         fflush(stdout);
273     }
274 }
275 bool Player::pauseCallback(std_srvs::SetBool::Request &amp;req, std_srvs::SetBool::Response &amp;res)
276 {
277   pause_change_requested_ = (req.data != paused_);
278   requested_pause_state_ = req.data;
279   res.success = pause_change_requested_;
280   if (res.success)
281   {
282     res.message = std::string("Playback is now ") + (requested_pause_state_ ? "paused" : "resumed");
283   }
284   else
285   {
286     res.message = std::string("Bag is already ") + (requested_pause_state_ ? "paused." : "running.");
287   }
288   return true;
289 }
290 void Player::processPause(const bool paused, ros::WallTime &amp;horizon)
291 {
292   paused_ = paused;
293   if (paused_)
294   {
295     paused_time_ = ros::WallTime::now();
296   }
297   else
298   {
299     ros::WallDuration shift = ros::WallTime::now() - paused_time_;
300     paused_time_ = ros::WallTime::now();
301     time_translator_.shift(ros::Duration(shift.sec, shift.nsec));
302     horizon += shift;
303     time_publisher_.setWCHorizon(horizon);
304   }
305 }
306 void Player::waitForSubscribers() const
307 {
308     bool all_topics_subscribed = false;
309     std::cout &lt;&lt; "Waiting for subscribers." &lt;&lt; std::endl;
310     while (!all_topics_subscribed) {
311         all_topics_subscribed = std::all_of(
312             std::begin(publishers_), std::end(publishers_),
313             [](const PublisherMap::value_type&amp; pub) {
314                 return pub.second.getNumSubscribers() &gt; 0;
315             });
316         ros::WallDuration(0.1).sleep();
317     }
318     std::cout &lt;&lt; "Finished waiting for subscribers." &lt;&lt; std::endl;
319 }
320 void Player::advertise(const ConnectionInfo* c)
321 {
322     ros::M_string::const_iterator header_iter = c-&gt;header-&gt;find("callerid");
323     std::string callerid = (header_iter != c-&gt;header-&gt;end() ? header_iter-&gt;second : string(""));
324     string callerid_topic = callerid + c-&gt;topic;
325     map&lt;string, ros::Publisher&gt;::iterator pub_iter = publishers_.find(callerid_topic);
326     if (pub_iter == publishers_.end()) {
327         ros::AdvertiseOptions opts = createAdvertiseOptions(c, options_.queue_size, options_.prefix);
328         ros::Publisher pub = node_handle_.advertise(opts);
329         publishers_.insert(publishers_.begin(), pair&lt;string, ros::Publisher&gt;(callerid_topic, pub));
330         pub_iter = publishers_.find(callerid_topic);
331     }
332 }
333 void Player::doPublish(MessageInstance const&amp; m) {
334     string const&amp; topic   = m.getTopic();
335     ros::Time const&amp; time = m.getTime();
336     string callerid       = m.getCallerId();
337     ros::Time translated = time_translator_.translate(time);
338     ros::WallTime horizon = ros::WallTime(translated.sec, translated.nsec);
339     time_publisher_.setHorizon(time);
340     time_publisher_.setWCHorizon(horizon);
341     string callerid_topic = callerid + topic;
342     map&lt;string, ros::Publisher&gt;::iterator pub_iter = publishers_.find(callerid_topic);
343     ROS_ASSERT(pub_iter != publishers_.end());
344     ros::spinOnce();
345     if (options_.at_once) {
346         time_publisher_.stepClock();
347         pub_iter-&gt;second.publish(m);
348         printTime();
349         return;
350     }
351     if (time - time_publisher_.getTime() &gt; options_.skip_empty)
352     {
353       time_publisher_.stepClock();
354       ros::WallDuration shift = ros::WallTime::now() - horizon ;
355       time_translator_.shift(ros::Duration(shift.sec, shift.nsec));
356       horizon += shift;
357       time_publisher_.setWCHorizon(horizon);
358       (pub_iter-&gt;second).publish(m);
359       printTime();
360       return;
361     }
362     if (pause_for_topics_)
363     {
364         for (std::vector&lt;std::string&gt;::iterator i = options_.pause_topics.begin();
365              i != options_.pause_topics.end();
366              ++i)
367         {
368             if (topic == *i)
369             {
370                 paused_ = true;
371                 paused_time_ = ros::WallTime::now();
372             }
373         }
374     }
375     if (rate_control_sub_ != NULL) {
376         if ((time_publisher_.getTime() - last_rate_control_).toSec() &gt; options_.rate_control_max_delay) {
377             delayed_ = true;
378             paused_time_ = ros::WallTime::now();
379         }
380     }
381     while ((paused_ || delayed_ || !time_publisher_.horizonReached()) &amp;&amp; node_handle_.ok())
382     {
383         bool charsleftorpaused = true;
384         while (charsleftorpaused &amp;&amp; node_handle_.ok())
385         {
386             ros::spinOnce();
387             if (pause_change_requested_)
388             {
389               processPause(requested_pause_state_, horizon);
390               pause_change_requested_ = false;
391             }
392             switch (readCharFromStdin()){
393             case ' ':
394                 processPause(!paused_, horizon);
395                 break;
396             case 's':
397                 if (paused_) {
398                     time_publisher_.stepClock();
399                     ros::WallDuration shift = ros::WallTime::now() - horizon ;
400                     paused_time_ = ros::WallTime::now();
401                     time_translator_.shift(ros::Duration(shift.sec, shift.nsec));
402                     horizon += shift;
403                     time_publisher_.setWCHorizon(horizon);
404                     (pub_iter-&gt;second).publish(m);
405                     printTime();
406                     return;
407                 }
408                 break;
409             case 't':
410                 pause_for_topics_ = !pause_for_topics_;
411                 break;
412             case EOF:
413                 if (paused_)
414                 {
415                     printTime();
416                     time_publisher_.runStalledClock(ros::WallDuration(.1));
417                     ros::spinOnce();
418                 }
419                 else if (delayed_)
420                 {
421                     printTime();
422                     time_publisher_.runStalledClock(ros::WallDuration(.1));
423                     ros::spinOnce();
424                     if(rate_control_sub_ == NULL || (time_publisher_.getTime() - last_rate_control_).toSec() &lt;= options_.rate_control_max_delay) {
425                         delayed_ = false;
426                         ros::WallDuration shift = ros::WallTime::now() - paused_time_;
427                         paused_time_ = ros::WallTime::now();
428                         time_translator_.shift(ros::Duration(shift.sec, shift.nsec));
429                         horizon += shift;
430                         time_publisher_.setWCHorizon(horizon);
431                     }
432                 }
433                 else
434                     charsleftorpaused = false;
435             }
436         }
437         printTime();
438         time_publisher_.runClock(ros::WallDuration(.1));
439         ros::spinOnce();
440     }
441     pub_iter-&gt;second.publish(m);
442 }
443 void Player::doKeepAlive() {
444     ros::Time const&amp; time = time_publisher_.getTime() + ros::Duration(10.0);
445     ros::Time translated = time_translator_.translate(time);
446     ros::WallTime horizon = ros::WallTime(translated.sec, translated.nsec);
447     time_publisher_.setHorizon(time);
448     time_publisher_.setWCHorizon(horizon);
449     if (options_.at_once) {
450         return;
451     }
452     delayed_ = false;
453     while ((paused_ || !time_publisher_.horizonReached()) &amp;&amp; node_handle_.ok())
454     {
455         bool charsleftorpaused = true;
456         while (charsleftorpaused &amp;&amp; node_handle_.ok())
457         {
458             switch (readCharFromStdin()){
459             case ' ':
460                 paused_ = !paused_;
461                 if (paused_) {
462                     paused_time_ = ros::WallTime::now();
463                 }
464                 else
465                 {
466                     ros::WallDuration shift = ros::WallTime::now() - paused_time_;
467                     paused_time_ = ros::WallTime::now();
468                     time_translator_.shift(ros::Duration(shift.sec, shift.nsec));
469                     horizon += shift;
470                     time_publisher_.setWCHorizon(horizon);
471                 }
472                 break;
473             case EOF:
474                 if (paused_)
475                 {
476                     printTime();
477                     time_publisher_.runStalledClock(ros::WallDuration(.1));
478                     ros::spinOnce();
479                 }
480                 else
481                     charsleftorpaused = false;
482             }
483         }
484         printTime();
485         time_publisher_.runClock(ros::WallDuration(.1));
486         ros::spinOnce();
487     }
488 }
489 void Player::setupTerminal() {
490     if (terminal_modified_)
491         return;
492 #if defined(_MSC_VER)
493     input_handle = GetStdHandle(STD_INPUT_HANDLE);
494     if (input_handle == INVALID_HANDLE_VALUE)
495     {
496         std::cout &lt;&lt; "Failed to set up standard input handle." &lt;&lt; std::endl;
497         return;
498     }
499     if (! GetConsoleMode(input_handle, &amp;stdin_set) )
500     {
501         std::cout &lt;&lt; "Failed to save the console mode." &lt;&lt; std::endl;
502         return;
503     }
504     terminal_modified_ = true;
505 #else
506     const int fd = fileno(stdin);
507     termios flags;
508     tcgetattr(fd, &amp;orig_flags_);
509     flags = orig_flags_;
510     flags.c_lflag &amp;= ~ICANON;          flags.c_cc[VMIN]  = 0;             flags.c_cc[VTIME] = 0;             tcsetattr(fd, TCSANOW, &amp;flags);
511     FD_ZERO(&amp;stdin_fdset_);
512     FD_SET(fd, &amp;stdin_fdset_);
513     maxfd_ = fd + 1;
514     terminal_modified_ = true;
515 #endif
516 }
517 void Player::restoreTerminal() {
518 	if (!terminal_modified_)
519 		return;
520 #if defined(_MSC_VER)
521     SetConsoleMode(input_handle, stdin_set);
522 #else
523     const int fd = fileno(stdin);
524     tcsetattr(fd, TCSANOW, &amp;orig_flags_);
525 #endif
526     terminal_modified_ = false;
527 }
528 int Player::readCharFromStdin() {
529 #ifdef __APPLE__
530     fd_set testfd;
531     FD_COPY(&amp;stdin_fdset_, &amp;testfd);
532 #elif !defined(_MSC_VER)
533     fd_set testfd = stdin_fdset_;
534 #endif
535 #if defined(_MSC_VER)
536     DWORD events = 0;
537     INPUT_RECORD input_record[1];
538     DWORD input_size = 1;
539     BOOL b = GetNumberOfConsoleInputEvents(input_handle, &amp;events);
540     if (b &amp;&amp; events &gt; 0)
541     {
542         b = ReadConsoleInput(input_handle, input_record, input_size, &amp;events);
543         if (b)
544         {
545             for (unsigned int i = 0; i &lt; events; ++i)
546             {
547                 if (input_record[i].EventType &amp; KEY_EVENT &amp; input_record[i].Event.KeyEvent.bKeyDown)
548                 {
549                     CHAR ch = input_record[i].Event.KeyEvent.uChar.AsciiChar;
550                     return ch;
551                 }
552             }
553         }
554     }
555     return EOF;
556 #else
557     timeval tv;
558     tv.tv_sec  = 0;
559     tv.tv_usec = 0;
560     if (select(maxfd_, &amp;testfd, NULL, NULL, &amp;tv) &lt;= 0)
561         return EOF;
562     return getc(stdin);
563 #endif
564 }
565 TimePublisher::TimePublisher() : time_scale_(1.0)
566 {
567   setPublishFrequency(-1.0);
568   time_pub_ = node_handle_.advertise&lt;rosgraph_msgs::Clock&gt;("clock",1);
569 }
570 void TimePublisher::setPublishFrequency(double publish_frequency)
571 {
572   publish_frequency_ = publish_frequency;
573   do_publish_ = (publish_frequency &gt; 0.0);
574   wall_step_.fromSec(1.0 / publish_frequency);
575 }
576 void TimePublisher::setTimeScale(double time_scale)
577 {
578     time_scale_ = time_scale;
579 }
580 void TimePublisher::setHorizon(const ros::Time&amp; horizon)
581 {
582     horizon_ = horizon;
583 }
584 void TimePublisher::setWCHorizon(const ros::WallTime&amp; horizon)
585 {
586   wc_horizon_ = horizon;
587 }
588 void TimePublisher::setTime(const ros::Time&amp; time)
589 {
590     current_ = time;
591 }
592 ros::Time const&amp; TimePublisher::getTime() const
593 {
594     return current_;
595 }
596 void TimePublisher::runClock(const ros::WallDuration&amp; duration)
597 {
598     if (do_publish_)
599     {
600         rosgraph_msgs::Clock pub_msg;
601         ros::WallTime t = ros::WallTime::now();
602         ros::WallTime done = t + duration;
603         while (t &lt; done &amp;&amp; t &lt; wc_horizon_)
604         {
605             ros::WallDuration leftHorizonWC = wc_horizon_ - t;
606             ros::Duration d(leftHorizonWC.sec, leftHorizonWC.nsec);
607             d *= time_scale_;
608             current_ = horizon_ - d;
609             if (current_ &gt;= horizon_)
610               current_ = horizon_;
611             if (t &gt;= next_pub_)
612             {
613                 pub_msg.clock = current_;
614                 time_pub_.publish(pub_msg);
615                 next_pub_ = t + wall_step_;
616             }
617             ros::WallTime target = done;
618             if (target &gt; wc_horizon_)
619               target = wc_horizon_;
620             if (target &gt; next_pub_)
621               target = next_pub_;
622             ros::WallTime::sleepUntil(target);
623             t = ros::WallTime::now();
624         }
625     } else {
626         ros::WallTime t = ros::WallTime::now();
627         ros::WallDuration leftHorizonWC = wc_horizon_ - t;
628         ros::Duration d(leftHorizonWC.sec, leftHorizonWC.nsec);
629         d *= time_scale_;
630         current_ = horizon_ - d;
631         if (current_ &gt;= horizon_)
632             current_ = horizon_;
633         ros::WallTime target = ros::WallTime::now() + duration;
634         if (target &gt; wc_horizon_)
635             target = wc_horizon_;
636         ros::WallTime::sleepUntil(target);
637     }
638 }
639 void TimePublisher::stepClock()
640 {
641     if (do_publish_)
642     {
643         current_ = horizon_;
644         rosgraph_msgs::Clock pub_msg;
645         pub_msg.clock = current_;
646         time_pub_.publish(pub_msg);
647         ros::WallTime t = ros::WallTime::now();
648         next_pub_ = t + wall_step_;
649     } else {
650         current_ = horizon_;
651     }
652 }
653 void TimePublisher::runStalledClock(const ros::WallDuration&amp; duration)
654 {
655     if (do_publish_)
656     {
657         rosgraph_msgs::Clock pub_msg;
658         ros::WallTime t = ros::WallTime::now();
659         ros::WallTime done = t + duration;
660         while ( t &lt; done )
661         {
662             if (t &gt; next_pub_)
663             {
664                 pub_msg.clock = current_;
665                 time_pub_.publish(pub_msg);
666                 next_pub_ = t + wall_step_;
667             }
668             ros::WallTime target = done;
669             if (target &gt; next_pub_)
670               target = next_pub_;
671             ros::WallTime::sleepUntil(target);
672             t = ros::WallTime::now();
673         }
674     } else {
675         duration.sleep();
676     }
677 }
678 bool TimePublisher::horizonReached()
679 {
680   return ros::WallTime::now() &gt; wc_horizon_;
681 }
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
