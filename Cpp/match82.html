<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_api_hash_sha1.cpp & test_api_mac_cmac.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_api_hash_sha1.cpp & test_api_mac_cmac.cpp
      </h3>
      <h1 align="center">
        57.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_api_hash_sha1.cpp (71.79487%)<TH>test_api_mac_cmac.cpp (47.457626%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match82-0.html#0',2,'match82-1.html#0',3)" NAME="0">(124-151)<TD><A HREF="javascript:ZweiFrames('match82-0.html#0',2,'match82-1.html#0',3)" NAME="0">(200-227)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match82-0.html#1',2,'match82-1.html#1',3)" NAME="1">(93-120)<TD><A HREF="javascript:ZweiFrames('match82-0.html#1',2,'match82-1.html#1',3)" NAME="1">(160-187)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match82-0.html#2',2,'match82-1.html#2',3)" NAME="2">(66-89)<TD><A HREF="javascript:ZweiFrames('match82-0.html#2',2,'match82-1.html#2',3)" NAME="2">(124-147)</A><TD ALIGN=center><FONT COLOR="#e70000">20</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match82-0.html#3',2,'match82-1.html#3',3)" NAME="3">(38-62)<TD><A HREF="javascript:ZweiFrames('match82-0.html#3',2,'match82-1.html#3',3)" NAME="3">(87-111)</A><TD ALIGN=center><FONT COLOR="#e70000">20</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_api_hash_sha1.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * This file is part of cryptopp-bindings-api.
 *
 * (c) Stephen Berquet &lt;stephen.berquet@gmail.com&gt;
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

#include &quot;src/hash/api_hash_sha1.h&quot;
#include &quot;src/mac/api_mac_hmac.h&quot;
#include &quot;src/utils/api_hex_utils.h&quot;
#include &quot;tests/test_api_assertions.h&quot;
#include &lt;gtest/gtest.h&gt;

TEST(HashSha1Test, inheritance) {
    CryptoppApi::HashSha1 hash;

    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::HashTransformationInterface*&gt;(&amp;hash));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::HashInterface*&gt;(&amp;hash));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::HashAbstract*&gt;(&amp;hash));
}

TEST(HashSha1Test, infos) {
    CryptoppApi::HashSha1 hash;

    EXPECT_STREQ(&quot;sha1&quot;, hash.getName());
    EXPECT_EQ(64, hash.getBlockSize());
    EXPECT_EQ(20, hash.getDigestSize());
}

TEST(HashSha1Test, calculateDigest) {
    CryptoppApi::HashSha1 hash;

<A NAME="3"></A>    // build expected digests
    byte *expected1;
    byte *expected2;
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match82-1.html#3',3,'match82-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    size_t expected1Length = 0;
    size_t expected2Length = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;b0399d2029f64d445bd131ffaa399a42d2f8e7dc&quot;, 40, &amp;expected1, expected1Length);
    CryptoppApi::HexUtils::hex2bin(&quot;9cf95dacd226dcf43da376cdb6cbba7035218921&quot;, 40, &amp;expected2, expected2Length);

    // calculate actual digests
    const char *input1  = &quot;qwertyuiop&quot;;
    const char *input2  = &quot;azerty&quot;;
    size_t digestSize   = hash.getDigestSize();
    byte actual1[digestSize];
    byte actual2[digestSize];

    hash.calculateDigest(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1), actual1);
    hash.calculateDigest(reinterpret_cast&lt;const byte*&gt;(input2), strlen(input2), actual2);

    // test digests
    EXPECT_BYTE_ARRAY_EQ(expected1, expected1Length, actual1, digestSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, expected2Length, actual2, digestSize);

    delete[] expected1;
    delete[] expected2;
}

TEST(HashSha1Test, update) {
    CryptoppApi::HashSha1 hash;</B></FONT>
<A NAME="2"></A>
    // build expected digest
    byte *expected;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match82-1.html#2',3,'match82-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    size_t expectedLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;b0399d2029f64d445bd131ffaa399a42d2f8e7dc&quot;, 40, &amp;expected, expectedLength);

    // calculate actual digest
    const char *input1  = &quot;qwerty&quot;;
    const char *input2  = &quot;uio&quot;;
    const char *input3  = &quot;p&quot;;
    size_t digestSize   = hash.getDigestSize();
    byte actual[digestSize];

    hash.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    hash.update(reinterpret_cast&lt;const byte*&gt;(input2), strlen(input2));
    hash.update(reinterpret_cast&lt;const byte*&gt;(input3), strlen(input3));

    hash.finalize(actual);

    // test digests
    EXPECT_BYTE_ARRAY_EQ(expected, expectedLength, actual, digestSize);

    delete[] expected;
}

TEST(HashSha1Test, restartNotNecessaryAfterFinalize) {
    CryptoppApi::HashSha1 hash;</B></FONT>
<A NAME="1"></A>
    // build expected digest
    byte *expected;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match82-1.html#1',3,'match82-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    size_t expectedLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;b0399d2029f64d445bd131ffaa399a42d2f8e7dc&quot;, 40, &amp;expected, expectedLength);

    // calculate actual digest
    const char *input1  = &quot;qwerty&quot;;
    const char *input2  = &quot;uio&quot;;
    const char *input3  = &quot;p&quot;;
    size_t digestSize   = hash.getDigestSize();
    byte actual[digestSize];

    hash.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    hash.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    hash.finalize(actual);

    hash.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    hash.update(reinterpret_cast&lt;const byte*&gt;(input2), strlen(input2));
    hash.update(reinterpret_cast&lt;const byte*&gt;(input3), strlen(input3));

    hash.finalize(actual);

    // test digests
    EXPECT_BYTE_ARRAY_EQ(expected, expectedLength, actual, digestSize);

    delete[] expected;
}

TEST(HashSha1Test, restart) {
    CryptoppApi::HashSha1 hash;</B></FONT>
<A NAME="0"></A>
    // build expected digest
    byte *expected;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match82-1.html#0',3,'match82-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    size_t expectedLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;b0399d2029f64d445bd131ffaa399a42d2f8e7dc&quot;, 40, &amp;expected, expectedLength);

    // calculate actual digest
    const char *input1  = &quot;qwerty&quot;;
    const char *input2  = &quot;uio&quot;;
    const char *input3  = &quot;p&quot;;
    size_t digestSize   = hash.getDigestSize();
    byte actual[digestSize];

    hash.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    hash.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    hash.restart();

    hash.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    hash.update(reinterpret_cast&lt;const byte*&gt;(input2), strlen(input2));
    hash.update(reinterpret_cast&lt;const byte*&gt;(input3), strlen(input3));

    hash.finalize(actual);

    // test digests
    EXPECT_BYTE_ARRAY_EQ(expected, expectedLength, actual, digestSize);

    delete[] expected;
}

TEST(HashSha1Test, largeData) {
    CryptoppApi::HashSha1 hash;</B></FONT>

    size_t digestSize   = hash.getDigestSize();
    byte *input         = new byte[10485760];
    byte output[digestSize];

    hash.calculateDigest(input, 10485760, output);
    hash.update(input, 10485760);
    hash.finalize(output);

    delete[] input;
}

TEST(HashSha1Test, hmac) {
    CryptoppApi::HashSha1 hash;
    CryptoppApi::MacHmac mac(&amp;hash);

    // build expected digest
    byte *expected;
    size_t expectedLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;675b0b3a1b4ddf4e124872da6c2f632bfed957e9&quot;, 40, &amp;expected, expectedLength);

    // calculate digest
    std::string inputStr(&quot;Hi There&quot;);
    const byte *input   = reinterpret_cast&lt;const byte*&gt;(inputStr.c_str());
    size_t inputLength  = inputStr.length();

    byte *key;
    size_t keyLength    = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b&quot;, 32, &amp;key, keyLength);
    mac.setKey(key, keyLength);

    byte actual[mac.getDigestSize()];
    mac.calculateDigest(input, inputLength, actual);
    EXPECT_BYTE_ARRAY_EQ(expected, expectedLength, actual, mac.getDigestSize());

    delete[] expected;
    delete[] key;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_api_mac_cmac.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * This file is part of cryptopp-bindings-api.
 *
 * (c) Stephen Berquet &lt;stephen.berquet@gmail.com&gt;
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

#include &quot;src/exception/api_exception.h&quot;
#include &quot;src/keying/api_symmetric_key_abstract.h&quot;
#include &quot;src/mac/api_mac_cmac.h&quot;
#include &quot;src/symmetric/cipher/block/api_block_cipher_aes.h&quot;
#include &quot;src/utils/api_hex_utils.h&quot;
#include &quot;tests/test_api_assertions.h&quot;
#include &lt;gtest/gtest.h&gt;

TEST(MacCmacTest, inheritance) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::MacCmac mac(&amp;cipher);

    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::HashTransformationInterface*&gt;(&amp;mac));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::MacInterface*&gt;(&amp;mac));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::MacAbstract*&gt;(&amp;mac));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricKeyAbstract*&gt;(&amp;mac));
}

TEST(MacCmacTest, infos) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::MacCmac mac(&amp;cipher);

    EXPECT_STREQ(&quot;cmac(aes)&quot;, mac.getName());
    EXPECT_EQ(0, mac.getBlockSize());
    EXPECT_EQ(16, mac.getDigestSize());
}

TEST(MacCmacTest, isValidKeyLength) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::MacCmac mac(&amp;cipher);

    EXPECT_TRUE(mac.isValidKeyLength(32));
    EXPECT_TRUE(mac.isValidKeyLength(24));
    EXPECT_TRUE(mac.isValidKeyLength(16));
    EXPECT_FALSE(mac.isValidKeyLength(23));
    EXPECT_FALSE(mac.isValidKeyLength(125));
    EXPECT_FALSE(mac.isValidKeyLength(0));
}

TEST(MacCmacTest, setGetKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::MacCmac mac(&amp;cipher);

    // set key
    byte *key;
    size_t keyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;0102030405060708090a0b0c0d0e0f10&quot;, 32, &amp;key, keyLength);

    mac.setKey(key, keyLength);

    // get key
    size_t key2Length   = mac.getKeyLength();
    byte *key2          = new byte[key2Length];
    mac.getKey(key2);

    // test key
    EXPECT_BYTE_ARRAY_EQ(key, keyLength, key2, key2Length);

    delete[] key;
    delete[] key2;
}

TEST(MacCmacTest, calculateDigest) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::MacCmac mac(&amp;cipher);

    // set key
    byte *key;
    size_t keyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

    mac.setKey(key, keyLength);
    delete[] key;

<A NAME="3"></A>    // build expected digests
    byte *expected1;
    byte *expected2;
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match82-0.html#3',2,'match82-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    size_t expected1Length = 0;
    size_t expected2Length = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;caa7624159a7b2f383509739843c8f3f&quot;, 32, &amp;expected1, expected1Length);
    CryptoppApi::HexUtils::hex2bin(&quot;6cc65b89ebbfbbb933a0db79d8c5f629&quot;, 32, &amp;expected2, expected2Length);

    // calculate actual digests
    const char *input1  = &quot;qwertyuiop&quot;;
    const char *input2  = &quot;azerty&quot;;
    size_t digestSize   = mac.getDigestSize();
    byte actual1[digestSize];
    byte actual2[digestSize];

    mac.calculateDigest(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1), actual1);
    mac.calculateDigest(reinterpret_cast&lt;const byte*&gt;(input2), strlen(input2), actual2);

    // test digests
    EXPECT_BYTE_ARRAY_EQ(expected1, expected1Length, actual1, digestSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, expected2Length, actual2, digestSize);

    delete[] expected1;
    delete[] expected2;
}

TEST(MacCmacTest, update) {
    CryptoppApi::BlockCipherAes cipher;</B></FONT>
    CryptoppApi::MacCmac mac(&amp;cipher);

    // set key
    byte *key;
    size_t keyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

    mac.setKey(key, keyLength);
    delete[] key;
<A NAME="2"></A>
    // build expected digest
    byte *expected;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match82-0.html#2',2,'match82-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    size_t expectedLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;caa7624159a7b2f383509739843c8f3f&quot;, 32, &amp;expected, expectedLength);

    // calculate actual digest
    const char *input1  = &quot;qwerty&quot;;
    const char *input2  = &quot;uio&quot;;
    const char *input3  = &quot;p&quot;;
    size_t digestSize   = mac.getDigestSize();
    byte actual[digestSize];

    mac.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    mac.update(reinterpret_cast&lt;const byte*&gt;(input2), strlen(input2));
    mac.update(reinterpret_cast&lt;const byte*&gt;(input3), strlen(input3));

    mac.finalize(actual);

    // test digest
    EXPECT_BYTE_ARRAY_EQ(expected, expectedLength, actual, digestSize);

    delete[] expected;
}

TEST(MacCmacTest, restartNotNecessaryAfterFinalize) {
    CryptoppApi::BlockCipherAes cipher;</B></FONT>
    CryptoppApi::MacCmac mac(&amp;cipher);

    // set key
    byte *key;
    size_t keyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

    mac.setKey(key, keyLength);
    delete[] key;
<A NAME="1"></A>
    // build expected digest
    byte *expected;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match82-0.html#1',2,'match82-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    size_t expectedLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;caa7624159a7b2f383509739843c8f3f&quot;, 32, &amp;expected, expectedLength);

    // calculate actual digest
    const char *input1  = &quot;qwerty&quot;;
    const char *input2  = &quot;uio&quot;;
    const char *input3  = &quot;p&quot;;
    size_t digestSize   = mac.getDigestSize();
    byte actual[digestSize];

    mac.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    mac.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    mac.finalize(actual);

    mac.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    mac.update(reinterpret_cast&lt;const byte*&gt;(input2), strlen(input2));
    mac.update(reinterpret_cast&lt;const byte*&gt;(input3), strlen(input3));

    mac.finalize(actual);

    // test digest
    EXPECT_BYTE_ARRAY_EQ(expected, expectedLength, actual, digestSize);

    delete[] expected;
}

TEST(MacCmacTest, restart) {
    CryptoppApi::BlockCipherAes cipher;</B></FONT>
    CryptoppApi::MacCmac mac(&amp;cipher);

    // set key
    byte *key;
    size_t keyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

    mac.setKey(key, keyLength);
    delete[] key;
<A NAME="0"></A>
    // build expected digest
    byte *expected;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match82-0.html#0',2,'match82-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    size_t expectedLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;caa7624159a7b2f383509739843c8f3f&quot;, 32, &amp;expected, expectedLength);

    // calculate actual digest
    const char *input1  = &quot;qwerty&quot;;
    const char *input2  = &quot;uio&quot;;
    const char *input3  = &quot;p&quot;;
    size_t digestSize   = mac.getDigestSize();
    byte actual[digestSize];

    mac.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    mac.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    mac.restart();

    mac.update(reinterpret_cast&lt;const byte*&gt;(input1), strlen(input1));
    mac.update(reinterpret_cast&lt;const byte*&gt;(input2), strlen(input2));
    mac.update(reinterpret_cast&lt;const byte*&gt;(input3), strlen(input3));

    mac.finalize(actual);

    // test digest
    EXPECT_BYTE_ARRAY_EQ(expected, expectedLength, actual, digestSize);

    delete[] expected;
}

TEST(MacCmacTest, largeData) {
    CryptoppApi::BlockCipherAes cipher;</B></FONT>
    CryptoppApi::MacCmac mac(&amp;cipher);

    // set key
    byte *key;
    size_t keyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

    mac.setKey(key, keyLength);
    delete[] key;

    // calculate digest
    size_t digestSize   = mac.getDigestSize();
    byte *input         = new byte[10485760];
    byte output[digestSize];
    memset(input, 0, 10485760);

    mac.calculateDigest(input, 10485760, output);
    mac.update(input, 10485760);
    mac.finalize(output);

    delete[] input;
}

TEST(MacCmacTest, setEmptyKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::MacCmac mac(&amp;cipher);

    EXPECT_THROW_MSG(mac.setKey(NULL, 0), CryptoppApi::Exception, &quot;a key is required&quot;);
}

TEST(MacCmacTest, calculateDigestWithoutKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::MacCmac mac(&amp;cipher);

    // calculate digest without key
    size_t digestSize   = mac.getDigestSize();
    const char *input   = &quot;qwerty&quot;;
    byte actual[digestSize];

    EXPECT_THROW_MSG(mac.calculateDigest(reinterpret_cast&lt;const byte*&gt;(input), strlen(input), actual), CryptoppApi::Exception, &quot;a key is required&quot;);
    EXPECT_THROW_MSG(mac.update(reinterpret_cast&lt;const byte*&gt;(input), strlen(input)), CryptoppApi::Exception, &quot;a key is required&quot;);
    EXPECT_THROW_MSG(mac.finalize(actual), CryptoppApi::Exception, &quot;a key is required&quot;);
}

TEST(MacCmacTest, keyNotMatchingUnderlyingOne) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::MacCmac mac1(&amp;cipher);
    CryptoppApi::MacCmac mac2(&amp;cipher);

    std::string key1(&quot;1234567890123456&quot;);
    std::string key2(&quot;azertyuiopqwerty&quot;);
    std::string key3(&quot;wxcvbnqsdfghjklm&quot;);
    mac1.setKey(reinterpret_cast&lt;const byte*&gt;(key1.c_str()), key1.length());

    size_t inputLength = 20;
    byte input[inputLength];
    byte output[mac1.getDigestSize()];

    mac2.setKey(reinterpret_cast&lt;const byte*&gt;(key2.c_str()), key2.length());
    EXPECT_THROW_MSG(mac1.calculateDigest(input, inputLength, output), CryptoppApi::Exception, &quot;key is not matching the one owned by the underlying cipher object&quot;);

    cipher.setKey(reinterpret_cast&lt;const byte*&gt;(key3.c_str()), key3.length());
    EXPECT_THROW_MSG(mac1.calculateDigest(input, inputLength, output), CryptoppApi::Exception, &quot;key is not matching the one owned by the underlying cipher object&quot;);
}
</PRE>
</div>
  </div>
</body>
</html>
