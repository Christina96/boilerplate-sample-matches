
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_image_data_layer.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <fstream>
3  #include <map>
4  #include <string>
5  #include <vector>
6  #include "gtest/gtest.h"
7  #include "caffe/blob.hpp"
8  #include "caffe/common.hpp"
9  #include "caffe/filler.hpp"
10  #include "caffe/layers/image_data_layer.hpp"
11  #include "caffe/proto/caffe.pb.h"
12  #include "caffe/util/io.hpp"
13  #include "caffe/test/test_caffe_main.hpp"
14  namespace caffe {
15  template <typename TypeParam>
16  class ImageDataLayerTest : public MultiDeviceTest<TypeParam> {
17    typedef typename TypeParam::Dtype Dtype;
18   protected:
19    ImageDataLayerTest()
20        : seed_(1701),
21          blob_top_data_(new Blob<Dtype>()),
22          blob_top_label_(new Blob<Dtype>()) {}
23    virtual void SetUp() {
24      blob_top_vec_.push_back(blob_top_data_);
25      blob_top_vec_.push_back(blob_top_label_);
26      Caffe::set_random_seed(seed_);
27      MakeTempFilename(&filename_);
28      std::ofstream outfile(filename_.c_str(), std::ofstream::out);
29      LOG(INFO) << "Using temporary file " << filename_;
30      for (int i = 0; i < 5; ++i) {
31        outfile << EXAMPLES_SOURCE_DIR "images/cat.jpg " << i << std::endl;
32      }
33      outfile.close();
34      MakeTempFilename(&filename_reshape_);
35      std::ofstream reshapefile(filename_reshape_.c_str(), std::ofstream::out);
36      LOG(INFO) << "Using temporary file " << filename_reshape_;
37      reshapefile << EXAMPLES_SOURCE_DIR "images/cat.jpg " << 0 << std::endl;
38      reshapefile << EXAMPLES_SOURCE_DIR "images/fish-bike.jpg " << 1
39                  << std::endl;
40      reshapefile.close();
41      MakeTempFilename(&filename_space_);
42      std::ofstream spacefile(filename_space_.c_str(), std::ofstream::out);
43      LOG(INFO) << "Using temporary file " << filename_space_;
44      spacefile << EXAMPLES_SOURCE_DIR "images/cat.jpg " << 0 << std::endl;
45      spacefile << EXAMPLES_SOURCE_DIR "images/cat gray.jpg " << 1 << std::endl;
46      spacefile.close();
47    }
48    virtual ~ImageDataLayerTest() {
49      delete blob_top_data_;
50      delete blob_top_label_;
51    }
52    int seed_;
53    string filename_;
54    string filename_reshape_;
55    string filename_space_;
56    Blob<Dtype>* const blob_top_data_;
57    Blob<Dtype>* const blob_top_label_;
58    vector<Blob<Dtype>*> blob_bottom_vec_;
59    vector<Blob<Dtype>*> blob_top_vec_;
60  };
61  TYPED_TEST_CASE(ImageDataLayerTest, TestDtypesAndDevices);
62  template <typename Dtype>
63  static void write_blob_to_file(const std::string& file_name,
64          const Blob<Dtype>& blob) {
65    std::ofstream file(file_name.c_str(), std::ios::out | std::ios::binary);
66    if (file.fail())  {
67        ASSERT_FALSE(true);
68        return;
69    }
70    file.write(reinterpret_cast<const char*>(&blob.shape()[0]), 4 * sizeof(int));
71    ASSERT_FALSE(file.fail());
72    file.write(reinterpret_cast<const char*>(blob.cpu_data()),
73            blob.count() * sizeof(Dtype));
74    ASSERT_FALSE(file.fail());
75    file.close();
76  }
77  template <typename Dtype>
78  static void read_blob_from_file(const std::string& file_name,
79          Blob<Dtype>& blob) {
80    std::ifstream file(file_name.c_str(), std::ifstream::binary);
81    if (file.fail()) {
82        ASSERT_FALSE(true);
83        return;
84    }
85    vector<int> shape(4, 0);
86    file.read(reinterpret_cast<char*>(&shape[0]), 4 * sizeof(int));
87    ASSERT_FALSE(file.fail());
88    blob.Reshape(shape);
89    file.read(reinterpret_cast<char*>(blob.mutable_cpu_data()),
90            blob.count() * sizeof(Dtype));
91    ASSERT_FALSE(file.fail());
92  }
93  TYPED_TEST(ImageDataLayerTest, TestRead) {
94    typedef typename TypeParam::Dtype Dtype;
95    std::string file_name = std::string(EXAMPLES_SOURCE_DIR)+
96            std::string("test_blobs/ImageDataLayerTest_TestRead_")+
97            std::string(typeid(Dtype).name())+std::string(".blob");
98    LayerParameter param;
99    ImageDataParameter* image_data_param = param.mutable_image_data_param();
100    image_data_param->set_batch_size(5);
101    image_data_param->set_source(this->filename_.c_str());
102    image_data_param->set_shuffle(false);
103    ImageDataLayer<Dtype> layer(param);
104    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
105    EXPECT_EQ(this->blob_top_data_->num(), 5);
106    EXPECT_EQ(this->blob_top_data_->channels(), 3);
107    EXPECT_EQ(this->blob_top_data_->height(), 360);
108    EXPECT_EQ(this->blob_top_data_->width(), 480);
109    EXPECT_EQ(this->blob_top_label_->num(), 5);
110    EXPECT_EQ(this->blob_top_label_->channels(), 1);
111    EXPECT_EQ(this->blob_top_label_->height(), 1);
112    EXPECT_EQ(this->blob_top_label_->width(), 1);
113    for (int iter = 0; iter < 2; ++iter)  {
114      layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
115      for (int i = 0; i < 5; ++i) {
<span onclick='openModal()' class='match'>116        EXPECT_EQ(i, this->blob_top_label_->cpu_data()[i]);
117      }
</span>118  #ifdef GENERATE_IDL_TEST_DATA
119      write_blob_to_file(file_name, *this->blob_top_data_);
120  #endif
121      Blob<Dtype> tmp_blob;
122      read_blob_from_file(file_name, tmp_blob);
123      EXPECT_EQ(0, memcmp(this->blob_top_data_->cpu_data(), tmp_blob.cpu_data(),
124              sizeof(Dtype)*this->blob_top_data_->count()));
125    }
126  }
127  TYPED_TEST(ImageDataLayerTest, TestResize) {
128    typedef typename TypeParam::Dtype Dtype;
129    std::string file_name = std::string(EXAMPLES_SOURCE_DIR) +
130            std::string("test_blobs/ImageDataLayerTest_TestResize_")
131            +std::string(typeid(Dtype).name())+std::string(".blob");
132    LayerParameter param;
133    ImageDataParameter* image_data_param = param.mutable_image_data_param();
134    image_data_param->set_batch_size(5);
135    image_data_param->set_source(this->filename_.c_str());
136    image_data_param->set_new_height(256);
137    image_data_param->set_new_width(256);
138    image_data_param->set_shuffle(false);
139    ImageDataLayer<Dtype> layer(param);
140    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
141    EXPECT_EQ(this->blob_top_data_->num(), 5);
142    EXPECT_EQ(this->blob_top_data_->channels(), 3);
143    EXPECT_EQ(this->blob_top_data_->height(), 256);
144    EXPECT_EQ(this->blob_top_data_->width(), 256);
145    EXPECT_EQ(this->blob_top_label_->num(), 5);
146    EXPECT_EQ(this->blob_top_label_->channels(), 1);
147    EXPECT_EQ(this->blob_top_label_->height(), 1);
148    EXPECT_EQ(this->blob_top_label_->width(), 1);
149    for (int iter = 0; iter < 2; ++iter) {
150      layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
151      for (int i = 0; i < 5; ++i) {
152        EXPECT_EQ(i, this->blob_top_label_->cpu_data()[i]);
153      }
154  #ifdef GENERATE_IDL_TEST_DATA
155      write_blob_to_file(file_name, *this->blob_top_data_);
156  #endif
157      Blob<Dtype> tmp_blob;
158      read_blob_from_file(file_name, tmp_blob);
159      EXPECT_EQ(0, memcmp(this->blob_top_data_->cpu_data(), tmp_blob.cpu_data(),
160              sizeof(Dtype)*this->blob_top_data_->count()));
161    }
162  }
163  TYPED_TEST(ImageDataLayerTest, TestReshape) {
164    typedef typename TypeParam::Dtype Dtype;
165    LayerParameter param;
166    ImageDataParameter* image_data_param = param.mutable_image_data_param();
167    image_data_param->set_batch_size(1);
168    image_data_param->set_source(this->filename_reshape_.c_str());
169    image_data_param->set_shuffle(false);
170    ImageDataLayer<Dtype> layer(param);
171    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
172    EXPECT_EQ(this->blob_top_label_->num(), 1);
173    EXPECT_EQ(this->blob_top_label_->channels(), 1);
174    EXPECT_EQ(this->blob_top_label_->height(), 1);
175    EXPECT_EQ(this->blob_top_label_->width(), 1);
176    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
177    EXPECT_EQ(this->blob_top_data_->num(), 1);
178    EXPECT_EQ(this->blob_top_data_->channels(), 3);
179    EXPECT_EQ(this->blob_top_data_->height(), 360);
180    EXPECT_EQ(this->blob_top_data_->width(), 480);
181    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
182    EXPECT_EQ(this->blob_top_data_->num(), 1);
183    EXPECT_EQ(this->blob_top_data_->channels(), 3);
184    EXPECT_EQ(this->blob_top_data_->height(), 323);
185    EXPECT_EQ(this->blob_top_data_->width(), 481);
186  }
187  TYPED_TEST(ImageDataLayerTest, TestShuffle) {
188    typedef typename TypeParam::Dtype Dtype;
189    std::string file_name = std::string(EXAMPLES_SOURCE_DIR) +
190            std::string("test_blobs/ImageDataLayerTest_TestShuffle_")+
191            std::string(typeid(Dtype).name())+std::string(".blob");
192    LayerParameter param;
193    ImageDataParameter* image_data_param = param.mutable_image_data_param();
194    image_data_param->set_batch_size(5);
195    image_data_param->set_source(this->filename_.c_str());
196    image_data_param->set_shuffle(true);
197    ImageDataLayer<Dtype> layer(param);
198    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
199    EXPECT_EQ(this->blob_top_data_->num(), 5);
200    EXPECT_EQ(this->blob_top_data_->channels(), 3);
201    EXPECT_EQ(this->blob_top_data_->height(), 360);
202    EXPECT_EQ(this->blob_top_data_->width(), 480);
203    EXPECT_EQ(this->blob_top_label_->num(), 5);
204    EXPECT_EQ(this->blob_top_label_->channels(), 1);
205    EXPECT_EQ(this->blob_top_label_->height(), 1);
206    EXPECT_EQ(this->blob_top_label_->width(), 1);
207    for (int iter = 0; iter < 2; ++iter) {
208      layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
209      map<Dtype, int> values_to_indices;
210      int num_in_order = 0;
211      for (int i = 0; i < 5; ++i) {
212        Dtype value = this->blob_top_label_->cpu_data()[i];
213        EXPECT_EQ(values_to_indices.find(value), values_to_indices.end());
214        values_to_indices[value] = i;
215        num_in_order += (value == Dtype(i));
216      }
217      EXPECT_EQ(5, values_to_indices.size());
218      EXPECT_GT(5, num_in_order);
219  #ifdef GENERATE_IDL_TEST_DATA
220      write_blob_to_file(file_name, *this->blob_top_data_);
221  #endif
222      Blob<Dtype> tmp_blob;
223      read_blob_from_file(file_name, tmp_blob);
224      EXPECT_EQ(0, memcmp(this->blob_top_data_->cpu_data(), tmp_blob.cpu_data(),
225              sizeof(Dtype)*this->blob_top_data_->count()));
226    }
227  }
228  TYPED_TEST(ImageDataLayerTest, TestSpace) {
229    typedef typename TypeParam::Dtype Dtype;
230    LayerParameter param;
231    ImageDataParameter* image_data_param = param.mutable_image_data_param();
232    image_data_param->set_batch_size(1);
233    image_data_param->set_source(this->filename_space_.c_str());
234    image_data_param->set_shuffle(false);
235    ImageDataLayer<Dtype> layer(param);
236    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
237    EXPECT_EQ(this->blob_top_label_->num(), 1);
238    EXPECT_EQ(this->blob_top_label_->channels(), 1);
239    EXPECT_EQ(this->blob_top_label_->height(), 1);
240    EXPECT_EQ(this->blob_top_label_->width(), 1);
241    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
242    EXPECT_EQ(this->blob_top_data_->num(), 1);
243    EXPECT_EQ(this->blob_top_data_->channels(), 3);
244    EXPECT_EQ(this->blob_top_data_->height(), 360);
245    EXPECT_EQ(this->blob_top_data_->width(), 480);
246    EXPECT_EQ(this->blob_top_label_->cpu_data()[0], 0);
247    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
248    EXPECT_EQ(this->blob_top_data_->num(), 1);
249    EXPECT_EQ(this->blob_top_data_->channels(), 3);
250    EXPECT_EQ(this->blob_top_data_->height(), 360);
251    EXPECT_EQ(this->blob_top_data_->width(), 480);
252    EXPECT_EQ(this->blob_top_label_->cpu_data()[0], 1);
253  }
254  }  
255  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkldnn_split_layer.cpp</h3>
            <pre><code>1  #if defined(MKLDNN_SUPPORTED)
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/mkldnn_layers.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename TypeParam>
12  class MKLDNNSplitLayerTest : public MultiDeviceTest<TypeParam> {
13    typedef typename TypeParam::Dtype Dtype;
14   protected:
15    MKLDNNSplitLayerTest()
16        : blob_bottom_(new Blob<Dtype>(2, 3, 6, 5)),
17          blob_top_a_(new Blob<Dtype>()),
18          blob_top_b_(new Blob<Dtype>()) {
19      FillerParameter filler_param;
20      GaussianFiller<Dtype> filler(filler_param);
21      filler.Fill(this->blob_bottom_);
22      blob_bottom_vec_.push_back(blob_bottom_);
23      blob_top_vec_.push_back(blob_top_a_);
24      blob_top_vec_.push_back(blob_top_b_);
25    }
26    virtual ~MKLDNNSplitLayerTest() {
27      delete blob_bottom_;
28      delete blob_top_a_;
29      delete blob_top_b_;
30    }
31    Blob<Dtype>* const blob_bottom_;
32    Blob<Dtype>* const blob_top_a_;
33    Blob<Dtype>* const blob_top_b_;
34    vector<Blob<Dtype>*> blob_bottom_vec_;
35    vector<Blob<Dtype>*> blob_top_vec_;
36  };
37  typedef ::testing::Types<CPUDevice<float> > TestDtypesCPU;
38  TYPED_TEST_CASE(MKLDNNSplitLayerTest, TestDtypesCPU);
39  TYPED_TEST(MKLDNNSplitLayerTest, TestSetup) {
40    typedef typename TypeParam::Dtype Dtype;
41    LayerParameter layer_param;
42    MKLDNNSplitLayer<Dtype> layer(layer_param);
43    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
44    EXPECT_EQ(this->blob_top_a_->num(), 2);
45    EXPECT_EQ(this->blob_top_a_->channels(), 3);
46    EXPECT_EQ(this->blob_top_a_->height(), 6);
47    EXPECT_EQ(this->blob_top_a_->width(), 5);
48    EXPECT_EQ(this->blob_top_b_->num(), 2);
49    EXPECT_EQ(this->blob_top_b_->channels(), 3);
50    EXPECT_EQ(this->blob_top_b_->height(), 6);
51    EXPECT_EQ(this->blob_top_b_->width(), 5);
52  }
53  TYPED_TEST(MKLDNNSplitLayerTest, Test) {
54    typedef typename TypeParam::Dtype Dtype;
55    LayerParameter layer_param;
56    MKLDNNSplitLayer<Dtype> layer(layer_param);
57    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
58    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
59    for (int i = 0; i < this->blob_bottom_->count(); ++i) {
60      Dtype bottom_value = this->blob_bottom_->cpu_data()[i];
61      EXPECT_EQ(bottom_value, this->blob_top_a_->cpu_data()[i]);
<span onclick='openModal()' class='match'>62      EXPECT_EQ(bottom_value, this->blob_top_b_->cpu_data()[i]);
63    }
</span>64  }
65  TYPED_TEST(MKLDNNSplitLayerTest, TestGradient) {
66    typedef typename TypeParam::Dtype Dtype;
67    LayerParameter layer_param;
68    MKLDNNSplitLayer<Dtype> layer(layer_param);
69    GradientChecker<Dtype> checker(1e-2, 1e-2);
70    checker.CheckGradientEltwise(&layer, this->blob_bottom_vec_,
71        this->blob_top_vec_);
72  }
73  }
74  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_image_data_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkldnn_split_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>116        EXPECT_EQ(i, this->blob_top_label_->cpu_data()[i]);
117      }
</pre></code></div>
                <div class="column column_space"><pre><code>62      EXPECT_EQ(bottom_value, this->blob_top_b_->cpu_data()[i]);
63    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    