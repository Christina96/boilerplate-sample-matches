
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.477124183006536%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-postag.cpp</h3>
            <pre><code>1  #include <postag.h>
2  TPosTagType TPosElt::GetTypeFromAna(const TStr& AnaType) {
3      if (AnaType.Empty()) {  return pttUndef; }
4      switch (AnaType[0]) {
5          case 'N': return pttNoun;
6          case 'V': return pttVerb;
7          case 'A': return pttAdjective;
8          case 'R': return pttAdverb;
9          case 'P': return pttPronoun;
10          case 'S': return pttAdposition;
11          case 'C': return pttConjunction;
12          case 'Q': return pttParticle;
13          case 'I': return pttInterjection;
14          case 'M': return pttNumeral;
15          case 'Y': return pttAbbreviation;
16          case 'X': return pttResidual;
17          default: return pttUndef;
18      }
19  }
20  void TPosSentBs::MakeSplit(const int& Train, const int& Test) {
21      if (Train == -1) {
22          TestSents = TInt::GetMn(Test, GetSents());
23          TrainSents = GetSents() - TestSents;
24      } else if (Test == -1) { 
25          TrainSents = TInt::GetMn(Train, GetSents());
26          TestSents = GetSents() - TrainSents;
27      } else {
28          TrainSents = TInt::GetMn(Train, GetSents());
29          TestSents = TInt::GetMn(Test, GetSents()-TrainSents);
30      }
31  }
32  int TPosSentBs::CompareSent(const TPosSent& OrgSent, const TPosSent& PredSent) const {
33      IAssert(OrgSent.GetElts() == PredSent.GetElts());
34      int MatchCount = 0;
35      for (int EltN = 2; EltN < (OrgSent.GetElts()-1); EltN++) {
36          const TPosTagType OrgTagType = OrgSent.GetElt(EltN).GetPosTagType();
37          const TPosTagType PredTagType = PredSent.GetElt(EltN).GetPosTagType();
38          if (OrgTagType == PredTagType) { MatchCount++; }
39      }
40      return MatchCount;
41  }
42  int TPosSentBs::CompareSentKnown(const TPosSent& OrgSent, 
43          const TPosSent& PredSent, const PPosHmm& Hmm) const {
44      IAssert(OrgSent.GetElts() == PredSent.GetElts());
45      int MatchCount = 0;
46      for (int EltN = 2; EltN < (OrgSent.GetElts()-1); EltN++) {
47          if (!Hmm->IsKnown(OrgSent.GetElt(EltN).GetLemmaStr())) { continue; }
48          const TPosTagType OrgTagType = OrgSent.GetElt(EltN).GetPosTagType();
49          const TPosTagType PredTagType = PredSent.GetElt(EltN).GetPosTagType();
50          if (OrgTagType == PredTagType) { MatchCount++; }
51      }
52      return MatchCount;
53  }
54  int TPosSentBs::CompareSentUnknown(const TPosSent& OrgSent, 
55          const TPosSent& PredSent, const PPosHmm& Hmm) const {
56      IAssert(OrgSent.GetElts() == PredSent.GetElts());
57      int MatchCount = 0;
58      for (int EltN = 2; EltN < (OrgSent.GetElts()-1); EltN++) {
59          if (Hmm->IsKnown(OrgSent.GetElt(EltN).GetLemmaStr())) { continue; }
60          const TPosTagType OrgTagType = OrgSent.GetElt(EltN).GetPosTagType();
61          const TPosTagType PredTagType = PredSent.GetElt(EltN).GetPosTagType();
62          if (OrgTagType == PredTagType) { MatchCount++; }
63      }
64      return MatchCount;
65  }
66  PPosSentBs TPosSentBs::LoadMte(const TStr& XmlFNm) {
67      PPosSentBs PosSentBs = TPosSentBs::New();
68      printf("Loading XML ... ");
69      PSIn XmlSIn = TFIn::New(XmlFNm);
70      PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
71      PXmlTok TopTok = XmlDoc->GetTok();
72      printf("done\n");
73      TXmlTokV PartTokV; TopTok->GetTagTokV("text|body|div", PartTokV);
74      printf("Loading %d parts ... ", PartTokV.Len());
75      int AllSubParts = 0, AllParas = 0, AllSents = 0, AllWords = 0;
76      for (int PartN = 0; PartN < PartTokV.Len(); PartN++) {
77          PXmlTok PartTok = PartTokV[PartN];
78          const int SubParts = PartTok->GetSubToks(); AllSubParts += SubParts;
79          for (int SubPartN = 0; SubPartN < SubParts; SubPartN++) {
80              PXmlTok SubPartTok = PartTok->GetSubTok(SubPartN);
81              if (SubPartTok->GetStrArgVal("type", "") == "appendix") { continue; }
82              const int Paras = SubPartTok->GetSubToks();
83              for (int ParaN = 0; ParaN < Paras; ParaN++) {
84                  PXmlTok ParaTok = SubPartTok->GetSubTok(ParaN);
85                  if (!ParaTok->IsTag()) { continue; } AllParas++;
86                  const int Sents = ParaTok->GetSubToks();
87                  for (int SentN = 0; SentN < Sents; SentN++) {
88                      PXmlTok SentTok = ParaTok->GetSubTok(SentN);
89                      if (!SentTok->IsTag()) { continue; } AllSents++;
90                      const int Words = SentTok->GetSubToks();
91                      TPosSent PosSent;
92                      PosSent.AddElt(TPosElt(pttBegining)); 
93                      PosSent.AddElt(TPosElt(pttBegining)); 
94                      for (int WordN = 0; WordN < Words; WordN++) {
95                          PXmlTok WordTok = SentTok->GetSubTok(WordN);
96                          if (!WordTok->IsTag()) { continue; } AllWords++;
97                          if (WordTok->GetTagNm() == "w") {
98                              TStr WordStr = WordTok->GetTokStr(false);
99                              TStr LemmaStr = WordTok->GetStrArgVal("lemma", "");
100                              TStr AnaType = WordTok->GetStrArgVal("ana", "");
101                              const TPosTagType PosTagType = TPosElt::GetTypeFromAna(AnaType);
102                              PosSent.AddElt(TPosElt(WordStr, LemmaStr, PosTagType));
103                          }
104                      }
105                      PosSent.AddElt(TPosElt(pttEnd)); 
106                      if (PosSent.GetElts() > 3) { PosSentBs->AddSent(PosSent); }
107                  }
108              }
109          }
110      }
111      printf("Done (Chapters:%d, Paragraphs:%d, Sentences:%d, Words:%d)\n",
112          AllSubParts, AllParas, AllSents, AllWords);
113      return PosSentBs;
114  }
115  void TPosHmm::LearnProb(const PPosSentBs& PosSentBs, int& Tokens, 
116          TIntPrIntH& BigramCountH, TIntTrIntH& TrigramCountH,
117          TIntPrIntH& LexicalCountH) {
118      LemmaH.Clr(); StateH.Clr();
119      Tokens = 0; BigramCountH.Clr();
120      TrigramCountH.Clr(); LexicalCountH.Clr(); 
121      const int Sents = PosSentBs->GetTrainSents();
122      printf("Counting %d sentences ... ", Sents);
123      for (int SentN = 0; SentN < Sents; SentN++) {
124          const TPosSent& Sent = PosSentBs->GetTrainSent(SentN);
125          const int Elts = Sent.GetElts();
126          int OldState = -1, OldOldState = -1;
127          for (int EltN = 0; EltN < Elts; EltN++) {
128              const TPosElt& Elt = Sent.GetElt(EltN);           
129              const int LemmaId = LemmaH.AddKey(Elt.GetLemmaStr());
130              LemmaH[LemmaId]++; 
131              const int State = int(Elt.GetPosTagType());
132              StateH.AddDat(State)++;
133              Tokens++;
134              if (EltN > 0) { 
135                  IAssert(OldState != -1);
136                  BigramCountH.AddDat(TIntPr(OldState, State))++;
137              }
138              if (EltN > 1) {
139                  IAssert(OldState != -1 && OldOldState != -1);
140                  TrigramCountH.AddDat(TIntTr(OldOldState, OldState, State))++;
141              }
142              LexicalCountH.AddDat(TIntPr(LemmaId, State))++;
143              OldOldState = OldState;
144              OldState = State;
145          }
146      }
147      printf("Done (Lemmas:%d States:%d, Bigrams:%d, Trigrams:%d, Lexical:%d)\n", LemmaH.Len(), 
148          StateH.Len(), BigramCountH.Len(), TrigramCountH.Len(), LexicalCountH.Len());
149      StateProbH.Clr(); BigramProbH.Clr();
150      TrigramProbH.Clr(); LexicalProbH.Clr();
151      printf("Calculating probabilities ... ");
152      {printf("States ");
153      IAssert(Tokens > 0);
154      int KeyId = StateH.FFirstKeyId(); double ProbSum = 0.0; 
155      while (StateH.FNextKeyId(KeyId)) {
156          const int State = StateH.GetKey(KeyId);
157          const int StateCount = StateH[KeyId];        
158          const double Prob = double(StateCount) / double(Tokens);
159          StateProbH.AddDat(State, Prob);
160          ProbSum += Prob;
161      }printf("(%g) ... ", ProbSum);}
162      {printf("Bigrams ");
163      int KeyId = BigramCountH.FFirstKeyId(); double ProbSum = 0.0;
164      while (BigramCountH.FNextKeyId(KeyId)) {
165          const TIntPr& Bigram = BigramCountH.GetKey(KeyId);
166          const int BigramCount = BigramCountH[KeyId];
167          const int OldStateCount = StateH.GetDat(Bigram.Val1); 
168          IAssert(OldStateCount > 0);        
169          const double Prob = double(BigramCount) / double (OldStateCount);
170          BigramProbH.AddDat(Bigram, Prob);
171          ProbSum += Prob;
172      }printf("(%g) ... ", ProbSum);}
173      {printf("Trigrams ");
174      int KeyId = TrigramCountH.FFirstKeyId(); double ProbSum = 0.0;
175      while (TrigramCountH.FNextKeyId(KeyId)) {
176          const TIntTr& Trigram = TrigramCountH.GetKey(KeyId);
177          const int TrigramCount = TrigramCountH[KeyId];
178          TIntPr OldBigram(Trigram.Val1, Trigram.Val2);
179          const int OldBigramCount = BigramCountH.GetDat(OldBigram);
180          IAssert(OldBigramCount > 0);
181          const double Prob = double(TrigramCount) / double(OldBigramCount);
182          TrigramProbH.AddDat(Trigram, Prob);
183          ProbSum += Prob;
184      }printf("(%g) ... ", ProbSum);}
185      {printf("Lexical ");
186      int KeyId = LexicalCountH.FFirstKeyId(); double ProbSum = 0.0;
187      while (LexicalCountH.FNextKeyId(KeyId)) {
188          const TIntPr& Lexical = LexicalCountH.GetKey(KeyId);
189          const int LexicalCount = LexicalCountH[KeyId];
190          const int StateCount = StateH.GetDat(Lexical.Val2); 
191          IAssert(StateCount > 0);
192          const double Prob = double(LexicalCount) / double(StateCount);
193          LexicalProbH.AddDat(Lexical, Prob);
194          ProbSum += Prob;
195      } printf("(%g) ", ProbSum);}
196      printf("Done\n");
197  }
<span onclick='openModal()' class='match'>198  void TPosHmm::LearnLambdas(const int& Tokens, const TIntPrIntH& BigramCountH, 
199          const TIntTrIntH& TrigramCountH, const TIntPrIntH& LexicalCountH) {
200      printf("Learning lambdas ... ");
201      double Lambda1 = 0.0, Lambda2 = 0.0, Lambda3 = 0.0;
</span>202      int KeyId = TrigramProbH.FFirstKeyId(); IAssert(Tokens > 1);
203      while (TrigramProbH.FNextKeyId(KeyId)) {
204          const TIntTr& Trigram = TrigramProbH.GetKey(KeyId);
205          const int TrigramCount = TrigramCountH[KeyId];
206          TIntPr OldBigram(Trigram.Val1, Trigram.Val2);
207          const int OldBigramCount = BigramCountH.GetDat(OldBigram);
208          TIntPr Bigram(Trigram.Val2, Trigram.Val3);
209          const int BigramCount = BigramCountH.GetDat(Bigram);
210          const int OldStateCount = StateH.GetDat(Trigram.Val2); 
211          const int StateCount = StateH.GetDat(Trigram.Val3); 
212          const double Val3 = OldBigramCount > 1 ? 
213              double(TrigramCount - 1) / double(OldBigramCount - 1) : 0.0;
214          const double Val2 = OldStateCount > 1 ?
215              double(BigramCount - 1) / double (OldStateCount - 1) : 0.0;
216          const double Val1 = double(StateCount - 1) / double(Tokens - 1);
217          if (Val3 > Val1 && Val3 > Val2) { Lambda3 += TrigramCount; }
218          else if (Val2 > Val1 && Val2 > Val3) { Lambda2 += TrigramCount; }
219          else if (Val1 > Val2 && Val1 > Val3) { Lambda1 += TrigramCount; }
220      } 
221      LambdaV = TFltV::GetV(Lambda1, Lambda2, Lambda3);
222      TLinAlg::NormalizeL1(LambdaV);
223      printf("Done (L1:%.6f, L2:%.6f, L3:%.6f)\n", 
224          LambdaV[0].Val, LambdaV[1].Val, LambdaV[2].Val);
225  }
226  void TPosHmm::LearnUnknown(const PPosSentBs& PosSentBs, 
227          const int& MxLemmaFq, const int& MxSuffixLen) {
228      SuffixH.Clr(); TIntPrIntH StateSuffixCountH;
229      const int Sents = PosSentBs->GetTrainSents();
230      int AllSuffixFq = 0; TIntH StateCountH;
231      printf("Counting %d sentences ... ", Sents);
232      for (int SentN = 0; SentN < Sents; SentN++) {
233          const TPosSent& Sent = PosSentBs->GetTrainSent(SentN);
234          const int Elts = Sent.GetElts();
235          for (int EltN = 0; EltN < Elts; EltN++) {
236              const TPosElt& Elt = Sent.GetElt(EltN);           
237              TStr Lemma = Elt.GetLemmaStr();
238              if (LemmaH.GetDat(Lemma) > MxLemmaFq) { continue; }
239              const int MxChs = TInt::GetMn(Lemma.Len(), MxSuffixLen);
240              for (int Chs = 1; Chs <= MxChs; Chs++) {
241                  AllSuffixFq++;
242                  const int State = int(Elt.GetPosTagType());
243                  StateCountH.AddDat(State)++;
244                  TStr Suffix = Lemma.Right(Chs);
245                  const int SuffixId = SuffixH.AddKey(Suffix);
246                  SuffixH[SuffixId]++; 
247                  TIntPr StateSuffix(State, SuffixId);
248                  StateSuffixCountH.AddDat(StateSuffix)++;
249              }
250          }
251      }
252      SuffixStateProbH.Clr();
253      printf("Probabilities (Suffix:%d) ... ", SuffixH.Len());
254      int KeyId = StateSuffixCountH.FFirstKeyId(); 
255      double ProbSum = 0.0, InvProbSum = 0.0;
256      while (StateSuffixCountH.FNextKeyId(KeyId)) {
257          const TIntPr& StateSuffix = StateSuffixCountH.GetKey(KeyId);
258          const int StateSuffixCount = StateSuffixCountH[KeyId];
259          const int SuffixCount = SuffixH[StateSuffix.Val2];
260          const double Prob = double(StateSuffixCount) / double(SuffixCount);
261          const double SuffixProb = double(SuffixCount) / double(AllSuffixFq);
262          const int StateCount = StateCountH.GetDat(StateSuffix.Val1);
263          const double StateProb = double(StateCount) / double(AllSuffixFq);
264          const double InvProb = Prob * SuffixProb / StateProb;
265          TIntPr SuffixState(StateSuffix.Val2, StateSuffix.Val1);
266          SuffixStateProbH.AddDat(SuffixState, InvProb);
267          ProbSum += Prob; InvProbSum += InvProb;
268      }
269      printf("Done (Prob:%g, Inv:%g)\n", ProbSum, InvProbSum);
270      printf("Learning smoothing weights ... ");
271      int MxProbState = -1; double MxProbStateWgt = 0.0;
272      {double MxProbStateProb = 0.0, MxProbStateSumProb = 0.0;
273      int StateKeyId = StateH.FFirstKeyId();
274      while (StateH.FNextKeyId(StateKeyId)) { 
275          const int CurrState = StateH.GetKey(StateKeyId);
276          const double Prob = StateProbH.GetDat(CurrState);
277          MxProbStateSumProb += Prob;
278          if (Prob > MxProbStateProb) { 
279              MxProbState = CurrState; MxProbStateProb = Prob; 
280          }
281      } MxProbStateWgt = MxProbStateProb / MxProbStateSumProb; }
282      ThetaV.Gen(MxSuffixLen+1); ThetaV.PutAll(0.0);
283      for (int SentN = 0; SentN < Sents; SentN++) {
284          const TPosSent& Sent = PosSentBs->GetTrainSent(SentN);
285          const int Elts = Sent.GetElts();
286          for (int EltN = 0; EltN < Elts; EltN++) {
287              const TPosElt& Elt = Sent.GetElt(EltN);           
288              const int EltState = int(Elt.GetPosTagType());
289              TStr Lemma = Elt.GetLemmaStr();
290              if (LemmaH.GetDat(Lemma) > MxLemmaFq) { continue; }
291              if (EltState == MxProbState) { ThetaV[0] += MxProbStateWgt; }
292              const int MxChs = TInt::GetMn(Lemma.Len(), MxSuffixLen);
293              for (int Chs = 1; Chs <= MxChs; Chs++) {
294                  const int State = int(Elt.GetPosTagType());
295                  const int SuffixId = SuffixH.GetKeyId(Lemma.Right(Chs));
296                  int MxState = -1; double MxProb = 0.0, SumProb = 0.0;
297                  {int StateKeyId = StateH.FFirstKeyId();
298                  while (StateH.FNextKeyId(StateKeyId)) { 
299                      const int CurrState = StateH.GetKey(StateKeyId);
300                      TIntPr SuffixState(SuffixId, CurrState);
301                      if (!SuffixStateProbH.IsKey(SuffixState)) { continue; }
302                      const double Prob = SuffixStateProbH.GetDat(SuffixState);
303                      SumProb += Prob;
304                      if (Prob > MxProb) { MxState = CurrState; MxProb = Prob; }
305                  }}
306                  if (MxState == State) { ThetaV[Chs] += double(Chs) * MxProb / SumProb; }
307              }
308          }
309      }
310      TLinAlg::NormalizeL1(ThetaV);
311      printf("Done\n");
312      TLAMisc::PrintTFltV(ThetaV, "Theta");
313  }
314  double TPosHmm::GetTrigramProb(const int& OldOldState, 
315          const int& OldState, const int& State) const {
316      TIntPr Bigram(OldState, State);
317      TIntTr Trigram(OldOldState, OldState, State);
318      const double UnigramProb = StateProbH.IsKey(State) ? 
319          StateProbH.GetDat(State) : 0.0;
320      const double BigramProb = BigramProbH.IsKey(Bigram) ? 
321          BigramProbH.GetDat(Bigram) : 0.0;
322      const double TrigramProb = TrigramProbH.IsKey(Trigram) ? 
323          TrigramProbH.GetDat(Trigram) : 0.0; 
324      return LambdaV[0] * UnigramProb + LambdaV[1] * BigramProb + LambdaV[2] * TrigramProb;
325  }
326  double TPosHmm::GetLexicalProb(const TStr& Lemma, const int& State) const {
327      if (LemmaH.IsKey(Lemma)) {
328          const int LemmaId = LemmaH.GetKeyId(Lemma);
329          TIntPr Lexical(LemmaId, State);
330          return LexicalProbH.IsKey(Lexical) ? LexicalProbH.GetDat(Lexical) : 0.0;
331      } else {
332          double Prob = ThetaV[0] * StateProbH.GetDat(State);
333          const int MxChs = Lemma.Len(); int Chs;
334          for (Chs = 1; Chs <= MxChs; Chs++) {
335              TStr Suffix = Lemma.Right(Chs);
336              if (!SuffixH.IsKey(Suffix)) { break; }
337              const int SuffixId = SuffixH.GetKeyId(Suffix);
338              TIntPr SuffixState(SuffixId, State);
339              if (!SuffixStateProbH.IsKey(SuffixState)) { break; }
340              const double SuffixProb = SuffixStateProbH.GetDat(SuffixState);
341              Prob += ThetaV[Chs] * SuffixProb;
342          }
343          return Prob;
344      }
345      return 0.0;
346  }
347  TPosHmm::TPosHmm(const PPosSentBs& PosSentBs) {
348      int Tokens; TIntPrIntH BigramCountH; 
349      TIntTrIntH TrigramCountH; TIntPrIntH LexicalCountH;
350      LearnProb(PosSentBs, Tokens, BigramCountH, TrigramCountH, LexicalCountH);
351      LearnLambdas(Tokens, BigramCountH, TrigramCountH, LexicalCountH);
352      LearnUnknown(PosSentBs, 10, 10);
353  }
354  void TPosHmm::Tag(TPosSent& Sent) {
355      if (Sent.GetElts() < 4) { return; }
356      const int States = StateH.Len();
357      const int BeginState = int(pttBegining), EndState = int(pttEnd);
358      const int BeginStateId = StateH.GetKeyId(BeginState);
359      const int EndStateId = StateH.GetKeyId(EndState);
360      const int Elts = Sent.GetElts();
361      TFltVV MxProbVV(Elts, States); MxProbVV.PutAll(0.0);
362      TIntVV BackVV(Elts, States); BackVV.PutAll(-1);
363      { 
364          const int FirstEltN = 2;
365          TStr Lemma = Sent.GetElt(FirstEltN).GetLemmaStr();
366          for (int StateId = 0; StateId < States; StateId++) {
367              const int State = StateH.GetKey(StateId);
368              const double TrigramProb = GetTrigramProb(BeginState, BeginState, State);
369              const double LexicalProb = GetLexicalProb(Lemma, State);
370              const double Prob = TrigramProb * LexicalProb;
371              MxProbVV(FirstEltN, StateId) = Prob;
372              BackVV(FirstEltN, StateId) = BeginStateId;
373              BackVV(0, StateId) = BackVV(1, StateId) = -1;
374          }
375          BackVV(1, BeginStateId) = BeginStateId;
376      }
377      for (int EltN = 3; EltN < (Elts-1); EltN++) {
378          TStr Lemma = Sent.GetElt(EltN).GetLemmaStr();
379          bool PositiveMoveP = false;
380          for (int StateId = 0; StateId < States; StateId++) {
381              const int State = StateH.GetKey(StateId);
382              int MxOldStateId = -1; double MxProb = 0.0;
383              for (int OldStateId = 0; OldStateId < States; OldStateId++) {
384                  const int OldState = StateH.GetKey(OldStateId);
385                  const int OldOldStateId = BackVV(EltN-1, OldStateId);
386                  if (OldOldStateId == -1) { continue; }
387                  const int OldOldState = StateH.GetKey(OldOldStateId);
388                  const double OldProb = MxProbVV(EltN-1, OldStateId);
389                  const double TrigramProb = GetTrigramProb(OldOldState, OldState, State);
390                  const double LexicalProb = GetLexicalProb(Lemma, State);
391                  const double Prob = OldProb * TrigramProb * LexicalProb;
392                  if (Prob > MxProb) { MxProb = Prob; MxOldStateId = OldStateId; }
393              }
394              MxProbVV(EltN, StateId) = MxProb;
395              BackVV(EltN, StateId) = MxOldStateId;
396              PositiveMoveP = PositiveMoveP || (MxOldStateId != -1);
397          }
398          IAssert(PositiveMoveP);
399      }
400      const int LastEltN = Elts-1;
401      int MxOldStateId = -1; double MxProb = 0.0;
402      for (int OldStateId = 0; OldStateId < States; OldStateId++) {
403          const int OldState = StateH.GetKey(OldStateId);
404          const int OldOldStateId = BackVV(LastEltN-1, OldStateId);
405          if (OldOldStateId == -1) { continue; }
406          const int OldOldState = StateH.GetKey(OldOldStateId);
407          const double OldProb = MxProbVV(LastEltN-1, OldStateId);
408          const double TrigramProb = GetTrigramProb(OldOldState, OldState, EndState);
409          const double Prob = OldProb * TrigramProb;
410          if (Prob > MxProb) { MxProb = Prob; MxOldStateId = OldStateId; }
411      } IAssert(MxOldStateId != -1);
412      Sent.GetElt(LastEltN).PutPosTagType(pttEnd); 
413      for (int EltN = Elts-2; EltN >= 0; EltN--) {
414          const int MxOldState = StateH.GetKey(MxOldStateId);
415          const TPosTagType MxTagType = TPosTagType(MxOldState);
416          Sent.GetElt(EltN).PutPosTagType(MxTagType);
417          MxOldStateId = BackVV(EltN, MxOldStateId);
418          IAssert((MxOldStateId != -1) || (EltN == 0));
419      }
420  }
421  int TPosHmm::GetKnowns(const TPosSent& Sent) const {
422      int Knowns = 0;
423      for (int EltN = 2; EltN < (Sent.GetElts()-1); EltN++) {
424          if (IsKnown(Sent.GetElt(EltN).GetLemmaStr())) { Knowns++; }
425      }
426      return Knowns;
427  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gridvcl.cpp</h3>
            <pre><code>1  #include "gridvcl.h"
2  void __fastcall TVclStrGrid::OnGridKeyDown(
3   TObject *Sender, WORD &Key, TShiftState Shift){
4    if (Key==27){
5      int ColN; int RowN;
6      if (IsSelCell(ColN, RowN)){
7        PutVal(ColN, RowN, PrevSelValStr);
8      }
9    }
10    if (Key==' '){
11      int ColN; int RowN;
12      if (IsSelCell(ColN, RowN)){
13        TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
14        if (VarType==gvtBool){ 
15          ActValCheckBox->Checked=!ActValCheckBox->Checked;
16        } else
17        if (VarType==gvtStrV){ 
18          if (ActValComboBox->Items->Count>0){
19            ActValComboBox->ItemIndex=
20             (ActValComboBox->ItemIndex+1)%ActValComboBox->Items->Count;
21            OnActValChange(ActValComboBox);
22          }
23        }
24      }
25    }
26  }
27  void __fastcall TVclStrGrid::OnGridMouseDown(
28   TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y){
29    int ColN; int RowN; StrGrid->MouseToCell(X, Y, ColN, RowN);
30    SelCell(ColN, RowN);
31  }
32  void __fastcall TVclStrGrid::OnGridMouseUp(
33   TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y){
34    SyncToGui();
35  }
36  void __fastcall TVclStrGrid::OnGridSelectCell(
37   TObject *Sender, int ACol, int ARow, bool &CanSelect){
38    CanSelect=SelCell(ACol, ARow);
39    SyncToGui();
40  }
41  void __fastcall TVclStrGrid::OnGridSetEditText(
42   TObject *Sender, int ACol, int ARow, const AnsiString Value){
43    _OnGridSetEditText(ACol, ARow, Value.c_str());
44  }
45  void __fastcall TVclStrGrid::OnGridGetEditMask(
46   TObject *Sender, int ColN, int RowN, AnsiString& MaskStr){
47    TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
48    if (VarType==gvtStrMask){
49      MaskStr="#0.9;1; ";
50    } else {
51      MaskStr="";
52    }
53  }
54  void __fastcall TVclStrGrid::OnGridTopLeftChanged(TObject *Sender){
55    SyncToGui();
56  }
57  void __fastcall TVclStrGrid::OnActValChange(TObject *Sender){
58    TStr ValStr;
59    if (Sender==ActValEd){
60      ValStr=ActValEd->Text.c_str();
61      int ColN; int RowN;
62      if (IsSelCell(ColN, RowN)){
63        TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
64      }
65    } else
66    if (Sender==ActValCheckBox){
67      ValStr=TBool::GetYesNoStr(ActValCheckBox->Checked);
68    } else
69    if (Sender==GridValCheckBox){
70      ValStr=TBool::GetYesNoStr(GridValCheckBox->Checked);
71    } else
72    if (Sender==ActValComboBox){
73      ValStr=ActValComboBox->Text.c_str();
74    } else
75    if (Sender==GridValComboBox){
76      ValStr=GridValComboBox->Text.c_str();
77    } else
78    if (Sender==ActExtValEd){
79      ValStr=ActExtValEd->Text.c_str();
80    } else {
81      Fail;
82    }
83    int ColN; int RowN;
84    if (IsSelCell(ColN, RowN)){
85      PutVal(ColN, RowN, ValStr);
86    }
87  }
88  void __fastcall TVclStrGrid::OnActExtEdBtClick(TObject *Sender){
89    TStr ExtNm=ActExtEdBt->Caption.c_str();
90    TExtGetStrF ExtGetStrF;
91    if (IsExtGetStrF(ExtNm, ExtGetStrF)){
92      int ColN; int RowN;
93      if (IsSelCell(ColN, RowN)){
94        TStr PrevValStr=GetVal(ColN, RowN);
95        TStr NewValStr; bool OkP;
96        (*ExtGetStrF())(false, PrevValStr, NewValStr, OkP);
97        if (OkP){
98          ActExtValEd->Text=NewValStr.CStr();
99        }
100      }
101    }
102  }
103  void TVclStrGrid::EnableCtrl(TControl* Control, const bool& VisibleP){
104    if (Control!=NULL){
105      if (!Control->Enabled){Control->Enabled=true;}
106      if (Control->Visible!=VisibleP){Control->Visible=VisibleP;}
107    }
108  }
109  void TVclStrGrid::DisableCtrl(TControl* Control, const bool& VisibleP){
110    if (Control!=NULL){
111      if (Control->Enabled){Control->Enabled=false;}
112      if (Control->Visible!=VisibleP){Control->Visible=VisibleP;}
113    }
114  }
115  void TVclStrGrid::InitGrid(){
116    IAssert(StrGrid!=NULL);
117    StrGrid->ScrollBars=ssBoth;
118    StrGrid->Options.Clear();
119    StrGrid->Options<<goFixedVertLine<<goFixedHorzLine;
120    StrGrid->Options<<goVertLine<<goHorzLine;
121    StrGrid->Options<<goDrawFocusSelected<<goColSizing;
122    StrGrid->Options<<goTabs;
123    StrGrid->OnKeyDown=&OnGridKeyDown;
124    StrGrid->OnMouseDown=&OnGridMouseDown;
125    StrGrid->OnMouseUp=&OnGridMouseUp;
126    StrGrid->OnSelectCell=&OnGridSelectCell;
127    StrGrid->OnSetEditText=&OnGridSetEditText;
128    StrGrid->OnGetEditMask=&OnGridGetEditMask;
129    StrGrid->OnTopLeftChanged=&OnGridTopLeftChanged;
130  }
131  void TVclStrGrid::InitActInput(const PVclStrGrid& PrevStrGrid){
132    if (PrevStrGrid.Empty()){
133      if (ActValEd!=NULL){
134        ActValEd->OnChange=&OnActValChange;
135        ActValEd->OnKeyDown=&OnGridKeyDown;
136        ActValCheckBox=new TCheckBox(StrGrid);
137        ActValCheckBox->Parent=ActValEd->Parent;
138        ActValCheckBox->OnClick=&OnActValChange;
139        ActValCheckBox->OnKeyDown=&OnGridKeyDown;
140        ActValCheckBox->Visible=false;
141        ActValCheckBox->TabOrder=-1;
142        ActValCheckBox->Anchors=ActValEd->Anchors;
143        ActValCheckBox->Left=ActValEd->Left; ActValCheckBox->Top=ActValEd->Top;
144        ActValCheckBox->Width=ActValEd->Width; ActValCheckBox->Height=ActValEd->Height;
145        GridValCheckBox=new TCheckBox(StrGrid);
146        GridValCheckBox->Parent=StrGrid->Parent;
147        GridValCheckBox->OnClick=&OnActValChange;
148        GridValCheckBox->OnKeyDown=&OnGridKeyDown;
149        GridValCheckBox->Visible=false;
150        GridValCheckBox->TabOrder=-1;
151        GridValCheckBox->Color=clActiveCaption;
152        ActValComboBox=new TComboBox(StrGrid);
153        ActValComboBox->Parent=ActValEd->Parent;
154        ActValComboBox->OnChange=&OnActValChange;
155        ActValComboBox->OnKeyDown=&OnGridKeyDown;
156        ActValComboBox->Style=Stdctrls::csDropDownList;
157        ActValComboBox->Visible=false;
158        ActValComboBox->TabOrder=-1;
159        ActValComboBox->Anchors=ActValEd->Anchors;
160        ActValComboBox->Left=ActValEd->Left; ActValComboBox->Top=ActValEd->Top;
161        ActValComboBox->Width=ActValEd->Width; ActValComboBox->Height=ActValEd->Height;
162        GridValComboBox=new TComboBox(StrGrid);
163        GridValComboBox->Parent=StrGrid->Parent;
164        GridValComboBox->OnChange=&OnActValChange;
165        GridValComboBox->OnKeyDown=&OnGridKeyDown;
166        GridValComboBox->Style=Stdctrls::csDropDownList;
167        GridValComboBox->Visible=false;
168        GridValComboBox->TabOrder=-1;
169      } else {
170        ActValCheckBox=NULL;
171        GridValCheckBox=NULL;
172        ActValComboBox=NULL;
173        GridValComboBox=NULL;
174      }
175      ActExtEdBt=new TButton(StrGrid);
176      ActExtEdBt->Parent=ActValEd->Parent;
177      ActExtEdBt->OnClick=&OnActExtEdBtClick;
178      ActExtEdBt->Visible=false;
179      ActExtEdBt->TabOrder=-1;
180      ActExtEdBt->Anchors=ActValEd->Anchors;
181      ActExtEdBt->Anchors>>akLeft;
182      ActExtEdBt->Width=80;
183      ActExtEdBt->Height=ActValEd->Height;
184      ActExtEdBt->Left=ActValEd->Left+ActValEd->Width-ActExtEdBt->Width;
185      ActExtEdBt->Top=ActValEd->Top;
186      GridExtEdBt=new TButton(StrGrid);
187      GridExtEdBt->Parent=StrGrid->Parent;
188      GridExtEdBt->OnClick=&OnActExtEdBtClick;
189      GridExtEdBt->Visible=false;
190      GridExtEdBt->TabOrder=-1;
191      ActExtValEd=new TEdit(StrGrid);
192      ActExtValEd->Parent=ActValEd->Parent;
193      ActExtValEd->OnChange=&OnActValChange;
194      ActExtValEd->OnKeyDown=&OnGridKeyDown;
195      ActExtValEd->Visible=false;
196      ActExtValEd->TabOrder=-1;
197      ActExtValEd->Anchors=ActValEd->Anchors;
198      ActExtValEd->Left=ActValEd->Left; ActExtValEd->Top=ActValEd->Top;
199      ActExtValEd->Width=ActValEd->Width-ActExtEdBt->Width-10;
200      ActExtValEd->Height=ActValEd->Height;
201    } else {
202      IAssert(PrevStrGrid->ActValEd==ActValEd);
203    }
204  }
205  TVclStrGrid::TVclStrGrid(
206   TStringGrid* _StrGrid, TEdit* _ActValEd,
207   const int& _FixedCols, const int& _FixedRows,
208   const PVclStrGrid& PrevStrGrid):
209    GridValVV(), FixedCols(_FixedCols), FixedRows(_FixedRows),
210    StrGrid(_StrGrid), GridValCheckBox(NULL), GridValComboBox(NULL),
211    SelColN(-1), SelRowN(-1), PrevSelValStr(),
212    ActValEd(_ActValEd), ActValCheckBox(NULL), ActValComboBox(NULL),
213    ActExtValEd(NULL), GridExtEdBt(NULL), ActExtEdBt(NULL),
214    ColRowPrToVarTypeH(), ColRowPrToDfValStrH(), ColRowPrToValStrVH(){
215    GridValVV.Gen(FixedCols, FixedRows);
216    InitActInput(PrevStrGrid);
217    InitGrid();
218    UnSelCell();
219    SyncToGui();
220  }
221  PVclStrGrid TVclStrGrid::New(
222   TStringGrid* StrGrid, TEdit* ActValEd,
223   const int& FixedCols, const int& FixedRows,
224   const PVclStrGrid& PrevStrGrid){
225    if (PrevStrGrid.Empty()){
226      return new TVclStrGrid(StrGrid, ActValEd, FixedCols, FixedRows, PrevStrGrid);
227    } else {
228      PVclStrGrid StrGrid=PrevStrGrid;
229      StrGrid->FixedCols=FixedCols;
230      StrGrid->FixedRows=FixedRows;
231      StrGrid->SelColN=-1;
232      StrGrid->SelRowN=-1;
233      StrGrid->PrevSelValStr="";
234      StrGrid->ColRowPrToVarTypeH.Clr();
235      StrGrid->ColRowPrToDfValStrH.Clr();
236      StrGrid->ColRowPrToValStrVH.Clr();
237      StrGrid->GridValVV.Gen(FixedCols, FixedRows);
238      StrGrid->InitGrid();
239      StrGrid->UnSelCell();
240      StrGrid->SyncToGui();
241      return StrGrid;
242    }
243  }
244  TVclStrGrid::~TVclStrGrid(){
245    if (GridValCheckBox!=NULL){GridValCheckBox->Visible=false;}
246    if (GridValComboBox!=NULL){GridValComboBox->Visible=false;}
247    if (ActValEd!=NULL){ActValEd->Visible=false;}
248    if (ActValCheckBox!=NULL){ActValCheckBox->Visible=false;}
249    if (ActValComboBox!=NULL){ActValComboBox->Visible=false;}
250    if (ActExtValEd!=NULL){ActExtValEd->Visible=false;}
251    if (ActExtEdBt!=NULL){ActExtEdBt->Visible=false;}
252    if (GridExtEdBt!=NULL){GridExtEdBt->Visible=false;}
253  }
254  void TVclStrGrid::RegExtGetStrF(
255   const TStr& ExtNm, const TExtGetStrF& ExtGetStrF){
256    TypeToGetStrFH.AddDat(ExtNm, ExtGetStrF);
257  }
258  bool TVclStrGrid::IsExtGetStrF(const TStr& ExtNm, TExtGetStrF& ExtGetStrF) const {
259    return TypeToGetStrFH.IsKeyGetDat(ExtNm, ExtGetStrF);
260  }
261  void TVclStrGrid::SyncToGui(){
262    int GridCols=TInt::GetMx(FixedCols+1, GetCols());
263    int GridRows=TInt::GetMx(FixedRows+1, GetRows());
264    if (StrGrid->FixedCols!=FixedCols){StrGrid->FixedCols=FixedCols;}
265    if (StrGrid->FixedRows!=FixedRows){StrGrid->FixedRows=FixedRows;}
266    if (StrGrid->ColCount!=GridCols){StrGrid->ColCount=GridCols;}
267    if (StrGrid->RowCount!=GridRows){StrGrid->RowCount=GridRows;}
268    for (int ColN=0; ColN<GridCols; ColN++){
269      for (int RowN=0; RowN<GridRows; RowN++){
270        if ((ColN<GetCols())&&(RowN<GetRows())){
271          TStr ValStr=GetVal(ColN, RowN);
272          if (StrGrid->Cells[ColN][RowN]!=ValStr.CStr()){
273            StrGrid->Cells[ColN][RowN]=ValStr.CStr();
274          }
275        } else {
276          StrGrid->Cells[ColN][RowN]="";
277        }
278      }
279    }
280    SelCell(SelColN, SelRowN, false);
281  }
282  void TVclStrGrid::_OnGridSetEditText(
283   const int& ColN, const int& RowN, const TStr& ValStr){
284    if ((0<=ColN)&&(ColN<GetCols())&&(0<=RowN)&&(RowN<GetRows())){
285      At(ColN, RowN)=ValStr.CStr();
286      SelCell(ColN, RowN, false);
287    }
288  }
289  void TVclStrGrid::FitColWidth(const int& MnWidth){
290    for (int ColN=0; ColN<GetCols(); ColN++){
291      int MxWidth=0;
292      for (int RowN=0; RowN<GetRows(); RowN++){
293        TStr ValStr=GetVal(ColN, RowN);
294        int Width=StrGrid->Canvas->TextWidth(ValStr.CStr());
295        MxWidth=TInt::GetMx(MxWidth, Width);
296      }
297      MxWidth=TInt::GetMx(5+MxWidth, MnWidth);
298      StrGrid->ColWidths[ColN]=MxWidth;
299    }
300    SyncToGui();
301  }
302  void TVclStrGrid::FitRowHeight(const int& MnHeight){
303    int AllMxHeight=0;
304    for (int RowN=0; RowN<GetRows(); RowN++){
305      int MxHeight=0;
306      for (int ColN=0; ColN<GetCols(); ColN++){
307        TStr ValStr=GetVal(ColN, RowN);
308        int Height=StrGrid->Canvas->TextHeight(ValStr.CStr());
309        MxHeight=TInt::GetMx(MxHeight, Height);
310      }
311      MxHeight=TInt::GetMx(1+MxHeight, MnHeight);
312      AllMxHeight=TInt::GetMx(AllMxHeight, MxHeight);
313    }
314    StrGrid->DefaultRowHeight=AllMxHeight;
315    SyncToGui();
316  }
317  void TVclStrGrid::FitColRowSize(const int& MnColWidth, const int& MnRowHeight){
318    FitColWidth(MnColWidth);
319    FitRowHeight(MnRowHeight);
320  }
321  int TVclStrGrid::SetFontSize(const int& FontSize){
322    if (FontSize>0){
323      StrGrid->Font->Size=FontSize;
324      GridValCheckBox->Font->Size=FontSize;
325      GridValComboBox->Font->Size=FontSize;
326      GridExtEdBt->Font->Size=FontSize;
327      FitColRowSize();
328    }
329    return StrGrid->Font->Size;
330  }
331  void TVclStrGrid::SetDfGridLook(){
332    SetFontSize(8);
333    for (int ColN=0; ColN<StrGrid->ColCount; ColN++){
334      TInt ColWidth;
335      if (!ColNToWidthH.IsKeyGetDat(ColN, ColWidth)){ColWidth=64;}
336      StrGrid->ColWidths[ColN]=ColWidth;
337    }
338    for (int RowN=0; RowN<StrGrid->RowCount; RowN++){
339      StrGrid->RowHeights[RowN]=22;}
340    SyncToGui();
341  }
342  bool TVclStrGrid::SelCell(
343   const int ColN, const int RowN, const bool& UpdatePrevSelValStrP){
344    if ((FixedCols<=ColN)&&(ColN<GetCols())&&(FixedRows<=RowN)&&(RowN<GetRows())){
345      if (ActValEd!=NULL){
346        SelColN=-1; SelRowN=-1;
347        TVclStrGridVarType VarType; TStrV ValStrV;
348        GetCellVarType(ColN, RowN, VarType, ValStrV);
349        if (VarType==gvtBool){ 
350          DisableCtrl(ActValEd);
351          EnableCtrl(ActValCheckBox); EnableCtrl(GridValCheckBox);
352          DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
353          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
354          TRect Rect=StrGrid->CellRect(ColN, RowN);
355          GridValCheckBox->Left=3+Rect.Left&bsol;*+10*/;
356          GridValCheckBox->Top=3+Rect.Top;
357          GridValCheckBox->Width=Rect.Width()&bsol;*-10*/;
358          GridValCheckBox->Height=Rect.Height();
359          ActValCheckBox->Checked=(At(ColN, RowN)==TBool::GetYesNoStr(true));
360          GridValCheckBox->Checked=ActValCheckBox->Checked;
361        } else
362        if (VarType==gvtStrV){ 
363          DisableCtrl(ActValEd);
364          DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
365          EnableCtrl(ActValComboBox); EnableCtrl(GridValComboBox);
366          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
367          TRect Rect=StrGrid->CellRect(ColN, RowN);
368          GridValComboBox->Left=3+Rect.Left&bsol;*+10*/;
369          GridValComboBox->Top=3+Rect.Top;
370          GridValComboBox->Width=Rect.Width()&bsol;*-10*/;
371          GridValComboBox->Height=Rect.Height();
372          ActValComboBox->Items->Clear(); GridValComboBox->Items->Clear();
373          for (int ValStrN=0; ValStrN<ValStrV.Len(); ValStrN++){
374            ActValComboBox->Items->Add(ValStrV[ValStrN].CStr());
375            GridValComboBox->Items->Add(ValStrV[ValStrN].CStr());
376          }
377          ActValComboBox->ItemIndex=
378           ActValComboBox->Items->IndexOf(At(ColN, RowN).CStr());
379          if ((ValStrV.Len()>0)&&(ActValComboBox->ItemIndex==-1)){
380            ActValComboBox->ItemIndex=0;}
381          GridValComboBox->ItemIndex=ActValComboBox->ItemIndex;
382        } else
383        if (VarType==gvtExt){ 
384          TStr ExtNm;
385          if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), ExtNm)){}
386          else if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), ExtNm)){}
387          else {ExtNm="";}
388          TExtGetStrF ExtGetStrF;
389          if (IsExtGetStrF(ExtNm, ExtGetStrF)){
390            DisableCtrl(ActValEd);
391            DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
392            DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
393            EnableCtrl(ActExtValEd); EnableCtrl(ActExtEdBt); EnableCtrl(GridExtEdBt);
394            TRect Rect=StrGrid->CellRect(ColN, RowN);
395            GridExtEdBt->Left=3+Rect.Left;
396            GridExtEdBt->Top=3+Rect.Top;
397            GridExtEdBt->Width=Rect.Width();
398            GridExtEdBt->Height=Rect.Height();
399            int TxtWidth=10+StrGrid->Canvas->TextWidth(ExtNm.CStr());
400            if (GridExtEdBt->Width>2*TxtWidth){
401              GridExtEdBt->Left=Rect.Right-TxtWidth+1;
402              GridExtEdBt->Width=TxtWidth;
403            }
404            ActExtValEd->Text=At(ColN, RowN).CStr();
405            ActExtEdBt->Caption=ExtNm.CStr();
406            GridExtEdBt->Caption=ExtNm.CStr();
407          }
408        } else { 
409          EnableCtrl(ActValEd);
410          DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
411          DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
412          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
413          ActValEd->Text=At(ColN, RowN).CStr();
414        }
415      }
416      SelColN=ColN; SelRowN=RowN;
417      if (UpdatePrevSelValStrP){PrevSelValStr=GetVal(ColN, RowN);}
418      if (IsGridCell(ColN, RowN)){
419        StrGrid->Options<<goEditing;
420      } else {
421        StrGrid->Options>>goEditing;
422      }
423      TGridRect SelRect;
424      SelRect.Left=ColN; SelRect.Top=RowN;
425      SelRect.Right=ColN; SelRect.Bottom=RowN;
426      StrGrid->Selection=SelRect;
427      return true;
428    } else {
429      UnSelCell();
430      return false;
431    }
432  }
433  void TVclStrGrid::UnSelCell(){
434    SelColN=-1; SelRowN=-1;
435    DisableCtrl(ActValEd, true);
436    DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
437    DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
438    DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
439    if (Empty()){ActValEd->Text="No Data";}
440    else {ActValEd->Text="";}
441    StrGrid->Options>>goEditing;
442    TGridRect SelRect;
443    SelRect.Left=-1; SelRect.Top=-1;
444    SelRect.Right=-1; SelRect.Bottom=-1;
445    StrGrid->Selection=SelRect;
446  }
447  bool TVclStrGrid::IsSelCell(int& _SelColN, int& _SelRowN) const {
448    if ((FixedCols<=SelColN)&&(SelColN<GetCols())&&
449     (FixedRows<=SelRowN)&&(SelRowN<GetRows())){
450      _SelColN=SelColN; _SelRowN=SelRowN; return true;
451    } else {
452      return false;
453    }
454  }
455  TStr TVclStrGrid::GetVal(const int& ColN, const int& RowN){
456    TStr ValStr=GridValVV.At(ColN, RowN);
457    if ((FixedCols<=ColN)&&(FixedRows<=RowN)){
458      TVclStrGridVarType VarType; TStrV ValStrV;
459      GetCellVarType(ColN, RowN, VarType, ValStrV);
460      if (VarType==gvtBool){ 
461        ValStr=TBool::GetYesNoStr(ValStr==TBool::GetYesNoStr(true));
462      } else
463      if (VarType==gvtStrV){ 
464        if (!ValStrV.IsIn(ValStr)){
465          if (ValStrV.Len()>0){ValStr=ValStrV[0];} else {ValStr="";}
466        }
467      } else
468      if (VarType==gvtFlt){ 
469        if (!ValStr.IsFlt()){ValStr="0";}
470      } else
471      if (VarType==gvtInt){ 
472        if (!ValStr.IsInt()){ValStr="0";}
473      } else
474      if (VarType==gvtExt){ 
475        TStr ExtNm;
476        if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), ExtNm)){}
477        else if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), ExtNm)){}
478        else {ExtNm="";}
479        TExtGetStrF ExtGetStrF;
480        if (IsExtGetStrF(ExtNm, ExtGetStrF)){
481          TStr NewValStr; bool OkP;
482          (*ExtGetStrF())(true, ValStr, NewValStr, OkP);
483          if (OkP){ValStr=NewValStr;}
484        }
485      }
486      GridValVV.PutXY(ColN, RowN, ValStr);
487    }
488    return ValStr;
489  }
490  void TVclStrGrid::DelCol(const int& ColN){
491    GridValVV.DelX(ColN);
492    SyncToGui();
493  }
494  void TVclStrGrid::DelRow(const int& DelRowN){
495    ColRowPrToVarTypeH.DelIfKey(TIntPr(1, DelRowN));
496    ColRowPrToDfValStrH.DelIfKey(TIntPr(1, DelRowN));
497    ColRowPrToValStrVH.DelIfKey(TIntPr(1, DelRowN));
498    for (int RowN=DelRowN+1; RowN<GetRows(); RowN++){
499      TInt VarType;
500      if (ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(1, RowN), VarType)){
501        ColRowPrToVarTypeH.AddDat(TIntPr(1, RowN-1), VarType);
502        ColRowPrToVarTypeH.DelKey(TIntPr(1, RowN));
503      }
504      TStr DfValStr;
505      if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), DfValStr)){
506        ColRowPrToDfValStrH.AddDat(TIntPr(1, RowN-1), DfValStr);
507        ColRowPrToDfValStrH.DelKey(TIntPr(1, RowN));
508      }
509      TStrV ValStrV;
510      if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){
511        ColRowPrToValStrVH.AddDat(TIntPr(1, RowN-1), ValStrV);
512        ColRowPrToValStrVH.DelKey(TIntPr(1, RowN));
513      }
514    }
515    GridValVV.DelY(DelRowN);
516    SyncToGui();
517  }
518  void TVclStrGrid::GetCellVarType(
519   const int& ColN, const int& RowN,
520   TVclStrGridVarType& VarType, TStrV& ValStrV) const {
521    TInt _VarType;
522    if ((FixedRows==1)&&(ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(ColN, 1), _VarType))){
523      VarType=TVclStrGridVarType(int(_VarType));
524      if (VarType==gvtStrV){
525        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(ColN, 1), ValStrV)){}
526        else {ValStrV.Clr();}
527      }
528    } else
529    if ((FixedCols==1)&&(ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(1, RowN), _VarType))){
530      VarType=TVclStrGridVarType(int(_VarType));
531      if (VarType==gvtStrV){
532        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){}
533        else {ValStrV.Clr();}
534      }
535    } else {
536      VarType=gvtUndef; ValStrV.Clr();
537    }
538  }
539  bool TVclStrGrid::IsGridCell(const int& ColN, const int& RowN) const {
540    TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
541    return (VarType!=gvtBool)&&(VarType!=gvtStrV);
542  }
543  int TVclStrGrid::AddColVar(
<span onclick='openModal()' class='match'>544   const TStr& VarNm, const int& ColWidth,
545   const TVclStrGridVarType& VarType,
546   const TStr& DfValStr, const TStrV& ValStrV){
547    IAssert(FixedRows==1);
548    GridValVV.AddXDim();
549    int ColN=GetCols()-1;
550    At(ColN, 0)=VarNm;
</span>551    if (ColWidth!=-1){
552      ColNToWidthH.AddDat(ColN, ColWidth);
553      StrGrid->ColCount=GetCols();
554      StrGrid->ColWidths[ColN]=ColWidth;
555    }
556    ColRowPrToVarTypeH.AddDat(TIntPr(ColN, 1), VarType);
557    if (!DfValStr.Empty()){
558      ColRowPrToDfValStrH.AddDat(TIntPr(ColN, 1), DfValStr);}
559    if (!ValStrV.Empty()){
560      ColRowPrToValStrVH.AddDat(TIntPr(ColN, 1), ValStrV);}
561    SyncToGui();
562    int VarN=GetCols()-1-FixedCols;
563    return VarN;
564  }
565  int TVclStrGrid::AddColVar(
566   const TStr& VarNm, const int& ColWidth,
567   const TVclStrGridVarType& VarType,
568   const TStr& DfValStr, const TStr& ValStrVStr, const char& SplitCh){
569    TStrV ValStrV; ValStrVStr.SplitOnAllCh(SplitCh, ValStrV);
570    return AddColVar(VarNm, ColWidth, VarType, DfValStr, ValStrV);
571  }
572  int TVclStrGrid::AddRowVar(
573   const TStr& VarNm,
574   const TVclStrGridVarType& VarType,
575   const TStr& DfValStr, const TStrV& ValStrV){
576    IAssert(FixedCols==1);
577    GridValVV.AddYDim();
578    At(0, GetRows()-1)=VarNm;
579    int RowN=GetRows()-1;
580    ColRowPrToVarTypeH.AddDat(TIntPr(1, RowN), VarType);
581    if (!DfValStr.Empty()){
582      ColRowPrToDfValStrH.AddDat(TIntPr(1, RowN), DfValStr);}
583    if (!ValStrV.Empty()){
584      ColRowPrToValStrVH.AddDat(TIntPr(1, RowN), ValStrV);}
585    SyncToGui();
586    int VarN=GetRows()-1-FixedRows;
587    return VarN;
588  }
589  TStr TVclStrGrid::GetDfColVarVal(const int& ColVarN){
590    int ColN=FixedCols+ColVarN;
591    TStr DfValStr;
592    if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), DfValStr)){
593      if ((!DfValStr.Empty())&&(DfValStr.LastCh()=='#')){
594        TStr SubDfValStr=DfValStr.GetSubStr(0, DfValStr.Len()-2);
595        DfValStr=GetUniqueColVarVal(ColVarN, SubDfValStr);
596      }
597      TVclStrGridVarType VarType; GetCellVarType(ColN, -1, VarType);
598      if (VarType==gvtExt){DfValStr="";}
599    }
600    return DfValStr;
601  }
602  int TVclStrGrid::AddColRec(){
603    GridValVV.AddXDim();
604    SyncToGui();
605    int ColRecN=GetCols()-1-FixedCols;
606    return ColRecN;
607  }
608  int TVclStrGrid::AddRowRec(){
609    GridValVV.AddYDim();
610    int RowN=GetRows()-1;
611    int RowRecN=GetRows()-1-FixedRows;
612    for (int ColVarN=0; ColVarN<GetColVars(); ColVarN++){
613      PutColVarVal(ColVarN, RowRecN, GetDfColVarVal(ColVarN));}
614    SyncToGui(); SetFocus();
615    SelCell(FixedCols, RowN);
616    return RowRecN;
617  }
618  int TVclStrGrid::AddRowRec(const TStr& VarNm, const TStrV& ValStrV){
619    int RecN=AddRowRec();
620    if (!VarNm.Empty()){RowVarNm(RecN)=VarNm;}
621    for (int VarN=0; VarN<ValStrV.Len(); VarN++){
622      ColVarVal(VarN, RecN)=ValStrV[VarN];}
623    SyncToGui();
624    return RecN;
625  }
626  TStr TVclStrGrid::GetUniqueColVarVal(const int& ColVarN, const TStr& PfxValStr){
627    int RowRecs=GetRowRecs();
628    TStrH VarValH(RowRecs);
629    for (int RowRecN=0; RowRecN<RowRecs; RowRecN++){
630      VarValH.AddDat(ColVarVal(ColVarN, RowRecN));}
631    int ValStrN=1;
632    forever{
633      TStr ValStr=PfxValStr+TInt::GetStr(ValStrN);
634      if (!VarValH.IsKey(ValStr)){return ValStr;}
635      ValStrN++;
636    }
637  }
638  void TVclStrGrid::DelSelRowRec(){
639    int DelColN; int DelRowN;
640    if (IsSelCell(DelColN, DelRowN)){
641      DelRow(DelRowN);
642      SelCell(DelColN, DelRowN);
643      if (!IsSelCell()){
644        SelCell(DelColN, DelRowN-1);}
645      SyncToGui();
646    }
647    SetFocus();
648  }
649  void TVclStrGrid::CopySelRowRec(){
650    int SrcColN; int SrcRowN;
651    if (IsSelCell(SrcColN, SrcRowN)){
652      int DstRecN=AddRowRec();
653      int DstRowN=GetRowNFromRecN(DstRecN);
654      for (int ColN=0; ColN<GetCols(); ColN++){
655        At(ColN, DstRowN)=GetVal(ColN, SrcRowN);}
656      SelCell(GetFixedCols(), GetRows()-1);
657      SyncToGui();
658    }
659    SetFocus();
660  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-postag.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gridvcl.cpp</div>
                <div class="column column_space"><pre><code>198  void TPosHmm::LearnLambdas(const int& Tokens, const TIntPrIntH& BigramCountH, 
199          const TIntTrIntH& TrigramCountH, const TIntPrIntH& LexicalCountH) {
200      printf("Learning lambdas ... ");
201      double Lambda1 = 0.0, Lambda2 = 0.0, Lambda3 = 0.0;
</pre></code></div>
                <div class="column column_space"><pre><code>544   const TStr& VarNm, const int& ColWidth,
545   const TVclStrGridVarType& VarType,
546   const TStr& DfValStr, const TStrV& ValStrV){
547    IAssert(FixedRows==1);
548    GridValVV.AddXDim();
549    int ColN=GetCols()-1;
550    At(ColN, 0)=VarNm;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    