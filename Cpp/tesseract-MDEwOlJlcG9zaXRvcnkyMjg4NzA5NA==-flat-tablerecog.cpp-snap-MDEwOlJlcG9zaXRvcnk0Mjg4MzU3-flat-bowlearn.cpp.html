
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.7083333333333335%, Tokens: 12</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablerecog.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "tablerecog.h"
5  #include <algorithm>
6  namespace tesseract {
7  const double kHorizontalSpacing = 0.30;
8  const double kVerticalSpacing = -0.2;
9  const int kCellSplitRowThreshold = 0;
10  const int kCellSplitColumnThreshold = 0;
11  const int kLinedTableMinVerticalLines = 3;
12  const int kLinedTableMinHorizontalLines = 3;
13  const double kRequiredColumns = 0.7;
14  const double kMarginFactor = 1.1;
15  const double kMaxRowSize = 2.5;
16  const double kGoodRowNumberOfColumnsSmall[] = {2, 2, 2, 2, 2, 3, 3};
17  const double kGoodRowNumberOfColumnsLarge = 0.7;
18  const double kMinFilledArea = 0.35;
19  static bool IsWeakTableRow(StructuredTable *table, int row) {
20    if (!table->VerifyRowFilled(row)) {
21      return false;
22    }
23    double threshold;
24    if (table->column_count() < countof(kGoodRowNumberOfColumnsSmall)) {
25      threshold = kGoodRowNumberOfColumnsSmall[table->column_count()];
26    } else {
27      threshold = table->column_count() * kGoodRowNumberOfColumnsLarge;
28    }
29    return table->CountFilledCellsInRow(row) < threshold;
30  }
31  StructuredTable::StructuredTable()
32      : text_grid_(nullptr)
33      , line_grid_(nullptr)
34      , is_lined_(false)
35      , space_above_(0)
36      , space_below_(0)
37      , space_left_(0)
38      , space_right_(0)
39      , median_cell_height_(0)
40      , median_cell_width_(0)
41      , max_text_height_(INT32_MAX) {}
42  void StructuredTable::Init() {}
43  void StructuredTable::set_text_grid(ColPartitionGrid *text_grid) {
44    text_grid_ = text_grid;
45  }
46  void StructuredTable::set_line_grid(ColPartitionGrid *line_grid) {
47    line_grid_ = line_grid;
48  }
49  void StructuredTable::set_max_text_height(int height) {
50    max_text_height_ = height;
51  }
52  bool StructuredTable::is_lined() const {
53    return is_lined_;
54  }
55  unsigned StructuredTable::row_count() const {
56    return cell_y_.empty() ? 0 : cell_y_.size() - 1;
57  }
58  unsigned StructuredTable::column_count() const {
59    return cell_x_.empty() ? 0 : cell_x_.size() - 1;
60  }
61  unsigned StructuredTable::cell_count() const {
62    return row_count() * column_count();
63  }
64  void StructuredTable::set_bounding_box(const TBOX &box) {
65    bounding_box_ = box;
66  }
67  const TBOX &StructuredTable::bounding_box() const {
68    return bounding_box_;
69  }
70  int StructuredTable::median_cell_height() {
71    return median_cell_height_;
72  }
73  int StructuredTable::median_cell_width() {
74    return median_cell_width_;
75  }
76  int StructuredTable::row_height(unsigned row) const {
77    ASSERT_HOST(row < row_count());
78    return cell_y_[row + 1] - cell_y_[row];
79  }
80  int StructuredTable::column_width(unsigned column) const {
81    ASSERT_HOST(column < column_count());
82    return cell_x_[column + 1] - cell_x_[column];
83  }
84  int StructuredTable::space_above() const {
85    return space_above_;
86  }
87  int StructuredTable::space_below() const {
88    return space_below_;
89  }
90  bool StructuredTable::FindLinedStructure() {
91    ClearStructure();
92    ColPartitionGridSearch box_search(line_grid_);
93    box_search.SetUniqueMode(true);
94    box_search.StartRectSearch(bounding_box_);
95    ColPartition *line = nullptr;
96    while ((line = box_search.NextRectSearch()) != nullptr) {
97      if (line->IsHorizontalLine()) {
98        cell_y_.push_back(line->MidY());
99      }
100      if (line->IsVerticalLine()) {
101        cell_x_.push_back(line->MidX());
102      }
103    }
104    if (cell_x_.size() < 3 || cell_y_.size() < 3) {
105      return false;
106    }
107    std::sort(cell_x_.begin(), cell_x_.end());
108    auto last_x = std::unique(cell_x_.begin(), cell_x_.end());
109    cell_x_.erase(last_x, cell_x_.end());
110    std::sort(cell_y_.begin(), cell_y_.end());
111    auto last_y = std::unique(cell_y_.begin(), cell_y_.end());
112    cell_y_.erase(last_y, cell_y_.end());
113    cell_x_[0] = bounding_box_.left();
114    cell_x_[cell_x_.size() - 1] = bounding_box_.right();
115    cell_y_[0] = bounding_box_.bottom();
116    cell_y_[cell_y_.size() - 1] = bounding_box_.top();
117    last_x = std::unique(cell_x_.begin(), cell_x_.end());
118    cell_x_.erase(last_x, cell_x_.end());
119    last_y = std::unique(cell_y_.begin(), cell_y_.end());
120    cell_y_.erase(last_y, cell_y_.end());
121    CalculateMargins();
122    CalculateStats();
123    is_lined_ = VerifyLinedTableCells();
124    return is_lined_;
125  }
126  bool StructuredTable::FindWhitespacedStructure() {
127    ClearStructure();
128    FindWhitespacedColumns();
129    FindWhitespacedRows();
130    if (!VerifyWhitespacedTable()) {
131      return false;
132    } else {
133      bounding_box_.set_left(cell_x_[0]);
134      bounding_box_.set_right(cell_x_[cell_x_.size() - 1]);
135      bounding_box_.set_bottom(cell_y_[0]);
136      bounding_box_.set_top(cell_y_[cell_y_.size() - 1]);
137      AbsorbNearbyLines();
138      CalculateMargins();
139      CalculateStats();
140      return true;
141    }
142  }
143  bool StructuredTable::DoesPartitionFit(const ColPartition &part) const {
144    const TBOX &box = part.bounding_box();
145    for (int i : cell_x_) {
146      if (box.left() < i && i < box.right()) {
147        return false;
148      }
149    }
150    for (int i : cell_y_) {
151      if (box.bottom() < i && i < box.top()) {
152        return false;
153      }
154    }
155    return true;
156  }
157  int StructuredTable::CountFilledCells() {
158    return CountFilledCells(0, row_count() - 1, 0, column_count() - 1);
159  }
160  int StructuredTable::CountFilledCellsInRow(int row) {
161    return CountFilledCells(row, row, 0, column_count() - 1);
162  }
163  int StructuredTable::CountFilledCellsInColumn(int column) {
164    return CountFilledCells(0, row_count() - 1, column, column);
165  }
166  int StructuredTable::CountFilledCells(unsigned row_start, unsigned row_end, unsigned column_start,
167                                        unsigned column_end) {
168    ASSERT_HOST(row_start <= row_end && row_end < row_count());
169    ASSERT_HOST(column_start <= column_end && column_end < column_count());
170    int cell_count = 0;
171    TBOX cell_box;
172    for (unsigned row = row_start; row <= row_end; ++row) {
173      cell_box.set_bottom(cell_y_[row]);
174      cell_box.set_top(cell_y_[row + 1]);
175      for (unsigned col = column_start; col <= column_end; ++col) {
176        cell_box.set_left(cell_x_[col]);
177        cell_box.set_right(cell_x_[col + 1]);
178        if (CountPartitions(cell_box) > 0) {
179          ++cell_count;
180        }
181      }
182    }
183    return cell_count;
184  }
185  bool StructuredTable::VerifyRowFilled(int row) {
186    for (unsigned i = 0; i < column_count(); ++i) {
187      auto area_filled = CalculateCellFilledPercentage(row, i);
188      if (area_filled >= kMinFilledArea) {
189        return true;
190      }
191    }
192    return false;
193  }
194  double StructuredTable::CalculateCellFilledPercentage(unsigned row, unsigned column) {
195    ASSERT_HOST(row <= row_count());
196    ASSERT_HOST(column <= column_count());
197    const TBOX kCellBox(cell_x_[column], cell_y_[row], cell_x_[column + 1], cell_y_[row + 1]);
198    ASSERT_HOST(!kCellBox.null_box());
199    ColPartitionGridSearch gsearch(text_grid_);
200    gsearch.SetUniqueMode(true);
201    gsearch.StartRectSearch(kCellBox);
202    double area_covered = 0;
203    ColPartition *text = nullptr;
204    while ((text = gsearch.NextRectSearch()) != nullptr) {
205      if (text->IsTextType()) {
206        area_covered += text->bounding_box().intersection(kCellBox).area();
207      }
208    }
209    const int32_t current_area = kCellBox.area();
210    if (current_area == 0) {
211      return 1.0;
212    }
213    return std::min(1.0, area_covered / current_area);
214  }
215  #ifndef GRAPHICS_DISABLED
216  void StructuredTable::Display(ScrollView *window, ScrollView::Color color) {
217    window->Brush(ScrollView::NONE);
218    window->Pen(color);
219    window->Rectangle(bounding_box_.left(), bounding_box_.bottom(), bounding_box_.right(),
220                      bounding_box_.top());
221    for (int i : cell_x_) {
222      window->Line(i, bounding_box_.bottom(), i, bounding_box_.top());
223    }
224    for (int i : cell_y_) {
225      window->Line(bounding_box_.left(), i, bounding_box_.right(), i);
226    }
227    window->UpdateWindow();
228  }
229  #endif
230  void StructuredTable::ClearStructure() {
231    cell_x_.clear();
232    cell_y_.clear();
233    is_lined_ = false;
234    space_above_ = 0;
235    space_below_ = 0;
236    space_left_ = 0;
237    space_right_ = 0;
238    median_cell_height_ = 0;
239    median_cell_width_ = 0;
240  }
241  bool StructuredTable::VerifyLinedTableCells() {
242    ASSERT_HOST(cell_y_.size() >= 2 && cell_x_.size() >= 2);
243    for (int i : cell_y_) {
244      if (CountHorizontalIntersections(i) > 0) {
245        return false;
246      }
247    }
248    for (int i : cell_x_) {
249      if (CountVerticalIntersections(i) > 0) {
250        return false;
251      }
252    }
253    return true;
254  }
255  bool StructuredTable::VerifyWhitespacedTable() {
256    return row_count() >= 2 && column_count() >= 2 && cell_count() >= 6;
257  }
258  void StructuredTable::FindWhitespacedColumns() {
259    std::vector<int> left_sides;
260    std::vector<int> right_sides;
261    ColPartitionGridSearch gsearch(text_grid_);
262    gsearch.SetUniqueMode(true);
263    gsearch.StartRectSearch(bounding_box_);
264    ColPartition *text = nullptr;
265    while ((text = gsearch.NextRectSearch()) != nullptr) {
266      if (!text->IsTextType()) {
267        continue;
268      }
269      ASSERT_HOST(text->bounding_box().left() < text->bounding_box().right());
270      int spacing = static_cast<int>(text->median_width() * kHorizontalSpacing / 2.0 + 0.5);
271      left_sides.push_back(text->bounding_box().left() - spacing);
272      right_sides.push_back(text->bounding_box().right() + spacing);
273    }
274    if (left_sides.empty() || right_sides.empty()) {
275      return;
276    }
277    std::sort(left_sides.begin(), left_sides.end());
278    std::sort(right_sides.begin(), right_sides.end());
279    FindCellSplitLocations(left_sides, right_sides, kCellSplitColumnThreshold, &cell_x_);
280  }
281  void StructuredTable::FindWhitespacedRows() {
282    std::vector<int> bottom_sides;
283    std::vector<int> top_sides;
284    int min_bottom = INT32_MAX;
285    int max_top = INT32_MIN;
286    ColPartitionGridSearch gsearch(text_grid_);
287    gsearch.SetUniqueMode(true);
288    gsearch.StartRectSearch(bounding_box_);
289    ColPartition *text = nullptr;
290    while ((text = gsearch.NextRectSearch()) != nullptr) {
291      if (!text->IsTextType()) {
292        continue;
293      }
294      ASSERT_HOST(text->bounding_box().bottom() < text->bounding_box().top());
295      min_bottom = std::min(min_bottom, static_cast<int>(text->bounding_box().bottom()));
296      max_top = std::max(max_top, static_cast<int>(text->bounding_box().top()));
297      if (text->bounding_box().height() > max_text_height_) {
298        continue;
299      }
300      int spacing = static_cast<int>(text->bounding_box().height() * kVerticalSpacing / 2.0 + 0.5);
301      int bottom = text->bounding_box().bottom() - spacing;
302      int top = text->bounding_box().top() + spacing;
303      if (bottom >= top) {
304        continue;
305      }
306      bottom_sides.push_back(bottom);
307      top_sides.push_back(top);
308    }
309    if (bottom_sides.empty() || top_sides.empty()) {
310      return;
311    }
312    std::sort(bottom_sides.begin(), bottom_sides.end());
313    std::sort(top_sides.begin(), top_sides.end());
314    FindCellSplitLocations(bottom_sides, top_sides, kCellSplitRowThreshold, &cell_y_);
315    cell_y_[0] = min_bottom;
316    cell_y_[cell_y_.size() - 1] = max_top;
317  }
318  void StructuredTable::CalculateMargins() {
319    space_above_ = INT32_MAX;
320    space_below_ = INT32_MAX;
321    space_right_ = INT32_MAX;
322    space_left_ = INT32_MAX;
323    UpdateMargins(text_grid_);
324    UpdateMargins(line_grid_);
325  }
326  void StructuredTable::UpdateMargins(ColPartitionGrid *grid) {
327    int below = FindVerticalMargin(grid, bounding_box_.bottom(), true);
328    space_below_ = std::min(space_below_, below);
329    int above = FindVerticalMargin(grid, bounding_box_.top(), false);
330    space_above_ = std::min(space_above_, above);
331    int left = FindHorizontalMargin(grid, bounding_box_.left(), true);
332    space_left_ = std::min(space_left_, left);
333    int right = FindHorizontalMargin(grid, bounding_box_.right(), false);
334    space_right_ = std::min(space_right_, right);
335  }
336  int StructuredTable::FindVerticalMargin(ColPartitionGrid *grid, int border, bool decrease) const {
337    ColPartitionGridSearch gsearch(grid);
338    gsearch.SetUniqueMode(true);
339    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), border);
340    ColPartition *part = nullptr;
341    while ((part = gsearch.NextVerticalSearch(decrease)) != nullptr) {
342      if (!part->IsTextType() && !part->IsHorizontalLine()) {
343        continue;
344      }
345      int distance =
346          decrease ? border - part->bounding_box().top() : part->bounding_box().bottom() - border;
347      if (distance >= 0) {
348        return distance;
349      }
350    }
351    return INT32_MAX;
352  }
353  int StructuredTable::FindHorizontalMargin(ColPartitionGrid *grid, int border, bool decrease) const {
354    ColPartitionGridSearch gsearch(grid);
355    gsearch.SetUniqueMode(true);
356    gsearch.StartSideSearch(border, bounding_box_.bottom(), bounding_box_.top());
357    ColPartition *part = nullptr;
358    while ((part = gsearch.NextSideSearch(decrease)) != nullptr) {
359      if (!part->IsTextType() && !part->IsVerticalLine()) {
360        continue;
361      }
362      int distance =
363          decrease ? border - part->bounding_box().right() : part->bounding_box().left() - border;
364      if (distance >= 0) {
365        return distance;
366      }
367    }
368    return INT32_MAX;
369  }
370  void StructuredTable::CalculateStats() {
371    const int kMaxCellHeight = 1000;
372    const int kMaxCellWidth = 1000;
373    STATS height_stats(0, kMaxCellHeight);
374    STATS width_stats(0, kMaxCellWidth);
375    for (unsigned i = 0; i < row_count(); ++i) {
376      height_stats.add(row_height(i), column_count());
377    }
378    for (unsigned i = 0; i < column_count(); ++i) {
379      width_stats.add(column_width(i), row_count());
380    }
381    median_cell_height_ = static_cast<int>(height_stats.median() + 0.5);
382    median_cell_width_ = static_cast<int>(width_stats.median() + 0.5);
383  }
384  void StructuredTable::AbsorbNearbyLines() {
385    ColPartitionGridSearch gsearch(line_grid_);
386    gsearch.SetUniqueMode(true);
387    ColPartition *line = nullptr;
388    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), bounding_box_.top());
389    while ((line = gsearch.NextVerticalSearch(false)) != nullptr) {
390      if (!line->IsHorizontalLine()) {
391        break;
392      }
393      TBOX text_search(bounding_box_.left(), bounding_box_.top() + 1, bounding_box_.right(),
394                       line->MidY());
395      if (text_search.height() > median_cell_height_ * 2) {
396        break;
397      }
398      if (CountPartitions(text_search) > 0) {
399        break;
400      }
401      bounding_box_.set_top(line->MidY());
402    }
403    line = nullptr;
404    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), bounding_box_.bottom());
405    while ((line = gsearch.NextVerticalSearch(true)) != nullptr) {
406      if (!line->IsHorizontalLine()) {
407        break;
408      }
409      TBOX text_search(bounding_box_.left(), line->MidY(), bounding_box_.right(),
410                       bounding_box_.bottom() - 1);
411      if (text_search.height() > median_cell_height_ * 2) {
412        break;
413      }
414      if (CountPartitions(text_search) > 0) {
415        break;
416      }
417      bounding_box_.set_bottom(line->MidY());
418    }
419  }
420  void StructuredTable::FindCellSplitLocations(const std::vector<int> &min_list,
421                                               const std::vector<int> &max_list, int max_merged,
422                                               std::vector<int> *locations) {
423    locations->clear();
424    ASSERT_HOST(min_list.size() == max_list.size());
425    if (min_list.empty()) {
426      return;
427    }
428    ASSERT_HOST(min_list.at(0) < max_list.at(0));
429    ASSERT_HOST(min_list.at(min_list.size() - 1) < max_list.at(max_list.size() - 1));
430    locations->push_back(min_list.at(0));
431    unsigned min_index = 0;
432    unsigned max_index = 0;
433    int stacked_partitions = 0;
434    int last_cross_position = INT32_MAX;
435    while (min_index < min_list.size()) {
436      if (min_list[min_index] < max_list[max_index]) {
437        ++stacked_partitions;
438        if (last_cross_position != INT32_MAX && stacked_partitions > max_merged) {
439          int mid = (last_cross_position + min_list[min_index]) / 2;
440          locations->push_back(mid);
441          last_cross_position = INT32_MAX;
442        }
443        ++min_index;
444      } else {
445        --stacked_partitions;
446        if (last_cross_position == INT32_MAX && stacked_partitions <= max_merged) {
447          last_cross_position = max_list[max_index];
448        }
449        ++max_index;
450      }
451    }
452    locations->push_back(max_list.at(max_list.size() - 1));
453  }
454  int StructuredTable::CountVerticalIntersections(int x) {
455    int count = 0;
456    const int kGridSize = text_grid_->gridsize();
457    TBOX vertical_box = bounding_box_;
458    vertical_box.set_left(x - kGridSize);
459    vertical_box.set_right(x + kGridSize);
460    ColPartitionGridSearch gsearch(text_grid_);
461    gsearch.SetUniqueMode(true);
462    gsearch.StartRectSearch(vertical_box);
463    ColPartition *text = nullptr;
464    while ((text = gsearch.NextRectSearch()) != nullptr) {
465      if (!text->IsTextType()) {
466        continue;
467      }
468      const TBOX &box = text->bounding_box();
469      if (box.left() < x && x < box.right()) {
470        ++count;
471      }
472    }
473    return count;
474  }
475  int StructuredTable::CountHorizontalIntersections(int y) {
476    int count = 0;
477    const int kGridSize = text_grid_->gridsize();
478    TBOX horizontal_box = bounding_box_;
479    horizontal_box.set_bottom(y - kGridSize);
480    horizontal_box.set_top(y + kGridSize);
481    ColPartitionGridSearch gsearch(text_grid_);
482    gsearch.SetUniqueMode(true);
483    gsearch.StartRectSearch(horizontal_box);
484    ColPartition *text = nullptr;
485    while ((text = gsearch.NextRectSearch()) != nullptr) {
486      if (!text->IsTextType()) {
487        continue;
488      }
489      const TBOX &box = text->bounding_box();
490      if (box.bottom() < y && y < box.top()) {
491        ++count;
492      }
493    }
494    return count;
495  }
496  int StructuredTable::CountPartitions(const TBOX &box) {
497    ColPartitionGridSearch gsearch(text_grid_);
498    gsearch.SetUniqueMode(true);
499    gsearch.StartRectSearch(box);
500    int count = 0;
501    ColPartition *text = nullptr;
502    while ((text = gsearch.NextRectSearch()) != nullptr) {
503      if (text->IsTextType()) {
504        ++count;
505      }
506    }
507    return count;
508  }
509  void TableRecognizer::Init() {}
510  void TableRecognizer::set_text_grid(ColPartitionGrid *text_grid) {
511    text_grid_ = text_grid;
512  }
513  void TableRecognizer::set_line_grid(ColPartitionGrid *line_grid) {
514    line_grid_ = line_grid;
515  }
516  void TableRecognizer::set_min_height(int height) {
517    min_height_ = height;
518  }
519  void TableRecognizer::set_min_width(int width) {
520    min_width_ = width;
521  }
522  void TableRecognizer::set_max_text_height(int height) {
523    max_text_height_ = height;
524  }
525  StructuredTable *TableRecognizer::RecognizeTable(const TBOX &guess) {
526    auto *table = new StructuredTable();
527    table->Init();
528    table->set_text_grid(text_grid_);
529    table->set_line_grid(line_grid_);
530    table->set_max_text_height(max_text_height_);
531    if (RecognizeLinedTable(guess, table)) {
532      return table;
533    }
534    if (RecognizeWhitespacedTable(guess, table)) {
535      return table;
536    }
537    delete table;
538    return nullptr;
539  }
540  bool TableRecognizer::RecognizeLinedTable(const TBOX &guess_box, StructuredTable *table) {
541    if (!HasSignificantLines(guess_box)) {
542      return false;
543    }
544    TBOX line_bound = guess_box;
545    if (!FindLinesBoundingBox(&line_bound)) {
546      return false;
547    }
548    table->set_bounding_box(line_bound);
549    return table->FindLinedStructure();
550  }
551  bool TableRecognizer::HasSignificantLines(const TBOX &guess) {
552    ColPartitionGridSearch box_search(line_grid_);
553    box_search.SetUniqueMode(true);
554    box_search.StartRectSearch(guess);
555    ColPartition *line = nullptr;
556    int vertical_count = 0;
557    int horizontal_count = 0;
558    while ((line = box_search.NextRectSearch()) != nullptr) {
559      if (line->IsHorizontalLine()) {
560        ++horizontal_count;
561      }
562      if (line->IsVerticalLine()) {
563        ++vertical_count;
564      }
565    }
566    return vertical_count >= kLinedTableMinVerticalLines &&
567           horizontal_count >= kLinedTableMinHorizontalLines;
568  }
569  bool TableRecognizer::FindLinesBoundingBox(TBOX *bounding_box) {
570    if (!FindLinesBoundingBoxIteration(bounding_box)) {
571      return false;
572    }
573    bool changed = true;
574    while (changed) {
575      changed = false;
576      int old_area = bounding_box->area();
577      bool check = FindLinesBoundingBoxIteration(bounding_box);
578      ASSERT_HOST(check);
579      ASSERT_HOST(bounding_box->area() >= old_area);
580      changed = (bounding_box->area() > old_area);
581    }
582    return true;
583  }
584  bool TableRecognizer::FindLinesBoundingBoxIteration(TBOX *bounding_box) {
585    ColPartitionGridSearch box_search(line_grid_);
586    box_search.SetUniqueMode(true);
587    box_search.StartRectSearch(*bounding_box);
588    ColPartition *line = nullptr;
589    bool first_line = true;
590    while ((line = box_search.NextRectSearch()) != nullptr) {
591      if (line->IsLineType()) {
592        if (first_line) {
593          *bounding_box = line->bounding_box();
594          first_line = false;
595        } else {
596          *bounding_box += line->bounding_box();
597        }
598      }
599    }
600    return !first_line;
601  }
602  bool TableRecognizer::RecognizeWhitespacedTable(const TBOX &guess_box, StructuredTable *table) {
603    TBOX best_box = guess_box; 
604    int best_below = 0;        
605    int best_above = 0;        
606    TBOX adjusted = guess_box; 
607    const int kMidGuessY = (guess_box.bottom() + guess_box.top()) / 2;
608    unsigned best_cols = 0;
<span onclick='openModal()' class='match'>609    bool found_good_border = false;
610    int last_bottom = INT32_MAX;
611    int bottom =
612        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY - min_height_ / 2, true);
613    int top =
614        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY + min_height_ / 2, false);
615    adjusted.set_top(top);
616    int previous_below = 0;
617    const int kMaxChances = 10;
</span>618    int chances = kMaxChances;
619    while (bottom != last_bottom) {
620      adjusted.set_bottom(bottom);
621      if (adjusted.height() >= min_height_) {
622        table->set_bounding_box(adjusted);
623        if (table->FindWhitespacedStructure() &&
624            table->column_count() >= best_cols * kRequiredColumns) {
625          if (false && IsWeakTableRow(table, 0)) {
626            --chances;
627          } else {
628            chances = kMaxChances;
629            double max_row_height = kMaxRowSize * table->median_cell_height();
630            if ((table->space_below() * kMarginFactor >= best_below &&
631                 table->space_below() >= previous_below) ||
632                (table->CountFilledCellsInRow(0) > 1 && table->row_height(0) < max_row_height)) {
633              best_box.set_bottom(bottom);
634              best_below = table->space_below();
635              best_cols = std::max(table->column_count(), best_cols);
636              found_good_border = true;
637            }
638          }
639          previous_below = table->space_below();
640        } else {
641          --chances;
642        }
643      }
644      if (chances <= 0) {
645        break;
646      }
647      last_bottom = bottom;
648      bottom = NextHorizontalSplit(guess_box.left(), guess_box.right(), last_bottom, true);
649    }
650    if (!found_good_border) {
651      return false;
652    }
653    found_good_border = false;
654    int last_top = INT32_MIN;
655    top =
656        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY + min_height_ / 2, false);
657    int previous_above = 0;
658    chances = kMaxChances;
659    adjusted.set_bottom(best_box.bottom());
660    while (last_top != top) {
661      adjusted.set_top(top);
662      if (adjusted.height() >= min_height_) {
663        table->set_bounding_box(adjusted);
664        if (table->FindWhitespacedStructure() &&
665            table->column_count() >= best_cols * kRequiredColumns) {
666          int last_row = table->row_count() - 1;
667          if (false && IsWeakTableRow(table, last_row)) {
668            --chances;
669          } else {
670            chances = kMaxChances;
671            double max_row_height = kMaxRowSize * table->median_cell_height();
672            if ((table->space_above() * kMarginFactor >= best_above &&
673                 table->space_above() >= previous_above) ||
674                (table->CountFilledCellsInRow(last_row) > 1 &&
675                 table->row_height(last_row) < max_row_height)) {
676              best_box.set_top(top);
677              best_above = table->space_above();
678              best_cols = std::max(table->column_count(), best_cols);
679              found_good_border = true;
680            }
681          }
682          previous_above = table->space_above();
683        } else {
684          --chances;
685        }
686      }
687      if (chances <= 0) {
688        break;
689      }
690      last_top = top;
691      top = NextHorizontalSplit(guess_box.left(), guess_box.right(), last_top, false);
692    }
693    if (!found_good_border) {
694      return false;
695    }
696    if (best_box.null_box()) {
697      return false;
698    }
699    table->set_bounding_box(best_box);
700    return table->FindWhitespacedStructure();
701  }
702  int TableRecognizer::NextHorizontalSplit(int left, int right, int y, bool top_to_bottom) {
703    ColPartitionGridSearch gsearch(text_grid_);
704    gsearch.SetUniqueMode(true);
705    gsearch.StartVerticalSearch(left, right, y);
706    ColPartition *text = nullptr;
707    int last_y = y;
708    while ((text = gsearch.NextVerticalSearch(top_to_bottom)) != nullptr) {
709      if (!text->IsTextType() || !text->IsHorizontalType()) {
710        continue;
711      }
712      if (text->bounding_box().height() > max_text_height_) {
713        continue;
714      }
715      const TBOX &text_box = text->bounding_box();
716      if (top_to_bottom && (last_y >= y || last_y <= text_box.top())) {
717        last_y = std::min(last_y, static_cast<int>(text_box.bottom()));
718        continue;
719      }
720      if (!top_to_bottom && (last_y <= y || last_y >= text_box.bottom())) {
721        last_y = std::max(last_y, static_cast<int>(text_box.top()));
722        continue;
723      }
724      return last_y;
725    }
726    return last_y;
727  }
728  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowlearn.cpp</h3>
            <pre><code>1  void TBowLearn::TrainMajorityMd(const PBowDocBs& BowDocBs, TFltV& MdCatExWgtV){
2    int AllCats=BowDocBs->GetCats();
3    double SumCatExWgt=0;
4    {for (int DIdN=0; DIdN<BowDocBs->GetTrainDocs(); DIdN++){
5      int DId=BowDocBs->GetTrainDId(DIdN);
6      int CIds=BowDocBs->GetDocCIds(DId);
7      for (int CIdN=0; CIdN<CIds; CIdN++){
8        int CId=BowDocBs->GetDocCId(DId, CIdN);
9        MdCatExWgtV[CId]++; SumCatExWgt++;
10      }
11    }}
12    if (SumCatExWgt>0){
13      for (int CId=0; CId<AllCats; CId++){
14        MdCatExWgtV[CId]/=SumCatExWgt;
15        TStr CatNm=BowDocBs->GetCatNm(CId);
16      }
17    } else {printf("No training examples!\n");}
18  }
19  double TBowLearn::TestMajorityMd(const PBowDocBs& BowDocBs,
20   TFltV& MdCatExWgtV, FILE* OutFile, int& TestExs){
21    int AllCats=BowDocBs->GetCats();
22    double CorrectExs=0; TestExs=0;
23    int MajorCId=-1; TFlt MajorCatWgt=0;
24    {for (int CId=0; CId<AllCats; CId++){
25      if (MdCatExWgtV[CId]>MajorCatWgt){MajorCId=CId; MajorCatWgt=MdCatExWgtV[CId];}
26    }}
27    if (MajorCId>-1){
28      TStr CatNm=BowDocBs->GetCatNm(MajorCId);
29      printf("\nMajority category P(%d:%s)=%.5f\n", MajorCId, CatNm(), MajorCatWgt()); /&bsol;**
30      fprintf(OutFile, "\nMajority category P(%d:%s)=%.5f\n", MajorCId, CatNm(), MajorCatWgt());
31    } else {
32      printf("No category with probability > 0\n"); /&bsol;**
33      fprintf(OutFile, "No category with probability > 0\n");
34      return CorrectExs;
35    }
36    for (int DIdN=0; DIdN<BowDocBs->GetTestDocs(); DIdN++){
37      int DId=BowDocBs->GetTestDId(DIdN);
38      int WIds=BowDocBs->GetDocWIds(DId);
39      int CIds=BowDocBs->GetDocCIds(DId);
40      TestExs++;
41      fprintf(OutFile, "Document vector:");
42      {for (int WIdN=0; WIdN<WIds; WIdN++){
43        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
44        TStr WordStr=BowDocBs->GetWordStr(WId);
45        for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
46          fprintf(OutFile, "%s ", WordStr.CStr()); /&bsol;**
47        }
48      }}
49      fprintf(OutFile, "\n");
50      {for (int CIdN=0; CIdN<CIds; CIdN++){
51        int CId=BowDocBs->GetDocCId(DId, CIdN);
52        TStr CatNm=BowDocBs->GetCatNm(CId);
53        fprintf(OutFile, "[%d:%s] ", CId, CatNm());
54        if (CId==MajorCId){CorrectExs+=1/double(CIds);}
55      }}
56      fprintf(OutFile, "  --> ");
57      int CId=MajorCId;
58      TStr CatNm=BowDocBs->GetCatNm(CId);
59      fprintf(OutFile, "\n  [%d:%s]:%.5f ", CId, CatNm(), MajorCatWgt());
60      fprintf(OutFile, "\n    Model evidence: majority class value");
61      fprintf(OutFile, "\n");
62    }
63    printf("Testing documents:%d, Non-empty documents:%d ",
64     BowDocBs->GetTestDocs(), TestExs);
65    fprintf(OutFile, "Testing documents:%d, Non-empty documents:%d ",
66     BowDocBs->GetTestDocs(), TestExs);
67    if (TestExs>0){
68      printf("CorrectExs:%.5f\n", CorrectExs);
69      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
70    } else {
71      printf("CorrectExs:%.5f\n", CorrectExs);
72      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
73    }
74    return CorrectExs;
75  }
76  void TBowLearn::TrainInvertedMd(const PBowDocBs& BowDocBs,
77   TFltVV& MdWordCatWgtVV, TFltV& MdWordWgtV, TFltV& MdCatWgtV){
78    int AllWords=BowDocBs->GetWords();
79    int AllCats=BowDocBs->GetCats();
80    for (int DIdN=0; DIdN<BowDocBs->GetTrainDocs(); DIdN++){
81      int DId=BowDocBs->GetTrainDId(DIdN);
82      int WIds=BowDocBs->GetDocWIds(DId);
83      int CIds=BowDocBs->GetDocCIds(DId);
84      for (int WIdN=0; WIdN<WIds; WIdN++){
85        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
86        for (int CIdN=0; CIdN<CIds; CIdN++){
87          int CId=BowDocBs->GetDocCId(DId, CIdN);
88          double CatWgt=WordFq*(1/double(CIds));
89          MdWordCatWgtVV.At(WId, CId)+=CatWgt;
90        }
91      }
92    }
93    for (int WId=0; WId<AllWords; WId++){
94      double SumWordCatWgt=0;
95      for (int CId=0; CId<AllCats; CId++){
96        SumWordCatWgt+=MdWordCatWgtVV.At(WId, CId);}
97      if (SumWordCatWgt>0){
98        for (int CId=0; CId<AllCats; CId++){
99          MdWordCatWgtVV.At(WId, CId)/=SumWordCatWgt;}
100      }
101      double WordWgt=0;
102      {for (int CId=0; CId<AllCats; CId++){
103        double WordCatWgt=MdWordCatWgtVV.At(WId, CId);
104        if (WordCatWgt>=0){
105          WordWgt-=WordCatWgt*log(WordCatWgt);}
106      }}
107      TStr WordStr=BowDocBs->GetWordStr(WId);
108      MdWordWgtV[WId]=1/(1+TMath::Sqr(WordWgt));
109    }
110    printf("\n"); /&bsol;**
111    double SumCatExWgt=0;
112    {for (int DIdN=0; DIdN<BowDocBs->GetTrainDocs(); DIdN++){
113      int DId=BowDocBs->GetTrainDId(DIdN);
114      int CIds=BowDocBs->GetDocCIds(DId);
115      for (int CIdN=0; CIdN<CIds; CIdN++){
116        int CId=BowDocBs->GetDocCId(DId, CIdN);
117       MdCatWgtV[CId]++; SumCatExWgt++;
118      }
119    }}
120    if (SumCatExWgt>0){
121      for (int CId=0; CId<AllCats; CId++){
122        TStr CatNm=BowDocBs->GetCatNm(CId); /&bsol;**
123        MdCatWgtV[CId]=1/log(1+1+TMath::Sqr(MdCatWgtV[CId]));
124      }
125      printf("\n"); /&bsol;**
126    } else {printf("No training examples!\n");}
127  }
128  double TBowLearn::TestInvertedMd(const PBowDocBs& BowDocBs,
129   TFltVV& MdWordCatWgtVV, TFltV& MdWordWgtV, TFltV& MdCatWgtV,
130   FILE* OutFile, int& TestExs){
131    int AllCats=BowDocBs->GetCats();
132    double CorrectExs=0; TestExs=0;
133    int MajorCId=-1; TFlt MajorCatWgt=0;
134    {for (int CId=0; CId<AllCats; CId++){
135      if (MdCatWgtV[CId]>MajorCatWgt){MajorCId=CId; MajorCatWgt=MdCatWgtV[CId];}
136    }}
137    if (MajorCId>-1){
138      TStr CatNm=BowDocBs->GetCatNm(MajorCId);
139      printf("\nMajority category P(%d:%s])=%.5f\n", MajorCId, CatNm(), MajorCatWgt()); /&bsol;**
140      fprintf(OutFile, "\nMajority category P(%d:%s])=%.5f\n", MajorCId, CatNm(), MajorCatWgt());
141    } else {
142      printf("No category with probability > 0\n"); /&bsol;**
143      fprintf(OutFile, "No category with probability > 0\n");
144    }
145    for (int DIdN=0; DIdN<BowDocBs->GetTestDocs(); DIdN++){
146      int DId=BowDocBs->GetTestDId(DIdN);
147      int WIds=BowDocBs->GetDocWIds(DId);
148      int CIds=BowDocBs->GetDocCIds(DId);
149      if (WIds==0){printf("It is hard to classify an empty document!\n"); continue;}
150      TFltIntKdV CatWgtCIdKdV(AllCats);
151      {for (int CId=0; CId<AllCats; CId++){
152        CatWgtCIdKdV[CId].Dat=CId; CatWgtCIdKdV[CId].Key=0;
153      }}
154      {for (int WIdN=0; WIdN<WIds; WIdN++){
155        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
156        printf("MdWordWgtV[%d]:%.3f ", WId, MdWordWgtV[WId]());/&bsol;**
157        for (int CId=0; CId<AllCats; CId++){
158          double CatWgt=
159           WordFq*MdCatWgtV[CId]*MdWordWgtV[WId]*MdWordCatWgtVV.At(WId, CId);
160          CatWgtCIdKdV[CId].Key+=CatWgt;
161          if ((CId==5)||(CId==130)){printf("CatWgt[%d]=%.1f*%.3f*%.3f*%.3f\n",
162              CId, WordFq, MdCatWgtV[CId](), MdWordWgtV[WId](), MdWordCatWgtVV.At(WId, CId)());} /&bsol;**
163          if ((CId==5)||(CId==130)){printf("CatWgt.Key[%d]=%.5f\n", CId, CatWgtCIdKdV[CId].Key());} /&bsol;**
164        }
165      }}
166      double SumCatWgt=0;
167      {for (int CId=0; CId<AllCats; CId++){
168        SumCatWgt+=CatWgtCIdKdV[CId].Key;
169        if ((CId==5)||(CId==130)){ /&bsol;**
170          printf("\nMdCatWgtV[%d]=%.5f CatWgt[%d]=%.5f\n", CId, MdCatWgtV[CId](),
171            CId, CatWgtCIdKdV[CId].Key());
172        }
173      }}
174      printf("\n");
175      if (SumCatWgt>0){
176        for (int CId=0; CId<AllCats; CId++){CatWgtCIdKdV[CId].Key/=SumCatWgt;}
177      }
178      CatWgtCIdKdV.Sort(false);
179      printf("BestCat:%d, prob:%.5f\n", CatWgtCIdKdV[0].Dat(), CatWgtCIdKdV[0].Key()); /&bsol;**
180      if (CatWgtCIdKdV[0].Key<=0.0001){ 
181        printf("No category found for %d!\n", DId); /&bsol;**
182        fprintf(OutFile, "No category found for %d!\n", DId);
183        continue;
184      }
185      double SumCatWgtSF=0; TIntV BestCIdV;
186      for (int CIdN=0; CIdN<AllCats; CIdN++){
187        double CatWgt=CatWgtCIdKdV[CIdN].Key;
188        int CId=CatWgtCIdKdV[CIdN].Dat;
189        SumCatWgtSF+=CatWgt; BestCIdV.Add(CId);
190        if (SumCatWgtSF>0.25){break;}
191      }
192      TestExs++;
193      printf("Document vector: "); /&bsol;**
194      fprintf(OutFile, "Document vector:");
195      {for (int WIdN=0; WIdN<WIds; WIdN++){
196        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
197        TStr WordStr=BowDocBs->GetWordStr(WId);
198        for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
199          printf("%s ", WordStr.CStr()); /&bsol;**
200          fprintf(OutFile, "%s ", WordStr.CStr()); /&bsol;**
201        }
202      }}
203      printf("\n"); /&bsol;**
204      fprintf(OutFile, "\n");
205      {for (int CIdN=0; CIdN<CIds; CIdN++){
206        int CId=BowDocBs->GetDocCId(DId, CIdN);
207        TStr CatNm=BowDocBs->GetCatNm(CId);
208        printf("[%d:%s] ", CId, CatNm()); /&bsol;**
209        fprintf(OutFile, "[%d:%s] ", CId, CatNm());
210        if (BestCIdV.IsIn(CId)){CorrectExs+=1/double(CIds);}
211      }}
212      printf("  --> "); /&bsol;**
213      fprintf(OutFile, "  --> ");
214      {for (int CIdN=0; CIdN<BestCIdV.Len(); CIdN++){
215        int CId=BestCIdV[CIdN];
216        TStr CatNm=BowDocBs->GetCatNm(CId);
217        printf("\n  [%d:%s]:%.5f ", CId, CatNm(), CatWgtCIdKdV[CIdN].Key()); /&bsol;**
218        fprintf(OutFile, "\n  [%d:%s]:%.5f ", CId, CatNm(), CatWgtCIdKdV[CIdN].Key());
219        printf("\n    Model evidence: ");  /&bsol;**
220        fprintf(OutFile, "\n    Model evidence: ");
221        for (int WIdN=0; WIdN<WIds; WIdN++){
222          int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
223          if (MdWordCatWgtVV.At(WId, CId)>0){
224            TStr WordStr=BowDocBs->GetWordStr(WId);
225            printf("TF(%s)=%.1f ", WordStr.CStr(), MdWordCatWgtVV.At(WId, CId)()); /&bsol;**
226            fprintf(OutFile, "TF(%s)=%.1f ", WordStr.CStr(), MdWordCatWgtVV.At(WId, CId)());
227          }
228        }
229        printf("\n"); /&bsol;**
230        fprintf(OutFile, "\n");
231      }}
232      printf("\n"); /&bsol;**
233      fprintf(OutFile, "\n");
234    }
235    printf("Testing documents:%d, Non-empty documents:%d ",
236     BowDocBs->GetTestDocs(), TestExs);
237    fprintf(OutFile, "Testing documents:%d, Non-empty documents:%d ",
238     BowDocBs->GetTestDocs(), TestExs);
239    if (TestExs>0){
240      printf("CorrectExs:%.5f\n", CorrectExs);
241      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
242    } else {
243      printf("CorrectExs:%.5f\n", CorrectExs);
244      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
245    }
246    return CorrectExs;
247  }
248  void TBowLearn::TrainSimMd(const PBowDocBs& BowDocBs,
249   const TVec<TIntV>& DIdVV, TBowSpVV& ConceptSpVV){
250    int AllCats=BowDocBs->GetCats();
251    TIntV CtxTrainDIdV; BowDocBs->GetTrainDIdV(CtxTrainDIdV);
252    PBowDocWgtBs BowDocWgtBs= /&bsol;** Dunja: error, CtxTrainDIdV has 389 Ids, but their range is 0..3175
253     TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF, 0, 0, CtxTrainDIdV);
254    PBowSim BowSim=TBowSim::New(bstCos);
255    for (int CIdN=0; CIdN<AllCats; CIdN++){
256      ConceptSpVV[CIdN]=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, DIdVV[CIdN]);
257    }
258  }
259  double TBowLearn::TestSimMd(const PBowDocBs& BowDocBs,
260   const TBowSpVV& ConceptSpVV,
261   FILE* OutFile, int& TestExs){
262    int AllCats=BowDocBs->GetCats();
263    TIntV CtxTestDIdNV; BowDocBs->GetTestDIdV(CtxTestDIdNV);
264    PBowDocWgtBs BowDocWgtBs=
265     TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF, 0, 0, CtxTestDIdNV);
266    double CorrectExs=0; TestExs=0;
267    for (int DIdN=0; DIdN<BowDocBs->GetTestDocs(); DIdN++){
268      int DId=BowDocWgtBs->GetDId(DIdN);
269      PBowSpV SpV=BowDocWgtBs->GetSpV(DId);
270      int DIdx=BowDocBs->GetTestDId(DIdN);
271      printf("DIdx:%d = DId:%d ", DIdx, DId); 
272      int WIdsx=BowDocBs->GetDocWIds(DId);
273      int WIds=SpV->GetWIds();
274      printf("WIdsx:%d = WIds:%d", WIdsx, WIds); 
275      int CIds=BowDocBs->GetDocCIds(DId);
276      if (WIds==0){printf("It is hard to classify an empty document!\n"); continue;}
277      for (int WIdN=0; WIdN<WIds; WIdN++){
278        int WId=SpV->GetWId(WIdN); double WordWgt=SpV->GetWgt(WIdN);
279        printf("WId:%d  ", WId);
280        TStr WordStr=BowDocBs->GetWordStr(WId);
281        printf("%s:%.2f ", WordStr.CStr(), WordWgt); /&bsol;**
282      }
283      printf("\n");
284      PBowSim BowSim=TBowSim::New(bstCos);
285      TFltIntKdV CatWgtCIdKdV(AllCats);
286      for (int CId=0; CId<AllCats; CId++){
287        CatWgtCIdKdV[CId].Dat=CId;
288        CatWgtCIdKdV[CId].Key=BowSim->GetSim(ConceptSpVV[CId], SpV);
289        printf("Sim[%d]=%.3f ", CId, CatWgtCIdKdV[CId].Key());
290      }
291      CatWgtCIdKdV.Sort(false);
292      printf("BestCat:%d, prob:%.5f\n", CatWgtCIdKdV[0].Dat(), CatWgtCIdKdV[0].Key());
293      if (CatWgtCIdKdV[0].Key<=0.0001){ 
294        printf("No category found for %d!\n", DId); /&bsol;**
295        fprintf(OutFile, "No category found for %d!\n", DId);
296        continue;
297      }
298      double SumCatWgtSF=0; TIntV BestCIdV;
299      for (int CIdN=0; CIdN<AllCats; CIdN++){
300        double CatWgt=CatWgtCIdKdV[CIdN].Key;
301        int CId=CatWgtCIdKdV[CIdN].Dat;
302        SumCatWgtSF+=CatWgt; BestCIdV.Add(CId);
303        if (SumCatWgtSF>0.25){break;}
304      }
305      TestExs++;
306      {for (int CIdN=0; CIdN<CIds; CIdN++){
307        int CId=BowDocBs->GetDocCId(DId, CIdN);
308        TStr CatNm=BowDocBs->GetCatNm(CId);
309        printf("[%s]-%d ", CatNm(), CId); /&bsol;**
310        fprintf(OutFile, "[%s]-%d ", CatNm(), CId);
311        if (BestCIdV.IsIn(CId)){CorrectExs+=1/double(CIds);}
312      }}
313      printf("  Document: "); /&bsol;**
314      fprintf(OutFile, "  Document: ");
315      {for (int WIdN=0; WIdN<WIds; WIdN++){
316        int WId=SpV->GetWId(WIdN); double WordWgt=SpV->GetWgt(WIdN);
317        TStr WordStr=BowDocBs->GetWordStr(WId);
318        printf("%s:%.2f ", WordStr.CStr(), WordWgt);
319        fprintf(OutFile, "%s:%.2f ", WordStr.CStr(), WordWgt);
320      }}
321      printf("\n--> "); /&bsol;**
322      fprintf(OutFile, "\n--> ");
323      {for (int CIdN=0; CIdN<BestCIdV.Len(); CIdN++){
324        int CId=BestCIdV[CIdN];
325        TStr CatNm=BowDocBs->GetCatNm(CId);
326        printf("[%s]:%.5f ", CatNm(), CatWgtCIdKdV[CIdN].Key());
327        fprintf(OutFile, "[%s]:%.5f ", CatNm(), CatWgtCIdKdV[CIdN].Key());
328        for (int WIdN=0; WIdN<WIds; WIdN++){
329          int WId=SpV->GetWId(WIdN); double WordWgt=ConceptSpVV[CId]->GetWgt(WIdN);
330          if (WordWgt>0){
331            TStr WordStr=BowDocBs->GetWordStr(WId);
332            printf("TF(%s,%d)=%.5f ", WordStr.CStr(), CId, WordWgt);
333            fprintf(OutFile, "TF(%s,%d)=%.5f ", WordStr.CStr(), CId, WordWgt);
334          }
335        }
336      }}
337      printf("\n"); /&bsol;**
338      fprintf(OutFile, "\n");
339    }
340    return CorrectExs;
341  }
342  void TBowLearn::TrainNBayesMd(const PBowDocBs& BowDocBs,
343   TFltVV& MdWordCatWgtVV, TFltV& MdCatWgtV,
344   TFltV& MdCatExWgtV){
345    int AllWords=BowDocBs->GetWords();
346    int AllCats=BowDocBs->GetCats();
347    int TrainDocs=BowDocBs->GetTrainDocs();
348    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
349      int DId=BowDocBs->GetTrainDId(DIdN);
350      int WIds=BowDocBs->GetDocWIds(DId);
351      int CIds=BowDocBs->GetDocCIds(DId);
352      for (int WIdN=0; WIdN<WIds; WIdN++){
353        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
354        for (int CIdN=0; CIdN<CIds; CIdN++){
355          int CId=BowDocBs->GetDocCId(DId, CIdN);
356          double CatWgt=WordFq*(1/double(CIds));
357          MdWordCatWgtVV.At(WId, CId)+=CatWgt;
358        }
359      }
360    }
361    {for (int CId=0; CId<AllCats; CId++){
362      double SumWordCatWgt=0;
363      for (int WId=0; WId<AllWords; WId++){
364        SumWordCatWgt+=MdWordCatWgtVV.At(WId, CId);
365      }
366      MdCatWgtV[CId]=SumWordCatWgt;
367    }}
368    {for (int DIdN=0; DIdN<TrainDocs; DIdN++){
369      int DId=BowDocBs->GetTrainDId(DIdN);
370      int CIds=BowDocBs->GetDocCIds(DId);
371      for (int CIdN=0; CIdN<CIds; CIdN++){
372        int CId=BowDocBs->GetDocCId(DId, CIdN);
373        MdCatExWgtV[CId]++;
374      }
375    }}
376    if (TrainDocs>0){
377      for (int CId=0; CId<AllCats; CId++){
378        MdCatExWgtV[CId]/=TrainDocs;
379        TStr CatNm=BowDocBs->GetCatNm(CId);
380      }
381    } else {printf("No training examples!\n");}
382  }
383  double TBowLearn::TestNBayesMd(const PBowDocBs& BowDocBs,
384   TFltVV& MdWordCatWgtVV, TFltV& MdCatWgtV,
385   TFltV& MdCatExWgtV, FILE* OutFile, FILE* ErrFile, int& TestExs){
386    int AllWords=BowDocBs->GetWords();
387    int AllCats=BowDocBs->GetCats();
388    int MajorCId=-1; TFlt MajorCatWgt=0;
389    {for (int CId=0; CId<AllCats; CId++){
390      if (MdCatExWgtV[CId]>MajorCatWgt){MajorCId=CId; MajorCatWgt=MdCatExWgtV[CId];}
391    }}
392    if (MajorCId>-1){
393      TStr CatNm=BowDocBs->GetCatNm(MajorCId);
394      fprintf(OutFile, "      Majority P(%d:%s])=%.5f\n", MajorCId, CatNm(), MajorCatWgt());
395    } else {
396      fprintf(OutFile, "      No category with probability > 0\n");
397    }
398    double CorrectExs=0; TestExs=0;
399    for (int DIdN=0; DIdN<BowDocBs->GetTestDocs(); DIdN++){
400      int DId=BowDocBs->GetTestDId(DIdN);
401      int WIds=BowDocBs->GetDocWIds(DId);
402      int CIds=BowDocBs->GetDocCIds(DId);
403      if (WIds==0){printf("It is hard to classify an empty document!\n"); continue;}
404      TIntV ShareWordsCat(AllCats); 
405      TFltIntKdV CatWgtCIdKdV(AllCats);
406      {for (int CId=0; CId<AllCats; CId++){
407        ShareWordsCat[CId]=0;
408        CatWgtCIdKdV[CId].Dat=CId; CatWgtCIdKdV[CId].Key=0;
409      }}
410      {for (int CId=0; CId<AllCats; CId++){
411        if(MdCatExWgtV[CId]>0){ 
412          for (int WIdN=0; WIdN<WIds; WIdN++){
413            int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
414            WordFq=1;
415            if(MdWordCatWgtVV.At(WId, CId)>0){
416              ShareWordsCat[CId]=1;
417            }
418            double CatWgt=(MdWordCatWgtVV.At(WId, CId)+1)/(MdCatWgtV[CId]+double(AllWords));
419            CatWgtCIdKdV[CId].Key+=(log(CatWgt)*WordFq);
420          }
421          CatWgtCIdKdV[CId].Key+=log(double(MdCatExWgtV[CId]));
422        } else {
423          CatWgtCIdKdV[CId].Key=TFlt::NInf;
424        }
425      }}
426      CatWgtCIdKdV.Sort(false);
427      if(ShareWordsCat[CatWgtCIdKdV[0].Dat]==0){ 
428        continue; 
429      }
430      double SumCatWgt=0;
431      {for (int CIdN=0; CIdN<AllCats; CIdN++){
432        if (ShareWordsCat[CatWgtCIdKdV[CIdN].Dat]==1){
433          CatWgtCIdKdV[CIdN].Key=exp(double(CatWgtCIdKdV[CIdN].Key));
434        } else {CatWgtCIdKdV[CIdN].Key=0;}
435        SumCatWgt+=CatWgtCIdKdV[CIdN].Key;
436      }}
437      if (SumCatWgt>0){
438        {for (int CIdN=0; CIdN<AllCats; CIdN++){
439          CatWgtCIdKdV[CIdN].Key/=SumCatWgt;
440        }}
441      }
442      double SumCatWgtSF=0; TIntV BestCIdV;
443      {for (int CIdN=0; CIdN<AllCats; CIdN++){
444        double CatWgt=CatWgtCIdKdV[CIdN].Key;
445        int CId=CatWgtCIdKdV[CIdN].Dat;
446        SumCatWgtSF+=CatWgt; BestCIdV.Add(CId);
447        if (SumCatWgtSF>0.25){break;}
448      }}
449      bool ErrorInClass=true;
450      {for (int CIdN=0; CIdN<CIds; CIdN++){
451        int CId=BowDocBs->GetDocCId(DId, CIdN);
452        if (BestCIdV.IsIn(CId)){ErrorInClass=false;}
453      }}
454      if (ErrorInClass){fprintf(ErrFile, "%s\n", BowDocBs->GetDocNm(DId).CStr());}
455      TestExs++;
456      fprintf(OutFile, "Document vector:");
457      {for (int WIdN=0; WIdN<WIds; WIdN++){
458        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
459        TStr WordStr=BowDocBs->GetWordStr(WId);
460        for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
461          fprintf(OutFile, "%s ", WordStr.CStr()); /&bsol;**
462        }
463      }}
464      fprintf(OutFile, "\n");
465      {for (int CIdN=0; CIdN<CIds; CIdN++){
466        int CId=BowDocBs->GetDocCId(DId, CIdN);
467        TStr CatNm=BowDocBs->GetCatNm(CId);
468        fprintf(OutFile, "[%d:%s] ", CId, CatNm());
469        if (BestCIdV.IsIn(CId)){CorrectExs+=1/double(CIds);}
470      }}
471      fprintf(OutFile, "  --> ");
472      {for (int CIdN=0; CIdN<BestCIdV.Len(); CIdN++){
473        int CId=BestCIdV[CIdN];
474        TStr CatNm=BowDocBs->GetCatNm(CId);
475        fprintf(OutFile, "\n  [%d:%s]:%.5f ", CId, CatNm(), CatWgtCIdKdV[CIdN].Key());
476        fprintf(OutFile, "\n    Model evidence: ");
477        for (int WIdN=0; WIdN<WIds; WIdN++){
478          int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
479          if (MdWordCatWgtVV.At(WId, CId)>0){
480            TStr WordStr=BowDocBs->GetWordStr(WId);
481            fprintf(OutFile, "TF(%s)=%.1f ", WordStr.CStr(), MdWordCatWgtVV.At(WId, CId)());
482          }
483        }
484        fprintf(OutFile, "\n");
485      }}
486      fprintf(OutFile, "\n");
487    }
488    fprintf(OutFile, "Testing documents:%d, Non-empty documents:%d ", BowDocBs->GetTestDocs(), TestExs);
489    if (TestExs>0){
490      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
491    } else {
492      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
493    }
494    return CorrectExs;
495  }
496  void TBowLearn::TrainBinNBayesMd(const PBowDocBs& BowDocBs,
497   TFltVV& MdWordCatWgtVV, TFltV& MdCatWgtV,
498   TFltV& MdCatExWgtV, const TFileId& OutFile){
499    int AllWords=BowDocBs->GetWords();
500    int AllCats=BowDocBs->GetCats();
501    int TrainDocs=BowDocBs->GetTrainDocs();
502    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
503      int DId=BowDocBs->GetTrainDId(DIdN);
504      int WIds=BowDocBs->GetDocWIds(DId);
505      int CIds=BowDocBs->GetDocCIds(DId);
506      for (int WIdN=0; WIdN<WIds; WIdN++){
507        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
508        for (int CIdN=0; CIdN<CIds; CIdN++){
509          int CId=BowDocBs->GetDocCId(DId, CIdN);
510          double CatWgt=WordFq*(1/double(CIds));
511          MdWordCatWgtVV.At(WId, CId)+=CatWgt;
512        }
513      }
514    }
515    {for (int CId=0; CId<AllCats; CId++){
516      double SumWordCatWgt=0;
517      for (int WId=0; WId<AllWords; WId++){
518        SumWordCatWgt+=MdWordCatWgtVV.At(WId, CId);
519      }
520      MdCatWgtV[CId]=SumWordCatWgt;
521    }}
522    {for (int DIdN=0; DIdN<TrainDocs; DIdN++){
523      int DId=BowDocBs->GetTrainDId(DIdN);
524      int CIds=BowDocBs->GetDocCIds(DId);
525      for (int CIdN=0; CIdN<CIds; CIdN++){
526        int CId=BowDocBs->GetDocCId(DId, CIdN);
527        MdCatExWgtV[CId]++;
528      }
529    }}
530    if (TrainDocs>0){
531      for (int CId=0; CId<AllCats; CId++){
532        MdCatExWgtV[CId]/=TrainDocs;
533        TStr CatNm=BowDocBs->GetCatNm(CId);
534      }
535    } else {printf("No training examples!\n");}
536    fprintf(OutFile, "\n# NBayes Model\n");
537    fprintf(OutFile, "# Feature");
538    for (int CId=0; CId<AllCats; CId++){
539      TStr CatNm=BowDocBs->GetCatNm(CId);
540      fprintf(OutFile, ", %s_Weight", CatNm.CStr());
541    }
542    fprintf(OutFile, "\n");
543    {for (int WId=0; WId<AllWords; WId++){
544      fprintf(OutFile, "%s", BowDocBs->GetWordStr(WId).CStr());
545      for (int CId=0; CId<AllCats; CId++){
546        fprintf(OutFile, ", %0.5f", MdWordCatWgtVV.At(WId, CId)());
547      }
548      fprintf(OutFile, "\n");
549    }}
550  }
551  void TBowLearn::TestBinNBayesMd(const PBowDocBs& BowDocBs,
552   const TStr& TargetCatNm,
553   TFltVV& MdWordCatWgtVV, TFltV& MdCatWgtV, TFltV& MdCatExWgtV,
554   const TFileId& TrainOutFile, const TFileId& TestOutFile, const TFileId& ErrFile){
555    double MnProb=0.00000001;
556    int AllWords=BowDocBs->GetWords();
557    int AllCats=BowDocBs->GetCats();
558    int TargetCId=BowDocBs->GetCId(TargetCatNm);
559    int TrainDocs=BowDocBs->GetTrainDocs();
560    int TestDocs=BowDocBs->GetTestDocs();
561    int MajorCId=-1; TFlt MajorCatWgt=0;
562    {for (int CId=0; CId<AllCats; CId++){
563      if (MdCatExWgtV[CId]>MajorCatWgt){MajorCId=CId; MajorCatWgt=MdCatExWgtV[CId];}
564    }}
565    if (MajorCId>-1){
566      TStr CatNm=BowDocBs->GetCatNm(MajorCId);
567      printf("      Majority P([%d]:%s)=%.5f\n", MajorCId, CatNm(), MajorCatWgt()); /&bsol;**
568      fprintf(ErrFile, "      Majority P([%d]:%s)=%.5f\n", MajorCId, CatNm(), MajorCatWgt());
569    } else {
570      printf("      No category with probability > 0\n"); /&bsol;**
571      fprintf(ErrFile, "      No category with probability > 0\n");
572    }
573    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
574    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
575      int DId=BowDocBs->GetTrainDId(DIdN);
576      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
577      int DocWIds=BowDocBs->GetDocWIds(DId);
578      if (DocWIds==0){
579        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
580      }
581      TFltIntKdV CatWgtCIdKdV(AllCats);
582      {for (int CId=0; CId<AllCats; CId++){
583        CatWgtCIdKdV[CId].Dat=CId; CatWgtCIdKdV[CId].Key=0;
584      }}
585      {for (int WIdN=0; WIdN<DocWIds; WIdN++){
586        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
587        WordFq=1; 
588        for (int CId=0; CId<AllCats; CId++){
589          double CatWgt=(MdWordCatWgtVV.At(WId, CId)+1)/(MdCatWgtV[CId]+double(AllWords));
590          CatWgtCIdKdV[CId].Key+=(log(CatWgt)*WordFq);
591        }
592      }}
593      {for (int CId=0; CId<AllCats; CId++){
594        if(MdCatExWgtV[CId]>0){
595          CatWgtCIdKdV[CId].Key+=log(double(MdCatExWgtV[CId]));
596        } else {CatWgtCIdKdV[CId].Key=TFlt::NInf;}
597      }}
598      CatWgtCIdKdV.Sort(false); 
599      {for (int CId=1; CId<AllCats; CId++){
600        CatWgtCIdKdV[CId].Key-=CatWgtCIdKdV[0].Key;
601      }}
602      CatWgtCIdKdV[0].Key-=CatWgtCIdKdV[0].Key;
603      double SumCatWgt=0;
604      for (int CId=0; CId<AllCats; CId++){
605        CatWgtCIdKdV[CId].Key=exp(double(CatWgtCIdKdV[CId].Key));
606        SumCatWgt+=CatWgtCIdKdV[CId].Key;
607      }
608      if (SumCatWgt>0){
609        for (int CId=0; CId<AllCats; CId++){CatWgtCIdKdV[CId].Key/=SumCatWgt;}
610      }
611      if (CatWgtCIdKdV[0].Key<=MnProb){ 
612        CatWgtCIdKdV[0].Dat=MajorCId; CatWgtCIdKdV[0].Key=MajorCatWgt;
613      }
614      bool PredClassVal;
615      PredClassVal=(CatWgtCIdKdV[0].Dat==TargetCId);
616      if (PredClassVal==ClassVal){
617        if (PredClassVal){TruePos++;} else {TrueNeg++;}
618      } else {
619        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
620      }
621      int ClassValN=(ClassVal)?1:-1;
622      int PredClassValN=(PredClassVal)?1:-1;
623      fprintf(TrainOutFile, "%0.6f # true=%d # docDesc=%s\n",
624       PredClassValN*CatWgtCIdKdV[0].Key, ClassValN, BowDocBs->GetDocNm(DId).CStr());
625    }}
626    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
627    for (int DIdN=0; DIdN<TestDocs; DIdN++){
628      int DId=BowDocBs->GetTestDId(DIdN);
629      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
630      int DocWIds=BowDocBs->GetDocWIds(DId);
631      if (DocWIds==0){
632        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
633      }
634      TFltIntKdV CatWgtCIdKdV(AllCats);
635      {for (int CId=0; CId<AllCats; CId++){
636        CatWgtCIdKdV[CId].Dat=CId; CatWgtCIdKdV[CId].Key=0;
637      }}
638      {for (int WIdN=0; WIdN<DocWIds; WIdN++){
639        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
640        WordFq=1; 
641        for (int CId=0; CId<AllCats; CId++){
642          double CatWgt=(MdWordCatWgtVV.At(WId, CId)+1)/(MdCatWgtV[CId]+double(AllWords));
643          CatWgtCIdKdV[CId].Key+=(log(CatWgt)*WordFq);
644        }
645      }}
646      {for (int CId=0; CId<AllCats; CId++){
647        CatWgtCIdKdV[CId].Key+=log(double(MdCatExWgtV[CId]));
648      }}
649      CatWgtCIdKdV.Sort(false); 
650      {for (int CId=1; CId<AllCats; CId++){
651        CatWgtCIdKdV[CId].Key-=CatWgtCIdKdV[0].Key;
652      }}
653      CatWgtCIdKdV[0].Key-=CatWgtCIdKdV[0].Key;
654      double SumCatWgt=0;
655      for (int CId=0; CId<AllCats; CId++){
656        CatWgtCIdKdV[CId].Key=exp(double(CatWgtCIdKdV[CId].Key));
657        SumCatWgt+=CatWgtCIdKdV[CId].Key;
658      }
659      if (SumCatWgt>0){
660        for (int CId=0; CId<AllCats; CId++){CatWgtCIdKdV[CId].Key/=SumCatWgt;}
661      }
662      if (CatWgtCIdKdV[0].Key<=MnProb){ 
663        CatWgtCIdKdV[0].Dat=MajorCId; CatWgtCIdKdV[0].Key=MajorCatWgt;
664      }
665      bool PredClassVal;
666      PredClassVal=(CatWgtCIdKdV[0].Dat==TargetCId);
667      if (PredClassVal==ClassVal){
668        if (PredClassVal){TruePos++;} else {TrueNeg++;}
669      } else {
670        fprintf(ErrFile, "%s\n", BowDocBs->GetDocNm(DId).CStr());
671        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
672      }
673      int ClassValN=(ClassVal)?1:-1;
674      int PredClassValN=(PredClassVal)?1:-1;
675      fprintf(TestOutFile, "%0.6f # true=%d # docDesc=%s\n",
676       PredClassValN*CatWgtCIdKdV[0].Key, ClassValN, BowDocBs->GetDocNm(DId).CStr());
677    }
678    double Acc=100*(TruePos+TrueNeg)/double(TestDocs);
679    double Prec=100*(TruePos/double(TruePos+FalsePos));
680    double Rec=100*(TruePos/double(TruePos+FalseNeg));
681    printf("Precision %0.2f%%, Recall %0.2f%%, Accuracy %0.2f%%\n", Prec, Rec, Acc);
682    }
683  }
684  void TBowLearn::TrainWinnowMd(const PBowDocBs& BowDocBs,
685   const TStr& TargetCatNm, TFltV& ExpWgtV,
686   const TFileId& OutFile, const double& Beta){
687    double VoteTsh=0.5;
688    int TargetCId=BowDocBs->GetCId(TargetCatNm);
689    int TrainDocs=BowDocBs->GetTrainDocs();
690    ExpWgtV.PutAll(1);
<span onclick='openModal()' class='match'>691    const double MnWgt=1e-15;
692    double PrevAcc=0; double PrevPrec=0; double PrevRec=0; double PrevF1=0;
693    const double MxDiff=-0.005; const int MxWorseIters=3; int WorseIters=0;
</span>694    const int MxIters=50; int IterN=0;
695    while ((IterN<MxIters)&&(WorseIters<MxWorseIters)){
696      IterN++;
697      int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
698      for (int DIdN=0; DIdN<TrainDocs; DIdN++){
699        int DId=BowDocBs->GetTrainDId(DIdN);
700        bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
701        double PosWgt=0; double NegWgt=0;
702        double OldSum=0; double NewSum=0;
703        int DocWIds=BowDocBs->GetDocWIds(DId);
704        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
705          int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
706          int PosExpN=2*DocWId; int NegExpN=2*DocWId+1;
707          OldSum+=ExpWgtV[PosExpN]+ExpWgtV[NegExpN];
708          int PenN=(ClassVal)?NegExpN:PosExpN;
709          ExpWgtV[PenN]=ExpWgtV[PenN]*Beta;
710          NewSum+=ExpWgtV[PosExpN]+ExpWgtV[NegExpN];
711          PosWgt+=ExpWgtV[PosExpN]; NegWgt+=ExpWgtV[NegExpN];
712        }
713        if (NewSum>MnWgt){
714          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
715            int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
716            ExpWgtV[2*DocWId]=ExpWgtV[2*DocWId]*OldSum/NewSum;
717            ExpWgtV[2*DocWId+1]=ExpWgtV[2*DocWId+1]*OldSum/NewSum;
718          }
719        }
720        bool PredClassVal;
721        if (PosWgt+NegWgt==0){PredClassVal=TBool::GetRnd();}
722        else {PredClassVal=(PosWgt/(PosWgt+NegWgt))>VoteTsh;}
723        if (PredClassVal==ClassVal){
724          if (PredClassVal){TruePos++;} else {TrueNeg++;}
725        } else {
726          if (PredClassVal){FalsePos++;} else {FalseNeg++;}
727        }
728      }
729      double Acc=100*(TruePos+TrueNeg)/double(TrainDocs);
730      double Prec=(TruePos/double(TruePos+FalsePos));
731      double Rec=(TruePos/double(TruePos+FalseNeg));
732      double F1=(2*Prec*Rec/(Prec+Rec));
733      if (((Acc-PrevAcc)<MxDiff)||((F1-PrevF1)<MxDiff)||(((Prec-PrevPrec)<MxDiff)&&
734       ((Rec-PrevRec)<MxDiff))){WorseIters++;}
735      else {WorseIters=0;}
736      PrevAcc=Acc; PrevPrec=Prec; PrevRec=Rec; PrevF1=F1;
737    if(IterN==1){fprintf(OutFile, "# IterN, Precision, Recall, F1, Accuracy\n");}
738      printf("%d] Precision %0.2f, Recall %0.2f, F1 %0.2f, Accuracy %0.2f%%\n",
739        IterN, Prec, Rec, F1, Acc);
740      fprintf(OutFile,
741        "%d %0.2f, %0.2f, %0.2f, %0.2f%%\n", IterN, Prec, Rec, F1, Acc);
742    }
743  }
744  void TBowLearn::TestWinnowMd(const PBowDocBs& BowDocBs,
745   const TStr& TargetCatNm, const TFltV& ExpWgtV,
746   const TFileId& TrainOutFile, const TFileId& TestOutFile, const TFileId& ErrFile,
747   const double& &bsol;*Beta*/){
748    double VoteTsh=0.5;
749    int TargetCId=BowDocBs->GetCId(TargetCatNm);
750    int TrainDocs=BowDocBs->GetTrainDocs();
751    int TestDocs=BowDocBs->GetTestDocs();
752    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
753    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
754      int DId=BowDocBs->GetTrainDId(DIdN);
755      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
756      double PosWgt=0; double NegWgt=0;
757      int DocWIds=BowDocBs->GetDocWIds(DId);
758      if (DocWIds==0){
759        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
760      }
761      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
762        int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
763        int PosExpN=2*DocWId; int NegExpN=2*DocWId+1;
764        PosWgt+=ExpWgtV[PosExpN]; NegWgt+=ExpWgtV[NegExpN];
765      }
766      bool PredClassVal;
767      if (PosWgt+NegWgt==0){PredClassVal=TBool::GetRnd();}
768      else {PredClassVal=(PosWgt/(PosWgt+NegWgt))>VoteTsh;}
769      if (PredClassVal==ClassVal){
770        if (PredClassVal){TruePos++;} else {TrueNeg++;}
771      } else {
772        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
773      }
774      int ClassValN=(ClassVal)?1:-1;
775      fprintf(TrainOutFile, "%0.6f # true=%d # docDesc=%s\n",
776       (PosWgt/(PosWgt+NegWgt))-VoteTsh, ClassValN, BowDocBs->GetDocNm(DId).CStr());
777    }}
778    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
779    for (int DIdN=0; DIdN<TestDocs; DIdN++){
780      int DId=BowDocBs->GetTestDId(DIdN);
781      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
782      double PosWgt=0; double NegWgt=0;
783      int DocWIds=BowDocBs->GetDocWIds(DId);
784      if (DocWIds==0){
785        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
786      }
787      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
788        int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
789        int PosExpN=2*DocWId; int NegExpN=2*DocWId+1;
790        PosWgt+=ExpWgtV[PosExpN]; NegWgt+=ExpWgtV[NegExpN];
791      }
792      bool PredClassVal; double PredVal;
793      if (PosWgt+NegWgt==0){
794        PredClassVal=TBool::GetRnd(); PredVal=double(PredClassVal);}
795      else {
796        PredClassVal=(PosWgt/(PosWgt+NegWgt))>VoteTsh;
797        PredVal=double(PosWgt/(PosWgt+NegWgt))-VoteTsh;
798      }
799      if (PredClassVal==ClassVal){
800        if (PredClassVal){TruePos++;} else {TrueNeg++;}
801      } else {
802        fprintf(ErrFile, "%s\n", BowDocBs->GetDocNm(DId).CStr());
803        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
804      }
805      int ClassValN=(ClassVal)?1:-1;
806      fprintf(TestOutFile, "%0.6f # true=%d # docDesc=%s\n",
807       PredVal, ClassValN, BowDocBs->GetDocNm(DId).CStr());
808    }
809    double Acc=100*(TruePos+TrueNeg)/double(TestDocs);
810    double Prec=(TruePos/double(TruePos+FalsePos));
811    double Rec=(TruePos/double(TruePos+FalseNeg));
812    double F1=(2*Prec*Rec/(Prec+Rec));
813    printf("Precision %0.2f%%, Recall %0.2f%%, F1 %0.2f, Accuracy %0.2f%%\n", Prec, Rec, F1, Acc);
814    }
815  }
816  void TBowLearn::TrainPerceptronMd(const PBowDocBs& BowDocBs,
817   const TStr& TargetCatNm, TFltV& ExpWgtV,
818   const TFileId& OutFile, const double& Beta, const double& VoteTsh){
819    int TargetCId=BowDocBs->GetCId(TargetCatNm);
820    int TrainDocs=BowDocBs->GetTrainDocs();
821    ExpWgtV.PutAll(0);
822    double PrevAcc=0; double PrevPrec=0; double PrevRec=0; double PrevF1=0;
823    const double MxDiff=-0.005; const int MxWorseIters=3; int WorseIters=0;
824    const int MxIters=30; int IterN=0;
825    while ((IterN<MxIters)&&(WorseIters<MxWorseIters)){
826      IterN++;
827      int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
828      for (int DIdN=0; DIdN<TrainDocs; DIdN++){
829        int DId=BowDocBs->GetTrainDId(DIdN);
830        bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
831        double Wgt=0;
832        int DocWIds=BowDocBs->GetDocWIds(DId);
833        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
834          int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
835          Wgt+=ExpWgtV[DocWId];
836        }
837        bool PredClassVal;
838        if (Wgt==0){PredClassVal=TBool::GetRnd();}
839        else {PredClassVal=(Wgt>VoteTsh);}
840        if ((PredClassVal==ClassVal)&&(fabs(Wgt)>VoteTsh)){
841          if (PredClassVal){TruePos++;} else {TrueNeg++;}
842        } else { 
843          if (PredClassVal){FalsePos++;} else {FalseNeg++;}
844          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
845            int DocWId; double WordFq; BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, WordFq);
846            if (PredClassVal){ExpWgtV[DocWId]-=Beta*WordFq;} else {ExpWgtV[DocWId]+=Beta*WordFq;}
847          }
848        }
849      }
850      double Acc=100*(TruePos+TrueNeg)/double(TrainDocs);
851      double Prec=(TruePos/double(TruePos+FalsePos));
852      double Rec=(TruePos/double(TruePos+FalseNeg));
853      double F1=(2*Prec*Rec/(Prec+Rec));
854      if (((Acc-PrevAcc)<MxDiff)||((F1-PrevF1)<MxDiff)||(((Prec-PrevPrec)<MxDiff)&&
855       ((Rec-PrevRec)<MxDiff))){WorseIters++;}
856      else {WorseIters=0;}
857      PrevAcc=Acc; PrevPrec=Prec; PrevRec=Rec; PrevF1=F1;
858      if(IterN==1){fprintf(OutFile, "# IterN, Precision, Recall, F1, Accuracy\n");}
859      printf("%d] Precision %0.2f, Recall %0.2f, F1 %0.4f, Accuracy %0.2f%%\n",
860        IterN, Prec, Rec, F1, Acc);
861      fprintf(OutFile,
862        "%d %0.2f, %0.2f, %0.2f, %0.2f%%\n", IterN, Prec, Rec, F1, Acc);
863    }
864  }
865  void TBowLearn::TestPerceptronMd(const PBowDocBs& BowDocBs,
866   const TStr& TargetCatNm, const TFltV& ExpWgtV,
867   const TFileId& TrainOutFile, const TFileId& TestOutFile, const TFileId& ErrFile,
868   const double& &bsol;*Beta*/){
869    double VoteTsh=0.0;
870    const double MxWgt=1e+15;
871    int TargetCId=BowDocBs->GetCId(TargetCatNm);
872    int TrainDocs=BowDocBs->GetTrainDocs();
873    int TestDocs=BowDocBs->GetTestDocs();
874    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
875    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
876      int DId=BowDocBs->GetTrainDId(DIdN);
877      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
878      double Wgt=0;
879      int DocWIds=BowDocBs->GetDocWIds(DId);
880      if (DocWIds==0){
881        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
882      }
883      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
884        int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
885        Wgt+=ExpWgtV[DocWId];
886      }
887      bool PredClassVal;
888      if (Wgt==0){PredClassVal=TBool::GetRnd();}
889      else {PredClassVal=(Wgt>VoteTsh);}
890      if (PredClassVal==ClassVal){
891        if (PredClassVal){TruePos++;} else {TrueNeg++;}
892      } else {
893        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
894      }
895      int ClassValN=(ClassVal)?1:-1;
896      fprintf(TrainOutFile, "%0.6f # true=%d # docDesc=%s\n",
897       Wgt-VoteTsh, ClassValN, BowDocBs->GetDocNm(DId).CStr());
898    }}
899    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
900    for (int DIdN=0; DIdN<TestDocs; DIdN++){
901      int DId=BowDocBs->GetTestDId(DIdN);
902      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
903      double Wgt=0;
904      int DocWIds=BowDocBs->GetDocWIds(DId);
905      if (DocWIds==0){
906        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
907      }
908      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
909        int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
910        Wgt+=ExpWgtV[DocWId];
911      }
912      if(Wgt>MxWgt){Wgt=MxWgt;}
913      bool PredClassVal=(Wgt>VoteTsh);
914      if (PredClassVal==ClassVal){
915        if (PredClassVal){TruePos++;} else {TrueNeg++;}
916      } else {
917        fprintf(ErrFile, "%s\n", BowDocBs->GetDocNm(DId).CStr());
918        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
919      }
920      int ClassValN=(ClassVal)?1:-1;
921      fprintf(TestOutFile, "%0.6f # true=%d # docDesc=%s\n",
922       Wgt-VoteTsh, ClassValN, BowDocBs->GetDocNm(DId).CStr());
923    }
924    double Acc=100*(TruePos+TrueNeg)/double(TestDocs);
925    double Prec=(TruePos/double(TruePos+FalsePos));
926    double Rec=(TruePos/double(TruePos+FalseNeg));
927    double F1=(2*Prec*Rec/(Prec+Rec));
928    printf("Precision %0.2f, Recall %0.2f, F1: %0.2f, Accuracy %0.2f%%\n", Prec, Rec, F1, Acc);
929    }
930  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablerecog.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowlearn.cpp</div>
                <div class="column column_space"><pre><code>609    bool found_good_border = false;
610    int last_bottom = INT32_MAX;
611    int bottom =
612        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY - min_height_ / 2, true);
613    int top =
614        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY + min_height_ / 2, false);
615    adjusted.set_top(top);
616    int previous_below = 0;
617    const int kMaxChances = 10;
</pre></code></div>
                <div class="column column_space"><pre><code>691    const double MnWgt=1e-15;
692    double PrevAcc=0; double PrevPrec=0; double PrevRec=0; double PrevF1=0;
693    const double MxDiff=-0.005; const int MxWorseIters=3; int WorseIters=0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    