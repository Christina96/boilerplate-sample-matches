
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 22.269705603038936%, Tokens: 12</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "hysgen.h"
3  void THysgenUtil::DumpCmtyVV(const TStr OutFNm, TVec<TIntV>& CmtyVV, TIntStrH& NIDNmH) {
4    FILE* F = fopen(OutFNm.CStr(), "wt");
5    for (int c = 0; c < CmtyVV.Len(); c++) {
6      fprintf(F, "\n\n*** COMMUNITY #%d, Length=%d ***\n", c+1, CmtyVV[c].Len());
7      for (int u = 0; u < CmtyVV[c].Len(); u++) {
8        if (NIDNmH.IsKey(CmtyVV[c][u])){
9          fprintf(F, "%s\t", NIDNmH.GetDat(CmtyVV[c][u]).CStr());
10        }
11        else {
12          fprintf(F, "%d\t", (int) CmtyVV[c][u]);
13        }
14      }
15      fprintf(F, "\n");
16    }
17    fclose(F);
18  }
19  void THysgenUtil::DumpCmtyVH(const TStr OutFNm, TVec<TIntFltH>& CmtyVH, TIntStrH& NIDNmH, Criteria Crit) {
20    FILE* F = fopen(OutFNm.CStr(), "wt");
21    int UId;
22    for (int c = 0; c < CmtyVH.Len(); c++) {
23      fprintf(F, "\n\n*** COMMUNITY #%d, Length=%d ***\n", c+1, CmtyVH[c].Len());
24      TIntV SortedV;
25      if (Crit == Alphabetical) {
26        TIntStrH SortedCNames;
27        for (TIntFltH::TIter NI = CmtyVH[c].BegI(); NI < CmtyVH[c].EndI(); NI++) {
28          SortedCNames.AddDat(NI.GetKey(), NIDNmH.GetDat(NI.GetKey()));
29        }
30        SortedCNames.SortByDat();
31        for (TIntStrH::TIter NI = SortedCNames.BegI();
32             NI < SortedCNames.EndI(); NI++) {
33          SortedV.Add(NI.GetKey());
34        }
35      } else {
36        CmtyVH[c].SortByDat(false);
37        CmtyVH[c].GetKeyV(SortedV);
38      }
39      for (TIntV ::TIter NI = SortedV.BegI(); NI < SortedV.EndI(); NI++) {
40        UId = NI->Val;
41        if (NIDNmH.IsKey(UId)){
42          fprintf(F, "%s: ", NIDNmH.GetDat(UId).CStr());
43        }
44        else {
45          fprintf(F, "%d: ", UId);
46        }
47        fprintf(F, "%f,\t", (double) CmtyVH[c].GetDat(UId));
48      }
49      fprintf(F, "\n");
50    }
51    fclose(F);
52  }
53  PHGraph THysgenUtil::LoadEdgeList(const TStr& InFNm, TStrHash<TInt>& NodeNameH,
54                                    TSsFmt SsFmt) {
55    TSsParser Ss(InFNm, SsFmt);
56    PHGraph PG = THGraph::New();
57    THGraph& G = *PG;
58    TStrHash<TInt> StrSet(Mega(1), true);
59    int EIdCtr = 0;
60    int RedunEdgesCnt = 0; 
61    std::string Curr;
62    while (Ss.Next()) {
63      TIntSet NIdH;
64      NIdH.Gen(Ss.Len());
65      if (Ss.Len() == 0) { continue; }
66      Curr = Ss[0];
67      if (Curr.compare(0,1, "#") == 0) { continue; } 
68      for (int i = 0; i < Ss.Len(); i++){
69        int ENId = StrSet.AddKey(Ss[i]);
70        if (! G.IsNode(ENId)) { G.AddNode(ENId, Ss[i]); }
71        NIdH.AddKey(ENId);
72      }
73      if (G.AddEdge(NIdH,EIdCtr) >= 0) {
74        EIdCtr++;
75      } else {RedunEdgesCnt++; }
76    }
77    printf("\nNumber of redundant edges: %d:\n", RedunEdgesCnt);
78    NodeNameH = StrSet;
79    NodeNameH.Pack();
80    G.Defrag();
81    return PG;
82  }
83  template<class PHGraph>
84  double THysgenUtil::GetConductance(const PHGraph& Graph, const TIntSet& CmtyS,
85                                     const int N2Edges) {
86    TIntV NeiNV;
87    int Vol = 0,  Cut = 0;
88    double Phi = 0.0;
89    for (int i = 0; i < CmtyS.Len(); i++) {
90      if (! Graph->IsNode(CmtyS[i])) { continue; }
91      THGraph::TNodeI  NI = Graph->GetNI(CmtyS[i]);
92      NI.GetNbrNodes(NeiNV);
93      for (int nei = 0; nei < NeiNV.Len(); nei++) {
94        if (! CmtyS.IsKey(NeiNV[nei])) { Cut += 1; }
95      }
96      Vol += NI.Get2Edges();
97    }
98    int N2Edges2 = N2Edges * 2;
99    if (Vol != N2Edges2) {
100      if (N2Edges2 - Vol < Vol) { Phi = Cut / double (N2Edges2 - Vol); }
101      else if (Vol == 0) { Phi = 0.0; }
102      else { Phi = Cut / double(Vol); }
103    } else {
104      if (Vol == N2Edges2) { Phi = 1.0; }
105    }
106    return Phi;
107  }
108  template<class PHGraph>
109  void THysgenUtil::GetNbhCom(const PHGraph& Graph, const int NID, TIntSet& NBCmtyS) {
110    THGraph::TNodeI NI = Graph->GetNI(NID);
111    NBCmtyS.Gen(NI.GetNbrNodes() + 1);
112    NBCmtyS.AddKey(NID);
113    for (int e = 0; e < NI.GetNbrNodes(); e++) {
114      NBCmtyS.AddKey(NI.GetNbrNId(e));
115    }
116  }
117  template<class PHGraph>
118  void THysgenUtil::GetPhiNIdPrV(const PHGraph &G, TFltIntPrV &PhiNIdPrV, const int MinComSiz) {
119    PhiNIdPrV.Gen(G->GetNodes(), 0);
120    const int N2Edges = G->Get2Edges();
121    TExeTm RunTm;
122    for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
123      TIntSet NBCmty(NI.GetNbrNodes() + 1);
124      double Phi;
125      if (NI.GetNbrNodes() < MinComSiz) { 
126        Phi = 1.0;
127      } else {
128        THysgenUtil::GetNbhCom<PHGraph>(G, NI.GetId(), NBCmty);
129        Phi = THysgenUtil::GetConductance(G, NBCmty, N2Edges);
130      }
131      PhiNIdPrV.Add(TFltIntPr(Phi, NI.GetId()));
132    }
133    PhiNIdPrV.Sort(true);
134    fflush(stdout);
135  }
136  void THysgenUtil::GetBinLocs(const int& DecNum, TIntV& LocsV, const TIntV& NodMapV) {
137    int MaxShift = ceil(TMath::Log2((double) DecNum+1));
138    int NumCopy = DecNum;
139    for (int j = 0; j < MaxShift; j++) {
140      if ( NumCopy / 2.0 != floor(NumCopy / 2.0) ) {
141        LocsV.Add(NodMapV[j]);
142      }
143      NumCopy = int(NumCopy / 2.0);
144    }
145  }
146  void THysgen::SetGraph(const PHGraph& GraphPt) {
147    HONEIdsV.Gen(GraphPt->GetNodes());
148    HONNIdsV.Gen(GraphPt->GetNodes());
149    HOKIDSV.Gen(GraphPt->GetNodes());
150    TIntV NIDV;
151    GraphPt->GetNIdV(NIDV);
152    NIdToIdx.Gen(NIDV.Len());
153    NIdToIdx.AddKeyV(NIDV);
154    G = TSnap::GetSubGraph(GraphPt, NIDV);
155    for (int nid = 0; nid < G->GetNodes(); nid++) {
156      IAssert(G->IsNode(nid));
157    }
158    PrNoCom = 1.0 / (double) G->GetNodes();
159    if (1.0 / PrNoCom > sqrt(TFlt::Mx)) { PrNoCom = 0.99 / sqrt(TFlt::Mx); } 
160    NegWgt = 1.0;
161  }
162  void THysgen::LoadComInit(const TStr& InFNm, TSsFmt SsFmt) {
163    TSsParser Ss(InFNm, SsFmt);
164    TVec<TStrFltH> ComsVH;
165    TStrSet NodsInFile(G->GetNodes());
166    std::string Curr;
167    printf("Loading community initializations from file ...\n");
168    while (Ss.Next()) {
169      if (Ss.Len() == 0) { continue; }
170      Curr = Ss[0];
171      if (Curr.compare(0,1, "#") == 0 || Curr.compare(0,1, "*") == 0) { continue; } 
172      TStrFltH CurComH;
173      for (int i = 0; i < Ss.Len(); i++){
174        Curr = Ss[i];
175        TStr NName; double SN;
176        int SepLoc = Curr.find_first_of(":");
177        if (SepLoc == -1) {
178          NName = Curr.c_str();
179          SN = InitVal;
180        } else {
181          NName = Curr.substr(0, SepLoc).c_str();
182          SN = strtod(Curr.substr(SepLoc + 2, 8).c_str(), NULL);
183        }
184        CurComH.AddDat(NName, SN);
185        NodsInFile.AddKey(NName);
186      }
187      ComsVH.Add(CurComH);
188    }
189    for (int c = 0; c < ComsVH.Len(); c++) {
190      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
191        AddNCom(NI.GetId(), c, InitNullS);
192        if (ComsVH[c].IsKey(NI.GetName())) {
193          AddNCom(NI.GetId(), c, ComsVH[c].GetDat(NI.GetName()));
194        }
195      }
196    }
197    printf("\n");
198    for (int c = 0; c < GetNumComs(); c++) {
199      printf("comm %d:\t\t", c);
200      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
201        if (GetNCom(NI.GetId(),c) > InitNullS) {
202          printf("%s,%0.2f\t",NI.GetName().CStr(), GetNCom(NI.GetId(),c));
203        }
204      }
205      printf("\n");
206    }
207    printf("\n Likelihood of the initial community memberships from the file is: %f\n", Likelihood());
208  }
209  void THysgen::ComInit(const int InitComs, const int MinComSiz, const double PerturbDens) {
210    IAssertR(InitVal>0.0 || InitNullS>0.0, "Error: At least one of -ic or -in "
211             "parameters should be set > 0. Cannot start without any initalization.");
212    S.Gen(G->GetNodes()); 
213    time_t InitTime = time(NULL);
214    printf("\n** Initializing the communities and the parameters is started...\n");
215    NumCIdNV.Gen(InitComs);
216    NumComs = InitComs;
217    if (InitNullS > 0.0) {
218      UniformComInit(InitComs);
219      InitTime = time(NULL);
220      InitEdgeProb();
221    }
222    if (InitNullS != InitVal) {
223      InitTime = time(NULL);
224      NeighborComInit(MinComSiz, InitNullS==0.0);
225      if (InitNullS==0.0) {
226        InitTime = time(NULL);
227        InitEdgeProb();
228      }
229    }
230    if (InitNullS != InitVal) {
231      RandomComPerturb(PerturbDens);
232    } else { RandomComPerturb(); }
233    printf("\n** Initializations finsihed [%lu sec]\n", time(NULL) - InitTime);
234  }
235  void THysgen::UniformComInit(const int InitComs) {
236    for (int c=0; c < NumComs; c++) {
237      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
238        AddNCom(NI.GetId(), c, InitNullS, true);
239      }
240    }
241  }
242  void THysgen::RandomComPerturb(double Density) {
243    if (Density <= 0.0) { return; }
244    for (int c=0; c < NumComs; c++) {
245      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
246        if (GetNCom(NI.GetId(), c) == 0) { continue; } 
247        if (Rnd.GetUniDev() < Density) { AddNCom(NI.GetId(), c, InitVal*Rnd.GetUniDev()); }
248      }
249    }
250  }
251  void THysgen::NeighborComInit(const int MinComSiz, const bool& IsInit) {
252    TFltIntPrV PhiNIdPrV;
253    THysgenUtil::GetPhiNIdPrV<PHGraph>(G, PhiNIdPrV, MinComSiz);
254    NeighborComInit(PhiNIdPrV, IsInit);
255  }
256  void THysgen::NeighborComInit(TFltIntPrV& PhiNIdPrV, const bool& IsInit) {
257    PhiNIdPrV.Sort(true);
258    TIntV NIdV;
259    TIntV EIdV;
260    THGraph::TNodeI NI;
261    THGraph::TEdgeI EI;
262    TIntSet InvalidNIDS(S.Len());
263    TIntV NumCIdNDefV(NumComs, 0);
264    int CurCID = 0;
265    for (int ui = 0; ui < PhiNIdPrV.Len(); ui++) {
266      if (PhiNIdPrV[ui].Val1 == 0.0) { 
267        continue;
268      }
269      int UID = PhiNIdPrV[ui].Val2;
270      fflush(stdout);
271      if (InvalidNIDS.IsKey(UID)) { continue; }
272      AddNCom(UID, CurCID, InitVal, IsInit);
273      InvalidNIDS.AddKey(UID);
274      NI = G->GetNI(UID);
275      fflush(stdout);
276      NI.GetNbrNodes(NIdV);
277      AddNCom(NIdV, CurCID, InitVal, IsInit);
278      NumCIdNDefV[CurCID] = NIdV.Len()+1;
279      InvalidNIDS.AddKeyV(NIdV);
280      CurCID++;
281      if (CurCID >= NumComs) { break; }
282      fflush(stdout);
283    }
284    if (NumComs > CurCID) {
285      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
286    }
287    for (int c = 0; c < NumCIdNV.Len(); c++) {
288      if (NumCIdNDefV[c] == 0) {
289        printf("Empty communities remained after initialization. "
290               "Members are getting assigned randomly!!\n\n");
291        int ComSz = 10;
292        for (int u = 0; u < ComSz; u++) {
293          int UID = Rnd.GetUniDevInt(G->GetNodes());
294          AddNCom(UID, c, InitVal, IsInit);
295        }
296      }
297    }
298  }
299  void THysgen::InitEdgeProb(){
300    TInt NId;
301    TInt CIterKey;
302    ProbEdgCommHH.Gen(G->GetEdges());
303    ProbNotEdgH.Gen(G->GetEdges());
304    ProbEdgH.Gen(G->GetEdges());
305    ProbENoiseV.Gen(G->GetNodes(),1);
306    ProbENoiseV[0] = 1;
307    int DPMatSize = NumComs + (SNoise>0); 
308    AuxDPEdgVV.Gen(DPMatSize);
309    for (int i = 0; i < DPMatSize; i++) {
310      AuxDPEdgVV[i].Gen(DPMatSize);
311      for (int j = 0; j < DPMatSize; j++) {
312        AuxDPEdgVV[i][j] = 0.0;
313      }
314    }
315    for (THGraph::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
316      TIntV NumMmbrsInEdgV(NumComs);
317      TIntFltH ProdH(NumComs);
318      TIntV NeiNV;
319      EI.GetNodesV(NeiNV);
320      for (int n = 0; n < NeiNV.Len(); n++) {
321        NId = NeiNV[n];
322        for (TIntFltH::TIter SNI = S[NId].BegI(); SNI < S[NId].EndI(); SNI++) {
323          CIterKey = SNI.GetKey();
324          if (!ProdH.IsKey(CIterKey)) { ProdH.AddDat(CIterKey, 1.0); }
325          ProdH.AddDat(CIterKey, ProdH.GetDat(CIterKey)*SNI.GetDat());
326          NumMmbrsInEdgV[CIterKey] ++;
327        }
328      }
329      for (int CId = 0; CId < NumComs; CId++){
330        if (NumMmbrsInEdgV[CId] > 0 && NumMmbrsInEdgV[CId] < NeiNV.Len()) {
331          ProdH.DelKey(CId);
332        }
333      }
334      AddECom(EI.GetId(), ProdH);
335    }
336    if (InitNullS > 0.0) { InitPrAllEdgesS(InitNullS, true);
337    } else { InitPrAllEdgesS(InitVal, false); }
338  }
339  void THysgen::UpdateUEdgesProb(const int& UId, const int& CId, const double& SUNew){
340    double SUOld = GetNCom(UId,CId);
341    TIntV EIdV;
342    TIntFltH ProbEH;
343    double PrECOld;
344    double PrECNew;
345    int EId;
346    G->GetNI(UId).GetEIDs(EIdV);
347    for (int e = 0; e < EIdV.Len(); e++) {
348      EId = EIdV[e];
349      if (SUOld < DBL_EPSILON) {
350        TIntV ENodesV;
351        G->GetEI(EId).GetNbrNodes(ENodesV);
352        PrECNew = SUNew;
353        for (int n = 0; n < ENodesV.Len(); n++) {
354          if (ENodesV[n] == UId) { continue; }
355          PrECNew *= GetNCom(ENodesV[n], CId);
356        }
357      } else {
358        PrECOld = GetECom(EId, CId);
359        PrECNew = PrECOld*SUNew/SUOld;
360      }
361      if (PrECNew > 0.0) {
362        AddECom(EId, CId, PrECNew);
363      } else {
364        DelECom(EId, CId);
365      }
366    }
367  }
368  void THysgen::InitPrAllEdgesS(const double& DefVal, const bool& IsEqualComms){
369    if (SumPrPsblEdgesPow_nVV.Len()==0) {
370      SumPrPsblEdgesPow_nVV.Gen(NumCIdNV.Len(), 0.0);
371    } else {
372      SumPrPsblEdgesPow_nVV.Clr();
373      SumPrPsblEdgesPow_nVV.Gen(NumCIdNV.Len(), 0.0);
374    }
375    TFlt SToN = 1.0;
376    for (int c=0; c<NumCIdNV.Len(); c++){
377      TFltV PsiV;
378      PsiV.Add(1.0);
379      SToN = 1.0;
380      for (int n=1; (n <= MinTayN && PsiV[n-1] > 0.0) || (n<=TayN && PsiV[n-1]>TayThresh) ; n++){ 
381        SToN *= DefVal;
382        PsiV.Add(pow(SToN+1.0, NumCIdNV[c]) - 1);
383      }
384      SumPrPsblEdgesPow_nVV.Add(PsiV);
385      if (IsEqualComms && NumCIdNV.Len()>1) {
386        for (int c=1; c<NumCIdNV.Len(); c++) {
387          TFltV PsiVCopy(SumPrPsblEdgesPow_nVV[0]);
388          SumPrPsblEdgesPow_nVV.Add(PsiVCopy);
389        }
390        printf("\n Done the same initialization for the rest of %d communities...\n",NumComs()-1);
391        break;
392      }
393    }
394  }
395  void THysgen::UpdatePrAllEdgesS(const int &UID, const int &CID, const double& SNNew){
396    TFltV PsiV(SumPrPsblEdgesPow_nVV[CID].Len());
397    UpdatePrAllEdgesS(PsiV, UID, CID, SNNew, true);
398  }
399  void THysgen::UpdatePrAllEdgesS(TFltV& PsiV, const int& UID, const int& CID, const double& SNNew, const bool IsApplyChange){
400    PsiV[0] = 1.0; 
401    double SNOld = GetNCom(UID,CID);
402    double SToNOld = 1.0, SToNNew = 1.0;
403    int nLast = 0;
404    for (int n=1; (n <= MinTayN && PsiV[n-1] > 0.0) ||
405                  (n <= TayN    && PsiV[n-1]>TayThresh); n++){
406      if (n >= PsiV.Len()) {
407        PsiV.Add(0.0);
408      }
409      SToNOld *= SNOld; SToNNew *= SNNew;
410      PsiV[n] = ((SToNNew+1.0)/(SToNOld+1.0)) *
411                                      (SumPrPsblEdgesPow_nVV[CID][n]-SToNOld) + SToNNew; 
412      nLast = n;
413    }
414    if (IsApplyChange) {
415      for (int n = 1; n <= nLast; n++) {
416        if (n >= SumPrPsblEdgesPow_nVV[CID].Len()) {
417          SumPrPsblEdgesPow_nVV[CID].Add(-1.0);
418        }
419        SumPrPsblEdgesPow_nVV[CID][n] = PsiV[n];
420      }
421      nLast++;
422      while (nLast < SumPrPsblEdgesPow_nVV[CID].Len()) {
423        SumPrPsblEdgesPow_nVV[CID][nLast] = 0.0;
424        nLast++;
425      }
426    }
427  }
428  double THysgen::PredictAllCEdgesS(const int &UID, const int &CID,
429                                    const bool IsLikelihood, const bool Verbose){
430    double SCoef = 1.0;
431    double LikCoef = 1.0;
432    double S_uc = GetNCom(UID,CID);
433    double SPowN = 1.0;
434    if (!IsLikelihood){
435      if (S_uc <= 0.0) { return SumPrPsblEdgesPow_nVV[CID][1]; }
436      else { SCoef = 1.0/S_uc; }
437    }
438    if (S_uc<=0.0 && IsLikelihood) { return 0.0; }
439    double Val = 0.0;
440    double Val_n;
441    if (Verbose) {
442      printf("### PredictAllCEdgesS for node %d and comm %d :\n", UID, CID);
443    }
444    for (int n=1; n<SumPrPsblEdgesPow_nVV[CID].Len() &&
445                  SumPrPsblEdgesPow_nVV[CID][n]>TayThresh; n++){
446      if (IsLikelihood) { LikCoef = -n; }
447      SPowN *= S_uc;
448      Val_n = SCoef * (SPowN/(1+SPowN)) * (SumPrPsblEdgesPow_nVV[CID][n] - SPowN) / LikCoef;
449      Val += Val_n;
450      if(Verbose){
451        printf("\t --- (n=%d): %f\n", n , Val_n);
452      }
453    }
454    return Val;
455  }
456  double THysgen::PredictAllCEdgesS(const int &UID, const int &CID, const double& SNNew,
457                                    const bool IsLikelihood, const bool Verbose){
458    IAssertR(IsLikelihood,"This Overload of function is only designed for computing the likelihood, not gradient!\n");
459    double SCoef = 1.0;
460    double LikCoef;
461    double SPowN = 1.0;
462    if (SNNew <= 0.0) { return 0.0; } 
463    double Val = 0.0;
464    double Val_n;
465    if (Verbose) {
466      printf("### PredictAllCEdgesS for node %d and comm %d :\n", UID, CID);
467    }
468    TFltV PsiV(SumPrPsblEdgesPow_nVV[CID].Len());
469    UpdatePrAllEdgesS(PsiV, UID, CID, SNNew, false);
470    for (int n=1; n<PsiV.Len() && PsiV[n]>TayThresh; n++){ 
471      LikCoef = -n;
472      SPowN *= SNNew;
473      Val_n = SCoef * (SPowN/(1.0+SPowN)) * (PsiV[n] - SPowN) / LikCoef;
474      Val += Val_n;
475      if(Verbose){
476        printf("\t --- (n=%d): %f\n", n , Val_n);
477      }
478    }
479    return Val;
480  }
481  double THysgen::PredictAllCEdgesS_direct(const int &UID, const int &CID,
482                                           const bool IsLikelihood, const bool Verbose) {
483    double Psi_c = 0.0;
484    double S_uc = GetNCom(UID,CID);
485    if (S_uc <= 0.0 && IsLikelihood) { return 0.0; }
486    TIntV CNodesV(S.Len(),0);
487    for (int nod=0; nod < S.Len(); nod++) {
488      if (GetNCom(nod, CID) > 0.0 || nod==UID) {CNodesV.Add(nod);}
489    }
490    TInt NPsbEdges = pow(2, CNodesV.Len());
491    for (int e=0; e<NPsbEdges; e++) {
492      TIntV ENodesV;
493      THysgenUtil::GetBinLocs(e, ENodesV, CNodesV);
494      if (!ENodesV.IsIn(UID) || ENodesV.Len() < 2) { continue; }
495      double ECProb = 1.0;
496      for (int i = 0; i < ENodesV.Len(); i++) {
497        if (Verbose) {
498          printf("%d, ", ENodesV[i]()); }
499        if (ENodesV[i] != UID) { ECProb *= GetNCom(ENodesV[i], CID); }
500      }
501      if (Verbose) {
502        printf(" --\t ECProb=%f, ", ECProb);
503      }
<span onclick='openModal()' class='match'>504      if (ECProb == 1.0 && S_uc == 1.0) { continue; }
505      if (!IsLikelihood) {
506        Psi_c += (ECProb / (1.0 - ECProb*S_uc));
507      } else {
508        Psi_c += log(1.0 - ECProb*S_uc);
509      }
</span>510      if (Verbose) {
511        printf(" *Islikelihood=%d*, Psi_c=%f\n", IsLikelihood, Psi_c); }
512    }
513    return Psi_c;
514  }
515  void THysgen::UpdateProbNotEdgH(const int &EId, const double &PrECNew,
516                                const double &PrECOld) {
517    double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
518    if (PrECNew>=0.0 && ProbNotEdgH.IsKey(EId) && ProbNotEdgH.GetDat(EId)()==-1.0)  {
519      TIntFltH& ProdH = ProbEdgCommHH.GetDat(EId); 
520      ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
521      if (1.0 - ProbEdgH.GetDat(EId) < 1.0) { 
522        ProbNotEdgH.AddDat(EId, 1.0 - ProbEdgH.GetDat(EId));
523      }
524      return;
525    }
526    double PrNotE;
527    if (PrECOld < 1.0){
528      PrNotE = ProbNotEdgH.GetDat(EId) * (1.0 - PrECNew) / (1.0 - PrECOld);
529    } else {
530      PrNotE = 1.0 - PrENoise;
531      for (TIntFltH::TIter HI = ProbEdgCommHH.GetDat(EId).BegI();
532           HI < ProbEdgCommHH.GetDat(EId).EndI(); HI++) {
533        PrNotE *= 1.0 - HI.GetDat();
534      }
535    }
536    ProbNotEdgH.AddDat(EId, PrNotE);
537    ProbEdgH.AddDat(EId, 1-PrNotE);
538    if (PrNotE >= 1.0) {
539      TIntFltH& ProdH = ProbEdgCommHH.GetDat(EId);
540      ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
541      ProbNotEdgH.AddDat(EId,-1.0);
542    }
543  }
544  double THysgen::DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
545    double DP = 0.0;
546    for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
547      if (UV.IsKey(HI.GetKey())) {
548        DP += UV.GetDat(HI.GetKey()) * HI.GetDat();
549      }
550    }
551    return DP;
552  }
553  void THysgen::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
554    S.Gen(G->GetNodes());
555    NumCIdNV.Gen(CmtyVV.Len());
556    NumComs = CmtyVV.Len();
557    for (int c = 0; c < CmtyVV.Len(); c++) {
558      for (int u = 0; u < CmtyVV[c].Len(); u++) {
559        int UID = CmtyVV[c][u];
560        if (! NIdToIdx.IsKey(UID)) { continue; }
561        AddNCom(NIdToIdx.GetKeyId(UID), c, 1.0);
562      }
563    }
564  }
565  double THysgen::Likelihood() {
566    TExeTm ExeTm;
567    double L = 0.0;
568    for (int u = 0; u < S.Len(); u++) {
569      double LU = LikelihoodForRow(u);
570      L += LU;
571    }
572    return L ;
573  }
574  double THysgen::LikelihoodForRow(const int UID) {
575    return LikelihoodForRow(UID, S[UID]);
576  }
577  double THysgen::LikelihoodForRow(const int UID, const TIntFltH &SU) {
578    bool IsSUpdated = false;
579    if (S[UID].Len() != SU.Len()) {
580      IsSUpdated = true;
581    } else {
582      for (int CID = 0; CID < NumComs; CID++){
583        if (!S[UID].IsKey(CID) && !SU.IsKey(CID)) {continue;}
584        if ( (S[UID].IsKey(CID) && !SU.IsKey(CID)) ||
585            (!S[UID].IsKey(CID) && SU.IsKey(CID)) ||
586            abs(S[UID].GetDat(CID) - SU.GetDat(CID)) > DBL_MIN ) {
587          IsSUpdated = true;
588          break;
589        }
590      }
591    }
592    double L = 0.0;
593    const bool IsLikelihood = true;
594    THGraph::TNodeI NI = G->GetNI(UID);
595    TIntV EIdV; 
596    NI.GetEIDs(EIdV);
597    TFlt SumLgPrNotUEdges = 0.0; 
598    for (int e = 0; e < NI.GetDeg(); e++) {
599      int EId = EIdV[e];
600      TIntFltH PrENewCH;
601      if (HONNIdsV[UID].IsKey(EId)) { continue; }
602        L += log(GetPrE(EId, UID, SU, PrENewCH));
603        for (TIntFltH::TIter PrECI = PrENewCH.BegI(); PrECI < PrENewCH.EndI(); PrECI++){
604          SumLgPrNotUEdges += log(1.0 - PrECI.GetDat());
605        }
606    }
607    TFlt SumAllPsbl = 0.0;
608    for (TIntFltH::TIter UCI = SU.BegI(); UCI < SU.EndI(); UCI++) {
609      if (IsSUpdated) {
610        SumAllPsbl += PredictAllCEdgesS(UID, UCI.GetKey(), UCI.GetDat(), IsLikelihood);
611      } else {
612        SumAllPsbl += PredictAllCEdgesS(UID, UCI.GetKey(), IsLikelihood);
613      }
614    }
615    L += NegWgt * (SumAllPsbl - SumLgPrNotUEdges);
616    if (RegCoef > 0.0) {
617      L -= RegCoef * Sum(SU);
618    }
619    return L;
620  }
621  void THysgen::GradientForRow(const int UId, TIntFltH &GradNod) {
622    GradNod.Gen(GetNumComs());
623    THGraph::TNodeI NI = G->GetNI(UId);
624    int NDeg = NI.GetDeg();
625    TIntV EIdV; 
626    NI.GetEIDs(EIdV);
627    TIntFltH PredEH(NDeg);
628    TFltV PredECMinusUV(GetNumComs());
629    TFltV GradV(GetNumComs());
630    TIntV CIDV(GetNumComs());
631    TIntV NIdV;
632    TInt NId;
633    TInt EId;
634    for (int e = 0; e < NDeg; e++) {
635      EId = EIdV[e];
636      if (HONEIdsV[UId].IsKey(EId)) { continue; }
637      PredEH.AddDat(EId, GetPrE(EId)); 
638    }
639    for (int CId = 0; CId < NumComs; CId++) { 
640      double Val = 0.0;
641      for (int e = 0; e < NDeg; e++) {
642        EId = EIdV[e];
643        if (HONEIdsV[UId].IsKey(EId)) { continue; }
644        if (GetNCom(UId, CId) > 0.0) {
645          PredECMinusUV[CId] =
646            GetECom(EId, CId) / GetNCom(UId, CId); 
647        } else {
648          PredECMinusUV[CId] = 1.0;
649          G->GetEI(EId).GetNodesV(NIdV);
650          for (int m = 0; m < NIdV.Len(); m++) {
651            NId = NIdV[m];
652            if (NId != UId) { PredECMinusUV[CId] *= GetNCom(NId, CId); }
653          }
654        }
655        double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
656        if (GetECom(EId, CId) >= 1.0 || (1.0 - GetECom(EId, CId) <= 0.0)) {
657          double PredENotCId = 1.0 - PrENoise;
658          for (int c2 = 0; c2 < NumComs; c2++) {
659            if (c2 == CId) { continue; }
660            PredENotCId *= 1.0 - GetECom(EId, c2);
661          }
662          Val += PredECMinusUV[CId] * PredENotCId / PredEH.GetDat(EId); 
663        }
664        else {
665          double PrNotENotC = (1.0 - PredEH.GetDat(EId)) / (1.0 - GetECom(EId, CId));
666          Val +=
667            PredECMinusUV[CId] * PrNotENotC / PredEH.GetDat(EId);
668        }
669        Val += NegWgt * (PredECMinusUV[CId] /
670          (1.0 - GetECom(EId, CId)));
671      }
672      Val -= NegWgt * PredictAllCEdgesS(UId, CId, false);
673      CIDV[CId] = CId;
674      GradV[CId] = Val;
675    }
676    for (int c = 0; c < GradV.Len(); c++) {
677      GradNod.AddDat(CIDV[c], GradV[CIDV[c]]);
678    }
679  }
680  void THysgen::GetCmtyVV(TVec<TIntFltH>& CmtyVH, TVec<TIntV>& CmtyVV, TVec<TFltV>& WckVV,
681                          const double Thres, const int MinSz) {
682    CmtyVH.Gen(NumComs, 0.0);
683    CmtyVV.Gen(NumComs, 0.0);
684    for (int CId = 0; CId < NumComs; CId++) {
685      TIntFltH NIDSucH(S.Len());
686      TIntV CmtyV;
687      for (int u = 0; u < S.Len(); u++) {
688        int NID = NIdToIdx[u];
689        if (GetNCom(u, CId) > Thres) {
690          NIDSucH.AddDat(NID, GetNCom(u, CId));
691        }
692      }
693      NIDSucH.SortByDat(false);
694      NIDSucH.GetKeyV(CmtyV);
695      if (CmtyV.Len() < MinSz) { continue; }
696      CmtyVH.Add(NIDSucH);
697      CmtyVV.Add(CmtyV);
698    }
699    if ( NumComs != CmtyVV.Len()) {
700      printf("Unsorted Community vector generated. %d communities are ommitted\n",
701             NumComs.Val - CmtyVV.Len());
702    }
703  }
704  void THysgen::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV) {
705    GetCmtyVVUnSorted(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
706  }
707  void THysgen::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
708    CmtyVV.Gen(NumComs, 0.0);
709    for (int c = 0; c < NumComs; c++) {
710      TIntV CmtyV;
711      for (int u = 0; u < G->GetNodes(); u++) {
712        if (GetNCom(u, c) > Thres) { CmtyV.Add(NIdToIdx[u]); }
713      }
714      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
715    }
716    if ( NumComs != CmtyVV.Len()) {
717      printf("*Sorted* Community vector generated. %d communities are ommitted\n",
718             NumComs.Val - CmtyVV.Len());
719    }
720  }
721  double THysgen::GetStepSizeByLineSearch(const int UID, const TIntFltH &DeltaH,
722                                          const double &stepSize,
723                                          const double &CtrlParam,
724                                          const double &ReductionRatio,
725                                          const int MaxIter) {
726    double StepSize = stepSize;
727    double NewVal;
728    bool ShouldReduce = true;
729    while (ShouldReduce) {
730      ShouldReduce = false;
731      for (TIntFltH::TIter CI = DeltaH.BegI(); CI < DeltaH.EndI(); CI++) {
732        int CID = CI.GetKey();
733        NewVal = GetNCom(UID, CID) + StepSize * CI.GetDat();
734        if ((NewVal < MinVal || NewVal > MaxVal)) {
735          StepSize *= ReductionRatio;
736          ShouldReduce = true;
737          break;
738        }
739      }
740    }
741    double InitLikelihood = LikelihoodForRow(UID);
742    double FinalLikelihood = 0.0;
743    TIntFltH SearchVecH;
744    for(int iter = 0; iter < MaxIter; iter++) {
745      TIntFltH NewVarH;
746      GetUpdatedNodP(NewVarH, SearchVecH, UID, DeltaH, StepSize);
747      FinalLikelihood = LikelihoodForRow(UID, NewVarH);
748      double DotProd = DotProduct(SearchVecH, SearchVecH);
749      if (FinalLikelihood < InitLikelihood + CtrlParam * StepSize * DotProd ||
750                                                      isinf(FinalLikelihood)) {
751        StepSize *= ReductionRatio;
752      } else {
753        break;
754      }
755      if (iter == MaxIter - 1 || DotProd < 0.00001) {
756        StepSize = 0.0;
757        break;
758      }
759    }
760    return StepSize;
761  }
762  int THysgen::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm,
763                             const double StepSize, const double StepCtrlParam, const double StepReductionRatio) {
764    int NegLikPermits = MaxIter/3;
765    int MaxIterLineSearch = 100;
766    time_t InitTime = time(NULL);
767    time_t InitIterTime;
768    TExeTm ExeTm, CheckTm;
769    int iter = 0; 
770    TIntFltPrV IterLV; 
771    THGraph::TNodeI UI; 
772    double PrevL = Likelihood(), CurL = 0.0, DiffL;
773    printf("\n0 iterations (iter/#nodes = 0) {[INITIAL] Likelihood: %.4e}\n",PrevL);
774    TIntV NIdxV(S.Len(), 0);  
775    for (int i = 0; i < S.Len(); i++) { NIdxV.Add(i); }
776    TIntFltH GradUH;
777    TFltV Last5;
778    double SumLast5 = 0;
779    while(iter < MaxIter) {
780      InitIterTime = time(NULL);
781      NIdxV.Shuffle(Rnd);
782      for (int ui = 0; ui < S.Len(); ui++, iter++) {
783        int u = NIdxV[ui];
784        GradientForRow(u, GradUH);
785        if (Norm2(GradUH) < 1e-4) { continue; }
786        TIntFltH GradAdjustedH;
787        TIntFltH SearchVecH;
788        NormalizeIfLarge(GradUH, GradAdjustedH);
789        bool IsAnyValidChange = RmvWeakDirections(u, GradAdjustedH);
790        if (! IsAnyValidChange) { continue; }
791        double LearnRate = GetStepSizeByLineSearch(u, GradAdjustedH, StepSize,
792                                                   StepCtrlParam,
793                                                   StepReductionRatio,
794                                                   MaxIterLineSearch);
795        if (LearnRate <= DBL_MIN) { continue; }
796        TIntFltH SNew;
797        GetUpdatedNodP(SNew, u, GradAdjustedH, LearnRate);
798        double NewSuc;
799        for (int CID = 0; CID < NumComs; CID++) {
800          if (! SNew.IsKey(CID)) {
801            NewSuc = 0.0;
802          } else {
803            NewSuc = SNew.GetDat(CID);
804          }
805          if (NewSuc < DBL_EPSILON) {
806            DelNCom(u, CID);
807          } else {
808            AddNCom(u, CID, NewSuc);
809          }
810        }
811        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
812          IterLV.Add(TIntFltPr(iter, Likelihood()));
813        }
814      }
815      CurL = Likelihood();
816      DiffL = CurL - PrevL;
817      PrevL = CurL;
818      double AdjDiffL = (abs(DiffL) < 1000.0) ? abs(DiffL) : 1000.0;
819      Last5.Add(AdjDiffL);
820      SumLast5 += AdjDiffL;
821      if (Last5.Len() > 5) {
822        SumLast5 -= Last5[0];
823        Last5.Del(0);
824      }
825      if (fabs(CurL) < 1e9) {
826        if (fabs(DiffL) < 1e9) {
827          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4f, Diff: %.4f} [%lu/%lu sec]\n",
828                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
829        } else {
830          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4f, Diff: %.4e} [%lu/%lu sec]\n",
831                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
832        }
833      } else {
834        if (fabs(DiffL) < 1e9) {
835          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4e, Diff: %.4f} [%lu/%lu sec]\n",
836                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
837        } else {
838          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4e, Diff: %.4e} [%lu/%lu sec]\n",
839                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
840        }
841      }
842      printf("\n");
843      fflush(stdout);
844      if (DiffL < 0.0) { 
845        if (NegLikPermits <= 0) { break; }
846        NegLikPermits --;
847      }
848      if (SumLast5/Last5.Len() <= Thres) {
849        printf("The average of last five differences < threshold. Iterations end...\n");
850        break;
851      }
852    }
853    printf("\n");
854    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
855    if (! PlotNm.Empty()) {
856      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
857    }
858    return iter;
859  }
860  double THysgen::GetPrE(const int &EId, const int &UId, const TIntFltH &SUNewH,
861                         TIntFltH &PrEOutCH) {
862    double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
863    double SUOld;
864    double SUNew;
865    double PrECOld;
866    double PrENew = 1.0 - PrENoise;
867    int SCId;
868    for (TIntFltH::TIter SCI = SUNewH.BegI(); SCI < SUNewH.EndI(); SCI++) {
869      SCId = SCI.GetKey();
870      SUNew = SCI.GetDat();
871      SUOld = GetNCom(UId, SCId);
872      if (SUOld < DBL_EPSILON) {
873        TIntV ENodesV;
874        G->GetEI(EId).GetNbrNodes(ENodesV);
875        double PrEC = SUNew;
876        for (int n = 0; n < ENodesV.Len(); n++) {
877          if (ENodesV[n] == UId) { continue; }
878          PrEC *= GetNCom(ENodesV[n], SCId);
879        }
880        PrEOutCH.AddDat(SCId, PrEC);
881      } else {
882        PrECOld = GetECom(EId, SCId);
883        PrEOutCH.AddDat(SCId, PrECOld * SUNew / SUOld);
884      }
885      PrENew *= 1.0 - PrEOutCH.GetDat(SCId);
886    }
887    if (PrENew < 1.0) { PrENew = 1.0 - PrENew; }
888    else {
889      PrENew = GetPrEPrecision(PrEOutCH, AuxDPEdgVV, PrENoise);
890    }
891    return PrENew;
892  }
893  double THysgen::GetPrEPrecision(const TIntFltH &ECH, TVec<TFltV> &DPMatVV,
894                                  const double PrENoise) {
895    int NumEC = ECH.Len();
896    TFltV ECV(NumEC);
897    ECH.GetDatV(ECV);
898    if (PrENoise > 0.0) { ECV.Add(PrENoise); NumEC++; }
899    for (int i=1; i<NumEC; i++) {
900      DPMatVV[i][NumEC-1] = 0;
901    }
902    DPMatVV[0][NumEC-1] = ECV[NumEC-1];
903    for (int j= NumEC - 2; j >= 0; j--) {
904      DPMatVV[0][j] = DPMatVV[0][j + 1] + ECV[j];
905    }
906    for (int i=1; i<NumEC; i++) {
907      for (int j=NumEC-1-i; j>=0; j--) {
908        DPMatVV[i][j] = ECV[j] * DPMatVV[i-1][j+1] + DPMatVV[i][j+1];
909      }
910    }
911    double prob = 0.0;
912    double SignCoef = 1.0;
913    for (int i=0; i<NumEC; i++) {
914      prob += SignCoef * DPMatVV[i][0];
915      SignCoef *= -1.0;
916    }
917    if (prob < DBL_MIN || prob >1) {
918      prob = DBL_MIN;
919    }
920    return prob;
921  }
922  void THysgen::GetUpdatedNodP(TIntFltH &SNew, const int &UID, const TIntFltH& GradUH,
923                          double &StepSize) {
924    TIntFltH SearchVecOut;
925    GetUpdatedNodP(SNew, SearchVecOut, UID, GradUH, StepSize);
926  }
927  void THysgen::GetUpdatedNodP(TIntFltH &SNew, TIntFltH& SearchVecOut, const int& UID,
928                               const TIntFltH& GradUH, double& StepSize) {
929    for (int CID = 0; CID < NumComs; CID++) {
930      if (GradUH.IsKey(CID)) {
931        double Change = StepSize * GradUH.GetDat(CID);
932        if (RegCoef>0.0 && GetNCom(UID, CID)>0.0) {
933          Change -= - RegCoef;
934        }
935        double NewSuc = GetNCom(UID, CID) + Change;
936        if (NewSuc < DBL_EPSILON) {
937          NewSuc = MinVal;
938        } else if (NewSuc >= MaxVal - TayThresh) {
939          NewSuc = MaxVal - TayThresh;
940        }
941        Change = NewSuc - GetNCom(UID, CID);
942        if (NewSuc >= DBL_EPSILON) {
943          SNew.AddDat(CID, NewSuc);
944        }
945        SearchVecOut.AddDat(CID, Change);
946      } else {
947        if (GetNCom(UID, CID) > 0.0) {
948          double NewSuc;
949          if (GetNCom(UID, CID) >= MaxVal - TayThresh) {
950            NewSuc = MaxVal - TayThresh;
951          } else {
952            NewSuc = GetNCom(UID, CID);
953          }
954          SNew.AddDat(CID, NewSuc);
955        }
956      }
957    }
958  }
959  bool THysgen::AcceptStepSA(const int &UID, const TIntFltH &SNew, const int &Iter,
960                        const int &MaxIter, const double &SAParamK) {
961    double T0 = 100.0;
962    double T = T0/((double)Iter+1.0);
963    double OldLikelihood = LikelihoodForRow(UID);
964    double NewLikelihood = LikelihoodForRow(UID, SNew);
965    double DeltaE = - (NewLikelihood-OldLikelihood);
966    double PrAccept = exp(-DeltaE/(SAParamK*T));
967    if (Rnd.GetUniDev() < PrAccept) { return true; }
968    return false;
969  }
970  bool THysgen::RmvWeakDirections(const int &UId, TIntFltH &GradH) {
971    bool IsEligible = false;
972    THashSet<TInt> BadDirH;
973    for (TIntFltH::TIter CI = GradH.BegI(); CI < GradH.EndI(); CI++) {
974      if ((GetNCom(UId, CI.GetKey()) < DBL_EPSILON && CI.GetDat() < DBL_EPSILON) ||
975            (1.0 - GetNCom(UId, CI.GetKey()) < DBL_EPSILON && CI.GetDat() > DBL_EPSILON)) {
976        BadDirH.AddKey(CI.GetKey());
977      } else {
978        IsEligible = true;
979      }
980    }
981    if (BadDirH.Len() > 0) {
982      for (THashSet<TInt>::TIter CId = BadDirH.BegI();
983           CId < BadDirH.EndI(); CId++) {
984        GradH.DelKey(CId.GetKey());
985      }
986    }
987    return IsEligible;
988  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-signnet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "signnet.h"
3  PSignNet TSignNet::GetEdgeSubNet(const int& EDat1, const int& EDat2, const int& EDat3) const {
4    TIntSet EDatSet;
5    EDatSet.AddKey(EDat1);
6    if (EDat2!=TInt::Mn) { EDatSet.AddKey(EDat2); }
7    if (EDat3!=TInt::Mn) { EDatSet.AddKey(EDat3); }
8    PSignNet Net = TSignNet::New();
9    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
10      if (! EDatSet.IsKey(EI())) { continue; }
11      if (! Net->IsNode(EI.GetSrcNId())) {
12        Net->AddNode(EI.GetSrcNId(), EI.GetSrcNDat()); }
13      if (! Net->IsNode(EI.GetDstNId())) {
14        Net->AddNode(EI.GetDstNId(), EI.GetDstNDat()); }
15      Net->AddEdge(EI);
16    }
17    return Net;
18  }
19  void TSignNet::PermuteEdgeSigns() {
20    TIntV EDatV(GetEdges(), 0);
21    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
22      EDatV.Add(EI());
23    }
24    EDatV.Shuffle(TInt::Rnd);
25    int i = 0;
26    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
27      EI() = EDatV[i++];
28    }
29  }
30  void TSignNet::RewireNetwork() {
31    TIntH NIdDatH;
32    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
33      NIdDatH.AddDat(NI.GetId(), NI()); }
34    PNGraph PlusG = TSnap::ConvertGraph<PNGraph>(GetSignSubNet(+1));
35    PNGraph MinusG = TSnap::ConvertGraph<PNGraph>(GetSignSubNet(-1));
36    PlusG = TSnap::GenRewire(PlusG);
37    MinusG = TSnap::GenRewire(MinusG);
38    Clr(false);
39    for (TNGraph::TNodeI NI = PlusG->BegNI(); NI < PlusG->EndNI(); NI++) {
40      AddNode(NI.GetId()); }
41    for (TNGraph::TNodeI NI = MinusG->BegNI(); NI < MinusG->EndNI(); NI++) {
42      AddNode(NI.GetId(), NIdDatH.GetDat(NI.GetId())); }
43    for (TNGraph::TEdgeI EI = PlusG->BegEI(); EI < PlusG->EndEI(); EI++) {
44      AddEdge(EI.GetSrcNId(), EI.GetDstNId(), +1); }
45    for (TNGraph::TEdgeI EI = MinusG->BegEI(); EI < MinusG->EndEI(); EI++) {
46      AddEdge(EI.GetSrcNId(), EI.GetDstNId(), -1); }
47  }
48  void TSignNet::SimplifyNet() {
49    TIntPrV DelV;
50    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
51      if (EI.GetSrcNId() > EI.GetDstNId()) { continue; }
52      if (EI.GetSrcNId() == EI.GetDstNId()) {
53        DelV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
54      else if (EI.GetSrcNId() < EI.GetDstNId() && IsEdge(EI.GetDstNId(), EI.GetSrcNId())) {
55        if (TInt::Rnd.GetUniDev() < 0.5) {
56          DelV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
57        else {
58          DelV.Add(TIntPr(EI.GetDstNId(), EI.GetSrcNId())); }
59      }
60    }
61    printf("Deleting %d edges\n", DelV.Len());
62    for (int e = 0; e < DelV.Len(); e++) {
63      DelEdge(DelV[e].Val1, DelV[e].Val2);
64    }
65  }
66  void TSignNet::FlipMinusEdges(const int&  OldSign, const int& NewSign) {
67    TIntPrV MinusEV;
68    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
69      if (EI() == OldSign) {
70        MinusEV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
71    }
72    int NFlip = 0;
73    for (int e = 0; e < MinusEV.Len(); e++) {
74      DelEdge(MinusEV[e].Val1, MinusEV[e].Val2);
75      if (! IsEdge(MinusEV[e].Val2, MinusEV[e].Val1)) {
76        AddEdge(MinusEV[e].Val2, MinusEV[e].Val1, NewSign);
77        NFlip++;
78      }
79    }
80    printf("%d/%d (%.4f) edges flipped\n", NFlip, MinusEV.Len(), NFlip/double(MinusEV.Len()));
81  }
82  void TSignNet::CountStructBalance() const {
83    TIntSet NbrIdSet;
84    THash<TIntTr, TInt> TriadCntH;
85    TIntH SignH;
86    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
87      SignH.AddDat(EI()) += 1;
88    }
89    printf("Structural balance triads: %d nodes, %d edges\n  background sign distribution:\n", GetNodes(), GetEdges());
90    SignH.SortByKey(false);
91    for (int i = 0; i < SignH.Len(); i++) {
92      printf("\t%2d\t%d\n", SignH.GetKey(i)(), SignH[i]());
93    }
94    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
95      const TNodeI SrcNI = GetNI(EI.GetSrcNId());
96      const TNodeI DstNI = GetNI(EI.GetDstNId());
97      const TInt E1Dat = EI();
98      NbrIdSet.Clr(false);
99      for (int es = 0; es < SrcNI.GetDeg(); es++) {
100        NbrIdSet.AddKey(SrcNI.GetNbrNId(es));
101      }
102      for (int ed = 0; ed < DstNI.GetDeg(); ed++) {
103        const int nbr = DstNI.GetNbrNId(ed);
104        if (! NbrIdSet.IsKey(nbr)) { continue; }
105        const TInt E3Dat = DstNI.GetNbrEDat(ed);
106        for (int ed2 = 0; ed2 < SrcNI.GetDeg(); ed2++) {
107          if (nbr != SrcNI.GetNbrNId(ed2)) { continue; }
108          const TInt E2Dat = SrcNI.GetNbrEDat(ed2);
109          TriadCntH.AddDat(TIntTr(TMath::Mx(E1Dat, E2Dat, E3Dat),
110            TMath::Median(E1Dat, E2Dat, E3Dat), TMath::Mn(E1Dat, E2Dat, E3Dat))) += 1;
111        }
112      }
113    }
114    TriadCntH.SortByKey(false);
115    printf("triad counts (all counts are real, not times 3):\n");
116    int SumTriad = 0, SignTriad=0;
117    for (int i = 0; i < TriadCntH.Len(); i++) {
118      SumTriad += TriadCntH[i];
119      TIntTr SignTr = TriadCntH.GetKey(i);
120      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
121        SignTriad += TriadCntH[i]; }
122    }
123    for (int i = 0; i < TriadCntH.Len(); i++) {
124      TIntTr SignTr = TriadCntH.GetKey(i);
125      printf("\t%2d %2d %2d\t%8d\t%f", SignTr.Val1(), SignTr.Val2(), SignTr.Val3(),
126        TriadCntH[i]()/3, TriadCntH[i]()/double(SumTriad));
127      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
128        printf("\t%f", TriadCntH[i]()/double(SignTriad)); }
129      printf("\n");
130    }
131  }
132  void TSignNet::CountBalUnBal(const int& NId1, const int& NId2, int& BalTriads, int& UnBalTriads) const {
133    BalTriads=0; UnBalTriads=0;
134    int Sign=0;
135    if (IsEdge(NId1, NId2)) { Sign=GetEDat(NId1, NId2); }
136    else if (IsEdge(NId2, NId1)) { Sign=GetEDat(NId2, NId1); }
137    else { return; }
138    TNodeI NI1 = GetNI(NId1);
139    TNodeI NI2 = GetNI(NId2);
140    TIntH NbrH(NI1.GetDeg());
141    for (int i = 0; i < NI1.GetDeg(); i++) {
142      const int nid = NI1.GetNbrNId(i);
143      if (nid!=NId1 && nid!=NId2) {
144        NbrH.AddDat(nid, NI1.GetNbrEDat(i));
145      }
146    }
147    for (int i = 0; i < NI2.GetDeg(); i++) {
148      const int nid = NI2.GetNbrNId(i);
149      if (NbrH.IsKey(nid)) {
150        if (Sign*NbrH.GetDat(nid)*NI2.GetNbrEDat(i) == 1) { BalTriads++; }
151        else { UnBalTriads++; }
152      }
153    }
154  }
155  void TSignNet::SetNodePart(const int& PartId) {
156    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
157      NI() = PartId;
158    }
159  }
160  void TSignNet::SetNodePart(TVec<TIntV>& PartNIdV) {
161    SetNodePart(-1);
162    for (int p = 0; p < PartNIdV.Len(); p++) {
163      for (int n = 0; n < PartNIdV[p].Len(); n++) {
164        if (IsNode(PartNIdV[p][n])) {
165          GetNDat(PartNIdV[p][n]) = p+1; }
166      }
167    }
168  }
169  void TSignNet::GetPartStat(const TVec<TIntV>& PartNIdV, const TStr& Desc) const {
170    THash<TIntPr, TIntPr> PartEdgeH;
171    TIntH NIdPartH;
172    int PartSz=0;
173    for (int p = 0; p < PartNIdV.Len(); p++) {
174      for (int n = 0; n < PartNIdV[p].Len(); n++) {
175        NIdPartH.AddDat(PartNIdV[p][n], p);
176      }
177      PartSz += PartNIdV[p].Len();
178    }
179    TInt DstPart;
180    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
181      if (! NIdPartH.IsKey(NI.GetId())) { continue; }
182      const int SrcPart = NIdPartH.GetDat(NI.GetId());
183      for (int e = 0; e < NI.GetOutDeg(); e++) {
184        const int Sign = NI.GetOutEDat(e);
185        TIntPr& IOCnt = PartEdgeH.AddDat(TIntPr(SrcPart, Sign));
186        if (NIdPartH.IsKeyGetDat(NI.GetOutNId(e), DstPart) && SrcPart==DstPart) {
187          if (Sign>0) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
188        else {
189          if (Sign<0) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
190      }
191    }
192    PartEdgeH.SortByKey();
193    printf("%s: Satisfied edges (n:%d, e:%d, %d in partitions)\n", Desc.CStr(), GetNodes(), GetEdges(), PartSz);
194    int OkEdges=0, AllEdges=0;
195    for (int p = 0; p < PartEdgeH.Len(); p++) {
196      double frac = 0.0;
197      if (PartEdgeH[p].Val1+PartEdgeH[p].Val2>0) {
198        frac=PartEdgeH[p].Val1/double(PartEdgeH[p].Val1+PartEdgeH[p].Val2); }
199      OkEdges += PartEdgeH[p].Val1;
200      AllEdges += PartEdgeH[p].Val1 + PartEdgeH[p].Val2;
201      if (p==0 || PartEdgeH.GetKey(p).Val1!=PartEdgeH.GetKey(p-1).Val1) {
202        printf("  %2d  %2d : %6d : %6d  =  %f     size: %d\n", PartEdgeH.GetKey(p).Val1(), PartEdgeH.GetKey(p).Val2(),
203          PartEdgeH[p].Val1(), PartEdgeH[p].Val2(), frac,
204          PartNIdV[PartEdgeH.GetKey(p).Val1].Len());
205      } else {
206        printf("      %2d : %6d : %6d  =  %f\n", PartEdgeH.GetKey(p).Val2(),
207          PartEdgeH[p].Val1(), PartEdgeH[p].Val2(), frac);
208      }
209    }
210    printf("  all ok edges: %d / %d = %f\n\n", OkEdges, AllEdges, OkEdges/double(AllEdges));
211  }
212  void TSignNet::MakeStatusConsistent() {
213    printf("Make status consistent:\n");
214    PSignNet Net2 = TSignNet::New();
215    *Net2 = *this;
216    Net2->PrintInfo("NETWORK");
217    Net2->FlipMinusEdges(-1, 1);
218    TIntV NIdOrderV;
219    Fail;
220    TIntH NIdPosH;
221    for (int i = 0; i < NIdOrderV.Len(); i++) {
222      NIdPosH.AddDat(NIdOrderV[i], i); }
223    TIntPrV DelEdgeV;
224    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
225      if (NIdPosH.GetDat(EI.GetSrcNId()) > NIdPosH.GetDat(EI.GetDstNId())) {
226        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
227      }
228    }
229    printf("  Deleting %d/%d edges\n", DelEdgeV.Len(), GetEdges());
230    for (int e = 0; e < DelEdgeV.Len(); e++) {
231      DelEdge(DelEdgeV[e].Val1, DelEdgeV[e].Val2);
232    }
233    PrintInfo("STATUS CONSISTENT");
234  }
235  void TSignNet::EdgeSignStat() const {
236    int Plus=0, Minus=0;
237    int OneWayP=0, OneWayM=0;
238    int BWayPP=0, BWayPM=0, BWayMM=0;
239    TEdgeI EndE = EndEI();
240    for (TEdgeI EI = BegEI(); EI < EndE; EI++) {
241      const int Sign = EI();
242      TEdgeI EIX = GetEI(EI.GetDstNId(), EI.GetSrcNId());
243      if (Sign==1) { Plus++; } else { Minus++; }
244      if (EIX == EndE) {
245        if (Sign==1) { OneWayP++; } else { OneWayM++; }
246      } else {
247        if (Sign==EIX()) {
248          if (Sign==1) { BWayPP++; } else { BWayMM++; }
249        } else { BWayPM++; }
250      }
251    }
252    printf("Edges +1: %d\n", Plus);
253    printf("Edges -1: %d\n", Minus);
254    printf("One way +1:  %d\n", OneWayP);
255    printf("One way -1:  %d\n", OneWayM);
256    printf("Both way +1: %d\n", BWayPP);
257    printf("Both way -1: %d\n", BWayMM);
258    printf("Both way +1/-1: %d\n\n", BWayPM);
259  }
260  void TSignNet::PlotSignCmnNbrs(const TStr& OutFNm) const {
261    TFltFltH SupCmnH, SupCmnH2, OppCmnH, OppCmnH2;    
262    THash<TFlt, TMom> CmnFracH, CmnFracH2;  
263    PSignNet ThisPt = PSignNet((TSignNet*) this);
264    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
265      const int C = TSnap::GetCmnNbrs(ThisPt, EI.GetSrcNId(), EI.GetDstNId());
266      if (EI() == 1) { SupCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(1);
267      } else if (EI() == -1) { OppCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(0);  }
268    }
269    PSignNet PermNet = TSignNet::New();  *PermNet = *this;
270    PermNet->PermuteEdgeSigns();
271    for (TEdgeI EI = PermNet->BegEI(); EI < PermNet->EndEI(); EI++) {
272      const int C = TSnap::GetCmnNbrs(PermNet, EI.GetSrcNId(), EI.GetDstNId());
273      if (EI() == 1) { SupCmnH2.AddDat(C)++;  CmnFracH2.AddDat(C).Add(1);
274      } else if (EI() == -1) { OppCmnH2.AddDat(C)++;  CmnFracH2.AddDat(C).Add(0);  }
275    }
276    { TGnuPlot GP("cmnNbrs-"+OutFNm, "Number of common friends of votes");
277    GP.SetXYLabel("Number of common friends", "Number of votes"); GP.SetScale(gpsLog);
278    GP.AddPlot(SupCmnH, gpwLinesPoints, "Support vote");
279    GP.AddPlot(OppCmnH, gpwLinesPoints, "Oppose vote");
280    GP.AddPlot(SupCmnH2, gpwLinesPoints, "PERMUTED: Support vote");
281    GP.AddPlot(OppCmnH2, gpwLinesPoints, "PERMUTED: Oppose vote");
282    GP.SavePng(); }
283    TFltTrV V1, V2;
284    for (int i = 0; i < CmnFracH.Len(); i++) {
285      CmnFracH[i].Def();
286      const double StdErr = CmnFracH[i].GetSDev()/sqrt((double)CmnFracH[i].GetVals());
287      V1.Add(TFltTr(CmnFracH.GetKey(i), CmnFracH[i].GetMean(), StdErr));
288    }
289    for (int i = 0; i < CmnFracH2.Len(); i++) {
290      CmnFracH2[i].Def();
291      const double StdErr = CmnFracH2[i].GetSDev()/sqrt((double)CmnFracH2[i].GetVals());
292      V2.Add(TFltTr(CmnFracH2.GetKey(i), CmnFracH2[i].GetMean(), StdErr));
293    }
294    V1.Sort();  V2.Sort();
295    { TGnuPlot GP("cmnNbrsFrac-"+OutFNm, "Fraction of support votes");
296    GP.SetXYLabel("Number of common friends", "Fraction of support votes"); GP.SetScale(gpsLog);
297    GP.AddErrBar(V1, "True votes", "standard error");
298    GP.AddErrBar(V2, "PERMUTED edge signs", "standard error");
299    GP.SavePng(); }
300  }
301  PSignNet TSignNet::GetTriad(const int& N1, const int& N2, const int& N3) const {
302    PSignNet Net2 = TSignNet::New();
303    Net2->AddNode(0);  Net2->AddNode(1);  Net2->AddNode(2);
304    if (IsEdge(N1, N2)) { Net2->AddEdge(0, 1, GetEDat(N1, N2)); }
305    if (IsEdge(N2, N1)) { Net2->AddEdge(1, 0, GetEDat(N2, N1)); }
306    if (IsEdge(N1, N3)) { Net2->AddEdge(0, 2, GetEDat(N1, N3)); }
307    if (IsEdge(N3, N1)) { Net2->AddEdge(2, 0, GetEDat(N3, N1)); }
308    if (IsEdge(N2, N3)) { Net2->AddEdge(1, 2, GetEDat(N2, N3)); }
309    if (IsEdge(N3, N2)) { Net2->AddEdge(2, 1, GetEDat(N3, N2)); }
310    return Net2;
311  }
312  bool TSignNet::IsClosedTriad() const {
313    if (GetNodes() != 3) { return false; }
314    TNodeI NI = BegNI();
315    const int nid1 = NI.GetId(); NI++;
316    const int nid2 = NI.GetId(); NI++;
317    const int nid3 = NI.GetId();
318    if (IsEdge(nid1, nid2, false) && IsEdge(nid2, nid3, false) && IsEdge(nid1, nid3, false)) {
319      return true; }
320    return false;
321  }
322  bool TSignNet::IsBalanced() const {
323    if (GetEdges()!=3) { printf("%d\n", GetEdges()); }
324    IAssert(GetEdges()==3 && IsClosedTriad());
325    int Sig=1;
326    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
327      Sig *= EI();
328    }
329    if (Sig == 1) { return true; }
330    else { return false; }
331  }
332  double TSignNet::GetTriadProb(const double& PlusProb) const {
333    const int E = GetEdges();
334    int P = 0;
335    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
336      const int sign = EI();  IAssert(sign==1 || sign==-1);
337      if (sign==1) { P++; }
338    }
339    if (GetNodes()==3) { 
340      TNodeI NI = BegNI();
341      int Homo = 1;
342      if (P!=3 && P!=0 && NI.GetOutDeg()==1 && (NI++).GetOutDeg()==1 && (NI++).GetOutDeg()==1) {
343        NI = BegNI();
344        if (NI.GetId() == GetNI(GetNI(NI.GetOutNId(0)).GetOutNId(0)).GetOutNId(0)) {
345          Homo=3; 
346        }
347      }
348      return Homo * pow(PlusProb, P) * pow(1-PlusProb, E-P); 
349    }
350    return pow(PlusProb, P) * pow(1-PlusProb, E-P);
351  }
352  TIntPr TSignNet::GetNewEdge(const PSignNet& OldTriad) const {
353    IAssert(GetNodes()==3 && OldTriad->GetNodes()==3 && GetEdges()-OldTriad->GetEdges()==1);
354    PSignNet New = TSignNet::New(); *New=*this;
355    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
356      New->DelEdge(EI.GetSrcNId(), EI.GetDstNId());
357      if (TSignNet::IsSameTriad(OldTriad, New)!=-1) {
358        return TIntPr(EI.GetSrcNId(), EI.GetDstNId());
359      }
360      New->AddEdge(EI);
361    }
362    Fail;
363    return TIntPr(-1,-1);
364  }
365  int TSignNet::GetEdgeSig(const int& nid1, const int& nid2) const {
366    int e1, e2;
367    if (IsEdge(nid1, nid2)) { e1=GetEDat(nid1,nid2); } else { e1=0; }
368    if (IsEdge(nid2, nid1)) { e2=GetEDat(nid2,nid1); } else { e2=0; }
369    if (e1==0 && e2==0) { return 0; }
370    if (e1==1 && e2==0) { return 1; }
371    if (e1==-1 && e2==0) { return 2; }
372    if (e1==0 && e2==1) { return 3; }
373    if (e1==0 && e2==-1) { return 4; }
374    if (e1==1 && e2==1) { return 5; }
375    if (e1==1 && e2==-1) { return 6; }
376    if (e1==-1 && e2==1) { return 7; }
377    if (e1==-1 && e2==-1) { return 8; }
378    Fail; return -1;
379  }
380  TChA TSignNet::GetEdgeStr(const int& nid1, const int& nid2) const {
381    const int sig = GetEdgeSig(nid1, nid2);
382    return GetEdgeStr(sig);
383  }
384  TIntTr TSignNet::GetTriadSig(const bool& Canonical) const {
385    if (GetNodes()!=3) { return TIntTr(); }
386    TNodeI NI = BegNI();
387    const int nid1 = NI.GetId(); NI++;
388    const int nid2 = NI.GetId(); NI++;
389    const int nid3 = NI.GetId();
390    const int e1 = GetEdgeSig(nid1, nid2);
391    const int e2 = GetEdgeSig(nid2, nid3);
392    const int e3 = GetEdgeSig(nid3, nid1);
393    if (! Canonical) {
394      return TIntTr(e1, e2, e3); }
395    else { 
396      const TIntTr MinTr = TMath::Mn(TIntTr(e1, e2, e3), TIntTr(e2, e3, e1), TIntTr(e3, e1, e2));
397      const int e1a = GetEdgeSig(nid1, nid3);
398      const int e2a = GetEdgeSig(nid3, nid2);
399      const int e3a = GetEdgeSig(nid2, nid1);
400      return TMath::Mn(MinTr, TMath::Mn(TIntTr(e1a, e2a, e3a), TIntTr(e2a, e3a, e1a), TIntTr(e3a, e1a, e2a)));
401    }
402  }
403  TChA TSignNet::GetTriadStr(const bool& Canonical) const {
404    return GetTriadStr(GetTriadSig(Canonical));
405  }
406  TChA TSignNet::GetEdgeStr(const int& EdgeSig) {
407    switch(EdgeSig) {
408      case 1 : return "+o";
409      case 2 : return "-o";
410      case 3 : return "o+";
411      case 4 : return "o-";
412      case 5 : return "++";
413      case 6 : return "+-";
414      case 7 : return "-+";
415      case 8 : return "--";
416      default : return TChA();
417    }
418  }
419  TChA TSignNet::GetTriadStr(const TIntTr& TriadSig) {
420    return GetEdgeStr(TriadSig.Val1)+"\t"+GetEdgeStr(TriadSig.Val2)+"\t"+GetEdgeStr(TriadSig.Val3);
421  }
422  int TSignNet::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2) {
423    static THash<TInt, TVec<TIntV> > PermH;
424    if (PermH.Empty()) {
425      PermH.AddDat(2).Add(TIntV::GetV(0,1));
426      PermH.AddDat(2).Add(TIntV::GetV(1,0));
427      PermH.AddDat(3).Add(TIntV::GetV(0,1,2));
428      PermH.AddDat(3).Add(TIntV::GetV(0,2,1));
429      PermH.AddDat(3).Add(TIntV::GetV(1,0,2));
430      PermH.AddDat(3).Add(TIntV::GetV(1,2,0));
431      PermH.AddDat(3).Add(TIntV::GetV(2,0,1));
432      PermH.AddDat(3).Add(TIntV::GetV(2,1,0));
433    }
434    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) { return -1; }
435    IAssert(Net1->GetNodes()==2 || Net1->GetNodes()==3);
436    const TVec<TIntV>& PermV = PermH.GetDat(Net1->GetNodes());
437    for (int p = 0; p < PermV.Len(); p++) {
438      const TIntV& Perm = PermV[p];
439      TSignNet::TEdgeI EndEI2 = Net2->EndEI();
440      int i = 0;
441      bool Ok = true;
442      for (TSignNet::TNodeI NI1 = Net1->BegNI(); NI1 < Net1->EndNI(); NI1++, i++) {
443        TSignNet::TNodeI NI2 = Net2->GetNI(Perm[i]);
444        if (NI1.GetOutDeg() != NI2.GetOutDeg() || NI1.GetInDeg() != NI2.GetInDeg()) { Ok=false; break; }
445        for (int e = 0; e < NI1.GetOutDeg(); e++) {
446          const TSignNet::TEdgeI EI2 = Net2->GetEI(NI2.GetId(), Perm[NI1.GetOutNId(e)]);
447          if (EI2 == EndEI2 || NI1.GetOutEDat(e) != EI2()) { Ok=false; break; }
448        }
449      }
450      if (Ok) { return p; }
451    }
452    return -1;
453  }
454  void TSignNet::CountSignedTriads(const TStr& OutFNm) const {
455    printf("Count signed triads");
456    TVec<PSignNet> TriadIdV;
457    TVec<PSignNet> TriadIdV2;
458    TIntH TriadIdCntH;
459    TIntV NbrV;
460    PSignNet ThisPt = PSignNet((TSignNet*) this);
461    double AllPlusE=0, AllE = GetEdges();
462    int c=0, Decile=int(AllE/100);
463    TIntH UnSignCntH;
464    TIntH SignToUnsignH;
465    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
466      TSnap::GetCmnNbrs(ThisPt, EI.GetSrcNId(), EI.GetDstNId(), NbrV);
467      for (int n = 0; n < NbrV.Len(); n++) {
468        PSignNet TriadNet = GetTriad(EI.GetSrcNId(), EI.GetDstNId(), NbrV[n]);
469        int TriadId = -1;
470        for (int i = 0; i < TriadIdV.Len() && TriadId==-1; i++) {
471          if (IsSameTriad(TriadIdV[i], TriadNet)!=-1) { TriadId=i; break; } }
472        if (TriadId==-1) { TriadId=TriadIdV.Len();  TriadIdV.Add(TriadNet); }
473        TriadIdCntH.AddDat(TriadId) += 1;
474        TriadNet = GetTriad(EI.GetSrcNId(), EI.GetDstNId(), NbrV[n]);
475        TriadNet->SetAllEDat(1);
476        int TriadId2 = -1;
477        for (int i = 0; i < TriadIdV2.Len() && TriadId2==-1; i++) {
478          if (IsSameTriad(TriadIdV2[i], TriadNet)!=-1) { TriadId2=i; break; } }
479        if (TriadId2==-1) { TriadId2=TriadIdV2.Len();  TriadIdV2.Add(TriadNet); }
480        UnSignCntH.AddDat(TriadId2) += 1;
481        SignToUnsignH.AddDat(TriadId, TriadId2);
482      }
483      if (EI() == 1) { AllPlusE += 1; }
484      if (++c % Decile ==0) { printf("."); }
485    }
486    TVec<TTriple<TInt, TChA, TInt> > SortIdV;
487    for (int t = 0; t < TriadIdCntH.Len(); t++) {
488      PSignNet Net = TriadIdV[TriadIdCntH.GetKey(t)];
489      const int E = Net->GetEdges();
490      TriadIdCntH[t].Val /= E;
491      SortIdV.Add(TTriple<TInt, TChA, TInt>(Net->GetEdges(), Net->GetTriadStr(true), TriadIdCntH.GetKey(t)));
492    }
493    for (int u=0; u < UnSignCntH.Len(); u++) {
494      const int E = TriadIdV2[UnSignCntH.GetKey(u)]->GetEdges();
495      UnSignCntH[u].Val /= E;
496      printf("unsigned count:  %d\t%d\t%d\n", UnSignCntH.GetKey(u)(), E, UnSignCntH[u]());
497    }
498    SortIdV.Sort();
499    const double PlusProb = AllPlusE / AllE;
500    FILE *T = fopen(TStr::Fmt("SignTriad-%s.tab", OutFNm.CStr()).CStr(), "wt");
501    fprintf(T, "AB\tBC\tCA\tCount\tE[Count]\tSurprise\tTriadProb\n");
502    printf("%d triads\n", TriadIdCntH.Len());
503    printf("plus prob %d / %d = %f\n", int(AllPlusE), int(AllE), PlusProb);
504    for (int t = 0; t < SortIdV.Len(); t++) {
505      const int Id = SortIdV[t].Val3;
506      int PlusE = 0;
507      PSignNet TriadNet = TriadIdV[Id];
508      TStr FNm = TStr::Fmt("SignTriad-%s-%02d", OutFNm.CStr(), t+1);
509      FILE *F = fopen(TStr(FNm+".dot").CStr(), "wt");
510      fprintf(F, "digraph G {\n");
511      fprintf(F, "  graph [splines=true, overlap=false]\n  node  [shape=ellipse, width=0.3, height=0.3 label=\"\"]\n");
512      for (TEdgeI EI = TriadNet->BegEI(); EI < TriadNet->EndEI(); EI++) {
513        fprintf(F, "  n%d -> n%d [label=\"%s\" len=2];\n", EI.GetSrcNId(), EI.GetDstNId(),  EI()==1?"+":"--");
514        if (EI() == 1) { PlusE++; }
515      }
516      const double TriadCnt = TriadIdCntH.GetDat(Id);
517      const double TriadProb = TriadNet->GetTriadProb(PlusProb);
518      const double UnSignCnt = UnSignCntH.GetDat(SignToUnsignH.GetDat(Id)).Val;
519      const double ExpCnt = TriadProb * UnSignCnt; 
520      const double Surp = (TriadCnt-ExpCnt) / sqrt(UnSignCnt*TriadProb*(1.0-TriadProb));
521      fprintf(F, "  label = \"T=%d, E[T]=%d, S=%.1f\";\n}\n", int(TriadCnt), int(ExpCnt), Surp);
522      fclose(F);
523      TGraphViz::DoLayout(FNm+".dot", FNm+".gif",  gvlNeato);
524      fprintf(T, "%s\t%d\t%d\t%.2f\t%f\n", TriadNet->GetTriadStr(true).CStr(), int(TriadCnt), int(ExpCnt), Surp, TriadProb);
525    }
526    fclose(T);
527    printf("\n");
528  }
529  void TSignNet::PlotGraphProp(const TStr& OutFNm) const {
530    PSignNet Net = GetSignSubNet(+1);
531    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
532    TSnap::PlotOutDegDistr(Net, OutFNm+"-plus");
533    TSnap::PlotInDegDistr(Net, OutFNm+"-plus");
534    TSnap::PlotWccDistr(Net, OutFNm+"-plus");
535    TSnap::PlotClustCf(Net, OutFNm+"-plus");
536    const int NPlus = Net->GetEdges();
537    Net = TSnap::GetRndESubGraph(PSignNet((TSignNet*) this), NPlus);
538    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
539    TSnap::PlotOutDegDistr(Net, OutFNm+"-plusRnd");
540    TSnap::PlotInDegDistr(Net, OutFNm+"-plusRnd");
541    TSnap::PlotWccDistr(Net, OutFNm+"-plusRnd");
542    TSnap::PlotClustCf(Net, OutFNm+"-plusRnd");
543    Net = GetSignSubNet(-1);
544    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
545    TSnap::PlotOutDegDistr(Net, OutFNm+"-minus");
546    TSnap::PlotInDegDistr(Net, OutFNm+"-minus");
547    TSnap::PlotWccDistr(Net, OutFNm+"-minus");
548    TSnap::PlotClustCf(Net, OutFNm+"-minus");
549    const int NMinus = Net->GetEdges();
550    Net = TSnap::GetRndESubGraph(PSignNet((TSignNet*) this), NMinus);
551    while (Net->GetNodes() < GetNodes()) { Net->AddNode(); }
552    TSnap::PlotOutDegDistr(Net, OutFNm+"-minusRnd");
553    TSnap::PlotInDegDistr(Net, OutFNm+"-minusRnd");
554    TSnap::PlotWccDistr(Net, OutFNm+"-minusRnd");
555    TSnap::PlotClustCf(Net, OutFNm+"-minusRnd");
556  }
557  void TSignNet::PlotInOutPlusFrac(const TStr& OutFNm) const {
558    THash<TFltPr, TInt> CntH, Cnt2H;
559    THash<TFltPr, TInt> FracH, Frac2H;
560    const int FracRes = 100;
561    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
562      int PlusIn=1, PlusOut=1, MinusIn=1, MinusOut=1;
563      for (int i = 0; i < NI.GetOutDeg(); i++) {
564        if (NI.GetOutEDat(i)==1) { PlusOut++; } else { MinusOut++; } }
565      for (int i = 0; i < NI.GetInDeg(); i++) {
566        if (NI.GetInEDat(i)==1) { PlusIn++; } else { MinusIn++; } }
567      CntH.AddDat(TFltPr(PlusOut+TInt::Rnd.GetUniDev(), PlusIn+TInt::Rnd.GetUniDev())) += 1;
568      Cnt2H.AddDat(TFltPr(MinusOut+TInt::Rnd.GetUniDev(), MinusIn+TInt::Rnd.GetUniDev())) += 1;
569      FracH.AddDat(TFltPr(TInt::Rnd.GetUniDev()+int(FracRes*PlusOut/double(NI.GetOutDeg()+1)), TInt::Rnd.GetUniDev()+int(FracRes*PlusIn/double(NI.GetInDeg()+1)))) += 1;
570      Frac2H.AddDat(TFltPr(TInt::Rnd.GetUniDev()+int(FracRes*MinusOut/double(NI.GetOutDeg()+1)), TInt::Rnd.GetUniDev()+int(FracRes*MinusIn/double(NI.GetInDeg()+1)))) += 1;
571    }
572    TFltPrV V1;  TFltPrV V2;
573    CntH.GetKeyV(V1);
574    FracH.GetKeyV(V2);
575    TGnuPlot::PlotValV(V1, "plusCnt."+OutFNm, OutFNm, "number of pluses out", "number of pluses in", gpsLog10XY, false, gpwPoints);
576    TGnuPlot::PlotValV(V2, "plusFrac."+OutFNm, OutFNm, "fraction of pluses out", "fraction of pluses in", gpsAuto, false, gpwPoints);
577    Cnt2H.GetKeyV(V1);
578    Frac2H.GetKeyV(V2);
579    TGnuPlot::PlotValV(V1, "minusCnt."+OutFNm, OutFNm, "number of minuses out", "number of minuses in", gpsLog10XY, false, gpwPoints);
580    TGnuPlot::PlotValV(V2, "minusFrac."+OutFNm, OutFNm, "fraction of minuses out", "fraction of minuses in", gpsAuto, false, gpwPoints);
581  }
582  void TSignNet::SavePajek(const TStr& OutFNm) {
583    const TStrV ClrV = TStrV::GetV("Gray45", "Green", "Magenta", "Cyan", "OliveGreen", "NavyBlue", "Orange", "Purple", "Brown");
584    const int Clrs = ClrV.Len();
585    TIntH NodeClr;
586    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NodeClr.AddKey(NI()); }
587    FILE *F = fopen(OutFNm.CStr(), "wt");
588    TIntH NIdToIdH(GetNodes(), true);
589    fprintf(F, "*Vertices %d\n", GetNodes());
590    int i = 0;
591    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, i++) {
592      fprintf(F, "%d  \"%d\" ic %s fos 10\n", i+1, NI.GetId(), ClrV[NodeClr.GetKeyId(NI())%Clrs].CStr());
593      NIdToIdH.AddDat(NI.GetId(), i+1);
594    }
595    fprintf(F, "*Arcs %d\n", GetEdges()); 
596    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
597      const int NId = NIdToIdH.GetDat(NI.GetId());
598      for (int e = 0; e < NI.GetOutDeg(); e++) {
599        TStr EdgeColor = "Gray45";
600        if (NI()!=-1 && NI.GetOutNDat(e)!=-1) { 
601          if (NI.GetOutEDat(e)==-1) {
602            EdgeColor = NI()!=NI.GetOutNDat(e) ? "Blue":"Red"; }  
603          else if (NI.GetOutEDat(e)==1) {
604            EdgeColor = NI()==NI.GetOutNDat(e) ? "Blue":"Red"; }  
605        }
606        fprintf(F, "%d %d %g c %s\n", NId, NIdToIdH.GetDat(NI.GetOutNId(e)).Val, 1.0, EdgeColor.CStr());
607      }
608    }
609    fclose(F);
610  }
611  void TSignNet::SaveTxt(const TStr& OutFNm) const {
612    FILE *F = fopen(OutFNm.CStr(), "wt");
613    fprintf(F, "# Signed network. %d nodes, %d edges\n", GetNodes(), GetEdges());
614    fprintf(F, "# Source\tDestination\tEdgeSign\n");
615    THashSet<TInt> NIdSet;
616    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
617      NIdSet.AddKey(EI.GetSrcNId());  NIdSet.AddKey(EI.GetDstNId());
618      fprintf(F, "%d\t%d\t%d\n", NIdSet.GetKeyId(EI.GetSrcNId()), NIdSet.GetKeyId(EI.GetDstNId()), EI());
619    }
620    fclose(F);
621  }
622  void TSignNet::DrawGraphViz(const TStr& OutFNm, const TStr& Desc, const bool& NodeLabels, const bool& EdgeLabels, const bool& SaveDir) {
623    FILE *F = fopen(TStr(OutFNm+".dot").CStr(), "wt");
624    if (! SaveDir) { fprintf(F, "graph G {\n"); }
625    else { fprintf(F, "digraph G {\n"); }
626    fprintf(F, "  graph [splines=true, overlap=false]\n");
627    fprintf(F, "  node  [shape=ellipse, width=0.3, height=0.3 %s]\n", NodeLabels?"":", label=\"\"");
628    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
629      fprintf(F, "  %d %s;\n", NI.GetId(), NodeLabels?TStr::Fmt("[label=\"%d : %d\"]", NI.GetId(), NI()).CStr():"");
630    }
631    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
632      for (int e = 0; e < NI.GetOutDeg(); e++) {
633        if (! SaveDir) {
634          if (! IsEdge(NI.GetOutNId(e), NI.GetId())) {
635            fprintf(F, "  %d -- %d [dir=\"forward\"%s];\n", NI.GetId(), NI.GetOutNId(e),
636              EdgeLabels?TStr::Fmt(", label=\"%d\"", GetEDat(NI.GetId(), NI.GetOutNId(e))).CStr():"");  
637          } else if (NI.GetId() < NI.GetOutNId(e)) {
638            fprintf(F, "  %d -- %d %s;\n", NI.GetId(), NI.GetOutNId(e),
639              EdgeLabels?TStr::Fmt("[label=\"%d/%d\"]", GetEDat(NI.GetId(), NI.GetOutNId(e)), 
640              GetEDat(NI.GetOutNId(e), NI.GetId())).CStr():"");  
641          }
642        } else {
643          fprintf(F, "  %d -> %d %s;\n", NI.GetId(), NI.GetOutNId(e),
644            EdgeLabels?TStr::Fmt("[label=\"%d\"]", GetEDat(NI.GetId(), NI.GetOutNId(e))).CStr():"");
645        }
646      }
647    }
648    if (! Desc.Empty()) {
649      fprintf(F, "  label = \"\\n%s\\n\";\n", Desc.CStr());
650    }
651    fprintf(F, "  fontsize=24;\n");
652    fprintf(F, "}\n");
653    fclose(F);
654    TGraphViz::DoLayout(OutFNm+".dot", OutFNm+".gif",  gvlNeato);
655  }
656  void TSignNet::PrintInfo(const TStr& Desc) const {
657    if (! Desc.Empty()) { printf("%s\n", Desc.CStr()); }
658    else { printf("Signed network\n"); }
659    TIntH SignH;
660    int edges = 0;
661    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
662      SignH.AddDat(EI()) += 1;
663      edges++;
664    }
665    SignH.SortByKey();
666    printf("  nodes: %d\n", GetNodes());
667    printf("  edges: %d\n", edges);
668    for (int i = 0; i < SignH.Len(); i++) {
669      printf("  %2d: %d\n", SignH.GetKey(i), SignH[i]);
670    }
671    printf("\n");
672  }
673  void TSignNet::Dump() const {
674    printf("Net (%d, %d)\n", GetNodes(), GetEdges());
675    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
676      printf("  %d\t%d\t%d\n", EI.GetSrcNId(), EI.GetDstNId(), EI());
677    }
678    printf("\n");
679  }
680  bool TSignMicroEvol::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2, const TIntV& Perm) const {
681    int i = 0;
682    TSignNet::TEdgeI EndEI2 = Net2->EndEI();
683    for (TSignNet::TNodeI NI1 = Net1->BegNI(); NI1 < Net1->EndNI(); NI1++, i++) {
684      TSignNet::TNodeI NI2 = Net2->GetNI(Perm[i]);
685      if (NI1.GetOutDeg() != NI2.GetOutDeg() || NI1.GetInDeg() != NI2.GetInDeg()) {
686        return false;
687      }
688      for (int e = 0; e < NI1.GetOutDeg(); e++) {
689        const TSignNet::TEdgeI EI2 = Net2->GetEI(NI2.GetId(), Perm[NI1.GetOutNId(e)]);
690        if (EI2 == EndEI2 || NI1.GetOutEDat(e) != EI2()) {
691          return false;
692        }
693      }
694    }
695    return true;
696  }
697  void TSignNet::GetPartOverlap(const TVec<TIntV>& PartNIdV1, const TVec<TIntV>& PartNIdV2) {
698    printf("Partition overlap:\n");
699    for (int p2 = 0; p2 < PartNIdV2.Len(); p2++) {
700      printf("\t%6d(%d)", p2, PartNIdV2[p2].Len());
701    }
702    printf("\n");
703    for (int p1 = 0; p1 < PartNIdV1.Len(); p1++) {
704      printf("%6d(%d)\t", p1, PartNIdV1[p1].Len());
705      for (int p2 = 0; p2 < PartNIdV2.Len(); p2++) {
706        printf("%9d\t", PartNIdV1[p1].IntrsLen(PartNIdV2[p2]));
707      }
708      printf("\n");
709    }
710  }
711  PSignNet TSignNet::LoadEpinions(const TStr& FNm) {
712    TSsParser Ss(FNm, ssfTabSep);
713    PSignNet Net = TSignNet::New();
714    while (Ss.Next()) {
715      const int src = Ss.GetInt(0);
716      const int dst = Ss.GetInt(1);
717      if (src == dst) { continue; } 
718      if (!Net->IsNode(Ss.GetInt(0))) {
719        Net->AddNode(Ss.GetInt(0));
720      }
721      if (!Net->IsNode(Ss.GetInt(0))) {
722        Net->AddNode(Ss.GetInt(1));
723      }
724      Net->AddEdge(Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2));
725    }
726    return Net;
727  }
728  PSignNet TSignNet::LoadSlashdot(const TStr& InFNm) {
729    THashSet<TChA> NIdSet;
730    TChA LnStr;
731    TVec<char *> WrdV;
732    int Sign;
733    PSignNet Net = TSignNet::New();
734    for (TFIn FIn(InFNm); FIn.GetNextLn(LnStr); ) {
735      if (LnStr.Empty() || LnStr[0]=='#') { continue; }
736      LnStr.ToLc();
737      TStrUtil::SplitOnCh(LnStr, WrdV, '\t', false);
738      NIdSet.AddKey(WrdV[0]);
739      if (strcmp(WrdV[1], "friends")==0) { Sign = 1; }
740      else if (strcmp(WrdV[1], "fans")==0) { continue; } 
741      else if (strcmp(WrdV[1], "foes")==0) { Sign = -1; } else { Fail; }
742      const int SrcNId = NIdSet.AddKey(WrdV[0]);
743      if (! Net->IsNode(SrcNId)) {
744        Net->AddNode(SrcNId); }
745      for (int e = 2; e < WrdV.Len(); e++) {
746        const int DstNId = NIdSet.AddKey(WrdV[e]);
747        if (SrcNId != DstNId && ! Net->IsEdge(SrcNId, DstNId)) {
748          Net->AddNode(DstNId);
749          Net->AddEdge(SrcNId, DstNId, Sign);
750        }
751      }
752    }
753    TSnap::PrintInfo(Net, InFNm);
754    return Net;
755  }
756  PSignNet TSignNet::GetSmallNet() {
757    PSignNet Net = TSignNet::New();
758    for (int i = 0; i < 5; i ++) { Net->AddNode(); }
759    Net->AddEdge(0,1, +1); Net->AddEdge(1,2, +1); Net->AddEdge(2,0, -1);  Net->AddEdge(0,2, -1);
760    Net->AddEdge(1,3, +1);
761    Net->AddEdge(3,4, +1); Net->AddEdge(4,3, +1);
762     Net->AddEdge(1,4, +1);
763    return Net;
764  }
765  int THopfield::MinEnergy(const int& NPart) {
766    TIntV NIdV(Net->GetNodes(), 0);
767    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
768      NIdPartH.AddDat(NI.GetId(), TInt::Rnd.GetUniDevInt(NPart));
769      NIdV.Add(NI.GetId());
770    }
771    TIntPrV EnergyV(NPart); 
772    int Flips = 0;
773    for (int iter = 0; iter < 100; iter++) {
774      NIdV.Shuffle(TInt::Rnd);
775      Flips = 0;
776      for (int n = 0; n < NIdV.Len(); n++) {
777        TSignNet::TNodeI NI = Net->GetNI(NIdV[n]);
778        for (int p = 0; p < NPart; p++) {
779          EnergyV[p].Val1=0;  EnergyV[p].Val2=p; }
780        for (int e = 0; e < NI.GetOutDeg(); e++) {
781          const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
782          const int Sign = NI.GetOutEDat(e);
783          EnergyV[DstPart].Val1 += Sign;
784        }
785        EnergyV.Sort(false); 
786        const int NewPart = EnergyV[0].Val2;
787        if (NIdPartH.GetDat(NI.GetId()) != NewPart) { 
788          NIdPartH.AddDat(NI.GetId(), NewPart);
789          Flips++;
790        }
791      }
792    }
793    int OkMns=0, OkPls=0, AllMns=0, AllPls=0;
794    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
795      const int SrcPart = NIdPartH.GetDat(NI.GetId());
796      for (int e = 0; e < NI.GetOutDeg(); e++) {
797        const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
798        const int Vote = NI.GetOutEDat(e);
799        if (Vote < 0) {
800          if (DstPart != SrcPart) { OkMns++; }
801          AllMns++; }
802        if (Vote > 0) {
803          if (DstPart == SrcPart) { OkPls++; }
804          AllPls++;
805        }
806      }
807    }
808    if (OkPls+OkMns > MxEnergy) {
809      MxEnergy = OkPls+OkMns;
810      BestPart = NIdPartH;
811    }
812    return OkPls+OkMns;
813  }
814  int THopfield::FindStableSet(const int& NPart, const int& NRuns) {
815    NIdPartH.Clr();
816    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
817      NIdPartH.AddDat(NI.GetId(), 0);
818    }
819    TIntPrV PartSzV(NPart);
820    int MxOk=0, SumOk=0;
821    printf("Find stable set %d runs\n", NRuns);
822    for (int runs = 0; runs < NRuns; runs++) {
823      const int OkEdges = MinEnergy(NPart);
824      EnergDistr.AddDat(OkEdges) += 1;
825      for (int i = 0; i < NPart; i++) {
826        PartSzV[i]=TIntPr(0,i); }
827      for (int i = 0; i < NIdPartH.Len(); i++) {
828        PartSzV[NIdPartH[i]].Val1 += 1; }
829      PartSzV.Sort(false); 
830      for (int i = 0; i < NIdPartH.Len(); i++) {
831        const int PartId = PartSzV[NIdPartH[i]].Val2;
832        NIdPartCnt.AddDat(NIdPartH.GetKey(i))[PartId] += 1;
833      }
834      SumOk += OkEdges;
835      MxOk = TMath::Mx(MxOk, OkEdges);
836    }
837    printf("  Best: %d   Average: %d\n", MxOk, SumOk/NRuns);
838    return MxOk;
839  }
840  void THopfield::GetStableSet(const int& Tresh, TVec<TIntV>& PartNIdV) {
841    PartNIdV.Gen(NIdPartCnt[0].Len());
842    for (int i = 0; i < NIdPartCnt.Len(); i++) {
843      const int MxPart = NIdPartCnt[i].FindMx();
844      if (NIdPartCnt[i][MxPart] >= Tresh) {
845        PartNIdV[MxPart].Add(NIdPartCnt.GetKey(i));
846      }
847    }
848    while (! PartNIdV.Empty() && PartNIdV.Last().Empty()) {
849      PartNIdV.DelLast();
850    }
851    for (int p = 0; p < PartNIdV.Len(); p++) {
852      PartNIdV[p].Sort();
853    }
854  }
855  void THopfield::PlotPartStab(const TStr& FNm, TStr Desc) const {
856    int runs = 0;
857    for (int r = 0; r < EnergDistr.Len(); r++) {
858      runs+=EnergDistr[r];
859    }
860    if (Desc.Empty()) { Desc = FNm; }
861    for (int part = 0; part < NIdPartCnt[0].Len(); part++) {
862      TIntH PartH;
863      for (int n = 0; n < NIdPartCnt.Len(); n++) {
864        if (NIdPartCnt[n][part]>0) {
865          PartH.AddDat(NIdPartCnt[n][part]) += 1;
866        }
867      }
868      if (PartH.Len() <= 1) { continue; }
869      TGnuPlot::PlotValCntH(PartH, TStr::Fmt("partStab-%s-%d", FNm.CStr(), part), TStr::Fmt("%s: Partition %d stability. %d runs. Best energy: %d",
870        Desc.CStr(), part, runs, MxEnergy), "Number of times in the partition", "Number of nodes", gpsAuto, false);
871    }
872    TGnuPlot::PlotValCntH(EnergDistr, "hopfEnerg-"+FNm, TStr::Fmt("%s: Hopfield energy distribution over %d runs. Max: %d", Desc.CStr(), runs, MxEnergy),
873      TStr::Fmt("Energy (number of satisfied edges, out of %d", Net->GetEdges()), "Number of solutions");
874  }
875  void THopfield::DumpPartStat() const {
876    int OkMns=0, OkPls=0, AllMns=0, AllPls=0;
877    TIntH OkPlsH, AllPlsH, OkMnsH, AllMnsH;
878    int NPart=0;
879    for (int i = 0; i < NIdPartH.Len(); i++) {
880      NPart = TMath::Mx(NIdPartH[i].Val, NPart);
881    }
882    for (int p = 0; p < NPart; p++) {
883      OkPlsH.AddDat(p,0); AllPlsH.AddDat(p,0);
884      OkMnsH.AddDat(p,0); AllMnsH.AddDat(p,0);
885    }
886    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
887      const int SrcPart = NIdPartH.GetDat(NI.GetId());
888      for (int e = 0; e < NI.GetOutDeg(); e++) {
889        const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
890        const int Vote = NI.GetOutEDat(e);
891        if (Vote == -1) {
892          if (DstPart != SrcPart) { OkMnsH.AddDat(SrcPart) += 1;  OkMns++; }
893          AllMnsH.AddDat(SrcPart) += 1;  AllMns++; }
894        if (Vote == +1) {
895          if (DstPart == SrcPart) { OkPlsH.AddDat(SrcPart) += 1;  OkPls++; }
896          AllPlsH.AddDat(SrcPart) += 1;  AllPls++;
897        }
898      }
899    }
900    printf("\nSatisfied edges: + : %5d / %5d  = %f\n", OkPls, AllPls, double(OkPls)/double(AllPls));
901    printf(  "                 - : %5d / %5d  = %f\n", OkMns, AllMns, double(OkMns)/double(AllMns));
902    TIntH PartCntH;
903    for (TSignNet::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
904      PartCntH.AddDat(NIdPartH.GetDat(NI.GetId())) += 1; }
905    PartCntH.SortByKey();
906    for (int p = 0; p < PartCntH.Len(); p++) {
907      printf("  part %2d : %5d (%.4f) nodes: +: %25s    -: %25s\n", p, PartCntH[p], PartCntH[p]/double(NIdPartH.Len()),
908        TStr::Fmt("%5d/%d=%.4f", OkPlsH.GetDat(PartCntH.GetKey(p)), AllPlsH.GetDat(PartCntH.GetKey(p)), OkPlsH.GetDat(PartCntH.GetKey(p))/double(AllPlsH.GetDat(PartCntH.GetKey(p)))).CStr(),
909        TStr::Fmt("%5d/%d=%.4f", OkMnsH.GetDat(PartCntH.GetKey(p)), AllMnsH.GetDat(PartCntH.GetKey(p)), OkMnsH.GetDat(PartCntH.GetKey(p))/double(AllMnsH.GetDat(PartCntH.GetKey(p)))).CStr() );
910    }
911  }
912  void TSignMicroEvol::BuildPerms() {
913    PermH.Clr();
914    PermH.AddDat(2).Add(TIntV::GetV(0,1));
915    PermH.AddDat(2).Add(TIntV::GetV(1,0));
916    PermH.AddDat(3).Add(TIntV::GetV(0,1,2));
917    PermH.AddDat(3).Add(TIntV::GetV(0,2,1));
918    PermH.AddDat(3).Add(TIntV::GetV(1,0,2));
919    PermH.AddDat(3).Add(TIntV::GetV(1,2,0));
920    PermH.AddDat(3).Add(TIntV::GetV(2,0,1));
921    PermH.AddDat(3).Add(TIntV::GetV(2,1,0));
922  }
923  TSignMicroEvol::TSignMicroEvol(PSignNet NetPt) : Network(NetPt) {
924    TransNet = TTransitionNet::New();
925    BuildPerms();
926  }
927  TSignMicroEvol::TSignMicroEvol(TSIn& SIn) {
928    TInt Nets(SIn);
929    for (int n = 0; n < Nets; n++) {
930      TriadIdV.Add(TSignNet::Load(SIn));
931    }
932    TransNet = TTransitionNet::Load(SIn);
933    TInt Diads(SIn);
934    for (int d = 0; d < Diads; d++) {
935      OpnTriadV.Add(TSignNet::Load(SIn));
936    }
937    CloseTriadH.Load(SIn);
938    Triad3to4H.Load(SIn);
939    BuildPerms();
940  }
941  void TSignMicroEvol::Save(TSOut& SOut) const {
942    SOut.Save(TriadIdV.Len());
943    for (int n = 0; n < TriadIdV.Len(); n++) {
944      TriadIdV[n]->Save(SOut);
945    }
946    TransNet->Save(SOut);
947    SOut.Save(OpnTriadV.Len());
948    for (int d = 0; d < OpnTriadV.Len(); d++) {
949      OpnTriadV[d]->Save(SOut);
950    }
951    CloseTriadH.Save(SOut);
952    Triad3to4H.Save(SOut);
953  }
954  PSignNet TSignMicroEvol::GetSubGraph(const int& N1, const int& N2) {
955    PSignNet Net2 = TSignNet::New();
956    Net2->AddNode(0);  Net2->AddNode(1);
957    if (Network->IsEdge(N1, N2)) { Net2->AddEdge(0, 1, Network->GetEDat(N1, N2)); }
958    if (Network->IsEdge(N2, N1)) { Net2->AddEdge(1, 0, Network->GetEDat(N2, N1)); }
959    return Net2;
960  }
961  PSignNet TSignMicroEvol::GetSubGraph(const int& N1, const int& N2, const int& N3) {
962    PSignNet Net2 = TSignNet::New();
963    Net2->AddNode(0);  Net2->AddNode(1);  Net2->AddNode(2);
964    if (Network->IsEdge(N1, N2)) { Net2->AddEdge(0, 1, Network->GetEDat(N1, N2)); }
965    if (Network->IsEdge(N2, N1)) { Net2->AddEdge(1, 0, Network->GetEDat(N2, N1)); }
966    if (Network->IsEdge(N1, N3)) { Net2->AddEdge(0, 2, Network->GetEDat(N1, N3)); }
967    if (Network->IsEdge(N3, N1)) { Net2->AddEdge(2, 0, Network->GetEDat(N3, N1)); }
968    if (Network->IsEdge(N2, N3)) { Net2->AddEdge(1, 2, Network->GetEDat(N2, N3)); }
969    if (Network->IsEdge(N3, N2)) { Net2->AddEdge(2, 1, Network->GetEDat(N3, N2)); }
970    return Net2;
971  }
972  void TSignMicroEvol::CountTriadClose(const int& SrcNId, const int& DstNId, const int& Sign, const double& SrcOutPlusProb,
973                               const double& DstInPlusProb, const bool& OnlySimpleTriads) {
974    IAssert(! Network->IsEdge(SrcNId, DstNId));
975    if (! Network->IsEdge(DstNId, SrcNId)) {
976      TIntV NbrV;
977      TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
978      for (int n = 0; n < NbrV.Len(); n++) {
979        PSignNet Net1 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
980        PSignNet Net2 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
981        Net2->AddEdge(0, 1, Sign); 
982        const int Net1Id = GetTriadId(Net1);
983        const int Net2Id = GetTriadId(Net2);
984        if (! TransNet->IsNode(Net1Id)) { TransNet->AddNode(Net1Id, 0); }
985        if (! TransNet->IsNode(Net2Id)) { TransNet->AddNode(Net2Id, 0); }
986        if (! TransNet->IsEdge(Net1Id, Net2Id)) { TransNet->AddEdge(Net1Id, Net2Id); }
987        TransNet->GetNDat(Net1Id) += 1;
988        TransNet->GetNDat(Net2Id) += 1;
989        { TTransStat& Stat = TransNet->GetEDat(Net1Id, Net2Id);
990        if (Sign == +1) { Stat.SumWgt += SrcOutPlusProb; }
991        else { Stat.SumWgt+= 1-SrcOutPlusProb; }
992        Stat.Cnt++;  Stat.VarSq += SrcOutPlusProb*(1-SrcOutPlusProb); }
993        { const int TrId = GetOpnTriadId(Net1);
994        TCloseStat& ClsStat = CloseTriadH.AddDat(TrId);
995        if (Sign == +1) { ClsStat.PlsCnt++; }
996        else { ClsStat.MnsCnt++; }
997        ClsStat.OutSumWgt += SrcOutPlusProb;
998        ClsStat.OutVarSq += SrcOutPlusProb*(1-SrcOutPlusProb);
999        ClsStat.InSumWgt += DstInPlusProb;
1000        ClsStat.InVarSq += DstInPlusProb*(1-DstInPlusProb);
1001        ClsStat.OutPlusPH.AddDat(int(SrcOutPlusProb*50)*2) += 1;
1002        ClsStat.InPlusPH.AddDat(int(DstInPlusProb*50)*2) += 1; }
1003      }
1004    } else { 
1005      RepLinkCntH.AddDat(TIntPr(Network->GetEDat(DstNId, SrcNId), Sign)).Val1 += 1;
1006      RepLinkCntH.AddDat(TIntPr(Network->GetEDat(DstNId, SrcNId), Sign)).Val2 += SrcOutPlusProb;
1007    }
1008    if (OnlySimpleTriads && Network->IsEdge(DstNId, SrcNId)) {
1009      return; }
1010    else {
1011      Network->AddNode(SrcNId);
1012      Network->AddNode(DstNId);
1013      Network->AddEdge(SrcNId, DstNId, Sign);
1014    }
1015  }
1016  void TSignMicroEvol::CountTriad3to4Edges(const int& SrcNId, const int& DstNId, const int& Sign, const double& SrcOutPlusProb, const double& DstInPlusProb) {
1017    IAssert(! Network->IsEdge(SrcNId, DstNId));
1018    TIntV NbrV;
1019    TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
1020    for (int n = 0; n < NbrV.Len(); n++) {
1021      PSignNet Net1 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1022      if (! (Net1->GetEdges()==3 && Net1->IsClosedTriad())) { continue; }
1023      PSignNet Net2 = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1024      Net2->AddEdge(0, 1, +1); 
1025      const int Net1Id = GetTriadId(Net1);
1026      const int Net2Id = GetTriadId(Net2);
1027      TCloseStat& ClsStat = Triad3to4H.AddDat(TIntPr(Net1Id, Net2Id));
1028      if (Sign == +1) { ClsStat.PlsCnt++; }
1029      else { ClsStat.MnsCnt++; }
1030      ClsStat.OutSumWgt += SrcOutPlusProb;
1031      ClsStat.OutVarSq += SrcOutPlusProb*(1-SrcOutPlusProb);
1032      ClsStat.InSumWgt += DstInPlusProb;
1033      ClsStat.InVarSq += DstInPlusProb*(1-DstInPlusProb);
1034      ClsStat.OutPlusPH.AddDat(int(SrcOutPlusProb*50)*2) += 1;
1035      ClsStat.InPlusPH.AddDat(int(DstInPlusProb*50)*2) += 1;
1036    }
1037    Network->AddNode(SrcNId);
1038    Network->AddNode(DstNId);
1039    Network->AddEdge(SrcNId, DstNId, Sign);
1040  }
1041  void TSignMicroEvol::CountTriadCloseVec(const int& SrcNId, const int& DstNId, const int& Sign) {
1042    TIntV NbrV;
1043    TSnap::GetCmnNbrs(Network, SrcNId, DstNId, NbrV);
1044    TTuple<TInt, 16> CntV;
1045    for (int n = 0; n < NbrV.Len(); n++) {
1046      PSignNet OpnTriadNet = GetSubGraph(SrcNId, DstNId, NbrV[n]);
1047      if (OpnTriadNet->GetEdges() != 2) { continue; }
1048      const int TdId = GetOpnTriadId(OpnTriadNet);
1049      IAssert(TdId < 16);
1050      CntV[TdId]++;
1051    }
1052    TIntPr& Cnt = TriadVecV.AddDat(CntV);
1053    if (Sign==+1) { Cnt.Val1 += 1; }
1054    else { Cnt.Val2 += 1; }
1055    IAssert(! Network->IsEdge(SrcNId, DstNId));
1056    Network->AddNode(SrcNId);  Network->AddNode(DstNId);
1057    Network->AddEdge(SrcNId, DstNId, Sign);
1058  }
1059  int TSignMicroEvol::IsSameOpnTriad(const PSignNet& Net1, const PSignNet& Net2) {
1060    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) {
1061      return false;
1062    }
1063    TSignNet::TEdgeI EI1 = Net1->BegEI();
1064    TSignNet::TEdgeI EI2 = Net2->BegEI();
1065    while (EI1 < Net1->EndEI()) {
1066      if (EI1.GetSrcNId() != EI2.GetSrcNId()) { return false; }
1067      if (EI1.GetDstNId() != EI2.GetDstNId()) { return false; }
1068      if (EI1() != EI2()) { return false; }
1069      EI1++;  EI2++;
1070    }
1071    return true;
1072  }
1073  int TSignMicroEvol::GetOpnTriadId(const PSignNet& Net1) {
1074    for (int i = 0; i < OpnTriadV.Len(); i++) {
1075      if (IsSameOpnTriad(OpnTriadV[i], Net1)) { return i; }
1076    }
1077    OpnTriadV.Add(Net1);
1078    return OpnTriadV.Len()-1;
1079  }
1080  bool TSignMicroEvol::IsSameTriad(const PSignNet& Net1, const PSignNet& Net2, int& PermId) const {
1081    if (Net1->GetNodes() != Net2->GetNodes() || Net1->GetEdges() != Net2->GetEdges()) {
1082      return false; }
1083    const TVec<TIntV>& PermV = PermH.GetDat(Net1->GetNodes());
1084    for (int p = 0; p < PermV.Len(); p++) {
1085      if (IsSameTriad(Net1, Net2, PermV[p])) {
1086        PermId=p; return true;
1087      }
1088    }
1089    return false;
1090  }
1091  int TSignMicroEvol::GetTriadId(const PSignNet& Net1) {
1092    int PermId;
1093    for (int i = 0; i < TriadIdV.Len(); i++) {
1094      if (IsSameTriad(TriadIdV[i], Net1, PermId)) { TriadIdV[i]=Net1; return i; }
1095    }
1096    TriadIdV.Add(Net1);
1097    TransNet->AddNode(TriadIdV.Len()-1, 0);
1098    return TriadIdV.Len()-1;
1099  }
1100  double TSignMicroEvol::GetStatusDelta(const PSignNet& Net, const int& NId1, const int& NId2) {
1101    int S1, S2;
1102    if (! Net->IsEdge(NId1, NId2)) { S1 = 0; }
1103    else if (Net->GetEDat(NId1, NId2)>0) { S1 = 1; } else { S1 = -1; }
1104    if (! Net->IsEdge(NId2, NId1)) { S2 = 0; }
1105    else if (Net->GetEDat(NId2, NId1)>0) { S2 = 1; } else { S2 = -1; }
1106    if (S1==+1 && S2==0) { return +0.2; }
1107    if (S1==-1 && S2==0) { return -0.8; }
1108    if (S1==0 && S2==+1) { return -0.2; }
1109    if (S1==0 && S2==-1) { return +0.8; }
1110    if (S1==+1 && S2==+1) { return +0.4; }
1111    if (S1==-1 && S2==-1) { return -1.6; }
1112    if (S1==+1 && S2==-1) { return +1; }
1113    if (S1==-1 && S2==+1) { return -1; }
1114    Fail;  return -1;
1115  }
1116  double TSignMicroEvol::GetStatus(const PSignNet& Net, const int& NId) {
1117    if (NId == 2) { return 0; }
1118    return GetStatusDelta(Net, 2, NId);
1119  }
1120  bool TSignMicroEvol::IsStatusFrac(const int& OpnTriadId, const bool& DstNode) const {
1121    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1122    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1123    if (DstNode) {
1124      if (GetStatus(SrcNet, 1) > 0) { if (Stat.GetPlsFrac()>0.8) { return true; } }
1125      else { if(Stat.GetPlsFrac()<0.2) { return true; } }
1126    } else {
1127      if (GetStatus(SrcNet, 1) > 0) { if (Stat.GetPlsFrac()<0.2) { return true; } }
1128      else { if(Stat.GetPlsFrac()>0.8) { return true; } }
1129    }
1130    return false;
1131  }
1132  bool TSignMicroEvol::IsStatusSurp(const int& OpnTriadId, const bool& DstNode) const {
1133    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1134    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1135    if (DstNode) {
1136      if (GetStatus(SrcNet, 1)*Stat.GetOutPlsSurp() > 0) { return true; } 
1137    } else {
1138      if (GetStatus(SrcNet, 0)*Stat.GetInPlsSurp() < 0) { return true; }
1139    }
1140    return false;
1141  }
1142  int GetUnDirEdgeSign(const PSignNet& Net, const int& NId1, const int& NId2) {
1143    int S1, S2, S;
1144    if (! Net->IsEdge(NId1, NId2)) { S1 = 0; }
1145    else if (Net->GetEDat(NId1, NId2)>0) { S1 = 1; } else { S1 = -1; }
1146    if (! Net->IsEdge(NId2, NId1)) { S2 = 0; }
1147    else if (Net->GetEDat(NId2, NId1)>0) { S2 = 1; } else { S2 = -1; }
1148    if (S1==0) { S=S2; }
1149    else if (S2==0) { S=S1; }
1150    else { S=TMath::Mx(S1,S2); }
1151    return S;
1152  }
1153  bool TSignMicroEvol::IsBalanceFrac(const int& OpnTriadId) const {
1154    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1155    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1156    const int S1 = GetUnDirEdgeSign(SrcNet, 0,2);
1157    const int S2 = GetUnDirEdgeSign(SrcNet, 1,2);
1158    const double Plus = Stat.GetPlsFrac();
1159    if (S1*S2 > 0 && Plus > 0.8) { return true; }
1160    if (S1*S2 < 0 && Plus < 0.8) { return true; }
1161    return false;
1162  }
1163  bool TSignMicroEvol::IsBalanceSurp(const int& OpnTriadId) const {
1164   const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId); 
1165    PSignNet SrcNet = OpnTriadV[OpnTriadId];
1166    const int S1 = GetUnDirEdgeSign(SrcNet, 0,2);
1167    const int S2 = GetUnDirEdgeSign(SrcNet, 1,2);
1168    const double Surp = Stat.GetOutPlsSurp();
1169    if (S1*S2 > 0 && Surp > 0) { return true; }
1170    if (S1*S2 < 0 && Surp < 0) { return true; }
1171    return false;
1172  }
1173  void TSignMicroEvol::PrintInfo() const {
1174    TSnap::PrintInfo(Network);
1175    Network->PrintInfo();
1176    THash<TIntPr, TFltPr> H = RepLinkCntH;
1177    H.SortByDat(false);
1178    printf("*** RECIPROCAL Links\n");
1179    for (int i = 0; i < H.Len(); i++) {
1180      printf(" %c is reciprocated by %c :  cnt %g  surp: %f\n",
1181        H.GetKey(i).Val1==1?'+':'-', H.GetKey(i).Val2==1?'+':'-', H[i].Val1, H[i].Val2);
1182    }
1183  }
1184  char TSignMicroEvol::GetEdgeChar(const PSignNet& Network, const int& n1, const int& n2) {
1185    if (! Network->IsEdge(n1,n2)) { return 'o'; }
1186    else if (Network->GetEDat(n1,n2)>0) { return '+'; }
1187    else { return '-'; }
1188  }
1189  void TSignMicroEvol::SaveCloseTriadTxt(const TStr& FNmPref, const bool& DrawNets, const bool& PlotHists) {
1190    printf("*** OPEN TRIADS %d\n", OpnTriadV.Len());
1191    TVec<TTriple<TInt, TStr, TInt> > OpnIdV;
1192    for (int n = 0; n < OpnTriadV.Len(); n++) {
1193      PSignNet SrcNet = OpnTriadV[n];
1194      OpnIdV.Add(TTriple<TInt, TStr, TInt>(SrcNet->GetEdges(), TStr::Fmt("%c%c%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2)), n));
1195    }
1196    OpnIdV.Sort();
1197    FILE* F = fopen(TStr::Fmt("%s-diad.tab", FNmPref.CStr()).CStr(), "wt");
1198    fprintf(F, "AB\tBC\tAC+\tAC-\tPctAC+\tOUT-Surprise\tIN-Surprise\tDst-StsFrac\tDst-StsSurp\tSrc-StsFrac\tSrc-StsSurp\tBalFrac\tBalSurp\n");
1199    for (int n = 0; n < OpnIdV.Len(); n++) {
1200      const int Id = OpnIdV[n].Val3;
1201      PSignNet SrcNet = OpnTriadV[Id];
1202      const TCloseStat Stat = CloseTriadH.GetDat(Id); 
1203      fprintf(F, "%c%c\t%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2));
1204      fprintf(F, "\t%d\t%d\t%.4f\t%.4f\t%.4f\t%s\t%s\t%s\t%s\t%s\t%s\n", Stat.PlsCnt, Stat.MnsCnt, Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp(),
1205        IsStatusFrac(Id,true)?"1":"0", IsStatusSurp(Id,true)?"1":"0", IsStatusFrac(Id,false)?"1":"0", IsStatusSurp(Id,false)?"1":"0",
1206        IsBalanceFrac(Id)?"1":"0", IsBalanceSurp(Id)?"1":"0");
1207    }
1208    fclose(F);
1209    if (DrawNets) {
1210      for (int i = 0; i < 16; i++) {
1211        const int Id = OpnIdV[i].Val3;
1212        TStr Label = TStr::Fmt("dst-status: p+:%s  s+:%s\\nsrc-status: p+:%s  s+:%s\\nbalance: p+:%s s+:%s",
1213          IsStatusFrac(Id,true)?"Y":"N", IsStatusSurp(Id,true)?"Y":"N",
1214          IsStatusFrac(Id,false)?"Y":"N", IsStatusSurp(Id,false)?"Y":"N",
1215          IsBalanceFrac(Id)?"Y":"N", IsBalanceSurp(Id)?"Y":"N");
1216        DrawCloseTriad(TStr::Fmt("%s_%02d", FNmPref.CStr(), i), Id, Label);
1217      }
1218    }
1219    if (PlotHists) {
1220      for (int i = 0; i < 16; i++) {
1221        const int Id = OpnIdV[i].Val3;
1222        CloseTriadH.GetDat(Id).SaveHist(TStr::Fmt("%s_%02d", FNmPref.CStr(), i));
1223      }
1224    }
1225    printf("done.\n");
1226  }
1227  void TSignMicroEvol::DrawCloseTriad(const TStr& FNmPref, const int& OpnTriadId, const TStr& Label) {
1228    PSignNet Network = OpnTriadV[OpnTriadId];
1229    TStr FNm = TStr::Fmt("%s-OpnTriad.dot", FNmPref.CStr());
1230    FILE *F = fopen(FNm.CStr(), "wt");
1231    fprintf(F, "  digraph G {\n");
1232    fprintf(F, "    graph [splines=true, overlap=false];\n");
1233    fprintf(F, "    node  [shape=ellipse, width=0.3, height=0.3];\n");
1234    fprintf(F, "    edge  [len=4];\n");
1235    for (TSignNet::TNodeI NI = Network->BegNI(); NI < Network->EndNI(); NI++) {
1236      fprintf(F, "    node%d [label=\"%g\"];\n", NI.GetId(), GetStatus(Network, NI.GetId())); }
1237    for (TSignNet::TEdgeI EI = Network->BegEI(); EI < Network->EndEI(); EI++) {
1238      fprintf(F, "    node%d -> node%d [label=\"%s\"];\n",
1239        EI.GetSrcNId(), EI.GetDstNId(), EI()==1?"+":"--"); }
1240    const TCloseStat Stat = CloseTriadH.GetDat(OpnTriadId);
1241    fprintf(F, "    node0 -> node1 [label=\"+:%d -:%d\\np+:%.3f  so: %.1f  si: %.1f\", color=\"red\"];\n",
1242      Stat.PlsCnt(), Stat.MnsCnt(), Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp());
1243    if (! Label.Empty()) { fprintf(F, "label = \"%s\";\n", Label.CStr()); }
1244    fprintf(F, "}\n");
1245    fclose(F);
1246    TSnap::TSnapDetail::GVizDoLayout(FNm, FNm.GetFMid()+".gif", gvlNeato);
1247  }
1248  bool IsBalancedSwapEdge(const PSignNet& Net, const TIntPr& BackEdge, const int& Sign) {
1249    const int s1 = Net->GetEDat(BackEdge.Val2, BackEdge.Val1);
1250    const int s2 = Net->GetEDat(BackEdge.Val1, BackEdge.Val2);
1251    Net->DelEdge(BackEdge.Val2, BackEdge.Val1);
1252    Net->GetEDat(BackEdge.Val1, BackEdge.Val2) = Sign;
1253    const bool IsBal = Net->IsBalanced();
1254    Net->AddEdge(BackEdge.Val2, BackEdge.Val1, s1);
1255    Net->GetEDat(BackEdge.Val1, BackEdge.Val2) = s2;
1256    return IsBal;
1257  }
1258  void TSignMicroEvol::SaveTriad3to4Edges(const TStr& FNmPref) {
1259    TVec<TPair<TIntTr, TInt> > SigTIdV;
1260    for (int t = 0; t < Triad3to4H.Len(); t++) {
1261      SigTIdV.Add(TPair<TIntTr, TInt>(TriadIdV[Triad3to4H.GetKey(t).Val1]->GetTriadSig(), t));
1262    }
1263    SigTIdV.Sort();
1264    FILE *F = fopen(TStr::Fmt("tr3to4-%s2.tab", FNmPref.CStr()).CStr(), "wt");
1265    fprintf(F, "Balanced\tSrcTriad\t\t\t\tDstTriad\t\t\tPlus-BAL\tMns-BAL\tPlusCnt\tPlusFrac\tOUT-Supr\tIN-Surp\tBal-Frac\tBal-OutSurp\tBal-InSurp\n");
1266    for (int t = 0; t < SigTIdV.Len(); t++) {
1267      const int SrcTId = Triad3to4H.GetKey(SigTIdV[t].Val2).Val1;
1268      const int DstTId = Triad3to4H.GetKey(SigTIdV[t].Val2).Val2;
1269      const TCloseStat& Stat = Triad3to4H[SigTIdV[t].Val2];
1270      TIntTr SrcSig = TriadIdV[SrcTId]->GetTriadSig();
1271      TIntTr DstSig = TriadIdV[DstTId]->GetTriadSig();
1272      TIntPr NewEdge = TriadIdV[DstTId]->GetNewEdge(TriadIdV[SrcTId]);
1273      const bool SrcBal = TriadIdV[SrcTId]->IsBalanced();
1274      const bool DstPlsBal = IsBalancedSwapEdge(TriadIdV[DstTId], NewEdge, 1);
1275      const bool DstMnsBal = IsBalancedSwapEdge(TriadIdV[DstTId], NewEdge, -1);
1276      IAssert(int(DstPlsBal)+int(DstMnsBal)==1);
1277      fprintf(F, "%d\t%s\t->\t%s\t%d\t%d\t%d\t%.3f\t%.3f\t%.3f",
1278        SrcBal?1:0, TSignNet::GetTriadStr(SrcSig).CStr(),
1279        TSignNet::GetTriadStr(DstSig).CStr(), DstPlsBal?1:0, DstMnsBal?1:0,
1280        Stat.PlsCnt, Stat.GetPlsFrac(), Stat.GetOutPlsSurp(), Stat.GetInPlsSurp());
1281      const bool IsPlusBal = (DstPlsBal && Stat.GetPlsFrac()>0.8) || (! DstPlsBal && Stat.GetPlsFrac()<0.8);
1282      const bool IsOutSur = (DstPlsBal && Stat.GetOutPlsSurp()>2) || (! DstPlsBal && Stat.GetOutPlsSurp()<-2);
1283      const bool IsInSur = (DstPlsBal && Stat.GetInPlsSurp()>2) || (! DstPlsBal && Stat.GetInPlsSurp()<-2);
1284      fprintf(F, "\t%d\t%d\t%d\n", IsPlusBal?1:0, IsOutSur?1:0, IsInSur?1:0);
1285    }
1286    fclose(F);
1287  }
1288  void TSignMicroEvol::SaveTriadCloseVec(const TStr& FNmPref) {
1289    IAssert(OpnTriadV.Len() == 16);
1290    TVec<TTriple<TInt, TStr, TInt> > OpnIdV;
1291    for (int n = 0; n < OpnTriadV.Len(); n++) {
1292      PSignNet SrcNet = OpnTriadV[n];
1293      OpnIdV.Add(TTriple<TInt, TStr, TInt>(SrcNet->GetEdges(), TStr::Fmt("%c%c%c%c", GetEdgeChar(SrcNet, 0,2), GetEdgeChar(SrcNet, 2,0), GetEdgeChar(SrcNet, 2,1), GetEdgeChar(SrcNet, 1,2)), n));
1294    }
1295    OpnIdV.Sort();
1296    TriadVecV.SortByKey(false);
1297    FILE *F = fopen(TStr::Fmt("trVec2-%s.tab", FNmPref.CStr()).CStr(), "wt");
1298    for (int i = 0; i < OpnIdV.Len(); i++) { fprintf(F, "%s\t", OpnIdV[i].Val2.CStr()); }
1299    fprintf(F, "PlsCnt\tMnsCnt\n");
1300    printf("%d vectors\n", TriadVecV.Len());
1301    for (int v = 0; v < TMath::Mn(1000, TriadVecV.Len()); v++) {
1302      const TTuple<TInt, 16>& V = TriadVecV.GetKey(v);
1303      for (int i = 0; i < V.Len(); i++) {
1304        fprintf(F, "%d\t", V[OpnIdV[i].Val3]);
1305      }
1306      fprintf(F, "%d\t%d\n", TriadVecV[v].Val1, TriadVecV[v].Val2);
1307    }
1308    fclose(F);
1309  }
1310  void TSignMicroEvol::EpinionsTriadEvolution(const bool& OnlySimpleTriads) {
1311    TSsParser Ss("W:\\Data\\Epinions\\user_rating.txt", ssfTabSep);
1312    TVec<TIntQu> EdgeV;
1313    for (int c = 0; Ss.Next(); c++) {
1314      TChA ChA(Ss[3]);
1315      TVec<char*> V;  TStrUtil::SplitOnCh(ChA, V, '/');
1316      TSecTm Tm(atoi(V[0]), atoi(V[1]), atoi(V[2]));
1317      EdgeV.Add(TIntQu(Tm.GetAbsSecs(), Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2))); 
1318    }
1319    EdgeV.Sort();
1320    PSignNet Net = TSignNet::New();
1321    int e = 0;
1322    const TSecTm BegTm(2001, 01, 10);
1323    for (; e < EdgeV.Len() && (uint)EdgeV[e].Val1 <= BegTm.GetAbsSecs(); e++) {
1324      if (OnlySimpleTriads &&  Net->IsEdge(EdgeV[e].Val3, EdgeV[e].Val2)) { continue; }
1325      Net->AddNode(EdgeV[e].Val2);  Net->AddNode(EdgeV[e].Val3);
1326      Net->AddEdge(EdgeV[e].Val2, EdgeV[e].Val3, EdgeV[e].Val4);
1327    }
1328    TSnap::PrintInfo(Net);
1329    TSignMicroEvol SME(Net);
1330    TIntFltH OutPlusProbH, InPlusProbH;
1331    { THash<TInt, TIntPr> PlsMnsCnt1, PlsMnsCnt2;
1332    for (int e1=0; e1 < EdgeV.Len(); e1++) {
1333      if (EdgeV[e1].Val4==1) { PlsMnsCnt1.AddDat(EdgeV[e1].Val2).Val1++; } 
1334      else { PlsMnsCnt1.AddDat(EdgeV[e1].Val2).Val2++; }
1335      if (EdgeV[e1].Val4==1) { PlsMnsCnt2.AddDat(EdgeV[e1].Val3).Val1++; } 
1336      else { PlsMnsCnt2.AddDat(EdgeV[e1].Val3).Val2++; }
1337    }
1338    for (int u = 0; u < PlsMnsCnt1.Len(); u++) {
1339      OutPlusProbH.AddDat(PlsMnsCnt1.GetKey(u), PlsMnsCnt1[u].Val1/double(PlsMnsCnt1[u].Val1+PlsMnsCnt1[u].Val2)); }
1340    for (int u = 0; u < PlsMnsCnt2.Len(); u++) {
1341      InPlusProbH.AddDat(PlsMnsCnt2.GetKey(u), PlsMnsCnt2[u].Val1/double(PlsMnsCnt2[u].Val1+PlsMnsCnt2[u].Val2));
1342    } } /&bsol;*/
1343    printf("*** skip fist %d edges\n", e);
1344    int Plus=0, Minus=0, SkipEdges=e;
1345    const TStr OutFNm = TStr::Fmt("epin851-%s", OnlySimpleTriads?"SmpTr":"AllTr");
1346    for (; e < EdgeV.Len(); e++) {
1347      const int n1 = EdgeV[e].Val2;
1348      const int n2 = EdgeV[e].Val3;
1349      const int Sign = EdgeV[e].Val4;
<span onclick='openModal()' class='match'>1350      if (n1 == n2 || Net->IsEdge(n1,n2))  { continue; }
1351      if (Sign==1) { Plus++; } else { Minus++; }
</span>1352      const double SrcOutPlusProb = OutPlusProbH.GetDat(n1);  
1353      const double DstInPlusProb = InPlusProbH.GetDat(n2);    
1354      SME.CountTriad3to4Edges(n1, n2, Sign, SrcOutPlusProb, DstInPlusProb);
1355      if ((e+1) % 1000 == 0) { printf("."); }
1356    }
1357    printf("\n\n*** %s\n", OutFNm.CStr());
1358    printf("In %d good edges %d plus %d minus.\n", EdgeV.Len()-SkipEdges, Plus, Minus);
1359    SME.PrintInfo();
1360    SME.SaveTriad3to4Edges(OutFNm);            
1361  }
1362  void GetKeyPrV(const THash<TIntPr, TInt>& H, const int& MinCnt, TFltPrV& V) {
1363    V.Clr(false);
1364    for (int i = 0; i < H.Len(); i++) {
1365      if (H[i] >= MinCnt) {
1366        V.Add(TFltPr(H.GetKey(i).Val1+TInt::Rnd.GetUniDev()+1.0,
1367          H.GetKey(i).Val2+TInt::Rnd.GetUniDev()+1.0));
1368      }
1369    }
1370  }
1371  void TSignMicroEvol::EpinionsStat() {
1372    TSsParser Ss("W:\\Data\\Epinions\\user_rating.txt", ssfTabSep);
1373    TVec<TIntQu> EdgeV;
1374    for (int c = 0; Ss.Next(); c++) {
1375      TChA ChA(Ss[3]);
1376      TVec<char*> V;  TStrUtil::SplitOnCh(ChA, V, '/');
1377      TSecTm Tm(atoi(V[0]), atoi(V[1]), atoi(V[2]));
1378      EdgeV.Add(TIntQu(Tm.GetAbsSecs(), Ss.GetInt(0), Ss.GetInt(1), Ss.GetInt(2))); 
1379    }
1380    THash<TInt, TIntQu> NIdPmOutInH;
1381    for (int e = 0; e < EdgeV.Len(); e++) {
1382      TIntQu& Src = NIdPmOutInH.AddDat(EdgeV[e].Val2);
1383      TIntQu& Dst = NIdPmOutInH.AddDat(EdgeV[e].Val3);
1384      if (EdgeV[e].Val4 == 1) {
1385        Src.Val1++; Dst.Val3++; 
1386      } else {
1387        Src.Val2++; Dst.Val4++; 
1388      }
1389    }
1390    TFltPrV PiPo, PiMi, PiMo, PoMi, PoMo, MiMo;
1391    THash<TIntPr, TInt> PiPoH, PiMiH, PiMoH, PoMiH, PoMoH, MiMoH;
1392    for (int i = 0; i < NIdPmOutInH.Len(); i++) {
1393      TIntQu PMOI = NIdPmOutInH[i];
1394      PiPo.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val1+TInt::Rnd.GetUniDev()+1.0));
1395      PiMi.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val4+TInt::Rnd.GetUniDev()+1.0));
1396      PiMo.Add(TFltPr(PMOI.Val3+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));
1397      PoMi.Add(TFltPr(PMOI.Val1+TInt::Rnd.GetUniDev()+1.0, PMOI.Val4+TInt::Rnd.GetUniDev()+1.0));
1398      PoMo.Add(TFltPr(PMOI.Val1+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));
1399      MiMo.Add(TFltPr(PMOI.Val4+TInt::Rnd.GetUniDev()+1.0, PMOI.Val2+TInt::Rnd.GetUniDev()+1.0));/&bsol;*/
1400      PiPoH.AddDat(TIntPr(PMOI.Val3, PMOI.Val1)) += 1;
1401      PiMiH.AddDat(TIntPr(PMOI.Val3, PMOI.Val4)) += 1;
1402      PiMoH.AddDat(TIntPr(PMOI.Val3, PMOI.Val2)) += 1;
1403      PoMiH.AddDat(TIntPr(PMOI.Val1, PMOI.Val4)) += 1;
1404      PoMoH.AddDat(TIntPr(PMOI.Val1, PMOI.Val2)) += 1;
1405      MiMoH.AddDat(TIntPr(PMOI.Val4, PMOI.Val2)) += 1;
1406    }
1407    TStr OutFNm = "EpinAll";
1408    TGnuPlot::PlotValV(PiPo, "pipo-"+OutFNm, OutFNm, "Number of + IN", "Number of + OUT", gpsLog, false, gpwPoints);
1409    TGnuPlot::PlotValV(PiMi, "pimi-"+OutFNm, OutFNm, "Number of + IN", "Number of - IN", gpsLog, false, gpwPoints);
1410    TGnuPlot::PlotValV(PiMo, "pimo-"+OutFNm, OutFNm, "Number of + IN", "Number of - OUT", gpsLog, false, gpwPoints);
1411    TGnuPlot::PlotValV(PoMi, "pomi-"+OutFNm, OutFNm, "Number of + OUT", "Number of - IN", gpsLog, false, gpwPoints);
1412    TGnuPlot::PlotValV(PoMo, "pomo-"+OutFNm, OutFNm, "Number of + OUT", "Number of - OUT", gpsLog, false, gpwPoints);
1413    TGnuPlot::PlotValV(MiMo, "mimo-"+OutFNm, OutFNm, "Number of - IN", "Number of - OUT", gpsLog, false, gpwPoints);
1414  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-signnet.cpp</div>
                <div class="column column_space"><pre><code>504      if (ECProb == 1.0 && S_uc == 1.0) { continue; }
505      if (!IsLikelihood) {
506        Psi_c += (ECProb / (1.0 - ECProb*S_uc));
507      } else {
508        Psi_c += log(1.0 - ECProb*S_uc);
509      }
</pre></code></div>
                <div class="column column_space"><pre><code>1350      if (n1 == n2 || Net->IsEdge(n1,n2))  { continue; }
1351      if (Sign==1) { Plus++; } else { Minus++; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    