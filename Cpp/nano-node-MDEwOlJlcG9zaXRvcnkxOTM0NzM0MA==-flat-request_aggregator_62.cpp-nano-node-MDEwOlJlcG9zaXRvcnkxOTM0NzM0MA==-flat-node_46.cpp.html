
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-request_aggregator_62.cpp</h3>
            <pre><code>1  #include <nano/lib/stats.hpp>
2  #include <nano/lib/threading.hpp>
3  #include <nano/node/active_transactions.hpp>
4  #include <nano/node/common.hpp>
5  #include <nano/node/network.hpp>
6  #include <nano/node/nodeconfig.hpp>
7  #include <nano/node/request_aggregator.hpp>
8  #include <nano/node/voting.hpp>
9  #include <nano/node/wallet.hpp>
10  #include <nano/secure/ledger.hpp>
11  #include <nano/secure/store.hpp>
12  nano::request_aggregator::request_aggregator (nano::node_config const & config_a, nano::stats & stats_a, nano::vote_generator & generator_a, nano::vote_generator & final_generator_a, nano::local_vote_history & history_a, nano::ledger & ledger_a, nano::wallets & wallets_a, nano::active_transactions & active_a) :
13  	config{ config_a },
14  	max_delay (config_a.network_params.network.is_dev_network () ? 50 : 300),
15  	small_delay (config_a.network_params.network.is_dev_network () ? 10 : 50),
16  	max_channel_requests (config_a.max_queued_requests),
17  	stats (stats_a),
18  	local_votes (history_a),
19  	ledger (ledger_a),
20  	wallets (wallets_a),
21  	active (active_a),
22  	generator (generator_a),
23  	final_generator (final_generator_a),
24  	thread ([this] () { run (); })
25  {
26  	generator.set_reply_action ([this] (std::shared_ptr<nano::vote> const & vote_a, std::shared_ptr<nano::transport::channel> const & channel_a) {
27  		this->reply_action (vote_a, channel_a);
28  	});
29  	final_generator.set_reply_action ([this] (std::shared_ptr<nano::vote> const & vote_a, std::shared_ptr<nano::transport::channel> const & channel_a) {
30  		this->reply_action (vote_a, channel_a);
31  	});
32  	nano::unique_lock<nano::mutex> lock{ mutex };
33  	condition.wait (lock, [&started = started] { return started; });
34  }
35  void nano::request_aggregator::add (std::shared_ptr<nano::transport::channel> const & channel_a, std::vector<std::pair<nano::block_hash, nano::root>> const & hashes_roots_a)
36  {
37  	debug_assert (wallets.reps ().voting > 0);
38  	bool error = true;
39  	auto const endpoint (nano::transport::map_endpoint_to_v6 (channel_a->get_endpoint ()));
40  	nano::unique_lock<nano::mutex> lock{ mutex };
41  	if (requests.empty () || (requests.get<tag_deadline> ().begin ()->deadline + 2 * this->max_delay > std::chrono::steady_clock::now ()))
42  	{
43  		auto & requests_by_endpoint (requests.get<tag_endpoint> ());
44  		auto existing (requests_by_endpoint.find (endpoint));
45  		if (existing == requests_by_endpoint.end ())
46  		{
47  			existing = requests_by_endpoint.emplace (channel_a).first;
48  		}
49  		requests_by_endpoint.modify (existing, [&hashes_roots_a, &channel_a, &error, this] (channel_pool & pool_a) {
50  			pool_a.channel = channel_a;
51  			if (pool_a.hashes_roots.size () + hashes_roots_a.size () <= this->max_channel_requests)
52  			{
53  				error = false;
54  				auto new_deadline (std::min (pool_a.start + this->max_delay, std::chrono::steady_clock::now () + this->small_delay));
55  				pool_a.deadline = new_deadline;
56  				pool_a.hashes_roots.insert (pool_a.hashes_roots.begin (), hashes_roots_a.begin (), hashes_roots_a.end ());
57  			}
58  		});
59  		if (requests.size () == 1)
60  		{
61  			lock.unlock ();
62  			condition.notify_all ();
63  		}
64  	}
65  	stats.inc (nano::stat::type::aggregator, !error ? nano::stat::detail::aggregator_accepted : nano::stat::detail::aggregator_dropped);
66  }
67  void nano::request_aggregator::run ()
68  {
69  	nano::thread_role::set (nano::thread_role::name::request_aggregator);
70  	nano::unique_lock<nano::mutex> lock{ mutex };
71  	started = true;
72  	lock.unlock ();
73  	condition.notify_all ();
74  	lock.lock ();
75  	while (!stopped)
76  	{
77  		if (!requests.empty ())
78  		{
79  			auto & requests_by_deadline (requests.get<tag_deadline> ());
80  			auto front (requests_by_deadline.begin ());
81  			if (front->deadline < std::chrono::steady_clock::now ())
82  			{
83  				decltype (front->channel) channel{};
84  				decltype (front->hashes_roots) hashes_roots{};
85  				requests_by_deadline.modify (front, [&channel, &hashes_roots] (channel_pool & pool) {
86  					channel.swap (pool.channel);
87  					hashes_roots.swap (pool.hashes_roots);
88  				});
89  				requests_by_deadline.erase (front);
90  				lock.unlock ();
91  				erase_duplicates (hashes_roots);
92  				auto const remaining = aggregate (hashes_roots, channel);
93  				if (!remaining.first.empty ())
94  				{
95  					auto const generated = generator.generate (remaining.first, channel);
96  					stats.add (nano::stat::type::requests, nano::stat::detail::requests_cannot_vote, stat::dir::in, remaining.first.size () - generated);
97  				}
98  				if (!remaining.second.empty ())
99  				{
100  					auto const generated = final_generator.generate (remaining.second, channel);
101  					stats.add (nano::stat::type::requests, nano::stat::detail::requests_cannot_vote, stat::dir::in, remaining.second.size () - generated);
102  				}
103  				lock.lock ();
104  			}
105  			else
106  			{
107  				auto deadline = front->deadline;
108  				condition.wait_until (lock, deadline, [this, &deadline] () { return this->stopped || deadline < std::chrono::steady_clock::now (); });
109  			}
110  		}
111  		else
112  		{
113  			condition.wait_for (lock, small_delay, [this] () { return this->stopped || !this->requests.empty (); });
114  		}
115  	}
116  }
117  void nano::request_aggregator::stop ()
118  {
119  	{
120  		nano::lock_guard<nano::mutex> guard{ mutex };
121  		stopped = true;
122  	}
123  	condition.notify_all ();
124  	if (thread.joinable ())
125  	{
126  		thread.join ();
127  	}
128  }
129  std::size_t nano::request_aggregator::size ()
130  {
131  	nano::unique_lock<nano::mutex> lock{ mutex };
132  	return requests.size ();
133  }
134  bool nano::request_aggregator::empty ()
135  {
136  	return size () == 0;
137  }
138  void nano::request_aggregator::reply_action (std::shared_ptr<nano::vote> const & vote_a, std::shared_ptr<nano::transport::channel> const & channel_a) const
139  {
140  	nano::confirm_ack confirm{ config.network_params.network, vote_a };
141  	channel_a->send (confirm);
142  }
143  void nano::request_aggregator::erase_duplicates (std::vector<std::pair<nano::block_hash, nano::root>> & requests_a) const
144  {
145  	std::sort (requests_a.begin (), requests_a.end (), [] (auto const & pair1, auto const & pair2) {
146  		return pair1.first < pair2.first;
147  	});
148  	requests_a.erase (std::unique (requests_a.begin (), requests_a.end (), [] (auto const & pair1, auto const & pair2) {
149  		return pair1.first == pair2.first;
150  	}),
151  	requests_a.end ());
152  }
153  std::pair<std::vector<std::shared_ptr<nano::block>>, std::vector<std::shared_ptr<nano::block>>> nano::request_aggregator::aggregate (std::vector<std::pair<nano::block_hash, nano::root>> const & requests_a, std::shared_ptr<nano::transport::channel> & channel_a) const
154  {
155  	auto transaction (ledger.store.tx_begin_read ());
156  	std::vector<std::shared_ptr<nano::block>> to_generate;
157  	std::vector<std::shared_ptr<nano::block>> to_generate_final;
158  	std::vector<std::shared_ptr<nano::vote>> cached_votes;
159  	std::unordered_set<nano::block_hash> cached_hashes;
160  	for (auto const & [hash, root] : requests_a)
161  	{
162  		if (cached_hashes.count (hash) > 0)
163  		{
164  			continue;
165  		}
166  		auto find_votes (local_votes.votes (root, hash));
167  		if (!find_votes.empty ())
168  		{
169  			for (auto & found_vote : find_votes)
170  			{
171  				cached_votes.push_back (found_vote);
172  				for (auto & found_hash : found_vote->hashes)
173  				{
174  					cached_hashes.insert (found_hash);
175  				}
176  			}
177  		}
178  		else
179  		{
180  			bool generate_vote (true);
181  			bool generate_final_vote (false);
182  			std::shared_ptr<nano::block> block;
183  			auto final_vote_hashes (ledger.store.final_vote.get (transaction, root));
184  			if (!final_vote_hashes.empty ())
185  			{
186  				generate_final_vote = true;
187  				block = ledger.store.block.get (transaction, final_vote_hashes[0]);
188  				if (block != nullptr && final_vote_hashes.size () > 1)
189  				{
190  					to_generate_final.push_back (block);
191  					block = ledger.store.block.get (transaction, final_vote_hashes[1]);
192  					debug_assert (final_vote_hashes.size () == 2);
193  				}
194  			}
195  			if (block == nullptr)
196  			{
197  				block = active.winner (hash);
198  			}
199  			if (block == nullptr)
200  			{
201  				block = ledger.store.block.get (transaction, hash);
202  				if (block != nullptr)
203  				{
204  					nano::confirmation_height_info confirmation_height_info;
205  					ledger.store.confirmation_height.get (transaction, block->account ().is_zero () ? block->sideband ().account : block->account (), confirmation_height_info);
206  					generate_final_vote = (confirmation_height_info.height >= block->sideband ().height);
207  				}
208  			}
209  			if (block == nullptr && !root.is_zero ())
210  			{
211  				auto successor (ledger.store.block.successor (transaction, root.as_block_hash ()));
212  				if (successor.is_zero ())
213  				{
214  					auto info = ledger.account_info (transaction, root.as_account ());
215  					if (info)
216  					{
217  						successor = info->open_block;
218  					}
219  				}
220  				if (!successor.is_zero ())
221  				{
222  					auto successor_block = ledger.store.block.get (transaction, successor);
223  					debug_assert (successor_block != nullptr);
224  					block = std::move (successor_block);
225  					auto find_successor_votes (local_votes.votes (root, successor));
226  					if (!find_successor_votes.empty ())
227  					{
228  						cached_votes.insert (cached_votes.end (), find_successor_votes.begin (), find_successor_votes.end ());
229  						generate_vote = false;
230  					}
231  					if (block != nullptr && generate_vote)
232  					{
233  						nano::confirmation_height_info confirmation_height_info;
234  						ledger.store.confirmation_height.get (transaction, block->account ().is_zero () ? block->sideband ().account : block->account (), confirmation_height_info);
235  						generate_final_vote = (confirmation_height_info.height >= block->sideband ().height);
236  					}
237  				}
238  			}
239  			if (block)
240  			{
241  				if (generate_vote)
242  				{
243  					if (generate_final_vote)
244  					{
245  						to_generate_final.push_back (block);
246  					}
247  					else
248  					{
249  						to_generate.push_back (block);
250  					}
251  				}
252  				if (block->hash () != hash)
253  				{
254  					nano::publish publish (config.network_params.network, block);
255  					channel_a->send (publish);
256  				}
257  			}
258  			else
259  			{
260  				stats.inc (nano::stat::type::requests, nano::stat::detail::requests_unknown, stat::dir::in);
261  			}
262  		}
263  	}
264  	std::sort (cached_votes.begin (), cached_votes.end ());
265  	cached_votes.erase (std::unique (cached_votes.begin (), cached_votes.end ()), cached_votes.end ());
266  	for (auto const & vote : cached_votes)
267  	{
268  		reply_action (vote, channel_a);
269  	}
270  	stats.add (nano::stat::type::requests, nano::stat::detail::requests_cached_hashes, stat::dir::in, cached_hashes.size ());
271  	stats.add (nano::stat::type::requests, nano::stat::detail::requests_cached_votes, stat::dir::in, cached_votes.size ());
272  	return std::make_pair (to_generate, to_generate_final);
273  }
274  std::unique_ptr<nano::container_info_component> nano::collect_container_info (nano::request_aggregator & aggregator, std::string const & name)
275  {
276  	auto pools_count = aggregator.size ();
277  	auto sizeof_element = sizeof (decltype (aggregator.requests)::value_type);
278  	auto composite = std::make_unique<container_info_composite> (name);
<span onclick='openModal()' class='match'>279  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "pools", pools_count, sizeof_element }));
280  	return composite;
</span>281  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_46.cpp</h3>
            <pre><code>1  #include <nano/lib/threading.hpp>
2  #include <nano/lib/tomlconfig.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <nano/node/common.hpp>
5  #include <nano/node/daemonconfig.hpp>
6  #include <nano/node/node.hpp>
7  #include <nano/node/rocksdb/rocksdb.hpp>
8  #include <nano/node/scheduler/buckets.hpp>
9  #include <nano/node/scheduler/component.hpp>
10  #include <nano/node/scheduler/hinted.hpp>
11  #include <nano/node/scheduler/optimistic.hpp>
12  #include <nano/node/telemetry.hpp>
13  #include <nano/node/websocket.hpp>
14  #include <nano/secure/buffer.hpp>
15  #include <boost/filesystem.hpp>
16  #include <boost/property_tree/json_parser.hpp>
17  #include <algorithm>
18  #include <cstdlib>
19  #include <fstream>
20  #include <future>
21  #include <sstream>
22  double constexpr nano::node::price_max;
23  double constexpr nano::node::free_cutoff;
24  namespace nano
25  {
26  extern unsigned char nano_bootstrap_weights_live[];
27  extern std::size_t nano_bootstrap_weights_live_size;
28  extern unsigned char nano_bootstrap_weights_beta[];
29  extern std::size_t nano_bootstrap_weights_beta_size;
30  }
31  nano::backlog_population::config nano::backlog_population_config (const nano::node_config & config)
32  {
33  	nano::backlog_population::config cfg{};
34  	cfg.enabled = config.frontiers_confirmation != nano::frontiers_confirmation_mode::disabled;
35  	cfg.frequency = config.backlog_scan_frequency;
36  	cfg.batch_size = config.backlog_scan_batch_size;
37  	return cfg;
38  }
39  nano::vote_cache::config nano::nodeconfig_to_vote_cache_config (node_config const & config, node_flags const & flags)
40  {
41  	vote_cache::config cfg{};
42  	cfg.max_size = flags.inactive_votes_cache_size;
43  	return cfg;
44  }
45  nano::outbound_bandwidth_limiter::config nano::outbound_bandwidth_limiter_config (const nano::node_config & config)
46  {
47  	outbound_bandwidth_limiter::config cfg{};
48  	cfg.standard_limit = config.bandwidth_limit;
49  	cfg.standard_burst_ratio = config.bandwidth_limit_burst_ratio;
50  	cfg.bootstrap_limit = config.bootstrap_bandwidth_limit;
51  	cfg.bootstrap_burst_ratio = config.bootstrap_bandwidth_burst_ratio;
52  	return cfg;
53  }
54  void nano::node::keepalive (std::string const & address_a, uint16_t port_a)
55  {
56  	auto node_l (shared_from_this ());
57  	network.resolver.async_resolve (boost::asio::ip::udp::resolver::query (address_a, std::to_string (port_a)), [node_l, address_a, port_a] (boost::system::error_code const & ec, boost::asio::ip::udp::resolver::iterator i_a) {
58  		if (!ec)
59  		{
60  			for (auto i (i_a), n (boost::asio::ip::udp::resolver::iterator{}); i != n; ++i)
61  			{
62  				auto endpoint (nano::transport::map_endpoint_to_v6 (i->endpoint ()));
63  				std::weak_ptr<nano::node> node_w (node_l);
64  				auto channel (node_l->network.find_channel (endpoint));
65  				if (!channel)
66  				{
67  					node_l->network.tcp_channels.start_tcp (endpoint);
68  				}
69  				else
70  				{
71  					node_l->network.send_keepalive (channel);
72  				}
73  			}
74  		}
75  		else
76  		{
77  			node_l->logger.try_log (boost::str (boost::format ("Error resolving address: %1%:%2%: %3%") % address_a % port_a % ec.message ()));
78  		}
79  	});
80  }
81  std::unique_ptr<nano::container_info_component> nano::collect_container_info (rep_crawler & rep_crawler, std::string const & name)
82  {
83  	std::size_t count;
84  	{
85  		nano::lock_guard<nano::mutex> guard{ rep_crawler.active_mutex };
86  		count = rep_crawler.active.size ();
87  	}
88  	auto const sizeof_element = sizeof (decltype (rep_crawler.active)::value_type);
89  	auto composite = std::make_unique<container_info_composite> (name);
<span onclick='openModal()' class='match'>90  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "active", count, sizeof_element }));
91  	return composite;
</span>92  }
93  nano::keypair nano::load_or_create_node_id (boost::filesystem::path const & application_path, nano::logger_mt & logger)
94  {
95  	auto node_private_key_path = application_path / "node_id_private.key";
96  	std::ifstream ifs (node_private_key_path.c_str ());
97  	if (ifs.good ())
98  	{
99  		logger.always_log (boost::str (boost::format ("%1% exists, reading node id from it") % node_private_key_path.string ()));
100  		std::string node_private_key;
101  		ifs >> node_private_key;
102  		release_assert (node_private_key.size () == 64);
103  		nano::keypair kp = nano::keypair (node_private_key);
104  		return kp;
105  	}
106  	else
107  	{
108  		logger.always_log (boost::str (boost::format ("%1% does not exist, creating a new node_id") % node_private_key_path.string ()));
109  		nano::keypair kp;
110  		std::ofstream ofs (node_private_key_path.c_str (), std::ofstream::out | std::ofstream::trunc);
111  		ofs << kp.prv.to_string () << std::endl
112  			<< std::flush;
113  		ofs.close ();
114  		release_assert (!ofs.fail ());
115  		return kp;
116  	}
117  }
118  nano::node::node (boost::asio::io_context & io_ctx_a, uint16_t peering_port_a, boost::filesystem::path const & application_path_a, nano::logging const & logging_a, nano::work_pool & work_a, nano::node_flags flags_a, unsigned seq) :
119  	node (io_ctx_a, application_path_a, nano::node_config (peering_port_a, logging_a), work_a, flags_a, seq)
120  {
121  }
122  nano::node::node (boost::asio::io_context & io_ctx_a, boost::filesystem::path const & application_path_a, nano::node_config const & config_a, nano::work_pool & work_a, nano::node_flags flags_a, unsigned seq) :
123  	write_database_queue (!flags_a.force_use_write_database_queue && (config_a.rocksdb_config.enable)),
124  	io_ctx (io_ctx_a),
125  	node_initialized_latch (1),
126  	config (config_a),
127  	network_params{ config.network_params },
128  	stats (config.stats_config),
129  	workers{ config.background_threads, nano::thread_role::name::worker },
130  	bootstrap_workers{ config.bootstrap_serving_threads, nano::thread_role::name::bootstrap_worker },
131  	flags (flags_a),
132  	work (work_a),
133  	distributed_work (*this),
134  	logger (config_a.logging.min_time_between_log_output),
135  	store_impl (nano::make_store (logger, application_path_a, network_params.ledger, flags.read_only, true, config_a.rocksdb_config, config_a.diagnostics_config.txn_tracking, config_a.block_processor_batch_max_time, config_a.lmdb_config, config_a.backup_before_upgrade)),
136  	store (*store_impl),
137  	unchecked{ stats, flags.disable_block_processor_unchecked_deletion },
138  	wallets_store_impl (std::make_unique<nano::mdb_wallets_store> (application_path_a / "wallets.ldb", config_a.lmdb_config)),
139  	wallets_store (*wallets_store_impl),
140  	gap_cache (*this),
141  	ledger (store, stats, network_params.ledger, flags_a.generate_cache),
142  	checker (config.signature_checker_threads),
143  	outbound_limiter{ outbound_bandwidth_limiter_config (config) },
144  	network (*this, config.peering_port.has_value () ? *config.peering_port : 0),
145  	telemetry{ nano::telemetry::config{ config, flags }, *this, network, observers, network_params, stats },
146  	bootstrap_initiator (*this),
147  	bootstrap_server{ store, ledger, network_params.network, stats },
148  	tcp_listener (network.port, *this),
149  	application_path (application_path_a),
150  	port_mapping (*this),
151  	rep_crawler (*this),
152  	vote_processor (checker, active, observers, stats, config, flags, logger, online_reps, rep_crawler, ledger, network_params),
153  	warmed_up (0),
154  	block_processor (*this, write_database_queue),
155  	online_reps (ledger, config),
156  	history{ config.network_params.voting },
157  	vote_uniquer (block_uniquer),
158  	confirmation_height_processor (ledger, write_database_queue, config.conf_height_processor_batch_min_time, config.logging, logger, node_initialized_latch, flags.confirmation_height_processor_mode),
159  	inactive_vote_cache{ nano::nodeconfig_to_vote_cache_config (config, flags) },
160  	generator{ config, ledger, wallets, vote_processor, history, network, stats, &bsol;* non-final */ false },
161  	final_generator{ config, ledger, wallets, vote_processor, history, network, stats, &bsol;* final */ true },
162  	active (*this, confirmation_height_processor),
163  	scheduler_impl{ std::make_unique<nano::scheduler::component> (*this) },
164  	scheduler{ *scheduler_impl },
165  	aggregator (config, stats, generator, final_generator, history, ledger, wallets, active),
166  	wallets (wallets_store.init_error (), *this),
167  	backlog{ nano::backlog_population_config (config), store, stats },
168  	ascendboot{ config, block_processor, ledger, network, stats },
169  	websocket{ config.websocket_config, observers, wallets, ledger, io_ctx, logger },
170  	epoch_upgrader{ *this, ledger, store, network_params, logger },
171  	startup_time (std::chrono::steady_clock::now ()),
172  	node_seq (seq),
173  	block_broadcast{ network, block_arrival, !flags.disable_block_processor_republishing },
174  	block_publisher{ active },
175  	gap_tracker{ gap_cache },
176  	process_live_dispatcher{ ledger, scheduler.buckets, inactive_vote_cache, websocket }
177  {
178  	block_broadcast.connect (block_processor);
179  	block_publisher.connect (block_processor);
180  	gap_tracker.connect (block_processor);
181  	process_live_dispatcher.connect (block_processor);
182  	unchecked.satisfied.add ([this] (nano::unchecked_info const & info) {
183  		this->block_processor.add (info.block);
184  	});
185  	inactive_vote_cache.rep_weight_query = [this] (nano::account const & rep) {
186  		return ledger.weight (rep);
187  	};
188  	backlog.activate_callback.add ([this] (nano::transaction const & transaction, nano::account const & account, nano::account_info const & account_info, nano::confirmation_height_info const & conf_info) {
189  		scheduler.buckets.activate (account, transaction);
190  		scheduler.optimistic.activate (account, account_info, conf_info);
191  	});
192  	if (!init_error ())
193  	{
194  		active.vacancy_update = [this] () {
195  			scheduler.buckets.notify ();
196  			scheduler.hinted.notify ();
197  			scheduler.optimistic.notify ();
198  		};
199  		wallets.observer = [this] (bool active) {
200  			observers.wallet.notify (active);
201  		};
202  		network.channel_observer = [this] (std::shared_ptr<nano::transport::channel> const & channel_a) {
203  			debug_assert (channel_a != nullptr);
204  			observers.endpoint.notify (channel_a);
205  		};
206  		network.disconnect_observer = [this] () {
207  			observers.disconnect.notify ();
208  		};
209  		if (!config.callback_address.empty ())
210  		{
211  			observers.blocks.add ([this] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const & votes_a, nano::account const & account_a, nano::amount const & amount_a, bool is_state_send_a, bool is_state_epoch_a) {
212  				auto block_a (status_a.winner);
213  				if ((status_a.type == nano::election_status_type::active_confirmed_quorum || status_a.type == nano::election_status_type::active_confirmation_height) && this->block_arrival.recent (block_a->hash ()))
214  				{
215  					auto node_l (shared_from_this ());
216  					background ([node_l, block_a, account_a, amount_a, is_state_send_a, is_state_epoch_a] () {
217  						boost::property_tree::ptree event;
218  						event.add ("account", account_a.to_account ());
219  						event.add ("hash", block_a->hash ().to_string ());
220  						std::string block_text;
221  						block_a->serialize_json (block_text);
222  						event.add ("block", block_text);
223  						event.add ("amount", amount_a.to_string_dec ());
224  						if (is_state_send_a)
225  						{
226  							event.add ("is_send", is_state_send_a);
227  							event.add ("subtype", "send");
228  						}
229  						else if (block_a->type () == nano::block_type::state)
230  						{
231  							if (block_a->link ().is_zero ())
232  							{
233  								event.add ("subtype", "change");
234  							}
235  							else if (is_state_epoch_a)
236  							{
237  								debug_assert (amount_a == 0 && node_l->ledger.is_epoch_link (block_a->link ()));
238  								event.add ("subtype", "epoch");
239  							}
240  							else
241  							{
242  								event.add ("subtype", "receive");
243  							}
244  						}
245  						std::stringstream ostream;
246  						boost::property_tree::write_json (ostream, event);
247  						ostream.flush ();
248  						auto body (std::make_shared<std::string> (ostream.str ()));
249  						auto address (node_l->config.callback_address);
250  						auto port (node_l->config.callback_port);
251  						auto target (std::make_shared<std::string> (node_l->config.callback_target));
252  						auto resolver (std::make_shared<boost::asio::ip::tcp::resolver> (node_l->io_ctx));
253  						resolver->async_resolve (boost::asio::ip::tcp::resolver::query (address, std::to_string (port)), [node_l, address, port, target, body, resolver] (boost::system::error_code const & ec, boost::asio::ip::tcp::resolver::iterator i_a) {
254  							if (!ec)
255  							{
256  								node_l->do_rpc_callback (i_a, address, port, target, body, resolver);
257  							}
258  							else
259  							{
260  								if (node_l->config.logging.callback_logging ())
261  								{
262  									node_l->logger.always_log (boost::str (boost::format ("Error resolving callback: %1%:%2%: %3%") % address % port % ec.message ()));
263  								}
264  								node_l->stats.inc (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out);
265  							}
266  						});
267  					});
268  				}
269  			});
270  		}
271  		observers.blocks.add ([this] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const & votes_a, nano::account const & account_a, nano::amount const & amount_a, bool is_state_send_a, bool is_state_epoch_a) {
272  			debug_assert (status_a.type != nano::election_status_type::ongoing);
273  			switch (status_a.type)
274  			{
275  				case nano::election_status_type::active_confirmed_quorum:
276  					this->stats.inc (nano::stat::type::confirmation_observer, nano::stat::detail::active_quorum, nano::stat::dir::out);
277  					break;
278  				case nano::election_status_type::active_confirmation_height:
279  					this->stats.inc (nano::stat::type::confirmation_observer, nano::stat::detail::active_conf_height, nano::stat::dir::out);
280  					break;
281  				case nano::election_status_type::inactive_confirmation_height:
282  					this->stats.inc (nano::stat::type::confirmation_observer, nano::stat::detail::inactive_conf_height, nano::stat::dir::out);
283  					break;
284  				default:
285  					break;
286  			}
287  		});
288  		observers.endpoint.add ([this] (std::shared_ptr<nano::transport::channel> const & channel_a) {
289  			this->network.send_keepalive_self (channel_a);
290  		});
291  		observers.vote.add ([this] (std::shared_ptr<nano::vote> vote_a, std::shared_ptr<nano::transport::channel> const & channel_a, nano::vote_code code_a) {
292  			debug_assert (code_a != nano::vote_code::invalid);
293  			if (code_a == nano::vote_code::indeterminate)
294  			{
295  				auto active_in_rep_crawler (!this->rep_crawler.response (channel_a, vote_a));
296  				if (active_in_rep_crawler)
297  				{
298  					this->online_reps.observe (vote_a->account);
299  				}
300  				this->gap_cache.vote (vote_a);
301  			}
302  		});
303  		observers.work_cancel.add ([this] (nano::root const & root_a) {
304  			this->work.cancel (root_a);
305  			this->distributed_work.cancel (root_a);
306  		});
307  		logger.always_log ("Node starting, version: ", NANO_VERSION_STRING);
308  		logger.always_log ("Build information: ", BUILD_INFO);
309  		logger.always_log ("Database backend: ", store.vendor_get ());
310  		auto const network_label = network_params.network.get_current_network_as_string ();
311  		logger.always_log ("Active network: ", network_label);
312  		logger.always_log (boost::str (boost::format ("Work pool running %1% threads %2%") % work.threads.size () % (work.opencl ? "(1 for OpenCL)" : "")));
313  		logger.always_log (boost::str (boost::format ("%1% work peers configured") % config.work_peers.size ()));
314  		if (!work_generation_enabled ())
315  		{
316  			logger.always_log ("Work generation is disabled");
317  		}
318  		if (config.logging.node_lifetime_tracing ())
319  		{
320  			logger.always_log ("Constructing node");
321  		}
322  		logger.always_log (boost::str (boost::format ("Outbound Voting Bandwidth limited to %1% bytes per second, burst ratio %2%") % config.bandwidth_limit % config.bandwidth_limit_burst_ratio));
323  		auto is_initialized (false);
324  		{
325  			auto const transaction (store.tx_begin_read ());
326  			is_initialized = (store.account.begin (transaction) != store.account.end ());
327  		}
328  		if (!is_initialized && !flags.read_only)
329  		{
330  			auto const transaction (store.tx_begin_write ({ tables::accounts, tables::blocks, tables::confirmation_height, tables::frontiers }));
331  			store.initialize (transaction, ledger.cache, ledger.constants);
332  		}
333  		if (!ledger.block_or_pruned_exists (config.network_params.ledger.genesis->hash ()))
334  		{
335  			std::stringstream ss;
336  			ss << "Genesis block not found. This commonly indicates a configuration issue, check that the --network or --data_path command line arguments are correct, "
337  				  "and also the ledger backend node config option. If using a read-only CLI command a ledger must already exist, start the node with --daemon first.";
338  			if (network_params.network.is_beta_network ())
339  			{
340  				ss << " Beta network may have reset, try clearing database files";
341  			}
342  			auto const str = ss.str ();
343  			logger.always_log (str);
344  			std::cerr << str << std::endl;
345  			std::exit (1);
346  		}
347  		if (config.enable_voting)
348  		{
349  			std::ostringstream stream;
350  			stream << "Voting is enabled, more system resources will be used";
351  			auto voting (wallets.reps ().voting);
352  			if (voting > 0)
353  			{
354  				stream << ". " << voting << " representative(s) are configured";
355  				if (voting > 1)
356  				{
357  					stream << ". Voting with more than one representative can limit performance";
358  				}
359  			}
360  			logger.always_log (stream.str ());
361  		}
362  		node_id = nano::load_or_create_node_id (application_path, logger);
363  		logger.always_log ("Node ID: ", node_id.pub.to_node_id ());
364  		if ((network_params.network.is_live_network () || network_params.network.is_beta_network ()) && !flags.inactive_node)
365  		{
366  			auto const bootstrap_weights = get_bootstrap_weights ();
367  			const bool use_bootstrap_weight = ledger.cache.block_count < bootstrap_weights.first;
368  			if (use_bootstrap_weight)
369  			{
370  				ledger.bootstrap_weights = bootstrap_weights.second;
371  				for (auto const & rep : ledger.bootstrap_weights)
372  				{
373  					logger.always_log ("Using bootstrap rep weight: ", rep.first.to_account (), " -> ", nano::uint128_union (rep.second).format_balance (Mxrb_ratio, 0, true), " XRB");
374  				}
375  			}
376  			ledger.bootstrap_weight_max_blocks = bootstrap_weights.first;
377  			if (!flags.disable_unchecked_drop && !use_bootstrap_weight && !flags.read_only)
378  			{
379  				unchecked.clear ();
380  				logger.always_log ("Dropping unchecked blocks");
381  			}
382  		}
383  		ledger.pruning = flags.enable_pruning || store.pruned.count (store.tx_begin_read ()) > 0;
384  		if (ledger.pruning)
385  		{
386  			if (config.enable_voting && !flags.inactive_node)
387  			{
388  				std::string str = "Incompatibility detected between config node.enable_voting and existing pruned blocks";
389  				logger.always_log (str);
390  				std::cerr << str << std::endl;
391  				std::exit (1);
392  			}
393  			else if (!flags.enable_pruning && !flags.inactive_node)
394  			{
395  				std::string str = "To start node with existing pruned blocks use launch flag --enable_pruning";
396  				logger.always_log (str);
397  				std::cerr << str << std::endl;
398  				std::exit (1);
399  			}
400  		}
401  	}
402  	node_initialized_latch.count_down ();
403  }
404  nano::node::~node ()
405  {
406  	if (config.logging.node_lifetime_tracing ())
407  	{
408  		logger.always_log ("Destructing node");
409  	}
410  	stop ();
411  }
412  void nano::node::do_rpc_callback (boost::asio::ip::tcp::resolver::iterator i_a, std::string const & address, uint16_t port, std::shared_ptr<std::string> const & target, std::shared_ptr<std::string> const & body, std::shared_ptr<boost::asio::ip::tcp::resolver> const & resolver)
413  {
414  	if (i_a != boost::asio::ip::tcp::resolver::iterator{})
415  	{
416  		auto node_l (shared_from_this ());
417  		auto sock (std::make_shared<boost::asio::ip::tcp::socket> (node_l->io_ctx));
418  		sock->async_connect (i_a->endpoint (), [node_l, target, body, sock, address, port, i_a, resolver] (boost::system::error_code const & ec) mutable {
419  			if (!ec)
420  			{
421  				auto req (std::make_shared<boost::beast::http::request<boost::beast::http::string_body>> ());
422  				req->method (boost::beast::http::verb::post);
423  				req->target (*target);
424  				req->version (11);
425  				req->insert (boost::beast::http::field::host, address);
426  				req->insert (boost::beast::http::field::content_type, "application/json");
427  				req->body () = *body;
428  				req->prepare_payload ();
429  				boost::beast::http::async_write (*sock, *req, [node_l, sock, address, port, req, i_a, target, body, resolver] (boost::system::error_code const & ec, std::size_t bytes_transferred) mutable {
430  					if (!ec)
431  					{
432  						auto sb (std::make_shared<boost::beast::flat_buffer> ());
433  						auto resp (std::make_shared<boost::beast::http::response<boost::beast::http::string_body>> ());
434  						boost::beast::http::async_read (*sock, *sb, *resp, [node_l, sb, resp, sock, address, port, i_a, target, body, resolver] (boost::system::error_code const & ec, std::size_t bytes_transferred) mutable {
435  							if (!ec)
436  							{
437  								if (boost::beast::http::to_status_class (resp->result ()) == boost::beast::http::status_class::successful)
438  								{
439  									node_l->stats.inc (nano::stat::type::http_callback, nano::stat::detail::initiate, nano::stat::dir::out);
440  								}
441  								else
442  								{
443  									if (node_l->config.logging.callback_logging ())
444  									{
445  										node_l->logger.try_log (boost::str (boost::format ("Callback to %1%:%2% failed with status: %3%") % address % port % resp->result ()));
446  									}
447  									node_l->stats.inc (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out);
448  								}
449  							}
450  							else
451  							{
452  								if (node_l->config.logging.callback_logging ())
453  								{
454  									node_l->logger.try_log (boost::str (boost::format ("Unable complete callback: %1%:%2%: %3%") % address % port % ec.message ()));
455  								}
456  								node_l->stats.inc (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out);
457  							};
458  						});
459  					}
460  					else
461  					{
462  						if (node_l->config.logging.callback_logging ())
463  						{
464  							node_l->logger.try_log (boost::str (boost::format ("Unable to send callback: %1%:%2%: %3%") % address % port % ec.message ()));
465  						}
466  						node_l->stats.inc (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out);
467  					}
468  				});
469  			}
470  			else
471  			{
472  				if (node_l->config.logging.callback_logging ())
473  				{
474  					node_l->logger.try_log (boost::str (boost::format ("Unable to connect to callback address: %1%:%2%: %3%") % address % port % ec.message ()));
475  				}
476  				node_l->stats.inc (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out);
477  				++i_a;
478  				node_l->do_rpc_callback (i_a, address, port, target, body, resolver);
479  			}
480  		});
481  	}
482  }
483  bool nano::node::copy_with_compaction (boost::filesystem::path const & destination)
484  {
485  	return store.copy_db (destination);
486  }
487  std::unique_ptr<nano::container_info_component> nano::collect_container_info (node & node, std::string const & name)
488  {
489  	auto composite = std::make_unique<container_info_composite> (name);
490  	composite->add_component (collect_container_info (node.work, "work"));
491  	composite->add_component (collect_container_info (node.gap_cache, "gap_cache"));
492  	composite->add_component (collect_container_info (node.ledger, "ledger"));
493  	composite->add_component (collect_container_info (node.active, "active"));
494  	composite->add_component (collect_container_info (node.bootstrap_initiator, "bootstrap_initiator"));
495  	composite->add_component (collect_container_info (node.tcp_listener, "tcp_listener"));
496  	composite->add_component (collect_container_info (node.network, "network"));
497  	composite->add_component (node.telemetry.collect_container_info ("telemetry"));
498  	composite->add_component (collect_container_info (node.workers, "workers"));
499  	composite->add_component (collect_container_info (node.observers, "observers"));
500  	composite->add_component (collect_container_info (node.wallets, "wallets"));
501  	composite->add_component (collect_container_info (node.vote_processor, "vote_processor"));
502  	composite->add_component (collect_container_info (node.rep_crawler, "rep_crawler"));
503  	composite->add_component (collect_container_info (node.block_processor, "block_processor"));
504  	composite->add_component (collect_container_info (node.block_arrival, "block_arrival"));
505  	composite->add_component (collect_container_info (node.online_reps, "online_reps"));
506  	composite->add_component (collect_container_info (node.history, "history"));
507  	composite->add_component (collect_container_info (node.block_uniquer, "block_uniquer"));
508  	composite->add_component (collect_container_info (node.vote_uniquer, "vote_uniquer"));
509  	composite->add_component (collect_container_info (node.confirmation_height_processor, "confirmation_height_processor"));
510  	composite->add_component (collect_container_info (node.distributed_work, "distributed_work"));
511  	composite->add_component (collect_container_info (node.aggregator, "request_aggregator"));
512  	composite->add_component (node.scheduler.buckets.collect_container_info ("election_scheduler"));
513  	composite->add_component (node.inactive_vote_cache.collect_container_info ("inactive_vote_cache"));
514  	composite->add_component (collect_container_info (node.generator, "vote_generator"));
515  	composite->add_component (collect_container_info (node.final_generator, "vote_generator_final"));
516  	composite->add_component (node.ascendboot.collect_container_info ("bootstrap_ascending"));
517  	composite->add_component (node.unchecked.collect_container_info ("unchecked"));
518  	return composite;
519  }
520  void nano::node::process_active (std::shared_ptr<nano::block> const & incoming)
521  {
522  	block_arrival.add (incoming->hash ());
523  	block_processor.add (incoming);
524  }
525  [[nodiscard]] nano::process_return nano::node::process (nano::write_transaction const & transaction, nano::block & block)
526  {
527  	return ledger.process (transaction, block);
528  }
529  nano::process_return nano::node::process (nano::block & block)
530  {
531  	auto const transaction = store.tx_begin_write ({ tables::accounts, tables::blocks, tables::frontiers, tables::pending });
532  	return process (transaction, block);
533  }
534  std::optional<nano::process_return> nano::node::process_local (std::shared_ptr<nano::block> const & block_a)
535  {
536  	block_arrival.add (block_a->hash ());
537  	block_broadcast.set_local (block_a);
538  	return block_processor.add_blocking (block_a);
539  }
540  void nano::node::process_local_async (std::shared_ptr<nano::block> const & block_a)
541  {
542  	block_arrival.add (block_a->hash ());
543  	block_processor.add (block_a);
544  }
545  void nano::node::start ()
546  {
547  	long_inactivity_cleanup ();
548  	network.start ();
549  	add_initial_peers ();
550  	if (!flags.disable_legacy_bootstrap && !flags.disable_ongoing_bootstrap)
551  	{
552  		ongoing_bootstrap ();
553  	}
554  	if (!flags.disable_unchecked_cleanup)
555  	{
556  		auto this_l (shared ());
557  		workers.push_task ([this_l] () {
558  			this_l->ongoing_unchecked_cleanup ();
559  		});
560  	}
561  	if (flags.enable_pruning)
562  	{
563  		auto this_l (shared ());
564  		workers.push_task ([this_l] () {
565  			this_l->ongoing_ledger_pruning ();
566  		});
567  	}
568  	if (!flags.disable_rep_crawler)
569  	{
570  		rep_crawler.start ();
571  	}
572  	ongoing_rep_calculation ();
573  	ongoing_peer_store ();
574  	ongoing_online_weight_calculation_queue ();
575  	bool tcp_enabled = false;
576  	if (config.tcp_incoming_connections_max > 0 && !(flags.disable_bootstrap_listener && flags.disable_tcp_realtime))
577  	{
578  		tcp_listener.start ();
579  		tcp_enabled = true;
580  		if (network.port != tcp_listener.port)
581  		{
582  			network.port = tcp_listener.port;
583  		}
584  		logger.always_log (boost::str (boost::format ("Node started with peering port `%1%`.") % network.port));
585  	}
586  	if (!flags.disable_backup)
587  	{
588  		backup_wallet ();
589  	}
590  	if (!flags.disable_search_pending)
591  	{
592  		search_receivable_all ();
593  	}
594  	if (!flags.disable_wallet_bootstrap)
595  	{
596  		auto this_l (shared ());
597  		workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::minutes (1), [this_l] () {
598  			this_l->bootstrap_wallet ();
599  		});
600  	}
601  	if (config.external_address == boost::asio::ip::address_v6::any ().to_string () && tcp_enabled)
602  	{
603  		port_mapping.start ();
604  	}
605  	wallets.start ();
606  	active.start ();
607  	generator.start ();
608  	final_generator.start ();
609  	scheduler.optimistic.start ();
610  	scheduler.buckets.start ();
611  	backlog.start ();
612  	scheduler.hinted.start ();
613  	bootstrap_server.start ();
614  	if (!flags.disable_ascending_bootstrap)
615  	{
616  		ascendboot.start ();
617  	}
618  	websocket.start ();
619  	telemetry.start ();
620  }
621  void nano::node::stop ()
622  {
623  	if (stopped.exchange (true))
624  	{
625  		return;
626  	}
627  	logger.always_log ("Node stopping");
628  	distributed_work.stop ();
629  	backlog.stop ();
630  	if (!flags.disable_ascending_bootstrap)
631  	{
632  		ascendboot.stop ();
633  	}
634  	unchecked.stop ();
635  	block_processor.stop ();
636  	aggregator.stop ();
637  	vote_processor.stop ();
638  	scheduler.buckets.stop ();
639  	scheduler.optimistic.stop ();
640  	scheduler.hinted.stop ();
641  	active.stop ();
642  	generator.stop ();
643  	final_generator.stop ();
644  	confirmation_height_processor.stop ();
645  	network.stop ();
646  	telemetry.stop ();
647  	websocket.stop ();
648  	bootstrap_server.stop ();
649  	bootstrap_initiator.stop ();
650  	tcp_listener.stop ();
651  	port_mapping.stop ();
652  	checker.stop ();
653  	wallets.stop ();
654  	stats.stop ();
655  	epoch_upgrader.stop ();
656  	workers.stop ();
657  }
658  void nano::node::keepalive_preconfigured (std::vector<std::string> const & peers_a)
659  {
660  	for (auto i (peers_a.begin ()), n (peers_a.end ()); i != n; ++i)
661  	{
662  		keepalive (*i, network_params.network.default_node_port);
663  	}
664  }
665  nano::block_hash nano::node::latest (nano::account const & account_a)
666  {
667  	auto const transaction (store.tx_begin_read ());
668  	return ledger.latest (transaction, account_a);
669  }
670  nano::uint128_t nano::node::balance (nano::account const & account_a)
671  {
672  	auto const transaction (store.tx_begin_read ());
673  	return ledger.account_balance (transaction, account_a);
674  }
675  std::shared_ptr<nano::block> nano::node::block (nano::block_hash const & hash_a)
676  {
677  	auto const transaction (store.tx_begin_read ());
678  	return store.block.get (transaction, hash_a);
679  }
680  std::pair<nano::uint128_t, nano::uint128_t> nano::node::balance_pending (nano::account const & account_a, bool only_confirmed_a)
681  {
682  	std::pair<nano::uint128_t, nano::uint128_t> result;
683  	auto const transaction (store.tx_begin_read ());
684  	result.first = ledger.account_balance (transaction, account_a, only_confirmed_a);
685  	result.second = ledger.account_receivable (transaction, account_a, only_confirmed_a);
686  	return result;
687  }
688  nano::uint128_t nano::node::weight (nano::account const & account_a)
689  {
690  	return ledger.weight (account_a);
691  }
692  nano::block_hash nano::node::rep_block (nano::account const & account_a)
693  {
694  	auto const transaction (store.tx_begin_read ());
695  	nano::block_hash result (0);
696  	auto info = ledger.account_info (transaction, account_a);
697  	if (info)
698  	{
699  		result = ledger.representative (transaction, info->head);
700  	}
701  	return result;
702  }
703  nano::uint128_t nano::node::minimum_principal_weight ()
704  {
705  	return online_reps.trended () / network_params.network.principal_weight_factor;
706  }
707  void nano::node::long_inactivity_cleanup ()
708  {
709  	bool perform_cleanup = false;
710  	auto const transaction (store.tx_begin_write ({ tables::online_weight, tables::peers }));
711  	if (store.online_weight.count (transaction) > 0)
712  	{
713  		auto sample (store.online_weight.rbegin (transaction));
714  		auto n (store.online_weight.end ());
715  		debug_assert (sample != n);
716  		auto const one_week_ago = static_cast<std::size_t> ((std::chrono::system_clock::now () - std::chrono::hours (7 * 24)).time_since_epoch ().count ());
717  		perform_cleanup = sample->first < one_week_ago;
718  	}
719  	if (perform_cleanup)
720  	{
721  		store.online_weight.clear (transaction);
722  		store.peer.clear (transaction);
723  		logger.always_log ("Removed records of peers and online weight after a long period of inactivity");
724  	}
725  }
726  void nano::node::ongoing_rep_calculation ()
727  {
728  	auto now (std::chrono::steady_clock::now ());
729  	vote_processor.calculate_weights ();
730  	std::weak_ptr<nano::node> node_w (shared_from_this ());
731  	workers.add_timed_task (now + std::chrono::minutes (10), [node_w] () {
732  		if (auto node_l = node_w.lock ())
733  		{
734  			node_l->ongoing_rep_calculation ();
735  		}
736  	});
737  }
738  void nano::node::ongoing_bootstrap ()
739  {
740  	auto next_wakeup = network_params.network.bootstrap_interval;
741  	if (warmed_up < 3)
742  	{
743  		next_wakeup = std::chrono::seconds (5);
744  		if (!bootstrap_initiator.in_progress () && !network.empty ())
745  		{
746  			++warmed_up;
747  		}
748  	}
749  	if (network_params.network.is_dev_network () && flags.bootstrap_interval != 0)
750  	{
751  		next_wakeup = std::chrono::seconds (flags.bootstrap_interval);
752  		++warmed_up;
753  	}
754  	uint32_t frontiers_age (std::numeric_limits<uint32_t>::max ());
755  	auto bootstrap_weight_reached (ledger.cache.block_count >= ledger.bootstrap_weight_max_blocks);
756  	auto previous_bootstrap_count (stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate, nano::stat::dir::out) + stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate_legacy_age, nano::stat::dir::out));
757  	if (bootstrap_weight_reached)
758  	{
759  		if (warmed_up < 3)
760  		{
761  			uint64_t last_sample_time (0);
762  			auto last_record = store.online_weight.rbegin (store.tx_begin_read ());
763  			if (last_record != store.online_weight.end ())
764  			{
765  				last_sample_time = last_record->first;
766  			}
767  			uint64_t time_since_last_sample = std::chrono::duration_cast<std::chrono::seconds> (std::chrono::system_clock::now ().time_since_epoch ()).count () - static_cast<uint64_t> (last_sample_time / std::pow (10, 9)); 
768  			if (time_since_last_sample + 60 * 60 < std::numeric_limits<uint32_t>::max ())
769  			{
770  				frontiers_age = std::max<uint32_t> (static_cast<uint32_t> (time_since_last_sample + 60 * 60), network_params.bootstrap.default_frontiers_age_seconds);
771  			}
772  		}
773  		else if (previous_bootstrap_count % 4 != 0)
774  		{
775  			frontiers_age = network_params.bootstrap.default_frontiers_age_seconds;
776  		}
777  	}
778  	bootstrap_initiator.bootstrap (false, boost::str (boost::format ("auto_bootstrap_%1%") % previous_bootstrap_count), frontiers_age);
779  	std::weak_ptr<nano::node> node_w (shared_from_this ());
780  	workers.add_timed_task (std::chrono::steady_clock::now () + next_wakeup, [node_w] () {
781  		if (auto node_l = node_w.lock ())
782  		{
783  			node_l->ongoing_bootstrap ();
784  		}
785  	});
786  }
787  void nano::node::ongoing_peer_store ()
788  {
789  	const bool stored{ network.tcp_channels.store_all (true) };
790  	std::weak_ptr<nano::node> node_w (shared_from_this ());
791  	workers.add_timed_task (std::chrono::steady_clock::now () + network_params.network.peer_dump_interval, [node_w] () {
792  		if (auto node_l = node_w.lock ())
793  		{
794  			node_l->ongoing_peer_store ();
795  		}
796  	});
797  }
798  void nano::node::backup_wallet ()
799  {
800  	auto transaction (wallets.tx_begin_read ());
801  	for (auto i (wallets.items.begin ()), n (wallets.items.end ()); i != n; ++i)
802  	{
803  		boost::system::error_code error_chmod;
804  		auto backup_path (application_path / "backup");
805  		boost::filesystem::create_directories (backup_path);
806  		nano::set_secure_perm_directory (backup_path, error_chmod);
807  		i->second->store.write_backup (transaction, backup_path / (i->first.to_string () + ".json"));
808  	}
809  	auto this_l (shared ());
810  	workers.add_timed_task (std::chrono::steady_clock::now () + network_params.node.backup_interval, [this_l] () {
811  		this_l->backup_wallet ();
812  	});
813  }
814  void nano::node::search_receivable_all ()
815  {
816  	wallets.reload ();
817  	wallets.search_receivable_all ();
818  	auto this_l (shared ());
819  	workers.add_timed_task (std::chrono::steady_clock::now () + network_params.node.search_pending_interval, [this_l] () {
820  		this_l->search_receivable_all ();
821  	});
822  }
823  void nano::node::bootstrap_wallet ()
824  {
825  	std::deque<nano::account> accounts;
826  	{
827  		nano::lock_guard<nano::mutex> lock{ wallets.mutex };
828  		auto const transaction (wallets.tx_begin_read ());
829  		for (auto i (wallets.items.begin ()), n (wallets.items.end ()); i != n && accounts.size () < 128; ++i)
830  		{
831  			auto & wallet (*i->second);
832  			nano::lock_guard<std::recursive_mutex> wallet_lock{ wallet.store.mutex };
833  			for (auto j (wallet.store.begin (transaction)), m (wallet.store.end ()); j != m && accounts.size () < 128; ++j)
834  			{
835  				nano::account account (j->first);
836  				accounts.push_back (account);
837  			}
838  		}
839  	}
840  	if (!accounts.empty ())
841  	{
842  		bootstrap_initiator.bootstrap_wallet (accounts);
843  	}
844  }
845  void nano::node::unchecked_cleanup ()
846  {
847  	std::vector<nano::uint128_t> digests;
848  	std::deque<nano::unchecked_key> cleaning_list;
849  	auto const attempt (bootstrap_initiator.current_attempt ());
850  	const bool long_attempt (attempt != nullptr && std::chrono::duration_cast<std::chrono::seconds> (std::chrono::steady_clock::now () - attempt->attempt_start).count () > config.unchecked_cutoff_time.count ());
851  	if (ledger.cache.block_count >= ledger.bootstrap_weight_max_blocks && !long_attempt)
852  	{
853  		auto const now (nano::seconds_since_epoch ());
854  		auto const transaction (store.tx_begin_read ());
855  		unchecked.for_each (
856  		[this, &digests, &cleaning_list, &now] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
857  			if ((now - info.modified ()) > static_cast<uint64_t> (config.unchecked_cutoff_time.count ()))
858  			{
859  				digests.push_back (network.publish_filter.hash (info.block));
860  				cleaning_list.push_back (key);
861  			} }, [iterations = 0, count = 1024 * 1024] () mutable { return iterations++ < count; });
862  	}
863  	if (!cleaning_list.empty ())
864  	{
865  		logger.always_log (boost::str (boost::format ("Deleting %1% old unchecked blocks") % cleaning_list.size ()));
866  	}
867  	while (!cleaning_list.empty ())
868  	{
869  		std::size_t deleted_count (0);
870  		while (deleted_count++ < 2 * 1024 && !cleaning_list.empty ())
871  		{
872  			auto key (cleaning_list.front ());
873  			cleaning_list.pop_front ();
874  			if (unchecked.exists (key))
875  			{
876  				unchecked.del (key);
877  			}
878  		}
879  	}
880  	network.publish_filter.clear (digests);
881  }
882  void nano::node::ongoing_unchecked_cleanup ()
883  {
884  	unchecked_cleanup ();
885  	workers.add_timed_task (std::chrono::steady_clock::now () + network_params.node.unchecked_cleaning_interval, [this_l = shared ()] () {
886  		this_l->ongoing_unchecked_cleanup ();
887  	});
888  }
889  bool nano::node::collect_ledger_pruning_targets (std::deque<nano::block_hash> & pruning_targets_a, nano::account & last_account_a, uint64_t const batch_read_size_a, uint64_t const max_depth_a, uint64_t const cutoff_time_a)
890  {
891  	uint64_t read_operations (0);
892  	bool finish_transaction (false);
893  	auto const transaction (store.tx_begin_read ());
894  	for (auto i (store.confirmation_height.begin (transaction, last_account_a)), n (store.confirmation_height.end ()); i != n && !finish_transaction;)
895  	{
896  		++read_operations;
897  		auto const & account (i->first);
898  		nano::block_hash hash (i->second.frontier);
899  		uint64_t depth (0);
900  		while (!hash.is_zero () && depth < max_depth_a)
901  		{
902  			auto block (store.block.get (transaction, hash));
903  			if (block != nullptr)
904  			{
905  				if (block->sideband ().timestamp > cutoff_time_a || depth == 0)
906  				{
907  					hash = block->previous ();
908  				}
909  				else
910  				{
911  					break;
912  				}
913  			}
914  			else
915  			{
916  				release_assert (depth != 0);
917  				hash = 0;
918  			}
919  			if (++depth % batch_read_size_a == 0)
920  			{
921  				transaction.refresh ();
922  			}
923  		}
924  		if (!hash.is_zero ())
925  		{
926  			pruning_targets_a.push_back (hash);
927  		}
928  		read_operations += depth;
929  		if (read_operations >= batch_read_size_a)
930  		{
931  			last_account_a = account.number () + 1;
932  			finish_transaction = true;
933  		}
934  		else
935  		{
936  			++i;
937  		}
938  	}
939  	return !finish_transaction || last_account_a.is_zero ();
940  }
941  void nano::node::ledger_pruning (uint64_t const batch_size_a, bool bootstrap_weight_reached_a, bool log_to_cout_a)
942  {
943  	uint64_t const max_depth (config.max_pruning_depth != 0 ? config.max_pruning_depth : std::numeric_limits<uint64_t>::max ());
944  	uint64_t const cutoff_time (bootstrap_weight_reached_a ? nano::seconds_since_epoch () - config.max_pruning_age.count () : std::numeric_limits<uint64_t>::max ());
945  	uint64_t pruned_count (0);
946  	uint64_t transaction_write_count (0);
947  	nano::account last_account (1); 
948  	std::deque<nano::block_hash> pruning_targets;
949  	bool target_finished (false);
950  	while ((transaction_write_count != 0 || !target_finished) && !stopped)
951  	{
952  		while (pruning_targets.size () < batch_size_a && !target_finished && !stopped)
953  		{
954  			target_finished = collect_ledger_pruning_targets (pruning_targets, last_account, batch_size_a * 2, max_depth, cutoff_time);
955  		}
956  		transaction_write_count = 0;
957  		if (!pruning_targets.empty () && !stopped)
958  		{
959  			auto scoped_write_guard = write_database_queue.wait (nano::writer::pruning);
960  			auto write_transaction (store.tx_begin_write ({ tables::blocks, tables::pruned }));
961  			while (!pruning_targets.empty () && transaction_write_count < batch_size_a && !stopped)
962  			{
963  				auto const & pruning_hash (pruning_targets.front ());
964  				auto account_pruned_count (ledger.pruning_action (write_transaction, pruning_hash, batch_size_a));
965  				transaction_write_count += account_pruned_count;
966  				pruning_targets.pop_front ();
967  			}
968  			pruned_count += transaction_write_count;
969  			auto log_message (boost::str (boost::format ("%1% blocks pruned") % pruned_count));
970  			if (!log_to_cout_a)
971  			{
972  				logger.try_log (log_message);
973  			}
974  			else
975  			{
976  				std::cout << log_message << std::endl;
977  			}
978  		}
979  	}
980  	auto const log_message (boost::str (boost::format ("Total recently pruned block count: %1%") % pruned_count));
981  	if (!log_to_cout_a)
982  	{
983  		logger.always_log (log_message);
984  	}
985  	else
986  	{
987  		std::cout << log_message << std::endl;
988  	}
989  }
990  void nano::node::ongoing_ledger_pruning ()
991  {
992  	auto bootstrap_weight_reached (ledger.cache.block_count >= ledger.bootstrap_weight_max_blocks);
993  	ledger_pruning (flags.block_processor_batch_size != 0 ? flags.block_processor_batch_size : 2 * 1024, bootstrap_weight_reached, false);
994  	auto const ledger_pruning_interval (bootstrap_weight_reached ? config.max_pruning_age : std::min (config.max_pruning_age, std::chrono::seconds (15 * 60)));
995  	auto this_l (shared ());
996  	workers.add_timed_task (std::chrono::steady_clock::now () + ledger_pruning_interval, [this_l] () {
997  		this_l->workers.push_task ([this_l] () {
998  			this_l->ongoing_ledger_pruning ();
999  		});
1000  	});
1001  }
1002  int nano::node::price (nano::uint128_t const & balance_a, int amount_a)
1003  {
1004  	debug_assert (balance_a >= amount_a * nano::Gxrb_ratio);
1005  	auto balance_l (balance_a);
1006  	double result (0.0);
1007  	for (auto i (0); i < amount_a; ++i)
1008  	{
1009  		balance_l -= nano::Gxrb_ratio;
1010  		auto balance_scaled ((balance_l / nano::Mxrb_ratio).convert_to<double> ());
1011  		auto units (balance_scaled / 1000.0);
1012  		auto unit_price (((free_cutoff - units) / free_cutoff) * price_max);
1013  		result += std::min (std::max (0.0, unit_price), price_max);
1014  	}
1015  	return static_cast<int> (result * 100.0);
1016  }
1017  uint64_t nano::node::default_difficulty (nano::work_version const version_a) const
1018  {
1019  	uint64_t result{ std::numeric_limits<uint64_t>::max () };
1020  	switch (version_a)
1021  	{
1022  		case nano::work_version::work_1:
1023  			result = network_params.work.threshold_base (version_a);
1024  			break;
1025  		default:
1026  			debug_assert (false && "Invalid version specified to default_difficulty");
1027  	}
1028  	return result;
1029  }
1030  uint64_t nano::node::default_receive_difficulty (nano::work_version const version_a) const
1031  {
1032  	uint64_t result{ std::numeric_limits<uint64_t>::max () };
1033  	switch (version_a)
1034  	{
1035  		case nano::work_version::work_1:
1036  			result = network_params.work.epoch_2_receive;
1037  			break;
1038  		default:
1039  			debug_assert (false && "Invalid version specified to default_receive_difficulty");
1040  	}
1041  	return result;
1042  }
1043  uint64_t nano::node::max_work_generate_difficulty (nano::work_version const version_a) const
1044  {
1045  	return nano::difficulty::from_multiplier (config.max_work_generate_multiplier, default_difficulty (version_a));
1046  }
1047  bool nano::node::local_work_generation_enabled () const
1048  {
1049  	return config.work_threads > 0 || work.opencl;
1050  }
1051  bool nano::node::work_generation_enabled () const
1052  {
1053  	return work_generation_enabled (config.work_peers);
1054  }
1055  bool nano::node::work_generation_enabled (std::vector<std::pair<std::string, uint16_t>> const & peers_a) const
1056  {
1057  	return !peers_a.empty () || local_work_generation_enabled ();
1058  }
1059  boost::optional<uint64_t> nano::node::work_generate_blocking (nano::block & block_a, uint64_t difficulty_a)
1060  {
1061  	auto opt_work_l (work_generate_blocking (block_a.work_version (), block_a.root (), difficulty_a, block_a.account ()));
1062  	if (opt_work_l.is_initialized ())
1063  	{
1064  		block_a.block_work_set (*opt_work_l);
1065  	}
1066  	return opt_work_l;
1067  }
1068  void nano::node::work_generate (nano::work_version const version_a, nano::root const & root_a, uint64_t difficulty_a, std::function<void (boost::optional<uint64_t>)> callback_a, boost::optional<nano::account> const & account_a, bool secondary_work_peers_a)
1069  {
1070  	auto const & peers_l (secondary_work_peers_a ? config.secondary_work_peers : config.work_peers);
1071  	if (distributed_work.make (version_a, root_a, peers_l, difficulty_a, callback_a, account_a))
1072  	{
1073  		callback_a (boost::none);
1074  	}
1075  }
1076  boost::optional<uint64_t> nano::node::work_generate_blocking (nano::work_version const version_a, nano::root const & root_a, uint64_t difficulty_a, boost::optional<nano::account> const & account_a)
1077  {
1078  	std::promise<boost::optional<uint64_t>> promise;
1079  	work_generate (
1080  	version_a, root_a, difficulty_a, [&promise] (boost::optional<uint64_t> opt_work_a) {
1081  		promise.set_value (opt_work_a);
1082  	},
1083  	account_a);
1084  	return promise.get_future ().get ();
1085  }
1086  boost::optional<uint64_t> nano::node::work_generate_blocking (nano::block & block_a)
1087  {
1088  	debug_assert (network_params.network.is_dev_network ());
1089  	return work_generate_blocking (block_a, default_difficulty (nano::work_version::work_1));
1090  }
1091  boost::optional<uint64_t> nano::node::work_generate_blocking (nano::root const & root_a)
1092  {
1093  	debug_assert (network_params.network.is_dev_network ());
1094  	return work_generate_blocking (root_a, default_difficulty (nano::work_version::work_1));
1095  }
1096  boost::optional<uint64_t> nano::node::work_generate_blocking (nano::root const & root_a, uint64_t difficulty_a)
1097  {
1098  	debug_assert (network_params.network.is_dev_network ());
1099  	return work_generate_blocking (nano::work_version::work_1, root_a, difficulty_a);
1100  }
1101  void nano::node::add_initial_peers ()
1102  {
1103  	if (flags.disable_add_initial_peers)
1104  	{
1105  		logger.always_log ("Skipping add_initial_peers because disable_add_initial_peers is set");
1106  		return;
1107  	}
1108  	auto transaction (store.tx_begin_read ());
1109  	for (auto i (store.peer.begin (transaction)), n (store.peer.end ()); i != n; ++i)
1110  	{
1111  		nano::endpoint endpoint (boost::asio::ip::address_v6 (i->first.address_bytes ()), i->first.port ());
1112  		if (!network.reachout (endpoint, config.allow_local_peers))
1113  		{
1114  			network.tcp_channels.start_tcp (endpoint);
1115  		}
1116  	}
1117  }
1118  std::shared_ptr<nano::election> nano::node::block_confirm (std::shared_ptr<nano::block> const & block_a)
1119  {
1120  	scheduler.buckets.manual (block_a);
1121  	scheduler.buckets.flush ();
1122  	auto election = active.election (block_a->qualified_root ());
1123  	if (election != nullptr)
1124  	{
1125  		election->transition_active ();
1126  		return election;
1127  	}
1128  	return {};
1129  }
1130  bool nano::node::block_confirmed (nano::block_hash const & hash_a)
1131  {
1132  	auto transaction (store.tx_begin_read ());
1133  	return ledger.block_confirmed (transaction, hash_a);
1134  }
1135  bool nano::node::block_confirmed_or_being_confirmed (nano::block_hash const & hash_a)
1136  {
1137  	return confirmation_height_processor.is_processing_block (hash_a) || ledger.block_confirmed (store.tx_begin_read (), hash_a);
1138  }
1139  void nano::node::ongoing_online_weight_calculation_queue ()
1140  {
1141  	std::weak_ptr<nano::node> node_w (shared_from_this ());
1142  	workers.add_timed_task (std::chrono::steady_clock::now () + (std::chrono::seconds (network_params.node.weight_period)), [node_w] () {
1143  		if (auto node_l = node_w.lock ())
1144  		{
1145  			node_l->ongoing_online_weight_calculation ();
1146  		}
1147  	});
1148  }
1149  bool nano::node::online () const
1150  {
1151  	return rep_crawler.total_weight () > online_reps.delta ();
1152  }
1153  void nano::node::ongoing_online_weight_calculation ()
1154  {
1155  	online_reps.sample ();
1156  	ongoing_online_weight_calculation_queue ();
1157  }
1158  void nano::node::receive_confirmed (nano::transaction const & block_transaction_a, nano::block_hash const & hash_a, nano::account const & destination_a)
1159  {
1160  	nano::unique_lock<nano::mutex> lk{ wallets.mutex };
1161  	auto wallets_l = wallets.get_wallets ();
1162  	auto wallet_transaction = wallets.tx_begin_read ();
1163  	lk.unlock ();
1164  	for ([[maybe_unused]] auto const & [id, wallet] : wallets_l)
1165  	{
1166  		if (wallet->store.exists (wallet_transaction, destination_a))
1167  		{
1168  			nano::account representative;
1169  			representative = wallet->store.representative (wallet_transaction);
1170  			auto pending = ledger.pending_info (block_transaction_a, nano::pending_key (destination_a, hash_a));
1171  			if (pending)
1172  			{
1173  				auto amount (pending->amount.number ());
1174  				wallet->receive_async (hash_a, representative, amount, destination_a, [] (std::shared_ptr<nano::block> const &) {});
1175  			}
1176  			else
1177  			{
1178  				if (!ledger.block_or_pruned_exists (block_transaction_a, hash_a))
1179  				{
1180  					logger.try_log (boost::str (boost::format ("Confirmed block is missing:  %1%") % hash_a.to_string ()));
1181  					debug_assert (false && "Confirmed block is missing");
1182  				}
1183  				else
1184  				{
1185  					logger.try_log (boost::str (boost::format ("Block %1% has already been received") % hash_a.to_string ()));
1186  				}
1187  			}
1188  		}
1189  	}
1190  }
1191  void nano::node::process_confirmed_data (nano::transaction const & transaction_a, std::shared_ptr<nano::block> const & block_a, nano::block_hash const & hash_a, nano::account & account_a, nano::uint128_t & amount_a, bool & is_state_send_a, bool & is_state_epoch_a, nano::account & pending_account_a)
1192  {
1193  	account_a = block_a->account ();
1194  	if (account_a.is_zero ())
1195  	{
1196  		account_a = block_a->sideband ().account;
1197  	}
1198  	auto previous (block_a->previous ());
1199  	bool error (false);
1200  	auto previous_balance (ledger.balance_safe (transaction_a, previous, error));
1201  	auto block_balance (store.block.balance_calculated (block_a));
1202  	if (hash_a != ledger.constants.genesis->account ())
1203  	{
1204  		if (!error)
1205  		{
1206  			amount_a = block_balance > previous_balance ? block_balance - previous_balance : previous_balance - block_balance;
1207  		}
1208  		else
1209  		{
1210  			amount_a = 0;
1211  		}
1212  	}
1213  	else
1214  	{
1215  		amount_a = nano::dev::constants.genesis_amount;
1216  	}
1217  	if (auto state = dynamic_cast<nano::state_block *> (block_a.get ()))
1218  	{
1219  		if (state->hashables.balance < previous_balance)
1220  		{
1221  			is_state_send_a = true;
1222  		}
1223  		if (amount_a == 0 && network_params.ledger.epochs.is_epoch_link (state->link ()))
1224  		{
1225  			is_state_epoch_a = true;
1226  		}
1227  		pending_account_a = state->hashables.link.as_account ();
1228  	}
1229  	if (auto send = dynamic_cast<nano::send_block *> (block_a.get ()))
1230  	{
1231  		pending_account_a = send->hashables.destination;
1232  	}
1233  }
1234  void nano::node::process_confirmed (nano::election_status const & status_a, uint64_t iteration_a)
1235  {
1236  	auto hash (status_a.winner->hash ());
1237  	decltype (iteration_a) const num_iters = (config.block_processor_batch_max_time / network_params.node.process_confirmed_interval) * 4;
1238  	if (auto block_l = ledger.store.block.get (ledger.store.tx_begin_read (), hash))
1239  	{
1240  		active.recently_confirmed.put (block_l->qualified_root (), hash);
1241  		confirmation_height_processor.add (block_l);
1242  	}
1243  	else if (iteration_a < num_iters)
1244  	{
1245  		iteration_a++;
1246  		std::weak_ptr<nano::node> node_w (shared ());
1247  		workers.add_timed_task (std::chrono::steady_clock::now () + network_params.node.process_confirmed_interval, [node_w, status_a, iteration_a] () {
1248  			if (auto node_l = node_w.lock ())
1249  			{
1250  				node_l->process_confirmed (status_a, iteration_a);
1251  			}
1252  		});
1253  	}
1254  	else
1255  	{
1256  		active.remove_election_winner_details (hash);
1257  	}
1258  }
1259  std::shared_ptr<nano::node> nano::node::shared ()
1260  {
1261  	return shared_from_this ();
1262  }
1263  int nano::node::store_version ()
1264  {
1265  	auto transaction (store.tx_begin_read ());
1266  	return store.version.get (transaction);
1267  }
1268  bool nano::node::init_error () const
1269  {
1270  	return store.init_error () || wallets_store.init_error ();
1271  }
1272  std::pair<uint64_t, decltype (nano::ledger::bootstrap_weights)> nano::node::get_bootstrap_weights () const
1273  {
1274  	std::unordered_map<nano::account, nano::uint128_t> weights;
1275  	uint8_t const * weight_buffer = network_params.network.is_live_network () ? nano_bootstrap_weights_live : nano_bootstrap_weights_beta;
1276  	std::size_t weight_size = network_params.network.is_live_network () ? nano_bootstrap_weights_live_size : nano_bootstrap_weights_beta_size;
1277  	nano::bufferstream weight_stream ((uint8_t const *)weight_buffer, weight_size);
1278  	nano::uint128_union block_height;
1279  	uint64_t max_blocks = 0;
1280  	if (!nano::try_read (weight_stream, block_height))
1281  	{
1282  		max_blocks = nano::narrow_cast<uint64_t> (block_height.number ());
1283  		while (true)
1284  		{
1285  			nano::account account;
1286  			if (nano::try_read (weight_stream, account.bytes))
1287  			{
1288  				break;
1289  			}
1290  			nano::amount weight;
1291  			if (nano::try_read (weight_stream, weight.bytes))
1292  			{
1293  				break;
1294  			}
1295  			weights[account] = weight.number ();
1296  		}
1297  	}
1298  	return { max_blocks, weights };
1299  }
1300  void nano::node::bootstrap_block (const nano::block_hash & hash)
1301  {
1302  	if (!ledger.pruning || !store.pruned.exists (store.tx_begin_read (), hash))
1303  	{
1304  		gap_cache.bootstrap_start (hash);
1305  	}
1306  }
1307  uint64_t nano::node::get_confirmation_height (nano::transaction const & transaction_a, nano::account & account_a)
1308  {
1309  	nano::confirmation_height_info info;
1310  	store.confirmation_height.get (transaction_a, account_a, info);
1311  	return info.height;
1312  }
1313  nano::account nano::node::get_node_id () const
1314  {
1315  	return node_id.pub;
1316  };
1317  nano::telemetry_data nano::node::local_telemetry () const
1318  {
1319  	nano::telemetry_data telemetry_data;
1320  	telemetry_data.node_id = node_id.pub;
1321  	telemetry_data.block_count = ledger.cache.block_count;
1322  	telemetry_data.cemented_count = ledger.cache.cemented_count;
1323  	telemetry_data.bandwidth_cap = config.bandwidth_limit;
1324  	telemetry_data.protocol_version = network_params.network.protocol_version;
1325  	telemetry_data.uptime = std::chrono::duration_cast<std::chrono::seconds> (std::chrono::steady_clock::now () - startup_time).count ();
1326  	telemetry_data.unchecked_count = unchecked.count ();
1327  	telemetry_data.genesis_block = network_params.ledger.genesis->hash ();
1328  	telemetry_data.peer_count = nano::narrow_cast<decltype (telemetry_data.peer_count)> (network.size ());
1329  	telemetry_data.account_count = ledger.cache.account_count;
1330  	telemetry_data.major_version = nano::get_major_node_version ();
1331  	telemetry_data.minor_version = nano::get_minor_node_version ();
1332  	telemetry_data.patch_version = nano::get_patch_node_version ();
1333  	telemetry_data.pre_release_version = nano::get_pre_release_node_version ();
1334  	telemetry_data.maker = static_cast<std::underlying_type_t<telemetry_maker>> (ledger.pruning ? telemetry_maker::nf_pruned_node : telemetry_maker::nf_node);
1335  	telemetry_data.timestamp = std::chrono::system_clock::now ();
1336  	telemetry_data.active_difficulty = default_difficulty (nano::work_version::work_1);
1337  	telemetry_data.sign (node_id);
1338  	return telemetry_data;
1339  }
1340  nano::node_wrapper::node_wrapper (boost::filesystem::path const & path_a, boost::filesystem::path const & config_path_a, nano::node_flags const & node_flags_a) :
1341  	network_params{ nano::network_constants::active_network },
1342  	io_context (std::make_shared<boost::asio::io_context> ()),
1343  	work{ network_params.network, 1 }
1344  {
1345  	boost::system::error_code error_chmod;
1346  	boost::filesystem::create_directories (path_a);
1347  	nano::set_secure_perm_directory (path_a, error_chmod);
1348  	nano::daemon_config daemon_config{ path_a, network_params };
1349  	auto error = nano::read_node_config_toml (config_path_a, daemon_config, node_flags_a.config_overrides);
1350  	if (error)
1351  	{
1352  		std::cerr << "Error deserializing config file";
1353  		if (!node_flags_a.config_overrides.empty ())
1354  		{
1355  			std::cerr << " or --config option";
1356  		}
1357  		std::cerr << "\n"
1358  				  << error.get_message () << std::endl;
1359  		std::exit (1);
1360  	}
1361  	auto & node_config = daemon_config.node;
1362  	node_config.peering_port = 24000;
1363  	node_config.logging.max_size = std::numeric_limits<std::uintmax_t>::max ();
1364  	node_config.logging.init (path_a);
1365  	node = std::make_shared<nano::node> (*io_context, path_a, node_config, work, node_flags_a);
1366  }
1367  nano::node_wrapper::~node_wrapper ()
1368  {
1369  	node->stop ();
1370  }
1371  nano::inactive_node::inactive_node (boost::filesystem::path const & path_a, boost::filesystem::path const & config_path_a, nano::node_flags const & node_flags_a) :
1372  	node_wrapper (path_a, config_path_a, node_flags_a),
1373  	node (node_wrapper.node)
1374  {
1375  	node_wrapper.node->active.stop ();
1376  }
1377  nano::inactive_node::inactive_node (boost::filesystem::path const & path_a, nano::node_flags const & node_flags_a) :
1378  	inactive_node (path_a, path_a, node_flags_a)
1379  {
1380  }
1381  nano::node_flags const & nano::inactive_node_flag_defaults ()
1382  {
1383  	static nano::node_flags node_flags;
1384  	node_flags.inactive_node = true;
1385  	node_flags.read_only = true;
1386  	node_flags.generate_cache.reps = false;
1387  	node_flags.generate_cache.cemented_count = false;
1388  	node_flags.generate_cache.unchecked_count = false;
1389  	node_flags.generate_cache.account_count = false;
1390  	node_flags.disable_bootstrap_listener = true;
1391  	node_flags.disable_tcp_realtime = true;
1392  	return node_flags;
1393  }
1394  std::unique_ptr<nano::store> nano::make_store (nano::logger_mt & logger, boost::filesystem::path const & path, nano::ledger_constants & constants, bool read_only, bool add_db_postfix, nano::rocksdb_config const & rocksdb_config, nano::txn_tracking_config const & txn_tracking_config_a, std::chrono::milliseconds block_processor_batch_max_time_a, nano::lmdb_config const & lmdb_config_a, bool backup_before_upgrade)
1395  {
1396  	if (rocksdb_config.enable)
1397  	{
1398  		return std::make_unique<nano::rocksdb::store> (logger, add_db_postfix ? path / "rocksdb" : path, constants, rocksdb_config, read_only);
1399  	}
1400  	return std::make_unique<nano::lmdb::store> (logger, add_db_postfix ? path / "data.ldb" : path, constants, txn_tracking_config_a, block_processor_batch_max_time_a, lmdb_config_a, backup_before_upgrade);
1401  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-request_aggregator_62.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_46.cpp</div>
                </div>
                <div class="column column_space"><pre><code>279  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "pools", pools_count, sizeof_element }));
280  	return composite;
</pre></code></div>
                <div class="column column_space"><pre><code>90  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "active", count, sizeof_element }));
91  	return composite;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    