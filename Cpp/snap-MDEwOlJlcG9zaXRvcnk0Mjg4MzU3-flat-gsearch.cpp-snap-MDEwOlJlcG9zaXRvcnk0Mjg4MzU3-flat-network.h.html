
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.604307937774232%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</h3>
            <pre><code>1  TStr TGixConst::WdGixFNm = "WdGix";
2  TStr TGixConst::WdGixDatFNm = "WdGix.Dat";
3  TStr TGixConst::WdGixBsFNm = "WdGixBs.MBlobBs";
4  TStr TGixConst::WdGixMDSFNm = "WdGixMDS.Dat";
5  TStr TGixConst::TrGixFNm = "TrGix";
6  TStr TGixConst::TrGixDatFNm = "TrGix.Dat";
7  TStr TGixConst::TrGixDocBsFNm = "TrGixDocBs.MBlobBs";
8  TStr TGixConst::TrGixSentBsFNm = "TrGixSentBs.MBlobBs";
9  TStr TGixConst::TrGixTrAttrBsFNm = "TrGixTrAttrBs.MBlobBs";
10  TStr TGixConst::MWdGixFNm = "MWdGix";
11  TStr TGixConst::MWdGixDatFNm = "MWdGix.Dat";
12  TStr TGixConst::MWdGixDocBsFNm = "MWdGixDocBs.MBlobBs";
13  TStr TGixConst::MWdGixBsFNm = "MWdGixBs.Dat";
14  int TWdGixItem::TitleBit = 0;
15  int TWdGixItem::NmObjBit = 1;
16  int TWdGixItem::AnchorBit = 2;
17  int TWdGixItem::EmphBit = 3;
18  TWdGixItem::TWdGixItem(const TBlobPt& BlobPt, const uchar& _Wgt, const uchar& _WdPos,
19          const bool& TitleP, const bool& NmObjP, const bool& AnchorP, const bool& EmphP):
20              Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()), WdPos(_WdPos) {
21      FSet.SetBit(TitleBit, TitleP);
22      FSet.SetBit(NmObjBit, NmObjP);
23      FSet.SetBit(AnchorBit, AnchorP);
24      FSet.SetBit(EmphBit, EmphP);
25  }
26  TWdGixItem::TWdGixItem(const uchar& _Seg, const uint& _Addr, const uchar& _Wgt,
27          const uchar& _WdPos, const bool& TitleP, const bool& NmObjP, const bool& AnchorP,
28          const bool& EmphP): Seg(_Seg), Addr(_Addr), Wgt(_Wgt), WdPos(_WdPos) {
29      FSet.SetBit(TitleBit, TitleP);
30      FSet.SetBit(NmObjBit, NmObjP);
31      FSet.SetBit(AnchorBit, AnchorP);
32      FSet.SetBit(EmphBit, EmphP);
33  }
34  TWdGixItem::TWdGixItem(TSIn& SIn) {
35      SIn.Load(Seg); SIn.Load(Addr);
36      SIn.Load(Wgt); SIn.Load(WdPos); FSet=TB8Set(SIn);
37  }
38  void TWdGixItem::Save(TSOut& SOut) const {
39      SOut.Save(Seg); SOut.Save(Addr);
40      SOut.Save(Wgt); SOut.Save(WdPos); FSet.Save(SOut);
41  }
42  inline bool TWdGixItem::operator==(const TWdGixItem& Item) const {
43      return (Seg == Item.Seg) && (Addr == Item.Addr); 
44  }
45  inline bool TWdGixItem::operator<(const TWdGixItem& Item) const {
46      return (Seg < Item.Seg) ||
47          ((Seg == Item.Seg) && (Addr < Item.Addr)); 
48  }
49  void TWdGix::LoadTags() {
50      TitleTagH.AddKey("<TITLE>");
51      NmObjTagH.AddKey("<NMOBJ>");
52      EmphTagH.AddKey("<EM>"); EmphTagH.AddKey("<A>"); EmphTagH.AddKey("<B>");
53      EmphTagH.AddKey("<I>"); EmphTagH.AddKey("<H1>"); EmphTagH.AddKey("<H2>");
54      EmphTagH.AddKey("<H3>"); EmphTagH.AddKey("<H4>"); EmphTagH.AddKey("<H5>");
55  }
56  TWdGix::TWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
57      FPath = _FPath; FAccess = _FAccess;
58      WGix = TWGix::New(TGixConst::WdGixFNm, FPath, FAccess, CacheSize);
59      if (FAccess == faCreate) {
60          Stemmer = TStemmer::New(stmtPorter, false);
61          SwSet = TSwSet::New(swstEn523);
62      } else {
63          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
64          TFIn FIn(WdGixDatFNm);
65          WordH.Load(FIn);
66          Stemmer = TStemmer::Load(FIn);
67          SwSet = TSwSet::Load(FIn);
68      }
69      LoadTags();
70  }
71  TWdGix::~TWdGix() {
72      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
73          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
74          TFOut FOut(WdGixDatFNm);
75          WordH.Save(FOut);
76          Stemmer->Save(FOut);
77          SwSet->Save(FOut);
78      }
79  }
80  void TWdGix::AddHtml(const TStr& HtmlStr, const TBlobPt& BlobPt, const uchar& Wgt) {
81      PSIn HtmlSIn = TStrIn::New(HtmlStr);
82      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
83      THash<TInt, TWdGixItemV> WIdToItemVH; uchar WdPos = 0;
84      bool TitleP = false, NmObjP = false; int EmphLv = 0;
85      while (HtmlLx.Sym != hsyEof) {
86          if (HtmlLx.Sym == hsyStr) {
87              TStr WordStr = HtmlLx.UcChA;
88              if (!SwSet->IsIn(WordStr)) {
89                  WordStr=Stemmer->GetStem(WordStr);
90                  const int WId = WordH.AddKey(WordStr);
91                  WdPos++;
92                  WIdToItemVH.AddDat(WId).Add(
93                      TWdGixItem(BlobPt, Wgt, WdPos, TitleP, NmObjP, false, (EmphLv>0)));
94              }
95          } else if (HtmlLx.Sym == hsyBTag) {
96              TStr TagStr = HtmlLx.UcChA;
97              if (TitleTagH.IsKey(TagStr)) { TitleP = true; }
98              if (NmObjTagH.IsKey(TagStr)) { NmObjP = true; }
99              if (EmphTagH.IsKey(TagStr)) { EmphLv++; }
100          } else if (HtmlLx.Sym == hsyETag) {
101              TStr TagStr = HtmlLx.UcChA;
102              if (TitleTagH.IsKey(TagStr)) { TitleP = false; }
103              if (NmObjTagH.IsKey(TagStr)) { NmObjP = false; }
104              if (EmphTagH.IsKey(TagStr)) { EmphLv--; EmphLv = TInt::GetMx(0, EmphLv); }
105          }
106          HtmlLx.GetSym();
107      }
108      int WdKeyId = WIdToItemVH.FFirstKeyId();
109      while (WIdToItemVH.FNextKeyId(WdKeyId)) {
110          const int WId = WIdToItemVH.GetKey(WdKeyId); WordH[WId]++;
111          const TWdGixItemV& ItemV = WIdToItemVH[WdKeyId];
112          const uchar Seg = ItemV[0].GetSeg();
113          const uint Addr = ItemV[0].GetAddr();
114          const uchar Count = uchar(TInt::GetMn(int(TUCh::Mx), ItemV.Len()));
115          bool TitleP = false, NmObjP = false, EmphP = false, AnchorP = false;
116          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
117              const TWdGixItem& Item = ItemV[ItemN];
118              TitleP = TitleP || Item.IsTitle();
119              NmObjP = NmObjP || Item.IsNmObj();
120              EmphP = EmphP || Item.IsAnchor();
121              AnchorP = AnchorP || Item.IsEmph();
122          }
123          TWdGixItem Item(Seg, Addr, Wgt, Count, TitleP, NmObjP, AnchorP, EmphP);
124          WGix->AddItem(WId, Item);
125      }
126  }
127  bool TWdGix::Search(const TStr& QueryStr, TWdGixItemV& ResItemV) {
128      PWGixExpItem WGixExp = TWGixExpItem::NewEmpty();
129      PSIn HtmlSIn = TStrIn::New(QueryStr);
130      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
131      while (HtmlLx.Sym != hsyEof) {
132          if (HtmlLx.Sym == hsyStr) {
133              TStr WordStr = HtmlLx.UcChA;
134              WordStr=Stemmer->GetStem(WordStr);
135              const int WId = WordH.GetKeyId(WordStr);
136              if (WId != -1) {
137                  PWGixExpItem WGixExpItem = TWGixExpItem::NewItem(WId);
138                  if (WGixExp->IsEmpty()) { WGixExp = WGixExpItem; }
139                  else { WGixExp = TWGixExpItem::NewAnd(WGixExp, WGixExpItem); }
140              }
141          }
142          HtmlLx.GetSym();
143      }
144      return WGixExp->Eval(WGix, ResItemV);
145  }
146  void TWdGixMDS::AddDate(const TBlobPt& DocBlobPt, const TTm& DateTime) {
147      TAddrPr AddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr());
148      const uint64 DateMSecs = TTm::GetMSecsFromTm(DateTime);
149      AddrPrToDateH.AddDat(AddrPr, DateMSecs);
150  }
151  inline uint64 TWdGixMDS::GetDateMSecs(const TBlobPt& DocBlobPt) const {
152      return AddrPrToDateH.GetDat(TAddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr()));
153  }
154  inline TTm TWdGixMDS::GetDateTTm(const TBlobPt& DocBlobPt) const {
155      return TTm::GetTmFromMSecs(GetDateMSecs(DocBlobPt));
156  }
157  void TWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
158          const TStrV& CatNmV, const TTm& DateTime) {
159      DocTitleV.Add(DocTitle);
160      DocTitleV.Last().DelChAll('\n');
161      DocTitleV.Last().DelChAll('\r');
162      DocStrV.Add(DocStr);
163      CatNmVV.Add(CatNmV);
164      DateTimeV.Add(DateTime);
165  }
166  void TWdGixRSet::SortByDate(const bool& Asc) {
167      typedef TPair<TUInt64, TInt> TUInt64IntPr;
168      TVec<TUInt64IntPr> TmMSecsDocNV;
169      const int Docs = GetDocs();
170      for (int DocN = 0; DocN < Docs; DocN++) {
171          uint64 TmMSecs = TTm::GetMSecsFromTm(DateTimeV[DocN]);
172          TmMSecsDocNV.Add(TUInt64IntPr(TmMSecs, DocN));
173      }
174      TmMSecsDocNV.Sort(Asc);
175      TStrV NewDocTitleV(Docs, 0), NewDocStrV(Docs, 0);
176      TVec<TStrV> NewCatNmVV(Docs, 0); TTmV NewDateTimeV(Docs, 0);
177      for (int NewDocN = 0; NewDocN < Docs; NewDocN++) {
178          const int OldDocN = TmMSecsDocNV[NewDocN].Val2;
179          NewDocTitleV.Add(DocTitleV[OldDocN]);
180          NewDocStrV.Add(DocStrV[OldDocN]);
181          NewCatNmVV.Add(CatNmVV[OldDocN]);
182          NewDateTimeV.Add(DateTimeV[OldDocN]);
183      }
184      DocTitleV = NewDocTitleV; DocStrV = NewDocStrV;
185      CatNmVV = NewCatNmVV; DateTimeV = NewDateTimeV;
186  }
187  void TWdGixRSet::PrintRes(PNotify Notify) {
188      const int Docs = GetDocs();
189      Notify->OnStatus(TStr::Fmt(
190          "All results: %d, Showing results from %d to %d",
191          AllDocs.Val, Docs, Docs + Offset.Val));
192      for (int DocN = 0; DocN < Docs; DocN++) {
193          TTm DateTime = DateTimeV[DocN];
194          if (DateTime.IsDef()) {
195              Notify->OnStatus(TStr::Fmt("[%d: %s] %s ...", DocN+1,
196                  DateTime.GetWebLogDateStr().CStr(),
197                  DocTitleV[DocN].Left(50).CStr()));
198          } else {
199              Notify->OnStatus(TStr::Fmt("[%d] %s ...", DocN+1,
200                  DocTitleV[DocN].Left(60).CStr()));
201          }
202      }
203      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
204          AllDocs.Val, Docs, Docs + Offset.Val));
205  }
206  PBowDocBs TWdGixRSet::GenBowDocBs() const {
207      PSwSet SwSet = TSwSet::New(swstEn523);
208      PStemmer Stemmer = TStemmer::New(stmtPorter, true);
209      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
210      const int Docs = GetDocs();
211      for (int DocN = 0; DocN < Docs; DocN++) {
212          const TStr& DocNm = DocTitleV[DocN];
213          const TStr& DocStr = DocStrV[DocN];
214          BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, true);
215      }
216      return BowDocBs;
217  }
218  void TWdGixBs::Filter(const TWgtWdGixItemKdV& InItemV,
219          const TWdGixBsGrouping& Grouping, TWgtWdGixItemKdV& OutItemV) {
220      OutItemV.Clr();
221      if (Grouping == wgbgName) {
222          TStrFltH NameToRankH; TStrH NameToItemNH;
223          const int Items = InItemV.Len();
224          for (int ItemN = 0; ItemN < Items; ItemN++) {
225              TBlobPt BlobPt = InItemV[ItemN].Dat.GetBlobPt();
226              TStr Name = GetDocTitle(BlobPt);
227              const double Rank = InItemV[ItemN].Key;
228              if (NameToRankH.IsKey(Name)) {
229                  const double OldRank = NameToRankH.GetDat(Name);
230                  if (Rank > OldRank) {
231                      NameToRankH.GetDat(Name) = Rank;
232                      NameToItemNH.GetDat(Name) = ItemN;
233                  }
234              } else {
235                  NameToRankH.AddDat(Name) = Rank;
236                  NameToItemNH.AddDat(Name) = ItemN;
237              }
238          }
239          int KeyId = NameToItemNH.FFirstKeyId();
240          while (NameToItemNH.FNextKeyId(KeyId)) {
241              const int ItemN = NameToItemNH[KeyId];
242              OutItemV.Add(InItemV[ItemN]);
243          }
244      } else if (Grouping == wgbgDate) {
245          Fail;
246      } else if (Grouping == wgbgDateTime) {
247          Fail;
248      }
249  }
250  TWdGixBs::TWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
251      FPath = _FPath; FAccess = _FAccess;
252      TStr WdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixBsFNm;
253      DocBBs = TMBlobBs::New(WdGixBsFNm, FAccess);
254      if (FAccess == faCreate) { WdGixMDS = TWdGixMDS::New(); }
255      else {
256          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
257          WdGixMDS = TWdGixMDS::LoadBin(WdGixMDSFNm);
258      }
259      WdGix = TWdGix::New(FPath, FAccess, CacheSize);
260  }
261  TWdGixBs::~TWdGixBs() {
262      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
263          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
264          WdGixMDS->SaveBin(WdGixMDSFNm);
265      }
266  }
267  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
268          const TStrV& CatNmV, const TTm& DateTime, const uchar& Wgt) {
269      TMOut DocMOut;
270      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
271      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
272      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
273      WdGix->AddHtml(DocStr, DocBlobPt, Wgt);
274  }
275  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStoreStr,
276          const TStr& DocIndexStr, const TStrV& CatNmV,
277          const TTm& DateTime, const uchar& Wgt) {
278      TMOut DocMOut;
279      DocTitle.Save(DocMOut); DocStoreStr.Save(DocMOut); CatNmV.Save(DocMOut);
280      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
281      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
282      WdGix->AddHtml(DocIndexStr, DocBlobPt, Wgt);
283  }
284  void TWdGixBs::GetDoc(const TBlobPt& BlobPt,
285          TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
286      PSIn SIn = DocBBs->GetBlob(BlobPt);
287      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
288  }
289  TStr TWdGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
290      PSIn SIn = DocBBs->GetBlob(BlobPt);
291      TStr DocTitle; DocTitle.Load(*SIn);
292      return DocTitle;
293  }
294  TStr TWdGixBs::GetDocStr(const TBlobPt& BlobPt) const {
295      PSIn SIn = DocBBs->GetBlob(BlobPt);
296      {TStr DocTitle; DocTitle.Load(*SIn);}
297      TStr DocStr; DocStr.Load(*SIn);
298      return DocStr;
299  }
300  TStrV TWdGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
301      PSIn SIn = DocBBs->GetBlob(BlobPt);
302      {TStr DocTitle; DocTitle.Load(*SIn);}
303      {TStr DocStr; DocStr.Load(*SIn);}
304      TStrV CatNmV; CatNmV.Load(*SIn);
305      return CatNmV;
306  }
307  PWdGixRSet TWdGixBs::SearchDoc(const TStr& QueryStr,
308          const TWdGixBsGrouping& Grouping, TWdGixRankFun& RankFun,
309          const int& Docs, const int& Offset, const TTm& MnDate,
310          const TTm& MxDate) {
311      printf("  Loading from Gix ...\n");
312      TWdGixItemV ResItemV; WdGix->Search(QueryStr, ResItemV);
313      printf("  Weighting %d hits ...\n", ResItemV.Len());
314      TWgtWdGixItemKdV FullWgtItemV(ResItemV.Len(), 0);
315      const bool CheckMnDateP = MnDate.IsDef();
316      const bool CheckMxDateP = MxDate.IsDef();
317      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
318          const TWdGixItem& Item = ResItemV[ItemN];
319          TTm DateTime = WdGixMDS->GetDateTTm(Item.GetBlobPt());
320          if (CheckMnDateP && DateTime < MnDate) { continue; }
321          if (CheckMxDateP && DateTime > MxDate) { continue; }
322          const double Wgt = RankFun(DateTime, Item.GetWgt(), Item.GetWdPos(),
323              Item.IsTitle(), Item.IsNmObj(), Item.IsAnchor(), Item.IsEmph());
324          FullWgtItemV.Add(TWgtWdGixItemKd(Wgt, Item));
325      }
326      printf("  Filtering ...\n");
327      if (Grouping != wgbgNone) {
328          TWgtWdGixItemKdV TmpWgtItemV;
329          Filter(FullWgtItemV, Grouping, TmpWgtItemV);
330          FullWgtItemV = TmpWgtItemV;
331      }
332      printf("  Sorting %d hits ...\n", FullWgtItemV.Len());
333      TWgtWdGixItemKdV WgtItemV;
334      if (Docs == -1) {
335          WgtItemV = FullWgtItemV;
336      } else if (ResItemV.Len() >= (Docs + Offset)) {
337          WgtItemV = FullWgtItemV;
338          WgtItemV.Sort(false); WgtItemV.Trunc(Docs + Offset);
339          WgtItemV.Sort(true); WgtItemV.Trunc(Docs);
340      } else if (ResItemV.Len() > Offset) {
341          WgtItemV = FullWgtItemV; WgtItemV.Sort(true);
342          WgtItemV.Trunc(FullWgtItemV.Len() - Offset);
343      } else {
344      }
345      WgtItemV.Sort(false);
346      printf("  Loading content for %d hits ...\n", WgtItemV.Len());
347      PWdGixRSet RSet = TWdGixRSet::New(
348          QueryStr, FullWgtItemV.Len(), Offset);
349      for (int ItemN = 0; ItemN < WgtItemV.Len(); ItemN++) {
350          const TWdGixItem& Item = WgtItemV[ItemN].Dat;
351          TBlobPt DocBlobPt = Item.GetBlobPt();
352          TStr DocTitle, DocStr; TStrV CatNmV;
353          GetDoc(DocBlobPt, DocTitle, DocStr, CatNmV);
354          TTm DateTime = WdGixMDS->GetDateTTm(DocBlobPt);
355          RSet->AddDoc(DocTitle, DocStr, CatNmV, DateTime);
356      }
357      printf("  Done\n");
358      return RSet;
359  }
360  void TWdGixBs::AddReuters(const TStr& XmlFNm) {
361      PXmlDoc Doc=TXmlDoc::LoadTxt(XmlFNm);
362      TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
363      TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
364      TChA DocChA; DocChA += "<doc>";
365      TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
366      DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
367      DocChA += "<body>";
368      TStr DocHeadline = Doc->GetTagTok("newsitem|headline")->GetTokStr(false);
369      DocChA += "<p><em>"; DocChA += TXmlDoc::GetXmlStr(DocHeadline); DocChA += "</em></p>\n";
370      TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
371      for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
372          TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
373          TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("enamex", NmObjTokV);
374          for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
375              TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
376              ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
377          }
378          DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
379      }
380      DocChA += "</body></doc>";
381      TStrV CatNmV;
382      TXmlTokV CdsTokV; Doc->GetTagTokV("newsitem|metadata|codes", CdsTokV);
383      for (int CdsTokN = 0; CdsTokN < CdsTokV.Len(); CdsTokN++){
384          PXmlTok CdsTok = CdsTokV[CdsTokN];
385          TXmlTokV CdTokV; CdsTok->GetTagTokV("code", CdTokV);
386          if (CdsTok->GetArgVal("class") == "bip:topics:1.0"){
387              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
388                  TStr CdNm = CdTokV[CdTokN]->GetArgVal("code");
389                  CatNmV.AddMerged(CdNm);
390              }
391          } else if (CdsTok->GetArgVal("class")=="bip:countries:1.0"){
392              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
393                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
394                  CatNmV.AddMerged(CdNm);
395              }
396          } else if (CdsTok->GetArgVal("class")=="bip:industries:1.0"){
397              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
398                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
399                  CatNmV.AddMerged(CdNm);
400              }
401          } else { Fail; }
402      }
403      AddDoc(DocTitle, DocChA, CatNmV, DateTm);
404  }
405  void TWdGixBs::IndexReuters(const TStr& FPath) {
406      PNotify Notify = TStdNotify::New();
407      Notify->OnStatus("Loading Reuters documents from " + FPath + " ...\n");
408      TFFile FFile(FPath, ".xml", true);
409      TStr XmlFNm; int Files = 0;
410      while (FFile.Next(XmlFNm)) {
411          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm); Files++; }
412          if (Files % 1000 == 0) { Notify->OnStatus(TStr::Fmt("F:%d\r", Files)); }
413      }
414      Notify->OnStatus(TStr::Fmt("F:%d\n", Files));
415  }
416  void TWdGixBs::IndexNmEnBs(const TStr& FNm) {
417      PNotify Notify = TStdNotify::New();
418      Notify->OnStatus("Loading name-entitites from " + FNm + " ...\n");
419      PNmEnBs NmEnBs = TNmEnBs::LoadBin(FNm, true);
420      int NmEnKeyId = NmEnBs->GetFFirstNmEn();
421      int NmEnN = 0; const int NmEns = NmEnBs->GetNmEns();
422      while (NmEnBs->GetFNextNmEn(NmEnKeyId)) {
423          if (NmEnN > 100000) { break; }
424          if (NmEnN % 1000 == 0) { Notify->OnStatus(TStr::Fmt("N:%d/%d\r", NmEnN, NmEns)); }
425          TStr NmEnStr = NmEnBs->GetNmEnStr(NmEnKeyId);
426          IAssertR(NmEnBs->IsNmEn(NmEnStr), NmEnStr);
427          THash<TUInt, TChA> DateIntToCtxH; THash<TUInt, TInt> DateIntToCountH;
428          const TIntV& NmEnCtxIdV = NmEnBs->GetCtxIdV(NmEnKeyId);
429          for (int CtxIdN = 0; CtxIdN < NmEnCtxIdV.Len(); CtxIdN++) {
430              const int CtxId = NmEnCtxIdV[CtxIdN];
431              TStr NmEnCtxStr = NmEnBs->GetCtxStr(CtxId);
432              TTm NmEnCtxTm = NmEnBs->GetCtxTm(CtxId);
433              const uint DateInt = TTm::GetDateIntFromTm(NmEnCtxTm);
434              DateIntToCtxH.AddDat(DateInt) += NmEnCtxStr;
435              DateIntToCountH.AddDat(DateInt)++;
436          }
437          int CtxKeyId = DateIntToCtxH.FFirstKeyId();
438          while (DateIntToCtxH.FNextKeyId(CtxKeyId)) {
439              const int DateInt = DateIntToCtxH.GetKey(CtxKeyId);
440              TTm CtxDate = TTm::GetTmFromDateTimeInt(DateInt);
441              TStr CtxStr = DateIntToCtxH[CtxKeyId];
442              const uchar Wgt = uchar(DateIntToCountH.GetDat(DateInt).Val);
443              AddDoc(NmEnStr, CtxStr, TStrV(), CtxDate, Wgt);
444          }
445          NmEnN++;
446      }
447      Notify->OnStatus(TStr::Fmt("N:%d/%d", NmEnN, NmEns));
448  }
449  void TWdGixBs::IndexNyt(const TStr& XmlFNm) {
450      PNotify Notify = TStdNotify::New();
451      Notify->OnStatus("Loading NYT documents from " + XmlFNm + " ...\n");
452      PSIn SIn = TFIn::New(XmlFNm); int Docs = 0;
453      TStr LastTitle = "";
454      forever {
455          if (Docs % 1000 == 0) { Notify->OnStatus(TStr::Fmt("Docs: %d\r", Docs)); }
456          PXmlDoc Doc = TXmlDoc::LoadTxt(SIn); Docs++;
457          if (!Doc->IsOk()) { printf("%s - %s\n", LastTitle.CStr(), Doc->GetMsgStr().CStr()); break; }
458          TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
459          TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
460          TChA DocChA; DocChA += "<doc>";
461          TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
462          DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
463          DocChA += "<body>";
464          TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
465          for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
466              TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
467              TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("ent", NmObjTokV);
468              for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
469                  TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
470                  ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
471              }
472              DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
473          }
474          DocChA += "</body></doc>";
475          AddDoc(DocTitle, DocChA, TStrV(), DateTm);
476          LastTitle = DocTitle;
477      }
478      Notify->OnStatus(TStr::Fmt("Docs: %d", Docs));
479  }
480  TSearchTopics::TSearchTopics(PWdGixRSet RSet, const int& Topics) {
481      PBowDocBs BowDocBs = RSet->GenBowDocBs();
482      TRnd Rnd(1);
483      PBowDocPart BowDocPart = TBowClust::GetKMeansPart(
484          TNullNotify::New(), BowDocBs, TBowSim::New(bstCos), Rnd,
485          Topics, 1, 10, 1, bwwtLogDFNrmTFIDF, 0.0, 0);
486      TopicV.Gen(Topics, 0);
487      TIntH FrameH; THash<TInt, TIntH> FrameTopicHH;
488      for (int ClustN = 0; ClustN < BowDocPart->GetClusts(); ClustN++) {
489          PBowDocPartClust Clust = BowDocPart->GetClust(ClustN);
490          TStr TopicNm = Clust->GetConceptSpV()->GetStr(BowDocBs, 3, 1, ", ", false, false);
491          TopicV.Add(TopicNm);
492          for (int DocN = 0; DocN < Clust->GetDocs(); DocN++) {
493              const int DocId = Clust->GetDId(DocN);
494              TTm DocDate = RSet->GetDocDateTime(DocId);
495              const uint FrameId = TTm::GetYearIntFromTm(DocDate);
496              FrameH.AddDat(FrameId)++;
497              FrameTopicHH.AddDat(FrameId).AddDat(ClustN)++;
498          }
499      }
500      const int Frames = FrameH.Len();
501      FrameV.Gen(Frames, 0);
502      TopicFrameFqVV.Gen(Topics, Frames); TopicFrameFqVV.PutAll(0.0);
503      FrameH.SortByKey(); int FrameKeyId = FrameH.FFirstKeyId();
504      while (FrameH.FNextKeyId(FrameKeyId)) {
505          int FrameId = FrameH.GetKey(FrameKeyId);
506          TTm FrameDate = TTm::GetTmFromDateTimeInt(FrameId);
507          TStr FrameNm = TStr::Fmt("%4d", FrameDate.GetYear());
508          const int FrameN = FrameV.Add(FrameNm);
509          const TIntH& TopicH = FrameTopicHH.GetDat(FrameId);
510          int TopicKeyId = TopicH.FFirstKeyId(); int CountSum = 0;
511          while (TopicH.FNextKeyId(TopicKeyId)) {
512              const int TopicN = TopicH.GetKey(TopicKeyId);
513              int TopicCount = TInt::Abs(TopicH.GetDat(TopicKeyId)) > 1000 ?
514                  0 : TopicH.GetDat(TopicKeyId)();
515              CountSum += TopicCount;
516              const double Fq = double(CountSum); 
517              TopicFrameFqVV(TopicN, FrameN) = Fq;
518          }
519      }
520  }
521  TTrGixItem::TTrGixItem(const TBlobPt& BlobPt, const int& _SubjectId,
522      const int& _PredicatId, const int& _ObjectId, const int& _WdId,
523      const uchar& Type, const uchar& Pos, const bool& Full, const bool& Stem,
524      const uchar& Hyper): Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()),
525          SubjectId(_SubjectId), PredicatId(_PredicatId), ObjectId(_ObjectId), WdId(_WdId) {
526      SetWordInfo(Type, Pos, Full, Stem, Hyper);
527      ClrMergeInfo();
528  }
529  TTrGixItem::TTrGixItem(TSIn& SIn) {
530      SIn.Load(Seg); SIn.Load(Addr);
531      SIn.Load(SubjectId);
532      SIn.Load(PredicatId);
533      SIn.Load(ObjectId);
534      SIn.Load(WdId);
535      SIn.Load(WdInfo);
536      ClrMergeInfo();
537  }
538  void TTrGixItem::Save(TSOut& SOut) const {
539      SOut.Save(Seg); SOut.Save(Addr);
540      SOut.Save(SubjectId);
541      SOut.Save(PredicatId);
542      SOut.Save(ObjectId);
543      SOut.Save(WdId);
544      SOut.Save(WdInfo);
545  }
546  bool TTrGixItem::operator==(const TTrGixItem& Item) const {
547      return ((Seg==Item.Seg)&&(Addr==Item.Addr)&&
548          (SubjectId==Item.SubjectId)&&
549          (PredicatId==Item.PredicatId)&&
550          (ObjectId==Item.ObjectId));
551  }
552  bool TTrGixItem::operator<(const TTrGixItem& Item) const {
553      return (Seg<Item.Seg) ||
554          ((Seg==Item.Seg)&&(Addr<Item.Addr)) ||
555          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId<Item.SubjectId)) ||
556          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId<Item.PredicatId)) ||
557          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId==Item.PredicatId)&&(ObjectId<Item.ObjectId));
558  }
559  void TTrGixItem::SetWordInfo(const uchar& Type, const uchar& Pos,
560          const bool& Full, const bool& Stem, const uchar& Hyper) {
561      TTrGixItemWdInfo Info;
562      Info.Short = 0;
563      Info.Bits.Type = Type;
564      Info.Bits.Pos = Type;
565      Info.Bits.Full = Full ? 1 : 0;
566      Info.Bits.Stem = Stem ? 1 : 0;
567      Info.Bits.Hyper = Hyper;
568      WdInfo = Info.Short;
569  }
570  char TTrGix::SubjectType = 0;
571  char TTrGix::SubjectWdType = 1;
572  char TTrGix::SubjectAttrWdType = 2;
573  char TTrGix::SubjectStemType = 3;
574  char TTrGix::SubjectAttrStemType = 4;
575  char TTrGix::PredicatType = 5;
576  char TTrGix::PredicatWdType = 6;
577  char TTrGix::PredicatAttrWdType = 7;
578  char TTrGix::PredicatStemType = 8;
579  char TTrGix::PredicatAttrStemType = 9;
580  char TTrGix::ObjectType = 10;
581  char TTrGix::ObjectWdType = 11;
582  char TTrGix::ObjectAttrWdType = 12;
583  char TTrGix::ObjectStemType = 13;
584  char TTrGix::ObjectAttrStemType = 14;
585  void TTrGix::AddTrPart(const int& FullId, const char& Type, const int& SubjectId,
586          const int& PredicatId, const int& ObjectId, const TBlobPt& BlobPt) {
587      Gix->AddItem(TTrGixKey(FullId, Type),
588          TTrGixItem(BlobPt, SubjectId, PredicatId,
589              ObjectId, FullId, Type, 0, true, false, 0));
590  }
591  void TTrGix::AddTrPart(const TIntPrV& IdPrV, const char& WdType, const char& StemType,
592          const int& SubjectId, const int& PredicatId, const int& ObjectId,
593          const TBlobPt& BlobPt) {
594      for (int IdPrN = 0; IdPrN < IdPrV.Len(); IdPrN++) {
595          const int WdId = IdPrV[IdPrN].Val1;
596          Gix->AddItem(TTrGixKey(WdId, WdType),
597              TTrGixItem(BlobPt, SubjectId, PredicatId,
598                  ObjectId, WdId, WdType, IdPrN, false, false, 0));
599          const int StemId = IdPrV[IdPrN].Val2;
600          Gix->AddItem(TTrGixKey(StemId, StemType),
601              TTrGixItem(BlobPt, SubjectId, PredicatId,
602                  ObjectId, StemId, StemType, IdPrN, false, true, 0));
603      }
604  }
605  TTrGix::PTGixExpItem TTrGix::GetExactExp(const TStr& Str, const char& Type) {
606      TTrGixKey FullTrKey = TTrGixKey(GetWordId(Str, false), Type);
607      return TTGixExpItem::NewItem(FullTrKey);
608  }
609  TTrGix::PTGixExpItem TTrGix::GetPartExp(const TStr& Str, const char& WdType, const char& StemType) {
610      TIntPrV WordStemIdV; GetWordIdV(Str, WordStemIdV, false);
611      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
612      for (int WordStemIdN = 0; WordStemIdN < WordStemIdV.Len(); WordStemIdN++) {
613          TTrGixKey WdKey(WordStemIdV[WordStemIdN].Val1, WdType);
614          TTrGixKey StemKey(WordStemIdV[WordStemIdN].Val2, StemType);
615          PTGixExpItem ExpItem = TTGixExpItem::NewOr(
616              TTGixExpItem::NewItem(WdKey), TTGixExpItem::NewItem(StemKey));
617          if (Exp->IsEmpty()) { Exp = ExpItem; }
618          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
619      }
620      return Exp;
621  }
622  TTrGix::TTrGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
623      FPath = _FPath; FAccess = _FAccess;
624      Gix = TTGix::New(TGixConst::TrGixFNm, FPath, FAccess, CacheSize);
625      if (FAccess == faCreate) {
626          Stemmer = TStemmer::New(stmtPorter, true);
627      } else {
628          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
629          TFIn FIn(TrGixDatFNm);
630          WordH.Load(FIn);
631          Stemmer = TStemmer::Load(FIn);
632      }
633  }
634  TTrGix::~TTrGix() {
635      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
636          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
637          TFOut FOut(TrGixDatFNm);
638          WordH.Save(FOut);
639          Stemmer->Save(FOut);
640      }
641  }
642  int TTrGix::GetWordId(const TStr& WordStr, const bool& AddIfNotExistP) {
643      if (WordStr.Empty()) { return -1; }
644      if (AddIfNotExistP) { return WordH.AddKey(WordStr.GetUc()); }
645      else { return WordH.GetKeyId(WordStr.GetUc()); }
646  }
647  inline TStr TTrGix::GetWordStr(const int& WId) const {
648      return WId != -1 ? WordH.GetKey(WId) : "";
649  }
650  void TTrGix::GetWordIdV(const TStr& Str,
651          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
652      PSIn HtmlSIn = TStrIn::New(Str);
653      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
654      while (HtmlLx.Sym != hsyEof) {
655          if (HtmlLx.Sym == hsyStr) {
656              const TStr WordStr = HtmlLx.UcChA;
657              const int WordId = GetWordId(WordStr, AddIfNotExistP);
658              const int StemId = GetWordId(Stemmer->GetStem(WordStr), AddIfNotExistP);
659              WordStemIdV.Add(TIntPr(WordId, StemId));
660          }
661          HtmlLx.GetSym();
662      }
663  }
664  void TTrGix::GetWordIdV(const TStrV& WordStrV,
665          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
666      for (int WordStrN = 0; WordStrN < WordStrV.Len(); WordStrN++) {
667          GetWordIdV(WordStrV[WordStrN], WordStemIdV, AddIfNotExistP);
668      }
669  }
670  void TTrGix::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
671          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
672          const TStrV& ObjectAttrV, const TBlobPt& BlobPt) {
673      const int SubjectId = GetWordId(SubjectStr, true);
674      const int PredicatId = GetWordId(PredicatStr, true);
675      const int ObjectId = GetWordId(ObjectStr, true);
676      AddTrPart(SubjectId, SubjectType, SubjectId, PredicatId, ObjectId, BlobPt);
677      AddTrPart(PredicatId, PredicatType, SubjectId, PredicatId, ObjectId, BlobPt);
678      AddTrPart(ObjectId, ObjectType, SubjectId, PredicatId, ObjectId, BlobPt);
679      TIntPrV SubjectWIdSIdV; GetWordIdV(SubjectStr, SubjectWIdSIdV, true);
680      TIntPrV SubjectAttrWIdSIdV; GetWordIdV(SubjectAttrV, SubjectAttrWIdSIdV, true);
681      TIntPrV PredicatWIdSIdV; GetWordIdV(PredicatStr, PredicatWIdSIdV, true);
682      TIntPrV PredicatAttrWIdSIdV; GetWordIdV(PredicatAttrV, PredicatAttrWIdSIdV, true);
683      TIntPrV ObjectWIdSIdV; GetWordIdV(ObjectStr, ObjectWIdSIdV, true);
684      TIntPrV ObjectAttrWIdSIdV; GetWordIdV(ObjectAttrV, ObjectAttrWIdSIdV, true);
685      AddTrPart(SubjectWIdSIdV, SubjectWdType, SubjectStemType,
686          SubjectId, PredicatId, ObjectId, BlobPt);
687      AddTrPart(SubjectAttrWIdSIdV, SubjectAttrWdType, SubjectAttrStemType,
688          SubjectId, PredicatId, ObjectId, BlobPt);
689      AddTrPart(PredicatWIdSIdV, PredicatWdType, PredicatStemType,
690          SubjectId, PredicatId, ObjectId, BlobPt);
691      AddTrPart(PredicatAttrWIdSIdV, PredicatAttrWdType, PredicatAttrStemType,
692          SubjectId, PredicatId, ObjectId, BlobPt);
693      AddTrPart(ObjectWIdSIdV, ObjectWdType, ObjectStemType,
694          SubjectId, PredicatId, ObjectId, BlobPt);
695      AddTrPart(ObjectAttrWIdSIdV, ObjectAttrWdType, ObjectAttrStemType,
696          SubjectId, PredicatId, ObjectId, BlobPt);
697  }
698  bool TTrGix::SearchExact(const TStr& SubjectStr, const TStr& PredicatStr,
699          const TStr& ObjectStr, TTrGixItemV& ResItemV) {
700      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
701      if (!SubjectStr.Empty()) {
702          PTGixExpItem ExpItem = GetExactExp(SubjectStr, SubjectType);
703          if (Exp->IsEmpty()) { Exp = ExpItem; }
704          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
705      }
706      if (!PredicatStr.Empty()) {
707          PTGixExpItem ExpItem = GetExactExp(PredicatStr, PredicatType);
708          if (Exp->IsEmpty()) { Exp = ExpItem; }
709          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
710      }
711      if (!ObjectStr.Empty()) {
712          PTGixExpItem ExpItem = GetExactExp(ObjectStr, ObjectType);
713          if (Exp->IsEmpty()) { Exp = ExpItem; }
714          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
715      }
716      return Exp->Eval(Gix, ResItemV);
717  }
718  bool TTrGix::SearchPart(const TStr& SubjectStr, const TStr& PredicatStr,
719          const TStr& ObjectStr, TTrGixItemV& ResItemV, const bool& IncExactP) {
720      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
721      if (!SubjectStr.Empty()) {
722          PTGixExpItem ExpItem = GetPartExp(SubjectStr, SubjectWdType, SubjectStemType);
723          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(SubjectStr, SubjectType), ExpItem); }
724          if (Exp->IsEmpty()) { Exp = ExpItem; }
725          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
726      }
727      if (!PredicatStr.Empty()) {
728          PTGixExpItem ExpItem = GetPartExp(PredicatStr, PredicatWdType, PredicatStemType);
729          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(PredicatStr, PredicatType), ExpItem); }
730          if (Exp->IsEmpty()) { Exp = ExpItem; }
731          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
732      }
733      if (!ObjectStr.Empty()) {
734          PTGixExpItem ExpItem = GetPartExp(ObjectStr, ObjectWdType, ObjectStemType);
735          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(ObjectStr, ObjectType), ExpItem); }
736          if (Exp->IsEmpty()) { Exp = ExpItem; }
737          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
738      }
739      return Exp->Eval(Gix, ResItemV);
740  }
741  void TTrGixRSet::AddTr(const TStrTr& TrStr, const TBlobPtV& TrAttrBlobPtV) {
742      TrStrV.Add(TrStr);
743      TrAttrBlobPtVV.Add(TrAttrBlobPtV);
744  }
745  void TTrGixRSet::GetSubjectV(TStrIntKdV& SubjectStrWgtV) {
746      TIntStrKdV SubjectWgtStrV;
747      for (int TrN = 0; TrN < GetTrs(); TrN++) {
748          const TStr& SubjectStr = TrStrV[TrN].Val1;
749          const int Wgt = GetTrCount(TrN);
750          SubjectWgtStrV.Add(TIntStrKd(Wgt, SubjectStr));
751      }
752      SubjectWgtStrV.Sort(false);
753      GetSwitchedKdV<TInt, TStr>(SubjectWgtStrV, SubjectStrWgtV);
754  }
755  void TTrGixRSet::GetPredicatV(TStrIntKdV& PredicatStrWgtV) {
756      TIntStrKdV PredicatWgtStrV;
757      for (int TrN = 0; TrN < GetTrs(); TrN++) {
758          const TStr& PredicatStr = TrStrV[TrN].Val2;
759          const int Wgt = GetTrCount(TrN);
760          PredicatWgtStrV.Add(TIntStrKd(Wgt, PredicatStr));
761      }
762      PredicatWgtStrV.Sort(false);
763      GetSwitchedKdV<TInt, TStr>(PredicatWgtStrV, PredicatStrWgtV);
764  }
765  void TTrGixRSet::GetObjectV(TStrIntKdV& ObjectStrWgtV) {
766      TIntStrKdV ObjectWgtStrV;
767      for (int TrN = 0; TrN < GetTrs(); TrN++) {
768          const TStr& ObjectStr = TrStrV[TrN].Val3;
769          const int Wgt = GetTrCount(TrN);
770          ObjectWgtStrV.Add(TIntStrKd(Wgt, ObjectStr));
771      }
772      ObjectWgtStrV.Sort(false);
773      GetSwitchedKdV<TInt, TStr>(ObjectWgtStrV, ObjectStrWgtV);
774  }
775  void TTrGixRSet::PrintRes(const bool& PrintSentsP, PNotify Notify) const {
776      printf("Query:\n");
777      printf("  Subject: '%s'\n", GetSubjectStr().CStr());
778      printf("  Predicat: '%s'\n", GetPredicatStr().CStr());
779      printf("  Object: '%s'\n", GetObjectStr().CStr());
780      printf("Displaying: %d - %d (All hits: %d)\n",
781          GetOffset()+1, Offset.Val+GetTrs()+1, GetAllTrs());
782      for (int TrN = 0; TrN < GetTrs(); TrN++) {
783          printf("%d. [%s <- %s -> %s], (Support:%d)\n", TrN+GetOffset()+1,
784              GetTrSubjectStr(TrN).CStr(), GetTrPredicatStr(TrN).CStr(),
785              GetTrObjectStr(TrN).CStr(), GetTrCount(TrN));
786      }
787  }
788  void TTrGixBs::GetAttrV(PXmlTok XmlTok, TStrV& AttrV) {
789      TXmlTokV AttrTokV; XmlTok->GetTagTokV("attrib", AttrTokV);
790      for (int AttrTokN = 0; AttrTokN < AttrTokV.Len(); AttrTokN++) {
791          PXmlTok AttrTok = AttrTokV[AttrTokN];
792          AttrV.Add(AttrTok->GetStrArgVal("word"));
793          GetAttrV(AttrTok, AttrV);
794      }
795  }
796  TTrGixBs::TTrGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
797      FPath = _FPath; FAccess = _FAccess;
798      TStr TrGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDocBsFNm;
799      DocBBs = TMBlobBs::New(TrGixDocBsFNm, FAccess);
800      TStr TrGixSentBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixSentBsFNm;
801      SentBBs = TMBlobBs::New(TrGixSentBsFNm, FAccess);
802      TStr TrGixTrAttrBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixTrAttrBsFNm;
803      TrAttrBBs = TMBlobBs::New(TrGixTrAttrBsFNm, FAccess);
804      TrGix = TTrGix::New(FPath, FAccess, CacheSize);
805  }
806  TTrGixBs::~TTrGixBs() {
807      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
808      }
809  }
810  TBlobPt TTrGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr, const TStrV& CatNmV) {
811      TMOut DocMOut;
812      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
813      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
814      return DocBlobPt;
815  }
816  TBlobPt TTrGixBs::AddSent(const TStr& SentStr) {
817      TMOut SentMOut; SentStr.Save(SentMOut);
818      TBlobPt SentBlobPt = SentBBs->PutBlob(SentMOut.GetSIn());
819      return SentBlobPt;
820  }
821  TBlobPt TTrGixBs::AddTrAttr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
822          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
823          const TStrV& ObjectAttrV, const TBlobPt& SentBlobPt, const TBlobPt& DocBlobPt) {
824      TMOut TrAttrMOut;
825      SubjectStr.Save(TrAttrMOut); SubjectAttrV.Save(TrAttrMOut);
826      PredicatStr.Save(TrAttrMOut); PredicatAttrV.Save(TrAttrMOut);
827      ObjectStr.Save(TrAttrMOut); ObjectAttrV.Save(TrAttrMOut);
828      SentBlobPt.Save(TrAttrMOut); DocBlobPt.Save(TrAttrMOut);
829      TBlobPt TrAttrBlobPt = TrAttrBBs->PutBlob(TrAttrMOut.GetSIn());
830      return TrAttrBlobPt;
831  }
832  void TTrGixBs::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
833          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
834          const TStrV& ObjectAttrV, const TBlobPt& TrAttrBlobPt) {
835      TrGix->AddTr(SubjectStr, SubjectAttrV, PredicatStr,
836          PredicatAttrV, ObjectStr, ObjectAttrV, TrAttrBlobPt);
837  }
838  void TTrGixBs::GetDoc(const TBlobPt& DocBlobPt, TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
839      PSIn SIn = DocBBs->GetBlob(DocBlobPt);
840      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
841  }
842  TStr TTrGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
843      PSIn SIn = DocBBs->GetBlob(BlobPt);
844      TStr DocTitle; DocTitle.Load(*SIn);
845      return DocTitle;
846  }
847  TStr TTrGixBs::GetDocStr(const TBlobPt& BlobPt) const {
848      PSIn SIn = DocBBs->GetBlob(BlobPt);
849      {TStr DocTitle; DocTitle.Load(*SIn);}
850      TStr DocStr; DocStr.Load(*SIn);
851      return DocStr;
852  }
853  TStrV TTrGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
854      PSIn SIn = DocBBs->GetBlob(BlobPt);
855      {TStr DocTitle; DocTitle.Load(*SIn);}
856      {TStr DocStr; DocStr.Load(*SIn);}
857      TStrV CatNmV; CatNmV.Load(*SIn);
858      return CatNmV;
859  }
860  TStr TTrGixBs::GetSentStr(const TBlobPt& SentBlobPt) {
861      PSIn SIn = SentBBs->GetBlob(SentBlobPt);
862      return TStr(*SIn);
863  }
864  void TTrGixBs::GetTrAttr(const TBlobPt& TrAttrBlobPt, TStr& SubjectStr,
865          TStrV& SubjectAttrV, TStr& PredicatStr, TStrV& PredicatAttrV,
866          TStr& ObjectStr, TStrV& ObjectAttrV, TBlobPt& SentBlobPt,
867          TBlobPt& DocBlobPt) {
868      PSIn SIn = TrAttrBBs->GetBlob(TrAttrBlobPt);
869      SubjectStr.Load(*SIn); SubjectAttrV.Load(*SIn);
870      PredicatStr.Load(*SIn); PredicatAttrV.Load(*SIn);
871      ObjectStr.Load(*SIn); ObjectAttrV.Load(*SIn);
872      SentBlobPt = TBlobPt(*SIn); DocBlobPt = TBlobPt(*SIn);
873  }
874  PTrGixRSet TTrGixBs::SearchTr(const TStr& SubjectStr, const TStr& PredicatStr,
875          const TStr& ObjectStr, TTrGixRankFun& RankFun, const int& Docs,
876          const int& Offset, const bool& ExactP) {
877      TTrGixItemV ResItemV;
878      if (ExactP) { TrGix->SearchExact(SubjectStr, PredicatStr, ObjectStr, ResItemV); }
879      else { TrGix->SearchPart(SubjectStr, PredicatStr, ObjectStr, ResItemV, true); }
880      THash<TIntTr, TIntV> TrToItemVH;
881      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
882          const TTrGixItem& Item = ResItemV[ItemN];
883          TrToItemVH.AddDat(Item.GetIdTr()).Add(ItemN);
884      }
885      TFltIntKdV FullWgtTrKeyIdV;
886      int TrKeyId = TrToItemVH.FFirstKeyId();
887      while (TrToItemVH.FNextKeyId(TrKeyId)) {
888          const double Wgt = RankFun(TrToItemVH[TrKeyId].Len());
889          FullWgtTrKeyIdV.Add(TFltIntKd(Wgt, TrKeyId));
890      }
891      TFltIntKdV WgtTrKeyIdV;
892      if (Docs == -1) {
893          WgtTrKeyIdV = FullWgtTrKeyIdV;
894      } else if (ResItemV.Len() >= (Docs + Offset)) {
895          WgtTrKeyIdV = FullWgtTrKeyIdV;
896          WgtTrKeyIdV.Sort(false); WgtTrKeyIdV.Trunc(Docs + Offset);
897          WgtTrKeyIdV.Sort(true); WgtTrKeyIdV.Trunc(Docs);
898      } else if (ResItemV.Len() > Offset) {
899          WgtTrKeyIdV = FullWgtTrKeyIdV; WgtTrKeyIdV.Sort(true);
900          WgtTrKeyIdV.Trunc(FullWgtTrKeyIdV.Len() - Offset);
901      } else {
902      }
903      WgtTrKeyIdV.Sort(false);
904      PTrGixRSet RSet = TTrGixRSet::New(SubjectStr, PredicatStr,
905          ObjectStr, FullWgtTrKeyIdV.Len(), Offset);
906      for (int TrN = 0; TrN < WgtTrKeyIdV.Len(); TrN++) {
907          const int TrKeyId = WgtTrKeyIdV[TrN].Dat;
908          const TIntTr& WIdTr = TrToItemVH.GetKey(TrKeyId);
909          const TIntV& ItemV = TrToItemVH[TrKeyId];
910          TStr SubjectStr = TrGix->GetWordStr(WIdTr.Val1);
911          TStr PredicatStr = TrGix->GetWordStr(WIdTr.Val2);
912          TStr ObjectStr = TrGix->GetWordStr(WIdTr.Val3);
913          TStrTr TrStr(SubjectStr, PredicatStr, ObjectStr);
914          TBlobPtV TrAttrBlobPtV;
915          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
916              const TTrGixItem& Item = ResItemV[ItemV[ItemN]];
917              TBlobPt TrAttrBlobPt = Item.GetBlobPt();
918              TrAttrBlobPtV.Add(TrAttrBlobPt);
919          }
920          RSet->AddTr(TrStr, TrAttrBlobPtV);
921      }
922      return RSet;
923  }
924  void TTrGixBs::AddReuters(const TStr& XmlFNm, int& Trs, const PSOut& CsvOut) {
925      PNotify Notify = TStdNotify::New();
926      TBlobPt EmptyDocBlobPt = AddDoc("No full document text!");
927      PSIn XmlSIn = TFIn::New(XmlFNm);
928      TXmlDoc::SkipTopTag(XmlSIn);
929      PXmlDoc XmlDoc; int XmlDocs = 0;
930      forever{
931          if (Trs % 100 == 0) { Notify->OnStatus(TStr::Fmt("%d\r", Trs)); }
932          XmlDocs++; XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
933          if (!XmlDoc->IsOk()) { break; }
934          PXmlTok TopTok = XmlDoc->GetTok();
935          if (TopTok->IsTag("sentence")){
936              TStr DocStr = ""; TBlobPt DocBlobPt = EmptyDocBlobPt;
937              TStr SentStr = TopTok->GetTagTok("originalSentence")->GetTokStr(false);
938              TBlobPt SentBlobPt = AddSent(SentStr);
939              TXmlTokV TrTokV; TopTok->GetTagTokV("triplet", TrTokV);
940              for (int TrTokN = 0; TrTokN < TrTokV.Len(); TrTokN++) {
941                  PXmlTok TrTok = TrTokV[TrTokN];
942                  TStr SubjectStr = TrTok->GetTagTok("subject")->GetStrArgVal("word");
943                  TStr PredicatStr = TrTok->GetTagTok("verb")->GetStrArgVal("word");
944                  TStr ObjectStr = TrTok->GetTagTok("object")->GetStrArgVal("word");
945                  TStrV SubjectAttrV; GetAttrV(TrTok->GetTagTok("subject"), SubjectAttrV);
946                  TStrV PredicatAttrV; GetAttrV(TrTok->GetTagTok("verb"), PredicatAttrV);
947                  TStrV ObjectAttrV; GetAttrV(TrTok->GetTagTok("object"), ObjectAttrV);
948                  TBlobPt TrAttrBlobPt = AddTrAttr(SubjectStr, SubjectAttrV,
949                      PredicatStr, PredicatAttrV, ObjectStr, ObjectAttrV,
950                      SentBlobPt, DocBlobPt);
951                  AddTr(SubjectStr, SubjectAttrV, PredicatStr, PredicatAttrV,
952                      ObjectStr, ObjectAttrV, TrAttrBlobPt);
953                  Trs++;
954                  if (!CsvOut.Empty()) {
955                      SubjectStr.DelChAll(','); CsvOut->PutStr(SubjectStr + ",");
956                      PredicatStr.DelChAll(','); CsvOut->PutStr(PredicatStr + ",");
957                      ObjectStr.DelChAll(','); CsvOut->PutStr(ObjectStr + ",");
958                      CsvOut->PutStr(TStr::Fmt("%u,", uint(SentBlobPt.GetSeg())));
959                      CsvOut->PutStr(TStr::Fmt("%u,", SentBlobPt.GetAddr()));
960                      CsvOut->PutStr(TStr::Fmt("%d,", SubjectAttrV.Len()));
961                      for (int AttrN = 0; AttrN < SubjectAttrV.Len(); AttrN++) {
962                          SubjectAttrV[AttrN].DelChAll(',');
963                          CsvOut->PutStr(SubjectAttrV[AttrN]);
964                          CsvOut->PutStr(",");
965                      }
966                      CsvOut->PutStr(TStr::Fmt("%d,", PredicatAttrV.Len()));
967                      for (int AttrN = 0; AttrN < PredicatAttrV.Len(); AttrN++) {
968                          PredicatAttrV[AttrN].DelChAll(',');
969                          CsvOut->PutStr(PredicatAttrV[AttrN]);
970                          CsvOut->PutStr(",");
971                      }
972                      CsvOut->PutStr(TStr::Fmt("%d,", ObjectAttrV.Len()));
973                      for (int AttrN = 0; AttrN < ObjectAttrV.Len(); AttrN++) {
974                          ObjectAttrV[AttrN].DelChAll(',');
975                          CsvOut->PutStr(ObjectAttrV[AttrN]);
976                          CsvOut->PutStr(",");
977                      }
978                      CsvOut->PutStr("-1"); CsvOut->PutLn();
979                  }
980              }
981          }
982      }
983      CsvOut->Flush();
984  }
985  void TTrGixBs::IndexReuters(const TStr& XmlFPath, const TStr& CsvFNm, const int& MxTrs) {
986      PNotify Notify = TStdNotify::New();
987      Notify->OnStatus("Loading Reuters documents from " + XmlFPath + " ...\n");
988      TFFile FFile(XmlFPath, ".xml", true); TStr XmlFNm; int Files = 0, Trs = 0;
989      PSOut CsvOut; if (!CsvFNm.Empty()) { CsvOut = TFOut::New(CsvFNm); }
990      while (FFile.Next(XmlFNm) && ((MxTrs == -11)||(MxTrs > Trs))) {
991          Notify->OnStatus(TStr::Fmt("Loading %3d : %s ...", Files+1, XmlFNm.CStr()));
992          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm, Trs, CsvOut); Files++; }
993      }
994      Notify->OnStatus(TStr::Fmt("Triplets loaded: %d", Trs));
995  }
996  TMWdGixItem::TMWdGixItem(TSIn& SIn) {
997      SIn.Load(Seg); SIn.Load(Addr);
998      SIn.Load(WdFq); SIn.Load(DocWds);
999  }
1000  void TMWdGixItem::Save(TSOut& SOut) const {
1001      SOut.Save(Seg); SOut.Save(Addr);
1002      SOut.Save(WdFq); SOut.Save(DocWds);
1003  }
1004  inline bool TMWdGixItem::operator==(const TMWdGixItem& Item) const {
1005      return (Seg == Item.Seg) && (Addr == Item.Addr);
1006  }
1007  inline bool TMWdGixItem::operator<(const TMWdGixItem& Item) const {
1008      return (Seg < Item.Seg) || ((Seg == Item.Seg) && (Addr < Item.Addr));
1009  }
1010  void TMWdGixDefMerger::Union(TMWdGixItemV& DstV, const TMWdGixItemV& SrcV) const {
1011      TMWdGixItemV DstValV(TInt::GetMx(DstV.Len(), SrcV.Len()), 0);
1012      int ValN1 = 0; int ValN2 = 0;
1013      while ((ValN1<DstV.Len()) && (ValN2<SrcV.Len())){
1014          const TMWdGixItem& Val1 = DstV.GetVal(ValN1);
1015          const TMWdGixItem& Val2 = SrcV.GetVal(ValN2);
1016          if (Val1 < Val2) { DstValV.Add(Val1); ValN1++; }
1017          else if (Val1>Val2) { DstValV.Add(Val2); ValN2++; }
1018          else { DstValV.Add(TMWdGixItem(Val1, Val2)); ValN1++; ValN2++; }
1019      }
1020      for (int RestValN1=ValN1; RestValN1<DstV.Len(); RestValN1++){
1021          DstValV.Add(DstV.GetVal(RestValN1));}
1022      for (int RestValN2=ValN2; RestValN2<SrcV.Len(); RestValN2++){
1023          DstValV.Add(SrcV.GetVal(RestValN2));}
1024      DstV = DstValV;
1025  }
1026  void TMWdGixDefMerger::Def(const TInt& Key, TMWdGixItemV& ItemV) const  {
1027      const int WdDocFq = MWdGix->GetWdFq(Key);
1028      const int Docs = MWdGix->GetAllDocs();
1029      const double AvgDocWds = MWdGix->GetAvgDocWds();
1030      const int Items = ItemV.Len();
1031      for (int ItemN = 0; ItemN < Items; ItemN++) {
1032          TMWdGixItem& Item = ItemV[ItemN];
1033          const int WdFq = Item.GetWdFq();
1034          const int DocWds = Item.GetDocWds();
1035          const double Wgt = RankFun->WdRank(WdFq, DocWds, WdDocFq, Docs, AvgDocWds);
1036          Item.PutWgt(Wgt);
1037      }
1038  }
1039  TMWdGix::TMWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
1040      FPath = _FPath; FAccess = _FAccess;
1041      printf("Loading '%s' .. ", FPath.CStr());
1042      if (FAccess == faCreate) { printf("create .. "); }
1043      if (FAccess == faRdOnly) { printf("read-only .. "); }
1044      printf("Cache[%s]\n", TUInt64::GetMegaStr(CacheSize).CStr());
1045      MWGix = TMWGix::New(TGixConst::MWdGixFNm, FPath, FAccess, CacheSize);
1046      if (FAccess != faCreate) {
1047          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1048          TFIn FIn(MWdGixDatFNm);
1049          WordH.Load(FIn);
1050          AllDocs.Load(FIn);
1051          AllWords.Load(FIn);
1052      }
1053  }
1054  TMWdGix::~TMWdGix() {
1055      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1056          printf("Closing %s: docs=%d, words=%d\n",
1057              FPath.CStr(), AllDocs.Val, AllWords.Val);
1058          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1059          TFOut FOut(MWdGixDatFNm);
1060          WordH.Save(FOut);
1061          AllDocs.Save(FOut);
1062          AllWords.Save(FOut);
1063      }
1064  }
1065  void TMWdGix::AddHtml(const TStr& DocStr, const TBlobPt& BlobPt) {
1066      PSIn HtmlSIn = TStrIn::New(DocStr);
1067      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1068      TIntH DocWIdH; int DocWds = 0;
1069      while (HtmlLx.Sym != hsyEof) {
1070          if (HtmlLx.Sym == hsyStr) {
1071              TStr WordStr = HtmlLx.UcChA;
1072              const int WId = WordH.AddKey(WordStr);
1073              DocWIdH.AddDat(WId)++;
1074              DocWds++;
1075          }
1076          HtmlLx.GetSym();
1077      }
1078      int WdKeyId = DocWIdH.FFirstKeyId();
1079      while (DocWIdH.FNextKeyId(WdKeyId)) {
1080          const int WId = DocWIdH.GetKey(WdKeyId);
1081          const int WdFq = DocWIdH[WdKeyId];
1082          WordH[WId]++; 
1083          TMWdGixKey Key(WId);
1084          TMWdGixItem Item(BlobPt, WdFq, DocWds);
1085          MWGix->AddItem(Key, Item);
1086      }
1087      AllDocs++; AllWords += DocWds;
1088  }
1089  bool TMWdGix::Search(const TStr& QueryStr,
1090          TMWdGixItemV& ResItemV, const TMWdGixDefMerger& Merger) {
1091      PMWGixExpItem MWGixExp = TMWGixExpItem::NewEmpty();
1092      PSIn HtmlSIn = TStrIn::New(QueryStr);
1093      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1094      while (HtmlLx.Sym != hsyEof) {
1095          if (HtmlLx.Sym == hsyStr) {
1096              TStr WordStr = HtmlLx.UcChA;
<span onclick='openModal()' class='match'>1097              const int WId = WordH.GetKeyId(WordStr);
1098              if (WId != -1) {
1099                  PMWGixExpItem MWGixExpItem = TMWGixExpItem::NewItem(TMWdGixKey(WId));
1100                  if (MWGixExp->IsEmpty()) { MWGixExp = MWGixExpItem; }
1101                  else { MWGixExp = TMWGixExpItem::NewOr(MWGixExp, MWGixExpItem); }
</span>1102              }
1103          }
1104          HtmlLx.GetSym();
1105      }
1106      return MWGixExp->Eval(MWGix, ResItemV, Merger);
1107  }
1108  TStr TMWdGixRSet::GetMainPara(const TStr& QueryStr, const TStr& FullStr) {
1109      PBowDocBs BowDocBs = TBowDocBs::New();
1110      BowDocBs->AddHtmlDoc("Query", TStrV(), QueryStr, false);
1111      TStrV ParaV; FullStr.SplitOnAllCh('\n', ParaV);
1112      if (ParaV.Empty()) { return ""; }
1113      for (int ParaN = 0; ParaN < ParaV.Len(); ParaN++) {
1114          BowDocBs->AddHtmlDoc("Doc" + TInt::GetStr(ParaN), TStrV(), ParaV[ParaN], false);
1115      }
1116      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
1117      PBowSpV QuerySpV = BowDocWgtBs->GetSpV(0); int MxParaN = 0;
1118      double MxParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(1));
1119      for (int ParaN = 1; ParaN < ParaV.Len(); ParaN++) {
1120          const double ParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(ParaN+1));
1121          if (ParaSim > MxParaSim) {
1122              MxParaSim = ParaSim;
1123              MxParaN = ParaN;
1124          }
1125      }
1126      return ParaV[MxParaN];
1127  }
1128  void TMWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1129          const TStr& DocLang, const TStrV& KeyWdV) {
1130      DocTitleV.Add(DocTitle);
1131      DocTitleV.Last().DelChAll('\n');
1132      DocTitleV.Last().DelChAll('\r');
1133      DocStrV.Add(GetMainPara(LangQueryH.GetDat(DocLang), DocStr));
1134      DocLangV.Add(DocLang);
1135      KeyWdVV.Add(KeyWdV);
1136  }
1137  void TMWdGixRSet::PrintRes(PNotify Notify) {
1138      const int Docs = GetDocs();
1139      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1140          AllDocs.Val, Docs, Docs + Offset.Val));
1141      for (int DocN = 0; DocN < Docs; DocN++) {
1142          TStr DocStr = DocTitleV[DocN] + " - " + DocStrV[DocN];
1143          DocStr.DelChAll('\n'); DocStr.DelChAll('\r');
1144          Notify->OnStatus(TStr::Fmt("[%d:%s] %s ...", DocN+1,
1145              DocLangV[DocN].CStr(), DocStr.Left(60).CStr()));
1146      }
1147      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1148          AllDocs.Val, Docs, Docs + Offset.Val));
1149  }
1150  TStr TMWdGixRSet::GetWsXml(const TStrPrStrH& EurovocH) const {
1151      PXmlTok TopTok = TXmlTok::New("cca");
1152      TopTok->AddArg("allhits", GetAllDocs());
1153      for (int DocN = 0; DocN < GetDocs(); DocN++) {
1154          PXmlTok HitTok = TXmlTok::New("hit");
1155          HitTok->AddArg("rank", DocN+1);
1156          HitTok->AddArg("lang", DocLangV[DocN]);
1157          TStr Title = DocTitleV[DocN];
1158          if (Title.Len() > 100) { Title = Title.Left(100) + "..."; }
1159          TStr Snipet = DocStrV[DocN].Left(800);
1160          if (Snipet.Len() > 800) { Snipet = Snipet.Left(800) + "..."; }
1161          HitTok->AddSubTok(TXmlTok::New("title", Title));
1162          HitTok->AddSubTok(TXmlTok::New("snipet", Snipet));
1163          PXmlTok KeyWdTok = TXmlTok::New("keywords");
1164          const TStrV& KeyWdV = KeyWdVV[DocN]; int GoodKeyWds = 0;
1165          for (int KeyWdN = 0; KeyWdN < KeyWdV.Len(); KeyWdN++) {
1166              TStrPr KeyWd(QueryLang, KeyWdV[KeyWdN]);
1167              if (EurovocH.IsKey(KeyWd)) {
1168                  KeyWdTok->AddSubTok(TXmlTok::New("keyword", EurovocH.GetDat(KeyWd)));
1169                  GoodKeyWds++;
1170              }
1171          }
1172          HitTok->AddSubTok(KeyWdTok);
1173          if (GoodKeyWds == 0) { continue; }
1174          TopTok->AddSubTok(HitTok);
1175      }
1176      return TopTok->GetTokStr();
1177  }
1178  TMWdGixBs::TMWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& _CacheSize) {
1179      FPath = _FPath; FAccess = _FAccess; CacheSize = _CacheSize;
1180      TStr MWdGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDocBsFNm;
1181      DocBBs = TMBlobBs::New(MWdGixDocBsFNm, FAccess);
1182      if (FAccess != faCreate) {
1183          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1184          AlignPairBs = TAlignPairBs::LoadBin(MWdGixBsFNm);
1185          InitGixs(FAccess);
1186      }
1187  }
1188  TMWdGixBs::~TMWdGixBs() {
1189      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1190          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1191          AlignPairBs->SaveBin(MWdGixBsFNm);
1192      }
1193  }
1194  void TMWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1195          const TStr& DocLang, const TStrV& KeyWdV) {
1196      TMOut DocMOut;
1197      DocTitle.Save(DocMOut); DocStr.Save(DocMOut);
1198      DocLang.Save(DocMOut); KeyWdV.Save(DocMOut);
1199      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
1200      LangMWdGixH.GetDat(DocLang)->AddHtml(DocStr, DocBlobPt);
1201  }
1202  void TMWdGixBs::GetDoc(const TBlobPt& BlobPt, TStr& DocTitle,
1203          TStr& DocStr, TStr& DocLang, TStrV& KeyWdV) const {
1204      PSIn SIn = DocBBs->GetBlob(BlobPt);
1205      DocTitle.Load(*SIn); DocStr.Load(*SIn);
1206      DocLang.Load(*SIn); KeyWdV.Load(*SIn);
1207  }
1208  PMWdGixRSet TMWdGixBs::SearchDoc(const TStr& QueryStr, const TStr& QueryLang,
1209          const TStrV& TargetLangV, const int& Docs, const int& Offset,
1210          PMWdGixRankFun& RankFun) {
1211      if (!AlignPairBs->IsLang(QueryLang)) {
1212          return TMWdGixRSet::New(QueryStr, "", TStrStrH(), 0, 0); }
1213      const int Queries = TargetLangV.Len();
1214      printf("  Translationg %d queries ...\n", Queries);
1215      const int QueryLangId = AlignPairBs->GetLangId(QueryLang);
1216      TStrStrH LangQueryH;
1217      TWgtMWdGixIntItemKdV FullWgtLangItemV;
1218      for (int TargetLangN = 0; TargetLangN < Queries; TargetLangN++) {
1219          if (!AlignPairBs->IsLang(TargetLangV[TargetLangN])) { continue; }
1220          const TStr& TargetLang = TargetLangV[TargetLangN];
1221          const int TargetLangId = AlignPairBs->GetLangId(TargetLang);
1222          if (TargetLangId == QueryLangId) { continue; }
1223          TStr TargetQueryStr = AlignPairBs->MapQuery(
1224              AlignPairMap, QueryStr, QueryLangId, TargetLangId);
1225          LangQueryH.AddDat(TargetLang, TargetQueryStr);
1226          printf("  Query: '%s' -> '%s'\n", QueryStr.CStr(), TargetQueryStr.CStr());
1227          printf("  Loading from Gix ...\n");
1228          TMWdGixItemV LangResItemV;
1229          PMWdGix LangMWdGix = LangMWdGixH.GetDat(TargetLang);
1230          TMWdGixDefMerger LangMerger(LangMWdGix, RankFun);
1231          LangMWdGix->Search(TargetQueryStr, LangResItemV, LangMerger);
1232          double MxWgt = 0.0;
1233          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1234              const TMWdGixItem& Item = LangResItemV[ItemN];
1235              MxWgt = TFlt::GetMx(Item.GetWgt(), MxWgt);
1236          }
1237          printf("  MxWgt: %g\n", MxWgt);
1238          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1239              const TMWdGixItem& Item = LangResItemV[ItemN];
1240              const double Wgt = MxWgt > 0.0 ? Item.GetWgt() / MxWgt : 0.0;
1241              TMWdGixIntItemPr LangItemPr(TargetLangId, Item);
1242              FullWgtLangItemV.Add(TWgtMWdGixIntItemKd(Wgt, LangItemPr));
1243          }
1244      }
1245      FullWgtLangItemV.Sort(false);
1246      printf("  Sorting %d hits ...\n", FullWgtLangItemV.Len());
1247      TWgtMWdGixIntItemKdV WgtLangItemV;
1248      if (Docs == -1) {
1249          WgtLangItemV = FullWgtLangItemV;
1250      } else if (FullWgtLangItemV.Len() >= (Docs + Offset)) {
1251          WgtLangItemV = FullWgtLangItemV;
1252          WgtLangItemV.Sort(false); WgtLangItemV.Trunc(Docs + Offset);
1253          WgtLangItemV.Sort(true); WgtLangItemV.Trunc(Docs);
1254      } else if (FullWgtLangItemV.Len() > Offset) {
1255          WgtLangItemV = FullWgtLangItemV; WgtLangItemV.Sort(true);
1256          WgtLangItemV.Trunc(FullWgtLangItemV.Len() - Offset);
1257      } else {
1258      }
1259      WgtLangItemV.Sort(false);
1260      printf("  Loading content for %d hits ...\n", WgtLangItemV.Len());
1261      PMWdGixRSet RSet = TMWdGixRSet::New(QueryStr,
1262          QueryLang, LangQueryH, FullWgtLangItemV.Len(), Offset);
1263      for (int ItemN = 0; ItemN < WgtLangItemV.Len(); ItemN++) {
1264          const TMWdGixIntItemPr& LangItem = WgtLangItemV[ItemN].Dat;
1265          const TMWdGixItem& Item = LangItem.Val2;
1266          TBlobPt DocBlobPt = Item.GetBlobPt();
1267          TStr DocTitle, DocStr, DocLang; TStrV KeyWdV;
1268          GetDoc(DocBlobPt, DocTitle, DocStr, DocLang, KeyWdV);
1269          RSet->AddDoc(DocTitle, DocStr, DocLang, KeyWdV);
1270      }
1271      printf("  Done\n");
1272      return RSet;
1273  }
1274  void TMWdGixBs::AddAcquis(const TStr& XmlFNm, const TStr& Lang) {
1275      PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlFNm);
1276      if (!XmlDoc->IsOk()) { return; }
1277      PXmlTok TopTok = XmlDoc->GetTok();
1278      PXmlTok TextTok = TopTok->GetTagTok("text|body");
1279      if (TextTok.Empty()) { printf("  Bad file '%s'\n", XmlFNm.CStr()); return; }
1280      TStr DocTitle; TChA DocChA;
1281      for (int SubTokN = 0; SubTokN < TextTok->GetSubToks(); SubTokN++) {
1282          PXmlTok SubTok = TextTok->GetSubTok(SubTokN);
1283          if (!SubTok->IsTag()) { continue; }
1284          if (SubTok->GetTagNm() == "head") {
1285              DocTitle = SubTok->GetTokStr(false);
1286          } else if (SubTok->GetTagNm() == "div") {
1287              for (int ParaN = 0; ParaN < SubTok->GetSubToks(); ParaN++) {
1288                  if (SubTok->IsTag()) {
1289                      DocChA += SubTok->GetSubTok(ParaN)->GetTokStr(false);
1290                      DocChA += '\n';
1291                  }
1292              }
1293              DocChA += '\n';
1294          }
1295      }
1296      TStrV KeyWdV;
1297      PXmlTok KeyWdTok = TopTok->GetTagTok("teiHeader|profileDesc|textClass");
1298      if (!KeyWdTok.Empty()) {
1299          for (int SubTokN = 0; SubTokN < KeyWdTok->GetSubToks(); SubTokN++) {
1300              PXmlTok SubTok = KeyWdTok->GetSubTok(SubTokN);
1301              if (!SubTok->IsTag()) { continue; }
1302              if (SubTok->IsArg("scheme")) {
1303                  KeyWdV.Add(SubTok->GetStrArgVal("scheme") + "-" + SubTok->GetTokStr(false));
1304              }
1305          }
1306      }
1307      if (!KeyWdV.Empty()) { AddDoc(DocTitle, DocChA, Lang, KeyWdV); }
1308  }
1309  void TMWdGixBs::IndexAcquis(const TStr& InFPath, PAlignPairBs _AlignPairBs,
1310          const int& MxDocs, const int64& IndexCacheSize) {
1311      AlignPairBs = _AlignPairBs;
1312      int LangId = AlignPairBs->FFirstLangId();
1313      while (AlignPairBs->FNextLangId(LangId)) {
1314          const TStr& Lang = AlignPairBs->GetLang(LangId);
1315          TStr LangFPath = InFPath + "/" + Lang;
1316          printf("Indexing %s ...\n", LangFPath.CStr());
1317          LangMWdGixH.AddDat(Lang) =
1318                  TMWdGix::New(FPath + "/" + Lang, FAccess, IndexCacheSize);
1319          TFFile FFile(LangFPath, ".xml", true);
1320          TStr XmlFNm; int XmlFNms = 0;
1321          while (FFile.Next(XmlFNm)) {
1322              if (XmlFNms == MxDocs) { break; }
1323              if (XmlFNms % 100 == 0) { printf("  %d\r", XmlFNms); }
1324              try { AddAcquis(XmlFNm, Lang); } catch (...) { }
1325              XmlFNms++;
1326          } printf("\n");
1327          LangMWdGixH.Clr();
1328      }
1329      InitGixs(faRdOnly);
1330  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.h</h3>
            <pre><code>1  #ifndef NETWORK_H
2  #define NETWORK_H
3  template <class TNodeData>
4  class TNodeNet {
5  public:
6    typedef TNodeData TNodeDat;
7    typedef TNodeNet<TNodeData> TNet;
8    typedef TPt<TNet> PNet;
9  public:
10    class TNode {
11    private:
12      TInt Id;
13      TNodeData NodeDat;
14      TIntV InNIdV, OutNIdV;
15    public:
16      TNode() : Id(-1), NodeDat(), InNIdV(), OutNIdV() { }
17      TNode(const int& NId) : Id(NId), NodeDat(), InNIdV(), OutNIdV() { }
18      TNode(const int& NId, const TNodeData& NodeData) : Id(NId), NodeDat(NodeData), InNIdV(), OutNIdV() { }
19      TNode(const TNode& Node) : Id(Node.Id), NodeDat(Node.NodeDat), InNIdV(Node.InNIdV), OutNIdV(Node.OutNIdV) { }
20      TNode(TSIn& SIn) : Id(SIn), NodeDat(SIn), InNIdV(SIn), OutNIdV(SIn) { }
21      void Save(TSOut& SOut) const { Id.Save(SOut);  NodeDat.Save(SOut);  InNIdV.Save(SOut);  OutNIdV.Save(SOut); }
22      int GetId() const { return Id; }
23      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
24      int GetInDeg() const { return InNIdV.Len(); }
25      int GetOutDeg() const { return OutNIdV.Len(); }
26      const TNodeData& GetDat() const { return NodeDat; }
27      TNodeData& GetDat() { return NodeDat; }
28      int GetInNId(const int& NodeN) const { return InNIdV[NodeN]; }
29      int GetOutNId(const int& NodeN) const { return OutNIdV[NodeN]; }
30      int GetNbrNId(const int& NodeN) const { return NodeN<GetOutDeg() ? GetOutNId(NodeN):GetInNId(NodeN-GetOutDeg()); }
31      bool IsInNId(const int& NId) const { return InNIdV.SearchBin(NId) != -1; }
32      bool IsOutNId(const int& NId) const { return OutNIdV.SearchBin(NId) != -1; }
33      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
34      void LoadShM(TShMIn& MStream) {
35        Id = TInt(MStream);
36        NodeDat = TNodeData(MStream);
37        InNIdV.LoadShM(MStream);
38        OutNIdV.LoadShM(MStream);
39      }
40      bool operator < (const TNode& Node) const { return NodeDat < Node.NodeDat; }
41      friend class TNodeNet<TNodeData>;
42    };
43    class TNodeI {
44    private:
45      typedef typename THash<TInt, TNode>::TIter THashIter;
46      THashIter NodeHI;
47      TNodeNet *Net;
48    public:
49      TNodeI() : NodeHI(), Net(NULL) { }
50      TNodeI(const THashIter& NodeHIter, const TNodeNet* NetPt) : NodeHI(NodeHIter), Net((TNodeNet *) NetPt) { }
51      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Net(NodeI.Net) { }
52      TNodeI& operator = (const TNodeI& NodeI) { NodeHI=NodeI.NodeHI; Net=NodeI.Net; return *this; }
53      TNodeI& operator++ (int) { NodeHI++;  return *this; }
54      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
55      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
56      int GetId() const { return NodeHI.GetDat().GetId(); }
57      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
58      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
59      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
60      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
61      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
62      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
63      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
64      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
65      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
66      const TNodeData& operator () () const { return NodeHI.GetDat().NodeDat; }
67      TNodeData& operator () () { return NodeHI.GetDat().GetDat(); }
68      const TNodeData& GetDat() const { return NodeHI.GetDat().GetDat(); }
69      TNodeData& GetDat() { return NodeHI.GetDat().GetDat(); }
70      const TNodeData& GetInNDat(const int& NodeN) const { return Net->GetNDat(GetInNId(NodeN)); }
71      TNodeData& GetInNDat(const int& NodeN) { return Net->GetNDat(GetInNId(NodeN)); }
72      const TNodeData& GetOutNDat(const int& NodeN) const { return Net->GetNDat(GetOutNId(NodeN)); }
73      TNodeData& GetOutNDat(const int& NodeN) { return Net->GetNDat(GetOutNId(NodeN)); }
74      const TNodeData& GetNbrNDat(const int& NodeN) const { return Net->GetNDat(GetNbrNId(NodeN)); }
75      TNodeData& GetNbrNDat(const int& NodeN) { return Net->GetNDat(GetNbrNId(NodeN)); }
76      friend class TNodeNet<TNodeData>;
77    };
78    class TEdgeI {
79    private:
80      TNodeI CurNode, EndNode;
81      int CurEdge;
82    public:
83      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
84      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
85      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
86      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode;  EndNode=EdgeI.EndNode;  CurEdge=EdgeI.CurEdge; }  return *this; }
87      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0;  CurNode++;
88        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
89      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
90      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
91      int GetId() const { return -1; }
92      int GetSrcNId() const { return CurNode.GetId(); }
93      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
94      const TNodeData& GetSrcNDat() const { return CurNode.GetDat(); }
95      TNodeData& GetDstNDat() { return CurNode.GetOutNDat(CurEdge); }
96      friend class TNodeNet<TNodeData>;
97    };
98  protected:
99    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
100  protected:
101    TCRef CRef;
102    TInt MxNId;
103    THash<TInt, TNode> NodeH;
104  private:
105    class TNodeFunctor {
106    public:
107      TNodeFunctor() {}
108      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
109    };
110  private:
111    void LoadNetworkShM(TShMIn& ShMIn) {
112      MxNId = TInt(ShMIn);
113      TNodeFunctor f;
114      NodeH.LoadShM(ShMIn, f);
115    }
116  public:
117    TNodeNet() : CRef(), MxNId(0), NodeH() { }
118    explicit TNodeNet(const int& Nodes, const int& Edges) : MxNId(0) { Reserve(Nodes, Edges); }
119    TNodeNet(const TNodeNet& NodeNet) : MxNId(NodeNet.MxNId), NodeH(NodeNet.NodeH) { }
120    TNodeNet(TSIn& SIn) : MxNId(SIn), NodeH(SIn) { }
121    virtual ~TNodeNet() { }
122    virtual void Save(TSOut& SOut) const { MxNId.Save(SOut);  NodeH.Save(SOut); SOut.Flush(); }
123    static PNet New() { return PNet(new TNodeNet()); }
124    static PNet Load(TSIn& SIn) { return PNet(new TNodeNet(SIn)); }
125    static PNet LoadShM(TShMIn& ShMIn) {
126      TNodeNet* Network = new TNodeNet();
127      Network->LoadNetworkShM(ShMIn);
128      return PNet(Network);
129    }
130    bool HasFlag(const TGraphFlag& Flag) const;
131    TNodeNet& operator = (const TNodeNet& NodeNet) {
132      if (this!=&NodeNet) { NodeH=NodeNet.NodeH;  MxNId=NodeNet.MxNId; }  return *this; }
133    int GetNodes() const { return NodeH.Len(); }
134    int AddNode(int NId = -1);
135    int AddNodeUnchecked(int NId = -1);
136    int AddNode(int NId, const TNodeData& NodeDat);
137    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId(), NodeI.GetDat()); }
138    virtual void DelNode(const int& NId);
139    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
140    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
141    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
142    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
143    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
144    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
145    void SetNDat(const int& NId, const TNodeData& NodeDat);
146    TNodeData& GetNDat(const int& NId) { return NodeH.GetDat(NId).NodeDat; }
147    const TNodeData& GetNDat(const int& NId) const { return NodeH.GetDat(NId).NodeDat; }
148    int GetMxNId() const { return MxNId; }
149    int GetEdges() const;
150    int AddEdge(const int& SrcNId, const int& DstNId);
151    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
152    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
153    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
154    TEdgeI BegEI() const { TNodeI NI=BegNI();  while(NI<EndNI() && NI.GetOutDeg()==0) NI++;  return TEdgeI(NI, EndNI()); }
155    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
156    TEdgeI GetEI(const int& EId) const;
157    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
158    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
159    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
160    void GetNIdV(TIntV& NIdV) const;
161    bool Empty() const { return GetNodes()==0; }
162    void Clr(const bool& DoDel=true, const bool& ResetDat=true) {
163      MxNId = 0;  NodeH.Clr(DoDel, -1, ResetDat); }
164    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes/2); } }
165    void SortNIdById(const bool& Asc=true) { NodeH.SortByKey(Asc); }
166    void SortNIdByDat(const bool& Asc=true) { NodeH.SortByDat(Asc); }
167    void Defrag(const bool& OnlyNodeLinks=false);
168    bool IsOk(const bool& ThrowExcept=true) const;
169    friend class TPt<TNodeNet<TNodeData> >;
170  };
171  namespace TSnap {
172  template <class TNodeData> struct IsDirected<TNodeNet<TNodeData> > { enum { Val = 1 }; };
173  template <class TNodeData> struct IsNodeDat<TNodeNet<TNodeData> > { enum { Val = 1 }; };
174  }
175  template <class TNodeData>
176  bool TNodeNet<TNodeData>::HasFlag(const TGraphFlag& Flag) const {
177    return HasGraphFlag(typename TNet, Flag);
178  }
179  template <class TNodeData>
180  int TNodeNet<TNodeData>::AddNode(int NId) {
181    if (NId == -1) {
182      NId = MxNId;  MxNId++;
183    } else {
184      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
185      MxNId = TMath::Mx(NId+1, MxNId());
186    }
187    NodeH.AddDat(NId, TNode(NId));
188    return NId;
189  }
190  template <class TNodeData>
191  int TNodeNet<TNodeData>::AddNodeUnchecked(int NId) {
192    if (NId == -1) {
193      NId = MxNId;  MxNId++;
194    } else {
195      if (IsNode(NId)) { return -1;}
196      MxNId = TMath::Mx(NId+1, MxNId());
197    }
198    NodeH.AddDat(NId, TNode(NId));
199    return NId;
200  }
201  template <class TNodeData>
202  int TNodeNet<TNodeData>::AddNode(int NId, const TNodeData& NodeDat) {
203    if (NId == -1) {
204      NId = MxNId;  MxNId++;
205    } else {
206      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
207      MxNId = TMath::Mx(NId+1, MxNId());
208    }
209    NodeH.AddDat(NId, TNode(NId, NodeDat));
210    return NId;
211  }
212  template <class TNodeData>
213  void TNodeNet<TNodeData>::DelNode(const int& NId) {
214    { TNode& Node = GetNode(NId);
215    for (int e = 0; e < Node.GetOutDeg(); e++) {
216    const int nbr = Node.GetOutNId(e);
217    if (nbr == NId) { continue; }
218      TNode& N = GetNode(nbr);
219      int n = N.InNIdV.SearchBin(NId);
220      if (n!= -1) { N.InNIdV.Del(n); }
221    }
222    for (int e = 0; e < Node.GetInDeg(); e++) {
223    const int nbr = Node.GetInNId(e);
224    if (nbr == NId) { continue; }
225      TNode& N = GetNode(nbr);
226      int n = N.OutNIdV.SearchBin(NId);
227      if (n!= -1) { N.OutNIdV.Del(n); }
228    } }
229    NodeH.DelKey(NId);
230  }
231  template <class TNodeData>
232  void TNodeNet<TNodeData>::SetNDat(const int& NId, const TNodeData& NodeDat) {
233    IAssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist.", NId).CStr());
234    NodeH.GetDat(NId).NodeDat = NodeDat;
235  }
236  template <class TNodeData>
237  int TNodeNet<TNodeData>::GetEdges() const {
238    int edges=0;
239    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N);) {
240      edges+=NodeH[N].GetOutDeg(); }
241    return edges;
242  }
243  template <class TNodeData>
244  int TNodeNet<TNodeData>::AddEdge(const int& SrcNId, const int& DstNId) {
245    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
246    if (IsEdge(SrcNId, DstNId)) { return -2; }
247    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
248    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
249    return -1; 
250  }
251  template <class TNodeData>
252  void TNodeNet<TNodeData>::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
253    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
254    GetNode(SrcNId).OutNIdV.DelIfIn(DstNId);
255    GetNode(DstNId).InNIdV.DelIfIn(SrcNId);
256    if (! IsDir) {
257      GetNode(DstNId).OutNIdV.DelIfIn(SrcNId);
258      GetNode(SrcNId).InNIdV.DelIfIn(DstNId);
259    }
260  }
261  template <class TNodeData>
262  bool TNodeNet<TNodeData>::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
263    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
264    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
265    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
266  }
267  template <class TNodeData>
268  void TNodeNet<TNodeData>::GetNIdV(TIntV& NIdV) const {
269    NIdV.Reserve(GetNodes(), 0);
270    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
271      NIdV.Add(NodeH.GetKey(N)); }
272  }
273  template <class TNodeData>
274  typename TNodeNet<TNodeData>::TEdgeI  TNodeNet<TNodeData>::GetEI(const int& SrcNId, const int& DstNId) const {
275    const TNodeI SrcNI = GetNI(SrcNId);
276    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
277    if (NodeN == -1) { return EndEI(); }
278    return TEdgeI(SrcNI, EndNI(), NodeN);
279  }
280  template <class TNodeData>
281  void TNodeNet<TNodeData>::Defrag(const bool& OnlyNodeLinks) {
282    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
283      TNode& Node = NodeH[n];
284      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
285    }
286    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
287      NodeH.Defrag(); }
288  }
289  template <class TNodeData>
290  bool TNodeNet<TNodeData>::IsOk(const bool& ThrowExcept) const {
291    bool RetVal = true;
292    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
293      const TNode& Node = NodeH[N];
294      if (! Node.OutNIdV.IsSorted()) {
295        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
296        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
297      }
298      if (! Node.InNIdV.IsSorted()) {
299        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
300        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
301      }
302      int prevNId = -1;
303      for (int e = 0; e < Node.GetOutDeg(); e++) {
304        if (! IsNode(Node.GetOutNId(e))) {
305          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
306            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
307          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
308        }
309        if (e > 0 && prevNId == Node.GetOutNId(e)) {
310          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
311            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
312          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
313        }
314        prevNId = Node.GetOutNId(e);
315      }
316      prevNId = -1;
317      for (int e = 0; e < Node.GetInDeg(); e++) {
318        if (! IsNode(Node.GetInNId(e))) {
319          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
320            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
321          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
322        }
323        if (e > 0 && prevNId == Node.GetInNId(e)) {
324          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
325            Node.GetId(), Node.GetId(), Node.GetInNId(e));
326          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
327        }
328        prevNId = Node.GetInNId(e);
329      }
330    }
331    return RetVal;
332  }
333  typedef TNodeNet<TInt> TIntNNet;
334  typedef TPt<TIntNNet> PIntNNet;
335  typedef TNodeNet<TFlt> TFltNNet;
336  typedef TPt<TFltNNet> PFltNNet;
337  typedef TNodeNet<TStr> TStrNNet;
338  typedef TPt<TStrNNet> PStrNNet;
339  template <class TNodeData, class TEdgeData>
340  class TNodeEDatNet {
341  public:
342    typedef TNodeData TNodeDat;
343    typedef TEdgeData TEdgeDat;
344    typedef TNodeEDatNet<TNodeData, TEdgeData> TNet;
345    typedef TPt<TNet> PNet;
346    typedef TVec<TPair<TInt, TEdgeData> > TNIdDatPrV;
347  public:
348    class TNode {
349    private:
350      TInt  Id;
351      TNodeData NodeDat;
352      TIntV InNIdV;
353      TNIdDatPrV OutNIdV;
354    public:
355      TNode() : Id(-1), NodeDat(), InNIdV(), OutNIdV() { }
356      TNode(const int& NId) : Id(NId), NodeDat(), InNIdV(), OutNIdV() { }
357      TNode(const int& NId, const TNodeData& NodeData) : Id(NId), NodeDat(NodeData), InNIdV(), OutNIdV() { }
358      TNode(const TNode& Node) : Id(Node.Id), NodeDat(Node.NodeDat), InNIdV(Node.InNIdV), OutNIdV(Node.OutNIdV) { }
359      TNode(TSIn& SIn) : Id(SIn), NodeDat(SIn), InNIdV(SIn), OutNIdV(SIn) { }
360      void Save(TSOut& SOut) const { Id.Save(SOut);  NodeDat.Save(SOut);  InNIdV.Save(SOut);  OutNIdV.Save(SOut); }
361      int GetId() const { return Id; }
362      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
363      int GetInDeg() const { return InNIdV.Len(); }
364      int GetOutDeg() const { return OutNIdV.Len(); }
365      const TNodeData& GetDat() const { return NodeDat; }
366      TNodeData& GetDat() { return NodeDat; }
367      int GetInNId(const int& EdgeN) const { return InNIdV[EdgeN]; }
368      int GetOutNId(const int& EdgeN) const { return OutNIdV[EdgeN].Val1; }
369      int GetNbrNId(const int& EdgeN) const { return EdgeN<GetOutDeg() ? GetOutNId(EdgeN):GetInNId(EdgeN-GetOutDeg()); }
370      TEdgeData& GetOutEDat(const int& EdgeN) { return OutNIdV[EdgeN].Val2; }
371      const TEdgeData& GetOutEDat(const int& EdgeN) const { return OutNIdV[EdgeN].Val2; }
372      bool IsInNId(const int& NId) const { return InNIdV.SearchBin(NId)!=-1; }
373      bool IsOutNId(const int& NId) const { return TNodeEDatNet::GetNIdPos(OutNIdV, NId)!=-1; }
374      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
375      void LoadShM(TShMIn& MStream) {
376        Id = TInt(MStream);
377        NodeDat = TNodeData(MStream);
378        InNIdV.LoadShM(MStream);
379        OutNIdV.LoadShM(MStream);
380      }
381      bool operator < (const TNode& Node) const { return NodeDat < Node.NodeDat; }
382      friend class TNodeEDatNet<TNodeData, TEdgeData>;
383    };
384    class TNodeI {
385    private:
386      typedef typename THash<TInt, TNode>::TIter THashIter;
387      THashIter NodeHI;
388      TNodeEDatNet *Net;
389    public:
390      TNodeI() : NodeHI(), Net(NULL) { }
391      TNodeI(const THashIter& NodeHIter, const TNodeEDatNet* NetPt) : NodeHI(NodeHIter), Net((TNodeEDatNet *) NetPt) { }
392      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Net(NodeI.Net) { }
393      TNodeI& operator = (const TNodeI& NodeI) { NodeHI=NodeI.NodeHI; Net=NodeI.Net; return *this; }
394      TNodeI& operator++ (int) { NodeHI++;  return *this; }
395      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
396      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
397      int GetId() const { return NodeHI.GetDat().GetId(); }
398      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
399      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
400      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
401      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
402      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
403      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
404      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
405      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
406      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
407      const TNodeData& operator () () const { return NodeHI.GetDat().NodeDat; }
408      TNodeData& operator () () { return NodeHI.GetDat().GetDat(); }
409      const TNodeData& GetDat() const { return NodeHI.GetDat().GetDat(); }
410      TNodeData& GetDat() { return NodeHI.GetDat().GetDat(); }
411      const TNodeData& GetOutNDat(const int& NodeN) const { return Net->GetNDat(GetOutNId(NodeN)); }
412      TNodeData& GetOutNDat(const int& NodeN) { return Net->GetNDat(GetOutNId(NodeN)); }
413      const TNodeData& GetInNDat(const int& NodeN) const { return Net->GetNDat(GetInNId(NodeN)); }
414      TNodeData& GetInNDat(const int& NodeN) { return Net->GetNDat(GetInNId(NodeN)); }
415      const TNodeData& GetNbrNDat(const int& NodeN) const { return Net->GetNDat(GetNbrNId(NodeN)); }
416      TNodeData& GetNbrNDat(const int& NodeN) { return Net->GetNDat(GetNbrNId(NodeN)); }
417      TEdgeData& GetOutEDat(const int& EdgeN) { return NodeHI.GetDat().GetOutEDat(EdgeN); }
418      const TEdgeData& GetOutEDat(const int& EdgeN) const { return NodeHI.GetDat().GetOutEDat(EdgeN); }
419      TEdgeData& GetInEDat(const int& EdgeN) { return Net->GetEDat(GetInNId(EdgeN), GetId()); }
420      const TEdgeData& GetInEDat(const int& EdgeN) const { return Net->GetEDat(GetInNId(EdgeN), GetId()); }
421      TEdgeData& GetNbrEDat(const int& EdgeN) { return EdgeN<GetOutDeg() ? GetOutEDat(EdgeN) : GetInEDat(EdgeN-GetOutDeg()); }
422      const TEdgeData& GetNbrEDat(const int& EdgeN) const { return EdgeN<GetOutDeg() ? GetOutEDat(EdgeN) : GetInEDat(EdgeN-GetOutDeg()); }
423      friend class TNodeEDatNet<TNodeData, TEdgeData>;
424    };
425    class TEdgeI {
426    private:
427      TNodeI CurNode, EndNode;
428      int CurEdge;
429    public:
430      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
431      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
432      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
433      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode;  EndNode=EdgeI.EndNode;  CurEdge=EdgeI.CurEdge; }  return *this; }
434      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0;  CurNode++;
435        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
436      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
437      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
438      int GetId() const { return -1; }
439      int GetSrcNId() const { return CurNode.GetId(); }
440      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
441      TEdgeData& operator () () { return CurNode.GetOutEDat(CurEdge); }
442      const TEdgeData& operator () () const { return CurNode.GetOutEDat(CurEdge); }
443      TEdgeData& GetDat() { return CurNode.GetOutEDat(CurEdge); }
444      const TEdgeData& GetDat() const { return CurNode.GetOutEDat(CurEdge); }
445      TNodeData& GetSrcNDat() { return CurNode(); }
446      const TNodeData& GetSrcNDat() const { return CurNode(); }
447      TNodeData& GetDstNDat() { return CurNode.GetOutNDat(CurEdge); }
448      const TNodeData& GetDstNDat() const { return CurNode.GetOutNDat(CurEdge); }
449      friend class TNodeEDatNet<TNodeData, TEdgeData>;
450    };
451  protected:
452    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
453    static int GetNIdPos(const TVec<TPair<TInt, TEdgeData> >& NIdV, const int& NId);
454  protected:
455    TCRef CRef;
456    TInt MxNId;
457    THash<TInt, TNode> NodeH;
458  private:
459    class TNodeFunctor {
460    public:
461      TNodeFunctor() {}
462      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
463    };
464  private:
465    void LoadNetworkShM(TShMIn& ShMIn) {
466      MxNId = TInt(ShMIn);
467      TNodeFunctor f;
468      NodeH.LoadShM(ShMIn, f);
469    }
470  public:
471    TNodeEDatNet() : CRef(), MxNId(0), NodeH() { }
472    explicit TNodeEDatNet(const int& Nodes, const int& Edges) : MxNId(0) { Reserve(Nodes, Edges); }
473    TNodeEDatNet(const TNodeEDatNet& NodeNet) : MxNId(NodeNet.MxNId), NodeH(NodeNet.NodeH) { }
474    TNodeEDatNet(TSIn& SIn) : MxNId(SIn), NodeH(SIn) { }
475    virtual ~TNodeEDatNet() { }
476    virtual void Save(TSOut& SOut) const { MxNId.Save(SOut);  NodeH.Save(SOut); SOut.Flush(); }
477    static PNet New() { return PNet(new TNet()); }
478    static PNet Load(TSIn& SIn) { return PNet(new TNet(SIn)); }
479    static PNet LoadShM(TShMIn& ShMIn) {
480      TNet* Network = new TNet();
481      Network->LoadNetworkShM(ShMIn);
482      return PNet(Network);
483    }
484    bool HasFlag(const TGraphFlag& Flag) const;
485    TNodeEDatNet& operator = (const TNodeEDatNet& NodeNet) { if (this!=&NodeNet) {
486      NodeH=NodeNet.NodeH;  MxNId=NodeNet.MxNId; }  return *this; }
487    int GetNodes() const { return NodeH.Len(); }
488    int AddNode(int NId = -1);
489    int AddNodeUnchecked(int NId = -1);
490    int AddNode(int NId, const TNodeData& NodeDat);
491    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId(), NodeI.GetDat()); }
492    void DelNode(const int& NId);
493    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
494    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
495    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
496    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
497    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
498    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
499    void SetNDat(const int& NId, const TNodeData& NodeDat);
500    TNodeData& GetNDat(const int& NId) { return NodeH.GetDat(NId).NodeDat; }
501    const TNodeData& GetNDat(const int& NId) const { return NodeH.GetDat(NId).NodeDat; }
502    int GetMxNId() const { return MxNId; }
503    int GetEdges() const;
504    int AddEdge(const int& SrcNId, const int& DstNId);
505    int AddEdge(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat);
506    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI()); }
507    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
508    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
509    TEdgeI BegEI() const { TNodeI NI=BegNI();  while(NI<EndNI() && NI.GetOutDeg()==0) NI++; return TEdgeI(NI, EndNI()); }
510    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
511    TEdgeI GetEI(const int& EId) const; 
512    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
513    void SetEDat(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat);
514    bool GetEDat(const int& SrcNId, const int& DstNId, TEdgeData& EdgeDat) const;
515    TEdgeData& GetEDat(const int& SrcNId, const int& DstNId);
516    const TEdgeData& GetEDat(const int& SrcNId, const int& DstNId) const;
517    void SetAllEDat(const TEdgeData& EdgeDat);
518    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
519    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
520    void GetNIdV(TIntV& NIdV) const;
521    bool Empty() const { return GetNodes()==0; }
522    void Clr(const bool& DoDel=true, const bool& ResetDat=true) {
523      MxNId = 0;  NodeH.Clr(DoDel, -1, ResetDat); }
524    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes/2); } }
525    void SortNIdById(const bool& Asc=true) { NodeH.SortByKey(Asc); }
526    void SortNIdByDat(const bool& Asc=true) { NodeH.SortByDat(Asc); }
527    void Defrag(const bool& OnlyNodeLinks=false);
528    bool IsOk(const bool& ThrowExcept=true) const;
529    friend class TPt<TNodeEDatNet<TNodeData, TEdgeData> >;
530  };
531  namespace TSnap {
532  template <class TNodeData, class TEdgeData> struct IsDirected<TNodeEDatNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
533  template <class TNodeData, class TEdgeData> struct IsNodeDat<TNodeEDatNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
534  template <class TNodeData, class TEdgeData> struct IsEdgeDat<TNodeEDatNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
535  }
536  template <class TNodeData, class TEdgeData>
537  bool TNodeEDatNet<TNodeData, TEdgeData>::HasFlag(const TGraphFlag& Flag) const {
538    return HasGraphFlag(typename TNet, Flag);
539  }
540  template <class TNodeData, class TEdgeData>
541  int TNodeEDatNet<TNodeData, TEdgeData>::GetNIdPos(const TVec<TPair<TInt, TEdgeData> >& NIdV, const int& NId) {
542    int LValN=0, RValN = NIdV.Len()-1;
543    while (RValN >= LValN) {
544      const int ValN = (LValN+RValN)/2;
545      const int CurNId = NIdV[ValN].Val1;
546      if (NId == CurNId) { return ValN; }
547      if (NId < CurNId) { RValN=ValN-1; }
548      else { LValN=ValN+1; }
549    }
550    return -1;
551  }
552  template <class TNodeData, class TEdgeData>
553  int TNodeEDatNet<TNodeData, TEdgeData>::AddNode(int NId) {
554    if (NId == -1) {
555      NId = MxNId;  MxNId++;
556    } else {
557      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
558      MxNId = TMath::Mx(NId+1, MxNId());
559    }
560    NodeH.AddDat(NId, TNode(NId));
561    return NId;
562  }
563  template <class TNodeData, class TEdgeData>
564  int TNodeEDatNet<TNodeData, TEdgeData>::AddNodeUnchecked(int NId) {
565    if (NId == -1) {
566      NId = MxNId;  MxNId++;
567    } else {
568      if (IsNode(NId)) { return -1;}
569      MxNId = TMath::Mx(NId+1, MxNId());
570    }
571    NodeH.AddDat(NId, TNode(NId));
572    return NId;
573  }
574  template <class TNodeData, class TEdgeData>
575  int TNodeEDatNet<TNodeData, TEdgeData>::AddNode(int NId, const TNodeData& NodeDat) {
576    if (NId == -1) {
577      NId = MxNId;  MxNId++;
578    } else {
579      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
580      MxNId = TMath::Mx(NId+1, MxNId());
581    }
582    NodeH.AddDat(NId, TNode(NId, NodeDat));
583    return NId;
584  }
585  template <class TNodeData, class TEdgeData>
586  void TNodeEDatNet<TNodeData, TEdgeData>::SetNDat(const int& NId, const TNodeData& NodeDat) {
587    IAssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist.", NId).CStr());
588    NodeH.GetDat(NId).NodeDat = NodeDat;
589  }
590  template <class TNodeData, class TEdgeData>
591  void TNodeEDatNet<TNodeData, TEdgeData>::DelNode(const int& NId) {
592    const TNode& Node = GetNode(NId);
593    for (int out = 0; out < Node.GetOutDeg(); out++) {
594      const int nbr = Node.GetOutNId(out);
595      if (nbr == NId) { continue; }
596      TIntV& NIdV = GetNode(nbr).InNIdV;
597      const int pos = NIdV.SearchBin(NId);
598      if (pos != -1) { NIdV.Del(pos); }
599    }
600    for (int in = 0; in < Node.GetInDeg(); in++) {
601      const int nbr = Node.GetInNId(in);
602      if (nbr == NId) { continue; }
603      TNIdDatPrV& NIdDatV = GetNode(nbr).OutNIdV;
604      const int pos = GetNIdPos(NIdDatV, NId);
605      if (pos != -1) { NIdDatV.Del(pos); }
606    }
607    NodeH.DelKey(NId);
608  }
609  template <class TNodeData, class TEdgeData>
610  int TNodeEDatNet<TNodeData, TEdgeData>::GetEdges() const {
611    int edges=0;
612    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
613      edges+=NodeH[N].GetOutDeg(); }
614    return edges;
615  }
616  template <class TNodeData, class TEdgeData>
617  int TNodeEDatNet<TNodeData, TEdgeData>::AddEdge(const int& SrcNId, const int& DstNId) {
618    return AddEdge(SrcNId, DstNId, TEdgeData());
619  }
620  template <class TNodeData, class TEdgeData>
621  int TNodeEDatNet<TNodeData, TEdgeData>::AddEdge(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat) {
622    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
623    if (IsEdge(SrcNId, DstNId)) {
624      GetEDat(SrcNId, DstNId) = EdgeDat;
625      return -2;
626    }
627    GetNode(SrcNId).OutNIdV.AddSorted(TPair<TInt, TEdgeData>(DstNId, EdgeDat));
628    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
629    return -1; 
630  }
631  template <class TNodeData, class TEdgeData>
632  void TNodeEDatNet<TNodeData, TEdgeData>::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
633    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
634    int pos = GetNIdPos(GetNode(SrcNId).OutNIdV, DstNId);
635    if (pos != -1) { GetNode(SrcNId).OutNIdV.Del(pos); }
636    pos = GetNode(DstNId).InNIdV.SearchBin(SrcNId);
637    if (pos != -1) { GetNode(DstNId).InNIdV.Del(pos); }
638    if (! IsDir) {
639      pos = GetNIdPos(GetNode(DstNId).OutNIdV, SrcNId);
640      if (pos != -1) { GetNode(DstNId).OutNIdV.Del(pos); }
641      pos = GetNode(SrcNId).InNIdV.SearchBin(DstNId);
642      if (pos != -1) { GetNode(SrcNId).InNIdV.Del(pos); }
643    }
644  }
645  template <class TNodeData, class TEdgeData>
646  bool TNodeEDatNet<TNodeData, TEdgeData>::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
647    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
648    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
649    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
650  }
651  template <class TNodeData, class TEdgeData>
652  void TNodeEDatNet<TNodeData, TEdgeData>::SetEDat(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat) {
653    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
654    IAssertR(IsEdge(SrcNId, DstNId), TStr::Fmt("Edge between %d and %d does not exist.", SrcNId, DstNId).CStr());
655    GetEDat(SrcNId, DstNId) = EdgeDat;
656  }
657  template <class TNodeData, class TEdgeData>
658  bool TNodeEDatNet<TNodeData, TEdgeData>::GetEDat(const int& SrcNId, const int& DstNId, TEdgeData& EdgeDat) const {
659    if (! IsEdge(SrcNId, DstNId)) { return false; }
660    const TNode& N = GetNode(SrcNId);
661    EdgeDat = N.GetOutEDat(GetNIdPos(N.OutNIdV, DstNId));
662    return true;
663  }
664  template <class TNodeData, class TEdgeData>
665  TEdgeData& TNodeEDatNet<TNodeData, TEdgeData>::GetEDat(const int& SrcNId, const int& DstNId) {
666    Assert(IsEdge(SrcNId, DstNId));
667    TNode& N = GetNode(SrcNId);
668    return N.GetOutEDat(GetNIdPos(N.OutNIdV, DstNId));
669  }
670  template <class TNodeData, class TEdgeData>
671  const TEdgeData& TNodeEDatNet<TNodeData, TEdgeData>::GetEDat(const int& SrcNId, const int& DstNId) const {
672    Assert(IsEdge(SrcNId, DstNId));
673    const TNode& N = GetNode(SrcNId);
674    return N.GetOutEDat(GetNIdPos(N.OutNIdV, DstNId));
675  }
676  template <class TNodeData, class TEdgeData>
677  void TNodeEDatNet<TNodeData, TEdgeData>::SetAllEDat(const TEdgeData& EdgeDat) {
678    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
679      EI() = EdgeDat;
680    }
681  }
682  template <class TNodeData, class TEdgeData>
683  typename TNodeEDatNet<TNodeData, TEdgeData>::TEdgeI  TNodeEDatNet<TNodeData, TEdgeData>::GetEI(const int& SrcNId, const int& DstNId) const {
684    const TNodeI SrcNI = GetNI(SrcNId);
685    int NodeN = -1;
686    const TNIdDatPrV& NIdDatV = SrcNI.NodeHI.GetDat().OutNIdV;
687    int LValN=0, RValN=NIdDatV.Len()-1;
688    while (RValN>=LValN){
689      int ValN=(LValN+RValN)/2;
690      if (DstNId==NIdDatV[ValN].Val1){ NodeN=ValN; break; }
691      if (DstNId<NIdDatV[ValN].Val1){RValN=ValN-1;} else {LValN=ValN+1;}
692    }
693    if (NodeN == -1) { return EndEI(); }
694    else { return TEdgeI(SrcNI, EndNI(), NodeN); }
695  }
696  template <class TNodeData, class TEdgeData>
697  void TNodeEDatNet<TNodeData, TEdgeData>::GetNIdV(TIntV& NIdV) const {
698    NIdV.Reserve(GetNodes(), 0);
699    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
700      NIdV.Add(NodeH.GetKey(N)); }
701  }
702  template <class TNodeData, class TEdgeData>
703  void TNodeEDatNet<TNodeData, TEdgeData>::Defrag(const bool& OnlyNodeLinks) {
704    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n);) {
705      TNode& Node = NodeH[n];
706      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
707    }
708    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
709      NodeH.Defrag();
710    }
711  }
712  template <class TNodeData, class TEdgeData>
713  bool TNodeEDatNet<TNodeData, TEdgeData>::IsOk(const bool& ThrowExcept) const {
714    bool RetVal = true;
715    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
716      const TNode& Node = NodeH[N];
717      if (! Node.OutNIdV.IsSorted()) {
718        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
719        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
720      }
721      if (! Node.InNIdV.IsSorted()) {
722        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
723        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
724      }
725      int prevNId = -1;
726      for (int e = 0; e < Node.GetOutDeg(); e++) {
727        if (! IsNode(Node.GetOutNId(e))) {
728          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
729            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
730          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
731        }
732        if (e > 0 && prevNId == Node.GetOutNId(e)) {
733          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
734            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
735          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
736        }
737        prevNId = Node.GetOutNId(e);
738      }
739      prevNId = -1;
740      for (int e = 0; e < Node.GetInDeg(); e++) {
741        if (! IsNode(Node.GetInNId(e))) {
742          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
743            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
744          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
745        }
746        if (e > 0 && prevNId == Node.GetInNId(e)) {
747          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
748            Node.GetId(), Node.GetId(), Node.GetInNId(e));
749          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
750        }
751        prevNId = Node.GetInNId(e);
752      }
753    }
754    return RetVal;
755  }
756  typedef TNodeEDatNet<TInt, TInt> TIntNEDNet;
757  typedef TPt<TIntNEDNet> PIntNEDNet;
758  typedef TNodeEDatNet<TInt, TFlt> TIntFltNEDNet;
759  typedef TPt<TIntFltNEDNet> PIntFltNEDNet;
760  typedef TNodeEDatNet<TStr, TInt> TStrIntNEDNet;
761  typedef TPt<TStrIntNEDNet> PStrIntNEDNet;
762  template <class TNodeData, class TEdgeData>
763  class TNodeEdgeNet {
764  public:
765    typedef TNodeData TNodeDat;
766    typedef TEdgeData TEdgeDat;
767    typedef TNodeEdgeNet<TNodeData, TEdgeData> TNet;
768    typedef TPt<TNet> PNet;
769  public:
770    class TNode {
771    private:
772      TInt Id;
773      TIntV InEIdV, OutEIdV;
774      TNodeData NodeDat;
775    public:
776      TNode() : Id(-1), InEIdV(), OutEIdV(), NodeDat() { }
777      TNode(const int& NId) : Id(NId), InEIdV(), OutEIdV(), NodeDat()  { }
778      TNode(const int& NId, const TNodeData& NodeData) : Id(NId), InEIdV(), OutEIdV(), NodeDat(NodeData) { }
779      TNode(const TNode& Node) : Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV), NodeDat(Node.NodeDat) { }
780      TNode(TSIn& SIn) : Id(SIn), InEIdV(SIn), OutEIdV(SIn), NodeDat(SIn) { }
781      void Save(TSOut& SOut) const { Id.Save(SOut);  InEIdV.Save(SOut);  OutEIdV.Save(SOut);  NodeDat.Save(SOut); }
782      bool operator < (const TNode& Node) const { return NodeDat < Node.NodeDat; }
783      int GetId() const { return Id; }
784      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
785      int GetInDeg() const { return InEIdV.Len(); }
786      int GetOutDeg() const { return OutEIdV.Len(); }
787      const TNodeData& GetDat() const { return NodeDat; }
788      TNodeData& GetDat() { return NodeDat; }
789      int GetInEId(const int& NodeN) const { return InEIdV[NodeN]; }
790      int GetOutEId(const int& NodeN) const { return OutEIdV[NodeN]; }
791      int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
792      bool IsInEId(const int& EId) const { return InEIdV.SearchBin(EId) != -1; }
793      bool IsOutEId(const int& EId) const { return OutEIdV.SearchBin(EId) != -1; }
794      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
795      void LoadShM(TShMIn& MStream) {
796        Id = TInt(MStream);
797        InEIdV.LoadShM(MStream);
798        OutEIdV.LoadShM(MStream);
799        NodeDat = TNodeData(MStream);
800      }
801      friend class TNodeEdgeNet<TNodeData, TEdgeData>;
802    };
803    class TEdge {
804    private:
805      TInt Id, SrcNId, DstNId;
806      TEdgeData EdgeDat;
807    public:
808      TEdge() : Id(-1), SrcNId(-1), DstNId(-1), EdgeDat() { }
809      TEdge(const int& EId, const int& SourceNId, const int& DestNId) : Id(EId), SrcNId(SourceNId), DstNId(DestNId), EdgeDat() { }
810      TEdge(const int& EId, const int& SourceNId, const int& DestNId, const TEdgeData& EdgeData) : Id(EId), SrcNId(SourceNId), DstNId(DestNId), EdgeDat(EdgeData) { }
811      TEdge(const TEdge& Edge) : Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId), EdgeDat(Edge.EdgeDat) { }
812      TEdge(TSIn& SIn) : Id(SIn), SrcNId(SIn), DstNId(SIn), EdgeDat(SIn) { }
813      void Save(TSOut& SOut) const { Id.Save(SOut);  SrcNId.Save(SOut);  DstNId.Save(SOut);  EdgeDat.Save(SOut); }
814      bool operator < (const TEdge& Edge) const { return EdgeDat < Edge.EdgeDat; }
815      int GetId() const { return Id; }
816      int GetSrcNId() const { return SrcNId; }
817      int GetDstNId() const { return DstNId; }
818      void Load(TSIn& InStream) {
819        Id = TInt(InStream);
820        SrcNId = TInt(InStream);
821        DstNId = TInt(InStream);
822        EdgeDat = TEdgeData(InStream);
823      }
824      const TEdgeData& GetDat() const { return EdgeDat; }
825      TEdgeData& GetDat() { return EdgeDat; }
826      friend class TNodeEdgeNet;
827    };
828    class TNodeI {
829    private:
830      typedef typename THash<TInt, TNode>::TIter THashIter;
831      THashIter NodeHI;
832      TNodeEdgeNet *Net;
833    public:
834      TNodeI() : NodeHI(), Net(NULL) { }
835      TNodeI(const THashIter& NodeHIter, const TNodeEdgeNet* NetPt) : NodeHI(NodeHIter), Net((TNodeEdgeNet *)NetPt) { }
836      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Net(NodeI.Net) { }
837      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI;  Net=NodeI.Net;  return *this; }
838      TNodeI& operator++ (int) { NodeHI++;  return *this; }
839      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
840      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
841      int GetId() const { return NodeHI.GetDat().GetId(); }
842      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
843      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
844      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
845      int GetInNId(const int& EdgeN) const { return Net->GetEdge(NodeHI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
846      int GetOutNId(const int& EdgeN) const { return Net->GetEdge(NodeHI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
847      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Net->GetEdge(NodeHI.GetDat().GetNbrEId(EdgeN));
848        return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
849      bool IsInNId(const int& NId) const;
850      bool IsOutNId(const int& NId) const;
851      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
852      const TNodeData& operator () () const { return NodeHI.GetDat().GetDat(); }
853      TNodeData& operator () () { return NodeHI.GetDat().GetDat(); }
854      const TNodeData& GetDat() const { return NodeHI.GetDat().GetDat(); }
855      TNodeData& GetDat() { return NodeHI.GetDat().GetDat(); }
856      const TNodeData& GetInNDat(const int& EdgeN) const { return Net->GetNDat(GetInNId(EdgeN)); }
857      TNodeData& GetInNDat(const int& EdgeN) { return Net->GetNDat(GetInNId(EdgeN)); }
858      const TNodeData& GetOutNDat(const int& EdgeN) const { return Net->GetNDat(GetOutNId(EdgeN)); }
859      TNodeData& GetOutNDat(const int& EdgeN) { return Net->GetNDat(GetOutNId(EdgeN)); }
860      const TNodeData& GetNbrNDat(const int& EdgeN) const { return Net->GetNDat(GetNbrNId(EdgeN)); }
861      TNodeData& GetNbrNDat(const int& EdgeN) { return Net->GetNDat(GetNbrNId(EdgeN)); }
862      int GetInEId(const int& EdgeN) const { return NodeHI.GetDat().GetInEId(EdgeN); }
863      int GetOutEId(const int& EdgeN) const { return NodeHI.GetDat().GetOutEId(EdgeN); }
864      int GetNbrEId(const int& EdgeN) const { return NodeHI.GetDat().GetNbrEId(EdgeN); }
865      bool IsInEId(const int& EId) const { return NodeHI.GetDat().IsInEId(EId); }
866      bool IsOutEId(const int& EId) const { return NodeHI.GetDat().IsOutEId(EId); }
867      bool IsNbrEId(const int& EId) const { return NodeHI.GetDat().IsNbrEId(EId); }
868      TEdgeDat& GetInEDat(const int& EdgeN) { return Net->GetEDat(GetInEId(EdgeN)); }
869      const TEdgeDat& GetInEDat(const int& EdgeN) const { return Net->GetEDat(GetInEId(EdgeN)); }
870      TEdgeDat& GetOutEDat(const int& EdgeN) { return Net->GetEDat(GetOutEId(EdgeN)); }
871      const TEdgeDat& GetOutEDat(const int& EdgeN) const { return Net->GetEDat(GetOutEId(EdgeN)); }
872      TEdgeDat& GetNbrEDat(const int& EdgeN) { return Net->GetEDat(GetNbrEId(EdgeN)); }
873      const TEdgeDat& GetNbrEDat(const int& EdgeN) const { return Net->GetEDat(GetNbrEId(EdgeN)); }
874      friend class TNodeEdgeNet;
875    };
876    class TEdgeI {
877    private:
878      typedef typename THash<TInt, TEdge>::TIter THashIter;
879      THashIter EdgeHI;
880      TNodeEdgeNet *Net;
881    public:
882      TEdgeI() : EdgeHI(), Net(NULL) { }
883      TEdgeI(const THashIter& EdgeHIter, const TNodeEdgeNet *NetPt) : EdgeHI(EdgeHIter), Net((TNodeEdgeNet *) NetPt) { }
884      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Net(EdgeI.Net) { }
885      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI;  Net=EdgeI.Net; }  return *this; }
886      TEdgeI& operator++ (int) { EdgeHI++;  return *this; }
887      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
888      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
889      int GetId() const { return EdgeHI.GetDat().GetId(); }
890      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
891      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
892      const TEdgeData& operator () () const { return EdgeHI.GetDat().GetDat(); }
893      TEdgeData& operator () () { return EdgeHI.GetDat().GetDat(); }
894      const TEdgeData& GetDat() const { return EdgeHI.GetDat().GetDat(); }
895      TEdgeData& GetDat() { return EdgeHI.GetDat().GetDat(); }
896      const TNodeData& GetSrcNDat() const { return Net->GetNDat(GetSrcNId()); }
897      TNodeData& GetSrcNDat() { return Net->GetNDat(GetSrcNId()); }
898      const TNodeData& GetDstNDat() const { return Net->GetNDat(GetDstNId()); }
899      TNodeData& GetDstNDat() { return Net->GetNDat(GetDstNId()); }
900      friend class TNodeEdgeNet;
901    };
902  private:
903    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
904    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
905    const TNode& GetNodeKId(const int& NodeKeyId) const { return NodeH[NodeKeyId]; }
906    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
907    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
908    const TEdge& GetEdgeKId(const int& EdgeKeyId) const { return EdgeH[EdgeKeyId]; }
909  protected:
910    TCRef CRef;
911    TInt MxNId, MxEId;
912    THash<TInt, TNode> NodeH;
913    THash<TInt, TEdge> EdgeH;
914  private:
915    class LoadTNodeFunctor {
916    public:
917      LoadTNodeFunctor() {}
918      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
919    };
920  private:
921    void LoadNetworkShM(TShMIn& ShMIn) {
922      MxNId = TInt(ShMIn);
923      MxEId = TInt(ShMIn);
924      LoadTNodeFunctor fn;
925      NodeH.LoadShM(ShMIn, fn);
926      EdgeH.LoadShM(ShMIn);
927    }
928  public:
929    TNodeEdgeNet() : CRef(), MxNId(0), MxEId(0) { }
930    explicit TNodeEdgeNet(const int& Nodes, const int& Edges) : CRef(), MxNId(0), MxEId(0) { Reserve(Nodes, Edges); }
931    TNodeEdgeNet(const TNodeEdgeNet& Net) : MxNId(Net.MxNId), MxEId(Net.MxEId), NodeH(Net.NodeH), EdgeH(Net.EdgeH) { }
932    TNodeEdgeNet(TSIn& SIn) : MxNId(SIn), MxEId(SIn), NodeH(SIn), EdgeH(SIn) { }
933    virtual ~TNodeEdgeNet() { }
934    virtual void Save(TSOut& SOut) const { MxNId.Save(SOut);  MxEId.Save(SOut);  NodeH.Save(SOut);  EdgeH.Save(SOut); SOut.Flush(); }
935    static PNet New() { return PNet(new TNet()); }
936    static PNet Load(TSIn& SIn) { return PNet(new TNet(SIn)); }
937    static PNet LoadShM(TShMIn& ShMIn) {
938      TNet* Network = new TNet();
939      Network->LoadNetworkShM(ShMIn);
940      return PNet(Network);
941    }
942    bool HasFlag(const TGraphFlag& Flag) const;
943    TNodeEdgeNet& operator = (const TNodeEdgeNet& Net) {
944      if (this!=&Net) { NodeH=Net.NodeH; EdgeH=Net.EdgeH; MxNId=Net.MxNId; MxEId=Net.MxEId; }  return *this; }
945    int GetNodes() const { return NodeH.Len(); }
946    int AddNode(int NId = -1);
947    int AddNodeUnchecked(int NId = -1);
948    int AddNode(int NId, const TNodeData& NodeDat);
949    friend class TCrossNet;
950    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId(), NodeI.GetDat()); }
951    void DelNode(const int& NId);
952    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
953    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
954    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
955    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
956    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
957    void SetNDat(const int& NId, const TNodeData& NodeDat);
958    TNodeData& GetNDat(const int& NId) { return NodeH.GetDat(NId).NodeDat; }
959    const TNodeData& GetNDat(const int& NId) const { return NodeH.GetDat(NId).NodeDat; }
960    int GetMxNId() const { return MxNId; }
961    int GetEdges() const { return EdgeH.Len(); }
962    int GetUniqEdges(const bool& IsDir=true) const;
963    int AddEdge(const int& SrcNId, const int& DstNId, int EId = -1);
964    int AddEdge(const int& SrcNId, const int& DstNId, int EId, const TEdgeData& EdgeDat);
965    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetId(), EdgeI.GetDat()); }
966    void DelEdge(const int& EId);
967    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
968    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
969    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId;  return IsEdge(SrcNId, DstNId, EId, IsDir); }
970    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const;
971    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
972    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
973    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
974    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
975    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
976    void SetEDat(const int& EId, const TEdgeData& EdgeDat);
977    TEdgeData& GetEDat(const int& EId) { return EdgeH.GetDat(EId).EdgeDat; }
978    const TEdgeData& GetEDat(const int& EId) const { return EdgeH.GetDat(EId).EdgeDat; }
979    void SetAllEDat(const TEdgeData& EdgeDat);
980    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
981    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
982    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
983    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
984    void GetNIdV(TIntV& NIdV) const;
985    void GetEIdV(TIntV& EIdV) const;
986    bool Empty() const { return GetNodes()==0; }
987    void Clr() { MxNId=0;  MxEId=0;  NodeH.Clr();  EdgeH.Clr(); }
988    void Reserve(const int& Nodes, const int& Edges) {
989      if (Nodes>0) { NodeH.Gen(Nodes/2); }  if (Edges>0) { EdgeH.Gen(Edges/2); } }
990    void SortNIdById(const bool& Asc=true) { NodeH.SortByKey(Asc); }
991    void SortNIdByDat(const bool& Asc=true) { NodeH.SortByDat(Asc); }
992    void SortEIdById(const bool& Asc=true) { EdgeH.SortByKey(Asc); }
993    void SortEIdByDat(const bool& Asc=true) { EdgeH.SortByDat(Asc); }
994    void Defrag(const bool& OnlyNodeLinks=false);
995    bool IsOk(const bool& ThrowExcept=true) const;
996    friend class TPt<TNodeEdgeNet<TNodeData, TEdgeData> >;
997  };
998  namespace TSnap {
999  template <class TNodeData, class TEdgeData> struct IsMultiGraph<TNodeEdgeNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
1000  template <class TNodeData, class TEdgeData> struct IsDirected<TNodeEdgeNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
1001  template <class TNodeData, class TEdgeData> struct IsNodeDat<TNodeEdgeNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
1002  template <class TNodeData, class TEdgeData> struct IsEdgeDat<TNodeEdgeNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
1003  }
1004  template <class TNodeData, class TEdgeData>
1005  bool TNodeEdgeNet<TNodeData, TEdgeData>::HasFlag(const TGraphFlag& Flag) const {
1006    return HasGraphFlag(typename TNet, Flag);
1007  }
1008  template <class TNodeData, class TEdgeData>
1009  bool TNodeEdgeNet<TNodeData, TEdgeData>::TNodeI::IsInNId(const int& NId) const {
1010    const TNode& Node = NodeHI.GetDat();
1011    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
1012      if (NId == Net->GetEdge(Node.GetInEId(edge)).GetSrcNId())
1013        return true;
1014    }
1015    return false;
1016  }
1017  template <class TNodeData, class TEdgeData>
1018  bool TNodeEdgeNet<TNodeData, TEdgeData>::TNodeI::IsOutNId(const int& NId) const {
1019    const TNode& Node = NodeHI.GetDat();
1020    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
1021      if (NId == Net->GetEdge(Node.GetOutEId(edge)).GetDstNId())
1022        return true;
1023    }
1024    return false;
1025  }
1026  template <class TNodeData, class TEdgeData>
1027  int TNodeEdgeNet<TNodeData, TEdgeData>::AddNode(int NId) {
1028    if (NId == -1) {
1029      NId = MxNId;  MxNId++;
1030    } else {
1031      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1032      MxNId = TMath::Mx(NId+1, MxNId());
1033    }
1034    NodeH.AddDat(NId, TNode(NId));
1035    return NId;
1036  }
1037  template <class TNodeData, class TEdgeData>
1038  int TNodeEdgeNet<TNodeData, TEdgeData>::AddNodeUnchecked(int NId) {
1039    if (NId == -1) {
1040      NId = MxNId;  MxNId++;
1041    } else {
1042      if (IsNode(NId)) { return -1;}
1043      MxNId = TMath::Mx(NId+1, MxNId());
1044    }
1045    NodeH.AddDat(NId, TNode(NId));
1046    return NId;
1047  }
1048  template <class TNodeData, class TEdgeData>
1049  int TNodeEdgeNet<TNodeData, TEdgeData>::AddNode(int NId, const TNodeData& NodeDat) {
1050    if (NId == -1) {
1051      NId = MxNId;  MxNId++;
1052    } else {
1053      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1054      MxNId = TMath::Mx(NId+1, MxNId());
1055    }
1056    NodeH.AddDat(NId, TNode(NId, NodeDat));
1057    return NId;
1058  }
1059  template <class TNodeData, class TEdgeData>
1060  void TNodeEdgeNet<TNodeData, TEdgeData>::DelNode(const int& NId) {
1061    const TNode& Node = GetNode(NId);
1062    for (int out = 0; out < Node.GetOutDeg(); out++) {
1063      const int EId = Node.GetOutEId(out);
1064      const TEdge& Edge = GetEdge(EId);
1065      IAssert(Edge.GetSrcNId() == NId);
1066      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
1067      EdgeH.DelKey(EId);
1068    }
1069    for (int in = 0; in < Node.GetInDeg(); in++) {
1070      const int EId = Node.GetInEId(in);
1071      const TEdge& Edge = GetEdge(EId);
1072      IAssert(Edge.GetDstNId() == NId);
1073      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
1074      EdgeH.DelKey(EId);
1075    }
1076    NodeH.DelKey(NId);
1077  }
1078  template <class TNodeData, class TEdgeData>
1079  void TNodeEdgeNet<TNodeData, TEdgeData>::SetNDat(const int& NId, const TNodeData& NodeDat) {
1080    IAssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist.", NId).CStr());
1081    NodeH.GetDat(NId).NodeDat = NodeDat;
1082  }
1083  template <class TNodeData, class TEdgeData>
1084  int TNodeEdgeNet<TNodeData, TEdgeData>::GetUniqEdges(const bool& IsDir) const {
1085    TIntPrSet UniqESet(GetEdges());
1086    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
1087      const int Src = EI.GetSrcNId();
1088      const int Dst = EI.GetDstNId();
1089      if (IsDir) { UniqESet.AddKey(TIntPr(Src, Dst)); }
1090      else { UniqESet.AddKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst))); }
1091    }
1092    return UniqESet.Len();
1093  }
1094  template <class TNodeData, class TEdgeData>
1095  int TNodeEdgeNet<TNodeData, TEdgeData>::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
1096    if (EId == -1) { EId = MxEId;  MxEId++; }
1097    else { MxEId = TMath::Mx(EId+1, MxEId()); }
1098    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
1099    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1100    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
1101    GetNode(SrcNId).OutEIdV.AddSorted(EId);
1102    GetNode(DstNId).InEIdV.AddSorted(EId);
1103    return EId;
1104  }
1105  template <class TNodeData, class TEdgeData>
1106  int TNodeEdgeNet<TNodeData, TEdgeData>::AddEdge(const int& SrcNId, const int& DstNId, int EId, const TEdgeData& EdgeDat) {
1107    if (EId == -1) { EId = MxEId;  MxEId++; }
1108    else { MxEId = TMath::Mx(EId+1, MxEId()); }
1109    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
1110    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1111    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId, EdgeDat));
1112    GetNode(SrcNId).OutEIdV.AddSorted(EId);
1113    GetNode(DstNId).InEIdV.AddSorted(EId);
1114    return EId;
1115  }
1116  template <class TNodeData, class TEdgeData>
1117  void TNodeEdgeNet<TNodeData, TEdgeData>::DelEdge(const int& EId) {
1118    IAssert(IsEdge(EId));
1119    const int SrcNId = GetEdge(EId).GetSrcNId();
1120    const int DstNId = GetEdge(EId).GetDstNId();
1121    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
1122    GetNode(DstNId).InEIdV.DelIfIn(EId);
1123    EdgeH.DelKey(EId);
1124  }
1125  template <class TNodeData, class TEdgeData>
1126  void TNodeEdgeNet<TNodeData, TEdgeData>::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
1127    int EId;
1128    IAssert(IsEdge(SrcNId, DstNId, EId, IsDir));
1129    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
1130    GetNode(DstNId).InEIdV.DelIfIn(EId);
1131    EdgeH.DelKey(EId);
1132  }
1133  template <class TNodeData, class TEdgeData>
1134  bool TNodeEdgeNet<TNodeData, TEdgeData>::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
1135    if (! IsNode(SrcNId)) { return false; }
1136    if (! IsNode(DstNId)) { return false; }
1137    const TNode& SrcNode = GetNode(SrcNId);
1138    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
1139      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
1140      if (DstNId == Edge.GetDstNId()) {
1141        EId = Edge.GetId();  return true; }
1142    }
1143    if (! IsDir) {
1144      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
1145      const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
1146      if (DstNId == Edge.GetSrcNId()) {
1147        EId = Edge.GetId();  return true; }
1148      }
1149    }
1150    return false;
1151  }
1152  template <class TNodeData, class TEdgeData>
1153  void TNodeEdgeNet<TNodeData, TEdgeData>::SetEDat(const int& EId, const TEdgeData& EdgeDat) {
1154    IAssertR(IsEdge(EId), TStr::Fmt("EdgeId %d does not exist.", EId).CStr());
1155    GetEI(EId).GetDat() = EdgeDat;
1156  }
1157  template <class TNodeData, class TEdgeData>
1158  void TNodeEdgeNet<TNodeData, TEdgeData>::SetAllEDat(const TEdgeData& EdgeDat) {
1159    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
1160      EI() = EdgeDat;
1161    }
1162  }
1163  template <class TNodeData, class TEdgeData>
1164  void TNodeEdgeNet<TNodeData, TEdgeData>::GetNIdV(TIntV& NIdV) const {
1165    NIdV.Gen(GetNodes(), 0);
1166    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N);) {
1167      NIdV.Add(NodeH.GetKey(N));
1168    }
1169  }
1170  template <class TNodeData, class TEdgeData>
1171  void TNodeEdgeNet<TNodeData, TEdgeData>::GetEIdV(TIntV& EIdV) const {
1172    EIdV.Gen(GetEdges(), 0);
1173    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E);) {
1174      EIdV.Add(EdgeH.GetKey(E));
1175    }
1176  }
1177  template <class TNodeData, class TEdgeData>
1178  void TNodeEdgeNet<TNodeData, TEdgeData>::Defrag(const bool& OnlyNodeLinks) {
1179    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid);) {
1180      TNode& Node = NodeH[kid];
1181      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
1182    }
1183    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
1184    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
1185  }
1186  template <class TNodeData, class TEdgeData>
1187  bool TNodeEdgeNet<TNodeData, TEdgeData>::IsOk(const bool& ThrowExcept) const {
1188    bool RetVal = true;
1189    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
1190      const TNode& Node = NodeH[N];
1191      if (! Node.OutEIdV.IsSorted()) {
1192        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
1193        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1194      }
1195      if (! Node.InEIdV.IsSorted()) {
1196        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
1197        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1198      }
1199      int prevEId = -1;
1200      for (int e = 0; e < Node.GetOutDeg(); e++) {
1201        if (! IsEdge(Node.GetOutEId(e))) {
1202          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
1203          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1204        }
1205        if (e > 0 && prevEId == Node.GetOutEId(e)) {
1206          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
1207          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1208        }
1209        prevEId = Node.GetOutEId(e);
1210      }
1211      prevEId = -1;
1212      for (int e = 0; e < Node.GetInDeg(); e++) {
1213        if (! IsEdge(Node.GetInEId(e))) {
1214          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
1215          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1216        }
1217        if (e > 0 && prevEId == Node.GetInEId(e)) {
1218          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
1219          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1220        }
1221        prevEId = Node.GetInEId(e);
1222      }
1223    }
1224    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
1225      const TEdge& Edge = EdgeH[E];
1226      if (! IsNode(Edge.GetSrcNId())) {
1227        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
1228        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1229      }
1230      if (! IsNode(Edge.GetDstNId())) {
1231        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
1232        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1233      }
1234    }
1235    return RetVal;
1236  }
1237  typedef TNodeEdgeNet<TInt, TInt> TIntNENet;
1238  typedef TPt<TIntNENet> PIntNENet;
1239  typedef TNodeEdgeNet<TFlt, TFlt> TFltNENet;
1240  typedef TPt<TFltNENet> PFltNENet;
1241  class TNEANet;
1242  typedef TPt<TNEANet> PNEANet;
1243  class TNEANet {
1244  public:
1245    typedef TNEANet TNet;
1246    typedef TPt<TNEANet> PNet;
1247  public:
1248    class TNode {
1249    private:
1250      TInt Id;
1251      TIntV InEIdV, OutEIdV;
1252    public:
1253      TNode() : Id(-1), InEIdV(), OutEIdV() { }
1254      TNode(const int& NId) : Id(NId), InEIdV(), OutEIdV() { }
1255      TNode(const TNode& Node) : Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV) { }
1256      TNode(TSIn& SIn) : Id(SIn), InEIdV(SIn), OutEIdV(SIn) { }
1257      void Save(TSOut& SOut) const { Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut); }
1258      int GetId() const { return Id; }
1259      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
1260      int GetInDeg() const { return InEIdV.Len(); }
1261      int GetOutDeg() const { return OutEIdV.Len(); }
1262      int GetInEId(const int& EdgeN) const { return InEIdV[EdgeN]; }
1263      int GetOutEId(const int& EdgeN) const { return OutEIdV[EdgeN]; }
1264      int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
1265      bool IsInEId(const int& EId) const { return InEIdV.SearchBin(EId) != -1; }
1266      bool IsOutEId(const int& EId) const { return OutEIdV.SearchBin(EId) != -1; }
1267      void LoadShM(TShMIn& MStream) {
1268        Id = TInt(MStream);
1269        InEIdV.LoadShM(MStream);
1270        OutEIdV.LoadShM(MStream);
1271      }
1272      friend class TNEANet;
1273    };
1274    class TEdge {
1275    private:
1276      TInt Id, SrcNId, DstNId;
1277    public:
1278      TEdge() : Id(-1), SrcNId(-1), DstNId(-1) { }
1279      TEdge(const int& EId, const int& SourceNId, const int& DestNId) : Id(EId), SrcNId(SourceNId), DstNId(DestNId) { }
1280      TEdge(const TEdge& Edge) : Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId) { }
1281      TEdge(TSIn& SIn) : Id(SIn), SrcNId(SIn), DstNId(SIn) { }
1282      void Save(TSOut& SOut) const { Id.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
1283      int GetId() const { return Id; }
1284      int GetSrcNId() const { return SrcNId; }
1285      int GetDstNId() const { return DstNId; }
1286      void Load(TSIn& InStream) {
1287        Id = TInt(InStream);
1288        SrcNId = TInt(InStream);
1289        DstNId = TInt(InStream);
1290      }
1291      friend class TNEANet;
1292    };
1293    class TNodeI {
1294    protected:
1295      typedef THash<TInt, TNode>::TIter THashIter;
1296      THashIter NodeHI;
1297      const TNEANet *Graph;
1298    public:
1299      TNodeI() : NodeHI(), Graph(NULL) { }
1300      TNodeI(const THashIter& NodeHIter, const TNEANet* GraphPt) : NodeHI(NodeHIter), Graph(GraphPt) { }
1301      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Graph(NodeI.Graph) { }
1302      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; Graph=NodeI.Graph; return *this; }
1303      TNodeI& operator++ (int) { NodeHI++; return *this; }
1304      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
1305      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
1306      int GetId() const { return NodeHI.GetDat().GetId(); }
1307      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
1308      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
1309      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
1310      int GetInNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
1311      int GetOutNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
1312      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Graph->GetEdge(NodeHI.GetDat().GetNbrEId(EdgeN)); return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
1313      bool IsInNId(const int& NId) const;
1314      bool IsOutNId(const int& NId) const;
1315      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
1316      int GetInEId(const int& EdgeN) const { return NodeHI.GetDat().GetInEId(EdgeN); }
1317      int GetOutEId(const int& EdgeN) const { return NodeHI.GetDat().GetOutEId(EdgeN); }
1318      int GetNbrEId(const int& EdgeN) const { return NodeHI.GetDat().GetNbrEId(EdgeN); }
1319      bool IsInEId(const int& EId) const { return NodeHI.GetDat().IsInEId(EId); }
1320      bool IsOutEId(const int& EId) const { return NodeHI.GetDat().IsOutEId(EId); }
1321      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
1322      void GetAttrNames(TStrV& Names) const { Graph->AttrNameNI(GetId(), Names); }
1323      void GetAttrVal(TStrV& Val) const { Graph->AttrValueNI(GetId(), Val); }
1324      void GetIntAttrNames(TStrV& Names) const { Graph->IntAttrNameNI(GetId(), Names); }
1325      void GetIntAttrVal(TIntV& Val) const { Graph->IntAttrValueNI(GetId(), Val); }
1326      void GetIntVAttrNames(TStrV& Names) const { Graph->IntVAttrNameNI(GetId(), Names); }
1327      void GetIntVAttrVal(TVec<TIntV>& Val) const { Graph->IntVAttrValueNI(GetId(), Val); }
1328      void GetStrAttrNames(TStrV& Names) const { Graph->StrAttrNameNI(GetId(), Names); }
1329      void GetStrAttrVal(TStrV& Val) const { Graph->StrAttrValueNI(GetId(), Val); }
1330      void GetFltAttrNames(TStrV& Names) const { Graph->FltAttrNameNI(GetId(), Names); }
1331      void GetFltAttrVal(TFltV& Val) const { Graph->FltAttrValueNI(GetId(), Val); }
1332      friend class TNEANet;
1333    };
1334    class TEdgeI {
1335    private:
1336      typedef THash<TInt, TEdge>::TIter THashIter;
1337      THashIter EdgeHI;
1338      const TNEANet *Graph;
1339    public:
1340      TEdgeI() : EdgeHI(), Graph(NULL) { }
1341      TEdgeI(const THashIter& EdgeHIter, const TNEANet *GraphPt) : EdgeHI(EdgeHIter), Graph(GraphPt) { }
1342      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Graph(EdgeI.Graph) { }
1343      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI; Graph=EdgeI.Graph; }  return *this; }
1344      TEdgeI& operator++ (int) { EdgeHI++; return *this; }
1345      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
1346      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
1347      int GetId() const { return EdgeHI.GetDat().GetId(); }
1348      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
1349      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
1350      void GetAttrNames(TStrV& Names) const { Graph->AttrNameEI(GetId(), Names); }
1351      void GetAttrVal(TStrV& Val) const { Graph->AttrValueEI(GetId(), Val); }
1352      void GetIntAttrNames(TStrV& Names) const { Graph->IntAttrNameEI(GetId(), Names); }
1353      void GetIntAttrVal(TIntV& Val) const { Graph->IntAttrValueEI(GetId(), Val); }
1354      void GetIntVAttrNames(TStrV& Names) const { Graph->IntVAttrNameEI(GetId(), Names); }
1355      void GetIntVAttrVal(TVec<TIntV>& Val) const { Graph->IntVAttrValueEI(GetId(), Val); }
1356      void GetStrAttrNames(TStrV& Names) const { Graph->StrAttrNameEI(GetId(), Names); }
1357      void GetStrAttrVal(TStrV& Val) const { Graph->StrAttrValueEI(GetId(), Val); }
1358      void GetFltAttrNames(TStrV& Names) const { Graph->FltAttrNameEI(GetId(), Names); }
1359      void GetFltAttrVal(TFltV& Val) const { Graph->FltAttrValueEI(GetId(), Val); }
1360      friend class TNEANet;
1361    };
1362    class TAIntI {
1363    private:
1364      typedef TIntV::TIter TIntVecIter;
1365      TIntVecIter HI;
1366      bool isNode;
1367      TStr attr;
1368      const TNEANet *Graph;
1369    public:
1370      TAIntI() : HI(), attr(), Graph(NULL) { }
1371      TAIntI(const TIntVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
1372      TAIntI(const TAIntI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1373      TAIntI& operator = (const TAIntI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1374      bool operator < (const TAIntI& I) const { return HI < I.HI; }
1375      bool operator == (const TAIntI& I) const { return HI == I.HI; }
1376      TInt GetDat() const { return HI[0]; }
1377      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetIntAttrDefaultN(attr) : GetDat() == Graph->GetIntAttrDefaultE(attr); };
1378      TAIntI& operator++(int) { HI++; return *this; }
1379      friend class TNEANet;
1380    };
1381    class TAIntVI {
1382    private:
1383      typedef TVec<TIntV>::TIter TIntVVecIter;
1384      TIntVVecIter HI;
1385      bool IsDense;
1386      typedef THash<TInt, TIntV>::TIter TIntHVecIter;
1387      TIntHVecIter HHI;
1388      bool isNode;
1389      TStr attr;
1390      const TNEANet *Graph;
1391    public:
1392      TAIntVI() : HI(), IsDense(), HHI(), attr(), Graph(NULL) { }
1393      TAIntVI(const TIntVVecIter& HIter, const TIntHVecIter& HHIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt, bool is_dense) : HI(HIter), IsDense(is_dense), HHI(HHIter), attr(), Graph(GraphPt) {
1394        isNode = !isEdgeIter; attr = attribute;
1395      }
1396      TAIntVI(const TAIntVI& I) : HI(I.HI), IsDense(I.IsDense), HHI(I.HHI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1397      TAIntVI& operator = (const TAIntVI& I) { HI = I.HI; HHI = I.HHI, Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1398      bool operator < (const TAIntVI& I) const { return HI == I.HI ? HHI < I.HHI : HI < I.HI; }
1399      bool operator == (const TAIntVI& I) const { return HI == I.HI && HHI == I.HHI; }
1400      TIntV GetDat() const { return IsDense? HI[0] : HHI.GetDat(); }
1401      TAIntVI& operator++(int) { if (IsDense) {HI++;} else {HHI++;} return *this; }
1402      friend class TNEANet;
1403    };
1404    class TAFltVI {
1405    private:
1406      typedef TVec<TFltV>::TIter TFltVVecIter;
1407      TFltVVecIter HI;
1408      bool IsDense;
1409      typedef THash<TInt, TFltV>::TIter TFltHVecIter;
1410      TFltHVecIter HHI;
1411      bool isNode;
1412      TStr attr;
1413      const TNEANet *Graph;
1414    public:
1415      TAFltVI() : HI(), IsDense(), HHI(), attr(), Graph(NULL) { }
1416      TAFltVI(const TFltVVecIter& HIter, const TFltHVecIter& HHIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt, bool is_dense) : HI(HIter), IsDense(is_dense), HHI(HHIter), attr(), Graph(GraphPt) {
1417        isNode = !isEdgeIter; attr = attribute;
1418      }
1419      TAFltVI(const TAFltVI& I) : HI(I.HI), IsDense(I.IsDense), HHI(I.HHI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1420      TAFltVI& operator = (const TAFltVI& I) { HI = I.HI; HHI = I.HHI, Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1421      bool operator < (const TAFltVI& I) const { return HI == I.HI ? HHI < I.HHI : HI < I.HI; }
1422      bool operator == (const TAFltVI& I) const { return HI == I.HI && HHI == I.HHI; }
1423      TFltV GetDat() const { return IsDense? HI[0] : HHI.GetDat(); }
1424      TAFltVI& operator++(int) { if (IsDense) {HI++;} else {HHI++;} return *this; }
1425      friend class TNEANet;
1426    };
1427    class TAStrI {
1428    private:
1429      typedef TStrV::TIter TStrVecIter;
1430      TStrVecIter HI;
1431      bool isNode;
1432      TStr attr;
1433      const TNEANet *Graph;
1434    public:
1435      TAStrI() : HI(), attr(), Graph(NULL) { }
1436      TAStrI(const TStrVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
1437      TAStrI(const TAStrI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1438      TAStrI& operator = (const TAStrI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1439      bool operator < (const TAStrI& I) const { return HI < I.HI; }
1440      bool operator == (const TAStrI& I) const { return HI == I.HI; }
1441      TStr GetDat() const { return HI[0]; }
1442      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetStrAttrDefaultN(attr) : GetDat() == Graph->GetStrAttrDefaultE(attr); };
1443      TAStrI& operator++(int) { HI++; return *this; }
1444      friend class TNEANet;
1445    };
1446    class TAFltI {
1447    private:
1448      typedef TFltV::TIter TFltVecIter;
1449      TFltVecIter HI;
1450      bool isNode;
1451      TStr attr;
1452      const TNEANet *Graph;
1453    public:
1454      TAFltI() : HI(), attr(), Graph(NULL) { }
1455      TAFltI(const TFltVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
1456      TAFltI(const TAFltI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1457      TAFltI& operator = (const TAFltI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1458      bool operator < (const TAFltI& I) const { return HI < I.HI; }
1459      bool operator == (const TAFltI& I) const { return HI == I.HI; }
1460      TFlt GetDat() const { return HI[0]; }
1461      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetFltAttrDefaultN(attr) : GetDat() == Graph->GetFltAttrDefaultE(attr); };
1462      TAFltI& operator++(int) { HI++; return *this; }
1463      friend class TNEANet;
1464    };
1465  protected:
1466    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
1467    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
1468    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
1469    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
1470    int AddAttributes(const int NId);
1471  protected:
1472    TInt GetIntAttrDefaultN(const TStr& attribute) const { return IntDefaultsN.IsKey(attribute) ? IntDefaultsN.GetDat(attribute) : (TInt) TInt::Mn; }
1473    TStr GetStrAttrDefaultN(const TStr& attribute) const { return StrDefaultsN.IsKey(attribute) ? StrDefaultsN.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
1474    TFlt GetFltAttrDefaultN(const TStr& attribute) const { return FltDefaultsN.IsKey(attribute) ? FltDefaultsN.GetDat(attribute) : (TFlt) TFlt::Mn; }
1475    TInt GetIntAttrDefaultE(const TStr& attribute) const { return IntDefaultsE.IsKey(attribute) ? IntDefaultsE.GetDat(attribute) : (TInt) TInt::Mn; }
1476    TStr GetStrAttrDefaultE(const TStr& attribute) const { return StrDefaultsE.IsKey(attribute) ? StrDefaultsE.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
1477    TFlt GetFltAttrDefaultE(const TStr& attribute) const { return FltDefaultsE.IsKey(attribute) ? FltDefaultsE.GetDat(attribute) : (TFlt) TFlt::Mn; }
1478  public:
1479    TCRef CRef;
1480  protected:
1481    TInt MxNId, MxEId;
1482    THash<TInt, TNode> NodeH;
1483    THash<TInt, TEdge> EdgeH;
1484    TStrIntPrH KeyToIndexTypeN, KeyToIndexTypeE;
1485    THash<TStr, TBool> KeyToDenseN, KeyToDenseE;
1486    THash<TStr, TInt> IntDefaultsN, IntDefaultsE;
1487    THash<TStr, TStr> StrDefaultsN, StrDefaultsE;
1488    THash<TStr, TFlt> FltDefaultsN, FltDefaultsE;
1489    TVec<TIntV> VecOfIntVecsN, VecOfIntVecsE;
1490    TVec<TStrV> VecOfStrVecsN, VecOfStrVecsE;
1491    TVec<TFltV> VecOfFltVecsN, VecOfFltVecsE;
1492    TVec<TVec<TIntV> > VecOfIntVecVecsN, VecOfIntVecVecsE;
1493    TVec<TVec<TFltV> > VecOfFltVecVecsN, VecOfFltVecVecsE; 
1494    TVec<THash<TInt, TIntV> > VecOfIntHashVecsN, VecOfIntHashVecsE;
1495    TVec<THash<TInt, TFltV> > VecOfFltHashVecsN, VecOfFltHashVecsE;
1496    enum { IntType, StrType, FltType, IntVType, FltVType };
1497    TAttr SAttrN;
1498    TAttr SAttrE;
1499  private:
1500    class LoadTNodeFunctor {
1501    public:
1502      LoadTNodeFunctor() {}
1503      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
1504    };
1505    class LoadVecFunctor {
1506    public:
1507      LoadVecFunctor() {}
1508      template<typename TElem>
1509      void operator() (TVec<TElem>* n, TShMIn& ShMIn) {
1510        n->LoadShM(ShMIn);
1511      }
1512    };
1513    class LoadVecOfVecFunctor {
1514    public:
1515      LoadVecOfVecFunctor() {}
1516      template<typename TElem>
1517      void operator() (TVec<TVec<TElem> >* n, TShMIn& ShMIn) {
1518        LoadVecFunctor f;
1519        n->LoadShM(ShMIn, f);
1520      }
1521    };
1522    class LoadHashOfVecFunctor {
1523    public:
1524      LoadHashOfVecFunctor() {}
1525      template<typename TElem>
1526      void operator() (THash<TInt, TVec<TElem> >* n, TShMIn& ShMIn) {
1527        LoadVecFunctor f;
1528        n->LoadShM(ShMIn, f);
1529      }
1530    };
1531  protected:
1532    TInt CheckDenseOrSparseN(const TStr& attr) const {
1533      if (!KeyToDenseN.IsKey(attr)) return -1;
1534      if (KeyToDenseN.GetDat(attr)) return 1;
1535      return 0;
1536    }
1537    TInt CheckDenseOrSparseE(const TStr& attr) const {
1538      if (!KeyToDenseE.IsKey(attr)) return -1;
1539      if (KeyToDenseE.GetDat(attr)) return 1;
1540      return 0;
1541    }
1542  public:
1543    TNEANet() : CRef(), MxNId(0), MxEId(0), NodeH(), EdgeH(),
1544      KeyToIndexTypeN(), KeyToIndexTypeE(), KeyToDenseN(), KeyToDenseE(), IntDefaultsN(), IntDefaultsE(),
1545      StrDefaultsN(), StrDefaultsE(), FltDefaultsN(), FltDefaultsE(),
1546      VecOfIntVecsN(), VecOfIntVecsE(), VecOfStrVecsN(), VecOfStrVecsE(),
1547      VecOfFltVecsN(), VecOfFltVecsE(),  VecOfIntVecVecsN(), VecOfIntVecVecsE(),
1548      VecOfFltVecVecsN(), VecOfFltVecVecsE(), 
1549      VecOfIntHashVecsN(), VecOfIntHashVecsE(), 
1550      VecOfFltHashVecsN(), VecOfFltHashVecsE(), 
1551      SAttrN(), SAttrE(){ }
1552    explicit TNEANet(const int& Nodes, const int& Edges) : CRef(),
1553      MxNId(0), MxEId(0), NodeH(), EdgeH(), KeyToIndexTypeN(), KeyToIndexTypeE(), KeyToDenseN(), KeyToDenseE(),
1554      IntDefaultsN(), IntDefaultsE(), StrDefaultsN(), StrDefaultsE(),
1555      FltDefaultsN(), FltDefaultsE(), VecOfIntVecsN(), VecOfIntVecsE(),
1556      VecOfStrVecsN(), VecOfStrVecsE(), VecOfFltVecsN(), VecOfFltVecsE(), VecOfIntVecVecsN(), VecOfIntVecVecsE(),
1557      VecOfFltVecVecsN(), VecOfFltVecVecsE(), 
1558      VecOfIntHashVecsN(), VecOfIntHashVecsE(), 
1559      VecOfFltHashVecsN(), VecOfFltHashVecsE(), 
1560      SAttrN(), SAttrE()
1561      { Reserve(Nodes, Edges); }
1562    TNEANet(const TNEANet& Graph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId),
1563      NodeH(Graph.NodeH), EdgeH(Graph.EdgeH), KeyToIndexTypeN(), KeyToIndexTypeE(), KeyToDenseN(), KeyToDenseE(),
1564      IntDefaultsN(), IntDefaultsE(), StrDefaultsN(), StrDefaultsE(),
1565      FltDefaultsN(), FltDefaultsE(), VecOfIntVecsN(), VecOfIntVecsE(),
1566      VecOfStrVecsN(), VecOfStrVecsE(), VecOfFltVecsN(), VecOfFltVecsE(), VecOfIntVecVecsN(), VecOfIntVecVecsE(),
1567      VecOfFltVecVecsN(), VecOfFltVecVecsE(), 
1568      VecOfIntHashVecsN(), VecOfIntHashVecsE(), 
1569      VecOfFltHashVecsN(), VecOfFltHashVecsE(), 
1570      SAttrN(), SAttrE() { }
1571    TNEANet(TSIn& SIn) : MxNId(SIn), MxEId(SIn), NodeH(SIn), EdgeH(SIn),
1572      KeyToIndexTypeN(SIn), KeyToIndexTypeE(SIn), KeyToDenseN(SIn), KeyToDenseE(SIn), IntDefaultsN(SIn), IntDefaultsE(SIn),
1573      StrDefaultsN(SIn), StrDefaultsE(SIn), FltDefaultsN(SIn), FltDefaultsE(SIn),
1574      VecOfIntVecsN(SIn), VecOfIntVecsE(SIn), VecOfStrVecsN(SIn),VecOfStrVecsE(SIn),
1575      VecOfFltVecsN(SIn), VecOfFltVecsE(SIn), VecOfIntVecVecsN(SIn), VecOfIntVecVecsE(SIn), 
1576      VecOfFltVecVecsN(SIn), VecOfFltVecVecsE(SIn), 
1577      VecOfIntHashVecsN(SIn), VecOfIntHashVecsE(SIn),
1578      VecOfFltHashVecsN(SIn), VecOfFltHashVecsE(SIn), 
1579      SAttrN(SIn), SAttrE(SIn) { }
1580  protected:
1581    TNEANet(const TNEANet& Graph, bool modeSubGraph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId),
1582      NodeH(Graph.NodeH), EdgeH(Graph.EdgeH), KeyToIndexTypeN(), KeyToIndexTypeE(Graph.KeyToIndexTypeE), KeyToDenseN(), KeyToDenseE(Graph.KeyToDenseE),
1583      IntDefaultsN(Graph.IntDefaultsN), IntDefaultsE(Graph.IntDefaultsE), StrDefaultsN(Graph.StrDefaultsN), StrDefaultsE(Graph.StrDefaultsE),
1584      FltDefaultsN(Graph.FltDefaultsN), FltDefaultsE(Graph.FltDefaultsE), VecOfIntVecsN(Graph.VecOfIntVecsN), VecOfIntVecsE(Graph.VecOfIntVecsE),
1585      VecOfStrVecsN(Graph.VecOfStrVecsN), VecOfStrVecsE(Graph.VecOfStrVecsE), VecOfFltVecsN(Graph.VecOfFltVecsN), VecOfFltVecsE(Graph.VecOfFltVecsE),
1586      VecOfIntVecVecsN(), VecOfIntVecVecsE(Graph.VecOfIntVecVecsE), 
1587      VecOfFltVecVecsN(), VecOfFltVecVecsE(Graph.VecOfFltVecVecsE), 
1588      VecOfIntHashVecsN(), VecOfIntHashVecsE(Graph.VecOfIntHashVecsE),
1589      VecOfFltHashVecsN(), VecOfFltHashVecsE(Graph.VecOfFltHashVecsE) 
1590       { }
1591    TNEANet(bool copyAll, const TNEANet& Graph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId),
1592      NodeH(Graph.NodeH), EdgeH(Graph.EdgeH), KeyToIndexTypeN(Graph.KeyToIndexTypeN), KeyToIndexTypeE(Graph.KeyToIndexTypeE), KeyToDenseN(Graph.KeyToDenseN), KeyToDenseE(Graph.KeyToDenseE),
1593      IntDefaultsN(Graph.IntDefaultsN), IntDefaultsE(Graph.IntDefaultsE), StrDefaultsN(Graph.StrDefaultsN), StrDefaultsE(Graph.StrDefaultsE),
1594      FltDefaultsN(Graph.FltDefaultsN), FltDefaultsE(Graph.FltDefaultsE), VecOfIntVecsN(Graph.VecOfIntVecsN), VecOfIntVecsE(Graph.VecOfIntVecsE),
1595      VecOfStrVecsN(Graph.VecOfStrVecsN), VecOfStrVecsE(Graph.VecOfStrVecsE), VecOfFltVecsN(Graph.VecOfFltVecsN), VecOfFltVecsE(Graph.VecOfFltVecsE),
1596      VecOfIntVecVecsN(Graph.VecOfIntVecVecsN), VecOfIntVecVecsE(Graph.VecOfIntVecVecsE), 
1597      VecOfFltVecVecsN(Graph.VecOfFltVecVecsN), VecOfFltVecVecsE(Graph.VecOfFltVecVecsE), 
1598      VecOfIntHashVecsN(Graph.VecOfIntHashVecsN), VecOfIntHashVecsE(Graph.VecOfIntHashVecsE), 
1599      VecOfFltHashVecsN(Graph.VecOfFltHashVecsN), VecOfFltHashVecsE(Graph.VecOfFltHashVecsE), 
1600      SAttrN(Graph.SAttrN), SAttrE(Graph.SAttrE) { }
1601  public:
1602    void Save(TSOut& SOut) const {
1603      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
1604      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
1605      KeyToDenseN.Save(SOut); KeyToDenseE.Save(SOut);
1606      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
1607      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
1608      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
1609      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
1610      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
1611      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut);
1612      VecOfIntVecVecsN.Save(SOut); VecOfIntVecVecsE.Save(SOut);
1613      VecOfFltVecVecsN.Save(SOut); VecOfFltVecVecsE.Save(SOut); 
1614      VecOfIntHashVecsN.Save(SOut); VecOfIntHashVecsE.Save(SOut); 
1615      VecOfFltHashVecsN.Save(SOut); VecOfFltHashVecsE.Save(SOut); 
1616      SAttrN.Save(SOut); SAttrE.Save(SOut);
1617      SOut.Flush(); }
1618    void Save_V1(TSOut& SOut) const {
1619      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
1620      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
1621      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
1622      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
1623      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
1624      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
1625      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
1626      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut);
1627      SOut.Flush(); }
1628    void Save_V2(TSOut& SOut) const {
1629      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
1630      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
1631      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
1632      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
1633      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
1634      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
1635      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
1636      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut);
1637      VecOfIntVecVecsN.Save(SOut); VecOfIntVecVecsE.Save(SOut); 
1638      VecOfFltVecVecsN.Save(SOut); VecOfFltVecVecsE.Save(SOut); 
1639      SAttrN.Save(SOut); SAttrE.Save(SOut);
1640      SOut.Flush(); }
1641    static PNEANet New() { return PNEANet(new TNEANet()); }
1642    static PNEANet New(const int& Nodes, const int& Edges) { return PNEANet(new TNEANet(Nodes, Edges)); }
1643    static PNEANet Load(TSIn& SIn) { return PNEANet(new TNEANet(SIn)); }
1644    static PNEANet Load_V1(TSIn& SIn) {
1645      PNEANet Graph = PNEANet(new TNEANet());
1646      Graph->MxNId.Load(SIn); Graph->MxEId.Load(SIn);
1647      Graph->NodeH.Load(SIn); Graph->EdgeH.Load(SIn);
1648      Graph->KeyToIndexTypeN.Load(SIn); Graph->KeyToIndexTypeE.Load(SIn);
1649      Graph->IntDefaultsN.Load(SIn); Graph->IntDefaultsE.Load(SIn);
1650      Graph->StrDefaultsN.Load(SIn); Graph->StrDefaultsE.Load(SIn);
1651      Graph->FltDefaultsN.Load(SIn); Graph->FltDefaultsE.Load(SIn);
1652      Graph->VecOfIntVecsN.Load(SIn); Graph->VecOfIntVecsE.Load(SIn);
1653      Graph->VecOfStrVecsN.Load(SIn); Graph->VecOfStrVecsE.Load(SIn);
1654      Graph->VecOfFltVecsN.Load(SIn); Graph->VecOfFltVecsE.Load(SIn); 
1655      return Graph;
1656    }
1657    static PNEANet Load_V2(TSIn& SIn) {
1658      PNEANet Graph = PNEANet(new TNEANet());
1659      Graph->MxNId.Load(SIn); Graph->MxEId.Load(SIn);
1660      Graph->NodeH.Load(SIn); Graph->EdgeH.Load(SIn);
1661      Graph->KeyToIndexTypeN.Load(SIn); Graph->KeyToIndexTypeE.Load(SIn);
1662      Graph->IntDefaultsN.Load(SIn); Graph->IntDefaultsE.Load(SIn);
1663      Graph->StrDefaultsN.Load(SIn); Graph->StrDefaultsE.Load(SIn);
1664      Graph->FltDefaultsN.Load(SIn); Graph->FltDefaultsE.Load(SIn);
1665      Graph->VecOfIntVecsN.Load(SIn); Graph->VecOfIntVecsE.Load(SIn);
1666      Graph->VecOfStrVecsN.Load(SIn); Graph->VecOfStrVecsE.Load(SIn);
1667      Graph->VecOfFltVecsN.Load(SIn); Graph->VecOfFltVecsE.Load(SIn);
1668      Graph->VecOfIntVecVecsN.Load(SIn); Graph->VecOfIntVecVecsE.Load(SIn);
1669      Graph->VecOfFltVecVecsN.Load(SIn); Graph->VecOfFltVecVecsE.Load(SIn); 
1670      Graph->SAttrN.Load(SIn); Graph->SAttrE.Load(SIn);
1671      return Graph;
1672    }
1673    void LoadNetworkShM(TShMIn& ShMIn);
1674    static PNEANet LoadShM(TShMIn& ShMIn) {
1675      TNEANet* Network = new TNEANet();
1676      Network->LoadNetworkShM(ShMIn);
1677      return PNEANet(Network);
1678    }
1679    void ConvertToSparse() { 
1680      TInt VecLength = VecOfIntVecVecsN.Len();
1681      THash<TStr, TIntPr>::TIter iter;
1682      if (VecLength != 0) {
1683        VecOfIntHashVecsN = TVec<THash<TInt, TIntV> >(VecLength);
1684        for (iter = KeyToIndexTypeN.BegI(); !iter.IsEnd(); iter=iter.Next()) {
1685          if (iter.GetDat().Val1 == IntVType) {
1686            TStr attribute = iter.GetKey();
1687            TInt index = iter.GetDat().Val2();
1688            for (int i=0; i<VecOfIntVecVecsN[index].Len(); i++) {
1689              if(VecOfIntVecVecsN[index][i].Len() > 0) {
1690                VecOfIntHashVecsN[index].AddDat(TInt(i), VecOfIntVecVecsN[index][i]);
1691              }
1692            }
1693            KeyToDenseN.AddDat(attribute, TBool(false));
1694          }
1695        }
1696      }
1697      VecOfIntVecVecsN.Clr();
1698      VecLength = VecOfIntVecVecsE.Len();
1699      if (VecLength != 0) {
1700        VecOfIntHashVecsE = TVec<THash<TInt, TIntV> >(VecLength);
1701        for (iter = KeyToIndexTypeE.BegI(); !iter.IsEnd(); iter=iter.Next()) {
1702          if (iter.GetDat().Val1 == IntVType) {
1703            TStr attribute = iter.GetKey();
1704            TInt index = iter.GetDat().Val2();
1705            for (int i=0; i<VecOfIntVecVecsE[index].Len(); i++) {
1706              if(VecOfIntVecVecsE[index][i].Len() > 0) {
1707                VecOfIntHashVecsE[index].AddDat(TInt(i), VecOfIntVecVecsE[index][i]);
1708              }
1709            }
1710            KeyToDenseE.AddDat(attribute, TBool(false));
1711          }
1712        }
1713      }
1714      VecOfIntVecVecsE.Clr();
1715      VecLength = VecOfFltVecVecsN.Len();
1716      if (VecLength != 0) {
1717        VecOfFltHashVecsN = TVec<THash<TInt, TFltV> >(VecLength);
1718        for (iter = KeyToIndexTypeN.BegI(); !iter.IsEnd(); iter=iter.Next()) {
1719          if (iter.GetDat().Val1 == FltVType) {
1720            TStr attribute = iter.GetKey();
1721            TInt index = iter.GetDat().Val2();
1722            for (int i=0; i<VecOfFltVecVecsN[index].Len(); i++) {
1723              if(VecOfFltVecVecsN[index][i].Len() > 0) {
1724                VecOfFltHashVecsN[index].AddDat(TInt(i), VecOfFltVecVecsN[index][i]);
1725              }
1726            }
1727            KeyToDenseN.AddDat(attribute, TBool(false));
1728          }
1729        }
1730      }
1731      VecOfFltVecVecsN.Clr();
1732      VecLength = VecOfFltVecVecsE.Len();
1733      if (VecLength != 0) {
1734        VecOfFltHashVecsE = TVec<THash<TInt, TFltV> >(VecLength);
1735        for (iter = KeyToIndexTypeE.BegI(); !iter.IsEnd(); iter=iter.Next()) {
1736          if (iter.GetDat().Val1 == FltVType) {
1737            TStr attribute = iter.GetKey();
1738            TInt index = iter.GetDat().Val2();
1739            for (int i=0; i<VecOfFltVecVecsE[index].Len(); i++) {
1740              if(VecOfFltVecVecsE[index][i].Len() > 0) {
1741                VecOfFltHashVecsE[index].AddDat(TInt(i), VecOfFltVecVecsE[index][i]);
1742              }
1743            }
1744            KeyToDenseE.AddDat(attribute, TBool(false));
1745          }
1746        }
1747      }
1748      VecOfFltVecVecsE.Clr();
1749    }
1750    bool HasFlag(const TGraphFlag& Flag) const;
1751    TNEANet& operator = (const TNEANet& Graph) { if (this!=&Graph) {
1752      MxNId=Graph.MxNId; MxEId=Graph.MxEId; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH; }
1753      return *this; }
1754    int GetNodes() const { return NodeH.Len(); }
1755    int AddNode(int NId = -1);
1756    int AddNodeUnchecked(int NId = -1);
1757    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId()); }
1758    virtual void DelNode(const int& NId);
1759    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
1760    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
1761    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
1762    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
1763    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
1764    TAIntI BegNAIntI(const TStr& attr) const {
1765      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
1766    TAIntI EndNAIntI(const TStr& attr) const {
1767      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
1768    TAIntI GetNAIntI(const TStr& attr, const int& NId) const {
1769      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
1770    TAIntVI BegNAIntVI(const TStr& attr) const {
1771      TVec<TIntV>::TIter HI = NULL;
1772      THash<TInt, TIntV>::TIter HHI;
1773      TInt location = CheckDenseOrSparseN(attr);
1774      TBool IsDense = true;
1775      if (location != -1) {
1776        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1777        if (location == 1) {
1778          HI = VecOfIntVecVecsN[index].BegI();
1779        } else {
1780          IsDense = false;
1781          HHI = VecOfIntHashVecsN[index].BegI();
1782        }
1783      }
1784      return TAIntVI(HI, HHI, attr, false, this, IsDense);
1785    }
1786    TAIntVI EndNAIntVI(const TStr& attr) const {
1787      TVec<TIntV>::TIter HI = NULL;
1788      THash<TInt, TIntV>::TIter HHI;
1789      TInt location = CheckDenseOrSparseN(attr);
1790      TBool IsDense = true;
1791      if (location != -1) {
1792        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1793        if (location == 1) {
1794          HI = VecOfIntVecVecsN[index].EndI();
1795        } else {
1796          IsDense = false;
1797          HHI = VecOfIntHashVecsN[index].EndI();
1798        }
1799      }
1800      return TAIntVI(HI, HHI, attr, false, this, IsDense);
1801    }
1802    TAIntVI GetNAIntVI(const TStr& attr, const int& NId) const {
1803      TVec<TIntV>::TIter HI = NULL;
1804      THash<TInt, TIntV>::TIter HHI;
1805      TInt location = CheckDenseOrSparseN(attr);
<span onclick='openModal()' class='match'>1806      TBool IsDense = true;
1807      if (location != -1) {
1808        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1809        if (location == 1) {
1810          HI = VecOfIntVecVecsN[index].GetI(NodeH.GetKeyId(NId));
1811        } else {
1812          IsDense = false;
</span>1813          HHI = VecOfIntHashVecsN[index].GetI(NodeH.GetKeyId(NId));
1814        }
1815      }
1816      return TAIntVI(HI, HHI, attr, false, this, IsDense);
1817    }
1818    TAFltVI BegNAFltVI(const TStr& attr) const {
1819      TVec<TFltV>::TIter HI = NULL;
1820      THash<TInt, TFltV>::TIter HHI;
1821      TInt location = CheckDenseOrSparseN(attr);
1822      TBool IsDense = true;
1823      if (location != -1) {
1824        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1825        if (location == 1) {
1826          HI = VecOfFltVecVecsN[index].BegI();
1827        } else {
1828          IsDense = false;
1829          HHI = VecOfFltHashVecsN[index].BegI();
1830        }
1831      }
1832      return TAFltVI(HI, HHI, attr, false, this, IsDense);
1833    }
1834    TAFltVI EndNAFltVI(const TStr& attr) const {
1835      TVec<TFltV>::TIter HI = NULL;
1836      THash<TInt, TFltV>::TIter HHI;
1837      TInt location = CheckDenseOrSparseN(attr);
1838      TBool IsDense = true;
1839      if (location != -1) {
1840        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1841        if (location == 1) {
1842          HI = VecOfFltVecVecsN[index].EndI();
1843        } else {
1844          IsDense = false;
1845          HHI = VecOfFltHashVecsN[index].EndI();
1846        }
1847      }
1848      return TAFltVI(HI, HHI, attr, false, this, IsDense);
1849    }
1850    TAFltVI GetNAFltVI(const TStr& attr, const int& NId) const {
1851      TVec<TFltV>::TIter HI = NULL;
1852      THash<TInt, TFltV>::TIter HHI;
1853      TInt location = CheckDenseOrSparseN(attr);
1854      TBool IsDense = true;
1855      if (location != -1) {
1856        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1857        if (location == 1) {
1858          HI = VecOfFltVecVecsN[index].GetI(NodeH.GetKeyId(NId));
1859        } else {
1860          IsDense = false;
1861          HHI = VecOfFltHashVecsN[index].GetI(NodeH.GetKeyId(NId));
1862        }
1863      }
1864      return TAFltVI(HI, HHI, attr, false, this, IsDense);
1865    }
1866    TAStrI BegNAStrI(const TStr& attr) const {
1867      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
1868    TAStrI EndNAStrI(const TStr& attr) const {
1869      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
1870    TAStrI GetNAStrI(const TStr& attr, const int& NId) const {
1871      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
1872    TAFltI BegNAFltI(const TStr& attr) const {
1873      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
1874    TAFltI EndNAFltI(const TStr& attr) const {
1875      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
1876    TAFltI GetNAFltI(const TStr& attr, const int& NId) const {
1877      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
1878    void AttrNameNI(const TInt& NId, TStrV& Names) const {
1879      AttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1880    void AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1881    void AttrValueNI(const TInt& NId, TStrV& Values) const {
1882      AttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1883    void AttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const;
1884    void IntAttrNameNI(const TInt& NId, TStrV& Names) const {
1885      IntAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1886    void IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1887    void IntAttrValueNI(const TInt& NId, TIntV& Values) const {
1888      IntAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1889    void IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const;
1890    void IntVAttrNameNI(const TInt& NId, TStrV& Names) const {
1891      IntVAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1892    void IntVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1893    void IntVAttrValueNI(const TInt& NId, TVec<TIntV>& Values) const {
1894      IntVAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1895    void IntVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TIntV>& Values) const;
1896    void FltVAttrNameNI(const TInt& NId, TStrV& Names) const {
1897      FltVAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1898    void FltVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1899    void FltVAttrValueNI(const TInt& NId, TVec<TFltV>& Values) const {
1900      FltVAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1901    void FltVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TFltV>& Values) const;
1902    void StrAttrNameNI(const TInt& NId, TStrV& Names) const {
1903      StrAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1904    void StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1905    void StrAttrValueNI(const TInt& NId, TStrV& Values) const {
1906      StrAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1907    void StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const;
1908    void FltAttrNameNI(const TInt& NId, TStrV& Names) const {
1909      FltAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1910    void FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1911    void FltAttrValueNI(const TInt& NId, TFltV& Values) const {
1912      FltAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1913    void FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const;
1914    void AttrNameEI(const TInt& EId, TStrV& Names) const {
1915      AttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1916    void AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1917    void AttrValueEI(const TInt& EId, TStrV& Values) const {
1918      AttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1919    void AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const;
1920    void IntAttrNameEI(const TInt& EId, TStrV& Names) const {
1921      IntAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1922    void IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1923    void IntAttrValueEI(const TInt& EId, TIntV& Values) const {
1924      IntAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1925    void IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const;
1926    void IntVAttrNameEI(const TInt& EId, TStrV& Names) const {
1927      IntVAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1928    void IntVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1929    void IntVAttrValueEI(const TInt& EId, TVec<TIntV>& Values) const {
1930      IntVAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1931    void IntVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TIntV>& Values) const;
1932    void FltVAttrNameEI(const TInt& EId, TStrV& Names) const {
1933      FltVAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1934    void FltVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1935    void FltVAttrValueEI(const TInt& EId, TVec<TFltV>& Values) const {
1936      FltVAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1937    void FltVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TFltV>& Values) const;
1938    void StrAttrNameEI(const TInt& EId, TStrV& Names) const {
1939      StrAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1940    void StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1941    void StrAttrValueEI(const TInt& EId, TStrV& Values) const {
1942      StrAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1943    void StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const;
1944    void FltAttrNameEI(const TInt& EId, TStrV& Names) const {
1945      FltAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1946    void FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1947    void FltAttrValueEI(const TInt& EId, TFltV& Values) const {
1948      FltAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1949    void FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const;
1950    TAIntI BegEAIntI(const TStr& attr) const {
1951      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);
1952    }
1953    TAIntI EndEAIntI(const TStr& attr) const {
1954      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
1955    }
1956    TAIntI GetEAIntI(const TStr& attr, const int& EId) const {
1957      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
1958    }
1959    TAIntVI BegEAIntVI(const TStr& attr) const {
1960      TVec<TIntV>::TIter HI = NULL;
1961      THash<TInt, TIntV>::TIter HHI;
1962      TInt location = CheckDenseOrSparseE(attr);
1963      TBool IsDense = true;
1964      if (location != -1) {
1965        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
1966        if (location == 1) {
1967          HI = VecOfIntVecVecsE[index].BegI();
1968        } else {
1969          IsDense = false;
1970          HHI = VecOfIntHashVecsE[index].BegI();
1971        }
1972      }
1973      return TAIntVI(HI, HHI, attr, true, this, IsDense);
1974    }
1975    TAIntVI EndEAIntVI(const TStr& attr) const {
1976      TVec<TIntV>::TIter HI = NULL;
1977      THash<TInt, TIntV>::TIter HHI;
1978      TInt location = CheckDenseOrSparseE(attr);
1979      TBool IsDense = true;
1980      if (location != -1) {
1981        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
1982        if (location == 1) {
1983          HI = VecOfIntVecVecsE[index].EndI();
1984        } else {
1985          IsDense = false;
1986          HHI = VecOfIntHashVecsE[index].EndI();
1987        }
1988      }
1989      return TAIntVI(HI, HHI, attr, true, this, IsDense);
1990    }
1991    TAIntVI GetEAIntVI(const TStr& attr, const int& EId) const {
1992      TVec<TIntV>::TIter HI = NULL;
1993      THash<TInt, TIntV>::TIter HHI;
1994      TInt location = CheckDenseOrSparseE(attr);
1995      TBool IsDense = true;
1996      if (location != -1) {
1997        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
1998        if (location == 1) {
1999          HI = VecOfIntVecVecsE[index].GetI(EdgeH.GetKeyId(EId));
2000        } else {
2001          IsDense = false;
2002          HHI = VecOfIntHashVecsE[index].GetI(EdgeH.GetKeyId(EId));
2003        }
2004      }
2005      return TAIntVI(HI, HHI, attr, true, this, IsDense);
2006    }
2007    TAFltVI BegEAFltVI(const TStr& attr) const {
2008      TVec<TFltV>::TIter HI = NULL;
2009      THash<TInt, TFltV>::TIter HHI;
2010      TInt location = CheckDenseOrSparseE(attr);
2011      TBool IsDense = true;
2012      if (location != -1) {
2013        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
2014        if (location == 1) {
2015          HI = VecOfFltVecVecsE[index].BegI();
2016        } else {
2017          IsDense = false;
2018          HHI = VecOfFltHashVecsE[index].BegI();
2019        }
2020      }
2021      return TAFltVI(HI, HHI, attr, true, this, IsDense);
2022    }
2023    TAFltVI EndEAFltVI(const TStr& attr) const {
2024      TVec<TFltV>::TIter HI = NULL;
2025      THash<TInt, TFltV>::TIter HHI;
2026      TInt location = CheckDenseOrSparseE(attr);
2027      TBool IsDense = true;
2028      if (location != -1) {
2029        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
2030        if (location == 1) {
2031          HI = VecOfFltVecVecsE[index].EndI();
2032        } else {
2033          IsDense = false;
2034          HHI = VecOfFltHashVecsE[index].EndI();
2035        }
2036      }
2037      return TAFltVI(HI, HHI, attr, true, this, IsDense);
2038    }
2039    TAFltVI GetEAFltVI(const TStr& attr, const int& EId) const {
2040      TVec<TFltV>::TIter HI = NULL;
2041      THash<TInt, TFltV>::TIter HHI;
2042      TInt location = CheckDenseOrSparseE(attr);
2043      TBool IsDense = true;
2044      if (location != -1) {
2045        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
2046        if (location == 1) {
2047          HI = VecOfFltVecVecsE[index].GetI(EdgeH.GetKeyId(EId));
2048        } else {
2049          IsDense = false;
2050          HHI = VecOfFltHashVecsE[index].GetI(EdgeH.GetKeyId(EId));
2051        }
2052      }
2053      return TAFltVI(HI, HHI, attr, true, this, IsDense);
2054    }
2055    TAStrI BegEAStrI(const TStr& attr) const {
2056      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);   }
2057    TAStrI EndEAStrI(const TStr& attr) const {
2058      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
2059    }
2060    TAStrI GetEAStrI(const TStr& attr, const int& EId) const {
2061      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
2062    }
2063    TAFltI BegEAFltI(const TStr& attr) const {
2064      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);
2065    }
2066    TAFltI EndEAFltI(const TStr& attr) const {
2067      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
2068    }
2069    TAFltI GetEAFltI(const TStr& attr, const int& EId) const {
2070      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
2071    }
2072    int GetMxNId() const { return MxNId; }
2073    int GetMxEId() const { return MxEId; }
2074    int GetEdges() const { return EdgeH.Len(); }
2075    int AddEdge(const int& SrcNId, const int& DstNId, int EId  = -1);
2076    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetId()); }
2077    void DelEdge(const int& EId);
2078    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
2079    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
2080    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId; return IsEdge(SrcNId, DstNId, EId, IsDir); }
2081    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const;
2082    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
2083    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
2084    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
2085    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
2086    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
2087    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
2088    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
2089    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
2090    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
2091    void GetNIdV(TIntV& NIdV) const;
2092    void GetEIdV(TIntV& EIdV) const;
2093    bool Empty() const { return GetNodes()==0; }
2094    void Clr() { MxNId=0; MxEId=0; NodeH.Clr(); EdgeH.Clr();
2095      KeyToIndexTypeN.Clr(); KeyToIndexTypeE.Clr(); IntDefaultsN.Clr(); IntDefaultsE.Clr();
2096      StrDefaultsN.Clr(); StrDefaultsE.Clr(); FltDefaultsN.Clr(); FltDefaultsE.Clr();
2097      VecOfIntVecsN.Clr(); VecOfIntVecsE.Clr(); VecOfStrVecsN.Clr(); VecOfStrVecsE.Clr();
2098      VecOfFltVecsN.Clr(); VecOfFltVecsE.Clr(); VecOfIntVecVecsN.Clr(); VecOfIntVecVecsE.Clr(); 
2099      VecOfFltVecVecsN.Clr(); VecOfFltVecVecsE.Clr(); 
2100      SAttrN.Clr(); SAttrE.Clr();}
2101    void Reserve(const int& Nodes, const int& Edges) {
2102      if (Nodes>0) { NodeH.Gen(Nodes/2); } if (Edges>0) { EdgeH.Gen(Edges/2); } }
2103    void Defrag(const bool& OnlyNodeLinks=false);
2104    bool IsOk(const bool& ThrowExcept=true) const;
2105    void Dump(FILE *OutF=stdout) const;
2106    int AddIntAttrDatN(const TNodeI& NodeI, const TInt& value, const TStr& attr) { return AddIntAttrDatN(NodeI.GetId(), value, attr); }
2107    int AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr);
2108    int AddStrAttrDatN(const TNodeI& NodeI, const TStr& value, const TStr& attr) { return AddStrAttrDatN(NodeI.GetId(), value, attr); }
2109    int AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr);
2110    int AddFltAttrDatN(const TNodeI& NodeI, const TFlt& value, const TStr& attr) { return AddFltAttrDatN(NodeI.GetId(), value, attr); }
2111    int AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr);
2112    int AddIntVAttrDatN(const TNodeI& NodeI, const TIntV& value, const TStr& attr) { return AddIntVAttrDatN(NodeI.GetId(), value, attr); }
2113    int AddIntVAttrDatN(const int& NId, const TIntV& value, const TStr& attr, TBool UseDense=true);
2114    int AddFltVAttrDatN(const TNodeI& NodeI, const TFltV& value, const TStr& attr) { return AddFltVAttrDatN(NodeI.GetId(), value, attr); }
2115    int AddFltVAttrDatN(const int& NId, const TFltV& value, const TStr& attr, TBool UseDense=true);
2116    int AppendIntVAttrDatN(const TNodeI& NodeI, const TInt& value, const TStr& attr) { return AppendIntVAttrDatN(NodeI.GetId(), value, attr); }
2117    int AppendIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr, TBool UseDense=true);
2118    int DelFromIntVAttrDatN(const TNodeI& NodeI, const TInt& value, const TStr& attr) { return DelFromIntVAttrDatN(NodeI.GetId(), value, attr); }
2119    int DelFromIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr);
2120    int AppendFltVAttrDatN(const TNodeI& NodeI, const TFlt& value, const TStr& attr) { return AppendFltVAttrDatN(NodeI.GetId(), value, attr); }
2121    int AppendFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr, TBool UseDense=true);
2122    int DelFromFltVAttrDatN(const TNodeI& NodeI, const TFlt& value, const TStr& attr) { return DelFromFltVAttrDatN(NodeI.GetId(), value, attr); }
2123    int DelFromFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr);
2124    int AddIntAttrDatE(const TEdgeI& EdgeI, const TInt& value, const TStr& attr) { return AddIntAttrDatE(EdgeI.GetId(), value, attr); }
2125    int AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr);
2126    int AddStrAttrDatE(const TEdgeI& EdgeI, const TStr& value, const TStr& attr) { return AddStrAttrDatE(EdgeI.GetId(), value, attr); }
2127    int AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr);
2128    int AddFltAttrDatE(const TEdgeI& EdgeI, const TFlt& value, const TStr& attr) { return AddFltAttrDatE(EdgeI.GetId(), value, attr); }
2129    int AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr);
2130    int AddIntVAttrDatE(const TEdgeI& EdgeI, const TIntV& value, const TStr& attr) { return AddIntVAttrDatE(EdgeI.GetId(), value, attr); }
2131    int AddIntVAttrDatE(const int& EId, const TIntV& value, const TStr& attr, TBool UseDense=true);
2132    int AppendIntVAttrDatE(const TEdgeI& EdgeI, const TInt& value, const TStr& attr) { return AppendIntVAttrDatE(EdgeI.GetId(), value, attr); }
2133    int AppendIntVAttrDatE(const int& EId, const TInt& value, const TStr& attr, TBool UseDense=true);
2134    int AddFltVAttrDatE(const TEdgeI& EdgeI, const TFltV& value, const TStr& attr) { return AddFltVAttrDatE(EdgeI.GetId(), value, attr); }
2135    int AddFltVAttrDatE(const int& EId, const TFltV& value, const TStr& attr, TBool UseDense=true);
2136    int AppendFltVAttrDatE(const TEdgeI& EdgeI, const TFlt& value, const TStr& attr) { return AppendFltVAttrDatE(EdgeI.GetId(), value, attr); }
2137    int AppendFltVAttrDatE(const int& EId, const TFlt& value, const TStr& attr, TBool UseDense=true);
2138    TInt GetIntAttrDatN(const TNodeI& NodeI, const TStr& attr) { return GetIntAttrDatN(NodeI.GetId(), attr); }
2139    TInt GetIntAttrDatN(const int& NId, const TStr& attr);
2140    TStr GetStrAttrDatN(const TNodeI& NodeI, const TStr& attr) { return GetStrAttrDatN(NodeI.GetId(), attr); }
2141    TStr GetStrAttrDatN(const int& NId, const TStr& attr);
2142    TFlt GetFltAttrDatN(const TNodeI& NodeI, const TStr& attr) { return GetFltAttrDatN(NodeI.GetId(), attr); }
2143    TFlt GetFltAttrDatN(const int& NId, const TStr& attr);
2144    TIntV GetIntVAttrDatN(const TNodeI& NodeI, const TStr& attr) const { return GetIntVAttrDatN(NodeI.GetId(), attr); }
2145    TIntV GetIntVAttrDatN(const int& NId, const TStr& attr) const;
2146    TFltV GetFltVAttrDatN(const TNodeI& NodeI, const TStr& attr) const { return GetFltVAttrDatN(NodeI.GetId(), attr); }
2147    TFltV GetFltVAttrDatN(const int& NId, const TStr& attr) const;
2148    int GetIntAttrIndN(const TStr& attr);
2149    int GetAttrIndN(const TStr& attr);
2150    TInt GetIntAttrIndDatN(const TNodeI& NodeI, const int& index) { return GetIntAttrIndDatN(NodeI.GetId(), index); }
2151    TInt GetIntAttrIndDatN(const int& NId, const int& index);
2152    TStr GetStrAttrIndDatN(const TNodeI& NodeI, const int& index) { return GetStrAttrIndDatN(NodeI.GetId(), index); }
2153    TStr GetStrAttrIndDatN(const int& NId, const int& index);
2154    TFlt GetFltAttrIndDatN(const TNodeI& NodeI, const int& index) { return GetFltAttrIndDatN(NodeI.GetId(), index); }
2155    TFlt GetFltAttrIndDatN(const int& NId, const int& index);
2156    TInt GetIntAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetIntAttrDatE(EdgeI.GetId(), attr); }
2157    TInt GetIntAttrDatE(const int& EId, const TStr& attr);
2158    TStr GetStrAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetStrAttrDatE(EdgeI.GetId(), attr); }
2159    TStr GetStrAttrDatE(const int& EId, const TStr& attr);
2160    TFlt GetFltAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetFltAttrDatE(EdgeI.GetId(), attr); }
2161    TFlt GetFltAttrDatE(const int& EId, const TStr& attr);
2162    TIntV GetIntVAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetIntVAttrDatE(EdgeI.GetId(), attr); }
2163    TIntV GetIntVAttrDatE(const int& EId, const TStr& attr);
2164    TFltV GetFltVAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetFltVAttrDatE(EdgeI.GetId(), attr); }
2165    TFltV GetFltVAttrDatE(const int& EId, const TStr& attr);
2166    int GetIntAttrIndE(const TStr& attr);
2167    int GetAttrIndE(const TStr& attr);
2168    TInt GetIntAttrIndDatE(const TEdgeI& EdgeI, const int& index) { return GetIntAttrIndDatE(EdgeI.GetId(), index); }
2169    TInt GetIntAttrIndDatE(const int& EId, const int& index);
2170    TFlt GetFltAttrIndDatE(const TEdgeI& EdgeI, const int& index) { return GetFltAttrIndDatE(EdgeI.GetId(), index); }
2171    TFlt GetFltAttrIndDatE(const int& EId, const int& index);
2172    TStr GetStrAttrIndDatE(const TEdgeI& EdgeI, const int& index) { return GetStrAttrIndDatE(EdgeI.GetId(), index); }
2173    TStr GetStrAttrIndDatE(const int& EId, const int& index);
2174    int DelAttrDatN(const TNodeI& NodeI, const TStr& attr) { return DelAttrDatN(NodeI.GetId(), attr); } 
2175    int DelAttrDatN(const int& NId, const TStr& attr); 
2176    int DelAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return DelAttrDatE(EdgeI.GetId(), attr); } 
2177    int DelAttrDatE(const int& EId, const TStr& attr); 
2178    int AddIntAttrN(const TStr& attr, TInt defaultValue=TInt::Mn);
2179    int AddStrAttrN(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
2180    int AddFltAttrN(const TStr& attr, TFlt defaultValue=TFlt::Mn);
2181    int AddIntVAttrN(const TStr& attr, TBool UseDense=true);
2182    int AddFltVAttrN(const TStr& attr, TBool UseDense=true);
2183    int AddIntAttrE(const TStr& attr, TInt defaultValue=TInt::Mn);
2184    int AddStrAttrE(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
2185    int AddFltAttrE(const TStr& attr, TFlt defaultValue=TFlt::Mn);
2186    int AddIntVAttrE(const TStr& attr, TBool UseDense=true);
2187    int AddFltVAttrE(const TStr& attr, TBool UseDense=true);
2188    int DelAttrN(const TStr& attr);
2189    int DelAttrE(const TStr& attr);
2190    bool IsAttrDeletedN(const int& NId, const TStr& attr) const;
2191    bool IsIntAttrDeletedN(const int& NId, const TStr& attr) const;
2192    bool IsIntVAttrDeletedN(const int& NId, const TStr& attr) const;
2193    bool IsFltVAttrDeletedN(const int& NId, const TStr& attr) const;
2194    bool IsStrAttrDeletedN(const int& NId, const TStr& attr) const;
2195    bool IsFltAttrDeletedN(const int& NId, const TStr& attr) const;
2196    bool NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2197    bool NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2198    bool NodeAttrIsIntVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2199    bool NodeAttrIsFltVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2200    bool NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2201    bool NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2202    bool IsAttrDeletedE(const int& EId, const TStr& attr) const;
2203    bool IsIntAttrDeletedE(const int& EId, const TStr& attr) const;
2204    bool IsIntVAttrDeletedE(const int& EId, const TStr& attr) const;
2205    bool IsFltVAttrDeletedE(const int& EId, const TStr& attr) const;
2206    bool IsStrAttrDeletedE(const int& EId, const TStr& attr) const;
2207    bool IsFltAttrDeletedE(const int& EId, const TStr& attr) const;
2208    bool EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2209    bool EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2210    bool EdgeAttrIsIntVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2211    bool EdgeAttrIsFltVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2212    bool EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2213    bool EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2214    TStr GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2215    TStr GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2216    TFlt GetWeightOutEdges(const TNodeI& NI, const TStr& attr);
2217    bool IsFltAttrE(const TStr& attr);
2218    bool IsIntAttrE(const TStr& attr);
2219    bool IsStrAttrE(const TStr& attr);
2220    TVec<TFlt>& GetFltAttrVecE(const TStr& attr);
2221    int GetFltKeyIdE(const int& EId);
2222    void GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) ;
2223    void GetAttrNNames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const;
2224    void GetAttrENames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const;
2225    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val);
2226    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val);
2227    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TInt& Val) {
2228      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2229    }
2230    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TInt& Val) {
2231      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2232    }
2233    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val);
2234    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val);
2235    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TFlt& Val) {
2236      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2237    }
2238    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TFlt& Val) {
2239      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2240    }
2241    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val);
2242    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val);
2243    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TStr& Val) {
2244      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2245    }
2246    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TStr& Val) {
2247      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2248    }
2249    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& ValX) const;
2250    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& ValX) const;
2251    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TInt& ValX) const {
2252      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2253    }
2254    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TInt& ValX) const {
2255      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2256    }
2257    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& ValX) const;
2258    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& ValX) const;
2259    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TFlt& ValX) const {
2260      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2261    } 
2262    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TFlt& ValX) const {
2263      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2264    }
2265    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& ValX) const;
2266    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& ValX) const;
2267    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TStr& ValX) const {
2268      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2269    }
2270    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TStr& ValX) const {
2271      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2272    }
2273    int DelSAttrDatN(const TInt& NId, const TStr& AttrName);
2274    int DelSAttrDatN(const TInt& NId, const TInt& AttrId);
2275    int DelSAttrDatN(const TNodeI& NodeI, const TStr& AttrName) {
2276      return DelSAttrDatN(NodeI.GetId(), AttrName);
2277    }
2278    int DelSAttrDatN(const TNodeI& NodeI, const TInt& AttrId) {
2279      return DelSAttrDatN(NodeI.GetId(), AttrId);
2280    }
2281    int GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2282    int GetSAttrVN(const TNodeI& NodeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2283      return GetSAttrVN(NodeI.GetId(), AttrType, AttrV);
2284    }
2285    int GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const;
2286    int GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const;
2287    int AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2288    int GetSAttrIdN(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2289    int GetSAttrNameN(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2290    int AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TInt& Val);
2291    int AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TInt& Val);
2292    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TInt& Val) {
2293      return AddSAttrDatE(EdgeI.GetId(), AttrName, Val);
2294    }
2295    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TInt& Val) {
2296      return AddSAttrDatE(EdgeI.GetId(), AttrId, Val);
2297    }
2298    int AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TFlt& Val);
2299    int AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TFlt& Val);
2300    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TFlt& Val) {
2301      return AddSAttrDatE(EdgeI.GetId(), AttrName, Val);
2302    }
2303    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TFlt& Val){
2304      return AddSAttrDatE(EdgeI.GetId(), AttrId, Val);
2305    }
2306    int AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TStr& Val);
2307    int AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TStr& Val);
2308    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TStr& Val) {
2309      return AddSAttrDatE(EdgeI.GetId(), AttrName, Val);
2310    }
2311    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TStr& Val) {
2312      return AddSAttrDatE(EdgeI.GetId(), AttrId, Val);
2313    }
2314    int GetSAttrDatE(const TInt& EId, const TStr& AttrName, TInt& ValX) const;
2315    int GetSAttrDatE(const TInt& EId, const TInt& AttrId, TInt& ValX) const;
2316    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TInt& ValX) const {
2317      return GetSAttrDatE(EdgeI.GetId(), AttrName, ValX);
2318    }
2319    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TInt& ValX) const {
2320      return GetSAttrDatE(EdgeI.GetId(), AttrId, ValX);
2321    } 
2322    int GetSAttrDatE(const TInt& EId, const TStr& AttrName, TFlt& ValX) const; 
2323    int GetSAttrDatE(const TInt& EId, const TInt& AttrId, TFlt& ValX) const;
2324    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TFlt& ValX) const {
2325      return GetSAttrDatE(EdgeI.GetId(), AttrName, ValX);
2326    }
2327    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TFlt& ValX) const {
2328      return GetSAttrDatE(EdgeI.GetId(), AttrId, ValX);
2329    } 
2330    int GetSAttrDatE(const TInt& EId, const TStr& AttrName, TStr& ValX) const;
2331    int GetSAttrDatE(const TInt& EId, const TInt& AttrId, TStr& ValX) const;
2332    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TStr& ValX) const {
2333      return GetSAttrDatE(EdgeI.GetId(), AttrName, ValX);
2334    }
2335    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TStr& ValX) const {
2336      return GetSAttrDatE(EdgeI.GetId(), AttrId, ValX);
2337    }
2338    int DelSAttrDatE(const TInt& EId, const TStr& AttrName);
2339    int DelSAttrDatE(const TInt& EId, const TInt& AttrId);
2340    int DelSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName) {
2341      return DelSAttrDatE(EdgeI.GetId(), AttrName);
2342    }
2343    int DelSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId) {
2344      return DelSAttrDatE(EdgeI.GetId(), AttrId);
2345    } 
2346    int GetSAttrVE(const TInt& EId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2347    int GetSAttrVE(const TEdgeI& EdgeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2348      return GetSAttrVE(EdgeI.GetId(), AttrType, AttrV);
2349    }
2350    int GetIdVSAttrE(const TStr& AttrName, TIntV& IdV) const;
2351    int GetIdVSAttrE(const TInt& AttrId, TIntV& IdV) const;
2352    int AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2353    int GetSAttrIdE(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2354    int GetSAttrNameE(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2355    static PNEANet GetSmallGraph();
2356    friend class TPt<TNEANet>;
2357  };
2358  namespace TSnap {
2359  template <> struct IsMultiGraph<TNEANet> { enum { Val = 1 }; };
2360  template <> struct IsDirected<TNEANet> { enum { Val = 1 }; };
2361  }
2362  class TUndirNet;
2363  typedef TPt<TUndirNet> PUndirNet;
2364  class TDirNet;
2365  typedef TPt<TDirNet> PDirNet;
2366  class TUndirNet {
2367  public:
2368    typedef TUndirNet TNet;
2369    typedef TPt<TUndirNet> PNet;
2370  public:
2371    class TNode {
2372    private:
2373      TInt Id;
2374      TIntV NIdV;
2375    public:
2376      TNode() : Id(-1), NIdV() { }
2377      TNode(const int& NId) : Id(NId), NIdV() { }
2378      TNode(const TNode& Node) : Id(Node.Id), NIdV(Node.NIdV) { }
2379      TNode(TSIn& SIn) : Id(SIn), NIdV(SIn) { }
2380      void Save(TSOut& SOut) const { Id.Save(SOut); NIdV.Save(SOut); }
2381      int GetId() const { return Id; }
2382      int GetDeg() const { return NIdV.Len(); }
2383      int GetInDeg() const { return GetDeg(); }
2384      int GetOutDeg() const { return GetDeg(); }
2385      int GetInNId(const int& NodeN) const { return GetNbrNId(NodeN); }
2386      int GetOutNId(const int& NodeN) const { return GetNbrNId(NodeN); }
2387      int GetNbrNId(const int& NodeN) const { return NIdV[NodeN]; }
2388      bool IsNbrNId(const int& NId) const { return NIdV.SearchBin(NId)!=-1; }
2389      bool IsInNId(const int& NId) const { return IsNbrNId(NId); }
2390      bool IsOutNId(const int& NId) const { return IsNbrNId(NId); }
2391      void PackOutNIdV() { NIdV.Pack(); }
2392      void PackNIdV() { NIdV.Pack(); }
2393      void SortNIdV() { NIdV.Sort();}
2394      void LoadShM(TShMIn& MStream) {
2395        Id = TInt(MStream);
2396        NIdV.LoadShM(MStream);
2397      }
2398      friend class TUndirNet;
2399      friend class TUndirNetMtx;
2400    };
2401    class TNodeI {
2402    private:
2403      typedef THash<TInt, TNode>::TIter THashIter;
2404      THashIter NodeHI;
2405    public:
2406      TNodeI() : NodeHI() { }
2407      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
2408      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
2409      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
2410      TNodeI& operator++ (int) { NodeHI++; return *this; }
2411      TNodeI& operator-- (int) { NodeHI--; return *this; }
2412      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
2413      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
2414      int GetId() const { return NodeHI.GetDat().GetId(); }
2415      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
2416      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
2417      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
2418      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
2419      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
2420      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
2421      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
2422      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
2423      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
2424      bool IsNbrNId(const int& NId) const { return NodeHI.GetDat().IsNbrNId(NId); }
2425      friend class TUndirNet;
2426    };
2427    class TEdgeI {
2428    private:
2429      TNodeI CurNode, EndNode;
2430      int CurEdge;
2431    public:
2432      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
2433      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
2434      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
2435      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; } return *this; }
2436      TEdgeI& operator++ (int) { do { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++; while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } } } while (CurNode < EndNode && GetSrcNId()>GetDstNId()); return *this; }
2437      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
2438      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
2439      int GetId() const { return -1; }
2440      int GetSrcNId() const { return CurNode.GetId(); }
2441      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
2442      friend class TUndirNet;
2443    };
2444  private:
2445    TCRef CRef;
2446    TInt MxNId, NEdges;
2447    THash<TInt, TNode> NodeH;
2448    TAttr SAttrN;
2449    TAttrPair SAttrE;
2450  private:
2451    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
2452    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
2453    TIntPr OrderEdgeNodes(const int& SrcNId, const int& DstNId) const;
2454  private:
2455    class LoadTNodeFunctor {
2456    public:
2457      LoadTNodeFunctor() {}
2458      void operator() (TNode* n, TShMIn& ShMIn) {n->LoadShM(ShMIn);}
2459    };
2460  private:
2461    void LoadNetworkShM(TShMIn& ShMIn) {
2462      MxNId = TInt(ShMIn);
2463      NEdges = TInt(ShMIn);
2464      LoadTNodeFunctor NodeFn;
2465      NodeH.LoadShM(ShMIn, NodeFn);
2466      SAttrN.Load(ShMIn);
2467      SAttrE = TAttrPair(ShMIn);
2468    }
2469  public:
2470    TUndirNet() : CRef(), MxNId(0), NEdges(0), NodeH(), SAttrN(), SAttrE() { }
2471    explicit TUndirNet(const int& Nodes, const int& Edges) : MxNId(0), NEdges(0), SAttrN(), SAttrE() { Reserve(Nodes, Edges); }
2472    TUndirNet(const TUndirNet& Graph) : MxNId(Graph.MxNId), NEdges(Graph.NEdges), NodeH(Graph.NodeH),
2473      SAttrN(), SAttrE() { }
2474    TUndirNet(TSIn& SIn) : MxNId(SIn), NEdges(SIn), NodeH(SIn), SAttrN(SIn), SAttrE(SIn) { }
2475    void Save(TSOut& SOut) const { MxNId.Save(SOut); NEdges.Save(SOut); NodeH.Save(SOut);
2476      SAttrN.Save(SOut); SAttrE.Save(SOut);
2477      SOut.Flush(); }
2478    void Save_V1(TSOut& SOut) const { MxNId.Save(SOut); NEdges.Save(SOut); NodeH.Save(SOut); SOut.Flush(); }
2479    static PUndirNet New() { return new TUndirNet(); }
2480    static PUndirNet New(const int& Nodes, const int& Edges) { return new TUndirNet(Nodes, Edges); }
2481    static PUndirNet Load(TSIn& SIn) { return PUndirNet(new TUndirNet(SIn)); }
2482    static PUndirNet Load_V1(TSIn& SIn) { PUndirNet Graph = PUndirNet(new TUndirNet());
2483      Graph->MxNId.Load(SIn); Graph->NEdges.Load(SIn); Graph->NodeH.Load(SIn); return Graph;
2484    }
2485    static PUndirNet LoadShM(TShMIn& ShMIn) {
2486      TUndirNet* Network = new TUndirNet();
2487      Network->LoadNetworkShM(ShMIn);
2488      return PUndirNet(Network);
2489    }
2490    bool HasFlag(const TGraphFlag& Flag) const;
2491    TUndirNet& operator = (const TUndirNet& Graph) {
2492      if (this!=&Graph) { MxNId=Graph.MxNId; NEdges=Graph.NEdges; NodeH=Graph.NodeH; } return *this; }
2493    int GetNodes() const { return NodeH.Len(); }
2494    int AddNode(int NId = -1);
2495    int AddNodeUnchecked(int NId = -1);
2496    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId()); }
2497    int AddNode(const int& NId, const TIntV& NbrNIdV);
2498    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& NIdVId);
2499    void DelNode(const int& NId);
2500    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
2501    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
2502    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
2503    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
2504    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
2505    int GetMxNId() const { return MxNId; }
2506    int GetEdges() const;
2507    int AddEdge(const int& SrcNId, const int& DstNId);
2508    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
2509    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
2510    void DelEdge(const int& SrcNId, const int& DstNId);
2511    bool IsEdge(const int& SrcNId, const int& DstNId) const;
2512    TEdgeI BegEI() const { TNodeI NI = BegNI(); TEdgeI EI(NI, EndNI(), 0); if (GetNodes() != 0 && (NI.GetOutDeg()==0 || NI.GetId()>NI.GetOutNId(0))) { EI++; } return EI; }
2513    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
2514    TEdgeI GetEI(const int& EId) const;
2515    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
2516    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
2517    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
2518    void GetNIdV(TIntV& NIdV) const;
2519    bool Empty() const { return GetNodes()==0; }
2520    void Clr() { MxNId=0; NEdges=0; NodeH.Clr(); SAttrN.Clr(); SAttrE.Clr(); }
2521    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) NodeH.Gen(Nodes/2); }
2522    void ReserveNIdDeg(const int& NId, const int& Deg) { GetNode(NId).NIdV.Reserve(Deg); }
2523    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
2524    void Defrag(const bool& OnlyNodeLinks=false);
2525    bool IsOk(const bool& ThrowExcept=true) const;
2526    void Dump(FILE *OutF=stdout) const;
2527    static PUndirNet GetSmallGraph();
2528    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val);
2529    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val);
2530    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TInt& Val) {
2531      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2532    }
2533    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TInt& Val) {
2534      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2535    }
2536    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val);
2537    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val);
2538    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TFlt& Val) {
2539      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2540    }
2541    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TFlt& Val) {
2542      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2543    }
2544    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val);
2545    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val);
2546    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TStr& Val) {
2547      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2548    }
2549    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TStr& Val) {
2550      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2551    }
2552    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& ValX) const;
2553    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& ValX) const;
2554    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TInt& ValX) const {
2555      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2556    }
2557    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TInt& ValX) const {
2558      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2559    }
2560    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& ValX) const;
2561    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& ValX) const;
2562    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TFlt& ValX) const {
2563      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2564    } 
2565    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TFlt& ValX) const {
2566      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2567    }
2568    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& ValX) const;
2569    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& ValX) const;
2570    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TStr& ValX) const {
2571      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2572    }
2573    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TStr& ValX) const {
2574      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2575    }
2576    int DelSAttrDatN(const TInt& NId, const TStr& AttrName);
2577    int DelSAttrDatN(const TInt& NId, const TInt& AttrId);
2578    int DelSAttrDatN(const TNodeI& NodeI, const TStr& AttrName) {
2579      return DelSAttrDatN(NodeI.GetId(), AttrName);
2580    }
2581    int DelSAttrDatN(const TNodeI& NodeI, const TInt& AttrId) {
2582      return DelSAttrDatN(NodeI.GetId(), AttrId);
2583    }
2584    int GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2585    int GetSAttrVN(const TNodeI& NodeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2586      return GetSAttrVN(NodeI.GetId(), AttrType, AttrV);
2587    }
2588    int GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const;
2589    int GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const;
2590    int AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2591    int GetSAttrIdN(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2592    int GetSAttrNameN(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2593    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val);
2594    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val);
2595    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TInt& Val) {
2596      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2597    }
2598    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TInt& Val) {
2599      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2600    }
2601    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val);
2602    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val);
2603    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TFlt& Val) {
2604      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2605    }
2606    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TFlt& Val){
2607      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2608    }
2609    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val);
2610    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val);
2611    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TStr& Val) {
2612      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2613    }
2614    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TStr& Val) {
2615      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2616    }
2617    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& ValX) const;
2618    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& ValX) const;
2619    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TInt& ValX) const {
2620      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2621    }
2622    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TInt& ValX) const {
2623      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2624    } 
2625    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& ValX) const; 
2626    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& ValX) const;
2627    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TFlt& ValX) const {
2628      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2629    }
2630    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TFlt& ValX) const {
2631      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2632    } 
2633    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& ValX) const;
2634    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& ValX) const;
2635    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TStr& ValX) const {
2636      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2637    }
2638    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TStr& ValX) const {
2639      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2640    }
2641    int DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName);
2642    int DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId);
2643    int DelSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName) {
2644      return DelSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName);
2645    }
2646    int DelSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId) {
2647      return DelSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId);
2648    } 
2649    int GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2650    int GetSAttrVE(const TEdgeI& EdgeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2651      return GetSAttrVE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrType, AttrV);
2652    }
2653    int GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const;
2654    int GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const;
2655    int AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2656    int GetSAttrIdE(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2657    int GetSAttrNameE(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2658    friend class TUndirNetMtx;
2659    friend class TPt<TUndirNet>;
2660  };
2661  class TDirNet {
2662  public:
2663    typedef TDirNet TNet;
2664    typedef TPt<TDirNet> PNet;
2665  public:
2666    class TNode {
2667    private:
2668      TInt Id;
2669      TIntV InNIdV, OutNIdV;
2670    public:
2671      TNode() : Id(-1), InNIdV(), OutNIdV() { }
2672      TNode(const int& NId) : Id(NId), InNIdV(), OutNIdV() { }
2673      TNode(const TNode& Node) : Id(Node.Id), InNIdV(Node.InNIdV), OutNIdV(Node.OutNIdV) { }
2674      TNode(TSIn& SIn) : Id(SIn), InNIdV(SIn), OutNIdV(SIn) { }
2675      void Save(TSOut& SOut) const { Id.Save(SOut); InNIdV.Save(SOut); OutNIdV.Save(SOut); }
2676      int GetId() const { return Id; }
2677      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
2678      int GetInDeg() const { return InNIdV.Len(); }
2679      int GetOutDeg() const { return OutNIdV.Len(); }
2680      int GetInNId(const int& NodeN) const { return InNIdV[NodeN]; }
2681      int GetOutNId(const int& NodeN) const { return OutNIdV[NodeN]; }
2682      int GetNbrNId(const int& NodeN) const { return NodeN<GetOutDeg()?GetOutNId(NodeN):GetInNId(NodeN-GetOutDeg()); }
2683      bool IsInNId(const int& NId) const { return InNIdV.SearchBin(NId) != -1; }
2684      bool IsOutNId(const int& NId) const { return OutNIdV.SearchBin(NId) != -1; }
2685      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
2686      void PackOutNIdV() { OutNIdV.Pack(); }
2687      void PackNIdV() { InNIdV.Pack(); }
2688      void SortNIdV() { InNIdV.Sort(); OutNIdV.Sort();}
2689      void LoadShM(TShMIn& MStream) {
2690        Id = TInt(MStream);
2691        InNIdV.LoadShM(MStream);
2692        OutNIdV.LoadShM(MStream);
2693      }
2694      friend class TDirNet;
2695      friend class TDirNetMtx;
2696    };
2697    class TNodeI {
2698    private:
2699      typedef THash<TInt, TNode>::TIter THashIter;
2700      THashIter NodeHI;
2701    public:
2702      TNodeI() : NodeHI() { }
2703      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
2704      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
2705      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
2706      TNodeI& operator++ (int) { NodeHI++; return *this; }
2707      TNodeI& operator-- (int) { NodeHI--; return *this; }
2708      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
2709      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
2710      int GetId() const { return NodeHI.GetDat().GetId(); }
2711      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
2712      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
2713      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
2714      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
2715      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
2716      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
2717      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
2718      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
2719      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
2720      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
2721      friend class TDirNet;
2722    };
2723    class TEdgeI {
2724    private:
2725      TNodeI CurNode, EndNode;
2726      int CurEdge;
2727    public:
2728      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
2729      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
2730      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
2731      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; }  return *this; }
2732      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++;
2733        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
2734      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
2735      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
2736      int GetId() const { return -1; }
2737      int GetSrcNId() const { return CurNode.GetId(); }
2738      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
2739      friend class TDirNet;
2740    };
2741  private:
2742    TCRef CRef;
2743    TInt MxNId;
2744    THash<TInt, TNode> NodeH;
2745    TAttr SAttrN;
2746    TAttrPair SAttrE;
2747  private:
2748    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
2749    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
2750  private:
2751    class TNodeFunctor {
2752    public:
2753      TNodeFunctor() {}
2754      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
2755    };
2756  private:
2757    void LoadNetworkShM(TShMIn& ShMIn) {
2758      MxNId = TInt(ShMIn);
2759      TNodeFunctor f;
2760      NodeH.LoadShM(ShMIn, f);
2761      SAttrN.Load(ShMIn);
2762      SAttrE = TAttrPair(ShMIn);
2763    }
2764  public:
2765    TDirNet() : CRef(), MxNId(0), NodeH(), SAttrN(), SAttrE() { }
2766    explicit TDirNet(const int& Nodes, const int& Edges) : MxNId(0), SAttrN(), SAttrE() { Reserve(Nodes, Edges); }
2767    TDirNet(const TDirNet& Graph) : MxNId(Graph.MxNId), NodeH(Graph.NodeH), SAttrN(), SAttrE() { }
2768    TDirNet(TSIn& SIn) : MxNId(SIn), NodeH(SIn), SAttrN(SIn), SAttrE(SIn) { }
2769    void Save(TSOut& SOut) const { MxNId.Save(SOut); NodeH.Save(SOut); SAttrN.Save(SOut); SAttrE.Save(SOut); SOut.Flush(); }
2770    void Save_V1(TSOut& SOut) const { MxNId.Save(SOut); NodeH.Save(SOut); SOut.Flush(); }
2771    static PDirNet New() { return new TDirNet(); }
2772    static PDirNet New(const int& Nodes, const int& Edges) { return new TDirNet(Nodes, Edges); }
2773    static PDirNet Load(TSIn& SIn) { return PDirNet(new TDirNet(SIn)); }
2774    static PDirNet Load_V1(TSIn& SIn) { PDirNet Graph = PDirNet(new TDirNet());
2775      Graph->MxNId.Load(SIn); Graph->NodeH.Load(SIn); return Graph;
2776    }
2777    static PDirNet LoadShM(TShMIn& ShMIn) {
2778      TDirNet* Network = new TDirNet();
2779      Network->LoadNetworkShM(ShMIn);
2780      return PDirNet(Network);
2781    }
2782    bool HasFlag(const TGraphFlag& Flag) const;
2783    TDirNet& operator = (const TDirNet& Graph) {
2784      if (this!=&Graph) { MxNId=Graph.MxNId; NodeH=Graph.NodeH; }  return *this; }
2785    int GetNodes() const { return NodeH.Len(); }
2786    int AddNode(int NId = -1);
2787    int AddNodeUnchecked(int NId = -1);
2788    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
2789    int AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV);
2790    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId);
2791    void DelNode(const int& NId);
2792    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
2793    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
2794    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
2795    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
2796    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
2797    int GetMxNId() const { return MxNId; }
2798    int GetEdges() const;
2799    int AddEdge(const int& SrcNId, const int& DstNId);
2800    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
2801    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
2802    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
2803    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
2804    TEdgeI BegEI() const { TNodeI NI=BegNI(); while(NI<EndNI() && NI.GetOutDeg()==0){NI++;} return TEdgeI(NI, EndNI()); }
2805    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
2806    TEdgeI GetEI(const int& EId) const; 
2807    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
2808    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
2809    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
2810    void GetNIdV(TIntV& NIdV) const;
2811    bool Empty() const { return GetNodes()==0; }
2812    void Clr() { MxNId=0; NodeH.Clr(); SAttrN.Clr(); SAttrE.Clr(); }
2813    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes/2); } }
2814    void ReserveNIdInDeg(const int& NId, const int& InDeg) { GetNode(NId).InNIdV.Reserve(InDeg); }
2815    void ReserveNIdOutDeg(const int& NId, const int& OutDeg) { GetNode(NId).OutNIdV.Reserve(OutDeg); }
2816    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
2817    void Defrag(const bool& OnlyNodeLinks=false);
2818    bool IsOk(const bool& ThrowExcept=true) const;
2819    void Dump(FILE *OutF=stdout) const;
2820    static PDirNet GetSmallGraph();
2821    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val);
2822    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val);
2823    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TInt& Val) {
2824      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2825    }
2826    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TInt& Val) {
2827      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2828    }
2829    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val);
2830    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val);
2831    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TFlt& Val) {
2832      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2833    }
2834    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TFlt& Val) {
2835      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2836    }
2837    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val);
2838    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val);
2839    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TStr& Val) {
2840      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2841    }
2842    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TStr& Val) {
2843      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2844    }
2845    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& ValX) const;
2846    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& ValX) const;
2847    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TInt& ValX) const {
2848      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2849    }
2850    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TInt& ValX) const {
2851      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2852    }
2853    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& ValX) const;
2854    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& ValX) const;
2855    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TFlt& ValX) const {
2856      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2857    } 
2858    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TFlt& ValX) const {
2859      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2860    }
2861    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& ValX) const;
2862    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& ValX) const;
2863    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TStr& ValX) const {
2864      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2865    }
2866    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TStr& ValX) const {
2867      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2868    }
2869    int DelSAttrDatN(const TInt& NId, const TStr& AttrName);
2870    int DelSAttrDatN(const TInt& NId, const TInt& AttrId);
2871    int DelSAttrDatN(const TNodeI& NodeI, const TStr& AttrName) {
2872      return DelSAttrDatN(NodeI.GetId(), AttrName);
2873    }
2874    int DelSAttrDatN(const TNodeI& NodeI, const TInt& AttrId) {
2875      return DelSAttrDatN(NodeI.GetId(), AttrId);
2876    }
2877    int GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2878    int GetSAttrVN(const TNodeI& NodeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2879      return GetSAttrVN(NodeI.GetId(), AttrType, AttrV);
2880    }
2881    int GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const;
2882    int GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const;
2883    int AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2884    int GetSAttrIdN(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2885    int GetSAttrNameN(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2886    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val);
2887    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val);
2888    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TInt& Val) {
2889      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2890    }
2891    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TInt& Val) {
2892      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2893    }
2894    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val);
2895    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val);
2896    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TFlt& Val) {
2897      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2898    }
2899    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TFlt& Val){
2900      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2901    }
2902    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val);
2903    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val);
2904    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TStr& Val) {
2905      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2906    }
2907    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TStr& Val) {
2908      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2909    }
2910    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& ValX) const;
2911    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& ValX) const;
2912    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TInt& ValX) const {
2913      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2914    }
2915    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TInt& ValX) const {
2916      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2917    } 
2918    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& ValX) const; 
2919    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& ValX) const;
2920    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TFlt& ValX) const {
2921      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2922    }
2923    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TFlt& ValX) const {
2924      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2925    } 
2926    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& ValX) const;
2927    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& ValX) const;
2928    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TStr& ValX) const {
2929      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2930    }
2931    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TStr& ValX) const {
2932      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2933    }
2934    int DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName);
2935    int DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId);
2936    int DelSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName) {
2937      return DelSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName);
2938    }
2939    int DelSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId) {
2940      return DelSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId);
2941    } 
2942    int GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2943    int GetSAttrVE(const TEdgeI& EdgeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2944      return GetSAttrVE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrType, AttrV);
2945    }
2946    int GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const;
2947    int GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const;
2948    int AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2949    int GetSAttrIdE(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2950    int GetSAttrNameE(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2951    friend class TPt<TDirNet>;
2952    friend class TDirNetMtx;
2953  };
2954  namespace TSnap {
2955  template <> struct IsDirected<TDirNet> { enum { Val = 1 }; };
2956  }
2957  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.h</div>
                </div>
                <div class="column column_space"><pre><code>1097              const int WId = WordH.GetKeyId(WordStr);
1098              if (WId != -1) {
1099                  PMWGixExpItem MWGixExpItem = TMWGixExpItem::NewItem(TMWdGixKey(WId));
1100                  if (MWGixExp->IsEmpty()) { MWGixExp = MWGixExpItem; }
1101                  else { MWGixExp = TMWGixExpItem::NewOr(MWGixExp, MWGixExpItem); }
</pre></code></div>
                <div class="column column_space"><pre><code>1806      TBool IsDense = true;
1807      if (location != -1) {
1808        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1809        if (location == 1) {
1810          HI = VecOfIntVecVecsN[index].GetI(NodeH.GetKeyId(NId));
1811        } else {
1812          IsDense = false;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    