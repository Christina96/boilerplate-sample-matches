
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.303370786516854%, Tokens: 13</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-compute_image_mean.cpp</h3>
            <pre><code>1  #include <stdint.h>
2  #include <algorithm>
3  #include <string>
4  #include <utility>
5  #include <vector>
6  #include "boost/scoped_ptr.hpp"
7  #include "gflags/gflags.h"
8  #include "glog/logging.h"
9  #include "caffe/proto/caffe.pb.h"
10  #include "caffe/util/db.hpp"
11  #include "caffe/util/io.hpp"
12  using namespace caffe;  
13  using std::max;
14  using std::pair;
15  using boost::scoped_ptr;
16  DEFINE_string(backend, "lmdb",
17          "The backend {leveldb, lmdb} containing the images");
18  int main(int argc, char** argv) {
19    ::google::InitGoogleLogging(argv[0]);
20  #ifdef USE_OPENCV
21  #ifndef GFLAGS_GFLAGS_H_
22    namespace gflags = google;
23  #endif
24    gflags::SetUsageMessage("Compute the mean_image of a set of images given by"
25          " a leveldb/lmdb\n"
26          "Usage:\n"
27          "    compute_image_mean [FLAGS] INPUT_DB [OUTPUT_FILE]\n");
28    gflags::ParseCommandLineFlags(&argc, &argv, true);
29    if (argc < 2 || argc > 3) {
30      gflags::ShowUsageWithFlagsRestrict(argv[0], "tools/compute_image_mean");
31      return 1;
32    }
33    scoped_ptr<db::DB> db(db::GetDB(FLAGS_backend));
34    db->Open(argv[1], db::READ);
35    scoped_ptr<db::Cursor> cursor(db->NewCursor());
36    BlobProto sum_blob;
37    int count = 0;
38    Datum datum;
39    datum.ParseFromString(cursor->value());
40    if (DecodeDatumNative(&datum)) {
41      LOG(INFO) << "Decoding Datum";
42    }
43    sum_blob.set_num(1);
44    sum_blob.set_channels(datum.channels());
45    sum_blob.set_height(datum.height());
46    sum_blob.set_width(datum.width());
47    const int data_size = datum.channels() * datum.height() * datum.width();
48    int size_in_datum = std::max<int>(datum.data().size(),
49                                      datum.float_data_size());
50    for (int i = 0; i < size_in_datum; ++i) {
51      sum_blob.add_data(0.);
52    }
53    LOG(INFO) << "Starting Iteration";
54    while (cursor->valid()) {
55      Datum datum;
56      datum.ParseFromString(cursor->value());
57      DecodeDatumNative(&datum);
58      const std::string& data = datum.data();
59      size_in_datum = std::max<int>(datum.data().size(),
60          datum.float_data_size());
61      CHECK_EQ(size_in_datum, data_size) << "Incorrect data field size " <<
62          size_in_datum;
63      if (data.size() != 0) {
64        CHECK_EQ(data.size(), size_in_datum);
65        for (int i = 0; i < size_in_datum; ++i) {
66          sum_blob.set_data(i, sum_blob.data(i) + (uint8_t)data[i]);
67        }
68      } else {
69        CHECK_EQ(datum.float_data_size(), size_in_datum);
70        for (int i = 0; i < size_in_datum; ++i) {
71          sum_blob.set_data(i, sum_blob.data(i) +
72              static_cast<float>(datum.float_data(i)));
73        }
74      }
75      ++count;
76      if (count % 10000 == 0) {
77        LOG(INFO) << "Processed " << count << " files.";
78      }
79      cursor->Next();
80    }
81    if (count % 10000 != 0) {
82      LOG(INFO) << "Processed " << count << " files.";
83    }
84    if (count == 0) {
85      LOG(FATAL) << "Division by zero 'count' value possible.";
86    }
87    for (int i = 0; i < sum_blob.data_size(); ++i) {
88      sum_blob.set_data(i, sum_blob.data(i) / count);
89    }
90    if (argc == 3) {
91      LOG(INFO) << "Write to " << argv[2];
92      WriteProtoToBinaryFile(sum_blob, argv[2]);
93    }
94    const int channels = sum_blob.channels();
95    const int dim = sum_blob.height() * sum_blob.width();
96    std::vector<float> mean_values(channels, 0.0);
97    LOG(INFO) << "Number of channels: " << channels;
<span onclick='openModal()' class='match'>98    for (int c = 0; c < channels; ++c) {
99      for (int i = 0; i < dim; ++i) {
100        mean_values[c] += sum_blob.data(dim * c + i);
101      }
102      LOG(INFO) << "mean_value channel [" << c << "]:" << mean_values[c] / dim;
103    }
</span>104  #else
105    LOG(FATAL) << "This tool requires OpenCV; compile with USE_OPENCV.";
106  #endif  
107    return 0;
108  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-batch_classification.cpp</h3>
            <pre><code>1  #include <caffe/caffe.hpp>
2  #ifdef USE_OPENCV
3  #include <opencv2/core/core.hpp>
4  #include <opencv2/highgui/highgui.hpp>
5  #include <opencv2/imgproc/imgproc.hpp>
6  #endif  
7  #include <algorithm>
8  #include <iosfwd>
9  #include <memory>
10  #include <string>
11  #include <utility>
12  #include <vector>
13  #include <gflags/gflags.h>
14  #ifdef USE_OPENCV
15  using namespace caffe;  
16  using std::string;
17  using std::cout;
18  using std::cerr;
19  using std::endl;
20  using std::vector;
21  DEFINE_string(model, "",
22      "Required; The model definition protocol buffer text file.");
23  DEFINE_string(weights, "",
24      "Required; The pretrained weights.");
25  DEFINE_string(input, "",
26      "Required; File that contain the path of input images line by line");
27  DEFINE_string(label_file, "",
28      "Required; The label file.");
29  DEFINE_string(engine, "",
30      "Optional; Engine can only be CAFFE | MKL2017 | MKLDNN");
31  DEFINE_string(mean_file, "",
32      "Optional; The mean file used to subtract from the input image.");
33  DEFINE_string(mean_value, "104,117,123",
34      "Optional; If specified, can be one value or can be same as image channels"
35      " - would subtract from the corresponding channel). Separated by ','.");
36  DEFINE_int32(batch_size, 1,
37      "Optional; batch size, default 1");
38  typedef std::pair<string, float> Prediction;
39  class Classifier {
40      public:
41          Classifier(const string& model_file,
42                  const string& trained_file,
43                  const string& mean_file,
44                  const string& mean_value,
45                  const string& label_file,
46                  const string& engine,
47                  const size_t batch_size,
48                  const size_t topN = 5
49                  );
50          vector<vector<Prediction> > ClassifyBatch(vector<cv::Mat>& imgs);
51      private:
52          void SetMean(const string& mean_file, const string& mean_value);
53          vector<float> PredictBatch(vector<cv::Mat>& imgs);
54          void WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch);
55          void WriteImgToInput(const vector<cv::Mat>& imgs, vector<vector<cv::Mat> >* input_channels_batch);
56          void Preprocess(cv::Mat& img);
57          void PreprocessBatch(vector<cv::Mat>& imgs);
58      private:
59          shared_ptr<Net<float> > net_;
60          cv::Size input_geometry_;
61          int num_channels_;
62          cv::Mat mean_;
63          size_t batch_size_;
64          size_t topN_;
65          std::vector<string> labels_;
66  };
67  Classifier::Classifier(const string& model_file,
68          const string& trained_file,
69          const string& mean_file,
70          const string& mean_value,
71          const string& label_file,
72          const string& engine,
73          const size_t batch_size,
74          const size_t topN
75          ) {
76  #ifdef CPU_ONLY
77      Caffe::set_mode(Caffe::CPU);
78  #else
79      Caffe::set_mode(Caffe::GPU);
80  #endif
81      net_.reset(new Net<float>(model_file, TEST, 0, NULL, NULL, engine));
82      net_->CopyTrainedLayersFrom(trained_file);
83      CHECK_EQ(net_->num_inputs(), 1) << "Network should have exactly one input.";
84      CHECK_EQ(net_->num_outputs(), 1) << "Network should have exactly one output.";
85      Blob<float>* input_layer = net_->input_blobs()[0];
86      num_channels_ = input_layer->channels();
87      CHECK(num_channels_ == 3 || num_channels_ == 1)
88          << "Input layer should have 1 or 3 channels.";
89      input_geometry_ = cv::Size(input_layer->width(), input_layer->height());
90      SetMean(mean_file, mean_value);
91      batch_size_ = batch_size;
92      topN_ = topN;
93      if(!label_file.empty()) {
94      std::ifstream labels(label_file.c_str());
95      CHECK(labels) << "Unable to open labels file " << label_file;
96      string line;
97      while (std::getline(labels, line))
98          labels_.push_back(string(line));
99      Blob<float>* output_layer = net_->output_blobs()[0];
100      CHECK_EQ(labels_.size(), output_layer->channels())
101          << "Number of labels is different from the output layer dimension.";
102      }
103  }
104  static bool PairCompare(const std::pair<float, int>& lhs,
105          const std::pair<float, int>& rhs) {
106      return lhs.first > rhs.first;
107  }
108  static vector<int> Argmax(const vector<float>& v, int N) {
109      vector<std::pair<float, int> > pairs;
110      for (size_t i = 0; i < v.size(); ++i)
111          pairs.push_back(std::make_pair(v[i], i));
112      std::partial_sort(pairs.begin(), pairs.begin() + N, pairs.end(), PairCompare);
113      vector<int> result;
114      for (int i = 0; i < N; ++i)
115          result.push_back(pairs[i].second);
116      return result;
117  }
118  vector<vector<Prediction> > Classifier::ClassifyBatch(vector<cv::Mat>& imgs) {
119      vector<float> output_batch = PredictBatch(imgs);
120      vector<vector<Prediction> > predictionsBatch;
121      int output_channels = net_->output_blobs()[0]->channels();
122      for (size_t i = 0; i < batch_size_; ++i) {
123          vector<float> output(output_batch.begin() + i*output_channels, output_batch.begin()+(i+1)*output_channels);
124          vector<int> maxN = Argmax(output, topN_);
125          vector<Prediction>  predictions;
126          for (int i = 0; i < topN_; ++i) {
127              int idx = maxN[i];
128              if(labels_.empty()) {
129                  predictions.push_back(std::make_pair(std::to_string(idx), output[idx]));
130              } else{
131                  predictions.push_back(std::make_pair(labels_[idx], output[idx]));
132              }
133          }
134          predictionsBatch.push_back(predictions);
135      }
136      return predictionsBatch;
137  }
138  void Classifier::SetMean(const string& mean_file, const string& mean_value) {
139      cv::Scalar channel_mean;
140      if(!mean_file.empty()) {
141          BlobProto blob_proto;
142          ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &blob_proto);
143          Blob<float> mean_blob;
144          mean_blob.FromProto(blob_proto);
145          CHECK_EQ(mean_blob.channels(), num_channels_)
146              << "Number of channels of mean file doesn't match input layer.";
147          vector<cv::Mat> channels;
148          float* data = mean_blob.mutable_cpu_data();
149          for (int i = 0; i < num_channels_; ++i) {
150              cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);
151              channels.push_back(channel);
152              data += mean_blob.height() * mean_blob.width();
153          }
154          cv::Mat mean;
155          cv::merge(channels, mean);
156          channel_mean = cv::mean(mean);
157          mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);
158      }
159      if (!mean_value.empty()) {
160          stringstream ss(mean_value);
161          vector<float> values;
162          string item;
163          while (getline(ss, item, ',')) {
164              float value = std::atof(item.c_str());
165              values.push_back(value);
166          }
167          CHECK(values.size() == 1 || values.size() == num_channels_) <<
168              "Specify either 1 mean_value or as many as channels: " << num_channels_;
169          std::vector<cv::Mat> channels;
170          for (int i = 0; i < num_channels_; ++i) {
171              cv::Mat channel(input_geometry_.height, input_geometry_.width, CV_32FC1,
172                      cv::Scalar(values[i]));
173              channels.push_back(channel);
174          }
175          cv::merge(channels, mean_);
176      }
177  }
178  vector<float> Classifier::PredictBatch(vector<cv::Mat>& imgs) {
179      Blob<float>* input_layer = net_->input_blobs()[0];
180      input_layer->Reshape(batch_size_, num_channels_,
181              input_geometry_.height, input_geometry_.width);
182      net_->Reshape();
183      vector<vector<cv::Mat> > input_channels_batch;
184      WrapInputLayerBatch(&input_channels_batch);
185      PreprocessBatch(imgs);
186      WriteImgToInput(imgs, &input_channels_batch);
187      net_->Forward();
188      Blob<float>* output_layer = net_->output_blobs()[0];
189      const float* begin = output_layer->cpu_data();
190      const float* end = begin + output_layer->channels() * batch_size_;
191      printf("output_layer->channels: %d\n", output_layer->channels());
192      return vector<float>(begin, end);
193  }
194  void Classifier::WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch) {
195      Blob<float>* input_layer = net_->input_blobs()[0];
196      int width = input_layer->width();
197      int height = input_layer->height();
198      float* input_data = input_layer->mutable_cpu_data();
199      int num = input_layer->num();
<span onclick='openModal()' class='match'>200      for( int j = 0; j < num; ++j) {
201          vector<cv::Mat> input_channels;
202          for (int i = 0; i < input_layer->channels(); ++i) {
203              cv::Mat channel(height, width, CV_32FC1, input_data);
204              input_channels.push_back(channel);
205              input_data += width * height;
206          }
207          input_channels_batch->push_back(input_channels);
208      }
</span>209  }
210  void Classifier::WriteImgToInput(const vector<cv::Mat>& imgs,
211          vector<vector<cv::Mat> >* input_channels_batch)
212  {
213      for(size_t i=0; i<batch_size_; ++i) {
214          cv::split(imgs[i], input_channels_batch->at(i));
215      }
216  }
217  void Classifier::PreprocessBatch(vector<cv::Mat>& imgs) {
218      for(size_t i=0; i<imgs.size(); ++i) {
219          Preprocess(imgs[i]);
220      }
221  }
222  void Classifier::Preprocess(cv::Mat& img) {
223      cv::Mat sample;
224      if (img.channels() == 3 && num_channels_ == 1)
225          cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);
226      else if (img.channels() == 4 && num_channels_ == 1)
227          cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);
228      else if (img.channels() == 4 && num_channels_ == 3)
229          cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);
230      else if (img.channels() == 1 && num_channels_ == 3)
231          cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
232      else
233          sample = img;
234      cv::Mat sample_resized;
235      if (sample.size() != input_geometry_)
236          cv::resize(sample, sample_resized, input_geometry_);
237      else
238          sample_resized = sample;
239      cv::Mat sample_float;
240      if (num_channels_ == 3)
241          sample_resized.convertTo(sample_float, CV_32FC3);
242      else
243          sample_resized.convertTo(sample_float, CV_32FC1);
244      cv::subtract(sample_float, mean_, img);
245  }
246  vector<cv::Mat> loadImgBatch(vector<string> imgNames) {
247      vector<cv::Mat> imgs;
248      for(size_t i=0; i<imgNames.size(); ++i) {
249          cv::Mat img = cv::imread(imgNames[i], -1);
250          CHECK(!img.empty()) << "Unable to decode image " << imgNames[i];
251          imgs.push_back(img);
252      }
253      return imgs;
254  }
255  void printPrediction(vector<Prediction> predictions) {
256      for (size_t i = 0; i < predictions.size(); ++i) {
257          Prediction p = predictions[i];
258          cout << std::fixed << std::setprecision(4) << p.second << " - \""
259              << p.first << "\"" << endl;
260      }
261  }
262  void printPredictionsBatch(vector<string> imgNames,
263          vector<vector<Prediction> > predictionsBatch) {
264      for( size_t i = 0; i < predictionsBatch.size(); ++i) {
265          cout << "---------- "<< i + 1 <<": Prediction for "
266              << imgNames[i] << " ----------" << endl;
267          printPrediction(predictionsBatch[i]);
268      }
269  }
270  vector<string> readImgListFromPath(string file) {
271      vector<string> rawImgNames;
272      std::ifstream input_lines(file.c_str());
273      CHECK(input_lines) << "Unable to open file " << file;
274      string line;
275      while (std::getline(input_lines, line))
276          rawImgNames.push_back(string(line));
277      return rawImgNames;
278  }
279  int main(int argc, char** argv) {
280      ::google::InitGoogleLogging(argv[0]);
281  #ifndef GFLAGS_GFLAGS_H_
282      namespace gflags = google;
283  #endif
284      gflags::SetUsageMessage("Image classification.\n"
285          "Usage:\n"
286          "batch_classification <args>\n"
287          "Example: ./batch_classification --model <model path> --weights <weights path> --input <input.txt> --batch_size <num>"
288          );
289      gflags::ParseCommandLineFlags(&argc, &argv, true);
290      CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition to score.";
291      CHECK_GT(FLAGS_weights.size(), 0) << "Need model weights to score.";
292      CHECK_GT(FLAGS_input.size(), 0) << "Need model weights to score.";
293      cout<<"Use batch size: "<< FLAGS_batch_size << endl;
294      if (FLAGS_mean_file.empty()) {
295          cout<<"Use mean value: "<< FLAGS_mean_value<<endl;
296      }else{
297          cout<<"Use mean file: "<<FLAGS_mean_file<<endl;
298      }
299  #ifdef USE_MLSL
300      caffe::mn::init(&argc,&argv);
301  #endif
302      Classifier classifier(FLAGS_model, FLAGS_weights, FLAGS_mean_file,
303              FLAGS_mean_value, FLAGS_label_file, FLAGS_engine, FLAGS_batch_size);
304      vector<string> rawImgNames = readImgListFromPath(FLAGS_input);
305      if(rawImgNames.size() > 0 && rawImgNames.size() < FLAGS_batch_size) {
306          while(rawImgNames.size() < FLAGS_batch_size) {
307              rawImgNames.insert(rawImgNames.end(), rawImgNames.begin(), rawImgNames.end());
308          }
309      }
310      vector<string> imgNames(rawImgNames.begin(), rawImgNames.begin() + FLAGS_batch_size);
311      vector<cv::Mat> imgs = loadImgBatch(rawImgNames);
312      vector<vector<Prediction> > predictionsBatch = classifier.ClassifyBatch(imgs);
313      printPredictionsBatch(imgNames, predictionsBatch);
314      return 0;
315  }
316  #else
317  int main(int argc, char** argv) {
318      LOG(FATAL) << "This example requires OpenCV; compile with USE_OPENCV.";
319  }
320  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-compute_image_mean.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-batch_classification.cpp</div>
                <div class="column column_space"><pre><code>98    for (int c = 0; c < channels; ++c) {
99      for (int i = 0; i < dim; ++i) {
100        mean_values[c] += sum_blob.data(dim * c + i);
101      }
102      LOG(INFO) << "mean_value channel [" << c << "]:" << mean_values[c] / dim;
103    }
</pre></code></div>
                <div class="column column_space"><pre><code>200      for( int j = 0; j < num; ++j) {
201          vector<cv::Mat> input_channels;
202          for (int i = 0; i < input_layer->channels(); ++i) {
203              cv::Mat channel(height, width, CV_32FC1, input_data);
204              input_channels.push_back(channel);
205              input_data += width * height;
206          }
207          input_channels_batch->push_back(input_channels);
208      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    