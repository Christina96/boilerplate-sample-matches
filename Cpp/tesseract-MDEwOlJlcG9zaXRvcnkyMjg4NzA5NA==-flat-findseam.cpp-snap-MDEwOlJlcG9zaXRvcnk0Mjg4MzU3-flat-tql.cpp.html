
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.781641168289291%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-findseam.cpp</h3>
            <pre><code>1  #include "findseam.h"
2  #include "outlines.h"
3  #include "plotedges.h"
4  #include "seam.h"
5  #include "wordrec.h"
6  #ifdef HAVE_CONFIG_H
7  #  include "config_auto.h"
8  #endif
9  #define partial_split_priority(split) (grade_split_length(split) + grade_sharpness(split))
10  #define SPLIT_CLOSENESS 20 &bsol;* Difference in x value */
11  #define MAX_NUM_SEAMS 150
12  #define NO_FULL_PRIORITY (-1) 
13  #define BAD_PRIORITY 9999.0
14  namespace tesseract {
15  void Wordrec::add_seam_to_queue(float new_priority, SEAM *new_seam, SeamQueue *seams) {
16    if (new_seam == nullptr) {
17      return;
18    }
19    if (chop_debug) {
20      tprintf("Pushing new seam with priority %g :", new_priority);
21      new_seam->Print("seam: ");
22    }
23    if (seams->size() >= MAX_NUM_SEAMS) {
24      SeamPair old_pair(0, nullptr);
25      if (seams->PopWorst(&old_pair) && old_pair.key() <= new_priority) {
26        if (chop_debug) {
27          tprintf("Old seam staying with priority %g\n", old_pair.key());
28        }
29        delete new_seam;
30        seams->Push(&old_pair);
31        return;
32      } else if (chop_debug) {
33        tprintf("New seam with priority %g beats old worst seam with %g\n", new_priority,
34                old_pair.key());
35      }
36    }
37    SeamPair new_pair(new_priority, new_seam);
38    seams->Push(&new_pair);
39  }
40  void Wordrec::choose_best_seam(SeamQueue *seam_queue, const SPLIT *split, PRIORITY priority,
41                                 SEAM **seam_result, TBLOB *blob, SeamPile *seam_pile) {
42    SEAM *seam;
43    float my_priority;
44    my_priority = priority;
45    if (split != nullptr) {
46      TPOINT split_point = split->point1->pos;
47      split_point += split->point2->pos;
48      split_point /= 2;
49      seam = new SEAM(my_priority, split_point, *split);
50      if (chop_debug > 1) {
51        seam->Print("Partial priority    ");
52      }
53      add_seam_to_queue(my_priority, seam, seam_queue);
54      if (my_priority > chop_good_split) {
55        return;
56      }
57    }
58    TBOX bbox = blob->bounding_box();
59    while (!seam_queue->empty()) {
60      SeamPair seam_pair;
61      seam_queue->Pop(&seam_pair);
62      seam = seam_pair.extract_data();
63      my_priority =
64          seam->FullPriority(bbox.left(), bbox.right(), chop_overlap_knob, chop_centered_maxwidth,
65                             chop_center_knob, chop_width_change_knob);
66      if (chop_debug) {
67        char str[80];
68        snprintf(str, sizeof(str), "Full my_priority %0.0f,  ", my_priority);
69        seam->Print(str);
70      }
71      if ((*seam_result == nullptr || (*seam_result)->priority() > my_priority) &&
72          my_priority < chop_ok_split) {
73        if (seam->IsHealthy(*blob, chop_min_outline_points, chop_min_outline_area)) {
74          delete *seam_result;
75          *seam_result = new SEAM(*seam);
76          (*seam_result)->set_priority(my_priority);
77        } else {
78          delete seam;
79          seam = nullptr;
80          my_priority = BAD_PRIORITY;
81        }
82      }
83      if (my_priority < chop_good_split) {
84        delete seam;
85        return; &bsol;* Made good answer */
86      }
87      if (seam) {
88        if (seam_pile->size() < chop_seam_pile_size) {
89          combine_seam(*seam_pile, seam, seam_queue);
90          SeamDecPair pair(seam_pair.key(), seam);
91          seam_pile->Push(&pair);
92        } else if (chop_new_seam_pile && seam_pile->size() == chop_seam_pile_size &&
93                   seam_pile->PeekTop().key() > seam_pair.key()) {
94          combine_seam(*seam_pile, seam, seam_queue);
95          SeamDecPair pair;
96          seam_pile->Pop(&pair); 
97          pair.set_key(seam_pair.key());
98          pair.set_data(seam);
99          seam_pile->Push(&pair);
100        } else {
101          delete seam;
102        }
103      }
104      my_priority = seam_queue->empty() ? NO_FULL_PRIORITY : seam_queue->PeekTop().key();
105      if ((my_priority > chop_ok_split) || (my_priority > chop_good_split && split)) {
106        return;
107      }
<span onclick='openModal()' class='match'>108    }
109  }
110  void Wordrec::combine_seam(const SeamPile &seam_pile, const SEAM *seam, SeamQueue *seam_queue) {
111    for (int x = 0; x < seam_pile.size(); ++x) {
</span>112      const SEAM *this_one = seam_pile.get(x).data();
113      if (seam->CombineableWith(*this_one, SPLIT_CLOSENESS, chop_ok_split)) {
114        SEAM *new_one = new SEAM(*seam);
115        new_one->CombineWith(*this_one);
116        if (chop_debug > 1) {
117          new_one->Print("Combo priority       ");
118        }
119        add_seam_to_queue(new_one->priority(), new_one, seam_queue);
120      }
121    }
122  }
123  SEAM *Wordrec::pick_good_seam(TBLOB *blob) {
124    SeamPile seam_pile(chop_seam_pile_size);
125    EDGEPT *points[MAX_NUM_POINTS];
126    EDGEPT_CLIST new_points;
127    SEAM *seam = nullptr;
128    TESSLINE *outline;
129    int16_t num_points = 0;
130  #ifndef GRAPHICS_DISABLED
131    if (chop_debug > 2) {
132      wordrec_display_splits.set_value(true);
133    }
134    draw_blob_edges(blob);
135  #endif
136    PointHeap point_heap(MAX_NUM_POINTS);
137    for (outline = blob->outlines; outline; outline = outline->next) {
138      prioritize_points(outline, &point_heap);
139    }
140    while (!point_heap.empty() && num_points < MAX_NUM_POINTS) {
141      points[num_points++] = point_heap.PeekTop().data();
142      point_heap.Pop(nullptr);
143    }
144    SeamQueue seam_queue(MAX_NUM_SEAMS);
145    try_point_pairs(points, num_points, &seam_queue, &seam_pile, &seam, blob);
146    try_vertical_splits(points, num_points, &new_points, &seam_queue, &seam_pile, &seam, blob);
147    if (seam == nullptr) {
148      choose_best_seam(&seam_queue, nullptr, BAD_PRIORITY, &seam, blob, &seam_pile);
149    } else if (seam->priority() > chop_good_split) {
150      choose_best_seam(&seam_queue, nullptr, seam->priority(), &seam, blob, &seam_pile);
151    }
152    EDGEPT_C_IT it(&new_points);
153    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
154      EDGEPT *inserted_point = it.data();
155      if (seam == nullptr || !seam->UsesPoint(inserted_point)) {
156        for (outline = blob->outlines; outline; outline = outline->next) {
157          if (outline->loop == inserted_point) {
158            outline->loop = outline->loop->next;
159          }
160        }
161        remove_edgept(inserted_point);
162      }
163    }
164    if (seam) {
165      if (seam->priority() > chop_ok_split) {
166        delete seam;
167        seam = nullptr;
168      }
169  #ifndef GRAPHICS_DISABLED
170      else if (wordrec_display_splits) {
171        seam->Mark(edge_window);
172        if (chop_debug > 2) {
173          edge_window->Update();
174          edge_window->Wait();
175        }
176      }
177  #endif
178    }
179    if (chop_debug) {
180      wordrec_display_splits.set_value(false);
181    }
182    return (seam);
183  }
184  void Wordrec::try_point_pairs(EDGEPT *points[MAX_NUM_POINTS], int16_t num_points,
185                                SeamQueue *seam_queue, SeamPile *seam_pile, SEAM **seam,
186                                TBLOB *blob) {
187    int16_t x;
188    int16_t y;
189    PRIORITY priority;
190    for (x = 0; x < num_points; x++) {
191      for (y = x + 1; y < num_points; y++) {
192        if (points[y] &&
193            points[x]->WeightedDistance(*points[y], chop_x_y_weight) < chop_split_length &&
194            points[x] != points[y]->next && points[y] != points[x]->next &&
195            !is_exterior_point(points[x], points[y]) && !is_exterior_point(points[y], points[x])) {
196          SPLIT split(points[x], points[y]);
197          priority = partial_split_priority(&split);
198          choose_best_seam(seam_queue, &split, priority, seam, blob, seam_pile);
199        }
200      }
201    }
202  }
203  void Wordrec::try_vertical_splits(EDGEPT *points[MAX_NUM_POINTS], int16_t num_points,
204                                    EDGEPT_CLIST *new_points, SeamQueue *seam_queue,
205                                    SeamPile *seam_pile, SEAM **seam, TBLOB *blob) {
206    EDGEPT *vertical_point = nullptr;
207    int16_t x;
208    PRIORITY priority;
209    TESSLINE *outline;
210    for (x = 0; x < num_points; x++) {
211      vertical_point = nullptr;
212      for (outline = blob->outlines; outline; outline = outline->next) {
213        vertical_projection_point(points[x], outline->loop, &vertical_point, new_points);
214      }
215      if (vertical_point && points[x] != vertical_point->next && vertical_point != points[x]->next &&
216          points[x]->WeightedDistance(*vertical_point, chop_x_y_weight) < chop_split_length) {
217        SPLIT split(points[x], vertical_point);
218        priority = partial_split_priority(&split);
219        choose_best_seam(seam_queue, &split, priority, seam, blob, seam_pile);
220      }
221    }
222  }
223  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tql.cpp</h3>
            <pre><code>1  #include "StdAfx.h"
2  #include "tql.h"
3  class ETql{
4  private:
5    TStr ErrMsg;
6  public:
7    ETql(const TStr& _ErrMsg):
8      ErrMsg(_ErrMsg){}
9    ETql& operator=(const ETql& E){
10      ErrMsg=E.ErrMsg; return *this;}
<span onclick='openModal()' class='match'>11    TStr GetErrMsg() const {return ErrMsg;}
12  };
13  void TTqlChDef::SetChTy(const TTqlLxChTy& ChTy, const TStr& Str){
14    for (int ChN=0; ChN<Str.Len(); ChN++){ChTyV[Str[ChN]-TCh::Mn]=TInt(ChTy);}
</span>15  }
16  TTqlChDef::TTqlChDef():
17    ChTyV(TCh::Vals){
18    ChTyV.PutAll(TInt(tlcAlpha));
19    for (char Ch=TCh::NullCh; Ch<=' '; Ch++){SetChTy(tlcSpace, TStr(Ch));}
20    SetChTy(tlcNum, "0123456789");
21    SetChTy(tlcSym, "&|!()[]\"+-#*:<=>");
22    SetChTy(tlcEof, TCh::EofCh);
23  }
24  TTqlRwMap::TTqlRwMap():
25    StrToRwH(20){
26    StrToRwH.AddDat("domain", trwDomain);
27    StrToRwH.AddDat("depth", trwDepth);
28    StrToRwH.AddDat("feature", trwFeature);
29    StrToRwH.AddDat("outgoingurl", trwOutgoingUrl);
30    StrToRwH.AddDat("title", trwTitle);
31    StrToRwH.AddDat("after", trwAfter);
32    StrToRwH.AddDat("before", trwBefore);
33    StrToRwH.AddDat("within", trwWithin);
34  }
35  bool TTqlRwMap::IsRw(const TStr& RwStr, TTqlRw& Rw) const {
36    int KeyId=StrToRwH.GetKeyId(RwStr);
37    if (KeyId==-1){return false;}
38    else {Rw=TTqlRw(int(StrToRwH[KeyId])); return true;}
39  }
40  TTqlChDef TTqlLx::ChDef;
41  TTqlLx::TTqlLx(const TStr& ExpStr):
42    SIn(TStrIn::New(ExpStr)), Ch(' '),  Sym(tsyUndef), Str(){
43  }
44  TTqlLxSym TTqlLx::GetSym(const TFSet& Expect){
45    Str.Clr();
46    while (ChDef.IsSpace(Ch)){GetCh();}
47    if (Expect.In(tsyNum)){
48      if (!ChDef.IsNum(Ch)){throw ETql("Number expected.");}
49      Sym=tsyNum;
50      do {Str.AddCh(Ch); GetCh();} while (ChDef.IsNum(Ch));
51    } else {
52      switch (ChDef.GetChTy(Ch)){
53        case tlcAlpha:
54        case tlcNum:
55          do {Str.AddCh(Ch); GetCh();} while (ChDef.IsAlNum(Ch));
56          if (Str=="OR"){Sym=tsyOr;}
57          else if (Str=="AND"){Sym=tsyAnd;}
58          else if (Str=="NOT"){Sym=tsyNot;}
59          else {Sym=tsyWord;}
60          break;
61        case tlcSym:
62          Str.AddCh(Ch);
63          switch (Ch){
64            case '\"': Sym=tsyDQuote; GetCh(); break;
65            case ':': Sym=tsyColon; GetCh(); break;
66            case '(': Sym=tsyLParen; GetCh(); break;
67            case ')': Sym=tsyRParen; GetCh(); break;
68            case '[': Sym=tsyLBracket; GetCh(); break;
69            case ']': Sym=tsyRBracket; GetCh(); break;
70            case '|': Sym=tsyOr; GetCh(); break;
71            case '&': Sym=tsyAnd; GetCh(); break;
72            case '!': Sym=tsyNot; GetCh(); break;
73            case '+': Sym=tsyIncl; GetCh(); break;
74            case '-': Sym=tsyExcl; GetCh(); break;
75            case '#': Sym=tsyTitle; GetCh(); break;
76            case '*': Sym=tsyWCard; GetCh(); break;
77            case '<':
78              GetCh();
79              if (Ch=='='){Sym=tsyLEq; GetCh();}
80              else if (Ch=='>'){Sym=tsyNEq; GetCh();}
81              else {Sym=tsyLss;}
82              break;
83            case '=': Sym=tsyEq; GetCh(); break;
84            case '>':
85              GetCh();
86              if (Ch=='='){Sym=tsyGEq; GetCh();}
87              else {Sym=tsyGtr;}
88              break;
89            default: Sym=tsySSym; GetCh();
90          }
91          break;
92        case tlcEof: Sym=tsyEof; break;
93        default: Sym=tsyUndef; GetCh();
94      }
95    }
96    if ((!Expect.In(Sym))&&(!Expect.Empty())){
97      if (Sym==tsyEof){
98        throw ETql("Unexpected end of expression.");
99      } else {
100        throw ETql("Unexpected symbol.");
101      }
102    }
103    return Sym;
104  }
105  TTqlItem::TTqlItem(const TTqlItemType& _Type,
106   const PTqlItem& Item1, const PTqlItem& Item2):
107    Type(_Type), ItemV(), WordStrV(){
108    IAssert(
109     (Type==titOr)||(Type==titAnd)||(Type==titNot)||
110     (Type==titIncl)||(Type==titExcl)||
111     (Type==titInTag)||(Type==titTitle)||(Type==titWCard));
112    if (Type==titWCard){
113      IAssert(Item1->GetType()==titWord);
114      IAssert(Item2.Empty());
115    }
116    ItemV.Add(Item1);
117    if (!Item2.Empty()){ItemV.Add(Item2);}
118  }
119  TTqlItem::TTqlItem(const TStr& TagNm, const PTqlItem& Item):
120    Type(titInTag), ItemV(), WordStrV(){
121    WordStrV.Add(TagNm);
122    ItemV.Add(Item);
123  }
124  TTqlItem::TTqlItem(const TStr& TagNm, const TStr& RelOpStr, const TStr& ArgStr):
125    Type(titTagRel), ItemV(), WordStrV(){
126    WordStrV.Add(TagNm);
127    WordStrV.Add(RelOpStr);
128    WordStrV.Add(ArgStr);
129  }
130  TTqlItem::TTqlItem(const TStr& WordStr):
131    Type(titWord), ItemV(), WordStrV(){
132    WordStrV.Add(WordStr);
133  }
134  TTqlItem::TTqlItem(const TStrV& _WordStrV):
135    Type(titPhrase), ItemV(), WordStrV(_WordStrV){}
136  TTqlItem::TTqlItem(const TStr& MetaTag, const TStrV& ArgStrV):
137    Type(titMeta), ItemV(), WordStrV(){
138    WordStrV.Add(MetaTag);
139    WordStrV.AddV(ArgStrV);
140  }
141  PTqlItem TTqlItem::GetItem(const int& ItemN) const {
142    IAssert(
143     (Type==titOr)||(Type==titAnd)||(Type==titNot)||
144     (Type==titIncl)||(Type==titExcl)||
145     (Type==titInTag)||(Type==titTitle)||(Type==titWCard));
146    return ItemV[ItemN];
147  }
148  TStr TTqlItem::GetTagNm() const {
149    IAssert((Type==titInTag)||(Type==titTagRel));
150    return WordStrV[0];
151  }
152  TRelOp TTqlItem::GetRelOp() const {
153    IAssert(Type==titTagRel);
154    TStr RelOpStr=WordStrV[1];
155    if (RelOpStr=="<"){return roLs;}
156    else if (RelOpStr=="<="){return roLEq;}
157    else if (RelOpStr=="="){return roEq;}
158    else if (RelOpStr=="<>"){return roEq;}
159    else if (RelOpStr==">="){return roGEq;}
160    else if (RelOpStr==">"){return roGt;}
161    else {return roUndef;}
162  }
163  TStr TTqlItem::GetRelArgStr() const {
164    IAssert(Type==titTagRel);
165    return WordStrV[2];
166  }
167  TStr TTqlItem::GetWordStr() const {
168    IAssert(Type==titWord);
169    return WordStrV[0];
170  }
171  int TTqlItem::GetPhraseLen() const {
172    IAssert(Type==titPhrase);
173    return WordStrV.Len();
174  }
175  TStr TTqlItem::GetPhraseWordStr(const int& WordStrN) const {
176    IAssert(Type==titPhrase);
177    return WordStrV[WordStrN];
178  }
179  PTqlCtxSet TTqlItem::Eval(const TTqlIx& TqlIx) const {
180    PTqlCtxSet CtxSet;
181    switch (Type){
182      case titOr:{
183        CtxSet=GetItem(0)->Eval(TqlIx);
184        PTqlCtxSet RDocIdSet=GetItem(1)->Eval(TqlIx);
185        CtxSet=CtxSet->GetOrCtxSet(RDocIdSet);
186        break;}
187      case titAnd:{
188        CtxSet=GetItem(0)->Eval(TqlIx);
189        PTqlCtxSet RDocIdSet=GetItem(1)->Eval(TqlIx);
190        CtxSet=CtxSet->GetAndCtxSet(RDocIdSet);
191        break;}
192      case titNot:{
193        CtxSet=GetItem()->Eval(TqlIx);
194        break;} /&bsol;**
195      case titIncl: CtxSet=GetItem()->Eval(TqlIx); break; /&bsol;**
196      case titExcl: CtxSet=GetItem()->Eval(TqlIx); break; /&bsol;**
197      case titInTag:
198        CtxSet=GetItem()->Eval(TqlIx);
199        CtxSet=CtxSet->GetTagCtxSet(GetTagNm());
200        break;
201      case titTagRel:
202        CtxSet=TqlIx.GetCtxSet(GetTagNm(), GetRelOp(), GetRelArgStr(), 1000);
203        break;
204      case titTitle:
205        CtxSet=GetItem()->Eval(TqlIx);
206        CtxSet=CtxSet->GetTitleCtxSet();
207        break;
208      case titWCard:{
209        PTqlItem SubItem=GetItem();
210        CtxSet=TqlIx.GetCtxSet(SubItem->GetWordStr(), true, 100);
211        break;}
212      case titWord:{
213        CtxSet=TqlIx.GetCtxSet(GetWordStr(), false, -1);
214        break;}
215      case titPhrase:{
216        /&bsol;** performs "and" between phrase words only
217        if (GetPhraseLen()>0){
218          CtxSet=TqlIx.GetCtxSet(GetPhraseWordStr(0), false, -1);
219          for (int WordN=1; WordN<GetPhraseLen(); WordN++){
220            PTqlCtxSet RDocIdSet=
221             TqlIx.GetCtxSet(GetPhraseWordStr(WordN), false, -1);
222            CtxSet=CtxSet->GetAndCtxSet(RDocIdSet);
223          }
224        } else {
225          CtxSet=TqlIx.GetEmptyCtxSet();
226        }
227        break;}
228      case titMeta: CtxSet=GetItem()->Eval(TqlIx); break; /&bsol;**
229      default: Fail;
230    }
231    return CtxSet;
232  }
233  PTqlItem TTqlExp::ParseFact(TTqlLx& Lx, const TFSet& Expect){
234    if (Lx.Sym==tsyNot){
235      Lx.GetSym(FactExpect);
236      PTqlItem Item=ParseFact(Lx, Expect);
237      return PTqlItem(new TTqlItem(titNot, Item));
238    } else
239    if (Lx.Sym==tsyIncl){
240      Lx.GetSym(FactExpect);
241      PTqlItem Item=ParseFact(Lx, Expect);
242      return PTqlItem(new TTqlItem(titIncl, Item));
243    } else
244    if (Lx.Sym==tsyExcl){
245      Lx.GetSym(FactExpect);
246      PTqlItem Item=ParseFact(Lx, Expect);
247      return PTqlItem(new TTqlItem(titExcl, Item));
248    } else
249    if (Lx.Sym==tsyTitle){
250      Lx.GetSym(FactExpect);
251      PTqlItem Item=ParseFact(Lx, Expect);
252      return PTqlItem(new TTqlItem(titTitle, Item));
253    } else
254    if (Lx.Sym==tsyLParen){
255      Lx.GetSym(ExpExpect);
256      PTqlItem Item=ParseExp(Lx, TFSet()|tsyRParen);
257      Lx.GetSym(Expect);
258      return Item;
259    } else
260    if (Lx.Sym==tsyLBracket){
261      Lx.GetSym(tsyWord); TStr TagNm=Lx.Str;
262      Lx.GetSym(tsyRBracket);
263      Lx.GetSym(TFSet(FactExpect)|RelOpSet);
264      if (RelOpSet.In(Lx.Sym)){
265        TStr RelOpStr=Lx.Str;
266        Lx.GetSym(tsyWord, tsyExcl);
267        TStr ArgStr;
268        if (Lx.Sym==tsyExcl){
269          Lx.GetSym(tsyWord); ArgStr=TStr("-")+Lx.Str;
270        } else {
271          ArgStr=Lx.Str;
272        }
273        Lx.GetSym(Expect);
274        return PTqlItem(new TTqlItem(TagNm, RelOpStr, ArgStr));
275      } else {
276        PTqlItem Item=ParseFact(Lx, Expect);
277        return PTqlItem(new TTqlItem(TagNm, Item));
278      }
279    } else
280    if (Lx.Sym==tsyDQuote){
281      TStrV WordStrV;
282      do {
283        Lx.GetSym();
284        if (Lx.Sym==tsyWord){
285          WordStrV.Add(Lx.Str);}
286      } while (Lx.Sym!=tsyDQuote);
287      Lx.GetSym(Expect);
288      return PTqlItem(new TTqlItem(WordStrV));
289    } else
290    if (Lx.Sym==tsyWord){
291      PTqlItem Item=PTqlItem(new TTqlItem(Lx.Str));
292      Lx.GetSym(TFSet(Expect)|tsyWCard);
293      if (Lx.Sym==tsyWCard){
294        PTqlItem WCardItem=
295         PTqlItem(new TTqlItem(titWCard, Item));
296        Item=WCardItem;
297        Lx.GetSym(Expect);
298      }
299      return Item;
300    } else {
301      Fail; return NULL;
302    }
303  }
304  PTqlItem TTqlExp::ParseTerm(TTqlLx& Lx, const TFSet& Expect){
305    TFSet LoopExpect=TFSet(Expect)|FactExpect|tsyAnd;
306    PTqlItem Item=ParseFact(Lx, LoopExpect);
307    while ((Lx.Sym==tsyAnd)||(FactExpect.In(Lx.Sym))){
308      if (Lx.Sym==tsyAnd){
309        Lx.GetSym(FactExpect);}
310      PTqlItem RItem=ParseFact(Lx, LoopExpect);
311      Item=PTqlItem(new TTqlItem(titAnd, Item, RItem));
312    }
313    return Item;
314  }
315  PTqlItem TTqlExp::ParseExp(TTqlLx& Lx, const TFSet& Expect){
316    PTqlItem Item=ParseTerm(Lx, TFSet(Expect)|tsyOr);
317    while (Lx.Sym==tsyOr){
318      Lx.GetSym(TermExpect);
319      PTqlItem RItem=ParseTerm(Lx, TFSet(Expect)|tsyOr);
320      Item=PTqlItem(new TTqlItem(titOr, Item, RItem));
321    }
322    return Item;
323  }
324  TTqlExp::TTqlExp(const TStr& _ExpStr):
325    ExpStr(_ExpStr), Ok(true), ErrMsg(), Item(),
326    RelOpSet(), FactExpect(), TermExpect(), ExpExpect(){
327    RelOpSet=TFSet(tsyLss, tsyLEq, tsyEq, tsyNEq, tsyGEq, tsyGtr);
328    FactExpect=TFSet(tsyNot, tsyIncl, tsyExcl, tsyTitle, tsyLParen, tsyLBracket,
329     tsyDQuote, tsyWord);
330    TermExpect=FactExpect;
331    ExpExpect=TermExpect;
332    TTqlLx Lx(ExpStr);
333    try {
334      Lx.GetSym(ExpExpect);
335      Item=ParseExp(Lx, TFSet()|tsyEof);
336    }
337    catch (ETql E){
338      Ok=false; ErrMsg=E.GetErrMsg();
339    }
340  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-findseam.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tql.cpp</div>
                <div class="column column_space"><pre><code>108    }
109  }
110  void Wordrec::combine_seam(const SeamPile &seam_pile, const SEAM *seam, SeamQueue *seam_queue) {
111    for (int x = 0; x < seam_pile.size(); ++x) {
</pre></code></div>
                <div class="column column_space"><pre><code>11    TStr GetErrMsg() const {return ErrMsg;}
12  };
13  void TTqlChDef::SetChTy(const TTqlLxChTy& ChTy, const TStr& Str){
14    for (int ChN=0; ChN<Str.Len(); ChN++){ChTyV[Str[ChN]-TCh::Mn]=TInt(ChTy);}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    