
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexAPDL.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static inline bool IsAWordChar(const int ch) {
20  	return (ch < 0x80 && (isalnum(ch) || ch == '_'));
21  }
22  static inline bool IsAnOperator(char ch) {
23  	if (ch == '*' || ch == '/' || ch == '-' || ch == '+' ||
24  		ch == '(' || ch == ')' || ch == '=' || ch == '^' ||
25  		ch == '[' || ch == ']' || ch == '<' || ch == '&' ||
26  		ch == '>' || ch == ',' || ch == '|' || ch == '~' ||
<span onclick='openModal()' class='match'>27  		ch == '$' || ch == ':' || ch == '%')
28  		return true;
29  	return false;
30  }
31  static void ColouriseAPDLDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
</span>32                              Accessor &styler) {
33  	int stringStart = ' ';
34  	WordList &processors = *keywordlists[0];
35  	WordList &commands = *keywordlists[1];
36  	WordList &slashcommands = *keywordlists[2];
37  	WordList &starcommands = *keywordlists[3];
38  	WordList &arguments = *keywordlists[4];
39  	WordList &functions = *keywordlists[5];
40  	initStyle = SCE_APDL_DEFAULT;
41  	StyleContext sc(startPos, length, initStyle, styler);
42  	for (; sc.More(); sc.Forward()) {
43  		if (sc.state == SCE_APDL_NUMBER) {
44  			if (!(IsADigit(sc.ch) || sc.ch == '.' || (sc.ch == 'e' || sc.ch == 'E') ||
45  				((sc.ch == '+' || sc.ch == '-') && (sc.chPrev == 'e' || sc.chPrev == 'E')))) {
46  				sc.SetState(SCE_APDL_DEFAULT);
47  			}
48  		} else if (sc.state == SCE_APDL_COMMENT) {
49  			if (sc.atLineEnd) {
50  				sc.SetState(SCE_APDL_DEFAULT);
51  			}
52  		} else if (sc.state == SCE_APDL_COMMENTBLOCK) {
53  			if (sc.atLineEnd) {
54  				if (sc.ch == '\r') {
55  				sc.Forward();
56  				}
57  				sc.ForwardSetState(SCE_APDL_DEFAULT);
58  			}
59  		} else if (sc.state == SCE_APDL_STRING) {
60  			if (sc.atLineEnd) {
61  				sc.SetState(SCE_APDL_DEFAULT);
62  			} else if ((sc.ch == '\'' && stringStart == '\'') || (sc.ch == '\"' && stringStart == '\"')) {
63  				sc.ForwardSetState(SCE_APDL_DEFAULT);
64  			}
65  		} else if (sc.state == SCE_APDL_WORD) {
66  			if (!IsAWordChar(sc.ch)) {
67  				char s[100];
68  				sc.GetCurrentLowered(s, sizeof(s));
69  				if (processors.InList(s)) {
70  					sc.ChangeState(SCE_APDL_PROCESSOR);
71  				} else if (slashcommands.InList(s)) {
72  					sc.ChangeState(SCE_APDL_SLASHCOMMAND);
73  				} else if (starcommands.InList(s)) {
74  					sc.ChangeState(SCE_APDL_STARCOMMAND);
75  				} else if (commands.InList(s)) {
76  					sc.ChangeState(SCE_APDL_COMMAND);
77  				} else if (arguments.InList(s)) {
78  					sc.ChangeState(SCE_APDL_ARGUMENT);
79  				} else if (functions.InList(s)) {
80  					sc.ChangeState(SCE_APDL_FUNCTION);
81  				}
82  				sc.SetState(SCE_APDL_DEFAULT);
83  			}
84  		} else if (sc.state == SCE_APDL_OPERATOR) {
85  			if (!IsAnOperator(static_cast<char>(sc.ch))) {
86  			    sc.SetState(SCE_APDL_DEFAULT);
87  			}
88  		}
89  		if (sc.state == SCE_APDL_DEFAULT) {
90  			if (sc.ch == '!' && sc.chNext == '!') {
91  				sc.SetState(SCE_APDL_COMMENTBLOCK);
92  			} else if (sc.ch == '!') {
93  				sc.SetState(SCE_APDL_COMMENT);
94  			} else if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
95  				sc.SetState(SCE_APDL_NUMBER);
96  			} else if (sc.ch == '\'' || sc.ch == '\"') {
97  				sc.SetState(SCE_APDL_STRING);
98  				stringStart = sc.ch;
99  			} else if (IsAWordChar(sc.ch) || ((sc.ch == '*' || sc.ch == '/') && !isgraph(sc.chPrev))) {
100  				sc.SetState(SCE_APDL_WORD);
101  			} else if (IsAnOperator(static_cast<char>(sc.ch))) {
102  				sc.SetState(SCE_APDL_OPERATOR);
103  			}
104  		}
105  	}
106  	sc.Complete();
107  }
108  static int character_classification[128] =
109  {
110      0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,
111      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
112      1,  2,  0,  2,  2,  2,  2,  2,  2,  2,  6,  2,  2,  2,  10, 6,
113      60, 60, 28, 28, 28, 28, 28, 28, 28, 28, 2,  2,  2,  2,  2,  2,
114      2,  20, 20, 20, 20, 20, 20, 4,  4,  4,  4,  4,  4,  4,  4,  4,
115      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  2,  2,  4,
116      2,  20, 20, 20, 20, 20, 20, 4,  4,  4,  4,  4,  4,  4,  4,  4,
117      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  2,  2,  0
118  };
119  static bool IsSpace(int c) {
120  	return c < 128 && (character_classification[c] & 1);
121  }
122  static bool IsIdentifier(int c) {
123  	return c < 128 && (character_classification[c] & 4);
124  }
125  static int LowerCase(int c)
126  {
127  	if (c >= 'A' && c <= 'Z')
128  		return 'a' + c - 'A';
129  	return c;
130  }
131  static int CheckAPDLFoldPoint(char const *token, int &level) {
132  	if (!strcmp(token, "*if") ||
133  		!strcmp(token, "*do") ||
134  		!strcmp(token, "*dowhile") ) {
135  		level |= SC_FOLDLEVELHEADERFLAG;
136  		return 1;
137  	}
138  	if (!strcmp(token, "*endif") ||
139  		!strcmp(token, "*enddo") ) {
140  		return -1;
141  	}
142  	return 0;
143  }
144  static void FoldAPDLDoc(Sci_PositionU startPos, Sci_Position length, int,
145  	WordList *[], Accessor &styler) {
146  	Sci_Position line = styler.GetLine(startPos);
147  	int level = styler.LevelAt(line);
148  	int go = 0, done = 0;
149  	Sci_Position endPos = startPos + length;
150  	char word[256];
151  	int wordlen = 0;
152  	Sci_Position i;
153      bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
154  	for (i = startPos; i < endPos; i++) {
155  		int c = styler.SafeGetCharAt(i);
156  		if (!done && !go) {
157  			if (wordlen) { 
158  				word[wordlen] = static_cast<char>(LowerCase(c));
159  				if (!IsIdentifier(c)) { 
160  					word[wordlen] = '\0';
161  					go = CheckAPDLFoldPoint(word, level);
162  					if (!go) {
163  						if (IsSpace(c) && IsIdentifier(word[wordlen - 1])) {
164  							word[wordlen] = ' ';
165  							if (wordlen < 255)
166  								wordlen++;
167  						}
168  						else 
169  							done = 1;
170  					}
171  				} else if (wordlen < 255) {
172  					wordlen++;
173  				}
174  			} else { 
175  				if (!IsSpace(c)) {
176  					if (IsIdentifier(c)) {
177  						word[0] = static_cast<char>(LowerCase(c));
178  						wordlen = 1;
179  					} else 
180  						done = 1;
181  				}
182  			}
183  		}
184  		if (c == '\n') { 
185  			if (!done && wordlen == 0 && foldCompact) 
186  				level |= SC_FOLDLEVELWHITEFLAG;
187  			if (level != styler.LevelAt(line))
188  				styler.SetLevel(line, level);
189  			level += go;
190  			line++;
191  			wordlen = 0;
192  			level &= ~SC_FOLDLEVELHEADERFLAG;
193  			level &= ~SC_FOLDLEVELWHITEFLAG;
194  			go = 0;
195  			done = 0;
196  		}
197  	}
198  }
199  static const char * const apdlWordListDesc[] = {
200      "processors",
201      "commands",
202      "slashommands",
203      "starcommands",
204      "arguments",
205      "functions",
206      0
207  };
208  LexerModule lmAPDL(SCLEX_APDL, ColouriseAPDLDoc, "apdl", FoldAPDLDoc, apdlWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexGAP.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static inline bool IsGAPOperator(char ch) {
20  	if (IsASCII(ch) && isalnum(ch)) return false;
21  	if (ch == '+' || ch == '-' || ch == '*' || ch == '/' ||
22  		ch == '^' || ch == ',' || ch == '!' || ch == '.' ||
23  		ch == '=' || ch == '<' || ch == '>' || ch == '(' ||
24  		ch == ')' || ch == ';' || ch == '[' || ch == ']' ||
<span onclick='openModal()' class='match'>25  		ch == '{' || ch == '}' || ch == ':' )
26  		return true;
27  	return false;
28  }
29  static void GetRange(Sci_PositionU start, Sci_PositionU end, Accessor &styler, char *s, Sci_PositionU len) {
</span>30  	Sci_PositionU i = 0;
31  	while ((i < end - start + 1) && (i < len-1)) {
32  		s[i] = static_cast<char>(styler[start + i]);
33  		i++;
34  	}
35  	s[i] = '\0';
36  }
37  static void ColouriseGAPDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[], Accessor &styler) {
38  	WordList &keywords1 = *keywordlists[0];
39  	WordList &keywords2 = *keywordlists[1];
40  	WordList &keywords3 = *keywordlists[2];
41  	WordList &keywords4 = *keywordlists[3];
42  	if (initStyle == SCE_GAP_STRINGEOL) initStyle = SCE_GAP_DEFAULT;
43  	StyleContext sc(startPos, length, initStyle, styler);
44  	for (; sc.More(); sc.Forward()) {
45  		if ( sc.atLineStart ) {
46  			if (sc.state == SCE_GAP_STRING) sc.SetState(SCE_GAP_STRING);
47  			if (sc.state == SCE_GAP_CHAR) sc.SetState(SCE_GAP_CHAR);
48  		}
49  		if (sc.ch == '\\' ) {
50  			if (sc.chNext == '\n' || sc.chNext == '\r') {
51  				sc.Forward();
52  				if (sc.ch == '\r' && sc.chNext == '\n') {
53  					sc.Forward();
54  				}
55  				continue;
56  			}
57  		}
58  		switch (sc.state) {
59  			case SCE_GAP_OPERATOR :
60  				sc.SetState(SCE_GAP_DEFAULT);
61  				break;
62  			case SCE_GAP_NUMBER :
63  				if (!IsADigit(sc.ch)) {
64  					if (sc.ch == '\\') {
65  						if (!sc.atLineEnd) {
66  							if (!IsADigit(sc.chNext)) {
67  								sc.Forward();
68  								sc.ChangeState(SCE_GAP_IDENTIFIER);
69  							}
70  						}
71  					} else if (isalpha(sc.ch) || sc.ch == '_') {
72  						sc.ChangeState(SCE_GAP_IDENTIFIER);
73  					}
74  					else sc.SetState(SCE_GAP_DEFAULT);
75  				}
76  				break;
77  			case SCE_GAP_IDENTIFIER :
78  				if (!(iswordstart(static_cast<char>(sc.ch)) || sc.ch == '$')) {
79  					if (sc.ch == '\\') sc.Forward();
80  					else {
81  						char s[1000];
82  						sc.GetCurrent(s, sizeof(s));
83  						if (keywords1.InList(s)) {
84  							sc.ChangeState(SCE_GAP_KEYWORD);
85  						} else if (keywords2.InList(s)) {
86  							sc.ChangeState(SCE_GAP_KEYWORD2);
87  						} else if (keywords3.InList(s)) {
88  							sc.ChangeState(SCE_GAP_KEYWORD3);
89  						} else if (keywords4.InList(s)) {
90  							sc.ChangeState(SCE_GAP_KEYWORD4);
91  						}
92  						sc.SetState(SCE_GAP_DEFAULT);
93  					}
94  				}
95  				break;
96  			case SCE_GAP_COMMENT :
97  				if (sc.atLineEnd) {
98  					sc.SetState(SCE_GAP_DEFAULT);
99  				}
100  				break;
101  			case SCE_GAP_STRING:
102  				if (sc.atLineEnd) {
103  					sc.ChangeState(SCE_GAP_STRINGEOL);
104  				} else if (sc.ch == '\\') {
105  					if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\') {
106  						sc.Forward();
107  					}
108  				} else if (sc.ch == '\"') {
109  					sc.ForwardSetState(SCE_GAP_DEFAULT);
110  				}
111  				break;
112  			case SCE_GAP_CHAR:
113  				if (sc.atLineEnd) {
114  					sc.ChangeState(SCE_GAP_STRINGEOL);
115  				} else if (sc.ch == '\\') {
116  					if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\') {
117  						sc.Forward();
118  					}
119  				} else if (sc.ch == '\'') {
120  					sc.ForwardSetState(SCE_GAP_DEFAULT);
121  				}
122  				break;
123  			case SCE_GAP_STRINGEOL:
124  				if (sc.atLineStart) {
125  					sc.SetState(SCE_GAP_DEFAULT);
126  				}
127  				break;
128  		}
129  		if (sc.state == SCE_GAP_DEFAULT) {
130  			if (IsGAPOperator(static_cast<char>(sc.ch))) {
131  				sc.SetState(SCE_GAP_OPERATOR);
132  			}
133  			else if (IsADigit(sc.ch)) {
134  				sc.SetState(SCE_GAP_NUMBER);
135  			} else if (isalpha(sc.ch) || sc.ch == '_' || sc.ch == '\\' || sc.ch == '$' || sc.ch == '~') {
136  				sc.SetState(SCE_GAP_IDENTIFIER);
137  				if (sc.ch == '\\') sc.Forward();
138  			} else if (sc.ch == '#') {
139  				sc.SetState(SCE_GAP_COMMENT);
140  			} else if (sc.ch == '\"') {
141  				sc.SetState(SCE_GAP_STRING);
142  			} else if (sc.ch == '\'') {
143  				sc.SetState(SCE_GAP_CHAR);
144  			}
145  		}
146  	}
147  	sc.Complete();
148  }
149  static int ClassifyFoldPointGAP(const char* s) {
150  	int level = 0;
151  	if (strcmp(s, "function") == 0 ||
152  		strcmp(s, "do") == 0 ||
153  		strcmp(s, "if") == 0 ||
154  		strcmp(s, "repeat") == 0 ) {
155  		level = 1;
156  	} else if (strcmp(s, "end") == 0 ||
157  			strcmp(s, "od") == 0 ||
158  			strcmp(s, "fi") == 0 ||
159  			strcmp(s, "until") == 0 ) {
160  		level = -1;
161  	}
162  	return level;
163  }
164  static void FoldGAPDoc( Sci_PositionU startPos, Sci_Position length, int initStyle,   WordList** , Accessor &styler) {
165  	Sci_PositionU endPos = startPos + length;
166  	int visibleChars = 0;
167  	Sci_Position lineCurrent = styler.GetLine(startPos);
168  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
169  	int levelCurrent = levelPrev;
170  	char chNext = styler[startPos];
171  	int styleNext = styler.StyleAt(startPos);
172  	int style = initStyle;
173  	Sci_Position lastStart = 0;
174  	for (Sci_PositionU i = startPos; i < endPos; i++) {
175  		char ch = chNext;
176  		chNext = styler.SafeGetCharAt(i + 1);
177  		int stylePrev = style;
178  		style = styleNext;
179  		styleNext = styler.StyleAt(i + 1);
180  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
181  		if (stylePrev != SCE_GAP_KEYWORD && style == SCE_GAP_KEYWORD) {
182  			lastStart = i;
183  		}
184  		if (stylePrev == SCE_GAP_KEYWORD) {
185  			if(iswordchar(ch) && !iswordchar(chNext)) {
186  				char s[100];
187  				GetRange(lastStart, i, styler, s, sizeof(s));
188  				levelCurrent += ClassifyFoldPointGAP(s);
189  			}
190  		}
191  		if (atEOL) {
192  			int lev = levelPrev;
193  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
194  				lev |= SC_FOLDLEVELHEADERFLAG;
195  			if (lev != styler.LevelAt(lineCurrent)) {
196  				styler.SetLevel(lineCurrent, lev);
197  			}
198  			lineCurrent++;
199  			levelPrev = levelCurrent;
200  			visibleChars = 0;
201  		}
202  		if (!isspacechar(ch))
203  			visibleChars++;
204  	}
205  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
206  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
207  }
208  static const char * const GAPWordListDesc[] = {
209  	"Keywords 1",
210  	"Keywords 2",
211  	"Keywords 3 (unused)",
212  	"Keywords 4 (unused)",
213  	0
214  };
215  LexerModule lmGAP(
216     SCLEX_GAP,
217     ColouriseGAPDoc,
218     "gap",
219     FoldGAPDoc,
220     GAPWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexAPDL.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexGAP.cxx</div>
                </div>
                <div class="column column_space"><pre><code>27  		ch == '$' || ch == ':' || ch == '%')
28  		return true;
29  	return false;
30  }
31  static void ColouriseAPDLDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
</pre></code></div>
                <div class="column column_space"><pre><code>25  		ch == '{' || ch == '}' || ch == ':' )
26  		return true;
27  	return false;
28  }
29  static void GetRange(Sci_PositionU start, Sci_PositionU end, Accessor &styler, char *s, Sci_PositionU len) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    