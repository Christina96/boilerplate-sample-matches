
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.049723756906078%, Tokens: 10</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-final_vote_store_84.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/secure/store.hpp>
3  #include <lmdb/libraries/liblmdb/lmdb.h>
4  namespace nano
5  {
6  namespace lmdb
7  {
8  	class store;
9  	class final_vote_store : public nano::final_vote_store
10  	{
11  	private:
12  		nano::lmdb::store & store;
13  	public:
14  		explicit final_vote_store (nano::lmdb::store & store);
<span onclick='openModal()' class='match'>15  		bool put (nano::write_transaction const & transaction_a, nano::qualified_root const & root_a, nano::block_hash const & hash_a) override;
16  		std::vector<nano::block_hash> get (nano::transaction const & transaction_a, nano::root const & root_a) override;
17  		void del (nano::write_transaction const & transaction_a, nano::root const & root_a) override;
18  		size_t count (nano::transaction const & transaction_a) const override;
19  		void clear (nano::write_transaction const & transaction_a, nano::root const & root_a) override;
</span>20  		void clear (nano::write_transaction const & transaction_a) override;
21  		nano::store_iterator<nano::qualified_root, nano::block_hash> begin (nano::transaction const & transaction_a, nano::qualified_root const & root_a) const override;
22  		nano::store_iterator<nano::qualified_root, nano::block_hash> begin (nano::transaction const & transaction_a) const override;
23  		nano::store_iterator<nano::qualified_root, nano::block_hash> end () const override;
24  		void for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::qualified_root, nano::block_hash>, nano::store_iterator<nano::qualified_root, nano::block_hash>)> const & action_a) const override;
25  		MDB_dbi final_votes_handle{ 0 };
26  	};
27  }
28  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.h</h3>
            <pre><code>1  class TGrowthStat;
2  typedef TPt<TGrowthStat> PGrowthStat;
3  class TGStatVec;
4  typedef TPt<TGStatVec> PGStatVec;
5  class TTimeNet;
6  typedef TPt<TTimeNet> PTimeNet;
7  class TTimeNENet;
8  typedef TPt<TTimeNENet> PTimeNENet;
9  class TTimeNet : public TNodeNet<TSecTm> {
10  public:
11    typedef TNodeNet<TSecTm> TNet;
12    typedef TPt<TNodeNet<TSecTm> > PNet;
13  public:
14    class TTmBucket {
15    public:
16      TSecTm BegTm; 
17      TIntV NIdV;
18    public:
19      TTmBucket() { }
20      TTmBucket(const TSecTm& BucketTm) : BegTm(BucketTm) { }
21      TTmBucket(const TTmBucket& TmBucket) : BegTm(TmBucket.BegTm), NIdV(TmBucket.NIdV) { }
22      TTmBucket& operator = (const TTmBucket& TmBucket) { if (this!=&TmBucket) {
23        BegTm=TmBucket.BegTm; NIdV=TmBucket.NIdV; } return *this; }
24    };
25    typedef TVec<TTmBucket> TTmBucketV;
26  public:
27    TTimeNet() { }
28    TTimeNet(const int& Nodes, const int& Edges) : TNet(Nodes, Edges) { }
29    TTimeNet(const TTimeNet& TimeNet) : TNet(TimeNet) { }
30    TTimeNet(TSIn& SIn) : TNet(SIn) { }
31    void Save(TSOut& SOut) const { TNet::Save(SOut); }
32    static PTimeNet New() { return new TTimeNet(); }
33    static PTimeNet New(const int& Nodes, const int& Edges) { return new TTimeNet(Nodes, Edges); }
34    static PTimeNet Load(TSIn& SIn) { return new TTimeNet(SIn); }
35    TTimeNet& operator = (const TTimeNet& TimeNet);
36    PTimeNet GetSubGraph(const TIntV& NIdV) const;
37    PTimeNENet GetTimeNENet() const;
38    void GetNIdByTm(TIntV& NIdV) const;
39    void GetTmBuckets(const TTmUnit& GroupBy, TTmBucketV& TmBucketV) const;
<span onclick='openModal()' class='match'>40    void GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const;
41    PGStatVec TimeGrowth(const TTmUnit& TmUnit, const TFSet& TakeStat, const TSecTm& StartTm) const;
42    void PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& GroupBy, const TSecTm& StartTm,
43      const int& NDiamRuns=10, const bool& OnlyWcc=false, const bool& AlsoRewire=false) const;
</span>44    void PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& GroupBy,
45      const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam) const;
46    void PlotCCfOverTm(const TStr& FNmPref, TStr Desc, const TTmUnit& TmUnit, const int& NodesBucket=-1) const;
47    void PlotMedianDegOverTm(const TStr& FNmPref, const TTmUnit& TmUnit, const int& NodesPerBucket=-1) const;
48    static PTimeNet LoadBipartite(const TStr& InFNm);
49    static PTimeNet LoadArxiv(const TStr& PaperFNm, const TStr& CiteFNm);
50    static PTimeNet LoadPatents(const TStr& PatentFNm, const TStr& CiteFNm);
51    static PTimeNet LoadAmazon(const TStr& StlFNm);
52    friend class TPt<TTimeNet>;
53  };
54  namespace TSnap {
55  template <> struct IsDirected<TTimeNet> { enum { Val = 1 }; };
56  template <> struct IsNodeDat<TTimeNet> { enum { Val = 1 }; };
57  }
58  class TTimeNENet : public TNodeEdgeNet<TSecTm, TSecTm> {
59  public:
60    typedef TNodeEdgeNet<TSecTm, TSecTm> TNet;
61    typedef TPt<TNodeEdgeNet<TSecTm, TSecTm> > PNet;
62  public:
63    TTimeNENet() { }
64    TTimeNENet(const int& Nodes, const int& Edges) : TNet(Nodes, Edges) { }
65    TTimeNENet(TSIn& SIn) : TNet(SIn) { }
66    TTimeNENet(const TTimeNENet& TimeNet) : TNet(TimeNet) { }
67    void Save(TSOut& SOut) const { TNet::Save(SOut); }
68    static PTimeNENet New() { return new TTimeNENet(); }
69    static PTimeNENet New(const int& Nodes, const int& Edges) { return new TTimeNENet(Nodes, Edges); }
70    static PTimeNENet Load(TSIn& SIn) { return new TTimeNENet(SIn); }
71    TTimeNENet& operator = (const TTimeNENet& TimeNet);
72    PTimeNet GetTimeNet() const;
73    PTimeNENet Get1stEdgeNet() const;
74    PTimeNENet GetSubGraph(const TIntV& NIdV) const;
75    PTimeNENet GetESubGraph(const TIntV& EIdV) const;
76    PTimeNENet GetGraphUpToTm(const TSecTm& MaxEdgeTm) const;
77    void SortNodeEdgeTimes();
78    void UpdateNodeTimes();
79    void SetNodeTmToFirstEdgeTm();
80    void SetRndEdgeTimes(const int& MinTmEdge=0);
81    void DumpTimeStat() const;
82    void GetNIdByTm(TIntV& NIdV) const;
83    void GetEIdByTm(TIntV& EIdV) const;
84    void GetTmBuckets(const TTmUnit& GroupBy, TTimeNet::TTmBucketV& TmBucketV) const;
85    void GetEdgeTmBuckets(const TTmUnit& GroupBy, TTimeNet::TTmBucketV& TmBucketV) const;
86    void GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const;
87    void GetEdgeBuckets(const int EdgesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const;
88    int GetTriadEdges(TIntV& TriadEIdV) const;
89    PGStatVec TimeGrowth(const TTmUnit& TimeStep, const TFSet& TakeStat, const TSecTm& StartTm=TSecTm(1)) const;
90    PGStatVec TimeGrowth(const TStr& FNmPref, const TStr& Desc, const TFSet& TakeStat, const int& NDiamRuns,
91      const TTmUnit& TmUnit, const int& TakeNTmUnits, const bool& LinkBWays) const;
92    void PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& GroupBy, const TSecTm& StartTm,
93      const int& NDiamRuns=10, const bool& OnlyWcc=false) const;
94    void PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
95      const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam, const bool& LinkBWays);
96    void SaveEdgeTm(const TStr& EdgeFNm, const bool& RenumberNId=false, const bool& RelativeTm=false) const;
97    static PTimeNENet GetSmallNet();
98    static PTimeNENet GetGnmRndNet(const int& Nodes, const int& Edges);
99    static PTimeNENet GetPrefAttach(const int& Nodes, const int& Edges, const double& GammaIn, const double& GammaOut);
100    static PTimeNENet GetPrefAttach(const int& Nodes, const int& OutDeg);
101    static PTimeNENet LoadFlickr(const TStr& NodeFNm, const TStr& EdgeFNm);
102    static PTimeNENet LoadEdgeTm(const TStr& EdgeFNm, const int& SrcFld=0, const int& DstFld=1, const int& TimeFld=2, const TSsFmt& Separator=ssfTabSep);
103    friend class TPt<TTimeNENet>;
104  };
105  namespace TSnap {
106  template <> struct IsMultiGraph<TTimeNENet> { enum { Val = 1 }; };
107  template <> struct IsDirected<TTimeNENet> { enum { Val = 1 }; };
108  template <> struct IsNodeDat<TTimeNENet> { enum { Val = 1 }; };
109  template <> struct IsEdgeDat<TTimeNENet> { enum { Val = 1 }; };
110  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-final_vote_store_84.hpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.h</div>
                <div class="column column_space"><pre><code>15  		bool put (nano::write_transaction const & transaction_a, nano::qualified_root const & root_a, nano::block_hash const & hash_a) override;
16  		std::vector<nano::block_hash> get (nano::transaction const & transaction_a, nano::root const & root_a) override;
17  		void del (nano::write_transaction const & transaction_a, nano::root const & root_a) override;
18  		size_t count (nano::transaction const & transaction_a) const override;
19  		void clear (nano::write_transaction const & transaction_a, nano::root const & root_a) override;
</pre></code></div>
                <div class="column column_space"><pre><code>40    void GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const;
41    PGStatVec TimeGrowth(const TTmUnit& TmUnit, const TFSet& TakeStat, const TSecTm& StartTm) const;
42    void PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& GroupBy, const TSecTm& StartTm,
43      const int& NDiamRuns=10, const bool& OnlyWcc=false, const bool& AlsoRewire=false) const;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    