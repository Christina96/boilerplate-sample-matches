
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.7211703958691909%, Tokens: 10</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-layer.hpp</h3>
            <pre><code>1  #ifndef CAFFE_LAYER_H_
2  #define CAFFE_LAYER_H_
3  #include <algorithm>
4  #include <string>
5  #include <vector>
6  #include "caffe/blob.hpp"
7  #include "caffe/common.hpp"
8  #include "caffe/layer_factory.hpp"
9  #include "caffe/proto/caffe.pb.h"
10  #include "caffe/util/math_functions.hpp"
11  #include "caffe/multinode/mlsl.hpp"
12  #define MAX_ELEMS_TO_LOG 16
13  #define LOG_LAYER(layer) DLOG(INFO) << layer->type() << ": "
14  #define LOG_BLOB(layer, blob, part, blob_id, description)              \
15    do                                                                   \
16    {                                                                    \
17        long elems_to_log = std::min(static_cast<long>(MAX_ELEMS_TO_LOG), blob->count());    \
18        for (long idx = 0; idx < elems_to_log; idx++)                     \
19        {                                                                \
20            LOG_LAYER(layer) << description                              \
21                             << ", blob_id " << blob_id                  \
22                             << ", idx "     << idx                      \
23                             << ", value "   << blob->cpu_##part()[idx]; \
24        }                                                                \
25    } while (0)
26  #define LOG_PARAM_BLOB(blob, part, blob_id, description)               \
27    do                                                                   \
28    {                                                                    \
29        long elems_to_log = std::min(static_cast<long>(MAX_ELEMS_TO_LOG), blob->count());    \
30        for (long idx = 0; idx < elems_to_log; idx++)                     \
31        {                                                                \
32            DLOG(INFO) << description                                    \
33                       << ", blob_id " << blob_id                        \
34                       << ", idx "     << idx                            \
35                       << ", value "   << blob->cpu_##part()[idx];       \
36        }                                                                \
37    } while (0)
38  #define LOG_BUFFER(layer, buffer, buffer_id, description)    \
39    do                                                         \
40    {                                                          \
41        if (!buffer) {                                         \
42                            \
43            break;                                             \
44        }                                                      \
45        for (int idx = 0; idx < MAX_ELEMS_TO_LOG; idx++)       \
46        {                                                      \
47            LOG_LAYER(layer) << description                    \
48                             << ", buffer_id " << buffer_id    \
49                             << ", idx "       << idx          \
50                             << ", value "     << buffer[idx]; \
51        }                                                      \
52    } while (0)
53  namespace boost { class mutex; }
54  namespace caffe {
55  template <typename Dtype>
56  class Layer {
57  #ifdef USE_MLSL
58  public:
59  	MLSL::Operation *layerOp{ nullptr };
60    mn::Distribution &GetDistribution();
61    virtual bool ParamNeedReduce(int param_id) { return true; }
62  protected:
63    virtual bool Bypass(const vector<Blob<Dtype>*>& bottom,
64                        const vector<Blob<Dtype>*>& top);
65    virtual void MultinodeSetUp(const vector<Blob<Dtype>*>& bottom,
66                                const vector<Blob<Dtype>*>& top);
67  #endif &bsol;* USE_MLSL */
68   public:
69    explicit Layer(const LayerParameter& param)
70      : layer_param_(param), is_shared_(false) {
71        phase_ = param.phase();
72        if (layer_param_.blobs_size() > 0) {
73          blobs_.resize(layer_param_.blobs_size());
74          for (int i = 0; i < layer_param_.blobs_size(); ++i) {
75            blobs_[i].reset(new Blob<Dtype>());
76            blobs_[i]->FromProto(layer_param_.blobs(i));
77          }
78        }
79      }
80    virtual ~Layer() {}
81    void SetUp(const vector<Blob<Dtype>*>& bottom,
82        const vector<Blob<Dtype>*>& top) {
83      InitMutex();
84      CheckBlobCounts(bottom, top);
85      LayerSetUp(bottom, top);
86      Reshape(bottom, top);
87      SetLossWeights(top);
88  #ifdef USE_MLSL
89      MultinodeSetUp(bottom, top);
90  #endif
91    }
92    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
93        const vector<Blob<Dtype>*>& top) {}
94    virtual inline bool ShareInParallel() const { return false; }
95    inline bool IsShared() const { return is_shared_; }
96    inline void SetShared(bool is_shared) {
97      CHECK(ShareInParallel() || !is_shared)
98          << type() << "Layer does not support sharing.";
99      is_shared_ = is_shared;
100    }
101    virtual void Reshape(const vector<Blob<Dtype>*>& bottom,
102        const vector<Blob<Dtype>*>& top) = 0;
103    inline Dtype Forward(const vector<Blob<Dtype>*>& bottom,
104        const vector<Blob<Dtype>*>& top);
105    inline void Backward(const vector<Blob<Dtype>*>& top,
<span onclick='openModal()' class='match'>106        const vector<bool>& propagate_down,
107        const vector<Blob<Dtype>*>& bottom);
108    vector<shared_ptr<Blob<Dtype> > >& blobs() {
109      return blobs_;
110    }
111    const LayerParameter& layer_param() const { return layer_param_; }
</span>112    virtual void ToProto(LayerParameter* param, bool write_diff = false);
113    inline Dtype loss(const int top_index) const {
114      return (loss_.size() > top_index) ? loss_[top_index] : Dtype(0);
115    }
116    inline void set_loss(const int top_index, const Dtype value) {
117      if (loss_.size() <= top_index) {
118        loss_.resize(top_index + 1, Dtype(0));
119      }
120      loss_[top_index] = value;
121    }
122    virtual inline const char* type() const { return ""; }
123    virtual inline int ExactNumBottomBlobs() const { return -1; }
124    virtual inline int MinBottomBlobs() const { return -1; }
125    virtual inline int MaxBottomBlobs() const { return -1; }
126    virtual inline int ExactNumTopBlobs() const { return -1; }
127    virtual inline int MinTopBlobs() const { return -1; }
128    virtual inline int MaxTopBlobs() const { return -1; }
129    virtual inline bool EqualNumBottomTopBlobs() const { return false; }
130    virtual inline bool AutoTopBlobs() const { return false; }
131    virtual inline bool AllowForceBackward(const int bottom_index) const {
132      return true;
133    }
134    inline bool param_propagate_down(const int param_id) {
135      return (param_propagate_down_.size() > param_id) ?
136          param_propagate_down_[param_id] : false;
137    }
138    inline void set_param_propagate_down(const int param_id, const bool value) {
139      if (param_propagate_down_.size() <= param_id) {
140        param_propagate_down_.resize(param_id + 1, true);
141      }
142      param_propagate_down_[param_id] = value;
143    }
144   protected:
145    LayerParameter layer_param_;
146    Phase phase_;
147    vector<shared_ptr<Blob<Dtype> > > blobs_;
148    vector<bool> param_propagate_down_;
149    vector<Dtype> loss_;
150    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
151        const vector<Blob<Dtype>*>& top) = 0;
152    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
153        const vector<Blob<Dtype>*>& top) {
154      return Forward_cpu(bottom, top);
155    }
156    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
157        const vector<bool>& propagate_down,
158        const vector<Blob<Dtype>*>& bottom) = 0;
159    virtual void Backward_gpu(const vector<Blob<Dtype>*>& top,
160        const vector<bool>& propagate_down,
161        const vector<Blob<Dtype>*>& bottom) {
162      Backward_cpu(top, propagate_down, bottom);
163    }
164    virtual void CheckBlobCounts(const vector<Blob<Dtype>*>& bottom,
165                                 const vector<Blob<Dtype>*>& top) {
166      if (ExactNumBottomBlobs() >= 0) {
167        CHECK_EQ(ExactNumBottomBlobs(), bottom.size())
168            << type() << " Layer takes " << ExactNumBottomBlobs()
169            << " bottom blob(s) as input.";
170      }
171      if (MinBottomBlobs() >= 0) {
172        CHECK_LE(MinBottomBlobs(), bottom.size())
173            << type() << " Layer takes at least " << MinBottomBlobs()
174            << " bottom blob(s) as input.";
175      }
176      if (MaxBottomBlobs() >= 0) {
177        CHECK_GE(MaxBottomBlobs(), bottom.size())
178            << type() << " Layer takes at most " << MaxBottomBlobs()
179            << " bottom blob(s) as input.";
180      }
181      if (ExactNumTopBlobs() >= 0) {
182        CHECK_EQ(ExactNumTopBlobs(), top.size())
183            << type() << " Layer produces " << ExactNumTopBlobs()
184            << " top blob(s) as output.";
185      }
186      if (MinTopBlobs() >= 0) {
187        CHECK_LE(MinTopBlobs(), top.size())
188            << type() << " Layer produces at least " << MinTopBlobs()
189            << " top blob(s) as output.";
190      }
191      if (MaxTopBlobs() >= 0) {
192        CHECK_GE(MaxTopBlobs(), top.size())
193            << type() << " Layer produces at most " << MaxTopBlobs()
194            << " top blob(s) as output.";
195      }
196      if (EqualNumBottomTopBlobs()) {
197        CHECK_EQ(bottom.size(), top.size())
198            << type() << " Layer produces one top blob as output for each "
199            << "bottom blob input.";
200      }
201    }
202    inline void SetLossWeights(const vector<Blob<Dtype>*>& top) {
203      const int num_loss_weights = layer_param_.loss_weight_size();
204      if (num_loss_weights) {
205        CHECK_EQ(top.size(), num_loss_weights) << "loss_weight must be "
206            "unspecified or specified once per top blob.";
207        for (int top_id = 0; top_id < top.size(); ++top_id) {
208          const Dtype loss_weight = layer_param_.loss_weight(top_id);
209          if (loss_weight == Dtype(0)) { continue; }
210          this->set_loss(top_id, loss_weight);
211          const int count = top[top_id]->count();
212          Dtype* loss_multiplier = top[top_id]->mutable_cpu_diff();
213          caffe_set(count, loss_weight, loss_multiplier);
214        }
215      }
216    }
217   private:
218    bool is_shared_;
219    shared_ptr<boost::mutex> forward_mutex_;
220    void InitMutex();
221    void Lock();
222    void Unlock();
223    DISABLE_COPY_AND_ASSIGN(Layer);
224  };  
225  template <typename Dtype>
226  inline Dtype Layer<Dtype>::Forward(const vector<Blob<Dtype>*>& bottom,
227      const vector<Blob<Dtype>*>& top) {
228    Lock();
229    Dtype loss = 0;
230    Reshape(bottom, top);
231  #ifdef USE_MLSL
232    if (Bypass(bottom, top)) {
233      Unlock();
234      return loss;
235    }
236  #endif
237    switch (Caffe::mode()) {
238    case Caffe::CPU:
239      Forward_cpu(bottom, top);
240      for (int top_id = 0; top_id < top.size(); ++top_id) {
241        if (!this->loss(top_id)) { continue; }
242        const int count = top[top_id]->count();
243        const Dtype* data = top[top_id]->cpu_data();
244        const Dtype* loss_weights = top[top_id]->cpu_diff();
245        loss += caffe_cpu_dot(count, data, loss_weights);
246      }
247      break;
248    case Caffe::GPU:
249      Forward_gpu(bottom, top);
250  #ifndef CPU_ONLY
251      for (int top_id = 0; top_id < top.size(); ++top_id) {
252        if (!this->loss(top_id)) { continue; }
253        const int count = top[top_id]->count();
254        const Dtype* data = top[top_id]->gpu_data();
255        const Dtype* loss_weights = top[top_id]->gpu_diff();
256        Dtype blob_loss = 0;
257        caffe_gpu_dot(count, data, loss_weights, &blob_loss);
258        loss += blob_loss;
259      }
260  #endif
261      break;
262    default:
263      LOG(FATAL) << "Unknown caffe mode.";
264    }
265    Unlock();
266    return loss;
267  }
268  template <typename Dtype>
269  inline void Layer<Dtype>::Backward(const vector<Blob<Dtype>*>& top,
270      const vector<bool>& propagate_down,
271      const vector<Blob<Dtype>*>& bottom) {
272  #ifdef USE_MLSL
273    if (Bypass(bottom, top)) return;
274  #endif
275    switch (Caffe::mode()) {
276    case Caffe::CPU:
277      Backward_cpu(top, propagate_down, bottom);
278      break;
279    case Caffe::GPU:
280      Backward_gpu(top, propagate_down, bottom);
281      break;
282    default:
283      LOG(FATAL) << "Unknown caffe mode.";
284    }
285  }
286  template <typename Dtype>
287  void Layer<Dtype>::ToProto(LayerParameter* param, bool write_diff) {
288    param->Clear();
289    param->CopyFrom(layer_param_);
290    param->clear_blobs();
291    for (int i = 0; i < blobs_.size(); ++i) {
292      blobs_[i]->ToProto(param->add_blobs(), write_diff);
293    }
294  }
295  }  
296  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.h</h3>
            <pre><code>1  #ifndef crawler_h
2  #define crawler_h
3  #include "net.h"
4  #include "mine.h"
5  ClassHdTP(TCrawler, PCrawler);
6  ClassTP(TCrawlerDef, PCrawlerDef)
7  private:
8    int MxUrls;
9    int MnConns;
10    int MxConns;
11    int MxConnsPerSrv;
12    int AfterFetchDelaySecs;
13    int MxLev;
14    int MxDep;
15    int MxContLen;
16    int MnQLen;
17    int QResetMod;
18    int MxQSegLen;
19    int MxRetries;
20    int RevisitSecs;
21    bool RedirDmAllowedP;
22    TStrV StartUrlStrV;
23    TStrV RqDmNmV;
24    TStrV BadDmNmV;
25    PGeoIpBs GeoIpBs;
26    TStrV RqCountryNmV;
27    TStrV RqContTypeNmV;
28    TStrV BadFExtV;
29    TStrH BadFExtH;
30    TStr UserAgentStr;
31    UndefCopyAssign(TCrawlerDef);
32  public:
33    TCrawlerDef():
34      MxUrls(100000), MnConns(1), MxConns(10), MxConnsPerSrv(1),
35      AfterFetchDelaySecs(1), MxLev(3), MxDep(3), MxContLen(100000),
36      MnQLen(1000), QResetMod(1000), MxQSegLen(1000000),
37      MxRetries(2), RevisitSecs(-1), RedirDmAllowedP(false),
38      StartUrlStrV(), RqDmNmV(), BadDmNmV(), GeoIpBs(), RqCountryNmV(),
39      RqContTypeNmV(), BadFExtV(), BadFExtH(), UserAgentStr(){}
40    static PCrawlerDef New(){
41      return PCrawlerDef(new TCrawlerDef());}
42    void PutMxUrls(const int& _MxUrls){MxUrls=_MxUrls;}
43    int GetMxUrls() const {return MxUrls;}
44    void PutMnConns(const int& _MnConns){MnConns=_MnConns;}
45    int GetMnConns() const {return MnConns;}
46    void PutMxConns(const int& _MxConns){MxConns=_MxConns;}
47    int GetMxConns() const {return MxConns;}
48    void PutMxConnsPerSrv(const int& _MxConnsPerSrv){
49      MxConnsPerSrv=_MxConnsPerSrv;}
50    int GetMxConnsPerSrv() const {return MxConnsPerSrv;}
51    void PutAfterFetchDelaySecs(const int& _AfterFetchDelaySecs){
52      AfterFetchDelaySecs=_AfterFetchDelaySecs;}
53    int GetAfterFetchDelaySecs() const {return AfterFetchDelaySecs;}
54    void PutMxLev(const int& _MxLev){MxLev=_MxLev;}
55    int GetMxLev() const {return MxLev;}
56    void PutMxDep(const int& _MxDep){MxDep=_MxDep;}
57    int GetMxDep() const {return MxDep;}
58    void PutMxContLen(const int& _MxContLen){MxContLen=_MxContLen;}
59    int GetMxContLen() const {return MxContLen;}
60    void PutMnQLen(const int& _MnQLen){MnQLen=_MnQLen;}
61    int GetMnQLen() const {return MnQLen;}
62    void PutQResetMod(const int& _QResetMod){QResetMod=_QResetMod;}
63    int GetQResetMod() const {return QResetMod;}
64    void PutMxQSegLen(const int& _MxQSegLen){MxQSegLen=_MxQSegLen;}
65    int GetMxQSegLen() const {return MxQSegLen;}
66    void PutMxRetries(const int& _MxRetries){MxRetries=_MxRetries;}
67    int GetMxRetries() const {return MxRetries;}
68    void PutRevisitSecs(const int& _RevisitSecs){RevisitSecs=_RevisitSecs;}
69    int GetRevisitSecs() const {return RevisitSecs;}
70    void PutRedirDmAllowed(const bool& _RedirDmAllowedP){RedirDmAllowedP=_RedirDmAllowedP;}
71    bool IsRedirDmAllowed() const {return RedirDmAllowedP;}
72    void AddStartUrlStr(const TStr& UrlStr){
73      PUrl Url=TUrl::New(UrlStr);
74      EAssertRA(Url->IsOk(usHttp), "Url must have HTTP schema", UrlStr);
75      StartUrlStrV.Add(UrlStr);}
76    void AddStartUrlStrV(const TStrV& UrlStrV){
77      for (int UrlStrN=0; UrlStrN<UrlStrV.Len(); UrlStrN++){AddStartUrlStr(UrlStrV[UrlStrN]);}}
78    int GetStartUrls() const {
79      return StartUrlStrV.Len();}
80    TStr GetStartUrl(const int& StartUrlN) const {
81      return StartUrlStrV[StartUrlN];}
82    void AddRqDmNm(const TStr& DmNm){RqDmNmV.AddUnique(DmNm);}
83    void AddRqDmNmV(const TStrV& DmNmV){
84      for (int DmNmN=0; DmNmN<DmNmV.Len(); DmNmN++){AddRqDmNm(DmNmV[DmNmN]);}}
85    void AddBadDmNm(const TStr& DmNm){BadDmNmV.AddUnique(DmNm);}
86    void AddBadDmNmV(const TStrV& DmNmV){
87      for (int DmNmN=0; DmNmN<DmNmV.Len(); DmNmN++){AddBadDmNm(DmNmV[DmNmN]);}}
88    bool IsHostNmOk(const TStr& DmNm);
89    void LoadGeoIpBs(const TStr& GeoIpBsFNm){GeoIpBs=TGeoIpBs::LoadBin(GeoIpBsFNm);}
90    PGeoIpBs GetGeoIpBs() const {return GeoIpBs;}
91    bool IsGeoIpBs() const {return GetGeoIpBs().Empty();}
92    void AddRqCountryNm(const TStr& CountryNm){RqCountryNmV.Add(CountryNm);}
93    void AddRqCountryNmV(const TStrV& CountryNmV){
94      for (int CountryNmN=0; CountryNmN<CountryNmV.Len(); CountryNmN++){
95        AddRqCountryNm(CountryNmV[CountryNmN]);}}
96    void AddRqContTypeNm(const TStr& ContTypeNm){RqContTypeNmV.Add(ContTypeNm);}
97    void AddRqContTypeNmV(const TStrV& ContTypeNmV){
98      for (int ContTypeNmN=0; ContTypeNmN<ContTypeNmV.Len(); ContTypeNmN++){
99        AddRqContTypeNm(ContTypeNmV[ContTypeNmN]);}}
100    bool IsContTypeNmOk(const TStr& ContTypeNm);
101    void AddBadFExt(const TStr& FExt){
102      BadFExtV.Add(FExt.GetUc()); BadFExtH.AddKey(FExt.GetUc());}
103    void AddBadFExtV(const TStrV& FExtV){
104      for (int FExtN=0; FExtN<FExtV.Len(); FExtN++){AddBadFExt(FExtV[FExtN]);}}
105    bool IsFExtOk(const PUrl& Url) const;
106    void PutUserAgentStr(const TStr& _UserAgentStr){UserAgentStr=_UserAgentStr;}
107    TStr GetUserAgentStr() const {return UserAgentStr;}
108    void OptHtmlCrawling();
109    void AddSiteUrlStr(const TStr& SiteUrlStr);
110    void AddSiteUrlStrV(const TStrV& SiteUrlStrV);
111    void LoadUrlStrV(const TStr& SiteUrlStrVFNm);
112    TStr GetStr();
113  };
114  class TCrawlerUrlDesc{
115  public:
116    TBlobPt DocBlobPt;
117    TMd5Sig DocMemMd5Sig;
118    TSecTm DocSecTm;
119    TUCh DocLev;
120    TUCh DocDep;
121  public:
122    TCrawlerUrlDesc():
123      DocBlobPt(), DocMemMd5Sig(), DocSecTm(), DocLev(), DocDep(){}
124    TCrawlerUrlDesc(
125     const TBlobPt& _DocBlobPt, const TMd5Sig& _DocMemMd5Sig,
126     const TSecTm& _DocSecTm, const TUCh& _DocLev, const TUCh& _DocDep):
127      DocBlobPt(_DocBlobPt), DocMemMd5Sig(_DocMemMd5Sig),
128      DocSecTm(_DocSecTm), DocLev(_DocLev), DocDep(_DocDep){}
129    TCrawlerUrlDesc(TSIn& SIn):
130      DocBlobPt(SIn), DocMemMd5Sig(SIn), DocSecTm(SIn), DocLev(SIn), DocDep(SIn){}
131    void Save(TSOut& SOut) const {
132      DocBlobPt.Save(SOut); DocMemMd5Sig.Save(SOut);
133      DocSecTm.Save(SOut); DocLev.Save(SOut); DocDep.Save(SOut);}
134    TCrawlerUrlDesc& operator=(const TCrawlerUrlDesc& UrlDesc){
135      DocBlobPt=UrlDesc.DocBlobPt; DocMemMd5Sig=UrlDesc.DocMemMd5Sig;
136      DocSecTm=UrlDesc.DocSecTm; DocLev=UrlDesc.DocLev; DocDep=UrlDesc.DocDep;
137      return *this;}
138  };
139  ClassTP(TCrawlerUrlDescBs, PCrawlerUrlDescBs)
140  private:
141    TCrawler* Crawler;
142    typedef TPair<TInt, TBlobPt> TIntBlobPtPr;
143    THash<TMd5Sig, TCrawlerUrlDesc> UrlMd5SigToDescH;
144    UndefDefaultCopyAssign(TCrawlerUrlDescBs);
145  public:
146    TCrawlerUrlDescBs(TCrawler* _Crawler);
147    static PCrawlerUrlDescBs New(TCrawler* Crawler){
148      return new TCrawlerUrlDescBs(Crawler);}
149    int GetUrls() const {return UrlMd5SigToDescH.Len();}
150    bool IsUrl(const TMd5Sig& UrlMd5Sig) const {
151      return UrlMd5SigToDescH.IsKey(UrlMd5Sig);}
152    void AddUrlDesc(const TMd5Sig& UrlMd5Sig, const TCrawlerUrlDesc& UrlDesc){
153      UrlMd5SigToDescH.AddDat(UrlMd5Sig, UrlDesc);}
154    TCrawlerUrlDesc& GetUrlDesc(const TMd5Sig& UrlMd5Sig){
155      return UrlMd5SigToDescH.GetDat(UrlMd5Sig);}
156    TStr GetFNm() const;
157    void Load();
158    void Save();
159  };
160  ClassTPV(TCrawlerHost, PCrawlerHost, TCrawlerHostV)
161  private:
162    TStr HostNm, RevHostNm;
163    TStr IpNum;
164    int ActiveConns;
165    int FetchedUrls;
166    int FetchErrors;
167    int QueueUrls;
168    uint64 TransferBytes;
169    int TransferMSecs;
170    TSecTm LastFetchTm;
171    UndefDefaultCopyAssign(TCrawlerHost);
172  public:
173    TCrawlerHost(const TStr& _HostNm):
174      HostNm(_HostNm), RevHostNm(_HostNm.Reverse()), IpNum(),
175      ActiveConns(0), FetchedUrls(0), FetchErrors(0),
176      QueueUrls(0), TransferBytes(0), TransferMSecs(0), LastFetchTm(0){}
177    static PCrawlerHost New(const TStr& HostNm){
178      return new TCrawlerHost(HostNm);}
179    TStr GetHostNm() const {return HostNm;}
180    TStr GetRevHostNm() const {return RevHostNm;}
181    bool IsIpNum() const {return !IpNum.Empty();}
182    TStr& GetIpNum(){return IpNum;}
183    int& GetActiveConns(){return ActiveConns;}
184    int& GetFetchedUrls(){return FetchedUrls;}
185    int& GetFetchErrors(){return FetchErrors;}
186    int& GetQueueUrls(){return QueueUrls;}
187    uint64& GetTransferBytes(){return TransferBytes;}
188    int& GetTransferMSecs(){return TransferMSecs;}
189    double GetAvgHttpRespLen(){
190      return FetchedUrls==0 ? 0 : TransferBytes/double(FetchedUrls);}
191    double GetAvgTransferBps(){
192      return TransferMSecs==0 ? 0 : (TransferBytes*8.0)/(TransferMSecs/1000.0);}
193    TSecTm& GetLastFetchTm(){return LastFetchTm;}
194  };
195  ClassTP(TCrawlerHostBs, PCrawlerHostBs)
196  private:
197    TCrawler* Crawler;
198    THash<TStr, PCrawlerHost> NmToHostH;
199    UndefDefaultCopyAssign(TCrawlerHostBs);
200  public:
201    TCrawlerHostBs(TCrawler* _Crawler);
202    static PCrawlerHostBs New(TCrawler* Crawler){
203      return new TCrawlerHostBs(Crawler);}
204    int GetHosts() const {return NmToHostH.Len();}
<span onclick='openModal()' class='match'>205    bool IsHost(const TStr& HostNm) const {
206      return NmToHostH.IsKey(HostNm);}
207    PCrawlerHost AddGetHost(const TStr& HostNm);
208    PCrawlerHost GetHost(const TStr& HostNm){
209      return NmToHostH.GetDat(HostNm);}
</span>210    PCrawlerHost GetHost(const int& HostN){
211      return NmToHostH[HostN];}
212    void GetSortedHostV(TCrawlerHostV& HostV, const TStr& SortOrderNm);
213    void GetSummaryInfo(
214     int& ActiveConns, int& FetchedUrls, int& FetchErrors, int& QueueUrls,
215     double& TransferBytes, double& TransferMSecs, 
216     double& AvgHttpRespLen, double& AvgTransferBps);
217  };
218  ClassTP(TCrawlerQueue, PCrawlerQueue)
219  private:
220    TCrawler* Crawler;
221    THash<TMd5Sig, TStrStrIntIntQu> UrlMd5SigToUrlStrHostNmLevDepQuH;
222    TVec<TIntQ> LevUrlIdQV;
223    TStr ToDelUrlQBBsFNm;
224    PBlobBs UrlQBBs;
225    UndefDefaultCopyAssign(TCrawlerQueue);
226  public:
227    TCrawlerQueue(TCrawler* _Crawler);
228    static PCrawlerQueue New(TCrawler* Crawler){
229      return new TCrawlerQueue(Crawler);}
230    int GetQLevs() const {return LevUrlIdQV.Len();}
231    int GetQLevUrls(const int& Lev) const {return LevUrlIdQV[Lev].Len();}
232    int GetQUrls() const {return UrlMd5SigToUrlStrHostNmLevDepQuH.Len();}
233    int GetUnconnQUrls() const {
234      int QUrls=0; int Levs=GetQLevs();
235      for (int Lev=0; Lev<Levs; Lev++){QUrls+=GetQLevUrls(Lev);}
236      return QUrls;}
237    bool Empty() const {return GetQUrls()==0;}
238    void GetQUrlsHostPrV(TIntStrPrV& QUrlsHostPrV);
239    bool IsQUrl(const TMd5Sig& UrlMd5Sig) const {
240      return UrlMd5SigToUrlStrHostNmLevDepQuH.IsKey(UrlMd5Sig);}
241    int AddQUrl(const TMd5Sig& UrlMd5Sig, const TStr& UrlStr, const TStr& HostNm, const int& Lev, const int& Dep){
242      int QUrlId=UrlMd5SigToUrlStrHostNmLevDepQuH.AddKey(UrlMd5Sig);
243      UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId]=TStrStrIntIntQu(UrlStr, HostNm, Lev, Dep);
244      return QUrlId;}
245    void DelQUrl(const int& QUrlId){
246      UrlMd5SigToUrlStrHostNmLevDepQuH.DelKeyId(QUrlId);}
247    TStr GetQUrlStr(const TMd5Sig& UrlMd5Sig) const {
248      return UrlMd5SigToUrlStrHostNmLevDepQuH.GetDat(UrlMd5Sig).Val1;}
249    TStr GetQUrlStr(const int& QUrlId) const {
250      return UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val1;}
251    TStr GetQHostNm(const int& QUrlId) const {
252      return UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val2;}
253    int GetQUrlLev(const TMd5Sig& UrlMd5Sig) const {
254      return UrlMd5SigToUrlStrHostNmLevDepQuH.GetDat(UrlMd5Sig).Val3;}
255    int GetQUrlLev(const int& QUrlId) const {
256      return UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val3;}
257    int GetQUrlDep(const TMd5Sig& UrlMd5Sig) const {
258      return UrlMd5SigToUrlStrHostNmLevDepQuH.GetDat(UrlMd5Sig).Val4;}
259    int GetQUrlDep(const int& QUrlId) const {
260      return UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val4;}
261    void GetQUrl(const int& QUrlId, TMd5Sig& UrlMd5Sig, int& Lev, int& Dep){
262      UrlMd5Sig=UrlMd5SigToUrlStrHostNmLevDepQuH.GetKey(QUrlId);
263      Lev=UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val3;
264      Dep=UrlMd5SigToUrlStrHostNmLevDepQuH[QUrlId].Val4;}
265    void PushQUrl(const TStr& UrlStr, const int& Lev, const int& Dep);
266    void PushQUrl(const PUrl& Url, const int& Lev, const int& Dep);
267    bool PopQUrl(int& QUrlId, TStr& UrlStr);
268    void ShuffleUrlQ();
269    void ResetQUrlBs();
270    TStr GetUrlQBBsFNm() const;
271    TStr GetUrlQBBsWcFNm() const;
272    void PushQUrlBs();
273    void PushQUrlToUrlQBs(const PUrl& Url, const int& Lev, const int& Dep);
274    void PushQUrlToUrlQBs(const TStr& UrlStr, const int& Lev, const int& Dep);
275    void PopSaveQUrlBs();
276  };
277  ClassTPE(TCrawlerFetcher, PCrawlerFetcher, TWebPgFetch)
278  private:
279    TCrawler* Crawler;
280    typedef TTriple<TInt, PUrl, TUInt64> TQUrlIdUrlTmTr;
281    THash<TInt, TQUrlIdUrlTmTr> ConnIdToQUrlIdUrlTmTrH;
282    int CurMxConns;
283    TTm LastClrZombiesTm;
284    int Zombies;
285    TIntIntH ZombieConnIdToFetchSizeH;
286    UndefDefaultCopyAssign(TCrawlerFetcher);
287    void DelCrawlerFetcherConn(const int& ConnId);
288  public:
289    TCrawlerFetcher(TCrawler* _Crawler);
290    static PCrawlerFetcher New(TCrawler* Crawler){
291      return new TCrawlerFetcher(Crawler);}
292    void AddConn(const int& ConnId, const int& QUrlId, const PUrl& Url){
293      ConnIdToQUrlIdUrlTmTrH.AddDat(ConnId, TQUrlIdUrlTmTr(QUrlId, Url, TTm::GetCurUniMSecs()));}
294    void GetDelConn(const int& ConnId, int& QUrlId, PUrl& Url, int& MSecs){
295      QUrlId=ConnIdToQUrlIdUrlTmTrH.GetDat(ConnId).Val1;
296      Url=ConnIdToQUrlIdUrlTmTrH.GetDat(ConnId).Val2;
297      MSecs=int(TTm::GetCurUniMSecs()-ConnIdToQUrlIdUrlTmTrH.GetDat(ConnId).Val3);
298      ConnIdToQUrlIdUrlTmTrH.DelKey(ConnId);}
299    int GetConns() const {return ConnIdToQUrlIdUrlTmTrH.Len();}
300    void GetConnV(TIntStrIntIntQuV& ConnIdUrlStrMSecsSizeQuV);
301    void PutCurMxConns(const int& _CurMxConns){CurMxConns=_CurMxConns;}
302    int GetCurMxConns() const {return CurMxConns;}
303    void ClrZombies();
304    int GetZombies() const {return Zombies;}
305    void Fetch();
306    void OnFetch(const int& &bsol;*ConnId*/, const PWebPg& WebPg);
307    void OnError(const int& &bsol;*ConnId*/, const TStr& MsgStr);
308  };
309  ClassTP(TCrawlerDocBs, PCrawlerDocBs)
310  private:
311    TCrawler* Crawler;
312    TStr DocBsNm;
313    TStr DocBsNrFPath;
314    TStr DocBsFAccessNm;
315    int DocBsMxSegLen;
316    PBlobBs DocBBs;
317    UndefDefaultCopyAssign(TCrawlerDocBs);
318  public:
319    TCrawlerDocBs(TCrawler* _Crawler):
320      Crawler(_Crawler),
321      DocBsNm(), DocBsNrFPath(), DocBsFAccessNm(), DocBBs(){}
322    static PCrawlerDocBs New(TCrawler* Crawler){
323      return new TCrawlerDocBs(Crawler);}
324    virtual ~TCrawlerDocBs(){}
325    void PutDocBsNm(const TStr& _DocBsNm){DocBsNm=_DocBsNm;}
326    TStr GetDocBsNm() const {return DocBsNm;}
327    void PutDocBsNrFPath(const TStr& _DocBsNrFPath){DocBsNrFPath=_DocBsNrFPath;}
328    TStr GetDocBsNrFPath() const {return DocBsNrFPath;}
329    void PutDocBsFAccessNm(const TStr& _DocBsFAccessNm){DocBsFAccessNm=_DocBsFAccessNm;}
330    TStr GetDocBsFAccessNm() const {return DocBsFAccessNm;}
331    void PutDocBsMxSegLen(const int& _DocBsMxSegLen){DocBsMxSegLen=_DocBsMxSegLen;}
332    int GetDocBsMxSegLen() const {return DocBsMxSegLen;}
333    PBlobBs GetDocBBs() const {return DocBBs;}
334    TFAccess Open();
335    void Close();
336    TBlobPt AddDoc(const TStr& DocUrlStr, const TMem& DocMem);
337    TBlobPt FFirstDocBlobPt(){return DocBBs->FFirstBlobPt();}
338    bool FNextDocBlobPt(TBlobPt& TrvDocBlobPt,
339     TBlobPt& DocBlobPt, TStr& DateTimeStr, TStr& DocUrlStr, TMem& DocMem);
340  };
341  class TCrawlerTimer: public TTTimer{
342  private:
343    TCrawler* Crawler;
344    uint64 LastEventMSecs;
345    uint64 Last100SecsEventMSecs;
346    uint64 Last1000SecsEventMSecs;
347    UndefDefaultCopyAssign(TCrawlerTimer);
348  public:
349    TCrawlerTimer(TCrawler* _Crawler, const int& TimerTout):
350      TTTimer(TimerTout), Crawler(_Crawler), LastEventMSecs(0),
351      Last100SecsEventMSecs(0), Last1000SecsEventMSecs(0){}
352    static PTimer New(TCrawler* Crawler, const int& TimerTout){
353      return new TCrawlerTimer(Crawler, TimerTout);}
354    void OnTimeOut();
355  };
356  ClassTPE(TCrawlerWebSrv, PCrawlerWebSrv, TWebSrv)
357  private:
358    TCrawler* Crawler;
359    UndefCopyAssign(TCrawlerWebSrv);
360  public:
361    TCrawlerWebSrv(TCrawler* _Crawler, const int& PortN):
362      TWebSrv(PortN, false), Crawler(_Crawler){}
363    static PCrawlerWebSrv New(TCrawler* Crawler, const int& PortN=7777){
364      return new TCrawlerWebSrv(Crawler, PortN);}
365    virtual ~TCrawlerWebSrv(){}
366    TStr GetUrlStr(const int& RefreshSecs, const TStr& SortOrderNm);
367    TStr GetAnchorStr(const TStr& DescStr, 
368     const int& RefreshSecs, const TStr& SortOrderNm);
369    void OnHttpRq(const int& SockId, const PHttpRq& HttpRq);
370  };
371  ClassTP(TCrawlerStat, PCrawlerStat)
372  private:
373    TCrawler* Crawler;
374    uint64 Last100SecsEventMSecs;
375    uint64 Last1000SecsEventMSecs;
376    uint64 Last100SecsFetchedUrls;
377    uint64 Last1000SecsFetchedUrls;
378    double Last100SecsCrawlingSpeed;
379    double Last1000SecsCrawlingSpeed;
380    UndefDefaultCopyAssign(TCrawlerStat);
381  public:
382    TCrawlerStat(TCrawler* _Crawler):
383      Crawler(_Crawler),
384      Last100SecsEventMSecs(0), Last1000SecsEventMSecs(0),
385      Last100SecsFetchedUrls(0), Last1000SecsFetchedUrls(0),
386      Last100SecsCrawlingSpeed(0), Last1000SecsCrawlingSpeed(0){}
387    static PCrawlerStat New(TCrawler* Crawler){
388      return new TCrawlerStat(Crawler);}
389    ~TCrawlerStat(){}
390    void On100Secs();
391    void On1000Secs();
392    double GetLast100SecsCrawlingSpeed(){
393      return Last100SecsCrawlingSpeed;}
394    double GetLast1000SecsCrawlingSpeed(){
395      return Last1000SecsCrawlingSpeed;}
396  };
397  ClassTP(TCrawler, PCrawler)
398  private:
399    PCrawlerDef Def;
400    PCrawlerUrlDescBs UrlDescBs;
401    PCrawlerHostBs HostBs;
402    PCrawlerQueue Queue;
403    PCrawlerFetcher Fetcher;
404    PCrawlerDocBs DocBs;
405    PCrawlerStat Stat;
406    PTimer Timer;
407    PCrawlerWebSrv WebSrv;
408    TTm StartTm;
409    UndefCopyAssign(TCrawler);
410  public:
411    TCrawler();
412    static PCrawler New(){
413      return PCrawler(new TCrawler());}
414    ~TCrawler(){}
415    TCrawler(TSIn&){Fail;}
416    static PCrawler Load(TSIn& SIn){Fail; return NULL;}
417    void Save(TSOut&){Fail;}
418    PCrawlerDef GetDef() const {return Def;}
419    PCrawlerUrlDescBs GetUrlDescBs() const {return UrlDescBs;}
420    PCrawlerHostBs GetHostBs() const {return HostBs;}
421    PCrawlerQueue GetQueue() const {return Queue;}
422    PCrawlerFetcher GetFetcher() const {return Fetcher;}
423    PCrawlerDocBs GetDocBs() const {return DocBs;}
424    PCrawlerStat GetStat() const {return Stat;}
425    PTimer GetTimer() const {return Timer;}
426    PCrawlerWebSrv GetWebSrv() const {return WebSrv;}
427    TTm GetStartTm() const {return StartTm;}
428    void DefCrawlBs(const TStr& CrawlBsNm, const TStr& CrawlBsFPath,
429     const TStr& CrawlBsFAccessNm, const int& CrawlBsMxSegLen);
430    void StartCrawling();
431    void StopCrawling();
432    static TMd5Sig GetUrlMd5Sig(const TStr& UrlStr);
433  };
434  typedef PBlobBs PCrawlBs;
435  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-layer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-crawler.h</div>
                </div>
                <div class="column column_space"><pre><code>106        const vector<bool>& propagate_down,
107        const vector<Blob<Dtype>*>& bottom);
108    vector<shared_ptr<Blob<Dtype> > >& blobs() {
109      return blobs_;
110    }
111    const LayerParameter& layer_param() const { return layer_param_; }
</pre></code></div>
                <div class="column column_space"><pre><code>205    bool IsHost(const TStr& HostNm) const {
206      return NmToHostH.IsKey(HostNm);}
207    PCrawlerHost AddGetHost(const TStr& HostNm);
208    PCrawlerHost GetHost(const TStr& HostNm){
209      return NmToHostH.GetDat(HostNm);}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    