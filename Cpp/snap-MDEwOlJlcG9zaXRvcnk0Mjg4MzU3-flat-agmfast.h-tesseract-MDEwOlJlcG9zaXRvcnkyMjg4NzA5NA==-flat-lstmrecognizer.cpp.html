
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.476669716376944%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmfast.h</h3>
            <pre><code>1  #ifndef snap_agmfast_h
2  #define snap_agmfast_h
3  #include "Snap.h"
4  class TAGMFast { 
5  private:
6    PUNGraph G; 
7    TVec<TIntFltH> F; 
8    TRnd Rnd; 
9    TIntV NIDV; 
10    TFlt RegCoef; 
11    TFltV SumFV; 
12    TBool NodesOk; 
13    TInt NumComs; 
14  public:
15    TVec<TIntSet> HOVIDSV; 
16    TFlt MinVal; 
17    TFlt MaxVal; 
18    TFlt NegWgt; 
19    TFlt PNoCom; 
20    TBool DoParallel; 
21    TAGMFast(const PUNGraph& GraphPt, const int& InitComs, const int RndSeed = 0): Rnd(RndSeed), RegCoef(0), 
22      NodesOk(true), MinVal(0.0), MaxVal(1000.0), NegWgt(1.0) { SetGraph(GraphPt); RandomInit(InitComs); }
23    void SetGraph(const PUNGraph& GraphPt);
24    void SetRegCoef(const double _RegCoef) { RegCoef = _RegCoef; }
25    double GetRegCoef() { return RegCoef; }
26    void RandomInit(const int InitComs);
27    void NeighborComInit(const int InitComs);
28    void SetCmtyVV(const TVec<TIntV>& CmtyVV);
29    double Likelihood(const bool DoParallel = false);
30    double LikelihoodForRow(const int UID);
31    double LikelihoodForRow(const int UID, const TIntFltH& FU);
32    int MLENewton(const double& Thres, const int& MaxIter, const TStr& PlotNm = TStr());
33    void GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet);
34    double GradientForOneVar(const TFltV& AlphaKV, const int UID, const int CID, const double& Val);
35    double HessianForOneVar(const TFltV& AlphaKV, const int UID, const int CID, const double& Val);
36    double LikelihoodForOneVar(const TFltV& AlphaKV, const int UID, const int CID, const double& Val);
37    void GetCmtyVV(TVec<TIntV>& CmtyVV);
38    void GetCmtyVV(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
39    int FindComsByCV(TIntV& ComsV, const double HOFrac = 0.2, const int NumThreads = 20, const TStr& PlotLFNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1);
40    int FindComsByCV(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr& OutFNm, const double StepAlpha = 0.3, const double StepBeta = 0.3);
41    double LikelihoodHoldOut(const bool DoParallel = false);
42    double GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10);
43    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr& PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
44    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr& PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
45    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const TStr& PlotNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1) {
46      int ChunkSize = G->GetNodes() / 10 / ChunkNum;
47      if (ChunkSize == 0) { ChunkSize = 1; }
48      return MLEGradAscentParallel(Thres, MaxIter, ChunkNum, ChunkSize, PlotNm, StepAlpha, StepBeta);
49    }
50    void Save(TSOut& SOut);
51    void Load(TSIn& SIn, const int& RndSeed = 0);
52    double inline GetCom(const int& NID, const int& CID) {
53      if (F[NID].IsKey(CID)) {
54        return F[NID].GetDat(CID);
55      } else {
56        return 0.0;
57      }
58    }
59    void inline AddCom(const int& NID, const int& CID, const double& Val) {
60      if (F[NID].IsKey(CID)) {
61        SumFV[CID] -= F[NID].GetDat(CID);
62      }
63      F[NID].AddDat(CID) = Val;
64      SumFV[CID] += Val;
65    }
66    void inline DelCom(const int& NID, const int& CID) {
67      if (F[NID].IsKey(CID)) {
68        SumFV[CID] -= F[NID].GetDat(CID);
69        F[NID].DelKey(CID);
70      }
71    }
72    double inline DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
73      double DP = 0;
74      if (UV.Len() > VV.Len()) {
75        for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
76          if (VV.IsKey(HI.GetKey())) { 
77            DP += VV.GetDat(HI.GetKey()) * HI.GetDat(); 
78          }
79        }
80      } else {
81        for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
82          if (UV.IsKey(HI.GetKey())) { 
83            DP += UV.GetDat(HI.GetKey()) * HI.GetDat(); 
84          }
85        }
86      }
87      return DP;
88    }
89    double inline DotProduct(const int& UID, const int& VID) {
90      return DotProduct(F[UID], F[VID]);
91    }
92    double inline Prediction(const TIntFltH& FU, const TIntFltH& FV) {
93      double DP = log (1.0 / (1.0 - PNoCom)) + DotProduct(FU, FV);
94      IAssertR(DP > 0.0, TStr::Fmt("DP: %f", DP));
95      return exp(- DP);
96    }
97    double inline Prediction(const int& UID, const int& VID) {
98      return Prediction(F[UID], F[VID]);
99    }
100    double inline Sum(const TIntFltH& UV) {
101      double N = 0.0;
102      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
103        N += HI.GetDat();
104      }
105      return N;
106    }
107    double inline Norm2(const TIntFltH& UV) {
108      double N = 0.0;
109      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
110        N += HI.GetDat() * HI.GetDat();
111      }
112      return N;
113    }
114  };
115  class TAGMFastUtil {
116  public:
117  template<class PGraph>
118  static double GetConductance(const PGraph& Graph, const TIntSet& CmtyS, const int Edges) {
119    const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
120    int Edges2;
121    if (GraphType) { Edges2 = Edges >= 0 ? Edges : Graph->GetEdges(); }
122    else { Edges2 = Edges >= 0 ? 2 * Edges : Graph->GetEdges(); }
<span onclick='openModal()' class='match'>123    int Vol = 0,  Cut = 0; 
124    double Phi = 0.0;
125    for (int i = 0; i < CmtyS.Len(); i++) {
126      if (! Graph->IsNode(CmtyS[i])) { continue; }
</span>127      typename PGraph::TObj::TNodeI  NI = Graph->GetNI(CmtyS[i]);
128      for (int e = 0; e < NI.GetOutDeg(); e++) {
129        if (! CmtyS.IsKey(NI.GetOutNId(e))) { Cut += 1; }
130      }
131      Vol += NI.GetOutDeg();
132    }
133    if (Vol != Edges2) {
134      if (2 * Vol > Edges2) { Phi = Cut / double (Edges2 - Vol); }
135      else if (Vol == 0) { Phi = 0.0; }
136      else { Phi = Cut / double(Vol); }
137    } else {
138      if (Vol == Edges2) { Phi = 1.0; }
139    }
140    return Phi;
141  }
142  template<class PGraph>
143    static void GenHoldOutPairs(const PGraph& G, TVec<TIntSet>& HoldOutSet, double HOFrac, TRnd& Rnd)  {
144      TIntPrV EdgeV(G->GetEdges(), 0);
145      for (typename PGraph::TObj::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
146        EdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
147      }
148      EdgeV.Shuffle(Rnd);
149      const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
150      HoldOutSet.Gen(G->GetNodes());
151      int HOTotal = int(HOFrac * G->GetNodes() * (G->GetNodes() - 1) / 2.0);
152      if (GraphType) { HOTotal *= 2;}
153      int HOCnt = 0;
154      int HOEdges = (int) TMath::Round(HOFrac * G->GetEdges());
155      printf("holding out %d edges...\n", HOEdges);
156      for (int he = 0; he < (int) HOEdges; he++) {
157        HoldOutSet[EdgeV[he].Val1].AddKey(EdgeV[he].Val2);
158        if (! GraphType) { HoldOutSet[EdgeV[he].Val2].AddKey(EdgeV[he].Val1); }
159        HOCnt++;
160      }
161      printf("%d Edges hold out\n", HOCnt);
162      while(HOCnt++ < HOTotal) {
163        int SrcNID = Rnd.GetUniDevInt(G->GetNodes());
164        int DstNID = Rnd.GetUniDevInt(G->GetNodes());
165        if (SrcNID == DstNID) { continue; }
166        HoldOutSet[SrcNID].AddKey(DstNID);
167        if (! GraphType) { HoldOutSet[DstNID].AddKey(SrcNID); }
168      }
169    }
170  template<class PGraph>
171    static void GetNbhCom(const PGraph& Graph, const int NID, TIntSet& NBCmtyS) {
172      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NID);
173      NBCmtyS.Gen(NI.GetDeg());
174      NBCmtyS.AddKey(NID);
175      for (int e = 0; e < NI.GetDeg(); e++) {
176        NBCmtyS.AddKey(NI.GetNbrNId(e));
177      }
178    }
179  template<class PGraph>
180    static void GetNIdPhiV(const PGraph& G, TFltIntPrV& NIdPhiV) {
181      NIdPhiV.Gen(G->GetNodes(), 0);
182      const int Edges = G->GetEdges();
183      TExeTm RunTm;
184      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
185        TIntSet NBCmty(NI.GetDeg() + 1);
186        double Phi;
187        if (NI.GetDeg() < 5) { 
188          Phi = 1.0; 
189        } else {
190          TAGMFastUtil::GetNbhCom<PGraph>(G, NI.GetId(), NBCmty);
191          Phi = TAGMFastUtil::GetConductance(G, NBCmty, Edges);
192        }
193        NIdPhiV.Add(TFltIntPr(Phi, NI.GetId()));
194      }
195      printf("conductance computation completed [%s]\n", RunTm.GetTmStr());
196      fflush(stdout);
197    }
198  };
199  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lstmrecognizer.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "lstmrecognizer.h"
5  #include <allheaders.h>
6  #include "dict.h"
7  #include "genericheap.h"
8  #include "helpers.h"
9  #include "imagedata.h"
10  #include "input.h"
11  #include "lstm.h"
12  #include "normalis.h"
13  #include "pageres.h"
14  #include "ratngs.h"
15  #include "recodebeam.h"
16  #include "scrollview.h"
17  #include "statistc.h"
18  #include "tprintf.h"
19  #include <unordered_set>
20  #include <vector>
21  namespace tesseract {
22  const double kDictRatio = 2.25;
23  const double kCertOffset = -0.085;
24  LSTMRecognizer::LSTMRecognizer(const std::string &language_data_path_prefix)
25      : LSTMRecognizer::LSTMRecognizer() {
26    ccutil_.language_data_path_prefix = language_data_path_prefix;
27  }
28  LSTMRecognizer::LSTMRecognizer()
29      : network_(nullptr)
30      , training_flags_(0)
31      , training_iteration_(0)
32      , sample_iteration_(0)
33      , null_char_(UNICHAR_BROKEN)
34      , learning_rate_(0.0f)
35      , momentum_(0.0f)
36      , adam_beta_(0.0f)
37      , dict_(nullptr)
38      , search_(nullptr)
39      , debug_win_(nullptr) {}
40  LSTMRecognizer::~LSTMRecognizer() {
41    delete network_;
42    delete dict_;
43    delete search_;
44  }
45  bool LSTMRecognizer::Load(const ParamsVectors *params, const std::string &lang,
46                            TessdataManager *mgr) {
47    TFile fp;
48    if (!mgr->GetComponent(TESSDATA_LSTM, &fp)) {
49      return false;
50    }
51    if (!DeSerialize(mgr, &fp)) {
52      return false;
53    }
54    if (lang.empty()) {
55      return true;
56    }
57    LoadDictionary(params, lang, mgr);
58    return true;
59  }
60  bool LSTMRecognizer::Serialize(const TessdataManager *mgr, TFile *fp) const {
61    bool include_charsets = mgr == nullptr || !mgr->IsComponentAvailable(TESSDATA_LSTM_RECODER) ||
62                            !mgr->IsComponentAvailable(TESSDATA_LSTM_UNICHARSET);
63    if (!network_->Serialize(fp)) {
64      return false;
65    }
66    if (include_charsets && !GetUnicharset().save_to_file(fp)) {
67      return false;
68    }
69    if (!fp->Serialize(network_str_)) {
70      return false;
71    }
72    if (!fp->Serialize(&training_flags_)) {
73      return false;
74    }
75    if (!fp->Serialize(&training_iteration_)) {
76      return false;
77    }
78    if (!fp->Serialize(&sample_iteration_)) {
79      return false;
80    }
81    if (!fp->Serialize(&null_char_)) {
82      return false;
83    }
84    if (!fp->Serialize(&adam_beta_)) {
85      return false;
86    }
87    if (!fp->Serialize(&learning_rate_)) {
88      return false;
89    }
90    if (!fp->Serialize(&momentum_)) {
91      return false;
92    }
93    if (include_charsets && IsRecoding() && !recoder_.Serialize(fp)) {
94      return false;
95    }
96    return true;
97  }
98  bool LSTMRecognizer::DeSerialize(const TessdataManager *mgr, TFile *fp) {
99    delete network_;
100    network_ = Network::CreateFromFile(fp);
101    if (network_ == nullptr) {
102      return false;
103    }
104    bool include_charsets = mgr == nullptr || !mgr->IsComponentAvailable(TESSDATA_LSTM_RECODER) ||
105                            !mgr->IsComponentAvailable(TESSDATA_LSTM_UNICHARSET);
106    if (include_charsets && !ccutil_.unicharset.load_from_file(fp, false)) {
107      return false;
108    }
109    if (!fp->DeSerialize(network_str_)) {
110      return false;
111    }
112    if (!fp->DeSerialize(&training_flags_)) {
113      return false;
114    }
115    if (!fp->DeSerialize(&training_iteration_)) {
116      return false;
117    }
118    if (!fp->DeSerialize(&sample_iteration_)) {
119      return false;
120    }
121    if (!fp->DeSerialize(&null_char_)) {
122      return false;
123    }
124    if (!fp->DeSerialize(&adam_beta_)) {
125      return false;
126    }
127    if (!fp->DeSerialize(&learning_rate_)) {
128      return false;
129    }
130    if (!fp->DeSerialize(&momentum_)) {
131      return false;
132    }
133    if (include_charsets && !LoadRecoder(fp)) {
134      return false;
135    }
136    if (!include_charsets && !LoadCharsets(mgr)) {
137      return false;
138    }
139    network_->SetRandomizer(&randomizer_);
140    network_->CacheXScaleFactor(network_->XScaleFactor());
141    return true;
142  }
143  bool LSTMRecognizer::LoadCharsets(const TessdataManager *mgr) {
144    TFile fp;
145    if (!mgr->GetComponent(TESSDATA_LSTM_UNICHARSET, &fp)) {
146      return false;
147    }
148    if (!ccutil_.unicharset.load_from_file(&fp, false)) {
149      return false;
150    }
151    if (!mgr->GetComponent(TESSDATA_LSTM_RECODER, &fp)) {
152      return false;
153    }
154    if (!LoadRecoder(&fp)) {
155      return false;
156    }
157    return true;
158  }
159  bool LSTMRecognizer::LoadRecoder(TFile *fp) {
160    if (IsRecoding()) {
161      if (!recoder_.DeSerialize(fp)) {
162        return false;
163      }
164      RecodedCharID code;
165      recoder_.EncodeUnichar(UNICHAR_SPACE, &code);
166      if (code(0) != UNICHAR_SPACE) {
167        tprintf("Space was garbled in recoding!!\n");
168        return false;
169      }
170    } else {
171      recoder_.SetupPassThrough(GetUnicharset());
172      training_flags_ |= TF_COMPRESS_UNICHARSET;
173    }
174    return true;
175  }
176  bool LSTMRecognizer::LoadDictionary(const ParamsVectors *params, const std::string &lang,
177                                      TessdataManager *mgr) {
178    delete dict_;
179    dict_ = new Dict(&ccutil_);
180    dict_->user_words_file.ResetFrom(params);
181    dict_->user_words_suffix.ResetFrom(params);
182    dict_->user_patterns_file.ResetFrom(params);
183    dict_->user_patterns_suffix.ResetFrom(params);
184    dict_->SetupForLoad(Dict::GlobalDawgCache());
185    dict_->LoadLSTM(lang, mgr);
186    if (dict_->FinishLoad()) {
187      return true; 
188    }
189    if (log_level <= 0) {
190      tprintf("Failed to load any lstm-specific dictionaries for lang %s!!\n", lang.c_str());
191    }
192    delete dict_;
193    dict_ = nullptr;
194    return false;
195  }
196  void LSTMRecognizer::RecognizeLine(const ImageData &image_data,
197                                     float invert_threshold, bool debug,
198                                     double worst_dict_cert, const TBOX &line_box,
199                                     PointerVector<WERD_RES> *words, int lstm_choice_mode,
200                                     int lstm_choice_amount) {
201    NetworkIO outputs;
202    float scale_factor;
203    NetworkIO inputs;
204    if (!RecognizeLine(image_data, invert_threshold, debug, false, false, &scale_factor, &inputs, &outputs)) {
205      return;
206    }
207    if (search_ == nullptr) {
208      search_ = new RecodeBeamSearch(recoder_, null_char_, SimpleTextOutput(), dict_);
209    }
210    search_->excludedUnichars.clear();
211    search_->Decode(outputs, kDictRatio, kCertOffset, worst_dict_cert, &GetUnicharset(),
212                    lstm_choice_mode);
213    search_->ExtractBestPathAsWords(line_box, scale_factor, debug, &GetUnicharset(), words,
214                                    lstm_choice_mode);
215    if (lstm_choice_mode) {
216      search_->extractSymbolChoices(&GetUnicharset());
217      for (int i = 0; i < lstm_choice_amount; ++i) {
218        search_->DecodeSecondaryBeams(outputs, kDictRatio, kCertOffset, worst_dict_cert,
219                                      &GetUnicharset(), lstm_choice_mode);
220        search_->extractSymbolChoices(&GetUnicharset());
221      }
222      search_->segmentTimestepsByCharacters();
223      unsigned char_it = 0;
224      for (size_t i = 0; i < words->size(); ++i) {
225        for (int j = 0; j < words->at(i)->end; ++j) {
226          if (char_it < search_->ctc_choices.size()) {
227            words->at(i)->CTC_symbol_choices.push_back(search_->ctc_choices[char_it]);
228          }
229          if (char_it < search_->segmentedTimesteps.size()) {
230            words->at(i)->segmented_timesteps.push_back(search_->segmentedTimesteps[char_it]);
231          }
232          ++char_it;
233        }
234        words->at(i)->timesteps =
235            search_->combineSegmentedTimesteps(&words->at(i)->segmented_timesteps);
236      }
237      search_->segmentedTimesteps.clear();
238      search_->ctc_choices.clear();
239      search_->excludedUnichars.clear();
240    }
241  }
242  void LSTMRecognizer::OutputStats(const NetworkIO &outputs, float *min_output, float *mean_output,
243                                   float *sd) {
244    const int kOutputScale = INT8_MAX;
245    STATS stats(0, kOutputScale);
246    for (int t = 0; t < outputs.Width(); ++t) {
247      int best_label = outputs.BestLabel(t, nullptr);
248      if (best_label != null_char_) {
249        float best_output = outputs.f(t)[best_label];
250        stats.add(static_cast<int>(kOutputScale * best_output), 1);
251      }
252    }
253    if (stats.get_total() == 0) {
254      *min_output = 0.0f;
255      *mean_output = 0.0f;
256      *sd = 1.0f;
257    } else {
258      *min_output = static_cast<float>(stats.min_bucket()) / kOutputScale;
259      *mean_output = stats.mean() / kOutputScale;
260      *sd = stats.sd() / kOutputScale;
261    }
262  }
263  bool LSTMRecognizer::RecognizeLine(const ImageData &image_data,
264                                     float invert_threshold, bool debug,
265                                     bool re_invert, bool upside_down, float *scale_factor,
266                                     NetworkIO *inputs, NetworkIO *outputs) {
267    SetRandomSeed();
268    int min_width = network_->XScaleFactor();
269    Image pix = Input::PrepareLSTMInputs(image_data, network_, min_width, &randomizer_, scale_factor);
270    if (pix == nullptr) {
271      tprintf("Line cannot be recognized!!\n");
272      return false;
273    }
274    const int kMaxImageWidth = 128 * pixGetHeight(pix);
275    if (network_->IsTraining() && pixGetWidth(pix) > kMaxImageWidth) {
276      tprintf("Image too large to learn!! Size = %dx%d\n", pixGetWidth(pix), pixGetHeight(pix));
277      pix.destroy();
278      return false;
279    }
280    if (upside_down) {
281      pixRotate180(pix, pix);
282    }
283    *scale_factor = min_width / *scale_factor;
284    inputs->set_int_mode(IsIntMode());
285    SetRandomSeed();
286    Input::PreparePixInput(network_->InputShape(), pix, &randomizer_, inputs);
287    network_->Forward(debug, *inputs, nullptr, &scratch_space_, outputs);
288    if (invert_threshold > 0.0f) {
289      float pos_min, pos_mean, pos_sd;
290      OutputStats(*outputs, &pos_min, &pos_mean, &pos_sd);
291      if (pos_mean < invert_threshold) {
292        NetworkIO inv_inputs, inv_outputs;
293        inv_inputs.set_int_mode(IsIntMode());
294        SetRandomSeed();
295        pixInvert(pix, pix);
296        Input::PreparePixInput(network_->InputShape(), pix, &randomizer_, &inv_inputs);
297        network_->Forward(debug, inv_inputs, nullptr, &scratch_space_, &inv_outputs);
298        float inv_min, inv_mean, inv_sd;
299        OutputStats(inv_outputs, &inv_min, &inv_mean, &inv_sd);
300        if (inv_mean > pos_mean) {
301          if (debug) {
302            tprintf("Inverting image: old min=%g, mean=%g, sd=%g, inv %g,%g,%g\n", pos_min, pos_mean,
303                    pos_sd, inv_min, inv_mean, inv_sd);
304          }
305          *outputs = inv_outputs;
306          *inputs = inv_inputs;
307        } else if (re_invert) {
308          SetRandomSeed();
309          network_->Forward(debug, *inputs, nullptr, &scratch_space_, outputs);
310        }
311      }
312    }
313    pix.destroy();
314    if (debug) {
315      std::vector<int> labels, coords;
316      LabelsFromOutputs(*outputs, &labels, &coords);
317  #ifndef GRAPHICS_DISABLED
318      DisplayForward(*inputs, labels, coords, "LSTMForward", &debug_win_);
319  #endif
320      DebugActivationPath(*outputs, labels, coords);
321    }
322    return true;
323  }
324  std::string LSTMRecognizer::DecodeLabels(const std::vector<int> &labels) {
325    std::string result;
326    unsigned end = 1;
327    for (unsigned start = 0; start < labels.size(); start = end) {
328      if (labels[start] == null_char_) {
329        end = start + 1;
330      } else {
331        result += DecodeLabel(labels, start, &end, nullptr);
332      }
333    }
334    return result;
335  }
336  #ifndef GRAPHICS_DISABLED
337  void LSTMRecognizer::DisplayForward(const NetworkIO &inputs, const std::vector<int> &labels,
338                                      const std::vector<int> &label_coords, const char *window_name,
339                                      ScrollView **window) {
340    Image input_pix = inputs.ToPix();
341    Network::ClearWindow(false, window_name, pixGetWidth(input_pix), pixGetHeight(input_pix), window);
342    int line_height = Network::DisplayImage(input_pix, *window);
343    DisplayLSTMOutput(labels, label_coords, line_height, *window);
344  }
345  void LSTMRecognizer::DisplayLSTMOutput(const std::vector<int> &labels,
346                                         const std::vector<int> &xcoords, int height,
347                                         ScrollView *window) {
348    int x_scale = network_->XScaleFactor();
349    window->TextAttributes("Arial", height / 4, false, false, false);
350    unsigned end = 1;
351    for (unsigned start = 0; start < labels.size(); start = end) {
352      int xpos = xcoords[start] * x_scale;
353      if (labels[start] == null_char_) {
354        end = start + 1;
355        window->Pen(ScrollView::RED);
356      } else {
357        window->Pen(ScrollView::GREEN);
358        const char *str = DecodeLabel(labels, start, &end, nullptr);
359        if (*str == '\\') {
360          str = "\\\\";
361        }
362        xpos = xcoords[(start + end) / 2] * x_scale;
363        window->Text(xpos, height, str);
364      }
365      window->Line(xpos, 0, xpos, height * 3 / 2);
366    }
367    window->Update();
368  }
369  #endif 
370  void LSTMRecognizer::DebugActivationPath(const NetworkIO &outputs, const std::vector<int> &labels,
371                                           const std::vector<int> &xcoords) {
372    if (xcoords[0] > 0) {
373      DebugActivationRange(outputs, "<null>", null_char_, 0, xcoords[0]);
374    }
375    unsigned end = 1;
376    for (unsigned start = 0; start < labels.size(); start = end) {
377      if (labels[start] == null_char_) {
378        end = start + 1;
379        DebugActivationRange(outputs, "<null>", null_char_, xcoords[start], xcoords[end]);
380        continue;
381      } else {
382        int decoded;
383        const char *label = DecodeLabel(labels, start, &end, &decoded);
384        DebugActivationRange(outputs, label, labels[start], xcoords[start], xcoords[start + 1]);
385        for (unsigned i = start + 1; i < end; ++i) {
386          DebugActivationRange(outputs, DecodeSingleLabel(labels[i]), labels[i], xcoords[i],
387                               xcoords[i + 1]);
388        }
389      }
390    }
391  }
392  void LSTMRecognizer::DebugActivationRange(const NetworkIO &outputs, const char *label,
393                                            int best_choice, int x_start, int x_end) {
394    tprintf("%s=%d On [%d, %d), scores=", label, best_choice, x_start, x_end);
395    double max_score = 0.0;
396    double mean_score = 0.0;
397    const int width = x_end - x_start;
398    for (int x = x_start; x < x_end; ++x) {
399      const float *line = outputs.f(x);
400      const double score = line[best_choice] * 100.0;
401      if (score > max_score) {
402        max_score = score;
403      }
404      mean_score += score / width;
<span onclick='openModal()' class='match'>405      int best_c = 0;
406      double best_score = 0.0;
407      for (int c = 0; c < outputs.NumFeatures(); ++c) {
408        if (c != best_choice && line[c] > best_score) {
</span>409          best_c = c;
410          best_score = line[c];
411        }
412      }
413      tprintf(" %.3g(%s=%d=%.3g)", score, DecodeSingleLabel(best_c), best_c, best_score * 100.0);
414    }
415    tprintf(", Mean=%g, max=%g\n", mean_score, max_score);
416  }
417  #if 0 
418  static bool NullIsBest(const NetworkIO& output, float null_thr,
419                         int null_char, int t) {
420    if (output.f(t)[null_char] >= null_thr) return true;
421    if (output.BestLabel(t, null_char, null_char, nullptr) != UNICHAR_SPACE)
422      return false;
423    return output.f(t)[null_char] > output.f(t)[UNICHAR_SPACE];
424  }
425  #endif
426  void LSTMRecognizer::LabelsFromOutputs(const NetworkIO &outputs, std::vector<int> *labels,
427                                         std::vector<int> *xcoords) {
428    if (SimpleTextOutput()) {
429      LabelsViaSimpleText(outputs, labels, xcoords);
430    } else {
431      LabelsViaReEncode(outputs, labels, xcoords);
432    }
433  }
434  void LSTMRecognizer::LabelsViaReEncode(const NetworkIO &output, std::vector<int> *labels,
435                                         std::vector<int> *xcoords) {
436    if (search_ == nullptr) {
437      search_ = new RecodeBeamSearch(recoder_, null_char_, SimpleTextOutput(), dict_);
438    }
439    search_->Decode(output, 1.0, 0.0, RecodeBeamSearch::kMinCertainty, nullptr);
440    search_->ExtractBestPathAsLabels(labels, xcoords);
441  }
442  void LSTMRecognizer::LabelsViaSimpleText(const NetworkIO &output, std::vector<int> *labels,
443                                           std::vector<int> *xcoords) {
444    labels->clear();
445    xcoords->clear();
446    const int width = output.Width();
447    for (int t = 0; t < width; ++t) {
448      float score = 0.0f;
449      const int label = output.BestLabel(t, &score);
450      if (label != null_char_) {
451        labels->push_back(label);
452        xcoords->push_back(t);
453      }
454    }
455    xcoords->push_back(width);
456  }
457  const char *LSTMRecognizer::DecodeLabel(const std::vector<int> &labels, unsigned start, unsigned *end,
458                                          int *decoded) {
459    *end = start + 1;
460    if (IsRecoding()) {
461      RecodedCharID code;
462      if (labels[start] == null_char_) {
463        if (decoded != nullptr) {
464          code.Set(0, null_char_);
465          *decoded = recoder_.DecodeUnichar(code);
466        }
467        return "<null>";
468      }
469      unsigned index = start;
470      while (index < labels.size() && code.length() < RecodedCharID::kMaxCodeLen) {
471        code.Set(code.length(), labels[index++]);
472        while (index < labels.size() && labels[index] == null_char_) {
473          ++index;
474        }
475        int uni_id = recoder_.DecodeUnichar(code);
476        if (uni_id != INVALID_UNICHAR_ID &&
477            (index == labels.size() || code.length() == RecodedCharID::kMaxCodeLen ||
478             recoder_.IsValidFirstCode(labels[index]))) {
479          *end = index;
480          if (decoded != nullptr) {
481            *decoded = uni_id;
482          }
483          if (uni_id == UNICHAR_SPACE) {
484            return " ";
485          }
486          return GetUnicharset().get_normed_unichar(uni_id);
487        }
488      }
489      return "<Undecodable>";
490    } else {
491      if (decoded != nullptr) {
492        *decoded = labels[start];
493      }
494      if (labels[start] == null_char_) {
495        return "<null>";
496      }
497      if (labels[start] == UNICHAR_SPACE) {
498        return " ";
499      }
500      return GetUnicharset().get_normed_unichar(labels[start]);
501    }
502  }
503  const char *LSTMRecognizer::DecodeSingleLabel(int label) {
504    if (label == null_char_) {
505      return "<null>";
506    }
507    if (IsRecoding()) {
508      RecodedCharID code;
509      code.Set(0, label);
510      label = recoder_.DecodeUnichar(code);
511      if (label == INVALID_UNICHAR_ID) {
512        return ".."; 
513      }
514    }
515    if (label == UNICHAR_SPACE) {
516      return " ";
517    }
518    return GetUnicharset().get_normed_unichar(label);
519  }
520  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmfast.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lstmrecognizer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>123    int Vol = 0,  Cut = 0; 
124    double Phi = 0.0;
125    for (int i = 0; i < CmtyS.Len(); i++) {
126      if (! Graph->IsNode(CmtyS[i])) { continue; }
</pre></code></div>
                <div class="column column_space"><pre><code>405      int best_c = 0;
406      double best_score = 0.0;
407      for (int c = 0; c < outputs.NumFeatures(); ++c) {
408        if (c != best_choice && line[c] > best_score) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    