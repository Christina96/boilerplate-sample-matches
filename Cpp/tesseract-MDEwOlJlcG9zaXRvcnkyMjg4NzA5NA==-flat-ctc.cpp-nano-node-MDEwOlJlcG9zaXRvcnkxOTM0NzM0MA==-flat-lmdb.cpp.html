
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4390243902439024%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ctc.cpp</h3>
            <pre><code>1  #include "ctc.h"
2  #include "matrix.h"
3  #include "network.h"
4  #include "networkio.h"
5  #include "scrollview.h"
6  #include <algorithm>
7  #include <cfloat> 
8  #include <cmath>
9  #include <memory>
10  namespace tesseract {
11  const float CTC::kMinProb_ = 1e-12;
12  const double CTC::kMaxExpArg_ = 80.0;
13  const double CTC::kMinTotalTimeProb_ = 1e-8;
14  const double CTC::kMinTotalFinalProb_ = 1e-6;
15  bool CTC::ComputeCTCTargets(const std::vector<int> &labels, int null_char,
16                              const GENERIC_2D_ARRAY<float> &outputs, NetworkIO *targets) {
17    std::unique_ptr<CTC> ctc(new CTC(labels, null_char, outputs));
18    if (!ctc->ComputeLabelLimits()) {
19      return false; 
20    }
21    GENERIC_2D_ARRAY<float> simple_targets;
22    ctc->ComputeSimpleTargets(&simple_targets);
23    float bias_fraction = ctc->CalculateBiasFraction();
24    simple_targets *= bias_fraction;
25    ctc->outputs_ += simple_targets;
26    NormalizeProbs(&ctc->outputs_);
27    GENERIC_2D_ARRAY<double> log_alphas, log_betas;
28    ctc->Forward(&log_alphas);
29    ctc->Backward(&log_betas);
30    log_alphas += log_betas;
31    ctc->NormalizeSequence(&log_alphas);
32    ctc->LabelsToClasses(log_alphas, targets);
33    NormalizeProbs(targets);
34    return true;
35  }
36  CTC::CTC(const std::vector<int> &labels, int null_char, const GENERIC_2D_ARRAY<float> &outputs)
37      : labels_(labels), outputs_(outputs), null_char_(null_char) {
38    num_timesteps_ = outputs.dim1();
39    num_classes_ = outputs.dim2();
40    num_labels_ = labels_.size();
41  }
42  bool CTC::ComputeLabelLimits() {
43    min_labels_.clear();
44    min_labels_.resize(num_timesteps_, 0);
45    max_labels_.clear();
46    max_labels_.resize(num_timesteps_, 0);
47    int min_u = num_labels_ - 1;
48    if (labels_[min_u] == null_char_) {
49      --min_u;
50    }
51    for (int t = num_timesteps_ - 1; t >= 0; --t) {
52      min_labels_[t] = min_u;
53      if (min_u > 0) {
54        --min_u;
55        if (labels_[min_u] == null_char_ && min_u > 0 && labels_[min_u + 1] != labels_[min_u - 1]) {
56          --min_u;
57        }
58      }
59    }
60    int max_u = labels_[0] == null_char_;
61    for (int t = 0; t < num_timesteps_; ++t) {
62      max_labels_[t] = max_u;
63      if (max_labels_[t] < min_labels_[t]) {
64        return false; 
65      }
66      if (max_u + 1 < num_labels_) {
67        ++max_u;
68        if (labels_[max_u] == null_char_ && max_u + 1 < num_labels_ &&
69            labels_[max_u + 1] != labels_[max_u - 1]) {
70          ++max_u;
71        }
72      }
73    }
74    return true;
75  }
76  void CTC::ComputeSimpleTargets(GENERIC_2D_ARRAY<float> *targets) const {
77    targets->Resize(num_timesteps_, num_classes_, 0.0f);
78    std::vector<float> half_widths;
79    std::vector<int> means;
80    ComputeWidthsAndMeans(&half_widths, &means);
81    for (int l = 0; l < num_labels_; ++l) {
82      int label = labels_[l];
83      float left_half_width = half_widths[l];
84      float right_half_width = left_half_width;
85      int mean = means[l];
86      if (label == null_char_) {
87        if (!NeededNull(l)) {
88          if ((l > 0 && mean == means[l - 1]) || (l + 1 < num_labels_ && mean == means[l + 1])) {
89            continue; 
90          }
91        }
92        if (l > 0) {
93          left_half_width = mean - means[l - 1];
94        }
95        if (l + 1 < num_labels_) {
96          right_half_width = means[l + 1] - mean;
97        }
98      }
99      if (mean >= 0 && mean < num_timesteps_) {
100        targets->put(mean, label, 1.0f);
101      }
102      for (int offset = 1; offset < left_half_width && mean >= offset; ++offset) {
103        float prob = 1.0f - offset / left_half_width;
104        if (mean - offset < num_timesteps_ && prob > targets->get(mean - offset, label)) {
105          targets->put(mean - offset, label, prob);
106        }
107      }
108      for (int offset = 1; offset < right_half_width && mean + offset < num_timesteps_; ++offset) {
109        float prob = 1.0f - offset / right_half_width;
110        if (mean + offset >= 0 && prob > targets->get(mean + offset, label)) {
111          targets->put(mean + offset, label, prob);
112        }
113      }
114    }
115  }
116  void CTC::ComputeWidthsAndMeans(std::vector<float> *half_widths, std::vector<int> *means) const {
117    int num_plus = 0, num_star = 0;
118    for (int i = 0; i < num_labels_; ++i) {
119      if (labels_[i] != null_char_ || NeededNull(i)) {
120        ++num_plus;
121      } else {
122        ++num_star;
123      }
124    }
125    float plus_size = 1.0f, star_size = 0.0f;
126    float total_floating = num_plus + num_star;
127    if (total_floating <= num_timesteps_) {
128      plus_size = star_size = num_timesteps_ / total_floating;
129    } else if (num_star > 0) {
130      star_size = static_cast<float>(num_timesteps_ - num_plus) / num_star;
131    }
132    float mean_pos = 0.0f;
133    for (int i = 0; i < num_labels_; ++i) {
134      float half_width;
135      if (labels_[i] != null_char_ || NeededNull(i)) {
136        half_width = plus_size / 2.0f;
137      } else {
138        half_width = star_size / 2.0f;
139      }
140      mean_pos += half_width;
141      means->push_back(static_cast<int>(mean_pos));
142      mean_pos += half_width;
143      half_widths->push_back(half_width);
144    }
145  }
146  static int BestLabel(const GENERIC_2D_ARRAY<float> &outputs, int t) {
147    int result = 0;
148    int num_classes = outputs.dim2();
149    const float *outputs_t = outputs[t];
150    for (int c = 1; c < num_classes; ++c) {
151      if (outputs_t[c] > outputs_t[result]) {
152        result = c;
153      }
154    }
155    return result;
156  }
157  float CTC::CalculateBiasFraction() {
158    std::vector<int> output_labels;
159    for (int t = 0; t < num_timesteps_; ++t) {
160      int label = BestLabel(outputs_, t);
161      while (t + 1 < num_timesteps_ && BestLabel(outputs_, t + 1) == label) {
162        ++t;
163      }
164      if (label != null_char_) {
165        output_labels.push_back(label);
166      }
167    }
168    std::vector<int> truth_counts(num_classes_);
169    std::vector<int> output_counts(num_classes_);
170    for (int l = 0; l < num_labels_; ++l) {
171      ++truth_counts[labels_[l]];
172    }
173    for (auto l : output_labels) {
174      ++output_counts[l];
175    }
176    int true_pos = 0, false_pos = 0, total_labels = 0;
177    for (int c = 0; c < num_classes_; ++c) {
178      if (c == null_char_) {
179        continue;
180      }
181      int truth_count = truth_counts[c];
182      int ocr_count = output_counts[c];
183      if (truth_count > 0) {
184        total_labels += truth_count;
185        if (ocr_count > truth_count) {
186          true_pos += truth_count;
187          false_pos += ocr_count - truth_count;
188        } else {
189          true_pos += ocr_count;
190        }
191      }
192    }
193    if (total_labels == 0) {
194      return 0.0f;
195    }
196    return exp(std::max(true_pos - false_pos, 1) * std::log(kMinProb_) / total_labels);
197  }
198  static double LogSumExp(double ln_x, double ln_y) {
199    if (ln_x >= ln_y) {
200      return ln_x + log1p(exp(ln_y - ln_x));
201    } else {
202      return ln_y + log1p(exp(ln_x - ln_y));
203    }
204  }
205  void CTC::Forward(GENERIC_2D_ARRAY<double> *log_probs) const {
206    log_probs->Resize(num_timesteps_, num_labels_, -FLT_MAX);
207    log_probs->put(0, 0, log(outputs_(0, labels_[0])));
208    if (labels_[0] == null_char_) {
209      log_probs->put(0, 1, log(outputs_(0, labels_[1])));
210    }
211    for (int t = 1; t < num_timesteps_; ++t) {
212      const float *outputs_t = outputs_[t];
213      for (int u = min_labels_[t]; u <= max_labels_[t]; ++u) {
<span onclick='openModal()' class='match'>214        double log_sum = log_probs->get(t - 1, u);
215        if (u > 0) {
216          log_sum = LogSumExp(log_sum, log_probs->get(t - 1, u - 1));
217        }
218        if (u >= 2 && labels_[u - 1] == null_char_ && labels_[u] != labels_[u - 2]) {
219          log_sum = LogSumExp(log_sum, log_probs->get(t - 1, u - 2));
220        }
</span>221        double label_prob = outputs_t[labels_[u]];
222        log_sum += log(label_prob);
223        log_probs->put(t, u, log_sum);
224      }
225    }
226  }
227  void CTC::Backward(GENERIC_2D_ARRAY<double> *log_probs) const {
228    log_probs->Resize(num_timesteps_, num_labels_, -FLT_MAX);
229    log_probs->put(num_timesteps_ - 1, num_labels_ - 1, 0.0);
230    if (labels_[num_labels_ - 1] == null_char_) {
231      log_probs->put(num_timesteps_ - 1, num_labels_ - 2, 0.0);
232    }
233    for (int t = num_timesteps_ - 2; t >= 0; --t) {
234      const float *outputs_tp1 = outputs_[t + 1];
235      for (int u = min_labels_[t]; u <= max_labels_[t]; ++u) {
236        double log_sum = log_probs->get(t + 1, u) + std::log(outputs_tp1[labels_[u]]);
237        if (u + 1 < num_labels_) {
238          double prev_prob = outputs_tp1[labels_[u + 1]];
239          log_sum = LogSumExp(log_sum, log_probs->get(t + 1, u + 1) + log(prev_prob));
240        }
241        if (u + 2 < num_labels_ && labels_[u + 1] == null_char_ && labels_[u] != labels_[u + 2]) {
242          double skip_prob = outputs_tp1[labels_[u + 2]];
243          log_sum = LogSumExp(log_sum, log_probs->get(t + 1, u + 2) + log(skip_prob));
244        }
245        log_probs->put(t, u, log_sum);
246      }
247    }
248  }
249  void CTC::NormalizeSequence(GENERIC_2D_ARRAY<double> *probs) const {
250    double max_logprob = probs->Max();
251    for (int u = 0; u < num_labels_; ++u) {
252      double total = 0.0;
253      for (int t = 0; t < num_timesteps_; ++t) {
254        double prob = probs->get(t, u);
255        if (prob > -FLT_MAX) {
256          prob = ClippedExp(prob - max_logprob);
257        } else {
258          prob = 0.0;
259        }
260        total += prob;
261        probs->put(t, u, prob);
262      }
263      if (total < kMinTotalTimeProb_) {
264        total = kMinTotalTimeProb_;
265      }
266      for (int t = 0; t < num_timesteps_; ++t) {
267        probs->put(t, u, probs->get(t, u) / total);
268      }
269    }
270  }
271  void CTC::LabelsToClasses(const GENERIC_2D_ARRAY<double> &probs, NetworkIO *targets) const {
272    for (int t = 0; t < num_timesteps_; ++t) {
273      float *targets_t = targets->f(t);
274      std::vector<double> class_probs(num_classes_);
275      for (int u = 0; u < num_labels_; ++u) {
276        double prob = probs(t, u);
277        if (prob > class_probs[labels_[u]]) {
278          class_probs[labels_[u]] = prob;
279        }
280      }
281      int best_class = 0;
282      for (int c = 0; c < num_classes_; ++c) {
283        targets_t[c] = class_probs[c];
284        if (class_probs[c] > class_probs[best_class]) {
285          best_class = c;
286        }
287      }
288    }
289  }
290  void CTC::NormalizeProbs(GENERIC_2D_ARRAY<float> *probs) {
291    int num_timesteps = probs->dim1();
292    int num_classes = probs->dim2();
293    for (int t = 0; t < num_timesteps; ++t) {
294      float *probs_t = (*probs)[t];
295      double total = 0.0;
296      for (int c = 0; c < num_classes; ++c) {
297        total += probs_t[c];
298      }
299      if (total < kMinTotalFinalProb_) {
300        total = kMinTotalFinalProb_;
301      }
302      double increment = 0.0;
303      for (int c = 0; c < num_classes; ++c) {
304        double prob = probs_t[c] / total;
305        if (prob < kMinProb_) {
306          increment += kMinProb_ - prob;
307        }
308      }
309      total += increment;
310      for (int c = 0; c < num_classes; ++c) {
311        float prob = probs_t[c] / total;
312        probs_t[c] = std::max(prob, kMinProb_);
313      }
314    }
315  }
316  bool CTC::NeededNull(int index) const {
317    return labels_[index] == null_char_ && index > 0 && index + 1 < num_labels_ &&
318           labels_[index + 1] == labels_[index - 1];
319  }
320  } 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-lmdb.cpp</h3>
            <pre><code>1  #include <nano/lib/utility.hpp>
2  #include <nano/node/common.hpp>
3  #include <nano/node/lmdb/lmdb.hpp>
4  #include <nano/node/lmdb/lmdb_iterator.hpp>
5  #include <nano/node/lmdb/wallet_value.hpp>
6  #include <nano/secure/buffer.hpp>
7  #include <nano/secure/versioning.hpp>
8  #include <boost/filesystem.hpp>
9  #include <boost/format.hpp>
10  #include <queue>
11  namespace nano
12  {
13  template <>
14  void * mdb_val::data () const
15  {
16  	return value.mv_data;
17  }
18  template <>
19  std::size_t mdb_val::size () const
20  {
21  	return value.mv_size;
22  }
23  template <>
24  mdb_val::db_val (std::size_t size_a, void * data_a) :
25  	value ({ size_a, data_a })
26  {
27  }
28  template <>
29  void mdb_val::convert_buffer_to_value ()
30  {
31  	value = { buffer->size (), const_cast<uint8_t *> (buffer->data ()) };
32  }
33  }
34  nano::lmdb::store::store (nano::logger_mt & logger_a, boost::filesystem::path const & path_a, nano::ledger_constants & constants, nano::txn_tracking_config const & txn_tracking_config_a, std::chrono::milliseconds block_processor_batch_max_time_a, nano::lmdb_config const & lmdb_config_a, bool backup_before_upgrade_a) :
35  	nano::store{
36  		block_store,
37  		frontier_store,
38  		account_store,
39  		pending_store,
40  		online_weight_store,
41  		pruned_store,
42  		peer_store,
43  		confirmation_height_store,
44  		final_vote_store,
45  		version_store
46  	},
47  	block_store{ *this },
48  	frontier_store{ *this },
49  	account_store{ *this },
50  	pending_store{ *this },
51  	online_weight_store{ *this },
52  	pruned_store{ *this },
53  	peer_store{ *this },
54  	confirmation_height_store{ *this },
55  	final_vote_store{ *this },
56  	version_store{ *this },
57  	logger (logger_a),
58  	env (error, path_a, nano::mdb_env::options::make ().set_config (lmdb_config_a).set_use_no_mem_init (true)),
59  	mdb_txn_tracker (logger_a, txn_tracking_config_a, block_processor_batch_max_time_a),
60  	txn_tracking_enabled (txn_tracking_config_a.enable)
61  {
62  	if (!error)
63  	{
64  		auto is_fully_upgraded (false);
65  		auto is_fresh_db (false);
66  		{
67  			auto transaction (tx_begin_read ());
68  			auto err = mdb_dbi_open (env.tx (transaction), "meta", 0, &block_store.meta_handle);
69  			is_fresh_db = err != MDB_SUCCESS;
70  			if (err == MDB_SUCCESS)
71  			{
72  				is_fully_upgraded = (version.get (transaction) == version_current);
73  				mdb_dbi_close (env, block_store.meta_handle);
74  			}
75  		}
76  		if (!is_fully_upgraded)
77  		{
78  			if (!is_fresh_db)
79  			{
80  				logger.always_log ("Upgrade in progress...");
81  				if (backup_before_upgrade_a)
82  				{
83  					create_backup_file (env, path_a, logger_a);
84  				}
85  			}
86  			auto needs_vacuuming = false;
87  			{
88  				auto transaction (tx_begin_write ());
89  				open_databases (error, transaction, MDB_CREATE);
90  				if (!error)
91  				{
92  					error |= do_upgrades (transaction, constants, needs_vacuuming);
93  				}
94  			}
95  			if (needs_vacuuming)
96  			{
97  				logger.always_log ("Preparing vacuum...");
98  				auto vacuum_success = vacuum_after_upgrade (path_a, lmdb_config_a);
99  				logger.always_log (vacuum_success ? "Vacuum succeeded." : "Failed to vacuum. (Optional) Ensure enough disk space is available for a copy of the database and try to vacuum after shutting down the node");
100  			}
101  		}
102  		else
103  		{
104  			auto transaction (tx_begin_read ());
105  			open_databases (error, transaction, 0);
106  		}
107  	}
108  }
109  bool nano::lmdb::store::vacuum_after_upgrade (boost::filesystem::path const & path_a, nano::lmdb_config const & lmdb_config_a)
110  {
111  	auto vacuum_path = path_a.parent_path () / "vacuumed.ldb";
112  	auto vacuum_success = copy_db (vacuum_path);
113  	if (vacuum_success)
114  	{
115  		mdb_env_sync (env.environment, true);
116  		mdb_env_close (env.environment);
117  		env.environment = nullptr;
118  		boost::filesystem::rename (vacuum_path, path_a);
119  		auto options = nano::mdb_env::options::make ()
120  					   .set_config (lmdb_config_a)
121  					   .set_use_no_mem_init (true);
122  		env.init (error, path_a, options);
123  		if (!error)
124  		{
125  			auto transaction (tx_begin_read ());
126  			open_databases (error, transaction, 0);
127  		}
128  	}
129  	else
130  	{
131  		boost::filesystem::remove (vacuum_path);
132  	}
133  	return vacuum_success;
134  }
135  void nano::lmdb::store::serialize_mdb_tracker (boost::property_tree::ptree & json, std::chrono::milliseconds min_read_time, std::chrono::milliseconds min_write_time)
136  {
137  	mdb_txn_tracker.serialize_json (json, min_read_time, min_write_time);
138  }
139  void nano::lmdb::store::serialize_memory_stats (boost::property_tree::ptree & json)
140  {
141  	MDB_stat stats;
142  	auto status (mdb_env_stat (env.environment, &stats));
143  	release_assert (status == 0);
144  	json.put ("branch_pages", stats.ms_branch_pages);
145  	json.put ("depth", stats.ms_depth);
146  	json.put ("entries", stats.ms_entries);
147  	json.put ("leaf_pages", stats.ms_leaf_pages);
148  	json.put ("overflow_pages", stats.ms_overflow_pages);
149  	json.put ("page_size", stats.ms_psize);
150  }
151  nano::write_transaction nano::lmdb::store::tx_begin_write (std::vector<nano::tables> const &, std::vector<nano::tables> const &)
152  {
153  	return env.tx_begin_write (create_txn_callbacks ());
154  }
155  nano::read_transaction nano::lmdb::store::tx_begin_read () const
156  {
157  	return env.tx_begin_read (create_txn_callbacks ());
158  }
159  std::string nano::lmdb::store::vendor_get () const
160  {
161  	return boost::str (boost::format ("LMDB %1%.%2%.%3%") % MDB_VERSION_MAJOR % MDB_VERSION_MINOR % MDB_VERSION_PATCH);
162  }
163  nano::mdb_txn_callbacks nano::lmdb::store::create_txn_callbacks () const
164  {
165  	nano::mdb_txn_callbacks mdb_txn_callbacks;
166  	if (txn_tracking_enabled)
167  	{
168  		mdb_txn_callbacks.txn_start = ([&mdb_txn_tracker = mdb_txn_tracker] (nano::transaction_impl const * transaction_impl) {
169  			mdb_txn_tracker.add (transaction_impl);
170  		});
171  		mdb_txn_callbacks.txn_end = ([&mdb_txn_tracker = mdb_txn_tracker] (nano::transaction_impl const * transaction_impl) {
172  			mdb_txn_tracker.erase (transaction_impl);
173  		});
174  	}
175  	return mdb_txn_callbacks;
176  }
177  void nano::lmdb::store::open_databases (bool & error_a, nano::transaction const & transaction_a, unsigned flags)
178  {
179  	error_a |= mdb_dbi_open (env.tx (transaction_a), "frontiers", flags, &frontier_store.frontiers_handle) != 0;
180  	error_a |= mdb_dbi_open (env.tx (transaction_a), "online_weight", flags, &online_weight_store.online_weight_handle) != 0;
181  	error_a |= mdb_dbi_open (env.tx (transaction_a), "meta", flags, &block_store.meta_handle) != 0;
182  	error_a |= mdb_dbi_open (env.tx (transaction_a), "peers", flags, &peer_store.peers_handle) != 0;
183  	error_a |= mdb_dbi_open (env.tx (transaction_a), "pruned", flags, &pruned_store.pruned_handle) != 0;
184  	error_a |= mdb_dbi_open (env.tx (transaction_a), "confirmation_height", flags, &confirmation_height_store.confirmation_height_handle) != 0;
185  	error_a |= mdb_dbi_open (env.tx (transaction_a), "accounts", flags, &account_store.accounts_v0_handle) != 0;
186  	account_store.accounts_handle = account_store.accounts_v0_handle;
187  	error_a |= mdb_dbi_open (env.tx (transaction_a), "pending", flags, &pending_store.pending_v0_handle) != 0;
188  	pending_store.pending_handle = pending_store.pending_v0_handle;
189  	error_a |= mdb_dbi_open (env.tx (transaction_a), "final_votes", flags, &final_vote_store.final_votes_handle) != 0;
190  	auto version_l = version.get (transaction_a);
191  	if (version_l < 19)
192  	{
193  		error_a |= mdb_dbi_open (env.tx (transaction_a), "send", flags, &block_store.send_blocks_handle) != 0;
194  		error_a |= mdb_dbi_open (env.tx (transaction_a), "receive", flags, &block_store.receive_blocks_handle) != 0;
195  		error_a |= mdb_dbi_open (env.tx (transaction_a), "open", flags, &block_store.open_blocks_handle) != 0;
196  		error_a |= mdb_dbi_open (env.tx (transaction_a), "change", flags, &block_store.change_blocks_handle) != 0;
197  		if (version_l >= 15)
198  		{
199  			error_a |= mdb_dbi_open (env.tx (transaction_a), "state_blocks", flags, &block_store.state_blocks_handle) != 0;
200  			block_store.state_blocks_v0_handle = block_store.state_blocks_handle;
201  		}
202  	}
203  	else
204  	{
205  		error_a |= mdb_dbi_open (env.tx (transaction_a), "blocks", MDB_CREATE, &block_store.blocks_handle) != 0;
206  	}
207  	if (version_l < 16)
208  	{
209  		error_a |= mdb_dbi_open (env.tx (transaction_a), "representation", flags, &account_store.representation_handle) != 0;
210  	}
211  	if (version_l < 15)
212  	{
213  		error_a |= mdb_dbi_open (env.tx (transaction_a), "state", flags, &block_store.state_blocks_v0_handle) != 0;
214  		block_store.state_blocks_handle = block_store.state_blocks_v0_handle;
215  		error_a |= mdb_dbi_open (env.tx (transaction_a), "accounts_v1", flags, &account_store.accounts_v1_handle) != 0;
216  		error_a |= mdb_dbi_open (env.tx (transaction_a), "pending_v1", flags, &pending_store.pending_v1_handle) != 0;
217  		error_a |= mdb_dbi_open (env.tx (transaction_a), "state_v1", flags, &block_store.state_blocks_v1_handle) != 0;
218  	}
219  }
220  bool nano::lmdb::store::do_upgrades (nano::write_transaction & transaction_a, nano::ledger_constants & constants, bool & needs_vacuuming)
221  {
222  	auto error (false);
223  	auto version_l = version.get (transaction_a);
224  	switch (version_l)
225  	{
226  		case 1:
227  		case 2:
228  		case 3:
229  		case 4:
230  		case 5:
231  		case 6:
232  		case 7:
233  		case 8:
234  		case 9:
235  		case 10:
236  		case 11:
237  		case 12:
238  		case 13:
239  			logger.always_log (boost::str (boost::format ("The version of the ledger (%1%) is lower than the minimum (%2%) which is supported for upgrades. Either upgrade to a v19, v20 or v21 node first or delete the ledger.") % version_l % version_minimum));
240  			error = true;
241  			break;
242  		case 14:
243  			upgrade_v14_to_v15 (transaction_a);
244  			[[fallthrough]];
245  		case 15:
246  			upgrade_v15_to_v16 (transaction_a);
247  			[[fallthrough]];
248  		case 16:
249  			upgrade_v16_to_v17 (transaction_a);
250  			[[fallthrough]];
251  		case 17:
252  			upgrade_v17_to_v18 (transaction_a, constants);
253  			[[fallthrough]];
254  		case 18:
255  			upgrade_v18_to_v19 (transaction_a);
256  			needs_vacuuming = true;
257  			[[fallthrough]];
258  		case 19:
259  			upgrade_v19_to_v20 (transaction_a);
260  			[[fallthrough]];
261  		case 20:
262  			upgrade_v20_to_v21 (transaction_a);
263  			[[fallthrough]];
264  		case 21:
265  			upgrade_v21_to_v22 (transaction_a);
266  			[[fallthrough]];
267  		case 22:
268  			break;
269  		default:
270  			logger.always_log (boost::str (boost::format ("The version of the ledger (%1%) is too high for this node") % version_l));
271  			error = true;
272  			break;
273  	}
274  	return error;
275  }
276  void nano::lmdb::store::upgrade_v14_to_v15 (nano::write_transaction & transaction_a)
277  {
278  	logger.always_log ("Preparing v14 to v15 database upgrade...");
279  	std::vector<std::pair<nano::account, nano::account_info>> account_infos;
280  	upgrade_counters account_counters (count (transaction_a, account_store.accounts_v0_handle), count (transaction_a, account_store.accounts_v1_handle));
281  	account_infos.reserve (account_counters.before_v0 + account_counters.before_v1);
282  	nano::mdb_merge_iterator<nano::account, nano::account_info_v14> i_account (transaction_a, account_store.accounts_v0_handle, account_store.accounts_v1_handle);
283  	nano::mdb_merge_iterator<nano::account, nano::account_info_v14> n_account{};
284  	for (; i_account != n_account; ++i_account)
285  	{
286  		nano::account account (i_account->first);
287  		nano::account_info_v14 account_info_v14 (i_account->second);
288  		auto rep_block = block_get_v14 (transaction_a, account_info_v14.rep_block);
289  		release_assert (rep_block != nullptr);
290  		account_infos.emplace_back (account, nano::account_info{ account_info_v14.head, rep_block->representative (), account_info_v14.open_block, account_info_v14.balance, account_info_v14.modified, account_info_v14.block_count, i_account.from_first_database ? nano::epoch::epoch_0 : nano::epoch::epoch_1 });
291  		mdb_put (env.tx (transaction_a), confirmation_height_store.confirmation_height_handle, nano::mdb_val (account), nano::mdb_val (account_info_v14.confirmation_height), MDB_APPEND);
292  		i_account.from_first_database ? ++account_counters.after_v0 : ++account_counters.after_v1;
293  	}
294  	logger.always_log ("Finished extracting confirmation height to its own database");
295  	debug_assert (account_counters.are_equal ());
296  	mdb_drop (env.tx (transaction_a), account_store.accounts_v1_handle, 1);
297  	mdb_drop (env.tx (transaction_a), account_store.accounts_v0_handle, 0);
298  	for (auto const & account_account_info_pair : account_infos)
299  	{
300  		auto const & account_info (account_account_info_pair.second);
301  		mdb_put (env.tx (transaction_a), account_store.accounts_handle, nano::mdb_val (account_account_info_pair.first), nano::mdb_val (account_info), MDB_APPEND);
302  	}
303  	logger.always_log ("Epoch merge upgrade: Finished accounts, now doing state blocks");
304  	account_infos.clear ();
305  	MDB_dbi state_blocks_new;
306  	mdb_dbi_open (env.tx (transaction_a), "state_blocks", MDB_CREATE, &state_blocks_new);
307  	upgrade_counters state_counters (count (transaction_a, block_store.state_blocks_v0_handle), count (transaction_a, block_store.state_blocks_v1_handle));
308  	nano::mdb_merge_iterator<nano::block_hash, nano::state_block_w_sideband_v14> i_state (transaction_a, block_store.state_blocks_v0_handle, block_store.state_blocks_v1_handle);
309  	nano::mdb_merge_iterator<nano::block_hash, nano::state_block_w_sideband_v14> n_state{};
310  	auto num = 0u;
311  	for (; i_state != n_state; ++i_state, ++num)
312  	{
313  		nano::block_hash hash (i_state->first);
314  		nano::state_block_w_sideband_v14 state_block_w_sideband_v14 (i_state->second);
315  		auto & sideband_v14 = state_block_w_sideband_v14.sideband;
316  		nano::block_sideband_v18 sideband (sideband_v14.account, sideband_v14.successor, sideband_v14.balance, sideband_v14.height, sideband_v14.timestamp, i_state.from_first_database ? nano::epoch::epoch_0 : nano::epoch::epoch_1, false, false, false);
317  		std::vector<uint8_t> data;
318  		{
319  			nano::vectorstream stream (data);
320  			state_block_w_sideband_v14.state_block->serialize (stream);
321  			sideband.serialize (stream, sideband_v14.type);
322  		}
323  		nano::mdb_val value{ data.size (), (void *)data.data () };
324  		auto s = mdb_put (env.tx (transaction_a), state_blocks_new, nano::mdb_val (hash), value, MDB_APPEND);
325  		release_assert_success (s);
326  		constexpr auto output_cutoff = 1000000;
327  		if (num % output_cutoff == 0 && num != 0)
328  		{
329  			logger.always_log (boost::str (boost::format ("Database epoch merge upgrade %1% million state blocks upgraded") % (num / output_cutoff)));
330  		}
331  		i_state.from_first_database ? ++state_counters.after_v0 : ++state_counters.after_v1;
332  	}
333  	debug_assert (state_counters.are_equal ());
334  	logger.always_log ("Epoch merge upgrade: Finished state blocks, now doing pending blocks");
335  	block_store.state_blocks_handle = state_blocks_new;
336  	mdb_drop (env.tx (transaction_a), block_store.state_blocks_v1_handle, 1);
337  	mdb_drop (env.tx (transaction_a), block_store.state_blocks_v0_handle, 1);
338  	block_store.state_blocks_v0_handle = block_store.state_blocks_handle;
339  	upgrade_counters pending_counters (count (transaction_a, pending_store.pending_v0_handle), count (transaction_a, pending_store.pending_v1_handle));
340  	std::vector<std::pair<nano::pending_key, nano::pending_info>> pending_infos;
341  	pending_infos.reserve (pending_counters.before_v0 + pending_counters.before_v1);
342  	nano::mdb_merge_iterator<nano::pending_key, nano::pending_info_v14> i_pending (transaction_a, pending_store.pending_v0_handle, pending_store.pending_v1_handle);
343  	nano::mdb_merge_iterator<nano::pending_key, nano::pending_info_v14> n_pending{};
344  	for (; i_pending != n_pending; ++i_pending)
345  	{
346  		nano::pending_info_v14 info (i_pending->second);
347  		pending_infos.emplace_back (nano::pending_key (i_pending->first), nano::pending_info{ info.source, info.amount, i_pending.from_first_database ? nano::epoch::epoch_0 : nano::epoch::epoch_1 });
348  		i_pending.from_first_database ? ++pending_counters.after_v0 : ++pending_counters.after_v1;
349  	}
350  	debug_assert (pending_counters.are_equal ());
351  	mdb_drop (env.tx (transaction_a), pending_store.pending_v1_handle, 1);
352  	mdb_drop (env.tx (transaction_a), pending_store.pending_v0_handle, 0);
353  	for (auto const & pending_key_pending_info_pair : pending_infos)
354  	{
355  		mdb_put (env.tx (transaction_a), pending_store.pending_handle, nano::mdb_val (pending_key_pending_info_pair.first), nano::mdb_val (pending_key_pending_info_pair.second), MDB_APPEND);
356  	}
357  	version.put (transaction_a, 15);
358  	logger.always_log ("Finished epoch merge upgrade");
359  }
360  void nano::lmdb::store::upgrade_v15_to_v16 (nano::write_transaction const & transaction_a)
361  {
362  	debug_assert (account_store.representation_handle != 0);
363  	if (account_store.representation_handle != 0)
364  	{
365  		auto status (mdb_drop (env.tx (transaction_a), account_store.representation_handle, 1));
366  		release_assert (status == MDB_SUCCESS);
367  		account_store.representation_handle = 0;
368  	}
369  	version.put (transaction_a, 16);
370  }
371  void nano::lmdb::store::upgrade_v16_to_v17 (nano::write_transaction const & transaction_a)
372  {
373  	logger.always_log ("Preparing v16 to v17 database upgrade...");
374  	auto account_info_i = account.begin (transaction_a);
375  	auto account_info_n = account.end ();
376  	std::vector<std::pair<nano::account, nano::confirmation_height_info>> confirmation_height_infos;
377  	auto num = 0u;
378  	for (nano::mdb_iterator<nano::account, uint64_t> i (transaction_a, confirmation_height_store.confirmation_height_handle), n (nano::mdb_iterator<nano::account, uint64_t>{}); i != n; ++i, ++account_info_i, ++num)
379  	{
380  		nano::account account (i->first);
381  		uint64_t confirmation_height (i->second);
382  		debug_assert (account == account_info_i->first);
383  		auto const & account_info = account_info_i->second;
384  		if (confirmation_height == 0)
385  		{
386  			confirmation_height_infos.emplace_back (account, confirmation_height_info{ 0, nano::block_hash (0) });
387  		}
388  		else
389  		{
390  			if (account_info_i->second.block_count / 2 >= confirmation_height)
391  			{
392  				auto block = block_get_v18 (transaction_a, account_info.open_block);
393  				debug_assert (block);
394  				auto height = 1;
395  				while (height != confirmation_height)
396  				{
397  					block = block_get_v18 (transaction_a, block->sideband ().successor);
398  					debug_assert (block);
399  					++height;
400  				}
401  				debug_assert (block->sideband ().height == confirmation_height);
402  				confirmation_height_infos.emplace_back (account, confirmation_height_info{ confirmation_height, block->hash () });
403  			}
404  			else
405  			{
406  				auto block = block_get_v18 (transaction_a, account_info.head);
407  				auto height = block->sideband ().height;
408  				while (height != confirmation_height)
409  				{
410  					block = block_get_v18 (transaction_a, block->previous ());
411  					debug_assert (block);
412  					--height;
413  				}
414  				confirmation_height_infos.emplace_back (account, confirmation_height_info{ confirmation_height, block->hash () });
415  			}
416  		}
417  		constexpr auto output_cutoff = 200000;
418  		if (num % output_cutoff == 0 && num != 0)
419  		{
420  			logger.always_log (boost::str (boost::format ("Confirmation height frontier set for %1%00k accounts") % ((num / output_cutoff) * 2)));
421  		}
422  	}
423  	auto status (mdb_drop (env.tx (transaction_a), confirmation_height_store.confirmation_height_handle, 0));
424  	release_assert_success (status);
425  	for (auto const & confirmation_height_info_pair : confirmation_height_infos)
426  	{
427  		mdb_put (env.tx (transaction_a), confirmation_height_store.confirmation_height_handle, nano::mdb_val (confirmation_height_info_pair.first), nano::mdb_val (confirmation_height_info_pair.second), MDB_APPEND);
428  	}
429  	version.put (transaction_a, 17);
430  	logger.always_log ("Finished upgrading confirmation height frontiers");
431  }
432  void nano::lmdb::store::upgrade_v17_to_v18 (nano::write_transaction const & transaction_a, nano::ledger_constants & constants)
433  {
434  	logger.always_log ("Preparing v17 to v18 database upgrade...");
435  	auto count_pre (count (transaction_a, block_store.state_blocks_handle));
436  	auto num = 0u;
437  	for (nano::mdb_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::state_block>> state_i (transaction_a, block_store.state_blocks_handle), state_n{}; state_i != state_n; ++state_i, ++num)
438  	{
439  		nano::block_w_sideband_v18<nano::state_block> block_w_sideband (state_i->second);
440  		auto & block (block_w_sideband.block);
441  		auto & sideband (block_w_sideband.sideband);
442  		bool is_send{ false };
443  		bool is_receive{ false };
444  		bool is_epoch{ false };
445  		nano::amount prev_balance (0);
446  		if (!block->hashables.previous.is_zero ())
447  		{
448  			prev_balance = block_balance_v18 (transaction_a, block->hashables.previous);
449  		}
450  		if (block->hashables.balance == prev_balance && constants.epochs.is_epoch_link (block->hashables.link))
451  		{
452  			is_epoch = true;
453  		}
454  		else if (block->hashables.balance < prev_balance)
455  		{
456  			is_send = true;
457  		}
458  		else if (!block->hashables.link.is_zero ())
459  		{
460  			is_receive = true;
461  		}
462  		nano::block_sideband_v18 new_sideband (sideband.account, sideband.successor, sideband.balance, sideband.height, sideband.timestamp, sideband.details.epoch, is_send, is_receive, is_epoch);
463  		std::vector<uint8_t> data;
464  		{
465  			nano::vectorstream stream (data);
466  			block->serialize (stream);
467  			new_sideband.serialize (stream, block->type ());
468  		}
469  		nano::mdb_val value{ data.size (), (void *)data.data () };
470  		auto s = mdb_cursor_put (state_i.cursor, state_i->first, value, MDB_CURRENT);
471  		release_assert_success (s);
472  		constexpr auto output_cutoff = 1000000;
473  		if (num > 0 && num % output_cutoff == 0)
474  		{
475  			logger.always_log (boost::str (boost::format ("Database sideband upgrade %1% million state blocks upgraded (out of %2%)") % (num / output_cutoff) % count_pre));
476  		}
477  	}
478  	auto count_post (count (transaction_a, block_store.state_blocks_handle));
479  	release_assert (count_pre == count_post);
480  	version.put (transaction_a, 18);
481  	logger.always_log ("Finished upgrading the sideband");
482  }
483  void nano::lmdb::store::upgrade_v18_to_v19 (nano::write_transaction const & transaction_a)
484  {
485  	logger.always_log ("Preparing v18 to v19 database upgrade...");
486  	auto count_pre (count (transaction_a, block_store.state_blocks_handle) + count (transaction_a, block_store.send_blocks_handle) + count (transaction_a, block_store.receive_blocks_handle) + count (transaction_a, block_store.change_blocks_handle) + count (transaction_a, block_store.open_blocks_handle));
487  	std::map<nano::block_hash, nano::block_w_sideband> legacy_open_receive_change_blocks;
488  	for (auto i (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::change_block>> (std::make_unique<nano::mdb_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::change_block>>> (transaction_a, block_store.change_blocks_handle))), n (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::change_block>> (nullptr)); i != n; ++i)
489  	{
490  		nano::block_sideband_v18 const & old_sideband (i->second.sideband);
491  		nano::block_sideband new_sideband (old_sideband.account, old_sideband.successor, old_sideband.balance, old_sideband.height, old_sideband.timestamp, nano::epoch::epoch_0, false, false, false, nano::epoch::epoch_0);
492  		legacy_open_receive_change_blocks[i->first] = { nano::block_w_sideband{ i->second.block, new_sideband } };
493  	}
494  	for (auto i (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::open_block>> (std::make_unique<nano::mdb_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::open_block>>> (transaction_a, block_store.open_blocks_handle))), n (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::open_block>> (nullptr)); i != n; ++i)
495  	{
496  		nano::block_sideband_v18 const & old_sideband (i->second.sideband);
497  		nano::block_sideband new_sideband (old_sideband.account, old_sideband.successor, old_sideband.balance, old_sideband.height, old_sideband.timestamp, nano::epoch::epoch_0, false, false, false, nano::epoch::epoch_0);
498  		legacy_open_receive_change_blocks[i->first] = { nano::block_w_sideband{ i->second.block, new_sideband } };
499  	}
500  	for (auto i (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::receive_block>> (std::make_unique<nano::mdb_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::receive_block>>> (transaction_a, block_store.receive_blocks_handle))), n (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::receive_block>> (nullptr)); i != n; ++i)
501  	{
502  		nano::block_sideband_v18 const & old_sideband (i->second.sideband);
503  		nano::block_sideband new_sideband (old_sideband.account, old_sideband.successor, old_sideband.balance, old_sideband.height, old_sideband.timestamp, nano::epoch::epoch_0, false, false, false, nano::epoch::epoch_0);
504  		legacy_open_receive_change_blocks[i->first] = { nano::block_w_sideband{ i->second.block, new_sideband } };
505  	}
506  	release_assert (!mdb_drop (env.tx (transaction_a), block_store.receive_blocks_handle, 1));
507  	block_store.receive_blocks_handle = 0;
508  	release_assert (!mdb_drop (env.tx (transaction_a), block_store.open_blocks_handle, 1));
509  	block_store.open_blocks_handle = 0;
510  	release_assert (!mdb_drop (env.tx (transaction_a), block_store.change_blocks_handle, 1));
511  	block_store.change_blocks_handle = 0;
512  	logger.always_log ("Write legacy open/receive/change to new format");
513  	MDB_dbi temp_legacy_open_receive_change_blocks;
514  	{
515  		mdb_dbi_open (env.tx (transaction_a), "temp_legacy_open_receive_change_blocks", MDB_CREATE, &temp_legacy_open_receive_change_blocks);
516  		for (auto const & legacy_block : legacy_open_receive_change_blocks)
517  		{
518  			std::vector<uint8_t> data;
519  			{
520  				nano::vectorstream stream (data);
521  				nano::serialize_block (stream, *legacy_block.second.block);
522  				legacy_block.second.sideband.serialize (stream, legacy_block.second.block->type ());
523  			}
524  			nano::mdb_val value{ data.size (), (void *)data.data () };
525  			auto s = mdb_put (env.tx (transaction_a), temp_legacy_open_receive_change_blocks, nano::mdb_val (legacy_block.first), value, MDB_APPEND);
526  			release_assert_success (s);
527  		}
528  	}
529  	logger.always_log ("Write legacy send to new format");
530  	MDB_dbi temp_legacy_send_blocks;
531  	{
532  		mdb_dbi_open (env.tx (transaction_a), "temp_legacy_send_blocks", MDB_CREATE, &temp_legacy_send_blocks);
533  		for (auto i (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::send_block>> (std::make_unique<nano::mdb_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::send_block>>> (transaction_a, block_store.send_blocks_handle))), n (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::send_block>> (nullptr)); i != n; ++i)
534  		{
535  			auto const & block_w_sideband_v18 (i->second);
536  			std::vector<uint8_t> data;
537  			{
538  				nano::vectorstream stream (data);
539  				nano::serialize_block (stream, *block_w_sideband_v18.block);
540  				block_w_sideband_v18.sideband.serialize (stream, nano::block_type::send); 
541  			}
542  			nano::mdb_val value{ data.size (), (void *)data.data () };
543  			auto s = mdb_put (env.tx (transaction_a), temp_legacy_send_blocks, nano::mdb_val (i->first), value, MDB_APPEND);
544  			release_assert_success (s);
545  		}
546  	}
547  	release_assert (!mdb_drop (env.tx (transaction_a), block_store.send_blocks_handle, 1));
548  	block_store.send_blocks_handle = 0;
549  	logger.always_log ("Merge legacy open/receive/change with legacy send blocks");
550  	MDB_dbi temp_legacy_send_open_receive_change_blocks;
551  	{
552  		mdb_dbi_open (env.tx (transaction_a), "temp_legacy_send_open_receive_change_blocks", MDB_CREATE, &temp_legacy_send_open_receive_change_blocks);
553  		nano::mdb_merge_iterator<nano::block_hash, nano::block_w_sideband> i (transaction_a, temp_legacy_open_receive_change_blocks, temp_legacy_send_blocks);
554  		nano::mdb_merge_iterator<nano::block_hash, nano::block_w_sideband> n{};
555  		for (; i != n; ++i)
556  		{
557  			auto s = mdb_put (env.tx (transaction_a), temp_legacy_send_open_receive_change_blocks, nano::mdb_val (i->first), nano::mdb_val (i->second), MDB_APPEND);
558  			release_assert_success (s);
559  		}
560  		mdb_drop (env.tx (transaction_a), temp_legacy_send_blocks, 1);
561  		mdb_drop (env.tx (transaction_a), temp_legacy_open_receive_change_blocks, 1);
562  	}
563  	logger.always_log ("Write state blocks to new format");
564  	MDB_dbi temp_state_blocks;
565  	{
566  		auto type_state (nano::block_type::state);
567  		mdb_dbi_open (env.tx (transaction_a), "temp_state_blocks", MDB_CREATE, &temp_state_blocks);
568  		for (auto i (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::state_block>> (std::make_unique<nano::mdb_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::state_block>>> (transaction_a, block_store.state_blocks_handle))), n (nano::store_iterator<nano::block_hash, nano::block_w_sideband_v18<nano::state_block>> (nullptr)); i != n; ++i)
569  		{
570  			auto const & block_w_sideband_v18 (i->second);
571  			nano::block_sideband_v18 const & old_sideband (block_w_sideband_v18.sideband);
572  			nano::epoch source_epoch (nano::epoch::epoch_0);
573  			if (old_sideband.details.is_receive)
574  			{
575  				auto db_val (block_raw_get_by_type_v18 (transaction_a, block_w_sideband_v18.block->link ().as_block_hash (), type_state));
576  				if (db_val.is_initialized ())
577  				{
578  					nano::bufferstream stream (reinterpret_cast<uint8_t const *> (db_val.get ().data ()), db_val.get ().size ());
579  					auto source_block (nano::deserialize_block (stream, type_state));
580  					release_assert (source_block != nullptr);
581  					nano::block_sideband_v18 source_sideband;
582  					auto error (source_sideband.deserialize (stream, type_state));
583  					release_assert (!error);
584  					source_epoch = source_sideband.details.epoch;
585  				}
586  			}
587  			nano::block_sideband new_sideband (old_sideband.account, old_sideband.successor, old_sideband.balance, old_sideband.height, old_sideband.timestamp, old_sideband.details.epoch, old_sideband.details.is_send, old_sideband.details.is_receive, old_sideband.details.is_epoch, source_epoch);
588  			std::vector<uint8_t> data;
589  			{
590  				nano::vectorstream stream (data);
591  				nano::serialize_block (stream, *block_w_sideband_v18.block);
592  				new_sideband.serialize (stream, nano::block_type::state);
593  			}
594  			nano::mdb_val value{ data.size (), (void *)data.data () };
595  			auto s = mdb_put (env.tx (transaction_a), temp_state_blocks, nano::mdb_val (i->first), value, MDB_APPEND);
596  			release_assert_success (s);
597  		}
598  	}
599  	release_assert (!mdb_drop (env.tx (transaction_a), block_store.state_blocks_handle, 1));
600  	block_store.state_blocks_handle = 0;
601  	logger.always_log ("Merging all legacy blocks with state blocks");
602  	nano::mdb_merge_iterator<nano::block_hash, nano::block_w_sideband> i (transaction_a, temp_legacy_send_open_receive_change_blocks, temp_state_blocks);
603  	nano::mdb_merge_iterator<nano::block_hash, nano::block_w_sideband> n{};
604  	mdb_dbi_open (env.tx (transaction_a), "blocks", MDB_CREATE, &block_store.blocks_handle);
605  	for (; i != n; ++i)
606  	{
607  		auto s = mdb_put (env.tx (transaction_a), block_store.blocks_handle, nano::mdb_val (i->first), nano::mdb_val (i->second), MDB_APPEND);
608  		release_assert_success (s);
609  	}
610  	mdb_drop (env.tx (transaction_a), temp_legacy_send_open_receive_change_blocks, 1);
611  	mdb_drop (env.tx (transaction_a), temp_state_blocks, 1);
612  	auto count_post (count (transaction_a, block_store.blocks_handle));
613  	release_assert (count_pre == count_post);
614  	MDB_dbi vote{ 0 };
615  	release_assert (!mdb_dbi_open (env.tx (transaction_a), "vote", MDB_CREATE, &vote));
616  	release_assert (!mdb_drop (env.tx (transaction_a), vote, 1));
617  	version.put (transaction_a, 19);
618  	logger.always_log ("Finished upgrading all blocks to new blocks database");
619  }
620  void nano::lmdb::store::upgrade_v19_to_v20 (nano::write_transaction const & transaction_a)
621  {
622  	logger.always_log ("Preparing v19 to v20 database upgrade...");
623  	mdb_dbi_open (env.tx (transaction_a), "pruned", MDB_CREATE, &pruned_store.pruned_handle);
624  	version.put (transaction_a, 20);
625  	logger.always_log ("Finished creating new pruned table");
626  }
627  void nano::lmdb::store::upgrade_v20_to_v21 (nano::write_transaction const & transaction_a)
628  {
629  	logger.always_log ("Preparing v20 to v21 database upgrade...");
630  	mdb_dbi_open (env.tx (transaction_a), "final_votes", MDB_CREATE, &final_vote_store.final_votes_handle);
631  	version.put (transaction_a, 21);
632  	logger.always_log ("Finished creating new final_vote table");
633  }
634  void nano::lmdb::store::upgrade_v21_to_v22 (nano::write_transaction const & transaction_a)
635  {
636  	logger.always_log ("Preparing v21 to v22 database upgrade...");
637  	MDB_dbi unchecked_handle{ 0 };
638  	release_assert (!mdb_dbi_open (env.tx (transaction_a), "unchecked", MDB_CREATE, &unchecked_handle));
639  	release_assert (!mdb_drop (env.tx (transaction_a), unchecked_handle, 1)); 
640  	version.put (transaction_a, 22);
641  	logger.always_log ("Finished removing unchecked table");
642  }
643  void nano::lmdb::store::create_backup_file (nano::mdb_env & env_a, boost::filesystem::path const & filepath_a, nano::logger_mt & logger_a)
644  {
645  	auto extension = filepath_a.extension ();
646  	auto filename_without_extension = filepath_a.filename ().replace_extension ("");
647  	auto orig_filepath = filepath_a;
648  	auto & backup_path = orig_filepath.remove_filename ();
649  	auto backup_filename = filename_without_extension;
650  	backup_filename += "_backup_";
651  	backup_filename += std::to_string (std::chrono::system_clock::now ().time_since_epoch ().count ());
652  	backup_filename += extension;
653  	auto backup_filepath = backup_path / backup_filename;
654  	auto start_message (boost::str (boost::format ("Performing %1% backup before database upgrade...") % filepath_a.filename ()));
655  	logger_a.always_log (start_message);
656  	std::cout << start_message << std::endl;
657  	auto error (mdb_env_copy (env_a, backup_filepath.string ().c_str ()));
658  	if (error)
659  	{
660  		auto error_message (boost::str (boost::format ("%1% backup failed") % filepath_a.filename ()));
661  		logger_a.always_log (error_message);
662  		std::cerr << error_message << std::endl;
663  		std::exit (1);
664  	}
665  	else
666  	{
667  		auto success_message (boost::str (boost::format ("Backup created: %1%") % backup_filename));
668  		logger_a.always_log (success_message);
669  		std::cout << success_message << std::endl;
670  	}
671  }
672  bool nano::lmdb::store::exists (nano::transaction const & transaction_a, tables table_a, nano::mdb_val const & key_a) const
673  {
674  	nano::mdb_val junk;
675  	auto status = get (transaction_a, table_a, key_a, junk);
676  	release_assert (status == MDB_SUCCESS || status == MDB_NOTFOUND);
677  	return (status == MDB_SUCCESS);
678  }
679  int nano::lmdb::store::get (nano::transaction const & transaction_a, tables table_a, nano::mdb_val const & key_a, nano::mdb_val & value_a) const
680  {
681  	return mdb_get (env.tx (transaction_a), table_to_dbi (table_a), key_a, value_a);
682  }
683  int nano::lmdb::store::put (nano::write_transaction const & transaction_a, tables table_a, nano::mdb_val const & key_a, nano::mdb_val const & value_a) const
684  {
685  	return (mdb_put (env.tx (transaction_a), table_to_dbi (table_a), key_a, value_a, 0));
686  }
687  int nano::lmdb::store::del (nano::write_transaction const & transaction_a, tables table_a, nano::mdb_val const & key_a) const
688  {
689  	return (mdb_del (env.tx (transaction_a), table_to_dbi (table_a), key_a, nullptr));
690  }
691  int nano::lmdb::store::drop (nano::write_transaction const & transaction_a, tables table_a)
692  {
693  	return clear (transaction_a, table_to_dbi (table_a));
694  }
695  int nano::lmdb::store::clear (nano::write_transaction const & transaction_a, MDB_dbi handle_a)
696  {
697  	return mdb_drop (env.tx (transaction_a), handle_a, 0);
698  }
699  uint64_t nano::lmdb::store::count (nano::transaction const & transaction_a, tables table_a) const
700  {
701  	return count (transaction_a, table_to_dbi (table_a));
702  }
703  uint64_t nano::lmdb::store::count (nano::transaction const & transaction_a, MDB_dbi db_a) const
704  {
705  	MDB_stat stats;
706  	auto status (mdb_stat (env.tx (transaction_a), db_a, &stats));
707  	release_assert_success (status);
708  	return (stats.ms_entries);
709  }
710  MDB_dbi nano::lmdb::store::table_to_dbi (tables table_a) const
711  {
712  	switch (table_a)
713  	{
714  		case tables::frontiers:
715  			return frontier_store.frontiers_handle;
716  		case tables::accounts:
717  			return account_store.accounts_handle;
718  		case tables::blocks:
719  			return block_store.blocks_handle;
720  		case tables::pending:
721  			return pending_store.pending_handle;
722  		case tables::online_weight:
723  			return online_weight_store.online_weight_handle;
724  		case tables::meta:
725  			return block_store.meta_handle;
726  		case tables::peers:
727  			return peer_store.peers_handle;
728  		case tables::pruned:
729  			return pruned_store.pruned_handle;
730  		case tables::confirmation_height:
731  			return confirmation_height_store.confirmation_height_handle;
732  		case tables::final_votes:
733  			return final_vote_store.final_votes_handle;
734  		default:
735  			release_assert (false);
736  			return peer_store.peers_handle;
737  	}
738  }
739  bool nano::lmdb::store::not_found (int status) const
740  {
741  	return (status_code_not_found () == status);
742  }
743  bool nano::lmdb::store::success (int status) const
744  {
745  	return (MDB_SUCCESS == status);
746  }
747  int nano::lmdb::store::status_code_not_found () const
748  {
749  	return MDB_NOTFOUND;
750  }
751  std::string nano::lmdb::store::error_string (int status) const
752  {
753  	return mdb_strerror (status);
754  }
755  bool nano::lmdb::store::copy_db (boost::filesystem::path const & destination_file)
756  {
757  	return !mdb_env_copy2 (env.environment, destination_file.string ().c_str (), MDB_CP_COMPACT);
758  }
759  void nano::lmdb::store::rebuild_db (nano::write_transaction const & transaction_a)
760  {
761  	std::vector<MDB_dbi> tables = { account_store.accounts_handle, block_store.blocks_handle, pruned_store.pruned_handle, confirmation_height_store.confirmation_height_handle };
762  	for (auto const & table : tables)
763  	{
764  		MDB_dbi temp;
765  		mdb_dbi_open (env.tx (transaction_a), "temp_table", MDB_CREATE, &temp);
766  		for (auto i (nano::store_iterator<nano::uint256_union, nano::mdb_val> (std::make_unique<nano::mdb_iterator<nano::uint256_union, nano::mdb_val>> (transaction_a, table))), n (nano::store_iterator<nano::uint256_union, nano::mdb_val> (nullptr)); i != n; ++i)
767  		{
768  			auto s = mdb_put (env.tx (transaction_a), temp, nano::mdb_val (i->first), i->second, MDB_APPEND);
769  			release_assert_success (s);
770  		}
771  		release_assert (count (transaction_a, table) == count (transaction_a, temp));
772  		mdb_drop (env.tx (transaction_a), table, 0);
773  		for (auto i (nano::store_iterator<nano::uint256_union, nano::mdb_val> (std::make_unique<nano::mdb_iterator<nano::uint256_union, nano::mdb_val>> (transaction_a, temp))), n (nano::store_iterator<nano::uint256_union, nano::mdb_val> (nullptr)); i != n; ++i)
774  		{
775  			auto s = mdb_put (env.tx (transaction_a), table, nano::mdb_val (i->first), i->second, MDB_APPEND);
776  			release_assert_success (s);
777  		}
778  		release_assert (count (transaction_a, table) == count (transaction_a, temp));
779  		mdb_drop (env.tx (transaction_a), temp, 1);
780  	}
781  	{
782  		MDB_dbi temp;
783  		mdb_dbi_open (env.tx (transaction_a), "temp_table", MDB_CREATE, &temp);
784  		for (auto i (nano::store_iterator<nano::pending_key, nano::pending_info> (std::make_unique<nano::mdb_iterator<nano::pending_key, nano::pending_info>> (transaction_a, pending_store.pending_handle))), n (nano::store_iterator<nano::pending_key, nano::pending_info> (nullptr)); i != n; ++i)
785  		{
786  			auto s = mdb_put (env.tx (transaction_a), temp, nano::mdb_val (i->first), nano::mdb_val (i->second), MDB_APPEND);
787  			release_assert_success (s);
788  		}
789  		release_assert (count (transaction_a, pending_store.pending_handle) == count (transaction_a, temp));
790  		mdb_drop (env.tx (transaction_a), pending_store.pending_handle, 0);
791  		for (auto i (nano::store_iterator<nano::pending_key, nano::pending_info> (std::make_unique<nano::mdb_iterator<nano::pending_key, nano::pending_info>> (transaction_a, temp))), n (nano::store_iterator<nano::pending_key, nano::pending_info> (nullptr)); i != n; ++i)
792  		{
793  			auto s = mdb_put (env.tx (transaction_a), pending_store.pending_handle, nano::mdb_val (i->first), nano::mdb_val (i->second), MDB_APPEND);
794  			release_assert_success (s);
795  		}
796  		release_assert (count (transaction_a, pending_store.pending_handle) == count (transaction_a, temp));
797  		mdb_drop (env.tx (transaction_a), temp, 1);
798  	}
799  }
800  bool nano::lmdb::store::init_error () const
801  {
802  	return error;
803  }
804  std::shared_ptr<nano::block> nano::lmdb::store::block_get_v18 (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
805  {
806  	nano::block_type type;
807  	auto value (block_raw_get_v18 (transaction_a, hash_a, type));
808  	std::shared_ptr<nano::block> result;
809  	if (value.size () != 0)
810  	{
811  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
812  		result = nano::deserialize_block (stream, type);
813  		release_assert (result != nullptr);
814  		nano::block_sideband_v18 sideband;
815  		auto error = (sideband.deserialize (stream, type));
816  		release_assert (!error);
817  		result->sideband_set (nano::block_sideband (sideband.account, sideband.successor, sideband.balance, sideband.height, sideband.timestamp, sideband.details.epoch, sideband.details.is_send, sideband.details.is_receive, sideband.details.is_epoch, nano::epoch::epoch_0));
818  	}
819  	return result;
820  }
821  nano::mdb_val nano::lmdb::store::block_raw_get_v18 (nano::transaction const & transaction_a, nano::block_hash const & hash_a, nano::block_type & type_a) const
822  {
823  	nano::mdb_val result;
824  	nano::block_type block_types[]{ nano::block_type::state, nano::block_type::send, nano::block_type::receive, nano::block_type::open, nano::block_type::change };
825  	for (auto current_type : block_types)
826  	{
827  		auto db_val (block_raw_get_by_type_v18 (transaction_a, hash_a, current_type));
828  		if (db_val.is_initialized ())
829  		{
830  			type_a = current_type;
831  			result = db_val.get ();
832  			break;
833  		}
834  	}
835  	return result;
836  }
837  boost::optional<nano::mdb_val> nano::lmdb::store::block_raw_get_by_type_v18 (nano::transaction const & transaction_a, nano::block_hash const & hash_a, nano::block_type & type_a) const
838  {
839  	nano::mdb_val value;
840  	nano::mdb_val hash (hash_a);
841  	int status = status_code_not_found ();
842  	switch (type_a)
843  	{
844  		case nano::block_type::send:
845  		{
846  			status = mdb_get (env.tx (transaction_a), block_store.send_blocks_handle, hash, value);
847  			break;
848  		}
849  		case nano::block_type::receive:
850  		{
851  			status = mdb_get (env.tx (transaction_a), block_store.receive_blocks_handle, hash, value);
852  			break;
853  		}
854  		case nano::block_type::open:
855  		{
856  			status = mdb_get (env.tx (transaction_a), block_store.open_blocks_handle, hash, value);
857  			break;
858  		}
859  		case nano::block_type::change:
860  		{
861  			status = mdb_get (env.tx (transaction_a), block_store.change_blocks_handle, hash, value);
862  			break;
863  		}
864  		case nano::block_type::state:
865  		{
866  			status = mdb_get (env.tx (transaction_a), block_store.state_blocks_handle, hash, value);
867  			break;
868  		}
869  		case nano::block_type::invalid:
870  		case nano::block_type::not_a_block:
871  		{
872  			break;
873  		}
874  	}
875  	release_assert (success (status) || not_found (status));
876  	boost::optional<nano::mdb_val> result;
877  	if (success (status))
878  	{
879  		result = value;
880  	}
881  	return result;
882  }
883  nano::uint128_t nano::lmdb::store::block_balance_v18 (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
884  {
885  	auto block (block_get_v18 (transaction_a, hash_a));
886  	release_assert (block);
887  	nano::uint128_t result (this->block.balance_calculated (block));
888  	return result;
889  }
890  std::size_t nano::lmdb::store::block_successor_offset_v14 (nano::transaction const & transaction_a, std::size_t entry_size_a, nano::block_type type_a) const
891  {
892  	return entry_size_a - nano::block_sideband_v14::size (type_a);
893  }
894  nano::block_hash nano::lmdb::store::block_successor_v14 (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
895  {
896  	nano::block_type type;
897  	auto value (block_raw_get_v14 (transaction_a, hash_a, type));
898  	nano::block_hash result;
899  	if (value.size () != 0)
900  	{
901  		debug_assert (value.size () >= result.bytes.size ());
902  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()) + block_successor_offset_v14 (transaction_a, value.size (), type), result.bytes.size ());
903  		auto error (nano::try_read (stream, result.bytes));
904  		(void)error;
905  		debug_assert (!error);
906  	}
907  	else
908  	{
909  		result.clear ();
910  	}
911  	return result;
912  }
913  nano::mdb_val nano::lmdb::store::block_raw_get_v14 (nano::transaction const & transaction_a, nano::block_hash const & hash_a, nano::block_type & type_a, bool * is_state_v1) const
914  {
915  	nano::mdb_val result;
916  	nano::block_type block_types[]{ nano::block_type::state, nano::block_type::send, nano::block_type::receive, nano::block_type::open, nano::block_type::change };
917  	for (auto current_type : block_types)
918  	{
919  		auto db_val (block_raw_get_by_type_v14 (transaction_a, hash_a, current_type, is_state_v1));
920  		if (db_val.is_initialized ())
921  		{
922  			type_a = current_type;
923  			result = db_val.get ();
924  			break;
925  		}
926  	}
927  	return result;
928  }
929  boost::optional<nano::mdb_val> nano::lmdb::store::block_raw_get_by_type_v14 (nano::transaction const & transaction_a, nano::block_hash const & hash_a, nano::block_type & type_a, bool * is_state_v1) const
930  {
931  	nano::mdb_val value;
932  	nano::mdb_val hash (hash_a);
933  	int status = status_code_not_found ();
934  	switch (type_a)
935  	{
936  		case nano::block_type::send:
937  		{
938  			status = mdb_get (env.tx (transaction_a), block_store.send_blocks_handle, hash, value);
939  			break;
940  		}
941  		case nano::block_type::receive:
942  		{
943  			status = mdb_get (env.tx (transaction_a), block_store.receive_blocks_handle, hash, value);
944  			break;
945  		}
946  		case nano::block_type::open:
947  		{
948  			status = mdb_get (env.tx (transaction_a), block_store.open_blocks_handle, hash, value);
949  			break;
950  		}
951  		case nano::block_type::change:
952  		{
953  			status = mdb_get (env.tx (transaction_a), block_store.change_blocks_handle, hash, value);
954  			break;
955  		}
956  		case nano::block_type::state:
957  		{
<span onclick='openModal()' class='match'>958  			status = mdb_get (env.tx (transaction_a), block_store.state_blocks_v1_handle, hash, value);
959  			if (is_state_v1 != nullptr)
960  			{
961  				*is_state_v1 = success (status);
962  			}
963  			if (not_found (status))
964  			{
965  				status = mdb_get (env.tx (transaction_a), block_store.state_blocks_v0_handle, hash, value);
966  			}
</span>967  			break;
968  		}
969  		case nano::block_type::invalid:
970  		case nano::block_type::not_a_block:
971  		{
972  			break;
973  		}
974  	}
975  	release_assert (success (status) || not_found (status));
976  	boost::optional<nano::mdb_val> result;
977  	if (success (status))
978  	{
979  		result = value;
980  	}
981  	return result;
982  }
983  std::shared_ptr<nano::block> nano::lmdb::store::block_get_v14 (nano::transaction const & transaction_a, nano::block_hash const & hash_a, nano::block_sideband_v14 * sideband_a, bool * is_state_v1) const
984  {
985  	nano::block_type type;
986  	auto value (block_raw_get_v14 (transaction_a, hash_a, type, is_state_v1));
987  	std::shared_ptr<nano::block> result;
988  	if (value.size () != 0)
989  	{
990  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
991  		result = nano::deserialize_block (stream, type);
992  		debug_assert (result != nullptr);
993  		if (sideband_a)
994  		{
995  			sideband_a->type = type;
996  			bool error = sideband_a->deserialize (stream);
997  			(void)error;
998  			debug_assert (!error);
999  		}
1000  	}
1001  	return result;
1002  }
1003  nano::lmdb::store::upgrade_counters::upgrade_counters (uint64_t count_before_v0, uint64_t count_before_v1) :
1004  	before_v0 (count_before_v0),
1005  	before_v1 (count_before_v1)
1006  {
1007  }
1008  bool nano::lmdb::store::upgrade_counters::are_equal () const
1009  {
1010  	return (before_v0 == after_v0) && (before_v1 == after_v1);
1011  }
1012  unsigned nano::lmdb::store::max_block_write_batch_num () const
1013  {
1014  	return std::numeric_limits<unsigned>::max ();
1015  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ctc.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-lmdb.cpp</div>
                <div class="column column_space"><pre><code>214        double log_sum = log_probs->get(t - 1, u);
215        if (u > 0) {
216          log_sum = LogSumExp(log_sum, log_probs->get(t - 1, u - 1));
217        }
218        if (u >= 2 && labels_[u - 1] == null_char_ && labels_[u] != labels_[u - 2]) {
219          log_sum = LogSumExp(log_sum, log_probs->get(t - 1, u - 2));
220        }
</pre></code></div>
                <div class="column column_space"><pre><code>958  			status = mdb_get (env.tx (transaction_a), block_store.state_blocks_v1_handle, hash, value);
959  			if (is_state_v1 != nullptr)
960  			{
961  				*is_state_v1 = success (status);
962  			}
963  			if (not_found (status))
964  			{
965  				status = mdb_get (env.tx (transaction_a), block_store.state_blocks_v0_handle, hash, value);
966  			}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    