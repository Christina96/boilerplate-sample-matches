
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 95, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ff.cpp</h3>
            <pre><code>1  void TForestFire::InfectAll() {
2    InfectNIdV.Gen(Graph->GetNodes());
3    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
4      InfectNIdV.Add(NI.GetId()); }
5  }
6  void TForestFire::InfectRnd(const int& NInfect) {
7    IAssert(NInfect < Graph->GetNodes());
8    TIntV NIdV(Graph->GetNodes(), 0);
9    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
10      NIdV.Add(NI.GetId()); }
11    NIdV.Shuffle(Rnd);
12    InfectNIdV.Gen(NInfect, 0);
13    for (int i = 0; i < NInfect; i++) {
14      InfectNIdV.Add(NIdV[i]); }
15  }
16  void TForestFire::BurnExpFire() {
17    const double OldFwdBurnProb = FwdBurnProb;
18    const double OldBckBurnProb = BckBurnProb;
19    const int NInfect = InfectNIdV.Len();
20    const TNGraph& G = *Graph;
21    TIntH BurnedNIdH;               
22    TIntV BurningNIdV = InfectNIdV; 
23    TIntV NewBurnedNIdV;            
24    bool HasAliveNbrs;              
25    int NBurned = NInfect, NDiedFire=0;
26    for (int i = 0; i < InfectNIdV.Len(); i++) {
27      BurnedNIdH.AddDat(InfectNIdV[i]); }
28    NBurnedTmV.Clr(false);  NBurningTmV.Clr(false);  NewBurnedTmV.Clr(false);
29    for (int time = 0; ; time++) {
30      NewBurnedNIdV.Clr(false);
31      for (int node = 0; node < BurningNIdV.Len(); node++) {
32        const int& BurningNId = BurningNIdV[node];
33        const TNGraph::TNodeI Node = G.GetNI(BurningNId);
34        HasAliveNbrs = false;
35        NDiedFire = 0;
36        for (int e = 0; e < Node.GetOutDeg(); e++) {
37          const int OutNId = Node.GetOutNId(e);
38          if (! BurnedNIdH.IsKey(OutNId)) { 
39            HasAliveNbrs = true;
40            if (Rnd.GetUniDev() < FwdBurnProb) {
41              BurnedNIdH.AddDat(OutNId);  NewBurnedNIdV.Add(OutNId);  NBurned++; }
42          }
43        }
44        if (BckBurnProb > 0.0) {
45          for (int e = 0; e < Node.GetInDeg(); e++) {
46            const int InNId = Node.GetInNId(e);
47            if (! BurnedNIdH.IsKey(InNId)) { 
48              HasAliveNbrs = true;
49              if (Rnd.GetUniDev() < BckBurnProb) {
50                BurnedNIdH.AddDat(InNId);  NewBurnedNIdV.Add(InNId);  NBurned++; }
51            }
52          }
53        }
54        if (! HasAliveNbrs) { NDiedFire++; }
55      }
56      NBurnedTmV.Add(NBurned);
57      NBurningTmV.Add(BurningNIdV.Len() - NDiedFire);
58      NewBurnedTmV.Add(NewBurnedNIdV.Len());
59      BurningNIdV.Swap(NewBurnedNIdV);    
60      if (BurningNIdV.Empty()) break;
61      FwdBurnProb = FwdBurnProb * ProbDecay;
62      BckBurnProb = BckBurnProb * ProbDecay;
63    }
64    BurnedNIdV.Gen(BurnedNIdH.Len(), 0);
65    for (int i = 0; i < BurnedNIdH.Len(); i++) {
66      BurnedNIdV.Add(BurnedNIdH.GetKey(i)); }
67    FwdBurnProb = OldFwdBurnProb;
68    BckBurnProb = OldBckBurnProb;
69  }
70  void TForestFire::BurnGeoFire() {
71    const double OldFwdBurnProb=FwdBurnProb;
72    const double OldBckBurnProb=BckBurnProb;
73    const int& NInfect = InfectNIdV.Len();
74    const TNGraph& G = *Graph;
75    TIntH BurnedNIdH;               
76    TIntV BurningNIdV = InfectNIdV; 
77    TIntV NewBurnedNIdV;            
78    bool HasAliveInNbrs, HasAliveOutNbrs; 
79    TIntV AliveNIdV;                
80    int NBurned = NInfect, time;
81    for (int i = 0; i < InfectNIdV.Len(); i++) {
82      BurnedNIdH.AddDat(InfectNIdV[i]); }
83    NBurnedTmV.Clr(false);  NBurningTmV.Clr(false);  NewBurnedTmV.Clr(false);
84    for (time = 0; ; time++) {
85      NewBurnedNIdV.Clr(false);
86      for (int node = 0; node < BurningNIdV.Len(); node++) {
87        const int& BurningNId = BurningNIdV[node];
88        const TNGraph::TNodeI Node = G.GetNI(BurningNId);
89        HasAliveOutNbrs = false;
90        AliveNIdV.Clr(false); 
91        for (int e = 0; e < Node.GetOutDeg(); e++) {
92          const int OutNId = Node.GetOutNId(e);
93          if (! BurnedNIdH.IsKey(OutNId)) {
<span onclick='openModal()' class='match'>94            HasAliveOutNbrs = true;  AliveNIdV.Add(OutNId); }
95        }
96        const int BurnNFwdLinks = Rnd.GetGeoDev(1.0-FwdBurnProb) - 1;
97        if (HasAliveOutNbrs && BurnNFwdLinks > 0) {
98          AliveNIdV.Shuffle(Rnd);
99          for (int i = 0; i < TMath::Mn(BurnNFwdLinks, AliveNIdV.Len()); i++) {
100            BurnedNIdH.AddDat(AliveNIdV[i]);
101            NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
102        }
103        if (BckBurnProb > 0.0) {
</span>104          HasAliveInNbrs = false;
105          AliveNIdV.Clr(false);
106          for (int e = 0; e < Node.GetInDeg(); e++) {
107            const int InNId = Node.GetInNId(e);
108            if (! BurnedNIdH.IsKey(InNId)) {
109              HasAliveInNbrs = true;  AliveNIdV.Add(InNId); }
110          }
111          const int BurnNBckLinks = Rnd.GetGeoDev(1.0-BckBurnProb) - 1;
112          if (HasAliveInNbrs && BurnNBckLinks > 0) {
113            AliveNIdV.Shuffle(Rnd);
114            for (int i = 0; i < TMath::Mn(BurnNBckLinks, AliveNIdV.Len()); i++) {
115              BurnedNIdH.AddDat(AliveNIdV[i]);
116              NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
117          }
118        }
119      }
120      NBurnedTmV.Add(NBurned);  NBurningTmV.Add(BurningNIdV.Len());  NewBurnedTmV.Add(NewBurnedNIdV.Len());
121      BurningNIdV.Swap(NewBurnedNIdV);   
122      if (BurningNIdV.Empty()) break;
123      FwdBurnProb = FwdBurnProb * ProbDecay;
124      BckBurnProb = BckBurnProb * ProbDecay;
125    }
126    BurnedNIdV.Gen(BurnedNIdH.Len(), 0);
127    for (int i = 0; i < BurnedNIdH.Len(); i++) {
128      BurnedNIdV.Add(BurnedNIdH.GetKey(i)); }
129    FwdBurnProb = OldFwdBurnProb;
130    BckBurnProb = OldBckBurnProb;
131  }
132  void TForestFire::PlotFire(const TStr& FNmPref, const TStr& Desc, const bool& PlotAllBurned) {
133    TGnuPlot GnuPlot(FNmPref, TStr::Fmt("%s. ForestFire. G(%d, %d). Fwd:%g  Bck:%g  NInfect:%d",
134      Desc.CStr(), Graph->GetNodes(), Graph->GetEdges(), FwdBurnProb(), BckBurnProb(), InfectNIdV.Len()));
135    GnuPlot.SetXYLabel("TIME EPOCH", "Number of NODES");
136    if (PlotAllBurned) GnuPlot.AddPlot(NBurnedTmV, gpwLinesPoints, "All burned nodes till time");
137    GnuPlot.AddPlot(NBurningTmV, gpwLinesPoints, "Burning nodes at time");
138    GnuPlot.AddPlot(NewBurnedTmV, gpwLinesPoints, "Newly burned nodes at time");
139    GnuPlot.SavePng(TFile::GetUniqueFNm(TStr::Fmt("fireSz.%s_#.png", FNmPref.CStr())));
140  }
141  PNGraph TForestFire::GenGraph(const int& Nodes, const double& FwdProb, const double& BckProb) {
142    TFfGGen Ff(false, 1, FwdProb, BckProb, 1.0, 0.0, 0.0);
143    Ff.GenGraph(Nodes);
144    return Ff.GetGraph();
145  }
146  int TFfGGen::TimeLimitSec = 30*60; 
147  TFfGGen::TFfGGen(const bool& BurnExpFireP, const int& StartNNodes, const double& ForwBurnProb,
148                   const double& BackBurnProb, const double& DecayProb, const double& Take2AmbasPrb, const double& OrphanPrb) :
149   Graph(), BurnExpFire(BurnExpFireP), StartNodes(StartNNodes), FwdBurnProb(ForwBurnProb),
150   BckBurnProb(BackBurnProb), ProbDecay(DecayProb), Take2AmbProb(Take2AmbasPrb), OrphanProb(OrphanPrb) {
151  }
152  TStr TFfGGen::GetParamStr() const {
153    return TStr::Fmt("%s  FWD:%g  BCK:%g, StartNds:%d, Take2:%g, Orphan:%g, ProbDecay:%g",
154      BurnExpFire?"EXP":"GEO", FwdBurnProb(), BckBurnProb(), StartNodes(), Take2AmbProb(), OrphanProb(), ProbDecay());
155  }
156  TFfGGen::TStopReason TFfGGen::AddNodes(const int& GraphNodes, const bool& FloodStop) {
157    printf("\n***ForestFire:  %s  Nodes:%d  StartNodes:%d  Take2AmbProb:%g\n", BurnExpFire?"ExpFire":"GeoFire", GraphNodes, StartNodes(), Take2AmbProb());
158    printf("                FwdBurnP:%g  BckBurnP:%g  ProbDecay:%g  Orphan:%g\n", FwdBurnProb(), BckBurnProb(), ProbDecay(), OrphanProb());
159    TExeTm ExeTm;
160    int Burned1=0, Burned2=0, Burned3=0; 
161    if (Graph.Empty()) { Graph = PNGraph::New(); }
162    if (Graph->GetNodes() == 0) {
163      for (int n = 0; n < StartNodes; n++) { Graph->AddNode(); }
164    }
165    int NEdges = Graph->GetEdges();
166    TRnd Rnd(0);
167    TForestFire ForestFire(Graph, FwdBurnProb, BckBurnProb, ProbDecay, 0);
168    for (int NNodes = Graph->GetNodes()+1; NNodes <= GraphNodes; NNodes++) {
169      const int NewNId = Graph->AddNode(-1);
170      IAssert(NewNId == Graph->GetNodes()-1); 
171      if (OrphanProb == 0.0 || Rnd.GetUniDev() > OrphanProb) {
172        if (Take2AmbProb == 0.0 || Rnd.GetUniDev() > Take2AmbProb || NewNId < 2) {
173          ForestFire.Infect(Rnd.GetUniDevInt(NewNId)); 
174        } else {
175          const int AmbassadorNId1 = Rnd.GetUniDevInt(NewNId);
176          int AmbassadorNId2 = Rnd.GetUniDevInt(NewNId);
177          while (AmbassadorNId1 == AmbassadorNId2) {
178            AmbassadorNId2 = Rnd.GetUniDevInt(NewNId); }
179          ForestFire.Infect(TIntV::GetV(AmbassadorNId1, AmbassadorNId2)); 
180        }
181        if (BurnExpFire) { ForestFire.BurnExpFire(); }
182        else { ForestFire.BurnGeoFire(); }
183        for (int e = 0; e < ForestFire.GetBurned(); e++) {
184          Graph->AddEdge(NewNId, ForestFire.GetBurnedNId(e));
185          NEdges++;
186        }
187        Burned1=Burned2;  Burned2=Burned3;  Burned3=ForestFire.GetBurned();
188      } else {
189        Burned1=Burned2;  Burned2=Burned3;  Burned3=0;
190      }
191      if (NNodes % Kilo(1) == 0) {
192        printf("(%d, %d)  burned: [%d,%d,%d]  [%s]\n", NNodes, NEdges, Burned1, Burned2, Burned3, ExeTm.GetStr()); }
193      if (FloodStop && NEdges>GraphNodes && (NEdges/double(NNodes)>1000.0)) { 
194        printf(". FLOOD. G(%6d, %6d)\n", NNodes, NEdges);  return srFlood; }
195      if (NNodes % 1000 == 0 && TimeLimitSec > 0 && ExeTm.GetSecs() > TimeLimitSec) {
196        printf(". TIME LIMIT. G(%d, %d)\n", Graph->GetNodes(), Graph->GetEdges());
197        return srTimeLimit; }
198    }
199    IAssert(Graph->GetEdges() == NEdges);
200    return srOk;
201  }
202  TFfGGen::TStopReason TFfGGen::GenGraph(const int& GraphNodes, const bool& FloodStop) {
203    Graph = PNGraph::New();
204    return AddNodes(GraphNodes, FloodStop);
205  }
206  TFfGGen::TStopReason TFfGGen::GenGraph(const int& GraphNodes, PGStatVec& EvolStat, const bool& FloodStop) {
207    int GrowthStatNodes = 100;
208    Graph = PNGraph::New();
209    AddNodes(StartNodes);
210    TStopReason SR = srUndef;
211    while (Graph->GetNodes() < GraphNodes) {
212      SR = AddNodes(GrowthStatNodes, FloodStop);
213      if (SR != srOk) { return SR; }
214      EvolStat->Add(Graph, TSecTm(Graph->GetNodes()));
215      GrowthStatNodes = int(1.5*GrowthStatNodes);
216    }
217    return SR;
218  }
219  void TFfGGen::PlotFireSize(const TStr& FNmPref, const TStr& DescStr) {
220    TGnuPlot GnuPlot("fs."+FNmPref, TStr::Fmt("%s. Fire size. G(%d, %d)",
221      DescStr.CStr(), Graph->GetNodes(), Graph->GetEdges()));
222    GnuPlot.SetXYLabel("Vertex id (iterations)", "Fire size (node out-degree)");
223    TFltPrV IdToOutDegV;
224    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
225      IdToOutDegV.Add(TFltPr(NI.GetId(), NI.GetOutDeg())); }
226    IdToOutDegV.Sort();
227    GnuPlot.AddPlot(IdToOutDegV, gpwImpulses, "Node out-degree");
228    GnuPlot.SavePng();
229  }
230  void TFfGGen::GenFFGraphs(const double& FProb, const double& BProb, const TStr& FNm) {
231    const int NRuns = 10;
232    const int NNodes = 10000;
233    TGStat::NDiamRuns = 10;
234    TVec<PGStatVec> GAtTmV;
235    TFfGGen FF(false, 1, FProb, BProb, 1.0, 0, 0);
236    for (int r = 0; r < NRuns; r++) {
237      PGStatVec GV = TGStatVec::New(tmuNodes, TGStat::AllStat());
238      FF.GenGraph(NNodes, GV, true);
239      for (int i = 0; i < GV->Len(); i++) {
240        if (i == GAtTmV.Len()) {
241          GAtTmV.Add(TGStatVec::New(tmuNodes, TGStat::AllStat()));
242        }
243        GAtTmV[i]->Add(GV->At(i));
244      }
245      IAssert(GAtTmV.Len() == GV->Len());
246    }
247    PGStatVec AvgStat = TGStatVec::New(tmuNodes, TGStat::AllStat());
248    for (int i = 0; i < GAtTmV.Len(); i++) {
249      AvgStat->Add(GAtTmV[i]->GetAvgGStat(false));
250    }
251    AvgStat->PlotAllVsX(gsvNodes, FNm, TStr::Fmt("Forest Fire: F:%g  B:%g (%d runs)", FProb, BProb, NRuns));
252    AvgStat->Last()->PlotAll(FNm, TStr::Fmt("Forest Fire: F:%g  B:%g (%d runs)", FProb, BProb, NRuns));
253  }
254  &bsol;* ForestFire.GenGraph(NNodes, true);
255      if (! ForestFire.GetGrowthStat()->Empty()) {
256        GrowthSet->Add(ForestFire.GetGrowthStat()); }
257    }
258    IAssert(! GrowthSet.Empty());
259    FBPrGSetH.AddDat(TFltPr(FwdProb, BckProb), GrowthSet);
260    PGrowthStat AvgStat = TGrowthStat::New();
261    AvgStat->AvgGrowthStat(*GrowthSet);
262    FBPrGStatH.AddDat(TFltPr(FwdProb, BckProb), AvgStat);
263    const double DiamCf = LastDecDiam().Val1;
264    const double GplCf = LastGplCf().Val1;
265    if (Plot && ! AvgStat.Empty()) {
266      const TStr FNm = TStr::Fmt("F%04d.B%04d", int(FwdProb*10000), int(BckProb*10000));
267      const TStr Title = GetTitleStr(Len()-1);
268      AvgStat->PlotDiam(FNm, Title);
269      AvgStat->PlotGpl(FNm, Title, true, false, false, false, false);
270    }
271    return TFltPr(GplCf, DiamCf);
272  }
273  void TFfPhaseTrans::FwdProbSteps(const double& MinFwdProb, const double& MaxFwdProb, const double& BckProb) {
274    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFwd.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
275    TFfGGen::TimeLimitSec = 10*60;
276    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
277      RunForestFire(FwdProb, BckProb, true);
278      { TFOut FOut(BinFNm);
279      Save(FOut); }
280    }
281  }
282  void TFfPhaseTrans::FwdProbStepsFact(const double& MinFwdProb, const double& MaxFwdProb, const double& BckFact) {
283    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFwd.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
284    TFfGGen::TimeLimitSec = 10*60;
285    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
286      RunForestFire(FwdProb, BckFact*FwdProb, true);
287      { TFOut FOut(BinFNm);
288      Save(FOut); }
289    }
290  }
291  void TFfPhaseTrans::FwdBckPhasePlot(const double& MinFwdProb, const double& MaxFwdProb, const double& MinBckFact,
292                                      const double& MaxBckFact, const int& TimeLimitSec) {
293    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFF.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
294    TFfGGen::TimeLimitSec = TimeLimitSec;
295    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
296      for (double BckFact = MinBckFact; BckFact < MaxBckFact+0.001; BckFact += ProbInc) {
297        const double BckProb = FwdProb * BckFact;
298        RunForestFire(FwdProb, BckProb, true);
299        { TFOut FOut(BinFNm);
300        Save(FOut); }
301      }
302    }
303  }
304  void TFfPhaseTrans::FindGplPhaseTr(const double& StartFProb, const double& FollowGplCf, const TStr& FNmPref, const TStr& Desc) {
305    const TStr FNm = TStr::Fmt("phGPL.%s", GetFNm(FNmPref).CStr());
306    const double Tolerance = 0.01;
307    const double MinDelta = 0.001;
308    const bool Plot = false;
309    TFfGGen::TimeLimitSec = 10*60;
310    TGrowthStat::MinNodesEdges = 2*(StartNodes-1)+100;
311    const int OldNDiamRuns = TGraphStat::NDiamRuns;
312    TGraphStat::NDiamRuns = 1;  
313    TakeStat(TFSet() | gsEffDiam);
314    FILE *F = fopen((FNm+".txt").CStr(), "wt");
315    fprintf(F, "FollowGplCf:  %g\n", FollowGplCf);
316    fprintf(F, "StartNodes:   %d\n", StartNodes());
317    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
318    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
319    fprintf(F, "Tolerance:    %g\n", Tolerance);
320    double FwdProb = StartFProb, LBckRat=0, RBckRat=1, BckRat, GplCf;
321    while (FwdProb < 1.0) {
322      while (true) {
323        BckRat = (RBckRat+LBckRat) / 2;
324        fprintf(F, "FWD: %g, (%f -- %f)", FwdProb, LBckRat, RBckRat);
325        GplCf = RunForestFire(FwdProb, FwdProb*BckRat, Plot).Val1;
326        IAssert(GplCf != -1);
327        fprintf(F, "  %f  gpl: %.4f (%.4f)", BckRat, GplCf, LastGplCf().Val2());
328        if (TMath::IsInEps(GplCf - FollowGplCf, Tolerance)) { fprintf(F, "  ***\n"); break; }
329        if (RBckRat-LBckRat < MinDelta) { fprintf(F, "  gap\n"); break; }
330        if (GplCf > FollowGplCf) { RBckRat = BckRat; } else { LBckRat = BckRat; }
331        fprintf(F, "\n");  fflush(F);
332      }
333      FwdProb += ProbInc;
334      RBckRat = BckRat+0.01;
335      if (RBckRat > 1.0) RBckRat = 1.0;
336      LBckRat = RBckRat - 0.2;
337      if (LBckRat < 0.0) LBckRat = 0.0;
338      { TFOut FOut(FNm+".bin");
339       Save(FOut); }
340      SaveGplPhaseTr(FollowGplCf, FNmPref, Desc);
341      fprintf(F, "\n");
342    }
343    fclose(F);
344    TGraphStat::NDiamRuns = OldNDiamRuns;
345  }
346  void TFfPhaseTrans::SaveGplPhaseTr(const double& FollowGplCf, const TStr& FNmPref, const TStr& Desc) {
347    const double Tolerance = 0.02;
348    THash<TFlt,  TIntFltPr> FProbH;
349    for (int i = 0; i < Len(); i ++) {
350      const double FProb = GetFProb(i);
351      const double GplCf = GetGplCf(i).Val1;
352      if (TMath::IsInEps(GplCf-FollowGplCf, Tolerance)) {
353        if (! FProbH.IsKey(FProb)) {
354          FProbH.AddDat(FProb, TIntFltPr(i, GplCf)); }
355        else {
356          const double bestCf = FProbH.GetDat(FProb).Val2;
357          if (fabs(bestCf - FollowGplCf) > fabs(GplCf - FollowGplCf)) {
358            FProbH.AddDat(FProb, TIntFltPr(i, GplCf)); }
359        }
360      }
361    }
362    TVec<TPair<TFlt, TIntFltPr> > FProbV;
363    FProbH.GetKeyDatPrV(FProbV);  FProbV.Sort();
364    const bool HasDiam = TakeStatSet.In(gsEffDiam);
365    FILE *F = fopen(TStr::Fmt("phGPL.%s.tab", GetFNm(FNmPref).CStr()).CStr(), "wt");
366    if (! Desc.Empty()) fprintf(F, "%s\n", Desc.CStr());
367    fprintf(F, "FollowGplCf:  %g\n", FollowGplCf);
368    fprintf(F, "StartNodes:   %d\n", StartNodes());
369    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
370    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
371    fprintf(F, "Tolerance:    %g\n", Tolerance);
372    fprintf(F, "id\tFProb\tBProb\tBRatio\tGlp\tGlpDev");
373    if (HasDiam) {  fprintf(F, "\tDiamCf\tDiamDev\tEffDiam"); }
374    fprintf(F, "\n");
375    for (int i = 0; i < FProbH.Len(); i++) {
376      const int Id = FProbV[i].Val2.Val1;
377      const TFltPr Gpl = GetGplCf(Id);
378      fprintf(F, "%d\t%f\t%f\t%f\t", Id, GetFProb(Id), GetBProb(Id), GetBProb(Id)/GetFProb(Id));
379      fprintf(F, "%f\t%f", Gpl.Val1(), Gpl.Val2());
380      if (HasDiam) {
381        const TFltPr DiamCf = GetDecDiam(Id);
382        fprintf(F, "\t%f\t%f\t%f", DiamCf.Val1(), DiamCf.Val2(), GetEffDiam(Id, -1).Val1());
383      }
384      fprintf(F, "\n");
385    }
386    fclose(F);
387  }
388  void TFfPhaseTrans::FindDiamPhaseTr(const double& StartFProb, const double& FollowDiamCf, const TStr& FNmPref, const TStr& Desc) {
389    const TStr FNm = TStr::Fmt("phDIAM.%s", GetFNm(FNmPref).CStr());
390    const double Tolerance = 0.01;
391    const double MinDelta = 0.001;
392    const bool Plot = false;
393    TFfGGen::TimeLimitSec = 10*60;
394    const int OldNDiamRuns = TGraphStat::NDiamRuns;
395    TGraphStat::NDiamRuns = 1;
396    TGrowthStat::MinNodesEdges = 2*(StartNodes-1)+100;
397    TakeStat(TFSet() | gsEffDiam);
398    FILE *F = fopen((FNm+".txt").CStr(), "wt");
399    fprintf(F, "FollowDiamCf: %g\n", FollowDiamCf);
400    fprintf(F, "StartNodes:   %d\n", StartNodes());
401    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
402    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
403    fprintf(F, "Tolerance:    %g\n", Tolerance);
404    double FwdProb = StartFProb, LBckRat=0, RBckRat=1, BckRat, DiamCf;
405    while (FwdProb < 1.0) {
406      while (true) {
407        BckRat = (RBckRat+LBckRat) / 2;
408        fprintf(F, "FWD: %g, (%f -- %f)", FwdProb, LBckRat, RBckRat);
409        DiamCf = RunForestFire(FwdProb, FwdProb*BckRat, Plot).Val2;
410        IAssert(DiamCf != -1);
411        fprintf(F, "  %f  diam: %.4f (%.4f)", BckRat, DiamCf, LastDecDiam().Val2());
412        if (TMath::IsInEps(DiamCf - FollowDiamCf, Tolerance)) { fprintf(F, "  ***\n"); break; }
413        if (RBckRat-LBckRat < MinDelta) { fprintf(F, "  gap\n"); break; }
414        if (DiamCf < FollowDiamCf) { RBckRat = BckRat; } else { LBckRat = BckRat; }
415        fprintf(F, "\n");  fflush(F);
416      }
417      FwdProb += ProbInc;
418      RBckRat = BckRat+0.05;
419      if (RBckRat > 1.0) RBckRat = 1.0;
420      LBckRat = RBckRat - 0.15;
421      if (LBckRat < 0.0) LBckRat = 0.0;
422      { TFOut FOut(FNm+".bin");
423      Save(FOut); }
424      SaveDiamPhaseTr(FollowDiamCf, FNmPref, Desc);
425      fprintf(F, "\n");
426    }
427    fclose(F);
428    TGraphStat::NDiamRuns = OldNDiamRuns;
429  }
430  void TFfPhaseTrans::SaveDiamPhaseTr(const double& FollowDiamCf, const TStr& FNmPref, const TStr& Desc) {
431    const double Tolerance = 0.03;
432    THash<TFlt,  TIntFltPr> FProbH;
433    for (int i = 0; i < Len(); i ++) {
434      const double FProb = GetFProb(i);
435      const double DiamCf = GetDecDiam(i).Val1;
436      if (TMath::IsInEps(DiamCf - FollowDiamCf, Tolerance)) {
437        if (! FProbH.IsKey(FProb)) {
438          FProbH.AddDat(FProb, TIntFltPr(i, DiamCf)); }
439        else {
440          const double bestCf = FProbH.GetDat(FProb).Val2;
441          if (fabs(bestCf - FollowDiamCf) > fabs(DiamCf - FollowDiamCf)) {
442            FProbH.AddDat(FProb, TIntFltPr(i, DiamCf)); }
443        }
444      }
445    }
446    TVec<TPair<TFlt, TIntFltPr> > FProbV;
447    FProbH.GetKeyDatPrV(FProbV);  FProbV.Sort();
448    FILE *F = fopen(TStr::Fmt("phDIAM.%s.tab", GetFNm(FNmPref).CStr()).CStr(), "wt");
449    if (! Desc.Empty()) fprintf(F, "%s\n", Desc.CStr());
450    fprintf(F, "FollowDiamCf: %g\n", FollowDiamCf);
451    fprintf(F, "StartNodes:   %d\n", StartNodes());
452    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
453    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
454    fprintf(F, "Tolerance:    %g\n", Tolerance);
455    fprintf(F, "id\tFProb\tBProb\tBRatio\tDiamCf\tDiamDev\tGplCf\tGplDev\tEffDiam\n");
456    for (int i = 0; i < FProbV.Len(); i++) {
457      const int Id = FProbV[i].Val2.Val1;
458      const TFltPr DiamCf = GetDecDiam(Id);
459      const TFltPr GplCf = GetGplCf(Id);
460      const TFltPr EffDiam = GetEffDiam(Id, -1);
461      fprintf(F, "%d\t%f\t%f\t%f\t", Id, GetFProb(Id), GetBProb(Id), GetBProb(Id)/GetFProb(Id));
462      fprintf(F, "%f\t%f\t%f\t%f\t%f\n", DiamCf.Val1(), DiamCf.Val2(), GplCf.Val1(), GplCf.Val2(), EffDiam.Val1());
463    }
464    fclose(F);
465  }
466  void TFfPhaseTrans::Merge(const PFfPhaseTrans& FfPhaseTrans) {
467    Merge(*FfPhaseTrans);
468  }
469  void TFfPhaseTrans::Merge(const TFfPhaseTrans& FfPhaseTrans) {
470    printf("Merging:\n");
471    printf("  source      %6d  (Fwd,Bck) pairs\n", FfPhaseTrans.Len());
472    printf("  destination %6d  (Fwd,Bck) pairs\n", Len());
473    IAssert(BurExpFire == FfPhaseTrans.BurExpFire);
474    IAssert(NNodes == FfPhaseTrans.NNodes);
475    IAssert(StartNodes == FfPhaseTrans.StartNodes);
476    IAssert(Take2AmbProb == FfPhaseTrans.Take2AmbProb);
477    IAssert(FBPrGSetH.Len() == FBPrGStatH.Len());
478    IAssert(FfPhaseTrans.FBPrGSetH.Len() == FfPhaseTrans.FBPrGStatH.Len());
479    for (int i1 = 0; i1 < FfPhaseTrans.FBPrGSetH.Len(); i1++) {
480      IAssert(FfPhaseTrans.FBPrGSetH.GetKey(i1) == FfPhaseTrans.FBPrGStatH.GetKey(i1));
481      const TFltPr& Key = FfPhaseTrans.FBPrGSetH.GetKey(i1);
482      if (! FBPrGStatH.IsKey(Key)) {
483        const PGrowthStat Stat = FfPhaseTrans.FBPrGStatH[i1];
484        const PGrowthSet Set = FfPhaseTrans.FBPrGSetH[i1];
485        FBPrGStatH.AddDat(Key, Stat);
486        FBPrGSetH.AddDat(Key, Set);
487      }
488    }
489    printf("  ** merged   %6d  (Fwd,Bck) pairs\n", Len());
490  }
491  /&bsol;*/
492  int TUndirFFire::BurnGeoFire(const int& StartNId) {
493    BurnedSet.Clr(false);
494    BurningNIdV.Clr(false);  
495    NewBurnedNIdV.Clr(false);
496    AliveNIdV.Clr(false);
497    const TUNGraph& G = *Graph;
498    int NBurned = 1;
499    BurnedSet.AddKey(StartNId);
500    BurningNIdV.Add(StartNId);
501    while (! BurningNIdV.Empty()) {
502      for (int node = 0; node < BurningNIdV.Len(); node++) {
503        const int& BurningNId = BurningNIdV[node];
504        const TUNGraph::TNodeI& Node = G.GetNI(BurningNId);
505        AliveNIdV.Clr(false); 
506        for (int e = 0; e < Node.GetOutDeg(); e++) {
507          const int OutNId = Node.GetOutNId(e);
508          if (! BurnedSet.IsKey(OutNId)) {
509            AliveNIdV.Add(OutNId); }
510        }
511        const int BurnNLinks = Rnd.GetGeoDev(1.0-BurnProb) - 1;
512        if (! AliveNIdV.Empty() && BurnNLinks > 0) {
513          AliveNIdV.Shuffle(Rnd);
514          for (int i = 0; i < TMath::Mn(BurnNLinks, AliveNIdV.Len()); i++) {
515            BurnedSet.AddKey(AliveNIdV[i]);
516            NewBurnedNIdV.Add(AliveNIdV[i]);
517            NBurned++;
518          }
519        }
520      }
521      BurningNIdV.Swap(NewBurnedNIdV);   
522      NewBurnedNIdV.Clr(false);
523    }
524    IAssert(BurnedSet.Len() == NBurned);
525    return NBurned;
526  }
527  TFfGGen::TStopReason TUndirFFire::AddNodes(const int& GraphNodes, const bool& FloodStop) {
528    printf("\n***Undirected GEO ForestFire: graph(%d,%d) add %d nodes, burn prob %.3f\n", 
529      Graph->GetNodes(), Graph->GetEdges(), GraphNodes, BurnProb);
530    TExeTm ExeTm;
531    int Burned1=0, Burned2=0, Burned3=0; 
532    TIntPrV NodesEdgesV;
533    if (Graph.Empty()) { Graph = PUNGraph::New(); }
534    if (Graph->GetNodes() == 0) { Graph->AddNode(); }
535    int NEdges = Graph->GetEdges();
536    for (int NNodes = Graph->GetNodes()+1; NNodes <= GraphNodes; NNodes++) {
537      const int NewNId = Graph->AddNode(-1);
538      IAssert(NewNId == Graph->GetNodes()-1); 
539      const int StartNId = Rnd.GetUniDevInt(NewNId);
540      const int NBurned = BurnGeoFire(StartNId);
541      for (int e = 0; e < NBurned; e++) {
542        Graph->AddEdge(NewNId, GetBurnedNId(e)); }
543      NEdges += NBurned;
544      Burned1=Burned2;  Burned2=Burned3;  Burned3=NBurned;
545      if (NNodes % Kilo(1) == 0) {
546        printf("(%d, %d)    burned: [%d,%d,%d]  [%s]\n", NNodes, NEdges, Burned1, Burned2, Burned3, ExeTm.GetStr()); 
547        NodesEdgesV.Add(TIntPr(NNodes, NEdges));
548      }
549      if (FloodStop && NEdges>1000 && NEdges/double(NNodes)>100.0) { 
550        printf("!!! FLOOD. G(%6d, %6d)\n", NNodes, NEdges);  return TFfGGen::srFlood; }
551    }
552    printf("\n");
553    IAssert(Graph->GetEdges() == NEdges);
554    return TFfGGen::srOk;
555  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ff.cpp</h3>
            <pre><code>1  void TForestFire::InfectAll() {
2    InfectNIdV.Gen(Graph->GetNodes());
3    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
4      InfectNIdV.Add(NI.GetId()); }
5  }
6  void TForestFire::InfectRnd(const int& NInfect) {
7    IAssert(NInfect < Graph->GetNodes());
8    TIntV NIdV(Graph->GetNodes(), 0);
9    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
10      NIdV.Add(NI.GetId()); }
11    NIdV.Shuffle(Rnd);
12    InfectNIdV.Gen(NInfect, 0);
13    for (int i = 0; i < NInfect; i++) {
14      InfectNIdV.Add(NIdV[i]); }
15  }
16  void TForestFire::BurnExpFire() {
17    const double OldFwdBurnProb = FwdBurnProb;
18    const double OldBckBurnProb = BckBurnProb;
19    const int NInfect = InfectNIdV.Len();
20    const TNGraph& G = *Graph;
21    TIntH BurnedNIdH;               
22    TIntV BurningNIdV = InfectNIdV; 
23    TIntV NewBurnedNIdV;            
24    bool HasAliveNbrs;              
25    int NBurned = NInfect, NDiedFire=0;
26    for (int i = 0; i < InfectNIdV.Len(); i++) {
27      BurnedNIdH.AddDat(InfectNIdV[i]); }
28    NBurnedTmV.Clr(false);  NBurningTmV.Clr(false);  NewBurnedTmV.Clr(false);
29    for (int time = 0; ; time++) {
30      NewBurnedNIdV.Clr(false);
31      for (int node = 0; node < BurningNIdV.Len(); node++) {
32        const int& BurningNId = BurningNIdV[node];
33        const TNGraph::TNodeI Node = G.GetNI(BurningNId);
34        HasAliveNbrs = false;
35        NDiedFire = 0;
36        for (int e = 0; e < Node.GetOutDeg(); e++) {
37          const int OutNId = Node.GetOutNId(e);
38          if (! BurnedNIdH.IsKey(OutNId)) { 
39            HasAliveNbrs = true;
40            if (Rnd.GetUniDev() < FwdBurnProb) {
41              BurnedNIdH.AddDat(OutNId);  NewBurnedNIdV.Add(OutNId);  NBurned++; }
42          }
43        }
44        if (BckBurnProb > 0.0) {
45          for (int e = 0; e < Node.GetInDeg(); e++) {
46            const int InNId = Node.GetInNId(e);
47            if (! BurnedNIdH.IsKey(InNId)) { 
48              HasAliveNbrs = true;
49              if (Rnd.GetUniDev() < BckBurnProb) {
50                BurnedNIdH.AddDat(InNId);  NewBurnedNIdV.Add(InNId);  NBurned++; }
51            }
52          }
53        }
54        if (! HasAliveNbrs) { NDiedFire++; }
55      }
56      NBurnedTmV.Add(NBurned);
57      NBurningTmV.Add(BurningNIdV.Len() - NDiedFire);
58      NewBurnedTmV.Add(NewBurnedNIdV.Len());
59      BurningNIdV.Swap(NewBurnedNIdV);    
60      if (BurningNIdV.Empty()) break;
61      FwdBurnProb = FwdBurnProb * ProbDecay;
62      BckBurnProb = BckBurnProb * ProbDecay;
63    }
64    BurnedNIdV.Gen(BurnedNIdH.Len(), 0);
65    for (int i = 0; i < BurnedNIdH.Len(); i++) {
66      BurnedNIdV.Add(BurnedNIdH.GetKey(i)); }
67    FwdBurnProb = OldFwdBurnProb;
68    BckBurnProb = OldBckBurnProb;
69  }
70  void TForestFire::BurnGeoFire() {
71    const double OldFwdBurnProb=FwdBurnProb;
72    const double OldBckBurnProb=BckBurnProb;
73    const int& NInfect = InfectNIdV.Len();
74    const TNGraph& G = *Graph;
75    TIntH BurnedNIdH;               
76    TIntV BurningNIdV = InfectNIdV; 
77    TIntV NewBurnedNIdV;            
78    bool HasAliveInNbrs, HasAliveOutNbrs; 
79    TIntV AliveNIdV;                
80    int NBurned = NInfect, time;
81    for (int i = 0; i < InfectNIdV.Len(); i++) {
82      BurnedNIdH.AddDat(InfectNIdV[i]); }
83    NBurnedTmV.Clr(false);  NBurningTmV.Clr(false);  NewBurnedTmV.Clr(false);
84    for (time = 0; ; time++) {
85      NewBurnedNIdV.Clr(false);
86      for (int node = 0; node < BurningNIdV.Len(); node++) {
87        const int& BurningNId = BurningNIdV[node];
88        const TNGraph::TNodeI Node = G.GetNI(BurningNId);
89        HasAliveOutNbrs = false;
90        AliveNIdV.Clr(false); 
91        for (int e = 0; e < Node.GetOutDeg(); e++) {
92          const int OutNId = Node.GetOutNId(e);
93          if (! BurnedNIdH.IsKey(OutNId)) {
94            HasAliveOutNbrs = true;  AliveNIdV.Add(OutNId); }
95        }
96        const int BurnNFwdLinks = Rnd.GetGeoDev(1.0-FwdBurnProb) - 1;
97        if (HasAliveOutNbrs && BurnNFwdLinks > 0) {
98          AliveNIdV.Shuffle(Rnd);
99          for (int i = 0; i < TMath::Mn(BurnNFwdLinks, AliveNIdV.Len()); i++) {
100            BurnedNIdH.AddDat(AliveNIdV[i]);
101            NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
102        }
103        if (BckBurnProb > 0.0) {
104          HasAliveInNbrs = false;
105          AliveNIdV.Clr(false);
106          for (int e = 0; e < Node.GetInDeg(); e++) {
107            const int InNId = Node.GetInNId(e);
108            if (! BurnedNIdH.IsKey(InNId)) {
<span onclick='openModal()' class='match'>109              HasAliveInNbrs = true;  AliveNIdV.Add(InNId); }
110          }
111          const int BurnNBckLinks = Rnd.GetGeoDev(1.0-BckBurnProb) - 1;
112          if (HasAliveInNbrs && BurnNBckLinks > 0) {
113            AliveNIdV.Shuffle(Rnd);
114            for (int i = 0; i < TMath::Mn(BurnNBckLinks, AliveNIdV.Len()); i++) {
115              BurnedNIdH.AddDat(AliveNIdV[i]);
116              NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
117          }
118        }
</span>119      }
120      NBurnedTmV.Add(NBurned);  NBurningTmV.Add(BurningNIdV.Len());  NewBurnedTmV.Add(NewBurnedNIdV.Len());
121      BurningNIdV.Swap(NewBurnedNIdV);   
122      if (BurningNIdV.Empty()) break;
123      FwdBurnProb = FwdBurnProb * ProbDecay;
124      BckBurnProb = BckBurnProb * ProbDecay;
125    }
126    BurnedNIdV.Gen(BurnedNIdH.Len(), 0);
127    for (int i = 0; i < BurnedNIdH.Len(); i++) {
128      BurnedNIdV.Add(BurnedNIdH.GetKey(i)); }
129    FwdBurnProb = OldFwdBurnProb;
130    BckBurnProb = OldBckBurnProb;
131  }
132  void TForestFire::PlotFire(const TStr& FNmPref, const TStr& Desc, const bool& PlotAllBurned) {
133    TGnuPlot GnuPlot(FNmPref, TStr::Fmt("%s. ForestFire. G(%d, %d). Fwd:%g  Bck:%g  NInfect:%d",
134      Desc.CStr(), Graph->GetNodes(), Graph->GetEdges(), FwdBurnProb(), BckBurnProb(), InfectNIdV.Len()));
135    GnuPlot.SetXYLabel("TIME EPOCH", "Number of NODES");
136    if (PlotAllBurned) GnuPlot.AddPlot(NBurnedTmV, gpwLinesPoints, "All burned nodes till time");
137    GnuPlot.AddPlot(NBurningTmV, gpwLinesPoints, "Burning nodes at time");
138    GnuPlot.AddPlot(NewBurnedTmV, gpwLinesPoints, "Newly burned nodes at time");
139    GnuPlot.SavePng(TFile::GetUniqueFNm(TStr::Fmt("fireSz.%s_#.png", FNmPref.CStr())));
140  }
141  PNGraph TForestFire::GenGraph(const int& Nodes, const double& FwdProb, const double& BckProb) {
142    TFfGGen Ff(false, 1, FwdProb, BckProb, 1.0, 0.0, 0.0);
143    Ff.GenGraph(Nodes);
144    return Ff.GetGraph();
145  }
146  int TFfGGen::TimeLimitSec = 30*60; 
147  TFfGGen::TFfGGen(const bool& BurnExpFireP, const int& StartNNodes, const double& ForwBurnProb,
148                   const double& BackBurnProb, const double& DecayProb, const double& Take2AmbasPrb, const double& OrphanPrb) :
149   Graph(), BurnExpFire(BurnExpFireP), StartNodes(StartNNodes), FwdBurnProb(ForwBurnProb),
150   BckBurnProb(BackBurnProb), ProbDecay(DecayProb), Take2AmbProb(Take2AmbasPrb), OrphanProb(OrphanPrb) {
151  }
152  TStr TFfGGen::GetParamStr() const {
153    return TStr::Fmt("%s  FWD:%g  BCK:%g, StartNds:%d, Take2:%g, Orphan:%g, ProbDecay:%g",
154      BurnExpFire?"EXP":"GEO", FwdBurnProb(), BckBurnProb(), StartNodes(), Take2AmbProb(), OrphanProb(), ProbDecay());
155  }
156  TFfGGen::TStopReason TFfGGen::AddNodes(const int& GraphNodes, const bool& FloodStop) {
157    printf("\n***ForestFire:  %s  Nodes:%d  StartNodes:%d  Take2AmbProb:%g\n", BurnExpFire?"ExpFire":"GeoFire", GraphNodes, StartNodes(), Take2AmbProb());
158    printf("                FwdBurnP:%g  BckBurnP:%g  ProbDecay:%g  Orphan:%g\n", FwdBurnProb(), BckBurnProb(), ProbDecay(), OrphanProb());
159    TExeTm ExeTm;
160    int Burned1=0, Burned2=0, Burned3=0; 
161    if (Graph.Empty()) { Graph = PNGraph::New(); }
162    if (Graph->GetNodes() == 0) {
163      for (int n = 0; n < StartNodes; n++) { Graph->AddNode(); }
164    }
165    int NEdges = Graph->GetEdges();
166    TRnd Rnd(0);
167    TForestFire ForestFire(Graph, FwdBurnProb, BckBurnProb, ProbDecay, 0);
168    for (int NNodes = Graph->GetNodes()+1; NNodes <= GraphNodes; NNodes++) {
169      const int NewNId = Graph->AddNode(-1);
170      IAssert(NewNId == Graph->GetNodes()-1); 
171      if (OrphanProb == 0.0 || Rnd.GetUniDev() > OrphanProb) {
172        if (Take2AmbProb == 0.0 || Rnd.GetUniDev() > Take2AmbProb || NewNId < 2) {
173          ForestFire.Infect(Rnd.GetUniDevInt(NewNId)); 
174        } else {
175          const int AmbassadorNId1 = Rnd.GetUniDevInt(NewNId);
176          int AmbassadorNId2 = Rnd.GetUniDevInt(NewNId);
177          while (AmbassadorNId1 == AmbassadorNId2) {
178            AmbassadorNId2 = Rnd.GetUniDevInt(NewNId); }
179          ForestFire.Infect(TIntV::GetV(AmbassadorNId1, AmbassadorNId2)); 
180        }
181        if (BurnExpFire) { ForestFire.BurnExpFire(); }
182        else { ForestFire.BurnGeoFire(); }
183        for (int e = 0; e < ForestFire.GetBurned(); e++) {
184          Graph->AddEdge(NewNId, ForestFire.GetBurnedNId(e));
185          NEdges++;
186        }
187        Burned1=Burned2;  Burned2=Burned3;  Burned3=ForestFire.GetBurned();
188      } else {
189        Burned1=Burned2;  Burned2=Burned3;  Burned3=0;
190      }
191      if (NNodes % Kilo(1) == 0) {
192        printf("(%d, %d)  burned: [%d,%d,%d]  [%s]\n", NNodes, NEdges, Burned1, Burned2, Burned3, ExeTm.GetStr()); }
193      if (FloodStop && NEdges>GraphNodes && (NEdges/double(NNodes)>1000.0)) { 
194        printf(". FLOOD. G(%6d, %6d)\n", NNodes, NEdges);  return srFlood; }
195      if (NNodes % 1000 == 0 && TimeLimitSec > 0 && ExeTm.GetSecs() > TimeLimitSec) {
196        printf(". TIME LIMIT. G(%d, %d)\n", Graph->GetNodes(), Graph->GetEdges());
197        return srTimeLimit; }
198    }
199    IAssert(Graph->GetEdges() == NEdges);
200    return srOk;
201  }
202  TFfGGen::TStopReason TFfGGen::GenGraph(const int& GraphNodes, const bool& FloodStop) {
203    Graph = PNGraph::New();
204    return AddNodes(GraphNodes, FloodStop);
205  }
206  TFfGGen::TStopReason TFfGGen::GenGraph(const int& GraphNodes, PGStatVec& EvolStat, const bool& FloodStop) {
207    int GrowthStatNodes = 100;
208    Graph = PNGraph::New();
209    AddNodes(StartNodes);
210    TStopReason SR = srUndef;
211    while (Graph->GetNodes() < GraphNodes) {
212      SR = AddNodes(GrowthStatNodes, FloodStop);
213      if (SR != srOk) { return SR; }
214      EvolStat->Add(Graph, TSecTm(Graph->GetNodes()));
215      GrowthStatNodes = int(1.5*GrowthStatNodes);
216    }
217    return SR;
218  }
219  void TFfGGen::PlotFireSize(const TStr& FNmPref, const TStr& DescStr) {
220    TGnuPlot GnuPlot("fs."+FNmPref, TStr::Fmt("%s. Fire size. G(%d, %d)",
221      DescStr.CStr(), Graph->GetNodes(), Graph->GetEdges()));
222    GnuPlot.SetXYLabel("Vertex id (iterations)", "Fire size (node out-degree)");
223    TFltPrV IdToOutDegV;
224    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
225      IdToOutDegV.Add(TFltPr(NI.GetId(), NI.GetOutDeg())); }
226    IdToOutDegV.Sort();
227    GnuPlot.AddPlot(IdToOutDegV, gpwImpulses, "Node out-degree");
228    GnuPlot.SavePng();
229  }
230  void TFfGGen::GenFFGraphs(const double& FProb, const double& BProb, const TStr& FNm) {
231    const int NRuns = 10;
232    const int NNodes = 10000;
233    TGStat::NDiamRuns = 10;
234    TVec<PGStatVec> GAtTmV;
235    TFfGGen FF(false, 1, FProb, BProb, 1.0, 0, 0);
236    for (int r = 0; r < NRuns; r++) {
237      PGStatVec GV = TGStatVec::New(tmuNodes, TGStat::AllStat());
238      FF.GenGraph(NNodes, GV, true);
239      for (int i = 0; i < GV->Len(); i++) {
240        if (i == GAtTmV.Len()) {
241          GAtTmV.Add(TGStatVec::New(tmuNodes, TGStat::AllStat()));
242        }
243        GAtTmV[i]->Add(GV->At(i));
244      }
245      IAssert(GAtTmV.Len() == GV->Len());
246    }
247    PGStatVec AvgStat = TGStatVec::New(tmuNodes, TGStat::AllStat());
248    for (int i = 0; i < GAtTmV.Len(); i++) {
249      AvgStat->Add(GAtTmV[i]->GetAvgGStat(false));
250    }
251    AvgStat->PlotAllVsX(gsvNodes, FNm, TStr::Fmt("Forest Fire: F:%g  B:%g (%d runs)", FProb, BProb, NRuns));
252    AvgStat->Last()->PlotAll(FNm, TStr::Fmt("Forest Fire: F:%g  B:%g (%d runs)", FProb, BProb, NRuns));
253  }
254  &bsol;* ForestFire.GenGraph(NNodes, true);
255      if (! ForestFire.GetGrowthStat()->Empty()) {
256        GrowthSet->Add(ForestFire.GetGrowthStat()); }
257    }
258    IAssert(! GrowthSet.Empty());
259    FBPrGSetH.AddDat(TFltPr(FwdProb, BckProb), GrowthSet);
260    PGrowthStat AvgStat = TGrowthStat::New();
261    AvgStat->AvgGrowthStat(*GrowthSet);
262    FBPrGStatH.AddDat(TFltPr(FwdProb, BckProb), AvgStat);
263    const double DiamCf = LastDecDiam().Val1;
264    const double GplCf = LastGplCf().Val1;
265    if (Plot && ! AvgStat.Empty()) {
266      const TStr FNm = TStr::Fmt("F%04d.B%04d", int(FwdProb*10000), int(BckProb*10000));
267      const TStr Title = GetTitleStr(Len()-1);
268      AvgStat->PlotDiam(FNm, Title);
269      AvgStat->PlotGpl(FNm, Title, true, false, false, false, false);
270    }
271    return TFltPr(GplCf, DiamCf);
272  }
273  void TFfPhaseTrans::FwdProbSteps(const double& MinFwdProb, const double& MaxFwdProb, const double& BckProb) {
274    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFwd.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
275    TFfGGen::TimeLimitSec = 10*60;
276    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
277      RunForestFire(FwdProb, BckProb, true);
278      { TFOut FOut(BinFNm);
279      Save(FOut); }
280    }
281  }
282  void TFfPhaseTrans::FwdProbStepsFact(const double& MinFwdProb, const double& MaxFwdProb, const double& BckFact) {
283    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFwd.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
284    TFfGGen::TimeLimitSec = 10*60;
285    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
286      RunForestFire(FwdProb, BckFact*FwdProb, true);
287      { TFOut FOut(BinFNm);
288      Save(FOut); }
289    }
290  }
291  void TFfPhaseTrans::FwdBckPhasePlot(const double& MinFwdProb, const double& MaxFwdProb, const double& MinBckFact,
292                                      const double& MaxBckFact, const int& TimeLimitSec) {
293    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFF.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
294    TFfGGen::TimeLimitSec = TimeLimitSec;
295    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
296      for (double BckFact = MinBckFact; BckFact < MaxBckFact+0.001; BckFact += ProbInc) {
297        const double BckProb = FwdProb * BckFact;
298        RunForestFire(FwdProb, BckProb, true);
299        { TFOut FOut(BinFNm);
300        Save(FOut); }
301      }
302    }
303  }
304  void TFfPhaseTrans::FindGplPhaseTr(const double& StartFProb, const double& FollowGplCf, const TStr& FNmPref, const TStr& Desc) {
305    const TStr FNm = TStr::Fmt("phGPL.%s", GetFNm(FNmPref).CStr());
306    const double Tolerance = 0.01;
307    const double MinDelta = 0.001;
308    const bool Plot = false;
309    TFfGGen::TimeLimitSec = 10*60;
310    TGrowthStat::MinNodesEdges = 2*(StartNodes-1)+100;
311    const int OldNDiamRuns = TGraphStat::NDiamRuns;
312    TGraphStat::NDiamRuns = 1;  
313    TakeStat(TFSet() | gsEffDiam);
314    FILE *F = fopen((FNm+".txt").CStr(), "wt");
315    fprintf(F, "FollowGplCf:  %g\n", FollowGplCf);
316    fprintf(F, "StartNodes:   %d\n", StartNodes());
317    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
318    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
319    fprintf(F, "Tolerance:    %g\n", Tolerance);
320    double FwdProb = StartFProb, LBckRat=0, RBckRat=1, BckRat, GplCf;
321    while (FwdProb < 1.0) {
322      while (true) {
323        BckRat = (RBckRat+LBckRat) / 2;
324        fprintf(F, "FWD: %g, (%f -- %f)", FwdProb, LBckRat, RBckRat);
325        GplCf = RunForestFire(FwdProb, FwdProb*BckRat, Plot).Val1;
326        IAssert(GplCf != -1);
327        fprintf(F, "  %f  gpl: %.4f (%.4f)", BckRat, GplCf, LastGplCf().Val2());
328        if (TMath::IsInEps(GplCf - FollowGplCf, Tolerance)) { fprintf(F, "  ***\n"); break; }
329        if (RBckRat-LBckRat < MinDelta) { fprintf(F, "  gap\n"); break; }
330        if (GplCf > FollowGplCf) { RBckRat = BckRat; } else { LBckRat = BckRat; }
331        fprintf(F, "\n");  fflush(F);
332      }
333      FwdProb += ProbInc;
334      RBckRat = BckRat+0.01;
335      if (RBckRat > 1.0) RBckRat = 1.0;
336      LBckRat = RBckRat - 0.2;
337      if (LBckRat < 0.0) LBckRat = 0.0;
338      { TFOut FOut(FNm+".bin");
339       Save(FOut); }
340      SaveGplPhaseTr(FollowGplCf, FNmPref, Desc);
341      fprintf(F, "\n");
342    }
343    fclose(F);
344    TGraphStat::NDiamRuns = OldNDiamRuns;
345  }
346  void TFfPhaseTrans::SaveGplPhaseTr(const double& FollowGplCf, const TStr& FNmPref, const TStr& Desc) {
347    const double Tolerance = 0.02;
348    THash<TFlt,  TIntFltPr> FProbH;
349    for (int i = 0; i < Len(); i ++) {
350      const double FProb = GetFProb(i);
351      const double GplCf = GetGplCf(i).Val1;
352      if (TMath::IsInEps(GplCf-FollowGplCf, Tolerance)) {
353        if (! FProbH.IsKey(FProb)) {
354          FProbH.AddDat(FProb, TIntFltPr(i, GplCf)); }
355        else {
356          const double bestCf = FProbH.GetDat(FProb).Val2;
357          if (fabs(bestCf - FollowGplCf) > fabs(GplCf - FollowGplCf)) {
358            FProbH.AddDat(FProb, TIntFltPr(i, GplCf)); }
359        }
360      }
361    }
362    TVec<TPair<TFlt, TIntFltPr> > FProbV;
363    FProbH.GetKeyDatPrV(FProbV);  FProbV.Sort();
364    const bool HasDiam = TakeStatSet.In(gsEffDiam);
365    FILE *F = fopen(TStr::Fmt("phGPL.%s.tab", GetFNm(FNmPref).CStr()).CStr(), "wt");
366    if (! Desc.Empty()) fprintf(F, "%s\n", Desc.CStr());
367    fprintf(F, "FollowGplCf:  %g\n", FollowGplCf);
368    fprintf(F, "StartNodes:   %d\n", StartNodes());
369    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
370    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
371    fprintf(F, "Tolerance:    %g\n", Tolerance);
372    fprintf(F, "id\tFProb\tBProb\tBRatio\tGlp\tGlpDev");
373    if (HasDiam) {  fprintf(F, "\tDiamCf\tDiamDev\tEffDiam"); }
374    fprintf(F, "\n");
375    for (int i = 0; i < FProbH.Len(); i++) {
376      const int Id = FProbV[i].Val2.Val1;
377      const TFltPr Gpl = GetGplCf(Id);
378      fprintf(F, "%d\t%f\t%f\t%f\t", Id, GetFProb(Id), GetBProb(Id), GetBProb(Id)/GetFProb(Id));
379      fprintf(F, "%f\t%f", Gpl.Val1(), Gpl.Val2());
380      if (HasDiam) {
381        const TFltPr DiamCf = GetDecDiam(Id);
382        fprintf(F, "\t%f\t%f\t%f", DiamCf.Val1(), DiamCf.Val2(), GetEffDiam(Id, -1).Val1());
383      }
384      fprintf(F, "\n");
385    }
386    fclose(F);
387  }
388  void TFfPhaseTrans::FindDiamPhaseTr(const double& StartFProb, const double& FollowDiamCf, const TStr& FNmPref, const TStr& Desc) {
389    const TStr FNm = TStr::Fmt("phDIAM.%s", GetFNm(FNmPref).CStr());
390    const double Tolerance = 0.01;
391    const double MinDelta = 0.001;
392    const bool Plot = false;
393    TFfGGen::TimeLimitSec = 10*60;
394    const int OldNDiamRuns = TGraphStat::NDiamRuns;
395    TGraphStat::NDiamRuns = 1;
396    TGrowthStat::MinNodesEdges = 2*(StartNodes-1)+100;
397    TakeStat(TFSet() | gsEffDiam);
398    FILE *F = fopen((FNm+".txt").CStr(), "wt");
399    fprintf(F, "FollowDiamCf: %g\n", FollowDiamCf);
400    fprintf(F, "StartNodes:   %d\n", StartNodes());
401    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
402    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
403    fprintf(F, "Tolerance:    %g\n", Tolerance);
404    double FwdProb = StartFProb, LBckRat=0, RBckRat=1, BckRat, DiamCf;
405    while (FwdProb < 1.0) {
406      while (true) {
407        BckRat = (RBckRat+LBckRat) / 2;
408        fprintf(F, "FWD: %g, (%f -- %f)", FwdProb, LBckRat, RBckRat);
409        DiamCf = RunForestFire(FwdProb, FwdProb*BckRat, Plot).Val2;
410        IAssert(DiamCf != -1);
411        fprintf(F, "  %f  diam: %.4f (%.4f)", BckRat, DiamCf, LastDecDiam().Val2());
412        if (TMath::IsInEps(DiamCf - FollowDiamCf, Tolerance)) { fprintf(F, "  ***\n"); break; }
413        if (RBckRat-LBckRat < MinDelta) { fprintf(F, "  gap\n"); break; }
414        if (DiamCf < FollowDiamCf) { RBckRat = BckRat; } else { LBckRat = BckRat; }
415        fprintf(F, "\n");  fflush(F);
416      }
417      FwdProb += ProbInc;
418      RBckRat = BckRat+0.05;
419      if (RBckRat > 1.0) RBckRat = 1.0;
420      LBckRat = RBckRat - 0.15;
421      if (LBckRat < 0.0) LBckRat = 0.0;
422      { TFOut FOut(FNm+".bin");
423      Save(FOut); }
424      SaveDiamPhaseTr(FollowDiamCf, FNmPref, Desc);
425      fprintf(F, "\n");
426    }
427    fclose(F);
428    TGraphStat::NDiamRuns = OldNDiamRuns;
429  }
430  void TFfPhaseTrans::SaveDiamPhaseTr(const double& FollowDiamCf, const TStr& FNmPref, const TStr& Desc) {
431    const double Tolerance = 0.03;
432    THash<TFlt,  TIntFltPr> FProbH;
433    for (int i = 0; i < Len(); i ++) {
434      const double FProb = GetFProb(i);
435      const double DiamCf = GetDecDiam(i).Val1;
436      if (TMath::IsInEps(DiamCf - FollowDiamCf, Tolerance)) {
437        if (! FProbH.IsKey(FProb)) {
438          FProbH.AddDat(FProb, TIntFltPr(i, DiamCf)); }
439        else {
440          const double bestCf = FProbH.GetDat(FProb).Val2;
441          if (fabs(bestCf - FollowDiamCf) > fabs(DiamCf - FollowDiamCf)) {
442            FProbH.AddDat(FProb, TIntFltPr(i, DiamCf)); }
443        }
444      }
445    }
446    TVec<TPair<TFlt, TIntFltPr> > FProbV;
447    FProbH.GetKeyDatPrV(FProbV);  FProbV.Sort();
448    FILE *F = fopen(TStr::Fmt("phDIAM.%s.tab", GetFNm(FNmPref).CStr()).CStr(), "wt");
449    if (! Desc.Empty()) fprintf(F, "%s\n", Desc.CStr());
450    fprintf(F, "FollowDiamCf: %g\n", FollowDiamCf);
451    fprintf(F, "StartNodes:   %d\n", StartNodes());
452    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
453    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
454    fprintf(F, "Tolerance:    %g\n", Tolerance);
455    fprintf(F, "id\tFProb\tBProb\tBRatio\tDiamCf\tDiamDev\tGplCf\tGplDev\tEffDiam\n");
456    for (int i = 0; i < FProbV.Len(); i++) {
457      const int Id = FProbV[i].Val2.Val1;
458      const TFltPr DiamCf = GetDecDiam(Id);
459      const TFltPr GplCf = GetGplCf(Id);
460      const TFltPr EffDiam = GetEffDiam(Id, -1);
461      fprintf(F, "%d\t%f\t%f\t%f\t", Id, GetFProb(Id), GetBProb(Id), GetBProb(Id)/GetFProb(Id));
462      fprintf(F, "%f\t%f\t%f\t%f\t%f\n", DiamCf.Val1(), DiamCf.Val2(), GplCf.Val1(), GplCf.Val2(), EffDiam.Val1());
463    }
464    fclose(F);
465  }
466  void TFfPhaseTrans::Merge(const PFfPhaseTrans& FfPhaseTrans) {
467    Merge(*FfPhaseTrans);
468  }
469  void TFfPhaseTrans::Merge(const TFfPhaseTrans& FfPhaseTrans) {
470    printf("Merging:\n");
471    printf("  source      %6d  (Fwd,Bck) pairs\n", FfPhaseTrans.Len());
472    printf("  destination %6d  (Fwd,Bck) pairs\n", Len());
473    IAssert(BurExpFire == FfPhaseTrans.BurExpFire);
474    IAssert(NNodes == FfPhaseTrans.NNodes);
475    IAssert(StartNodes == FfPhaseTrans.StartNodes);
476    IAssert(Take2AmbProb == FfPhaseTrans.Take2AmbProb);
477    IAssert(FBPrGSetH.Len() == FBPrGStatH.Len());
478    IAssert(FfPhaseTrans.FBPrGSetH.Len() == FfPhaseTrans.FBPrGStatH.Len());
479    for (int i1 = 0; i1 < FfPhaseTrans.FBPrGSetH.Len(); i1++) {
480      IAssert(FfPhaseTrans.FBPrGSetH.GetKey(i1) == FfPhaseTrans.FBPrGStatH.GetKey(i1));
481      const TFltPr& Key = FfPhaseTrans.FBPrGSetH.GetKey(i1);
482      if (! FBPrGStatH.IsKey(Key)) {
483        const PGrowthStat Stat = FfPhaseTrans.FBPrGStatH[i1];
484        const PGrowthSet Set = FfPhaseTrans.FBPrGSetH[i1];
485        FBPrGStatH.AddDat(Key, Stat);
486        FBPrGSetH.AddDat(Key, Set);
487      }
488    }
489    printf("  ** merged   %6d  (Fwd,Bck) pairs\n", Len());
490  }
491  /&bsol;*/
492  int TUndirFFire::BurnGeoFire(const int& StartNId) {
493    BurnedSet.Clr(false);
494    BurningNIdV.Clr(false);  
495    NewBurnedNIdV.Clr(false);
496    AliveNIdV.Clr(false);
497    const TUNGraph& G = *Graph;
498    int NBurned = 1;
499    BurnedSet.AddKey(StartNId);
500    BurningNIdV.Add(StartNId);
501    while (! BurningNIdV.Empty()) {
502      for (int node = 0; node < BurningNIdV.Len(); node++) {
503        const int& BurningNId = BurningNIdV[node];
504        const TUNGraph::TNodeI& Node = G.GetNI(BurningNId);
505        AliveNIdV.Clr(false); 
506        for (int e = 0; e < Node.GetOutDeg(); e++) {
507          const int OutNId = Node.GetOutNId(e);
508          if (! BurnedSet.IsKey(OutNId)) {
509            AliveNIdV.Add(OutNId); }
510        }
511        const int BurnNLinks = Rnd.GetGeoDev(1.0-BurnProb) - 1;
512        if (! AliveNIdV.Empty() && BurnNLinks > 0) {
513          AliveNIdV.Shuffle(Rnd);
514          for (int i = 0; i < TMath::Mn(BurnNLinks, AliveNIdV.Len()); i++) {
515            BurnedSet.AddKey(AliveNIdV[i]);
516            NewBurnedNIdV.Add(AliveNIdV[i]);
517            NBurned++;
518          }
519        }
520      }
521      BurningNIdV.Swap(NewBurnedNIdV);   
522      NewBurnedNIdV.Clr(false);
523    }
524    IAssert(BurnedSet.Len() == NBurned);
525    return NBurned;
526  }
527  TFfGGen::TStopReason TUndirFFire::AddNodes(const int& GraphNodes, const bool& FloodStop) {
528    printf("\n***Undirected GEO ForestFire: graph(%d,%d) add %d nodes, burn prob %.3f\n", 
529      Graph->GetNodes(), Graph->GetEdges(), GraphNodes, BurnProb);
530    TExeTm ExeTm;
531    int Burned1=0, Burned2=0, Burned3=0; 
532    TIntPrV NodesEdgesV;
533    if (Graph.Empty()) { Graph = PUNGraph::New(); }
534    if (Graph->GetNodes() == 0) { Graph->AddNode(); }
535    int NEdges = Graph->GetEdges();
536    for (int NNodes = Graph->GetNodes()+1; NNodes <= GraphNodes; NNodes++) {
537      const int NewNId = Graph->AddNode(-1);
538      IAssert(NewNId == Graph->GetNodes()-1); 
539      const int StartNId = Rnd.GetUniDevInt(NewNId);
540      const int NBurned = BurnGeoFire(StartNId);
541      for (int e = 0; e < NBurned; e++) {
542        Graph->AddEdge(NewNId, GetBurnedNId(e)); }
543      NEdges += NBurned;
544      Burned1=Burned2;  Burned2=Burned3;  Burned3=NBurned;
545      if (NNodes % Kilo(1) == 0) {
546        printf("(%d, %d)    burned: [%d,%d,%d]  [%s]\n", NNodes, NEdges, Burned1, Burned2, Burned3, ExeTm.GetStr()); 
547        NodesEdgesV.Add(TIntPr(NNodes, NEdges));
548      }
549      if (FloodStop && NEdges>1000 && NEdges/double(NNodes)>100.0) { 
550        printf("!!! FLOOD. G(%6d, %6d)\n", NNodes, NEdges);  return TFfGGen::srFlood; }
551    }
552    printf("\n");
553    IAssert(Graph->GetEdges() == NEdges);
554    return TFfGGen::srOk;
555  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ff.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ff.cpp</div>
                </div>
                <div class="column column_space"><pre><code>94            HasAliveOutNbrs = true;  AliveNIdV.Add(OutNId); }
95        }
96        const int BurnNFwdLinks = Rnd.GetGeoDev(1.0-FwdBurnProb) - 1;
97        if (HasAliveOutNbrs && BurnNFwdLinks > 0) {
98          AliveNIdV.Shuffle(Rnd);
99          for (int i = 0; i < TMath::Mn(BurnNFwdLinks, AliveNIdV.Len()); i++) {
100            BurnedNIdH.AddDat(AliveNIdV[i]);
101            NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
102        }
103        if (BckBurnProb > 0.0) {
</pre></code></div>
                <div class="column column_space"><pre><code>109              HasAliveInNbrs = true;  AliveNIdV.Add(InNId); }
110          }
111          const int BurnNBckLinks = Rnd.GetGeoDev(1.0-BckBurnProb) - 1;
112          if (HasAliveInNbrs && BurnNBckLinks > 0) {
113            AliveNIdV.Shuffle(Rnd);
114            for (int i = 0; i < TMath::Mn(BurnNBckLinks, AliveNIdV.Len()); i++) {
115              BurnedNIdH.AddDat(AliveNIdV[i]);
116              NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
117          }
118        }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    