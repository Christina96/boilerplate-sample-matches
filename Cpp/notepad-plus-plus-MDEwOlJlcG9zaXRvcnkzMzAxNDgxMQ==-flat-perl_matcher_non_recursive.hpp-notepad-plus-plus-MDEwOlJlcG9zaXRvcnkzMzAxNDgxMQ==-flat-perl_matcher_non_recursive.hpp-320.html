
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher_non_recursive.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_PERL_MATCHER_NON_RECURSIVE_HPP
2  #define BOOST_REGEX_V5_PERL_MATCHER_NON_RECURSIVE_HPP
3  #include &lt;boost/regex/v5/mem_block_cache.hpp&gt;
4  #ifdef BOOST_REGEX_MSVC
5  #  pragma warning(push)
6  #  pragma warning(disable: 4706 4459)
7  #if BOOST_REGEX_MSVC &lt; 1910
8  #pragma warning(disable:4800)
9  #endif
10  #endif
11  namespace boost{
12  namespace BOOST_REGEX_DETAIL_NS{
13  template &lt;class T&gt;
14  inline void inplace_destroy(T* p)
15  {
16     (void)p;  
17     p-&gt;~T();
18  }
19  struct saved_state
20  {
21     union{
22        unsigned int state_id;
23        std::size_t padding1;
24        std::ptrdiff_t padding2;
25        void* padding3;
26     };
27     saved_state(unsigned i) : state_id(i) {}
28  };
29  template &lt;class BidiIterator&gt;
30  struct saved_matched_paren : public saved_state
31  {
32     int index;
33     sub_match&lt;BidiIterator&gt; sub;
34     saved_matched_paren(int i, const sub_match&lt;BidiIterator&gt;&amp; s) : saved_state(1), index(i), sub(s){}
35  };
36  template &lt;class BidiIterator&gt;
37  struct saved_position : public saved_state
38  {
39     const re_syntax_base* pstate;
40     BidiIterator position;
41     saved_position(const re_syntax_base* ps, BidiIterator pos, int i) : saved_state(i), pstate(ps), position(pos){}
42  };
43  template &lt;class BidiIterator&gt;
44  struct saved_assertion : public saved_position&lt;BidiIterator&gt;
45  {
46     bool positive;
47     saved_assertion(bool p, const re_syntax_base* ps, BidiIterator pos) 
48        : saved_position&lt;BidiIterator&gt;(ps, pos, saved_type_assertion), positive(p){}
49  };
50  template &lt;class BidiIterator&gt;
51  struct saved_repeater : public saved_state
52  {
53     repeater_count&lt;BidiIterator&gt; count;
54     saved_repeater(int i, repeater_count&lt;BidiIterator&gt;** s, BidiIterator start, int current_recursion_id)
55        : saved_state(saved_state_repeater_count), count(i, s, start, current_recursion_id){}
56  };
57  struct saved_extra_block : public saved_state
58  {
59     saved_state *base, *end;
60     saved_extra_block(saved_state* b, saved_state* e) 
61        : saved_state(saved_state_extra_block), base(b), end(e) {}
62  };
63  struct save_state_init
64  {
65     saved_state** stack;
66     save_state_init(saved_state** base, saved_state** end)
67        : stack(base)
68     {
69        *base = static_cast&lt;saved_state*&gt;(get_mem_block());
70        *end = reinterpret_cast&lt;saved_state*&gt;(reinterpret_cast&lt;char*&gt;(*base)+BOOST_REGEX_BLOCKSIZE);
71        --(*end);
72        (void) new (*end)saved_state(0);
73        BOOST_REGEX_ASSERT(*end &gt; *base);
74     }
75     ~save_state_init()
76     {
77        put_mem_block(*stack);
78        *stack = 0;
79     }
80  };
81  template &lt;class BidiIterator&gt;
82  struct saved_single_repeat : public saved_state
83  {
84     std::size_t count;
85     const re_repeat* rep;
86     BidiIterator last_position;
87     saved_single_repeat(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id) 
88        : saved_state(arg_id), count(c), rep(r), last_position(lp){}
89  };
90  template &lt;class Results&gt;
91  struct saved_recursion : public saved_state
92  {
93     saved_recursion(int idx, const re_syntax_base* p, Results* pr, Results* pr2) 
94        : saved_state(14), recursion_id(idx), preturn_address(p), internal_results(*pr), prior_results(*pr2) {}
95     int recursion_id;
96     const re_syntax_base* preturn_address;
97     Results internal_results, prior_results;
98  };
99  struct saved_change_case : public saved_state
100  {
101     bool icase;
102     saved_change_case(bool c) : saved_state(18), icase(c) {}
103  };
104  struct incrementer
105  {
106     incrementer(unsigned* pu) : m_pu(pu) { ++*m_pu; }
107     ~incrementer() { --*m_pu; }
108     bool operator &gt; (unsigned i) { return *m_pu &gt; i; }
109  private:
110     unsigned* m_pu;
111  };
112  template &lt;class BidiIterator, class Allocator, class traits&gt;
113  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_all_states()
114  {
115     static matcher_proc_type const s_match_vtable[34] = 
116     {
117        (&amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_startmark),
118        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_endmark,
119        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_literal,
120        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_start_line,
121        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_end_line,
122        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_wild,
123        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_match,
124        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_word_boundary,
125        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_within_word,
126        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_word_start,
127        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_word_end,
128        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_buffer_start,
129        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_buffer_end,
130        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_backref,
131        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_long_set,
132        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_set,
133        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_jump,
134        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_alt,
135        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_rep,
136        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_combining,
137        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_soft_buffer_end,
138        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_restart_continue,
139        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_dot_repeat_dispatch,
140        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_char_repeat,
141        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_set_repeat,
142        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_long_set_repeat,
143        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_backstep,
144        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_assert_backref,
145        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_toggle_case,
146        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_recursion,
147        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_fail,
148        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_accept,
149        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_commit,
150        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_then,
151     };
152     incrementer inc(&amp;m_recursions);
153     if(inc &gt; 80)
154        raise_error(traits_inst, regex_constants::error_complexity);
155     push_recursion_stopper();
156     do{
157        while(pstate)
158        {
159           matcher_proc_type proc = s_match_vtable[pstate-&gt;type];
160           ++state_count;
161           if(!(this-&gt;*proc)())
162           {
163              if(state_count &gt; max_state_count)
164                 raise_error(traits_inst, regex_constants::error_complexity);
165              if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
166                 m_has_partial_match = true;
167              bool successful_unwind = unwind(false);
168              if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
169                 m_has_partial_match = true;
170              if(!successful_unwind)
171                 return m_recursive_result;
172           }
173        }
174     }while(unwind(true));
175     return m_recursive_result;
176  }
177  template &lt;class BidiIterator, class Allocator, class traits&gt;
178  void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::extend_stack()
179  {
180     if(used_block_count)
181     {
182        --used_block_count;
183        saved_state* stack_base;
184        saved_state* backup_state;
185        stack_base = static_cast&lt;saved_state*&gt;(get_mem_block());
186        backup_state = reinterpret_cast&lt;saved_state*&gt;(reinterpret_cast&lt;char*&gt;(stack_base)+BOOST_REGEX_BLOCKSIZE);
187        saved_extra_block* block = static_cast&lt;saved_extra_block*&gt;(backup_state);
188        --block;
189        (void) new (block) saved_extra_block(m_stack_base, m_backup_state);
190        m_stack_base = stack_base;
191        m_backup_state = block;
192     }
193     else
194        raise_error(traits_inst, regex_constants::error_stack);
195  }
196  template &lt;class BidiIterator, class Allocator, class traits&gt;
197  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_matched_paren(int index, const sub_match&lt;BidiIterator&gt;&amp; sub)
198  {
199     saved_matched_paren&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_matched_paren&lt;BidiIterator&gt;*&gt;(m_backup_state);
200     --pmp;
201     if(pmp &lt; m_stack_base)
202     {
203        extend_stack();
204        pmp = static_cast&lt;saved_matched_paren&lt;BidiIterator&gt;*&gt;(m_backup_state);
205        --pmp;
206     }
207     (void) new (pmp)saved_matched_paren&lt;BidiIterator&gt;(index, sub);
208     m_backup_state = pmp;
209  }
210  template &lt;class BidiIterator, class Allocator, class traits&gt;
211  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_case_change(bool c)
212  {
213     saved_change_case* pmp = static_cast&lt;saved_change_case*&gt;(m_backup_state);
214     --pmp;
215     if(pmp &lt; m_stack_base)
216     {
217        extend_stack();
218        pmp = static_cast&lt;saved_change_case*&gt;(m_backup_state);
219        --pmp;
220     }
221     (void) new (pmp)saved_change_case(c);
222     m_backup_state = pmp;
223  }
224  template &lt;class BidiIterator, class Allocator, class traits&gt;
225  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_recursion_stopper()
226  {
227     saved_state* pmp = m_backup_state;
228     --pmp;
229     if(pmp &lt; m_stack_base)
230     {
231        extend_stack();
232        pmp = m_backup_state;
233        --pmp;
234     }
235     (void) new (pmp)saved_state(saved_type_recurse);
236     m_backup_state = pmp;
237  }
238  template &lt;class BidiIterator, class Allocator, class traits&gt;
239  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_assertion(const re_syntax_base* ps, bool positive)
240  {
241     saved_assertion&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_assertion&lt;BidiIterator&gt;*&gt;(m_backup_state);
242     --pmp;
243     if(pmp &lt; m_stack_base)
244     {
245        extend_stack();
246        pmp = static_cast&lt;saved_assertion&lt;BidiIterator&gt;*&gt;(m_backup_state);
247        --pmp;
248     }
249     (void) new (pmp)saved_assertion&lt;BidiIterator&gt;(positive, ps, position);
250     m_backup_state = pmp;
251  }
252  template &lt;class BidiIterator, class Allocator, class traits&gt;
253  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_alt(const re_syntax_base* ps)
254  {
255     saved_position&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
256     --pmp;
257     if(pmp &lt; m_stack_base)
258     {
259        extend_stack();
260        pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
261        --pmp;
262     }
263     (void) new (pmp)saved_position&lt;BidiIterator&gt;(ps, position, saved_state_alt);
264     m_backup_state = pmp;
265  }
266  template &lt;class BidiIterator, class Allocator, class traits&gt;
267  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_non_greedy_repeat(const re_syntax_base* ps)
268  {
269     saved_position&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
270     --pmp;
271     if(pmp &lt; m_stack_base)
272     {
273        extend_stack();
274        pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
275        --pmp;
276     }
277     (void) new (pmp)saved_position&lt;BidiIterator&gt;(ps, position, saved_state_non_greedy_long_repeat);
278     m_backup_state = pmp;
279  }
280  template &lt;class BidiIterator, class Allocator, class traits&gt;
281  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_repeater_count(int i, repeater_count&lt;BidiIterator&gt;** s)
282  {
283     saved_repeater&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_repeater&lt;BidiIterator&gt;*&gt;(m_backup_state);
284     --pmp;
285     if(pmp &lt; m_stack_base)
286     {
287        extend_stack();
288        pmp = static_cast&lt;saved_repeater&lt;BidiIterator&gt;*&gt;(m_backup_state);
289        --pmp;
290     }
291     (void) new (pmp)saved_repeater&lt;BidiIterator&gt;(i, s, position, this-&gt;recursion_stack.empty() ? (INT_MIN + 3) : this-&gt;recursion_stack.back().idx);
292     m_backup_state = pmp;
293  }
294  template &lt;class BidiIterator, class Allocator, class traits&gt;
295  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)
296  {
297     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
298     --pmp;
299     if(pmp &lt; m_stack_base)
300     {
301        extend_stack();
302        pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
303        --pmp;
304     }
305     (void) new (pmp)saved_single_repeat&lt;BidiIterator&gt;(c, r, last_position, state_id);
306     m_backup_state = pmp;
307  }
308  template &lt;class BidiIterator, class Allocator, class traits&gt;
309  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_recursion(int idx, const re_syntax_base* p, results_type* presults, results_type* presults2)
310  {
311     saved_recursion&lt;results_type&gt;* pmp = static_cast&lt;saved_recursion&lt;results_type&gt;*&gt;(m_backup_state);
312     --pmp;
313     if(pmp &lt; m_stack_base)
314     {
315        extend_stack();
316        pmp = static_cast&lt;saved_recursion&lt;results_type&gt;*&gt;(m_backup_state);
317        --pmp;
318     }
319     (void) new (pmp)saved_recursion&lt;results_type&gt;(idx, p, presults, presults2);
320     m_backup_state = pmp;
321  }
322  template &lt;class BidiIterator, class Allocator, class traits&gt;
323  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_toggle_case()
324  {
325     push_case_change(this-&gt;icase);
326     this-&gt;icase = static_cast&lt;const re_case*&gt;(pstate)-&gt;icase;
327     pstate = pstate-&gt;next.p;
328     return true;
329  }
330  template &lt;class BidiIterator, class Allocator, class traits&gt;
331  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_startmark()
332  {
333     int index = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index;
334     icase = static_cast&lt;const re_brace*&gt;(pstate)-&gt;icase;
335     switch(index)
336     {
337     case 0:
338        pstate = pstate-&gt;next.p;
339        break;
340     case -1:
341     case -2:
342        {
343           const re_syntax_base* next_pstate = static_cast&lt;const re_jump*&gt;(pstate-&gt;next.p)-&gt;alt.p-&gt;next.p;
344           pstate = pstate-&gt;next.p-&gt;next.p;
345           push_assertion(next_pstate, index == -1);
346           break;
347        }
348     case -3:
349        {
350           bool old_independent = m_independent;
351           m_independent = true;
352           const re_syntax_base* next_pstate = static_cast&lt;const re_jump*&gt;(pstate-&gt;next.p)-&gt;alt.p-&gt;next.p;
353           pstate = pstate-&gt;next.p-&gt;next.p;
354           bool r = false;
355  #if !defined(BOOST_NO_EXCEPTIONS)
356        try{
357  #endif
358           r = match_all_states();
359           if(!r &amp;&amp; !m_independent)
360           {
361              while (m_backup_state-&gt;state_id)
362                 unwind(false);
363              return false;
364           }
365  #if !defined(BOOST_NO_EXCEPTIONS)
366        }
367        catch(...)
368        {
369           pstate = next_pstate;
370           while(unwind(true)) {}
371           throw;
372        }
373  #endif
374        pstate = next_pstate;
375        m_independent = old_independent;
376  #ifdef BOOST_REGEX_MATCH_EXTRA
377           if(r &amp;&amp; (m_match_flags &amp; match_extra))
378           {
379              match_results&lt;BidiIterator, Allocator&gt; temp_match(*m_presult);
380              unsigned i;
381              for(i = 0; i &lt; temp_match.size(); ++i)
382                 (*m_presult)[i].get_captures().clear();
383  #if !defined(BOOST_NO_EXCEPTIONS)
384              try{
385  #endif
386                 r = match_all_states();
387  #if !defined(BOOST_NO_EXCEPTIONS)
388              }
389              catch(...)
390              {
391                 pstate = next_pstate;
392                 while(unwind(true)) {}
393                 throw;
394              }
395  #endif
396              for(i = 0; i &lt; temp_match.size(); ++i)
397              {
398                 typedef typename sub_match&lt;BidiIterator&gt;::capture_sequence_type seq;
399                 seq&amp; s1 = (*m_presult)[i].get_captures();
400                 const seq&amp; s2 = temp_match[i].captures();
401                 s1.insert(
402                    s1.end(), 
403                    s2.begin(), 
404                    s2.end());
405              }
406           }
407  #endif
408           return r;
409        }
410     case -4:
411        {
412        const re_alt* alt = static_cast&lt;const re_alt*&gt;(pstate-&gt;next.p);
413        BOOST_REGEX_ASSERT(alt-&gt;type == syntax_element_alt);
414        pstate = alt-&gt;next.p;
415        if(pstate-&gt;type == syntax_element_assert_backref)
416        {
417           if(!match_assert_backref())
418              pstate = alt-&gt;alt.p;
419           break;
420        }
421        else
422        {
423           BOOST_REGEX_ASSERT(pstate-&gt;type == syntax_element_startmark);
424           bool negated = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index == -2;
425           BidiIterator saved_position = position;
426           const re_syntax_base* next_pstate = static_cast&lt;const re_jump*&gt;(pstate-&gt;next.p)-&gt;alt.p-&gt;next.p;
427           pstate = pstate-&gt;next.p-&gt;next.p;
428  #if !defined(BOOST_NO_EXCEPTIONS)
429           try{
430  #endif
431              bool r = match_all_states();
432              position = saved_position;
433              if(negated)
434                 r = !r;
435              if(r)
436                 pstate = next_pstate;
437              else
438                 pstate = alt-&gt;alt.p;
439  #if !defined(BOOST_NO_EXCEPTIONS)
440           }
441           catch(...)
442           {
443              pstate = next_pstate;
444              while(unwind(true)){}
445              throw;
446           }
447  #endif
448           break;
449        }
450        }
451     case -5:
452        {
453           push_matched_paren(0, (*m_presult)[0]);
454           m_presult-&gt;set_first(position, 0, true);
455           pstate = pstate-&gt;next.p;
456           break;
457        }
458     default:
459     {
460        BOOST_REGEX_ASSERT(index &gt; 0);
461        if((m_match_flags &amp; match_nosubs) == 0)
462        {
463           push_matched_paren(index, (*m_presult)[index]);
464           m_presult-&gt;set_first(position, index);
465        }
466        pstate = pstate-&gt;next.p;
467        break;
468     }
469     }
470     return true;
471  }
472  template &lt;class BidiIterator, class Allocator, class traits&gt;
473  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_alt()
474  {
475     bool take_first, take_second;
476     const re_alt* jmp = static_cast&lt;const re_alt*&gt;(pstate);
477     if(position == last)
478     {
479        take_first = jmp-&gt;can_be_null &amp; mask_take;
480        take_second = jmp-&gt;can_be_null &amp; mask_skip;
481     }
482     else
483     {
484        take_first = can_start(*position, jmp-&gt;_map, (unsigned char)mask_take);
485        take_second = can_start(*position, jmp-&gt;_map, (unsigned char)mask_skip);
486    }
487     if(take_first)
488     {
489        if(take_second)
490        {
491           push_alt(jmp-&gt;alt.p);
492        }
493        pstate = pstate-&gt;next.p;
494        return true;
495     }
496     if(take_second)
497     {
498        pstate = jmp-&gt;alt.p;
499        return true;
500     }
501     return false;  
502  }
503  template &lt;class BidiIterator, class Allocator, class traits&gt;
504  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_rep()
505  {
506  #ifdef BOOST_REGEX_MSVC
507  #pragma warning(push)
508  #pragma warning(disable:4127 4244)
509  #endif
510  #ifdef BOOST_BORLANDC
511  #pragma option push -w-8008 -w-8066 -w-8004
512  #endif
513     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
514     bool take_first, take_second;
515     if(position == last)
516     {
517        take_first = rep-&gt;can_be_null &amp; mask_take;
518        take_second = rep-&gt;can_be_null &amp; mask_skip;
519     }
520     else
521     {
522        take_first = can_start(*position, rep-&gt;_map, (unsigned char)mask_take);
523        take_second = can_start(*position, rep-&gt;_map, (unsigned char)mask_skip);
524     }
525     if((m_backup_state-&gt;state_id != saved_state_repeater_count) 
526        || (static_cast&lt;saved_repeater&lt;BidiIterator&gt;*&gt;(m_backup_state)-&gt;count.get_id() != rep-&gt;state_id)
527        || (next_count-&gt;get_id() != rep-&gt;state_id))
528     {
529        push_repeater_count(rep-&gt;state_id, &amp;next_count);
530     }
531     next_count-&gt;check_null_repeat(position, rep-&gt;max);
532     if(next_count-&gt;get_count() &lt; rep-&gt;min)
533     {
534        if(take_first)
535        {
536           ++(*next_count);
537           pstate = rep-&gt;next.p;
538           return true;
539        }
540        return false;
541     }
542     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
543     if(greedy)
544     {
545        if((next_count-&gt;get_count() &lt; rep-&gt;max) &amp;&amp; take_first)
546        {
547           if(take_second)
548           {
549              push_alt(rep-&gt;alt.p);
550           }
551           ++(*next_count);
552           pstate = rep-&gt;next.p;
553           return true;
554        }
555        else if(take_second)
556        {
557           pstate = rep-&gt;alt.p;
558           return true;
559        }
560        return false; 
561     }
562     else 
563     {
564        if(take_second)
565        {
566           if((next_count-&gt;get_count() &lt; rep-&gt;max) &amp;&amp; take_first)
567           {
568              push_non_greedy_repeat(rep-&gt;next.p);
569           }
570           pstate = rep-&gt;alt.p;
571           return true;
572        }
573        if((next_count-&gt;get_count() &lt; rep-&gt;max) &amp;&amp; take_first)
574        {
575           ++(*next_count);
576           pstate = rep-&gt;next.p;
577           return true;
578        }
579     }
580     return false;
581  #ifdef BOOST_BORLANDC
582  #pragma option pop
583  #endif
584  #ifdef BOOST_REGEX_MSVC
585  #pragma warning(pop)
586  #endif
587  }
588  template &lt;class BidiIterator, class Allocator, class traits&gt;
589  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_dot_repeat_slow()
590  {
591     std::size_t count = 0;
592     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
593     re_syntax_base* psingle = rep-&gt;next.p;
594     while(count &lt; rep-&gt;min)
595     {
596        pstate = psingle;
597        if(!match_wild())
598           return false;
599        ++count;
600     }
601     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
602     if(greedy)
603     {
604        while(count &lt; rep-&gt;max)
605        {
606           pstate = psingle;
607           if(!match_wild())
608              break;
609           ++count;
610        }
611        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
612           restart = position;
613        if(count - rep-&gt;min)
614           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
615        pstate = rep-&gt;alt.p;
616        return true;
617     }
618     else
619     {
620        if(count &lt; rep-&gt;max)
621           push_single_repeat(count, rep, position, saved_state_rep_slow_dot);
622        pstate = rep-&gt;alt.p;
623        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
624     }
625  }
626  template &lt;class BidiIterator, class Allocator, class traits&gt;
627  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_dot_repeat_fast()
628  {
629     if(m_match_flags &amp; match_not_dot_null)
630        return match_dot_repeat_slow();
631     if((static_cast&lt;const re_dot*&gt;(pstate-&gt;next.p)-&gt;mask &amp; match_any_mask) == 0)
632        return match_dot_repeat_slow();
633     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
634     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
635     std::size_t count = static_cast&lt;std::size_t&gt;((std::min)(static_cast&lt;std::size_t&gt;(std::distance(position, last)), greedy ? rep-&gt;max : rep-&gt;min));
636     if(rep-&gt;min &gt; count)
637     {
638        position = last;
639        return false;  
640     }
641     std::advance(position, count);
642     if(greedy)
643     {
644        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
645           restart = position;
646        if(count - rep-&gt;min)
647           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
648        pstate = rep-&gt;alt.p;
649        return true;
650     }
651     else
652     {
653        if(count &lt; rep-&gt;max)
654           push_single_repeat(count, rep, position, saved_state_rep_fast_dot);
655        pstate = rep-&gt;alt.p;
656        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
657     }
658  }
659  template &lt;class BidiIterator, class Allocator, class traits&gt;
660  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_char_repeat()
661  {
662  #ifdef BOOST_REGEX_MSVC
663  #pragma warning(push)
664  #pragma warning(disable:4127)
665  #endif
666  #ifdef BOOST_BORLANDC
667  #pragma option push -w-8008 -w-8066 -w-8004
668  #endif
669     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
670     BOOST_REGEX_ASSERT(1 == static_cast&lt;const re_literal*&gt;(rep-&gt;next.p)-&gt;length);
671     const char_type what = *reinterpret_cast&lt;const char_type*&gt;(static_cast&lt;const re_literal*&gt;(rep-&gt;next.p) + 1);
672     std::size_t count = 0;
673     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
674     std::size_t desired = greedy ? rep-&gt;max : rep-&gt;min;
675     if(::boost::is_random_access_iterator&lt;BidiIterator&gt;::value)
676     {
677        BidiIterator end = position;
678        std::size_t len = (desired == (std::numeric_limits&lt;std::size_t&gt;::max)()) ? 0u : std::distance(position, last);
679        if(desired &gt;= len)
680           end = last;
681        else
682           std::advance(end, desired);
683        BidiIterator origin(position);
684        while((position != end) &amp;&amp; (traits_inst.translate(*position, icase) == what))
685        {
686           ++position;
687        }
688        count = (unsigned)std::distance(origin, position);
689     }
690     else
691     {
692        while((count &lt; desired) &amp;&amp; (position != last) &amp;&amp; (traits_inst.translate(*position, icase) == what))
693        {
694           ++position;
695           ++count;
696        }
697     }
698     if(count &lt; rep-&gt;min)
699        return false;
700     if(greedy)
701     {
702        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
703           restart = position;
704        if(count - rep-&gt;min)
705           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
706        pstate = rep-&gt;alt.p;
707        return true;
708     }
709     else
710     {
711        if(count &lt; rep-&gt;max)
712           push_single_repeat(count, rep, position, saved_state_rep_char);
713        pstate = rep-&gt;alt.p;
714        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
715     }
716  #ifdef BOOST_BORLANDC
717  #pragma option pop
718  #endif
719  #ifdef BOOST_REGEX_MSVC
720  #pragma warning(pop)
721  #endif
722  }
723  template &lt;class BidiIterator, class Allocator, class traits&gt;
724  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_set_repeat()
725  {
726  #ifdef BOOST_REGEX_MSVC
727  #pragma warning(push)
728  #pragma warning(disable:4127)
729  #endif
730  #ifdef BOOST_BORLANDC
731  #pragma option push -w-8008 -w-8066 -w-8004
732  #endif
733     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
734     const unsigned char* map = static_cast&lt;const re_set*&gt;(rep-&gt;next.p)-&gt;_map;
735     std::size_t count = 0;
736     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
737     std::size_t desired = greedy ? rep-&gt;max : rep-&gt;min;
738     if(::boost::is_random_access_iterator&lt;BidiIterator&gt;::value)
739     {
740        BidiIterator end = position;
741        std::size_t len = (desired == (std::numeric_limits&lt;std::size_t&gt;::max)()) ? 0u : std::distance(position, last);
742        if(desired &gt;= len)
743           end = last;
744        else
745           std::advance(end, desired);
746        BidiIterator origin(position);
747        while((position != end) &amp;&amp; map[static_cast&lt;unsigned char&gt;(traits_inst.translate(*position, icase))])
748        {
749           ++position;
750        }
751        count = (unsigned)std::distance(origin, position);
752     }
753     else
754     {
755        while((count &lt; desired) &amp;&amp; (position != last) &amp;&amp; map[static_cast&lt;unsigned char&gt;(traits_inst.translate(*position, icase))])
756        {
757           ++position;
758           ++count;
759        }
760     }
761     if(count &lt; rep-&gt;min)
762        return false;
763     if(greedy)
764     {
765        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
766           restart = position;
767        if(count - rep-&gt;min)
768           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
769        pstate = rep-&gt;alt.p;
770        return true;
771     }
772     else
773     {
774        if(count &lt; rep-&gt;max)
775           push_single_repeat(count, rep, position, saved_state_rep_short_set);
776        pstate = rep-&gt;alt.p;
777        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
778     }
779  #ifdef BOOST_BORLANDC
780  #pragma option pop
781  #endif
782  #ifdef BOOST_REGEX_MSVC
783  #pragma warning(pop)
784  #endif
785  }
786  template &lt;class BidiIterator, class Allocator, class traits&gt;
787  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_long_set_repeat()
788  {
789  #ifdef BOOST_REGEX_MSVC
790  #pragma warning(push)
791  #pragma warning(disable:4127)
792  #endif
793  #ifdef BOOST_BORLANDC
794  #pragma option push -w-8008 -w-8066 -w-8004
795  #endif
796     typedef typename traits::char_class_type m_type;
797     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
798     const re_set_long&lt;m_type&gt;* set = static_cast&lt;const re_set_long&lt;m_type&gt;*&gt;(pstate-&gt;next.p);
799     std::size_t count = 0;
800     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
801     std::size_t desired = greedy ? rep-&gt;max : rep-&gt;min;
802     if(::boost::is_random_access_iterator&lt;BidiIterator&gt;::value)
803     {
804        BidiIterator end = position;
805        std::size_t len = (desired == (std::numeric_limits&lt;std::size_t&gt;::max)()) ? 0u : std::distance(position, last);
806        if(desired &gt;= len)
807           end = last;
808        else
809           std::advance(end, desired);
810        BidiIterator origin(position);
811        while((position != end) &amp;&amp; (position != re_is_set_member(position, last, set, re.get_data(), icase)))
812        {
813           ++position;
814        }
815        count = (unsigned)std::distance(origin, position);
816     }
817     else
818     {
819        while((count &lt; desired) &amp;&amp; (position != last) &amp;&amp; (position != re_is_set_member(position, last, set, re.get_data(), icase)))
820        {
821           ++position;
822           ++count;
823        }
824     }
825     if(count &lt; rep-&gt;min)
826        return false;
827     if(greedy)
828     {
829        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
830           restart = position;
831        if(count - rep-&gt;min)
832           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
833        pstate = rep-&gt;alt.p;
834        return true;
835     }
836     else
837     {
838        if(count &lt; rep-&gt;max)
839           push_single_repeat(count, rep, position, saved_state_rep_long_set);
840        pstate = rep-&gt;alt.p;
841        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
842     }
843  #ifdef BOOST_BORLANDC
844  #pragma option pop
845  #endif
846  #ifdef BOOST_REGEX_MSVC
847  #pragma warning(pop)
848  #endif
849  }
850  template &lt;class BidiIterator, class Allocator, class traits&gt;
851  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_recursion()
852  {
853     BOOST_REGEX_ASSERT(pstate-&gt;type == syntax_element_recurse);
854     for(typename std::vector&lt;recursion_info&lt;results_type&gt; &gt;::reverse_iterator i = recursion_stack.rbegin(); i != recursion_stack.rend(); ++i)
855     {
856        if(i-&gt;idx == static_cast&lt;const re_brace*&gt;(static_cast&lt;const re_jump*&gt;(pstate)-&gt;alt.p)-&gt;index)
857        {
858           if(i-&gt;location_of_start == position)
859              return false;
860           break;
861        }
862     }
863     push_recursion_pop();
864     if(recursion_stack.capacity() == 0)
865     {
866        recursion_stack.reserve(50);
867     }
868     recursion_stack.push_back(recursion_info&lt;results_type&gt;());
869     recursion_stack.back().preturn_address = pstate-&gt;next.p;
870     recursion_stack.back().results = *m_presult;
871     pstate = static_cast&lt;const re_jump*&gt;(pstate)-&gt;alt.p;
872     recursion_stack.back().idx = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index;
873     recursion_stack.back().location_of_start = position;
874     {
875        push_repeater_count(-(2 + static_cast&lt;const re_brace*&gt;(pstate)-&gt;index), &amp;next_count);
876     }
877     return true;
878  }
879  template &lt;class BidiIterator, class Allocator, class traits&gt;
880  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_endmark()
881  {
882     int index = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index;
883     icase = static_cast&lt;const re_brace*&gt;(pstate)-&gt;icase;
884     if(index &gt; 0)
885     {
886        if((m_match_flags &amp; match_nosubs) == 0)
887        {
888           m_presult-&gt;set_second(position, index);
889        }
890        if(!recursion_stack.empty())
891        {
892           if(index == recursion_stack.back().idx)
893           {
894              pstate = recursion_stack.back().preturn_address;
895              *m_presult = recursion_stack.back().results;
896              push_recursion(recursion_stack.back().idx, recursion_stack.back().preturn_address, m_presult, &amp;recursion_stack.back().results);
897              recursion_stack.pop_back();
898              push_repeater_count(-(2 + index), &amp;next_count);
899           }
900        }
901     }
902     else if((index &lt; 0) &amp;&amp; (index != -4))
903     {
904        pstate = 0;
905        return true;
906     }
907     pstate = pstate-&gt;next.p;
908     return true;
909  }
910  template &lt;class BidiIterator, class Allocator, class traits&gt;
911  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_match()
912  {
913     if(!recursion_stack.empty())
914     {
915        BOOST_REGEX_ASSERT(0 == recursion_stack.back().idx);
916        pstate = recursion_stack.back().preturn_address;
917        push_recursion(recursion_stack.back().idx, recursion_stack.back().preturn_address, m_presult, &amp;recursion_stack.back().results);
918        *m_presult = recursion_stack.back().results;
919        recursion_stack.pop_back();
920        return true;
921     }
922     if((m_match_flags &amp; match_not_null) &amp;&amp; (position == (*m_presult)[0].first))
923        return false;
924     if((m_match_flags &amp; match_all) &amp;&amp; (position != last))
925        return false;
926     if((m_match_flags &amp; regex_constants::match_not_initial_null) &amp;&amp; (position == search_base))
927        return false;
928     m_presult-&gt;set_second(position);
929     pstate = 0;
930     m_has_found_match = true;
931     if((m_match_flags &amp; match_posix) == match_posix)
932     {
933        m_result.maybe_assign(*m_presult);
934        if((m_match_flags &amp; match_any) == 0)
935           return false;
936     }
937  #ifdef BOOST_REGEX_MATCH_EXTRA
938     if(match_extra &amp; m_match_flags)
939     {
940        for(unsigned i = 0; i &lt; m_presult-&gt;size(); ++i)
941           if((*m_presult)[i].matched)
942              ((*m_presult)[i]).get_captures().push_back((*m_presult)[i]);
943     }
944  #endif
945     return true;
946  }
947  template &lt;class BidiIterator, class Allocator, class traits&gt;
948  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_commit()
949  {
950     switch(static_cast&lt;const re_commit*&gt;(pstate)-&gt;action)
951     {
952     case commit_commit:
953        restart = last;
954        break;
955     case commit_skip:
956        if(base != position)
957        {
958           restart = position;
959           --restart;
960        }
961        break;
962     case commit_prune:
963        break;
964     }
965     saved_state* pmp = m_backup_state;
966     --pmp;
967     if(pmp &lt; m_stack_base)
968     {
969        extend_stack();
970        pmp = m_backup_state;
971        --pmp;
972     }
973     (void) new (pmp)saved_state(16);
974     m_backup_state = pmp;
975     pstate = pstate-&gt;next.p;
976     return true;
977  }
978  template &lt;class BidiIterator, class Allocator, class traits&gt;
979  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_then()
980  {
981     saved_state* pmp = m_backup_state;
982     --pmp;
983     if(pmp &lt; m_stack_base)
984     {
985        extend_stack();
986        pmp = m_backup_state;
987        --pmp;
988     }
989     (void) new (pmp)saved_state(17);
990     m_backup_state = pmp;
991     pstate = pstate-&gt;next.p;
992     return true;
993  }
994  template &lt;class BidiIterator, class Allocator, class traits&gt;
995  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::skip_until_paren(int index, bool have_match)
996  {
997     while(pstate)
998     {
999        if(pstate-&gt;type == syntax_element_endmark)
1000        {
1001           if(static_cast&lt;const re_brace*&gt;(pstate)-&gt;index == index)
1002           {
1003              if(have_match)
1004                 return this-&gt;match_endmark();
1005              pstate = pstate-&gt;next.p;
1006              return true;
1007           }
1008           else
1009           {
1010              const re_syntax_base* sp = pstate;
1011              match_endmark();
1012              if(!pstate)
1013              {
1014                 unwind(true);
1015                 if (!pstate)
1016                    pstate = sp-&gt;next.p;
1017              }
1018           }
1019           continue;
1020        }
1021        else if(pstate-&gt;type == syntax_element_match)
1022           return true;
1023        else if(pstate-&gt;type == syntax_element_startmark)
1024        {
1025           int idx = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index;
1026           pstate = pstate-&gt;next.p;
1027           skip_until_paren(idx, false);
1028           continue;
1029        }
1030        pstate = pstate-&gt;next.p;
1031     }
1032     return true;
1033  }
1034  template &lt;class BidiIterator, class Allocator, class traits&gt;
1035  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind(bool have_match)
1036  {
1037     static unwind_proc_type const s_unwind_table[19] = 
1038     {
1039        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_end,
1040        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_paren,
1041        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion_stopper,
1042        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_assertion,
1043        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_alt,
1044        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_repeater_counter,
1045        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_extra_block,
1046        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_greedy_single_repeat,
1047        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_slow_dot_repeat,
1048        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_fast_dot_repeat,
1049        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_char_repeat,
1050        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_short_set_repeat,
1051        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_long_set_repeat,
1052        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_non_greedy_repeat,
1053        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion,
1054        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion_pop,
1055        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_commit,
1056        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_then,
1057        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_case,
1058     };
1059     m_recursive_result = have_match;
1060     m_unwound_lookahead = false;
1061     m_unwound_alt = false;
1062     unwind_proc_type unwinder;
1063     bool cont;
1064     do
1065     {
1066        unwinder = s_unwind_table[m_backup_state-&gt;state_id];
1067        cont = (this-&gt;*unwinder)(m_recursive_result);
1068     }while(cont);
1069     return pstate ? true : false;
1070  }
1071  template &lt;class BidiIterator, class Allocator, class traits&gt;
1072  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_end(bool)
1073  {
1074     pstate = 0;   
1075     return false; 
1076  }
1077  template &lt;class BidiIterator, class Allocator, class traits&gt;
1078  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_case(bool)
1079  {
1080     saved_change_case* pmp = static_cast&lt;saved_change_case*&gt;(m_backup_state);
1081     icase = pmp-&gt;icase;
1082     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1083     m_backup_state = pmp;
1084     return true;
1085  }
1086  template &lt;class BidiIterator, class Allocator, class traits&gt;
1087  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_paren(bool have_match)
1088  {
1089     saved_matched_paren&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_matched_paren&lt;BidiIterator&gt;*&gt;(m_backup_state);
1090     if(!have_match)
1091     {
1092        m_presult-&gt;set_first(pmp-&gt;sub.first, pmp-&gt;index, pmp-&gt;index == 0);
1093        m_presult-&gt;set_second(pmp-&gt;sub.second, pmp-&gt;index, pmp-&gt;sub.matched, pmp-&gt;index == 0);
1094     }
1095  #ifdef BOOST_REGEX_MATCH_EXTRA
1096     else if(pmp-&gt;sub.matched &amp;&amp; (match_extra &amp; m_match_flags))
1097        ((*m_presult)[pmp-&gt;index]).get_captures().push_back(pmp-&gt;sub);
1098  #endif
1099     m_backup_state = pmp+1;
1100     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp);
1101     return true; 
1102  }
1103  template &lt;class BidiIterator, class Allocator, class traits&gt;
1104  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion_stopper(bool)
1105  {
1106     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1107     pstate = 0;   
1108     return false; 
1109  }
1110  template &lt;class BidiIterator, class Allocator, class traits&gt;
1111  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_assertion(bool r)
1112  {
1113     saved_assertion&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_assertion&lt;BidiIterator&gt;*&gt;(m_backup_state);
1114     pstate = pmp-&gt;pstate;
1115     position = pmp-&gt;position;
1116     bool result = (r == pmp-&gt;positive);
1117     m_recursive_result = pmp-&gt;positive ? r : !r;
1118     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1119     m_backup_state = pmp;
1120     m_unwound_lookahead = true;
1121     return !result; 
1122  }
1123  template &lt;class BidiIterator, class Allocator, class traits&gt;
1124  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_alt(bool r)
1125  {
1126     saved_position&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
1127     if(!r)
1128     {
1129        pstate = pmp-&gt;pstate;
1130        position = pmp-&gt;position;
1131     }
1132     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1133     m_backup_state = pmp;
1134     m_unwound_alt = !r;
1135     return r; 
1136  }
1137  template &lt;class BidiIterator, class Allocator, class traits&gt;
1138  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_repeater_counter(bool)
1139  {
1140     saved_repeater&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_repeater&lt;BidiIterator&gt;*&gt;(m_backup_state);
1141     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1142     m_backup_state = pmp;
1143     return true; 
1144  }
1145  template &lt;class BidiIterator, class Allocator, class traits&gt;
1146  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_extra_block(bool)
1147  {
1148     ++used_block_count;
1149     saved_extra_block* pmp = static_cast&lt;saved_extra_block*&gt;(m_backup_state);
1150     void* condemmed = m_stack_base;
1151     m_stack_base = pmp-&gt;base;
1152     m_backup_state = pmp-&gt;end;
1153     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp);
1154     put_mem_block(condemmed);
1155     return true; 
1156  }
1157  template &lt;class BidiIterator, class Allocator, class traits&gt;
1158  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::destroy_single_repeat()
1159  {
1160     saved_single_repeat&lt;BidiIterator&gt;* p = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
<span onclick='openModal()' class='match'>1161     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(p++);
1162     m_backup_state = p;
1163  }
</span>1164  template &lt;class BidiIterator, class Allocator, class traits&gt;
1165  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_greedy_single_repeat(bool r)
1166  {
1167     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1168     if(r) 
1169     {
1170        destroy_single_repeat();
1171        return true;
1172     }
1173     const re_repeat* rep = pmp-&gt;rep;
1174     std::size_t count = pmp-&gt;count;
1175     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1176     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1177     count -= rep-&gt;min;
1178     if((m_match_flags &amp; match_partial) &amp;&amp; (position == last))
1179        m_has_partial_match = true;
1180     BOOST_REGEX_ASSERT(count);
1181     position = pmp-&gt;last_position;
1182     do
1183     {
1184        --position;
1185        --count;
1186        ++state_count;
1187     }while(count &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1188     if(count == 0)
1189     {
1190           destroy_single_repeat();
1191           if(!can_start(*position, rep-&gt;_map, mask_skip))
1192              return true;
1193     }
1194     else
1195     {
1196        pmp-&gt;count = count + rep-&gt;min;
1197        pmp-&gt;last_position = position;
1198     }
1199     pstate = rep-&gt;alt.p;
1200     return false;
1201  }
1202  template &lt;class BidiIterator, class Allocator, class traits&gt;
1203  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_slow_dot_repeat(bool r)
1204  {
1205     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1206     if(r) 
1207     {
1208        destroy_single_repeat();
1209        return true;
1210     }
1211     const re_repeat* rep = pmp-&gt;rep;
1212     std::size_t count = pmp-&gt;count;
1213     BOOST_REGEX_ASSERT(rep-&gt;type == syntax_element_dot_rep);
1214     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1215     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1216     BOOST_REGEX_ASSERT(rep-&gt;next.p-&gt;type == syntax_element_wild);
1217     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1218     pstate = rep-&gt;next.p;
1219     position = pmp-&gt;last_position;
1220     if(position != last)
1221     {
1222        do
1223        {
1224           if(!match_wild())
1225           {
1226              destroy_single_repeat();
1227              return true;
1228           }
1229           ++count;
1230           ++state_count;
1231           pstate = rep-&gt;next.p;
1232        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1233     }   
1234     if(position == last)
1235     {
1236        destroy_single_repeat();
1237        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1238           m_has_partial_match = true;
1239        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1240           return true;
1241     }
1242     else if(count == rep-&gt;max)
1243     {
1244        destroy_single_repeat();
1245        if(!can_start(*position, rep-&gt;_map, mask_skip))
1246           return true;
1247     }
1248     else
1249     {
1250        pmp-&gt;count = count;
1251        pmp-&gt;last_position = position;
1252     }
1253     pstate = rep-&gt;alt.p;
1254     return false;
1255  }
1256  template &lt;class BidiIterator, class Allocator, class traits&gt;
1257  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_fast_dot_repeat(bool r)
1258  {
1259     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1260     if(r) 
1261     {
1262        destroy_single_repeat();
1263        return true;
1264     }
1265     const re_repeat* rep = pmp-&gt;rep;
1266     std::size_t count = pmp-&gt;count;
1267     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1268     position = pmp-&gt;last_position;
1269     if(position != last)
1270     {
1271        do
1272        {
1273           ++position;
1274           ++count;
1275           ++state_count;
1276        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1277     }
1278     if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
1279        restart = position;
1280     if(position == last)
1281     {
1282        destroy_single_repeat();
1283        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1284           m_has_partial_match = true;
1285        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1286           return true;
1287     }
1288     else if(count == rep-&gt;max)
1289     {
1290        destroy_single_repeat();
1291        if(!can_start(*position, rep-&gt;_map, mask_skip))
1292           return true;
1293     }
1294     else
1295     {
1296        pmp-&gt;count = count;
1297        pmp-&gt;last_position = position;
1298     }
1299     pstate = rep-&gt;alt.p;
1300     return false;
1301  }
1302  template &lt;class BidiIterator, class Allocator, class traits&gt;
1303  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_char_repeat(bool r)
1304  {
1305     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1306     if(r) 
1307     {
1308        destroy_single_repeat();
1309        return true;
1310     }
1311     const re_repeat* rep = pmp-&gt;rep;
1312     std::size_t count = pmp-&gt;count;
1313     pstate = rep-&gt;next.p;
1314     const char_type what = *reinterpret_cast&lt;const char_type*&gt;(static_cast&lt;const re_literal*&gt;(pstate) + 1);
1315     position = pmp-&gt;last_position;
1316     BOOST_REGEX_ASSERT(rep-&gt;type == syntax_element_char_rep);
1317     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1318     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1319     BOOST_REGEX_ASSERT(rep-&gt;next.p-&gt;type == syntax_element_literal);
1320     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1321     if(position != last)
1322     {
1323        do
1324        {
1325           if(traits_inst.translate(*position, icase) != what)
1326           {
1327              destroy_single_repeat();
1328              return true;
1329           }
1330           ++count;
1331           ++ position;
1332           ++state_count;
1333           pstate = rep-&gt;next.p;
1334        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1335     }   
1336     if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
1337        restart = position;
1338     if(position == last)
1339     {
1340        destroy_single_repeat();
1341        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1342           m_has_partial_match = true;
1343        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1344           return true;
1345     }
1346     else if(count == rep-&gt;max)
1347     {
1348        destroy_single_repeat();
1349        if(!can_start(*position, rep-&gt;_map, mask_skip))
1350           return true;
1351     }
1352     else
1353     {
1354        pmp-&gt;count = count;
1355        pmp-&gt;last_position = position;
1356     }
1357     pstate = rep-&gt;alt.p;
1358     return false;
1359  }
1360  template &lt;class BidiIterator, class Allocator, class traits&gt;
1361  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_short_set_repeat(bool r)
1362  {
1363     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1364     if(r) 
1365     {
1366        destroy_single_repeat();
1367        return true;
1368     }
1369     const re_repeat* rep = pmp-&gt;rep;
1370     std::size_t count = pmp-&gt;count;
1371     pstate = rep-&gt;next.p;
1372     const unsigned char* map = static_cast&lt;const re_set*&gt;(rep-&gt;next.p)-&gt;_map;
1373     position = pmp-&gt;last_position;
1374     BOOST_REGEX_ASSERT(rep-&gt;type == syntax_element_short_set_rep);
1375     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1376     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1377     BOOST_REGEX_ASSERT(rep-&gt;next.p-&gt;type == syntax_element_set);
1378     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1379     if(position != last)
1380     {
1381        do
1382        {
1383           if(!map[static_cast&lt;unsigned char&gt;(traits_inst.translate(*position, icase))])
1384           {
1385              destroy_single_repeat();
1386              return true;
1387           }
1388           ++count;
1389           ++ position;
1390           ++state_count;
1391           pstate = rep-&gt;next.p;
1392        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1393     }   
1394     if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
1395        restart = position;
1396     if(position == last)
1397     {
1398        destroy_single_repeat();
1399        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1400           m_has_partial_match = true;
1401        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1402           return true;
1403     }
1404     else if(count == rep-&gt;max)
1405     {
1406        destroy_single_repeat();
1407        if(!can_start(*position, rep-&gt;_map, mask_skip))
1408           return true;
1409     }
1410     else
1411     {
1412        pmp-&gt;count = count;
1413        pmp-&gt;last_position = position;
1414     }
1415     pstate = rep-&gt;alt.p;
1416     return false;
1417  }
1418  template &lt;class BidiIterator, class Allocator, class traits&gt;
1419  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_long_set_repeat(bool r)
1420  {
1421     typedef typename traits::char_class_type m_type;
1422     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1423     if(r)
1424     {
1425        destroy_single_repeat();
1426        return true;
1427     }
1428     const re_repeat* rep = pmp-&gt;rep;
1429     std::size_t count = pmp-&gt;count;
1430     pstate = rep-&gt;next.p;
1431     const re_set_long&lt;m_type&gt;* set = static_cast&lt;const re_set_long&lt;m_type&gt;*&gt;(pstate);
1432     position = pmp-&gt;last_position;
1433     BOOST_REGEX_ASSERT(rep-&gt;type == syntax_element_long_set_rep);
1434     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1435     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1436     BOOST_REGEX_ASSERT(rep-&gt;next.p-&gt;type == syntax_element_long_set);
1437     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1438     if(position != last)
1439     {
1440        do
1441        {
1442           if(position == re_is_set_member(position, last, set, re.get_data(), icase))
1443           {
1444              destroy_single_repeat();
1445              return true;
1446           }
1447           ++position;
1448           ++count;
1449           ++state_count;
1450           pstate = rep-&gt;next.p;
1451        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1452     }   
1453     if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
1454        restart = position;
1455     if(position == last)
1456     {
1457        destroy_single_repeat();
1458        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1459           m_has_partial_match = true;
1460        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1461           return true;
1462     }
1463     else if(count == rep-&gt;max)
1464     {
1465        destroy_single_repeat();
1466        if(!can_start(*position, rep-&gt;_map, mask_skip))
1467           return true;
1468     }
1469     else
1470     {
1471        pmp-&gt;count = count;
1472        pmp-&gt;last_position = position;
1473     }
1474     pstate = rep-&gt;alt.p;
1475     return false;
1476  }
1477  template &lt;class BidiIterator, class Allocator, class traits&gt;
1478  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_non_greedy_repeat(bool r)
1479  {
1480     saved_position&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
1481     if(!r)
1482     {
1483        position = pmp-&gt;position;
1484        pstate = pmp-&gt;pstate;
1485        ++(*next_count);
1486     }
1487     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1488     m_backup_state = pmp;
1489     return r;
1490  }
1491  template &lt;class BidiIterator, class Allocator, class traits&gt;
1492  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion(bool r)
1493  {
1494     saved_recursion&lt;results_type&gt;* pmp = static_cast&lt;saved_recursion&lt;results_type&gt;*&gt;(m_backup_state);
1495     if (!r)
1496     {
1497        recursion_stack.push_back(recursion_info&lt;results_type&gt;());
1498        recursion_stack.back().idx = pmp-&gt;recursion_id;
1499        recursion_stack.back().preturn_address = pmp-&gt;preturn_address;
1500        recursion_stack.back().results = pmp-&gt;prior_results;
1501        recursion_stack.back().location_of_start = position;
1502        *m_presult = pmp-&gt;internal_results;
1503     }
1504     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1505     m_backup_state = pmp;
1506     return true;
1507  }
1508  template &lt;class BidiIterator, class Allocator, class traits&gt;
1509  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion_pop(bool r)
1510  {
1511     saved_state* pmp = static_cast&lt;saved_state*&gt;(m_backup_state);
1512     if (!r &amp;&amp; !recursion_stack.empty())
1513     {
1514        *m_presult = recursion_stack.back().results;
1515        position = recursion_stack.back().location_of_start;
1516        recursion_stack.pop_back();
1517     }
1518     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1519     m_backup_state = pmp;
1520     return true;
1521  }
1522  template &lt;class BidiIterator, class Allocator, class traits&gt;
1523  void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_recursion_pop()
1524  {
1525     saved_state* pmp = static_cast&lt;saved_state*&gt;(m_backup_state);
1526     --pmp;
1527     if(pmp &lt; m_stack_base)
1528     {
1529        extend_stack();
1530        pmp = static_cast&lt;saved_state*&gt;(m_backup_state);
1531        --pmp;
1532     }
1533     (void) new (pmp)saved_state(15);
1534     m_backup_state = pmp;
1535  }
1536  template &lt;class BidiIterator, class Allocator, class traits&gt;
1537  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_commit(bool b)
1538  {
1539     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1540     while(unwind(b) &amp;&amp; !m_unwound_lookahead){}
1541     if(m_unwound_lookahead &amp;&amp; pstate)
1542     {
1543        m_unwound_lookahead = false;
1544        saved_state* pmp = m_backup_state;
1545        --pmp;
1546        if(pmp &lt; m_stack_base)
1547        {
1548           extend_stack();
1549           pmp = m_backup_state;
1550           --pmp;
1551        }
1552        (void) new (pmp)saved_state(16);
1553        m_backup_state = pmp;
1554     }
1555     m_independent = false;
1556     return false;
1557  }
1558  template &lt;class BidiIterator, class Allocator, class traits&gt;
1559  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_then(bool b)
1560  {
1561     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1562     bool result = false;
1563     result = unwind(b);
1564     while(result &amp;&amp; !m_unwound_alt)
1565     {
1566        result = unwind(b);
1567     }
1568     if(result &amp;&amp; m_unwound_alt)
1569        unwind(b);
1570     return false;
1571  }
1572  } 
1573  } 
1574  #ifdef BOOST_REGEX_MSVC
1575  #  pragma warning(pop)
1576  #endif
1577  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher_non_recursive.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_PERL_MATCHER_NON_RECURSIVE_HPP
2  #define BOOST_REGEX_V5_PERL_MATCHER_NON_RECURSIVE_HPP
3  #include &lt;boost/regex/v5/mem_block_cache.hpp&gt;
4  #ifdef BOOST_REGEX_MSVC
5  #  pragma warning(push)
6  #  pragma warning(disable: 4706 4459)
7  #if BOOST_REGEX_MSVC &lt; 1910
8  #pragma warning(disable:4800)
9  #endif
10  #endif
11  namespace boost{
12  namespace BOOST_REGEX_DETAIL_NS{
13  template &lt;class T&gt;
14  inline void inplace_destroy(T* p)
15  {
16     (void)p;  
17     p-&gt;~T();
18  }
19  struct saved_state
20  {
21     union{
22        unsigned int state_id;
23        std::size_t padding1;
24        std::ptrdiff_t padding2;
25        void* padding3;
26     };
27     saved_state(unsigned i) : state_id(i) {}
28  };
29  template &lt;class BidiIterator&gt;
30  struct saved_matched_paren : public saved_state
31  {
32     int index;
33     sub_match&lt;BidiIterator&gt; sub;
34     saved_matched_paren(int i, const sub_match&lt;BidiIterator&gt;&amp; s) : saved_state(1), index(i), sub(s){}
35  };
36  template &lt;class BidiIterator&gt;
37  struct saved_position : public saved_state
38  {
39     const re_syntax_base* pstate;
40     BidiIterator position;
41     saved_position(const re_syntax_base* ps, BidiIterator pos, int i) : saved_state(i), pstate(ps), position(pos){}
42  };
43  template &lt;class BidiIterator&gt;
44  struct saved_assertion : public saved_position&lt;BidiIterator&gt;
45  {
46     bool positive;
47     saved_assertion(bool p, const re_syntax_base* ps, BidiIterator pos) 
48        : saved_position&lt;BidiIterator&gt;(ps, pos, saved_type_assertion), positive(p){}
49  };
50  template &lt;class BidiIterator&gt;
51  struct saved_repeater : public saved_state
52  {
53     repeater_count&lt;BidiIterator&gt; count;
54     saved_repeater(int i, repeater_count&lt;BidiIterator&gt;** s, BidiIterator start, int current_recursion_id)
55        : saved_state(saved_state_repeater_count), count(i, s, start, current_recursion_id){}
56  };
57  struct saved_extra_block : public saved_state
58  {
59     saved_state *base, *end;
60     saved_extra_block(saved_state* b, saved_state* e) 
61        : saved_state(saved_state_extra_block), base(b), end(e) {}
62  };
63  struct save_state_init
64  {
65     saved_state** stack;
66     save_state_init(saved_state** base, saved_state** end)
67        : stack(base)
68     {
69        *base = static_cast&lt;saved_state*&gt;(get_mem_block());
70        *end = reinterpret_cast&lt;saved_state*&gt;(reinterpret_cast&lt;char*&gt;(*base)+BOOST_REGEX_BLOCKSIZE);
71        --(*end);
72        (void) new (*end)saved_state(0);
73        BOOST_REGEX_ASSERT(*end &gt; *base);
74     }
75     ~save_state_init()
76     {
77        put_mem_block(*stack);
78        *stack = 0;
79     }
80  };
81  template &lt;class BidiIterator&gt;
82  struct saved_single_repeat : public saved_state
83  {
84     std::size_t count;
85     const re_repeat* rep;
86     BidiIterator last_position;
87     saved_single_repeat(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id) 
88        : saved_state(arg_id), count(c), rep(r), last_position(lp){}
89  };
90  template &lt;class Results&gt;
91  struct saved_recursion : public saved_state
92  {
93     saved_recursion(int idx, const re_syntax_base* p, Results* pr, Results* pr2) 
94        : saved_state(14), recursion_id(idx), preturn_address(p), internal_results(*pr), prior_results(*pr2) {}
95     int recursion_id;
96     const re_syntax_base* preturn_address;
97     Results internal_results, prior_results;
98  };
99  struct saved_change_case : public saved_state
100  {
101     bool icase;
102     saved_change_case(bool c) : saved_state(18), icase(c) {}
103  };
104  struct incrementer
105  {
106     incrementer(unsigned* pu) : m_pu(pu) { ++*m_pu; }
107     ~incrementer() { --*m_pu; }
108     bool operator &gt; (unsigned i) { return *m_pu &gt; i; }
109  private:
110     unsigned* m_pu;
111  };
112  template &lt;class BidiIterator, class Allocator, class traits&gt;
113  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_all_states()
114  {
115     static matcher_proc_type const s_match_vtable[34] = 
116     {
117        (&amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_startmark),
118        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_endmark,
119        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_literal,
120        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_start_line,
121        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_end_line,
122        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_wild,
123        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_match,
124        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_word_boundary,
125        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_within_word,
126        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_word_start,
127        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_word_end,
128        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_buffer_start,
129        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_buffer_end,
130        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_backref,
131        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_long_set,
132        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_set,
133        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_jump,
134        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_alt,
135        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_rep,
136        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_combining,
137        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_soft_buffer_end,
138        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_restart_continue,
139        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_dot_repeat_dispatch,
140        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_char_repeat,
141        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_set_repeat,
142        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_long_set_repeat,
143        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_backstep,
144        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_assert_backref,
145        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_toggle_case,
146        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_recursion,
147        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_fail,
148        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_accept,
149        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_commit,
150        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_then,
151     };
152     incrementer inc(&amp;m_recursions);
153     if(inc &gt; 80)
154        raise_error(traits_inst, regex_constants::error_complexity);
155     push_recursion_stopper();
156     do{
157        while(pstate)
158        {
159           matcher_proc_type proc = s_match_vtable[pstate-&gt;type];
160           ++state_count;
161           if(!(this-&gt;*proc)())
162           {
163              if(state_count &gt; max_state_count)
164                 raise_error(traits_inst, regex_constants::error_complexity);
165              if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
166                 m_has_partial_match = true;
167              bool successful_unwind = unwind(false);
168              if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
169                 m_has_partial_match = true;
170              if(!successful_unwind)
171                 return m_recursive_result;
172           }
173        }
174     }while(unwind(true));
175     return m_recursive_result;
176  }
177  template &lt;class BidiIterator, class Allocator, class traits&gt;
178  void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::extend_stack()
179  {
180     if(used_block_count)
181     {
182        --used_block_count;
183        saved_state* stack_base;
184        saved_state* backup_state;
185        stack_base = static_cast&lt;saved_state*&gt;(get_mem_block());
186        backup_state = reinterpret_cast&lt;saved_state*&gt;(reinterpret_cast&lt;char*&gt;(stack_base)+BOOST_REGEX_BLOCKSIZE);
187        saved_extra_block* block = static_cast&lt;saved_extra_block*&gt;(backup_state);
188        --block;
189        (void) new (block) saved_extra_block(m_stack_base, m_backup_state);
190        m_stack_base = stack_base;
191        m_backup_state = block;
192     }
193     else
194        raise_error(traits_inst, regex_constants::error_stack);
195  }
196  template &lt;class BidiIterator, class Allocator, class traits&gt;
197  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_matched_paren(int index, const sub_match&lt;BidiIterator&gt;&amp; sub)
198  {
199     saved_matched_paren&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_matched_paren&lt;BidiIterator&gt;*&gt;(m_backup_state);
200     --pmp;
201     if(pmp &lt; m_stack_base)
202     {
203        extend_stack();
204        pmp = static_cast&lt;saved_matched_paren&lt;BidiIterator&gt;*&gt;(m_backup_state);
205        --pmp;
206     }
207     (void) new (pmp)saved_matched_paren&lt;BidiIterator&gt;(index, sub);
208     m_backup_state = pmp;
209  }
210  template &lt;class BidiIterator, class Allocator, class traits&gt;
211  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_case_change(bool c)
212  {
213     saved_change_case* pmp = static_cast&lt;saved_change_case*&gt;(m_backup_state);
214     --pmp;
215     if(pmp &lt; m_stack_base)
216     {
217        extend_stack();
218        pmp = static_cast&lt;saved_change_case*&gt;(m_backup_state);
219        --pmp;
220     }
221     (void) new (pmp)saved_change_case(c);
222     m_backup_state = pmp;
223  }
224  template &lt;class BidiIterator, class Allocator, class traits&gt;
225  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_recursion_stopper()
226  {
227     saved_state* pmp = m_backup_state;
228     --pmp;
229     if(pmp &lt; m_stack_base)
230     {
231        extend_stack();
232        pmp = m_backup_state;
233        --pmp;
234     }
235     (void) new (pmp)saved_state(saved_type_recurse);
236     m_backup_state = pmp;
237  }
238  template &lt;class BidiIterator, class Allocator, class traits&gt;
239  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_assertion(const re_syntax_base* ps, bool positive)
240  {
241     saved_assertion&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_assertion&lt;BidiIterator&gt;*&gt;(m_backup_state);
242     --pmp;
243     if(pmp &lt; m_stack_base)
244     {
245        extend_stack();
246        pmp = static_cast&lt;saved_assertion&lt;BidiIterator&gt;*&gt;(m_backup_state);
247        --pmp;
248     }
249     (void) new (pmp)saved_assertion&lt;BidiIterator&gt;(positive, ps, position);
250     m_backup_state = pmp;
251  }
252  template &lt;class BidiIterator, class Allocator, class traits&gt;
253  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_alt(const re_syntax_base* ps)
254  {
255     saved_position&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
256     --pmp;
257     if(pmp &lt; m_stack_base)
258     {
259        extend_stack();
260        pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
261        --pmp;
262     }
263     (void) new (pmp)saved_position&lt;BidiIterator&gt;(ps, position, saved_state_alt);
264     m_backup_state = pmp;
265  }
266  template &lt;class BidiIterator, class Allocator, class traits&gt;
267  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_non_greedy_repeat(const re_syntax_base* ps)
268  {
269     saved_position&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
270     --pmp;
271     if(pmp &lt; m_stack_base)
272     {
273        extend_stack();
274        pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
275        --pmp;
276     }
277     (void) new (pmp)saved_position&lt;BidiIterator&gt;(ps, position, saved_state_non_greedy_long_repeat);
278     m_backup_state = pmp;
279  }
280  template &lt;class BidiIterator, class Allocator, class traits&gt;
281  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_repeater_count(int i, repeater_count&lt;BidiIterator&gt;** s)
282  {
283     saved_repeater&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_repeater&lt;BidiIterator&gt;*&gt;(m_backup_state);
284     --pmp;
285     if(pmp &lt; m_stack_base)
286     {
287        extend_stack();
288        pmp = static_cast&lt;saved_repeater&lt;BidiIterator&gt;*&gt;(m_backup_state);
289        --pmp;
290     }
291     (void) new (pmp)saved_repeater&lt;BidiIterator&gt;(i, s, position, this-&gt;recursion_stack.empty() ? (INT_MIN + 3) : this-&gt;recursion_stack.back().idx);
292     m_backup_state = pmp;
293  }
294  template &lt;class BidiIterator, class Allocator, class traits&gt;
295  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)
296  {
297     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
298     --pmp;
299     if(pmp &lt; m_stack_base)
300     {
301        extend_stack();
302        pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
303        --pmp;
304     }
305     (void) new (pmp)saved_single_repeat&lt;BidiIterator&gt;(c, r, last_position, state_id);
306     m_backup_state = pmp;
307  }
308  template &lt;class BidiIterator, class Allocator, class traits&gt;
309  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_recursion(int idx, const re_syntax_base* p, results_type* presults, results_type* presults2)
310  {
311     saved_recursion&lt;results_type&gt;* pmp = static_cast&lt;saved_recursion&lt;results_type&gt;*&gt;(m_backup_state);
312     --pmp;
313     if(pmp &lt; m_stack_base)
314     {
315        extend_stack();
316        pmp = static_cast&lt;saved_recursion&lt;results_type&gt;*&gt;(m_backup_state);
317        --pmp;
318     }
319     (void) new (pmp)saved_recursion&lt;results_type&gt;(idx, p, presults, presults2);
320     m_backup_state = pmp;
321  }
322  template &lt;class BidiIterator, class Allocator, class traits&gt;
323  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_toggle_case()
324  {
325     push_case_change(this-&gt;icase);
326     this-&gt;icase = static_cast&lt;const re_case*&gt;(pstate)-&gt;icase;
327     pstate = pstate-&gt;next.p;
328     return true;
329  }
330  template &lt;class BidiIterator, class Allocator, class traits&gt;
331  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_startmark()
332  {
333     int index = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index;
334     icase = static_cast&lt;const re_brace*&gt;(pstate)-&gt;icase;
335     switch(index)
336     {
337     case 0:
338        pstate = pstate-&gt;next.p;
339        break;
340     case -1:
341     case -2:
342        {
343           const re_syntax_base* next_pstate = static_cast&lt;const re_jump*&gt;(pstate-&gt;next.p)-&gt;alt.p-&gt;next.p;
344           pstate = pstate-&gt;next.p-&gt;next.p;
345           push_assertion(next_pstate, index == -1);
346           break;
347        }
348     case -3:
349        {
350           bool old_independent = m_independent;
351           m_independent = true;
352           const re_syntax_base* next_pstate = static_cast&lt;const re_jump*&gt;(pstate-&gt;next.p)-&gt;alt.p-&gt;next.p;
353           pstate = pstate-&gt;next.p-&gt;next.p;
354           bool r = false;
355  #if !defined(BOOST_NO_EXCEPTIONS)
356        try{
357  #endif
358           r = match_all_states();
359           if(!r &amp;&amp; !m_independent)
360           {
361              while (m_backup_state-&gt;state_id)
362                 unwind(false);
363              return false;
364           }
365  #if !defined(BOOST_NO_EXCEPTIONS)
366        }
367        catch(...)
368        {
369           pstate = next_pstate;
370           while(unwind(true)) {}
371           throw;
372        }
373  #endif
374        pstate = next_pstate;
375        m_independent = old_independent;
376  #ifdef BOOST_REGEX_MATCH_EXTRA
377           if(r &amp;&amp; (m_match_flags &amp; match_extra))
378           {
379              match_results&lt;BidiIterator, Allocator&gt; temp_match(*m_presult);
380              unsigned i;
381              for(i = 0; i &lt; temp_match.size(); ++i)
382                 (*m_presult)[i].get_captures().clear();
383  #if !defined(BOOST_NO_EXCEPTIONS)
384              try{
385  #endif
386                 r = match_all_states();
387  #if !defined(BOOST_NO_EXCEPTIONS)
388              }
389              catch(...)
390              {
391                 pstate = next_pstate;
392                 while(unwind(true)) {}
393                 throw;
394              }
395  #endif
396              for(i = 0; i &lt; temp_match.size(); ++i)
397              {
398                 typedef typename sub_match&lt;BidiIterator&gt;::capture_sequence_type seq;
399                 seq&amp; s1 = (*m_presult)[i].get_captures();
400                 const seq&amp; s2 = temp_match[i].captures();
401                 s1.insert(
402                    s1.end(), 
403                    s2.begin(), 
404                    s2.end());
405              }
406           }
407  #endif
408           return r;
409        }
410     case -4:
411        {
412        const re_alt* alt = static_cast&lt;const re_alt*&gt;(pstate-&gt;next.p);
413        BOOST_REGEX_ASSERT(alt-&gt;type == syntax_element_alt);
414        pstate = alt-&gt;next.p;
415        if(pstate-&gt;type == syntax_element_assert_backref)
416        {
417           if(!match_assert_backref())
418              pstate = alt-&gt;alt.p;
419           break;
420        }
421        else
422        {
423           BOOST_REGEX_ASSERT(pstate-&gt;type == syntax_element_startmark);
424           bool negated = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index == -2;
425           BidiIterator saved_position = position;
426           const re_syntax_base* next_pstate = static_cast&lt;const re_jump*&gt;(pstate-&gt;next.p)-&gt;alt.p-&gt;next.p;
427           pstate = pstate-&gt;next.p-&gt;next.p;
428  #if !defined(BOOST_NO_EXCEPTIONS)
429           try{
430  #endif
431              bool r = match_all_states();
432              position = saved_position;
433              if(negated)
434                 r = !r;
435              if(r)
436                 pstate = next_pstate;
437              else
438                 pstate = alt-&gt;alt.p;
439  #if !defined(BOOST_NO_EXCEPTIONS)
440           }
441           catch(...)
442           {
443              pstate = next_pstate;
444              while(unwind(true)){}
445              throw;
446           }
447  #endif
448           break;
449        }
450        }
451     case -5:
452        {
453           push_matched_paren(0, (*m_presult)[0]);
454           m_presult-&gt;set_first(position, 0, true);
455           pstate = pstate-&gt;next.p;
456           break;
457        }
458     default:
459     {
460        BOOST_REGEX_ASSERT(index &gt; 0);
461        if((m_match_flags &amp; match_nosubs) == 0)
462        {
463           push_matched_paren(index, (*m_presult)[index]);
464           m_presult-&gt;set_first(position, index);
465        }
466        pstate = pstate-&gt;next.p;
467        break;
468     }
469     }
470     return true;
471  }
472  template &lt;class BidiIterator, class Allocator, class traits&gt;
473  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_alt()
474  {
475     bool take_first, take_second;
476     const re_alt* jmp = static_cast&lt;const re_alt*&gt;(pstate);
477     if(position == last)
478     {
479        take_first = jmp-&gt;can_be_null &amp; mask_take;
480        take_second = jmp-&gt;can_be_null &amp; mask_skip;
481     }
482     else
483     {
484        take_first = can_start(*position, jmp-&gt;_map, (unsigned char)mask_take);
485        take_second = can_start(*position, jmp-&gt;_map, (unsigned char)mask_skip);
486    }
487     if(take_first)
488     {
489        if(take_second)
490        {
491           push_alt(jmp-&gt;alt.p);
492        }
493        pstate = pstate-&gt;next.p;
494        return true;
495     }
496     if(take_second)
497     {
498        pstate = jmp-&gt;alt.p;
499        return true;
500     }
501     return false;  
502  }
503  template &lt;class BidiIterator, class Allocator, class traits&gt;
504  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_rep()
505  {
506  #ifdef BOOST_REGEX_MSVC
507  #pragma warning(push)
508  #pragma warning(disable:4127 4244)
509  #endif
510  #ifdef BOOST_BORLANDC
511  #pragma option push -w-8008 -w-8066 -w-8004
512  #endif
513     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
514     bool take_first, take_second;
515     if(position == last)
516     {
517        take_first = rep-&gt;can_be_null &amp; mask_take;
518        take_second = rep-&gt;can_be_null &amp; mask_skip;
519     }
520     else
521     {
522        take_first = can_start(*position, rep-&gt;_map, (unsigned char)mask_take);
523        take_second = can_start(*position, rep-&gt;_map, (unsigned char)mask_skip);
524     }
525     if((m_backup_state-&gt;state_id != saved_state_repeater_count) 
526        || (static_cast&lt;saved_repeater&lt;BidiIterator&gt;*&gt;(m_backup_state)-&gt;count.get_id() != rep-&gt;state_id)
527        || (next_count-&gt;get_id() != rep-&gt;state_id))
528     {
529        push_repeater_count(rep-&gt;state_id, &amp;next_count);
530     }
531     next_count-&gt;check_null_repeat(position, rep-&gt;max);
532     if(next_count-&gt;get_count() &lt; rep-&gt;min)
533     {
534        if(take_first)
535        {
536           ++(*next_count);
537           pstate = rep-&gt;next.p;
538           return true;
539        }
540        return false;
541     }
542     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
543     if(greedy)
544     {
545        if((next_count-&gt;get_count() &lt; rep-&gt;max) &amp;&amp; take_first)
546        {
547           if(take_second)
548           {
549              push_alt(rep-&gt;alt.p);
550           }
551           ++(*next_count);
552           pstate = rep-&gt;next.p;
553           return true;
554        }
555        else if(take_second)
556        {
557           pstate = rep-&gt;alt.p;
558           return true;
559        }
560        return false; 
561     }
562     else 
563     {
564        if(take_second)
565        {
566           if((next_count-&gt;get_count() &lt; rep-&gt;max) &amp;&amp; take_first)
567           {
568              push_non_greedy_repeat(rep-&gt;next.p);
569           }
570           pstate = rep-&gt;alt.p;
571           return true;
572        }
573        if((next_count-&gt;get_count() &lt; rep-&gt;max) &amp;&amp; take_first)
574        {
575           ++(*next_count);
576           pstate = rep-&gt;next.p;
577           return true;
578        }
579     }
580     return false;
581  #ifdef BOOST_BORLANDC
582  #pragma option pop
583  #endif
584  #ifdef BOOST_REGEX_MSVC
585  #pragma warning(pop)
586  #endif
587  }
588  template &lt;class BidiIterator, class Allocator, class traits&gt;
589  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_dot_repeat_slow()
590  {
591     std::size_t count = 0;
592     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
593     re_syntax_base* psingle = rep-&gt;next.p;
594     while(count &lt; rep-&gt;min)
595     {
596        pstate = psingle;
597        if(!match_wild())
598           return false;
599        ++count;
600     }
601     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
602     if(greedy)
603     {
604        while(count &lt; rep-&gt;max)
605        {
606           pstate = psingle;
607           if(!match_wild())
608              break;
609           ++count;
610        }
611        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
612           restart = position;
613        if(count - rep-&gt;min)
614           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
615        pstate = rep-&gt;alt.p;
616        return true;
617     }
618     else
619     {
620        if(count &lt; rep-&gt;max)
621           push_single_repeat(count, rep, position, saved_state_rep_slow_dot);
622        pstate = rep-&gt;alt.p;
623        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
624     }
625  }
626  template &lt;class BidiIterator, class Allocator, class traits&gt;
627  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_dot_repeat_fast()
628  {
629     if(m_match_flags &amp; match_not_dot_null)
630        return match_dot_repeat_slow();
631     if((static_cast&lt;const re_dot*&gt;(pstate-&gt;next.p)-&gt;mask &amp; match_any_mask) == 0)
632        return match_dot_repeat_slow();
633     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
634     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
635     std::size_t count = static_cast&lt;std::size_t&gt;((std::min)(static_cast&lt;std::size_t&gt;(std::distance(position, last)), greedy ? rep-&gt;max : rep-&gt;min));
636     if(rep-&gt;min &gt; count)
637     {
638        position = last;
639        return false;  
640     }
641     std::advance(position, count);
642     if(greedy)
643     {
644        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
645           restart = position;
646        if(count - rep-&gt;min)
647           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
648        pstate = rep-&gt;alt.p;
649        return true;
650     }
651     else
652     {
653        if(count &lt; rep-&gt;max)
654           push_single_repeat(count, rep, position, saved_state_rep_fast_dot);
655        pstate = rep-&gt;alt.p;
656        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
657     }
658  }
659  template &lt;class BidiIterator, class Allocator, class traits&gt;
660  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_char_repeat()
661  {
662  #ifdef BOOST_REGEX_MSVC
663  #pragma warning(push)
664  #pragma warning(disable:4127)
665  #endif
666  #ifdef BOOST_BORLANDC
667  #pragma option push -w-8008 -w-8066 -w-8004
668  #endif
669     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
670     BOOST_REGEX_ASSERT(1 == static_cast&lt;const re_literal*&gt;(rep-&gt;next.p)-&gt;length);
671     const char_type what = *reinterpret_cast&lt;const char_type*&gt;(static_cast&lt;const re_literal*&gt;(rep-&gt;next.p) + 1);
672     std::size_t count = 0;
673     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
674     std::size_t desired = greedy ? rep-&gt;max : rep-&gt;min;
675     if(::boost::is_random_access_iterator&lt;BidiIterator&gt;::value)
676     {
677        BidiIterator end = position;
678        std::size_t len = (desired == (std::numeric_limits&lt;std::size_t&gt;::max)()) ? 0u : std::distance(position, last);
679        if(desired &gt;= len)
680           end = last;
681        else
682           std::advance(end, desired);
683        BidiIterator origin(position);
684        while((position != end) &amp;&amp; (traits_inst.translate(*position, icase) == what))
685        {
686           ++position;
687        }
688        count = (unsigned)std::distance(origin, position);
689     }
690     else
691     {
692        while((count &lt; desired) &amp;&amp; (position != last) &amp;&amp; (traits_inst.translate(*position, icase) == what))
693        {
694           ++position;
695           ++count;
696        }
697     }
698     if(count &lt; rep-&gt;min)
699        return false;
700     if(greedy)
701     {
702        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
703           restart = position;
704        if(count - rep-&gt;min)
705           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
706        pstate = rep-&gt;alt.p;
707        return true;
708     }
709     else
710     {
711        if(count &lt; rep-&gt;max)
712           push_single_repeat(count, rep, position, saved_state_rep_char);
713        pstate = rep-&gt;alt.p;
714        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
715     }
716  #ifdef BOOST_BORLANDC
717  #pragma option pop
718  #endif
719  #ifdef BOOST_REGEX_MSVC
720  #pragma warning(pop)
721  #endif
722  }
723  template &lt;class BidiIterator, class Allocator, class traits&gt;
724  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_set_repeat()
725  {
726  #ifdef BOOST_REGEX_MSVC
727  #pragma warning(push)
728  #pragma warning(disable:4127)
729  #endif
730  #ifdef BOOST_BORLANDC
731  #pragma option push -w-8008 -w-8066 -w-8004
732  #endif
733     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
734     const unsigned char* map = static_cast&lt;const re_set*&gt;(rep-&gt;next.p)-&gt;_map;
735     std::size_t count = 0;
736     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
737     std::size_t desired = greedy ? rep-&gt;max : rep-&gt;min;
738     if(::boost::is_random_access_iterator&lt;BidiIterator&gt;::value)
739     {
740        BidiIterator end = position;
741        std::size_t len = (desired == (std::numeric_limits&lt;std::size_t&gt;::max)()) ? 0u : std::distance(position, last);
742        if(desired &gt;= len)
743           end = last;
744        else
745           std::advance(end, desired);
746        BidiIterator origin(position);
747        while((position != end) &amp;&amp; map[static_cast&lt;unsigned char&gt;(traits_inst.translate(*position, icase))])
748        {
749           ++position;
750        }
751        count = (unsigned)std::distance(origin, position);
752     }
753     else
754     {
755        while((count &lt; desired) &amp;&amp; (position != last) &amp;&amp; map[static_cast&lt;unsigned char&gt;(traits_inst.translate(*position, icase))])
756        {
757           ++position;
758           ++count;
759        }
760     }
761     if(count &lt; rep-&gt;min)
762        return false;
763     if(greedy)
764     {
765        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
766           restart = position;
767        if(count - rep-&gt;min)
768           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
769        pstate = rep-&gt;alt.p;
770        return true;
771     }
772     else
773     {
774        if(count &lt; rep-&gt;max)
775           push_single_repeat(count, rep, position, saved_state_rep_short_set);
776        pstate = rep-&gt;alt.p;
777        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
778     }
779  #ifdef BOOST_BORLANDC
780  #pragma option pop
781  #endif
782  #ifdef BOOST_REGEX_MSVC
783  #pragma warning(pop)
784  #endif
785  }
786  template &lt;class BidiIterator, class Allocator, class traits&gt;
787  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_long_set_repeat()
788  {
789  #ifdef BOOST_REGEX_MSVC
790  #pragma warning(push)
791  #pragma warning(disable:4127)
792  #endif
793  #ifdef BOOST_BORLANDC
794  #pragma option push -w-8008 -w-8066 -w-8004
795  #endif
796     typedef typename traits::char_class_type m_type;
797     const re_repeat* rep = static_cast&lt;const re_repeat*&gt;(pstate);
798     const re_set_long&lt;m_type&gt;* set = static_cast&lt;const re_set_long&lt;m_type&gt;*&gt;(pstate-&gt;next.p);
799     std::size_t count = 0;
800     bool greedy = (rep-&gt;greedy) &amp;&amp; (!(m_match_flags &amp; regex_constants::match_any) || m_independent);   
801     std::size_t desired = greedy ? rep-&gt;max : rep-&gt;min;
802     if(::boost::is_random_access_iterator&lt;BidiIterator&gt;::value)
803     {
804        BidiIterator end = position;
805        std::size_t len = (desired == (std::numeric_limits&lt;std::size_t&gt;::max)()) ? 0u : std::distance(position, last);
806        if(desired &gt;= len)
807           end = last;
808        else
809           std::advance(end, desired);
810        BidiIterator origin(position);
811        while((position != end) &amp;&amp; (position != re_is_set_member(position, last, set, re.get_data(), icase)))
812        {
813           ++position;
814        }
815        count = (unsigned)std::distance(origin, position);
816     }
817     else
818     {
819        while((count &lt; desired) &amp;&amp; (position != last) &amp;&amp; (position != re_is_set_member(position, last, set, re.get_data(), icase)))
820        {
821           ++position;
822           ++count;
823        }
824     }
825     if(count &lt; rep-&gt;min)
826        return false;
827     if(greedy)
828     {
829        if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
830           restart = position;
831        if(count - rep-&gt;min)
832           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
833        pstate = rep-&gt;alt.p;
834        return true;
835     }
836     else
837     {
838        if(count &lt; rep-&gt;max)
839           push_single_repeat(count, rep, position, saved_state_rep_long_set);
840        pstate = rep-&gt;alt.p;
841        return (position == last) ? (rep-&gt;can_be_null &amp; mask_skip) : can_start(*position, rep-&gt;_map, mask_skip);
842     }
843  #ifdef BOOST_BORLANDC
844  #pragma option pop
845  #endif
846  #ifdef BOOST_REGEX_MSVC
847  #pragma warning(pop)
848  #endif
849  }
850  template &lt;class BidiIterator, class Allocator, class traits&gt;
851  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_recursion()
852  {
853     BOOST_REGEX_ASSERT(pstate-&gt;type == syntax_element_recurse);
854     for(typename std::vector&lt;recursion_info&lt;results_type&gt; &gt;::reverse_iterator i = recursion_stack.rbegin(); i != recursion_stack.rend(); ++i)
855     {
856        if(i-&gt;idx == static_cast&lt;const re_brace*&gt;(static_cast&lt;const re_jump*&gt;(pstate)-&gt;alt.p)-&gt;index)
857        {
858           if(i-&gt;location_of_start == position)
859              return false;
860           break;
861        }
862     }
863     push_recursion_pop();
864     if(recursion_stack.capacity() == 0)
865     {
866        recursion_stack.reserve(50);
867     }
868     recursion_stack.push_back(recursion_info&lt;results_type&gt;());
869     recursion_stack.back().preturn_address = pstate-&gt;next.p;
870     recursion_stack.back().results = *m_presult;
871     pstate = static_cast&lt;const re_jump*&gt;(pstate)-&gt;alt.p;
872     recursion_stack.back().idx = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index;
873     recursion_stack.back().location_of_start = position;
874     {
875        push_repeater_count(-(2 + static_cast&lt;const re_brace*&gt;(pstate)-&gt;index), &amp;next_count);
876     }
877     return true;
878  }
879  template &lt;class BidiIterator, class Allocator, class traits&gt;
880  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_endmark()
881  {
882     int index = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index;
883     icase = static_cast&lt;const re_brace*&gt;(pstate)-&gt;icase;
884     if(index &gt; 0)
885     {
886        if((m_match_flags &amp; match_nosubs) == 0)
887        {
888           m_presult-&gt;set_second(position, index);
889        }
890        if(!recursion_stack.empty())
891        {
892           if(index == recursion_stack.back().idx)
893           {
894              pstate = recursion_stack.back().preturn_address;
895              *m_presult = recursion_stack.back().results;
896              push_recursion(recursion_stack.back().idx, recursion_stack.back().preturn_address, m_presult, &amp;recursion_stack.back().results);
897              recursion_stack.pop_back();
898              push_repeater_count(-(2 + index), &amp;next_count);
899           }
900        }
901     }
902     else if((index &lt; 0) &amp;&amp; (index != -4))
903     {
904        pstate = 0;
905        return true;
906     }
907     pstate = pstate-&gt;next.p;
908     return true;
909  }
910  template &lt;class BidiIterator, class Allocator, class traits&gt;
911  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_match()
912  {
913     if(!recursion_stack.empty())
914     {
915        BOOST_REGEX_ASSERT(0 == recursion_stack.back().idx);
916        pstate = recursion_stack.back().preturn_address;
917        push_recursion(recursion_stack.back().idx, recursion_stack.back().preturn_address, m_presult, &amp;recursion_stack.back().results);
918        *m_presult = recursion_stack.back().results;
919        recursion_stack.pop_back();
920        return true;
921     }
922     if((m_match_flags &amp; match_not_null) &amp;&amp; (position == (*m_presult)[0].first))
923        return false;
924     if((m_match_flags &amp; match_all) &amp;&amp; (position != last))
925        return false;
926     if((m_match_flags &amp; regex_constants::match_not_initial_null) &amp;&amp; (position == search_base))
927        return false;
928     m_presult-&gt;set_second(position);
929     pstate = 0;
930     m_has_found_match = true;
931     if((m_match_flags &amp; match_posix) == match_posix)
932     {
933        m_result.maybe_assign(*m_presult);
934        if((m_match_flags &amp; match_any) == 0)
935           return false;
936     }
937  #ifdef BOOST_REGEX_MATCH_EXTRA
938     if(match_extra &amp; m_match_flags)
939     {
940        for(unsigned i = 0; i &lt; m_presult-&gt;size(); ++i)
941           if((*m_presult)[i].matched)
942              ((*m_presult)[i]).get_captures().push_back((*m_presult)[i]);
943     }
944  #endif
945     return true;
946  }
947  template &lt;class BidiIterator, class Allocator, class traits&gt;
948  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_commit()
949  {
950     switch(static_cast&lt;const re_commit*&gt;(pstate)-&gt;action)
951     {
952     case commit_commit:
953        restart = last;
954        break;
955     case commit_skip:
956        if(base != position)
957        {
958           restart = position;
959           --restart;
960        }
961        break;
962     case commit_prune:
963        break;
964     }
965     saved_state* pmp = m_backup_state;
966     --pmp;
967     if(pmp &lt; m_stack_base)
968     {
969        extend_stack();
970        pmp = m_backup_state;
971        --pmp;
972     }
973     (void) new (pmp)saved_state(16);
974     m_backup_state = pmp;
975     pstate = pstate-&gt;next.p;
976     return true;
977  }
978  template &lt;class BidiIterator, class Allocator, class traits&gt;
979  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::match_then()
980  {
981     saved_state* pmp = m_backup_state;
982     --pmp;
983     if(pmp &lt; m_stack_base)
984     {
985        extend_stack();
986        pmp = m_backup_state;
987        --pmp;
988     }
989     (void) new (pmp)saved_state(17);
990     m_backup_state = pmp;
991     pstate = pstate-&gt;next.p;
992     return true;
993  }
994  template &lt;class BidiIterator, class Allocator, class traits&gt;
995  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::skip_until_paren(int index, bool have_match)
996  {
997     while(pstate)
998     {
999        if(pstate-&gt;type == syntax_element_endmark)
1000        {
1001           if(static_cast&lt;const re_brace*&gt;(pstate)-&gt;index == index)
1002           {
1003              if(have_match)
1004                 return this-&gt;match_endmark();
1005              pstate = pstate-&gt;next.p;
1006              return true;
1007           }
1008           else
1009           {
1010              const re_syntax_base* sp = pstate;
1011              match_endmark();
1012              if(!pstate)
1013              {
1014                 unwind(true);
1015                 if (!pstate)
1016                    pstate = sp-&gt;next.p;
1017              }
1018           }
1019           continue;
1020        }
1021        else if(pstate-&gt;type == syntax_element_match)
1022           return true;
1023        else if(pstate-&gt;type == syntax_element_startmark)
1024        {
1025           int idx = static_cast&lt;const re_brace*&gt;(pstate)-&gt;index;
1026           pstate = pstate-&gt;next.p;
1027           skip_until_paren(idx, false);
1028           continue;
1029        }
1030        pstate = pstate-&gt;next.p;
1031     }
1032     return true;
1033  }
1034  template &lt;class BidiIterator, class Allocator, class traits&gt;
1035  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind(bool have_match)
1036  {
1037     static unwind_proc_type const s_unwind_table[19] = 
1038     {
1039        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_end,
1040        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_paren,
1041        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion_stopper,
1042        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_assertion,
1043        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_alt,
1044        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_repeater_counter,
1045        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_extra_block,
1046        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_greedy_single_repeat,
1047        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_slow_dot_repeat,
1048        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_fast_dot_repeat,
1049        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_char_repeat,
1050        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_short_set_repeat,
1051        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_long_set_repeat,
1052        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_non_greedy_repeat,
1053        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion,
1054        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion_pop,
1055        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_commit,
1056        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_then,
1057        &amp;perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_case,
1058     };
1059     m_recursive_result = have_match;
1060     m_unwound_lookahead = false;
1061     m_unwound_alt = false;
1062     unwind_proc_type unwinder;
1063     bool cont;
1064     do
1065     {
1066        unwinder = s_unwind_table[m_backup_state-&gt;state_id];
1067        cont = (this-&gt;*unwinder)(m_recursive_result);
1068     }while(cont);
1069     return pstate ? true : false;
1070  }
1071  template &lt;class BidiIterator, class Allocator, class traits&gt;
1072  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_end(bool)
1073  {
1074     pstate = 0;   
1075     return false; 
1076  }
1077  template &lt;class BidiIterator, class Allocator, class traits&gt;
1078  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_case(bool)
1079  {
1080     saved_change_case* pmp = static_cast&lt;saved_change_case*&gt;(m_backup_state);
1081     icase = pmp-&gt;icase;
<span onclick='openModal()' class='match'>1082     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1083     m_backup_state = pmp;
1084     return true;
</span>1085  }
1086  template &lt;class BidiIterator, class Allocator, class traits&gt;
1087  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_paren(bool have_match)
1088  {
1089     saved_matched_paren&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_matched_paren&lt;BidiIterator&gt;*&gt;(m_backup_state);
1090     if(!have_match)
1091     {
1092        m_presult-&gt;set_first(pmp-&gt;sub.first, pmp-&gt;index, pmp-&gt;index == 0);
1093        m_presult-&gt;set_second(pmp-&gt;sub.second, pmp-&gt;index, pmp-&gt;sub.matched, pmp-&gt;index == 0);
1094     }
1095  #ifdef BOOST_REGEX_MATCH_EXTRA
1096     else if(pmp-&gt;sub.matched &amp;&amp; (match_extra &amp; m_match_flags))
1097        ((*m_presult)[pmp-&gt;index]).get_captures().push_back(pmp-&gt;sub);
1098  #endif
1099     m_backup_state = pmp+1;
1100     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp);
1101     return true; 
1102  }
1103  template &lt;class BidiIterator, class Allocator, class traits&gt;
1104  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion_stopper(bool)
1105  {
1106     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1107     pstate = 0;   
1108     return false; 
1109  }
1110  template &lt;class BidiIterator, class Allocator, class traits&gt;
1111  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_assertion(bool r)
1112  {
1113     saved_assertion&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_assertion&lt;BidiIterator&gt;*&gt;(m_backup_state);
1114     pstate = pmp-&gt;pstate;
1115     position = pmp-&gt;position;
1116     bool result = (r == pmp-&gt;positive);
1117     m_recursive_result = pmp-&gt;positive ? r : !r;
1118     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1119     m_backup_state = pmp;
1120     m_unwound_lookahead = true;
1121     return !result; 
1122  }
1123  template &lt;class BidiIterator, class Allocator, class traits&gt;
1124  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_alt(bool r)
1125  {
1126     saved_position&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
1127     if(!r)
1128     {
1129        pstate = pmp-&gt;pstate;
1130        position = pmp-&gt;position;
1131     }
1132     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1133     m_backup_state = pmp;
1134     m_unwound_alt = !r;
1135     return r; 
1136  }
1137  template &lt;class BidiIterator, class Allocator, class traits&gt;
1138  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_repeater_counter(bool)
1139  {
1140     saved_repeater&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_repeater&lt;BidiIterator&gt;*&gt;(m_backup_state);
1141     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1142     m_backup_state = pmp;
1143     return true; 
1144  }
1145  template &lt;class BidiIterator, class Allocator, class traits&gt;
1146  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_extra_block(bool)
1147  {
1148     ++used_block_count;
1149     saved_extra_block* pmp = static_cast&lt;saved_extra_block*&gt;(m_backup_state);
1150     void* condemmed = m_stack_base;
1151     m_stack_base = pmp-&gt;base;
1152     m_backup_state = pmp-&gt;end;
1153     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp);
1154     put_mem_block(condemmed);
1155     return true; 
1156  }
1157  template &lt;class BidiIterator, class Allocator, class traits&gt;
1158  inline void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::destroy_single_repeat()
1159  {
1160     saved_single_repeat&lt;BidiIterator&gt;* p = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1161     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(p++);
1162     m_backup_state = p;
1163  }
1164  template &lt;class BidiIterator, class Allocator, class traits&gt;
1165  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_greedy_single_repeat(bool r)
1166  {
1167     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1168     if(r) 
1169     {
1170        destroy_single_repeat();
1171        return true;
1172     }
1173     const re_repeat* rep = pmp-&gt;rep;
1174     std::size_t count = pmp-&gt;count;
1175     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1176     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1177     count -= rep-&gt;min;
1178     if((m_match_flags &amp; match_partial) &amp;&amp; (position == last))
1179        m_has_partial_match = true;
1180     BOOST_REGEX_ASSERT(count);
1181     position = pmp-&gt;last_position;
1182     do
1183     {
1184        --position;
1185        --count;
1186        ++state_count;
1187     }while(count &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1188     if(count == 0)
1189     {
1190           destroy_single_repeat();
1191           if(!can_start(*position, rep-&gt;_map, mask_skip))
1192              return true;
1193     }
1194     else
1195     {
1196        pmp-&gt;count = count + rep-&gt;min;
1197        pmp-&gt;last_position = position;
1198     }
1199     pstate = rep-&gt;alt.p;
1200     return false;
1201  }
1202  template &lt;class BidiIterator, class Allocator, class traits&gt;
1203  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_slow_dot_repeat(bool r)
1204  {
1205     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1206     if(r) 
1207     {
1208        destroy_single_repeat();
1209        return true;
1210     }
1211     const re_repeat* rep = pmp-&gt;rep;
1212     std::size_t count = pmp-&gt;count;
1213     BOOST_REGEX_ASSERT(rep-&gt;type == syntax_element_dot_rep);
1214     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1215     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1216     BOOST_REGEX_ASSERT(rep-&gt;next.p-&gt;type == syntax_element_wild);
1217     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1218     pstate = rep-&gt;next.p;
1219     position = pmp-&gt;last_position;
1220     if(position != last)
1221     {
1222        do
1223        {
1224           if(!match_wild())
1225           {
1226              destroy_single_repeat();
1227              return true;
1228           }
1229           ++count;
1230           ++state_count;
1231           pstate = rep-&gt;next.p;
1232        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1233     }   
1234     if(position == last)
1235     {
1236        destroy_single_repeat();
1237        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1238           m_has_partial_match = true;
1239        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1240           return true;
1241     }
1242     else if(count == rep-&gt;max)
1243     {
1244        destroy_single_repeat();
1245        if(!can_start(*position, rep-&gt;_map, mask_skip))
1246           return true;
1247     }
1248     else
1249     {
1250        pmp-&gt;count = count;
1251        pmp-&gt;last_position = position;
1252     }
1253     pstate = rep-&gt;alt.p;
1254     return false;
1255  }
1256  template &lt;class BidiIterator, class Allocator, class traits&gt;
1257  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_fast_dot_repeat(bool r)
1258  {
1259     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1260     if(r) 
1261     {
1262        destroy_single_repeat();
1263        return true;
1264     }
1265     const re_repeat* rep = pmp-&gt;rep;
1266     std::size_t count = pmp-&gt;count;
1267     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1268     position = pmp-&gt;last_position;
1269     if(position != last)
1270     {
1271        do
1272        {
1273           ++position;
1274           ++count;
1275           ++state_count;
1276        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1277     }
1278     if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
1279        restart = position;
1280     if(position == last)
1281     {
1282        destroy_single_repeat();
1283        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1284           m_has_partial_match = true;
1285        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1286           return true;
1287     }
1288     else if(count == rep-&gt;max)
1289     {
1290        destroy_single_repeat();
1291        if(!can_start(*position, rep-&gt;_map, mask_skip))
1292           return true;
1293     }
1294     else
1295     {
1296        pmp-&gt;count = count;
1297        pmp-&gt;last_position = position;
1298     }
1299     pstate = rep-&gt;alt.p;
1300     return false;
1301  }
1302  template &lt;class BidiIterator, class Allocator, class traits&gt;
1303  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_char_repeat(bool r)
1304  {
1305     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1306     if(r) 
1307     {
1308        destroy_single_repeat();
1309        return true;
1310     }
1311     const re_repeat* rep = pmp-&gt;rep;
1312     std::size_t count = pmp-&gt;count;
1313     pstate = rep-&gt;next.p;
1314     const char_type what = *reinterpret_cast&lt;const char_type*&gt;(static_cast&lt;const re_literal*&gt;(pstate) + 1);
1315     position = pmp-&gt;last_position;
1316     BOOST_REGEX_ASSERT(rep-&gt;type == syntax_element_char_rep);
1317     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1318     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1319     BOOST_REGEX_ASSERT(rep-&gt;next.p-&gt;type == syntax_element_literal);
1320     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1321     if(position != last)
1322     {
1323        do
1324        {
1325           if(traits_inst.translate(*position, icase) != what)
1326           {
1327              destroy_single_repeat();
1328              return true;
1329           }
1330           ++count;
1331           ++ position;
1332           ++state_count;
1333           pstate = rep-&gt;next.p;
1334        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1335     }   
1336     if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
1337        restart = position;
1338     if(position == last)
1339     {
1340        destroy_single_repeat();
1341        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1342           m_has_partial_match = true;
1343        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1344           return true;
1345     }
1346     else if(count == rep-&gt;max)
1347     {
1348        destroy_single_repeat();
1349        if(!can_start(*position, rep-&gt;_map, mask_skip))
1350           return true;
1351     }
1352     else
1353     {
1354        pmp-&gt;count = count;
1355        pmp-&gt;last_position = position;
1356     }
1357     pstate = rep-&gt;alt.p;
1358     return false;
1359  }
1360  template &lt;class BidiIterator, class Allocator, class traits&gt;
1361  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_short_set_repeat(bool r)
1362  {
1363     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1364     if(r) 
1365     {
1366        destroy_single_repeat();
1367        return true;
1368     }
1369     const re_repeat* rep = pmp-&gt;rep;
1370     std::size_t count = pmp-&gt;count;
1371     pstate = rep-&gt;next.p;
1372     const unsigned char* map = static_cast&lt;const re_set*&gt;(rep-&gt;next.p)-&gt;_map;
1373     position = pmp-&gt;last_position;
1374     BOOST_REGEX_ASSERT(rep-&gt;type == syntax_element_short_set_rep);
1375     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1376     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1377     BOOST_REGEX_ASSERT(rep-&gt;next.p-&gt;type == syntax_element_set);
1378     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1379     if(position != last)
1380     {
1381        do
1382        {
1383           if(!map[static_cast&lt;unsigned char&gt;(traits_inst.translate(*position, icase))])
1384           {
1385              destroy_single_repeat();
1386              return true;
1387           }
1388           ++count;
1389           ++ position;
1390           ++state_count;
1391           pstate = rep-&gt;next.p;
1392        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1393     }   
1394     if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
1395        restart = position;
1396     if(position == last)
1397     {
1398        destroy_single_repeat();
1399        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1400           m_has_partial_match = true;
1401        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1402           return true;
1403     }
1404     else if(count == rep-&gt;max)
1405     {
1406        destroy_single_repeat();
1407        if(!can_start(*position, rep-&gt;_map, mask_skip))
1408           return true;
1409     }
1410     else
1411     {
1412        pmp-&gt;count = count;
1413        pmp-&gt;last_position = position;
1414     }
1415     pstate = rep-&gt;alt.p;
1416     return false;
1417  }
1418  template &lt;class BidiIterator, class Allocator, class traits&gt;
1419  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_long_set_repeat(bool r)
1420  {
1421     typedef typename traits::char_class_type m_type;
1422     saved_single_repeat&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_single_repeat&lt;BidiIterator&gt;*&gt;(m_backup_state);
1423     if(r)
1424     {
1425        destroy_single_repeat();
1426        return true;
1427     }
1428     const re_repeat* rep = pmp-&gt;rep;
1429     std::size_t count = pmp-&gt;count;
1430     pstate = rep-&gt;next.p;
1431     const re_set_long&lt;m_type&gt;* set = static_cast&lt;const re_set_long&lt;m_type&gt;*&gt;(pstate);
1432     position = pmp-&gt;last_position;
1433     BOOST_REGEX_ASSERT(rep-&gt;type == syntax_element_long_set_rep);
1434     BOOST_REGEX_ASSERT(rep-&gt;next.p != 0);
1435     BOOST_REGEX_ASSERT(rep-&gt;alt.p != 0);
1436     BOOST_REGEX_ASSERT(rep-&gt;next.p-&gt;type == syntax_element_long_set);
1437     BOOST_REGEX_ASSERT(count &lt; rep-&gt;max);
1438     if(position != last)
1439     {
1440        do
1441        {
1442           if(position == re_is_set_member(position, last, set, re.get_data(), icase))
1443           {
1444              destroy_single_repeat();
1445              return true;
1446           }
1447           ++position;
1448           ++count;
1449           ++state_count;
1450           pstate = rep-&gt;next.p;
1451        }while((count &lt; rep-&gt;max) &amp;&amp; (position != last) &amp;&amp; !can_start(*position, rep-&gt;_map, mask_skip));
1452     }   
1453     if((rep-&gt;leading) &amp;&amp; (count &lt; rep-&gt;max))
1454        restart = position;
1455     if(position == last)
1456     {
1457        destroy_single_repeat();
1458        if((m_match_flags &amp; match_partial) &amp;&amp; (position == last) &amp;&amp; (position != search_base))
1459           m_has_partial_match = true;
1460        if(0 == (rep-&gt;can_be_null &amp; mask_skip))
1461           return true;
1462     }
1463     else if(count == rep-&gt;max)
1464     {
1465        destroy_single_repeat();
1466        if(!can_start(*position, rep-&gt;_map, mask_skip))
1467           return true;
1468     }
1469     else
1470     {
1471        pmp-&gt;count = count;
1472        pmp-&gt;last_position = position;
1473     }
1474     pstate = rep-&gt;alt.p;
1475     return false;
1476  }
1477  template &lt;class BidiIterator, class Allocator, class traits&gt;
1478  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_non_greedy_repeat(bool r)
1479  {
1480     saved_position&lt;BidiIterator&gt;* pmp = static_cast&lt;saved_position&lt;BidiIterator&gt;*&gt;(m_backup_state);
1481     if(!r)
1482     {
1483        position = pmp-&gt;position;
1484        pstate = pmp-&gt;pstate;
1485        ++(*next_count);
1486     }
1487     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1488     m_backup_state = pmp;
1489     return r;
1490  }
1491  template &lt;class BidiIterator, class Allocator, class traits&gt;
1492  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion(bool r)
1493  {
1494     saved_recursion&lt;results_type&gt;* pmp = static_cast&lt;saved_recursion&lt;results_type&gt;*&gt;(m_backup_state);
1495     if (!r)
1496     {
1497        recursion_stack.push_back(recursion_info&lt;results_type&gt;());
1498        recursion_stack.back().idx = pmp-&gt;recursion_id;
1499        recursion_stack.back().preturn_address = pmp-&gt;preturn_address;
1500        recursion_stack.back().results = pmp-&gt;prior_results;
1501        recursion_stack.back().location_of_start = position;
1502        *m_presult = pmp-&gt;internal_results;
1503     }
1504     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1505     m_backup_state = pmp;
1506     return true;
1507  }
1508  template &lt;class BidiIterator, class Allocator, class traits&gt;
1509  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_recursion_pop(bool r)
1510  {
1511     saved_state* pmp = static_cast&lt;saved_state*&gt;(m_backup_state);
1512     if (!r &amp;&amp; !recursion_stack.empty())
1513     {
1514        *m_presult = recursion_stack.back().results;
1515        position = recursion_stack.back().location_of_start;
1516        recursion_stack.pop_back();
1517     }
1518     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1519     m_backup_state = pmp;
1520     return true;
1521  }
1522  template &lt;class BidiIterator, class Allocator, class traits&gt;
1523  void perl_matcher&lt;BidiIterator, Allocator, traits&gt;::push_recursion_pop()
1524  {
1525     saved_state* pmp = static_cast&lt;saved_state*&gt;(m_backup_state);
1526     --pmp;
1527     if(pmp &lt; m_stack_base)
1528     {
1529        extend_stack();
1530        pmp = static_cast&lt;saved_state*&gt;(m_backup_state);
1531        --pmp;
1532     }
1533     (void) new (pmp)saved_state(15);
1534     m_backup_state = pmp;
1535  }
1536  template &lt;class BidiIterator, class Allocator, class traits&gt;
1537  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_commit(bool b)
1538  {
1539     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1540     while(unwind(b) &amp;&amp; !m_unwound_lookahead){}
1541     if(m_unwound_lookahead &amp;&amp; pstate)
1542     {
1543        m_unwound_lookahead = false;
1544        saved_state* pmp = m_backup_state;
1545        --pmp;
1546        if(pmp &lt; m_stack_base)
1547        {
1548           extend_stack();
1549           pmp = m_backup_state;
1550           --pmp;
1551        }
1552        (void) new (pmp)saved_state(16);
1553        m_backup_state = pmp;
1554     }
1555     m_independent = false;
1556     return false;
1557  }
1558  template &lt;class BidiIterator, class Allocator, class traits&gt;
1559  bool perl_matcher&lt;BidiIterator, Allocator, traits&gt;::unwind_then(bool b)
1560  {
1561     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1562     bool result = false;
1563     result = unwind(b);
1564     while(result &amp;&amp; !m_unwound_alt)
1565     {
1566        result = unwind(b);
1567     }
1568     if(result &amp;&amp; m_unwound_alt)
1569        unwind(b);
1570     return false;
1571  }
1572  } 
1573  } 
1574  #ifdef BOOST_REGEX_MSVC
1575  #  pragma warning(pop)
1576  #endif
1577  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher_non_recursive.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher_non_recursive.hpp</div>
                </div>
                <div class="column column_space"><pre><code>1161     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(p++);
1162     m_backup_state = p;
1163  }
</pre></code></div>
                <div class="column column_space"><pre><code>1082     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1083     m_backup_state = pmp;
1084     return true;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    