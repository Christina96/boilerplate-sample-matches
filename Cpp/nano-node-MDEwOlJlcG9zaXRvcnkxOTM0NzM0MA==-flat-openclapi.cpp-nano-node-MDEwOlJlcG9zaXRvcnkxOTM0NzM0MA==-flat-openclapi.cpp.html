
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 54, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-openclapi.cpp</h3>
            <pre><code>1  #include <nano/node/openclwork.hpp>
2  #include <dlfcn.h>
3  namespace
4  {
5  class opencl_initializer
6  {
7  public:
8  	opencl_initializer ()
9  	{
10  		opencl_library = dlopen ("libOpenCL.so", RTLD_NOW);
11  		if (opencl_library != nullptr)
12  		{
13  			clGetPlatformIDs = reinterpret_cast<decltype (clGetPlatformIDs)> (dlsym (opencl_library, "clGetPlatformIDs"));
14  			clGetPlatformInfo = reinterpret_cast<decltype (clGetPlatformInfo)> (dlsym (opencl_library, "clGetPlatformInfo"));
15  			clGetDeviceIDs = reinterpret_cast<decltype (clGetDeviceIDs)> (dlsym (opencl_library, "clGetDeviceIDs"));
16  			clGetDeviceInfo = reinterpret_cast<decltype (clGetDeviceInfo)> (dlsym (opencl_library, "clGetDeviceInfo"));
17  			clCreateContext = reinterpret_cast<decltype (clCreateContext)> (dlsym (opencl_library, "clCreateContext"));
18  			clCreateCommandQueue = reinterpret_cast<decltype (clCreateCommandQueue)> (dlsym (opencl_library, "clCreateCommandQueue"));
19  			clCreateBuffer = reinterpret_cast<decltype (clCreateBuffer)> (dlsym (opencl_library, "clCreateBuffer"));
20  			clCreateProgramWithSource = reinterpret_cast<decltype (clCreateProgramWithSource)> (dlsym (opencl_library, "clCreateProgramWithSource"));
21  			clBuildProgram = reinterpret_cast<decltype (clBuildProgram)> (dlsym (opencl_library, "clBuildProgram"));
22  			clGetProgramBuildInfo = reinterpret_cast<decltype (clGetProgramBuildInfo)> (dlsym (opencl_library, "clGetProgramBuildInfo"));
23  			clCreateKernel = reinterpret_cast<decltype (clCreateKernel)> (dlsym (opencl_library, "clCreateKernel"));
24  			clSetKernelArg = reinterpret_cast<decltype (clSetKernelArg)> (dlsym (opencl_library, "clSetKernelArg"));
25  			clReleaseKernel = reinterpret_cast<decltype (clReleaseKernel)> (dlsym (opencl_library, "clReleaseKernel"));
26  			clReleaseProgram = reinterpret_cast<decltype (clReleaseProgram)> (dlsym (opencl_library, "clReleaseProgram"));
27  			clReleaseContext = reinterpret_cast<decltype (clReleaseContext)> (dlsym (opencl_library, "clReleaseContext"));
28  			clEnqueueWriteBuffer = reinterpret_cast<decltype (clEnqueueWriteBuffer)> (dlsym (opencl_library, "clEnqueueWriteBuffer"));
29  			clEnqueueNDRangeKernel = reinterpret_cast<decltype (clEnqueueNDRangeKernel)> (dlsym (opencl_library, "clEnqueueNDRangeKernel"));
30  			clEnqueueReadBuffer = reinterpret_cast<decltype (clEnqueueReadBuffer)> (dlsym (opencl_library, "clEnqueueReadBuffer"));
31  			clFinish = reinterpret_cast<decltype (clFinish)> (dlsym (opencl_library, "clFinish"));
32  			nano::opencl_loaded = true;
33  		}
34  	}
35  	~opencl_initializer ()
36  	{
37  		if (opencl_library != nullptr)
38  		{
39  			nano::opencl_loaded = false;
40  			dlclose (opencl_library);
41  		}
42  	}
43  	void * opencl_library;
44  	cl_int (*clGetPlatformIDs) (cl_uint, cl_platform_id *, cl_uint *);
45  	cl_int (*clGetPlatformInfo) (cl_platform_id, cl_platform_info, std::size_t, void *, std::size_t *);
46  	cl_int (*clGetDeviceIDs) (cl_platform_id, cl_device_type, cl_uint, cl_device_id *, cl_uint *);
47  	cl_int (*clGetDeviceInfo) (cl_device_id, cl_device_info, std::size_t, void *, std::size_t *);
48  	cl_context (*clCreateContext) (cl_context_properties const *, cl_uint, cl_device_id const *, void (*) (char const *, const void *, std::size_t, void *), void *, cl_int *);
49  	cl_command_queue (*clCreateCommandQueue) (cl_context, cl_device_id, cl_command_queue_properties, cl_int *);
50  	cl_mem (*clCreateBuffer) (cl_context, cl_mem_flags, std::size_t, void *, cl_int *);
51  	cl_program (*clCreateProgramWithSource) (cl_context, cl_uint, char const **, std::size_t const *, cl_int *);
52  	cl_int (*clBuildProgram) (cl_program, cl_uint, cl_device_id const *, char const *, void (*) (cl_program, void *), void *);
53  	cl_int (*clGetProgramBuildInfo) (cl_program, cl_device_id, cl_program_build_info, std::size_t, void *, std::size_t *);
54  	cl_kernel (*clCreateKernel) (cl_program, char const *, cl_int *);
55  	cl_int (*clSetKernelArg) (cl_kernel, cl_uint, std::size_t, void const *);
56  	cl_int (*clReleaseKernel) (cl_kernel);
57  	cl_int (*clReleaseProgram) (cl_program);
58  	cl_int (*clReleaseContext) (cl_context);
59  	cl_int (*clEnqueueWriteBuffer) (cl_command_queue, cl_mem, cl_bool, std::size_t, std::size_t, void const *, cl_uint, cl_event const *, cl_event *);
60  	cl_int (*clEnqueueNDRangeKernel) (cl_command_queue, cl_kernel, cl_uint, std::size_t const *, std::size_t const *, std::size_t const *, cl_uint, cl_event const *, cl_event *);
61  	cl_int (*clEnqueueReadBuffer) (cl_command_queue, cl_mem, cl_bool, std::size_t, std::size_t, void *, cl_uint, cl_event const *, cl_event *);
62  	cl_int (*clFinish) (cl_command_queue);
63  	static opencl_initializer initializer;
64  };
65  }
66  opencl_initializer opencl_initializer::initializer;
67  cl_int clGetPlatformIDs (cl_uint num_entries, cl_platform_id * platforms, cl_uint * num_platforms)
68  {
<span onclick='openModal()' class='match'>69  	cl_int result;
70  	if (opencl_initializer::initializer.opencl_library != nullptr)
71  	{
72  		result = opencl_initializer::initializer.clGetPlatformIDs (num_entries, platforms, num_platforms);
73  	}
74  	else
75  	{
76  		result = CL_SUCCESS;
77  		if (num_platforms != nullptr)
78  		{
79  			*num_platforms = 0;
80  		}
81  	}
82  	return result;
83  }
84  cl_int clGetPlatformInfo (cl_platform_id platform, cl_platform_info param_name, std::size_t param_value_size, void * param_value, std::size_t * param_value_size_ret)
</span>85  {
86  	return opencl_initializer::initializer.clGetPlatformInfo (platform, param_name, param_value_size, param_value, param_value_size_ret);
87  }
88  cl_int clGetDeviceIDs (cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id * devices, cl_uint * num_devices)
89  {
90  	return opencl_initializer::initializer.clGetDeviceIDs (platform, device_type, num_entries, devices, num_devices);
91  }
92  cl_int clGetDeviceInfo (cl_device_id device, cl_device_info param_name, std::size_t param_value_size, void * param_value, std::size_t * param_value_size_ret)
93  {
94  	return opencl_initializer::initializer.clGetDeviceInfo (device, param_name, param_value_size, param_value, param_value_size_ret);
95  }
96  cl_context clCreateContext (cl_context_properties const * properties, cl_uint num_devices, cl_device_id const * devices, void (*pfn_notify) (char const *, const void *, std::size_t, void *), void * user_data, cl_int * errcode_ret)
97  {
98  	return opencl_initializer::initializer.clCreateContext (properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
99  }
100  cl_command_queue clCreateCommandQueue (cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int * errcode_ret)
101  {
102  	return opencl_initializer::initializer.clCreateCommandQueue (context, device, properties, errcode_ret);
103  }
104  cl_mem clCreateBuffer (cl_context context, cl_mem_flags flags, std::size_t size, void * host_ptr, cl_int * errcode_ret)
105  {
106  	return opencl_initializer::initializer.clCreateBuffer (context, flags, size, host_ptr, errcode_ret);
107  }
108  cl_program clCreateProgramWithSource (cl_context context, cl_uint count, char const ** strings, std::size_t const * lengths, cl_int * errcode_ret)
109  {
110  	return opencl_initializer::initializer.clCreateProgramWithSource (context, count, strings, lengths, errcode_ret);
111  }
112  cl_int clBuildProgram (cl_program program, cl_uint num_devices, cl_device_id const * device_list, char const * options, void (*pfn_notify) (cl_program, void *), void * user_data)
113  {
114  	return opencl_initializer::initializer.clBuildProgram (program, num_devices, device_list, options, pfn_notify, user_data);
115  }
116  cl_int clGetProgramBuildInfo (cl_program program, cl_device_id device, cl_program_build_info param_name, std::size_t param_value_size, void * param_value, std::size_t * param_value_size_ret)
117  {
118  	return opencl_initializer::initializer.clGetProgramBuildInfo (program, device, param_name, param_value_size, param_value, param_value_size_ret);
119  }
120  cl_kernel clCreateKernel (cl_program program, char const * kernel_name, cl_int * errcode_ret)
121  {
122  	return opencl_initializer::initializer.clCreateKernel (program, kernel_name, errcode_ret);
123  }
124  cl_int clSetKernelArg (cl_kernel kernel, cl_uint arg_index, std::size_t arg_size, void const * arg_value)
125  {
126  	return opencl_initializer::initializer.clSetKernelArg (kernel, arg_index, arg_size, arg_value);
127  }
128  cl_int clReleaseKernel (cl_kernel kernel)
129  {
130  	return opencl_initializer::initializer.clReleaseKernel (kernel);
131  }
132  cl_int clReleaseProgram (cl_program program)
133  {
134  	return opencl_initializer::initializer.clReleaseProgram (program);
135  }
136  cl_int clReleaseContext (cl_context context)
137  {
138  	return opencl_initializer::initializer.clReleaseContext (context);
139  }
140  cl_int clEnqueueWriteBuffer (cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, std::size_t offset, std::size_t size, void const * ptr, cl_uint num_events_in_wait_list, cl_event const * event_wait_list, cl_event * event)
141  {
142  	return opencl_initializer::initializer.clEnqueueWriteBuffer (command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
143  }
144  cl_int clEnqueueNDRangeKernel (cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, std::size_t const * global_work_offset, std::size_t const * global_work_size, std::size_t const * local_work_size, cl_uint num_events_in_wait_list, cl_event const * event_wait_list, cl_event * event)
145  {
146  	return opencl_initializer::initializer.clEnqueueNDRangeKernel (command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event);
147  }
148  cl_int clEnqueueReadBuffer (cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, std::size_t offset, std::size_t size, void * ptr, cl_uint num_events_in_wait_list, cl_event const * event_wait_list, cl_event * event)
149  {
150  	return opencl_initializer::initializer.clEnqueueReadBuffer (command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
151  }
152  cl_int clFinish (cl_command_queue command_queue)
153  {
154  	return opencl_initializer::initializer.clFinish (command_queue);
155  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-openclapi.cpp</h3>
            <pre><code>1  #include <nano/node/openclwork.hpp>
2  #include <dlfcn.h>
3  namespace
4  {
5  class opencl_initializer
6  {
7  public:
8  	opencl_initializer ()
9  	{
10  		opencl_library = dlopen ("libOpenCL.so", RTLD_NOW);
11  		if (opencl_library != nullptr)
12  		{
13  			clGetPlatformIDs = reinterpret_cast<decltype (clGetPlatformIDs)> (dlsym (opencl_library, "clGetPlatformIDs"));
14  			clGetPlatformInfo = reinterpret_cast<decltype (clGetPlatformInfo)> (dlsym (opencl_library, "clGetPlatformInfo"));
15  			clGetDeviceIDs = reinterpret_cast<decltype (clGetDeviceIDs)> (dlsym (opencl_library, "clGetDeviceIDs"));
16  			clGetDeviceInfo = reinterpret_cast<decltype (clGetDeviceInfo)> (dlsym (opencl_library, "clGetDeviceInfo"));
17  			clCreateContext = reinterpret_cast<decltype (clCreateContext)> (dlsym (opencl_library, "clCreateContext"));
18  			clCreateCommandQueue = reinterpret_cast<decltype (clCreateCommandQueue)> (dlsym (opencl_library, "clCreateCommandQueue"));
19  			clCreateBuffer = reinterpret_cast<decltype (clCreateBuffer)> (dlsym (opencl_library, "clCreateBuffer"));
20  			clCreateProgramWithSource = reinterpret_cast<decltype (clCreateProgramWithSource)> (dlsym (opencl_library, "clCreateProgramWithSource"));
21  			clBuildProgram = reinterpret_cast<decltype (clBuildProgram)> (dlsym (opencl_library, "clBuildProgram"));
22  			clGetProgramBuildInfo = reinterpret_cast<decltype (clGetProgramBuildInfo)> (dlsym (opencl_library, "clGetProgramBuildInfo"));
23  			clCreateKernel = reinterpret_cast<decltype (clCreateKernel)> (dlsym (opencl_library, "clCreateKernel"));
24  			clSetKernelArg = reinterpret_cast<decltype (clSetKernelArg)> (dlsym (opencl_library, "clSetKernelArg"));
25  			clReleaseKernel = reinterpret_cast<decltype (clReleaseKernel)> (dlsym (opencl_library, "clReleaseKernel"));
26  			clReleaseProgram = reinterpret_cast<decltype (clReleaseProgram)> (dlsym (opencl_library, "clReleaseProgram"));
27  			clReleaseContext = reinterpret_cast<decltype (clReleaseContext)> (dlsym (opencl_library, "clReleaseContext"));
28  			clEnqueueWriteBuffer = reinterpret_cast<decltype (clEnqueueWriteBuffer)> (dlsym (opencl_library, "clEnqueueWriteBuffer"));
29  			clEnqueueNDRangeKernel = reinterpret_cast<decltype (clEnqueueNDRangeKernel)> (dlsym (opencl_library, "clEnqueueNDRangeKernel"));
30  			clEnqueueReadBuffer = reinterpret_cast<decltype (clEnqueueReadBuffer)> (dlsym (opencl_library, "clEnqueueReadBuffer"));
31  			clFinish = reinterpret_cast<decltype (clFinish)> (dlsym (opencl_library, "clFinish"));
32  			nano::opencl_loaded = true;
33  		}
34  	}
35  	~opencl_initializer ()
36  	{
37  		if (opencl_library != nullptr)
38  		{
39  			nano::opencl_loaded = false;
40  			dlclose (opencl_library);
41  		}
42  	}
43  	void * opencl_library;
44  	cl_int (*clGetPlatformIDs) (cl_uint, cl_platform_id *, cl_uint *);
45  	cl_int (*clGetPlatformInfo) (cl_platform_id, cl_platform_info, std::size_t, void *, std::size_t *);
46  	cl_int (*clGetDeviceIDs) (cl_platform_id, cl_device_type, cl_uint, cl_device_id *, cl_uint *);
47  	cl_int (*clGetDeviceInfo) (cl_device_id, cl_device_info, std::size_t, void *, std::size_t *);
48  	cl_context (*clCreateContext) (cl_context_properties const *, cl_uint, cl_device_id const *, void (*) (char const *, const void *, std::size_t, void *), void *, cl_int *);
49  	cl_command_queue (*clCreateCommandQueue) (cl_context, cl_device_id, cl_command_queue_properties, cl_int *);
50  	cl_mem (*clCreateBuffer) (cl_context, cl_mem_flags, std::size_t, void *, cl_int *);
51  	cl_program (*clCreateProgramWithSource) (cl_context, cl_uint, char const **, std::size_t const *, cl_int *);
52  	cl_int (*clBuildProgram) (cl_program, cl_uint, cl_device_id const *, char const *, void (*) (cl_program, void *), void *);
53  	cl_int (*clGetProgramBuildInfo) (cl_program, cl_device_id, cl_program_build_info, std::size_t, void *, std::size_t *);
54  	cl_kernel (*clCreateKernel) (cl_program, char const *, cl_int *);
55  	cl_int (*clSetKernelArg) (cl_kernel, cl_uint, std::size_t, void const *);
56  	cl_int (*clReleaseKernel) (cl_kernel);
57  	cl_int (*clReleaseProgram) (cl_program);
58  	cl_int (*clReleaseContext) (cl_context);
59  	cl_int (*clEnqueueWriteBuffer) (cl_command_queue, cl_mem, cl_bool, std::size_t, std::size_t, void const *, cl_uint, cl_event const *, cl_event *);
60  	cl_int (*clEnqueueNDRangeKernel) (cl_command_queue, cl_kernel, cl_uint, std::size_t const *, std::size_t const *, std::size_t const *, cl_uint, cl_event const *, cl_event *);
61  	cl_int (*clEnqueueReadBuffer) (cl_command_queue, cl_mem, cl_bool, std::size_t, std::size_t, void *, cl_uint, cl_event const *, cl_event *);
62  	cl_int (*clFinish) (cl_command_queue);
63  	static opencl_initializer initializer;
64  };
65  }
66  opencl_initializer opencl_initializer::initializer;
67  cl_int clGetPlatformIDs (cl_uint num_entries, cl_platform_id * platforms, cl_uint * num_platforms)
68  {
<span onclick='openModal()' class='match'>69  	cl_int result;
70  	if (opencl_initializer::initializer.opencl_library != nullptr)
71  	{
72  		result = opencl_initializer::initializer.clGetPlatformIDs (num_entries, platforms, num_platforms);
73  	}
74  	else
75  	{
76  		result = CL_SUCCESS;
77  		if (num_platforms != nullptr)
78  		{
79  			*num_platforms = 0;
80  		}
81  	}
82  	return result;
83  }
84  cl_int clGetPlatformInfo (cl_platform_id platform, cl_platform_info param_name, std::size_t param_value_size, void * param_value, std::size_t * param_value_size_ret)
</span>85  {
86  	return opencl_initializer::initializer.clGetPlatformInfo (platform, param_name, param_value_size, param_value, param_value_size_ret);
87  }
88  cl_int clGetDeviceIDs (cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id * devices, cl_uint * num_devices)
89  {
90  	return opencl_initializer::initializer.clGetDeviceIDs (platform, device_type, num_entries, devices, num_devices);
91  }
92  cl_int clGetDeviceInfo (cl_device_id device, cl_device_info param_name, std::size_t param_value_size, void * param_value, std::size_t * param_value_size_ret)
93  {
94  	return opencl_initializer::initializer.clGetDeviceInfo (device, param_name, param_value_size, param_value, param_value_size_ret);
95  }
96  cl_context clCreateContext (cl_context_properties const * properties, cl_uint num_devices, cl_device_id const * devices, void (*pfn_notify) (char const *, const void *, std::size_t, void *), void * user_data, cl_int * errcode_ret)
97  {
98  	return opencl_initializer::initializer.clCreateContext (properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
99  }
100  cl_command_queue clCreateCommandQueue (cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int * errcode_ret)
101  {
102  	return opencl_initializer::initializer.clCreateCommandQueue (context, device, properties, errcode_ret);
103  }
104  cl_mem clCreateBuffer (cl_context context, cl_mem_flags flags, std::size_t size, void * host_ptr, cl_int * errcode_ret)
105  {
106  	return opencl_initializer::initializer.clCreateBuffer (context, flags, size, host_ptr, errcode_ret);
107  }
108  cl_program clCreateProgramWithSource (cl_context context, cl_uint count, char const ** strings, std::size_t const * lengths, cl_int * errcode_ret)
109  {
110  	return opencl_initializer::initializer.clCreateProgramWithSource (context, count, strings, lengths, errcode_ret);
111  }
112  cl_int clBuildProgram (cl_program program, cl_uint num_devices, cl_device_id const * device_list, char const * options, void (*pfn_notify) (cl_program, void *), void * user_data)
113  {
114  	return opencl_initializer::initializer.clBuildProgram (program, num_devices, device_list, options, pfn_notify, user_data);
115  }
116  cl_int clGetProgramBuildInfo (cl_program program, cl_device_id device, cl_program_build_info param_name, std::size_t param_value_size, void * param_value, std::size_t * param_value_size_ret)
117  {
118  	return opencl_initializer::initializer.clGetProgramBuildInfo (program, device, param_name, param_value_size, param_value, param_value_size_ret);
119  }
120  cl_kernel clCreateKernel (cl_program program, char const * kernel_name, cl_int * errcode_ret)
121  {
122  	return opencl_initializer::initializer.clCreateKernel (program, kernel_name, errcode_ret);
123  }
124  cl_int clSetKernelArg (cl_kernel kernel, cl_uint arg_index, std::size_t arg_size, void const * arg_value)
125  {
126  	return opencl_initializer::initializer.clSetKernelArg (kernel, arg_index, arg_size, arg_value);
127  }
128  cl_int clReleaseKernel (cl_kernel kernel)
129  {
130  	return opencl_initializer::initializer.clReleaseKernel (kernel);
131  }
132  cl_int clReleaseProgram (cl_program program)
133  {
134  	return opencl_initializer::initializer.clReleaseProgram (program);
135  }
136  cl_int clReleaseContext (cl_context context)
137  {
138  	return opencl_initializer::initializer.clReleaseContext (context);
139  }
140  cl_int clEnqueueWriteBuffer (cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, std::size_t offset, std::size_t size, void const * ptr, cl_uint num_events_in_wait_list, cl_event const * event_wait_list, cl_event * event)
141  {
142  	return opencl_initializer::initializer.clEnqueueWriteBuffer (command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
143  }
144  cl_int clEnqueueNDRangeKernel (cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, std::size_t const * global_work_offset, std::size_t const * global_work_size, std::size_t const * local_work_size, cl_uint num_events_in_wait_list, cl_event const * event_wait_list, cl_event * event)
145  {
146  	return opencl_initializer::initializer.clEnqueueNDRangeKernel (command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event);
147  }
148  cl_int clEnqueueReadBuffer (cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, std::size_t offset, std::size_t size, void * ptr, cl_uint num_events_in_wait_list, cl_event const * event_wait_list, cl_event * event)
149  {
150  	return opencl_initializer::initializer.clEnqueueReadBuffer (command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
151  }
152  cl_int clFinish (cl_command_queue command_queue)
153  {
154  	return opencl_initializer::initializer.clFinish (command_queue);
155  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-openclapi.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-openclapi.cpp</div>
                </div>
                <div class="column column_space"><pre><code>69  	cl_int result;
70  	if (opencl_initializer::initializer.opencl_library != nullptr)
71  	{
72  		result = opencl_initializer::initializer.clGetPlatformIDs (num_entries, platforms, num_platforms);
73  	}
74  	else
75  	{
76  		result = CL_SUCCESS;
77  		if (num_platforms != nullptr)
78  		{
79  			*num_platforms = 0;
80  		}
81  	}
82  	return result;
83  }
84  cl_int clGetPlatformInfo (cl_platform_id platform, cl_platform_info param_name, std::size_t param_value_size, void * param_value, std::size_t * param_value_size_ret)
</pre></code></div>
                <div class="column column_space"><pre><code>69  	cl_int result;
70  	if (opencl_initializer::initializer.opencl_library != nullptr)
71  	{
72  		result = opencl_initializer::initializer.clGetPlatformIDs (num_entries, platforms, num_platforms);
73  	}
74  	else
75  	{
76  		result = CL_SUCCESS;
77  		if (num_platforms != nullptr)
78  		{
79  			*num_platforms = 0;
80  		}
81  	}
82  	return result;
83  }
84  cl_int clGetPlatformInfo (cl_platform_id platform, cl_platform_info param_name, std::size_t param_value_size, void * param_value, std::size_t * param_value_size_ret)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    