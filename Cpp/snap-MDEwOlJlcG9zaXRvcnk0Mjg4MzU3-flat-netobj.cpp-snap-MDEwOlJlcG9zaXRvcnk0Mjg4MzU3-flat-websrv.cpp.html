
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-netobj.cpp</h3>
            <pre><code>1  THash<TStr, TNetObj::TNetObjLoadF> TNetObj::TypeToLoadFH;
2  PNetObj TNetObj::Load(TSIn& SIn){
3    TStr TypeNm(SIn);
4    int TypeKeyId=-1;
5    if (TypeToLoadFH.IsKey(TypeNm, TypeKeyId)){
6      TNetObjLoadF LoadF=TypeToLoadFH[TypeKeyId];
7      return (*LoadF())(SIn);
8    } else {
9      return NULL;
10    }
11  }
12  bool TNetObj::Reg(const TStr& TypeNm, const TNetObjLoadF& LoadF){
13    IAssert(!TypeToLoadFH.IsKey(TypeNm));
14    TypeToLoadFH.AddDat(TypeNm, LoadF);
15    return true;
16  }
17  PSIn TNetObj::GetPckSIn(const PNetObj& NetObj){
18    TMOut NetObjMOut; NetObj->Save(NetObjMOut);
19    TNetObjPckHd PckHd(NetObjMOut.Len());
20    TMOut PckMOut; PckHd.Save(PckMOut); PckMOut.Save(NetObjMOut.GetSIn(true));
21    return PckMOut.GetSIn(true);
22  }
23  PNetObj TNetObj::GetPckNetObj(TMOut& MOut, bool& Ok){
24    Ok=true;
25    while (MOut.Len()>=TNetObjPckHd::GetSize()){
26      PSIn PckSIn=MOut.GetSIn(false, TNetObjPckHd::GetSize());
27      TNetObjPckHd PckHd(*PckSIn, Ok);
28      if (!Ok){break;}
29      if (MOut.Len()<TNetObjPckHd::GetSize()+PckHd.GetPckLen()){break;}
30      PSIn VoidPckSIn=MOut.GetSIn(true, TNetObjPckHd::GetSize());
31      TNetObjPckHd VoidPckHd(*VoidPckSIn, Ok);
32      PSIn NetObjSIn=MOut.GetSIn(true, PckHd.GetPckLen());
33      return TNetObj::Load(*NetObjSIn);
34    }
35    return NULL;
36  }
37  bool TNetAck::IsReg=TNetAck::MkReg();
38  bool TNetNotify::IsReg=TNetNotify::MkReg();
39  bool TNetErr::IsReg=TNetErr::MkReg();
40  bool TNetAccept::IsReg=TNetAccept::MkReg();
41  bool TNetConn::IsReg=TNetConn::MkReg();
42  bool TNetClose::IsReg=TNetClose::MkReg();
43  bool TNetTimeOut::IsReg=TNetTimeOut::MkReg();
44  bool TNetReg::IsReg=TNetReg::MkReg();
45  TStr TNetReg::GetRegTypeStr(const int& NetRegType){
46    switch (NetRegType){
47      case nrtLogin: return "Login";
48      case nrtConfirm: return "Confirm";
49      case nrtRefuse: return "Refuse";
50      case nrtLogout: return "Logout";
51      default: Fail; return TStr();
52    }
53  }
54  bool TNetChatMsg::IsReg=TNetChatMsg::MkReg();
55  TStr TNetChatMsg::GetLogStr(){
56    TChA LogChA;
57    LogChA+=FromAddrStr;
58    LogChA+=" > [";
59    for (int ToAddrStrN=0; ToAddrStrN<GetToAddrStrs(); ToAddrStrN++){
60      if (ToAddrStrN>0){LogChA+=", ";}
61      LogChA+=GetToAddrStr(ToAddrStrN);
62    }
63    LogChA+="]: ";
64    LogChA+=MsgStr;
65    return LogChA;
66  }
67  bool TNetMem::IsReg=TNetMem::MkReg();
68  void TNetSrvSockEvent::OnAccept(const int& SockId, const PSock& Sock){
69    NetSrv->CltSockIdToSockH.AddDat(SockId, Sock);
70    PNetObj NetAccept=PNetObj(new TNetAccept(SockId));
71    NetAccept->PutSockId(SockId);
72    NetSrv->OnNetObj(NetAccept);
73  }
74  void TNetSrvSockEvent::OnRead(const int& SockId, const PSIn& SIn){
75    NetSrv->SockMOut.Save(*SIn);
76    forever {
77      bool Ok; PNetObj NetObj=TNetObj::GetPckNetObj(NetSrv->SockMOut, Ok);
78      if (!Ok){OnError(SockId, -1, "Error reading net-object."); break;}
79      if (NetObj.Empty()){break;}
80      else {NetObj->PutSockId(SockId); NetSrv->OnNetObj(NetObj);}
81      if (!TSock::IsSockId(SockId)){
82        break;}
83    }
84  }
85  void TNetSrvSockEvent::OnWrite(const int& SockId){
86    PSock Sock=NetSrv->CltSockIdToSockH.GetDat(SockId);
87    if (!Sock.Empty()&&Sock->IsUnsent()){Sock->Send(PSIn());}
88  }
89  void TNetSrvSockEvent::OnClose(const int& SockId){
90    PSock CltSock=NetSrv->CltSockIdToSockH.GetDat(SockId);
91    CltSock->PutTimeOut(1);
92  }
93  void TNetSrvSockEvent::OnTimeOut(const int& SockId){
94    PNetObj NetClose=PNetObj(new TNetClose());
95    NetClose->PutSockId(SockId);
96    NetSrv->OnNetObj(NetClose);
97    NetSrv->DisconnClt(SockId);
98  }
99  void TNetSrvSockEvent::OnError(
100   const int& SockId, const int& ErrCd, const TStr& MsgStr){
101    PNetObj NetErr=PNetObj(new TNetErr(ErrCd, MsgStr));
102    NetErr->PutSockId(SockId);
103    NetSrv->OnNetObj(NetErr);
104    NetSrv->DisconnClt(SockId);
105  }
106  TNetSrv::TNetSrv(const int& _PortN, const bool& FixedPortNP):
107    PortN(_PortN),
108    SrvSockEvent(), SrvSock(),
109    CltSockIdToSockH(100),
110    SockMOut(){
111    SrvSockEvent=PSockEvent(new TNetSrvSockEvent(this));
112    TSockEvent::Reg(SrvSockEvent);
113    SrvSock=TSock::New(SrvSockEvent);
114    try {
115      if (FixedPortNP){
116        SrvSock->Listen(PortN);
117      } else {
<span onclick='openModal()' class='match'>118        PortN=SrvSock->GetPortAndListen(PortN);
119      }
120    } catch (...){TSockEvent::UnReg(SrvSockEvent); throw;}
121  }
</span>122  TNetSrv::~TNetSrv(){
123    TSockEvent::UnReg(SrvSockEvent);
124  }
125  void TNetSrv::Disconn(){
126    int SockIdToSockP=CltSockIdToSockH.FFirstKeyId();
127    while (CltSockIdToSockH.FNextKeyId(SockIdToSockP)){
128      int CltSockId=CltSockIdToSockH.GetKey(SockIdToSockP);
129      DisconnClt(CltSockId);
130    }
131    SrvSock=NULL;
132  }
133  void TNetSrv::DisconnClt(const int& CltSockId){
134    CltSockIdToSockH.DelKey(CltSockId);
135  }
136  void TNetSrv::SendNetObj(const int& CltSockId, const PNetObj& NetObj){
137    NetObj->PutSockId(CltSockId);
138    PSock CltSock=CltSockIdToSockH.GetDat(CltSockId);
139    CltSock->Send(TNetObj::GetPckSIn(NetObj));
140  }
141  void TNetSrv::BroadcastNetObj(const PNetObj& NetObj){
142    int SockIdToSockP=CltSockIdToSockH.FFirstKeyId();
143    while (CltSockIdToSockH.FNextKeyId(SockIdToSockP)){
144      int CltSockId=CltSockIdToSockH.GetKey(SockIdToSockP);
145      SendNetObj(CltSockId, NetObj);
146    }
147  }
148  const int TNetCltSockEvent::MxGetHostTrys=3;
149  TNetCltSockEvent::TNetCltSockEvent(TNetClt* _NetClt):
150    Mode(csmGetingHost), GetHostTrys(0),
151    NetClt(_NetClt){}
152  void TNetCltSockEvent::OnRead(const int& SockId, const PSIn& SIn){
153    IAssert(Mode==csmConnected);
154    NetClt->SockMOut.Save(*SIn);
155    forever {
156      bool Ok; PNetObj NetObj=TNetObj::GetPckNetObj(NetClt->SockMOut, Ok);
157      if (!Ok){OnError(SockId, -1, "Error reading net-object."); break;}
158      if (NetObj.Empty()){break;}
159      else {NetObj->PutSockId(SockId); NetClt->OnNetObj(NetObj);}
160      if (!TSock::IsSockId(SockId)){
161        break;}
162    }
163  }
164  void TNetCltSockEvent::OnWrite(const int& SockId){
165    if (!NetClt->Sock.Empty()&&NetClt->Sock->IsUnsent()){
166      NetClt->Sock->Send(PSIn());
167    }
168  }
169  void TNetCltSockEvent::OnConnect(const int& SockId){
170    IAssert(Mode==csmConnecting);
171    Mode=csmConnected;
172    PNetObj NetConn=PNetObj(new TNetConn());
173    NetConn->PutSockId(SockId);
174    NetClt->OnNetObj(NetConn);
175    NetClt->Sock->DelTimeOut();
176  }
177  void TNetCltSockEvent::OnClose(const int&){
178    Mode=csmAfterClose;
179    NetClt->Sock->PutTimeOut(1);
180  }
181  void TNetCltSockEvent::OnTimeOut(const int& SockId){
182    NetClt->Sock->DelTimeOut();
183    switch (Mode){
184      case csmConnecting: 
185        OnError(SockId, -1, "Connecting timeout"); break;
186      case csmConnected: 
187        break;
188      case csmAfterClose: 
189        {PNetObj NetClose=PNetObj(new TNetClose());
190        NetClose->PutSockId(SockId);
191        NetClt->OnNetObj(NetClose); break;}
192      default: Fail;
193    }
194  }
195  void TNetCltSockEvent::OnError(
196   const int& SockId, const int& ErrCd, const TStr& MsgStr){
197    PNetObj NetErr=PNetObj(new TNetErr(ErrCd, MsgStr));
198    NetErr->PutSockId(SockId);
199    NetClt->OnNetObj(NetErr);
200  }
201  void TNetCltSockEvent::OnGetHost(const PSockHost& SockHost){
202    IAssert(Mode==csmGetingHost);
203    if (SockHost->IsOk()){
204      Mode=csmConnecting;
205      NetClt->Sock=PSock(new TSock(this));
206      NetClt->Sock->Connect(SockHost, NetClt->GetPortN());
207      NetClt->Sock->PutTimeOut(10*1000);
208    } else
209    if (SockHost->GetStatus()==shsTryAgain){
210      GetHostTrys++;
211      if (GetHostTrys<MxGetHostTrys){
212        TSockHost::GetAsyncSockHost(NetClt->GetHostNm(), this);
213      } else {
214        OnError(-1, -1, "Can't get host info");
215      }
216    } else {
217      OnError(-1, -1, "Invalid host");
218    }
219  }
220  TNetClt::TNetClt(
221   const TStr& _HostNm, const int& _PortN,
222   const TStr& _UsrNm, const TStr& _PwdStr):
223    HostNm(_HostNm), PortN(_PortN),
224    SockEvent(), Sock(), SockMOut(),
225    UsrNm(_UsrNm), PwdStr(_PwdStr){
226    SockEvent=PSockEvent(new TNetCltSockEvent(this));
227    TSockEvent::Reg(SockEvent);
228    TSockHost::GetAsyncSockHost(HostNm, SockEvent);
229  }
230  TNetClt::~TNetClt(){
231    TSockEvent::UnReg(SockEvent);
232  }
233  void TNetClt::SendNetObj(const PNetObj& NetObj){
234    NetObj->PutSockId(Sock->GetSockId());
235    Sock->Send(TNetObj::GetPckSIn(NetObj));
236  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-websrv.cpp</h3>
            <pre><code>1  void TWebSrvSockEvent::OnRead(const int& SockId, const PSIn& SIn){
2    WebSrv->OnRead(SockId, SIn);}
3  void TWebSrvSockEvent::OnWrite(const int& SockId){
4    WebSrv->OnWrite(SockId);}
5  void TWebSrvSockEvent::OnOob(const int& SockId){
6    WebSrv->OnOob(SockId);}
7  void TWebSrvSockEvent::OnAccept(const int& SockId, const PSock& Sock){
8    WebSrv->OnAccept(SockId, Sock);}
9  void TWebSrvSockEvent::OnConnect(const int& SockId){
10    WebSrv->OnConnect(SockId);}
11  void TWebSrvSockEvent::OnClose(const int& SockId){
12    WebSrv->OnClose(SockId);}
13  void TWebSrvSockEvent::OnTimeOut(const int& SockId){
14    WebSrv->OnTimeOut(SockId);}
15  void TWebSrvSockEvent::OnError(
16   const int& SockId, const int& ErrCd, const TStr& ErrStr){
17    WebSrv->OnError(SockId, ErrCd, ErrStr);}
18  void TWebSrvSockEvent::OnGetHost(const PSockHost& SockHost){
19    WebSrv->OnGetHost(SockHost);}
20  TWebSrv::TWebSrv(
21   const int& _PortN, const bool& FixedPortNP, const PNotify& _Notify):
22    Notify(_Notify),
23    PortN(_PortN),
24    HomeNrFPath(TStr::GetNrFPath(TDir::GetCurDir())),
25    SockEvent(), Sock(),
26    SockIdToConnH(){
27    SockEvent=PSockEvent(new TWebSrvSockEvent(this));
28    TSockEvent::Reg(SockEvent);
29    Sock=TSock::New(SockEvent);
30    try {
31      if (FixedPortNP){
32        Sock->Listen(PortN);
33      } else {
<span onclick='openModal()' class='match'>34        PortN=Sock->GetPortAndListen(PortN);
35      }
36    } catch (...){TSockEvent::UnReg(SockEvent); throw;}
37    TChA MsgChA;
</span>38    MsgChA+="Web-Server: Started at port ";
39    MsgChA+=TInt::GetStr(PortN); MsgChA+=".";
40    TNotify::OnNotify(Notify, ntInfo, MsgChA);
41  }
42  TWebSrv::~TWebSrv(){
43    TSockEvent::UnReg(SockEvent);
44    TNotify::OnNotify(Notify, ntInfo, "Web-Server: Stopped.");
45  }
46  void TWebSrv::OnRead(const int& SockId, const PSIn& SIn){
47    TChA PckChA; TChA::LoadTxt(SIn, PckChA);
48    if (PckChA.Empty()){return;}
49    TChA& HttpRqChA=GetConn(SockId)->GetHttpRqChA();
50    HttpRqChA+=PckChA;
51    PSIn HttpRqSIn=TMIn::New(HttpRqChA);
52    PHttpRq HttpRq=THttpRq::New(HttpRqSIn);
53    if (HttpRq->IsComplete()){
54      GetConn(SockId)->PutType(wsctWaitingToRespond);
55      OnHttpRq(SockId, HttpRq);
56    }
57  }
58  void TWebSrv::OnWrite(const int& SockId){
59    if (GetConn(SockId)->GetType()==wsctSending){
60      PSock Sock=GetConn(SockId)->GetSock();
61      if (Sock->IsUnsent()){
62        Sock->Send(NULL);}
63      if (!Sock->IsUnsent()){
64        DelConn(SockId);
65      }
66    }
67  }
68  void TWebSrv::OnAccept(const int& SockId, const PSock& Sock){
69    PWebSrvConn Conn=TWebSrvConn::New(Sock, this);
70    AddConn(SockId, Conn);
71    Sock->PutTimeOut(25*1000);
72    Conn->PutType(wsctReceiving);
73  }
74  void TWebSrv::OnClose(const int& SockId){
75    DelConn(SockId);
76  }
77  void TWebSrv::OnTimeOut(const int& SockId){
78    DelConn(SockId);
79  }
80  void TWebSrv::OnError(const int& SockId, const int& &bsol;*ErrCd*/, const TStr& ErrStr){
81    DelConn(SockId);
82    TChA MsgChA; MsgChA+="Web-Server: Error: '"; MsgChA+=ErrStr; MsgChA+="'.";
83    TNotify::OnNotify(Notify, ntInfo, MsgChA);
84  }
85  void TWebSrv::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
86    if (!HttpRq->IsOk()){
87      TNotify::OnNotify(Notify, ntInfo, "Web-Server: Bad Http Request.");
88      return;
89    }
90    PUrl RqUrl=HttpRq->GetUrl();
91    if (!RqUrl->IsOk()){
92      TNotify::OnNotify(Notify, ntInfo, "Web-Server: Bad Url Requested.");
93      return;
94    }
95    PHttpResp HttpResp;
96    if (!RqUrl->GetPathStr().Empty()){
97      TStr ExeFPath=TSysProc::GetExeFNm().GetFPath();
98      TStr RqFNm=RqUrl->GetPathStr();
99      if (RqFNm.LastCh()=='/'){RqFNm=RqFNm+"default.htm";}
100      if ((RqFNm[0]=='/')||(RqFNm[0]=='\\')){RqFNm.DelSubStr(0, 0);}
101      RqFNm=ExeFPath+RqFNm;
102      bool RqFOpened=false; PSIn RqSIn=TFIn::New(RqFNm, RqFOpened);
103      if (!RqFOpened){
104        TChA HtmlChA;
105        HtmlChA+="<html><title>Error - Not Found</title><body>";
106        HtmlChA+="File: "; HtmlChA+=RqUrl->GetPathStr(); HtmlChA+=" not found.";
107        HtmlChA+="</body></html>";
108        PSIn BodySIn=TMIn::New(HtmlChA);
109        HttpResp=PHttpResp(new THttpResp(
110         THttp::ErrNotFoundStatusCd, THttp::TextHtmlFldVal, false, BodySIn, ""));
111      } else {
112        PSIn BodySIn=RqSIn;
113        if (THttp::IsHtmlFExt(RqFNm.GetFExt())){
114          HttpResp=PHttpResp(new THttpResp(
115           THttp::OkStatusCd, THttp::TextHtmlFldVal, false, BodySIn, ""));
116        } else
117        if (THttp::IsGifFExt(RqFNm.GetFExt())){
118          HttpResp=PHttpResp(new THttpResp(
119           THttp::OkStatusCd, THttp::ImageGifFldVal, false, BodySIn, ""));
120        } else {
121          HttpResp=PHttpResp(new THttpResp(
122           THttp::OkStatusCd, THttp::AppOctetFldVal, false, BodySIn, ""));
123        }
124      }
125    } else {
126      TChA HtmlChA;
127      HtmlChA+="<html><title>Tralala Hopsasa</title><body>";
128      HtmlChA+=TSecTm::GetCurTm().GetStr();
129      HtmlChA+="</body></html>";
130      PSIn BodySIn=TMIn::New(HtmlChA);
131      HttpResp=THttpResp::New(
132       THttp::OkStatusCd, THttp::TextHtmlFldVal, false, BodySIn);
133    }
134    SendHttpResp(SockId, HttpResp);
135    if (RqUrl->IsOk()){
136      TChA MsgChA;
137      MsgChA+="Web-Server: Request for '";
138      MsgChA+=RqUrl->GetUrlStr(); MsgChA+="'.";
139      TNotify::OnNotify(Notify, ntInfo, MsgChA);
140    }
141  }
142  void TWebSrv::SendHttpResp(const int& SockId, const PHttpResp& HttpResp){
143    PWebSrvConn Conn;
144    if (IsConn(SockId, Conn)){
145      if (Conn->GetType()==wsctWaitingToRespond){
146        Conn->Send(HttpResp->GetSIn());
147        GetConn(SockId)->PutType(wsctSending);
148        if (!Conn->GetSock()->IsUnsent()){
149          DelConn(SockId);
150        }
151      } else {
152        OnError(SockId, -1, "Connection is not ready for http-response");
153      }
154    }
155  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-netobj.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-websrv.cpp</div>
                </div>
                <div class="column column_space"><pre><code>118        PortN=SrvSock->GetPortAndListen(PortN);
119      }
120    } catch (...){TSockEvent::UnReg(SrvSockEvent); throw;}
121  }
</pre></code></div>
                <div class="column column_space"><pre><code>34        PortN=Sock->GetPortAndListen(PortN);
35      }
36    } catch (...){TSockEvent::UnReg(SockEvent); throw;}
37    TChA MsgChA;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    