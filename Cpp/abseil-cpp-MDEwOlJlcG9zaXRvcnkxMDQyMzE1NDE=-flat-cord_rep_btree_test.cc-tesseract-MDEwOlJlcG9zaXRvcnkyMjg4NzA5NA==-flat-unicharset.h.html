
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_btree.h"
2  #include <cmath>
3  #include <deque>
4  #include <iostream>
5  #include <string>
6  #include <vector>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/raw_logging.h"
11  #include "absl/cleanup/cleanup.h"
12  #include "absl/strings/internal/cord_data_edge.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_test_util.h"
15  #include "absl/strings/str_cat.h"
16  #include "absl/strings/string_view.h"
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace cord_internal {
20  class CordRepBtreeTestPeer {
21   public:
22    static void SetEdge(CordRepBtree* node, size_t idx, CordRep* edge) {
23      node->edges_[idx] = edge;
24    }
25    static void AddEdge(CordRepBtree* node, CordRep* edge) {
26      node->edges_[node->fetch_add_end(1)] = edge;
27    }
28  };
29  namespace {
30  using ::absl::cordrep_testing::AutoUnref;
31  using ::absl::cordrep_testing::CordCollectRepsIf;
32  using ::absl::cordrep_testing::CordToString;
33  using ::absl::cordrep_testing::CordVisitReps;
34  using ::absl::cordrep_testing::CreateFlatsFromString;
35  using ::absl::cordrep_testing::CreateRandomString;
36  using ::absl::cordrep_testing::MakeExternal;
37  using ::absl::cordrep_testing::MakeFlat;
38  using ::absl::cordrep_testing::MakeSubstring;
39  using ::testing::_;
40  using ::testing::AllOf;
41  using ::testing::AnyOf;
42  using ::testing::Conditional;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::Eq;
46  using ::testing::HasSubstr;
47  using ::testing::Le;
48  using ::testing::Ne;
49  using ::testing::Not;
50  using ::testing::SizeIs;
51  using ::testing::TypedEq;
52  MATCHER_P(EqFlatHolding, data, "Equals flat holding data") {
53    if (arg->tag < FLAT) {
54      *result_listener << "Expected FLAT, got tag " << static_cast<int>(arg->tag);
55      return false;
56    }
<span onclick='openModal()' class='match'>57    std::string actual = CordToString(arg);
58    if (actual != data) {
59      *result_listener << "Expected flat holding \"" << data
</span>60                       << "\", got flat holding \"" << actual << "\"";
61      return false;
62    }
63    return true;
64  }
65  MATCHER_P(IsNode, height, absl::StrCat("Is a valid node of height ", height)) {
66    if (arg == nullptr) {
67      *result_listener << "Expected NODE, got nullptr";
68      return false;
69    }
70    if (arg->tag != BTREE) {
71      *result_listener << "Expected NODE, got " << static_cast<int>(arg->tag);
72      return false;
73    }
74    if (!CordRepBtree::IsValid(arg->btree())) {
75      CordRepBtree::Dump(arg->btree(), "Expected valid NODE, got:", false,
76                         *result_listener->stream());
77      return false;
78    }
79    if (arg->btree()->height() != height) {
80      *result_listener << "Expected NODE of height " << height << ", got "
81                       << arg->btree()->height();
82      return false;
83    }
84    return true;
85  }
86  MATCHER_P2(IsSubstring, start, length,
87             absl::StrCat("Is a substring(start = ", start, ", length = ", length,
88                          ")")) {
89    if (arg == nullptr) {
90      *result_listener << "Expected substring, got nullptr";
91      return false;
92    }
93    if (arg->tag != SUBSTRING) {
94      *result_listener << "Expected SUBSTRING, got "
95                       << static_cast<int>(arg->tag);
96      return false;
97    }
98    const CordRepSubstring* const substr = arg->substring();
99    if (substr->start != start || substr->length != length) {
100      *result_listener << "Expected substring(" << start << ", " << length
101                       << "), got substring(" << substr->start << ", "
102                       << substr->length << ")";
103      return false;
104    }
105    return true;
106  }
107  MATCHER_P2(EqExtractResult, tree, rep, "Equals ExtractResult") {
108    if (arg.tree != tree || arg.extracted != rep) {
109      *result_listener << "Expected {" << static_cast<const void*>(tree) << ", "
110                       << static_cast<const void*>(rep) << "}, got {" << arg.tree
111                       << ", " << arg.extracted << "}";
112      return false;
113    }
114    return true;
115  }
116  class DataConsumer {
117   public:
118    DataConsumer(absl::string_view data, bool forward)
119        : data_(data), forward_(forward) {}
120    absl::string_view Next(size_t n) {
121      assert(n <= data_.size() - consumed_);
122      consumed_ += n;
123      return data_.substr(forward_ ? consumed_ - n : data_.size() - consumed_, n);
124    }
125    absl::string_view Consumed() const {
126      return forward_ ? data_.substr(0, consumed_)
127                      : data_.substr(data_.size() - consumed_);
128    }
129   private:
130    absl::string_view data_;
131    size_t consumed_ = 0;
132    bool forward_;
133  };
134  CordRepBtree* BtreeAdd(CordRepBtree* node, bool append,
135                         absl::string_view data) {
136    return append ? CordRepBtree::Append(node, data)
137                  : CordRepBtree::Prepend(node, data);
138  }
139  void GetLeafEdges(const CordRepBtree* tree, std::vector<CordRep*>& edges) {
140    if (tree->height() == 0) {
141      for (CordRep* edge : tree->Edges()) {
142        edges.push_back(edge);
143      }
144    } else {
145      for (CordRep* edge : tree->Edges()) {
146        GetLeafEdges(edge->btree(), edges);
147      }
148    }
149  }
150  std::vector<CordRep*> GetLeafEdges(const CordRepBtree* tree) {
151    std::vector<CordRep*> edges;
152    GetLeafEdges(tree, edges);
153    return edges;
154  }
155  CordRepFlat* MakeHexFlat(size_t i) {
156    return MakeFlat(absl::StrCat("0x", absl::Hex(i, absl::kZeroPad4)));
157  }
158  CordRepBtree* MakeLeaf(size_t size = CordRepBtree::kMaxCapacity) {
159    assert(size <= CordRepBtree::kMaxCapacity);
160    CordRepBtree* leaf = CordRepBtree::Create(MakeHexFlat(0));
161    for (size_t i = 1; i < size; ++i) {
162      leaf = CordRepBtree::Append(leaf, MakeHexFlat(i));
163    }
164    return leaf;
165  }
166  CordRepBtree* MakeTree(size_t size, bool append = true) {
167    CordRepBtree* tree = CordRepBtree::Create(MakeHexFlat(0));
168    for (size_t i = 1; i < size; ++i) {
169      tree = append ? CordRepBtree::Append(tree, MakeHexFlat(i))
170                    : CordRepBtree::Prepend(tree, MakeHexFlat(i));
171    }
172    return tree;
173  }
174  CordRepBtree* CreateTree(absl::Span<CordRep* const> reps) {
175    auto it = reps.begin();
176    CordRepBtree* tree = CordRepBtree::Create(*it);
177    while (++it != reps.end()) tree = CordRepBtree::Append(tree, *it);
178    return tree;
179  }
180  CordRepBtree* CreateTree(absl::string_view data, size_t chunk_size) {
181    return CreateTree(CreateFlatsFromString(data, chunk_size));
182  }
183  CordRepBtree* CreateTreeReverse(absl::string_view data, size_t chunk_size) {
184    std::vector<CordRep*> flats = CreateFlatsFromString(data, chunk_size);
185    auto rit = flats.rbegin();
186    CordRepBtree* tree = CordRepBtree::Create(*rit);
187    while (++rit != flats.rend()) tree = CordRepBtree::Prepend(tree, *rit);
188    return tree;
189  }
190  class CordRepBtreeTest : public testing::TestWithParam<bool> {
191   public:
192    bool shared() const { return GetParam(); }
193    static std::string ToString(testing::TestParamInfo<bool> param) {
194      return param.param ? "Shared" : "Private";
195    }
196  };
197  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeTest, testing::Bool(),
198                           CordRepBtreeTest::ToString);
199  class CordRepBtreeHeightTest : public testing::TestWithParam<int> {
200   public:
201    int height() const { return GetParam(); }
202    static std::string ToString(testing::TestParamInfo<int> param) {
203      return absl::StrCat(param.param);
204    }
205  };
206  INSTANTIATE_TEST_SUITE_P(WithHeights, CordRepBtreeHeightTest,
207                           testing::Range(0, CordRepBtree::kMaxHeight),
208                           CordRepBtreeHeightTest::ToString);
209  using TwoBools = testing::tuple<bool, bool>;
210  class CordRepBtreeDualTest : public testing::TestWithParam<TwoBools> {
211   public:
212    bool first_shared() const { return std::get<0>(GetParam()); }
213    bool second_shared() const { return std::get<1>(GetParam()); }
214    static std::string ToString(testing::TestParamInfo<TwoBools> param) {
215      if (std::get<0>(param.param)) {
216        return std::get<1>(param.param) ? "BothShared" : "FirstShared";
217      }
218      return std::get<1>(param.param) ? "SecondShared" : "Private";
219    }
220  };
221  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeDualTest,
222                           testing::Combine(testing::Bool(), testing::Bool()),
223                           CordRepBtreeDualTest::ToString);
224  TEST(CordRepBtreeTest, SizeIsMultipleOf64) {
225    if (sizeof(size_t) == 8 && sizeof(void*) == 8) {
226      EXPECT_THAT(sizeof(CordRepBtree) % 64, Eq(0u))
227          << "Should be multiple of 64";
228    }
229  }
230  TEST(CordRepBtreeTest, NewDestroyEmptyTree) {
231    auto* tree = CordRepBtree::New();
232    EXPECT_THAT(tree->size(), Eq(0u));
233    EXPECT_THAT(tree->height(), Eq(0));
234    EXPECT_THAT(tree->Edges(), ElementsAre());
235    CordRepBtree::Destroy(tree);
236  }
237  TEST(CordRepBtreeTest, NewDestroyEmptyTreeAtHeight) {
238    auto* tree = CordRepBtree::New(3);
239    EXPECT_THAT(tree->size(), Eq(0u));
240    EXPECT_THAT(tree->height(), Eq(3));
241    EXPECT_THAT(tree->Edges(), ElementsAre());
242    CordRepBtree::Destroy(tree);
243  }
244  TEST(CordRepBtreeTest, Btree) {
245    CordRep* rep = CordRepBtree::New();
246    EXPECT_THAT(rep->btree(), Eq(rep));
247    EXPECT_THAT(static_cast<const CordRep*>(rep)->btree(), Eq(rep));
248    CordRep::Unref(rep);
249  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
250    rep = MakeFlat("Hello world");
251    EXPECT_DEATH(rep->btree(), ".*");
252    EXPECT_DEATH(static_cast<const CordRep*>(rep)->btree(), ".*");
253    CordRep::Unref(rep);
254  #endif
255  }
256  TEST(CordRepBtreeTest, EdgeData) {
257    CordRepFlat* flat = MakeFlat("Hello world");
258    CordRepExternal* external = MakeExternal("Hello external");
259    CordRep* substr1 = MakeSubstring(1, 6, CordRep::Ref(flat));
260    CordRep* substr2 = MakeSubstring(1, 6, CordRep::Ref(external));
261    CordRep* bad_substr = MakeSubstring(1, 2, CordRep::Ref(substr1));
262    EXPECT_TRUE(IsDataEdge(flat));
263    EXPECT_THAT(EdgeData(flat).data(), TypedEq<const void*>(flat->Data()));
264    EXPECT_THAT(EdgeData(flat), Eq("Hello world"));
265    EXPECT_TRUE(IsDataEdge(external));
266    EXPECT_THAT(EdgeData(external).data(), TypedEq<const void*>(external->base));
267    EXPECT_THAT(EdgeData(external), Eq("Hello external"));
268    EXPECT_TRUE(IsDataEdge(substr1));
269    EXPECT_THAT(EdgeData(substr1).data(), TypedEq<const void*>(flat->Data() + 1));
270    EXPECT_THAT(EdgeData(substr1), Eq("ello w"));
271    EXPECT_TRUE(IsDataEdge(substr2));
272    EXPECT_THAT(EdgeData(substr2).data(),
273                TypedEq<const void*>(external->base + 1));
274    EXPECT_THAT(EdgeData(substr2), Eq("ello e"));
275    EXPECT_FALSE(IsDataEdge(bad_substr));
276  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
277    EXPECT_DEATH(EdgeData(bad_substr), ".*");
278  #endif
279    CordRep::Unref(bad_substr);
280    CordRep::Unref(substr2);
281    CordRep::Unref(substr1);
282    CordRep::Unref(external);
283    CordRep::Unref(flat);
284  }
285  TEST(CordRepBtreeTest, CreateUnrefLeaf) {
286    auto* flat = MakeFlat("a");
287    auto* leaf = CordRepBtree::Create(flat);
288    EXPECT_THAT(leaf->size(), Eq(1u));
289    EXPECT_THAT(leaf->height(), Eq(0));
290    EXPECT_THAT(leaf->Edges(), ElementsAre(flat));
291    CordRepBtree::Unref(leaf);
292  }
293  TEST(CordRepBtreeTest, NewUnrefNode) {
294    auto* leaf = CordRepBtree::Create(MakeFlat("a"));
295    CordRepBtree* tree = CordRepBtree::New(leaf);
296    EXPECT_THAT(tree->size(), Eq(1u));
297    EXPECT_THAT(tree->height(), Eq(1));
298    EXPECT_THAT(tree->Edges(), ElementsAre(leaf));
299    CordRepBtree::Unref(tree);
300  }
301  TEST_P(CordRepBtreeTest, AppendToLeafToCapacity) {
302    AutoUnref refs;
303    std::vector<CordRep*> flats;
304    flats.push_back(MakeHexFlat(0));
305    auto* leaf = CordRepBtree::Create(flats.back());
306    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
307      refs.RefIf(shared(), leaf);
308      flats.push_back(MakeHexFlat(i));
309      auto* result = CordRepBtree::Append(leaf, flats.back());
310      EXPECT_THAT(result->height(), Eq(0));
311      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
312      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
313      leaf = result;
314    }
315    CordRep::Unref(leaf);
316  }
317  TEST_P(CordRepBtreeTest, PrependToLeafToCapacity) {
318    AutoUnref refs;
319    std::deque<CordRep*> flats;
320    flats.push_front(MakeHexFlat(0));
321    auto* leaf = CordRepBtree::Create(flats.front());
322    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
323      refs.RefIf(shared(), leaf);
324      flats.push_front(MakeHexFlat(i));
325      auto* result = CordRepBtree::Prepend(leaf, flats.front());
326      EXPECT_THAT(result->height(), Eq(0));
327      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
328      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
329      leaf = result;
330    }
331    CordRep::Unref(leaf);
332  }
333  TEST_P(CordRepBtreeTest, AppendPrependToLeafToCapacity) {
334    AutoUnref refs;
335    std::deque<CordRep*> flats;
336    flats.push_front(MakeHexFlat(0));
337    auto* leaf = CordRepBtree::Create(flats.front());
338    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
339      refs.RefIf(shared(), leaf);
340      CordRepBtree* result;
341      if (i % 2 != 0) {
342        flats.push_front(MakeHexFlat(i));
343        result = CordRepBtree::Prepend(leaf, flats.front());
344      } else {
345        flats.push_back(MakeHexFlat(i));
346        result = CordRepBtree::Append(leaf, flats.back());
347      }
348      EXPECT_THAT(result->height(), Eq(0));
349      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
350      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
351      leaf = result;
352    }
353    CordRep::Unref(leaf);
354  }
355  TEST_P(CordRepBtreeTest, AppendToLeafBeyondCapacity) {
356    AutoUnref refs;
357    auto* leaf = MakeLeaf();
358    refs.RefIf(shared(), leaf);
359    CordRep* flat = MakeFlat("abc");
360    auto* result = CordRepBtree::Append(leaf, flat);
361    ASSERT_THAT(result, IsNode(1));
362    EXPECT_THAT(result, Ne(leaf));
363    absl::Span<CordRep* const> edges = result->Edges();
364    ASSERT_THAT(edges, ElementsAre(leaf, IsNode(0)));
365    EXPECT_THAT(edges[1]->btree()->Edges(), ElementsAre(flat));
366    CordRep::Unref(result);
367  }
368  TEST_P(CordRepBtreeTest, PrependToLeafBeyondCapacity) {
369    AutoUnref refs;
370    auto* leaf = MakeLeaf();
371    refs.RefIf(shared(), leaf);
372    CordRep* flat = MakeFlat("abc");
373    auto* result = CordRepBtree::Prepend(leaf, flat);
374    ASSERT_THAT(result, IsNode(1));
375    EXPECT_THAT(result, Ne(leaf));
376    absl::Span<CordRep* const> edges = result->Edges();
377    ASSERT_THAT(edges, ElementsAre(IsNode(0), leaf));
378    EXPECT_THAT(edges[0]->btree()->Edges(), ElementsAre(flat));
379    CordRep::Unref(result);
380  }
381  TEST_P(CordRepBtreeTest, AppendToTreeOneDeep) {
382    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
383    AutoUnref refs;
384    std::vector<CordRep*> flats;
385    flats.push_back(MakeHexFlat(0));
386    CordRepBtree* tree = CordRepBtree::Create(flats.back());
387    for (size_t i = 1; i <= max_cap; ++i) {
388      flats.push_back(MakeHexFlat(i));
389      tree = CordRepBtree::Append(tree, flats.back());
390    }
391    ASSERT_THAT(tree, IsNode(1));
392    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
393      refs.RefIf(shared(), tree);
394      refs.RefIf(i % 4 == 0, tree->Edges().back());
395      flats.push_back(MakeHexFlat(i));
396      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
397      ASSERT_THAT(result, IsNode(1));
398      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
399      std::vector<CordRep*> edges = GetLeafEdges(result);
400      ASSERT_THAT(edges, ElementsAreArray(flats));
401      tree = result;
402    }
403    CordRep::Unref(tree);
404  }
405  TEST_P(CordRepBtreeTest, AppendToTreeTwoDeep) {
406    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
407    AutoUnref refs;
408    std::vector<CordRep*> flats;
409    flats.push_back(MakeHexFlat(0));
410    CordRepBtree* tree = CordRepBtree::Create(flats.back());
411    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
412      flats.push_back(MakeHexFlat(i));
413      tree = CordRepBtree::Append(tree, flats.back());
414    }
415    ASSERT_THAT(tree, IsNode(2));
416    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
417      refs.RefIf(shared(), tree);
418      refs.RefIf(i % 16 == 0, tree->Edges().back());
419      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
420      flats.push_back(MakeHexFlat(i));
421      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
422      ASSERT_THAT(result, IsNode(2));
423      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
424      std::vector<CordRep*> edges = GetLeafEdges(result);
425      ASSERT_THAT(edges, ElementsAreArray(flats));
426      tree = result;
427    }
428    CordRep::Unref(tree);
429  }
430  TEST_P(CordRepBtreeTest, PrependToTreeOneDeep) {
431    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
432    AutoUnref refs;
433    std::deque<CordRep*> flats;
434    flats.push_back(MakeHexFlat(0));
435    CordRepBtree* tree = CordRepBtree::Create(flats.back());
436    for (size_t i = 1; i <= max_cap; ++i) {
437      flats.push_front(MakeHexFlat(i));
438      tree = CordRepBtree::Prepend(tree, flats.front());
439    }
440    ASSERT_THAT(tree, IsNode(1));
441    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
442      refs.RefIf(shared(), tree);
443      refs.RefIf(i % 4 == 0, tree->Edges().back());
444      flats.push_front(MakeHexFlat(i));
445      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
446      ASSERT_THAT(result, IsNode(1));
447      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
448      std::vector<CordRep*> edges = GetLeafEdges(result);
449      ASSERT_THAT(edges, ElementsAreArray(flats));
450      tree = result;
451    }
452    CordRep::Unref(tree);
453  }
454  TEST_P(CordRepBtreeTest, PrependToTreeTwoDeep) {
455    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
456    AutoUnref refs;
457    std::deque<CordRep*> flats;
458    flats.push_back(MakeHexFlat(0));
459    CordRepBtree* tree = CordRepBtree::Create(flats.back());
460    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
461      flats.push_front(MakeHexFlat(i));
462      tree = CordRepBtree::Prepend(tree, flats.front());
463    }
464    ASSERT_THAT(tree, IsNode(2));
465    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
466      refs.RefIf(shared(), tree);
467      refs.RefIf(i % 16 == 0, tree->Edges().back());
468      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
469      flats.push_front(MakeHexFlat(i));
470      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
471      ASSERT_THAT(result, IsNode(2));
472      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
473      std::vector<CordRep*> edges = GetLeafEdges(result);
474      ASSERT_THAT(edges, ElementsAreArray(flats));
475      tree = result;
476    }
477    CordRep::Unref(tree);
478  }
479  TEST_P(CordRepBtreeDualTest, MergeLeafsNotExceedingCapacity) {
480    for (bool use_append : {false, true}) {
481      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
482      AutoUnref refs;
483      std::vector<CordRep*> flats;
484      CordRepBtree* left = MakeLeaf(3);
485      GetLeafEdges(left, flats);
486      refs.RefIf(first_shared(), left);
487      CordRepBtree* right = MakeLeaf(2);
488      GetLeafEdges(right, flats);
489      refs.RefIf(second_shared(), right);
490      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
491                                      : CordRepBtree::Prepend(right, left);
492      EXPECT_THAT(tree, IsNode(0));
493      EXPECT_THAT(tree->Edges(), ElementsAreArray(flats));
494      CordRepBtree::Unref(tree);
495    }
496  }
497  TEST_P(CordRepBtreeDualTest, MergeLeafsExceedingCapacity) {
498    for (bool use_append : {false, true}) {
499      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
500      AutoUnref refs;
501      CordRepBtree* left = MakeLeaf(CordRepBtree::kMaxCapacity - 2);
502      refs.RefIf(first_shared(), left);
503      CordRepBtree* right = MakeLeaf(CordRepBtree::kMaxCapacity - 1);
504      refs.RefIf(second_shared(), right);
505      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
506                                      : CordRepBtree::Prepend(right, left);
507      EXPECT_THAT(tree, IsNode(1));
508      EXPECT_THAT(tree->Edges(), ElementsAre(left, right));
509      CordRepBtree::Unref(tree);
510    }
511  }
512  TEST_P(CordRepBtreeDualTest, MergeEqualHeightTrees) {
513    for (bool use_append : {false, true}) {
514      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
515      AutoUnref refs;
516      std::vector<CordRep*> flats;
517      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3);
518      GetLeafEdges(left, flats);
519      refs.RefIf(first_shared(), left);
520      CordRepBtree* right = MakeTree(CordRepBtree::kMaxCapacity * 2);
521      GetLeafEdges(right, flats);
522      refs.RefIf(second_shared(), right);
523      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
524                                      : CordRepBtree::Prepend(right, left);
525      EXPECT_THAT(tree, IsNode(1));
526      EXPECT_THAT(tree->Edges(), SizeIs(5u));
527      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
528      CordRepBtree::Unref(tree);
529    }
530  }
531  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeNotExceedingLeafCapacity) {
532    for (bool use_append : {false, true}) {
533      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
534      AutoUnref refs;
535      std::vector<CordRep*> flats;
536      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 2 + 2);
537      GetLeafEdges(left, flats);
538      refs.RefIf(first_shared(), left);
539      CordRepBtree* right = MakeTree(3);
540      GetLeafEdges(right, flats);
541      refs.RefIf(second_shared(), right);
542      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
543                                      : CordRepBtree::Prepend(right, left);
544      EXPECT_THAT(tree, IsNode(1));
545      EXPECT_THAT(tree->Edges(), SizeIs(3u));
546      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
547      CordRepBtree::Unref(tree);
548    }
549  }
550  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeExceedingLeafCapacity) {
551    for (bool use_append : {false, true}) {
552      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
553      AutoUnref refs;
554      std::vector<CordRep*> flats;
555      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3 - 2);
556      GetLeafEdges(left, flats);
557      refs.RefIf(first_shared(), left);
558      CordRepBtree* right = MakeTree(3);
559      GetLeafEdges(right, flats);
560      refs.RefIf(second_shared(), right);
561      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
562                                      : CordRepBtree::Prepend(right, left);
563      EXPECT_THAT(tree, IsNode(1));
564      EXPECT_THAT(tree->Edges(), SizeIs(4u));
565      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
566      CordRepBtree::Unref(tree);
567    }
568  }
569  void RefEdgesAt(size_t depth, AutoUnref& refs, CordRepBtree* tree) {
570    absl::Span<CordRep* const> edges = tree->Edges();
571    if (depth == 0) {
572      refs.Ref(edges.front());
573      refs.Ref(edges.back());
574    } else {
575      assert(tree->height() > 0);
576      RefEdgesAt(depth - 1, refs, edges.front()->btree());
577      RefEdgesAt(depth - 1, refs, edges.back()->btree());
578    }
579  }
580  TEST(CordRepBtreeTest, MergeFuzzTest) {
581    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
582    std::minstd_rand rnd;
583    std::uniform_int_distribution<int> coin_flip(0, 1);
584    std::uniform_int_distribution<int> dice_throw(1, 6);
585    auto random_leaf_count = [&]() {
586      std::uniform_int_distribution<int> dist_height(0, 3);
587      std::uniform_int_distribution<int> dist_leaf(0, max_cap - 1);
588      const int height = dist_height(rnd);
589      return (height ? pow(max_cap, height) : 0) + dist_leaf(rnd);
590    };
591    for (int i = 0; i < 10000; ++i) {
592      AutoUnref refs;
593      std::vector<CordRep*> flats;
594      CordRepBtree* left = MakeTree(random_leaf_count(), coin_flip(rnd));
595      GetLeafEdges(left, flats);
596      if (dice_throw(rnd) == 1) {
597        std::uniform_int_distribution<size_t> dist(
598            0, static_cast<size_t>(left->height()));
599        RefEdgesAt(dist(rnd), refs, left);
600      }
601      CordRepBtree* right = MakeTree(random_leaf_count(), coin_flip(rnd));
602      GetLeafEdges(right, flats);
603      if (dice_throw(rnd) == 1) {
604        std::uniform_int_distribution<size_t> dist(
605            0, static_cast<size_t>(right->height()));
606        RefEdgesAt(dist(rnd), refs, right);
607      }
608      CordRepBtree* tree = CordRepBtree::Append(left, right);
609      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
610      CordRepBtree::Unref(tree);
611    }
612  }
613  TEST_P(CordRepBtreeTest, RemoveSuffix) {
614    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
615    for (size_t cap : {max_cap - 1, max_cap * 2, max_cap * max_cap * 2}) {
616      const std::string data = CreateRandomString(cap * 512);
617      {
618        AutoUnref refs;
619        CordRepBtree* node = refs.RefIf(shared(), CreateTree(data, 512));
620        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, data.length()), Eq(nullptr));
621        node = refs.RefIf(shared(), CreateTree(data, 512));
622        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, 0), Eq(node));
623        CordRep::Unref(node);
624      }
625      for (size_t n = 1; n < data.length(); ++n) {
626        AutoUnref refs;
627        auto flats = CreateFlatsFromString(data, 512);
628        CordRepBtree* node = refs.RefIf(shared(), CreateTree(flats));
629        CordRep* rep = refs.Add(CordRepBtree::RemoveSuffix(node, n));
630        EXPECT_THAT(CordToString(rep), Eq(data.substr(0, data.length() - n)));
631        auto is_flat = [](CordRep* rep) { return rep->tag >= FLAT; };
632        std::vector<CordRep*> edges = CordCollectRepsIf(is_flat, rep);
633        ASSERT_THAT(edges.size(), Le(flats.size()));
634        CordRep* last_edge = edges.back();
635        edges.pop_back();
636        const size_t last_length = rep->length - edges.size() * 512;
637        size_t index = 0;
638        for (CordRep* edge : edges) {
639          ASSERT_THAT(edge, Eq(flats[index++]));
640          ASSERT_THAT(edge->length, Eq(512u));
641        }
642        if (last_length >= 500) {
643          EXPECT_THAT(last_edge, Eq(flats[index++]));
644          if (shared()) {
645            EXPECT_THAT(last_edge->length, Eq(512u));
646          } else {
647            EXPECT_TRUE(last_edge->refcount.IsOne());
648            EXPECT_THAT(last_edge->length, Eq(last_length));
649          }
650        }
651      }
652    }
653  }
654  TEST(CordRepBtreeTest, SubTree) {
655    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
656    const size_t n = max_cap * max_cap * 2;
657    const std::string data = CreateRandomString(n * 3);
658    std::vector<CordRep*> flats;
659    for (absl::string_view s = data; !s.empty(); s.remove_prefix(3)) {
660      flats.push_back(MakeFlat(s.substr(0, 3)));
661    }
662    CordRepBtree* node = CordRepBtree::Create(CordRep::Ref(flats[0]));
663    for (size_t i = 1; i < flats.size(); ++i) {
664      node = CordRepBtree::Append(node, CordRep::Ref(flats[i]));
665    }
666    for (size_t offset = 0; offset < data.length(); ++offset) {
667      for (size_t length = 1; length <= data.length() - offset; ++length) {
668        CordRep* rep = node->SubTree(offset, length);
669        EXPECT_THAT(CordToString(rep), Eq(data.substr(offset, length)));
670        CordRep::Unref(rep);
671      }
672    }
673    CordRepBtree::Unref(node);
674    for (CordRep* rep : flats) {
675      CordRep::Unref(rep);
676    }
677  }
678  TEST(CordRepBtreeTest, SubTreeOnExistingSubstring) {
679    AutoUnref refs;
680    std::string data = CreateRandomString(1000);
681    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
682    CordRep* flat = MakeFlat(data);
683    leaf = CordRepBtree::Append(leaf, flat);
684    CordRep* result = leaf->SubTree(0, 3 + 990);
685    ASSERT_THAT(result->tag, Eq(BTREE));
686    CordRep::Unref(leaf);
687    leaf = result->btree();
688    ASSERT_THAT(leaf->Edges(), ElementsAre(_, IsSubstring(0u, 990u)));
689    EXPECT_THAT(leaf->Edges()[1]->substring()->child, Eq(flat));
690    result = leaf->SubTree(3 + 5, 970);
691    ASSERT_THAT(result, IsSubstring(5u, 970u));
692    EXPECT_THAT(result->substring()->child, Eq(flat));
693    CordRep::Unref(result);
694    CordRep::Unref(leaf);
695  }
696  TEST_P(CordRepBtreeTest, AddDataToLeaf) {
697    const size_t n = CordRepBtree::kMaxCapacity;
698    const std::string data = CreateRandomString(n * 3);
699    for (bool append : {true, false}) {
700      AutoUnref refs;
701      DataConsumer consumer(data, append);
702      SCOPED_TRACE(append ? "Append" : "Prepend");
703      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
704      for (size_t i = 1; i < n; ++i) {
705        refs.RefIf(shared(), leaf);
706        CordRepBtree* result = BtreeAdd(leaf, append, consumer.Next(3));
707        EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
708        EXPECT_THAT(CordToString(result), Eq(consumer.Consumed()));
709        leaf = result;
710      }
711      CordRep::Unref(leaf);
712    }
713  }
714  TEST_P(CordRepBtreeTest, AppendDataToTree) {
715    AutoUnref refs;
716    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
717    std::string data = CreateRandomString(n * 3);
718    CordRepBtree* tree = refs.RefIf(shared(), CreateTree(data, 3));
719    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
720    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
721    CordRepBtree* result = CordRepBtree::Append(tree, "123456789");
722    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
723    EXPECT_THAT(result->Edges(),
724                ElementsAre(leaf0, Conditional(shared(), Ne(leaf1), Eq(leaf1))));
725    EXPECT_THAT(CordToString(result), Eq(data + "123456789"));
726    CordRep::Unref(result);
727  }
728  TEST_P(CordRepBtreeTest, PrependDataToTree) {
729    AutoUnref refs;
730    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
731    std::string data = CreateRandomString(n * 3);
732    CordRepBtree* tree = refs.RefIf(shared(), CreateTreeReverse(data, 3));
733    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
734    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
735    CordRepBtree* result = CordRepBtree::Prepend(tree, "123456789");
736    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
737    EXPECT_THAT(result->Edges(),
738                ElementsAre(Conditional(shared(), Ne(leaf0), Eq(leaf0)), leaf1));
739    EXPECT_THAT(CordToString(result), Eq("123456789" + data));
740    CordRep::Unref(result);
741  }
742  TEST_P(CordRepBtreeTest, AddDataToTreeThreeLevelsDeep) {
743    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
744    const size_t n = max_cap * max_cap * max_cap;
745    const std::string data = CreateRandomString(n * 3);
746    for (bool append : {true, false}) {
747      AutoUnref refs;
748      DataConsumer consumer(data, append);
749      SCOPED_TRACE(append ? "Append" : "Prepend");
750      CordRepBtree* tree = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
751      for (size_t i = 1; i < max_cap; ++i) {
752        tree = BtreeAdd(tree, append, consumer.Next(3));
753      }
754      ASSERT_THAT(CordToString(tree), Eq(consumer.Consumed()));
755      refs.RefIf(shared(), tree);
756      CordRepBtree* result = BtreeAdd(tree, append, consumer.Next(3));
757      ASSERT_THAT(result, IsNode(1));
758      ASSERT_THAT(result, Ne(tree));
759      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
760      tree = result;
761      for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
762        refs.RefIf(shared(), tree);
763        result = BtreeAdd(tree, append, consumer.Next(3));
764        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
765        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
766        tree = result;
767      }
768      refs.RefIf(shared(), tree);
769      result = BtreeAdd(tree, append, consumer.Next(3));
770      ASSERT_THAT(result, IsNode(2));
771      ASSERT_THAT(result, Ne(tree));
772      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
773      tree = result;
774      for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap;
775           ++i) {
776        refs.RefIf(shared(), tree);
777        result = BtreeAdd(tree, append, consumer.Next(3));
778        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
779        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
780        tree = result;
781      }
782      CordRep::Unref(tree);
783    }
784  }
785  TEST_P(CordRepBtreeTest, AddLargeDataToLeaf) {
786    const size_t max_cap = CordRepBtree::kMaxCapacity;
787    const size_t n = max_cap * max_cap * max_cap * 3 + 2;
788    const std::string data = CreateRandomString(n * kMaxFlatLength);
789    for (bool append : {true, false}) {
790      AutoUnref refs;
791      SCOPED_TRACE(append ? "Append" : "Prepend");
792      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
793      refs.RefIf(shared(), leaf);
794      CordRepBtree* result = BtreeAdd(leaf, append, data);
795      EXPECT_THAT(CordToString(result), Eq(append ? "abc" + data : data + "abc"));
796      CordRep::Unref(result);
797    }
798  }
799  TEST_P(CordRepBtreeTest, CreateFromTreeReturnsTree) {
800    AutoUnref refs;
801    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
802    refs.RefIf(shared(), leaf);
803    CordRepBtree* result = CordRepBtree::Create(leaf);
804    EXPECT_THAT(result, Eq(leaf));
805    CordRep::Unref(result);
806  }
807  TEST(CordRepBtreeTest, GetCharacter) {
808    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
809    std::string data = CreateRandomString(n * 3);
810    CordRepBtree* tree = CreateTree(data, 3);
811    tree = tree->Append(tree, MakeSubstring(4, 5, MakeFlat("abcdefghijklm")));
812    data += "efghi";
813    for (size_t i = 0; i < data.length(); ++i) {
814      ASSERT_THAT(tree->GetCharacter(i), Eq(data[i]));
815    }
816    CordRep::Unref(tree);
817  }
818  TEST_P(CordRepBtreeTest, IsFlatSingleFlat) {
819    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
820    absl::string_view fragment;
821    EXPECT_TRUE(leaf->IsFlat(nullptr));
822    EXPECT_TRUE(leaf->IsFlat(&fragment));
823    EXPECT_THAT(fragment, Eq("Hello world"));
824    fragment = "";
825    EXPECT_TRUE(leaf->IsFlat(0, 11, nullptr));
826    EXPECT_TRUE(leaf->IsFlat(0, 11, &fragment));
827    EXPECT_THAT(fragment, Eq("Hello world"));
828    EXPECT_TRUE(leaf->IsFlat(1, 4, &fragment));
829    EXPECT_THAT(fragment, Eq("ello"));
830    EXPECT_TRUE(leaf->IsFlat(6, 5, &fragment));
831    EXPECT_THAT(fragment, Eq("world"));
832    CordRep::Unref(leaf);
833  }
834  TEST(CordRepBtreeTest, IsFlatMultiFlat) {
835    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
836    std::string data = CreateRandomString(n * 3);
837    CordRepBtree* tree = CreateTree(data, 3);
838    tree = tree->Append(tree, MakeSubstring(4, 3, MakeFlat("abcdefghijklm")));
839    tree = tree->Append(tree, MakeSubstring(8, 3, MakeFlat("abcdefghijklm")));
840    data += "efgijk";
841    EXPECT_FALSE(tree->IsFlat(nullptr));
842    absl::string_view fragment = "Can't touch this";
843    EXPECT_FALSE(tree->IsFlat(&fragment));
844    EXPECT_THAT(fragment, Eq("Can't touch this"));
845    for (size_t offset = 0; offset < data.size(); offset += 3) {
846      EXPECT_TRUE(tree->IsFlat(offset, 3, nullptr));
847      EXPECT_TRUE(tree->IsFlat(offset, 3, &fragment));
848      EXPECT_THAT(fragment, Eq(data.substr(offset, 3)));
849      fragment = "Can't touch this";
850      if (offset > 0) {
851        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, nullptr));
852        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, &fragment));
853        EXPECT_THAT(fragment, Eq("Can't touch this"));
854      }
855      if (offset < data.size() - 4) {
856        EXPECT_FALSE(tree->IsFlat(offset, 4, nullptr));
857        EXPECT_FALSE(tree->IsFlat(offset, 4, &fragment));
858        EXPECT_THAT(fragment, Eq("Can't touch this"));
859      }
860    }
861    CordRep::Unref(tree);
862  }
863  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
864  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotPrivate) {
865    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
866    CordRepBtree::Ref(tree);
867    EXPECT_DEATH(tree->GetAppendBuffer(1), ".*");
868    CordRepBtree::Unref(tree);
869    CordRepBtree::Unref(tree);
870  }
871  #endif  
872  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotFlat) {
873    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
874    for (int i = 1; i <= height(); ++i) {
875      tree = CordRepBtree::New(tree);
876    }
877    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
878    CordRepBtree::Unref(tree);
879  }
880  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNotPrivate) {
881    CordRepFlat* flat = MakeFlat("abc");
882    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
883    for (int i = 1; i <= height(); ++i) {
884      tree = CordRepBtree::New(tree);
885    }
886    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
887    CordRepBtree::Unref(tree);
888    CordRep::Unref(flat);
889  }
890  TEST_P(CordRepBtreeHeightTest, GetAppendBufferTreeNotPrivate) {
891    if (height() == 0) return;
892    AutoUnref refs;
893    CordRepFlat* flat = MakeFlat("abc");
894    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
895    for (int i = 1; i <= height(); ++i) {
896      if (i == (height() + 1) / 2) refs.Ref(tree);
897      tree = CordRepBtree::New(tree);
898    }
899    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
900    CordRepBtree::Unref(tree);
901    CordRep::Unref(flat);
902  }
903  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNoCapacity) {
904    CordRepFlat* flat = MakeFlat("abc");
905    flat->length = flat->Capacity();
906    CordRepBtree* tree = CordRepBtree::Create(flat);
907    for (int i = 1; i <= height(); ++i) {
908      tree = CordRepBtree::New(tree);
909    }
910    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
911    CordRepBtree::Unref(tree);
912  }
913  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatWithCapacity) {
914    CordRepFlat* flat = MakeFlat("abc");
915    CordRepBtree* tree = CordRepBtree::Create(flat);
916    for (int i = 1; i <= height(); ++i) {
917      tree = CordRepBtree::New(tree);
918    }
919    absl::Span<char> span = tree->GetAppendBuffer(2);
920    EXPECT_THAT(span, SizeIs(2u));
921    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 3));
922    EXPECT_THAT(tree->length, Eq(5u));
923    size_t avail = flat->Capacity() - 5;
924    span = tree->GetAppendBuffer(avail + 100);
925    EXPECT_THAT(span, SizeIs(avail));
926    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 5));
927    EXPECT_THAT(tree->length, Eq(5 + avail));
928    CordRepBtree::Unref(tree);
929  }
930  TEST(CordRepBtreeTest, Dump) {
931    std::stringstream ss;
932    CordRepBtree::Dump(nullptr, ss);
933    CordRepBtree::Dump(nullptr, "Once upon a label", ss);
934    CordRepBtree::Dump(nullptr, "Once upon a label", false, ss);
935    CordRepBtree::Dump(nullptr, "Once upon a label", true, ss);
936    CordRepFlat* flat = MakeFlat("Hello world");
937    CordRepExternal* external = MakeExternal("Hello external");
938    CordRep* substr_flat = MakeSubstring(1, 6, CordRep::Ref(flat));
939    CordRep* substr_external = MakeSubstring(2, 7, CordRep::Ref(external));
940    CordRepBtree* tree = CordRepBtree::Create(flat);
941    tree = CordRepBtree::Append(tree, external);
942    tree = CordRepBtree::Append(tree, substr_flat);
943    tree = CordRepBtree::Append(tree, substr_external);
944    while (tree->height() == 0) {
945      tree = CordRepBtree::Append(tree, CordRep::Ref(flat));
946      tree = CordRepBtree::Append(tree, CordRep::Ref(external));
947      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_flat));
948      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_external));
949    }
950    for (int api = 0; api <= 3; ++api) {
951      absl::string_view api_scope;
952      std::stringstream ss;
953      switch (api) {
954        case 0:
955          api_scope = "Bare";
956          CordRepBtree::Dump(tree, ss);
957          break;
958        case 1:
959          api_scope = "Label only";
960          CordRepBtree::Dump(tree, "Once upon a label", ss);
961          break;
962        case 2:
963          api_scope = "Label no content";
964          CordRepBtree::Dump(tree, "Once upon a label", false, ss);
965          break;
966        default:
967          api_scope = "Label and content";
968          CordRepBtree::Dump(tree, "Once upon a label", true, ss);
969          break;
970      }
971      SCOPED_TRACE(api_scope);
972      std::string str = ss.str();
973      EXPECT_THAT(str, AllOf(HasSubstr("Node(1)"), HasSubstr("Leaf"),
974                             HasSubstr("Private"), HasSubstr("Shared")));
975      EXPECT_THAT(str, AllOf(HasSubstr("len = 11"), HasSubstr("len = 14"),
976                             HasSubstr("len = 6"), HasSubstr("len = 7"),
977                             HasSubstr("start = 1"), HasSubstr("start = 2")));
978      EXPECT_THAT(
979          str, AllOf(HasSubstr(absl::StrCat("0x", absl::Hex(flat))),
980                     HasSubstr(absl::StrCat("0x", absl::Hex(external))),
981                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_flat))),
982                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_external)))));
983      if (api != 0) {
984        EXPECT_THAT(str, HasSubstr("Once upon a label"));
985      }
986      if (api != 3) {
987        EXPECT_THAT(str, Not(AnyOf((HasSubstr("data = \"Hello world\""),
988                                    HasSubstr("data = \"Hello external\""),
989                                    HasSubstr("data = \"ello w\""),
990                                    HasSubstr("data = \"llo ext\"")))));
991      } else {
992        EXPECT_THAT(str, AllOf((HasSubstr("data = \"Hello world\""),
993                                HasSubstr("data = \"Hello external\""),
994                                HasSubstr("data = \"ello w\""),
995                                HasSubstr("data = \"llo ext\""))));
996      }
997    }
998    CordRep::Unref(tree);
999  }
1000  TEST(CordRepBtreeTest, IsValid) {
1001    EXPECT_FALSE(CordRepBtree::IsValid(nullptr));
1002    CordRepBtree* empty = CordRepBtree::New(0);
1003    EXPECT_TRUE(CordRepBtree::IsValid(empty));
1004    CordRep::Unref(empty);
1005    for (bool as_tree : {false, true}) {
1006      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
1007      CordRepBtree* tree = as_tree ? CordRepBtree::New(leaf) : nullptr;
1008      CordRepBtree* check = as_tree ? tree : leaf;
1009      ASSERT_TRUE(CordRepBtree::IsValid(check));
1010      leaf->length--;
1011      EXPECT_FALSE(CordRepBtree::IsValid(check));
1012      leaf->length++;
1013      ASSERT_TRUE(CordRepBtree::IsValid(check));
1014      leaf->tag--;
1015      EXPECT_FALSE(CordRepBtree::IsValid(check));
1016      leaf->tag++;
1017      ASSERT_TRUE(CordRepBtree::IsValid(check));
1018      leaf->storage[0] = static_cast<uint8_t>(CordRepBtree::kMaxHeight + 1);
1019      EXPECT_FALSE(CordRepBtree::IsValid(check));
1020      leaf->storage[0] = 1;
1021      EXPECT_FALSE(CordRepBtree::IsValid(check));
1022      leaf->storage[0] = 0;
1023      ASSERT_TRUE(CordRepBtree::IsValid(check));
1024      const uint8_t begin = leaf->storage[1];
1025      leaf->storage[1] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity);
1026      EXPECT_FALSE(CordRepBtree::IsValid(check));
1027      leaf->storage[1] = 2;
1028      EXPECT_FALSE(CordRepBtree::IsValid(check));
1029      leaf->storage[1] = begin;
1030      ASSERT_TRUE(CordRepBtree::IsValid(check));
1031      const uint8_t end = leaf->storage[2];
1032      leaf->storage[2] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity + 1);
1033      EXPECT_FALSE(CordRepBtree::IsValid(check));
1034      leaf->storage[2] = end;
1035      ASSERT_TRUE(CordRepBtree::IsValid(check));
1036      CordRep* const edge = leaf->Edges()[0];
1037      const uint8_t tag = edge->tag;
1038      CordRepBtreeTestPeer::SetEdge(leaf, begin, nullptr);
1039      EXPECT_FALSE(CordRepBtree::IsValid(check));
1040      CordRepBtreeTestPeer::SetEdge(leaf, begin, edge);
1041      edge->tag = BTREE;
1042      EXPECT_FALSE(CordRepBtree::IsValid(check));
1043      edge->tag = tag;
1044      if (as_tree) {
1045        ASSERT_TRUE(CordRepBtree::IsValid(check));
1046        leaf->length--;
1047        EXPECT_FALSE(CordRepBtree::IsValid(check));
1048        leaf->length++;
1049        ASSERT_TRUE(CordRepBtree::IsValid(check));
1050        tree->storage[0] = static_cast<uint8_t>(2);
1051        EXPECT_FALSE(CordRepBtree::IsValid(check));
1052        tree->storage[0] = 1;
1053        ASSERT_TRUE(CordRepBtree::IsValid(check));
1054        CordRep* const edge = tree->Edges()[0];
1055        const uint8_t tag = edge->tag;
1056        edge->tag = FLAT;
1057        EXPECT_FALSE(CordRepBtree::IsValid(check));
1058        edge->tag = tag;
1059      }
1060      ASSERT_TRUE(CordRepBtree::IsValid(check));
1061      CordRep::Unref(check);
1062    }
1063  }
1064  TEST(CordRepBtreeTest, AssertValid) {
1065    CordRepBtree* tree = CordRepBtree::Create(MakeFlat("abc"));
1066    const CordRepBtree* ctree = tree;
1067    EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree));
1068    EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree));
1069  #if defined(GTEST_HAS_DEATH_TEST)
1070    CordRepBtree* nulltree = nullptr;
1071    const CordRepBtree* cnulltree = nullptr;
1072    EXPECT_DEBUG_DEATH(
1073        EXPECT_THAT(CordRepBtree::AssertValid(nulltree), Eq(nulltree)), ".*");
1074    EXPECT_DEBUG_DEATH(
1075        EXPECT_THAT(CordRepBtree::AssertValid(cnulltree), Eq(cnulltree)), ".*");
1076    tree->length--;
1077    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree)),
1078                       ".*");
1079    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree)),
1080                       ".*");
1081    tree->length++;
1082  #endif
1083    CordRep::Unref(tree);
1084  }
1085  TEST(CordRepBtreeTest, CheckAssertValidShallowVsDeep) {
1086    const bool exhaustive_validation = IsCordBtreeExhaustiveValidationEnabled();
1087    auto cleanup = absl::MakeCleanup([exhaustive_validation] {
1088      SetCordBtreeExhaustiveValidation(exhaustive_validation);
1089    });
1090    CordRep* flat = MakeFlat("abc");
1091    CordRepBtree* tree = CordRepBtree::Create(flat);
1092    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
1093    const size_t n = max_cap * max_cap * 2;
1094    for (size_t i = 0; i < n; ++i) {
1095      tree = CordRepBtree::Append(tree, MakeFlat("Hello world"));
1096    }
1097    flat->length = 100;
1098    SetCordBtreeExhaustiveValidation(false);
1099    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1100    EXPECT_TRUE(CordRepBtree::IsValid(tree, true));
1101    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1102    CordRepBtree::AssertValid(tree);
1103    CordRepBtree::AssertValid(tree, true);
1104  #if defined(GTEST_HAS_DEATH_TEST)
1105    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, false), ".*");
1106  #endif
1107    SetCordBtreeExhaustiveValidation(true);
1108    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1109    EXPECT_FALSE(CordRepBtree::IsValid(tree, true));
1110    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1111  #if defined(GTEST_HAS_DEATH_TEST)
1112    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree), ".*");
1113    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, true), ".*");
1114  #endif
1115    flat->length = 3;
1116    CordRep::Unref(tree);
1117  }
1118  TEST_P(CordRepBtreeTest, Rebuild) {
1119    for (size_t size : {3u, 8u, 100u, 10000u, 1000000u}) {
1120      SCOPED_TRACE(absl::StrCat("Rebuild @", size));
1121      std::vector<CordRepFlat*> flats;
1122      for (size_t i = 0; i < size; ++i) {
1123        flats.push_back(CordRepFlat::New(2));
1124        flats.back()->Data()[0] = 'x';
1125        flats.back()->length = 1;
1126      }
1127      size_t split_count = 0;
1128      size_t split_limit = 3;
1129      auto it = flats.begin();
1130      CordRepBtree* left = nullptr;
1131      CordRepBtree* right = CordRepBtree::New(*it);
1132      while (++it != flats.end()) {
1133        if (++split_count >= split_limit) {
1134          split_limit += split_limit / 16;
1135          left = left ? CordRepBtree::Append(left, right) : right;
1136          right = CordRepBtree::New(*it);
1137        } else {
1138          right = CordRepBtree::Append(right, *it);
1139        }
1140      }
1141      left = left ? CordRepBtree::Append(left, right) : right;
1142      AutoUnref ref;
1143      left = ref.Add(CordRepBtree::Rebuild(ref.RefIf(shared(), left)));
1144      ASSERT_TRUE(CordRepBtree::IsValid(left));
1145      bool ok = true;
1146      it = flats.begin();
1147      CordVisitReps(left, [&](CordRep* edge) {
1148        if (edge->tag < FLAT) return;
1149        ok = ok && (it != flats.end() && *it++ == edge);
1150      });
1151      EXPECT_TRUE(ok && it == flats.end()) << "Rebuild edges mismatch";
1152    }
1153  }
1154  CordRepBtree::ExtractResult ExtractLast(CordRepBtree* input, size_t cap = 1) {
1155    return CordRepBtree::ExtractAppendBuffer(input, cap);
1156  }
1157  TEST(CordRepBtreeTest, ExtractAppendBufferLeafSingleFlat) {
1158    CordRep* flat = MakeFlat("Abc");
1159    CordRepBtree* leaf = CordRepBtree::Create(flat);
1160    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(nullptr, flat));
1161    CordRep::Unref(flat);
1162  }
1163  TEST(CordRepBtreeTest, ExtractAppendBufferNodeSingleFlat) {
1164    CordRep* flat = MakeFlat("Abc");
1165    CordRepBtree* leaf = CordRepBtree::Create(flat);
1166    CordRepBtree* node = CordRepBtree::New(leaf);
1167    EXPECT_THAT(ExtractLast(node), EqExtractResult(nullptr, flat));
1168    CordRep::Unref(flat);
1169  }
1170  TEST(CordRepBtreeTest, ExtractAppendBufferLeafTwoFlats) {
1171    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1172    CordRepBtree* leaf = CreateTree(flats);
1173    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(flats[0], flats[1]));
1174    CordRep::Unref(flats[0]);
1175    CordRep::Unref(flats[1]);
1176  }
1177  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlats) {
1178    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1179    CordRepBtree* leaf = CreateTree(flats);
1180    CordRepBtree* node = CordRepBtree::New(leaf);
1181    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1182    CordRep::Unref(flats[0]);
1183    CordRep::Unref(flats[1]);
1184  }
1185  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlatsInTwoLeafs) {
1186    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1187    CordRepBtree* leaf1 = CordRepBtree::Create(flats[0]);
1188    CordRepBtree* leaf2 = CordRepBtree::Create(flats[1]);
1189    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1190    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1191    CordRep::Unref(flats[0]);
1192    CordRep::Unref(flats[1]);
1193  }
1194  TEST(CordRepBtreeTest, ExtractAppendBufferLeafThreeFlats) {
1195    std::vector<CordRep*> flats = CreateFlatsFromString("abcdefghi", 3);
1196    CordRepBtree* leaf = CreateTree(flats);
1197    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, flats[2]));
1198    CordRep::Unref(flats[2]);
1199    CordRep::Unref(leaf);
1200  }
1201  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightNoFolding) {
1202    CordRep* flat = MakeFlat("Abc");
1203    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1204    CordRepBtree* leaf1 = CordRepBtree::Create(flat);
1205    CordRepBtree* leaf2 = CreateTree(flats);
1206    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1207    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, flats[1]));
1208    EXPECT_THAT(node->Edges(), ElementsAre(leaf1, leaf2));
1209    EXPECT_THAT(leaf1->Edges(), ElementsAre(flat));
1210    EXPECT_THAT(leaf2->Edges(), ElementsAre(flats[0]));
1211    CordRep::Unref(node);
1212    CordRep::Unref(flats[1]);
1213  }
1214  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightLeafFolding) {
1215    CordRep* flat = MakeFlat("Abc");
1216    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1217    CordRepBtree* leaf1 = CreateTree(flats);
1218    CordRepBtree* leaf2 = CordRepBtree::Create(flat);
1219    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1220    EXPECT_THAT(ExtractLast(node), EqExtractResult(leaf1, flat));
1221    EXPECT_THAT(leaf1->Edges(), ElementsAreArray(flats));
1222    CordRep::Unref(leaf1);
1223    CordRep::Unref(flat);
1224  }
1225  TEST(CordRepBtreeTest, ExtractAppendBufferNoCapacity) {
1226    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1227    CordRepBtree* leaf = CreateTree(flats);
1228    size_t avail = flats[1]->flat()->Capacity() - flats[1]->length;
1229    EXPECT_THAT(ExtractLast(leaf, avail + 1), EqExtractResult(leaf, nullptr));
1230    EXPECT_THAT(ExtractLast(leaf, avail), EqExtractResult(flats[0], flats[1]));
1231    CordRep::Unref(flats[0]);
1232    CordRep::Unref(flats[1]);
1233  }
1234  TEST(CordRepBtreeTest, ExtractAppendBufferNotFlat) {
1235    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1236    auto substr = MakeSubstring(1, 2, flats[1]);
1237    CordRepBtree* leaf = CreateTree({flats[0], substr});
1238    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1239    CordRep::Unref(leaf);
1240  }
1241  TEST(CordRepBtreeTest, ExtractAppendBufferShared) {
1242    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1243    CordRepBtree* leaf = CreateTree(flats);
1244    CordRep::Ref(flats[1]);
1245    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1246    CordRep::Unref(flats[1]);
1247    CordRep::Ref(leaf);
1248    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1249    CordRep::Unref(leaf);
1250    CordRepBtree* node = CordRepBtree::New(leaf);
1251    CordRep::Ref(node);
1252    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, nullptr));
1253    CordRep::Unref(node);
1254    CordRep::Unref(node);
1255  }
1256  }  
1257  }  
1258  ABSL_NAMESPACE_END
1259  }  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCUTIL_UNICHARSET_H_
2  #define TESSERACT_CCUTIL_UNICHARSET_H_
3  #include "errcode.h"
4  #include "unicharmap.h"
5  #include <tesseract/unichar.h>
6  #include "helpers.h"
7  #include "serialis.h"
8  #include <functional> 
9  namespace tesseract {
10  enum SpecialUnicharCodes {
11    UNICHAR_SPACE,
12    UNICHAR_JOINED,
13    UNICHAR_BROKEN,
14    SPECIAL_UNICHAR_CODES_COUNT
15  };
16  enum class OldUncleanUnichars {
17    kFalse,
18    kTrue,
19  };
20  class TESS_API CHAR_FRAGMENT {
21  public:
22    static const int kMinLen = 6;
23    static const int kMaxLen = 3 + UNICHAR_LEN + 2;
24    static const int kMaxChunks = 5;
25    inline void set_all(const char *unichar, int pos, int total, bool natural) {
26      set_unichar(unichar);
27      set_pos(pos);
28      set_total(total);
29      set_natural(natural);
30    }
31    inline void set_unichar(const char *uch) {
32      strncpy(this->unichar, uch, sizeof(this->unichar));
33      this->unichar[UNICHAR_LEN] = '\0';
34    }
35    inline void set_pos(int p) {
36      this->pos = p;
37    }
38    inline void set_total(int t) {
39      this->total = t;
40    }
41    inline const char *get_unichar() const {
42      return this->unichar;
43    }
44    inline int get_pos() const {
45      return this->pos;
46    }
47    inline int get_total() const {
48      return this->total;
49    }
50    static std::string to_string(const char *unichar, int pos, int total,
51                                 bool natural);
52    std::string to_string() const {
53      return to_string(unichar, pos, total, natural);
54    }
55    inline bool equals(const char *other_unichar, int other_pos,
56                       int other_total) const {
57      return (strcmp(this->unichar, other_unichar) == 0 &&
58              this->pos == other_pos && this->total == other_total);
59    }
60    inline bool equals(const CHAR_FRAGMENT *other) const {
61      return this->equals(other->get_unichar(), other->get_pos(),
62                          other->get_total());
63    }
64    inline bool is_continuation_of(const CHAR_FRAGMENT *fragment) const {
65      return (strcmp(this->unichar, fragment->get_unichar()) == 0 &&
66              this->total == fragment->get_total() &&
67              this->pos == fragment->get_pos() + 1);
68    }
69    inline bool is_beginning() const {
70      return this->pos == 0;
71    }
72    inline bool is_ending() const {
73      return this->pos == this->total - 1;
74    }
75    inline bool is_natural() const {
76      return natural;
77    }
78    void set_natural(bool value) {
79      natural = value;
80    }
81    static CHAR_FRAGMENT *parse_from_string(const char *str);
82  private:
83    char unichar[UNICHAR_LEN + 1];
84    bool natural;
85    int16_t pos;   
86    int16_t total; 
87  };
88  class TESS_API UNICHARSET {
89  public:
90    static const char *kCustomLigatures[][2];
91    static const char *kSpecialUnicharCodes[SPECIAL_UNICHAR_CODES_COUNT];
92    enum Direction {
93      U_LEFT_TO_RIGHT = 0,
94      U_RIGHT_TO_LEFT = 1,
95      U_EUROPEAN_NUMBER = 2,
96      U_EUROPEAN_NUMBER_SEPARATOR = 3,
97      U_EUROPEAN_NUMBER_TERMINATOR = 4,
98      U_ARABIC_NUMBER = 5,
99      U_COMMON_NUMBER_SEPARATOR = 6,
100      U_BLOCK_SEPARATOR = 7,
101      U_SEGMENT_SEPARATOR = 8,
102      U_WHITE_SPACE_NEUTRAL = 9,
103      U_OTHER_NEUTRAL = 10,
104      U_LEFT_TO_RIGHT_EMBEDDING = 11,
105      U_LEFT_TO_RIGHT_OVERRIDE = 12,
106      U_RIGHT_TO_LEFT_ARABIC = 13,
107      U_RIGHT_TO_LEFT_EMBEDDING = 14,
108      U_RIGHT_TO_LEFT_OVERRIDE = 15,
109      U_POP_DIRECTIONAL_FORMAT = 16,
110      U_DIR_NON_SPACING_MARK = 17,
111      U_BOUNDARY_NEUTRAL = 18,
112      U_FIRST_STRONG_ISOLATE = 19,
113      U_LEFT_TO_RIGHT_ISOLATE = 20,
114      U_RIGHT_TO_LEFT_ISOLATE = 21,
115      U_POP_DIRECTIONAL_ISOLATE = 22,
116  #ifndef U_HIDE_DEPRECATED_API
117      U_CHAR_DIRECTION_COUNT
118  #endif 
119    };
120    UNICHARSET();
121    ~UNICHARSET();
122    UNICHAR_ID unichar_to_id(const char *const unichar_repr) const;
123    UNICHAR_ID unichar_to_id(const char *const unichar_repr, int length) const;
124    int step(const char *str) const;
125    bool encodable_string(const char *str, unsigned *first_bad_position) const;
126    bool encode_string(const char *str, bool give_up_on_failure,
127                       std::vector<UNICHAR_ID> *encoding,
128                       std::vector<char> *lengths,
129                       unsigned *encoded_length) const;
130    const char *id_to_unichar(UNICHAR_ID id) const;
131    const char *id_to_unichar_ext(UNICHAR_ID id) const;
132    static std::string debug_utf8_str(const char *str);
133    static std::string CleanupString(const char *utf8_str) {
134      return CleanupString(utf8_str, strlen(utf8_str));
135    }
136    static std::string CleanupString(const char *utf8_str, size_t length);
137    std::string debug_str(UNICHAR_ID id) const;
138    std::string debug_str(const char *unichar_repr) const {
139      return debug_str(unichar_to_id(unichar_repr));
140    }
141    void unichar_insert(const char *const unichar_repr,
142                        OldUncleanUnichars old_style);
143    void unichar_insert(const char *const unichar_repr) {
144      unichar_insert(unichar_repr, OldUncleanUnichars::kFalse);
145    }
146    void unichar_insert_backwards_compatible(const char *const unichar_repr) {
<span onclick='openModal()' class='match'>147      std::string cleaned = CleanupString(unichar_repr);
148      if (cleaned != unichar_repr) {
149        unichar_insert(unichar_repr, OldUncleanUnichars::kTrue);
</span>150      } else {
151        auto old_size = size();
152        unichar_insert(unichar_repr, OldUncleanUnichars::kFalse);
153        if (size() == old_size) {
154          unichar_insert(unichar_repr, OldUncleanUnichars::kTrue);
155        }
156      }
157    }
158    bool contains_unichar_id(UNICHAR_ID unichar_id) const {
159      return static_cast<size_t>(unichar_id) < unichars.size();
160    }
161    bool contains_unichar(const char *const unichar_repr) const;
162    bool contains_unichar(const char *const unichar_repr, int length) const;
163    bool eq(UNICHAR_ID unichar_id, const char *const unichar_repr) const;
164    void delete_pointers_in_unichars() {
165      for (auto &unichar : unichars) {
166        delete unichar.properties.fragment;
167        unichar.properties.fragment = nullptr;
168      }
169    }
170    void clear() {
171      if (script_table != nullptr) {
172        for (int i = 0; i < script_table_size_used; ++i) {
173          delete[] script_table[i];
174        }
175        delete[] script_table;
176        script_table = nullptr;
177        script_table_size_used = 0;
178      }
179      script_table_size_reserved = 0;
180      delete_pointers_in_unichars();
181      unichars.clear();
182      ids.clear();
183      top_bottom_set_ = false;
184      script_has_upper_lower_ = false;
185      script_has_xheight_ = false;
186      old_style_included_ = false;
187      null_sid_ = 0;
188      common_sid_ = 0;
189      latin_sid_ = 0;
190      cyrillic_sid_ = 0;
191      greek_sid_ = 0;
192      han_sid_ = 0;
193      hiragana_sid_ = 0;
194      katakana_sid_ = 0;
195      thai_sid_ = 0;
196      hangul_sid_ = 0;
197      default_sid_ = 0;
198    }
199    size_t size() const {
200      return unichars.size();
201    }
202    bool save_to_file(const char *const filename) const {
203      FILE *file = fopen(filename, "w+b");
204      if (file == nullptr) {
205        return false;
206      }
207      bool result = save_to_file(file);
208      fclose(file);
209      return result;
210    }
211    bool save_to_file(FILE *file) const {
212      std::string str;
213      return save_to_string(str) &&
214             tesseract::Serialize(file, &str[0], str.length());
215    }
216    bool save_to_file(tesseract::TFile *file) const {
217      std::string str;
218      return save_to_string(str) && file->Serialize(&str[0], str.length());
219    }
220    bool save_to_string(std::string &str) const;
221    bool load_from_file(const char *const filename, bool skip_fragments) {
222      FILE *file = fopen(filename, "rb");
223      if (file == nullptr) {
224        return false;
225      }
226      bool result = load_from_file(file, skip_fragments);
227      fclose(file);
228      return result;
229    }
230    bool load_from_file(const char *const filename) {
231      return load_from_file(filename, false);
232    }
233    bool load_from_file(FILE *file, bool skip_fragments);
234    bool load_from_file(FILE *file) {
235      return load_from_file(file, false);
236    }
237    bool load_from_file(tesseract::TFile *file, bool skip_fragments);
238    void post_load_setup();
239    bool major_right_to_left() const;
240    void set_black_and_whitelist(const char *blacklist, const char *whitelist,
241                                 const char *unblacklist);
242    void set_isalpha(UNICHAR_ID unichar_id, bool value) {
243      unichars[unichar_id].properties.isalpha = value;
244    }
245    void set_islower(UNICHAR_ID unichar_id, bool value) {
246      unichars[unichar_id].properties.islower = value;
247    }
248    void set_isupper(UNICHAR_ID unichar_id, bool value) {
249      unichars[unichar_id].properties.isupper = value;
250    }
251    void set_isdigit(UNICHAR_ID unichar_id, bool value) {
252      unichars[unichar_id].properties.isdigit = value;
253    }
254    void set_ispunctuation(UNICHAR_ID unichar_id, bool value) {
255      unichars[unichar_id].properties.ispunctuation = value;
256    }
257    void set_isngram(UNICHAR_ID unichar_id, bool value) {
258      unichars[unichar_id].properties.isngram = value;
259    }
260    void set_script(UNICHAR_ID unichar_id, const char *value) {
261      unichars[unichar_id].properties.script_id = add_script(value);
262    }
263    void set_other_case(UNICHAR_ID unichar_id, UNICHAR_ID other_case) {
264      unichars[unichar_id].properties.other_case = other_case;
265    }
266    void set_direction(UNICHAR_ID unichar_id, UNICHARSET::Direction value) {
267      unichars[unichar_id].properties.direction = value;
268    }
269    void set_mirror(UNICHAR_ID unichar_id, UNICHAR_ID mirror) {
270      unichars[unichar_id].properties.mirror = mirror;
271    }
272    void set_normed(UNICHAR_ID unichar_id, const char *normed) {
273      unichars[unichar_id].properties.normed = normed;
274      unichars[unichar_id].properties.normed_ids.clear();
275    }
276    void set_normed_ids(UNICHAR_ID unichar_id);
277    bool get_isalpha(UNICHAR_ID unichar_id) const {
278      if (INVALID_UNICHAR_ID == unichar_id) {
279        return false;
280      }
281      ASSERT_HOST(contains_unichar_id(unichar_id));
282      return unichars[unichar_id].properties.isalpha;
283    }
284    bool get_islower(UNICHAR_ID unichar_id) const {
285      if (INVALID_UNICHAR_ID == unichar_id) {
286        return false;
287      }
288      ASSERT_HOST(contains_unichar_id(unichar_id));
289      return unichars[unichar_id].properties.islower;
290    }
291    bool get_isupper(UNICHAR_ID unichar_id) const {
292      if (INVALID_UNICHAR_ID == unichar_id) {
293        return false;
294      }
295      ASSERT_HOST(contains_unichar_id(unichar_id));
296      return unichars[unichar_id].properties.isupper;
297    }
298    bool get_isdigit(UNICHAR_ID unichar_id) const {
299      if (INVALID_UNICHAR_ID == unichar_id) {
300        return false;
301      }
302      ASSERT_HOST(contains_unichar_id(unichar_id));
303      return unichars[unichar_id].properties.isdigit;
304    }
305    bool get_ispunctuation(UNICHAR_ID unichar_id) const {
306      if (INVALID_UNICHAR_ID == unichar_id) {
307        return false;
308      }
309      ASSERT_HOST(contains_unichar_id(unichar_id));
310      return unichars[unichar_id].properties.ispunctuation;
311    }
312    bool get_isngram(UNICHAR_ID unichar_id) const {
313      if (INVALID_UNICHAR_ID == unichar_id) {
314        return false;
315      }
316      ASSERT_HOST(contains_unichar_id(unichar_id));
317      return unichars[unichar_id].properties.isngram;
318    }
319    bool get_isprivate(UNICHAR_ID unichar_id) const;
320    bool top_bottom_useful() const {
321      return top_bottom_set_;
322    }
323    void set_ranges_empty();
324    void SetPropertiesFromOther(const UNICHARSET &src) {
325      PartialSetPropertiesFromOther(0, src);
326    }
327    void PartialSetPropertiesFromOther(int start_index, const UNICHARSET &src);
328    void ExpandRangesFromOther(const UNICHARSET &src);
329    void CopyFrom(const UNICHARSET &src);
330    void AppendOtherUnicharset(const UNICHARSET &src);
331    bool SizesDistinct(UNICHAR_ID id1, UNICHAR_ID id2) const;
332    void get_top_bottom(UNICHAR_ID unichar_id, int *min_bottom, int *max_bottom,
333                        int *min_top, int *max_top) const {
334      if (INVALID_UNICHAR_ID == unichar_id) {
335        *min_bottom = *min_top = 0;
336        *max_bottom = *max_top = 256; 
337        return;
338      }
339      ASSERT_HOST(contains_unichar_id(unichar_id));
340      *min_bottom = unichars[unichar_id].properties.min_bottom;
341      *max_bottom = unichars[unichar_id].properties.max_bottom;
342      *min_top = unichars[unichar_id].properties.min_top;
343      *max_top = unichars[unichar_id].properties.max_top;
344    }
345    void set_top_bottom(UNICHAR_ID unichar_id, int min_bottom, int max_bottom,
346                        int min_top, int max_top) {
347      unichars[unichar_id].properties.min_bottom =
348          ClipToRange<int>(min_bottom, 0, UINT8_MAX);
349      unichars[unichar_id].properties.max_bottom =
350          ClipToRange<int>(max_bottom, 0, UINT8_MAX);
351      unichars[unichar_id].properties.min_top =
352          ClipToRange<int>(min_top, 0, UINT8_MAX);
353      unichars[unichar_id].properties.max_top =
354          ClipToRange<int>(max_top, 0, UINT8_MAX);
355    }
356    void get_width_stats(UNICHAR_ID unichar_id, float *width,
357                         float *width_sd) const {
358      if (INVALID_UNICHAR_ID == unichar_id) {
359        *width = 0.0f;
360        *width_sd = 0.0f;
361        return;
362      }
363      ASSERT_HOST(contains_unichar_id(unichar_id));
364      *width = unichars[unichar_id].properties.width;
365      *width_sd = unichars[unichar_id].properties.width_sd;
366    }
367    void set_width_stats(UNICHAR_ID unichar_id, float width, float width_sd) {
368      unichars[unichar_id].properties.width = width;
369      unichars[unichar_id].properties.width_sd = width_sd;
370    }
371    void get_bearing_stats(UNICHAR_ID unichar_id, float *bearing,
372                           float *bearing_sd) const {
373      if (INVALID_UNICHAR_ID == unichar_id) {
374        *bearing = *bearing_sd = 0.0f;
375        return;
376      }
377      ASSERT_HOST(contains_unichar_id(unichar_id));
378      *bearing = unichars[unichar_id].properties.bearing;
379      *bearing_sd = unichars[unichar_id].properties.bearing_sd;
380    }
381    void set_bearing_stats(UNICHAR_ID unichar_id, float bearing,
382                           float bearing_sd) {
383      unichars[unichar_id].properties.bearing = bearing;
384      unichars[unichar_id].properties.bearing_sd = bearing_sd;
385    }
386    void get_advance_stats(UNICHAR_ID unichar_id, float *advance,
387                           float *advance_sd) const {
388      if (INVALID_UNICHAR_ID == unichar_id) {
389        *advance = *advance_sd = 0;
390        return;
391      }
392      ASSERT_HOST(contains_unichar_id(unichar_id));
393      *advance = unichars[unichar_id].properties.advance;
394      *advance_sd = unichars[unichar_id].properties.advance_sd;
395    }
396    void set_advance_stats(UNICHAR_ID unichar_id, float advance,
397                           float advance_sd) {
398      unichars[unichar_id].properties.advance = advance;
399      unichars[unichar_id].properties.advance_sd = advance_sd;
400    }
401    bool PropertiesIncomplete(UNICHAR_ID unichar_id) const {
402      return unichars[unichar_id].properties.AnyRangeEmpty();
403    }
404    bool IsSpaceDelimited(UNICHAR_ID unichar_id) const {
405      if (INVALID_UNICHAR_ID == unichar_id) {
406        return true;
407      }
408      int script_id = get_script(unichar_id);
409      return script_id != han_sid_ && script_id != thai_sid_ &&
410             script_id != hangul_sid_ && script_id != hiragana_sid_ &&
411             script_id != katakana_sid_;
412    }
413    int get_script(UNICHAR_ID unichar_id) const {
414      if (INVALID_UNICHAR_ID == unichar_id) {
415        return null_sid_;
416      }
417      ASSERT_HOST(contains_unichar_id(unichar_id));
418      return unichars[unichar_id].properties.script_id;
419    }
420    unsigned int get_properties(UNICHAR_ID unichar_id) const;
421    char get_chartype(UNICHAR_ID unichar_id) const;
422    UNICHAR_ID get_other_case(UNICHAR_ID unichar_id) const {
423      if (INVALID_UNICHAR_ID == unichar_id) {
424        return INVALID_UNICHAR_ID;
425      }
426      ASSERT_HOST(contains_unichar_id(unichar_id));
427      return unichars[unichar_id].properties.other_case;
428    }
429    Direction get_direction(UNICHAR_ID unichar_id) const {
430      if (INVALID_UNICHAR_ID == unichar_id) {
431        return UNICHARSET::U_OTHER_NEUTRAL;
432      }
433      ASSERT_HOST(contains_unichar_id(unichar_id));
434      return unichars[unichar_id].properties.direction;
435    }
436    UNICHAR_ID get_mirror(UNICHAR_ID unichar_id) const {
437      if (INVALID_UNICHAR_ID == unichar_id) {
438        return INVALID_UNICHAR_ID;
439      }
440      ASSERT_HOST(contains_unichar_id(unichar_id));
441      return unichars[unichar_id].properties.mirror;
442    }
443    UNICHAR_ID to_lower(UNICHAR_ID unichar_id) const {
444      if (INVALID_UNICHAR_ID == unichar_id) {
445        return INVALID_UNICHAR_ID;
446      }
447      ASSERT_HOST(contains_unichar_id(unichar_id));
448      if (unichars[unichar_id].properties.islower) {
449        return unichar_id;
450      }
451      return unichars[unichar_id].properties.other_case;
452    }
453    UNICHAR_ID to_upper(UNICHAR_ID unichar_id) const {
454      if (INVALID_UNICHAR_ID == unichar_id) {
455        return INVALID_UNICHAR_ID;
456      }
457      ASSERT_HOST(contains_unichar_id(unichar_id));
458      if (unichars[unichar_id].properties.isupper) {
459        return unichar_id;
460      }
461      return unichars[unichar_id].properties.other_case;
462    }
463    bool has_special_codes() const {
464      return get_fragment(UNICHAR_BROKEN) != nullptr &&
465             strcmp(id_to_unichar(UNICHAR_BROKEN),
466                    kSpecialUnicharCodes[UNICHAR_BROKEN]) == 0;
467    }
468    bool AnyRepeatedUnicodes() const;
469    const CHAR_FRAGMENT *get_fragment(UNICHAR_ID unichar_id) const {
470      if (INVALID_UNICHAR_ID == unichar_id) {
471        return nullptr;
472      }
473      ASSERT_HOST(contains_unichar_id(unichar_id));
474      return unichars[unichar_id].properties.fragment;
475    }
476    bool get_isalpha(const char *const unichar_repr) const {
477      return get_isalpha(unichar_to_id(unichar_repr));
478    }
479    bool get_islower(const char *const unichar_repr) const {
480      return get_islower(unichar_to_id(unichar_repr));
481    }
482    bool get_isupper(const char *const unichar_repr) const {
483      return get_isupper(unichar_to_id(unichar_repr));
484    }
485    bool get_isdigit(const char *const unichar_repr) const {
486      return get_isdigit(unichar_to_id(unichar_repr));
487    }
488    bool get_ispunctuation(const char *const unichar_repr) const {
489      return get_ispunctuation(unichar_to_id(unichar_repr));
490    }
491    unsigned int get_properties(const char *const unichar_repr) const {
492      return get_properties(unichar_to_id(unichar_repr));
493    }
494    char get_chartype(const char *const unichar_repr) const {
495      return get_chartype(unichar_to_id(unichar_repr));
496    }
497    int get_script(const char *const unichar_repr) const {
498      return get_script(unichar_to_id(unichar_repr));
499    }
500    const CHAR_FRAGMENT *get_fragment(const char *const unichar_repr) const {
501      if (unichar_repr == nullptr || unichar_repr[0] == '\0' ||
502          !ids.contains(unichar_repr, false)) {
503        return nullptr;
504      }
505      return get_fragment(unichar_to_id(unichar_repr));
506    }
507    bool get_isalpha(const char *const unichar_repr, int length) const {
508      return get_isalpha(unichar_to_id(unichar_repr, length));
509    }
510    bool get_islower(const char *const unichar_repr, int length) const {
511      return get_islower(unichar_to_id(unichar_repr, length));
512    }
513    bool get_isupper(const char *const unichar_repr, int length) const {
514      return get_isupper(unichar_to_id(unichar_repr, length));
515    }
516    bool get_isdigit(const char *const unichar_repr, int length) const {
517      return get_isdigit(unichar_to_id(unichar_repr, length));
518    }
519    bool get_ispunctuation(const char *const unichar_repr, int length) const {
520      return get_ispunctuation(unichar_to_id(unichar_repr, length));
521    }
522    const char *get_normed_unichar(UNICHAR_ID unichar_id) const {
523      if (unichar_id == UNICHAR_SPACE) {
524        return " ";
525      }
526      return unichars[unichar_id].properties.normed.c_str();
527    }
528    const std::vector<UNICHAR_ID> &normed_ids(UNICHAR_ID unichar_id) const {
529      return unichars[unichar_id].properties.normed_ids;
530    }
531    int get_script(const char *const unichar_repr, int length) const {
532      return get_script(unichar_to_id(unichar_repr, length));
533    }
534    int get_script_table_size() const {
535      return script_table_size_used;
536    }
537    const char *get_script_from_script_id(int id) const {
538      if (id >= script_table_size_used || id < 0) {
539        return null_script;
540      }
541      return script_table[id];
542    }
543    int get_script_id_from_name(const char *script_name) const;
544    bool is_null_script(const char *script) const {
545      return script == null_script;
546    }
547    int add_script(const char *script);
548    bool get_enabled(UNICHAR_ID unichar_id) const {
549      ASSERT_HOST(contains_unichar_id(unichar_id));
550      return unichars[unichar_id].properties.enabled;
551    }
552    int null_sid() const {
553      return null_sid_;
554    }
555    int common_sid() const {
556      return common_sid_;
557    }
558    int latin_sid() const {
559      return latin_sid_;
560    }
561    int cyrillic_sid() const {
562      return cyrillic_sid_;
563    }
564    int greek_sid() const {
565      return greek_sid_;
566    }
567    int han_sid() const {
568      return han_sid_;
569    }
570    int hiragana_sid() const {
571      return hiragana_sid_;
572    }
573    int katakana_sid() const {
574      return katakana_sid_;
575    }
576    int thai_sid() const {
577      return thai_sid_;
578    }
579    int hangul_sid() const {
580      return hangul_sid_;
581    }
582    int default_sid() const {
583      return default_sid_;
584    }
585    bool script_has_upper_lower() const {
586      return script_has_upper_lower_;
587    }
588    bool script_has_xheight() const {
589      return script_has_xheight_;
590    }
591  private:
592    struct TESS_API UNICHAR_PROPERTIES {
593      UNICHAR_PROPERTIES();
594      void Init();
595      void SetRangesOpen();
596      void SetRangesEmpty();
597      bool AnyRangeEmpty() const;
598      void ExpandRangesFrom(const UNICHAR_PROPERTIES &src);
599      void CopyFrom(const UNICHAR_PROPERTIES &src);
600      bool isalpha;
601      bool islower;
602      bool isupper;
603      bool isdigit;
604      bool ispunctuation;
605      bool isngram;
606      bool enabled;
607      uint8_t min_bottom;
608      uint8_t max_bottom;
609      uint8_t min_top;
610      uint8_t max_top;
611      float width;
612      float width_sd;
613      float bearing;
614      float bearing_sd;
615      float advance;
616      float advance_sd;
617      int script_id;
618      UNICHAR_ID other_case; 
619      Direction direction;   
620      UNICHAR_ID mirror;
621      std::vector<UNICHAR_ID> normed_ids;
622      std::string normed; 
623      CHAR_FRAGMENT *fragment;
624    };
625    struct UNICHAR_SLOT {
626      char representation[UNICHAR_LEN + 1];
627      UNICHAR_PROPERTIES properties;
628    };
629    void encode_string(const char *str, int str_index, int str_length,
630                       std::vector<UNICHAR_ID> *encoding,
631                       std::vector<char> *lengths, unsigned *best_total_length,
632                       std::vector<UNICHAR_ID> *best_encoding,
633                       std::vector<char> *best_lengths) const;
634    bool GetStrProperties(const char *utf8_str, UNICHAR_PROPERTIES *props) const;
635    bool load_via_fgets(const std::function<char *(char *, int)> &fgets_cb,
636                        bool skip_fragments);
637    static const char *kCleanupMaps[][2];
638    static const char *null_script;
639    std::vector<UNICHAR_SLOT> unichars;
640    UNICHARMAP ids;
641    char **script_table;
642    int script_table_size_used;
643    int script_table_size_reserved;
644    bool top_bottom_set_;
645    bool script_has_upper_lower_;
646    bool script_has_xheight_;
647    bool old_style_included_;
648    int null_sid_;
649    int common_sid_;
650    int latin_sid_;
651    int cyrillic_sid_;
652    int greek_sid_;
653    int han_sid_;
654    int hiragana_sid_;
655    int katakana_sid_;
656    int thai_sid_;
657    int hangul_sid_;
658    int default_sid_;
659  };
660  } 
661  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset.h</div>
                </div>
                <div class="column column_space"><pre><code>57    std::string actual = CordToString(arg);
58    if (actual != data) {
59      *result_listener << "Expected flat holding \"" << data
</pre></code></div>
                <div class="column column_space"><pre><code>147      std::string cleaned = CleanupString(unichar_repr);
148      if (cleaned != unichar_repr) {
149        unichar_insert(unichar_repr, OldUncleanUnichars::kTrue);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    