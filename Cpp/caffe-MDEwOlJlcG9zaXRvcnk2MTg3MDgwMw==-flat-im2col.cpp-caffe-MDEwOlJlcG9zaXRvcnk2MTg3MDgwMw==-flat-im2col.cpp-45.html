
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 35, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im2col.cpp</h3>
            <pre><code>1  #include &lt;vector&gt;
2  #include &quot;caffe/util/im2col.hpp&quot;
3  #include &quot;caffe/util/math_functions.hpp&quot;
4  namespace caffe {
5  inline bool is_a_ge_zero_and_a_lt_b(int a, int b) {
6    return static_cast&lt;unsigned&gt;(a) &lt; static_cast&lt;unsigned&gt;(b);
7  }
8  template &lt;typename Dtype&gt;
9  void im2col_cpu(const Dtype* data_im, const int channels,
10      const int height, const int width, const int kernel_h, const int kernel_w,
11      const int pad_h, const int pad_w,
12      const int stride_h, const int stride_w,
13      const int dilation_h, const int dilation_w,
14      Dtype* data_col) {
15  #if 0
16    const int output_h = (height + 2 * pad_h -
17      (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
18    const int output_w = (width + 2 * pad_w -
19      (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
20    const int channel_size = height * width;
21    for (int channel = channels; channel--; data_im += channel_size) {
22      for (int kernel_row = 0; kernel_row &lt; kernel_h; kernel_row++) {
23        for (int kernel_col = 0; kernel_col &lt; kernel_w; kernel_col++) {
24          int input_row = -pad_h + kernel_row * dilation_h;
25          for (int output_rows = output_h; output_rows; output_rows--) {
26            if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {
27              for (int output_cols = output_w; output_cols; output_cols--) {
28                *(data_col++) = 0;
29              }
30            } else {
31              int input_col = -pad_w + kernel_col * dilation_w;
32              for (int output_col = output_w; output_col; output_col--) {
33                if (is_a_ge_zero_and_a_lt_b(input_col, width)) {
34                  *(data_col++) = data_im[input_row * width + input_col];
35                } else {
36                  *(data_col++) = 0;
37                }
38                input_col += stride_w;
39              }
40            }
41            input_row += stride_h;
42          }
43        }
44      }
45    }
46  #else
47    int dil_kernel_h = (kernel_h - 1) * dilation_h + 1;
48    int dil_kernel_w = (kernel_w - 1) * dilation_w + 1;
49    int height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
50    int width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
51    int channels_col = channels * kernel_h * kernel_w;
52    #ifdef _OPENMP
53    #pragma omp parallel for
54    #endif
55    for (int c = 0; c &lt; channels_col; ++c) {
56      int w_offset = c % kernel_w;
57      int h_offset = (c / kernel_w) % kernel_h;
58      int c_im = c / kernel_h / kernel_w;
<span onclick='openModal()' class='match'>59      const int hc0 = h_offset * dilation_h - pad_h;
60      const int wc0 = w_offset * dilation_w - pad_w;
61      for (int h = 0; h &lt; height_col; ++h) {
62        int h_pad = h * stride_h + hc0;
</span>63        const int row_offset = (c * height_col + h) * width_col;
64        const int srow_offset = (c_im * height + h_pad) * width;
65        for (int w = 0; w &lt; width_col; ++w) {
66          int w_pad = w * stride_w + wc0;
67          if ((((unsigned)h_pad) &lt; ((unsigned)height)) &amp;&amp; (((unsigned)w_pad) &lt; ((unsigned)width)))
68            data_col[row_offset + w] = data_im[srow_offset + w_pad];
69          else {
70            data_col[row_offset + w] = 0.;
71          }
72        }
73      }
74    }
75  #endif
76  }
77  template &lt;typename Dtype&gt;
78  void im3d2col_cpu(const Dtype* data_im, const int channels,
79      const int depth, const int height, const int width,
80      const int kernel_d, const int kernel_h, const int kernel_w,
81      const int pad_d, const int pad_h, const int pad_w,
82      const int stride_d, const int stride_h, const int stride_w,
83      const int dilation_d, const int dilation_h, const int dilation_w,
84      Dtype* data_col) {
85    long dil_kernel_h = (kernel_h - 1) * dilation_h + 1;
86    long dil_kernel_w = (kernel_w - 1) * dilation_w + 1;
87    long dil_kernel_d = (kernel_d - 1) * dilation_d + 1;
88    long height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
89    long width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
90    long depth_col = (depth + 2 * pad_d - dil_kernel_d) / stride_d + 1;
91    long channels_col = channels * kernel_h * kernel_w * kernel_d;
92    #ifdef _OPENMP
93    #pragma omp parallel for
94    #endif
95    for (long c = 0; c &lt; channels_col; ++c) {
96      long w_offset = c % kernel_w;
97      long h_offset = (c / kernel_w) % kernel_h;
98      long d_offset = (c / kernel_w / kernel_h) % kernel_d;
99      long c_im = c / kernel_h / kernel_w / kernel_d;
100      for (int d = 0; d &lt; depth_col; ++d) {
101        long d_pad = d * stride_d - pad_d + d_offset * dilation_d;
102        for (long h = 0; h &lt; height_col; ++h) {
103          long h_pad = h * stride_h - pad_h + h_offset * dilation_h;
104          for (long w = 0; w &lt; width_col; ++w) {
105            long w_pad = w * stride_w - pad_w + w_offset * dilation_w;
106            if (((unsigned long)h_pad &lt; (unsigned long)height) &amp;&amp;
107                ((unsigned long)w_pad &lt; (unsigned long)width) &amp;&amp;
108                ((unsigned long)d_pad &lt; (unsigned long)depth)) {
109              data_col[((c * depth_col + d) * height_col + h) * width_col + w] =
110                data_im[((c_im * depth + d_pad) * height + h_pad) * width + w_pad];
111            } else {
112              data_col[((c * depth_col + d) * height_col + h) * width_col + w] = 0.;
113            }
114          }
115        }
116      }
117    }
118  }
119  template void im2col_cpu&lt;float&gt;(const float* data_im, const int channels,
120      const int height, const int width, const int kernel_h, const int kernel_w,
121      const int pad_h, const int pad_w, const int stride_h,
122      const int stride_w, const int dilation_h, const int dilation_w,
123      float* data_col);
124  template void im2col_cpu&lt;double&gt;(const double* data_im, const int channels,
125      const int height, const int width, const int kernel_h, const int kernel_w,
126      const int pad_h, const int pad_w, const int stride_h,
127      const int stride_w, const int dilation_h, const int dilation_w,
128      double* data_col);
129  template void im3d2col_cpu&lt;float&gt;(const float* data_im, const int channels,
130      const int depth, const int height, const int width,
131      const int kernel_d, const int kernel_h, const int kernel_w,
132      const int pad_d, const int pad_h, const int pad_w,
133      const int stride_d, const int stride_h, const int stride_w,
134      const int dilation_d, const int dilation_h, const int dilation_w,
135      float* data_col);
136  template void im3d2col_cpu&lt;double&gt;(const double* data_im, const int channels,
137      const int depth, const int height, const int width,
138      const int kernel_d, const int kernel_h, const int kernel_w,
139      const int pad_d, const int pad_h, const int pad_w,
140      const int stride_d, const int stride_h, const int stride_w,
141      const int dilation_d, const int dilation_h, const int dilation_w,
142      double* data_col);
143  template &lt;typename Dtype&gt;
144  inline void im2col_nd_core_cpu(const Dtype* data_input, const bool im2col,
145      const int num_spatial_axes, const int* im_shape, const int* col_shape,
146      const int* kernel_shape, const int* pad, const int* stride,
147      const int* dilation, Dtype* data_output) {
148    if (!im2col) {
149      size_t im_size = im_shape[0];
150      for (int i = 0; i &lt; num_spatial_axes; ++i) {
151        im_size *= (size_t)im_shape[1 + i];
152      }
153      caffe_set(im_size, Dtype(0), data_output);
154    }
155    int kernel_size = 1;
156    for (int i = 0; i &lt; num_spatial_axes; ++i) {
157      kernel_size *= kernel_shape[i];
158    }
159    const int channels_col = col_shape[0];
160    vector&lt;int&gt; d_offset(num_spatial_axes, 0);
161    vector&lt;int&gt; d_iter(num_spatial_axes, 0);
162    for (int c_col = 0; c_col &lt; channels_col; ++c_col) {
163      int offset = c_col;
164      for (int d_i = num_spatial_axes - 1; d_i &gt;= 0; --d_i) {
165        if (d_i &lt; num_spatial_axes - 1) {
166          offset /= kernel_shape[d_i + 1];
167        }
168        d_offset[d_i] = offset % kernel_shape[d_i];
169      }
170      for (bool incremented = true; incremented; ) {
171        int index_col = c_col;
172        int index_im = c_col / kernel_size;
173        bool is_padding = false;
174        for (int d_i = 0; d_i &lt; num_spatial_axes; ++d_i) {
175          const int d = d_iter[d_i];
176          const int d_im = d * stride[d_i] - pad[d_i] +
177              d_offset[d_i] * dilation[d_i];
178          is_padding |= d_im &lt; 0 || d_im &gt;= im_shape[d_i + 1];
179          index_col *= col_shape[d_i + 1];
180          index_col += d;
181          index_im *= im_shape[d_i + 1];
182          index_im += d_im;
183        }
184        if (im2col) {
185          if (is_padding) {
186            data_output[index_col] = 0;
187          } else {
188            data_output[index_col] = data_input[index_im];
189          }
190        } else if (!is_padding) {  
191          data_output[index_im] += data_input[index_col];
192        }
193        incremented = false;
194        for (int d_i = num_spatial_axes - 1; d_i &gt;= 0; --d_i) {
195          const int d_max = col_shape[d_i + 1];
196          DCHECK_LT(d_iter[d_i], d_max);
197          if (d_iter[d_i] == d_max - 1) {
198            d_iter[d_i] = 0;
199          } else {  
200            ++d_iter[d_i];
201            incremented = true;
202            break;
203          }
204        }
205      }  
206    }  
207  }
208  template &lt;typename Dtype&gt;
209  void im2col_nd_cpu(const Dtype* data_im, const int num_spatial_axes,
210      const int* im_shape, const int* col_shape,
211      const int* kernel_shape, const int* pad, const int* stride,
212      const int* dilation, Dtype* data_col) {
213    const bool kIm2Col = true;
214    im2col_nd_core_cpu(data_im, kIm2Col, num_spatial_axes, im_shape, col_shape,
215                    kernel_shape, pad, stride, dilation, data_col);
216  }
217  template void im2col_nd_cpu&lt;float&gt;(const float* data_im,
218      const int num_spatial_axes,
219      const int* im_shape, const int* col_shape,
220      const int* kernel_shape, const int* pad, const int* stride,
221      const int* dilation, float* data_col);
222  template void im2col_nd_cpu&lt;double&gt;(const double* data_im,
223      const int num_spatial_axes,
224      const int* im_shape, const int* col_shape,
225      const int* kernel_shape, const int* pad, const int* stride,
226      const int* dilation, double* data_col);
227  template &lt;typename Dtype&gt;
228  void col2im_cpu(const Dtype* data_col, const int channels,
229      const int height, const int width, const int kernel_h, const int kernel_w,
230      const int pad_h, const int pad_w,
231      const int stride_h, const int stride_w,
232      const int dilation_h, const int dilation_w,
233      Dtype* data_im) {
234  #if 0
235    caffe_set(height * width * channels, Dtype(0), data_im);
236    const int output_h = (height + 2 * pad_h -
237      (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
238    const int output_w = (width + 2 * pad_w -
239      (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
240    const int channel_size = height * width;
241    for (int channel = channels; channel--; data_im += channel_size) {
242      for (int kernel_row = 0; kernel_row &lt; kernel_h; kernel_row++) {
243        for (int kernel_col = 0; kernel_col &lt; kernel_w; kernel_col++) {
244          int input_row = -pad_h + kernel_row * dilation_h;
245          for (int output_rows = output_h; output_rows; output_rows--) {
246            if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {
247              data_col += output_w;
248            } else {
249              int input_col = -pad_w + kernel_col * dilation_w;
250              for (int output_col = output_w; output_col; output_col--) {
251                if (is_a_ge_zero_and_a_lt_b(input_col, width)) {
252                  data_im[input_row * width + input_col] += *data_col;
253                }
254                data_col++;
255                input_col += stride_w;
256              }
257            }
258            input_row += stride_h;
259          }
260        }
261      }
262    }
263  #else
264    int dil_patch_h = (kernel_h - 1) * dilation_h + 1;
265    int dil_patch_w = (kernel_w - 1) * dilation_w + 1;
266    int height_col = (height + 2 * pad_h - dil_patch_h) / stride_h + 1;
267    int width_col = (width + 2 * pad_w - dil_patch_w) / stride_w + 1;
268    long chunk_len = kernel_h * kernel_w;
269    caffe_set((size_t)height * (size_t)width * (size_t)channels, Dtype(0), data_im);
270    #ifdef _OPENMP
271    #pragma omp parallel for if (channels &gt; 1)
272    #endif 
273    for (int idx = 0; idx &lt; channels; ++idx) {
274      for (int inner_idx = 0; inner_idx &lt; chunk_len; ++inner_idx) {
275        int c = idx * chunk_len + inner_idx;
276        int w_offset = c % kernel_w;
277        int h_offset = (c / kernel_w) % kernel_h;
278        int c_im = c / kernel_h / kernel_w;
279        const int hc0 = h_offset * dilation_h - pad_h;
280        const int wc0 = w_offset * dilation_w - pad_w;
281        for (int h = 0; h &lt; height_col; ++h) {
282          for (int w = 0; w &lt; width_col; ++w) {
283            int h_pad = h * stride_h + hc0;
284            const int srow_offset = (c_im * height + h_pad) * width;
285            const int row_offset = (c * height_col + h) * width_col;
286            int w_pad = w * stride_w + wc0;
287            if ((((unsigned)h_pad) &lt; ((unsigned)height)) &amp;&amp; (((unsigned)w_pad) &lt; ((unsigned)width))) {
288              data_im[srow_offset + w_pad] += data_col[row_offset + w];
289            }
290          }
291        }
292      }
293    }
294  #endif
295  }
296  template &lt;typename Dtype&gt;
297  void col2im3d_cpu(const Dtype* data_col, const int channels,
298      const int depth, const int height, const int width,
299      const int kernel_d, const int kernel_h, const int kernel_w,
300      const int pad_d, const int pad_h, const int pad_w,
301      const int stride_d, const int stride_h, const int stride_w,
302      const int dilation_d, const int dilation_h, const int dilation_w,
303      Dtype* data_im) {
304    long dil_patch_h = (kernel_h - 1) * dilation_h + 1;
305    long dil_patch_w = (kernel_w - 1) * dilation_w + 1;
306    long dil_patch_d = (kernel_d - 1) * dilation_d + 1;
307    long height_col = (height + 2 * pad_h - dil_patch_h) / stride_h + 1;
308    long width_col = (width + 2 * pad_w - dil_patch_w) / stride_w + 1;
309    long depth_col = (depth + 2 * pad_d - dil_patch_d) / stride_d + 1;
310    long num_kernels = (size_t)channels * (size_t)height * (size_t)width * (size_t)depth;
311    long chunk_len = kernel_h * kernel_w * kernel_d;
312    caffe_set(num_kernels, Dtype(0), data_im);
313    #ifdef _OPENMP
314    #pragma omp parallel for if (channels &gt; 1)
315    #endif
316    for (long c_im = 0; c_im &lt; channels; ++c_im) {
317      for (long c = c_im * chunk_len; c &lt; chunk_len * (c_im + 1); ++c) {
318        long w_offset = c % kernel_w;
319        long h_offset = (c / kernel_w) % kernel_h;
320        long d_offset = (c / kernel_w / kernel_h) % kernel_d;
321        long dc0 = d_offset * dilation_d - pad_d;
322        long hc0 = h_offset * dilation_h - pad_h;
323        long wc0 = w_offset * dilation_w - pad_w;
324        for (long d = 0; d &lt; depth_col; ++d) {
325          long d_pad = d * stride_d + dc0;
326          for (long h = 0; h &lt; height_col; ++h) {
327            long h_pad = h * stride_h + hc0;
328            for (long w = 0; w &lt; width_col; ++w) {
329              long w_pad = w * stride_w + wc0;
330              if (((unsigned long)h_pad &lt; (unsigned long)height) &amp;&amp;
331                  ((unsigned long)w_pad &lt; (unsigned long)width) &amp;&amp;
332                  ((unsigned long)d_pad &lt; (unsigned long)depth)) {
333                data_im[((c_im * depth + d_pad) * height + h_pad) * width + w_pad] +=
334                  data_col[((c * depth_col + d) * height_col + h) * width_col + w];
335              }
336            }
337          }
338        }
339      }
340    }
341  }
342  template void col2im_cpu&lt;float&gt;(const float* data_col, const int channels,
343      const int height, const int width, const int kernel_h, const int kernel_w,
344      const int pad_h, const int pad_w, const int stride_h,
345      const int stride_w, const int dilation_h, const int dilation_w,
346      float* data_im);
347  template void col2im_cpu&lt;double&gt;(const double* data_col, const int channels,
348      const int height, const int width, const int kernel_h, const int kernel_w,
349      const int pad_h, const int pad_w, const int stride_h,
350      const int stride_w, const int dilation_h, const int dilation_w,
351      double* data_im);
352  template void col2im3d_cpu&lt;float&gt;(const float* data_col, const int channels,
353      const int depth, const int height, const int width,
354      const int kernel_d, const int kernel_h, const int kernel_w,
355      const int pad_d, const int pad_h, const int pad_w,
356      const int stride_d, const int stride_h, const int stride_w,
357      const int dilation_d, const int dilation_h, const int dilation_w,
358      float* data_im);
359  template void col2im3d_cpu&lt;double&gt;(const double* data_col, const int channels,
360      const int depth, const int height, const int width,
361      const int kernel_d, const int kernel_h, const int kernel_w,
362      const int pad_d, const int pad_h, const int pad_w,
363      const int stride_d, const int stride_h, const int stride_w,
364      const int dilation_d, const int dilation_h, const int dilation_w,
365      double* data_im);
366  template &lt;typename Dtype&gt;
367  void col2im_nd_cpu(const Dtype* data_col, const int num_spatial_axes,
368      const int* im_shape, const int* col_shape,
369      const int* kernel_shape, const int* pad, const int* stride,
370      const int* dilation, Dtype* data_im) {
371    const bool kIm2Col = false;
372    im2col_nd_core_cpu(data_col, kIm2Col, num_spatial_axes, im_shape, col_shape,
373                       kernel_shape, pad, stride, dilation, data_im);
374  }
375  template void col2im_nd_cpu&lt;float&gt;(const float* data_col,
376      const int num_spatial_axes,
377      const int* im_shape, const int* col_shape,
378      const int* kernel_shape, const int* pad, const int* stride,
379      const int* dilation, float* data_im);
380  template void col2im_nd_cpu&lt;double&gt;(const double* data_col,
381      const int num_spatial_axes,
382      const int* im_shape, const int* col_shape,
383      const int* kernel_shape, const int* pad, const int* stride,
384      const int* dilation, double* data_im);
385  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im2col.cpp</h3>
            <pre><code>1  #include &lt;vector&gt;
2  #include &quot;caffe/util/im2col.hpp&quot;
3  #include &quot;caffe/util/math_functions.hpp&quot;
4  namespace caffe {
5  inline bool is_a_ge_zero_and_a_lt_b(int a, int b) {
6    return static_cast&lt;unsigned&gt;(a) &lt; static_cast&lt;unsigned&gt;(b);
7  }
8  template &lt;typename Dtype&gt;
9  void im2col_cpu(const Dtype* data_im, const int channels,
10      const int height, const int width, const int kernel_h, const int kernel_w,
11      const int pad_h, const int pad_w,
12      const int stride_h, const int stride_w,
13      const int dilation_h, const int dilation_w,
14      Dtype* data_col) {
15  #if 0
16    const int output_h = (height + 2 * pad_h -
17      (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
18    const int output_w = (width + 2 * pad_w -
19      (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
20    const int channel_size = height * width;
21    for (int channel = channels; channel--; data_im += channel_size) {
22      for (int kernel_row = 0; kernel_row &lt; kernel_h; kernel_row++) {
23        for (int kernel_col = 0; kernel_col &lt; kernel_w; kernel_col++) {
24          int input_row = -pad_h + kernel_row * dilation_h;
25          for (int output_rows = output_h; output_rows; output_rows--) {
26            if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {
27              for (int output_cols = output_w; output_cols; output_cols--) {
28                *(data_col++) = 0;
29              }
30            } else {
31              int input_col = -pad_w + kernel_col * dilation_w;
32              for (int output_col = output_w; output_col; output_col--) {
33                if (is_a_ge_zero_and_a_lt_b(input_col, width)) {
34                  *(data_col++) = data_im[input_row * width + input_col];
35                } else {
36                  *(data_col++) = 0;
37                }
38                input_col += stride_w;
39              }
40            }
41            input_row += stride_h;
42          }
43        }
44      }
45    }
46  #else
47    int dil_kernel_h = (kernel_h - 1) * dilation_h + 1;
48    int dil_kernel_w = (kernel_w - 1) * dilation_w + 1;
49    int height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
50    int width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
51    int channels_col = channels * kernel_h * kernel_w;
52    #ifdef _OPENMP
53    #pragma omp parallel for
54    #endif
55    for (int c = 0; c &lt; channels_col; ++c) {
56      int w_offset = c % kernel_w;
57      int h_offset = (c / kernel_w) % kernel_h;
58      int c_im = c / kernel_h / kernel_w;
59      const int hc0 = h_offset * dilation_h - pad_h;
60      const int wc0 = w_offset * dilation_w - pad_w;
61      for (int h = 0; h &lt; height_col; ++h) {
62        int h_pad = h * stride_h + hc0;
63        const int row_offset = (c * height_col + h) * width_col;
64        const int srow_offset = (c_im * height + h_pad) * width;
65        for (int w = 0; w &lt; width_col; ++w) {
66          int w_pad = w * stride_w + wc0;
67          if ((((unsigned)h_pad) &lt; ((unsigned)height)) &amp;&amp; (((unsigned)w_pad) &lt; ((unsigned)width)))
68            data_col[row_offset + w] = data_im[srow_offset + w_pad];
69          else {
70            data_col[row_offset + w] = 0.;
71          }
72        }
73      }
74    }
75  #endif
76  }
77  template &lt;typename Dtype&gt;
78  void im3d2col_cpu(const Dtype* data_im, const int channels,
79      const int depth, const int height, const int width,
80      const int kernel_d, const int kernel_h, const int kernel_w,
81      const int pad_d, const int pad_h, const int pad_w,
82      const int stride_d, const int stride_h, const int stride_w,
83      const int dilation_d, const int dilation_h, const int dilation_w,
84      Dtype* data_col) {
85    long dil_kernel_h = (kernel_h - 1) * dilation_h + 1;
86    long dil_kernel_w = (kernel_w - 1) * dilation_w + 1;
87    long dil_kernel_d = (kernel_d - 1) * dilation_d + 1;
88    long height_col = (height + 2 * pad_h - dil_kernel_h) / stride_h + 1;
89    long width_col = (width + 2 * pad_w - dil_kernel_w) / stride_w + 1;
90    long depth_col = (depth + 2 * pad_d - dil_kernel_d) / stride_d + 1;
91    long channels_col = channels * kernel_h * kernel_w * kernel_d;
92    #ifdef _OPENMP
93    #pragma omp parallel for
94    #endif
95    for (long c = 0; c &lt; channels_col; ++c) {
96      long w_offset = c % kernel_w;
97      long h_offset = (c / kernel_w) % kernel_h;
98      long d_offset = (c / kernel_w / kernel_h) % kernel_d;
99      long c_im = c / kernel_h / kernel_w / kernel_d;
100      for (int d = 0; d &lt; depth_col; ++d) {
101        long d_pad = d * stride_d - pad_d + d_offset * dilation_d;
102        for (long h = 0; h &lt; height_col; ++h) {
103          long h_pad = h * stride_h - pad_h + h_offset * dilation_h;
104          for (long w = 0; w &lt; width_col; ++w) {
105            long w_pad = w * stride_w - pad_w + w_offset * dilation_w;
106            if (((unsigned long)h_pad &lt; (unsigned long)height) &amp;&amp;
107                ((unsigned long)w_pad &lt; (unsigned long)width) &amp;&amp;
108                ((unsigned long)d_pad &lt; (unsigned long)depth)) {
109              data_col[((c * depth_col + d) * height_col + h) * width_col + w] =
110                data_im[((c_im * depth + d_pad) * height + h_pad) * width + w_pad];
111            } else {
112              data_col[((c * depth_col + d) * height_col + h) * width_col + w] = 0.;
113            }
114          }
115        }
116      }
117    }
118  }
119  template void im2col_cpu&lt;float&gt;(const float* data_im, const int channels,
120      const int height, const int width, const int kernel_h, const int kernel_w,
121      const int pad_h, const int pad_w, const int stride_h,
122      const int stride_w, const int dilation_h, const int dilation_w,
123      float* data_col);
124  template void im2col_cpu&lt;double&gt;(const double* data_im, const int channels,
125      const int height, const int width, const int kernel_h, const int kernel_w,
126      const int pad_h, const int pad_w, const int stride_h,
127      const int stride_w, const int dilation_h, const int dilation_w,
128      double* data_col);
129  template void im3d2col_cpu&lt;float&gt;(const float* data_im, const int channels,
130      const int depth, const int height, const int width,
131      const int kernel_d, const int kernel_h, const int kernel_w,
132      const int pad_d, const int pad_h, const int pad_w,
133      const int stride_d, const int stride_h, const int stride_w,
134      const int dilation_d, const int dilation_h, const int dilation_w,
135      float* data_col);
136  template void im3d2col_cpu&lt;double&gt;(const double* data_im, const int channels,
137      const int depth, const int height, const int width,
138      const int kernel_d, const int kernel_h, const int kernel_w,
139      const int pad_d, const int pad_h, const int pad_w,
140      const int stride_d, const int stride_h, const int stride_w,
141      const int dilation_d, const int dilation_h, const int dilation_w,
142      double* data_col);
143  template &lt;typename Dtype&gt;
144  inline void im2col_nd_core_cpu(const Dtype* data_input, const bool im2col,
145      const int num_spatial_axes, const int* im_shape, const int* col_shape,
146      const int* kernel_shape, const int* pad, const int* stride,
147      const int* dilation, Dtype* data_output) {
148    if (!im2col) {
149      size_t im_size = im_shape[0];
150      for (int i = 0; i &lt; num_spatial_axes; ++i) {
151        im_size *= (size_t)im_shape[1 + i];
152      }
153      caffe_set(im_size, Dtype(0), data_output);
154    }
155    int kernel_size = 1;
156    for (int i = 0; i &lt; num_spatial_axes; ++i) {
157      kernel_size *= kernel_shape[i];
158    }
159    const int channels_col = col_shape[0];
160    vector&lt;int&gt; d_offset(num_spatial_axes, 0);
161    vector&lt;int&gt; d_iter(num_spatial_axes, 0);
162    for (int c_col = 0; c_col &lt; channels_col; ++c_col) {
163      int offset = c_col;
164      for (int d_i = num_spatial_axes - 1; d_i &gt;= 0; --d_i) {
165        if (d_i &lt; num_spatial_axes - 1) {
166          offset /= kernel_shape[d_i + 1];
167        }
168        d_offset[d_i] = offset % kernel_shape[d_i];
169      }
170      for (bool incremented = true; incremented; ) {
171        int index_col = c_col;
172        int index_im = c_col / kernel_size;
173        bool is_padding = false;
174        for (int d_i = 0; d_i &lt; num_spatial_axes; ++d_i) {
175          const int d = d_iter[d_i];
176          const int d_im = d * stride[d_i] - pad[d_i] +
177              d_offset[d_i] * dilation[d_i];
178          is_padding |= d_im &lt; 0 || d_im &gt;= im_shape[d_i + 1];
179          index_col *= col_shape[d_i + 1];
180          index_col += d;
181          index_im *= im_shape[d_i + 1];
182          index_im += d_im;
183        }
184        if (im2col) {
185          if (is_padding) {
186            data_output[index_col] = 0;
187          } else {
188            data_output[index_col] = data_input[index_im];
189          }
190        } else if (!is_padding) {  
191          data_output[index_im] += data_input[index_col];
192        }
193        incremented = false;
194        for (int d_i = num_spatial_axes - 1; d_i &gt;= 0; --d_i) {
195          const int d_max = col_shape[d_i + 1];
196          DCHECK_LT(d_iter[d_i], d_max);
197          if (d_iter[d_i] == d_max - 1) {
198            d_iter[d_i] = 0;
199          } else {  
200            ++d_iter[d_i];
201            incremented = true;
202            break;
203          }
204        }
205      }  
206    }  
207  }
208  template &lt;typename Dtype&gt;
209  void im2col_nd_cpu(const Dtype* data_im, const int num_spatial_axes,
210      const int* im_shape, const int* col_shape,
211      const int* kernel_shape, const int* pad, const int* stride,
212      const int* dilation, Dtype* data_col) {
213    const bool kIm2Col = true;
214    im2col_nd_core_cpu(data_im, kIm2Col, num_spatial_axes, im_shape, col_shape,
215                    kernel_shape, pad, stride, dilation, data_col);
216  }
217  template void im2col_nd_cpu&lt;float&gt;(const float* data_im,
218      const int num_spatial_axes,
219      const int* im_shape, const int* col_shape,
220      const int* kernel_shape, const int* pad, const int* stride,
221      const int* dilation, float* data_col);
222  template void im2col_nd_cpu&lt;double&gt;(const double* data_im,
223      const int num_spatial_axes,
224      const int* im_shape, const int* col_shape,
225      const int* kernel_shape, const int* pad, const int* stride,
226      const int* dilation, double* data_col);
227  template &lt;typename Dtype&gt;
228  void col2im_cpu(const Dtype* data_col, const int channels,
229      const int height, const int width, const int kernel_h, const int kernel_w,
230      const int pad_h, const int pad_w,
231      const int stride_h, const int stride_w,
232      const int dilation_h, const int dilation_w,
233      Dtype* data_im) {
234  #if 0
235    caffe_set(height * width * channels, Dtype(0), data_im);
236    const int output_h = (height + 2 * pad_h -
237      (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
238    const int output_w = (width + 2 * pad_w -
239      (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
240    const int channel_size = height * width;
241    for (int channel = channels; channel--; data_im += channel_size) {
242      for (int kernel_row = 0; kernel_row &lt; kernel_h; kernel_row++) {
243        for (int kernel_col = 0; kernel_col &lt; kernel_w; kernel_col++) {
244          int input_row = -pad_h + kernel_row * dilation_h;
245          for (int output_rows = output_h; output_rows; output_rows--) {
246            if (!is_a_ge_zero_and_a_lt_b(input_row, height)) {
247              data_col += output_w;
248            } else {
249              int input_col = -pad_w + kernel_col * dilation_w;
250              for (int output_col = output_w; output_col; output_col--) {
251                if (is_a_ge_zero_and_a_lt_b(input_col, width)) {
252                  data_im[input_row * width + input_col] += *data_col;
253                }
254                data_col++;
255                input_col += stride_w;
256              }
257            }
258            input_row += stride_h;
259          }
260        }
261      }
262    }
263  #else
264    int dil_patch_h = (kernel_h - 1) * dilation_h + 1;
265    int dil_patch_w = (kernel_w - 1) * dilation_w + 1;
266    int height_col = (height + 2 * pad_h - dil_patch_h) / stride_h + 1;
267    int width_col = (width + 2 * pad_w - dil_patch_w) / stride_w + 1;
268    long chunk_len = kernel_h * kernel_w;
269    caffe_set((size_t)height * (size_t)width * (size_t)channels, Dtype(0), data_im);
270    #ifdef _OPENMP
271    #pragma omp parallel for if (channels &gt; 1)
272    #endif 
273    for (int idx = 0; idx &lt; channels; ++idx) {
274      for (int inner_idx = 0; inner_idx &lt; chunk_len; ++inner_idx) {
275        int c = idx * chunk_len + inner_idx;
276        int w_offset = c % kernel_w;
277        int h_offset = (c / kernel_w) % kernel_h;
278        int c_im = c / kernel_h / kernel_w;
<span onclick='openModal()' class='match'>279        const int hc0 = h_offset * dilation_h - pad_h;
280        const int wc0 = w_offset * dilation_w - pad_w;
281        for (int h = 0; h &lt; height_col; ++h) {
282          for (int w = 0; w &lt; width_col; ++w) {
</span>283            int h_pad = h * stride_h + hc0;
284            const int srow_offset = (c_im * height + h_pad) * width;
285            const int row_offset = (c * height_col + h) * width_col;
286            int w_pad = w * stride_w + wc0;
287            if ((((unsigned)h_pad) &lt; ((unsigned)height)) &amp;&amp; (((unsigned)w_pad) &lt; ((unsigned)width))) {
288              data_im[srow_offset + w_pad] += data_col[row_offset + w];
289            }
290          }
291        }
292      }
293    }
294  #endif
295  }
296  template &lt;typename Dtype&gt;
297  void col2im3d_cpu(const Dtype* data_col, const int channels,
298      const int depth, const int height, const int width,
299      const int kernel_d, const int kernel_h, const int kernel_w,
300      const int pad_d, const int pad_h, const int pad_w,
301      const int stride_d, const int stride_h, const int stride_w,
302      const int dilation_d, const int dilation_h, const int dilation_w,
303      Dtype* data_im) {
304    long dil_patch_h = (kernel_h - 1) * dilation_h + 1;
305    long dil_patch_w = (kernel_w - 1) * dilation_w + 1;
306    long dil_patch_d = (kernel_d - 1) * dilation_d + 1;
307    long height_col = (height + 2 * pad_h - dil_patch_h) / stride_h + 1;
308    long width_col = (width + 2 * pad_w - dil_patch_w) / stride_w + 1;
309    long depth_col = (depth + 2 * pad_d - dil_patch_d) / stride_d + 1;
310    long num_kernels = (size_t)channels * (size_t)height * (size_t)width * (size_t)depth;
311    long chunk_len = kernel_h * kernel_w * kernel_d;
312    caffe_set(num_kernels, Dtype(0), data_im);
313    #ifdef _OPENMP
314    #pragma omp parallel for if (channels &gt; 1)
315    #endif
316    for (long c_im = 0; c_im &lt; channels; ++c_im) {
317      for (long c = c_im * chunk_len; c &lt; chunk_len * (c_im + 1); ++c) {
318        long w_offset = c % kernel_w;
319        long h_offset = (c / kernel_w) % kernel_h;
320        long d_offset = (c / kernel_w / kernel_h) % kernel_d;
321        long dc0 = d_offset * dilation_d - pad_d;
322        long hc0 = h_offset * dilation_h - pad_h;
323        long wc0 = w_offset * dilation_w - pad_w;
324        for (long d = 0; d &lt; depth_col; ++d) {
325          long d_pad = d * stride_d + dc0;
326          for (long h = 0; h &lt; height_col; ++h) {
327            long h_pad = h * stride_h + hc0;
328            for (long w = 0; w &lt; width_col; ++w) {
329              long w_pad = w * stride_w + wc0;
330              if (((unsigned long)h_pad &lt; (unsigned long)height) &amp;&amp;
331                  ((unsigned long)w_pad &lt; (unsigned long)width) &amp;&amp;
332                  ((unsigned long)d_pad &lt; (unsigned long)depth)) {
333                data_im[((c_im * depth + d_pad) * height + h_pad) * width + w_pad] +=
334                  data_col[((c * depth_col + d) * height_col + h) * width_col + w];
335              }
336            }
337          }
338        }
339      }
340    }
341  }
342  template void col2im_cpu&lt;float&gt;(const float* data_col, const int channels,
343      const int height, const int width, const int kernel_h, const int kernel_w,
344      const int pad_h, const int pad_w, const int stride_h,
345      const int stride_w, const int dilation_h, const int dilation_w,
346      float* data_im);
347  template void col2im_cpu&lt;double&gt;(const double* data_col, const int channels,
348      const int height, const int width, const int kernel_h, const int kernel_w,
349      const int pad_h, const int pad_w, const int stride_h,
350      const int stride_w, const int dilation_h, const int dilation_w,
351      double* data_im);
352  template void col2im3d_cpu&lt;float&gt;(const float* data_col, const int channels,
353      const int depth, const int height, const int width,
354      const int kernel_d, const int kernel_h, const int kernel_w,
355      const int pad_d, const int pad_h, const int pad_w,
356      const int stride_d, const int stride_h, const int stride_w,
357      const int dilation_d, const int dilation_h, const int dilation_w,
358      float* data_im);
359  template void col2im3d_cpu&lt;double&gt;(const double* data_col, const int channels,
360      const int depth, const int height, const int width,
361      const int kernel_d, const int kernel_h, const int kernel_w,
362      const int pad_d, const int pad_h, const int pad_w,
363      const int stride_d, const int stride_h, const int stride_w,
364      const int dilation_d, const int dilation_h, const int dilation_w,
365      double* data_im);
366  template &lt;typename Dtype&gt;
367  void col2im_nd_cpu(const Dtype* data_col, const int num_spatial_axes,
368      const int* im_shape, const int* col_shape,
369      const int* kernel_shape, const int* pad, const int* stride,
370      const int* dilation, Dtype* data_im) {
371    const bool kIm2Col = false;
372    im2col_nd_core_cpu(data_col, kIm2Col, num_spatial_axes, im_shape, col_shape,
373                       kernel_shape, pad, stride, dilation, data_im);
374  }
375  template void col2im_nd_cpu&lt;float&gt;(const float* data_col,
376      const int num_spatial_axes,
377      const int* im_shape, const int* col_shape,
378      const int* kernel_shape, const int* pad, const int* stride,
379      const int* dilation, float* data_im);
380  template void col2im_nd_cpu&lt;double&gt;(const double* data_col,
381      const int num_spatial_axes,
382      const int* im_shape, const int* col_shape,
383      const int* kernel_shape, const int* pad, const int* stride,
384      const int* dilation, double* data_im);
385  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im2col.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im2col.cpp</div>
                </div>
                <div class="column column_space"><pre><code>59      const int hc0 = h_offset * dilation_h - pad_h;
60      const int wc0 = w_offset * dilation_w - pad_w;
61      for (int h = 0; h &lt; height_col; ++h) {
62        int h_pad = h * stride_h + hc0;
</pre></code></div>
                <div class="column column_space"><pre><code>279        const int hc0 = h_offset * dilation_h - pad_h;
280        const int wc0 = w_offset * dilation_w - pad_w;
281        for (int h = 0; h &lt; height_col; ++h) {
282          for (int w = 0; w &lt; width_col; ++w) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    