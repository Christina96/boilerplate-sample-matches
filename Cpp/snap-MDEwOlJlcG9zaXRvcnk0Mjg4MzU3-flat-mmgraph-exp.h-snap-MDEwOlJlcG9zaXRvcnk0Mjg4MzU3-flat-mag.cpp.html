
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.234708392603128%, Tokens: 11</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmgraph-exp.h</h3>
            <pre><code>1  #ifndef MGRAPH_H
2  #define MGRAPH_H
3  #include "network.h"
4  #include "networkmp.h"
5  template<class TNode>
6  class TMNet;
7  class TSVNode {
8  private:
9    TInt TypeId;
10    TInt Id;
11    TVec<TIntV > InEIdVV, OutEIdVV;
12    TInt InDeg, OutDeg;
13  public:
14    TSVNode() : TypeId(-1), Id(-1), InEIdVV(), OutEIdVV(), InDeg(0), OutDeg(0) { }
15    TSVNode(const int& NTypeId, const int& NId) : TypeId(NTypeId), Id(NId), InEIdVV(), OutEIdVV(), InDeg(0), OutDeg(0) { }
16    TSVNode(const TSVNode& Node) : TypeId(Node.TypeId), Id(Node.Id), InEIdVV(Node.InEIdVV), OutEIdVV(Node.OutEIdVV), InDeg(Node.InDeg), OutDeg(Node.OutDeg) { }
17    TSVNode(const TSVNode& Node, const TIntV& InETypeIdV, const TIntV& OutETypeIdV) :
18                  TypeId(Node.TypeId), Id(Node.Id), InEIdVV(Node.InEIdVV.Len()), OutEIdVV(Node.OutEIdVV.Len()),
19                  InDeg(0), OutDeg(0) {
20      for (int i = 0; i < InETypeIdV.Len(); i++) {
21        int ETypeId = InETypeIdV[i];
22        InEIdVV[ETypeId] = Node.InEIdVV[ETypeId];
23        InDeg += Node.InEIdVV[ETypeId].Len();
24      }
25      for (int i = 0; i < OutETypeIdV.Len(); i++) {
26        int ETypeId = OutETypeIdV[i];
27        OutEIdVV[ETypeId] = Node.OutEIdVV[ETypeId];
28        OutDeg += Node.OutEIdVV[ETypeId].Len();
29      }
30    }
31    TSVNode(TSIn& SIn) : TypeId(SIn), Id(SIn), InEIdVV(SIn), OutEIdVV(SIn), InDeg(0), OutDeg(0) { }
32    void Save(TSOut& SOut) const { TypeId.Save(SOut); Id.Save(SOut); InEIdVV.Save(SOut); OutEIdVV.Save(SOut); InDeg.Save(SOut); OutDeg.Save(SOut); }
33    int GetTypeId() const { return TypeId; }
34    int GetId() const { return Id; }
35    int GetDeg() const { return GetInDeg() + GetOutDeg(); }
36    int GetInDeg(const int& ETypeId) const {return InEIdVV[ETypeId].Len();}
37    int GetInDeg() const { return InDeg; }
38    int GetOutDeg(int ETypeId) const {return OutEIdVV[ETypeId].Len();}
39    int GetOutDeg() const { return OutDeg; }
40    void AddInETypeIds(const TIntV& ETypeIds) {
41      int MxETypeId = -1;
42      for (int i = 0; i < ETypeIds.Len(); i++) {
43        if (MxETypeId < ETypeIds[i]) { MxETypeId = ETypeIds[i]; }
44      }
45      InEIdVV.Reserve(MxETypeId+1, MxETypeId+1);
46      for (int i = 0; i < ETypeIds.Len(); i++) {
47        InEIdVV[ETypeIds[i]] = TIntV();
48      }
49    }
50    void AddOutETypeIds(const TIntV& ETypeIds) {
51      int MxETypeId = -1;
52      for (int i = 0; i < ETypeIds.Len(); i++) {
53        if (MxETypeId < ETypeIds[i]) { MxETypeId = ETypeIds[i]; }
54      }
55      OutEIdVV.Reserve(MxETypeId+1, MxETypeId+1);
56      for (int i = 0; i < ETypeIds.Len(); i++) {
57        OutEIdVV[ETypeIds[i]] = TIntV();
58      }
59    }
60    void AddInNbr(const int& ETypeId, const int& EId) { InEIdVV[ETypeId].Add(EId); InDeg++; }
61    void AddOutNbr(const int& ETypeId, const int& EId) { OutEIdVV[ETypeId].Add(EId); OutDeg++; }
62    void DelInNbr(const int& ETypeId, const int& EId) { InEIdVV[ETypeId].DelIfIn(EId); InDeg--; }
63    void DelOutNbr(const int& ETypeId, const int& EId) { OutEIdVV[ETypeId].DelIfIn(EId); OutDeg--; }
64    int GetInEId(const int& EdgeN) const {
65      int CumSum = 0;
66      int ETypeId = 0;
67      for (; ETypeId < InEIdVV.Len(); ETypeId++) {
68        CumSum += InEIdVV[ETypeId].Len();
69        if (CumSum > EdgeN) { CumSum -= InEIdVV[ETypeId].Len(); break; }
70      }
71      return InEIdVV[ETypeId][EdgeN-CumSum];
72    }
73    int GetOutEId(const int& EdgeN) const {
74      int CumSum = 0;
75      int ETypeId = 0;
76      for (; ETypeId < OutEIdVV.Len(); ETypeId++) {
77        CumSum += OutEIdVV[ETypeId].Len();
78        if (CumSum > EdgeN) { CumSum -= OutEIdVV[ETypeId].Len(); break; }
79      }
80      return OutEIdVV[ETypeId][EdgeN-CumSum];
81    }
82    void GetInEIdV(TIntV& EIdV) const {
83      EIdV.Gen(InDeg, 0);
84      for (int i = 0; i < InEIdVV.Len(); i++) {
85        EIdV.AddV(InEIdVV[i]);
86      }
87    }
88    void GetOutEIdV(TIntV& EIdV) const {
89      EIdV.Gen(OutDeg, 0);
90      for (int i = 0; i < OutEIdVV.Len(); i++) {
91        EIdV.AddV(OutEIdVV[i]);
92      }
93    }
94    void GetInEIdV(const TInt ETypeId, TIntV& EIdV) const {
95      EIdV = InEIdVV[ETypeId.Val];
96    }
97    void GetOutEIdV(const TInt ETypeId, TIntV& EIdV) const {
98      EIdV = OutEIdVV[ETypeId.Val];
99    }
100    void GetInEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
101      EIdV.Reserve(InDeg, 0);
102      for (int k = 0; k < ETypeIdV.Len(); k++) {
103        EIdV.AddV(InEIdVV[ETypeIdV[k].Val]);
104      }
105    }
106    void GetOutEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
107      EIdV.Reserve(OutDeg, 0);
108      for (int k = 0; k < ETypeIdV.Len(); k++) {
109        EIdV.AddV(OutEIdVV[ETypeIdV[k].Val]);
110      }
111    }
112    friend class TMNet<TSVNode>;
113  };
114  class TMVNode {
115  private:
116    TInt TypeId; 
117    TInt Id; 
118    TIntV InEIdV, OutEIdV; 
119    TIntV InETypeIdV, OutETypeIdV; 
120  public:
121    TMVNode() : TypeId(-1), Id(-1), InEIdV(), OutEIdV(), InETypeIdV(), OutETypeIdV() { }
122    TMVNode(const int& NTypeId, const int& NId) : TypeId(NTypeId), Id(NId), InEIdV(), OutEIdV(), InETypeIdV(), OutETypeIdV() { }
123    TMVNode(const TMVNode& Node) : TypeId(Node.TypeId), Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV),
124                                          InETypeIdV(Node.InETypeIdV), OutETypeIdV(Node.OutETypeIdV) { }
125    TMVNode(const TMVNode& Node, const TIntV& InETypeIdV, const TIntV& OutETypeIdV) :
126              TypeId(Node.TypeId), Id(Node.Id), InEIdV(Node.InEIdV.Len()), OutEIdV(Node.OutEIdV.Len()),
127              InETypeIdV(Node.InETypeIdV.Len()), OutETypeIdV(Node.OutETypeIdV.Len()) {
128      TIntSet InETypeIdSet(InETypeIdV);
129      for (int i = 0; i < Node.InEIdV.Len(); i++) {
130        if (InETypeIdSet.IsKey(Node.InETypeIdV[i])) {
131          InEIdV.Add(Node.InEIdV[i]);
132        }
133      }
134      TIntSet OutETypeIdSet(OutETypeIdV);
135      for (int i = 0; i < Node.OutEIdV.Len(); i++) {
136        if (OutETypeIdSet.IsKey(Node.OutETypeIdV[i])) {
137          OutEIdV.Add(Node.OutEIdV[i]);
138        }
139      }
140    }
141    TMVNode(TSIn& SIn) : TypeId(SIn), Id(SIn), InEIdV(SIn), OutEIdV(SIn), InETypeIdV(SIn), OutETypeIdV(SIn) { }
142    void Save(TSOut& SOut) const { TypeId.Save(SOut); Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut);
143                                    InETypeIdV.Save(SOut); OutETypeIdV.Save(SOut); }
144    int GetTypeId() const { return TypeId; }
145    int GetId() const { return Id; }
146    int GetDeg() const { return GetInDeg() + GetOutDeg(); }
147    int GetInDeg() const { return InEIdV.Len(); }
148    int GetOutDeg() const { return OutEIdV.Len(); }
149    int GetInEId(const int& EdgeN) const { return InEIdV[EdgeN]; }
150    int GetOutEId(const int& EdgeN) const { return OutEIdV[EdgeN]; }
151    int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
152    void GetInEIdV(TIntV& EIdV) const { EIdV = InEIdV; }
153    void GetOutEIdV(TIntV& EIdV) const { EIdV = OutEIdV; }
154    bool IsInEId(const int& EId) const { return InEIdV.SearchForw(EId) != -1; }
155    bool IsOutEId(const int& EId) const { return OutEIdV.SearchForw(EId) != -1; }
156    void AddInETypeIds(const TIntV& ETypeIds) { } 
157    void AddOutETypeIds(const TIntV& ETypeIds) { } 
158    void AddInNbr(const int& ETypeId, const int& EId) {
159      InETypeIdV.Add(ETypeId);
160      InEIdV.Add(EId);
161    }
162    void AddOutNbr(const int& ETypeId, const int& EId) {
163      OutETypeIdV.Add(ETypeId);
164      OutEIdV.Add(EId);
165    }
166    void DelInNbr(const int& ETypeId, const int& EId) {
167      int EIdN = InEIdV.SearchBack(EId);
168      InETypeIdV.Del(EIdN);
169      InEIdV.Del(EIdN);
170    }
171    void DelOutNbr(const int& ETypeId, const int& EId) {
172      int EIdN = OutEIdV.SearchBack(EId);
173      OutETypeIdV.Del(EIdN);
174      OutEIdV.Del(EIdN);
175    }
176    void GetInEIdV(const TInt& ETypeId, TIntV& EIdV) const {
177      EIdV.Reduce(0); 
178      for (int i = 0; i < InEIdV.Len(); i++) {
179        if (InETypeIdV[i] == ETypeId) { EIdV.Add(InEIdV[i]); }
180      }
181    }
182    void GetOutEIdV(const TInt& ETypeId, TIntV& EIdV) const {
183      EIdV.Reduce(0); 
184      for (int i = 0; i < OutEIdV.Len(); i++) {
185        if (OutETypeIdV[i] == ETypeId) { EIdV.Add(OutEIdV[i]); }
186      }
187    }
188    void GetInEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
189      EIdV.Reserve(InEIdV.Len(), 0);
190      for (int k = 0; k < ETypeIdV.Len(); k++) {
191        TInt ETypeId = ETypeIdV[k];
192        for (int i = 0; i < InETypeIdV.Len(); i++) {
193          if (InETypeIdV[i] == ETypeId) { EIdV.Add(InEIdV[i]); }
194        }
195      }
196    }
197    void GetOutEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
198      EIdV.Reserve(OutEIdV.Len(), 0);
199      for (int k = 0; k < ETypeIdV.Len(); k++) {
200        TInt ETypeId = ETypeIdV[k];
201        for (int i = 0; i < OutETypeIdV.Len(); i++) {
202          if (OutETypeIdV[i] == ETypeId) { EIdV.Add(OutEIdV[i]); }
203        }
204      }
205    }
206    friend class TMNet<TMVNode>;
207  };
208  class TCVNode {
209  public:
210    static const int DEF_WEIGHT;
211    static const int DEF_WEIGHT_COEFF;
212    static const int DEF_EXPAND_RATIO;
213  private:
214    static void RedistributeEIds(const TIntV& Weights, TIntV& EIdV, TIntV& TypeIndexV, TIntV& TypeDegV) {
215      IAssertR(TypeIndexV.Len() == TypeDegV.Len(), TStr::Fmt("The node is in inconsistent state."));
216      int NTypes = Weights.Len();
217      TIntV NewTypeIndexV(NTypes); 
218      int CumSum = 0; 
219      for (int ETypeId = 0; ETypeId < NTypes; ETypeId++) {
220        NewTypeIndexV[ETypeId] = CumSum;
221        CumSum += Weights[ETypeId] * DEF_WEIGHT_COEFF;
222      }
223      TIntV NewEIdV(CumSum);
224      for (int ETypeId = TypeIndexV.Len() - 1; ETypeId >= 0; ETypeId--) {
225        IAssertR(CumSum >= NewTypeIndexV[ETypeId] + TypeDegV[ETypeId], TStr::Fmt("The node is in inconsistent state."));
226        for (int i = 0; i < TypeDegV[ETypeId]; i++) {
227          NewEIdV[NewTypeIndexV[ETypeId] + i] = EIdV[TypeIndexV[ETypeId] + i];
228        }
229      }
230      TypeDegV.Reserve(NTypes, NTypes);
231      TypeIndexV = NewTypeIndexV;
232      EIdV = NewEIdV;
233    }
234  private:
235    TInt TypeId; 
236    TInt Id; 
237    TIntV InEIdV, OutEIdV;
238    TInt InDeg, OutDeg;
239    TIntV InTypeIndexV, OutTypeIndexV;
240    TIntV InTypeDegV, OutTypeDegV;
241  public:
242    TCVNode() : TypeId(-1), Id(-1), InEIdV(), OutEIdV(), InDeg(0), OutDeg(0),
243                                      InTypeIndexV(), OutTypeIndexV(), InTypeDegV(), OutTypeDegV() { }
244    TCVNode(const int& NTypeId, const int& NId) : TypeId(NTypeId), Id(NId), InEIdV(), OutEIdV(), InDeg(0), OutDeg(0),
245                                      InTypeIndexV(), OutTypeIndexV(), InTypeDegV(), OutTypeDegV() { }
246    TCVNode(const TCVNode& Node) : TypeId(Node.TypeId), Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV),
247                                      InDeg(Node.InDeg), OutDeg(Node.OutDeg), InTypeIndexV(Node.InTypeIndexV), OutTypeIndexV(Node.OutTypeIndexV),
248                                      InTypeDegV(Node.InTypeDegV), OutTypeDegV(Node.OutTypeDegV) { }
249    TCVNode(const TCVNode& Node, const TIntV& InETypeIdV, const TIntV& OutETypeIdV) :
250                                      TypeId(Node.TypeId), Id(Node.Id), InDeg(0), OutDeg(0),
251                                      InTypeIndexV(Node.InTypeIndexV.Len()), OutTypeIndexV(Node.OutTypeIndexV.Len()),
252                                      InTypeDegV(Node.InTypeDegV.Len()), OutTypeDegV(Node.OutTypeDegV.Len()) {
253      for (TIntV::TIter iter = InETypeIdV.BegI(); iter < InETypeIdV.EndI(); iter++) {
254        InDeg += Node.InTypeDegV[*iter];
255        InTypeDegV[*iter] = Node.InTypeDegV[*iter];
256      }
257      int index = 0;
258      InEIdV.Gen(InDeg);
259      TIntSet InETypeIdSet(InETypeIdV);
260      for (int ETypeId = 0; ETypeId < InTypeIndexV.Len(); ETypeId++) {
261        InTypeIndexV[ETypeId] = index;
<span onclick='openModal()' class='match'>262        if (InETypeIdSet.IsKey(ETypeId)) {
263          for (int i = Node.InTypeIndexV[ETypeId]; i < Node.InTypeIndexV[ETypeId] + Node.InTypeDegV[ETypeId]; i++) {
264            InEIdV[index++] = Node.InEIdV[i];
265          }
266        }
267      }
</span>268      IAssert(index == InDeg);
269      for (TIntV::TIter iter = OutETypeIdV.BegI(); iter < OutETypeIdV.EndI(); iter++) {
270        OutDeg += Node.OutTypeDegV[*iter];
271        OutTypeDegV[*iter] = Node.OutTypeDegV[*iter];
272      }
273      index = 0;
274      OutEIdV.Gen(OutDeg);
275      TIntSet OutETypeIdSet(OutETypeIdV);
276      for (int ETypeId = 0; ETypeId < OutTypeIndexV.Len(); ETypeId++) {
277        OutTypeIndexV[ETypeId] = index;
278        if (OutETypeIdSet.IsKey(ETypeId)) {
279          for (int i = Node.OutTypeIndexV[ETypeId]; i < Node.OutTypeIndexV[ETypeId] + Node.OutTypeDegV[ETypeId]; i++) {
280            OutEIdV[index++] = Node.OutEIdV[i];
281          }
282        }
283      }
284      IAssert(index == OutDeg);
285    }
286    TCVNode(TSIn& SIn) : TypeId(SIn), Id(SIn), InEIdV(SIn), OutEIdV(SIn), InDeg(SIn), OutDeg(SIn),
287                                      InTypeIndexV(SIn), OutTypeIndexV(SIn), InTypeDegV(SIn), OutTypeDegV(SIn) { }
288    void Save(TSOut& SOut) const { TypeId.Save(SOut); Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut);
289                                      InDeg.Save(SOut); OutDeg.Save(SOut); InTypeIndexV.Save(SOut); OutTypeIndexV.Save(SOut);
290                                      InTypeDegV.Save(SOut); OutTypeDegV.Save(SOut); }
291    int GetTypeId() const { return TypeId; }
292    int GetId() const { return Id; }
293    int GetDeg() const { return InDeg + OutDeg; }
294    int GetInDeg() const { return InDeg; }
295    int GetOutDeg() const { return OutDeg; }
296    int GetInDeg(const int& ETypeId) const { return InTypeDegV[ETypeId]; }
297    int GetOutDeg(const int& ETypeId) const { return OutTypeDegV[ETypeId]; }
298    int GetInEId(const int& EdgeN) const {
299      int CumSum = 0;
300      int ETypeId = 0;
301      for (; ETypeId < InTypeDegV.Len(); ETypeId++) {
302        CumSum += InTypeDegV[ETypeId];
303        if (CumSum > EdgeN) { CumSum -= InTypeDegV[ETypeId]; break; }
304      }
305      return InEIdV[InTypeIndexV[ETypeId] + EdgeN - CumSum];
306    }
307    int GetOutEId(const int& EdgeN) const {
308      int CumSum = 0;
309      int ETypeId = 0;
310      for (; ETypeId < OutTypeDegV.Len(); ETypeId++) {
311        CumSum += OutTypeDegV[ETypeId];
312        if (CumSum > EdgeN) { CumSum -= OutTypeDegV[ETypeId]; break; }
313      }
314      return OutEIdV[OutTypeIndexV[ETypeId] + EdgeN - CumSum];
315    }
316    int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
317    void GetInEIdV(TIntV& EIdV) const {
318      EIdV.Gen(InDeg, 0);
319      for (int ETypeId = 0; ETypeId < InTypeDegV.Len(); ETypeId++) {
320        for (int i = InTypeIndexV[ETypeId]; i < InTypeIndexV[ETypeId] + InTypeDegV[ETypeId]; i++) {
321          EIdV.Add(InEIdV[i]);
322        }
323      }
324    }
325    void GetOutEIdV(TIntV& EIdV) const {
326      EIdV.Gen(OutDeg, 0);
327      for (int ETypeId = 0; ETypeId < OutTypeDegV.Len(); ETypeId++) {
328        for (int i = OutTypeIndexV[ETypeId]; i < OutTypeIndexV[ETypeId] + OutTypeDegV[ETypeId]; i++) {
329          EIdV.Add(OutEIdV[i]);
330        }
331      }
332    }
333    void AddInETypeIds(const TIntV& ETypeIds) {
334      if (ETypeIds.Len() == 0) { return; }
335      int MxETypeId = InTypeIndexV.Len() - 1;
336      for (TIntV::TIter iter = ETypeIds.BegI(); iter < ETypeIds.EndI(); iter++) {
337        if (MxETypeId < *iter) { MxETypeId = *iter; }
338      }
339      TIntV InWeights(MxETypeId + 1);
340      for (int ETypeId = 0; ETypeId < InTypeDegV.Len(); ETypeId++) {
341        InWeights[ETypeId] = InTypeDegV[ETypeId];
342      }
343      for (TIntV::TIter iter = ETypeIds.BegI(); iter < ETypeIds.EndI(); iter++) {
344        InWeights[*iter] = DEF_WEIGHT;
345      }
346      RedistributeEIds(InWeights, InEIdV, InTypeIndexV, InTypeDegV);
347    }
348    void AddOutETypeIds(const TIntV& ETypeIds) {
349      if (ETypeIds.Len() == 0) { return; }
350      int MxETypeId = OutTypeIndexV.Len() - 1;
351      for (TIntV::TIter iter = ETypeIds.BegI(); iter < ETypeIds.EndI(); iter++) {
352        if (MxETypeId < *iter) { MxETypeId = *iter; }
353      }
354      TIntV OutWeights(MxETypeId + 1);
355      for (int ETypeId = 0; ETypeId < OutTypeDegV.Len(); ETypeId++) {
356        OutWeights[ETypeId] = OutTypeDegV[ETypeId];
357      }
358      for (TIntV::TIter iter = ETypeIds.BegI(); iter < ETypeIds.EndI(); iter++) {
359        OutWeights[*iter] = DEF_WEIGHT;
360      }
361      RedistributeEIds(OutWeights, OutEIdV, OutTypeIndexV, OutTypeDegV);
362    }
363    void AddInNbr(const int& ETypeId, const int& EId) {
364      int Deg = InTypeDegV[ETypeId];
365      int Capacity = (ETypeId == (InTypeIndexV.Len()-1)) ? InEIdV.Len() : InTypeIndexV[ETypeId+1].Val;
366      Capacity -= InTypeIndexV[ETypeId];
367      if (Deg >= Capacity) {
368        IAssertR(Deg == Capacity, TStr::Fmt("The node is in inconsistent state."));
369        TIntV Weights(InTypeDegV);
370        Weights[ETypeId] = (Weights[ETypeId] + 4) * DEF_EXPAND_RATIO;
371        RedistributeEIds(Weights, InEIdV, InTypeIndexV, InTypeDegV);
372      }
373      InEIdV[InTypeIndexV[ETypeId] + Deg] = EId;
374      InTypeDegV[ETypeId]++;
375      InDeg++;
376    }
377    void AddOutNbr(const int& ETypeId, const int& EId) {
378      int Deg = OutTypeDegV[ETypeId];
379      int Capacity = (ETypeId == (OutTypeIndexV.Len()-1)) ? OutEIdV.Len() : OutTypeIndexV[ETypeId+1].Val;
380      Capacity -= OutTypeIndexV[ETypeId];
381      if (Deg >= Capacity) {
382        IAssertR(Deg == Capacity, TStr::Fmt("The node is in inconsistent state."));
383        TIntV Weights(OutTypeDegV);
384        Weights[ETypeId] = (Weights[ETypeId] + 4) * DEF_EXPAND_RATIO; 
385        RedistributeEIds(Weights, OutEIdV, OutTypeIndexV, OutTypeDegV);
386      }
387      OutEIdV[OutTypeIndexV[ETypeId] + Deg] = EId;
388      OutTypeDegV[ETypeId]++;
389      OutDeg++;
390    }
391    void DelInNbr(const int& ETypeId, const int& EId) {
392      int ValN = InEIdV.SearchForw(EId, InTypeIndexV[ETypeId]);
393      for (int MValN=ValN+1; MValN<InTypeIndexV[ETypeId]+InTypeDegV[ETypeId]; MValN++){
394        InEIdV[MValN-1]=InEIdV[MValN];
395      }
396      InDeg--;
397      InTypeDegV[ETypeId]--;
398    }
399    void DelOutNbr(const int& ETypeId, const int& EId) {
400      int ValN = OutEIdV.SearchForw(EId, OutTypeIndexV[ETypeId]);
401      for (int MValN=ValN+1; MValN<OutTypeIndexV[ETypeId]+OutTypeDegV[ETypeId]; MValN++){
402        OutEIdV[MValN-1]=OutEIdV[MValN];
403      }
404      OutDeg--;
405      OutTypeDegV[ETypeId]--;
406    }
407    void GetInEIdV(const TInt& ETypeId, TIntV& EIdV) const {
408      int Sz = InTypeDegV[ETypeId].Val;
409      EIdV.Reserve(Sz, Sz);
410      int Ind = InTypeIndexV[ETypeId].Val;
411      for (int i = 0; i < Sz; i++) {
412        EIdV[i] = InEIdV[Ind+i];
413      }
414    }
415    void GetOutEIdV(const TInt& ETypeId, TIntV& EIdV) const {
416      int Sz = OutTypeDegV[ETypeId].Val;
417      EIdV.Reserve(Sz, Sz);
418      int Ind = OutTypeIndexV[ETypeId].Val;
419      for (int i = 0; i < Sz; i++) {
420        EIdV[i] = OutEIdV[Ind+i];
421      }
422    }
423    void GetInEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
424      int Sz = 0;
425      for (int k = 0; k < ETypeIdV.Len(); k++) {
426        Sz += InTypeDegV[ETypeIdV[k]].Val;
427      }
428      EIdV.Reserve(Sz, 0);
429      int Ind;
430      for (int k = 0; k < ETypeIdV.Len(); k++) {
431        Ind = InTypeIndexV[ETypeIdV[k]].Val;
432        for (int i = 0; i < InTypeDegV[ETypeIdV[k]]; i++) {
433          EIdV.Add(InEIdV[Ind]);
434        }
435      }
436    }
437    void GetOutEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
438      int Sz = 0;
439      for (int k = 0; k < ETypeIdV.Len(); k++) {
440        Sz += OutTypeDegV[ETypeIdV[k]].Val;
441      }
442      EIdV.Reserve(Sz, 0);
443      int Ind;
444      for (int k = 0; k < ETypeIdV.Len(); k++) {
445        Ind = OutTypeIndexV[ETypeIdV[k]].Val;
446        for (int i = 0; i < OutTypeDegV[ETypeIdV[k]]; i++) {
447          EIdV.Add(OutEIdV[Ind]);
448        }
449      }
450    }
451    friend class TMNet<TCVNode>;
452  };
453  template<class TNode>
454  class TMNet {
455  public:
456    typedef TMNet TNet;
457    typedef TPt<TMNet> PNet;
458  public:
459    class TEdge {
460    private:
461      TInt TypeId, Id, SrcNId, DstNId;
462    public:
463      TEdge() : TypeId(-1), Id(-1), SrcNId(-1), DstNId(-1) { }
464      TEdge(const int& ETypeId, const int& EId, const int& SourceNId, const int& DestNId) : TypeId(ETypeId), Id(EId), SrcNId(SourceNId), DstNId(DestNId) { }
465      TEdge(const TEdge& Edge) : TypeId(Edge.TypeId), Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId) { }
466      TEdge(TSIn& SIn) : TypeId(SIn), Id(SIn), SrcNId(SIn), DstNId(SIn) { }
467      void Save(TSOut& SOut) const { TypeId.Save(SOut), Id.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
468      int GetTypeId() const { return TypeId; }
469      int GetId() const { return Id; }
470      int GetSrcNId() const { return SrcNId; }
471      int GetDstNId() const { return DstNId; }
472      friend class TMNet;
473    };
474    class TNodeType {
475    private:
476      TInt Id;
477      TStr Name;
478      TInt MxNId;
479      THash<TInt, TNode> NodeH;
480    public:
481      TNodeType() : Id(-1), Name(), MxNId(0), NodeH(){ }
482      TNodeType(const int& NTypeId, const TStr& NTypeName) : Id(NTypeId), Name(NTypeName), MxNId(0), NodeH(){ }
483      TNodeType(const TNodeType& NodeType) : Id(NodeType.Id), Name(NodeType.Name), MxNId(NodeType.MxNId), NodeH(NodeType.NodeH) { }
484      TNodeType(const TNodeType& NodeType, const TIntV& InETypeIdV, const TIntV& OutETypeIdV) :
485                Id(NodeType.Id), Name(NodeType.Name), MxNId(NodeType.MxNId), NodeH(NodeType.NodeH.Len()) {
486        for (typename THash<TInt,TNode>::TIter iter = NodeType.NodeH.BegI(); iter < NodeType.NodeH.EndI(); iter++) {
487          TNode NewNode(iter.GetDat(), InETypeIdV, OutETypeIdV);
488          NodeH.AddDat(iter.GetKey(), NewNode);
489        }
490      }
491      TNodeType(TSIn& SIn) : Id(SIn), Name(SIn), MxNId(SIn), NodeH(SIn) { }
492      void Save(TSOut& SOut) const { Id.Save(SOut); Name.Save(SOut); MxNId.Save(SOut); NodeH.Save(SOut); }
493      int GetId() const { return Id; }
494      TStr GetName() const { return Name; }
495      int GetMxNId() const { return MxNId; }
496      friend class TMNet;
497    };
498    template<class TEdge>
499    class TMNodeI {
500    private:
501      typedef typename THash<TInt, TNode>::TIter THashIter;
502      typedef typename TVec<TNodeType>::TIter TTypeIter;
503      TTypeIter VecI;
504      TTypeIter VecEndI;
505      THashIter HashI;
506      const TMNet *Graph;
507    private:
508      THashIter VecElemBegI() {
509        return (*VecI).NodeH.BegI();
510      }
511      void FindNextNonEmptyHashI() {
512        while (HashI.IsEnd() && VecI < VecEndI) {
513          VecI++;
514          HashI = VecElemBegI();
515        }
516      }
517    public:
518      TMNodeI() : VecI(), VecEndI(), HashI(), Graph(NULL) { }
519      TMNodeI(const TTypeIter& TypeIter, const THashIter& NodeIter, const TMNet* GraphPt)
520                : VecI(TypeIter), VecEndI(GraphPt->TypeNodeV.EndI()), HashI(NodeIter), Graph(GraphPt) { }
521      TMNodeI(const TTypeIter& TypeIter, const TMNet* GraphPt) : VecI(TypeIter), VecEndI(GraphPt->TypeNodeV.EndI()), Graph(GraphPt) {
522        if (VecI < VecEndI) {
523          HashI = VecElemBegI();
524          FindNextNonEmptyHashI();
525        } else {
526          HashI = THashIter();
527        }
528      }
529      TMNodeI(const TMNodeI& NodeI) : VecI(NodeI.VecI), VecEndI(NodeI.VecEndI), HashI(NodeI.HashI), Graph(NodeI.Graph) { }
530      TMNodeI& operator = (const TMNodeI& NodeI) { VecI=NodeI.VecI; VecEndI=NodeI.VecEndI; HashI=NodeI.HashI; Graph=NodeI.Graph; return *this; }
531      TMNodeI& operator++ (int) {
532        HashI++;
533        FindNextNonEmptyHashI();
534        return *this;
535      }
536      bool operator < (const TMNodeI& NodeI) const { return VecI < NodeI.VecI || HashI < NodeI.HashI; }
537      bool operator == (const TMNodeI& NodeI) const { return VecI == NodeI.VecI && HashI == NodeI.HashI; }
538      int GetId() const { return HashI.GetDat().GetId(); }
539      int GetLocalId() const { return TMNet::GetLocalNId(GetId()); }
540      int GetTypeId() const { return HashI.GetDat().GetTypeId(); }
541      int GetDeg() const { return HashI.GetDat().GetDeg(); }
542      int GetInDeg() const { return HashI.GetDat().GetInDeg(); }
543      int GetOutDeg() const { return HashI.GetDat().GetOutDeg(); }
544      int GetInNId(const int& EdgeN) const { return Graph->GetEdge(HashI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
545      int GetOutNId(const int& EdgeN) const { return Graph->GetEdge(HashI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
546      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Graph->GetEdge(HashI.GetDat().GetNbrEId(EdgeN)); return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
547      bool IsInNId(const int& NId) const {
548        const TNode& Node = HashI.GetDat();
549        for (int edge = 0; edge < Node.GetInDeg(); edge++) {
550          if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId()) { return true; }
551        }
552        return false;
553      }
554      bool IsOutNId(const int& NId) const {
555        const TNode& Node = HashI.GetDat();
556        for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
557          if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId()) { return true; }
558        }
559        return false;
560      }
561      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
562      int GetInEId(const int& EdgeN) const { return HashI.GetDat().GetInEId(EdgeN); }
563      int GetOutEId(const int& EdgeN) const { return HashI.GetDat().GetOutEId(EdgeN); }
564      int GetNbrEId(const int& EdgeN) const { return HashI.GetDat().GetNbrEId(EdgeN); }
565      bool IsInEId(const int& EId) const { return HashI.GetDat().IsInEId(EId); }
566      bool IsOutEId(const int& EId) const { return HashI.GetDat().IsOutEId(EId); }
567      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
568    };
569    typedef TMNodeI<TEdge> TNodeI;
570    class TEdgeI {
571    private:
572      typedef typename THash<TInt, TEdge>::TIter THashIter;
573      THashIter EdgeHI;
574      const TMNet *Graph;
575    public:
576      TEdgeI() : EdgeHI(), Graph(NULL) { }
577      TEdgeI(const THashIter& EdgeHIter, const TMNet *GraphPt) : EdgeHI(EdgeHIter), Graph(GraphPt) { }
578      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Graph(EdgeI.Graph) { }
579      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI; Graph=EdgeI.Graph; }  return *this; }
580      TEdgeI& operator++ (int) { EdgeHI++; return *this; }
581      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
582      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
583      int GetId() const { return EdgeHI.GetDat().GetId(); }
584      int GetTypeId() const { return EdgeHI.GetDat().GetTypeId(); }
585      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
586      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
587      friend class TMNet;
588    };
589  private:
590    static const int NTYPEID_NBITS = 3; 
591    static const int NTYPEID_FLAG = (1 << NTYPEID_NBITS) - 1;
592    static int GetGlobalNId(const int& NTypeId, const int& NId) { return (NId << NTYPEID_NBITS) + NTypeId;}
593  private:
594    TCRef CRef;
595    TInt MxNId;
596    TInt MxEId;
597    THash<TStr, int> NTypeH;
598    THash<TStr, int> ETypeH;
599    TVec<TNodeType> TypeNodeV;
600    TIntV EdgeSzV; 
601    THash<TInt, TEdge> EdgeH;
602    int Sz;
603    TVec<TIntV> InETypes;
604    TVec<TIntV> OutETypes;
605    TStrIntPrH KeyToIndexTypeN, KeyToIndexTypeE;
606    enum { IntType, StrType, FltType };
607  private:
608    TNode& GetNode(const int&NId) {
609      int NTypeId = GetNTypeId(NId);
610      int LocalNId = GetLocalNId(NId);
611      return GetNode(NTypeId, LocalNId);
612    }
613    const TNode& GetNode(const int&NId) const {
614      int NTypeId = GetNTypeId(NId);
615      int LocalNId = GetLocalNId(NId);
616      return GetNode(NTypeId, LocalNId);
617    }
618    TNode& GetNode(const int& NTypeId, const int& NId) { return TypeNodeV[NTypeId].NodeH.GetDat(NId); }
619    const TNode& GetNode(const int& NTypeId, const int& NId) const { return TypeNodeV[NTypeId].NodeH.GetDat(NId); }
620    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
621    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
622    void AssertNTypeId(const int NTypeId) const {
623      IAssertR(IsNTypeId(NTypeId), TStr::Fmt("NodeTypeId %d does not exist", NTypeId));
624    }
625  public:
626    TMNet() : CRef(), MxEId(0), NTypeH(), ETypeH(), TypeNodeV(), EdgeH(), Sz(0), InETypes(), OutETypes(),
627      KeyToIndexTypeN(), KeyToIndexTypeE() { }
628    TMNet(const TMNet& Graph) : MxEId(Graph.MxEId),
629      NTypeH(Graph.NTypeH), ETypeH(Graph.ETypeH), TypeNodeV(Graph.TypeNodeV), EdgeH(Graph.EdgeH), Sz(Graph.Sz),
630      InETypes(Graph.InETypes), OutETypes(Graph.OutETypes), KeyToIndexTypeN(), KeyToIndexTypeE() { }
631    static TPt<TMNet<TNode> > New() {
632      return TPt<TMNet<TNode> >(new TMNet());
633    }
634    TMNet& operator = (const TMNet& Graph) { if (this!=&Graph) {
635      MxEId=Graph.MxEId; NTypeH=Graph.NTypeH; ETypeH=Graph.ETypeH; TypeNodeV=Graph.TypeNodeV; EdgeH=Graph.EdgeH;
636      Sz=Graph.Sz; InETypes=Graph.InETypes; OutETypes=Graph.OutETypes;
637      KeyToIndexTypeN=Graph.KeyToIndexTypeN; KeyToIndexTypeE=Graph.KeyToIndexTypeE;}
638      return *this; }
639    bool HasFlag(const TGraphFlag& Flag) const {
640      if (Flag == gfDirected) { return true; }
641      else if (Flag == gfMultiGraph) { return true; }
642      else return false;
643    }
644    static int GetNTypeId(const int& NId) { return NId & NTYPEID_FLAG; } 
645    static int GetLocalNId(const int& GlobalNId) { return GlobalNId >> NTYPEID_NBITS; }
646    int GetMxNTypeId() const { return TypeNodeV.Len(); }
647    int AddNType(const TStr& NTypeName) {
648      int KeyId = NTypeH.GetKeyId(NTypeName);
649      if (KeyId == -1) {
650        int NTypeId = GetMxNTypeId();
651        NTypeH.AddDat(NTypeName, NTypeId);
652        TypeNodeV.Add(TNodeType(NTypeId, NTypeName));
653        IAssertR(NTypeId == InETypes.Len(), TStr::Fmt("InETypes has inconsistent length."));
654        IAssertR(NTypeId == OutETypes.Len(), TStr::Fmt("OutETypes has inconsistent length."));
655        InETypes.Add(TIntV());
656        OutETypes.Add(TIntV());
657        return NTypeId;
658      } else {
659        TStr TempKey;
660        int NTypeId;
661        NTypeH.GetKeyDat(KeyId, TempKey, NTypeId);
662        return NTypeId;
663      }
664    }
665    int GetNTypeId(const TStr& NTypeStr) { return NTypeH.GetDat(NTypeStr); }
666    TStr GetNTypeName(const int NTypeId) {
667      AssertNTypeId(NTypeId);
668      return TypeNodeV[NTypeId].Name;
669    }
670    bool IsNTypeId(const int NTypeId) const { return NTypeId >= 0 && NTypeId < TypeNodeV.Len(); }
671    int GetNodes() const { return Sz; }
672    int GetNodes(const int& NTypeId) const { return TypeNodeV[NTypeId].NodeH.Len(); }
673    int GetMxNId() const { return MxNId; }
674    int GetMxNId(const int& NTypeId) const {
675      AssertNTypeId(NTypeId);
676      return TypeNodeV[NTypeId].MxNId;
677    }
678    int AddNode(const int& NTypeId, int NId = -1) {
679      AssertNTypeId(NTypeId);
680      TNodeType* NodeType = &TypeNodeV[NTypeId];
681      if (NId == -1) {
682        NId = NodeType->MxNId; NodeType->MxNId++;
683      } else {
684        IAssertR(!IsNode(NTypeId, NId), TStr::Fmt("NodeId %d with type %d already exists", NId, NTypeId));
685        NodeType->MxNId = TMath::Mx(NId+1, NodeType->GetMxNId());
686      }
687      TNode NewNode(NTypeId, GetGlobalNId(NTypeId, NId));
688      NewNode.AddInETypeIds(InETypes[NTypeId]);
689      NewNode.AddOutETypeIds(OutETypes[NTypeId]);
690      NodeType->NodeH.AddDat(NId, NewNode);
691      int GlobalNId = GetGlobalNId(NTypeId, NId);
692      MxNId = TMath::Mx(GlobalNId+1, MxNId());
693      Sz++;
694      return GlobalNId;
695    }
696    int AddNode(const TStr& NTypeStr) { return AddNode(GetNTypeId(NTypeStr)); }
697    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetTypeId(), NodeId.GetId()); }
698    bool IsNode(const int& NId) const { return IsNode(GetNTypeId(NId), GetLocalNId(NId)); }
699    bool IsNode(const int& NTypeId, const int& NId) const {
700      if (!IsNTypeId(NTypeId)) { return false; }
701      return TypeNodeV[NTypeId].NodeH.IsKey(NId);
702    }
703    void DelNode(const int& NTypeId, const int& NId) {
704      const TNode& Node = GetNode(NTypeId, NId);
705      TIntV EIdV;
706      Node.GetOutEIdV(EIdV);
707      for (int out = 0; out < EIdV.Len(); out++) {
708        DelEdge(EIdV[out]);
709      }
710      Node.GetInEIdV(EIdV);
711      for (int in = 0; in < EIdV.Len(); in++) {
712        DelEdge(EIdV[in]);
713      }
714      TypeNodeV[NTypeId].NodeH.DelKey(NId);
715      Sz--;
716    }
717    void DelNode(const int& NId) { DelNode(GetNTypeId(NId), GetLocalNId(NId)); }
718    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetTypeId(), NodeI.GetId()); }
719    TNodeI BegNI() const {
720      return TNodeI(TypeNodeV.BegI(), this);
721    }
722    TNodeI EndNI() const { return TNodeI(TypeNodeV.EndI(), this); }
723    TNodeI GetNI(const int& NId) const {
724      int NTypeId = GetNTypeId(NId);
725      int LocalNId = GetLocalNId(NId);
726      return GetNI(NTypeId, LocalNId);
727    }
728    TNodeI BegNI(const int& NTypeId) const { return TNodeI(TypeNodeV.GetI(NTypeId), this); }
729    TNodeI EndNI(const int& NTypeId) const { return TNodeI(TypeNodeV.GetI(NTypeId), TypeNodeV[NTypeId].NodeH.EndI(), this); }
730    TNodeI GetNI(const int& NTypeId, const int& NId) const {
731      return TNodeI(TypeNodeV.GetI(NTypeId), TypeNodeV[NTypeId].NodeH.GetI(NId), this);
732    }
733    void GetNIdV(TIntV& NIdV) const {
734      NIdV.Gen(GetNodes(), 0);
735      for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
736        NIdV.Add(NI.GetId());
737      }
738    }
739    int AddEType(const TStr& ETypeName, const TStr& SrcNTypeName, const TStr& DstNTypeName) {
740      int KeyId = ETypeH.GetKeyId(ETypeName);
741      if (KeyId == -1) {
742        int ETypeId = ETypeH.Len();
743        ETypeH.AddDat(ETypeName, ETypeId);
744        InETypes[GetNTypeId(DstNTypeName)].Add(ETypeId);
745        OutETypes[GetNTypeId(SrcNTypeName)].Add(ETypeId);
746        EdgeSzV.Reserve(ETypeId+1, ETypeId+1);
747        EdgeSzV[ETypeId] = 0;
748        return ETypeId;
749      } else {
750        TStr TempKey;
751        int ETypeId;
752        ETypeH.GetKeyDat(KeyId, TempKey, ETypeId);
753        return ETypeId;
754      }
755    }
756    int GetETypeId(const TStr& ETypeStr) { return ETypeH.GetDat(ETypeStr); }
757    int GetMxEId() const { return MxEId; }
758    int GetEdges() const { return EdgeH.Len(); }
759    int GetEdges(const int& ETypeId) const { return EdgeSzV[ETypeId].Val; }
760    int AddEdge(const int& SrcNId, const int& DstNId, const int& ETypeId, int EId  = -1) {
761      if (EId == -1) { EId = MxEId;  MxEId++; }
762      else { MxEId = TMath::Mx(EId+1, MxEId()); }
763      IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
764      IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
765      EdgeH.AddDat(EId, TEdge(ETypeId, EId, SrcNId, DstNId));
766      GetNode(SrcNId).AddOutNbr(ETypeId, EId);
767      GetNode(DstNId).AddInNbr(ETypeId, EId);
768      EdgeSzV[ETypeId] += 1;
769      return EId;
770    }
771    int AddEdge(const int& SrcNId, const int& DstNId, const TStr& ETypeStr) { return AddEdge(SrcNId, DstNId, GetETypeId(ETypeStr)); }
772    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetTypeId(), EdgeI.GetId()); }
773    void DelEdge(const int& EId) {
774      IAssert(IsEdge(EId));
775      TEdge Edge = GetEdge(EId);
776      int ETypeId = Edge.GetTypeId();
777      const int SrcNId = Edge.GetSrcNId();
778      const int DstNId = Edge.GetDstNId();
779      GetNode(SrcNId).DelOutNbr(ETypeId, EId);
780      GetNode(DstNId).DelInNbr(ETypeId, EId);
781      EdgeH.DelKey(EId);
782      EdgeSzV[ETypeId] -= 1;
783    }
784    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) {
785      int EId;
786      IAssert(IsEdge(SrcNId, DstNId, EId, IsDir)); 
787      while (IsEdge(SrcNId, DstNId, EId, IsDir)) {
788        DelEdge(EId);
789      }
790    }
791    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
792    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId; return IsEdge(SrcNId, DstNId, EId, IsDir); }
793    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const {
794      const TNode& SrcNode = GetNode(SrcNId);
795      for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
796        const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
797        if (DstNId == Edge.GetDstNId()) {
798          EId = Edge.GetId();
799          return true;
800        }
801      }
802      if (! IsDir) {
803        for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
804          const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
805          if (DstNId == Edge.GetSrcNId()) {
806            EId = Edge.GetId();
807            return true;
808          }
809        }
810      }
811      return false;
812    }
813    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
814    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
815    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
816    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
817    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
818    int GetRndNId(TRnd& Rnd=TInt::Rnd) {
819      int RandN = Rnd.GetUniDevInt(Sz);
820      int Ct = 0;
821      int NTypeId = 0;
822      for (; NTypeId < TypeNodeV.Len(); NTypeId++) {
823        Ct += TypeNodeV[NTypeId].NodeH.Len();
824        if (Ct > RandN) { break; }
825      }
826      return GetRndNId(NTypeId, Rnd);
827    }
828    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
829    int GetRndNId(const int& NTypeId, TRnd& Rnd=TInt::Rnd) {
830      return TypeNodeV[NTypeId].NodeH.GetKey(TypeNodeV[NTypeId].NodeH.GetRndKeyId(Rnd, 0.8));
831    }
832    TNodeI GetRndNI(const int& NTypeId, TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(NTypeId, Rnd)); }
833    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
834    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
835    TPt<TMNet<TNode> > GetSubGraph(const TIntV& NTypeIdV) {
836      TPt<TMNet<TNode> > PNewGraph = New();
837      TMNet<TNode>& NewGraph = *PNewGraph;
838      TIntSet NTypeIdSet(NTypeIdV);
839      for (typename THash<TStr,int>::TIter iter = NTypeH.BegI(); iter < NTypeH.EndI(); iter++) {
840        if (NTypeIdSet.IsKey(TInt(iter.GetDat()))) { NewGraph.NTypeH.AddDat(iter.GetKey(), iter.GetDat()); }
841      }
842      TIntIntH EdgeCounter;
843      for (int i = 0; i < InETypes.Len(); i++) {
844        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
845        for (int j = 0; j < InETypes[i].Len(); j++) {
846          EdgeCounter.AddDat(InETypes[i][j], TInt(1));
847        }
848      }
849      for (int i = 0; i < OutETypes.Len(); i++) {
850        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
851        for (int j = 0; j < OutETypes[i].Len(); j++) {
852          if (EdgeCounter.IsKey(OutETypes[i][j])) { EdgeCounter.AddDat(OutETypes[i][j], TInt(2)); }
853        }
854      }
855      TIntSet ETypeIdSet;
856      for (typename TIntIntH::TIter iter = EdgeCounter.BegI(); iter < EdgeCounter.EndI(); iter++) {
857        if (iter.GetDat().Val == 2) { ETypeIdSet.AddKey(iter.GetKey()); }
858      }
859      for (typename THash<TStr,int>::TIter iter = ETypeH.BegI(); iter < ETypeH.EndI(); iter++) {
860        if (ETypeIdSet.IsKey(TInt(iter.GetDat()))) { NewGraph.ETypeH.AddDat(iter.GetKey(), iter.GetDat()); }
861      }
862      NewGraph.InETypes.Gen(InETypes.Len());
863      for (int i = 0; i < InETypes.Len(); i++) {
864        for (int j = 0; j < InETypes[i].Len(); j++) {
865          int ETypeId = InETypes[i][j];
866          if (ETypeIdSet.IsKey(ETypeId)) { NewGraph.InETypes[i].Add(ETypeId); }
867        }
868      }
869      NewGraph.OutETypes.Gen(OutETypes.Len());
870      for (int i = 0; i < OutETypes.Len(); i++) {
871        for (int j = 0; j < OutETypes[i].Len(); j++) {
872          int ETypeId = OutETypes[i][j];
873          if (ETypeIdSet.IsKey(ETypeId)) { NewGraph.OutETypes[i].Add(ETypeId); }
874        }
875      }
876      NewGraph.Sz = 0;
877      NewGraph.TypeNodeV.Gen(TypeNodeV.Len());
878      for (int NTypeId = 0; NTypeId < TypeNodeV.Len(); NTypeId++) {
879        if (NTypeIdSet.IsKey(NTypeId)) {
880          NewGraph.TypeNodeV[NTypeId] = TNodeType(TypeNodeV[NTypeId], NewGraph.InETypes[NTypeId], NewGraph.OutETypes[NTypeId]);
881          NewGraph.Sz += NewGraph.TypeNodeV[NTypeId].NodeH.Len();
882        } else {
883          NewGraph.TypeNodeV[NTypeId] = TNodeType(TypeNodeV[NTypeId].GetId(), TypeNodeV[NTypeId].GetName());
884        }
885      }
886      NewGraph.MxNId = MxNId;
887      int MaxEId = 0;
888      for (TEdgeI iter = BegEI(); iter < EndEI(); iter++) {
889        if (!ETypeIdSet.IsKey(iter.GetTypeId())) { continue; }
890        int EId = iter.GetId();
891        NewGraph.EdgeH.AddDat(EId, TEdge(iter.GetTypeId(), EId, iter.GetSrcNId(), iter.GetDstNId()));
892        if (MaxEId < EId) { MaxEId = EId; }
893      }
894      NewGraph.MxEId = MaxEId + 1;
895      return PNewGraph;
896    }
897    TPt<TMNet<TNode> > GetSubGraph(const TStrV& NTypeNameV) {
898      TIntV NTypeIdV;
899      for (int i = 0; i < NTypeNameV.Len(); i++) {
900        NTypeIdV.Add(NTypeH.GetDat(NTypeNameV[i]));
901      }
902      return GetSubGraph(NTypeIdV);
903    }
904    PNEANet GetSubGraphTNEANet(const TIntV& NTypeIdV) {
905      TIntSet NTypeIdSet(NTypeIdV);
906      TIntIntH EdgeCounter;
907      for (int i = 0; i < InETypes.Len(); i++) {
908        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
909        for (int j = 0; j < InETypes[i].Len(); j++) {
910          EdgeCounter.AddDat(InETypes[i][j], TInt(1));
911        }
912      }
913      for (int i = 0; i < OutETypes.Len(); i++) {
914        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
915        for (int j = 0; j < OutETypes[i].Len(); j++) {
916          if (EdgeCounter.IsKey(OutETypes[i][j])) { EdgeCounter.AddDat(OutETypes[i][j], TInt(2)); }
917        }
918      }
919      TIntV ETypeIdV;
920      for (typename TIntIntH::TIter iter = EdgeCounter.BegI(); iter < EdgeCounter.EndI(); iter++) {
921        if (iter.GetDat().Val == 2) {
922          ETypeIdV.Add(iter.GetKey());
923        }
924      }
925      return GetSubGraphTNEANet2(NTypeIdV, ETypeIdV);
926    }
927    PNEANet GetSubGraphTNEANet(const TIntV& NTypeIdV, const TIntV& ETypeIdV) {
928      PNEANet PNewGraph = PNEANet::New();
929      for (int i = 0; i < NTypeIdV.Len(); i++) {
930        TInt NTypeId = NTypeIdV[i];
931        for (typename THash<TInt,TNode>::TIter iter = TypeNodeV[NTypeId].NodeH.BegI(); iter < TypeNodeV[NTypeId].NodeH.EndI(); iter++) {
932          PNewGraph->AddNode(GetGlobalNId(NTypeId, iter.GetKey().Val));
933        }
934      }
935      TIntSet ETypeIdSet(ETypeIdV);
936      for (TEdgeI iter = BegEI(); iter < EndEI(); iter++) {
937        if (ETypeIdSet.IsKey(iter.GetTypeId())) {
938          PNewGraph->AddEdge(iter.GetSrcNId(), iter.GetDstNId(), iter.GetId());
939        }
940      }
941      return PNewGraph;
942    }
943    PNEANet GetSubGraphTNEANet2(const TIntV& NTypeIdV, const TIntV& ETypeIdV) {
944      PNEANet PNewGraph = PNEANet::New();
945      for (int i = 0; i < NTypeIdV.Len(); i++) {
946        TInt NTypeId = NTypeIdV[i];
947        for (typename THash<TInt,TNode>::TIter iter = TypeNodeV[NTypeId].NodeH.BegI(); iter < TypeNodeV[NTypeId].NodeH.EndI(); iter++) {
948          PNewGraph->AddNode(GetGlobalNId(NTypeId, iter.GetKey().Val));
949        }
950      }
951      TIntSet ETypeIdSet(ETypeIdV);
952      TIntV EIdV; 
953      for (int i = 0; i < NTypeIdV.Len(); i++) {
954        TInt NTypeId = NTypeIdV[i];
955        TIntV* POutETypes = &(OutETypes[NTypeId]);
956        TIntV OutETypeIdV;
957        for (TIntV::TIter iter = POutETypes->BegI(); iter < POutETypes->EndI(); iter++) {
958          if (ETypeIdSet.IsKey(*iter)) { OutETypeIdV.Add(*iter); }
959        }
960        for (typename THash<TInt,TNode>::TIter iter = TypeNodeV[NTypeId].NodeH.BegI(); iter < TypeNodeV[NTypeId].NodeH.EndI(); iter++) {
961          TNode* PNode = &(iter.GetDat());
962          for (int j = 0; j < OutETypeIdV.Len(); j++) {
963            PNode->GetOutEIdV(OutETypeIdV.GetVal(j).Val, EIdV);
964            for (int k = 0; k < EIdV.Len(); k++) {
965              TInt EId = EIdV[k];
966              PNewGraph->AddEdge(PNode->GetId(), GetEdge(EId).GetDstNId(), EId);
967            }
968          }
969        }
970      }
971      return PNewGraph;
972    }
973  #ifdef GCC_ATOMIC
974    PNEANetMP GetSubGraphTNEANetMP2(const TIntV& NTypeIdV) {
975      TStopwatch* Sw = TStopwatch::GetInstance();
976      Sw->Start(TStopwatch::ComputeETypes);
977      TIntSet NTypeIdSet(NTypeIdV);
978      TIntIntH EdgeCounter;
979      for (int i = 0; i < InETypes.Len(); i++) {
980        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
981        for (int j = 0; j < InETypes[i].Len(); j++) {
982          EdgeCounter.AddDat(InETypes[i][j], TInt(1));
983        }
984      }
985      for (int i = 0; i < OutETypes.Len(); i++) {
986        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
987        for (int j = 0; j < OutETypes[i].Len(); j++) {
988          if (EdgeCounter.IsKey(OutETypes[i][j])) { EdgeCounter.AddDat(OutETypes[i][j], TInt(2)); }
989        }
990      }
991      TIntV ETypeIdV;
992      for (typename TIntIntH::TIter iter = EdgeCounter.BegI(); iter < EdgeCounter.EndI(); iter++) {
993        if (iter.GetDat().Val == 2) {
994          ETypeIdV.Add(iter.GetKey());
995        }
996      }
997      Sw->Stop(TStopwatch::ComputeETypes);
998      return GetSubGraphTNEANetMP2(NTypeIdV, ETypeIdV);
999    }
1000    PNEANetMP GetSubGraphTNEANetMP(const TIntV& NTypeIdV, const TIntV& ETypeIdV) {
1001      TStopwatch* Sw = TStopwatch::GetInstance();
1002      Sw->Start(TStopwatch::EstimateSizes);
1003      int SubgraphSz = 0;
1004      for (TIntV::TIter iter = NTypeIdV.BegI(); iter < NTypeIdV.EndI(); iter++) {
1005        SubgraphSz += GetNodes((*iter).Val);
1006      }
1007      int SubgraphEdgeSz = 0;
1008      for (TIntV::TIter iter = ETypeIdV.BegI(); iter < ETypeIdV.EndI(); iter++) {
1009        SubgraphEdgeSz += GetEdges((*iter).Val);
1010      }
1011      Sw->Stop(TStopwatch::EstimateSizes);
1012      Sw->Start(TStopwatch::InitGraph);
1013      PNEANetMP PNewGraph = TNEANetMP::New(SubgraphSz, SubgraphEdgeSz);
1014      TIntSet ETypeIdSet(ETypeIdV);
1015      Sw->Stop(TStopwatch::InitGraph);
1016      TIntV OutETypeIdVV[NTypeIdV.Len()];
1017      TIntV InETypeIdVV[NTypeIdV.Len()];
1018      Sw->Start(TStopwatch::ExtractNbrETypes);
1019      #pragma omp parallel for schedule(static)
1020      for (int i = 0; i < NTypeIdV.Len(); i++) {
1021        TInt NTypeId = NTypeIdV[i];
1022        TIntV* POutETypes = &(OutETypes[NTypeId]);
1023        for (TIntV::TIter iter = POutETypes->BegI(); iter < POutETypes->EndI(); iter++) {
1024          if (ETypeIdSet.IsKey(*iter)) { OutETypeIdVV[i].Add(*iter); }
1025        }
1026        TIntV* PInETypes = &(InETypes[NTypeId]);
1027        for (TIntV::TIter iter = PInETypes->BegI(); iter < PInETypes->EndI(); iter++) {
1028          if (ETypeIdSet.IsKey(*iter)) { InETypeIdVV[i].Add(*iter); }
1029        }
1030      }
1031      Sw->Stop(TStopwatch::ExtractNbrETypes);
1032      TIntV Offsets(NTypeIdV.Len()+1);
1033      Offsets[0] = 0;
1034      for (int i = 0; i < NTypeIdV.Len(); i++) {
1035        Offsets[i+1] = Offsets[i] + TypeNodeV[NTypeIdV[i]].NodeH.GetMxKeyIds();
1036      }
1037      Sw->Start(TStopwatch::PopulateGraph);
1038      #pragma omp parallel for schedule(static)
1039      for (int j = 0; j < Offsets[NTypeIdV.Len()]; j++) {
1040        int i;
1041        Offsets.SearchBinLeft(j, i);
1042        THash<TInt,TNode> *NodeHPtr = &(TypeNodeV[NTypeIdV[i]].NodeH);
1043        int KeyId = j - Offsets[i];
1044        if (!NodeHPtr->IsKeyId(KeyId)) { continue; }
1045        TNode* PNode = &((*NodeHPtr)[KeyId]);
1046        int NId = PNode->GetId();
1047        TIntV EIdV;
1048        TIntV OutEIdV;
1049        for (TIntV::TIter iter = OutETypeIdVV[i].BegI(); iter < OutETypeIdVV[i].EndI(); iter++) {
1050          PNode->GetOutEIdV((*iter).Val, EIdV);
1051          OutEIdV.AddV(EIdV);
1052        }
1053        TIntV InEIdV;
1054        for (TIntV::TIter iter = InETypeIdVV[i].BegI(); iter < InETypeIdVV[i].EndI(); iter++) {
1055          PNode->GetInEIdV((*iter).Val, EIdV);
1056          InEIdV.AddV(EIdV);
1057        }
1058        PNewGraph->AddNodeWithEdges(NId, InEIdV, OutEIdV);
1059        for (TIntV::TIter iter = OutEIdV.BegI(); iter < OutEIdV.EndI(); iter++) {
1060          PNewGraph->AddEdgeUnchecked((*iter), NId, GetEdge(*iter).GetDstNId());
1061        }
1062      }
1063      Sw->Stop(TStopwatch::PopulateGraph);
1064      PNewGraph->SetNodes(SubgraphSz);
1065      PNewGraph->SetEdges(SubgraphEdgeSz);
1066      return PNewGraph;
1067    }
1068    PNEANetMP GetSubGraphTNEANetMP2(const TIntV& NTypeIdV, const TIntV& ETypeIdV) {
1069      TStopwatch* Sw = TStopwatch::GetInstance();
1070      Sw->Start(TStopwatch::EstimateSizes);
1071      int SubgraphSz = 0;
1072      for (TIntV::TIter iter = NTypeIdV.BegI(); iter < NTypeIdV.EndI(); iter++) {
1073        SubgraphSz += GetNodes((*iter).Val);
1074      }
1075      int SubgraphEdgeSz = 0;
1076      for (TIntV::TIter iter = ETypeIdV.BegI(); iter < ETypeIdV.EndI(); iter++) {
1077        SubgraphEdgeSz += GetEdges((*iter).Val);
1078      }
1079      Sw->Stop(TStopwatch::EstimateSizes);
1080      Sw->Start(TStopwatch::InitGraph);
1081      PNEANetMP PNewGraph = TNEANetMP::New(SubgraphSz, SubgraphEdgeSz);
1082      TIntSet ETypeIdSet(ETypeIdV);
1083      Sw->Stop(TStopwatch::InitGraph);
1084      for (int i = 0; i < NTypeIdV.Len(); i++) {
1085        Sw->Start(TStopwatch::ExtractNbrETypes);
1086        TInt NTypeId = NTypeIdV[i];
1087        TIntV* POutETypes = &(OutETypes[NTypeId]);
1088        TIntV OutETypeIdV;
1089        for (TIntV::TIter iter = POutETypes->BegI(); iter < POutETypes->EndI(); iter++) {
1090          if (ETypeIdSet.IsKey(*iter)) { OutETypeIdV.Add(*iter); }
1091        }
1092        TIntV* PInETypes = &(InETypes[NTypeId]);
1093        TIntV InETypeIdV;
1094        for (TIntV::TIter iter = PInETypes->BegI(); iter < PInETypes->EndI(); iter++) {
1095          if (ETypeIdSet.IsKey(*iter)) { InETypeIdV.Add(*iter); }
1096        }
1097        Sw->Stop(TStopwatch::ExtractNbrETypes);
1098        Sw->Start(TStopwatch::PopulateGraph);
1099        THash<TInt,TNode> *NodeHPtr = &(TypeNodeV[NTypeId].NodeH);
1100        #pragma omp parallel for schedule(static)
1101        for (int KeyId = 0; KeyId < NodeHPtr->GetMxKeyIds(); KeyId++) {
1102          if (!NodeHPtr->IsKeyId(KeyId)) { continue; }
1103          TIntV OutEIdV;
1104          TIntV InEIdV;
1105          TNode* PNode = &((*NodeHPtr)[KeyId]);
1106          int NId = PNode->GetId();
1107          PNode->GetOutEIdV(OutETypeIdV, OutEIdV);
1108          PNode->GetInEIdV(InETypeIdV, InEIdV);
1109          PNewGraph->AddNodeWithEdges(NId, InEIdV, OutEIdV);
1110          for (TIntV::TIter iter = OutEIdV.BegI(); iter < OutEIdV.EndI(); iter++) {
1111            PNewGraph->AddEdgeUnchecked((*iter), NId, GetEdge(*iter).GetDstNId());
1112          }
1113        }
1114        Sw->Stop(TStopwatch::PopulateGraph);
1115      }
1116      PNewGraph->SetNodes(SubgraphSz);
1117      PNewGraph->SetEdges(SubgraphEdgeSz);
1118      return PNewGraph;
1119    }
1120  #endif 
1121    friend class TPt<TMNet>;
1122  };
1123  typedef TMNet<TSVNode> TSVNet;
1124  typedef TPt<TSVNet> PSVNet;
1125  typedef TMNet<TMVNode> TMVNet;
1126  typedef TPt<TMVNet> PMVNet;
1127  typedef TMNet<TCVNode> TCVNet;
1128  typedef TPt<TCVNet> PCVNet;
1129  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mag.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "mag.h"
3  TRnd TMAGNodeSimple::Rnd = TRnd(0);
4  TRnd TMAGNodeBern::Rnd = TRnd(0);
5  TRnd TMAGNodeBeta::Rnd = TRnd(0);
6  const double TMAGAffMtx::NInf = -DBL_MAX;
7  TMAGAffMtx::TMAGAffMtx(const TFltV& SeedMatrix) : SeedMtx(SeedMatrix) {
8    MtxDim = (int) sqrt((double)SeedMatrix.Len());
9    IAssert(MtxDim*MtxDim == SeedMtx.Len());
10  }
11  TMAGAffMtx& TMAGAffMtx::operator = (const TMAGAffMtx& Kronecker) {
12    if (this != &Kronecker){
13      MtxDim=Kronecker.MtxDim;
14      SeedMtx=Kronecker.SeedMtx;
15    }
16    return *this;
17  }
18  bool TMAGAffMtx::IsProbMtx() const {
19    for (int i = 0; i < Len(); i++) {
20      if (At(i) < 0.0 || At(i) > 1.0) return false;
21    }
22    return true;
23  }
24  void TMAGAffMtx::SetRndMtx(TRnd& Rnd, const int& PrmMtxDim, const double& MinProb) {
25    MtxDim = PrmMtxDim;
26    SeedMtx.Gen(MtxDim*MtxDim);
27    for (int p = 0; p < SeedMtx.Len(); p++) {
28      do {
29        SeedMtx[p] = Rnd.GetUniDev();
30      } while (SeedMtx[p] < MinProb);
31    }
32  }
33  void TMAGAffMtx::SetEpsMtx(const double& Eps1, const double& Eps0, const int& Eps1Val, const int& Eps0Val) {
34    for (int i = 0; i < Len(); i++) {
35      double& Val = At(i);
36      if (Val == Eps1Val) Val = double(Eps1);
37      else if (Val == Eps0Val) Val = double(Eps0);
38    }
39  }
40  void TMAGAffMtx::AddRndNoise(TRnd& Rnd, const double& SDev) {
41    Dump("before");
42    double NewVal;
43    int c =0;
44    for (int i = 0; i < Len(); i++) {
45      for(c = 0; ((NewVal = At(i)*Rnd.GetNrmDev(1, SDev, 0.8, 1.2)) < 0.01 || NewVal>0.99) && c <1000; c++) { }
46      if (c < 999) { At(i) = NewVal; } else { printf("XXXXX\n"); }
47    }
48    Dump("after");
49  }
50  TStr TMAGAffMtx::GetMtxStr() const {
51    TChA ChA("[");
52    for (int i = 0; i < Len(); i++) {
53      ChA += TStr::Fmt("%g", At(i));
54      if ((i+1)%GetDim()==0 && (i+1<Len())) { ChA += "; "; }
55      else if (i+1<Len()) { ChA += " "; }
56    }
57    ChA += "]";
58    return TStr(ChA);
59  }
60  void TMAGAffMtx::GetLLMtx(TMAGAffMtx& LLMtx) {
61    LLMtx.GenMtx(MtxDim);
62    for (int i = 0; i < Len(); i++) {
63      if (At(i) != 0.0) { LLMtx.At(i) = log(At(i)); }
64      else { LLMtx.At(i) = NInf; }
65    }
66  }
67  void TMAGAffMtx::GetProbMtx(TMAGAffMtx& ProbMtx) {
68    ProbMtx.GenMtx(MtxDim);
69    for (int i = 0; i < Len(); i++) {
70      if (At(i) != NInf) { ProbMtx.At(i) = exp(At(i)); }
71      else { ProbMtx.At(i) = 0.0; }
72    }
73  }
74  void TMAGAffMtx::Swap(TMAGAffMtx& Mtx) {
75    ::Swap(MtxDim, Mtx.MtxDim);
76    SeedMtx.Swap(Mtx.SeedMtx);
77  }
78  double TMAGAffMtx::GetMtxSum() const {
79    double Sum = 0;
80    for (int i = 0; i < Len(); i++) {
81      Sum += At(i); }
82    return Sum;
83  }
84  double TMAGAffMtx::GetRowSum(const int& RowId) const {
85    double Sum = 0;
86    for (int c = 0; c < GetDim(); c++) {
87      Sum += At(RowId, c); }
88    return Sum;
89  }
90  double TMAGAffMtx::GetColSum(const int& ColId) const {
91    double Sum = 0;
92    for (int r = 0; r < GetDim(); r++) {
93      Sum += At(r, ColId); }
94    return Sum;
95  }
96  double TMAGAffMtx::Normalize() {
97  	double Sum = GetMtxSum();
98  	if(Sum == 0) {
99  		return 0;
100  	}
101  	for(int i = 0; i < Len(); i++) {
102  		At(i) = At(i) / Sum;
103  	}
104  	return Sum;
105  }
106  void TMAGAffMtx::Dump(const TStr& MtxNm, const bool& Sort) const {
107    if (! MtxNm.Empty()) printf("%s\n", MtxNm.CStr());
108    double Sum=0.0;
109    TFltV ValV = SeedMtx;
110    if (Sort) { ValV.Sort(false); }
111    for (int i = 0; i < ValV.Len(); i++) {
112      printf("  %10.4g", ValV[i]());
113      Sum += ValV[i];
114      if ((i+1) % GetDim() == 0) { printf("\n"); }
115    }
116    printf(" (sum:%.4f)\n", Sum);
117  }
118  double TMAGAffMtx::GetAvgAbsErr(const TMAGAffMtx& Mtx1, const TMAGAffMtx& Mtx2) {
119    TFltV P1 = Mtx1.GetMtx();
120    TFltV P2 = Mtx2.GetMtx();
121    IAssert(P1.Len() == P2.Len());
122    P1.Sort();  P2.Sort();
123    double delta = 0.0;
124    for (int i = 0; i < P1.Len(); i++) {
125      delta += fabs(P1[i] - P2[i]);
126    }
127    return delta/P1.Len();
128  }
129  double TMAGAffMtx::GetAvgFroErr(const TMAGAffMtx& Mtx1, const TMAGAffMtx& Mtx2) {
130    TFltV P1 = Mtx1.GetMtx();
131    TFltV P2 = Mtx2.GetMtx();
132    IAssert(P1.Len() == P2.Len());
133    P1.Sort();  P2.Sort();
134    double delta = 0.0;
135    for (int i = 0; i < P1.Len(); i++) {
136      delta += pow(P1[i] - P2[i], 2);
137    }
138    return sqrt(delta/P1.Len());
139  }
140  TMAGAffMtx TMAGAffMtx::GetMtx(TStr MatlabMtxStr) {
141    TStrV RowStrV, ColStrV;
142    MatlabMtxStr.ChangeChAll(',', ' ');
143    MatlabMtxStr.SplitOnAllCh(';', RowStrV);  IAssert(! RowStrV.Empty());
144    RowStrV[0].SplitOnWs(ColStrV);    IAssert(! ColStrV.Empty());
145    const int Rows = RowStrV.Len();
146    const int Cols = ColStrV.Len();
147    IAssert(Rows == Cols);
148    TMAGAffMtx Mtx(Rows);
149    for (int r = 0; r < Rows; r++) {
150      RowStrV[r].SplitOnWs(ColStrV);
151      IAssert(ColStrV.Len() == Cols);
152      for (int c = 0; c < Cols; c++) {
153        Mtx.At(r, c) = (double) ColStrV[c].GetFlt(); }
154    }
155    return Mtx;
156  }
157  TMAGAffMtx TMAGAffMtx::GetRndMtx(TRnd& Rnd, const int& Dim, const double& MinProb) {
158    TMAGAffMtx Mtx;
159    Mtx.SetRndMtx(Rnd, Dim, MinProb);
160    return Mtx;
161  }
162  void TMAGNodeSimple::AttrGen(TIntVV& AttrVV, const int& NNodes) {
163  	IAssert(Dim > 0);
164  	AttrVV.Gen(NNodes, Dim);
165  	AttrVV.PutAll(0);
166  	for(int i = 0; i < NNodes; i++) {
167  		for(int l = 0; l < Dim; l++) {
168  			if((TMAGNodeSimple::Rnd).GetUniDev() > Mu) {
169  				AttrVV.At(i, l) = 1;
170  			}
171  		}
172  	}
173  }
174  void TMAGNodeSimple::LoadTxt(const TStr& InFNm) {
175  	FILE *fp = fopen(InFNm.CStr(), "r");
176  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
177  	char buf[128];
178  	char *token;
179  	TStr TokenStr;
180  	TFlt Val;
181  	token = strtok(buf, "&");
182  	token = strtok(token, " \t");
183  	TokenStr = TStr(token);
184  	Mu = TokenStr.GetFlt(Val);
185  	fclose(fp);
186  }
187  void TMAGNodeSimple::SaveTxt(TStrV& OutStrV) const {
188  	OutStrV.Gen(Dim, 0);
189  	for(int i = 0; i < Dim; i++) {
190  		OutStrV.Add(TStr::Fmt("%f", double(Mu)));
191  	}
192  }
193  TMAGNodeBern& TMAGNodeBern::operator=(const TMAGNodeBern& Dist) {
194  	MuV = Dist.MuV;
195  	Dim = Dist.Dim;
196  	return (*this);
197  }
198  void TMAGNodeBern::AttrGen(TIntVV& AttrVV, const int& NNodes) {
199  	IAssert(Dim > 0);
200  	AttrVV.Gen(NNodes, Dim);
201  	AttrVV.PutAll(0);
202  	for(int i = 0; i < NNodes; i++) {
203  		for(int l = 0; l < Dim; l++) {
204  			if((TMAGNodeBern::Rnd).GetUniDev() > MuV[l]) {
205  				AttrVV.At(i, l) = 1;
206  			}
207  		}
208  	}
209  }
210  void TMAGNodeBern::LoadTxt(const TStr& InFNm) {
211  	FILE *fp = fopen(InFNm.CStr(), "r");
212  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
213  	Dim = 0;
214  	MuV.Gen(10, 0);
215  	char buf[128];
216  	char *token;
217  	TStr TokenStr;
218  	TFlt Val;
219  	while(fgets(buf, sizeof(buf), fp) != NULL) {
220  		token = strtok(buf, "&");
221  		token = strtok(token, " \t");
222  		TokenStr = TStr(token);
223  		MuV.Add(TokenStr.GetFlt(Val));
224  	}
225  	Dim = MuV.Len();
226  	fclose(fp);
227  }
228  void TMAGNodeBern::SaveTxt(TStrV& OutStrV) const {
229  	OutStrV.Gen(Dim, 0);
230  	for(int i = 0; i < Dim; i++) {
231  		OutStrV.Add(TStr::Fmt("%f", double(MuV[i])));
232  	}
233  }
234  TMAGNodeBeta& TMAGNodeBeta::operator=(const TMAGNodeBeta& Dist) {
235  	AlphaV = Dist.AlphaV;
236  	BetaV = Dist.BetaV;
237  	Dim = Dist.Dim;
238  	MuV = Dist.MuV;
239  	Dirty = Dist.Dirty;
240  	return (*this);
241  }
242  void TMAGNodeBeta::SetBeta(const int& Attr, const double& Alpha, const double& Beta) {
243  	IAssert(Attr < Dim);
244  	AlphaV[Attr] = Alpha;
245  	BetaV[Attr] = Beta;
246  	Dirty = true;
247  }
248  void TMAGNodeBeta::SetBetaV(const TFltV& _AlphaV, const TFltV& _BetaV) {
249  	IAssert(_AlphaV.Len() == _BetaV.Len());
250  	AlphaV = _AlphaV;
251  	BetaV = _BetaV;
252  	Dim = _AlphaV.Len();
253  	Dirty = true;
254  }
255  void TMAGNodeBeta::AttrGen(TIntVV& AttrVV, const int& NNodes) {
256  	IAssert(Dim > 0);
257  	AttrVV.Gen(NNodes, Dim);
258  	AttrVV.PutAll(0);
259  	for(int i = 0; i < NNodes; i++) {
260  		for(int l = 0; l < Dim; l++) {
261  			double x = TMAGNodeBeta::Rnd.GetGammaDev((int)AlphaV[l]);
262  			double y = TMAGNodeBeta::Rnd.GetGammaDev((int)BetaV[l]);
263  			MuV[l] = x / (x + y);
264  			if((TMAGNodeBeta::Rnd).GetUniDev() > MuV[l]) {
265  				AttrVV.At(i, l) = 1;
266  			}
267  		}
268  	}
269  	Dirty = false;
270  }
271  void TMAGNodeBeta::LoadTxt(const TStr& InFNm) {
272  	FILE *fp = fopen(InFNm.CStr(), "r");
273  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
274  	Dim = 0;
275  	AlphaV.Gen(10, 0);
276  	BetaV.Gen(10, 0);
277  	char buf[128];
278  	char *token;
279  	TStr TokenStr;
280  	TFlt Val;
281  	while(fgets(buf, sizeof(buf), fp) != NULL) {
282  		token = strtok(buf, "&");
283  		token = strtok(token, " \t");
284  		TokenStr = TStr(token);
285  		AlphaV.Add(TokenStr.GetFlt(Val));
286  		token = strtok(NULL, " \t");
287  		TokenStr = TStr(token);
288  		BetaV.Add(TokenStr.GetFlt(Val));
289  		Dim++;
290  	}
291  	fclose(fp);
292  }
293  void TMAGNodeBeta::SaveTxt(TStrV& OutStrV) const {
294  	OutStrV.Gen(Dim, 0);
295  	for(int i = 0; i < Dim; i++) {
296  		OutStrV.Add(TStr::Fmt("%f %f", double(AlphaV[i]), double(BetaV[i])));
297  	}
298  }
299  void TMAGFitBern::SetGraph(const PNGraph& GraphPt) {
300  	Graph = GraphPt;
301  	bool NodesOk = true;
302  	for (int nid = 0; nid < Graph->GetNodes(); nid++) {
303  	if (! Graph->IsNode(nid)) { NodesOk=false; break; } }
304  	if (! NodesOk) {
305  	TIntV NIdV;  GraphPt->GetNIdV(NIdV);
306  	Graph = TSnap::GetSubGraph(GraphPt, NIdV, true);
307  	for (int nid = 0; nid < Graph->GetNodes(); nid++) {
308  	  IAssert(Graph->IsNode(nid)); }
309  	}
310  }
311  void TMAGFitBern::SetPhiVV(const TIntVV& AttrVV, const int KnownIds) {
312  	const int NNodes = Param.GetNodes();
313  	const int NAttrs = Param.GetAttrs();
314  	PhiVV.Gen(NNodes, NAttrs);
315  	KnownVV.Gen(NNodes, NAttrs);
316  	for(int l = 0; l < NAttrs; l++) {
317  		for(int i = 0; i < NNodes; i++) {
318  			if(int(AttrVV(i, l)) == 0) {
319  				PhiVV(i, l) = 0.9999;
320  			} else {
321  				PhiVV(i, l) = 0.0001;
322  			}
323  		}
324  		if(l < KnownIds) {
325  			KnownVV.PutY(l, true);
326  		} else {
327  			KnownVV.PutY(l, false);
328  		}
329  	}
330  }
331  void TMAGFitBern::SaveTxt(const TStr& FNm) {
332  	const int NNodes = Param.GetNodes();
333  	const int NAttrs = Param.GetAttrs();
334  	const TFltV MuV = GetMuV();
335  	TMAGAffMtxV MtxV;
336  	Param.GetMtxV(MtxV);
337  	FILE *fp = fopen(FNm.GetCStr(), "w");
338  	for(int l = 0; l < NAttrs; l++) {
339  		fprintf(fp, "%.4f\t", double(MuV[l]));
340  		for(int row = 0; row < 2; row++) {
341  			for(int col = 0; col < 2; col++) {
342  				fprintf(fp, " %.4f", double(MtxV[l].At(row, col)));
343  			}
344  			fprintf(fp, (row == 0) ? ";" : "\n");
345  		}
346  	}
347  	fclose(fp);
348  	fp = fopen((FNm + "f").CStr(), "w");
349  	for(int i = 0; i < NNodes; i++) {
350  		for(int l = 0; l < NAttrs; l++) {
351  			fprintf(fp, "%f ", double(PhiVV(i, l)));
352  		}
353  		fprintf(fp, "\n");
354  	}
355  	fclose(fp);
356  }
357  void TMAGFitBern::Init(const TFltV& MuV, const TMAGAffMtxV& AffMtxV) {
358  	TMAGNodeBern DistParam(MuV);
359  	Param.SetNodeAttr(DistParam);
360  	Param.SetMtxV(AffMtxV);
361  	const int NNodes = Param.GetNodes();
362  	const int NAttrs = Param.GetAttrs();
363  	PhiVV.Gen(NNodes, NAttrs);
364  	KnownVV.Gen(NNodes, NAttrs);
365  	KnownVV.PutAll(false);
366  }
367  #if 0
368  void TMAGFitBern::PerturbInit(const TFltV& MuV, const TMAGAffMtxV& AffMtxV, const double& PerturbRate) {
369  	IAssert(PerturbRate < 1.0);
370  	TFltV InitMuV = MuV;	
371  	TMAGNodeBern DistParam(InitMuV);
372  	Param.SetMtxV(AffMtxV);
373  	TRnd& Rnd = TMAGNodeBern::Rnd;
374  	TMAGAffMtxV PerturbMtxV = AffMtxV;
375  	const int NNodes = Param.GetNodes();
376  	const int NAttrs = Param.GetAttrs();
377  	for(int l = 0; l < NAttrs; l++) {
378  		double Mu = MuV[l] + PerturbRate * (Rnd.GetUniDev() - 0.5) * 2;
379  		if(Mu < 0.01) {  Mu = 0.01;  }
380  		if(Mu > 0.99) {  Mu = 0.99;  }
381  		DistParam.SetMu(l, Mu);
382  		TMAGAffMtx AffMtx(AffMtxV[l]);
383  		for(int p = 0; p < 4; p++) {
384  			AffMtx.At(p) += PerturbRate * (Rnd.GetUniDev() - 0.5) * 2;
385  			if(AffMtx.At(p) < 0.05) {  AffMtx.At(p) = 0.05;  }
386  			if(AffMtx.At(p) > 0.95) {  AffMtx.At(p) = 0.95;  }
387  		}
388  		AffMtx.At(0, 1) = AffMtx.At(1, 0);
389  		PerturbMtxV[l] = AffMtx;
390  	}
391  	printf("\n");
392  	for(int l = 0; l < NAttrs; l++) {
393  		printf("Mu = %.3f  ", DistParam.GetMu(l));
394  		printf("AffMtx = %s\n", PerturbMtxV[l].GetMtxStr().GetCStr());
395  	}
396  	Param.SetMtxV(PerturbMtxV);
397  	Param.SetNodeAttr(DistParam);
398  	PhiVV.Gen(NNodes, NAttrs);
399  	KnownVV.Gen(NNodes, NAttrs);
400  	KnownVV.PutAll(false);
401  }
402  #endif	
403  void TMAGFitBern::RandomInit(const TFltV& MuV, const TMAGAffMtxV& AffMtxV, const int& Seed) {
404  	TRnd& Rnd = TMAGNodeBern::Rnd;
405  	Rnd.PutSeed(Seed);
406  	TFltV InitMuV = MuV;	InitMuV.PutAll(0.5);
407  	TMAGNodeBern DistParam(InitMuV);
408  	Param.SetMtxV(AffMtxV);
409  	const int NNodes = Param.GetNodes();
410  	const int NAttrs = Param.GetAttrs();
411  	PhiVV.Gen(NNodes, NAttrs);
412  	KnownVV.Gen(NNodes, NAttrs);
413  	KnownVV.PutAll(false);
414  	for(int i = 0; i < NNodes; i++) {
415  		for(int l = 0; l < NAttrs; l++) {
416  			PhiVV.At(i, l) = Rnd.GetUniDev();
417  		}
418  	}
419  	TMAGAffMtxV RndMtxV = AffMtxV;
420  	for(int l = 0; l < NAttrs; l++) {
421  		for(int p = 0; p < 4; p++) {
422  			RndMtxV[l].At(p) = TMAGNodeBern::Rnd.GetUniDev();
423  			if(RndMtxV[l].At(p) < 0.1) {  RndMtxV[l].At(p) = 0.1;  }
424  			if(RndMtxV[l].At(p) > 0.9) {  RndMtxV[l].At(p) = 0.9;  }
425  		}
426  		RndMtxV[l].At(0, 1) = RndMtxV[l].At(1, 0);
427  	}
428  	printf("\n");
429  	for(int l = 0; l < NAttrs; l++) {
430  		printf("AffMtx = %s\n", RndMtxV[l].GetMtxStr().GetCStr());
431  	}
432  	Param.SetMtxV(RndMtxV);
433  	Param.SetNodeAttr(DistParam);
434  }
435  const double TMAGFitBern::GetInCoeff(const int& i, const int& j, const int& l, const int& A, const TMAGAffMtx& Theta) const {
436  	return (PhiVV.At(i, l) * Theta.At(0, A) + (1.0 - PhiVV.At(i, l)) * Theta.At(1, A));
437  }
438  const double TMAGFitBern::GetOutCoeff(const int& i, const int& j, const int& l, const int& A, const TMAGAffMtx& Theta) const {
439  	return (PhiVV.At(j, l) * Theta.At(A, 0) + (1.0 - PhiVV.At(j, l)) * Theta.At(A, 1));
440  }
441  const double TMAGFitBern::GetAvgInCoeff(const int& i, const int& AId, const int& A, const TMAGAffMtx& Theta) const {
442  	const int NNodes = Param.GetNodes();
443  	const double Mu_l = AvgPhiV[AId] / double(NNodes);
444  	return (Mu_l * Theta.At(0, A) + (1.0 - Mu_l) * Theta.At(1, A));
445  }
446  const double TMAGFitBern::GetAvgOutCoeff(const int& i, const int& AId, const int& A, const TMAGAffMtx& Theta) const {
447  	const int NNodes = Param.GetNodes();
448  	const double Mu_l = AvgPhiV[AId] / double(NNodes);
449  	return (Mu_l * Theta.At(A, 0) + (1.0 - Mu_l) * Theta.At(A, 1));
450  }
451  const double TMAGFitBern::GetProbPhi(const int& NId1, const int& NId2, const int& AId, const int& Attr1, const int& Attr2) const {
452  	double Prob1 = (Attr1 == 0) ? double(PhiVV.At(NId1, AId)) : (1.0 - PhiVV.At(NId1, AId));
453  	double Prob2 = (Attr2 == 0) ? double(PhiVV.At(NId2, AId)) : (1.0 - PhiVV.At(NId2, AId));
454  	return (Prob1 * Prob2);
455  }
456  const double TMAGFitBern::GetProbMu(const int& NId1, const int& NId2, const int& AId, const int& Attr1, const int& Attr2, const bool Left, const bool Right) const {
457  	TMAGNodeBern DistParam = Param.GetNodeAttr();
458  	double Mu = AvgPhiV[AId] / double(Param.GetNodes());
459  	double Prob1 = (Left) ? double(PhiVV.At(NId1, AId)) : double(Mu);
460  	double Prob2 = (Right)? double(PhiVV.At(NId2, AId)) : double(Mu);
461  	Prob1 = (Attr1 == 0) ? Prob1 : 1.0 - Prob1;
462  	Prob2 = (Attr2 == 0) ? Prob2 : 1.0 - Prob2;
463  	return (Prob1 * Prob2);
464  }
465  const double TMAGFitBern::GetThetaLL(const int& NId1, const int& NId2, const int& AId) const {
466  	double LL = 0.0;
467  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
468  	for(int A1 = 0; A1 < 2; A1++) {
469  		for(int A2 = 0; A2 < 2; A2++) {
470  			LL += GetProbPhi(NId1, NId2, AId, A1, A2) * Mtx.At(A1, A2);
471  		}
472  	}
473  	return log(LL);
474  }
475  const double TMAGFitBern::GetAvgThetaLL(const int& NId1, const int& NId2, const int& AId, const bool Left, const bool Right) const {
476  	double LL = 0.0;
477  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
478  	for(int A1 = 0; A1 < 2; A1++) {
479  		for(int A2 = 0; A2 < 2; A2++) {
480  			LL += GetProbMu(NId1, NId2, AId, A1, A2, Left, Right) * Mtx.At(A1, A2);
481  		}
482  	}
483  	return log(LL);
484  }
485  const double TMAGFitBern::GetSqThetaLL(const int& NId1, const int& NId2, const int& AId) const {
486  	double LL = 0.0;
487  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
488  	for(int A1 = 0; A1 < 2; A1++) {
489  		for(int A2 = 0; A2 < 2; A2++) {
490  			LL += GetProbPhi(NId1, NId2, AId, A1, A2) * Mtx.At(A1, A2) * Mtx.At(A1, A2);
491  		}
492  	}
493  	return log(LL);
494  }
495  const double TMAGFitBern::GetAvgSqThetaLL(const int& NId1, const int& NId2, const int& AId, const bool Left, const bool Right) const {
496  	double LL = 0.0;
497  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
498  	for(int A1 = 0; A1 < 2; A1++) {
499  		for(int A2 = 0; A2 < 2; A2++) {
500  			LL += GetProbMu(NId1, NId2, AId, A1, A2, Left, Right) * Mtx.At(A1, A2) * Mtx.At(A1, A2);
501  		}
502  	}
503  	return log(LL);
504  }
505  const double TMAGFitBern::GetProdLinWeight(const int& NId1, const int& NId2) const {
506  	const int NAttrs = Param.GetAttrs();
507  	double LL = 0.0;
508  	for(int l = 0; l < NAttrs; l++) {
509  		LL += GetThetaLL(NId1, NId2, l);
510  	}
511  	return LL + log(NormConst);
512  }
513  const double TMAGFitBern::GetAvgProdLinWeight(const int& NId1, const int& NId2, const bool Left, const bool Right) const {
514  	const int NAttrs = Param.GetAttrs();
515  	double LL = 0.0;
516  	for(int l = 0; l < NAttrs; l++) {
517  		LL += GetAvgThetaLL(NId1, NId2, l, Left, Right);
518  	}
519  	return LL + log(NormConst);
520  }
521  const double TMAGFitBern::GetProdSqWeight(const int& NId1, const int& NId2) const {
522  	const int NAttrs = Param.GetAttrs();
523  	double LL = 0.0;
524  	for(int l = 0; l < NAttrs; l++) {
525  		LL += GetSqThetaLL(NId1, NId2, l);
526  	}
527  	return LL + 2 * log(NormConst);
528  }
529  const double TMAGFitBern::GetAvgProdSqWeight(const int& NId1, const int& NId2, const bool Left, const bool Right) const {
530  	const int NAttrs = Param.GetAttrs();
531  	double LL = 0.0;
532  	for(int l = 0; l < NAttrs; l++) {
533  		LL += GetAvgSqThetaLL(NId1, NId2, l, Left, Right);
534  	}
535  	return LL + 2 * log(NormConst);
536  }
537  const double LogSumExp(const double LogVal1, const double LogVal2) {
538  	double MaxExp = (LogVal1 > LogVal2) ? LogVal1 : LogVal2;
539  	double Sum = exp(LogVal1 - MaxExp) + exp(LogVal2 - MaxExp);
540  	return (log(Sum) + MaxExp);
541  }
542  const double LogSumExp(const TFltV& LogValV) {
543  	const int Len = LogValV.Len();
544  	double MaxExp = -DBL_MAX;
545  	for(int i = 0; i < Len; i++) {
546  		if(MaxExp < LogValV[i]) {  MaxExp = LogValV[i];  }
547  	}
548  	double Sum = 0.0;
549  	for(int i = 0; i < Len; i++) {
550  		Sum += exp(LogValV[i] - MaxExp);
551  	}
552  	return (log(Sum) + MaxExp);
553  }
554  const double LogSumExp(const double *LogValArray, const int Len) {
555  	TFltV TmpV(Len);
556  	for(int i = 0; i < Len; i++) {  TmpV[i] = LogValArray[i];  }
557  	return LogSumExp(TmpV);
558  }
559  const double TMAGFitBern::GradPhiMI(const double& x, const int& NId, const int& AId, const double& Lambda, const double& DeltaQ, const TFltVV& CntVV) {
560  	const int NAttrs = CntVV.GetYDim();
561  	double Grad = DeltaQ - log(x) + log(1.0-x);
562  	for(int l = 0; l < NAttrs; l++) {
563  		if(l == AId) {  continue;  }
564  		const double C0 = PhiVV(NId, l);
565  		const double C1 = 1.0 - C0;
566  		Grad -= Lambda * C0 * log(CntVV(0, l) + C0 * x);
567  		Grad -= Lambda * C1 * log(CntVV(1, l) + C1 * x);
568  		Grad += Lambda * C0 * log(CntVV(2, l) + C0 * (1-x));
569  		Grad += Lambda * C1 * log(CntVV(3, l) + C1 * (1-x));
570  		Grad -= Lambda * log(CntVV(0, l) + CntVV(1, l) + x);
571  		Grad += Lambda * log(CntVV(2, l) + CntVV(3, l) + (1-x));
572  	}
573  	return Grad;
574  }
575  const double TMAGFitBern::ObjPhiMI(const double& x, const int& NId, const int& AId, const double& Lambda, const double& Q0, const double& Q1, const TFltVV& CntVV) {
576  	const int NAttrs = CntVV.GetYDim();
577  	double Val = x*(Q0 - log(x)) + (1-x)*(Q1 - log(1.0-x));
578  	for(int l = 0; l < NAttrs; l++) {
579  		if(l == AId) {  continue;  }
580  		const double C0 = PhiVV(NId, l);
581  		const double C1 = 1.0 - C0;
582  		Val -= Lambda * (CntVV(0, l) + C0 * x) * log(CntVV(0, l) + C0 * x);
583  		Val -= Lambda * (CntVV(1, l) + C1 * x) * log(CntVV(1, l) + C1 * x);
584  		Val -= Lambda * (CntVV(2, l) + C0 * (1-x)) * log(CntVV(2, l) + C0 * (1-x));
585  		Val -= Lambda * (CntVV(3, l) + C1 * (1-x)) * log(CntVV(3, l) + C1 * (1-x));
586  		Val += Lambda * (CntVV(0, l) + CntVV(1, l) + x) * log(CntVV(0, l) + CntVV(1, l) + x);
587  		Val += Lambda * (CntVV(2, l) + CntVV(3, l) + 1 - x) * log(CntVV(2, l) + CntVV(3, l) + (1-x));
588  		if(!(CntVV(0, l) > 0))	printf("CntVV(0, %d) = %.2f\n", l, double(CntVV(0, l)));
589  		if(!(CntVV(1, l) > 0))	printf("CntVV(1, %d) = %.2f\n", l, double(CntVV(1, l)));
590  		if(!(CntVV(2, l) > 0))	printf("CntVV(2, %d) = %.2f\n", l, double(CntVV(2, l)));
591  		if(!(CntVV(3, l) > 0))	printf("CntVV(3, %d) = %.2f\n", l, double(CntVV(3, l)));
592  	}
593  	return Val;
594  }
595  const double TMAGFitBern::GetEstNoEdgeLL(const int& NId, const int& AId) const {
596  	TMAGNodeBern DistParam = Param.GetNodeAttr();
597  	double LL = 0.0;
598  	return LL;
599  }
600  const double TMAGFitBern::UpdatePhi(const int& NId, const int& AId, double& Phi) {
601  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
602  	TMAGAffMtx SqTheta(Theta);
603  	const int NNodes = Param.GetNodes();
604  	Theta.GetLLMtx(LLTheta);
605  	TMAGNodeBern DistParam = Param.GetNodeAttr();
606  	const double Mu = DistParam.GetMu(AId);
607  	for(int i = 0; i < Theta.Len(); i++) {
608  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
609  	}
610  	double EdgeQ[2], NonEdgeQ[2], MaxExp[2];
611  	TFltV NonEdgeLLV[2];
612  	for(int i = 0; i < 2; i++) {
613  		EdgeQ[i] = 0.0;
614  		NonEdgeQ[i] = 0.0;
615  		MaxExp[i] = -DBL_MAX;
616  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
617  	}
618  	for(int j = 0; j < NNodes; j++) {
619  		if(j == NId) {	continue;	}
620  		if(Graph->IsEdge(NId, j)) {
621  			EdgeQ[0] += GetOutCoeff(NId, j, AId, 0, LLTheta);
622  			EdgeQ[1] += GetOutCoeff(NId, j, AId, 1, LLTheta);
623  		} else {
624  			double LinW = GetProdLinWeight(NId, j) - GetThetaLL(NId, j, AId);
625  			double SqW = GetProdSqWeight(NId, j) - GetSqThetaLL(NId, j, AId);
626  			for(int i = 0; i < 2; i++) {
627  				NonEdgeLLV[i].Add(LinW + log(GetOutCoeff(NId, j, AId, i, Theta)));
628  				NonEdgeLLV[i].Add(SqW + log(GetOutCoeff(NId, j, AId, i, SqTheta)) + log(0.5));
629  			}
630  		}
631  		if(Graph->IsEdge(j, NId)) {
632  			EdgeQ[0] += GetInCoeff(j, NId, AId, 0, LLTheta);
633  			EdgeQ[1] += GetInCoeff(j, NId, AId, 1, LLTheta);
634  		} else {
635  			double LinW = GetProdLinWeight(j, NId) - GetThetaLL(j, NId, AId);
636  			double SqW = GetProdSqWeight(j, NId) - GetSqThetaLL(j, NId, AId);
637  			for(int i = 0; i < 2; i++) {
638  				NonEdgeLLV[i].Add(LinW + log(GetInCoeff(j, NId, AId, i, Theta)));
639  				NonEdgeLLV[i].Add(SqW + log(GetInCoeff(j, NId, AId, i, SqTheta)) + log(0.5));
640  			}
641  		}
642  	}
643  	NonEdgeQ[0] = LogSumExp(NonEdgeLLV[0]);
644  	NonEdgeQ[1] = LogSumExp(NonEdgeLLV[1]);
645  	double Q[2];
646  	Q[0] = log(Mu) + EdgeQ[0] - exp(NonEdgeQ[0]);
647  	Q[1] = log(1.0 - Mu) + EdgeQ[1] - exp(NonEdgeQ[1]);
648  	Phi = Q[0] - LogSumExp(Q, 2);
649  	Phi = exp(Phi);
650  	return Phi - PhiVV.At(NId, AId);
651  }
652  const double TMAGFitBern::UpdatePhiMI(const double& Lambda, const int& NId, const int& AId, double& Phi) {
653  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
654  	TMAGAffMtx SqTheta(Theta);
655  	const int NNodes = Param.GetNodes();
656  	const int NAttrs = Param.GetAttrs();
657  	Theta.GetLLMtx(LLTheta);
658  	TMAGNodeBern DistParam = Param.GetNodeAttr();
659  	const double Mu = DistParam.GetMu(AId);
660  	for(int i = 0; i < Theta.Len(); i++) {
661  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
662  	}
663  	double EdgeQ[2], NonEdgeQ[2], MaxExp[2];
664  	TFltV NonEdgeLLV[2];
665  	TFltVV CntVV(4, NAttrs);		CntVV.PutAll(0.0);
666  	for(int i = 0; i < 2; i++) {
667  		EdgeQ[i] = 0.0;
668  		NonEdgeQ[i] = 0.0;
669  		MaxExp[i] = -DBL_MAX;
670  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
671  	}
672  	for(int j = 0; j < NNodes; j++) {
673  		if(j == NId) {	continue;	}
674  		for(int l = 0; l < NAttrs; l++) {
675  			if(l == AId) {  continue;  }
676  			CntVV(0, l) = CntVV(0, l) + PhiVV(j, AId) * PhiVV(j, l);
677  			CntVV(1, l) = CntVV(1, l) + PhiVV(j, AId) * (1.0-PhiVV(j, l));
678  			CntVV(2, l) = CntVV(2, l) + (1.0-PhiVV(j, AId)) * PhiVV(j, l);
679  			CntVV(3, l) = CntVV(3, l) + (1.0-PhiVV(j, AId)) * (1.0-PhiVV(j, l));
680  		}
681  		if(Graph->IsEdge(NId, j)) {
682  			EdgeQ[0] += GetOutCoeff(NId, j, AId, 0, LLTheta);
683  			EdgeQ[1] += GetOutCoeff(NId, j, AId, 1, LLTheta);
684  		} else {
685  			double LinW = GetProdLinWeight(NId, j) - GetThetaLL(NId, j, AId);
686  			double SqW = GetProdSqWeight(NId, j) - GetSqThetaLL(NId, j, AId);
687  			for(int i = 0; i < 2; i++) {
688  				NonEdgeLLV[i].Add(LinW + log(GetOutCoeff(NId, j, AId, i, Theta)));
689  				NonEdgeLLV[i].Add(SqW + log(GetOutCoeff(NId, j, AId, i, SqTheta)) + log(0.5));
690  			}
691  		}
692  		if(Graph->IsEdge(j, NId)) {
693  			EdgeQ[0] += GetInCoeff(j, NId, AId, 0, LLTheta);
694  			EdgeQ[1] += GetInCoeff(j, NId, AId, 1, LLTheta);
695  		} else {
696  			double LinW = GetProdLinWeight(j, NId) - GetThetaLL(j, NId, AId);
697  			double SqW = GetProdSqWeight(j, NId) - GetSqThetaLL(j, NId, AId);
698  			for(int i = 0; i < 2; i++) {
699  				NonEdgeLLV[i].Add(LinW + log(GetInCoeff(j, NId, AId, i, Theta)));
700  				NonEdgeLLV[i].Add(SqW + log(GetInCoeff(j, NId, AId, i, SqTheta)) + log(0.5));
701  			}
702  		}
703  	}
704  	NonEdgeQ[0] = LogSumExp(NonEdgeLLV[0]);
705  	NonEdgeQ[1] = LogSumExp(NonEdgeLLV[1]);
706  	double Q[2];
707  	Q[0] = log(Mu) + EdgeQ[0] - exp(NonEdgeQ[0]);
708  	Q[1] = log(1.0 - Mu) + EdgeQ[1] - exp(NonEdgeQ[1]);
709  	double DeltaQ = Q[0] - Q[1];
710  	double x[] = {PhiVV(NId, AId)};
711  	for(int n = 0; n < 1; n++) {
712  		double LrnRate = 0.001;
713  		for(int step = 0; step < 200; step++) {
714  			double Grad = GradPhiMI(x[n], NId, AId, Lambda, DeltaQ, CntVV);
715  			if(Grad > 0.0) {  x[n] += LrnRate;  }
716  			else {  x[n] -= LrnRate;  }
717  			if(x[n] > 0.9999) {  x[n] = 0.9999;  }
718  			if(x[n] < 0.0001) {  x[n] = 0.0001;  }
719  			LrnRate *= 0.995;
720  		}
721  	}
722  	double MaxVal = -DBL_MAX;
723  	int MaxX = -1;
724  	for(int n = 0; n < 1; n++) {
725  		double Val = ObjPhiMI(x[n], NId, AId, Lambda, Q[0], Q[1], CntVV);
726  		if(Val > MaxVal) {
727  			MaxVal = Val;
728  			MaxX = n;
729  		}
730  	}
731  	IAssert(MaxX >= 0);
732  	Phi = x[MaxX];
733  	return Phi - PhiVV.At(NId, AId);
734  }
735  const double TMAGFitBern::UpdateApxPhiMI(const double& Lambda, const int& NId, const int& AId, double& Phi, TFltVV& ProdVV) {
736  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
737  	const int NNodes = Param.GetNodes();
738  	const int NAttrs = Param.GetAttrs();
739  	Theta.GetLLMtx(LLTheta);
740  	TMAGNodeBern DistParam = Param.GetNodeAttr();
741  	const double Mu = DistParam.GetMu(AId);
742  	TMAGAffMtx SqTheta(Theta);
743  	for(int i = 0; i < Theta.Len(); i++) {
744  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
745  	}
746  	TFltV ProdV;	ProdVV.GetRow(NId, ProdV);
747  	ProdV[0] -= GetAvgThetaLL(NId, NId, AId, true, false);
748  	ProdV[1] -= GetAvgThetaLL(NId, NId, AId, false, true);
749  	ProdV[2] -= log(2.0) + GetAvgSqThetaLL(NId, NId, AId, true, false);
750  	ProdV[3] -= log(2.0) + GetAvgSqThetaLL(NId, NId, AId, false, true);
751  	double EdgeQ[2], MaxExp[2];
752  	TFltV NonEdgeLLV[2];
753  	TFltVV CntVV(4, NAttrs);		CntVV.PutAll(0.0);
754  	for(int i = 0; i < 2; i++) {
755  		EdgeQ[i] = 0.0;
756  		MaxExp[i] = -DBL_MAX;
757  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
758  	}
759  	for(int F = 0; F < 2; F++) {
760  		NonEdgeLLV[F].Add(ProdV[0] + log(GetAvgOutCoeff(NId, AId, F, Theta)));
761  		NonEdgeLLV[F].Add(ProdV[1] + log(GetAvgInCoeff(NId, AId, F, Theta)));
762  		NonEdgeLLV[F].Add(ProdV[2] + log(GetAvgOutCoeff(NId, AId, F, SqTheta)));
763  		NonEdgeLLV[F].Add(ProdV[3] + log(GetAvgInCoeff(NId, AId, F, SqTheta)));
764  	}
765  	EdgeQ[0] = -(NNodes - 1) * exp(LogSumExp(NonEdgeLLV[0]));
766  	EdgeQ[1] = -(NNodes - 1) * exp(LogSumExp(NonEdgeLLV[1]));
767  	for(int l = 0; l < NAttrs; l++) {
768  		if(l == AId) {  continue;  }
769  		int BgId = (AId > l) ? AId : l;
770  		int SmId = (AId + l) - BgId;
771  		int SmL = (l < AId) ? 1 : 0;
772  		BgId *= 4;
773  		CntVV(0, l) = AvgPhiPairVV(SmId, BgId) - PhiVV(NId, AId) * PhiVV(NId, l);
774  		CntVV(1+SmL, l) = AvgPhiPairVV(SmId, BgId+1+SmL) - PhiVV(NId, AId) * (1.0-PhiVV(NId, l));
775  		CntVV(2-SmL, l) = AvgPhiPairVV(SmId, BgId+2-SmL) - (1.0-PhiVV(NId, AId)) * PhiVV(NId, l);
776  		CntVV(3, l) = AvgPhiPairVV(SmId, BgId+3) - (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, l));
777  	}
778  	TNGraph::TNodeI NI = Graph->GetNI(NId);
779  	for(int d = 0; d < NI.GetOutDeg(); d++) {
780  		int Out = NI.GetOutNId(d);
781  		if(NId == Out) {  continue;  }
782  		double LinW = GetProdLinWeight(NId, Out) - GetThetaLL(NId, Out, AId);
783  		double SqW = GetProdSqWeight(NId, Out) - GetSqThetaLL(NId, Out, AId);
784  		for(int F = 0; F < 2; F++) {
785  			EdgeQ[F] += GetOutCoeff(NId, Out, AId, F, LLTheta);
786  			EdgeQ[F] += exp(LinW + log(GetOutCoeff(NId, Out, AId, F, Theta)));
787  			EdgeQ[F] += 0.5 * exp(SqW + log(GetOutCoeff(NId, Out, AId, F, SqTheta)));
788  		}
789  	}
790  	for(int d = 0; d < NI.GetInDeg(); d++) {
791  		int In = NI.GetInNId(d);
792  		if(NId == In) {  continue;  }
793  		double LinW = GetProdLinWeight(In, NId) - GetThetaLL(In, NId, AId);
794  		double SqW = GetProdSqWeight(In, NId) - GetSqThetaLL(In, NId, AId);
795  		for(int F = 0; F < 2; F++) {
796  			EdgeQ[F] += GetInCoeff(In, NId, AId, F, LLTheta);
797  			EdgeQ[F] += exp(LinW + log(GetInCoeff(In, NId, AId, F, Theta)));
798  			EdgeQ[F] += 0.5 * exp(SqW + log(GetInCoeff(In, NId, AId, F, SqTheta)));
799  		}
800  	}
801  	EdgeQ[0] += log(Mu);
802  	EdgeQ[1] += log(1.0 - Mu);
803  	double DeltaQ = EdgeQ[0] - EdgeQ[1];
804  	double x[] = {PhiVV(NId, AId)};
805  	TFltV ObjValV;	ObjValV.Gen(60, 0);
806  	for(int n = 0; n < 1; n++) {
807  		double LrnRate = 0.001;
808  		for(int step = 0; step < 50; step++) {
809  			double Grad = GradPhiMI(x[n], NId, AId, Lambda, DeltaQ, CntVV);
810  			if(Grad > 0.0) {  x[n] += LrnRate;  }
811  			else {  x[n] -= LrnRate;  }
812  			if(x[n] > 0.9999) {  x[n] = 0.9999;  }
813  			if(x[n] < 0.0001) {  x[n] = 0.0001;  }
814  			if(x[n] == 0.9999 || x[n] == 0.0001) {
815  				break;
816  			}
817  			LrnRate *= 0.995;
818  		}
819  		ObjValV.Add(x[n]);
820  	}
821  	double MaxVal = -DBL_MAX;
822  	int MaxX = -1;
823  	for(int n = 0; n < ObjValV.Len(); n++) {
824  		double Val = ObjPhiMI(ObjValV[n], NId, AId, Lambda, EdgeQ[0], EdgeQ[1], CntVV);
825  		if(Val > MaxVal) {
826  			MaxVal = Val;
827  			MaxX = n;
828  		} else if(MaxX < 0) {
829  			printf("(%d, %d) : %f  Q[0] = %f  Q[1] = %f  Val = %f\n", NId, AId, double(x[n]), double(EdgeQ[0]), double(EdgeQ[1]), Val);
830  		}
831  	}
832  	IAssert(MaxX >= 0);
833  	Phi = ObjValV[MaxX];
834  	return Phi - PhiVV.At(NId, AId);
835  }
836  double TMAGFitBern::DoEStepOneIter(const TFltV& TrueMuV, TFltVV& NewPhiVV, const double& Lambda) {
837  	const int NNodes = Param.GetNodes();
838  	const int NAttrs = Param.GetAttrs();
839  	double MaxDelta = 0, L1 = 0;
840  	double Val;
841  	TFltIntIntTrV NewVal;
842  	int RndCount = 0;
843  	TFltV MuV(NAttrs);	MuV.PutAll(0.0);
844  	TIntV NIndV(NNodes), AIndV(NAttrs);
845  	NewVal.Gen(NAttrs * 2);
846  	for(int i = 0; i < NNodes; i++) {
847  		for(int l = 0; l < NAttrs * 2; l++) {
848  			const int NId = TMAGNodeBern::Rnd.GetUniDevInt(NNodes);
849  			const int AId = TMAGNodeBern::Rnd.GetUniDevInt(NAttrs);
850  			double Delta = 0.0;
851  			if(KnownVV(NId, AId)) {
852  				Val = PhiVV.At(NId, AId);
853  			} else {
854  				Delta = UpdatePhiMI(Lambda, NId, AId, Val);
855  			}
856  			NewVal[l] = TFltIntIntTr(Val, NId, AId);
857  			if(fabs(Delta) > MaxDelta) {
858  				MaxDelta = fabs(Delta);
859  			}
860  			if(Val > 0.3 && Val < 0.7) {	RndCount++;	}
861  		}
862  		for(int l = 0; l < NAttrs * 2; l++) {
863  			const int NId = NewVal[l].Val2;
864  			const int AId = NewVal[l].Val3;
865  			PhiVV.At(NId, AId) = NewVal[l].Val1;
866  		}
867  	}
868  	for(int i = 0; i < NNodes; i++) {
869  		for(int l = 0; l < NAttrs; l++) {
870  			MuV[l] = MuV[l] + PhiVV.At(i, l);
871  		}
872  	}
873  	for(int l = 0; l < NAttrs; l++) {
874  		MuV[l] = MuV[l] / double(NNodes);
875  	}
876  	TFltV SortMuV = MuV;
877  	double Avg = 0.0;
878  	SortMuV.Sort(false);
879  	for(int l = 0; l < NAttrs; l++) {
880  		printf("  F[%d] = %.3f", l, double(MuV[l]));
881  		Avg += SortMuV[l];
882  		L1 += fabs(TrueMuV[l] - SortMuV[l]);
883  	}
884  	printf("\n");
885  	printf("  Rnd = %d(%.3f)", RndCount, double(RndCount) / double(NNodes * NAttrs));
886  	printf("  Avg = %.3f\n", Avg / double(NAttrs));
887  	L1 /= double(NAttrs);
888  	return L1;
889  }
890  double TMAGFitBern::DoEStepApxOneIter(const TFltV& TrueMuV, TFltVV& NewPhiVV, const double& Lambda) {
891  	const int NNodes = Param.GetNodes();
892  	const int NAttrs = Param.GetAttrs();
893  	double MaxDelta = 0, L1 = 0;
894  	double Val;
895  	TFltIntIntTrV NewVal;
896  	int RndCount = 0;
897  	TFltV MuV(NAttrs);	MuV.PutAll(0.0);
898  	TFltVV ProdVV(NNodes, 4);	ProdVV.PutAll(0.0);
899  	TIntV NIndV(NNodes), AIndV(NAttrs);
900  	AvgPhiV.Gen(NAttrs);	AvgPhiV.PutAll(0.0);
901  	AvgPhiPairVV.Gen(NAttrs, 4*NAttrs);		AvgPhiPairVV.PutAll(0.0);
902  	for(int i = 0; i < NNodes; i++) {
903  		for(int l = 0; l < NAttrs; l++) {
904  			for(int p = l+1; p < NAttrs; p++) {
905  				int index = 4 * p;
906  				AvgPhiPairVV(l, index) += PhiVV(i, l) * PhiVV(i, p);
907  				AvgPhiPairVV(l, index+1) += PhiVV(i, l) * (1.0-PhiVV(i, p));
908  				AvgPhiPairVV(l, index+2) += (1.0-PhiVV(i, l)) * PhiVV(i, p);
909  				AvgPhiPairVV(l, index+3) += (1.0-PhiVV(i, l)) * (1.0-PhiVV(i, p));
910  			}
911  			AvgPhiV[l] += PhiVV(i, l);
912  		}
913  	}
914  	for(int i = 0; i < NNodes; i++) {
915  		ProdVV(i, 0) = GetAvgProdLinWeight(i, i, true, false);
916  		ProdVV(i, 1) = GetAvgProdLinWeight(i, i, false, true);
917  		ProdVV(i, 2) = GetAvgProdSqWeight(i, i, true, false);
918  		ProdVV(i, 3) = GetAvgProdSqWeight(i, i, false, true);
919  	}
920  	const int Iter = 3;
921  	NewVal.Gen(NAttrs * Iter);
922  	for(int i = 0; i < NNodes * Iter; i++) {
923  		for(int l = 0; l < NAttrs; l++) {
924  			const int NId = TMAGNodeBern::Rnd.GetUniDevInt(NNodes);
925  			const int AId = TMAGNodeBern::Rnd.GetUniDevInt(NAttrs);
926  			double Delta = 0.0;
927  			if(KnownVV(NId, AId)) {
928  				Val = PhiVV.At(NId, AId);
929  			} else {
930  				Delta = UpdateApxPhiMI(Lambda, NId, AId, Val, ProdVV);
931  			}
932  			NewVal[l] = TFltIntIntTr(Val, NId, AId);
933  			if(fabs(Delta) > MaxDelta) {
934  				MaxDelta = fabs(Delta);
935  			}
936  			if(Val > 0.3 && Val < 0.7) {	RndCount++;	}
937  		}
938  		for(int l = 0; l < NAttrs; l++) {
939  			const int NId = NewVal[l].Val2;
940  			const int AId = NewVal[l].Val3;
941  			ProdVV(NId, 0) -= GetAvgThetaLL(NId, NId, AId, true, false);
942  			ProdVV(NId, 1) -= GetAvgThetaLL(NId, NId, AId, false, true);
943  			ProdVV(NId, 2) -= GetAvgSqThetaLL(NId, NId, AId, true, false);
944  			ProdVV(NId, 3) -= GetAvgSqThetaLL(NId, NId, AId, false, true);
945  			for(int p = 0; p < NAttrs; p++) {
946  				if(p > AId) {
947  					int index = 4 * p;
948  					AvgPhiPairVV(AId, index) -= PhiVV(NId, AId) * PhiVV(NId, p);
949  					AvgPhiPairVV(AId, index+1) -= PhiVV(NId, AId) * (1.0-PhiVV(NId, p));
950  					AvgPhiPairVV(AId, index+2) -= (1.0-PhiVV(NId, AId)) * PhiVV(NId, p);
951  					AvgPhiPairVV(AId, index+3) -= (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, p));
952  				} else if (p < AId) {
953  					int index = 4 * AId;
954  					AvgPhiPairVV(p, index) -= PhiVV(NId, p) * PhiVV(NId, AId);
955  					AvgPhiPairVV(p, index+1) -= PhiVV(NId, p) * (1.0-PhiVV(NId, AId));
956  					AvgPhiPairVV(p, index+2) -= (1.0-PhiVV(NId, p)) * PhiVV(NId, AId);
957  					AvgPhiPairVV(p, index+3) -= (1.0-PhiVV(NId, p)) * (1.0-PhiVV(NId, AId));
958  				}
959  			}
960  			AvgPhiV[AId] -= PhiVV(NId, AId);
961  			PhiVV.At(NId, AId) = NewVal[l].Val1;
962  			ProdVV(NId, 0) += GetAvgThetaLL(NId, NId, AId, true, false);
963  			ProdVV(NId, 1) += GetAvgThetaLL(NId, NId, AId, false, true);
964  			ProdVV(NId, 2) += GetAvgSqThetaLL(NId, NId, AId, true, false);
965  			ProdVV(NId, 3) += GetAvgSqThetaLL(NId, NId, AId, false, true);
966  			for(int p = 0; p < NAttrs; p++) {
967  				if(p > AId) {
968  					int index = 4 * p;
969  					AvgPhiPairVV(AId, index) += PhiVV(NId, AId) * PhiVV(NId, p);
970  					AvgPhiPairVV(AId, index+1) += PhiVV(NId, AId) * (1.0-PhiVV(NId, p));
971  					AvgPhiPairVV(AId, index+2) += (1.0-PhiVV(NId, AId)) * PhiVV(NId, p);
972  					AvgPhiPairVV(AId, index+3) += (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, p));
973  				} else if (p < AId) {
974  					int index = 4 * AId;
975  					AvgPhiPairVV(p, index) += PhiVV(NId, p) * PhiVV(NId, AId);
976  					AvgPhiPairVV(p, index+1) += PhiVV(NId, p) * (1.0-PhiVV(NId, AId));
977  					AvgPhiPairVV(p, index+2) += (1.0-PhiVV(NId, p)) * PhiVV(NId, AId);
978  					AvgPhiPairVV(p, index+3) += (1.0-PhiVV(NId, p)) * (1.0-PhiVV(NId, AId));
979  				}
980  			}
981  			AvgPhiV[AId] += PhiVV(NId, AId);
982  		}
983  	}
984  	for(int l = 0; l < NAttrs; l++) {
985  		MuV[l] = AvgPhiV[l] / double(NNodes);
986  	}
987  	TFltV SortMuV = MuV;
988  	double Avg = 0.0;
989  	for(int l = 0; l < NAttrs; l++) {
990  		printf("  F[%d] = %.3f", l, double(MuV[l]));
991  		Avg += SortMuV[l];
992  	}
993  	printf("\n");
994  	printf("  Rnd = %d(%.3f)", RndCount, double(RndCount) / double(NNodes * NAttrs));
995  	printf("  Avg = %.3f\n", Avg / double(NAttrs));
996  	return L1;
997  }
998  double TMAGFitBern::DoEStep(const TFltV& TrueMuV, const int& NIter, double& LL, const double& Lambda) {
999  	const int NNodes = Param.GetNodes();
1000  	const int NAttrs = Param.GetAttrs();
1001  	TFltVV NewPhiVV(NNodes, NAttrs);
1002  	TFltV Delta(NIter);
1003  	for(int i = 0; i < NIter; i++) {
1004  		TExeTm IterTm;
1005  		printf("EStep iteration : %d\n", (i+1));
1006  		if(ESpeedUp) {
1007  			Delta[i] = DoEStepApxOneIter(TrueMuV, NewPhiVV, Lambda);
1008  		} else {
1009  			Delta[i] = DoEStepOneIter(TrueMuV, NewPhiVV, Lambda);
1010  		}
1011  		printf("  (Time = %s)\n", IterTm.GetTmStr());
1012  	}
1013  	printf("\n");
1014  	NewPhiVV.Clr();
1015  	return Delta.Last();
1016  }
1017  const double TMAGFitBern::UpdateMu(const int& AId) {
1018  	const int NNodes = Param.GetNodes();
1019  	TMAGNodeBern DistParam = Param.GetNodeAttr();
1020  	const double OldMu = DistParam.GetMu(AId);
1021  	double NewMu = 0.0;
1022  	for(int i = 0; i < NNodes; i++) {
1023  		NewMu += PhiVV.At(i, AId);
1024  	}
1025  	AvgPhiV[AId] = NewMu;
1026  	NewMu /= double(NNodes);
1027  	printf("      [Posterior Mu] = %.4f\n", NewMu);
1028  	double Delta = fabs(NewMu - OldMu);
1029  	DistParam.SetMu(AId, NewMu);
1030  	Param.SetNodeAttr(DistParam);
1031  	return Delta;
1032  }
1033  const void TMAGFitBern::GradAffMtx(const int& AId, const TFltVV& ProdVV, const TFltVV& SqVV, const TMAGAffMtx& CurMtx, TFltV& GradV) {
1034  	const int NNodes = Param.GetNodes();
1035  	GradV.PutAll(0.0);
1036  	for(int i = 0; i < NNodes; i++) {
1037  		for(int j = 0; j < NNodes; j++) {
1038  			double Prod = ProdVV(i, j) - GetThetaLL(i, j, AId);
1039  			double Sq = SqVV(i, j) - GetSqThetaLL(i, j, AId);
1040  			for(int p = 0; p < 4; p++) {
1041  				int Ai = p / 2;
1042  				int Aj = p % 2;
1043  				double Prob = GetProbPhi(i, j, AId, Ai, Aj);
1044  				if(Graph->IsEdge(i, j)) {
1045  					GradV[p] += Prob / CurMtx.At(p);
1046  				} else {
1047  					GradV[p] -= Prob * exp(Prod);
1048  					GradV[p] -= Prob * exp(Sq) * CurMtx.At(p);
1049  				}
1050  			}
1051  		}
1052  	}
1053  }
1054  const void TMAGFitBern::GradApxAffMtx(const int& AId, const TFltVV& ProdVV, const TFltVV& SqVV, const TMAGAffMtx& CurMtx, TFltV& GradV) {
1055  	const int NNodes = Param.GetNodes();
1056  	GradV.PutAll(0.0);
1057  	TFltV LogSumV;
1058  	for(int p = 0; p < 4; p++) {
1059  		int Ai = p / 2;
1060  		int Aj = p % 2;
1061  		LogSumV.Gen(NNodes * 4, 0);
1062  		for(int i = 0; i < NNodes; i++) {
1063  			const double LProd = ProdVV(i, 0) - GetAvgThetaLL(i, i, AId, true, false);
1064  			const double LSq = SqVV(i, 0) - GetAvgSqThetaLL(i, i, AId, true, false);
1065  			const double RProd = ProdVV(i, 1) - GetAvgThetaLL(i, i, AId, false, true);
1066  			const double RSq = SqVV(i, 1) - GetAvgSqThetaLL(i, i, AId, false, true);
1067  			LogSumV.Add(LProd + log(GetProbMu(i, i, AId, Ai, Aj, true, false)));
1068  			LogSumV.Add(LSq + log(GetProbMu(i, i, AId, Ai, Aj, true, false)) + log(CurMtx.At(p)));
1069  			LogSumV.Add(RProd + log(GetProbMu(i, i, AId, Ai, Aj, false, true)));
1070  			LogSumV.Add(RSq + log(GetProbMu(i, i, AId, Ai, Aj, false, true)) + log(CurMtx.At(p)));
1071  		}
1072  		double LogSum = LogSumExp(LogSumV);
1073  		GradV[p] -= (NNodes - 1) * 0.5 * exp(LogSum);
1074  	}
1075  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1076  		const int NId1 = EI.GetSrcNId();
1077  		const int NId2 = EI.GetDstNId();
1078  		const double ProdOne = GetProdLinWeight(NId1, NId2) - GetThetaLL(NId1, NId2, AId);
1079  		const double SqOne = GetProdSqWeight(NId1, NId2) - GetSqThetaLL(NId1, NId2, AId);
1080  		for(int p = 0; p < 4; p++) {
1081  			int Ai = p / 2;
1082  			int Aj = p % 2;
1083  			double Prob = GetProbPhi(NId1, NId2, AId, Ai, Aj);
1084  			GradV[p] += Prob / CurMtx.At(p);
1085  			GradV[p] += Prob * exp(ProdOne);
1086  			GradV[p] += Prob * exp(SqOne) * CurMtx.At(p);
1087  		}
1088  	}
1089  #if 0
1090  	const double Prod = ProdVV(0, 0) - GetAvgThetaLL(0, 0, AId, false, false);
1091  	const double Sq = SqVV(0, 0) - GetAvgSqThetaLL(0, 0, AId, false, false);
1092  	for(int p = 0; p < 4; p++) {
1093  		int Ai = p / 2;
1094  		int Aj = p % 2;
1095  		GradV[p] -= NSq * exp(Prod) * GetProbMu(0, 0, AId, Ai, Aj, false, false);
1096  		GradV[p] -= NSq * exp(Sq) * GetProbMu(0, 0, AId, Ai, Aj, false, false) * CurMtx.At(p);
1097  	}
1098  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1099  		const int NId1 = EI.GetSrcNId();
1100  		const int NId2 = EI.GetDstNId();
1101  		const double ProdOne = GetProdLinWeight(NId1, NId2) - GetThetaLL(NId1, NId2, AId);
1102  		const double SqOne = GetProdSqWeight(NId1, NId2) - GetSqThetaLL(NId1, NId2, AId);
1103  		for(int p = 0; p < 4; p++) {
1104  			int Ai = p / 2;
1105  			int Aj = p % 2;
1106  			double Prob = GetProbPhi(NId1, NId2, AId, Ai, Aj);
1107  		}
1108  	}
1109  #endif
1110  }
1111  const double TMAGFitBern::UpdateAffMtx(const int& AId, const double& LrnRate, const double& MaxGrad, const double& Lambda, TFltVV& ProdVV, TFltVV& SqVV, TMAGAffMtx& NewMtx) {
1112  	double Delta = 0.0;
1113  	TMAGAffMtx AffMtx = Param.GetMtx(AId);
1114  	TFltV GradV(4);
1115  	TFltV HessV(4);
1116  	if(MSpeedUp) {
1117  		GradApxAffMtx(AId, ProdVV, SqVV, NewMtx, GradV);
1118  	} else {
1119  		GradAffMtx(AId, ProdVV, SqVV, NewMtx, GradV);
1120  	}
1121  	double Ratio = 1.0;
1122  	for(int p = 0; p < 4; p++) {
1123  		if(fabs(Ratio * LrnRate * GradV[p]) > MaxGrad) {
1124  			Ratio = MaxGrad / fabs(LrnRate * GradV[p]);
1125  		}
1126  	}
1127  	for(int p = 0; p < 4; p++) {
1128  		GradV[p] *= (Ratio * LrnRate);
1129  		NewMtx.At(p) = AffMtx.At(p) + GradV[p];
1130  		if(NewMtx.At(p) < 0.0001) {  NewMtx.At(p) = 0.0001;  }
1131  	}
1132  	printf("      [Attr = %d]\n", AId);
1133      printf("        %s  + [%f, %f; %f %f]  ----->  %s\n", (AffMtx.GetMtxStr()).GetCStr(), double(GradV[0]), double(GradV[1]), double(GradV[2]), double(GradV[3]), (NewMtx.GetMtxStr()).GetCStr());
1134  	return Delta;
1135  }
1136  void TMAGFitBern::NormalizeAffMtxV(TMAGAffMtxV& MtxV, const bool UseMu) {
1137  	const int NNodes = Param.GetNodes();
1138  	const int NAttrs = MtxV.Len();
1139  	TFltV MuV = GetMuV();
1140  	double Product = 1.0, ExpEdge = NNodes * (NNodes - 1);
1141  	TFltV SumV(NAttrs), EdgeSumV(NAttrs);
1142  	SumV.PutAll(0.0);	EdgeSumV.PutAll(0.0);
1143  	for(int l = 0; l < NAttrs; l++) {
1144  		double Mu = (UseMu) ? double(MuV[l]) : (AvgPhiV[l] / double(NNodes));
1145  		EdgeSumV[l] += Mu * Mu * MtxV[l].At(0, 0);
1146  		EdgeSumV[l] += Mu * (1.0-Mu) * MtxV[l].At(0, 1);
1147  		EdgeSumV[l] += Mu * (1.0-Mu) * MtxV[l].At(1, 0);
1148  		EdgeSumV[l] += (1.0-Mu) * (1.0-Mu) * MtxV[l].At(1, 1);
1149  		SumV[l] = SumV[l] + MtxV[l].At(0, 0);
1150  		SumV[l] = SumV[l] + MtxV[l].At(0, 1);
1151  		SumV[l] = SumV[l] + MtxV[l].At(1, 0);
1152  		SumV[l] = SumV[l] + MtxV[l].At(1, 1);
1153  		Product *= SumV[l];
1154  		ExpEdge *= EdgeSumV[l];
1155  	}
1156  	ExpEdge = Graph->GetEdges() / ExpEdge;
1157  	NormConst *= Product;
1158  	Product = 1.0;
1159  	for(int l = 0; l < NAttrs; l++) {
1160  		for(int p = 0; p < 4; p++) {
1161  			MtxV[l].At(p) = MtxV[l].At(p) * Product / SumV[l];
1162  		}
1163  	}
1164  }
1165  void TMAGFitBern::UnNormalizeAffMtxV(TMAGAffMtxV& MtxV, const bool UseMu) {
1166  	const int NNodes = Param.GetNodes();
1167  	const int NAttrs = MtxV.Len();
1168  	TFltIntPrV MaxEntV(NAttrs);
1169  	TFltV MuV = GetMuV();
1170  	NormalizeAffMtxV(MtxV, UseMu);
1171  	double ExpEdge = NNodes * (NNodes - 1);
1172  	for(int l = 0; l < NAttrs; l++) {
1173  		double Mu = MuV[l];
1174  		double EdgeSum = Mu * Mu * MtxV[l].At(0, 0);
1175  		EdgeSum += Mu * (1.0-Mu) * MtxV[l].At(0, 1);
1176  		EdgeSum += Mu * (1.0-Mu) * MtxV[l].At(1, 0);
1177  		EdgeSum += (1.0-Mu) * (1.0-Mu) * MtxV[l].At(1, 1);
1178  		ExpEdge *= EdgeSum;
1179  	}
1180  	NormConst = double(Graph->GetEdges()) / ExpEdge;
1181  	for(int l = 0; l < NAttrs; l++) {
1182  		MaxEntV[l] = TFltIntPr(-1, l);
1183  		for(int p = 0; p < 4; p++) {
1184  			if(MaxEntV[l].Val1 < MtxV[l].At(p)) {  MaxEntV[l].Val1 = MtxV[l].At(p);  }
1185  		}
1186  	}
1187  	MaxEntV.Sort(false);
1188  	for(int l = 0; l < NAttrs; l++) {
1189  		int CurId = MaxEntV[l].Val2;
1190  		double Factor = pow(NormConst, 1.0 / double(NAttrs - l));
1191  		double MaxFactor = 0.9999 / MaxEntV[l].Val1;
1192  		Factor = (Factor > MaxFactor) ? MaxFactor : Factor;
1193  		NormConst = NormConst / Factor;
1194  		for(int p = 0; p < 4; p++) {
1195  			MtxV[CurId].At(p) = MtxV[CurId].At(p) * Factor;
1196  		}
1197  	}
1198  }
1199  const void TMAGFitBern::PrepareUpdateAffMtx(TFltVV& ProdVV, TFltVV& SqVV) {
1200  	const int NNodes = Param.GetNodes();
1201  	ProdVV.Gen(NNodes, NNodes);
1202  	SqVV.Gen(NNodes, NNodes);
<span onclick='openModal()' class='match'>1203  	for(int i = 0; i < NNodes; i++) {
1204  		for(int j = 0; j < NNodes; j++) {
1205  			ProdVV(i, j) = GetProdLinWeight(i, j);
1206  			SqVV(i, j) = GetProdSqWeight(i, j);
1207  		}
1208  	}
1209  }
</span>1210  const void TMAGFitBern::PrepareUpdateApxAffMtx(TFltVV& ProdVV, TFltVV& SqVV) {
1211  	const int NNodes = Param.GetNodes();
1212  	ProdVV.Gen(NNodes, 2);
1213  	SqVV.Gen(NNodes, 2);
1214  	for(int i = 0; i < NNodes; i++) {
1215  		ProdVV(i, 0) = GetAvgProdLinWeight(i, i, true, false);
1216  		ProdVV(i, 1) = GetAvgProdLinWeight(i, i, false, true);
1217  		SqVV(i, 0) = GetAvgProdSqWeight(i, i, true, false);
1218  		SqVV(i, 1) = GetAvgProdSqWeight(i, i, false, true);
1219  	}
1220  }
1221  const double TMAGFitBern::UpdateAffMtxV(const int& GradIter, const double& LrnRate, const double& MaxGrad, const double& Lambda, const int& NReal) {
1222  	const int NNodes = Param.GetNodes();
1223  	const int NAttrs = Param.GetAttrs();
1224  	const TMAGNodeBern DistParam = Param.GetNodeAttr();
1225  	const TFltV MuV = DistParam.GetMuV();
1226  	double Delta = 0.0;
1227  	double DecLrnRate = LrnRate, DecMaxGrad = MaxGrad;
1228  	TFltVV ProdVV(NNodes, NNodes), SqVV(NNodes, NNodes);
1229  	TMAGAffMtxV NewMtxV, OldMtxV;
1230  	Param.GetMtxV(OldMtxV);
1231  	Param.GetMtxV(NewMtxV);
1232  	for(int g = 0; g < GradIter; g++) {
1233  		if(MSpeedUp) {
1234  			PrepareUpdateApxAffMtx(ProdVV, SqVV);
1235  		} else {
1236  			PrepareUpdateAffMtx(ProdVV, SqVV);
1237  		}
1238  		printf("    [Grad step = %d]\n", (g+1));
1239  		for(int l = NReal; l < NAttrs; l++) {
1240  			UpdateAffMtx(l, DecLrnRate, DecMaxGrad, Lambda, ProdVV, SqVV, NewMtxV[l]);
1241  			Param.SetMtxV(NewMtxV);
1242  		}
1243  		DecLrnRate *= 0.97;
1244  		DecMaxGrad *= 0.97;
1245  		printf("\n");
1246  		NormalizeAffMtxV(NewMtxV, true);
1247  		Param.SetMtxV(NewMtxV);
1248  	}
1249  	NormalizeAffMtxV(NewMtxV, true);
1250  	printf( "\nFinal\n");
1251  	for(int l = 0; l < NAttrs; l++) {
1252  		printf("    [");
1253  		for(int p = 0; p < 4; p++) {
1254  			Delta += fabs(OldMtxV[l].At(p) - NewMtxV[l].At(p));
1255  			printf(" %.4f ", double(NewMtxV[l].At(p)));
1256  		}
1257  		printf("]\n");
1258  	}
1259  	Param.SetMtxV(NewMtxV);
1260  	ProdVV.Clr();		SqVV.Clr();
1261  	return Delta;
1262  }
1263  void TMAGFitBern::DoMStep(const int& GradIter, const double& LrnRate, const double& MaxGrad, const double& Lambda, const int& NReal) {
1264  	const int NAttrs = Param.GetAttrs();
1265  	double MuDelta = 0.0, AffMtxDelta = 0.0;
1266  	TExeTm ExeTm;
1267  	printf("\n");
1268  	AvgPhiV.Gen(NAttrs);	AvgPhiV.PutAll(0.0);
1269  	for(int l = 0; l < NAttrs; l++) {
1270  		MuDelta += UpdateMu(l);
1271  	}
1272  	printf("\n");
1273  	printf("  == Update Theta\n");
1274  	AffMtxDelta += UpdateAffMtxV(GradIter, LrnRate, MaxGrad, Lambda, NReal);
1275  	printf("\n");
1276  	printf("Elpased time = %s\n", ExeTm.GetTmStr());
1277  	printf("\n");
1278  }
1279  void TMAGFitBern::DoEMAlg(const int& NStep, const int& NEstep, const int& NMstep, const double& LrnRate, const double& MaxGrad, const double& Lambda, const double& ReInit, const int& NReal) {
1280  	const int NNodes = Param.GetNodes();
1281  	const int NAttrs = Param.GetAttrs();
1282  	TIntV IndexV;
1283  	double LL;
1284  	MuHisV.Gen(NStep + 1, 0);
1285  	MtxHisV.Gen(NStep + 1, 0);
1286  	LLHisV.Gen(NStep + 1, 0);
1287  	printf("--------------------------------------------\n");
1288  	printf("Before EM Iteration\n");
1289  	printf("--------------------------------------------\n");
1290  	TMAGAffMtxV InitMtxV;
1291  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1292  	Param.GetMtxV(InitMtxV);
1293  	TFltV InitMuV = NodeAttr.GetMuV();
1294  	for(int i = 0; i < NNodes; i++) {
1295  		for(int l = 0; l < NAttrs; l++) {
1296  			if(! KnownVV(i, l)) {
1297  				PhiVV.At(i, l) = TMAGNodeBern::Rnd.GetUniDev();
1298  			}
1299  		}
1300  	}
1301  	if(Debug) {
1302  		double LL = ComputeApxLL();
1303  		MuHisV.Add(InitMuV);
1304  		MtxHisV.Add(InitMtxV);
1305  		LLHisV.Add(LL);
1306  	}
1307  	NormalizeAffMtxV(InitMtxV, true);
1308  	Param.SetMtxV(InitMtxV);
1309  	for(int n = 0; n < NStep; n++) {
1310  		printf("--------------------------------------------\n");
1311  		printf("EM Iteration : %d\n", (n+1));
1312  		printf("--------------------------------------------\n");
1313  		NodeAttr = Param.GetNodeAttr();
1314  		for(int i = 0; i < NNodes; i++) {
1315  			for(int l = 0; l < NAttrs; l++) {
1316  				if(!KnownVV(i, l) && TMAGNodeBern::Rnd.GetUniDev() < ReInit) {
1317  					PhiVV.At(i, l) = TMAGNodeBern::Rnd.GetUniDev();
1318  				}
1319  			}
1320  		}
1321  		DoEStep(InitMuV, NEstep, LL, Lambda);
1322  		Param.GetMtxV(InitMtxV);
1323  		Param.SetMtxV(InitMtxV);
1324  		DoMStep(NMstep, LrnRate, MaxGrad, Lambda, NReal);
1325  		printf("\n");
1326  		if(Debug) {
1327  			double LL = ComputeApxLL();
1328  			MuHisV.Add(InitMuV);
1329  			MtxHisV.Add(InitMtxV);
1330  			LLHisV.Add(LL);
1331  			printf("    ApxLL = %.2f (Const = %f)\n", LL, double(NormConst));
1332  		}
1333  	}
1334  	Param.GetMtxV(InitMtxV);
1335  	UnNormalizeAffMtxV(InitMtxV, true);
1336  	Param.SetMtxV(InitMtxV);
1337  }
1338  void TMAGFitBern::MakeCCDF(const TFltPrV& RawV, TFltPrV& CcdfV) {
1339  	double Total = 0.0;
1340  	CcdfV.Gen(RawV.Len(), 0);
1341  	for(int i = 0; i < RawV.Len(); i++) {
1342  		if(RawV[i].Val2 <= 0) {  continue;  }
1343  		Total += RawV[i].Val2;
1344  		CcdfV.Add(RawV[i]);
1345  		IAssert(RawV[i].Val2 > 0);
1346  	}
1347  	for(int i = 1; i < CcdfV.Len(); i++) {
1348  		CcdfV[i].Val2 += CcdfV[i-1].Val2;
1349  	}
1350  	for(int i = CcdfV.Len() - 1; i > 0; i--) {
1351  		CcdfV[i].Val2 = (Total - CcdfV[i-1].Val2) ;
1352  		if(CcdfV[i].Val2 <= 0) {  printf("CCDF = %f\n", double(CcdfV[i].Val2));}
1353  		IAssert(CcdfV[i].Val2 > 0);
1354  	}
1355  	CcdfV[0].Val2 = Total;
1356  }
1357  void TMAGFitBern::PlotProperties(const TStr& FNm) {
1358  	const int NNodes = Param.GetNodes();
1359  	const int NAttrs = Param.GetAttrs();
1360  	TMAGParam<TMAGNodeBern> MAGGen(NNodes, NAttrs);
1361  	TMAGNodeBern MAGNode = Param.GetNodeAttr();
1362  	MAGGen.SetNodeAttr(MAGNode);
1363  	TMAGAffMtxV MtxV;	Param.GetMtxV(MtxV);
1364  	MAGGen.SetMtxV(MtxV);
1365  	PNGraph TrG = new TNGraph;
1366  	*TrG = *Graph;
1367  	TIntVV AttrVV(NNodes, NAttrs);
1368  	for(int i = 0; i < NNodes; i++) {
1369  		for(int j = 0; j < NAttrs; j++) {
1370  			if(PhiVV(i, j) > TMAGNodeBern::Rnd.GetUniDev())	AttrVV(i, j) = 0;
1371  			else AttrVV(i, j) = 1;
1372  		}
1373  	}
1374  	PNGraph MAG = MAGGen.GenMAG(AttrVV, true, 10000);
1375  	printf("%d edges created for MAG...\n", MAG->GetEdges());
1376  	TSnap::DelZeroDegNodes(TrG);
1377  	TSnap::DelZeroDegNodes(MAG);
1378  	TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal | gsdTriadPart);
1379      TGnuPlot InDegP(FNm + "-InDeg"), OutDegP(FNm + "-OutDeg"), SvalP(FNm + "-Sval"), SvecP(FNm + "-Svec"), WccP(FNm + "-Wcc"), HopP(FNm + "-Hop"), TriadP(FNm + "-Triad"), CcfP(FNm + "-Ccf");;
1380      InDegP.SetXYLabel("Degree", "# of nodes");
1381      OutDegP.SetXYLabel("Degree", "# of nodes");
1382      SvalP.SetXYLabel("Rank", "Singular value");
1383      SvecP.SetXYLabel("Rank", "Primary SngVec component");
1384      WccP.SetXYLabel("Size of component", "# of components");
1385      CcfP.SetXYLabel("Degree", "Clustering coefficient");
1386      HopP.SetXYLabel("Hops", "# of node pairs");
1387      TriadP.SetXYLabel("# of triads", "# of participating nodes");
1388      InDegP.SetScale(gpsLog10XY);    InDegP.AddCmd("set key top right");
1389      OutDegP.SetScale(gpsLog10XY);   OutDegP.AddCmd("set key top right");
1390      SvalP.SetScale(gpsLog10XY);     SvalP.AddCmd("set key top right");
1391      SvecP.SetScale(gpsLog10XY);     SvecP.AddCmd("set key top right");
1392      CcfP.SetScale(gpsLog10XY);      CcfP.AddCmd("set key top right");
1393      HopP.SetScale(gpsLog10XY);      HopP.AddCmd("set key top right");
1394      TriadP.SetScale(gpsLog10XY);    TriadP.AddCmd("set key top right");
1395  	InDegP.ShowGrid(false);
1396  	OutDegP.ShowGrid(false);
1397  	SvalP.ShowGrid(false);
1398  	SvecP.ShowGrid(false);
1399  	CcfP.ShowGrid(false);
1400  	HopP.ShowGrid(false);
1401  	TriadP.ShowGrid(false);
1402  	const TStr Style[2] = {"lt 1 lw 3 lc rgb 'black'", "lt 2 lw 3 lc rgb 'red'"};
1403  	const TStr Name[2] = {"Real", "MAG"};
1404  	GS.Add(Graph, TSecTm(1), "Real Graph");
1405  	GS.Add(MAG, TSecTm(2), "MAG");
1406  	TFltPrV InDegV, OutDegV, SvalV, SvecV, HopV, WccV, CcfV, TriadV;
1407  	for(int i = 0; i < GS.Len(); i++) {
1408  		MakeCCDF(GS.At(i)->GetDistr(gsdInDeg), InDegV);
1409  		MakeCCDF(GS.At(i)->GetDistr(gsdOutDeg), OutDegV);
1410  		SvalV = GS.At(i)->GetDistr(gsdSngVal);
1411  		SvecV = GS.At(i)->GetDistr(gsdSngVec);
1412  		MakeCCDF(GS.At(i)->GetDistr(gsdClustCf), CcfV);
1413  		HopV = GS.At(i)->GetDistr(gsdHops);
1414  		MakeCCDF(GS.At(i)->GetDistr(gsdTriadPart), TriadV);
1415  		InDegP.AddPlot(InDegV, gpwLines, Name[i], Style[i]);
1416  		OutDegP.AddPlot(OutDegV, gpwLines, Name[i], Style[i]);
1417  		SvalP.AddPlot(SvalV, gpwLines, Name[i], Style[i]);
1418  		SvecP.AddPlot(SvecV, gpwLines, Name[i], Style[i]);
1419  		CcfP.AddPlot(CcfV, gpwLines, Name[i], Style[i]);
1420  		HopP.AddPlot(HopV, gpwLines, Name[i], Style[i]);
1421  		TriadP.AddPlot(TriadV, gpwLines, Name[i], Style[i]);
1422  	}
1423  	InDegP.SaveEps(30);
1424  	OutDegP.SaveEps(30);
1425  	SvalP.SaveEps(30);
1426  	SvecP.SaveEps(30);
1427  	CcfP.SaveEps(30);
1428  	HopP.SaveEps(30);
1429  	TriadP.SaveEps(30);
1430  }
1431  void TMAGFitBern::CountAttr(TFltV& EstMuV) const {
1432  	const int NNodes = PhiVV.GetXDim();
1433  	const int NAttrs = PhiVV.GetYDim();
1434  	EstMuV.Gen(NAttrs);
1435  	EstMuV.PutAll(0.0);
1436  	for(int l = 0; l < NAttrs; l++) {
1437  		for(int i = 0; i < NNodes; i++) {
1438  			EstMuV[l] = EstMuV[l] + PhiVV(i, l);
1439  		}
1440  		EstMuV[l] = EstMuV[l] / double(NNodes);
1441  	}
1442  }
1443  void TMAGFitBern::SortAttrOrdering(const TFltV& TrueMuV, TIntV& IndexV) const {
1444  	const int NAttrs = TrueMuV.Len();
1445  	TFltV EstMuV, SortedTrueMuV, SortedEstMuV, TrueIdxV, EstIdxV;
1446  	IndexV.Gen(NAttrs);
1447  	TrueIdxV.Gen(NAttrs);
1448  	EstIdxV.Gen(NAttrs);
1449  	for(int l = 0; l < NAttrs; l++) {
1450  		TrueIdxV[l] = l;
1451  		EstIdxV[l] = l;
1452  	}
1453  	CountAttr(EstMuV);
1454  	SortedTrueMuV = TrueMuV;
1455  	SortedEstMuV = EstMuV;
1456  	for(int i = 0; i < NAttrs; i++) {
1457  		if(SortedTrueMuV[i] > 0.5) {  SortedTrueMuV[i] = 1.0 - SortedTrueMuV[i];  }
1458  		if(SortedEstMuV[i] > 0.5) {  SortedEstMuV[i] = 1.0 - SortedEstMuV[i];  }
1459  	}
1460  	for(int i = 0; i < NAttrs; i++) {
1461  		for(int j = i+1; j < NAttrs; j++) {
1462  			if(SortedTrueMuV[i] < SortedTrueMuV[j]) {
1463  				SortedTrueMuV.Swap(i, j);
1464  				TrueIdxV.Swap(i, j);
1465  			}
1466  			if(SortedEstMuV[i] < SortedEstMuV[j]) {
1467  				EstIdxV.Swap((int)SortedEstMuV[i], (int)SortedEstMuV[j]);
1468  				SortedEstMuV.Swap(i, j);
1469  			}
1470  		}
1471  	}
1472  	for(int l = 0; l < NAttrs; l++) {
1473  		IndexV[l] = (int)TrueIdxV[(int)EstIdxV[l]];
1474  	}
1475  }
1476  const bool TMAGFitBern::NextPermutation(TIntV& IndexV) const {
1477  	const int NAttrs = IndexV.Len();
1478  	int Pos = NAttrs - 1;
1479  	while(Pos > 0) {
1480  		if(IndexV[Pos-1] < IndexV[Pos]) {
1481  			break;
1482  		}
1483  		Pos--;
1484  	}
1485  	if(Pos == 0) {
1486  		return false;
1487  	}
1488  	int Val = NAttrs, NewPos = -1;
1489  	for(int i = Pos; i < NAttrs; i++) {
1490  		if(IndexV[i] > IndexV[Pos - 1] && IndexV[i] < Val) {
1491  			NewPos = i;
1492  			Val = IndexV[i];
1493  		}
1494  	}
1495  	IndexV[NewPos] = IndexV[Pos - 1];
1496  	IndexV[Pos - 1] = Val;
1497  	TIntV SubIndexV;
1498      IndexV.GetSubValV(Pos, NAttrs - 1, SubIndexV);
1499  	SubIndexV.Sort(true);
1500  	for(int i = Pos; i < NAttrs; i++) {
1501  		IndexV[i] = SubIndexV[i - Pos];
1502  	}
1503  	return true;
1504  }
1505  const double TMAGFitBern::ComputeJointOneLL(const TIntVV& AttrVV) const {
1506  	double LL = 0.0;
1507  	const int NNodes = Param.GetNodes();
1508  	const int NAttrs = Param.GetAttrs();
1509  	TMAGAffMtxV MtxV(NAttrs);	Param.GetMtxV(MtxV);
1510  	const TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1511  	const TFltV MuV = NodeAttr.GetMuV();
1512  	for(int l = 0; l < NAttrs; l++) {
1513  		for(int i = 0; i < MtxV[l].Len(); i++) {
1514  			MtxV[l].At(i) = log(MtxV[l].At(i));
1515  		}
1516  	}
1517  	for(int i = 0; i < NNodes; i++) {
1518  		for(int l = 0; l < NAttrs; l++) {
1519  			if(AttrVV.At(i, l) == 0) {
1520  				LL += log(MuV[l]);
1521  			} else {
1522  				LL += log(1.0 - MuV[l]);
1523  			}
1524  		}
1525  		for(int j = 0; j < NNodes; j++) {
1526  			if(i == j) {  continue;  }
1527  			double ProbLL = 0.0;
1528  			for(int l = 0; l < NAttrs; l++) {
1529  				ProbLL += MtxV[l].At(AttrVV.At(i, l), AttrVV.At(j, l));
1530  			}
1531  			if(Graph->IsEdge(i, j)) {
1532  				LL += ProbLL;
1533  			} else {
1534  				LL += log(1-exp(ProbLL));
1535  			}
1536  		}
1537  	}
1538  	return LL;
1539  }
1540  const double TMAGFitBern::ComputeJointAdjLL(const TIntVV& AttrVV) const {
1541  	double LL = 0.0;
1542  	const int NNodes = Param.GetNodes();
1543  	const int NAttrs = Param.GetAttrs();
1544  	TMAGAffMtxV MtxV(NAttrs);	Param.GetMtxV(MtxV);
1545  	const TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1546  	const TFltV MuV = NodeAttr.GetMuV();
1547  	for(int l = 0; l < NAttrs; l++) {
1548  		for(int i = 0; i < MtxV[l].Len(); i++) {
1549  			MtxV[l].At(i) = log(MtxV[l].At(i));
1550  		}
1551  	}
1552  	for(int i = 0; i < NNodes; i++) {
1553  		for(int j = 0; j < NNodes; j++) {
1554  			if(i == j) {  continue;  }
1555  			double ProbLL = 0.0;
1556  			for(int l = 0; l < NAttrs; l++) {
1557  				ProbLL += MtxV[l].At(AttrVV.At(i, l), AttrVV.At(j, l));
1558  			}
1559  			if(Graph->IsEdge(i, j)) {
1560  				LL += ProbLL;
1561  			} else {
1562  				LL += log(1-exp(ProbLL));
1563  			}
1564  		}
1565  	}
1566  	return LL;
1567  }
1568  const double TMAGFitBern::ComputeJointLL(int NSample) const {
1569  	double LL = 0.0;
1570  	const int NNodes = Param.GetNodes();
1571  	const int NAttrs = Param.GetAttrs();
1572  	TRnd Rnd(2000);
1573  	TIntVV AttrVV(NNodes, NAttrs);
1574  	int count = 0;
1575  	for(int s = 0; s < NSample; s++) {
1576  		for(int i = 0; i < NNodes; i++) {
1577  			for(int l = 0; l < NAttrs; l++) {
1578  				if(Rnd.GetUniDev() <= PhiVV(i, l)) {
1579  					AttrVV.At(i, l) = 0;
1580  				} else {
1581  					AttrVV.At(i, l) = 1;
1582  				}
1583  				if(PhiVV(i, l) > 0.05 && PhiVV(i, l) < 0.95) count++;
1584  			}
1585  		}
1586  		LL += ComputeJointOneLL(AttrVV);
1587  	}
1588  	AttrVV.Clr();
1589  	return LL / double(NSample);
1590  }
1591  const double TMAGFitBern::ComputeApxLL() const {
1592  	double LL = 0.0;
1593  	const int NNodes = Param.GetNodes();
1594  	const int NAttrs = Param.GetAttrs();
1595  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1596  	TFltV MuV = NodeAttr.GetMuV();
1597  	TMAGAffMtxV LLMtxV(NAttrs);
1598  	for(int l = 0; l < NAttrs; l++) {
1599  		for(int i = 0; i < NNodes; i++) {
1600  			LL += PhiVV(i, l) * log(MuV[l]);
1601  			LL += (1.0 - PhiVV(i, l)) * log(1.0 - MuV[l]);
1602  			LL -= PhiVV(i, l) * log(PhiVV(i, l));
1603  			LL -= (1.0 - PhiVV(i, l)) * log(1.0 - PhiVV(i, l));
1604  		}
1605  		TMAGAffMtx Theta = Param.GetMtx(l);
1606  		Theta.GetLLMtx(LLMtxV[l]);
1607  	}
1608  	for(int i = 0; i < NNodes; i++) {
1609  		for(int j = 0; j < NNodes; j++) {
1610  			if(i == j) {  continue;  }
1611  			if(Graph->IsEdge(i, j)) {
1612  				for(int l = 0; l < NAttrs; l++) {
1613  					LL += GetProbPhi(i, j, l, 0, 0) * LLMtxV[l].At(0, 0);
1614  					LL += GetProbPhi(i, j, l, 0, 1) * LLMtxV[l].At(0, 1);
1615  					LL += GetProbPhi(i, j, l, 1, 0) * LLMtxV[l].At(1, 0);
1616  					LL += GetProbPhi(i, j, l, 1, 1) * LLMtxV[l].At(1, 1);
1617  				}
1618  				LL += log(NormConst);
1619  			} else {
1620  				LL += log(1-exp(GetProdLinWeight(i, j)));
1621  			}
1622  		}
1623  	}
1624  	return LL;
1625  }
1626  const double TMAGFitBern::ComputeApxAdjLL() const {
1627  	double LL = 0.0;
1628  	const int NNodes = Param.GetNodes();
1629  	const int NAttrs = Param.GetAttrs();
1630  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1631  	TFltV MuV = NodeAttr.GetMuV();
1632  	MuV.PutAll(0.0);
1633  	TMAGAffMtxV LLMtxV(NAttrs);
1634  	double TotalEdge = 0.0;
1635  	for(int l = 0; l < NAttrs; l++) {
1636  		TMAGAffMtx Theta = Param.GetMtx(l);
1637  		Theta.GetLLMtx(LLMtxV[l]);
1638  	}
1639  	for(int i = 0; i < NNodes; i++) {
1640  		for(int j = 0; j < NNodes; j++) {
1641  			if(i == j) {  continue;  }
1642  			if(Graph->IsEdge(i, j)) {
1643  				for(int l = 0; l < NAttrs; l++) {
1644  					LL += GetProbPhi(i, j, l, 0, 0) * LLMtxV[l].At(0, 0);
1645  					LL += GetProbPhi(i, j, l, 0, 1) * LLMtxV[l].At(0, 1);
1646  					LL += GetProbPhi(i, j, l, 1, 0) * LLMtxV[l].At(1, 0);
1647  					LL += GetProbPhi(i, j, l, 1, 1) * LLMtxV[l].At(1, 1);
1648  				}
1649  			} else {
1650  				LL += log(1-exp(GetProdLinWeight(i, j)));
1651  			}
1652  			double TempLL = 1.0;
1653  			for(int l = 0; l < NAttrs; l++) {
1654  				int Ai = (double(PhiVV(i, l)) > 0.5) ? 0 : 1;
1655  				int Aj = (double(PhiVV(j, l)) > 0.5) ? 0 : 1;
1656  				TempLL *= Param.GetMtx(l).At(Ai, Aj);
1657  			}
1658  			if(TMAGNodeBern::Rnd.GetUniDev() < TempLL) {
1659  				TotalEdge += 1.0;
1660  			}
1661  		}
1662  	}
1663  	return LL;
1664  }
1665  const double TMAGFitBern::ComputeMI(const TIntVV& AttrV, const int AId1, const int AId2) {
1666  	const int NNodes = AttrV.GetXDim();
1667  	double MI = 0.0;
1668  	double Cor = 0.0;
1669  	TFltVV Pxy(2,2);
1670  	TFltV Px(2), Py(2);
1671  	Pxy.PutAll(0.0);
1672  	Px.PutAll(0.0);
1673  	Py.PutAll(0.0);
1674  	for(int i = 0; i < NNodes; i++) {
1675  		int X = AttrV(i, AId1);
1676  		int Y = AttrV(i, AId2);
1677  		Pxy(X, Y) = Pxy(X, Y) + 1;
1678  		Px[X] = Px[X] + 1;
1679  		Py[Y] = Py[Y] + 1;
1680  		Cor += double(X * Y);
1681  	}
1682  	for(int x = 0; x < 2; x++) {
1683  		for(int y = 0; y < 2; y++) {
1684        MI += Pxy(x, y) / double(NNodes) * (log(Pxy(x, y).Val) - log(Px[x].Val) - log(Py[y].Val) + log((double)NNodes));
1685  		}
1686  	}
1687  	return MI;
1688  }
1689  const double TMAGFitBern::ComputeMI(const TFltVV& AttrV, const int AId1, const int AId2) {
1690  	const int NNodes = AttrV.GetXDim();
1691  	double MI = 0.0;
1692  	double Cor = 0.0;
1693  	TFltVV Pxy(2,2);
1694  	TFltV Px(2), Py(2);
1695  	Pxy.PutAll(0.0);
1696  	Px.PutAll(0.0);
1697  	Py.PutAll(0.0);
1698  	for(int i = 0; i < NNodes; i++) {
1699  		double X = AttrV(i, AId1);
1700  		double Y = AttrV(i, AId2);
1701  		Pxy(0, 0) = Pxy(0, 0) + X * Y;
1702  		Pxy(0, 1) = Pxy(0, 1) + X * (1 - Y);
1703  		Pxy(1, 0) = Pxy(1, 0) + (1 - X) * Y;
1704  		Pxy(1, 1) = (i+1) - Pxy(0, 0) - Pxy(0, 1) - Pxy(1, 0);
1705  		Px[0] = Px[0] + X;
1706  		Py[0] = Py[0] + Y;
1707  		Cor += double((1-X) * (1-Y));
1708  	}
1709  	Px[1] = NNodes - Px[0];
1710  	Py[1] = NNodes - Py[0];
1711  	for(int x = 0; x < 2; x++) {
1712  		for(int y = 0; y < 2; y++) {
1713  			MI += Pxy(x, y) / double(NNodes) * (log(Pxy(x, y)) - log(Px[x]) - log(Py[y]) + log(double(NNodes)));
1714  		}
1715  	}
1716  	return MI;
1717  }
1718  const double TMAGFitBern::ComputeMI(const TIntVV& AttrV) {
1719  	const int NAttrs = AttrV.GetYDim();
1720  	double MI = 0.0;
1721  	for(int l = 0; l < NAttrs; l++) {
1722  		for(int k = l+1; k < NAttrs; k++) {
1723  			MI += ComputeMI(AttrV, l, k);
1724  		}
1725  	}
1726  	return MI;
1727  }
1728  const double TMAGFitBern::ComputeMI(const TFltVV& AttrV) {
1729  	const int NAttrs = AttrV.GetYDim();
1730  	double MI = 0.0;
1731  	for(int l = 0; l < NAttrs; l++) {
1732  		for(int k = l+1; k < NAttrs; k++) {
1733  			MI += ComputeMI(AttrV, l, k);
1734  		}
1735  	}
1736  	return MI;
1737  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmgraph-exp.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mag.cpp</div>
                </div>
                <div class="column column_space"><pre><code>262        if (InETypeIdSet.IsKey(ETypeId)) {
263          for (int i = Node.InTypeIndexV[ETypeId]; i < Node.InTypeIndexV[ETypeId] + Node.InTypeDegV[ETypeId]; i++) {
264            InEIdV[index++] = Node.InEIdV[i];
265          }
266        }
267      }
</pre></code></div>
                <div class="column column_space"><pre><code>1203  	for(int i = 0; i < NNodes; i++) {
1204  		for(int j = 0; j < NNodes; j++) {
1205  			ProdVV(i, j) = GetProdLinWeight(i, j);
1206  			SqVV(i, j) = GetProdSqWeight(i, j);
1207  		}
1208  	}
1209  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    