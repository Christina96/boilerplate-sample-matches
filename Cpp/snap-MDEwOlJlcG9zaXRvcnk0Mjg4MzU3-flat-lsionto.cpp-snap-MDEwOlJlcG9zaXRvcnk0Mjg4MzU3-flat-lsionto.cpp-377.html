
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 40, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</h3>
            <pre><code>1  #include &quot;lsionto.h&quot;
2  void TOntoConcept::GenMedoid(PBowDocWgtBs BowDocWgtBs) {
3      TFltIntKdV WgtDIdV;
4      for (int DIdN = 0; DIdN &lt; DIdV.Len(); DIdN++) {
5          const int DId = DIdV[DIdN];
6          PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DId);
7          const double Wgt = TBowSim::GetCosSim(ConceptSpV, DocSpV);
8          WgtDIdV.Add(TFltIntKd(Wgt, DId));
9      }
10      const int TopN = 33;
11      TFltIntKdV TopWgtDIdV;
12      if (WgtDIdV.Len() &gt; TopN) {
13          TFltIntKdHp::GetTopV(htMin, TopN, WgtDIdV, TopWgtDIdV, true);
14      } else { 
15          TopWgtDIdV = WgtDIdV; TopWgtDIdV.Sort(false);
16      }
17      GetSwitchedKdV&lt;TFlt, TInt&gt;(TopWgtDIdV, MedoidDIdWgtV);
18  }
19  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
20          const int _Id, const TIntV&amp; _DIdV): Id(_Id), DIdV(_DIdV)  { 
21      ResetCentroidSpV(BowDocWgtBs);
22      CptNm = GetKeyWdStr(BowDocBs, 3, 1.0, &quot;, &quot;, false, false);
23      SvmKeyWdSpV = TBowSpV::New();
24      if (!DIdV.IsSorted()) { DIdV.Sort(); }
25      Compactness = Clarity = -1.0;
26  };
27  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, const int _Id, 
28          const TStr&amp; _CptNm, const TIntV&amp; _DIdV): Id(_Id), CptNm(_CptNm), DIdV(_DIdV) { 
29      ResetCentroidSpV(BowDocWgtBs);
30      SvmKeyWdSpV = TBowSpV::New();
31      if (!DIdV.IsSorted()) { DIdV.Sort(); }
32      Compactness = Clarity = -1.0;
33  };
34  void TOntoConcept::ResetCentroidSpV(PBowDocWgtBs BowDocWgtBs) {
35      ConceptSpV = TBowClust::GetConceptSpV(BowDocWgtBs, NULL, DIdV);
36      GenMedoid(BowDocWgtBs);
37      IsValid = true;
38  }
39  void TOntoConcept::SetDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV&amp; _DIdV) {
40      if (Id == 0) return; 
41      DIdV = _DIdV; if (!DIdV.IsSorted()) { DIdV.Sort(); }
42      ResetCentroidSpV(BowDocWgtBs);
43  }
44  void TOntoConcept::AddDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV&amp; SubDIdV) {
45      DIdV.Union(SubDIdV);
46      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
47      else { IsValid = false; }
48  }
49  void TOntoConcept::AddDId(PBowDocWgtBs BowDocWgtBs, const int&amp; DId) {
50      if (DIdV.SearchBin(DId) == -1) { DIdV.AddSorted(DId); }
51      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
52      else { IsValid = false; }
53  }
54  void TOntoConcept::DelDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV&amp; SubDIdV) {
55      if (Id == 0) return; 
56      DIdV.Diff(SubDIdV);
57      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
58      else { IsValid = false; }
59  }
60  bool TOntoConcept::DelDId(PBowDocWgtBs BowDocWgtBs, const int&amp; DId) {
61      if (Id == 0) return false; 
62      bool DocDeletedP = DIdV.DelIfIn(DId);
63      if (DocDeletedP &amp;&amp; !BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
64      else { IsValid = false; }
65      return DocDeletedP;
66  }
67  TStr TOntoConcept::GetKeyWdStr(PBowDocBs BowDocBs, const int&amp; TopWords, 
68          const double&amp; TopWordsWgtPrc, const TStr&amp; SepStr, 
69          const bool&amp; ShowWeights, const bool&amp; UseMedoidP) const { 
70      if (!UseMedoidP) {
71          return ConceptSpV-&gt;GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
72      } else {
73          if (MedoidDIdWgtV.Empty()) { return &quot;Empty concept&quot;; }
74          TStr KeyWdStr = BowDocBs-&gt;GetDocNm(MedoidDIdWgtV[0].Key);
75          const int DIds = TInt::GetMn(TopWords, MedoidDIdWgtV.Len());
76          for (int DIdN = 1; DIdN &lt; DIds; DIdN++) {
77              const int DId = MedoidDIdWgtV[DIdN].Key;
78              TStr DocNm = BowDocBs-&gt;GetDocNm(DId);
79              KeyWdStr += SepStr; KeyWdStr += DocNm;
80          }
81          return KeyWdStr;
82      }
83  }
84  TStr TOntoConcept::GetSvmKeyWdStr(PBowDocBs BowDocBs, const int&amp; TopWords,
85          const double&amp; TopWordsWgtPrc, const TStr&amp; SepStr, const bool&amp; ShowWeights) const {
86      return SvmKeyWdSpV-&gt;GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
87  }
88  void TOntoConcept::CalcCptMd(PBowDocBs BowDocBs, const TIntV&amp; ContextDIdV,
89          const double&amp; SvmC, const double&amp; SvmJ, const int&amp; SvmTime) {
90      if (Id == 0) return;
91      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, 
92          bwwtLogDFNrmTFIDF, 0.0, 0, ContextDIdV);
93      PSVMTrainSet TrainSet = TBowDocBs2TrainSet::NewBowAllCatV(
94          BowDocWgtBs, ContextDIdV, DIdV);
95      CptMd = TSVMModel::NewClsLinear(TrainSet, SvmC, SvmJ, TIntV(), 
96          TSVMLearnParam::Lin(SvmTime));
97      CptMd-&gt;MakeProb(TrainSet);
98  }
99  TStr TOntoRltType::SubCptOfRltStr = &quot;SubConcept-Of&quot;;
100  TStr TOntoRltType::SimilarRltStr = &quot;Similar&quot;;
101  void TOntoAlg::SuggestKMeans(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
102          const TIntV&amp; DIdV, const int&amp; _NewConceptN, PUniqueId UniqueId, 
103          TOntoConceptV&amp; NewConceptV) {
104      const int NewConceptN = TInt::GetMn(DIdV.Len(), _NewConceptN);
105      NewConceptV.Clr(); if (NewConceptN &lt; 2) return;
106      TIntV FullDIdV; BowDocWgtBs-&gt;GetDIdV(FullDIdV);
107      BowDocWgtBs-&gt;SetDIdV(DIdV);
108      PBowSim BowSim = TBowSim::New(bstCos);
109      PBowDocPart BowDocPart=TBowClust::GetKMeansPartForDocWgtBs(
110          TNotify::StdNotify, BowDocWgtBs, BowDocBs, 
111          BowSim, TRnd(1), NewConceptN, 1, 10, 1);
112      BowDocWgtBs-&gt;SetDIdV(FullDIdV);
113      IAssert(BowDocPart-&gt;GetClusts() == NewConceptN);
114      NewConceptV.Gen(NewConceptN, 0);
115      for (int ClustC = 0; ClustC &lt; NewConceptN; ClustC++) {
116          PBowDocPartClust Clust = BowDocPart-&gt;GetClust(ClustC);
117          TIntV CptDIdV; Clust-&gt;GetDIdV(CptDIdV);
118          NewConceptV.Add(TOntoConcept::New(BowDocBs,
119              BowDocWgtBs, UniqueId-&gt;GetNextId(), CptDIdV));
120      }
121  }
122  void TOntoAlg::SuggestCat(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
123          const TIntV&amp; DIdV, PUniqueId UniqueId, TOntoConceptV&amp; NewConceptV) {
124      TIntIntVH CIdDIdVH;
125      for (int DocN = 0; DocN &lt; DIdV.Len(); DocN++) {
126          const int DId = DIdV[DocN];
127          const int DocCIds = BowDocBs-&gt;GetDocCIds(DId);
128          for (int DocCIdN = 0; DocCIdN &lt; DocCIds; DocCIdN++) {
129              const int DocCId = BowDocBs-&gt;GetDocCId(DId, DocCIdN);
130              if (CIdDIdVH.IsKey(DocCId)) {
131                  CIdDIdVH.GetDat(DocCId).Add(DId);
132              } else {
133                  CIdDIdVH.AddDat(DocCId, TIntV::GetV(DId));
134              }
135          }
136      }
137      TIntKdV DocsKeyIdV(CIdDIdVH.Len(), 0);
138      int KeyId = CIdDIdVH.FFirstKeyId();
139      while (CIdDIdVH.FNextKeyId(KeyId)) {
140          const int Docs = CIdDIdVH[KeyId].Len();
141          DocsKeyIdV.Add(TIntKd(Docs, KeyId));
142      }
143      DocsKeyIdV.Sort(false);
144      NewConceptV.Gen(CIdDIdVH.Len(), 0);
145      for (int CptN = 0; CptN &lt; DocsKeyIdV.Len(); CptN++) {
146          const int CptKeyId = DocsKeyIdV[CptN].Dat;
147          const TIntV&amp; CptDIdV = CIdDIdVH[CptKeyId];
148          TStr CptNm = BowDocBs-&gt;GetCatNm(CIdDIdVH.GetKey(CptKeyId));
149          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
150              UniqueId-&gt;GetNextId(), CptNm, CptDIdV));
151      }
152  }
153  void TOntoAlg::SuggestLwOntoCfier(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
154          const TIntV&amp; DIdV, PLwOntoCfier LwOntoCfier, const int&amp; _NewConcepts, 
155          PUniqueId UniqueId, TOntoConceptV&amp; NewConceptV) {
156      TIntH TermIdFqH; TIntIntVH TermIdDIdVH;
157      for (int DIdN = 0; DIdN &lt; DIdV.Len(); DIdN++) {
158          const int DId = DIdV[DIdN];
159          TStr DocStr = BowDocBs-&gt;GetDocStr(DId);
160          TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
161          LwOntoCfier-&gt;ClassifyStr(DocStr, SimTermIdPrV);
162          if (!SimTermIdPrV.Empty()) { 
163              const int TermId = SimTermIdPrV[0].Val2;
164              if (TermIdFqH.IsKey(TermId)) { 
165                  TermIdFqH(TermId)++; 
166                  TermIdDIdVH(TermId).Add(DId);
167              } else { 
168                  TermIdFqH.AddDat(TermId, 1); 
169                  TermIdDIdVH.AddDat(TermId, TIntV::GetV(DId));
170              }
171          }
172      }
173      TIntPrV TermFqIdV; TermIdFqH.GetDatKeyPrV(TermFqIdV); TermFqIdV.Sort(false);
174      const int NewConcepts = TInt::GetMn(_NewConcepts, TermFqIdV.Len());
175      NewConceptV.Gen(NewConcepts, 0);
176      PLwTermBs TermBs = LwOntoCfier-&gt;GetLwOnto()-&gt;GetTermBs();
177      for (int NewConceptN = 0; NewConceptN &lt; NewConcepts; NewConceptN++) {
178          const int TermId = TermFqIdV[NewConceptN].Val2;
179          const TIntV&amp; CptDIdV = TermIdDIdVH(TermId);
180          TStr TermNm = TermBs-&gt;GetTerm(TermId)-&gt;GetTermNm();
181          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
182              UniqueId-&gt;GetNextId(), TermNm, CptDIdV));
183      }
184  }
185  TStr TOntoExportPTO::GetUri(const int&amp; Id, const TStr&amp; Nm) {
186      TChA CleanChA; bool ToUc = true;
187      for (int ChN = 0; ChN &lt; Nm.Len(); ChN++) {
188          char Ch = Nm[ChN];
189          if (TCh::IsAlpha(Ch)) { 
190              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
191              CleanChA += Ch; 
192          } else { ToUc = true; }
193      }
194      return TInt::GetStr(Id) + &quot;_&quot; + TStr(CleanChA);
195  }
196  void TOntoExportPTO::StartExport() {
197      SOut-&gt;PutStrLn(&quot;&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;&quot;);
198      SOut-&gt;PutStrLn(&quot;&quot;);
199      SOut-&gt;PutStrLn(&quot;&lt;!DOCTYPE rdf:RDF [&quot;);
200      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY rdf  &#x27;http:&amp;bsol;&amp;bsol;www.w3.org/1999/02/22-rdf-syntax-ns#&#x27;&gt;&quot;);
201      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY rdfs &#x27;http:&amp;bsol;&amp;bsol;www.w3.org/2000/01/rdf-schema#&#x27;&gt;&quot;);
202      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY owl  &#x27;http:&amp;bsol;&amp;bsol;www.w3.org/2002/07/owl#&#x27;&gt;&quot;);
203      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY xsd  &#x27;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema#&#x27; &gt;&quot;);
204      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY ptop &#x27;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protont#&#x27;&gt;&quot;);
205      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY psys &#x27;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protons#&#x27;&gt;&quot;);
206      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY protonkm  &#x27;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protonkm#&#x27;&gt;&quot;);
207      if (DigLibP) { SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY diglib &#x27;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protons#&#x27;&gt;&quot;); }
208      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY jsikm  &#x27;http:&amp;bsol;&amp;bsol;kt.ijs.si/blazf/jsikm#&#x27;&gt;&quot;);
209      SOut-&gt;PutStrLn(&quot;]&gt;&quot;);
210      SOut-&gt;PutStrLn(&quot;&quot;);
211      SOut-&gt;PutStrLn(&quot;&lt;rdf:RDF&quot;);
212      SOut-&gt;PutStrLn(&quot;    xmlns:owl=\&quot;&amp;owl;\&quot;&quot;);
213      SOut-&gt;PutStrLn(&quot;    xmlns:rdf=\&quot;&amp;rdf;\&quot;&quot;);
214      SOut-&gt;PutStrLn(&quot;    xmlns:rdfs=\&quot;&amp;rdfs;\&quot;&quot;);
215      SOut-&gt;PutStrLn(&quot;    xmlns:psys=\&quot;&amp;psys;\&quot;&quot;);
216      SOut-&gt;PutStrLn(&quot;    xmlns:ptop=\&quot;&amp;ptop;\&quot;&quot;);
217      SOut-&gt;PutStrLn(&quot;    xmlns:protonkm=\&quot;&amp;protonkm;\&quot;&quot;);
218      SOut-&gt;PutStrLn(&quot;    xmlns=\&quot;&amp;protonkm;\&quot;&quot;);
219      if (DigLibP) { SOut-&gt;PutStrLn(&quot;    xmlns:diglib=\&quot;&amp;diglib;\&quot;&quot;); }
220      SOut-&gt;PutStrLn(&quot;    xmlns:jsikm=\&quot;&amp;jsikm;\&quot;&quot;);
221      SOut-&gt;PutStrLn(&quot;    xml:base=\&quot;&amp;protonkm;\&quot;&quot;); 
222      SOut-&gt;PutStrLn(&quot;&gt;&quot;);
223      SOut-&gt;PutStrLn(&quot;&quot;);
224      SOut-&gt;PutStrLn(&quot;&lt;owl:Ontology rdf:about=\&quot;\&quot;&gt;&quot;);
225      SOut-&gt;PutStrLn(&quot;  &lt;rdfs:comment&gt;PROTON Topics (from Inspec Thesaurus) ordered by algorithm X&lt;/rdfs:comment&gt;&quot;);
226      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protons\&quot;/&gt;&quot;);
227      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protont\&quot;/&gt;&quot;);
228      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protonu\&quot;/&gt;&quot;);
229      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protonkm\&quot;/&gt;&quot;);
230      if (DigLibP) { SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;kt.ijs.si/blazf/jsikm\&quot;/&gt;&quot;); }
231      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;kt.ijs.si/blazf/jsikm\&quot;/&gt;&quot;);
232      SOut-&gt;PutStrLn(&quot;  &lt;owl:versionInfo&gt;\&quot;0.1\&quot;&lt;/owl:versionInfo&gt;&quot;);
233      SOut-&gt;PutStrLn(&quot;&lt;/owl:Ontology&gt;&quot;);
234      SOut-&gt;PutStrLn(&quot;&quot;);
235  }
236  void TOntoExportPTO::EndExport() {
237      SOut-&gt;PutStrLn(&quot;&lt;/rdf:RDF&gt;&quot;);
238      SOut-&gt;Flush();
239  }
240  void TOntoExportPTO::PutCpt(const int&amp; CptId, const TStr CptNm, 
241          const TIntStrPrV&amp; SubCptIdNmV, const TIntStrPrV&amp; SuperCptIdNmV, const TIntV&amp; DIdV, 
242          PBowDocBs BowDocBs, PBowSpV KeyWdSpV, PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
243      SOut-&gt;PutStrLn(&quot;&lt;ptop:Topic rdf:about=\&quot;#Cpt&quot; + GetUri(CptId, CptNm) + &quot;\&quot;&gt;&quot;);
244      SOut-&gt;PutStrLn(&quot;  &lt;psys:description&gt;&quot; + CptNm + &quot;&lt;/psys:description&gt;&quot;);
245      for (int SuperCptN = 0; SuperCptN &lt; SuperCptIdNmV.Len(); SuperCptN++) {
246          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
247          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
248          SOut-&gt;PutStrLn(&quot;  &lt;ptop:subTopicOf rdf:resource=\&quot;#Cpt&quot; + 
249              GetUri(SuperCptId, SuperCptNm) + &quot;\&quot; /&gt;&quot;);
250      }
251      if (DigLibP) {
252          for (int DIdN = 0; DIdN &lt; DIdV.Len(); DIdN++) {
253              const int DId = DIdV[DIdN];
254              TStr DNm = BowDocBs-&gt;GetDocNm(DId);
255              SOut-&gt;PutStrLn(&quot;  &lt;diglib:hasArticle rdf:resource=\&quot;#Doc&quot; + 
256                  GetUri(DId, DNm) + &quot;\&quot; /&gt;&quot;);
257          }
258      }
259      SOut-&gt;PutStrLn(TStr::Fmt(&quot;  &lt;jsikm:hasOntoGenClassProperties rdf:resource=\&quot;#CLS_PROP_%d\&quot; /&gt;&quot;, CptId));
260      SOut-&gt;PutStrLn(&quot;&lt;/ptop:Topic&gt;&quot;);
261      SOut-&gt;PutStrLn(TStr::Fmt(&quot;&lt;jsikm:OntoGenClassProperties rdf:about=\&quot;#CLS_PROP_%d\&quot;&gt;&quot;, CptId));
262      TStr KeyWdStr = KeyWdSpV-&gt;GetStr(BowDocBs, 10, 1.0, &quot;, &quot;, false, true);
263      SOut-&gt;PutStrLn(&quot;  &lt;jsikm:hasCentroidKeywords&gt;&quot; + KeyWdStr + &quot;&lt;/jsikm:hasCentroidKeywords&gt;&quot;);
264      TStr SvmKeyWdStr = SvmKeyWdSpV-&gt;GetStr(BowDocBs, 10, 1.0, &quot;, &quot;, false, true);
265      SOut-&gt;PutStrLn(&quot;  &lt;jsikm:hasSVMKeywords&gt;&quot; + SvmKeyWdStr + &quot;&lt;/jsikm:hasSVMKeywords&gt;&quot;);
266      SOut-&gt;PutStrLn(&quot;&lt;/jsikm:OntoGenClassProperties&gt;&quot;);
267      SOut-&gt;PutStrLn(&quot;&quot;);
268  }
269  void TOntoExportPTO::PutDoc(const int&amp; DId, const TStr&amp; DocTitle, 
270          const TStr&amp; DocAbstract, const TIntStrPrV&amp; CptIdNmV) {
271      SOut-&gt;PutStrLn(&quot;&lt;ptop:Document rdf:about=\&quot;#Doc&quot; + GetUri(DId, DocTitle) + &quot;\&quot;&gt;&quot;);
272      for (int CptIdN = 0; CptIdN &lt; CptIdNmV.Len(); CptIdN++) {
273          const int CptId = CptIdNmV[CptIdN].Val1;
274          TStr CptNm = CptIdNmV[CptIdN].Val2;
275          SOut-&gt;PutStrLn(&quot;  &lt;ptop:hasSubject rdf:resource=\&quot;#Cpt&quot; + 
276              GetUri(CptId, CptNm) + &quot;\&quot; /&gt;&quot;);
277      }
278      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
279      CleanDocAbstract.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;); CleanDocAbstract.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;);
280      SOut-&gt;PutStrLn(TStr::Fmt(&quot;  &lt;ptop:documentAbstract&gt;%s&lt;/ptop:documentAbstract&gt;&quot;, CleanDocAbstract.CStr()));
281      SOut-&gt;PutStrLn(TStr::Fmt(&quot;  &lt;jsikm:hasOntoGenInstanceProperties rdf:resource=\&quot;#INST_PROP_%d\&quot; /&gt;&quot;, DId));
282      SOut-&gt;PutStrLn(&quot;&lt;/ptop:Document&gt;&quot;);
283      TStr ShortBowFNm = BowFNmStr.GetFMid() + BowFNmStr.GetFExt();
284      SOut-&gt;PutStrLn(TStr::Fmt(&quot;&lt;jsikm:OntoGenInstanceProperties rdf:about=\&quot;#INST_PROP_%d\&quot;&gt;&quot;, DId));
285      SOut-&gt;PutStrLn(TStr::Fmt(&quot;  &lt;jsikm:locationOfInstance&gt;%s#%d&lt;/jsikm:locationOfInstance&gt;&quot;, ShortBowFNm.CStr(), DId));
286      SOut-&gt;PutStrLn(&quot;&lt;/jsikm:OntoGenInstanceProperties&gt;&quot;);
287      SOut-&gt;PutStrLn(&quot;&quot;);
288  }
289  void TOntoExportProlog::StartExport() {
290      SOut-&gt;PutStrLn(&quot;% OntoGen export in Prolog.&quot;);
291  }
292  void TOntoExportProlog::EndExport() {
293      SOut-&gt;Flush();
294  }
295  void TOntoExportProlog::PutCpt(const int&amp; CptId, const TStr CptNm, 
296          const TIntStrPrV&amp; SubCptIdNmV, const TIntStrPrV&amp; SuperCptIdNmV, 
297          const TIntV&amp; DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
298          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
299      SOut-&gt;PutStrLn(TStr::Fmt(&quot;class( %s, label, &#x27;%s&#x27; ).&quot;, 
300          GetCptLabel(CptId).CStr(), CptNm.CStr()));
301      for (int SuperCptN = 0; SuperCptN &lt; SuperCptIdNmV.Len(); SuperCptN++) {
302          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
303          SOut-&gt;PutStrLn(TStr::Fmt(&quot;subClassOf( %s, %s ).&quot;, 
304              GetCptLabel(CptId).CStr(), GetCptLabel(SuperCptId).CStr()));
305      }
306  }
307  void TOntoExportProlog::PutDoc(const int&amp; DId, const TStr&amp; DocTitle, 
308          const TStr&amp; DocAbstract, const TIntStrPrV&amp; CptIdNmV) {
309      TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll(&#x27;\&#x27;&#x27;);
310      CleanDocTitle.DelChAll(&#x27;\n&#x27;); CleanDocTitle.DelChAll(&#x27;\r&#x27;);
311      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
312      CleanDocAbstract.DelChAll(&#x27;\&#x27;&#x27;); CleanDocAbstract.DelChAll(&#x27;\n&#x27;); 
313      CleanDocAbstract.DelChAll(&#x27;\r&#x27;);
314      SOut-&gt;PutStrLn(TStr::Fmt(&quot;instance( %s, label, &#x27;%s&#x27; ).&quot;, 
315          GetInstLabel(DId).CStr(), CleanDocTitle.CStr()));
316      SOut-&gt;PutStrLn(TStr::Fmt(&quot;instance( %s, text, &#x27;%s&#x27; ).&quot;, 
317          GetInstLabel(DId).CStr(), CleanDocAbstract.CStr()));
318      for (int CptIdN = 0; CptIdN &lt; CptIdNmV.Len(); CptIdN++) {
319          const int CptId = CptIdNmV[CptIdN].Val1;
320          SOut-&gt;PutStrLn(TStr::Fmt(&quot;instanceOf( %s, %s ).&quot;, 
321              GetInstLabel(DId).CStr(), GetCptLabel(CptId).CStr()));
322      }
323  }
324  TStr TOntoExportOWL::GetUri(const int&amp; Id, const TStr&amp; Nm) {
325      TChA CleanChA; bool ToUc = true;
326      for (int ChN = 0; ChN &lt; Nm.Len(); ChN++) {
327          char Ch = Nm[ChN];
328          if (TCh::IsAlpha(Ch)) { 
329              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
330              CleanChA += Ch; 
331          } else { ToUc = true; }
332      }
333      return TInt::GetStr(Id) + &quot;_&quot; + TStr(CleanChA);
334  }
335  void TOntoExportOWL::StartExport() {
336      SOut-&gt;PutStrLn(&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&quot;);
337      SOut-&gt;PutStrLn(&quot;&lt;rdf:RDF&quot;);
338      SOut-&gt;PutStrLn(&quot;    xmlns:rdf=\&quot;http:&amp;bsol;&amp;bsol;www.w3.org/1999/02/22-rdf-syntax-ns#\&quot;&quot;);
339      SOut-&gt;PutStrLn(&quot;    xmlns:xsd=\&quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema#\&quot;&quot;);
340      SOut-&gt;PutStrLn(&quot;    xmlns:rdfs=\&quot;http:&amp;bsol;&amp;bsol;www.w3.org/2000/01/rdf-schema#\&quot;&quot;);
341      SOut-&gt;PutStrLn(&quot;    xmlns:owl=\&quot;http:&amp;bsol;&amp;bsol;www.w3.org/2002/07/owl#\&quot;&quot;);
342      SOut-&gt;PutStrLn(&quot;    xmlns=\&quot;http:&amp;bsol;&amp;bsol;www.owl-ontologies.com/Ontology1150050933.owl#\&quot;&quot;);
343      SOut-&gt;PutStrLn(&quot;    xml:base=\&quot;http:&amp;bsol;&amp;bsol;www.owl-ontologies.com/Ontology1150050933.owl\&quot;&gt;&quot;);
344      SOut-&gt;PutStrLn(&quot;&quot;);
345      SOut-&gt;PutStrLn(&quot;&lt;owl:Ontology rdf:about=\&quot;OntoGen OWL export\&quot;/&gt;&quot;);
346      SOut-&gt;PutStrLn(&quot;&quot;);
347  }
348  void TOntoExportOWL::EndExport() {
349      SOut-&gt;PutStrLn(&quot;&quot;);
350      SOut-&gt;PutStrLn(&quot;&lt;/rdf:RDF&gt;&quot;);
351      SOut-&gt;Flush();
352  }
353  void TOntoExportOWL::PutCpt(const int&amp; CptId, const TStr CptNm, 
354          const TIntStrPrV&amp; SubCptIdNmV, const TIntStrPrV&amp; SuperCptIdNmV, 
355          const TIntV&amp; DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
356          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
357      SOut-&gt;PutStrLn(&quot;&lt;owl:Class rdf:ID=\&quot;Cpt&quot; + GetUri(CptId, CptNm) + &quot;\&quot;&gt;&quot;);
358      SOut-&gt;PutStrLn(&quot;  &lt;rdfs:label&gt;&quot; + CptNm + &quot;&lt;/rdfs:label&gt;&quot;);
359      for (int SuperCptN = 0; SuperCptN &lt; SuperCptIdNmV.Len(); SuperCptN++) {
360          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
361          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
362          SOut-&gt;PutStrLn(&quot;  &lt;rdfs:subClassOf rdf:resource=\&quot;#Cpt&quot; + 
363              GetUri(SuperCptId, SuperCptNm) + &quot;\&quot;/&gt;&quot;);
364      }
365      SOut-&gt;PutStrLn(&quot;&lt;/owl:Class&gt;&quot;);
366      SOut-&gt;PutStrLn(&quot;&quot;);
367  }
368  void TOntoExportOWL::PutDoc(const int&amp; DId, const TStr&amp; DocTitle, 
369          const TStr&amp; DocAbstract, const TIntStrPrV&amp; CptIdNmV) {
370      if (!StoreDocsP) { return; }
371      for (int CptIdN = 0; CptIdN &lt; CptIdNmV.Len(); CptIdN++) {
372          const int CptId = CptIdNmV[CptIdN].Val1;
373          TStr CptNm = CptIdNmV[CptIdN].Val2;
374          SOut-&gt;PutStrLn(&quot;&lt;Cpt&quot; + GetUri(CptId, CptNm) + &quot; rdf:ID=\&quot;Doc&quot; + 
375              GetUri(DId, DocTitle) + &quot;\&quot;&gt;&quot;);
376          if (CptIdN == 0) {
377              TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll(&#x27;\&#x27;&#x27;);
378              CleanDocTitle.DelChAll(&#x27;\n&#x27;); CleanDocTitle.DelChAll(&#x27;\r&#x27;);
379              SOut-&gt;PutStrLn(&quot;  &lt;rdfs:label&gt;&quot; + CleanDocTitle + &quot;&lt;/rdfs:label&gt;&quot;);
380              if (StoreAbstractsP) {
381                  TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
382                  CleanDocAbstract.DelChAll(&#x27;\&#x27;&#x27;); CleanDocAbstract.DelChAll(&#x27;\n&#x27;); 
383                  CleanDocAbstract.DelChAll(&#x27;\r&#x27;);
384                  SOut-&gt;PutStrLn(&quot;  &lt;rdfs:comment&gt;&quot; + CleanDocAbstract + &quot;&lt;/rdfs:label&gt;&quot;);
385              }
386          }
387          SOut-&gt;PutStrLn(&quot;&lt;/Cpt&quot; + GetUri(CptId, CptNm) + &quot;&gt;&quot;);
388      }
389      SOut-&gt;PutStrLn(&quot;&quot;);
390  }
391  void TOntoExportOWL::PutRltType(const TStr&amp; RltNm, const bool&amp; DirectedP,
392          const bool&amp; TransitiveP) {
393      SOut-&gt;PutStrLn(&quot;&lt;owl:ObjectProperty rdf:ID=\&quot;&quot; + RltNm + &quot;\&quot;/&gt;&quot;);
394      SOut-&gt;PutStrLn(&quot;&quot;);    
395  }
396  void TOntoExportOWL::PutRlt(const TStr&amp; RltNm, const int&amp; SrcCptId, 
397          const TStr SrcCptNm, const int&amp; DstCptId, const TStr DstCptNm) {
398      SOut-&gt;PutStrLn(&quot;&lt;owl:Class rdf:ID=\&quot;Cpt&quot; + GetUri(SrcCptId, SrcCptNm) + &quot;\&quot;&gt;&quot;);
399      SOut-&gt;PutStrLn(&quot;  &lt;rdfs:subClassOf&gt;&lt;owl:Restriction&gt;&quot;);
400      SOut-&gt;PutStrLn(&quot;    &lt;owl:onProperty rdf:resource=\&quot;#&quot; + RltNm + &quot;\&quot;/&gt;&quot;);
401      SOut-&gt;PutStrLn(&quot;    &lt;owl:someValuesFrom&gt;&quot;);
402      SOut-&gt;PutStrLn(&quot;      &lt;owl:Class rdf:ID=\&quot;Cpt&quot; + GetUri(DstCptId, DstCptNm) + &quot;\&quot;/&gt;&quot;);
403      SOut-&gt;PutStrLn(&quot;    &lt;/owl:someValuesFrom&gt;&quot;);
404      SOut-&gt;PutStrLn(&quot;  &lt;/owl:Restriction&gt;&lt;/rdfs:subClassOf&gt;&quot;);
405      SOut-&gt;PutStrLn(&quot;&lt;/owl:Class&gt;&quot;);
406      SOut-&gt;PutStrLn(&quot;&quot;);    
407  }
408  TOntology::TOntology(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs, 
409      const TBowSimType&amp; BowSimType): BowDocBs(_BowDocBs), 
410          BowDocWgtBs(_BowDocWgtBs) {
411      BowSim = TBowSim::New(BowSimType);
412      OntoGraph = TGGraph::New();
413      UniqueId = TUniqueId::New(0);
414      GenerateEmptyOnto();
415  }
416  void TOntology::GenerateEmptyOnto() {
417      TIntV AllDIdV; BowDocBs-&gt;GetAllDIdV(AllDIdV);
418      POntoConcept RootCpt = TOntoConcept::New(BowDocBs, 
419          BowDocWgtBs, UniqueId-&gt;GetNextId(), AllDIdV);
420      RootCpt-&gt;SetName(&quot;root&quot;);
421      AddConcept(RootCpt, -1);
422      OntoGraph-&gt;GetPp()-&gt;AddPpStr(&quot;BoldVNm&quot;, &quot;&quot;, &quot;root&quot;);
423      RltTypeV.Add(TOntoRltType(TOntoRltType::SubCptOfRltStr, true, true));
424      RltTypeV.Add(TOntoRltType(TOntoRltType::SimilarRltStr, false, false));
425  }
426  void TOntology::RefreshCptIdPosH() {
427      CptIdPosH.Clr();
428      for (int CptC = 0; CptC &lt; ConceptV.Len(); CptC++) {
429          const int CptId = ConceptV[CptC]-&gt;GetId();
430          IAssertR(!CptIdPosH.IsKey(CptId), &quot;Concept ID not unique!&quot;);
431          CptIdPosH.AddDat(CptId, CptC);
432      }
433  }
434  void TOntology::ReconnectToRoot() {
435      for (int CptC = 0; CptC &lt; ConceptV.Len(); CptC++) {
436          const int CptId = ConceptV[CptC]-&gt;GetId();
437          if (!IsRootCpt(CptId) &amp;&amp; !HasSuperCpt(CptId)) {
438              AddRlt(CptId, 0, TOntoRltType::SubCptOfRltStr);
439          }
440      }
441  }
442  void TOntology::AddRltsFromList(TIntStrPrV&amp; InRltV, 
443          TIntStrPrV&amp; OutRltV, TIntStrPrV&amp; UndirRltV) {
444      for (int InEdN = 0; InEdN &lt; InRltV.Len(); InEdN++) {
445          const int CptId1 = InRltV[InEdN].Val1;
446          TStr RltNm1 = InRltV[InEdN].Val2; Assert(IsRltDir(RltNm1));
447          for (int OutEdN = 0; OutEdN &lt; OutRltV.Len(); OutEdN++) {
448              const int CptId2 = OutRltV[OutEdN].Val1;
449              TStr RltNm2 = OutRltV[OutEdN].Val2; Assert(IsRltDir(RltNm2));
450              if (CptId1 != CptId2 &amp;&amp; RltNm1 == RltNm2) {
451                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
452                  if (!IsRltTransitive(RltNm1)) continue;
453                  AddRlt(CptId1, CptId2, RltNm1);
454              }
455          }
456      }
457      for (int InEdN = 0; InEdN &lt; UndirRltV.Len(); InEdN++) {
458          const int CptId1 = UndirRltV[InEdN].Val1;
459          TStr RltNm1 = UndirRltV[InEdN].Val2; Assert(!IsRltDir(RltNm1));
460          for (int OutEdN = 0; OutEdN &lt; UndirRltV.Len(); OutEdN++) {
461              const int CptId2 = UndirRltV[OutEdN].Val1;
462              TStr RltNm2 = UndirRltV[OutEdN].Val2; Assert(!IsRltDir(RltNm2));
463              if (CptId1 != CptId2 &amp;&amp; RltNm1 == RltNm2) {
464                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
465                  if (!IsRltTransitive(RltNm1)) continue;
466                  AddRlt(CptId1, CptId2, RltNm1);
467              }
468          }
469      }
470  }
471  void TOntology::AddSonDIdV(const int&amp; CptId, TIntV&amp; SonDIdV) {
472      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
473      for (int SubCptIdN = 0; SubCptIdN &lt; SubCptIdV.Len(); SubCptIdN++) {
474          const int SubCptId = SubCptIdV[SubCptIdN];
475          TIntV SubCptDIdV; GetCptDIdV(SubCptId, SubCptDIdV);
476          SonDIdV.Union(SubCptDIdV);
477          AddSonDIdV(SubCptId, SonDIdV);
478      }
479  }
480  void TOntology::CfyDIdR(const int&amp; DId, const TIntV&amp; CptIdV, TIntFltKdV&amp; CfyResV) {
481      for (int CptIdN = 0; CptIdN &lt; CptIdV.Len(); CptIdN++) {
482          const int CptId = CptIdV[CptIdN];
483          POntoConcept Cpt = GetConcept(CptId);
484          if (Cpt-&gt;IsCptMd()) {
485              bool IsDocInCpt; double Prob;
486              Cpt-&gt;CfyDocSpV(BowDocWgtBs-&gt;GetSpV(DId), IsDocInCpt, Prob);
487              if (IsDocInCpt) {
488                  CfyResV.Add(TIntFltKd(CptId, Prob));
489                  TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
490                  CfyDIdR(DId, SubCptIdV, CfyResV);
491              }
492          }
493      }
494  }
495  void TOntology::Export(POntoExport OntoExport) {
496      OntoExport-&gt;StartExport();
497      TIntV CptIdV; GetCptIdV(CptIdV);
498      TIntIntVH DIdCptIdVH;
499      for (int CptN = 0; CptN &lt; CptIdV.Len(); CptN++) {
500          const int CptId = CptIdV[CptN];
501          TStr CptNm = TXmlDoc::GetXmlStr(GetCptName(CptId));
502          if (OntoExport-&gt;IsCptAlwaysSvm()) { ExtractKeywords(CptId); }
503          TIntStrPrV SubCptIdNmV;
504          if (OntoExport-&gt;IsCptSubCptLink()) {
505              TIntStrPrV CptInRltV; GetCptInRltV(CptId, CptInRltV);
506              for (int SubCptN = 0; SubCptN &lt; CptInRltV.Len(); SubCptN++) {
507                  TStr RltNm = CptInRltV[SubCptN].Val2;
508                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
509                      const int SubCptId = CptInRltV[SubCptN].Val1;
510                      TStr SubCptNm = GetCptName(SubCptId);
511                      SubCptIdNmV.Add(TIntStrPr(SubCptId, SubCptNm));
512                  }
513              }
514          }
515          TIntStrPrV SuperCptIdNmV;
516          if (OntoExport-&gt;IsCptSuperCptLink()) {
517              TIntStrPrV CptOutRltV; GetCptOutRltV(CptId, CptOutRltV);
518              for (int SuperCptN = 0; SuperCptN &lt; CptOutRltV.Len(); SuperCptN++) {
519                  TStr RltNm = CptOutRltV[SuperCptN].Val2;
520                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
521                      const int SuperCptId = CptOutRltV[SuperCptN].Val1;
522                      TStr SuperCptNm = GetCptName(SuperCptId);
523                      SuperCptIdNmV.Add(TIntStrPr(SuperCptId, SuperCptNm));
524                  }
525              }
526          }
527          TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
528          for (int DocN = 0; DocN &lt; CptDIdV.Len(); DocN++) {
529              const int DId = CptDIdV[DocN];
530              if (DIdCptIdVH.IsKey(DId)) {
531                  DIdCptIdVH.GetDat(DId).Add(CptId);
532              } else {
533                  DIdCptIdVH.AddDat(DId, TIntV::GetV(CptId));
534              }
535          }
536          if (!OntoExport-&gt;IsCptDocLink()) { CptDIdV.Clr(); }
537          OntoExport-&gt;PutCpt(CptId, CptNm, SubCptIdNmV, SuperCptIdNmV, 
538              CptDIdV, BowDocBs, GetConcept(CptId)-&gt;GetCentroidSpV(), 
539              GetConcept(CptId)-&gt;GetSvmSpV(), TBowSpV::New(-1));
540      }
541      TIntV AllDIdV; BowDocBs-&gt;GetAllDIdV(AllDIdV);
542      for (int DocN = 0; DocN &lt; AllDIdV.Len(); DocN++) {
543          const int DId = AllDIdV[DocN];
544          TStr DocTitle = BowDocBs-&gt;GetDocNm(DId);
545          TStr DocAbstract = BowDocBs-&gt;GetDocStr(DId);
546          TIntStrPrV CptIdNmV;
547          if (DIdCptIdVH.IsKey(DId) &amp;&amp; OntoExport-&gt;IsDocCptLink()) {
548              TIntV&amp; DocCptIdV = DIdCptIdVH.GetDat(DId);
549              for (int DocCptIdN = 0; DocCptIdN &lt; DocCptIdV.Len(); DocCptIdN++) {
550                  const int CptId = DocCptIdV[DocCptIdN];
551                  TStr CptNm = GetCptName(CptId);
552                  CptIdNmV.Add(TIntStrPr(CptId, CptNm));
553              }
554          }
555          OntoExport-&gt;PutDoc(DId, DocTitle, DocAbstract, CptIdNmV);
556      }        
557      if (OntoExport-&gt;IsRlt()) {
558          const int RltTypes = GetRltTypes();
559          for (int RltTypeN = 0; RltTypeN &lt; RltTypes; RltTypeN++) {
560              TStr RltTypeNm = GetRltTypeNm(RltTypeN);
561              if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
562                  OntoExport-&gt;PutRltType(RltTypeNm, 
563                      IsRltDir(RltTypeNm), IsRltTransitive(RltTypeNm));
564              }
565          }
566          for (int CptN = 0; CptN &lt; CptIdV.Len(); CptN++) {
567              const int SrcCptId = CptIdV[CptN];
568              TStr SrcCptNm = GetCptName(SrcCptId);
569              TIntStrPrV CptOutRltV; GetCptOutRltV(SrcCptId, CptOutRltV);
570              for (int OutRltN = 0; OutRltN &lt; CptOutRltV.Len(); OutRltN++) {
571                  const TStr&amp; RltTypeNm = CptOutRltV[OutRltN].Val2;
572                  if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
573                      const int DstCptId = CptOutRltV[OutRltN].Val1;
574                      OntoExport-&gt;PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
575                          DstCptId, GetCptName(DstCptId));
576                  }
577              }
578              TIntStrPrV CptUndirRltV; GetCptUndirRltV(SrcCptId, CptUndirRltV);
579              for (int UndirRltN = 0; UndirRltN &lt; CptUndirRltV.Len(); UndirRltN++) {
580                  const TStr&amp; RltTypeNm = CptUndirRltV[UndirRltN].Val2;
581                  const int DstCptId = CptUndirRltV[UndirRltN].Val1;
582                  if (SrcCptId &lt; DstCptId) {
583                      OntoExport-&gt;PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
584                          DstCptId, GetCptName(DstCptId));
585                  }
586              }
587          }
588      }
589      OntoExport-&gt;EndExport();
590  }
591  void TOntology::GetCptIdV(TIntV&amp; CptIdV) {
592      CptIdV.Gen(ConceptV.Len(), 0);
593      for (int CptIdN = 0; CptIdN &lt; ConceptV.Len(); CptIdN++) {
594          CptIdV.Add(ConceptV[CptIdN]-&gt;GetId());
595      }
596      CptIdV.Sort();
597  }
598  void TOntology::SetCptName(const int&amp; CptId, const TStr&amp; NewName) {
599      GetConcept(CptId)-&gt;SetName(NewName);
600      OntoGraph-&gt;GetVrtx(CptId)-&gt;PutDNm(NewName);
601  }
602  void TOntology::SetCptDIdV(const int&amp; CptId, const TIntV&amp; _NewDIdV, const bool&amp; PropagateP) {
603      if (PropagateP) {
604          TIntV NewDIdV = _NewDIdV;
605          if (!NewDIdV.IsSorted()) { NewDIdV.Sort(); }
606          TIntV OldDIdV; GetCptDIdV(CptId, OldDIdV);
607          TIntV BothDIdV; OldDIdV.Union(NewDIdV, BothDIdV);
608          TIntV AddDIdV; BothDIdV.Diff(OldDIdV, AddDIdV);
609          AddUpDIdV(CptId, AddDIdV);
610          TIntV DelDIdV; BothDIdV.Diff(NewDIdV, DelDIdV);
611          DelDownDIdV(CptId, DelDIdV);
612      } else {
613          GetConcept(CptId)-&gt;SetDIdV(BowDocWgtBs, _NewDIdV);
614      }
615  }
616  void TOntology::GetCptSimV(const int&amp; CptId, TFltIntKdV&amp; SimCptIdV) {
617      PBowSpV CptSpV = GetConcept(CptId)-&gt;GetCentroidSpV();
618      SimCptIdV.Gen(GetConcepts() - 1, 0);
619      for (int CptN = 0; CptN &lt; GetConcepts(); CptN++) {
620          const int CptId2 = ConceptV[CptN]-&gt;GetId();
621          if (CptId != CptId2) {
622              PBowSpV CptSpV2 = ConceptV[CptN]-&gt;GetCentroidSpV();
623              SimCptIdV.Add(TFltIntKd(BowSim-&gt;GetSim(CptSpV, CptSpV2), CptId2));
624          }
625      }
626      SimCptIdV.Sort(false);
627  }
628  void TOntology::CalcCptMd(const int&amp; CptId, const double&amp; SvmC, 
629          const double&amp; SvmJ, const int&amp; SvmTime) {
630      if (IsRootCpt(CptId)) return;
631      TIntV ContextDIdV; BowDocBs-&gt;GetAllDIdV(ContextDIdV);
632      GetConcept(CptId)-&gt;CalcCptMd(BowDocBs, ContextDIdV, SvmC, SvmJ, SvmTime);
633  }
634  void TOntology::CfyDId(const int&amp; DId, TIntFltKdV&amp; CfyResV) {
635      const int CptIds = GetConcepts(); CfyResV.Gen(CptIds, 0);
636      for (int CptIdN = 0; CptIdN &lt; CptIds; CptIdN++) {
637          const int CptId = GetCptId(CptIdN);
638          POntoConcept Cpt = GetConcept(CptId);
639          if (Cpt-&gt;IsCptMd()) {
640              bool IsDocInCpt; double Prob;
641              Cpt-&gt;CfyDocSpV(BowDocWgtBs-&gt;GetSpV(DId), IsDocInCpt, Prob);
642              if (IsDocInCpt) {
643                  CfyResV.Add(TIntFltKd(CptId, Prob));
644              } else {
645                  CfyResV.Add(TIntFltKd(CptId, Prob - 1.0));
646              }
647          } else if (IsRootCpt(CptId)) {
648              CfyResV.Add(TIntFltKd(CptId, 1.0));
649          } else {
650              CfyResV.Add(TIntFltKd(CptId, -1.0));
651          }
652      }
653      CfyResV.Sort();
654  }
655  void TOntology::IncludeLnDocs(const TStr&amp; LnDocFNm, TIntV&amp; NewDIdV) {
656      TBowFl::LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, true, -1, true);    
657      NewDIdV.Sort(); ReCalcWgtBs(); 
658      GetRootCpt()-&gt;AddDIdV(BowDocWgtBs, NewDIdV); 
659  }
660  void TOntology::IncludeFolder(const TStr&amp; FPath, TIntV&amp; NewDIdV, const bool&amp; RecurseDirP) {
661      TBowFl::LoadHtmlTxt(BowDocBs, FPath, NewDIdV, RecurseDirP, -1, true);
662      NewDIdV.Sort(); ReCalcWgtBs(); 
663      GetRootCpt()-&gt;AddDIdV(BowDocWgtBs, NewDIdV); 
664  }
665  void TOntology::AddDocToCptV(const int&amp; DId, const TIntV&amp; CptIdV, const bool&amp; UpdateCentroidP) {
666      for (int CptIdN = 0; CptIdN &lt; CptIdV.Len(); CptIdN++) {
667          const int CptId = CptIdV[CptIdN];
668          if (UpdateCentroidP) {
669              GetConcept(CptId)-&gt;AddDId(BowDocWgtBs, DId);
670          } else {
671              GetConcept(CptId)-&gt;AddDId(NULL, DId);
672          }
673      }
674  }
675  void TOntology::ResetAllCptKeyWd() {
676      const int CptIds = GetConcepts();
677      for (int CptIdN = 0; CptIdN &lt; CptIds; CptIdN++) {
678          const int CptId = GetCptId(CptIdN);
679          if (!GetConcept(CptId)-&gt;IsCentroidValid()) {
680              GetConcept(CptId)-&gt;ResetCentroidSpV(BowDocWgtBs);
681          }
682      }
683  }
684  void TOntology::GetSubCptIdV(const int&amp; CptId, TIntV&amp; SubCptIdV) {
685      TIntStrPrV InRltV; GetCptInRltV(CptId, InRltV);
686      SubCptIdV.Gen(InRltV.Len(), 0);
687      for (int InRltN = 0; InRltN &lt; InRltV.Len(); InRltN++) {
688          if (InRltV[InRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
689              SubCptIdV.Add(InRltV[InRltN].Val1);
690          }
691      }
692      SubCptIdV.Sort();
693  }
694  void TOntology::GetSuperCptIdV(const int&amp; CptId, TIntV&amp; SuperCptIdV) {
695      TIntStrPrV OutRltV; GetCptOutRltV(CptId, OutRltV);
696      SuperCptIdV.Gen(OutRltV.Len(), 0);
697      for (int OutRltN = 0; OutRltN &lt; OutRltV.Len(); OutRltN++) {
698          if (OutRltV[OutRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
699              SuperCptIdV.Add(OutRltV[OutRltN].Val1);
700          }
701      }
702      SuperCptIdV.Sort();
703  }
704  void TOntology::GetCptUnusedDIdV(const int&amp; CptId, TIntV&amp; DIdV) {
705      GetConcept(CptId)-&gt;GetDIdV(DIdV);
706      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
707      for (int SubCptN = 0; SubCptN &lt; SubCptIdV.Len(); SubCptN++) {
708          const int SubCptId = SubCptIdV[SubCptN];
709          TIntV SubDIdV; GetConcept(SubCptId)-&gt;GetDIdV(SubDIdV);
710          DIdV.Diff(SubDIdV);
711      }   
712  }
713  void TOntology::GetCptContextDIdV(const int&amp; CptId, 
714          TIntV&amp; ContextDIdV, const bool&amp; AddSonDIdP) {
715      ContextDIdV.Clr();
716      GetConcept(CptId)-&gt;GetDIdV(ContextDIdV);
717      if (HasSuperCpt(CptId)) {
718          TIntV SuperCptIdV, SuperDIdV; GetSuperCptIdV(CptId, SuperCptIdV);
719          for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
720              const int SuperCptId = SuperCptIdV[SuperCptIdN];
721              GetConcept(SuperCptId)-&gt;GetDIdV(SuperDIdV);    
722              ContextDIdV.Union(SuperDIdV);
723          }
724      }
725      if (AddSonDIdP) AddSonDIdV(CptId, ContextDIdV);
726  }
727  void TOntology::GetInconsistDIdV(const int&amp; CptId, TIntV&amp; InconsistDIdV) {
728      InconsistDIdV.Clr();
729      TIntV SonDIdV; AddSonDIdV(CptId, SonDIdV);
730      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
731      SonDIdV.Union(CptDIdV); 
732      SonDIdV.Diff(CptDIdV, InconsistDIdV);
733  }
734  void TOntology::GetCptDocSimV(const int&amp; CptId, const TIntV&amp; DIdV, TFltV&amp; CptDocSimV) {
735      PBowSpV CptSpV = GetConcept(CptId)-&gt;GetCentroidSpV();
736      const int Docs = DIdV.Len(); CptDocSimV.Gen(Docs, 0);
737      for (int DocN = 0; DocN &lt; Docs; DocN++) {
738          PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DIdV[DocN]);
739          CptDocSimV.Add(BowSim-&gt;GetSim(CptSpV, DocSpV));
740      }
741  }
742  void TOntology::AddUpDIdV(const int&amp; CptId, const TIntV&amp; SubDIdV) {
743      GetConcept(CptId)-&gt;AddDIdV(BowDocWgtBs, SubDIdV);
744      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
745      for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
746          const int SuperCptId = SuperCptIdV[SuperCptIdN];
747          if (!IsRootCpt(SuperCptId)) { AddUpDIdV(SuperCptId, SubDIdV); }
748      }
749  }
750  void TOntology::DelUpDIdV(const int&amp; CptId, const TIntV&amp; SubDIdV) {
751      GetConcept(CptId)-&gt;DelDIdV(BowDocWgtBs, SubDIdV);
752      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
753      for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
754          const int SuperCptId = SuperCptIdV[SuperCptIdN];
755          if (!IsRootCpt(SuperCptId)) { DelUpDIdV(SuperCptId, SubDIdV); }
756      }
757  }
758  void TOntology::DelDownDIdV(const int&amp; CptId, const TIntV&amp; SubDIdV) {
759      GetConcept(CptId)-&gt;DelDIdV(BowDocWgtBs, SubDIdV);
760      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
761      for (int SubCptIdN = 0; SubCptIdN &lt; SubCptIdV.Len(); SubCptIdN++) {
762          const int SubCptId = SubCptIdV[SubCptIdN];
763          DelDownDIdV(SubCptId, SubDIdV);
764      }
765  }
766  void TOntology::DelDownDId(const int&amp; CptId, const int&amp; DId) {
767      GetConcept(CptId)-&gt;DelDId(BowDocWgtBs, DId);
768      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
769      for (int SubCptIdN = 0; SubCptIdN &lt; SubCptIdV.Len(); SubCptIdN++) {
770          const int SubCptId = SubCptIdV[SubCptIdN];
771          DelDownDId(SubCptId, DId);
772      }
773  }
774  void TOntology::GetCptInRltV(const int&amp; CptId, TIntStrPrV&amp; InRltV) {
775      POntoConcept Cpt = GetConcept(CptId);
776      PVrtx CptVrtx = OntoGraph-&gt;GetVrtx(CptId);
777      InRltV.Gen(CptVrtx-&gt;GetInEIds(), 0);
778      for (int InEIdN = 0; InEIdN &lt; CptVrtx-&gt;GetInEIds(); InEIdN++) {
779          PEdge InEdge = OntoGraph-&gt;GetEdge(CptVrtx-&gt;GetInEId(InEIdN));
780          if (InEdge-&gt;IsDir()) 
781              InRltV.Add(TIntStrPr(InEdge-&gt;GetOtherVId(CptVrtx), InEdge-&gt;GetDNm()));
782      }
783      InRltV.Sort();
784  }
785  void TOntology::GetCptOutRltV(const int&amp; CptId, TIntStrPrV&amp; OutRltV) {
786      POntoConcept Cpt = GetConcept(CptId);
787      PVrtx CptVrtx = OntoGraph-&gt;GetVrtx(CptId);
788      OutRltV.Gen(CptVrtx-&gt;GetOutEIds(), 0);
789      for (int OutEIdN = 0; OutEIdN &lt; CptVrtx-&gt;GetOutEIds(); OutEIdN++) {
790          PEdge OutEdge = OntoGraph-&gt;GetEdge(CptVrtx-&gt;GetOutEId(OutEIdN));
791          if (OutEdge-&gt;IsDir()) 
792              OutRltV.Add(TIntStrPr(OutEdge-&gt;GetOtherVId(CptVrtx), OutEdge-&gt;GetDNm()));
793      }
794      OutRltV.Sort();
795  }
796  void TOntology::GetCptUndirRltV(const int&amp; CptId, TIntStrPrV&amp; UndirRltV) {
797      POntoConcept Cpt = GetConcept(CptId);
798      PVrtx CptVrtx = OntoGraph-&gt;GetVrtx(CptId);
799      UndirRltV.Gen(CptVrtx-&gt;GetOutEIds(), 0);
800      for (int OutEIdN = 0; OutEIdN &lt; CptVrtx-&gt;GetOutEIds(); OutEIdN++) {
801          PEdge OutEdge = OntoGraph-&gt;GetEdge(CptVrtx-&gt;GetOutEId(OutEIdN));
802          if (!OutEdge-&gt;IsDir()) 
803              UndirRltV.Add(TIntStrPr(OutEdge-&gt;GetOtherVId(CptVrtx), OutEdge-&gt;GetDNm()));
804      }
805      UndirRltV.Sort();
806  }
807  void TOntology::GetCptRltV(const int&amp; CptId, TIntStrPrV&amp; InRltV, 
808          TIntStrPrV&amp; OutRltV, TIntStrPrV&amp; UndirRltV) {
809      GetCptInRltV(CptId, InRltV);
810      GetCptOutRltV(CptId, OutRltV); 
811      GetCptUndirRltV(CptId, UndirRltV); 
812  }
813  int TOntology::GetRltTypeN(const TStr&amp; RltTypeNm) const {
814      for (int RltTypeN = 0; RltTypeN &lt; RltTypeV.Len(); RltTypeN++) {
815          if (RltTypeV[RltTypeN].IsType(RltTypeNm)) {
816              return RltTypeN;
817          }
818      }
819      return -1;
820  }
821  bool TOntology::IsRlt(const int&amp; CptId1, const int&amp; CptId2, const TStr&amp; RltTypeNm) {
822      Assert(IsCptId(CptId1) &amp;&amp; IsCptId(CptId2));
823      PEdge Edge; 
824      if (OntoGraph-&gt;IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
825          return (Edge-&gt;GetDNm() == RltTypeNm);
826      }
827      return false;
828  }
829  void TOntology::AddRlt(const int&amp; CptId1, const int&amp; CptId2, const TStr&amp; RltTypeNm) {
830      Assert(IsCptId(CptId1) &amp;&amp; IsCptId(CptId2));
831      const bool IsDir = IsRltDir(RltTypeNm);
832      PEdge NewEdge = TGEdge::New(OntoGraph-&gt;GetVrtx(CptId1), 
833          OntoGraph-&gt;GetVrtx(CptId2), RltTypeNm, IsDir);
834      NewEdge-&gt;PutDNm(RltTypeNm);
835      OntoGraph-&gt;AddEdge(NewEdge);
836  }
837  bool TOntology::DelRlt(const int&amp; CptId1, const int&amp; CptId2, const TStr&amp; RltTypeNm) {
838      Assert(IsCptId(CptId1) &amp;&amp; IsCptId(CptId2));
839      PEdge Edge; bool DeletedP = false;
840      if (OntoGraph-&gt;IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
841          if (Edge-&gt;GetDNm() == RltTypeNm) {
842              OntoGraph-&gt;DelEdge(Edge);
843              DeletedP = true;
844          } else {
845              InfoNotify(&quot;There is no such relationship!!&quot;);
846          }
847      } else {
848          InfoNotify(&quot;There is no such relationship&quot;);
849          AssertR(false, TStr(&quot;There is no such relationship&quot;));
850      }
851      ReconnectToRoot();
852      return DeletedP;
853  }
854  void TOntology::SuggestConcepts(const TIntV&amp; DIdV, const TOntoSuggestAlgType&amp; AlgType, 
855          const int&amp; NewConceptN, TOntoConceptV&amp; NewConceptV) {
856      NewConceptV.Clr();
857      if ((DIdV.Len() &gt; NewConceptN) || (NewConceptN == -1)) {
858          if (AlgType == osatKMeans) {
859              TOntoAlg::SuggestKMeans(BowDocBs, BowDocWgtBs, DIdV, 
860                  NewConceptN, UniqueId, NewConceptV);
861          } else if (AlgType == osatCat) {
862              TOntoAlg::SuggestCat(BowDocBs, BowDocWgtBs, DIdV, 
863                  UniqueId, NewConceptV);
864          }
865      }
866  }
867  void TOntology::SuggestSubconcepts(const int&amp; CptId, const TOntoSuggestAlgType&amp; AlgType, 
868          const int&amp; NewConceptN, const bool&amp; UnusedDocsP, TOntoConceptV&amp; NewConceptV) {
869      TIntV DIdV; 
870      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
871      else {  GetConcept(CptId)-&gt;GetDIdV(DIdV); }
872      SuggestConcepts(DIdV, AlgType, NewConceptN, NewConceptV);
873  }
874  void TOntology::SuggestSubconcepts(const int&amp; CptId, const PLwOntoCfier&amp; LwOntoCfier,
875          const int&amp; NewConceptN, const bool&amp; UnusedDocsP, TOntoConceptV&amp; NewConceptV) {
876      TIntV DIdV; 
877      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
878      else {  GetConcept(CptId)-&gt;GetDIdV(DIdV); }
879      NewConceptV.Clr();
880      if (DIdV.Len() &gt; NewConceptN) {
881          TOntoAlg::SuggestLwOntoCfier(BowDocBs, BowDocWgtBs,
882              DIdV, LwOntoCfier, NewConceptN, UniqueId, NewConceptV);
883      }
884  }
885  POntoConcept TOntology::GenSubconcept(const TStr&amp; NewCptNm, const TIntV&amp; NewCptDIdV) {
886      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
887          UniqueId-&gt;GetNextId(), NewCptNm, NewCptDIdV);
888  }
889  POntoConcept TOntology::GenSubconcept(const TIntV&amp; NewCptDIdV) {
890      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
891          UniqueId-&gt;GetNextId(), NewCptDIdV);
892  }
893  void TOntology::SuggestConceptNm(const int&amp; CptId, const TVec&lt;PLwOntoCfier&gt;&amp; LwOntoCfierV, 
894          const int&amp; MxSuggestNms, TStrV&amp; SuggestNmV, TIntV&amp; SuggestSuppV, TIntV&amp; SuggestVocNV) {
895      TIntPrIntH TermIdVocNFqH; TIntV DIdV; GetCptDIdV(CptId, DIdV); 
896      for (int VocN = 0; VocN &lt; LwOntoCfierV.Len(); VocN++) {
897          PLwOntoCfier LwOntoCfier = LwOntoCfierV[VocN];
898          PLwTermBs LwTermBs = LwOntoCfier-&gt;GetLwOnto()-&gt;GetTermBs();
899          for (int DIdN = 0; DIdN &lt; DIdV.Len(); DIdN++) {
900              const int DId = DIdV[DIdN];
901              TStr DocStr = BowDocBs-&gt;GetDocStr(DId);
902              TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
903              LwOntoCfier-&gt;ClassifyStr(DocStr, SimTermIdPrV);
904              const int TermIds = TInt::GetMn(3, SimTermIdPrV.Len());
905              for (int TermIdN = 0; TermIdN &lt; TermIds; TermIdN++) {
906                  const int TermId = SimTermIdPrV[TermIdN].Val2;
907                  TIntPr TermIdVocN(TermId, VocN);
908                  TStr TermNm = LwTermBs-&gt;GetTerm(TermId)-&gt;GetTermNm();
909                  if (TermIdVocNFqH.IsKey(TermIdVocN)) { TermIdVocNFqH(TermIdVocN)++; } 
910                  else { TermIdVocNFqH.AddDat(TermIdVocN, 1); }
911              }             
912          }
913      }
914      TIntIntPrPrV TermFqIdVocNV; TermIdVocNFqH.GetDatKeyPrV(TermFqIdVocNV); 
915      TermFqIdVocNV.Sort(false);
916      SuggestNmV.Clr(); SuggestSuppV.Clr(); SuggestVocNV.Clr();
917      const int SuggestNms = TInt::GetMn(MxSuggestNms, TermFqIdVocNV.Len());
918      for (int SuggestNmN = 0; SuggestNmN &lt; SuggestNms; SuggestNmN++) {
919          const int TermId = TermFqIdVocNV[SuggestNmN].Val2.Val1;
920          const int Supp = TermFqIdVocNV[SuggestNmN].Val1;
921          const int VocN = TermFqIdVocNV[SuggestNmN].Val2.Val2;
922          PLwTermBs LwTermBs = LwOntoCfierV[VocN]-&gt;GetLwOnto()-&gt;GetTermBs();
923          TStr TermNm = LwTermBs-&gt;GetTerm(TermId)-&gt;GetTermNm();
924          SuggestNmV.Add(TermNm); 
925          SuggestSuppV.Add(Supp); 
926          SuggestVocNV.Add(VocN);
927      }
928  }
929  void TOntology::AddConcept(const POntoConcept&amp; NewCpt, const int&amp; FatherCptId) {
930      const int NewCptId = NewCpt-&gt;GetId();
931      IAssertR(!IsCptId(NewCptId), &quot;There already is a conceptwith the same ID!&quot;);
932      ConceptV.Add(NewCpt); RefreshCptIdPosH();
933      TStr NewCptIdStr = TStr::Fmt(&quot;Cpt%d&quot;, NewCptId);
934      PVrtx NewCptVrtx = TGVrtx::New(NewCptId, NewCptIdStr);
935      TStr Name = NewCpt-&gt;GetName(); Name.ChangeChAll(&#x27; &#x27;, &#x27;\\&#x27;);
936      NewCptVrtx-&gt;PutDNm(Name); 
937      NewCptVrtx-&gt;PutShape(&quot;Rect&quot;);
938      OntoGraph-&gt;AddVrtx(NewCptVrtx);
939      if (FatherCptId &gt;= 0) {
940          IAssertR(IsCptId(FatherCptId), &quot;There is no such concept!&quot;);
941          AddRlt(NewCptId, FatherCptId, TOntoRltType::SubCptOfRltStr);
942      } else {
943          IAssert(ConceptV.Len() == 1);
944      }
945  }
946  void TOntology::BreakConcept(const int&amp; OldCptId, const TOntoConceptV&amp; NewCptV) {
947      if (IsRootCpt(OldCptId)) return; 
948      IAssert(!NewCptV.Empty());
949      IAssertR(IsCptId(OldCptId), &quot;There is no such concept!&quot;);
950      for (int CptC = 0; CptC &lt; NewCptV.Len(); CptC++) {
951          POntoConcept NewCpt = NewCptV[CptC];
952          const int NewCptId = NewCpt-&gt;GetId();
953          IAssertR(!IsCptId(NewCptId), 
954              &quot;There already is a concept with the same ID!&quot;);
955          ConceptV.Add(NewCpt); RefreshCptIdPosH();
956          TStr Name = NewCpt-&gt;GetName(); Name.ChangeStrAll(&quot; &quot;, &quot;\\&quot;);
957          PVrtx v = TGVrtx::New(NewCptId, Name.CStr());
958          OntoGraph-&gt;AddVrtx(v);
959      }
960      TIntStrPrV InRltV, OutRltV, UndirRltV;
961      GetCptRltV(OldCptId, InRltV, OutRltV, UndirRltV);
962      for (int InRltN = 0; InRltN &lt; InRltV.Len(); InRltN++) { 
963          const int VrtxId1 = InRltV[InRltN].Val1;
964          TStr RltNm = InRltV[InRltN].Val2;
965          for (int CptC = 0; CptC &lt; NewCptV.Len(); CptC++) {
966              const int NewCptId = NewCptV[CptC]-&gt;GetId();
967              AddRlt(VrtxId1, NewCptId, RltNm);
968          }
969      }
970      for (int OutRltN = 0; OutRltN &lt; OutRltV.Len(); OutRltN++) {
971          const int VrtxId2 = OutRltV[OutRltN].Val1;
972          TStr RltNm = OutRltV[OutRltN].Val2;
973          for (int CptC = 0; CptC &lt; NewCptV.Len(); CptC++) {
974              const int NewCptId = NewCptV[CptC]-&gt;GetId();
975              AddRlt(NewCptId, VrtxId2, RltNm);
976          }
977      }
978      for (int UndirRltN = 0; UndirRltN &lt; UndirRltV.Len(); UndirRltN++) {
979          const int VrtxId2 = UndirRltV[UndirRltN].Val1;
980          TStr RltNm = UndirRltV[UndirRltN].Val2;
981          for (int CptC = 0; CptC &lt; NewCptV.Len(); CptC++) {
982              const int NewCptId = NewCptV[CptC]-&gt;GetId();
983              AddRlt(NewCptId, VrtxId2, RltNm);
984          }
985      }
986      ConceptV.Del(CptIdPosH.GetDat(OldCptId)); RefreshCptIdPosH();
987      OntoGraph-&gt;DelVrtx(OldCptId); ReconnectToRoot();
988  }
989  void TOntology::PruneSubconcept(const POntoConcept&amp; SubCpt, const int&amp; FatherCptId) {
990      if (FatherCptId == 0) return; 
991      IAssertR(IsCptId(FatherCptId), &quot;There is no such concept!&quot;);
992      TIntV SubCptDIdV; SubCpt-&gt;GetDIdV(SubCptDIdV);
993      GetConcept(FatherCptId)-&gt;DelDIdV(BowDocWgtBs, SubCptDIdV);
994  }
995  void TOntology::DeleteConcept(const int&amp; CptId, const bool&amp; DoRedirect) {
996      if (IsRootCpt(CptId)) return; 
997      IAssertR(IsCptId(CptId), &quot;There is no such concept!&quot;);
998      if (DoRedirect) {
999          TIntStrPrV InRltV, OutRltV, UndirRltV;
1000          GetCptRltV(CptId, InRltV, OutRltV, UndirRltV);
1001          AddRltsFromList(InRltV, OutRltV, UndirRltV);
1002      }
1003      ConceptV.Del(CptIdPosH.GetDat(CptId)); RefreshCptIdPosH();
1004      OntoGraph-&gt;DelVrtx(CptId); ReconnectToRoot();
1005  }
1006  void TOntology::UniteConcepts(const int&amp; CptId1, const int&amp; CptId2) {
1007  }
1008  void TOntology::CopyConcept(const int&amp; CptId, const int NewFatherCptId, const bool&amp; MoveP) {
1009      if (IsRootCpt(CptId)) return; 
1010      IAssertR(IsCptId(CptId), &quot;There is no such concept!&quot;);
1011      IAssertR(IsCptId(NewFatherCptId), &quot;There is no such concept!&quot;);
1012      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
1013      SuperCptIdV.DelIfIn(NewFatherCptId);
1014      if (SuperCptIdV.Empty()) return; 
1015      AddRlt(CptId, NewFatherCptId, TOntoRltType::SubCptOfRltStr);
1016      for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
1017          const int SuperCptId = SuperCptIdV[SuperCptIdN];
1018          DelRlt(CptId, SuperCptId, TOntoRltType::SubCptOfRltStr);
1019      }
1020      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1021      if (MoveP) {
1022          for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
1023              const int SuperCptId = SuperCptIdV[SuperCptIdN];
1024              DelUpDIdV(SuperCptId, CptDIdV);
1025          }
1026      }
1027      AddUpDIdV(NewFatherCptId, CptDIdV);
1028  }
1029  void TOntology::NewConcept() {
1030      POntoConcept Cpt = TOntoConcept::New(BowDocBs, 
1031          BowDocWgtBs, UniqueId-&gt;GetNextId(), &quot;New Concept&quot;, TIntV());
1032      IAssert(ConceptV[0]-&gt;GetId() == 0);
1033      AddConcept(Cpt, 0);
1034  }
<span onclick='openModal()' class='match'>1035  void TOntology::ExtractKeywords(const int&amp; CptId) {
1036      if (IsRootCpt(CptId)) return;
1037      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1038      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1039      PBowSpV SvmSpV;
</span>1040      if (CptDIdV.Len() &gt; 0) {
1041          SvmSpV = TBowSVMMd::GetKeywords(BowDocBs, ContextDIdV, CptDIdV, 50, 1.0, 5.0);
1042      } else {
1043          SvmSpV = TBowSpV::New();
1044      }
1045      GetConcept(CptId)-&gt;SetSvmSpV(SvmSpV);
1046  }
1047  void TOntology::CalcCptCompactness(const int&amp; CptId) {
1048      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1049      if (CptDIdV.Len() &gt; 0) {
1050          PBowSpV CentroidSpV = GetConcept(CptId)-&gt;GetCentroidSpV();
1051          double Qual = 0.0; 
1052          for (int DIdN = 0; DIdN &lt; CptDIdV.Len(); DIdN++) {
1053              const int DId = CptDIdV[DIdN];
1054              PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DId);
1055              Qual += BowSim-&gt;GetSim(CentroidSpV, DocSpV);
1056          }
1057          GetConcept(CptId)-&gt;SetCompactness(Qual / CptDIdV.Len());
1058      } else {
1059          GetConcept(CptId)-&gt;SetCompactness(1.0);
1060      }
1061  }
1062  void TOntology::CalcCptClarity(const int&amp; CptId) {
1063      if (IsRootCpt(CptId)) return;
1064      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1065      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1066      if (CptDIdV.Len() &gt; 20) {
1067          TCfyRes CfyRes = TBowSVMMd::CrossValidClsLinear(
1068              5, 1, BowDocBs, BowDocWgtBs, ContextDIdV, CptDIdV, 1, 5.0);
1069          const double Clarity = CfyRes.BreakEvenPoint();
1070          GetConcept(CptId)-&gt;SetClarity(Clarity);
1071      }
1072  }
1073  void TOntology::PrepareGraph(const int&amp; SelectedCptId) {
1074      IAssert(GetConcepts() &gt; 0);
1075      if (IsCptId(SelectedCptId)) {
1076          TStr VrtxNm = OntoGraph-&gt;GetVrtx(SelectedCptId)-&gt;GetDNm();
1077          OntoGraph-&gt;GetPp()-&gt;PutValStr(&quot;BoldVNm&quot;, VrtxNm);
1078      }
1079  }
1080  void TOntology::PlaceGraph() {
1081      IAssert(GetConcepts() &gt; 0);
1082      PVrtx RootVrtx = OntoGraph-&gt;GetVrtx(0);
1083      OntoGraph-&gt;PlaceGraphAsStar(RootVrtx, TOntoRltType::SubCptOfRltStr);
1084      OntoGraph-&gt;RescaleXY(0.1, RootVrtx);
1085  }
1086  void TOntology::ExportPTO(const TStr&amp; FNm, const bool&amp; DigLibP) { 
1087      PSOut SOut = TFOut::New(FNm);
1088      TStr BowFNm = FNm + &quot;.bow&quot;; BowDocBs-&gt;SaveBin(BowFNm);
1089      POntoExport OntoExport = TOntoExportPTO::New(SOut, DigLibP, BowFNm);
1090      this-&gt;Export(OntoExport);
1091  }
1092  void TOntology::ExportProlog(const TStr&amp; FNm) {
1093      PSOut SOut = TFOut::New(FNm);
1094      POntoExport OntoExport = TOntoExportProlog::New(SOut);
1095      this-&gt;Export(OntoExport);
1096  }
1097  void TOntology::ExportOwl(const TStr&amp; FNm, const bool&amp; StoreDocsP, const bool&amp; StoreAbstractsP) {
1098      PSOut SOut = TFOut::New(FNm);
1099      POntoExport OntoExport = TOntoExportOWL::New(SOut, StoreDocsP, StoreAbstractsP);
1100      this-&gt;Export(OntoExport);
1101  }
1102  POntology TOntology::ImportPTO(const TStr&amp; RdfFNm, const TStr&amp; BowFNm) {
1103      PBowDocBs BowDocBs = TBowDocBs::LoadBin(BowFNm);
1104      const int MnWordFq = BowDocBs-&gt;GetDocs() &gt; 111 ? 5 : 3;
1105      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1106          BowDocBs, bwwtLogDFNrmTFIDF, 0.2, MnWordFq);
1107      POntology Onto = TOntology::New(BowDocBs, BowDocWgtBs, bstCos);
1108      PXmlDoc Rdf = TXmlDoc::LoadTxt(RdfFNm);
1109      IAssertR(Rdf-&gt;IsOk(), &quot;Wrong RDF format&quot;);
1110      TStrIntH TopicUriIdH;
1111      PXmlTok RootTok; IAssert(Rdf-&gt;IsTagTok(&quot;rdf:RDF&quot;, RootTok));
1112      TXmlTokV TopicV; RootTok-&gt;GetTagTokV(&quot;ptop:Topic&quot;, TopicV);
1113      TXmlTokV DocV; RootTok-&gt;GetTagTokV(&quot;ptop:Document&quot;, DocV);
1114      TXmlTokV DocPropV; RootTok-&gt;GetTagTokV(&quot;jsikm:OntoGenInstanceProperties&quot;, DocPropV);
1115      TIntIntVH TopicIdDocIdVH; TopicIdDocIdVH.AddDat(0, TIntV());
1116      for (int TopicN = 0; TopicN &lt; TopicV.Len(); TopicN++) {
1117          PXmlTok TopicTok = TopicV[TopicN];
1118          TStr TopicURI = TopicTok-&gt;GetArgVal(&quot;rdf:about&quot;);
1119          TStr TopicName = TopicTok-&gt;GetTagTok(&quot;psys:description&quot;)-&gt;GetTagTokStr(&quot;&quot;);
1120          int UnderScorePos = TopicURI.SearchCh(&#x27;_&#x27;);
1121          TStr TopicURIPrefix = TopicURI.Left(UnderScorePos);
1122          if (TopicURIPrefix != &quot;#Cpt0&quot; &amp;&amp; TopicURI != &quot;#TOP_0&quot;) {
1123              const int TopicId = Onto-&gt;UniqueId-&gt;GetNextId(); 
1124              POntoConcept TopicCpt = TOntoConcept::New(Onto-&gt;BowDocBs, 
1125                  Onto-&gt;BowDocWgtBs, TopicId, TopicName, TIntV());
1126              Onto-&gt;AddConcept(TopicCpt, 0);
1127              TopicUriIdH.AddDat(TopicURI, TopicId);
1128              TopicIdDocIdVH.AddDat(TopicId, TIntV());
1129          } else {
1130              Onto-&gt;SetCptName(0, TopicName);
1131              TopicUriIdH.AddDat(TopicURI, 0);
1132          }        
1133      }
1134      for (int TopicN = 0; TopicN &lt; TopicV.Len(); TopicN++) {
1135          PXmlTok TopicTok = TopicV[TopicN];
1136          TStr TopicURI = TopicTok-&gt;GetArgVal(&quot;rdf:about&quot;);
1137          const int TopicId = TopicUriIdH.GetDat(TopicURI);
1138          bool ConnectedToRoot = false;
1139          if (TopicId &gt; 0) {
1140              TXmlTokV SuperTopicV; TopicTok-&gt;GetTagTokV(&quot;ptop:subTopicOf&quot;, SuperTopicV);
1141              for (int SupTopN = 0; SupTopN &lt; SuperTopicV.Len(); SupTopN++) {
1142                  TStr SuperTopicURI = SuperTopicV[SupTopN]-&gt;GetArgVal(&quot;rdf:resource&quot;);
1143                  const int SuperTopicId = TopicUriIdH.GetDat(SuperTopicURI);
1144                  if (SuperTopicId == 0) {
1145                      ConnectedToRoot = true;
1146                  } else {            
1147                      Onto-&gt;AddRlt(TopicId, SuperTopicId, TOntoRltType::SubCptOfRltStr);
1148                  }
1149              }
1150              if (!ConnectedToRoot) {
1151                  Onto-&gt;DelRlt(TopicId, 0, TOntoRltType::SubCptOfRltStr);
1152              }
1153          }
1154      }
1155      TStrIntH DocPropIdH;
1156      for (int DocN = 0; DocN &lt; DocPropV.Len(); DocN++) {
1157          PXmlTok DocPropTok = DocPropV[DocN];
1158          TStr DocPropURI = DocPropTok-&gt;GetArgVal(&quot;rdf:about&quot;);
1159          TStr Link = DocPropTok-&gt;GetTagTok(&quot;jsikm:locationOfInstance&quot;)-&gt;GetTagTokStr(&quot;&quot;);
1160          TStrV LinkPartV; Link.SplitOnAllCh(&#x27;#&#x27;, LinkPartV);
1161          IAssert(LinkPartV.Len() == 2);
1162          const int DocId = LinkPartV[1].GetInt();
1163          IAssert(BowDocBs-&gt;IsDId(DocId));
1164          DocPropIdH.AddDat(DocPropURI, DocId);
1165      }
1166      for (int DocN = 0; DocN &lt; DocV.Len(); DocN++) {
1167          PXmlTok DocTok = DocV[DocN];
1168          TStr DocPropURI = DocTok-&gt;GetTagTok(&quot;jsikm:hasOntoGenInstanceProperties&quot;)-&gt;GetArgVal(&quot;rdf:resource&quot;);
1169          const int DocId = DocPropIdH.GetDat(DocPropURI);
1170          TopicIdDocIdVH.GetDat(0).Add(DocId);
1171          TXmlTokV SubjectTopicV; DocTok-&gt;GetTagTokV(&quot;ptop:hasSubject&quot;, SubjectTopicV);
1172          for (int SubjectN = 0; SubjectN &lt; SubjectTopicV.Len(); SubjectN++) {
1173              PXmlTok SubjectTok = SubjectTopicV[SubjectN];
1174              TStr SubjectUri = SubjectTok-&gt;GetArgVal(&quot;rdf:resource&quot;);
1175              const int SubjectId = TopicUriIdH.GetDat(SubjectUri);
1176              if (SubjectId &gt; 0) {
1177                  IAssert(TopicIdDocIdVH.IsKey(SubjectId));
1178                  TopicIdDocIdVH.GetDat(SubjectId).Add(DocId);
1179              }
1180          }
1181      }
1182      int KeyId = TopicIdDocIdVH.FFirstKeyId();
1183      while (TopicIdDocIdVH.FNextKeyId(KeyId)) {
1184          const int TopicId = TopicIdDocIdVH.GetKey(KeyId);
1185          Onto-&gt;SetCptDIdV(TopicId, TopicIdDocIdVH.GetDat(TopicId), false);
1186      }
1187      return Onto;
1188  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</h3>
            <pre><code>1  #include &quot;lsionto.h&quot;
2  void TOntoConcept::GenMedoid(PBowDocWgtBs BowDocWgtBs) {
3      TFltIntKdV WgtDIdV;
4      for (int DIdN = 0; DIdN &lt; DIdV.Len(); DIdN++) {
5          const int DId = DIdV[DIdN];
6          PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DId);
7          const double Wgt = TBowSim::GetCosSim(ConceptSpV, DocSpV);
8          WgtDIdV.Add(TFltIntKd(Wgt, DId));
9      }
10      const int TopN = 33;
11      TFltIntKdV TopWgtDIdV;
12      if (WgtDIdV.Len() &gt; TopN) {
13          TFltIntKdHp::GetTopV(htMin, TopN, WgtDIdV, TopWgtDIdV, true);
14      } else { 
15          TopWgtDIdV = WgtDIdV; TopWgtDIdV.Sort(false);
16      }
17      GetSwitchedKdV&lt;TFlt, TInt&gt;(TopWgtDIdV, MedoidDIdWgtV);
18  }
19  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
20          const int _Id, const TIntV&amp; _DIdV): Id(_Id), DIdV(_DIdV)  { 
21      ResetCentroidSpV(BowDocWgtBs);
22      CptNm = GetKeyWdStr(BowDocBs, 3, 1.0, &quot;, &quot;, false, false);
23      SvmKeyWdSpV = TBowSpV::New();
24      if (!DIdV.IsSorted()) { DIdV.Sort(); }
25      Compactness = Clarity = -1.0;
26  };
27  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, const int _Id, 
28          const TStr&amp; _CptNm, const TIntV&amp; _DIdV): Id(_Id), CptNm(_CptNm), DIdV(_DIdV) { 
29      ResetCentroidSpV(BowDocWgtBs);
30      SvmKeyWdSpV = TBowSpV::New();
31      if (!DIdV.IsSorted()) { DIdV.Sort(); }
32      Compactness = Clarity = -1.0;
33  };
34  void TOntoConcept::ResetCentroidSpV(PBowDocWgtBs BowDocWgtBs) {
35      ConceptSpV = TBowClust::GetConceptSpV(BowDocWgtBs, NULL, DIdV);
36      GenMedoid(BowDocWgtBs);
37      IsValid = true;
38  }
39  void TOntoConcept::SetDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV&amp; _DIdV) {
40      if (Id == 0) return; 
41      DIdV = _DIdV; if (!DIdV.IsSorted()) { DIdV.Sort(); }
42      ResetCentroidSpV(BowDocWgtBs);
43  }
44  void TOntoConcept::AddDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV&amp; SubDIdV) {
45      DIdV.Union(SubDIdV);
46      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
47      else { IsValid = false; }
48  }
49  void TOntoConcept::AddDId(PBowDocWgtBs BowDocWgtBs, const int&amp; DId) {
50      if (DIdV.SearchBin(DId) == -1) { DIdV.AddSorted(DId); }
51      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
52      else { IsValid = false; }
53  }
54  void TOntoConcept::DelDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV&amp; SubDIdV) {
55      if (Id == 0) return; 
56      DIdV.Diff(SubDIdV);
57      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
58      else { IsValid = false; }
59  }
60  bool TOntoConcept::DelDId(PBowDocWgtBs BowDocWgtBs, const int&amp; DId) {
61      if (Id == 0) return false; 
62      bool DocDeletedP = DIdV.DelIfIn(DId);
63      if (DocDeletedP &amp;&amp; !BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
64      else { IsValid = false; }
65      return DocDeletedP;
66  }
67  TStr TOntoConcept::GetKeyWdStr(PBowDocBs BowDocBs, const int&amp; TopWords, 
68          const double&amp; TopWordsWgtPrc, const TStr&amp; SepStr, 
69          const bool&amp; ShowWeights, const bool&amp; UseMedoidP) const { 
70      if (!UseMedoidP) {
71          return ConceptSpV-&gt;GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
72      } else {
73          if (MedoidDIdWgtV.Empty()) { return &quot;Empty concept&quot;; }
74          TStr KeyWdStr = BowDocBs-&gt;GetDocNm(MedoidDIdWgtV[0].Key);
75          const int DIds = TInt::GetMn(TopWords, MedoidDIdWgtV.Len());
76          for (int DIdN = 1; DIdN &lt; DIds; DIdN++) {
77              const int DId = MedoidDIdWgtV[DIdN].Key;
78              TStr DocNm = BowDocBs-&gt;GetDocNm(DId);
79              KeyWdStr += SepStr; KeyWdStr += DocNm;
80          }
81          return KeyWdStr;
82      }
83  }
84  TStr TOntoConcept::GetSvmKeyWdStr(PBowDocBs BowDocBs, const int&amp; TopWords,
85          const double&amp; TopWordsWgtPrc, const TStr&amp; SepStr, const bool&amp; ShowWeights) const {
86      return SvmKeyWdSpV-&gt;GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
87  }
88  void TOntoConcept::CalcCptMd(PBowDocBs BowDocBs, const TIntV&amp; ContextDIdV,
89          const double&amp; SvmC, const double&amp; SvmJ, const int&amp; SvmTime) {
90      if (Id == 0) return;
91      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, 
92          bwwtLogDFNrmTFIDF, 0.0, 0, ContextDIdV);
93      PSVMTrainSet TrainSet = TBowDocBs2TrainSet::NewBowAllCatV(
94          BowDocWgtBs, ContextDIdV, DIdV);
95      CptMd = TSVMModel::NewClsLinear(TrainSet, SvmC, SvmJ, TIntV(), 
96          TSVMLearnParam::Lin(SvmTime));
97      CptMd-&gt;MakeProb(TrainSet);
98  }
99  TStr TOntoRltType::SubCptOfRltStr = &quot;SubConcept-Of&quot;;
100  TStr TOntoRltType::SimilarRltStr = &quot;Similar&quot;;
101  void TOntoAlg::SuggestKMeans(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
102          const TIntV&amp; DIdV, const int&amp; _NewConceptN, PUniqueId UniqueId, 
103          TOntoConceptV&amp; NewConceptV) {
104      const int NewConceptN = TInt::GetMn(DIdV.Len(), _NewConceptN);
105      NewConceptV.Clr(); if (NewConceptN &lt; 2) return;
106      TIntV FullDIdV; BowDocWgtBs-&gt;GetDIdV(FullDIdV);
107      BowDocWgtBs-&gt;SetDIdV(DIdV);
108      PBowSim BowSim = TBowSim::New(bstCos);
109      PBowDocPart BowDocPart=TBowClust::GetKMeansPartForDocWgtBs(
110          TNotify::StdNotify, BowDocWgtBs, BowDocBs, 
111          BowSim, TRnd(1), NewConceptN, 1, 10, 1);
112      BowDocWgtBs-&gt;SetDIdV(FullDIdV);
113      IAssert(BowDocPart-&gt;GetClusts() == NewConceptN);
114      NewConceptV.Gen(NewConceptN, 0);
115      for (int ClustC = 0; ClustC &lt; NewConceptN; ClustC++) {
116          PBowDocPartClust Clust = BowDocPart-&gt;GetClust(ClustC);
117          TIntV CptDIdV; Clust-&gt;GetDIdV(CptDIdV);
118          NewConceptV.Add(TOntoConcept::New(BowDocBs,
119              BowDocWgtBs, UniqueId-&gt;GetNextId(), CptDIdV));
120      }
121  }
122  void TOntoAlg::SuggestCat(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
123          const TIntV&amp; DIdV, PUniqueId UniqueId, TOntoConceptV&amp; NewConceptV) {
124      TIntIntVH CIdDIdVH;
125      for (int DocN = 0; DocN &lt; DIdV.Len(); DocN++) {
126          const int DId = DIdV[DocN];
127          const int DocCIds = BowDocBs-&gt;GetDocCIds(DId);
128          for (int DocCIdN = 0; DocCIdN &lt; DocCIds; DocCIdN++) {
129              const int DocCId = BowDocBs-&gt;GetDocCId(DId, DocCIdN);
130              if (CIdDIdVH.IsKey(DocCId)) {
131                  CIdDIdVH.GetDat(DocCId).Add(DId);
132              } else {
133                  CIdDIdVH.AddDat(DocCId, TIntV::GetV(DId));
134              }
135          }
136      }
137      TIntKdV DocsKeyIdV(CIdDIdVH.Len(), 0);
138      int KeyId = CIdDIdVH.FFirstKeyId();
139      while (CIdDIdVH.FNextKeyId(KeyId)) {
140          const int Docs = CIdDIdVH[KeyId].Len();
141          DocsKeyIdV.Add(TIntKd(Docs, KeyId));
142      }
143      DocsKeyIdV.Sort(false);
144      NewConceptV.Gen(CIdDIdVH.Len(), 0);
145      for (int CptN = 0; CptN &lt; DocsKeyIdV.Len(); CptN++) {
146          const int CptKeyId = DocsKeyIdV[CptN].Dat;
147          const TIntV&amp; CptDIdV = CIdDIdVH[CptKeyId];
148          TStr CptNm = BowDocBs-&gt;GetCatNm(CIdDIdVH.GetKey(CptKeyId));
149          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
150              UniqueId-&gt;GetNextId(), CptNm, CptDIdV));
151      }
152  }
153  void TOntoAlg::SuggestLwOntoCfier(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
154          const TIntV&amp; DIdV, PLwOntoCfier LwOntoCfier, const int&amp; _NewConcepts, 
155          PUniqueId UniqueId, TOntoConceptV&amp; NewConceptV) {
156      TIntH TermIdFqH; TIntIntVH TermIdDIdVH;
157      for (int DIdN = 0; DIdN &lt; DIdV.Len(); DIdN++) {
158          const int DId = DIdV[DIdN];
159          TStr DocStr = BowDocBs-&gt;GetDocStr(DId);
160          TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
161          LwOntoCfier-&gt;ClassifyStr(DocStr, SimTermIdPrV);
162          if (!SimTermIdPrV.Empty()) { 
163              const int TermId = SimTermIdPrV[0].Val2;
164              if (TermIdFqH.IsKey(TermId)) { 
165                  TermIdFqH(TermId)++; 
166                  TermIdDIdVH(TermId).Add(DId);
167              } else { 
168                  TermIdFqH.AddDat(TermId, 1); 
169                  TermIdDIdVH.AddDat(TermId, TIntV::GetV(DId));
170              }
171          }
172      }
173      TIntPrV TermFqIdV; TermIdFqH.GetDatKeyPrV(TermFqIdV); TermFqIdV.Sort(false);
174      const int NewConcepts = TInt::GetMn(_NewConcepts, TermFqIdV.Len());
175      NewConceptV.Gen(NewConcepts, 0);
176      PLwTermBs TermBs = LwOntoCfier-&gt;GetLwOnto()-&gt;GetTermBs();
177      for (int NewConceptN = 0; NewConceptN &lt; NewConcepts; NewConceptN++) {
178          const int TermId = TermFqIdV[NewConceptN].Val2;
179          const TIntV&amp; CptDIdV = TermIdDIdVH(TermId);
180          TStr TermNm = TermBs-&gt;GetTerm(TermId)-&gt;GetTermNm();
181          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
182              UniqueId-&gt;GetNextId(), TermNm, CptDIdV));
183      }
184  }
185  TStr TOntoExportPTO::GetUri(const int&amp; Id, const TStr&amp; Nm) {
186      TChA CleanChA; bool ToUc = true;
187      for (int ChN = 0; ChN &lt; Nm.Len(); ChN++) {
188          char Ch = Nm[ChN];
189          if (TCh::IsAlpha(Ch)) { 
190              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
191              CleanChA += Ch; 
192          } else { ToUc = true; }
193      }
194      return TInt::GetStr(Id) + &quot;_&quot; + TStr(CleanChA);
195  }
196  void TOntoExportPTO::StartExport() {
197      SOut-&gt;PutStrLn(&quot;&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;&quot;);
198      SOut-&gt;PutStrLn(&quot;&quot;);
199      SOut-&gt;PutStrLn(&quot;&lt;!DOCTYPE rdf:RDF [&quot;);
200      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY rdf  &#x27;http:&amp;bsol;&amp;bsol;www.w3.org/1999/02/22-rdf-syntax-ns#&#x27;&gt;&quot;);
201      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY rdfs &#x27;http:&amp;bsol;&amp;bsol;www.w3.org/2000/01/rdf-schema#&#x27;&gt;&quot;);
202      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY owl  &#x27;http:&amp;bsol;&amp;bsol;www.w3.org/2002/07/owl#&#x27;&gt;&quot;);
203      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY xsd  &#x27;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema#&#x27; &gt;&quot;);
204      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY ptop &#x27;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protont#&#x27;&gt;&quot;);
205      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY psys &#x27;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protons#&#x27;&gt;&quot;);
206      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY protonkm  &#x27;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protonkm#&#x27;&gt;&quot;);
207      if (DigLibP) { SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY diglib &#x27;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protons#&#x27;&gt;&quot;); }
208      SOut-&gt;PutStrLn(&quot;    &lt;!ENTITY jsikm  &#x27;http:&amp;bsol;&amp;bsol;kt.ijs.si/blazf/jsikm#&#x27;&gt;&quot;);
209      SOut-&gt;PutStrLn(&quot;]&gt;&quot;);
210      SOut-&gt;PutStrLn(&quot;&quot;);
211      SOut-&gt;PutStrLn(&quot;&lt;rdf:RDF&quot;);
212      SOut-&gt;PutStrLn(&quot;    xmlns:owl=\&quot;&amp;owl;\&quot;&quot;);
213      SOut-&gt;PutStrLn(&quot;    xmlns:rdf=\&quot;&amp;rdf;\&quot;&quot;);
214      SOut-&gt;PutStrLn(&quot;    xmlns:rdfs=\&quot;&amp;rdfs;\&quot;&quot;);
215      SOut-&gt;PutStrLn(&quot;    xmlns:psys=\&quot;&amp;psys;\&quot;&quot;);
216      SOut-&gt;PutStrLn(&quot;    xmlns:ptop=\&quot;&amp;ptop;\&quot;&quot;);
217      SOut-&gt;PutStrLn(&quot;    xmlns:protonkm=\&quot;&amp;protonkm;\&quot;&quot;);
218      SOut-&gt;PutStrLn(&quot;    xmlns=\&quot;&amp;protonkm;\&quot;&quot;);
219      if (DigLibP) { SOut-&gt;PutStrLn(&quot;    xmlns:diglib=\&quot;&amp;diglib;\&quot;&quot;); }
220      SOut-&gt;PutStrLn(&quot;    xmlns:jsikm=\&quot;&amp;jsikm;\&quot;&quot;);
221      SOut-&gt;PutStrLn(&quot;    xml:base=\&quot;&amp;protonkm;\&quot;&quot;); 
222      SOut-&gt;PutStrLn(&quot;&gt;&quot;);
223      SOut-&gt;PutStrLn(&quot;&quot;);
224      SOut-&gt;PutStrLn(&quot;&lt;owl:Ontology rdf:about=\&quot;\&quot;&gt;&quot;);
225      SOut-&gt;PutStrLn(&quot;  &lt;rdfs:comment&gt;PROTON Topics (from Inspec Thesaurus) ordered by algorithm X&lt;/rdfs:comment&gt;&quot;);
226      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protons\&quot;/&gt;&quot;);
227      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protont\&quot;/&gt;&quot;);
228      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protonu\&quot;/&gt;&quot;);
229      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;proton.semanticweb.org/2005/04/protonkm\&quot;/&gt;&quot;);
230      if (DigLibP) { SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;kt.ijs.si/blazf/jsikm\&quot;/&gt;&quot;); }
231      SOut-&gt;PutStrLn(&quot;  &lt;owl:imports rdf:resource=\&quot;http:&amp;bsol;&amp;bsol;kt.ijs.si/blazf/jsikm\&quot;/&gt;&quot;);
232      SOut-&gt;PutStrLn(&quot;  &lt;owl:versionInfo&gt;\&quot;0.1\&quot;&lt;/owl:versionInfo&gt;&quot;);
233      SOut-&gt;PutStrLn(&quot;&lt;/owl:Ontology&gt;&quot;);
234      SOut-&gt;PutStrLn(&quot;&quot;);
235  }
236  void TOntoExportPTO::EndExport() {
237      SOut-&gt;PutStrLn(&quot;&lt;/rdf:RDF&gt;&quot;);
238      SOut-&gt;Flush();
239  }
240  void TOntoExportPTO::PutCpt(const int&amp; CptId, const TStr CptNm, 
241          const TIntStrPrV&amp; SubCptIdNmV, const TIntStrPrV&amp; SuperCptIdNmV, const TIntV&amp; DIdV, 
242          PBowDocBs BowDocBs, PBowSpV KeyWdSpV, PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
243      SOut-&gt;PutStrLn(&quot;&lt;ptop:Topic rdf:about=\&quot;#Cpt&quot; + GetUri(CptId, CptNm) + &quot;\&quot;&gt;&quot;);
244      SOut-&gt;PutStrLn(&quot;  &lt;psys:description&gt;&quot; + CptNm + &quot;&lt;/psys:description&gt;&quot;);
245      for (int SuperCptN = 0; SuperCptN &lt; SuperCptIdNmV.Len(); SuperCptN++) {
246          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
247          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
248          SOut-&gt;PutStrLn(&quot;  &lt;ptop:subTopicOf rdf:resource=\&quot;#Cpt&quot; + 
249              GetUri(SuperCptId, SuperCptNm) + &quot;\&quot; /&gt;&quot;);
250      }
251      if (DigLibP) {
252          for (int DIdN = 0; DIdN &lt; DIdV.Len(); DIdN++) {
253              const int DId = DIdV[DIdN];
254              TStr DNm = BowDocBs-&gt;GetDocNm(DId);
255              SOut-&gt;PutStrLn(&quot;  &lt;diglib:hasArticle rdf:resource=\&quot;#Doc&quot; + 
256                  GetUri(DId, DNm) + &quot;\&quot; /&gt;&quot;);
257          }
258      }
259      SOut-&gt;PutStrLn(TStr::Fmt(&quot;  &lt;jsikm:hasOntoGenClassProperties rdf:resource=\&quot;#CLS_PROP_%d\&quot; /&gt;&quot;, CptId));
260      SOut-&gt;PutStrLn(&quot;&lt;/ptop:Topic&gt;&quot;);
261      SOut-&gt;PutStrLn(TStr::Fmt(&quot;&lt;jsikm:OntoGenClassProperties rdf:about=\&quot;#CLS_PROP_%d\&quot;&gt;&quot;, CptId));
262      TStr KeyWdStr = KeyWdSpV-&gt;GetStr(BowDocBs, 10, 1.0, &quot;, &quot;, false, true);
263      SOut-&gt;PutStrLn(&quot;  &lt;jsikm:hasCentroidKeywords&gt;&quot; + KeyWdStr + &quot;&lt;/jsikm:hasCentroidKeywords&gt;&quot;);
264      TStr SvmKeyWdStr = SvmKeyWdSpV-&gt;GetStr(BowDocBs, 10, 1.0, &quot;, &quot;, false, true);
265      SOut-&gt;PutStrLn(&quot;  &lt;jsikm:hasSVMKeywords&gt;&quot; + SvmKeyWdStr + &quot;&lt;/jsikm:hasSVMKeywords&gt;&quot;);
266      SOut-&gt;PutStrLn(&quot;&lt;/jsikm:OntoGenClassProperties&gt;&quot;);
267      SOut-&gt;PutStrLn(&quot;&quot;);
268  }
269  void TOntoExportPTO::PutDoc(const int&amp; DId, const TStr&amp; DocTitle, 
270          const TStr&amp; DocAbstract, const TIntStrPrV&amp; CptIdNmV) {
271      SOut-&gt;PutStrLn(&quot;&lt;ptop:Document rdf:about=\&quot;#Doc&quot; + GetUri(DId, DocTitle) + &quot;\&quot;&gt;&quot;);
272      for (int CptIdN = 0; CptIdN &lt; CptIdNmV.Len(); CptIdN++) {
273          const int CptId = CptIdNmV[CptIdN].Val1;
274          TStr CptNm = CptIdNmV[CptIdN].Val2;
275          SOut-&gt;PutStrLn(&quot;  &lt;ptop:hasSubject rdf:resource=\&quot;#Cpt&quot; + 
276              GetUri(CptId, CptNm) + &quot;\&quot; /&gt;&quot;);
277      }
278      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
279      CleanDocAbstract.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;); CleanDocAbstract.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;);
280      SOut-&gt;PutStrLn(TStr::Fmt(&quot;  &lt;ptop:documentAbstract&gt;%s&lt;/ptop:documentAbstract&gt;&quot;, CleanDocAbstract.CStr()));
281      SOut-&gt;PutStrLn(TStr::Fmt(&quot;  &lt;jsikm:hasOntoGenInstanceProperties rdf:resource=\&quot;#INST_PROP_%d\&quot; /&gt;&quot;, DId));
282      SOut-&gt;PutStrLn(&quot;&lt;/ptop:Document&gt;&quot;);
283      TStr ShortBowFNm = BowFNmStr.GetFMid() + BowFNmStr.GetFExt();
284      SOut-&gt;PutStrLn(TStr::Fmt(&quot;&lt;jsikm:OntoGenInstanceProperties rdf:about=\&quot;#INST_PROP_%d\&quot;&gt;&quot;, DId));
285      SOut-&gt;PutStrLn(TStr::Fmt(&quot;  &lt;jsikm:locationOfInstance&gt;%s#%d&lt;/jsikm:locationOfInstance&gt;&quot;, ShortBowFNm.CStr(), DId));
286      SOut-&gt;PutStrLn(&quot;&lt;/jsikm:OntoGenInstanceProperties&gt;&quot;);
287      SOut-&gt;PutStrLn(&quot;&quot;);
288  }
289  void TOntoExportProlog::StartExport() {
290      SOut-&gt;PutStrLn(&quot;% OntoGen export in Prolog.&quot;);
291  }
292  void TOntoExportProlog::EndExport() {
293      SOut-&gt;Flush();
294  }
295  void TOntoExportProlog::PutCpt(const int&amp; CptId, const TStr CptNm, 
296          const TIntStrPrV&amp; SubCptIdNmV, const TIntStrPrV&amp; SuperCptIdNmV, 
297          const TIntV&amp; DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
298          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
299      SOut-&gt;PutStrLn(TStr::Fmt(&quot;class( %s, label, &#x27;%s&#x27; ).&quot;, 
300          GetCptLabel(CptId).CStr(), CptNm.CStr()));
301      for (int SuperCptN = 0; SuperCptN &lt; SuperCptIdNmV.Len(); SuperCptN++) {
302          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
303          SOut-&gt;PutStrLn(TStr::Fmt(&quot;subClassOf( %s, %s ).&quot;, 
304              GetCptLabel(CptId).CStr(), GetCptLabel(SuperCptId).CStr()));
305      }
306  }
307  void TOntoExportProlog::PutDoc(const int&amp; DId, const TStr&amp; DocTitle, 
308          const TStr&amp; DocAbstract, const TIntStrPrV&amp; CptIdNmV) {
309      TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll(&#x27;\&#x27;&#x27;);
310      CleanDocTitle.DelChAll(&#x27;\n&#x27;); CleanDocTitle.DelChAll(&#x27;\r&#x27;);
311      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
312      CleanDocAbstract.DelChAll(&#x27;\&#x27;&#x27;); CleanDocAbstract.DelChAll(&#x27;\n&#x27;); 
313      CleanDocAbstract.DelChAll(&#x27;\r&#x27;);
314      SOut-&gt;PutStrLn(TStr::Fmt(&quot;instance( %s, label, &#x27;%s&#x27; ).&quot;, 
315          GetInstLabel(DId).CStr(), CleanDocTitle.CStr()));
316      SOut-&gt;PutStrLn(TStr::Fmt(&quot;instance( %s, text, &#x27;%s&#x27; ).&quot;, 
317          GetInstLabel(DId).CStr(), CleanDocAbstract.CStr()));
318      for (int CptIdN = 0; CptIdN &lt; CptIdNmV.Len(); CptIdN++) {
319          const int CptId = CptIdNmV[CptIdN].Val1;
320          SOut-&gt;PutStrLn(TStr::Fmt(&quot;instanceOf( %s, %s ).&quot;, 
321              GetInstLabel(DId).CStr(), GetCptLabel(CptId).CStr()));
322      }
323  }
324  TStr TOntoExportOWL::GetUri(const int&amp; Id, const TStr&amp; Nm) {
325      TChA CleanChA; bool ToUc = true;
326      for (int ChN = 0; ChN &lt; Nm.Len(); ChN++) {
327          char Ch = Nm[ChN];
328          if (TCh::IsAlpha(Ch)) { 
329              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
330              CleanChA += Ch; 
331          } else { ToUc = true; }
332      }
333      return TInt::GetStr(Id) + &quot;_&quot; + TStr(CleanChA);
334  }
335  void TOntoExportOWL::StartExport() {
336      SOut-&gt;PutStrLn(&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&quot;);
337      SOut-&gt;PutStrLn(&quot;&lt;rdf:RDF&quot;);
338      SOut-&gt;PutStrLn(&quot;    xmlns:rdf=\&quot;http:&amp;bsol;&amp;bsol;www.w3.org/1999/02/22-rdf-syntax-ns#\&quot;&quot;);
339      SOut-&gt;PutStrLn(&quot;    xmlns:xsd=\&quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema#\&quot;&quot;);
340      SOut-&gt;PutStrLn(&quot;    xmlns:rdfs=\&quot;http:&amp;bsol;&amp;bsol;www.w3.org/2000/01/rdf-schema#\&quot;&quot;);
341      SOut-&gt;PutStrLn(&quot;    xmlns:owl=\&quot;http:&amp;bsol;&amp;bsol;www.w3.org/2002/07/owl#\&quot;&quot;);
342      SOut-&gt;PutStrLn(&quot;    xmlns=\&quot;http:&amp;bsol;&amp;bsol;www.owl-ontologies.com/Ontology1150050933.owl#\&quot;&quot;);
343      SOut-&gt;PutStrLn(&quot;    xml:base=\&quot;http:&amp;bsol;&amp;bsol;www.owl-ontologies.com/Ontology1150050933.owl\&quot;&gt;&quot;);
344      SOut-&gt;PutStrLn(&quot;&quot;);
345      SOut-&gt;PutStrLn(&quot;&lt;owl:Ontology rdf:about=\&quot;OntoGen OWL export\&quot;/&gt;&quot;);
346      SOut-&gt;PutStrLn(&quot;&quot;);
347  }
348  void TOntoExportOWL::EndExport() {
349      SOut-&gt;PutStrLn(&quot;&quot;);
350      SOut-&gt;PutStrLn(&quot;&lt;/rdf:RDF&gt;&quot;);
351      SOut-&gt;Flush();
352  }
353  void TOntoExportOWL::PutCpt(const int&amp; CptId, const TStr CptNm, 
354          const TIntStrPrV&amp; SubCptIdNmV, const TIntStrPrV&amp; SuperCptIdNmV, 
355          const TIntV&amp; DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
356          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
357      SOut-&gt;PutStrLn(&quot;&lt;owl:Class rdf:ID=\&quot;Cpt&quot; + GetUri(CptId, CptNm) + &quot;\&quot;&gt;&quot;);
358      SOut-&gt;PutStrLn(&quot;  &lt;rdfs:label&gt;&quot; + CptNm + &quot;&lt;/rdfs:label&gt;&quot;);
359      for (int SuperCptN = 0; SuperCptN &lt; SuperCptIdNmV.Len(); SuperCptN++) {
360          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
361          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
362          SOut-&gt;PutStrLn(&quot;  &lt;rdfs:subClassOf rdf:resource=\&quot;#Cpt&quot; + 
363              GetUri(SuperCptId, SuperCptNm) + &quot;\&quot;/&gt;&quot;);
364      }
365      SOut-&gt;PutStrLn(&quot;&lt;/owl:Class&gt;&quot;);
366      SOut-&gt;PutStrLn(&quot;&quot;);
367  }
368  void TOntoExportOWL::PutDoc(const int&amp; DId, const TStr&amp; DocTitle, 
369          const TStr&amp; DocAbstract, const TIntStrPrV&amp; CptIdNmV) {
370      if (!StoreDocsP) { return; }
371      for (int CptIdN = 0; CptIdN &lt; CptIdNmV.Len(); CptIdN++) {
372          const int CptId = CptIdNmV[CptIdN].Val1;
373          TStr CptNm = CptIdNmV[CptIdN].Val2;
374          SOut-&gt;PutStrLn(&quot;&lt;Cpt&quot; + GetUri(CptId, CptNm) + &quot; rdf:ID=\&quot;Doc&quot; + 
375              GetUri(DId, DocTitle) + &quot;\&quot;&gt;&quot;);
376          if (CptIdN == 0) {
377              TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll(&#x27;\&#x27;&#x27;);
378              CleanDocTitle.DelChAll(&#x27;\n&#x27;); CleanDocTitle.DelChAll(&#x27;\r&#x27;);
379              SOut-&gt;PutStrLn(&quot;  &lt;rdfs:label&gt;&quot; + CleanDocTitle + &quot;&lt;/rdfs:label&gt;&quot;);
380              if (StoreAbstractsP) {
381                  TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
382                  CleanDocAbstract.DelChAll(&#x27;\&#x27;&#x27;); CleanDocAbstract.DelChAll(&#x27;\n&#x27;); 
383                  CleanDocAbstract.DelChAll(&#x27;\r&#x27;);
384                  SOut-&gt;PutStrLn(&quot;  &lt;rdfs:comment&gt;&quot; + CleanDocAbstract + &quot;&lt;/rdfs:label&gt;&quot;);
385              }
386          }
387          SOut-&gt;PutStrLn(&quot;&lt;/Cpt&quot; + GetUri(CptId, CptNm) + &quot;&gt;&quot;);
388      }
389      SOut-&gt;PutStrLn(&quot;&quot;);
390  }
391  void TOntoExportOWL::PutRltType(const TStr&amp; RltNm, const bool&amp; DirectedP,
392          const bool&amp; TransitiveP) {
393      SOut-&gt;PutStrLn(&quot;&lt;owl:ObjectProperty rdf:ID=\&quot;&quot; + RltNm + &quot;\&quot;/&gt;&quot;);
394      SOut-&gt;PutStrLn(&quot;&quot;);    
395  }
396  void TOntoExportOWL::PutRlt(const TStr&amp; RltNm, const int&amp; SrcCptId, 
397          const TStr SrcCptNm, const int&amp; DstCptId, const TStr DstCptNm) {
398      SOut-&gt;PutStrLn(&quot;&lt;owl:Class rdf:ID=\&quot;Cpt&quot; + GetUri(SrcCptId, SrcCptNm) + &quot;\&quot;&gt;&quot;);
399      SOut-&gt;PutStrLn(&quot;  &lt;rdfs:subClassOf&gt;&lt;owl:Restriction&gt;&quot;);
400      SOut-&gt;PutStrLn(&quot;    &lt;owl:onProperty rdf:resource=\&quot;#&quot; + RltNm + &quot;\&quot;/&gt;&quot;);
401      SOut-&gt;PutStrLn(&quot;    &lt;owl:someValuesFrom&gt;&quot;);
402      SOut-&gt;PutStrLn(&quot;      &lt;owl:Class rdf:ID=\&quot;Cpt&quot; + GetUri(DstCptId, DstCptNm) + &quot;\&quot;/&gt;&quot;);
403      SOut-&gt;PutStrLn(&quot;    &lt;/owl:someValuesFrom&gt;&quot;);
404      SOut-&gt;PutStrLn(&quot;  &lt;/owl:Restriction&gt;&lt;/rdfs:subClassOf&gt;&quot;);
405      SOut-&gt;PutStrLn(&quot;&lt;/owl:Class&gt;&quot;);
406      SOut-&gt;PutStrLn(&quot;&quot;);    
407  }
408  TOntology::TOntology(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs, 
409      const TBowSimType&amp; BowSimType): BowDocBs(_BowDocBs), 
410          BowDocWgtBs(_BowDocWgtBs) {
411      BowSim = TBowSim::New(BowSimType);
412      OntoGraph = TGGraph::New();
413      UniqueId = TUniqueId::New(0);
414      GenerateEmptyOnto();
415  }
416  void TOntology::GenerateEmptyOnto() {
417      TIntV AllDIdV; BowDocBs-&gt;GetAllDIdV(AllDIdV);
418      POntoConcept RootCpt = TOntoConcept::New(BowDocBs, 
419          BowDocWgtBs, UniqueId-&gt;GetNextId(), AllDIdV);
420      RootCpt-&gt;SetName(&quot;root&quot;);
421      AddConcept(RootCpt, -1);
422      OntoGraph-&gt;GetPp()-&gt;AddPpStr(&quot;BoldVNm&quot;, &quot;&quot;, &quot;root&quot;);
423      RltTypeV.Add(TOntoRltType(TOntoRltType::SubCptOfRltStr, true, true));
424      RltTypeV.Add(TOntoRltType(TOntoRltType::SimilarRltStr, false, false));
425  }
426  void TOntology::RefreshCptIdPosH() {
427      CptIdPosH.Clr();
428      for (int CptC = 0; CptC &lt; ConceptV.Len(); CptC++) {
429          const int CptId = ConceptV[CptC]-&gt;GetId();
430          IAssertR(!CptIdPosH.IsKey(CptId), &quot;Concept ID not unique!&quot;);
431          CptIdPosH.AddDat(CptId, CptC);
432      }
433  }
434  void TOntology::ReconnectToRoot() {
435      for (int CptC = 0; CptC &lt; ConceptV.Len(); CptC++) {
436          const int CptId = ConceptV[CptC]-&gt;GetId();
437          if (!IsRootCpt(CptId) &amp;&amp; !HasSuperCpt(CptId)) {
438              AddRlt(CptId, 0, TOntoRltType::SubCptOfRltStr);
439          }
440      }
441  }
442  void TOntology::AddRltsFromList(TIntStrPrV&amp; InRltV, 
443          TIntStrPrV&amp; OutRltV, TIntStrPrV&amp; UndirRltV) {
444      for (int InEdN = 0; InEdN &lt; InRltV.Len(); InEdN++) {
445          const int CptId1 = InRltV[InEdN].Val1;
446          TStr RltNm1 = InRltV[InEdN].Val2; Assert(IsRltDir(RltNm1));
447          for (int OutEdN = 0; OutEdN &lt; OutRltV.Len(); OutEdN++) {
448              const int CptId2 = OutRltV[OutEdN].Val1;
449              TStr RltNm2 = OutRltV[OutEdN].Val2; Assert(IsRltDir(RltNm2));
450              if (CptId1 != CptId2 &amp;&amp; RltNm1 == RltNm2) {
451                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
452                  if (!IsRltTransitive(RltNm1)) continue;
453                  AddRlt(CptId1, CptId2, RltNm1);
454              }
455          }
456      }
457      for (int InEdN = 0; InEdN &lt; UndirRltV.Len(); InEdN++) {
458          const int CptId1 = UndirRltV[InEdN].Val1;
459          TStr RltNm1 = UndirRltV[InEdN].Val2; Assert(!IsRltDir(RltNm1));
460          for (int OutEdN = 0; OutEdN &lt; UndirRltV.Len(); OutEdN++) {
461              const int CptId2 = UndirRltV[OutEdN].Val1;
462              TStr RltNm2 = UndirRltV[OutEdN].Val2; Assert(!IsRltDir(RltNm2));
463              if (CptId1 != CptId2 &amp;&amp; RltNm1 == RltNm2) {
464                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
465                  if (!IsRltTransitive(RltNm1)) continue;
466                  AddRlt(CptId1, CptId2, RltNm1);
467              }
468          }
469      }
470  }
471  void TOntology::AddSonDIdV(const int&amp; CptId, TIntV&amp; SonDIdV) {
472      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
473      for (int SubCptIdN = 0; SubCptIdN &lt; SubCptIdV.Len(); SubCptIdN++) {
474          const int SubCptId = SubCptIdV[SubCptIdN];
475          TIntV SubCptDIdV; GetCptDIdV(SubCptId, SubCptDIdV);
476          SonDIdV.Union(SubCptDIdV);
477          AddSonDIdV(SubCptId, SonDIdV);
478      }
479  }
480  void TOntology::CfyDIdR(const int&amp; DId, const TIntV&amp; CptIdV, TIntFltKdV&amp; CfyResV) {
481      for (int CptIdN = 0; CptIdN &lt; CptIdV.Len(); CptIdN++) {
482          const int CptId = CptIdV[CptIdN];
483          POntoConcept Cpt = GetConcept(CptId);
484          if (Cpt-&gt;IsCptMd()) {
485              bool IsDocInCpt; double Prob;
486              Cpt-&gt;CfyDocSpV(BowDocWgtBs-&gt;GetSpV(DId), IsDocInCpt, Prob);
487              if (IsDocInCpt) {
488                  CfyResV.Add(TIntFltKd(CptId, Prob));
489                  TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
490                  CfyDIdR(DId, SubCptIdV, CfyResV);
491              }
492          }
493      }
494  }
495  void TOntology::Export(POntoExport OntoExport) {
496      OntoExport-&gt;StartExport();
497      TIntV CptIdV; GetCptIdV(CptIdV);
498      TIntIntVH DIdCptIdVH;
499      for (int CptN = 0; CptN &lt; CptIdV.Len(); CptN++) {
500          const int CptId = CptIdV[CptN];
501          TStr CptNm = TXmlDoc::GetXmlStr(GetCptName(CptId));
502          if (OntoExport-&gt;IsCptAlwaysSvm()) { ExtractKeywords(CptId); }
503          TIntStrPrV SubCptIdNmV;
504          if (OntoExport-&gt;IsCptSubCptLink()) {
505              TIntStrPrV CptInRltV; GetCptInRltV(CptId, CptInRltV);
506              for (int SubCptN = 0; SubCptN &lt; CptInRltV.Len(); SubCptN++) {
507                  TStr RltNm = CptInRltV[SubCptN].Val2;
508                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
509                      const int SubCptId = CptInRltV[SubCptN].Val1;
510                      TStr SubCptNm = GetCptName(SubCptId);
511                      SubCptIdNmV.Add(TIntStrPr(SubCptId, SubCptNm));
512                  }
513              }
514          }
515          TIntStrPrV SuperCptIdNmV;
516          if (OntoExport-&gt;IsCptSuperCptLink()) {
517              TIntStrPrV CptOutRltV; GetCptOutRltV(CptId, CptOutRltV);
518              for (int SuperCptN = 0; SuperCptN &lt; CptOutRltV.Len(); SuperCptN++) {
519                  TStr RltNm = CptOutRltV[SuperCptN].Val2;
520                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
521                      const int SuperCptId = CptOutRltV[SuperCptN].Val1;
522                      TStr SuperCptNm = GetCptName(SuperCptId);
523                      SuperCptIdNmV.Add(TIntStrPr(SuperCptId, SuperCptNm));
524                  }
525              }
526          }
527          TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
528          for (int DocN = 0; DocN &lt; CptDIdV.Len(); DocN++) {
529              const int DId = CptDIdV[DocN];
530              if (DIdCptIdVH.IsKey(DId)) {
531                  DIdCptIdVH.GetDat(DId).Add(CptId);
532              } else {
533                  DIdCptIdVH.AddDat(DId, TIntV::GetV(CptId));
534              }
535          }
536          if (!OntoExport-&gt;IsCptDocLink()) { CptDIdV.Clr(); }
537          OntoExport-&gt;PutCpt(CptId, CptNm, SubCptIdNmV, SuperCptIdNmV, 
538              CptDIdV, BowDocBs, GetConcept(CptId)-&gt;GetCentroidSpV(), 
539              GetConcept(CptId)-&gt;GetSvmSpV(), TBowSpV::New(-1));
540      }
541      TIntV AllDIdV; BowDocBs-&gt;GetAllDIdV(AllDIdV);
542      for (int DocN = 0; DocN &lt; AllDIdV.Len(); DocN++) {
543          const int DId = AllDIdV[DocN];
544          TStr DocTitle = BowDocBs-&gt;GetDocNm(DId);
545          TStr DocAbstract = BowDocBs-&gt;GetDocStr(DId);
546          TIntStrPrV CptIdNmV;
547          if (DIdCptIdVH.IsKey(DId) &amp;&amp; OntoExport-&gt;IsDocCptLink()) {
548              TIntV&amp; DocCptIdV = DIdCptIdVH.GetDat(DId);
549              for (int DocCptIdN = 0; DocCptIdN &lt; DocCptIdV.Len(); DocCptIdN++) {
550                  const int CptId = DocCptIdV[DocCptIdN];
551                  TStr CptNm = GetCptName(CptId);
552                  CptIdNmV.Add(TIntStrPr(CptId, CptNm));
553              }
554          }
555          OntoExport-&gt;PutDoc(DId, DocTitle, DocAbstract, CptIdNmV);
556      }        
557      if (OntoExport-&gt;IsRlt()) {
558          const int RltTypes = GetRltTypes();
559          for (int RltTypeN = 0; RltTypeN &lt; RltTypes; RltTypeN++) {
560              TStr RltTypeNm = GetRltTypeNm(RltTypeN);
561              if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
562                  OntoExport-&gt;PutRltType(RltTypeNm, 
563                      IsRltDir(RltTypeNm), IsRltTransitive(RltTypeNm));
564              }
565          }
566          for (int CptN = 0; CptN &lt; CptIdV.Len(); CptN++) {
567              const int SrcCptId = CptIdV[CptN];
568              TStr SrcCptNm = GetCptName(SrcCptId);
569              TIntStrPrV CptOutRltV; GetCptOutRltV(SrcCptId, CptOutRltV);
570              for (int OutRltN = 0; OutRltN &lt; CptOutRltV.Len(); OutRltN++) {
571                  const TStr&amp; RltTypeNm = CptOutRltV[OutRltN].Val2;
572                  if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
573                      const int DstCptId = CptOutRltV[OutRltN].Val1;
574                      OntoExport-&gt;PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
575                          DstCptId, GetCptName(DstCptId));
576                  }
577              }
578              TIntStrPrV CptUndirRltV; GetCptUndirRltV(SrcCptId, CptUndirRltV);
579              for (int UndirRltN = 0; UndirRltN &lt; CptUndirRltV.Len(); UndirRltN++) {
580                  const TStr&amp; RltTypeNm = CptUndirRltV[UndirRltN].Val2;
581                  const int DstCptId = CptUndirRltV[UndirRltN].Val1;
582                  if (SrcCptId &lt; DstCptId) {
583                      OntoExport-&gt;PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
584                          DstCptId, GetCptName(DstCptId));
585                  }
586              }
587          }
588      }
589      OntoExport-&gt;EndExport();
590  }
591  void TOntology::GetCptIdV(TIntV&amp; CptIdV) {
592      CptIdV.Gen(ConceptV.Len(), 0);
593      for (int CptIdN = 0; CptIdN &lt; ConceptV.Len(); CptIdN++) {
594          CptIdV.Add(ConceptV[CptIdN]-&gt;GetId());
595      }
596      CptIdV.Sort();
597  }
598  void TOntology::SetCptName(const int&amp; CptId, const TStr&amp; NewName) {
599      GetConcept(CptId)-&gt;SetName(NewName);
600      OntoGraph-&gt;GetVrtx(CptId)-&gt;PutDNm(NewName);
601  }
602  void TOntology::SetCptDIdV(const int&amp; CptId, const TIntV&amp; _NewDIdV, const bool&amp; PropagateP) {
603      if (PropagateP) {
604          TIntV NewDIdV = _NewDIdV;
605          if (!NewDIdV.IsSorted()) { NewDIdV.Sort(); }
606          TIntV OldDIdV; GetCptDIdV(CptId, OldDIdV);
607          TIntV BothDIdV; OldDIdV.Union(NewDIdV, BothDIdV);
608          TIntV AddDIdV; BothDIdV.Diff(OldDIdV, AddDIdV);
609          AddUpDIdV(CptId, AddDIdV);
610          TIntV DelDIdV; BothDIdV.Diff(NewDIdV, DelDIdV);
611          DelDownDIdV(CptId, DelDIdV);
612      } else {
613          GetConcept(CptId)-&gt;SetDIdV(BowDocWgtBs, _NewDIdV);
614      }
615  }
616  void TOntology::GetCptSimV(const int&amp; CptId, TFltIntKdV&amp; SimCptIdV) {
617      PBowSpV CptSpV = GetConcept(CptId)-&gt;GetCentroidSpV();
618      SimCptIdV.Gen(GetConcepts() - 1, 0);
619      for (int CptN = 0; CptN &lt; GetConcepts(); CptN++) {
620          const int CptId2 = ConceptV[CptN]-&gt;GetId();
621          if (CptId != CptId2) {
622              PBowSpV CptSpV2 = ConceptV[CptN]-&gt;GetCentroidSpV();
623              SimCptIdV.Add(TFltIntKd(BowSim-&gt;GetSim(CptSpV, CptSpV2), CptId2));
624          }
625      }
626      SimCptIdV.Sort(false);
627  }
628  void TOntology::CalcCptMd(const int&amp; CptId, const double&amp; SvmC, 
629          const double&amp; SvmJ, const int&amp; SvmTime) {
630      if (IsRootCpt(CptId)) return;
631      TIntV ContextDIdV; BowDocBs-&gt;GetAllDIdV(ContextDIdV);
632      GetConcept(CptId)-&gt;CalcCptMd(BowDocBs, ContextDIdV, SvmC, SvmJ, SvmTime);
633  }
634  void TOntology::CfyDId(const int&amp; DId, TIntFltKdV&amp; CfyResV) {
635      const int CptIds = GetConcepts(); CfyResV.Gen(CptIds, 0);
636      for (int CptIdN = 0; CptIdN &lt; CptIds; CptIdN++) {
637          const int CptId = GetCptId(CptIdN);
638          POntoConcept Cpt = GetConcept(CptId);
639          if (Cpt-&gt;IsCptMd()) {
640              bool IsDocInCpt; double Prob;
641              Cpt-&gt;CfyDocSpV(BowDocWgtBs-&gt;GetSpV(DId), IsDocInCpt, Prob);
642              if (IsDocInCpt) {
643                  CfyResV.Add(TIntFltKd(CptId, Prob));
644              } else {
645                  CfyResV.Add(TIntFltKd(CptId, Prob - 1.0));
646              }
647          } else if (IsRootCpt(CptId)) {
648              CfyResV.Add(TIntFltKd(CptId, 1.0));
649          } else {
650              CfyResV.Add(TIntFltKd(CptId, -1.0));
651          }
652      }
653      CfyResV.Sort();
654  }
655  void TOntology::IncludeLnDocs(const TStr&amp; LnDocFNm, TIntV&amp; NewDIdV) {
656      TBowFl::LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, true, -1, true);    
657      NewDIdV.Sort(); ReCalcWgtBs(); 
658      GetRootCpt()-&gt;AddDIdV(BowDocWgtBs, NewDIdV); 
659  }
660  void TOntology::IncludeFolder(const TStr&amp; FPath, TIntV&amp; NewDIdV, const bool&amp; RecurseDirP) {
661      TBowFl::LoadHtmlTxt(BowDocBs, FPath, NewDIdV, RecurseDirP, -1, true);
662      NewDIdV.Sort(); ReCalcWgtBs(); 
663      GetRootCpt()-&gt;AddDIdV(BowDocWgtBs, NewDIdV); 
664  }
665  void TOntology::AddDocToCptV(const int&amp; DId, const TIntV&amp; CptIdV, const bool&amp; UpdateCentroidP) {
666      for (int CptIdN = 0; CptIdN &lt; CptIdV.Len(); CptIdN++) {
667          const int CptId = CptIdV[CptIdN];
668          if (UpdateCentroidP) {
669              GetConcept(CptId)-&gt;AddDId(BowDocWgtBs, DId);
670          } else {
671              GetConcept(CptId)-&gt;AddDId(NULL, DId);
672          }
673      }
674  }
675  void TOntology::ResetAllCptKeyWd() {
676      const int CptIds = GetConcepts();
677      for (int CptIdN = 0; CptIdN &lt; CptIds; CptIdN++) {
678          const int CptId = GetCptId(CptIdN);
679          if (!GetConcept(CptId)-&gt;IsCentroidValid()) {
680              GetConcept(CptId)-&gt;ResetCentroidSpV(BowDocWgtBs);
681          }
682      }
683  }
684  void TOntology::GetSubCptIdV(const int&amp; CptId, TIntV&amp; SubCptIdV) {
685      TIntStrPrV InRltV; GetCptInRltV(CptId, InRltV);
686      SubCptIdV.Gen(InRltV.Len(), 0);
687      for (int InRltN = 0; InRltN &lt; InRltV.Len(); InRltN++) {
688          if (InRltV[InRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
689              SubCptIdV.Add(InRltV[InRltN].Val1);
690          }
691      }
692      SubCptIdV.Sort();
693  }
694  void TOntology::GetSuperCptIdV(const int&amp; CptId, TIntV&amp; SuperCptIdV) {
695      TIntStrPrV OutRltV; GetCptOutRltV(CptId, OutRltV);
696      SuperCptIdV.Gen(OutRltV.Len(), 0);
697      for (int OutRltN = 0; OutRltN &lt; OutRltV.Len(); OutRltN++) {
698          if (OutRltV[OutRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
699              SuperCptIdV.Add(OutRltV[OutRltN].Val1);
700          }
701      }
702      SuperCptIdV.Sort();
703  }
704  void TOntology::GetCptUnusedDIdV(const int&amp; CptId, TIntV&amp; DIdV) {
705      GetConcept(CptId)-&gt;GetDIdV(DIdV);
706      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
707      for (int SubCptN = 0; SubCptN &lt; SubCptIdV.Len(); SubCptN++) {
708          const int SubCptId = SubCptIdV[SubCptN];
709          TIntV SubDIdV; GetConcept(SubCptId)-&gt;GetDIdV(SubDIdV);
710          DIdV.Diff(SubDIdV);
711      }   
712  }
713  void TOntology::GetCptContextDIdV(const int&amp; CptId, 
714          TIntV&amp; ContextDIdV, const bool&amp; AddSonDIdP) {
715      ContextDIdV.Clr();
716      GetConcept(CptId)-&gt;GetDIdV(ContextDIdV);
717      if (HasSuperCpt(CptId)) {
718          TIntV SuperCptIdV, SuperDIdV; GetSuperCptIdV(CptId, SuperCptIdV);
719          for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
720              const int SuperCptId = SuperCptIdV[SuperCptIdN];
721              GetConcept(SuperCptId)-&gt;GetDIdV(SuperDIdV);    
722              ContextDIdV.Union(SuperDIdV);
723          }
724      }
725      if (AddSonDIdP) AddSonDIdV(CptId, ContextDIdV);
726  }
727  void TOntology::GetInconsistDIdV(const int&amp; CptId, TIntV&amp; InconsistDIdV) {
728      InconsistDIdV.Clr();
729      TIntV SonDIdV; AddSonDIdV(CptId, SonDIdV);
730      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
731      SonDIdV.Union(CptDIdV); 
732      SonDIdV.Diff(CptDIdV, InconsistDIdV);
733  }
734  void TOntology::GetCptDocSimV(const int&amp; CptId, const TIntV&amp; DIdV, TFltV&amp; CptDocSimV) {
735      PBowSpV CptSpV = GetConcept(CptId)-&gt;GetCentroidSpV();
736      const int Docs = DIdV.Len(); CptDocSimV.Gen(Docs, 0);
737      for (int DocN = 0; DocN &lt; Docs; DocN++) {
738          PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DIdV[DocN]);
739          CptDocSimV.Add(BowSim-&gt;GetSim(CptSpV, DocSpV));
740      }
741  }
742  void TOntology::AddUpDIdV(const int&amp; CptId, const TIntV&amp; SubDIdV) {
743      GetConcept(CptId)-&gt;AddDIdV(BowDocWgtBs, SubDIdV);
744      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
745      for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
746          const int SuperCptId = SuperCptIdV[SuperCptIdN];
747          if (!IsRootCpt(SuperCptId)) { AddUpDIdV(SuperCptId, SubDIdV); }
748      }
749  }
750  void TOntology::DelUpDIdV(const int&amp; CptId, const TIntV&amp; SubDIdV) {
751      GetConcept(CptId)-&gt;DelDIdV(BowDocWgtBs, SubDIdV);
752      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
753      for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
754          const int SuperCptId = SuperCptIdV[SuperCptIdN];
755          if (!IsRootCpt(SuperCptId)) { DelUpDIdV(SuperCptId, SubDIdV); }
756      }
757  }
758  void TOntology::DelDownDIdV(const int&amp; CptId, const TIntV&amp; SubDIdV) {
759      GetConcept(CptId)-&gt;DelDIdV(BowDocWgtBs, SubDIdV);
760      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
761      for (int SubCptIdN = 0; SubCptIdN &lt; SubCptIdV.Len(); SubCptIdN++) {
762          const int SubCptId = SubCptIdV[SubCptIdN];
763          DelDownDIdV(SubCptId, SubDIdV);
764      }
765  }
766  void TOntology::DelDownDId(const int&amp; CptId, const int&amp; DId) {
767      GetConcept(CptId)-&gt;DelDId(BowDocWgtBs, DId);
768      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
769      for (int SubCptIdN = 0; SubCptIdN &lt; SubCptIdV.Len(); SubCptIdN++) {
770          const int SubCptId = SubCptIdV[SubCptIdN];
771          DelDownDId(SubCptId, DId);
772      }
773  }
774  void TOntology::GetCptInRltV(const int&amp; CptId, TIntStrPrV&amp; InRltV) {
775      POntoConcept Cpt = GetConcept(CptId);
776      PVrtx CptVrtx = OntoGraph-&gt;GetVrtx(CptId);
777      InRltV.Gen(CptVrtx-&gt;GetInEIds(), 0);
778      for (int InEIdN = 0; InEIdN &lt; CptVrtx-&gt;GetInEIds(); InEIdN++) {
779          PEdge InEdge = OntoGraph-&gt;GetEdge(CptVrtx-&gt;GetInEId(InEIdN));
780          if (InEdge-&gt;IsDir()) 
781              InRltV.Add(TIntStrPr(InEdge-&gt;GetOtherVId(CptVrtx), InEdge-&gt;GetDNm()));
782      }
783      InRltV.Sort();
784  }
785  void TOntology::GetCptOutRltV(const int&amp; CptId, TIntStrPrV&amp; OutRltV) {
786      POntoConcept Cpt = GetConcept(CptId);
787      PVrtx CptVrtx = OntoGraph-&gt;GetVrtx(CptId);
788      OutRltV.Gen(CptVrtx-&gt;GetOutEIds(), 0);
789      for (int OutEIdN = 0; OutEIdN &lt; CptVrtx-&gt;GetOutEIds(); OutEIdN++) {
790          PEdge OutEdge = OntoGraph-&gt;GetEdge(CptVrtx-&gt;GetOutEId(OutEIdN));
791          if (OutEdge-&gt;IsDir()) 
792              OutRltV.Add(TIntStrPr(OutEdge-&gt;GetOtherVId(CptVrtx), OutEdge-&gt;GetDNm()));
793      }
794      OutRltV.Sort();
795  }
796  void TOntology::GetCptUndirRltV(const int&amp; CptId, TIntStrPrV&amp; UndirRltV) {
797      POntoConcept Cpt = GetConcept(CptId);
798      PVrtx CptVrtx = OntoGraph-&gt;GetVrtx(CptId);
799      UndirRltV.Gen(CptVrtx-&gt;GetOutEIds(), 0);
800      for (int OutEIdN = 0; OutEIdN &lt; CptVrtx-&gt;GetOutEIds(); OutEIdN++) {
801          PEdge OutEdge = OntoGraph-&gt;GetEdge(CptVrtx-&gt;GetOutEId(OutEIdN));
802          if (!OutEdge-&gt;IsDir()) 
803              UndirRltV.Add(TIntStrPr(OutEdge-&gt;GetOtherVId(CptVrtx), OutEdge-&gt;GetDNm()));
804      }
805      UndirRltV.Sort();
806  }
807  void TOntology::GetCptRltV(const int&amp; CptId, TIntStrPrV&amp; InRltV, 
808          TIntStrPrV&amp; OutRltV, TIntStrPrV&amp; UndirRltV) {
809      GetCptInRltV(CptId, InRltV);
810      GetCptOutRltV(CptId, OutRltV); 
811      GetCptUndirRltV(CptId, UndirRltV); 
812  }
813  int TOntology::GetRltTypeN(const TStr&amp; RltTypeNm) const {
814      for (int RltTypeN = 0; RltTypeN &lt; RltTypeV.Len(); RltTypeN++) {
815          if (RltTypeV[RltTypeN].IsType(RltTypeNm)) {
816              return RltTypeN;
817          }
818      }
819      return -1;
820  }
821  bool TOntology::IsRlt(const int&amp; CptId1, const int&amp; CptId2, const TStr&amp; RltTypeNm) {
822      Assert(IsCptId(CptId1) &amp;&amp; IsCptId(CptId2));
823      PEdge Edge; 
824      if (OntoGraph-&gt;IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
825          return (Edge-&gt;GetDNm() == RltTypeNm);
826      }
827      return false;
828  }
829  void TOntology::AddRlt(const int&amp; CptId1, const int&amp; CptId2, const TStr&amp; RltTypeNm) {
830      Assert(IsCptId(CptId1) &amp;&amp; IsCptId(CptId2));
831      const bool IsDir = IsRltDir(RltTypeNm);
832      PEdge NewEdge = TGEdge::New(OntoGraph-&gt;GetVrtx(CptId1), 
833          OntoGraph-&gt;GetVrtx(CptId2), RltTypeNm, IsDir);
834      NewEdge-&gt;PutDNm(RltTypeNm);
835      OntoGraph-&gt;AddEdge(NewEdge);
836  }
837  bool TOntology::DelRlt(const int&amp; CptId1, const int&amp; CptId2, const TStr&amp; RltTypeNm) {
838      Assert(IsCptId(CptId1) &amp;&amp; IsCptId(CptId2));
839      PEdge Edge; bool DeletedP = false;
840      if (OntoGraph-&gt;IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
841          if (Edge-&gt;GetDNm() == RltTypeNm) {
842              OntoGraph-&gt;DelEdge(Edge);
843              DeletedP = true;
844          } else {
845              InfoNotify(&quot;There is no such relationship!!&quot;);
846          }
847      } else {
848          InfoNotify(&quot;There is no such relationship&quot;);
849          AssertR(false, TStr(&quot;There is no such relationship&quot;));
850      }
851      ReconnectToRoot();
852      return DeletedP;
853  }
854  void TOntology::SuggestConcepts(const TIntV&amp; DIdV, const TOntoSuggestAlgType&amp; AlgType, 
855          const int&amp; NewConceptN, TOntoConceptV&amp; NewConceptV) {
856      NewConceptV.Clr();
857      if ((DIdV.Len() &gt; NewConceptN) || (NewConceptN == -1)) {
858          if (AlgType == osatKMeans) {
859              TOntoAlg::SuggestKMeans(BowDocBs, BowDocWgtBs, DIdV, 
860                  NewConceptN, UniqueId, NewConceptV);
861          } else if (AlgType == osatCat) {
862              TOntoAlg::SuggestCat(BowDocBs, BowDocWgtBs, DIdV, 
863                  UniqueId, NewConceptV);
864          }
865      }
866  }
867  void TOntology::SuggestSubconcepts(const int&amp; CptId, const TOntoSuggestAlgType&amp; AlgType, 
868          const int&amp; NewConceptN, const bool&amp; UnusedDocsP, TOntoConceptV&amp; NewConceptV) {
869      TIntV DIdV; 
870      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
871      else {  GetConcept(CptId)-&gt;GetDIdV(DIdV); }
872      SuggestConcepts(DIdV, AlgType, NewConceptN, NewConceptV);
873  }
874  void TOntology::SuggestSubconcepts(const int&amp; CptId, const PLwOntoCfier&amp; LwOntoCfier,
875          const int&amp; NewConceptN, const bool&amp; UnusedDocsP, TOntoConceptV&amp; NewConceptV) {
876      TIntV DIdV; 
877      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
878      else {  GetConcept(CptId)-&gt;GetDIdV(DIdV); }
879      NewConceptV.Clr();
880      if (DIdV.Len() &gt; NewConceptN) {
881          TOntoAlg::SuggestLwOntoCfier(BowDocBs, BowDocWgtBs,
882              DIdV, LwOntoCfier, NewConceptN, UniqueId, NewConceptV);
883      }
884  }
885  POntoConcept TOntology::GenSubconcept(const TStr&amp; NewCptNm, const TIntV&amp; NewCptDIdV) {
886      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
887          UniqueId-&gt;GetNextId(), NewCptNm, NewCptDIdV);
888  }
889  POntoConcept TOntology::GenSubconcept(const TIntV&amp; NewCptDIdV) {
890      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
891          UniqueId-&gt;GetNextId(), NewCptDIdV);
892  }
893  void TOntology::SuggestConceptNm(const int&amp; CptId, const TVec&lt;PLwOntoCfier&gt;&amp; LwOntoCfierV, 
894          const int&amp; MxSuggestNms, TStrV&amp; SuggestNmV, TIntV&amp; SuggestSuppV, TIntV&amp; SuggestVocNV) {
895      TIntPrIntH TermIdVocNFqH; TIntV DIdV; GetCptDIdV(CptId, DIdV); 
896      for (int VocN = 0; VocN &lt; LwOntoCfierV.Len(); VocN++) {
897          PLwOntoCfier LwOntoCfier = LwOntoCfierV[VocN];
898          PLwTermBs LwTermBs = LwOntoCfier-&gt;GetLwOnto()-&gt;GetTermBs();
899          for (int DIdN = 0; DIdN &lt; DIdV.Len(); DIdN++) {
900              const int DId = DIdV[DIdN];
901              TStr DocStr = BowDocBs-&gt;GetDocStr(DId);
902              TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
903              LwOntoCfier-&gt;ClassifyStr(DocStr, SimTermIdPrV);
904              const int TermIds = TInt::GetMn(3, SimTermIdPrV.Len());
905              for (int TermIdN = 0; TermIdN &lt; TermIds; TermIdN++) {
906                  const int TermId = SimTermIdPrV[TermIdN].Val2;
907                  TIntPr TermIdVocN(TermId, VocN);
908                  TStr TermNm = LwTermBs-&gt;GetTerm(TermId)-&gt;GetTermNm();
909                  if (TermIdVocNFqH.IsKey(TermIdVocN)) { TermIdVocNFqH(TermIdVocN)++; } 
910                  else { TermIdVocNFqH.AddDat(TermIdVocN, 1); }
911              }             
912          }
913      }
914      TIntIntPrPrV TermFqIdVocNV; TermIdVocNFqH.GetDatKeyPrV(TermFqIdVocNV); 
915      TermFqIdVocNV.Sort(false);
916      SuggestNmV.Clr(); SuggestSuppV.Clr(); SuggestVocNV.Clr();
917      const int SuggestNms = TInt::GetMn(MxSuggestNms, TermFqIdVocNV.Len());
918      for (int SuggestNmN = 0; SuggestNmN &lt; SuggestNms; SuggestNmN++) {
919          const int TermId = TermFqIdVocNV[SuggestNmN].Val2.Val1;
920          const int Supp = TermFqIdVocNV[SuggestNmN].Val1;
921          const int VocN = TermFqIdVocNV[SuggestNmN].Val2.Val2;
922          PLwTermBs LwTermBs = LwOntoCfierV[VocN]-&gt;GetLwOnto()-&gt;GetTermBs();
923          TStr TermNm = LwTermBs-&gt;GetTerm(TermId)-&gt;GetTermNm();
924          SuggestNmV.Add(TermNm); 
925          SuggestSuppV.Add(Supp); 
926          SuggestVocNV.Add(VocN);
927      }
928  }
929  void TOntology::AddConcept(const POntoConcept&amp; NewCpt, const int&amp; FatherCptId) {
930      const int NewCptId = NewCpt-&gt;GetId();
931      IAssertR(!IsCptId(NewCptId), &quot;There already is a conceptwith the same ID!&quot;);
932      ConceptV.Add(NewCpt); RefreshCptIdPosH();
933      TStr NewCptIdStr = TStr::Fmt(&quot;Cpt%d&quot;, NewCptId);
934      PVrtx NewCptVrtx = TGVrtx::New(NewCptId, NewCptIdStr);
935      TStr Name = NewCpt-&gt;GetName(); Name.ChangeChAll(&#x27; &#x27;, &#x27;\\&#x27;);
936      NewCptVrtx-&gt;PutDNm(Name); 
937      NewCptVrtx-&gt;PutShape(&quot;Rect&quot;);
938      OntoGraph-&gt;AddVrtx(NewCptVrtx);
939      if (FatherCptId &gt;= 0) {
940          IAssertR(IsCptId(FatherCptId), &quot;There is no such concept!&quot;);
941          AddRlt(NewCptId, FatherCptId, TOntoRltType::SubCptOfRltStr);
942      } else {
943          IAssert(ConceptV.Len() == 1);
944      }
945  }
946  void TOntology::BreakConcept(const int&amp; OldCptId, const TOntoConceptV&amp; NewCptV) {
947      if (IsRootCpt(OldCptId)) return; 
948      IAssert(!NewCptV.Empty());
949      IAssertR(IsCptId(OldCptId), &quot;There is no such concept!&quot;);
950      for (int CptC = 0; CptC &lt; NewCptV.Len(); CptC++) {
951          POntoConcept NewCpt = NewCptV[CptC];
952          const int NewCptId = NewCpt-&gt;GetId();
953          IAssertR(!IsCptId(NewCptId), 
954              &quot;There already is a concept with the same ID!&quot;);
955          ConceptV.Add(NewCpt); RefreshCptIdPosH();
956          TStr Name = NewCpt-&gt;GetName(); Name.ChangeStrAll(&quot; &quot;, &quot;\\&quot;);
957          PVrtx v = TGVrtx::New(NewCptId, Name.CStr());
958          OntoGraph-&gt;AddVrtx(v);
959      }
960      TIntStrPrV InRltV, OutRltV, UndirRltV;
961      GetCptRltV(OldCptId, InRltV, OutRltV, UndirRltV);
962      for (int InRltN = 0; InRltN &lt; InRltV.Len(); InRltN++) { 
963          const int VrtxId1 = InRltV[InRltN].Val1;
964          TStr RltNm = InRltV[InRltN].Val2;
965          for (int CptC = 0; CptC &lt; NewCptV.Len(); CptC++) {
966              const int NewCptId = NewCptV[CptC]-&gt;GetId();
967              AddRlt(VrtxId1, NewCptId, RltNm);
968          }
969      }
970      for (int OutRltN = 0; OutRltN &lt; OutRltV.Len(); OutRltN++) {
971          const int VrtxId2 = OutRltV[OutRltN].Val1;
972          TStr RltNm = OutRltV[OutRltN].Val2;
973          for (int CptC = 0; CptC &lt; NewCptV.Len(); CptC++) {
974              const int NewCptId = NewCptV[CptC]-&gt;GetId();
975              AddRlt(NewCptId, VrtxId2, RltNm);
976          }
977      }
978      for (int UndirRltN = 0; UndirRltN &lt; UndirRltV.Len(); UndirRltN++) {
979          const int VrtxId2 = UndirRltV[UndirRltN].Val1;
980          TStr RltNm = UndirRltV[UndirRltN].Val2;
981          for (int CptC = 0; CptC &lt; NewCptV.Len(); CptC++) {
982              const int NewCptId = NewCptV[CptC]-&gt;GetId();
983              AddRlt(NewCptId, VrtxId2, RltNm);
984          }
985      }
986      ConceptV.Del(CptIdPosH.GetDat(OldCptId)); RefreshCptIdPosH();
987      OntoGraph-&gt;DelVrtx(OldCptId); ReconnectToRoot();
988  }
989  void TOntology::PruneSubconcept(const POntoConcept&amp; SubCpt, const int&amp; FatherCptId) {
990      if (FatherCptId == 0) return; 
991      IAssertR(IsCptId(FatherCptId), &quot;There is no such concept!&quot;);
992      TIntV SubCptDIdV; SubCpt-&gt;GetDIdV(SubCptDIdV);
993      GetConcept(FatherCptId)-&gt;DelDIdV(BowDocWgtBs, SubCptDIdV);
994  }
995  void TOntology::DeleteConcept(const int&amp; CptId, const bool&amp; DoRedirect) {
996      if (IsRootCpt(CptId)) return; 
997      IAssertR(IsCptId(CptId), &quot;There is no such concept!&quot;);
998      if (DoRedirect) {
999          TIntStrPrV InRltV, OutRltV, UndirRltV;
1000          GetCptRltV(CptId, InRltV, OutRltV, UndirRltV);
1001          AddRltsFromList(InRltV, OutRltV, UndirRltV);
1002      }
1003      ConceptV.Del(CptIdPosH.GetDat(CptId)); RefreshCptIdPosH();
1004      OntoGraph-&gt;DelVrtx(CptId); ReconnectToRoot();
1005  }
1006  void TOntology::UniteConcepts(const int&amp; CptId1, const int&amp; CptId2) {
1007  }
1008  void TOntology::CopyConcept(const int&amp; CptId, const int NewFatherCptId, const bool&amp; MoveP) {
1009      if (IsRootCpt(CptId)) return; 
1010      IAssertR(IsCptId(CptId), &quot;There is no such concept!&quot;);
1011      IAssertR(IsCptId(NewFatherCptId), &quot;There is no such concept!&quot;);
1012      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
1013      SuperCptIdV.DelIfIn(NewFatherCptId);
1014      if (SuperCptIdV.Empty()) return; 
1015      AddRlt(CptId, NewFatherCptId, TOntoRltType::SubCptOfRltStr);
1016      for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
1017          const int SuperCptId = SuperCptIdV[SuperCptIdN];
1018          DelRlt(CptId, SuperCptId, TOntoRltType::SubCptOfRltStr);
1019      }
1020      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1021      if (MoveP) {
1022          for (int SuperCptIdN = 0; SuperCptIdN &lt; SuperCptIdV.Len(); SuperCptIdN++) {
1023              const int SuperCptId = SuperCptIdV[SuperCptIdN];
1024              DelUpDIdV(SuperCptId, CptDIdV);
1025          }
1026      }
1027      AddUpDIdV(NewFatherCptId, CptDIdV);
1028  }
1029  void TOntology::NewConcept() {
1030      POntoConcept Cpt = TOntoConcept::New(BowDocBs, 
1031          BowDocWgtBs, UniqueId-&gt;GetNextId(), &quot;New Concept&quot;, TIntV());
1032      IAssert(ConceptV[0]-&gt;GetId() == 0);
1033      AddConcept(Cpt, 0);
1034  }
1035  void TOntology::ExtractKeywords(const int&amp; CptId) {
1036      if (IsRootCpt(CptId)) return;
1037      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1038      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1039      PBowSpV SvmSpV;
1040      if (CptDIdV.Len() &gt; 0) {
1041          SvmSpV = TBowSVMMd::GetKeywords(BowDocBs, ContextDIdV, CptDIdV, 50, 1.0, 5.0);
1042      } else {
1043          SvmSpV = TBowSpV::New();
1044      }
1045      GetConcept(CptId)-&gt;SetSvmSpV(SvmSpV);
1046  }
1047  void TOntology::CalcCptCompactness(const int&amp; CptId) {
1048      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1049      if (CptDIdV.Len() &gt; 0) {
1050          PBowSpV CentroidSpV = GetConcept(CptId)-&gt;GetCentroidSpV();
1051          double Qual = 0.0; 
1052          for (int DIdN = 0; DIdN &lt; CptDIdV.Len(); DIdN++) {
1053              const int DId = CptDIdV[DIdN];
1054              PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DId);
1055              Qual += BowSim-&gt;GetSim(CentroidSpV, DocSpV);
1056          }
1057          GetConcept(CptId)-&gt;SetCompactness(Qual / CptDIdV.Len());
1058      } else {
1059          GetConcept(CptId)-&gt;SetCompactness(1.0);
1060      }
1061  }
<span onclick='openModal()' class='match'>1062  void TOntology::CalcCptClarity(const int&amp; CptId) {
1063      if (IsRootCpt(CptId)) return;
1064      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1065      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1066      if (CptDIdV.Len() &gt; 20) {
</span>1067          TCfyRes CfyRes = TBowSVMMd::CrossValidClsLinear(
1068              5, 1, BowDocBs, BowDocWgtBs, ContextDIdV, CptDIdV, 1, 5.0);
1069          const double Clarity = CfyRes.BreakEvenPoint();
1070          GetConcept(CptId)-&gt;SetClarity(Clarity);
1071      }
1072  }
1073  void TOntology::PrepareGraph(const int&amp; SelectedCptId) {
1074      IAssert(GetConcepts() &gt; 0);
1075      if (IsCptId(SelectedCptId)) {
1076          TStr VrtxNm = OntoGraph-&gt;GetVrtx(SelectedCptId)-&gt;GetDNm();
1077          OntoGraph-&gt;GetPp()-&gt;PutValStr(&quot;BoldVNm&quot;, VrtxNm);
1078      }
1079  }
1080  void TOntology::PlaceGraph() {
1081      IAssert(GetConcepts() &gt; 0);
1082      PVrtx RootVrtx = OntoGraph-&gt;GetVrtx(0);
1083      OntoGraph-&gt;PlaceGraphAsStar(RootVrtx, TOntoRltType::SubCptOfRltStr);
1084      OntoGraph-&gt;RescaleXY(0.1, RootVrtx);
1085  }
1086  void TOntology::ExportPTO(const TStr&amp; FNm, const bool&amp; DigLibP) { 
1087      PSOut SOut = TFOut::New(FNm);
1088      TStr BowFNm = FNm + &quot;.bow&quot;; BowDocBs-&gt;SaveBin(BowFNm);
1089      POntoExport OntoExport = TOntoExportPTO::New(SOut, DigLibP, BowFNm);
1090      this-&gt;Export(OntoExport);
1091  }
1092  void TOntology::ExportProlog(const TStr&amp; FNm) {
1093      PSOut SOut = TFOut::New(FNm);
1094      POntoExport OntoExport = TOntoExportProlog::New(SOut);
1095      this-&gt;Export(OntoExport);
1096  }
1097  void TOntology::ExportOwl(const TStr&amp; FNm, const bool&amp; StoreDocsP, const bool&amp; StoreAbstractsP) {
1098      PSOut SOut = TFOut::New(FNm);
1099      POntoExport OntoExport = TOntoExportOWL::New(SOut, StoreDocsP, StoreAbstractsP);
1100      this-&gt;Export(OntoExport);
1101  }
1102  POntology TOntology::ImportPTO(const TStr&amp; RdfFNm, const TStr&amp; BowFNm) {
1103      PBowDocBs BowDocBs = TBowDocBs::LoadBin(BowFNm);
1104      const int MnWordFq = BowDocBs-&gt;GetDocs() &gt; 111 ? 5 : 3;
1105      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1106          BowDocBs, bwwtLogDFNrmTFIDF, 0.2, MnWordFq);
1107      POntology Onto = TOntology::New(BowDocBs, BowDocWgtBs, bstCos);
1108      PXmlDoc Rdf = TXmlDoc::LoadTxt(RdfFNm);
1109      IAssertR(Rdf-&gt;IsOk(), &quot;Wrong RDF format&quot;);
1110      TStrIntH TopicUriIdH;
1111      PXmlTok RootTok; IAssert(Rdf-&gt;IsTagTok(&quot;rdf:RDF&quot;, RootTok));
1112      TXmlTokV TopicV; RootTok-&gt;GetTagTokV(&quot;ptop:Topic&quot;, TopicV);
1113      TXmlTokV DocV; RootTok-&gt;GetTagTokV(&quot;ptop:Document&quot;, DocV);
1114      TXmlTokV DocPropV; RootTok-&gt;GetTagTokV(&quot;jsikm:OntoGenInstanceProperties&quot;, DocPropV);
1115      TIntIntVH TopicIdDocIdVH; TopicIdDocIdVH.AddDat(0, TIntV());
1116      for (int TopicN = 0; TopicN &lt; TopicV.Len(); TopicN++) {
1117          PXmlTok TopicTok = TopicV[TopicN];
1118          TStr TopicURI = TopicTok-&gt;GetArgVal(&quot;rdf:about&quot;);
1119          TStr TopicName = TopicTok-&gt;GetTagTok(&quot;psys:description&quot;)-&gt;GetTagTokStr(&quot;&quot;);
1120          int UnderScorePos = TopicURI.SearchCh(&#x27;_&#x27;);
1121          TStr TopicURIPrefix = TopicURI.Left(UnderScorePos);
1122          if (TopicURIPrefix != &quot;#Cpt0&quot; &amp;&amp; TopicURI != &quot;#TOP_0&quot;) {
1123              const int TopicId = Onto-&gt;UniqueId-&gt;GetNextId(); 
1124              POntoConcept TopicCpt = TOntoConcept::New(Onto-&gt;BowDocBs, 
1125                  Onto-&gt;BowDocWgtBs, TopicId, TopicName, TIntV());
1126              Onto-&gt;AddConcept(TopicCpt, 0);
1127              TopicUriIdH.AddDat(TopicURI, TopicId);
1128              TopicIdDocIdVH.AddDat(TopicId, TIntV());
1129          } else {
1130              Onto-&gt;SetCptName(0, TopicName);
1131              TopicUriIdH.AddDat(TopicURI, 0);
1132          }        
1133      }
1134      for (int TopicN = 0; TopicN &lt; TopicV.Len(); TopicN++) {
1135          PXmlTok TopicTok = TopicV[TopicN];
1136          TStr TopicURI = TopicTok-&gt;GetArgVal(&quot;rdf:about&quot;);
1137          const int TopicId = TopicUriIdH.GetDat(TopicURI);
1138          bool ConnectedToRoot = false;
1139          if (TopicId &gt; 0) {
1140              TXmlTokV SuperTopicV; TopicTok-&gt;GetTagTokV(&quot;ptop:subTopicOf&quot;, SuperTopicV);
1141              for (int SupTopN = 0; SupTopN &lt; SuperTopicV.Len(); SupTopN++) {
1142                  TStr SuperTopicURI = SuperTopicV[SupTopN]-&gt;GetArgVal(&quot;rdf:resource&quot;);
1143                  const int SuperTopicId = TopicUriIdH.GetDat(SuperTopicURI);
1144                  if (SuperTopicId == 0) {
1145                      ConnectedToRoot = true;
1146                  } else {            
1147                      Onto-&gt;AddRlt(TopicId, SuperTopicId, TOntoRltType::SubCptOfRltStr);
1148                  }
1149              }
1150              if (!ConnectedToRoot) {
1151                  Onto-&gt;DelRlt(TopicId, 0, TOntoRltType::SubCptOfRltStr);
1152              }
1153          }
1154      }
1155      TStrIntH DocPropIdH;
1156      for (int DocN = 0; DocN &lt; DocPropV.Len(); DocN++) {
1157          PXmlTok DocPropTok = DocPropV[DocN];
1158          TStr DocPropURI = DocPropTok-&gt;GetArgVal(&quot;rdf:about&quot;);
1159          TStr Link = DocPropTok-&gt;GetTagTok(&quot;jsikm:locationOfInstance&quot;)-&gt;GetTagTokStr(&quot;&quot;);
1160          TStrV LinkPartV; Link.SplitOnAllCh(&#x27;#&#x27;, LinkPartV);
1161          IAssert(LinkPartV.Len() == 2);
1162          const int DocId = LinkPartV[1].GetInt();
1163          IAssert(BowDocBs-&gt;IsDId(DocId));
1164          DocPropIdH.AddDat(DocPropURI, DocId);
1165      }
1166      for (int DocN = 0; DocN &lt; DocV.Len(); DocN++) {
1167          PXmlTok DocTok = DocV[DocN];
1168          TStr DocPropURI = DocTok-&gt;GetTagTok(&quot;jsikm:hasOntoGenInstanceProperties&quot;)-&gt;GetArgVal(&quot;rdf:resource&quot;);
1169          const int DocId = DocPropIdH.GetDat(DocPropURI);
1170          TopicIdDocIdVH.GetDat(0).Add(DocId);
1171          TXmlTokV SubjectTopicV; DocTok-&gt;GetTagTokV(&quot;ptop:hasSubject&quot;, SubjectTopicV);
1172          for (int SubjectN = 0; SubjectN &lt; SubjectTopicV.Len(); SubjectN++) {
1173              PXmlTok SubjectTok = SubjectTopicV[SubjectN];
1174              TStr SubjectUri = SubjectTok-&gt;GetArgVal(&quot;rdf:resource&quot;);
1175              const int SubjectId = TopicUriIdH.GetDat(SubjectUri);
1176              if (SubjectId &gt; 0) {
1177                  IAssert(TopicIdDocIdVH.IsKey(SubjectId));
1178                  TopicIdDocIdVH.GetDat(SubjectId).Add(DocId);
1179              }
1180          }
1181      }
1182      int KeyId = TopicIdDocIdVH.FFirstKeyId();
1183      while (TopicIdDocIdVH.FNextKeyId(KeyId)) {
1184          const int TopicId = TopicIdDocIdVH.GetKey(KeyId);
1185          Onto-&gt;SetCptDIdV(TopicId, TopicIdDocIdVH.GetDat(TopicId), false);
1186      }
1187      return Onto;
1188  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1035  void TOntology::ExtractKeywords(const int&amp; CptId) {
1036      if (IsRootCpt(CptId)) return;
1037      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1038      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1039      PBowSpV SvmSpV;
</pre></code></div>
                <div class="column column_space"><pre><code>1062  void TOntology::CalcCptClarity(const int&amp; CptId) {
1063      if (IsRootCpt(CptId)) return;
1064      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1065      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1066      if (CptDIdV.Len() &gt; 20) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    