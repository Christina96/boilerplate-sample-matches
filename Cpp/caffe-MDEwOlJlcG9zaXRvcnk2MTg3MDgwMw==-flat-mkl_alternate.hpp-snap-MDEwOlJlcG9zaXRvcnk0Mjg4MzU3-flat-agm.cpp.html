
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.939592908732764%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_alternate.hpp</h3>
            <pre><code>1  #ifndef CAFFE_UTIL_MKL_ALTERNATE_H_
2  #define CAFFE_UTIL_MKL_ALTERNATE_H_
3  #ifdef USE_MKL
4  #include <mkl_cblas.h>
5  #else  
6  extern "C" {
7  #include <cblas.h>
8  }
9  #include <math.h>
10  #define DEFINE_VSL_UNARY_FUNC(name, operation) \
11    template<typename Dtype> \
12    void v##name(const int n, const Dtype* a, Dtype* y) { \
13      CHECK_GT(n, 0); CHECK(a); CHECK(y); \
14      for (int i = 0; i < n; ++i) { operation; } \
15    } \
16    inline void vs##name( \
17      const int n, const float* a, float* y) { \
18      v##name<float>(n, a, y); \
19    } \
20    inline void vd##name( \
21        const int n, const double* a, double* y) { \
22      v##name<double>(n, a, y); \
23    }
24  DEFINE_VSL_UNARY_FUNC(Sqr, y[i] = a[i] * a[i]);
25  DEFINE_VSL_UNARY_FUNC(Exp, y[i] = exp(a[i]));
26  DEFINE_VSL_UNARY_FUNC(Ln, y[i] = log(a[i]));
27  DEFINE_VSL_UNARY_FUNC(Abs, y[i] = fabs(a[i]));
28  #define DEFINE_VSL_BINARY_FUNC(name, operation) \
29    template<typename Dtype> \
30    void v##name(const int n, const Dtype* a, const Dtype* b, Dtype* y) { \
31      CHECK_GT(n, 0); CHECK(a); CHECK(b); CHECK(y); \
32      for (int i = 0; i < n; ++i) { operation; } \
33    } \
34    inline void vs##name( \
35      const int n, const float* a, const float* b, float* y) { \
36      v##name<float>(n, a, b, y); \
37    } \
38    inline void vd##name( \
39        const int n, const double* a, const double* b, double* y) { \
40      v##name<double>(n, a, b, y); \
41    }
42  DEFINE_VSL_BINARY_FUNC(Add, y[i] = a[i] + b[i]);
43  DEFINE_VSL_BINARY_FUNC(Sub, y[i] = a[i] - b[i]);
44  DEFINE_VSL_BINARY_FUNC(Mul, y[i] = a[i] * b[i]);
45  DEFINE_VSL_BINARY_FUNC(Div, y[i] = a[i] / b[i]);
46  template <typename Dtype>
47  inline void vPowx(const int n, const Dtype* a, Dtype b, Dtype* y) {
48  #ifdef _OPENMP
49      #pragma omp parallel for
50  #endif
51    for (int i = 0; i < n; ++i) {
52      y[i] = std::pow(a[i], b);
53    }
54  }
55  #define vsPowx vPowx<float>
56  #define vdPowx vPowx<double>
<span onclick='openModal()' class='match'>57  inline void cblas_saxpby(const int N, const float alpha, const float* X,
58                           const int incX, const float beta, float* Y,
</span>59                           const int incY) {
60    cblas_sscal(N, beta, Y, incY);
61    cblas_saxpy(N, alpha, X, incX, Y, incY);
62  }
63  inline void cblas_daxpby(const int N, const double alpha, const double* X,
64                           const int incX, const double beta, double* Y,
65                           const int incY) {
66    cblas_dscal(N, beta, Y, incY);
67    cblas_daxpy(N, alpha, X, incX, Y, incY);
68  }
69  #endif  
70  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agm.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "Snap.h"
3  #include "agm.h"
4  #include "agmfit.h"
5  void TAGM::RndConnectInsideCommunity(PUNGraph& Graph, const TIntV& CmtyV, const double& Prob, TRnd& Rnd){
6    int CNodes = CmtyV.Len(), CEdges;
7    if (CNodes < 20) {
8      CEdges = (int) Rnd.GetBinomialDev(Prob, CNodes * (CNodes-1) / 2);
9    } else {
10      CEdges = (int) (Prob * CNodes * (CNodes - 1) / 2);
11    }
12    THashSet<TIntPr> NewEdgeSet(CEdges);
13    for (int edge = 0; edge < CEdges; ) {
14      int SrcNId = CmtyV[Rnd.GetUniDevInt(CNodes)];
15      int DstNId = CmtyV[Rnd.GetUniDevInt(CNodes)];
16      if (SrcNId > DstNId) { Swap(SrcNId,DstNId); }
17      if (SrcNId != DstNId && ! NewEdgeSet.IsKey(TIntPr(SrcNId, DstNId))) { 
18        NewEdgeSet.AddKey(TIntPr(SrcNId, DstNId));
19        Graph->AddEdge(SrcNId, DstNId);
20        edge++; 
21      } 
22    }
23  }
24  PUNGraph TAGM::GenAGM(TVec<TIntV>& CmtyVV, const double& DensityCoef, const int TargetEdges, TRnd& Rnd){
25    PUNGraph TryG = TAGM::GenAGM(CmtyVV, DensityCoef, 1.0, Rnd);
26    const double ScaleCoef = (double) TargetEdges / (double) TryG->GetEdges();
27    return TAGM::GenAGM(CmtyVV, DensityCoef, ScaleCoef, Rnd);
28  }
29  PUNGraph TAGM::GenAGM(TVec<TIntV>& CmtyVV, const double& DensityCoef, const double& ScaleCoef, TRnd& Rnd){
30    TFltV CProbV;
31    double Prob;
32    for (int i = 0; i < CmtyVV.Len(); i++) {
33      Prob = ScaleCoef*pow( double( CmtyVV[i].Len()), - DensityCoef);
34      if (Prob > 1.0) { Prob = 1; }
35      CProbV.Add(Prob);
36    }
37    return TAGM::GenAGM(CmtyVV, CProbV, Rnd);
38  }
39  PUNGraph TAGM::GenAGM(TVec<TIntV>& CmtyVV, const TFltV& CProbV, TRnd& Rnd, const double PNoCom){
40    PUNGraph G = TUNGraph::New(100 * CmtyVV.Len(), -1);
41    printf("AGM begins\n");
42    for (int i = 0; i < CmtyVV.Len(); i++) {
43      TIntV& CmtyV = CmtyVV[i];
44      for (int u = 0; u < CmtyV.Len(); u++) {
45        if ( G->IsNode(CmtyV[u])) { continue; }
46        G->AddNode(CmtyV[u]);
47      }
48      double Prob = CProbV[i];
49      RndConnectInsideCommunity(G, CmtyV, Prob, Rnd);
50    }
51    if (PNoCom > 0.0) { 
52      TIntSet NIDS;
53      for (int c = 0; c < CmtyVV.Len(); c++) {
54        for (int u = 0; u < CmtyVV[c].Len(); u++) {
55          NIDS.AddKey(CmtyVV[c][u]);
56        }
57      }
58      TIntV NIDV;
59      NIDS.GetKeyV(NIDV);
60      RndConnectInsideCommunity(G,NIDV,PNoCom,Rnd);
61    }
62    printf("AGM completed (%d nodes %d edges)\n",G->GetNodes(),G->GetEdges());
63    G->Defrag();
64    return G;
65  }
66  void TAGMUtil::GenPLSeq(TIntV& SzSeq, const int& SeqLen, const double& Alpha, TRnd& Rnd, const int& Min, const int& Max) {
67    SzSeq.Gen(SeqLen, 0);
68    while (SzSeq.Len() < SeqLen) {
69      int Sz = (int) TMath::Round(Rnd.GetPowerDev(Alpha));
70      if (Sz >= Min && Sz <= Max) {
71        SzSeq.Add(Sz);
72      }
73    }
74  }
<span onclick='openModal()' class='match'>75  void TAGMUtil::GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd){
75  void TAGMUtil::GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd){
</span>76    TIntV NIDV(Nodes, 0);
77    for (int i = 0; i < Nodes; i++) {
78      NIDV.Add(i);
79    }
80    GenCmtyVVFromPL(CmtyVV, NIDV, Nodes, Coms, ComSzAlpha, MemAlpha, MinSz, MaxSz, MinK, MaxK, Rnd);
81  }
82  void TAGMUtil::GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const PUNGraph& Graph, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd){
83    if (Coms == 0 || Nodes == 0) {
84      CmtyVV.Clr();
85      return;
86    }
87    TIntV NIDV;
88    Graph->GetNIdV(NIDV);
89    GenCmtyVVFromPL(CmtyVV, NIDV, Nodes, Coms, ComSzAlpha, MemAlpha, MinSz, MaxSz, MinK, MaxK, Rnd);
90  }
91  void TAGMUtil::GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const TIntV& NIDV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd){
92    if (Coms == 0 || Nodes == 0) {
93      CmtyVV.Clr();
94      return;
95    }
96    TIntV ComSzSeq, MemSeq;
97    TAGMUtil::GenPLSeq(ComSzSeq,Coms,ComSzAlpha,Rnd,MinSz,MaxSz);
98    TAGMUtil::GenPLSeq(MemSeq,Nodes,MemAlpha,Rnd,MinK,MaxK);
99    TIntPrV CIDSzPrV, NIDMemPrV;
100    for (int i = 0; i < ComSzSeq.Len(); i++) {
101      CIDSzPrV.Add(TIntPr(i, ComSzSeq[i]));
102    }
103    for (int i = 0; i < MemSeq.Len(); i++) {
104      NIDMemPrV.Add(TIntPr(NIDV[i], MemSeq[i]));
105    }
106    TAGMUtil::ConnectCmtyVV(CmtyVV, CIDSzPrV, NIDMemPrV, Rnd);
107  }
108  void TAGMUtil::ConnectCmtyVV(TVec<TIntV>& CmtyVV, const TIntPrV& CIDSzPrV, const TIntPrV& NIDMemPrV, TRnd& Rnd) {
109    const int Nodes = NIDMemPrV.Len(), Coms = CIDSzPrV.Len();
110    TIntV NDegV,CDegV;
111    TIntPrSet CNIDSet;
112    TIntSet HitNodes(Nodes);
113    THash<TInt,TIntV> CmtyVH;
114    for (int i = 0;i < CIDSzPrV.Len(); i++) {
115      for (int j = 0; j < CIDSzPrV[i].Val2; j++) {
116        CDegV.Add(CIDSzPrV[i].Val1);
117      }
118    }
119    for (int i = 0; i < NIDMemPrV.Len(); i++) {
120      for (int j = 0; j < NIDMemPrV[i].Val2; j++) {
121        NDegV.Add(NIDMemPrV[i].Val1);
122      }
123    }
124    while (CDegV.Len() < (int) (1.2 * Nodes)) {
125      CDegV.Add(CIDSzPrV[Rnd.GetUniDevInt(Coms)].Val1);
126    }
127    while (NDegV.Len() < CDegV.Len()) {
128      NDegV.Add(NIDMemPrV[Rnd.GetUniDevInt(Nodes)].Val1);
129    }
130    printf("Total Mem: %d, Total Sz: %d\n",NDegV.Len(), CDegV.Len());
131    int c=0;
132    while (c++ < 15 && CDegV.Len() > 1) {
133      for (int i = 0; i < CDegV.Len(); i++) {
134        int u = Rnd.GetUniDevInt(CDegV.Len());
135        int v = Rnd.GetUniDevInt(NDegV.Len());
136        if (CNIDSet.IsKey(TIntPr(CDegV[u], NDegV[v]))) { continue; }
137        CNIDSet.AddKey(TIntPr(CDegV[u], NDegV[v]));
138        HitNodes.AddKey(NDegV[v]);
139        if (u == CDegV.Len() - 1) { CDegV.DelLast(); }
140        else { 
141          CDegV[u] = CDegV.Last(); 
142          CDegV.DelLast();
143        }
144        if (v == NDegV.Len() - 1) { NDegV.DelLast(); }
145        else { 
146          NDegV[v] = NDegV.Last();
147          NDegV.DelLast();
148        }
149      }
150    }
151    for (int i = 0; i < Nodes; i++) {
152      int NID = NIDMemPrV[i].Val1;
153      if (! HitNodes.IsKey(NID)) {
154        CNIDSet.AddKey(TIntPr(CIDSzPrV[Rnd.GetUniDevInt(Coms)].Val1, NID));
155        HitNodes.AddKey(NID);
156      }
157    }
158    IAssert(HitNodes.Len() == Nodes);
159    for (int i = 0; i < CNIDSet.Len(); i++) {
160      TIntPr CNIDPr = CNIDSet[i];
161      CmtyVH.AddDat(CNIDPr.Val1);
162      CmtyVH.GetDat(CNIDPr.Val1).Add(CNIDPr.Val2);
163    }
164    CmtyVH.GetDatV(CmtyVV);
165  }
166  void TAGMUtil::RewireCmtyVV(const TVec<TIntV>& CmtyVVIn, TVec<TIntV>& CmtyVVOut, TRnd& Rnd){
167    THash<TInt,TIntV> CmtyVH;
168    for (int i = 0; i < CmtyVVIn.Len(); i++) {
169      CmtyVH.AddDat(i, CmtyVVIn[i]);
170    }
171    TAGMUtil::RewireCmtyNID(CmtyVH, Rnd);
172    CmtyVH.GetDatV(CmtyVVOut);
173  }
174  void TAGMUtil::RewireCmtyNID(THash<TInt,TIntV >& CmtyVH, TRnd& Rnd) {
175    THash<TInt,TIntV > NewCmtyVH(CmtyVH.Len());
176    TIntV NDegV;
177    TIntV CDegV;
178    for (int i = 0; i < CmtyVH.Len(); i++) {
179      int CID = CmtyVH.GetKey(i);
180      for (int j = 0; j < CmtyVH[i].Len(); j++) {
181        int NID = CmtyVH[i][j];
182        NDegV.Add(NID);
183        CDegV.Add(CID);
184      }
185    }
186    TIntPrSet CNIDSet(CDegV.Len());
187    int c=0;
188    while (c++ < 15 && CDegV.Len() > 1){
189      for (int i = 0; i < CDegV.Len(); i++) {
190        int u = Rnd.GetUniDevInt(CDegV.Len());
191        int v = Rnd.GetUniDevInt(NDegV.Len());
192        if (CNIDSet.IsKey(TIntPr(CDegV[u], NDegV[v]))) { continue; }
193        CNIDSet.AddKey(TIntPr(CDegV[u], NDegV[v]));
194        if (u == CDegV.Len() - 1) { 
195          CDegV.DelLast(); 
196        }  else {
197          CDegV[u] = CDegV.Last();
198          CDegV.DelLast();
199        }
200        if ( v == NDegV.Len() - 1) {
201          NDegV.DelLast();
202        }  else{
203          NDegV[v] = NDegV.Last();
204          NDegV.DelLast();
205        }
206      }
207    }
208    for (int i = 0; i < CNIDSet.Len(); i++) {
209      TIntPr CNIDPr = CNIDSet[i];
210      IAssert(CmtyVH.IsKey(CNIDPr.Val1));
211      NewCmtyVH.AddDat(CNIDPr.Val1);
212      NewCmtyVH.GetDat(CNIDPr.Val1).Add(CNIDPr.Val2);
213    }
214    CmtyVH = NewCmtyVH;
215  }
216  void TAGMUtil::LoadCmtyVV(const TStr& InFNm, TVec<TIntV>& CmtyVV) {
217    CmtyVV.Gen(Kilo(100), 0);
218    TSsParser Ss(InFNm, ssfWhiteSep);
219    while (Ss.Next()) {
220      if(Ss.GetFlds() > 0) {
221        TIntV CmtyV;
222        for (int i = 0; i < Ss.GetFlds(); i++) {
223          if (Ss.IsInt(i)) {
224            CmtyV.Add(Ss.GetInt(i));
225          }
226        }
227        CmtyVV.Add(CmtyV);
228      }
229    }
230    CmtyVV.Pack();
231    printf("community loading completed (%d communities)\n",CmtyVV.Len());
232  }
233  void TAGMUtil::LoadCmtyVV(const TStr& InFNm, TVec<TIntV>& CmtyVV, TStrHash<TInt>& StrToNIdH, const int BeginCol, const int MinSz, const TSsFmt Sep) {
234    CmtyVV.Gen(Kilo(100), 0);
235    TSsParser Ss(InFNm, Sep);
236    while (Ss.Next()) {
237      if(Ss.GetFlds() > BeginCol) {
238        TIntV CmtyV;
239        for (int i = BeginCol; i < Ss.GetFlds(); i++) {
240          if (StrToNIdH.IsKey(Ss.GetFld(i))) {
241            CmtyV.Add(StrToNIdH.GetKeyId(Ss.GetFld(i)));
242          }
243        }
244        if (CmtyV.Len() < MinSz) { continue; }
245        CmtyVV.Add(CmtyV);
246      }
247    }
248    CmtyVV.Pack();
249    printf("community loading completed (%d communities)\n",CmtyVV.Len());
250  }
251  void TAGMUtil::DumpCmtyVV(const TStr& OutFNm, const TVec<TIntV>& CmtyVV) {
252    FILE* F = fopen(OutFNm.CStr(),"wt");
253    for (int i = 0; i < CmtyVV.Len(); i++) {
254      for (int j = 0; j < CmtyVV[i].Len(); j++) {
255        fprintf(F,"%d\t", (int) CmtyVV[i][j]);
256      }
257      fprintf(F,"\n");
258    }
259    fclose(F);
260  }
261  void TAGMUtil::DumpCmtyVV(const TStr OutFNm, TVec<TIntV>& CmtyVV, TIntStrH& NIDNmH) {
262    FILE* F = fopen(OutFNm.CStr(), "wt");
263    for (int c = 0; c < CmtyVV.Len(); c++) {
264      for (int u = 0; u < CmtyVV[c].Len(); u++) {
265        if (NIDNmH.IsKey(CmtyVV[c][u])){
266          fprintf(F, "%s\t", NIDNmH.GetDat(CmtyVV[c][u]).CStr());
267        }
268        else {
269          fprintf(F, "%d\t", (int) CmtyVV[c][u]);
270        }
271      }
272      fprintf(F, "\n");
273    }
274    fclose(F);
275  }
276  int TAGMUtil::TotalMemberships(const TVec<TIntV>& CmtyVV){
277    int M = 0;
278    for (int i = 0; i < CmtyVV.Len(); i++) {
279      M += CmtyVV[i].Len();
280    }
281    return M;
282  }
283  void TAGMUtil::GetNodeMembership(TIntH& NIDComVH, const THash<TInt,TIntV >& CmtyVH) {
284    NIDComVH.Clr();
285    for (THash<TInt,TIntV>::TIter HI = CmtyVH.BegI(); HI < CmtyVH.EndI(); HI++){
286      for (int j = 0;j < HI.GetDat().Len(); j++) {
287        int NID = HI.GetDat()[j];
288        NIDComVH.AddDat(NID)++;
289      }
290    }
291  }
292  void TAGMUtil::GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntV>& CmtyVV) {
293    NIDComVH.Clr();
294    for (int i = 0; i < CmtyVV.Len(); i++){
295      int CID = i;
296      for (int j = 0; j < CmtyVV[i].Len(); j++) {
297        int NID = CmtyVV[i][j];
298        NIDComVH.AddDat(NID).AddKey(CID);
299      }
300    }
301  }
302  void TAGMUtil::GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntV>& CmtyVV, const TIntV& NIDV) {
303    NIDComVH.Clr();
304    for (int u = 0; u < NIDV.Len(); u++) {
305      NIDComVH.AddDat(NIDV[u]);
306    }
307    for (int i = 0; i < CmtyVV.Len(); i++){
308      int CID = i;
309      for (int j = 0; j < CmtyVV[i].Len(); j++) {
310        int NID = CmtyVV[i][j];
311        NIDComVH.AddDat(NID).AddKey(CID);
312      }
313    }
314  }
315  void TAGMUtil::GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntSet>& CmtyVV) {
316    for (int i = 0; i < CmtyVV.Len(); i++){
317      int CID = i;
318      for (TIntSet::TIter SI = CmtyVV[i].BegI(); SI < CmtyVV[i].EndI(); SI++) {
319        int NID = SI.GetKey();
320        NIDComVH.AddDat(NID).AddKey(CID);
321      }
322    }
323  }
324  void TAGMUtil::GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const THash<TInt,TIntV>& CmtyVH) {
325    for (THash<TInt,TIntV>::TIter HI = CmtyVH.BegI(); HI < CmtyVH.EndI(); HI++){
326      int CID = HI.GetKey();
327      for (int j = 0; j < HI.GetDat().Len(); j++) {
328        int NID = HI.GetDat()[j];
329        NIDComVH.AddDat(NID).AddKey(CID);
330      }
331    }
332  }
333  void TAGMUtil::GetNodeMembership(THash<TInt,TIntV >& NIDComVH, const THash<TInt,TIntV>& CmtyVH) {
334    for (int i = 0; i < CmtyVH.Len(); i++){
335      int CID = CmtyVH.GetKey(i);
336      for (int j = 0; j < CmtyVH[i].Len(); j++) {
337        int NID = CmtyVH[i][j];
338        NIDComVH.AddDat(NID).Add(CID);
339      }
340    }
341  }
342  void TAGMUtil::GetNodeMembership(THash<TInt,TIntV >& NIDComVH, const TVec<TIntV>& CmtyVV) {
343    THash<TInt,TIntV> CmtyVH;
344    for (int i = 0; i < CmtyVV.Len(); i++) {
345      CmtyVH.AddDat(i, CmtyVV[i]);
346    }
347    GetNodeMembership(NIDComVH, CmtyVH);
348  }
349  int TAGMUtil::Intersection(const TIntV& C1, const TIntV& C2) {
350    TIntSet S1(C1), S2(C2);
351    return TAGMUtil::Intersection(S1, S2);
352  }
353  void TAGMUtil::GetIntersection(const THashSet<TInt>& A, const THashSet<TInt>& B, THashSet<TInt>& C) {
354    C.Gen(A.Len());
355    if (A.Len() < B.Len()) {
356      for (THashSetKeyI<TInt> it = A.BegI(); it < A.EndI(); it++) 
357        if (B.IsKey(it.GetKey())) C.AddKey(it.GetKey());
358    } else {
359      for (THashSetKeyI<TInt> it = B.BegI(); it < B.EndI(); it++) 
360        if (A.IsKey(it.GetKey())) C.AddKey(it.GetKey());
361    }
362  }
363  int TAGMUtil::Intersection(const THashSet<TInt>& A, const THashSet<TInt>& B) {
364    int n = 0;
365    if (A.Len() < B.Len()) {
366      for (THashSetKeyI<TInt> it = A.BegI(); it < A.EndI(); it++) 
367        if (B.IsKey(it.GetKey())) n++;
368    } else {
369      for (THashSetKeyI<TInt> it = B.BegI(); it < B.EndI(); it++) 
370        if (A.IsKey(it.GetKey())) n++;
371    }
372    return n;
373  }
374  void TAGMUtil::SaveGephi(const TStr& OutFNm, const PUNGraph& G, const TVec<TIntV>& CmtyVVAtr, const double MaxSz, const double MinSz, const TIntStrH& NIDNameH, const THash<TInt, TIntTr>& NIDColorH ) {
375    THash<TInt,TIntV> NIDComVHAtr;
376    TAGMUtil::GetNodeMembership(NIDComVHAtr, CmtyVVAtr);
377    FILE* F = fopen(OutFNm.CStr(), "wt");
378    fprintf(F, "<?xml version='1.0' encoding='UTF-8'?>\n");
379    fprintf(F, "<gexf xmlns='http:&bsol;&bsol;www.gexf.net/1.2draft' xmlns:viz='http:&bsol;&bsol;www.gexf.net/1.1draft/viz' xmlns:xsi='http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance' xsi:schemaLocation='http:&bsol;&bsol;www.gexf.net/1.2draft http:&bsol;&bsol;www.gexf.net/1.2draft/gexf.xsd' version='1.2'>\n");
380    fprintf(F, "\t<graph mode='static' defaultedgetype='undirected'>\n");
381    if (CmtyVVAtr.Len() > 0) {
382      fprintf(F, "\t<attributes class='node'>\n");
383      for (int c = 0; c < CmtyVVAtr.Len(); c++) {
384        fprintf(F, "\t\t<attribute id='%d' title='c%d' type='boolean'>", c, c);
385        fprintf(F, "\t\t<default>false</default>\n");
386        fprintf(F, "\t\t</attribute>\n");
387      }
388      fprintf(F, "\t</attributes>\n");
389    }
390    fprintf(F, "\t\t<nodes>\n");
391    for (TUNGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
392      int NID = NI.GetId();
393      TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): "";
394      TIntTr Color = NIDColorH.IsKey(NID)? NIDColorH.GetDat(NID) : TIntTr(120, 120, 120);
395      double Size = MinSz;
396      double SizeStep = (MaxSz - MinSz) / (double) CmtyVVAtr.Len();
397      if (NIDComVHAtr.IsKey(NID)) {
398        Size = MinSz +  SizeStep *  (double) NIDComVHAtr.GetDat(NID).Len();
399      }
400      double Alpha = 1.0;
401      fprintf(F, "\t\t\t<node id='%d' label='%s'>\n", NID, Label.CStr());
402      fprintf(F, "\t\t\t\t<viz:color r='%d' g='%d' b='%d' a='%.1f'/>\n", Color.Val1.Val, Color.Val2.Val, Color.Val3.Val, Alpha);
403      fprintf(F, "\t\t\t\t<viz:size value='%.3f'/>\n", Size);
404      if (NIDComVHAtr.IsKey(NID)) {
405        fprintf(F, "\t\t\t\t<attvalues>\n");
406        for (int c = 0; c < NIDComVHAtr.GetDat(NID).Len(); c++) {
407          int CID = NIDComVHAtr.GetDat(NID)[c];
408          fprintf(F, "\t\t\t\t\t<attvalue for='%d' value='true'/>\n", CID);
409        }
410        fprintf(F, "\t\t\t\t</attvalues>\n");
411      }
412      fprintf(F, "\t\t\t</node>\n");
413    }
414    fprintf(F, "\t\t</nodes>\n");
415    int EID = 0;
416    fprintf(F, "\t\t<edges>\n");
417    for (TUNGraph::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
418      fprintf(F, "\t\t\t<edge id='%d' source='%d' target='%d'/>\n", EID++, EI.GetSrcNId(), EI.GetDstNId());
419    }
420    fprintf(F, "\t\t</edges>\n");
421    fprintf(F, "\t</graph>\n");
422    fprintf(F, "</gexf>\n");
423    fclose(F);
424  }
425  void TAGMUtil::SaveBipartiteGephi(const TStr& OutFNm, const TIntV& NIDV, const TVec<TIntV>& CmtyVV, const double MaxSz, const double MinSz, const TIntStrH& NIDNameH, const THash<TInt, TIntTr>& NIDColorH, const THash<TInt, TIntTr>& CIDColorH ) {
426    if (CmtyVV.Len() == 0) { return; }
427    double NXMin = 0.1, YMin = 0.1, NXMax = 250.00, YMax = 30.0;
428    double CXMin = 0.3 * NXMax, CXMax = 0.7 * NXMax;
429    double CStep = (CXMax - CXMin) / (double) CmtyVV.Len(), NStep = (NXMax - NXMin) / (double) NIDV.Len();
430    THash<TInt,TIntV> NIDComVH;
431    TAGMUtil::GetNodeMembership(NIDComVH, CmtyVV);
432    FILE* F = fopen(OutFNm.CStr(), "wt");
433    fprintf(F, "<?xml version='1.0' encoding='UTF-8'?>\n");
434    fprintf(F, "<gexf xmlns='http:&bsol;&bsol;www.gexf.net/1.2draft' xmlns:viz='http:&bsol;&bsol;www.gexf.net/1.1draft/viz' xmlns:xsi='http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance' xsi:schemaLocation='http:&bsol;&bsol;www.gexf.net/1.2draft http:&bsol;&bsol;www.gexf.net/1.2draft/gexf.xsd' version='1.2'>\n");
435    fprintf(F, "\t<graph mode='static' defaultedgetype='directed'>\n");
436    fprintf(F, "\t\t<nodes>\n");
437    for (int c = 0; c < CmtyVV.Len(); c++) {
438      int CID = c;
439      double XPos = c * CStep + CXMin;
440      TIntTr Color = CIDColorH.IsKey(CID)? CIDColorH.GetDat(CID) : TIntTr(120, 120, 120);
441      fprintf(F, "\t\t\t<node id='C%d' label='C%d'>\n", CID, CID);
442      fprintf(F, "\t\t\t\t<viz:color r='%d' g='%d' b='%d'/>\n", Color.Val1.Val, Color.Val2.Val, Color.Val3.Val);
443      fprintf(F, "\t\t\t\t<viz:size value='%.3f'/>\n", MaxSz);
444      fprintf(F, "\t\t\t\t<viz:shape value='square'/>\n");
445      fprintf(F, "\t\t\t\t<viz:position x='%f' y='%f' z='0.0'/>\n", XPos, YMax); 
446      fprintf(F, "\t\t\t</node>\n");
447    }
448    for (int u = 0;u < NIDV.Len(); u++) {
449      int NID = NIDV[u];
450      TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): "";
451      double Size = MinSz;
452      double XPos = NXMin + u * NStep;
453      TIntTr Color = NIDColorH.IsKey(NID)? NIDColorH.GetDat(NID) : TIntTr(120, 120, 120);
454      double Alpha = 1.0;
455      fprintf(F, "\t\t\t<node id='%d' label='%s'>\n", NID, Label.CStr());
456      fprintf(F, "\t\t\t\t<viz:color r='%d' g='%d' b='%d' a='%.1f'/>\n", Color.Val1.Val, Color.Val2.Val, Color.Val3.Val, Alpha);
457      fprintf(F, "\t\t\t\t<viz:size value='%.3f'/>\n", Size);
458      fprintf(F, "\t\t\t\t<viz:shape value='square'/>\n");
459      fprintf(F, "\t\t\t\t<viz:position x='%f' y='%f' z='0.0'/>\n", XPos, YMin); 
460      fprintf(F, "\t\t\t</node>\n");
461    }
462    fprintf(F, "\t\t</nodes>\n");
463    fprintf(F, "\t\t<edges>\n");
464    int EID = 0;
465    for (int u = 0;u < NIDV.Len(); u++) {
466      int NID = NIDV[u];
467      if (NIDComVH.IsKey(NID)) {
468        for (int c = 0; c < NIDComVH.GetDat(NID).Len(); c++) {
469          int CID = NIDComVH.GetDat(NID)[c];
470          fprintf(F, "\t\t\t<edge id='%d' source='C%d' target='%d'/>\n", EID++, CID, NID);
471        }
472      }
473    }
474    fprintf(F, "\t\t</edges>\n");
475    fprintf(F, "\t</graph>\n");
476    fprintf(F, "</gexf>\n");
477  }
478  int TAGMUtil::FindComsByAGM(const PUNGraph& Graph, const int InitComs, const int MaxIter, const int RndSeed, const double RegGap, const double PNoCom, const TStr PltFPrx) {
479    TRnd Rnd(RndSeed);
480    int LambdaIter = 100;
481    if (Graph->GetNodes() < 200) { LambdaIter = 1; } 
482    if (Graph->GetNodes() < 200 && Graph->GetEdges() > 2000) { LambdaIter = 100; } 
483    TAGMFit AGMFitM(Graph, InitComs, RndSeed);
484    if (PNoCom > 0.0) { AGMFitM.SetPNoCom(PNoCom); }
485    AGMFitM.RunMCMC(MaxIter, LambdaIter, "");
486    int TE = Graph->GetEdges();
487    TFltV RegV; 
488    RegV.Add(0.3 * TE);
489    for (int r = 0; r < 25; r++) {
490      RegV.Add(RegV.Last() * RegGap);
491    }
492    TFltPrV RegComsV, RegLV, RegBICV;
493    TFltV LV, BICV;
494    for (int r = 0; r < RegV.Len(); r++) {
495      double RegCoef = RegV[r];
496      AGMFitM.SetRegCoef(RegCoef);
497      AGMFitM.MLEGradAscentGivenCAG(0.01, 1000);
498      AGMFitM.SetRegCoef(0.0);
499      TVec<TIntV> EstCmtyVV;
500      AGMFitM.GetCmtyVV(EstCmtyVV, 0.99);
501      int NumLowQ = EstCmtyVV.Len();
502      RegComsV.Add(TFltPr(RegCoef, (double) NumLowQ));
503      if (EstCmtyVV.Len() > 0) {
504        TAGMFit AFTemp(Graph, EstCmtyVV, Rnd);
505        AFTemp.MLEGradAscentGivenCAG(0.001, 1000);
506        double CurL = AFTemp.Likelihood();
507        LV.Add(CurL);
508        BICV.Add(-2.0 * CurL + (double) EstCmtyVV.Len() * log((double) Graph->GetNodes() * (Graph->GetNodes() - 1) / 2.0));
509      }
510      else {
511        break;
512      }
513    }
514    if (LV.Len() == 0) { return 2; }
515    else if (LV[0] == LV.Last()) { return (int) TMath::Mx<TFlt>(2.0, RegComsV[LV.Len() - 1].Val2); }
516    int MaxL = 100;
517    {
518      TFltV& ValueV = LV;
519      TFltPrV& RegValueV = RegLV;
520      double MinValue = TFlt::Mx, MaxValue = TFlt::Mn;
521      for (int l = 0; l < ValueV.Len(); l++) {
522        if (ValueV[l] < MinValue) { MinValue = ValueV[l]; }
523        if (ValueV[l] > MaxValue) { MaxValue = ValueV[l]; }
524      }
525      while (ValueV.Len() < RegV.Len()) { ValueV.Add(MinValue); }
526      double RangeVal = MaxValue - MinValue;
527      for (int l = 0; l < ValueV.Len(); l++) {
528        RegValueV.Add(TFltPr(RegV[l], double(MaxL) * (ValueV[l] - MinValue) / RangeVal));
529      }
530    }
531    {
532      TFltV& ValueV = BICV;
533      TFltPrV& RegValueV = RegBICV;
534      double MinValue = TFlt::Mx, MaxValue = TFlt::Mn;
535      for (int l = 0; l < ValueV.Len(); l++) {
536        if (ValueV[l] < MinValue) { MinValue = ValueV[l]; }
537        if (ValueV[l] > MaxValue) { MaxValue = ValueV[l]; }
538      }
539      while (ValueV.Len() < RegV.Len()) { ValueV.Add(MaxValue); }
540      double RangeVal = MaxValue - MinValue;
541      for (int l = 0; l < ValueV.Len(); l++) {
542        RegValueV.Add(TFltPr(RegV[l], double(MaxL) * (ValueV[l] - MinValue) / RangeVal));
543      }
544    }
545    TVec<TFltV> XV(RegLV.Len());
546    TFltV YV (RegLV.Len());
547    for (int l = 0; l < RegLV.Len(); l++) {
548      XV[l] = TFltV::GetV(log(RegLV[l].Val1));
549      YV[l] = RegLV[l].Val2 / (double) MaxL;
550    }
551    TFltPrV LRVScaled, LRV;
552    TLogRegFit LRFit;
553    PLogRegPredict LRMd = LRFit.CalcLogRegNewton(XV, YV, PltFPrx);
554    for (int l = 0; l < RegLV.Len(); l++) {
555      LRV.Add(TFltPr(RegV[l], LRMd->GetCfy(XV[l])));
556      LRVScaled.Add(TFltPr(RegV[l], double(MaxL) * LRV.Last().Val2));
557    }
558    int NumComs = 0, IdxRegDrop = 0;
559    double LRThres = 1.1, RegDrop; 
560    double LeftReg = 0.0, RightReg = 0.0;
561    TFltV Theta;
562    LRMd->GetTheta(Theta);
563    RegDrop = (- Theta[1] - LRThres) / Theta[0];
564    if (RegDrop <= XV[0][0]) { NumComs = (int) RegComsV[0].Val2; }
565    else if (RegDrop >= XV.Last()[0]) { NumComs = (int) RegComsV.Last().Val2; }
566    else {  
567      for (int i = 0; i < XV.Len(); i++) {
568        if (XV[i][0] > RegDrop) { IdxRegDrop = i; break; }
569      }
570      if (IdxRegDrop == 0) {
571        printf("Error!! RegDrop:%f, Theta[0]:%f, Theta[1]:%f\n", RegDrop, Theta[0].Val, Theta[1].Val);
572        for (int l = 0; l < RegLV.Len(); l++) {
573          printf("X[%d]:%f, Y[%d]:%f\n", l, XV[l][0].Val, l, YV[l].Val);
574        }
575      }
576      IAssert(IdxRegDrop > 0);
577      LeftReg = RegDrop - XV[IdxRegDrop - 1][0];
578      RightReg = XV[IdxRegDrop][0] - RegDrop;
579      NumComs = (int) TMath::Round( (RightReg * RegComsV[IdxRegDrop - 1].Val2 + LeftReg * RegComsV[IdxRegDrop].Val2) / (LeftReg + RightReg));
580    }
581    printf("Num Coms:%d\n", NumComs);
582    if (NumComs < 2) { NumComs = 2; }
583    if (PltFPrx.Len() > 0) {
584      TStr PlotTitle = TStr::Fmt("N:%d, E:%d ", Graph->GetNodes(), TE);
585      TGnuPlot GPC(PltFPrx + ".l");
586      GPC.AddPlot(RegComsV, gpwLinesPoints, "C");
587      GPC.AddPlot(RegLV, gpwLinesPoints, "likelihood");
588      GPC.AddPlot(RegBICV, gpwLinesPoints, "BIC");
589      GPC.AddPlot(LRVScaled, gpwLinesPoints, "Sigmoid (scaled)");
590      GPC.SetScale(gpsLog10X);
591      GPC.SetTitle(PlotTitle);
592      GPC.SavePng(PltFPrx + ".l.png");
593    }
594    return NumComs;
595  }
596  double TAGMUtil::GetConductance(const PUNGraph& Graph, const TIntSet& CmtyS, const int Edges) {
597    const int Edges2 = Edges >= 0 ? 2*Edges : Graph->GetEdges();
598    int Vol = 0,  Cut = 0; 
599    double Phi = 0.0;
600    for (int i = 0; i < CmtyS.Len(); i++) {
601      if (! Graph->IsNode(CmtyS[i])) { continue; }
602      TUNGraph::TNodeI NI = Graph->GetNI(CmtyS[i]);
603      for (int e = 0; e < NI.GetOutDeg(); e++) {
604        if (! CmtyS.IsKey(NI.GetOutNId(e))) { Cut += 1; }
605      }
606      Vol += NI.GetOutDeg();
607    }
608    if (Vol != Edges2) {
609      if (2 * Vol > Edges2) { Phi = Cut / double (Edges2 - Vol); }
610      else if (Vol == 0) { Phi = 0.0; }
611      else { Phi = Cut / double(Vol); }
612    } else {
613      if (Vol == Edges2) { Phi = 1.0; }
614    }
615    return Phi;
616  }
617  void TAGMUtil::GetNbhCom(const PUNGraph& Graph, const int NID, TIntSet& NBCmtyS) {
618    TUNGraph::TNodeI NI = Graph->GetNI(NID);
619    NBCmtyS.Gen(NI.GetDeg());
620    NBCmtyS.AddKey(NID);
621    for (int e = 0; e < NI.GetDeg(); e++) {
622      NBCmtyS.AddKey(NI.GetNbrNId(e));
623    }
624  }
625  void TLogRegFit::GetNewtonStep(TFltVV& HVV, const TFltV& GradV, TFltV& DeltaLV){
626    bool HSingular = false;
627    for (int i = 0; i < HVV.GetXDim(); i++) {
628      if (HVV(i,i) == 0.0) {
629        HVV(i,i) = 0.001;
630        HSingular = true;
631      }
632      DeltaLV[i] = GradV[i] / HVV(i, i);
633    }
634    if (! HSingular) {
635      if (HVV(0, 0) < 0) { 
636        for (int r = 0; r < Theta.Len(); r++) {
637          for (int c = 0; c < Theta.Len(); c++) {
638            HVV(r, c) = - HVV(r, c);
639          }
640        }
641        TNumericalStuff::SolveSymetricSystem(HVV, GradV, DeltaLV);
642      }
643      else {
644        TNumericalStuff::SolveSymetricSystem(HVV, GradV, DeltaLV);
645        for (int i = 0; i < DeltaLV.Len(); i++) {
646          DeltaLV[i] = - DeltaLV[i];
647        }
648      }
649    }
650  }
651  void TLogRegFit::Hessian(TFltVV& HVV) {
652    HVV.Gen(Theta.Len(), Theta.Len());
653    TFltV OutV;
654    TLogRegPredict::GetCfy(X, OutV, Theta);
655    for (int i = 0; i < X.Len(); i++) {
656      for (int r = 0; r < Theta.Len(); r++) {
657        HVV.At(r, r) += - (X[i][r] * OutV[i] * (1 - OutV[i]) * X[i][r]);
658        for (int c = r + 1; c < Theta.Len(); c++) {
659          HVV.At(r, c) += - (X[i][r] * OutV[i] * (1 - OutV[i]) * X[i][c]);
660          HVV.At(c, r) += - (X[i][r] * OutV[i] * (1 - OutV[i]) * X[i][c]);
661        }
662      }
663    }
664  }
665  int TLogRegFit::MLENewton(const double& ChangeEps, const int& MaxStep, const TStr PlotNm) {
666    TExeTm ExeTm;
667    TFltV GradV(Theta.Len()), DeltaLV(Theta.Len());
668    TFltVV HVV(Theta.Len(), Theta.Len());
669    int iter = 0;
670    double MinVal = -1e10, MaxVal = 1e10;
671    for(iter = 0; iter < MaxStep; iter++) {
672      Gradient(GradV);
673      Hessian(HVV);
674      GetNewtonStep(HVV, GradV, DeltaLV);
675      double Increment = TLinAlg::DotProduct(GradV, DeltaLV);
676      if (Increment <= ChangeEps) {break;}
677      double LearnRate = GetStepSizeByLineSearch(DeltaLV, GradV, 0.15, 0.5);
678      for(int i = 0; i < Theta.Len(); i++) {
679        double Change = LearnRate * DeltaLV[i];
680        Theta[i] += Change;
681        if(Theta[i] < MinVal) { Theta[i] = MinVal;}
682        if(Theta[i] > MaxVal) { Theta[i] = MaxVal;}
683      }
684    }
685    if (! PlotNm.Empty()) {
686      printf("MLE with Newton method completed with %d iterations(%s)\n",iter,ExeTm.GetTmStr());
687    }
688    return iter;
689  }
690  int TLogRegFit::MLEGradient(const double& ChangeEps, const int& MaxStep, const TStr PlotNm) {
691    TExeTm ExeTm;
692    TFltV GradV(Theta.Len());
693    int iter = 0;
694    TIntFltPrV IterLV, IterGradNormV;
695    double MinVal = -1e10, MaxVal = 1e10;
696    double GradCutOff = 100000;
697    for(iter = 0; iter < MaxStep; iter++) {
698      Gradient(GradV);    
699      for(int i = 0; i < Theta.Len(); i++) {
700        if (GradV[i] < -GradCutOff) { GradV[i] = -GradCutOff; }
701        if (GradV[i] > GradCutOff) { GradV[i] = GradCutOff; }
702        if (Theta[i] <= MinVal && GradV[i] < 0) { GradV[i] = 0.0; }
703        if (Theta[i] >= MaxVal && GradV[i] > 0) { GradV[i] = 0.0; }
704      }
705      double Alpha = 0.15, Beta = 0.9;
706      double LearnRate = GetStepSizeByLineSearch(GradV, GradV, Alpha, Beta);
707      if (TLinAlg::Norm(GradV) < ChangeEps) { break; }
708      for(int i = 0; i < Theta.Len(); i++) {
709        double Change = LearnRate * GradV[i];
710        Theta[i] += Change;
711        if(Theta[i] < MinVal) { Theta[i] = MinVal;}
712        if(Theta[i] > MaxVal) { Theta[i] = MaxVal;}
713      }
714      if (! PlotNm.Empty()) {
715        double L = Likelihood();
716        IterLV.Add(TIntFltPr(iter, L));
717        IterGradNormV.Add(TIntFltPr(iter, TLinAlg::Norm(GradV)));
718      }
719    }
720    if (! PlotNm.Empty()) {
721      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
722      TGnuPlot::PlotValV(IterGradNormV, PlotNm + ".gradnorm_Q");
723      printf("MLE for Lambda completed with %d iterations(%s)\n",iter,ExeTm.GetTmStr());
724    }
725    return iter;
726  }
727  double TLogRegFit::GetStepSizeByLineSearch(const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta) {
728    double StepSize = 1.0;
729    double InitLikelihood = Likelihood();
730    IAssert(Theta.Len() == DeltaV.Len());
731    TFltV NewThetaV(Theta.Len());
732    double MinVal = -1e10, MaxVal = 1e10;
733    for(int iter = 0; ; iter++) {
734      for (int i = 0; i < Theta.Len(); i++){
735        NewThetaV[i] = Theta[i] + StepSize * DeltaV[i];
736        if (NewThetaV[i] < MinVal) { NewThetaV[i] = MinVal;  }
737        if (NewThetaV[i] > MaxVal) { NewThetaV[i] = MaxVal; }
738      }
739      if (Likelihood(NewThetaV) < InitLikelihood + Alpha * StepSize * TLinAlg::DotProduct(GradV, DeltaV)) {
740        StepSize *= Beta;
741      } else {
742        break;
743      }
744    }
745    return StepSize;
746  }
747  double TLogRegFit::Likelihood(const TFltV& NewTheta) {
748    TFltV OutV;
749    TLogRegPredict::GetCfy(X, OutV, NewTheta);
750    double L = 0;
751    for (int r = 0; r < OutV.Len(); r++) {
752      L += Y[r] * log(OutV[r]);
753      L += (1 - Y[r]) * log(1 - OutV[r]);
754    }
755    return L;
756  }
757  void TLogRegFit::Gradient(TFltV& GradV) {
758    TFltV OutV;
759    TLogRegPredict::GetCfy(X, OutV, Theta);
760    GradV.Gen(M);
761    for (int r = 0; r < X.Len(); r++) {
762      for (int m = 0; m < M; m++) {
763        GradV[m] += (Y[r] - OutV[r]) * X[r][m];
764      }
765    }
766  }
767  PLogRegPredict TLogRegFit::CalcLogRegNewton(const TVec<TFltV>& XPt, const TFltV& yPt, const TStr& PlotNm, const double& ChangeEps, const int& MaxStep, const bool Intercept) {
768    X = XPt;
769    Y = yPt;
770    IAssert(X.Len() == Y.Len());
771    if (Intercept == false) { 
772      for (int r = 0; r < X.Len(); r++) {  X[r].Add(1); }
773    }
774    M = X[0].Len();
775    for (int r = 0; r < X.Len(); r++) {  IAssert(X[r].Len() == M); }
776    for (int r = 0; r < Y.Len(); r++) {  
777      if (Y[r] >= 0.99999) { Y[r] = 0.99999; }
778      if (Y[r] <= 0.00001) { Y[r] = 0.00001; }
779    }
780    Theta.Gen(M);
781    MLENewton(ChangeEps, MaxStep, PlotNm);
782    return new TLogRegPredict(Theta); 
783  };
784  PLogRegPredict TLogRegFit::CalcLogRegGradient(const TVec<TFltV>& XPt, const TFltV& yPt, const TStr& PlotNm, const double& ChangeEps, const int& MaxStep, const bool Intercept) {
785    X = XPt;
786    Y = yPt;
787    IAssert(X.Len() == Y.Len());
788    if (Intercept == false) { 
789      for (int r = 0; r < X.Len(); r++) {  X[r].Add(1); }
790    }
791    M = X[0].Len();
792    for (int r = 0; r < X.Len(); r++) {  IAssert(X[r].Len() == M); }
793    for (int r = 0; r < Y.Len(); r++) {  
794      if (Y[r] >= 0.99999) { Y[r] = 0.99999; }
795      if (Y[r] <= 0.00001) { Y[r] = 0.00001; }
796    }
797    Theta.Gen(M);
798    MLEGradient(ChangeEps, MaxStep, PlotNm);
799    return new TLogRegPredict(Theta); 
800  };
801  double TLogRegPredict::GetCfy(const TFltV& AttrV, const TFltV& NewTheta) {
802      int len = AttrV.Len();
803      double res = 0;
804      if (len < NewTheta.Len()) { res = NewTheta.Last(); } 
805      for (int i = 0; i < len; i++) {
806        if (i < NewTheta.Len()) { res += AttrV[i] * NewTheta[i]; }
807      }
808      double mu = 1 / (1 + exp(-res));
809      return mu;
810  }
811  void TLogRegPredict::GetCfy(const TVec<TFltV>& X, TFltV& OutV, const TFltV& NewTheta) {
812    OutV.Gen(X.Len());
813    for (int r = 0; r < X.Len(); r++) {
814      OutV[r] = GetCfy(X[r], NewTheta);
815    }
816  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_alternate.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agm.cpp</div>
                </div>
                <div class="column column_space"><pre><code>57  inline void cblas_saxpby(const int N, const float alpha, const float* X,
58                           const int incX, const float beta, float* Y,
</pre></code></div>
                <div class="column column_space"><pre><code>75  void TAGMUtil::GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd){
75  void TAGMUtil::GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    