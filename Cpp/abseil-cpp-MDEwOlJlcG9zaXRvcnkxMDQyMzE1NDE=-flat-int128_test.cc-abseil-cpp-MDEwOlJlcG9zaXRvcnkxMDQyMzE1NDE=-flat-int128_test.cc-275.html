
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-int128_test.cc</h3>
            <pre><code>1  #include &quot;absl/numeric/int128.h&quot;
2  #include &lt;algorithm&gt;
3  #include &lt;limits&gt;
4  #include &lt;random&gt;
5  #include &lt;type_traits&gt;
6  #include &lt;utility&gt;
7  #include &lt;vector&gt;
8  #include &quot;gtest/gtest.h&quot;
9  #include &quot;absl/base/internal/cycleclock.h&quot;
10  #include &quot;absl/hash/hash_testing.h&quot;
11  #include &quot;absl/meta/type_traits.h&quot;
12  #if defined(_MSC_VER) &amp;&amp; _MSC_VER == 1900
13  #pragma warning(disable:4146)
14  #endif
15  #define MAKE_INT128(HI, LO) absl::MakeInt128(static_cast&lt;int64_t&gt;(HI), LO)
16  namespace {
17  template &lt;typename T&gt;
18  class Uint128IntegerTraitsTest : public ::testing::Test {};
19  typedef ::testing::Types&lt;bool, char, signed char, unsigned char, char16_t,
20                           char32_t, wchar_t,
21                           short,           
22                           unsigned short,  
23                           int, unsigned int,
24                           long,                
25                           unsigned long,       
26                           long long,           
27                           unsigned long long&gt;  
28      IntegerTypes;
29  template &lt;typename T&gt;
30  class Uint128FloatTraitsTest : public ::testing::Test {};
31  typedef ::testing::Types&lt;float, double, long double&gt; FloatingPointTypes;
32  TYPED_TEST_SUITE(Uint128IntegerTraitsTest, IntegerTypes);
33  TYPED_TEST(Uint128IntegerTraitsTest, ConstructAssignTest) {
34    static_assert(std::is_constructible&lt;absl::uint128, TypeParam&gt;::value,
35                  &quot;absl::uint128 must be constructible from TypeParam&quot;);
36    static_assert(std::is_assignable&lt;absl::uint128&amp;, TypeParam&gt;::value,
37                  &quot;absl::uint128 must be assignable from TypeParam&quot;);
38    static_assert(!std::is_assignable&lt;TypeParam&amp;, absl::uint128&gt;::value,
39                  &quot;TypeParam must not be assignable from absl::uint128&quot;);
40  }
41  TYPED_TEST_SUITE(Uint128FloatTraitsTest, FloatingPointTypes);
42  TYPED_TEST(Uint128FloatTraitsTest, ConstructAssignTest) {
43    static_assert(std::is_constructible&lt;absl::uint128, TypeParam&gt;::value,
44                  &quot;absl::uint128 must be constructible from TypeParam&quot;);
45    static_assert(!std::is_assignable&lt;absl::uint128&amp;, TypeParam&gt;::value,
46                  &quot;absl::uint128 must not be assignable from TypeParam&quot;);
47    static_assert(!std::is_assignable&lt;TypeParam&amp;, absl::uint128&gt;::value,
48                  &quot;TypeParam must not be assignable from absl::uint128&quot;);
49  }
50  #ifdef ABSL_HAVE_INTRINSIC_INT128
51  TEST(Uint128, IntrinsicTypeTraitsTest) {
52    static_assert(std::is_constructible&lt;absl::uint128, __int128&gt;::value,
53                  &quot;absl::uint128 must be constructible from __int128&quot;);
54    static_assert(std::is_assignable&lt;absl::uint128&amp;, __int128&gt;::value,
55                  &quot;absl::uint128 must be assignable from __int128&quot;);
56    static_assert(!std::is_assignable&lt;__int128&amp;, absl::uint128&gt;::value,
57                  &quot;__int128 must not be assignable from absl::uint128&quot;);
58    static_assert(std::is_constructible&lt;absl::uint128, unsigned __int128&gt;::value,
59                  &quot;absl::uint128 must be constructible from unsigned __int128&quot;);
60    static_assert(std::is_assignable&lt;absl::uint128&amp;, unsigned __int128&gt;::value,
61                  &quot;absl::uint128 must be assignable from unsigned __int128&quot;);
62    static_assert(!std::is_assignable&lt;unsigned __int128&amp;, absl::uint128&gt;::value,
63                  &quot;unsigned __int128 must not be assignable from absl::uint128&quot;);
64  }
65  #endif  
66  TEST(Uint128, TrivialTraitsTest) {
67    static_assert(absl::is_trivially_default_constructible&lt;absl::uint128&gt;::value,
68                  &quot;&quot;);
69    static_assert(absl::is_trivially_copy_constructible&lt;absl::uint128&gt;::value,
70                  &quot;&quot;);
71    static_assert(absl::is_trivially_copy_assignable&lt;absl::uint128&gt;::value, &quot;&quot;);
72    static_assert(std::is_trivially_destructible&lt;absl::uint128&gt;::value, &quot;&quot;);
73  }
74  TEST(Uint128, AllTests) {
75    absl::uint128 zero = 0;
76    absl::uint128 one = 1;
77    absl::uint128 one_2arg = absl::MakeUint128(0, 1);
78    absl::uint128 two = 2;
79    absl::uint128 three = 3;
80    absl::uint128 big = absl::MakeUint128(2000, 2);
81    absl::uint128 big_minus_one = absl::MakeUint128(2000, 1);
82    absl::uint128 bigger = absl::MakeUint128(2001, 1);
83    absl::uint128 biggest = absl::Uint128Max();
84    absl::uint128 high_low = absl::MakeUint128(1, 0);
85    absl::uint128 low_high =
86        absl::MakeUint128(0, std::numeric_limits&lt;uint64_t&gt;::max());
87    EXPECT_LT(one, two);
88    EXPECT_GT(two, one);
89    EXPECT_LT(one, big);
90    EXPECT_LT(one, big);
91    EXPECT_EQ(one, one_2arg);
92    EXPECT_NE(one, two);
93    EXPECT_GT(big, one);
94    EXPECT_GE(big, two);
95    EXPECT_GE(big, big_minus_one);
96    EXPECT_GT(big, big_minus_one);
97    EXPECT_LT(big_minus_one, big);
98    EXPECT_LE(big_minus_one, big);
99    EXPECT_NE(big_minus_one, big);
100    EXPECT_LT(big, biggest);
101    EXPECT_LE(big, biggest);
102    EXPECT_GT(biggest, big);
103    EXPECT_GE(biggest, big);
104    EXPECT_EQ(big, ~~big);
105    EXPECT_EQ(one, one | one);
106    EXPECT_EQ(big, big | big);
107    EXPECT_EQ(one, one | zero);
108    EXPECT_EQ(one, one &amp; one);
109    EXPECT_EQ(big, big &amp; big);
110    EXPECT_EQ(zero, one &amp; zero);
111    EXPECT_EQ(zero, big &amp; ~big);
112    EXPECT_EQ(zero, one ^ one);
113    EXPECT_EQ(zero, big ^ big);
114    EXPECT_EQ(one, one ^ zero);
115    EXPECT_EQ(big, big &lt;&lt; 0);
116    EXPECT_EQ(big, big &gt;&gt; 0);
117    EXPECT_GT(big &lt;&lt; 1, big);
118    EXPECT_LT(big &gt;&gt; 1, big);
119    EXPECT_EQ(big, (big &lt;&lt; 10) &gt;&gt; 10);
120    EXPECT_EQ(big, (big &gt;&gt; 1) &lt;&lt; 1);
121    EXPECT_EQ(one, (one &lt;&lt; 80) &gt;&gt; 80);
122    EXPECT_EQ(zero, (one &gt;&gt; 80) &lt;&lt; 80);
123    absl::uint128 big_copy = big;
124    EXPECT_EQ(big &lt;&lt; 0, big_copy &lt;&lt;= 0);
125    big_copy = big;
126    EXPECT_EQ(big &gt;&gt; 0, big_copy &gt;&gt;= 0);
127    big_copy = big;
128    EXPECT_EQ(big &lt;&lt; 1, big_copy &lt;&lt;= 1);
129    big_copy = big;
130    EXPECT_EQ(big &gt;&gt; 1, big_copy &gt;&gt;= 1);
131    big_copy = big;
132    EXPECT_EQ(big &lt;&lt; 10, big_copy &lt;&lt;= 10);
133    big_copy = big;
134    EXPECT_EQ(big &gt;&gt; 10, big_copy &gt;&gt;= 10);
135    big_copy = big;
136    EXPECT_EQ(big &lt;&lt; 64, big_copy &lt;&lt;= 64);
137    big_copy = big;
138    EXPECT_EQ(big &gt;&gt; 64, big_copy &gt;&gt;= 64);
139    big_copy = big;
140    EXPECT_EQ(big &lt;&lt; 73, big_copy &lt;&lt;= 73);
141    big_copy = big;
142    EXPECT_EQ(big &gt;&gt; 73, big_copy &gt;&gt;= 73);
143    EXPECT_EQ(absl::Uint128High64(biggest), std::numeric_limits&lt;uint64_t&gt;::max());
144    EXPECT_EQ(absl::Uint128Low64(biggest), std::numeric_limits&lt;uint64_t&gt;::max());
145    EXPECT_EQ(zero + one, one);
146    EXPECT_EQ(one + one, two);
147    EXPECT_EQ(big_minus_one + one, big);
148    EXPECT_EQ(one - one, zero);
149    EXPECT_EQ(one - zero, one);
150    EXPECT_EQ(zero - one, biggest);
151    EXPECT_EQ(big - big, zero);
152    EXPECT_EQ(big - one, big_minus_one);
153    EXPECT_EQ(big + std::numeric_limits&lt;uint64_t&gt;::max(), bigger);
154    EXPECT_EQ(biggest + 1, zero);
155    EXPECT_EQ(zero - 1, biggest);
156    EXPECT_EQ(high_low - one, low_high);
157    EXPECT_EQ(low_high + one, high_low);
158    EXPECT_EQ(absl::Uint128High64((absl::uint128(1) &lt;&lt; 64) - 1), 0);
159    EXPECT_EQ(absl::Uint128Low64((absl::uint128(1) &lt;&lt; 64) - 1),
160              std::numeric_limits&lt;uint64_t&gt;::max());
161    EXPECT_TRUE(!!one);
162    EXPECT_TRUE(!!high_low);
163    EXPECT_FALSE(!!zero);
164    EXPECT_FALSE(!one);
165    EXPECT_FALSE(!high_low);
166    EXPECT_TRUE(!zero);
167    EXPECT_TRUE(zero == 0);       
168    EXPECT_FALSE(zero != 0);      
169    EXPECT_FALSE(one == 0);       
170    EXPECT_TRUE(one != 0);        
171    EXPECT_FALSE(high_low == 0);  
172    EXPECT_TRUE(high_low != 0);   
173    absl::uint128 test = zero;
174    EXPECT_EQ(++test, one);
175    EXPECT_EQ(test, one);
176    EXPECT_EQ(test++, one);
177    EXPECT_EQ(test, two);
178    EXPECT_EQ(test -= 2, zero);
179    EXPECT_EQ(test, zero);
180    EXPECT_EQ(test += 2, two);
181    EXPECT_EQ(test, two);
182    EXPECT_EQ(--test, one);
183    EXPECT_EQ(test, one);
184    EXPECT_EQ(test--, one);
185    EXPECT_EQ(test, zero);
186    EXPECT_EQ(test |= three, three);
187    EXPECT_EQ(test &amp;= one, one);
188    EXPECT_EQ(test ^= three, two);
189    EXPECT_EQ(test &gt;&gt;= 1, one);
190    EXPECT_EQ(test &lt;&lt;= 1, two);
191    EXPECT_EQ(big, +big);
192    EXPECT_EQ(two, +two);
193    EXPECT_EQ(absl::Uint128Max(), +absl::Uint128Max());
194    EXPECT_EQ(zero, +zero);
195    EXPECT_EQ(big, -(-big));
196    EXPECT_EQ(two, -((-one) - 1));
197    EXPECT_EQ(absl::Uint128Max(), -one);
198    EXPECT_EQ(zero, -zero);
199    EXPECT_EQ(absl::Uint128Max(), absl::kuint128max);
200  }
201  TEST(Int128, RightShiftOfNegativeNumbers) {
202    absl::int128 minus_six = -6;
203    absl::int128 minus_three = -3;
204    absl::int128 minus_two = -2;
205    absl::int128 minus_one = -1;
206    if ((-6 &gt;&gt; 1) == -3) {
207      EXPECT_EQ(minus_six &gt;&gt; 1, minus_three);
208      EXPECT_EQ(minus_six &gt;&gt; 2, minus_two);
209      EXPECT_EQ(minus_six &gt;&gt; 65, minus_one);
210    } else {
211      EXPECT_EQ(minus_six &gt;&gt; 1, absl::int128(absl::uint128(minus_six) &gt;&gt; 1));
212      EXPECT_EQ(minus_six &gt;&gt; 2, absl::int128(absl::uint128(minus_six) &gt;&gt; 2));
213      EXPECT_EQ(minus_six &gt;&gt; 65, absl::int128(absl::uint128(minus_six) &gt;&gt; 65));
214    }
215  }
216  TEST(Uint128, ConversionTests) {
217    EXPECT_TRUE(absl::MakeUint128(1, 0));
218  #ifdef ABSL_HAVE_INTRINSIC_INT128
219    unsigned __int128 intrinsic =
220        (static_cast&lt;unsigned __int128&gt;(0x3a5b76c209de76f6) &lt;&lt; 64) +
221        0x1f25e1d63a2b46c5;
222    absl::uint128 custom =
223        absl::MakeUint128(0x3a5b76c209de76f6, 0x1f25e1d63a2b46c5);
224    EXPECT_EQ(custom, absl::uint128(intrinsic));
225    EXPECT_EQ(custom, absl::uint128(static_cast&lt;__int128&gt;(intrinsic)));
226    EXPECT_EQ(intrinsic, static_cast&lt;unsigned __int128&gt;(custom));
227    EXPECT_EQ(intrinsic, static_cast&lt;__int128&gt;(custom));
228  #endif  
229    double precise_double = 0x530e * std::pow(2.0, 64.0) + 0xda74000000000000;
230    absl::uint128 from_precise_double(precise_double);
231    absl::uint128 from_precise_ints =
232        absl::MakeUint128(0x530e, 0xda74000000000000);
233    EXPECT_EQ(from_precise_double, from_precise_ints);
234    EXPECT_DOUBLE_EQ(static_cast&lt;double&gt;(from_precise_ints), precise_double);
235    double approx_double =
236        static_cast&lt;double&gt;(0xffffeeeeddddcccc) * std::pow(2.0, 64.0) +
237        static_cast&lt;double&gt;(0xbbbbaaaa99998888);
238    absl::uint128 from_approx_double(approx_double);
239    EXPECT_DOUBLE_EQ(static_cast&lt;double&gt;(from_approx_double), approx_double);
240    double round_to_zero = 0.7;
241    double round_to_five = 5.8;
242    double round_to_nine = 9.3;
243    EXPECT_EQ(static_cast&lt;absl::uint128&gt;(round_to_zero), 0);
244    EXPECT_EQ(static_cast&lt;absl::uint128&gt;(round_to_five), 5);
245    EXPECT_EQ(static_cast&lt;absl::uint128&gt;(round_to_nine), 9);
246    absl::uint128 highest_precision_in_long_double =
247        ~absl::uint128{} &gt;&gt; (128 - std::numeric_limits&lt;long double&gt;::digits);
248    EXPECT_EQ(highest_precision_in_long_double,
249              static_cast&lt;absl::uint128&gt;(
250                  static_cast&lt;long double&gt;(highest_precision_in_long_double)));
251    const absl::uint128 arbitrary_mask =
252        absl::MakeUint128(0xa29f622677ded751, 0xf8ca66add076f468);
253    EXPECT_EQ(highest_precision_in_long_double &amp; arbitrary_mask,
254              static_cast&lt;absl::uint128&gt;(static_cast&lt;long double&gt;(
255                  highest_precision_in_long_double &amp; arbitrary_mask)));
256    EXPECT_EQ(static_cast&lt;absl::uint128&gt;(-0.1L), 0);
257  }
258  TEST(Uint128, OperatorAssignReturnRef) {
259    absl::uint128 v(1);
260    (v += 4) -= 3;
261    EXPECT_EQ(2, v);
262  }
263  TEST(Uint128, Multiply) {
264    absl::uint128 a, b, c;
265    a = 0;
266    b = 0;
267    c = a * b;
268    EXPECT_EQ(0, c);
269    a = absl::uint128(0) - 1;
270    b = absl::uint128(0) - 1;
271    c = a * b;
272    EXPECT_EQ(1, c);
273    c = absl::uint128(0) - 1;
274    c *= c;
275    EXPECT_EQ(1, c);
276    for (int i = 0; i &lt; 64; ++i) {
277      for (int j = 0; j &lt; 64; ++j) {
278        a = absl::uint128(1) &lt;&lt; i;
279        b = absl::uint128(1) &lt;&lt; j;
280        c = a * b;
281        EXPECT_EQ(absl::uint128(1) &lt;&lt; (i + j), c);
282      }
283    }
284    a = absl::MakeUint128(0xffffeeeeddddcccc, 0xbbbbaaaa99998888);
285    b = absl::MakeUint128(0x7777666655554444, 0x3333222211110000);
286    c = a * b;
287    EXPECT_EQ(absl::MakeUint128(0x530EDA741C71D4C3, 0xBF25975319080000), c);
288    EXPECT_EQ(0, c - b * a);
289    EXPECT_EQ(a*a - b*b, (a+b) * (a-b));
290    a = absl::MakeUint128(0x0123456789abcdef, 0xfedcba9876543210);
291    b = absl::MakeUint128(0x02468ace13579bdf, 0xfdb97531eca86420);
292    c = a * b;
293    EXPECT_EQ(absl::MakeUint128(0x97a87f4f261ba3f2, 0x342d0bbf48948200), c);
294    EXPECT_EQ(0, c - b * a);
295    EXPECT_EQ(a*a - b*b, (a+b) * (a-b));
296  }
297  TEST(Uint128, AliasTests) {
298    absl::uint128 x1 = absl::MakeUint128(1, 2);
299    absl::uint128 x2 = absl::MakeUint128(2, 4);
300    x1 += x1;
301    EXPECT_EQ(x2, x1);
302    absl::uint128 x3 = absl::MakeUint128(1, static_cast&lt;uint64_t&gt;(1) &lt;&lt; 63);
303    absl::uint128 x4 = absl::MakeUint128(3, 0);
304    x3 += x3;
305    EXPECT_EQ(x4, x3);
306  }
307  TEST(Uint128, DivideAndMod) {
308    using std::swap;
309    absl::uint128 a, b, q, r;
310    a = 0;
311    b = 123;
312    q = a / b;
313    r = a % b;
314    EXPECT_EQ(0, q);
315    EXPECT_EQ(0, r);
316    a = absl::MakeUint128(0x530eda741c71d4c3, 0xbf25975319080000);
317    q = absl::MakeUint128(0x4de2cab081, 0x14c34ab4676e4bab);
318    b = absl::uint128(0x1110001);
319    r = absl::uint128(0x3eb455);
320    ASSERT_EQ(a, q * b + r);  
321    absl::uint128 result_q, result_r;
322    result_q = a / b;
323    result_r = a % b;
324    EXPECT_EQ(q, result_q);
325    EXPECT_EQ(r, result_r);
326    swap(q, b);
327    result_q = a / b;
328    result_r = a % b;
329    EXPECT_EQ(q, result_q);
330    EXPECT_EQ(r, result_r);
331    swap(b, q);
332    swap(a, b);
333    result_q = a / b;
334    result_r = a % b;
335    EXPECT_EQ(0, result_q);
336    EXPECT_EQ(a, result_r);
337    swap(a, q);
338    result_q = a / b;
339    result_r = a % b;
340    EXPECT_EQ(0, result_q);
341    EXPECT_EQ(a, result_r);
342    swap(q, a);
343    swap(b, a);
344    b = a / 2 + 1;
345    absl::uint128 expected_r =
346        absl::MakeUint128(0x29876d3a0e38ea61, 0xdf92cba98c83ffff);
347    ASSERT_EQ(a / 2 - 1, expected_r);
348    ASSERT_EQ(a, b + expected_r);
349    result_q = a / b;
350    result_r = a % b;
351    EXPECT_EQ(1, result_q);
352    EXPECT_EQ(expected_r, result_r);
353  }
354  TEST(Uint128, DivideAndModRandomInputs) {
355    const int kNumIters = 1 &lt;&lt; 18;
356    std::minstd_rand random(testing::UnitTest::GetInstance()-&gt;random_seed());
357    std::uniform_int_distribution&lt;uint64_t&gt; uniform_uint64;
358    for (int i = 0; i &lt; kNumIters; ++i) {
359      const absl::uint128 a =
360          absl::MakeUint128(uniform_uint64(random), uniform_uint64(random));
361      const absl::uint128 b =
362          absl::MakeUint128(uniform_uint64(random), uniform_uint64(random));
363      if (b == 0) {
364        continue;  
365      }
366      const absl::uint128 q = a / b;
367      const absl::uint128 r = a % b;
368      ASSERT_EQ(a, b * q + r);
369    }
370  }
371  TEST(Uint128, ConstexprTest) {
372    constexpr absl::uint128 zero = absl::uint128();
373    constexpr absl::uint128 one = 1;
374    constexpr absl::uint128 minus_two = -2;
375    EXPECT_EQ(zero, absl::uint128(0));
376    EXPECT_EQ(one, absl::uint128(1));
377    EXPECT_EQ(minus_two, absl::MakeUint128(-1, -2));
378  }
379  TEST(Uint128, NumericLimitsTest) {
380    static_assert(std::numeric_limits&lt;absl::uint128&gt;::is_specialized, &quot;&quot;);
381    static_assert(!std::numeric_limits&lt;absl::uint128&gt;::is_signed, &quot;&quot;);
382    static_assert(std::numeric_limits&lt;absl::uint128&gt;::is_integer, &quot;&quot;);
383    EXPECT_EQ(static_cast&lt;int&gt;(128 * std::log10(2)),
384              std::numeric_limits&lt;absl::uint128&gt;::digits10);
385    EXPECT_EQ(0, std::numeric_limits&lt;absl::uint128&gt;::min());
386    EXPECT_EQ(0, std::numeric_limits&lt;absl::uint128&gt;::lowest());
387    EXPECT_EQ(absl::Uint128Max(), std::numeric_limits&lt;absl::uint128&gt;::max());
388  }
389  TEST(Uint128, Hash) {
390    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
391        absl::uint128{0},
392        absl::uint128{1},
393        ~absl::uint128{},
394        absl::uint128{std::numeric_limits&lt;int64_t&gt;::max()},
395        absl::uint128{std::numeric_limits&lt;uint64_t&gt;::max()} + 0,
396        absl::uint128{std::numeric_limits&lt;uint64_t&gt;::max()} + 1,
397        absl::uint128{std::numeric_limits&lt;uint64_t&gt;::max()} + 2,
398        absl::uint128{1} &lt;&lt; 62,
399        absl::uint128{1} &lt;&lt; 63,
400        absl::uint128{1} &lt;&lt; 64,
401        absl::uint128{1} &lt;&lt; 65,
402        std::numeric_limits&lt;absl::uint128&gt;::max(),
403        std::numeric_limits&lt;absl::uint128&gt;::max() - 1,
404        std::numeric_limits&lt;absl::uint128&gt;::min() + 1,
405        std::numeric_limits&lt;absl::uint128&gt;::min(),
406    }));
407  }
408  TEST(Int128Uint128, ConversionTest) {
409    absl::int128 nonnegative_signed_values[] = {
410        0,
411        1,
412        0xffeeddccbbaa9988,
413        absl::MakeInt128(0x7766554433221100, 0),
414        absl::MakeInt128(0x1234567890abcdef, 0xfedcba0987654321),
415        absl::Int128Max()};
416    for (absl::int128 value : nonnegative_signed_values) {
417      EXPECT_EQ(value, absl::int128(absl::uint128(value)));
418      absl::uint128 assigned_value;
419      assigned_value = value;
420      EXPECT_EQ(value, absl::int128(assigned_value));
421    }
422    absl::int128 negative_values[] = {
423        -1, -0x1234567890abcdef,
424        absl::MakeInt128(-0x5544332211ffeedd, 0),
425        -absl::MakeInt128(0x76543210fedcba98, 0xabcdef0123456789)};
426    for (absl::int128 value : negative_values) {
427      EXPECT_EQ(absl::uint128(-value), -absl::uint128(value));
428      absl::uint128 assigned_value;
429      assigned_value = value;
430      EXPECT_EQ(absl::uint128(-value), -assigned_value);
431    }
432  }
433  template &lt;typename T&gt;
434  class Int128IntegerTraitsTest : public ::testing::Test {};
435  TYPED_TEST_SUITE(Int128IntegerTraitsTest, IntegerTypes);
436  TYPED_TEST(Int128IntegerTraitsTest, ConstructAssignTest) {
437    static_assert(std::is_constructible&lt;absl::int128, TypeParam&gt;::value,
438                  &quot;absl::int128 must be constructible from TypeParam&quot;);
439    static_assert(std::is_assignable&lt;absl::int128&amp;, TypeParam&gt;::value,
440                  &quot;absl::int128 must be assignable from TypeParam&quot;);
441    static_assert(!std::is_assignable&lt;TypeParam&amp;, absl::int128&gt;::value,
442                  &quot;TypeParam must not be assignable from absl::int128&quot;);
443  }
444  template &lt;typename T&gt;
445  class Int128FloatTraitsTest : public ::testing::Test {};
446  TYPED_TEST_SUITE(Int128FloatTraitsTest, FloatingPointTypes);
447  TYPED_TEST(Int128FloatTraitsTest, ConstructAssignTest) {
448    static_assert(std::is_constructible&lt;absl::int128, TypeParam&gt;::value,
449                  &quot;absl::int128 must be constructible from TypeParam&quot;);
450    static_assert(!std::is_assignable&lt;absl::int128&amp;, TypeParam&gt;::value,
451                  &quot;absl::int128 must not be assignable from TypeParam&quot;);
452    static_assert(!std::is_assignable&lt;TypeParam&amp;, absl::int128&gt;::value,
453                  &quot;TypeParam must not be assignable from absl::int128&quot;);
454  }
455  #ifdef ABSL_HAVE_INTRINSIC_INT128
456  TEST(Int128, IntrinsicTypeTraitsTest) {
457    static_assert(std::is_constructible&lt;absl::int128, __int128&gt;::value,
458                  &quot;absl::int128 must be constructible from __int128&quot;);
459    static_assert(std::is_assignable&lt;absl::int128&amp;, __int128&gt;::value,
460                  &quot;absl::int128 must be assignable from __int128&quot;);
461    static_assert(!std::is_assignable&lt;__int128&amp;, absl::int128&gt;::value,
462                  &quot;__int128 must not be assignable from absl::int128&quot;);
463    static_assert(std::is_constructible&lt;absl::int128, unsigned __int128&gt;::value,
464                  &quot;absl::int128 must be constructible from unsigned __int128&quot;);
465    static_assert(!std::is_assignable&lt;absl::int128&amp;, unsigned __int128&gt;::value,
466                  &quot;absl::int128 must be assignable from unsigned __int128&quot;);
467    static_assert(!std::is_assignable&lt;unsigned __int128&amp;, absl::int128&gt;::value,
468                  &quot;unsigned __int128 must not be assignable from absl::int128&quot;);
469  }
470  #endif  
471  TEST(Int128, TrivialTraitsTest) {
472    static_assert(absl::is_trivially_default_constructible&lt;absl::int128&gt;::value,
473                  &quot;&quot;);
474    static_assert(absl::is_trivially_copy_constructible&lt;absl::int128&gt;::value, &quot;&quot;);
475    static_assert(absl::is_trivially_copy_assignable&lt;absl::int128&gt;::value, &quot;&quot;);
476    static_assert(std::is_trivially_destructible&lt;absl::int128&gt;::value, &quot;&quot;);
477  }
478  TEST(Int128, BoolConversionTest) {
479    EXPECT_FALSE(absl::int128(0));
480    for (int i = 0; i &lt; 64; ++i) {
481      EXPECT_TRUE(absl::MakeInt128(0, uint64_t{1} &lt;&lt; i));
482    }
483    for (int i = 0; i &lt; 63; ++i) {
484      EXPECT_TRUE(absl::MakeInt128(int64_t{1} &lt;&lt; i, 0));
485    }
486    EXPECT_TRUE(absl::Int128Min());
487    EXPECT_EQ(absl::int128(1), absl::int128(true));
488    EXPECT_EQ(absl::int128(0), absl::int128(false));
489  }
490  template &lt;typename T&gt;
491  class Int128IntegerConversionTest : public ::testing::Test {};
492  TYPED_TEST_SUITE(Int128IntegerConversionTest, IntegerTypes);
493  TYPED_TEST(Int128IntegerConversionTest, RoundTripTest) {
494    EXPECT_EQ(TypeParam{0}, static_cast&lt;TypeParam&gt;(absl::int128(0)));
495    EXPECT_EQ(std::numeric_limits&lt;TypeParam&gt;::min(),
496              static_cast&lt;TypeParam&gt;(
497                  absl::int128(std::numeric_limits&lt;TypeParam&gt;::min())));
498    EXPECT_EQ(std::numeric_limits&lt;TypeParam&gt;::max(),
499              static_cast&lt;TypeParam&gt;(
500                  absl::int128(std::numeric_limits&lt;TypeParam&gt;::max())));
501  }
502  template &lt;typename T&gt;
503  class Int128FloatConversionTest : public ::testing::Test {};
504  TYPED_TEST_SUITE(Int128FloatConversionTest, FloatingPointTypes);
505  TYPED_TEST(Int128FloatConversionTest, ConstructAndCastTest) {
506    for (int i = 0; i &lt; 110; ++i) {  
507      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i);
508      TypeParam float_value = std::ldexp(static_cast&lt;TypeParam&gt;(0x9f5b), i);
509      absl::int128 int_value = absl::int128(0x9f5b) &lt;&lt; i;
510      EXPECT_EQ(float_value, static_cast&lt;TypeParam&gt;(int_value));
511      EXPECT_EQ(-float_value, static_cast&lt;TypeParam&gt;(-int_value));
512      EXPECT_EQ(int_value, absl::int128(float_value));
513      EXPECT_EQ(-int_value, absl::int128(-float_value));
514    }
515    uint64_t values[] = {0x6d4492c24fb86199, 0x26ead65e4cb359b5,
516                         0x2c43407433ba3fd1, 0x3b574ec668df6b55,
517                         0x1c750e55a29f4f0f};
518    for (uint64_t value : values) {
519      for (int i = 0; i &lt;= 64; ++i) {
520        SCOPED_TRACE(::testing::Message()
521                     &lt;&lt; &quot;value = &quot; &lt;&lt; value &lt;&lt; &quot;; i = &quot; &lt;&lt; i);
522        TypeParam fvalue = std::ldexp(static_cast&lt;TypeParam&gt;(value), i);
523        EXPECT_DOUBLE_EQ(fvalue, static_cast&lt;TypeParam&gt;(absl::int128(fvalue)));
524        EXPECT_DOUBLE_EQ(-fvalue, static_cast&lt;TypeParam&gt;(-absl::int128(fvalue)));
525        EXPECT_DOUBLE_EQ(-fvalue, static_cast&lt;TypeParam&gt;(absl::int128(-fvalue)));
526        EXPECT_DOUBLE_EQ(fvalue, static_cast&lt;TypeParam&gt;(-absl::int128(-fvalue)));
527      }
528    }
529    absl::int128 large_values[] = {
530        absl::MakeInt128(0x5b0640d96c7b3d9f, 0xb7a7189e51d18622),
531        absl::MakeInt128(0x34bed042c6f65270, 0x73b236570669a089),
532        absl::MakeInt128(0x43deba9e6da12724, 0xf7f0f83da686797d),
533        absl::MakeInt128(0x71e8d383be4e5589, 0x75c3f96fb00752b6)};
534    for (absl::int128 value : large_values) {
535      value &gt;&gt;= (127 - std::numeric_limits&lt;TypeParam&gt;::digits);
536      value |= absl::int128(1) &lt;&lt; (std::numeric_limits&lt;TypeParam&gt;::digits - 1);
537      value |= 1;
538      for (int i = 0; i &lt; 127 - std::numeric_limits&lt;TypeParam&gt;::digits; ++i) {
539        absl::int128 int_value = value &lt;&lt; i;
540        EXPECT_EQ(int_value,
541                  static_cast&lt;absl::int128&gt;(static_cast&lt;TypeParam&gt;(int_value)));
542        EXPECT_EQ(-int_value,
543                  static_cast&lt;absl::int128&gt;(static_cast&lt;TypeParam&gt;(-int_value)));
544      }
545    }
546    EXPECT_EQ(0, absl::int128(TypeParam(0.1)));
547    EXPECT_EQ(17, absl::int128(TypeParam(17.8)));
548    EXPECT_EQ(0, absl::int128(TypeParam(-0.8)));
549    EXPECT_EQ(-53, absl::int128(TypeParam(-53.1)));
550    EXPECT_EQ(0, absl::int128(TypeParam(0.5)));
551    EXPECT_EQ(0, absl::int128(TypeParam(-0.5)));
552    TypeParam just_lt_one = std::nexttoward(TypeParam(1), TypeParam(0));
553    EXPECT_EQ(0, absl::int128(just_lt_one));
554    TypeParam just_gt_minus_one = std::nexttoward(TypeParam(-1), TypeParam(0));
555    EXPECT_EQ(0, absl::int128(just_gt_minus_one));
556    EXPECT_DOUBLE_EQ(std::ldexp(static_cast&lt;TypeParam&gt;(1), 127),
557                     static_cast&lt;TypeParam&gt;(absl::Int128Max()));
558    EXPECT_DOUBLE_EQ(-std::ldexp(static_cast&lt;TypeParam&gt;(1), 127),
559                     static_cast&lt;TypeParam&gt;(absl::Int128Min()));
560  }
561  TEST(Int128, FactoryTest) {
562    EXPECT_EQ(absl::int128(-1), absl::MakeInt128(-1, -1));
563    EXPECT_EQ(absl::int128(-31), absl::MakeInt128(-1, -31));
564    EXPECT_EQ(absl::int128(std::numeric_limits&lt;int64_t&gt;::min()),
565              absl::MakeInt128(-1, std::numeric_limits&lt;int64_t&gt;::min()));
566    EXPECT_EQ(absl::int128(0), absl::MakeInt128(0, 0));
567    EXPECT_EQ(absl::int128(1), absl::MakeInt128(0, 1));
568    EXPECT_EQ(absl::int128(std::numeric_limits&lt;int64_t&gt;::max()),
569              absl::MakeInt128(0, std::numeric_limits&lt;int64_t&gt;::max()));
570  }
571  TEST(Int128, HighLowTest) {
572    struct HighLowPair {
573      int64_t high;
574      uint64_t low;
575    };
576    HighLowPair values[]{{0, 0}, {0, 1}, {1, 0}, {123, 456}, {-654, 321}};
577    for (const HighLowPair&amp; pair : values) {
578      absl::int128 value = absl::MakeInt128(pair.high, pair.low);
579      EXPECT_EQ(pair.low, absl::Int128Low64(value));
580      EXPECT_EQ(pair.high, absl::Int128High64(value));
581    }
582  }
583  TEST(Int128, LimitsTest) {
584    EXPECT_EQ(absl::MakeInt128(0x7fffffffffffffff, 0xffffffffffffffff),
585              absl::Int128Max());
586    EXPECT_EQ(absl::Int128Max(), ~absl::Int128Min());
587  }
588  #if defined(ABSL_HAVE_INTRINSIC_INT128)
589  TEST(Int128, IntrinsicConversionTest) {
590    __int128 intrinsic =
591        (static_cast&lt;__int128&gt;(0x3a5b76c209de76f6) &lt;&lt; 64) + 0x1f25e1d63a2b46c5;
592    absl::int128 custom =
593        absl::MakeInt128(0x3a5b76c209de76f6, 0x1f25e1d63a2b46c5);
594    EXPECT_EQ(custom, absl::int128(intrinsic));
595    EXPECT_EQ(intrinsic, static_cast&lt;__int128&gt;(custom));
596  }
597  #endif  
598  TEST(Int128, ConstexprTest) {
599    constexpr absl::int128 zero = absl::int128();
600    constexpr absl::int128 one = 1;
601    constexpr absl::int128 minus_two = -2;
602    constexpr absl::int128 min = absl::Int128Min();
603    constexpr absl::int128 max = absl::Int128Max();
604    EXPECT_EQ(zero, absl::int128(0));
605    EXPECT_EQ(one, absl::int128(1));
606    EXPECT_EQ(minus_two, absl::MakeInt128(-1, -2));
607    EXPECT_GT(max, one);
608    EXPECT_LT(min, minus_two);
609  }
610  TEST(Int128, ComparisonTest) {
611    struct TestCase {
612      absl::int128 smaller;
613      absl::int128 larger;
614    };
615    TestCase cases[] = {
616        {absl::int128(0), absl::int128(123)},
617        {absl::MakeInt128(-12, 34), absl::MakeInt128(12, 34)},
618        {absl::MakeInt128(1, 1000), absl::MakeInt128(1000, 1)},
619        {absl::MakeInt128(-1000, 1000), absl::MakeInt128(-1, 1)},
620    };
621    for (const TestCase&amp; pair : cases) {
622      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;pair.smaller = &quot; &lt;&lt; pair.smaller
623                                        &lt;&lt; &quot;; pair.larger = &quot; &lt;&lt; pair.larger);
624      EXPECT_TRUE(pair.smaller == pair.smaller);  
625      EXPECT_TRUE(pair.larger == pair.larger);    
626      EXPECT_FALSE(pair.smaller == pair.larger);  
627      EXPECT_TRUE(pair.smaller != pair.larger);    
628      EXPECT_FALSE(pair.smaller != pair.smaller);  
629      EXPECT_FALSE(pair.larger != pair.larger);    
630      EXPECT_TRUE(pair.smaller &lt; pair.larger);   
631      EXPECT_FALSE(pair.larger &lt; pair.smaller);  
632      EXPECT_TRUE(pair.larger &gt; pair.smaller);   
633      EXPECT_FALSE(pair.smaller &gt; pair.larger);  
634      EXPECT_TRUE(pair.smaller &lt;= pair.larger);   
635      EXPECT_FALSE(pair.larger &lt;= pair.smaller);  
636      EXPECT_TRUE(pair.smaller &lt;= pair.smaller);  
637      EXPECT_TRUE(pair.larger &lt;= pair.larger);    
638      EXPECT_TRUE(pair.larger &gt;= pair.smaller);   
639      EXPECT_FALSE(pair.smaller &gt;= pair.larger);  
640      EXPECT_TRUE(pair.smaller &gt;= pair.smaller);  
641      EXPECT_TRUE(pair.larger &gt;= pair.larger);    
642    }
643  }
644  TEST(Int128, UnaryPlusTest) {
645    int64_t values64[] = {0, 1, 12345, 0x4000000000000000,
646                          std::numeric_limits&lt;int64_t&gt;::max()};
647    for (int64_t value : values64) {
648      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;value = &quot; &lt;&lt; value);
649      EXPECT_EQ(absl::int128(value), +absl::int128(value));
650      EXPECT_EQ(absl::int128(-value), +absl::int128(-value));
651      EXPECT_EQ(absl::MakeInt128(value, 0), +absl::MakeInt128(value, 0));
652      EXPECT_EQ(absl::MakeInt128(-value, 0), +absl::MakeInt128(-value, 0));
653    }
654  }
655  TEST(Int128, UnaryNegationTest) {
656    int64_t values64[] = {0, 1, 12345, 0x4000000000000000,
657                          std::numeric_limits&lt;int64_t&gt;::max()};
658    for (int64_t value : values64) {
<span onclick='openModal()' class='match'>659      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;value = &quot; &lt;&lt; value);
660      EXPECT_EQ(absl::int128(-value), -absl::int128(value));
</span>661      EXPECT_EQ(absl::int128(value), -absl::int128(-value));
662      EXPECT_EQ(absl::MakeInt128(-value, 0), -absl::MakeInt128(value, 0));
663      EXPECT_EQ(absl::MakeInt128(value, 0), -absl::MakeInt128(-value, 0));
664    }
665  }
666  TEST(Int128, LogicalNotTest) {
667    EXPECT_TRUE(!absl::int128(0));
668    for (int i = 0; i &lt; 64; ++i) {
669      EXPECT_FALSE(!absl::MakeInt128(0, uint64_t{1} &lt;&lt; i));
670    }
671    for (int i = 0; i &lt; 63; ++i) {
672      EXPECT_FALSE(!absl::MakeInt128(int64_t{1} &lt;&lt; i, 0));
673    }
674  }
675  TEST(Int128, AdditionSubtractionTest) {
676    std::pair&lt;int64_t, int64_t&gt; cases[]{
677        {0, 0},                              
678        {0, 2945781290834},                  
679        {1908357619234, 0},                  
680        {0, -1204895918245},                 
681        {-2957928523560, 0},                 
682        {89023982312461, 98346012567134},    
683        {-63454234568239, -23456235230773},  
684        {98263457263502, -21428561935925},   
685        {-88235237438467, 15923659234573},   
686    };
687    for (const auto&amp; pair : cases) {
688      SCOPED_TRACE(::testing::Message()
689                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
690      EXPECT_EQ(absl::int128(pair.first + pair.second),
691                absl::int128(pair.first) + absl::int128(pair.second));
692      EXPECT_EQ(absl::int128(pair.second + pair.first),
693                absl::int128(pair.second) += absl::int128(pair.first));
694      EXPECT_EQ(absl::int128(pair.first - pair.second),
695                absl::int128(pair.first) - absl::int128(pair.second));
696      EXPECT_EQ(absl::int128(pair.second - pair.first),
697                absl::int128(pair.second) -= absl::int128(pair.first));
698      EXPECT_EQ(
699          absl::MakeInt128(pair.second + pair.first, 0),
700          absl::MakeInt128(pair.second, 0) + absl::MakeInt128(pair.first, 0));
701      EXPECT_EQ(
702          absl::MakeInt128(pair.first + pair.second, 0),
703          absl::MakeInt128(pair.first, 0) += absl::MakeInt128(pair.second, 0));
704      EXPECT_EQ(
705          absl::MakeInt128(pair.second - pair.first, 0),
706          absl::MakeInt128(pair.second, 0) - absl::MakeInt128(pair.first, 0));
707      EXPECT_EQ(
708          absl::MakeInt128(pair.first - pair.second, 0),
709          absl::MakeInt128(pair.first, 0) -= absl::MakeInt128(pair.second, 0));
710    }
711    EXPECT_EQ(absl::MakeInt128(31, 0),
712              absl::MakeInt128(20, 1) +
713                  absl::MakeInt128(10, std::numeric_limits&lt;uint64_t&gt;::max()));
714  }
715  TEST(Int128, IncrementDecrementTest) {
716    absl::int128 value = 0;
717    EXPECT_EQ(0, value++);
718    EXPECT_EQ(1, value);
719    EXPECT_EQ(1, value--);
720    EXPECT_EQ(0, value);
721    EXPECT_EQ(-1, --value);
722    EXPECT_EQ(-1, value);
723    EXPECT_EQ(0, ++value);
724    EXPECT_EQ(0, value);
725  }
726  TEST(Int128, MultiplicationTest) {
727    for (int i = 0; i &lt; 64; ++i) {
728      for (int j = 0; j &lt; 127 - i; ++j) {
729        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
730        absl::int128 a = absl::int128(1) &lt;&lt; i;
731        absl::int128 b = absl::int128(1) &lt;&lt; j;
732        absl::int128 c = absl::int128(1) &lt;&lt; (i + j);
733        EXPECT_EQ(c, a * b);
734        EXPECT_EQ(-c, -a * b);
735        EXPECT_EQ(-c, a * -b);
736        EXPECT_EQ(c, -a * -b);
737        EXPECT_EQ(c, absl::int128(a) *= b);
738        EXPECT_EQ(-c, absl::int128(-a) *= b);
739        EXPECT_EQ(-c, absl::int128(a) *= -b);
740        EXPECT_EQ(c, absl::int128(-a) *= -b);
741      }
742    }
743    std::pair&lt;int64_t, int64_t&gt; small_values[] = {
744        {0x5e61, 0xf29f79ca14b4},    
745        {0x3e033b, -0x612c0ee549},   
746        {-0x052ce7e8, 0x7c728f0f},   
747        {-0x3af7054626, -0xfb1e1d},  
748    };
749    for (const std::pair&lt;int64_t, int64_t&gt;&amp; pair : small_values) {
750      SCOPED_TRACE(::testing::Message()
751                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
752      EXPECT_EQ(absl::int128(pair.first * pair.second),
753                absl::int128(pair.first) * absl::int128(pair.second));
754      EXPECT_EQ(absl::int128(pair.first * pair.second),
755                absl::int128(pair.first) *= absl::int128(pair.second));
756      EXPECT_EQ(absl::MakeInt128(pair.first * pair.second, 0),
757                absl::MakeInt128(pair.first, 0) * absl::int128(pair.second));
758      EXPECT_EQ(absl::MakeInt128(pair.first * pair.second, 0),
759                absl::MakeInt128(pair.first, 0) *= absl::int128(pair.second));
760    }
761    std::pair&lt;int64_t, int64_t&gt; small_values2[] = {
762        {0x1bb0a110, 0x31487671},
763        {0x4792784e, 0x28add7d7},
764        {0x7b66553a, 0x11dff8ef},
765    };
766    for (const std::pair&lt;int64_t, int64_t&gt;&amp; pair : small_values2) {
767      SCOPED_TRACE(::testing::Message()
768                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
769      absl::int128 a = absl::int128(pair.first &lt;&lt; 32);
770      absl::int128 b = absl::int128(pair.second &lt;&lt; 32);
771      absl::int128 c = absl::MakeInt128(pair.first * pair.second, 0);
772      EXPECT_EQ(c, a * b);
773      EXPECT_EQ(-c, -a * b);
774      EXPECT_EQ(-c, a * -b);
775      EXPECT_EQ(c, -a * -b);
776      EXPECT_EQ(c, absl::int128(a) *= b);
777      EXPECT_EQ(-c, absl::int128(-a) *= b);
778      EXPECT_EQ(-c, absl::int128(a) *= -b);
779      EXPECT_EQ(c, absl::int128(-a) *= -b);
780    }
781    absl::int128 large_values[] = {
782        {absl::MakeInt128(0xd66f061af02d0408, 0x727d2846cb475b53)},
783        {absl::MakeInt128(0x27b8d5ed6104452d, 0x03f8a33b0ee1df4f)},
784        {-absl::MakeInt128(0x621b6626b9e8d042, 0x27311ac99df00938)},
785        {-absl::MakeInt128(0x34e0656f1e95fb60, 0x4281cfd731257a47)},
786    };
787    for (absl::int128 value : large_values) {
788      EXPECT_EQ(0, 0 * value);
789      EXPECT_EQ(0, value * 0);
790      EXPECT_EQ(0, absl::int128(0) *= value);
791      EXPECT_EQ(0, value *= 0);
792      EXPECT_EQ(value, 1 * value);
793      EXPECT_EQ(value, value * 1);
794      EXPECT_EQ(value, absl::int128(1) *= value);
795      EXPECT_EQ(value, value *= 1);
796      EXPECT_EQ(-value, -1 * value);
797      EXPECT_EQ(-value, value * -1);
798      EXPECT_EQ(-value, absl::int128(-1) *= value);
799      EXPECT_EQ(-value, value *= -1);
800    }
801    EXPECT_EQ(absl::MakeInt128(0xcd0efd3442219bb, 0xde47c05bcd9df6e1),
802              absl::MakeInt128(0x7c6448, 0x3bc4285c47a9d253) * 0x1a6037537b);
803    EXPECT_EQ(-absl::MakeInt128(0x1f8f149850b1e5e6, 0x1e50d6b52d272c3e),
804              -absl::MakeInt128(0x23, 0x2e68a513ca1b8859) * 0xe5a434cd14866e);
805    EXPECT_EQ(-absl::MakeInt128(0x55cae732029d1fce, 0xca6474b6423263e4),
806              0xa9b98a8ddf66bc * -absl::MakeInt128(0x81, 0x672e58231e2469d7));
807    EXPECT_EQ(absl::MakeInt128(0x19c8b7620b507dc4, 0xfec042b71a5f29a4),
808              -0x3e39341147 * -absl::MakeInt128(0x6a14b2, 0x5ed34cca42327b3c));
809    EXPECT_EQ(absl::MakeInt128(0xcd0efd3442219bb, 0xde47c05bcd9df6e1),
810              absl::MakeInt128(0x7c6448, 0x3bc4285c47a9d253) *= 0x1a6037537b);
811    EXPECT_EQ(-absl::MakeInt128(0x1f8f149850b1e5e6, 0x1e50d6b52d272c3e),
812              -absl::MakeInt128(0x23, 0x2e68a513ca1b8859) *= 0xe5a434cd14866e);
813    EXPECT_EQ(-absl::MakeInt128(0x55cae732029d1fce, 0xca6474b6423263e4),
814              absl::int128(0xa9b98a8ddf66bc) *=
815              -absl::MakeInt128(0x81, 0x672e58231e2469d7));
816    EXPECT_EQ(absl::MakeInt128(0x19c8b7620b507dc4, 0xfec042b71a5f29a4),
817              absl::int128(-0x3e39341147) *=
818              -absl::MakeInt128(0x6a14b2, 0x5ed34cca42327b3c));
819  }
820  TEST(Int128, DivisionAndModuloTest) {
821    std::pair&lt;int64_t, int64_t&gt; small_pairs[] = {
822        {0x15f2a64138, 0x67da05},    {0x5e56d194af43045f, 0xcf1543fb99},
823        {0x15e61ed052036a, -0xc8e6}, {0x88125a341e85, -0xd23fb77683},
824        {-0xc06e20, 0x5a},           {-0x4f100219aea3e85d, 0xdcc56cb4efe993},
825        {-0x168d629105, -0xa7},      {-0x7b44e92f03ab2375, -0x6516},
826    };
827    for (const std::pair&lt;int64_t, int64_t&gt;&amp; pair : small_pairs) {
828      SCOPED_TRACE(::testing::Message()
829                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
830      absl::int128 dividend = pair.first;
831      absl::int128 divisor = pair.second;
832      int64_t quotient = pair.first / pair.second;
833      int64_t remainder = pair.first % pair.second;
834      EXPECT_EQ(quotient, dividend / divisor);
835      EXPECT_EQ(quotient, absl::int128(dividend) /= divisor);
836      EXPECT_EQ(remainder, dividend % divisor);
837      EXPECT_EQ(remainder, absl::int128(dividend) %= divisor);
838    }
839    absl::int128 values[] = {
840        absl::MakeInt128(0x63d26ee688a962b2, 0x9e1411abda5c1d70),
841        absl::MakeInt128(0x152f385159d6f986, 0xbf8d48ef63da395d),
842        -absl::MakeInt128(0x3098d7567030038c, 0x14e7a8a098dc2164),
843        -absl::MakeInt128(0x49a037aca35c809f, 0xa6a87525480ef330),
844    };
845    for (absl::int128 value : values) {
846      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;value = &quot; &lt;&lt; value);
847      EXPECT_EQ(0, 0 / value);
848      EXPECT_EQ(0, absl::int128(0) /= value);
849      EXPECT_EQ(0, 0 % value);
850      EXPECT_EQ(0, absl::int128(0) %= value);
851      EXPECT_EQ(value, value / 1);
852      EXPECT_EQ(value, absl::int128(value) /= 1);
853      EXPECT_EQ(0, value % 1);
854      EXPECT_EQ(0, absl::int128(value) %= 1);
855      EXPECT_EQ(-value, value / -1);
856      EXPECT_EQ(-value, absl::int128(value) /= -1);
857      EXPECT_EQ(0, value % -1);
858      EXPECT_EQ(0, absl::int128(value) %= -1);
859    }
860    EXPECT_EQ(0, absl::Int128Max() / absl::Int128Min());
861    EXPECT_EQ(absl::Int128Max(), absl::Int128Max() % absl::Int128Min());
862    EXPECT_EQ(-1, absl::Int128Min() / absl::Int128Max());
863    EXPECT_EQ(-1, absl::Int128Min() % absl::Int128Max());
864    absl::int128 positive_values[] = {
865        absl::MakeInt128(0x21e1a1cc69574620, 0xe7ac447fab2fc869),
866        absl::MakeInt128(0x32c2ff3ab89e66e8, 0x03379a613fd1ce74),
867        absl::MakeInt128(0x6f32ca786184dcaf, 0x046f9c9ecb3a9ce1),
868        absl::MakeInt128(0x1aeb469dd990e0ee, 0xda2740f243cd37eb),
869    };
870    for (absl::int128 value : positive_values) {
871      for (int i = 0; i &lt; 127; ++i) {
872        SCOPED_TRACE(::testing::Message()
873                     &lt;&lt; &quot;value = &quot; &lt;&lt; value &lt;&lt; &quot;; i = &quot; &lt;&lt; i);
874        absl::int128 power_of_two = absl::int128(1) &lt;&lt; i;
875        EXPECT_EQ(value &gt;&gt; i, value / power_of_two);
876        EXPECT_EQ(value &gt;&gt; i, absl::int128(value) /= power_of_two);
877        EXPECT_EQ(value &amp; (power_of_two - 1), value % power_of_two);
878        EXPECT_EQ(value &amp; (power_of_two - 1),
879                  absl::int128(value) %= power_of_two);
880      }
881    }
882    struct DivisionModCase {
883      absl::int128 dividend;
884      absl::int128 divisor;
885      absl::int128 quotient;
886      absl::int128 remainder;
887    };
888    DivisionModCase manual_cases[] = {
889        {absl::MakeInt128(0x6ada48d489007966, 0x3c9c5c98150d5d69),
890         absl::MakeInt128(0x8bc308fb, 0x8cb9cc9a3b803344), 0xc3b87e08,
891         absl::MakeInt128(0x1b7db5e1, 0xd9eca34b7af04b49)},
892        {absl::MakeInt128(0xd6946511b5b, 0x4886c5c96546bf5f),
893         -absl::MakeInt128(0x263b, 0xfd516279efcfe2dc), -0x59cbabf0,
894         absl::MakeInt128(0x622, 0xf462909155651d1f)},
895        {-absl::MakeInt128(0x33db734f9e8d1399, 0x8447ac92482bca4d), 0x37495078240,
896         -absl::MakeInt128(0xf01f1, 0xbc0368bf9a77eae8), -0x21a508f404d},
897        {-absl::MakeInt128(0x13f837b409a07e7d, 0x7fc8e248a7d73560), -0x1b9f,
898         absl::MakeInt128(0xb9157556d724, 0xb14f635714d7563e), -0x1ade},
899    };
900    for (const DivisionModCase test_case : manual_cases) {
901      EXPECT_EQ(test_case.quotient, test_case.dividend / test_case.divisor);
902      EXPECT_EQ(test_case.quotient,
903                absl::int128(test_case.dividend) /= test_case.divisor);
904      EXPECT_EQ(test_case.remainder, test_case.dividend % test_case.divisor);
905      EXPECT_EQ(test_case.remainder,
906                absl::int128(test_case.dividend) %= test_case.divisor);
907    }
908  }
909  TEST(Int128, BitwiseLogicTest) {
910    EXPECT_EQ(absl::int128(-1), ~absl::int128(0));
911    absl::int128 values[]{
912        0, -1, 0xde400bee05c3ff6b, absl::MakeInt128(0x7f32178dd81d634a, 0),
913        absl::MakeInt128(0xaf539057055613a9, 0x7d104d7d946c2e4d)};
914    for (absl::int128 value : values) {
915      EXPECT_EQ(value, ~~value);
916      EXPECT_EQ(value, value | value);
917      EXPECT_EQ(value, value &amp; value);
918      EXPECT_EQ(0, value ^ value);
919      EXPECT_EQ(value, absl::int128(value) |= value);
920      EXPECT_EQ(value, absl::int128(value) &amp;= value);
921      EXPECT_EQ(0, absl::int128(value) ^= value);
922      EXPECT_EQ(value, value | 0);
923      EXPECT_EQ(0, value &amp; 0);
924      EXPECT_EQ(value, value ^ 0);
925      EXPECT_EQ(absl::int128(-1), value | absl::int128(-1));
926      EXPECT_EQ(value, value &amp; absl::int128(-1));
927      EXPECT_EQ(~value, value ^ absl::int128(-1));
928    }
929    std::pair&lt;int64_t, int64_t&gt; pairs64[]{
930        {0x7f86797f5e991af4, 0x1ee30494fb007c97},
931        {0x0b278282bacf01af, 0x58780e0a57a49e86},
932        {0x059f266ccb93a666, 0x3d5b731bae9286f5},
933        {0x63c0c4820f12108c, 0x58166713c12e1c3a},
934        {0x381488bb2ed2a66e, 0x2220a3eb76a3698c},
935        {0x2a0a0dfb81e06f21, 0x4b60585927f5523c},
936        {0x555b1c3a03698537, 0x25478cd19d8e53cb},
937        {0x4750f6f27d779225, 0x16397553c6ff05fc},
938    };
939    for (const std::pair&lt;int64_t, int64_t&gt;&amp; pair : pairs64) {
940      SCOPED_TRACE(::testing::Message()
941                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
942      EXPECT_EQ(absl::MakeInt128(~pair.first, ~pair.second),
943                ~absl::MakeInt128(pair.first, pair.second));
944      EXPECT_EQ(absl::int128(pair.first &amp; pair.second),
945                absl::int128(pair.first) &amp; absl::int128(pair.second));
946      EXPECT_EQ(absl::int128(pair.first | pair.second),
947                absl::int128(pair.first) | absl::int128(pair.second));
948      EXPECT_EQ(absl::int128(pair.first ^ pair.second),
949                absl::int128(pair.first) ^ absl::int128(pair.second));
950      EXPECT_EQ(absl::int128(pair.first &amp; pair.second),
951                absl::int128(pair.first) &amp;= absl::int128(pair.second));
952      EXPECT_EQ(absl::int128(pair.first | pair.second),
953                absl::int128(pair.first) |= absl::int128(pair.second));
954      EXPECT_EQ(absl::int128(pair.first ^ pair.second),
955                absl::int128(pair.first) ^= absl::int128(pair.second));
956      EXPECT_EQ(
957          absl::MakeInt128(pair.first &amp; pair.second, 0),
958          absl::MakeInt128(pair.first, 0) &amp; absl::MakeInt128(pair.second, 0));
959      EXPECT_EQ(
960          absl::MakeInt128(pair.first | pair.second, 0),
961          absl::MakeInt128(pair.first, 0) | absl::MakeInt128(pair.second, 0));
962      EXPECT_EQ(
963          absl::MakeInt128(pair.first ^ pair.second, 0),
964          absl::MakeInt128(pair.first, 0) ^ absl::MakeInt128(pair.second, 0));
965      EXPECT_EQ(
966          absl::MakeInt128(pair.first &amp; pair.second, 0),
967          absl::MakeInt128(pair.first, 0) &amp;= absl::MakeInt128(pair.second, 0));
968      EXPECT_EQ(
969          absl::MakeInt128(pair.first | pair.second, 0),
970          absl::MakeInt128(pair.first, 0) |= absl::MakeInt128(pair.second, 0));
971      EXPECT_EQ(
972          absl::MakeInt128(pair.first ^ pair.second, 0),
973          absl::MakeInt128(pair.first, 0) ^= absl::MakeInt128(pair.second, 0));
974    }
975  }
976  TEST(Int128, BitwiseShiftTest) {
977    for (int i = 0; i &lt; 64; ++i) {
978      for (int j = 0; j &lt;= i; ++j) {
979        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
980        EXPECT_EQ(uint64_t{1} &lt;&lt; i, absl::int128(uint64_t{1} &lt;&lt; j) &lt;&lt; (i - j));
981        EXPECT_EQ(uint64_t{1} &lt;&lt; i, absl::int128(uint64_t{1} &lt;&lt; j) &lt;&lt;= (i - j));
982      }
983    }
984    for (int i = 0; i &lt; 63; ++i) {
985      for (int j = 0; j &lt; 64; ++j) {
986        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
987        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
988                  absl::int128(uint64_t{1} &lt;&lt; j) &lt;&lt; (i + 64 - j));
989        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
990                  absl::int128(uint64_t{1} &lt;&lt; j) &lt;&lt;= (i + 64 - j));
991      }
992      for (int j = 0; j &lt;= i; ++j) {
993        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
994        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
995                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &lt;&lt; (i - j));
996        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
997                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &lt;&lt;= (i - j));
998      }
999    }
1000    for (int i = 0; i &lt; 64; ++i) {
1001      for (int j = i; j &lt; 64; ++j) {
1002        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
1003        EXPECT_EQ(uint64_t{1} &lt;&lt; i, absl::int128(uint64_t{1} &lt;&lt; j) &gt;&gt; (j - i));
1004        EXPECT_EQ(uint64_t{1} &lt;&lt; i, absl::int128(uint64_t{1} &lt;&lt; j) &gt;&gt;= (j - i));
1005      }
1006      for (int j = 0; j &lt; 63; ++j) {
1007        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
1008        EXPECT_EQ(uint64_t{1} &lt;&lt; i,
1009                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &gt;&gt; (j + 64 - i));
1010        EXPECT_EQ(uint64_t{1} &lt;&lt; i,
1011                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &gt;&gt;= (j + 64 - i));
1012      }
1013    }
1014    for (int i = 0; i &lt; 63; ++i) {
1015      for (int j = i; j &lt; 63; ++j) {
1016        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
1017        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
1018                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &gt;&gt; (j - i));
1019        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
1020                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &gt;&gt;= (j - i));
1021      }
1022    }
1023    absl::int128 val1 = MAKE_INT128(0x123456789abcdef0, 0x123456789abcdef0);
1024    absl::int128 val2 = MAKE_INT128(0xfedcba0987654321, 0xfedcba0987654321);
1025    EXPECT_EQ(val1 &lt;&lt; 63, MAKE_INT128(0x91a2b3c4d5e6f78, 0x0));
1026    EXPECT_EQ(val1 &lt;&lt; 64, MAKE_INT128(0x123456789abcdef0, 0x0));
1027    EXPECT_EQ(val2 &lt;&lt; 63, MAKE_INT128(0xff6e5d04c3b2a190, 0x8000000000000000));
1028    EXPECT_EQ(val2 &lt;&lt; 64, MAKE_INT128(0xfedcba0987654321, 0x0));
1029    EXPECT_EQ(val1 &lt;&lt; 126, MAKE_INT128(0x0, 0x0));
1030    EXPECT_EQ(val2 &lt;&lt; 126, MAKE_INT128(0x4000000000000000, 0x0));
1031    EXPECT_EQ(val1 &gt;&gt; 63, MAKE_INT128(0x0, 0x2468acf13579bde0));
1032    EXPECT_EQ(val1 &gt;&gt; 64, MAKE_INT128(0x0, 0x123456789abcdef0));
1033    EXPECT_EQ(val2 &gt;&gt; 63, MAKE_INT128(0xffffffffffffffff, 0xfdb974130eca8643));
1034    EXPECT_EQ(val2 &gt;&gt; 64, MAKE_INT128(0xffffffffffffffff, 0xfedcba0987654321));
1035    EXPECT_EQ(val1 &gt;&gt; 126, MAKE_INT128(0x0, 0x0));
1036    EXPECT_EQ(val2 &gt;&gt; 126, MAKE_INT128(0xffffffffffffffff, 0xffffffffffffffff));
1037  }
1038  TEST(Int128, NumericLimitsTest) {
1039    static_assert(std::numeric_limits&lt;absl::int128&gt;::is_specialized, &quot;&quot;);
1040    static_assert(std::numeric_limits&lt;absl::int128&gt;::is_signed, &quot;&quot;);
1041    static_assert(std::numeric_limits&lt;absl::int128&gt;::is_integer, &quot;&quot;);
1042    EXPECT_EQ(static_cast&lt;int&gt;(127 * std::log10(2)),
1043              std::numeric_limits&lt;absl::int128&gt;::digits10);
1044    EXPECT_EQ(absl::Int128Min(), std::numeric_limits&lt;absl::int128&gt;::min());
1045    EXPECT_EQ(absl::Int128Min(), std::numeric_limits&lt;absl::int128&gt;::lowest());
1046    EXPECT_EQ(absl::Int128Max(), std::numeric_limits&lt;absl::int128&gt;::max());
1047  }
1048  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-int128_test.cc</h3>
            <pre><code>1  #include &quot;absl/numeric/int128.h&quot;
2  #include &lt;algorithm&gt;
3  #include &lt;limits&gt;
4  #include &lt;random&gt;
5  #include &lt;type_traits&gt;
6  #include &lt;utility&gt;
7  #include &lt;vector&gt;
8  #include &quot;gtest/gtest.h&quot;
9  #include &quot;absl/base/internal/cycleclock.h&quot;
10  #include &quot;absl/hash/hash_testing.h&quot;
11  #include &quot;absl/meta/type_traits.h&quot;
12  #if defined(_MSC_VER) &amp;&amp; _MSC_VER == 1900
13  #pragma warning(disable:4146)
14  #endif
15  #define MAKE_INT128(HI, LO) absl::MakeInt128(static_cast&lt;int64_t&gt;(HI), LO)
16  namespace {
17  template &lt;typename T&gt;
18  class Uint128IntegerTraitsTest : public ::testing::Test {};
19  typedef ::testing::Types&lt;bool, char, signed char, unsigned char, char16_t,
20                           char32_t, wchar_t,
21                           short,           
22                           unsigned short,  
23                           int, unsigned int,
24                           long,                
25                           unsigned long,       
26                           long long,           
27                           unsigned long long&gt;  
28      IntegerTypes;
29  template &lt;typename T&gt;
30  class Uint128FloatTraitsTest : public ::testing::Test {};
31  typedef ::testing::Types&lt;float, double, long double&gt; FloatingPointTypes;
32  TYPED_TEST_SUITE(Uint128IntegerTraitsTest, IntegerTypes);
33  TYPED_TEST(Uint128IntegerTraitsTest, ConstructAssignTest) {
34    static_assert(std::is_constructible&lt;absl::uint128, TypeParam&gt;::value,
35                  &quot;absl::uint128 must be constructible from TypeParam&quot;);
36    static_assert(std::is_assignable&lt;absl::uint128&amp;, TypeParam&gt;::value,
37                  &quot;absl::uint128 must be assignable from TypeParam&quot;);
38    static_assert(!std::is_assignable&lt;TypeParam&amp;, absl::uint128&gt;::value,
39                  &quot;TypeParam must not be assignable from absl::uint128&quot;);
40  }
41  TYPED_TEST_SUITE(Uint128FloatTraitsTest, FloatingPointTypes);
42  TYPED_TEST(Uint128FloatTraitsTest, ConstructAssignTest) {
43    static_assert(std::is_constructible&lt;absl::uint128, TypeParam&gt;::value,
44                  &quot;absl::uint128 must be constructible from TypeParam&quot;);
45    static_assert(!std::is_assignable&lt;absl::uint128&amp;, TypeParam&gt;::value,
46                  &quot;absl::uint128 must not be assignable from TypeParam&quot;);
47    static_assert(!std::is_assignable&lt;TypeParam&amp;, absl::uint128&gt;::value,
48                  &quot;TypeParam must not be assignable from absl::uint128&quot;);
49  }
50  #ifdef ABSL_HAVE_INTRINSIC_INT128
51  TEST(Uint128, IntrinsicTypeTraitsTest) {
52    static_assert(std::is_constructible&lt;absl::uint128, __int128&gt;::value,
53                  &quot;absl::uint128 must be constructible from __int128&quot;);
54    static_assert(std::is_assignable&lt;absl::uint128&amp;, __int128&gt;::value,
55                  &quot;absl::uint128 must be assignable from __int128&quot;);
56    static_assert(!std::is_assignable&lt;__int128&amp;, absl::uint128&gt;::value,
57                  &quot;__int128 must not be assignable from absl::uint128&quot;);
58    static_assert(std::is_constructible&lt;absl::uint128, unsigned __int128&gt;::value,
59                  &quot;absl::uint128 must be constructible from unsigned __int128&quot;);
60    static_assert(std::is_assignable&lt;absl::uint128&amp;, unsigned __int128&gt;::value,
61                  &quot;absl::uint128 must be assignable from unsigned __int128&quot;);
62    static_assert(!std::is_assignable&lt;unsigned __int128&amp;, absl::uint128&gt;::value,
63                  &quot;unsigned __int128 must not be assignable from absl::uint128&quot;);
64  }
65  #endif  
66  TEST(Uint128, TrivialTraitsTest) {
67    static_assert(absl::is_trivially_default_constructible&lt;absl::uint128&gt;::value,
68                  &quot;&quot;);
69    static_assert(absl::is_trivially_copy_constructible&lt;absl::uint128&gt;::value,
70                  &quot;&quot;);
71    static_assert(absl::is_trivially_copy_assignable&lt;absl::uint128&gt;::value, &quot;&quot;);
72    static_assert(std::is_trivially_destructible&lt;absl::uint128&gt;::value, &quot;&quot;);
73  }
74  TEST(Uint128, AllTests) {
75    absl::uint128 zero = 0;
76    absl::uint128 one = 1;
77    absl::uint128 one_2arg = absl::MakeUint128(0, 1);
78    absl::uint128 two = 2;
79    absl::uint128 three = 3;
80    absl::uint128 big = absl::MakeUint128(2000, 2);
81    absl::uint128 big_minus_one = absl::MakeUint128(2000, 1);
82    absl::uint128 bigger = absl::MakeUint128(2001, 1);
83    absl::uint128 biggest = absl::Uint128Max();
84    absl::uint128 high_low = absl::MakeUint128(1, 0);
85    absl::uint128 low_high =
86        absl::MakeUint128(0, std::numeric_limits&lt;uint64_t&gt;::max());
87    EXPECT_LT(one, two);
88    EXPECT_GT(two, one);
89    EXPECT_LT(one, big);
90    EXPECT_LT(one, big);
91    EXPECT_EQ(one, one_2arg);
92    EXPECT_NE(one, two);
93    EXPECT_GT(big, one);
94    EXPECT_GE(big, two);
95    EXPECT_GE(big, big_minus_one);
96    EXPECT_GT(big, big_minus_one);
97    EXPECT_LT(big_minus_one, big);
98    EXPECT_LE(big_minus_one, big);
99    EXPECT_NE(big_minus_one, big);
100    EXPECT_LT(big, biggest);
101    EXPECT_LE(big, biggest);
102    EXPECT_GT(biggest, big);
103    EXPECT_GE(biggest, big);
104    EXPECT_EQ(big, ~~big);
105    EXPECT_EQ(one, one | one);
106    EXPECT_EQ(big, big | big);
107    EXPECT_EQ(one, one | zero);
108    EXPECT_EQ(one, one &amp; one);
109    EXPECT_EQ(big, big &amp; big);
110    EXPECT_EQ(zero, one &amp; zero);
111    EXPECT_EQ(zero, big &amp; ~big);
112    EXPECT_EQ(zero, one ^ one);
113    EXPECT_EQ(zero, big ^ big);
114    EXPECT_EQ(one, one ^ zero);
115    EXPECT_EQ(big, big &lt;&lt; 0);
116    EXPECT_EQ(big, big &gt;&gt; 0);
117    EXPECT_GT(big &lt;&lt; 1, big);
118    EXPECT_LT(big &gt;&gt; 1, big);
119    EXPECT_EQ(big, (big &lt;&lt; 10) &gt;&gt; 10);
120    EXPECT_EQ(big, (big &gt;&gt; 1) &lt;&lt; 1);
121    EXPECT_EQ(one, (one &lt;&lt; 80) &gt;&gt; 80);
122    EXPECT_EQ(zero, (one &gt;&gt; 80) &lt;&lt; 80);
123    absl::uint128 big_copy = big;
124    EXPECT_EQ(big &lt;&lt; 0, big_copy &lt;&lt;= 0);
125    big_copy = big;
126    EXPECT_EQ(big &gt;&gt; 0, big_copy &gt;&gt;= 0);
127    big_copy = big;
128    EXPECT_EQ(big &lt;&lt; 1, big_copy &lt;&lt;= 1);
129    big_copy = big;
130    EXPECT_EQ(big &gt;&gt; 1, big_copy &gt;&gt;= 1);
131    big_copy = big;
132    EXPECT_EQ(big &lt;&lt; 10, big_copy &lt;&lt;= 10);
133    big_copy = big;
134    EXPECT_EQ(big &gt;&gt; 10, big_copy &gt;&gt;= 10);
135    big_copy = big;
136    EXPECT_EQ(big &lt;&lt; 64, big_copy &lt;&lt;= 64);
137    big_copy = big;
138    EXPECT_EQ(big &gt;&gt; 64, big_copy &gt;&gt;= 64);
139    big_copy = big;
140    EXPECT_EQ(big &lt;&lt; 73, big_copy &lt;&lt;= 73);
141    big_copy = big;
142    EXPECT_EQ(big &gt;&gt; 73, big_copy &gt;&gt;= 73);
143    EXPECT_EQ(absl::Uint128High64(biggest), std::numeric_limits&lt;uint64_t&gt;::max());
144    EXPECT_EQ(absl::Uint128Low64(biggest), std::numeric_limits&lt;uint64_t&gt;::max());
145    EXPECT_EQ(zero + one, one);
146    EXPECT_EQ(one + one, two);
147    EXPECT_EQ(big_minus_one + one, big);
148    EXPECT_EQ(one - one, zero);
149    EXPECT_EQ(one - zero, one);
150    EXPECT_EQ(zero - one, biggest);
151    EXPECT_EQ(big - big, zero);
152    EXPECT_EQ(big - one, big_minus_one);
153    EXPECT_EQ(big + std::numeric_limits&lt;uint64_t&gt;::max(), bigger);
154    EXPECT_EQ(biggest + 1, zero);
155    EXPECT_EQ(zero - 1, biggest);
156    EXPECT_EQ(high_low - one, low_high);
157    EXPECT_EQ(low_high + one, high_low);
158    EXPECT_EQ(absl::Uint128High64((absl::uint128(1) &lt;&lt; 64) - 1), 0);
159    EXPECT_EQ(absl::Uint128Low64((absl::uint128(1) &lt;&lt; 64) - 1),
160              std::numeric_limits&lt;uint64_t&gt;::max());
161    EXPECT_TRUE(!!one);
162    EXPECT_TRUE(!!high_low);
163    EXPECT_FALSE(!!zero);
164    EXPECT_FALSE(!one);
165    EXPECT_FALSE(!high_low);
166    EXPECT_TRUE(!zero);
167    EXPECT_TRUE(zero == 0);       
168    EXPECT_FALSE(zero != 0);      
169    EXPECT_FALSE(one == 0);       
170    EXPECT_TRUE(one != 0);        
171    EXPECT_FALSE(high_low == 0);  
172    EXPECT_TRUE(high_low != 0);   
173    absl::uint128 test = zero;
174    EXPECT_EQ(++test, one);
175    EXPECT_EQ(test, one);
176    EXPECT_EQ(test++, one);
177    EXPECT_EQ(test, two);
178    EXPECT_EQ(test -= 2, zero);
179    EXPECT_EQ(test, zero);
180    EXPECT_EQ(test += 2, two);
181    EXPECT_EQ(test, two);
182    EXPECT_EQ(--test, one);
183    EXPECT_EQ(test, one);
184    EXPECT_EQ(test--, one);
185    EXPECT_EQ(test, zero);
186    EXPECT_EQ(test |= three, three);
187    EXPECT_EQ(test &amp;= one, one);
188    EXPECT_EQ(test ^= three, two);
189    EXPECT_EQ(test &gt;&gt;= 1, one);
190    EXPECT_EQ(test &lt;&lt;= 1, two);
191    EXPECT_EQ(big, +big);
192    EXPECT_EQ(two, +two);
193    EXPECT_EQ(absl::Uint128Max(), +absl::Uint128Max());
194    EXPECT_EQ(zero, +zero);
195    EXPECT_EQ(big, -(-big));
196    EXPECT_EQ(two, -((-one) - 1));
197    EXPECT_EQ(absl::Uint128Max(), -one);
198    EXPECT_EQ(zero, -zero);
199    EXPECT_EQ(absl::Uint128Max(), absl::kuint128max);
200  }
201  TEST(Int128, RightShiftOfNegativeNumbers) {
202    absl::int128 minus_six = -6;
203    absl::int128 minus_three = -3;
204    absl::int128 minus_two = -2;
205    absl::int128 minus_one = -1;
206    if ((-6 &gt;&gt; 1) == -3) {
207      EXPECT_EQ(minus_six &gt;&gt; 1, minus_three);
208      EXPECT_EQ(minus_six &gt;&gt; 2, minus_two);
209      EXPECT_EQ(minus_six &gt;&gt; 65, minus_one);
210    } else {
211      EXPECT_EQ(minus_six &gt;&gt; 1, absl::int128(absl::uint128(minus_six) &gt;&gt; 1));
212      EXPECT_EQ(minus_six &gt;&gt; 2, absl::int128(absl::uint128(minus_six) &gt;&gt; 2));
213      EXPECT_EQ(minus_six &gt;&gt; 65, absl::int128(absl::uint128(minus_six) &gt;&gt; 65));
214    }
215  }
216  TEST(Uint128, ConversionTests) {
217    EXPECT_TRUE(absl::MakeUint128(1, 0));
218  #ifdef ABSL_HAVE_INTRINSIC_INT128
219    unsigned __int128 intrinsic =
220        (static_cast&lt;unsigned __int128&gt;(0x3a5b76c209de76f6) &lt;&lt; 64) +
221        0x1f25e1d63a2b46c5;
222    absl::uint128 custom =
223        absl::MakeUint128(0x3a5b76c209de76f6, 0x1f25e1d63a2b46c5);
224    EXPECT_EQ(custom, absl::uint128(intrinsic));
225    EXPECT_EQ(custom, absl::uint128(static_cast&lt;__int128&gt;(intrinsic)));
226    EXPECT_EQ(intrinsic, static_cast&lt;unsigned __int128&gt;(custom));
227    EXPECT_EQ(intrinsic, static_cast&lt;__int128&gt;(custom));
228  #endif  
229    double precise_double = 0x530e * std::pow(2.0, 64.0) + 0xda74000000000000;
230    absl::uint128 from_precise_double(precise_double);
231    absl::uint128 from_precise_ints =
232        absl::MakeUint128(0x530e, 0xda74000000000000);
233    EXPECT_EQ(from_precise_double, from_precise_ints);
234    EXPECT_DOUBLE_EQ(static_cast&lt;double&gt;(from_precise_ints), precise_double);
235    double approx_double =
236        static_cast&lt;double&gt;(0xffffeeeeddddcccc) * std::pow(2.0, 64.0) +
237        static_cast&lt;double&gt;(0xbbbbaaaa99998888);
238    absl::uint128 from_approx_double(approx_double);
239    EXPECT_DOUBLE_EQ(static_cast&lt;double&gt;(from_approx_double), approx_double);
240    double round_to_zero = 0.7;
241    double round_to_five = 5.8;
242    double round_to_nine = 9.3;
243    EXPECT_EQ(static_cast&lt;absl::uint128&gt;(round_to_zero), 0);
244    EXPECT_EQ(static_cast&lt;absl::uint128&gt;(round_to_five), 5);
245    EXPECT_EQ(static_cast&lt;absl::uint128&gt;(round_to_nine), 9);
246    absl::uint128 highest_precision_in_long_double =
247        ~absl::uint128{} &gt;&gt; (128 - std::numeric_limits&lt;long double&gt;::digits);
248    EXPECT_EQ(highest_precision_in_long_double,
249              static_cast&lt;absl::uint128&gt;(
250                  static_cast&lt;long double&gt;(highest_precision_in_long_double)));
251    const absl::uint128 arbitrary_mask =
252        absl::MakeUint128(0xa29f622677ded751, 0xf8ca66add076f468);
253    EXPECT_EQ(highest_precision_in_long_double &amp; arbitrary_mask,
254              static_cast&lt;absl::uint128&gt;(static_cast&lt;long double&gt;(
255                  highest_precision_in_long_double &amp; arbitrary_mask)));
256    EXPECT_EQ(static_cast&lt;absl::uint128&gt;(-0.1L), 0);
257  }
258  TEST(Uint128, OperatorAssignReturnRef) {
259    absl::uint128 v(1);
260    (v += 4) -= 3;
261    EXPECT_EQ(2, v);
262  }
263  TEST(Uint128, Multiply) {
264    absl::uint128 a, b, c;
265    a = 0;
266    b = 0;
267    c = a * b;
268    EXPECT_EQ(0, c);
269    a = absl::uint128(0) - 1;
270    b = absl::uint128(0) - 1;
271    c = a * b;
272    EXPECT_EQ(1, c);
273    c = absl::uint128(0) - 1;
274    c *= c;
275    EXPECT_EQ(1, c);
276    for (int i = 0; i &lt; 64; ++i) {
277      for (int j = 0; j &lt; 64; ++j) {
278        a = absl::uint128(1) &lt;&lt; i;
279        b = absl::uint128(1) &lt;&lt; j;
280        c = a * b;
281        EXPECT_EQ(absl::uint128(1) &lt;&lt; (i + j), c);
282      }
283    }
284    a = absl::MakeUint128(0xffffeeeeddddcccc, 0xbbbbaaaa99998888);
285    b = absl::MakeUint128(0x7777666655554444, 0x3333222211110000);
286    c = a * b;
287    EXPECT_EQ(absl::MakeUint128(0x530EDA741C71D4C3, 0xBF25975319080000), c);
288    EXPECT_EQ(0, c - b * a);
289    EXPECT_EQ(a*a - b*b, (a+b) * (a-b));
290    a = absl::MakeUint128(0x0123456789abcdef, 0xfedcba9876543210);
291    b = absl::MakeUint128(0x02468ace13579bdf, 0xfdb97531eca86420);
292    c = a * b;
293    EXPECT_EQ(absl::MakeUint128(0x97a87f4f261ba3f2, 0x342d0bbf48948200), c);
294    EXPECT_EQ(0, c - b * a);
295    EXPECT_EQ(a*a - b*b, (a+b) * (a-b));
296  }
297  TEST(Uint128, AliasTests) {
298    absl::uint128 x1 = absl::MakeUint128(1, 2);
299    absl::uint128 x2 = absl::MakeUint128(2, 4);
300    x1 += x1;
301    EXPECT_EQ(x2, x1);
302    absl::uint128 x3 = absl::MakeUint128(1, static_cast&lt;uint64_t&gt;(1) &lt;&lt; 63);
303    absl::uint128 x4 = absl::MakeUint128(3, 0);
304    x3 += x3;
305    EXPECT_EQ(x4, x3);
306  }
307  TEST(Uint128, DivideAndMod) {
308    using std::swap;
309    absl::uint128 a, b, q, r;
310    a = 0;
311    b = 123;
312    q = a / b;
313    r = a % b;
314    EXPECT_EQ(0, q);
315    EXPECT_EQ(0, r);
316    a = absl::MakeUint128(0x530eda741c71d4c3, 0xbf25975319080000);
317    q = absl::MakeUint128(0x4de2cab081, 0x14c34ab4676e4bab);
318    b = absl::uint128(0x1110001);
319    r = absl::uint128(0x3eb455);
320    ASSERT_EQ(a, q * b + r);  
321    absl::uint128 result_q, result_r;
322    result_q = a / b;
323    result_r = a % b;
324    EXPECT_EQ(q, result_q);
325    EXPECT_EQ(r, result_r);
326    swap(q, b);
327    result_q = a / b;
328    result_r = a % b;
329    EXPECT_EQ(q, result_q);
330    EXPECT_EQ(r, result_r);
331    swap(b, q);
332    swap(a, b);
333    result_q = a / b;
334    result_r = a % b;
335    EXPECT_EQ(0, result_q);
336    EXPECT_EQ(a, result_r);
337    swap(a, q);
338    result_q = a / b;
339    result_r = a % b;
340    EXPECT_EQ(0, result_q);
341    EXPECT_EQ(a, result_r);
342    swap(q, a);
343    swap(b, a);
344    b = a / 2 + 1;
345    absl::uint128 expected_r =
346        absl::MakeUint128(0x29876d3a0e38ea61, 0xdf92cba98c83ffff);
347    ASSERT_EQ(a / 2 - 1, expected_r);
348    ASSERT_EQ(a, b + expected_r);
349    result_q = a / b;
350    result_r = a % b;
351    EXPECT_EQ(1, result_q);
352    EXPECT_EQ(expected_r, result_r);
353  }
354  TEST(Uint128, DivideAndModRandomInputs) {
355    const int kNumIters = 1 &lt;&lt; 18;
356    std::minstd_rand random(testing::UnitTest::GetInstance()-&gt;random_seed());
357    std::uniform_int_distribution&lt;uint64_t&gt; uniform_uint64;
358    for (int i = 0; i &lt; kNumIters; ++i) {
359      const absl::uint128 a =
360          absl::MakeUint128(uniform_uint64(random), uniform_uint64(random));
361      const absl::uint128 b =
362          absl::MakeUint128(uniform_uint64(random), uniform_uint64(random));
363      if (b == 0) {
364        continue;  
365      }
366      const absl::uint128 q = a / b;
367      const absl::uint128 r = a % b;
368      ASSERT_EQ(a, b * q + r);
369    }
370  }
371  TEST(Uint128, ConstexprTest) {
372    constexpr absl::uint128 zero = absl::uint128();
373    constexpr absl::uint128 one = 1;
374    constexpr absl::uint128 minus_two = -2;
375    EXPECT_EQ(zero, absl::uint128(0));
376    EXPECT_EQ(one, absl::uint128(1));
377    EXPECT_EQ(minus_two, absl::MakeUint128(-1, -2));
378  }
379  TEST(Uint128, NumericLimitsTest) {
380    static_assert(std::numeric_limits&lt;absl::uint128&gt;::is_specialized, &quot;&quot;);
381    static_assert(!std::numeric_limits&lt;absl::uint128&gt;::is_signed, &quot;&quot;);
382    static_assert(std::numeric_limits&lt;absl::uint128&gt;::is_integer, &quot;&quot;);
383    EXPECT_EQ(static_cast&lt;int&gt;(128 * std::log10(2)),
384              std::numeric_limits&lt;absl::uint128&gt;::digits10);
385    EXPECT_EQ(0, std::numeric_limits&lt;absl::uint128&gt;::min());
386    EXPECT_EQ(0, std::numeric_limits&lt;absl::uint128&gt;::lowest());
387    EXPECT_EQ(absl::Uint128Max(), std::numeric_limits&lt;absl::uint128&gt;::max());
388  }
389  TEST(Uint128, Hash) {
390    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
391        absl::uint128{0},
392        absl::uint128{1},
393        ~absl::uint128{},
394        absl::uint128{std::numeric_limits&lt;int64_t&gt;::max()},
395        absl::uint128{std::numeric_limits&lt;uint64_t&gt;::max()} + 0,
396        absl::uint128{std::numeric_limits&lt;uint64_t&gt;::max()} + 1,
397        absl::uint128{std::numeric_limits&lt;uint64_t&gt;::max()} + 2,
398        absl::uint128{1} &lt;&lt; 62,
399        absl::uint128{1} &lt;&lt; 63,
400        absl::uint128{1} &lt;&lt; 64,
401        absl::uint128{1} &lt;&lt; 65,
402        std::numeric_limits&lt;absl::uint128&gt;::max(),
403        std::numeric_limits&lt;absl::uint128&gt;::max() - 1,
404        std::numeric_limits&lt;absl::uint128&gt;::min() + 1,
405        std::numeric_limits&lt;absl::uint128&gt;::min(),
406    }));
407  }
408  TEST(Int128Uint128, ConversionTest) {
409    absl::int128 nonnegative_signed_values[] = {
410        0,
411        1,
412        0xffeeddccbbaa9988,
413        absl::MakeInt128(0x7766554433221100, 0),
414        absl::MakeInt128(0x1234567890abcdef, 0xfedcba0987654321),
415        absl::Int128Max()};
416    for (absl::int128 value : nonnegative_signed_values) {
417      EXPECT_EQ(value, absl::int128(absl::uint128(value)));
418      absl::uint128 assigned_value;
419      assigned_value = value;
420      EXPECT_EQ(value, absl::int128(assigned_value));
421    }
422    absl::int128 negative_values[] = {
423        -1, -0x1234567890abcdef,
424        absl::MakeInt128(-0x5544332211ffeedd, 0),
425        -absl::MakeInt128(0x76543210fedcba98, 0xabcdef0123456789)};
426    for (absl::int128 value : negative_values) {
427      EXPECT_EQ(absl::uint128(-value), -absl::uint128(value));
428      absl::uint128 assigned_value;
429      assigned_value = value;
430      EXPECT_EQ(absl::uint128(-value), -assigned_value);
431    }
432  }
433  template &lt;typename T&gt;
434  class Int128IntegerTraitsTest : public ::testing::Test {};
435  TYPED_TEST_SUITE(Int128IntegerTraitsTest, IntegerTypes);
436  TYPED_TEST(Int128IntegerTraitsTest, ConstructAssignTest) {
437    static_assert(std::is_constructible&lt;absl::int128, TypeParam&gt;::value,
438                  &quot;absl::int128 must be constructible from TypeParam&quot;);
439    static_assert(std::is_assignable&lt;absl::int128&amp;, TypeParam&gt;::value,
440                  &quot;absl::int128 must be assignable from TypeParam&quot;);
441    static_assert(!std::is_assignable&lt;TypeParam&amp;, absl::int128&gt;::value,
442                  &quot;TypeParam must not be assignable from absl::int128&quot;);
443  }
444  template &lt;typename T&gt;
445  class Int128FloatTraitsTest : public ::testing::Test {};
446  TYPED_TEST_SUITE(Int128FloatTraitsTest, FloatingPointTypes);
447  TYPED_TEST(Int128FloatTraitsTest, ConstructAssignTest) {
448    static_assert(std::is_constructible&lt;absl::int128, TypeParam&gt;::value,
449                  &quot;absl::int128 must be constructible from TypeParam&quot;);
450    static_assert(!std::is_assignable&lt;absl::int128&amp;, TypeParam&gt;::value,
451                  &quot;absl::int128 must not be assignable from TypeParam&quot;);
452    static_assert(!std::is_assignable&lt;TypeParam&amp;, absl::int128&gt;::value,
453                  &quot;TypeParam must not be assignable from absl::int128&quot;);
454  }
455  #ifdef ABSL_HAVE_INTRINSIC_INT128
456  TEST(Int128, IntrinsicTypeTraitsTest) {
457    static_assert(std::is_constructible&lt;absl::int128, __int128&gt;::value,
458                  &quot;absl::int128 must be constructible from __int128&quot;);
459    static_assert(std::is_assignable&lt;absl::int128&amp;, __int128&gt;::value,
460                  &quot;absl::int128 must be assignable from __int128&quot;);
461    static_assert(!std::is_assignable&lt;__int128&amp;, absl::int128&gt;::value,
462                  &quot;__int128 must not be assignable from absl::int128&quot;);
463    static_assert(std::is_constructible&lt;absl::int128, unsigned __int128&gt;::value,
464                  &quot;absl::int128 must be constructible from unsigned __int128&quot;);
465    static_assert(!std::is_assignable&lt;absl::int128&amp;, unsigned __int128&gt;::value,
466                  &quot;absl::int128 must be assignable from unsigned __int128&quot;);
467    static_assert(!std::is_assignable&lt;unsigned __int128&amp;, absl::int128&gt;::value,
468                  &quot;unsigned __int128 must not be assignable from absl::int128&quot;);
469  }
470  #endif  
471  TEST(Int128, TrivialTraitsTest) {
472    static_assert(absl::is_trivially_default_constructible&lt;absl::int128&gt;::value,
473                  &quot;&quot;);
474    static_assert(absl::is_trivially_copy_constructible&lt;absl::int128&gt;::value, &quot;&quot;);
475    static_assert(absl::is_trivially_copy_assignable&lt;absl::int128&gt;::value, &quot;&quot;);
476    static_assert(std::is_trivially_destructible&lt;absl::int128&gt;::value, &quot;&quot;);
477  }
478  TEST(Int128, BoolConversionTest) {
479    EXPECT_FALSE(absl::int128(0));
480    for (int i = 0; i &lt; 64; ++i) {
481      EXPECT_TRUE(absl::MakeInt128(0, uint64_t{1} &lt;&lt; i));
482    }
483    for (int i = 0; i &lt; 63; ++i) {
484      EXPECT_TRUE(absl::MakeInt128(int64_t{1} &lt;&lt; i, 0));
485    }
486    EXPECT_TRUE(absl::Int128Min());
487    EXPECT_EQ(absl::int128(1), absl::int128(true));
488    EXPECT_EQ(absl::int128(0), absl::int128(false));
489  }
490  template &lt;typename T&gt;
491  class Int128IntegerConversionTest : public ::testing::Test {};
492  TYPED_TEST_SUITE(Int128IntegerConversionTest, IntegerTypes);
493  TYPED_TEST(Int128IntegerConversionTest, RoundTripTest) {
494    EXPECT_EQ(TypeParam{0}, static_cast&lt;TypeParam&gt;(absl::int128(0)));
495    EXPECT_EQ(std::numeric_limits&lt;TypeParam&gt;::min(),
496              static_cast&lt;TypeParam&gt;(
497                  absl::int128(std::numeric_limits&lt;TypeParam&gt;::min())));
498    EXPECT_EQ(std::numeric_limits&lt;TypeParam&gt;::max(),
499              static_cast&lt;TypeParam&gt;(
500                  absl::int128(std::numeric_limits&lt;TypeParam&gt;::max())));
501  }
502  template &lt;typename T&gt;
503  class Int128FloatConversionTest : public ::testing::Test {};
504  TYPED_TEST_SUITE(Int128FloatConversionTest, FloatingPointTypes);
505  TYPED_TEST(Int128FloatConversionTest, ConstructAndCastTest) {
506    for (int i = 0; i &lt; 110; ++i) {  
507      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i);
508      TypeParam float_value = std::ldexp(static_cast&lt;TypeParam&gt;(0x9f5b), i);
509      absl::int128 int_value = absl::int128(0x9f5b) &lt;&lt; i;
510      EXPECT_EQ(float_value, static_cast&lt;TypeParam&gt;(int_value));
511      EXPECT_EQ(-float_value, static_cast&lt;TypeParam&gt;(-int_value));
512      EXPECT_EQ(int_value, absl::int128(float_value));
513      EXPECT_EQ(-int_value, absl::int128(-float_value));
514    }
515    uint64_t values[] = {0x6d4492c24fb86199, 0x26ead65e4cb359b5,
516                         0x2c43407433ba3fd1, 0x3b574ec668df6b55,
517                         0x1c750e55a29f4f0f};
518    for (uint64_t value : values) {
519      for (int i = 0; i &lt;= 64; ++i) {
520        SCOPED_TRACE(::testing::Message()
521                     &lt;&lt; &quot;value = &quot; &lt;&lt; value &lt;&lt; &quot;; i = &quot; &lt;&lt; i);
522        TypeParam fvalue = std::ldexp(static_cast&lt;TypeParam&gt;(value), i);
523        EXPECT_DOUBLE_EQ(fvalue, static_cast&lt;TypeParam&gt;(absl::int128(fvalue)));
524        EXPECT_DOUBLE_EQ(-fvalue, static_cast&lt;TypeParam&gt;(-absl::int128(fvalue)));
525        EXPECT_DOUBLE_EQ(-fvalue, static_cast&lt;TypeParam&gt;(absl::int128(-fvalue)));
526        EXPECT_DOUBLE_EQ(fvalue, static_cast&lt;TypeParam&gt;(-absl::int128(-fvalue)));
527      }
528    }
529    absl::int128 large_values[] = {
530        absl::MakeInt128(0x5b0640d96c7b3d9f, 0xb7a7189e51d18622),
531        absl::MakeInt128(0x34bed042c6f65270, 0x73b236570669a089),
532        absl::MakeInt128(0x43deba9e6da12724, 0xf7f0f83da686797d),
533        absl::MakeInt128(0x71e8d383be4e5589, 0x75c3f96fb00752b6)};
534    for (absl::int128 value : large_values) {
535      value &gt;&gt;= (127 - std::numeric_limits&lt;TypeParam&gt;::digits);
536      value |= absl::int128(1) &lt;&lt; (std::numeric_limits&lt;TypeParam&gt;::digits - 1);
537      value |= 1;
538      for (int i = 0; i &lt; 127 - std::numeric_limits&lt;TypeParam&gt;::digits; ++i) {
539        absl::int128 int_value = value &lt;&lt; i;
540        EXPECT_EQ(int_value,
541                  static_cast&lt;absl::int128&gt;(static_cast&lt;TypeParam&gt;(int_value)));
542        EXPECT_EQ(-int_value,
543                  static_cast&lt;absl::int128&gt;(static_cast&lt;TypeParam&gt;(-int_value)));
544      }
545    }
546    EXPECT_EQ(0, absl::int128(TypeParam(0.1)));
547    EXPECT_EQ(17, absl::int128(TypeParam(17.8)));
548    EXPECT_EQ(0, absl::int128(TypeParam(-0.8)));
549    EXPECT_EQ(-53, absl::int128(TypeParam(-53.1)));
550    EXPECT_EQ(0, absl::int128(TypeParam(0.5)));
551    EXPECT_EQ(0, absl::int128(TypeParam(-0.5)));
552    TypeParam just_lt_one = std::nexttoward(TypeParam(1), TypeParam(0));
553    EXPECT_EQ(0, absl::int128(just_lt_one));
554    TypeParam just_gt_minus_one = std::nexttoward(TypeParam(-1), TypeParam(0));
555    EXPECT_EQ(0, absl::int128(just_gt_minus_one));
556    EXPECT_DOUBLE_EQ(std::ldexp(static_cast&lt;TypeParam&gt;(1), 127),
557                     static_cast&lt;TypeParam&gt;(absl::Int128Max()));
558    EXPECT_DOUBLE_EQ(-std::ldexp(static_cast&lt;TypeParam&gt;(1), 127),
559                     static_cast&lt;TypeParam&gt;(absl::Int128Min()));
560  }
561  TEST(Int128, FactoryTest) {
562    EXPECT_EQ(absl::int128(-1), absl::MakeInt128(-1, -1));
563    EXPECT_EQ(absl::int128(-31), absl::MakeInt128(-1, -31));
564    EXPECT_EQ(absl::int128(std::numeric_limits&lt;int64_t&gt;::min()),
565              absl::MakeInt128(-1, std::numeric_limits&lt;int64_t&gt;::min()));
566    EXPECT_EQ(absl::int128(0), absl::MakeInt128(0, 0));
567    EXPECT_EQ(absl::int128(1), absl::MakeInt128(0, 1));
568    EXPECT_EQ(absl::int128(std::numeric_limits&lt;int64_t&gt;::max()),
569              absl::MakeInt128(0, std::numeric_limits&lt;int64_t&gt;::max()));
570  }
571  TEST(Int128, HighLowTest) {
572    struct HighLowPair {
573      int64_t high;
574      uint64_t low;
575    };
576    HighLowPair values[]{{0, 0}, {0, 1}, {1, 0}, {123, 456}, {-654, 321}};
577    for (const HighLowPair&amp; pair : values) {
578      absl::int128 value = absl::MakeInt128(pair.high, pair.low);
579      EXPECT_EQ(pair.low, absl::Int128Low64(value));
580      EXPECT_EQ(pair.high, absl::Int128High64(value));
581    }
582  }
583  TEST(Int128, LimitsTest) {
584    EXPECT_EQ(absl::MakeInt128(0x7fffffffffffffff, 0xffffffffffffffff),
585              absl::Int128Max());
586    EXPECT_EQ(absl::Int128Max(), ~absl::Int128Min());
587  }
588  #if defined(ABSL_HAVE_INTRINSIC_INT128)
589  TEST(Int128, IntrinsicConversionTest) {
590    __int128 intrinsic =
591        (static_cast&lt;__int128&gt;(0x3a5b76c209de76f6) &lt;&lt; 64) + 0x1f25e1d63a2b46c5;
592    absl::int128 custom =
593        absl::MakeInt128(0x3a5b76c209de76f6, 0x1f25e1d63a2b46c5);
594    EXPECT_EQ(custom, absl::int128(intrinsic));
595    EXPECT_EQ(intrinsic, static_cast&lt;__int128&gt;(custom));
596  }
597  #endif  
598  TEST(Int128, ConstexprTest) {
599    constexpr absl::int128 zero = absl::int128();
600    constexpr absl::int128 one = 1;
601    constexpr absl::int128 minus_two = -2;
602    constexpr absl::int128 min = absl::Int128Min();
603    constexpr absl::int128 max = absl::Int128Max();
604    EXPECT_EQ(zero, absl::int128(0));
605    EXPECT_EQ(one, absl::int128(1));
606    EXPECT_EQ(minus_two, absl::MakeInt128(-1, -2));
607    EXPECT_GT(max, one);
608    EXPECT_LT(min, minus_two);
609  }
610  TEST(Int128, ComparisonTest) {
611    struct TestCase {
612      absl::int128 smaller;
613      absl::int128 larger;
614    };
615    TestCase cases[] = {
616        {absl::int128(0), absl::int128(123)},
617        {absl::MakeInt128(-12, 34), absl::MakeInt128(12, 34)},
618        {absl::MakeInt128(1, 1000), absl::MakeInt128(1000, 1)},
619        {absl::MakeInt128(-1000, 1000), absl::MakeInt128(-1, 1)},
620    };
621    for (const TestCase&amp; pair : cases) {
622      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;pair.smaller = &quot; &lt;&lt; pair.smaller
623                                        &lt;&lt; &quot;; pair.larger = &quot; &lt;&lt; pair.larger);
624      EXPECT_TRUE(pair.smaller == pair.smaller);  
625      EXPECT_TRUE(pair.larger == pair.larger);    
626      EXPECT_FALSE(pair.smaller == pair.larger);  
627      EXPECT_TRUE(pair.smaller != pair.larger);    
628      EXPECT_FALSE(pair.smaller != pair.smaller);  
629      EXPECT_FALSE(pair.larger != pair.larger);    
630      EXPECT_TRUE(pair.smaller &lt; pair.larger);   
631      EXPECT_FALSE(pair.larger &lt; pair.smaller);  
632      EXPECT_TRUE(pair.larger &gt; pair.smaller);   
633      EXPECT_FALSE(pair.smaller &gt; pair.larger);  
634      EXPECT_TRUE(pair.smaller &lt;= pair.larger);   
635      EXPECT_FALSE(pair.larger &lt;= pair.smaller);  
636      EXPECT_TRUE(pair.smaller &lt;= pair.smaller);  
637      EXPECT_TRUE(pair.larger &lt;= pair.larger);    
638      EXPECT_TRUE(pair.larger &gt;= pair.smaller);   
639      EXPECT_FALSE(pair.smaller &gt;= pair.larger);  
640      EXPECT_TRUE(pair.smaller &gt;= pair.smaller);  
641      EXPECT_TRUE(pair.larger &gt;= pair.larger);    
642    }
643  }
644  TEST(Int128, UnaryPlusTest) {
645    int64_t values64[] = {0, 1, 12345, 0x4000000000000000,
646                          std::numeric_limits&lt;int64_t&gt;::max()};
647    for (int64_t value : values64) {
648      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;value = &quot; &lt;&lt; value);
649      EXPECT_EQ(absl::int128(value), +absl::int128(value));
650      EXPECT_EQ(absl::int128(-value), +absl::int128(-value));
651      EXPECT_EQ(absl::MakeInt128(value, 0), +absl::MakeInt128(value, 0));
652      EXPECT_EQ(absl::MakeInt128(-value, 0), +absl::MakeInt128(-value, 0));
653    }
654  }
655  TEST(Int128, UnaryNegationTest) {
656    int64_t values64[] = {0, 1, 12345, 0x4000000000000000,
657                          std::numeric_limits&lt;int64_t&gt;::max()};
658    for (int64_t value : values64) {
659      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;value = &quot; &lt;&lt; value);
660      EXPECT_EQ(absl::int128(-value), -absl::int128(value));
661      EXPECT_EQ(absl::int128(value), -absl::int128(-value));
662      EXPECT_EQ(absl::MakeInt128(-value, 0), -absl::MakeInt128(value, 0));
663      EXPECT_EQ(absl::MakeInt128(value, 0), -absl::MakeInt128(-value, 0));
664    }
665  }
666  TEST(Int128, LogicalNotTest) {
667    EXPECT_TRUE(!absl::int128(0));
668    for (int i = 0; i &lt; 64; ++i) {
669      EXPECT_FALSE(!absl::MakeInt128(0, uint64_t{1} &lt;&lt; i));
670    }
671    for (int i = 0; i &lt; 63; ++i) {
672      EXPECT_FALSE(!absl::MakeInt128(int64_t{1} &lt;&lt; i, 0));
673    }
674  }
675  TEST(Int128, AdditionSubtractionTest) {
676    std::pair&lt;int64_t, int64_t&gt; cases[]{
677        {0, 0},                              
678        {0, 2945781290834},                  
679        {1908357619234, 0},                  
680        {0, -1204895918245},                 
681        {-2957928523560, 0},                 
682        {89023982312461, 98346012567134},    
683        {-63454234568239, -23456235230773},  
684        {98263457263502, -21428561935925},   
685        {-88235237438467, 15923659234573},   
686    };
687    for (const auto&amp; pair : cases) {
688      SCOPED_TRACE(::testing::Message()
689                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
690      EXPECT_EQ(absl::int128(pair.first + pair.second),
691                absl::int128(pair.first) + absl::int128(pair.second));
692      EXPECT_EQ(absl::int128(pair.second + pair.first),
693                absl::int128(pair.second) += absl::int128(pair.first));
694      EXPECT_EQ(absl::int128(pair.first - pair.second),
695                absl::int128(pair.first) - absl::int128(pair.second));
696      EXPECT_EQ(absl::int128(pair.second - pair.first),
697                absl::int128(pair.second) -= absl::int128(pair.first));
698      EXPECT_EQ(
699          absl::MakeInt128(pair.second + pair.first, 0),
700          absl::MakeInt128(pair.second, 0) + absl::MakeInt128(pair.first, 0));
701      EXPECT_EQ(
702          absl::MakeInt128(pair.first + pair.second, 0),
703          absl::MakeInt128(pair.first, 0) += absl::MakeInt128(pair.second, 0));
704      EXPECT_EQ(
705          absl::MakeInt128(pair.second - pair.first, 0),
706          absl::MakeInt128(pair.second, 0) - absl::MakeInt128(pair.first, 0));
707      EXPECT_EQ(
708          absl::MakeInt128(pair.first - pair.second, 0),
709          absl::MakeInt128(pair.first, 0) -= absl::MakeInt128(pair.second, 0));
710    }
711    EXPECT_EQ(absl::MakeInt128(31, 0),
712              absl::MakeInt128(20, 1) +
713                  absl::MakeInt128(10, std::numeric_limits&lt;uint64_t&gt;::max()));
714  }
715  TEST(Int128, IncrementDecrementTest) {
716    absl::int128 value = 0;
717    EXPECT_EQ(0, value++);
718    EXPECT_EQ(1, value);
719    EXPECT_EQ(1, value--);
720    EXPECT_EQ(0, value);
721    EXPECT_EQ(-1, --value);
722    EXPECT_EQ(-1, value);
723    EXPECT_EQ(0, ++value);
724    EXPECT_EQ(0, value);
725  }
726  TEST(Int128, MultiplicationTest) {
727    for (int i = 0; i &lt; 64; ++i) {
728      for (int j = 0; j &lt; 127 - i; ++j) {
729        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
730        absl::int128 a = absl::int128(1) &lt;&lt; i;
731        absl::int128 b = absl::int128(1) &lt;&lt; j;
732        absl::int128 c = absl::int128(1) &lt;&lt; (i + j);
733        EXPECT_EQ(c, a * b);
734        EXPECT_EQ(-c, -a * b);
735        EXPECT_EQ(-c, a * -b);
736        EXPECT_EQ(c, -a * -b);
737        EXPECT_EQ(c, absl::int128(a) *= b);
738        EXPECT_EQ(-c, absl::int128(-a) *= b);
739        EXPECT_EQ(-c, absl::int128(a) *= -b);
740        EXPECT_EQ(c, absl::int128(-a) *= -b);
741      }
742    }
743    std::pair&lt;int64_t, int64_t&gt; small_values[] = {
744        {0x5e61, 0xf29f79ca14b4},    
745        {0x3e033b, -0x612c0ee549},   
746        {-0x052ce7e8, 0x7c728f0f},   
747        {-0x3af7054626, -0xfb1e1d},  
748    };
749    for (const std::pair&lt;int64_t, int64_t&gt;&amp; pair : small_values) {
750      SCOPED_TRACE(::testing::Message()
751                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
752      EXPECT_EQ(absl::int128(pair.first * pair.second),
753                absl::int128(pair.first) * absl::int128(pair.second));
754      EXPECT_EQ(absl::int128(pair.first * pair.second),
755                absl::int128(pair.first) *= absl::int128(pair.second));
756      EXPECT_EQ(absl::MakeInt128(pair.first * pair.second, 0),
757                absl::MakeInt128(pair.first, 0) * absl::int128(pair.second));
758      EXPECT_EQ(absl::MakeInt128(pair.first * pair.second, 0),
759                absl::MakeInt128(pair.first, 0) *= absl::int128(pair.second));
760    }
761    std::pair&lt;int64_t, int64_t&gt; small_values2[] = {
762        {0x1bb0a110, 0x31487671},
763        {0x4792784e, 0x28add7d7},
764        {0x7b66553a, 0x11dff8ef},
765    };
766    for (const std::pair&lt;int64_t, int64_t&gt;&amp; pair : small_values2) {
767      SCOPED_TRACE(::testing::Message()
768                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
769      absl::int128 a = absl::int128(pair.first &lt;&lt; 32);
770      absl::int128 b = absl::int128(pair.second &lt;&lt; 32);
771      absl::int128 c = absl::MakeInt128(pair.first * pair.second, 0);
772      EXPECT_EQ(c, a * b);
773      EXPECT_EQ(-c, -a * b);
774      EXPECT_EQ(-c, a * -b);
775      EXPECT_EQ(c, -a * -b);
776      EXPECT_EQ(c, absl::int128(a) *= b);
777      EXPECT_EQ(-c, absl::int128(-a) *= b);
778      EXPECT_EQ(-c, absl::int128(a) *= -b);
779      EXPECT_EQ(c, absl::int128(-a) *= -b);
780    }
781    absl::int128 large_values[] = {
782        {absl::MakeInt128(0xd66f061af02d0408, 0x727d2846cb475b53)},
783        {absl::MakeInt128(0x27b8d5ed6104452d, 0x03f8a33b0ee1df4f)},
784        {-absl::MakeInt128(0x621b6626b9e8d042, 0x27311ac99df00938)},
785        {-absl::MakeInt128(0x34e0656f1e95fb60, 0x4281cfd731257a47)},
786    };
787    for (absl::int128 value : large_values) {
788      EXPECT_EQ(0, 0 * value);
789      EXPECT_EQ(0, value * 0);
790      EXPECT_EQ(0, absl::int128(0) *= value);
791      EXPECT_EQ(0, value *= 0);
792      EXPECT_EQ(value, 1 * value);
793      EXPECT_EQ(value, value * 1);
794      EXPECT_EQ(value, absl::int128(1) *= value);
795      EXPECT_EQ(value, value *= 1);
796      EXPECT_EQ(-value, -1 * value);
797      EXPECT_EQ(-value, value * -1);
798      EXPECT_EQ(-value, absl::int128(-1) *= value);
799      EXPECT_EQ(-value, value *= -1);
800    }
801    EXPECT_EQ(absl::MakeInt128(0xcd0efd3442219bb, 0xde47c05bcd9df6e1),
802              absl::MakeInt128(0x7c6448, 0x3bc4285c47a9d253) * 0x1a6037537b);
803    EXPECT_EQ(-absl::MakeInt128(0x1f8f149850b1e5e6, 0x1e50d6b52d272c3e),
804              -absl::MakeInt128(0x23, 0x2e68a513ca1b8859) * 0xe5a434cd14866e);
805    EXPECT_EQ(-absl::MakeInt128(0x55cae732029d1fce, 0xca6474b6423263e4),
806              0xa9b98a8ddf66bc * -absl::MakeInt128(0x81, 0x672e58231e2469d7));
807    EXPECT_EQ(absl::MakeInt128(0x19c8b7620b507dc4, 0xfec042b71a5f29a4),
808              -0x3e39341147 * -absl::MakeInt128(0x6a14b2, 0x5ed34cca42327b3c));
809    EXPECT_EQ(absl::MakeInt128(0xcd0efd3442219bb, 0xde47c05bcd9df6e1),
810              absl::MakeInt128(0x7c6448, 0x3bc4285c47a9d253) *= 0x1a6037537b);
811    EXPECT_EQ(-absl::MakeInt128(0x1f8f149850b1e5e6, 0x1e50d6b52d272c3e),
812              -absl::MakeInt128(0x23, 0x2e68a513ca1b8859) *= 0xe5a434cd14866e);
813    EXPECT_EQ(-absl::MakeInt128(0x55cae732029d1fce, 0xca6474b6423263e4),
814              absl::int128(0xa9b98a8ddf66bc) *=
815              -absl::MakeInt128(0x81, 0x672e58231e2469d7));
816    EXPECT_EQ(absl::MakeInt128(0x19c8b7620b507dc4, 0xfec042b71a5f29a4),
817              absl::int128(-0x3e39341147) *=
818              -absl::MakeInt128(0x6a14b2, 0x5ed34cca42327b3c));
819  }
820  TEST(Int128, DivisionAndModuloTest) {
821    std::pair&lt;int64_t, int64_t&gt; small_pairs[] = {
822        {0x15f2a64138, 0x67da05},    {0x5e56d194af43045f, 0xcf1543fb99},
823        {0x15e61ed052036a, -0xc8e6}, {0x88125a341e85, -0xd23fb77683},
824        {-0xc06e20, 0x5a},           {-0x4f100219aea3e85d, 0xdcc56cb4efe993},
825        {-0x168d629105, -0xa7},      {-0x7b44e92f03ab2375, -0x6516},
826    };
827    for (const std::pair&lt;int64_t, int64_t&gt;&amp; pair : small_pairs) {
828      SCOPED_TRACE(::testing::Message()
829                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
830      absl::int128 dividend = pair.first;
831      absl::int128 divisor = pair.second;
832      int64_t quotient = pair.first / pair.second;
833      int64_t remainder = pair.first % pair.second;
834      EXPECT_EQ(quotient, dividend / divisor);
835      EXPECT_EQ(quotient, absl::int128(dividend) /= divisor);
836      EXPECT_EQ(remainder, dividend % divisor);
837      EXPECT_EQ(remainder, absl::int128(dividend) %= divisor);
838    }
839    absl::int128 values[] = {
840        absl::MakeInt128(0x63d26ee688a962b2, 0x9e1411abda5c1d70),
841        absl::MakeInt128(0x152f385159d6f986, 0xbf8d48ef63da395d),
842        -absl::MakeInt128(0x3098d7567030038c, 0x14e7a8a098dc2164),
843        -absl::MakeInt128(0x49a037aca35c809f, 0xa6a87525480ef330),
844    };
845    for (absl::int128 value : values) {
<span onclick='openModal()' class='match'>846      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;value = &quot; &lt;&lt; value);
847      EXPECT_EQ(0, 0 / value);
</span>848      EXPECT_EQ(0, absl::int128(0) /= value);
849      EXPECT_EQ(0, 0 % value);
850      EXPECT_EQ(0, absl::int128(0) %= value);
851      EXPECT_EQ(value, value / 1);
852      EXPECT_EQ(value, absl::int128(value) /= 1);
853      EXPECT_EQ(0, value % 1);
854      EXPECT_EQ(0, absl::int128(value) %= 1);
855      EXPECT_EQ(-value, value / -1);
856      EXPECT_EQ(-value, absl::int128(value) /= -1);
857      EXPECT_EQ(0, value % -1);
858      EXPECT_EQ(0, absl::int128(value) %= -1);
859    }
860    EXPECT_EQ(0, absl::Int128Max() / absl::Int128Min());
861    EXPECT_EQ(absl::Int128Max(), absl::Int128Max() % absl::Int128Min());
862    EXPECT_EQ(-1, absl::Int128Min() / absl::Int128Max());
863    EXPECT_EQ(-1, absl::Int128Min() % absl::Int128Max());
864    absl::int128 positive_values[] = {
865        absl::MakeInt128(0x21e1a1cc69574620, 0xe7ac447fab2fc869),
866        absl::MakeInt128(0x32c2ff3ab89e66e8, 0x03379a613fd1ce74),
867        absl::MakeInt128(0x6f32ca786184dcaf, 0x046f9c9ecb3a9ce1),
868        absl::MakeInt128(0x1aeb469dd990e0ee, 0xda2740f243cd37eb),
869    };
870    for (absl::int128 value : positive_values) {
871      for (int i = 0; i &lt; 127; ++i) {
872        SCOPED_TRACE(::testing::Message()
873                     &lt;&lt; &quot;value = &quot; &lt;&lt; value &lt;&lt; &quot;; i = &quot; &lt;&lt; i);
874        absl::int128 power_of_two = absl::int128(1) &lt;&lt; i;
875        EXPECT_EQ(value &gt;&gt; i, value / power_of_two);
876        EXPECT_EQ(value &gt;&gt; i, absl::int128(value) /= power_of_two);
877        EXPECT_EQ(value &amp; (power_of_two - 1), value % power_of_two);
878        EXPECT_EQ(value &amp; (power_of_two - 1),
879                  absl::int128(value) %= power_of_two);
880      }
881    }
882    struct DivisionModCase {
883      absl::int128 dividend;
884      absl::int128 divisor;
885      absl::int128 quotient;
886      absl::int128 remainder;
887    };
888    DivisionModCase manual_cases[] = {
889        {absl::MakeInt128(0x6ada48d489007966, 0x3c9c5c98150d5d69),
890         absl::MakeInt128(0x8bc308fb, 0x8cb9cc9a3b803344), 0xc3b87e08,
891         absl::MakeInt128(0x1b7db5e1, 0xd9eca34b7af04b49)},
892        {absl::MakeInt128(0xd6946511b5b, 0x4886c5c96546bf5f),
893         -absl::MakeInt128(0x263b, 0xfd516279efcfe2dc), -0x59cbabf0,
894         absl::MakeInt128(0x622, 0xf462909155651d1f)},
895        {-absl::MakeInt128(0x33db734f9e8d1399, 0x8447ac92482bca4d), 0x37495078240,
896         -absl::MakeInt128(0xf01f1, 0xbc0368bf9a77eae8), -0x21a508f404d},
897        {-absl::MakeInt128(0x13f837b409a07e7d, 0x7fc8e248a7d73560), -0x1b9f,
898         absl::MakeInt128(0xb9157556d724, 0xb14f635714d7563e), -0x1ade},
899    };
900    for (const DivisionModCase test_case : manual_cases) {
901      EXPECT_EQ(test_case.quotient, test_case.dividend / test_case.divisor);
902      EXPECT_EQ(test_case.quotient,
903                absl::int128(test_case.dividend) /= test_case.divisor);
904      EXPECT_EQ(test_case.remainder, test_case.dividend % test_case.divisor);
905      EXPECT_EQ(test_case.remainder,
906                absl::int128(test_case.dividend) %= test_case.divisor);
907    }
908  }
909  TEST(Int128, BitwiseLogicTest) {
910    EXPECT_EQ(absl::int128(-1), ~absl::int128(0));
911    absl::int128 values[]{
912        0, -1, 0xde400bee05c3ff6b, absl::MakeInt128(0x7f32178dd81d634a, 0),
913        absl::MakeInt128(0xaf539057055613a9, 0x7d104d7d946c2e4d)};
914    for (absl::int128 value : values) {
915      EXPECT_EQ(value, ~~value);
916      EXPECT_EQ(value, value | value);
917      EXPECT_EQ(value, value &amp; value);
918      EXPECT_EQ(0, value ^ value);
919      EXPECT_EQ(value, absl::int128(value) |= value);
920      EXPECT_EQ(value, absl::int128(value) &amp;= value);
921      EXPECT_EQ(0, absl::int128(value) ^= value);
922      EXPECT_EQ(value, value | 0);
923      EXPECT_EQ(0, value &amp; 0);
924      EXPECT_EQ(value, value ^ 0);
925      EXPECT_EQ(absl::int128(-1), value | absl::int128(-1));
926      EXPECT_EQ(value, value &amp; absl::int128(-1));
927      EXPECT_EQ(~value, value ^ absl::int128(-1));
928    }
929    std::pair&lt;int64_t, int64_t&gt; pairs64[]{
930        {0x7f86797f5e991af4, 0x1ee30494fb007c97},
931        {0x0b278282bacf01af, 0x58780e0a57a49e86},
932        {0x059f266ccb93a666, 0x3d5b731bae9286f5},
933        {0x63c0c4820f12108c, 0x58166713c12e1c3a},
934        {0x381488bb2ed2a66e, 0x2220a3eb76a3698c},
935        {0x2a0a0dfb81e06f21, 0x4b60585927f5523c},
936        {0x555b1c3a03698537, 0x25478cd19d8e53cb},
937        {0x4750f6f27d779225, 0x16397553c6ff05fc},
938    };
939    for (const std::pair&lt;int64_t, int64_t&gt;&amp; pair : pairs64) {
940      SCOPED_TRACE(::testing::Message()
941                   &lt;&lt; &quot;pair = {&quot; &lt;&lt; pair.first &lt;&lt; &quot;, &quot; &lt;&lt; pair.second &lt;&lt; &#x27;}&#x27;);
942      EXPECT_EQ(absl::MakeInt128(~pair.first, ~pair.second),
943                ~absl::MakeInt128(pair.first, pair.second));
944      EXPECT_EQ(absl::int128(pair.first &amp; pair.second),
945                absl::int128(pair.first) &amp; absl::int128(pair.second));
946      EXPECT_EQ(absl::int128(pair.first | pair.second),
947                absl::int128(pair.first) | absl::int128(pair.second));
948      EXPECT_EQ(absl::int128(pair.first ^ pair.second),
949                absl::int128(pair.first) ^ absl::int128(pair.second));
950      EXPECT_EQ(absl::int128(pair.first &amp; pair.second),
951                absl::int128(pair.first) &amp;= absl::int128(pair.second));
952      EXPECT_EQ(absl::int128(pair.first | pair.second),
953                absl::int128(pair.first) |= absl::int128(pair.second));
954      EXPECT_EQ(absl::int128(pair.first ^ pair.second),
955                absl::int128(pair.first) ^= absl::int128(pair.second));
956      EXPECT_EQ(
957          absl::MakeInt128(pair.first &amp; pair.second, 0),
958          absl::MakeInt128(pair.first, 0) &amp; absl::MakeInt128(pair.second, 0));
959      EXPECT_EQ(
960          absl::MakeInt128(pair.first | pair.second, 0),
961          absl::MakeInt128(pair.first, 0) | absl::MakeInt128(pair.second, 0));
962      EXPECT_EQ(
963          absl::MakeInt128(pair.first ^ pair.second, 0),
964          absl::MakeInt128(pair.first, 0) ^ absl::MakeInt128(pair.second, 0));
965      EXPECT_EQ(
966          absl::MakeInt128(pair.first &amp; pair.second, 0),
967          absl::MakeInt128(pair.first, 0) &amp;= absl::MakeInt128(pair.second, 0));
968      EXPECT_EQ(
969          absl::MakeInt128(pair.first | pair.second, 0),
970          absl::MakeInt128(pair.first, 0) |= absl::MakeInt128(pair.second, 0));
971      EXPECT_EQ(
972          absl::MakeInt128(pair.first ^ pair.second, 0),
973          absl::MakeInt128(pair.first, 0) ^= absl::MakeInt128(pair.second, 0));
974    }
975  }
976  TEST(Int128, BitwiseShiftTest) {
977    for (int i = 0; i &lt; 64; ++i) {
978      for (int j = 0; j &lt;= i; ++j) {
979        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
980        EXPECT_EQ(uint64_t{1} &lt;&lt; i, absl::int128(uint64_t{1} &lt;&lt; j) &lt;&lt; (i - j));
981        EXPECT_EQ(uint64_t{1} &lt;&lt; i, absl::int128(uint64_t{1} &lt;&lt; j) &lt;&lt;= (i - j));
982      }
983    }
984    for (int i = 0; i &lt; 63; ++i) {
985      for (int j = 0; j &lt; 64; ++j) {
986        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
987        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
988                  absl::int128(uint64_t{1} &lt;&lt; j) &lt;&lt; (i + 64 - j));
989        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
990                  absl::int128(uint64_t{1} &lt;&lt; j) &lt;&lt;= (i + 64 - j));
991      }
992      for (int j = 0; j &lt;= i; ++j) {
993        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
994        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
995                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &lt;&lt; (i - j));
996        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
997                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &lt;&lt;= (i - j));
998      }
999    }
1000    for (int i = 0; i &lt; 64; ++i) {
1001      for (int j = i; j &lt; 64; ++j) {
1002        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
1003        EXPECT_EQ(uint64_t{1} &lt;&lt; i, absl::int128(uint64_t{1} &lt;&lt; j) &gt;&gt; (j - i));
1004        EXPECT_EQ(uint64_t{1} &lt;&lt; i, absl::int128(uint64_t{1} &lt;&lt; j) &gt;&gt;= (j - i));
1005      }
1006      for (int j = 0; j &lt; 63; ++j) {
1007        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
1008        EXPECT_EQ(uint64_t{1} &lt;&lt; i,
1009                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &gt;&gt; (j + 64 - i));
1010        EXPECT_EQ(uint64_t{1} &lt;&lt; i,
1011                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &gt;&gt;= (j + 64 - i));
1012      }
1013    }
1014    for (int i = 0; i &lt; 63; ++i) {
1015      for (int j = i; j &lt; 63; ++j) {
1016        SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;; j = &quot; &lt;&lt; j);
1017        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
1018                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &gt;&gt; (j - i));
1019        EXPECT_EQ(absl::MakeInt128(uint64_t{1} &lt;&lt; i, 0),
1020                  absl::MakeInt128(uint64_t{1} &lt;&lt; j, 0) &gt;&gt;= (j - i));
1021      }
1022    }
1023    absl::int128 val1 = MAKE_INT128(0x123456789abcdef0, 0x123456789abcdef0);
1024    absl::int128 val2 = MAKE_INT128(0xfedcba0987654321, 0xfedcba0987654321);
1025    EXPECT_EQ(val1 &lt;&lt; 63, MAKE_INT128(0x91a2b3c4d5e6f78, 0x0));
1026    EXPECT_EQ(val1 &lt;&lt; 64, MAKE_INT128(0x123456789abcdef0, 0x0));
1027    EXPECT_EQ(val2 &lt;&lt; 63, MAKE_INT128(0xff6e5d04c3b2a190, 0x8000000000000000));
1028    EXPECT_EQ(val2 &lt;&lt; 64, MAKE_INT128(0xfedcba0987654321, 0x0));
1029    EXPECT_EQ(val1 &lt;&lt; 126, MAKE_INT128(0x0, 0x0));
1030    EXPECT_EQ(val2 &lt;&lt; 126, MAKE_INT128(0x4000000000000000, 0x0));
1031    EXPECT_EQ(val1 &gt;&gt; 63, MAKE_INT128(0x0, 0x2468acf13579bde0));
1032    EXPECT_EQ(val1 &gt;&gt; 64, MAKE_INT128(0x0, 0x123456789abcdef0));
1033    EXPECT_EQ(val2 &gt;&gt; 63, MAKE_INT128(0xffffffffffffffff, 0xfdb974130eca8643));
1034    EXPECT_EQ(val2 &gt;&gt; 64, MAKE_INT128(0xffffffffffffffff, 0xfedcba0987654321));
1035    EXPECT_EQ(val1 &gt;&gt; 126, MAKE_INT128(0x0, 0x0));
1036    EXPECT_EQ(val2 &gt;&gt; 126, MAKE_INT128(0xffffffffffffffff, 0xffffffffffffffff));
1037  }
1038  TEST(Int128, NumericLimitsTest) {
1039    static_assert(std::numeric_limits&lt;absl::int128&gt;::is_specialized, &quot;&quot;);
1040    static_assert(std::numeric_limits&lt;absl::int128&gt;::is_signed, &quot;&quot;);
1041    static_assert(std::numeric_limits&lt;absl::int128&gt;::is_integer, &quot;&quot;);
1042    EXPECT_EQ(static_cast&lt;int&gt;(127 * std::log10(2)),
1043              std::numeric_limits&lt;absl::int128&gt;::digits10);
1044    EXPECT_EQ(absl::Int128Min(), std::numeric_limits&lt;absl::int128&gt;::min());
1045    EXPECT_EQ(absl::Int128Min(), std::numeric_limits&lt;absl::int128&gt;::lowest());
1046    EXPECT_EQ(absl::Int128Max(), std::numeric_limits&lt;absl::int128&gt;::max());
1047  }
1048  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-int128_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-int128_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>659      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;value = &quot; &lt;&lt; value);
660      EXPECT_EQ(absl::int128(-value), -absl::int128(value));
</pre></code></div>
                <div class="column column_space"><pre><code>846      SCOPED_TRACE(::testing::Message() &lt;&lt; &quot;value = &quot; &lt;&lt; value);
847      EXPECT_EQ(0, 0 / value);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    