
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.590062111801243%, Tokens: 9</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fast_uniform_bits_test.cc</h3>
            <pre><code>1  #include "absl/random/internal/fast_uniform_bits.h"
2  #include <random>
3  #include "gtest/gtest.h"
4  namespace absl {
5  ABSL_NAMESPACE_BEGIN
6  namespace random_internal {
7  namespace {
8  template <typename IntType>
9  class FastUniformBitsTypedTest : public ::testing::Test {};
10  using IntTypes = ::testing::Types<uint8_t, uint16_t, uint32_t, uint64_t>;
11  TYPED_TEST_SUITE(FastUniformBitsTypedTest, IntTypes);
12  TYPED_TEST(FastUniformBitsTypedTest, BasicTest) {
<span onclick='openModal()' class='match'>13    using Limits = std::numeric_limits<TypeParam>;
14    using FastBits = FastUniformBits<TypeParam>;
15    EXPECT_EQ(0, (FastBits::min)());
16    EXPECT_EQ((Limits::max)(), (FastBits::max)());
17    constexpr int kIters = 10000;
18    std::random_device rd;
19    std::mt19937 gen(rd());
20    FastBits fast;
21    for (int i = 0; i < kIters; i++) {
</span>22      const auto v = fast(gen);
23      EXPECT_LE(v, (FastBits::max)());
24      EXPECT_GE(v, (FastBits::min)());
25    }
26  }
27  template <typename UIntType, UIntType Lo, UIntType Hi, UIntType Val = Lo>
28  struct FakeUrbg {
29    using result_type = UIntType;
30    FakeUrbg() = default;
31    explicit FakeUrbg(bool r) : reject(r) {}
32    static constexpr result_type(max)() { return Hi; }
33    static constexpr result_type(min)() { return Lo; }
34    result_type operator()() {
35      return ((++calls % 2) == 1 && reject) ? Hi : Val;
36    }
37    bool reject = false;
38    size_t calls = 0;
39  };
40  TEST(FastUniformBitsTest, IsPowerOfTwoOrZero) {
41    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{0}));
42    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{1}));
43    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{2}));
44    EXPECT_FALSE(IsPowerOfTwoOrZero(uint8_t{3}));
45    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{4}));
46    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{16}));
47    EXPECT_FALSE(IsPowerOfTwoOrZero(uint8_t{17}));
48    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint8_t>::max)()));
49    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{0}));
50    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{1}));
51    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{2}));
52    EXPECT_FALSE(IsPowerOfTwoOrZero(uint16_t{3}));
53    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{4}));
54    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{16}));
55    EXPECT_FALSE(IsPowerOfTwoOrZero(uint16_t{17}));
56    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint16_t>::max)()));
57    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{0}));
58    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{1}));
59    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{2}));
60    EXPECT_FALSE(IsPowerOfTwoOrZero(uint32_t{3}));
61    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{32}));
62    EXPECT_FALSE(IsPowerOfTwoOrZero(uint32_t{17}));
63    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint32_t>::max)()));
64    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{0}));
65    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{1}));
66    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{2}));
67    EXPECT_FALSE(IsPowerOfTwoOrZero(uint64_t{3}));
68    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{4}));
69    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{64}));
70    EXPECT_FALSE(IsPowerOfTwoOrZero(uint64_t{17}));
71    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint64_t>::max)()));
72  }
73  TEST(FastUniformBitsTest, IntegerLog2) {
74    EXPECT_EQ(0, IntegerLog2(uint16_t{0}));
75    EXPECT_EQ(0, IntegerLog2(uint16_t{1}));
76    EXPECT_EQ(1, IntegerLog2(uint16_t{2}));
77    EXPECT_EQ(1, IntegerLog2(uint16_t{3}));
78    EXPECT_EQ(2, IntegerLog2(uint16_t{4}));
79    EXPECT_EQ(2, IntegerLog2(uint16_t{5}));
80    EXPECT_EQ(2, IntegerLog2(uint16_t{7}));
81    EXPECT_EQ(3, IntegerLog2(uint16_t{8}));
82    EXPECT_EQ(63, IntegerLog2((std::numeric_limits<uint64_t>::max)()));
83  }
84  TEST(FastUniformBitsTest, RangeSize) {
85    EXPECT_EQ(2, (RangeSize<FakeUrbg<uint8_t, 0, 1>>()));
86    EXPECT_EQ(3, (RangeSize<FakeUrbg<uint8_t, 0, 2>>()));
87    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint8_t, 0, 3>>()));
88    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint8_t, 2, 5>>()));
89    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint8_t, 2, 6>>()));
90    EXPECT_EQ(9, (RangeSize<FakeUrbg<uint8_t, 2, 10>>()));
91    EXPECT_EQ(
92        0, (RangeSize<
93               FakeUrbg<uint8_t, 0, (std::numeric_limits<uint8_t>::max)()>>()));
94    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint16_t, 0, 3>>()));
95    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint16_t, 2, 5>>()));
96    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint16_t, 2, 6>>()));
97    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint16_t, 1000, 1017>>()));
98    EXPECT_EQ(
99        0, (RangeSize<
100               FakeUrbg<uint16_t, 0, (std::numeric_limits<uint16_t>::max)()>>()));
101    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint32_t, 0, 3>>()));
102    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint32_t, 2, 5>>()));
103    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint32_t, 2, 6>>()));
104    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint32_t, 1000, 1017>>()));
105    EXPECT_EQ(0, (RangeSize<FakeUrbg<uint32_t, 0, 0xffffffff>>()));
106    EXPECT_EQ(0xffffffff, (RangeSize<FakeUrbg<uint32_t, 1, 0xffffffff>>()));
107    EXPECT_EQ(0xfffffffe, (RangeSize<FakeUrbg<uint32_t, 1, 0xfffffffe>>()));
108    EXPECT_EQ(0xfffffffd, (RangeSize<FakeUrbg<uint32_t, 2, 0xfffffffe>>()));
109    EXPECT_EQ(
110        0, (RangeSize<
111               FakeUrbg<uint32_t, 0, (std::numeric_limits<uint32_t>::max)()>>()));
112    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint64_t, 0, 3>>()));
113    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint64_t, 2, 5>>()));
114    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint64_t, 2, 6>>()));
115    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint64_t, 1000, 1017>>()));
116    EXPECT_EQ(0x100000000, (RangeSize<FakeUrbg<uint64_t, 0, 0xffffffff>>()));
117    EXPECT_EQ(0xffffffff, (RangeSize<FakeUrbg<uint64_t, 1, 0xffffffff>>()));
118    EXPECT_EQ(0xfffffffe, (RangeSize<FakeUrbg<uint64_t, 1, 0xfffffffe>>()));
119    EXPECT_EQ(0xfffffffd, (RangeSize<FakeUrbg<uint64_t, 2, 0xfffffffe>>()));
120    EXPECT_EQ(0, (RangeSize<FakeUrbg<uint64_t, 0, 0xffffffffffffffff>>()));
121    EXPECT_EQ(0xffffffffffffffff,
122              (RangeSize<FakeUrbg<uint64_t, 1, 0xffffffffffffffff>>()));
123    EXPECT_EQ(0xfffffffffffffffe,
124              (RangeSize<FakeUrbg<uint64_t, 1, 0xfffffffffffffffe>>()));
125    EXPECT_EQ(0xfffffffffffffffd,
126              (RangeSize<FakeUrbg<uint64_t, 2, 0xfffffffffffffffe>>()));
127    EXPECT_EQ(
128        0, (RangeSize<
129               FakeUrbg<uint64_t, 0, (std::numeric_limits<uint64_t>::max)()>>()));
130  }
131  using Urng1_5bit = FakeUrbg<uint8_t, 0, 2, 0>;  
132  using Urng4bits = FakeUrbg<uint8_t, 1, 0x10, 2>;
133  using Urng22bits = FakeUrbg<uint32_t, 0, 0x3fffff, 0x301020>;
134  using Urng31bits = FakeUrbg<uint32_t, 1, 0xfffffffe, 0x60070f03>;  
135  using Urng32bits = FakeUrbg<uint32_t, 0, 0xffffffff, 0x74010f01>;
136  using Urng33bits =
137      FakeUrbg<uint64_t, 1, 0x1ffffffff, 0x013301033>;  
138  using Urng63bits = FakeUrbg<uint64_t, 1, 0xfffffffffffffffe,
139                              0xfedcba9012345678>;  
140  using Urng64bits =
141      FakeUrbg<uint64_t, 0, 0xffffffffffffffff, 0x123456780fedcba9>;
142  TEST(FastUniformBitsTest, OutputsUpTo32Bits) {
143    Urng1_5bit urng1_5;
144    Urng4bits urng4;
145    Urng22bits urng22;
146    Urng31bits urng31;
147    Urng32bits urng32;
148    Urng33bits urng33;
149    Urng63bits urng63;
150    Urng64bits urng64;
151    {
152      FastUniformBits<uint8_t> fast8;
153      EXPECT_EQ(0x0, fast8(urng1_5));
154      EXPECT_EQ(0x11, fast8(urng4));
155      EXPECT_EQ(0x20, fast8(urng22));
156      EXPECT_EQ(0x2, fast8(urng31));
157      EXPECT_EQ(0x1, fast8(urng32));
158      EXPECT_EQ(0x32, fast8(urng33));
159      EXPECT_EQ(0x77, fast8(urng63));
160      EXPECT_EQ(0xa9, fast8(urng64));
161    }
162    {
163      FastUniformBits<uint16_t> fast16;
164      EXPECT_EQ(0x0, fast16(urng1_5));
165      EXPECT_EQ(0x1111, fast16(urng4));
166      EXPECT_EQ(0x1020, fast16(urng22));
167      EXPECT_EQ(0x0f02, fast16(urng31));
168      EXPECT_EQ(0x0f01, fast16(urng32));
169      EXPECT_EQ(0x1032, fast16(urng33));
170      EXPECT_EQ(0x5677, fast16(urng63));
171      EXPECT_EQ(0xcba9, fast16(urng64));
172    }
173    {
174      FastUniformBits<uint32_t> fast32;
175      EXPECT_EQ(0x0, fast32(urng1_5));
176      EXPECT_EQ(0x11111111, fast32(urng4));
177      EXPECT_EQ(0x08301020, fast32(urng22));
178      EXPECT_EQ(0x0f020f02, fast32(urng31));
179      EXPECT_EQ(0x74010f01, fast32(urng32));
180      EXPECT_EQ(0x13301032, fast32(urng33));
181      EXPECT_EQ(0x12345677, fast32(urng63));
182      EXPECT_EQ(0x0fedcba9, fast32(urng64));
183    }
184  }
185  TEST(FastUniformBitsTest, Outputs64Bits) {
186    FastUniformBits<uint64_t> fast64;
187    {
188      FakeUrbg<uint8_t, 0, 1, 0> urng0;
189      FakeUrbg<uint8_t, 0, 1, 1> urng1;
190      Urng4bits urng4;
191      Urng22bits urng22;
192      Urng31bits urng31;
193      Urng32bits urng32;
194      Urng33bits urng33;
195      Urng63bits urng63;
196      Urng64bits urng64;
197      EXPECT_EQ(0x0, fast64(urng0));
198      EXPECT_EQ(64, urng0.calls);
199      EXPECT_EQ(0xffffffffffffffff, fast64(urng1));
200      EXPECT_EQ(64, urng1.calls);
201      EXPECT_EQ(0x1111111111111111, fast64(urng4));
202      EXPECT_EQ(16, urng4.calls);
203      EXPECT_EQ(0x01020c0408301020, fast64(urng22));
204      EXPECT_EQ(3, urng22.calls);
205      EXPECT_EQ(0x387811c3c0870f02, fast64(urng31));
206      EXPECT_EQ(3, urng31.calls);
207      EXPECT_EQ(0x74010f0174010f01, fast64(urng32));
208      EXPECT_EQ(2, urng32.calls);
209      EXPECT_EQ(0x808194040cb01032, fast64(urng33));
210      EXPECT_EQ(3, urng33.calls);
211      EXPECT_EQ(0x1234567712345677, fast64(urng63));
212      EXPECT_EQ(2, urng63.calls);
213      EXPECT_EQ(0x123456780fedcba9, fast64(urng64));
214      EXPECT_EQ(1, urng64.calls);
215    }
216    {
217      Urng1_5bit urng1_5;
218      EXPECT_EQ(0x0, fast64(urng1_5));
219      EXPECT_EQ(65, urng1_5.calls);
220    }
221    {
222      Urng1_5bit urng1_5(true);
223      Urng31bits urng31(true);
224      Urng33bits urng33(true);
225      Urng63bits urng63(true);
226      EXPECT_EQ(0, fast64(urng1_5));
227      EXPECT_EQ(128, urng1_5.calls);
228      EXPECT_EQ(0x387811c3c0870f02, fast64(urng31));
229      EXPECT_EQ(6, urng31.calls);
230      EXPECT_EQ(0x808194040cb01032, fast64(urng33));
231      EXPECT_EQ(6, urng33.calls);
232      EXPECT_EQ(0x1234567712345677, fast64(urng63));
233      EXPECT_EQ(4, urng63.calls);
234    }
235  }
236  TEST(FastUniformBitsTest, URBG32bitRegression) {
237    EXPECT_EQ(2147483646, RangeSize<std::minstd_rand>());
238    EXPECT_EQ(30, IntegerLog2(RangeSize<std::minstd_rand>()));
239    std::minstd_rand gen(1);
240    FastUniformBits<uint64_t> fast64;
241    EXPECT_EQ(0x05e47095f8791f45, fast64(gen));
242    EXPECT_EQ(0x028be17e3c07c122, fast64(gen));
243    EXPECT_EQ(0x55d2847c1626e8c2, fast64(gen));
244  }
245  }  
246  }  
247  ABSL_NAMESPACE_END
248  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-lrn_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "caffe/layers/lrn_layer.hpp"
3  #include "caffe/util/math_functions.hpp"
4  #ifdef _OPENMP
5  #include <omp.h>
6  #endif
7  namespace caffe {
8  template <typename Dtype>
9  void LRNLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
10        const vector<Blob<Dtype>*>& top) {
11    size_ = this->layer_param_.lrn_param().local_size();
12    CHECK_EQ(size_ % 2, 1) << "LRN only supports odd values for local_size";
13    pre_pad_ = (size_ - 1) / 2;
14    alpha_ = this->layer_param_.lrn_param().alpha();
15    beta_ = this->layer_param_.lrn_param().beta();
16    k_ = this->layer_param_.lrn_param().k();
17    if (this->layer_param_.lrn_param().norm_region() ==
18        LRNParameter_NormRegion_WITHIN_CHANNEL) {
19      split_top_vec_.clear();
20      split_top_vec_.push_back(&product_input_);
21      split_top_vec_.push_back(&square_input_);
22      LayerParameter split_param;
23      split_layer_.reset(new SplitLayer<Dtype>(split_param));
24      split_layer_->SetUp(bottom, split_top_vec_);
25      square_bottom_vec_.clear();
26      square_top_vec_.clear();
27      square_bottom_vec_.push_back(&square_input_);
28      square_top_vec_.push_back(&square_output_);
29      LayerParameter square_param;
30      square_param.mutable_power_param()->set_power(Dtype(2));
31      square_layer_.reset(new PowerLayer<Dtype>(square_param));
32      square_layer_->SetUp(square_bottom_vec_, square_top_vec_);
33      pool_top_vec_.clear();
34      pool_top_vec_.push_back(&pool_output_);
35      LayerParameter pool_param;
36      pool_param.mutable_pooling_param()->set_pool(
37          PoolingParameter_PoolMethod_AVE);
38      pool_param.mutable_pooling_param()->set_pad(pre_pad_);
39      pool_param.mutable_pooling_param()->set_kernel_size(size_);
40      pool_layer_.reset(new PoolingLayer<Dtype>(pool_param));
41      pool_layer_->SetUp(square_top_vec_, pool_top_vec_);
42      power_top_vec_.clear();
43      power_top_vec_.push_back(&power_output_);
44      LayerParameter power_param;
45      power_param.mutable_power_param()->set_power(-beta_);
46      power_param.mutable_power_param()->set_scale(alpha_);
47      power_param.mutable_power_param()->set_shift(Dtype(1));
48      power_layer_.reset(new PowerLayer<Dtype>(power_param));
49      power_layer_->SetUp(pool_top_vec_, power_top_vec_);
50      product_bottom_vec_.clear();
51      product_bottom_vec_.push_back(&product_input_);
52      product_bottom_vec_.push_back(&power_output_);
53      LayerParameter product_param;
54      EltwiseParameter* eltwise_param = product_param.mutable_eltwise_param();
55      eltwise_param->set_operation(EltwiseParameter_EltwiseOp_PROD);
56      product_layer_.reset(new EltwiseLayer<Dtype>(product_param));
57      product_layer_->SetUp(product_bottom_vec_, top);
58    }
59  }
60  template <typename Dtype>
61  void LRNLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
62        const vector<Blob<Dtype>*>& top) {
63    CHECK_EQ(4, bottom[0]->num_axes()) << "Input must have 4 axes, "
64        << "corresponding to (num, channels, height, width)";
65    num_ = bottom[0]->num();
66    channels_ = bottom[0]->channels();
67    height_ = bottom[0]->height();
68    width_ = bottom[0]->width();
69    num_of_threads_ = 1;
70  #ifdef _OPENMP
71    num_of_threads_ = omp_get_max_threads() < num_ ? omp_get_max_threads() : num_;
72    if (num_of_threads_ < 1) {
73       LOG(WARNING) << "LRN layer: omp_get_max_threads() =" << num_of_threads_;
74       num_of_threads_ = 1;
75    }
76  #endif
77    switch (this->layer_param_.lrn_param().norm_region()) {
78    case LRNParameter_NormRegion_ACROSS_CHANNELS:
79      top[0]->Reshape(num_, channels_, height_, width_);
80      scale_.Reshape(num_, channels_, height_, width_);
81      padded_ratio_.Reshape(num_of_threads_, channels_ + size_ - 1,
82                            height_, width_);
83      accum_ratio_.Reshape(num_of_threads_, 1, height_, width_);
84      break;
85    case LRNParameter_NormRegion_WITHIN_CHANNEL:
86      split_layer_->Reshape(bottom, split_top_vec_);
87      square_layer_->Reshape(square_bottom_vec_, square_top_vec_);
88      pool_layer_->Reshape(square_top_vec_, pool_top_vec_);
89      power_layer_->Reshape(pool_top_vec_, power_top_vec_);
90      product_layer_->Reshape(product_bottom_vec_, top);
91      break;
92    }
93  }
94  template <typename Dtype>
95  void LRNLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
96      const vector<Blob<Dtype>*>& top) {
97    switch (this->layer_param_.lrn_param().norm_region()) {
98    case LRNParameter_NormRegion_ACROSS_CHANNELS:
99      CrossChannelForward_cpu(bottom, top);
100      break;
101    case LRNParameter_NormRegion_WITHIN_CHANNEL:
102      WithinChannelForward(bottom, top);
103      break;
104    default:
105      LOG(FATAL) << "Unknown normalization region.";
106    }
107  }
108  template <typename Dtype>
109  void LRNLayer<Dtype>::CrossChannelForward_cpu(
110      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
111    const Dtype* bottom_data = bottom[0]->cpu_data();
112    Dtype* top_data = top[0]->mutable_cpu_data();
113    Dtype* scale_data = scale_.mutable_cpu_data();
114    Dtype alpha_over_size = alpha_ / size_;
115    caffe_sqr(num_ * channels_ * height_ * width_, bottom_data, top_data);
116    caffe_set(num_ * channels_ * height_ * width_, Dtype(k_), scale_data);
117  #ifdef _OPENMP
118    #if defined(_MSC_EXTENSIONS)
119      #pragma omp parallel for
120    #else
121      #pragma omp parallel for collapse(2)
122    #endif
123  #endif
124    for (int n = 0; n < num_; n++) {
125      for (int c = 0; c < channels_; c++) {
126        for (int i = c - pre_pad_; i <= c + pre_pad_; i++) {
127          if ((i >= 0) && (i < channels_)) {
128            caffe_axpy<Dtype>(height_ * width_, alpha_over_size,
129              top_data + scale_.offset(n, i),
130              scale_data + scale_.offset(n, c));
131          }
132        }
133      }
134    }
135    caffe_powx<Dtype>(scale_.count(), scale_data, -beta_, top_data);
136    caffe_mul<Dtype>(scale_.count(), top_data, bottom_data, top_data);
137  }
138  template <typename Dtype>
139  void LRNLayer<Dtype>::WithinChannelForward(
140      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
141    split_layer_->Forward(bottom, split_top_vec_);
142    square_layer_->Forward(square_bottom_vec_, square_top_vec_);
143    pool_layer_->Forward(square_top_vec_, pool_top_vec_);
144    power_layer_->Forward(pool_top_vec_, power_top_vec_);
145    product_layer_->Forward(product_bottom_vec_, top);
146  }
147  template <typename Dtype>
148  void LRNLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
149      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
150    switch (this->layer_param_.lrn_param().norm_region()) {
151    case LRNParameter_NormRegion_ACROSS_CHANNELS:
152      CrossChannelBackward_cpu(top, propagate_down, bottom);
153      break;
154    case LRNParameter_NormRegion_WITHIN_CHANNEL:
155      WithinChannelBackward(top, propagate_down, bottom);
156      break;
157    default:
158      LOG(FATAL) << "Unknown normalization region.";
159    }
160  }
161  template <typename Dtype>
162  void LRNLayer<Dtype>::CrossChannelBackward_cpu(
163      const vector<Blob<Dtype>*>& top, const vector<bool>& propagate_down,
164      const vector<Blob<Dtype>*>& bottom) {
165    const Dtype* top_diff = top[0]->cpu_diff();
166    const Dtype* top_data = top[0]->cpu_data();
167    const Dtype* bottom_data = bottom[0]->cpu_data();
168    const Dtype* scale_data = scale_.cpu_data();
169    Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
170    Dtype* padded_ratio_data = padded_ratio_.mutable_cpu_data();
171    Dtype* accum_ratio_data = accum_ratio_.mutable_cpu_data();
<span onclick='openModal()' class='match'>172    Dtype* accum_ratio_times_bottom = accum_ratio_.mutable_cpu_diff();
173    caffe_set(padded_ratio_.count(), Dtype(0), padded_ratio_data);
174    Dtype cache_ratio_value = 2. * alpha_ * beta_ / size_;
175    caffe_powx<Dtype>(scale_.count(), scale_data, -beta_, bottom_diff);
176    caffe_mul<Dtype>(scale_.count(), top_diff, bottom_diff, bottom_diff);
177    int inverse_pre_pad = size_ - (size_ + 1) / 2;
178  #ifdef _OPENMP
179      #pragma omp parallel for num_threads(this->num_of_threads_)
180  #endif
181      for (int n = 0; n < num_; ++n) {
</span>182        int tid = 0;
183  #ifdef _OPENMP
184        tid = omp_get_thread_num();
185  #endif
186        int block_offset = scale_.offset(n);
187        caffe_mul<Dtype>(channels_ * height_ * width_,
188            top_diff + block_offset,
189            top_data + block_offset,
190            padded_ratio_data + padded_ratio_.offset(tid, inverse_pre_pad));
191        caffe_div<Dtype>(channels_ * height_ * width_,
192            padded_ratio_data + padded_ratio_.offset(tid, inverse_pre_pad),
193            scale_data + block_offset,
194            padded_ratio_data + padded_ratio_.offset(tid, inverse_pre_pad));
195        caffe_set(height_*width_,
196                  Dtype(0),
197                  accum_ratio_data + accum_ratio_.offset(tid, 0));
198        for (int c = 0; c < size_ - 1; ++c) {
199          caffe_add<Dtype>(height_ * width_,
200                            accum_ratio_data + accum_ratio_.offset(tid, 0),
201                            padded_ratio_data + padded_ratio_.offset(tid, c),
202                            accum_ratio_data + accum_ratio_.offset(tid, 0));
203        }
204        for (int c = 0; c < channels_; ++c) {
205          caffe_add<Dtype>(height_ * width_,
206              accum_ratio_data + accum_ratio_.offset(tid, 0),
207              padded_ratio_data + padded_ratio_.offset(tid, c + size_ - 1),
208              accum_ratio_data + accum_ratio_.offset(tid, 0));
209          caffe_mul<Dtype>(height_ * width_,
210                           bottom_data + top[0]->offset(n, c),
211                           accum_ratio_data + accum_ratio_.offset(tid, 0),
212                           accum_ratio_times_bottom +
213                           accum_ratio_.offset(tid, 0));
214          caffe_axpy<Dtype>(height_ * width_, -cache_ratio_value,
215              accum_ratio_times_bottom + accum_ratio_.offset(tid, 0),
216              bottom_diff + top[0]->offset(n, c));
217          caffe_sub<Dtype>(height_ * width_,
218              accum_ratio_data + accum_ratio_.offset(tid, 0),
219              padded_ratio_data + padded_ratio_.offset(tid, c),
220              accum_ratio_data + accum_ratio_.offset(tid, 0));
221        }
222      }
223  }
224  template <typename Dtype>
225  void LRNLayer<Dtype>::WithinChannelBackward(
226      const vector<Blob<Dtype>*>& top, const vector<bool>& propagate_down,
227      const vector<Blob<Dtype>*>& bottom) {
228    if (propagate_down[0]) {
229      vector<bool> product_propagate_down(2, true);
230      product_layer_->Backward(top, product_propagate_down, product_bottom_vec_);
231      power_layer_->Backward(power_top_vec_, propagate_down, pool_top_vec_);
232      pool_layer_->Backward(pool_top_vec_, propagate_down, square_top_vec_);
233      square_layer_->Backward(square_top_vec_, propagate_down,
234                              square_bottom_vec_);
235      split_layer_->Backward(split_top_vec_, propagate_down, bottom);
236    }
237  }
238  #ifdef CPU_ONLY
239  STUB_GPU(LRNLayer);
240  STUB_GPU_FORWARD(LRNLayer, CrossChannelForward);
241  STUB_GPU_BACKWARD(LRNLayer, CrossChannelBackward);
242  #endif
243  INSTANTIATE_CLASS(LRNLayer);
244  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fast_uniform_bits_test.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-lrn_layer.cpp</div>
                <div class="column column_space"><pre><code>13    using Limits = std::numeric_limits<TypeParam>;
14    using FastBits = FastUniformBits<TypeParam>;
15    EXPECT_EQ(0, (FastBits::min)());
16    EXPECT_EQ((Limits::max)(), (FastBits::max)());
17    constexpr int kIters = 10000;
18    std::random_device rd;
19    std::mt19937 gen(rd());
20    FastBits fast;
21    for (int i = 0; i < kIters; i++) {
</pre></code></div>
                <div class="column column_space"><pre><code>172    Dtype* accum_ratio_times_bottom = accum_ratio_.mutable_cpu_diff();
173    caffe_set(padded_ratio_.count(), Dtype(0), padded_ratio_data);
174    Dtype cache_ratio_value = 2. * alpha_ * beta_ / size_;
175    caffe_powx<Dtype>(scale_.count(), scale_data, -beta_, bottom_diff);
176    caffe_mul<Dtype>(scale_.count(), top_diff, bottom_diff, bottom_diff);
177    int inverse_pre_pad = size_ - (size_ + 1) / 2;
178  #ifdef _OPENMP
179      #pragma omp parallel for num_threads(this->num_of_threads_)
180  #endif
181      for (int n = 0; n < num_; ++n) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    