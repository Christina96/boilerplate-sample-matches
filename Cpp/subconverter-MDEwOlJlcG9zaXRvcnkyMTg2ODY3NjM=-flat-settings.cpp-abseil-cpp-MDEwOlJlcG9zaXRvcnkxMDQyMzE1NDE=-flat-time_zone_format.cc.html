
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.062034739454094%, Tokens: 9</h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</h3>
            <pre><code>1  #include <string>
2  #include <mutex>
3  #include <toml.hpp>
4  #include "../config/binding.h"
5  #include "../handler/webget.h"
6  #include "../script/cron.h"
7  #include "../server/webserver.h"
8  #include "../utils/logger.h"
9  #include "../utils/network.h"
10  #include "interfaces.h"
11  #include "multithread.h"
12  #include "settings.h"
13  std::mutex gMutexConfigure;
14  Settings global;
15  extern WebServer webServer;
16  const std::map<std::string, ruleset_type> RulesetTypes = {{"clash-domain:", RULESET_CLASH_DOMAIN}, {"clash-ipcidr:", RULESET_CLASH_IPCIDR}, {"clash-classic:", RULESET_CLASH_CLASSICAL}, \
17              {"quanx:", RULESET_QUANX}, {"surge:", RULESET_SURGE}};
18  int importItems(string_array &target, bool scope_limit)
19  {
20      string_array result;
21      std::stringstream ss;
22      std::string path, content, strLine;
23      unsigned int itemCount = 0;
24      for(std::string &x : target)
25      {
26          if(x.find("!!import:") == x.npos)
27          {
28              result.emplace_back(x);
29              continue;
30          }
31          path = x.substr(x.find(":") + 1);
32          writeLog(0, "Trying to import items from " + path);
33          std::string proxy = parseProxy(global.proxyConfig);
34          if(fileExist(path))
35              content = fileGet(path, scope_limit);
36          else if(isLink(path))
37              content = webGet(path, proxy, global.cacheConfig);
38          else
39              writeLog(0, "File not found or not a valid URL: " + path, LOG_LEVEL_ERROR);
40          if(!content.size())
41              return -1;
42          ss << content;
43          char delimiter = getLineBreak(content);
44          std::string::size_type lineSize;
45          while(getline(ss, strLine, delimiter))
46          {
47              lineSize = strLine.size();
48              if(lineSize && strLine[lineSize - 1] == '\r') 
49                  strLine.erase(--lineSize);
50              if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) 
51                  continue;
52              result.emplace_back(std::move(strLine));
53              itemCount++;
54          }
55          ss.clear();
56      }
57      target.swap(result);
58      writeLog(0, "Imported " + std::to_string(itemCount) + " item(s).");
59      return 0;
60  }
61  toml::value parseToml(const std::string &content, const std::string &fname)
62  {
63      std::istringstream is(content);
64      return toml::parse(is, fname);
65  }
66  void importItems(std::vector<toml::value> &root, const std::string &import_key, bool scope_limit = true)
67  {
68      std::string content;
69      std::vector<toml::value> newRoot;
70      auto iter = root.begin();
71      size_t count = 0;
72      std::string proxy = parseProxy(global.proxyConfig);
73      while(iter != root.end())
74      {
75          auto& table = iter->as_table();
76          if(table.find("import") == table.end())
77              newRoot.emplace_back(std::move(*iter));
78          else
79          {
80              const std::string &path = toml::get<std::string>(table.at("import"));
81              writeLog(0, "Trying to import items from " + path);
82              if(fileExist(path))
83                  content = fileGet(path, scope_limit);
84              else if(isLink(path))
85                  content = webGet(path, proxy, global.cacheConfig);
86              else
87                  writeLog(0, "File not found or not a valid URL: " + path, LOG_LEVEL_ERROR);
88              if(content.size())
89              {
90                  auto items = parseToml(content, path);
91                  auto list = toml::find<std::vector<toml::value>>(items, import_key);
92                  count += list.size();
93                  std::move(list.begin(), list.end(), std::back_inserter(newRoot));
94              }
95          }
96          iter++;
97      }
98      root.swap(newRoot);
99      writeLog(0, "Imported " + std::to_string(count) + " item(s).");
100      return;
101  }
102  void readRegexMatch(YAML::Node node, const std::string &delimiter, string_array &dest, bool scope_limit = true)
103  {
104      YAML::Node object;
105      std::string script, url, match, rep, strLine;
106      for(unsigned i = 0; i < node.size(); i++)
107      {
108          object = node[i];
109          object["script"] >>= script;
110          if(script.size())
111          {
112              dest.emplace_back("!!script:" + script);
113              continue;
114          }
115          object["import"] >>= url;
116          if(url.size())
117          {
118              dest.emplace_back("!!import:" + url);
119              continue;
120          }
121          object["match"] >>= match;
122          object["replace"] >>= rep;
123          if(match.size() && rep.size())
124              strLine = match + delimiter + rep;
125          else
126              continue;
127          dest.emplace_back(std::move(strLine));
128      }
129      importItems(dest, scope_limit);
130  }
131  void readEmoji(YAML::Node node, string_array &dest, bool scope_limit = true)
132  {
133      YAML::Node object;
134      std::string script, url, match, rep, strLine;
135      for(unsigned i = 0; i < node.size(); i++)
136      {
137          object = node[i];
138          object["script"] >>= script;
139          if(script.size())
140          {
141              dest.emplace_back("!!script:" + script);
142              continue;
143          }
144          object["import"] >>= url;
145          if(url.size())
146          {
147              url = "!!import:" + url;
148              dest.emplace_back(url);
149              continue;
150          }
151          object["match"] >>= match;
152          object["emoji"] >>= rep;
153          if(match.size() && rep.size())
154              strLine = match + "," + rep;
155          else
156              continue;
157          dest.emplace_back(std::move(strLine));
158      }
159      importItems(dest, scope_limit);
160  }
161  void readGroup(YAML::Node node, string_array &dest, bool scope_limit = true)
162  {
163      std::string strLine, name, type;
164      string_array tempArray;
165      YAML::Node object;
166      unsigned int i, j;
167      for(i = 0; i < node.size(); i++)
168      {
169          eraseElements(tempArray);
170          object = node[i];
171          object["import"] >>= name;
172          if(name.size())
173          {
174              dest.emplace_back("!!import:" + name);
175              continue;
176          }
177          std::string url = "http:&bsol;&bsol;www.gstatic.com/generate_204", interval = "300", tolerance, timeout;
178          object["name"] >>= name;
179          object["type"] >>= type;
180          tempArray.emplace_back(name);
181          tempArray.emplace_back(type);
182          object["url"] >>= url;
183          object["interval"] >>= interval;
184          object["tolerance"] >>= tolerance;
185          object["timeout"] >>= timeout;
186          for(j = 0; j < object["rule"].size(); j++)
187              tempArray.emplace_back(safe_as<std::string>(object["rule"][j]));
188          switch(hash_(type))
189          {
190          case "select"_hash:
191              if(tempArray.size() < 3)
192                  continue;
193              break;
194          case "ssid"_hash:
195              if(tempArray.size() < 4)
196                  continue;
197              break;
198          default:
199              if(tempArray.size() < 3)
200                  continue;
201              tempArray.emplace_back(url);
202              tempArray.emplace_back(interval + "," + timeout + "," + tolerance);
203          }
204          strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b) -> std::string
205          {
206              return std::move(a) + "`" + std::move(b);
207          });
208          dest.emplace_back(std::move(strLine));
209      }
210      importItems(dest, scope_limit);
211  }
212  void readRuleset(YAML::Node node, string_array &dest, bool scope_limit = true)
213  {
214      std::string strLine, name, url, group, interval;
215      YAML::Node object;
216      for(unsigned int i = 0; i < node.size(); i++)
217      {
218          object = node[i];
219          object["import"] >>= name;
220          if(name.size())
221          {
222              dest.emplace_back("!!import:" + name);
223              continue;
224          }
225          object["ruleset"] >>= url;
226          object["group"] >>= group;
227          object["rule"] >>= name;
228          object["interval"] >>= interval;
229          if(url.size())
230          {
231              strLine = group + "," + url;
232              if(interval.size())
233                  strLine += "," + interval;
234          }
235          else if(name.size())
236              strLine = group + ",[]" + name;
237          else
238              continue;
239          dest.emplace_back(std::move(strLine));
240      }
241      importItems(dest, scope_limit);
242  }
243  void refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array)
244  {
245      eraseElements(ruleset_content_array);
246      std::string rule_group, rule_url, rule_url_typed, interval;
247      RulesetContent rc;
248      std::string proxy = parseProxy(global.proxyRuleset);
249      for(RulesetConfig &x : ruleset_list)
250      {
251          rule_group = x.Group;
252          rule_url = x.Url;
253          std::string::size_type pos = x.Url.find("[]");
254          if(pos != std::string::npos)
255          {
256              writeLog(0, "Adding rule '" + rule_url.substr(pos + 2) + "," + rule_group + "'.", LOG_LEVEL_INFO);
257              rc = {rule_group, "", "", RULESET_SURGE, std::async(std::launch::async, [=](){return rule_url.substr(pos);}), 0};
258          }
259          else
260          {
261              ruleset_type type = RULESET_SURGE;
262              rule_url_typed = rule_url;
263              auto iter = std::find_if(RulesetTypes.begin(), RulesetTypes.end(), [rule_url](auto y){ return startsWith(rule_url, y.first); });
264              if(iter != RulesetTypes.end())
265              {
266                  rule_url.erase(0, iter->first.size());
267                  type = iter->second;
268              }
269              writeLog(0, "Updating ruleset url '" + rule_url + "' with group '" + rule_group + "'.", LOG_LEVEL_INFO);
270              rc = {rule_group, rule_url, rule_url_typed, type, fetchFileAsync(rule_url, proxy, global.cacheRuleset, true, global.asyncFetchRuleset), x.Interval};
271          }
272          ruleset_content_array.emplace_back(std::move(rc));
273      }
274      ruleset_content_array.shrink_to_fit();
275  }
276  void readYAMLConf(YAML::Node &node)
277  {
278      YAML::Node section = node["common"];
279      std::string strLine;
280      string_array tempArray;
281      section["api_mode"] >> global.APIMode;
282      section["api_access_token"] >> global.accessToken;
283      if(section["default_url"].IsSequence())
284      {
285          section["default_url"] >> tempArray;
286          if(tempArray.size())
287          {
288              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
289              {
290                  return std::move(a) + "|" + std::move(b);
291              });
292              global.defaultUrls = strLine;
293              eraseElements(tempArray);
294          }
295      }
296      global.enableInsert = safe_as<std::string>(section["enable_insert"]);
297      if(section["insert_url"].IsSequence())
298      {
299          section["insert_url"] >> tempArray;
300          if(tempArray.size())
301          {
302              strLine = std::accumulate(std::next(tempArray.begin()), tempArray.end(), tempArray[0], [](std::string a, std::string b)
303              {
304                  return std::move(a) + "|" + std::move(b);
305              });
306              global.insertUrls = strLine;
307              eraseElements(tempArray);
308          }
309      }
310      section["prepend_insert_url"] >> global.prependInsert;
311      if(section["exclude_remarks"].IsSequence())
312          section["exclude_remarks"] >> global.excludeRemarks;
313      if(section["include_remarks"].IsSequence())
314          section["include_remarks"] >> global.includeRemarks;
315      global.filterScript = safe_as<bool>(section["enable_filter"]) ? safe_as<std::string>(section["filter_script"]) : "";
316      section["base_path"] >> global.basePath;
317      section["clash_rule_base"] >> global.clashBase;
318      section["surge_rule_base"] >> global.surgeBase;
319      section["surfboard_rule_base"] >> global.surfboardBase;
320      section["mellow_rule_base"] >> global.mellowBase;
321      section["quan_rule_base"] >> global.quanBase;
322      section["quanx_rule_base"] >> global.quanXBase;
323      section["loon_rule_base"] >> global.loonBase;
324      section["sssub_rule_base"] >> global.SSSubBase;
325      section["default_external_config"] >> global.defaultExtConfig;
326      section["append_proxy_type"] >> global.appendType;
327      section["proxy_config"] >> global.proxyConfig;
328      section["proxy_ruleset"] >> global.proxyRuleset;
329      section["proxy_subscription"] >> global.proxySubscription;
330      if(node["userinfo"].IsDefined())
331      {
332          section = node["userinfo"];
333          if(section["stream_rule"].IsSequence())
334          {
335              readRegexMatch(section["stream_rule"], "|", tempArray, false);
336              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
337              safe_set_streams(configs);
338              eraseElements(tempArray);
339          }
340          if(section["time_rule"].IsSequence())
341          {
342              readRegexMatch(section["time_rule"], "|", tempArray, false);
343              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
344              safe_set_times(configs);
345              eraseElements(tempArray);
346          }
347      }
348      if(node["node_pref"].IsDefined())
349      {
350          section = node["node_pref"];
351          global.UDPFlag.set(safe_as<std::string>(section["udp_flag"]));
352          global.TFOFlag.set(safe_as<std::string>(section["tcp_fast_open_flag"]));
353          global.skipCertVerify.set(safe_as<std::string>(section["skip_cert_verify_flag"]));
354          global.TLS13Flag.set(safe_as<std::string>(section["tls13_flag"]));
355          section["sort_flag"] >> global.enableSort;
356          section["sort_script"] >> global.sortScript;
357          section["filter_deprecated_nodes"] >> global.filterDeprecated;
358          section["append_sub_userinfo"] >> global.appendUserinfo;
359          section["clash_use_new_field_name"] >> global.clashUseNewField;
360          section["clash_proxies_style"] >> global.clashProxiesStyle;
361      }
362      if(section["rename_node"].IsSequence())
363      {
364          readRegexMatch(section["rename_node"], "@", tempArray, false);
365          auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "@");
366          safe_set_renames(configs);
367          eraseElements(tempArray);
368      }
369      if(node["managed_config"].IsDefined())
370      {
371          section = node["managed_config"];
372          section["write_managed_config"] >> global.writeManagedConfig;
373          section["managed_config_prefix"] >> global.managedConfigPrefix;
374          section["config_update_interval"] >> global.updateInterval;
375          section["config_update_strict"] >> global.updateStrict;
376          section["quanx_device_id"] >> global.quanXDevID;
377      }
378      if(node["surge_external_proxy"].IsDefined())
379      {
380          node["surge_external_proxy"]["surge_ssr_path"] >> global.surgeSSRPath;
381          node["surge_external_proxy"]["resolve_hostname"] >> global.surgeResolveHostname;
382      }
383      if(node["emojis"].IsDefined())
384      {
385          section = node["emojis"];
386          section["add_emoji"] >> global.addEmoji;
387          section["remove_old_emoji"] >> global.removeEmoji;
388          if(section["rules"].IsSequence())
389          {
390              readEmoji(section["rules"], tempArray, false);
391              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ",");
392              safe_set_emojis(configs);
393              eraseElements(tempArray);
394          }
395      }
396      const char *rulesets_title = node["rulesets"].IsDefined() ? "rulesets" : "ruleset";
397      if(node[rulesets_title].IsDefined())
398      {
399          section = node[rulesets_title];
400          section["enabled"] >> global.enableRuleGen;
401          if(!global.enableRuleGen)
402          {
403              global.overwriteOriginalRules = false;
404              global.updateRulesetOnRequest = false;
405          }
406          else
407          {
408              section["overwrite_original_rules"] >> global.overwriteOriginalRules;
409              section["update_ruleset_on_request"] >> global.updateRulesetOnRequest;
410          }
411          const char *ruleset_title = section["rulesets"].IsDefined() ? "rulesets" : "surge_ruleset";
412          if(section[ruleset_title].IsSequence())
413          {
414              string_array vArray;
415              readRuleset(section[ruleset_title], vArray, false);
416              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
417          }
418      }
419      const char *groups_title = node["proxy_groups"].IsDefined() ? "proxy_groups" : "proxy_group";
420      if(node[groups_title].IsDefined() && node[groups_title]["custom_proxy_group"].IsDefined())
421      {
422          string_array vArray;
423          readGroup(node[groups_title]["custom_proxy_group"], vArray, false);
424          global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
425      }
426      if(node["template"].IsDefined())
427      {
428          node["template"]["template_path"] >> global.templatePath;
429          if(node["template"]["globals"].IsSequence())
430          {
431              eraseElements(global.templateVars);
432              for(size_t i = 0; i < node["template"]["globals"].size(); i++)
433              {
434                  std::string key, value;
435                  node["template"]["globals"][i]["key"] >> key;
436                  node["template"]["globals"][i]["value"] >> value;
437                  global.templateVars[key] = value;
438              }
439          }
440      }
441      if(node["aliases"].IsSequence())
442      {
443          webServer.reset_redirect();
444          for(size_t i = 0; i < node["aliases"].size(); i++)
445          {
446              std::string uri, target;
447              node["aliases"][i]["uri"] >> uri;
448              node["aliases"][i]["target"] >> target;
449              webServer.append_redirect(uri, target);
450          }
451      }
452      if(node["tasks"].IsSequence())
453      {
454          string_array vArray;
455          for(size_t i = 0; i < node["tasks"].size(); i++)
456          {
457              std::string name, exp, path, timeout;
458              node["tasks"][i]["import"] >> name;
459              if(name.size())
460              {
461                  vArray.emplace_back("!!import:" + name);
462                  continue;
463              }
464              node["tasks"][i]["name"] >> name;
465              node["tasks"][i]["cronexp"] >> exp;
466              node["tasks"][i]["path"] >> path;
467              node["tasks"][i]["timeout"] >> timeout;
468              strLine = name + "`" + exp + "`" + path + "`" + timeout;
469              vArray.emplace_back(std::move(strLine));
470          }
471          importItems(vArray, false);
472          global.enableCron = !vArray.empty();
473          global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);
474          refresh_schedule();
475      }
476      if(node["server"].IsDefined())
477      {
478          node["server"]["listen"] >> global.listenAddress;
479          node["server"]["port"] >> global.listenPort;
480          node["server"]["serve_file_root"] >>= webServer.serve_file_root;
481          webServer.serve_file = !webServer.serve_file_root.empty();
482      }
483      if(node["advanced"].IsDefined())
484      {
485          std::string log_level;
486          node["advanced"]["log_level"] >> log_level;
487          node["advanced"]["print_debug_info"] >> global.printDbgInfo;
488          if(global.printDbgInfo)
489              global.logLevel = LOG_LEVEL_VERBOSE;
490          else
491          {
492              switch(hash_(log_level))
493              {
494              case "warn"_hash:
495                  global.logLevel = LOG_LEVEL_WARNING;
496                  break;
497              case "error"_hash:
498                  global.logLevel = LOG_LEVEL_ERROR;
499                  break;
500              case "fatal"_hash:
501                  global.logLevel = LOG_LEVEL_FATAL;
502                  break;
503              case "verbose"_hash:
504                  global.logLevel = LOG_LEVEL_VERBOSE;
505                  break;
506              case "debug"_hash:
507                  global.logLevel = LOG_LEVEL_DEBUG;
508                  break;
509              default:
510                  global.logLevel = LOG_LEVEL_INFO;
511              }
512          }
513          node["advanced"]["max_pending_connections"] >> global.maxPendingConns;
514          node["advanced"]["max_concurrent_threads"] >> global.maxConcurThreads;
515          node["advanced"]["max_allowed_rulesets"] >> global.maxAllowedRulesets;
516          node["advanced"]["max_allowed_rules"] >> global.maxAllowedRules;
517          node["advanced"]["max_allowed_download_size"] >> global.maxAllowedDownloadSize;
518          if(node["advanced"]["enable_cache"].IsDefined())
519          {
520              if(safe_as<bool>(node["advanced"]["enable_cache"]))
521              {
522                  node["advanced"]["cache_subscription"] >> global.cacheSubscription;
523                  node["advanced"]["cache_config"] >> global.cacheConfig;
524                  node["advanced"]["cache_ruleset"] >> global.cacheRuleset;
525                  node["advanced"]["serve_cache_on_fetch_fail"] >> global.serveCacheOnFetchFail;
526              }
527              else
528                  global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
529          }
530          node["advanced"]["script_clean_context"] >> global.scriptCleanContext;
531          node["advanced"]["async_fetch_ruleset"] >> global.asyncFetchRuleset;
532          node["advanced"]["skip_failed_links"] >> global.skipFailedLinks;
533      }
534      writeLog(0, "Load preference settings in YAML format completed.", LOG_LEVEL_INFO);
535  }
536  template <class T, class... U>
537  void find_if_exist(const toml::value &v, const toml::key &k, T& target, U&&... args)
538  {
539      if(v.contains(k)) target = toml::find<T>(v, k);
540      if constexpr (sizeof...(args) > 0) find_if_exist(v, std::forward<U>(args)...);
541  }
542  void operate_toml_kv_table(const std::vector<toml::table> &arr, const toml::key &key_name, const toml::key &value_name, std::function<void (const toml::value&, const toml::value&)> binary_op)
543  {
544      for(const toml::table &table : arr)
545      {
546          const auto &key = table.at(key_name), value = table.at(value_name);
547          binary_op(key, value);
548      }
549  }
550  void readTOMLConf(toml::value &root)
551  {
552      const auto &section_common = toml::find(root, "common");
553      string_array default_url, insert_url;
554      find_if_exist(section_common, "default_url", default_url, "insert_url", insert_url);
555      global.defaultUrls = join(default_url, "|");
556      global.insertUrls = join(insert_url, "|");
557      bool filter = false;
558      find_if_exist(section_common,
559                    "api_mode", global.APIMode,
560                    "api_access_token", global.accessToken,
561                    "exclude_remarks", global.excludeRemarks,
562                    "include_remarks", global.includeRemarks,
563                    "enable_insert", global.enableInsert,
564                    "prepend_insert_url", global.prependInsert,
565                    "enable_filter", filter,
566                    "default_external_config", global.defaultExtConfig,
567                    "base_path", global.basePath,
568                    "clash_rule_base", global.clashBase,
569                    "surge_rule_base", global.surgeBase,
570                    "surfboard_rule_base", global.surfboardBase,
571                    "mellow_rule_base", global.mellowBase,
572                    "quan_rule_base", global.quanBase,
573                    "quanx_rule_base", global.quanXBase,
574                    "loon_rule_base", global.loonBase,
575                    "proxy_config", global.proxyConfig,
576                    "proxy_ruleset", global.proxyRuleset,
577                    "proxy_subscription", global.proxySubscription,
578                    "append_proxy_type", global.appendType
579      );
580      if(filter)
581          find_if_exist(section_common, "filter_script", global.filterScript);
582      else
583          global.filterScript.clear();
584      safe_set_streams(toml::find_or<RegexMatchConfigs>(root, "userinfo", "stream_rule", RegexMatchConfigs{}));
585      safe_set_times(toml::find_or<RegexMatchConfigs>(root, "userinfo", "time_rule", RegexMatchConfigs{}));
586      const auto &section_node_pref = toml::find(root, "node_pref");
587      find_if_exist(section_node_pref,
588                    "udp_flag", global.UDPFlag,
589                    "tcp_fast_open_flag", global.TFOFlag,
590                    "skip_cert_verify_flag", global.skipCertVerify,
591                    "tls13_flag", global.TLS13Flag,
592                    "sort_flag", global.enableSort,
593                    "sort_script", global.sortScript,
594                    "filter_deprecated_nodes", global.filterDeprecated,
595                    "append_sub_userinfo", global.appendUserinfo,
596                    "clash_use_new_field_name", global.clashUseNewField,
597                    "clash_proxies_style", global.clashProxiesStyle
598      );
599      auto renameconfs = toml::find_or<std::vector<toml::value>>(section_node_pref, "rename_node", {});
600      importItems(renameconfs, "rename_node", false);
601      safe_set_renames(toml::get<RegexMatchConfigs>(toml::value(renameconfs)));
602      const auto &section_managed = toml::find(root, "managed_config");
603      find_if_exist(section_managed,
604                    "write_managed_config", global.writeManagedConfig,
605                    "managed_config_prefix", global.managedConfigPrefix,
606                    "config_update_interval", global.updateInterval,
607                    "config_update_strict", global.updateStrict,
608                    "quanx_device_id", global.quanXDevID
609      );
610      const auto &section_surge_external = toml::find(root, "surge_external_proxy");
611      find_if_exist(section_surge_external,
612                    "surge_ssr_path", global.surgeSSRPath,
613                    "resolve_hostname", global.surgeResolveHostname
614      );
615      const auto &section_emojis = toml::find(root, "emojis");
616      find_if_exist(section_emojis,
617                    "add_emoji", global.addEmoji,
618                    "remove_old_emoji", global.removeEmoji
619      );
620      auto emojiconfs = toml::find_or<std::vector<toml::value>>(section_emojis, "emoji", {});
621      importItems(emojiconfs, "emoji", false);
622      safe_set_emojis(toml::get<RegexMatchConfigs>(toml::value(emojiconfs)));
623      auto groups = toml::find_or<std::vector<toml::value>>(root, "custom_groups", {});
624      importItems(groups, "custom_groups", false);
625      global.customProxyGroups = toml::get<ProxyGroupConfigs>(toml::value(groups));
626      const auto &section_ruleset = toml::find(root, "ruleset");
627      find_if_exist(section_ruleset,
628                    "enabled", global.enableRuleGen,
629                    "overwrite_original_rules", global.overwriteOriginalRules,
630                    "update_ruleset_on_request", global.updateRulesetOnRequest
631      );
632      auto rulesets = toml::find_or<std::vector<toml::value>>(root, "rulesets", {});
633      importItems(rulesets, "rulesets", false);
634      global.customRulesets = toml::get<RulesetConfigs>(toml::value(rulesets));
635      const auto &section_template = toml::find(root, "template");
636      global.templatePath = toml::find_or(section_template, "template_path", "template");
637      eraseElements(global.templateVars);
638      operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section_template, "globals", {}), "key", "value", [&](const toml::value &key, const toml::value &value)
639      {
640          global.templateVars[key.as_string()] = value.as_string();
641      });
642      webServer.reset_redirect();
643      operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(root, "aliases", {}), "uri", "target", [&](const toml::value &key, const toml::value &value)
644      {
645          webServer.append_redirect(key.as_string(), value.as_string());
646      });
647      auto tasks = toml::find_or<std::vector<toml::value>>(root, "tasks", {});
648      importItems(tasks, "tasks", false);
649      global.cronTasks = toml::get<CronTaskConfigs>(toml::value(tasks));
650      const auto &section_server = toml::find(root, "server");
651      find_if_exist(section_server,
652                    "listen", global.listenAddress,
653                    "port", global.listenPort,
654                    "serve_file_root", webServer.serve_file_root
655      );
656      webServer.serve_file = !webServer.serve_file_root.empty();
657      const auto &section_advanced = toml::find(root, "advanced");
658      std::string log_level;
659      bool enable_cache = true;
660      int cache_subscription = global.cacheSubscription, cache_config = global.cacheConfig, cache_ruleset = global.cacheRuleset;
661      find_if_exist(section_advanced,
662                    "log_level", log_level,
663                    "print_debug_info", global.printDbgInfo,
664                    "max_pending_connections", global.maxPendingConns,
665                    "max_concurrent_threads", global.maxConcurThreads,
666                    "max_allowed_rulesets", global.maxAllowedRulesets,
667                    "max_allowed_rules", global.maxAllowedRules,
668                    "max_allowed_download_size", global.maxAllowedDownloadSize,
669                    "enable_cache", enable_cache,
670                    "cache_subscription", cache_subscription,
671                    "cache_config", cache_config,
672                    "cache_ruleset", cache_ruleset,
673                    "script_clean_context", global.scriptCleanContext,
674                    "async_fetch_ruleset", global.asyncFetchRuleset,
675                    "skip_failed_links", global.skipFailedLinks
676      );
677      if(global.printDbgInfo)
678          global.logLevel = LOG_LEVEL_VERBOSE;
679      else
680      {
<span onclick='openModal()' class='match'>681          switch(hash_(log_level))
682          {
683          case "warn"_hash:
684              global.logLevel = LOG_LEVEL_WARNING;
685              break;
686          case "error"_hash:
687              global.logLevel = LOG_LEVEL_ERROR;
688              break;
689          case "fatal"_hash:
</span>690              global.logLevel = LOG_LEVEL_FATAL;
691              break;
692          case "verbose"_hash:
693              global.logLevel = LOG_LEVEL_VERBOSE;
694              break;
695          case "debug"_hash:
696              global.logLevel = LOG_LEVEL_DEBUG;
697              break;
698          default:
699              global.logLevel = LOG_LEVEL_INFO;
700          }
701      }
702      if(enable_cache)
703      {
704          global.cacheSubscription = cache_subscription;
705          global.cacheConfig = cache_config;
706          global.cacheRuleset = cache_ruleset;
707      }
708      else
709      {
710          global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;
711      }
712      writeLog(0, "Load preference settings in TOML format completed.", LOG_LEVEL_INFO);
713  }
714  void readConf()
715  {
716      guarded_mutex guard(gMutexConfigure);
717      writeLog(0, "Loading preference settings...", LOG_LEVEL_INFO);
718      eraseElements(global.excludeRemarks);
719      eraseElements(global.includeRemarks);
720      eraseElements(global.customProxyGroups);
721      eraseElements(global.customRulesets);
722      try
723      {
724          std::string prefdata = fileGet(global.prefPath, false);
725          if(prefdata.find("common:") != prefdata.npos)
726          {
727              YAML::Node yaml = YAML::Load(prefdata);
728              if(yaml.size() && yaml["common"])
729                  return readYAMLConf(yaml);
730          }
731          toml::value conf = parseToml(prefdata, global.prefPath);
732          if(!conf.is_uninitialized() && toml::find_or<int>(conf, "version", 0))
733              return readTOMLConf(conf);
734      }
735      catch (YAML::Exception &e)
736      {
737          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
738          writeLog(0, "Unable to load preference settings as YAML.", LOG_LEVEL_DEBUG);
739      }
740      catch (toml::exception &e)
741      {
742          writeLog(0, e.what(), LOG_LEVEL_DEBUG);
743          writeLog(0, "Unable to load preference settings as TOML.", LOG_LEVEL_DEBUG);
744      }
745      INIReader ini;
746      ini.allow_dup_section_titles = true;
747      int retVal = ini.ParseFile(global.prefPath);
748      if(retVal != INIREADER_EXCEPTION_NONE)
749      {
750          writeLog(0, "Unable to load preference settings as INI. Reason: " + ini.GetLastError(), LOG_LEVEL_FATAL);
751          return;
752      }
753      string_array tempArray;
754      ini.EnterSection("common");
755      ini.GetBoolIfExist("api_mode", global.APIMode);
756      ini.GetIfExist("api_access_token", global.accessToken);
757      ini.GetIfExist("default_url", global.defaultUrls);
758      global.enableInsert = ini.Get("enable_insert");
759      ini.GetIfExist("insert_url", global.insertUrls);
760      ini.GetBoolIfExist("prepend_insert_url", global.prependInsert);
761      if(ini.ItemPrefixExist("exclude_remarks"))
762          ini.GetAll("exclude_remarks", global.excludeRemarks);
763      if(ini.ItemPrefixExist("include_remarks"))
764          ini.GetAll("include_remarks", global.includeRemarks);
765      global.filterScript = ini.GetBool("enable_filter") ? ini.Get("filter_script"): "";
766      ini.GetIfExist("base_path", global.basePath);
767      ini.GetIfExist("clash_rule_base", global.clashBase);
768      ini.GetIfExist("surge_rule_base", global.surgeBase);
769      ini.GetIfExist("surfboard_rule_base", global.surfboardBase);
770      ini.GetIfExist("mellow_rule_base", global.mellowBase);
771      ini.GetIfExist("quan_rule_base", global.quanBase);
772      ini.GetIfExist("quanx_rule_base", global.quanXBase);
773      ini.GetIfExist("loon_rule_base", global.loonBase);
774      ini.GetIfExist("default_external_config", global.defaultExtConfig);
775      ini.GetBoolIfExist("append_proxy_type", global.appendType);
776      ini.GetIfExist("proxy_config", global.proxyConfig);
777      ini.GetIfExist("proxy_ruleset", global.proxyRuleset);
778      ini.GetIfExist("proxy_subscription", global.proxySubscription);
779      if(ini.SectionExist("surge_external_proxy"))
780      {
781          ini.EnterSection("surge_external_proxy");
782          ini.GetIfExist("surge_ssr_path", global.surgeSSRPath);
783          ini.GetBoolIfExist("resolve_hostname", global.surgeResolveHostname);
784      }
785      if(ini.SectionExist("node_pref"))
786      {
787          ini.EnterSection("node_pref");
788          global.UDPFlag.set(ini.Get("udp_flag"));
789          global.TFOFlag.set(ini.Get("tcp_fast_open_flag"));
790          global.skipCertVerify.set(ini.Get("skip_cert_verify_flag"));
791          global.TLS13Flag.set(ini.Get("tls13_flag"));
792          ini.GetBoolIfExist("sort_flag", global.enableSort);
793          global.sortScript = ini.Get("sort_script");
794          ini.GetBoolIfExist("filter_deprecated_nodes", global.filterDeprecated);
795          ini.GetBoolIfExist("append_sub_userinfo", global.appendUserinfo);
796          ini.GetBoolIfExist("clash_use_new_field_name", global.clashUseNewField);
797          ini.GetIfExist("clash_proxies_style", global.clashProxiesStyle);
798          if(ini.ItemPrefixExist("rename_node"))
799          {
800              ini.GetAll("rename_node", tempArray);
801              importItems(tempArray, false);
802              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "@");
803              safe_set_renames(configs);
804              eraseElements(tempArray);
805          }
806      }
807      if(ini.SectionExist("userinfo"))
808      {
809          ini.EnterSection("userinfo");
810          if(ini.ItemPrefixExist("stream_rule"))
811          {
812              ini.GetAll("stream_rule", tempArray);
813              importItems(tempArray, false);
814              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
815              safe_set_streams(configs);
816              eraseElements(tempArray);
817          }
818          if(ini.ItemPrefixExist("time_rule"))
819          {
820              ini.GetAll("time_rule", tempArray);
821              importItems(tempArray, false);
822              auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "|");
823              safe_set_times(configs);
824              eraseElements(tempArray);
825          }
826      }
827      ini.EnterSection("managed_config");
828      ini.GetBoolIfExist("write_managed_config", global.writeManagedConfig);
829      ini.GetIfExist("managed_config_prefix", global.managedConfigPrefix);
830      ini.GetIntIfExist("config_update_interval", global.updateInterval);
831      ini.GetBoolIfExist("config_update_strict", global.updateStrict);
832      ini.GetIfExist("quanx_device_id", global.quanXDevID);
833      ini.EnterSection("emojis");
834      ini.GetBoolIfExist("add_emoji", global.addEmoji);
835      ini.GetBoolIfExist("remove_old_emoji", global.removeEmoji);
836      if(ini.ItemPrefixExist("rule"))
837      {
838          ini.GetAll("rule", tempArray);
839          importItems(tempArray, false);
840          auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ",");
841          safe_set_emojis(configs);
842          eraseElements(tempArray);
843      }
844      if(ini.SectionExist("rulesets"))
845          ini.EnterSection("rulesets");
846      else
847          ini.EnterSection("ruleset");
848      global.enableRuleGen = ini.GetBool("enabled");
849      if(global.enableRuleGen)
850      {
851          ini.GetBoolIfExist("overwrite_original_rules", global.overwriteOriginalRules);
852          ini.GetBoolIfExist("update_ruleset_on_request", global.updateRulesetOnRequest);
853          if(ini.ItemPrefixExist("ruleset"))
854          {
855              string_array vArray;
856              ini.GetAll("ruleset", vArray);
857              importItems(vArray, false);
858              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
859          }
860          else if(ini.ItemPrefixExist("surge_ruleset"))
861          {
862              string_array vArray;
863              ini.GetAll("surge_ruleset", vArray);
864              importItems(vArray, false);
865              global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
866          }
867      }
868      else
869      {
870          global.overwriteOriginalRules = false;
871          global.updateRulesetOnRequest = false;
872      }
873      if(ini.SectionExist("proxy_groups"))
874          ini.EnterSection("proxy_groups");
875      else
876          ini.EnterSection("clash_proxy_group");
877      if(ini.ItemPrefixExist("custom_proxy_group"))
878      {
879          string_array vArray;
880          ini.GetAll("custom_proxy_group", vArray);
881          importItems(vArray, false);
882          global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
883      }
884      ini.EnterSection("template");
885      ini.GetIfExist("template_path", global.templatePath);
886      string_multimap tempmap;
887      ini.GetItems(tempmap);
888      eraseElements(global.templateVars);
889      for(auto &x : tempmap)
890      {
891          if(x.first == "template_path")
892              continue;
893          global.templateVars[x.first] = x.second;
894      }
895      global.templateVars["managed_config_prefix"] = global.managedConfigPrefix;
896      if(ini.SectionExist("aliases"))
897      {
898          ini.EnterSection("aliases");
899          ini.GetItems(tempmap);
900          webServer.reset_redirect();
901          for(auto &x : tempmap)
902              webServer.append_redirect(x.first, x.second);
903      }
904      if(ini.SectionExist("tasks"))
905      {
906          string_array vArray;
907          ini.EnterSection("tasks");
908          ini.GetAll("task", vArray);
909          importItems(vArray, false);
910          global.enableCron = !vArray.empty();
911          global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);
912          refresh_schedule();
913      }
914      ini.EnterSection("server");
915      ini.GetIfExist("listen", global.listenAddress);
916      ini.GetIntIfExist("port", global.listenPort);
917      webServer.serve_file_root = ini.Get("serve_file_root");
918      webServer.serve_file = !webServer.serve_file_root.empty();
919      ini.EnterSection("advanced");
920      std::string log_level;
921      ini.GetIfExist("log_level", log_level);
922      ini.GetBoolIfExist("print_debug_info", global.printDbgInfo);
923      if(global.printDbgInfo)
924          global.logLevel = LOG_LEVEL_VERBOSE;
925      else
926      {
927          switch(hash_(log_level))
928          {
929          case "warn"_hash:
930              global.logLevel = LOG_LEVEL_WARNING;
931              break;
932          case "error"_hash:
933              global.logLevel = LOG_LEVEL_ERROR;
934              break;
935          case "fatal"_hash:
936              global.logLevel = LOG_LEVEL_FATAL;
937              break;
938          case "verbose"_hash:
939              global.logLevel = LOG_LEVEL_VERBOSE;
940              break;
941          case "debug"_hash:
942              global.logLevel = LOG_LEVEL_DEBUG;
943              break;
944          default:
945              global.logLevel = LOG_LEVEL_INFO;
946          }
947      }
948      ini.GetIntIfExist("max_pending_connections", global.maxPendingConns);
949      ini.GetIntIfExist("max_concurrent_threads", global.maxConcurThreads);
950      ini.GetNumberIfExist("max_allowed_rulesets", global.maxAllowedRulesets);
951      ini.GetNumberIfExist("max_allowed_rules", global.maxAllowedRules);
952      ini.GetNumberIfExist("max_allowed_download_size", global.maxAllowedDownloadSize);
953      if(ini.ItemExist("enable_cache"))
954      {
955          if(ini.GetBool("enable_cache"))
956          {
957              ini.GetIntIfExist("cache_subscription", global.cacheSubscription);
958              ini.GetIntIfExist("cache_config", global.cacheConfig);
959              ini.GetIntIfExist("cache_ruleset", global.cacheRuleset);
960              ini.GetBoolIfExist("serve_cache_on_fetch_fail", global.serveCacheOnFetchFail);
961          }
962          else
963          {
964              global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0; 
965              global.serveCacheOnFetchFail = false;
966          }
967      }
968      ini.GetBoolIfExist("script_clean_context", global.scriptCleanContext);
969      ini.GetBoolIfExist("async_fetch_ruleset", global.asyncFetchRuleset);
970      ini.GetBoolIfExist("skip_failed_links", global.skipFailedLinks);
971      writeLog(0, "Load preference settings in INI format completed.", LOG_LEVEL_INFO);
972  }
973  int loadExternalYAML(YAML::Node &node, ExternalConfig &ext)
974  {
975      YAML::Node section = node["custom"], object;
976      std::string name, type, url, interval;
977      std::string group, strLine;
978      section["clash_rule_base"] >> ext.clash_rule_base;
979      section["surge_rule_base"] >> ext.surge_rule_base;
980      section["surfboard_rule_base"] >> ext.surfboard_rule_base;
981      section["mellow_rule_base"] >> ext.mellow_rule_base;
982      section["quan_rule_base"] >> ext.quan_rule_base;
983      section["quanx_rule_base"] >> ext.quanx_rule_base;
984      section["loon_rule_base"] >> ext.loon_rule_base;
985      section["sssub_rule_base"] >> ext.sssub_rule_base;
986      section["enable_rule_generator"] >> ext.enable_rule_generator;
987      section["overwrite_original_rules"] >> ext.overwrite_original_rules;
988      const char *group_name = section["proxy_groups"].IsDefined() ? "proxy_groups" : "custom_proxy_group";
989      if(section[group_name].size())
990      {
991          string_array vArray;
992          readGroup(section[group_name], vArray, global.APIMode);
993          ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
994      }
995      const char *ruleset_name = section["rulesets"].IsDefined() ? "rulesets" : "surge_ruleset";
996      if(section[ruleset_name].size())
997      {
998          string_array vArray;
999          readRuleset(section[ruleset_name], vArray, global.APIMode);
1000          if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)
1001          {
1002              writeLog(0, "Ruleset count in external config has exceeded limit.", LOG_LEVEL_WARNING);
1003              return -1;
1004          }
1005          ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);
1006      }
1007      if(section["rename_node"].size())
1008      {
1009          string_array vArray;
1010          readRegexMatch(section["rename_node"], "@", vArray, global.APIMode);
1011          ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, "@");
1012      }
1013      ext.add_emoji = safe_as<std::string>(section["add_emoji"]);
1014      ext.remove_old_emoji = safe_as<std::string>(section["remove_old_emoji"]);
1015      const char *emoji_name = section["emojis"].IsDefined() ? "emojis" : "emoji";
1016      if(section[emoji_name].size())
1017      {
1018          string_array vArray;
1019          readEmoji(section[emoji_name], vArray, global.APIMode);
1020          ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, ",");
1021      }
1022      section["include_remarks"] >> ext.include;
1023      section["exclude_remarks"] >> ext.exclude;
1024      if(node["template_args"].IsSequence() && ext.tpl_args != NULL)
1025      {
1026          std::string key, value;
1027          for(size_t i = 0; i < node["template_args"].size(); i++)
1028          {
1029              node["template_args"][i]["key"] >> key;
1030              node["template_args"][i]["value"] >> value;
1031              ext.tpl_args->local_vars[key] = value;
1032          }
1033      }
1034      return 0;
1035  }
1036  int loadExternalTOML(toml::value &root, ExternalConfig &ext)
1037  {
1038      const auto &section = toml::find(root, "custom");
1039      find_if_exist(section,
1040                    "enable_rule_generator", ext.enable_rule_generator,
1041                    "overwrite_original_rules", ext.overwrite_original_rules,
1042                    "clash_rule_base", ext.clash_rule_base,
1043                    "surge_rule_base", ext.surge_rule_base,
1044                    "surfboard_rule_base", ext.surfboard_rule_base,
1045                    "mellow_rule_base", ext.mellow_rule_base,
1046                    "quan_rule_base", ext.quan_rule_base,
1047                    "quanx_rule_base", ext.quanx_rule_base,
1048                    "sssub_rule_base", ext.sssub_rule_base,
1049                    "add_emoji", ext.add_emoji,
1050                    "remove_old_emoji", ext.remove_old_emoji,
1051                    "include_remarks", ext.include,
1052                    "exclude_remarks", ext.exclude
1053      );
1054      if(ext.tpl_args != nullptr) operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(section, "template_args", {}), "key", "value",
1055                                                        [&](const toml::value &key, const toml::value &value)
1056      {
1057          std::string val = toml::format(value);
1058          ext.tpl_args->local_vars[key.as_string()] = val;
1059      });
1060      auto groups = toml::find_or<std::vector<toml::value>>(root, "custom_groups", {});
1061      importItems(groups, "custom_groups", false);
1062      ext.custom_proxy_group = toml::get<ProxyGroupConfigs>(toml::value(groups));
1063      auto rulesets = toml::find_or<std::vector<toml::value>>(root, "rulesets", {});
1064      importItems(rulesets, "rulesets", false);
1065      if(global.maxAllowedRulesets && rulesets.size() > global.maxAllowedRulesets)
1066      {
1067          writeLog(0, "Ruleset count in external config has exceeded limit. ", LOG_LEVEL_WARNING);
1068          return -1;
1069      }
1070      ext.surge_ruleset = toml::get<RulesetConfigs>(toml::value(rulesets));
1071      auto emojiconfs = toml::find_or<std::vector<toml::value>>(root, "emoji", {});
1072      importItems(emojiconfs, "emoji", false);
1073      ext.emoji = toml::get<RegexMatchConfigs>(toml::value(emojiconfs));
1074      auto renameconfs = toml::find_or<std::vector<toml::value>>(root, "rename_node", {});
1075      importItems(renameconfs, "rename_node", false);
1076      ext.rename = toml::get<RegexMatchConfigs>(toml::value(renameconfs));
1077      return 0;
1078  }
1079  int loadExternalConfig(std::string &path, ExternalConfig &ext)
1080  {
1081      std::string base_content, proxy = parseProxy(global.proxyConfig), config = fetchFile(path, proxy, global.cacheConfig);
1082      if(render_template(config, *ext.tpl_args, base_content, global.templatePath) != 0)
1083          base_content = config;
1084      try
1085      {
1086          YAML::Node yaml = YAML::Load(base_content);
1087          if(yaml.size() && yaml["custom"].IsDefined())
1088              return loadExternalYAML(yaml, ext);
1089          toml::value conf = parseToml(base_content, path);
1090          if(!conf.is_uninitialized() && toml::find_or<int>(conf, "version", 0))
1091              return loadExternalTOML(conf, ext);
1092      }
1093      catch (YAML::Exception &e)
1094      {
1095      }
1096      catch (toml::exception &e)
1097      {
1098      }
1099      INIReader ini;
1100      ini.store_isolated_line = true;
1101      ini.SetIsolatedItemsSection("custom");
1102      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
1103      {
1104          writeLog(0, "Load external configuration failed. Reason: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1105          return -1;
1106      }
1107      ini.EnterSection("custom");
1108      if(ini.ItemPrefixExist("custom_proxy_group"))
1109      {
1110          string_array vArray;
1111          ini.GetAll("custom_proxy_group", vArray);
1112          importItems(vArray, global.APIMode);
1113          ext.custom_proxy_group = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
1114      }
1115      std::string ruleset_name = ini.ItemPrefixExist("ruleset") ? "ruleset" : "surge_ruleset";
1116      if(ini.ItemPrefixExist(ruleset_name))
1117      {
1118          string_array vArray;
1119          ini.GetAll(ruleset_name, vArray);
1120          importItems(vArray, global.APIMode);
1121          if(global.maxAllowedRulesets && vArray.size() > global.maxAllowedRulesets)
1122          {
1123              writeLog(0, "Ruleset count in external config has exceeded limit. ", LOG_LEVEL_WARNING);
1124              return -1;
1125          }
1126          ext.surge_ruleset = INIBinding::from<RulesetConfig>::from_ini(vArray);
1127      }
1128      ini.GetIfExist("clash_rule_base", ext.clash_rule_base);
1129      ini.GetIfExist("surge_rule_base", ext.surge_rule_base);
1130      ini.GetIfExist("surfboard_rule_base", ext.surfboard_rule_base);
1131      ini.GetIfExist("mellow_rule_base", ext.mellow_rule_base);
1132      ini.GetIfExist("quan_rule_base", ext.quan_rule_base);
1133      ini.GetIfExist("quanx_rule_base", ext.quanx_rule_base);
1134      ini.GetIfExist("loon_rule_base", ext.loon_rule_base);
1135      ini.GetIfExist("sssub_rule_base", ext.sssub_rule_base);
1136      ini.GetBoolIfExist("overwrite_original_rules", ext.overwrite_original_rules);
1137      ini.GetBoolIfExist("enable_rule_generator", ext.enable_rule_generator);
1138      if(ini.ItemPrefixExist("rename"))
1139      {
1140          string_array vArray;
1141          ini.GetAll("rename", vArray);
1142          importItems(vArray, global.APIMode);
1143          ext.rename = INIBinding::from<RegexMatchConfig>::from_ini(vArray, "@");
1144      }
1145      ext.add_emoji = ini.Get("add_emoji");
1146      ext.remove_old_emoji = ini.Get("remove_old_emoji");
1147      if(ini.ItemPrefixExist("emoji"))
1148      {
1149          string_array vArray;
1150          ini.GetAll("emoji", vArray);
1151          importItems(vArray, global.APIMode);
1152          ext.emoji = INIBinding::from<RegexMatchConfig>::from_ini(vArray, ",");
1153      }
1154      if(ini.ItemPrefixExist("include_remarks"))
1155          ini.GetAll("include_remarks", ext.include);
1156      if(ini.ItemPrefixExist("exclude_remarks"))
1157          ini.GetAll("exclude_remarks", ext.exclude);
1158      if(ini.SectionExist("template") && ext.tpl_args != nullptr)
1159      {
1160          ini.EnterSection("template");
1161          string_multimap tempmap;
1162          ini.GetItems(tempmap);
1163          for(auto &x : tempmap)
1164              ext.tpl_args->local_vars[x.first] = x.second;
1165      }
1166      return 0;
1167  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</h3>
            <pre><code>1  #if !defined(HAS_STRPTIME)
2  #if !defined(_MSC_VER) && !defined(__MINGW32__)
3  #define HAS_STRPTIME 1  
4  #endif
5  #endif
6  #if defined(HAS_STRPTIME) && HAS_STRPTIME
7  #if !defined(_XOPEN_SOURCE) && !defined(__OpenBSD__)
8  #define _XOPEN_SOURCE  
9  #endif
10  #endif
11  #include "absl/base/config.h"
12  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
13  #include <time.h>
14  #include <cctype>
15  #include <chrono>
16  #include <cstddef>
17  #include <cstdint>
18  #include <cstring>
19  #include <ctime>
20  #include <limits>
21  #include <string>
22  #include <vector>
23  #if !HAS_STRPTIME
24  #include <iomanip>
25  #include <sstream>
26  #endif
27  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
28  #include "time_zone_if.h"
29  namespace absl {
30  ABSL_NAMESPACE_BEGIN
31  namespace time_internal {
32  namespace cctz {
33  namespace detail {
34  namespace {
35  #if !HAS_STRPTIME
36  char* strptime(const char* s, const char* fmt, std::tm* tm) {
37    std::istringstream input(s);
38    input >> std::get_time(tm, fmt);
39    if (input.fail()) return nullptr;
40    return const_cast<char*>(s) +
41           (input.eof() ? strlen(s) : static_cast<std::size_t>(input.tellg()));
42  }
43  #endif
44  int ToTmWday(weekday wd) {
45    switch (wd) {
46      case weekday::sunday:
47        return 0;
48      case weekday::monday:
49        return 1;
50      case weekday::tuesday:
51        return 2;
52      case weekday::wednesday:
53        return 3;
54      case weekday::thursday:
55        return 4;
56      case weekday::friday:
57        return 5;
58      case weekday::saturday:
59        return 6;
60    }
61    return 0; &bsol;*NOTREACHED*/
62  }
63  weekday FromTmWday(int tm_wday) {
64    switch (tm_wday) {
65      case 0:
66        return weekday::sunday;
67      case 1:
68        return weekday::monday;
69      case 2:
70        return weekday::tuesday;
71      case 3:
72        return weekday::wednesday;
73      case 4:
74        return weekday::thursday;
75      case 5:
76        return weekday::friday;
77      case 6:
78        return weekday::saturday;
79    }
80    return weekday::sunday; &bsol;*NOTREACHED*/
81  }
82  std::tm ToTM(const time_zone::absolute_lookup& al) {
83    std::tm tm{};
84    tm.tm_sec = al.cs.second();
85    tm.tm_min = al.cs.minute();
86    tm.tm_hour = al.cs.hour();
87    tm.tm_mday = al.cs.day();
88    tm.tm_mon = al.cs.month() - 1;
89    if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
90      tm.tm_year = std::numeric_limits<int>::min();
91    } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
92      tm.tm_year = std::numeric_limits<int>::max();
93    } else {
94      tm.tm_year = static_cast<int>(al.cs.year() - 1900);
95    }
96    tm.tm_wday = ToTmWday(get_weekday(al.cs));
97    tm.tm_yday = get_yearday(al.cs) - 1;
98    tm.tm_isdst = al.is_dst ? 1 : 0;
99    return tm;
100  }
101  int ToWeek(const civil_day& cd, weekday week_start) {
102    const civil_day d(cd.year() % 400, cd.month(), cd.day());
103    return static_cast<int>((d - prev_weekday(civil_year(d), week_start)) / 7);
104  }
105  const char kDigits[] = "0123456789";
106  char* Format64(char* ep, int width, std::int_fast64_t v) {
107    bool neg = false;
108    if (v < 0) {
109      --width;
110      neg = true;
111      if (v == std::numeric_limits<std::int_fast64_t>::min()) {
112        std::int_fast64_t last_digit = -(v % 10);
113        v /= 10;
114        if (last_digit < 0) {
115          ++v;
116          last_digit += 10;
117        }
118        --width;
119        *--ep = kDigits[last_digit];
120      }
121      v = -v;
122    }
123    do {
124      --width;
125      *--ep = kDigits[v % 10];
126    } while (v /= 10);
127    while (--width >= 0) *--ep = '0';  
128    if (neg) *--ep = '-';
129    return ep;
130  }
131  char* Format02d(char* ep, int v) {
132    *--ep = kDigits[v % 10];
133    *--ep = kDigits[(v / 10) % 10];
134    return ep;
135  }
136  char* FormatOffset(char* ep, int offset, const char* mode) {
137    char sign = '+';
138    if (offset < 0) {
139      offset = -offset;  
140      sign = '-';
141    }
142    const int seconds = offset % 60;
143    const int minutes = (offset /= 60) % 60;
144    const int hours = offset /= 60;
145    const char sep = mode[0];
146    const bool ext = (sep != '\0' && mode[1] == '*');
147    const bool ccc = (ext && mode[2] == ':');
148    if (ext && (!ccc || seconds != 0)) {
149      ep = Format02d(ep, seconds);
150      *--ep = sep;
151    } else {
152      if (hours == 0 && minutes == 0) sign = '+';
153    }
154    if (!ccc || minutes != 0 || seconds != 0) {
155      ep = Format02d(ep, minutes);
156      if (sep != '\0') *--ep = sep;
157    }
158    ep = Format02d(ep, hours);
159    *--ep = sign;
160    return ep;
161  }
162  void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
163    for (std::size_t i = 2; i != 32; i *= 2) {
164      std::size_t buf_size = fmt.size() * i;
165      std::vector<char> buf(buf_size);
166      if (std::size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
167        out->append(&buf[0], len);
168        return;
169      }
170    }
171  }
172  template <typename T>
173  const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
174    if (dp != nullptr) {
175      const T kmin = std::numeric_limits<T>::min();
176      bool erange = false;
177      bool neg = false;
178      T value = 0;
179      if (*dp == '-') {
180        neg = true;
181        if (width <= 0 || --width != 0) {
182          ++dp;
183        } else {
184          dp = nullptr;  
185        }
186      }
187      if (const char* const bp = dp) {
188        while (const char* cp = strchr(kDigits, *dp)) {
189          int d = static_cast<int>(cp - kDigits);
190          if (d >= 10) break;
191          if (value < kmin / 10) {
192            erange = true;
193            break;
194          }
195          value *= 10;
196          if (value < kmin + d) {
197            erange = true;
198            break;
199          }
200          value -= d;
201          dp += 1;
202          if (width > 0 && --width == 0) break;
203        }
204        if (dp != bp && !erange && (neg || value != kmin)) {
205          if (!neg || value != 0) {
206            if (!neg) value = -value;  
207            if (min <= value && value <= max) {
208              *vp = value;
209            } else {
210              dp = nullptr;
211            }
212          } else {
213            dp = nullptr;
214          }
215        } else {
216          dp = nullptr;
217        }
218      }
219    }
220    return dp;
221  }
222  const int kDigits10_64 = 18;
223  const std::int_fast64_t kExp10[kDigits10_64 + 1] = {
224      1,
225      10,
226      100,
227      1000,
228      10000,
229      100000,
230      1000000,
231      10000000,
232      100000000,
233      1000000000,
234      10000000000,
235      100000000000,
236      1000000000000,
237      10000000000000,
238      100000000000000,
239      1000000000000000,
240      10000000000000000,
241      100000000000000000,
242      1000000000000000000,
243  };
244  }  
245  std::string format(const std::string& format, const time_point<seconds>& tp,
246                     const detail::femtoseconds& fs, const time_zone& tz) {
247    std::string result;
248    result.reserve(format.size());  
249    const time_zone::absolute_lookup al = tz.lookup(tp);
250    const std::tm tm = ToTM(al);
251    char buf[3 + kDigits10_64];  
252    char* const ep = buf + sizeof(buf);
253    char* bp;  
254    const char* pending = format.c_str();  
255    const char* cur = pending;
256    const char* end = pending + format.length();
257    while (cur != end) {  
258      const char* start = cur;
259      while (cur != end && *cur != '%') ++cur;
260      if (cur != start && pending == start) {
261        result.append(pending, static_cast<std::size_t>(cur - pending));
262        pending = start = cur;
263      }
264      const char* percent = cur;
265      while (cur != end && *cur == '%') ++cur;
266      if (cur != start && pending == start) {
267        std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;
268        result.append(pending, escaped);
269        pending += escaped * 2;
270        if (pending != cur && cur == end) {
271          result.push_back(*pending++);
272        }
273      }
274      if (cur == end || (cur - percent) % 2 == 0) continue;
275      if (strchr("YmdeUuWwHMSzZs%", *cur)) {
276        if (cur - 1 != pending) {
277          FormatTM(&result, std::string(pending, cur - 1), tm);
278        }
<span onclick='openModal()' class='match'>279        switch (*cur) {
280          case 'Y':
281            bp = Format64(ep, 0, al.cs.year());
282            result.append(bp, static_cast<std::size_t>(ep - bp));
283            break;
284          case 'm':
285            bp = Format02d(ep, al.cs.month());
286            result.append(bp, static_cast<std::size_t>(ep - bp));
287            break;
288          case 'd':
</span>289          case 'e':
290            bp = Format02d(ep, al.cs.day());
291            if (*cur == 'e' && *bp == '0') *bp = ' ';  
292            result.append(bp, static_cast<std::size_t>(ep - bp));
293            break;
294          case 'U':
295            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::sunday));
296            result.append(bp, static_cast<std::size_t>(ep - bp));
297            break;
298          case 'u':
299            bp = Format64(ep, 0, tm.tm_wday ? tm.tm_wday : 7);
300            result.append(bp, static_cast<std::size_t>(ep - bp));
301            break;
302          case 'W':
303            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::monday));
304            result.append(bp, static_cast<std::size_t>(ep - bp));
305            break;
306          case 'w':
307            bp = Format64(ep, 0, tm.tm_wday);
308            result.append(bp, static_cast<std::size_t>(ep - bp));
309            break;
310          case 'H':
311            bp = Format02d(ep, al.cs.hour());
312            result.append(bp, static_cast<std::size_t>(ep - bp));
313            break;
314          case 'M':
315            bp = Format02d(ep, al.cs.minute());
316            result.append(bp, static_cast<std::size_t>(ep - bp));
317            break;
318          case 'S':
319            bp = Format02d(ep, al.cs.second());
320            result.append(bp, static_cast<std::size_t>(ep - bp));
321            break;
322          case 'z':
323            bp = FormatOffset(ep, al.offset, "");
324            result.append(bp, static_cast<std::size_t>(ep - bp));
325            break;
326          case 'Z':
327            result.append(al.abbr);
328            break;
329          case 's':
330            bp = Format64(ep, 0, ToUnixSeconds(tp));
331            result.append(bp, static_cast<std::size_t>(ep - bp));
332            break;
333          case '%':
334            result.push_back('%');
335            break;
336        }
337        pending = ++cur;
338        continue;
339      }
340      if (*cur == ':' && cur + 1 != end) {
341        if (*(cur + 1) == 'z') {
342          if (cur - 1 != pending) {
343            FormatTM(&result, std::string(pending, cur - 1), tm);
344          }
345          bp = FormatOffset(ep, al.offset, ":");
346          result.append(bp, static_cast<std::size_t>(ep - bp));
347          pending = cur += 2;
348          continue;
349        }
350        if (*(cur + 1) == ':' && cur + 2 != end) {
351          if (*(cur + 2) == 'z') {
352            if (cur - 1 != pending) {
353              FormatTM(&result, std::string(pending, cur - 1), tm);
354            }
355            bp = FormatOffset(ep, al.offset, ":*");
356            result.append(bp, static_cast<std::size_t>(ep - bp));
357            pending = cur += 3;
358            continue;
359          }
360          if (*(cur + 2) == ':' && cur + 3 != end) {
361            if (*(cur + 3) == 'z') {
362              if (cur - 1 != pending) {
363                FormatTM(&result, std::string(pending, cur - 1), tm);
364              }
365              bp = FormatOffset(ep, al.offset, ":*:");
366              result.append(bp, static_cast<std::size_t>(ep - bp));
367              pending = cur += 4;
368              continue;
369            }
370          }
371        }
372      }
373      if (*cur != 'E' || ++cur == end) continue;
374      if (*cur == 'T') {
375        if (cur - 2 != pending) {
376          FormatTM(&result, std::string(pending, cur - 2), tm);
377        }
378        result.append("T");
379        pending = ++cur;
380      } else if (*cur == 'z') {
381        if (cur - 2 != pending) {
382          FormatTM(&result, std::string(pending, cur - 2), tm);
383        }
384        bp = FormatOffset(ep, al.offset, ":");
385        result.append(bp, static_cast<std::size_t>(ep - bp));
386        pending = ++cur;
387      } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {
388        if (cur - 2 != pending) {
389          FormatTM(&result, std::string(pending, cur - 2), tm);
390        }
391        bp = FormatOffset(ep, al.offset, ":*");
392        result.append(bp, static_cast<std::size_t>(ep - bp));
393        pending = cur += 2;
394      } else if (*cur == '*' && cur + 1 != end &&
395                 (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
396        if (cur - 2 != pending) {
397          FormatTM(&result, std::string(pending, cur - 2), tm);
398        }
399        char* cp = ep;
400        bp = Format64(cp, 15, fs.count());
401        while (cp != bp && cp[-1] == '0') --cp;
402        switch (*(cur + 1)) {
403          case 'S':
404            if (cp != bp) *--bp = '.';
405            bp = Format02d(bp, al.cs.second());
406            break;
407          case 'f':
408            if (cp == bp) *--bp = '0';
409            break;
410        }
411        result.append(bp, static_cast<std::size_t>(cp - bp));
412        pending = cur += 2;
413      } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
414        if (cur - 2 != pending) {
415          FormatTM(&result, std::string(pending, cur - 2), tm);
416        }
417        bp = Format64(ep, 4, al.cs.year());
418        result.append(bp, static_cast<std::size_t>(ep - bp));
419        pending = cur += 2;
420      } else if (std::isdigit(*cur)) {
421        int n = 0;
422        if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
423          if (*np == 'S' || *np == 'f') {
424            if (cur - 2 != pending) {
425              FormatTM(&result, std::string(pending, cur - 2), tm);
426            }
427            bp = ep;
428            if (n > 0) {
429              if (n > kDigits10_64) n = kDigits10_64;
430              bp = Format64(bp, n,
431                            (n > 15) ? fs.count() * kExp10[n - 15]
432                                     : fs.count() / kExp10[15 - n]);
433              if (*np == 'S') *--bp = '.';
434            }
435            if (*np == 'S') bp = Format02d(bp, al.cs.second());
436            result.append(bp, static_cast<std::size_t>(ep - bp));
437            pending = cur = ++np;
438          }
439        }
440      }
441    }
442    if (end != pending) {
443      FormatTM(&result, std::string(pending, end), tm);
444    }
445    return result;
446  }
447  namespace {
448  const char* ParseOffset(const char* dp, const char* mode, int* offset) {
449    if (dp != nullptr) {
450      const char first = *dp++;
451      if (first == '+' || first == '-') {
452        char sep = mode[0];
453        int hours = 0;
454        int minutes = 0;
455        int seconds = 0;
456        const char* ap = ParseInt(dp, 2, 0, 23, &hours);
457        if (ap != nullptr && ap - dp == 2) {
458          dp = ap;
459          if (sep != '\0' && *ap == sep) ++ap;
460          const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
461          if (bp != nullptr && bp - ap == 2) {
462            dp = bp;
463            if (sep != '\0' && *bp == sep) ++bp;
464            const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
465            if (cp != nullptr && cp - bp == 2) dp = cp;
466          }
467          *offset = ((hours * 60 + minutes) * 60) + seconds;
468          if (first == '-') *offset = -*offset;
469        } else {
470          dp = nullptr;
471        }
472      } else if (first == 'Z' || first == 'z') {  
473        *offset = 0;
474      } else {
475        dp = nullptr;
476      }
477    }
478    return dp;
479  }
480  const char* ParseZone(const char* dp, std::string* zone) {
481    zone->clear();
482    if (dp != nullptr) {
483      while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
484      if (zone->empty()) dp = nullptr;
485    }
486    return dp;
487  }
488  const char* ParseSubSeconds(const char* dp, detail::femtoseconds* subseconds) {
489    if (dp != nullptr) {
490      std::int_fast64_t v = 0;
491      std::int_fast64_t exp = 0;
492      const char* const bp = dp;
493      while (const char* cp = strchr(kDigits, *dp)) {
494        int d = static_cast<int>(cp - kDigits);
495        if (d >= 10) break;
496        if (exp < 15) {
497          exp += 1;
498          v *= 10;
499          v += d;
500        }
501        ++dp;
502      }
503      if (dp != bp) {
504        v *= kExp10[15 - exp];
505        *subseconds = detail::femtoseconds(v);
506      } else {
507        dp = nullptr;
508      }
509    }
510    return dp;
511  }
512  const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
513    if (dp != nullptr) {
514      dp = strptime(dp, fmt, tm);
515    }
516    return dp;
517  }
518  bool FromWeek(int week_num, weekday week_start, year_t* year, std::tm* tm) {
519    const civil_year y(*year % 400);
520    civil_day cd = prev_weekday(y, week_start);  
521    cd = next_weekday(cd - 1, FromTmWday(tm->tm_wday)) + (week_num * 7);
522    if (const year_t shift = cd.year() - y.year()) {
523      if (shift > 0) {
524        if (*year > std::numeric_limits<year_t>::max() - shift) return false;
525      } else {
526        if (*year < std::numeric_limits<year_t>::min() - shift) return false;
527      }
528      *year += shift;
529    }
530    tm->tm_mon = cd.month() - 1;
531    tm->tm_mday = cd.day();
532    return true;
533  }
534  }  
535  bool parse(const std::string& format, const std::string& input,
536             const time_zone& tz, time_point<seconds>* sec,
537             detail::femtoseconds* fs, std::string* err) {
538    const char* data = input.c_str();  
539    while (std::isspace(*data)) ++data;
540    const year_t kyearmax = std::numeric_limits<year_t>::max();
541    const year_t kyearmin = std::numeric_limits<year_t>::min();
542    bool saw_year = false;
543    year_t year = 1970;
544    std::tm tm{};
545    tm.tm_year = 1970 - 1900;
546    tm.tm_mon = 1 - 1;  
547    tm.tm_mday = 1;
548    tm.tm_hour = 0;
549    tm.tm_min = 0;
550    tm.tm_sec = 0;
551    tm.tm_wday = 4;  
552    tm.tm_yday = 0;
553    tm.tm_isdst = 0;
554    auto subseconds = detail::femtoseconds::zero();
555    bool saw_offset = false;
556    int offset = 0;  
557    std::string zone = "UTC";
558    const char* fmt = format.c_str();  
559    bool twelve_hour = false;
560    bool afternoon = false;
561    int week_num = -1;
562    weekday week_start = weekday::sunday;
563    bool saw_percent_s = false;
564    std::int_fast64_t percent_s = 0;
565    while (data != nullptr && *fmt != '\0') {
566      if (std::isspace(*fmt)) {
567        while (std::isspace(*data)) ++data;
568        while (std::isspace(*++fmt)) continue;
569        continue;
570      }
571      if (*fmt != '%') {
572        if (*data == *fmt) {
573          ++data;
574          ++fmt;
575        } else {
576          data = nullptr;
577        }
578        continue;
579      }
580      const char* percent = fmt;
581      if (*++fmt == '\0') {
582        data = nullptr;
583        continue;
584      }
585      switch (*fmt++) {
586        case 'Y':
587          data = ParseInt(data, 0, kyearmin, kyearmax, &year);
588          if (data != nullptr) saw_year = true;
589          continue;
590        case 'm':
591          data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
592          if (data != nullptr) tm.tm_mon -= 1;
593          week_num = -1;
594          continue;
595        case 'd':
596        case 'e':
597          data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
598          week_num = -1;
599          continue;
600        case 'U':
601          data = ParseInt(data, 0, 0, 53, &week_num);
602          week_start = weekday::sunday;
603          continue;
604        case 'W':
605          data = ParseInt(data, 0, 0, 53, &week_num);
606          week_start = weekday::monday;
607          continue;
608        case 'u':
609          data = ParseInt(data, 0, 1, 7, &tm.tm_wday);
610          if (data != nullptr) tm.tm_wday %= 7;
611          continue;
612        case 'w':
613          data = ParseInt(data, 0, 0, 6, &tm.tm_wday);
614          continue;
615        case 'H':
616          data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
617          twelve_hour = false;
618          continue;
619        case 'M':
620          data = ParseInt(data, 2, 0, 59, &tm.tm_min);
621          continue;
622        case 'S':
623          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
624          continue;
625        case 'I':
626        case 'l':
627        case 'r':  
628          twelve_hour = true;
629          break;
630        case 'R':  
631        case 'T':  
632        case 'c':  
633        case 'X':  
634          twelve_hour = false;
635          break;
636        case 'z':
637          data = ParseOffset(data, "", &offset);
638          if (data != nullptr) saw_offset = true;
639          continue;
640        case 'Z':  
641          data = ParseZone(data, &zone);
642          continue;
643        case 's':
644          data =
645              ParseInt(data, 0, std::numeric_limits<std::int_fast64_t>::min(),
646                       std::numeric_limits<std::int_fast64_t>::max(), &percent_s);
647          if (data != nullptr) saw_percent_s = true;
648          continue;
649        case ':':
650          if (fmt[0] == 'z' ||
651              (fmt[0] == ':' &&
652               (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {
653            data = ParseOffset(data, ":", &offset);
654            if (data != nullptr) saw_offset = true;
655            fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;
656            continue;
657          }
658          break;
659        case '%':
660          data = (*data == '%' ? data + 1 : nullptr);
661          continue;
662        case 'E':
663          if (fmt[0] == 'T') {
664            if (*data == 'T' || *data == 't') {
665              ++data;
666              ++fmt;
667            } else {
668              data = nullptr;
669            }
670            continue;
671          }
672          if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {
673            data = ParseOffset(data, ":", &offset);
674            if (data != nullptr) saw_offset = true;
675            fmt += (fmt[0] == 'z') ? 1 : 2;
676            continue;
677          }
678          if (fmt[0] == '*' && fmt[1] == 'S') {
679            data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
680            if (data != nullptr && *data == '.') {
681              data = ParseSubSeconds(data + 1, &subseconds);
682            }
683            fmt += 2;
684            continue;
685          }
686          if (fmt[0] == '*' && fmt[1] == 'f') {
687            if (data != nullptr && std::isdigit(*data)) {
688              data = ParseSubSeconds(data, &subseconds);
689            }
690            fmt += 2;
691            continue;
692          }
693          if (fmt[0] == '4' && fmt[1] == 'Y') {
694            const char* bp = data;
695            data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);
696            if (data != nullptr) {
697              if (data - bp == 4) {
698                saw_year = true;
699              } else {
700                data = nullptr;  
701              }
702            }
703            fmt += 2;
704            continue;
705          }
706          if (std::isdigit(*fmt)) {
707            int n = 0;  
708            if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
709              if (*np == 'S') {
710                data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
711                if (data != nullptr && *data == '.') {
712                  data = ParseSubSeconds(data + 1, &subseconds);
713                }
714                fmt = ++np;
715                continue;
716              }
717              if (*np == 'f') {
718                if (data != nullptr && std::isdigit(*data)) {
719                  data = ParseSubSeconds(data, &subseconds);
720                }
721                fmt = ++np;
722                continue;
723              }
724            }
725          }
726          if (*fmt == 'c') twelve_hour = false;  
727          if (*fmt == 'X') twelve_hour = false;  
728          if (*fmt != '\0') ++fmt;
729          break;
730        case 'O':
731          if (*fmt == 'H') twelve_hour = false;
732          if (*fmt == 'I') twelve_hour = true;
733          if (*fmt != '\0') ++fmt;
734          break;
735      }
736      const char* orig_data = data;
737      std::string spec(percent, static_cast<std::size_t>(fmt - percent));
738      data = ParseTM(data, spec.c_str(), &tm);
739      if (spec == "%p" && data != nullptr) {
740        std::string test_input = "1";
741        test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));
742        const char* test_data = test_input.c_str();
743        std::tm tmp{};
744        ParseTM(test_data, "%I%p", &tmp);
745        afternoon = (tmp.tm_hour == 13);
746      }
747    }
748    if (twelve_hour && afternoon && tm.tm_hour < 12) {
749      tm.tm_hour += 12;
750    }
751    if (data == nullptr) {
752      if (err != nullptr) *err = "Failed to parse input";
753      return false;
754    }
755    while (std::isspace(*data)) ++data;
756    if (*data != '\0') {
757      if (err != nullptr) *err = "Illegal trailing data in input string";
758      return false;
759    }
760    if (saw_percent_s) {
761      *sec = FromUnixSeconds(percent_s);
762      *fs = detail::femtoseconds::zero();
763      return true;
764    }
765    time_zone ptz = saw_offset ? utc_time_zone() : tz;
766    if (tm.tm_sec == 60) {
767      tm.tm_sec -= 1;
768      offset -= 1;
769      subseconds = detail::femtoseconds::zero();
770    }
771    if (!saw_year) {
772      year = year_t{tm.tm_year};
773      if (year > kyearmax - 1900) {
774        if (err != nullptr) *err = "Out-of-range year";
775        return false;
776      }
777      year += 1900;
778    }
779    if (week_num != -1) {
780      if (!FromWeek(week_num, week_start, &year, &tm)) {
781        if (err != nullptr) *err = "Out-of-range field";
782        return false;
783      }
784    }
785    const int month = tm.tm_mon + 1;
786    civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
787    if (cs.month() != month || cs.day() != tm.tm_mday) {
788      if (err != nullptr) *err = "Out-of-range field";
789      return false;
790    }
791    if ((offset < 0 && cs > civil_second::max() + offset) ||
792        (offset > 0 && cs < civil_second::min() + offset)) {
793      if (err != nullptr) *err = "Out-of-range field";
794      return false;
795    }
796    cs -= offset;
797    const auto tp = ptz.lookup(cs).pre;
798    if (tp == time_point<seconds>::max()) {
799      const auto al = ptz.lookup(time_point<seconds>::max());
800      if (cs > al.cs) {
801        if (err != nullptr) *err = "Out-of-range field";
802        return false;
803      }
804    }
805    if (tp == time_point<seconds>::min()) {
806      const auto al = ptz.lookup(time_point<seconds>::min());
807      if (cs < al.cs) {
808        if (err != nullptr) *err = "Out-of-range field";
809        return false;
810      }
811    }
812    *sec = tp;
813    *fs = subseconds;
814    return true;
815  }
816  }  
817  }  
818  }  
819  ABSL_NAMESPACE_END
820  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-settings.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</div>
                </div>
                <div class="column column_space"><pre><code>681          switch(hash_(log_level))
682          {
683          case "warn"_hash:
684              global.logLevel = LOG_LEVEL_WARNING;
685              break;
686          case "error"_hash:
687              global.logLevel = LOG_LEVEL_ERROR;
688              break;
689          case "fatal"_hash:
</pre></code></div>
                <div class="column column_space"><pre><code>279        switch (*cur) {
280          case 'Y':
281            bp = Format64(ep, 0, al.cs.year());
282            result.append(bp, static_cast<std::size_t>(ep - bp));
283            break;
284          case 'm':
285            bp = Format02d(ep, al.cs.month());
286            result.append(bp, static_cast<std::size_t>(ep - bp));
287            break;
288          case 'd':
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    