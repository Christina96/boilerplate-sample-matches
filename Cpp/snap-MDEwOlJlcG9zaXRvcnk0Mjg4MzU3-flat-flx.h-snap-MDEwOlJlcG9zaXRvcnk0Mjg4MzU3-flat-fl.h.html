
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.h</h3>
            <pre><code>1  class TMem;
2  class TChA;
3  class TStr;
4  class TCs{
5  private:
6    static const int MxMask;
7    int Val;
8  public:
9    TCs(): Val(0){}
10    TCs(const TCs& Cs): Val(Cs.Val&MxMask){}
11    TCs(const int& Int): Val(Int&MxMask){}
12    TCs& operator=(const TCs& Cs){Val=Cs.Val; return *this;}
13    bool operator==(const TCs& Cs) const {return Val==Cs.Val;}
14    TCs& TCs::operator+=(const TCs& Cs){Val=(Val+Cs.Val)&MxMask; return *this;}
15    TCs& TCs::operator+=(const char& Ch){Val=(Val+Ch)&MxMask; return *this;}
16    TCs& TCs::operator+=(const int& Int){Val=(Val+Int)&MxMask; return *this;}
17    int Get() const {return Val;}
18    static TCs GetCsFromBf(char* Bf, const int& BfL);
19  };
20  class TSOutMnp {
21  public:
22    virtual TSOut& operator()(TSOut& SOut) const=0;
23  };
24  class TSBase{
25  protected:
26    TCRef CRef;
27    TSStr SNm;
28    TCs Cs;
29  protected:
30    TSBase(){}
31    TSBase(const TSBase&);
32    TSBase& operator=(const TSBase&);
33  public:
34    TSBase(const TSStr& Nm): SNm(Nm){}
35    virtual ~TSBase(){}
36    virtual TStr GetSNm() const;
37  };
38  class TSIn: virtual public TSBase{
39  private:
40    bool FastMode;
41  private:
42    TSIn(const TSIn&);
43    TSIn& operator=(const TSIn&);
44  public:
45    TSIn(): TSBase("Input-Stream"), FastMode(false){}
46    TSIn(const TStr& Str);
47    virtual ~TSIn(){}
48    virtual bool Eof() const=0; 
49    virtual int Len() const=0; 
50    virtual char GetCh()=0; 
51    virtual char PeekCh()=0; 
52    virtual int GetBf(const void* Bf, const int& BfL)=0;
53    bool IsFastMode() const {return FastMode;}
54    void SetFastMode(const bool& _FastMode){FastMode=_FastMode;}
55    void LoadCs();
56    void LoadBf(const void* Bf, const int& BfL){Cs+=GetBf(Bf, BfL);}
57    void* LoadNewBf(const int& BfL){
58      void* Bf=(void*)new char[BfL]; Cs+=GetBf(Bf, BfL); return Bf;}
59    void Load(bool& Bool){Cs+=GetBf(&Bool, sizeof(Bool));}
60    void Load(uchar& UCh){Cs+=GetBf(&UCh, sizeof(UCh));}
61    void Load(char& Ch){Cs+=GetBf(&Ch, sizeof(Ch));}
62    void Load(short& Short){Cs+=GetBf(&Short, sizeof(Short));} 
63    void Load(ushort& UShort){Cs+=GetBf(&UShort, sizeof(UShort));} 
64    void Load(int& Int){Cs+=GetBf(&Int, sizeof(Int));}
65    void Load(uint& UInt){Cs+=GetBf(&UInt, sizeof(UInt));}
66    void Load(int64& Int){Cs+=GetBf(&Int, sizeof(Int));}
67    void Load(uint64& UInt){Cs+=GetBf(&UInt, sizeof(UInt));}
68    void Load(double& Flt){Cs+=GetBf(&Flt, sizeof(Flt));}
69    void Load(sdouble& SFlt){Cs+=GetBf(&SFlt, sizeof(SFlt));}
70    void Load(ldouble& LFlt){Cs+=GetBf(&LFlt, sizeof(LFlt));}
71    void Load(char*& CStr, const int& MxCStrLen, const int& CStrLen){
72      CStr=new char[MxCStrLen+1]; Cs+=GetBf(CStr, CStrLen+1);}
73    void Load(char*& CStr);
74    TSIn& operator>>(bool& Bool){Cs+=GetBf(&Bool, sizeof(Bool)); return *this;}
75    TSIn& operator>>(uchar& UCh){Cs+=GetBf(&UCh, sizeof(UCh)); return *this;}
76    TSIn& operator>>(char& Ch){Cs+=GetBf(&Ch, sizeof(Ch)); return *this;}
77    TSIn& operator>>(short& Sh){Cs+=GetBf(&Sh, sizeof(Sh)); return *this;}
78    TSIn& operator>>(ushort& USh){Cs+=GetBf(&USh, sizeof(USh)); return *this;}
79    TSIn& operator>>(int& Int){Cs+=GetBf(&Int, sizeof(Int)); return *this;}
80    TSIn& operator>>(uint& UInt){Cs+=GetBf(&UInt, sizeof(UInt)); return *this;}
81    TSIn& operator>>(int64& Int){Cs+=GetBf(&Int, sizeof(Int)); return *this;}
82    TSIn& operator>>(uint64& UInt){Cs+=GetBf(&UInt, sizeof(UInt)); return *this;}
83    TSIn& operator>>(float& Flt){Cs+=GetBf(&Flt, sizeof(Flt)); return *this;}
84    TSIn& operator>>(double& Double){Cs+=GetBf(&Double, sizeof(Double)); return *this;}
85    TSIn& operator>>(long double& LDouble){Cs+=GetBf(&LDouble, sizeof(LDouble)); return *this;}
86    static const TPt<TSIn> StdIn;
87    friend class TPt<TSIn>;
88  };
89  typedef TPt<TSIn> PSIn;
90  template <class T>
91  TSIn& operator>>(TSIn& SIn, T& Val) {
92    Val.Load(SIn); return SIn;
93  }
94  class TSOut: virtual public TSBase{
95  private:
96    int MxLnLen, LnLen;
97    int UpdateLnLen(const int& StrLen, const bool& ForceInLn=false);
98  private:
99    TSOut(const TSIn&);
100    TSOut& operator = (const TSOut&);
101  public:
102    TSOut(): TSBase("Output-Stream"), MxLnLen(-1), LnLen(0){}
103    TSOut(const TStr& Str);
104    virtual ~TSOut(){}
105    void EnableLnTrunc(const int& _MxLnLen){MxLnLen=_MxLnLen;}
106    void DisableLnTrunc(){MxLnLen=-1;}
107    virtual int PutCh(const char& Ch)=0;
108    virtual int PutBf(const void* LBf, const int& LBfL)=0;
109    virtual void Flush()=0;
110    virtual TFileId GetFileId() const {return NULL;}
111    int PutMem(const TMem& Mem);
112    int PutCh(const char& Ch, const int& Chs);
113    int PutBool(const bool& Bool);
114    int PutInt(const int& Int);
115    int PutInt(const int& Int, char* FmtStr);
116    int PutUInt(const uint& Int);
117    int PutUInt(const uint& Int, char* FmtStr);
118    int PutFlt(const double& Flt);
119    int PutFlt(const double& Flt, char* FmtStr);
<span onclick='openModal()' class='match'>120    int PutStr(const char* CStr);
121    int PutStr(const TChA& ChA);
122    int PutStr(const TStr& Str, char* FmtStr);
</span>123    int PutStr(const TStr& Str, const bool& ForceInLn=false);
124    int PutStrLn(const TStr& Str, const bool& ForceInLn=false){
125      int Cs=PutStr(Str,ForceInLn); Cs+=PutLn(); return Cs;}
126    int PutIndent(const int& IndentLev=1);
127    int PutLn(const int& Lns=1);
128    int PutDosLn(const int& Lns=1);
129    int PutSep(const int& NextStrLen=0);
130    int PutSepLn(const int& Lns=0);
131    void SaveCs(){Cs+=PutBf(&Cs, sizeof(Cs));}
132    void SaveBf(const void* Bf, const int& BfL){Cs+=PutBf(Bf, BfL);}
133    void Save(const bool& Bool){Cs+=PutBf(&Bool, sizeof(Bool));}
134    void Save(const char& Ch){Cs+=PutBf(&Ch, sizeof(Ch));}
135    void Save(const uchar& UCh){Cs+=PutBf(&UCh, sizeof(UCh));}
136    void Save(const short& Short){Cs+=PutBf(&Short, sizeof(Short));}
137    void Save(const ushort& UShort){Cs+=PutBf(&UShort, sizeof(UShort));}
138    void Save(const int& Int){Cs+=PutBf(&Int, sizeof(Int));}
139    void Save(const uint& UInt){Cs+=PutBf(&UInt, sizeof(UInt));}
140    void Save(const int64& Int){Cs+=PutBf(&Int, sizeof(Int));}
141    void Save(const uint64& UInt){Cs+=PutBf(&UInt, sizeof(UInt));}
142    void Save(const double& Flt){Cs+=PutBf(&Flt, sizeof(Flt));}
143    void Save(const sdouble& SFlt){Cs+=PutBf(&SFlt, sizeof(SFlt));}
144    void Save(const ldouble& LFlt){Cs+=PutBf(&LFlt, sizeof(LFlt));}
145    void Save(const char* CStr, const int& CStrLen){Cs+=PutBf(CStr, CStrLen+1);}
146    void Save(const char* CStr);
147    void Save(TSIn& SIn, const int& BfL=-1);
148    void Save(const PSIn& SIn, const int& BfL=-1){Save(*SIn, BfL);}
149    void Save(const void* Bf, const int& BfL){Cs+=PutBf(Bf, BfL);}
150    TSOut& operator<<(const bool& Bool){Cs+=PutBf(&Bool, sizeof(Bool)); return *this;}
151    TSOut& operator<<(const uchar& UCh){Cs+=PutBf(&UCh, sizeof(UCh)); return *this;}
152    TSOut& operator<<(const char& Ch){Cs+=PutBf(&Ch, sizeof(Ch)); return *this;}
153    TSOut& operator<<(const short& Sh){Cs+=PutBf(&Sh, sizeof(Sh)); return *this;}
154    TSOut& operator<<(const ushort& USh){Cs+=PutBf(&USh, sizeof(USh)); return *this;}
155    TSOut& operator<<(const int& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
156    TSOut& operator<<(const uint& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
157    TSOut& operator<<(const int64& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
158    TSOut& operator<<(const uint64& UInt){Cs+=PutBf(&UInt, sizeof(UInt)); return *this;}
159    TSOut& operator<<(const float& Flt){Cs+=PutBf(&Flt, sizeof(Flt)); return *this;}
160    TSOut& operator<<(const double& Double){Cs+=PutBf(&Double, sizeof(Double)); return *this;}
161    TSOut& operator<<(const long double& LDouble){Cs+=PutBf(&LDouble, sizeof(LDouble)); return *this;}
162    TSOut& operator<<(const TSOutMnp& Mnp){return Mnp(*this);}
163    TSOut& operator<<(TSOut&(*FuncPt)(TSOut&)){return FuncPt(*this);}
164    TSOut& operator<<(TSIn& SIn);
165    TSOut& operator<<(PSIn& SIn){return operator<<(*SIn);}
166    static const TPt<TSOut> StdOut;
167    friend class TPt<TSOut>;
168  };
169  typedef TPt<TSOut> PSOut;
170  template <class T>
171  TSOut& operator<<(TSOut& SOut, const T& Val){
172    Val.Save(SOut); return SOut;
173  }
174  class TSInOut: public TSIn, public TSOut{
175  private:
176    TSInOut(const TSInOut&);
177    TSInOut& operator=(const TSInOut&);
178  public:
179    TSInOut(): TSBase("Input-Output-Stream"), TSIn(), TSOut() {}
180    virtual ~TSInOut(){}
181    virtual void SetPos(const int& Pos)=0;
182    virtual void MovePos(const int& DPos)=0;
183    virtual int GetPos() const=0;
184    virtual int GetSize() const=0; 
185    virtual void Clr()=0; 
186    friend class TPt<TSInOut>;
187  };
188  typedef TPt<TSInOut> PSInOut;
189  class TStdIn: public TSIn{
190  private:
191    TStdIn(const TStdIn&);
192    TStdIn& operator=(const TStdIn&);
193  public:
194    TStdIn(): TSBase("Standard input"), TSIn() {}
195    bool Eof() const {return feof(stdin)!=0;}
196    int Len() const {return -1;}
197    char GetCh(){return char(getchar());}
198    char PeekCh(){
199      int Ch=getchar(); ungetc(Ch, stdin); return char(Ch);}
200    int GetBf(const void* LBf, const int& LBfL);
201  };
202  class TStdOut: public TSOut{
203  private:
204    TStdOut(const TStdOut&);
205    TStdOut& operator=(const TStdOut&);
206  public:
207    TStdOut(): TSBase(TSStr("Standard output")), TSOut(){}
208    int PutCh(const char& Ch){putchar(Ch); return Ch;}
209    int PutBf(const void *LBf, const int& LBfL);
210    void Flush(){fflush(stdout);}
211  };
212  class TFIn: public TSIn{
213  private:
214    static const int MxBfL;
215    TFileId FileId;
216    char* Bf;
217    int BfC, BfL;
218  public:
219    void SetFPos(const int& FPos) const;
220    int GetFPos() const;
221    int GetFLen() const;
222  private:
223    void FillBf();
224  private:
225    TFIn();
226    TFIn(const TFIn&);
227    TFIn& operator=(const TFIn&);
228  public:
229    TFIn(const TStr& FNm);
230    TFIn(const TStr& FNm, bool& OpenedP);
231    static PSIn New(const TStr& FNm);
232    static PSIn New(const TStr& FNm, bool& OpenedP);
233    ~TFIn();
234    bool Eof() const {return (BfC==BfL)&&(BfL<MxBfL);}
235    int Len() const {return GetFLen()-(GetFPos()-BfL+BfC);}
236    char GetCh(){if (BfC==BfL){FillBf();} return Bf[BfC++];}
237    char PeekCh(){if (BfC==BfL){FillBf();} return Bf[BfC];}
238    int GetBf(const void* LBf, const int& LBfL);
239  };
240  class TFOut: public TSOut{
241  private:
242    static const int MxBfL;
243    TFileId FileId;
244    char* Bf;
245    int BfL;
246  private:
247    void FlushBf();
248  private:
249    TFOut();
250    TFOut(const TFOut&);
251    TFOut& operator=(const TFOut&);
252  public:
253    TFOut(const TStr& _FNm, const bool& Append=false);
254    TFOut(const TStr& _FNm, const bool& Append, bool& OpenedP);
255    static PSOut New(const TStr& FNm, const bool& Append=false);
256    static PSOut New(const TStr& FNm, const bool& Append, bool& OpenedP);
257    ~TFOut();
258    int PutCh(const char& Ch);
259    int PutBf(const void* LBf, const int& LBfL);
260    void Flush();
261    TFileId GetFileId() const {return FileId;}
262  };
263  typedef enum {faUndef, faCreate, faUpdate, faAppend, faRdOnly, faRestore} TFAccess;
264  class TFInOut : public TSInOut {
265  private:
266    TFileId FileId;
267  private:
268    TFInOut();
269    TFInOut(const TFIn&);
270    TFInOut& operator=(const TFIn&);
271  public:
272    TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo);
273    static PSInOut New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo);
274    ~TFInOut() { if (FileId!=NULL) IAssert(fclose(FileId) == 0); }
275    TStr GetFNm() const;
276    TFileId GetFileId() const {return FileId;}
277    bool Eof() const { return feof(FileId) != 0; }
278    int Len() const { return GetSize() - GetPos(); } 
279    char GetCh() { return char(fgetc(FileId)); }
280    char PeekCh() { const char Ch = GetCh();  MovePos(-1);  return Ch; }
281    int GetBf(const void* LBf, const int& LBfL);
282    void SetPos(const int& Pos) { IAssert(fseek(FileId, Pos, SEEK_SET)==0); }
283    void MovePos(const int& DPos) { IAssert(fseek(FileId, DPos, SEEK_CUR)==0); }
284    int GetPos() const { return ftell(FileId); }
285    int GetSize() const;
286    void Clr() { Fail; }
287    int PutCh(const char& Ch) { return PutBf(&Ch, sizeof(Ch)); }
288    int PutBf(const void* LBf, const int& LBfL);
289    void Flush() { IAssert(fflush(FileId) == 0); }
290  };
291  class TMIn: public TSIn{
292  private:
293    char* Bf;
294    int BfC, BfL;
295    bool Free;
296  private:
297    TMIn();
298    TMIn(const TMIn&);
299    TMIn& operator=(const TMIn&);
300  public:
301    TMIn(const void* _Bf, const int& _BfL, const bool& TakeBf=false, const bool& _Free=true);
302    TMIn(TSIn& SIn);
303    TMIn(const char* CStr);
304    TMIn(const TStr& Str);
305    TMIn(const TChA& ChA);
306    static PSIn New(const char* CStr);
307    static PSIn New(const TStr& Str);
308    static PSIn New(const TChA& ChA);
309    ~TMIn(){if (Bf!=NULL&&Free){delete[] Bf;}}
310    bool Eof() const {return BfC==BfL;}
311    int Len() const {return BfL-BfC;}
312    char GetCh();
313    char PeekCh();
314    int GetBf(const void* LBf, const int& LBfL);
315    char* GetBfAddr(){return Bf;}
316  };
317  class TMOut: public TSOut{
318  private:
319    char* Bf;
320    int BfL, MxBfL;
321    bool OwnBf;
322    void Resize();
323  private:
324    TMOut(const TMOut&);
325    TMOut& operator=(const TMOut&);
326  public:
327    TMOut(const int& _MxBfL=1024);
328    static PSOut New(const int& MxBfL=1024){
329      return PSOut(new TMOut(MxBfL));}
330    TMOut(char* _Bf, const int& _MxBfL);
331    ~TMOut(){if (OwnBf&&(Bf!=NULL)){delete[] Bf;}}
332    int PutCh(const char& Ch){if (BfL==MxBfL){
333      Resize();} return Bf[BfL++]=Ch;}
334    int PutBf(const void* LBf, const int& LBfL);
335    void Flush(){}
336    int Len() const {return BfL;}
337    void Clr(){BfL=0;}
338    char GetCh(const int& ChN) const {
339      IAssert((0<=ChN)&&(ChN<BfL)); return Bf[ChN];}
340    TStr GetAsStr() const;
341    void CutBf(const int& CutBfL);
342    PSIn GetSIn(const bool& IsCut=true, const int& CutBfL=-1);
343    char* GetBfAddr() const {return Bf;}
344    bool IsCrLfLn() const;
345    TStr GetCrLfLn();
346    bool IsEolnLn() const;
347    TStr GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf);
348    void MkEolnLn();
349  };
350  class TChRet{
351  private:
352    PSIn SIn;
353    char EofCh;
354    char Ch;
355  private:
356    TChRet();
357    TChRet(const TChRet&);
358    TChRet& operator=(const TChRet&);
359  public:
360    TChRet(const PSIn& _SIn, const char& _EofCh=0):
361      SIn(_SIn), EofCh(_EofCh), Ch(_EofCh){}
362    bool Eof() const {return Ch==EofCh;}
363    char GetCh(){
364      if (SIn->Eof()){return Ch=EofCh;} else {return Ch=SIn->GetCh();}}
365    char operator()(){return Ch;}
366  };
367  ClassTP(TFRnd, PFRnd)
368  private:
369    TFileId FileId;
370    TSStr FNm;
371    bool RecAct;
372    int HdLen, RecLen;
373  private:
374    void RefreshFPos();
375  private:
376    TFRnd(const TFRnd&);
377    TFRnd& operator=(const TFRnd&);
378  public:
379    TFRnd(const TStr& _FNm, const TFAccess& FAccess,
380     const bool& CreateIfNo=true, const int& _HdLen=-1, const int& _RecLen=-1);
381    static PFRnd New(const TStr& FNm,
382     const TFAccess& FAccess, const bool& CreateIfNo=true,
383     const int& HdLen=-1, const int& RecLen=-1){
384      return new TFRnd(FNm, FAccess, CreateIfNo, HdLen, RecLen);}
385    ~TFRnd();
386    TStr GetFNm() const;
387    void SetHdRecLen(const int& _HdLen, const int& _RecLen){
388      HdLen=_HdLen; RecLen=_RecLen; RecAct=(HdLen>=0)&&(RecLen>0);}
389    void SetFPos(const int& FPos);
390    void MoveFPos(const int& DFPos);
391    int GetFPos();
392    int GetFLen();
393    bool Empty(){return GetFLen()==0;}
394    bool Eof(){return GetFPos()==GetFLen();}
395    void SetRecN(const int& RecN);
396    int GetRecN();
397    int GetRecs();
398    void GetBf(void* Bf, const int& BfL);
399    void PutBf(const void* Bf, const int& BfL);
400    void Flush();
401    void GetHd(void* Hd){IAssert(RecAct);
402      int FPos=GetFPos(); SetFPos(0); GetBf(Hd, HdLen); SetFPos(FPos);}
403    void PutHd(const void* Hd){IAssert(RecAct);
404      int FPos=GetFPos(); SetFPos(0); PutBf(Hd, HdLen); SetFPos(FPos);}
405    void GetRec(void* Rec, const int& RecN=-1){
406      IAssert(RecAct); if (RecN!=-1){SetRecN(RecN);} GetBf(Rec, RecLen);}
407    void PutRec(const void* Rec, const int& RecN=-1){
408      IAssert(RecAct); if (RecN!=-1){SetRecN(RecN);} PutBf(Rec, RecLen);}
409    void PutCs(const TCs& Cs){PutBf(&Cs, sizeof(Cs));}
410    TCs GetCs(){TCs Cs; GetBf(&Cs, sizeof(Cs)); return Cs;}
411    void PutCh(const char& Ch){PutBf(&Ch, sizeof(Ch));}
412    void PutCh(const char& Ch, const int& Chs);
413    char GetCh(){char Ch; GetBf(&Ch, sizeof(Ch)); return Ch;}
414    void PutUCh(const uchar& UCh){PutBf(&UCh, sizeof(UCh));}
415    uchar GetUCh(){uchar UCh; GetBf(&UCh, sizeof(UCh)); return UCh;}
416    void PutInt(const int& Int){PutBf(&Int, sizeof(Int));}
417    int GetInt(){int Int; GetBf(&Int, sizeof(Int)); return Int;}
418    void PutUInt(const uint& UInt){PutBf(&UInt, sizeof(UInt));}
419    uint GetUInt(){uint UInt; GetBf(&UInt, sizeof(UInt)); return UInt;}
420    void PutStr(const TStr& Str);
421    TStr GetStr(const int& StrLen);
422    TStr GetStr(const int& MxStrLen, bool& IsOk);
423    void PutSIn(const PSIn& SIn, TCs& Cs);
424    PSIn GetSIn(const int& SInLen, TCs& Cs);
425    static TStr GetStrFromFAccess(const TFAccess& FAccess);
426    static TFAccess GetFAccessFromStr(const TStr& Str);
427  };
428  class TFile{
429  public:
430    static const TStr TxtFExt;
431    static const TStr HtmlFExt;
432    static const TStr HtmFExt;
433    static const TStr GifFExt;
434    static const TStr JarFExt;
435  public:
436    static bool Exists(const TStr& FNm);
437    static void Del(const TStr& FNm, const bool& ThrowExceptP=true);
438    static void DelWc(const TStr& WcStr, const bool& RecurseDirP=false);
439    static void Rename(const TStr& SrcFNm, const TStr& DstFNm);
440    static TStr GetUniqueFNm(const TStr& FNm);
441  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.h</h3>
            <pre><code>1  #include "bd.h"
2  class TMem;
3  class TChA;
4  class TStr;
5  class TCs{
6  private:
7    static const int MxMask;
8    int Val;
9  public:
10    TCs(): Val(0){}
11    TCs(const TCs& Cs): Val(Cs.Val&MxMask){}
12    TCs(const int& Int): Val(Int&MxMask){}
13    TCs& operator=(const TCs& Cs){Val=Cs.Val; return *this;}
14    bool operator==(const TCs& Cs) const {return Val==Cs.Val;}
15    TCs& operator+=(const TCs& Cs){Val=(Val+Cs.Val)&MxMask; return *this;}
16    TCs& operator+=(const char& Ch){Val=(Val+Ch)&MxMask; return *this;}
17    TCs& operator+=(const int& Int){Val=(Val+Int)&MxMask; return *this;}
18    int Get() const {return Val;}
19    static TCs GetCsFromBf(char* Bf, const int& BfL);
20  };
21  class TSOutMnp {
22  public:
23    virtual TSOut& operator()(TSOut& SOut) const=0;
24    virtual ~TSOutMnp();
25  };
26  class TSBase{
27  protected:
28    TCRef CRef;
29    TSStr SNm;
30    TCs Cs;
31  public:
32    TSBase(const TSStr& Nm): SNm(Nm){}
33    virtual ~TSBase(){}
34    virtual TStr GetSNm() const;
35  };
36  class TSIn: virtual public TSBase{
37  private:
38    bool FastMode;
39  private:
40    TSIn(const TSIn&);
41    TSIn& operator=(const TSIn&);
42  public:
43    TSIn(): TSBase("Input-Stream"), FastMode(false){}
44    TSIn(const TStr& Str);
45    virtual ~TSIn(){}
46    virtual bool Eof()=0; 
47    virtual int Len() const=0;  
48    virtual char GetCh()=0;     
49    virtual char PeekCh()=0;    
50    virtual int GetBf(const void* Bf, const TSize& BfL)=0; 
51    virtual bool GetNextLnBf(TChA& LnChA)=0;  
52    virtual void Reset(){Fail;}
53    bool IsFastMode() const {return FastMode;}
54    void SetFastMode(const bool& _FastMode){FastMode=_FastMode;}
55    virtual void LoadCs();
56    void LoadBf(const void* Bf, const TSize& BfL){Cs+=GetBf(Bf, BfL);}
57    void* LoadNewBf(const int& BfL){
58      void* Bf=(void*)new char[BfL]; Cs+=GetBf(Bf, BfL); return Bf;}
59    void Load(bool& Bool){Cs+=GetBf(&Bool, sizeof(Bool));}
60    void Load(uchar& UCh){Cs+=GetBf(&UCh, sizeof(UCh));}
61    void Load(char& Ch){Cs+=GetBf(&Ch, sizeof(Ch));}
62    void Load(short& Short){Cs+=GetBf(&Short, sizeof(Short));} 
63    void Load(ushort& UShort){Cs+=GetBf(&UShort, sizeof(UShort));} 
64    void Load(int& Int){Cs+=GetBf(&Int, sizeof(Int));}
65    void Load(uint& UInt){Cs+=GetBf(&UInt, sizeof(UInt));}
66    void Load(int64& Int){Cs+=GetBf(&Int, sizeof(Int));}
67    void Load(uint64& UInt){Cs+=GetBf(&UInt, sizeof(UInt));}
68    void Load(double& Flt){Cs+=GetBf(&Flt, sizeof(Flt));}
69    void Load(sdouble& SFlt){Cs+=GetBf(&SFlt, sizeof(SFlt));}
70    void Load(ldouble& LFlt){Cs+=GetBf(&LFlt, sizeof(LFlt));}
71    void Load(char*& CStr, const int& MxCStrLen, const int& CStrLen){
72      CStr=new char[MxCStrLen+1]; Cs+=GetBf(CStr, CStrLen+1);}
73    void Load(char*& CStr);
74    TSIn& operator>>(bool& Bool){Cs+=GetBf(&Bool, sizeof(Bool)); return *this;}
75    TSIn& operator>>(uchar& UCh){Cs+=GetBf(&UCh, sizeof(UCh)); return *this;}
76    TSIn& operator>>(char& Ch){Cs+=GetBf(&Ch, sizeof(Ch)); return *this;}
77    TSIn& operator>>(short& Sh){Cs+=GetBf(&Sh, sizeof(Sh)); return *this;}
78    TSIn& operator>>(ushort& USh){Cs+=GetBf(&USh, sizeof(USh)); return *this;}
79    TSIn& operator>>(int& Int){Cs+=GetBf(&Int, sizeof(Int)); return *this;}
80    TSIn& operator>>(uint& UInt){Cs+=GetBf(&UInt, sizeof(UInt)); return *this;}
81    TSIn& operator>>(int64& Int){Cs+=GetBf(&Int, sizeof(Int)); return *this;}
82    TSIn& operator>>(uint64& UInt){Cs+=GetBf(&UInt, sizeof(UInt)); return *this;}
83    TSIn& operator>>(float& Flt){Cs+=GetBf(&Flt, sizeof(Flt)); return *this;}
84    TSIn& operator>>(double& Double){Cs+=GetBf(&Double, sizeof(Double)); return *this;}
85    TSIn& operator>>(long double& LDouble){Cs+=GetBf(&LDouble, sizeof(LDouble)); return *this;}
86    bool GetNextLn(TStr& LnStr);
87    bool GetNextLn(TChA& LnChA);
88    static const TPt<TSIn> StdIn;
89    friend class TPt<TSIn>;
90  };
91  typedef TPt<TSIn> PSIn;
92  template <class T>
93  TSIn& operator>>(TSIn& SIn, T& Val) {
94    Val.Load(SIn); return SIn;
95  }
96  class TSOut: virtual public TSBase{
97  private:
98    int MxLnLen, LnLen;
99    int UpdateLnLen(const int& StrLen, const bool& ForceInLn=false);
100  private:
101    TSOut(const TSIn&);
102    TSOut& operator = (const TSOut&);
103  public:
104    TSOut(): TSBase("Output-Stream"), MxLnLen(-1), LnLen(0){}
105    TSOut(const TStr& Str);
106    virtual ~TSOut(){}
107    void EnableLnTrunc(const int& _MxLnLen){MxLnLen=_MxLnLen;}
108    void DisableLnTrunc(){MxLnLen=-1;}
109    virtual int PutCh(const char& Ch)=0;
110    virtual int PutBf(const void* LBf, const TSize& LBfL)=0;
111    virtual void Flush()=0;
112    virtual TFileId GetFileId() const {return NULL;}
113    int PutMem(const TMem& Mem);
114    int PutCh(const char& Ch, const int& Chs);
115    int PutBool(const bool& Bool);
116    int PutInt(const int& Int);
117    int PutInt(const int& Int, const char* FmtStr);
118    int PutUInt(const uint& Int);
119    int PutUInt(const uint& Int, const char* FmtStr);
120    int PutFlt(const double& Flt);
121    int PutFlt(const double& Flt, const char* FmtStr);
<span onclick='openModal()' class='match'>122    int PutStr(const char* CStr);
123    int PutStr(const TChA& ChA);
124    int PutStr(const TStr& Str, const char* FmtStr);
</span>125    int PutStr(const TStr& Str, const bool& ForceInLn=false);
126    int PutStrLn(const TStr& Str, const bool& ForceInLn=false){
127      int Cs=PutStr(Str,ForceInLn); Cs+=PutLn(); return Cs;}
128    int PutStrFmt(const char *FmtStr, ...); 
129    int PutStrFmtLn(const char *FmtStr, ...); 
130    int PutIndent(const int& IndentLev=1);
131    int PutLn(const int& Lns=1);
132    int PutDosLn(const int& Lns=1);
133    int PutSep(const int& NextStrLen=0);
134    int PutSepLn(const int& Lns=0);
135    void SaveCs(){Cs+=PutBf(&Cs, sizeof(Cs));}
136    void SaveBf(const void* Bf, const TSize& BfL){Cs+=PutBf(Bf, BfL);}
137    void Save(const bool& Bool){Cs+=PutBf(&Bool, sizeof(Bool));}
138    void Save(const char& Ch){Cs+=PutBf(&Ch, sizeof(Ch));}
139    void Save(const uchar& UCh){Cs+=PutBf(&UCh, sizeof(UCh));}
140    void Save(const short& Short){Cs+=PutBf(&Short, sizeof(Short));}
141    void Save(const ushort& UShort){Cs+=PutBf(&UShort, sizeof(UShort));}
142    void Save(const int& Int){Cs+=PutBf(&Int, sizeof(Int));}
143    void Save(const uint& UInt){Cs+=PutBf(&UInt, sizeof(UInt));}
144    void Save(const int64& Int){Cs+=PutBf(&Int, sizeof(Int));}
145    void Save(const uint64& UInt){Cs+=PutBf(&UInt, sizeof(UInt));}
146    void Save(const double& Flt){Cs+=PutBf(&Flt, sizeof(Flt));}
147    void Save(const sdouble& SFlt){Cs+=PutBf(&SFlt, sizeof(SFlt));}
148    void Save(const ldouble& LFlt){Cs+=PutBf(&LFlt, sizeof(LFlt));}
149    void Save(const char* CStr, const TSize& CStrLen){Cs+=PutBf(CStr, CStrLen+1);}
150    void Save(const char* CStr);
151    void Save(TSIn& SIn, const TSize& BfL=-1);
152    void Save(const PSIn& SIn, const TSize& BfL=-1){Save(*SIn, BfL);}
153    void Save(const void* Bf, const TSize& BfL){Cs+=PutBf(Bf, BfL);}
154    TSOut& operator<<(const bool& Bool){Cs+=PutBf(&Bool, sizeof(Bool)); return *this;}
155    TSOut& operator<<(const uchar& UCh){Cs+=PutBf(&UCh, sizeof(UCh)); return *this;}
156    TSOut& operator<<(const char& Ch){Cs+=PutBf(&Ch, sizeof(Ch)); return *this;}
157    TSOut& operator<<(const short& Sh){Cs+=PutBf(&Sh, sizeof(Sh)); return *this;}
158    TSOut& operator<<(const ushort& USh){Cs+=PutBf(&USh, sizeof(USh)); return *this;}
159    TSOut& operator<<(const int& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
160    TSOut& operator<<(const uint& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
161    TSOut& operator<<(const int64& Int){Cs+=PutBf(&Int, sizeof(Int)); return *this;}
162    TSOut& operator<<(const uint64& UInt){Cs+=PutBf(&UInt, sizeof(UInt)); return *this;}
163    TSOut& operator<<(const float& Flt){Cs+=PutBf(&Flt, sizeof(Flt)); return *this;}
164    TSOut& operator<<(const double& Double){Cs+=PutBf(&Double, sizeof(Double)); return *this;}
165    TSOut& operator<<(const long double& LDouble){Cs+=PutBf(&LDouble, sizeof(LDouble)); return *this;}
166    TSOut& operator<<(const TSOutMnp& Mnp){return Mnp(*this);}
167    TSOut& operator<<(TSOut&(*FuncPt)(TSOut&)){return FuncPt(*this);}
168    TSOut& operator<<(TSIn& SIn);
169    TSOut& operator<<(PSIn& SIn){return operator<<(*SIn);}
170    static const TPt<TSOut> StdOut;
171    friend class TPt<TSOut>;
172  };
173  typedef TPt<TSOut> PSOut;
174  template <class T>
175  TSOut& operator<<(TSOut& SOut, const T& Val){
176    Val.Save(SOut); return SOut;
177  }
178  class TSInOut: public TSIn, public TSOut{
179  private:
180    TSInOut(const TSInOut&);
181    TSInOut& operator=(const TSInOut&);
182  public:
183    TSInOut(): TSBase("Input-Output-Stream"), TSIn(), TSOut() {}
184    virtual ~TSInOut(){}
185    virtual void SetPos(const int& Pos)=0;
186    virtual void MovePos(const int& DPos)=0;
187    virtual int GetPos() const=0;
188    virtual int GetSize() const=0; 
189    virtual void Clr()=0; 
190    friend class TPt<TSInOut>;
191  };
192  typedef TPt<TSInOut> PSInOut;
193  class TStdIn: public TSIn{
194  private:
195    TStdIn(const TStdIn&);
196    TStdIn& operator=(const TStdIn&);
197  public:
198    TStdIn();
199    static TPt<TSIn> New(){return new TStdIn();}
200    bool Eof(){return feof(stdin)!=0;}
201    int Len() const {return -1;}
202    char GetCh(){return char(getchar());}
203    char PeekCh(){
204      int Ch=getchar(); ungetc(Ch, stdin); return char(Ch);}
205    int GetBf(const void* LBf, const TSize& LBfL);
206    void Reset(){Cs=TCs();}
207    bool GetNextLnBf(TChA& LnChA);
208  };
209  class TStdOut: public TSOut{
210  private:
211    TStdOut(const TStdOut&);
212    TStdOut& operator=(const TStdOut&);
213  public:
214    TStdOut();
215    static TPt<TSOut> New(){return new TStdOut();}
216    int PutCh(const char& Ch){putchar(Ch); return Ch;}
217    int PutBf(const void *LBf, const TSize& LBfL);
218    void Flush(){fflush(stdout);}
219  };
220  class TFIn: public TSIn{
221  private:
222    static const int MxBfL;
223    TFileId FileId;
224    char* Bf;
225    int BfC, BfL;
226  private:
227    void SetFPos(const int& FPos) const;
228    int GetFPos() const;
229    int GetFLen() const;
230    void FillBf();
231    int FindEol(int& BfN, bool& CrEnd);
232  private:
233    TFIn();
234    TFIn(const TFIn&);
235    TFIn& operator=(const TFIn&);
236  public:
237    TFIn(const TStr& FNm);
238    TFIn(const TStr& FNm, bool& OpenedP);
239    static PSIn New(const TStr& FNm);
240    static PSIn New(const TStr& FNm, bool& OpenedP);
241    ~TFIn();
242    bool Eof(){
243      if ((BfC==BfL)&&(BfL==MxBfL)){FillBf();}
244      return (BfC==BfL)&&(BfL<MxBfL);}
245    int Len() const {return GetFLen()-(GetFPos()-BfL+BfC);}
246    char GetCh(){
247      if (BfC==BfL){if (Eof()){return 0;} return Bf[BfC++];}
248      else {return Bf[BfC++];}}
249    char PeekCh(){
250      if (BfC==BfL){if (Eof()){return 0;} return Bf[BfC];}
251      else {return Bf[BfC];}}
252    int GetBf(const void* LBf, const TSize& LBfL);
253    void Reset(){rewind(FileId); Cs=TCs(); BfC=BfL=-1; FillBf();}
254    bool GetNextLnBf(TChA& LnChA);
255  };
256  class TFOut: public TSOut{
257  private:
258    static const TSize MxBfL;
259    TFileId FileId;
260    char* Bf;
261    TSize BfL;
262  private:
263    void FlushBf();
264  private:
265    TFOut();
266    TFOut(const TFOut&);
267    TFOut& operator=(const TFOut&);
268  public:
269    TFOut(const TStr& _FNm, const bool& Append=false);
270    TFOut(const TStr& _FNm, const bool& Append, bool& OpenedP);
271    static PSOut New(const TStr& FNm, const bool& Append=false);
272    static PSOut New(const TStr& FNm, const bool& Append, bool& OpenedP);
273    ~TFOut();
274    int PutCh(const char& Ch);
275    int PutBf(const void* LBf, const TSize& LBfL);
276    void Flush();
277    TFileId GetFileId() const {return FileId;}
278  };
279  typedef enum {faUndef, faCreate, faUpdate, faAppend, faRdOnly, faRestore} TFAccess;
280  class TFInOut : public TSInOut {
281  private:
282    TFileId FileId;
283  private:
284    TFInOut();
285    TFInOut(const TFIn&);
286    TFInOut& operator=(const TFIn&);
287  public:
288    TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo);
289    static PSInOut New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo);
290    ~TFInOut() { if (FileId!=NULL) IAssert(fclose(FileId) == 0); }
291    TStr GetFNm() const;
292    TFileId GetFileId() const {return FileId;}
293    bool Eof(){ return feof(FileId) != 0; }
294    int Len() const { return GetSize() - GetPos(); } 
295    char GetCh() { return char(fgetc(FileId)); }
296    char PeekCh() { const char Ch = GetCh();  MovePos(-1);  return Ch; }
297    int GetBf(const void* LBf, const TSize& LBfL);
298    bool GetNextLnBf(TChA& LnChA);
299    void SetPos(const int& Pos) { IAssert(fseek(FileId, Pos, SEEK_SET)==0); }
300    void MovePos(const int& DPos) { IAssert(fseek(FileId, DPos, SEEK_CUR)==0); }
301    int GetPos() const { return (int) ftell(FileId); }
302    int GetSize() const;
303    void Clr() { Fail; }
304    int PutCh(const char& Ch) { return PutBf(&Ch, sizeof(Ch)); }
305    int PutBf(const void* LBf, const TSize& LBfL);
306    void Flush() { IAssert(fflush(FileId) == 0); }
307  };
308  class TShMIn : public TSIn {
309  private:
310      char* OriginalBuffer;
311      TSize TotalLength;
312      TSize SizeLeft;
313      char* Cursor;
314      bool IsMemoryMapped;
315  public:
316      TShMIn(const TStr& Str);
317      TShMIn(void* _Bf, const TSize& _BfL);
318      ~TShMIn() {}
319      bool Eof() { return SizeLeft<=0; }
320      int Len() const { return TotalLength; }
321      char GetCh() {
322        char c;
323        LoadAndAdvance(&c, sizeof(c));
324        return c;
325      }
326      char* getCursor() {
327        return Cursor;
328      }
329      char PeekCh() {
330        return ((char*)Cursor)[0];
331      }
332      void LoadCs() {
333        TCs TestCs;
334        GetBf(&TestCs, sizeof(TestCs));
335      }
336      int GetBf(const void* LBf, const TSize& LBfL){
337        LoadAndAdvance((char*)LBf, LBfL);
338        return 0;
339      }
340      bool GetNextLnBf(TChA& LnChA){
341        return false;
342      }
343      void LoadAndAdvance(void* Dest, TSize ElemSize) {
344        memcpy(Dest, Cursor, ElemSize);
345        AdvanceCursor(ElemSize);
346      }
347      char* AdvanceCursor(TSize N) {
348        char* TempCursor = Cursor;
349        Cursor += N;
350        SizeLeft -= N;
351        return TempCursor;
352      }
353      void CloseMapping();
354  };
355  class TMIn: public TSIn{
356  private:
357    char* Bf;
358    uint64 BfC, BfL;
359    bool IsMemoryMapped;
360  private:
361    TMIn();
362    TMIn(const TMIn&);
363    TMIn& operator=(const TMIn&);
364  private:
365    int FindEol(uint64& BfN, bool& CrEnd);
366  public:
367    TMIn(const void* _Bf, const uint64& _BfL, const bool& TakeBf=false);
368    TMIn(TSIn& SIn);
369    TMIn(const char* CStr);
370    TMIn(const TStr& Str, bool FromFile);
371    TMIn(const TChA& ChA);
372    static PSIn New(const void* _Bf, const uint64& _BfL, const bool& TakeBf=false);
373    static PSIn New(const char* CStr);
374    static PSIn New(const TStr& Str);
375    static PSIn New(const TChA& ChA);
376    static TPt<TMIn> New(const TStr& Str, bool FromFile);
377    ~TMIn();
378    bool Eof(){return BfC==BfL;}
379    int Len() const {return static_cast<int>(BfL-BfC);}
380    char GetCh();
381    char PeekCh();
382    int GetBf(const void* LBf, const TSize& LBfL);
383    void Reset(){Cs=TCs(); BfC=0;}
384    bool GetNextLnBf(TChA& LnChA);
385    uint64 GetBfC();
386    uint64 GetBfL();
387    void SetBfC(uint64 Pos);
388    uint64 CountNewLinesInRange(uint64 Lb, uint64 Ub);
389    uint64 GetLineStartPos(uint64 Ind);
390    uint64 GetLineEndPos(uint64 Ind);
391    char* GetLine(uint64 Ind);
392    void SkipCommentLines();
393    char* GetBfAddr(){return Bf;}
394    friend class TPt<TMIn>;
395  };
396  typedef TPt<TMIn> PMIn;
397  class TMOut: public TSOut{
398  private:
399    char* Bf;
400    int BfL, MxBfL;
401    bool OwnBf;
402    void Resize(const int& ReqLen = -1);
403  private:
404    TMOut(const TMOut&);
405    TMOut& operator=(const TMOut&);
406  public:
407    TMOut(const int& _MxBfL=1024);
408    static PSOut New(const int& MxBfL=1024){
409      return PSOut(new TMOut(MxBfL));}
410    TMOut(char* _Bf, const int& _MxBfL);
411    ~TMOut(){if (OwnBf&&(Bf!=NULL)){delete[] Bf;}}
412    int PutCh(const char& Ch){if (BfL==MxBfL){
413      Resize();} return Bf[BfL++]=Ch;}
414    int PutBf(const void* LBf, const TSize& LBfL);
415    void AppendBf(const void* LBf, const TSize& LBfL);
416    void Flush(){}
417    int Len() const {return BfL;}
418    void Clr(){BfL=0;}
419    char GetCh(const int& ChN) const {
420      IAssert((0<=ChN)&&(ChN<BfL)); return Bf[ChN];}
421    TStr GetAsStr() const;
422    void CutBf(const int& CutBfL);
423    PSIn GetSIn(const bool& IsCut=true, const int& CutBfL=-1);
424    char* GetBfAddr() const {return Bf;}
425    bool IsCrLfLn() const;
426    TStr GetCrLfLn();
427    bool IsEolnLn() const;
428    TStr GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf);
429    void MkEolnLn();
430  };
431  class TChRet{
432  private:
433    PSIn SIn;
434    char EofCh;
435    char Ch;
436  private:
437    TChRet();
438    TChRet(const TChRet&);
439    TChRet& operator=(const TChRet&);
440  public:
441    TChRet(const PSIn& _SIn, const char& _EofCh=0):
442      SIn(_SIn), EofCh(_EofCh), Ch(_EofCh){}
443    bool Eof() const {return Ch==EofCh;}
444    char GetCh(){
445      if (SIn->Eof()){return Ch=EofCh;} else {return Ch=SIn->GetCh();}}
446    char operator()(){return Ch;}
447  };
448  class TLnRet{
449  private:
450    PSIn SIn;
451    UndefDefaultCopyAssign(TLnRet);
452  public:
453    TLnRet(const PSIn& _SIn): SIn(_SIn) {}
454    bool NextLn(TStr& LnStr);
455  };
456  ClassTP(TFRnd, PFRnd)
457  private:
458    TFileId FileId;
459    TSStr FNm;
460    bool RecAct;
461    int HdLen, RecLen;
462  private:
463    void RefreshFPos();
464  private:
465    TFRnd(const TFRnd&);
466    TFRnd& operator=(const TFRnd&);
467  public:
468    TFRnd(const TStr& _FNm, const TFAccess& FAccess,
469     const bool& CreateIfNo=true, const int& _HdLen=-1, const int& _RecLen=-1);
470    static PFRnd New(const TStr& FNm,
471     const TFAccess& FAccess, const bool& CreateIfNo=true,
472     const int& HdLen=-1, const int& RecLen=-1){
473      return new TFRnd(FNm, FAccess, CreateIfNo, HdLen, RecLen);}
474    ~TFRnd();
475    TStr GetFNm() const;
476    void SetHdRecLen(const int& _HdLen, const int& _RecLen){
477      HdLen=_HdLen; RecLen=_RecLen; RecAct=(HdLen>=0)&&(RecLen>0);}
478    void SetFPos(const int& FPos);
479    void MoveFPos(const int& DFPos);
480    int GetFPos();
481    int GetFLen();
482    bool Empty(){return GetFLen()==0;}
483    bool Eof(){return GetFPos()==GetFLen();}
484    void SetRecN(const int& RecN);
485    int GetRecN();
486    int GetRecs();
487    void GetBf(void* Bf, const TSize& BfL);
488    void PutBf(const void* Bf, const TSize& BfL);
489    void Flush();
490    void GetHd(void* Hd){IAssert(RecAct);
491      int FPos=GetFPos(); SetFPos(0); GetBf(Hd, HdLen); SetFPos(FPos);}
492    void PutHd(const void* Hd){IAssert(RecAct);
493      int FPos=GetFPos(); SetFPos(0); PutBf(Hd, HdLen); SetFPos(FPos);}
494    void GetRec(void* Rec, const int& RecN=-1){
495      IAssert(RecAct); if (RecN!=-1){SetRecN(RecN);} GetBf(Rec, RecLen);}
496    void PutRec(const void* Rec, const int& RecN=-1){
497      IAssert(RecAct); if (RecN!=-1){SetRecN(RecN);} PutBf(Rec, RecLen);}
498    void PutCs(const TCs& Cs){PutBf(&Cs, sizeof(Cs));}
499    TCs GetCs(){TCs Cs; GetBf(&Cs, sizeof(Cs)); return Cs;}
500    void PutCh(const char& Ch){PutBf(&Ch, sizeof(Ch));}
501    void PutCh(const char& Ch, const int& Chs);
502    char GetCh(){char Ch; GetBf(&Ch, sizeof(Ch)); return Ch;}
503    void PutUCh(const uchar& UCh){PutBf(&UCh, sizeof(UCh));}
504    uchar GetUCh(){uchar UCh; GetBf(&UCh, sizeof(UCh)); return UCh;}
505    void PutInt(const int& Int){PutBf(&Int, sizeof(Int));}
506    int GetInt(){int Int; GetBf(&Int, sizeof(Int)); return Int;}
507    void PutUInt(const uint& UInt){PutBf(&UInt, sizeof(UInt));}
508    uint GetUInt(){uint UInt; GetBf(&UInt, sizeof(UInt)); return UInt;}
509    void PutStr(const TStr& Str);
510    TStr GetStr(const int& StrLen);
511    TStr GetStr(const int& MxStrLen, bool& IsOk);
512    void PutSIn(const PSIn& SIn, TCs& Cs);
513    PSIn GetSIn(const int& SInLen, TCs& Cs);
514    static TStr GetStrFromFAccess(const TFAccess& FAccess);
515    static TFAccess GetFAccessFromStr(const TStr& Str);
516  };
517  class TFile{
518  public:
519    static const TStr TxtFExt;
520    static const TStr HtmlFExt;
521    static const TStr HtmFExt;
522    static const TStr GifFExt;
523    static const TStr JarFExt;
524  public:
525    static bool Exists(const TStr& FNm);
526    static void Copy(const TStr& SrcFNm, const TStr& DstFNm, 
527      const bool& ThrowExceptP=true, const bool& FailIfExistsP=false);
528    static void Del(const TStr& FNm, const bool& ThrowExceptP=true);
529    static void DelWc(const TStr& WcStr, const bool& RecurseDirP=false);
530    static void Rename(const TStr& SrcFNm, const TStr& DstFNm);
531    static TStr GetUniqueFNm(const TStr& FNm);
532    static uint64 GetSize(const TStr& FNm);
533    static uint64 GetCreateTm(const TStr& FNm);
534    static uint64 GetLastAccessTm(const TStr& FNm);
535    static uint64 GetLastWriteTm(const TStr& FNm);
536  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.h</div>
                </div>
                <div class="column column_space"><pre><code>120    int PutStr(const char* CStr);
121    int PutStr(const TChA& ChA);
122    int PutStr(const TStr& Str, char* FmtStr);
</pre></code></div>
                <div class="column column_space"><pre><code>122    int PutStr(const char* CStr);
123    int PutStr(const TChA& ChA);
124    int PutStr(const TStr& Str, const char* FmtStr);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    