
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.961848468565288%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablerecog.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "tablerecog.h"
5  #include <algorithm>
6  namespace tesseract {
7  const double kHorizontalSpacing = 0.30;
8  const double kVerticalSpacing = -0.2;
9  const int kCellSplitRowThreshold = 0;
10  const int kCellSplitColumnThreshold = 0;
11  const int kLinedTableMinVerticalLines = 3;
12  const int kLinedTableMinHorizontalLines = 3;
13  const double kRequiredColumns = 0.7;
14  const double kMarginFactor = 1.1;
15  const double kMaxRowSize = 2.5;
16  const double kGoodRowNumberOfColumnsSmall[] = {2, 2, 2, 2, 2, 3, 3};
17  const double kGoodRowNumberOfColumnsLarge = 0.7;
18  const double kMinFilledArea = 0.35;
19  static bool IsWeakTableRow(StructuredTable *table, int row) {
20    if (!table->VerifyRowFilled(row)) {
21      return false;
22    }
23    double threshold;
24    if (table->column_count() < countof(kGoodRowNumberOfColumnsSmall)) {
25      threshold = kGoodRowNumberOfColumnsSmall[table->column_count()];
26    } else {
27      threshold = table->column_count() * kGoodRowNumberOfColumnsLarge;
28    }
29    return table->CountFilledCellsInRow(row) < threshold;
30  }
31  StructuredTable::StructuredTable()
32      : text_grid_(nullptr)
33      , line_grid_(nullptr)
34      , is_lined_(false)
35      , space_above_(0)
36      , space_below_(0)
37      , space_left_(0)
38      , space_right_(0)
39      , median_cell_height_(0)
40      , median_cell_width_(0)
41      , max_text_height_(INT32_MAX) {}
42  void StructuredTable::Init() {}
43  void StructuredTable::set_text_grid(ColPartitionGrid *text_grid) {
44    text_grid_ = text_grid;
45  }
46  void StructuredTable::set_line_grid(ColPartitionGrid *line_grid) {
47    line_grid_ = line_grid;
48  }
49  void StructuredTable::set_max_text_height(int height) {
50    max_text_height_ = height;
51  }
52  bool StructuredTable::is_lined() const {
53    return is_lined_;
54  }
55  unsigned StructuredTable::row_count() const {
56    return cell_y_.empty() ? 0 : cell_y_.size() - 1;
57  }
58  unsigned StructuredTable::column_count() const {
59    return cell_x_.empty() ? 0 : cell_x_.size() - 1;
60  }
61  unsigned StructuredTable::cell_count() const {
62    return row_count() * column_count();
63  }
64  void StructuredTable::set_bounding_box(const TBOX &box) {
65    bounding_box_ = box;
66  }
67  const TBOX &StructuredTable::bounding_box() const {
68    return bounding_box_;
69  }
70  int StructuredTable::median_cell_height() {
71    return median_cell_height_;
72  }
73  int StructuredTable::median_cell_width() {
74    return median_cell_width_;
75  }
76  int StructuredTable::row_height(unsigned row) const {
77    ASSERT_HOST(row < row_count());
78    return cell_y_[row + 1] - cell_y_[row];
79  }
80  int StructuredTable::column_width(unsigned column) const {
81    ASSERT_HOST(column < column_count());
82    return cell_x_[column + 1] - cell_x_[column];
83  }
84  int StructuredTable::space_above() const {
85    return space_above_;
86  }
87  int StructuredTable::space_below() const {
88    return space_below_;
89  }
90  bool StructuredTable::FindLinedStructure() {
91    ClearStructure();
92    ColPartitionGridSearch box_search(line_grid_);
93    box_search.SetUniqueMode(true);
94    box_search.StartRectSearch(bounding_box_);
95    ColPartition *line = nullptr;
96    while ((line = box_search.NextRectSearch()) != nullptr) {
97      if (line->IsHorizontalLine()) {
98        cell_y_.push_back(line->MidY());
99      }
100      if (line->IsVerticalLine()) {
101        cell_x_.push_back(line->MidX());
102      }
103    }
104    if (cell_x_.size() < 3 || cell_y_.size() < 3) {
105      return false;
106    }
107    std::sort(cell_x_.begin(), cell_x_.end());
108    auto last_x = std::unique(cell_x_.begin(), cell_x_.end());
109    cell_x_.erase(last_x, cell_x_.end());
110    std::sort(cell_y_.begin(), cell_y_.end());
111    auto last_y = std::unique(cell_y_.begin(), cell_y_.end());
112    cell_y_.erase(last_y, cell_y_.end());
113    cell_x_[0] = bounding_box_.left();
114    cell_x_[cell_x_.size() - 1] = bounding_box_.right();
115    cell_y_[0] = bounding_box_.bottom();
116    cell_y_[cell_y_.size() - 1] = bounding_box_.top();
117    last_x = std::unique(cell_x_.begin(), cell_x_.end());
118    cell_x_.erase(last_x, cell_x_.end());
119    last_y = std::unique(cell_y_.begin(), cell_y_.end());
120    cell_y_.erase(last_y, cell_y_.end());
121    CalculateMargins();
122    CalculateStats();
123    is_lined_ = VerifyLinedTableCells();
124    return is_lined_;
125  }
126  bool StructuredTable::FindWhitespacedStructure() {
127    ClearStructure();
128    FindWhitespacedColumns();
129    FindWhitespacedRows();
130    if (!VerifyWhitespacedTable()) {
131      return false;
132    } else {
133      bounding_box_.set_left(cell_x_[0]);
134      bounding_box_.set_right(cell_x_[cell_x_.size() - 1]);
135      bounding_box_.set_bottom(cell_y_[0]);
136      bounding_box_.set_top(cell_y_[cell_y_.size() - 1]);
137      AbsorbNearbyLines();
138      CalculateMargins();
139      CalculateStats();
140      return true;
141    }
142  }
143  bool StructuredTable::DoesPartitionFit(const ColPartition &part) const {
144    const TBOX &box = part.bounding_box();
145    for (int i : cell_x_) {
146      if (box.left() < i && i < box.right()) {
147        return false;
148      }
149    }
150    for (int i : cell_y_) {
151      if (box.bottom() < i && i < box.top()) {
152        return false;
153      }
154    }
155    return true;
156  }
157  int StructuredTable::CountFilledCells() {
158    return CountFilledCells(0, row_count() - 1, 0, column_count() - 1);
159  }
160  int StructuredTable::CountFilledCellsInRow(int row) {
161    return CountFilledCells(row, row, 0, column_count() - 1);
162  }
163  int StructuredTable::CountFilledCellsInColumn(int column) {
164    return CountFilledCells(0, row_count() - 1, column, column);
165  }
166  int StructuredTable::CountFilledCells(unsigned row_start, unsigned row_end, unsigned column_start,
167                                        unsigned column_end) {
168    ASSERT_HOST(row_start <= row_end && row_end < row_count());
169    ASSERT_HOST(column_start <= column_end && column_end < column_count());
170    int cell_count = 0;
171    TBOX cell_box;
172    for (unsigned row = row_start; row <= row_end; ++row) {
173      cell_box.set_bottom(cell_y_[row]);
174      cell_box.set_top(cell_y_[row + 1]);
175      for (unsigned col = column_start; col <= column_end; ++col) {
176        cell_box.set_left(cell_x_[col]);
177        cell_box.set_right(cell_x_[col + 1]);
178        if (CountPartitions(cell_box) > 0) {
179          ++cell_count;
180        }
181      }
182    }
183    return cell_count;
184  }
185  bool StructuredTable::VerifyRowFilled(int row) {
186    for (unsigned i = 0; i < column_count(); ++i) {
187      auto area_filled = CalculateCellFilledPercentage(row, i);
188      if (area_filled >= kMinFilledArea) {
189        return true;
190      }
191    }
192    return false;
193  }
194  double StructuredTable::CalculateCellFilledPercentage(unsigned row, unsigned column) {
195    ASSERT_HOST(row <= row_count());
196    ASSERT_HOST(column <= column_count());
197    const TBOX kCellBox(cell_x_[column], cell_y_[row], cell_x_[column + 1], cell_y_[row + 1]);
198    ASSERT_HOST(!kCellBox.null_box());
199    ColPartitionGridSearch gsearch(text_grid_);
200    gsearch.SetUniqueMode(true);
201    gsearch.StartRectSearch(kCellBox);
202    double area_covered = 0;
203    ColPartition *text = nullptr;
204    while ((text = gsearch.NextRectSearch()) != nullptr) {
205      if (text->IsTextType()) {
206        area_covered += text->bounding_box().intersection(kCellBox).area();
207      }
208    }
209    const int32_t current_area = kCellBox.area();
210    if (current_area == 0) {
211      return 1.0;
212    }
213    return std::min(1.0, area_covered / current_area);
214  }
215  #ifndef GRAPHICS_DISABLED
216  void StructuredTable::Display(ScrollView *window, ScrollView::Color color) {
217    window->Brush(ScrollView::NONE);
218    window->Pen(color);
219    window->Rectangle(bounding_box_.left(), bounding_box_.bottom(), bounding_box_.right(),
220                      bounding_box_.top());
221    for (int i : cell_x_) {
222      window->Line(i, bounding_box_.bottom(), i, bounding_box_.top());
223    }
224    for (int i : cell_y_) {
225      window->Line(bounding_box_.left(), i, bounding_box_.right(), i);
226    }
227    window->UpdateWindow();
228  }
229  #endif
230  void StructuredTable::ClearStructure() {
231    cell_x_.clear();
232    cell_y_.clear();
233    is_lined_ = false;
234    space_above_ = 0;
235    space_below_ = 0;
236    space_left_ = 0;
237    space_right_ = 0;
238    median_cell_height_ = 0;
239    median_cell_width_ = 0;
240  }
241  bool StructuredTable::VerifyLinedTableCells() {
242    ASSERT_HOST(cell_y_.size() >= 2 && cell_x_.size() >= 2);
243    for (int i : cell_y_) {
244      if (CountHorizontalIntersections(i) > 0) {
245        return false;
246      }
247    }
<span onclick='openModal()' class='match'>248    for (int i : cell_x_) {
249      if (CountVerticalIntersections(i) > 0) {
250        return false;
251      }
252    }
253    return true;
254  }
</span>255  bool StructuredTable::VerifyWhitespacedTable() {
256    return row_count() >= 2 && column_count() >= 2 && cell_count() >= 6;
257  }
258  void StructuredTable::FindWhitespacedColumns() {
259    std::vector<int> left_sides;
260    std::vector<int> right_sides;
261    ColPartitionGridSearch gsearch(text_grid_);
262    gsearch.SetUniqueMode(true);
263    gsearch.StartRectSearch(bounding_box_);
264    ColPartition *text = nullptr;
265    while ((text = gsearch.NextRectSearch()) != nullptr) {
266      if (!text->IsTextType()) {
267        continue;
268      }
269      ASSERT_HOST(text->bounding_box().left() < text->bounding_box().right());
270      int spacing = static_cast<int>(text->median_width() * kHorizontalSpacing / 2.0 + 0.5);
271      left_sides.push_back(text->bounding_box().left() - spacing);
272      right_sides.push_back(text->bounding_box().right() + spacing);
273    }
274    if (left_sides.empty() || right_sides.empty()) {
275      return;
276    }
277    std::sort(left_sides.begin(), left_sides.end());
278    std::sort(right_sides.begin(), right_sides.end());
279    FindCellSplitLocations(left_sides, right_sides, kCellSplitColumnThreshold, &cell_x_);
280  }
281  void StructuredTable::FindWhitespacedRows() {
282    std::vector<int> bottom_sides;
283    std::vector<int> top_sides;
284    int min_bottom = INT32_MAX;
285    int max_top = INT32_MIN;
286    ColPartitionGridSearch gsearch(text_grid_);
287    gsearch.SetUniqueMode(true);
288    gsearch.StartRectSearch(bounding_box_);
289    ColPartition *text = nullptr;
290    while ((text = gsearch.NextRectSearch()) != nullptr) {
291      if (!text->IsTextType()) {
292        continue;
293      }
294      ASSERT_HOST(text->bounding_box().bottom() < text->bounding_box().top());
295      min_bottom = std::min(min_bottom, static_cast<int>(text->bounding_box().bottom()));
296      max_top = std::max(max_top, static_cast<int>(text->bounding_box().top()));
297      if (text->bounding_box().height() > max_text_height_) {
298        continue;
299      }
300      int spacing = static_cast<int>(text->bounding_box().height() * kVerticalSpacing / 2.0 + 0.5);
301      int bottom = text->bounding_box().bottom() - spacing;
302      int top = text->bounding_box().top() + spacing;
303      if (bottom >= top) {
304        continue;
305      }
306      bottom_sides.push_back(bottom);
307      top_sides.push_back(top);
308    }
309    if (bottom_sides.empty() || top_sides.empty()) {
310      return;
311    }
312    std::sort(bottom_sides.begin(), bottom_sides.end());
313    std::sort(top_sides.begin(), top_sides.end());
314    FindCellSplitLocations(bottom_sides, top_sides, kCellSplitRowThreshold, &cell_y_);
315    cell_y_[0] = min_bottom;
316    cell_y_[cell_y_.size() - 1] = max_top;
317  }
318  void StructuredTable::CalculateMargins() {
319    space_above_ = INT32_MAX;
320    space_below_ = INT32_MAX;
321    space_right_ = INT32_MAX;
322    space_left_ = INT32_MAX;
323    UpdateMargins(text_grid_);
324    UpdateMargins(line_grid_);
325  }
326  void StructuredTable::UpdateMargins(ColPartitionGrid *grid) {
327    int below = FindVerticalMargin(grid, bounding_box_.bottom(), true);
328    space_below_ = std::min(space_below_, below);
329    int above = FindVerticalMargin(grid, bounding_box_.top(), false);
330    space_above_ = std::min(space_above_, above);
331    int left = FindHorizontalMargin(grid, bounding_box_.left(), true);
332    space_left_ = std::min(space_left_, left);
333    int right = FindHorizontalMargin(grid, bounding_box_.right(), false);
334    space_right_ = std::min(space_right_, right);
335  }
336  int StructuredTable::FindVerticalMargin(ColPartitionGrid *grid, int border, bool decrease) const {
337    ColPartitionGridSearch gsearch(grid);
338    gsearch.SetUniqueMode(true);
339    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), border);
340    ColPartition *part = nullptr;
341    while ((part = gsearch.NextVerticalSearch(decrease)) != nullptr) {
342      if (!part->IsTextType() && !part->IsHorizontalLine()) {
343        continue;
344      }
345      int distance =
346          decrease ? border - part->bounding_box().top() : part->bounding_box().bottom() - border;
347      if (distance >= 0) {
348        return distance;
349      }
350    }
351    return INT32_MAX;
352  }
353  int StructuredTable::FindHorizontalMargin(ColPartitionGrid *grid, int border, bool decrease) const {
354    ColPartitionGridSearch gsearch(grid);
355    gsearch.SetUniqueMode(true);
356    gsearch.StartSideSearch(border, bounding_box_.bottom(), bounding_box_.top());
357    ColPartition *part = nullptr;
358    while ((part = gsearch.NextSideSearch(decrease)) != nullptr) {
359      if (!part->IsTextType() && !part->IsVerticalLine()) {
360        continue;
361      }
362      int distance =
363          decrease ? border - part->bounding_box().right() : part->bounding_box().left() - border;
364      if (distance >= 0) {
365        return distance;
366      }
367    }
368    return INT32_MAX;
369  }
370  void StructuredTable::CalculateStats() {
371    const int kMaxCellHeight = 1000;
372    const int kMaxCellWidth = 1000;
373    STATS height_stats(0, kMaxCellHeight);
374    STATS width_stats(0, kMaxCellWidth);
375    for (unsigned i = 0; i < row_count(); ++i) {
376      height_stats.add(row_height(i), column_count());
377    }
378    for (unsigned i = 0; i < column_count(); ++i) {
379      width_stats.add(column_width(i), row_count());
380    }
381    median_cell_height_ = static_cast<int>(height_stats.median() + 0.5);
382    median_cell_width_ = static_cast<int>(width_stats.median() + 0.5);
383  }
384  void StructuredTable::AbsorbNearbyLines() {
385    ColPartitionGridSearch gsearch(line_grid_);
386    gsearch.SetUniqueMode(true);
387    ColPartition *line = nullptr;
388    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), bounding_box_.top());
389    while ((line = gsearch.NextVerticalSearch(false)) != nullptr) {
390      if (!line->IsHorizontalLine()) {
391        break;
392      }
393      TBOX text_search(bounding_box_.left(), bounding_box_.top() + 1, bounding_box_.right(),
394                       line->MidY());
395      if (text_search.height() > median_cell_height_ * 2) {
396        break;
397      }
398      if (CountPartitions(text_search) > 0) {
399        break;
400      }
401      bounding_box_.set_top(line->MidY());
402    }
403    line = nullptr;
404    gsearch.StartVerticalSearch(bounding_box_.left(), bounding_box_.right(), bounding_box_.bottom());
405    while ((line = gsearch.NextVerticalSearch(true)) != nullptr) {
406      if (!line->IsHorizontalLine()) {
407        break;
408      }
409      TBOX text_search(bounding_box_.left(), line->MidY(), bounding_box_.right(),
410                       bounding_box_.bottom() - 1);
411      if (text_search.height() > median_cell_height_ * 2) {
412        break;
413      }
414      if (CountPartitions(text_search) > 0) {
415        break;
416      }
417      bounding_box_.set_bottom(line->MidY());
418    }
419  }
420  void StructuredTable::FindCellSplitLocations(const std::vector<int> &min_list,
421                                               const std::vector<int> &max_list, int max_merged,
422                                               std::vector<int> *locations) {
423    locations->clear();
424    ASSERT_HOST(min_list.size() == max_list.size());
425    if (min_list.empty()) {
426      return;
427    }
428    ASSERT_HOST(min_list.at(0) < max_list.at(0));
429    ASSERT_HOST(min_list.at(min_list.size() - 1) < max_list.at(max_list.size() - 1));
430    locations->push_back(min_list.at(0));
431    unsigned min_index = 0;
432    unsigned max_index = 0;
433    int stacked_partitions = 0;
434    int last_cross_position = INT32_MAX;
435    while (min_index < min_list.size()) {
436      if (min_list[min_index] < max_list[max_index]) {
437        ++stacked_partitions;
438        if (last_cross_position != INT32_MAX && stacked_partitions > max_merged) {
439          int mid = (last_cross_position + min_list[min_index]) / 2;
440          locations->push_back(mid);
441          last_cross_position = INT32_MAX;
442        }
443        ++min_index;
444      } else {
445        --stacked_partitions;
446        if (last_cross_position == INT32_MAX && stacked_partitions <= max_merged) {
447          last_cross_position = max_list[max_index];
448        }
449        ++max_index;
450      }
451    }
452    locations->push_back(max_list.at(max_list.size() - 1));
453  }
454  int StructuredTable::CountVerticalIntersections(int x) {
455    int count = 0;
456    const int kGridSize = text_grid_->gridsize();
457    TBOX vertical_box = bounding_box_;
458    vertical_box.set_left(x - kGridSize);
459    vertical_box.set_right(x + kGridSize);
460    ColPartitionGridSearch gsearch(text_grid_);
461    gsearch.SetUniqueMode(true);
462    gsearch.StartRectSearch(vertical_box);
463    ColPartition *text = nullptr;
464    while ((text = gsearch.NextRectSearch()) != nullptr) {
465      if (!text->IsTextType()) {
466        continue;
467      }
468      const TBOX &box = text->bounding_box();
469      if (box.left() < x && x < box.right()) {
470        ++count;
471      }
472    }
473    return count;
474  }
475  int StructuredTable::CountHorizontalIntersections(int y) {
476    int count = 0;
477    const int kGridSize = text_grid_->gridsize();
478    TBOX horizontal_box = bounding_box_;
479    horizontal_box.set_bottom(y - kGridSize);
480    horizontal_box.set_top(y + kGridSize);
481    ColPartitionGridSearch gsearch(text_grid_);
482    gsearch.SetUniqueMode(true);
483    gsearch.StartRectSearch(horizontal_box);
484    ColPartition *text = nullptr;
485    while ((text = gsearch.NextRectSearch()) != nullptr) {
486      if (!text->IsTextType()) {
487        continue;
488      }
489      const TBOX &box = text->bounding_box();
490      if (box.bottom() < y && y < box.top()) {
491        ++count;
492      }
493    }
494    return count;
495  }
496  int StructuredTable::CountPartitions(const TBOX &box) {
497    ColPartitionGridSearch gsearch(text_grid_);
498    gsearch.SetUniqueMode(true);
499    gsearch.StartRectSearch(box);
500    int count = 0;
501    ColPartition *text = nullptr;
502    while ((text = gsearch.NextRectSearch()) != nullptr) {
503      if (text->IsTextType()) {
504        ++count;
505      }
506    }
507    return count;
508  }
509  void TableRecognizer::Init() {}
510  void TableRecognizer::set_text_grid(ColPartitionGrid *text_grid) {
511    text_grid_ = text_grid;
512  }
513  void TableRecognizer::set_line_grid(ColPartitionGrid *line_grid) {
514    line_grid_ = line_grid;
515  }
516  void TableRecognizer::set_min_height(int height) {
517    min_height_ = height;
518  }
519  void TableRecognizer::set_min_width(int width) {
520    min_width_ = width;
521  }
522  void TableRecognizer::set_max_text_height(int height) {
523    max_text_height_ = height;
524  }
525  StructuredTable *TableRecognizer::RecognizeTable(const TBOX &guess) {
526    auto *table = new StructuredTable();
527    table->Init();
528    table->set_text_grid(text_grid_);
529    table->set_line_grid(line_grid_);
530    table->set_max_text_height(max_text_height_);
531    if (RecognizeLinedTable(guess, table)) {
532      return table;
533    }
534    if (RecognizeWhitespacedTable(guess, table)) {
535      return table;
536    }
537    delete table;
538    return nullptr;
539  }
540  bool TableRecognizer::RecognizeLinedTable(const TBOX &guess_box, StructuredTable *table) {
541    if (!HasSignificantLines(guess_box)) {
542      return false;
543    }
544    TBOX line_bound = guess_box;
545    if (!FindLinesBoundingBox(&line_bound)) {
546      return false;
547    }
548    table->set_bounding_box(line_bound);
549    return table->FindLinedStructure();
550  }
551  bool TableRecognizer::HasSignificantLines(const TBOX &guess) {
552    ColPartitionGridSearch box_search(line_grid_);
553    box_search.SetUniqueMode(true);
554    box_search.StartRectSearch(guess);
555    ColPartition *line = nullptr;
556    int vertical_count = 0;
557    int horizontal_count = 0;
558    while ((line = box_search.NextRectSearch()) != nullptr) {
559      if (line->IsHorizontalLine()) {
560        ++horizontal_count;
561      }
562      if (line->IsVerticalLine()) {
563        ++vertical_count;
564      }
565    }
566    return vertical_count >= kLinedTableMinVerticalLines &&
567           horizontal_count >= kLinedTableMinHorizontalLines;
568  }
569  bool TableRecognizer::FindLinesBoundingBox(TBOX *bounding_box) {
570    if (!FindLinesBoundingBoxIteration(bounding_box)) {
571      return false;
572    }
573    bool changed = true;
574    while (changed) {
575      changed = false;
576      int old_area = bounding_box->area();
577      bool check = FindLinesBoundingBoxIteration(bounding_box);
578      ASSERT_HOST(check);
579      ASSERT_HOST(bounding_box->area() >= old_area);
580      changed = (bounding_box->area() > old_area);
581    }
582    return true;
583  }
584  bool TableRecognizer::FindLinesBoundingBoxIteration(TBOX *bounding_box) {
585    ColPartitionGridSearch box_search(line_grid_);
586    box_search.SetUniqueMode(true);
587    box_search.StartRectSearch(*bounding_box);
588    ColPartition *line = nullptr;
589    bool first_line = true;
590    while ((line = box_search.NextRectSearch()) != nullptr) {
591      if (line->IsLineType()) {
592        if (first_line) {
593          *bounding_box = line->bounding_box();
594          first_line = false;
595        } else {
596          *bounding_box += line->bounding_box();
597        }
598      }
599    }
600    return !first_line;
601  }
602  bool TableRecognizer::RecognizeWhitespacedTable(const TBOX &guess_box, StructuredTable *table) {
603    TBOX best_box = guess_box; 
604    int best_below = 0;        
605    int best_above = 0;        
606    TBOX adjusted = guess_box; 
607    const int kMidGuessY = (guess_box.bottom() + guess_box.top()) / 2;
608    unsigned best_cols = 0;
609    bool found_good_border = false;
610    int last_bottom = INT32_MAX;
611    int bottom =
612        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY - min_height_ / 2, true);
613    int top =
614        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY + min_height_ / 2, false);
615    adjusted.set_top(top);
616    int previous_below = 0;
617    const int kMaxChances = 10;
618    int chances = kMaxChances;
619    while (bottom != last_bottom) {
620      adjusted.set_bottom(bottom);
621      if (adjusted.height() >= min_height_) {
622        table->set_bounding_box(adjusted);
623        if (table->FindWhitespacedStructure() &&
624            table->column_count() >= best_cols * kRequiredColumns) {
625          if (false && IsWeakTableRow(table, 0)) {
626            --chances;
627          } else {
628            chances = kMaxChances;
629            double max_row_height = kMaxRowSize * table->median_cell_height();
630            if ((table->space_below() * kMarginFactor >= best_below &&
631                 table->space_below() >= previous_below) ||
632                (table->CountFilledCellsInRow(0) > 1 && table->row_height(0) < max_row_height)) {
633              best_box.set_bottom(bottom);
634              best_below = table->space_below();
635              best_cols = std::max(table->column_count(), best_cols);
636              found_good_border = true;
637            }
638          }
639          previous_below = table->space_below();
640        } else {
641          --chances;
642        }
643      }
644      if (chances <= 0) {
645        break;
646      }
647      last_bottom = bottom;
648      bottom = NextHorizontalSplit(guess_box.left(), guess_box.right(), last_bottom, true);
649    }
650    if (!found_good_border) {
651      return false;
652    }
653    found_good_border = false;
654    int last_top = INT32_MIN;
655    top =
656        NextHorizontalSplit(guess_box.left(), guess_box.right(), kMidGuessY + min_height_ / 2, false);
657    int previous_above = 0;
658    chances = kMaxChances;
659    adjusted.set_bottom(best_box.bottom());
660    while (last_top != top) {
661      adjusted.set_top(top);
662      if (adjusted.height() >= min_height_) {
663        table->set_bounding_box(adjusted);
664        if (table->FindWhitespacedStructure() &&
665            table->column_count() >= best_cols * kRequiredColumns) {
666          int last_row = table->row_count() - 1;
667          if (false && IsWeakTableRow(table, last_row)) {
668            --chances;
669          } else {
670            chances = kMaxChances;
671            double max_row_height = kMaxRowSize * table->median_cell_height();
672            if ((table->space_above() * kMarginFactor >= best_above &&
673                 table->space_above() >= previous_above) ||
674                (table->CountFilledCellsInRow(last_row) > 1 &&
675                 table->row_height(last_row) < max_row_height)) {
676              best_box.set_top(top);
677              best_above = table->space_above();
678              best_cols = std::max(table->column_count(), best_cols);
679              found_good_border = true;
680            }
681          }
682          previous_above = table->space_above();
683        } else {
684          --chances;
685        }
686      }
687      if (chances <= 0) {
688        break;
689      }
690      last_top = top;
691      top = NextHorizontalSplit(guess_box.left(), guess_box.right(), last_top, false);
692    }
693    if (!found_good_border) {
694      return false;
695    }
696    if (best_box.null_box()) {
697      return false;
698    }
699    table->set_bounding_box(best_box);
700    return table->FindWhitespacedStructure();
701  }
702  int TableRecognizer::NextHorizontalSplit(int left, int right, int y, bool top_to_bottom) {
703    ColPartitionGridSearch gsearch(text_grid_);
704    gsearch.SetUniqueMode(true);
705    gsearch.StartVerticalSearch(left, right, y);
706    ColPartition *text = nullptr;
707    int last_y = y;
708    while ((text = gsearch.NextVerticalSearch(top_to_bottom)) != nullptr) {
709      if (!text->IsTextType() || !text->IsHorizontalType()) {
710        continue;
711      }
712      if (text->bounding_box().height() > max_text_height_) {
713        continue;
714      }
715      const TBOX &text_box = text->bounding_box();
716      if (top_to_bottom && (last_y >= y || last_y <= text_box.top())) {
717        last_y = std::min(last_y, static_cast<int>(text_box.bottom()));
718        continue;
719      }
720      if (!top_to_bottom && (last_y <= y || last_y >= text_box.bottom())) {
721        last_y = std::max(last_y, static_cast<int>(text_box.top()));
722        continue;
723      }
724      return last_y;
725    }
726    return last_y;
727  }
728  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-shapetable.cpp</h3>
            <pre><code>1  #include "shapetable.h"
2  #include "bitvector.h"
3  #include "fontinfo.h"
4  #include "intfeaturespace.h"
5  #include "unicharset.h"
6  #include "unicity_table.h"
7  #include <algorithm>
8  namespace tesseract {
9  int ShapeRating::FirstResultWithUnichar(const std::vector<ShapeRating> &results,
10                                          const ShapeTable &shape_table, UNICHAR_ID unichar_id) {
11    for (unsigned r = 0; r < results.size(); ++r) {
12      const auto shape_id = results[r].shape_id;
13      const Shape &shape = shape_table.GetShape(shape_id);
14      if (shape.ContainsUnichar(unichar_id)) {
15        return r;
16      }
17    }
18    return -1;
19  }
20  int UnicharRating::FirstResultWithUnichar(const std::vector<UnicharRating> &results,
21                                            UNICHAR_ID unichar_id) {
22    for (unsigned r = 0; r < results.size(); ++r) {
23      if (results[r].unichar_id == unichar_id) {
24        return r;
25      }
26    }
27    return -1;
28  }
29  bool UnicharAndFonts::Serialize(FILE *fp) const {
30    return tesseract::Serialize(fp, &unichar_id) && tesseract::Serialize(fp, font_ids);
31  }
32  bool UnicharAndFonts::DeSerialize(TFile *fp) {
33    return fp->DeSerialize(&unichar_id) && fp->DeSerialize(font_ids);
34  }
35  int UnicharAndFonts::SortByUnicharId(const void *v1, const void *v2) {
36    const auto *p1 = static_cast<const UnicharAndFonts *>(v1);
37    const auto *p2 = static_cast<const UnicharAndFonts *>(v2);
38    return p1->unichar_id - p2->unichar_id;
39  }
40  bool UnicharAndFonts::StdSortByUnicharId(const UnicharAndFonts &v1, const UnicharAndFonts &v2) {
41    return v1.unichar_id < v2.unichar_id;
42  }
43  bool Shape::Serialize(FILE *fp) const {
44    uint8_t sorted = unichars_sorted_;
45    return tesseract::Serialize(fp, &sorted) && tesseract::Serialize(fp, unichars_);
46  }
47  bool Shape::DeSerialize(TFile *fp) {
48    uint8_t sorted;
49    if (!fp->DeSerialize(&sorted)) {
50      return false;
51    }
52    unichars_sorted_ = sorted != 0;
53    return fp->DeSerialize(unichars_);
54  }
55  void Shape::AddToShape(int unichar_id, int font_id) {
56    for (auto &unichar : unichars_) {
57      if (unichar.unichar_id == unichar_id) {
58        std::vector<int> &font_list = unichar.font_ids;
59        for (int f : font_list) {
60          if (f == font_id) {
61            return; 
62          }
63        }
64        font_list.push_back(font_id);
65        return;
66      }
67    }
68    unichars_.emplace_back(unichar_id, font_id);
69    unichars_sorted_ = unichars_.size() <= 1;
70  }
71  void Shape::AddShape(const Shape &other) {
72    for (const auto &unichar : other.unichars_) {
73      for (unsigned f = 0; f < unichar.font_ids.size(); ++f) {
74        AddToShape(unichar.unichar_id, unichar.font_ids[f]);
75      }
76    }
77    unichars_sorted_ = unichars_.size() <= 1;
78  }
79  bool Shape::ContainsUnicharAndFont(int unichar_id, int font_id) const {
80    for (const auto &unichar : unichars_) {
81      if (unichar.unichar_id == unichar_id) {
82        auto &font_list = unichar.font_ids;
<span onclick='openModal()' class='match'>83        for (int f : font_list) {
84          if (f == font_id) {
85            return true;
86          }
87        }
88        return false;
89      }
</span>90    }
91    return false;
92  }
93  bool Shape::ContainsUnichar(int unichar_id) const {
94    for (const auto &unichar : unichars_) {
95      if (unichar.unichar_id == unichar_id) {
96        return true;
97      }
98    }
99    return false;
100  }
101  bool Shape::ContainsFont(int font_id) const {
102    for (const auto &unichar : unichars_) {
103      auto &font_list = unichar.font_ids;
104      for (int f : font_list) {
105        if (f == font_id) {
106          return true;
107        }
108      }
109    }
110    return false;
111  }
112  bool Shape::ContainsFontProperties(const FontInfoTable &font_table, uint32_t properties) const {
113    for (const auto &unichar : unichars_) {
114      auto &font_list = unichar.font_ids;
115      for (int f : font_list) {
116        if (font_table.at(f).properties == properties) {
117          return true;
118        }
119      }
120    }
121    return false;
122  }
123  bool Shape::ContainsMultipleFontProperties(const FontInfoTable &font_table) const {
124    uint32_t properties = font_table.at(unichars_[0].font_ids[0]).properties;
125    for (const auto &unichar : unichars_) {
126      auto &font_list = unichar.font_ids;
127      for (int f : font_list) {
128        if (font_table.at(f).properties != properties) {
129          return true;
130        }
131      }
132    }
133    return false;
134  }
135  bool Shape::operator==(const Shape &other) const {
136    return IsSubsetOf(other) && other.IsSubsetOf(*this);
137  }
138  bool Shape::IsSubsetOf(const Shape &other) const {
139    for (const auto &unichar : unichars_) {
140      int unichar_id = unichar.unichar_id;
141      const std::vector<int> &font_list = unichar.font_ids;
142      for (int f : font_list) {
143        if (!other.ContainsUnicharAndFont(unichar_id, f)) {
144          return false;
145        }
146      }
147    }
148    return true;
149  }
150  bool Shape::IsEqualUnichars(Shape *other) {
151    if (unichars_.size() != other->unichars_.size()) {
152      return false;
153    }
154    if (!unichars_sorted_) {
155      SortUnichars();
156    }
157    if (!other->unichars_sorted_) {
158      other->SortUnichars();
159    }
160    for (unsigned c = 0; c < unichars_.size(); ++c) {
161      if (unichars_[c].unichar_id != other->unichars_[c].unichar_id) {
162        return false;
163      }
164    }
165    return true;
166  }
167  void Shape::SortUnichars() {
168    std::sort(unichars_.begin(), unichars_.end(), UnicharAndFonts::StdSortByUnicharId);
169    unichars_sorted_ = true;
170  }
171  ShapeTable::ShapeTable() : unicharset_(nullptr), num_fonts_(0) {}
172  ShapeTable::ShapeTable(const UNICHARSET &unicharset) : unicharset_(&unicharset), num_fonts_(0) {}
173  bool ShapeTable::Serialize(FILE *fp) const {
174    return tesseract::Serialize(fp, shape_table_);
175  }
176  bool ShapeTable::DeSerialize(TFile *fp) {
177    if (!fp->DeSerialize(shape_table_)) {
178      return false;
179    }
180    num_fonts_ = 0;
181    return true;
182  }
183  int ShapeTable::NumFonts() const {
184    if (num_fonts_ <= 0) {
185      for (auto shape_id : shape_table_) {
186        const Shape &shape = *shape_id;
187        for (int c = 0; c < shape.size(); ++c) {
188          for (int font_id : shape[c].font_ids) {
189            if (font_id >= num_fonts_) {
190              num_fonts_ = font_id + 1;
191            }
192          }
193        }
194      }
195    }
196    return num_fonts_;
197  }
198  void ShapeTable::ReMapClassIds(const std::vector<int> &unicharset_map) {
199    for (auto shape : shape_table_) {
200      for (int c = 0; c < shape->size(); ++c) {
201        shape->SetUnicharId(c, unicharset_map[(*shape)[c].unichar_id]);
202      }
203    }
204  }
205  std::string ShapeTable::DebugStr(unsigned shape_id) const {
206    if (shape_id >= shape_table_.size()) {
207      return "INVALID_UNICHAR_ID";
208    }
209    const Shape &shape = GetShape(shape_id);
210    std::string result;
211    result += "Shape" + std::to_string(shape_id);
212    if (shape.size() > 100) {
213      result += " Num unichars=" + std::to_string(shape.size());
214      return result;
215    }
216    for (int c = 0; c < shape.size(); ++c) {
217      result += " c_id=" + std::to_string(shape[c].unichar_id);
218      result += "=";
219      result += unicharset_->id_to_unichar(shape[c].unichar_id);
220      if (shape.size() < 10) {
221        result += ", " + std::to_string(shape[c].font_ids.size());
222        result += " fonts =";
223        int num_fonts = shape[c].font_ids.size();
224        if (num_fonts > 10) {
225          result += " " + std::to_string(shape[c].font_ids[0]);
226          result += " ... " + std::to_string(shape[c].font_ids[num_fonts - 1]);
227        } else {
228          for (int f = 0; f < num_fonts; ++f) {
229            result += " " + std::to_string(shape[c].font_ids[f]);
230          }
231        }
232      }
233    }
234    return result;
235  }
236  std::string ShapeTable::SummaryStr() const {
237    int max_unichars = 0;
238    int num_multi_shapes = 0;
239    int num_master_shapes = 0;
240    for (unsigned s = 0; s < shape_table_.size(); ++s) {
241      if (MasterDestinationIndex(s) != s) {
242        continue;
243      }
244      ++num_master_shapes;
245      int shape_size = GetShape(s).size();
246      if (shape_size > 1) {
247        ++num_multi_shapes;
248      }
249      if (shape_size > max_unichars) {
250        max_unichars = shape_size;
251      }
252    }
253    std::string result;
254    result += "Number of shapes = " + std::to_string(num_master_shapes);
255    result += " max unichars = " + std::to_string(max_unichars);
256    result += " number with multiple unichars = " + std::to_string(num_multi_shapes);
257    return result;
258  }
259  unsigned ShapeTable::AddShape(int unichar_id, int font_id) {
260    auto index = shape_table_.size();
261    auto *shape = new Shape;
262    shape->AddToShape(unichar_id, font_id);
263    shape_table_.push_back(shape);
264    num_fonts_ = std::max(num_fonts_, font_id + 1);
265    return index;
266  }
267  unsigned ShapeTable::AddShape(const Shape &other) {
268    unsigned index;
269    for (index = 0; index < shape_table_.size() && !(other == *shape_table_[index]); ++index) {
270      continue;
271    }
272    if (index == shape_table_.size()) {
273      auto *shape = new Shape(other);
274      shape_table_.push_back(shape);
275    }
276    num_fonts_ = 0;
277    return index;
278  }
279  void ShapeTable::DeleteShape(unsigned shape_id) {
280    delete shape_table_[shape_id];
281    shape_table_.erase(shape_table_.begin() + shape_id);
282  }
283  void ShapeTable::AddToShape(unsigned shape_id, int unichar_id, int font_id) {
284    Shape &shape = *shape_table_[shape_id];
285    shape.AddToShape(unichar_id, font_id);
286    num_fonts_ = std::max(num_fonts_, font_id + 1);
287  }
288  void ShapeTable::AddShapeToShape(unsigned shape_id, const Shape &other) {
289    Shape &shape = *shape_table_[shape_id];
290    shape.AddShape(other);
291    num_fonts_ = 0;
292  }
293  int ShapeTable::FindShape(int unichar_id, int font_id) const {
294    for (unsigned s = 0; s < shape_table_.size(); ++s) {
295      const Shape &shape = GetShape(s);
296      for (int c = 0; c < shape.size(); ++c) {
297        if (shape[c].unichar_id == unichar_id) {
298          if (font_id < 0) {
299            return s; 
300          }
301          for (int f : shape[c].font_ids) {
302            if (f == font_id) {
303              return s;
304            }
305          }
306        }
307      }
308    }
309    return -1;
310  }
311  void ShapeTable::GetFirstUnicharAndFont(unsigned shape_id, int *unichar_id, int *font_id) const {
312    const UnicharAndFonts &unichar_and_fonts = (*shape_table_[shape_id])[0];
313    *unichar_id = unichar_and_fonts.unichar_id;
314    *font_id = unichar_and_fonts.font_ids[0];
315  }
316  int ShapeTable::BuildFromShape(const Shape &shape, const ShapeTable &master_shapes) {
317    BitVector shape_map(master_shapes.NumShapes());
318    for (int u_ind = 0; u_ind < shape.size(); ++u_ind) {
319      for (unsigned f_ind = 0; f_ind < shape[u_ind].font_ids.size(); ++f_ind) {
320        int c = shape[u_ind].unichar_id;
321        int f = shape[u_ind].font_ids[f_ind];
322        int master_id = master_shapes.FindShape(c, f);
323        if (master_id >= 0) {
324          shape_map.SetBit(master_id);
325        } else if (FindShape(c, f) < 0) {
326          AddShape(c, f);
327        }
328      }
329    }
330    int num_masters = 0;
331    for (unsigned s = 0; s < master_shapes.NumShapes(); ++s) {
332      if (shape_map[s]) {
333        AddShape(master_shapes.GetShape(s));
334        ++num_masters;
335      }
336    }
337    return num_masters;
338  }
339  bool ShapeTable::AlreadyMerged(unsigned shape_id1, unsigned shape_id2) const {
340    return MasterDestinationIndex(shape_id1) == MasterDestinationIndex(shape_id2);
341  }
342  bool ShapeTable::AnyMultipleUnichars() const {
343    auto num_shapes = NumShapes();
344    for (unsigned s1 = 0; s1 < num_shapes; ++s1) {
345      if (MasterDestinationIndex(s1) != s1) {
346        continue;
347      }
348      if (GetShape(s1).size() > 1) {
349        return true;
350      }
351    }
352    return false;
353  }
354  int ShapeTable::MaxNumUnichars() const {
355    int max_num_unichars = 0;
356    int num_shapes = NumShapes();
357    for (int s = 0; s < num_shapes; ++s) {
358      if (GetShape(s).size() > max_num_unichars) {
359        max_num_unichars = GetShape(s).size();
360      }
361    }
362    return max_num_unichars;
363  }
364  void ShapeTable::ForceFontMerges(unsigned start, unsigned end) {
365    for (unsigned s1 = start; s1 < end; ++s1) {
366      if (MasterDestinationIndex(s1) == s1 && GetShape(s1).size() == 1) {
367        int unichar_id = GetShape(s1)[0].unichar_id;
368        for (auto s2 = s1 + 1; s2 < end; ++s2) {
369          if (MasterDestinationIndex(s2) == s2 && GetShape(s2).size() == 1 &&
370              unichar_id == GetShape(s2)[0].unichar_id) {
371            MergeShapes(s1, s2);
372          }
373        }
374      }
375    }
376    ShapeTable compacted(*unicharset_);
377    compacted.AppendMasterShapes(*this, nullptr);
378    *this = compacted;
379  }
380  unsigned ShapeTable::MasterUnicharCount(unsigned shape_id) const {
381    int master_id = MasterDestinationIndex(shape_id);
382    return GetShape(master_id).size();
383  }
384  int ShapeTable::MasterFontCount(unsigned shape_id) const {
385    int master_id = MasterDestinationIndex(shape_id);
386    const Shape &shape = GetShape(master_id);
387    int font_count = 0;
388    for (int c = 0; c < shape.size(); ++c) {
389      font_count += shape[c].font_ids.size();
390    }
391    return font_count;
392  }
393  int ShapeTable::MergedUnicharCount(unsigned shape_id1, unsigned shape_id2) const {
394    int master_id1 = MasterDestinationIndex(shape_id1);
395    int master_id2 = MasterDestinationIndex(shape_id2);
396    Shape combined_shape(*shape_table_[master_id1]);
397    combined_shape.AddShape(*shape_table_[master_id2]);
398    return combined_shape.size();
399  }
400  void ShapeTable::MergeShapes(unsigned shape_id1, unsigned shape_id2) {
401    auto master_id1 = MasterDestinationIndex(shape_id1);
402    auto master_id2 = MasterDestinationIndex(shape_id2);
403    shape_table_[master_id2]->set_destination_index(master_id1);
404    shape_table_[master_id1]->AddShape(*shape_table_[master_id2]);
405  }
406  void ShapeTable::SwapShapes(unsigned shape_id1, unsigned shape_id2) {
407    Shape *tmp = shape_table_[shape_id1];
408    shape_table_[shape_id1] = shape_table_[shape_id2];
409    shape_table_[shape_id2] = tmp;
410  }
411  unsigned ShapeTable::MasterDestinationIndex(unsigned shape_id) const {
412    auto dest_id = shape_table_[shape_id]->destination_index();
413    if (static_cast<unsigned>(dest_id) == shape_id || dest_id < 0) {
414      return shape_id; 
415    }
416    auto master_id = shape_table_[dest_id]->destination_index();
417    if (master_id == dest_id || master_id < 0) {
418      return dest_id; 
419    }
420    master_id = MasterDestinationIndex(master_id);
421    return master_id;
422  }
423  bool ShapeTable::SubsetUnichar(unsigned shape_id1, unsigned shape_id2) const {
424    const Shape &shape1 = GetShape(shape_id1);
425    const Shape &shape2 = GetShape(shape_id2);
426    int c1, c2;
427    for (c1 = 0; c1 < shape1.size(); ++c1) {
428      int unichar_id1 = shape1[c1].unichar_id;
429      if (!shape2.ContainsUnichar(unichar_id1)) {
430        break;
431      }
432    }
433    for (c2 = 0; c2 < shape2.size(); ++c2) {
434      int unichar_id2 = shape2[c2].unichar_id;
435      if (!shape1.ContainsUnichar(unichar_id2)) {
436        break;
437      }
438    }
439    return c1 == shape1.size() || c2 == shape2.size();
440  }
441  bool ShapeTable::MergeSubsetUnichar(int merge_id1, int merge_id2, unsigned shape_id) const {
442    const Shape &merge1 = GetShape(merge_id1);
443    const Shape &merge2 = GetShape(merge_id2);
444    const Shape &shape = GetShape(shape_id);
445    int cm1, cm2, cs;
446    for (cs = 0; cs < shape.size(); ++cs) {
447      int unichar_id = shape[cs].unichar_id;
448      if (!merge1.ContainsUnichar(unichar_id) && !merge2.ContainsUnichar(unichar_id)) {
449        break; 
450      }
451    }
452    for (cm1 = 0; cm1 < merge1.size(); ++cm1) {
453      int unichar_id1 = merge1[cm1].unichar_id;
454      if (!shape.ContainsUnichar(unichar_id1)) {
455        break; 
456      }
457    }
458    for (cm2 = 0; cm2 < merge2.size(); ++cm2) {
459      int unichar_id2 = merge2[cm2].unichar_id;
460      if (!shape.ContainsUnichar(unichar_id2)) {
461        break; 
462      }
463    }
464    return cs == shape.size() || (cm1 == merge1.size() && cm2 == merge2.size());
465  }
466  bool ShapeTable::EqualUnichars(unsigned shape_id1, unsigned shape_id2) const {
467    const Shape &shape1 = GetShape(shape_id1);
468    const Shape &shape2 = GetShape(shape_id2);
469    for (int c1 = 0; c1 < shape1.size(); ++c1) {
470      int unichar_id1 = shape1[c1].unichar_id;
471      if (!shape2.ContainsUnichar(unichar_id1)) {
472        return false;
473      }
474    }
475    for (int c2 = 0; c2 < shape2.size(); ++c2) {
476      int unichar_id2 = shape2[c2].unichar_id;
477      if (!shape1.ContainsUnichar(unichar_id2)) {
478        return false;
479      }
480    }
481    return true;
482  }
483  bool ShapeTable::MergeEqualUnichars(int merge_id1, int merge_id2, unsigned shape_id) const {
484    const Shape &merge1 = GetShape(merge_id1);
485    const Shape &merge2 = GetShape(merge_id2);
486    const Shape &shape = GetShape(shape_id);
487    for (int cs = 0; cs < shape.size(); ++cs) {
488      int unichar_id = shape[cs].unichar_id;
489      if (!merge1.ContainsUnichar(unichar_id) && !merge2.ContainsUnichar(unichar_id)) {
490        return false; 
491      }
492    }
493    for (int cm1 = 0; cm1 < merge1.size(); ++cm1) {
494      int unichar_id1 = merge1[cm1].unichar_id;
495      if (!shape.ContainsUnichar(unichar_id1)) {
496        return false; 
497      }
498    }
499    for (int cm2 = 0; cm2 < merge2.size(); ++cm2) {
500      int unichar_id2 = merge2[cm2].unichar_id;
501      if (!shape.ContainsUnichar(unichar_id2)) {
502        return false; 
503      }
504    }
505    return true;
506  }
507  bool ShapeTable::CommonUnichars(unsigned shape_id1, unsigned shape_id2) const {
508    const Shape &shape1 = GetShape(shape_id1);
509    const Shape &shape2 = GetShape(shape_id2);
510    for (int c1 = 0; c1 < shape1.size(); ++c1) {
511      int unichar_id1 = shape1[c1].unichar_id;
512      if (shape2.ContainsUnichar(unichar_id1)) {
513        return true;
514      }
515    }
516    return false;
517  }
518  bool ShapeTable::CommonFont(unsigned shape_id1, unsigned shape_id2) const {
519    const Shape &shape1 = GetShape(shape_id1);
520    const Shape &shape2 = GetShape(shape_id2);
521    for (int c1 = 0; c1 < shape1.size(); ++c1) {
522      const std::vector<int> &font_list1 = shape1[c1].font_ids;
523      for (int f : font_list1) {
524        if (shape2.ContainsFont(f)) {
525          return true;
526        }
527      }
528    }
529    return false;
530  }
531  void ShapeTable::AppendMasterShapes(const ShapeTable &other, std::vector<int> *shape_map) {
532    if (shape_map != nullptr) {
533      shape_map->clear();
534      shape_map->resize(other.NumShapes(), -1);
535    }
536    for (unsigned s = 0; s < other.shape_table_.size(); ++s) {
537      if (other.shape_table_[s]->destination_index() < 0) {
538        int index = AddShape(*other.shape_table_[s]);
539        if (shape_map != nullptr) {
540          (*shape_map)[s] = index;
541        }
542      }
543    }
544  }
545  int ShapeTable::NumMasterShapes() const {
546    int num_shapes = 0;
547    for (auto s : shape_table_) {
548      if (s->destination_index() < 0) {
549        ++num_shapes;
550      }
551    }
552    return num_shapes;
553  }
554  void ShapeTable::AddShapeToResults(const ShapeRating &shape_rating, std::vector<int> *unichar_map,
555                                     std::vector<UnicharRating> *results) const {
556    if (shape_rating.joined) {
557      AddUnicharToResults(UNICHAR_JOINED, shape_rating.rating, unichar_map, results);
558    }
559    if (shape_rating.broken) {
560      AddUnicharToResults(UNICHAR_BROKEN, shape_rating.rating, unichar_map, results);
561    }
562    const Shape &shape = GetShape(shape_rating.shape_id);
563    for (int u = 0; u < shape.size(); ++u) {
564      int result_index =
565          AddUnicharToResults(shape[u].unichar_id, shape_rating.rating, unichar_map, results);
566      for (int font_id : shape[u].font_ids) {
567        (*results)[result_index].fonts.emplace_back(font_id,
568                                                    IntCastRounded(shape_rating.rating * INT16_MAX));
569      }
570    }
571  }
572  int ShapeTable::AddUnicharToResults(int unichar_id, float rating, std::vector<int> *unichar_map,
573                                      std::vector<UnicharRating> *results) const {
574    int result_index = unichar_map->at(unichar_id);
575    if (result_index < 0) {
576      UnicharRating result(unichar_id, rating);
577      result_index = results->size();
578      results->push_back(result);
579      (*unichar_map)[unichar_id] = result_index;
580    }
581    return result_index;
582  }
583  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablerecog.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-shapetable.cpp</div>
                </div>
                <div class="column column_space"><pre><code>248    for (int i : cell_x_) {
249      if (CountVerticalIntersections(i) > 0) {
250        return false;
251      }
252    }
253    return true;
254  }
</pre></code></div>
                <div class="column column_space"><pre><code>83        for (int f : font_list) {
84          if (f == font_id) {
85            return true;
86          }
87        }
88        return false;
89      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    