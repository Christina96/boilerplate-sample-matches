
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-params_model.cpp</h3>
            <pre><code>1  #include "params_model.h"
2  #include <cctype>
3  #include <cmath>
4  #include <cstdio>
5  #include "bitvector.h"
6  #include "helpers.h"   
7  #include "serialis.h"  
8  #include "tprintf.h"
9  namespace tesseract {
<span onclick='openModal()' class='match'>10  static const float kScoreScaleFactor = 100.0f;
11  static const float kMinFinalCost = 0.001f;
12  static const float kMaxFinalCost = 100.0f;
</span>13  void ParamsModel::Print() {
14    for (int p = 0; p < PTRAIN_NUM_PASSES; ++p) {
15      tprintf("ParamsModel for pass %d lang %s\n", p, lang_.c_str());
16      for (unsigned i = 0; i < weights_vec_[p].size(); ++i) {
17        tprintf("%s = %g\n", kParamsTrainingFeatureTypeName[i], weights_vec_[p][i]);
18      }
19    }
20  }
21  void ParamsModel::Copy(const ParamsModel &other_model) {
22    for (int p = 0; p < PTRAIN_NUM_PASSES; ++p) {
23      weights_vec_[p] = other_model.weights_for_pass(static_cast<PassEnum>(p));
24    }
25  }
26  bool ParamsModel::ParseLine(char *line, char **key, float *val) {
27    if (line[0] == '#') {
28      return false;
29    }
30    int end_of_key = 0;
31    while (line[end_of_key] && !(isascii(line[end_of_key]) && isspace(line[end_of_key]))) {
32      end_of_key++;
33    }
34    if (!line[end_of_key]) {
35      tprintf("ParamsModel::Incomplete line %s\n", line);
36      return false;
37    }
38    line[end_of_key++] = 0;
39    *key = line;
40    if (sscanf(line + end_of_key, " %f", val) != 1) {
41      return false;
42    }
43    return true;
44  }
45  float ParamsModel::ComputeCost(const float features[]) const {
46    float unnorm_score = 0.0;
47    for (int f = 0; f < PTRAIN_NUM_FEATURE_TYPES; ++f) {
48      unnorm_score += weights_vec_[pass_][f] * features[f];
49    }
50    return ClipToRange(-unnorm_score / kScoreScaleFactor, kMinFinalCost, kMaxFinalCost);
51  }
52  bool ParamsModel::Equivalent(const ParamsModel &that) const {
53    float epsilon = 0.0001f;
54    for (int p = 0; p < PTRAIN_NUM_PASSES; ++p) {
55      if (weights_vec_[p].size() != that.weights_vec_[p].size()) {
56        return false;
57      }
58      for (unsigned i = 0; i < weights_vec_[p].size(); i++) {
59        if (weights_vec_[p][i] != that.weights_vec_[p][i] &&
60            std::fabs(weights_vec_[p][i] - that.weights_vec_[p][i]) > epsilon) {
61          return false;
62        }
63      }
64    }
65    return true;
66  }
67  bool ParamsModel::LoadFromFp(const char *lang, TFile *fp) {
68    const int kMaxLineSize = 100;
69    char line[kMaxLineSize];
70    BitVector present;
71    present.Init(PTRAIN_NUM_FEATURE_TYPES);
72    lang_ = lang;
73    std::vector<float> &weights = weights_vec_[pass_];
74    weights.clear();
75    weights.resize(PTRAIN_NUM_FEATURE_TYPES, 0.0f);
76    while (fp->FGets(line, kMaxLineSize) != nullptr) {
77      char *key = nullptr;
78      float value;
79      if (!ParseLine(line, &key, &value)) {
80        continue;
81      }
82      int idx = ParamsTrainingFeatureByName(key);
83      if (idx < 0) {
84        tprintf("ParamsModel::Unknown parameter %s\n", key);
85        continue;
86      }
87      if (!present[idx]) {
88        present.SetValue(idx, true);
89      }
90      weights[idx] = value;
91    }
92    bool complete = (present.NumSetBits() == PTRAIN_NUM_FEATURE_TYPES);
93    if (!complete) {
94      for (int i = 0; i < PTRAIN_NUM_FEATURE_TYPES; i++) {
95        if (!present[i]) {
96          tprintf("Missing field %s.\n", kParamsTrainingFeatureTypeName[i]);
97        }
98      }
99      lang_ = "";
100      weights.clear();
101    }
102    return complete;
103  }
104  bool ParamsModel::SaveToFile(const char *full_path) const {
105    const std::vector<float> &weights = weights_vec_[pass_];
106    if (weights.size() != PTRAIN_NUM_FEATURE_TYPES) {
107      tprintf("Refusing to save ParamsModel that has not been initialized.\n");
108      return false;
109    }
110    FILE *fp = fopen(full_path, "wb");
111    if (!fp) {
112      tprintf("Could not open %s for writing.\n", full_path);
113      return false;
114    }
115    bool all_good = true;
116    for (unsigned i = 0; i < weights.size(); i++) {
117      if (fprintf(fp, "%s %f\n", kParamsTrainingFeatureTypeName[i], weights[i]) < 0) {
118        all_good = false;
119      }
120    }
121    fclose(fp);
122    return all_good;
123  }
124  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-params_model.cpp</h3>
            <pre><code>1  #include "params_model.h"
2  #include <cctype>
3  #include <cmath>
4  #include <cstdio>
5  #include "bitvector.h"
6  #include "helpers.h"   
7  #include "serialis.h"  
8  #include "tprintf.h"
9  namespace tesseract {
10  static const float kScoreScaleFactor = 100.0f;
<span onclick='openModal()' class='match'>11  static const float kMinFinalCost = 0.001f;
12  static const float kMaxFinalCost = 100.0f;
13  void ParamsModel::Print() {
</span>14    for (int p = 0; p < PTRAIN_NUM_PASSES; ++p) {
15      tprintf("ParamsModel for pass %d lang %s\n", p, lang_.c_str());
16      for (unsigned i = 0; i < weights_vec_[p].size(); ++i) {
17        tprintf("%s = %g\n", kParamsTrainingFeatureTypeName[i], weights_vec_[p][i]);
18      }
19    }
20  }
21  void ParamsModel::Copy(const ParamsModel &other_model) {
22    for (int p = 0; p < PTRAIN_NUM_PASSES; ++p) {
23      weights_vec_[p] = other_model.weights_for_pass(static_cast<PassEnum>(p));
24    }
25  }
26  bool ParamsModel::ParseLine(char *line, char **key, float *val) {
27    if (line[0] == '#') {
28      return false;
29    }
30    int end_of_key = 0;
31    while (line[end_of_key] && !(isascii(line[end_of_key]) && isspace(line[end_of_key]))) {
32      end_of_key++;
33    }
34    if (!line[end_of_key]) {
35      tprintf("ParamsModel::Incomplete line %s\n", line);
36      return false;
37    }
38    line[end_of_key++] = 0;
39    *key = line;
40    if (sscanf(line + end_of_key, " %f", val) != 1) {
41      return false;
42    }
43    return true;
44  }
45  float ParamsModel::ComputeCost(const float features[]) const {
46    float unnorm_score = 0.0;
47    for (int f = 0; f < PTRAIN_NUM_FEATURE_TYPES; ++f) {
48      unnorm_score += weights_vec_[pass_][f] * features[f];
49    }
50    return ClipToRange(-unnorm_score / kScoreScaleFactor, kMinFinalCost, kMaxFinalCost);
51  }
52  bool ParamsModel::Equivalent(const ParamsModel &that) const {
53    float epsilon = 0.0001f;
54    for (int p = 0; p < PTRAIN_NUM_PASSES; ++p) {
55      if (weights_vec_[p].size() != that.weights_vec_[p].size()) {
56        return false;
57      }
58      for (unsigned i = 0; i < weights_vec_[p].size(); i++) {
59        if (weights_vec_[p][i] != that.weights_vec_[p][i] &&
60            std::fabs(weights_vec_[p][i] - that.weights_vec_[p][i]) > epsilon) {
61          return false;
62        }
63      }
64    }
65    return true;
66  }
67  bool ParamsModel::LoadFromFp(const char *lang, TFile *fp) {
68    const int kMaxLineSize = 100;
69    char line[kMaxLineSize];
70    BitVector present;
71    present.Init(PTRAIN_NUM_FEATURE_TYPES);
72    lang_ = lang;
73    std::vector<float> &weights = weights_vec_[pass_];
74    weights.clear();
75    weights.resize(PTRAIN_NUM_FEATURE_TYPES, 0.0f);
76    while (fp->FGets(line, kMaxLineSize) != nullptr) {
77      char *key = nullptr;
78      float value;
79      if (!ParseLine(line, &key, &value)) {
80        continue;
81      }
82      int idx = ParamsTrainingFeatureByName(key);
83      if (idx < 0) {
84        tprintf("ParamsModel::Unknown parameter %s\n", key);
85        continue;
86      }
87      if (!present[idx]) {
88        present.SetValue(idx, true);
89      }
90      weights[idx] = value;
91    }
92    bool complete = (present.NumSetBits() == PTRAIN_NUM_FEATURE_TYPES);
93    if (!complete) {
94      for (int i = 0; i < PTRAIN_NUM_FEATURE_TYPES; i++) {
95        if (!present[i]) {
96          tprintf("Missing field %s.\n", kParamsTrainingFeatureTypeName[i]);
97        }
98      }
99      lang_ = "";
100      weights.clear();
101    }
102    return complete;
103  }
104  bool ParamsModel::SaveToFile(const char *full_path) const {
105    const std::vector<float> &weights = weights_vec_[pass_];
106    if (weights.size() != PTRAIN_NUM_FEATURE_TYPES) {
107      tprintf("Refusing to save ParamsModel that has not been initialized.\n");
108      return false;
109    }
110    FILE *fp = fopen(full_path, "wb");
111    if (!fp) {
112      tprintf("Could not open %s for writing.\n", full_path);
113      return false;
114    }
115    bool all_good = true;
116    for (unsigned i = 0; i < weights.size(); i++) {
117      if (fprintf(fp, "%s %f\n", kParamsTrainingFeatureTypeName[i], weights[i]) < 0) {
118        all_good = false;
119      }
120    }
121    fclose(fp);
122    return all_good;
123  }
124  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-params_model.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-params_model.cpp</div>
                </div>
                <div class="column column_space"><pre><code>10  static const float kScoreScaleFactor = 100.0f;
11  static const float kMinFinalCost = 0.001f;
12  static const float kMaxFinalCost = 100.0f;
</pre></code></div>
                <div class="column column_space"><pre><code>11  static const float kMinFinalCost = 0.001f;
12  static const float kMaxFinalCost = 100.0f;
13  void ParamsModel::Print() {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    