
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4837007140639553%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-civil_time_detail.h</h3>
            <pre><code>1  #ifndef ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_
2  #define ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_
3  #include <cstdint>
4  #include <limits>
5  #include <ostream>
6  #include <type_traits>
7  #include "absl/base/config.h"
8  #if __cpp_constexpr >= 201304 || (defined(_MSC_VER) && _MSC_VER >= 1910)
9  #define CONSTEXPR_D constexpr  
10  #define CONSTEXPR_F constexpr  
11  #define CONSTEXPR_M constexpr  
12  #else
13  #define CONSTEXPR_D const
14  #define CONSTEXPR_F inline
15  #define CONSTEXPR_M
16  #endif
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace time_internal {
20  namespace cctz {
21  using year_t = std::int_fast64_t;
22  using diff_t = std::int_fast64_t;
23  namespace detail {
24  using month_t = std::int_fast8_t;   
25  using day_t = std::int_fast8_t;     
26  using hour_t = std::int_fast8_t;    
27  using minute_t = std::int_fast8_t;  
28  using second_t = std::int_fast8_t;  
29  struct fields {
30    CONSTEXPR_M fields(year_t year, month_t month, day_t day, hour_t hour,
31                       minute_t minute, second_t second)
32        : y(year), m(month), d(day), hh(hour), mm(minute), ss(second) {}
33    std::int_least64_t y;
34    std::int_least8_t m;
35    std::int_least8_t d;
36    std::int_least8_t hh;
37    std::int_least8_t mm;
38    std::int_least8_t ss;
39  };
40  struct second_tag {};
41  struct minute_tag : second_tag {};
42  struct hour_tag : minute_tag {};
43  struct day_tag : hour_tag {};
44  struct month_tag : day_tag {};
45  struct year_tag : month_tag {};
46  namespace impl {
47  CONSTEXPR_F bool is_leap_year(year_t y) noexcept {
48    return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
49  }
50  CONSTEXPR_F int year_index(year_t y, month_t m) noexcept {
51    const int yi = static_cast<int>((y + (m > 2)) % 400);
52    return yi < 0 ? yi + 400 : yi;
53  }
54  CONSTEXPR_F int days_per_century(int yi) noexcept {
55    return 36524 + (yi == 0 || yi > 300);
56  }
57  CONSTEXPR_F int days_per_4years(int yi) noexcept {
58    return 1460 + (yi == 0 || yi > 300 || (yi - 1) % 100 < 96);
59  }
60  CONSTEXPR_F int days_per_year(year_t y, month_t m) noexcept {
61    return is_leap_year(y + (m > 2)) ? 366 : 365;
62  }
63  CONSTEXPR_F int days_per_month(year_t y, month_t m) noexcept {
64    CONSTEXPR_D int k_days_per_month[1 + 12] = {
65        -1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  
66    };
67    return k_days_per_month[m] + (m == 2 && is_leap_year(y));
68  }
69  CONSTEXPR_F fields n_day(year_t y, month_t m, diff_t d, diff_t cd, hour_t hh,
70                           minute_t mm, second_t ss) noexcept {
71    year_t ey = y % 400;
72    const year_t oey = ey;
73    ey += (cd / 146097) * 400;
74    cd %= 146097;
75    if (cd < 0) {
76      ey -= 400;
77      cd += 146097;
78    }
79    ey += (d / 146097) * 400;
80    d = d % 146097 + cd;
81    if (d > 0) {
82      if (d > 146097) {
83        ey += 400;
84        d -= 146097;
85      }
<span onclick='openModal()' class='match'>86    } else {
87      if (d > -365) {
88        ey -= 1;
89        d += days_per_year(ey, m);
90      } else {
91        ey -= 400;
92        d += 146097;
93      }
</span>94    }
95    if (d > 365) {
96      int yi = year_index(ey, m);  
97      for (;;) {
98        int n = days_per_century(yi);
99        if (d <= n) break;
100        d -= n;
101        ey += 100;
102        yi += 100;
103        if (yi >= 400) yi -= 400;
104      }
105      for (;;) {
106        int n = days_per_4years(yi);
107        if (d <= n) break;
108        d -= n;
109        ey += 4;
110        yi += 4;
111        if (yi >= 400) yi -= 400;
112      }
113      for (;;) {
114        int n = days_per_year(ey, m);
115        if (d <= n) break;
116        d -= n;
117        ++ey;
118      }
119    }
120    if (d > 28) {
121      for (;;) {
122        int n = days_per_month(ey, m);
123        if (d <= n) break;
124        d -= n;
125        if (++m > 12) {
126          ++ey;
127          m = 1;
128        }
129      }
130    }
131    return fields(y + (ey - oey), m, static_cast<day_t>(d), hh, mm, ss);
132  }
133  CONSTEXPR_F fields n_mon(year_t y, diff_t m, diff_t d, diff_t cd, hour_t hh,
134                           minute_t mm, second_t ss) noexcept {
135    if (m != 12) {
136      y += m / 12;
137      m %= 12;
138      if (m <= 0) {
139        y -= 1;
140        m += 12;
141      }
142    }
143    return n_day(y, static_cast<month_t>(m), d, cd, hh, mm, ss);
144  }
145  CONSTEXPR_F fields n_hour(year_t y, diff_t m, diff_t d, diff_t cd, diff_t hh,
146                            minute_t mm, second_t ss) noexcept {
147    cd += hh / 24;
148    hh %= 24;
149    if (hh < 0) {
150      cd -= 1;
151      hh += 24;
152    }
153    return n_mon(y, m, d, cd, static_cast<hour_t>(hh), mm, ss);
154  }
155  CONSTEXPR_F fields n_min(year_t y, diff_t m, diff_t d, diff_t hh, diff_t ch,
156                           diff_t mm, second_t ss) noexcept {
157    ch += mm / 60;
158    mm %= 60;
159    if (mm < 0) {
160      ch -= 1;
161      mm += 60;
162    }
163    return n_hour(y, m, d, hh / 24 + ch / 24, hh % 24 + ch % 24,
164                  static_cast<minute_t>(mm), ss);
165  }
166  CONSTEXPR_F fields n_sec(year_t y, diff_t m, diff_t d, diff_t hh, diff_t mm,
167                           diff_t ss) noexcept {
168    if (0 <= ss && ss < 60) {
169      const second_t nss = static_cast<second_t>(ss);
170      if (0 <= mm && mm < 60) {
171        const minute_t nmm = static_cast<minute_t>(mm);
172        if (0 <= hh && hh < 24) {
173          const hour_t nhh = static_cast<hour_t>(hh);
174          if (1 <= d && d <= 28 && 1 <= m && m <= 12) {
175            const day_t nd = static_cast<day_t>(d);
176            const month_t nm = static_cast<month_t>(m);
177            return fields(y, nm, nd, nhh, nmm, nss);
178          }
179          return n_mon(y, m, d, 0, nhh, nmm, nss);
180        }
181        return n_hour(y, m, d, hh / 24, hh % 24, nmm, nss);
182      }
183      return n_min(y, m, d, hh, mm / 60, mm % 60, nss);
184    }
185    diff_t cm = ss / 60;
186    ss %= 60;
187    if (ss < 0) {
188      cm -= 1;
189      ss += 60;
190    }
191    return n_min(y, m, d, hh, mm / 60 + cm / 60, mm % 60 + cm % 60,
192                 static_cast<second_t>(ss));
193  }
194  }  
195  CONSTEXPR_F fields step(second_tag, fields f, diff_t n) noexcept {
196    return impl::n_sec(f.y, f.m, f.d, f.hh, f.mm + n / 60, f.ss + n % 60);
197  }
198  CONSTEXPR_F fields step(minute_tag, fields f, diff_t n) noexcept {
199    return impl::n_min(f.y, f.m, f.d, f.hh + n / 60, 0, f.mm + n % 60, f.ss);
200  }
201  CONSTEXPR_F fields step(hour_tag, fields f, diff_t n) noexcept {
202    return impl::n_hour(f.y, f.m, f.d + n / 24, 0, f.hh + n % 24, f.mm, f.ss);
203  }
204  CONSTEXPR_F fields step(day_tag, fields f, diff_t n) noexcept {
205    return impl::n_day(f.y, f.m, f.d, n, f.hh, f.mm, f.ss);
206  }
207  CONSTEXPR_F fields step(month_tag, fields f, diff_t n) noexcept {
208    return impl::n_mon(f.y + n / 12, f.m + n % 12, f.d, 0, f.hh, f.mm, f.ss);
209  }
210  CONSTEXPR_F fields step(year_tag, fields f, diff_t n) noexcept {
211    return fields(f.y + n, f.m, f.d, f.hh, f.mm, f.ss);
212  }
213  namespace impl {
214  CONSTEXPR_F diff_t scale_add(diff_t v, diff_t f, diff_t a) noexcept {
215    return (v < 0) ? ((v + 1) * f + a) - f : ((v - 1) * f + a) + f;
216  }
217  CONSTEXPR_F diff_t ymd_ord(year_t y, month_t m, day_t d) noexcept {
218    const diff_t eyear = (m <= 2) ? y - 1 : y;
219    const diff_t era = (eyear >= 0 ? eyear : eyear - 399) / 400;
220    const diff_t yoe = eyear - era * 400;
221    const diff_t doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;
222    const diff_t doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
223    return era * 146097 + doe - 719468;
224  }
225  CONSTEXPR_F diff_t day_difference(year_t y1, month_t m1, day_t d1, year_t y2,
226                                    month_t m2, day_t d2) noexcept {
227    const diff_t a_c4_off = y1 % 400;
228    const diff_t b_c4_off = y2 % 400;
229    diff_t c4_diff = (y1 - a_c4_off) - (y2 - b_c4_off);
230    diff_t delta = ymd_ord(a_c4_off, m1, d1) - ymd_ord(b_c4_off, m2, d2);
231    if (c4_diff > 0 && delta < 0) {
232      delta += 2 * 146097;
233      c4_diff -= 2 * 400;
234    } else if (c4_diff < 0 && delta > 0) {
235      delta -= 2 * 146097;
236      c4_diff += 2 * 400;
237    }
238    return (c4_diff / 400 * 146097) + delta;
239  }
240  }  
241  CONSTEXPR_F diff_t difference(year_tag, fields f1, fields f2) noexcept {
242    return f1.y - f2.y;
243  }
244  CONSTEXPR_F diff_t difference(month_tag, fields f1, fields f2) noexcept {
245    return impl::scale_add(difference(year_tag{}, f1, f2), 12, (f1.m - f2.m));
246  }
247  CONSTEXPR_F diff_t difference(day_tag, fields f1, fields f2) noexcept {
248    return impl::day_difference(f1.y, f1.m, f1.d, f2.y, f2.m, f2.d);
249  }
250  CONSTEXPR_F diff_t difference(hour_tag, fields f1, fields f2) noexcept {
251    return impl::scale_add(difference(day_tag{}, f1, f2), 24, (f1.hh - f2.hh));
252  }
253  CONSTEXPR_F diff_t difference(minute_tag, fields f1, fields f2) noexcept {
254    return impl::scale_add(difference(hour_tag{}, f1, f2), 60, (f1.mm - f2.mm));
255  }
256  CONSTEXPR_F diff_t difference(second_tag, fields f1, fields f2) noexcept {
257    return impl::scale_add(difference(minute_tag{}, f1, f2), 60, f1.ss - f2.ss);
258  }
259  CONSTEXPR_F fields align(second_tag, fields f) noexcept { return f; }
260  CONSTEXPR_F fields align(minute_tag, fields f) noexcept {
261    return fields{f.y, f.m, f.d, f.hh, f.mm, 0};
262  }
263  CONSTEXPR_F fields align(hour_tag, fields f) noexcept {
264    return fields{f.y, f.m, f.d, f.hh, 0, 0};
265  }
266  CONSTEXPR_F fields align(day_tag, fields f) noexcept {
267    return fields{f.y, f.m, f.d, 0, 0, 0};
268  }
269  CONSTEXPR_F fields align(month_tag, fields f) noexcept {
270    return fields{f.y, f.m, 1, 0, 0, 0};
271  }
272  CONSTEXPR_F fields align(year_tag, fields f) noexcept {
273    return fields{f.y, 1, 1, 0, 0, 0};
274  }
275  namespace impl {
276  template <typename H>
277  H AbslHashValueImpl(second_tag, H h, fields f) {
278    return H::combine(std::move(h), f.y, f.m, f.d, f.hh, f.mm, f.ss);
279  }
280  template <typename H>
281  H AbslHashValueImpl(minute_tag, H h, fields f) {
282    return H::combine(std::move(h), f.y, f.m, f.d, f.hh, f.mm);
283  }
284  template <typename H>
285  H AbslHashValueImpl(hour_tag, H h, fields f) {
286    return H::combine(std::move(h), f.y, f.m, f.d, f.hh);
287  }
288  template <typename H>
289  H AbslHashValueImpl(day_tag, H h, fields f) {
290    return H::combine(std::move(h), f.y, f.m, f.d);
291  }
292  template <typename H>
293  H AbslHashValueImpl(month_tag, H h, fields f) {
294    return H::combine(std::move(h), f.y, f.m);
295  }
296  template <typename H>
297  H AbslHashValueImpl(year_tag, H h, fields f) {
298    return H::combine(std::move(h), f.y);
299  }
300  }  
301  template <typename T>
302  class civil_time {
303   public:
304    explicit CONSTEXPR_M civil_time(year_t y, diff_t m = 1, diff_t d = 1,
305                                    diff_t hh = 0, diff_t mm = 0,
306                                    diff_t ss = 0) noexcept
307        : civil_time(impl::n_sec(y, m, d, hh, mm, ss)) {}
308    CONSTEXPR_M civil_time() noexcept : f_{1970, 1, 1, 0, 0, 0} {}
309    civil_time(const civil_time&) = default;
310    civil_time& operator=(const civil_time&) = default;
311    template <typename U, typename S>
312    using preserves_data =
313        typename std::enable_if<std::is_base_of<U, S>::value>::type;
314    template <typename U>
315    CONSTEXPR_M civil_time(const civil_time<U>& ct,
316                           preserves_data<T, U>* = nullptr) noexcept
317        : civil_time(ct.f_) {}
318    template <typename U>
319    explicit CONSTEXPR_M civil_time(const civil_time<U>& ct,
320                                    preserves_data<U, T>* = nullptr) noexcept
321        : civil_time(ct.f_) {}
322    static CONSTEXPR_F civil_time(max)() {
323      const auto max_year = (std::numeric_limits<std::int_least64_t>::max)();
324      return civil_time(max_year, 12, 31, 23, 59, 59);
325    }
326    static CONSTEXPR_F civil_time(min)() {
327      const auto min_year = (std::numeric_limits<std::int_least64_t>::min)();
328      return civil_time(min_year, 1, 1, 0, 0, 0);
329    }
330    CONSTEXPR_M year_t year() const noexcept { return f_.y; }
331    CONSTEXPR_M int month() const noexcept { return f_.m; }
332    CONSTEXPR_M int day() const noexcept { return f_.d; }
333    CONSTEXPR_M int hour() const noexcept { return f_.hh; }
334    CONSTEXPR_M int minute() const noexcept { return f_.mm; }
335    CONSTEXPR_M int second() const noexcept { return f_.ss; }
336    CONSTEXPR_M civil_time& operator+=(diff_t n) noexcept {
337      return *this = *this + n;
338    }
339    CONSTEXPR_M civil_time& operator-=(diff_t n) noexcept {
340      return *this = *this - n;
341    }
342    CONSTEXPR_M civil_time& operator++() noexcept { return *this += 1; }
343    CONSTEXPR_M civil_time operator++(int) noexcept {
344      const civil_time a = *this;
345      ++*this;
346      return a;
347    }
348    CONSTEXPR_M civil_time& operator--() noexcept { return *this -= 1; }
349    CONSTEXPR_M civil_time operator--(int) noexcept {
350      const civil_time a = *this;
351      --*this;
352      return a;
353    }
354    friend CONSTEXPR_F civil_time operator+(civil_time a, diff_t n) noexcept {
355      return civil_time(step(T{}, a.f_, n));
356    }
357    friend CONSTEXPR_F civil_time operator+(diff_t n, civil_time a) noexcept {
358      return a + n;
359    }
360    friend CONSTEXPR_F civil_time operator-(civil_time a, diff_t n) noexcept {
361      return n != (std::numeric_limits<diff_t>::min)()
362                 ? civil_time(step(T{}, a.f_, -n))
363                 : civil_time(step(T{}, step(T{}, a.f_, -(n + 1)), 1));
364    }
365    friend CONSTEXPR_F diff_t operator-(civil_time lhs, civil_time rhs) noexcept {
366      return difference(T{}, lhs.f_, rhs.f_);
367    }
368    template <typename H>
369    friend H AbslHashValue(H h, civil_time a) {
370      return impl::AbslHashValueImpl(T{}, std::move(h), a.f_);
371    }
372   private:
373    template <typename U>
374    friend class civil_time;
375    explicit CONSTEXPR_M civil_time(fields f) noexcept : f_(align(T{}, f)) {}
376    fields f_;
377  };
378  template <typename T, typename U>
379  CONSTEXPR_F diff_t operator-(civil_time<T>, civil_time<U>) = delete;
380  using civil_year = civil_time<year_tag>;
381  using civil_month = civil_time<month_tag>;
382  using civil_day = civil_time<day_tag>;
383  using civil_hour = civil_time<hour_tag>;
384  using civil_minute = civil_time<minute_tag>;
385  using civil_second = civil_time<second_tag>;
386  template <typename T1, typename T2>
387  CONSTEXPR_F bool operator<(const civil_time<T1>& lhs,
388                             const civil_time<T2>& rhs) noexcept {
389    return (
390        lhs.year() < rhs.year() ||
391        (lhs.year() == rhs.year() &&
392         (lhs.month() < rhs.month() ||
393          (lhs.month() == rhs.month() &&
394           (lhs.day() < rhs.day() || (lhs.day() == rhs.day() &&
395                                      (lhs.hour() < rhs.hour() ||
396                                       (lhs.hour() == rhs.hour() &&
397                                        (lhs.minute() < rhs.minute() ||
398                                         (lhs.minute() == rhs.minute() &&
399                                          (lhs.second() < rhs.second())))))))))));
400  }
401  template <typename T1, typename T2>
402  CONSTEXPR_F bool operator<=(const civil_time<T1>& lhs,
403                              const civil_time<T2>& rhs) noexcept {
404    return !(rhs < lhs);
405  }
406  template <typename T1, typename T2>
407  CONSTEXPR_F bool operator>=(const civil_time<T1>& lhs,
408                              const civil_time<T2>& rhs) noexcept {
409    return !(lhs < rhs);
410  }
411  template <typename T1, typename T2>
412  CONSTEXPR_F bool operator>(const civil_time<T1>& lhs,
413                             const civil_time<T2>& rhs) noexcept {
414    return rhs < lhs;
415  }
416  template <typename T1, typename T2>
417  CONSTEXPR_F bool operator==(const civil_time<T1>& lhs,
418                              const civil_time<T2>& rhs) noexcept {
419    return lhs.year() == rhs.year() && lhs.month() == rhs.month() &&
420           lhs.day() == rhs.day() && lhs.hour() == rhs.hour() &&
421           lhs.minute() == rhs.minute() && lhs.second() == rhs.second();
422  }
423  template <typename T1, typename T2>
424  CONSTEXPR_F bool operator!=(const civil_time<T1>& lhs,
425                              const civil_time<T2>& rhs) noexcept {
426    return !(lhs == rhs);
427  }
428  enum class weekday {
429    monday,
430    tuesday,
431    wednesday,
432    thursday,
433    friday,
434    saturday,
435    sunday,
436  };
437  CONSTEXPR_F weekday get_weekday(const civil_second& cs) noexcept {
438    CONSTEXPR_D weekday k_weekday_by_mon_off[13] = {
439        weekday::monday,    weekday::tuesday,  weekday::wednesday,
440        weekday::thursday,  weekday::friday,   weekday::saturday,
441        weekday::sunday,    weekday::monday,   weekday::tuesday,
442        weekday::wednesday, weekday::thursday, weekday::friday,
443        weekday::saturday,
444    };
445    CONSTEXPR_D int k_weekday_offsets[1 + 12] = {
446        -1, 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4,
447    };
448    year_t wd = 2400 + (cs.year() % 400) - (cs.month() < 3);
449    wd += wd / 4 - wd / 100 + wd / 400;
450    wd += k_weekday_offsets[cs.month()] + cs.day();
451    return k_weekday_by_mon_off[wd % 7 + 6];
452  }
453  CONSTEXPR_F civil_day next_weekday(civil_day cd, weekday wd) noexcept {
454    CONSTEXPR_D weekday k_weekdays_forw[14] = {
455        weekday::monday,    weekday::tuesday,  weekday::wednesday,
456        weekday::thursday,  weekday::friday,   weekday::saturday,
457        weekday::sunday,    weekday::monday,   weekday::tuesday,
458        weekday::wednesday, weekday::thursday, weekday::friday,
459        weekday::saturday,  weekday::sunday,
460    };
461    weekday base = get_weekday(cd);
462    for (int i = 0;; ++i) {
463      if (base == k_weekdays_forw[i]) {
464        for (int j = i + 1;; ++j) {
465          if (wd == k_weekdays_forw[j]) {
466            return cd + (j - i);
467          }
468        }
469      }
470    }
471  }
472  CONSTEXPR_F civil_day prev_weekday(civil_day cd, weekday wd) noexcept {
473    CONSTEXPR_D weekday k_weekdays_back[14] = {
474        weekday::sunday,   weekday::saturday,  weekday::friday,
475        weekday::thursday, weekday::wednesday, weekday::tuesday,
476        weekday::monday,   weekday::sunday,    weekday::saturday,
477        weekday::friday,   weekday::thursday,  weekday::wednesday,
478        weekday::tuesday,  weekday::monday,
479    };
480    weekday base = get_weekday(cd);
481    for (int i = 0;; ++i) {
482      if (base == k_weekdays_back[i]) {
483        for (int j = i + 1;; ++j) {
484          if (wd == k_weekdays_back[j]) {
485            return cd - (j - i);
486          }
487        }
488      }
489    }
490  }
491  CONSTEXPR_F int get_yearday(const civil_second& cs) noexcept {
492    CONSTEXPR_D int k_month_offsets[1 + 12] = {
493        -1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
494    };
495    const int feb29 = (cs.month() > 2 && impl::is_leap_year(cs.year()));
496    return k_month_offsets[cs.month()] + feb29 + cs.day();
497  }
498  std::ostream& operator<<(std::ostream& os, const civil_year& y);
499  std::ostream& operator<<(std::ostream& os, const civil_month& m);
500  std::ostream& operator<<(std::ostream& os, const civil_day& d);
501  std::ostream& operator<<(std::ostream& os, const civil_hour& h);
502  std::ostream& operator<<(std::ostream& os, const civil_minute& m);
503  std::ostream& operator<<(std::ostream& os, const civil_second& s);
504  std::ostream& operator<<(std::ostream& os, weekday wd);
505  }  
506  }  
507  }  
508  ABSL_NAMESPACE_END
509  }  
510  #undef CONSTEXPR_M
511  #undef CONSTEXPR_F
512  #undef CONSTEXPR_D
513  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-conv.h</h3>
            <pre><code>1  #ifndef CONV_H
2  #define CONV_H
3  namespace TSnap {
4  template<class PGraph>
5  PGraph ToGraph(PTable Table, const TStr& SrcCol, const TStr& DstCol, TAttrAggr AggrPolicy)
6  {
7  	PGraph Graph = PGraph::TObj::New();
8    const TAttrType NodeType = Table->GetColType(SrcCol);
9    Assert(NodeType == Table->GetColType(DstCol));
10    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
11    const TInt DstColIdx = Table->GetColIdx(DstCol);
12    if (NodeType == atInt) {
13      for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
14        if ((Table->Next)[CurrRowIdx] == Table->Invalid) { continue; }
15        TInt SVal = (Table->IntCols)[SrcColIdx][CurrRowIdx];
16        TInt DVal = (Table->IntCols)[DstColIdx][CurrRowIdx];
17        Graph->AddNodeUnchecked(SVal);
18        Graph->AddNodeUnchecked(DVal);
19        Graph->AddEdgeUnchecked(SVal, DVal);
20      }
21    } else if (NodeType == atFlt) {
22      THash<TFlt, TInt> FltNodeVals;
23      for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
24        if ((Table->Next)[CurrRowIdx] == Table->Invalid) { continue; }
25        TInt SVal, DVal;
26        TFlt FSVal = (Table->FltCols)[SrcColIdx][CurrRowIdx];
27        SVal = Table->CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
28        TFlt FDVal = (Table->FltCols)[SrcColIdx][CurrRowIdx];
29        DVal = Table->CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
30        Graph->AddEdge(SVal, DVal);
31      }
32    } else {
33      for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
34        if ((Table->Next)[CurrRowIdx] == Table->Invalid) { continue; }
35        TInt SVal = (Table->StrColMaps)[SrcColIdx][CurrRowIdx];
36        TInt DVal = (Table->StrColMaps)[DstColIdx][CurrRowIdx];
37        Graph->AddNodeUnchecked(SVal);
38        Graph->AddNodeUnchecked(DVal);
39        Graph->AddEdgeUnchecked(SVal, DVal);
40      }
41    }
42    Graph->SortNodeAdjV();
43    return Graph;
44  }
45  template<class PGraph>
46  PGraph ToNetwork(PTable Table,
47    const TStr& SrcCol, const TStr& DstCol,
48    TStrV& SrcAttrV, TStrV& DstAttrV, TStrV& EdgeAttrV,
49    TAttrAggr AggrPolicy)
50  {
51  	PGraph Graph = PGraph::TObj::New();
52    const TAttrType NodeType = Table->GetColType(SrcCol);
53    Assert(NodeType == Table->GetColType(DstCol));
54    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
55    const TInt DstColIdx = Table->GetColIdx(DstCol);
56    THash<TFlt, TInt> FltNodeVals;
57    THash<TInt, TStrIntVH> NodeIntAttrs;
58    THash<TInt, TStrFltVH> NodeFltAttrs;
59    THash<TInt, TStrStrVH> NodeStrAttrs;
60    for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
61      if ((Table->Next)[CurrRowIdx] == Table->Invalid) {
62        continue;
63      }
64     TInt SVal, DVal;
65      if (NodeType == atFlt) {
66        TFlt FSVal = (Table->FltCols)[SrcColIdx][CurrRowIdx];
67        SVal = Table->CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
68        TFlt FDVal = (Table->FltCols)[SrcColIdx][CurrRowIdx];
69        DVal = Table->CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
70      } else if (NodeType == atInt || NodeType == atStr) {
71        if (NodeType == atInt) {
72          SVal = (Table->IntCols)[SrcColIdx][CurrRowIdx];
73          DVal = (Table->IntCols)[DstColIdx][CurrRowIdx];
74        } else {
75          SVal = (Table->StrColMaps)[SrcColIdx][CurrRowIdx];
76          if (strlen(Table->GetContextKey(SVal)) == 0) { continue; }  
77          DVal = (Table->StrColMaps)[DstColIdx][CurrRowIdx];
78          if (strlen(Table->GetContextKey(DVal)) == 0) { continue; }  
79        }
80        if (!Graph->IsNode(SVal)) {Graph->AddNode(SVal); }
81        if (!Graph->IsNode(DVal)) {Graph->AddNode(DVal); }
82      }
83      Graph->AddEdge(SVal, DVal, CurrRowIdx);
84  		for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
85  			TStr ColName = EdgeAttrV[i];
86  			TAttrType T = Table->GetColType(ColName);
87  			TInt Index = Table->GetColIdx(ColName);
88  			switch (T) {
89  				case atInt:
90  					Graph->AddIntAttrDatE(CurrRowIdx, Table->IntCols[Index][CurrRowIdx], ColName);
91  					break;
92  				case atFlt:
93  					Graph->AddFltAttrDatE(CurrRowIdx, Table->FltCols[Index][CurrRowIdx], ColName);
94  					break;
95  				case atStr:
96  					Graph->AddStrAttrDatE(CurrRowIdx, Table->GetStrValIdx(Index, CurrRowIdx), ColName);
97  					break;
98  			}
99  		}
100      if ((Table->SrcNodeAttrV).Len() > 0) {
101        Table->AddNodeAttributes(SVal, Table->SrcNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
102    	}
103      if ((Table->DstNodeAttrV).Len() > 0) {
104        Table->AddNodeAttributes(DVal, Table->DstNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
105      }
106    }
107    if ((Table->SrcNodeAttrV).Len() > 0 || (Table->DstNodeAttrV).Len() > 0) {
108      for (TNEANet::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
109        TInt NId = NodeI.GetId();
110        if (NodeIntAttrs.IsKey(NId)) {
111          TStrIntVH IntAttrVals = NodeIntAttrs.GetDat(NId);
112          for (TStrIntVH::TIter it = IntAttrVals.BegI(); it < IntAttrVals.EndI(); it++) {
113            TInt AttrVal = Table->AggregateVector<TInt>(it.GetDat(), AggrPolicy);
114            Graph->AddIntAttrDatN(NId, AttrVal, it.GetKey());
115          }
116        }
117        if (NodeFltAttrs.IsKey(NId)) {
118          TStrFltVH FltAttrVals = NodeFltAttrs.GetDat(NId);
119          for (TStrFltVH::TIter it = FltAttrVals.BegI(); it < FltAttrVals.EndI(); it++) {
120            TFlt AttrVal = Table->AggregateVector<TFlt>(it.GetDat(), AggrPolicy);
121            Graph->AddFltAttrDatN(NId, AttrVal, it.GetKey());
122          }
123        }
124        if (NodeStrAttrs.IsKey(NId)) {
125          TStrStrVH StrAttrVals = NodeStrAttrs.GetDat(NId);
126          for (TStrStrVH::TIter it = StrAttrVals.BegI(); it < StrAttrVals.EndI(); it++) {
127            TStr AttrVal = Table->AggregateVector<TStr>(it.GetDat(), AggrPolicy);
128            Graph->AddStrAttrDatN(NId, AttrVal, it.GetKey());
129          }
130        }
131      }
132    }
133    return Graph;
134  }
135  template<class PGraph>
136  PGraph ToNetwork(PTable Table,
137    const TStr& SrcCol, const TStr& DstCol, TAttrAggr AggrPolicy)
138  {
139    TStrV V;
140    return ToNetwork<PGraph>(Table, SrcCol, DstCol, V, AggrPolicy);
141  }
142  #ifdef GCC_ATOMIC
143  template<class PGraphMP>
144  PGraphMP ToGraphMP(PTable Table, const TStr& SrcCol, const TStr& DstCol) {
145    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
146    const TInt DstColIdx = Table->GetColIdx(DstCol);
147    const TAttrType NodeType = Table->GetColType(SrcCol);
148    Assert(NodeType == Table->GetColType(DstCol));
149    const TInt NumRows = Table->NumValidRows;
150    TIntV SrcCol1, DstCol1, SrcCol2, DstCol2;
151    #pragma omp parallel sections num_threads(4)
152    {
153      #pragma omp section
154      { SrcCol1.Reserve(NumRows, NumRows); }
155      #pragma omp section
156      { SrcCol2.Reserve(NumRows, NumRows); }
157      #pragma omp section
158      { DstCol1.Reserve(NumRows, NumRows); }
159      #pragma omp section
160      { DstCol2.Reserve(NumRows, NumRows); }
161    }
162    TIntPrV Partitions;
163    Table->GetPartitionRanges(Partitions, omp_get_max_threads());
164    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
165    omp_set_num_threads(omp_get_max_threads());
166    if (NodeType == atInt) {
167      #pragma omp parallel for schedule(static)
168      for (int i = 0; i < Partitions.Len(); i++) {
169        TRowIterator RowI(Partitions[i].GetVal1(), Table());
170        TRowIterator EndI(Partitions[i].GetVal2(), Table());
171        while (RowI < EndI) {
172          TInt RowId = RowI.GetRowIdx();
173          SrcCol1[RowId] = RowI.GetIntAttr(SrcColIdx);
174          SrcCol2[RowId] = RowI.GetIntAttr(SrcColIdx);
175          DstCol1[RowId] = RowI.GetIntAttr(DstColIdx);
176          DstCol2[RowId] = RowI.GetIntAttr(DstColIdx);
177          RowI++;
178        }
179      }
180    }
181    else if (NodeType == atStr) {
182      #pragma omp parallel for schedule(static)
183      for (int i = 0; i < Partitions.Len(); i++) {
184        TRowIterator RowI(Partitions[i].GetVal1(), Table());
185        TRowIterator EndI(Partitions[i].GetVal2(), Table());
186        while (RowI < EndI) {
187          TInt RowId = RowI.GetRowIdx();
188          SrcCol1[RowId] = RowI.GetStrMapById(SrcColIdx);
189          SrcCol2[RowId] = RowI.GetStrMapById(SrcColIdx);
190          DstCol1[RowId] = RowI.GetStrMapById(DstColIdx);
191          DstCol2[RowId] = RowI.GetStrMapById(DstColIdx);
192          RowI++;
193        }
194      }
195    }
196    omp_set_num_threads(omp_get_max_threads());
197    #pragma omp parallel
198    {
199      #pragma omp single nowait
200      {
201        #pragma omp task untied shared(SrcCol1, DstCol1)
202        { TTable::QSortKeyVal(SrcCol1, DstCol1, 0, NumRows-1); }
203      }
204      #pragma omp single nowait
205      {
206        #pragma omp task untied shared(SrcCol2, DstCol2)
207       { TTable::QSortKeyVal(DstCol2, SrcCol2, 0, NumRows-1); }
208      }
209      #pragma omp taskwait
210    }
211    TInt NumThreads = omp_get_max_threads();
212    TInt PartSize = (NumRows/NumThreads);
213    TIntV SrcOffsets, DstOffsets;
214    SrcOffsets.Add(0);
215    for (TInt i = 1; i < NumThreads; i++) {
216      TInt CurrOffset = i * PartSize;
217      while (CurrOffset < (i+1) * PartSize &&
218            SrcCol1[CurrOffset-1] == SrcCol1[CurrOffset]) {
219        CurrOffset++;
220      }
221      if (CurrOffset < (i+1) * PartSize) { SrcOffsets.Add(CurrOffset); }
222    }
223    SrcOffsets.Add(NumRows);
224    DstOffsets.Add(0);
225    for (TInt i = 1; i < NumThreads; i++) {
226      TInt CurrOffset = i * PartSize;
227      while (CurrOffset < (i+1) * PartSize &&
228            DstCol2[CurrOffset-1] == DstCol2[CurrOffset]) {
229        CurrOffset++;
230      }
231      if (CurrOffset < (i+1) * PartSize) { DstOffsets.Add(CurrOffset); }
232    }
233    DstOffsets.Add(NumRows);
234    TInt SrcPartCnt = SrcOffsets.Len()-1;
235    TInt DstPartCnt = DstOffsets.Len()-1;
236    TIntV SrcNodeCounts, DstNodeCounts;
237    SrcNodeCounts.Reserve(SrcPartCnt, SrcPartCnt);
238    DstNodeCounts.Reserve(DstPartCnt, DstPartCnt);
239    #pragma omp parallel for schedule(dynamic)
240    for (int t = 0; t < SrcPartCnt+DstPartCnt; t++) {
241      if (t < SrcPartCnt) {
242        TInt i = t;
243        if (SrcOffsets[i] != SrcOffsets[i+1]) {
244          SrcNodeCounts[i] = 1;
245          TInt CurrNode = SrcCol1[SrcOffsets[i]];
246          for (TInt j = SrcOffsets[i]+1; j < SrcOffsets[i+1]; j++) {
247            while (j < SrcOffsets[i+1] && SrcCol1[j] == CurrNode) { j++; }
248            if (j < SrcOffsets[i+1]) {
249              SrcNodeCounts[i]++;
250              CurrNode = SrcCol1[j];
251            }
252          }
253        }
254      } else {
255        TInt i = t - SrcPartCnt;
256        if (DstOffsets[i] != DstOffsets[i+1]) {
257          DstNodeCounts[i] = 1;
258          TInt CurrNode = DstCol2[DstOffsets[i]];
259          for (TInt j = DstOffsets[i]+1; j < DstOffsets[i+1]; j++) {
260            while (j < DstOffsets[i+1] && DstCol2[j] == CurrNode) { j++; }
261            if (j < DstOffsets[i+1]) {
262              DstNodeCounts[i]++;
263              CurrNode = DstCol2[j];
264            }
265          }
266        }
267      }
268    }
269    TInt TotalSrcNodes = 0;
270    TIntV SrcIdOffsets;
271    for (int i = 0; i < SrcPartCnt; i++) {
272      SrcIdOffsets.Add(TotalSrcNodes);
273      TotalSrcNodes += SrcNodeCounts[i];
274    }
275    TInt TotalDstNodes = 0;
276    TIntV DstIdOffsets;
277    for (int i = 0; i < DstPartCnt; i++) {
278      DstIdOffsets.Add(TotalDstNodes);
279      TotalDstNodes += DstNodeCounts[i];
280    }
281    TIntPrV SrcNodeIds, DstNodeIds;
282    #pragma omp parallel sections
283    {
284      #pragma omp section
285      { SrcNodeIds.Reserve(TotalSrcNodes, TotalSrcNodes); }
286      #pragma omp section
287      { DstNodeIds.Reserve(TotalDstNodes, TotalDstNodes); }
288    }
289    #pragma omp parallel for schedule(dynamic)
290    for (int t = 0; t < SrcPartCnt+DstPartCnt; t++) {
291      if (t < SrcPartCnt) {
292        TInt i = t;
293        if (SrcOffsets[i] != SrcOffsets[i+1]) {
294          TInt CurrNode = SrcCol1[SrcOffsets[i]];
295          TInt ThreadOffset = SrcIdOffsets[i];
296          SrcNodeIds[ThreadOffset] = TIntPr(CurrNode, SrcOffsets[i]);
297          TInt CurrCount = 1;
298          for (TInt j = SrcOffsets[i]+1; j < SrcOffsets[i+1]; j++) {
299            while (j < SrcOffsets[i+1] && SrcCol1[j] == CurrNode) { j++; }
300            if (j < SrcOffsets[i+1]) {
301              CurrNode = SrcCol1[j];
302              SrcNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
303              CurrCount++;
304            }
305          }
306        }
307      } else {
308        TInt i = t - SrcPartCnt;
309        if (DstOffsets[i] != DstOffsets[i+1]) {
310          TInt CurrNode = DstCol2[DstOffsets[i]];
311          TInt ThreadOffset = DstIdOffsets[i];
312          DstNodeIds[ThreadOffset] = TIntPr(CurrNode, DstOffsets[i]);
313          TInt CurrCount = 1;
314          for (TInt j = DstOffsets[i]+1; j < DstOffsets[i+1]; j++) {
315            while (j < DstOffsets[i+1] && DstCol2[j] == CurrNode) { j++; }
316            if (j < DstOffsets[i+1]) {
317              CurrNode = DstCol2[j];
318              DstNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
319              CurrCount++;
320            }
321          }
322        }
323      }
324    }
325    TIntTrV Nodes;
326    Nodes.Reserve(TotalSrcNodes+TotalDstNodes);
327    TInt i = 0, j = 0;
328    while (i < TotalSrcNodes && j < TotalDstNodes) {
329      if (SrcNodeIds[i].Val1 == DstNodeIds[j].Val1) {
330        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, j));
331        i++;
332        j++;
333      } else if (SrcNodeIds[i].Val1 < DstNodeIds[j].Val1) {
334        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1));
335        i++;
336      } else {
337        Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j));
338        j++;
339      }
340    }
341    for (; i < TotalSrcNodes; i++) { Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1)); }
342    for (; j < TotalDstNodes; j++) { Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j)); }
343    TInt NumNodes = Nodes.Len();
344    PGraphMP Graph = TNGraphMP::New(NumNodes, NumRows);
345    NumThreads = 1;
346    int Delta = (NumNodes+NumThreads-1)/NumThreads;
347    TVec<TIntV> InVV(NumNodes);
348    TVec<TIntV> OutVV(NumNodes);
349    omp_set_num_threads(NumThreads);
350    #pragma omp parallel for schedule(static,Delta)
351    for (int m = 0; m < NumNodes; m++) {
352      TInt n, i, j;
353      Nodes[m].GetVal(n, i, j);
354      if (i >= 0) {
355        TInt Offset = SrcNodeIds[i].GetVal2();
356        TInt Sz = DstCol1.Len()-Offset;
357        if (i < SrcNodeIds.Len()-1) { Sz = SrcNodeIds[i+1].GetVal2()-Offset; }
358        OutVV[m].Reserve(Sz);
359      }
360      if (j >= 0) {
361        TInt Offset = DstNodeIds[j].GetVal2();
362        TInt Sz = SrcCol2.Len()-Offset;
363        if (j < DstNodeIds.Len()-1) { Sz = DstNodeIds[j+1].GetVal2()-Offset; }
364        InVV[m].Reserve(Sz);
365      }
366    }
367    NumThreads = omp_get_max_threads();
368    Delta = (NumNodes+NumThreads-1)/(10*NumThreads);
369    omp_set_num_threads(NumThreads);
370    #pragma omp parallel for schedule(dynamic)
371    for (int m = 0; m < NumNodes; m++) {
372      TInt n, i, j;
373      Nodes[m].GetVal(n, i, j);
374      if (i >= 0) {
375        TInt Offset = SrcNodeIds[i].GetVal2();
376        TInt Sz = DstCol1.Len()-Offset;
377        if (i < SrcNodeIds.Len()-1) { Sz = SrcNodeIds[i+1].GetVal2()-Offset; }
378        OutVV[m].CopyUniqueFrom(DstCol1, Offset, Sz);
379      }
380      if (j >= 0) {
381        TInt Offset = DstNodeIds[j].GetVal2();
382        TInt Sz = SrcCol2.Len()-Offset;
383        if (j < DstNodeIds.Len()-1) { Sz = DstNodeIds[j+1].GetVal2()-Offset; }
384        InVV[m].CopyUniqueFrom(SrcCol2, Offset, Sz);
385      }
386      Graph->AddNodeWithEdges(n, InVV[m], OutVV[m]);
387    }
388    Graph->SetNodes(NumNodes);
389    return Graph;
390  }
391  template<class PGraphMP>
392  PGraphMP ToGraphMP3(PTable Table, const TStr& SrcCol, const TStr& DstCol) {
393    PNGraphMP Graph;
394    int MaxThreads = omp_get_max_threads();
395    int Length, Threads, Delta, Nodes, Last;
396    uint64_t NumNodesEst;
397    TInt SrcColIdx, DstColIdx;
398    TIntV InVec, OutVec;
399    SrcColIdx = Table->GetColIdx(SrcCol);
400    DstColIdx = Table->GetColIdx(DstCol);
401    const TAttrType NodeType = Table->GetColType(SrcCol);
402    Assert(NodeType == Table->GetColType(DstCol));
403    int NumRows = Table->Next.Len();
404    double Load = 10;
405    int sz = NumRows / Load;
406    int *buckets = (int *)malloc(sz * sizeof(int));
407    #pragma omp parallel for
408      for (int i = 0; i < sz; i++)
409        buckets[i] = 0;
410    if (NodeType == atInt) {
411      #pragma omp parallel for
412        for (int i = 0; i < NumRows; i++) {
413          int vert = Table->IntCols[DstColIdx][i];
414          buckets[vert % sz] = 1;
415        }
416    }
417    else if (NodeType == atStr ) {
418      #pragma omp parallel for
419        for (int i = 0; i < NumRows; i++) {
420          int vert = (Table->StrColMaps)[DstColIdx][i];
421          buckets[vert % sz] = 1;
422        }
423    }
424    int cnt = 0;
425    #pragma omp parallel for reduction(+:cnt)
426      for (int i = 0; i < sz; i++) {
427        if (buckets[i] == 0)
428          cnt += 1;
429    }
430    NumNodesEst = sz * log ((double)sz / cnt);
431    free (buckets);
432    while (1)
433    {
434      Graph = TNGraphMP::New(NumNodesEst, 100);
435      Length = Graph->Reserved();
436      Threads = MaxThreads/2;
437      Delta = (Length + Threads - 1) / Threads;
438      OutVec.Gen(Length);
439      InVec.Gen(Length);
440      Last = NumRows;
441      Nodes = 0;
442      omp_set_num_threads(Threads);
443      #pragma omp parallel for schedule(static, Delta)
444        for (int CurrRowIdx = 0; CurrRowIdx < Last; CurrRowIdx++) {
445          if ((uint64_t) Nodes + 1000 >= NumNodesEst) {
446            continue;
447          }
448          TInt SVal, DVal;
449          if (NodeType == atInt) {
450            SVal = Table->IntCols[SrcColIdx][CurrRowIdx];
451            DVal = Table->IntCols[DstColIdx][CurrRowIdx];
452          }
453          else if (NodeType == atStr ) {
454            SVal = (Table->StrColMaps)[SrcColIdx][CurrRowIdx];
455            DVal = (Table->StrColMaps)[DstColIdx][CurrRowIdx];
456          }
457          int SrcIdx = abs((SVal.GetPrimHashCd()) % Length);
458          if (!Graph->AddOutEdge1(SrcIdx, SVal, DVal)) {
459            #pragma omp critical
460            {
461                    Nodes++;
462            }
463          }
464          __sync_fetch_and_add(&OutVec[SrcIdx].Val, 1);
465          int DstIdx = abs((DVal.GetPrimHashCd()) % Length);
466          if (!Graph->AddInEdge1(DstIdx, SVal, DVal)) {
467            #pragma omp critical
468            {
469              Nodes++;
470            }
471          }
472          __sync_fetch_and_add(&InVec[DstIdx].Val, 1);
473        }
474      if ((uint64_t) Nodes + 1000 >= NumNodesEst) {
475        Graph.Clr();
476        InVec.Clr();
477        OutVec.Clr();
478        NumNodesEst *= 2;
479      }
480      else {
481        break;
482      }
483    }
484    Graph->SetNodes(Nodes);
485    uint Edges = 0;
486    for (int i = 0; i < Length; i++) {
487      Edges += OutVec[i] + InVec[i];
488    }
489    for (int Idx = 0; Idx < Length; Idx++) {
490      if (OutVec[Idx] > 0 || InVec[Idx] > 0) {
491        Graph->ReserveNodeDegs(Idx, InVec[Idx], OutVec[Idx]);
492      }
493    }
494    Length = Graph->Reserved();
495    Threads = MaxThreads;
496    Delta = (Length + Threads - 1) / Threads;
497    omp_set_num_threads(Threads);
498    #pragma omp parallel for schedule(static,Delta)
499    for (int CurrRowIdx = 0; CurrRowIdx < Last; CurrRowIdx++) {
500  	TInt SVal, DVal;
501  	if (NodeType == atInt) {
502        SVal = Table->IntCols[SrcColIdx][CurrRowIdx];
503        DVal = Table->IntCols[DstColIdx][CurrRowIdx];
504  	}
505  	else if (NodeType == atStr) {
506        SVal = (Table->StrColMaps)[SrcColIdx][CurrRowIdx];
507        DVal = (Table->StrColMaps)[DstColIdx][CurrRowIdx];
508  	}
509      Graph->AddOutEdge2(SVal, DVal);
510      Graph->AddInEdge2(SVal, DVal);
511    }
512    Length = Graph->Reserved();
513    Threads = MaxThreads*2;
514    Delta = (Length + Threads - 1) / Threads;
515    omp_set_num_threads(Threads);
516    #pragma omp parallel for schedule(dynamic)
517    for (int Idx = 0; Idx < Length; Idx++) {
518      if (OutVec[Idx] > 0 || InVec[Idx] > 0) {
519        Graph->SortEdges(Idx, InVec[Idx], OutVec[Idx]);
520      }
521    }
522    return Graph;
523  }
524  template<class PGraphMP>
525  inline PGraphMP ToNetworkMP(PTable Table,
526    const TStr& SrcCol, const TStr& DstCol,
527    TStrV& SrcAttrV, TStrV& DstAttrV, TStrV& EdgeAttrV,
528    TAttrAggr AggrPolicy) {
529    TStopwatch* Sw = TStopwatch::GetInstance();
530    Sw->Start(TStopwatch::AllocateColumnCopies);
531    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
532    const TInt DstColIdx = Table->GetColIdx(DstCol);
533    const TInt NumRows = Table->GetNumValidRows();
534    const TAttrType NodeType = Table->GetColType(SrcCol);
535    Assert(NodeType == Table->GetColType(DstCol));
536    TIntV SrcCol1, EdgeCol1, EdgeCol2, DstCol2;
537    THash<TInt, TStrIntVH> NodeIntAttrs;
538    THash<TInt, TStrFltVH> NodeFltAttrs;
539    THash<TInt, TStrStrVH> NodeStrAttrs;
540    #pragma omp parallel sections num_threads(4)
541    {
542      #pragma omp section
543      { SrcCol1.Reserve(NumRows, NumRows); }
544      #pragma omp section
545      { EdgeCol1.Reserve(NumRows, NumRows); }
546      #pragma omp section
547      { DstCol2.Reserve(NumRows, NumRows); }
548      #pragma omp section
549      { EdgeCol2.Reserve(NumRows, NumRows); }
550    }
551    Sw->Stop(TStopwatch::AllocateColumnCopies);
552    Sw->Start(TStopwatch::CopyColumns);
553    TIntPrV Partitions;
554    Table->GetPartitionRanges(Partitions, omp_get_max_threads());
555    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
556    omp_set_num_threads(omp_get_max_threads());
557    if (NodeType == atInt) {
558      #pragma omp parallel for schedule(static)
559      for (int i = 0; i < Partitions.Len(); i++) {
560        TRowIterator RowI(Partitions[i].GetVal1(), Table());
561        TRowIterator EndI(Partitions[i].GetVal2(), Table());
562        while (RowI < EndI) {
563          TInt RowId = RowI.GetRowIdx();
564          SrcCol1[RowId] = RowI.GetIntAttr(SrcColIdx);
565          EdgeCol1[RowId] = RowId;
566          DstCol2[RowId] = RowI.GetIntAttr(DstColIdx);
567          EdgeCol2[RowId] = RowId;
568          RowI++;
569        }
570      }
571    }
572    else if (NodeType == atStr) {
573      #pragma omp parallel for schedule(static)
574      for (int i = 0; i < Partitions.Len(); i++) {
575        TRowIterator RowI(Partitions[i].GetVal1(), Table());
576        TRowIterator EndI(Partitions[i].GetVal2(), Table());
577        while (RowI < EndI) {
578          TInt RowId = RowI.GetRowIdx();
579          SrcCol1[RowId] = RowI.GetStrMapById(SrcColIdx);
580          EdgeCol1[RowId] = RowId;
581          DstCol2[RowId] = RowI.GetStrMapById(DstColIdx);
582          EdgeCol2[RowId] = RowId;
583          RowI++;
584        }
585      }
586    }
587    Sw->Stop(TStopwatch::CopyColumns);
588    Sw->Start(TStopwatch::Sort);
589    omp_set_num_threads(omp_get_max_threads());
590    #pragma omp parallel
591    {
592      #pragma omp single nowait
593      {
594        #ifndef GLib_WIN32
595        #pragma omp task untied shared(SrcCol1, EdgeCol1)
596        #endif
597        { TTable::QSortKeyVal(SrcCol1, EdgeCol1, 0, NumRows-1); }
598      }
599      #pragma omp single nowait
600      {
601        #ifndef GLib_WIN32
602        #pragma omp task untied shared(EdgeCol2, DstCol2)
603        #endif
604       { TTable::QSortKeyVal(DstCol2, EdgeCol2, 0, NumRows-1); }
605      }
606      #ifndef GLib_WIN32
607      #pragma omp taskwait
608      #endif
609    }
610    Sw->Stop(TStopwatch::Sort);
611    Sw->Start(TStopwatch::Group);
612    TInt NumThreads = omp_get_max_threads();
613    TInt PartSize = (NumRows/NumThreads);
614    TIntV SrcOffsets, DstOffsets;
615    SrcOffsets.Add(0);
616    for (TInt i = 1; i < NumThreads; i++) {
617      TInt CurrOffset = i * PartSize;
618      while (CurrOffset < (i+1) * PartSize &&
619            SrcCol1[CurrOffset-1] == SrcCol1[CurrOffset]) {
620        CurrOffset++;
621      }
622      if (CurrOffset < (i+1) * PartSize) { SrcOffsets.Add(CurrOffset); }
623    }
624    SrcOffsets.Add(NumRows);
625    DstOffsets.Add(0);
626    for (TInt i = 1; i < NumThreads; i++) {
627      TInt CurrOffset = i * PartSize;
628      while (CurrOffset < (i+1) * PartSize &&
629            DstCol2[CurrOffset-1] == DstCol2[CurrOffset]) {
630        CurrOffset++;
631      }
632      if (CurrOffset < (i+1) * PartSize) { DstOffsets.Add(CurrOffset); }
633    }
634    DstOffsets.Add(NumRows);
635    TInt SrcPartCnt = SrcOffsets.Len()-1; 
636    TInt DstPartCnt = DstOffsets.Len()-1; 
637    TIntV SrcNodeCounts, DstNodeCounts;
638    SrcNodeCounts.Reserve(SrcPartCnt, SrcPartCnt);
639    DstNodeCounts.Reserve(DstPartCnt, DstPartCnt);
640    #pragma omp parallel for schedule(dynamic)
641    for (int t = 0; t < SrcPartCnt+DstPartCnt; t++) {
642      if (t < SrcPartCnt) {
643        TInt i = t;
644        if (SrcOffsets[i] != SrcOffsets[i+1]) {
645          SrcNodeCounts[i] = 1;
646          TInt CurrNode = SrcCol1[SrcOffsets[i]];
647          for (TInt j = SrcOffsets[i]+1; j < SrcOffsets[i+1]; j++) {
648            while (j < SrcOffsets[i+1] && SrcCol1[j] == CurrNode) { j++; }
649            if (j < SrcOffsets[i+1]) {
650              SrcNodeCounts[i]++;
651              CurrNode = SrcCol1[j];
652            }
653          }
654        }
655      } else {
656        TInt i = t - SrcPartCnt;
657        if (DstOffsets[i] != DstOffsets[i+1]) {
658          DstNodeCounts[i] = 1;
659          TInt CurrNode = DstCol2[DstOffsets[i]];
660          for (TInt j = DstOffsets[i]+1; j < DstOffsets[i+1]; j++) {
661            while (j < DstOffsets[i+1] && DstCol2[j] == CurrNode) { j++; }
662            if (j < DstOffsets[i+1]) {
663              DstNodeCounts[i]++;
664              CurrNode = DstCol2[j];
665            }
666          }
667        }
668      }
669    }
670    TInt TotalSrcNodes = 0;
671    TIntV SrcIdOffsets;
672    for (int i = 0; i < SrcPartCnt; i++) {
673      SrcIdOffsets.Add(TotalSrcNodes);
674      TotalSrcNodes += SrcNodeCounts[i];
675    }
676    TInt TotalDstNodes = 0;
677    TIntV DstIdOffsets;
678    for (int i = 0; i < DstPartCnt; i++) {
679      DstIdOffsets.Add(TotalDstNodes);
680      TotalDstNodes += DstNodeCounts[i];
681    }
682    TIntPrV SrcNodeIds, DstNodeIds;
683    #pragma omp parallel sections
684    {
685      #pragma omp section
686      { SrcNodeIds.Reserve(TotalSrcNodes, TotalSrcNodes); }
687      #pragma omp section
688      { DstNodeIds.Reserve(TotalDstNodes, TotalDstNodes); }
689    }
690    #pragma omp parallel for schedule(dynamic)
691    for (int t = 0; t < SrcPartCnt+DstPartCnt; t++) {
692      if (t < SrcPartCnt) {
693        TInt i = t;
694        if (SrcOffsets[i] != SrcOffsets[i+1]) {
695          TInt CurrNode = SrcCol1[SrcOffsets[i]];
696          TInt ThreadOffset = SrcIdOffsets[i];
697          SrcNodeIds[ThreadOffset] = TIntPr(CurrNode, SrcOffsets[i]);
698          TInt CurrCount = 1;
699          for (TInt j = SrcOffsets[i]+1; j < SrcOffsets[i+1]; j++) {
700            while (j < SrcOffsets[i+1] && SrcCol1[j] == CurrNode) { j++; }
701            if (j < SrcOffsets[i+1]) {
702              CurrNode = SrcCol1[j];
703              SrcNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
704              CurrCount++;
705            }
706          }
707        }
708      } else {
709        TInt i = t - SrcPartCnt;
710        if (DstOffsets[i] != DstOffsets[i+1]) {
711          TInt CurrNode = DstCol2[DstOffsets[i]];
712          TInt ThreadOffset = DstIdOffsets[i];
713          DstNodeIds[ThreadOffset] = TIntPr(CurrNode, DstOffsets[i]);
714          TInt CurrCount = 1;
715          for (TInt j = DstOffsets[i]+1; j < DstOffsets[i+1]; j++) {
716            while (j < DstOffsets[i+1] && DstCol2[j] == CurrNode) { j++; }
717            if (j < DstOffsets[i+1]) {
718              CurrNode = DstCol2[j];
719              DstNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
720              CurrCount++;
721            }
722          }
723        }
724      }
725    }
726    Sw->Stop(TStopwatch::Group);
727    Sw->Start(TStopwatch::MergeNeighborhoods);
728    TIntTrV Nodes;
729    Nodes.Reserve(TotalSrcNodes+TotalDstNodes);
730    TInt i = 0, j = 0;
731    while (i < TotalSrcNodes && j < TotalDstNodes) {
732      if (SrcNodeIds[i].Val1 == DstNodeIds[j].Val1) {
733        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, j));
734        i++;
735        j++;
736      } else if (SrcNodeIds[i].Val1 < DstNodeIds[j].Val1) {
737        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1));
738        i++;
739      } else {
740        Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j));
741        j++;
742      }
743    }
744    for (; i < TotalSrcNodes; i++) { Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1)); }
745    for (; j < TotalDstNodes; j++) { Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j)); }
746    Sw->Stop(TStopwatch::MergeNeighborhoods);
747    Sw->Start(TStopwatch::AddNeighborhoods);
748    TInt NumNodes = Nodes.Len();
749    PGraphMP Graph = PGraphMP::TObj::New(NumNodes, NumRows);
750    TVec<TIntV> InVV(NumNodes);
751    TVec<TIntV> OutVV(NumNodes);
752    #pragma omp parallel for schedule(static,100)
753    for (int m = 0; m < NumNodes; m++) {
754      TInt n, i, j;
755      Nodes[m].GetVal(n, i, j);
756      if (i >= 0) {
757        TInt Offset = SrcNodeIds[i].GetVal2();
758        TInt Sz = EdgeCol1.Len()-Offset;
759        if (i < SrcNodeIds.Len()-1) { Sz = SrcNodeIds[i+1].GetVal2()-Offset; }
760        OutVV[m].Reserve(Sz);
761        OutVV[m].CopyUniqueFrom(EdgeCol1, Offset, Sz);
762      }
763      if (j >= 0) {
764        TInt Offset = DstNodeIds[j].GetVal2();
765        TInt Sz = EdgeCol2.Len()-Offset;
766        if (j < DstNodeIds.Len()-1) { Sz = DstNodeIds[j+1].GetVal2()-Offset; }
767        InVV[m].Reserve(Sz);
768        InVV[m].CopyUniqueFrom(EdgeCol2, Offset, Sz);
769      }
770      Graph->AddNodeWithEdges(n, InVV[m], OutVV[m]);
771    }
772    Graph->SetNodes(NumNodes);
773    Sw->Stop(TStopwatch::AddNeighborhoods);
774    Sw->Start(TStopwatch::AddEdges);
775    omp_set_num_threads(omp_get_max_threads());
776    if (NodeType == atInt) {
777      #pragma omp parallel for schedule(static)
778      for (int i = 0; i < Partitions.Len(); i++) {
779        TRowIterator RowI(Partitions[i].GetVal1(), Table());
780        TRowIterator EndI(Partitions[i].GetVal2(), Table());
781        while (RowI < EndI) {
782          TInt RowId = RowI.GetRowIdx(); 
783          TInt SrcId = RowI.GetIntAttr(SrcColIdx);
784          TInt DstId = RowI.GetIntAttr(DstColIdx);
785          Graph->AddEdgeUnchecked(RowId, SrcId, DstId);
786          RowI++;
787  		for (TInt ea_i = 0; ea_i < EdgeAttrV.Len(); ea_i++) {
788            TStr ColName = EdgeAttrV[ea_i];
789            TAttrType T = Table->GetColType(ColName);
790            TInt Index = Table->GetColIdx(ColName);
791            switch (T) {
792              case atInt:
793                Graph->AddIntAttrDatE(RowId, Table->IntCols[Index][RowId], ColName);
794                break;
795              case atFlt:
796                Graph->AddFltAttrDatE(RowId, Table->FltCols[Index][RowId], ColName);
797                break;
798              case atStr:
799                Graph->AddStrAttrDatE(RowId, Table->GetStrValIdx(Index, RowId), ColName);
800                break;
801            }
802          }
803          if ((Table->SrcNodeAttrV).Len() > 0) {
804            Table->AddNodeAttributes(SrcId, Table->SrcNodeAttrV, RowId, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
805         	}
806          if ((Table->DstNodeAttrV).Len() > 0) {
807           Table->AddNodeAttributes(SrcId, Table->DstNodeAttrV, RowId, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
808          }
809        }
810      }
811    }
812    else if (NodeType == atStr) {
813      #pragma omp parallel for schedule(static)
814      for (int i = 0; i < Partitions.Len(); i++) {
815        TRowIterator RowI(Partitions[i].GetVal1(), Table());
816        TRowIterator EndI(Partitions[i].GetVal2(), Table());
817        while (RowI < EndI) {
818          TInt RowId = RowI.GetRowIdx(); 
819          TInt SrcId = RowI.GetStrMapById(SrcColIdx);
820          TInt DstId = RowI.GetStrMapById(DstColIdx);
821          Graph->AddEdgeUnchecked(RowId, SrcId, DstId);
822          RowI++;
823  		for (TInt ea_i = 0; ea_i < EdgeAttrV.Len(); ea_i++) {
824            TStr ColName = EdgeAttrV[ea_i];
825            TAttrType T = Table->GetColType(ColName);
826            TInt Index = Table->GetColIdx(ColName);
827            switch (T) {
828              case atInt:
829                Graph->AddIntAttrDatE(RowId, Table->IntCols[Index][RowId], ColName);
830                break;
831              case atFlt:
832                Graph->AddFltAttrDatE(RowId, Table->FltCols[Index][RowId], ColName);
833                break;
834              case atStr:
835                Graph->AddStrAttrDatE(RowId, Table->GetStrValIdx(Index, RowId), ColName);
836                break;
837            }
838          }
839          if ((Table->SrcNodeAttrV).Len() > 0) {
840            Table->AddNodeAttributes(SrcId, Table->SrcNodeAttrV, RowId, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
841         	}
842          if ((Table->DstNodeAttrV).Len() > 0) {
843           Table->AddNodeAttributes(SrcId, Table->DstNodeAttrV, RowId, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
844          }
845        }
846      }
847    }
848    if ((Table->SrcNodeAttrV).Len() > 0 || (Table->DstNodeAttrV).Len() > 0) {
849      for (typename PGraphMP::TObj::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
850        TInt NId = NodeI.GetId();
851        if (NodeIntAttrs.IsKey(NId)) {
852          TStrIntVH IntAttrVals = NodeIntAttrs.GetDat(NId);
853          for (TStrIntVH::TIter it = IntAttrVals.BegI(); it < IntAttrVals.EndI(); it++) {
854            TInt AttrVal = Table->AggregateVector<TInt>(it.GetDat(), AggrPolicy);
855            Graph->AddIntAttrDatN(NId, AttrVal, it.GetKey());
856          }
857        }
858        if (NodeFltAttrs.IsKey(NId)) {
859          TStrFltVH FltAttrVals = NodeFltAttrs.GetDat(NId);
860          for (TStrFltVH::TIter it = FltAttrVals.BegI(); it < FltAttrVals.EndI(); it++) {
861            TFlt AttrVal = Table->AggregateVector<TFlt>(it.GetDat(), AggrPolicy);
862            Graph->AddFltAttrDatN(NId, AttrVal, it.GetKey());
863          }
864        }
865        if (NodeStrAttrs.IsKey(NId)) {
866          TStrStrVH StrAttrVals = NodeStrAttrs.GetDat(NId);
867          for (TStrStrVH::TIter it = StrAttrVals.BegI(); it < StrAttrVals.EndI(); it++) {
868            TStr AttrVal = Table->AggregateVector<TStr>(it.GetDat(), AggrPolicy);
869            Graph->AddStrAttrDatN(NId, AttrVal, it.GetKey());
870          }
871        }
872      }
873    }
874    Graph->SetEdges(NumRows);
875    Sw->Stop(TStopwatch::AddEdges);
876    return Graph;
877  }
878  template<class PGraphMP>
879  PGraphMP ToNetworkMP(PTable Table,
880    const TStr& SrcCol, const TStr& DstCol, TAttrAggr AggrPolicy)
881  {
882    TStrV V;
883    return ToNetworkMP<PGraphMP>(Table, SrcCol, DstCol, V,AggrPolicy);
884  }
885  template<class PGraphMP>
886  inline PGraphMP ToNetworkMP2(PTable Table,
887    const TStr& SrcCol, const TStr& DstCol,
888    TStrV& SrcAttrV, TStrV& DstAttrV, TStrV& EdgeAttrV,
889    TAttrAggr AggrPolicy) {
890    TStopwatch* Sw = TStopwatch::GetInstance();
891    Sw->Start(TStopwatch::AllocateColumnCopies);
892    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
893    const TInt DstColIdx = Table->GetColIdx(DstCol);
894    const TInt NumRows = Table->NumValidRows;
895    const TAttrType NodeType = Table->GetColType(SrcCol);
896    Assert(NodeType == Table->GetColType(DstCol));
897    TIntV SrcCol1, EdgeCol1, EdgeCol2, DstCol2;
898    #pragma omp parallel sections num_threads(4)
899    {
900      #pragma omp section
901      { SrcCol1.Reserve(NumRows, NumRows); }
902      #pragma omp section
903      { EdgeCol1.Reserve(NumRows, NumRows); }
904      #pragma omp section
905      { DstCol2.Reserve(NumRows, NumRows); }
906      #pragma omp section
907      { EdgeCol2.Reserve(NumRows, NumRows); }
908    }
909    Sw->Stop(TStopwatch::AllocateColumnCopies);
910    Sw->Start(TStopwatch::CopyColumns);
911    TIntPrV Partitions;
912    const int NThreads = 40;
913    Table->GetPartitionRanges(Partitions, NThreads);
914    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
915    if (NodeType == atInt) {
916      #pragma omp parallel for schedule(static)
917      for (int i = 0; i < Partitions.Len(); i++) {
918        TRowIterator RowI(Partitions[i].GetVal1(), Table());
919        TRowIterator EndI(Partitions[i].GetVal2(), Table());
920        while (RowI < EndI) {
921          TInt RowId = RowI.GetRowIdx();
922          SrcCol1[RowId] = RowI.GetIntAttr(SrcColIdx);
923          EdgeCol1[RowId] = RowId;
924          DstCol2[RowId] = RowI.GetIntAttr(DstColIdx);
925          EdgeCol2[RowId] = RowId;
926          RowI++;
927        }
928      }
929    }
930    else if (NodeType == atStr) {
931      #pragma omp parallel for schedule(static)
932      for (int i = 0; i < Partitions.Len(); i++) {
933        TRowIterator RowI(Partitions[i].GetVal1(), Table());
934        TRowIterator EndI(Partitions[i].GetVal2(), Table());
935        while (RowI < EndI) {
936          TInt RowId = RowI.GetRowIdx();
937          SrcCol1[RowId] = RowI.GetStrMapById(SrcColIdx);
938          EdgeCol1[RowId] = RowId;
939          DstCol2[RowId] = RowI.GetStrMapById(DstColIdx);
940          EdgeCol2[RowId] = RowId;
941          RowI++;
942        }
943      }
944    }
945    int Parts[NThreads+1];
946    for (int i = 0; i < NThreads; i++) {
947      Parts[i] = NumRows.Val / NThreads * i;
948    }
949    Parts[NThreads] = NumRows;
950    Sw->Stop(TStopwatch::CopyColumns);
951    Sw->Start(TStopwatch::Sort);
952    TInt ExtremePoints[4][NThreads];
953    omp_set_num_threads(omp_get_max_threads());
954    #pragma omp parallel
955    {
956      #pragma omp for schedule(static) nowait
957      for (int i = 0; i < NThreads; i++) {
958        TInt StartPos = Parts[i];
959        TInt EndPos = Parts[i+1]-1;
960        TTable::QSortKeyVal(SrcCol1, EdgeCol1, StartPos, EndPos);
961        ExtremePoints[0][i] = SrcCol1[StartPos];
962        ExtremePoints[2][i] = SrcCol1[EndPos];
963      }
964      #pragma omp for schedule(static) nowait
965      for (int i = 0; i < NThreads; i++) {
966        TInt StartPos = Parts[i];
967        TInt EndPos = Parts[i+1]-1;
968        TTable::QSortKeyVal(DstCol2, EdgeCol2, StartPos, EndPos);
969        ExtremePoints[1][i] = DstCol2[StartPos];
970        ExtremePoints[3][i] = DstCol2[EndPos];
971      }
972    }
973    TInt MinId(INT_MAX);
974    for (int j = 0; j < 2; j++) {
975      for (int i = 0; i < NThreads; i++) {
976        if (MinId > ExtremePoints[j][i]) { MinId = ExtremePoints[j][i]; }
977      }
978    }
979    TInt MaxId(-1);
980    for (int j = 2; j < 4; j++) {
981      for (int i = 0; i < NThreads; i++) {
982        if (MaxId < ExtremePoints[j][i]) { MaxId = ExtremePoints[j][i]; }
983      }
984    }
985    Sw->Stop(TStopwatch::Sort);
986    Sw->Start(TStopwatch::Group);
987    const int NumCollectors = 20;
988    int Range = MaxId.Val - MinId.Val;
989    TIntV IdRanges(NumCollectors+1);
990    for (int j = 0; j < NumCollectors; j++) {
991      IdRanges[j] = MinId + Range/NumCollectors*j;
992    }
993    IdRanges[NumCollectors] = MaxId+1;
994    int SrcOffsets[NThreads][NumCollectors+1];
995    #pragma omp parallel for schedule(static)
996    for (int i = 0; i < NThreads; i++) {
997      int CollectorId = 0;
998      for (int j = Parts[i]; j < Parts[i+1]; j++) {
999        while (SrcCol1[j] >= IdRanges[CollectorId]) {
1000          SrcOffsets[i][CollectorId++] = j;
1001        }
1002      }
1003      while (CollectorId <= NumCollectors) {
1004        SrcOffsets[i][CollectorId++] = Parts[i+1];
1005      }
1006    }
1007    int DstOffsets[NThreads][NumCollectors+1];
1008    #pragma omp parallel for schedule(static)
1009    for (int i = 0; i < NThreads; i++) {
1010      int CollectorId = 0;
1011      for (int j = Parts[i]; j < Parts[i+1]; j++) {
1012        while (DstCol2[j] >= IdRanges[CollectorId]) {
1013          DstOffsets[i][CollectorId++] = j;
1014        }
1015      }
1016      while (CollectorId <= NumCollectors) {
1017        DstOffsets[i][CollectorId++] = Parts[i+1];
1018      }
1019    }
1020    TIntV SrcCollectorOffsets(NumCollectors+1);
1021    SrcCollectorOffsets[0] = 0;
1022    for (int k = 0; k < NumCollectors; k++) {
1023      int SumOffset = 0;
1024      for (int i = 0; i < NThreads; i++) {
1025        SumOffset += SrcOffsets[i][k+1] - SrcOffsets[i][k];
1026      }
1027      SrcCollectorOffsets[k+1] = SrcCollectorOffsets[k] + SumOffset;
1028    }
1029    TIntV DstCollectorOffsets(NumCollectors+1);
1030    DstCollectorOffsets[0] = 0;
1031    for (int k = 0; k < NumCollectors; k++) {
1032      int SumOffset = 0;
1033      for (int i = 0; i < NThreads; i++) {
1034        SumOffset += DstOffsets[i][k+1] - DstOffsets[i][k];
1035      }
1036      DstCollectorOffsets[k+1] = DstCollectorOffsets[k] + SumOffset;
1037    }
1038    TIntV SrcCol3, EdgeCol3, EdgeCol4, DstCol4;
1039    #pragma omp parallel sections num_threads(4)
1040    {
1041      #pragma omp section
1042      { SrcCol3.Reserve(NumRows, NumRows); }
1043      #pragma omp section
1044      { EdgeCol3.Reserve(NumRows, NumRows); }
1045      #pragma omp section
1046      { DstCol4.Reserve(NumRows, NumRows); }
1047      #pragma omp section
1048      { EdgeCol4.Reserve(NumRows, NumRows); }
1049    }
1050    TIntV SrcNodeCounts(NumCollectors), DstNodeCounts(NumCollectors);
1051    #pragma omp parallel for schedule(static)
1052    for (int k = 0; k < NumCollectors; k++) {
1053      int ind = SrcCollectorOffsets[k];
1054      for (int i = 0; i < NThreads; i++) {
1055        for (int j = SrcOffsets[i][k]; j < SrcOffsets[i][k+1]; j++) {
1056          SrcCol3[ind] = SrcCol1[j];
1057          EdgeCol3[ind] = EdgeCol1[j];
1058          ind++;
1059        }
1060      }
1061      TTable::QSortKeyVal(SrcCol3, EdgeCol3, SrcCollectorOffsets[k], SrcCollectorOffsets[k+1]-1);
1062      int SrcCount = 0;
1063      if (SrcCollectorOffsets[k+1] > SrcCollectorOffsets[k]) {
1064        SrcCount = 1;
1065        for (int j = SrcCollectorOffsets[k]+1; j < SrcCollectorOffsets[k+1]; j++) {
1066          if (SrcCol3[j] != SrcCol3[j-1]) { SrcCount++; }
1067        }
1068      }
1069      SrcNodeCounts[k] = SrcCount;
1070      ind = DstCollectorOffsets[k];
1071      for (int i = 0; i < NThreads; i++) {
1072        for (int j = DstOffsets[i][k]; j < DstOffsets[i][k+1]; j++) {
1073          DstCol4[ind] = DstCol2[j];
1074          EdgeCol4[ind] = EdgeCol2[j];
1075          ind++;
1076        }
1077      }
1078      TTable::QSortKeyVal(DstCol4, EdgeCol4, DstCollectorOffsets[k], DstCollectorOffsets[k+1]-1);
1079      int DstCount = 0;
1080      if (DstCollectorOffsets[k+1] > DstCollectorOffsets[k]) {
1081        DstCount = 1;
1082        for (int j = DstCollectorOffsets[k]+1; j < DstCollectorOffsets[k+1]; j++) {
1083          if (DstCol4[j] != DstCol4[j-1]) { DstCount++; }
1084        }
1085      }
1086      DstNodeCounts[k] = DstCount;
1087    }
1088    TInt TotalSrcNodes = 0;
1089    TIntV SrcIdOffsets;
1090    for (int i = 0; i < NumCollectors; i++) {
1091      SrcIdOffsets.Add(TotalSrcNodes);
1092      TotalSrcNodes += SrcNodeCounts[i];
1093    }
1094    TInt TotalDstNodes = 0;
1095    TIntV DstIdOffsets;
1096    for (int i = 0; i < NumCollectors; i++) {
1097      DstIdOffsets.Add(TotalDstNodes);
1098      TotalDstNodes += DstNodeCounts[i];
1099    }
1100    TIntPrV SrcNodeIds, DstNodeIds;
1101    #pragma omp parallel sections
1102    {
1103      #pragma omp section
1104      { SrcNodeIds.Reserve(TotalSrcNodes, TotalSrcNodes); }
1105      #pragma omp section
1106      { DstNodeIds.Reserve(TotalDstNodes, TotalDstNodes); }
1107    }
1108    #pragma omp parallel for schedule(dynamic)
1109    for (int t = 0; t < 2*NumCollectors; t++) {
1110      if (t < NumCollectors) {
1111        TInt i = t;
1112        if (SrcCollectorOffsets[i] < SrcCollectorOffsets[i+1]) {
1113          TInt CurrNode = SrcCol3[SrcCollectorOffsets[i]];
1114          TInt ThreadOffset = SrcIdOffsets[i];
1115          SrcNodeIds[ThreadOffset] = TIntPr(CurrNode, SrcCollectorOffsets[i]);
1116          TInt CurrCount = 1;
1117          for (TInt j = SrcCollectorOffsets[i]+1; j < SrcCollectorOffsets[i+1]; j++) {
1118            while (j < SrcCollectorOffsets[i+1] && SrcCol3[j] == CurrNode) { j++; }
1119            if (j < SrcCollectorOffsets[i+1]) {
1120              CurrNode = SrcCol3[j];
1121              SrcNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
1122              CurrCount++;
1123            }
1124          }
1125        }
1126      } else {
1127        TInt i = t - NumCollectors;
1128        if (DstCollectorOffsets[i] < DstCollectorOffsets[i+1]) {
1129          TInt CurrNode = DstCol4[DstCollectorOffsets[i]];
1130          TInt ThreadOffset = DstIdOffsets[i];
1131          DstNodeIds[ThreadOffset] = TIntPr(CurrNode, DstCollectorOffsets[i]);
1132          TInt CurrCount = 1;
1133          for (TInt j = DstCollectorOffsets[i]+1; j < DstCollectorOffsets[i+1]; j++) {
1134            while (j < DstCollectorOffsets[i+1] && DstCol4[j] == CurrNode) { j++; }
1135            if (j < DstCollectorOffsets[i+1]) {
1136              CurrNode = DstCol4[j];
1137              DstNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
1138              CurrCount++;
1139            }
1140          }
1141        }
1142      }
1143    }
1144    Sw->Stop(TStopwatch::Group);
1145    Sw->Start(TStopwatch::MergeNeighborhoods);
1146    TIntTrV Nodes;
1147    Nodes.Reserve(TotalSrcNodes+TotalDstNodes);
1148    TInt i = 0, j = 0;
1149    while (i < TotalSrcNodes && j < TotalDstNodes) {
1150      if (SrcNodeIds[i].Val1 == DstNodeIds[j].Val1) {
1151        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, j));
1152        i++;
1153        j++;
1154      } else if (SrcNodeIds[i].Val1 < DstNodeIds[j].Val1) {
1155        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1));
1156        i++;
1157      } else {
1158        Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j));
1159        j++;
1160      }
1161    }
1162    for (; i < TotalSrcNodes; i++) { Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1)); }
1163    for (; j < TotalDstNodes; j++) { Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j)); }
1164    Sw->Stop(TStopwatch::MergeNeighborhoods);
1165    Sw->Start(TStopwatch::AddNeighborhoods);
1166    TInt NumNodes = Nodes.Len();
1167    PGraphMP Graph = PGraphMP::TObj::New(NumNodes, NumRows);
1168    TVec<TIntV> InVV(NumNodes);
1169    TVec<TIntV> OutVV(NumNodes);
1170    #pragma omp parallel for schedule(static,100)
1171    for (int m = 0; m < NumNodes; m++) {
1172      TInt n, i, j;
1173      Nodes[m].GetVal(n, i, j);
1174      if (i >= 0) {
1175        TInt Offset = SrcNodeIds[i].GetVal2();
1176        TInt Sz = EdgeCol3.Len()-Offset;
1177        if (i < SrcNodeIds.Len()-1) { Sz = SrcNodeIds[i+1].GetVal2()-Offset; }
1178        OutVV[m].Reserve(Sz);
1179        OutVV[m].CopyUniqueFrom(EdgeCol3, Offset, Sz);
1180      }
1181      if (j >= 0) {
1182        TInt Offset = DstNodeIds[j].GetVal2();
1183        TInt Sz = EdgeCol4.Len()-Offset;
1184        if (j < DstNodeIds.Len()-1) { Sz = DstNodeIds[j+1].GetVal2()-Offset; }
1185        InVV[m].Reserve(Sz);
1186        InVV[m].CopyUniqueFrom(EdgeCol4, Offset, Sz);
1187      }
1188      Graph->AddNodeWithEdges(n, InVV[m], OutVV[m]);
1189    }
1190    Graph->SetNodes(NumNodes);
1191    Sw->Stop(TStopwatch::AddNeighborhoods);
1192    Sw->Start(TStopwatch::AddEdges);
1193    omp_set_num_threads(omp_get_max_threads());
1194    if (NodeType == atInt) {
1195      #pragma omp parallel for schedule(static)
1196      for (int i = 0; i < Partitions.Len(); i++) {
1197        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1198        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1199        while (RowI < EndI) {
1200          TInt RowId = RowI.GetRowIdx(); 
1201          TInt SrcId = RowI.GetIntAttr(SrcColIdx);
1202          TInt DstId = RowI.GetIntAttr(DstColIdx);
1203          Graph->AddEdgeUnchecked(RowId, SrcId, DstId);
1204          RowI++;
1205        }
1206      }
1207    }
1208    else if (NodeType == atStr) {
1209      #pragma omp parallel for schedule(static)
1210      for (int i = 0; i < Partitions.Len(); i++) {
1211        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1212        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1213        while (RowI < EndI) {
1214          TInt RowId = RowI.GetRowIdx(); 
1215          TInt SrcId = RowI.GetStrMapById(SrcColIdx);
1216          TInt DstId = RowI.GetStrMapById(DstColIdx);
1217          Graph->AddEdgeUnchecked(RowId, SrcId, DstId);
1218          RowI++;
1219        }
1220      }
1221    }
1222    Graph->SetEdges(NumRows);
1223    Sw->Stop(TStopwatch::AddEdges);
1224    return Graph;
1225  }
1226  template<class PGraphMP>
1227  PGraphMP ToNetworkMP2(PTable Table,
1228    const TStr& SrcCol, const TStr& DstCol, TAttrAggr AggrPolicy)
1229  {
1230    TStrV V;
1231    return ToNetworkMP2<PGraphMP>(Table, SrcCol, DstCol, V, V, V, AggrPolicy);
1232  }
1233  #endif 
1234  int LoadModeNetToNet(PMMNet Graph, const TStr& Name, PTable Table, const TStr& NCol,
1235    TStrV& NodeAttrV);
1236  int LoadMode(TModeNet& Graph, PTable Table, const TStr& NCol,
1237    TStrV& NodeAttrV);
1238  int LoadCrossNetToNet(PMMNet Graph, const TStr& Mode1, const TStr& Mode2, const TStr& CrossName,
1239   PTable Table, const TStr& SrcCol, const TStr& DstCol, TStrV& EdgeAttrV);
1240  int LoadCrossNet(TCrossNet& Graph, PTable Table, const TStr& SrcCol, const TStr& DstCol,
1241    TStrV& EdgeAttrV);
1242  template<class PGraph>
1243  PGraph ToNetwork(PTable Table,
1244    const TStr& SrcCol, const TStr& DstCol,
1245    TStrV& EdgeAttrV,
1246    TAttrAggr AggrPolicy) {
1247    PGraph Graph = PGraph::TObj::New();
1248    const TAttrType NodeType = Table->GetColType(SrcCol);
1249    Assert(NodeType == Table->GetColType(DstCol));
1250    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
1251    const TInt DstColIdx = Table->GetColIdx(DstCol);
1252    THash<TFlt, TInt> FltNodeVals;
1253    for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
1254      if ((Table->Next)[CurrRowIdx] == Table->Invalid) {
1255        continue;
1256      }
1257      TInt SVal, DVal;
1258      if (NodeType == atFlt) {
1259        TFlt FSVal = (Table->FltCols)[SrcColIdx][CurrRowIdx];
1260        SVal = Table->CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
1261        TFlt FDVal = (Table->FltCols)[SrcColIdx][CurrRowIdx];
1262        DVal = Table->CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
1263      }
<span onclick='openModal()' class='match'>1264      else if (NodeType == atInt || NodeType == atStr) {
1265        if (NodeType == atInt) {
1266          SVal = (Table->IntCols)[SrcColIdx][CurrRowIdx];
1267          DVal = (Table->IntCols)[DstColIdx][CurrRowIdx];
1268        }
1269        else {
1270          SVal = (Table->StrColMaps)[SrcColIdx][CurrRowIdx];
1271          DVal = (Table->StrColMaps)[DstColIdx][CurrRowIdx];
1272        }
</span>1273        if (!Graph->IsNode(SVal)) {Graph->AddNode(SVal); }
1274        if (!Graph->IsNode(DVal)) {Graph->AddNode(DVal); }
1275      }
1276      Graph->AddEdge(SVal, DVal, CurrRowIdx);
1277      for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
1278        TStr ColName = EdgeAttrV[i];
1279        TAttrType T = Table->GetColType(ColName);
1280        TInt Index = Table->GetColIdx(ColName);
1281        switch (T) {
1282          case atInt:
1283            Graph->AddIntAttrDatE(CurrRowIdx, Table->IntCols[Index][CurrRowIdx], ColName);
1284            break;
1285          case atFlt:
1286            Graph->AddFltAttrDatE(CurrRowIdx, Table->FltCols[Index][CurrRowIdx], ColName);
1287            break;
1288          case atStr:
1289            Graph->AddStrAttrDatE(CurrRowIdx, Table->GetStrValIdx(Index, CurrRowIdx), ColName);
1290            break;
1291        }
1292      }
1293    }
1294    return Graph;
1295  }
1296  #ifdef GCC_ATOMIC
1297  template<class PGraphMP>
1298  inline PGraphMP ToNetworkMP(PTable Table,
1299    const TStr& SrcCol, const TStr& DstCol,
1300    TStrV& EdgeAttrV,
1301    TAttrAggr AggrPolicy) {
1302    TStopwatch* Sw = TStopwatch::GetInstance();
1303    Sw->Start(TStopwatch::AllocateColumnCopies);
1304    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
1305    const TInt DstColIdx = Table->GetColIdx(DstCol);
1306    const TInt NumRows = Table->GetNumValidRows();
1307    const TAttrType NodeType = Table->GetColType(SrcCol);
1308    Assert(NodeType == Table->GetColType(DstCol));
1309    TIntV SrcCol1, EdgeCol1, EdgeCol2, DstCol2;
1310    THash<TInt, TStrIntVH> NodeIntAttrs;
1311    THash<TInt, TStrFltVH> NodeFltAttrs;
1312    THash<TInt, TStrStrVH> NodeStrAttrs;
1313    #pragma omp parallel sections num_threads(4)
1314    {
1315      #pragma omp section
1316      { SrcCol1.Reserve(NumRows, NumRows); }
1317      #pragma omp section
1318      { EdgeCol1.Reserve(NumRows, NumRows); }
1319      #pragma omp section
1320      { DstCol2.Reserve(NumRows, NumRows); }
1321      #pragma omp section
1322      { EdgeCol2.Reserve(NumRows, NumRows); }
1323    }
1324    Sw->Stop(TStopwatch::AllocateColumnCopies);
1325    Sw->Start(TStopwatch::CopyColumns);
1326    TIntPrV Partitions;
1327    Table->GetPartitionRanges(Partitions, omp_get_max_threads());
1328    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1329    omp_set_num_threads(omp_get_max_threads());
1330    if (NodeType == atInt) {
1331      #pragma omp parallel for schedule(static)
1332      for (int i = 0; i < Partitions.Len(); i++) {
1333        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1334        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1335        while (RowI < EndI) {
1336          TInt RowId = RowI.GetRowIdx();
1337          SrcCol1[RowId] = RowI.GetIntAttr(SrcColIdx);
1338          EdgeCol1[RowId] = RowId;
1339          DstCol2[RowId] = RowI.GetIntAttr(DstColIdx);
1340          EdgeCol2[RowId] = RowId;
1341          RowI++;
1342        }
1343      }
1344    }
1345    else if (NodeType == atStr) {
1346      #pragma omp parallel for schedule(static)
1347      for (int i = 0; i < Partitions.Len(); i++) {
1348        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1349        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1350        while (RowI < EndI) {
1351          TInt RowId = RowI.GetRowIdx();
1352          SrcCol1[RowId] = RowI.GetStrMapById(SrcColIdx);
1353          EdgeCol1[RowId] = RowId;
1354          DstCol2[RowId] = RowI.GetStrMapById(DstColIdx);
1355          EdgeCol2[RowId] = RowId;
1356          RowI++;
1357       }
1358      }
1359    }
1360    Sw->Stop(TStopwatch::CopyColumns);
1361    Sw->Start(TStopwatch::Sort);
1362    omp_set_num_threads(omp_get_max_threads());
1363    #pragma omp parallel
1364    {
1365      #pragma omp single nowait
1366      {
1367        #ifndef GLib_WIN32
1368        #pragma omp task untied shared(SrcCol1, EdgeCol1)
1369        #endif
1370        { TTable::QSortKeyVal(SrcCol1, EdgeCol1, 0, NumRows-1); }
1371      }
1372      #pragma omp single nowait
1373      {
1374        #ifndef GLib_WIN32
1375        #pragma omp task untied shared(EdgeCol2, DstCol2)
1376        #endif
1377       { TTable::QSortKeyVal(DstCol2, EdgeCol2, 0, NumRows-1); }
1378      }
1379      #ifndef GLib_WIN32
1380      #pragma omp taskwait
1381      #endif
1382    }
1383    Sw->Stop(TStopwatch::Sort);
1384    Sw->Start(TStopwatch::Group);
1385    TInt NumThreads = omp_get_max_threads();
1386    TInt PartSize = (NumRows/NumThreads);
1387    TIntV SrcOffsets, DstOffsets;
1388    SrcOffsets.Add(0);
1389    for (TInt i = 1; i < NumThreads; i++) {
1390      TInt CurrOffset = i * PartSize;
1391      while (CurrOffset < (i+1) * PartSize &&
1392            SrcCol1[CurrOffset-1] == SrcCol1[CurrOffset]) {
1393        CurrOffset++;
1394      }
1395      if (CurrOffset < (i+1) * PartSize) { SrcOffsets.Add(CurrOffset); }
1396    }
1397    SrcOffsets.Add(NumRows);
1398    DstOffsets.Add(0);
1399    for (TInt i = 1; i < NumThreads; i++) {
1400      TInt CurrOffset = i * PartSize;
1401      while (CurrOffset < (i+1) * PartSize &&
1402            DstCol2[CurrOffset-1] == DstCol2[CurrOffset]) {
1403        CurrOffset++;
1404      }
1405      if (CurrOffset < (i+1) * PartSize) { DstOffsets.Add(CurrOffset); }
1406    }
1407    DstOffsets.Add(NumRows);
1408    TInt SrcPartCnt = SrcOffsets.Len()-1; 
1409    TInt DstPartCnt = DstOffsets.Len()-1; 
1410    TIntV SrcNodeCounts, DstNodeCounts;
1411    SrcNodeCounts.Reserve(SrcPartCnt, SrcPartCnt);
1412    DstNodeCounts.Reserve(DstPartCnt, DstPartCnt);
1413    #pragma omp parallel for schedule(dynamic)
1414    for (int t = 0; t < SrcPartCnt+DstPartCnt; t++) {
1415      if (t < SrcPartCnt) {
1416        TInt i = t;
1417        if (SrcOffsets[i] != SrcOffsets[i+1]) {
1418          SrcNodeCounts[i] = 1;
1419          TInt CurrNode = SrcCol1[SrcOffsets[i]];
1420          for (TInt j = SrcOffsets[i]+1; j < SrcOffsets[i+1]; j++) {
1421            while (j < SrcOffsets[i+1] && SrcCol1[j] == CurrNode) { j++; }
1422            if (j < SrcOffsets[i+1]) {
1423              SrcNodeCounts[i]++;
1424              CurrNode = SrcCol1[j];
1425            }
1426          }
1427        }
1428      } else {
1429        TInt i = t - SrcPartCnt;
1430        if (DstOffsets[i] != DstOffsets[i+1]) {
1431          DstNodeCounts[i] = 1;
1432          TInt CurrNode = DstCol2[DstOffsets[i]];
1433          for (TInt j = DstOffsets[i]+1; j < DstOffsets[i+1]; j++) {
1434            while (j < DstOffsets[i+1] && DstCol2[j] == CurrNode) { j++; }
1435            if (j < DstOffsets[i+1]) {
1436              DstNodeCounts[i]++;
1437              CurrNode = DstCol2[j];
1438            }
1439          }
1440        }
1441      }
1442    }
1443    TInt TotalSrcNodes = 0;
1444    TIntV SrcIdOffsets;
1445    for (int i = 0; i < SrcPartCnt; i++) {
1446      SrcIdOffsets.Add(TotalSrcNodes);
1447      TotalSrcNodes += SrcNodeCounts[i];
1448    }
1449    TInt TotalDstNodes = 0;
1450    TIntV DstIdOffsets;
1451    for (int i = 0; i < DstPartCnt; i++) {
1452      DstIdOffsets.Add(TotalDstNodes);
1453      TotalDstNodes += DstNodeCounts[i];
1454    }
1455    TIntPrV SrcNodeIds, DstNodeIds;
1456    #pragma omp parallel sections
1457    {
1458      #pragma omp section
1459      { SrcNodeIds.Reserve(TotalSrcNodes, TotalSrcNodes); }
1460      #pragma omp section
1461      { DstNodeIds.Reserve(TotalDstNodes, TotalDstNodes); }
1462    }
1463    #pragma omp parallel for schedule(dynamic)
1464    for (int t = 0; t < SrcPartCnt+DstPartCnt; t++) {
1465      if (t < SrcPartCnt) {
1466        TInt i = t;
1467        if (SrcOffsets[i] != SrcOffsets[i+1]) {
1468          TInt CurrNode = SrcCol1[SrcOffsets[i]];
1469          TInt ThreadOffset = SrcIdOffsets[i];
1470          SrcNodeIds[ThreadOffset] = TIntPr(CurrNode, SrcOffsets[i]);
1471          TInt CurrCount = 1;
1472          for (TInt j = SrcOffsets[i]+1; j < SrcOffsets[i+1]; j++) {
1473            while (j < SrcOffsets[i+1] && SrcCol1[j] == CurrNode) { j++; }
1474            if (j < SrcOffsets[i+1]) {
1475              CurrNode = SrcCol1[j];
1476              SrcNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
1477              CurrCount++;
1478            }
1479          }
1480        }
1481      } else {
1482        TInt i = t - SrcPartCnt;
1483        if (DstOffsets[i] != DstOffsets[i+1]) {
1484          TInt CurrNode = DstCol2[DstOffsets[i]];
1485          TInt ThreadOffset = DstIdOffsets[i];
1486          DstNodeIds[ThreadOffset] = TIntPr(CurrNode, DstOffsets[i]);
1487          TInt CurrCount = 1;
1488          for (TInt j = DstOffsets[i]+1; j < DstOffsets[i+1]; j++) {
1489            while (j < DstOffsets[i+1] && DstCol2[j] == CurrNode) { j++; }
1490            if (j < DstOffsets[i+1]) {
1491              CurrNode = DstCol2[j];
1492              DstNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
1493              CurrCount++;
1494            }
1495          }
1496        }
1497      }
1498    }
1499    Sw->Stop(TStopwatch::Group);
1500    Sw->Start(TStopwatch::MergeNeighborhoods);
1501    TIntTrV Nodes;
1502    Nodes.Reserve(TotalSrcNodes+TotalDstNodes);
1503    TInt i = 0, j = 0;
1504    while (i < TotalSrcNodes && j < TotalDstNodes) {
1505      if (SrcNodeIds[i].Val1 == DstNodeIds[j].Val1) {
1506        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, j));
1507        i++;
1508        j++;
1509      } else if (SrcNodeIds[i].Val1 < DstNodeIds[j].Val1) {
1510        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1));
1511        i++;
1512      } else {
1513        Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j));
1514        j++;
1515      }
1516    }
1517    for (; i < TotalSrcNodes; i++) { Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1)); }
1518    for (; j < TotalDstNodes; j++) { Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j)); }
1519    Sw->Stop(TStopwatch::MergeNeighborhoods);
1520    Sw->Start(TStopwatch::AddNeighborhoods);
1521    TInt NumNodes = Nodes.Len();
1522    PGraphMP Graph = PGraphMP::TObj::New(NumNodes, NumRows);
1523    TVec<TIntV> InVV(NumNodes);
1524    TVec<TIntV> OutVV(NumNodes);
1525    #pragma omp parallel for schedule(static,100)
1526    for (int m = 0; m < NumNodes; m++) {
1527      TInt n, i, j;
1528      Nodes[m].GetVal(n, i, j);
1529      if (i >= 0) {
1530        TInt Offset = SrcNodeIds[i].GetVal2();
1531        TInt Sz = EdgeCol1.Len()-Offset;
1532        if (i < SrcNodeIds.Len()-1) { Sz = SrcNodeIds[i+1].GetVal2()-Offset; }
1533        OutVV[m].Reserve(Sz);
1534        OutVV[m].CopyUniqueFrom(EdgeCol1, Offset, Sz);
1535      }
1536      if (j >= 0) {
1537        TInt Offset = DstNodeIds[j].GetVal2();
1538        TInt Sz = EdgeCol2.Len()-Offset;
1539        if (j < DstNodeIds.Len()-1) { Sz = DstNodeIds[j+1].GetVal2()-Offset; }
1540        InVV[m].Reserve(Sz);
1541        InVV[m].CopyUniqueFrom(EdgeCol2, Offset, Sz);
1542      }
1543      Graph->AddNodeWithEdges(n, InVV[m], OutVV[m]);
1544    }
1545    Graph->SetNodes(NumNodes);
1546    Sw->Stop(TStopwatch::AddNeighborhoods);
1547    Sw->Start(TStopwatch::AddEdges);
1548    omp_set_num_threads(omp_get_max_threads());
1549    if (NodeType == atInt) {
1550      #pragma omp parallel for schedule(static)
1551      for (int i = 0; i < Partitions.Len(); i++) {
1552        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1553        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1554        while (RowI < EndI) {
1555          TInt RowId = RowI.GetRowIdx(); 
1556          TInt SrcId = RowI.GetIntAttr(SrcColIdx);
1557          TInt DstId = RowI.GetIntAttr(DstColIdx);
1558          Graph->AddEdgeUnchecked(RowId, SrcId, DstId);
1559          RowI++;
1560        }
1561      }
1562    }
1563    else if (NodeType == atStr) {
1564      #pragma omp parallel for schedule(static)
1565      for (int i = 0; i < Partitions.Len(); i++) {
1566        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1567        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1568        while (RowI < EndI) {
1569          TInt RowId = RowI.GetRowIdx(); 
1570          TInt SrcId = RowI.GetStrMapById(SrcColIdx);
1571          TInt DstId = RowI.GetStrMapById(DstColIdx);
1572          Graph->AddEdgeUnchecked(RowId, SrcId, DstId);
1573          RowI++;
1574        }
1575      }
1576    }
1577    Graph->SetEdges(NumRows);
1578    Graph->SetMxEId(NumRows);
1579    Sw->Stop(TStopwatch::AddEdges);
1580    for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
1581      if ((Table->Next)[CurrRowIdx] == Table->Invalid) {
1582        continue;
1583      }
1584      for (TInt ea_i = 0; ea_i < EdgeAttrV.Len(); ea_i++) {
1585        TStr ColName = EdgeAttrV[ea_i];
1586        TAttrType T = Table->GetColType(ColName);
1587        TInt Index = Table->GetColIdx(ColName);
1588        switch (T) {
1589          case atInt:
1590            Graph->AddIntAttrDatE(CurrRowIdx, Table->IntCols[Index][CurrRowIdx], ColName);
1591            break;
1592          case atFlt:
1593            Graph->AddFltAttrDatE(CurrRowIdx, Table->FltCols[Index][CurrRowIdx], ColName);
1594            break;
1595          case atStr:
1596            Graph->AddStrAttrDatE(CurrRowIdx, Table->GetStrValIdx(Index, CurrRowIdx), ColName);
1597            break;
1598        }
1599      }
1600    }
1601    return Graph;
1602  }
1603  #endif 
1604  template<class PGraph>
1605  PGraph ToNetwork(PTable Table,
1606    const TStr& SrcCol, const TStr& DstCol,
1607    TStrV& EdgeAttrV, PTable NodeTable, const TStr& NodeCol, TStrV& NodeAttrV,
1608    TAttrAggr AggrPolicy) {
1609    PGraph Graph = PGraph::TObj::New();
1610    const TAttrType NodeType = Table->GetColType(SrcCol);
1611    Assert(NodeType == Table->GetColType(DstCol));
1612    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
1613    const TInt DstColIdx = Table->GetColIdx(DstCol);
1614    const TAttrType NodeTypeN = NodeTable->GetColType(NodeCol);
1615    const TInt NodeColIdx = NodeTable->GetColIdx(NodeCol);
1616    THash<TInt, TStrIntVH> NodeIntAttrs;
1617    THash<TInt, TStrFltVH> NodeFltAttrs;
1618    THash<TInt, TStrStrVH> NodeStrAttrs;
1619    THash<TFlt, TInt> FltNodeVals;
1620    for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
1621      if ((Table->Next)[CurrRowIdx] == Table->Invalid) {
1622        continue;
1623      }
1624      TInt SVal, DVal;
1625      if (NodeType == atFlt) {
1626        TFlt FSVal = (Table->FltCols)[SrcColIdx][CurrRowIdx];
1627        SVal = Table->CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
1628        TFlt FDVal = (Table->FltCols)[SrcColIdx][CurrRowIdx];
1629        DVal = Table->CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
1630      }
1631      else if (NodeType == atInt || NodeType == atStr) {
1632        if (NodeType == atInt) {
1633          SVal = (Table->IntCols)[SrcColIdx][CurrRowIdx];
1634          DVal = (Table->IntCols)[DstColIdx][CurrRowIdx];
1635        }
1636        else {
1637          SVal = (Table->StrColMaps)[SrcColIdx][CurrRowIdx];
1638          DVal = (Table->StrColMaps)[DstColIdx][CurrRowIdx];
1639        }
1640        if (!Graph->IsNode(SVal)) {Graph->AddNode(SVal); }
1641        if (!Graph->IsNode(DVal)) {Graph->AddNode(DVal); }
1642      }
1643      Graph->AddEdge(SVal, DVal, CurrRowIdx);
1644      for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
1645        TStr ColName = EdgeAttrV[i];
1646        TAttrType T = Table->GetColType(ColName);
1647        TInt Index = Table->GetColIdx(ColName);
1648        switch (T) {
1649          case atInt:
1650            Graph->AddIntAttrDatE(CurrRowIdx, Table->IntCols[Index][CurrRowIdx], ColName);
1651            break;
1652          case atFlt:
1653            Graph->AddFltAttrDatE(CurrRowIdx, Table->FltCols[Index][CurrRowIdx], ColName);
1654            break;
1655          case atStr:
1656            Graph->AddStrAttrDatE(CurrRowIdx, Table->GetStrValIdx(Index, CurrRowIdx), ColName);
1657            break;
1658        }
1659      }
1660    }
1661    if (NodeAttrV.Len() > 0) {
1662      for (int CurrRowIdx = 0; CurrRowIdx < (NodeTable->Next).Len(); CurrRowIdx++) {
1663        if ((NodeTable->Next)[CurrRowIdx] == NodeTable->Invalid) {
1664        	continue;
1665        }
1666        TInt NId;
1667        if (NodeTypeN == atInt) {
1668          NId = (NodeTable->IntCols)[NodeColIdx][CurrRowIdx];
1669        }
1670        else if (NodeTypeN == atStr){
1671          NId = (NodeTable->StrColMaps)[NodeColIdx][CurrRowIdx];
1672        }
1673        for (TInt i = 0; i < NodeAttrV.Len(); i++) {
1674          TStr ColName = NodeAttrV[i];
1675          TAttrType T = NodeTable->GetColType(ColName);
1676          TInt Index = NodeTable->GetColIdx(ColName);
1677          switch (T) {
1678            case atInt:
1679              Graph->AddIntAttrDatN(NId, NodeTable->IntCols[Index][CurrRowIdx], ColName);
1680              break;
1681            case atFlt:
1682              Graph->AddFltAttrDatN(NId, NodeTable->FltCols[Index][CurrRowIdx], ColName);
1683              break;
1684            case atStr:
1685              Graph->AddStrAttrDatN(NId, NodeTable->GetStrValIdx(Index, CurrRowIdx), ColName);
1686              break;
1687          }
1688        }
1689      }
1690    }
1691    return Graph;
1692  }
1693  #ifdef GCC_ATOMIC
1694  template<class PGraphMP>
1695  inline PGraphMP ToNetworkMP(PTable Table,
1696    const TStr& SrcCol, const TStr& DstCol,
1697    TStrV& EdgeAttrV, PTable NodeTable, const TStr& NodeCol, TStrV& NodeAttrV,
1698    TAttrAggr AggrPolicy) {
1699    TStopwatch* Sw = TStopwatch::GetInstance();
1700    Sw->Start(TStopwatch::AllocateColumnCopies);
1701    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
1702    const TInt DstColIdx = Table->GetColIdx(DstCol);
1703    const TInt NumRows = Table->GetNumValidRows();
1704    const TAttrType NodeType = Table->GetColType(SrcCol);
1705    Assert(NodeType == Table->GetColType(DstCol));
1706    TIntV SrcCol1, EdgeCol1, EdgeCol2, DstCol2;
1707    const TAttrType NodeTypeN = NodeTable->GetColType(NodeCol);
1708    const TInt NodeColIdx = NodeTable->GetColIdx(NodeCol);
1709    THash<TInt, TStrIntVH> NodeIntAttrs;
1710    THash<TInt, TStrFltVH> NodeFltAttrs;
1711    THash<TInt, TStrStrVH> NodeStrAttrs;
1712    #pragma omp parallel sections num_threads(4)
1713    {
1714      #pragma omp section
1715      { SrcCol1.Reserve(NumRows, NumRows); }
1716      #pragma omp section
1717      { EdgeCol1.Reserve(NumRows, NumRows); }
1718      #pragma omp section
1719      { DstCol2.Reserve(NumRows, NumRows); }
1720      #pragma omp section
1721      { EdgeCol2.Reserve(NumRows, NumRows); }
1722    }
1723    Sw->Stop(TStopwatch::AllocateColumnCopies);
1724    Sw->Start(TStopwatch::CopyColumns);
1725    TIntPrV Partitions;
1726    Table->GetPartitionRanges(Partitions, omp_get_max_threads());
1727    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1728    omp_set_num_threads(omp_get_max_threads());
1729    if (NodeType == atInt) {
1730      #pragma omp parallel for schedule(static)
1731      for (int i = 0; i < Partitions.Len(); i++) {
1732        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1733        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1734        while (RowI < EndI) {
1735          TInt RowId = RowI.GetRowIdx();
1736          SrcCol1[RowId] = RowI.GetIntAttr(SrcColIdx);
1737          EdgeCol1[RowId] = RowId;
1738          DstCol2[RowId] = RowI.GetIntAttr(DstColIdx);
1739          EdgeCol2[RowId] = RowId;
1740          RowI++;
1741        }
1742      }
1743    }
1744    else if (NodeType == atStr) {
1745      #pragma omp parallel for schedule(static)
1746      for (int i = 0; i < Partitions.Len(); i++) {
1747        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1748        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1749        while (RowI < EndI) {
1750          TInt RowId = RowI.GetRowIdx();
1751          SrcCol1[RowId] = RowI.GetStrMapById(SrcColIdx);
1752          EdgeCol1[RowId] = RowId;
1753          DstCol2[RowId] = RowI.GetStrMapById(DstColIdx);
1754          EdgeCol2[RowId] = RowId;
1755          RowI++;
1756        }
1757      }
1758    }
1759    Sw->Stop(TStopwatch::CopyColumns);
1760    Sw->Start(TStopwatch::Sort);
1761    omp_set_num_threads(omp_get_max_threads());
1762    #pragma omp parallel
1763    {
1764      #pragma omp single nowait
1765      {
1766        #ifndef GLib_WIN32
1767        #pragma omp task untied shared(SrcCol1, EdgeCol1)
1768        #endif
1769        { TTable::QSortKeyVal(SrcCol1, EdgeCol1, 0, NumRows-1); }
1770      }
1771      #pragma omp single nowait
1772      {
1773        #ifndef GLib_WIN32
1774        #pragma omp task untied shared(EdgeCol2, DstCol2)
1775        #endif
1776       { TTable::QSortKeyVal(DstCol2, EdgeCol2, 0, NumRows-1); }
1777      }
1778      #ifndef GLib_WIN32
1779      #pragma omp taskwait
1780      #endif
1781    }
1782    Sw->Stop(TStopwatch::Sort);
1783    Sw->Start(TStopwatch::Group);
1784    TInt NumThreads = omp_get_max_threads();
1785    TInt PartSize = (NumRows/NumThreads);
1786    TIntV SrcOffsets, DstOffsets;
1787    SrcOffsets.Add(0);
1788    for (TInt i = 1; i < NumThreads; i++) {
1789      TInt CurrOffset = i * PartSize;
1790      while (CurrOffset < (i+1) * PartSize &&
1791            SrcCol1[CurrOffset-1] == SrcCol1[CurrOffset]) {
1792        CurrOffset++;
1793      }
1794      if (CurrOffset < (i+1) * PartSize) { SrcOffsets.Add(CurrOffset); }
1795    }
1796    SrcOffsets.Add(NumRows);
1797    DstOffsets.Add(0);
1798    for (TInt i = 1; i < NumThreads; i++) {
1799      TInt CurrOffset = i * PartSize;
1800      while (CurrOffset < (i+1) * PartSize &&
1801            DstCol2[CurrOffset-1] == DstCol2[CurrOffset]) {
1802        CurrOffset++;
1803      }
1804      if (CurrOffset < (i+1) * PartSize) { DstOffsets.Add(CurrOffset); }
1805    }
1806    DstOffsets.Add(NumRows);
1807    TInt SrcPartCnt = SrcOffsets.Len()-1; 
1808    TInt DstPartCnt = DstOffsets.Len()-1; 
1809    TIntV SrcNodeCounts, DstNodeCounts;
1810    SrcNodeCounts.Reserve(SrcPartCnt, SrcPartCnt);
1811    DstNodeCounts.Reserve(DstPartCnt, DstPartCnt);
1812    #pragma omp parallel for schedule(dynamic)
1813    for (int t = 0; t < SrcPartCnt+DstPartCnt; t++) {
1814      if (t < SrcPartCnt) {
1815        TInt i = t;
1816        if (SrcOffsets[i] != SrcOffsets[i+1]) {
1817          SrcNodeCounts[i] = 1;
1818          TInt CurrNode = SrcCol1[SrcOffsets[i]];
1819          for (TInt j = SrcOffsets[i]+1; j < SrcOffsets[i+1]; j++) {
1820            while (j < SrcOffsets[i+1] && SrcCol1[j] == CurrNode) { j++; }
1821            if (j < SrcOffsets[i+1]) {
1822              SrcNodeCounts[i]++;
1823              CurrNode = SrcCol1[j];
1824            }
1825          }
1826        }
1827      } else {
1828        TInt i = t - SrcPartCnt;
1829        if (DstOffsets[i] != DstOffsets[i+1]) {
1830          DstNodeCounts[i] = 1;
1831          TInt CurrNode = DstCol2[DstOffsets[i]];
1832          for (TInt j = DstOffsets[i]+1; j < DstOffsets[i+1]; j++) {
1833            while (j < DstOffsets[i+1] && DstCol2[j] == CurrNode) { j++; }
1834            if (j < DstOffsets[i+1]) {
1835              DstNodeCounts[i]++;
1836              CurrNode = DstCol2[j];
1837            }
1838          }
1839        }
1840      }
1841    }
1842    TInt TotalSrcNodes = 0;
1843    TIntV SrcIdOffsets;
1844    for (int i = 0; i < SrcPartCnt; i++) {
1845      SrcIdOffsets.Add(TotalSrcNodes);
1846      TotalSrcNodes += SrcNodeCounts[i];
1847    }
1848    TInt TotalDstNodes = 0;
1849    TIntV DstIdOffsets;
1850    for (int i = 0; i < DstPartCnt; i++) {
1851      DstIdOffsets.Add(TotalDstNodes);
1852      TotalDstNodes += DstNodeCounts[i];
1853    }
1854    TIntPrV SrcNodeIds, DstNodeIds;
1855    #pragma omp parallel sections
1856    {
1857      #pragma omp section
1858      { SrcNodeIds.Reserve(TotalSrcNodes, TotalSrcNodes); }
1859      #pragma omp section
1860      { DstNodeIds.Reserve(TotalDstNodes, TotalDstNodes); }
1861    }
1862    #pragma omp parallel for schedule(dynamic)
1863    for (int t = 0; t < SrcPartCnt+DstPartCnt; t++) {
1864      if (t < SrcPartCnt) {
1865        TInt i = t;
1866        if (SrcOffsets[i] != SrcOffsets[i+1]) {
1867          TInt CurrNode = SrcCol1[SrcOffsets[i]];
1868          TInt ThreadOffset = SrcIdOffsets[i];
1869          SrcNodeIds[ThreadOffset] = TIntPr(CurrNode, SrcOffsets[i]);
1870          TInt CurrCount = 1;
1871          for (TInt j = SrcOffsets[i]+1; j < SrcOffsets[i+1]; j++) {
1872            while (j < SrcOffsets[i+1] && SrcCol1[j] == CurrNode) { j++; }
1873            if (j < SrcOffsets[i+1]) {
1874              CurrNode = SrcCol1[j];
1875              SrcNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
1876              CurrCount++;
1877            }
1878          }
1879        }
1880      } else {
1881        TInt i = t - SrcPartCnt;
1882        if (DstOffsets[i] != DstOffsets[i+1]) {
1883          TInt CurrNode = DstCol2[DstOffsets[i]];
1884          TInt ThreadOffset = DstIdOffsets[i];
1885          DstNodeIds[ThreadOffset] = TIntPr(CurrNode, DstOffsets[i]);
1886          TInt CurrCount = 1;
1887          for (TInt j = DstOffsets[i]+1; j < DstOffsets[i+1]; j++) {
1888            while (j < DstOffsets[i+1] && DstCol2[j] == CurrNode) { j++; }
1889            if (j < DstOffsets[i+1]) {
1890              CurrNode = DstCol2[j];
1891              DstNodeIds[ThreadOffset+CurrCount] = TIntPr(CurrNode, j);
1892              CurrCount++;
1893            }
1894          }
1895        }
1896      }
1897    }
1898    Sw->Stop(TStopwatch::Group);
1899    Sw->Start(TStopwatch::MergeNeighborhoods);
1900    TIntTrV Nodes;
1901    Nodes.Reserve(TotalSrcNodes+TotalDstNodes);
1902    TInt i = 0, j = 0;
1903    while (i < TotalSrcNodes && j < TotalDstNodes) {
1904      if (SrcNodeIds[i].Val1 == DstNodeIds[j].Val1) {
1905        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, j));
1906        i++;
1907        j++;
1908      } else if (SrcNodeIds[i].Val1 < DstNodeIds[j].Val1) {
1909        Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1));
1910        i++;
1911      } else {
1912        Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j));
1913        j++;
1914      }
1915    }
1916    for (; i < TotalSrcNodes; i++) { Nodes.Add(TIntTr(SrcNodeIds[i].Val1, i, -1)); }
1917    for (; j < TotalDstNodes; j++) { Nodes.Add(TIntTr(DstNodeIds[j].Val1, -1, j)); }
1918    Sw->Stop(TStopwatch::MergeNeighborhoods);
1919    Sw->Start(TStopwatch::AddNeighborhoods);
1920    TInt NumNodes = Nodes.Len();
1921    PGraphMP Graph = PGraphMP::TObj::New(NumNodes, NumRows);
1922    TVec<TIntV> InVV(NumNodes);
1923    TVec<TIntV> OutVV(NumNodes);
1924    #pragma omp parallel for schedule(static,100)
1925    for (int m = 0; m < NumNodes; m++) {
1926      TInt n, i, j;
1927      Nodes[m].GetVal(n, i, j);
1928      if (i >= 0) {
1929        TInt Offset = SrcNodeIds[i].GetVal2();
1930        TInt Sz = EdgeCol1.Len()-Offset;
1931        if (i < SrcNodeIds.Len()-1) { Sz = SrcNodeIds[i+1].GetVal2()-Offset; }
1932        OutVV[m].Reserve(Sz);
1933        OutVV[m].CopyUniqueFrom(EdgeCol1, Offset, Sz);
1934      }
1935      if (j >= 0) {
1936        TInt Offset = DstNodeIds[j].GetVal2();
1937        TInt Sz = EdgeCol2.Len()-Offset;
1938        if (j < DstNodeIds.Len()-1) { Sz = DstNodeIds[j+1].GetVal2()-Offset; }
1939        InVV[m].Reserve(Sz);
1940        InVV[m].CopyUniqueFrom(EdgeCol2, Offset, Sz);
1941      }
1942      Graph->AddNodeWithEdges(n, InVV[m], OutVV[m]);
1943    }
1944    Graph->SetNodes(NumNodes);
1945    Sw->Stop(TStopwatch::AddNeighborhoods);
1946    Sw->Start(TStopwatch::AddEdges);
1947    omp_set_num_threads(omp_get_max_threads());
1948    if (NodeType == atInt) {
1949      #pragma omp parallel for schedule(static)
1950      for (int i = 0; i < Partitions.Len(); i++) {
1951        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1952        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1953        while (RowI < EndI) {
1954          TInt RowId = RowI.GetRowIdx(); 
1955          TInt SrcId = RowI.GetIntAttr(SrcColIdx);
1956          TInt DstId = RowI.GetIntAttr(DstColIdx);
1957          Graph->AddEdgeUnchecked(RowId, SrcId, DstId);
1958          RowI++;
1959        }
1960      }
1961    }
1962    else if (NodeType == atStr) {
1963      #pragma omp parallel for schedule(static)
1964      for (int i = 0; i < Partitions.Len(); i++) {
1965        TRowIterator RowI(Partitions[i].GetVal1(), Table());
1966        TRowIterator EndI(Partitions[i].GetVal2(), Table());
1967        while (RowI < EndI) {
1968          TInt RowId = RowI.GetRowIdx(); 
1969          TInt SrcId = RowI.GetStrMapById(SrcColIdx);
1970          TInt DstId = RowI.GetStrMapById(DstColIdx);
1971          Graph->AddEdgeUnchecked(RowId, SrcId, DstId);
1972          RowI++;
1973        }
1974      }
1975    }
1976    Graph->SetEdges(NumRows);
1977    Graph->SetMxEId(NumRows);
1978    Sw->Stop(TStopwatch::AddEdges);
1979    for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
1980      if ((Table->Next)[CurrRowIdx] == Table->Invalid) {
1981        continue;
1982      }
1983      for (TInt ea_i = 0; ea_i < EdgeAttrV.Len(); ea_i++) {
1984        TStr ColName = EdgeAttrV[ea_i];
1985        TAttrType T = Table->GetColType(ColName);
1986        TInt Index = Table->GetColIdx(ColName);
1987        switch (T) {
1988          case atInt:
1989            Graph->AddIntAttrDatE(CurrRowIdx, Table->IntCols[Index][CurrRowIdx], ColName);
1990            break;
1991          case atFlt:
1992            Graph->AddFltAttrDatE(CurrRowIdx, Table->FltCols[Index][CurrRowIdx], ColName);
1993            break;
1994          case atStr:
1995            Graph->AddStrAttrDatE(CurrRowIdx, Table->GetStrValIdx(Index, CurrRowIdx), ColName);
1996            break;
1997        }
1998      }
1999    }
2000    if (NodeAttrV.Len() > 0) {
2001      for (int CurrRowIdx = 0; CurrRowIdx < (NodeTable->Next).Len(); CurrRowIdx++) {
2002        if ((NodeTable->Next)[CurrRowIdx] == NodeTable->Invalid) {
2003        	continue;
2004        }
2005        TInt NId;
2006        if (NodeTypeN == atInt) {
2007          NId = (NodeTable->IntCols)[NodeColIdx][CurrRowIdx];
2008        }
2009        else if (NodeTypeN == atStr){
2010          NId = (NodeTable->StrColMaps)[NodeColIdx][CurrRowIdx];
2011        }
2012        for (TInt i = 0; i < NodeAttrV.Len(); i++) {
2013          TStr ColName = NodeAttrV[i];
2014          TAttrType T = NodeTable->GetColType(ColName);
2015          TInt Index = NodeTable->GetColIdx(ColName);
2016          switch (T) {
2017            case atInt:
2018              Graph->AddIntAttrDatN(NId, NodeTable->IntCols[Index][CurrRowIdx], ColName);
2019              break;
2020            case atFlt:
2021              Graph->AddFltAttrDatN(NId, NodeTable->FltCols[Index][CurrRowIdx], ColName);
2022              break;
2023            case atStr:
2024              Graph->AddStrAttrDatN(NId, NodeTable->GetStrValIdx(Index, CurrRowIdx), ColName);
2025              break;
2026          }
2027        }
2028      }
2029    }
2030    return Graph;
2031  }
2032  #endif 
2033  }; 
2034  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-civil_time_detail.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-conv.h</div>
                </div>
                <div class="column column_space"><pre><code>86    } else {
87      if (d > -365) {
88        ey -= 1;
89        d += days_per_year(ey, m);
90      } else {
91        ey -= 400;
92        d += 146097;
93      }
</pre></code></div>
                <div class="column column_space"><pre><code>1264      else if (NodeType == atInt || NodeType == atStr) {
1265        if (NodeType == atInt) {
1266          SVal = (Table->IntCols)[SrcColIdx][CurrRowIdx];
1267          DVal = (Table->IntCols)[DstColIdx][CurrRowIdx];
1268        }
1269        else {
1270          SVal = (Table->StrColMaps)[SrcColIdx][CurrRowIdx];
1271          DVal = (Table->StrColMaps)[DstColIdx][CurrRowIdx];
1272        }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    