
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</h3>
            <pre><code>1  #ifdef GLib_LINUX
2  extern &quot;C&quot; {
3  	#include &lt;sys/mman.h&gt;
4  }
5  #endif
6  const int TCs::MxMask=0x0FFFFFFF;
7  TCs TCs::GetCsFromBf(char* Bf, const int&amp; BfL){
8    TCs Cs;
9    for (int BfC=0; BfC&lt;BfL; BfC++){Cs+=Bf[BfC];}
10    return Cs;
11  }
12  TStr TSBase::GetSNm() const {
13    return TStr(SNm.CStr());
14  }
15  TSIn::TSIn(const TStr&amp; Str) : TSBase(Str.CStr()), FastMode(false){}
16  void TSIn::LoadCs(){
17    TCs CurCs=Cs; TCs TestCs;
18    Cs+=GetBf(&amp;TestCs, sizeof(TestCs));
19    EAssertR(CurCs==TestCs, &quot;Invalid checksum reading &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
20  }
21  void TSIn::Load(char*&amp; CStr){
22    char Ch; Load(Ch);
23    int CStrLen=int(Ch);
24    EAssertR(CStrLen&gt;=0, &quot;Error reading stream &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
25    CStr=new char[CStrLen+1];
26    if (CStrLen&gt;0){Cs+=GetBf(CStr, CStrLen);}
27    CStr[CStrLen]=TCh::NullCh;
28  }
29  bool TSIn::GetNextLn(TStr&amp; LnStr){
30    TChA LnChA;
31    const bool IsNext=GetNextLn(LnChA);
32    LnStr=LnChA;
33    return IsNext;
34  }
35  bool TSIn::GetNextLn(TChA&amp; LnChA){
36    LnChA.Clr();
37    while (!Eof()){
38      const char Ch=GetCh();
39      if (Ch==&#x27;\n&#x27;){return true;}
40      if (Ch==&#x27;\r&#x27; &amp;&amp; PeekCh()==&#x27;\n&#x27;){GetCh(); return true;}
41      LnChA.AddCh(Ch);
42    }
43    return !LnChA.Empty();
44  }
45  const PSIn TSIn::StdIn=PSIn(new TStdIn());
46  TStdIn::TStdIn(): TSBase(&quot;Standard input&quot;), TSIn(&quot;Standard input&quot;) {}
47  TSOut::TSOut(const TStr&amp; Str):
48    TSBase(Str.CStr()), MxLnLen(-1), LnLen(0){}
49  int TSOut::UpdateLnLen(const int&amp; StrLen, const bool&amp; ForceInLn){
50    int Cs=0;
51    if (MxLnLen!=-1){
52      if ((!ForceInLn)&amp;&amp;(LnLen+StrLen&gt;MxLnLen)){Cs+=PutLn();}
53      LnLen+=StrLen;
54    }
55    return Cs;
56  }
57  int TSOut::PutMem(const TMem&amp; Mem){
58    return PutBf(Mem(), Mem.Len());
59  }
60  int TSOut::PutCh(const char&amp; Ch, const int&amp; Chs){
61    int Cs=0;
62    for (int ChN=0; ChN&lt;Chs; ChN++){Cs+=PutCh(Ch);}
63    return Cs;
64  }
65  int TSOut::PutBool(const bool&amp; Bool){
66    return PutStr(TBool::GetStr(Bool));
67  }
68  int TSOut::PutInt(const int&amp; Int){
69    return PutStr(TInt::GetStr(Int));
70  }
71  int TSOut::PutInt(const int&amp; Int, const char* FmtStr){
72    return PutStr(TInt::GetStr(Int, FmtStr));
73  }
74  int TSOut::PutUInt(const uint&amp; UInt){
75    return PutStr(TUInt::GetStr(UInt));
76  }
77  int TSOut::PutUInt(const uint&amp; UInt, const char* FmtStr){
78    return PutStr(TUInt::GetStr(UInt, FmtStr));
79  }
80  int TSOut::PutFlt(const double&amp; Flt){
81    return PutStr(TFlt::GetStr(Flt));
82  }
83  int TSOut::PutFlt(const double&amp; Flt, const char* FmtStr){
84    return PutStr(TFlt::GetStr(Flt, FmtStr));
85  }
86  int TSOut::PutStr(const char* CStr){
87    int Cs=UpdateLnLen(int(strlen(CStr)));
88    return Cs+PutBf(CStr, int(strlen(CStr)));
89  }
90  int TSOut::PutStr(const TChA&amp; ChA){
91    int Cs=UpdateLnLen(ChA.Len());
92    return Cs+PutBf(ChA.CStr(), ChA.Len());
93  }
94  int TSOut::PutStr(const TStr&amp; Str, const char* FmtStr){
95    return PutStr(TStr::GetStr(Str, FmtStr));
96  }
97  int TSOut::PutStr(const TStr&amp; Str, const bool&amp; ForceInLn){
98    int Cs=UpdateLnLen(Str.Len(), ForceInLn);
99    return Cs+PutBf(Str.CStr(), Str.Len());
100  }
101  int TSOut::PutStrFmt(const char *FmtStr, ...){
102    char Bf[10*1024];
103    va_list valist;
104    va_start(valist, FmtStr);
105    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
106    va_end(valist);
107    return RetVal!=-1 ? PutStr(TStr(Bf)) : 0;	
108  }
109  int TSOut::PutStrFmtLn(const char *FmtStr, ...){
110    char Bf[10*1024];
111    va_list valist;
112    va_start(valist, FmtStr);
113    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
114    va_end(valist);
115    return RetVal!=-1 ? PutStrLn(TStr(Bf)) : PutLn();	
116  }
117  int TSOut::PutIndent(const int&amp; IndentLev){
118    return PutCh(&#x27; &#x27;, IndentLev*2);
119  }
120  int TSOut::PutLn(const int&amp; Lns){
121    LnLen=0; int Cs=0;
122    for (int LnN=0; LnN&lt;Lns; LnN++){Cs+=PutCh(&#x27;\n&#x27;);}
123    return Cs;
124  }
125  int TSOut::PutDosLn(const int&amp; Lns){
126    LnLen=0; int Cs=0;
127    for (int LnN=0; LnN&lt;Lns; LnN++){Cs+=PutCh(TCh::CrCh)+PutCh(TCh::LfCh);}
128    return Cs;
129  }
130  int TSOut::PutSep(const int&amp; NextStrLen){
131    int Cs=0;
132    if (MxLnLen==-1){
133      Cs+=PutCh(&#x27; &#x27;);
134    } else {
135      if (LnLen&gt;0){
136        if (LnLen+1+NextStrLen&gt;MxLnLen){Cs+=PutLn();} else {Cs+=PutCh(&#x27; &#x27;);}
137      }
138    }
139    return Cs;
140  }
141  int TSOut::PutSepLn(const int&amp; Lns){
142    int Cs=0;
143    if (LnLen&gt;0){Cs+=PutLn();}
144    Cs+=PutLn(Lns);
145    return Cs;
146  }
147  void TSOut::Save(const char* CStr){
148    int CStrLen=int(strlen(CStr));
149    EAssertR(CStrLen&lt;=127, &quot;Error writting stream &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
150    Save(char(CStrLen));
151    if (CStrLen&gt;0){Cs+=PutBf(CStr, CStrLen);}
152  }
153  void TSOut::Save(TSIn&amp; SIn, const TSize&amp; BfL){
154    Fail;
155    if (BfL==0){ 
156      while (!SIn.Eof()){Save(SIn.GetCh());}
157    } else {
158      for (TSize BfC=0; BfC&lt;BfL; BfC++){Save(SIn.GetCh());}
159    }
160  }
161  TSOut&amp; TSOut::operator&lt;&lt;(TSIn&amp; SIn) {
162    while (!SIn.Eof())
163      operator&lt;&lt;((char)SIn.GetCh());
164    return *this;
165  }
166  const PSOut TSOut::StdOut=PSOut(new TStdOut());
167  TStdOut::TStdOut(): TSBase(TSStr(&quot;Standard output&quot;)), TSOut(&quot;Standard output&quot;){}
168  int TStdIn::GetBf(const void* LBf, const TSize&amp; LBfL){
169    int LBfS=0;
170    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
171      LBfS+=(((char*)LBf)[LBfC]=GetCh());}
172    return LBfS;
173  }
174  bool TStdIn::GetNextLnBf(TChA&amp; LnChA){
175    FailR(TStr::Fmt(&quot;TStdIn::GetNextLnBf: not implemented&quot;).CStr());
176    return false;
177  }
178  int TStdOut::PutBf(const void* LBf, const TSize&amp; LBfL){
179    int LBfS=0;
180    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
181      LBfS+=PutCh(((char*)LBf)[LBfC]);}
182    return LBfS;
183  }
184  const int TFIn::MxBfL=16*1024;
185  void TFIn::SetFPos(const int&amp; FPos) const {
186    EAssertR(
187     fseek(FileId, FPos, SEEK_SET)==0,
188     &quot;Error seeking into file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
189  }
190  int TFIn::GetFPos() const {
191    const int FPos=(int)ftell(FileId);
192    EAssertR(FPos!=-1, &quot;Error seeking into file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
193    return FPos;
194  }
195  int TFIn::GetFLen() const {
196    const int FPos=GetFPos();
197    EAssertR(
198     fseek(FileId, 0, SEEK_END)==0,
199     &quot;Error seeking into file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
200    const int FLen=GetFPos(); SetFPos(FPos);
201    return FLen;
202  }
203  void TFIn::FillBf(){
204    EAssertR(
205     (BfC==BfL)&amp;&amp;((BfL==-1)||(BfL==MxBfL)),
206     &quot;Error reading file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
207    BfL=int(fread(Bf, 1, MxBfL, FileId));
208    EAssertR((BfC!=0)||(BfL!=0), &quot;Error reading file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
209    BfC=0;
210  }
211  TFIn::TFIn(const TStr&amp; FNm):
212    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
213    EAssertR(!FNm.Empty(), &quot;Empty file-name.&quot;);
214    FileId=fopen(FNm.CStr(), &quot;rb&quot;);
215    EAssertR(FileId!=NULL, &quot;Can not open file &#x27;&quot;+FNm+&quot;&#x27;.&quot;);
216    Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();
217  }
218  TFIn::TFIn(const TStr&amp; FNm, bool&amp; OpenedP):
219    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
220    EAssertR(!FNm.Empty(), &quot;Empty file-name.&quot;);
221    FileId=fopen(FNm.CStr(), &quot;rb&quot;);
222    OpenedP=(FileId!=NULL);
223    if (OpenedP){
224      Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();}
225  }
226  PSIn TFIn::New(const TStr&amp; FNm){
227    try {
228      return PSIn(new TFIn(FNm));
229    } catch (PExcept&amp; Except) {
230      printf(&quot;*** Exception: %s\n&quot;, Except-&gt;GetMsgStr().CStr());
231      EFailR(Except-&gt;GetMsgStr());
232    }
233    return PSIn(new TFIn(FNm));
234  }
<span onclick='openModal()' class='match'>235  PSIn TFIn::New(const TStr&amp; FNm, bool&amp; OpenedP){
236    return PSIn(new TFIn(FNm, OpenedP));
</span>237  }
238  TFIn::~TFIn(){
239    if (FileId!=NULL){
240      EAssertR(fclose(FileId)==0, &quot;Can not close file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);}
241    if (Bf!=NULL){delete[] Bf;}
242  }
243  int TFIn::GetBf(const void* LBf, const TSize&amp; LBfL){
244    int LBfS=0;
245    if (TSize(BfC+LBfL)&gt;TSize(BfL)){
246      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
247        if (BfC==BfL){FillBf();}
248        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
249    } else {
250      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
251        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
252    }
253    return LBfS;
254  }
255  bool TFIn::GetNextLnBf(TChA&amp; LnChA) {
256    int Status;
257    int BfN;        
258    int BfP;        
259    bool CrEnd;     
260    LnChA.Clr();
261    CrEnd = false;
262    do {
263      if (BfC &gt;= BfL) {
264        BfP = 0;
265      } else {
266        BfP = BfC;
267      }
268      Status = FindEol(BfN,CrEnd);
269      if (Status &gt;= 0) {
270        if (BfN-BfP &gt; 0) {
271          LnChA.AddBf(&amp;Bf[BfP],BfN-BfP);
272        }
273        if (Status == 1) {
274          return true;
275        }
276      }
277    } while (Status == 0);
278    return !LnChA.Empty();
279  }
280  int TFIn::FindEol(int&amp; BfN, bool&amp; CrEnd) {
281    char Ch;
282    if (BfC &gt;= BfL) {
283      if (Eof()) {
284        return -1;
285      }
286      if (CrEnd &amp;&amp; Bf[BfC]==&#x27;\n&#x27;) {
287        BfC++;
288        BfN = BfC-1;
289        return 1;
290      }
291    }
292    CrEnd = false;
293    while (BfC &lt; BfL) {
294      Ch = Bf[BfC++];
295      if (Ch==&#x27;\n&#x27;) {
296        BfN = BfC-1;
297        return 1;
298      }
299      if (Ch==&#x27;\r&#x27;) {
300        if (BfC == BfL) {
301          CrEnd = true;
302          BfN = BfC-1;
303          return 0;
304        } else if (Bf[BfC]==&#x27;\n&#x27;) {
305          BfC++;
306          BfN = BfC-2;
307          return 1;
308        }
309      }
310    }
311    BfN = BfC;
312    return 0;
313  }
314  const TSize TFOut::MxBfL=16*1024;;
315  void TFOut::FlushBf(){
316    EAssertR(
317     fwrite(Bf, 1, BfL, FileId)==BfL,
318     &quot;Error writting to the file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
319    BfL=0;
320  }
321  TFOut::TFOut(const TStr&amp; FNm, const bool&amp; Append):
322    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
323    if (FNm.GetUc()==&quot;CON&quot;){
324      FileId=stdout;
325    } else {
326      if (Append){FileId=fopen(FNm.CStr(), &quot;a+b&quot;);}
327      else {FileId=fopen(FNm.CStr(), &quot;w+b&quot;);}
328      EAssertR(FileId!=NULL, &quot;Can not open file &#x27;&quot;+FNm+&quot;&#x27;.&quot;);
329      Bf=new char[MxBfL]; BfL=0;
330    }
331  }
332  TFOut::TFOut(const TStr&amp; FNm, const bool&amp; Append, bool&amp; OpenedP):
333    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
334    if (FNm.GetUc()==&quot;CON&quot;){
335      FileId=stdout;
336    } else {
337      if (Append){FileId=fopen(FNm.CStr(), &quot;a+b&quot;);}
338      else {FileId=fopen(FNm.CStr(), &quot;w+b&quot;);}
339      OpenedP=(FileId!=NULL);
340      if (OpenedP){
341        Bf=new char[MxBfL]; BfL=0;}
342    }
343  }
344  PSOut TFOut::New(const TStr&amp; FNm, const bool&amp; Append){
345    return PSOut(new TFOut(FNm, Append));
346  }
347  PSOut TFOut::New(const TStr&amp; FNm, const bool&amp; Append, bool&amp; OpenedP){
348    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
349    if (OpenedP){return SOut;} else {return NULL;}
350  }
351  TFOut::~TFOut(){
352    if (FileId!=NULL){FlushBf();}
353    if (Bf!=NULL){delete[] Bf;}
354    if (FileId!=NULL){
355      EAssertR(fclose(FileId)==0, &quot;Can not close file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);}
356  }
357  int TFOut::PutCh(const char&amp; Ch){
358    if (BfL==TSize(MxBfL)){FlushBf();}
359    return Bf[BfL++]=Ch;
360  }
361  int TFOut::PutBf(const void* LBf, const TSize&amp; LBfL){
362    int LBfS=0;
363    if (BfL+LBfL&gt;MxBfL){
364      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
365        LBfS+=PutCh(((char*)LBf)[LBfC]);}
366    } else {
367      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
368        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
369    }
370    return LBfS;
371  }
372  void TFOut::Flush(){
373    FlushBf();
374    EAssertR(fflush(FileId)==0, &quot;Can not flush file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
375  }
376  TFInOut::TFInOut(const TStr&amp; FNm, const TFAccess&amp; FAccess, const bool&amp; CreateIfNo) :
377   TSBase(TSStr(FNm.CStr())), FileId(NULL) {
378    switch (FAccess){
379      case faCreate: FileId=fopen(FNm.CStr(), &quot;w+b&quot;); break;
380      case faUpdate: FileId=fopen(FNm.CStr(), &quot;r+b&quot;); break;
381      case faAppend: FileId=fopen(FNm.CStr(), &quot;r+b&quot;);
382        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
383      case faRdOnly: FileId=fopen(FNm.CStr(), &quot;rb&quot;); break;
384      default: Fail;
385    }
386    if ((FileId==NULL)&amp;&amp;(CreateIfNo)){FileId=fopen(FNm.CStr(), &quot;w+b&quot;);}
387    IAssert(FileId!=NULL);
388  }
389  PSInOut TFInOut::New(const TStr&amp; FNm, const TFAccess&amp; FAccess, const bool&amp; CreateIfNo) {
390    return PSInOut(new TFInOut(FNm, FAccess, CreateIfNo));
391  }
392  int TFInOut::GetSize() const {
393    const int FPos = GetPos();
394    IAssert(fseek(FileId, 0, SEEK_END) == 0);
395    const int FLen = GetPos();
396    IAssert(fseek(FileId, FPos, SEEK_SET) == 0);
397    return FLen;
398  }
399  int TFInOut::PutBf(const void* LBf, const TSize&amp; LBfL) {
400    int LBfS = 0;
401    for (TSize i = 0; i &lt; LBfL; i++) {
402      LBfS += ((char *)LBf)[i];
403    }
404    IAssert(fwrite(LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
405    return LBfS;
406  }
407  int TFInOut::GetBf(const void* LBf, const TSize&amp; LBfL) {
408    IAssert(fread((void *)LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
409    int LBfS = 0;
410    for (TSize i = 0; i &lt; LBfL; i++) {
411      LBfS += ((char *)LBf)[i];
412    }
413    return LBfS;
414  }
415  bool TFInOut::GetNextLnBf(TChA&amp; LnChA){
416    FailR(TStr::Fmt(&quot;TFInOut::GetNextLnBf: not implemented&quot;).CStr());
417    return false;
418  }
419  TStr TFInOut::GetFNm() const {
420    return GetSNm();
421  }
422  TShMIn::TShMIn(const TStr&amp; Str): TSBase(&quot;Input-Shared_Memory&quot;), 
423      TSIn(&quot;Input-Shared_Memory&quot;), TotalLength(0),
424      SizeLeft(0) {
425  #ifdef GLib_LINUX
426        TStr FNm = Str;
427        TFileId FileId;
428        int fd;
429        uint64 FLen;
430        EAssertR(!FNm.Empty(), &quot;Empty file-name.&quot;);
431        FileId=fopen(FNm.CStr(), &quot;rb&quot;);
432        fd = fileno(FileId);
433        EAssertR(FileId!=NULL, &quot;Can not open file &#x27;&quot;+FNm+&quot;&#x27;.&quot;);
434        EAssertR(
435            fseek(FileId, 0, SEEK_END)==0,
436            &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
437        FLen=(uint64)ftell(FileId);
438        EAssertR(
439            fseek(FileId, 0, SEEK_SET)==0,
440            &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
441        char *Mapped;
442        Mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
443        EAssertR(Mapped!=MAP_FAILED, &quot;mmap failed in TShMIn.&quot;);
444        OriginalBuffer = Mapped;
445        Cursor = OriginalBuffer;
446        SizeLeft = FLen;
447        TotalLength = FLen;
448        IsMemoryMapped = true;
449  #else
450        TExcept::Throw(&quot;TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n&quot;);
451  #endif
452      }
453  TShMIn::TShMIn(void* _Bf, const TSize&amp; _BfL): TSBase(&quot;Input-Shared_Memory&quot;), 
454    TSIn(&quot;Input-Shared_Memory&quot;), TotalLength(_BfL), SizeLeft(_BfL), IsMemoryMapped(false) {
455      OriginalBuffer = (char*)_Bf;
456      Cursor = (char*)_Bf;
457    }
458  void TShMIn::CloseMapping() {
459    if (OriginalBuffer!=NULL){
460      if (IsMemoryMapped) {
461  #ifdef GLib_LINUX
462        munmap(OriginalBuffer, TotalLength);
463        IsMemoryMapped = false;
464        OriginalBuffer = NULL;
465        Cursor = NULL;
466        TotalLength= 0;
467        SizeLeft = 0;
468  #endif
469      }
470    }
471  }
472  TMIn::TMIn(const void* _Bf, const uint64&amp; _BfL, const bool&amp; TakeBf):
473    TSBase(&quot;Input-Memory&quot;), TSIn(&quot;Input-Memory&quot;), Bf(NULL), BfC(0), BfL(_BfL), IsMemoryMapped(false){
474    if (TakeBf){
475      Bf=(char*)_Bf;
476    } else {
477      Bf=new char[static_cast&lt;size_t&gt;(BfL)]; memmove(Bf, _Bf, static_cast&lt;size_t&gt;(BfL));
478    }
479  }
480  TMIn::TMIn(TSIn&amp; SIn):
481    TSBase(&quot;Input-Memory&quot;), TSIn(&quot;Input-Memory&quot;), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
482    BfL=SIn.Len(); Bf=new char[static_cast&lt;size_t&gt;(BfL)];
483    for (uint64 BfC=0; BfC&lt;BfL; BfC++){Bf[BfC]=SIn.GetCh();}
484  }
485  TMIn::TMIn(const char* CStr):
486    TSBase(&quot;Input-Memory&quot;), TSIn(&quot;Input-Memory&quot;), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
487    BfL=uint64(strlen(CStr)); Bf=new char[static_cast&lt;size_t&gt;(BfL+1)]; strcpy(Bf, CStr);
488  }
489  TMIn::TMIn(const TStr&amp; Str, bool FromFile):
490    TSBase(&quot;Input-Memory&quot;), TSIn(&quot;Input-Memory&quot;), Bf(NULL), BfC(0), BfL(0){
491    if (FromFile == false) {
492      BfL=Str.Len(); Bf=new char[static_cast&lt;size_t&gt;(BfL)]; strncpy(Bf, Str.CStr(), static_cast&lt;size_t&gt;(BfL));
493      IsMemoryMapped = false;
494    }
495    else {
496  #ifdef GLib_LINUX
497      TStr FNm = Str;
498      TFileId FileId;
499      int fd;
500      uint64 FLen;
501      EAssertR(!FNm.Empty(), &quot;Empty file-name.&quot;);
502      FileId=fopen(FNm.CStr(), &quot;rb&quot;);
503      fd = fileno(FileId);
504      EAssertR(FileId!=NULL, &quot;Can not open file &#x27;&quot;+FNm+&quot;&#x27;.&quot;);
505      EAssertR(
506          fseek(FileId, 0, SEEK_END)==0,
507          &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
508      FLen=(uint64)ftell(FileId);
509      EAssertR(
510          fseek(FileId, 0, SEEK_SET)==0,
511          &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
512      char *mapped;
513      mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
514      IsMemoryMapped = true;
515      if (mapped == MAP_FAILED) {
516        printf(&quot;mmap failed: %d %s\n&quot;, fd, strerror (errno));
517        Bf = NULL;
518        BfC = BfL = 0;
519      }
520      else {
521        Bf = mapped;
522        BfC = 0;
523        BfL = FLen;
524      }
525      IsMemoryMapped = true;
526  #else
527      TExcept::Throw(&quot;TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n&quot;);
528  #endif
529    }
530  }
531  TMIn::TMIn(const TChA&amp; ChA):
532    TSBase(&quot;Input-Memory&quot;), TSIn(&quot;Input-Memory&quot;), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
533    BfL=ChA.Len(); Bf=new char[static_cast&lt;size_t&gt;(BfL)]; strncpy(Bf, ChA.CStr(), static_cast&lt;size_t&gt;(BfL));
534  }
535  PSIn TMIn::New(const void* _Bf, const uint64&amp; _BfL, const bool&amp; TakeBf){
536    return PSIn(new TMIn(_Bf, _BfL, TakeBf));
537  }
538  PSIn TMIn::New(const char* CStr){
539    return PSIn(new TMIn(CStr));
540  }
541  PSIn TMIn::New(const TStr&amp; Str){
542    return PSIn(new TMIn(Str));
543  }
544  PMIn TMIn::New(const TStr&amp; Str, bool FromFile){
545    return new TMIn(Str, FromFile);
546  }
547  PSIn TMIn::New(const TChA&amp; ChA){
548    return PSIn(new TMIn(ChA));
549  }
550  TMIn::~TMIn(){
551    if (Bf!=NULL){
552      if (IsMemoryMapped) {
553  #ifdef GLib_LINUX
554        munmap(Bf, BfL);
555  #endif
556      }
557      else {
558        delete[] Bf;
559      }
560    }
561  }
562  char TMIn::GetCh(){
563    EAssertR(BfC&lt;BfL, &quot;Reading beyond the end of stream.&quot;);
564    return Bf[BfC++];
565  }
566  char TMIn::PeekCh(){
567    EAssertR(BfC&lt;BfL, &quot;Reading beyond the end of stream.&quot;);
568    return Bf[BfC];
569  }
570  int TMIn::GetBf(const void* LBf, const TSize&amp; LBfL){
571    EAssertR(TSize(BfC+LBfL)&lt;=TSize(BfL), &quot;Reading beyond the end of stream.&quot;);
572    int LBfS=0;
573    for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
574      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
575    return LBfS;
576  }
577  int TMIn::FindEol(uint64&amp; BfN, bool&amp; CrEnd) {
578    char Ch;
579    if (BfC &gt;= BfL) {
580      if (Eof()) {
581        return -1;
582      }
583      if (CrEnd &amp;&amp; Bf[BfC]==&#x27;\n&#x27;) {
584        BfC++;
585        BfN = BfC-1;
586        return 1;
587      }
588    }
589    CrEnd = false;
590    while (BfC &lt; BfL) {
591      Ch = Bf[BfC++];
592      if (Ch==&#x27;\n&#x27;) {
593        BfN = BfC-1;
594        return 1;
595      }
596      if (Ch==&#x27;\r&#x27;) {
597        if (BfC == BfL) {
598          CrEnd = true;
599          BfN = BfC-1;
600          return 0;
601        } else if (Bf[BfC]==&#x27;\n&#x27;) {
602          BfC++;
603          BfN = BfC-2;
604          return 1;
605        }
606      }
607    }
608    BfN = BfC;
609    return 0;
610  }
611  bool TMIn::GetNextLnBf(TChA&amp; LnChA){
612    FailR(TStr::Fmt(&quot;TMIn::GetNextLnBf: not implemented&quot;).CStr());
613    return false;
614  }
615  uint64 TMIn::GetBfC() {
616    return BfC;
617  }
618  uint64 TMIn::GetBfL() {
619    return BfL;
620  }
621  void TMIn::SetBfC(uint64 Pos) {
622    BfC = Pos;
623  }
624  uint64 TMIn::CountNewLinesInRange(uint64 Lb, uint64 Ub) {
625    uint64 Cnt = 0;
626    if (Lb &gt;= BfL) {
627      return 0;
628    }
629    for (uint64 i = Lb; i &lt; Ub; i++) {
630      if (Bf[i] == &#x27;\n&#x27;) {
631        Cnt += 1;
632      }
633    }
634    return Cnt;
635  }
636  uint64 TMIn::GetLineStartPos(uint64 Ind) {
637    while (Ind &gt; 0 &amp;&amp; Bf[Ind-1] != &#x27;\n&#x27;) {
638      Ind--;
639    }
640    return Ind;
641  }
642  uint64 TMIn::GetLineEndPos(uint64 Ind) {
643    while (Ind &lt; BfL &amp;&amp; Bf[Ind] != &#x27;\n&#x27;) {
644      Ind++;
645    }
646    if (Ind == BfL) Ind--;
647    return Ind;
648  }
649  char* TMIn::GetLine(uint64 Index) {
650    return &amp;Bf[Index];
651  }
652  void TMIn::SkipCommentLines() {
653    while (BfC &lt; BfL &amp;&amp; TCh::IsHashCh(Bf[BfC])) {
654      while (BfC &lt; BfL &amp;&amp; Bf[BfC] != &#x27;\n&#x27;) {
655        BfC++;
656      }
657      BfC++;
658    }
659  }
660  void TMOut::Resize(const int&amp; ReqLen){
661    IAssert(OwnBf&amp;&amp;(BfL==MxBfL || ReqLen &gt;= 0));
662    if (Bf==NULL){
663      IAssert(MxBfL==0); 
664      if (ReqLen &lt; 0) Bf=new char[MxBfL=1024];
665      else Bf=new char[MxBfL=ReqLen];
666    } else {
667      if (ReqLen &lt; 0){ MxBfL*=2; }
668      else if (ReqLen &lt; MxBfL){ return; } 
669      else { MxBfL=(2*MxBfL &lt; ReqLen ? ReqLen : 2*MxBfL); }
670      char* NewBf=new char[MxBfL];
671      memmove(NewBf, Bf, BfL); delete[] Bf; Bf=NewBf;
672    }
673  }
674  TMOut::TMOut(const int&amp; _MxBfL):
675    TSBase(&quot;Output-Memory&quot;), TSOut(&quot;Output-Memory&quot;),
676    Bf(NULL), BfL(0), MxBfL(0), OwnBf(true){
677    MxBfL=_MxBfL&gt;0?_MxBfL:1024;
678    Bf=new char[MxBfL];
679  }
680  TMOut::TMOut(char* _Bf, const int&amp; _MxBfL):
681    TSBase(&quot;Output-Memory&quot;), TSOut(&quot;Output-Memory&quot;),
682    Bf(_Bf), BfL(0), MxBfL(_MxBfL), OwnBf(false){}
683  void TMOut::AppendBf(const void* LBf, const TSize&amp; LBfL) {
684    Resize(Len() + (int)LBfL);
685    memcpy(Bf + BfL, LBf, LBfL);
686    BfL += (int)LBfL;
687  }
688  int TMOut::PutBf(const void* LBf, const TSize&amp; LBfL){
689    int LBfS=0;
690    if (TSize(BfL+LBfL)&gt;TSize(MxBfL)){
691      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
692        LBfS+=PutCh(((char*)LBf)[LBfC]);}
693    } else {
694      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
695        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
696    }
697    return LBfS;
698  }
699  TStr TMOut::GetAsStr() const {
700    TChA ChA(BfL);
701    for (int BfC=0; BfC&lt;BfL; BfC++){ChA+=Bf[BfC];}
702    return ChA;
703  }
704  void TMOut::CutBf(const int&amp; CutBfL){
705    IAssert((0&lt;=CutBfL)&amp;&amp;(CutBfL&lt;=BfL));
706    if (CutBfL==BfL){BfL=0;}
707    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
708  }
709  PSIn TMOut::GetSIn(const bool&amp; IsCut, const int&amp; CutBfL){
710    IAssert((CutBfL==-1)||((0&lt;=CutBfL)));
711    int SInBfL= (CutBfL==-1) ? BfL : TInt::GetMn(BfL, CutBfL);
712    PSIn SIn;
713    if (OwnBf&amp;&amp;IsCut&amp;&amp;(SInBfL==BfL)){
714      SIn=PSIn(new TMIn(Bf, SInBfL, true));
715      Bf=NULL; BfL=MxBfL=0; OwnBf=true;
716    } else {
717      SIn=PSIn(new TMIn(Bf, SInBfL, false));
718      if (IsCut){CutBf(SInBfL);}
719    }
720    return SIn;
721  }
722  bool TMOut::IsCrLfLn() const {
723    for (int BfC=0; BfC&lt;BfL; BfC++){
724      if ((Bf[BfC]==TCh::CrCh)&amp;&amp;((BfC+1&lt;BfL)&amp;&amp;(Bf[BfC+1]==TCh::LfCh))){return true;}}
725    return false;
726  }
727  TStr TMOut::GetCrLfLn(){
728    IAssert(IsCrLfLn());
729    TChA Ln;
730    for (int BfC=0; BfC&lt;BfL; BfC++){
731      char Ch=Bf[BfC];
732      if ((Ch==TCh::CrCh)&amp;&amp;((BfC+1&lt;BfL)&amp;&amp;(Bf[BfC+1]==TCh::LfCh))){
733        Ln+=TCh::CrCh; Ln+=TCh::LfCh; CutBf(BfC+1+1); break;
734      } else {
735        Ln+=Ch;
736      }
737    }
738    return Ln;
739  }
740  bool TMOut::IsEolnLn() const {
741    for (int BfC=0; BfC&lt;BfL; BfC++){
742      if ((Bf[BfC]==TCh::CrCh)||(Bf[BfC]==TCh::LfCh)){return true;}
743    }
744    return false;
745  }
746  TStr TMOut::GetEolnLn(const bool&amp; DoAddEoln, const bool&amp; DoCutBf){
747    IAssert(IsEolnLn());
748    int LnChs=0; TChA Ln;
749    for (int BfC=0; BfC&lt;BfL; BfC++){
750      char Ch=Bf[BfC];
751      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
752        LnChs++; if (DoAddEoln){Ln+=Ch;}
753        if (BfC+1&lt;BfL){
754          char NextCh=Bf[BfC+1];
755          if (((Ch==TCh::CrCh)&amp;&amp;(NextCh==TCh::LfCh))||
756           ((Ch==TCh::LfCh)&amp;&amp;(NextCh==TCh::CrCh))){
757            LnChs++; if (DoAddEoln){Ln+=NextCh;}
758          }
759        }
760        break;
761      } else {
762        LnChs++; Ln+=Ch;
763      }
764    }
765    if (DoCutBf){
766      CutBf(LnChs);
767    }
768    return Ln;
769  }
770  void TMOut::MkEolnLn(){
771    if (!IsEolnLn()){
772      PutCh(TCh::CrCh); PutCh(TCh::LfCh);}
773  }
774  bool TLnRet::NextLn(TStr&amp; LnStr) {
775      if (SIn-&gt;Eof()) { return false; }
776      TChA LnChA; char Ch = TCh::EofCh;
777      while (!SIn-&gt;Eof() &amp;&amp; ((Ch=SIn-&gt;GetCh())!=&#x27;\n&#x27;)) {
778          if (Ch != &#x27;\r&#x27;) { LnChA += Ch; }
779      }
780      LnStr = LnChA; return true;
781  }
782  #ifndef SEEK_SET
783  #define SEEK_CUR    1
784  #define SEEK_END    2
785  #define SEEK_SET    0
786  #endif
787  void TFRnd::RefreshFPos(){
788    EAssertR(
789     fseek(FileId, 0, SEEK_CUR)==0,
790     &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
791  }
792  TFRnd::TFRnd(const TStr&amp; _FNm, const TFAccess&amp; FAccess,
793   const bool&amp; CreateIfNo, const int&amp; _HdLen, const int&amp; _RecLen):
794    FileId(NULL), FNm(_FNm.CStr()),
795    RecAct(false), HdLen(_HdLen), RecLen(_RecLen){
796    RecAct=(HdLen&gt;=0)&amp;&amp;(RecLen&gt;0);
797    switch (FAccess){
798      case faCreate: FileId=fopen(FNm.CStr(), &quot;w+b&quot;); break;
799      case faUpdate: FileId=fopen(FNm.CStr(), &quot;r+b&quot;); break;
800      case faAppend: FileId=fopen(FNm.CStr(), &quot;r+b&quot;);
801        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
802      case faRdOnly: FileId=fopen(FNm.CStr(), &quot;rb&quot;); break;
803      default: Fail;
804    }
805    if ((FileId==NULL)&amp;&amp;(CreateIfNo)){
806      FileId=fopen(FNm.CStr(), &quot;w+b&quot;);}
807    EAssertR(FileId!=NULL, &quot;Can not open file &#x27;&quot;+_FNm+&quot;&#x27;.&quot;);
808  }
809  TFRnd::~TFRnd(){
810    EAssertR(fclose(FileId)==0, &quot;Can not close file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
811  }
812  TStr TFRnd::GetFNm() const {
813    return FNm.CStr();
814  }
815  void TFRnd::SetFPos(const int&amp; FPos){
816    EAssertR(
817     fseek(FileId, FPos, SEEK_SET)==0,
818     &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
819  }
820  void TFRnd::MoveFPos(const int&amp; DFPos){
821    EAssertR(
822     fseek(FileId, DFPos, SEEK_CUR)==0,
823     &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
824  }
825  int TFRnd::GetFPos(){
826    int FPos= (int) ftell(FileId);
827    EAssertR(FPos!=-1, &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
828    return FPos;
829  }
830  int TFRnd::GetFLen(){
831    int FPos=GetFPos();
832    EAssertR(
833     fseek(FileId, 0, SEEK_END)==0,
834     &quot;Error seeking into file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
835    int FLen=GetFPos(); SetFPos(FPos); return FLen;
836  }
837  void TFRnd::SetRecN(const int&amp; RecN){
838    IAssert(RecAct);
839    SetFPos(HdLen+RecN*RecLen);
840  }
841  int TFRnd::GetRecN(){
842    IAssert(RecAct);
843    int FPos=GetFPos()-HdLen;
844    EAssertR(FPos%RecLen==0, &quot;Invalid position in file&#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
845    return FPos/RecLen;
846  }
847  int TFRnd::GetRecs(){
848    IAssert(RecAct);
849    int FLen=GetFLen()-HdLen;
850    EAssertR(FLen%RecLen==0, &quot;Invalid length of file&#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
851    return FLen/RecLen;
852  }
853  void TFRnd::GetBf(void* Bf, const TSize&amp; BfL){
854    RefreshFPos();
855    EAssertR(
856     fread(Bf, 1, BfL, FileId)==BfL,
857     &quot;Error reading file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
858  }
859  void TFRnd::PutBf(const void* Bf, const TSize&amp; BfL){
860    RefreshFPos();
861    EAssertR(
862     fwrite(Bf, 1, BfL, FileId)==BfL,
863     &quot;Error writting to the file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
864  }
865  void TFRnd::Flush(){
866    EAssertR(fflush(FileId)==0, &quot;Can not flush file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
867  }
868  void TFRnd::PutCh(const char&amp; Ch, const int&amp; Chs){
869    if (Chs&gt;0){
870      char* CStr=new char[Chs];
871      for (int ChN=0; ChN&lt;Chs; ChN++){CStr[ChN]=Ch;}
872      PutBf(CStr, Chs);
873      delete[] CStr;
874    }
875  }
876  void TFRnd::PutStr(const TStr&amp; Str){
877    PutBf(Str.CStr(), Str.Len()+1);
878  }
879  TStr TFRnd::GetStr(const int&amp; StrLen, bool&amp; IsOk){
880    IsOk=false; TStr Str;
881    if (GetFPos()+StrLen+1&lt;=GetFLen()){
882      char* CStr=new char[StrLen+1];
883      GetBf(CStr, StrLen+1);
884      if (CStr[StrLen+1-1]==TCh::NullCh){IsOk=true; Str=CStr;}
885      delete[] CStr;
886    }
887    return Str;
888  }
889  TStr TFRnd::GetStr(const int&amp; StrLen){
890    TStr Str;
891    char* CStr=new char[StrLen+1];
892    GetBf(CStr, StrLen+1);
893    EAssertR(CStr[StrLen+1-1]==TCh::NullCh, &quot;Error reading file &#x27;&quot;+TStr(FNm)+&quot;&#x27;.&quot;);
894    Str=CStr;
895    delete[] CStr;
896    return Str;
897  }
898  void TFRnd::PutSIn(const PSIn&amp; SIn, TCs&amp; Cs){
899    int BfL=SIn-&gt;Len();
900    char* Bf=new char[BfL];
901    SIn-&gt;GetBf(Bf, BfL);
902    Cs=TCs::GetCsFromBf(Bf, BfL);
903    PutBf(Bf, BfL);
904    delete[] Bf;
905  }
906  PSIn TFRnd::GetSIn(const int&amp; BfL, TCs&amp; Cs){
907    char* Bf=new char[BfL];
908    GetBf(Bf, BfL);
909    Cs=TCs::GetCsFromBf(Bf, BfL);
910    PSIn SIn=PSIn(new TMIn(Bf, BfL, true));
911    return SIn;
912  }
913  TStr TFRnd::GetStrFromFAccess(const TFAccess&amp; FAccess){
914    switch (FAccess){
915      case faCreate: return &quot;Create&quot;;
916      case faUpdate: return &quot;Update&quot;;
917      case faAppend: return &quot;Append&quot;;
918      case faRdOnly: return &quot;ReadOnly&quot;;
919      case faRestore: return &quot;Restore&quot;;
920      default: Fail; return TStr();
921    }
922  }
923  TFAccess TFRnd::GetFAccessFromStr(const TStr&amp; Str){
924    TStr UcStr=Str.GetUc();
925    if (UcStr==&quot;CREATE&quot;){return faCreate;}
926    if (UcStr==&quot;UPDATE&quot;){return faUpdate;}
927    if (UcStr==&quot;APPEND&quot;){return faAppend;}
928    if (UcStr==&quot;READONLY&quot;){return faRdOnly;}
929    if (UcStr==&quot;RESTORE&quot;){return faRestore;}
930    if (UcStr==&quot;NEW&quot;){return faCreate;}
931    if (UcStr==&quot;CONT&quot;){return faUpdate;}
932    if (UcStr==&quot;CONTINUE&quot;){return faUpdate;}
933    if (UcStr==&quot;REST&quot;){return faRestore;}
934    if (UcStr==&quot;RESTORE&quot;){return faRestore;}
935    return faUndef;
936  }
937  const TStr TFile::TxtFExt=&quot;.Txt&quot;;
938  const TStr TFile::HtmlFExt=&quot;.Html&quot;;
939  const TStr TFile::HtmFExt=&quot;.Htm&quot;;
940  const TStr TFile::GifFExt=&quot;.Gif&quot;;
941  const TStr TFile::JarFExt=&quot;.Jar&quot;;
942  bool TFile::Exists(const TStr&amp; FNm){
943    if (FNm.Empty()) { return false; }
944    bool DoExists;
945    TFIn FIn(FNm, DoExists);
946    return DoExists;
947  }
948  #if defined(GLib_WIN32)
949  void TFile::Copy(const TStr&amp; SrcFNm, const TStr&amp; DstFNm, 
950   const bool&amp; ThrowExceptP, const bool&amp; FailIfExistsP){
951    if (ThrowExceptP){
952      if (CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP) == 0) {
953          int ErrorCode = (int)GetLastError();
954          TExcept::Throw(TStr::Fmt(
955              &quot;Error %d copying file &#x27;%s&#x27; to &#x27;%s&#x27;.&quot;, 
956              ErrorCode, SrcFNm.CStr(), DstFNm.CStr()));
957      }
958    } else {
959      CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP);
960    }
961  }
962  #elif defined(GLib_LINUX)
963  void TFile::Copy(const TStr&amp; SrcFNm, const TStr&amp; DstFNm,
964   const bool&amp; ThrowExceptP, const bool&amp; FailIfExistsP){
965  	int input, output;
966  	size_t filesize;
967  	void *source, *target;
968  	if( (input = open(SrcFNm.CStr(), O_RDONLY)) == -1) {
969  		if (ThrowExceptP) {
970  			TExcept::Throw(TStr::Fmt(
971  			            &quot;Error copying file &#x27;%s&#x27; to &#x27;%s&#x27;: cannot open source file for reading.&quot;,
972  			            SrcFNm.CStr(), DstFNm.CStr()));
973  		} else {
974  			return;
975  		}
976  	}
977  	if( (output = open(DstFNm.CStr(), O_RDWR | O_CREAT | O_TRUNC, 0666)) == -1)	{
978  		close(input);
979  		if (ThrowExceptP) {
980  			TExcept::Throw(TStr::Fmt(
981  			            &quot;Error copying file &#x27;%s&#x27; to &#x27;%s&#x27;: cannot open destination file for writing.&quot;,
982  			            SrcFNm.CStr(), DstFNm.CStr()));
983  		} else {
984  			return;
985  		}
986  	}
987  	filesize = lseek(input, 0, SEEK_END);
988  	lseek(output, filesize - 1, SEEK_SET);
989  	write(output, &#x27;\0&#x27;, 1);
990  	if((source = mmap(0, filesize, PROT_READ, MAP_SHARED, input, 0)) == (void *) -1) {
991  		close(input);
992  		close(output);
993  		if (ThrowExceptP) {
994  			TExcept::Throw(TStr::Fmt(
995  						&quot;Error copying file &#x27;%s&#x27; to &#x27;%s&#x27;: cannot mmap input file.&quot;,
996  						SrcFNm.CStr(), DstFNm.CStr()));
997  		} else {
998  			return;
999  		}
1000  	}
1001  	if((target = mmap(0, filesize, PROT_WRITE, MAP_SHARED, output, 0)) == (void *) -1) {
1002  		munmap(source, filesize);
1003  		close(input);
1004  		close(output);
1005  		if (ThrowExceptP) {
1006  			TExcept::Throw(TStr::Fmt(
1007  						&quot;Error copying file &#x27;%s&#x27; to &#x27;%s&#x27;: cannot mmap output file.&quot;,
1008  						SrcFNm.CStr(), DstFNm.CStr()));
1009  		} else {
1010  			return;
1011  		}
1012  	}
1013  	memcpy(target, source, filesize);
1014  	munmap(source, filesize);
1015  	munmap(target, filesize);
1016  	close(input);
1017  	close(output);
1018  }
1019  #endif
1020  void TFile::Del(const TStr&amp; FNm, const bool&amp; ThrowExceptP){
1021    if (ThrowExceptP){
1022      EAssertR(
1023       remove(FNm.CStr())==0,
1024       &quot;Error removing file &#x27;&quot;+FNm+&quot;&#x27;.&quot;);
1025    } else {
1026      remove(FNm.CStr());
1027    }
1028  }
1029  void TFile::DelWc(const TStr&amp; WcStr, const bool&amp; RecurseDirP){
1030    TStrV FNmV;
1031    TFFile FFile(WcStr, RecurseDirP); TStr FNm;
1032    while (FFile.Next(FNm)){
1033      FNmV.Add(FNm);}
1034    for (int FNmN=0; FNmN&lt;FNmV.Len(); FNmN++){
1035      Del(FNmV[FNmN], false);}
1036  }
1037  void TFile::Rename(const TStr&amp; SrcFNm, const TStr&amp; DstFNm){
1038    EAssertR(
1039     rename(SrcFNm.CStr(), DstFNm.CStr())==0,
1040     &quot;Error renaming file &#x27;&quot;+SrcFNm+&quot;&#x27; to &quot;+DstFNm+&quot;&#x27;.&quot;);
1041  }
1042  TStr TFile::GetUniqueFNm(const TStr&amp; FNm){
1043    int Cnt=1; int ch;
1044    TStr NewFNm; TStr TmpFNm=FNm;
1045    if (FNm.SearchCh(&#x27;#&#x27;) == -1) {
1046      for (ch = FNm.Len()-1; ch &gt;= 0; ch--) if (FNm[ch] == &#x27;.&#x27;) break;
1047      if (ch != -1) TmpFNm.InsStr(ch, &quot;.#&quot;);
1048      else TmpFNm += &quot;.#&quot;;
1049    }
1050    forever{
1051      NewFNm=TmpFNm;
1052      NewFNm.ChangeStr(&quot;#&quot;, TStr::Fmt(&quot;%03d&quot;, Cnt)); Cnt++;
1053      if (!TFile::Exists(NewFNm)){break;}
1054    }
1055    return NewFNm;
1056  }
1057  #ifdef GLib_WIN
1058  uint64 TFile::GetSize(const TStr&amp; FNm) {
1059      HANDLE hFile = CreateFile(
1060         FNm.CStr(),            
1061         GENERIC_READ,          
1062         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1063         NULL,                  
1064         OPEN_EXISTING,         
1065         FILE_ATTRIBUTE_NORMAL, 
1066         NULL);                 
1067      if (hFile == INVALID_HANDLE_VALUE) {
1068          TExcept::Throw(&quot;Can not open file &quot; + FNm + &quot;!&quot;); }
1069      LARGE_INTEGER lpFileSizeHigh;
1070  	if (!GetFileSizeEx(hFile, &amp;lpFileSizeHigh)) {
1071          TExcept::Throw(&quot;Can not read size of file &quot; + FNm + &quot;!&quot;); }
1072      CloseHandle(hFile);
1073  	return uint64(lpFileSizeHigh.QuadPart);
1074  }
1075  uint64 TFile::GetCreateTm(const TStr&amp; FNm) {
1076      HANDLE hFile = CreateFile(
1077         FNm.CStr(),            
1078         GENERIC_READ,          
1079         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1080         NULL,                  
1081         OPEN_EXISTING,         
1082         FILE_ATTRIBUTE_NORMAL, 
1083         NULL);                 
1084      if (hFile == INVALID_HANDLE_VALUE) {
1085          TExcept::Throw(&quot;Can not open file &quot; + FNm + &quot;!&quot;); }
1086      FILETIME lpCreationTime;
1087      if (!GetFileTime(hFile, &amp;lpCreationTime, NULL, NULL)) {
1088          TExcept::Throw(&quot;Can not read time from file &quot; + FNm + &quot;!&quot;); }
1089      CloseHandle(hFile);
1090      TUInt64 UInt64(uint(lpCreationTime.dwHighDateTime), 
1091          uint(lpCreationTime.dwLowDateTime));
1092      return UInt64.Val / uint64(10000);
1093  }
1094  uint64 TFile::GetLastAccessTm(const TStr&amp; FNm) {
1095      HANDLE hFile = CreateFile(
1096         FNm.CStr(),            
1097         GENERIC_READ,          
1098         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1099         NULL,                  
1100         OPEN_EXISTING,         
1101         FILE_ATTRIBUTE_NORMAL, 
1102         NULL);                 
1103      if (hFile == INVALID_HANDLE_VALUE) {
1104          TExcept::Throw(&quot;Can not open file &quot; + FNm + &quot;!&quot;); }
1105      FILETIME lpLastAccessTime;
1106      if (!GetFileTime(hFile, NULL, &amp;lpLastAccessTime, NULL)) {
1107          TExcept::Throw(&quot;Can not read time from file &quot; + FNm + &quot;!&quot;); }
1108      CloseHandle(hFile);
1109      TUInt64 UInt64(uint(lpLastAccessTime.dwHighDateTime), 
1110          uint(lpLastAccessTime.dwLowDateTime));
1111      return UInt64.Val / uint64(10000);
1112  }
1113  uint64 TFile::GetLastWriteTm(const TStr&amp; FNm) {
1114      HANDLE hFile = CreateFile(
1115         FNm.CStr(),            
1116         GENERIC_READ,          
1117         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1118         NULL,                  
1119         OPEN_EXISTING,         
1120         FILE_ATTRIBUTE_NORMAL, 
1121         NULL);                 
1122      if (hFile == INVALID_HANDLE_VALUE) {
1123          TExcept::Throw(&quot;Can not open file &quot; + FNm + &quot;!&quot;); }
1124      FILETIME lpLastWriteTime;
1125      if (!GetFileTime(hFile, NULL, NULL, &amp;lpLastWriteTime)) {
1126          TExcept::Throw(&quot;Can not read time from file &quot; + FNm + &quot;!&quot;); }
1127      CloseHandle(hFile);
1128      TUInt64 UInt64(uint(lpLastWriteTime.dwHighDateTime), 
1129          uint(lpLastWriteTime.dwLowDateTime));
1130      return UInt64.Val / uint64(10000);
1131  }
1132  #elif defined(GLib_LINUX)
1133  uint64 TFile::GetSize(const TStr&amp; FNm) {
1134  	Fail; return 0;
1135  }
1136  uint64 TFile::GetCreateTm(const TStr&amp; FNm) {
1137  	return GetLastWriteTm(FNm);
1138  }
1139  uint64 TFile::GetLastWriteTm(const TStr&amp; FNm) {
1140  	struct stat st;
1141  	if (stat(FNm.CStr(), &amp;st) != 0) {
1142  		TExcept::Throw(&quot;Cannot read tile from file &quot; + FNm + &quot;!&quot;);
1143  	}
1144  	return uint64(st.st_mtime);
1145  }
1146  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-zipfl.cpp</h3>
            <pre><code>1  #if defined(GLib_WIN)
2    TStr TZipIn::SevenZipPath = &quot;C:\\7Zip&quot;;
3  #elif defined(GLib_CYGWIN)
4    TStr TZipIn::SevenZipPath = &quot;/usr/bin&quot;;
5  #elif defined(GLib_MACOSX) 
6    TStr TZipIn::SevenZipPath = &quot;/usr/local/bin&quot;;
7  #else 
8    TStr TZipIn::SevenZipPath = &quot;/usr/bin&quot;;
9  #endif
10  TStrStrH TZipIn::FExtToCmdH;
11  const int TZipIn::MxBfL=32*1024;
12  void TZipIn::CreateZipProcess(const TStr&amp; Cmd, const TStr&amp; ZipFNm) {
13    const TStr CmdLine = TStr::Fmt(&quot;%s %s&quot;, Cmd.CStr(), ZipFNm.CStr());
14    #ifdef GLib_WIN
15    PROCESS_INFORMATION piProcInfo;
16    STARTUPINFO siStartInfo;
17    ZeroMemory( &amp;piProcInfo, sizeof(PROCESS_INFORMATION));
18    ZeroMemory( &amp;siStartInfo, sizeof(STARTUPINFO));
19    siStartInfo.cb = sizeof(STARTUPINFO);
20    siStartInfo.hStdOutput = ZipStdoutWr;
21    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
22    const BOOL FuncRetn = CreateProcess(NULL,
23      (LPSTR) CmdLine.CStr(),  
24      NULL,          
25      NULL,          
26      TRUE,          
27      0,             
28      NULL,          
29      NULL,          
30      &amp;siStartInfo,  
31      &amp;piProcInfo);  
32    EAssertR(FuncRetn!=0, TStr::Fmt(&quot;Can not execute &#x27;%s&#x27; (Set the TZipIn::SevenZipPath)&quot;, CmdLine.CStr()).CStr());
33    CloseHandle(piProcInfo.hProcess);
34    CloseHandle(piProcInfo.hThread);
35    #else
36    ZipStdoutRd = popen((TZipIn::SevenZipPath+&quot;/&quot;+CmdLine).CStr(), &quot;r&quot;);
37    EAssertR(ZipStdoutRd,  TStr::Fmt(&quot;Can not execute &#x27;%s&#x27; (Set the TZipIn::SevenZipPath)&quot;, CmdLine.CStr()).CStr());
38    #endif
39  }
40  void TZipIn::FillBf(){
41    EAssertR(CurFPos &lt; FLen, TStr::Fmt(&quot;End of file &#x27;%s&#x27; reached (CurFPos=%s, FLen=%s).&quot;, GetSNm().CStr(), TUInt64(CurFPos).GetStr().CStr(), TUInt64(FLen).GetStr().CStr()));
42    EAssertR((BfC==BfL)&amp;bsol;*&amp;&amp;((BfL==-1)||(BfL==MxBfL))*/, &quot;Error reading file &#x27;&quot;+GetSNm()+&quot;&#x27; (Set the TZipIn::SevenZipPath).&quot;);
43    #ifdef GLib_WIN
44    DWORD BytesRead;
45    EAssert(ReadFile(ZipStdoutRd, Bf, MxBfL, &amp;BytesRead, NULL) != 0);
46    #else
47    size_t BytesRead = fread(Bf, 1, MxBfL, ZipStdoutRd);
48    EAssert(BytesRead != 0);
49    #endif
50    BfL = (int) BytesRead;
51    CurFPos += BytesRead;
52    EAssertR((BfC!=0)||(BfL!=0), &quot;Error reading file &#x27;&quot;+GetSNm()+&quot;&#x27; (Set the TZipIn::SevenZipPath).&quot;);
53    BfC = 0;
54  }
55  TZipIn::TZipIn(const TStr&amp; FNm) : TSBase(FNm.CStr()), TSIn(FNm), ZipStdoutRd(NULL), ZipStdoutWr(NULL),
56    FLen(0), CurFPos(0), Bf(NULL), BfC(0), BfL(0) {
57    EAssertR(! FNm.Empty(), &quot;Empty file-name.&quot;);
58    EAssertR(TFile::Exists(FNm), TStr::Fmt(&quot;File %s does not exist&quot;, FNm.CStr()).CStr());
59    FLen = 0;
60    if (! IsZipFNm(FNm)) {
61      printf(&quot;*** Error: file %s, compression format %s not supported\n&quot;, FNm.CStr(), FNm.GetFExt().CStr());
62      EFailR(TStr::Fmt(&quot;File %s: compression format %s not supported&quot;, FNm.CStr(), FNm.GetFExt().CStr()).CStr());
63    }
64    FLen = TZipIn::GetFLen(FNm);
65    if (FLen == 0) { return; } 
66    #ifdef GLib_WIN
67    SECURITY_ATTRIBUTES saAttr;
68    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
69    saAttr.bInheritHandle = TRUE;
70    saAttr.lpSecurityDescriptor = NULL;
71    const int PipeBufferSz = 32*1024;
72    EAssertR(CreatePipe(&amp;ZipStdoutRd, &amp;ZipStdoutWr, &amp;saAttr, PipeBufferSz), &quot;Stdout pipe creation failed&quot;);
73    SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
74    #else
75    #endif
76    CreateZipProcess(GetCmd(FNm), FNm);
77    Bf = new char[MxBfL]; BfC = BfL=-1;
78    FillBf();
79  }
80  TZipIn::TZipIn(const TStr&amp; FNm, bool&amp; OpenedP) : TSBase(FNm.CStr()), TSIn(FNm), ZipStdoutRd(NULL), ZipStdoutWr(NULL),
81    FLen(0), CurFPos(0), Bf(NULL), BfC(0), BfL(0) {
82    EAssertR(! FNm.Empty(), &quot;Empty file-name.&quot;);
83    FLen = TZipIn::GetFLen(FNm);
84    OpenedP = TFile::Exists(FNm);
85    if (OpenedP) {
86      #ifdef GLib_WIN
87      SECURITY_ATTRIBUTES saAttr;
88      saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
89      saAttr.bInheritHandle = TRUE;
90      saAttr.lpSecurityDescriptor = NULL;
91      EAssertR(CreatePipe(&amp;ZipStdoutRd, &amp;ZipStdoutWr, &amp;saAttr, 0), &quot;Stdout pipe creation failed&quot;);
92      SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
93      #else
94      #endif
95      CreateZipProcess(GetCmd(FNm.GetFExt()), FNm);
96      Bf = new char[MxBfL]; BfC = BfL=-1;
97      FillBf();
98    }
99  }
100  PSIn TZipIn::New(const TStr&amp; FNm) {
101    return PSIn(new TZipIn(FNm));
102  }
<span onclick='openModal()' class='match'>103  PSIn TZipIn::New(const TStr&amp; FNm, bool&amp; OpenedP){
104    return PSIn(new TZipIn(FNm, OpenedP));
</span>105  }
106  TZipIn::~TZipIn(){
107    #ifdef GLib_WIN
108    if (ZipStdoutRd != NULL) {
109      EAssertR(CloseHandle(ZipStdoutRd), &quot;Closing read-end of pipe failed&quot;); }
110    if (ZipStdoutWr != NULL) {
111      EAssertR(CloseHandle(ZipStdoutWr)!=0, &quot;Closing write-end of pipe failed&quot;); }
112    #else
113    if (ZipStdoutRd != NULL) {
114      EAssertR(pclose(ZipStdoutRd) != -1, &quot;Closing of the process failed&quot;); }
115    #endif
116    if (Bf != NULL) { delete[] Bf; }
117  }
118  int TZipIn::GetBf(const void* LBf, const TSize&amp; LBfL){
119    int LBfS=0;
120    if (TSize(BfC+LBfL)&gt;TSize(BfL)){
121      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
122        if (BfC==BfL){FillBf();}
123        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
124    } else {
125      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
126        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
127    }
128    return LBfS;
129  }
130  bool TZipIn::GetNextLnBf(TChA&amp; LnChA) {
131    int Status;
132    int BfN;        
133    int BfP;        
134    LnChA.Clr();
135    do {
136      if (BfC &gt;= BfL) { BfP = 0; } 
137      else { BfP = BfC; }
138      Status = FindEol(BfN);
139      if (Status &gt;= 0) {
140        LnChA.AddBf(&amp;Bf[BfP],BfN-BfP);
141        if (Status == 1) { return true; } 
142      }
143    } while (Status == 0);
144    return !LnChA.Empty();
145  }
146  int TZipIn::FindEol(int&amp; BfN) {
147    char Ch;
148    if (BfC &gt;= BfL) { 
149      if (Eof()) { return -1; }
150      FillBf();
151    }
152    while (BfC &lt; BfL) {
153      Ch = Bf[BfC++];
154      if (Ch==&#x27;\n&#x27;) { BfN = BfC-1; return 1; }
155      if (Ch==&#x27;\r&#x27; &amp;&amp; Bf[BfC+1]==&#x27;\n&#x27;) {
156        BfC++;  BfN = BfC-2;  return 1; }
157    }
158    BfN = BfC;
159    return 0;
160  }
161  bool TZipIn::IsZipExt(const TStr&amp; FNmExt) {
162    if (FExtToCmdH.Empty()) FillFExtToCmdH();
163    return FExtToCmdH.IsKey(FNmExt);
164  }
165  void TZipIn::FillFExtToCmdH() {
166    #ifdef GLib_WIN
167    const char* ZipCmd = &quot;7z.exe e -y -bd -so&quot;;
168    #else
169    const char* ZipCmd = &quot;7za e -y -bd -so&quot;;
170    #endif
171    if (FExtToCmdH.Empty()) {
172      FExtToCmdH.AddDat(&quot;.gz&quot;,  ZipCmd);
173      FExtToCmdH.AddDat(&quot;.7z&quot;,  ZipCmd);
174      FExtToCmdH.AddDat(&quot;.rar&quot;, ZipCmd);
175      FExtToCmdH.AddDat(&quot;.zip&quot;, ZipCmd);
176      FExtToCmdH.AddDat(&quot;.cab&quot;, ZipCmd);
177      FExtToCmdH.AddDat(&quot;.arj&quot;, ZipCmd);
178      FExtToCmdH.AddDat(&quot;.bzip2&quot;, ZipCmd);
179      FExtToCmdH.AddDat(&quot;.bz2&quot;, ZipCmd);
180    }
181  }
182  TStr TZipIn::GetCmd(const TStr&amp; ZipFNm) {
183    if (FExtToCmdH.Empty()) FillFExtToCmdH();
184    const TStr Ext = ZipFNm.GetFExt().GetLc();
185    EAssertR(FExtToCmdH.IsKey(Ext), TStr::Fmt(&quot;Unsupported file extension &#x27;%s&#x27;&quot;, Ext.CStr()));
186    return FExtToCmdH.GetDat(Ext);
187  }
188  uint64 TZipIn::GetFLen(const TStr&amp; ZipFNm) {
189    #ifdef GLib_WIN
190    HANDLE ZipStdoutRd, ZipStdoutWr;
191    SECURITY_ATTRIBUTES saAttr;
192    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
193    saAttr.bInheritHandle = TRUE;
194    saAttr.lpSecurityDescriptor = NULL;
195    const int PipeBufferSz = 32*1024;
196    EAssertR(CreatePipe(&amp;ZipStdoutRd, &amp;ZipStdoutWr, &amp;saAttr, PipeBufferSz), &quot;Stdout pipe creation failed&quot;);
197    SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
198    { const TStr CmdLine = TStr::Fmt(&quot;7z.exe l %s&quot;, ZipFNm.CStr());
199    PROCESS_INFORMATION piProcInfo;
200    STARTUPINFO siStartInfo;
201    ZeroMemory( &amp;piProcInfo, sizeof(PROCESS_INFORMATION));
202    ZeroMemory( &amp;siStartInfo, sizeof(STARTUPINFO));
203    siStartInfo.cb = sizeof(STARTUPINFO);
204    siStartInfo.hStdOutput = ZipStdoutWr;
205    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
206    const BOOL FuncRetn = CreateProcess(NULL, (LPSTR) CmdLine.CStr(),
207      NULL, NULL, TRUE, 0, NULL, NULL, &amp;siStartInfo, &amp;piProcInfo);
208    EAssertR(FuncRetn!=0, TStr::Fmt(&quot;Can not execute &#x27;%s&#x27; (Set the TZipIn::SevenZipPath)&quot;, CmdLine.CStr()).CStr());
209    CloseHandle(piProcInfo.hProcess);
210    CloseHandle(piProcInfo.hThread); }
211    #else
212    const TStr CmdLine = TStr::Fmt(&quot;7za l %s&quot;, ZipFNm.CStr());
213    FILE* ZipStdoutRd = popen((TZipIn::SevenZipPath+&quot;/&quot;+CmdLine).CStr(), &quot;r&quot;);
214    EAssertR(ZipStdoutRd, TStr::Fmt(&quot;Can not execute &#x27;%s/%s&#x27; (Set the TZipIn::SevenZipPath)&quot;, TZipIn::SevenZipPath.CStr(), CmdLine.CStr()).CStr());
215    #endif
216    const int BfSz = 32*1024;
217    char* Bf = new char [BfSz];
218    int BfC=0, BfL=0;
219    memset(Bf, 0, BfSz);
220    #ifdef GLib_WIN
221    DWORD BytesRead;
222    EAssert(ReadFile(ZipStdoutRd, Bf, MxBfL, &amp;BytesRead, NULL) != 0);
223    #else
224    size_t BytesRead = fread(Bf, 1, MxBfL, ZipStdoutRd);
225    EAssert(BytesRead != 0);
226    EAssert(pclose(ZipStdoutRd) != -1);
227    #endif
228    BfL = (int) BytesRead;  IAssert((BfC!=0)||(BfL!=0));
229    BfC = 0; Bf[BfL] = 0;
230    TStr Str(Bf);  delete [] Bf;
231    TStrV StrV; Str.SplitOnWs(StrV);
232    int n = StrV.Len()-1;
233    while (n &gt; 0 &amp;&amp; ! StrV[n].IsPrefix(&quot;-----&quot;)) { n--; }
234    if (n-7 &lt;= 0) {
235      WrNotify(TStr::Fmt(&quot;Corrupt file %s: MESSAGE:\n&quot;, ZipFNm.CStr()).CStr(), Str.CStr());
236      SaveToErrLog(TStr::Fmt(&quot;Corrupt file %s. Message:\n:%s\n&quot;, ZipFNm.CStr(), Str.CStr()).CStr());
237      return 0;
238    }
239    return StrV[n-7].GetInt64();
240  }
241  TStrStrH TZipOut::FExtToCmdH;
242  const TSize TZipOut::MxBfL=4*1024;
243  void TZipOut::FlushBf() {
244    #ifdef GLib_WIN
245    DWORD BytesOut;
246    EAssertR(WriteFile(ZipStdinWr, Bf, DWORD(BfL), &amp;BytesOut, NULL)!=0, &quot;Error writting to the file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
247    #else
248    size_t BytesOut = fwrite(Bf, 1, BfL, ZipStdinWr);
249    #endif
250    EAssert(BytesOut == BfL);
251    BfL = 0;
252  }
253  void TZipOut::CreateZipProcess(const TStr&amp; Cmd, const TStr&amp; ZipFNm) {
254    const TStr CmdLine = TStr::Fmt(&quot;%s %s&quot;, Cmd.CStr(), ZipFNm.CStr());
255    #ifdef GLib_WIN
256    PROCESS_INFORMATION piProcInfo;
257    STARTUPINFO siStartInfo;
258    ZeroMemory( &amp;piProcInfo, sizeof(PROCESS_INFORMATION));
259    ZeroMemory( &amp;siStartInfo, sizeof(STARTUPINFO));
260    siStartInfo.cb = sizeof(STARTUPINFO);
261    siStartInfo.hStdInput = ZipStdinRd;
262    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
263    const BOOL FuncRetn = CreateProcess(NULL,
264      (LPSTR) CmdLine.CStr(),  
265      NULL,          
266      NULL,          
267      TRUE,          
268      0,             
269      NULL,          
270      NULL,          
271      &amp;siStartInfo,  
272      &amp;piProcInfo);  
273    EAssertR(FuncRetn!=0, TStr::Fmt(&quot;Can not execute &#x27;%s&#x27; (Set the TZipIn::SevenZipPath)&quot;, CmdLine.CStr()).CStr());
274    CloseHandle(piProcInfo.hProcess);
275    CloseHandle(piProcInfo.hThread);
276    #else
277    ZipStdinWr = popen((TZipIn::SevenZipPath+&quot;/&quot;+CmdLine).CStr(), &quot;r&quot;);
278    EAssertR(ZipStdinWr,  TStr::Fmt(&quot;Can not execute &#x27;%s&#x27; (Set the TZipIn::SevenZipPath)&quot;, CmdLine.CStr()).CStr());
279    #endif
280  }
281  TZipOut::TZipOut(const TStr&amp; FNm) : TSBase(FNm.CStr()), TSOut(FNm), ZipStdinRd(NULL), ZipStdinWr(NULL), Bf(NULL), BfL(0){
282    EAssertR(! FNm.Empty(), &quot;Empty file-name.&quot;);
283    #ifdef GLib_WIN
284    SECURITY_ATTRIBUTES saAttr;
285    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
286    saAttr.bInheritHandle = TRUE;
287    saAttr.lpSecurityDescriptor = NULL;
288    EAssertR(CreatePipe(&amp;ZipStdinRd, &amp;ZipStdinWr, &amp;saAttr, 0), &quot;Stdout pipe creation failed&quot;);
289    SetHandleInformation(ZipStdinWr, HANDLE_FLAG_INHERIT, 0);
290    #else
291    #endif
292    CreateZipProcess(GetCmd(FNm), FNm);
293    Bf=new char[MxBfL];  BfL=0;
294  }
295  PSOut TZipOut::New(const TStr&amp; FNm){
296    return PSOut(new TZipOut(FNm));
297  }
298  TZipOut::~TZipOut() {
299    if (BfL!=0) { FlushBf(); }
300    #ifdef GLib_WIN
301    if (ZipStdinWr != NULL) { EAssertR(CloseHandle(ZipStdinWr), &quot;Closing write-end of pipe failed&quot;); }
302    if (ZipStdinRd != NULL) { EAssertR(CloseHandle(ZipStdinRd), &quot;Closing read-end of pipe failed&quot;); }
303    #else
304    if (ZipStdinWr != NULL) { EAssertR(pclose(ZipStdinWr) != -1, &quot;Closing of the process failed&quot;); }
305    #endif
306    if (Bf!=NULL) { delete[] Bf; }
307  }
308  int TZipOut::PutCh(const char&amp; Ch){
309    if (BfL==MxBfL) {FlushBf();}
310    return Bf[BfL++]=Ch;
311  }
312  int TZipOut::PutBf(const void* LBf, const TSize&amp; LBfL){
313    int LBfS=0;
314    if (BfL+LBfL&gt;MxBfL){
315      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
316        LBfS+=PutCh(((char*)LBf)[LBfC]);}
317    } else {
318      for (TSize LBfC=0; LBfC&lt;LBfL; LBfC++){
319        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
320    }
321    return LBfS;
322  }
323  void TZipOut::Flush(){
324    FlushBf();
325    #ifdef GLib_WIN
326    EAssertR(FlushFileBuffers(ZipStdinWr)!=0, &quot;Can not flush file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
327    #else
328    EAssertR(fflush(ZipStdinWr)==0, &quot;Can not flush file &#x27;&quot;+GetSNm()+&quot;&#x27;.&quot;);
329    #endif
330  }
331  bool TZipOut::IsZipExt(const TStr&amp; FNmExt) {
332    if (FExtToCmdH.Empty()) FillFExtToCmdH();
333    return FExtToCmdH.IsKey(FNmExt);
334  }
335  void TZipOut::FillFExtToCmdH() {
336    #ifdef GLib_WIN
337    const char* ZipCmd = &quot;7z.exe a -y -bd -si&quot;;
338    #else
339    const char* ZipCmd = &quot;7za a -y -bd -si&quot;;
340    #endif
341    if (FExtToCmdH.Empty()) {
342      FExtToCmdH.AddDat(&quot;.gz&quot;,  ZipCmd);
343      FExtToCmdH.AddDat(&quot;.7z&quot;,  ZipCmd);
344      FExtToCmdH.AddDat(&quot;.rar&quot;, ZipCmd);
345      FExtToCmdH.AddDat(&quot;.zip&quot;, ZipCmd);
346      FExtToCmdH.AddDat(&quot;.cab&quot;, ZipCmd);
347      FExtToCmdH.AddDat(&quot;.arj&quot;, ZipCmd);
348      FExtToCmdH.AddDat(&quot;.bzip2&quot;, ZipCmd);
349      FExtToCmdH.AddDat(&quot;.bz2&quot;, ZipCmd);
350    }
351  }
352  TStr TZipOut::GetCmd(const TStr&amp; ZipFNm) {
353    if (FExtToCmdH.Empty()) FillFExtToCmdH();
354    const TStr Ext = ZipFNm.GetFExt().GetLc();
355    EAssertR(FExtToCmdH.IsKey(Ext), TStr::Fmt(&quot;Unsupported file extension &#x27;%s&#x27;&quot;, Ext.CStr()));
356    return FExtToCmdH.GetDat(Ext)+ZipFNm.GetFMid();
357  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-zipfl.cpp</div>
                </div>
                <div class="column column_space"><pre><code>235  PSIn TFIn::New(const TStr&amp; FNm, bool&amp; OpenedP){
236    return PSIn(new TFIn(FNm, OpenedP));
</pre></code></div>
                <div class="column column_space"><pre><code>103  PSIn TZipIn::New(const TStr&amp; FNm, bool&amp; OpenedP){
104    return PSIn(new TZipIn(FNm, OpenedP));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    