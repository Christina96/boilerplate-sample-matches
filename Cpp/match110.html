<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for time_sequencer_unittest.cpp & msg_cache_unittest.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for time_sequencer_unittest.cpp & msg_cache_unittest.cpp
      </h3>
      <h1 align="center">
        26.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>time_sequencer_unittest.cpp (30.973452%)<TH>msg_cache_unittest.cpp (22.727272%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match110-0.html#0',2,'match110-1.html#0',3)" NAME="0">(110-127)<TD><A HREF="javascript:ZweiFrames('match110-0.html#0',2,'match110-1.html#0',3)" NAME="0">(190-212)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match110-0.html#1',2,'match110-1.html#1',3)" NAME="1">(54-69)<TD><A HREF="javascript:ZweiFrames('match110-0.html#1',2,'match110-1.html#1',3)" NAME="1">(55-70)</A><TD ALIGN=center><FONT COLOR="#f00000">17</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>time_sequencer_unittest.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2008, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of the Willow Garage nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

#include &lt;gtest/gtest.h&gt;

#include &quot;ros/time.h&quot;
#include &quot;message_filters/time_sequencer.h&quot;

using namespace message_filters;

struct Header
{
  ros::Time stamp;
};


struct Msg
{
  Header header;
<A NAME="1"></A>  int data;
};
typedef boost::shared_ptr&lt;Msg&gt; MsgPtr;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match110-1.html#1',3,'match110-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>typedef boost::shared_ptr&lt;Msg const&gt; MsgConstPtr;

namespace ros
{
namespace message_traits
{
template&lt;&gt;
struct TimeStamp&lt;Msg&gt;
{
  static ros::Time value(const Msg&amp; m)
  {
    return m.header.stamp;
  }
};
}
}</B></FONT>

class Helper
{
public:
  Helper()
  : count_(0)
  {}

  void cb(const MsgConstPtr&amp;)
  {
    ++count_;
  }

  int32_t count_;
};

TEST(TimeSequencer, simple)
{
  TimeSequencer&lt;Msg&gt; seq(ros::Duration(1.0), ros::Duration(0.01), 10);
  Helper h;
  seq.registerCallback(boost::bind(&amp;Helper::cb, &amp;h, boost::placeholders::_1));
  MsgPtr msg(boost::make_shared&lt;Msg&gt;());
  msg-&gt;header.stamp = ros::Time::now();
  seq.add(msg);

  ros::WallDuration(0.1).sleep();
  ros::spinOnce();
  ASSERT_EQ(h.count_, 0);

  ros::Time::setNow(ros::Time::now() + ros::Duration(2.0));

  ros::WallDuration(0.1).sleep();
  ros::spinOnce();

  ASSERT_EQ(h.count_, 1);
}

<A NAME="0"></A>TEST(TimeSequencer, compilation)
{
  TimeSequencer&lt;Msg&gt; seq(ros::Duration(1.0), ros::Duration(0.01), 10);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match110-1.html#0',3,'match110-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  TimeSequencer&lt;Msg&gt; seq2(ros::Duration(1.0), ros::Duration(0.01), 10);
  seq2.connectInput(seq);
}

struct EventHelper
{
public:
  void cb(const ros::MessageEvent&lt;Msg const&gt;&amp; evt)
  {
    event_ = evt;
  }

  ros::MessageEvent&lt;Msg const&gt; event_;
};

TEST(TimeSequencer, eventInEventOut)
{
  TimeSequencer&lt;Msg&gt; seq(ros::Duration(1.0), ros::Duration(0.01), 10);</B></FONT>
  TimeSequencer&lt;Msg&gt; seq2(seq, ros::Duration(1.0), ros::Duration(0.01), 10);
  EventHelper h;
  seq2.registerCallback(&amp;EventHelper::cb, &amp;h);

  ros::MessageEvent&lt;Msg const&gt; evt(boost::make_shared&lt;Msg const&gt;(), ros::Time::now());
  seq.add(evt);

  ros::Time::setNow(ros::Time::now() + ros::Duration(2));
  while (!h.event_.getMessage())
  {
    ros::WallDuration(0.01).sleep();
    ros::spinOnce();
  }

  EXPECT_EQ(h.event_.getReceiptTime(), evt.getReceiptTime());
  EXPECT_EQ(h.event_.getMessage(), evt.getMessage());
}

int main(int argc, char **argv){
  testing::InitGoogleTest(&amp;argc, argv);

  ros::init(argc, argv, &quot;time_sequencer_test&quot;);
  ros::NodeHandle nh;
  ros::Time::setNow(ros::Time());

  return RUN_ALL_TESTS();
}


</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>msg_cache_unittest.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2008, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of the Willow Garage nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

#include &lt;gtest/gtest.h&gt;

#include &quot;ros/time.h&quot;
#include &lt;ros/init.h&gt;
#include &quot;message_filters/cache.h&quot;

using namespace std ;
using namespace message_filters ;

struct Header
{
  ros::Time stamp ;
} ;


struct Msg
{
<A NAME="1"></A>  Header header ;
  int data ;
} ;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match110-0.html#1',2,'match110-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>typedef boost::shared_ptr&lt;Msg const&gt; MsgConstPtr;

namespace ros
{
namespace message_traits
{
template&lt;&gt;
struct TimeStamp&lt;Msg&gt;
{
  static ros::Time value(const Msg&amp; m)
  {
    return m.header.stamp;
  }
};
}
}</B></FONT>


void fillCacheEasy(Cache&lt;Msg&gt;&amp; cache, unsigned int start, unsigned int end)

{
  for (unsigned int i=start; i &lt; end; i++)
  {
    Msg* msg = new Msg ;
    msg-&gt;data = i ;
    msg-&gt;header.stamp.fromSec(i*10) ;

    boost::shared_ptr&lt;Msg const&gt; msg_ptr(msg) ;
    cache.add(msg_ptr) ;
  }
}

TEST(Cache, easyInterval)
{
  Cache&lt;Msg&gt; cache(10) ;
  fillCacheEasy(cache, 0, 5) ;

  vector&lt;boost::shared_ptr&lt;Msg const&gt; &gt; interval_data = cache.getInterval(ros::Time().fromSec(5), ros::Time().fromSec(35)) ;

  ASSERT_EQ(interval_data.size(), (unsigned int) 3) ;
  EXPECT_EQ(interval_data[0]-&gt;data, 1) ;
  EXPECT_EQ(interval_data[1]-&gt;data, 2) ;
  EXPECT_EQ(interval_data[2]-&gt;data, 3) ;

  // Look for an interval past the end of the cache
  interval_data = cache.getInterval(ros::Time().fromSec(55), ros::Time().fromSec(65)) ;
  EXPECT_EQ(interval_data.size(), (unsigned int) 0) ;

  // Look for an interval that fell off the back of the cache
  fillCacheEasy(cache, 5, 20) ;
  interval_data = cache.getInterval(ros::Time().fromSec(5), ros::Time().fromSec(35)) ;
  EXPECT_EQ(interval_data.size(), (unsigned int) 0) ;
}

TEST(Cache, easySurroundingInterval)
{
  Cache&lt;Msg&gt; cache(10);
  fillCacheEasy(cache, 1, 6);

  vector&lt;boost::shared_ptr&lt;Msg const&gt; &gt; interval_data;
  interval_data = cache.getSurroundingInterval(ros::Time(15,0), ros::Time(35,0)) ;
  ASSERT_EQ(interval_data.size(), (unsigned int) 4);
  EXPECT_EQ(interval_data[0]-&gt;data, 1);
  EXPECT_EQ(interval_data[1]-&gt;data, 2);
  EXPECT_EQ(interval_data[2]-&gt;data, 3);
  EXPECT_EQ(interval_data[3]-&gt;data, 4);

  interval_data = cache.getSurroundingInterval(ros::Time(0,0), ros::Time(35,0)) ;
  ASSERT_EQ(interval_data.size(), (unsigned int) 4);
  EXPECT_EQ(interval_data[0]-&gt;data, 1);

  interval_data = cache.getSurroundingInterval(ros::Time(35,0), ros::Time(35,0)) ;
  ASSERT_EQ(interval_data.size(), (unsigned int) 2);
  EXPECT_EQ(interval_data[0]-&gt;data, 3);
  EXPECT_EQ(interval_data[1]-&gt;data, 4);

  interval_data = cache.getSurroundingInterval(ros::Time(55,0), ros::Time(55,0)) ;
  ASSERT_EQ(interval_data.size(), (unsigned int) 1);
  EXPECT_EQ(interval_data[0]-&gt;data, 5);
}


boost::shared_ptr&lt;Msg const&gt; buildMsg(double time, int data)
{
  Msg* msg = new Msg ;
  msg-&gt;data = data ;
  msg-&gt;header.stamp.fromSec(time) ;

  boost::shared_ptr&lt;Msg const&gt; msg_ptr(msg) ;
  return msg_ptr ;
}

TEST(Cache, easyUnsorted)
{
  Cache&lt;Msg&gt; cache(10) ;

  cache.add(buildMsg(10.0, 1)) ;
  cache.add(buildMsg(30.0, 3)) ;
  cache.add(buildMsg(70.0, 7)) ;
  cache.add(buildMsg( 5.0, 0)) ;
  cache.add(buildMsg(20.0, 2)) ;

  vector&lt;boost::shared_ptr&lt;Msg const&gt; &gt; interval_data = cache.getInterval(ros::Time().fromSec(3), ros::Time().fromSec(15)) ;

  ASSERT_EQ(interval_data.size(), (unsigned int) 2) ;
  EXPECT_EQ(interval_data[0]-&gt;data, 0) ;
  EXPECT_EQ(interval_data[1]-&gt;data, 1) ;

  // Grab all the data
  interval_data = cache.getInterval(ros::Time().fromSec(0), ros::Time().fromSec(80)) ;
  ASSERT_EQ(interval_data.size(), (unsigned int) 5) ;
  EXPECT_EQ(interval_data[0]-&gt;data, 0) ;
  EXPECT_EQ(interval_data[1]-&gt;data, 1) ;
  EXPECT_EQ(interval_data[2]-&gt;data, 2) ;
  EXPECT_EQ(interval_data[3]-&gt;data, 3) ;
  EXPECT_EQ(interval_data[4]-&gt;data, 7) ;
}


TEST(Cache, easyElemBeforeAfter)
{
  Cache&lt;Msg&gt; cache(10) ;
  boost::shared_ptr&lt;Msg const&gt; elem_ptr ;

  fillCacheEasy(cache, 5, 10) ;

  elem_ptr = cache.getElemAfterTime( ros::Time().fromSec(85.0)) ;

  ASSERT_FALSE(!elem_ptr) ;
  EXPECT_EQ(elem_ptr-&gt;data, 9) ;

  elem_ptr = cache.getElemBeforeTime( ros::Time().fromSec(85.0)) ;
<A NAME="0"></A>  ASSERT_FALSE(!elem_ptr) ;
  EXPECT_EQ(elem_ptr-&gt;data, 8) ;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match110-0.html#0',2,'match110-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  elem_ptr = cache.getElemBeforeTime( ros::Time().fromSec(45.0)) ;
  EXPECT_TRUE(!elem_ptr) ;
}

struct EventHelper
{
public:
  void cb(const ros::MessageEvent&lt;Msg const&gt;&amp; evt)
  {
    event_ = evt;
  }

  ros::MessageEvent&lt;Msg const&gt; event_;
};

TEST(Cache, eventInEventOut)
{
  Cache&lt;Msg&gt; c0(10);
  Cache&lt;Msg&gt; c1(c0, 10);
  EventHelper h;
  c1.registerCallback(&amp;EventHelper::cb, &amp;h);

  ros::MessageEvent&lt;Msg const&gt; evt(boost::make_shared&lt;Msg const&gt;(), ros::Time(4));</B></FONT>
  c0.add(evt);

  EXPECT_EQ(h.event_.getReceiptTime(), evt.getReceiptTime());
  EXPECT_EQ(h.event_.getMessage(), evt.getMessage());
}

int main(int argc, char **argv){
  testing::InitGoogleTest(&amp;argc, argv);
  ros::init(argc, argv, &quot;blah&quot;);
  ros::Time::init();
  return RUN_ALL_TESTS();
}

</PRE>
</div>
  </div>
</body>
</html>
