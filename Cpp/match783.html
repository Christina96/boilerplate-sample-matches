<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for transport.t.cpp & rib-module.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for transport.t.cpp & rib-module.cpp
      </h3>
      <h1 align="center">
        4.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>transport.t.cpp (8.092485%)<TH>rib-module.cpp (3.482587%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match783-0.html#0',2,'match783-1.html#0',3)" NAME="0">(56-70)<TD><A HREF="javascript:ZweiFrames('match783-0.html#0',2,'match783-1.html#0',3)" NAME="0">(42-56)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>transport.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2020,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;face/transport.hpp&quot;
#include &quot;face/face.hpp&quot;

#include &quot;tests/test-common.hpp&quot;
#include &quot;tests/daemon/global-io-fixture.hpp&quot;
#include &quot;tests/daemon/face/dummy-link-service.hpp&quot;
#include &quot;tests/daemon/face/dummy-transport.hpp&quot;

#include &lt;boost/mpl/fold.hpp&gt;
#include &lt;boost/mpl/int.hpp&gt;
#include &lt;boost/mpl/lambda.hpp&gt;
#include &lt;boost/mpl/map.hpp&gt;
#include &lt;boost/mpl/pair.hpp&gt;
#include &lt;boost/mpl/push_back.hpp&gt;
#include &lt;boost/mpl/set.hpp&gt;
#include &lt;boost/mpl/vector.hpp&gt;

namespace nfd {
namespace face {
namespace tests {

namespace mpl = boost::mpl;
using namespace nfd::tests;

BOOST_AUTO_TEST_SUITE(Face)
BOOST_AUTO_TEST_SUITE(TestTransport)

<A NAME="0"></A>BOOST_AUTO_TEST_CASE(PersistencyChange)
{
  auto transport = make_unique&lt;DummyTransport&gt;();
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match783-1.html#0',3,'match783-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  BOOST_CHECK_EQUAL(transport-&gt;getPersistency(), ndn::nfd::FACE_PERSISTENCY_PERSISTENT);
  BOOST_CHECK_EQUAL(transport-&gt;persistencyHistory.size(), 0);

  BOOST_CHECK_EQUAL(transport-&gt;canChangePersistencyTo(ndn::nfd::FACE_PERSISTENCY_NONE), false);
  BOOST_REQUIRE_EQUAL(transport-&gt;canChangePersistencyTo(transport-&gt;getPersistency()), true);
  BOOST_REQUIRE_EQUAL(transport-&gt;canChangePersistencyTo(ndn::nfd::FACE_PERSISTENCY_PERMANENT), true);

  transport-&gt;setPersistency(transport-&gt;getPersistency());
  BOOST_CHECK_EQUAL(transport-&gt;getPersistency(), ndn::nfd::FACE_PERSISTENCY_PERSISTENT);
  BOOST_CHECK_EQUAL(transport-&gt;persistencyHistory.size(), 0);

  transport-&gt;setPersistency(ndn::nfd::FACE_PERSISTENCY_PERMANENT);
  BOOST_CHECK_EQUAL(transport-&gt;getPersistency(), ndn::nfd::FACE_PERSISTENCY_PERMANENT);
  BOOST_REQUIRE_EQUAL(transport-&gt;persistencyHistory.size(), 1);
  BOOST_CHECK_EQUAL(transport-&gt;persistencyHistory.back(), ndn::nfd::FACE_PERSISTENCY_PERSISTENT);</B></FONT>
}

/** \brief a macro to declare a TransportState as a integral constant
 *  \note we cannot use mpl::integral_c because TransportState is not an integral type
 */
#define TRANSPORT_STATE_C(X) mpl::int_&lt;static_cast&lt;int&gt;(TransportState::X)&gt;

/** \brief a map from every TransportState to a valid state transition sequence
 *         for entering this state from UP
 */
typedef mpl::map&lt;
  mpl::pair&lt;TRANSPORT_STATE_C(UP),
    mpl::vector&lt;&gt;&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(DOWN),
    mpl::vector&lt;
      TRANSPORT_STATE_C(DOWN)
    &gt;&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(CLOSING),
    mpl::vector&lt;
      TRANSPORT_STATE_C(CLOSING)
    &gt;&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(FAILED),
    mpl::vector&lt;
      TRANSPORT_STATE_C(FAILED)
    &gt;&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(CLOSED),
    mpl::vector&lt;
      TRANSPORT_STATE_C(CLOSING),
      TRANSPORT_STATE_C(CLOSED)
    &gt;&gt;
&gt; StateEntering;

/** \brief a sequence of all valid TransportStates
 */
typedef mpl::fold&lt;StateEntering,
  mpl::vector&lt;&gt;,
  mpl::push_back&lt;mpl::_1, mpl::first&lt;mpl::_2&gt;&gt;
&gt;::type States;

/** \brief a set of all valid state transitions
 */
typedef mpl::set&lt;
  mpl::pair&lt;TRANSPORT_STATE_C(UP), TRANSPORT_STATE_C(DOWN)&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(DOWN), TRANSPORT_STATE_C(UP)&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(UP), TRANSPORT_STATE_C(CLOSING)&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(UP), TRANSPORT_STATE_C(FAILED)&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(DOWN), TRANSPORT_STATE_C(CLOSING)&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(DOWN), TRANSPORT_STATE_C(FAILED)&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(CLOSING), TRANSPORT_STATE_C(CLOSED)&gt;,
  mpl::pair&lt;TRANSPORT_STATE_C(FAILED), TRANSPORT_STATE_C(CLOSED)&gt;
&gt; ValidStateTransitions;

/** \brief a metafunction to generate a sequence of all state transitions
 *         from a specified state
 */
template&lt;typename FromState, typename Result&gt;
struct StateTransitionsFrom : mpl::fold&lt;
                                States,
                                Result,
                                mpl::push_back&lt;mpl::_1, mpl::pair&lt;FromState, mpl::_2&gt;&gt;&gt;
{
};

/** \brief a sequence of all state transitions
 */
typedef mpl::fold&lt;
  States,
  mpl::vector&lt;&gt;,
  mpl::lambda&lt;StateTransitionsFrom&lt;mpl::_2, mpl::_1&gt;&gt;
&gt;::type AllStateTransitions;

#undef TRANSPORT_STATE_C

BOOST_AUTO_TEST_CASE_TEMPLATE(SetState, T, AllStateTransitions)
{
  auto transport = make_unique&lt;DummyTransport&gt;();

  TransportState from = static_cast&lt;TransportState&gt;(T::first::value);
  TransportState to = static_cast&lt;TransportState&gt;(T::second::value);
  BOOST_TEST_MESSAGE(&quot;SetState &quot; &lt;&lt; from &lt;&lt; &quot; -&gt; &quot; &lt;&lt; to);

  // enter from state
  using Steps = typename mpl::at&lt;StateEntering, mpl::int_&lt;T::first::value&gt;&gt;::type;
  mpl::for_each&lt;Steps&gt;([&amp;transport] (int state) {
    transport-&gt;setState(static_cast&lt;TransportState&gt;(state));
  });
  BOOST_REQUIRE_EQUAL(transport-&gt;getState(), from);

  bool hasSignal = false;
  transport-&gt;afterStateChange.connect(
    [from, to, &amp;hasSignal] (TransportState oldState, TransportState newState) {
      hasSignal = true;
      BOOST_CHECK_EQUAL(oldState, from);
      BOOST_CHECK_EQUAL(newState, to);
    });

  // do transition
  bool isValid = from == to ||
                 mpl::has_key&lt;ValidStateTransitions,
                   mpl::pair&lt;mpl::int_&lt;T::first::value&gt;, mpl::int_&lt;T::second::value&gt;&gt;
                 &gt;::value;
  if (isValid) {
    BOOST_REQUIRE_NO_THROW(transport-&gt;setState(to));
    BOOST_CHECK_EQUAL(hasSignal, from != to);
  }
  else {
    BOOST_CHECK_THROW(transport-&gt;setState(to), std::runtime_error);
  }
}

class DummyTransportFixture : public GlobalIoFixture
{
protected:
  void
  initialize(unique_ptr&lt;DummyTransport&gt; t = make_unique&lt;DummyTransport&gt;())
  {
    this-&gt;face = make_unique&lt;nfd::Face&gt;(make_unique&lt;DummyLinkService&gt;(), std::move(t));
    this-&gt;transport = static_cast&lt;DummyTransport*&gt;(face-&gt;getTransport());
    this-&gt;sentPackets = &amp;this-&gt;transport-&gt;sentPackets;
    this-&gt;receivedPackets = &amp;static_cast&lt;DummyLinkService*&gt;(face-&gt;getLinkService())-&gt;receivedPackets;
  }

protected:
  unique_ptr&lt;nfd::Face&gt; face;
  DummyTransport* transport = nullptr;
  const std::vector&lt;Block&gt;* sentPackets = nullptr;
  const std::vector&lt;RxPacket&gt;* receivedPackets = nullptr;
};

BOOST_FIXTURE_TEST_CASE(Send, DummyTransportFixture)
{
  this-&gt;initialize();

  Block pkt1 = ndn::encoding::makeStringBlock(300, &quot;Lorem ipsum dolor sit amet,&quot;);
  transport-&gt;send(pkt1);

  Block pkt2 = ndn::encoding::makeStringBlock(301, &quot;consectetur adipiscing elit,&quot;);
  transport-&gt;send(pkt2);

  transport-&gt;setState(TransportState::DOWN);
  Block pkt3 = ndn::encoding::makeStringBlock(302, &quot;sed do eiusmod tempor incididunt &quot;);
  transport-&gt;send(pkt3);

  transport-&gt;setState(TransportState::CLOSING);
  Block pkt4 = ndn::encoding::makeStringBlock(303, &quot;ut labore et dolore magna aliqua.&quot;);
  transport-&gt;send(pkt4);

  BOOST_CHECK_EQUAL(transport-&gt;getCounters().nOutPackets, 2);
  BOOST_CHECK_EQUAL(transport-&gt;getCounters().nOutBytes, pkt1.size() + pkt2.size());
  BOOST_REQUIRE_EQUAL(sentPackets-&gt;size(), 3);
  BOOST_CHECK(sentPackets-&gt;at(0) == pkt1);
  BOOST_CHECK(sentPackets-&gt;at(1) == pkt2);
  BOOST_CHECK(sentPackets-&gt;at(2) == pkt3);
}

BOOST_FIXTURE_TEST_CASE(Receive, DummyTransportFixture)
{
  this-&gt;initialize();

  Block pkt1 = ndn::encoding::makeStringBlock(300, &quot;Lorem ipsum dolor sit amet,&quot;);
  transport-&gt;receivePacket(pkt1);

  Block pkt2 = ndn::encoding::makeStringBlock(301, &quot;consectetur adipiscing elit,&quot;);
  transport-&gt;receivePacket(pkt2);

  transport-&gt;setState(TransportState::DOWN);
  Block pkt3 = ndn::encoding::makeStringBlock(302, &quot;sed do eiusmod tempor incididunt &quot;);
  transport-&gt;receivePacket(pkt3);

  BOOST_CHECK_EQUAL(transport-&gt;getCounters().nInPackets, 3);
  BOOST_CHECK_EQUAL(transport-&gt;getCounters().nInBytes, pkt1.size() + pkt2.size() + pkt3.size());
  BOOST_REQUIRE_EQUAL(receivedPackets-&gt;size(), 3);
  BOOST_CHECK(receivedPackets-&gt;at(0).packet == pkt1);
  BOOST_CHECK(receivedPackets-&gt;at(1).packet == pkt2);
  BOOST_CHECK(receivedPackets-&gt;at(2).packet == pkt3);
}

BOOST_AUTO_TEST_SUITE_END() // TestTransport
BOOST_AUTO_TEST_SUITE_END() // Face

} // namespace tests
} // namespace face
} // namespace nfd
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rib-module.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2020,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;rib-module.hpp&quot;
#include &quot;canonizer.hpp&quot;
#include &quot;face-module.hpp&quot;
#include &quot;find-face.hpp&quot;
#include &quot;format-helpers.hpp&quot;

namespace nfd {
namespace tools {
namespace nfdc {

void
RibModule::registerCommands(CommandParser&amp; parser)
{
<A NAME="0"></A>  CommandDefinition defRouteList(&quot;route&quot;, &quot;list&quot;);
  defRouteList
    .setTitle(&quot;print RIB routes&quot;)
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match783-0.html#0',2,'match783-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    .addArg(&quot;nexthop&quot;, ArgValueType::FACE_ID_OR_URI, Required::NO, Positional::YES)
    .addArg(&quot;origin&quot;, ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO);
  parser.addCommand(defRouteList, &amp;RibModule::list);
  parser.addAlias(&quot;route&quot;, &quot;list&quot;, &quot;&quot;);

  CommandDefinition defRouteShow(&quot;route&quot;, &quot;show&quot;);
  defRouteShow
    .setTitle(&quot;show routes toward a prefix&quot;)
    .addArg(&quot;prefix&quot;, ArgValueType::NAME, Required::YES, Positional::YES);
  parser.addCommand(defRouteShow, &amp;RibModule::show);

  CommandDefinition defRouteAdd(&quot;route&quot;, &quot;add&quot;);
  defRouteAdd
    .setTitle(&quot;add a route&quot;)
    .addArg(&quot;prefix&quot;, ArgValueType::NAME, Required::YES, Positional::YES)</B></FONT>
    .addArg(&quot;nexthop&quot;, ArgValueType::FACE_ID_OR_URI, Required::YES, Positional::YES)
    .addArg(&quot;origin&quot;, ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO)
    .addArg(&quot;cost&quot;, ArgValueType::UNSIGNED, Required::NO, Positional::NO)
    .addArg(&quot;no-inherit&quot;, ArgValueType::NONE, Required::NO, Positional::NO)
    .addArg(&quot;capture&quot;, ArgValueType::NONE, Required::NO, Positional::NO)
    .addArg(&quot;expires&quot;, ArgValueType::UNSIGNED, Required::NO, Positional::NO);
  parser.addCommand(defRouteAdd, &amp;RibModule::add);

  CommandDefinition defRouteRemove(&quot;route&quot;, &quot;remove&quot;);
  defRouteRemove
    .setTitle(&quot;remove a route&quot;)
    .addArg(&quot;prefix&quot;, ArgValueType::NAME, Required::YES, Positional::YES)
    .addArg(&quot;nexthop&quot;, ArgValueType::FACE_ID_OR_URI, Required::YES, Positional::YES)
    .addArg(&quot;origin&quot;, ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO);
  parser.addCommand(defRouteRemove, &amp;RibModule::remove);
}

void
RibModule::list(ExecuteContext&amp; ctx)
{
  auto nexthopIt = ctx.args.find(&quot;nexthop&quot;);
  std::set&lt;uint64_t&gt; nexthops;
  auto origin = ctx.args.getOptional&lt;RouteOrigin&gt;(&quot;origin&quot;);

  if (nexthopIt != ctx.args.end()) {
    FindFace findFace(ctx);
    FindFace::Code res = findFace.execute(nexthopIt-&gt;second, true);

    ctx.exitCode = static_cast&lt;int&gt;(res);
    switch (res) {
      case FindFace::Code::OK:
        break;
      case FindFace::Code::ERROR:
      case FindFace::Code::CANONIZE_ERROR:
      case FindFace::Code::NOT_FOUND:
        ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
        return;
      default:
        BOOST_ASSERT_MSG(false, &quot;unexpected FindFace result&quot;);
        return;
    }

    nexthops = findFace.getFaceIds();
  }

  listRoutesImpl(ctx, [&amp;] (const RibEntry&amp; entry, const Route&amp; route) {
    return (nexthops.empty() || nexthops.count(route.getFaceId()) &gt; 0) &amp;&amp;
           (!origin || route.getOrigin() == *origin);
  });
}

void
RibModule::show(ExecuteContext&amp; ctx)
{
  auto prefix = ctx.args.get&lt;Name&gt;(&quot;prefix&quot;);

  listRoutesImpl(ctx, [&amp;] (const RibEntry&amp; entry, const Route&amp; route) {
    return entry.getName() == prefix;
  });
}

void
RibModule::listRoutesImpl(ExecuteContext&amp; ctx, const RoutePredicate&amp; filter)
{
  ctx.controller.fetch&lt;ndn::nfd::RibDataset&gt;(
    [&amp;] (const std::vector&lt;RibEntry&gt;&amp; dataset) {
      bool hasRoute = false;
      for (const RibEntry&amp; entry : dataset) {
        for (const Route&amp; route : entry.getRoutes()) {
          if (filter(entry, route)) {
            hasRoute = true;
            formatRouteText(ctx.out, entry, route, true);
            ctx.out &lt;&lt; '\n';
          }
        }
      }

      if (!hasRoute) {
        ctx.exitCode = 6;
        ctx.err &lt;&lt; &quot;Route not found\n&quot;;
      }
    },
    ctx.makeDatasetFailureHandler(&quot;RIB dataset&quot;),
    ctx.makeCommandOptions());

  ctx.face.processEvents();
}

void
RibModule::add(ExecuteContext&amp; ctx)
{
  auto prefix = ctx.args.get&lt;Name&gt;(&quot;prefix&quot;);
  auto nexthop = ctx.args.at(&quot;nexthop&quot;);
  auto origin = ctx.args.get&lt;RouteOrigin&gt;(&quot;origin&quot;, ndn::nfd::ROUTE_ORIGIN_STATIC);
  auto cost = ctx.args.get&lt;uint64_t&gt;(&quot;cost&quot;, 0);
  bool wantChildInherit = !ctx.args.get&lt;bool&gt;(&quot;no-inherit&quot;, false);
  bool wantCapture = ctx.args.get&lt;bool&gt;(&quot;capture&quot;, false);
  auto expiresMillis = ctx.args.getOptional&lt;uint64_t&gt;(&quot;expires&quot;);

  auto registerRoute = [&amp;] (uint64_t faceId) {
    ControlParameters registerParams;
    registerParams
      .setName(prefix)
      .setFaceId(faceId)
      .setOrigin(origin)
      .setCost(cost)
      .setFlags((wantChildInherit ? ndn::nfd::ROUTE_FLAG_CHILD_INHERIT : ndn::nfd::ROUTE_FLAGS_NONE) |
                (wantCapture ? ndn::nfd::ROUTE_FLAG_CAPTURE : ndn::nfd::ROUTE_FLAGS_NONE));
    if (expiresMillis) {
      registerParams.setExpirationPeriod(time::milliseconds(*expiresMillis));
    }

    ctx.controller.start&lt;ndn::nfd::RibRegisterCommand&gt;(
      registerParams,
      [&amp;] (const ControlParameters&amp; resp) {
        ctx.exitCode = static_cast&lt;int&gt;(FindFace::Code::OK);
        ctx.out &lt;&lt; &quot;route-add-accepted &quot;;
        text::ItemAttributes ia;
        ctx.out &lt;&lt; ia(&quot;prefix&quot;) &lt;&lt; resp.getName()
                &lt;&lt; ia(&quot;nexthop&quot;) &lt;&lt; resp.getFaceId()
                &lt;&lt; ia(&quot;origin&quot;) &lt;&lt; resp.getOrigin()
                &lt;&lt; ia(&quot;cost&quot;) &lt;&lt; resp.getCost()
                &lt;&lt; ia(&quot;flags&quot;) &lt;&lt; static_cast&lt;ndn::nfd::RouteFlags&gt;(resp.getFlags());
        if (resp.hasExpirationPeriod()) {
          ctx.out &lt;&lt; ia(&quot;expires&quot;) &lt;&lt; text::formatDuration&lt;time::milliseconds&gt;(resp.getExpirationPeriod()) &lt;&lt; &quot;\n&quot;;
        }
        else {
          ctx.out&lt;&lt; ia(&quot;expires&quot;) &lt;&lt; &quot;never\n&quot;;
        }
      },
      ctx.makeCommandFailureHandler(&quot;adding route&quot;),
      ctx.makeCommandOptions());
  };

  auto handleFaceNotFound = [&amp;] {
    const FaceUri* faceUri = ndn::any_cast&lt;FaceUri&gt;(&amp;nexthop);
    if (faceUri == nullptr) {
      ctx.err &lt;&lt; &quot;Face not found\n&quot;;
      return;
    }

    if (faceUri-&gt;getScheme() == &quot;ether&quot;) {
      // Unicast Ethernet faces require a LocalUri, which hasn't been provided
      // Multicast Ethernet faces cannot be created via management (already exist on each interface)
      ctx.err &lt;&lt; &quot;Unable to implicitly create Ethernet faces\n&quot;;
      ctx.err &lt;&lt; &quot;Please create the face with 'nfdc face create' before adding the route\n&quot;;
      return;
    }

    optional&lt;FaceUri&gt; canonized;
    std::string error;
    std::tie(canonized, error) = canonize(ctx, *faceUri);
    if (!canonized) {
      // Canonization failed
      auto canonizationError = canonizeErrorHelper(*faceUri, error);
      ctx.exitCode = static_cast&lt;int&gt;(canonizationError.first);
      ctx.err &lt;&lt; canonizationError.second &lt;&lt; '\n';
      return;
    }

    ControlParameters faceCreateParams;
    faceCreateParams.setUri(canonized-&gt;toString());

    ctx.controller.start&lt;ndn::nfd::FaceCreateCommand&gt;(
      faceCreateParams,
      [&amp;] (const ControlParameters&amp; resp) {
        FaceModule::printSuccess(ctx.out, &quot;face-created&quot;, resp);
        registerRoute(resp.getFaceId());
      },
      ctx.makeCommandFailureHandler(&quot;implicitly creating face&quot;),
      ctx.makeCommandOptions());
  };

  FindFace findFace(ctx);
  FindFace::Code res = findFace.execute(nexthop);

  ctx.exitCode = static_cast&lt;int&gt;(res);
  switch (res) {
    case FindFace::Code::OK:
      registerRoute(findFace.getFaceId());
      break;
    case FindFace::Code::ERROR:
    case FindFace::Code::CANONIZE_ERROR:
      ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
      return;
    case FindFace::Code::NOT_FOUND:
      // Attempt to create face if it doesn't exist
      handleFaceNotFound();
      break;
    case FindFace::Code::AMBIGUOUS:
      ctx.err &lt;&lt; &quot;Multiple faces match specified remote FaceUri. Re-run the command with a FaceId:&quot;;
      findFace.printDisambiguation(ctx.err, FindFace::DisambiguationStyle::LOCAL_URI);
      ctx.err &lt;&lt; '\n';
      return;
    default:
      BOOST_ASSERT_MSG(false, &quot;unexpected FindFace result&quot;);
      return;
  }

  ctx.face.processEvents();
}

void
RibModule::remove(ExecuteContext&amp; ctx)
{
  auto prefix = ctx.args.get&lt;Name&gt;(&quot;prefix&quot;);
  auto nexthop = ctx.args.at(&quot;nexthop&quot;);
  auto origin = ctx.args.get&lt;RouteOrigin&gt;(&quot;origin&quot;, ndn::nfd::ROUTE_ORIGIN_STATIC);

  FindFace findFace(ctx);
  FindFace::Code res = findFace.execute(nexthop, true);

  ctx.exitCode = static_cast&lt;int&gt;(res);
  switch (res) {
    case FindFace::Code::OK:
      break;
    case FindFace::Code::ERROR:
    case FindFace::Code::CANONIZE_ERROR:
    case FindFace::Code::NOT_FOUND:
      ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
      return;
    default:
      BOOST_ASSERT_MSG(false, &quot;unexpected FindFace result&quot;);
      return;
  }

  for (uint64_t faceId : findFace.getFaceIds()) {
    ControlParameters unregisterParams;
    unregisterParams
      .setName(prefix)
      .setFaceId(faceId)
      .setOrigin(origin);

    ctx.controller.start&lt;ndn::nfd::RibUnregisterCommand&gt;(
      unregisterParams,
      [&amp;] (const ControlParameters&amp; resp) {
        ctx.out &lt;&lt; &quot;route-removed &quot;;
        text::ItemAttributes ia;
        ctx.out &lt;&lt; ia(&quot;prefix&quot;) &lt;&lt; resp.getName()
                &lt;&lt; ia(&quot;nexthop&quot;) &lt;&lt; resp.getFaceId()
                &lt;&lt; ia(&quot;origin&quot;) &lt;&lt; resp.getOrigin()
                &lt;&lt; '\n';
      },
      ctx.makeCommandFailureHandler(&quot;removing route&quot;),
      ctx.makeCommandOptions());
  }

  ctx.face.processEvents();
}

void
RibModule::fetchStatus(Controller&amp; controller,
                       const std::function&lt;void()&gt;&amp; onSuccess,
                       const Controller::DatasetFailCallback&amp; onFailure,
                       const CommandOptions&amp; options)
{
  controller.fetch&lt;ndn::nfd::RibDataset&gt;(
    [this, onSuccess] (const std::vector&lt;RibEntry&gt;&amp; result) {
      m_status = result;
      onSuccess();
    },
    onFailure, options);
}

void
RibModule::formatStatusXml(std::ostream&amp; os) const
{
  os &lt;&lt; &quot;&lt;rib&gt;&quot;;
  for (const RibEntry&amp; item : m_status) {
    this-&gt;formatItemXml(os, item);
  }
  os &lt;&lt; &quot;&lt;/rib&gt;&quot;;
}

void
RibModule::formatItemXml(std::ostream&amp; os, const RibEntry&amp; item) const
{
  os &lt;&lt; &quot;&lt;ribEntry&gt;&quot;;

  os &lt;&lt; &quot;&lt;prefix&gt;&quot; &lt;&lt; xml::Text{item.getName().toUri()} &lt;&lt; &quot;&lt;/prefix&gt;&quot;;

  os &lt;&lt; &quot;&lt;routes&gt;&quot;;
  for (const Route&amp; route : item.getRoutes()) {
    os &lt;&lt; &quot;&lt;route&gt;&quot;
       &lt;&lt; &quot;&lt;faceId&gt;&quot; &lt;&lt; route.getFaceId() &lt;&lt; &quot;&lt;/faceId&gt;&quot;
       &lt;&lt; &quot;&lt;origin&gt;&quot; &lt;&lt; route.getOrigin() &lt;&lt; &quot;&lt;/origin&gt;&quot;
       &lt;&lt; &quot;&lt;cost&gt;&quot; &lt;&lt; route.getCost() &lt;&lt; &quot;&lt;/cost&gt;&quot;;
    if (route.getFlags() == ndn::nfd::ROUTE_FLAGS_NONE) {
       os &lt;&lt; &quot;&lt;flags/&gt;&quot;;
    }
    else {
       os &lt;&lt; &quot;&lt;flags&gt;&quot;;
      if (route.isChildInherit()) {
        os &lt;&lt; &quot;&lt;childInherit/&gt;&quot;;
      }
      if (route.isRibCapture()) {
        os &lt;&lt; &quot;&lt;ribCapture/&gt;&quot;;
      }
      os &lt;&lt; &quot;&lt;/flags&gt;&quot;;
    }
    if (route.hasExpirationPeriod()) {
      os &lt;&lt; &quot;&lt;expirationPeriod&gt;&quot;
         &lt;&lt; xml::formatDuration(time::duration_cast&lt;time::seconds&gt;(route.getExpirationPeriod()))
         &lt;&lt; &quot;&lt;/expirationPeriod&gt;&quot;;
    }
    os &lt;&lt; &quot;&lt;/route&gt;&quot;;
  }
  os &lt;&lt; &quot;&lt;/routes&gt;&quot;;

  os &lt;&lt; &quot;&lt;/ribEntry&gt;&quot;;
}

void
RibModule::formatStatusText(std::ostream&amp; os) const
{
  os &lt;&lt; &quot;RIB:\n&quot;;
  for (const RibEntry&amp; item : m_status) {
    os &lt;&lt; &quot;  &quot;;
    formatEntryText(os, item);
    os &lt;&lt; '\n';
  }
}

void
RibModule::formatEntryText(std::ostream&amp; os, const RibEntry&amp; entry)
{
  os &lt;&lt; entry.getName() &lt;&lt; &quot; routes={&quot;;

  text::Separator sep(&quot;, &quot;);
  for (const Route&amp; route : entry.getRoutes()) {
    os &lt;&lt; sep;
    formatRouteText(os, entry, route, false);
  }

  os &lt;&lt; &quot;}&quot;;
}

void
RibModule::formatRouteText(std::ostream&amp; os, const RibEntry&amp; entry, const Route&amp; route,
                           bool includePrefix)
{
  text::ItemAttributes ia;

  if (includePrefix) {
    os &lt;&lt; ia(&quot;prefix&quot;) &lt;&lt; entry.getName();
  }
  os &lt;&lt; ia(&quot;nexthop&quot;) &lt;&lt; route.getFaceId();
  os &lt;&lt; ia(&quot;origin&quot;) &lt;&lt; route.getOrigin();
  os &lt;&lt; ia(&quot;cost&quot;) &lt;&lt; route.getCost();
  os &lt;&lt; ia(&quot;flags&quot;) &lt;&lt; static_cast&lt;ndn::nfd::RouteFlags&gt;(route.getFlags());
  if (route.hasExpirationPeriod()) {
    os &lt;&lt; ia(&quot;expires&quot;) &lt;&lt; text::formatDuration&lt;time::seconds&gt;(route.getExpirationPeriod());
  }
  else {
    os &lt;&lt; ia(&quot;expires&quot;) &lt;&lt; &quot;never&quot;;
  }
}

} // namespace nfdc
} // namespace tools
} // namespace nfd
</PRE>
</div>
  </div>
</body>
</html>
