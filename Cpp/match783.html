<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for transport.t.cpp &amp; rib-module.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for transport.t.cpp &amp; rib-module.cpp
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>transport.t.cpp (8.092485%)<th>rib-module.cpp (3.482587%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(56-70)<td><a href="#" name="0">(42-56)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>transport.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "face/transport.hpp"
2 #include "face/face.hpp"
3 #include "tests/test-common.hpp"
4 #include "tests/daemon/global-io-fixture.hpp"
5 #include "tests/daemon/face/dummy-link-service.hpp"
6 #include "tests/daemon/face/dummy-transport.hpp"
7 #include &lt;boost/mpl/fold.hpp&gt;
8 #include &lt;boost/mpl/int.hpp&gt;
9 #include &lt;boost/mpl/lambda.hpp&gt;
10 #include &lt;boost/mpl/map.hpp&gt;
11 #include &lt;boost/mpl/pair.hpp&gt;
12 #include &lt;boost/mpl/push_back.hpp&gt;
13 #include &lt;boost/mpl/set.hpp&gt;
14 #include &lt;boost/mpl/vector.hpp&gt;
15 namespace nfd {
16 namespace face {
17 namespace tests {
18 namespace mpl = boost::mpl;
19 using namespace nfd::tests;
20 BOOST_AUTO_TEST_SUITE(Face)
21 BOOST_AUTO_TEST_SUITE(TestTransport)
22 <a name="0"></a>BOOST_AUTO_TEST_CASE(PersistencyChange)
23 {
24   auto transport = make_unique&lt;DummyTransport&gt;();
25 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  BOOST_CHECK_EQUAL(transport-&gt;getPersistency(), ndn::nfd::FACE_PERSISTENCY_PERSISTENT);
26   BOOST_CHECK_EQUAL(transport-&gt;persistencyHistory.size(), 0);
27   BOOST_CHECK_EQUAL(transport-&gt;canChangePersistencyTo(ndn::nfd::FACE_PERSISTENCY_NONE), false);
28   BOOST_REQUIRE_EQUAL(transport-&gt;canChangePersistencyTo(transport-&gt;getPersistency()), true);
29   BOOST_REQUIRE_EQUAL(transport-&gt;canChangePersistencyTo(ndn::nfd::FACE_PERSISTENCY_PERMANENT), true);
30   transport-&gt;setPersistency(transport-&gt;getPersistency());
31   BOOST_CHECK_EQUAL(transport-&gt;getPersistency(), ndn::nfd::FACE_PERSISTENCY_PERSISTENT);
32   BOOST_CHECK_EQUAL(transport-&gt;persistencyHistory.size(), 0);
33   transport-&gt;setPersistency(ndn::nfd::FACE_PERSISTENCY_PERMANENT);
34   BOOST_CHECK_EQUAL(transport-&gt;getPersistency(), ndn::nfd::FACE_PERSISTENCY_PERMANENT);
35   BOOST_REQUIRE_EQUAL(transport-&gt;persistencyHistory.size(), 1);
36   BOOST_CHECK_EQUAL(transport-&gt;persistencyHistory.back(), ndn::nfd::FACE_PERSISTENCY_PERSISTENT);</b></font>
37 }
38 #define TRANSPORT_STATE_C(X) mpl::int_&lt;static_cast&lt;int&gt;(TransportState::X)&gt;
39 typedef mpl::map&lt;
40   mpl::pair&lt;TRANSPORT_STATE_C(UP),
41     mpl::vector&lt;&gt;&gt;,
42   mpl::pair&lt;TRANSPORT_STATE_C(DOWN),
43     mpl::vector&lt;
44       TRANSPORT_STATE_C(DOWN)
45     &gt;&gt;,
46   mpl::pair&lt;TRANSPORT_STATE_C(CLOSING),
47     mpl::vector&lt;
48       TRANSPORT_STATE_C(CLOSING)
49     &gt;&gt;,
50   mpl::pair&lt;TRANSPORT_STATE_C(FAILED),
51     mpl::vector&lt;
52       TRANSPORT_STATE_C(FAILED)
53     &gt;&gt;,
54   mpl::pair&lt;TRANSPORT_STATE_C(CLOSED),
55     mpl::vector&lt;
56       TRANSPORT_STATE_C(CLOSING),
57       TRANSPORT_STATE_C(CLOSED)
58     &gt;&gt;
59 &gt; StateEntering;
60 typedef mpl::fold&lt;StateEntering,
61   mpl::vector&lt;&gt;,
62   mpl::push_back&lt;mpl::_1, mpl::first&lt;mpl::_2&gt;&gt;
63 &gt;::type States;
64 typedef mpl::set&lt;
65   mpl::pair&lt;TRANSPORT_STATE_C(UP), TRANSPORT_STATE_C(DOWN)&gt;,
66   mpl::pair&lt;TRANSPORT_STATE_C(DOWN), TRANSPORT_STATE_C(UP)&gt;,
67   mpl::pair&lt;TRANSPORT_STATE_C(UP), TRANSPORT_STATE_C(CLOSING)&gt;,
68   mpl::pair&lt;TRANSPORT_STATE_C(UP), TRANSPORT_STATE_C(FAILED)&gt;,
69   mpl::pair&lt;TRANSPORT_STATE_C(DOWN), TRANSPORT_STATE_C(CLOSING)&gt;,
70   mpl::pair&lt;TRANSPORT_STATE_C(DOWN), TRANSPORT_STATE_C(FAILED)&gt;,
71   mpl::pair&lt;TRANSPORT_STATE_C(CLOSING), TRANSPORT_STATE_C(CLOSED)&gt;,
72   mpl::pair&lt;TRANSPORT_STATE_C(FAILED), TRANSPORT_STATE_C(CLOSED)&gt;
73 &gt; ValidStateTransitions;
74 template&lt;typename FromState, typename Result&gt;
75 struct StateTransitionsFrom : mpl::fold&lt;
76                                 States,
77                                 Result,
78                                 mpl::push_back&lt;mpl::_1, mpl::pair&lt;FromState, mpl::_2&gt;&gt;&gt;
79 {
80 };
81 typedef mpl::fold&lt;
82   States,
83   mpl::vector&lt;&gt;,
84   mpl::lambda&lt;StateTransitionsFrom&lt;mpl::_2, mpl::_1&gt;&gt;
85 &gt;::type AllStateTransitions;
86 #undef TRANSPORT_STATE_C
87 BOOST_AUTO_TEST_CASE_TEMPLATE(SetState, T, AllStateTransitions)
88 {
89   auto transport = make_unique&lt;DummyTransport&gt;();
90   TransportState from = static_cast&lt;TransportState&gt;(T::first::value);
91   TransportState to = static_cast&lt;TransportState&gt;(T::second::value);
92   BOOST_TEST_MESSAGE("SetState " &lt;&lt; from &lt;&lt; " -&gt; " &lt;&lt; to);
93   using Steps = typename mpl::at&lt;StateEntering, mpl::int_&lt;T::first::value&gt;&gt;::type;
94   mpl::for_each&lt;Steps&gt;([&amp;transport] (int state) {
95     transport-&gt;setState(static_cast&lt;TransportState&gt;(state));
96   });
97   BOOST_REQUIRE_EQUAL(transport-&gt;getState(), from);
98   bool hasSignal = false;
99   transport-&gt;afterStateChange.connect(
100     [from, to, &amp;hasSignal] (TransportState oldState, TransportState newState) {
101       hasSignal = true;
102       BOOST_CHECK_EQUAL(oldState, from);
103       BOOST_CHECK_EQUAL(newState, to);
104     });
105   bool isValid = from == to ||
106                  mpl::has_key&lt;ValidStateTransitions,
107                    mpl::pair&lt;mpl::int_&lt;T::first::value&gt;, mpl::int_&lt;T::second::value&gt;&gt;
108                  &gt;::value;
109   if (isValid) {
110     BOOST_REQUIRE_NO_THROW(transport-&gt;setState(to));
111     BOOST_CHECK_EQUAL(hasSignal, from != to);
112   }
113   else {
114     BOOST_CHECK_THROW(transport-&gt;setState(to), std::runtime_error);
115   }
116 }
117 class DummyTransportFixture : public GlobalIoFixture
118 {
119 protected:
120   void
121   initialize(unique_ptr&lt;DummyTransport&gt; t = make_unique&lt;DummyTransport&gt;())
122   {
123     this-&gt;face = make_unique&lt;nfd::Face&gt;(make_unique&lt;DummyLinkService&gt;(), std::move(t));
124     this-&gt;transport = static_cast&lt;DummyTransport*&gt;(face-&gt;getTransport());
125     this-&gt;sentPackets = &amp;this-&gt;transport-&gt;sentPackets;
126     this-&gt;receivedPackets = &amp;static_cast&lt;DummyLinkService*&gt;(face-&gt;getLinkService())-&gt;receivedPackets;
127   }
128 protected:
129   unique_ptr&lt;nfd::Face&gt; face;
130   DummyTransport* transport = nullptr;
131   const std::vector&lt;Block&gt;* sentPackets = nullptr;
132   const std::vector&lt;RxPacket&gt;* receivedPackets = nullptr;
133 };
134 BOOST_FIXTURE_TEST_CASE(Send, DummyTransportFixture)
135 {
136   this-&gt;initialize();
137   Block pkt1 = ndn::encoding::makeStringBlock(300, "Lorem ipsum dolor sit amet,");
138   transport-&gt;send(pkt1);
139   Block pkt2 = ndn::encoding::makeStringBlock(301, "consectetur adipiscing elit,");
140   transport-&gt;send(pkt2);
141   transport-&gt;setState(TransportState::DOWN);
142   Block pkt3 = ndn::encoding::makeStringBlock(302, "sed do eiusmod tempor incididunt ");
143   transport-&gt;send(pkt3);
144   transport-&gt;setState(TransportState::CLOSING);
145   Block pkt4 = ndn::encoding::makeStringBlock(303, "ut labore et dolore magna aliqua.");
146   transport-&gt;send(pkt4);
147   BOOST_CHECK_EQUAL(transport-&gt;getCounters().nOutPackets, 2);
148   BOOST_CHECK_EQUAL(transport-&gt;getCounters().nOutBytes, pkt1.size() + pkt2.size());
149   BOOST_REQUIRE_EQUAL(sentPackets-&gt;size(), 3);
150   BOOST_CHECK(sentPackets-&gt;at(0) == pkt1);
151   BOOST_CHECK(sentPackets-&gt;at(1) == pkt2);
152   BOOST_CHECK(sentPackets-&gt;at(2) == pkt3);
153 }
154 BOOST_FIXTURE_TEST_CASE(Receive, DummyTransportFixture)
155 {
156   this-&gt;initialize();
157   Block pkt1 = ndn::encoding::makeStringBlock(300, "Lorem ipsum dolor sit amet,");
158   transport-&gt;receivePacket(pkt1);
159   Block pkt2 = ndn::encoding::makeStringBlock(301, "consectetur adipiscing elit,");
160   transport-&gt;receivePacket(pkt2);
161   transport-&gt;setState(TransportState::DOWN);
162   Block pkt3 = ndn::encoding::makeStringBlock(302, "sed do eiusmod tempor incididunt ");
163   transport-&gt;receivePacket(pkt3);
164   BOOST_CHECK_EQUAL(transport-&gt;getCounters().nInPackets, 3);
165   BOOST_CHECK_EQUAL(transport-&gt;getCounters().nInBytes, pkt1.size() + pkt2.size() + pkt3.size());
166   BOOST_REQUIRE_EQUAL(receivedPackets-&gt;size(), 3);
167   BOOST_CHECK(receivedPackets-&gt;at(0).packet == pkt1);
168   BOOST_CHECK(receivedPackets-&gt;at(1).packet == pkt2);
169   BOOST_CHECK(receivedPackets-&gt;at(2).packet == pkt3);
170 }
171 BOOST_AUTO_TEST_SUITE_END() BOOST_AUTO_TEST_SUITE_END() 
} } } </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rib-module.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "rib-module.hpp"
2 #include "canonizer.hpp"
3 #include "face-module.hpp"
4 #include "find-face.hpp"
5 #include "format-helpers.hpp"
6 namespace nfd {
7 namespace tools {
8 namespace nfdc {
9 void
10 RibModule::registerCommands(CommandParser&amp; parser)
11 {
12 <a name="0"></a>  CommandDefinition defRouteList("route", "list");
13   defRouteList
14     .setTitle("print RIB routes")
15 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    .addArg("nexthop", ArgValueType::FACE_ID_OR_URI, Required::NO, Positional::YES)
16     .addArg("origin", ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO);
17   parser.addCommand(defRouteList, &amp;RibModule::list);
18   parser.addAlias("route", "list", "");
19   CommandDefinition defRouteShow("route", "show");
20   defRouteShow
21     .setTitle("show routes toward a prefix")
22     .addArg("prefix", ArgValueType::NAME, Required::YES, Positional::YES);
23   parser.addCommand(defRouteShow, &amp;RibModule::show);
24   CommandDefinition defRouteAdd("route", "add");
25   defRouteAdd
26     .setTitle("add a route")
27     .addArg("prefix", ArgValueType::NAME, Required::YES, Positional::YES)</b></font>
28     .addArg("nexthop", ArgValueType::FACE_ID_OR_URI, Required::YES, Positional::YES)
29     .addArg("origin", ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO)
30     .addArg("cost", ArgValueType::UNSIGNED, Required::NO, Positional::NO)
31     .addArg("no-inherit", ArgValueType::NONE, Required::NO, Positional::NO)
32     .addArg("capture", ArgValueType::NONE, Required::NO, Positional::NO)
33     .addArg("expires", ArgValueType::UNSIGNED, Required::NO, Positional::NO);
34   parser.addCommand(defRouteAdd, &amp;RibModule::add);
35   CommandDefinition defRouteRemove("route", "remove");
36   defRouteRemove
37     .setTitle("remove a route")
38     .addArg("prefix", ArgValueType::NAME, Required::YES, Positional::YES)
39     .addArg("nexthop", ArgValueType::FACE_ID_OR_URI, Required::YES, Positional::YES)
40     .addArg("origin", ArgValueType::ROUTE_ORIGIN, Required::NO, Positional::NO);
41   parser.addCommand(defRouteRemove, &amp;RibModule::remove);
42 }
43 void
44 RibModule::list(ExecuteContext&amp; ctx)
45 {
46   auto nexthopIt = ctx.args.find("nexthop");
47   std::set&lt;uint64_t&gt; nexthops;
48   auto origin = ctx.args.getOptional&lt;RouteOrigin&gt;("origin");
49   if (nexthopIt != ctx.args.end()) {
50     FindFace findFace(ctx);
51     FindFace::Code res = findFace.execute(nexthopIt-&gt;second, true);
52     ctx.exitCode = static_cast&lt;int&gt;(res);
53     switch (res) {
54       case FindFace::Code::OK:
55         break;
56       case FindFace::Code::ERROR:
57       case FindFace::Code::CANONIZE_ERROR:
58       case FindFace::Code::NOT_FOUND:
59         ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
60         return;
61       default:
62         BOOST_ASSERT_MSG(false, "unexpected FindFace result");
63         return;
64     }
65     nexthops = findFace.getFaceIds();
66   }
67   listRoutesImpl(ctx, [&amp;] (const RibEntry&amp; entry, const Route&amp; route) {
68     return (nexthops.empty() || nexthops.count(route.getFaceId()) &gt; 0) &amp;&amp;
69            (!origin || route.getOrigin() == *origin);
70   });
71 }
72 void
73 RibModule::show(ExecuteContext&amp; ctx)
74 {
75   auto prefix = ctx.args.get&lt;Name&gt;("prefix");
76   listRoutesImpl(ctx, [&amp;] (const RibEntry&amp; entry, const Route&amp; route) {
77     return entry.getName() == prefix;
78   });
79 }
80 void
81 RibModule::listRoutesImpl(ExecuteContext&amp; ctx, const RoutePredicate&amp; filter)
82 {
83   ctx.controller.fetch&lt;ndn::nfd::RibDataset&gt;(
84     [&amp;] (const std::vector&lt;RibEntry&gt;&amp; dataset) {
85       bool hasRoute = false;
86       for (const RibEntry&amp; entry : dataset) {
87         for (const Route&amp; route : entry.getRoutes()) {
88           if (filter(entry, route)) {
89             hasRoute = true;
90             formatRouteText(ctx.out, entry, route, true);
91             ctx.out &lt;&lt; '\n';
92           }
93         }
94       }
95       if (!hasRoute) {
96         ctx.exitCode = 6;
97         ctx.err &lt;&lt; "Route not found\n";
98       }
99     },
100     ctx.makeDatasetFailureHandler("RIB dataset"),
101     ctx.makeCommandOptions());
102   ctx.face.processEvents();
103 }
104 void
105 RibModule::add(ExecuteContext&amp; ctx)
106 {
107   auto prefix = ctx.args.get&lt;Name&gt;("prefix");
108   auto nexthop = ctx.args.at("nexthop");
109   auto origin = ctx.args.get&lt;RouteOrigin&gt;("origin", ndn::nfd::ROUTE_ORIGIN_STATIC);
110   auto cost = ctx.args.get&lt;uint64_t&gt;("cost", 0);
111   bool wantChildInherit = !ctx.args.get&lt;bool&gt;("no-inherit", false);
112   bool wantCapture = ctx.args.get&lt;bool&gt;("capture", false);
113   auto expiresMillis = ctx.args.getOptional&lt;uint64_t&gt;("expires");
114   auto registerRoute = [&amp;] (uint64_t faceId) {
115     ControlParameters registerParams;
116     registerParams
117       .setName(prefix)
118       .setFaceId(faceId)
119       .setOrigin(origin)
120       .setCost(cost)
121       .setFlags((wantChildInherit ? ndn::nfd::ROUTE_FLAG_CHILD_INHERIT : ndn::nfd::ROUTE_FLAGS_NONE) |
122                 (wantCapture ? ndn::nfd::ROUTE_FLAG_CAPTURE : ndn::nfd::ROUTE_FLAGS_NONE));
123     if (expiresMillis) {
124       registerParams.setExpirationPeriod(time::milliseconds(*expiresMillis));
125     }
126     ctx.controller.start&lt;ndn::nfd::RibRegisterCommand&gt;(
127       registerParams,
128       [&amp;] (const ControlParameters&amp; resp) {
129         ctx.exitCode = static_cast&lt;int&gt;(FindFace::Code::OK);
130         ctx.out &lt;&lt; "route-add-accepted ";
131         text::ItemAttributes ia;
132         ctx.out &lt;&lt; ia("prefix") &lt;&lt; resp.getName()
133                 &lt;&lt; ia("nexthop") &lt;&lt; resp.getFaceId()
134                 &lt;&lt; ia("origin") &lt;&lt; resp.getOrigin()
135                 &lt;&lt; ia("cost") &lt;&lt; resp.getCost()
136                 &lt;&lt; ia("flags") &lt;&lt; static_cast&lt;ndn::nfd::RouteFlags&gt;(resp.getFlags());
137         if (resp.hasExpirationPeriod()) {
138           ctx.out &lt;&lt; ia("expires") &lt;&lt; text::formatDuration&lt;time::milliseconds&gt;(resp.getExpirationPeriod()) &lt;&lt; "\n";
139         }
140         else {
141           ctx.out&lt;&lt; ia("expires") &lt;&lt; "never\n";
142         }
143       },
144       ctx.makeCommandFailureHandler("adding route"),
145       ctx.makeCommandOptions());
146   };
147   auto handleFaceNotFound = [&amp;] {
148     const FaceUri* faceUri = ndn::any_cast&lt;FaceUri&gt;(&amp;nexthop);
149     if (faceUri == nullptr) {
150       ctx.err &lt;&lt; "Face not found\n";
151       return;
152     }
153     if (faceUri-&gt;getScheme() == "ether") {
154       ctx.err &lt;&lt; "Unable to implicitly create Ethernet faces\n";
155       ctx.err &lt;&lt; "Please create the face with 'nfdc face create' before adding the route\n";
156       return;
157     }
158     optional&lt;FaceUri&gt; canonized;
159     std::string error;
160     std::tie(canonized, error) = canonize(ctx, *faceUri);
161     if (!canonized) {
162       auto canonizationError = canonizeErrorHelper(*faceUri, error);
163       ctx.exitCode = static_cast&lt;int&gt;(canonizationError.first);
164       ctx.err &lt;&lt; canonizationError.second &lt;&lt; '\n';
165       return;
166     }
167     ControlParameters faceCreateParams;
168     faceCreateParams.setUri(canonized-&gt;toString());
169     ctx.controller.start&lt;ndn::nfd::FaceCreateCommand&gt;(
170       faceCreateParams,
171       [&amp;] (const ControlParameters&amp; resp) {
172         FaceModule::printSuccess(ctx.out, "face-created", resp);
173         registerRoute(resp.getFaceId());
174       },
175       ctx.makeCommandFailureHandler("implicitly creating face"),
176       ctx.makeCommandOptions());
177   };
178   FindFace findFace(ctx);
179   FindFace::Code res = findFace.execute(nexthop);
180   ctx.exitCode = static_cast&lt;int&gt;(res);
181   switch (res) {
182     case FindFace::Code::OK:
183       registerRoute(findFace.getFaceId());
184       break;
185     case FindFace::Code::ERROR:
186     case FindFace::Code::CANONIZE_ERROR:
187       ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
188       return;
189     case FindFace::Code::NOT_FOUND:
190       handleFaceNotFound();
191       break;
192     case FindFace::Code::AMBIGUOUS:
193       ctx.err &lt;&lt; "Multiple faces match specified remote FaceUri. Re-run the command with a FaceId:";
194       findFace.printDisambiguation(ctx.err, FindFace::DisambiguationStyle::LOCAL_URI);
195       ctx.err &lt;&lt; '\n';
196       return;
197     default:
198       BOOST_ASSERT_MSG(false, "unexpected FindFace result");
199       return;
200   }
201   ctx.face.processEvents();
202 }
203 void
204 RibModule::remove(ExecuteContext&amp; ctx)
205 {
206   auto prefix = ctx.args.get&lt;Name&gt;("prefix");
207   auto nexthop = ctx.args.at("nexthop");
208   auto origin = ctx.args.get&lt;RouteOrigin&gt;("origin", ndn::nfd::ROUTE_ORIGIN_STATIC);
209   FindFace findFace(ctx);
210   FindFace::Code res = findFace.execute(nexthop, true);
211   ctx.exitCode = static_cast&lt;int&gt;(res);
212   switch (res) {
213     case FindFace::Code::OK:
214       break;
215     case FindFace::Code::ERROR:
216     case FindFace::Code::CANONIZE_ERROR:
217     case FindFace::Code::NOT_FOUND:
218       ctx.err &lt;&lt; findFace.getErrorReason() &lt;&lt; '\n';
219       return;
220     default:
221       BOOST_ASSERT_MSG(false, "unexpected FindFace result");
222       return;
223   }
224   for (uint64_t faceId : findFace.getFaceIds()) {
225     ControlParameters unregisterParams;
226     unregisterParams
227       .setName(prefix)
228       .setFaceId(faceId)
229       .setOrigin(origin);
230     ctx.controller.start&lt;ndn::nfd::RibUnregisterCommand&gt;(
231       unregisterParams,
232       [&amp;] (const ControlParameters&amp; resp) {
233         ctx.out &lt;&lt; "route-removed ";
234         text::ItemAttributes ia;
235         ctx.out &lt;&lt; ia("prefix") &lt;&lt; resp.getName()
236                 &lt;&lt; ia("nexthop") &lt;&lt; resp.getFaceId()
237                 &lt;&lt; ia("origin") &lt;&lt; resp.getOrigin()
238                 &lt;&lt; '\n';
239       },
240       ctx.makeCommandFailureHandler("removing route"),
241       ctx.makeCommandOptions());
242   }
243   ctx.face.processEvents();
244 }
245 void
246 RibModule::fetchStatus(Controller&amp; controller,
247                        const std::function&lt;void()&gt;&amp; onSuccess,
248                        const Controller::DatasetFailCallback&amp; onFailure,
249                        const CommandOptions&amp; options)
250 {
251   controller.fetch&lt;ndn::nfd::RibDataset&gt;(
252     [this, onSuccess] (const std::vector&lt;RibEntry&gt;&amp; result) {
253       m_status = result;
254       onSuccess();
255     },
256     onFailure, options);
257 }
258 void
259 RibModule::formatStatusXml(std::ostream&amp; os) const
260 {
261   os &lt;&lt; "&lt;rib&gt;";
262   for (const RibEntry&amp; item : m_status) {
263     this-&gt;formatItemXml(os, item);
264   }
265   os &lt;&lt; "&lt;/rib&gt;";
266 }
267 void
268 RibModule::formatItemXml(std::ostream&amp; os, const RibEntry&amp; item) const
269 {
270   os &lt;&lt; "&lt;ribEntry&gt;";
271   os &lt;&lt; "&lt;prefix&gt;" &lt;&lt; xml::Text{item.getName().toUri()} &lt;&lt; "&lt;/prefix&gt;";
272   os &lt;&lt; "&lt;routes&gt;";
273   for (const Route&amp; route : item.getRoutes()) {
274     os &lt;&lt; "&lt;route&gt;"
275        &lt;&lt; "&lt;faceId&gt;" &lt;&lt; route.getFaceId() &lt;&lt; "&lt;/faceId&gt;"
276        &lt;&lt; "&lt;origin&gt;" &lt;&lt; route.getOrigin() &lt;&lt; "&lt;/origin&gt;"
277        &lt;&lt; "&lt;cost&gt;" &lt;&lt; route.getCost() &lt;&lt; "&lt;/cost&gt;";
278     if (route.getFlags() == ndn::nfd::ROUTE_FLAGS_NONE) {
279        os &lt;&lt; "&lt;flags/&gt;";
280     }
281     else {
282        os &lt;&lt; "&lt;flags&gt;";
283       if (route.isChildInherit()) {
284         os &lt;&lt; "&lt;childInherit/&gt;";
285       }
286       if (route.isRibCapture()) {
287         os &lt;&lt; "&lt;ribCapture/&gt;";
288       }
289       os &lt;&lt; "&lt;/flags&gt;";
290     }
291     if (route.hasExpirationPeriod()) {
292       os &lt;&lt; "&lt;expirationPeriod&gt;"
293          &lt;&lt; xml::formatDuration(time::duration_cast&lt;time::seconds&gt;(route.getExpirationPeriod()))
294          &lt;&lt; "&lt;/expirationPeriod&gt;";
295     }
296     os &lt;&lt; "&lt;/route&gt;";
297   }
298   os &lt;&lt; "&lt;/routes&gt;";
299   os &lt;&lt; "&lt;/ribEntry&gt;";
300 }
301 void
302 RibModule::formatStatusText(std::ostream&amp; os) const
303 {
304   os &lt;&lt; "RIB:\n";
305   for (const RibEntry&amp; item : m_status) {
306     os &lt;&lt; "  ";
307     formatEntryText(os, item);
308     os &lt;&lt; '\n';
309   }
310 }
311 void
312 RibModule::formatEntryText(std::ostream&amp; os, const RibEntry&amp; entry)
313 {
314   os &lt;&lt; entry.getName() &lt;&lt; " routes={";
315   text::Separator sep(", ");
316   for (const Route&amp; route : entry.getRoutes()) {
317     os &lt;&lt; sep;
318     formatRouteText(os, entry, route, false);
319   }
320   os &lt;&lt; "}";
321 }
322 void
323 RibModule::formatRouteText(std::ostream&amp; os, const RibEntry&amp; entry, const Route&amp; route,
324                            bool includePrefix)
325 {
326   text::ItemAttributes ia;
327   if (includePrefix) {
328     os &lt;&lt; ia("prefix") &lt;&lt; entry.getName();
329   }
330   os &lt;&lt; ia("nexthop") &lt;&lt; route.getFaceId();
331   os &lt;&lt; ia("origin") &lt;&lt; route.getOrigin();
332   os &lt;&lt; ia("cost") &lt;&lt; route.getCost();
333   os &lt;&lt; ia("flags") &lt;&lt; static_cast&lt;ndn::nfd::RouteFlags&gt;(route.getFlags());
334   if (route.hasExpirationPeriod()) {
335     os &lt;&lt; ia("expires") &lt;&lt; text::formatDuration&lt;time::seconds&gt;(route.getExpirationPeriod());
336   }
337   else {
338     os &lt;&lt; ia("expires") &lt;&lt; "never";
339   }
340 }
} } } </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
