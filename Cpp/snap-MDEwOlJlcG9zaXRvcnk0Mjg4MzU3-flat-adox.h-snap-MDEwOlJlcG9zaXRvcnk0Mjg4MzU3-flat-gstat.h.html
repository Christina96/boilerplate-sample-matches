
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.01015228426396%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-adox.h</h3>
            <pre><code>1  #ifndef adox_h
2  #define adox_h
3  #include <ADODB.hpp>
4  #include "base.h"
5  ClassTP(TAdoDb, PAdoDb)
6  protected:
7    static int LastDbId;
8    TADOConnection* Connection;
9    bool Ok;
10    TStr ErrMsg;
11    int GetNewDbId(){return ++LastDbId;}
12  public:
13    TAdoDb();
14    virtual ~TAdoDb();
15    TAdoDb(TSIn&){Fail;}
16    static PAdoDb Load(TSIn& SIn){Fail; return NULL;}
17    void Save(TSOut&){Fail;}
18    void ConnDb(const TStr& ConnStr);
19    bool IsOk() const {return Ok;}
20    TStr GetErrMsg() const {return ErrMsg;}
21    TADOConnection* GetConnection(){return Connection;}
22    TStr GetNm() const {return Connection->Name.c_str();}
23    void Open() const {Connection->Open();}
24    void Close() const {Connection->Close();}
25  };
26  class TSqlSrvAdoDb: public TAdoDb{
27  public:
28    TSqlSrvAdoDb(): TAdoDb(){}
29    static PAdoDb New(const TStr& AliasNm, const TStr& UsrNm, const TStr& PwdStr);
30  };
31  ClassTP(TAdoQuery, PAdoQuery)
32  private:
33    TADOQuery* Query;
34    bool Ok;
35    TStr ErrMsg;
36    int RecN;
37  public:
38    TAdoQuery(const PAdoDb& AdoDb);
39    static PAdoQuery New(const PAdoDb& AdoDb){
40      return PAdoQuery(new TAdoQuery(AdoDb));}
41    ~TAdoQuery();
42    static PAdoQuery Load(TSIn& SIn){Fail; return NULL;}
43    void Save(TSOut&){Fail;}
44    TADOQuery* GetQuery(){return Query;}
45    bool IsOk(){return Ok;}
46    TStr GetErrMsg(){return ErrMsg;}
47    void Execute(const TStr& QueryStr);
48    void Select(const TStr& QueryStr);
49    int GetRecs() const {return Query->RecordCount;}
50    int GetRecN() const {return RecN;}
51    void First(){Query->First(); RecN=0;}
52    void Next(){Query->Next(); RecN++;}
53    bool Eof(){return Query->Eof;}
54    int GetFlds(){
55      return Query->FieldCount;}
56    TStr GetFldNm(const int& FldN){
57      return Query->Fields->Fields[FldN]->FieldName.c_str();}
58    TStr GetValStr(const int& FldN){
59      return Query->Fields->Fields[FldN]->AsString.c_str();}
60    TStr GetValStr(const TStr& FldNm){
61      return Query->FieldByName(FldNm.CStr())->AsString.c_str();}
62    bool GetValBool(const TStr& FldNm){
63      return Query->FieldByName(FldNm.CStr())->AsInteger!=0;}
64    int GetValInt(const int& FldN){
65      return Query->Fields->Fields[FldN]->AsInteger;}
66    int GetValInt(const TStr& FldNm){
67      return Query->FieldByName(FldNm.CStr())->AsInteger;}
68    double GetValFlt(const TStr& FldNm){
69      return Query->FieldByName(FldNm.CStr())->AsFloat;}
70  };
71  ClassTP(TAdoTable, PAdoTable)
72  private:
73    TADOTable* Table;
74    int RecN;
75  public:
76    TAdoTable(const PAdoDb& AdoDb, const TStr& TableNm);
77    static PAdoTable New(const PAdoDb& AdoDb, const TStr& TableNm){
78      return PAdoTable(new TAdoTable(AdoDb, TableNm));}
79    ~TAdoTable();
80    static PAdoTable Load(TSIn& SIn){Fail; return NULL;}
81    void Save(TSOut&){Fail;}
82    TADOTable* GetTable() const {return Table;}
83    void Open() const {Table->Open();}
84    void Close() const {Table->Close();}
85    int GetRecs() const {return Table->RecordCount;}
86    int GetRecN() const {return RecN;}
87    void First(){Table->First(); RecN=0;}
88    void Next(){Table->Next(); RecN++;}
89    bool Eof() const {return Table->Eof;}
90    void Insert() const {Table->Insert();}
91    void Edit() const {Table->Edit();}
92    void Post() const {Table->Post();}
93    int GetFlds() const {
94      return Table->FieldCount;}
<span onclick='openModal()' class='match'>95    TStr GetFldNm(const int& FldN) const {
96      return Table->Fields->Fields[FldN]->FieldName.c_str();}
97    TStr GetValStr(const int& FldN) const {
98      return Table->Fields->Fields[FldN]->AsString.c_str();}
99    void PutValStr(const TStr& FldNm, const TStr& FldVal) const {
</span>100      Table->FieldByName(FldNm.CStr())->AsString=FldVal.CStr();}
101    TStr GetValStr(const TStr& FldNm) const {
102      return Table->FieldByName(FldNm.CStr())->AsString.c_str();}
103    bool GetValBool(const TStr& FldNm) const {
104      return Table->FieldByName(FldNm.CStr())->AsInteger!=0;}
105    int GetValInt(const TStr& FldNm) const {
106      return Table->FieldByName(FldNm.CStr())->AsInteger;}
107    double GetValFlt(const TStr& FldNm) const {
108      return Table->FieldByName(FldNm.CStr())->AsFloat;}
109  };
110  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gstat.h</h3>
            <pre><code>1  class TGStat;
2  typedef TPt<TGStat> PGStat;
3  typedef TVec<PGStat> TGStatV;
4  class TGStatVec;
5  typedef TPt<TGStatVec> PGStatVec;
6  typedef enum TGStatVal_ {
7    gsvNone, gsvIndex, gsvTime, gsvNodes, gsvZeroNodes, gsvNonZNodes, gsvSrcNodes, gsvDstNodes,
8    gsvEdges, gsvUniqEdges, gsvBiDirEdges,
9    gsvWccNodes, gsvWccSrcNodes, gsvWccDstNodes, gsvWccEdges, gsvWccUniqEdges, gsvWccBiDirEdges,
10    gsvSccNodes, gsvSccEdges,gsvBccNodes, gsvBccEdges,
11    gsvFullDiam, gsvEffDiam, gsvEffWccDiam, gsvFullWccDiam,
12    gsvFullDiamDev, gsvEffDiamDev, gsvEffWccDiamDev, gsvFullWccDiamDev, 
13    gsvClustCf, gsvOpenTriads, gsvClosedTriads, gsvWccSize, gsvSccSize, gsvBccSize,
14    gsvMx
15  } TGStatVal;
16  typedef enum TGStatDistr_ {
17    gsdUndef=100, gsdInDeg, gsdOutDeg, gsdWcc, gsdScc,
18    gsdHops, gsdWccHops, gsdSngVal, gsdSngVec, gsdClustCf,
19    gsdTriadPart, 
20    gsdMx,
21  } TGStatDistr;
22  class TGStat {
23  public:
24    static int NDiamRuns;
25    static int TakeSngVals;
26    typedef TQuad<TStr, TStr, TStr, TGpScaleTy> TPlotInfo; 
27  public:
28    class TCmpByVal {
29    private:
30      TGStatVal ValCmp;
31      bool SortAsc;
32    public:
33      TCmpByVal(TGStatVal SortBy, bool Asc) : ValCmp(SortBy), SortAsc(Asc) { }
34      bool operator () (const TGStat& GS1, const TGStat& GS2) const;
35      bool operator () (const PGStat& GS1, const PGStat& GS2) const;
36    };
37  private:
38    static const TFltPrV EmptyV;
39    TCRef CRef;
40  public:
41    TSecTm Time;
42    TStr GraphNm;
43    TIntFltH ValStatH; 
44    THash<TInt, TFltPrV> DistrStatH; 
45  public:
46    TGStat(const TSecTm& GraphTm = TSecTm(), const TStr& GraphName=TStr());
47    TGStat(const PNGraph& Graph, const TSecTm& Time, TFSet StatFSet=TFSet(), const TStr& GraphName=TStr());
48    TGStat(const PUNGraph& Graph, const TSecTm& Time, TFSet StatFSet=TFSet(), const TStr& GraphName=TStr());
49    TGStat(const PNEGraph& Graph, const TSecTm& Time, TFSet StatFSet=TFSet(), const TStr& GraphName=TStr());
50    template <class PGraph> TGStat(const PGraph& Graph, const TSecTm& Time, TFSet StatFSet=TFSet(), const TStr& GraphName=TStr()) {
51      TakeStat(Graph, Time, StatFSet, GraphName); }
52    TGStat(const TGStat& GStat);
53    TGStat(TSIn& SIn);
54    void Save(TSOut& SOut) const;
55    static PGStat New(const TSecTm& Time=TSecTm(), const TStr& GraphName=TStr()) {
56      return new TGStat(Time, GraphName); }
57    static PGStat New(const PNGraph& Graph, const TSecTm& Time, TFSet StatFSet=TFSet(),
58      const TStr& GraphNm=TStr()) { return new TGStat(Graph, Time, StatFSet, GraphNm); }
59    static PGStat New(const PUNGraph& Graph, const TSecTm& Time, TFSet StatFSet=TFSet(),
60      const TStr& GraphNm=TStr()) { return new TGStat(Graph, Time, StatFSet, GraphNm); }
61    static PGStat New(const PNEGraph& Graph, const TSecTm& Time, TFSet StatFSet=TFSet(),
62      const TStr& GraphNm=TStr()) { return new TGStat(Graph, Time, StatFSet, GraphNm); }
63    template <class PGraph> PGStat New(const PGraph& Graph, const TSecTm& Time, TFSet StatFSet=TFSet(),
64      const TStr& GraphNm=TStr()) { return new TGStat(Graph, Time, StatFSet, GraphNm); }
65    static PGStat Load(TSIn& SIn) { return new TGStat(SIn); }
66    PGStat Clone() const { return new TGStat(*this); }
67    TGStat& operator = (const TGStat& GStat);
68    bool operator == (const TGStat& GStat) const;
69    bool operator < (const TGStat& GStat) const;
70    int GetYear() const { return Time.GetYearN(); }
71    int GetMonth() const { return Time.GetMonthN(); }
72    int GetDay() const { return Time.GetDayN(); }
73    int GetHour() const { return Time.GetHourN(); }
74    int GetMin() const { return Time.GetMinN(); }
75    int GetSec() const { return Time.GetSecN(); }
76    TStr GetTmStr() const { return Time.GetStr(); }
77    void SetTm(const TSecTm& GraphTm) { Time = GraphTm; }
78    TStr GetNm() const { return GraphNm; }
79    void SetNm(const TStr& GraphName) { GraphNm=GraphName; }
80    int GetTime(const TTmUnit& TimeUnit) const { return Time.GetInUnits(TimeUnit); }
81    int GetVals() const { return ValStatH.Len(); }
82    bool HasVal(const TGStatVal& StatVal) const;
83    double GetVal(const TGStatVal& StatVal) const;
84    void SetVal(const TGStatVal& StatVal, const double& Val);
85    int GetDistrs() const { return DistrStatH.Len(); }
86    bool HasDistr(const TGStatDistr& Distr) const { return DistrStatH.IsKey(Distr); }
87    const TFltPrV& GetDistr(const TGStatDistr& Distr) const;
88    void GetDistr(const TGStatDistr& Distr, TFltPrV& FltPrV) const;
89    void SetDistr(const TGStatDistr& Distr, const TFltPrV& FltPrV);
90    int GetNodes() const { return (int) GetVal(gsvNodes); }
91    int GetEdges() const { return (int) GetVal(gsvEdges); }
92    void TakeStat(const PNGraph& Graph, const TSecTm& Time, TFSet StatFSet, const TStr& GraphName);
93    void TakeStat(const PUNGraph& Graph, const TSecTm& Time, TFSet StatFSet, const TStr& GraphName);
94    template <class PGraph> void TakeStat(const PGraph& Graph, const TSecTm& Time, TFSet StatFSet, const TStr& GraphName);
95    template <class PGraph> void TakeBasicStat(const PGraph& Graph, const bool& IsMxWcc=false);
96    template <class PGraph> void TakeBasicStat(const PGraph& Graph, TFSet FSet, const bool& IsMxWcc=false);
97    template <class PGraph> void TakeSccStat(const PGraph& Graph, TFSet StatFSet);
98    template <class PGraph> void TakeBccStat(const PGraph& Graph, TFSet StatFSet);
99    template <class PGraph> void TakeDegDistr(const PGraph& Graph);
100    template <class PGraph> void TakeDegDistr(const PGraph& Graph, TFSet StatFSet);
101    template <class PGraph> void TakeDiam(const PGraph& Graph, const bool& IsMxWcc=false);
102    template <class PGraph> void TakeDiam(const PGraph& Graph, TFSet StatFSet, const bool& IsMxWcc=false);
103    template <class PGraph> void TakeConnComp(const PGraph& Graph);
104    template <class PGraph> void TakeConnComp(const PGraph& Graph, TFSet StatFSet);
105    template <class PGraph> void TakeClustCf(const PGraph& Graph, const int& SampleNodes=-1);
106    template <class PGraph> void TakeTriadPart(const PGraph& Graph);
107    void TakeSpectral(const PNGraph& Graph, const int _TakeSngVals = -1);
108    void TakeSpectral(const PNGraph& Graph, TFSet StatFSet, int _TakeSngVals = -1);
109    void Plot(const TGStatDistr& Distr, const TStr& FNmPref, TStr Desc=TStr(), bool PowerFit=false) const;
110    void Plot(const TFSet& FSet, const TStr& FNmPref, const TStr& Desc=TStr(), bool PowerFit=false) const;
111    void PlotAll(const TStr& FNmPref, TStr Desc=TStr(), bool PowerFit=false) const;
112    void DumpValStat();
113    void AvgGStat(const PGStatVec& GStatVec, const bool& ClipAt1=false);
114    void AvgGStat(const TGStatV& GStatV, const bool& ClipAt1=false);
115    static TStr GetDistrStr(const TGStatDistr& Distr);
116    static TStr GetValStr(const TGStatVal& Val);
117    static TPlotInfo GetPlotInfo(const TGStatVal& Val);
118    static TPlotInfo GetPlotInfo(const TGStatDistr& Distr);
119    static TFSet NoStat();
120    static TFSet BasicStat();
121    static TFSet DegDStat();
122    static TFSet NoDiamStat();
123    static TFSet NoDistrStat();
124    static TFSet NoSvdStat();
125    static TFSet AllStat();
126    friend class TCmpByVal;
127    friend class TPt<TGStat>;
128  };
129  class TGStatVec {
130  public:
131    static uint MinNodesEdges;
132  private:
133    TCRef CRef;
134    TTmUnit TmUnit;
135    TFSet StatFSet;
136    TGStatV GStatV; 
137  public:
138    TGStatVec(const TTmUnit& _TmUnit=tmu1Sec);
139    TGStatVec(const TTmUnit& _TmUnit, const TFSet& TakeGrowthStat);
140    TGStatVec(const TGStatVec& GStat);
141    static PGStatVec New(const TTmUnit& _TmUnit=tmu1Sec);
142    static PGStatVec New(const TTmUnit& _TmUnit, const TFSet& TakeGrowthStat);
143    static PGStatVec Load(TSIn& SIn) { return new TGStatVec(SIn); }
144    TGStatVec(TSIn& SIn);
145    void Save(TSOut& SOut) const;
146    TGStatVec& operator = (const TGStatVec& GStat);
147    PGStat Add();
148    PGStat Add(const TSecTm& Time, const TStr& GraphNm=TStr());
149    void Add(const PGStat& Growth) { GStatV.Add(Growth); }
150    void Add(const PNGraph& Graph, const TSecTm& Time, const TStr& GraphNm=TStr());
151    void Add(const PUNGraph& Graph, const TSecTm& Time, const TStr& GraphNm=TStr());
152    void Add(const PNEGraph& Graph, const TSecTm& Time, const TStr& GraphNm=TStr());
153    void Clr() { GStatV.Clr(); }
154    void Sort(const TGStatVal& SortBy=gsvNodes, const bool& Asc=true);
155    int Len() const { return GStatV.Len(); }
156    bool Empty() const { return GStatV.Empty(); }
<span onclick='openModal()' class='match'>157    PGStat operator[](const int& ValN) const { return GStatV[ValN]; }
158    PGStat At(const int& ValN) const { return GStatV[ValN]; }
159    PGStat Last() const { return GStatV.Last(); }
</span>160    const TGStatV& GetGStatV() const { return GStatV; }
161    int GetTime(const int& ValN) const { return At(ValN)->GetTime(TmUnit); }
162    void Del(const int& ValN) { GStatV.Del(ValN); }
163    void DelLast() { GStatV.DelLast(); }
164    void DelBefore(const TSecTm& Tm);
165    void DelAfter(const TSecTm& Tm);
166    void DelSmallNodes(const int& MinNodes);
167    void SetTmUnit(const TTmUnit& TimeUnit) { TmUnit = TimeUnit; }
168    TTmUnit GetTmUnit() const { return TmUnit; }
169    void SetTakeStat(const TFSet& TakeStatSet) { StatFSet = TakeStatSet; }
170    bool HasVal(const TGStatVal& Stat) const { return StatFSet.In(Stat); }
171    bool HasDistr(const TGStatDistr& Stat) const { return StatFSet.In(Stat); }
172    void GetValV(const TGStatVal& XVal, const TGStatVal& YVal, TFltPrV& ValV) const;
173    PGStat GetAvgGStat(const bool& ClipAt1=false);
174    void Plot(const TGStatVal& XVal, const TGStatVal& YVal, const TStr& OutFNm, TStr& Desc,
175      const TGpScaleTy& Scale=gpsAuto, const bool& PowerFit=false) const;
176    void PlotAllVsX(const TGStatVal& XVal, const TStr& OutFNm, TStr Desc=TStr(), const TGpScaleTy& Scale=gpsAuto, const bool& PowerFit=false) const;
177    void ImposeDistr(const TGStatDistr& Distr, const TStr& FNmPref, TStr Desc=TStr(), const bool& ExpBin=false,
178      const bool& PowerFit=false, const TGpSeriesTy& PlotWith=gpwLinesPoints, const TStr& Style="") const;
179    void SaveTxt(const TStr& FNmPref, const TStr& Desc) const;
180    friend class TPt<TGStatVec>;
181  };
182  template <class PGraph>
183  void TGStat::TakeStat(const PGraph& Graph, const TSecTm& _Time, TFSet StatFSet, const TStr& GraphName) {
184    printf("**TakeStat:  G(%u, %u)\n", Graph->GetNodes(), Graph->GetEdges());
185    TExeTm ExeTm, FullTm;
186    Time = _Time;
187    GraphNm = GraphName;
188    if (StatFSet.In(gsvNone)) { return; }
189    TakeBasicStat(Graph, false);
190    TakeSccStat(Graph, StatFSet);
191    TakeBccStat(Graph, StatFSet);
192    if (StatFSet.In(gsdWcc)) {
193      PGraph WccG = TSnap::GetMxWcc(Graph);
194      TakeBasicStat(WccG, true);
195      SetVal(gsvWccSize, WccG->GetNodes()/double(Graph->GetNodes()));
196    }
197    TakeDegDistr(Graph, StatFSet);
198    if (StatFSet.In(gsvFullDiam) || StatFSet.In(gsvEffDiam) || StatFSet.In(gsdHops) ||
199     StatFSet.In(gsvEffWccDiam) || StatFSet.In(gsdWccHops) || StatFSet.In(gsdWcc) || StatFSet.In(gsdScc) ||
200     StatFSet.In(gsdClustCf) || StatFSet.In(gsvClustCf) || StatFSet.In(gsdTriadPart)) {
201      PNGraph NGraph = TSnap::ConvertGraph<PNGraph>(Graph, true);
202      TakeDiam(NGraph, StatFSet, false);
203      TakeConnComp(NGraph, StatFSet);
204      TakeSpectral(NGraph, StatFSet, -1);
205      if (StatFSet.In(gsdClustCf) || StatFSet.In(gsvClustCf)) {
206        TakeClustCf(NGraph); }
207      if (StatFSet.In(gsdTriadPart)) {
208        TakeTriadPart(NGraph); }
209      if (StatFSet.In(gsvFullDiam) || StatFSet.In(gsvEffWccDiam)) {
210        TakeDiam(TSnap::GetMxWcc(NGraph), StatFSet, true); }
211      printf("**[%s]\n", FullTm.GetTmStr());
212    }
213  }
214  template <class PGraph>
215  void TGStat::TakeBasicStat(const PGraph& Graph, const bool& IsMxWcc) {
216    TakeBasicStat(Graph, TFSet() | gsvBiDirEdges | gsvWccBiDirEdges, IsMxWcc);
217  }
218  template <class PGraph>
219  void TGStat::TakeBasicStat(const PGraph& Graph, TFSet FSet, const bool& IsMxWcc) {
220    TExeTm ExeTm;
221    if (! IsMxWcc) {
222      printf("basic...");
223      const int Nodes = Graph->GetNodes();
224      SetVal(gsvNodes, Nodes);
225      SetVal(gsvZeroNodes, TSnap::CntDegNodes(Graph, 0));
226      SetVal(gsvNonZNodes, Nodes - GetVal(gsvZeroNodes));
227      SetVal(gsvSrcNodes, Nodes - TSnap::CntOutDegNodes(Graph, 0));
228      SetVal(gsvDstNodes, Nodes - TSnap::CntInDegNodes(Graph, 0));
229      SetVal(gsvEdges, Graph->GetEdges());
230      if (! Graph->HasFlag(gfMultiGraph)) { SetVal(gsvUniqEdges, Graph->GetEdges()); }
231      else { SetVal(gsvUniqEdges, TSnap::CntUniqDirEdges(Graph)); }
232      if (FSet.In(gsvBiDirEdges)) {
233        if (Graph->HasFlag(gfDirected)) { SetVal(gsvBiDirEdges, TSnap::CntUniqBiDirEdges(Graph)); }
234        else { SetVal(gsvUniqEdges, GetVal(gsvEdges)); }
235      }
236      printf("[%s] ", ExeTm.GetTmStr());
237    } else {
238      printf("basic wcc...");
239      const int Nodes = Graph->GetNodes();
240      SetVal(gsvWccNodes, Nodes);
241      SetVal(gsvWccSrcNodes, Nodes - TSnap::CntOutDegNodes(Graph, 0));
242      SetVal(gsvWccDstNodes, Nodes - TSnap::CntInDegNodes(Graph, 0));
243      SetVal(gsvWccEdges, Graph->GetEdges());
244      if (! Graph->HasFlag(gfMultiGraph)) { SetVal(gsvWccUniqEdges, Graph->GetEdges()); }
245      else { SetVal(gsvWccUniqEdges, TSnap::CntUniqDirEdges(Graph)); }
246      if (FSet.In(gsvBiDirEdges)) {
247        if (Graph->HasFlag(gfDirected)) { SetVal(gsvWccBiDirEdges, TSnap::CntUniqBiDirEdges(Graph)); }
248        else { SetVal(gsvUniqEdges, GetVal(gsvEdges)); }
249      }
250      printf("[%s]  ", ExeTm.GetTmStr());
251    }
252  }
253  template <class PGraph>
254  void TGStat::TakeDegDistr(const PGraph& Graph) {
255    TakeDegDistr(Graph, TFSet() | gsdInDeg | gsdOutDeg);
256  }
257  template <class PGraph>
258  void TGStat::TakeDegDistr(const PGraph& Graph, TFSet StatFSet) {
259    TExeTm ExeTm;
260    if (StatFSet.In(gsdOutDeg) || StatFSet.In(gsdOutDeg)) {
261      printf("deg:"); }
262    if (StatFSet.In(gsdInDeg)) {
263      printf("-in");
264      TFltPrV& InDegV = DistrStatH.AddDat(gsdInDeg);
265      TSnap::GetInDegCnt(Graph, InDegV);
266    }
267    if (StatFSet.In(gsdOutDeg)) {
268      printf("-out");
269      TFltPrV& OutDegV = DistrStatH.AddDat(gsdOutDeg);
270      TSnap::GetOutDegCnt(Graph, OutDegV);
271    }
272    if (StatFSet.In(gsdOutDeg) || StatFSet.In(gsdOutDeg)) {
273      printf("[%s]  ", ExeTm.GetTmStr()); }
274  }
275  template <class PGraph>
276  void TGStat::TakeDiam(const PGraph& Graph, const bool& IsMxWcc) {
277    TakeDiam(Graph, TFSet() | gsvFullDiam | gsvEffDiam | gsdHops |
278      gsvEffWccDiam| gsdWccHops, IsMxWcc);
279  }
280  template <class PGraph>
281  void TGStat::TakeDiam(const PGraph& Graph, TFSet StatFSet, const bool& IsMxWcc) {
282    TExeTm ExeTm;
283    if (! IsMxWcc) {
284      if (StatFSet.In(gsvFullDiam) || StatFSet.In(gsvEffDiam) || StatFSet.In(gsdHops)) {
285        printf("anf:%druns...", NDiamRuns); }
286      if (StatFSet.In(gsvEffDiam) || StatFSet.In(gsdHops)) {
287        TMom DiamMom;  ExeTm.Tick();
288        TIntFltKdV DistNbrsV;
289        for (int r = 0; r < NDiamRuns; r++) {
290          TSnap::GetAnf(Graph, DistNbrsV, -1, false, 32);
291          DiamMom.Add(TSnap::TSnapDetail::CalcEffDiam(DistNbrsV, 0.9));
292          printf(".");
293        }
294        DiamMom.Def();
295        SetVal(gsvEffDiam, DiamMom.GetMean());
296        SetVal(gsvEffDiamDev, DiamMom.GetSDev());
297        TFltPrV& HopsV = DistrStatH.AddDat(gsdHops);
298        HopsV.Gen(DistNbrsV.Len(), 0);
299        for (int i = 0; i < DistNbrsV.Len(); i++) {
300          HopsV.Add(TFltPr(DistNbrsV[i].Key(), DistNbrsV[i].Dat)); }
301        printf("  anf-eff %.1f[%s]", DiamMom.GetMean(), ExeTm.GetTmStr());
302      }
303    } else {
304      if (StatFSet.In(gsvEffWccDiam) || StatFSet.In(gsdWccHops)) { printf("wcc diam..."); }
305      if (StatFSet.In(gsvFullDiam)) {
306        TMom DiamMom;  ExeTm.Tick();
307        for (int r = 0; r < NDiamRuns; r++) {
308          DiamMom.Add(TSnap::GetBfsFullDiam(Graph, 1, false));
309          printf("."); }
310        DiamMom.Def();
311        SetVal(gsvFullDiam, DiamMom.GetMean());
312        SetVal(gsvFullDiamDev, DiamMom.GetSDev());
313        printf("  bfs-full %g[%s]", DiamMom.GetMean(), ExeTm.GetTmStr());
314      }
315      if (StatFSet.In(gsvEffWccDiam) || StatFSet.In(gsdWccHops)) {
316        TMom DiamMom; ExeTm.Tick();
317        TIntFltKdV DistNbrsV;
318        for (int r = 0; r < NDiamRuns; r++) {
319          TSnap::GetAnf(Graph, DistNbrsV, -1, false, 32);
320          DiamMom.Add(TSnap::TSnapDetail::CalcEffDiam(DistNbrsV, 0.9));
321          printf(".");
322        }
323        DiamMom.Def();
324        SetVal(gsvEffWccDiam, DiamMom.GetMean());
325        SetVal(gsvEffWccDiamDev, DiamMom.GetSDev());
326        TFltPrV& WccHopsV = DistrStatH.AddDat(gsdWccHops);
327        WccHopsV.Gen(DistNbrsV.Len(), 0);
328        for (int i = 0; i < DistNbrsV.Len(); i++) {
329          WccHopsV.Add(TFltPr(DistNbrsV[i].Key(), DistNbrsV[i].Dat)); }
330        printf("  anf-wcceff %.1f[%s]", DiamMom.GetMean(), ExeTm.GetTmStr());
331      }
332    }
333  }
334  template <class PGraph>
335  void TGStat::TakeConnComp(const PGraph& Graph) {
336    TakeConnComp(Graph, TFSet() | gsdWcc | gsdScc);
337  }
338  template <class PGraph>
339  void TGStat::TakeConnComp(const PGraph& Graph, TFSet StatFSet) {
340    TExeTm ExeTm;
341    if (StatFSet.In(gsdWcc)) {
342      printf("wcc...");
343      TIntPrV WccSzCntV1;
344      TSnap::GetWccSzCnt(Graph, WccSzCntV1);
345      TFltPrV& WccSzCntV = DistrStatH.AddDat(gsdWcc);
346      WccSzCntV.Gen(WccSzCntV1.Len(), 0);
347      for (int i = 0; i < WccSzCntV1.Len(); i++)
348        WccSzCntV.Add(TFltPr(WccSzCntV1[i].Val1(), WccSzCntV1[i].Val2()));
349    }
350    if (StatFSet.In(gsdScc)) {
351      printf("scc...");
352      TIntPrV SccSzCntV1;
353      TSnap::GetSccSzCnt(Graph, SccSzCntV1);
354      TFltPrV& SccSzCntV = DistrStatH.AddDat(gsdScc);
355      SccSzCntV.Gen(SccSzCntV1.Len(), 0);
356      for (int i = 0; i < SccSzCntV1.Len(); i++)
357        SccSzCntV.Add(TFltPr(SccSzCntV1[i].Val1(), SccSzCntV1[i].Val2()));
358    }
359    if (StatFSet.In(gsdWcc) || StatFSet.In(gsdScc)) { printf("[%s]  ", ExeTm.GetTmStr()); }
360  }
361  template <class PGraph>
362  void TGStat::TakeSccStat(const PGraph& Graph, TFSet StatFSet) {
363    TExeTm ExeTm;
364    if (StatFSet.In(gsvSccNodes) || StatFSet.In(gsvSccEdges) || StatFSet.In(gsvSccSize)) {
365      printf("scc...");
366      PGraph SccG = TSnap::GetMxScc(Graph);
367      SetVal(gsvSccNodes, SccG->GetNodes());
368      SetVal(gsvSccEdges, SccG->GetEdges());
369      SetVal(gsvSccSize, SccG->GetNodes()/double(Graph->GetNodes()));
370      printf("[%s]  ", ExeTm.GetTmStr());
371    }
372  }
373  template <class PGraph>
374  void TGStat::TakeBccStat(const PGraph& Graph, TFSet StatFSet) {
375    TExeTm ExeTm;
376    if (StatFSet.In(gsvBccNodes) || StatFSet.In(gsvBccEdges) || StatFSet.In(gsvBccSize)) {
377      printf("bcc...");
378      PGraph BccG = TSnap::GetMxBiCon(Graph);
379      SetVal(gsvBccNodes, BccG->GetNodes());
380      SetVal(gsvBccEdges, BccG->GetEdges());
381      SetVal(gsvBccSize, BccG->GetNodes()/double(Graph->GetNodes()));
382      printf("[%s]  ", ExeTm.GetTmStr());
383    }
384  }
385  template <class PGraph>
386  void TGStat::TakeClustCf(const PGraph& Graph, const int& SampleNodes) {
387    TExeTm ExeTm;
388    printf("clustcf...");
389    TFltPrV& ClustCfV = DistrStatH.AddDat(gsdClustCf);
390    int64 Open, Close;
391    const double ClustCf =  TSnap::GetClustCf(Graph, ClustCfV, Close, Open, SampleNodes);
392    SetVal(gsvClustCf, ClustCf);
393    SetVal(gsvOpenTriads, static_cast<double>(Open));
394    SetVal(gsvClosedTriads, static_cast<double>(Close));
395    printf("[%s]  ", ExeTm.GetTmStr());
396  }
397  template <class PGraph>
398  void TGStat::TakeTriadPart(const PGraph& Graph) {
399    TExeTm ExeTm;
400    printf("triadparticip...");
401    TFltPrV& TriadCntV = DistrStatH.AddDat(gsdTriadPart);
402    TIntPrV CntV;
403    TSnap::GetTriadParticip(Graph, CntV);
404    TriadCntV.Gen(CntV.Len(), 0);
405    for (int i = 0; i < CntV.Len(); i++) {
406      TriadCntV.Add(TFltPr(CntV[i].Val1(), CntV[i].Val2()));
407    }
408    printf("[%s]  ", ExeTm.GetTmStr());
409  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-adox.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gstat.h</div>
                </div>
                <div class="column column_space"><pre><code>95    TStr GetFldNm(const int& FldN) const {
96      return Table->Fields->Fields[FldN]->FieldName.c_str();}
97    TStr GetValStr(const int& FldN) const {
98      return Table->Fields->Fields[FldN]->AsString.c_str();}
99    void PutValStr(const TStr& FldNm, const TStr& FldVal) const {
</pre></code></div>
                <div class="column column_space"><pre><code>157    PGStat operator[](const int& ValN) const { return GStatV[ValN]; }
158    PGStat At(const int& ValN) const { return GStatV[ValN]; }
159    PGStat Last() const { return GStatV.Last(); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    