
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 83, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHollywood.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &lt;map&gt;
10  #include &lt;functional&gt;
11  #include &quot;ILexer.h&quot;
12  #include &quot;Scintilla.h&quot;
13  #include &quot;SciLexer.h&quot;
14  #include &quot;WordList.h&quot;
15  #include &quot;LexAccessor.h&quot;
16  #include &quot;StyleContext.h&quot;
17  #include &quot;CharacterSet.h&quot;
18  #include &quot;LexerModule.h&quot;
19  #include &quot;OptionSet.h&quot;
20  #include &quot;DefaultLexer.h&quot;
21  using namespace Scintilla;
22  using namespace Lexilla;
23  static int character_classification[128] =
24  {
25  	0, 
26  	0, 
27  	0, 
28  	0, 
29  	0, 
30  	0, 
31  	0, 
32  	0, 
33  	0, 
34  	1, 
35  	1, 
36  	0, 
37  	0, 
38  	1, 
39  	0, 
40  	0, 
41  	0, 
42  	0, 
43  	0, 
44  	0, 
45  	0, 
46  	0, 
47  	0, 
48  	0, 
49  	0, 
50  	0, 
51  	0, 
52  	0, 
53  	0, 
54  	0, 
55  	0, 
56  	0, 
57  	1, 
58  	4, 
59  	0, 
60  	0, 
61  	4, 
62  	2, 
63  	2, 
64  	2, 
65  	2, 
66  	2, 
67  	2, 
68  	2, 
69  	2, 
70  	2, 
71  	4, 
72  	2, 
73  	28, 
74  	28, 
75  	28, 
76  	28, 
77  	28, 
78  	28, 
79  	28, 
80  	28, 
81  	28, 
82  	28, 
83  	2, 
84  	2, 
85  	2, 
86  	2, 
87  	2, 
88  	2, 
89  	0, 
90  	84, 
91  	84, 
92  	84, 
93  	84, 
94  	84, 
95  	84, 
96  	68, 
97  	68, 
98  	68, 
99  	68, 
100  	68, 
101  	68, 
102  	68, 
103  	68, 
104  	68, 
105  	68, 
106  	68, 
107  	68, 
108  	68, 
109  	68, 
110  	68, 
111  	68, 
112  	68, 
113  	68, 
114  	68, 
115  	68, 
116  	2, 
117  	2, 
118  	2, 
119  	2, 
120  	68, 
121  	2, 
122  	84, 
123  	84, 
124  	84, 
125  	84, 
126  	84, 
127  	84, 
128  	68, 
129  	68, 
130  	68, 
131  	68, 
132  	68, 
133  	68, 
134  	68, 
135  	68, 
136  	68, 
137  	68, 
138  	68, 
139  	68, 
140  	68, 
141  	68, 
142  	68, 
143  	68, 
144  	68, 
145  	68, 
146  	68, 
147  	68, 
148  	2, 
149  	2, 
150  	2, 
151  	2, 
152  	0, 
153  };
154  static bool IsSpace(int c) {
155  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 1);
156  }
157  static bool IsOperator(int c) {
158  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 2);
159  }
160  static bool IsIdentifier(int c) {
161  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 4);
162  }
163  static bool IsDigit(int c) {
164  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 8);
165  }
166  static bool IsHexDigit(int c) {
167  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 16);
168  }
169  static int LowerCase(int c)
170  {
171  	if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;)
172  		return &#x27;a&#x27; + c - &#x27;A&#x27;;
173  	return c;
174  }
175  static int CheckHollywoodFoldPoint(char const *token) {
176  	if (!strcmp(token, &quot;function&quot;)) {
177  		return 1;
178  	}
179  	if (!strcmp(token, &quot;endfunction&quot;)) {
180  		return -1;
181  	}
182  	return 0;
183  }
184  struct OptionsHollywood {
185  	bool fold;
186  	bool foldCompact;
187  	OptionsHollywood() {
188  		fold = false;
189  		foldCompact = false;
190  	}
191  };
192  static const char * const hollywoodWordListDesc[] = {
193  	&quot;Hollywood keywords&quot;,
194  	&quot;Hollywood standard API functions&quot;,
195  	&quot;Hollywood plugin API functions&quot;,
196  	&quot;Hollywood plugin methods&quot;,
197  	0
198  };
199  struct OptionSetHollywood : public OptionSet&lt;OptionsHollywood&gt; {
200  	OptionSetHollywood(const char * const wordListDescriptions[]) {
201  		DefineProperty(&quot;fold&quot;, &amp;OptionsHollywood::fold);
202  		DefineProperty(&quot;fold.compact&quot;, &amp;OptionsHollywood::foldCompact);
203  		DefineWordListSets(wordListDescriptions);
204  	}
205  };
206  class LexerHollywood : public DefaultLexer {
207  	int (*CheckFoldPoint)(char const *);
208  	WordList keywordlists[4];	
209  	OptionsHollywood options;
210  	OptionSetHollywood osHollywood;
211  public:
212  	LexerHollywood(int (*CheckFoldPoint_)(char const *), const char * const wordListDescriptions[]) :
213  						 DefaultLexer(&quot;hollywood&quot;, SCLEX_HOLLYWOOD),
214  						 CheckFoldPoint(CheckFoldPoint_),
215  						 osHollywood(wordListDescriptions) {
216  	}
217  	virtual ~LexerHollywood() {
218  	}
219  	void SCI_METHOD Release() override {
220  		delete this;
221  	}
222  	int SCI_METHOD Version() const override {
223  		return lvRelease5;
224  	}
225  	const char * SCI_METHOD PropertyNames() override {
226  		return osHollywood.PropertyNames();
227  	}
228  	int SCI_METHOD PropertyType(const char *name) override {
229  		return osHollywood.PropertyType(name);
230  	}
231  	const char * SCI_METHOD DescribeProperty(const char *name) override {
232  		return osHollywood.DescribeProperty(name);
233  	}
234  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
235  	const char * SCI_METHOD PropertyGet(const char* key) override {
236  		return osHollywood.PropertyGet(key);
237  	}
238  	const char * SCI_METHOD DescribeWordListSets() override {
239  		return osHollywood.DescribeWordListSets();
240  	}
241  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
242  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
243  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
244  	void * SCI_METHOD PrivateCall(int, void *) override {
245  		return 0;
246  	}
247  	static ILexer5 *LexerFactoryHollywood() {
248  		return new LexerHollywood(CheckHollywoodFoldPoint, hollywoodWordListDesc);
249  	}
250  };
251  Sci_Position SCI_METHOD LexerHollywood::PropertySet(const char *key, const char *val) {
252  	if (osHollywood.PropertySet(&amp;options, key, val)) {
253  		return 0;
254  	}
255  	return -1;
256  }
257  Sci_Position SCI_METHOD LexerHollywood::WordListSet(int n, const char *wl) {
258  	WordList *wordListN = 0;
259  	switch (n) {
260  	case 0:
261  		wordListN = &amp;keywordlists[0];
262  		break;
263  	case 1:
264  		wordListN = &amp;keywordlists[1];
265  		break;
266  	case 2:
267  		wordListN = &amp;keywordlists[2];
268  		break;
269  	case 3:
<span onclick='openModal()' class='match'>270  		wordListN = &amp;keywordlists[3];
271  		break;
272  	}
273  	Sci_Position firstModification = -1;
274  	if (wordListN) {
275  		WordList wlNew;
276  		wlNew.Set(wl);
277  		if (*wordListN != wlNew) {
278  			wordListN-&gt;Set(wl);
279  			firstModification = 0;
280  		}
281  	}
282  	return firstModification;	
283  }
284  void SCI_METHOD LexerHollywood::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
285  	LexAccessor styler(pAccess);
286  	styler.StartAt(startPos);
</span>287  	bool inString = false;
288  	StyleContext sc(startPos, length, initStyle, styler);
289  	for (; ; sc.Forward())
290  	 {
291  	 	if (sc.atLineStart) inString = false;
292  	 	if (sc.ch == &#x27;\&quot;&#x27; &amp;&amp; sc.chPrev != &#x27;\\&#x27;) inString = !inString;
293  		if (sc.state == SCE_HOLLYWOOD_IDENTIFIER) {
294  			if (!IsIdentifier(sc.ch)) {				
295  				char s[100];
296  				int kstates[4] = {
297  					SCE_HOLLYWOOD_KEYWORD,
298  					SCE_HOLLYWOOD_STDAPI,
299  					SCE_HOLLYWOOD_PLUGINAPI,
300  					SCE_HOLLYWOOD_PLUGINMETHOD,
301  				};
302  				sc.GetCurrentLowered(s, sizeof(s));
303  				for (int i = 0; i &lt; 4; i++) {
304  					if (keywordlists[i].InList(s)) {
305  						sc.ChangeState(kstates[i]);
306  					}
307  				}
308  				sc.SetState(SCE_HOLLYWOOD_DEFAULT);				
309  			}
310  		} else if (sc.state == SCE_HOLLYWOOD_OPERATOR) {
311  			sc.SetState(SCE_HOLLYWOOD_DEFAULT);
312  		} else if (sc.state == SCE_HOLLYWOOD_PREPROCESSOR) {
313  			if (!IsIdentifier(sc.ch))
314  				sc.SetState(SCE_HOLLYWOOD_DEFAULT);
315  		} else if (sc.state == SCE_HOLLYWOOD_CONSTANT) {
316  			if (!IsIdentifier(sc.ch))
317  				sc.SetState(SCE_HOLLYWOOD_DEFAULT);
318  		} else if (sc.state == SCE_HOLLYWOOD_NUMBER) {
319  			if (!IsDigit(sc.ch) &amp;&amp; sc.ch != &#x27;.&#x27;)
320  				sc.SetState(SCE_HOLLYWOOD_DEFAULT);
321  		} else if (sc.state == SCE_HOLLYWOOD_HEXNUMBER) {
322  			if (!IsHexDigit(sc.ch))
323  				sc.SetState(SCE_HOLLYWOOD_DEFAULT);
324  		} else if (sc.state == SCE_HOLLYWOOD_STRING) {
325  			if (sc.ch == &#x27;&quot;&#x27;) {
326  				sc.ForwardSetState(SCE_HOLLYWOOD_DEFAULT);
327  			}
328  			if (sc.atLineEnd) {
329  				sc.SetState(SCE_HOLLYWOOD_DEFAULT);
330  			}
331  		} else if (sc.state == SCE_HOLLYWOOD_COMMENT) {
332  			if (sc.atLineEnd) {
333  				sc.SetState(SCE_HOLLYWOOD_DEFAULT);
334  			}
335  		} else if (sc.state == SCE_HOLLYWOOD_COMMENTBLOCK) {
336  			if (sc.Match(&quot;*/&quot;) &amp;&amp; !inString) {
337  				sc.Forward();
338  				sc.ForwardSetState(SCE_HOLLYWOOD_DEFAULT);
339  			}
340  		} else if (sc.state == SCE_HOLLYWOOD_STRINGBLOCK) {
341  			if (sc.Match(&quot;]]&quot;) &amp;&amp; !inString) {
342  				sc.Forward();
343  				sc.ForwardSetState(SCE_HOLLYWOOD_DEFAULT);
344  			}			
345  		}
346  		if (sc.state == SCE_HOLLYWOOD_DEFAULT) {
347  			if (sc.Match(&#x27;;&#x27;)) {
348  				sc.SetState(SCE_HOLLYWOOD_COMMENT);
349  			} else if (sc.Match(&quot;&amp;bsol;*&quot;)) {
350  				sc.SetState(SCE_HOLLYWOOD_COMMENTBLOCK);
351  				sc.Forward();
352  			} else if (sc.Match(&quot;[[&quot;)) {
353  				sc.SetState(SCE_HOLLYWOOD_STRINGBLOCK);
354  				sc.Forward();				
355  			} else if (sc.Match(&#x27;&quot;&#x27;)) {
356  				sc.SetState(SCE_HOLLYWOOD_STRING);
357  			} else if (sc.Match(&#x27;$&#x27;)) { 
358  				sc.SetState(SCE_HOLLYWOOD_HEXNUMBER);
359  			} else if (sc.Match(&quot;0x&quot;) || sc.Match(&quot;0X&quot;)) {  
360  				sc.SetState(SCE_HOLLYWOOD_HEXNUMBER);
361  				sc.Forward();
362  			} else if (sc.ch == &#x27;.&#x27; &amp;&amp; (sc.chNext &gt;= &#x27;0&#x27; &amp;&amp; sc.chNext &lt;= &#x27;9&#x27;)) {  
363  				sc.SetState(SCE_HOLLYWOOD_NUMBER);
364  				sc.Forward();	
365  			} else if (IsDigit(sc.ch)) {
366  				sc.SetState(SCE_HOLLYWOOD_NUMBER);
367  			} else if (sc.Match(&#x27;#&#x27;)) {
368  				sc.SetState(SCE_HOLLYWOOD_CONSTANT);
369  			} else if (sc.Match(&#x27;@&#x27;)) {
370  				sc.SetState(SCE_HOLLYWOOD_PREPROCESSOR);	
371  			} else if (IsOperator(sc.ch)) {
372  				sc.SetState(SCE_HOLLYWOOD_OPERATOR);
373  			} else if (IsIdentifier(sc.ch)) {
374  				sc.SetState(SCE_HOLLYWOOD_IDENTIFIER);
375  			}
376  		}
377  		if (!sc.More())
378  			break;
379  	}
380  	sc.Complete();
381  }
382  void SCI_METHOD LexerHollywood::Fold(Sci_PositionU startPos, Sci_Position length, int &amp;bsol;* initStyle */, IDocument *pAccess) {
383  	if (!options.fold)
384  		return;
385  	LexAccessor styler(pAccess);
386  	Sci_PositionU lengthDoc = startPos + length;
387  	int visibleChars = 0;
388  	Sci_Position lineCurrent = styler.GetLine(startPos);
389  	int levelPrev = styler.LevelAt(lineCurrent) &amp; SC_FOLDLEVELNUMBERMASK;
390  	int levelCurrent = levelPrev;
391  	char chNext = styler[startPos];
392  	int styleNext = styler.StyleAt(startPos);
393  	int done = 0;
394  	char word[256];
395  	int wordlen = 0;
396  	for (Sci_PositionU i = startPos; i &lt; lengthDoc; i++) {
397  		char ch = chNext;
398  		chNext = styler.SafeGetCharAt(i + 1);
399  		int style = styleNext;
400  		styleNext = styler.StyleAt(i + 1);
401  		bool atEOL = (ch == &#x27;\r&#x27; &amp;&amp; chNext != &#x27;\n&#x27;) || (ch == &#x27;\n&#x27;);
402  		if (!done) {
403  			if (wordlen) { 
404  				word[wordlen] = static_cast&lt;char&gt;(LowerCase(ch));
405  				if (!IsIdentifier(ch)) { 
406  					word[wordlen] = &#x27;\0&#x27;;
407  					levelCurrent += CheckFoldPoint(word);
408  					done = 1;
409  				} else if (wordlen &lt; 255) {
410  					wordlen++;
411  				}
412  			} else { 
413  				if (!IsSpace(ch)) {
414  					if (style != SCE_HOLLYWOOD_COMMENTBLOCK &amp;&amp; IsIdentifier(ch)) {
415  						word[0] = static_cast&lt;char&gt;(LowerCase(ch));
416  						wordlen = 1;
417  					} else 
418  						done = 1;
419  				}
420  			}
421  		}		
422  		if (atEOL) {
423  			int lev = levelPrev;
424  			if (visibleChars == 0 &amp;&amp; options.foldCompact) {
425  				lev |= SC_FOLDLEVELWHITEFLAG;
426  			}
427  			if ((levelCurrent &gt; levelPrev) &amp;&amp; (visibleChars &gt; 0)) {
428  				lev |= SC_FOLDLEVELHEADERFLAG;
429  			}
430  			if (lev != styler.LevelAt(lineCurrent)) {
431  				styler.SetLevel(lineCurrent, lev);
432  			}
433  			lineCurrent++;
434  			levelPrev = levelCurrent;
435  			visibleChars = 0;
436  			done = 0;
437  			wordlen = 0;			
438  		}
439  		if (!IsSpace(ch)) {
440  			visibleChars++;
441  		}
442  	}
443  	int flagsNext = styler.LevelAt(lineCurrent) &amp; ~SC_FOLDLEVELNUMBERMASK;
444  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);	
445  }
446  LexerModule lmHollywood(SCLEX_HOLLYWOOD, LexerHollywood::LexerFactoryHollywood, &quot;hollywood&quot;, hollywoodWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBasic.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &lt;map&gt;
10  #include &lt;functional&gt;
11  #include &quot;ILexer.h&quot;
12  #include &quot;Scintilla.h&quot;
13  #include &quot;SciLexer.h&quot;
14  #include &quot;WordList.h&quot;
15  #include &quot;LexAccessor.h&quot;
16  #include &quot;StyleContext.h&quot;
17  #include &quot;CharacterSet.h&quot;
18  #include &quot;LexerModule.h&quot;
19  #include &quot;OptionSet.h&quot;
20  #include &quot;DefaultLexer.h&quot;
21  using namespace Scintilla;
22  using namespace Lexilla;
23  static int character_classification[128] =
24  {
25  		0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,
26  		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
27  		1,  2,  0,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  10, 2,
28  	 60, 60, 28, 28, 28, 28, 28, 28, 28, 28,  2,  2,  2,  2,  2,  2,
29  		2, 84, 84, 84, 84, 84, 84, 68, 68, 68, 68, 68, 68, 68, 68, 68,
30  	 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,  2,  2,  2,  2, 68,
31  		2, 84, 84, 84, 84, 84, 84, 68, 68, 68, 68, 68, 68, 68, 68, 68,
32  	 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,  2,  2,  2,  2,  0
33  };
34  static bool IsSpace(int c) {
35  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 1);
36  }
37  static bool IsOperator(int c) {
38  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 2);
39  }
40  static bool IsIdentifier(int c) {
41  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 4);
42  }
43  static bool IsDigit(int c) {
44  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 8);
45  }
46  static bool IsHexDigit(int c) {
47  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 16);
48  }
49  static bool IsBinDigit(int c) {
50  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 32);
51  }
52  static bool IsLetter(int c) {
53  	return c &lt; 128 &amp;&amp; (character_classification[c] &amp; 64);
54  }
55  static int LowerCase(int c)
56  {
57  	if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;)
58  		return &#x27;a&#x27; + c - &#x27;A&#x27;;
59  	return c;
60  }
61  static int CheckBlitzFoldPoint(char const *token, int &amp;level) {
62  	if (!strcmp(token, &quot;function&quot;) ||
63  		!strcmp(token, &quot;type&quot;)) {
64  		level |= SC_FOLDLEVELHEADERFLAG;
65  		return 1;
66  	}
67  	if (!strcmp(token, &quot;end function&quot;) ||
68  		!strcmp(token, &quot;end type&quot;)) {
69  		return -1;
70  	}
71  	return 0;
72  }
73  static int CheckPureFoldPoint(char const *token, int &amp;level) {
74  	if (!strcmp(token, &quot;procedure&quot;) ||
75  		!strcmp(token, &quot;enumeration&quot;) ||
76  		!strcmp(token, &quot;interface&quot;) ||
77  		!strcmp(token, &quot;structure&quot;)) {
78  		level |= SC_FOLDLEVELHEADERFLAG;
79  		return 1;
80  	}
81  	if (!strcmp(token, &quot;endprocedure&quot;) ||
82  		!strcmp(token, &quot;endenumeration&quot;) ||
83  		!strcmp(token, &quot;endinterface&quot;) ||
84  		!strcmp(token, &quot;endstructure&quot;)) {
85  		return -1;
86  	}
87  	return 0;
88  }
89  static int CheckFreeFoldPoint(char const *token, int &amp;level) {
90  	if (!strcmp(token, &quot;function&quot;) ||
91  		!strcmp(token, &quot;sub&quot;) ||
92  		!strcmp(token, &quot;enum&quot;) ||
93  		!strcmp(token, &quot;type&quot;) ||
94  		!strcmp(token, &quot;union&quot;) ||
95  		!strcmp(token, &quot;property&quot;) ||
96  		!strcmp(token, &quot;destructor&quot;) ||
97  		!strcmp(token, &quot;constructor&quot;)) {
98  		level |= SC_FOLDLEVELHEADERFLAG;
99  		return 1;
100  	}
101  	if (!strcmp(token, &quot;end function&quot;) ||
102  		!strcmp(token, &quot;end sub&quot;) ||
103  		!strcmp(token, &quot;end enum&quot;) ||
104  		!strcmp(token, &quot;end type&quot;) ||
105  		!strcmp(token, &quot;end union&quot;) ||
106  		!strcmp(token, &quot;end property&quot;) ||
107  		!strcmp(token, &quot;end destructor&quot;) ||
108  		!strcmp(token, &quot;end constructor&quot;)) {
109  		return -1;
110  	}
111  	return 0;
112  }
113  struct OptionsBasic {
114  	bool fold;
115  	bool foldSyntaxBased;
116  	bool foldCommentExplicit;
117  	std::string foldExplicitStart;
118  	std::string foldExplicitEnd;
119  	bool foldExplicitAnywhere;
120  	bool foldCompact;
121  	OptionsBasic() {
122  		fold = false;
123  		foldSyntaxBased = true;
124  		foldCommentExplicit = false;
125  		foldExplicitStart = &quot;&quot;;
126  		foldExplicitEnd   = &quot;&quot;;
127  		foldExplicitAnywhere = false;
128  		foldCompact = true;
129  	}
130  };
131  static const char * const blitzbasicWordListDesc[] = {
132  	&quot;BlitzBasic Keywords&quot;,
133  	&quot;user1&quot;,
134  	&quot;user2&quot;,
135  	&quot;user3&quot;,
136  	0
137  };
138  static const char * const purebasicWordListDesc[] = {
139  	&quot;PureBasic Keywords&quot;,
140  	&quot;PureBasic PreProcessor Keywords&quot;,
141  	&quot;user defined 1&quot;,
142  	&quot;user defined 2&quot;,
143  	0
144  };
145  static const char * const freebasicWordListDesc[] = {
146  	&quot;FreeBasic Keywords&quot;,
147  	&quot;FreeBasic PreProcessor Keywords&quot;,
148  	&quot;user defined 1&quot;,
149  	&quot;user defined 2&quot;,
150  	0
151  };
152  struct OptionSetBasic : public OptionSet&lt;OptionsBasic&gt; {
153  	OptionSetBasic(const char * const wordListDescriptions[]) {
154  		DefineProperty(&quot;fold&quot;, &amp;OptionsBasic::fold);
155  		DefineProperty(&quot;fold.basic.syntax.based&quot;, &amp;OptionsBasic::foldSyntaxBased,
156  			&quot;Set this property to 0 to disable syntax based folding.&quot;);
157  		DefineProperty(&quot;fold.basic.comment.explicit&quot;, &amp;OptionsBasic::foldCommentExplicit,
158  			&quot;This option enables folding explicit fold points when using the Basic lexer. &quot;
159  			&quot;Explicit fold points allows adding extra folding by placing a ;{ (BB/PB) or &#x27;{ (FB) comment at the start &quot;
160  			&quot;and a ;} (BB/PB) or &#x27;} (FB) at the end of a section that should be folded.&quot;);
161  		DefineProperty(&quot;fold.basic.explicit.start&quot;, &amp;OptionsBasic::foldExplicitStart,
162  			&quot;The string to use for explicit fold start points, replacing the standard ;{ (BB/PB) or &#x27;{ (FB).&quot;);
163  		DefineProperty(&quot;fold.basic.explicit.end&quot;, &amp;OptionsBasic::foldExplicitEnd,
164  			&quot;The string to use for explicit fold end points, replacing the standard ;} (BB/PB) or &#x27;} (FB).&quot;);
165  		DefineProperty(&quot;fold.basic.explicit.anywhere&quot;, &amp;OptionsBasic::foldExplicitAnywhere,
166  			&quot;Set this property to 1 to enable explicit fold points anywhere, not just in line comments.&quot;);
167  		DefineProperty(&quot;fold.compact&quot;, &amp;OptionsBasic::foldCompact);
168  		DefineWordListSets(wordListDescriptions);
169  	}
170  };
171  class LexerBasic : public DefaultLexer {
172  	char comment_char;
173  	int (*CheckFoldPoint)(char const *, int &amp;);
174  	WordList keywordlists[4];
175  	OptionsBasic options;
176  	OptionSetBasic osBasic;
177  public:
178  	LexerBasic(const char *languageName_, int language_, char comment_char_,
179  		int (*CheckFoldPoint_)(char const *, int &amp;), const char * const wordListDescriptions[]) :
180  						 DefaultLexer(languageName_, language_),
181  						 comment_char(comment_char_),
182  						 CheckFoldPoint(CheckFoldPoint_),
183  						 osBasic(wordListDescriptions) {
184  	}
185  	virtual ~LexerBasic() {
186  	}
187  	void SCI_METHOD Release() override {
188  		delete this;
189  	}
190  	int SCI_METHOD Version() const override {
191  		return lvRelease5;
192  	}
193  	const char * SCI_METHOD PropertyNames() override {
194  		return osBasic.PropertyNames();
195  	}
196  	int SCI_METHOD PropertyType(const char *name) override {
197  		return osBasic.PropertyType(name);
198  	}
199  	const char * SCI_METHOD DescribeProperty(const char *name) override {
200  		return osBasic.DescribeProperty(name);
201  	}
202  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
203  	const char * SCI_METHOD PropertyGet(const char *key) override {
204  		return osBasic.PropertyGet(key);
205  	}
206  	const char * SCI_METHOD DescribeWordListSets() override {
207  		return osBasic.DescribeWordListSets();
208  	}
209  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
210  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
211  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
212  	void * SCI_METHOD PrivateCall(int, void *) override {
213  		return 0;
214  	}
215  	static ILexer5 *LexerFactoryBlitzBasic() {
216  		return new LexerBasic(&quot;blitzbasic&quot;, SCLEX_BLITZBASIC, &#x27;;&#x27;, CheckBlitzFoldPoint, blitzbasicWordListDesc);
217  	}
218  	static ILexer5 *LexerFactoryPureBasic() {
219  		return new LexerBasic(&quot;purebasic&quot;, SCLEX_PUREBASIC, &#x27;;&#x27;, CheckPureFoldPoint, purebasicWordListDesc);
220  	}
221  	static ILexer5 *LexerFactoryFreeBasic() {
222  		return new LexerBasic(&quot;freebasic&quot;, SCLEX_FREEBASIC, &#x27;\&#x27;&#x27;, CheckFreeFoldPoint, freebasicWordListDesc );
223  	}
224  };
225  Sci_Position SCI_METHOD LexerBasic::PropertySet(const char *key, const char *val) {
226  	if (osBasic.PropertySet(&amp;options, key, val)) {
227  		return 0;
228  	}
229  	return -1;
230  }
231  Sci_Position SCI_METHOD LexerBasic::WordListSet(int n, const char *wl) {
232  	WordList *wordListN = 0;
233  	switch (n) {
234  	case 0:
235  		wordListN = &amp;keywordlists[0];
236  		break;
237  	case 1:
238  		wordListN = &amp;keywordlists[1];
239  		break;
240  	case 2:
241  		wordListN = &amp;keywordlists[2];
242  		break;
243  	case 3:
<span onclick='openModal()' class='match'>244  		wordListN = &amp;keywordlists[3];
245  		break;
246  	}
247  	Sci_Position firstModification = -1;
248  	if (wordListN) {
249  		WordList wlNew;
250  		wlNew.Set(wl);
251  		if (*wordListN != wlNew) {
252  			wordListN-&gt;Set(wl);
253  			firstModification = 0;
254  		}
255  	}
256  	return firstModification;
257  }
258  void SCI_METHOD LexerBasic::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
259  	LexAccessor styler(pAccess);
260  	bool wasfirst = true, isfirst = true; 
</span>261  	styler.StartAt(startPos);
262  	int styleBeforeKeyword = SCE_B_DEFAULT;
263  	StyleContext sc(startPos, length, initStyle, styler);
264  	for (; ; sc.Forward()) {
265  		if (sc.state == SCE_B_IDENTIFIER) {
266  			if (!IsIdentifier(sc.ch)) {
267  				if (wasfirst &amp;&amp; sc.Match(&#x27;:&#x27;)) {
268  					sc.ChangeState(SCE_B_LABEL);
269  					sc.ForwardSetState(SCE_B_DEFAULT);
270  				} else {
271  					char s[100];
272  					int kstates[4] = {
273  						SCE_B_KEYWORD,
274  						SCE_B_KEYWORD2,
275  						SCE_B_KEYWORD3,
276  						SCE_B_KEYWORD4,
277  					};
278  					sc.GetCurrentLowered(s, sizeof(s));
279  					for (int i = 0; i &lt; 4; i++) {
280  						if (keywordlists[i].InList(s)) {
281  							sc.ChangeState(kstates[i]);
282  						}
283  					}
284  					if (sc.Match(&#x27;.&#x27;) || sc.Match(&#x27;$&#x27;) || sc.Match(&#x27;%&#x27;) ||
285  						sc.Match(&#x27;#&#x27;)) {
286  						sc.SetState(SCE_B_OPERATOR);
287  					} else {
288  						sc.SetState(SCE_B_DEFAULT);
289  					}
290  				}
291  			}
292  		} else if (sc.state == SCE_B_OPERATOR) {
293  			if (!IsOperator(sc.ch) || sc.Match(&#x27;#&#x27;))
294  				sc.SetState(SCE_B_DEFAULT);
295  		} else if (sc.state == SCE_B_LABEL) {
296  			if (!IsIdentifier(sc.ch))
297  				sc.SetState(SCE_B_DEFAULT);
298  		} else if (sc.state == SCE_B_CONSTANT) {
299  			if (!IsIdentifier(sc.ch))
300  				sc.SetState(SCE_B_DEFAULT);
301  		} else if (sc.state == SCE_B_NUMBER) {
302  			if (!IsDigit(sc.ch))
303  				sc.SetState(SCE_B_DEFAULT);
304  		} else if (sc.state == SCE_B_HEXNUMBER) {
305  			if (!IsHexDigit(sc.ch))
306  				sc.SetState(SCE_B_DEFAULT);
307  		} else if (sc.state == SCE_B_BINNUMBER) {
308  			if (!IsBinDigit(sc.ch))
309  				sc.SetState(SCE_B_DEFAULT);
310  		} else if (sc.state == SCE_B_STRING) {
311  			if (sc.ch == &#x27;&quot;&#x27;) {
312  				sc.ForwardSetState(SCE_B_DEFAULT);
313  			}
314  			if (sc.atLineEnd) {
315  				sc.ChangeState(SCE_B_ERROR);
316  				sc.SetState(SCE_B_DEFAULT);
317  			}
318  		} else if (sc.state == SCE_B_COMMENT || sc.state == SCE_B_PREPROCESSOR) {
319  			if (sc.atLineEnd) {
320  				sc.SetState(SCE_B_DEFAULT);
321  			}
322  		} else if (sc.state == SCE_B_DOCLINE) {
323  			if (sc.atLineEnd) {
324  				sc.SetState(SCE_B_DEFAULT);
325  			} else if (sc.ch == &#x27;\\&#x27; || sc.ch == &#x27;@&#x27;) {
326  				if (IsLetter(sc.chNext) &amp;&amp; sc.chPrev != &#x27;\\&#x27;) {
327  					styleBeforeKeyword = sc.state;
328  					sc.SetState(SCE_B_DOCKEYWORD);
329  				};
330  			}
331  		} else if (sc.state == SCE_B_DOCKEYWORD) {
332  			if (IsSpace(sc.ch)) {
333  				sc.SetState(styleBeforeKeyword);
334  			}	else if (sc.atLineEnd &amp;&amp; styleBeforeKeyword == SCE_B_DOCLINE) {
335  				sc.SetState(SCE_B_DEFAULT);
336  			}
337  		} else if (sc.state == SCE_B_COMMENTBLOCK) {
338  			if (sc.Match(&quot;\&#x27;/&quot;)) {
339  				sc.Forward();
340  				sc.ForwardSetState(SCE_B_DEFAULT);
341  			}
342  		} else if (sc.state == SCE_B_DOCBLOCK) {
343  			if (sc.Match(&quot;\&#x27;/&quot;)) {
344  				sc.Forward();
345  				sc.ForwardSetState(SCE_B_DEFAULT);
346  			} else if (sc.ch == &#x27;\\&#x27; || sc.ch == &#x27;@&#x27;) {
347  				if (IsLetter(sc.chNext) &amp;&amp; sc.chPrev != &#x27;\\&#x27;) {
348  					styleBeforeKeyword = sc.state;
349  					sc.SetState(SCE_B_DOCKEYWORD);
350  				};
351  			}
352  		}
353  		if (sc.atLineStart)
354  			isfirst = true;
355  		if (sc.state == SCE_B_DEFAULT || sc.state == SCE_B_ERROR) {
356  			if (isfirst &amp;&amp; sc.Match(&#x27;.&#x27;) &amp;&amp; comment_char != &#x27;\&#x27;&#x27;) {
357  					sc.SetState(SCE_B_LABEL);
358  			} else if (isfirst &amp;&amp; sc.Match(&#x27;#&#x27;)) {
359  				wasfirst = isfirst;
360  				sc.SetState(SCE_B_IDENTIFIER);
361  			} else if (sc.Match(comment_char)) {
362  				if (comment_char == &#x27;\&#x27;&#x27; &amp;&amp; sc.Match(comment_char, &#x27;$&#x27;))
363  					sc.SetState(SCE_B_PREPROCESSOR);
364  				else if (sc.Match(&quot;\&#x27;*&quot;) || sc.Match(&quot;\&#x27;!&quot;)) {
365  					sc.SetState(SCE_B_DOCLINE);
366  				} else {
367  					sc.SetState(SCE_B_COMMENT);
368  				}
369  			} else if (sc.Match(&quot;/\&#x27;&quot;)) {
370  				if (sc.Match(&quot;/\&#x27;*&quot;) || sc.Match(&quot;/\&#x27;!&quot;)) {	
371  					sc.SetState(SCE_B_DOCBLOCK);
372  				} else {
373  					sc.SetState(SCE_B_COMMENTBLOCK);
374  				}
375  				sc.Forward();	
376  			} else if (sc.Match(&#x27;&quot;&#x27;)) {
377  				sc.SetState(SCE_B_STRING);
378  			} else if (IsDigit(sc.ch)) {
379  				sc.SetState(SCE_B_NUMBER);
380  			} else if (sc.Match(&#x27;$&#x27;) || sc.Match(&quot;&amp;h&quot;) || sc.Match(&quot;&amp;H&quot;) || sc.Match(&quot;&amp;o&quot;) || sc.Match(&quot;&amp;O&quot;)) {
381  				sc.SetState(SCE_B_HEXNUMBER);
382  			} else if (sc.Match(&#x27;%&#x27;) || sc.Match(&quot;&amp;b&quot;) || sc.Match(&quot;&amp;B&quot;)) {
383  				sc.SetState(SCE_B_BINNUMBER);
384  			} else if (sc.Match(&#x27;#&#x27;)) {
385  				sc.SetState(SCE_B_CONSTANT);
386  			} else if (IsOperator(sc.ch)) {
387  				sc.SetState(SCE_B_OPERATOR);
388  			} else if (IsIdentifier(sc.ch)) {
389  				wasfirst = isfirst;
390  				sc.SetState(SCE_B_IDENTIFIER);
391  			} else if (!IsSpace(sc.ch)) {
392  				sc.SetState(SCE_B_ERROR);
393  			}
394  		}
395  		if (!IsSpace(sc.ch))
396  			isfirst = false;
397  		if (!sc.More())
398  			break;
399  	}
400  	sc.Complete();
401  }
402  void SCI_METHOD LexerBasic::Fold(Sci_PositionU startPos, Sci_Position length, int &amp;bsol;* initStyle */, IDocument *pAccess) {
403  	if (!options.fold)
404  		return;
405  	LexAccessor styler(pAccess);
406  	Sci_Position line = styler.GetLine(startPos);
407  	int level = styler.LevelAt(line);
408  	int go = 0, done = 0;
409  	Sci_Position endPos = startPos + length;
410  	char word[256];
411  	int wordlen = 0;
412  	const bool userDefinedFoldMarkers = !options.foldExplicitStart.empty() &amp;&amp; !options.foldExplicitEnd.empty();
413  	int cNext = styler[startPos];
414  	for (Sci_Position i = startPos; i &lt; endPos; i++) {
415  		int c = cNext;
416  		cNext = styler.SafeGetCharAt(i + 1);
417  		bool atEOL = (c == &#x27;\r&#x27; &amp;&amp; cNext != &#x27;\n&#x27;) || (c == &#x27;\n&#x27;);
418  		if (options.foldSyntaxBased &amp;&amp; !done &amp;&amp; !go) {
419  			if (wordlen) { 
420  				word[wordlen] = static_cast&lt;char&gt;(LowerCase(c));
421  				if (!IsIdentifier(c)) { 
422  					word[wordlen] = &#x27;\0&#x27;;
423  					go = CheckFoldPoint(word, level);
424  					if (!go) {
425  						if (IsSpace(c) &amp;&amp; IsIdentifier(word[wordlen - 1])) {
426  							word[wordlen] = &#x27; &#x27;;
427  							if (wordlen &lt; 255)
428  								wordlen++;
429  						}
430  						else 
431  							done = 1;
432  					}
433  				} else if (wordlen &lt; 255) {
434  					wordlen++;
435  				}
436  			} else { 
437  				if (!IsSpace(c)) {
438  					if (IsIdentifier(c)) {
439  						word[0] = static_cast&lt;char&gt;(LowerCase(c));
440  						wordlen = 1;
441  					} else 
442  						done = 1;
443  				}
444  			}
445  		}
446  		if (options.foldCommentExplicit &amp;&amp; ((styler.StyleAt(i) == SCE_B_COMMENT) || options.foldExplicitAnywhere)) {
447  			if (userDefinedFoldMarkers) {
448  				if (styler.Match(i, options.foldExplicitStart.c_str())) {
449   					level |= SC_FOLDLEVELHEADERFLAG;
450  					go = 1;
451  				} else if (styler.Match(i, options.foldExplicitEnd.c_str())) {
452   					go = -1;
453   				}
454  			} else {
455  				if (c == comment_char) {
456  					if (cNext == &#x27;{&#x27;) {
457  						level |= SC_FOLDLEVELHEADERFLAG;
458  						go = 1;
459  					} else if (cNext == &#x27;}&#x27;) {
460  						go = -1;
461  					}
462  				}
463   			}
464   		}
465  		if (atEOL) { 
466  			if (!done &amp;&amp; wordlen == 0 &amp;&amp; options.foldCompact) 
467  				level |= SC_FOLDLEVELWHITEFLAG;
468  			if (level != styler.LevelAt(line))
469  				styler.SetLevel(line, level);
470  			level += go;
471  			line++;
472  			wordlen = 0;
473  			level &amp;= ~SC_FOLDLEVELHEADERFLAG;
474  			level &amp;= ~SC_FOLDLEVELWHITEFLAG;
475  			go = 0;
476  			done = 0;
477  		}
478  	}
479  }
480  LexerModule lmBlitzBasic(SCLEX_BLITZBASIC, LexerBasic::LexerFactoryBlitzBasic, &quot;blitzbasic&quot;, blitzbasicWordListDesc);
481  LexerModule lmPureBasic(SCLEX_PUREBASIC, LexerBasic::LexerFactoryPureBasic, &quot;purebasic&quot;, purebasicWordListDesc);
482  LexerModule lmFreeBasic(SCLEX_FREEBASIC, LexerBasic::LexerFactoryFreeBasic, &quot;freebasic&quot;, freebasicWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHollywood.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBasic.cxx</div>
                </div>
                <div class="column column_space"><pre><code>270  		wordListN = &amp;keywordlists[3];
271  		break;
272  	}
273  	Sci_Position firstModification = -1;
274  	if (wordListN) {
275  		WordList wlNew;
276  		wlNew.Set(wl);
277  		if (*wordListN != wlNew) {
278  			wordListN-&gt;Set(wl);
279  			firstModification = 0;
280  		}
281  	}
282  	return firstModification;	
283  }
284  void SCI_METHOD LexerHollywood::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
285  	LexAccessor styler(pAccess);
286  	styler.StartAt(startPos);
</pre></code></div>
                <div class="column column_space"><pre><code>244  		wordListN = &amp;keywordlists[3];
245  		break;
246  	}
247  	Sci_Position firstModification = -1;
248  	if (wordListN) {
249  		WordList wlNew;
250  		wlNew.Set(wl);
251  		if (*wordListN != wlNew) {
252  			wordListN-&gt;Set(wl);
253  			firstModification = 0;
254  		}
255  	}
256  	return firstModification;
257  }
258  void SCI_METHOD LexerBasic::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
259  	LexAccessor styler(pAccess);
260  	bool wasfirst = true, isfirst = true; 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    