<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for BaseTestDataAccess.cpp & BaseTestDimension.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for BaseTestDataAccess.cpp & BaseTestDimension.cpp
      </h3>
      <h1 align="center">
        15.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>BaseTestDataAccess.cpp (13.787375%)<TH>BaseTestDimension.cpp (17.043121%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-1.html#0',3)" NAME="0">(37-67)<TD><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-1.html#0',3)" NAME="0">(247-299)</A><TD ALIGN=center><FONT COLOR="#ff0000">48</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#1',2,'match943-1.html#1',3)" NAME="1">(936-953)<TD><A HREF="javascript:ZweiFrames('match943-0.html#1',2,'match943-1.html#1',3)" NAME="1">(901-916)</A><TD ALIGN=center><FONT COLOR="#8f0000">27</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#2',2,'match943-1.html#2',3)" NAME="2">(652-661)<TD><A HREF="javascript:ZweiFrames('match943-0.html#2',2,'match943-1.html#2',3)" NAME="2">(206-213)</A><TD ALIGN=center><FONT COLOR="#640000">19</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#3',2,'match943-1.html#3',3)" NAME="3">(236-309)<TD><A HREF="javascript:ZweiFrames('match943-0.html#3',2,'match943-1.html#3',3)" NAME="3">(746-767)</A><TD ALIGN=center><FONT COLOR="#640000">19</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#4',2,'match943-1.html#4',3)" NAME="4">(398-412)<TD><A HREF="javascript:ZweiFrames('match943-0.html#4',2,'match943-1.html#4',3)" NAME="4">(538-555)</A><TD ALIGN=center><FONT COLOR="#550000">16</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#5',2,'match943-1.html#5',3)" NAME="5">(90-100)<TD><A HREF="javascript:ZweiFrames('match943-0.html#5',2,'match943-1.html#5',3)" NAME="5">(770-783)</A><TD ALIGN=center><FONT COLOR="#450000">13</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#6',2,'match943-1.html#6',3)" NAME="6">(767-779)<TD><A HREF="javascript:ZweiFrames('match943-0.html#6',2,'match943-1.html#6',3)" NAME="6">(606-616)</A><TD ALIGN=center><FONT COLOR="#3f0000">12</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#7',2,'match943-1.html#7',3)" NAME="7">(175-183)<TD><A HREF="javascript:ZweiFrames('match943-0.html#7',2,'match943-1.html#7',3)" NAME="7">(887-895)</A><TD ALIGN=center><FONT COLOR="#3f0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestDataAccess.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4996)
#endif

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iterator&gt;
#include &lt;stdexcept&gt;

#include &lt;nix/hydra/multiArray.hpp&gt;
#include &lt;nix/util/dataAccess.hpp&gt;

#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &lt;cppunit/CompilerOutputter.h&gt;
#include &lt;cppunit/TestResult.h&gt;
#include &lt;cppunit/TestResultCollector.h&gt;
#include &lt;cppunit/TestRunner.h&gt;
#include &lt;cppunit/BriefTestProgressListener.h&gt;

#include &quot;BaseTestDataAccess.hpp&quot;

using namespace nix;
using namespace std;
using namespace boost;

<A NAME="0"></A>void BaseTestDataAccess::testPositionToIndexRangeDimension() {
    string unit = &quot;ms&quot;;
    string invalid_unit = &quot;kV&quot;;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match943-1.html#0',3,'match943-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    string scaled_unit = &quot;s&quot;;

    CPPUNIT_ASSERT_THROW(util::positionToIndex(5.0, invalid_unit, rangeDim), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT(*util::positionToIndex(5.0, unit, PositionMatch::Less, rangeDim) == 3);
    CPPUNIT_ASSERT(*util::positionToIndex(0.005, scaled_unit, PositionMatch::Less, rangeDim) == 3);

    CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::Less, rangeDim));
    CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::LessOrEqual, rangeDim));
    CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::Equal, rangeDim));
    CPPUNIT_ASSERT(*(util::positionToIndex(1.0, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 0);
    CPPUNIT_ASSERT(*(util::positionToIndex(1.0, unit, PositionMatch::Greater, rangeDim)) == 0);

    CPPUNIT_ASSERT(!util::positionToIndex(1.2, unit, PositionMatch::Less, rangeDim));
    CPPUNIT_ASSERT(util::positionToIndex(1.2, unit, PositionMatch::LessOrEqual, rangeDim));
    CPPUNIT_ASSERT(util::positionToIndex(1.2, unit, PositionMatch::Equal, rangeDim));
    CPPUNIT_ASSERT(*(util::positionToIndex(1.2, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 0);
    CPPUNIT_ASSERT(*(util::positionToIndex(1.2, unit, PositionMatch::Greater, rangeDim)) == 1);

    CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::Less, rangeDim) == 2);
    CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::LessOrEqual, rangeDim) == 3);
    CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::Equal, rangeDim) == 3);
    CPPUNIT_ASSERT(*(util::positionToIndex(4.5, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 3);
    CPPUNIT_ASSERT(*(util::positionToIndex(4.5, unit, PositionMatch::Greater, rangeDim)) == 4);

    CPPUNIT_ASSERT(*util::positionToIndex(7.0, unit, PositionMatch::Less, rangeDim) == 4);
    CPPUNIT_ASSERT(*util::positionToIndex(7.0, unit, PositionMatch::LessOrEqual, rangeDim) == 4);
    CPPUNIT_ASSERT(!util::positionToIndex(7.0, unit, PositionMatch::Equal, rangeDim));
    CPPUNIT_ASSERT(!(util::positionToIndex(7.0, unit, PositionMatch::GreaterOrEqual, rangeDim)));
    CPPUNIT_ASSERT(!util::positionToIndex(7.0, unit, PositionMatch::Greater, rangeDim));

    CPPUNIT_ASSERT_THROW(util::positionToIndex({5.0, 1.2}, {1.4}, {unit, unit}, RangeMatch::Inclusive, rangeDim), std::runtime_error);</B></FONT>

    vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; range = util::positionToIndex({0.0}, {7.0}, {unit}, RangeMatch::Inclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 4);
    range = util::positionToIndex({0.0}, {7.0}, {unit}, RangeMatch::Exclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 4);
    
    range = util::positionToIndex({2.0}, {6.7}, {unit}, RangeMatch::Inclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 1 &amp;&amp; (*range[0]).second == 4);
    range = util::positionToIndex({2.0}, {6.7}, {unit}, RangeMatch::Exclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 1 &amp;&amp; (*range[0]).second == 3);

    range = util::positionToIndex({1.2}, {1.2}, {unit}, RangeMatch::Inclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 0);
    range = util::positionToIndex({1.2}, {1.2}, {unit}, RangeMatch::Exclusive, rangeDim);
    CPPUNIT_ASSERT(!range[0]);
}

void BaseTestDataAccess::testPositionToIndexRangeDimensionOld() {
    string unit = &quot;ms&quot;;
<A NAME="5"></A>    string invalid_unit = &quot;kV&quot;;
    string scaled_unit = &quot;s&quot;;

<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match943-1.html#5',3,'match943-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    CPPUNIT_ASSERT_THROW(util::positionToIndex(0.001, invalid_unit, rangeDim), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(util::positionToIndex(8.0, unit, rangeDim), nix::OutOfBounds);
    CPPUNIT_ASSERT(util::positionToIndex(0.001, unit, rangeDim) == 0);
    CPPUNIT_ASSERT(util::positionToIndex(0.001, scaled_unit, rangeDim) == 0);
    CPPUNIT_ASSERT_THROW(util::positionToIndex(0.008, scaled_unit, rangeDim), nix::OutOfBounds);
    CPPUNIT_ASSERT(util::positionToIndex(3.4, unit, rangeDim) == 2);
    CPPUNIT_ASSERT(util::positionToIndex(3.6, unit, rangeDim) == 3);
    CPPUNIT_ASSERT(util::positionToIndex(4.0, unit, rangeDim) == 3);
    CPPUNIT_ASSERT(util::positionToIndex(0.0034, scaled_unit, rangeDim) == 2);

    vector&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt; range = util::positionToIndex({0.001}, {3.4}, {unit}, rangeDim);</B></FONT>
    CPPUNIT_ASSERT(range[0].first == 0 &amp;&amp; range[0].second == 2);
    CPPUNIT_ASSERT_THROW(util::positionToIndex({0.001, 2.0}, {3.4}, {unit}, rangeDim), std::runtime_error);
    CPPUNIT_ASSERT_THROW(util::positionToIndex({7.5}, {8.0}, {unit}, rangeDim), nix::OutOfBounds);
}


void BaseTestDataAccess::testGetDimensionUnit() {
    std::vector&lt;nix::Column&gt; cols = {{&quot;current&quot;, &quot;nA&quot;, nix::DataType::Double},
                                     {&quot;note&quot;, &quot;&quot;, nix::DataType::String}};
    DataFrame df = block.createDataFrame(&quot;test&quot;, &quot;test&quot;, cols);

    data_array.appendDataFrameDimension(df);
    data_array.appendDataFrameDimension(df, 1);

    std::string unit = &quot;ms&quot;;
    std::string no_unit = &quot;none&quot;;

    std::vector&lt;Dimension&gt; dims = data_array.dimensions();
    CPPUNIT_ASSERT(dims.size() == 6);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[0]), no_unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[1]), unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[2]), unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[3]), cols[0].unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[4]), no_unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[5]), no_unit);
}


void BaseTestDataAccess::testPositionToIndexSampledDimension() {
    string unit = &quot;ms&quot;;
    string invalid_unit = &quot;kV&quot;;
    string scaled_unit = &quot;s&quot;;
    // test incompatible dims
    CPPUNIT_ASSERT_THROW(util::positionToIndex(1.0, invalid_unit, sampledDim), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(1.0, unit, sampledDim));
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(1.0, scaled_unit, sampledDim));

    sampledDim.unit(nix::none);
    CPPUNIT_ASSERT_THROW(util::positionToIndex(1.0, unit, sampledDim), nix::IncompatibleDimensions);
    sampledDim.unit(unit);

    vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({0.0, 2.0, 10.0}, {10.0, 2.0, 5.0}, {unit, unit, unit}, RangeMatch::Inclusive, sampledDim);
    CPPUNIT_ASSERT(ranges.size() == 3);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 10);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 2 &amp;&amp; (*ranges[1]).second == 2);
    CPPUNIT_ASSERT(!ranges[2]);// &amp;&amp; (*ranges[2]).first == 5 &amp;&amp; (*ranges[2]).second == 10);

    ranges = util::positionToIndex({0.0, 2.0, 10.0}, {10.0, 2.0, 5.0}, {unit, unit, unit}, RangeMatch::Exclusive, sampledDim);
    CPPUNIT_ASSERT(ranges.size() == 3);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 9);
    CPPUNIT_ASSERT(!ranges[1]);
    CPPUNIT_ASSERT(!ranges[2]); // &amp;&amp; (*ranges[2]).first == 5 &amp;&amp; (*ranges[2]).second == 9);
}

void BaseTestDataAccess::testPositionToIndexSampledDimensionOld() {
    string unit = &quot;ms&quot;;
    string invalid_unit = &quot;kV&quot;;
    string scaled_unit = &quot;s&quot;;

    CPPUNIT_ASSERT(util::positionToIndex(-8.0, unit, sampledDim) == 0);
    CPPUNIT_ASSERT_THROW(util::positionToIndex(0.005, invalid_unit, sampledDim), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT(util::positionToIndex(5.0, unit, sampledDim) == 5);
    CPPUNIT_ASSERT(util::positionToIndex(0.005, scaled_unit, sampledDim) == 5);

    CPPUNIT_ASSERT_THROW(util::positionToIndex({},{1.0}, {unit}, sampledDim), std::runtime_error);
    CPPUNIT_ASSERT_THROW(util::positionToIndex({0.0, 1.0}, {3.5, 0.5}, {unit, unit}, sampledDim), nix::OutOfBounds);
    CPPUNIT_ASSERT(util::positionToIndex({0.0, 0.5}, {3.5, 1.0}, {unit, unit}, sampledDim).size() == 2);

    vector&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges = util::positionToIndex({0.0}, {0.0}, {unit}, sampledDim);
    CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 0);
}
<A NAME="7"></A>

void BaseTestDataAccess::testPositionToIndexSetDimensionOld() {
<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match943-1.html#7',3,'match943-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    std::string unit = &quot;ms&quot;;
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(-5.9, &quot;none&quot;, setDim)); // because old style defaults to GreaterOrEqual
    CPPUNIT_ASSERT_THROW(util::positionToIndex(5.8, &quot;none&quot;, setDim), nix::OutOfBounds); // labels are set, but too few
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(0.5, &quot;none&quot;, setDim));
    CPPUNIT_ASSERT(util::positionToIndex(0.5, &quot;none&quot;, setDim) == 1);


    std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges;
    CPPUNIT_ASSERT_THROW(util::positionToIndex({10}, {1.}, {&quot;none&quot;}, setDim), nix::OutOfBounds);</B></FONT>
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex({1}, {10.}, {&quot;none&quot;}, setDim));

    int pos = -1;
    CPPUNIT_ASSERT_NO_THROW(check::converts_to_double(pos, &quot;Does not convert seamlessly to double!&quot;));
    ndsize_t large_pos = pow(10, 16);
    CPPUNIT_ASSERT_NO_THROW(check::converts_to_double(large_pos, &quot;Does not convert seamlessly to double!&quot;));
    large_pos = pow(10, 16);
    large_pos += 1;
    CPPUNIT_ASSERT_THROW(check::converts_to_double(large_pos, &quot;Does not convert seamlessly to double!&quot;), nix::OutOfBounds);
}


void BaseTestDataAccess::testPositionToIndexSetDimension() {
    CPPUNIT_ASSERT(!util::positionToIndex(5.8, PositionMatch::Equal, setDim));

    CPPUNIT_ASSERT_THROW(util::positionToIndex({5.0, 0.}, {10.5}, RangeMatch::Inclusive, setDim), std::runtime_error);
    
    vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({5.0, 0.}, {10.5, 1.0}, RangeMatch::Inclusive, setDim);
    CPPUNIT_ASSERT(ranges.size() == 2);
    CPPUNIT_ASSERT(!ranges[0]);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 1);

    ranges = util::positionToIndex({5.0, 0.}, {10.5, 1.0}, RangeMatch::Exclusive, setDim);
    CPPUNIT_ASSERT(ranges.size() == 2);
    CPPUNIT_ASSERT(!ranges[0]);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 0);   
}


void BaseTestDataAccess::testPositionToIndexDataFrameDimension() {
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(12.2, PositionMatch::GreaterOrEqual, dfDim)); // no throw even though not valid
    boost::optional&lt;ndsize_t&gt; pos = util::positionToIndex(12.2, PositionMatch::GreaterOrEqual, dfDim);
    CPPUNIT_ASSERT(!pos);

    
    CPPUNIT_ASSERT_THROW(util::positionToIndex({1.0, 2.0}, {0.0}, RangeMatch::Exclusive, dfDim), std::runtime_error);
    vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({0.0, 12.0, 5.0}, {9.0, 15.0, 0.0}, RangeMatch::Exclusive, dfDim);
    CPPUNIT_ASSERT(ranges.size() == 3);
    CPPUNIT_ASSERT(ranges[0]);
    CPPUNIT_ASSERT(!ranges[1]);
    CPPUNIT_ASSERT(!ranges[2]);
}


void BaseTestDataAccess::testOffsetAndCount() {
    NDSize offsets, counts;
    /*
     std::vector&lt;double&gt; position {0.0, 2.0, 3.4, 1.0};
     std::vector&lt;double&gt; extent {0.0, 6.0, 2.3, 1.0};
<A NAME="3"></A>     std::vector&lt;std::string&gt; units {&quot;none&quot;, &quot;ms&quot;, &quot;ms&quot;};
    */
    // implicitely calls with range = RangeMatch::Inclusive, 
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match943-1.html#3',3,'match943-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    util::getOffsetAndCount(position_tag, data_array, offsets, counts);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);

    // even if called with RangeMatch::Exclusive it will return count == 1
    util::getOffsetAndCount(position_tag, data_array, offsets, counts, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);

    position_tag.units(std::vector&lt;std::string&gt;());
    util::getOffsetAndCount(position_tag, data_array, offsets, counts);
    CPPUNIT_ASSERT(position_tag.units().size() == 0);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);

    /*
     Test a tag with position and extents
     position {0.0, 2.0, 3.4, 1.0};
     extent {0.0, 6.0, 2.3, 1.0};
     units {&quot;none&quot;, &quot;ms&quot;, &quot;ms&quot;};
     ref_dims = {Set (labels:{&quot;label_a&quot;, &quot;label_b&quot;}), Sampled(1.0, ms), Range(ticks:{1.2, 2.3, 3.4, 4.5, 6.7}, ms),
     DataFrame(ticks:{0., 2.5, 5.0, 7.5, 10.0, 12.5, 15., 17.5, 20., 22.5})}
    */
    // call with RangeMatch::Inclusive
    util::getOffsetAndCount(segment_tag, data_array, offsets, counts);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 7 &amp;&amp; counts[2] == 2);

    // call with RangeMatch::Exclusive
    util::getOffsetAndCount(segment_tag, data_array, offsets, counts, RangeMatch::Exclusive);

    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 6 &amp;&amp; counts[2] == 2);

    /*
    MultiTag:
    positions = [0.0 --&gt; 0.0, 3.0 --&gt; 9.0,  3.4 --&gt; 5.7, 1.0 --&gt; 3.0];  // position 1
                [0.0 --&gt; 0.0, 8.0 --&gt; 11.0, 2.3 --&gt; 4.3, 1.0 --&gt; 7.0];  // position 2

    ref_array {Set, Sample, Range, DataFrame}, as above
    */
    // calling with RangeMatch::Inclusive
    CPPUNIT_ASSERT_THROW(util::getOffsetAndCount(multi_tag, data_array, -1, offsets, counts), nix::OutOfBounds); // not a valid position index
    CPPUNIT_ASSERT_THROW(util::getOffsetAndCount(multi_tag, data_array, 3, offsets, counts), nix::OutOfBounds); // not a valid position index

    util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 3 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 7 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 3);

    util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 3 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 6 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 2);

    util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 8 &amp;&amp; offsets[2] == 1 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 4 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 7);

    util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts, RangeMatch::Exclusive);</B></FONT>
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 8 &amp;&amp; offsets[2] == 1 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 3 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 6);
}


void BaseTestDataAccess::testPositionInData() {
    NDSize offsets, counts;
    util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts);
    CPPUNIT_ASSERT(util::positionInData(data_array, offsets));
    CPPUNIT_ASSERT(util::positionAndExtentInData(data_array, offsets, counts));

    util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts);
    CPPUNIT_ASSERT(util::positionInData(data_array, offsets));
    CPPUNIT_ASSERT(!util::positionAndExtentInData(data_array, offsets, counts));
}


void BaseTestDataAccess::testRetrieveData() {
    std::vector&lt;ndsize_t&gt; position_indices(1, 0);
    CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 1), nix::OutOfBounds);

    position_indices[0] = 10;
    CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 0), nix::OutOfBounds);

    position_indices[0] = 0;
    std::vector&lt;DataView&gt; views;
    views = util::taggedData(multi_tag, position_indices, 0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(views.size() == 1);
    nix::DataView v = util::taggedData(multi_tag, 0, 0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT_EQUAL(v.dataExtent(), views[0].dataExtent());

    std::vector&lt;ndsize_t&gt; temp;
    std::vector&lt;DataView&gt; slices = util::taggedData(mtag2, temp, 0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slices.size() == mtag2.positions().dataExtent()[0]);

    // old-style calls, deprecated
    CPPUNIT_ASSERT_NO_THROW(util::retrieveData(mtag2, 0, 0));
    CPPUNIT_ASSERT_NO_THROW(util::retrieveData(mtag2, 0, mtag2.references()[0]));

    slices = util::taggedData(pointmtag, temp, 0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slices.size() == pointmtag.positions().dataExtent()[0]);

    DataView data_view = views[0];
    NDSize data_size = data_view.dataExtent();

    CPPUNIT_ASSERT(data_size.size() == 4);
    CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 7 &amp;&amp; data_size[2] == 2 &amp;&amp; data_size[3] == 3);
    position_indices[0] = 1;
    CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 0), nix::OutOfBounds);

    data_view = util::taggedData(position_tag, 0, RangeMatch::Inclusive);
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);
    CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 1 &amp;&amp; data_size[2] == 1 &amp;&amp; data_size[3] == 1);

    data_view = util::taggedData(segment_tag, 0, RangeMatch::Inclusive);
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);
    CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 7 &amp;&amp; data_size[2] == 2 &amp;&amp; data_size[3] == 2);

    DataView times_view = util::taggedData(times_tag, 0, RangeMatch::Inclusive);
    data_size = times_view.dataExtent();
    std::vector&lt;double&gt; times(data_size.size());
    times_view.getData(times);
    RangeDimension dim = times_tag.references()[0].dimensions()[0].asRangeDimension();
    CPPUNIT_ASSERT(data_size.size() == 1);
    CPPUNIT_ASSERT(data_size[0] == 77);
}


void BaseTestDataAccess::testTagFeatureData() {
    DataArray number_feat = block.createDataArray(&quot;number feature&quot;, &quot;test&quot;, nix::DataType::Double, {1});
    std::vector&lt;double&gt; number = {10.0};
    number_feat.setData(number);
    DataArray ramp_feat = block.createDataArray(&quot;ramp feature&quot;, &quot;test&quot;, nix::DataType::Double, {10});
    ramp_feat.label(&quot;voltage&quot;);
    ramp_feat.unit(&quot;mV&quot;);
    SampledDimension dim = ramp_feat.appendSampledDimension(1.0);
    dim.unit(&quot;ms&quot;);
    std::vector&lt;double&gt; ramp_data = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};
    ramp_feat.setData(ramp_data);

    Tag pos_tag = block.createTag(&quot;feature test&quot;, &quot;test&quot;, {5.0});
<A NAME="4"></A>    pos_tag.units({&quot;ms&quot;});

    Feature f1 = pos_tag.createFeature(number_feat, nix::LinkType::Untagged);
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match943-1.html#4',3,'match943-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    Feature f2 = pos_tag.createFeature(ramp_feat, nix::LinkType::Tagged);
    Feature f3 = pos_tag.createFeature(ramp_feat, nix::LinkType::Untagged);

    DataView data1 = util::featureData(pos_tag, 0);
    DataView data2 = util::featureData(pos_tag, 1);
    DataView data3 = util::featureData(pos_tag, 2);

    CPPUNIT_ASSERT(pos_tag.featureCount() == 3);
    CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data2.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());

    data1 = util::featureData(pos_tag, f1);
    data2 = util::featureData(pos_tag, f2);
    data3 = util::featureData(pos_tag, f3);</B></FONT>

    CPPUNIT_ASSERT(pos_tag.featureCount() == 3);
    CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data2.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());

    // make tag pointing to a slice
    pos_tag.extent({2.0});
    data1 = util::featureData(pos_tag, 0);
    data2 = util::featureData(pos_tag, 1);
    data3 = util::featureData(pos_tag, 2);

    CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data2.dataExtent().nelms() == 2);
    CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());

    pos_tag.deleteFeature(f1.id());
    pos_tag.deleteFeature(f2.id());
    pos_tag.deleteFeature(f3.id());
    block.deleteDataArray(number_feat.id());
    block.deleteDataArray(ramp_feat.id());
    block.deleteTag(pos_tag);
}


void BaseTestDataAccess::testMultiTagFeatureData() {
    DataArray index_data = block.createDataArray(&quot;indexed feature data&quot;, &quot;test&quot;, nix::DataType::Double, {10, 10});
    SampledDimension dim1 = index_data.appendSampledDimension(1.0);
    dim1.unit(&quot;ms&quot;);
    SampledDimension dim2 = index_data.appendSampledDimension(1.0);
    dim2.unit(&quot;ms&quot;);
    typedef boost::multi_array&lt;double, 2&gt; two_d_array;
    typedef two_d_array::index index;
    two_d_array data1(boost::extents[10][10]);
    index value;
    double total = 0.0;
    for(index i = 0; i != 10; ++i) {
        value = 100 * i;
        for(index j = 0; j != 10; ++j) {
            data1[i][j] = static_cast&lt;double&gt;(value++);
            total += data1[i][j];
        }
    }
    index_data.setData(data1);

    DataArray tagged_data = block.createDataArray(&quot;tagged feature data&quot;, &quot;test&quot;, nix::DataType::Double, {10, 20, 10, 10});
    dim1 = tagged_data.appendSampledDimension(1.0);
    dim1.unit(&quot;ms&quot;);
    dim2 = tagged_data.appendSampledDimension(1.0);
    dim2.unit(&quot;ms&quot;);
    SampledDimension dim3;
    dim3 = tagged_data.appendSampledDimension(1.0);
    dim3.unit(&quot;ms&quot;);
    SetDimension dim4 = tagged_data.appendSetDimension();
    typedef boost::multi_array&lt;double, 4&gt; four_d_array;
    typedef four_d_array::index four_d_index;
    four_d_array data2(boost::extents[10][20][10][10]);

    for(four_d_index i = 0; i != 2; ++i) {
        value = 100 * i;
        for(four_d_index j = 0; j != 20; ++j) {
            for(four_d_index k = 0; k != 10; ++k) {
                for (four_d_index l = 0; l != 10; ++l) {
                    data2[i][j][k][l] = static_cast&lt;double&gt;(value++);
                }
            }
        }
    }
    tagged_data.setData(data2);
    Feature index_feature = multi_tag.createFeature(index_data, nix::LinkType::Indexed);
    Feature tagged_feature = multi_tag.createFeature(tagged_data, nix::LinkType::Tagged);
    Feature untagged_feature = multi_tag.createFeature(index_data, nix::LinkType::Untagged);

    // preparations done, actually test
    std::vector&lt;ndsize_t&gt; indices(1, 0);
    CPPUNIT_ASSERT(multi_tag.featureCount() == 3);

    // indexed feature
    // read a single feature, old style function
    DataView data_view = util::retrieveFeatureData(multi_tag, 1, 0);
    CPPUNIT_ASSERT(data_view.dataExtent().size()  == 2);
    CPPUNIT_ASSERT(data_view.dataExtent().nelms() == 10);
    CPPUNIT_ASSERT_THROW(util::retrieveFeatureData(multi_tag, 10, 0), nix::OutOfBounds);
    CPPUNIT_ASSERT_NO_THROW(util::retrieveFeatureData(multi_tag, 1, index_feature));

    // read feature data, multiple indices at once
    data_view = util::featureData(multi_tag, indices, 0)[0];

    NDSize data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 2);
    CPPUNIT_ASSERT(data_size.nelms() == 10);
    double sum = 0.;
    double temp;
    NDSize offset(data_view.dataExtent().size(), 0);
    for (size_t i = 0; i &lt; data_size[1]; ++i){
        offset[1] = i;
        data_view.getData&lt;double&gt;(temp, offset);
        sum += temp;
    }
    CPPUNIT_ASSERT(sum == 45);

    indices[0] = 1;
    data_view = util::featureData(multi_tag, indices, 0)[0];
    sum = 0;
    for (size_t i = 0; i &lt; data_view.dataExtent()[1]; ++i){
        offset[1] = i;
        data_view.getData&lt;double&gt;(temp, offset);
        sum += temp;
    }
    CPPUNIT_ASSERT(sum == 1045);

    // untagged feature
    indices[0] = 0;
    data_view = util::featureData(multi_tag, indices, 2)[0];
    CPPUNIT_ASSERT(data_view.dataExtent().nelms() == 100);

    indices[0] = 1;
    data_view = util::featureData(multi_tag, indices, 2)[0];
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.nelms() == 100);
    sum = 0;
    for (size_t i = 0; i &lt; data_size[0]; ++i) {
        offset[0] = i;
        for (size_t j = 0; j &lt; data_size[1]; ++j) {
            offset[1] = j;
            data_view.getData&lt;double&gt;(temp, offset);
            sum += temp;
        }
    }
    CPPUNIT_ASSERT(sum == total);

    // tagged feature
    indices[0] = 0;
    data_view = util::featureData(multi_tag, indices, 1)[0];
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);

    data_view = util::featureData(multi_tag, indices, tagged_feature)[0];
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);

    indices[0] = 1;
    data_view = util::featureData(multi_tag, indices, 1)[0];
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);

    indices[0] = 2;
    CPPUNIT_ASSERT_THROW(util::featureData(multi_tag, indices, 1), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(util::featureData(multi_tag, indices, 3), nix::OutOfBounds);

    // test multiple positions
    std::vector&lt;nix::DataView&gt; views = util::featureData(multi_tag, {0, 1}, 0);
    CPPUNIT_ASSERT(views.size() == 2);
    CPPUNIT_ASSERT(views[0].dataExtent() == NDSize({1, 10}));
    CPPUNIT_ASSERT(views[0].dataExtent() == NDSize({1, 10}));

    // test positions without specifying
    indices.clear();
    views = util::featureData(multi_tag, indices, 0);
    CPPUNIT_ASSERT(views.size() == multi_tag.positionCount());

    // clean up
    multi_tag.deleteFeature(index_feature.id());
    multi_tag.deleteFeature(tagged_feature.id());
    multi_tag.deleteFeature(untagged_feature.id());
    block.deleteDataArray(tagged_data.id());
    block.deleteDataArray(index_data.id());
}


void BaseTestDataAccess::testMultiTagUnitSupport() {
    std::vector&lt;std::string&gt; valid_units{&quot;none&quot;,&quot;ms&quot;,&quot;ms&quot;};
    std::vector&lt;std::string&gt; invalid_units{&quot;mV&quot;, &quot;Ohm&quot;, &quot;muV&quot;};
    std::vector&lt;ndsize_t&gt; position_indices(1);

    MultiTag testTag = block.createMultiTag(&quot;test&quot;, &quot;testTag&quot;, multi_tag.positions());
    testTag.units(valid_units);
    testTag.addReference(data_array);
    
    position_indices[0] = 0;
    CPPUNIT_ASSERT_NO_THROW(util::retrieveData(testTag, position_indices, 0));
    
    testTag.units(nix::none);
    CPPUNIT_ASSERT_NO_THROW(util::retrieveData(testTag, position_indices, 0));
    
    testTag.units(invalid_units);
    CPPUNIT_ASSERT_THROW(util::taggedData(testTag, position_indices, 0), nix::IncompatibleDimensions);
}


void BaseTestDataAccess::testDataView() {
    NDSize zcount = {2, 5, 2, 5};
    NDSize zoffset = {0, 5, 2, 2};

    DataView io = DataView(data_array, zcount, zoffset);

    CPPUNIT_ASSERT_EQUAL(zcount, io.dataExtent());
    CPPUNIT_ASSERT_EQUAL(data_array.dataType(), io.dataType());

    typedef boost::multi_array&lt;double, 4&gt; array_type;
    array_type data(boost::extents[2][5][2][5]);
    io.getData(data);

    const array_type::size_type *ext = data.shape();
    for (size_t i = 0; i &lt; 4; i++) {
        CPPUNIT_ASSERT_EQUAL(static_cast&lt;array_type::size_type &gt;(zcount[i]), ext[i]);
    }

    array_type ref;
    data_array.getData(ref);

    for(size_t i = 0; i &lt; zcount[0]; ++i) {
        for(size_t j = 0; j &lt; zcount[1]; ++j) {
            for(size_t k = 0; k &lt; zcount[2]; ++k) {
                for (size_t l = 0; l &lt; zcount[3]; ++l) {
                    CPPUNIT_ASSERT_DOUBLES_EQUAL(ref[i + 0][j + 5][k + 2][l + 2],
                                                 data[i][j][k][l],
                                                 std::numeric_limits&lt;double&gt;::epsilon());
                    data[i][j][k][l] = 0.0;
                }
            }
        }
    }

    io.setData(data, {0, 0, 0, 0});
    data_array.getData(ref);

    for(size_t i = 0; i &lt; zcount[0]; ++i) {
        for(size_t j = 0; j &lt; zcount[1]; ++j) {
            for(size_t k = 0; k &lt; zcount[2]; ++k) {
                for (size_t l = 0; l &lt; zcount[3]; ++l) {
                    CPPUNIT_ASSERT_DOUBLES_EQUAL(ref[i + 0][j + 5][k + 2][l + 2],
                                                 0.0,
                                                 std::numeric_limits&lt;double&gt;::epsilon());
                }
            }
<A NAME="2"></A>        }
    }

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match943-1.html#2',3,'match943-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    double val = 0.0;
    CPPUNIT_ASSERT_THROW(io.getData(val, {}, {0, 0, 3, 2}), OutOfBounds);

    array_type r2d2(boost::extents[3][3][3][3]);
    CPPUNIT_ASSERT_THROW(io.getData(r2d2, {3, 3, 3, 3}, {}), OutOfBounds);

    CPPUNIT_ASSERT_THROW(io.dataExtent(zcount), std::runtime_error);

    CPPUNIT_ASSERT_THROW(DataView(data_array, {0, 0, 0, 0, 0}, {1, 1, 1}), IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(DataView(data_array, {0, 0, 0}, {1, 1}), IncompatibleDimensions);</B></FONT>
}


void BaseTestDataAccess::testDataSlice() {
    nix::Block b = file.createBlock(&quot;slicing data&quot;, &quot;nix.test&quot;);

    // 1D SampledDimension
    std::vector&lt;double&gt; time(1000);
    std::vector&lt;double&gt; voltage;
    double interval = 0.01;
    double pi = 3.1415;
    double freq = 1.5;
    std::iota(time.begin(), time.end(), 0.);
    std::transform(time.begin(), time.end(), time.begin(),
                   [interval](double t){ return t * interval; });
    std::transform(time.begin(), time.end(), std::back_inserter(voltage),
                   [pi, freq](double t) { return std::sin(t * freq * 2 * pi); });

    // create a DataArray
    nix::DataArray oned_array = b.createDataArray(&quot;sinewave&quot;, &quot;nix.sampled&quot;, nix::DataType::Double, {voltage.size()});
    oned_array.setData(voltage);
    oned_array.label(&quot;voltage&quot;);
    oned_array.unit(&quot;mV&quot;);

    nix::SampledDimension dim = oned_array.appendSampledDimension(interval);
    dim.label(&quot;time&quot;);
    dim.unit(&quot;s&quot;);

    // 2d data: Set - Sample
    typedef boost::multi_array&lt;double, 2&gt; array_type_2d;
    typedef array_type_2d::index index;

    array_type_2d data(boost::extents[10][time.size()]);
    for(index i = 0; i &lt; 10; ++i) {
        for (size_t j = 0; j &lt; time.size(); ++j) {
            data[i][j] = std::sin(time[j] * freq * 2 * pi + (i*2*pi/10));
        }
    }

    nix::NDSize data_shape(2, 10);  // NDSize object with rank two  10 elements per dim, for now
    data_shape[1] = time.size();
    // create the DataArray and store the data.
    nix::DataArray twod_array = b.createDataArray(&quot;2d sinewaves&quot;, &quot;nix.test&quot;, nix::DataType::Double, data_shape);
    twod_array.setData(data);
    twod_array.label(&quot;voltage&quot;);
    twod_array.unit(&quot;mV&quot;);
    twod_array.appendSetDimension();
    dim = twod_array.appendSampledDimension(interval);
    dim.label(&quot;time&quot;);
    dim.unit(&quot;s&quot;);

    // 2d data: Range - Sample
    std::vector&lt;double&gt; ticks(10);
    for(size_t i = 0; i &lt; 10; ++i) {
        ticks[i] = i * pi;
    }
    nix::DataArray twod_array2 = b.createDataArray(&quot;2d sinewaves 2&quot;, &quot;nix.test&quot;, nix::DataType::Double, data_shape);
    twod_array2.setData(data);
    twod_array2.label(&quot;voltage&quot;);
    twod_array2.unit(&quot;mV&quot;);
    RangeDimension rangeDim = twod_array2.appendRangeDimension(ticks);
    rangeDim.label(&quot;time&quot;);
    rangeDim.unit(&quot;s&quot;);
    dim = twod_array2.appendSampledDimension(interval);
    dim.label(&quot;time&quot;);
    dim.unit(&quot;s&quot;);

    // do the tests!
    nix::DataArray no_array;
    CPPUNIT_ASSERT_THROW(util::dataSlice(no_array, {1, 2}, {2,3}), nix::UninitializedEntity);
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1, 2}, {2, 3}), std::invalid_argument); // 1d data but called with 2d segment 
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1}, {2}, {&quot;ms&quot;, &quot;mV&quot;}), std::invalid_argument); // 1d positions, but two units
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1, 2, 3}, {1, 2}), std::invalid_argument); // different size of start and end
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {&quot;mV&quot;}), nix::IncompatibleDimensions); // sampledDimension represents time
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {&quot;ks&quot;}), nix::OutOfBounds); // well beyond data
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1.0}, {0.0}), std::invalid_argument); // start &gt; end

    CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}));
    CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {&quot;s&quot;}));
    CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {&quot;ms&quot;}));
    CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {0.001}, {&quot;ks&quot;}));
 
    // test with RangeMatch::Inclusive
    nix::DataView slice = util::dataSlice(oned_array, {0.0}, {1.0}, {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 101);

    slice = util::dataSlice(twod_array2, {3.14, 1.0}, {9.6, 2.0}, {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 3 &amp;&amp; slice.dataExtent()[1] == 101);

    slice = util::dataSlice(twod_array, {0., 0.0}, {9.0, 1.0}, {&quot;none&quot;, &quot;s&quot;}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 10 &amp;&amp; slice.dataExtent()[1] == 101);

    // test with RangeMatch::Exclusive
    slice = util::dataSlice(oned_array, {0.0}, {1.0}, {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 100);

    slice = util::dataSlice(oned_array, {1.0}, {1.0}, {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 1);

<A NAME="6"></A>    slice = util::dataSlice(twod_array2, {3.14, 1.0}, {9.6, 2.0}, {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 3 &amp;&amp; slice.dataExtent()[1] == 100);

<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match943-1.html#6',3,'match943-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    slice = util::dataSlice(twod_array, {0., 0.0}, {9.0, 1.0}, {&quot;none&quot;, &quot;s&quot;}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 9 &amp;&amp; slice.dataExtent()[1] == 100);

    b.deleteDataArray(oned_array);
    b.deleteDataArray(twod_array);
    file.deleteBlock(b);
}

void BaseTestDataAccess::testFlexibleTagging() {
    nix::Block b = file.createBlock(&quot;flexible tagging&quot;, &quot;nix.test&quot;);

    // create dummy data
    std::vector&lt;double&gt; data(1000, 0.0);</B></FONT>
    for (size_t i = 0; i &lt;data.size(); ++i) {
        data[i] = 3.14 * 1;
    }

    typedef boost::multi_array&lt;int, 2&gt; array_type_2d;
    typedef array_type_2d::index index;
    nix::NDSize data_shape_2d(2, 0);
    data_shape_2d[0] = 100;
    data_shape_2d[1] = 10;
    array_type_2d data2d(boost::extents[data_shape_2d[0]][data_shape_2d[1]]);
    for(index i = 0; i &lt; 100; ++i) {
        for(index j = 0; j &lt; 10; ++j) {
            data2d[i][j] = std::rand() % 100 + 1;
        }
    }

    typedef boost::multi_array&lt;int, 3&gt; array_type_3d;
    typedef array_type_3d::index index3;
    nix::NDSize data_shape_3d(3, 0);
    data_shape_3d[0] = 100;
    data_shape_3d[1] = 10;
    data_shape_3d[2] = 5;

    array_type_3d data3d(boost::extents[100][10][5]);
    for(index3 i = 0; i &lt; 100; ++i) {
        for(index3 j = 0; j &lt; 10; ++j) {
            for(index3 k = 0; k &lt; 5; ++k) {
                data3d[i][j][k] = std::rand() % 100 + 1;
            }
        }
    }
    // Create the DataArrays and store the data.
    nix::DataArray array = b.createDataArray(&quot;1d random data&quot;, &quot;nix.sampled&quot;, data);
    nix::SampledDimension dim = array.appendSampledDimension(0.1);
    dim.label(&quot;time&quot;);
    dim.unit(&quot;s&quot;);

    nix::DataArray array2d = b.createDataArray(&quot;2d random data&quot;, &quot;nix.sampled.2d&quot;, data2d);
    dim = array2d.appendSampledDimension(1.);
    dim.label(&quot;time&quot;);
    dim.unit(&quot;s&quot;);
    array2d.appendSetDimension();

    nix::DataArray array3d = b.createDataArray(&quot;3d random data&quot;, &quot;nix.sampled.3d&quot;, data3d);
    dim = array3d.appendSampledDimension(1.);
    dim.label(&quot;time&quot;);
    dim.unit(&quot;s&quot;);
    array3d.appendSetDimension();
    array3d.appendSetDimension();

    // Tag, tagging 2 dimensions
    nix::Tag tag = b.createTag(&quot;1stTag&quot;, &quot;nix.segment&quot;, {25, 0});
    tag.extent({50, 5});
    tag.units({&quot;s&quot;});
    tag.addReference(array);
    tag.addReference(array2d);
    tag.addReference(array3d);

    nix::DataView view = tag.taggedData(&quot;1d random data&quot;);
    nix::NDSize exp_shape({500});
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = tag.taggedData(&quot;2d random data&quot;);
    exp_shape = {50, 5};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = tag.taggedData(&quot;3d random data&quot;);
    exp_shape = {50, 5, 4};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    // Tag, tagging 3 dims without extents, i.e. a point
    nix::Tag ndTag = b.createTag(&quot;2ndTag&quot;, &quot;nix.points&quot;, {25, 0, 0});
    ndTag.addReference(array);
    ndTag.addReference(array2d);
    ndTag.addReference(array3d);

    view = ndTag.taggedData(&quot;1d random data&quot;);
    exp_shape = {1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = ndTag.taggedData(&quot;2d random data&quot;);
    exp_shape = {1, 1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = ndTag.taggedData(&quot;3d random data&quot;);
    exp_shape = {1, 1, 1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    //Tag, tagging 3d dims but with explicit zero extents
    nix::Tag rdTag = b.createTag(&quot;3rdTag11&quot;, &quot;nix.points&quot;, {25, 0, 0});
    rdTag.extent({0.0, 0.0, 0.0});
    rdTag.addReference(array);
    rdTag.addReference(array2d);
    rdTag.addReference(array3d);

    view = rdTag.taggedData(&quot;1d random data&quot;);
    exp_shape = {1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = rdTag.taggedData(&quot;2d random data&quot;);
    exp_shape = {1, 1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = rdTag.taggedData(&quot;3d random data&quot;);
    exp_shape = {1, 1, 1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    nix::Tag failTag = b.createTag(&quot;failing tag&quot;, &quot;nix.points&quot;, {25, 0, 0});
    failTag.extent({0.0, 0.0}); // this is invalid!
    failTag.addReference(array);
    failTag.addReference(array2d);
    failTag.addReference(array3d);

    CPPUNIT_ASSERT_THROW(failTag.taggedData(&quot;3d random data&quot;), nix::IncompatibleDimensions);

    // MultiTag
    typedef boost::multi_array&lt;double, 2&gt; pos_type;
    typedef pos_type::index index4;

    pos_type pos_data(boost::extents[5][2]);
    pos_type ext_data(boost::extents[5][2]);
    for(index4 i = 0; i &lt; 5; ++i) {
        pos_data[i][0] = i * 15.0 + 5.00;
        ext_data[i][0] = 10.0;
        pos_data[i][1] = 1.0;
        ext_data[i][1] = 2.0;
    }
    nix::DataArray positions = b.createDataArray(&quot;mtag positions&quot;, &quot;nix.positions.2d&quot;, pos_data);
    positions.appendSetDimension();
    positions.appendSetDimension();

    nix::DataArray extents = b.createDataArray(&quot;mtag_extents&quot;, &quot;nix.extents.2d&quot;, ext_data);
    extents.appendSetDimension();
    extents.appendSetDimension();

    nix::MultiTag mtag = b.createMultiTag(&quot;mtag&quot;, &quot;segments&quot;, positions);
    mtag.extents(extents);

    mtag.addReference(array);
    mtag.addReference(array2d);
    mtag.addReference(array3d);

    view = mtag.taggedData(0, &quot;1d random data&quot;);
    exp_shape = {100};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = mtag.taggedData(0, &quot;2d random data&quot;);
    exp_shape = {10, 2};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = mtag.taggedData(0, &quot;3d random data&quot;);
    exp_shape = {10, 2, 4};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
<A NAME="1"></A>

    // Test DataFrameDim
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match943-1.html#1',3,'match943-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    std::vector&lt;nix::Column&gt; cols = {{&quot;current&quot;, &quot;nA&quot;, nix::DataType::Double},
                                     {&quot;note&quot;, &quot;&quot;, nix::DataType::String}};
    nix::DataFrame df = b.createDataFrame(&quot;conditions&quot;, &quot;test&quot;, cols);
    std::vector&lt;nix::Variant&gt; vals(2);
    df.rows(10);
    for (int i = 0; i &lt; 10; ++i) {
        vals[0].set(i * 2.5);
        vals[1].set(&quot;test&quot;);
        df.writeRow(i, vals);
    }
    array3d.deleteDimensions();
    dim = array3d.appendSampledDimension(1.);
    dim.label(&quot;time&quot;);
    dim.unit(&quot;s&quot;);
    array3d.appendDataFrameDimension(df);
    array3d.appendSetDimension();

    nix::Tag dfTag = b.createTag(&quot;dftest&quot;, &quot;dftest&quot;, {25, 0});</B></FONT>
    dfTag.extent({50, 5});
    dfTag.addReference(array3d);

    view = dfTag.taggedData(&quot;3d random data&quot;);
    exp_shape = {50, 5, 4};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    dfTag.position({25});
    dfTag.extent({50});

    view = dfTag.taggedData(&quot;3d random data&quot;);
    exp_shape = {50, 9, 4};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    file.deleteBlock(b);
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestDimension.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in Section and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &lt;limits&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;stdexcept&gt;

#include &lt;nix/util/util.hpp&gt;
#include &lt;nix/valid/validate.hpp&gt;

#include &quot;BaseTestDimension.hpp&quot;

#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &lt;cppunit/CompilerOutputter.h&gt;
#include &lt;cppunit/TestResult.h&gt;
#include &lt;cppunit/TestResultCollector.h&gt;
#include &lt;cppunit/TestRunner.h&gt;
#include &lt;cppunit/BriefTestProgressListener.h&gt;
#include &lt;boost/math/constants/constants.hpp&gt;

using namespace nix;
using namespace valid;


void BaseTestDimension::testValidate() {
    Dimension d = data_array.appendSetDimension();
    valid::Result result = validate(d);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestDimension::testSetValidate() {
    SetDimension d = data_array.appendSetDimension();
    valid::Result result = validate(d);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestDimension::testRangeValidate() {
    std::vector&lt;double&gt; ticks;
    for (size_t i = 0; i &lt; 5; i++) {
        ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
    }
    RangeDimension d = data_array.appendRangeDimension(ticks);
    valid::Result result = validate(d);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestDimension::testSampleValidate() {
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();
    SampledDimension d = data_array.appendSampledDimension(samplingInterval);
    valid::Result result = validate(d);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestDimension::testIndex() {
    Dimension sd = data_array.appendSetDimension();
    CPPUNIT_ASSERT(data_array.dimensionCount() == 1 &amp;&amp; sd.index() == 1);
    data_array.deleteDimensions();
    CPPUNIT_ASSERT(data_array.dimensionCount() == 0);
}


void BaseTestDimension::testSampledDimLabel() {
    std::string label = &quot;aLabel&quot;;
    std::string other_label = &quot;anotherLabel&quot;;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    sd.label(label);
    CPPUNIT_ASSERT(*(sd.label()) == label);
    sd.label(other_label);
    CPPUNIT_ASSERT(*(sd.label()) == other_label);
    CPPUNIT_ASSERT_NO_THROW(sd.label(none));
    CPPUNIT_ASSERT(sd.label() == none);

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimUnit() {
    std::string invalidUnit = &quot;invalidunit&quot;;
    std::string validUnit = &quot;mV^2&quot;;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    CPPUNIT_ASSERT_THROW(sd.unit(invalidUnit), InvalidUnit);
    CPPUNIT_ASSERT_NO_THROW(sd.unit(validUnit));
    CPPUNIT_ASSERT(*(sd.unit()) == validUnit);
    CPPUNIT_ASSERT_NO_THROW(sd.unit(boost::none));
    CPPUNIT_ASSERT(sd.unit() == boost::none);
    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimSamplingInterval() {
    double impossible_sampling_interval = -1.0;
    double invalid_sampling_interval = 0.0;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    CPPUNIT_ASSERT(sd.samplingInterval() == boost::math::constants::pi&lt;double&gt;());
    CPPUNIT_ASSERT_THROW(sd.samplingInterval(impossible_sampling_interval), std::runtime_error);
    CPPUNIT_ASSERT_THROW(sd.samplingInterval(invalid_sampling_interval), std::runtime_error);
    CPPUNIT_ASSERT_NO_THROW(sd.samplingInterval(samplingInterval));
    CPPUNIT_ASSERT(sd.samplingInterval() == samplingInterval);

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimOffset() {
    double offset = 1.0;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    CPPUNIT_ASSERT_NO_THROW(sd.offset(offset));
    CPPUNIT_ASSERT(*(sd.offset()) == offset);
    CPPUNIT_ASSERT_NO_THROW(sd.offset(boost::none));
    CPPUNIT_ASSERT(sd.offset() == boost::none);

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimIndexOfOld() {
    double offset = 1.0;
    double samplingInterval = 1.0;

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
    SampledDimension sd;
    sd = d;
    // no offset, sampling interval = 1
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.5));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.0));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.5));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(10000000));

    CPPUNIT_ASSERT(sd.indexOf(-0.5) == 0);
    CPPUNIT_ASSERT(sd.indexOf(1.0) == 1);
    CPPUNIT_ASSERT(sd.indexOf(2.4) == 3);  // GreaterOrEqual
    CPPUNIT_ASSERT(sd.indexOf(4.28) == 5);
    CPPUNIT_ASSERT(sd.indexOf(6.99) == 7);
    CPPUNIT_ASSERT(sd.indexOf(7.0) == 7);

    // offset = 1.0 , sampling interval = 1.0
    sd.offset(offset);
    CPPUNIT_ASSERT(*(sd.offset()) == offset);
    
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-3.14));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.5));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(1.0));
    
    CPPUNIT_ASSERT(sd.indexOf(-1.0) == 0);
    CPPUNIT_ASSERT(sd.indexOf(0.0) == 0);
    CPPUNIT_ASSERT(sd.indexOf(2.0) == 1);
    CPPUNIT_ASSERT(sd.indexOf(6.28) == 6);
    CPPUNIT_ASSERT(sd.indexOf(3.75) == 3);

    // test ranges, offset = 1.0, sampling interval = 1.0
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.25, 1.01));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.0, 1.01));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(1.0, 1.01));
    CPPUNIT_ASSERT_THROW(sd.indexOf(1.01, 0.0), nix::OutOfBounds);

    CPPUNIT_ASSERT_THROW(sd.indexOf(-1.0, -.05), nix::OutOfBounds);  // because end pos is invalid
    std::pair&lt;ndsize_t, ndsize_t&gt; range = sd.indexOf(-1.0, 5.0);
    CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
    range = sd.indexOf(1.0, 5.0);
    CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
    CPPUNIT_ASSERT_THROW(sd.indexOf(5.0, 1.0), nix::OutOfBounds);
    range = sd.indexOf(1.5, 3.2);
<A NAME="2"></A>    CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 2); // less or equal for end of range
    range = sd.indexOf(1.5, 3.7);
    CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 2); // less or equal for end of range
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#2',2,'match943-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    range = sd.indexOf(1.5, 4.0);
    CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 3); // less or equal for end of range

    // test vectors of ranges, offset = 1, sampling interval = 1
    CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, 20.0, 40.0}, {10.9}), std::runtime_error);        
    CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, 20.0, 40.0}, {10.9, 12., 1.}), nix::OutOfBounds);
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.}));
    CPPUNIT_ASSERT(sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.}).size() == 3);</B></FONT>

    std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges = sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.});
    CPPUNIT_ASSERT(ranges.size() == 3);
    CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 9);
    CPPUNIT_ASSERT(sd.positionAt(ranges[0].first) == 1.0 &amp;&amp; sd.positionAt(ranges[0].second) == 10.); 
    CPPUNIT_ASSERT(ranges[1].first == 11 &amp;&amp; ranges[1].second == 19);
    CPPUNIT_ASSERT(sd.positionAt(ranges[1].first) == 12 &amp;&amp; sd.positionAt(ranges[1].second) == 20); 
    CPPUNIT_ASSERT(ranges[2].first == 0 &amp;&amp; ranges[2].second == 39);
    CPPUNIT_ASSERT(sd.positionAt(ranges[2].first) == 1. &amp;&amp; sd.positionAt(ranges[2].second) == 40); 

    // offset = -1.0 , sampling interval = 1.0
    sd.offset(-1.0);
    CPPUNIT_ASSERT(*(sd.offset()) == -1.0);
    
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-3.14));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-1.5));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.5));
    
    CPPUNIT_ASSERT(sd.indexOf(-3.14) == 0);
    CPPUNIT_ASSERT(sd.indexOf(-0.5) == 1);
    CPPUNIT_ASSERT(sd.indexOf(-1.0) == 0);
    CPPUNIT_ASSERT(sd.indexOf(0.5) == 2);
    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimIndexOf() {
    double samplingInterval = 1.;

    Dimension d = data_array.appendSampledDimension(samplingInterval);
<A NAME="0"></A>    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    sd = d;
    // offset = 0, sampling interval = 1
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater));
     
    CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Less));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater));

    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Less));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Greater));
   
    // offset = 1.0, sampling interval = 1
    sd.offset(1.0);
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater));
     
    CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Less));
    CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater));

    CPPUNIT_ASSERT(!sd.indexOf(1.0, PositionMatch::Less));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Greater));

    sd.offset(-1.0);
    // offset = -1.0, sampling interval = 1
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual) &amp;&amp; *sd.indexOf(-3.14, PositionMatch::GreaterOrEqual) == 0) ;
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater) &amp;&amp; *sd.indexOf(-3.14, PositionMatch::Greater) == 0);
     
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Less) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Less) == 0);
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::LessOrEqual) &amp;&amp; *sd.indexOf(0.0, PositionMatch::LessOrEqual) == 1);
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Equal) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Equal) == 1);
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual) &amp;&amp; *sd.indexOf(0.0, PositionMatch::GreaterOrEqual) == 1);
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Greater) == 2);</B></FONT>

    // test ranges offset = -1, sampling interval = 1
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 1 &amp;&amp; (*range).second == 1);
    range = sd.indexOf(0.0, 0.0, RangeMatch::Exclusive);    
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(-1.5, 2.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(-1.5, 2.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = sd.indexOf(2., -2.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range); // &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(2., -2.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range); // &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = sd.indexOf(2.0, 2.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(2., 2.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);

    // test vector of ranges, offset = -1, sampling interval = 1
    CPPUNIT_ASSERT_THROW(sd.indexOf({1.0, 20.0, 40.0}, {10.9, 12.}, RangeMatch::Exclusive), std::runtime_error);
    
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = sd.indexOf({1.0, 12.0, 1.0, 5.0}, {10.9, 20.0, 40.0, 5.0}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 2 &amp;&amp; (*ranges[0]).second == 11 &amp;&amp; 
                   sd.positionAt((*ranges[0]).first) &gt;= 1.0 &amp;&amp; sd.positionAt((*ranges[0]).second) &lt;= 10.9);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 13 &amp;&amp; (*ranges[1]).second == 21 &amp;&amp; 
                   sd.positionAt((*ranges[1]).first) == 12 &amp;&amp; sd.positionAt((*ranges[1]).second) == 20);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 2 &amp;&amp; (*ranges[2]).second == 41 &amp;&amp; 
                   sd.positionAt((*ranges[2]).first) == 1.0 &amp;&amp; sd.positionAt((*ranges[2]).second) == 40);
    CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 6 &amp;&amp; (*ranges[3]).second == 6 &amp;&amp; 
                   sd.positionAt((*ranges[3]).first) == 5 &amp;&amp; sd.positionAt((*ranges[3]).second) == 5);

    ranges = sd.indexOf({1.0, 12.0, 1.0, 5.0}, {10.9, 20.0, 40.0, 5.0}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 2 &amp;&amp; (*ranges[0]).second == 11 &amp;&amp; 
                   sd.positionAt((*ranges[0]).first) &gt;= 1.0 &amp;&amp; sd.positionAt((*ranges[0]).second) &lt;= 10.9);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 13 &amp;&amp; (*ranges[1]).second == 20 &amp;&amp; 
                   sd.positionAt((*ranges[1]).first) == 12 &amp;&amp; sd.positionAt((*ranges[1]).second) == 19);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 2 &amp;&amp; (*ranges[2]).second == 40 &amp;&amp; 
                   sd.positionAt((*ranges[2]).first) == 1.0 &amp;&amp; sd.positionAt((*ranges[2]).second) == 39);
    CPPUNIT_ASSERT(!ranges[3]);
    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimPositionAt() {
    double offset = 1.0;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    sd.offset(offset);
    CPPUNIT_ASSERT(sd.positionAt(0) == offset);
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        200 * samplingInterval + offset,
        sd.positionAt(200),
        std::numeric_limits&lt;double&gt;::round_error());

    CPPUNIT_ASSERT(sd[0] == offset);
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        200 * samplingInterval + offset,
        sd[200],
        std::numeric_limits&lt;double&gt;::round_error());

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimAxis() {
    double offset = 1.0;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    sd.offset(offset);

    std::vector&lt;double&gt; axis = sd.axis(100);
    CPPUNIT_ASSERT(axis.size() == 100);
    CPPUNIT_ASSERT(axis[0] == offset);
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        99 * samplingInterval + offset,
        axis.back(),
        std::numeric_limits&lt;double&gt;::round_error());

    axis = sd.axis(100, 10);
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        10 * samplingInterval + offset,
        axis[0],
        std::numeric_limits&lt;double&gt;::round_error());
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        109 * samplingInterval + offset,
        axis.back(),
        std::numeric_limits&lt;double&gt;::round_error());

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimOperators() {
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();
    Dimension d = data_array.appendSampledDimension(samplingInterval);
    Dimension d2 = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
    CPPUNIT_ASSERT(d2.dimensionType() == DimensionType::Sample);
    CPPUNIT_ASSERT_THROW(d.asRangeDimension(), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(d.asSetDimension(), nix::IncompatibleDimensions);
    SampledDimension sd1, sd2, sd3;
    sd1 = d;
    sd2 = d2;
    sd3 = data_array.getDimension(d.index());
    CPPUNIT_ASSERT(sd1.index() == d.index() &amp;&amp; sd2.index() == d2.index());
    CPPUNIT_ASSERT(sd1 != sd2);
    CPPUNIT_ASSERT(sd1 != sd3);
    data_array.deleteDimensions();
    Dimension dim = data_array.appendSetDimension();
    CPPUNIT_ASSERT_THROW(dim.asSampledDimension(), IncompatibleDimensions);
    SampledDimension sampled = data_array.appendSampledDimension(samplingInterval);
    RangeDimension range = data_array.appendRangeDimension(std::vector&lt;double&gt;({1, 2}));
    SetDimension set = data_array.appendSetDimension();
    std::stringstream s_stream, r_stream, set_stream;
    s_stream &lt;&lt; sampled.dimensionType();
    r_stream &lt;&lt; range.dimensionType();
    set_stream &lt;&lt; set.dimensionType();
    CPPUNIT_ASSERT(s_stream.str() == &quot;Sample&quot;);
    CPPUNIT_ASSERT(set_stream.str() == &quot;Set&quot;);
    CPPUNIT_ASSERT(r_stream.str() == &quot;Range&quot;);
    CPPUNIT_ASSERT(d != none);
    CPPUNIT_ASSERT(sampled != none);
    CPPUNIT_ASSERT(range != none);
    CPPUNIT_ASSERT(set != none);

    SampledDimension sd4;
    CPPUNIT_ASSERT_THROW(sd4 = range, nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_NO_THROW(sd4 = sampled);
    RangeDimension rd;
    CPPUNIT_ASSERT_THROW(rd = sampled, nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_NO_THROW(rd = range);
    SetDimension st;
    CPPUNIT_ASSERT_THROW(st = sampled, nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_NO_THROW(st = set);

    d = none; sampled = none; range = none; set = none;
    CPPUNIT_ASSERT(d == none);
    CPPUNIT_ASSERT(sampled == none);
    CPPUNIT_ASSERT(range == none);
    CPPUNIT_ASSERT(set == none);
}


void BaseTestDimension::testSetDimLabels() {
    std::vector&lt;std::string&gt; labels = {&quot;label_a&quot;, &quot;label_b&quot;,&quot;label_c&quot;,&quot;label_d&quot;,&quot;label_e&quot;};
    std::vector&lt;std::string&gt; new_labels = {&quot;new label_a&quot;, &quot;new label_b&quot;,&quot;new label_c&quot;};

    Dimension d = data_array.appendSetDimension();
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Set);

    SetDimension sd;
    sd = d;
    CPPUNIT_ASSERT(sd);
    sd.labels(labels);
    std::vector&lt;std::string&gt; retrieved_labels = sd.labels();
    CPPUNIT_ASSERT(retrieved_labels.size() == labels.size());
    for (size_t i = 0; i &lt; labels.size(); i++){
        CPPUNIT_ASSERT(labels[i] == retrieved_labels[i]);
    }

    sd.labels(new_labels);
    retrieved_labels = sd.labels();
    CPPUNIT_ASSERT(retrieved_labels.size() == new_labels.size());
    for (size_t i = 0; i &lt; new_labels.size(); i++){
        CPPUNIT_ASSERT(new_labels[i] == retrieved_labels[i]);
    }

    sd.labels(boost::none);
    retrieved_labels = sd.labels();
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), retrieved_labels.size());

    data_array.deleteDimensions();
}

void BaseTestDimension::testSetDimIndexOf() {
    std::vector&lt;std::string&gt; labels = {&quot;label_a&quot;, &quot;label_b&quot;,&quot;label_c&quot;,&quot;label_d&quot;,&quot;label_e&quot;};

    Dimension d = data_array.appendSetDimension();
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Set);
    SetDimension sd;
    sd = d;
    sd.labels(labels);

    boost::optional&lt;ndsize_t&gt; index;
    index = sd.indexOf(-1.0, PositionMatch::Less);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(-1.0, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(-1.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(-1.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
    index = sd.indexOf(-1.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);

    index = sd.indexOf(0.0, PositionMatch::Less);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(0.0, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
    index = sd.indexOf(0.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
    index = sd.indexOf(0.0000001, PositionMatch::Equal);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(0.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
    index = sd.indexOf(0.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 1);

    index = sd.indexOf(4.0, PositionMatch::Less);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 3);
    index = sd.indexOf(4.0, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(4.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(4.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(4.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(!index);

    index = sd.indexOf(5.0, PositionMatch::Less);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(5.0, PositionMatch::LessOrEqual);
<A NAME="4"></A>    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(5.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(!index);
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#4',2,'match943-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    index = sd.indexOf(5.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(5.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(!index);

    sd.labels(boost::none);
    index = sd.indexOf(5.0, PositionMatch::Less);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(5.0, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 6);

    index = sd.indexOf(5.5, PositionMatch::Less);</B></FONT>
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.5, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.5, PositionMatch::Equal);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(5.5, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 6);
    index = sd.indexOf(5.5, PositionMatch::Greater);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 6);

    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = sd.indexOf(0.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(0.0, 3.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(0.0, 3.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = sd.indexOf(3.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(3.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);

    sd.labels(labels);
    range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = sd.indexOf(1.0, 1.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(0.0, 3.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(0.0, 3.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = sd.indexOf(3.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(3.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(0.0, 7.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 4);
    range = sd.indexOf(3.0, 7.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);

    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges;
    CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, -1.0, 1.0}, {1.0, 2.0}, RangeMatch::Inclusive), std::runtime_error);
    ranges = sd.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 1);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 4);
<A NAME="6"></A>    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 4);
    CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 1 &amp;&amp; (*ranges[3]).second == 1);

<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#6',2,'match943-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    ranges = sd.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 0);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 3);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 4);
    CPPUNIT_ASSERT(!ranges[3]);
}

void BaseTestDimension::testRangeDimLabel() {
    std::string label = &quot;aLabel&quot;;
    std::string other_label = &quot;anotherLabel&quot;;</B></FONT>
    std::vector&lt;double&gt; ticks;
    for (size_t i = 0; i &lt; 5; i++) {
        ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
    }

    Dimension d = data_array.appendRangeDimension(ticks);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    rd.label(label);
    CPPUNIT_ASSERT(*(rd.label()) == label);
    rd.label(other_label);
    CPPUNIT_ASSERT(*(rd.label()) == other_label);
    rd.label(none);
    CPPUNIT_ASSERT(rd.label() == none);

    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimUnit() {
    std::string invalidUnit = &quot;invalidunit&quot;;
    std::string validUnit = &quot;ms&quot;;

    std::vector&lt;double&gt; ticks;
    for (size_t i = 0; i &lt; 5; i++) {
        ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
    }
    Dimension d = data_array.appendRangeDimension(ticks);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    CPPUNIT_ASSERT_THROW(rd.unit(invalidUnit), InvalidUnit);
    CPPUNIT_ASSERT_NO_THROW(rd.unit(validUnit));
    CPPUNIT_ASSERT(*(rd.unit()) == validUnit);
    CPPUNIT_ASSERT_NO_THROW(rd.unit(none));
    CPPUNIT_ASSERT(rd.unit() == none);

    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeTicks() {
    std::vector&lt;double&gt; ticks = {1.0, 2.0, 3.4, 42.0};
    std::vector&lt;double&gt; new_ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    std::vector&lt;double&gt; unordered_ticks = {-20.0, -100.0, 10.0, -10.0, 0.0};
    std::vector&lt;double&gt; double_ticks = {-20.0, -10.0, 10.0, -10.0, -20.0};

    Dimension d = data_array.appendRangeDimension(ticks);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    CPPUNIT_ASSERT(rd.ticks().size() == ticks.size());
    std::vector&lt;double&gt; retrieved_ticks = rd.ticks();
    CPPUNIT_ASSERT(retrieved_ticks.size() == ticks.size());
    for (size_t i = 0; i &lt; ticks.size(); i++) {
        CPPUNIT_ASSERT(ticks[i] == retrieved_ticks[i]);
    }
    CPPUNIT_ASSERT_THROW(rd.ticks(unordered_ticks), UnsortedTicks);
    CPPUNIT_ASSERT_THROW(rd.ticks(double_ticks), UnsortedTicks);
    rd.ticks(new_ticks);
    retrieved_ticks = rd.ticks();
    CPPUNIT_ASSERT(retrieved_ticks.size() == new_ticks.size());
    for (size_t i = 0; i &lt; new_ticks.size(); i++) {
        CPPUNIT_ASSERT(new_ticks[i] == retrieved_ticks[i]);
    }

    ticks.resize(100);
    for (size_t i = 0; i &lt; 100; ++i) {
        ticks[i] = i * 3.14;
    }
    rd.ticks(ticks);
    CPPUNIT_ASSERT(rd.ticks(0, 10).size() == 10);
    CPPUNIT_ASSERT(rd.ticks(1, 99).size() == 99);
    CPPUNIT_ASSERT(rd.ticks(10, 1)[0] == 10 * 3.14);
    CPPUNIT_ASSERT(rd.ticks(20, 1)[0] == 20 * 3.14);

    CPPUNIT_ASSERT_THROW(rd.ticks(0, ticks.size() + 10), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.ticks(20, ticks.size() - 10), nix::OutOfBounds);
    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimIndexOfOld() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    CPPUNIT_ASSERT(rd.indexOf(-100.) == 0);
    CPPUNIT_ASSERT(rd.indexOf(-50.) == 0);
    CPPUNIT_ASSERT(rd.indexOf(-70.) == 0);
    CPPUNIT_ASSERT(rd.indexOf(-10.0) == 1);
    CPPUNIT_ASSERT(rd.indexOf(-5.0) == 1);
    CPPUNIT_ASSERT(rd.indexOf(5.0) == 2);

    CPPUNIT_ASSERT_NO_THROW(rd.indexOf(257.28));
    CPPUNIT_ASSERT_THROW(rd.indexOf(257.28, false), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.indexOf(-257.28), nix::OutOfBounds);
    CPPUNIT_ASSERT_NO_THROW(rd.indexOf(-257.28, false));

    CPPUNIT_ASSERT_THROW(rd.indexOf(110., 120.), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.indexOf(-120., -110.), nix::OutOfBounds);
    std::pair&lt;ndsize_t, ndsize_t&gt; range = rd.indexOf(-100., 100.);
    CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
    range = rd.indexOf(-200., 200.);
    CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);

    CPPUNIT_ASSERT_THROW(rd.indexOf({-100.0, -90, 0.0}, {10.}), std::runtime_error);
    CPPUNIT_ASSERT_NO_THROW(rd.indexOf({-100.0, 20.0, 40.0}, {-45, 120., 100.}));
    CPPUNIT_ASSERT(rd.indexOf({-100.0, 20.0, 40.0}, {-45, 120., 100.}, false).size() == 3);
    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimIndexOf() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

<A NAME="3"></A>    RangeDimension rd;
    rd = d;

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#3',2,'match943-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CPPUNIT_ASSERT(*rd.indexOf(-110., PositionMatch::GreaterOrEqual) == 0);
    CPPUNIT_ASSERT(*rd.indexOf(-110., PositionMatch::GreaterOrEqual) == 0);
    CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::Less));
    CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::Equal));

    CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::GreaterOrEqual) == 0);
    CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::Greater) == 1);
    CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::LessOrEqual) == 0);
    CPPUNIT_ASSERT(!rd.indexOf(-100., PositionMatch::Less));
    CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::Equal) == 0);

    CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::GreaterOrEqual) == 1);
    CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::Greater) == 1);
    CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::LessOrEqual) == 0);
    CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::Less) == 0);
    CPPUNIT_ASSERT(!rd.indexOf(-50., PositionMatch::Equal));

    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::GreaterOrEqual) == 3);
    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::Greater) == 3);
    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::LessOrEqual) == 2);
<A NAME="5"></A>    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::Less) == 2);</B></FONT>
    CPPUNIT_ASSERT(!rd.indexOf(7., PositionMatch::Equal));

<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#5',2,'match943-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::GreaterOrEqual) == 3);
    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Greater) == 4);
    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::LessOrEqual) == 3);
    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Less) == 2);
    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Equal) == 3);

    CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::Greater));
    CPPUNIT_ASSERT(*rd.indexOf(110., PositionMatch::LessOrEqual) == 4);
    CPPUNIT_ASSERT(*rd.indexOf(110., PositionMatch::Less) == 4);
    CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::Equal));

    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range;
    range = rd.indexOf(40., 100., {}, RangeMatch::Inclusive);</B></FONT>
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(40., 100., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = rd.indexOf(-100., -45., {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = rd.indexOf(-100., -45., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = rd.indexOf(10., 120., {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(10., 120., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(100., 120., {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(100., 120., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(110., 150., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = rd.indexOf(100., -100., {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = rd.indexOf(100., -100., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);

    range = rd.indexOf(100., -100., rd.ticks(), RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);

    std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges;
    ranges = rd.indexOf({40., -100.}, {100., 100.}, true, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(ranges.size() == 2);
    CPPUNIT_ASSERT(ranges[0].first == 4 &amp;&amp; ranges[0].second == 4);
    CPPUNIT_ASSERT(ranges[1].first == 0 &amp;&amp; ranges[1].second == 4);
    
    CPPUNIT_ASSERT_THROW(rd.indexOf({40., -100., -100.}, {100., 100., 101.}, true, RangeMatch::Exclusive), nix::OutOfBounds);
    
    ranges = rd.indexOf({40., -100., -100.}, {100., 100., 101.}, false, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(ranges.size() == 2);
    CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 3);
    CPPUNIT_ASSERT(ranges[1].first == 0 &amp;&amp; ranges[1].second == 4);
    
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; optranges;
    optranges = rd.indexOf({40., -100.}, {100., 100.}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(optranges.size() == 2);
    CPPUNIT_ASSERT(optranges[0] &amp;&amp; (*optranges[0]).first == 4 &amp;&amp; (*optranges[0]).second == 4);
    CPPUNIT_ASSERT(optranges[1] &amp;&amp; (*optranges[1]).first == 0 &amp;&amp; (*optranges[1]).second == 4);

    optranges = rd.indexOf({40., -100., -100.}, {100., 100., 101.}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(optranges.size() == 3);
    CPPUNIT_ASSERT(!optranges[0]);
    CPPUNIT_ASSERT(optranges[1] &amp;&amp; (*optranges[1]).first == 0 &amp;&amp; (*optranges[1]).second == 3);
    CPPUNIT_ASSERT(optranges[2] &amp;&amp; (*optranges[2]).first == 0 &amp;&amp; (*optranges[2]).second == 4);
    
    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimTickAt() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    CPPUNIT_ASSERT(rd.tickAt(0) == -100.);
    CPPUNIT_ASSERT(rd.tickAt(4) == 100.);
    CPPUNIT_ASSERT_THROW(rd.tickAt(10), OutOfBounds);

    CPPUNIT_ASSERT(rd[0] == -100.);
    CPPUNIT_ASSERT(rd[4] == 100.);
    CPPUNIT_ASSERT_THROW(rd[10], OutOfBounds);

    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimAxis() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;

    std::vector&lt;double&gt; axis = rd.axis(2);
    CPPUNIT_ASSERT(axis.size() == 2);
    CPPUNIT_ASSERT(axis[0] == -100.0);
    CPPUNIT_ASSERT(axis[1] == -10.0);

    axis = rd.axis(2, 2);
    CPPUNIT_ASSERT(axis.size() == 2);
    CPPUNIT_ASSERT(axis[0] == 0.0);
    CPPUNIT_ASSERT(axis[1] == 10.0);

    CPPUNIT_ASSERT_THROW(rd.axis(10), OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.axis(2, 10), OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.axis(std::numeric_limits&lt;ndsize_t&gt;::max(), static_cast&lt;size_t&gt;(1)), OutOfBounds);
}


void BaseTestDimension::testRangeDimPositionInRange() {
<A NAME="7"></A>    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#7',2,'match943-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
    RangeDimension rd = d.asRangeDimension();

    CPPUNIT_ASSERT(rd.positionInRange(-99.0) == nix::PositionInRange::InRange);
    CPPUNIT_ASSERT(rd.positionInRange(99.0) == nix::PositionInRange::InRange);
    CPPUNIT_ASSERT(rd.positionInRange(100.1) == nix::PositionInRange::Greater);
    CPPUNIT_ASSERT(rd.positionInRange(-100.1) == nix::PositionInRange::Less);

    rd.ticks({});</B></FONT>
    CPPUNIT_ASSERT(rd.positionInRange(0.1) == nix::PositionInRange::NoRange);
}
<A NAME="1"></A>

void BaseTestDimension::testDataFrameDimIndexOf() {
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#1',2,'match943-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    std::vector&lt;nix::Column&gt; cols = {{&quot;current&quot;, &quot;nA&quot;, nix::DataType::Double},
                                     {&quot;note&quot;, &quot;&quot;, nix::DataType::String}};
    nix::DataFrame df = block.createDataFrame(&quot;conditions&quot;, &quot;test&quot;, cols);
    std::vector&lt;nix::Variant&gt; vals(2);
    df.rows(10);
    for (int i = 0; i &lt; 10; ++i) {
        vals[0].set(i * 2.5);
        vals[1].set(&quot;test&quot;);
        df.writeRow(i, vals);
    }

    Dimension d = data_array.appendDataFrameDimension(df, 0);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::DataFrame);
    DataFrameDimension dfDim;
    dfDim = d;</B></FONT>

    boost::optional&lt;ndsize_t&gt; pos = dfDim.indexOf(12.2, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(12.2, PositionMatch::Greater);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(12.2, PositionMatch::Equal);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(12.2, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
    pos = dfDim.indexOf(12.2, PositionMatch::Less);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);

    pos = dfDim.indexOf(9, PositionMatch::Greater);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(9, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
    pos = dfDim.indexOf(9, PositionMatch::Equal);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
    pos = dfDim.indexOf(9, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
    pos = dfDim.indexOf(9, PositionMatch::Less);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 8);

    pos = dfDim.indexOf(5, PositionMatch::Greater);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 6);
    pos = dfDim.indexOf(5, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
    pos = dfDim.indexOf(5, PositionMatch::Equal);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
    pos = dfDim.indexOf(5, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
    pos = dfDim.indexOf(5, PositionMatch::Less);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 4);

    pos = dfDim.indexOf(0.5, PositionMatch::Greater);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 1);
    pos = dfDim.indexOf(0.5, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 1);
    pos = dfDim.indexOf(0.5, PositionMatch::Equal);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(0.5, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
    pos = dfDim.indexOf(0.5, PositionMatch::Less);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);

    pos = dfDim.indexOf(-0.5, PositionMatch::Greater);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
    pos = dfDim.indexOf(-0.5, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
    pos = dfDim.indexOf(-0.5, PositionMatch::Equal);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(-0.5, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(-0.5, PositionMatch::Less);
    CPPUNIT_ASSERT(!pos);
 
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = dfDim.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = dfDim.indexOf(0.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(0.0, 3.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = dfDim.indexOf(0.0, 3.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = dfDim.indexOf(3.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(3.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    
    range = dfDim.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = dfDim.indexOf(1.0, 1.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(0.0, 3.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = dfDim.indexOf(0.0, 3.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = dfDim.indexOf(3.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(3.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(0.0, 9.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 9);
    range = dfDim.indexOf(3.0, 9.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 8);

    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges;
    CPPUNIT_ASSERT_THROW(dfDim.indexOf({0.0, -1.0, 1.0}, {1.0, 2.0}, RangeMatch::Inclusive), std::runtime_error);
    ranges = dfDim.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 1);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 4);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 9);
    CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 1 &amp;&amp; (*ranges[3]).second == 1);

    ranges = dfDim.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 0);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 3);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 8);
    CPPUNIT_ASSERT(!ranges[3]);
}

void BaseTestDimension::testAsDimensionMethods() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension x;
    Dimension d = data_array.appendRangeDimension(ticks);
    CPPUNIT_ASSERT_THROW(d.asSampledDimension(), IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(d.asSetDimension(), IncompatibleDimensions);
    x = d;
    CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Range);
    std::stringstream sa_str;
    sa_str &lt;&lt; x.dimensionType();
    CPPUNIT_ASSERT(sa_str.str() == &quot;Range&quot;);

    data_array.deleteDimensions();
    d = data_array.appendSampledDimension(0.1);
    CPPUNIT_ASSERT_THROW(d.asRangeDimension(), IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(d.asSetDimension(), IncompatibleDimensions);
    x = d;
    CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Sample);
    std::stringstream range_str;
    range_str &lt;&lt; x.dimensionType();
    CPPUNIT_ASSERT(range_str.str() == &quot;Sample&quot;);

    data_array.deleteDimensions();
    d = data_array.appendSetDimension();
    CPPUNIT_ASSERT_THROW(d.asRangeDimension(), IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(d.asSampledDimension(), IncompatibleDimensions);
    x = d;
    CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Set);
    std::stringstream set_str;
    set_str &lt;&lt; x.dimensionType();
    CPPUNIT_ASSERT(set_str.str() == &quot;Set&quot;);
}
</PRE>
</div>
  </div>
</body>
</html>
