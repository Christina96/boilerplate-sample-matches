<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for YShortcut.h & TreeItem.h</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 15% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
</HEAD>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
        <h3 align="center">
            Matches for YShortcut.h & TreeItem.h
        </h3>
        <h1 align="center">
            8.3%
        </h1>
        <center>
            <a href="index.html" target="_top">
                INDEX
            </a>
            <span>-</span>
            <a href="help-en.html" target="_top">
                HELP
            </a>
        </center>
    </div>
    <div>
        <TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
            <TR><TH><TH>YShortcut.h (9.090909%)<TH>TreeItem.h (7.7922077%)<TH>Tokens
            <TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' ><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-1.html#0',3)" NAME="0">(73-85)<TD><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-1.html#0',3)" NAME="0">(127-137)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
        </TABLE>
    </div>
</div>
<hr>
<div style="display: flex;">
    <div style="flex-grow: 1;">
        <h3>
            <center>
                <span>YShortcut.h</span>
                <span> - </span>
                <span></span>
            </center>
        </h3>
        <HR>
        <PRE>
/*
  Copyright (C) 2000-2012 Novell, Inc
  This library is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation; either version 2.1 of the
  License, or (at your option) version 3.0 of the License. This library
  is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
  License for more details. You should have received a copy of the GNU
  Lesser General Public License along with this library; if not, write
  to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  Floor, Boston, MA 02110-1301 USA
*/


/*-/

  File:		YShortcut.h

  Author:	Stefan Hundhammer &lt;shundhammer@suse.de&gt;

/-*/


#ifndef YShortcut_h
#define YShortcut_h

#include &lt;iosfwd&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &quot;YWidget.h&quot;
#include &quot;YItem.h&quot;


/**
 * Helper class for shortcut management:
 * This class holds data about the shortcut for one single widget.
 *
 * Notice that there is also a derived class YItemShortcut for item-based
 * widgets that may have multiple shortcuts like YDumbTab, YMenuBar,
 * YItemSelector.
 **/
class YShortcut
{
public:
    /**
     * Constructor
     * @param shortcut_widget (not owned, not nullptr)
     **/
    YShortcut( YWidget *shortcut_widget );

    /**
     * Destructor
     **/
    virtual ~YShortcut();

    /**
     * Marker for &quot;no shortcut&quot;
     **/
    enum { None = 0 };

    /**
     * Returns the YWidget this shortcut data belong to.
     **/
    YWidget * widget() const { return _widget; }

    /**
<A NAME="0"></A>     * Returns the textual representation of the widget class of the widget
     * this shortcut data belongs to.
     **/
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match943-1.html#0',3,'match943-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    const char * widgetClass() const { return widget()-&gt;widgetClass(); }

    /**
     * Returns 'true' if the widget that is associated with this shortcut is a
     * button (derived from YPushButton).
     **/
    bool isButton() const { return _isButton; }

    /**
     * Returns 'true' if the widget that is associated with this shortcut is a
     * wizard button (one of the navigation buttons of a wizard).
     **/
    bool isWizardButton() const { return _isWizardButton; }</B></FONT>

    /**
     * Returns 'true' if this is a shortcut for a (toplevel) menu item.
     *
     * This default implementation always returns 'false'.
     * Derived classes like YItemShortcut can choose to overwrite this.
     **/
    virtual bool isMenuItem() const { return false; }

    /**
     * Returns the complete shortcut string (which may or may not contain &quot;&amp;&quot;),
     * i.e. the value of the widget's shortcut property. For PushButtons, this
     * is the label on the button ( e.g., &quot;&amp;Details...&quot; ), for other widgets
     * usually the caption above it.
     *
     * This value is chached, i.e. this isn't a too expensive operation.
     **/
    std::string shortcutString();

    /**
     * Returns the shortcut string ( from the widget's shortcut property )
     * without any &quot;&amp;&quot; markers.
     *
     * But an escaped &quot;&amp;&amp;&quot; is preserved.
     **/
    std::string cleanShortcutString();

    /**
     * Static version of the above for general use:
     * Returns the specified string without any &quot;&amp;&quot; markers.
     * But an escaped &quot;&amp;&amp;&quot; is preserved.
     **/
    static std::string cleanShortcutString( std::string shortcutString );

    /**
     * The preferred shortcut character, i.e. the character that had been
     * preceded by &quot;&amp;&quot; before checking / resolving conflicts began. 0 if none.
     **/
    char preferred();

    /**
     * The actual shortcut character. 0 if none.
     *
     * This may be different from preferred() if it is overridden.
     **/
    char shortcut();

    /**
     * Set (override) the shortcut character.
     **/
    virtual void setShortcut( char newShortcut );

    /**
     * Clear the shortcut: Override the shortcut character with nothing.
     * This may happen if a conflict cannot be resolved.
     **/
    void clearShortcut();

    /**
     * Query the internal 'conflict' marker. This class doesn't care about that
     * flag, it just stores it for the convenience of higher-level classes.
     **/
    bool conflict() { return _conflict; }

    /**
     * Set or unset the internal 'conflict' marker.
     **/
    void setConflict( bool newConflictState = true ) { _conflict = newConflictState; }

    /**
     * Obtain the number of distinct valid shortcut characters in the shortcut
     * string, i.e. how many different shortcuts that widget could get.
     **/
    int distinctShortcutChars();

    /**
     * Return true if this shortcut contains any character that would be valid
     * as a shortcut character.
     **/
    bool hasValidShortcutChar();

    /**
     * Label of this shortcut suitable for debugging
     **/
    virtual std::string debugLabel() const { return _widget-&gt;debugLabel(); }

    /**
     * Static function: Returns the character used for marking keyboard
     * shortcuts.
     **/
    static char shortcutMarker() { return '&amp;'; }

    /**
     * Static function: Find the next occurrence of the shortcut marker ('&amp;')
     * in a string, beginning at starting position start_pos.
     *
     * An escaped &quot;&amp;&amp;&quot; does not count.
     *
     * Returns string::npos if not found or the position of the shortcut marker
     * (not the shortcut character!) if found.
     **/
    static std::string::size_type findShortcutPos( const std::string &amp; str, std::string::size_type start_pos = 0 );

    /**
     * Static function: Find the next shortcut marker in a string, beginning at
     * starting position start_pos.
     *
     * Returns the shortcut character or 0 if none found.
     **/
    static char findShortcut( const std::string &amp; str, std::string::size_type start_pos = 0 );

    /**
     * Returns 'true' if 'c' is a valid shortcut character, i.e. [a-zA-Z0-9],
     * 'false' otherwise.
     **/
    static bool isValid( char c );

    /**
     * Return the normalized version of shortcut character 'c', i.e. a
     * lowercase letter or a digit [a-z0-9]. Returns 0 if 'c' is invalid.
     **/
    static char normalized( char c );

    /**
     * Obtain a widget's shortcut property - the string that contains &quot;&amp;&quot; to
     * designate a shortcut.
     **/
    static std::string getShortcutString( const YWidget * widget );


protected:

    /**
     * Obtain the the shortcut property of this shortcut's widget - the string
     * that contains &quot;&amp;&quot; to designate a shortcut.
     **/
    virtual std::string getShortcutString();


    // Data members

    YWidget *	_widget;               ///&lt; (not owned)
    std::string	_shortcutString;       ///&lt; @see shortcutString
    bool	_shortcutStringCached; ///&lt; is _shortcutString initialized

    std::string	_cleanShortcutString;
    bool	_cleanShortcutStringCached; ///&lt; always false :facepalm:

    /// char or 0 (none found) or -1 (not initialized yet)
    /// @see preferred
    int		_preferred;

    /// char or 0 (none found) or -1 (not initialized yet)
    /// @see shortcut
    int		_shortcut;

    bool	_conflict;       ///&lt; @see conflict
    bool	_isButton;       ///&lt; @see isButton
    bool	_isWizardButton; ///&lt; @see isWizardButton

    /// -1 means uninitialized
    /// @see distinctShortcutChars
    int		_distinctShortcutChars;
};



/**
 * Special case for item-based widgets that can have multiple shortcuts like
 * YDumbTab, YMenuBar, YItemSelector. Each instance represents one of those
 * items.
 *
 * For YMenuBar, only the toplevel items are handled here since only their
 * shortcuts need to be unique within the dialog. Within each menu, shortcut
 * conflicts are resolved separately in YMenuWidget.
 **/
class YItemShortcut: public YShortcut
{
public:
    /**
     * Constructor.
     **/
    YItemShortcut( YWidget * widget, YItem * item );

    /**
     * Destructor.
     **/
    virtual ~YItemShortcut() {}

    /**
     * Return the associated item.
     **/
    YItem * item() const { return _item; }

    /**
     * Set (override) the shortcut character.
     *
     * Reimplemented from YShortcut.
     * In this subclass, it will change the internally stored item.
     **/
    virtual void setShortcut( char newShortcut );

    /**
     * Returns 'true' if this is a shortcut for a (toplevel) menu item.
     *
     * Reimplemented from YShortcut.
     **/
    virtual bool isMenuItem() const { return _isMenuItem; }

    /**
     * Label of this shortcut suitable for debugging
     **/
    virtual std::string debugLabel() const
        { return cleanShortcutString( _item-&gt;debugLabel() ); }


protected:

    /**
     * Obtain the the shortcut property of this shortcut's widget - the string
     * that contains &quot;&amp;&quot; to designate a shortcut.
     **/
    virtual std::string getShortcutString();


private:

    YItem * _item;
    bool    _isMenuItem;
};


std::ostream &amp; operator&lt;&lt;( std::ostream &amp; stream, const YShortcut * shortcut );


typedef std::vector&lt;YShortcut *&gt;	YShortcutList;
typedef YShortcutList::iterator		YShortcutListIterator;


#endif // YShortcut_h
</PRE>
    </div>
    <div style="flex-grow: 1;">
        <h3>
            <center>
                <span>TreeItem.h</span>
                <span> - </span>
                <span></span>
            </center>
        </h3>
        <HR>
        <PRE>
/*
  Copyright (C) 2000-2012 Novell, Inc
  This library is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation; either version 2.1 of the
  License, or (at your option) version 3.0 of the License. This library
  is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
  License for more details. You should have received a copy of the GNU
  Lesser General Public License along with this library; if not, write
  to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  Floor, Boston, MA 02110-1301 USA
*/


/*-/

  File:		TreeItem.h

  Author:	Stefan Hundhammer &lt;shundhammer@suse.de&gt;

/-*/

#ifndef TreeItem_h
#define TreeItem_h

#include &lt;string&gt;




/**
 * Template class for tree items that can handle tree children in a
 * generic way - firstChild(), next() and parent(). Each item stores one value
 * of type 'PAYLOAD'.
 *
 * Class 'PAYLOAD' needs to provide operator=().
 **/
template&lt;class PAYLOAD&gt; class TreeItem
{
public:

    /**
     * Constructor. Creates a new tree item with value &quot;val&quot; and inserts it
     * ( without maintaining any meaningful sort order! ) into the children list
     * of &quot;parent&quot;.
     **/
    TreeItem&lt;PAYLOAD&gt; ( const PAYLOAD &amp;		val,
			TreeItem&lt;PAYLOAD&gt; * 	parent = 0 )
	: _value( val )
	, _parent( parent )
	, _next(0)
	, _firstChild(0)
    {
	if ( _parent )
	    _parent-&gt;addChild( this );
    }


protected:

    /**
     * Constructor to be called for derived classes: Decide whether or not to
     * automatically insert this item into the parent's children list. Useful
     * for derived classes that want to maintain a specific sort order among
     * children.
     **/
    TreeItem&lt;PAYLOAD&gt; ( PAYLOAD			val,
			bool 			autoAddChild,
			TreeItem&lt;PAYLOAD&gt; * 	parent = 0 )
	: _value( val )
	, _parent( parent )
	, _next(0)
	, _firstChild(0)
    {
	if ( _parent &amp;&amp; autoAddChild )
	    _parent-&gt;addChild( this );
    }


private:
    /**
     * Private ( i.e. disabled ) copy constructor and operator=()
     * - neither makes any sense with this class.
     **/
    TreeItem&lt;PAYLOAD&gt;             ( const TreeItem&lt;PAYLOAD&gt; &amp; ) {}
    TreeItem&lt;PAYLOAD&gt; &amp; operator= ( const TreeItem&lt;PAYLOAD&gt; &amp; ) {}


public:

    /**
     * Destructor. Takes care of children - they will be deleted along with
     * this item.
     **/
    virtual ~TreeItem&lt;PAYLOAD&gt; ()
    {
	TreeItem&lt;PAYLOAD&gt; * child = firstChild();

	while ( child )
	{
	    TreeItem&lt;PAYLOAD&gt; * lastChild = child;
	    child = child-&gt;next();
	    delete lastChild;
	}
    }


    /**
     * Returns this item's value, the &quot;payload&quot;.
     **/
    const PAYLOAD &amp; value() const { return _value; }

    /**
     * Set this item's value, the &quot;payload&quot;.
     *
     * If the sort order among children of one level is important, overwrite
     * this method and change the sort order according to the new value.
     * The template class itself never calls this.
     **/
    void setValue( PAYLOAD newValue ) { _value = newValue; }

<A NAME="0"></A>    /**
     * Returns this item's parent or 0 if there is none.
     **/
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    TreeItem&lt;PAYLOAD&gt; * 	parent() 	const { return _parent; 	}

    /**
     * Returns this item's next sibling or 0 if there is none.
     **/
    TreeItem&lt;PAYLOAD&gt; * 	next() 		const { return _next; 		}

    /**
     * Returns this item's first child or 0 if there is none.
     **/
    TreeItem&lt;PAYLOAD&gt; * 	firstChild()	const { return _firstChild;	}</B></FONT>

    /**
     * Sets this item's parent.
     **/
    void setParent( TreeItem&lt;PAYLOAD&gt; * newParent )	{ _parent = newParent;	}

    /**
     * Sets this item's next sibling.
     **/
    void setNext( TreeItem&lt;PAYLOAD&gt; * newNext )		{ _next = newNext;	}

    /**
     * Sets this item's first child.
     **/
    void setFirstChild(	TreeItem&lt;PAYLOAD&gt; * newFirstChild )
	{ _firstChild = newFirstChild; }


    /**
     * Add a child to the internal children list - usually called from within
     * the child's default constructor.
     *
     * This default method does not maintain any meaningful sorting order -
     * derived classes that require this might want to use the other
     * constructor ( with 'autoAddChild' set to 'false' ) take care of child
     * insertion themselves.
     **/
    void addChild( TreeItem&lt;PAYLOAD&gt; * newChild )
    {
	if ( newChild )
	{
	    newChild-&gt;setNext( firstChild() );
	    setFirstChild( newChild );
	}
    }


protected:

    PAYLOAD		_value;
    TreeItem&lt;PAYLOAD&gt; *	_parent;
    TreeItem&lt;PAYLOAD&gt; * _next;
    TreeItem&lt;PAYLOAD&gt; * _firstChild;
};



/**
 * Template class for tree items that maintain sort order.
 *
 * Class 'PAYLOAD' to provide operator&lt;() in addition to what template
 *'TreeItem' requires.
 **/
template&lt;class PAYLOAD&gt; class SortedTreeItem: public TreeItem&lt;PAYLOAD&gt;
{
public:

    /**
     * Constructor. Creates a new tree item with value &quot;val&quot; and inserts it in
     * ascending sort order into the children list of &quot;parent&quot;.
     **/
    SortedTreeItem&lt;PAYLOAD&gt;( PAYLOAD 			val,
			     SortedTreeItem&lt;PAYLOAD&gt; * 	parentItem = 0 )
	: TreeItem&lt;PAYLOAD&gt; ( val, false, parentItem )
    {
	if ( parentItem )
	{
	    // Hopefully we have a SortedTreeItem parent
	    SortedTreeItem&lt;PAYLOAD&gt; * sortParent =
		dynamic_cast&lt;SortedTreeItem&lt;PAYLOAD&gt; *&gt; ( parentItem );

	    if ( sortParent )
		sortParent-&gt;insertChildSorted( this );
	    else // no SortedTreeItem parent - add unsorted
		parentItem-&gt;addChild( this );
	}
    }


    /**
     * Destructor.
     **/
    virtual ~SortedTreeItem&lt;PAYLOAD&gt; () {}


    /**
     * Insert a child into the internal children list in ascending sort order.
     * Called from the new child's constructor, thus 'public'.
     **/
    void insertChildSorted( SortedTreeItem&lt;PAYLOAD&gt; * newChild )
    {
	if ( ! newChild )
	    return;

	if ( ! firstChild() ||
	     newChild-&gt;value() &lt; firstChild()-&gt;value() )
	{
	    // Insert as first child

	    newChild-&gt;setNext( firstChild() );
	    this-&gt;setFirstChild( newChild );
	}
	else
	{
	    // Search correct place to insert

	    TreeItem&lt;PAYLOAD&gt; * child = firstChild();

	    while ( child-&gt;next() &amp;&amp;
		    child-&gt;next()-&gt;value() &lt; newChild-&gt;value() )
	    {
		child = child-&gt;next();
	    }


	    // Insert after 'child'

	    newChild-&gt;setNext( child-&gt;next() );
	    child-&gt;setNext( newChild );
	}
    }


    /**
     * Returns this item's parent or 0 if there is none.
     **/
    SortedTreeItem&lt;PAYLOAD&gt; * 	parent() 	const
	{ return ( SortedTreeItem&lt;PAYLOAD&gt; * ) TreeItem&lt;PAYLOAD&gt;::_parent; }

    /**
     * Returns this item's next sibling or 0 if there is none.
     **/
    SortedTreeItem&lt;PAYLOAD&gt; * 	next() 		const
	{ return ( SortedTreeItem&lt;PAYLOAD&gt; * ) TreeItem&lt;PAYLOAD&gt;::_next; }

    /**
     * Returns this item's first child or 0 if there is none.
     **/
    SortedTreeItem&lt;PAYLOAD&gt; * 	firstChild()	const
	{ return ( SortedTreeItem&lt;PAYLOAD&gt; * ) TreeItem&lt;PAYLOAD&gt;::_firstChild; }


private:

    /**
     * Private ( i.e. disabled ) copy constructor and operator=()
     * - neither makes any sense with this class.
     **/
    SortedTreeItem&lt;PAYLOAD&gt;             ( const SortedTreeItem&lt;PAYLOAD&gt; &amp; ) {}
    SortedTreeItem&lt;PAYLOAD&gt; &amp; operator= ( const SortedTreeItem&lt;PAYLOAD&gt; &amp; ) {}
};



/**
 * Find a direct child ( i.e., non-recursive ) with value &quot;searchVal&quot;.
 * Returns 0 if there is no such child.
 **/
template&lt;class ITEM, class PAYLOAD&gt; inline
ITEM *
findDirectChild( ITEM * item, PAYLOAD searchVal )
{
    TreeItem&lt;PAYLOAD&gt; * child = item-&gt;firstChild();

    while ( child )
    {
	if ( child-&gt;value() == searchVal )
	    return dynamic_cast&lt;ITEM *&gt; ( child );

	child = child-&gt;next();
    }

    return 0;
}



#endif // TreeItem_h
</PRE>
    </div>
</div>
<div class="modal" id="myModal" style="display:none;"><div><span class="close">x</span><div class="modal-content"><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
