<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for BaseTestDataAccess.cpp &amp; BaseTestDimension.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for BaseTestDataAccess.cpp &amp; BaseTestDimension.cpp
      </h3>
<h1 align="center">
        15.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>BaseTestDataAccess.cpp (13.787375%)<th>BaseTestDimension.cpp (17.043121%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(37-67)<td><a href="#" name="0">(247-299)</a><td align="center"><font color="#ff0000">48</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(936-953)<td><a href="#" name="1">(901-916)</a><td align="center"><font color="#8f0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(652-661)<td><a href="#" name="2">(206-213)</a><td align="center"><font color="#640000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(236-309)<td><a href="#" name="3">(746-767)</a><td align="center"><font color="#640000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(398-412)<td><a href="#" name="4">(538-555)</a><td align="center"><font color="#550000">16</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(90-100)<td><a href="#" name="5">(770-783)</a><td align="center"><font color="#450000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(767-779)<td><a href="#" name="6">(606-616)</a><td align="center"><font color="#3f0000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(175-183)<td><a href="#" name="7">(887-895)</a><td align="center"><font color="#3f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestDataAccess.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4996)
#endif

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iterator&gt;
#include &lt;stdexcept&gt;

#include &lt;nix/hydra/multiArray.hpp&gt;
#include &lt;nix/util/dataAccess.hpp&gt;

#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &lt;cppunit/CompilerOutputter.h&gt;
#include &lt;cppunit/TestResult.h&gt;
#include &lt;cppunit/TestResultCollector.h&gt;
#include &lt;cppunit/TestRunner.h&gt;
#include &lt;cppunit/BriefTestProgressListener.h&gt;

#include "BaseTestDataAccess.hpp"

using namespace nix;
using namespace std;
using namespace boost;

<a name="0"></a>void BaseTestDataAccess::testPositionToIndexRangeDimension() {
    string unit = "ms";
    string invalid_unit = "kV";
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    string scaled_unit = "s";

    CPPUNIT_ASSERT_THROW(util::positionToIndex(5.0, invalid_unit, rangeDim), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT(*util::positionToIndex(5.0, unit, PositionMatch::Less, rangeDim) == 3);
    CPPUNIT_ASSERT(*util::positionToIndex(0.005, scaled_unit, PositionMatch::Less, rangeDim) == 3);

    CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::Less, rangeDim));
    CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::LessOrEqual, rangeDim));
    CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::Equal, rangeDim));
    CPPUNIT_ASSERT(*(util::positionToIndex(1.0, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 0);
    CPPUNIT_ASSERT(*(util::positionToIndex(1.0, unit, PositionMatch::Greater, rangeDim)) == 0);

    CPPUNIT_ASSERT(!util::positionToIndex(1.2, unit, PositionMatch::Less, rangeDim));
    CPPUNIT_ASSERT(util::positionToIndex(1.2, unit, PositionMatch::LessOrEqual, rangeDim));
    CPPUNIT_ASSERT(util::positionToIndex(1.2, unit, PositionMatch::Equal, rangeDim));
    CPPUNIT_ASSERT(*(util::positionToIndex(1.2, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 0);
    CPPUNIT_ASSERT(*(util::positionToIndex(1.2, unit, PositionMatch::Greater, rangeDim)) == 1);

    CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::Less, rangeDim) == 2);
    CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::LessOrEqual, rangeDim) == 3);
    CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::Equal, rangeDim) == 3);
    CPPUNIT_ASSERT(*(util::positionToIndex(4.5, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 3);
    CPPUNIT_ASSERT(*(util::positionToIndex(4.5, unit, PositionMatch::Greater, rangeDim)) == 4);

    CPPUNIT_ASSERT(*util::positionToIndex(7.0, unit, PositionMatch::Less, rangeDim) == 4);
    CPPUNIT_ASSERT(*util::positionToIndex(7.0, unit, PositionMatch::LessOrEqual, rangeDim) == 4);
    CPPUNIT_ASSERT(!util::positionToIndex(7.0, unit, PositionMatch::Equal, rangeDim));
    CPPUNIT_ASSERT(!(util::positionToIndex(7.0, unit, PositionMatch::GreaterOrEqual, rangeDim)));
    CPPUNIT_ASSERT(!util::positionToIndex(7.0, unit, PositionMatch::Greater, rangeDim));

    CPPUNIT_ASSERT_THROW(util::positionToIndex({5.0, 1.2}, {1.4}, {unit, unit}, RangeMatch::Inclusive, rangeDim), std::runtime_error);</b></font>

    vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; range = util::positionToIndex({0.0}, {7.0}, {unit}, RangeMatch::Inclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 4);
    range = util::positionToIndex({0.0}, {7.0}, {unit}, RangeMatch::Exclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 4);
    
    range = util::positionToIndex({2.0}, {6.7}, {unit}, RangeMatch::Inclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 1 &amp;&amp; (*range[0]).second == 4);
    range = util::positionToIndex({2.0}, {6.7}, {unit}, RangeMatch::Exclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 1 &amp;&amp; (*range[0]).second == 3);

    range = util::positionToIndex({1.2}, {1.2}, {unit}, RangeMatch::Inclusive, rangeDim);
    CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 0);
    range = util::positionToIndex({1.2}, {1.2}, {unit}, RangeMatch::Exclusive, rangeDim);
    CPPUNIT_ASSERT(!range[0]);
}

void BaseTestDataAccess::testPositionToIndexRangeDimensionOld() {
    string unit = "ms";
<a name="5"></a>    string invalid_unit = "kV";
    string scaled_unit = "s";

<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    CPPUNIT_ASSERT_THROW(util::positionToIndex(0.001, invalid_unit, rangeDim), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(util::positionToIndex(8.0, unit, rangeDim), nix::OutOfBounds);
    CPPUNIT_ASSERT(util::positionToIndex(0.001, unit, rangeDim) == 0);
    CPPUNIT_ASSERT(util::positionToIndex(0.001, scaled_unit, rangeDim) == 0);
    CPPUNIT_ASSERT_THROW(util::positionToIndex(0.008, scaled_unit, rangeDim), nix::OutOfBounds);
    CPPUNIT_ASSERT(util::positionToIndex(3.4, unit, rangeDim) == 2);
    CPPUNIT_ASSERT(util::positionToIndex(3.6, unit, rangeDim) == 3);
    CPPUNIT_ASSERT(util::positionToIndex(4.0, unit, rangeDim) == 3);
    CPPUNIT_ASSERT(util::positionToIndex(0.0034, scaled_unit, rangeDim) == 2);

    vector&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt; range = util::positionToIndex({0.001}, {3.4}, {unit}, rangeDim);</b></font>
    CPPUNIT_ASSERT(range[0].first == 0 &amp;&amp; range[0].second == 2);
    CPPUNIT_ASSERT_THROW(util::positionToIndex({0.001, 2.0}, {3.4}, {unit}, rangeDim), std::runtime_error);
    CPPUNIT_ASSERT_THROW(util::positionToIndex({7.5}, {8.0}, {unit}, rangeDim), nix::OutOfBounds);
}


void BaseTestDataAccess::testGetDimensionUnit() {
    std::vector&lt;nix::Column&gt; cols = {{"current", "nA", nix::DataType::Double},
                                     {"note", "", nix::DataType::String}};
    DataFrame df = block.createDataFrame("test", "test", cols);

    data_array.appendDataFrameDimension(df);
    data_array.appendDataFrameDimension(df, 1);

    std::string unit = "ms";
    std::string no_unit = "none";

    std::vector&lt;Dimension&gt; dims = data_array.dimensions();
    CPPUNIT_ASSERT(dims.size() == 6);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[0]), no_unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[1]), unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[2]), unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[3]), cols[0].unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[4]), no_unit);
    CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[5]), no_unit);
}


void BaseTestDataAccess::testPositionToIndexSampledDimension() {
    string unit = "ms";
    string invalid_unit = "kV";
    string scaled_unit = "s";
    // test incompatible dims
    CPPUNIT_ASSERT_THROW(util::positionToIndex(1.0, invalid_unit, sampledDim), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(1.0, unit, sampledDim));
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(1.0, scaled_unit, sampledDim));

    sampledDim.unit(nix::none);
    CPPUNIT_ASSERT_THROW(util::positionToIndex(1.0, unit, sampledDim), nix::IncompatibleDimensions);
    sampledDim.unit(unit);

    vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({0.0, 2.0, 10.0}, {10.0, 2.0, 5.0}, {unit, unit, unit}, RangeMatch::Inclusive, sampledDim);
    CPPUNIT_ASSERT(ranges.size() == 3);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 10);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 2 &amp;&amp; (*ranges[1]).second == 2);
    CPPUNIT_ASSERT(!ranges[2]);// &amp;&amp; (*ranges[2]).first == 5 &amp;&amp; (*ranges[2]).second == 10);

    ranges = util::positionToIndex({0.0, 2.0, 10.0}, {10.0, 2.0, 5.0}, {unit, unit, unit}, RangeMatch::Exclusive, sampledDim);
    CPPUNIT_ASSERT(ranges.size() == 3);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 9);
    CPPUNIT_ASSERT(!ranges[1]);
    CPPUNIT_ASSERT(!ranges[2]); // &amp;&amp; (*ranges[2]).first == 5 &amp;&amp; (*ranges[2]).second == 9);
}

void BaseTestDataAccess::testPositionToIndexSampledDimensionOld() {
    string unit = "ms";
    string invalid_unit = "kV";
    string scaled_unit = "s";

    CPPUNIT_ASSERT(util::positionToIndex(-8.0, unit, sampledDim) == 0);
    CPPUNIT_ASSERT_THROW(util::positionToIndex(0.005, invalid_unit, sampledDim), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT(util::positionToIndex(5.0, unit, sampledDim) == 5);
    CPPUNIT_ASSERT(util::positionToIndex(0.005, scaled_unit, sampledDim) == 5);

    CPPUNIT_ASSERT_THROW(util::positionToIndex({},{1.0}, {unit}, sampledDim), std::runtime_error);
    CPPUNIT_ASSERT_THROW(util::positionToIndex({0.0, 1.0}, {3.5, 0.5}, {unit, unit}, sampledDim), nix::OutOfBounds);
    CPPUNIT_ASSERT(util::positionToIndex({0.0, 0.5}, {3.5, 1.0}, {unit, unit}, sampledDim).size() == 2);

    vector&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges = util::positionToIndex({0.0}, {0.0}, {unit}, sampledDim);
    CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 0);
}
<a name="7"></a>

void BaseTestDataAccess::testPositionToIndexSetDimensionOld() {
<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    std::string unit = "ms";
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(-5.9, "none", setDim)); // because old style defaults to GreaterOrEqual
    CPPUNIT_ASSERT_THROW(util::positionToIndex(5.8, "none", setDim), nix::OutOfBounds); // labels are set, but too few
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(0.5, "none", setDim));
    CPPUNIT_ASSERT(util::positionToIndex(0.5, "none", setDim) == 1);


    std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges;
    CPPUNIT_ASSERT_THROW(util::positionToIndex({10}, {1.}, {"none"}, setDim), nix::OutOfBounds);</b></font>
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex({1}, {10.}, {"none"}, setDim));

    int pos = -1;
    CPPUNIT_ASSERT_NO_THROW(check::converts_to_double(pos, "Does not convert seamlessly to double!"));
    ndsize_t large_pos = pow(10, 16);
    CPPUNIT_ASSERT_NO_THROW(check::converts_to_double(large_pos, "Does not convert seamlessly to double!"));
    large_pos = pow(10, 16);
    large_pos += 1;
    CPPUNIT_ASSERT_THROW(check::converts_to_double(large_pos, "Does not convert seamlessly to double!"), nix::OutOfBounds);
}


void BaseTestDataAccess::testPositionToIndexSetDimension() {
    CPPUNIT_ASSERT(!util::positionToIndex(5.8, PositionMatch::Equal, setDim));

    CPPUNIT_ASSERT_THROW(util::positionToIndex({5.0, 0.}, {10.5}, RangeMatch::Inclusive, setDim), std::runtime_error);
    
    vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({5.0, 0.}, {10.5, 1.0}, RangeMatch::Inclusive, setDim);
    CPPUNIT_ASSERT(ranges.size() == 2);
    CPPUNIT_ASSERT(!ranges[0]);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 1);

    ranges = util::positionToIndex({5.0, 0.}, {10.5, 1.0}, RangeMatch::Exclusive, setDim);
    CPPUNIT_ASSERT(ranges.size() == 2);
    CPPUNIT_ASSERT(!ranges[0]);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 0);   
}


void BaseTestDataAccess::testPositionToIndexDataFrameDimension() {
    CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(12.2, PositionMatch::GreaterOrEqual, dfDim)); // no throw even though not valid
    boost::optional&lt;ndsize_t&gt; pos = util::positionToIndex(12.2, PositionMatch::GreaterOrEqual, dfDim);
    CPPUNIT_ASSERT(!pos);

    
    CPPUNIT_ASSERT_THROW(util::positionToIndex({1.0, 2.0}, {0.0}, RangeMatch::Exclusive, dfDim), std::runtime_error);
    vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({0.0, 12.0, 5.0}, {9.0, 15.0, 0.0}, RangeMatch::Exclusive, dfDim);
    CPPUNIT_ASSERT(ranges.size() == 3);
    CPPUNIT_ASSERT(ranges[0]);
    CPPUNIT_ASSERT(!ranges[1]);
    CPPUNIT_ASSERT(!ranges[2]);
}


void BaseTestDataAccess::testOffsetAndCount() {
    NDSize offsets, counts;
    /*
     std::vector&lt;double&gt; position {0.0, 2.0, 3.4, 1.0};
     std::vector&lt;double&gt; extent {0.0, 6.0, 2.3, 1.0};
<a name="3"></a>     std::vector&lt;std::string&gt; units {"none", "ms", "ms"};
    */
    // implicitely calls with range = RangeMatch::Inclusive, 
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    util::getOffsetAndCount(position_tag, data_array, offsets, counts);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);

    // even if called with RangeMatch::Exclusive it will return count == 1
    util::getOffsetAndCount(position_tag, data_array, offsets, counts, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);

    position_tag.units(std::vector&lt;std::string&gt;());
    util::getOffsetAndCount(position_tag, data_array, offsets, counts);
    CPPUNIT_ASSERT(position_tag.units().size() == 0);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);

    /*
     Test a tag with position and extents
     position {0.0, 2.0, 3.4, 1.0};
     extent {0.0, 6.0, 2.3, 1.0};
     units {"none", "ms", "ms"};
     ref_dims = {Set (labels:{"label_a", "label_b"}), Sampled(1.0, ms), Range(ticks:{1.2, 2.3, 3.4, 4.5, 6.7}, ms),
     DataFrame(ticks:{0., 2.5, 5.0, 7.5, 10.0, 12.5, 15., 17.5, 20., 22.5})}
    */
    // call with RangeMatch::Inclusive
    util::getOffsetAndCount(segment_tag, data_array, offsets, counts);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 7 &amp;&amp; counts[2] == 2);

    // call with RangeMatch::Exclusive
    util::getOffsetAndCount(segment_tag, data_array, offsets, counts, RangeMatch::Exclusive);

    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 6 &amp;&amp; counts[2] == 2);

    /*
    MultiTag:
    positions = [0.0 --&gt; 0.0, 3.0 --&gt; 9.0,  3.4 --&gt; 5.7, 1.0 --&gt; 3.0];  // position 1
                [0.0 --&gt; 0.0, 8.0 --&gt; 11.0, 2.3 --&gt; 4.3, 1.0 --&gt; 7.0];  // position 2

    ref_array {Set, Sample, Range, DataFrame}, as above
    */
    // calling with RangeMatch::Inclusive
    CPPUNIT_ASSERT_THROW(util::getOffsetAndCount(multi_tag, data_array, -1, offsets, counts), nix::OutOfBounds); // not a valid position index
    CPPUNIT_ASSERT_THROW(util::getOffsetAndCount(multi_tag, data_array, 3, offsets, counts), nix::OutOfBounds); // not a valid position index

    util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 3 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 7 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 3);

    util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 3 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 6 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 2);

    util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts);
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 8 &amp;&amp; offsets[2] == 1 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 4 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 7);

    util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts, RangeMatch::Exclusive);</b></font>
    CPPUNIT_ASSERT(offsets.size() == 4);
    CPPUNIT_ASSERT(counts.size() == 4);
    CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 8 &amp;&amp; offsets[2] == 1 &amp;&amp; offsets[3] == 1);
    CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 3 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 6);
}


void BaseTestDataAccess::testPositionInData() {
    NDSize offsets, counts;
    util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts);
    CPPUNIT_ASSERT(util::positionInData(data_array, offsets));
    CPPUNIT_ASSERT(util::positionAndExtentInData(data_array, offsets, counts));

    util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts);
    CPPUNIT_ASSERT(util::positionInData(data_array, offsets));
    CPPUNIT_ASSERT(!util::positionAndExtentInData(data_array, offsets, counts));
}


void BaseTestDataAccess::testRetrieveData() {
    std::vector&lt;ndsize_t&gt; position_indices(1, 0);
    CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 1), nix::OutOfBounds);

    position_indices[0] = 10;
    CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 0), nix::OutOfBounds);

    position_indices[0] = 0;
    std::vector&lt;DataView&gt; views;
    views = util::taggedData(multi_tag, position_indices, 0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(views.size() == 1);
    nix::DataView v = util::taggedData(multi_tag, 0, 0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT_EQUAL(v.dataExtent(), views[0].dataExtent());

    std::vector&lt;ndsize_t&gt; temp;
    std::vector&lt;DataView&gt; slices = util::taggedData(mtag2, temp, 0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slices.size() == mtag2.positions().dataExtent()[0]);

    // old-style calls, deprecated
    CPPUNIT_ASSERT_NO_THROW(util::retrieveData(mtag2, 0, 0));
    CPPUNIT_ASSERT_NO_THROW(util::retrieveData(mtag2, 0, mtag2.references()[0]));

    slices = util::taggedData(pointmtag, temp, 0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slices.size() == pointmtag.positions().dataExtent()[0]);

    DataView data_view = views[0];
    NDSize data_size = data_view.dataExtent();

    CPPUNIT_ASSERT(data_size.size() == 4);
    CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 7 &amp;&amp; data_size[2] == 2 &amp;&amp; data_size[3] == 3);
    position_indices[0] = 1;
    CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 0), nix::OutOfBounds);

    data_view = util::taggedData(position_tag, 0, RangeMatch::Inclusive);
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);
    CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 1 &amp;&amp; data_size[2] == 1 &amp;&amp; data_size[3] == 1);

    data_view = util::taggedData(segment_tag, 0, RangeMatch::Inclusive);
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);
    CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 7 &amp;&amp; data_size[2] == 2 &amp;&amp; data_size[3] == 2);

    DataView times_view = util::taggedData(times_tag, 0, RangeMatch::Inclusive);
    data_size = times_view.dataExtent();
    std::vector&lt;double&gt; times(data_size.size());
    times_view.getData(times);
    RangeDimension dim = times_tag.references()[0].dimensions()[0].asRangeDimension();
    CPPUNIT_ASSERT(data_size.size() == 1);
    CPPUNIT_ASSERT(data_size[0] == 77);
}


void BaseTestDataAccess::testTagFeatureData() {
    DataArray number_feat = block.createDataArray("number feature", "test", nix::DataType::Double, {1});
    std::vector&lt;double&gt; number = {10.0};
    number_feat.setData(number);
    DataArray ramp_feat = block.createDataArray("ramp feature", "test", nix::DataType::Double, {10});
    ramp_feat.label("voltage");
    ramp_feat.unit("mV");
    SampledDimension dim = ramp_feat.appendSampledDimension(1.0);
    dim.unit("ms");
    std::vector&lt;double&gt; ramp_data = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};
    ramp_feat.setData(ramp_data);

    Tag pos_tag = block.createTag("feature test", "test", {5.0});
<a name="4"></a>    pos_tag.units({"ms"});

    Feature f1 = pos_tag.createFeature(number_feat, nix::LinkType::Untagged);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    Feature f2 = pos_tag.createFeature(ramp_feat, nix::LinkType::Tagged);
    Feature f3 = pos_tag.createFeature(ramp_feat, nix::LinkType::Untagged);

    DataView data1 = util::featureData(pos_tag, 0);
    DataView data2 = util::featureData(pos_tag, 1);
    DataView data3 = util::featureData(pos_tag, 2);

    CPPUNIT_ASSERT(pos_tag.featureCount() == 3);
    CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data2.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());

    data1 = util::featureData(pos_tag, f1);
    data2 = util::featureData(pos_tag, f2);
    data3 = util::featureData(pos_tag, f3);</b></font>

    CPPUNIT_ASSERT(pos_tag.featureCount() == 3);
    CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data2.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());

    // make tag pointing to a slice
    pos_tag.extent({2.0});
    data1 = util::featureData(pos_tag, 0);
    data2 = util::featureData(pos_tag, 1);
    data3 = util::featureData(pos_tag, 2);

    CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
    CPPUNIT_ASSERT(data2.dataExtent().nelms() == 2);
    CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());

    pos_tag.deleteFeature(f1.id());
    pos_tag.deleteFeature(f2.id());
    pos_tag.deleteFeature(f3.id());
    block.deleteDataArray(number_feat.id());
    block.deleteDataArray(ramp_feat.id());
    block.deleteTag(pos_tag);
}


void BaseTestDataAccess::testMultiTagFeatureData() {
    DataArray index_data = block.createDataArray("indexed feature data", "test", nix::DataType::Double, {10, 10});
    SampledDimension dim1 = index_data.appendSampledDimension(1.0);
    dim1.unit("ms");
    SampledDimension dim2 = index_data.appendSampledDimension(1.0);
    dim2.unit("ms");
    typedef boost::multi_array&lt;double, 2&gt; two_d_array;
    typedef two_d_array::index index;
    two_d_array data1(boost::extents[10][10]);
    index value;
    double total = 0.0;
    for(index i = 0; i != 10; ++i) {
        value = 100 * i;
        for(index j = 0; j != 10; ++j) {
            data1[i][j] = static_cast&lt;double&gt;(value++);
            total += data1[i][j];
        }
    }
    index_data.setData(data1);

    DataArray tagged_data = block.createDataArray("tagged feature data", "test", nix::DataType::Double, {10, 20, 10, 10});
    dim1 = tagged_data.appendSampledDimension(1.0);
    dim1.unit("ms");
    dim2 = tagged_data.appendSampledDimension(1.0);
    dim2.unit("ms");
    SampledDimension dim3;
    dim3 = tagged_data.appendSampledDimension(1.0);
    dim3.unit("ms");
    SetDimension dim4 = tagged_data.appendSetDimension();
    typedef boost::multi_array&lt;double, 4&gt; four_d_array;
    typedef four_d_array::index four_d_index;
    four_d_array data2(boost::extents[10][20][10][10]);

    for(four_d_index i = 0; i != 2; ++i) {
        value = 100 * i;
        for(four_d_index j = 0; j != 20; ++j) {
            for(four_d_index k = 0; k != 10; ++k) {
                for (four_d_index l = 0; l != 10; ++l) {
                    data2[i][j][k][l] = static_cast&lt;double&gt;(value++);
                }
            }
        }
    }
    tagged_data.setData(data2);
    Feature index_feature = multi_tag.createFeature(index_data, nix::LinkType::Indexed);
    Feature tagged_feature = multi_tag.createFeature(tagged_data, nix::LinkType::Tagged);
    Feature untagged_feature = multi_tag.createFeature(index_data, nix::LinkType::Untagged);

    // preparations done, actually test
    std::vector&lt;ndsize_t&gt; indices(1, 0);
    CPPUNIT_ASSERT(multi_tag.featureCount() == 3);

    // indexed feature
    // read a single feature, old style function
    DataView data_view = util::retrieveFeatureData(multi_tag, 1, 0);
    CPPUNIT_ASSERT(data_view.dataExtent().size()  == 2);
    CPPUNIT_ASSERT(data_view.dataExtent().nelms() == 10);
    CPPUNIT_ASSERT_THROW(util::retrieveFeatureData(multi_tag, 10, 0), nix::OutOfBounds);
    CPPUNIT_ASSERT_NO_THROW(util::retrieveFeatureData(multi_tag, 1, index_feature));

    // read feature data, multiple indices at once
    data_view = util::featureData(multi_tag, indices, 0)[0];

    NDSize data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 2);
    CPPUNIT_ASSERT(data_size.nelms() == 10);
    double sum = 0.;
    double temp;
    NDSize offset(data_view.dataExtent().size(), 0);
    for (size_t i = 0; i &lt; data_size[1]; ++i){
        offset[1] = i;
        data_view.getData&lt;double&gt;(temp, offset);
        sum += temp;
    }
    CPPUNIT_ASSERT(sum == 45);

    indices[0] = 1;
    data_view = util::featureData(multi_tag, indices, 0)[0];
    sum = 0;
    for (size_t i = 0; i &lt; data_view.dataExtent()[1]; ++i){
        offset[1] = i;
        data_view.getData&lt;double&gt;(temp, offset);
        sum += temp;
    }
    CPPUNIT_ASSERT(sum == 1045);

    // untagged feature
    indices[0] = 0;
    data_view = util::featureData(multi_tag, indices, 2)[0];
    CPPUNIT_ASSERT(data_view.dataExtent().nelms() == 100);

    indices[0] = 1;
    data_view = util::featureData(multi_tag, indices, 2)[0];
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.nelms() == 100);
    sum = 0;
    for (size_t i = 0; i &lt; data_size[0]; ++i) {
        offset[0] = i;
        for (size_t j = 0; j &lt; data_size[1]; ++j) {
            offset[1] = j;
            data_view.getData&lt;double&gt;(temp, offset);
            sum += temp;
        }
    }
    CPPUNIT_ASSERT(sum == total);

    // tagged feature
    indices[0] = 0;
    data_view = util::featureData(multi_tag, indices, 1)[0];
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);

    data_view = util::featureData(multi_tag, indices, tagged_feature)[0];
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);

    indices[0] = 1;
    data_view = util::featureData(multi_tag, indices, 1)[0];
    data_size = data_view.dataExtent();
    CPPUNIT_ASSERT(data_size.size() == 4);

    indices[0] = 2;
    CPPUNIT_ASSERT_THROW(util::featureData(multi_tag, indices, 1), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(util::featureData(multi_tag, indices, 3), nix::OutOfBounds);

    // test multiple positions
    std::vector&lt;nix::DataView&gt; views = util::featureData(multi_tag, {0, 1}, 0);
    CPPUNIT_ASSERT(views.size() == 2);
    CPPUNIT_ASSERT(views[0].dataExtent() == NDSize({1, 10}));
    CPPUNIT_ASSERT(views[0].dataExtent() == NDSize({1, 10}));

    // test positions without specifying
    indices.clear();
    views = util::featureData(multi_tag, indices, 0);
    CPPUNIT_ASSERT(views.size() == multi_tag.positionCount());

    // clean up
    multi_tag.deleteFeature(index_feature.id());
    multi_tag.deleteFeature(tagged_feature.id());
    multi_tag.deleteFeature(untagged_feature.id());
    block.deleteDataArray(tagged_data.id());
    block.deleteDataArray(index_data.id());
}


void BaseTestDataAccess::testMultiTagUnitSupport() {
    std::vector&lt;std::string&gt; valid_units{"none","ms","ms"};
    std::vector&lt;std::string&gt; invalid_units{"mV", "Ohm", "muV"};
    std::vector&lt;ndsize_t&gt; position_indices(1);

    MultiTag testTag = block.createMultiTag("test", "testTag", multi_tag.positions());
    testTag.units(valid_units);
    testTag.addReference(data_array);
    
    position_indices[0] = 0;
    CPPUNIT_ASSERT_NO_THROW(util::retrieveData(testTag, position_indices, 0));
    
    testTag.units(nix::none);
    CPPUNIT_ASSERT_NO_THROW(util::retrieveData(testTag, position_indices, 0));
    
    testTag.units(invalid_units);
    CPPUNIT_ASSERT_THROW(util::taggedData(testTag, position_indices, 0), nix::IncompatibleDimensions);
}


void BaseTestDataAccess::testDataView() {
    NDSize zcount = {2, 5, 2, 5};
    NDSize zoffset = {0, 5, 2, 2};

    DataView io = DataView(data_array, zcount, zoffset);

    CPPUNIT_ASSERT_EQUAL(zcount, io.dataExtent());
    CPPUNIT_ASSERT_EQUAL(data_array.dataType(), io.dataType());

    typedef boost::multi_array&lt;double, 4&gt; array_type;
    array_type data(boost::extents[2][5][2][5]);
    io.getData(data);

    const array_type::size_type *ext = data.shape();
    for (size_t i = 0; i &lt; 4; i++) {
        CPPUNIT_ASSERT_EQUAL(static_cast&lt;array_type::size_type &gt;(zcount[i]), ext[i]);
    }

    array_type ref;
    data_array.getData(ref);

    for(size_t i = 0; i &lt; zcount[0]; ++i) {
        for(size_t j = 0; j &lt; zcount[1]; ++j) {
            for(size_t k = 0; k &lt; zcount[2]; ++k) {
                for (size_t l = 0; l &lt; zcount[3]; ++l) {
                    CPPUNIT_ASSERT_DOUBLES_EQUAL(ref[i + 0][j + 5][k + 2][l + 2],
                                                 data[i][j][k][l],
                                                 std::numeric_limits&lt;double&gt;::epsilon());
                    data[i][j][k][l] = 0.0;
                }
            }
        }
    }

    io.setData(data, {0, 0, 0, 0});
    data_array.getData(ref);

    for(size_t i = 0; i &lt; zcount[0]; ++i) {
        for(size_t j = 0; j &lt; zcount[1]; ++j) {
            for(size_t k = 0; k &lt; zcount[2]; ++k) {
                for (size_t l = 0; l &lt; zcount[3]; ++l) {
                    CPPUNIT_ASSERT_DOUBLES_EQUAL(ref[i + 0][j + 5][k + 2][l + 2],
                                                 0.0,
                                                 std::numeric_limits&lt;double&gt;::epsilon());
                }
            }
<a name="2"></a>        }
    }

<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    double val = 0.0;
    CPPUNIT_ASSERT_THROW(io.getData(val, {}, {0, 0, 3, 2}), OutOfBounds);

    array_type r2d2(boost::extents[3][3][3][3]);
    CPPUNIT_ASSERT_THROW(io.getData(r2d2, {3, 3, 3, 3}, {}), OutOfBounds);

    CPPUNIT_ASSERT_THROW(io.dataExtent(zcount), std::runtime_error);

    CPPUNIT_ASSERT_THROW(DataView(data_array, {0, 0, 0, 0, 0}, {1, 1, 1}), IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(DataView(data_array, {0, 0, 0}, {1, 1}), IncompatibleDimensions);</b></font>
}


void BaseTestDataAccess::testDataSlice() {
    nix::Block b = file.createBlock("slicing data", "nix.test");

    // 1D SampledDimension
    std::vector&lt;double&gt; time(1000);
    std::vector&lt;double&gt; voltage;
    double interval = 0.01;
    double pi = 3.1415;
    double freq = 1.5;
    std::iota(time.begin(), time.end(), 0.);
    std::transform(time.begin(), time.end(), time.begin(),
                   [interval](double t){ return t * interval; });
    std::transform(time.begin(), time.end(), std::back_inserter(voltage),
                   [pi, freq](double t) { return std::sin(t * freq * 2 * pi); });

    // create a DataArray
    nix::DataArray oned_array = b.createDataArray("sinewave", "nix.sampled", nix::DataType::Double, {voltage.size()});
    oned_array.setData(voltage);
    oned_array.label("voltage");
    oned_array.unit("mV");

    nix::SampledDimension dim = oned_array.appendSampledDimension(interval);
    dim.label("time");
    dim.unit("s");

    // 2d data: Set - Sample
    typedef boost::multi_array&lt;double, 2&gt; array_type_2d;
    typedef array_type_2d::index index;

    array_type_2d data(boost::extents[10][time.size()]);
    for(index i = 0; i &lt; 10; ++i) {
        for (size_t j = 0; j &lt; time.size(); ++j) {
            data[i][j] = std::sin(time[j] * freq * 2 * pi + (i*2*pi/10));
        }
    }

    nix::NDSize data_shape(2, 10);  // NDSize object with rank two  10 elements per dim, for now
    data_shape[1] = time.size();
    // create the DataArray and store the data.
    nix::DataArray twod_array = b.createDataArray("2d sinewaves", "nix.test", nix::DataType::Double, data_shape);
    twod_array.setData(data);
    twod_array.label("voltage");
    twod_array.unit("mV");
    twod_array.appendSetDimension();
    dim = twod_array.appendSampledDimension(interval);
    dim.label("time");
    dim.unit("s");

    // 2d data: Range - Sample
    std::vector&lt;double&gt; ticks(10);
    for(size_t i = 0; i &lt; 10; ++i) {
        ticks[i] = i * pi;
    }
    nix::DataArray twod_array2 = b.createDataArray("2d sinewaves 2", "nix.test", nix::DataType::Double, data_shape);
    twod_array2.setData(data);
    twod_array2.label("voltage");
    twod_array2.unit("mV");
    RangeDimension rangeDim = twod_array2.appendRangeDimension(ticks);
    rangeDim.label("time");
    rangeDim.unit("s");
    dim = twod_array2.appendSampledDimension(interval);
    dim.label("time");
    dim.unit("s");

    // do the tests!
    nix::DataArray no_array;
    CPPUNIT_ASSERT_THROW(util::dataSlice(no_array, {1, 2}, {2,3}), nix::UninitializedEntity);
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1, 2}, {2, 3}), std::invalid_argument); // 1d data but called with 2d segment 
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1}, {2}, {"ms", "mV"}), std::invalid_argument); // 1d positions, but two units
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1, 2, 3}, {1, 2}), std::invalid_argument); // different size of start and end
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {"mV"}), nix::IncompatibleDimensions); // sampledDimension represents time
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {"ks"}), nix::OutOfBounds); // well beyond data
    CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1.0}, {0.0}), std::invalid_argument); // start &gt; end

    CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}));
    CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {"s"}));
    CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {"ms"}));
    CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {0.001}, {"ks"}));
 
    // test with RangeMatch::Inclusive
    nix::DataView slice = util::dataSlice(oned_array, {0.0}, {1.0}, {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 101);

    slice = util::dataSlice(twod_array2, {3.14, 1.0}, {9.6, 2.0}, {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 3 &amp;&amp; slice.dataExtent()[1] == 101);

    slice = util::dataSlice(twod_array, {0., 0.0}, {9.0, 1.0}, {"none", "s"}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 10 &amp;&amp; slice.dataExtent()[1] == 101);

    // test with RangeMatch::Exclusive
    slice = util::dataSlice(oned_array, {0.0}, {1.0}, {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 100);

    slice = util::dataSlice(oned_array, {1.0}, {1.0}, {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 1);

<a name="6"></a>    slice = util::dataSlice(twod_array2, {3.14, 1.0}, {9.6, 2.0}, {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 3 &amp;&amp; slice.dataExtent()[1] == 100);

<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    slice = util::dataSlice(twod_array, {0., 0.0}, {9.0, 1.0}, {"none", "s"}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(slice.dataExtent()[0] == 9 &amp;&amp; slice.dataExtent()[1] == 100);

    b.deleteDataArray(oned_array);
    b.deleteDataArray(twod_array);
    file.deleteBlock(b);
}

void BaseTestDataAccess::testFlexibleTagging() {
    nix::Block b = file.createBlock("flexible tagging", "nix.test");

    // create dummy data
    std::vector&lt;double&gt; data(1000, 0.0);</b></font>
    for (size_t i = 0; i &lt;data.size(); ++i) {
        data[i] = 3.14 * 1;
    }

    typedef boost::multi_array&lt;int, 2&gt; array_type_2d;
    typedef array_type_2d::index index;
    nix::NDSize data_shape_2d(2, 0);
    data_shape_2d[0] = 100;
    data_shape_2d[1] = 10;
    array_type_2d data2d(boost::extents[data_shape_2d[0]][data_shape_2d[1]]);
    for(index i = 0; i &lt; 100; ++i) {
        for(index j = 0; j &lt; 10; ++j) {
            data2d[i][j] = std::rand() % 100 + 1;
        }
    }

    typedef boost::multi_array&lt;int, 3&gt; array_type_3d;
    typedef array_type_3d::index index3;
    nix::NDSize data_shape_3d(3, 0);
    data_shape_3d[0] = 100;
    data_shape_3d[1] = 10;
    data_shape_3d[2] = 5;

    array_type_3d data3d(boost::extents[100][10][5]);
    for(index3 i = 0; i &lt; 100; ++i) {
        for(index3 j = 0; j &lt; 10; ++j) {
            for(index3 k = 0; k &lt; 5; ++k) {
                data3d[i][j][k] = std::rand() % 100 + 1;
            }
        }
    }
    // Create the DataArrays and store the data.
    nix::DataArray array = b.createDataArray("1d random data", "nix.sampled", data);
    nix::SampledDimension dim = array.appendSampledDimension(0.1);
    dim.label("time");
    dim.unit("s");

    nix::DataArray array2d = b.createDataArray("2d random data", "nix.sampled.2d", data2d);
    dim = array2d.appendSampledDimension(1.);
    dim.label("time");
    dim.unit("s");
    array2d.appendSetDimension();

    nix::DataArray array3d = b.createDataArray("3d random data", "nix.sampled.3d", data3d);
    dim = array3d.appendSampledDimension(1.);
    dim.label("time");
    dim.unit("s");
    array3d.appendSetDimension();
    array3d.appendSetDimension();

    // Tag, tagging 2 dimensions
    nix::Tag tag = b.createTag("1stTag", "nix.segment", {25, 0});
    tag.extent({50, 5});
    tag.units({"s"});
    tag.addReference(array);
    tag.addReference(array2d);
    tag.addReference(array3d);

    nix::DataView view = tag.taggedData("1d random data");
    nix::NDSize exp_shape({500});
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = tag.taggedData("2d random data");
    exp_shape = {50, 5};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = tag.taggedData("3d random data");
    exp_shape = {50, 5, 4};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    // Tag, tagging 3 dims without extents, i.e. a point
    nix::Tag ndTag = b.createTag("2ndTag", "nix.points", {25, 0, 0});
    ndTag.addReference(array);
    ndTag.addReference(array2d);
    ndTag.addReference(array3d);

    view = ndTag.taggedData("1d random data");
    exp_shape = {1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = ndTag.taggedData("2d random data");
    exp_shape = {1, 1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = ndTag.taggedData("3d random data");
    exp_shape = {1, 1, 1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    //Tag, tagging 3d dims but with explicit zero extents
    nix::Tag rdTag = b.createTag("3rdTag11", "nix.points", {25, 0, 0});
    rdTag.extent({0.0, 0.0, 0.0});
    rdTag.addReference(array);
    rdTag.addReference(array2d);
    rdTag.addReference(array3d);

    view = rdTag.taggedData("1d random data");
    exp_shape = {1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = rdTag.taggedData("2d random data");
    exp_shape = {1, 1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = rdTag.taggedData("3d random data");
    exp_shape = {1, 1, 1};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    nix::Tag failTag = b.createTag("failing tag", "nix.points", {25, 0, 0});
    failTag.extent({0.0, 0.0}); // this is invalid!
    failTag.addReference(array);
    failTag.addReference(array2d);
    failTag.addReference(array3d);

    CPPUNIT_ASSERT_THROW(failTag.taggedData("3d random data"), nix::IncompatibleDimensions);

    // MultiTag
    typedef boost::multi_array&lt;double, 2&gt; pos_type;
    typedef pos_type::index index4;

    pos_type pos_data(boost::extents[5][2]);
    pos_type ext_data(boost::extents[5][2]);
    for(index4 i = 0; i &lt; 5; ++i) {
        pos_data[i][0] = i * 15.0 + 5.00;
        ext_data[i][0] = 10.0;
        pos_data[i][1] = 1.0;
        ext_data[i][1] = 2.0;
    }
    nix::DataArray positions = b.createDataArray("mtag positions", "nix.positions.2d", pos_data);
    positions.appendSetDimension();
    positions.appendSetDimension();

    nix::DataArray extents = b.createDataArray("mtag_extents", "nix.extents.2d", ext_data);
    extents.appendSetDimension();
    extents.appendSetDimension();

    nix::MultiTag mtag = b.createMultiTag("mtag", "segments", positions);
    mtag.extents(extents);

    mtag.addReference(array);
    mtag.addReference(array2d);
    mtag.addReference(array3d);

    view = mtag.taggedData(0, "1d random data");
    exp_shape = {100};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = mtag.taggedData(0, "2d random data");
    exp_shape = {10, 2};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    view = mtag.taggedData(0, "3d random data");
    exp_shape = {10, 2, 4};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
<a name="1"></a>

    // Test DataFrameDim
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    std::vector&lt;nix::Column&gt; cols = {{"current", "nA", nix::DataType::Double},
                                     {"note", "", nix::DataType::String}};
    nix::DataFrame df = b.createDataFrame("conditions", "test", cols);
    std::vector&lt;nix::Variant&gt; vals(2);
    df.rows(10);
    for (int i = 0; i &lt; 10; ++i) {
        vals[0].set(i * 2.5);
        vals[1].set("test");
        df.writeRow(i, vals);
    }
    array3d.deleteDimensions();
    dim = array3d.appendSampledDimension(1.);
    dim.label("time");
    dim.unit("s");
    array3d.appendDataFrameDimension(df);
    array3d.appendSetDimension();

    nix::Tag dfTag = b.createTag("dftest", "dftest", {25, 0});</b></font>
    dfTag.extent({50, 5});
    dfTag.addReference(array3d);

    view = dfTag.taggedData("3d random data");
    exp_shape = {50, 5, 4};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    dfTag.position({25});
    dfTag.extent({50});

    view = dfTag.taggedData("3d random data");
    exp_shape = {50, 9, 4};
    CPPUNIT_ASSERT(view.dataExtent() == exp_shape);

    file.deleteBlock(b);
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestDimension.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
// Copyright (c) 2013, German Neuroinformatics Node (G-Node)
//
// All rights reserved.
//
// Redistribution and use in Section and binary forms, with or without
// modification, are permitted under the terms of the BSD License. See
// LICENSE file in the root of the Project.

#include &lt;limits&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;stdexcept&gt;

#include &lt;nix/util/util.hpp&gt;
#include &lt;nix/valid/validate.hpp&gt;

#include "BaseTestDimension.hpp"

#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &lt;cppunit/CompilerOutputter.h&gt;
#include &lt;cppunit/TestResult.h&gt;
#include &lt;cppunit/TestResultCollector.h&gt;
#include &lt;cppunit/TestRunner.h&gt;
#include &lt;cppunit/BriefTestProgressListener.h&gt;
#include &lt;boost/math/constants/constants.hpp&gt;

using namespace nix;
using namespace valid;


void BaseTestDimension::testValidate() {
    Dimension d = data_array.appendSetDimension();
    valid::Result result = validate(d);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestDimension::testSetValidate() {
    SetDimension d = data_array.appendSetDimension();
    valid::Result result = validate(d);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestDimension::testRangeValidate() {
    std::vector&lt;double&gt; ticks;
    for (size_t i = 0; i &lt; 5; i++) {
        ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
    }
    RangeDimension d = data_array.appendRangeDimension(ticks);
    valid::Result result = validate(d);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestDimension::testSampleValidate() {
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();
    SampledDimension d = data_array.appendSampledDimension(samplingInterval);
    valid::Result result = validate(d);
    CPPUNIT_ASSERT(result.getErrors().size() == 0);
    CPPUNIT_ASSERT(result.getWarnings().size() == 0);
}


void BaseTestDimension::testIndex() {
    Dimension sd = data_array.appendSetDimension();
    CPPUNIT_ASSERT(data_array.dimensionCount() == 1 &amp;&amp; sd.index() == 1);
    data_array.deleteDimensions();
    CPPUNIT_ASSERT(data_array.dimensionCount() == 0);
}


void BaseTestDimension::testSampledDimLabel() {
    std::string label = "aLabel";
    std::string other_label = "anotherLabel";
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    sd.label(label);
    CPPUNIT_ASSERT(*(sd.label()) == label);
    sd.label(other_label);
    CPPUNIT_ASSERT(*(sd.label()) == other_label);
    CPPUNIT_ASSERT_NO_THROW(sd.label(none));
    CPPUNIT_ASSERT(sd.label() == none);

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimUnit() {
    std::string invalidUnit = "invalidunit";
    std::string validUnit = "mV^2";
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    CPPUNIT_ASSERT_THROW(sd.unit(invalidUnit), InvalidUnit);
    CPPUNIT_ASSERT_NO_THROW(sd.unit(validUnit));
    CPPUNIT_ASSERT(*(sd.unit()) == validUnit);
    CPPUNIT_ASSERT_NO_THROW(sd.unit(boost::none));
    CPPUNIT_ASSERT(sd.unit() == boost::none);
    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimSamplingInterval() {
    double impossible_sampling_interval = -1.0;
    double invalid_sampling_interval = 0.0;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    CPPUNIT_ASSERT(sd.samplingInterval() == boost::math::constants::pi&lt;double&gt;());
    CPPUNIT_ASSERT_THROW(sd.samplingInterval(impossible_sampling_interval), std::runtime_error);
    CPPUNIT_ASSERT_THROW(sd.samplingInterval(invalid_sampling_interval), std::runtime_error);
    CPPUNIT_ASSERT_NO_THROW(sd.samplingInterval(samplingInterval));
    CPPUNIT_ASSERT(sd.samplingInterval() == samplingInterval);

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimOffset() {
    double offset = 1.0;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    CPPUNIT_ASSERT_NO_THROW(sd.offset(offset));
    CPPUNIT_ASSERT(*(sd.offset()) == offset);
    CPPUNIT_ASSERT_NO_THROW(sd.offset(boost::none));
    CPPUNIT_ASSERT(sd.offset() == boost::none);

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimIndexOfOld() {
    double offset = 1.0;
    double samplingInterval = 1.0;

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
    SampledDimension sd;
    sd = d;
    // no offset, sampling interval = 1
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.5));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.0));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.5));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(10000000));

    CPPUNIT_ASSERT(sd.indexOf(-0.5) == 0);
    CPPUNIT_ASSERT(sd.indexOf(1.0) == 1);
    CPPUNIT_ASSERT(sd.indexOf(2.4) == 3);  // GreaterOrEqual
    CPPUNIT_ASSERT(sd.indexOf(4.28) == 5);
    CPPUNIT_ASSERT(sd.indexOf(6.99) == 7);
    CPPUNIT_ASSERT(sd.indexOf(7.0) == 7);

    // offset = 1.0 , sampling interval = 1.0
    sd.offset(offset);
    CPPUNIT_ASSERT(*(sd.offset()) == offset);
    
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-3.14));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.5));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(1.0));
    
    CPPUNIT_ASSERT(sd.indexOf(-1.0) == 0);
    CPPUNIT_ASSERT(sd.indexOf(0.0) == 0);
    CPPUNIT_ASSERT(sd.indexOf(2.0) == 1);
    CPPUNIT_ASSERT(sd.indexOf(6.28) == 6);
    CPPUNIT_ASSERT(sd.indexOf(3.75) == 3);

    // test ranges, offset = 1.0, sampling interval = 1.0
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.25, 1.01));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.0, 1.01));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(1.0, 1.01));
    CPPUNIT_ASSERT_THROW(sd.indexOf(1.01, 0.0), nix::OutOfBounds);

    CPPUNIT_ASSERT_THROW(sd.indexOf(-1.0, -.05), nix::OutOfBounds);  // because end pos is invalid
    std::pair&lt;ndsize_t, ndsize_t&gt; range = sd.indexOf(-1.0, 5.0);
    CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
    range = sd.indexOf(1.0, 5.0);
    CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
    CPPUNIT_ASSERT_THROW(sd.indexOf(5.0, 1.0), nix::OutOfBounds);
    range = sd.indexOf(1.5, 3.2);
<a name="2"></a>    CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 2); // less or equal for end of range
    range = sd.indexOf(1.5, 3.7);
    CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 2); // less or equal for end of range
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    range = sd.indexOf(1.5, 4.0);
    CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 3); // less or equal for end of range

    // test vectors of ranges, offset = 1, sampling interval = 1
    CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, 20.0, 40.0}, {10.9}), std::runtime_error);        
    CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, 20.0, 40.0}, {10.9, 12., 1.}), nix::OutOfBounds);
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.}));
    CPPUNIT_ASSERT(sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.}).size() == 3);</b></font>

    std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges = sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.});
    CPPUNIT_ASSERT(ranges.size() == 3);
    CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 9);
    CPPUNIT_ASSERT(sd.positionAt(ranges[0].first) == 1.0 &amp;&amp; sd.positionAt(ranges[0].second) == 10.); 
    CPPUNIT_ASSERT(ranges[1].first == 11 &amp;&amp; ranges[1].second == 19);
    CPPUNIT_ASSERT(sd.positionAt(ranges[1].first) == 12 &amp;&amp; sd.positionAt(ranges[1].second) == 20); 
    CPPUNIT_ASSERT(ranges[2].first == 0 &amp;&amp; ranges[2].second == 39);
    CPPUNIT_ASSERT(sd.positionAt(ranges[2].first) == 1. &amp;&amp; sd.positionAt(ranges[2].second) == 40); 

    // offset = -1.0 , sampling interval = 1.0
    sd.offset(-1.0);
    CPPUNIT_ASSERT(*(sd.offset()) == -1.0);
    
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-3.14));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-1.5));
    CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.5));
    
    CPPUNIT_ASSERT(sd.indexOf(-3.14) == 0);
    CPPUNIT_ASSERT(sd.indexOf(-0.5) == 1);
    CPPUNIT_ASSERT(sd.indexOf(-1.0) == 0);
    CPPUNIT_ASSERT(sd.indexOf(0.5) == 2);
    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimIndexOf() {
    double samplingInterval = 1.;

    Dimension d = data_array.appendSampledDimension(samplingInterval);
<a name="0"></a>    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    sd = d;
    // offset = 0, sampling interval = 1
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater));
     
    CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Less));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater));

    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Less));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Greater));
   
    // offset = 1.0, sampling interval = 1
    sd.offset(1.0);
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater));
     
    CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Less));
    CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater));

    CPPUNIT_ASSERT(!sd.indexOf(1.0, PositionMatch::Less));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Greater));

    sd.offset(-1.0);
    // offset = -1.0, sampling interval = 1
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual) &amp;&amp; *sd.indexOf(-3.14, PositionMatch::GreaterOrEqual) == 0) ;
    CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater) &amp;&amp; *sd.indexOf(-3.14, PositionMatch::Greater) == 0);
     
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Less) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Less) == 0);
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::LessOrEqual) &amp;&amp; *sd.indexOf(0.0, PositionMatch::LessOrEqual) == 1);
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Equal) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Equal) == 1);
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual) &amp;&amp; *sd.indexOf(0.0, PositionMatch::GreaterOrEqual) == 1);
    CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Greater) == 2);</b></font>

    // test ranges offset = -1, sampling interval = 1
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 1 &amp;&amp; (*range).second == 1);
    range = sd.indexOf(0.0, 0.0, RangeMatch::Exclusive);    
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(-1.5, 2.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(-1.5, 2.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = sd.indexOf(2., -2.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range); // &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(2., -2.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range); // &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = sd.indexOf(2.0, 2.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(2., 2.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);

    // test vector of ranges, offset = -1, sampling interval = 1
    CPPUNIT_ASSERT_THROW(sd.indexOf({1.0, 20.0, 40.0}, {10.9, 12.}, RangeMatch::Exclusive), std::runtime_error);
    
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = sd.indexOf({1.0, 12.0, 1.0, 5.0}, {10.9, 20.0, 40.0, 5.0}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 2 &amp;&amp; (*ranges[0]).second == 11 &amp;&amp; 
                   sd.positionAt((*ranges[0]).first) &gt;= 1.0 &amp;&amp; sd.positionAt((*ranges[0]).second) &lt;= 10.9);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 13 &amp;&amp; (*ranges[1]).second == 21 &amp;&amp; 
                   sd.positionAt((*ranges[1]).first) == 12 &amp;&amp; sd.positionAt((*ranges[1]).second) == 20);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 2 &amp;&amp; (*ranges[2]).second == 41 &amp;&amp; 
                   sd.positionAt((*ranges[2]).first) == 1.0 &amp;&amp; sd.positionAt((*ranges[2]).second) == 40);
    CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 6 &amp;&amp; (*ranges[3]).second == 6 &amp;&amp; 
                   sd.positionAt((*ranges[3]).first) == 5 &amp;&amp; sd.positionAt((*ranges[3]).second) == 5);

    ranges = sd.indexOf({1.0, 12.0, 1.0, 5.0}, {10.9, 20.0, 40.0, 5.0}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 2 &amp;&amp; (*ranges[0]).second == 11 &amp;&amp; 
                   sd.positionAt((*ranges[0]).first) &gt;= 1.0 &amp;&amp; sd.positionAt((*ranges[0]).second) &lt;= 10.9);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 13 &amp;&amp; (*ranges[1]).second == 20 &amp;&amp; 
                   sd.positionAt((*ranges[1]).first) == 12 &amp;&amp; sd.positionAt((*ranges[1]).second) == 19);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 2 &amp;&amp; (*ranges[2]).second == 40 &amp;&amp; 
                   sd.positionAt((*ranges[2]).first) == 1.0 &amp;&amp; sd.positionAt((*ranges[2]).second) == 39);
    CPPUNIT_ASSERT(!ranges[3]);
    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimPositionAt() {
    double offset = 1.0;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    sd.offset(offset);
    CPPUNIT_ASSERT(sd.positionAt(0) == offset);
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        200 * samplingInterval + offset,
        sd.positionAt(200),
        std::numeric_limits&lt;double&gt;::round_error());

    CPPUNIT_ASSERT(sd[0] == offset);
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        200 * samplingInterval + offset,
        sd[200],
        std::numeric_limits&lt;double&gt;::round_error());

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimAxis() {
    double offset = 1.0;
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();

    Dimension d = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);

    SampledDimension sd;
    sd = d;
    sd.offset(offset);

    std::vector&lt;double&gt; axis = sd.axis(100);
    CPPUNIT_ASSERT(axis.size() == 100);
    CPPUNIT_ASSERT(axis[0] == offset);
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        99 * samplingInterval + offset,
        axis.back(),
        std::numeric_limits&lt;double&gt;::round_error());

    axis = sd.axis(100, 10);
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        10 * samplingInterval + offset,
        axis[0],
        std::numeric_limits&lt;double&gt;::round_error());
    CPPUNIT_ASSERT_DOUBLES_EQUAL(
        109 * samplingInterval + offset,
        axis.back(),
        std::numeric_limits&lt;double&gt;::round_error());

    data_array.deleteDimensions();
}


void BaseTestDimension::testSampledDimOperators() {
    double samplingInterval = boost::math::constants::pi&lt;double&gt;();
    Dimension d = data_array.appendSampledDimension(samplingInterval);
    Dimension d2 = data_array.appendSampledDimension(samplingInterval);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
    CPPUNIT_ASSERT(d2.dimensionType() == DimensionType::Sample);
    CPPUNIT_ASSERT_THROW(d.asRangeDimension(), nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(d.asSetDimension(), nix::IncompatibleDimensions);
    SampledDimension sd1, sd2, sd3;
    sd1 = d;
    sd2 = d2;
    sd3 = data_array.getDimension(d.index());
    CPPUNIT_ASSERT(sd1.index() == d.index() &amp;&amp; sd2.index() == d2.index());
    CPPUNIT_ASSERT(sd1 != sd2);
    CPPUNIT_ASSERT(sd1 != sd3);
    data_array.deleteDimensions();
    Dimension dim = data_array.appendSetDimension();
    CPPUNIT_ASSERT_THROW(dim.asSampledDimension(), IncompatibleDimensions);
    SampledDimension sampled = data_array.appendSampledDimension(samplingInterval);
    RangeDimension range = data_array.appendRangeDimension(std::vector&lt;double&gt;({1, 2}));
    SetDimension set = data_array.appendSetDimension();
    std::stringstream s_stream, r_stream, set_stream;
    s_stream &lt;&lt; sampled.dimensionType();
    r_stream &lt;&lt; range.dimensionType();
    set_stream &lt;&lt; set.dimensionType();
    CPPUNIT_ASSERT(s_stream.str() == "Sample");
    CPPUNIT_ASSERT(set_stream.str() == "Set");
    CPPUNIT_ASSERT(r_stream.str() == "Range");
    CPPUNIT_ASSERT(d != none);
    CPPUNIT_ASSERT(sampled != none);
    CPPUNIT_ASSERT(range != none);
    CPPUNIT_ASSERT(set != none);

    SampledDimension sd4;
    CPPUNIT_ASSERT_THROW(sd4 = range, nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_NO_THROW(sd4 = sampled);
    RangeDimension rd;
    CPPUNIT_ASSERT_THROW(rd = sampled, nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_NO_THROW(rd = range);
    SetDimension st;
    CPPUNIT_ASSERT_THROW(st = sampled, nix::IncompatibleDimensions);
    CPPUNIT_ASSERT_NO_THROW(st = set);

    d = none; sampled = none; range = none; set = none;
    CPPUNIT_ASSERT(d == none);
    CPPUNIT_ASSERT(sampled == none);
    CPPUNIT_ASSERT(range == none);
    CPPUNIT_ASSERT(set == none);
}


void BaseTestDimension::testSetDimLabels() {
    std::vector&lt;std::string&gt; labels = {"label_a", "label_b","label_c","label_d","label_e"};
    std::vector&lt;std::string&gt; new_labels = {"new label_a", "new label_b","new label_c"};

    Dimension d = data_array.appendSetDimension();
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Set);

    SetDimension sd;
    sd = d;
    CPPUNIT_ASSERT(sd);
    sd.labels(labels);
    std::vector&lt;std::string&gt; retrieved_labels = sd.labels();
    CPPUNIT_ASSERT(retrieved_labels.size() == labels.size());
    for (size_t i = 0; i &lt; labels.size(); i++){
        CPPUNIT_ASSERT(labels[i] == retrieved_labels[i]);
    }

    sd.labels(new_labels);
    retrieved_labels = sd.labels();
    CPPUNIT_ASSERT(retrieved_labels.size() == new_labels.size());
    for (size_t i = 0; i &lt; new_labels.size(); i++){
        CPPUNIT_ASSERT(new_labels[i] == retrieved_labels[i]);
    }

    sd.labels(boost::none);
    retrieved_labels = sd.labels();
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), retrieved_labels.size());

    data_array.deleteDimensions();
}

void BaseTestDimension::testSetDimIndexOf() {
    std::vector&lt;std::string&gt; labels = {"label_a", "label_b","label_c","label_d","label_e"};

    Dimension d = data_array.appendSetDimension();
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Set);
    SetDimension sd;
    sd = d;
    sd.labels(labels);

    boost::optional&lt;ndsize_t&gt; index;
    index = sd.indexOf(-1.0, PositionMatch::Less);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(-1.0, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(-1.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(-1.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
    index = sd.indexOf(-1.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);

    index = sd.indexOf(0.0, PositionMatch::Less);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(0.0, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
    index = sd.indexOf(0.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
    index = sd.indexOf(0.0000001, PositionMatch::Equal);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(0.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
    index = sd.indexOf(0.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 1);

    index = sd.indexOf(4.0, PositionMatch::Less);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 3);
    index = sd.indexOf(4.0, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(4.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(4.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(4.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(!index);

    index = sd.indexOf(5.0, PositionMatch::Less);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(5.0, PositionMatch::LessOrEqual);
<a name="4"></a>    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(5.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(!index);
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    index = sd.indexOf(5.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(5.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(!index);

    sd.labels(boost::none);
    index = sd.indexOf(5.0, PositionMatch::Less);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
    index = sd.indexOf(5.0, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.0, PositionMatch::Equal);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.0, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.0, PositionMatch::Greater);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 6);

    index = sd.indexOf(5.5, PositionMatch::Less);</b></font>
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.5, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
    index = sd.indexOf(5.5, PositionMatch::Equal);
    CPPUNIT_ASSERT(!index);
    index = sd.indexOf(5.5, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 6);
    index = sd.indexOf(5.5, PositionMatch::Greater);
    CPPUNIT_ASSERT(index &amp;&amp; *index == 6);

    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = sd.indexOf(0.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(0.0, 3.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(0.0, 3.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = sd.indexOf(3.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(3.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);

    sd.labels(labels);
    range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = sd.indexOf(1.0, 1.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(0.0, 3.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = sd.indexOf(0.0, 3.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = sd.indexOf(3.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(3.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = sd.indexOf(0.0, 7.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 4);
    range = sd.indexOf(3.0, 7.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);

    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges;
    CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, -1.0, 1.0}, {1.0, 2.0}, RangeMatch::Inclusive), std::runtime_error);
    ranges = sd.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 1);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 4);
<a name="6"></a>    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 4);
    CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 1 &amp;&amp; (*ranges[3]).second == 1);

<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    ranges = sd.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 0);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 3);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 4);
    CPPUNIT_ASSERT(!ranges[3]);
}

void BaseTestDimension::testRangeDimLabel() {
    std::string label = "aLabel";
    std::string other_label = "anotherLabel";</b></font>
    std::vector&lt;double&gt; ticks;
    for (size_t i = 0; i &lt; 5; i++) {
        ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
    }

    Dimension d = data_array.appendRangeDimension(ticks);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    rd.label(label);
    CPPUNIT_ASSERT(*(rd.label()) == label);
    rd.label(other_label);
    CPPUNIT_ASSERT(*(rd.label()) == other_label);
    rd.label(none);
    CPPUNIT_ASSERT(rd.label() == none);

    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimUnit() {
    std::string invalidUnit = "invalidunit";
    std::string validUnit = "ms";

    std::vector&lt;double&gt; ticks;
    for (size_t i = 0; i &lt; 5; i++) {
        ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
    }
    Dimension d = data_array.appendRangeDimension(ticks);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    CPPUNIT_ASSERT_THROW(rd.unit(invalidUnit), InvalidUnit);
    CPPUNIT_ASSERT_NO_THROW(rd.unit(validUnit));
    CPPUNIT_ASSERT(*(rd.unit()) == validUnit);
    CPPUNIT_ASSERT_NO_THROW(rd.unit(none));
    CPPUNIT_ASSERT(rd.unit() == none);

    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeTicks() {
    std::vector&lt;double&gt; ticks = {1.0, 2.0, 3.4, 42.0};
    std::vector&lt;double&gt; new_ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    std::vector&lt;double&gt; unordered_ticks = {-20.0, -100.0, 10.0, -10.0, 0.0};
    std::vector&lt;double&gt; double_ticks = {-20.0, -10.0, 10.0, -10.0, -20.0};

    Dimension d = data_array.appendRangeDimension(ticks);
    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    CPPUNIT_ASSERT(rd.ticks().size() == ticks.size());
    std::vector&lt;double&gt; retrieved_ticks = rd.ticks();
    CPPUNIT_ASSERT(retrieved_ticks.size() == ticks.size());
    for (size_t i = 0; i &lt; ticks.size(); i++) {
        CPPUNIT_ASSERT(ticks[i] == retrieved_ticks[i]);
    }
    CPPUNIT_ASSERT_THROW(rd.ticks(unordered_ticks), UnsortedTicks);
    CPPUNIT_ASSERT_THROW(rd.ticks(double_ticks), UnsortedTicks);
    rd.ticks(new_ticks);
    retrieved_ticks = rd.ticks();
    CPPUNIT_ASSERT(retrieved_ticks.size() == new_ticks.size());
    for (size_t i = 0; i &lt; new_ticks.size(); i++) {
        CPPUNIT_ASSERT(new_ticks[i] == retrieved_ticks[i]);
    }

    ticks.resize(100);
    for (size_t i = 0; i &lt; 100; ++i) {
        ticks[i] = i * 3.14;
    }
    rd.ticks(ticks);
    CPPUNIT_ASSERT(rd.ticks(0, 10).size() == 10);
    CPPUNIT_ASSERT(rd.ticks(1, 99).size() == 99);
    CPPUNIT_ASSERT(rd.ticks(10, 1)[0] == 10 * 3.14);
    CPPUNIT_ASSERT(rd.ticks(20, 1)[0] == 20 * 3.14);

    CPPUNIT_ASSERT_THROW(rd.ticks(0, ticks.size() + 10), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.ticks(20, ticks.size() - 10), nix::OutOfBounds);
    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimIndexOfOld() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    CPPUNIT_ASSERT(rd.indexOf(-100.) == 0);
    CPPUNIT_ASSERT(rd.indexOf(-50.) == 0);
    CPPUNIT_ASSERT(rd.indexOf(-70.) == 0);
    CPPUNIT_ASSERT(rd.indexOf(-10.0) == 1);
    CPPUNIT_ASSERT(rd.indexOf(-5.0) == 1);
    CPPUNIT_ASSERT(rd.indexOf(5.0) == 2);

    CPPUNIT_ASSERT_NO_THROW(rd.indexOf(257.28));
    CPPUNIT_ASSERT_THROW(rd.indexOf(257.28, false), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.indexOf(-257.28), nix::OutOfBounds);
    CPPUNIT_ASSERT_NO_THROW(rd.indexOf(-257.28, false));

    CPPUNIT_ASSERT_THROW(rd.indexOf(110., 120.), nix::OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.indexOf(-120., -110.), nix::OutOfBounds);
    std::pair&lt;ndsize_t, ndsize_t&gt; range = rd.indexOf(-100., 100.);
    CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
    range = rd.indexOf(-200., 200.);
    CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);

    CPPUNIT_ASSERT_THROW(rd.indexOf({-100.0, -90, 0.0}, {10.}), std::runtime_error);
    CPPUNIT_ASSERT_NO_THROW(rd.indexOf({-100.0, 20.0, 40.0}, {-45, 120., 100.}));
    CPPUNIT_ASSERT(rd.indexOf({-100.0, 20.0, 40.0}, {-45, 120., 100.}, false).size() == 3);
    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimIndexOf() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

<a name="3"></a>    RangeDimension rd;
    rd = d;

<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    CPPUNIT_ASSERT(*rd.indexOf(-110., PositionMatch::GreaterOrEqual) == 0);
    CPPUNIT_ASSERT(*rd.indexOf(-110., PositionMatch::GreaterOrEqual) == 0);
    CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::LessOrEqual));
    CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::Less));
    CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::Equal));

    CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::GreaterOrEqual) == 0);
    CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::Greater) == 1);
    CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::LessOrEqual) == 0);
    CPPUNIT_ASSERT(!rd.indexOf(-100., PositionMatch::Less));
    CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::Equal) == 0);

    CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::GreaterOrEqual) == 1);
    CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::Greater) == 1);
    CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::LessOrEqual) == 0);
    CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::Less) == 0);
    CPPUNIT_ASSERT(!rd.indexOf(-50., PositionMatch::Equal));

    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::GreaterOrEqual) == 3);
    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::Greater) == 3);
    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::LessOrEqual) == 2);
<a name="5"></a>    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::Less) == 2);</b></font>
    CPPUNIT_ASSERT(!rd.indexOf(7., PositionMatch::Equal));

<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::GreaterOrEqual) == 3);
    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Greater) == 4);
    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::LessOrEqual) == 3);
    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Less) == 2);
    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Equal) == 3);

    CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::GreaterOrEqual));
    CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::Greater));
    CPPUNIT_ASSERT(*rd.indexOf(110., PositionMatch::LessOrEqual) == 4);
    CPPUNIT_ASSERT(*rd.indexOf(110., PositionMatch::Less) == 4);
    CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::Equal));

    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range;
    range = rd.indexOf(40., 100., {}, RangeMatch::Inclusive);</b></font>
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(40., 100., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = rd.indexOf(-100., -45., {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = rd.indexOf(-100., -45., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = rd.indexOf(10., 120., {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(10., 120., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(100., 120., {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(100., 120., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
    range = rd.indexOf(110., 150., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = rd.indexOf(100., -100., {}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = rd.indexOf(100., -100., {}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);

    range = rd.indexOf(100., -100., rd.ticks(), RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);

    std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges;
    ranges = rd.indexOf({40., -100.}, {100., 100.}, true, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(ranges.size() == 2);
    CPPUNIT_ASSERT(ranges[0].first == 4 &amp;&amp; ranges[0].second == 4);
    CPPUNIT_ASSERT(ranges[1].first == 0 &amp;&amp; ranges[1].second == 4);
    
    CPPUNIT_ASSERT_THROW(rd.indexOf({40., -100., -100.}, {100., 100., 101.}, true, RangeMatch::Exclusive), nix::OutOfBounds);
    
    ranges = rd.indexOf({40., -100., -100.}, {100., 100., 101.}, false, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(ranges.size() == 2);
    CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 3);
    CPPUNIT_ASSERT(ranges[1].first == 0 &amp;&amp; ranges[1].second == 4);
    
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; optranges;
    optranges = rd.indexOf({40., -100.}, {100., 100.}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(optranges.size() == 2);
    CPPUNIT_ASSERT(optranges[0] &amp;&amp; (*optranges[0]).first == 4 &amp;&amp; (*optranges[0]).second == 4);
    CPPUNIT_ASSERT(optranges[1] &amp;&amp; (*optranges[1]).first == 0 &amp;&amp; (*optranges[1]).second == 4);

    optranges = rd.indexOf({40., -100., -100.}, {100., 100., 101.}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(optranges.size() == 3);
    CPPUNIT_ASSERT(!optranges[0]);
    CPPUNIT_ASSERT(optranges[1] &amp;&amp; (*optranges[1]).first == 0 &amp;&amp; (*optranges[1]).second == 3);
    CPPUNIT_ASSERT(optranges[2] &amp;&amp; (*optranges[2]).first == 0 &amp;&amp; (*optranges[2]).second == 4);
    
    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimTickAt() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;
    CPPUNIT_ASSERT(rd.tickAt(0) == -100.);
    CPPUNIT_ASSERT(rd.tickAt(4) == 100.);
    CPPUNIT_ASSERT_THROW(rd.tickAt(10), OutOfBounds);

    CPPUNIT_ASSERT(rd[0] == -100.);
    CPPUNIT_ASSERT(rd[4] == 100.);
    CPPUNIT_ASSERT_THROW(rd[10], OutOfBounds);

    data_array.deleteDimensions();
}


void BaseTestDimension::testRangeDimAxis() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);

    RangeDimension rd;
    rd = d;

    std::vector&lt;double&gt; axis = rd.axis(2);
    CPPUNIT_ASSERT(axis.size() == 2);
    CPPUNIT_ASSERT(axis[0] == -100.0);
    CPPUNIT_ASSERT(axis[1] == -10.0);

    axis = rd.axis(2, 2);
    CPPUNIT_ASSERT(axis.size() == 2);
    CPPUNIT_ASSERT(axis[0] == 0.0);
    CPPUNIT_ASSERT(axis[1] == 10.0);

    CPPUNIT_ASSERT_THROW(rd.axis(10), OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.axis(2, 10), OutOfBounds);
    CPPUNIT_ASSERT_THROW(rd.axis(std::numeric_limits&lt;ndsize_t&gt;::max(), static_cast&lt;size_t&gt;(1)), OutOfBounds);
}


void BaseTestDimension::testRangeDimPositionInRange() {
<a name="7"></a>    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension d = data_array.appendRangeDimension(ticks);

<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
    RangeDimension rd = d.asRangeDimension();

    CPPUNIT_ASSERT(rd.positionInRange(-99.0) == nix::PositionInRange::InRange);
    CPPUNIT_ASSERT(rd.positionInRange(99.0) == nix::PositionInRange::InRange);
    CPPUNIT_ASSERT(rd.positionInRange(100.1) == nix::PositionInRange::Greater);
    CPPUNIT_ASSERT(rd.positionInRange(-100.1) == nix::PositionInRange::Less);

    rd.ticks({});</b></font>
    CPPUNIT_ASSERT(rd.positionInRange(0.1) == nix::PositionInRange::NoRange);
}
<a name="1"></a>

void BaseTestDimension::testDataFrameDimIndexOf() {
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    std::vector&lt;nix::Column&gt; cols = {{"current", "nA", nix::DataType::Double},
                                     {"note", "", nix::DataType::String}};
    nix::DataFrame df = block.createDataFrame("conditions", "test", cols);
    std::vector&lt;nix::Variant&gt; vals(2);
    df.rows(10);
    for (int i = 0; i &lt; 10; ++i) {
        vals[0].set(i * 2.5);
        vals[1].set("test");
        df.writeRow(i, vals);
    }

    Dimension d = data_array.appendDataFrameDimension(df, 0);

    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::DataFrame);
    DataFrameDimension dfDim;
    dfDim = d;</b></font>

    boost::optional&lt;ndsize_t&gt; pos = dfDim.indexOf(12.2, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(12.2, PositionMatch::Greater);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(12.2, PositionMatch::Equal);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(12.2, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
    pos = dfDim.indexOf(12.2, PositionMatch::Less);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);

    pos = dfDim.indexOf(9, PositionMatch::Greater);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(9, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
    pos = dfDim.indexOf(9, PositionMatch::Equal);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
    pos = dfDim.indexOf(9, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
    pos = dfDim.indexOf(9, PositionMatch::Less);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 8);

    pos = dfDim.indexOf(5, PositionMatch::Greater);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 6);
    pos = dfDim.indexOf(5, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
    pos = dfDim.indexOf(5, PositionMatch::Equal);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
    pos = dfDim.indexOf(5, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
    pos = dfDim.indexOf(5, PositionMatch::Less);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 4);

    pos = dfDim.indexOf(0.5, PositionMatch::Greater);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 1);
    pos = dfDim.indexOf(0.5, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 1);
    pos = dfDim.indexOf(0.5, PositionMatch::Equal);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(0.5, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
    pos = dfDim.indexOf(0.5, PositionMatch::Less);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);

    pos = dfDim.indexOf(-0.5, PositionMatch::Greater);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
    pos = dfDim.indexOf(-0.5, PositionMatch::GreaterOrEqual);
    CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
    pos = dfDim.indexOf(-0.5, PositionMatch::Equal);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(-0.5, PositionMatch::LessOrEqual);
    CPPUNIT_ASSERT(!pos);
    pos = dfDim.indexOf(-0.5, PositionMatch::Less);
    CPPUNIT_ASSERT(!pos);
 
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = dfDim.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = dfDim.indexOf(0.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(0.0, 3.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = dfDim.indexOf(0.0, 3.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = dfDim.indexOf(3.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(3.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    
    range = dfDim.indexOf(0.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
    range = dfDim.indexOf(1.0, 1.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(0.0, 3.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
    range = dfDim.indexOf(0.0, 3.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
    range = dfDim.indexOf(3.0, 0.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(3.0, 0.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(!range);
    range = dfDim.indexOf(0.0, 9.0, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 9);
    range = dfDim.indexOf(3.0, 9.0, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 8);

    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges;
    CPPUNIT_ASSERT_THROW(dfDim.indexOf({0.0, -1.0, 1.0}, {1.0, 2.0}, RangeMatch::Inclusive), std::runtime_error);
    ranges = dfDim.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Inclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 1);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 4);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 9);
    CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 1 &amp;&amp; (*ranges[3]).second == 1);

    ranges = dfDim.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Exclusive);
    CPPUNIT_ASSERT(ranges.size() == 4);
    CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 0);
    CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 3);
    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 8);
    CPPUNIT_ASSERT(!ranges[3]);
}

void BaseTestDimension::testAsDimensionMethods() {
    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
    Dimension x;
    Dimension d = data_array.appendRangeDimension(ticks);
    CPPUNIT_ASSERT_THROW(d.asSampledDimension(), IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(d.asSetDimension(), IncompatibleDimensions);
    x = d;
    CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Range);
    std::stringstream sa_str;
    sa_str &lt;&lt; x.dimensionType();
    CPPUNIT_ASSERT(sa_str.str() == "Range");

    data_array.deleteDimensions();
    d = data_array.appendSampledDimension(0.1);
    CPPUNIT_ASSERT_THROW(d.asRangeDimension(), IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(d.asSetDimension(), IncompatibleDimensions);
    x = d;
    CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Sample);
    std::stringstream range_str;
    range_str &lt;&lt; x.dimensionType();
    CPPUNIT_ASSERT(range_str.str() == "Sample");

    data_array.deleteDimensions();
    d = data_array.appendSetDimension();
    CPPUNIT_ASSERT_THROW(d.asRangeDimension(), IncompatibleDimensions);
    CPPUNIT_ASSERT_THROW(d.asSampledDimension(), IncompatibleDimensions);
    x = d;
    CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Set);
    std::stringstream set_str;
    set_str &lt;&lt; x.dimensionType();
    CPPUNIT_ASSERT(set_str.str() == "Set");
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
