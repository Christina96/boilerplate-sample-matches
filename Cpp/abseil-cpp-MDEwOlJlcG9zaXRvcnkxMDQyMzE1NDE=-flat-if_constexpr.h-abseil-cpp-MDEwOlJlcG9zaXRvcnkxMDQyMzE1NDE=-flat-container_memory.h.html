
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-if_constexpr.h</h3>
            <pre><code>1  #ifndef ABSL_UTILITY_INTERNAL_IF_CONSTEXPR_H_
2  #define ABSL_UTILITY_INTERNAL_IF_CONSTEXPR_H_
3  #include <tuple>
4  #include <utility>
5  #include "absl/base/config.h"
6  namespace absl {
7  ABSL_NAMESPACE_BEGIN
8  namespace utility_internal {
9  template <bool condition, typename TrueFunc, typename FalseFunc,
10            typename... Args>
11  auto IfConstexprElse(TrueFunc&& true_func, FalseFunc&& false_func,
12                       Args&&... args) {
13    return std::get<condition>(std::forward_as_tuple(
14        std::forward<FalseFunc>(false_func), std::forward<TrueFunc>(true_func)))(
15        std::forward<Args>(args)...);
16  }
17  template <bool condition, typename Func, typename... Args>
18  void IfConstexpr(Func&& func, Args&&... args) {
19    IfConstexprElse<condition>(std::forward<Func>(func), [](auto&&...){},
<span onclick='openModal()' class='match'>20                               std::forward<Args>(args)...);
21  }
22  }  
23  ABSL_NAMESPACE_END
</span>24  }  
25  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container_memory.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_CONTAINER_MEMORY_H_
2  #define ABSL_CONTAINER_INTERNAL_CONTAINER_MEMORY_H_
3  #include <cassert>
4  #include <cstddef>
5  #include <cstring>
6  #include <memory>
7  #include <new>
8  #include <tuple>
9  #include <type_traits>
10  #include <utility>
11  #include "absl/base/config.h"
12  #include "absl/memory/memory.h"
13  #include "absl/meta/type_traits.h"
14  #include "absl/utility/utility.h"
15  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
16  #include <sanitizer/asan_interface.h>
17  #endif
18  #ifdef ABSL_HAVE_MEMORY_SANITIZER
19  #include <sanitizer/msan_interface.h>
20  #endif
21  namespace absl {
22  ABSL_NAMESPACE_BEGIN
23  namespace container_internal {
24  template <size_t Alignment>
25  struct alignas(Alignment) AlignedType {};
26  template <size_t Alignment, class Alloc>
27  void* Allocate(Alloc* alloc, size_t n) {
28    static_assert(Alignment > 0, "");
29    assert(n && "n must be positive");
30    using M = AlignedType<Alignment>;
31    using A = typename absl::allocator_traits<Alloc>::template rebind_alloc<M>;
32    using AT = typename absl::allocator_traits<Alloc>::template rebind_traits<M>;
33    A my_mem_alloc(*alloc);
34    void* p = AT::allocate(my_mem_alloc, (n + sizeof(M) - 1) / sizeof(M));
35    assert(reinterpret_cast<uintptr_t>(p) % Alignment == 0 &&
36           "allocator does not respect alignment");
37    return p;
38  }
39  template <size_t Alignment, class Alloc>
40  void Deallocate(Alloc* alloc, void* p, size_t n) {
41    static_assert(Alignment > 0, "");
42    assert(n && "n must be positive");
43    using M = AlignedType<Alignment>;
44    using A = typename absl::allocator_traits<Alloc>::template rebind_alloc<M>;
45    using AT = typename absl::allocator_traits<Alloc>::template rebind_traits<M>;
46    A my_mem_alloc(*alloc);
47    AT::deallocate(my_mem_alloc, static_cast<M*>(p),
48                   (n + sizeof(M) - 1) / sizeof(M));
49  }
50  namespace memory_internal {
51  template <class Alloc, class T, class Tuple, size_t... I>
52  void ConstructFromTupleImpl(Alloc* alloc, T* ptr, Tuple&& t,
53                              absl::index_sequence<I...>) {
54    absl::allocator_traits<Alloc>::construct(
55        *alloc, ptr, std::get<I>(std::forward<Tuple>(t))...);
56  }
57  template <class T, class F>
58  struct WithConstructedImplF {
59    template <class... Args>
60    decltype(std::declval<F>()(std::declval<T>())) operator()(
61        Args&&... args) const {
62      return std::forward<F>(f)(T(std::forward<Args>(args)...));
63    }
64    F&& f;
65  };
66  template <class T, class Tuple, size_t... Is, class F>
67  decltype(std::declval<F>()(std::declval<T>())) WithConstructedImpl(
68      Tuple&& t, absl::index_sequence<Is...>, F&& f) {
69    return WithConstructedImplF<T, F>{std::forward<F>(f)}(
70        std::get<Is>(std::forward<Tuple>(t))...);
71  }
72  template <class T, size_t... Is>
73  auto TupleRefImpl(T&& t, absl::index_sequence<Is...>)
74      -> decltype(std::forward_as_tuple(std::get<Is>(std::forward<T>(t))...)) {
75    return std::forward_as_tuple(std::get<Is>(std::forward<T>(t))...);
76  }
77  template <class T>
78  auto TupleRef(T&& t) -> decltype(
79      TupleRefImpl(std::forward<T>(t),
80                   absl::make_index_sequence<
81                       std::tuple_size<typename std::decay<T>::type>::value>())) {
82    return TupleRefImpl(
83        std::forward<T>(t),
84        absl::make_index_sequence<
85            std::tuple_size<typename std::decay<T>::type>::value>());
86  }
87  template <class F, class K, class V>
88  decltype(std::declval<F>()(std::declval<const K&>(), std::piecewise_construct,
89                             std::declval<std::tuple<K>>(), std::declval<V>()))
90  DecomposePairImpl(F&& f, std::pair<std::tuple<K>, V> p) {
91    const auto& key = std::get<0>(p.first);
92    return std::forward<F>(f)(key, std::piecewise_construct, std::move(p.first),
93                              std::move(p.second));
94  }
95  }  
96  template <class Alloc, class T, class Tuple>
97  void ConstructFromTuple(Alloc* alloc, T* ptr, Tuple&& t) {
98    memory_internal::ConstructFromTupleImpl(
99        alloc, ptr, std::forward<Tuple>(t),
100        absl::make_index_sequence<
101            std::tuple_size<typename std::decay<Tuple>::type>::value>());
102  }
103  template <class T, class Tuple, class F>
104  decltype(std::declval<F>()(std::declval<T>())) WithConstructed(
105      Tuple&& t, F&& f) {
106    return memory_internal::WithConstructedImpl<T>(
107        std::forward<Tuple>(t),
108        absl::make_index_sequence<
109            std::tuple_size<typename std::decay<Tuple>::type>::value>(),
110        std::forward<F>(f));
111  }
112  inline std::pair<std::tuple<>, std::tuple<>> PairArgs() { return {}; }
113  template <class F, class S>
114  std::pair<std::tuple<F&&>, std::tuple<S&&>> PairArgs(F&& f, S&& s) {
115    return {std::piecewise_construct, std::forward_as_tuple(std::forward<F>(f)),
116            std::forward_as_tuple(std::forward<S>(s))};
117  }
118  template <class F, class S>
119  std::pair<std::tuple<const F&>, std::tuple<const S&>> PairArgs(
120      const std::pair<F, S>& p) {
121    return PairArgs(p.first, p.second);
122  }
123  template <class F, class S>
124  std::pair<std::tuple<F&&>, std::tuple<S&&>> PairArgs(std::pair<F, S>&& p) {
125    return PairArgs(std::forward<F>(p.first), std::forward<S>(p.second));
126  }
127  template <class F, class S>
128  auto PairArgs(std::piecewise_construct_t, F&& f, S&& s)
129      -> decltype(std::make_pair(memory_internal::TupleRef(std::forward<F>(f)),
130                                 memory_internal::TupleRef(std::forward<S>(s)))) {
131    return std::make_pair(memory_internal::TupleRef(std::forward<F>(f)),
132                          memory_internal::TupleRef(std::forward<S>(s)));
133  }
134  template <class F, class... Args>
135  auto DecomposePair(F&& f, Args&&... args)
136      -> decltype(memory_internal::DecomposePairImpl(
137          std::forward<F>(f), PairArgs(std::forward<Args>(args)...))) {
138    return memory_internal::DecomposePairImpl(
139        std::forward<F>(f), PairArgs(std::forward<Args>(args)...));
140  }
141  template <class F, class Arg>
142  decltype(std::declval<F>()(std::declval<const Arg&>(), std::declval<Arg>()))
143  DecomposeValue(F&& f, Arg&& arg) {
144    const auto& key = arg;
145    return std::forward<F>(f)(key, std::forward<Arg>(arg));
146  }
147  inline void SanitizerPoisonMemoryRegion(const void* m, size_t s) {
148  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
149    ASAN_POISON_MEMORY_REGION(m, s);
150  #endif
151  #ifdef ABSL_HAVE_MEMORY_SANITIZER
152    __msan_poison(m, s);
153  #endif
154    (void)m;
155    (void)s;
156  }
157  inline void SanitizerUnpoisonMemoryRegion(const void* m, size_t s) {
158  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
159    ASAN_UNPOISON_MEMORY_REGION(m, s);
160  #endif
161  #ifdef ABSL_HAVE_MEMORY_SANITIZER
162    __msan_unpoison(m, s);
163  #endif
164    (void)m;
165    (void)s;
166  }
167  template <typename T>
168  inline void SanitizerPoisonObject(const T* object) {
169    SanitizerPoisonMemoryRegion(object, sizeof(T));
170  }
171  template <typename T>
172  inline void SanitizerUnpoisonObject(const T* object) {
173    SanitizerUnpoisonMemoryRegion(object, sizeof(T));
174  }
175  namespace memory_internal {
176  template <class Pair, class = std::true_type>
177  struct OffsetOf {
178    static constexpr size_t kFirst = static_cast<size_t>(-1);
179    static constexpr size_t kSecond = static_cast<size_t>(-1);
180  };
181  template <class Pair>
182  struct OffsetOf<Pair, typename std::is_standard_layout<Pair>::type> {
183    static constexpr size_t kFirst = offsetof(Pair, first);
184    static constexpr size_t kSecond = offsetof(Pair, second);
185  };
186  template <class K, class V>
187  struct IsLayoutCompatible {
188   private:
189    struct Pair {
190      K first;
191      V second;
192    };
193    template <class P>
194    static constexpr bool LayoutCompatible() {
195      return std::is_standard_layout<P>() && sizeof(P) == sizeof(Pair) &&
196             alignof(P) == alignof(Pair) &&
197             memory_internal::OffsetOf<P>::kFirst ==
198                 memory_internal::OffsetOf<Pair>::kFirst &&
199             memory_internal::OffsetOf<P>::kSecond ==
200                 memory_internal::OffsetOf<Pair>::kSecond;
201    }
202   public:
203    static constexpr bool value = std::is_standard_layout<K>() &&
204                                  std::is_standard_layout<Pair>() &&
205                                  memory_internal::OffsetOf<Pair>::kFirst == 0 &&
206                                  LayoutCompatible<std::pair<K, V>>() &&
207                                  LayoutCompatible<std::pair<const K, V>>();
208  };
209  }  
210  template <class K, class V>
211  union map_slot_type {
212    map_slot_type() {}
213    ~map_slot_type() = delete;
214    using value_type = std::pair<const K, V>;
215    using mutable_value_type =
216        std::pair<absl::remove_const_t<K>, absl::remove_const_t<V>>;
217    value_type value;
218    mutable_value_type mutable_value;
219    absl::remove_const_t<K> key;
220  };
221  template <class K, class V>
222  struct map_slot_policy {
223    using slot_type = map_slot_type<K, V>;
224    using value_type = std::pair<const K, V>;
225    using mutable_value_type =
226        std::pair<absl::remove_const_t<K>, absl::remove_const_t<V>>;
227   private:
228    static void emplace(slot_type* slot) {
229      new (slot) slot_type;
230    }
231    using kMutableKeys = memory_internal::IsLayoutCompatible<K, V>;
232   public:
233    static value_type& element(slot_type* slot) { return slot->value; }
234    static const value_type& element(const slot_type* slot) {
235      return slot->value;
236    }
237  #if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606
238    static K& mutable_key(slot_type* slot) {
239      return kMutableKeys::value ? slot->key
240                                 : *std::launder(const_cast<K*>(
241                                       std::addressof(slot->value.first)));
242    }
243  #else  
244    static const K& mutable_key(slot_type* slot) { return key(slot); }
245  #endif
246    static const K& key(const slot_type* slot) {
247      return kMutableKeys::value ? slot->key : slot->value.first;
248    }
249    template <class Allocator, class... Args>
250    static void construct(Allocator* alloc, slot_type* slot, Args&&... args) {
251      emplace(slot);
252      if (kMutableKeys::value) {
253        absl::allocator_traits<Allocator>::construct(*alloc, &slot->mutable_value,
254                                                     std::forward<Args>(args)...);
255      } else {
256        absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,
<span onclick='openModal()' class='match'>257                                                     std::forward<Args>(args)...);
258      }
259    }
260    template <class Allocator>
</span>261    static void construct(Allocator* alloc, slot_type* slot, slot_type* other) {
262      emplace(slot);
263      if (kMutableKeys::value) {
264        absl::allocator_traits<Allocator>::construct(
265            *alloc, &slot->mutable_value, std::move(other->mutable_value));
266      } else {
267        absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,
268                                                     std::move(other->value));
269      }
270    }
271    template <class Allocator>
272    static void construct(Allocator* alloc, slot_type* slot,
273                          const slot_type* other) {
274      emplace(slot);
275      absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,
276                                                   other->value);
277    }
278    template <class Allocator>
279    static void destroy(Allocator* alloc, slot_type* slot) {
280      if (kMutableKeys::value) {
281        absl::allocator_traits<Allocator>::destroy(*alloc, &slot->mutable_value);
282      } else {
283        absl::allocator_traits<Allocator>::destroy(*alloc, &slot->value);
284      }
285    }
286    template <class Allocator>
287    static void transfer(Allocator* alloc, slot_type* new_slot,
288                         slot_type* old_slot) {
289      emplace(new_slot);
290  #if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606
291      if (absl::is_trivially_relocatable<value_type>()) {
292        std::memcpy(static_cast<void*>(std::launder(&new_slot->value)),
293                    static_cast<const void*>(&old_slot->value),
294                    sizeof(value_type));
295        return;
296      }
297  #endif
298      if (kMutableKeys::value) {
299        absl::allocator_traits<Allocator>::construct(
300            *alloc, &new_slot->mutable_value, std::move(old_slot->mutable_value));
301      } else {
302        absl::allocator_traits<Allocator>::construct(*alloc, &new_slot->value,
303                                                     std::move(old_slot->value));
304      }
305      destroy(alloc, old_slot);
306    }
307  };
308  }  
309  ABSL_NAMESPACE_END
310  }  
311  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-if_constexpr.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container_memory.h</div>
                </div>
                <div class="column column_space"><pre><code>20                               std::forward<Args>(args)...);
21  }
22  }  
23  ABSL_NAMESPACE_END
</pre></code></div>
                <div class="column column_space"><pre><code>257                                                     std::forward<Args>(args)...);
258      }
259    }
260    template <class Allocator>
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    