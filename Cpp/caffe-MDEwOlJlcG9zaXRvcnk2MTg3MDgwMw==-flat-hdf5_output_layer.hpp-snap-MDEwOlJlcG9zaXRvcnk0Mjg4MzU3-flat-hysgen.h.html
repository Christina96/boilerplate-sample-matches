
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-hdf5_output_layer.hpp</h3>
            <pre><code>1  #ifndef CAFFE_HDF5_OUTPUT_LAYER_HPP_
2  #define CAFFE_HDF5_OUTPUT_LAYER_HPP_
3  #include "hdf5.h"
4  #include <string>
5  #include <vector>
6  #include "caffe/blob.hpp"
7  #include "caffe/layer.hpp"
8  #include "caffe/proto/caffe.pb.h"
9  namespace caffe {
10  #define HDF5_DATA_DATASET_NAME "data"
11  #define HDF5_DATA_LABEL_NAME "label"
12  template <typename Dtype>
13  class HDF5OutputLayer : public Layer<Dtype> {
14   public:
15    explicit HDF5OutputLayer(const LayerParameter& param)
16        : Layer<Dtype>(param), file_opened_(false) {}
17    virtual ~HDF5OutputLayer();
18    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
19        const vector<Blob<Dtype>*>& top);
20    virtual inline bool ShareInParallel() const { return true; }
21    virtual void Reshape(const vector<Blob<Dtype>*>& bottom,
22        const vector<Blob<Dtype>*>& top) {}
23    virtual inline const char* type() const { return "HDF5Output"; }
24    virtual inline int ExactNumBottomBlobs() const { return 2; }
25    virtual inline int ExactNumTopBlobs() const { return 0; }
26    inline std::string file_name() const { return file_name_; }
27   protected:
28    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
29        const vector<Blob<Dtype>*>& top);
30    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
31        const vector<Blob<Dtype>*>& top);
32    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
33        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
34    virtual void Backward_gpu(const vector<Blob<Dtype>*>& top,
35        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
36    virtual void SaveBlobs();
37    bool file_opened_;
38    std::string file_name_;
<span onclick='openModal()' class='match'>39    hid_t file_id_;
40    Blob<Dtype> data_blob_;
41    Blob<Dtype> label_blob_;
42  };
</span>43  }  
44  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.h</h3>
            <pre><code>1  #ifndef Pedrood_CmntyHyper_h
2  #define Pedrood_CmntyHyper_h
3  #include <execinfo.h>
4  #include "Snap.h"
5  #include <sstream>
6  #include <stdlib.h>
7  class THysgenUtil {
8  public:
9    enum Criteria {Alphabetical, Value};
10    static void DumpCmtyVV(const TStr OutFNm, TVec<TIntV>& CmtyVV, TIntStrH& NIDNmH);
11    static void DumpCmtyVH(const TStr OutFNm, TVec<TIntFltH>& CmtyVH,
12                           TIntStrH& NIDNmH, Criteria Crit=Value);
13    static PHGraph LoadEdgeList(const TStr& InFNm, TStrHash<TInt>& NodeNameH,
14                                const TSsFmt SsFmt = ssfTabSep);
15    template<class PHGraph>
16    static double GetConductance(const PHGraph& Graph, const TIntSet& CmtyS, const int N2Edges);
17    template<class PHGraph>
18    static void GetNbhCom(const PHGraph& Graph, const int NID, TIntSet& NBCmtyS);
19    template<class PHGraph>
20    static void GetPhiNIdPrV(const PHGraph &G, TFltIntPrV &PhiNIdPrV, const int MinComSiz);
21    static void GetBinLocs(const int& DecNum, TIntV& LocsV, const TIntV& NodMapV);
22    static double Min(double	N1, double N2) {
23      return (N1 < N2) ? N1 : N2;
24    }
25    static bool IsEqual(const double Num1, const double Num2) {
26      return abs(Num1 - Num2) < TFlt::Eps;
27    }
28  };
29  class THysgen {
30  private:
31    PHGraph G; 
32    TVec<TIntFltH> S; 
33    THash<TInt,TIntFltH> ProbEdgCommHH;
34    THash<TInt,TFlt> ProbNotEdgH;
35    THash<TInt,TFlt> ProbEdgH;
36    TVec<TFltV> AuxDPEdgVV;
37    TFltV ProbENoiseV; 
38    TRnd Rnd; 
39    TIntSet NIdToIdx;
40    TInt NumComs; 
41    TIntV NumCIdNV; 
<span onclick='openModal()' class='match'>42    TIntSet HOEIDS; 
43    TVec<TIntSet> HONEIdsV; 
44    TVec<TIntSet> HONNIdsV; 
45    TVec<TIntSet> HOKIDSV; 
</span>46    TInt MinTayN; 
47    TInt TayN; 
48    TFlt TayThresh; 
49    TVec<TFltV> SumPrPsblEdgesPow_nVV;
50    TFlt SNoise;
51    TFlt ThreshLearnRate;
52  public:
53    TFlt InitVal;   
54    TFlt InitNullS; 
55    TFlt MinVal;    
56    TFlt MaxVal;    
57    TFlt NegWgt;
58    TFlt RegCoef;   
59    TFlt PrNoCom;
60  private:
61    void GetUpdatedNodP(TIntFltH &SNew, const int &UID, const TIntFltH& GradUH,
62                        double &StepSize);
63    void GetUpdatedNodP(TIntFltH &SNew, TIntFltH& SearchVecOut, const int& UID,
64                        const TIntFltH& GradUH, double& StepSize);
65    bool AcceptStepSA(const int &UID, const TIntFltH &SNew, const int &Iter,
66                      const int &MaxIter, const double &SAParamK);
67    bool RmvWeakDirections(const int &UId, TIntFltH &GradH);
68    void InitEdgeProb();
69    void UpdateUEdgesProb(const int& UId, const int& CId, const double& SUNew);
70    void InitPrAllEdgesS(const double& DefVal, const bool& IsEqualComms=false);
71    void UpdatePrAllEdgesS(const int &UID, const int &CID, const double& SNNew);
72    void UpdatePrAllEdgesS(TFltV &PsiV, const int &UID, const int &CID,
73                           const double& SNNew, const bool IsApplyChange);
74    void UpdatePrAllEdgesS(const int &UID, const int &CID, const TFltV& SNodNewV){
75      UpdatePrAllEdgesS(UID, CID, SNodNewV[CID]);
76    }
77    double PredictAllCEdgesS_direct(const int &UID, const int &CID,
78                                    const bool IsLikelihood = false, const bool Verbose= false);
79    double PredictAllCEdgesS(const int &UID, const int &CID,
80                             const bool IsLikelihood = false, const bool Verbose=false);
81    double PredictAllCEdgesS(const int &UID, const int &CID, const double& SNNew,
82                             const bool IsLikelihood = true, const bool Verbose=false);
83    void UpdateProbNotEdgH(const int &EId, const double &PrECNew,
84                           const double &PrECOld);
85  public:
86    explicit THysgen(const PHGraph &GraphPt, const int RndSeed = 0,
87            const double InitCVal = 0.1, const double InitNulS = 0.03,
88            const double NoiseConstS = 0.01) :
89            Rnd(RndSeed), MinTayN(10), TayN(50), TayThresh(0.00001),
90            SNoise(NoiseConstS), InitVal(InitCVal), InitNullS(InitNulS),
91            MinVal(0.0), MaxVal(1.0), NegWgt(1.0), RegCoef(0.0) {
92      SNoise = (InitNulS>0.0) ? THysgenUtil::Min(NoiseConstS, InitNulS / 2.0) : NoiseConstS;
93      ThreshLearnRate = TayThresh / GraphPt->GetNodes();
94      SetGraph(GraphPt);
95    }
96    void Save(TSOut& SOut) {
97      G->Save(SOut);
98      S.Save(SOut);
99      ProbEdgCommHH.Save(SOut);
100      ProbNotEdgH.Save(SOut);
101      ProbEdgH.Save(SOut);
102      AuxDPEdgVV.Save(SOut);
103      ProbENoiseV.Save(SOut);
104      NIdToIdx.Save(SOut);
105      RegCoef.Save(SOut);
106      NumComs.Save(SOut);
107      NumCIdNV.Save(SOut);
108      HONEIdsV.Save(SOut);
109      HONNIdsV.Save(SOut);
110      HOKIDSV.Save(SOut);
111      TayN.Save(SOut);
112      MinTayN.Save(SOut);
113      TayThresh.Save(SOut);
114      SumPrPsblEdgesPow_nVV.Save(SOut);
115      InitVal.Save(SOut);
116      MinVal.Save(SOut);
117      MaxVal.Save(SOut);
118      NegWgt.Save(SOut);
119      PrNoCom.Save(SOut);
120      InitNullS.Save(SOut);
121    }
122    void Load(TSIn& SIn, const int& RndSeed = 0) {
123      G->Load(SIn);
124      S.Load(SIn);
125      ProbEdgCommHH.Load(SIn);
126      ProbNotEdgH.Load(SIn);
127      ProbEdgH.Load(SIn);
128      AuxDPEdgVV.Load(SIn);
129      ProbENoiseV.Load(SIn);
130      NIdToIdx.Load(SIn);
131      RegCoef.Load(SIn);
132      NumComs.Load(SIn);
133      NumCIdNV.Load(SIn);
134      HONEIdsV.Load(SIn);
135      HONNIdsV.Load(SIn);
136      HOKIDSV.Load(SIn);
137      TayN.Load(SIn);
138      MinTayN.Load(SIn);
139      TayThresh.Load(SIn);
140      SumPrPsblEdgesPow_nVV.Load(SIn);
141      InitVal.Load(SIn);
142      MinVal.Load(SIn);
143      MaxVal.Load(SIn);
144      NegWgt.Load(SIn);
145      PrNoCom.Load(SIn);
146      InitNullS.Load(SIn);
147    }
148    void SetGraph(const PHGraph& GraphPt);
149    void SetRegCoef(const double _RegCoef) { RegCoef = _RegCoef; }
150    double GetRegCoef() { return RegCoef; }
151    void LoadComInit(const TStr& InFNm, TSsFmt SsFmt=ssfTabSep);
152    void ComInit(const int InitComs, const int MinComSiz=5, const double PerturbDens=0.0);
153    void UniformComInit(const int InitComs);
154    void RandomComPerturb(double Density = 1.0);
155    void NeighborComInit(const int MinComSiz, const bool& IsInit = false);
156    void NeighborComInit(TFltIntPrV& PhiNIdPrV, const bool& IsInit = false);
157    TInt GetNumComs() { return NumComs; }
158    void SetCmtyVV(const TVec<TIntV>& CmtyVV);
159    double Likelihood();
160    double LikelihoodForRow(const int UID);
161    double LikelihoodForRow(const int UID, const TIntFltH &SU);
162    void GradientForRow(const int UId, TIntFltH &GradNod);
163    void GetCmtyVV(TVec<TIntFltH>& CmtyVH, TVec<TIntV>& CmtyVV, TVec<TFltV>& WckVV,
164                   const double Thres, const int MinSz = 3);
165    void GetCmtyVV(TVec<TIntFltH>& CmtyVH, TVec<TIntV>& CmtyVV, TVec<TFltV>& WckVV,
166                   const int MinSz = 3) {
167      printf("\n+-+-+-+- Threshold = %f -+-+-+-+\n",
168             sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()));
169      GetCmtyVV(CmtyVH, CmtyVV, WckVV,
170                sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), MinSz);
171    }
172    void GetCmtyVV(TVec<TIntFltH>& CmtyVH, TVec<TIntV>& CmtyVV,
173                   const double Thres, const int MinSz = 3) {
174      TVec<TFltV> TmpV;
175      GetCmtyVV(CmtyVH, CmtyVV, TmpV, Thres, MinSz);
176    }
177    void GetCmtyVV(TVec<TIntFltH>& CmtyVH, TVec<TIntV>& CmtyVV) {
178      TVec<TFltV> TmpVV;
179      GetCmtyVV(CmtyVH, CmtyVV, TmpVV,
180                sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
181    }
182    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV);
183    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
184    double GetStepSizeByLineSearch(const int UID, const TIntFltH &DeltaH,
185                                   const double &stepSize,
186                                   const double &CtrlParam,
187                                   const double &ReductionRatio,
188                                   const int MaxIter);
189    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm,
190                      const double StepSize = 0.3, const double StepCtrlParam = 0.3,
191                      const double StepReductionRatio = 0.3);
192    void inline GetNCom(TIntFltH& NIdH, const int& NID) {
193      NIdH = S[NID];
194    }
195    double inline GetNCom(const int& NID, const int& CID) {
196      if (S[NID].IsKey(CID)) {
197        return S[NID].GetDat(CID);
198      } else {
199        return 0.0;
200      }
201    }
202    void inline DelNCom(const int &UID, const int &CID) {
203      if (S[UID].IsKey(CID)) {
204        UpdatePrAllEdgesS(UID, CID, 0.0);
205        UpdateUEdgesProb(UID, CID, 0.0);
206        S[UID].DelKey(CID);
207        NumCIdNV[CID] --;
208      }
209    }
210    void inline AddNCom(const TIntV& NIdV, const int& CID, const double& Val, const bool& IsInit = false) {
211      for (int ui = 0; ui < NIdV.Len(); ui++){
212        AddNCom(NIdV[ui], CID, Val, IsInit);
213      }
214    }
215    void inline AddNCom(const int& UId, const int& CID, const double& Val, const bool& IsInit = false) {
216      if (Val < DBL_EPSILON) {
217        DelNCom(UId, CID);
218        return;
219      }
220      if (!IsInit){ 
221        UpdatePrAllEdgesS(UId, CID, Val);
222        UpdateUEdgesProb(UId, CID, Val);
223      }
224      if (S[UId].IsKey(CID)) {
225        NumCIdNV[CID] --;
226      }
227      S[UId].AddDat(CID, Val);
228      NumCIdNV[CID] ++;
229    }
230    double inline GetPrE(const int &EId) {
231      if (THysgenUtil::IsEqual(ProbNotEdgH.GetDat(EId)(), -1.0)) {
232        return ProbEdgH.GetDat(EId)();
233      }
234      return 1.0 - ProbNotEdgH.GetDat(EId);
235    }
236    double GetPrE(const int &EId, const int &UId, const TIntFltH &SUNewH,
237                  TIntFltH &PrEOutCH);
238    static double GetPrEPrecision(const TIntFltH &ECH, TVec<TFltV> &DPMatVV,
239                           const double PrENoise);
240    double inline GetENoiseProb(const int Size) {
241      if (Size > ProbENoiseV.Len()) { AddENoiseProb(Size); }
242      return ProbENoiseV[Size];
243    }
244    void inline AddENoiseProb(const int Size) {
245      for (int i = ProbENoiseV.Len(); i <= Size; i++) {
246        ProbENoiseV[i] = ProbENoiseV[i-1] * SNoise;
247      }
248    }
249    template <class TInt1, class TInt2>
250    double inline GetECom(const TInt1 &EId, const TInt2 &CId) {
251      if (ProbEdgCommHH.IsKey(EId) && ProbEdgCommHH.GetDat(EId).IsKey(CId)) {
252        return ProbEdgCommHH.GetDat(EId).GetDat(CId);
253      }
254      else {
255        return 0.0;
256      }
257    }
258    void inline AddECom(const int& EId, const TIntFltH& ProdH) {
259      double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
260      double PrNotE = 1.0 - PrENoise;
261      if (ProdH.Len() != 0) {
262        ProbEdgCommHH.AddDat(EId, ProdH);
263        for (TIntFltH::TIter HI = ProdH.BegI(); HI < ProdH.EndI(); HI++) {
264          PrNotE *= 1.0 - HI.GetDat();
265        }
266      } else {
267        if (ProbEdgCommHH.IsKey(EId)) {
268          ProbEdgCommHH.DelKey(EId);
269        }
270      }
271      if (PrNotE >= 1.0) {
272        ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
273        ProbNotEdgH.AddDat(EId,-1.0);
274        return;
275      }
276      ProbNotEdgH.AddDat(EId,PrNotE);
277      ProbEdgH.AddDat(EId,1-PrNotE);
278    }
279    void inline AddECom(const int& EId, const int& CId, const double& PrECNew) {
280      if (PrECNew <= 0.0) {
281        DelECom(EId, CId);
282        return;
283      }
284      double PrECOld = GetECom(EId, CId);
285      if (! ProbEdgCommHH.IsKey(EId)) {
286        TIntFltH EmptyEProdH(NumComs);
287        ProbEdgCommHH.AddDat(EId, EmptyEProdH);
288      }
289      ProbEdgCommHH.GetDat(EId).AddDat(CId, PrECNew);
290      UpdateProbNotEdgH(EId, PrECNew, PrECOld);
291    }
292    void inline DelECom(const int& EId, const int& CId) {
293      double PrECOld = GetECom(EId, CId);
294      if (PrECOld > 0.0) {
295        ProbEdgCommHH.GetDat(EId).DelKey(CId);
296        UpdateProbNotEdgH(EId, 0.0, PrECOld);
297      }
298    }
299    static double DotProduct(const TIntFltH& UV, const TIntFltH& VV);
300    double inline DotProduct(const int& UID, const int& VID) {
301      return DotProduct(S[UID], S[VID]);
302    }
303    void inline Normalize(const TIntFltH& UV, TIntFltH& UVNmd) {
304      double Nrm = Norm2(UV);
305      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
306        UVNmd.AddDat(HI.GetKey(), HI.GetDat()/Nrm);
307      }
308    }
309    void inline Normalize(TIntFltH& UV) {
310      double Nrm = Norm2(UV);
311      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
312        UV.AddDat(HI.GetKey(), HI.GetDat()/Nrm);
313      }
314    }
315    void inline NormalizeIfLarge(const TIntFltH& UV, TIntFltH& UVNmd) {
316      double Nrm = Norm2(UV);
317      if (Nrm >1.0) { Normalize(UV, UVNmd); }
318      else { 
319        for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
320          UVNmd.AddDat(HI.GetKey(), HI.GetDat());
321        }
322      }
323    }
324    double inline Sum(const TIntFltH& UV) {
325      double N = 0.0;
326      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
327        N += HI.GetDat();
328      }
329      return N;
330    }
331    double inline Norm2(const TIntFltH& UV) {
332      double N = 0.0;
333      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
334        N += HI.GetDat() * HI.GetDat();
335      }
336      return sqrt(N);
337    }
338    double inline Sigmoid(const double X) {
339      return 1.0 / ( 1.0 + exp(-X));
340    }
341  };
342  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-hdf5_output_layer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.h</div>
                </div>
                <div class="column column_space"><pre><code>39    hid_t file_id_;
40    Blob<Dtype> data_blob_;
41    Blob<Dtype> label_blob_;
42  };
</pre></code></div>
                <div class="column column_space"><pre><code>42    TIntSet HOEIDS; 
43    TVec<TIntSet> HONEIdsV; 
44    TVec<TIntSet> HONNIdsV; 
45    TVec<TIntSet> HOKIDSV; 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    