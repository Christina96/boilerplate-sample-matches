<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_api_symmetric_mode_ecb.cpp & test_api_symmetric_mode_ctr.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_api_symmetric_mode_ecb.cpp & test_api_symmetric_mode_ctr.cpp
      </h3>
      <h1 align="center">
        74.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_api_symmetric_mode_ecb.cpp (80.34188%)<TH>test_api_symmetric_mode_ctr.cpp (69.62963%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match49-0.html#0',2,'match49-1.html#0',3)" NAME="0">(17-110)<TD><A HREF="javascript:ZweiFrames('match49-0.html#0',2,'match49-1.html#0',3)" NAME="0">(17-113)</A><TD ALIGN=center><FONT COLOR="#ff0000">46</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match49-0.html#1',2,'match49-1.html#1',3)" NAME="1">(195-246)<TD><A HREF="javascript:ZweiFrames('match49-0.html#1',2,'match49-1.html#1',3)" NAME="1">(227-283)</A><TD ALIGN=center><FONT COLOR="#bc0000">34</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match49-0.html#2',2,'match49-1.html#2',3)" NAME="2">(124-175)<TD><A HREF="javascript:ZweiFrames('match49-0.html#2',2,'match49-1.html#2',3)" NAME="2">(149-205)</A><TD ALIGN=center><FONT COLOR="#bc0000">34</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match49-0.html#3',2,'match49-1.html#3',3)" NAME="3">(361-380)<TD><A HREF="javascript:ZweiFrames('match49-0.html#3',2,'match49-1.html#3',3)" NAME="3">(417-437)</A><TD ALIGN=center><FONT COLOR="#5e0000">17</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match49-0.html#4',2,'match49-1.html#4',3)" NAME="4">(302-326)<TD><A HREF="javascript:ZweiFrames('match49-0.html#4',2,'match49-1.html#4',3)" NAME="4">(352-377)</A><TD ALIGN=center><FONT COLOR="#580000">16</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match49-0.html#5',2,'match49-1.html#5',3)" NAME="5">(262-286)<TD><A HREF="javascript:ZweiFrames('match49-0.html#5',2,'match49-1.html#5',3)" NAME="5">(305-330)</A><TD ALIGN=center><FONT COLOR="#580000">16</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match49-0.html#6',2,'match49-1.html#6',3)" NAME="6">(334-351)<TD><A HREF="javascript:ZweiFrames('match49-0.html#6',2,'match49-1.html#6',3)" NAME="6">(388-405)</A><TD ALIGN=center><FONT COLOR="#480000">13</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match49-0.html#7',2,'match49-1.html#7',3)" NAME="7">(381-398)<TD><A HREF="javascript:ZweiFrames('match49-0.html#7',2,'match49-1.html#7',3)" NAME="7">(439-457)</A><TD ALIGN=center><FONT COLOR="#420000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_api_symmetric_mode_ecb.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * This file is part of cryptopp-bindings-api.
 *
 * (c) Stephen Berquet &lt;stephen.berquet@gmail.com&gt;
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

#include &quot;src/exception/api_exception.h&quot;
#include &quot;src/symmetric/cipher/block/api_block_cipher_aes.h&quot;
#include &quot;src/symmetric/mode/api_symmetric_mode_ecb.h&quot;
#include &quot;src/utils/api_hex_utils.h&quot;
<A NAME="0"></A>#include &quot;tests/test_api_assertions.h&quot;
#include &lt;gtest/gtest.h&gt;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match49-1.html#0',3,'match49-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>TEST(SymmetricModeEcbTest, inheritance) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricCipherInterface*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricTransformationInterface*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricModeInterface*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricModeAbstract*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricKeyAbstract*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricIvAbstract*&gt;(&amp;mode));
}

TEST(SymmetricModeEcbTest, infos) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    EXPECT_STREQ(&quot;ecb(aes)&quot;, mode.getName());
    EXPECT_EQ(16, mode.getBlockSize());
}

TEST(SymmetricModeEcbTest, isValidKeyLength) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    EXPECT_TRUE(mode.isValidKeyLength(16));
    EXPECT_FALSE(mode.isValidKeyLength(15));
    EXPECT_FALSE(mode.isValidKeyLength(17));

    EXPECT_TRUE(mode.isValidKeyLength(24));
    EXPECT_FALSE(mode.isValidKeyLength(23));
    EXPECT_FALSE(mode.isValidKeyLength(25));

    EXPECT_TRUE(mode.isValidKeyLength(32));
    EXPECT_FALSE(mode.isValidKeyLength(31));
    EXPECT_FALSE(mode.isValidKeyLength(33));
}

TEST(SymmetricModeEcbTest, isValidIvLength) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    EXPECT_TRUE(mode.isValidIvLength(0));
    EXPECT_FALSE(mode.isValidKeyLength(1));
    EXPECT_FALSE(mode.isValidKeyLength(17));
}

TEST(SymmetricModeEcbTest, setGetKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    // build keys
    byte *key128;
    byte *key192;
    byte *key256;
    size_t key128Length = 0;
    size_t key192Length = 0;
    size_t key256Length = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;0102030405060708090a0b0c0d0e0f10&quot;, 32, &amp;key128, key128Length);
    CryptoppApi::HexUtils::hex2bin(&quot;0102030405060708090a0b0c0d0e0f101112131415161718&quot;, 48, &amp;key192, key192Length);
    CryptoppApi::HexUtils::hex2bin(&quot;0102030405060708090a0b0c0d0e0f1011121314151617181901020304050607&quot;, 64, &amp;key256, key256Length);

    // set/get keys
    size_t key0Length = mode.getKeyLength();

    mode.setKey(key128, key128Length);
    size_t key128GetLength = mode.getKeyLength();
    byte key128Get[key128GetLength];
    mode.getKey(key128Get);

    mode.setKey(key192, key192Length);
    size_t key192GetLength = mode.getKeyLength();
    byte key192Get[key192GetLength];
    mode.getKey(key192Get);

    mode.setKey(key256, key256Length);
    size_t key256GetLength = mode.getKeyLength();
    byte key256Get[key256GetLength];
    mode.getKey(key256Get);

    // test keys
    EXPECT_EQ(0, key0Length);
    EXPECT_BYTE_ARRAY_EQ(key128, key128Length, key128Get, key128GetLength);
    EXPECT_BYTE_ARRAY_EQ(key192, key192Length, key192Get, key192GetLength);
    EXPECT_BYTE_ARRAY_EQ(key256, key256Length, key256Get, key256GetLength);

    delete[] key128;
    delete[] key192;
    delete[] key256;
}

TEST(SymmetricModeEcbTest, encrypt) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);
    size_t dataSize = 32;</B></FONT>

    byte output1[dataSize];
    byte output2[dataSize];
    byte *expected1;
    byte *expected2;

    // build keys
    byte *key128;
    byte *key192;
    byte *key256;
<A NAME="2"></A>    size_t key128Length = 0;
    size_t key192Length = 0;
    size_t key256Length = 0;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match49-1.html#2',3,'match49-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key128, key128Length);
    CryptoppApi::HexUtils::hex2bin(&quot;8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b&quot;, 48, &amp;key192, key192Length);
    CryptoppApi::HexUtils::hex2bin(&quot;603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4&quot;, 64, &amp;key256, key256Length);

    // build blocks
    byte *block1;
    byte *block2;
    size_t dummyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;30c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710&quot;, 64, &amp;block2, dummyLength);

    // aes128
    CryptoppApi::HexUtils::hex2bin(&quot;3ad77bb40d7a3660a89ecaf32466ef97f5d3d58503b9699de785895a96fdbaaf&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;43b1cd7f598ece23881b00e3ed0306887b0c785e27e8ad3f8223207104725dd4&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key128, key128Length);
    mode.encrypt(block1, output1, dataSize);
    mode.encrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    // aes192
    CryptoppApi::HexUtils::hex2bin(&quot;bd334f1d6e45f25ff712a214571fa5cc974104846d0ad3ad7734ecb3ecee4eef&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;ef7afd2270e2e60adce0ba2face6444e9a4b41ba738d6c72fb16691603c18e0e&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key192, key192Length);
    mode.encrypt(block1, output1, dataSize);
    mode.encrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    // aes256
    CryptoppApi::HexUtils::hex2bin(&quot;f3eed1bdb5d2a03c064b5a7e3db181f8591ccb10d410ed26dc5ba74a31362870&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;b6ed21b99ca6f4f9f153e7b1beafed1d23304b7a39f9f3ff067d8d8f9e24ecc7&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key256, key256Length);
    mode.encrypt(block1, output1, dataSize);
    mode.encrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    delete[] key128;
    delete[] key192;
    delete[] key256;
    delete[] block1;
    delete[] block2;</B></FONT>
}

TEST(SymmetricModeEcbTest, decrypt) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);
    size_t dataSize = 32;

    byte output1[dataSize];
    byte output2[dataSize];
    byte *block1;
    byte *block2;

    // build keys
    byte *key128;
    byte *key192;
    byte *key256;
<A NAME="1"></A>    size_t key128Length = 0;
    size_t key192Length = 0;
    size_t key256Length = 0;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match49-1.html#1',3,'match49-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key128, key128Length);
    CryptoppApi::HexUtils::hex2bin(&quot;8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b&quot;, 48, &amp;key192, key192Length);
    CryptoppApi::HexUtils::hex2bin(&quot;603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4&quot;, 64, &amp;key256, key256Length);

    // build expected data
    byte *expected1;
    byte *expected2;
    size_t dummyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;30c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710&quot;, 64, &amp;expected2, dummyLength);

    // aes128
    CryptoppApi::HexUtils::hex2bin(&quot;3ad77bb40d7a3660a89ecaf32466ef97f5d3d58503b9699de785895a96fdbaaf&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;43b1cd7f598ece23881b00e3ed0306887b0c785e27e8ad3f8223207104725dd4&quot;, 64, &amp;block2, dummyLength);
    mode.setKey(key128, key128Length);
    mode.decrypt(block1, output1, dataSize);
    mode.decrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] block1;
    delete[] block2;

    // aes192
    CryptoppApi::HexUtils::hex2bin(&quot;bd334f1d6e45f25ff712a214571fa5cc974104846d0ad3ad7734ecb3ecee4eef&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;ef7afd2270e2e60adce0ba2face6444e9a4b41ba738d6c72fb16691603c18e0e&quot;, 64, &amp;block2, dummyLength);
    mode.setKey(key192, key192Length);
    mode.decrypt(block1, output1, dataSize);
    mode.decrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] block1;
    delete[] block2;

    // aes256
    CryptoppApi::HexUtils::hex2bin(&quot;f3eed1bdb5d2a03c064b5a7e3db181f8591ccb10d410ed26dc5ba74a31362870&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;b6ed21b99ca6f4f9f153e7b1beafed1d23304b7a39f9f3ff067d8d8f9e24ecc7&quot;, 64, &amp;block2, dummyLength);
    mode.setKey(key256, key256Length);
    mode.decrypt(block1, output1, dataSize);
    mode.decrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] block1;
    delete[] block2;

    delete[] key128;
    delete[] key192;
    delete[] key256;
    delete[] expected1;
    delete[] expected2;</B></FONT>
}

TEST(SymmetricModeEcbTest, restartEncryption) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);
    size_t dataSize = 32;

    byte output1[dataSize];
    byte output2[dataSize];
    byte *expected1;
    byte *expected2;

<A NAME="5"></A>    // build key
    byte *key;
    size_t keyLength = 0;
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match49-1.html#5',3,'match49-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

    // build blocks
    byte *block1;
    byte *block2;
    size_t dummyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;30c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710&quot;, 64, &amp;block2, dummyLength);

    // calculate actual data
    CryptoppApi::HexUtils::hex2bin(&quot;3ad77bb40d7a3660a89ecaf32466ef97f5d3d58503b9699de785895a96fdbaaf&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;43b1cd7f598ece23881b00e3ed0306887b0c785e27e8ad3f8223207104725dd4&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key, keyLength);
    mode.encrypt(block1, output1, dataSize);
    mode.restart();
    mode.encrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    delete[] key;
    delete[] block1;
    delete[] block2;</B></FONT>
}

TEST(SymmetricModeEcbTest, restartDecryption) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);
    size_t dataSize = 32;

    byte output1[dataSize];
    byte output2[dataSize];
    byte *expected1;
    byte *expected2;

<A NAME="4"></A>    // build key
    byte *key;
    size_t keyLength = 0;
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match49-1.html#4',3,'match49-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

    // build blocks
    byte *block1;
    byte *block2;
    size_t dummyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;3ad77bb40d7a3660a89ecaf32466ef97f5d3d58503b9699de785895a96fdbaaf&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;43b1cd7f598ece23881b00e3ed0306887b0c785e27e8ad3f8223207104725dd4&quot;, 64, &amp;block2, dummyLength);

    // calculate actual data
    CryptoppApi::HexUtils::hex2bin(&quot;6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;30c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key, keyLength);
    mode.decrypt(block1, output1, dataSize);
    mode.restart();
    mode.decrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    delete[] key;
    delete[] block1;
    delete[] block2;</B></FONT>
}

TEST(SymmetricModeEcbTest, largeData) {
    CryptoppApi::BlockCipherAes cipher;
<A NAME="6"></A>    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    std::string key(&quot;1234567890123456&quot;);
<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match49-1.html#6',3,'match49-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    mode.setKey(reinterpret_cast&lt;const byte*&gt;(key.c_str()), key.length());

    size_t dataSize = 10485760;
    byte *input     = new byte[dataSize];
    byte *output    = new byte[dataSize];
    memset(input, 125, dataSize);
    mode.encrypt(input, output, dataSize);
    mode.decrypt(input, output, dataSize);

    delete[] input;
    delete[] output;
}

TEST(SymmetricModeEcbTest, cryptInvalidBlockSize) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    std::string key(&quot;1234567890123456&quot;);</B></FONT>
    mode.setKey(reinterpret_cast&lt;const byte*&gt;(key.c_str()), key.length());

    std::string dataStr(&quot;12345678901234567&quot;);
    const byte *data    = reinterpret_cast&lt;const byte*&gt;(dataStr.c_str());
    size_t dataLength   = dataStr.length();
    byte output[dataLength];
<A NAME="3"></A>
    EXPECT_THROW_MSG(mode.encrypt(data, output, dataLength), CryptoppApi::Exception, &quot;data size (17) is not a multiple of block size (16)&quot;);
    EXPECT_THROW_MSG(mode.decrypt(data, output, dataLength), CryptoppApi::Exception, &quot;data size (17) is not a multiple of block size (16)&quot;);
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match49-1.html#3',3,'match49-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

TEST(SymmetricModeEcbTest, invalidKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    byte key1[] = {45, 12, 14};
    byte key2[0];

    EXPECT_THROW_MSG(mode.setKey(key1, 3), CryptoppApi::Exception, &quot;3 is not a valid key length&quot;);
    EXPECT_THROW_MSG(mode.setKey(key2, 0), CryptoppApi::Exception, &quot;a key is required&quot;);
}

TEST(SymmetricModeEcbTest, invalidIv) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

<A NAME="7"></A>    byte iv[] = {45, 12, 14};

    EXPECT_THROW_MSG(mode.setIv(iv, 3), CryptoppApi::Exception, &quot;3 is not a valid initialization vector length&quot;);</B></FONT>
<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match49-1.html#7',3,'match49-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

TEST(SymmetricModeEcbTest, cryptWithoutKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode(&amp;cipher);

    size_t inputLength = mode.getBlockSize();
    byte input[inputLength];
    byte output[inputLength];

    EXPECT_THROW_MSG(mode.encrypt(input, output, inputLength), CryptoppApi::Exception, &quot;a key is required&quot;);
    EXPECT_THROW_MSG(mode.decrypt(input, output, inputLength), CryptoppApi::Exception, &quot;a key is required&quot;);
}

TEST(SymmetricModeEcbTest, keyNotMatchingUnderlyingOne) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeEcb mode1(&amp;cipher);
    CryptoppApi::SymmetricModeEcb mode2(&amp;cipher);</B></FONT>

    std::string key1(&quot;1234567890123456&quot;);
    std::string key2(&quot;azertyuiopqwerty&quot;);
    std::string key3(&quot;wxcvbnqsdfghjklm&quot;);
    mode1.setKey(reinterpret_cast&lt;const byte*&gt;(key1.c_str()), key1.length());

    size_t inputLength = mode1.getBlockSize();
    byte input[inputLength];
    byte output[inputLength];

    mode2.setKey(reinterpret_cast&lt;const byte*&gt;(key2.c_str()), key2.length());
    EXPECT_THROW_MSG(mode1.encrypt(input, output, inputLength), CryptoppApi::Exception, &quot;key is not matching the one owned by the underlying cipher object&quot;);

    cipher.setKey(reinterpret_cast&lt;const byte*&gt;(key3.c_str()), key3.length());
    EXPECT_THROW_MSG(mode1.encrypt(input, output, inputLength), CryptoppApi::Exception, &quot;key is not matching the one owned by the underlying cipher object&quot;);
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_api_symmetric_mode_ctr.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * This file is part of cryptopp-bindings-api.
 *
 * (c) Stephen Berquet &lt;stephen.berquet@gmail.com&gt;
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

#include &quot;src/exception/api_exception.h&quot;
#include &quot;src/symmetric/cipher/block/api_block_cipher_aes.h&quot;
#include &quot;src/symmetric/mode/api_symmetric_mode_ctr.h&quot;
#include &quot;src/utils/api_hex_utils.h&quot;
<A NAME="0"></A>#include &quot;tests/test_api_assertions.h&quot;
#include &lt;gtest/gtest.h&gt;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#0',2,'match49-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>TEST(SymmetricModeCtrTest, inheritance) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricCipherInterface*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricTransformationInterface*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricModeInterface*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricModeAbstract*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricKeyAbstract*&gt;(&amp;mode));
    EXPECT_TRUE(0 != dynamic_cast&lt;CryptoppApi::SymmetricIvAbstract*&gt;(&amp;mode));
}

TEST(SymmetricModeCtrTest, infos) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    EXPECT_STREQ(&quot;ctr(aes)&quot;, mode.getName());
    EXPECT_EQ(1, mode.getBlockSize());
}

TEST(SymmetricModeCtrTest, isValidKeyLength) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    EXPECT_TRUE(mode.isValidKeyLength(16));
    EXPECT_FALSE(mode.isValidKeyLength(15));
    EXPECT_FALSE(mode.isValidKeyLength(17));

    EXPECT_TRUE(mode.isValidKeyLength(24));
    EXPECT_FALSE(mode.isValidKeyLength(23));
    EXPECT_FALSE(mode.isValidKeyLength(25));

    EXPECT_TRUE(mode.isValidKeyLength(32));
    EXPECT_FALSE(mode.isValidKeyLength(31));
    EXPECT_FALSE(mode.isValidKeyLength(33));
}

TEST(SymmetricModeCtrTest, isValidIvLength) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    EXPECT_TRUE(mode.isValidIvLength(16));
    EXPECT_FALSE(mode.isValidKeyLength(15));
    EXPECT_FALSE(mode.isValidKeyLength(17));
}

TEST(SymmetricModeCtrTest, setGetKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    // build keys
    byte *key128;
    byte *key192;
    byte *key256;
    size_t key128Length = 0;
    size_t key192Length = 0;
    size_t key256Length = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;0102030405060708090a0b0c0d0e0f10&quot;, 32, &amp;key128, key128Length);
    CryptoppApi::HexUtils::hex2bin(&quot;0102030405060708090a0b0c0d0e0f101112131415161718&quot;, 48, &amp;key192, key192Length);
    CryptoppApi::HexUtils::hex2bin(&quot;0102030405060708090a0b0c0d0e0f1011121314151617181901020304050607&quot;, 64, &amp;key256, key256Length);

    // set/get keys
    size_t key0Length = mode.getKeyLength();

    mode.setKey(key128, key128Length);
    size_t key128GetLength = mode.getKeyLength();
    byte key128Get[key128GetLength];
    mode.getKey(key128Get);

    mode.setKey(key192, key192Length);
    size_t key192GetLength = mode.getKeyLength();
    byte key192Get[key192GetLength];
    mode.getKey(key192Get);

    mode.setKey(key256, key256Length);
    size_t key256GetLength = mode.getKeyLength();
    byte key256Get[key256GetLength];
    mode.getKey(key256Get);

    // test keys
    EXPECT_EQ(0, key0Length);
    EXPECT_BYTE_ARRAY_EQ(key128, key128Length, key128Get, key128GetLength);
    EXPECT_BYTE_ARRAY_EQ(key192, key192Length, key192Get, key192GetLength);
    EXPECT_BYTE_ARRAY_EQ(key256, key256Length, key256Get, key256GetLength);

    delete[] key128;
    delete[] key192;
    delete[] key256;
}

TEST(SymmetricModeCtrTest, setGetIv) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    // build iv
    byte *iv;
    size_t ivLength = 0;</B></FONT>
    CryptoppApi::HexUtils::hex2bin(&quot;0102030405060708090a0b0c0d0e0f10&quot;, 32, &amp;iv, ivLength);

    // set/get iv
    size_t iv0Length = mode.getIvLength();

    mode.setIv(iv, ivLength);
    size_t ivGetLength = mode.getIvLength();
    byte ivGet[ivGetLength];
    mode.getIv(ivGet);

    // test ivs
    EXPECT_EQ(0, iv0Length);
    EXPECT_BYTE_ARRAY_EQ(iv, ivLength, ivGet, ivGetLength);

    delete[] iv;
}

TEST(SymmetricModeCtrTest, encrypt) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);
    size_t dataSize = 32;

    byte output1[dataSize];
    byte output2[dataSize];
    byte *expected1;
    byte *expected2;

    // build keys
    byte *key128;
    byte *key192;
    byte *key256;
    size_t key128Length = 0;
<A NAME="2"></A>    size_t key192Length = 0;
    size_t key256Length = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key128, key128Length);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#2',2,'match49-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CryptoppApi::HexUtils::hex2bin(&quot;8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b&quot;, 48, &amp;key192, key192Length);
    CryptoppApi::HexUtils::hex2bin(&quot;603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4&quot;, 64, &amp;key256, key256Length);

    // build iv
    byte *iv;
    size_t ivLength;
    CryptoppApi::HexUtils::hex2bin(&quot;f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff&quot;, 32, &amp;iv, ivLength);
    mode.setIv(iv, ivLength);

    // build blocks
    byte *block1;
    byte *block2;
    size_t dummyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;30c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710&quot;, 64, &amp;block2, dummyLength);

    // aes128
    CryptoppApi::HexUtils::hex2bin(&quot;874d6191b620e3261bef6864990db6ce9806f66b7970fdff8617187bb9fffdff&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;5ae4df3edbd5d35e5b4f09020db03eab1e031dda2fbe03d1792170a0f3009cee&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key128, key128Length);
    mode.encrypt(block1, output1, dataSize);
    mode.encrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    // aes192
    CryptoppApi::HexUtils::hex2bin(&quot;1abc932417521ca24f2b0459fe7e6e0b090339ec0aa6faefd5ccc2c6f4ce8e94&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;1e36b26bd1ebc670d1bd1d665620abf74f78a7f6d29809585a97daec58c6b050&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key192, key192Length);
    mode.encrypt(block1, output1, dataSize);
    mode.encrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    // aes256
    CryptoppApi::HexUtils::hex2bin(&quot;601ec313775789a5b7a7f504bbf3d228f443e3ca4d62b59aca84e990cacaf5c5&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;2b0930daa23de94ce87017ba2d84988ddfc9c58db67aada613c2dd08457941a6&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key256, key256Length);
    mode.encrypt(block1, output1, dataSize);
    mode.encrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    delete[] iv;
    delete[] key128;
    delete[] key192;
    delete[] key256;
    delete[] block1;</B></FONT>
    delete[] block2;
}

TEST(SymmetricModeCtrTest, decrypt) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);
    size_t dataSize = 32;

    byte output1[dataSize];
    byte output2[dataSize];
    byte *block1;
    byte *block2;

    // build keys
    byte *key128;
    byte *key192;
    byte *key256;
    size_t key128Length = 0;
<A NAME="1"></A>    size_t key192Length = 0;
    size_t key256Length = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key128, key128Length);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#1',2,'match49-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CryptoppApi::HexUtils::hex2bin(&quot;8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b&quot;, 48, &amp;key192, key192Length);
    CryptoppApi::HexUtils::hex2bin(&quot;603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4&quot;, 64, &amp;key256, key256Length);

    // build iv
    byte *iv;
    size_t ivLength;
    CryptoppApi::HexUtils::hex2bin(&quot;f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff&quot;, 32, &amp;iv, ivLength);
    mode.setIv(iv, ivLength);

    // build expected data
    byte *expected1;
    byte *expected2;
    size_t dummyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;30c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710&quot;, 64, &amp;expected2, dummyLength);

    // aes128
    CryptoppApi::HexUtils::hex2bin(&quot;874d6191b620e3261bef6864990db6ce9806f66b7970fdff8617187bb9fffdff&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;5ae4df3edbd5d35e5b4f09020db03eab1e031dda2fbe03d1792170a0f3009cee&quot;, 64, &amp;block2, dummyLength);
    mode.setKey(key128, key128Length);
    mode.decrypt(block1, output1, dataSize);
    mode.decrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] block1;
    delete[] block2;

    // aes192
    CryptoppApi::HexUtils::hex2bin(&quot;1abc932417521ca24f2b0459fe7e6e0b090339ec0aa6faefd5ccc2c6f4ce8e94&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;1e36b26bd1ebc670d1bd1d665620abf74f78a7f6d29809585a97daec58c6b050&quot;, 64, &amp;block2, dummyLength);
    mode.setKey(key192, key192Length);
    mode.decrypt(block1, output1, dataSize);
    mode.decrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] block1;
    delete[] block2;

    // aes256
    CryptoppApi::HexUtils::hex2bin(&quot;601ec313775789a5b7a7f504bbf3d228f443e3ca4d62b59aca84e990cacaf5c5&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;2b0930daa23de94ce87017ba2d84988ddfc9c58db67aada613c2dd08457941a6&quot;, 64, &amp;block2, dummyLength);
    mode.setKey(key256, key256Length);
    mode.decrypt(block1, output1, dataSize);
    mode.decrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] block1;
    delete[] block2;

    delete[] iv;
    delete[] key128;
    delete[] key192;
    delete[] key256;
    delete[] expected1;</B></FONT>
    delete[] expected2;
}

TEST(SymmetricModeCtrTest, restartEncryption) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);
    size_t dataSize = 32;

    byte output1[dataSize];
    byte output2[dataSize];
    byte *expected1;
    byte *expected2;

    // build key
    byte *key;
    size_t keyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

<A NAME="5"></A>    // build iv
    byte *iv;
    size_t ivLength;
<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#5',2,'match49-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CryptoppApi::HexUtils::hex2bin(&quot;f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff&quot;, 32, &amp;iv, ivLength);
    mode.setIv(iv, ivLength);

    // build blocks
    byte *block1;
    byte *block2;
    size_t dummyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;30c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710&quot;, 64, &amp;block2, dummyLength);

    // calculate actual data
    CryptoppApi::HexUtils::hex2bin(&quot;874d6191b620e3261bef6864990db6ce9806f66b7970fdff8617187bb9fffdff&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;dc44c3353b3c98a11729d76cf094f30bc0b45879b83cca74b58b36ac1a3c44be&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key, keyLength);
    mode.encrypt(block1, output1, dataSize);
    mode.restart();
    mode.encrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    delete[] key;
    delete[] iv;
    delete[] block1;</B></FONT>
    delete[] block2;
}

TEST(SymmetricModeCtrTest, restartDecryption) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);
    size_t dataSize = 32;

    byte output1[dataSize];
    byte output2[dataSize];
    byte *expected1;
    byte *expected2;

    // build key
    byte *key;
    size_t keyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;2b7e151628aed2a6abf7158809cf4f3c&quot;, 32, &amp;key, keyLength);

<A NAME="4"></A>    // build iv
    byte *iv;
    size_t ivLength;
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#4',2,'match49-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CryptoppApi::HexUtils::hex2bin(&quot;f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff&quot;, 32, &amp;iv, ivLength);
    mode.setIv(iv, ivLength);

    // build blocks
    byte *block1;
    byte *block2;
    size_t dummyLength = 0;
    CryptoppApi::HexUtils::hex2bin(&quot;874d6191b620e3261bef6864990db6ce9806f66b7970fdff8617187bb9fffdff&quot;, 64, &amp;block1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;5ae4df3edbd5d35e5b4f09020db03eab1e031dda2fbe03d1792170a0f3009cee&quot;, 64, &amp;block2, dummyLength);

    // calculate actual data
    CryptoppApi::HexUtils::hex2bin(&quot;6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51&quot;, 64, &amp;expected1, dummyLength);
    CryptoppApi::HexUtils::hex2bin(&quot;b668004d43b5afeea99d1f77e72e9f4f282861e648cd52b2618107770f50ef40&quot;, 64, &amp;expected2, dummyLength);
    mode.setKey(key, keyLength);
    mode.decrypt(block1, output1, dataSize);
    mode.restart();
    mode.decrypt(block2, output2, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected1, dataSize, output1, dataSize);
    EXPECT_BYTE_ARRAY_EQ(expected2, dataSize, output2, dataSize);

    delete[] expected1;
    delete[] expected2;

    delete[] key;
    delete[] iv;
    delete[] block1;</B></FONT>
    delete[] block2;
}

TEST(SymmetricModeCtrTest, largeData) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

<A NAME="6"></A>    std::string key(&quot;1234567890123456&quot;);
    std::string iv(&quot;1234567890123456&quot;);
    mode.setKey(reinterpret_cast&lt;const byte*&gt;(key.c_str()), key.length());
<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#6',2,'match49-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    mode.setIv(reinterpret_cast&lt;const byte*&gt;(iv.c_str()), iv.length());

    size_t dataSize = 10485760;
    byte *input     = new byte[dataSize];
    byte *output    = new byte[dataSize];
    memset(input, 125, dataSize);
    mode.encrypt(input, output, dataSize);
    mode.decrypt(input, output, dataSize);

    delete[] input;
    delete[] output;
}

TEST(SymmetricModeCtrTest, isStream) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    std::string key(&quot;1234567890123456&quot;);</B></FONT>
    std::string iv(&quot;1234567890123456&quot;);
    mode.setKey(reinterpret_cast&lt;const byte*&gt;(key.c_str()), key.length());
    mode.setIv(reinterpret_cast&lt;const byte*&gt;(iv.c_str()), iv.length());

    std::string dataStr(&quot;12345678901234567&quot;);
    const byte *data    = reinterpret_cast&lt;const byte*&gt;(dataStr.c_str());
    size_t dataLength   = dataStr.length();
    byte output[dataLength];
<A NAME="3"></A>
    mode.encrypt(data, output, dataLength);
    mode.decrypt(data, output, dataLength);
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#3',2,'match49-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

TEST(SymmetricModeCtrTest, invalidKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    byte key1[] = {45, 12, 14};
    byte key2[0];

    EXPECT_THROW_MSG(mode.setKey(key1, 3), CryptoppApi::Exception, &quot;3 is not a valid key length&quot;);
    EXPECT_THROW_MSG(mode.setKey(key2, 0), CryptoppApi::Exception, &quot;a key is required&quot;);
}

TEST(SymmetricModeCtrTest, invalidIv) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    byte iv1[] = {45, 12, 14};
    byte iv2[0];
<A NAME="7"></A>
    EXPECT_THROW_MSG(mode.setIv(iv1, 3), CryptoppApi::Exception, &quot;3 is not a valid initialization vector length&quot;);</B></FONT>
    EXPECT_THROW_MSG(mode.setIv(iv2, 0), CryptoppApi::Exception, &quot;an initialization vector is required&quot;);
<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#7',2,'match49-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

TEST(SymmetricModeCtrTest, cryptWithoutKey) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    size_t inputLength = mode.getBlockSize();
    byte input[inputLength];
    byte output[inputLength];

    EXPECT_THROW_MSG(mode.encrypt(input, output, inputLength), CryptoppApi::Exception, &quot;a key is required&quot;);
    EXPECT_THROW_MSG(mode.decrypt(input, output, inputLength), CryptoppApi::Exception, &quot;a key is required&quot;);
}

TEST(SymmetricModeCtrTest, cryptWithoutIv) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode(&amp;cipher);

    std::string key(&quot;1234567890123456&quot;);</B></FONT>
    mode.setKey(reinterpret_cast&lt;const byte*&gt;(key.c_str()), key.length());

    size_t inputLength = mode.getBlockSize();
    byte input[inputLength];
    byte output[inputLength];

    EXPECT_THROW_MSG(mode.encrypt(input, output, inputLength), CryptoppApi::Exception, &quot;an initialization vector is required&quot;);
    EXPECT_THROW_MSG(mode.decrypt(input, output, inputLength), CryptoppApi::Exception, &quot;an initialization vector is required&quot;);
}

TEST(SymmetricModeCtrTest, keyNotMatchingUnderlyingOne) {
    CryptoppApi::BlockCipherAes cipher;
    CryptoppApi::SymmetricModeCtr mode1(&amp;cipher);
    CryptoppApi::SymmetricModeCtr mode2(&amp;cipher);

    std::string iv(&quot;1234567890123456&quot;);
    mode1.setIv(reinterpret_cast&lt;const byte*&gt;(iv.c_str()), iv.length());

    std::string key1(&quot;1234567890123456&quot;);
    std::string key2(&quot;azertyuiopqwerty&quot;);
    std::string key3(&quot;wxcvbnqsdfghjklm&quot;);
    mode1.setKey(reinterpret_cast&lt;const byte*&gt;(key1.c_str()), key1.length());

    size_t inputLength = mode1.getBlockSize();
    byte input[inputLength];
    byte output[inputLength];

    mode2.setKey(reinterpret_cast&lt;const byte*&gt;(key2.c_str()), key2.length());
    EXPECT_THROW_MSG(mode1.encrypt(input, output, inputLength), CryptoppApi::Exception, &quot;key is not matching the one owned by the underlying cipher object&quot;);

    cipher.setKey(reinterpret_cast&lt;const byte*&gt;(key3.c_str()), key3.length());
    EXPECT_THROW_MSG(mode1.encrypt(input, output, inputLength), CryptoppApi::Exception, &quot;key is not matching the one owned by the underlying cipher object&quot;);
}
</PRE>
</div>
  </div>
</body>
</html>
