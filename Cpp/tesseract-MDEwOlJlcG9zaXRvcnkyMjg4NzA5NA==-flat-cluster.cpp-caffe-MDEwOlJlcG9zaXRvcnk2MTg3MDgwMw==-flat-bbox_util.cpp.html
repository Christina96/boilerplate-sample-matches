
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.47425422762683%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cluster.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #include "cluster.h"
3  #include "genericheap.h"
4  #include "kdpair.h"
5  #include "matrix.h"
6  #include "tprintf.h"
7  #include "helpers.h"
8  #include <cfloat> 
9  #include <cmath>  
10  #include <vector> 
11  namespace tesseract {
12  #define HOTELLING 1  
13  #define FTABLE_X 10  
14  #define FTABLE_Y 100 
15  const double FTable[FTABLE_Y][FTABLE_X] = {
16      {
17          4052.19,
18          4999.52,
19          5403.34,
20          5624.62,
21          5763.65,
22          5858.97,
23          5928.33,
24          5981.10,
25          6022.50,
26          6055.85,
27      },
28      {
29          98.502,
30          99.000,
31          99.166,
32          99.249,
33          99.300,
34          99.333,
35          99.356,
36          99.374,
37          99.388,
38          99.399,
39      },
40      {
41          34.116,
42          30.816,
43          29.457,
44          28.710,
45          28.237,
46          27.911,
47          27.672,
48          27.489,
49          27.345,
50          27.229,
51      },
52      {
53          21.198,
54          18.000,
55          16.694,
56          15.977,
57          15.522,
58          15.207,
59          14.976,
60          14.799,
61          14.659,
62          14.546,
63      },
64      {
65          16.258,
66          13.274,
67          12.060,
68          11.392,
69          10.967,
70          10.672,
71          10.456,
72          10.289,
73          10.158,
74          10.051,
75      },
76      {
77          13.745,
78          10.925,
79          9.780,
80          9.148,
81          8.746,
82          8.466,
83          8.260,
84          8.102,
85          7.976,
86          7.874,
87      },
88      {
89          12.246,
90          9.547,
91          8.451,
92          7.847,
93          7.460,
94          7.191,
95          6.993,
96          6.840,
97          6.719,
98          6.620,
99      },
100      {
101          11.259,
102          8.649,
103          7.591,
104          7.006,
105          6.632,
106          6.371,
107          6.178,
108          6.029,
109          5.911,
110          5.814,
111      },
112      {
113          10.561,
114          8.022,
115          6.992,
116          6.422,
117          6.057,
118          5.802,
119          5.613,
120          5.467,
121          5.351,
122          5.257,
123      },
124      {
125          10.044,
126          7.559,
127          6.552,
128          5.994,
129          5.636,
130          5.386,
131          5.200,
132          5.057,
133          4.942,
134          4.849,
135      },
136      {
137          9.646,
138          7.206,
139          6.217,
140          5.668,
141          5.316,
142          5.069,
143          4.886,
144          4.744,
145          4.632,
146          4.539,
147      },
148      {
149          9.330,
150          6.927,
151          5.953,
152          5.412,
153          5.064,
154          4.821,
155          4.640,
156          4.499,
157          4.388,
158          4.296,
159      },
160      {
161          9.074,
162          6.701,
163          5.739,
164          5.205,
165          4.862,
166          4.620,
167          4.441,
168          4.302,
169          4.191,
170          4.100,
171      },
172      {
173          8.862,
174          6.515,
175          5.564,
176          5.035,
177          4.695,
178          4.456,
179          4.278,
180          4.140,
181          4.030,
182          3.939,
183      },
184      {
185          8.683,
186          6.359,
187          5.417,
188          4.893,
189          4.556,
190          4.318,
191          4.142,
192          4.004,
193          3.895,
194          3.805,
195      },
196      {
197          8.531,
198          6.226,
199          5.292,
200          4.773,
201          4.437,
202          4.202,
203          4.026,
204          3.890,
205          3.780,
206          3.691,
207      },
208      {
209          8.400,
210          6.112,
211          5.185,
212          4.669,
213          4.336,
214          4.102,
215          3.927,
216          3.791,
217          3.682,
218          3.593,
219      },
220      {
221          8.285,
222          6.013,
223          5.092,
224          4.579,
225          4.248,
226          4.015,
227          3.841,
228          3.705,
229          3.597,
230          3.508,
231      },
232      {
233          8.185,
234          5.926,
235          5.010,
236          4.500,
237          4.171,
238          3.939,
239          3.765,
240          3.631,
241          3.523,
242          3.434,
243      },
244      {
245          8.096,
246          5.849,
247          4.938,
248          4.431,
249          4.103,
250          3.871,
251          3.699,
252          3.564,
253          3.457,
254          3.368,
255      },
256      {
257          8.017,
258          5.780,
259          4.874,
260          4.369,
261          4.042,
262          3.812,
263          3.640,
264          3.506,
265          3.398,
266          3.310,
267      },
268      {
269          7.945,
270          5.719,
271          4.817,
272          4.313,
273          3.988,
274          3.758,
275          3.587,
276          3.453,
277          3.346,
278          3.258,
279      },
280      {
281          7.881,
282          5.664,
283          4.765,
284          4.264,
285          3.939,
286          3.710,
287          3.539,
288          3.406,
289          3.299,
290          3.211,
291      },
292      {
293          7.823,
294          5.614,
295          4.718,
296          4.218,
297          3.895,
298          3.667,
299          3.496,
300          3.363,
301          3.256,
302          3.168,
303      },
304      {
305          7.770,
306          5.568,
307          4.675,
308          4.177,
309          3.855,
310          3.627,
311          3.457,
312          3.324,
313          3.217,
314          3.129,
315      },
316      {
317          7.721,
318          5.526,
319          4.637,
320          4.140,
321          3.818,
322          3.591,
323          3.421,
324          3.288,
325          3.182,
326          3.094,
327      },
328      {
329          7.677,
330          5.488,
331          4.601,
332          4.106,
333          3.785,
334          3.558,
335          3.388,
336          3.256,
337          3.149,
338          3.062,
339      },
340      {
341          7.636,
342          5.453,
343          4.568,
344          4.074,
345          3.754,
346          3.528,
347          3.358,
348          3.226,
349          3.120,
350          3.032,
351      },
352      {
353          7.598,
354          5.420,
355          4.538,
356          4.045,
357          3.725,
358          3.499,
359          3.330,
360          3.198,
361          3.092,
362          3.005,
363      },
364      {
365          7.562,
366          5.390,
367          4.510,
368          4.018,
369          3.699,
370          3.473,
371          3.305,
372          3.173,
373          3.067,
374          2.979,
375      },
376      {
377          7.530,
378          5.362,
379          4.484,
380          3.993,
381          3.675,
382          3.449,
383          3.281,
384          3.149,
385          3.043,
386          2.955,
387      },
388      {
389          7.499,
390          5.336,
391          4.459,
392          3.969,
393          3.652,
394          3.427,
395          3.258,
396          3.127,
397          3.021,
398          2.934,
399      },
400      {
401          7.471,
402          5.312,
403          4.437,
404          3.948,
405          3.630,
406          3.406,
407          3.238,
408          3.106,
409          3.000,
410          2.913,
411      },
412      {
413          7.444,
414          5.289,
415          4.416,
416          3.927,
417          3.611,
418          3.386,
419          3.218,
420          3.087,
421          2.981,
422          2.894,
423      },
424      {
425          7.419,
426          5.268,
427          4.396,
428          3.908,
429          3.592,
430          3.368,
431          3.200,
432          3.069,
433          2.963,
434          2.876,
435      },
436      {
437          7.396,
438          5.248,
439          4.377,
440          3.890,
441          3.574,
442          3.351,
443          3.183,
444          3.052,
445          2.946,
446          2.859,
447      },
448      {
449          7.373,
450          5.229,
451          4.360,
452          3.873,
453          3.558,
454          3.334,
455          3.167,
456          3.036,
457          2.930,
458          2.843,
459      },
460      {
461          7.353,
462          5.211,
463          4.343,
464          3.858,
465          3.542,
466          3.319,
467          3.152,
468          3.021,
469          2.915,
470          2.828,
471      },
472      {
473          7.333,
474          5.194,
475          4.327,
476          3.843,
477          3.528,
478          3.305,
479          3.137,
480          3.006,
481          2.901,
482          2.814,
483      },
484      {
485          7.314,
486          5.179,
487          4.313,
488          3.828,
489          3.514,
490          3.291,
491          3.124,
492          2.993,
493          2.888,
494          2.801,
495      },
496      {
497          7.296,
498          5.163,
499          4.299,
500          3.815,
501          3.501,
502          3.278,
503          3.111,
504          2.980,
505          2.875,
506          2.788,
507      },
508      {
509          7.280,
510          5.149,
511          4.285,
512          3.802,
513          3.488,
514          3.266,
515          3.099,
516          2.968,
517          2.863,
518          2.776,
519      },
520      {
521          7.264,
522          5.136,
523          4.273,
524          3.790,
525          3.476,
526          3.254,
527          3.087,
528          2.957,
529          2.851,
530          2.764,
531      },
532      {
533          7.248,
534          5.123,
535          4.261,
536          3.778,
537          3.465,
538          3.243,
539          3.076,
540          2.946,
541          2.840,
542          2.754,
543      },
544      {
545          7.234,
546          5.110,
547          4.249,
548          3.767,
549          3.454,
550          3.232,
551          3.066,
552          2.935,
553          2.830,
554          2.743,
555      },
556      {
557          7.220,
558          5.099,
559          4.238,
560          3.757,
561          3.444,
562          3.222,
563          3.056,
564          2.925,
565          2.820,
566          2.733,
567      },
568      {
569          7.207,
570          5.087,
571          4.228,
572          3.747,
573          3.434,
574          3.213,
575          3.046,
576          2.916,
577          2.811,
578          2.724,
579      },
580      {
581          7.194,
582          5.077,
583          4.218,
584          3.737,
585          3.425,
586          3.204,
587          3.037,
588          2.907,
589          2.802,
590          2.715,
591      },
592      {
593          7.182,
594          5.066,
595          4.208,
596          3.728,
597          3.416,
598          3.195,
599          3.028,
600          2.898,
601          2.793,
602          2.706,
603      },
604      {
605          7.171,
606          5.057,
607          4.199,
608          3.720,
609          3.408,
610          3.186,
611          3.020,
612          2.890,
613          2.785,
614          2.698,
615      },
616      {
617          7.159,
618          5.047,
619          4.191,
620          3.711,
621          3.400,
622          3.178,
623          3.012,
624          2.882,
625          2.777,
626          2.690,
627      },
628      {
629          7.149,
630          5.038,
631          4.182,
632          3.703,
633          3.392,
634          3.171,
635          3.005,
636          2.874,
637          2.769,
638          2.683,
639      },
640      {
641          7.139,
642          5.030,
643          4.174,
644          3.695,
645          3.384,
646          3.163,
647          2.997,
648          2.867,
649          2.762,
650          2.675,
651      },
652      {
653          7.129,
654          5.021,
655          4.167,
656          3.688,
657          3.377,
658          3.156,
659          2.990,
660          2.860,
661          2.755,
662          2.668,
663      },
664      {
665          7.119,
666          5.013,
667          4.159,
668          3.681,
669          3.370,
670          3.149,
671          2.983,
672          2.853,
673          2.748,
674          2.662,
675      },
676      {
677          7.110,
678          5.006,
679          4.152,
680          3.674,
681          3.363,
682          3.143,
683          2.977,
684          2.847,
685          2.742,
686          2.655,
687      },
688      {
689          7.102,
690          4.998,
691          4.145,
692          3.667,
693          3.357,
694          3.136,
695          2.971,
696          2.841,
697          2.736,
698          2.649,
699      },
700      {
701          7.093,
702          4.991,
703          4.138,
704          3.661,
705          3.351,
706          3.130,
707          2.965,
708          2.835,
709          2.730,
710          2.643,
711      },
712      {
713          7.085,
714          4.984,
715          4.132,
716          3.655,
717          3.345,
718          3.124,
719          2.959,
720          2.829,
721          2.724,
722          2.637,
723      },
724      {
725          7.077,
726          4.977,
727          4.126,
728          3.649,
729          3.339,
730          3.119,
731          2.953,
732          2.823,
733          2.718,
734          2.632,
735      },
736      {
737          7.070,
738          4.971,
739          4.120,
740          3.643,
741          3.333,
742          3.113,
743          2.948,
744          2.818,
745          2.713,
746          2.626,
747      },
748      {
749          7.062,
750          4.965,
751          4.114,
752          3.638,
753          3.328,
754          3.108,
755          2.942,
756          2.813,
757          2.708,
758          2.621,
759      },
760      {
761          7.055,
762          4.959,
763          4.109,
764          3.632,
765          3.323,
766          3.103,
767          2.937,
768          2.808,
769          2.703,
770          2.616,
771      },
772      {
773          7.048,
774          4.953,
775          4.103,
776          3.627,
777          3.318,
778          3.098,
779          2.932,
780          2.803,
781          2.698,
782          2.611,
783      },
784      {
785          7.042,
786          4.947,
787          4.098,
788          3.622,
789          3.313,
790          3.093,
791          2.928,
792          2.798,
793          2.693,
794          2.607,
795      },
796      {
797          7.035,
798          4.942,
799          4.093,
800          3.618,
801          3.308,
802          3.088,
803          2.923,
804          2.793,
805          2.689,
806          2.602,
807      },
808      {
809          7.029,
810          4.937,
811          4.088,
812          3.613,
813          3.304,
814          3.084,
815          2.919,
816          2.789,
817          2.684,
818          2.598,
819      },
820      {
821          7.023,
822          4.932,
823          4.083,
824          3.608,
825          3.299,
826          3.080,
827          2.914,
828          2.785,
829          2.680,
830          2.593,
831      },
832      {
833          7.017,
834          4.927,
835          4.079,
836          3.604,
837          3.295,
838          3.075,
839          2.910,
840          2.781,
841          2.676,
842          2.589,
843      },
844      {
845          7.011,
846          4.922,
847          4.074,
848          3.600,
849          3.291,
850          3.071,
851          2.906,
852          2.777,
853          2.672,
854          2.585,
855      },
856      {
857          7.006,
858          4.917,
859          4.070,
860          3.596,
861          3.287,
862          3.067,
863          2.902,
864          2.773,
865          2.668,
866          2.581,
867      },
868      {
869          7.001,
870          4.913,
871          4.066,
872          3.591,
873          3.283,
874          3.063,
875          2.898,
876          2.769,
877          2.664,
878          2.578,
879      },
880      {
881          6.995,
882          4.908,
883          4.062,
884          3.588,
885          3.279,
886          3.060,
887          2.895,
888          2.765,
889          2.660,
890          2.574,
891      },
892      {
893          6.990,
894          4.904,
895          4.058,
896          3.584,
897          3.275,
898          3.056,
899          2.891,
900          2.762,
901          2.657,
902          2.570,
903      },
904      {
905          6.985,
906          4.900,
907          4.054,
908          3.580,
909          3.272,
910          3.052,
911          2.887,
912          2.758,
913          2.653,
914          2.567,
915      },
916      {
917          6.981,
918          4.896,
919          4.050,
920          3.577,
921          3.268,
922          3.049,
923          2.884,
924          2.755,
925          2.650,
926          2.563,
927      },
928      {
929          6.976,
930          4.892,
931          4.047,
932          3.573,
933          3.265,
934          3.046,
935          2.881,
936          2.751,
937          2.647,
938          2.560,
939      },
940      {
941          6.971,
942          4.888,
943          4.043,
944          3.570,
945          3.261,
946          3.042,
947          2.877,
948          2.748,
949          2.644,
950          2.557,
951      },
952      {
953          6.967,
954          4.884,
955          4.040,
956          3.566,
957          3.258,
958          3.039,
959          2.874,
960          2.745,
961          2.640,
962          2.554,
963      },
964      {
965          6.963,
966          4.881,
967          4.036,
968          3.563,
969          3.255,
970          3.036,
971          2.871,
972          2.742,
973          2.637,
974          2.551,
975      },
976      {
977          6.958,
978          4.877,
979          4.033,
980          3.560,
981          3.252,
982          3.033,
983          2.868,
984          2.739,
985          2.634,
986          2.548,
987      },
988      {
989          6.954,
990          4.874,
991          4.030,
992          3.557,
993          3.249,
994          3.030,
995          2.865,
996          2.736,
997          2.632,
998          2.545,
999      },
1000      {
1001          6.950,
1002          4.870,
1003          4.027,
1004          3.554,
1005          3.246,
1006          3.027,
1007          2.863,
1008          2.733,
1009          2.629,
1010          2.542,
1011      },
1012      {
1013          6.947,
1014          4.867,
1015          4.024,
1016          3.551,
1017          3.243,
1018          3.025,
1019          2.860,
1020          2.731,
1021          2.626,
1022          2.539,
1023      },
1024      {
1025          6.943,
1026          4.864,
1027          4.021,
1028          3.548,
1029          3.240,
1030          3.022,
1031          2.857,
1032          2.728,
1033          2.623,
1034          2.537,
1035      },
1036      {
1037          6.939,
1038          4.861,
1039          4.018,
1040          3.545,
1041          3.238,
1042          3.019,
1043          2.854,
1044          2.725,
1045          2.621,
1046          2.534,
1047      },
1048      {
1049          6.935,
1050          4.858,
1051          4.015,
1052          3.543,
1053          3.235,
1054          3.017,
1055          2.852,
1056          2.723,
1057          2.618,
1058          2.532,
1059      },
1060      {
1061          6.932,
1062          4.855,
1063          4.012,
1064          3.540,
1065          3.233,
1066          3.014,
1067          2.849,
1068          2.720,
1069          2.616,
1070          2.529,
1071      },
1072      {
1073          6.928,
1074          4.852,
1075          4.010,
1076          3.538,
1077          3.230,
1078          3.012,
1079          2.847,
1080          2.718,
1081          2.613,
1082          2.527,
1083      },
1084      {
1085          6.925,
1086          4.849,
1087          4.007,
1088          3.535,
1089          3.228,
1090          3.009,
1091          2.845,
1092          2.715,
1093          2.611,
1094          2.524,
1095      },
1096      {
1097          6.922,
1098          4.846,
1099          4.004,
1100          3.533,
1101          3.225,
1102          3.007,
1103          2.842,
1104          2.713,
1105          2.609,
1106          2.522,
1107      },
1108      {
1109          6.919,
1110          4.844,
1111          4.002,
1112          3.530,
1113          3.223,
1114          3.004,
1115          2.840,
1116          2.711,
1117          2.606,
1118          2.520,
1119      },
1120      {
1121          6.915,
1122          4.841,
1123          3.999,
1124          3.528,
1125          3.221,
1126          3.002,
1127          2.838,
1128          2.709,
1129          2.604,
1130          2.518,
1131      },
1132      {
1133          6.912,
1134          4.838,
1135          3.997,
1136          3.525,
1137          3.218,
1138          3.000,
1139          2.835,
1140          2.706,
1141          2.602,
1142          2.515,
1143      },
1144      {
1145          6.909,
1146          4.836,
1147          3.995,
1148          3.523,
1149          3.216,
1150          2.998,
1151          2.833,
1152          2.704,
1153          2.600,
1154          2.513,
1155      },
1156      {
1157          6.906,
1158          4.833,
1159          3.992,
1160          3.521,
1161          3.214,
1162          2.996,
1163          2.831,
1164          2.702,
1165          2.598,
1166          2.511,
1167      },
1168      {
1169          6.904,
1170          4.831,
1171          3.990,
1172          3.519,
1173          3.212,
1174          2.994,
1175          2.829,
1176          2.700,
1177          2.596,
1178          2.509,
1179      },
1180      {
1181          6.901,
1182          4.829,
1183          3.988,
1184          3.517,
1185          3.210,
1186          2.992,
1187          2.827,
1188          2.698,
1189          2.594,
1190          2.507,
1191      },
1192      {
1193          6.898,
1194          4.826,
1195          3.986,
1196          3.515,
1197          3.208,
1198          2.990,
1199          2.825,
1200          2.696,
1201          2.592,
1202          2.505,
1203      },
1204      {6.895, 4.824, 3.984, 3.513, 3.206, 2.988, 2.823, 2.694, 2.590, 2.503}};
1205  #define MINVARIANCE 0.0004
1206  #define MINSAMPLESPERBUCKET 5
1207  #define MINSAMPLES (MINBUCKETS * MINSAMPLESPERBUCKET)
1208  #define MINSAMPLESNEEDED 1
1209  #define BUCKETTABLESIZE 1024
1210  #define NORMALEXTENT 3.0
1211  struct TEMPCLUSTER {
1212    CLUSTER *Cluster;
1213    CLUSTER *Neighbor;
1214  };
1215  using ClusterPair = tesseract::KDPairInc<float, TEMPCLUSTER *>;
1216  using ClusterHeap = tesseract::GenericHeap<ClusterPair>;
1217  struct STATISTICS {
1218    STATISTICS(size_t n) : CoVariance(n * n), Min(n), Max(n) {
1219    }
1220    float AvgVariance = 1.0f;
1221    std::vector<float> CoVariance;
1222    std::vector<float> Min; 
1223    std::vector<float> Max; 
1224  };
1225  struct BUCKETS {
1226    BUCKETS(size_t n) : NumberOfBuckets(n), Count(n), ExpectedCount(n) {
1227    }
1228    ~BUCKETS() {
1229    }
1230    DISTRIBUTION Distribution = normal; 
1231    uint32_t SampleCount = 0;         
1232    double Confidence = 0.0;          
1233    double ChiSquared = 0.0;          
1234    uint16_t NumberOfBuckets;         
1235    uint16_t Bucket[BUCKETTABLESIZE]; 
1236    std::vector<uint32_t> Count;      
1237    std::vector<float> ExpectedCount; 
1238  };
1239  struct CHISTRUCT {
1240    CHISTRUCT(uint16_t degreesOfFreedom, double alpha) : DegreesOfFreedom(degreesOfFreedom), Alpha(alpha) {
1241    }
1242    uint16_t DegreesOfFreedom = 0;
1243    double Alpha = 0.0;
1244    double ChiSquared = 0.0;
1245  };
1246  struct ClusteringContext {
1247    ClusterHeap *heap;       
1248    TEMPCLUSTER *candidates; 
1249    KDTREE *tree;            
1250    int32_t next;            
1251  };
1252  using DENSITYFUNC = double (*)(int32_t);
1253  using SOLVEFUNC = double (*)(CHISTRUCT *, double);
1254  #define Odd(N) ((N) % 2)
1255  #define Mirror(N, R) ((R) - (N)-1)
1256  #define Abs(N) (((N) < 0) ? (-(N)) : (N))
1257  #define SqrtOf2Pi 2.506628275
1258  static const double kNormalStdDev = BUCKETTABLESIZE / (2.0 * NORMALEXTENT);
1259  static const double kNormalVariance =
1260      (BUCKETTABLESIZE * BUCKETTABLESIZE) / (4.0 * NORMALEXTENT * NORMALEXTENT);
1261  static const double kNormalMagnitude = (2.0 * NORMALEXTENT) / (SqrtOf2Pi * BUCKETTABLESIZE);
1262  static const double kNormalMean = BUCKETTABLESIZE / 2;
1263  #define LOOKUPTABLESIZE 8
1264  #define MAXDEGREESOFFREEDOM MAXBUCKETS
1265  static const uint32_t kCountTable[LOOKUPTABLESIZE] = {MINSAMPLES, 200,  400, 600, 800,
1266                                                        1000,       1500, 2000}; 
1267  static const uint16_t kBucketsTable[LOOKUPTABLESIZE] = {
1268      MINBUCKETS, 16, 20, 24, 27, 30, 35, MAXBUCKETS}; 
1269  static void CreateClusterTree(CLUSTERER *Clusterer);
1270  static void MakePotentialClusters(ClusteringContext *context, CLUSTER *Cluster, int32_t Level);
1271  static CLUSTER *FindNearestNeighbor(KDTREE *Tree, CLUSTER *Cluster, float *Distance);
1272  static CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster);
1273  static void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config);
1274  static PROTOTYPE *MakePrototype(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster);
1275  static PROTOTYPE *MakeDegenerateProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics,
1276                                        PROTOSTYLE Style, int32_t MinSamples);
1277  static PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster,
1278                                        STATISTICS *Statistics);
1279  static PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1280                                       BUCKETS *Buckets);
1281  static PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer, CLUSTER *Cluster,
1282                                        STATISTICS *Statistics, BUCKETS *Buckets);
1283  static PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1284                                   BUCKETS *NormalBuckets, double Confidence);
1285  static void MakeDimRandom(uint16_t i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc);
1286  static void MakeDimUniform(uint16_t i, PROTOTYPE *Proto, STATISTICS *Statistics);
1287  static STATISTICS *ComputeStatistics(int16_t N, PARAM_DESC ParamDesc[], CLUSTER *Cluster);
1288  static PROTOTYPE *NewSphericalProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1289  static PROTOTYPE *NewEllipticalProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1290  static PROTOTYPE *NewMixedProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1291  static PROTOTYPE *NewSimpleProto(int16_t N, CLUSTER *Cluster);
1292  static bool Independent(PARAM_DESC *ParamDesc, int16_t N, float *CoVariance, float Independence);
1293  static BUCKETS *GetBuckets(CLUSTERER *clusterer, DISTRIBUTION Distribution, uint32_t SampleCount,
1294                             double Confidence);
1295  static BUCKETS *MakeBuckets(DISTRIBUTION Distribution, uint32_t SampleCount, double Confidence);
1296  static uint16_t OptimumNumberOfBuckets(uint32_t SampleCount);
1297  static double ComputeChiSquared(uint16_t DegreesOfFreedom, double Alpha);
1298  static double NormalDensity(int32_t x);
1299  static double UniformDensity(int32_t x);
1300  static double Integral(double f1, double f2, double Dx);
1301  static void FillBuckets(BUCKETS *Buckets, CLUSTER *Cluster, uint16_t Dim, PARAM_DESC *ParamDesc,
1302                          float Mean, float StdDev);
1303  static uint16_t NormalBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev);
1304  static uint16_t UniformBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev);
1305  static bool DistributionOK(BUCKETS *Buckets);
1306  static uint16_t DegreesOfFreedom(DISTRIBUTION Distribution, uint16_t HistogramBuckets);
1307  static void AdjustBuckets(BUCKETS *Buckets, uint32_t NewSampleCount);
1308  static void InitBuckets(BUCKETS *Buckets);
1309  static int AlphaMatch(void *arg1,  
1310                        void *arg2); 
1311  static double Solve(SOLVEFUNC Function, void *FunctionParams, double InitialGuess, double Accuracy);
1312  static double ChiArea(CHISTRUCT *ChiParams, double x);
1313  static bool MultipleCharSamples(CLUSTERER *Clusterer, CLUSTER *Cluster, float MaxIllegal);
1314  static double InvertMatrix(const float *input, int size, float *inv);
1315  CLUSTERER *MakeClusterer(int16_t SampleSize, const PARAM_DESC ParamDesc[]) {
1316    int i;
1317    auto Clusterer = new CLUSTERER;
1318    Clusterer->SampleSize = SampleSize;
1319    Clusterer->NumberOfSamples = 0;
1320    Clusterer->NumChar = 0;
1321    Clusterer->Root = nullptr;
1322    Clusterer->ProtoList = NIL_LIST;
1323    Clusterer->ParamDesc = new PARAM_DESC[SampleSize];
1324    for (i = 0; i < SampleSize; i++) {
1325      Clusterer->ParamDesc[i].Circular = ParamDesc[i].Circular;
1326      Clusterer->ParamDesc[i].NonEssential = ParamDesc[i].NonEssential;
1327      Clusterer->ParamDesc[i].Min = ParamDesc[i].Min;
1328      Clusterer->ParamDesc[i].Max = ParamDesc[i].Max;
1329      Clusterer->ParamDesc[i].Range = ParamDesc[i].Max - ParamDesc[i].Min;
1330      Clusterer->ParamDesc[i].HalfRange = Clusterer->ParamDesc[i].Range / 2;
1331      Clusterer->ParamDesc[i].MidRange = (ParamDesc[i].Max + ParamDesc[i].Min) / 2;
1332    }
1333    Clusterer->KDTree = MakeKDTree(SampleSize, ParamDesc);
1334    for (auto &d : Clusterer->bucket_cache) {
1335      for (auto &c : d) {
1336        c = nullptr;
1337      }
1338    }
1339    return Clusterer;
1340  } 
1341  SAMPLE *MakeSample(CLUSTERER *Clusterer, const float *Feature, uint32_t CharID) {
1342    int i;
1343    ASSERT_HOST(Clusterer->Root == nullptr);
1344    auto Sample = new SAMPLE(Clusterer->SampleSize);
1345    Sample->Clustered = false;
1346    Sample->Prototype = false;
1347    Sample->SampleCount = 1;
1348    Sample->Left = nullptr;
1349    Sample->Right = nullptr;
1350    Sample->CharID = CharID;
1351    for (i = 0; i < Clusterer->SampleSize; i++) {
1352      Sample->Mean[i] = Feature[i];
1353    }
1354    Clusterer->NumberOfSamples++;
1355    KDStore(Clusterer->KDTree, &Sample->Mean[0], Sample);
1356    if (CharID >= Clusterer->NumChar) {
1357      Clusterer->NumChar = CharID + 1;
1358    }
1359    return (Sample);
1360  } 
1361  LIST ClusterSamples(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
1362    if (Clusterer->Root == nullptr) {
1363      CreateClusterTree(Clusterer);
1364    }
1365    FreeProtoList(&Clusterer->ProtoList);
1366    Clusterer->ProtoList = NIL_LIST;
1367    ComputePrototypes(Clusterer, Config);
1368    LIST proto_list = Clusterer->ProtoList;
1369    iterate(proto_list) {
1370      auto *proto = reinterpret_cast<PROTOTYPE *>(proto_list->first_node());
1371      proto->Cluster = nullptr;
1372    }
1373    return Clusterer->ProtoList;
1374  } 
1375  void FreeClusterer(CLUSTERER *Clusterer) {
1376    if (Clusterer != nullptr) {
1377      delete[] Clusterer->ParamDesc;
1378      delete Clusterer->KDTree;
1379      delete Clusterer->Root;
1380      for (auto &d : Clusterer->bucket_cache) {
1381        for (auto &c : d) {
1382          delete c;
1383        }
1384      }
1385      delete Clusterer;
1386    }
1387  } 
1388  void FreeProtoList(LIST *ProtoList) {
1389    destroy_nodes(*ProtoList, FreePrototype);
1390  } 
1391  void FreePrototype(void *arg) { 
1392    auto *Prototype = static_cast<PROTOTYPE *>(arg);
1393    if (Prototype->Cluster != nullptr) {
1394      Prototype->Cluster->Prototype = false;
1395    }
1396    if (Prototype->Style != spherical) {
1397      delete[] Prototype->Variance.Elliptical;
1398      delete[] Prototype->Magnitude.Elliptical;
1399      delete[] Prototype->Weight.Elliptical;
1400    }
1401    delete Prototype;
1402  } 
1403  CLUSTER *NextSample(LIST *SearchState) {
1404    CLUSTER *Cluster;
1405    if (*SearchState == NIL_LIST) {
1406      return (nullptr);
1407    }
1408    Cluster = reinterpret_cast<CLUSTER *>((*SearchState)->first_node());
1409    *SearchState = pop(*SearchState);
1410    for (;;) {
1411      if (Cluster->Left == nullptr) {
1412        return (Cluster);
1413      }
1414      *SearchState = push(*SearchState, Cluster->Right);
1415      Cluster = Cluster->Left;
1416    }
1417  } 
1418  float Mean(PROTOTYPE *Proto, uint16_t Dimension) {
1419    return (Proto->Mean[Dimension]);
1420  } 
1421  float StandardDeviation(PROTOTYPE *Proto, uint16_t Dimension) {
1422    switch (Proto->Style) {
1423      case spherical:
1424        return std::sqrt(Proto->Variance.Spherical);
1425      case elliptical:
1426        return std::sqrt(Proto->Variance.Elliptical[Dimension]);
1427      case mixed:
1428        switch (Proto->Distrib[Dimension]) {
1429          case normal:
1430            return std::sqrt(Proto->Variance.Elliptical[Dimension]);
1431          case uniform:
1432          case D_random:
1433            return Proto->Variance.Elliptical[Dimension];
1434          case DISTRIBUTION_COUNT:
1435            ASSERT_HOST(!"Distribution count not allowed!");
1436        }
1437    }
1438    return 0.0f;
1439  } 
1440  static void CreateClusterTree(CLUSTERER *Clusterer) {
1441    ClusteringContext context;
1442    ClusterPair HeapEntry;
1443    context.tree = Clusterer->KDTree;
1444    context.candidates = new TEMPCLUSTER[Clusterer->NumberOfSamples];
1445    context.next = 0;
1446    context.heap = new ClusterHeap(Clusterer->NumberOfSamples);
1447    KDWalk(context.tree, MakePotentialClusters, &context);
1448    while (context.heap->Pop(&HeapEntry)) {
1449      TEMPCLUSTER *PotentialCluster = HeapEntry.data();
1450      if (PotentialCluster->Cluster->Clustered) {
1451        continue;
1452      }
1453      else if (PotentialCluster->Neighbor->Clustered) {
1454        PotentialCluster->Neighbor =
1455            FindNearestNeighbor(context.tree, PotentialCluster->Cluster, &HeapEntry.key());
1456        if (PotentialCluster->Neighbor != nullptr) {
1457          context.heap->Push(&HeapEntry);
1458        }
1459      }
1460      else {
1461        PotentialCluster->Cluster = MakeNewCluster(Clusterer, PotentialCluster);
1462        PotentialCluster->Neighbor =
1463            FindNearestNeighbor(context.tree, PotentialCluster->Cluster, &HeapEntry.key());
1464        if (PotentialCluster->Neighbor != nullptr) {
1465          context.heap->Push(&HeapEntry);
1466        }
1467      }
1468    }
1469    Clusterer->Root = static_cast<CLUSTER *> RootOf(Clusterer->KDTree);
1470    delete context.tree;
1471    Clusterer->KDTree = nullptr;
1472    delete context.heap;
1473    delete[] context.candidates;
1474  } 
1475  static void MakePotentialClusters(ClusteringContext *context, CLUSTER *Cluster, int32_t &bsol;*Level*/) {
1476    ClusterPair HeapEntry;
1477    int next = context->next;
1478    context->candidates[next].Cluster = Cluster;
1479    HeapEntry.data() = &(context->candidates[next]);
1480    context->candidates[next].Neighbor =
1481        FindNearestNeighbor(context->tree, context->candidates[next].Cluster, &HeapEntry.key());
1482    if (context->candidates[next].Neighbor != nullptr) {
1483      context->heap->Push(&HeapEntry);
1484      context->next++;
1485    }
1486  } 
1487  static CLUSTER *FindNearestNeighbor(KDTREE *Tree, CLUSTER *Cluster, float *Distance)
1488  #define MAXNEIGHBORS 2
1489  #define MAXDISTANCE FLT_MAX
1490  {
1491    CLUSTER *Neighbor[MAXNEIGHBORS];
1492    float Dist[MAXNEIGHBORS];
1493    int NumberOfNeighbors;
1494    int32_t i;
1495    CLUSTER *BestNeighbor;
1496    KDNearestNeighborSearch(Tree, &Cluster->Mean[0], MAXNEIGHBORS, MAXDISTANCE, &NumberOfNeighbors,
1497                            reinterpret_cast<void **>(Neighbor), Dist);
1498    *Distance = MAXDISTANCE;
1499    BestNeighbor = nullptr;
1500    for (i = 0; i < NumberOfNeighbors; i++) {
1501      if ((Dist[i] < *Distance) && (Neighbor[i] != Cluster)) {
1502        *Distance = Dist[i];
1503        BestNeighbor = Neighbor[i];
1504      }
1505    }
1506    return BestNeighbor;
1507  } 
1508  static CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster) {
1509    auto Cluster = new CLUSTER(Clusterer->SampleSize);
1510    Cluster->Clustered = false;
1511    Cluster->Prototype = false;
1512    Cluster->Left = TempCluster->Cluster;
1513    Cluster->Right = TempCluster->Neighbor;
1514    Cluster->CharID = -1;
1515    Cluster->Left->Clustered = true;
1516    Cluster->Right->Clustered = true;
1517    KDDelete(Clusterer->KDTree, &Cluster->Left->Mean[0], Cluster->Left);
1518    KDDelete(Clusterer->KDTree, &Cluster->Right->Mean[0], Cluster->Right);
1519    Cluster->SampleCount = MergeClusters(Clusterer->SampleSize, Clusterer->ParamDesc,
1520                                         Cluster->Left->SampleCount, Cluster->Right->SampleCount,
1521                                         &Cluster->Mean[0], &Cluster->Left->Mean[0], &Cluster->Right->Mean[0]);
1522    KDStore(Clusterer->KDTree, &Cluster->Mean[0], Cluster);
1523    return Cluster;
1524  } 
1525  int32_t MergeClusters(int16_t N, PARAM_DESC ParamDesc[], int32_t n1, int32_t n2, float m[],
1526                        float m1[], float m2[]) {
1527    int32_t i, n;
1528    n = n1 + n2;
1529    for (i = N; i > 0; i--, ParamDesc++, m++, m1++, m2++) {
1530      if (ParamDesc->Circular) {
1531        if ((*m2 - *m1) > ParamDesc->HalfRange) {
1532          *m = (n1 * *m1 + n2 * (*m2 - ParamDesc->Range)) / n;
1533          if (*m < ParamDesc->Min) {
1534            *m += ParamDesc->Range;
1535          }
1536        } else if ((*m1 - *m2) > ParamDesc->HalfRange) {
1537          *m = (n1 * (*m1 - ParamDesc->Range) + n2 * *m2) / n;
1538          if (*m < ParamDesc->Min) {
1539            *m += ParamDesc->Range;
1540          }
1541        } else {
1542          *m = (n1 * *m1 + n2 * *m2) / n;
1543        }
1544      } else {
1545        *m = (n1 * *m1 + n2 * *m2) / n;
1546      }
1547    }
1548    return n;
1549  } 
1550  static void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
1551    LIST ClusterStack = NIL_LIST;
1552    CLUSTER *Cluster;
1553    PROTOTYPE *Prototype;
1554    if (Clusterer->Root != nullptr) {
1555      ClusterStack = push(NIL_LIST, Clusterer->Root);
1556    }
1557    while (ClusterStack != NIL_LIST) {
1558      Cluster = reinterpret_cast<CLUSTER *>(ClusterStack->first_node());
1559      ClusterStack = pop(ClusterStack);
1560      Prototype = MakePrototype(Clusterer, Config, Cluster);
1561      if (Prototype != nullptr) {
1562        Clusterer->ProtoList = push(Clusterer->ProtoList, Prototype);
1563      } else {
1564        ClusterStack = push(ClusterStack, Cluster->Right);
1565        ClusterStack = push(ClusterStack, Cluster->Left);
1566      }
1567    }
1568  } 
1569  static PROTOTYPE *MakePrototype(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster) {
1570    PROTOTYPE *Proto;
1571    BUCKETS *Buckets;
1572    if (MultipleCharSamples(Clusterer, Cluster, Config->MaxIllegal)) {
1573      return nullptr;
1574    }
1575    auto Statistics = ComputeStatistics(Clusterer->SampleSize, Clusterer->ParamDesc, Cluster);
1576    Proto = MakeDegenerateProto(Clusterer->SampleSize, Cluster, Statistics, Config->ProtoStyle,
1577                                static_cast<int32_t>(Config->MinSamples * Clusterer->NumChar));
1578    if (Proto != nullptr) {
1579      delete Statistics;
1580      return Proto;
1581    }
1582    if (!Independent(Clusterer->ParamDesc, Clusterer->SampleSize, &Statistics->CoVariance[0],
1583                     Config->Independence)) {
1584      delete Statistics;
1585      return nullptr;
1586    }
1587    if (HOTELLING && Config->ProtoStyle == elliptical) {
1588      Proto = TestEllipticalProto(Clusterer, Config, Cluster, Statistics);
1589      if (Proto != nullptr) {
1590        delete Statistics;
1591        return Proto;
1592      }
1593    }
1594    Buckets = GetBuckets(Clusterer, normal, Cluster->SampleCount, Config->Confidence);
1595    switch (Config->ProtoStyle) {
1596      case spherical:
1597        Proto = MakeSphericalProto(Clusterer, Cluster, Statistics, Buckets);
1598        break;
1599      case elliptical:
1600        Proto = MakeEllipticalProto(Clusterer, Cluster, Statistics, Buckets);
1601        break;
1602      case mixed:
1603        Proto = MakeMixedProto(Clusterer, Cluster, Statistics, Buckets, Config->Confidence);
1604        break;
1605      case automatic:
1606        Proto = MakeSphericalProto(Clusterer, Cluster, Statistics, Buckets);
1607        if (Proto != nullptr) {
1608          break;
1609        }
1610        Proto = MakeEllipticalProto(Clusterer, Cluster, Statistics, Buckets);
1611        if (Proto != nullptr) {
1612          break;
1613        }
1614        Proto = MakeMixedProto(Clusterer, Cluster, Statistics, Buckets, Config->Confidence);
1615        break;
1616    }
1617    delete Statistics;
1618    return Proto;
1619  } 
1620  static PROTOTYPE *MakeDegenerateProto( 
1621      uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics, PROTOSTYLE Style, int32_t MinSamples) {
1622    PROTOTYPE *Proto = nullptr;
1623    if (MinSamples < MINSAMPLESNEEDED) {
1624      MinSamples = MINSAMPLESNEEDED;
1625    }
1626    if (Cluster->SampleCount < MinSamples) {
1627      switch (Style) {
1628        case spherical:
1629          Proto = NewSphericalProto(N, Cluster, Statistics);
1630          break;
1631        case elliptical:
1632        case automatic:
1633          Proto = NewEllipticalProto(N, Cluster, Statistics);
1634          break;
1635        case mixed:
1636          Proto = NewMixedProto(N, Cluster, Statistics);
1637          break;
1638      }
1639      Proto->Significant = false;
1640    }
1641    return (Proto);
1642  } 
1643  static PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster,
1644                                        STATISTICS *Statistics) {
1645    const double kMagicSampleMargin = 0.0625;
1646    const double kFTableBoostMargin = 2.0;
1647    int N = Clusterer->SampleSize;
1648    CLUSTER *Left = Cluster->Left;
1649    CLUSTER *Right = Cluster->Right;
1650    if (Left == nullptr || Right == nullptr) {
1651      return nullptr;
1652    }
1653    int TotalDims = Left->SampleCount + Right->SampleCount;
1654    if (TotalDims < N + 1 || TotalDims < 2) {
1655      return nullptr;
1656    }
1657    std::vector<float> Covariance(static_cast<size_t>(N) * N);
1658    std::vector<float> Inverse(static_cast<size_t>(N) * N);
1659    std::vector<float> Delta(N);
1660    for (int i = 0; i < N; ++i) {
1661      int row_offset = i * N;
1662      if (!Clusterer->ParamDesc[i].NonEssential) {
<span onclick='openModal()' class='match'>1663        for (int j = 0; j < N; ++j) {
1664          if (!Clusterer->ParamDesc[j].NonEssential) {
1665            Covariance[j + row_offset] = Statistics->CoVariance[j + row_offset];
1666          } else {
1667            Covariance[j + row_offset] = 0.0f;
1668          }
</span>1669        }
1670      } else {
1671        for (int j = 0; j < N; ++j) {
1672          if (i == j) {
1673            Covariance[j + row_offset] = 1.0f;
1674          } else {
1675            Covariance[j + row_offset] = 0.0f;
1676          }
1677        }
1678      }
1679    }
1680    double err = InvertMatrix(&Covariance[0], N, &Inverse[0]);
1681    if (err > 1) {
1682      tprintf("Clustering error: Matrix inverse failed with error %g\n", err);
1683    }
1684    int EssentialN = 0;
1685    for (int dim = 0; dim < N; ++dim) {
1686      if (!Clusterer->ParamDesc[dim].NonEssential) {
1687        Delta[dim] = Left->Mean[dim] - Right->Mean[dim];
1688        ++EssentialN;
1689      } else {
1690        Delta[dim] = 0.0f;
1691      }
1692    }
1693    double Tsq = 0.0;
1694    for (int x = 0; x < N; ++x) {
1695      double temp = 0.0;
1696      for (int y = 0; y < N; ++y) {
1697        temp += static_cast<double>(Inverse[y + N * x]) * Delta[y];
1698      }
1699      Tsq += Delta[x] * temp;
1700    }
1701    double F = Tsq * (TotalDims - EssentialN - 1) / ((TotalDims - 2) * EssentialN);
1702    int Fx = EssentialN;
1703    if (Fx > FTABLE_X) {
1704      Fx = FTABLE_X;
1705    }
1706    --Fx;
1707    int Fy = TotalDims - EssentialN - 1;
1708    if (Fy > FTABLE_Y) {
1709      Fy = FTABLE_Y;
1710    }
1711    --Fy;
1712    double FTarget = FTable[Fy][Fx];
1713    if (Config->MagicSamples > 0 && TotalDims >= Config->MagicSamples * (1.0 - kMagicSampleMargin) &&
1714        TotalDims <= Config->MagicSamples * (1.0 + kMagicSampleMargin)) {
1715      FTarget += kFTableBoostMargin;
1716    }
1717    if (F < FTarget) {
1718      return NewEllipticalProto(Clusterer->SampleSize, Cluster, Statistics);
1719    }
1720    return nullptr;
1721  }
1722  static PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1723                                       BUCKETS *Buckets) {
1724    PROTOTYPE *Proto = nullptr;
1725    int i;
1726    for (i = 0; i < Clusterer->SampleSize; i++) {
1727      if (Clusterer->ParamDesc[i].NonEssential) {
1728        continue;
1729      }
1730      FillBuckets(Buckets, Cluster, i, &(Clusterer->ParamDesc[i]), Cluster->Mean[i],
1731                  sqrt(static_cast<double>(Statistics->AvgVariance)));
1732      if (!DistributionOK(Buckets)) {
1733        break;
1734      }
1735    }
1736    if (i >= Clusterer->SampleSize) {
1737      Proto = NewSphericalProto(Clusterer->SampleSize, Cluster, Statistics);
1738    }
1739    return (Proto);
1740  } 
1741  static PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer, CLUSTER *Cluster,
1742                                        STATISTICS *Statistics, BUCKETS *Buckets) {
1743    PROTOTYPE *Proto = nullptr;
1744    int i;
1745    for (i = 0; i < Clusterer->SampleSize; i++) {
1746      if (Clusterer->ParamDesc[i].NonEssential) {
1747        continue;
1748      }
1749      FillBuckets(Buckets, Cluster, i, &(Clusterer->ParamDesc[i]), Cluster->Mean[i],
1750                  sqrt(static_cast<double>(Statistics->CoVariance[i * (Clusterer->SampleSize + 1)])));
1751      if (!DistributionOK(Buckets)) {
1752        break;
1753      }
1754    }
1755    if (i >= Clusterer->SampleSize) {
1756      Proto = NewEllipticalProto(Clusterer->SampleSize, Cluster, Statistics);
1757    }
1758    return (Proto);
1759  } 
1760  static PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1761                                   BUCKETS *NormalBuckets, double Confidence) {
1762    PROTOTYPE *Proto;
1763    int i;
1764    BUCKETS *UniformBuckets = nullptr;
1765    BUCKETS *RandomBuckets = nullptr;
1766    Proto = NewMixedProto(Clusterer->SampleSize, Cluster, Statistics);
1767    for (i = 0; i < Clusterer->SampleSize; i++) {
1768      if (Clusterer->ParamDesc[i].NonEssential) {
1769        continue;
1770      }
1771      FillBuckets(NormalBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1772                  std::sqrt(Proto->Variance.Elliptical[i]));
1773      if (DistributionOK(NormalBuckets)) {
1774        continue;
1775      }
1776      if (RandomBuckets == nullptr) {
1777        RandomBuckets = GetBuckets(Clusterer, D_random, Cluster->SampleCount, Confidence);
1778      }
1779      MakeDimRandom(i, Proto, &(Clusterer->ParamDesc[i]));
1780      FillBuckets(RandomBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1781                  Proto->Variance.Elliptical[i]);
1782      if (DistributionOK(RandomBuckets)) {
1783        continue;
1784      }
1785      if (UniformBuckets == nullptr) {
1786        UniformBuckets = GetBuckets(Clusterer, uniform, Cluster->SampleCount, Confidence);
1787      }
1788      MakeDimUniform(i, Proto, Statistics);
1789      FillBuckets(UniformBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1790                  Proto->Variance.Elliptical[i]);
1791      if (DistributionOK(UniformBuckets)) {
1792        continue;
1793      }
1794      break;
1795    }
1796    if (i < Clusterer->SampleSize) {
1797      FreePrototype(Proto);
1798      Proto = nullptr;
1799    }
1800    return (Proto);
1801  } 
1802  static void MakeDimRandom(uint16_t i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc) {
1803    Proto->Distrib[i] = D_random;
1804    Proto->Mean[i] = ParamDesc->MidRange;
1805    Proto->Variance.Elliptical[i] = ParamDesc->HalfRange;
1806    Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
1807    Proto->Magnitude.Elliptical[i] = 1.0 / ParamDesc->Range;
1808    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1809    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1810  } 
1811  static void MakeDimUniform(uint16_t i, PROTOTYPE *Proto, STATISTICS *Statistics) {
1812    Proto->Distrib[i] = uniform;
1813    Proto->Mean[i] = Proto->Cluster->Mean[i] + (Statistics->Min[i] + Statistics->Max[i]) / 2;
1814    Proto->Variance.Elliptical[i] = (Statistics->Max[i] - Statistics->Min[i]) / 2;
1815    if (Proto->Variance.Elliptical[i] < MINVARIANCE) {
1816      Proto->Variance.Elliptical[i] = MINVARIANCE;
1817    }
1818    Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
1819    Proto->Magnitude.Elliptical[i] = 1.0 / (2.0 * Proto->Variance.Elliptical[i]);
1820    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1821    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1822  } 
1823  static STATISTICS *ComputeStatistics(int16_t N, PARAM_DESC ParamDesc[], CLUSTER *Cluster) {
1824    int i, j;
1825    LIST SearchState;
1826    SAMPLE *Sample;
1827    uint32_t SampleCountAdjustedForBias;
1828    auto Statistics = new STATISTICS(N);
1829    std::vector<float> Distance(N);
1830    InitSampleSearch(SearchState, Cluster);
1831    while ((Sample = NextSample(&SearchState)) != nullptr) {
1832      for (i = 0; i < N; i++) {
1833        Distance[i] = Sample->Mean[i] - Cluster->Mean[i];
1834        if (ParamDesc[i].Circular) {
1835          if (Distance[i] > ParamDesc[i].HalfRange) {
1836            Distance[i] -= ParamDesc[i].Range;
1837          }
1838          if (Distance[i] < -ParamDesc[i].HalfRange) {
1839            Distance[i] += ParamDesc[i].Range;
1840          }
1841        }
1842        if (Distance[i] < Statistics->Min[i]) {
1843          Statistics->Min[i] = Distance[i];
1844        }
1845        if (Distance[i] > Statistics->Max[i]) {
1846          Statistics->Max[i] = Distance[i];
1847        }
1848      }
1849      auto CoVariance = &Statistics->CoVariance[0];
1850      for (i = 0; i < N; i++) {
1851        for (j = 0; j < N; j++, CoVariance++) {
1852          *CoVariance += Distance[i] * Distance[j];
1853        }
1854      }
1855    }
1856    if (Cluster->SampleCount > 1) {
1857      SampleCountAdjustedForBias = Cluster->SampleCount - 1;
1858    } else {
1859      SampleCountAdjustedForBias = 1;
1860    }
1861    auto CoVariance = &Statistics->CoVariance[0];
1862    for (i = 0; i < N; i++) {
1863      for (j = 0; j < N; j++, CoVariance++) {
1864        *CoVariance /= SampleCountAdjustedForBias;
1865        if (j == i) {
1866          if (*CoVariance < MINVARIANCE) {
1867            *CoVariance = MINVARIANCE;
1868          }
1869          Statistics->AvgVariance *= *CoVariance;
1870        }
1871      }
1872    }
1873    Statistics->AvgVariance =
1874        static_cast<float>(pow(static_cast<double>(Statistics->AvgVariance), 1.0 / N));
1875    return Statistics;
1876  } 
1877  static PROTOTYPE *NewSphericalProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1878    PROTOTYPE *Proto;
1879    Proto = NewSimpleProto(N, Cluster);
1880    Proto->Variance.Spherical = Statistics->AvgVariance;
1881    if (Proto->Variance.Spherical < MINVARIANCE) {
1882      Proto->Variance.Spherical = MINVARIANCE;
1883    }
1884    Proto->Magnitude.Spherical = 1.0 / sqrt(2.0 * M_PI * Proto->Variance.Spherical);
1885    Proto->TotalMagnitude = static_cast<float>(
1886        pow(static_cast<double>(Proto->Magnitude.Spherical), static_cast<double>(N)));
1887    Proto->Weight.Spherical = 1.0 / Proto->Variance.Spherical;
1888    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1889    return (Proto);
1890  } 
1891  static PROTOTYPE *NewEllipticalProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1892    PROTOTYPE *Proto;
1893    int i;
1894    Proto = NewSimpleProto(N, Cluster);
1895    Proto->Variance.Elliptical = new float[N];
1896    Proto->Magnitude.Elliptical = new float[N];
1897    Proto->Weight.Elliptical = new float[N];
1898    auto CoVariance = &Statistics->CoVariance[0];
1899    Proto->TotalMagnitude = 1.0;
1900    for (i = 0; i < N; i++, CoVariance += N + 1) {
1901      Proto->Variance.Elliptical[i] = *CoVariance;
1902      if (Proto->Variance.Elliptical[i] < MINVARIANCE) {
1903        Proto->Variance.Elliptical[i] = MINVARIANCE;
1904      }
1905      Proto->Magnitude.Elliptical[i] = 1.0f / sqrt(2.0f * M_PI * Proto->Variance.Elliptical[i]);
1906      Proto->Weight.Elliptical[i] = 1.0f / Proto->Variance.Elliptical[i];
1907      Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1908    }
1909    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1910    Proto->Style = elliptical;
1911    return (Proto);
1912  } 
1913  static PROTOTYPE *NewMixedProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1914    auto Proto = NewEllipticalProto(N, Cluster, Statistics);
1915    Proto->Distrib.clear();
1916    Proto->Distrib.resize(N, normal);
1917    Proto->Style = mixed;
1918    return Proto;
1919  } 
1920  static PROTOTYPE *NewSimpleProto(int16_t N, CLUSTER *Cluster) {
1921    auto Proto = new PROTOTYPE;
1922    Proto->Mean = Cluster->Mean;
1923    Proto->Distrib.clear();
1924    Proto->Significant = true;
1925    Proto->Merged = false;
1926    Proto->Style = spherical;
1927    Proto->NumSamples = Cluster->SampleCount;
1928    Proto->Cluster = Cluster;
1929    Proto->Cluster->Prototype = true;
1930    return Proto;
1931  } 
1932  static bool Independent(PARAM_DESC *ParamDesc, int16_t N, float *CoVariance, float Independence) {
1933    int i, j;
1934    float *VARii; 
1935    float *VARjj; 
1936    float CorrelationCoeff;
1937    VARii = CoVariance;
1938    for (i = 0; i < N; i++, VARii += N + 1) {
1939      if (ParamDesc[i].NonEssential) {
1940        continue;
1941      }
1942      VARjj = VARii + N + 1;
1943      CoVariance = VARii + 1;
1944      for (j = i + 1; j < N; j++, CoVariance++, VARjj += N + 1) {
1945        if (ParamDesc[j].NonEssential) {
1946          continue;
1947        }
1948        if ((*VARii == 0.0) || (*VARjj == 0.0)) {
1949          CorrelationCoeff = 0.0;
1950        } else {
1951          CorrelationCoeff = sqrt(std::sqrt(*CoVariance * *CoVariance / (*VARii * *VARjj)));
1952        }
1953        if (CorrelationCoeff > Independence) {
1954          return false;
1955        }
1956      }
1957    }
1958    return true;
1959  } 
1960  static BUCKETS *GetBuckets(CLUSTERER *clusterer, DISTRIBUTION Distribution, uint32_t SampleCount,
1961                             double Confidence) {
1962    uint16_t NumberOfBuckets = OptimumNumberOfBuckets(SampleCount);
1963    BUCKETS *Buckets = clusterer->bucket_cache[Distribution][NumberOfBuckets - MINBUCKETS];
1964    if (Buckets == nullptr) {
1965      Buckets = MakeBuckets(Distribution, SampleCount, Confidence);
1966      clusterer->bucket_cache[Distribution][NumberOfBuckets - MINBUCKETS] = Buckets;
1967    } else {
1968      if (SampleCount != Buckets->SampleCount) {
1969        AdjustBuckets(Buckets, SampleCount);
1970      }
1971      if (Confidence != Buckets->Confidence) {
1972        Buckets->Confidence = Confidence;
1973        Buckets->ChiSquared =
1974            ComputeChiSquared(DegreesOfFreedom(Distribution, Buckets->NumberOfBuckets), Confidence);
1975      }
1976      InitBuckets(Buckets);
1977    }
1978    return Buckets;
1979  } 
1980  static BUCKETS *MakeBuckets(DISTRIBUTION Distribution, uint32_t SampleCount, double Confidence) {
1981    const DENSITYFUNC DensityFunction[] = {NormalDensity, UniformDensity, UniformDensity};
1982    int i, j;
1983    double BucketProbability;
1984    double NextBucketBoundary;
1985    double Probability;
1986    double ProbabilityDelta;
1987    double LastProbDensity;
1988    double ProbDensity;
1989    uint16_t CurrentBucket;
1990    bool Symmetrical;
1991    auto Buckets = new BUCKETS(OptimumNumberOfBuckets(SampleCount));
1992    Buckets->SampleCount = SampleCount;
1993    Buckets->Confidence = Confidence;
1994    Buckets->Distribution = Distribution;
1995    Symmetrical = true;
1996    Buckets->ChiSquared =
1997        ComputeChiSquared(DegreesOfFreedom(Distribution, Buckets->NumberOfBuckets), Confidence);
1998    if (Symmetrical) {
1999      BucketProbability = 1.0 / static_cast<double>(Buckets->NumberOfBuckets);
2000      CurrentBucket = Buckets->NumberOfBuckets / 2;
2001      if (Odd(Buckets->NumberOfBuckets)) {
2002        NextBucketBoundary = BucketProbability / 2;
2003      } else {
2004        NextBucketBoundary = BucketProbability;
2005      }
2006      Probability = 0.0;
2007      LastProbDensity = (*DensityFunction[static_cast<int>(Distribution)])(BUCKETTABLESIZE / 2);
2008      for (i = BUCKETTABLESIZE / 2; i < BUCKETTABLESIZE; i++) {
2009        ProbDensity = (*DensityFunction[static_cast<int>(Distribution)])(i + 1);
2010        ProbabilityDelta = Integral(LastProbDensity, ProbDensity, 1.0);
2011        Probability += ProbabilityDelta;
2012        if (Probability > NextBucketBoundary) {
2013          if (CurrentBucket < Buckets->NumberOfBuckets - 1) {
2014            CurrentBucket++;
2015          }
2016          NextBucketBoundary += BucketProbability;
2017        }
2018        Buckets->Bucket[i] = CurrentBucket;
2019        Buckets->ExpectedCount[CurrentBucket] += static_cast<float>(ProbabilityDelta * SampleCount);
2020        LastProbDensity = ProbDensity;
2021      }
2022      Buckets->ExpectedCount[CurrentBucket] += static_cast<float>((0.5 - Probability) * SampleCount);
2023      for (i = 0, j = BUCKETTABLESIZE - 1; i < j; i++, j--) {
2024        Buckets->Bucket[i] = Mirror(Buckets->Bucket[j], Buckets->NumberOfBuckets);
2025      }
2026      for (i = 0, j = Buckets->NumberOfBuckets - 1; i <= j; i++, j--) {
2027        Buckets->ExpectedCount[i] += Buckets->ExpectedCount[j];
2028      }
2029    }
2030    return Buckets;
2031  } 
2032  static uint16_t OptimumNumberOfBuckets(uint32_t SampleCount) {
2033    uint8_t Last, Next;
2034    float Slope;
2035    if (SampleCount < kCountTable[0]) {
2036      return kBucketsTable[0];
2037    }
2038    for (Last = 0, Next = 1; Next < LOOKUPTABLESIZE; Last++, Next++) {
2039      if (SampleCount <= kCountTable[Next]) {
2040        Slope = static_cast<float>(kBucketsTable[Next] - kBucketsTable[Last]) /
2041                static_cast<float>(kCountTable[Next] - kCountTable[Last]);
2042        return (
2043            static_cast<uint16_t>(kBucketsTable[Last] + Slope * (SampleCount - kCountTable[Last])));
2044      }
2045    }
2046    return kBucketsTable[Last];
2047  } 
2048  static double ComputeChiSquared(uint16_t DegreesOfFreedom, double Alpha)
2049  #define CHIACCURACY 0.01
2050  #define MINALPHA (1e-200)
2051  {
2052    static LIST ChiWith[MAXDEGREESOFFREEDOM + 1];
2053    Alpha = ClipToRange(Alpha, MINALPHA, 1.0);
2054    if (Odd(DegreesOfFreedom)) {
2055      DegreesOfFreedom++;
2056    }
2057    CHISTRUCT SearchKey(0.0, Alpha);
2058    auto *found = search(ChiWith[DegreesOfFreedom], &SearchKey, AlphaMatch);
2059    auto OldChiSquared = reinterpret_cast<CHISTRUCT *>(found ? found->first_node() : nullptr);
2060    if (OldChiSquared == nullptr) {
2061      OldChiSquared = new CHISTRUCT(DegreesOfFreedom, Alpha);
2062      OldChiSquared->ChiSquared =
2063          Solve(ChiArea, OldChiSquared, static_cast<double>(DegreesOfFreedom), CHIACCURACY);
2064      ChiWith[DegreesOfFreedom] = push(ChiWith[DegreesOfFreedom], OldChiSquared);
2065    } else {
2066    }
2067    return (OldChiSquared->ChiSquared);
2068  } 
2069  static double NormalDensity(int32_t x) {
2070    double Distance;
2071    Distance = x - kNormalMean;
2072    return kNormalMagnitude * exp(-0.5 * Distance * Distance / kNormalVariance);
2073  } 
2074  static double UniformDensity(int32_t x) {
2075    constexpr auto UniformDistributionDensity = 1.0 / BUCKETTABLESIZE;
2076    if ((x >= 0) && (x <= BUCKETTABLESIZE)) {
2077      return UniformDistributionDensity;
2078    } else {
2079      return 0.0;
2080    }
2081  } 
2082  static double Integral(double f1, double f2, double Dx) {
2083    return (f1 + f2) * Dx / 2.0;
2084  } 
2085  static void FillBuckets(BUCKETS *Buckets, CLUSTER *Cluster, uint16_t Dim, PARAM_DESC *ParamDesc,
2086                          float Mean, float StdDev) {
2087    uint16_t BucketID;
2088    int i;
2089    LIST SearchState;
2090    SAMPLE *Sample;
2091    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2092      Buckets->Count[i] = 0;
2093    }
2094    if (StdDev == 0.0) {
2095      InitSampleSearch(SearchState, Cluster);
2096      i = 0;
2097      while ((Sample = NextSample(&SearchState)) != nullptr) {
2098        if (Sample->Mean[Dim] > Mean) {
2099          BucketID = Buckets->NumberOfBuckets - 1;
2100        } else if (Sample->Mean[Dim] < Mean) {
2101          BucketID = 0;
2102        } else {
2103          BucketID = i;
2104        }
2105        Buckets->Count[BucketID] += 1;
2106        i++;
2107        if (i >= Buckets->NumberOfBuckets) {
2108          i = 0;
2109        }
2110      }
2111    } else {
2112      InitSampleSearch(SearchState, Cluster);
2113      while ((Sample = NextSample(&SearchState)) != nullptr) {
2114        switch (Buckets->Distribution) {
2115          case normal:
2116            BucketID = NormalBucket(ParamDesc, Sample->Mean[Dim], Mean, StdDev);
2117            break;
2118          case D_random:
2119          case uniform:
2120            BucketID = UniformBucket(ParamDesc, Sample->Mean[Dim], Mean, StdDev);
2121            break;
2122          default:
2123            BucketID = 0;
2124        }
2125        Buckets->Count[Buckets->Bucket[BucketID]] += 1;
2126      }
2127    }
2128  } 
2129  static uint16_t NormalBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev) {
2130    float X;
2131    if (ParamDesc->Circular) {
2132      if (x - Mean > ParamDesc->HalfRange) {
2133        x -= ParamDesc->Range;
2134      } else if (x - Mean < -ParamDesc->HalfRange) {
2135        x += ParamDesc->Range;
2136      }
2137    }
2138    X = ((x - Mean) / StdDev) * kNormalStdDev + kNormalMean;
2139    if (X < 0) {
2140      return 0;
2141    }
2142    if (X > BUCKETTABLESIZE - 1) {
2143      return (static_cast<uint16_t>(BUCKETTABLESIZE - 1));
2144    }
2145    return static_cast<uint16_t>(floor(static_cast<double>(X)));
2146  } 
2147  static uint16_t UniformBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev) {
2148    float X;
2149    if (ParamDesc->Circular) {
2150      if (x - Mean > ParamDesc->HalfRange) {
2151        x -= ParamDesc->Range;
2152      } else if (x - Mean < -ParamDesc->HalfRange) {
2153        x += ParamDesc->Range;
2154      }
2155    }
2156    X = ((x - Mean) / (2 * StdDev) * BUCKETTABLESIZE + BUCKETTABLESIZE / 2.0);
2157    if (X < 0) {
2158      return 0;
2159    }
2160    if (X > BUCKETTABLESIZE - 1) {
2161      return static_cast<uint16_t>(BUCKETTABLESIZE - 1);
2162    }
2163    return static_cast<uint16_t>(floor(static_cast<double>(X)));
2164  } 
2165  static bool DistributionOK(BUCKETS *Buckets) {
2166    float FrequencyDifference;
2167    float TotalDifference;
2168    int i;
2169    TotalDifference = 0.0;
2170    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2171      FrequencyDifference = Buckets->Count[i] - Buckets->ExpectedCount[i];
2172      TotalDifference += (FrequencyDifference * FrequencyDifference) / Buckets->ExpectedCount[i];
2173    }
2174    if (TotalDifference > Buckets->ChiSquared) {
2175      return false;
2176    } else {
2177      return true;
2178    }
2179  } 
2180  static uint16_t DegreesOfFreedom(DISTRIBUTION Distribution, uint16_t HistogramBuckets) {
2181    static uint8_t DegreeOffsets[] = {3, 3, 1};
2182    uint16_t AdjustedNumBuckets;
2183    AdjustedNumBuckets = HistogramBuckets - DegreeOffsets[static_cast<int>(Distribution)];
2184    if (Odd(AdjustedNumBuckets)) {
2185      AdjustedNumBuckets++;
2186    }
2187    return (AdjustedNumBuckets);
2188  } 
2189  static void AdjustBuckets(BUCKETS *Buckets, uint32_t NewSampleCount) {
2190    int i;
2191    double AdjustFactor;
2192    AdjustFactor =
2193        ((static_cast<double>(NewSampleCount)) / (static_cast<double>(Buckets->SampleCount)));
2194    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2195      Buckets->ExpectedCount[i] *= AdjustFactor;
2196    }
2197    Buckets->SampleCount = NewSampleCount;
2198  } 
2199  static void InitBuckets(BUCKETS *Buckets) {
2200    int i;
2201    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2202      Buckets->Count[i] = 0;
2203    }
2204  } 
2205  static int AlphaMatch(void *arg1,   
2206                        void *arg2) { 
2207    auto *ChiStruct = static_cast<CHISTRUCT *>(arg1);
2208    auto *SearchKey = static_cast<CHISTRUCT *>(arg2);
2209    return (ChiStruct->Alpha == SearchKey->Alpha);
2210  } 
2211  static double Solve(SOLVEFUNC Function, void *FunctionParams, double InitialGuess, double Accuracy)
2212  #define INITIALDELTA 0.1
2213  #define DELTARATIO 0.1
2214  {
2215    double x;
2216    double f;
2217    double Slope;
2218    double Delta;
2219    double NewDelta;
2220    double xDelta;
2221    double LastPosX, LastNegX;
2222    x = InitialGuess;
2223    Delta = INITIALDELTA;
2224    LastPosX = FLT_MAX;
2225    LastNegX = -FLT_MAX;
2226    f = (*Function)(static_cast<CHISTRUCT *>(FunctionParams), x);
2227    while (Abs(LastPosX - LastNegX) > Accuracy) {
2228      if (f < 0) {
2229        LastNegX = x;
2230      } else {
2231        LastPosX = x;
2232      }
2233      Slope = ((*Function)(static_cast<CHISTRUCT *>(FunctionParams), x + Delta) - f) / Delta;
2234      xDelta = f / Slope;
2235      x -= xDelta;
2236      NewDelta = Abs(xDelta) * DELTARATIO;
2237      if (NewDelta < Delta) {
2238        Delta = NewDelta;
2239      }
2240      f = (*Function)(static_cast<CHISTRUCT *>(FunctionParams), x);
2241    }
2242    return (x);
2243  } 
2244  static double ChiArea(CHISTRUCT *ChiParams, double x) {
2245    int i, N;
2246    double SeriesTotal;
2247    double Denominator;
2248    double PowerOfx;
2249    N = ChiParams->DegreesOfFreedom / 2 - 1;
2250    SeriesTotal = 1;
2251    Denominator = 1;
2252    PowerOfx = 1;
2253    for (i = 1; i <= N; i++) {
2254      Denominator *= 2 * i;
2255      PowerOfx *= x;
2256      SeriesTotal += PowerOfx / Denominator;
2257    }
2258    return ((SeriesTotal * exp(-0.5 * x)) - ChiParams->Alpha);
2259  } 
2260  static bool MultipleCharSamples(CLUSTERER *Clusterer, CLUSTER *Cluster, float MaxIllegal)
2261  #define ILLEGAL_CHAR 2
2262  {
2263    static std::vector<uint8_t> CharFlags;
2264    LIST SearchState;
2265    SAMPLE *Sample;
2266    int32_t CharID;
2267    int32_t NumCharInCluster;
2268    int32_t NumIllegalInCluster;
2269    float PercentIllegal;
2270    NumCharInCluster = Cluster->SampleCount;
2271    NumIllegalInCluster = 0;
2272    if (Clusterer->NumChar > CharFlags.size()) {
2273      CharFlags.resize(Clusterer->NumChar);
2274    }
2275    for (auto &CharFlag : CharFlags) {
2276      CharFlag = false;
2277    }
2278    InitSampleSearch(SearchState, Cluster);
2279    while ((Sample = NextSample(&SearchState)) != nullptr) {
2280      CharID = Sample->CharID;
2281      if (CharFlags[CharID] == false) {
2282        CharFlags[CharID] = true;
2283      } else {
2284        if (CharFlags[CharID] == true) {
2285          NumIllegalInCluster++;
2286          CharFlags[CharID] = ILLEGAL_CHAR;
2287        }
2288        NumCharInCluster--;
2289        PercentIllegal = static_cast<float>(NumIllegalInCluster) / NumCharInCluster;
2290        if (PercentIllegal > MaxIllegal) {
2291          destroy(SearchState);
2292          return true;
2293        }
2294      }
2295    }
2296    return false;
2297  } 
2298  static double InvertMatrix(const float *input, int size, float *inv) {
2299    GENERIC_2D_ARRAY<double> U(size, size, 0.0);
2300    GENERIC_2D_ARRAY<double> U_inv(size, size, 0.0);
2301    GENERIC_2D_ARRAY<double> L(size, size, 0.0);
2302    int row;
2303    int col;
2304    for (row = 0; row < size; row++) {
2305      for (col = 0; col < size; col++) {
2306        U[row][col] = input[row * size + col];
2307        L[row][col] = row == col ? 1.0 : 0.0;
2308        U_inv[row][col] = 0.0;
2309      }
2310    }
2311    for (col = 0; col < size; ++col) {
2312      int best_row = 0;
2313      double best_pivot = -1.0;
2314      for (row = col; row < size; ++row) {
2315        if (Abs(U[row][col]) > best_pivot) {
2316          best_pivot = Abs(U[row][col]);
2317          best_row = row;
2318        }
2319      }
2320      if (best_row != col) {
2321        for (int k = 0; k < size; ++k) {
2322          double tmp = U[best_row][k];
2323          U[best_row][k] = U[col][k];
2324          U[col][k] = tmp;
2325          tmp = L[best_row][k];
2326          L[best_row][k] = L[col][k];
2327          L[col][k] = tmp;
2328        }
2329      }
2330      for (row = col + 1; row < size; ++row) {
2331        double ratio = -U[row][col] / U[col][col];
2332        for (int j = col; j < size; ++j) {
2333          U[row][j] += U[col][j] * ratio;
2334        }
2335        for (int k = 0; k < size; ++k) {
2336          L[row][k] += L[col][k] * ratio;
2337        }
2338      }
2339    }
2340    for (col = 0; col < size; ++col) {
2341      U_inv[col][col] = 1.0 / U[col][col];
2342      for (row = col - 1; row >= 0; --row) {
2343        double total = 0.0;
2344        for (int k = col; k > row; --k) {
2345          total += U[row][k] * U_inv[k][col];
2346        }
2347        U_inv[row][col] = -total / U[row][row];
2348      }
2349    }
2350    for (row = 0; row < size; row++) {
2351      for (col = 0; col < size; col++) {
2352        double sum = 0.0;
2353        for (int k = row; k < size; ++k) {
2354          sum += U_inv[row][k] * L[k][col];
2355        }
2356        inv[row * size + col] = sum;
2357      }
2358    }
2359    double error_sum = 0.0;
2360    for (row = 0; row < size; row++) {
2361      for (col = 0; col < size; col++) {
2362        double sum = 0.0;
2363        for (int k = 0; k < size; ++k) {
2364          sum += static_cast<double>(input[row * size + k]) * inv[k * size + col];
2365        }
2366        if (row != col) {
2367          error_sum += Abs(sum);
2368        }
2369      }
2370    }
2371    return error_sum;
2372  }
2373  } 
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-bbox_util.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <csignal>
3  #include <ctime>
4  #include <functional>
5  #include <map>
6  #include <set>
7  #include <string>
8  #include <utility>
9  #include <vector>
10  #include "boost/iterator/counting_iterator.hpp"
11  #include "caffe/util/bbox_util.hpp"
12  #ifdef ENABLE_NMS_OPTIMIZATION
13  #include <immintrin.h>
14  #include "omp.h"
15  #endif
16  namespace caffe {
17  bool SortBBoxAscend(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
18    return bbox1.score() < bbox2.score();
19  }
20  bool SortBBoxDescend(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
21    return bbox1.score() > bbox2.score();
22  }
23  template <typename T>
24  bool SortScorePairAscend(const pair<float, T>& pair1,
25                           const pair<float, T>& pair2) {
26    return pair1.first < pair2.first;
27  }
28  template bool SortScorePairAscend(const pair<float, int>& pair1,
29                                    const pair<float, int>& pair2);
30  template bool SortScorePairAscend(const pair<float, pair<int, int> >& pair1,
31                                    const pair<float, pair<int, int> >& pair2);
32  template <typename T>
33  bool SortScorePairDescend(const pair<float, T>& pair1,
34                            const pair<float, T>& pair2) {
35    return pair1.first > pair2.first;
36  }
37  template bool SortScorePairDescend(const pair<float, int>& pair1,
38                                     const pair<float, int>& pair2);
39  template bool SortScorePairDescend(const pair<float, pair<int, int> >& pair1,
40                                     const pair<float, pair<int, int> >& pair2);
41  #ifdef ENABLE_NMS_OPTIMIZATION
42  #define DIVUP(m, n)((m) / (n) + ((m) % (n) > 0))
43  typedef unsigned long long int uint64_t;
44  static inline float max(float a, float b) { return (a) > (b) ? (a) : (b); }
45  static inline float min(float a, float b) { return (a) < (b) ? (a) : (b); }
46  #define MASK_ELEM(x, y) \
47    ((uint64_t*)((char*)mask_tbl + x * blocks * sizeof(uint64_t)) + y)
48  void cpu_nms_avx512_parallize_inner(int* __restrict keep_out, 
49                                      int* __restrict num_out, 
50                                      const float* __restrict x1,
51                                      const float* __restrict y1,
52                                      const float* __restrict x2, 
53                                      const float* __restrict y2,
54                                      int64_t boxes_num, 
55                                      float thresh_f)
56  {
57      const int blocks = DIVUP(boxes_num, 64);
58      uint64_t *mask_tbl = (uint64_t *)aligned_alloc(64, blocks * sizeof(uint64_t));
59      memset(mask_tbl, 0, sizeof(uint64_t) * blocks);
60      uint64_t i = 0, j = 0;
61      uint64_t num_to_keep = 0;
62      for (i = 0; i < boxes_num; i++) {
63          if (mask_tbl[i/64] & (1ull << (i % 64))) {
64              continue;
65          }
66          keep_out[num_to_keep++] = i;
67          __m512 x1_a = _mm512_set1_ps(x1[i]);
68          __m512 x2_a = _mm512_set1_ps(x2[i]);
69          __m512 y1_a = _mm512_set1_ps(y1[i]);
70          __m512 y2_a = _mm512_set1_ps(y2[i]);
71          __m512 zero = _mm512_setzero_ps();
72          __m512 Sa_w = _mm512_sub_ps(x2_a, x1_a);
73          __m512 Sa_h = _mm512_sub_ps(y2_a, y1_a);
74          __m512 Sa = _mm512_mul_ps(Sa_w, Sa_h);
75          __m512 thresh = _mm512_set1_ps(thresh_f);
76          for (j = i + 1; (j & 0xf) && (j < boxes_num); j ++) {
77              if (mask_tbl[j/64] & (1ull << (j % 64))) {
78                  continue;
79              }
80              float xx1 = max(x1[i], x1[j]);
81              float yy1 = max(y1[i], y1[j]);
82              float xx2 = min(x2[i], x2[j]);
83              float yy2 = min(y2[i], y2[j]);
84              float w = max(0.0f, xx2 - xx1 );
85              float h = max(0.0f, yy2 - yy1 );
86              float interS = w * h;
87              float Sa = (x2[i] - x1[i] ) * (y2[i] - y1[i] );
88              float Sb = (x2[j] - x1[j] ) * (y2[j] - y1[j] );
89              if (interS > thresh_f * (Sa + Sb - interS)) {
90                  mask_tbl[j/64] |= 1ull << (j % 64);
91              }
92          }
93          if (!(j & 0xf) && (j & 0x1f) && (j + 16 <= boxes_num)) {
94              __m512 x1_b = _mm512_load_ps(x1 + j);
95              __m512 y1_b = _mm512_load_ps(y1 + j);
96              __m512 x2_b = _mm512_load_ps(x2 + j);
97              __m512 y2_b = _mm512_load_ps(y2 + j);
98              __m512 xx1 = _mm512_max_ps(x1_a, x1_b);
99              __m512 yy1 = _mm512_max_ps(y1_a, y1_b);
100              __m512 xx2 = _mm512_min_ps(x2_a, x2_b);
101              __m512 yy2 = _mm512_min_ps(y2_a, y2_b);
102              __m512 w = _mm512_sub_ps(xx2, xx1);
103              __m512 h = _mm512_sub_ps(yy2, yy1);
104              w = _mm512_max_ps(w, zero);
105              h = _mm512_max_ps(h, zero);
106              __m512 interS = _mm512_mul_ps(w, h);
107              __m512 Sb_w = _mm512_sub_ps(x2_b, x1_b);
108              __m512 Sb_h = _mm512_sub_ps(y2_b, y1_b);
109              __m512 Sb = _mm512_mul_ps(Sb_w, Sb_h);
110              __m512 ovr = _mm512_add_ps(Sa, Sb);
111              ovr = _mm512_sub_ps(ovr, interS);
112              ovr = _mm512_mul_ps(ovr, thresh);
113              __mmask16 gt = _mm512_cmp_ps_mask(interS, ovr, _CMP_GT_OS);
114              uint64_t mask = gt;
115              mask_tbl[j/64] |= (mask) << (j % 64);
116              j += 16;
117          }
118          if (!(j & 0x1f) && (j & 0x3f) && (j + 32 <= boxes_num)) {
119              __m512 x1_b0 = _mm512_load_ps(x1 + j);
120              __m512 y1_b0 = _mm512_load_ps(y1 + j);
121              __m512 x2_b0 = _mm512_load_ps(x2 + j);
122              __m512 y2_b0 = _mm512_load_ps(y2 + j);
123              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
124              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
125              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
126              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
127              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
128              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
129              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
130              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
131              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
132              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
133              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
134              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
135              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
136              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
137              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
138              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
139              w0 = _mm512_max_ps(w0, zero);
140              h0 = _mm512_max_ps(h0, zero);
141              w1 = _mm512_max_ps(w1, zero);
142              h1 = _mm512_max_ps(h1, zero);
143              __m512 interS_0 = _mm512_mul_ps(w0, h0);
144              __m512 interS_1 = _mm512_mul_ps(w1, h1);
145              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
146              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
147              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
148              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
149              __m512 ovr0 = _mm512_fmadd_ps(Sb_w0, Sb_h0, Sa);
150              __m512 ovr1 = _mm512_fmadd_ps(Sb_w1, Sb_h1, Sa);
151              ovr0 = _mm512_sub_ps(ovr0, interS_0);
152              ovr1 = _mm512_sub_ps(ovr1, interS_1);
153              ovr0 = _mm512_mul_ps(ovr0, thresh);
154              ovr1 = _mm512_mul_ps(ovr1, thresh);
155              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
156              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
157              uint64_t mask = (gt0) | ((uint64_t)gt1 << 16);
158              mask_tbl[j/64] |= (mask) << (j % 64);
159              j += 32;
160          }
161          for (; (j + 64) <= boxes_num; j += 64) {
162              __m512 x1_b0 = _mm512_load_ps(x1 + j);
163              __m512 y1_b0 = _mm512_load_ps(y1 + j);
164              __m512 x2_b0 = _mm512_load_ps(x2 + j);
165              __m512 y2_b0 = _mm512_load_ps(y2 + j);
166              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
167              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
168              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
169              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
170              __m512 x1_b2 = _mm512_load_ps(x1 + j + 32);
171              __m512 y1_b2 = _mm512_load_ps(y1 + j + 32);
172              __m512 x2_b2 = _mm512_load_ps(x2 + j + 32);
173              __m512 y2_b2 = _mm512_load_ps(y2 + j + 32);
174              __m512 x1_b3 = _mm512_load_ps(x1 + j + 48);
175              __m512 y1_b3 = _mm512_load_ps(y1 + j + 48);
176              __m512 x2_b3 = _mm512_load_ps(x2 + j + 48);
177              __m512 y2_b3 = _mm512_load_ps(y2 + j + 48);
178              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
179              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
180              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
181              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
182              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
183              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
184              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
185              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
186              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
187              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
188              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
189              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
190              __m512 Sb_w2 = _mm512_sub_ps(x2_b2, x1_b2);
191              __m512 Sb_h2 = _mm512_sub_ps(y2_b2, y1_b2);
192              __m512 Sb_w3 = _mm512_sub_ps(x2_b3, x1_b3);
193              __m512 Sb_h3 = _mm512_sub_ps(y2_b3, y1_b3);
194              __m512 xx1_2 = _mm512_max_ps(x1_a, x1_b2);
195              __m512 yy1_2 = _mm512_max_ps(y1_a, y1_b2);
196              __m512 xx2_2 = _mm512_min_ps(x2_a, x2_b2);
197              __m512 yy2_2 = _mm512_min_ps(y2_a, y2_b2);
198              __m512 xx1_3 = _mm512_max_ps(x1_a, x1_b3);
199              __m512 yy1_3 = _mm512_max_ps(y1_a, y1_b3);
200              __m512 xx2_3 = _mm512_min_ps(x2_a, x2_b3);
201              __m512 yy2_3 = _mm512_min_ps(y2_a, y2_b3);
202              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
203              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
204              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
205              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
206              __m512 w2 = _mm512_sub_ps(xx2_2, xx1_2);
207              __m512 h2 = _mm512_sub_ps(yy2_2, yy1_2);
208              __m512 w3 = _mm512_sub_ps(xx2_3, xx1_3);
209              __m512 h3 = _mm512_sub_ps(yy2_3, yy1_3);
210              w0 = _mm512_max_ps(w0, zero);
211              h0 = _mm512_max_ps(h0, zero);
212              w1 = _mm512_max_ps(w1, zero);
213              h1 = _mm512_max_ps(h1, zero);
214              w2 = _mm512_max_ps(w2, zero);
215              h2 = _mm512_max_ps(h2, zero);
216              w3 = _mm512_max_ps(w3, zero);
217              h3 = _mm512_max_ps(h3, zero);
218              __m512 interS_0 = _mm512_mul_ps(w0, h0);
219              __m512 interS_1 = _mm512_mul_ps(w1, h1);
220              __m512 interS_2 = _mm512_mul_ps(w2, h2);
221              __m512 interS_3 = _mm512_mul_ps(w3, h3);
222              __m512 ovr0 = _mm512_fmadd_ps(Sb_w0, Sb_h0, Sa);
223              __m512 ovr1 = _mm512_fmadd_ps(Sb_w1, Sb_h1, Sa);
224              __m512 ovr2 = _mm512_fmadd_ps(Sb_w2, Sb_h2, Sa);
225              __m512 ovr3 = _mm512_fmadd_ps(Sb_w3, Sb_h3, Sa);
226              ovr0 = _mm512_sub_ps(ovr0, interS_0);
227              ovr1 = _mm512_sub_ps(ovr1, interS_1);
228              ovr2 = _mm512_sub_ps(ovr2, interS_2);
229              ovr3 = _mm512_sub_ps(ovr3, interS_3);
230              ovr0 = _mm512_mul_ps(ovr0, thresh);
231              ovr1 = _mm512_mul_ps(ovr1, thresh);
232              ovr2 = _mm512_mul_ps(ovr2, thresh);
233              ovr3 = _mm512_mul_ps(ovr3, thresh);
234              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
235              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
236              __mmask16 gt2 = _mm512_cmp_ps_mask(interS_2, ovr2, _CMP_GT_OS);
237              __mmask16 gt3 = _mm512_cmp_ps_mask(interS_3, ovr3, _CMP_GT_OS);
238              uint64_t mask = ((uint64_t)(gt0)) | (((uint64_t)gt1) << 16) | (((uint64_t)gt2) << 32) | (((uint64_t)gt3) << 48);
239              mask_tbl[j / 64] |= mask;
240          }
241          if ((j + 32) <= boxes_num) {
242              __m512 x1_b0 = _mm512_load_ps(x1 + j);
243              __m512 y1_b0 = _mm512_load_ps(y1 + j);
244              __m512 x2_b0 = _mm512_load_ps(x2 + j);
245              __m512 y2_b0 = _mm512_load_ps(y2 + j);
246              __m512 x1_b1 = _mm512_load_ps(x1 + j + 16);
247              __m512 y1_b1 = _mm512_load_ps(y1 + j + 16);
248              __m512 x2_b1 = _mm512_load_ps(x2 + j + 16);
249              __m512 y2_b1 = _mm512_load_ps(y2 + j + 16);
250              __m512 xx1_0 = _mm512_max_ps(x1_a, x1_b0);
251              __m512 yy1_0 = _mm512_max_ps(y1_a, y1_b0);
252              __m512 xx2_0 = _mm512_min_ps(x2_a, x2_b0);
253              __m512 yy2_0 = _mm512_min_ps(y2_a, y2_b0);
254              __m512 xx1_1 = _mm512_max_ps(x1_a, x1_b1);
255              __m512 yy1_1 = _mm512_max_ps(y1_a, y1_b1);
256              __m512 xx2_1 = _mm512_min_ps(x2_a, x2_b1);
257              __m512 yy2_1 = _mm512_min_ps(y2_a, y2_b1);
258              __m512 w0 = _mm512_sub_ps(xx2_0, xx1_0);
259              __m512 h0 = _mm512_sub_ps(yy2_0, yy1_0);
260              __m512 w1 = _mm512_sub_ps(xx2_1, xx1_1);
261              __m512 h1 = _mm512_sub_ps(yy2_1, yy1_1);
262              w0 = _mm512_max_ps(w0, zero);
263              h0 = _mm512_max_ps(h0, zero);
264              w1 = _mm512_max_ps(w1, zero);
265              h1 = _mm512_max_ps(h1, zero);
266              __m512 interS_0 = _mm512_mul_ps(w0, h0);
267              __m512 interS_1 = _mm512_mul_ps(w1, h1);
268              __m512 Sb_w0 = _mm512_sub_ps(x2_b0, x1_b0);
269              __m512 Sb_h0 = _mm512_sub_ps(y2_b0, y1_b0);
270              __m512 Sb_w1 = _mm512_sub_ps(x2_b1, x1_b1);
271              __m512 Sb_h1 = _mm512_sub_ps(y2_b1, y1_b1);
272              __m512 Sb0 = _mm512_mul_ps(Sb_w0, Sb_h0);
273              __m512 Sb1 = _mm512_mul_ps(Sb_w1, Sb_h1);
274              __m512 ovr0 = _mm512_add_ps(Sa, Sb0);
275              __m512 ovr1 = _mm512_add_ps(Sa, Sb1);
276              ovr0 = _mm512_sub_ps(ovr0, interS_0);
277              ovr1 = _mm512_sub_ps(ovr1, interS_1);
278              ovr0 = _mm512_mul_ps(ovr0, thresh);
279              ovr1 = _mm512_mul_ps(ovr1, thresh);
280              __mmask16 gt0 = _mm512_cmp_ps_mask(interS_0, ovr0, _CMP_GT_OS);
281              __mmask16 gt1 = _mm512_cmp_ps_mask(interS_1, ovr1, _CMP_GT_OS);
282              uint64_t mask = (gt0) | ((uint64_t)gt1 << 16);
283              mask_tbl[(j +  0) / 64] |= (mask) << (j % 64);
284              mask_tbl[(j + 32) / 64] |= (mask) >> (64-(j % 64));
285              j += 32;
286          }
287          if ((j + 16) <= boxes_num) {
288              __m512 x1_b = _mm512_load_ps(x1 + j);
289              __m512 y1_b = _mm512_load_ps(y1 + j);
290              __m512 x2_b = _mm512_load_ps(x2 + j);
291              __m512 y2_b = _mm512_load_ps(y2 + j);
292              __m512 xx1 = _mm512_max_ps(x1_a, x1_b);
293              __m512 yy1 = _mm512_max_ps(y1_a, y1_b);
294              __m512 xx2 = _mm512_min_ps(x2_a, x2_b);
295              __m512 yy2 = _mm512_min_ps(y2_a, y2_b);
296              __m512 w = _mm512_sub_ps(xx2, xx1);
297              __m512 h = _mm512_sub_ps(yy2, yy1);
298              w = _mm512_max_ps(w, zero);
299              h = _mm512_max_ps(h, zero);
300              __m512 interS = _mm512_mul_ps(w, h);
301              __m512 Sb_w = _mm512_sub_ps(x2_b, x1_b);
302              __m512 Sb_h = _mm512_sub_ps(y2_b, y1_b);
303              __m512 Sb = _mm512_mul_ps(Sb_w, Sb_h);
304              __m512 ovr = _mm512_add_ps(Sa, Sb);
305              ovr = _mm512_sub_ps(ovr, interS);
306              ovr = _mm512_mul_ps(ovr, thresh);
307              __mmask16 gt = _mm512_cmp_ps_mask(interS, ovr, _CMP_GT_OS);
308              uint64_t mask = gt;
309              mask_tbl[(j +  0) / 64] |= (mask) << (j % 64);
310              mask_tbl[(j + 16) / 64] |= (mask) >> (64-(j % 64));
311              j += 16;
312          }
313          for (; j < boxes_num; j ++) {
314              if (mask_tbl[j/64] & (1ull << (j % 64))) {
315                  continue;
316              }
317              float xx1 = max(x1[i], x1[j]);
318              float yy1 = max(y1[i], y1[j]);
319              float xx2 = min(x2[i], x2[j]);
320              float yy2 = min(y2[i], y2[j]);
321              float w = max(0.0f, xx2 - xx1 );
322              float h = max(0.0f, yy2 - yy1 );
323              float interS = w * h;
324              float Sa = (x2[i] - x1[i] ) * (y2[i] - y1[i] );
325              float Sb = (x2[j] - x1[j] ) * (y2[j] - y1[j] );
326              if (interS > thresh_f * (Sa + Sb - interS)) {
327                  mask_tbl[j/64] |= 1ull << (j % 64);
328              }
329          }
330      }
331      free(mask_tbl);
332      *num_out = num_to_keep;
333  }
334  void cpu_nms_avx512_caffe(int* __restrict keep_out, int* __restrict num_out,
335                            const vector<NormalizedBBox>& bboxes,
336                            vector<pair<float, int> >& score_index_vec,
337                            float thresh) {
338    uint64_t boxes_num = score_index_vec.size();
339    float* x1 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
340    float* y1 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
341    float* x2 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
342    float* y2 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
343    uint64_t i = 0;
344  #pragma omp parallel for
345    for (i = 0; i < boxes_num; ++i) {
346      x1[i] = bboxes[score_index_vec[i].second].xmin();
347      y1[i] = bboxes[score_index_vec[i].second].ymin();
348      x2[i] = bboxes[score_index_vec[i].second].xmax();
349      y2[i] = bboxes[score_index_vec[i].second].ymax();
350    }
351    cpu_nms_avx512_parallize_inner(keep_out, num_out, x1, y1, x2, y2, boxes_num,
352                                     thresh);
353  #pragma omp parallel for
354    for (int i = 0; i < *num_out; i++) {
355      keep_out[i] = score_index_vec[keep_out[i]].second;
356    }
357    free(x1);
358    free(x2);
359    free(y1);
360    free(y2);
361  }
362  #endif
363  NormalizedBBox UnitBBox() {
364    NormalizedBBox unit_bbox;
365    unit_bbox.set_xmin(0.);
366    unit_bbox.set_ymin(0.);
367    unit_bbox.set_xmax(1.);
368    unit_bbox.set_ymax(1.);
369    return unit_bbox;
370  }
371  bool IsCrossBoundaryBBox(const NormalizedBBox& bbox) {
372    return bbox.xmin() < 0 || bbox.xmin() > 1 ||
373        bbox.ymin() < 0 || bbox.ymin() > 1 ||
374        bbox.xmax() < 0 || bbox.xmax() > 1 ||
375        bbox.ymax() < 0 || bbox.ymax() > 1;
376  }
377  void IntersectBBox(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2,
378                     NormalizedBBox* intersect_bbox) {
379    if (bbox2.xmin() > bbox1.xmax() || bbox2.xmax() < bbox1.xmin() ||
380        bbox2.ymin() > bbox1.ymax() || bbox2.ymax() < bbox1.ymin()) {
381      intersect_bbox->set_xmin(0);
382      intersect_bbox->set_ymin(0);
383      intersect_bbox->set_xmax(0);
384      intersect_bbox->set_ymax(0);
385    } else {
386      intersect_bbox->set_xmin(std::max(bbox1.xmin(), bbox2.xmin()));
387      intersect_bbox->set_ymin(std::max(bbox1.ymin(), bbox2.ymin()));
388      intersect_bbox->set_xmax(std::min(bbox1.xmax(), bbox2.xmax()));
389      intersect_bbox->set_ymax(std::min(bbox1.ymax(), bbox2.ymax()));
390    }
391  }
392  float BBoxSize(const NormalizedBBox& bbox, const bool normalized) {
393    if (bbox.xmax() < bbox.xmin() || bbox.ymax() < bbox.ymin()) {
394      return 0;
395    } else {
396      if (bbox.has_size()) {
397        return bbox.size();
398      } else {
399        float width = bbox.xmax() - bbox.xmin();
400        float height = bbox.ymax() - bbox.ymin();
401        if (normalized) {
402          return width * height;
403        } else {
404          return (width + 1) * (height + 1);
405        }
406      }
407    }
408  }
409  template <typename Dtype>
410  Dtype BBoxSize(const Dtype* bbox, const bool normalized) {
411    if (bbox[2] < bbox[0] || bbox[3] < bbox[1]) {
412      return Dtype(0.);
413    } else {
414      const Dtype width = bbox[2] - bbox[0];
415      const Dtype height = bbox[3] - bbox[1];
416      if (normalized) {
417        return width * height;
418      } else {
419        return (width + 1) * (height + 1);
420      }
421    }
422  }
423  template float BBoxSize(const float* bbox, const bool normalized);
424  template double BBoxSize(const double* bbox, const bool normalized);
425  void ClipBBox(const NormalizedBBox& bbox, NormalizedBBox* clip_bbox) {
426    clip_bbox->set_xmin(std::max(std::min(bbox.xmin(), 1.f), 0.f));
427    clip_bbox->set_ymin(std::max(std::min(bbox.ymin(), 1.f), 0.f));
428    clip_bbox->set_xmax(std::max(std::min(bbox.xmax(), 1.f), 0.f));
429    clip_bbox->set_ymax(std::max(std::min(bbox.ymax(), 1.f), 0.f));
430    clip_bbox->clear_size();
431    clip_bbox->set_size(BBoxSize(*clip_bbox));
432    clip_bbox->set_difficult(bbox.difficult());
433  }
434  void ClipBBox(const NormalizedBBox& bbox, const float height, const float width,
435                NormalizedBBox* clip_bbox) {
436    clip_bbox->set_xmin(std::max(std::min(bbox.xmin(), width), 0.f));
437    clip_bbox->set_ymin(std::max(std::min(bbox.ymin(), height), 0.f));
438    clip_bbox->set_xmax(std::max(std::min(bbox.xmax(), width), 0.f));
439    clip_bbox->set_ymax(std::max(std::min(bbox.ymax(), height), 0.f));
440    clip_bbox->clear_size();
441    clip_bbox->set_size(BBoxSize(*clip_bbox));
442    clip_bbox->set_difficult(bbox.difficult());
443  }
444  void ScaleBBox(const NormalizedBBox& bbox, const int height, const int width,
445                 NormalizedBBox* scale_bbox) {
446    scale_bbox->set_xmin(bbox.xmin() * width);
447    scale_bbox->set_ymin(bbox.ymin() * height);
448    scale_bbox->set_xmax(bbox.xmax() * width);
449    scale_bbox->set_ymax(bbox.ymax() * height);
450    scale_bbox->clear_size();
451    bool normalized = !(width > 1 || height > 1);
452    scale_bbox->set_size(BBoxSize(*scale_bbox, normalized));
453    scale_bbox->set_difficult(bbox.difficult());
454  }
455  void OutputBBox(const NormalizedBBox& bbox, const pair<int, int>& img_size,
456                  const bool has_resize, const ResizeParameter& resize_param,
457                  NormalizedBBox* out_bbox) {
458    const int height = img_size.first;
459    const int width = img_size.second;
460    NormalizedBBox temp_bbox = bbox;
461    if (has_resize && resize_param.resize_mode()) {
462      float resize_height = resize_param.height();
463      CHECK_GT(resize_height, 0);
464      float resize_width = resize_param.width();
465      CHECK_GT(resize_width, 0);
466      float resize_aspect = resize_width / resize_height;
467      int height_scale = resize_param.height_scale();
468      int width_scale = resize_param.width_scale();
469      float aspect = static_cast<float>(width) / height;
470      float padding;
471      NormalizedBBox source_bbox;
472      switch (resize_param.resize_mode()) {
473        case ResizeParameter_Resize_mode_WARP:
474          ClipBBox(temp_bbox, &temp_bbox);
475          ScaleBBox(temp_bbox, height, width, out_bbox);
476          break;
477        case ResizeParameter_Resize_mode_FIT_LARGE_SIZE_AND_PAD:
478          if (aspect > resize_aspect) {
479            padding = (resize_height - resize_width / aspect) / 2;
480            source_bbox.set_xmin(0.);
481            source_bbox.set_ymin(padding / resize_height);
482            source_bbox.set_xmax(1.);
483            source_bbox.set_ymax(1. - padding / resize_height);
484          } else {
485            padding = (resize_width - resize_height * aspect) / 2;
486            source_bbox.set_xmin(padding / resize_width);
487            source_bbox.set_ymin(0.);
488            source_bbox.set_xmax(1. - padding / resize_width);
489            source_bbox.set_ymax(1.);
490          }
491          ProjectBBox(source_bbox, bbox, &temp_bbox);
492          ClipBBox(temp_bbox, &temp_bbox);
493          ScaleBBox(temp_bbox, height, width, out_bbox);
494          break;
495        case ResizeParameter_Resize_mode_FIT_SMALL_SIZE:
496          if (height_scale == 0 || width_scale == 0) {
497            ClipBBox(temp_bbox, &temp_bbox);
498            ScaleBBox(temp_bbox, height, width, out_bbox);
499          } else {
500            ScaleBBox(temp_bbox, height_scale, width_scale, out_bbox);
501            ClipBBox(*out_bbox, height, width, out_bbox);
502          }
503          break;
504        default:
505          LOG(FATAL) << "Unknown resize mode.";
506      }
507    } else {
508      ClipBBox(temp_bbox, &temp_bbox);
509      ScaleBBox(temp_bbox, height, width, out_bbox);
510    }
511  }
512  void LocateBBox(const NormalizedBBox& src_bbox, const NormalizedBBox& bbox,
513                  NormalizedBBox* loc_bbox) {
514    float src_width = src_bbox.xmax() - src_bbox.xmin();
515    float src_height = src_bbox.ymax() - src_bbox.ymin();
516    loc_bbox->set_xmin(src_bbox.xmin() + bbox.xmin() * src_width);
517    loc_bbox->set_ymin(src_bbox.ymin() + bbox.ymin() * src_height);
518    loc_bbox->set_xmax(src_bbox.xmin() + bbox.xmax() * src_width);
519    loc_bbox->set_ymax(src_bbox.ymin() + bbox.ymax() * src_height);
520    loc_bbox->set_difficult(bbox.difficult());
521  }
522  bool ProjectBBox(const NormalizedBBox& src_bbox, const NormalizedBBox& bbox,
523                   NormalizedBBox* proj_bbox) {
524    if (bbox.xmin() >= src_bbox.xmax() || bbox.xmax() <= src_bbox.xmin() ||
525        bbox.ymin() >= src_bbox.ymax() || bbox.ymax() <= src_bbox.ymin()) {
526      return false;
527    }
528    float src_width = src_bbox.xmax() - src_bbox.xmin();
529    float src_height = src_bbox.ymax() - src_bbox.ymin();
530    proj_bbox->set_xmin((bbox.xmin() - src_bbox.xmin()) / src_width);
531    proj_bbox->set_ymin((bbox.ymin() - src_bbox.ymin()) / src_height);
532    proj_bbox->set_xmax((bbox.xmax() - src_bbox.xmin()) / src_width);
533    proj_bbox->set_ymax((bbox.ymax() - src_bbox.ymin()) / src_height);
534    proj_bbox->set_difficult(bbox.difficult());
535    ClipBBox(*proj_bbox, proj_bbox);
536    if (BBoxSize(*proj_bbox) > 0) {
537      return true;
538    } else {
539      return false;
540    }
541  }
542  void ExtrapolateBBox(const ResizeParameter& param, const int height,
543      const int width, const NormalizedBBox& crop_bbox, NormalizedBBox* bbox) {
544    float height_scale = param.height_scale();
545    float width_scale = param.width_scale();
546    if (height_scale > 0 && width_scale > 0 &&
547        param.resize_mode() == ResizeParameter_Resize_mode_FIT_SMALL_SIZE) {
548      float orig_aspect = static_cast<float>(width) / height;
549      float resize_height = param.height();
550      float resize_width = param.width();
551      float resize_aspect = resize_width / resize_height;
552      if (orig_aspect < resize_aspect) {
553        resize_height = resize_width / orig_aspect;
554      } else {
555        resize_width = resize_height * orig_aspect;
556      }
557      float crop_height = resize_height * (crop_bbox.ymax() - crop_bbox.ymin());
558      float crop_width = resize_width * (crop_bbox.xmax() - crop_bbox.xmin());
559      CHECK_GE(crop_width, width_scale);
560      CHECK_GE(crop_height, height_scale);
561      bbox->set_xmin(bbox->xmin() * crop_width / width_scale);
562      bbox->set_xmax(bbox->xmax() * crop_width / width_scale);
563      bbox->set_ymin(bbox->ymin() * crop_height / height_scale);
564      bbox->set_ymax(bbox->ymax() * crop_height / height_scale);
565    }
566  }
567  float JaccardOverlap(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2,
568                       const bool normalized) {
569    NormalizedBBox intersect_bbox;
570    IntersectBBox(bbox1, bbox2, &intersect_bbox);
571    float intersect_width, intersect_height;
572    if (normalized) {
573      intersect_width = intersect_bbox.xmax() - intersect_bbox.xmin();
574      intersect_height = intersect_bbox.ymax() - intersect_bbox.ymin();
575    } else {
576      intersect_width = intersect_bbox.xmax() - intersect_bbox.xmin() + 1;
577      intersect_height = intersect_bbox.ymax() - intersect_bbox.ymin() + 1;
578    }
579    if (intersect_width > 0 && intersect_height > 0) {
580      float intersect_size = intersect_width * intersect_height;
581      float bbox1_size = BBoxSize(bbox1);
582      float bbox2_size = BBoxSize(bbox2);
583      return intersect_size / (bbox1_size + bbox2_size - intersect_size);
584    } else {
585      return 0.;
586    }
587  }
588  template <typename Dtype>
589  Dtype JaccardOverlap(const Dtype* bbox1, const Dtype* bbox2) {
590    if (bbox2[0] > bbox1[2] || bbox2[2] < bbox1[0] ||
591        bbox2[1] > bbox1[3] || bbox2[3] < bbox1[1]) {
592      return Dtype(0.);
593    } else {
594      const Dtype inter_xmin = std::max(bbox1[0], bbox2[0]);
595      const Dtype inter_ymin = std::max(bbox1[1], bbox2[1]);
596      const Dtype inter_xmax = std::min(bbox1[2], bbox2[2]);
597      const Dtype inter_ymax = std::min(bbox1[3], bbox2[3]);
598      const Dtype inter_width = inter_xmax - inter_xmin;
599      const Dtype inter_height = inter_ymax - inter_ymin;
600      const Dtype inter_size = inter_width * inter_height;
601      const Dtype bbox1_size = BBoxSize(bbox1);
602      const Dtype bbox2_size = BBoxSize(bbox2);
603      return inter_size / (bbox1_size + bbox2_size - inter_size);
604    }
605  }
606  template float JaccardOverlap(const float* bbox1, const float* bbox2);
607  template double JaccardOverlap(const double* bbox1, const double* bbox2);
608  float BBoxCoverage(const NormalizedBBox& bbox1, const NormalizedBBox& bbox2) {
609    NormalizedBBox intersect_bbox;
610    IntersectBBox(bbox1, bbox2, &intersect_bbox);
611    float intersect_size = BBoxSize(intersect_bbox);
612    if (intersect_size > 0) {
613      float bbox1_size = BBoxSize(bbox1);
614      CHECK_NE(bbox1_size, 0);
615      return intersect_size / bbox1_size;
616    } else {
617      return 0.;
618    }
619  }
620  bool MeetEmitConstraint(const NormalizedBBox& src_bbox,
621                          const NormalizedBBox& bbox,
622                          const EmitConstraint& emit_constraint) {
623    EmitType emit_type = emit_constraint.emit_type();
624    if (emit_type == EmitConstraint_EmitType_CENTER) {
625      float x_center = (bbox.xmin() + bbox.xmax()) / 2;
626      float y_center = (bbox.ymin() + bbox.ymax()) / 2;
627      if (x_center >= src_bbox.xmin() && x_center <= src_bbox.xmax() &&
628          y_center >= src_bbox.ymin() && y_center <= src_bbox.ymax()) {
629        return true;
630      } else {
631        return false;
632      }
633    } else if (emit_type == EmitConstraint_EmitType_MIN_OVERLAP) {
634      float bbox_coverage = BBoxCoverage(bbox, src_bbox);
635      return bbox_coverage > emit_constraint.emit_overlap();
636    } else {
637      LOG(FATAL) << "Unknown emit type.";
638      return false;
639    }
640  }
641  void EncodeBBox(
642      const NormalizedBBox& prior_bbox, const vector<float>& prior_variance,
643      const CodeType code_type, const bool encode_variance_in_target,
644      const NormalizedBBox& bbox, NormalizedBBox* encode_bbox) {
645    if (code_type == PriorBoxParameter_CodeType_CORNER) {
646      if (encode_variance_in_target) {
647        encode_bbox->set_xmin(bbox.xmin() - prior_bbox.xmin());
648        encode_bbox->set_ymin(bbox.ymin() - prior_bbox.ymin());
649        encode_bbox->set_xmax(bbox.xmax() - prior_bbox.xmax());
650        encode_bbox->set_ymax(bbox.ymax() - prior_bbox.ymax());
651      } else {
652        CHECK_EQ(prior_variance.size(), 4);
653        for (int i = 0; i < prior_variance.size(); ++i) {
654          CHECK_GT(prior_variance[i], 0);
655        }
656        encode_bbox->set_xmin(
657            (bbox.xmin() - prior_bbox.xmin()) / prior_variance[0]);
658        encode_bbox->set_ymin(
659            (bbox.ymin() - prior_bbox.ymin()) / prior_variance[1]);
660        encode_bbox->set_xmax(
661            (bbox.xmax() - prior_bbox.xmax()) / prior_variance[2]);
662        encode_bbox->set_ymax(
663            (bbox.ymax() - prior_bbox.ymax()) / prior_variance[3]);
664      }
665    } else if (code_type == PriorBoxParameter_CodeType_CENTER_SIZE) {
666      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
667      CHECK_GT(prior_width, 0);
668      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
669      CHECK_GT(prior_height, 0);
670      float prior_center_x = (prior_bbox.xmin() + prior_bbox.xmax()) / 2.;
671      float prior_center_y = (prior_bbox.ymin() + prior_bbox.ymax()) / 2.;
672      float bbox_width = bbox.xmax() - bbox.xmin();
673      CHECK_GT(bbox_width, 0);
674      float bbox_height = bbox.ymax() - bbox.ymin();
675      CHECK_GT(bbox_height, 0);
676      float bbox_center_x = (bbox.xmin() + bbox.xmax()) / 2.;
677      float bbox_center_y = (bbox.ymin() + bbox.ymax()) / 2.;
678      if (encode_variance_in_target) {
679        encode_bbox->set_xmin((bbox_center_x - prior_center_x) / prior_width);
680        encode_bbox->set_ymin((bbox_center_y - prior_center_y) / prior_height);
681        encode_bbox->set_xmax(log(bbox_width / prior_width));
682        encode_bbox->set_ymax(log(bbox_height / prior_height));
683      } else {
684        encode_bbox->set_xmin(
685            (bbox_center_x - prior_center_x) / prior_width / prior_variance[0]);
686        encode_bbox->set_ymin(
687            (bbox_center_y - prior_center_y) / prior_height / prior_variance[1]);
688        encode_bbox->set_xmax(
689            log(bbox_width / prior_width) / prior_variance[2]);
690        encode_bbox->set_ymax(
691            log(bbox_height / prior_height) / prior_variance[3]);
692      }
693    } else if (code_type == PriorBoxParameter_CodeType_CORNER_SIZE) {
694      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
695      CHECK_GT(prior_width, 0);
696      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
697      CHECK_GT(prior_height, 0);
698      if (encode_variance_in_target) {
699        encode_bbox->set_xmin((bbox.xmin() - prior_bbox.xmin()) / prior_width);
700        encode_bbox->set_ymin((bbox.ymin() - prior_bbox.ymin()) / prior_height);
701        encode_bbox->set_xmax((bbox.xmax() - prior_bbox.xmax()) / prior_width);
702        encode_bbox->set_ymax((bbox.ymax() - prior_bbox.ymax()) / prior_height);
703      } else {
704        CHECK_EQ(prior_variance.size(), 4);
705        for (int i = 0; i < prior_variance.size(); ++i) {
706          CHECK_GT(prior_variance[i], 0);
707        }
708        encode_bbox->set_xmin(
709            (bbox.xmin() - prior_bbox.xmin()) / prior_width / prior_variance[0]);
710        encode_bbox->set_ymin(
711            (bbox.ymin() - prior_bbox.ymin()) / prior_height / prior_variance[1]);
712        encode_bbox->set_xmax(
713            (bbox.xmax() - prior_bbox.xmax()) / prior_width / prior_variance[2]);
714        encode_bbox->set_ymax(
715            (bbox.ymax() - prior_bbox.ymax()) / prior_height / prior_variance[3]);
716      }
717    } else {
718      LOG(FATAL) << "Unknown LocLossType.";
719    }
720  }
721  void DecodeBBox(
722      const NormalizedBBox& prior_bbox, const vector<float>& prior_variance,
723      const CodeType code_type, const bool variance_encoded_in_target,
724      const bool clip_bbox, const NormalizedBBox& bbox,
725      NormalizedBBox* decode_bbox) {
726    if (code_type == PriorBoxParameter_CodeType_CORNER) {
727      if (variance_encoded_in_target) {
728        decode_bbox->set_xmin(prior_bbox.xmin() + bbox.xmin());
729        decode_bbox->set_ymin(prior_bbox.ymin() + bbox.ymin());
730        decode_bbox->set_xmax(prior_bbox.xmax() + bbox.xmax());
731        decode_bbox->set_ymax(prior_bbox.ymax() + bbox.ymax());
732      } else {
733        decode_bbox->set_xmin(
734            prior_bbox.xmin() + prior_variance[0] * bbox.xmin());
735        decode_bbox->set_ymin(
736            prior_bbox.ymin() + prior_variance[1] * bbox.ymin());
737        decode_bbox->set_xmax(
738            prior_bbox.xmax() + prior_variance[2] * bbox.xmax());
739        decode_bbox->set_ymax(
740            prior_bbox.ymax() + prior_variance[3] * bbox.ymax());
741      }
742    } else if (code_type == PriorBoxParameter_CodeType_CENTER_SIZE) {
743      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
744      CHECK_GT(prior_width, 0);
745      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
746      CHECK_GT(prior_height, 0);
747      float prior_center_x = (prior_bbox.xmin() + prior_bbox.xmax()) / 2.;
748      float prior_center_y = (prior_bbox.ymin() + prior_bbox.ymax()) / 2.;
749      float decode_bbox_center_x, decode_bbox_center_y;
750      float decode_bbox_width, decode_bbox_height;
751      if (variance_encoded_in_target) {
752        decode_bbox_center_x = bbox.xmin() * prior_width + prior_center_x;
753        decode_bbox_center_y = bbox.ymin() * prior_height + prior_center_y;
754        decode_bbox_width = exp(bbox.xmax()) * prior_width;
755        decode_bbox_height = exp(bbox.ymax()) * prior_height;
756      } else {
757        decode_bbox_center_x =
758            prior_variance[0] * bbox.xmin() * prior_width + prior_center_x;
759        decode_bbox_center_y =
760            prior_variance[1] * bbox.ymin() * prior_height + prior_center_y;
761        decode_bbox_width =
762            exp(prior_variance[2] * bbox.xmax()) * prior_width;
763        decode_bbox_height =
764            exp(prior_variance[3] * bbox.ymax()) * prior_height;
765      }
766      decode_bbox->set_xmin(decode_bbox_center_x - decode_bbox_width / 2.);
767      decode_bbox->set_ymin(decode_bbox_center_y - decode_bbox_height / 2.);
768      decode_bbox->set_xmax(decode_bbox_center_x + decode_bbox_width / 2.);
769      decode_bbox->set_ymax(decode_bbox_center_y + decode_bbox_height / 2.);
770    } else if (code_type == PriorBoxParameter_CodeType_CORNER_SIZE) {
771      float prior_width = prior_bbox.xmax() - prior_bbox.xmin();
772      CHECK_GT(prior_width, 0);
773      float prior_height = prior_bbox.ymax() - prior_bbox.ymin();
774      CHECK_GT(prior_height, 0);
775      if (variance_encoded_in_target) {
776        decode_bbox->set_xmin(prior_bbox.xmin() + bbox.xmin() * prior_width);
777        decode_bbox->set_ymin(prior_bbox.ymin() + bbox.ymin() * prior_height);
778        decode_bbox->set_xmax(prior_bbox.xmax() + bbox.xmax() * prior_width);
779        decode_bbox->set_ymax(prior_bbox.ymax() + bbox.ymax() * prior_height);
780      } else {
781        decode_bbox->set_xmin(
782            prior_bbox.xmin() + prior_variance[0] * bbox.xmin() * prior_width);
783        decode_bbox->set_ymin(
784            prior_bbox.ymin() + prior_variance[1] * bbox.ymin() * prior_height);
785        decode_bbox->set_xmax(
786            prior_bbox.xmax() + prior_variance[2] * bbox.xmax() * prior_width);
787        decode_bbox->set_ymax(
788            prior_bbox.ymax() + prior_variance[3] * bbox.ymax() * prior_height);
789      }
790    } else {
791      LOG(FATAL) << "Unknown LocLossType.";
792    }
793    float bbox_size = BBoxSize(*decode_bbox);
794    decode_bbox->set_size(bbox_size);
795    if (clip_bbox) {
796      ClipBBox(*decode_bbox, decode_bbox);
797    }
798  }
799  void DecodeBBoxes(const vector<NormalizedBBox>& prior_bboxes,
800                    const vector<vector<float> >& prior_variances,
801                    const CodeType code_type,
802                    const bool variance_encoded_in_target, const bool clip_bbox,
803                    const vector<NormalizedBBox>& bboxes,
804                    vector<NormalizedBBox>* decode_bboxes) {
805    CHECK_EQ(prior_bboxes.size(), prior_variances.size());
806    CHECK_EQ(prior_bboxes.size(), bboxes.size());
807    int num_bboxes = prior_bboxes.size();
808    if (num_bboxes >= 1) {
809      CHECK_EQ(prior_variances[0].size(), 4);
810    }
811    decode_bboxes->reserve(num_bboxes);
812    NormalizedBBox* result = new NormalizedBBox[num_bboxes];
813  #ifdef _OPENMP
814    #pragma omp parallel for
815  #endif
816    for (int i = 0; i < num_bboxes; ++i) {
817      DecodeBBox(prior_bboxes[i], prior_variances[i], code_type,
818                 variance_encoded_in_target, clip_bbox, bboxes[i], &result[i]);
819    }
820    decode_bboxes->assign(&result[0], &result[num_bboxes]);
821    delete[] result;
822  }
823  void DecodeBBoxesAll(const vector<LabelBBox>& all_loc_preds,
824      const vector<NormalizedBBox>& prior_bboxes,
825      const vector<vector<float> >& prior_variances,
826      const int num, const bool share_location,
827      const int num_loc_classes, const int background_label_id,
828      const CodeType code_type, const bool variance_encoded_in_target,
829      const bool clip, vector<LabelBBox>* all_decode_bboxes) {
830    CHECK_EQ(all_loc_preds.size(), num);
831    all_decode_bboxes->clear();
832    all_decode_bboxes->resize(num);
833  #ifdef _OPENMP
834    #pragma omp parallel for
835  #endif
836    for (int i = 0; i < num; ++i) {
837      for (int c = 0; c < num_loc_classes; ++c) {
838        int label = share_location ? -1 : c;
839        if (label == background_label_id) {
840          continue;
841        }
842        if (all_loc_preds[i].find(label) == all_loc_preds[i].end()) {
843          LOG(FATAL) << "Could not find location predictions for label " << label;
844        }
845        const vector<NormalizedBBox>& label_loc_preds =
846            all_loc_preds[i].find(label)->second;
847        DecodeBBoxes(prior_bboxes, prior_variances,
848                     code_type, variance_encoded_in_target, clip,
849                     label_loc_preds, &((*all_decode_bboxes)[i][label]));
850      }
851    }
852  }
853  void MatchBBox(const vector<NormalizedBBox>& gt_bboxes,
854      const vector<NormalizedBBox>& pred_bboxes, const int label,
855      const MatchType match_type, const float overlap_threshold,
856      const bool ignore_cross_boundary_bbox,
857      vector<int>* match_indices, vector<float>* match_overlaps) {
858    int num_pred = pred_bboxes.size();
859    match_indices->clear();
860    match_indices->resize(num_pred, -1);
861    match_overlaps->clear();
862    match_overlaps->resize(num_pred, 0.);
863    int num_gt = 0;
864    vector<int> gt_indices;
865    if (label == -1) {
866      num_gt = gt_bboxes.size();
867      for (int i = 0; i < num_gt; ++i) {
868        gt_indices.push_back(i);
869      }
870    } else {
871      for (int i = 0; i < gt_bboxes.size(); ++i) {
872        if (gt_bboxes[i].label() == label) {
873          num_gt++;
874          gt_indices.push_back(i);
875        }
876      }
877    }
878    if (num_gt == 0) {
879      return;
880    }
881    map<int, map<int, float> > overlaps;
882    for (int i = 0; i < num_pred; ++i) {
883      if (ignore_cross_boundary_bbox && IsCrossBoundaryBBox(pred_bboxes[i])) {
884        (*match_indices)[i] = -2;
885        continue;
886      }
887      for (int j = 0; j < num_gt; ++j) {
888        float overlap = JaccardOverlap(pred_bboxes[i], gt_bboxes[gt_indices[j]]);
889        if (overlap > 1e-6) {
890          (*match_overlaps)[i] = std::max((*match_overlaps)[i], overlap);
891          overlaps[i][j] = overlap;
892        }
893      }
894    }
895    vector<int> gt_pool;
896    for (int i = 0; i < num_gt; ++i) {
897      gt_pool.push_back(i);
898    }
899    while (gt_pool.size() > 0) {
900      int max_idx = -1;
901      int max_gt_idx = -1;
902      float max_overlap = -1;
903      for (map<int, map<int, float> >::iterator it = overlaps.begin();
904           it != overlaps.end(); ++it) {
905        int i = it->first;
906        if ((*match_indices)[i] != -1) {
907          continue;
908        }
909        for (int p = 0; p < gt_pool.size(); ++p) {
910          int j = gt_pool[p];
911          if (it->second.find(j) == it->second.end()) {
912            continue;
913          }
914          if (it->second[j] > max_overlap) {
915            max_idx = i;
916            max_gt_idx = j;
917            max_overlap = it->second[j];
918          }
919        }
920      }
921      if (max_idx == -1) {
922        break;
923      } else {
924        CHECK_EQ((*match_indices)[max_idx], -1);
925        (*match_indices)[max_idx] = gt_indices[max_gt_idx];
926        (*match_overlaps)[max_idx] = max_overlap;
927        gt_pool.erase(std::find(gt_pool.begin(), gt_pool.end(), max_gt_idx));
928      }
929    }
930    switch (match_type) {
931      case MultiBoxLossParameter_MatchType_BIPARTITE:
932        break;
933      case MultiBoxLossParameter_MatchType_PER_PREDICTION:
934        for (map<int, map<int, float> >::iterator it = overlaps.begin();
935             it != overlaps.end(); ++it) {
936          int i = it->first;
937          if ((*match_indices)[i] != -1) {
938            continue;
939          }
940          int max_gt_idx = -1;
941          float max_overlap = -1;
942          for (int j = 0; j < num_gt; ++j) {
943            if (it->second.find(j) == it->second.end()) {
944              continue;
945            }
946            float overlap = it->second[j];
947            if (overlap >= overlap_threshold && overlap > max_overlap) {
948              max_gt_idx = j;
949              max_overlap = overlap;
950            }
951          }
952          if (max_gt_idx != -1) {
953            CHECK_EQ((*match_indices)[i], -1);
954            (*match_indices)[i] = gt_indices[max_gt_idx];
955            (*match_overlaps)[i] = max_overlap;
956          }
957        }
958        break;
959      default:
960        LOG(FATAL) << "Unknown matching type.";
961        break;
962    }
963    return;
964  }
965  void FindMatches(const vector<LabelBBox>& all_loc_preds,
966        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
967        const vector<NormalizedBBox>& prior_bboxes,
968        const vector<vector<float> >& prior_variances,
969        const MultiBoxLossParameter& multibox_loss_param,
970        vector<map<int, vector<float> > >* all_match_overlaps,
971        vector<map<int, vector<int> > >* all_match_indices) {
972    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
973    const int num_classes = multibox_loss_param.num_classes();
974    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
975    const bool share_location = multibox_loss_param.share_location();
976    const int loc_classes = share_location ? 1 : num_classes;
977    const MatchType match_type = multibox_loss_param.match_type();
978    const float overlap_threshold = multibox_loss_param.overlap_threshold();
979    const bool use_prior_for_matching =
980        multibox_loss_param.use_prior_for_matching();
981    const int background_label_id = multibox_loss_param.background_label_id();
982    const CodeType code_type = multibox_loss_param.code_type();
983    const bool encode_variance_in_target =
984        multibox_loss_param.encode_variance_in_target();
985    const bool ignore_cross_boundary_bbox =
986        multibox_loss_param.ignore_cross_boundary_bbox();
987    int num = all_loc_preds.size();
988    for (int i = 0; i < num; ++i) {
989      map<int, vector<int> > match_indices;
990      map<int, vector<float> > match_overlaps;
991      if (all_gt_bboxes.find(i) == all_gt_bboxes.end()) {
992        all_match_indices->push_back(match_indices);
993        all_match_overlaps->push_back(match_overlaps);
994        continue;
995      }
996      const vector<NormalizedBBox>& gt_bboxes = all_gt_bboxes.find(i)->second;
997      if (!use_prior_for_matching) {
998        for (int c = 0; c < loc_classes; ++c) {
999          int label = share_location ? -1 : c;
1000          if (!share_location && label == background_label_id) {
1001            continue;
1002          }
1003          vector<NormalizedBBox> loc_bboxes;
1004          bool clip_bbox = false;
1005          DecodeBBoxes(prior_bboxes, prior_variances,
1006                       code_type, encode_variance_in_target, clip_bbox,
1007                       all_loc_preds[i].find(label)->second, &loc_bboxes);
1008          MatchBBox(gt_bboxes, loc_bboxes, label, match_type,
1009                    overlap_threshold, ignore_cross_boundary_bbox,
1010                    &match_indices[label], &match_overlaps[label]);
1011        }
1012      } else {
1013        vector<int> temp_match_indices;
1014        vector<float> temp_match_overlaps;
1015        const int label = -1;
1016        MatchBBox(gt_bboxes, prior_bboxes, label, match_type, overlap_threshold,
1017                  ignore_cross_boundary_bbox, &temp_match_indices,
1018                  &temp_match_overlaps);
1019        if (share_location) {
1020          match_indices[label] = temp_match_indices;
1021          match_overlaps[label] = temp_match_overlaps;
1022        } else {
1023          vector<int> gt_labels;
1024          for (int g = 0; g < gt_bboxes.size(); ++g) {
1025            gt_labels.push_back(gt_bboxes[g].label());
1026          }
1027          for (int c = 0; c < loc_classes; ++c) {
1028            if (c == background_label_id) {
1029              continue;
1030            }
1031            match_indices[c].resize(temp_match_indices.size(), -1);
1032            match_overlaps[c] = temp_match_overlaps;
1033            for (int m = 0; m < temp_match_indices.size(); ++m) {
1034              if (temp_match_indices[m] > -1) {
1035                const int gt_idx = temp_match_indices[m];
1036                CHECK_LT(gt_idx, gt_labels.size());
1037                if (c == gt_labels[gt_idx]) {
1038                  match_indices[c][m] = gt_idx;
1039                }
1040              }
1041            }
1042          }
1043        }
1044      }
1045      all_match_indices->push_back(match_indices);
1046      all_match_overlaps->push_back(match_overlaps);
1047    }
1048  }
1049  int CountNumMatches(const vector<map<int, vector<int> > >& all_match_indices,
1050                      const int num) {
1051    int num_matches = 0;
1052    for (int i = 0; i < num; ++i) {
1053      const map<int, vector<int> >& match_indices = all_match_indices[i];
1054      for (map<int, vector<int> >::const_iterator it = match_indices.begin();
1055           it != match_indices.end(); ++it) {
1056        const vector<int>& match_index = it->second;
1057        for (int m = 0; m < match_index.size(); ++m) {
1058          if (match_index[m] > -1) {
1059            ++num_matches;
1060          }
1061        }
1062      }
1063    }
1064    return num_matches;
1065  }
1066  inline bool IsEligibleMining(const MiningType mining_type, const int match_idx,
1067      const float match_overlap, const float neg_overlap) {
1068    if (mining_type == MultiBoxLossParameter_MiningType_MAX_NEGATIVE) {
1069      return match_idx == -1 && match_overlap < neg_overlap;
1070    } else if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1071      return true;
1072    } else {
1073      return false;
1074    }
1075  }
1076  template <typename Dtype>
1077  void MineHardExamples(const Blob<Dtype>& conf_blob,
1078      const vector<LabelBBox>& all_loc_preds,
1079      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1080      const vector<NormalizedBBox>& prior_bboxes,
1081      const vector<vector<float> >& prior_variances,
1082      const vector<map<int, vector<float> > >& all_match_overlaps,
1083      const MultiBoxLossParameter& multibox_loss_param,
1084      int* num_matches, int* num_negs,
1085      vector<map<int, vector<int> > >* all_match_indices,
1086      vector<vector<int> >* all_neg_indices) {
1087    int num = all_loc_preds.size();
1088    *num_matches = CountNumMatches(*all_match_indices, num);
1089    *num_negs = 0;
1090    int num_priors = prior_bboxes.size();
1091    CHECK_EQ(num_priors, prior_variances.size());
1092    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
1093    const int num_classes = multibox_loss_param.num_classes();
1094    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
1095    const int background_label_id = multibox_loss_param.background_label_id();
1096    const bool use_prior_for_nms = multibox_loss_param.use_prior_for_nms();
1097    const ConfLossType conf_loss_type = multibox_loss_param.conf_loss_type();
1098    const MiningType mining_type = multibox_loss_param.mining_type();
1099    if (mining_type == MultiBoxLossParameter_MiningType_NONE) {
1100      return;
1101    }
1102    const LocLossType loc_loss_type = multibox_loss_param.loc_loss_type();
1103    const float neg_pos_ratio = multibox_loss_param.neg_pos_ratio();
1104    const float neg_overlap = multibox_loss_param.neg_overlap();
1105    const CodeType code_type = multibox_loss_param.code_type();
1106    const bool encode_variance_in_target =
1107        multibox_loss_param.encode_variance_in_target();
1108    const bool has_nms_param = multibox_loss_param.has_nms_param();
1109    float nms_threshold = 0;
1110    int top_k = -1;
1111    if (has_nms_param) {
1112      nms_threshold = multibox_loss_param.nms_param().nms_threshold();
1113      top_k = multibox_loss_param.nms_param().top_k();
1114    }
1115    const int sample_size = multibox_loss_param.sample_size();
1116    vector<vector<float> > all_conf_loss;
1117  #ifdef CPU_ONLY
1118    ComputeConfLoss(conf_blob.cpu_data(), num, num_priors, num_classes,
1119        background_label_id, conf_loss_type, *all_match_indices, all_gt_bboxes,
1120        &all_conf_loss);
1121  #else
1122    ComputeConfLossGPU(conf_blob, num, num_priors, num_classes,
1123        background_label_id, conf_loss_type, *all_match_indices, all_gt_bboxes,
1124        &all_conf_loss);
1125  #endif
1126    vector<vector<float> > all_loc_loss;
1127    if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1128      Blob<Dtype> loc_pred, loc_gt;
1129      if (*num_matches != 0) {
1130        vector<int> loc_shape(2, 1);
1131        loc_shape[1] = *num_matches * 4;
1132        loc_pred.Reshape(loc_shape);
1133        loc_gt.Reshape(loc_shape);
1134        Dtype* loc_pred_data = loc_pred.mutable_cpu_data();
1135        Dtype* loc_gt_data = loc_gt.mutable_cpu_data();
1136        EncodeLocPrediction(all_loc_preds, all_gt_bboxes, *all_match_indices,
1137                            prior_bboxes, prior_variances, multibox_loss_param,
1138                            loc_pred_data, loc_gt_data);
1139      }
1140      ComputeLocLoss(loc_pred, loc_gt, *all_match_indices, num,
1141                     num_priors, loc_loss_type, &all_loc_loss);
1142    } else {
1143      for (int i = 0; i < num; ++i) {
1144        vector<float> loc_loss(num_priors, 0.f);
1145        all_loc_loss.push_back(loc_loss);
1146      }
1147    }
1148    for (int i = 0; i < num; ++i) {
1149      map<int, vector<int> >& match_indices = (*all_match_indices)[i];
1150      const map<int, vector<float> >& match_overlaps = all_match_overlaps[i];
1151      const vector<float>& conf_loss = all_conf_loss[i];
1152      const vector<float>& loc_loss = all_loc_loss[i];
1153      vector<float> loss;
1154      std::transform(conf_loss.begin(), conf_loss.end(), loc_loss.begin(),
1155                     std::back_inserter(loss), std::plus<float>());
1156      set<int> sel_indices;
1157      vector<int> neg_indices;
1158      for (map<int, vector<int> >::iterator it = match_indices.begin();
1159           it != match_indices.end(); ++it) {
1160        const int label = it->first;
1161        int num_sel = 0;
1162        vector<pair<float, int> > loss_indices;
1163        for (int m = 0; m < match_indices[label].size(); ++m) {
1164          if (IsEligibleMining(mining_type, match_indices[label][m],
1165              match_overlaps.find(label)->second[m], neg_overlap)) {
1166            loss_indices.push_back(std::make_pair(loss[m], m));
1167            ++num_sel;
1168          }
1169        }
1170        if (mining_type == MultiBoxLossParameter_MiningType_MAX_NEGATIVE) {
1171          int num_pos = 0;
1172          for (int m = 0; m < match_indices[label].size(); ++m) {
1173            if (match_indices[label][m] > -1) {
1174              ++num_pos;
1175            }
1176          }
1177          num_sel = std::min(static_cast<int>(num_pos * neg_pos_ratio), num_sel);
1178        } else if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE) {
1179          CHECK_GT(sample_size, 0);
1180          num_sel = std::min(sample_size, num_sel);
1181        }
1182        if (has_nms_param && nms_threshold > 0) {
1183          vector<float> sel_loss;
1184          vector<NormalizedBBox> sel_bboxes;
1185          if (use_prior_for_nms) {
1186            for (int m = 0; m < match_indices[label].size(); ++m) {
1187              if (IsEligibleMining(mining_type, match_indices[label][m],
1188                  match_overlaps.find(label)->second[m], neg_overlap)) {
1189                sel_loss.push_back(loss[m]);
1190                sel_bboxes.push_back(prior_bboxes[m]);
1191              }
1192            }
1193          } else {
1194            vector<NormalizedBBox> loc_bboxes;
1195            bool clip_bbox = false;
1196            DecodeBBoxes(prior_bboxes, prior_variances,
1197                         code_type, encode_variance_in_target, clip_bbox,
1198                         all_loc_preds[i].find(label)->second, &loc_bboxes);
1199            for (int m = 0; m < match_indices[label].size(); ++m) {
1200              if (IsEligibleMining(mining_type, match_indices[label][m],
1201                  match_overlaps.find(label)->second[m], neg_overlap)) {
1202                sel_loss.push_back(loss[m]);
1203                sel_bboxes.push_back(loc_bboxes[m]);
1204              }
1205            }
1206          }
1207          vector<int> nms_indices;
1208          ApplyNMS(sel_bboxes, sel_loss, nms_threshold, top_k, &nms_indices);
1209          if (nms_indices.size() < num_sel) {
1210            LOG(INFO) << "not enough sample after nms: " << nms_indices.size();
1211          }
1212          num_sel = std::min(static_cast<int>(nms_indices.size()), num_sel);
1213          for (int n = 0; n < num_sel; ++n) {
1214            sel_indices.insert(loss_indices[nms_indices[n]].second);
1215          }
1216        } else {
1217          std::sort(loss_indices.begin(), loss_indices.end(),
1218                    SortScorePairDescend<int>);
1219          for (int n = 0; n < num_sel; ++n) {
1220            sel_indices.insert(loss_indices[n].second);
1221          }
1222        }
1223        for (int m = 0; m < match_indices[label].size(); ++m) {
1224          if (match_indices[label][m] > -1) {
1225            if (mining_type == MultiBoxLossParameter_MiningType_HARD_EXAMPLE &&
1226                sel_indices.find(m) == sel_indices.end()) {
1227              match_indices[label][m] = -1;
1228              *num_matches -= 1;
1229            }
1230          } else if (match_indices[label][m] == -1) {
1231            if (sel_indices.find(m) != sel_indices.end()) {
1232              neg_indices.push_back(m);
1233              *num_negs += 1;
1234            }
1235          }
1236        }
1237      }
1238      all_neg_indices->push_back(neg_indices);
1239    }
1240  }
1241  template void MineHardExamples(const Blob<float>& conf_blob,
1242      const vector<LabelBBox>& all_loc_preds,
1243      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1244      const vector<NormalizedBBox>& prior_bboxes,
1245      const vector<vector<float> >& prior_variances,
1246      const vector<map<int, vector<float> > >& all_match_overlaps,
1247      const MultiBoxLossParameter& multibox_loss_param,
1248      int* num_matches, int* num_negs,
1249      vector<map<int, vector<int> > >* all_match_indices,
1250      vector<vector<int> >* all_neg_indices);
1251  template void MineHardExamples(const Blob<double>& conf_blob,
1252      const vector<LabelBBox>& all_loc_preds,
1253      const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1254      const vector<NormalizedBBox>& prior_bboxes,
1255      const vector<vector<float> >& prior_variances,
1256      const vector<map<int, vector<float> > >& all_match_overlaps,
1257      const MultiBoxLossParameter& multibox_loss_param,
1258      int* num_matches, int* num_negs,
1259      vector<map<int, vector<int> > >* all_match_indices,
1260      vector<vector<int> >* all_neg_indices);
1261  template <typename Dtype>
1262  void GetGroundTruth(const Dtype* gt_data, const int num_gt,
1263        const int background_label_id, const bool use_difficult_gt,
1264        map<int, vector<NormalizedBBox> >* all_gt_bboxes) {
1265    all_gt_bboxes->clear();
1266    for (int i = 0; i < num_gt; ++i) {
1267      int start_idx = i * 8;
1268      int item_id = gt_data[start_idx];
1269      if (item_id == -1) {
1270        continue;
1271      }
1272      int label = gt_data[start_idx + 1];
1273      CHECK_NE(background_label_id, label)
1274          << "Found background label in the dataset.";
1275      bool difficult = static_cast<bool>(gt_data[start_idx + 7]);
1276      if (!use_difficult_gt && difficult) {
1277        continue;
1278      }
1279      NormalizedBBox bbox;
1280      bbox.set_label(label);
1281      bbox.set_xmin(gt_data[start_idx + 3]);
1282      bbox.set_ymin(gt_data[start_idx + 4]);
1283      bbox.set_xmax(gt_data[start_idx + 5]);
1284      bbox.set_ymax(gt_data[start_idx + 6]);
1285      bbox.set_difficult(difficult);
1286      float bbox_size = BBoxSize(bbox);
1287      bbox.set_size(bbox_size);
1288      (*all_gt_bboxes)[item_id].push_back(bbox);
1289    }
1290  }
1291  template void GetGroundTruth(const float* gt_data, const int num_gt,
1292        const int background_label_id, const bool use_difficult_gt,
1293        map<int, vector<NormalizedBBox> >* all_gt_bboxes);
1294  template void GetGroundTruth(const double* gt_data, const int num_gt,
1295        const int background_label_id, const bool use_difficult_gt,
1296        map<int, vector<NormalizedBBox> >* all_gt_bboxes);
1297  template <typename Dtype>
1298  void GetGroundTruth(const Dtype* gt_data, const int num_gt,
1299        const int background_label_id, const bool use_difficult_gt,
1300        map<int, LabelBBox>* all_gt_bboxes) {
1301    all_gt_bboxes->clear();
1302    for (int i = 0; i < num_gt; ++i) {
1303      int start_idx = i * 8;
1304      int item_id = gt_data[start_idx];
1305      if (item_id == -1) {
1306        break;
1307      }
1308      NormalizedBBox bbox;
1309      int label = gt_data[start_idx + 1];
1310      CHECK_NE(background_label_id, label)
1311          << "Found background label in the dataset.";
1312      bool difficult = static_cast<bool>(gt_data[start_idx + 7]);
1313      if (!use_difficult_gt && difficult) {
1314        continue;
1315      }
1316      bbox.set_xmin(gt_data[start_idx + 3]);
1317      bbox.set_ymin(gt_data[start_idx + 4]);
1318      bbox.set_xmax(gt_data[start_idx + 5]);
1319      bbox.set_ymax(gt_data[start_idx + 6]);
1320      bbox.set_difficult(difficult);
1321      float bbox_size = BBoxSize(bbox);
1322      bbox.set_size(bbox_size);
1323      (*all_gt_bboxes)[item_id][label].push_back(bbox);
1324    }
1325  }
1326  template void GetGroundTruth(const float* gt_data, const int num_gt,
1327        const int background_label_id, const bool use_difficult_gt,
1328        map<int, LabelBBox>* all_gt_bboxes);
1329  template void GetGroundTruth(const double* gt_data, const int num_gt,
1330        const int background_label_id, const bool use_difficult_gt,
1331        map<int, LabelBBox>* all_gt_bboxes);
1332  template <typename Dtype>
1333  void GetLocPredictions(const Dtype* loc_data, const int num,
1334        const int num_preds_per_class, const int num_loc_classes,
1335        const bool share_location, vector<LabelBBox>* loc_preds) {
1336    loc_preds->clear();
1337    if (share_location) {
1338      CHECK_EQ(num_loc_classes, 1);
1339    }
1340    loc_preds->resize(num);
1341  #ifdef _OPENMP
1342    #pragma omp parallel for
1343  #endif
1344    for (int i = 0; i < num; ++i) {
1345      for (int c = 0; c < num_loc_classes; ++c) {
1346        int label = share_location ? -1 : c;
1347        if ((*loc_preds)[i].find(label) == (*loc_preds)[i].end()) {
1348          (*loc_preds)[i][label].resize(num_preds_per_class);
1349        } else {
1350          break;
1351        }
1352      }
1353    }
1354  #ifdef _OPENMP
1355    #if defined(_MSC_EXTENSIONS)
1356      #pragma omp parallel for
1357    #else
1358      #pragma omp parallel for collapse(3)
1359    #endif
1360  #endif
1361      for (int i = 0; i < num; ++i) {
1362        for (int p = 0; p < num_preds_per_class; ++p) {
1363          for (int c = 0; c < num_loc_classes; ++c) {
1364            int label = share_location ? -1 : c;
1365            (*loc_preds)[i][label][p].set_xmin(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4]);
1366            (*loc_preds)[i][label][p].set_ymin(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 1]);
1367            (*loc_preds)[i][label][p].set_xmax(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 2]);
1368            (*loc_preds)[i][label][p].set_ymax(loc_data[ i* num_preds_per_class * num_loc_classes * 4 + p * num_loc_classes * 4 + c * 4 + 3]);
1369        }
1370      }
1371    }
1372  }
1373  template void GetLocPredictions(const float* loc_data, const int num,
1374        const int num_preds_per_class, const int num_loc_classes,
1375        const bool share_location, vector<LabelBBox>* loc_preds);
1376  template void GetLocPredictions(const double* loc_data, const int num,
1377        const int num_preds_per_class, const int num_loc_classes,
1378        const bool share_location, vector<LabelBBox>* loc_preds);
1379  template <typename Dtype>
1380  void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1381        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1382        const vector<map<int, vector<int> > >& all_match_indices,
1383        const vector<NormalizedBBox>& prior_bboxes,
1384        const vector<vector<float> >& prior_variances,
1385        const MultiBoxLossParameter& multibox_loss_param,
1386        Dtype* loc_pred_data, Dtype* loc_gt_data) {
1387    int num = all_loc_preds.size();
1388    const CodeType code_type = multibox_loss_param.code_type();
1389    const bool encode_variance_in_target =
1390        multibox_loss_param.encode_variance_in_target();
1391    const bool bp_inside = multibox_loss_param.bp_inside();
1392    const bool use_prior_for_matching =
1393        multibox_loss_param.use_prior_for_matching();
1394    int count = 0;
1395    for (int i = 0; i < num; ++i) {
1396      for (map<int, vector<int> >::const_iterator
1397           it = all_match_indices[i].begin();
1398           it != all_match_indices[i].end(); ++it) {
1399        const int label = it->first;
1400        const vector<int>& match_index = it->second;
1401        CHECK(all_loc_preds[i].find(label) != all_loc_preds[i].end());
1402        const vector<NormalizedBBox>& loc_pred =
1403            all_loc_preds[i].find(label)->second;
1404        for (int j = 0; j < match_index.size(); ++j) {
1405          if (match_index[j] <= -1) {
1406            continue;
1407          }
1408          const int gt_idx = match_index[j];
1409          CHECK(all_gt_bboxes.find(i) != all_gt_bboxes.end());
1410          CHECK_LT(gt_idx, all_gt_bboxes.find(i)->second.size());
1411          const NormalizedBBox& gt_bbox = all_gt_bboxes.find(i)->second[gt_idx];
1412          NormalizedBBox gt_encode;
1413          CHECK_LT(j, prior_bboxes.size());
1414          EncodeBBox(prior_bboxes[j], prior_variances[j], code_type,
1415                     encode_variance_in_target, gt_bbox, &gt_encode);
1416          loc_gt_data[count * 4] = gt_encode.xmin();
1417          loc_gt_data[count * 4 + 1] = gt_encode.ymin();
1418          loc_gt_data[count * 4 + 2] = gt_encode.xmax();
1419          loc_gt_data[count * 4 + 3] = gt_encode.ymax();
1420          CHECK_LT(j, loc_pred.size());
1421          if (bp_inside) {
1422            NormalizedBBox match_bbox = prior_bboxes[j];
1423            if (!use_prior_for_matching) {
1424              const bool clip_bbox = false;
1425              DecodeBBox(prior_bboxes[j], prior_variances[j], code_type,
1426                         encode_variance_in_target, clip_bbox, loc_pred[j],
1427                         &match_bbox);
1428            }
1429            loc_pred_data[count * 4] =
1430                (match_bbox.xmin() < 0 || match_bbox.xmin() > 1) ?
1431                gt_encode.xmin() : loc_pred[j].xmin();
1432            loc_pred_data[count * 4 + 1] =
1433                (match_bbox.ymin() < 0 || match_bbox.ymin() > 1) ?
1434                gt_encode.ymin() : loc_pred[j].ymin();
1435            loc_pred_data[count * 4 + 2] =
1436                (match_bbox.xmax() < 0 || match_bbox.xmax() > 1) ?
1437                gt_encode.xmax() : loc_pred[j].xmax();
1438            loc_pred_data[count * 4 + 3] =
1439                (match_bbox.ymax() < 0 || match_bbox.ymax() > 1) ?
1440                gt_encode.ymax() : loc_pred[j].ymax();
1441          } else {
1442            loc_pred_data[count * 4] = loc_pred[j].xmin();
1443            loc_pred_data[count * 4 + 1] = loc_pred[j].ymin();
1444            loc_pred_data[count * 4 + 2] = loc_pred[j].xmax();
1445            loc_pred_data[count * 4 + 3] = loc_pred[j].ymax();
1446          }
1447          if (encode_variance_in_target) {
1448            for (int k = 0; k < 4; ++k) {
1449              CHECK_GT(prior_variances[j][k], 0);
1450              loc_pred_data[count * 4 + k] /= prior_variances[j][k];
1451              loc_gt_data[count * 4 + k] /= prior_variances[j][k];
1452            }
1453          }
1454          ++count;
1455        }
1456      }
1457    }
1458  }
1459  template void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1460        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1461        const vector<map<int, vector<int> > >& all_match_indices,
1462        const vector<NormalizedBBox>& prior_bboxes,
1463        const vector<vector<float> >& prior_variances,
1464        const MultiBoxLossParameter& multibox_loss_param,
1465        float* loc_pred_data, float* loc_gt_data);
1466  template void EncodeLocPrediction(const vector<LabelBBox>& all_loc_preds,
1467        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1468        const vector<map<int, vector<int> > >& all_match_indices,
1469        const vector<NormalizedBBox>& prior_bboxes,
1470        const vector<vector<float> >& prior_variances,
1471        const MultiBoxLossParameter& multibox_loss_param,
1472        double* loc_pred_data, double* loc_gt_data);
1473  template <typename Dtype>
1474  void ComputeLocLoss(const Blob<Dtype>& loc_pred, const Blob<Dtype>& loc_gt,
1475        const vector<map<int, vector<int> > >& all_match_indices,
1476        const int num, const int num_priors, const LocLossType loc_loss_type,
1477        vector<vector<float> >* all_loc_loss) {
1478    int loc_count = loc_pred.count();
1479    CHECK_EQ(loc_count, loc_gt.count());
1480    Blob<Dtype> diff;
1481    const Dtype* diff_data = NULL;
1482    if (loc_count != 0) {
1483      diff.Reshape(loc_pred.shape());
1484      caffe_sub(loc_count, loc_pred.cpu_data(), loc_gt.cpu_data(),
1485                diff.mutable_cpu_data());
1486      diff_data = diff.cpu_data();
1487    }
1488    CHECK_NOTNULL(diff_data);
1489    int count = 0;
1490    for (int i = 0; i < num; ++i) {
1491      vector<float> loc_loss(num_priors, 0.f);
1492      for (map<int, vector<int> >::const_iterator
1493           it = all_match_indices[i].begin();
1494           it != all_match_indices[i].end(); ++it) {
1495        const vector<int>& match_index = it->second;
1496        CHECK_EQ(num_priors, match_index.size());
1497        for (int j = 0; j < match_index.size(); ++j) {
1498          if (match_index[j] <= -1) {
1499            continue;
1500          }
1501          Dtype loss = 0;
1502          for (int k = 0; k < 4; ++k) {
1503            Dtype val = diff_data[count * 4 + k];
1504            if (loc_loss_type == MultiBoxLossParameter_LocLossType_SMOOTH_L1) {
1505              Dtype abs_val = fabs(val);
1506              if (abs_val < 1.) {
1507                loss += 0.5 * val * val;
1508              } else {
1509                loss += abs_val - 0.5;
1510              }
1511            } else if (loc_loss_type == MultiBoxLossParameter_LocLossType_L2) {
1512              loss += 0.5 * val * val;
1513            } else {
1514              LOG(FATAL) << "Unknown loc loss type.";
1515            }
1516          }
1517          loc_loss[j] = loss;
1518          ++count;
1519        }
1520      }
1521      all_loc_loss->push_back(loc_loss);
1522    }
1523  }
1524  template void ComputeLocLoss(const Blob<float>& loc_pred,
1525        const Blob<float>& loc_gt,
1526        const vector<map<int, vector<int> > >& all_match_indices,
1527        const int num, const int num_priors, const LocLossType loc_loss_type,
1528        vector<vector<float> >* all_loc_loss);
1529  template void ComputeLocLoss(const Blob<double>& loc_pred,
1530        const Blob<double>& loc_gt,
1531        const vector<map<int, vector<int> > >& all_match_indices,
1532        const int num, const int num_priors, const LocLossType loc_loss_type,
1533        vector<vector<float> >* all_loc_loss);
1534  template <typename Dtype>
1535  void GetConfidenceScores(const Dtype* conf_data, const int num,
1536                           const int num_preds_per_class, const int num_classes,
1537                           vector<map<int, vector<float> > >* conf_preds) {
1538    conf_preds->clear();
1539    conf_preds->resize(num);
1540    Dtype* buffer = new Dtype[num * num_preds_per_class * num_classes];
1541  #ifdef _OPENMP
1542    #if defined(_MSC_EXTENSIONS)
1543      #pragma omp parallel for
1544    #else
1545      #pragma omp parallel for collapse(3)
1546    #endif
1547  #endif
1548    for (int i = 0; i < num; ++i) {
1549      for (int c = 0; c < num_classes; ++c) {
1550        for (int p = 0; p < num_preds_per_class; ++p) {
1551          buffer[i * num_classes * num_preds_per_class + c * num_preds_per_class +
1552                 p] = conf_data[i * num_classes * num_preds_per_class +
1553                                p * num_classes + c];
1554        }
1555      }
1556    }
1557  #ifdef _OPENMP
1558    #pragma omp parallel for 
1559  #endif
1560    for (int i = 0; i < num; i++) {
1561      for (int c = 0; c < num_classes; ++c) {
1562        (*conf_preds)[i][c].reserve(num_preds_per_class);
1563        (*conf_preds)[i][c].assign(
1564            &buffer[i * num_classes * num_preds_per_class +
1565                    c * num_preds_per_class],
1566            &buffer[i * num_classes * num_preds_per_class +
1567                    c * num_preds_per_class + num_preds_per_class]);
1568      }
1569    }
1570    delete[] buffer;
1571  }
1572  template void GetConfidenceScores(const float* conf_data, const int num,
1573        const int num_preds_per_class, const int num_classes,
1574        vector<map<int, vector<float> > >* conf_preds);
1575  template void GetConfidenceScores(const double* conf_data, const int num,
1576        const int num_preds_per_class, const int num_classes,
1577        vector<map<int, vector<float> > >* conf_preds);
1578  template <typename Dtype>
1579  void GetConfidenceScores(const Dtype* conf_data, const int num,
1580        const int num_preds_per_class, const int num_classes,
1581        const bool class_major, vector<map<int, vector<float> > >* conf_preds) {
1582    conf_preds->clear();
1583    conf_preds->resize(num);
1584    for (int i = 0; i < num; ++i) {
1585      map<int, vector<float> >& label_scores = (*conf_preds)[i];
1586      if (class_major) {
1587        for (int c = 0; c < num_classes; ++c) {
1588          label_scores[c].assign(conf_data, conf_data + num_preds_per_class);
1589          conf_data += num_preds_per_class;
1590        }
1591      } else {
1592        for (int p = 0; p < num_preds_per_class; ++p) {
1593          int start_idx = p * num_classes;
1594          for (int c = 0; c < num_classes; ++c) {
1595            label_scores[c].push_back(conf_data[start_idx + c]);
1596          }
1597        }
1598        conf_data += num_preds_per_class * num_classes;
1599      }
1600    }
1601  }
1602  template void GetConfidenceScores(const float* conf_data, const int num,
1603        const int num_preds_per_class, const int num_classes,
1604        const bool class_major, vector<map<int, vector<float> > >* conf_preds);
1605  template void GetConfidenceScores(const double* conf_data, const int num,
1606        const int num_preds_per_class, const int num_classes,
1607        const bool class_major, vector<map<int, vector<float> > >* conf_preds);
1608  template <typename Dtype>
1609  void ComputeConfLoss(const Dtype* conf_data, const int num,
1610        const int num_preds_per_class, const int num_classes,
1611        const int background_label_id, const ConfLossType loss_type,
1612        vector<vector<float> >* all_conf_loss) {
1613    all_conf_loss->clear();
1614    for (int i = 0; i < num; ++i) {
1615      vector<float> conf_loss;
1616      for (int p = 0; p < num_preds_per_class; ++p) {
1617        int start_idx = p * num_classes;
1618        int label = background_label_id;
1619        Dtype loss = 0;
1620        if (loss_type == MultiBoxLossParameter_ConfLossType_SOFTMAX) {
1621          CHECK_GE(label, 0);
1622          CHECK_LT(label, num_classes);
1623          Dtype maxval = -FLT_MAX;
1624          for (int c = 0; c < num_classes; ++c) {
1625            maxval = std::max<Dtype>(conf_data[start_idx + c], maxval);
1626          }
1627          Dtype sum = 0.;
1628          for (int c = 0; c < num_classes; ++c) {
1629            sum += std::exp(conf_data[start_idx + c] - maxval);
1630          }
1631          Dtype prob = std::exp(conf_data[start_idx + label] - maxval) / sum;
1632          loss = -log(std::max(prob, Dtype(FLT_MIN)));
1633        } else if (loss_type == MultiBoxLossParameter_ConfLossType_LOGISTIC) {
1634          int target = 0;
<span onclick='openModal()' class='match'>1635          for (int c = 0; c < num_classes; ++c) {
1636            if (c == label) {
1637              target = 1;
1638            } else {
1639              target = 0;
1640            }
</span>1641            Dtype input = conf_data[start_idx + c];
1642            loss -= input * (target - (input >= 0)) -
1643                log(1 + exp(input - 2 * input * (input >= 0)));
1644          }
1645        } else {
1646          LOG(FATAL) << "Unknown conf loss type.";
1647        }
1648        conf_loss.push_back(loss);
1649      }
1650      conf_data += num_preds_per_class * num_classes;
1651      all_conf_loss->push_back(conf_loss);
1652    }
1653  }
1654  template void ComputeConfLoss(const float* conf_data, const int num,
1655        const int num_preds_per_class, const int num_classes,
1656        const int background_label_id, const ConfLossType loss_type,
1657        vector<vector<float> >* all_conf_loss);
1658  template void ComputeConfLoss(const double* conf_data, const int num,
1659        const int num_preds_per_class, const int num_classes,
1660        const int background_label_id, const ConfLossType loss_type,
1661        vector<vector<float> >* all_conf_loss);
1662  template <typename Dtype>
1663  void ComputeConfLoss(const Dtype* conf_data, const int num,
1664        const int num_preds_per_class, const int num_classes,
1665        const int background_label_id, const ConfLossType loss_type,
1666        const vector<map<int, vector<int> > >& all_match_indices,
1667        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1668        vector<vector<float> >* all_conf_loss) {
1669    CHECK_LT(background_label_id, num_classes);
1670    all_conf_loss->clear();
1671    for (int i = 0; i < num; ++i) {
1672      vector<float> conf_loss;
1673      const map<int, vector<int> >& match_indices = all_match_indices[i];
1674      for (int p = 0; p < num_preds_per_class; ++p) {
1675        int start_idx = p * num_classes;
1676        int label = background_label_id;
1677        for (map<int, vector<int> >::const_iterator it =
1678             match_indices.begin(); it != match_indices.end(); ++it) {
1679          const vector<int>& match_index = it->second;
1680          CHECK_EQ(match_index.size(), num_preds_per_class);
1681          if (match_index[p] > -1) {
1682            CHECK(all_gt_bboxes.find(i) != all_gt_bboxes.end());
1683            const vector<NormalizedBBox>& gt_bboxes =
1684                all_gt_bboxes.find(i)->second;
1685            CHECK_LT(match_index[p], gt_bboxes.size());
1686            label = gt_bboxes[match_index[p]].label();
1687            CHECK_GE(label, 0);
1688            CHECK_NE(label, background_label_id);
1689            CHECK_LT(label, num_classes);
1690            break;
1691          }
1692        }
1693        Dtype loss = 0;
1694        if (loss_type == MultiBoxLossParameter_ConfLossType_SOFTMAX) {
1695          CHECK_GE(label, 0);
1696          CHECK_LT(label, num_classes);
1697          Dtype maxval = conf_data[start_idx];
1698          for (int c = 1; c < num_classes; ++c) {
1699            maxval = std::max<Dtype>(conf_data[start_idx + c], maxval);
1700          }
1701          Dtype sum = 0.;
1702          for (int c = 0; c < num_classes; ++c) {
1703            sum += std::exp(conf_data[start_idx + c] - maxval);
1704          }
1705          Dtype prob = std::exp(conf_data[start_idx + label] - maxval) / sum;
1706          loss = -log(std::max(prob, Dtype(FLT_MIN)));
1707        } else if (loss_type == MultiBoxLossParameter_ConfLossType_LOGISTIC) {
1708          int target = 0;
1709          for (int c = 0; c < num_classes; ++c) {
1710            if (c == label) {
1711              target = 1;
1712            } else {
1713              target = 0;
1714            }
1715            Dtype input = conf_data[start_idx + c];
1716            loss -= input * (target - (input >= 0)) -
1717                log(1 + exp(input - 2 * input * (input >= 0)));
1718          }
1719        } else {
1720          LOG(FATAL) << "Unknown conf loss type.";
1721        }
1722        conf_loss.push_back(loss);
1723      }
1724      conf_data += num_preds_per_class * num_classes;
1725      all_conf_loss->push_back(conf_loss);
1726    }
1727  }
1728  template void ComputeConfLoss(const float* conf_data, const int num,
1729        const int num_preds_per_class, const int num_classes,
1730        const int background_label_id, const ConfLossType loss_type,
1731        const vector<map<int, vector<int> > >& all_match_indices,
1732        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1733        vector<vector<float> >* all_conf_loss);
1734  template void ComputeConfLoss(const double* conf_data, const int num,
1735        const int num_preds_per_class, const int num_classes,
1736        const int background_label_id, const ConfLossType loss_type,
1737        const vector<map<int, vector<int> > >& all_match_indices,
1738        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1739        vector<vector<float> >* all_conf_loss);
1740  template <typename Dtype>
1741  void EncodeConfPrediction(const Dtype* conf_data, const int num,
1742        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1743        const vector<map<int, vector<int> > >& all_match_indices,
1744        const vector<vector<int> >& all_neg_indices,
1745        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1746        Dtype* conf_pred_data, Dtype* conf_gt_data) {
1747    CHECK(multibox_loss_param.has_num_classes()) << "Must provide num_classes.";
1748    const int num_classes = multibox_loss_param.num_classes();
1749    CHECK_GE(num_classes, 1) << "num_classes should not be less than 1.";
1750    const int background_label_id = multibox_loss_param.background_label_id();
1751    const bool map_object_to_agnostic =
1752        multibox_loss_param.map_object_to_agnostic();
1753    if (map_object_to_agnostic) {
1754      if (background_label_id >= 0) {
1755        CHECK_EQ(num_classes, 2);
1756      } else {
1757        CHECK_EQ(num_classes, 1);
1758      }
1759    }
1760    const MiningType mining_type = multibox_loss_param.mining_type();
1761    bool do_neg_mining;
1762    if (multibox_loss_param.has_do_neg_mining()) {
1763      LOG(WARNING) << "do_neg_mining is deprecated, use mining_type instead.";
1764      do_neg_mining = multibox_loss_param.do_neg_mining();
1765      CHECK_EQ(do_neg_mining,
1766               mining_type != MultiBoxLossParameter_MiningType_NONE);
1767    }
1768    do_neg_mining = mining_type != MultiBoxLossParameter_MiningType_NONE;
1769    const ConfLossType conf_loss_type = multibox_loss_param.conf_loss_type();
1770    int count = 0;
1771    for (int i = 0; i < num; ++i) {
1772      if (all_gt_bboxes.find(i) != all_gt_bboxes.end()) {
1773        const map<int, vector<int> >& match_indices = all_match_indices[i];
1774        for (map<int, vector<int> >::const_iterator it =
1775            match_indices.begin(); it != match_indices.end(); ++it) {
1776          const vector<int>& match_index = it->second;
1777          CHECK_EQ(match_index.size(), num_priors);
1778          for (int j = 0; j < num_priors; ++j) {
1779            if (match_index[j] <= -1) {
1780              continue;
1781            }
1782            const int gt_label = map_object_to_agnostic ?
1783              background_label_id + 1 :
1784              all_gt_bboxes.find(i)->second[match_index[j]].label();
1785            int idx = do_neg_mining ? count : j;
1786            switch (conf_loss_type) {
1787              case MultiBoxLossParameter_ConfLossType_SOFTMAX:
1788                conf_gt_data[idx] = gt_label;
1789                break;
1790              case MultiBoxLossParameter_ConfLossType_LOGISTIC:
1791                conf_gt_data[idx * num_classes + gt_label] = 1;
1792                break;
1793              default:
1794                LOG(FATAL) << "Unknown conf loss type.";
1795            }
1796            if (do_neg_mining) {
1797              caffe_copy<Dtype>(num_classes, conf_data + j * num_classes,
1798                  conf_pred_data + count * num_classes);
1799              ++count;
1800            }
1801          }
1802        }
1803        if (do_neg_mining) {
1804          for (int n = 0; n < all_neg_indices[i].size(); ++n) {
1805            int j = all_neg_indices[i][n];
1806            CHECK_LT(j, num_priors);
1807            caffe_copy<Dtype>(num_classes, conf_data + j * num_classes,
1808                conf_pred_data + count * num_classes);
1809            switch (conf_loss_type) {
1810              case MultiBoxLossParameter_ConfLossType_SOFTMAX:
1811                conf_gt_data[count] = background_label_id;
1812                break;
1813              case MultiBoxLossParameter_ConfLossType_LOGISTIC:
1814                if (background_label_id >= 0 &&
1815                    background_label_id < num_classes) {
1816                  conf_gt_data[count * num_classes + background_label_id] = 1;
1817                }
1818                break;
1819              default:
1820                LOG(FATAL) << "Unknown conf loss type.";
1821            }
1822            ++count;
1823          }
1824        }
1825      }
1826      if (do_neg_mining) {
1827        conf_data += num_priors * num_classes;
1828      } else {
1829        conf_gt_data += num_priors;
1830      }
1831    }
1832  }
1833  template void EncodeConfPrediction(const float* conf_data, const int num,
1834        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1835        const vector<map<int, vector<int> > >& all_match_indices,
1836        const vector<vector<int> >& all_neg_indices,
1837        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1838        float* conf_pred_data, float* conf_gt_data);
1839  template void EncodeConfPrediction(const double* conf_data, const int num,
1840        const int num_priors, const MultiBoxLossParameter& multibox_loss_param,
1841        const vector<map<int, vector<int> > >& all_match_indices,
1842        const vector<vector<int> >& all_neg_indices,
1843        const map<int, vector<NormalizedBBox> >& all_gt_bboxes,
1844        double* conf_pred_data, double* conf_gt_data);
1845  template <typename Dtype>
1846  void GetPriorBBoxes(const Dtype* prior_data, const int num_priors,
1847        vector<NormalizedBBox>* prior_bboxes,
1848        vector<vector<float> >* prior_variances) {
1849  #ifdef _OPENMP
1850    #pragma omp parallel for
1851  #endif
1852    for (int i = 0; i < num_priors; ++i) {
1853      NormalizedBBox bbox;
1854      bbox.set_xmin(prior_data[i*4]);
1855      bbox.set_ymin(prior_data[i*4 + 1]);
1856      bbox.set_xmax(prior_data[i*4 + 2]);
1857      bbox.set_ymax(prior_data[i*4 + 3]);
1858      bbox.set_size(BBoxSize(bbox));
1859      prior_bboxes->at(i) = bbox;
1860    }
1861    vector<float> var(4, 0);
1862    for (int i = 0; i < num_priors; ++i) {
1863      for (int j = 0; j < 4; ++j) {
1864        var.at(j) = (prior_data[(num_priors + i) * 4 + j]);
1865      }
1866      prior_variances->at(i) = var;
1867    }
1868  }
1869  template void GetPriorBBoxes(const float* prior_data, const int num_priors,
1870        vector<NormalizedBBox>* prior_bboxes,
1871        vector<vector<float> >* prior_variances);
1872  template void GetPriorBBoxes(const double* prior_data, const int num_priors,
1873        vector<NormalizedBBox>* prior_bboxes,
1874        vector<vector<float> >* prior_variances);
1875  template <typename Dtype>
1876  void GetDetectionResults(const Dtype* det_data, const int num_det,
1877        const int background_label_id,
1878        map<int, map<int, vector<NormalizedBBox> > >* all_detections) {
1879    all_detections->clear();
1880    for (int i = 0; i < num_det; ++i) {
1881      int start_idx = i * 7;
1882      int item_id = det_data[start_idx];
1883      if (item_id == -1) {
1884        continue;
1885      }
1886      int label = det_data[start_idx + 1];
1887      CHECK_NE(background_label_id, label)
1888          << "Found background label in the detection results.";
1889      NormalizedBBox bbox;
1890      bbox.set_score(det_data[start_idx + 2]);
1891      bbox.set_xmin(det_data[start_idx + 3]);
1892      bbox.set_ymin(det_data[start_idx + 4]);
1893      bbox.set_xmax(det_data[start_idx + 5]);
1894      bbox.set_ymax(det_data[start_idx + 6]);
1895      float bbox_size = BBoxSize(bbox);
1896      bbox.set_size(bbox_size);
1897      (*all_detections)[item_id][label].push_back(bbox);
1898    }
1899  }
1900  template void GetDetectionResults(const float* det_data, const int num_det,
1901        const int background_label_id,
1902        map<int, map<int, vector<NormalizedBBox> > >* all_detections);
1903  template void GetDetectionResults(const double* det_data, const int num_det,
1904        const int background_label_id,
1905        map<int, map<int, vector<NormalizedBBox> > >* all_detections);
1906  void GetTopKScoreIndex(const vector<float>& scores, const vector<int>& indices,
1907        const int top_k, vector<pair<float, int> >* score_index_vec) {
1908    CHECK_EQ(scores.size(), indices.size());
1909    for (int i = 0; i < scores.size(); ++i) {
1910      score_index_vec->push_back(std::make_pair(scores[i], indices[i]));
1911    }
1912    std::stable_sort(score_index_vec->begin(), score_index_vec->end(),
1913                     SortScorePairDescend<int>);
1914    if (top_k > -1 && top_k < score_index_vec->size()) {
1915      score_index_vec->resize(top_k);
1916    }
1917  }
1918  void GetMaxScoreIndex(const vector<float>& scores, const float threshold,
1919        const int top_k, vector<pair<float, int> >* score_index_vec) {
1920  #ifdef _OPENMP
1921    #pragma omp parallel for
1922  #endif
1923    for (int i = 0; i < scores.size(); ++i) {
1924      if (scores[i] > threshold) {
1925        score_index_vec->at(i) = std::make_pair(scores[i], i);
1926      }
1927    }
1928    std::stable_sort(score_index_vec->begin(), score_index_vec->end(),
1929                     SortScorePairDescend<int>);
1930    if (top_k > -1 && top_k < score_index_vec->size()) {
1931      score_index_vec->resize(top_k);
1932    }
1933  }
1934  template <typename Dtype>
1935  void GetMaxScoreIndex(const Dtype* scores, const int num, const float threshold,
1936        const int top_k, vector<pair<Dtype, int> >* score_index_vec) {
1937    for (int i = 0; i < num; ++i) {
1938      if (scores[i] > threshold) {
1939        score_index_vec->push_back(std::make_pair(scores[i], i));
1940      }
1941    }
1942    std::sort(score_index_vec->begin(), score_index_vec->end(),
1943              SortScorePairDescend<int>);
1944    if (top_k > -1 && top_k < score_index_vec->size()) {
1945      score_index_vec->resize(top_k);
1946    }
1947  }
1948  template
1949  void GetMaxScoreIndex(const float* scores, const int num, const float threshold,
1950        const int top_k, vector<pair<float, int> >* score_index_vec);
1951  template
1952  void GetMaxScoreIndex(const double* scores, const int num,
1953        const float threshold, const int top_k,
1954        vector<pair<double, int> >* score_index_vec);
1955  void ApplyNMS(const vector<NormalizedBBox>& bboxes, const vector<float>& scores,
1956        const float threshold, const int top_k, const bool reuse_overlaps,
1957        map<int, map<int, float> >* overlaps, vector<int>* indices) {
1958    CHECK_EQ(bboxes.size(), scores.size())
1959        << "bboxes and scores have different size.";
1960    vector<int> idx(boost::counting_iterator<int>(0),
1961                    boost::counting_iterator<int>(scores.size()));
1962    vector<pair<float, int> > score_index_vec;
1963    GetTopKScoreIndex(scores, idx, top_k, &score_index_vec);
1964    indices->clear();
1965    while (score_index_vec.size() != 0) {
1966      int best_idx = score_index_vec.front().second;
1967      const NormalizedBBox& best_bbox = bboxes[best_idx];
1968      if (BBoxSize(best_bbox) < 1e-5) {
1969        score_index_vec.erase(score_index_vec.begin());
1970        continue;
1971      }
1972      indices->push_back(best_idx);
1973      score_index_vec.erase(score_index_vec.begin());
1974      if (top_k > -1 && indices->size() >= top_k) {
1975        break;
1976      }
1977      for (vector<pair<float, int> >::iterator it = score_index_vec.begin();
1978           it != score_index_vec.end(); ) {
1979        int cur_idx = it->second;
1980        const NormalizedBBox& cur_bbox = bboxes[cur_idx];
1981        if (BBoxSize(cur_bbox) < 1e-5) {
1982          it = score_index_vec.erase(it);
1983          continue;
1984        }
1985        float cur_overlap = 0.;
1986        if (reuse_overlaps) {
1987          if (overlaps->find(best_idx) != overlaps->end() &&
1988              overlaps->find(best_idx)->second.find(cur_idx) !=
1989              (*overlaps)[best_idx].end()) {
1990            cur_overlap = (*overlaps)[best_idx][cur_idx];
1991          } else if (overlaps->find(cur_idx) != overlaps->end() &&
1992                     overlaps->find(cur_idx)->second.find(best_idx) !=
1993                     (*overlaps)[cur_idx].end()) {
1994            cur_overlap = (*overlaps)[cur_idx][best_idx];
1995          } else {
1996            cur_overlap = JaccardOverlap(best_bbox, cur_bbox);
1997            (*overlaps)[best_idx][cur_idx] = cur_overlap;
1998          }
1999        } else {
2000          cur_overlap = JaccardOverlap(best_bbox, cur_bbox);
2001        }
2002        if (cur_overlap > threshold) {
2003          it = score_index_vec.erase(it);
2004        } else {
2005          ++it;
2006        }
2007      }
2008    }
2009  }
2010  void ApplyNMS(const vector<NormalizedBBox>& bboxes, const vector<float>& scores,
2011        const float threshold, const int top_k, vector<int>* indices) {
2012    bool reuse_overlap = false;
2013    map<int, map<int, float> > overlaps;
2014    ApplyNMS(bboxes, scores, threshold, top_k, reuse_overlap, &overlaps, indices);
2015  }
2016  void ApplyNMS(const bool* overlapped, const int num, vector<int>* indices) {
2017    vector<int> index_vec(boost::counting_iterator<int>(0),
2018                          boost::counting_iterator<int>(num));
2019    indices->clear();
2020    while (index_vec.size() != 0) {
2021      int best_idx = index_vec.front();
2022      indices->push_back(best_idx);
2023      index_vec.erase(index_vec.begin());
2024      for (vector<int>::iterator it = index_vec.begin(); it != index_vec.end();) {
2025        int cur_idx = *it;
2026        if (overlapped[best_idx * num + cur_idx]) {
2027          it = index_vec.erase(it);
2028        } else {
2029          ++it;
2030        }
2031      }
2032    }
2033  }
2034  inline int clamp(const int v, const int a, const int b) {
2035    return v < a ? a : v > b ? b : v;
2036  }
2037  void ApplyNMSFast(const vector<NormalizedBBox>& bboxes,
2038                    const vector<float>& scores, const float score_threshold,
2039                    const float nms_threshold, const float eta, const int top_k,
2040                    vector<int>* indices) {
2041    CHECK_EQ(bboxes.size(), scores.size())
2042        << "bboxes and scores have different size.";
2043    vector<pair<float, int> > score_index_vec(scores.size());
2044    GetMaxScoreIndex(scores, score_threshold, top_k, &score_index_vec);
2045    float adaptive_threshold = nms_threshold;
2046    indices->clear();
2047  #ifdef ENABLE_NMS_OPTIMIZATION
2048    if (_may_i_use_cpu_feature(_FEATURE_AVX512CD | _FEATURE_AVX512F)) {
2049      if (score_index_vec.size() == 0) return;
2050      indices->resize(score_index_vec.size());
2051      int* p = (int*)malloc(sizeof(int) * score_index_vec.size());
2052      int num_out = 0;
2053      cpu_nms_avx512_caffe(p, &num_out, bboxes, score_index_vec, nms_threshold);
2054      indices->assign(p, p + num_out);
2055      free(p);
2056    } else {
2057  #endif
2058      while (score_index_vec.size() != 0) {
2059        const int idx = score_index_vec.front().second;
2060        bool keep = true;
2061        for (int k = 0; k < indices->size(); ++k) {
2062          if (keep) {
2063            const int kept_idx = (*indices)[k];
2064            float overlap = JaccardOverlap(bboxes[idx], bboxes[kept_idx]);
2065            keep = overlap <= adaptive_threshold;
2066          } else {
2067            break;
2068          }
2069        }
2070        if (keep) {
2071          indices->push_back(idx);
2072        }
2073        score_index_vec.erase(score_index_vec.begin());
2074        if (keep && eta < 1 && adaptive_threshold > 0.5) {
2075          adaptive_threshold *= eta;
2076        }
2077      }
2078  #ifdef ENABLE_NMS_OPTIMIZATION
2079    }
2080  #endif
2081  }
2082  template <typename Dtype>
2083  void ApplyNMSFast(const Dtype* bboxes, const Dtype* scores, const int num,
2084        const float score_threshold, const float nms_threshold,
2085        const float eta, const int top_k, vector<int>* indices) {
2086    vector<pair<Dtype, int> > score_index_vec;
2087    GetMaxScoreIndex(scores, num, score_threshold, top_k, &score_index_vec);
2088    float adaptive_threshold = nms_threshold;
2089    indices->clear();
2090    while (score_index_vec.size() != 0) {
2091      const int idx = score_index_vec.front().second;
2092      bool keep = true;
2093      for (int k = 0; k < indices->size(); ++k) {
2094        if (keep) {
2095          const int kept_idx = (*indices)[k];
2096          float overlap = JaccardOverlap(bboxes + idx * 4, bboxes + kept_idx * 4);
2097          keep = overlap <= adaptive_threshold;
2098        } else {
2099          break;
2100        }
2101      }
2102      if (keep) {
2103        indices->push_back(idx);
2104      }
2105      score_index_vec.erase(score_index_vec.begin());
2106      if (keep && eta < 1 && adaptive_threshold > 0.5) {
2107        adaptive_threshold *= eta;
2108      }
2109    }
2110  }
2111  template
2112  void ApplyNMSFast(const float* bboxes, const float* scores, const int num,
2113        const float score_threshold, const float nms_threshold,
2114        const float eta, const int top_k, vector<int>* indices);
2115  template
2116  void ApplyNMSFast(const double* bboxes, const double* scores, const int num,
2117        const float score_threshold, const float nms_threshold,
2118        const float eta, const int top_k, vector<int>* indices);
2119  void CumSum(const vector<pair<float, int> >& pairs, vector<int>* cumsum) {
2120    vector<pair<float, int> > sort_pairs = pairs;
2121    std::stable_sort(sort_pairs.begin(), sort_pairs.end(),
2122                     SortScorePairDescend<int>);
2123    cumsum->clear();
2124    for (int i = 0; i < sort_pairs.size(); ++i) {
2125      if (i == 0) {
2126        cumsum->push_back(sort_pairs[i].second);
2127      } else {
2128        cumsum->push_back(cumsum->back() + sort_pairs[i].second);
2129      }
2130    }
2131  }
2132  void ComputeAP(const vector<pair<float, int> >& tp, const int num_pos,
2133                 const vector<pair<float, int> >& fp, const string ap_version,
2134                 vector<float>* prec, vector<float>* rec, float* ap) {
2135    const float eps = 1e-6;
2136    CHECK_EQ(tp.size(), fp.size()) << "tp must have same size as fp.";
2137    const int num = tp.size();
2138    for (int i = 0; i < num; ++i) {
2139      CHECK_LE(fabs(tp[i].first - fp[i].first), eps);
2140      CHECK_EQ(tp[i].second, 1 - fp[i].second);
2141    }
2142    prec->clear();
2143    rec->clear();
2144    *ap = 0;
2145    if (tp.size() == 0 || num_pos == 0) {
2146      return;
2147    }
2148    vector<int> tp_cumsum;
2149    CumSum(tp, &tp_cumsum);
2150    CHECK_EQ(tp_cumsum.size(), num);
2151    vector<int> fp_cumsum;
2152    CumSum(fp, &fp_cumsum);
2153    CHECK_EQ(fp_cumsum.size(), num);
2154    for (int i = 0; i < num; ++i) {
2155      prec->push_back(static_cast<float>(tp_cumsum[i]) /
2156                      (tp_cumsum[i] + fp_cumsum[i]));
2157    }
2158    for (int i = 0; i < num; ++i) {
2159      CHECK_LE(tp_cumsum[i], num_pos);
2160      rec->push_back(static_cast<float>(tp_cumsum[i]) / num_pos);
2161    }
2162    if (ap_version == "11point") {
2163      vector<float> max_precs(11, 0.);
2164      int start_idx = num - 1;
2165      for (int j = 10; j >= 0; --j) {
2166        for (int i = start_idx; i >= 0 ; --i) {
2167          if ((*rec)[i] < j / 10.) {
2168            start_idx = i;
2169            if (j > 0) {
2170              max_precs[j-1] = max_precs[j];
2171            }
2172            break;
2173          } else {
2174            if (max_precs[j] < (*prec)[i]) {
2175              max_precs[j] = (*prec)[i];
2176            }
2177          }
2178        }
2179      }
2180      for (int j = 10; j >= 0; --j) {
2181        *ap += max_precs[j] / 11;
2182      }
2183    } else if (ap_version == "MaxIntegral") {
2184      float cur_rec = rec->back();
2185      float cur_prec = prec->back();
2186      for (int i = num - 2; i >= 0; --i) {
2187        cur_prec = std::max<float>((*prec)[i], cur_prec);
2188        if (fabs(cur_rec - (*rec)[i]) > eps) {
2189          *ap += cur_prec * fabs(cur_rec - (*rec)[i]);
2190        }
2191        cur_rec = (*rec)[i];
2192      }
2193      *ap += cur_rec * cur_prec;
2194    } else if (ap_version == "Integral") {
2195      float prev_rec = 0.;
2196      for (int i = 0; i < num; ++i) {
2197        if (fabs((*rec)[i] - prev_rec) > eps) {
2198          *ap += (*prec)[i] * fabs((*rec)[i] - prev_rec);
2199        }
2200        prev_rec = (*rec)[i];
2201      }
2202    } else {
2203      LOG(FATAL) << "Unknown ap_version: " << ap_version;
2204    }
2205  }
2206  #ifdef USE_OPENCV
2207  cv::Scalar HSV2RGB(const float h, const float s, const float v) {
2208    const int h_i = static_cast<int>(h * 6);
2209    const float f = h * 6 - h_i;
2210    const float p = v * (1 - s);
2211    const float q = v * (1 - f*s);
2212    const float t = v * (1 - (1 - f) * s);
2213    float r, g, b;
2214    switch (h_i) {
2215      case 0:
2216        r = v; g = t; b = p;
2217        break;
2218      case 1:
2219        r = q; g = v; b = p;
2220        break;
2221      case 2:
2222        r = p; g = v; b = t;
2223        break;
2224      case 3:
2225        r = p; g = q; b = v;
2226        break;
2227      case 4:
2228        r = t; g = p; b = v;
2229        break;
2230      case 5:
2231        r = v; g = p; b = q;
2232        break;
2233      default:
2234        r = 1; g = 1; b = 1;
2235        break;
2236    }
2237    return cv::Scalar(r * 255, g * 255, b * 255);
2238  }
2239  vector<cv::Scalar> GetColors(const int n) {
2240    vector<cv::Scalar> colors;
2241    cv::RNG rng(12345);
2242    const float golden_ratio_conjugate = 0.618033988749895;
2243    const float s = 0.3;
2244    const float v = 0.99;
2245    for (int i = 0; i < n; ++i) {
2246      const float h = std::fmod(rng.uniform(0.f, 1.f) + golden_ratio_conjugate,
2247                                1.f);
2248      colors.push_back(HSV2RGB(h, s, v));
2249    }
2250    return colors;
2251  }
2252  static clock_t start_clock = clock();
2253  static cv::VideoWriter cap_out;
2254  template <typename Dtype>
2255  void VisualizeBBox(const vector<cv::Mat>& images, const Blob<Dtype>* detections,
2256                     const float threshold, const vector<cv::Scalar>& colors,
2257                     const map<int, string>& label_to_display_name,
2258                     const string& save_file) {
2259    CHECK_EQ(detections->width(), 7);
2260    const int num_det = detections->height();
2261    const int num_img = images.size();
2262    if (num_det == 0 || num_img == 0) {
2263      return;
2264    }
2265    float fps = num_img / (static_cast<double>(clock() - start_clock) /
2266            CLOCKS_PER_SEC);
2267    const Dtype* detections_data = detections->cpu_data();
2268    const int width = images[0].cols;
2269    const int height = images[0].rows;
2270    vector<LabelBBox> all_detections(num_img);
2271    for (int i = 0; i < num_det; ++i) {
2272      const int img_idx = detections_data[i * 7];
2273      CHECK_LT(img_idx, num_img);
2274      const int label = detections_data[i * 7 + 1];
2275      const float score = detections_data[i * 7 + 2];
2276      if (score < threshold) {
2277        continue;
2278      }
2279      NormalizedBBox bbox;
2280      bbox.set_xmin(detections_data[i * 7 + 3] * width);
2281      bbox.set_ymin(detections_data[i * 7 + 4] * height);
2282      bbox.set_xmax(detections_data[i * 7 + 5] * width);
2283      bbox.set_ymax(detections_data[i * 7 + 6] * height);
2284      bbox.set_score(score);
2285      all_detections[img_idx][label].push_back(bbox);
2286    }
2287    int fontface = cv::FONT_HERSHEY_SIMPLEX;
2288    double scale = 1;
2289    int thickness = 2;
2290    int baseline = 0;
2291    char buffer[50];
2292    for (int i = 0; i < num_img; ++i) {
2293      cv::Mat image = images[i];
2294      snprintf(buffer, sizeof(buffer), "FPS: %.2f", fps);
2295      cv::Size text = cv::getTextSize(buffer, fontface, scale, thickness,
2296                                      &baseline);
2297      cv::rectangle(image, cv::Point(0, 0),
2298                    cv::Point(text.width, text.height + baseline),
2299                    CV_RGB(255, 255, 255), CV_FILLED);
2300      cv::putText(image, buffer, cv::Point(0, text.height + baseline / 2.),
2301                  fontface, scale, CV_RGB(0, 0, 0), thickness, 8);
2302      for (map<int, vector<NormalizedBBox> >::iterator it =
2303           all_detections[i].begin(); it != all_detections[i].end(); ++it) {
2304        int label = it->first;
2305        string label_name = "Unknown";
2306        if (label_to_display_name.find(label) != label_to_display_name.end()) {
2307          label_name = label_to_display_name.find(label)->second;
2308        }
2309        CHECK_LT(label, colors.size());
2310        const cv::Scalar& color = colors[label];
2311        const vector<NormalizedBBox>& bboxes = it->second;
2312        for (int j = 0; j < bboxes.size(); ++j) {
2313          cv::Point top_left_pt(bboxes[j].xmin(), bboxes[j].ymin());
2314          cv::Point bottom_right_pt(bboxes[j].xmax(), bboxes[j].ymax());
2315          cv::rectangle(image, top_left_pt, bottom_right_pt, color, 4);
2316          cv::Point bottom_left_pt(bboxes[j].xmin(), bboxes[j].ymax());
2317          snprintf(buffer, sizeof(buffer), "%s: %.2f", label_name.c_str(),
2318                   bboxes[j].score());
2319          cv::Size text = cv::getTextSize(buffer, fontface, scale, thickness,
2320                                          &baseline);
2321          cv::rectangle(
2322              image, bottom_left_pt + cv::Point(0, 0),
2323              bottom_left_pt + cv::Point(text.width, -text.height-baseline),
2324              color, CV_FILLED);
2325          cv::putText(image, buffer, bottom_left_pt - cv::Point(0, baseline),
2326                      fontface, scale, CV_RGB(0, 0, 0), thickness, 8);
2327        }
2328      }
2329      if (!save_file.empty()) {
2330        if (!cap_out.isOpened()) {
2331          cv::Size size(image.size().width, image.size().height);
2332          cv::VideoWriter outputVideo(save_file, CV_FOURCC('D', 'I', 'V', 'X'),
2333              30, size, true);
2334          cap_out = outputVideo;
2335        }
2336        cap_out.write(image);
2337      }
2338      cv::imshow("detections", image);
2339      if (cv::waitKey(1) == 27) {
2340        raise(SIGINT);
2341      }
2342    }
2343    start_clock = clock();
2344  }
2345  template
2346  void VisualizeBBox(const vector<cv::Mat>& images,
2347                     const Blob<float>* detections,
2348                     const float threshold, const vector<cv::Scalar>& colors,
2349                     const map<int, string>& label_to_display_name,
2350                     const string& save_file);
2351  template
2352  void VisualizeBBox(const vector<cv::Mat>& images,
2353                     const Blob<double>* detections,
2354                     const float threshold, const vector<cv::Scalar>& colors,
2355                     const map<int, string>& label_to_display_name,
2356                     const string& save_file);
2357  #endif  
2358  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cluster.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-bbox_util.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1663        for (int j = 0; j < N; ++j) {
1664          if (!Clusterer->ParamDesc[j].NonEssential) {
1665            Covariance[j + row_offset] = Statistics->CoVariance[j + row_offset];
1666          } else {
1667            Covariance[j + row_offset] = 0.0f;
1668          }
</pre></code></div>
                <div class="column column_space"><pre><code>1635          for (int c = 0; c < num_classes; ++c) {
1636            if (c == label) {
1637              target = 1;
1638            } else {
1639              target = 0;
1640            }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    