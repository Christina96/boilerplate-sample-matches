
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-strip_test.cc</h3>
            <pre><code>1  #include &quot;absl/strings/strip.h&quot;
2  #include &lt;cassert&gt;
3  #include &lt;cstdio&gt;
4  #include &lt;cstring&gt;
5  #include &quot;gmock/gmock.h&quot;
6  #include &quot;gtest/gtest.h&quot;
7  #include &quot;absl/strings/string_view.h&quot;
8  namespace {
9  TEST(Strip, ConsumePrefixOneChar) {
10    absl::string_view input(&quot;abc&quot;);
11    EXPECT_TRUE(absl::ConsumePrefix(&amp;input, &quot;a&quot;));
12    EXPECT_EQ(input, &quot;bc&quot;);
13    EXPECT_FALSE(absl::ConsumePrefix(&amp;input, &quot;x&quot;));
14    EXPECT_EQ(input, &quot;bc&quot;);
15    EXPECT_TRUE(absl::ConsumePrefix(&amp;input, &quot;b&quot;));
16    EXPECT_EQ(input, &quot;c&quot;);
17    EXPECT_TRUE(absl::ConsumePrefix(&amp;input, &quot;c&quot;));
18    EXPECT_EQ(input, &quot;&quot;);
19    EXPECT_FALSE(absl::ConsumePrefix(&amp;input, &quot;a&quot;));
20    EXPECT_EQ(input, &quot;&quot;);
21  }
22  TEST(Strip, ConsumePrefix) {
23    absl::string_view input(&quot;abcdef&quot;);
24    EXPECT_FALSE(absl::ConsumePrefix(&amp;input, &quot;abcdefg&quot;));
25    EXPECT_EQ(input, &quot;abcdef&quot;);
26    EXPECT_FALSE(absl::ConsumePrefix(&amp;input, &quot;abce&quot;));
27    EXPECT_EQ(input, &quot;abcdef&quot;);
28    EXPECT_TRUE(absl::ConsumePrefix(&amp;input, &quot;&quot;));
29    EXPECT_EQ(input, &quot;abcdef&quot;);
30    EXPECT_FALSE(absl::ConsumePrefix(&amp;input, &quot;abcdeg&quot;));
31    EXPECT_EQ(input, &quot;abcdef&quot;);
32    EXPECT_TRUE(absl::ConsumePrefix(&amp;input, &quot;abcdef&quot;));
33    EXPECT_EQ(input, &quot;&quot;);
34    input = &quot;abcdef&quot;;
35    EXPECT_TRUE(absl::ConsumePrefix(&amp;input, &quot;abcde&quot;));
36    EXPECT_EQ(input, &quot;f&quot;);
37  }
38  TEST(Strip, ConsumeSuffix) {
39    absl::string_view input(&quot;abcdef&quot;);
40    EXPECT_FALSE(absl::ConsumeSuffix(&amp;input, &quot;abcdefg&quot;));
41    EXPECT_EQ(input, &quot;abcdef&quot;);
42    EXPECT_TRUE(absl::ConsumeSuffix(&amp;input, &quot;&quot;));
43    EXPECT_EQ(input, &quot;abcdef&quot;);
44    EXPECT_TRUE(absl::ConsumeSuffix(&amp;input, &quot;def&quot;));
45    EXPECT_EQ(input, &quot;abc&quot;);
46    input = &quot;abcdef&quot;;
47    EXPECT_FALSE(absl::ConsumeSuffix(&amp;input, &quot;abcdeg&quot;));
48    EXPECT_EQ(input, &quot;abcdef&quot;);
49    EXPECT_TRUE(absl::ConsumeSuffix(&amp;input, &quot;f&quot;));
50    EXPECT_EQ(input, &quot;abcde&quot;);
51    EXPECT_TRUE(absl::ConsumeSuffix(&amp;input, &quot;abcde&quot;));
52    EXPECT_EQ(input, &quot;&quot;);
53  }
54  TEST(Strip, StripPrefix) {
55    const absl::string_view null_str;
56    EXPECT_EQ(absl::StripPrefix(&quot;foobar&quot;, &quot;foo&quot;), &quot;bar&quot;);
57    EXPECT_EQ(absl::StripPrefix(&quot;foobar&quot;, &quot;&quot;), &quot;foobar&quot;);
58    EXPECT_EQ(absl::StripPrefix(&quot;foobar&quot;, null_str), &quot;foobar&quot;);
59    EXPECT_EQ(absl::StripPrefix(&quot;foobar&quot;, &quot;foobar&quot;), &quot;&quot;);
60    EXPECT_EQ(absl::StripPrefix(&quot;foobar&quot;, &quot;bar&quot;), &quot;foobar&quot;);
61    EXPECT_EQ(absl::StripPrefix(&quot;foobar&quot;, &quot;foobarr&quot;), &quot;foobar&quot;);
62    EXPECT_EQ(absl::StripPrefix(&quot;&quot;, &quot;&quot;), &quot;&quot;);
63  }
64  TEST(Strip, StripSuffix) {
65    const absl::string_view null_str;
66    EXPECT_EQ(absl::StripSuffix(&quot;foobar&quot;, &quot;bar&quot;), &quot;foo&quot;);
67    EXPECT_EQ(absl::StripSuffix(&quot;foobar&quot;, &quot;&quot;), &quot;foobar&quot;);
68    EXPECT_EQ(absl::StripSuffix(&quot;foobar&quot;, null_str), &quot;foobar&quot;);
69    EXPECT_EQ(absl::StripSuffix(&quot;foobar&quot;, &quot;foobar&quot;), &quot;&quot;);
70    EXPECT_EQ(absl::StripSuffix(&quot;foobar&quot;, &quot;foo&quot;), &quot;foobar&quot;);
71    EXPECT_EQ(absl::StripSuffix(&quot;foobar&quot;, &quot;ffoobar&quot;), &quot;foobar&quot;);
72    EXPECT_EQ(absl::StripSuffix(&quot;&quot;, &quot;&quot;), &quot;&quot;);
73  }
74  TEST(Strip, RemoveExtraAsciiWhitespace) {
75    const char* inputs[] = {
76        &quot;No extra space&quot;,
77        &quot;  Leading whitespace&quot;,
<span onclick='openModal()' class='match'>78        &quot;Trailing whitespace  &quot;,
79        &quot;  Leading and trailing  &quot;,
80        &quot; Whitespace \t  in\v   middle  &quot;,
81        &quot;&#x27;Eeeeep!  \n Newlines!\n&quot;,
82        &quot;nospaces&quot;,
83    };
84    const char* outputs[] = {
85        &quot;No extra space&quot;,
86        &quot;Leading whitespace&quot;,
</span>87        &quot;Trailing whitespace&quot;,
88        &quot;Leading and trailing&quot;,
89        &quot;Whitespace in middle&quot;,
90        &quot;&#x27;Eeeeep! Newlines!&quot;,
91        &quot;nospaces&quot;,
92    };
93    int NUM_TESTS = 7;
94    for (int i = 0; i &lt; NUM_TESTS; i++) {
95      std::string s(inputs[i]);
96      absl::RemoveExtraAsciiWhitespace(&amp;s);
97      EXPECT_STREQ(outputs[i], s.c_str());
98    }
99    std::string zero_string = &quot;&quot;;
100    assert(zero_string.empty());
101    absl::RemoveExtraAsciiWhitespace(&amp;zero_string);
102    EXPECT_EQ(zero_string.size(), 0);
103    EXPECT_TRUE(zero_string.empty());
104  }
105  TEST(Strip, StripTrailingAsciiWhitespace) {
106    std::string test = &quot;foo  &quot;;
107    absl::StripTrailingAsciiWhitespace(&amp;test);
108    EXPECT_EQ(test, &quot;foo&quot;);
109    test = &quot;   &quot;;
110    absl::StripTrailingAsciiWhitespace(&amp;test);
111    EXPECT_EQ(test, &quot;&quot;);
112    test = &quot;&quot;;
113    absl::StripTrailingAsciiWhitespace(&amp;test);
114    EXPECT_EQ(test, &quot;&quot;);
115    test = &quot; abc\t&quot;;
116    absl::StripTrailingAsciiWhitespace(&amp;test);
117    EXPECT_EQ(test, &quot; abc&quot;);
118  }
119  TEST(String, StripLeadingAsciiWhitespace) {
120    absl::string_view orig = &quot;\t  \n\f\r\n\vfoo&quot;;
121    EXPECT_EQ(&quot;foo&quot;, absl::StripLeadingAsciiWhitespace(orig));
122    orig = &quot;\t  \n\f\r\v\n\t  \n\f\r\v\n&quot;;
123    EXPECT_EQ(absl::string_view(), absl::StripLeadingAsciiWhitespace(orig));
124  }
125  TEST(Strip, StripAsciiWhitespace) {
126    std::string test2 = &quot;\t  \f\r\n\vfoo \t\f\r\v\n&quot;;
127    absl::StripAsciiWhitespace(&amp;test2);
128    EXPECT_EQ(test2, &quot;foo&quot;);
129    std::string test3 = &quot;bar&quot;;
130    absl::StripAsciiWhitespace(&amp;test3);
131    EXPECT_EQ(test3, &quot;bar&quot;);
132    std::string test4 = &quot;\t  \f\r\n\vfoo&quot;;
133    absl::StripAsciiWhitespace(&amp;test4);
134    EXPECT_EQ(test4, &quot;foo&quot;);
135    std::string test5 = &quot;foo \t\f\r\v\n&quot;;
136    absl::StripAsciiWhitespace(&amp;test5);
137    EXPECT_EQ(test5, &quot;foo&quot;);
138    absl::string_view test6(&quot;\t  \f\r\n\vfoo \t\f\r\v\n&quot;);
139    test6 = absl::StripAsciiWhitespace(test6);
140    EXPECT_EQ(test6, &quot;foo&quot;);
141    test6 = absl::StripAsciiWhitespace(test6);
142    EXPECT_EQ(test6, &quot;foo&quot;);  
143  }
144  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-parse_test.cc</h3>
            <pre><code>1  #include &quot;absl/flags/parse.h&quot;
2  #include &lt;stdlib.h&gt;
3  #include &lt;fstream&gt;
4  #include &lt;iostream&gt;
5  #include &lt;string&gt;
6  #include &lt;vector&gt;
7  #include &quot;gmock/gmock.h&quot;
8  #include &quot;gtest/gtest.h&quot;
9  #include &quot;absl/base/internal/scoped_set_env.h&quot;
10  #include &quot;absl/flags/flag.h&quot;
11  #include &quot;absl/flags/internal/parse.h&quot;
12  #include &quot;absl/flags/internal/usage.h&quot;
13  #include &quot;absl/flags/reflection.h&quot;
14  #include &quot;absl/log/log.h&quot;
15  #include &quot;absl/strings/str_cat.h&quot;
16  #include &quot;absl/strings/string_view.h&quot;
17  #include &quot;absl/strings/substitute.h&quot;
18  #include &quot;absl/types/span.h&quot;
19  #ifdef _WIN32
20  #include &lt;windows.h&gt;
21  #endif
22  #define FLAG_MULT(x) F3(x)
23  #define TEST_FLAG_HEADER FLAG_HEADER_
24  #define F(name) ABSL_FLAG(int, name, 0, &quot;&quot;);
25  #define F1(name) \
26    F(name##1);    \
27    F(name##2);    \
28    F(name##3);    \
29    F(name##4);    \
30    F(name##5);
31  #define F2(name) \
32    F1(name##1);   \
33    F1(name##2);   \
34    F1(name##3);   \
35    F1(name##4);   \
36    F1(name##5);
37  #define F3(name) \
38    F2(name##1);   \
39    F2(name##2);   \
40    F2(name##3);   \
41    F2(name##4);   \
42    F2(name##5);
43  FLAG_MULT(TEST_FLAG_HEADER)
44  namespace {
45  using absl::base_internal::ScopedSetEnv;
46  struct UDT {
47    UDT() = default;
48    UDT(const UDT&amp;) = default;
49    UDT&amp; operator=(const UDT&amp;) = default;
50    UDT(int v) : value(v) {}  
51    int value;
52  };
53  bool AbslParseFlag(absl::string_view in, UDT* udt, std::string* err) {
54    if (in == &quot;A&quot;) {
55      udt-&gt;value = 1;
56      return true;
57    }
58    if (in == &quot;AAA&quot;) {
59      udt-&gt;value = 10;
60      return true;
61    }
62    *err = &quot;Use values A, AAA instead&quot;;
63    return false;
64  }
65  std::string AbslUnparseFlag(const UDT&amp; udt) {
66    return udt.value == 1 ? &quot;A&quot; : &quot;AAA&quot;;
67  }
68  std::string GetTestTmpDirEnvVar(const char* const env_var_name) {
69  #ifdef _WIN32
70    char buf[MAX_PATH];
71    auto get_res = GetEnvironmentVariableA(env_var_name, buf, sizeof(buf));
72    if (get_res &gt;= sizeof(buf) || get_res == 0) {
73      return &quot;&quot;;
74    }
75    return std::string(buf, get_res);
76  #else
77    const char* val = ::getenv(env_var_name);
78    if (val == nullptr) {
79      return &quot;&quot;;
80    }
81    return val;
82  #endif
83  }
84  const std::string&amp; GetTestTempDir() {
85    static std::string* temp_dir_name = []() -&gt; std::string* {
86      std::string* res = new std::string(GetTestTmpDirEnvVar(&quot;TEST_TMPDIR&quot;));
87      if (res-&gt;empty()) {
88        *res = GetTestTmpDirEnvVar(&quot;TMPDIR&quot;);
89      }
90      if (res-&gt;empty()) {
91  #ifdef _WIN32
92        char temp_path_buffer[MAX_PATH];
93        auto len = GetTempPathA(MAX_PATH, temp_path_buffer);
94        if (len &lt; MAX_PATH &amp;&amp; len != 0) {
95          std::string temp_dir_name = temp_path_buffer;
96          if (!absl::EndsWith(temp_dir_name, &quot;\\&quot;)) {
97            temp_dir_name.push_back(&#x27;\\&#x27;);
98          }
99          absl::StrAppend(&amp;temp_dir_name, &quot;parse_test.&quot;, GetCurrentProcessId());
100          if (CreateDirectoryA(temp_dir_name.c_str(), nullptr)) {
101            *res = temp_dir_name;
102          }
103        }
104  #else
105        char temp_dir_template[] = &quot;/tmp/parse_test.XXXXXX&quot;;
106        if (auto* unique_name = ::mkdtemp(temp_dir_template)) {
107          *res = unique_name;
108        }
109  #endif
110      }
111      if (res-&gt;empty()) {
112        LOG(FATAL) &lt;&lt; &quot;Failed to make temporary directory for data files&quot;;
113      }
114  #ifdef _WIN32
115      *res += &quot;\\&quot;;
116  #else
117      *res += &quot;/&quot;;
118  #endif
119      return res;
120    }();
121    return *temp_dir_name;
122  }
123  struct FlagfileData {
124    const absl::string_view file_name;
125    const absl::Span&lt;const char* const&gt; file_lines;
126  };
127  constexpr const char* const ff1_data[] = {
128      &quot;# comment    &quot;,
129      &quot;  # comment  &quot;,
130      &quot;&quot;,
131      &quot;     &quot;,
132      &quot;--int_flag=-1&quot;,
133      &quot;  --string_flag=q2w2  &quot;,
134      &quot;  ##   &quot;,
135      &quot;  --double_flag=0.1&quot;,
136      &quot;--bool_flag=Y  &quot;
137  };
138  constexpr const char* const ff2_data[] = {
139      &quot;# Setting legacy flag&quot;,
140      &quot;--legacy_int=1111&quot;,
141      &quot;--legacy_bool&quot;,
142      &quot;--nobool_flag&quot;,
143      &quot;--legacy_str=aqsw&quot;,
144      &quot;--int_flag=100&quot;,
145      &quot;   ## =============&quot;
146  };
147  const char* GetFlagfileFlag(const std::vector&lt;FlagfileData&gt;&amp; ffd,
148                              std::string&amp; flagfile_flag) {
149    flagfile_flag = &quot;--flagfile=&quot;;
150    absl::string_view separator;
151    for (const auto&amp; flagfile_data : ffd) {
152      std::string flagfile_name =
153          absl::StrCat(GetTestTempDir(), flagfile_data.file_name);
154      std::ofstream flagfile_out(flagfile_name);
155      for (auto line : flagfile_data.file_lines) {
156        flagfile_out &lt;&lt; absl::Substitute(line, GetTestTempDir()) &lt;&lt; &quot;\n&quot;;
157      }
158      absl::StrAppend(&amp;flagfile_flag, separator, flagfile_name);
159      separator = &quot;,&quot;;
160    }
161    return flagfile_flag.c_str();
162  }
163  }  
164  ABSL_FLAG(int, int_flag, 1, &quot;&quot;);
165  ABSL_FLAG(double, double_flag, 1.1, &quot;&quot;);
166  ABSL_FLAG(std::string, string_flag, &quot;a&quot;, &quot;&quot;);
167  ABSL_FLAG(bool, bool_flag, false, &quot;&quot;);
168  ABSL_FLAG(UDT, udt_flag, -1, &quot;&quot;);
169  ABSL_RETIRED_FLAG(int, legacy_int, 1, &quot;&quot;);
170  ABSL_RETIRED_FLAG(bool, legacy_bool, false, &quot;&quot;);
171  ABSL_RETIRED_FLAG(std::string, legacy_str, &quot;l&quot;, &quot;&quot;);
172  namespace {
173  namespace flags = absl::flags_internal;
174  using testing::AllOf;
175  using testing::ElementsAreArray;
176  using testing::HasSubstr;
177  class ParseTest : public testing::Test {
178   public:
179    ~ParseTest() override { flags::SetFlagsHelpMode(flags::HelpMode::kNone); }
180   private:
181    absl::FlagSaver flag_saver_;
182  };
183  template &lt;int N&gt;
184  flags::HelpMode InvokeParseAbslOnlyImpl(const char* (&amp;in_argv)[N]) {
185    std::vector&lt;char*&gt; positional_args;
186    std::vector&lt;absl::UnrecognizedFlag&gt; unrecognized_flags;
187    return flags::ParseAbseilFlagsOnlyImpl(N, const_cast&lt;char**&gt;(in_argv),
188                                           positional_args, unrecognized_flags,
189                                           flags::UsageFlagsAction::kHandleUsage);
190  }
191  template &lt;int N&gt;
192  void InvokeParseAbslOnly(const char* (&amp;in_argv)[N]) {
193    std::vector&lt;char*&gt; positional_args;
194    std::vector&lt;absl::UnrecognizedFlag&gt; unrecognized_flags;
195    absl::ParseAbseilFlagsOnly(2, const_cast&lt;char**&gt;(in_argv), positional_args,
196                               unrecognized_flags);
197  }
198  template &lt;int N&gt;
199  std::vector&lt;char*&gt; InvokeParseCommandLineImpl(const char* (&amp;in_argv)[N]) {
200    return flags::ParseCommandLineImpl(
201        N, const_cast&lt;char**&gt;(in_argv), flags::UsageFlagsAction::kHandleUsage,
202        flags::OnUndefinedFlag::kAbortIfUndefined, std::cerr);
203  }
204  template &lt;int N&gt;
205  std::vector&lt;char*&gt; InvokeParse(const char* (&amp;in_argv)[N]) {
206    return absl::ParseCommandLine(N, const_cast&lt;char**&gt;(in_argv));
207  }
208  template &lt;int N&gt;
209  void TestParse(const char* (&amp;in_argv)[N], int int_flag_value,
210                 double double_flag_val, absl::string_view string_flag_val,
211                 bool bool_flag_val, int exp_position_args = 0) {
212    auto out_args = InvokeParse(in_argv);
213    EXPECT_EQ(out_args.size(), 1 + exp_position_args);
214    EXPECT_STREQ(out_args[0], &quot;testbin&quot;);
215    EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), int_flag_value);
216    EXPECT_NEAR(absl::GetFlag(FLAGS_double_flag), double_flag_val, 0.0001);
217    EXPECT_EQ(absl::GetFlag(FLAGS_string_flag), string_flag_val);
218    EXPECT_EQ(absl::GetFlag(FLAGS_bool_flag), bool_flag_val);
219  }
220  TEST_F(ParseTest, TestEmptyArgv) {
221    const char* in_argv[] = {&quot;testbin&quot;};
222    auto out_args = InvokeParse(in_argv);
223    EXPECT_EQ(out_args.size(), 1);
224    EXPECT_STREQ(out_args[0], &quot;testbin&quot;);
225  }
226  TEST_F(ParseTest, TestValidIntArg) {
227    const char* in_args1[] = {
228        &quot;testbin&quot;,
229        &quot;--int_flag=10&quot;,
230    };
231    TestParse(in_args1, 10, 1.1, &quot;a&quot;, false);
232    const char* in_args2[] = {
233        &quot;testbin&quot;,
234        &quot;-int_flag=020&quot;,
235    };
236    TestParse(in_args2, 20, 1.1, &quot;a&quot;, false);
237    const char* in_args3[] = {
238        &quot;testbin&quot;,
239        &quot;--int_flag&quot;,
240        &quot;-30&quot;,
241    };
242    TestParse(in_args3, -30, 1.1, &quot;a&quot;, false);
243    const char* in_args4[] = {
244        &quot;testbin&quot;,
245        &quot;-int_flag&quot;,
246        &quot;0x21&quot;,
247    };
248    TestParse(in_args4, 33, 1.1, &quot;a&quot;, false);
249  }
250  TEST_F(ParseTest, TestValidDoubleArg) {
251    const char* in_args1[] = {
252        &quot;testbin&quot;,
253        &quot;--double_flag=2.3&quot;,
254    };
255    TestParse(in_args1, 1, 2.3, &quot;a&quot;, false);
256    const char* in_args2[] = {
257        &quot;testbin&quot;,
258        &quot;--double_flag=0x1.2&quot;,
259    };
260    TestParse(in_args2, 1, 1.125, &quot;a&quot;, false);
261    const char* in_args3[] = {
262        &quot;testbin&quot;,
263        &quot;--double_flag&quot;,
264        &quot;99.7&quot;,
265    };
266    TestParse(in_args3, 1, 99.7, &quot;a&quot;, false);
267    const char* in_args4[] = {
268        &quot;testbin&quot;,
269        &quot;--double_flag&quot;,
270        &quot;0x20.1&quot;,
271    };
272    TestParse(in_args4, 1, 32.0625, &quot;a&quot;, false);
273  }
274  TEST_F(ParseTest, TestValidStringArg) {
275    const char* in_args1[] = {
276        &quot;testbin&quot;,
277        &quot;--string_flag=aqswde&quot;,
278    };
279    TestParse(in_args1, 1, 1.1, &quot;aqswde&quot;, false);
280    const char* in_args2[] = {
281        &quot;testbin&quot;,
282        &quot;-string_flag=a=b=c&quot;,
283    };
284    TestParse(in_args2, 1, 1.1, &quot;a=b=c&quot;, false);
285    const char* in_args3[] = {
286        &quot;testbin&quot;,
287        &quot;--string_flag&quot;,
288        &quot;zaxscd&quot;,
289    };
290    TestParse(in_args3, 1, 1.1, &quot;zaxscd&quot;, false);
291    const char* in_args4[] = {
292        &quot;testbin&quot;,
293        &quot;-string_flag&quot;,
294        &quot;--int_flag&quot;,
295    };
296    TestParse(in_args4, 1, 1.1, &quot;--int_flag&quot;, false);
297    const char* in_args5[] = {
298        &quot;testbin&quot;,
299        &quot;--string_flag&quot;,
300        &quot;--no_a_flag=11&quot;,
301    };
302    TestParse(in_args5, 1, 1.1, &quot;--no_a_flag=11&quot;, false);
303  }
304  TEST_F(ParseTest, TestValidBoolArg) {
305    const char* in_args1[] = {
306        &quot;testbin&quot;,
307        &quot;--bool_flag&quot;,
308    };
309    TestParse(in_args1, 1, 1.1, &quot;a&quot;, true);
310    const char* in_args2[] = {
311        &quot;testbin&quot;,
312        &quot;--nobool_flag&quot;,
313    };
314    TestParse(in_args2, 1, 1.1, &quot;a&quot;, false);
315    const char* in_args3[] = {
316        &quot;testbin&quot;,
317        &quot;--bool_flag=true&quot;,
318    };
319    TestParse(in_args3, 1, 1.1, &quot;a&quot;, true);
320    const char* in_args4[] = {
321        &quot;testbin&quot;,
322        &quot;-bool_flag=false&quot;,
323    };
324    TestParse(in_args4, 1, 1.1, &quot;a&quot;, false);
325  }
326  TEST_F(ParseTest, TestValidUDTArg) {
327    const char* in_args1[] = {
328        &quot;testbin&quot;,
329        &quot;--udt_flag=A&quot;,
330    };
331    InvokeParse(in_args1);
332    EXPECT_EQ(absl::GetFlag(FLAGS_udt_flag).value, 1);
333    const char* in_args2[] = {&quot;testbin&quot;, &quot;--udt_flag&quot;, &quot;AAA&quot;};
334    InvokeParse(in_args2);
335    EXPECT_EQ(absl::GetFlag(FLAGS_udt_flag).value, 10);
336  }
337  TEST_F(ParseTest, TestValidMultipleArg) {
338    const char* in_args1[] = {
339        &quot;testbin&quot;,           &quot;--bool_flag&quot;,       &quot;--int_flag=2&quot;,
340        &quot;--double_flag=0.1&quot;, &quot;--string_flag=asd&quot;,
341    };
342    TestParse(in_args1, 2, 0.1, &quot;asd&quot;, true);
343    const char* in_args2[] = {
344        &quot;testbin&quot;, &quot;--string_flag=&quot;, &quot;--nobool_flag&quot;, &quot;--int_flag&quot;,
345        &quot;-011&quot;,    &quot;--double_flag&quot;,  &quot;-1e-2&quot;,
346    };
347    TestParse(in_args2, -11, -0.01, &quot;&quot;, false);
348    const char* in_args3[] = {
349        &quot;testbin&quot;,          &quot;--int_flag&quot;,         &quot;-0&quot;, &quot;--string_flag&quot;, &quot;\&quot;\&quot;&quot;,
350        &quot;--bool_flag=true&quot;, &quot;--double_flag=1e18&quot;,
351    };
352    TestParse(in_args3, 0, 1e18, &quot;\&quot;\&quot;&quot;, true);
353  }
354  TEST_F(ParseTest, TestPositionalArgs) {
355    const char* in_args1[] = {
356        &quot;testbin&quot;,
357        &quot;p1&quot;,
358        &quot;p2&quot;,
359    };
360    TestParse(in_args1, 1, 1.1, &quot;a&quot;, false, 2);
361    auto out_args1 = InvokeParse(in_args1);
362    EXPECT_STREQ(out_args1[1], &quot;p1&quot;);
363    EXPECT_STREQ(out_args1[2], &quot;p2&quot;);
364    const char* in_args2[] = {
365        &quot;testbin&quot;,
366        &quot;--int_flag=2&quot;,
367        &quot;p1&quot;,
368    };
369    TestParse(in_args2, 2, 1.1, &quot;a&quot;, false, 1);
370    auto out_args2 = InvokeParse(in_args2);
371    EXPECT_STREQ(out_args2[1], &quot;p1&quot;);
372    const char* in_args3[] = {&quot;testbin&quot;, &quot;p1&quot;,          &quot;--int_flag=3&quot;,
373                              &quot;p2&quot;,      &quot;--bool_flag&quot;, &quot;true&quot;};
374    TestParse(in_args3, 3, 1.1, &quot;a&quot;, true, 3);
375    auto out_args3 = InvokeParse(in_args3);
376    EXPECT_STREQ(out_args3[1], &quot;p1&quot;);
377    EXPECT_STREQ(out_args3[2], &quot;p2&quot;);
378    EXPECT_STREQ(out_args3[3], &quot;true&quot;);
379    const char* in_args4[] = {
380        &quot;testbin&quot;,
381        &quot;--&quot;,
382        &quot;p1&quot;,
383        &quot;p2&quot;,
384    };
385    TestParse(in_args4, 3, 1.1, &quot;a&quot;, true, 2);
386    auto out_args4 = InvokeParse(in_args4);
387    EXPECT_STREQ(out_args4[1], &quot;p1&quot;);
388    EXPECT_STREQ(out_args4[2], &quot;p2&quot;);
389    const char* in_args5[] = {
390        &quot;testbin&quot;, &quot;p1&quot;, &quot;--int_flag=4&quot;, &quot;--&quot;, &quot;--bool_flag&quot;, &quot;false&quot;, &quot;p2&quot;,
391    };
392    TestParse(in_args5, 4, 1.1, &quot;a&quot;, true, 4);
393    auto out_args5 = InvokeParse(in_args5);
394    EXPECT_STREQ(out_args5[1], &quot;p1&quot;);
395    EXPECT_STREQ(out_args5[2], &quot;--bool_flag&quot;);
396    EXPECT_STREQ(out_args5[3], &quot;false&quot;);
397    EXPECT_STREQ(out_args5[4], &quot;p2&quot;);
398  }
399  using ParseDeathTest = ParseTest;
400  TEST_F(ParseDeathTest, TestUndefinedArg) {
401    const char* in_args1[] = {
402        &quot;testbin&quot;,
403        &quot;--undefined_flag&quot;,
404    };
405    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
406                              &quot;Unknown command line flag &#x27;undefined_flag&#x27;&quot;);
407    const char* in_args2[] = {
408        &quot;testbin&quot;,
409        &quot;--noprefixed_flag&quot;,
410    };
411    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
412                              &quot;Unknown command line flag &#x27;noprefixed_flag&#x27;&quot;);
413    const char* in_args3[] = {
414        &quot;testbin&quot;,
415        &quot;--Int_flag=1&quot;,
416    };
417    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
418                              &quot;Unknown command line flag &#x27;Int_flag&#x27;&quot;);
419  }
420  TEST_F(ParseDeathTest, TestInvalidBoolFlagFormat) {
421    const char* in_args1[] = {
422        &quot;testbin&quot;,
423        &quot;--bool_flag=&quot;,
424    };
425    EXPECT_DEATH_IF_SUPPORTED(
426        InvokeParse(in_args1),
427        &quot;Missing the value after assignment for the boolean flag &#x27;bool_flag&#x27;&quot;);
428    const char* in_args2[] = {
429        &quot;testbin&quot;,
430        &quot;--nobool_flag=true&quot;,
431    };
432    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
433                 &quot;Negative form with assignment is not valid for the boolean &quot;
434                 &quot;flag &#x27;bool_flag&#x27;&quot;);
435  }
436  TEST_F(ParseDeathTest, TestInvalidNonBoolFlagFormat) {
437    const char* in_args1[] = {
438        &quot;testbin&quot;,
439        &quot;--nostring_flag&quot;,
440    };
441    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
442                 &quot;Negative form is not valid for the flag &#x27;string_flag&#x27;&quot;);
443    const char* in_args2[] = {
444        &quot;testbin&quot;,
445        &quot;--int_flag&quot;,
446    };
447    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
448                 &quot;Missing the value for the flag &#x27;int_flag&#x27;&quot;);
449  }
450  TEST_F(ParseDeathTest, TestInvalidUDTFlagFormat) {
451    const char* in_args1[] = {
452        &quot;testbin&quot;,
453        &quot;--udt_flag=1&quot;,
454    };
455    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
456                 &quot;Illegal value &#x27;1&#x27; specified for flag &#x27;udt_flag&#x27;; Use values A, &quot;
457                 &quot;AAA instead&quot;);
458    const char* in_args2[] = {
459        &quot;testbin&quot;,
460        &quot;--udt_flag&quot;,
461        &quot;AA&quot;,
462    };
463    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
464                 &quot;Illegal value &#x27;AA&#x27; specified for flag &#x27;udt_flag&#x27;; Use values &quot;
465                 &quot;A, AAA instead&quot;);
466  }
467  TEST_F(ParseDeathTest, TestFlagSuggestions) {
468    const char* in_args1[] = {
469        &quot;testbin&quot;,
470        &quot;--legacy_boo&quot;,
471    };
472    EXPECT_DEATH_IF_SUPPORTED(
473        InvokeParse(in_args1),
474        &quot;Unknown command line flag &#x27;legacy_boo&#x27;. Did you mean: legacy_bool ?&quot;);
475    const char* in_args2[] = {&quot;testbin&quot;, &quot;--foo&quot;, &quot;--undefok=foo1&quot;};
476    EXPECT_DEATH_IF_SUPPORTED(
477        InvokeParse(in_args2),
478        &quot;Unknown command line flag &#x27;foo&#x27;. Did you mean: foo1 \\(undefok\\)?&quot;);
479    const char* in_args3[] = {
480        &quot;testbin&quot;,
481        &quot;--nolegacy_ino&quot;,
482    };
483    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
484                              &quot;Unknown command line flag &#x27;nolegacy_ino&#x27;. Did &quot;
485                              &quot;you mean: nolegacy_bool, legacy_int ?&quot;);
486  }
487  TEST_F(ParseTest, GetHints) {
488    EXPECT_THAT(absl::flags_internal::GetMisspellingHints(&quot;legacy_boo&quot;),
489                testing::ContainerEq(std::vector&lt;std::string&gt;{&quot;legacy_bool&quot;}));
490    EXPECT_THAT(absl::flags_internal::GetMisspellingHints(&quot;nolegacy_itn&quot;),
491                testing::ContainerEq(std::vector&lt;std::string&gt;{&quot;legacy_int&quot;}));
492    EXPECT_THAT(absl::flags_internal::GetMisspellingHints(&quot;nolegacy_int1&quot;),
493                testing::ContainerEq(std::vector&lt;std::string&gt;{&quot;legacy_int&quot;}));
494    EXPECT_THAT(absl::flags_internal::GetMisspellingHints(&quot;nolegacy_int&quot;),
495                testing::ContainerEq(std::vector&lt;std::string&gt;{&quot;legacy_int&quot;}));
496    EXPECT_THAT(absl::flags_internal::GetMisspellingHints(&quot;nolegacy_ino&quot;),
497                testing::ContainerEq(
498                    std::vector&lt;std::string&gt;{&quot;nolegacy_bool&quot;, &quot;legacy_int&quot;}));
499    EXPECT_THAT(
500        absl::flags_internal::GetMisspellingHints(&quot;FLAG_HEADER_000&quot;).size(), 100);
501  }
502  TEST_F(ParseTest, TestLegacyFlags) {
503    const char* in_args1[] = {
504        &quot;testbin&quot;,
505        &quot;--legacy_int=11&quot;,
506    };
507    TestParse(in_args1, 1, 1.1, &quot;a&quot;, false);
508    const char* in_args2[] = {
509        &quot;testbin&quot;,
510        &quot;--legacy_bool&quot;,
511    };
512    TestParse(in_args2, 1, 1.1, &quot;a&quot;, false);
513    const char* in_args3[] = {
514        &quot;testbin&quot;,       &quot;--legacy_int&quot;, &quot;22&quot;,           &quot;--int_flag=2&quot;,
515        &quot;--legacy_bool&quot;, &quot;true&quot;,         &quot;--legacy_str&quot;, &quot;--string_flag=qwe&quot;,
516    };
517    TestParse(in_args3, 2, 1.1, &quot;a&quot;, false, 1);
518  }
519  TEST_F(ParseTest, TestSimpleValidFlagfile) {
520    std::string flagfile_flag;
521    const char* in_args1[] = {
522        &quot;testbin&quot;,
523        GetFlagfileFlag({{&quot;parse_test.ff1&quot;, absl::MakeConstSpan(ff1_data)}},
524                        flagfile_flag),
525    };
526    TestParse(in_args1, -1, 0.1, &quot;q2w2  &quot;, true);
527    const char* in_args2[] = {
528        &quot;testbin&quot;,
529        GetFlagfileFlag({{&quot;parse_test.ff2&quot;, absl::MakeConstSpan(ff2_data)}},
530                        flagfile_flag),
531    };
532    TestParse(in_args2, 100, 0.1, &quot;q2w2  &quot;, false);
533  }
534  TEST_F(ParseTest, TestValidMultiFlagfile) {
535    std::string flagfile_flag;
536    const char* in_args1[] = {
537        &quot;testbin&quot;,
538        GetFlagfileFlag({{&quot;parse_test.ff2&quot;, absl::MakeConstSpan(ff2_data)},
539                         {&quot;parse_test.ff1&quot;, absl::MakeConstSpan(ff1_data)}},
540                        flagfile_flag),
541    };
542    TestParse(in_args1, -1, 0.1, &quot;q2w2  &quot;, true);
543  }
544  TEST_F(ParseTest, TestFlagfileMixedWithRegularFlags) {
545    std::string flagfile_flag;
546    const char* in_args1[] = {
547        &quot;testbin&quot;, &quot;--int_flag=3&quot;,
548        GetFlagfileFlag({{&quot;parse_test.ff1&quot;, absl::MakeConstSpan(ff1_data)}},
549                        flagfile_flag),
550        &quot;-double_flag=0.2&quot;};
551    TestParse(in_args1, -1, 0.2, &quot;q2w2  &quot;, true);
552  }
553  TEST_F(ParseTest, TestFlagfileInFlagfile) {
554    std::string flagfile_flag;
555    constexpr const char* const ff3_data[] = {
556        &quot;--flagfile=$0/parse_test.ff1&quot;,
557        &quot;--flagfile=$0/parse_test.ff2&quot;,
558    };
559    GetFlagfileFlag({{&quot;parse_test.ff2&quot;, absl::MakeConstSpan(ff2_data)},
560                     {&quot;parse_test.ff1&quot;, absl::MakeConstSpan(ff1_data)}},
561                        flagfile_flag);
562    const char* in_args1[] = {
563        &quot;testbin&quot;,
564        GetFlagfileFlag({{&quot;parse_test.ff3&quot;, absl::MakeConstSpan(ff3_data)}},
565                        flagfile_flag),
566    };
567    TestParse(in_args1, 100, 0.1, &quot;q2w2  &quot;, false);
568  }
569  TEST_F(ParseDeathTest, TestInvalidFlagfiles) {
570    std::string flagfile_flag;
571    constexpr const char* const ff4_data[] = {
572      &quot;--unknown_flag=10&quot;
573    };
574    const char* in_args1[] = {
575        &quot;testbin&quot;,
576        GetFlagfileFlag({{&quot;parse_test.ff4&quot;,
577                          absl::MakeConstSpan(ff4_data)}}, flagfile_flag),
578    };
579    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
580                 &quot;Unknown command line flag &#x27;unknown_flag&#x27;&quot;);
581    constexpr const char* const ff5_data[] = {
582      &quot;--int_flag 10&quot;,
583    };
584    const char* in_args2[] = {
585        &quot;testbin&quot;,
586        GetFlagfileFlag({{&quot;parse_test.ff5&quot;,
587                          absl::MakeConstSpan(ff5_data)}}, flagfile_flag),
588    };
589    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
590                 &quot;Unknown command line flag &#x27;int_flag 10&#x27;&quot;);
591    constexpr const char* const ff6_data[] = {
<span onclick='openModal()' class='match'>592        &quot;--int_flag=10&quot;, &quot;--&quot;, &quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;,
593    };
594    const char* in_args3[] = {
595        &quot;testbin&quot;,
596        GetFlagfileFlag({{&quot;parse_test.ff6&quot;, absl::MakeConstSpan(ff6_data)}},
</span>597                        flagfile_flag),
598    };
599    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
600                 &quot;Flagfile can&#x27;t contain position arguments or --&quot;);
601    const char* in_args4[] = {
602        &quot;testbin&quot;,
603        &quot;--flagfile=invalid_flag_file&quot;,
604    };
605    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args4),
606                              &quot;Can&#x27;t open flagfile invalid_flag_file&quot;);
607    constexpr const char* const ff7_data[] = {
608        &quot;--int_flag=10&quot;,
609        &quot;*bin*&quot;,
610        &quot;--str_flag=aqsw&quot;,
611    };
612    const char* in_args5[] = {
613        &quot;testbin&quot;,
614        GetFlagfileFlag({{&quot;parse_test.ff7&quot;, absl::MakeConstSpan(ff7_data)}},
615                        flagfile_flag),
616    };
617    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args5),
618                 &quot;Unexpected line in the flagfile .*: \\*bin\\*&quot;);
619  }
620  TEST_F(ParseTest, TestReadingRequiredFlagsFromEnv) {
621    const char* in_args1[] = {&quot;testbin&quot;,
622                              &quot;--fromenv=int_flag,bool_flag,string_flag&quot;};
623    ScopedSetEnv set_int_flag(&quot;FLAGS_int_flag&quot;, &quot;33&quot;);
624    ScopedSetEnv set_bool_flag(&quot;FLAGS_bool_flag&quot;, &quot;True&quot;);
625    ScopedSetEnv set_string_flag(&quot;FLAGS_string_flag&quot;, &quot;AQ12&quot;);
626    TestParse(in_args1, 33, 1.1, &quot;AQ12&quot;, true);
627  }
628  TEST_F(ParseDeathTest, TestReadingUnsetRequiredFlagsFromEnv) {
629    const char* in_args1[] = {&quot;testbin&quot;, &quot;--fromenv=int_flag&quot;};
630    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
631                 &quot;FLAGS_int_flag not found in environment&quot;);
632  }
633  TEST_F(ParseDeathTest, TestRecursiveFlagsFromEnv) {
634    const char* in_args1[] = {&quot;testbin&quot;, &quot;--fromenv=tryfromenv&quot;};
635    ScopedSetEnv set_tryfromenv(&quot;FLAGS_tryfromenv&quot;, &quot;int_flag&quot;);
636    EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
637                              &quot;Infinite recursion on flag tryfromenv&quot;);
638  }
639  TEST_F(ParseTest, TestReadingOptionalFlagsFromEnv) {
640    const char* in_args1[] = {
641        &quot;testbin&quot;, &quot;--tryfromenv=int_flag,bool_flag,string_flag,other_flag&quot;};
642    ScopedSetEnv set_int_flag(&quot;FLAGS_int_flag&quot;, &quot;17&quot;);
643    ScopedSetEnv set_bool_flag(&quot;FLAGS_bool_flag&quot;, &quot;Y&quot;);
644    TestParse(in_args1, 17, 1.1, &quot;a&quot;, true);
645  }
646  TEST_F(ParseTest, TestReadingFlagsFromEnvMoxedWithRegularFlags) {
647    const char* in_args1[] = {
648        &quot;testbin&quot;,
649        &quot;--bool_flag=T&quot;,
650        &quot;--tryfromenv=int_flag,bool_flag&quot;,
651        &quot;--int_flag=-21&quot;,
652    };
653    ScopedSetEnv set_int_flag(&quot;FLAGS_int_flag&quot;, &quot;-15&quot;);
654    ScopedSetEnv set_bool_flag(&quot;FLAGS_bool_flag&quot;, &quot;F&quot;);
655    TestParse(in_args1, -21, 1.1, &quot;a&quot;, false);
656  }
657  TEST_F(ParseDeathTest, TestSimpleHelpFlagHandling) {
658    const char* in_args1[] = {
659        &quot;testbin&quot;,
660        &quot;--help&quot;,
661    };
662    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kImportant);
663    EXPECT_EXIT(InvokeParse(in_args1), testing::ExitedWithCode(1), &quot;&quot;);
664    const char* in_args2[] = {
665        &quot;testbin&quot;,
666        &quot;--help&quot;,
667        &quot;--int_flag=3&quot;,
668    };
669    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args2), flags::HelpMode::kImportant);
670    EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 3);
671    const char* in_args3[] = {&quot;testbin&quot;, &quot;--help&quot;, &quot;some_positional_arg&quot;};
672    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args3), flags::HelpMode::kImportant);
673  }
674  TEST_F(ParseTest, TestSubstringHelpFlagHandling) {
675    const char* in_args1[] = {
676        &quot;testbin&quot;,
677        &quot;--help=abcd&quot;,
678    };
679    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kMatch);
680    EXPECT_EQ(flags::GetFlagsHelpMatchSubstr(), &quot;abcd&quot;);
681  }
682  TEST_F(ParseDeathTest, TestVersionHandling) {
683    const char* in_args1[] = {
684        &quot;testbin&quot;,
685        &quot;--version&quot;,
686    };
687    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kVersion);
688  }
689  TEST_F(ParseTest, TestCheckArgsHandling) {
690    const char* in_args1[] = {&quot;testbin&quot;, &quot;--only_check_args&quot;, &quot;--int_flag=211&quot;};
691    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kOnlyCheckArgs);
692    EXPECT_EXIT(InvokeParseAbslOnly(in_args1), testing::ExitedWithCode(0), &quot;&quot;);
693    EXPECT_EXIT(InvokeParse(in_args1), testing::ExitedWithCode(0), &quot;&quot;);
694    const char* in_args2[] = {&quot;testbin&quot;, &quot;--only_check_args&quot;, &quot;--unknown_flag=a&quot;};
695    EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args2), flags::HelpMode::kOnlyCheckArgs);
696    EXPECT_EXIT(InvokeParseAbslOnly(in_args2), testing::ExitedWithCode(0), &quot;&quot;);
697    EXPECT_EXIT(InvokeParse(in_args2), testing::ExitedWithCode(1), &quot;&quot;);
698  }
699  TEST_F(ParseTest, WasPresentOnCommandLine) {
700    const char* in_args1[] = {
701        &quot;testbin&quot;,        &quot;arg1&quot;, &quot;--bool_flag&quot;,
702        &quot;--int_flag=211&quot;, &quot;arg2&quot;, &quot;--double_flag=1.1&quot;,
703        &quot;--string_flag&quot;,  &quot;asd&quot;,  &quot;--&quot;,
704        &quot;--some_flag&quot;,    &quot;arg4&quot;,
705    };
706    InvokeParse(in_args1);
707    EXPECT_TRUE(flags::WasPresentOnCommandLine(&quot;bool_flag&quot;));
708    EXPECT_TRUE(flags::WasPresentOnCommandLine(&quot;int_flag&quot;));
709    EXPECT_TRUE(flags::WasPresentOnCommandLine(&quot;double_flag&quot;));
710    EXPECT_TRUE(flags::WasPresentOnCommandLine(&quot;string_flag&quot;));
711    EXPECT_FALSE(flags::WasPresentOnCommandLine(&quot;some_flag&quot;));
712    EXPECT_FALSE(flags::WasPresentOnCommandLine(&quot;another_flag&quot;));
713  }
714  TEST_F(ParseTest, ParseAbseilFlagsOnlySuccess) {
715    const char* in_args[] = {
716        &quot;testbin&quot;,
717        &quot;arg1&quot;,
718        &quot;--bool_flag&quot;,
719        &quot;--int_flag=211&quot;,
720        &quot;arg2&quot;,
721        &quot;--double_flag=1.1&quot;,
722        &quot;--undef_flag1&quot;,
723        &quot;--undef_flag2=123&quot;,
724        &quot;--string_flag&quot;,
725        &quot;asd&quot;,
726        &quot;--&quot;,
727        &quot;--some_flag&quot;,
728        &quot;arg4&quot;,
729    };
730    std::vector&lt;char*&gt; positional_args;
731    std::vector&lt;absl::UnrecognizedFlag&gt; unrecognized_flags;
732    absl::ParseAbseilFlagsOnly(13, const_cast&lt;char**&gt;(in_args), positional_args,
733                               unrecognized_flags);
734    EXPECT_THAT(positional_args,
735                ElementsAreArray(
736                    {absl::string_view(&quot;testbin&quot;), absl::string_view(&quot;arg1&quot;),
737                     absl::string_view(&quot;arg2&quot;), absl::string_view(&quot;--some_flag&quot;),
738                     absl::string_view(&quot;arg4&quot;)}));
739    EXPECT_THAT(unrecognized_flags,
740                ElementsAreArray(
741                    {absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
742                                            &quot;undef_flag1&quot;),
743                     absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
744                                            &quot;undef_flag2&quot;)}));
745  }
746  TEST_F(ParseDeathTest, ParseAbseilFlagsOnlyFailure) {
747    const char* in_args[] = {
748        &quot;testbin&quot;,
749        &quot;--int_flag=21.1&quot;,
750    };
751    EXPECT_DEATH_IF_SUPPORTED(
752        InvokeParseAbslOnly(in_args),
753        &quot;Illegal value &#x27;21.1&#x27; specified for flag &#x27;int_flag&#x27;&quot;);
754  }
755  TEST_F(ParseTest, UndefOkFlagsAreIgnored) {
756    const char* in_args[] = {
757        &quot;testbin&quot;,           &quot;--undef_flag1&quot;,
758        &quot;--undef_flag2=123&quot;, &quot;--undefok=undef_flag2&quot;,
759        &quot;--undef_flag3&quot;,     &quot;value&quot;,
760    };
761    std::vector&lt;char*&gt; positional_args;
762    std::vector&lt;absl::UnrecognizedFlag&gt; unrecognized_flags;
763    absl::ParseAbseilFlagsOnly(6, const_cast&lt;char**&gt;(in_args), positional_args,
764                               unrecognized_flags);
765    EXPECT_THAT(positional_args, ElementsAreArray({absl::string_view(&quot;testbin&quot;),
766                                                   absl::string_view(&quot;value&quot;)}));
767    EXPECT_THAT(unrecognized_flags,
768                ElementsAreArray(
769                    {absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
770                                            &quot;undef_flag1&quot;),
771                     absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
772                                            &quot;undef_flag3&quot;)}));
773  }
774  TEST_F(ParseTest, AllUndefOkFlagsAreIgnored) {
775    const char* in_args[] = {
776        &quot;testbin&quot;,
777        &quot;--undef_flag1&quot;,
778        &quot;--undef_flag2=123&quot;,
779        &quot;--undefok=undef_flag2,undef_flag1,undef_flag3&quot;,
780        &quot;--undef_flag3&quot;,
781        &quot;value&quot;,
782        &quot;--&quot;,
783        &quot;--undef_flag4&quot;,
784    };
785    std::vector&lt;char*&gt; positional_args;
786    std::vector&lt;absl::UnrecognizedFlag&gt; unrecognized_flags;
787    absl::ParseAbseilFlagsOnly(8, const_cast&lt;char**&gt;(in_args), positional_args,
788                               unrecognized_flags);
789    EXPECT_THAT(positional_args,
790                ElementsAreArray({absl::string_view(&quot;testbin&quot;),
791                                  absl::string_view(&quot;value&quot;),
792                                  absl::string_view(&quot;--undef_flag4&quot;)}));
793    EXPECT_THAT(unrecognized_flags, testing::IsEmpty());
794  }
795  TEST_F(ParseDeathTest, ExitOnUnrecognizedFlagPrintsHelp) {
796    const char* in_args[] = {
797        &quot;testbin&quot;,
798        &quot;--undef_flag1&quot;,
799        &quot;--help=int_flag&quot;,
800    };
801    EXPECT_EXIT(InvokeParseCommandLineImpl(in_args), testing::ExitedWithCode(1),
802                AllOf(HasSubstr(&quot;Unknown command line flag &#x27;undef_flag1&#x27;&quot;),
803                      HasSubstr(&quot;Try --helpfull to get a list of all flags&quot;)));
804  }
805  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-strip_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-parse_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>78        &quot;Trailing whitespace  &quot;,
79        &quot;  Leading and trailing  &quot;,
80        &quot; Whitespace \t  in\v   middle  &quot;,
81        &quot;&#x27;Eeeeep!  \n Newlines!\n&quot;,
82        &quot;nospaces&quot;,
83    };
84    const char* outputs[] = {
85        &quot;No extra space&quot;,
86        &quot;Leading whitespace&quot;,
</pre></code></div>
                <div class="column column_space"><pre><code>592        &quot;--int_flag=10&quot;, &quot;--&quot;, &quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;,
593    };
594    const char* in_args3[] = {
595        &quot;testbin&quot;,
596        GetFlagfileFlag({{&quot;parse_test.ff6&quot;, absl::MakeConstSpan(ff6_data)}},
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    