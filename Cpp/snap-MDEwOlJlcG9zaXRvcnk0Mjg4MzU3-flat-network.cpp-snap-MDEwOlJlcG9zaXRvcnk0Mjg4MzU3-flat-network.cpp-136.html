
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 135, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</h3>
            <pre><code>1  void TNEANet::LoadNetworkShM(TShMIn&amp; ShMIn) {
2    MxNId = TInt(ShMIn);
3    MxEId = TInt(ShMIn);
4    LoadTNodeFunctor NodeFn;
5    NodeH.LoadShM(ShMIn, NodeFn);
6    EdgeH.LoadShM(ShMIn);
7    KeyToIndexTypeN.LoadShM(ShMIn);
8    KeyToIndexTypeE.LoadShM(ShMIn);
9    KeyToDenseN.LoadShM(ShMIn);
10    KeyToDenseE.LoadShM(ShMIn);
11    IntDefaultsN.LoadShM(ShMIn);
12    IntDefaultsE.LoadShM(ShMIn);
13    StrDefaultsN.LoadShM(ShMIn);
14    StrDefaultsE.LoadShM(ShMIn);
15    FltDefaultsE.LoadShM(ShMIn);
16    FltDefaultsE.LoadShM(ShMIn);
17    LoadVecFunctor vec_fn;
18    VecOfIntVecsN.LoadShM(ShMIn, vec_fn);
19    VecOfIntVecsE.LoadShM(ShMIn, vec_fn);
20    VecOfStrVecsN.Load(ShMIn);
21    VecOfStrVecsE.Load(ShMIn);
22    VecOfFltVecsN.Load(ShMIn);
23    VecOfFltVecsE.Load(ShMIn);
24    LoadVecOfVecFunctor vec_of_vec_fn;
25    VecOfIntVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
26    VecOfIntVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
27    VecOfFltVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
28    VecOfFltVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
29    LoadHashOfVecFunctor hash_of_vec_fn;
30    VecOfIntHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
31    VecOfIntHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
32    VecOfFltHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
33    VecOfFltHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
34    SAttrN.Load(ShMIn);
35    SAttrE.Load(ShMIn);
36  }
37  bool TNEANet::HasFlag(const TGraphFlag&amp; Flag) const {
38    return HasGraphFlag(TNEANet::TNet, Flag);
39  }
40  bool TNEANet::TNodeI::IsInNId(const int&amp; NId) const {
41    const TNode&amp; Node = NodeHI.GetDat();
42    for (int edge = 0; edge &lt; Node.GetInDeg(); edge++) {
43      if (NId == Graph-&gt;GetEdge(Node.GetInEId(edge)).GetSrcNId())
44        return true;
45    }
46    return false;
47  }
48  bool TNEANet::TNodeI::IsOutNId(const int&amp; NId) const {
49    const TNode&amp; Node = NodeHI.GetDat();
50    for (int edge = 0; edge &lt; Node.GetOutDeg(); edge++) {
51      if (NId == Graph-&gt;GetEdge(Node.GetOutEId(edge)).GetDstNId())
52        return true;
53    }
54    return false;
55  }
56  void TNEANet::AttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
57    Names = TVec&lt;TStr&gt;();
58    while (!NodeHI.IsEnd()) {
59      if (!NodeAttrIsDeleted(NId, NodeHI)) {
60        Names.Add(NodeHI.GetKey());
61      }
62      NodeHI++;
63    }  
64  }
65  void TNEANet::AttrValueNI(const TInt&amp; NId , TStrIntPrH::TIter NodeHI, TStrV&amp; Values) const {
66    Values = TVec&lt;TStr&gt;();
67    while (!NodeHI.IsEnd()) {
68      if (!NodeAttrIsDeleted(NId, NodeHI)) {
69        Values.Add(GetNodeAttrValue(NId, NodeHI));
70      }
71      NodeHI++;
72    }
73  }
74  void TNEANet::IntAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
75    Names = TVec&lt;TStr&gt;();
76    while (!NodeHI.IsEnd()) {
77      if (NodeHI.GetDat().Val1 == IntType &amp;&amp; !NodeAttrIsIntDeleted(NId, NodeHI)) {
78        Names.Add(NodeHI.GetKey());
79      }
80      NodeHI++;
81    }  
82  }
83  void TNEANet::IntAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TIntV&amp; Values) const {
84    Values = TVec&lt;TInt&gt;();
85    while (!NodeHI.IsEnd()) {
86      if (NodeHI.GetDat().Val1 == IntType &amp;&amp; !NodeAttrIsIntDeleted(NId, NodeHI)) {
87        TInt val = this-&gt;VecOfIntVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
88        Values.Add(val);
89      }
90      NodeHI++;
91    }  
92  }
93  void TNEANet::IntVAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
94    Names = TVec&lt;TStr&gt;();
95    while (!NodeHI.IsEnd()) {
96      if (NodeHI.GetDat().Val1 == IntVType) {
97        Names.Add(NodeHI.GetKey());
98      }
99      NodeHI++;
100    }  
101  }
102  void TNEANet::IntVAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TVec&lt;TIntV&gt;&amp; Values) const {
103    Values = TVec&lt;TIntV&gt;();
104    while (!NodeHI.IsEnd()) {
105      if (NodeHI.GetDat().Val1 == IntVType) {
106        TInt index = NodeHI.GetDat().Val2;
107        TStr attr =  NodeHI.GetKey();
108        TInt loc = CheckDenseOrSparseN(attr);
109        if (loc == 1) {
110          TIntV val = this-&gt;VecOfIntVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
111          if (val.Len() != 0) Values.Add(val);
112        } else {
113          const THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsN[index];
114          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
115            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
116          }
117        }
118      }
119      NodeHI++;
120    }
121  }
122  void TNEANet::FltVAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
123    Names = TVec&lt;TStr&gt;();
124    while (!NodeHI.IsEnd()) {
125      if (NodeHI.GetDat().Val1 == FltVType) {
126        Names.Add(NodeHI.GetKey());
127      }
128      NodeHI++;
129    }  
130  }
131  void TNEANet::FltVAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TVec&lt;TFltV&gt;&amp; Values) const {
132    Values = TVec&lt;TFltV&gt;();
133    while (!NodeHI.IsEnd()) {
134      if (NodeHI.GetDat().Val1 == FltVType) {
135        TInt index = NodeHI.GetDat().Val2;
136        TStr attr =  NodeHI.GetKey();
137        TInt loc = CheckDenseOrSparseN(attr);
138        if (loc == 1) {
139          TFltV val = this-&gt;VecOfFltVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
140          if (val.Len() != 0) Values.Add(val);
141        } else {
142          const THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsN[index];
143          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
144            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
145          }
146        }
147      }
148      NodeHI++;
149    }
150  }
151  void TNEANet::StrAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
152    Names = TVec&lt;TStr&gt;();
153    while (!NodeHI.IsEnd()) {
154      if (NodeHI.GetDat().Val1 == StrType &amp;&amp; !NodeAttrIsStrDeleted(NId, NodeHI)) {
155        Names.Add(NodeHI.GetKey());
156      }
157      NodeHI++;
158    }  
159  }
160  void TNEANet::StrAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Values) const {
161    Values = TVec&lt;TStr&gt;();
162    while (!NodeHI.IsEnd()) {
163      if (NodeHI.GetDat().Val1 == StrType &amp;&amp; !NodeAttrIsStrDeleted(NId, NodeHI)) {
164        TStr val = this-&gt;VecOfStrVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
165        Values.Add(val);
166      }
167      NodeHI++;
168    }  
169  }
170  void TNEANet::FltAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
171    Names = TVec&lt;TStr&gt;();
172    while (!NodeHI.IsEnd()) {
173      if (NodeHI.GetDat().Val1 == FltType &amp;&amp; !NodeAttrIsFltDeleted(NId, NodeHI)) {
174        Names.Add(NodeHI.GetKey());
175      }
176      NodeHI++;
177    }  
178  }
179  void TNEANet::FltAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TFltV&amp; Values) const {
180    Values = TVec&lt;TFlt&gt;();
181    while (!NodeHI.IsEnd()) {
182      if (NodeHI.GetDat().Val1 == FltType &amp;&amp; !NodeAttrIsFltDeleted(NId, NodeHI)) {
183        TFlt val = (this-&gt;VecOfFltVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId)));
184        Values.Add(val);
185      }
186      NodeHI++;
187    }  
188  }
189  bool TNEANet::IsAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
190    bool IntDel = IsIntAttrDeletedN(NId, attr);
191    bool StrDel = IsStrAttrDeletedN(NId, attr);
192    bool FltDel = IsFltAttrDeletedN(NId, attr);
193    bool IntVDel = IsIntVAttrDeletedN(NId, attr);
194    bool FltVDel = IsFltVAttrDeletedN(NId, attr);
195    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
196  }
197  bool TNEANet::IsIntAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
198    return NodeAttrIsIntDeleted(NId, KeyToIndexTypeN.GetI(attr));
199  }
200  bool TNEANet::IsIntVAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
201    return NodeAttrIsIntVDeleted(NId, KeyToIndexTypeN.GetI(attr));
202  }
203  bool TNEANet::IsFltVAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
204    return NodeAttrIsFltVDeleted(NId, KeyToIndexTypeN.GetI(attr));
205  }
206  bool TNEANet::IsStrAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
207    return NodeAttrIsStrDeleted(NId, KeyToIndexTypeN.GetI(attr));
208  }
209  bool TNEANet::IsFltAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
210    return NodeAttrIsFltDeleted(NId, KeyToIndexTypeN.GetI(attr));
211  }
212  bool TNEANet::NodeAttrIsDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
213    bool IntDel = NodeAttrIsIntDeleted(NId, NodeHI);
214    bool StrDel = NodeAttrIsStrDeleted(NId, NodeHI);
215    bool FltDel = NodeAttrIsFltDeleted(NId, NodeHI);
216    bool IntVDel = NodeAttrIsIntVDeleted(NId, NodeHI);
217    return IntDel || StrDel || FltDel || IntVDel;
218  }
219  bool TNEANet::NodeAttrIsIntDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
220    if (NodeHI.GetDat().Val1 != IntType) {
221      return false;
222    }
223    return (GetIntAttrDefaultN(NodeHI.GetKey()) == this-&gt;VecOfIntVecsN.GetVal(
224      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
225  }
226  bool TNEANet::NodeAttrIsIntVDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
227    if (NodeHI.GetDat().Val1 != IntVType) {
228      return false;
229    }
230    return (TIntV() == this-&gt;VecOfIntVecVecsN.GetVal(
231      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
232  }
233  bool TNEANet::NodeAttrIsFltVDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
234    if (NodeHI.GetDat().Val1 != FltVType) {
235      return false;
236    }
237    return (TFltV() == this-&gt;VecOfFltVecVecsN.GetVal(
238      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
239  }
240  bool TNEANet::NodeAttrIsStrDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
241    if (NodeHI.GetDat().Val1 != StrType) {
242      return false;
243    }
244    return (GetStrAttrDefaultN(NodeHI.GetKey()) == this-&gt;VecOfStrVecsN.GetVal(
245      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
246  }
247  bool TNEANet::NodeAttrIsFltDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
248    if (NodeHI.GetDat().Val1 != FltType) {
249      return false;
250    }
251    return (GetFltAttrDefaultN(NodeHI.GetKey()) == this-&gt;VecOfFltVecsN.GetVal(
252      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
253  }
254  TStr TNEANet::GetNodeAttrValue(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
255    if (NodeHI.GetDat().Val1 == IntType) {
256      return (this-&gt;VecOfIntVecsN.GetVal(
257        this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
258    } else if(NodeHI.GetDat().Val1 == StrType) {
259      return this-&gt;VecOfStrVecsN.GetVal(
260      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId));
261    } else if (NodeHI.GetDat().Val1 == FltType) {
262      return (this-&gt;VecOfFltVecsN.GetVal(
263        this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
264    }
265    return TStr::GetNullStr();
266  }
267  void TNEANet::AttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
268    Names = TVec&lt;TStr&gt;();
269    while (!EdgeHI.IsEnd()) {
270      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
271        Names.Add(EdgeHI.GetKey());
272      }
273      EdgeHI++;
274    }  
275  }
276  void TNEANet::AttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Values) const {
277    Values = TVec&lt;TStr&gt;();
278    while (!EdgeHI.IsEnd()) {
279      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
280        Values.Add(GetEdgeAttrValue(EId, EdgeHI));
281      }
282      EdgeHI++;
283    }  
284  }
285  void TNEANet::IntAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
286    Names = TVec&lt;TStr&gt;();
287    while (!EdgeHI.IsEnd()) {
288      if (EdgeHI.GetDat().Val1 == IntType &amp;&amp; !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
289        Names.Add(EdgeHI.GetKey());
290      }
291      EdgeHI++;
292    }  
293  }
294  void TNEANet::IntAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TIntV&amp; Values) const {
295    Values = TVec&lt;TInt&gt;();
296    while (!EdgeHI.IsEnd()) {
297      if (EdgeHI.GetDat().Val1 == IntType &amp;&amp; !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
298        TInt val = (this-&gt;VecOfIntVecsE[EdgeHI.GetDat().Val2].GetVal(EdgeH.GetKeyId(EId)));
299        Values.Add(val);
300      }
301      EdgeHI++;
302    }  
303  }
304  void TNEANet::IntVAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
305    Names = TVec&lt;TStr&gt;();
306    while (!EdgeHI.IsEnd()) {
307      if (EdgeHI.GetDat().Val1 == IntVType) {
308        Names.Add(EdgeHI.GetKey());
309      }
310      EdgeHI++;
311    }  
312  }
313  void TNEANet::IntVAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TVec&lt;TIntV&gt;&amp; Values) const {
314    Values = TVec&lt;TIntV&gt;();
315    while (!EdgeHI.IsEnd()) {
316      if (EdgeHI.GetDat().Val1 == IntVType) {
317        TInt index = EdgeHI.GetDat().Val2;
318        TStr attr =  EdgeHI.GetKey();
319        TInt loc = CheckDenseOrSparseE(attr);
320        if (loc == 1) {
321          TIntV val = this-&gt;VecOfIntVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
322          if (val.Len() != 0) Values.Add(val);
323        } else {
324          const THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsE[index];
325          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
326            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
327          }
328        }
329      }
330      EdgeHI++;
331    }
332  }
333  void TNEANet::FltVAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
334    Names = TVec&lt;TStr&gt;();
335    while (!EdgeHI.IsEnd()) {
336      if (EdgeHI.GetDat().Val1 == FltVType) {
337        Names.Add(EdgeHI.GetKey());
338      }
339      EdgeHI++;
340    }  
341  }
342  void TNEANet::FltVAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TVec&lt;TFltV&gt;&amp; Values) const {
343    Values = TVec&lt;TFltV&gt;();
344    while (!EdgeHI.IsEnd()) {
345      if (EdgeHI.GetDat().Val1 == FltVType) {
346        TInt index = EdgeHI.GetDat().Val2;
347        TStr attr =  EdgeHI.GetKey();
348        TInt loc = CheckDenseOrSparseE(attr);
349        if (loc == 1) {
<span onclick='openModal()' class='match'>350          TFltV val = this-&gt;VecOfFltVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
351          if (val.Len() != 0) Values.Add(val);
352        } else {
353          const THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsE[index];
354          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
355            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
356          }
357        }
358      }
359      EdgeHI++;
360    }
361  }
362  void TNEANet::StrAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
363    Names = TVec&lt;TStr&gt;();
364    while (!EdgeHI.IsEnd()) {
365      if (EdgeHI.GetDat().Val1 == StrType &amp;&amp; !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
</span>366        Names.Add(EdgeHI.GetKey());
367      }
368      EdgeHI++;
369    }  
370  }
371  void TNEANet::StrAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Values) const {
372    Values = TVec&lt;TStr&gt;();
373    while (!EdgeHI.IsEnd()) {
374      if (EdgeHI.GetDat().Val1 == StrType &amp;&amp; !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
375        TStr val = this-&gt;VecOfStrVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId);
376        Values.Add(val);
377      }
378      EdgeHI++;
379    }  
380  }
381  void TNEANet::FltAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
382    Names = TVec&lt;TStr&gt;();
383    while (!EdgeHI.IsEnd()) {
384      if (EdgeHI.GetDat().Val1 == FltType &amp;&amp; !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
385        Names.Add(EdgeHI.GetKey());
386      }
387      EdgeHI++;
388    }  
389  }
390  void TNEANet::FltAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TFltV&amp; Values) const {
391    Values = TVec&lt;TFlt&gt;();
392    while (!EdgeHI.IsEnd()) {
393      if (EdgeHI.GetDat().Val1 == FltType &amp;&amp; !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
394        TFlt val = (this-&gt;VecOfFltVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
395        Values.Add(val);
396      }
397      EdgeHI++;
398    }  
399  }
400  bool TNEANet::IsAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
401    bool IntDel = IsIntAttrDeletedE(EId, attr);
402    bool IntVDel = IsIntVAttrDeletedE(EId, attr);
403    bool StrDel = IsStrAttrDeletedE(EId, attr);
404    bool FltDel = IsFltAttrDeletedE(EId, attr);
405    bool FltVDel = IsFltVAttrDeletedE(EId, attr);
406    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
407  }
408  bool TNEANet::IsIntAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
409    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
410  }
411  bool TNEANet::IsIntVAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
412    return EdgeAttrIsIntVDeleted(EId, KeyToIndexTypeE.GetI(attr));
413  }
414  bool TNEANet::IsFltVAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
415    return EdgeAttrIsFltVDeleted(EId, KeyToIndexTypeE.GetI(attr));
416  }
417  bool TNEANet::IsStrAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
418    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
419  }
420  bool TNEANet::IsFltAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
421    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
422  }
423  bool TNEANet::EdgeAttrIsDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
424    bool IntDel = EdgeAttrIsIntDeleted(EId, EdgeHI);
425    bool IntVDel = EdgeAttrIsIntVDeleted(EId, EdgeHI);
426    bool StrDel = EdgeAttrIsStrDeleted(EId, EdgeHI);
427    bool FltDel = EdgeAttrIsFltDeleted(EId, EdgeHI);
428    bool FltVDel = EdgeAttrIsFltVDeleted(EId, EdgeHI);
429    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
430  }
431  bool TNEANet::EdgeAttrIsIntDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
432    return (EdgeHI.GetDat().Val1 == IntType &amp;&amp;
433      GetIntAttrDefaultE(EdgeHI.GetKey()) == this-&gt;VecOfIntVecsE.GetVal(
434      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
435  }
436  bool TNEANet::EdgeAttrIsIntVDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
437    return (EdgeHI.GetDat().Val1 == IntVType &amp;&amp;
438      TIntV() == this-&gt;VecOfIntVecVecsE.GetVal(
439      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
440  }
441  bool TNEANet::EdgeAttrIsFltVDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
442    return (EdgeHI.GetDat().Val1 == FltVType &amp;&amp;
443      TFltV() == this-&gt;VecOfFltVecVecsE.GetVal(
444      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
445  }
446  bool TNEANet::EdgeAttrIsStrDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
447    return (EdgeHI.GetDat().Val1 == StrType &amp;&amp;
448      GetStrAttrDefaultE(EdgeHI.GetKey()) == this-&gt;VecOfStrVecsE.GetVal(
449      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
450  }
451  bool TNEANet::EdgeAttrIsFltDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
452    return (EdgeHI.GetDat().Val1 == FltType &amp;&amp;
453      GetFltAttrDefaultE(EdgeHI.GetKey()) == this-&gt;VecOfFltVecsE.GetVal(
454      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
455  }
456  TStr TNEANet::GetEdgeAttrValue(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
457    if (EdgeHI.GetDat().Val1 == IntType) {
458      return (this-&gt;VecOfIntVecsE.GetVal(
459        this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
460    } else if(EdgeHI.GetDat().Val1 == StrType) {
461      return this-&gt;VecOfStrVecsE.GetVal(
462      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId));
463    } else if (EdgeHI.GetDat().Val1 == FltType) {
464      return (this-&gt;VecOfFltVecsE.GetVal(
465        this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
466    }
467    return TStr::GetNullStr();
468  }
469  int TNEANet::AddNode(int NId) {
470    if (NId == -1) {
471      NId = MxNId;  MxNId++;
472    } else {
473      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
474      MxNId = TMath::Mx(NId+1, MxNId());
475    }
476    NodeH.AddDat(NId, TNode(NId));
477    AddAttributes(NId);
478    return NId;
479  }
480  int TNEANet::AddNodeUnchecked(int NId) {
481    if (NId == -1) {
482      NId = MxNId;  MxNId++;
483    } else {
484      if (IsNode(NId)) { return -1;}
485      MxNId = TMath::Mx(NId+1, MxNId());
486    }
487    NodeH.AddDat(NId, TNode(NId));
488    AddAttributes(NId);
489    return NId;
490  }
491  int TNEANet::AddAttributes(const int NId) {
492    int i;
493    for (i = 0; i &lt; VecOfIntVecsN.Len(); i++) {
494      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsN[i];
495      int KeyId = NodeH.GetKeyId(NId);
496      if (IntVec.Len() &gt; KeyId) {
497        IntVec[KeyId] = TInt::Mn;
498      } else {
499        IntVec.Ins(KeyId, TInt::Mn);
500      }
501    }
502    TVec&lt;TStr&gt; DefIntVec = TVec&lt;TStr&gt;();
503    IntDefaultsN.GetKeyV(DefIntVec);
504    for (i = 0; i &lt; DefIntVec.Len(); i++) {
505      TStr attr = DefIntVec[i];
506      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(DefIntVec[i]).Val2];
507      IntVec[NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
508    } 
509    for (i = 0; i &lt; VecOfStrVecsN.Len(); i++) {
510      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsN[i];
511      int KeyId = NodeH.GetKeyId(NId);
512      if (StrVec.Len() &gt; KeyId) {
513        StrVec[KeyId] = TStr::GetNullStr();
514      } else {
515        StrVec.Ins(KeyId, TStr::GetNullStr());
516      }
517    }
518    TVec&lt;TStr&gt; DefStrVec = TVec&lt;TStr&gt;();
519    StrDefaultsN.GetKeyV(DefStrVec);
520    for (i = 0; i &lt; DefStrVec.Len(); i++) {
521      TStr attr = DefStrVec[i];
522      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(DefStrVec[i]).Val2];
523      StrVec[NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
524    }
525    for (i = 0; i &lt; VecOfFltVecsN.Len(); i++) {
526      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsN[i];
527      int KeyId = NodeH.GetKeyId(NId);
528      if (FltVec.Len() &gt; KeyId) {
529        FltVec[KeyId] = TFlt::Mn;
530      } else {
531        FltVec.Ins(KeyId, TFlt::Mn);
532      }
533    }
534    TVec&lt;TStr&gt; DefFltVec = TVec&lt;TStr&gt;();
535    FltDefaultsN.GetKeyV(DefFltVec);
536    for (i = 0; i &lt; DefFltVec.Len(); i++) {
537      TStr attr = DefFltVec[i];
538      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(DefFltVec[i]).Val2];
539      FltVec[NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
540    }
541    for (i = 0; i &lt; VecOfIntVecVecsN.Len(); i++) {
542      TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsN[i];
543      int KeyId = NodeH.GetKeyId(NId);
544      if (IntVecV.Len() &gt; KeyId) {
545        IntVecV[KeyId] = TIntV();
546      } else {
547        IntVecV.Ins(KeyId, TIntV());
548      }
549    }
550    for (i = 0; i &lt; VecOfFltVecVecsN.Len(); i++) {
551      TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsN[i];
552      int KeyId = NodeH.GetKeyId(NId);
553      if (FltVecV.Len() &gt; KeyId) {
554        FltVecV[KeyId] = TFltV();
555      } else {
556        FltVecV.Ins(KeyId, TFltV());
557      }
558    }
559    return NId;
560  }
561  void TNEANet::DelNode(const int&amp; NId) {
562    int i;
563    TInt Id(NId);
564    SAttrN.DelSAttrId(Id);
565    const TNode&amp; Node = GetNode(NId);
566    for (int out = 0; out &lt; Node.GetOutDeg(); out++) {
567      const int EId = Node.GetOutEId(out);
568      const TEdge&amp; Edge = GetEdge(EId);
569      IAssert(Edge.GetSrcNId() == NId);
570      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
571      for (i = 0; i &lt; VecOfIntVecsE.Len(); i++) {
572        TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[i];
573        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
574      }
575      for (i = 0; i &lt; VecOfStrVecsE.Len(); i++) {
576        TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[i];
577        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
578      }
579      for (i = 0; i &lt; VecOfFltVecsE.Len(); i++) {
580        TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[i];
581        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
582      }
583      for (i = 0; i &lt; VecOfIntVecVecsE.Len(); i++) {
584        TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsE[i];
585        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
586      }
587      for (i = 0; i &lt; VecOfFltVecVecsE.Len(); i++) {
588        TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsE[i];
589        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
590      }
591      for (i = 0; i &lt; VecOfIntHashVecsE.Len(); i++) {
592        THash&lt;TInt, TIntV&gt;&amp; IntHashV = VecOfIntHashVecsE[i];
593        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
594          IntHashV.DelKey(EdgeH.GetKeyId(EId));
595        }
596      }
597      for (i = 0; i &lt; VecOfFltHashVecsE.Len(); i++) {
598        THash&lt;TInt, TFltV&gt;&amp; FltHashV = VecOfFltHashVecsE[i];
599        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
600          FltHashV.DelKey(EdgeH.GetKeyId(EId));
601        }
602      }
603      EdgeH.DelKey(EId);
604    }
605    for (int in = 0; in &lt; Node.GetInDeg(); in++) {
606      const int EId = Node.GetInEId(in);
607      const TEdge&amp; Edge = GetEdge(EId);
608      IAssert(Edge.GetDstNId() == NId);
609      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
610      for (i = 0; i &lt; VecOfIntVecsE.Len(); i++) {
611        TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[i];
612        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
613      }
614      for (i = 0; i &lt; VecOfStrVecsE.Len(); i++) {
615        TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[i];
616        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
617      }
618      for (i = 0; i &lt; VecOfFltVecsE.Len(); i++) {
619        TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[i];
620        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
621      }
622      for (i = 0; i &lt; VecOfIntVecVecsE.Len(); i++) {
623        TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsE[i];
624        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
625      }
626      for (i = 0; i &lt; VecOfFltVecVecsE.Len(); i++) {
627        TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsE[i];
628        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
629      }
630      for (i = 0; i &lt; VecOfIntHashVecsE.Len(); i++) {
631        THash&lt;TInt, TIntV&gt;&amp; IntHashV = VecOfIntHashVecsE[i];
632        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
633          IntHashV.DelKey(EdgeH.GetKeyId(EId));
634        }
635      }
636      for (i = 0; i &lt; VecOfFltHashVecsE.Len(); i++) {
637        THash&lt;TInt, TFltV&gt;&amp; FltHashV = VecOfFltHashVecsE[i];
638        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
639          FltHashV.DelKey(EdgeH.GetKeyId(EId));
640        }
641      }
642      EdgeH.DelKey(EId);
643    }
644    for (i = 0; i &lt; VecOfIntVecsN.Len(); i++) {
645      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsN[i];
646      IntVec[NodeH.GetKeyId(NId)] = TInt::Mn;
647    }
648    for (i = 0; i &lt; VecOfStrVecsN.Len(); i++) {
649      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsN[i];
650      StrVec[NodeH.GetKeyId(NId)] = TStr::GetNullStr();
651    }
652    for (i = 0; i &lt; VecOfFltVecsN.Len(); i++) {
653      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsN[i];
654      FltVec[NodeH.GetKeyId(NId)] = TFlt::Mn;
655    }
656    for (i = 0; i &lt; VecOfIntVecVecsN.Len(); i++) {
657      TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsN[i];
658      IntVecV[NodeH.GetKeyId(NId)] = TIntV();
659    }
660    for (i = 0; i &lt; VecOfFltVecVecsN.Len(); i++) {
661      TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsN[i];
662      FltVecV[NodeH.GetKeyId(NId)] = TFltV();
663    }
664    for (i = 0; i &lt; VecOfIntHashVecsN.Len(); i++) {
665      THash&lt;TInt, TIntV&gt;&amp; IntHashV = VecOfIntHashVecsN[i];
666      if (IntHashV.IsKey(NodeH.GetKeyId(NId))) {
667        IntHashV.DelKey(NodeH.GetKeyId(NId));
668      }
669    }
670    for (i = 0; i &lt; VecOfFltHashVecsN.Len(); i++) {
671      THash&lt;TInt, TFltV&gt;&amp; FltHashV = VecOfFltHashVecsN[i];
672      if (FltHashV.IsKey(NodeH.GetKeyId(NId))) {
673        FltHashV.DelKey(NodeH.GetKeyId(NId));
674      }
675    }
676    NodeH.DelKey(NId);
677  }
678  int TNEANet::AddEdge(const int&amp; SrcNId, const int&amp; DstNId, int EId) {
679    int i;
680    if (EId == -1) { EId = MxEId;  MxEId++; }
681    else { MxEId = TMath::Mx(EId+1, MxEId()); }
682    IAssertR(!IsEdge(EId), TStr::Fmt(&quot;EdgeId %d already exists&quot;, EId));
683    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
684    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
685    GetNode(SrcNId).OutEIdV.AddSorted(EId);
686    GetNode(DstNId).InEIdV.AddSorted(EId);
687    for (i = 0; i &lt; VecOfIntVecsE.Len(); i++) {
688      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[i];
689      int KeyId = EdgeH.GetKeyId(EId);
690      if (IntVec.Len() &gt; KeyId) {
691        IntVec[KeyId] = TInt::Mn;
692      } else {
693        IntVec.Ins(KeyId, TInt::Mn);
694      }
695    }
696    TVec&lt;TStr&gt; DefIntVec = TVec&lt;TStr&gt;();
697    IntDefaultsE.GetKeyV(DefIntVec);
698    for (i = 0; i &lt; DefIntVec.Len(); i++) {
699      TStr attr = DefIntVec[i];
700      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
701      IntVec[EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
702    }
703    for (i = 0; i &lt; VecOfIntVecVecsE.Len(); i++) {
704      TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsE[i];
705      IntVecV.Ins(EdgeH.GetKeyId(EId), TIntV());
706    }
707    for (i = 0; i &lt; VecOfFltVecVecsE.Len(); i++) {
708      TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsE[i];
709      FltVecV.Ins(EdgeH.GetKeyId(EId), TFltV());
710    }
711    for (i = 0; i &lt; VecOfStrVecsE.Len(); i++) {
712      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[i];
713      int KeyId = EdgeH.GetKeyId(EId);
714      if (StrVec.Len() &gt; KeyId) {
715        StrVec[KeyId] = TStr::GetNullStr();
716      } else {
717        StrVec.Ins(KeyId, TStr::GetNullStr());
718      }
719    }
720    TVec&lt;TStr&gt; DefStrVec = TVec&lt;TStr&gt;();
721    StrDefaultsE.GetKeyV(DefStrVec);
722    for (i = 0; i &lt; DefStrVec.Len(); i++) {
723      TStr attr = DefStrVec[i];
724      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
725      StrVec[EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
726    }
727    for (i = 0; i &lt; VecOfFltVecsE.Len(); i++) {
728      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[i];
729      int KeyId = EdgeH.GetKeyId(EId);
730      if (FltVec.Len() &gt; KeyId) {
731        FltVec[KeyId] = TFlt::Mn;
732      } else {
733        FltVec.Ins(KeyId, TFlt::Mn);
734      }
735    }
736    TVec&lt;TStr&gt; DefFltVec = TVec&lt;TStr&gt;();
737    FltDefaultsE.GetKeyV(DefFltVec);
738    for (i = 0; i &lt; DefFltVec.Len(); i++) {
739      TStr attr = DefFltVec[i];
740      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
741      FltVec[EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
742    }
743    return EId;
744  }
745  void TNEANet::DelEdge(const int&amp; EId) {
746    int i;
747    IAssert(IsEdge(EId));
748    const int SrcNId = GetEdge(EId).GetSrcNId();
749    const int DstNId = GetEdge(EId).GetDstNId();
750    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
751    GetNode(DstNId).InEIdV.DelIfIn(EId);
752    TInt Id(EId);
753    SAttrE.DelSAttrId(Id);
754    for (i = 0; i &lt; VecOfIntVecsE.Len(); i++) {
755      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[i];
756      IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
757    }
758    for (i = 0; i &lt; VecOfStrVecsE.Len(); i++) {
759      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[i];
760      StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
761    }
762    for (i = 0; i &lt; VecOfFltVecsE.Len(); i++) {
763      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[i];
764      FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
765    }
766    EdgeH.DelKey(EId);
767  }
768  void TNEANet::DelEdge(const int&amp; SrcNId, const int&amp; DstNId, const bool&amp; IsDir) {
769    int EId = 0;
770    bool Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
771    IAssert(Edge); 
772    while (Edge) {
773      DelEdge(EId);
774      Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
775    }
776  }
777  bool TNEANet::IsEdge(const int&amp; SrcNId, const int&amp; DstNId, int&amp; EId, const bool&amp; IsDir) const {
778    if (! IsNode(SrcNId) || ! IsNode(DstNId)) {
779      return false;
780    }
781    const TNode&amp; SrcNode = GetNode(SrcNId);
782    for (int edge = 0; edge &lt; SrcNode.GetOutDeg(); edge++) {
783      const TEdge&amp; Edge = GetEdge(SrcNode.GetOutEId(edge));
784      if (DstNId == Edge.GetDstNId()) {
785        EId = Edge.GetId();
786        return true;
787      }
788    }
789    if (! IsDir) {
790      for (int edge = 0; edge &lt; SrcNode.GetInDeg(); edge++) {
791        const TEdge&amp; Edge = GetEdge(SrcNode.GetInEId(edge));
792        if (DstNId == Edge.GetSrcNId()) {
793          EId = Edge.GetId();
794          return true;
795        }
796      }
797    }
798    return false;
799  }
800  void TNEANet::GetNIdV(TIntV&amp; NIdV) const {
801    NIdV.Gen(GetNodes(), 0);
802    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
803      NIdV.Add(NodeH.GetKey(N));
804    }
805  }
806  void TNEANet::GetEIdV(TIntV&amp; EIdV) const {
807    EIdV.Gen(GetEdges(), 0);
808    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
809      EIdV.Add(EdgeH.GetKey(E));
810    }
811  }
812  void TNEANet::Defrag(const bool&amp; OnlyNodeLinks) {
813    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
814      TNode&amp; Node = NodeH[kid];
815      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
816    }
817    if (! OnlyNodeLinks &amp;&amp; ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
818    if (! OnlyNodeLinks &amp;&amp; ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
819  }
820  bool TNEANet::IsOk(const bool&amp; ThrowExcept) const {
821    bool RetVal = true;
822    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
823      const TNode&amp; Node = NodeH[N];
824      if (! Node.OutEIdV.IsSorted()) {
825        const TStr Msg = TStr::Fmt(&quot;Out-edge list of node %d is not sorted.&quot;, Node.GetId());
826        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
827      }
828      if (! Node.InEIdV.IsSorted()) {
829        const TStr Msg = TStr::Fmt(&quot;In-edge list of node %d is not sorted.&quot;, Node.GetId());
830        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
831      }
832      int prevEId = -1;
833      for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
834        if (! IsEdge(Node.GetOutEId(e))) {
835          const TStr Msg = TStr::Fmt(&quot;Out-edge id %d of node %d does not exist.&quot;,  Node.GetOutEId(e), Node.GetId());
836          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
837        }
838        if (e &gt; 0 &amp;&amp; prevEId == Node.GetOutEId(e)) {
839          const TStr Msg = TStr::Fmt(&quot;Node %d has duplidate out-edge id %d.&quot;, Node.GetId(), Node.GetOutEId(e));
840          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
841        }
842        prevEId = Node.GetOutEId(e);
843      }
844      prevEId = -1;
845      for (int e = 0; e &lt; Node.GetInDeg(); e++) {
846        if (! IsEdge(Node.GetInEId(e))) {
847        const TStr Msg = TStr::Fmt(&quot;Out-edge id %d of node %d does not exist.&quot;,  Node.GetInEId(e), Node.GetId());
848        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
849        }
850        if (e &gt; 0 &amp;&amp; prevEId == Node.GetInEId(e)) {
851          const TStr Msg = TStr::Fmt(&quot;Node %d has duplidate out-edge id %d.&quot;, Node.GetId(), Node.GetInEId(e));
852          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
853        }
854        prevEId = Node.GetInEId(e);
855      }
856    }
857    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
858      const TEdge&amp; Edge = EdgeH[E];
859      if (! IsNode(Edge.GetSrcNId())) {
860        const TStr Msg = TStr::Fmt(&quot;Edge %d source node %d does not exist.&quot;, Edge.GetId(), Edge.GetSrcNId());
861        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
862      }
863      if (! IsNode(Edge.GetDstNId())) {
864        const TStr Msg = TStr::Fmt(&quot;Edge %d destination node %d does not exist.&quot;, Edge.GetId(), Edge.GetDstNId());
865        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
866      }
867    }
868    return RetVal;
869  }
870  void TNEANet::Dump(FILE *OutF) const {
871    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
872    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
873    fprintf(OutF, &quot;-------------------------------------------------\nDirected Node-Edge Network with Attributes: nodes: %d, edges: %d\n&quot;, GetNodes(), GetEdges());
874    for (TNodeI NodeI = BegNI(); NodeI &lt; EndNI(); NodeI++) {
875      fprintf(OutF, &quot;  %*d:&quot;, NodePlaces, NodeI.GetId());
876      fprintf(OutF, &quot;    in[%d]&quot;, NodeI.GetInDeg());
877      for (int edge = 0; edge &lt; NodeI.GetInDeg(); edge++) {
878        fprintf(OutF, &quot; %*d&quot;, EdgePlaces, NodeI.GetInEId(edge)); }
879      fprintf(OutF, &quot;    out[%d]&quot;, NodeI.GetOutDeg());
880      for (int edge = 0; edge &lt; NodeI.GetOutDeg(); edge++) {
881        fprintf(OutF, &quot; %*d&quot;, EdgePlaces, NodeI.GetOutEId(edge)); }
882      TIntV IntAttrN;
883      IntAttrValueNI(NodeI.GetId(), IntAttrN);
884      fprintf(OutF, &quot;    nai[%d]&quot;, IntAttrN.Len());
885      for (int i = 0; i &lt; IntAttrN.Len(); i++) {
886        fprintf(OutF, &quot; %*i&quot;, NodePlaces, IntAttrN[i]()); }
887      TStrV StrAttrN;
888      StrAttrValueNI(NodeI.GetId(), StrAttrN);
889      fprintf(OutF, &quot;    nas[%d]&quot;, StrAttrN.Len());
890      for (int i = 0; i &lt; StrAttrN.Len(); i++) {
891        fprintf(OutF, &quot; %*s&quot;, NodePlaces, StrAttrN[i]()); }
892      TFltV FltAttrN;
893      FltAttrValueNI(NodeI.GetId(), FltAttrN);
894      fprintf(OutF, &quot;    naf[%d]&quot;, FltAttrN.Len());
895      for (int i = 0; i &lt; FltAttrN.Len(); i++) {
896        fprintf(OutF, &quot; %*f&quot;, NodePlaces, FltAttrN[i]()); }
897      fprintf(OutF, &quot;\n&quot;);
898    }
899    for (TEdgeI EdgeI = BegEI(); EdgeI &lt; EndEI(); EdgeI++) {
900      fprintf(OutF, &quot;  %*d:  %*d  -&gt;  %*d&quot;, EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
901      TIntV IntAttrE;
902      IntAttrValueEI(EdgeI.GetId(), IntAttrE);
903      fprintf(OutF, &quot;    eai[%d]&quot;, IntAttrE.Len());
904      for (int i = 0; i &lt; IntAttrE.Len(); i++) {
905        fprintf(OutF, &quot; %*i&quot;, EdgePlaces, IntAttrE[i]()); 
906      }
907      TStrV StrAttrE;
908      StrAttrValueEI(EdgeI.GetId(), StrAttrE);
909      fprintf(OutF, &quot;    eas[%d]&quot;, StrAttrE.Len());
910      for (int i = 0; i &lt; StrAttrE.Len(); i++) {
911        fprintf(OutF, &quot; %*s&quot;, EdgePlaces, StrAttrE[i]()); 
912      }
913      TFltV FltAttrE;
914      FltAttrValueEI(EdgeI.GetId(), FltAttrE);
915      fprintf(OutF, &quot;    eaf[%d]&quot;, FltAttrE.Len());
916      for (int i = 0; i &lt; FltAttrE.Len(); i++) {
917        fprintf(OutF, &quot; %*f&quot;, EdgePlaces, FltAttrE[i]()); 
918      }
919      fprintf(OutF, &quot;\n&quot;);
920    }
921  }
922  int TNEANet::AddIntAttrDatN(const int&amp; NId, const TInt&amp; value, const TStr&amp; attr) {
923    int i;
924    TInt CurrLen;
925    if (!IsNode(NId)) {
926      return -1;
927    }
928    if (KeyToIndexTypeN.IsKey(attr)) {
929      TVec&lt;TInt&gt;&amp; NewVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
930      NewVec[NodeH.GetKeyId(NId)] = value;
931    } else {
932      CurrLen = VecOfIntVecsN.Len();
933      KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
934      TVec&lt;TInt&gt; NewVec = TVec&lt;TInt&gt;();
935      for (i = 0; i &lt; MxNId; i++) {
936        NewVec.Ins(i, GetIntAttrDefaultN(attr));
937      }
938      NewVec[NodeH.GetKeyId(NId)] = value;
939      VecOfIntVecsN.Add(NewVec);
940    }
941    return 0;
942  }
943  int TNEANet::AddIntVAttrDatN(const int&amp; NId, const TIntV&amp; value, const TStr&amp; attr, TBool UseDense) {
944    if (!IsNode(NId)) {
945      return -1;
946    }
947    TInt location = CheckDenseOrSparseN(attr);
948    if (location==-1) {
949      AddIntVAttrN(attr, UseDense);
950      location = CheckDenseOrSparseN(attr);
951    }
952    if (UseDense) {
953      IAssertR(location != 0, TStr::Fmt(&quot;NodeId %d exists for %s in sparse representation&quot;, NId, attr.CStr()));
954      TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
955      NewVec[NodeH.GetKeyId(NId)] = value;
956    } else {
957      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, NId, attr.CStr()));
958      THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
959      NewHash.AddDat(NodeH.GetKeyId(NId), value);
960    }
961    return 0;
962  } 
963  int TNEANet::AddFltVAttrDatN(const int&amp; NId, const TFltV&amp; value, const TStr&amp; attr, TBool UseDense) {
964    if (!IsNode(NId)) {
965      return -1;
966    }
967    TInt location = CheckDenseOrSparseN(attr);
968    if (location==-1) {
969      AddFltVAttrN(attr, UseDense);
970      location = CheckDenseOrSparseN(attr);
971    }
972    if (UseDense) {
973      IAssertR(location != 0, TStr::Fmt(&quot;NodeId %d exists for %s in sparse representation&quot;, NId, attr.CStr()));
974      TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
975      NewVec[NodeH.GetKeyId(NId)] = value;
976    } else {
977      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, NId, attr.CStr()));
978      THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
979      NewHash.AddDat(NodeH.GetKeyId(NId), value);
980    }
981    return 0;
982  } 
983  int TNEANet::AppendIntVAttrDatN(const int&amp; NId, const TInt&amp; value, const TStr&amp; attr, TBool UseDense) {
984    if (!IsNode(NId)) {
985      return -1;
986    }
987    TInt location = CheckDenseOrSparseN(attr);
988    if (location==-1) {
989      AddIntVAttrN(attr, UseDense);
990      location = CheckDenseOrSparseN(attr);
991    }
992    if (UseDense) {
993      IAssertR(location != 0, TStr::Fmt(&quot;NodeId %d exists for %s in sparse representation&quot;, NId, attr.CStr()));
994      TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
995      NewVec[NodeH.GetKeyId(NId)].Add(value);
996    } else {
997      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, NId, attr.CStr()));
998      THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
999      NewHash[NodeH.GetKeyId(NId)].Add(value);
1000    }
1001    return 0;
1002  } 
1003  int TNEANet::AppendFltVAttrDatN(const int&amp; NId, const TFlt&amp; value, const TStr&amp; attr, TBool UseDense) {
1004    if (!IsNode(NId)) {
1005      return -1;
1006    }
1007    TInt location = CheckDenseOrSparseN(attr);
1008    if (location==-1) {
1009      AddFltVAttrN(attr, UseDense);
1010      location = CheckDenseOrSparseN(attr);
1011    }
1012    if (UseDense) {
1013      IAssertR(location != 0, TStr::Fmt(&quot;NodeId %d exists for %s in sparse representation&quot;, NId, attr.CStr()));
1014      TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1015      NewVec[NodeH.GetKeyId(NId)].Add(value);
1016    } else {
1017      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, NId, attr.CStr()));
1018      THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1019      NewHash[NodeH.GetKeyId(NId)].Add(value);
1020    }
1021    return 0;
1022  } 
1023  int TNEANet::DelFromIntVAttrDatN(const int&amp; NId, const TInt&amp; value, const TStr&amp; attr) {
1024    TInt CurrLen;
1025    if (!IsNode(NId)) {
1026      return -1;
1027    }
1028    TInt location = CheckDenseOrSparseN(attr);
1029    if (location != -1) {
1030      if (location == 1) {
1031        TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1032        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1033          return -1;
1034        }
1035      } else {
1036        THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1037        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1038          return -1;
1039        }
1040      }
1041    } else {
1042      return -1;
1043    }
1044    return 0;
1045  } 
1046  int TNEANet::DelFromFltVAttrDatN(const int&amp; NId, const TFlt&amp; value, const TStr&amp; attr) {
1047    TInt CurrLen;
1048    if (!IsNode(NId)) {
1049      return -1;
1050    }
1051    TInt location = CheckDenseOrSparseN(attr);
1052    if (location != -1) {
1053      if (location == 1) {
1054        TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1055        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1056          return -1;
1057        }
1058      } else {
1059        THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1060        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1061          return -1;
1062        }
1063      }
1064    } else {
1065      return -1;
1066    }
1067    return 0;
1068  }
1069  int TNEANet::AddStrAttrDatN(const int&amp; NId, const TStr&amp; value, const TStr&amp; attr) {
1070    int i;
1071    TInt CurrLen;
1072    if (!IsNode(NId)) {
1073      return -1;
1074    }
1075    if (KeyToIndexTypeN.IsKey(attr)) {
1076      TVec&lt;TStr&gt;&amp; NewVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1077      NewVec[NodeH.GetKeyId(NId)] = value;
1078    } else {
1079      CurrLen = VecOfStrVecsN.Len();
1080      KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1081      TVec&lt;TStr&gt; NewVec = TVec&lt;TStr&gt;();
1082      for (i = 0; i &lt; MxNId; i++) {
1083          NewVec.Ins(i, GetStrAttrDefaultN(attr));
1084      }
1085      NewVec[NodeH.GetKeyId(NId)] = value;
1086      VecOfStrVecsN.Add(NewVec);
1087    }
1088    return 0;
1089  } 
1090  int TNEANet::AddFltAttrDatN(const int&amp; NId, const TFlt&amp; value, const TStr&amp; attr) {
1091    int i;
1092    TInt CurrLen;
1093    if (!IsNode(NId)) {
1094      return -1;
1095    }
1096    if (KeyToIndexTypeN.IsKey(attr)) {
1097      TVec&lt;TFlt&gt;&amp; NewVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1098      NewVec[NodeH.GetKeyId(NId)] = value;
1099    } else {
1100      CurrLen = VecOfFltVecsN.Len();
1101      KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1102      TVec&lt;TFlt&gt; NewVec = TVec&lt;TFlt&gt;();
1103      for (i = 0; i &lt; MxNId; i++) {
1104        NewVec.Ins(i, GetFltAttrDefaultN(attr));
1105      }
1106      NewVec[NodeH.GetKeyId(NId)] = value;
1107      VecOfFltVecsN.Add(NewVec);
1108    }
1109    return 0;
1110  } 
1111  int TNEANet::AddIntAttrDatE(const int&amp; EId, const TInt&amp; value, const TStr&amp; attr) {
1112    int i;
1113    TInt CurrLen;
1114    if (!IsEdge(EId)) {
1115       return -1;
1116    }
1117    if (KeyToIndexTypeE.IsKey(attr)) {
1118      TVec&lt;TInt&gt;&amp; NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1119      NewVec[EdgeH.GetKeyId(EId)] = value;
1120    } else {
1121      CurrLen = VecOfIntVecsE.Len();
1122      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1123      TVec&lt;TInt&gt; NewVec = TVec&lt;TInt&gt;();
1124      for (i = 0; i &lt; MxEId; i++) {
1125        NewVec.Ins(i, GetIntAttrDefaultE(attr));
1126      }
1127      NewVec[EdgeH.GetKeyId(EId)] = value;
1128      VecOfIntVecsE.Add(NewVec);
1129    }
1130    return 0;
1131  }
1132  int TNEANet::AddIntVAttrDatE(const int&amp; EId, const TIntV&amp; value, const TStr&amp; attr, TBool UseDense) {
1133    if (!IsEdge(EId)) {
1134      return -1;
1135    }
1136    TInt location = CheckDenseOrSparseE(attr);
1137    if (location==-1) {
1138      AddIntVAttrE(attr, UseDense);
1139      location = CheckDenseOrSparseE(attr);
1140    }
1141    if (UseDense) {
1142      IAssertR(location != 0, TStr::Fmt(&quot;EdgeID %d exists for %s in sparse representation&quot;, EId, attr.CStr()));
1143      TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1144      NewVec[EdgeH.GetKeyId(EId)] = value;
1145    } else {
1146      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, EId, attr.CStr()));
1147      THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1148      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1149    }
1150    return 0;
1151  } 
1152  int TNEANet::AddFltVAttrDatE(const int&amp; EId, const TFltV&amp; value, const TStr&amp; attr, TBool UseDense) {
1153    if (!IsEdge(EId)) {
1154      return -1;
1155    }
1156    TInt location = CheckDenseOrSparseE(attr);
1157    if (location==-1) {
1158      AddFltVAttrE(attr, UseDense);
1159      location = CheckDenseOrSparseE(attr);
1160    }
1161    if (UseDense) {
1162      IAssertR(location != 0, TStr::Fmt(&quot;EdgeID %d exists for %s in sparse representation&quot;, EId, attr.CStr()));
1163      TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1164      NewVec[EdgeH.GetKeyId(EId)] = value;
1165    } else {
1166      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, EId, attr.CStr()));
1167      THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1168      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1169    }
1170    return 0;
1171  } 
1172  int TNEANet::AppendIntVAttrDatE(const int&amp; EId, const TInt&amp; value, const TStr&amp; attr, TBool UseDense) {
1173    if (!IsEdge(EId)) {
1174      return -1;
1175    }
1176    TInt location = CheckDenseOrSparseE(attr);
1177    if (location==-1) return -1;
1178    if (UseDense) {
1179      IAssertR(location != 0, TStr::Fmt(&quot;Edge %d exists for %s in sparse representation&quot;, EId, attr.CStr()));
1180      TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1181      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1182    } else {
1183      IAssertR(location != 1, TStr::Fmt(&quot;Edge %d exists for %s in dense representation&quot;, EId, attr.CStr()));
1184      THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1185      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1186    }
1187    return 0;
1188  }
1189  int TNEANet::AppendFltVAttrDatE(const int&amp; EId, const TFlt&amp; value, const TStr&amp; attr, TBool UseDense) {
1190    if (!IsEdge(EId)) {
1191      return -1;
1192    }
1193    TInt location = CheckDenseOrSparseE(attr);
1194    if (location==-1) return -1;
1195    if (UseDense) {
1196      IAssertR(location != 0, TStr::Fmt(&quot;Edge %d exists for %s in sparse representation&quot;, EId, attr.CStr()));
1197      TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1198      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1199    } else {
1200      IAssertR(location != 1, TStr::Fmt(&quot;Edge %d exists for %s in dense representation&quot;, EId, attr.CStr()));
1201      THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1202      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1203    }
1204    return 0;
1205  }
1206  int TNEANet::AddStrAttrDatE(const int&amp; EId, const TStr&amp; value, const TStr&amp; attr) {
1207    int i;
1208    TInt CurrLen;
1209    if (!IsEdge(EId)) {
1210       return -1;
1211    }
1212    if (KeyToIndexTypeE.IsKey(attr)) {
1213      TVec&lt;TStr&gt;&amp; NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1214      NewVec[EdgeH.GetKeyId(EId)] = value;
1215    } else {
1216      CurrLen = VecOfStrVecsE.Len();
1217      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1218      TVec&lt;TStr&gt; NewVec = TVec&lt;TStr&gt;();
1219      for (i = 0; i &lt; MxEId; i++) {
1220        NewVec.Ins(i, GetStrAttrDefaultE(attr));
1221      }
1222      NewVec[EdgeH.GetKeyId(EId)] = value;
1223      VecOfStrVecsE.Add(NewVec);
1224    }
1225    return 0;
1226  } 
1227  int TNEANet::AddFltAttrDatE(const int&amp; EId, const TFlt&amp; value, const TStr&amp; attr) {
1228    int i;
1229    TInt CurrLen;
1230    if (!IsEdge(EId)) {
1231       return -1;
1232    }
1233    if (KeyToIndexTypeE.IsKey(attr)) {
1234      TVec&lt;TFlt&gt;&amp; NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1235      NewVec[EdgeH.GetKeyId(EId)] = value;
1236    } else {
1237      CurrLen = VecOfFltVecsE.Len();
1238      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1239      TVec&lt;TFlt&gt; NewVec = TVec&lt;TFlt&gt;();
1240      for (i = 0; i &lt; MxEId; i++) {
1241        NewVec.Ins(i, GetFltAttrDefaultE(attr));
1242      }
1243      NewVec[EdgeH.GetKeyId(EId)] = value;
1244      VecOfFltVecsE.Add(NewVec);
1245    }
1246    return 0;
1247  }
1248  TVec&lt;TFlt&gt;&amp; TNEANet::GetFltAttrVecE(const TStr&amp; attr) {
1249    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1250  }
1251  int TNEANet::GetFltKeyIdE(const int&amp; EId) {
1252    return EdgeH.GetKeyId(EId);
1253  }
1254  TInt TNEANet::GetIntAttrDatN(const int&amp; NId, const TStr&amp; attr) {
1255    return VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1256  }
1257  TIntV TNEANet::GetIntVAttrDatN(const int&amp; NId, const TStr&amp; attr) const {
1258    TInt location = CheckDenseOrSparseN(attr);
1259    if (location != 0) return VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1260    else return VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1261  }
1262  TFltV TNEANet::GetFltVAttrDatN(const int&amp; NId, const TStr&amp; attr) const {
1263    TInt location = CheckDenseOrSparseN(attr);
1264    if (location != 0) return VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1265    else return VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1266  }
1267  TStr TNEANet::GetStrAttrDatN(const int&amp; NId, const TStr&amp; attr) {
1268    return VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1269  }
1270  TFlt TNEANet::GetFltAttrDatN(const int&amp; NId, const TStr&amp; attr) {
1271    return VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1272  }
1273  TInt TNEANet::GetIntAttrIndDatN(const int&amp; NId, const int&amp; index) {
1274    return VecOfIntVecsN[index][NodeH.GetKeyId(NId)];
1275  }
1276  TStr TNEANet::GetStrAttrIndDatN(const int&amp; NId, const int&amp; index) {
1277    return VecOfStrVecsN[index][NodeH.GetKeyId(NId)];
1278  }
1279  TFlt TNEANet::GetFltAttrIndDatN(const int&amp; NId, const int&amp; index) {
1280    return VecOfFltVecsN[index][NodeH.GetKeyId(NId)];
1281  }
1282  int TNEANet::GetIntAttrIndN(const TStr&amp; attr) {
1283    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1284  }
1285  int TNEANet::GetAttrIndN(const TStr&amp; attr) {
1286    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1287  }
1288  TInt TNEANet::GetIntAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1289    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1290  }
1291  TIntV TNEANet::GetIntVAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1292    TInt location = CheckDenseOrSparseE(attr);
1293    if (location != 0) return VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1294    else return VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1295  }
1296  TFltV TNEANet::GetFltVAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1297    TInt location = CheckDenseOrSparseE(attr);
1298    if (location != 0) return VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1299    else return VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1300  }
1301  TStr TNEANet::GetStrAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1302    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1303  }
1304  TFlt TNEANet::GetFltAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1305    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1306  }
1307  TInt TNEANet::GetIntAttrIndDatE(const int&amp; EId, const int&amp; index) {
1308    return VecOfIntVecsE[index][EdgeH.GetKeyId(EId)];
1309  }
1310  TStr TNEANet::GetStrAttrIndDatE(const int&amp; EId, const int&amp; index) {
1311    return VecOfStrVecsE[index][EdgeH.GetKeyId(EId)];
1312  }
1313  TFlt TNEANet::GetFltAttrIndDatE(const int&amp; EId, const int&amp; index) {
1314    return VecOfFltVecsE[index][EdgeH.GetKeyId(EId)];
1315  }
1316  int TNEANet::GetIntAttrIndE(const TStr&amp; attr) {
1317    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1318  }
1319  int TNEANet::GetAttrIndE(const TStr&amp; attr) {
1320    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1321  }
1322  int TNEANet::DelAttrDatN(const int&amp; NId, const TStr&amp; attr) {
1323    TInt vecType = KeyToIndexTypeN(attr).Val1;
1324    if (vecType == IntType) {
1325      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
1326    } else if (vecType == StrType) {
1327      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
1328    } else if (vecType == FltType) {
1329      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
1330    } else if (vecType ==IntVType) {
1331      TInt location = CheckDenseOrSparseN(attr);
1332      if (location == 0) VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1333      else VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1334    } else if (vecType == FltVType) { 
1335      TInt location = CheckDenseOrSparseN(attr);
1336      if (location == 0) VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1337      else VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1338    } else {
1339      return -1;
1340    }
1341    return 0;
1342  }
1343  int TNEANet::DelAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1344    TInt vecType = KeyToIndexTypeE(attr).Val1;
1345    if (vecType == IntType) {
1346      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
1347    } else if (vecType == StrType) {
1348      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
1349    } else if (vecType == FltType) {
1350      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
1351    } else if (vecType == IntVType) {
1352      TInt location = CheckDenseOrSparseE(attr);
1353      if (location == 0) VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1354      else VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1355    } else if (vecType == FltVType) {
1356      TInt location = CheckDenseOrSparseE(attr);
1357      if (location == 0) VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1358      else VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1359    } else {
1360      return -1;
1361    }
1362    return 0;
1363  }
1364  int TNEANet::AddIntAttrN(const TStr&amp; attr, TInt defaultValue){
1365    int i;
1366    TInt CurrLen;
1367    TVec&lt;TInt&gt; NewVec;
1368    CurrLen = VecOfIntVecsN.Len();
1369    KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
1370    NewVec = TVec&lt;TInt&gt;();
1371    for (i = 0; i &lt; MxNId; i++) {
1372      NewVec.Ins(i, defaultValue);
1373    }
1374    VecOfIntVecsN.Add(NewVec);
1375    if (!IntDefaultsN.IsKey(attr)) {
1376      IntDefaultsN.AddDat(attr, defaultValue);
1377    } else {
1378      return -1;
1379    }
1380    return 0;
1381  }
1382  int TNEANet::AddIntVAttrN(const TStr&amp; attr, TBool UseDense){
1383    TInt CurrLen;
1384    if (UseDense) {
1385      CurrLen = VecOfIntVecVecsN.Len();
1386      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1387      KeyToDenseN.AddDat(attr, true);
1388      TVec&lt;TIntV&gt; NewVec = TVec&lt;TIntV&gt;(MxNId);
1389      VecOfIntVecVecsN.Add(NewVec);
1390    } else {
1391      CurrLen = VecOfIntHashVecsN.Len();
1392      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1393      KeyToDenseN.AddDat(attr, false);
1394      THash&lt;TInt, TIntV&gt; NewHash;
1395      VecOfIntHashVecsN.Add(NewHash);
1396    }
1397    return 0;
1398  }
1399  int TNEANet::AddFltVAttrN(const TStr&amp; attr, TBool UseDense){
1400    TInt CurrLen;
1401    if (UseDense) {
1402      CurrLen = VecOfFltVecVecsN.Len();
1403      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1404      KeyToDenseN.AddDat(attr, true);
1405      TVec&lt;TFltV&gt; NewVec = TVec&lt;TFltV&gt;(MxNId);
1406      VecOfFltVecVecsN.Add(NewVec);
1407    } else {
1408      CurrLen = VecOfFltHashVecsN.Len();
1409      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1410      KeyToDenseN.AddDat(attr, false);
1411      THash&lt;TInt, TFltV&gt; NewHash;
1412      VecOfFltHashVecsN.Add(NewHash);
1413    }
1414    return 0;
1415  }
1416  int TNEANet::AddStrAttrN(const TStr&amp; attr, TStr defaultValue) {
1417    int i;
1418    TInt CurrLen;
1419    TVec&lt;TStr&gt; NewVec;
1420    CurrLen = VecOfStrVecsN.Len();
1421    KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1422    NewVec = TVec&lt;TStr&gt;();
1423    for (i = 0; i &lt; MxNId; i++) {
1424      NewVec.Ins(i, defaultValue);
1425    }
1426    VecOfStrVecsN.Add(NewVec);
1427    if (!StrDefaultsN.IsKey(attr)) {
1428      StrDefaultsN.AddDat(attr, defaultValue);
1429    } else {
1430      return -1;
1431    }
1432    return 0;
1433  }
1434  int TNEANet::AddFltAttrN(const TStr&amp; attr, TFlt defaultValue) {
1435    int i;
1436    TInt CurrLen;
1437    TVec&lt;TFlt&gt; NewVec;
1438    CurrLen = VecOfFltVecsN.Len();
1439    KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1440    NewVec = TVec&lt;TFlt&gt;();
1441    for (i = 0; i &lt; MxNId; i++) {
1442      NewVec.Ins(i, defaultValue);
1443    }
1444    VecOfFltVecsN.Add(NewVec);
1445    if (!FltDefaultsN.IsKey(attr)) {
1446      FltDefaultsN.AddDat(attr, defaultValue);
1447    } else {
1448      return -1;
1449    }
1450    return 0;
1451  }
1452  int TNEANet::AddIntAttrE(const TStr&amp; attr, TInt defaultValue){
1453    int i;
1454    TInt CurrLen;
1455    TVec&lt;TInt&gt; NewVec;
1456    CurrLen = VecOfIntVecsE.Len();
1457    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1458    NewVec = TVec&lt;TInt&gt;();
1459    for (i = 0; i &lt; MxEId; i++) {
1460      NewVec.Ins(i, defaultValue);
1461    }
1462    VecOfIntVecsE.Add(NewVec);
1463    if (!IntDefaultsE.IsKey(attr)) {
1464      IntDefaultsE.AddDat(attr, defaultValue);
1465    } else {
1466      return -1;
1467    }
1468    return 0;
1469  }
1470  int TNEANet::AddIntVAttrE(const TStr&amp; attr, TBool UseDense){
1471    TInt CurrLen;
1472    if (UseDense) {
1473      CurrLen = VecOfIntVecVecsE.Len();
1474      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1475      KeyToDenseE.AddDat(attr, true);
1476      TVec&lt;TIntV&gt; NewVec = TVec&lt;TIntV&gt;(MxEId);
1477      VecOfIntVecVecsE.Add(NewVec);
1478    } else {
1479      CurrLen = VecOfIntHashVecsE.Len();
1480      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1481      KeyToDenseE.AddDat(attr, false);
1482      THash&lt;TInt, TIntV&gt; NewHash;
1483      VecOfIntHashVecsE.Add(NewHash);
1484    }
1485    return 0;
1486  }
1487  int TNEANet::AddFltVAttrE(const TStr&amp; attr, TBool UseDense){
1488    TInt CurrLen;
1489    if (UseDense) {
1490      CurrLen = VecOfFltVecVecsE.Len();
1491      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1492      KeyToDenseE.AddDat(attr, true);
1493      TVec&lt;TFltV&gt; NewVec = TVec&lt;TFltV&gt;(MxEId);
1494      VecOfFltVecVecsE.Add(NewVec);
1495    } else {
1496      CurrLen = VecOfFltHashVecsE.Len();
1497      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1498      KeyToDenseE.AddDat(attr, false);
1499      THash&lt;TInt, TFltV&gt; NewHash;
1500      VecOfFltHashVecsE.Add(NewHash);
1501    }
1502    return 0;
1503  }
1504  int TNEANet::AddStrAttrE(const TStr&amp; attr, TStr defaultValue) {
1505    int i;
1506    TInt CurrLen;
1507    TVec&lt;TStr&gt; NewVec;
1508    CurrLen = VecOfStrVecsE.Len();
1509    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1510    NewVec = TVec&lt;TStr&gt;();
1511    for (i = 0; i &lt; MxEId; i++) {
1512      NewVec.Ins(i, defaultValue);
1513    }
1514    VecOfStrVecsE.Add(NewVec);
1515    if (!StrDefaultsE.IsKey(attr)) {
1516      StrDefaultsE.AddDat(attr, defaultValue);
1517    } else {
1518      return -1;
1519    }
1520    return 0;
1521  }
1522  int TNEANet::AddFltAttrE(const TStr&amp; attr, TFlt defaultValue) {
1523    int i;
1524    TInt CurrLen;
1525    TVec&lt;TFlt&gt; NewVec;
1526    CurrLen = VecOfFltVecsE.Len();
1527    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1528    NewVec = TVec&lt;TFlt&gt;();
1529    for (i = 0; i &lt; MxEId; i++) {
1530      NewVec.Ins(i, defaultValue);
1531    }
1532    VecOfFltVecsE.Add(NewVec);
1533    if (!FltDefaultsE.IsKey(attr)) {
1534      FltDefaultsE.AddDat(attr, defaultValue);
1535    } else {
1536      return -1;
1537    }
1538    return 0;
1539  }
1540  int TNEANet::DelAttrN(const TStr&amp; attr) {
1541    TInt vecType = KeyToIndexTypeN(attr).Val1;
1542    if (vecType == IntType) {
1543      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TInt&gt;();
1544      if (IntDefaultsN.IsKey(attr)) {
1545        IntDefaultsN.DelKey(attr);
1546      }
1547    } else if (vecType == StrType) {
1548      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TStr&gt;();  
1549      if (StrDefaultsN.IsKey(attr)) {
1550        StrDefaultsN.DelKey(attr);
1551      }
1552    } else if (vecType == FltType) {
1553      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TFlt&gt;();
1554      if (FltDefaultsN.IsKey(attr)) {
1555        FltDefaultsN.DelKey(attr);
1556      }
1557    } else if (vecType == IntVType) {
1558      TInt location = CheckDenseOrSparseN(attr);
1559      if (location == 1) VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TIntV&gt;();
1560      else VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash&lt;TInt, TIntV&gt;();
1561      KeyToDenseN.DelKey(attr);
1562    } else if (vecType == FltVType) {
1563      TInt location = CheckDenseOrSparseN(attr);
1564      if (location == 1) VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TFltV&gt;();
1565      else VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash&lt;TInt, TFltV&gt;();
1566      KeyToDenseN.DelKey(attr);
1567    } else {
1568      return -1;
1569    }
1570    KeyToIndexTypeN.DelKey(attr);
1571    return 0;
1572  }
1573  int TNEANet::DelAttrE(const TStr&amp; attr) {
1574    TInt vecType = KeyToIndexTypeE(attr).Val1;
1575    if (vecType == IntType) {
1576      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec&lt;TInt&gt;();
1577      if (IntDefaultsE.IsKey(attr)) {
1578        IntDefaultsE.DelKey(attr);
1579      }
1580    } else if (vecType == StrType) {
1581      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec&lt;TStr&gt;();
1582      if (StrDefaultsE.IsKey(attr)) {
1583        StrDefaultsE.DelKey(attr);
1584      }  
1585    } else if (vecType == FltType) {
1586      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec&lt;TFlt&gt;();
1587      if (FltDefaultsE.IsKey(attr)) {
1588        FltDefaultsE.DelKey(attr);
1589      }
1590    } else {
1591      return -1;
1592    }
1593    KeyToIndexTypeE.DelKey(attr);
1594    return 0;
1595  }
1596  PNEANet TNEANet::GetSmallGraph() {
1597    PNEANet Net = TNEANet::New();
1598    for (int i = 0; i &lt; 5; i++) { Net-&gt;AddNode(i); }
1599    Net-&gt;AddEdge(0,1);  Net-&gt;AddEdge(0,2);
1600    Net-&gt;AddEdge(0,3);  Net-&gt;AddEdge(0,4);
1601    Net-&gt;AddEdge(1,2);  Net-&gt;AddEdge(1,2);
1602    return Net;
1603  }
1604  void TNEANet::GetAttrNNames(TStrV&amp; IntAttrNames, TStrV&amp; FltAttrNames, TStrV&amp; StrAttrNames) const {
1605    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it &lt; KeyToIndexTypeN.EndI(); it++) {
1606      if (it.GetDat().GetVal1() == IntType) {
1607        IntAttrNames.Add(it.GetKey());
1608      }
1609      if (it.GetDat().GetVal1() == FltType) {
1610        FltAttrNames.Add(it.GetKey());
1611      }
1612      if (it.GetDat().GetVal1() == StrType) {
1613        StrAttrNames.Add(it.GetKey());
1614      }
1615    }
1616  }
1617  void TNEANet::GetAttrENames(TStrV&amp; IntAttrNames, TStrV&amp; FltAttrNames, TStrV&amp; StrAttrNames) const {
1618    for (TStrIntPrH::TIter it = KeyToIndexTypeE.BegI(); it &lt; KeyToIndexTypeE.EndI(); it++) {
1619      if (it.GetDat().GetVal1() == IntType) {
1620        IntAttrNames.Add(it.GetKey());
1621      }
1622      if (it.GetDat().GetVal1() == FltType) {
1623        FltAttrNames.Add(it.GetKey());
1624      }
1625      if (it.GetDat().GetVal1() == StrType) {
1626        StrAttrNames.Add(it.GetKey());
1627      }
1628    }
1629  }
1630  TFlt TNEANet::GetWeightOutEdges(const TNodeI&amp; NI, const TStr&amp; attr) {
1631    TNode Node = GetNode(NI.GetId());
1632    TIntV OutEIdV = Node.OutEIdV;
1633    TFlt total = 0;
1634    int len = Node.OutEIdV.Len();
1635    for (int i = 0; i &lt; len; i++) {
1636      total += GetFltAttrDatE(Node.OutEIdV[i], attr);
1637    }
1638    return total;
1639  }
1640  void TNEANet::GetWeightOutEdgesV(TFltV&amp; OutWeights, const TFltV&amp; AttrVal) {
1641    for (TEdgeI it = BegEI(); it &lt; EndEI(); it++) {
1642      int EId = it.GetId();
1643      int SrcId = it.GetSrcNId();
1644      OutWeights[SrcId] +=AttrVal[GetFltKeyIdE(EId)];
1645    }
1646  }
1647  bool TNEANet::IsFltAttrE(const TStr&amp; attr) {
1648    return (KeyToIndexTypeE.IsKey(attr) &amp;&amp;
1649      KeyToIndexTypeE.GetDat(attr).Val1 == FltType);
1650  }
1651  bool TNEANet::IsIntAttrE(const TStr&amp; attr) {
1652    return (KeyToIndexTypeE.IsKey(attr) &amp;&amp;
1653      KeyToIndexTypeE.GetDat(attr).Val1 == IntType);
1654  }
1655  bool TNEANet::IsStrAttrE(const TStr&amp; attr) {
1656    return (KeyToIndexTypeE.IsKey(attr) &amp;&amp;
1657      KeyToIndexTypeE.GetDat(attr).Val1 == StrType);
1658  }
1659  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TInt&amp; Val) {
1660    if (!IsNode(NId)) {
1661      return -1;
1662    }
1663    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1664  }
1665  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TInt&amp; Val) {
1666    if (!IsNode(NId)) {
1667      return -1;
1668    }
1669    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1670  }
1671  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TFlt&amp; Val) {
1672    if (!IsNode(NId)) {
1673      return -1;
1674    }
1675    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1676  }
1677  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TFlt&amp; Val) {
1678    if (!IsNode(NId)) {
1679      return -1;
1680    }
1681    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1682  }
1683  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TStr&amp; Val) {
1684    if (!IsNode(NId)) {
1685      return -1;
1686    }
1687    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1688  }
1689  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TStr&amp; Val) {
1690    if (!IsNode(NId)) {
1691      return -1;
1692    }
1693    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1694  }
1695  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TInt&amp; Val) const {
1696    if (!IsNode(NId)) {
1697      return -1;
1698    }
1699    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1700  }
1701  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TInt&amp; Val) const {
1702    if (!IsNode(NId)) {
1703      return -1;
1704    }
1705    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1706  }
1707  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TFlt&amp; Val) const {
1708    if (!IsNode(NId)) {
1709      return -1;
1710    }
1711    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1712  }
1713  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TFlt&amp; Val) const {
1714    if (!IsNode(NId)) {
1715      return -1;
1716    }
1717    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1718  }
1719  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TStr&amp; Val) const {
1720    if (!IsNode(NId)) {
1721      return -1;
1722    }
1723    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1724  }
1725  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TStr&amp; Val) const {
1726    if (!IsNode(NId)) {
1727      return -1;
1728    }
1729    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1730  }
1731  int TNEANet::DelSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName) {
1732    if (!IsNode(NId)) {
1733      return -1;
1734    }
1735    return SAttrN.DelSAttrDat(NId, AttrName);
1736  }
1737  int TNEANet::DelSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId) {
1738    if (!IsNode(NId)) {
1739      return -1;
1740    }
1741    return SAttrN.DelSAttrDat(NId, AttrId);
1742  }
1743  int TNEANet::GetSAttrVN(const TInt&amp; NId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
1744    if (!IsNode(NId)) {
1745      return -1;
1746    }
1747    SAttrN.GetSAttrV(NId, AttrType, AttrV);
1748    return 0;
1749  }
1750  int TNEANet::GetIdVSAttrN(const TStr&amp; AttrName, TIntV&amp; IdV) const {
1751    return SAttrN.GetIdVSAttr(AttrName, IdV);
1752  }
1753  int TNEANet::GetIdVSAttrN(const TInt&amp; AttrId, TIntV&amp; IdV) const {
1754    return SAttrN.GetIdVSAttr(AttrId, IdV);
1755  }
1756  int TNEANet::AddSAttrN(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
1757    return SAttrN.AddSAttr(Name, AttrType, AttrId);
1758  }
1759  int TNEANet::GetSAttrIdN(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
1760    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
1761  }
1762  int TNEANet::GetSAttrNameN(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
1763    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
1764  }
1765  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, const TInt&amp; Val) {
1766    if (!IsEdge(EId)) {
1767      return -1;
1768    }
1769    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1770  }
1771  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, const TInt&amp; Val) {
1772    if (!IsEdge(EId)) {
1773      return -1;
1774    }
1775    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1776  }
1777  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, const TFlt&amp; Val) {
1778    if (!IsEdge(EId)) {
1779      return -1;
1780    }
1781    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1782  }
1783  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, const TFlt&amp; Val) {
1784    if (!IsEdge(EId)) {
1785      return -1;
1786    }
1787    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1788  }
1789  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, const TStr&amp; Val) {
1790    if (!IsEdge(EId)) {
1791      return -1;
1792    }
1793    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1794  }
1795  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, const TStr&amp; Val) {
1796    if (!IsEdge(EId)) {
1797      return -1;
1798    }
1799    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1800  }
1801  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, TInt&amp; Val) const {
1802    if (!IsEdge(EId)) {
1803      return -1;
1804    }
1805    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1806  }
1807  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, TInt&amp; Val) const {
1808    if (!IsEdge(EId)) {
1809      return -1;
1810    }
1811    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1812  }
1813  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, TFlt&amp; Val) const {
1814    if (!IsEdge(EId)) {
1815      return -1;
1816    }
1817    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1818  }
1819  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, TFlt&amp; Val) const {
1820    if (!IsEdge(EId)) {
1821      return -1;
1822    }
1823    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1824  }
1825  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, TStr&amp; Val) const {
1826    if (!IsEdge(EId)) {
1827      return -1;
1828    }
1829    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1830  }
1831  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, TStr&amp; Val) const {
1832    if (!IsEdge(EId)) {
1833      return -1;
1834    }
1835    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1836  }
1837  int TNEANet::DelSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName) {
1838    if (!IsEdge(EId)) {
1839      return -1;
1840    }
1841    return SAttrE.DelSAttrDat(EId, AttrName);
1842  }
1843  int TNEANet::DelSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId) {
1844    if (!IsEdge(EId)) {
1845      return -1;
1846    }
1847    return SAttrE.DelSAttrDat(EId, AttrId);
1848  }
1849  int TNEANet::GetSAttrVE(const TInt&amp; EId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
1850    if (!IsEdge(EId)) {
1851      return -1;
1852    }
1853    SAttrE.GetSAttrV(EId, AttrType, AttrV);
1854    return 0;
1855  }
1856  int TNEANet::GetIdVSAttrE(const TStr&amp; AttrName, TIntV&amp; IdV) const {
1857    return SAttrE.GetIdVSAttr(AttrName, IdV);
1858  }
1859  int TNEANet::GetIdVSAttrE(const TInt&amp; AttrId, TIntV&amp; IdV) const {
1860    return SAttrE.GetIdVSAttr(AttrId, IdV);
1861  }
1862  int TNEANet::AddSAttrE(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
1863    return SAttrE.AddSAttr(Name, AttrType, AttrId);
1864  }
1865  int TNEANet::GetSAttrIdE(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
1866    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
1867  }
1868  int TNEANet::GetSAttrNameE(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
1869    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
1870  }
1871  bool TUndirNet::HasFlag(const TGraphFlag&amp; Flag) const {
1872    return HasGraphFlag(TUndirNet::TNet, Flag);
1873  }
1874  int TUndirNet::AddNode(int NId) {
1875    if (NId == -1) {
1876      NId = MxNId;  MxNId++;
1877    } else {
1878      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
1879      MxNId = TMath::Mx(NId+1, MxNId());
1880    }
1881    NodeH.AddDat(NId, TNode(NId));
1882    return NId;
1883  }
1884  int TUndirNet::AddNodeUnchecked(int NId) {
1885    if (NId == -1) {
1886      NId = MxNId;  MxNId++;
1887    } else {
1888      if (IsNode(NId)) { return -1;}
1889      MxNId = TMath::Mx(NId+1, MxNId());
1890    }
1891    NodeH.AddDat(NId, TNode(NId));
1892    return NId;
1893  }
1894  int TUndirNet::AddNode(const int&amp; NId, const TIntV&amp; NbrNIdV) {
1895    int NewNId;
1896    if (NId == -1) {
1897      NewNId = MxNId;  MxNId++;
1898    } else {
1899      IAssertR(! IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
1900      NewNId = NId;
1901      MxNId = TMath::Mx(NewNId+1, MxNId());
1902    }
1903    TNode&amp; Node = NodeH.AddDat(NewNId);
1904    Node.Id = NewNId;
1905    Node.NIdV = NbrNIdV;
1906    Node.NIdV.Sort();
1907    NEdges += Node.GetDeg();
1908    for (int i = 0; i &lt; NbrNIdV.Len(); i++) {
1909      GetNode(NbrNIdV[i]).NIdV.AddSorted(NewNId);
1910    }
1911    return NewNId;
1912  }
1913  int TUndirNet::AddNode(const int&amp; NId, const TVecPool&lt;TInt&gt;&amp; Pool, const int&amp; NIdVId) {
1914    int NewNId;
1915    if (NId == -1) {
1916      NewNId = MxNId;  MxNId++;
1917    } else {
1918      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
1919      NewNId = NId;
1920      MxNId = TMath::Mx(NewNId+1, MxNId()); 
1921    }
1922    TNode&amp; Node = NodeH.AddDat(NewNId);
1923    Node.Id = NewNId;
1924    Node.NIdV.GenExt(Pool.GetValVPt(NIdVId), Pool.GetVLen(NIdVId));
1925    Node.NIdV.Sort();
1926    NEdges += Node.GetDeg();
1927    return NewNId;
1928  }
1929  void TUndirNet::DelNode(const int&amp; NId) {
1930    { AssertR(IsNode(NId), TStr::Fmt(&quot;NodeId %d does not exist&quot;, NId));
1931    TInt Id(NId);
1932    SAttrN.DelSAttrId(Id);
1933    TNode&amp; Node = GetNode(NId);
1934    NEdges -= Node.GetDeg();
1935    for (int e = 0; e &lt; Node.GetDeg(); e++) {
1936      const int nbr = Node.GetNbrNId(e);
1937      if (nbr == NId) { continue; }
1938      TNode&amp; N = GetNode(nbr);
1939      const int n = N.NIdV.SearchBin(NId);
1940      IAssert(n != -1); 
1941      if (n!= -1) { N.NIdV.Del(n); }
1942    } }
1943    NodeH.DelKey(NId);
1944  }
1945  int TUndirNet::GetEdges() const {
1946    return NEdges;
1947  }
1948  int TUndirNet::AddEdge(const int&amp; SrcNId, const int&amp; DstNId) {
1949    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
1950    if (IsEdge(SrcNId, DstNId)) { return -2; } 
1951    GetNode(SrcNId).NIdV.AddSorted(DstNId);
1952    if (SrcNId!=DstNId) { 
1953      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
1954    NEdges++;
1955    return -1; 
1956  }
1957  int TUndirNet::AddEdgeUnchecked(const int&amp; SrcNId, const int&amp; DstNId) {
1958    GetNode(SrcNId).NIdV.Add(DstNId);
1959    if (SrcNId!=DstNId) { 
1960      GetNode(DstNId).NIdV.Add(SrcNId); }
1961    NEdges++;
1962    return -1; 
1963  }
1964  void TUndirNet::DelEdge(const int&amp; SrcNId, const int&amp; DstNId) {
1965    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
1966    { TNode&amp; N = GetNode(SrcNId);
1967    const int n = N.NIdV.SearchBin(DstNId);
1968    TIntPr Id(SrcNId, DstNId);
1969    SAttrE.DelSAttrId(Id);
1970    if (n!= -1) { N.NIdV.Del(n);  NEdges--; } }
1971    if (SrcNId != DstNId) { 
1972      TNode&amp; N = GetNode(DstNId);
1973      const int n = N.NIdV.SearchBin(SrcNId);
1974      if (n!= -1) { N.NIdV.Del(n); }
1975    }
1976  }
1977  bool TUndirNet::IsEdge(const int&amp; SrcNId, const int&amp; DstNId) const {
1978    if (! IsNode(SrcNId) || ! IsNode(DstNId)) return false;
1979    return GetNode(SrcNId).IsNbrNId(DstNId);
1980  }
1981  TUndirNet::TEdgeI TUndirNet::GetEI(const int&amp; SrcNId, const int&amp; DstNId) const {
1982    const int MnNId = TMath::Mn(SrcNId, DstNId);
1983    const int MxNId = TMath::Mx(SrcNId, DstNId);
1984    const TNodeI SrcNI = GetNI(MnNId);
1985    const int NodeN = SrcNI.NodeHI.GetDat().NIdV.SearchBin(MxNId);
1986    IAssert(NodeN != -1);
1987    return TEdgeI(SrcNI, EndNI(), NodeN);
1988  }
1989  void TUndirNet::GetNIdV(TIntV&amp; NIdV) const {
1990    NIdV.Gen(GetNodes(), 0);
1991    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
1992      NIdV.Add(NodeH.GetKey(N)); }
1993  }
1994  void TUndirNet::Defrag(const bool&amp; OnlyNodeLinks) {
1995    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
1996      NodeH[n].NIdV.Pack();
1997    }
1998    if (! OnlyNodeLinks &amp;&amp; ! NodeH.IsKeyIdEqKeyN()) {
1999      NodeH.Defrag();
2000    }
2001  }
2002  bool TUndirNet::IsOk(const bool&amp; ThrowExcept) const {
2003    bool RetVal = true;
2004    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2005      const TNode&amp; Node = NodeH[N];
2006      if (! Node.NIdV.IsSorted()) {
2007        const TStr Msg = TStr::Fmt(&quot;Neighbor list of node %d is not sorted.&quot;, Node.GetId());
2008        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2009        RetVal=false;
2010      }
2011      int prevNId = -1;
2012      for (int e = 0; e &lt; Node.GetDeg(); e++) {
2013        if (! IsNode(Node.GetNbrNId(e))) {
2014          const TStr Msg = TStr::Fmt(&quot;Edge %d --&gt; %d: node %d does not exist.&quot;,
2015            Node.GetId(), Node.GetNbrNId(e), Node.GetNbrNId(e));
2016          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2017          RetVal=false;
2018        }
2019        if (e &gt; 0 &amp;&amp; prevNId == Node.GetNbrNId(e)) {
2020          const TStr Msg = TStr::Fmt(&quot;Node %d has duplicate edge %d --&gt; %d.&quot;,
2021            Node.GetId(), Node.GetId(), Node.GetNbrNId(e));
2022          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2023          RetVal=false;
2024        }
2025        prevNId = Node.GetNbrNId(e);
2026      }
2027    }
2028    int EdgeCnt = 0;
2029    for (TEdgeI EI = BegEI(); EI &lt; EndEI(); EI++) { EdgeCnt++; }
2030    if (EdgeCnt != GetEdges()) {
2031      const TStr Msg = TStr::Fmt(&quot;Number of edges counter is corrupted: GetEdges():%d, EdgeCount:%d.&quot;, GetEdges(), EdgeCnt);
2032      if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2033      RetVal=false;
2034    }
2035    return RetVal;
2036  }
2037  void TUndirNet::Dump(FILE *OutF) const {
2038    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2039    fprintf(OutF, &quot;-------------------------------------------------\nUndirected Node Graph: nodes: %d, edges: %d\n&quot;, GetNodes(), GetEdges());
2040    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2041      const TNode&amp; Node = NodeH[N];
2042      fprintf(OutF, &quot;  %*d [%d] &quot;, NodePlaces, Node.GetId(), Node.GetDeg());
2043      for (int edge = 0; edge &lt; Node.GetDeg(); edge++) {
2044        fprintf(OutF, &quot; %*d&quot;, NodePlaces, Node.GetNbrNId(edge)); }
2045      fprintf(OutF, &quot;\n&quot;);
2046    }
2047    fprintf(OutF, &quot;\n&quot;);
2048  }
2049  PUndirNet TUndirNet::GetSmallGraph() {
2050    PUndirNet Graph = TUndirNet::New();
2051    for (int i = 0; i &lt; 5; i++) { Graph-&gt;AddNode(i); }
2052    Graph-&gt;AddEdge(0,1);  Graph-&gt;AddEdge(0,2);
2053    Graph-&gt;AddEdge(0,3);  Graph-&gt;AddEdge(0,4);
2054    Graph-&gt;AddEdge(1,2);
2055    return Graph;
2056  }
2057  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TInt&amp; Val) {
2058    if (!IsNode(NId)) {
2059      return -1;
2060    }
2061    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2062  }
2063  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TInt&amp; Val) {
2064    if (!IsNode(NId)) {
2065      return -1;
2066    }
2067    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2068  }
2069  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TFlt&amp; Val) {
2070    if (!IsNode(NId)) {
2071      return -1;
2072    }
2073    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2074  }
2075  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TFlt&amp; Val) {
2076    if (!IsNode(NId)) {
2077      return -1;
2078    }
2079    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2080  }
2081  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TStr&amp; Val) {
2082    if (!IsNode(NId)) {
2083      return -1;
2084    }
2085    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2086  }
2087  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TStr&amp; Val) {
2088    if (!IsNode(NId)) {
2089      return -1;
2090    }
2091    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2092  }
2093  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TInt&amp; Val) const {
2094    if (!IsNode(NId)) {
2095      return -1;
2096    }
2097    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2098  }
2099  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TInt&amp; Val) const {
2100    if (!IsNode(NId)) {
2101      return -1;
2102    }
2103    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2104  }
2105  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TFlt&amp; Val) const {
2106    if (!IsNode(NId)) {
2107      return -1;
2108    }
2109    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2110  }
2111  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TFlt&amp; Val) const {
2112    if (!IsNode(NId)) {
2113      return -1;
2114    }
2115    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2116  }
2117  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TStr&amp; Val) const {
2118    if (!IsNode(NId)) {
2119      return -1;
2120    }
2121    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2122  }
2123  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TStr&amp; Val) const {
2124    if (!IsNode(NId)) {
2125      return -1;
2126    }
2127    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2128  }
2129  int TUndirNet::DelSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName) {
2130    if (!IsNode(NId)) {
2131      return -1;
2132    }
2133    return SAttrN.DelSAttrDat(NId, AttrName);
2134  }
2135  int TUndirNet::DelSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId) {
2136    if (!IsNode(NId)) {
2137      return -1;
2138    }
2139    return SAttrN.DelSAttrDat(NId, AttrId);
2140  }
2141  int TUndirNet::GetSAttrVN(const TInt&amp; NId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
2142    if (!IsNode(NId)) {
2143      return -1;
2144    }
2145    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2146    return 0;
2147  }
2148  int TUndirNet::GetIdVSAttrN(const TStr&amp; AttrName, TIntV&amp; IdV) const {
2149    return SAttrN.GetIdVSAttr(AttrName, IdV);
2150  }
2151  int TUndirNet::GetIdVSAttrN(const TInt&amp; AttrId, TIntV&amp; IdV) const {
2152    return SAttrN.GetIdVSAttr(AttrId, IdV);
2153  }
2154  int TUndirNet::AddSAttrN(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
2155    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2156  }
2157  int TUndirNet::GetSAttrIdN(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
2158    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2159  }
2160  int TUndirNet::GetSAttrNameN(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
2161    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2162  }
2163  TIntPr TUndirNet::OrderEdgeNodes(const int&amp; SrcNId, const int&amp; DstNId) const{
2164    if (SrcNId &lt; DstNId) {
2165      return TIntPr(SrcNId, DstNId);
2166    }
2167    return TIntPr(DstNId, SrcNId);
2168  }
2169  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TInt&amp; Val) {
2170    if (!IsEdge(SrcNId, DstNId)) {
2171      return -1;
2172    }
2173    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2174    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2175  }
2176  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TInt&amp; Val) {
2177    if (!IsEdge(SrcNId, DstNId)) {
2178      return -1;
2179    }
2180    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2181    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2182  }
2183  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TFlt&amp; Val) {
2184    if (!IsEdge(SrcNId, DstNId)) {
2185      return -1;
2186    }
2187    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2188    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2189  }
2190  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TFlt&amp; Val) {
2191    if (!IsEdge(SrcNId, DstNId)) {
2192      return -1;
2193    }
2194    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2195    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2196  }
2197  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TStr&amp; Val) {
2198    if (!IsEdge(SrcNId, DstNId)) {
2199      return -1;
2200    }
2201    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2202    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2203  }
2204  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TStr&amp; Val) {
2205    if (!IsEdge(SrcNId, DstNId)) {
2206      return -1;
2207    }
2208    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2209    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2210  }
2211  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TInt&amp; Val) const {
2212    if (!IsEdge(SrcNId, DstNId)) {
2213      return -1;
2214    }
2215    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2216    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2217  }
2218  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TInt&amp; Val) const {
2219    if (!IsEdge(SrcNId, DstNId)) {
2220      return -1;
2221    }
2222    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2223    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2224  }
2225  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TFlt&amp; Val) const {
2226    if (!IsEdge(SrcNId, DstNId)) {
2227      return -1;
2228    }
2229    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2230    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2231  }
2232  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TFlt&amp; Val) const {
2233    if (!IsEdge(SrcNId, DstNId)) {
2234      return -1;
2235    }
2236    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2237    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2238  }
2239  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TStr&amp; Val) const {
2240    if (!IsEdge(SrcNId, DstNId)) {
2241      return -1;
2242    }
2243    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2244    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2245  }
2246  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TStr&amp; Val) const {
2247    if (!IsEdge(SrcNId, DstNId)) {
2248      return -1;
2249    }
2250    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2251    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2252  }
2253  int TUndirNet::DelSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName) {
2254    if (!IsEdge(SrcNId, DstNId)) {
2255      return -1;
2256    }
2257    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2258    return SAttrE.DelSAttrDat(EId, AttrName);
2259  }
2260  int TUndirNet::DelSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId) {
2261    if (!IsEdge(SrcNId, DstNId)) {
2262      return -1;
2263    }
2264    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2265    return SAttrE.DelSAttrDat(EId, AttrId);
2266  }
2267  int TUndirNet::GetSAttrVE(const int&amp; SrcNId, const int&amp; DstNId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
2268    if (!IsEdge(SrcNId, DstNId)) {
2269      return -1;
2270    }
2271    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2272    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2273    return 0;
2274  }
2275  int TUndirNet::GetIdVSAttrE(const TStr&amp; AttrName, TIntPrV&amp; IdV) const {
2276    return SAttrE.GetIdVSAttr(AttrName, IdV);
2277  }
2278  int TUndirNet::GetIdVSAttrE(const TInt&amp; AttrId, TIntPrV&amp; IdV) const {
2279    return SAttrE.GetIdVSAttr(AttrId, IdV);
2280  }
2281  int TUndirNet::AddSAttrE(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
2282    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2283  }
2284  int TUndirNet::GetSAttrIdE(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
2285    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2286  }
2287  int TUndirNet::GetSAttrNameE(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
2288    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2289  }
2290  bool TDirNet::HasFlag(const TGraphFlag&amp; Flag) const {
2291    return HasGraphFlag(TDirNet::TNet, Flag);
2292  }
2293  int TDirNet::AddNode(int NId) {
2294    if (NId == -1) {
2295      NId = MxNId;  MxNId++;
2296    } else {
2297      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
2298      MxNId = TMath::Mx(NId+1, MxNId());
2299    }
2300    NodeH.AddDat(NId, TNode(NId));
2301    return NId;
2302  }
2303  int TDirNet::AddNodeUnchecked(int NId) {
2304    if (NId == -1) {
2305      NId = MxNId;  MxNId++;
2306    } else {
2307      if (IsNode(NId)) { return -1;}
2308      MxNId = TMath::Mx(NId+1, MxNId());
2309    }
2310    NodeH.AddDat(NId, TNode(NId));
2311    return NId;
2312  }
2313  int TDirNet::AddNode(const int&amp; NId, const TIntV&amp; InNIdV, const TIntV&amp; OutNIdV) {
2314    int NewNId;
2315    if (NId == -1) {
2316      NewNId = MxNId;  MxNId++;
2317    } else {
2318      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
2319      NewNId = NId;
2320      MxNId = TMath::Mx(NewNId+1, MxNId());
2321    }
2322    TNode&amp; Node = NodeH.AddDat(NewNId);
2323    Node.Id = NewNId;
2324    Node.InNIdV = InNIdV;
2325    Node.OutNIdV = OutNIdV;
2326    Node.InNIdV.Sort();
2327    Node.OutNIdV.Sort();
2328    return NewNId;
2329  }
2330  int TDirNet::AddNode(const int&amp; NId, const TVecPool&lt;TInt&gt;&amp; Pool, const int&amp; SrcVId, const int&amp; DstVId) {
2331    int NewNId;
2332    if (NId == -1) {
2333      NewNId = MxNId;  MxNId++;
2334    } else {
2335      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
2336      NewNId = NId;
2337      MxNId = TMath::Mx(NewNId+1, MxNId());
2338    }
2339    TNode&amp; Node = NodeH.AddDat(NewNId);
2340    Node.Id = NewNId;
2341    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
2342    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
2343    Node.InNIdV.Sort();
2344    Node.OutNIdV.Sort();
2345    return NewNId;
2346  }
2347  void TDirNet::DelNode(const int&amp; NId) {
2348    { TNode&amp; Node = GetNode(NId);
2349    TInt Id(NId);
2350    SAttrN.DelSAttrId(Id);
2351    for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
2352    const int nbr = Node.GetOutNId(e);
2353    if (nbr == NId) { continue; }
2354      TNode&amp; N = GetNode(nbr);
2355      const int n = N.InNIdV.SearchBin(NId);
2356      if (n!= -1) { N.InNIdV.Del(n); }
2357    }
2358    for (int e = 0; e &lt; Node.GetInDeg(); e++) {
2359    const int nbr = Node.GetInNId(e);
2360    if (nbr == NId) { continue; }
2361      TNode&amp; N = GetNode(nbr);
2362      const int n = N.OutNIdV.SearchBin(NId);
2363      if (n!= -1) { N.OutNIdV.Del(n); }
2364    } }
2365    NodeH.DelKey(NId);
2366  }
2367  int TDirNet::GetEdges() const {
2368    int edges=0;
2369    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2370      edges+=NodeH[N].GetOutDeg();
2371    }
2372    return edges;
2373  }
2374  int TDirNet::AddEdge(const int&amp; SrcNId, const int&amp; DstNId) {
2375    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
2376    if (IsEdge(SrcNId, DstNId)) { return -2; }
2377    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
2378    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
2379    return -1; 
2380  }
2381  int TDirNet::AddEdgeUnchecked(const int&amp; SrcNId, const int&amp; DstNId) {
2382    GetNode(SrcNId).OutNIdV.Add(DstNId);
2383    GetNode(DstNId).InNIdV.Add(SrcNId);
2384    return -1; 
2385  }
2386  void TDirNet::DelEdge(const int&amp; SrcNId, const int&amp; DstNId, const bool&amp; IsDir) {
2387    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
2388    { TNode&amp; N = GetNode(SrcNId);
2389    TIntPr Id(SrcNId, DstNId);
2390    SAttrE.DelSAttrId(Id);
2391    const int n = N.OutNIdV.SearchBin(DstNId);
2392    if (n!= -1) { N.OutNIdV.Del(n); } }
2393    { TNode&amp; N = GetNode(DstNId);
2394    const int n = N.InNIdV.SearchBin(SrcNId);
2395    if (n!= -1) { N.InNIdV.Del(n); } }
2396    if (! IsDir) {
2397      { TNode&amp; N = GetNode(SrcNId);
2398      const int n = N.InNIdV.SearchBin(DstNId);
2399      if (n!= -1) { N.InNIdV.Del(n); } }
2400      { TNode&amp; N = GetNode(DstNId);
2401      const int n = N.OutNIdV.SearchBin(SrcNId);
2402      if (n!= -1) { N.OutNIdV.Del(n); } }
2403    }
2404  }
2405  bool TDirNet::IsEdge(const int&amp; SrcNId, const int&amp; DstNId, const bool&amp; IsDir) const {
2406    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
2407    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
2408    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
2409  }
2410  TDirNet::TEdgeI TDirNet::GetEI(const int&amp; SrcNId, const int&amp; DstNId) const {
2411    const TNodeI SrcNI = GetNI(SrcNId);
2412    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
2413    IAssert(NodeN != -1);
2414    return TEdgeI(SrcNI, EndNI(), NodeN);
2415  }
2416  void TDirNet::GetNIdV(TIntV&amp; NIdV) const {
2417    NIdV.Gen(GetNodes(), 0);
2418    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2419      NIdV.Add(NodeH.GetKey(N)); }
2420  }
2421  void TDirNet::Defrag(const bool&amp; OnlyNodeLinks) {
2422    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
2423      TNode&amp; Node = NodeH[n];
2424      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
2425    }
2426    if (! OnlyNodeLinks &amp;&amp; ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
2427  }
2428  bool TDirNet::IsOk(const bool&amp; ThrowExcept) const {
2429    bool RetVal = true;
2430    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2431      const TNode&amp; Node = NodeH[N];
2432      if (! Node.OutNIdV.IsSorted()) {
2433        const TStr Msg = TStr::Fmt(&quot;Out-neighbor list of node %d is not sorted.&quot;, Node.GetId());
2434        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2435      }
2436      if (! Node.InNIdV.IsSorted()) {
2437        const TStr Msg = TStr::Fmt(&quot;In-neighbor list of node %d is not sorted.&quot;, Node.GetId());
2438        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2439      }
2440      int prevNId = -1;
2441      for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
2442        if (! IsNode(Node.GetOutNId(e))) {
2443          const TStr Msg = TStr::Fmt(&quot;Out-edge %d --&gt; %d: node %d does not exist.&quot;,
2444            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
2445          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2446        }
2447        if (e &gt; 0 &amp;&amp; prevNId == Node.GetOutNId(e)) {
2448          const TStr Msg = TStr::Fmt(&quot;Node %d has duplidate out-edge %d --&gt; %d.&quot;,
2449            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
2450          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2451        }
2452        prevNId = Node.GetOutNId(e);
2453      }
2454      prevNId = -1;
2455      for (int e = 0; e &lt; Node.GetInDeg(); e++) {
2456        if (! IsNode(Node.GetInNId(e))) {
2457          const TStr Msg = TStr::Fmt(&quot;In-edge %d &lt;-- %d: node %d does not exist.&quot;,
2458            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
2459          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2460        }
2461        if (e &gt; 0 &amp;&amp; prevNId == Node.GetInNId(e)) {
2462          const TStr Msg = TStr::Fmt(&quot;Node %d has duplidate in-edge %d &lt;-- %d.&quot;,
2463            Node.GetId(), Node.GetId(), Node.GetInNId(e));
2464          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2465        }
2466        prevNId = Node.GetInNId(e);
2467      }
2468    }
2469    return RetVal;
2470  }
2471  void TDirNet::Dump(FILE *OutF) const {
2472    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2473    fprintf(OutF, &quot;-------------------------------------------------\nDirected Node Graph: nodes: %d, edges: %d\n&quot;, GetNodes(), GetEdges());
2474    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2475      const TNode&amp; Node = NodeH[N];
2476      fprintf(OutF, &quot;  %*d]\n&quot;, NodePlaces, Node.GetId());
2477      fprintf(OutF, &quot;    in [%d]&quot;, Node.GetInDeg());
2478      for (int edge = 0; edge &lt; Node.GetInDeg(); edge++) {
2479        fprintf(OutF, &quot; %*d&quot;, NodePlaces, Node.GetInNId(edge)); }
2480      fprintf(OutF, &quot;\n    out[%d]&quot;, Node.GetOutDeg());
2481      for (int edge = 0; edge &lt; Node.GetOutDeg(); edge++) {
2482        fprintf(OutF, &quot; %*d&quot;, NodePlaces, Node.GetOutNId(edge)); }
2483      fprintf(OutF, &quot;\n&quot;);
2484    }
2485    fprintf(OutF, &quot;\n&quot;);
2486  }
2487  PDirNet TDirNet::GetSmallGraph() {
2488    PDirNet G = TDirNet::New();
2489    for (int i = 0; i &lt; 5; i++) { G-&gt;AddNode(i); }
2490    G-&gt;AddEdge(0,1); G-&gt;AddEdge(1,2); G-&gt;AddEdge(0,2);
2491    G-&gt;AddEdge(1,3); G-&gt;AddEdge(3,4); G-&gt;AddEdge(2,3);
2492    return G;
2493  }
2494  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TInt&amp; Val) {
2495    if (!IsNode(NId)) {
2496      return -1;
2497    }
2498    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2499  }
2500  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TInt&amp; Val) {
2501    if (!IsNode(NId)) {
2502      return -1;
2503    }
2504    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2505  }
2506  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TFlt&amp; Val) {
2507    if (!IsNode(NId)) {
2508      return -1;
2509    }
2510    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2511  }
2512  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TFlt&amp; Val) {
2513    if (!IsNode(NId)) {
2514      return -1;
2515    }
2516    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2517  }
2518  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TStr&amp; Val) {
2519    if (!IsNode(NId)) {
2520      return -1;
2521    }
2522    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2523  }
2524  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TStr&amp; Val) {
2525    if (!IsNode(NId)) {
2526      return -1;
2527    }
2528    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2529  }
2530  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TInt&amp; Val) const {
2531    if (!IsNode(NId)) {
2532      return -1;
2533    }
2534    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2535  }
2536  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TInt&amp; Val) const {
2537    if (!IsNode(NId)) {
2538      return -1;
2539    }
2540    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2541  }
2542  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TFlt&amp; Val) const {
2543    if (!IsNode(NId)) {
2544      return -1;
2545    }
2546    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2547  }
2548  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TFlt&amp; Val) const {
2549    if (!IsNode(NId)) {
2550      return -1;
2551    }
2552    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2553  }
2554  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TStr&amp; Val) const {
2555    if (!IsNode(NId)) {
2556      return -1;
2557    }
2558    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2559  }
2560  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TStr&amp; Val) const {
2561    if (!IsNode(NId)) {
2562      return -1;
2563    }
2564    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2565  }
2566  int TDirNet::DelSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName) {
2567    if (!IsNode(NId)) {
2568      return -1;
2569    }
2570    return SAttrN.DelSAttrDat(NId, AttrName);
2571  }
2572  int TDirNet::DelSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId) {
2573    if (!IsNode(NId)) {
2574      return -1;
2575    }
2576    return SAttrN.DelSAttrDat(NId, AttrId);
2577  }
2578  int TDirNet::GetSAttrVN(const TInt&amp; NId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
2579    if (!IsNode(NId)) {
2580      return -1;
2581    }
2582    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2583    return 0;
2584  }
2585  int TDirNet::GetIdVSAttrN(const TStr&amp; AttrName, TIntV&amp; IdV) const {
2586    return SAttrN.GetIdVSAttr(AttrName, IdV);
2587  }
2588  int TDirNet::GetIdVSAttrN(const TInt&amp; AttrId, TIntV&amp; IdV) const {
2589    return SAttrN.GetIdVSAttr(AttrId, IdV);
2590  }
2591  int TDirNet::AddSAttrN(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
2592    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2593  }
2594  int TDirNet::GetSAttrIdN(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
2595    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2596  }
2597  int TDirNet::GetSAttrNameN(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
2598    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2599  }
2600  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TInt&amp; Val) {
2601    if (!IsEdge(SrcNId, DstNId)) {
2602      return -1;
2603    }
2604    TIntPr EId(SrcNId, DstNId);
2605    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2606  }
2607  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TInt&amp; Val) {
2608    if (!IsEdge(SrcNId, DstNId)) {
2609      return -1;
2610    }
2611    TIntPr EId(SrcNId, DstNId);
2612    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2613  }
2614  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TFlt&amp; Val) {
2615    if (!IsEdge(SrcNId, DstNId)) {
2616      return -1;
2617    }
2618    TIntPr EId(SrcNId, DstNId);
2619    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2620  }
2621  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TFlt&amp; Val) {
2622    if (!IsEdge(SrcNId, DstNId)) {
2623      return -1;
2624    }
2625    TIntPr EId(SrcNId, DstNId);
2626    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2627  }
2628  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TStr&amp; Val) {
2629    if (!IsEdge(SrcNId, DstNId)) {
2630      return -1;
2631    }
2632    TIntPr EId(SrcNId, DstNId);
2633    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2634  }
2635  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TStr&amp; Val) {
2636    if (!IsEdge(SrcNId, DstNId)) {
2637      return -1;
2638    }
2639    TIntPr EId(SrcNId, DstNId);
2640    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2641  }
2642  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TInt&amp; Val) const {
2643    if (!IsEdge(SrcNId, DstNId)) {
2644      return -1;
2645    }
2646    TIntPr EId(SrcNId, DstNId);
2647    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2648  }
2649  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TInt&amp; Val) const {
2650    if (!IsEdge(SrcNId, DstNId)) {
2651      return -1;
2652    }
2653    TIntPr EId(SrcNId, DstNId);
2654    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2655  }
2656  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TFlt&amp; Val) const {
2657    if (!IsEdge(SrcNId, DstNId)) {
2658      return -1;
2659    }
2660    TIntPr EId(SrcNId, DstNId);
2661    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2662  }
2663  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TFlt&amp; Val) const {
2664    if (!IsEdge(SrcNId, DstNId)) {
2665      return -1;
2666    }
2667    TIntPr EId(SrcNId, DstNId);
2668    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2669  }
2670  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TStr&amp; Val) const {
2671    if (!IsEdge(SrcNId, DstNId)) {
2672      return -1;
2673    }
2674    TIntPr EId(SrcNId, DstNId);
2675    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2676  }
2677  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TStr&amp; Val) const {
2678    if (!IsEdge(SrcNId, DstNId)) {
2679      return -1;
2680    }
2681    TIntPr EId(SrcNId, DstNId);
2682    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2683  }
2684  int TDirNet::DelSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName) {
2685    if (!IsEdge(SrcNId, DstNId)) {
2686      return -1;
2687    }
2688    TIntPr EId(SrcNId, DstNId);
2689    return SAttrE.DelSAttrDat(EId, AttrName);
2690  }
2691  int TDirNet::DelSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId) {
2692    if (!IsEdge(SrcNId, DstNId)) {
2693      return -1;
2694    }
2695    TIntPr EId(SrcNId, DstNId);
2696    return SAttrE.DelSAttrDat(EId, AttrId);
2697  }
2698  int TDirNet::GetSAttrVE(const int&amp; SrcNId, const int&amp; DstNId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
2699    if (!IsEdge(SrcNId, DstNId)) {
2700      return -1;
2701    }
2702    TIntPr EId(SrcNId, DstNId);
2703    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2704    return 0;
2705  }
2706  int TDirNet::GetIdVSAttrE(const TStr&amp; AttrName, TIntPrV&amp; IdV) const {
2707    return SAttrE.GetIdVSAttr(AttrName, IdV);
2708  }
2709  int TDirNet::GetIdVSAttrE(const TInt&amp; AttrId, TIntPrV&amp; IdV) const {
2710    return SAttrE.GetIdVSAttr(AttrId, IdV);
2711  }
2712  int TDirNet::AddSAttrE(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
2713    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2714  }
2715  int TDirNet::GetSAttrIdE(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
2716    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2717  }
2718  int TDirNet::GetSAttrNameE(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
2719    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2720  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</h3>
            <pre><code>1  void TNEANet::LoadNetworkShM(TShMIn&amp; ShMIn) {
2    MxNId = TInt(ShMIn);
3    MxEId = TInt(ShMIn);
4    LoadTNodeFunctor NodeFn;
5    NodeH.LoadShM(ShMIn, NodeFn);
6    EdgeH.LoadShM(ShMIn);
7    KeyToIndexTypeN.LoadShM(ShMIn);
8    KeyToIndexTypeE.LoadShM(ShMIn);
9    KeyToDenseN.LoadShM(ShMIn);
10    KeyToDenseE.LoadShM(ShMIn);
11    IntDefaultsN.LoadShM(ShMIn);
12    IntDefaultsE.LoadShM(ShMIn);
13    StrDefaultsN.LoadShM(ShMIn);
14    StrDefaultsE.LoadShM(ShMIn);
15    FltDefaultsE.LoadShM(ShMIn);
16    FltDefaultsE.LoadShM(ShMIn);
17    LoadVecFunctor vec_fn;
18    VecOfIntVecsN.LoadShM(ShMIn, vec_fn);
19    VecOfIntVecsE.LoadShM(ShMIn, vec_fn);
20    VecOfStrVecsN.Load(ShMIn);
21    VecOfStrVecsE.Load(ShMIn);
22    VecOfFltVecsN.Load(ShMIn);
23    VecOfFltVecsE.Load(ShMIn);
24    LoadVecOfVecFunctor vec_of_vec_fn;
25    VecOfIntVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
26    VecOfIntVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
27    VecOfFltVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
28    VecOfFltVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
29    LoadHashOfVecFunctor hash_of_vec_fn;
30    VecOfIntHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
31    VecOfIntHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
32    VecOfFltHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
33    VecOfFltHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
34    SAttrN.Load(ShMIn);
35    SAttrE.Load(ShMIn);
36  }
37  bool TNEANet::HasFlag(const TGraphFlag&amp; Flag) const {
38    return HasGraphFlag(TNEANet::TNet, Flag);
39  }
40  bool TNEANet::TNodeI::IsInNId(const int&amp; NId) const {
41    const TNode&amp; Node = NodeHI.GetDat();
42    for (int edge = 0; edge &lt; Node.GetInDeg(); edge++) {
43      if (NId == Graph-&gt;GetEdge(Node.GetInEId(edge)).GetSrcNId())
44        return true;
45    }
46    return false;
47  }
48  bool TNEANet::TNodeI::IsOutNId(const int&amp; NId) const {
49    const TNode&amp; Node = NodeHI.GetDat();
50    for (int edge = 0; edge &lt; Node.GetOutDeg(); edge++) {
51      if (NId == Graph-&gt;GetEdge(Node.GetOutEId(edge)).GetDstNId())
52        return true;
53    }
54    return false;
55  }
56  void TNEANet::AttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
57    Names = TVec&lt;TStr&gt;();
58    while (!NodeHI.IsEnd()) {
59      if (!NodeAttrIsDeleted(NId, NodeHI)) {
60        Names.Add(NodeHI.GetKey());
61      }
62      NodeHI++;
63    }  
64  }
65  void TNEANet::AttrValueNI(const TInt&amp; NId , TStrIntPrH::TIter NodeHI, TStrV&amp; Values) const {
66    Values = TVec&lt;TStr&gt;();
67    while (!NodeHI.IsEnd()) {
68      if (!NodeAttrIsDeleted(NId, NodeHI)) {
69        Values.Add(GetNodeAttrValue(NId, NodeHI));
70      }
71      NodeHI++;
72    }
73  }
74  void TNEANet::IntAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
75    Names = TVec&lt;TStr&gt;();
76    while (!NodeHI.IsEnd()) {
77      if (NodeHI.GetDat().Val1 == IntType &amp;&amp; !NodeAttrIsIntDeleted(NId, NodeHI)) {
78        Names.Add(NodeHI.GetKey());
79      }
80      NodeHI++;
81    }  
82  }
83  void TNEANet::IntAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TIntV&amp; Values) const {
84    Values = TVec&lt;TInt&gt;();
85    while (!NodeHI.IsEnd()) {
86      if (NodeHI.GetDat().Val1 == IntType &amp;&amp; !NodeAttrIsIntDeleted(NId, NodeHI)) {
87        TInt val = this-&gt;VecOfIntVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
88        Values.Add(val);
89      }
90      NodeHI++;
91    }  
92  }
93  void TNEANet::IntVAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
94    Names = TVec&lt;TStr&gt;();
95    while (!NodeHI.IsEnd()) {
96      if (NodeHI.GetDat().Val1 == IntVType) {
97        Names.Add(NodeHI.GetKey());
98      }
99      NodeHI++;
100    }  
101  }
102  void TNEANet::IntVAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TVec&lt;TIntV&gt;&amp; Values) const {
103    Values = TVec&lt;TIntV&gt;();
104    while (!NodeHI.IsEnd()) {
105      if (NodeHI.GetDat().Val1 == IntVType) {
106        TInt index = NodeHI.GetDat().Val2;
107        TStr attr =  NodeHI.GetKey();
108        TInt loc = CheckDenseOrSparseN(attr);
109        if (loc == 1) {
110          TIntV val = this-&gt;VecOfIntVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
111          if (val.Len() != 0) Values.Add(val);
112        } else {
113          const THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsN[index];
114          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
115            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
116          }
117        }
118      }
119      NodeHI++;
120    }
121  }
122  void TNEANet::FltVAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
123    Names = TVec&lt;TStr&gt;();
124    while (!NodeHI.IsEnd()) {
125      if (NodeHI.GetDat().Val1 == FltVType) {
126        Names.Add(NodeHI.GetKey());
127      }
128      NodeHI++;
129    }  
130  }
131  void TNEANet::FltVAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TVec&lt;TFltV&gt;&amp; Values) const {
132    Values = TVec&lt;TFltV&gt;();
133    while (!NodeHI.IsEnd()) {
134      if (NodeHI.GetDat().Val1 == FltVType) {
135        TInt index = NodeHI.GetDat().Val2;
136        TStr attr =  NodeHI.GetKey();
137        TInt loc = CheckDenseOrSparseN(attr);
138        if (loc == 1) {
139          TFltV val = this-&gt;VecOfFltVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
140          if (val.Len() != 0) Values.Add(val);
141        } else {
142          const THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsN[index];
143          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
144            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
145          }
146        }
147      }
148      NodeHI++;
149    }
150  }
151  void TNEANet::StrAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
152    Names = TVec&lt;TStr&gt;();
153    while (!NodeHI.IsEnd()) {
154      if (NodeHI.GetDat().Val1 == StrType &amp;&amp; !NodeAttrIsStrDeleted(NId, NodeHI)) {
155        Names.Add(NodeHI.GetKey());
156      }
157      NodeHI++;
158    }  
159  }
160  void TNEANet::StrAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Values) const {
161    Values = TVec&lt;TStr&gt;();
162    while (!NodeHI.IsEnd()) {
163      if (NodeHI.GetDat().Val1 == StrType &amp;&amp; !NodeAttrIsStrDeleted(NId, NodeHI)) {
164        TStr val = this-&gt;VecOfStrVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
165        Values.Add(val);
166      }
167      NodeHI++;
168    }  
169  }
170  void TNEANet::FltAttrNameNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TStrV&amp; Names) const {
171    Names = TVec&lt;TStr&gt;();
172    while (!NodeHI.IsEnd()) {
173      if (NodeHI.GetDat().Val1 == FltType &amp;&amp; !NodeAttrIsFltDeleted(NId, NodeHI)) {
174        Names.Add(NodeHI.GetKey());
175      }
176      NodeHI++;
177    }  
178  }
179  void TNEANet::FltAttrValueNI(const TInt&amp; NId, TStrIntPrH::TIter NodeHI, TFltV&amp; Values) const {
180    Values = TVec&lt;TFlt&gt;();
181    while (!NodeHI.IsEnd()) {
182      if (NodeHI.GetDat().Val1 == FltType &amp;&amp; !NodeAttrIsFltDeleted(NId, NodeHI)) {
183        TFlt val = (this-&gt;VecOfFltVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId)));
184        Values.Add(val);
185      }
186      NodeHI++;
187    }  
188  }
189  bool TNEANet::IsAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
190    bool IntDel = IsIntAttrDeletedN(NId, attr);
191    bool StrDel = IsStrAttrDeletedN(NId, attr);
192    bool FltDel = IsFltAttrDeletedN(NId, attr);
193    bool IntVDel = IsIntVAttrDeletedN(NId, attr);
194    bool FltVDel = IsFltVAttrDeletedN(NId, attr);
195    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
196  }
197  bool TNEANet::IsIntAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
198    return NodeAttrIsIntDeleted(NId, KeyToIndexTypeN.GetI(attr));
199  }
200  bool TNEANet::IsIntVAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
201    return NodeAttrIsIntVDeleted(NId, KeyToIndexTypeN.GetI(attr));
202  }
203  bool TNEANet::IsFltVAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
204    return NodeAttrIsFltVDeleted(NId, KeyToIndexTypeN.GetI(attr));
205  }
206  bool TNEANet::IsStrAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
207    return NodeAttrIsStrDeleted(NId, KeyToIndexTypeN.GetI(attr));
208  }
209  bool TNEANet::IsFltAttrDeletedN(const int&amp; NId, const TStr&amp; attr) const {
210    return NodeAttrIsFltDeleted(NId, KeyToIndexTypeN.GetI(attr));
211  }
212  bool TNEANet::NodeAttrIsDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
213    bool IntDel = NodeAttrIsIntDeleted(NId, NodeHI);
214    bool StrDel = NodeAttrIsStrDeleted(NId, NodeHI);
215    bool FltDel = NodeAttrIsFltDeleted(NId, NodeHI);
216    bool IntVDel = NodeAttrIsIntVDeleted(NId, NodeHI);
217    return IntDel || StrDel || FltDel || IntVDel;
218  }
219  bool TNEANet::NodeAttrIsIntDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
220    if (NodeHI.GetDat().Val1 != IntType) {
221      return false;
222    }
223    return (GetIntAttrDefaultN(NodeHI.GetKey()) == this-&gt;VecOfIntVecsN.GetVal(
224      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
225  }
226  bool TNEANet::NodeAttrIsIntVDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
227    if (NodeHI.GetDat().Val1 != IntVType) {
228      return false;
229    }
230    return (TIntV() == this-&gt;VecOfIntVecVecsN.GetVal(
231      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
232  }
233  bool TNEANet::NodeAttrIsFltVDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
234    if (NodeHI.GetDat().Val1 != FltVType) {
235      return false;
236    }
237    return (TFltV() == this-&gt;VecOfFltVecVecsN.GetVal(
238      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
239  }
240  bool TNEANet::NodeAttrIsStrDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
241    if (NodeHI.GetDat().Val1 != StrType) {
242      return false;
243    }
244    return (GetStrAttrDefaultN(NodeHI.GetKey()) == this-&gt;VecOfStrVecsN.GetVal(
245      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
246  }
247  bool TNEANet::NodeAttrIsFltDeleted(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
248    if (NodeHI.GetDat().Val1 != FltType) {
249      return false;
250    }
251    return (GetFltAttrDefaultN(NodeHI.GetKey()) == this-&gt;VecOfFltVecsN.GetVal(
252      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
253  }
254  TStr TNEANet::GetNodeAttrValue(const int&amp; NId, const TStrIntPrH::TIter&amp; NodeHI) const {
255    if (NodeHI.GetDat().Val1 == IntType) {
256      return (this-&gt;VecOfIntVecsN.GetVal(
257        this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
258    } else if(NodeHI.GetDat().Val1 == StrType) {
259      return this-&gt;VecOfStrVecsN.GetVal(
260      this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId));
261    } else if (NodeHI.GetDat().Val1 == FltType) {
262      return (this-&gt;VecOfFltVecsN.GetVal(
263        this-&gt;KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
264    }
265    return TStr::GetNullStr();
266  }
267  void TNEANet::AttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
268    Names = TVec&lt;TStr&gt;();
269    while (!EdgeHI.IsEnd()) {
270      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
271        Names.Add(EdgeHI.GetKey());
272      }
273      EdgeHI++;
274    }  
275  }
276  void TNEANet::AttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Values) const {
277    Values = TVec&lt;TStr&gt;();
278    while (!EdgeHI.IsEnd()) {
279      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
280        Values.Add(GetEdgeAttrValue(EId, EdgeHI));
281      }
282      EdgeHI++;
283    }  
284  }
285  void TNEANet::IntAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
286    Names = TVec&lt;TStr&gt;();
287    while (!EdgeHI.IsEnd()) {
288      if (EdgeHI.GetDat().Val1 == IntType &amp;&amp; !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
289        Names.Add(EdgeHI.GetKey());
290      }
291      EdgeHI++;
292    }  
293  }
294  void TNEANet::IntAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TIntV&amp; Values) const {
295    Values = TVec&lt;TInt&gt;();
296    while (!EdgeHI.IsEnd()) {
297      if (EdgeHI.GetDat().Val1 == IntType &amp;&amp; !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
298        TInt val = (this-&gt;VecOfIntVecsE[EdgeHI.GetDat().Val2].GetVal(EdgeH.GetKeyId(EId)));
299        Values.Add(val);
300      }
301      EdgeHI++;
302    }  
303  }
304  void TNEANet::IntVAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
305    Names = TVec&lt;TStr&gt;();
306    while (!EdgeHI.IsEnd()) {
307      if (EdgeHI.GetDat().Val1 == IntVType) {
308        Names.Add(EdgeHI.GetKey());
309      }
310      EdgeHI++;
311    }  
312  }
313  void TNEANet::IntVAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TVec&lt;TIntV&gt;&amp; Values) const {
314    Values = TVec&lt;TIntV&gt;();
315    while (!EdgeHI.IsEnd()) {
316      if (EdgeHI.GetDat().Val1 == IntVType) {
317        TInt index = EdgeHI.GetDat().Val2;
318        TStr attr =  EdgeHI.GetKey();
319        TInt loc = CheckDenseOrSparseE(attr);
320        if (loc == 1) {
<span onclick='openModal()' class='match'>321          TIntV val = this-&gt;VecOfIntVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
322          if (val.Len() != 0) Values.Add(val);
323        } else {
324          const THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsE[index];
325          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
326            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
327          }
328        }
329      }
330      EdgeHI++;
331    }
332  }
333  void TNEANet::FltVAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
334    Names = TVec&lt;TStr&gt;();
335    while (!EdgeHI.IsEnd()) {
336      if (EdgeHI.GetDat().Val1 == FltVType) {
</span>337        Names.Add(EdgeHI.GetKey());
338      }
339      EdgeHI++;
340    }  
341  }
342  void TNEANet::FltVAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TVec&lt;TFltV&gt;&amp; Values) const {
343    Values = TVec&lt;TFltV&gt;();
344    while (!EdgeHI.IsEnd()) {
345      if (EdgeHI.GetDat().Val1 == FltVType) {
346        TInt index = EdgeHI.GetDat().Val2;
347        TStr attr =  EdgeHI.GetKey();
348        TInt loc = CheckDenseOrSparseE(attr);
349        if (loc == 1) {
350          TFltV val = this-&gt;VecOfFltVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
351          if (val.Len() != 0) Values.Add(val);
352        } else {
353          const THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsE[index];
354          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
355            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
356          }
357        }
358      }
359      EdgeHI++;
360    }
361  }
362  void TNEANet::StrAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
363    Names = TVec&lt;TStr&gt;();
364    while (!EdgeHI.IsEnd()) {
365      if (EdgeHI.GetDat().Val1 == StrType &amp;&amp; !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
366        Names.Add(EdgeHI.GetKey());
367      }
368      EdgeHI++;
369    }  
370  }
371  void TNEANet::StrAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Values) const {
372    Values = TVec&lt;TStr&gt;();
373    while (!EdgeHI.IsEnd()) {
374      if (EdgeHI.GetDat().Val1 == StrType &amp;&amp; !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
375        TStr val = this-&gt;VecOfStrVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId);
376        Values.Add(val);
377      }
378      EdgeHI++;
379    }  
380  }
381  void TNEANet::FltAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
382    Names = TVec&lt;TStr&gt;();
383    while (!EdgeHI.IsEnd()) {
384      if (EdgeHI.GetDat().Val1 == FltType &amp;&amp; !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
385        Names.Add(EdgeHI.GetKey());
386      }
387      EdgeHI++;
388    }  
389  }
390  void TNEANet::FltAttrValueEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TFltV&amp; Values) const {
391    Values = TVec&lt;TFlt&gt;();
392    while (!EdgeHI.IsEnd()) {
393      if (EdgeHI.GetDat().Val1 == FltType &amp;&amp; !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
394        TFlt val = (this-&gt;VecOfFltVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
395        Values.Add(val);
396      }
397      EdgeHI++;
398    }  
399  }
400  bool TNEANet::IsAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
401    bool IntDel = IsIntAttrDeletedE(EId, attr);
402    bool IntVDel = IsIntVAttrDeletedE(EId, attr);
403    bool StrDel = IsStrAttrDeletedE(EId, attr);
404    bool FltDel = IsFltAttrDeletedE(EId, attr);
405    bool FltVDel = IsFltVAttrDeletedE(EId, attr);
406    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
407  }
408  bool TNEANet::IsIntAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
409    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
410  }
411  bool TNEANet::IsIntVAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
412    return EdgeAttrIsIntVDeleted(EId, KeyToIndexTypeE.GetI(attr));
413  }
414  bool TNEANet::IsFltVAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
415    return EdgeAttrIsFltVDeleted(EId, KeyToIndexTypeE.GetI(attr));
416  }
417  bool TNEANet::IsStrAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
418    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
419  }
420  bool TNEANet::IsFltAttrDeletedE(const int&amp; EId, const TStr&amp; attr) const {
421    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
422  }
423  bool TNEANet::EdgeAttrIsDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
424    bool IntDel = EdgeAttrIsIntDeleted(EId, EdgeHI);
425    bool IntVDel = EdgeAttrIsIntVDeleted(EId, EdgeHI);
426    bool StrDel = EdgeAttrIsStrDeleted(EId, EdgeHI);
427    bool FltDel = EdgeAttrIsFltDeleted(EId, EdgeHI);
428    bool FltVDel = EdgeAttrIsFltVDeleted(EId, EdgeHI);
429    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
430  }
431  bool TNEANet::EdgeAttrIsIntDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
432    return (EdgeHI.GetDat().Val1 == IntType &amp;&amp;
433      GetIntAttrDefaultE(EdgeHI.GetKey()) == this-&gt;VecOfIntVecsE.GetVal(
434      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
435  }
436  bool TNEANet::EdgeAttrIsIntVDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
437    return (EdgeHI.GetDat().Val1 == IntVType &amp;&amp;
438      TIntV() == this-&gt;VecOfIntVecVecsE.GetVal(
439      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
440  }
441  bool TNEANet::EdgeAttrIsFltVDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
442    return (EdgeHI.GetDat().Val1 == FltVType &amp;&amp;
443      TFltV() == this-&gt;VecOfFltVecVecsE.GetVal(
444      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
445  }
446  bool TNEANet::EdgeAttrIsStrDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
447    return (EdgeHI.GetDat().Val1 == StrType &amp;&amp;
448      GetStrAttrDefaultE(EdgeHI.GetKey()) == this-&gt;VecOfStrVecsE.GetVal(
449      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
450  }
451  bool TNEANet::EdgeAttrIsFltDeleted(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
452    return (EdgeHI.GetDat().Val1 == FltType &amp;&amp;
453      GetFltAttrDefaultE(EdgeHI.GetKey()) == this-&gt;VecOfFltVecsE.GetVal(
454      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
455  }
456  TStr TNEANet::GetEdgeAttrValue(const int&amp; EId, const TStrIntPrH::TIter&amp; EdgeHI) const {
457    if (EdgeHI.GetDat().Val1 == IntType) {
458      return (this-&gt;VecOfIntVecsE.GetVal(
459        this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
460    } else if(EdgeHI.GetDat().Val1 == StrType) {
461      return this-&gt;VecOfStrVecsE.GetVal(
462      this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId));
463    } else if (EdgeHI.GetDat().Val1 == FltType) {
464      return (this-&gt;VecOfFltVecsE.GetVal(
465        this-&gt;KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
466    }
467    return TStr::GetNullStr();
468  }
469  int TNEANet::AddNode(int NId) {
470    if (NId == -1) {
471      NId = MxNId;  MxNId++;
472    } else {
473      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
474      MxNId = TMath::Mx(NId+1, MxNId());
475    }
476    NodeH.AddDat(NId, TNode(NId));
477    AddAttributes(NId);
478    return NId;
479  }
480  int TNEANet::AddNodeUnchecked(int NId) {
481    if (NId == -1) {
482      NId = MxNId;  MxNId++;
483    } else {
484      if (IsNode(NId)) { return -1;}
485      MxNId = TMath::Mx(NId+1, MxNId());
486    }
487    NodeH.AddDat(NId, TNode(NId));
488    AddAttributes(NId);
489    return NId;
490  }
491  int TNEANet::AddAttributes(const int NId) {
492    int i;
493    for (i = 0; i &lt; VecOfIntVecsN.Len(); i++) {
494      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsN[i];
495      int KeyId = NodeH.GetKeyId(NId);
496      if (IntVec.Len() &gt; KeyId) {
497        IntVec[KeyId] = TInt::Mn;
498      } else {
499        IntVec.Ins(KeyId, TInt::Mn);
500      }
501    }
502    TVec&lt;TStr&gt; DefIntVec = TVec&lt;TStr&gt;();
503    IntDefaultsN.GetKeyV(DefIntVec);
504    for (i = 0; i &lt; DefIntVec.Len(); i++) {
505      TStr attr = DefIntVec[i];
506      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(DefIntVec[i]).Val2];
507      IntVec[NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
508    } 
509    for (i = 0; i &lt; VecOfStrVecsN.Len(); i++) {
510      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsN[i];
511      int KeyId = NodeH.GetKeyId(NId);
512      if (StrVec.Len() &gt; KeyId) {
513        StrVec[KeyId] = TStr::GetNullStr();
514      } else {
515        StrVec.Ins(KeyId, TStr::GetNullStr());
516      }
517    }
518    TVec&lt;TStr&gt; DefStrVec = TVec&lt;TStr&gt;();
519    StrDefaultsN.GetKeyV(DefStrVec);
520    for (i = 0; i &lt; DefStrVec.Len(); i++) {
521      TStr attr = DefStrVec[i];
522      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(DefStrVec[i]).Val2];
523      StrVec[NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
524    }
525    for (i = 0; i &lt; VecOfFltVecsN.Len(); i++) {
526      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsN[i];
527      int KeyId = NodeH.GetKeyId(NId);
528      if (FltVec.Len() &gt; KeyId) {
529        FltVec[KeyId] = TFlt::Mn;
530      } else {
531        FltVec.Ins(KeyId, TFlt::Mn);
532      }
533    }
534    TVec&lt;TStr&gt; DefFltVec = TVec&lt;TStr&gt;();
535    FltDefaultsN.GetKeyV(DefFltVec);
536    for (i = 0; i &lt; DefFltVec.Len(); i++) {
537      TStr attr = DefFltVec[i];
538      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(DefFltVec[i]).Val2];
539      FltVec[NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
540    }
541    for (i = 0; i &lt; VecOfIntVecVecsN.Len(); i++) {
542      TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsN[i];
543      int KeyId = NodeH.GetKeyId(NId);
544      if (IntVecV.Len() &gt; KeyId) {
545        IntVecV[KeyId] = TIntV();
546      } else {
547        IntVecV.Ins(KeyId, TIntV());
548      }
549    }
550    for (i = 0; i &lt; VecOfFltVecVecsN.Len(); i++) {
551      TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsN[i];
552      int KeyId = NodeH.GetKeyId(NId);
553      if (FltVecV.Len() &gt; KeyId) {
554        FltVecV[KeyId] = TFltV();
555      } else {
556        FltVecV.Ins(KeyId, TFltV());
557      }
558    }
559    return NId;
560  }
561  void TNEANet::DelNode(const int&amp; NId) {
562    int i;
563    TInt Id(NId);
564    SAttrN.DelSAttrId(Id);
565    const TNode&amp; Node = GetNode(NId);
566    for (int out = 0; out &lt; Node.GetOutDeg(); out++) {
567      const int EId = Node.GetOutEId(out);
568      const TEdge&amp; Edge = GetEdge(EId);
569      IAssert(Edge.GetSrcNId() == NId);
570      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
571      for (i = 0; i &lt; VecOfIntVecsE.Len(); i++) {
572        TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[i];
573        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
574      }
575      for (i = 0; i &lt; VecOfStrVecsE.Len(); i++) {
576        TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[i];
577        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
578      }
579      for (i = 0; i &lt; VecOfFltVecsE.Len(); i++) {
580        TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[i];
581        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
582      }
583      for (i = 0; i &lt; VecOfIntVecVecsE.Len(); i++) {
584        TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsE[i];
585        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
586      }
587      for (i = 0; i &lt; VecOfFltVecVecsE.Len(); i++) {
588        TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsE[i];
589        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
590      }
591      for (i = 0; i &lt; VecOfIntHashVecsE.Len(); i++) {
592        THash&lt;TInt, TIntV&gt;&amp; IntHashV = VecOfIntHashVecsE[i];
593        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
594          IntHashV.DelKey(EdgeH.GetKeyId(EId));
595        }
596      }
597      for (i = 0; i &lt; VecOfFltHashVecsE.Len(); i++) {
598        THash&lt;TInt, TFltV&gt;&amp; FltHashV = VecOfFltHashVecsE[i];
599        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
600          FltHashV.DelKey(EdgeH.GetKeyId(EId));
601        }
602      }
603      EdgeH.DelKey(EId);
604    }
605    for (int in = 0; in &lt; Node.GetInDeg(); in++) {
606      const int EId = Node.GetInEId(in);
607      const TEdge&amp; Edge = GetEdge(EId);
608      IAssert(Edge.GetDstNId() == NId);
609      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
610      for (i = 0; i &lt; VecOfIntVecsE.Len(); i++) {
611        TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[i];
612        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
613      }
614      for (i = 0; i &lt; VecOfStrVecsE.Len(); i++) {
615        TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[i];
616        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
617      }
618      for (i = 0; i &lt; VecOfFltVecsE.Len(); i++) {
619        TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[i];
620        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
621      }
622      for (i = 0; i &lt; VecOfIntVecVecsE.Len(); i++) {
623        TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsE[i];
624        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
625      }
626      for (i = 0; i &lt; VecOfFltVecVecsE.Len(); i++) {
627        TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsE[i];
628        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
629      }
630      for (i = 0; i &lt; VecOfIntHashVecsE.Len(); i++) {
631        THash&lt;TInt, TIntV&gt;&amp; IntHashV = VecOfIntHashVecsE[i];
632        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
633          IntHashV.DelKey(EdgeH.GetKeyId(EId));
634        }
635      }
636      for (i = 0; i &lt; VecOfFltHashVecsE.Len(); i++) {
637        THash&lt;TInt, TFltV&gt;&amp; FltHashV = VecOfFltHashVecsE[i];
638        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
639          FltHashV.DelKey(EdgeH.GetKeyId(EId));
640        }
641      }
642      EdgeH.DelKey(EId);
643    }
644    for (i = 0; i &lt; VecOfIntVecsN.Len(); i++) {
645      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsN[i];
646      IntVec[NodeH.GetKeyId(NId)] = TInt::Mn;
647    }
648    for (i = 0; i &lt; VecOfStrVecsN.Len(); i++) {
649      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsN[i];
650      StrVec[NodeH.GetKeyId(NId)] = TStr::GetNullStr();
651    }
652    for (i = 0; i &lt; VecOfFltVecsN.Len(); i++) {
653      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsN[i];
654      FltVec[NodeH.GetKeyId(NId)] = TFlt::Mn;
655    }
656    for (i = 0; i &lt; VecOfIntVecVecsN.Len(); i++) {
657      TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsN[i];
658      IntVecV[NodeH.GetKeyId(NId)] = TIntV();
659    }
660    for (i = 0; i &lt; VecOfFltVecVecsN.Len(); i++) {
661      TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsN[i];
662      FltVecV[NodeH.GetKeyId(NId)] = TFltV();
663    }
664    for (i = 0; i &lt; VecOfIntHashVecsN.Len(); i++) {
665      THash&lt;TInt, TIntV&gt;&amp; IntHashV = VecOfIntHashVecsN[i];
666      if (IntHashV.IsKey(NodeH.GetKeyId(NId))) {
667        IntHashV.DelKey(NodeH.GetKeyId(NId));
668      }
669    }
670    for (i = 0; i &lt; VecOfFltHashVecsN.Len(); i++) {
671      THash&lt;TInt, TFltV&gt;&amp; FltHashV = VecOfFltHashVecsN[i];
672      if (FltHashV.IsKey(NodeH.GetKeyId(NId))) {
673        FltHashV.DelKey(NodeH.GetKeyId(NId));
674      }
675    }
676    NodeH.DelKey(NId);
677  }
678  int TNEANet::AddEdge(const int&amp; SrcNId, const int&amp; DstNId, int EId) {
679    int i;
680    if (EId == -1) { EId = MxEId;  MxEId++; }
681    else { MxEId = TMath::Mx(EId+1, MxEId()); }
682    IAssertR(!IsEdge(EId), TStr::Fmt(&quot;EdgeId %d already exists&quot;, EId));
683    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
684    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
685    GetNode(SrcNId).OutEIdV.AddSorted(EId);
686    GetNode(DstNId).InEIdV.AddSorted(EId);
687    for (i = 0; i &lt; VecOfIntVecsE.Len(); i++) {
688      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[i];
689      int KeyId = EdgeH.GetKeyId(EId);
690      if (IntVec.Len() &gt; KeyId) {
691        IntVec[KeyId] = TInt::Mn;
692      } else {
693        IntVec.Ins(KeyId, TInt::Mn);
694      }
695    }
696    TVec&lt;TStr&gt; DefIntVec = TVec&lt;TStr&gt;();
697    IntDefaultsE.GetKeyV(DefIntVec);
698    for (i = 0; i &lt; DefIntVec.Len(); i++) {
699      TStr attr = DefIntVec[i];
700      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
701      IntVec[EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
702    }
703    for (i = 0; i &lt; VecOfIntVecVecsE.Len(); i++) {
704      TVec&lt;TIntV&gt;&amp; IntVecV = VecOfIntVecVecsE[i];
705      IntVecV.Ins(EdgeH.GetKeyId(EId), TIntV());
706    }
707    for (i = 0; i &lt; VecOfFltVecVecsE.Len(); i++) {
708      TVec&lt;TFltV&gt;&amp; FltVecV = VecOfFltVecVecsE[i];
709      FltVecV.Ins(EdgeH.GetKeyId(EId), TFltV());
710    }
711    for (i = 0; i &lt; VecOfStrVecsE.Len(); i++) {
712      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[i];
713      int KeyId = EdgeH.GetKeyId(EId);
714      if (StrVec.Len() &gt; KeyId) {
715        StrVec[KeyId] = TStr::GetNullStr();
716      } else {
717        StrVec.Ins(KeyId, TStr::GetNullStr());
718      }
719    }
720    TVec&lt;TStr&gt; DefStrVec = TVec&lt;TStr&gt;();
721    StrDefaultsE.GetKeyV(DefStrVec);
722    for (i = 0; i &lt; DefStrVec.Len(); i++) {
723      TStr attr = DefStrVec[i];
724      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
725      StrVec[EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
726    }
727    for (i = 0; i &lt; VecOfFltVecsE.Len(); i++) {
728      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[i];
729      int KeyId = EdgeH.GetKeyId(EId);
730      if (FltVec.Len() &gt; KeyId) {
731        FltVec[KeyId] = TFlt::Mn;
732      } else {
733        FltVec.Ins(KeyId, TFlt::Mn);
734      }
735    }
736    TVec&lt;TStr&gt; DefFltVec = TVec&lt;TStr&gt;();
737    FltDefaultsE.GetKeyV(DefFltVec);
738    for (i = 0; i &lt; DefFltVec.Len(); i++) {
739      TStr attr = DefFltVec[i];
740      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
741      FltVec[EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
742    }
743    return EId;
744  }
745  void TNEANet::DelEdge(const int&amp; EId) {
746    int i;
747    IAssert(IsEdge(EId));
748    const int SrcNId = GetEdge(EId).GetSrcNId();
749    const int DstNId = GetEdge(EId).GetDstNId();
750    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
751    GetNode(DstNId).InEIdV.DelIfIn(EId);
752    TInt Id(EId);
753    SAttrE.DelSAttrId(Id);
754    for (i = 0; i &lt; VecOfIntVecsE.Len(); i++) {
755      TVec&lt;TInt&gt;&amp; IntVec = VecOfIntVecsE[i];
756      IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
757    }
758    for (i = 0; i &lt; VecOfStrVecsE.Len(); i++) {
759      TVec&lt;TStr&gt;&amp; StrVec = VecOfStrVecsE[i];
760      StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
761    }
762    for (i = 0; i &lt; VecOfFltVecsE.Len(); i++) {
763      TVec&lt;TFlt&gt;&amp; FltVec = VecOfFltVecsE[i];
764      FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
765    }
766    EdgeH.DelKey(EId);
767  }
768  void TNEANet::DelEdge(const int&amp; SrcNId, const int&amp; DstNId, const bool&amp; IsDir) {
769    int EId = 0;
770    bool Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
771    IAssert(Edge); 
772    while (Edge) {
773      DelEdge(EId);
774      Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
775    }
776  }
777  bool TNEANet::IsEdge(const int&amp; SrcNId, const int&amp; DstNId, int&amp; EId, const bool&amp; IsDir) const {
778    if (! IsNode(SrcNId) || ! IsNode(DstNId)) {
779      return false;
780    }
781    const TNode&amp; SrcNode = GetNode(SrcNId);
782    for (int edge = 0; edge &lt; SrcNode.GetOutDeg(); edge++) {
783      const TEdge&amp; Edge = GetEdge(SrcNode.GetOutEId(edge));
784      if (DstNId == Edge.GetDstNId()) {
785        EId = Edge.GetId();
786        return true;
787      }
788    }
789    if (! IsDir) {
790      for (int edge = 0; edge &lt; SrcNode.GetInDeg(); edge++) {
791        const TEdge&amp; Edge = GetEdge(SrcNode.GetInEId(edge));
792        if (DstNId == Edge.GetSrcNId()) {
793          EId = Edge.GetId();
794          return true;
795        }
796      }
797    }
798    return false;
799  }
800  void TNEANet::GetNIdV(TIntV&amp; NIdV) const {
801    NIdV.Gen(GetNodes(), 0);
802    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
803      NIdV.Add(NodeH.GetKey(N));
804    }
805  }
806  void TNEANet::GetEIdV(TIntV&amp; EIdV) const {
807    EIdV.Gen(GetEdges(), 0);
808    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
809      EIdV.Add(EdgeH.GetKey(E));
810    }
811  }
812  void TNEANet::Defrag(const bool&amp; OnlyNodeLinks) {
813    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
814      TNode&amp; Node = NodeH[kid];
815      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
816    }
817    if (! OnlyNodeLinks &amp;&amp; ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
818    if (! OnlyNodeLinks &amp;&amp; ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
819  }
820  bool TNEANet::IsOk(const bool&amp; ThrowExcept) const {
821    bool RetVal = true;
822    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
823      const TNode&amp; Node = NodeH[N];
824      if (! Node.OutEIdV.IsSorted()) {
825        const TStr Msg = TStr::Fmt(&quot;Out-edge list of node %d is not sorted.&quot;, Node.GetId());
826        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
827      }
828      if (! Node.InEIdV.IsSorted()) {
829        const TStr Msg = TStr::Fmt(&quot;In-edge list of node %d is not sorted.&quot;, Node.GetId());
830        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
831      }
832      int prevEId = -1;
833      for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
834        if (! IsEdge(Node.GetOutEId(e))) {
835          const TStr Msg = TStr::Fmt(&quot;Out-edge id %d of node %d does not exist.&quot;,  Node.GetOutEId(e), Node.GetId());
836          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
837        }
838        if (e &gt; 0 &amp;&amp; prevEId == Node.GetOutEId(e)) {
839          const TStr Msg = TStr::Fmt(&quot;Node %d has duplidate out-edge id %d.&quot;, Node.GetId(), Node.GetOutEId(e));
840          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
841        }
842        prevEId = Node.GetOutEId(e);
843      }
844      prevEId = -1;
845      for (int e = 0; e &lt; Node.GetInDeg(); e++) {
846        if (! IsEdge(Node.GetInEId(e))) {
847        const TStr Msg = TStr::Fmt(&quot;Out-edge id %d of node %d does not exist.&quot;,  Node.GetInEId(e), Node.GetId());
848        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
849        }
850        if (e &gt; 0 &amp;&amp; prevEId == Node.GetInEId(e)) {
851          const TStr Msg = TStr::Fmt(&quot;Node %d has duplidate out-edge id %d.&quot;, Node.GetId(), Node.GetInEId(e));
852          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
853        }
854        prevEId = Node.GetInEId(e);
855      }
856    }
857    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
858      const TEdge&amp; Edge = EdgeH[E];
859      if (! IsNode(Edge.GetSrcNId())) {
860        const TStr Msg = TStr::Fmt(&quot;Edge %d source node %d does not exist.&quot;, Edge.GetId(), Edge.GetSrcNId());
861        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
862      }
863      if (! IsNode(Edge.GetDstNId())) {
864        const TStr Msg = TStr::Fmt(&quot;Edge %d destination node %d does not exist.&quot;, Edge.GetId(), Edge.GetDstNId());
865        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
866      }
867    }
868    return RetVal;
869  }
870  void TNEANet::Dump(FILE *OutF) const {
871    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
872    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
873    fprintf(OutF, &quot;-------------------------------------------------\nDirected Node-Edge Network with Attributes: nodes: %d, edges: %d\n&quot;, GetNodes(), GetEdges());
874    for (TNodeI NodeI = BegNI(); NodeI &lt; EndNI(); NodeI++) {
875      fprintf(OutF, &quot;  %*d:&quot;, NodePlaces, NodeI.GetId());
876      fprintf(OutF, &quot;    in[%d]&quot;, NodeI.GetInDeg());
877      for (int edge = 0; edge &lt; NodeI.GetInDeg(); edge++) {
878        fprintf(OutF, &quot; %*d&quot;, EdgePlaces, NodeI.GetInEId(edge)); }
879      fprintf(OutF, &quot;    out[%d]&quot;, NodeI.GetOutDeg());
880      for (int edge = 0; edge &lt; NodeI.GetOutDeg(); edge++) {
881        fprintf(OutF, &quot; %*d&quot;, EdgePlaces, NodeI.GetOutEId(edge)); }
882      TIntV IntAttrN;
883      IntAttrValueNI(NodeI.GetId(), IntAttrN);
884      fprintf(OutF, &quot;    nai[%d]&quot;, IntAttrN.Len());
885      for (int i = 0; i &lt; IntAttrN.Len(); i++) {
886        fprintf(OutF, &quot; %*i&quot;, NodePlaces, IntAttrN[i]()); }
887      TStrV StrAttrN;
888      StrAttrValueNI(NodeI.GetId(), StrAttrN);
889      fprintf(OutF, &quot;    nas[%d]&quot;, StrAttrN.Len());
890      for (int i = 0; i &lt; StrAttrN.Len(); i++) {
891        fprintf(OutF, &quot; %*s&quot;, NodePlaces, StrAttrN[i]()); }
892      TFltV FltAttrN;
893      FltAttrValueNI(NodeI.GetId(), FltAttrN);
894      fprintf(OutF, &quot;    naf[%d]&quot;, FltAttrN.Len());
895      for (int i = 0; i &lt; FltAttrN.Len(); i++) {
896        fprintf(OutF, &quot; %*f&quot;, NodePlaces, FltAttrN[i]()); }
897      fprintf(OutF, &quot;\n&quot;);
898    }
899    for (TEdgeI EdgeI = BegEI(); EdgeI &lt; EndEI(); EdgeI++) {
900      fprintf(OutF, &quot;  %*d:  %*d  -&gt;  %*d&quot;, EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
901      TIntV IntAttrE;
902      IntAttrValueEI(EdgeI.GetId(), IntAttrE);
903      fprintf(OutF, &quot;    eai[%d]&quot;, IntAttrE.Len());
904      for (int i = 0; i &lt; IntAttrE.Len(); i++) {
905        fprintf(OutF, &quot; %*i&quot;, EdgePlaces, IntAttrE[i]()); 
906      }
907      TStrV StrAttrE;
908      StrAttrValueEI(EdgeI.GetId(), StrAttrE);
909      fprintf(OutF, &quot;    eas[%d]&quot;, StrAttrE.Len());
910      for (int i = 0; i &lt; StrAttrE.Len(); i++) {
911        fprintf(OutF, &quot; %*s&quot;, EdgePlaces, StrAttrE[i]()); 
912      }
913      TFltV FltAttrE;
914      FltAttrValueEI(EdgeI.GetId(), FltAttrE);
915      fprintf(OutF, &quot;    eaf[%d]&quot;, FltAttrE.Len());
916      for (int i = 0; i &lt; FltAttrE.Len(); i++) {
917        fprintf(OutF, &quot; %*f&quot;, EdgePlaces, FltAttrE[i]()); 
918      }
919      fprintf(OutF, &quot;\n&quot;);
920    }
921  }
922  int TNEANet::AddIntAttrDatN(const int&amp; NId, const TInt&amp; value, const TStr&amp; attr) {
923    int i;
924    TInt CurrLen;
925    if (!IsNode(NId)) {
926      return -1;
927    }
928    if (KeyToIndexTypeN.IsKey(attr)) {
929      TVec&lt;TInt&gt;&amp; NewVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
930      NewVec[NodeH.GetKeyId(NId)] = value;
931    } else {
932      CurrLen = VecOfIntVecsN.Len();
933      KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
934      TVec&lt;TInt&gt; NewVec = TVec&lt;TInt&gt;();
935      for (i = 0; i &lt; MxNId; i++) {
936        NewVec.Ins(i, GetIntAttrDefaultN(attr));
937      }
938      NewVec[NodeH.GetKeyId(NId)] = value;
939      VecOfIntVecsN.Add(NewVec);
940    }
941    return 0;
942  }
943  int TNEANet::AddIntVAttrDatN(const int&amp; NId, const TIntV&amp; value, const TStr&amp; attr, TBool UseDense) {
944    if (!IsNode(NId)) {
945      return -1;
946    }
947    TInt location = CheckDenseOrSparseN(attr);
948    if (location==-1) {
949      AddIntVAttrN(attr, UseDense);
950      location = CheckDenseOrSparseN(attr);
951    }
952    if (UseDense) {
953      IAssertR(location != 0, TStr::Fmt(&quot;NodeId %d exists for %s in sparse representation&quot;, NId, attr.CStr()));
954      TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
955      NewVec[NodeH.GetKeyId(NId)] = value;
956    } else {
957      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, NId, attr.CStr()));
958      THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
959      NewHash.AddDat(NodeH.GetKeyId(NId), value);
960    }
961    return 0;
962  } 
963  int TNEANet::AddFltVAttrDatN(const int&amp; NId, const TFltV&amp; value, const TStr&amp; attr, TBool UseDense) {
964    if (!IsNode(NId)) {
965      return -1;
966    }
967    TInt location = CheckDenseOrSparseN(attr);
968    if (location==-1) {
969      AddFltVAttrN(attr, UseDense);
970      location = CheckDenseOrSparseN(attr);
971    }
972    if (UseDense) {
973      IAssertR(location != 0, TStr::Fmt(&quot;NodeId %d exists for %s in sparse representation&quot;, NId, attr.CStr()));
974      TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
975      NewVec[NodeH.GetKeyId(NId)] = value;
976    } else {
977      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, NId, attr.CStr()));
978      THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
979      NewHash.AddDat(NodeH.GetKeyId(NId), value);
980    }
981    return 0;
982  } 
983  int TNEANet::AppendIntVAttrDatN(const int&amp; NId, const TInt&amp; value, const TStr&amp; attr, TBool UseDense) {
984    if (!IsNode(NId)) {
985      return -1;
986    }
987    TInt location = CheckDenseOrSparseN(attr);
988    if (location==-1) {
989      AddIntVAttrN(attr, UseDense);
990      location = CheckDenseOrSparseN(attr);
991    }
992    if (UseDense) {
993      IAssertR(location != 0, TStr::Fmt(&quot;NodeId %d exists for %s in sparse representation&quot;, NId, attr.CStr()));
994      TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
995      NewVec[NodeH.GetKeyId(NId)].Add(value);
996    } else {
997      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, NId, attr.CStr()));
998      THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
999      NewHash[NodeH.GetKeyId(NId)].Add(value);
1000    }
1001    return 0;
1002  } 
1003  int TNEANet::AppendFltVAttrDatN(const int&amp; NId, const TFlt&amp; value, const TStr&amp; attr, TBool UseDense) {
1004    if (!IsNode(NId)) {
1005      return -1;
1006    }
1007    TInt location = CheckDenseOrSparseN(attr);
1008    if (location==-1) {
1009      AddFltVAttrN(attr, UseDense);
1010      location = CheckDenseOrSparseN(attr);
1011    }
1012    if (UseDense) {
1013      IAssertR(location != 0, TStr::Fmt(&quot;NodeId %d exists for %s in sparse representation&quot;, NId, attr.CStr()));
1014      TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1015      NewVec[NodeH.GetKeyId(NId)].Add(value);
1016    } else {
1017      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, NId, attr.CStr()));
1018      THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1019      NewHash[NodeH.GetKeyId(NId)].Add(value);
1020    }
1021    return 0;
1022  } 
1023  int TNEANet::DelFromIntVAttrDatN(const int&amp; NId, const TInt&amp; value, const TStr&amp; attr) {
1024    TInt CurrLen;
1025    if (!IsNode(NId)) {
1026      return -1;
1027    }
1028    TInt location = CheckDenseOrSparseN(attr);
1029    if (location != -1) {
1030      if (location == 1) {
1031        TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1032        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1033          return -1;
1034        }
1035      } else {
1036        THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1037        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1038          return -1;
1039        }
1040      }
1041    } else {
1042      return -1;
1043    }
1044    return 0;
1045  } 
1046  int TNEANet::DelFromFltVAttrDatN(const int&amp; NId, const TFlt&amp; value, const TStr&amp; attr) {
1047    TInt CurrLen;
1048    if (!IsNode(NId)) {
1049      return -1;
1050    }
1051    TInt location = CheckDenseOrSparseN(attr);
1052    if (location != -1) {
1053      if (location == 1) {
1054        TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1055        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1056          return -1;
1057        }
1058      } else {
1059        THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1060        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1061          return -1;
1062        }
1063      }
1064    } else {
1065      return -1;
1066    }
1067    return 0;
1068  }
1069  int TNEANet::AddStrAttrDatN(const int&amp; NId, const TStr&amp; value, const TStr&amp; attr) {
1070    int i;
1071    TInt CurrLen;
1072    if (!IsNode(NId)) {
1073      return -1;
1074    }
1075    if (KeyToIndexTypeN.IsKey(attr)) {
1076      TVec&lt;TStr&gt;&amp; NewVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1077      NewVec[NodeH.GetKeyId(NId)] = value;
1078    } else {
1079      CurrLen = VecOfStrVecsN.Len();
1080      KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1081      TVec&lt;TStr&gt; NewVec = TVec&lt;TStr&gt;();
1082      for (i = 0; i &lt; MxNId; i++) {
1083          NewVec.Ins(i, GetStrAttrDefaultN(attr));
1084      }
1085      NewVec[NodeH.GetKeyId(NId)] = value;
1086      VecOfStrVecsN.Add(NewVec);
1087    }
1088    return 0;
1089  } 
1090  int TNEANet::AddFltAttrDatN(const int&amp; NId, const TFlt&amp; value, const TStr&amp; attr) {
1091    int i;
1092    TInt CurrLen;
1093    if (!IsNode(NId)) {
1094      return -1;
1095    }
1096    if (KeyToIndexTypeN.IsKey(attr)) {
1097      TVec&lt;TFlt&gt;&amp; NewVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1098      NewVec[NodeH.GetKeyId(NId)] = value;
1099    } else {
1100      CurrLen = VecOfFltVecsN.Len();
1101      KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1102      TVec&lt;TFlt&gt; NewVec = TVec&lt;TFlt&gt;();
1103      for (i = 0; i &lt; MxNId; i++) {
1104        NewVec.Ins(i, GetFltAttrDefaultN(attr));
1105      }
1106      NewVec[NodeH.GetKeyId(NId)] = value;
1107      VecOfFltVecsN.Add(NewVec);
1108    }
1109    return 0;
1110  } 
1111  int TNEANet::AddIntAttrDatE(const int&amp; EId, const TInt&amp; value, const TStr&amp; attr) {
1112    int i;
1113    TInt CurrLen;
1114    if (!IsEdge(EId)) {
1115       return -1;
1116    }
1117    if (KeyToIndexTypeE.IsKey(attr)) {
1118      TVec&lt;TInt&gt;&amp; NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1119      NewVec[EdgeH.GetKeyId(EId)] = value;
1120    } else {
1121      CurrLen = VecOfIntVecsE.Len();
1122      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1123      TVec&lt;TInt&gt; NewVec = TVec&lt;TInt&gt;();
1124      for (i = 0; i &lt; MxEId; i++) {
1125        NewVec.Ins(i, GetIntAttrDefaultE(attr));
1126      }
1127      NewVec[EdgeH.GetKeyId(EId)] = value;
1128      VecOfIntVecsE.Add(NewVec);
1129    }
1130    return 0;
1131  }
1132  int TNEANet::AddIntVAttrDatE(const int&amp; EId, const TIntV&amp; value, const TStr&amp; attr, TBool UseDense) {
1133    if (!IsEdge(EId)) {
1134      return -1;
1135    }
1136    TInt location = CheckDenseOrSparseE(attr);
1137    if (location==-1) {
1138      AddIntVAttrE(attr, UseDense);
1139      location = CheckDenseOrSparseE(attr);
1140    }
1141    if (UseDense) {
1142      IAssertR(location != 0, TStr::Fmt(&quot;EdgeID %d exists for %s in sparse representation&quot;, EId, attr.CStr()));
1143      TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1144      NewVec[EdgeH.GetKeyId(EId)] = value;
1145    } else {
1146      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, EId, attr.CStr()));
1147      THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1148      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1149    }
1150    return 0;
1151  } 
1152  int TNEANet::AddFltVAttrDatE(const int&amp; EId, const TFltV&amp; value, const TStr&amp; attr, TBool UseDense) {
1153    if (!IsEdge(EId)) {
1154      return -1;
1155    }
1156    TInt location = CheckDenseOrSparseE(attr);
1157    if (location==-1) {
1158      AddFltVAttrE(attr, UseDense);
1159      location = CheckDenseOrSparseE(attr);
1160    }
1161    if (UseDense) {
1162      IAssertR(location != 0, TStr::Fmt(&quot;EdgeID %d exists for %s in sparse representation&quot;, EId, attr.CStr()));
1163      TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1164      NewVec[EdgeH.GetKeyId(EId)] = value;
1165    } else {
1166      IAssertR(location != 1, TStr::Fmt(&quot;NodeId %d exists for %s in dense representation&quot;, EId, attr.CStr()));
1167      THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1168      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1169    }
1170    return 0;
1171  } 
1172  int TNEANet::AppendIntVAttrDatE(const int&amp; EId, const TInt&amp; value, const TStr&amp; attr, TBool UseDense) {
1173    if (!IsEdge(EId)) {
1174      return -1;
1175    }
1176    TInt location = CheckDenseOrSparseE(attr);
1177    if (location==-1) return -1;
1178    if (UseDense) {
1179      IAssertR(location != 0, TStr::Fmt(&quot;Edge %d exists for %s in sparse representation&quot;, EId, attr.CStr()));
1180      TVec&lt;TIntV&gt;&amp; NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1181      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1182    } else {
1183      IAssertR(location != 1, TStr::Fmt(&quot;Edge %d exists for %s in dense representation&quot;, EId, attr.CStr()));
1184      THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1185      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1186    }
1187    return 0;
1188  }
1189  int TNEANet::AppendFltVAttrDatE(const int&amp; EId, const TFlt&amp; value, const TStr&amp; attr, TBool UseDense) {
1190    if (!IsEdge(EId)) {
1191      return -1;
1192    }
1193    TInt location = CheckDenseOrSparseE(attr);
1194    if (location==-1) return -1;
1195    if (UseDense) {
1196      IAssertR(location != 0, TStr::Fmt(&quot;Edge %d exists for %s in sparse representation&quot;, EId, attr.CStr()));
1197      TVec&lt;TFltV&gt;&amp; NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1198      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1199    } else {
1200      IAssertR(location != 1, TStr::Fmt(&quot;Edge %d exists for %s in dense representation&quot;, EId, attr.CStr()));
1201      THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1202      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1203    }
1204    return 0;
1205  }
1206  int TNEANet::AddStrAttrDatE(const int&amp; EId, const TStr&amp; value, const TStr&amp; attr) {
1207    int i;
1208    TInt CurrLen;
1209    if (!IsEdge(EId)) {
1210       return -1;
1211    }
1212    if (KeyToIndexTypeE.IsKey(attr)) {
1213      TVec&lt;TStr&gt;&amp; NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1214      NewVec[EdgeH.GetKeyId(EId)] = value;
1215    } else {
1216      CurrLen = VecOfStrVecsE.Len();
1217      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1218      TVec&lt;TStr&gt; NewVec = TVec&lt;TStr&gt;();
1219      for (i = 0; i &lt; MxEId; i++) {
1220        NewVec.Ins(i, GetStrAttrDefaultE(attr));
1221      }
1222      NewVec[EdgeH.GetKeyId(EId)] = value;
1223      VecOfStrVecsE.Add(NewVec);
1224    }
1225    return 0;
1226  } 
1227  int TNEANet::AddFltAttrDatE(const int&amp; EId, const TFlt&amp; value, const TStr&amp; attr) {
1228    int i;
1229    TInt CurrLen;
1230    if (!IsEdge(EId)) {
1231       return -1;
1232    }
1233    if (KeyToIndexTypeE.IsKey(attr)) {
1234      TVec&lt;TFlt&gt;&amp; NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1235      NewVec[EdgeH.GetKeyId(EId)] = value;
1236    } else {
1237      CurrLen = VecOfFltVecsE.Len();
1238      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1239      TVec&lt;TFlt&gt; NewVec = TVec&lt;TFlt&gt;();
1240      for (i = 0; i &lt; MxEId; i++) {
1241        NewVec.Ins(i, GetFltAttrDefaultE(attr));
1242      }
1243      NewVec[EdgeH.GetKeyId(EId)] = value;
1244      VecOfFltVecsE.Add(NewVec);
1245    }
1246    return 0;
1247  }
1248  TVec&lt;TFlt&gt;&amp; TNEANet::GetFltAttrVecE(const TStr&amp; attr) {
1249    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1250  }
1251  int TNEANet::GetFltKeyIdE(const int&amp; EId) {
1252    return EdgeH.GetKeyId(EId);
1253  }
1254  TInt TNEANet::GetIntAttrDatN(const int&amp; NId, const TStr&amp; attr) {
1255    return VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1256  }
1257  TIntV TNEANet::GetIntVAttrDatN(const int&amp; NId, const TStr&amp; attr) const {
1258    TInt location = CheckDenseOrSparseN(attr);
1259    if (location != 0) return VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1260    else return VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1261  }
1262  TFltV TNEANet::GetFltVAttrDatN(const int&amp; NId, const TStr&amp; attr) const {
1263    TInt location = CheckDenseOrSparseN(attr);
1264    if (location != 0) return VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1265    else return VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1266  }
1267  TStr TNEANet::GetStrAttrDatN(const int&amp; NId, const TStr&amp; attr) {
1268    return VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1269  }
1270  TFlt TNEANet::GetFltAttrDatN(const int&amp; NId, const TStr&amp; attr) {
1271    return VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1272  }
1273  TInt TNEANet::GetIntAttrIndDatN(const int&amp; NId, const int&amp; index) {
1274    return VecOfIntVecsN[index][NodeH.GetKeyId(NId)];
1275  }
1276  TStr TNEANet::GetStrAttrIndDatN(const int&amp; NId, const int&amp; index) {
1277    return VecOfStrVecsN[index][NodeH.GetKeyId(NId)];
1278  }
1279  TFlt TNEANet::GetFltAttrIndDatN(const int&amp; NId, const int&amp; index) {
1280    return VecOfFltVecsN[index][NodeH.GetKeyId(NId)];
1281  }
1282  int TNEANet::GetIntAttrIndN(const TStr&amp; attr) {
1283    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1284  }
1285  int TNEANet::GetAttrIndN(const TStr&amp; attr) {
1286    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1287  }
1288  TInt TNEANet::GetIntAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1289    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1290  }
1291  TIntV TNEANet::GetIntVAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1292    TInt location = CheckDenseOrSparseE(attr);
1293    if (location != 0) return VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1294    else return VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1295  }
1296  TFltV TNEANet::GetFltVAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1297    TInt location = CheckDenseOrSparseE(attr);
1298    if (location != 0) return VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1299    else return VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1300  }
1301  TStr TNEANet::GetStrAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1302    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1303  }
1304  TFlt TNEANet::GetFltAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1305    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1306  }
1307  TInt TNEANet::GetIntAttrIndDatE(const int&amp; EId, const int&amp; index) {
1308    return VecOfIntVecsE[index][EdgeH.GetKeyId(EId)];
1309  }
1310  TStr TNEANet::GetStrAttrIndDatE(const int&amp; EId, const int&amp; index) {
1311    return VecOfStrVecsE[index][EdgeH.GetKeyId(EId)];
1312  }
1313  TFlt TNEANet::GetFltAttrIndDatE(const int&amp; EId, const int&amp; index) {
1314    return VecOfFltVecsE[index][EdgeH.GetKeyId(EId)];
1315  }
1316  int TNEANet::GetIntAttrIndE(const TStr&amp; attr) {
1317    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1318  }
1319  int TNEANet::GetAttrIndE(const TStr&amp; attr) {
1320    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1321  }
1322  int TNEANet::DelAttrDatN(const int&amp; NId, const TStr&amp; attr) {
1323    TInt vecType = KeyToIndexTypeN(attr).Val1;
1324    if (vecType == IntType) {
1325      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
1326    } else if (vecType == StrType) {
1327      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
1328    } else if (vecType == FltType) {
1329      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
1330    } else if (vecType ==IntVType) {
1331      TInt location = CheckDenseOrSparseN(attr);
1332      if (location == 0) VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1333      else VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1334    } else if (vecType == FltVType) { 
1335      TInt location = CheckDenseOrSparseN(attr);
1336      if (location == 0) VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1337      else VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1338    } else {
1339      return -1;
1340    }
1341    return 0;
1342  }
1343  int TNEANet::DelAttrDatE(const int&amp; EId, const TStr&amp; attr) {
1344    TInt vecType = KeyToIndexTypeE(attr).Val1;
1345    if (vecType == IntType) {
1346      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
1347    } else if (vecType == StrType) {
1348      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
1349    } else if (vecType == FltType) {
1350      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
1351    } else if (vecType == IntVType) {
1352      TInt location = CheckDenseOrSparseE(attr);
1353      if (location == 0) VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1354      else VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1355    } else if (vecType == FltVType) {
1356      TInt location = CheckDenseOrSparseE(attr);
1357      if (location == 0) VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1358      else VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1359    } else {
1360      return -1;
1361    }
1362    return 0;
1363  }
1364  int TNEANet::AddIntAttrN(const TStr&amp; attr, TInt defaultValue){
1365    int i;
1366    TInt CurrLen;
1367    TVec&lt;TInt&gt; NewVec;
1368    CurrLen = VecOfIntVecsN.Len();
1369    KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
1370    NewVec = TVec&lt;TInt&gt;();
1371    for (i = 0; i &lt; MxNId; i++) {
1372      NewVec.Ins(i, defaultValue);
1373    }
1374    VecOfIntVecsN.Add(NewVec);
1375    if (!IntDefaultsN.IsKey(attr)) {
1376      IntDefaultsN.AddDat(attr, defaultValue);
1377    } else {
1378      return -1;
1379    }
1380    return 0;
1381  }
1382  int TNEANet::AddIntVAttrN(const TStr&amp; attr, TBool UseDense){
1383    TInt CurrLen;
1384    if (UseDense) {
1385      CurrLen = VecOfIntVecVecsN.Len();
1386      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1387      KeyToDenseN.AddDat(attr, true);
1388      TVec&lt;TIntV&gt; NewVec = TVec&lt;TIntV&gt;(MxNId);
1389      VecOfIntVecVecsN.Add(NewVec);
1390    } else {
1391      CurrLen = VecOfIntHashVecsN.Len();
1392      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1393      KeyToDenseN.AddDat(attr, false);
1394      THash&lt;TInt, TIntV&gt; NewHash;
1395      VecOfIntHashVecsN.Add(NewHash);
1396    }
1397    return 0;
1398  }
1399  int TNEANet::AddFltVAttrN(const TStr&amp; attr, TBool UseDense){
1400    TInt CurrLen;
1401    if (UseDense) {
1402      CurrLen = VecOfFltVecVecsN.Len();
1403      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1404      KeyToDenseN.AddDat(attr, true);
1405      TVec&lt;TFltV&gt; NewVec = TVec&lt;TFltV&gt;(MxNId);
1406      VecOfFltVecVecsN.Add(NewVec);
1407    } else {
1408      CurrLen = VecOfFltHashVecsN.Len();
1409      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1410      KeyToDenseN.AddDat(attr, false);
1411      THash&lt;TInt, TFltV&gt; NewHash;
1412      VecOfFltHashVecsN.Add(NewHash);
1413    }
1414    return 0;
1415  }
1416  int TNEANet::AddStrAttrN(const TStr&amp; attr, TStr defaultValue) {
1417    int i;
1418    TInt CurrLen;
1419    TVec&lt;TStr&gt; NewVec;
1420    CurrLen = VecOfStrVecsN.Len();
1421    KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1422    NewVec = TVec&lt;TStr&gt;();
1423    for (i = 0; i &lt; MxNId; i++) {
1424      NewVec.Ins(i, defaultValue);
1425    }
1426    VecOfStrVecsN.Add(NewVec);
1427    if (!StrDefaultsN.IsKey(attr)) {
1428      StrDefaultsN.AddDat(attr, defaultValue);
1429    } else {
1430      return -1;
1431    }
1432    return 0;
1433  }
1434  int TNEANet::AddFltAttrN(const TStr&amp; attr, TFlt defaultValue) {
1435    int i;
1436    TInt CurrLen;
1437    TVec&lt;TFlt&gt; NewVec;
1438    CurrLen = VecOfFltVecsN.Len();
1439    KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1440    NewVec = TVec&lt;TFlt&gt;();
1441    for (i = 0; i &lt; MxNId; i++) {
1442      NewVec.Ins(i, defaultValue);
1443    }
1444    VecOfFltVecsN.Add(NewVec);
1445    if (!FltDefaultsN.IsKey(attr)) {
1446      FltDefaultsN.AddDat(attr, defaultValue);
1447    } else {
1448      return -1;
1449    }
1450    return 0;
1451  }
1452  int TNEANet::AddIntAttrE(const TStr&amp; attr, TInt defaultValue){
1453    int i;
1454    TInt CurrLen;
1455    TVec&lt;TInt&gt; NewVec;
1456    CurrLen = VecOfIntVecsE.Len();
1457    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1458    NewVec = TVec&lt;TInt&gt;();
1459    for (i = 0; i &lt; MxEId; i++) {
1460      NewVec.Ins(i, defaultValue);
1461    }
1462    VecOfIntVecsE.Add(NewVec);
1463    if (!IntDefaultsE.IsKey(attr)) {
1464      IntDefaultsE.AddDat(attr, defaultValue);
1465    } else {
1466      return -1;
1467    }
1468    return 0;
1469  }
1470  int TNEANet::AddIntVAttrE(const TStr&amp; attr, TBool UseDense){
1471    TInt CurrLen;
1472    if (UseDense) {
1473      CurrLen = VecOfIntVecVecsE.Len();
1474      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1475      KeyToDenseE.AddDat(attr, true);
1476      TVec&lt;TIntV&gt; NewVec = TVec&lt;TIntV&gt;(MxEId);
1477      VecOfIntVecVecsE.Add(NewVec);
1478    } else {
1479      CurrLen = VecOfIntHashVecsE.Len();
1480      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1481      KeyToDenseE.AddDat(attr, false);
1482      THash&lt;TInt, TIntV&gt; NewHash;
1483      VecOfIntHashVecsE.Add(NewHash);
1484    }
1485    return 0;
1486  }
1487  int TNEANet::AddFltVAttrE(const TStr&amp; attr, TBool UseDense){
1488    TInt CurrLen;
1489    if (UseDense) {
1490      CurrLen = VecOfFltVecVecsE.Len();
1491      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1492      KeyToDenseE.AddDat(attr, true);
1493      TVec&lt;TFltV&gt; NewVec = TVec&lt;TFltV&gt;(MxEId);
1494      VecOfFltVecVecsE.Add(NewVec);
1495    } else {
1496      CurrLen = VecOfFltHashVecsE.Len();
1497      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1498      KeyToDenseE.AddDat(attr, false);
1499      THash&lt;TInt, TFltV&gt; NewHash;
1500      VecOfFltHashVecsE.Add(NewHash);
1501    }
1502    return 0;
1503  }
1504  int TNEANet::AddStrAttrE(const TStr&amp; attr, TStr defaultValue) {
1505    int i;
1506    TInt CurrLen;
1507    TVec&lt;TStr&gt; NewVec;
1508    CurrLen = VecOfStrVecsE.Len();
1509    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1510    NewVec = TVec&lt;TStr&gt;();
1511    for (i = 0; i &lt; MxEId; i++) {
1512      NewVec.Ins(i, defaultValue);
1513    }
1514    VecOfStrVecsE.Add(NewVec);
1515    if (!StrDefaultsE.IsKey(attr)) {
1516      StrDefaultsE.AddDat(attr, defaultValue);
1517    } else {
1518      return -1;
1519    }
1520    return 0;
1521  }
1522  int TNEANet::AddFltAttrE(const TStr&amp; attr, TFlt defaultValue) {
1523    int i;
1524    TInt CurrLen;
1525    TVec&lt;TFlt&gt; NewVec;
1526    CurrLen = VecOfFltVecsE.Len();
1527    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1528    NewVec = TVec&lt;TFlt&gt;();
1529    for (i = 0; i &lt; MxEId; i++) {
1530      NewVec.Ins(i, defaultValue);
1531    }
1532    VecOfFltVecsE.Add(NewVec);
1533    if (!FltDefaultsE.IsKey(attr)) {
1534      FltDefaultsE.AddDat(attr, defaultValue);
1535    } else {
1536      return -1;
1537    }
1538    return 0;
1539  }
1540  int TNEANet::DelAttrN(const TStr&amp; attr) {
1541    TInt vecType = KeyToIndexTypeN(attr).Val1;
1542    if (vecType == IntType) {
1543      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TInt&gt;();
1544      if (IntDefaultsN.IsKey(attr)) {
1545        IntDefaultsN.DelKey(attr);
1546      }
1547    } else if (vecType == StrType) {
1548      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TStr&gt;();  
1549      if (StrDefaultsN.IsKey(attr)) {
1550        StrDefaultsN.DelKey(attr);
1551      }
1552    } else if (vecType == FltType) {
1553      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TFlt&gt;();
1554      if (FltDefaultsN.IsKey(attr)) {
1555        FltDefaultsN.DelKey(attr);
1556      }
1557    } else if (vecType == IntVType) {
1558      TInt location = CheckDenseOrSparseN(attr);
1559      if (location == 1) VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TIntV&gt;();
1560      else VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash&lt;TInt, TIntV&gt;();
1561      KeyToDenseN.DelKey(attr);
1562    } else if (vecType == FltVType) {
1563      TInt location = CheckDenseOrSparseN(attr);
1564      if (location == 1) VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec&lt;TFltV&gt;();
1565      else VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash&lt;TInt, TFltV&gt;();
1566      KeyToDenseN.DelKey(attr);
1567    } else {
1568      return -1;
1569    }
1570    KeyToIndexTypeN.DelKey(attr);
1571    return 0;
1572  }
1573  int TNEANet::DelAttrE(const TStr&amp; attr) {
1574    TInt vecType = KeyToIndexTypeE(attr).Val1;
1575    if (vecType == IntType) {
1576      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec&lt;TInt&gt;();
1577      if (IntDefaultsE.IsKey(attr)) {
1578        IntDefaultsE.DelKey(attr);
1579      }
1580    } else if (vecType == StrType) {
1581      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec&lt;TStr&gt;();
1582      if (StrDefaultsE.IsKey(attr)) {
1583        StrDefaultsE.DelKey(attr);
1584      }  
1585    } else if (vecType == FltType) {
1586      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec&lt;TFlt&gt;();
1587      if (FltDefaultsE.IsKey(attr)) {
1588        FltDefaultsE.DelKey(attr);
1589      }
1590    } else {
1591      return -1;
1592    }
1593    KeyToIndexTypeE.DelKey(attr);
1594    return 0;
1595  }
1596  PNEANet TNEANet::GetSmallGraph() {
1597    PNEANet Net = TNEANet::New();
1598    for (int i = 0; i &lt; 5; i++) { Net-&gt;AddNode(i); }
1599    Net-&gt;AddEdge(0,1);  Net-&gt;AddEdge(0,2);
1600    Net-&gt;AddEdge(0,3);  Net-&gt;AddEdge(0,4);
1601    Net-&gt;AddEdge(1,2);  Net-&gt;AddEdge(1,2);
1602    return Net;
1603  }
1604  void TNEANet::GetAttrNNames(TStrV&amp; IntAttrNames, TStrV&amp; FltAttrNames, TStrV&amp; StrAttrNames) const {
1605    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it &lt; KeyToIndexTypeN.EndI(); it++) {
1606      if (it.GetDat().GetVal1() == IntType) {
1607        IntAttrNames.Add(it.GetKey());
1608      }
1609      if (it.GetDat().GetVal1() == FltType) {
1610        FltAttrNames.Add(it.GetKey());
1611      }
1612      if (it.GetDat().GetVal1() == StrType) {
1613        StrAttrNames.Add(it.GetKey());
1614      }
1615    }
1616  }
1617  void TNEANet::GetAttrENames(TStrV&amp; IntAttrNames, TStrV&amp; FltAttrNames, TStrV&amp; StrAttrNames) const {
1618    for (TStrIntPrH::TIter it = KeyToIndexTypeE.BegI(); it &lt; KeyToIndexTypeE.EndI(); it++) {
1619      if (it.GetDat().GetVal1() == IntType) {
1620        IntAttrNames.Add(it.GetKey());
1621      }
1622      if (it.GetDat().GetVal1() == FltType) {
1623        FltAttrNames.Add(it.GetKey());
1624      }
1625      if (it.GetDat().GetVal1() == StrType) {
1626        StrAttrNames.Add(it.GetKey());
1627      }
1628    }
1629  }
1630  TFlt TNEANet::GetWeightOutEdges(const TNodeI&amp; NI, const TStr&amp; attr) {
1631    TNode Node = GetNode(NI.GetId());
1632    TIntV OutEIdV = Node.OutEIdV;
1633    TFlt total = 0;
1634    int len = Node.OutEIdV.Len();
1635    for (int i = 0; i &lt; len; i++) {
1636      total += GetFltAttrDatE(Node.OutEIdV[i], attr);
1637    }
1638    return total;
1639  }
1640  void TNEANet::GetWeightOutEdgesV(TFltV&amp; OutWeights, const TFltV&amp; AttrVal) {
1641    for (TEdgeI it = BegEI(); it &lt; EndEI(); it++) {
1642      int EId = it.GetId();
1643      int SrcId = it.GetSrcNId();
1644      OutWeights[SrcId] +=AttrVal[GetFltKeyIdE(EId)];
1645    }
1646  }
1647  bool TNEANet::IsFltAttrE(const TStr&amp; attr) {
1648    return (KeyToIndexTypeE.IsKey(attr) &amp;&amp;
1649      KeyToIndexTypeE.GetDat(attr).Val1 == FltType);
1650  }
1651  bool TNEANet::IsIntAttrE(const TStr&amp; attr) {
1652    return (KeyToIndexTypeE.IsKey(attr) &amp;&amp;
1653      KeyToIndexTypeE.GetDat(attr).Val1 == IntType);
1654  }
1655  bool TNEANet::IsStrAttrE(const TStr&amp; attr) {
1656    return (KeyToIndexTypeE.IsKey(attr) &amp;&amp;
1657      KeyToIndexTypeE.GetDat(attr).Val1 == StrType);
1658  }
1659  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TInt&amp; Val) {
1660    if (!IsNode(NId)) {
1661      return -1;
1662    }
1663    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1664  }
1665  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TInt&amp; Val) {
1666    if (!IsNode(NId)) {
1667      return -1;
1668    }
1669    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1670  }
1671  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TFlt&amp; Val) {
1672    if (!IsNode(NId)) {
1673      return -1;
1674    }
1675    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1676  }
1677  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TFlt&amp; Val) {
1678    if (!IsNode(NId)) {
1679      return -1;
1680    }
1681    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1682  }
1683  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TStr&amp; Val) {
1684    if (!IsNode(NId)) {
1685      return -1;
1686    }
1687    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1688  }
1689  int TNEANet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TStr&amp; Val) {
1690    if (!IsNode(NId)) {
1691      return -1;
1692    }
1693    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1694  }
1695  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TInt&amp; Val) const {
1696    if (!IsNode(NId)) {
1697      return -1;
1698    }
1699    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1700  }
1701  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TInt&amp; Val) const {
1702    if (!IsNode(NId)) {
1703      return -1;
1704    }
1705    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1706  }
1707  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TFlt&amp; Val) const {
1708    if (!IsNode(NId)) {
1709      return -1;
1710    }
1711    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1712  }
1713  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TFlt&amp; Val) const {
1714    if (!IsNode(NId)) {
1715      return -1;
1716    }
1717    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1718  }
1719  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TStr&amp; Val) const {
1720    if (!IsNode(NId)) {
1721      return -1;
1722    }
1723    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1724  }
1725  int TNEANet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TStr&amp; Val) const {
1726    if (!IsNode(NId)) {
1727      return -1;
1728    }
1729    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1730  }
1731  int TNEANet::DelSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName) {
1732    if (!IsNode(NId)) {
1733      return -1;
1734    }
1735    return SAttrN.DelSAttrDat(NId, AttrName);
1736  }
1737  int TNEANet::DelSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId) {
1738    if (!IsNode(NId)) {
1739      return -1;
1740    }
1741    return SAttrN.DelSAttrDat(NId, AttrId);
1742  }
1743  int TNEANet::GetSAttrVN(const TInt&amp; NId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
1744    if (!IsNode(NId)) {
1745      return -1;
1746    }
1747    SAttrN.GetSAttrV(NId, AttrType, AttrV);
1748    return 0;
1749  }
1750  int TNEANet::GetIdVSAttrN(const TStr&amp; AttrName, TIntV&amp; IdV) const {
1751    return SAttrN.GetIdVSAttr(AttrName, IdV);
1752  }
1753  int TNEANet::GetIdVSAttrN(const TInt&amp; AttrId, TIntV&amp; IdV) const {
1754    return SAttrN.GetIdVSAttr(AttrId, IdV);
1755  }
1756  int TNEANet::AddSAttrN(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
1757    return SAttrN.AddSAttr(Name, AttrType, AttrId);
1758  }
1759  int TNEANet::GetSAttrIdN(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
1760    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
1761  }
1762  int TNEANet::GetSAttrNameN(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
1763    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
1764  }
1765  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, const TInt&amp; Val) {
1766    if (!IsEdge(EId)) {
1767      return -1;
1768    }
1769    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1770  }
1771  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, const TInt&amp; Val) {
1772    if (!IsEdge(EId)) {
1773      return -1;
1774    }
1775    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1776  }
1777  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, const TFlt&amp; Val) {
1778    if (!IsEdge(EId)) {
1779      return -1;
1780    }
1781    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1782  }
1783  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, const TFlt&amp; Val) {
1784    if (!IsEdge(EId)) {
1785      return -1;
1786    }
1787    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1788  }
1789  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, const TStr&amp; Val) {
1790    if (!IsEdge(EId)) {
1791      return -1;
1792    }
1793    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1794  }
1795  int TNEANet::AddSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, const TStr&amp; Val) {
1796    if (!IsEdge(EId)) {
1797      return -1;
1798    }
1799    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1800  }
1801  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, TInt&amp; Val) const {
1802    if (!IsEdge(EId)) {
1803      return -1;
1804    }
1805    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1806  }
1807  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, TInt&amp; Val) const {
1808    if (!IsEdge(EId)) {
1809      return -1;
1810    }
1811    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1812  }
1813  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, TFlt&amp; Val) const {
1814    if (!IsEdge(EId)) {
1815      return -1;
1816    }
1817    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1818  }
1819  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, TFlt&amp; Val) const {
1820    if (!IsEdge(EId)) {
1821      return -1;
1822    }
1823    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1824  }
1825  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName, TStr&amp; Val) const {
1826    if (!IsEdge(EId)) {
1827      return -1;
1828    }
1829    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1830  }
1831  int TNEANet::GetSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId, TStr&amp; Val) const {
1832    if (!IsEdge(EId)) {
1833      return -1;
1834    }
1835    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1836  }
1837  int TNEANet::DelSAttrDatE(const TInt&amp; EId, const TStr&amp; AttrName) {
1838    if (!IsEdge(EId)) {
1839      return -1;
1840    }
1841    return SAttrE.DelSAttrDat(EId, AttrName);
1842  }
1843  int TNEANet::DelSAttrDatE(const TInt&amp; EId, const TInt&amp; AttrId) {
1844    if (!IsEdge(EId)) {
1845      return -1;
1846    }
1847    return SAttrE.DelSAttrDat(EId, AttrId);
1848  }
1849  int TNEANet::GetSAttrVE(const TInt&amp; EId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
1850    if (!IsEdge(EId)) {
1851      return -1;
1852    }
1853    SAttrE.GetSAttrV(EId, AttrType, AttrV);
1854    return 0;
1855  }
1856  int TNEANet::GetIdVSAttrE(const TStr&amp; AttrName, TIntV&amp; IdV) const {
1857    return SAttrE.GetIdVSAttr(AttrName, IdV);
1858  }
1859  int TNEANet::GetIdVSAttrE(const TInt&amp; AttrId, TIntV&amp; IdV) const {
1860    return SAttrE.GetIdVSAttr(AttrId, IdV);
1861  }
1862  int TNEANet::AddSAttrE(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
1863    return SAttrE.AddSAttr(Name, AttrType, AttrId);
1864  }
1865  int TNEANet::GetSAttrIdE(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
1866    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
1867  }
1868  int TNEANet::GetSAttrNameE(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
1869    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
1870  }
1871  bool TUndirNet::HasFlag(const TGraphFlag&amp; Flag) const {
1872    return HasGraphFlag(TUndirNet::TNet, Flag);
1873  }
1874  int TUndirNet::AddNode(int NId) {
1875    if (NId == -1) {
1876      NId = MxNId;  MxNId++;
1877    } else {
1878      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
1879      MxNId = TMath::Mx(NId+1, MxNId());
1880    }
1881    NodeH.AddDat(NId, TNode(NId));
1882    return NId;
1883  }
1884  int TUndirNet::AddNodeUnchecked(int NId) {
1885    if (NId == -1) {
1886      NId = MxNId;  MxNId++;
1887    } else {
1888      if (IsNode(NId)) { return -1;}
1889      MxNId = TMath::Mx(NId+1, MxNId());
1890    }
1891    NodeH.AddDat(NId, TNode(NId));
1892    return NId;
1893  }
1894  int TUndirNet::AddNode(const int&amp; NId, const TIntV&amp; NbrNIdV) {
1895    int NewNId;
1896    if (NId == -1) {
1897      NewNId = MxNId;  MxNId++;
1898    } else {
1899      IAssertR(! IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
1900      NewNId = NId;
1901      MxNId = TMath::Mx(NewNId+1, MxNId());
1902    }
1903    TNode&amp; Node = NodeH.AddDat(NewNId);
1904    Node.Id = NewNId;
1905    Node.NIdV = NbrNIdV;
1906    Node.NIdV.Sort();
1907    NEdges += Node.GetDeg();
1908    for (int i = 0; i &lt; NbrNIdV.Len(); i++) {
1909      GetNode(NbrNIdV[i]).NIdV.AddSorted(NewNId);
1910    }
1911    return NewNId;
1912  }
1913  int TUndirNet::AddNode(const int&amp; NId, const TVecPool&lt;TInt&gt;&amp; Pool, const int&amp; NIdVId) {
1914    int NewNId;
1915    if (NId == -1) {
1916      NewNId = MxNId;  MxNId++;
1917    } else {
1918      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
1919      NewNId = NId;
1920      MxNId = TMath::Mx(NewNId+1, MxNId()); 
1921    }
1922    TNode&amp; Node = NodeH.AddDat(NewNId);
1923    Node.Id = NewNId;
1924    Node.NIdV.GenExt(Pool.GetValVPt(NIdVId), Pool.GetVLen(NIdVId));
1925    Node.NIdV.Sort();
1926    NEdges += Node.GetDeg();
1927    return NewNId;
1928  }
1929  void TUndirNet::DelNode(const int&amp; NId) {
1930    { AssertR(IsNode(NId), TStr::Fmt(&quot;NodeId %d does not exist&quot;, NId));
1931    TInt Id(NId);
1932    SAttrN.DelSAttrId(Id);
1933    TNode&amp; Node = GetNode(NId);
1934    NEdges -= Node.GetDeg();
1935    for (int e = 0; e &lt; Node.GetDeg(); e++) {
1936      const int nbr = Node.GetNbrNId(e);
1937      if (nbr == NId) { continue; }
1938      TNode&amp; N = GetNode(nbr);
1939      const int n = N.NIdV.SearchBin(NId);
1940      IAssert(n != -1); 
1941      if (n!= -1) { N.NIdV.Del(n); }
1942    } }
1943    NodeH.DelKey(NId);
1944  }
1945  int TUndirNet::GetEdges() const {
1946    return NEdges;
1947  }
1948  int TUndirNet::AddEdge(const int&amp; SrcNId, const int&amp; DstNId) {
1949    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
1950    if (IsEdge(SrcNId, DstNId)) { return -2; } 
1951    GetNode(SrcNId).NIdV.AddSorted(DstNId);
1952    if (SrcNId!=DstNId) { 
1953      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
1954    NEdges++;
1955    return -1; 
1956  }
1957  int TUndirNet::AddEdgeUnchecked(const int&amp; SrcNId, const int&amp; DstNId) {
1958    GetNode(SrcNId).NIdV.Add(DstNId);
1959    if (SrcNId!=DstNId) { 
1960      GetNode(DstNId).NIdV.Add(SrcNId); }
1961    NEdges++;
1962    return -1; 
1963  }
1964  void TUndirNet::DelEdge(const int&amp; SrcNId, const int&amp; DstNId) {
1965    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
1966    { TNode&amp; N = GetNode(SrcNId);
1967    const int n = N.NIdV.SearchBin(DstNId);
1968    TIntPr Id(SrcNId, DstNId);
1969    SAttrE.DelSAttrId(Id);
1970    if (n!= -1) { N.NIdV.Del(n);  NEdges--; } }
1971    if (SrcNId != DstNId) { 
1972      TNode&amp; N = GetNode(DstNId);
1973      const int n = N.NIdV.SearchBin(SrcNId);
1974      if (n!= -1) { N.NIdV.Del(n); }
1975    }
1976  }
1977  bool TUndirNet::IsEdge(const int&amp; SrcNId, const int&amp; DstNId) const {
1978    if (! IsNode(SrcNId) || ! IsNode(DstNId)) return false;
1979    return GetNode(SrcNId).IsNbrNId(DstNId);
1980  }
1981  TUndirNet::TEdgeI TUndirNet::GetEI(const int&amp; SrcNId, const int&amp; DstNId) const {
1982    const int MnNId = TMath::Mn(SrcNId, DstNId);
1983    const int MxNId = TMath::Mx(SrcNId, DstNId);
1984    const TNodeI SrcNI = GetNI(MnNId);
1985    const int NodeN = SrcNI.NodeHI.GetDat().NIdV.SearchBin(MxNId);
1986    IAssert(NodeN != -1);
1987    return TEdgeI(SrcNI, EndNI(), NodeN);
1988  }
1989  void TUndirNet::GetNIdV(TIntV&amp; NIdV) const {
1990    NIdV.Gen(GetNodes(), 0);
1991    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
1992      NIdV.Add(NodeH.GetKey(N)); }
1993  }
1994  void TUndirNet::Defrag(const bool&amp; OnlyNodeLinks) {
1995    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
1996      NodeH[n].NIdV.Pack();
1997    }
1998    if (! OnlyNodeLinks &amp;&amp; ! NodeH.IsKeyIdEqKeyN()) {
1999      NodeH.Defrag();
2000    }
2001  }
2002  bool TUndirNet::IsOk(const bool&amp; ThrowExcept) const {
2003    bool RetVal = true;
2004    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2005      const TNode&amp; Node = NodeH[N];
2006      if (! Node.NIdV.IsSorted()) {
2007        const TStr Msg = TStr::Fmt(&quot;Neighbor list of node %d is not sorted.&quot;, Node.GetId());
2008        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2009        RetVal=false;
2010      }
2011      int prevNId = -1;
2012      for (int e = 0; e &lt; Node.GetDeg(); e++) {
2013        if (! IsNode(Node.GetNbrNId(e))) {
2014          const TStr Msg = TStr::Fmt(&quot;Edge %d --&gt; %d: node %d does not exist.&quot;,
2015            Node.GetId(), Node.GetNbrNId(e), Node.GetNbrNId(e));
2016          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2017          RetVal=false;
2018        }
2019        if (e &gt; 0 &amp;&amp; prevNId == Node.GetNbrNId(e)) {
2020          const TStr Msg = TStr::Fmt(&quot;Node %d has duplicate edge %d --&gt; %d.&quot;,
2021            Node.GetId(), Node.GetId(), Node.GetNbrNId(e));
2022          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2023          RetVal=false;
2024        }
2025        prevNId = Node.GetNbrNId(e);
2026      }
2027    }
2028    int EdgeCnt = 0;
2029    for (TEdgeI EI = BegEI(); EI &lt; EndEI(); EI++) { EdgeCnt++; }
2030    if (EdgeCnt != GetEdges()) {
2031      const TStr Msg = TStr::Fmt(&quot;Number of edges counter is corrupted: GetEdges():%d, EdgeCount:%d.&quot;, GetEdges(), EdgeCnt);
2032      if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2033      RetVal=false;
2034    }
2035    return RetVal;
2036  }
2037  void TUndirNet::Dump(FILE *OutF) const {
2038    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2039    fprintf(OutF, &quot;-------------------------------------------------\nUndirected Node Graph: nodes: %d, edges: %d\n&quot;, GetNodes(), GetEdges());
2040    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2041      const TNode&amp; Node = NodeH[N];
2042      fprintf(OutF, &quot;  %*d [%d] &quot;, NodePlaces, Node.GetId(), Node.GetDeg());
2043      for (int edge = 0; edge &lt; Node.GetDeg(); edge++) {
2044        fprintf(OutF, &quot; %*d&quot;, NodePlaces, Node.GetNbrNId(edge)); }
2045      fprintf(OutF, &quot;\n&quot;);
2046    }
2047    fprintf(OutF, &quot;\n&quot;);
2048  }
2049  PUndirNet TUndirNet::GetSmallGraph() {
2050    PUndirNet Graph = TUndirNet::New();
2051    for (int i = 0; i &lt; 5; i++) { Graph-&gt;AddNode(i); }
2052    Graph-&gt;AddEdge(0,1);  Graph-&gt;AddEdge(0,2);
2053    Graph-&gt;AddEdge(0,3);  Graph-&gt;AddEdge(0,4);
2054    Graph-&gt;AddEdge(1,2);
2055    return Graph;
2056  }
2057  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TInt&amp; Val) {
2058    if (!IsNode(NId)) {
2059      return -1;
2060    }
2061    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2062  }
2063  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TInt&amp; Val) {
2064    if (!IsNode(NId)) {
2065      return -1;
2066    }
2067    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2068  }
2069  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TFlt&amp; Val) {
2070    if (!IsNode(NId)) {
2071      return -1;
2072    }
2073    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2074  }
2075  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TFlt&amp; Val) {
2076    if (!IsNode(NId)) {
2077      return -1;
2078    }
2079    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2080  }
2081  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TStr&amp; Val) {
2082    if (!IsNode(NId)) {
2083      return -1;
2084    }
2085    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2086  }
2087  int TUndirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TStr&amp; Val) {
2088    if (!IsNode(NId)) {
2089      return -1;
2090    }
2091    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2092  }
2093  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TInt&amp; Val) const {
2094    if (!IsNode(NId)) {
2095      return -1;
2096    }
2097    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2098  }
2099  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TInt&amp; Val) const {
2100    if (!IsNode(NId)) {
2101      return -1;
2102    }
2103    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2104  }
2105  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TFlt&amp; Val) const {
2106    if (!IsNode(NId)) {
2107      return -1;
2108    }
2109    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2110  }
2111  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TFlt&amp; Val) const {
2112    if (!IsNode(NId)) {
2113      return -1;
2114    }
2115    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2116  }
2117  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TStr&amp; Val) const {
2118    if (!IsNode(NId)) {
2119      return -1;
2120    }
2121    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2122  }
2123  int TUndirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TStr&amp; Val) const {
2124    if (!IsNode(NId)) {
2125      return -1;
2126    }
2127    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2128  }
2129  int TUndirNet::DelSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName) {
2130    if (!IsNode(NId)) {
2131      return -1;
2132    }
2133    return SAttrN.DelSAttrDat(NId, AttrName);
2134  }
2135  int TUndirNet::DelSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId) {
2136    if (!IsNode(NId)) {
2137      return -1;
2138    }
2139    return SAttrN.DelSAttrDat(NId, AttrId);
2140  }
2141  int TUndirNet::GetSAttrVN(const TInt&amp; NId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
2142    if (!IsNode(NId)) {
2143      return -1;
2144    }
2145    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2146    return 0;
2147  }
2148  int TUndirNet::GetIdVSAttrN(const TStr&amp; AttrName, TIntV&amp; IdV) const {
2149    return SAttrN.GetIdVSAttr(AttrName, IdV);
2150  }
2151  int TUndirNet::GetIdVSAttrN(const TInt&amp; AttrId, TIntV&amp; IdV) const {
2152    return SAttrN.GetIdVSAttr(AttrId, IdV);
2153  }
2154  int TUndirNet::AddSAttrN(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
2155    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2156  }
2157  int TUndirNet::GetSAttrIdN(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
2158    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2159  }
2160  int TUndirNet::GetSAttrNameN(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
2161    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2162  }
2163  TIntPr TUndirNet::OrderEdgeNodes(const int&amp; SrcNId, const int&amp; DstNId) const{
2164    if (SrcNId &lt; DstNId) {
2165      return TIntPr(SrcNId, DstNId);
2166    }
2167    return TIntPr(DstNId, SrcNId);
2168  }
2169  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TInt&amp; Val) {
2170    if (!IsEdge(SrcNId, DstNId)) {
2171      return -1;
2172    }
2173    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2174    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2175  }
2176  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TInt&amp; Val) {
2177    if (!IsEdge(SrcNId, DstNId)) {
2178      return -1;
2179    }
2180    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2181    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2182  }
2183  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TFlt&amp; Val) {
2184    if (!IsEdge(SrcNId, DstNId)) {
2185      return -1;
2186    }
2187    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2188    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2189  }
2190  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TFlt&amp; Val) {
2191    if (!IsEdge(SrcNId, DstNId)) {
2192      return -1;
2193    }
2194    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2195    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2196  }
2197  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TStr&amp; Val) {
2198    if (!IsEdge(SrcNId, DstNId)) {
2199      return -1;
2200    }
2201    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2202    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2203  }
2204  int TUndirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TStr&amp; Val) {
2205    if (!IsEdge(SrcNId, DstNId)) {
2206      return -1;
2207    }
2208    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2209    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2210  }
2211  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TInt&amp; Val) const {
2212    if (!IsEdge(SrcNId, DstNId)) {
2213      return -1;
2214    }
2215    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2216    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2217  }
2218  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TInt&amp; Val) const {
2219    if (!IsEdge(SrcNId, DstNId)) {
2220      return -1;
2221    }
2222    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2223    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2224  }
2225  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TFlt&amp; Val) const {
2226    if (!IsEdge(SrcNId, DstNId)) {
2227      return -1;
2228    }
2229    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2230    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2231  }
2232  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TFlt&amp; Val) const {
2233    if (!IsEdge(SrcNId, DstNId)) {
2234      return -1;
2235    }
2236    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2237    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2238  }
2239  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TStr&amp; Val) const {
2240    if (!IsEdge(SrcNId, DstNId)) {
2241      return -1;
2242    }
2243    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2244    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2245  }
2246  int TUndirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TStr&amp; Val) const {
2247    if (!IsEdge(SrcNId, DstNId)) {
2248      return -1;
2249    }
2250    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2251    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2252  }
2253  int TUndirNet::DelSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName) {
2254    if (!IsEdge(SrcNId, DstNId)) {
2255      return -1;
2256    }
2257    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2258    return SAttrE.DelSAttrDat(EId, AttrName);
2259  }
2260  int TUndirNet::DelSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId) {
2261    if (!IsEdge(SrcNId, DstNId)) {
2262      return -1;
2263    }
2264    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2265    return SAttrE.DelSAttrDat(EId, AttrId);
2266  }
2267  int TUndirNet::GetSAttrVE(const int&amp; SrcNId, const int&amp; DstNId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
2268    if (!IsEdge(SrcNId, DstNId)) {
2269      return -1;
2270    }
2271    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2272    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2273    return 0;
2274  }
2275  int TUndirNet::GetIdVSAttrE(const TStr&amp; AttrName, TIntPrV&amp; IdV) const {
2276    return SAttrE.GetIdVSAttr(AttrName, IdV);
2277  }
2278  int TUndirNet::GetIdVSAttrE(const TInt&amp; AttrId, TIntPrV&amp; IdV) const {
2279    return SAttrE.GetIdVSAttr(AttrId, IdV);
2280  }
2281  int TUndirNet::AddSAttrE(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
2282    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2283  }
2284  int TUndirNet::GetSAttrIdE(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
2285    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2286  }
2287  int TUndirNet::GetSAttrNameE(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
2288    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2289  }
2290  bool TDirNet::HasFlag(const TGraphFlag&amp; Flag) const {
2291    return HasGraphFlag(TDirNet::TNet, Flag);
2292  }
2293  int TDirNet::AddNode(int NId) {
2294    if (NId == -1) {
2295      NId = MxNId;  MxNId++;
2296    } else {
2297      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
2298      MxNId = TMath::Mx(NId+1, MxNId());
2299    }
2300    NodeH.AddDat(NId, TNode(NId));
2301    return NId;
2302  }
2303  int TDirNet::AddNodeUnchecked(int NId) {
2304    if (NId == -1) {
2305      NId = MxNId;  MxNId++;
2306    } else {
2307      if (IsNode(NId)) { return -1;}
2308      MxNId = TMath::Mx(NId+1, MxNId());
2309    }
2310    NodeH.AddDat(NId, TNode(NId));
2311    return NId;
2312  }
2313  int TDirNet::AddNode(const int&amp; NId, const TIntV&amp; InNIdV, const TIntV&amp; OutNIdV) {
2314    int NewNId;
2315    if (NId == -1) {
2316      NewNId = MxNId;  MxNId++;
2317    } else {
2318      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
2319      NewNId = NId;
2320      MxNId = TMath::Mx(NewNId+1, MxNId());
2321    }
2322    TNode&amp; Node = NodeH.AddDat(NewNId);
2323    Node.Id = NewNId;
2324    Node.InNIdV = InNIdV;
2325    Node.OutNIdV = OutNIdV;
2326    Node.InNIdV.Sort();
2327    Node.OutNIdV.Sort();
2328    return NewNId;
2329  }
2330  int TDirNet::AddNode(const int&amp; NId, const TVecPool&lt;TInt&gt;&amp; Pool, const int&amp; SrcVId, const int&amp; DstVId) {
2331    int NewNId;
2332    if (NId == -1) {
2333      NewNId = MxNId;  MxNId++;
2334    } else {
2335      IAssertR(!IsNode(NId), TStr::Fmt(&quot;NodeId %d already exists&quot;, NId));
2336      NewNId = NId;
2337      MxNId = TMath::Mx(NewNId+1, MxNId());
2338    }
2339    TNode&amp; Node = NodeH.AddDat(NewNId);
2340    Node.Id = NewNId;
2341    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
2342    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
2343    Node.InNIdV.Sort();
2344    Node.OutNIdV.Sort();
2345    return NewNId;
2346  }
2347  void TDirNet::DelNode(const int&amp; NId) {
2348    { TNode&amp; Node = GetNode(NId);
2349    TInt Id(NId);
2350    SAttrN.DelSAttrId(Id);
2351    for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
2352    const int nbr = Node.GetOutNId(e);
2353    if (nbr == NId) { continue; }
2354      TNode&amp; N = GetNode(nbr);
2355      const int n = N.InNIdV.SearchBin(NId);
2356      if (n!= -1) { N.InNIdV.Del(n); }
2357    }
2358    for (int e = 0; e &lt; Node.GetInDeg(); e++) {
2359    const int nbr = Node.GetInNId(e);
2360    if (nbr == NId) { continue; }
2361      TNode&amp; N = GetNode(nbr);
2362      const int n = N.OutNIdV.SearchBin(NId);
2363      if (n!= -1) { N.OutNIdV.Del(n); }
2364    } }
2365    NodeH.DelKey(NId);
2366  }
2367  int TDirNet::GetEdges() const {
2368    int edges=0;
2369    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2370      edges+=NodeH[N].GetOutDeg();
2371    }
2372    return edges;
2373  }
2374  int TDirNet::AddEdge(const int&amp; SrcNId, const int&amp; DstNId) {
2375    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
2376    if (IsEdge(SrcNId, DstNId)) { return -2; }
2377    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
2378    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
2379    return -1; 
2380  }
2381  int TDirNet::AddEdgeUnchecked(const int&amp; SrcNId, const int&amp; DstNId) {
2382    GetNode(SrcNId).OutNIdV.Add(DstNId);
2383    GetNode(DstNId).InNIdV.Add(SrcNId);
2384    return -1; 
2385  }
2386  void TDirNet::DelEdge(const int&amp; SrcNId, const int&amp; DstNId, const bool&amp; IsDir) {
2387    IAssertR(IsNode(SrcNId) &amp;&amp; IsNode(DstNId), TStr::Fmt(&quot;%d or %d not a node.&quot;, SrcNId, DstNId).CStr());
2388    { TNode&amp; N = GetNode(SrcNId);
2389    TIntPr Id(SrcNId, DstNId);
2390    SAttrE.DelSAttrId(Id);
2391    const int n = N.OutNIdV.SearchBin(DstNId);
2392    if (n!= -1) { N.OutNIdV.Del(n); } }
2393    { TNode&amp; N = GetNode(DstNId);
2394    const int n = N.InNIdV.SearchBin(SrcNId);
2395    if (n!= -1) { N.InNIdV.Del(n); } }
2396    if (! IsDir) {
2397      { TNode&amp; N = GetNode(SrcNId);
2398      const int n = N.InNIdV.SearchBin(DstNId);
2399      if (n!= -1) { N.InNIdV.Del(n); } }
2400      { TNode&amp; N = GetNode(DstNId);
2401      const int n = N.OutNIdV.SearchBin(SrcNId);
2402      if (n!= -1) { N.OutNIdV.Del(n); } }
2403    }
2404  }
2405  bool TDirNet::IsEdge(const int&amp; SrcNId, const int&amp; DstNId, const bool&amp; IsDir) const {
2406    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
2407    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
2408    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
2409  }
2410  TDirNet::TEdgeI TDirNet::GetEI(const int&amp; SrcNId, const int&amp; DstNId) const {
2411    const TNodeI SrcNI = GetNI(SrcNId);
2412    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
2413    IAssert(NodeN != -1);
2414    return TEdgeI(SrcNI, EndNI(), NodeN);
2415  }
2416  void TDirNet::GetNIdV(TIntV&amp; NIdV) const {
2417    NIdV.Gen(GetNodes(), 0);
2418    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2419      NIdV.Add(NodeH.GetKey(N)); }
2420  }
2421  void TDirNet::Defrag(const bool&amp; OnlyNodeLinks) {
2422    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
2423      TNode&amp; Node = NodeH[n];
2424      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
2425    }
2426    if (! OnlyNodeLinks &amp;&amp; ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
2427  }
2428  bool TDirNet::IsOk(const bool&amp; ThrowExcept) const {
2429    bool RetVal = true;
2430    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2431      const TNode&amp; Node = NodeH[N];
2432      if (! Node.OutNIdV.IsSorted()) {
2433        const TStr Msg = TStr::Fmt(&quot;Out-neighbor list of node %d is not sorted.&quot;, Node.GetId());
2434        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2435      }
2436      if (! Node.InNIdV.IsSorted()) {
2437        const TStr Msg = TStr::Fmt(&quot;In-neighbor list of node %d is not sorted.&quot;, Node.GetId());
2438        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2439      }
2440      int prevNId = -1;
2441      for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
2442        if (! IsNode(Node.GetOutNId(e))) {
2443          const TStr Msg = TStr::Fmt(&quot;Out-edge %d --&gt; %d: node %d does not exist.&quot;,
2444            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
2445          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2446        }
2447        if (e &gt; 0 &amp;&amp; prevNId == Node.GetOutNId(e)) {
2448          const TStr Msg = TStr::Fmt(&quot;Node %d has duplidate out-edge %d --&gt; %d.&quot;,
2449            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
2450          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2451        }
2452        prevNId = Node.GetOutNId(e);
2453      }
2454      prevNId = -1;
2455      for (int e = 0; e &lt; Node.GetInDeg(); e++) {
2456        if (! IsNode(Node.GetInNId(e))) {
2457          const TStr Msg = TStr::Fmt(&quot;In-edge %d &lt;-- %d: node %d does not exist.&quot;,
2458            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
2459          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2460        }
2461        if (e &gt; 0 &amp;&amp; prevNId == Node.GetInNId(e)) {
2462          const TStr Msg = TStr::Fmt(&quot;Node %d has duplidate in-edge %d &lt;-- %d.&quot;,
2463            Node.GetId(), Node.GetId(), Node.GetInNId(e));
2464          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2465        }
2466        prevNId = Node.GetInNId(e);
2467      }
2468    }
2469    return RetVal;
2470  }
2471  void TDirNet::Dump(FILE *OutF) const {
2472    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2473    fprintf(OutF, &quot;-------------------------------------------------\nDirected Node Graph: nodes: %d, edges: %d\n&quot;, GetNodes(), GetEdges());
2474    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2475      const TNode&amp; Node = NodeH[N];
2476      fprintf(OutF, &quot;  %*d]\n&quot;, NodePlaces, Node.GetId());
2477      fprintf(OutF, &quot;    in [%d]&quot;, Node.GetInDeg());
2478      for (int edge = 0; edge &lt; Node.GetInDeg(); edge++) {
2479        fprintf(OutF, &quot; %*d&quot;, NodePlaces, Node.GetInNId(edge)); }
2480      fprintf(OutF, &quot;\n    out[%d]&quot;, Node.GetOutDeg());
2481      for (int edge = 0; edge &lt; Node.GetOutDeg(); edge++) {
2482        fprintf(OutF, &quot; %*d&quot;, NodePlaces, Node.GetOutNId(edge)); }
2483      fprintf(OutF, &quot;\n&quot;);
2484    }
2485    fprintf(OutF, &quot;\n&quot;);
2486  }
2487  PDirNet TDirNet::GetSmallGraph() {
2488    PDirNet G = TDirNet::New();
2489    for (int i = 0; i &lt; 5; i++) { G-&gt;AddNode(i); }
2490    G-&gt;AddEdge(0,1); G-&gt;AddEdge(1,2); G-&gt;AddEdge(0,2);
2491    G-&gt;AddEdge(1,3); G-&gt;AddEdge(3,4); G-&gt;AddEdge(2,3);
2492    return G;
2493  }
2494  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TInt&amp; Val) {
2495    if (!IsNode(NId)) {
2496      return -1;
2497    }
2498    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2499  }
2500  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TInt&amp; Val) {
2501    if (!IsNode(NId)) {
2502      return -1;
2503    }
2504    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2505  }
2506  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TFlt&amp; Val) {
2507    if (!IsNode(NId)) {
2508      return -1;
2509    }
2510    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2511  }
2512  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TFlt&amp; Val) {
2513    if (!IsNode(NId)) {
2514      return -1;
2515    }
2516    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2517  }
2518  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, const TStr&amp; Val) {
2519    if (!IsNode(NId)) {
2520      return -1;
2521    }
2522    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2523  }
2524  int TDirNet::AddSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, const TStr&amp; Val) {
2525    if (!IsNode(NId)) {
2526      return -1;
2527    }
2528    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2529  }
2530  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TInt&amp; Val) const {
2531    if (!IsNode(NId)) {
2532      return -1;
2533    }
2534    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2535  }
2536  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TInt&amp; Val) const {
2537    if (!IsNode(NId)) {
2538      return -1;
2539    }
2540    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2541  }
2542  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TFlt&amp; Val) const {
2543    if (!IsNode(NId)) {
2544      return -1;
2545    }
2546    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2547  }
2548  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TFlt&amp; Val) const {
2549    if (!IsNode(NId)) {
2550      return -1;
2551    }
2552    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2553  }
2554  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName, TStr&amp; Val) const {
2555    if (!IsNode(NId)) {
2556      return -1;
2557    }
2558    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2559  }
2560  int TDirNet::GetSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId, TStr&amp; Val) const {
2561    if (!IsNode(NId)) {
2562      return -1;
2563    }
2564    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2565  }
2566  int TDirNet::DelSAttrDatN(const TInt&amp; NId, const TStr&amp; AttrName) {
2567    if (!IsNode(NId)) {
2568      return -1;
2569    }
2570    return SAttrN.DelSAttrDat(NId, AttrName);
2571  }
2572  int TDirNet::DelSAttrDatN(const TInt&amp; NId, const TInt&amp; AttrId) {
2573    if (!IsNode(NId)) {
2574      return -1;
2575    }
2576    return SAttrN.DelSAttrDat(NId, AttrId);
2577  }
2578  int TDirNet::GetSAttrVN(const TInt&amp; NId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
2579    if (!IsNode(NId)) {
2580      return -1;
2581    }
2582    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2583    return 0;
2584  }
2585  int TDirNet::GetIdVSAttrN(const TStr&amp; AttrName, TIntV&amp; IdV) const {
2586    return SAttrN.GetIdVSAttr(AttrName, IdV);
2587  }
2588  int TDirNet::GetIdVSAttrN(const TInt&amp; AttrId, TIntV&amp; IdV) const {
2589    return SAttrN.GetIdVSAttr(AttrId, IdV);
2590  }
2591  int TDirNet::AddSAttrN(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
2592    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2593  }
2594  int TDirNet::GetSAttrIdN(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
2595    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2596  }
2597  int TDirNet::GetSAttrNameN(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
2598    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2599  }
2600  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TInt&amp; Val) {
2601    if (!IsEdge(SrcNId, DstNId)) {
2602      return -1;
2603    }
2604    TIntPr EId(SrcNId, DstNId);
2605    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2606  }
2607  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TInt&amp; Val) {
2608    if (!IsEdge(SrcNId, DstNId)) {
2609      return -1;
2610    }
2611    TIntPr EId(SrcNId, DstNId);
2612    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2613  }
2614  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TFlt&amp; Val) {
2615    if (!IsEdge(SrcNId, DstNId)) {
2616      return -1;
2617    }
2618    TIntPr EId(SrcNId, DstNId);
2619    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2620  }
2621  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TFlt&amp; Val) {
2622    if (!IsEdge(SrcNId, DstNId)) {
2623      return -1;
2624    }
2625    TIntPr EId(SrcNId, DstNId);
2626    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2627  }
2628  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, const TStr&amp; Val) {
2629    if (!IsEdge(SrcNId, DstNId)) {
2630      return -1;
2631    }
2632    TIntPr EId(SrcNId, DstNId);
2633    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2634  }
2635  int TDirNet::AddSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, const TStr&amp; Val) {
2636    if (!IsEdge(SrcNId, DstNId)) {
2637      return -1;
2638    }
2639    TIntPr EId(SrcNId, DstNId);
2640    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2641  }
2642  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TInt&amp; Val) const {
2643    if (!IsEdge(SrcNId, DstNId)) {
2644      return -1;
2645    }
2646    TIntPr EId(SrcNId, DstNId);
2647    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2648  }
2649  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TInt&amp; Val) const {
2650    if (!IsEdge(SrcNId, DstNId)) {
2651      return -1;
2652    }
2653    TIntPr EId(SrcNId, DstNId);
2654    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2655  }
2656  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TFlt&amp; Val) const {
2657    if (!IsEdge(SrcNId, DstNId)) {
2658      return -1;
2659    }
2660    TIntPr EId(SrcNId, DstNId);
2661    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2662  }
2663  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TFlt&amp; Val) const {
2664    if (!IsEdge(SrcNId, DstNId)) {
2665      return -1;
2666    }
2667    TIntPr EId(SrcNId, DstNId);
2668    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2669  }
2670  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName, TStr&amp; Val) const {
2671    if (!IsEdge(SrcNId, DstNId)) {
2672      return -1;
2673    }
2674    TIntPr EId(SrcNId, DstNId);
2675    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2676  }
2677  int TDirNet::GetSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId, TStr&amp; Val) const {
2678    if (!IsEdge(SrcNId, DstNId)) {
2679      return -1;
2680    }
2681    TIntPr EId(SrcNId, DstNId);
2682    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2683  }
2684  int TDirNet::DelSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TStr&amp; AttrName) {
2685    if (!IsEdge(SrcNId, DstNId)) {
2686      return -1;
2687    }
2688    TIntPr EId(SrcNId, DstNId);
2689    return SAttrE.DelSAttrDat(EId, AttrName);
2690  }
2691  int TDirNet::DelSAttrDatE(const int&amp; SrcNId, const int&amp; DstNId, const TInt&amp; AttrId) {
2692    if (!IsEdge(SrcNId, DstNId)) {
2693      return -1;
2694    }
2695    TIntPr EId(SrcNId, DstNId);
2696    return SAttrE.DelSAttrDat(EId, AttrId);
2697  }
2698  int TDirNet::GetSAttrVE(const int&amp; SrcNId, const int&amp; DstNId, const TAttrType AttrType, TAttrPrV&amp; AttrV) const {
2699    if (!IsEdge(SrcNId, DstNId)) {
2700      return -1;
2701    }
2702    TIntPr EId(SrcNId, DstNId);
2703    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2704    return 0;
2705  }
2706  int TDirNet::GetIdVSAttrE(const TStr&amp; AttrName, TIntPrV&amp; IdV) const {
2707    return SAttrE.GetIdVSAttr(AttrName, IdV);
2708  }
2709  int TDirNet::GetIdVSAttrE(const TInt&amp; AttrId, TIntPrV&amp; IdV) const {
2710    return SAttrE.GetIdVSAttr(AttrId, IdV);
2711  }
2712  int TDirNet::AddSAttrE(const TStr&amp; Name, const TAttrType&amp; AttrType, TInt&amp; AttrId) {
2713    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2714  }
2715  int TDirNet::GetSAttrIdE(const TStr&amp; Name, TInt&amp; AttrId, TAttrType&amp; AttrType) const {
2716    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2717  }
2718  int TDirNet::GetSAttrNameE(const TInt&amp; AttrId, TStr&amp; Name, TAttrType&amp; AttrType) const {
2719    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2720  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</div>
                </div>
                <div class="column column_space"><pre><code>350          TFltV val = this-&gt;VecOfFltVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
351          if (val.Len() != 0) Values.Add(val);
352        } else {
353          const THash&lt;TInt, TFltV&gt;&amp; NewHash = VecOfFltHashVecsE[index];
354          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
355            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
356          }
357        }
358      }
359      EdgeHI++;
360    }
361  }
362  void TNEANet::StrAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
363    Names = TVec&lt;TStr&gt;();
364    while (!EdgeHI.IsEnd()) {
365      if (EdgeHI.GetDat().Val1 == StrType &amp;&amp; !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
</pre></code></div>
                <div class="column column_space"><pre><code>321          TIntV val = this-&gt;VecOfIntVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
322          if (val.Len() != 0) Values.Add(val);
323        } else {
324          const THash&lt;TInt, TIntV&gt;&amp; NewHash = VecOfIntHashVecsE[index];
325          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
326            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
327          }
328        }
329      }
330      EdgeHI++;
331    }
332  }
333  void TNEANet::FltVAttrNameEI(const TInt&amp; EId, TStrIntPrH::TIter EdgeHI, TStrV&amp; Names) const {
334    Names = TVec&lt;TStr&gt;();
335    while (!EdgeHI.IsEnd()) {
336      if (EdgeHI.GetDat().Val1 == FltVType) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    