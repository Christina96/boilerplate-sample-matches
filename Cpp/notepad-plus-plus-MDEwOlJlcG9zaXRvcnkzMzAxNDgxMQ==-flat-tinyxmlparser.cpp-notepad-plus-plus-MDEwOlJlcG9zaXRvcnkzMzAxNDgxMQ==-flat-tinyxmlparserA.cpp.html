
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlparser.cpp</h3>
            <pre><code>1  #include <sstream>
2  #include <tchar.h>
3  #include "tinyxml.h"
4  TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] = 
5  {
6  	{ TEXT("&amp;"),  5, '&' },
7  	{ TEXT("&lt;"),   4, '<' },
8  	{ TEXT("&gt;"),   4, '>' },
9  	{ TEXT("&quot;"), 6, '\"' },
10  	{ TEXT("&apos;"), 6, '\'' }
11  };
12  class TiXmlParsingData
13  {
14  	friend class TiXmlDocument;
15    public:
16  	void Stamp( const TCHAR* now );
17  	const TiXmlCursor& Cursor()	{ return cursor; }
18    private:
19  	TiXmlParsingData( const TCHAR* start, int _tabsize, int row, int col )
20  	{
21  		assert( start );
22  		stamp = start;
23  		tabsize = _tabsize;
24  		cursor.row = row;
25  		cursor.col = col;
26  	}
27  	TiXmlCursor		cursor;
28  	const TCHAR*		stamp;
29  	int				tabsize;
30  };
31  void TiXmlParsingData::Stamp( const TCHAR* now )
32  {
33  	assert( now );
34  	if ( tabsize < 1 )
35  	{
36  		return;
37  	}
38  	int row = cursor.row;
39  	int col = cursor.col;
40  	const TCHAR* p = stamp;
41  	assert( p );
42  	while ( p < now )
43  	{
44  		switch (*p) {
45  			case 0:
46  				return;
47  			case '\r':
48  				++row;
49  				col = 0;				
50  				++p;
51  				if (*p == '\n') {
52  					++p;
53  				}
54  				break;
55  			case '\n':
56  				++row;
57  				col = 0;
58  				++p;
59  				if (*p == '\r') {
60  					++p;
61  				}
62  				break;
63  			case '\t':
64  				++p;
65  				col = (col / tabsize + 1) * tabsize;
66  				break;
67  			default:
68  				++p;
69  				++col;
70  				break;
71  		}
72  	}
73  	cursor.row = row;
74  	cursor.col = col;
75  	assert( cursor.row >= -1 );
76  	assert( cursor.col >= -1 );
77  	stamp = p;
78  	assert( stamp );
79  }
80  const TCHAR* TiXmlBase::SkipWhiteSpace( const TCHAR* p )
81  {
82  	if ( !p || !*p )
83  	{
84  		return 0;
85  	}
86  	while ( p && *p )
87  	{
88  		if ( _istspace( *p ) || *p == '\n' || *p =='\r' )		
89  			++p;
90  		else
91  			break;
92  	}
93  	return p;
94  }
95  #ifdef TIXML_USE_STL
96   bool TiXmlBase::StreamWhiteSpace( TIXML_ISTREAM * in, TIXML_STRING * tag )
97  {
98  	for ( ;; )
99  	{
100  		if ( !in->good() ) return false;
101  		int c = in->peek();
102  		if ( !IsWhiteSpace( c ) )
103  			return true;
104  		*tag += static_cast<TCHAR>(in->get());
105  	}
106  }
107   bool TiXmlBase::StreamTo( TIXML_ISTREAM * in, int character, TIXML_STRING * tag )
108  {
109  	while ( in->good() )
110  	{
111  		int c = in->peek();
112  		if ( c == character )
113  			return true;
114  		in->get();
115  		*tag += static_cast<TCHAR>(c);
116  	}
117  	return false;
118  }
119  #endif
120  const TCHAR* TiXmlBase::ReadName( const TCHAR* p, TIXML_STRING * name )
121  {
122  	*name = TEXT("");
123  	assert( p );
124  	if (    p && *p 
125  		 && ( _istalpha( *p ) || *p == '_' ) )
126  	{
127  		while(		p && *p
128  				&&	(		_istalnum( *p ) 
129  						 || *p == '_'
130  						 || *p == '-'
131  						 || *p == '.'
132  						 || *p == ':' ) )
133  		{
134  			(*name) += *p;
135  			++p;
136  		}
137  		return p;
138  	}
139  	return 0;
140  }
141  const TCHAR* TiXmlBase::GetEntity( const TCHAR* p, TCHAR* value )
142  {
143  	int i;
144  	if (wcsncmp( TEXT("&#x"), p, 3 ) == 0)
145  	{
146  		const TCHAR* end = wcschr(p+3, L';');
147  		if (end && end - p <= 3 + 4)
148  		{
149  			TCHAR* hexend;
150  			auto val = wcstol(p + 3, &hexend, 16);
151  			if (hexend == end)
152  			{
153  				*value = static_cast<TCHAR>(val);
154  				return end + 1;
155  			}
156  		}
157  	}
158  	for (i=0; i<NUM_ENTITY; ++i)
159  	{
160  		if (wcsncmp( entity[i].str, p, entity[i].strLength ) == 0 )
161  		{
162  			assert(static_cast<unsigned int>(lstrlen(entity[i].str)) == entity[i].strLength );
163  			*value = entity[i].chr;
164  			return (p + entity[i].strLength);
165  		}
166  	}
167  	*value = *p;	
168  	return p+1;
169  }
170  bool TiXmlBase::StringEqual( const TCHAR* p,
171  							 const TCHAR* tag,
172  							 bool ignoreCase )
173  {
174  	assert( p );
175  	if ( !p || !*p )
176  	{
177  		assert( 0 );
178  		return false;
179  	}
180      if ( _totlower( *p ) == _totlower( *tag ) )
181  	{
182  		const TCHAR* q = p;
183  		if (ignoreCase)
184  		{
185  			while ( *q && *tag && *q == *tag )
186  			{
187  				++q;
188  				++tag;
189  			}
190  			if ( *tag == 0 )		
191  			{
192  				return true;
193  			}
194  		}
195  		else
196  		{
197  			while ( *q && *tag && _totlower( *q ) == _totlower( *tag ) )
198  			{
199  				++q;
200  				++tag;
201  			}
202  			if ( *tag == 0 )
203  			{
204  				return true;
205  			}
206  		}
207  	}
208  	return false;
209  }
210  const TCHAR* TiXmlBase::ReadText(	const TCHAR* p, 
211  									TIXML_STRING * text, 
212  									bool trimWhiteSpace, 
213  									const TCHAR* endTag, 
214  									bool caseInsensitive )
215  {
216      *text = TEXT("");
217  	if (    !trimWhiteSpace			
218  		 || !condenseWhiteSpace )	
219  	{
220  		while (	   p && *p
221  				&& !StringEqual( p, endTag, caseInsensitive )
222  			  )
223  		{
224  			TCHAR c;
225  			p = GetChar( p, &c );
226              (* text) += c;
227  		}
228  	}
229  	else
230  	{
231  		bool whitespace = false;
232  		p = SkipWhiteSpace( p );
233  		while (	   p && *p
234  				&& !StringEqual( p, endTag, caseInsensitive ) )
235  		{
236  			if ( *p == '\r' || *p == '\n' )
237  			{
238  				whitespace = true;
239  				++p;
240  			}
241  			else if ( _istspace( *p ) )
242  			{
243  				whitespace = true;
244  				++p;
245  			}
246  			else
247  			{
248  				if ( whitespace )
249  				{
250                 (* text) += ' ';
251  					whitespace = false;
252  				}
253  				TCHAR c;
254  				p = GetChar( p, &c );
255              (* text) += c;
256  			}
257  		}
258  	}
259  	return p + lstrlen( endTag );
260  }
261  #ifdef TIXML_USE_STL
262  void TiXmlDocument::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
263  {
264  	if ( !StreamTo( in, '<', tag ) ) 
265  	{
266  		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0 );
267  		return;
268  	}
269  	while ( in->good() )
270  	{
271  		size_t tagIndex = tag->length();
272  		while ( in->good() && in->peek() != '>' )
273  		{
274  			int c = in->get();
275  			(*tag) += static_cast<TCHAR>(c);
276  		}
277  		if ( in->good() )
278  		{
279  			TiXmlNode* node = Identify( tag->c_str() + tagIndex );
280  			if ( node )
281  			{
282  				node->StreamIn( in, tag );
283  				bool isElement = node->ToElement() != 0;
284  				delete node;
285  				node = 0;
286  				if ( isElement )
287  				{
288  					return;
289  				}
290  			}
291  			else
292  			{
293  				SetError( TIXML_ERROR, 0, 0 );
294  				return;
295  			}
296  		}
297  	}
298  	SetError( TIXML_ERROR, 0, 0 );
299  }
300  #endif
301  const TCHAR* TiXmlDocument::Parse( const TCHAR* p, TiXmlParsingData* prevData )
302  {
303  	ClearError();
304  	if ( !p || !*p )
305  	{
306  		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0 );
307  		return 0;
308  	}
309  	location.Clear();
310  	if ( prevData )
311  	{
312  		location.row = prevData->cursor.row;
313  		location.col = prevData->cursor.col;
314  	}
315  	else
316  	{
317  		location.row = 0;
318  		location.col = 0;
319  	}
320  	TiXmlParsingData data( p, TabSize(), location.row, location.col );
321  	location = data.Cursor();
322      p = SkipWhiteSpace( p );
323  	if ( !p )
324  	{
325  		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0 );
326  		return 0;
327  	}
328  	while ( p && *p )
329  	{
330  		TiXmlNode* node = Identify( p );
331  		if ( node )
332  		{
333  			p = node->Parse( p, &data );
334  			LinkEndChild( node );
335  		}
336  		else
337  		{
338  			break;
339  		}
340  		p = SkipWhiteSpace( p );
341  	}
342  	return p;
343  }
344  void TiXmlDocument::SetError( int err, const TCHAR* pError, TiXmlParsingData* data )
345  {	
346  	if ( error )
347  		return;
348  	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
349  	error   = true;
350  	errorId = err;
351  	errorDesc = errorString[ errorId ];
352  	errorLocation.Clear();
353  	if ( pError && data )
354  	{
355  		data->Stamp( pError );
356  		errorLocation = data->Cursor();
357  	}
358  }
359  TiXmlNode* TiXmlNode::Identify( const TCHAR* p )
360  {
361  	TiXmlNode* returnNode = 0;
<span onclick='openModal()' class='match'>362  	p = SkipWhiteSpace( p );
363  	if ( !p || !*p || *p != '<' )
364  	{
365  		return 0;
</span>366  	}
367  	TiXmlDocument* doc = GetDocument();
368  	p = SkipWhiteSpace( p );
369  	if ( !p || !*p )
370  	{
371  		return 0;
372  	}
373  	const TCHAR* xmlHeader = { TEXT("<?xml") };
374  	const TCHAR* commentHeader = { TEXT("<!--") };
375  	if ( StringEqual( p, xmlHeader, true ) )
376  	{
377  		#ifdef DEBUG_PARSER
378  			TIXML_LOG( "XML parsing Declaration\n" );
379  		#endif
380  		returnNode = new TiXmlDeclaration();
381  	}
382  	else if (    _istalpha( *(p+1) )
383  			  || *(p+1) == '_' )
384  	{
385  		#ifdef DEBUG_PARSER
386  			TIXML_LOG( "XML parsing Element\n" );
387  		#endif
388  		returnNode = new TiXmlElement( TEXT("") );
389  	}
390  	else if ( StringEqual( p, commentHeader, false ) )
391  	{
392  		#ifdef DEBUG_PARSER
393  			TIXML_LOG( "XML parsing Comment\n" );
394  		#endif
395  		returnNode = new TiXmlComment();
396  	}
397  	else
398  	{
399  		#ifdef DEBUG_PARSER
400  			TIXML_LOG( "XML parsing Unknown\n" );
401  		#endif
402  		returnNode = new TiXmlUnknown();
403  	}
404  	if ( returnNode )
405  	{
406  		returnNode->parent = this;
407  	}
408  	else
409  	{
410  		if ( doc )
411  			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0 );
412  	}
413  	return returnNode;
414  }
415  #ifdef TIXML_USE_STL
416  void TiXmlElement::StreamIn (TIXML_ISTREAM * in, TIXML_STRING * tag)
417  {
418  	while( in->good() )
419  	{
420  		int c = in->get();
421  		(*tag) += static_cast<TCHAR>(c);
422  		if ( c == '>' )
423  			break;
424  	}
425  	if ( tag->length() < 3 ) return;
426  	if (    tag->at( tag->length() - 1 ) == '>' 
427  		 && tag->at( tag->length() - 2 ) == '/' )
428  	{
429  		return;
430  	}
431  	else if ( tag->at( tag->length() - 1 ) == '>' )
432  	{
433  		for ( ;; )
434  		{
435  			StreamWhiteSpace( in, tag );
436  			if ( in->good() && in->peek() != '<' ) 
437  			{
438  				TiXmlText text( TEXT("") );
439  				text.StreamIn( in, tag );
440  				continue;
441  			}
442  			if ( !in->good() ) return;
443  			assert( in->peek() == '<' );
444  			size_t tagIndex = tag->length();
445  			bool closingTag = false;
446  			bool firstCharFound = false;
447  			for ( ;; )
448  			{
449  				if ( !in->good() )
450  					return;
451  				int c = in->peek();
452  				if ( c == '>' )
453  					break;
454  				*tag += static_cast<TCHAR>(c);
455  				in->get();
456  				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
457  				{
458  					firstCharFound = true;
459  					if ( c == '/' )
460  						closingTag = true;
461  				}
462  			}
463  			if ( closingTag )
464  			{
465  				int c = in->get();
466  				assert( c == '>' );
467  				*tag += static_cast<TCHAR>(c);
468  				return;
469  			}
470  			else
471  			{
472  				const TCHAR* tagloc = tag->c_str() + tagIndex;
473  				TiXmlNode* node = Identify( tagloc );
474  				if ( !node )
475  					return;
476  				node->StreamIn( in, tag );
477  				delete node;
478  				node = 0;
479  			}
480  		}
481  	}
482  }
483  #endif
484  const TCHAR* TiXmlElement::Parse( const TCHAR* p, TiXmlParsingData* data )
485  {
486  	p = SkipWhiteSpace( p );
487  	TiXmlDocument* document = GetDocument();
488  	if ( !p || !*p )
489  	{
490  		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0 );
491  		return 0;
492  	}
493  	if ( data )
494  	{
495  		data->Stamp( p );
496  		location = data->Cursor();
497  	}
498  	if ( *p != '<' )
499  	{
500  		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data );
501  		return 0;
502  	}
503  	p = SkipWhiteSpace( p+1 );
504  	const TCHAR* pErr = p;
505      p = ReadName( p, &value );
506  	if ( !p || !*p )
507  	{
508  		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data );
509  		return 0;
510  	}
511      TIXML_STRING endTag (TEXT("</"));
512  	endTag += value;
513  	endTag += TEXT(">");
514  	while ( p && *p )
515  	{
516  		pErr = p;
517  		p = SkipWhiteSpace( p );
518  		if ( !p || !*p )
519  		{
520  			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data );
521  			return 0;
522  		}
523  		if ( *p == '/' )
524  		{
525  			++p;
526  			if ( *p  != '>' )
527  			{
528  				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data );		
529  				return 0;
530  			}
531  			return (p+1);
532  		}
533  		else if ( *p == '>' )
534  		{
535  			++p;
536  			p = ReadValue( p, data );		
537  			if ( !p || !*p )
538  				return 0;
539  			if ( StringEqual( p, endTag.c_str(), false ) )
540  			{
541  				p += endTag.length();
542  				return p;
543  			}
544  			else
545  			{
546  				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data );
547  				return 0;
548  			}
549  		}
550  		else
551  		{
552  			TiXmlAttribute* attrib = new TiXmlAttribute();
553  			if ( !attrib )
554  			{
555  				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data );
556  				return 0;
557  			}
558  			attrib->SetDocument( document );
559  			const TCHAR* pErr = p;
560  			p = attrib->Parse( p, data );
561  			if ( !p || !*p )
562  			{
563  				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data );
564  				delete attrib;
565  				return 0;
566  			}
567  			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
568  			if ( node )
569  			{
570  				node->SetValue( attrib->Value() );
571  				delete attrib;
572  				return 0;
573  			}
574  			attributeSet.Add( attrib );
575  		}
576  	}
577  	return p;
578  }
579  const TCHAR* TiXmlElement::ReadValue( const TCHAR* p, TiXmlParsingData* data )
580  {
581  	TiXmlDocument* document = GetDocument();
582  	p = SkipWhiteSpace( p );
583  	while ( p && *p )
584  	{
585  		if ( *p != '<' )
586  		{
587  			TiXmlText* textNode = new TiXmlText( TEXT("") );
588  			if ( !textNode )
589  			{
590  				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0 );
591  				    return 0;
592  			}
593  			p = textNode->Parse( p, data );
594  			if ( !textNode->Blank() )
595  				LinkEndChild( textNode );
596  			else
597  				delete textNode;
598  		} 
599  		else 
600  		{
601  			if ( StringEqual( p, TEXT("</"), false ) )
602  			{
603  				return p;
604  			}
605  			else
606  			{
607  				TiXmlNode* node = Identify( p );
608  				if ( node )
609  				{
610  					p = node->Parse( p, data );
611  					LinkEndChild( node );
612  				}				
613  				else
614  				{
615  					return 0;
616  				}
617  			}
618  		}
619  		p = SkipWhiteSpace( p );
620  	}
621  	if ( !p )
622  	{
623  		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0 );
624  	}	
625  	return p;
626  }
627  #ifdef TIXML_USE_STL
628  void TiXmlUnknown::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
629  {
630  	while ( in->good() )
631  	{
632  		int c = in->get();	
633  		(*tag) += static_cast<TCHAR>(c);
634  		if ( c == '>' )
635  		{
636  			return;		
637  		}
638  	}
639  }
640  #endif
641  const TCHAR* TiXmlUnknown::Parse( const TCHAR* p, TiXmlParsingData* data )
642  {
643  	TiXmlDocument* document = GetDocument();
644  	p = SkipWhiteSpace( p );
645  	if ( data )
646  	{
647  		data->Stamp( p );
648  		location = data->Cursor();
649  	}
650  	if ( !p || !*p || *p != '<' )
651  	{
652  		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data );
653  		return 0;
654  	}
655  	++p;
656      value = TEXT("");
657  	while ( p && *p && *p != '>' )
658  	{
659  		value += *p;
660  		++p;
661  	}
662  	if ( !p )
663  	{
664  		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0 );
665  	}
666  	if ( *p == '>' )
667  		return p+1;
668  	return p;
669  }
670  #ifdef TIXML_USE_STL
671  void TiXmlComment::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
672  {
673  	while ( in->good() )
674  	{
675  		int c = in->get();	
676  		(*tag) += static_cast<TCHAR>(c);
677  		if ( c == '>' 
678  			 && tag->at( tag->length() - 2 ) == '-'
679  			 && tag->at( tag->length() - 3 ) == '-' )
680  		{
681  			return;		
682  		}
683  	}
684  }
685  #endif
686  const TCHAR* TiXmlComment::Parse( const TCHAR* p, TiXmlParsingData* data )
687  {
688  	TiXmlDocument* document = GetDocument();
689  	value = TEXT("");
690  	p = SkipWhiteSpace( p );
691  	if ( data )
692  	{
693  		data->Stamp( p );
694  		location = data->Cursor();
695  	}
696  	const TCHAR* startTag = TEXT("<!--");
697  	const TCHAR* endTag   = TEXT("-->");
698  	if ( !StringEqual( p, startTag, false ) )
699  	{
700  		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data );
701  		return 0;
702  	}
703  	p += lstrlen( startTag );
704  	p = ReadText( p, &value, false, endTag, false );
705  	return p;
706  }
707  const TCHAR* TiXmlAttribute::Parse( const TCHAR* p, TiXmlParsingData* data )
708  {
709  	p = SkipWhiteSpace( p );
710  	if ( !p || !*p ) return 0;
711  	if ( data )
712  	{
713  		data->Stamp( p );
714  		location = data->Cursor();
715  	}
716  	const TCHAR* pErr = p;
717  	p = ReadName( p, &name );
718  	if ( !p || !*p )
719  	{
720  		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data );
721  		return 0;
722  	}
723  	p = SkipWhiteSpace( p );
724  	if ( !p || !*p || *p != '=' )
725  	{
726  		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data );
727  		return 0;
728  	}
729  	++p;	
730  	p = SkipWhiteSpace( p );
731  	if ( !p || !*p )
732  	{
733  		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data );
734  		return 0;
735  	}
736  	const TCHAR* end;
737  	if ( *p == '\'' )
738  	{
739  		++p;
740  		end = TEXT("\'");
741  		p = ReadText( p, &value, false, end, false );
742  	}
743  	else if ( *p == '"' )
744  	{
745  		++p;
746  		end = TEXT("\"");
747  		p = ReadText( p, &value, false, end, false );
748  	}
749  	else
750  	{
751  		value = TEXT("");
752  		while (    p && *p										
753  				&& !_istspace( *p ) && *p != '\n' && *p != '\r'	
754  				&& *p != '/' && *p != '>' )						
755  		{
756  			value += *p;
757  			++p;
758  		}
759  	}
760  	return p;
761  }
762  #ifdef TIXML_USE_STL
763  void TiXmlText::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
764  {
765  	while ( in->good() )
766  	{
767  		int c = in->peek();	
768  		if ( c == '<' )
769  			return;
770  		(*tag) += static_cast<TCHAR>(c);
771  		in->get();
772  	}
773  }
774  #endif
775  const TCHAR* TiXmlText::Parse( const TCHAR* p, TiXmlParsingData* data )
776  {
777  	value = TEXT("");
778  	if ( data )
779  	{
780  		data->Stamp( p );
781  		location = data->Cursor();
782  	}
783  	bool ignoreWhite = true;
784  	const TCHAR* end = TEXT("<");
785  	p = ReadText( p, &value, ignoreWhite, end, false );
786  	if ( p )
787  		return p-1;	
788  	return 0;
789  }
790  #ifdef TIXML_USE_STL
791  void TiXmlDeclaration::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
792  {
793  	while ( in->good() )
794  	{
795  		int c = in->get();
796  		(*tag) += static_cast<TCHAR>(c);
797  		if ( c == '>' )
798  		{
799  			return;
800  		}
801  	}
802  }
803  #endif
804  const TCHAR* TiXmlDeclaration::Parse( const TCHAR* p, TiXmlParsingData* data )
805  {
806  	p = SkipWhiteSpace( p );
807  	TiXmlDocument* document = GetDocument();
808  	if ( !p || !*p || !StringEqual( p, TEXT("<?xml"), true ) )
809  	{
810  		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0 );
811  		return 0;
812  	}
813  	if ( data )
814  	{
815  		data->Stamp( p );
816  		location = data->Cursor();
817  	}
818  	p += 5;
819  	version = TEXT("");
820  	encoding = TEXT("");
821  	standalone = TEXT("");
822  	while ( p && *p )
823  	{
824  		if ( *p == '>' )
825  		{
826  			++p;
827  			return p;
828  		}
829  		p = SkipWhiteSpace( p );
830  		if ( StringEqual( p, TEXT("version"), true ) )
831  		{
832  			TiXmlAttribute attrib;
833  			p = attrib.Parse( p, data );		
834  			version = attrib.Value();
835  		}
836  		else if ( StringEqual( p, TEXT("encoding"), true ) )
837  		{
838  			TiXmlAttribute attrib;
839  			p = attrib.Parse( p, data );		
840  			encoding = attrib.Value();
841  		}
842  		else if ( StringEqual( p, TEXT("standalone"), true ) )
843  		{
844  			TiXmlAttribute attrib;
845  			p = attrib.Parse( p, data );		
846  			standalone = attrib.Value();
847  		}
848  		else
849  		{
850  			while( p && *p && *p != '>' && !_istspace( *p ) )
851  				++p;
852  		}
853  	}
854  	return 0;
855  }
856  bool TiXmlText::Blank() const
857  {
858  	for (size_t i = 0, len = value.length(); i < len; i++)
859  		if ( !_istspace( value[i] ) )
860  			return false;
861  	return true;
862  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlparserA.cpp</h3>
            <pre><code>1  #include <sstream>
2  #include "tinyxmlA.h"
3  TiXmlBaseA::Entity TiXmlBaseA::entity[ NUM_ENTITY ] = 
4  {
5  	{ "&amp;",  5, '&' },
6  	{ "&lt;",   4, '<' },
7  	{ "&gt;",   4, '>' },
8  	{ "&quot;", 6, '\"' },
9  	{ "&apos;", 6, '\'' }
10  };
11  class TiXmlParsingDataA
12  {
13  	friend class TiXmlDocumentA;
14    public:
15  	void Stamp( const char* now );
16  	const TiXmlCursorA& Cursor()	{ return cursor; }
17    private:
18  	TiXmlParsingDataA( const char* start, int _tabsize, int row, int col )
19  	{
20  		assert( start );
21  		stamp = start;
22  		tabsize = _tabsize;
23  		cursor.row = row;
24  		cursor.col = col;
25  	}
26  	TiXmlCursorA		cursor;
27  	const char*		stamp;
28  	int				tabsize;
29  };
30  void TiXmlParsingDataA::Stamp( const char* now )
31  {
32  	assert( now );
33  	if ( tabsize < 1 )
34  	{
35  		return;
36  	}
37  	int row = cursor.row;
38  	int col = cursor.col;
39  	const char* p = stamp;
40  	assert( p );
41  	while ( p < now )
42  	{
43  		switch (*p) {
44  			case 0:
45  				return;
46  			case '\r':
47  				++row;
48  				col = 0;				
49  				++p;
50  				if (*p == '\n') {
51  					++p;
52  				}
53  				break;
54  			case '\n':
55  				++row;
56  				col = 0;
57  				++p;
58  				if (*p == '\r') {
59  					++p;
60  				}
61  				break;
62  			case '\t':
63  				++p;
64  				col = (col / tabsize + 1) * tabsize;
65  				break;
66  			default:
67  				++p;
68  				++col;
69  				break;
70  		}
71  	}
72  	cursor.row = row;
73  	cursor.col = col;
74  	assert( cursor.row >= -1 );
75  	assert( cursor.col >= -1 );
76  	stamp = p;
77  	assert( stamp );
78  }
79  const char* TiXmlBaseA::SkipWhiteSpace( const char* p )
80  {
81  	if ( !p || !*p )
82  	{
83  		return 0;
84  	}
85  	while ( p && *p )
86  	{
87  		if ( isspace( *p ) || *p == '\n' || *p =='\r' )		
88  			++p;
89  		else
90  			break;
91  	}
92  	return p;
93  }
94  #ifdef TIXMLA_USE_STL
95   bool TiXmlBaseA::StreamWhiteSpace( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
96  {
97  	for ( ;; )
98  	{
99  		if ( !in->good() ) return false;
100  		int c = in->peek();
101  		if ( !IsWhiteSpace( c ) )
102  			return true;
103  		*tag += static_cast<char>(in->get());
104  	}
105  }
106   bool TiXmlBaseA::StreamTo( TIXMLA_ISTREAM * in, int character, TIXMLA_STRING * tag )
107  {
108  	while ( in->good() )
109  	{
110  		int c = in->peek();
111  		if ( c == character )
112  			return true;
113  		in->get();
114  		*tag += static_cast<char>(c);
115  	}
116  	return false;
117  }
118  #endif
119  const char* TiXmlBaseA::ReadName( const char* p, TIXMLA_STRING * name )
120  {
121  	*name = "";
122  	assert( p );
123  	if ( p && *p 
124  		&& (isalpha(static_cast<unsigned char>(*p)) || *p == '_'))
125  	{
126  		while ( p && *p
127  				&&	(		isalnum( (unsigned char ) *p ) 
128  						 || *p == '_'
129  						 || *p == '-'
130  						 || *p == '.'
131  						 || *p == ':' ) )
132  		{
133  			(*name) += *p;
134  			++p;
135  		}
136  		return p;
137  	}
138  	return 0;
139  }
140  const char* TiXmlBaseA::GetEntity( const char* p, char* value )
141  {
142      TIXMLA_STRING ent;
143  	int i;
144  	if (    strncmp( "&#x", p, 3 ) == 0 
145  	     && *(p+3) 
146  		 && *(p+4) 
147  		 && ( *(p+4) == ';' || *(p+5) == ';' )
148  	   )
149  	{
150  		*value = 0;
151  		if ( *(p+4) == ';' )
152  		{
153  			if ( isalpha( *(p+3) ) ) 
154  				*value += static_cast<char>(static_cast<char>(tolower(*(p + 3))) - 'a' + 10);
155  			else				     
156  				*value += static_cast<char>(static_cast<char>(*(p + 3)) - '0');
157  			return p+5;
158  		}
159  		else
160  		{
161  			if (isalpha(*(p + 3))) *value += static_cast<char>((static_cast<char>(tolower(*(p + 3))) - 'a' + 10) * 16);
162  			else				     *value += static_cast<char>((static_cast<char>(*(p + 3)) - '0') * 16);
163  			if ( isalpha( *(p+4) ) ) 
164  				*value += static_cast<char>(static_cast<char>(tolower(*(p + 4))) - 'a' + 10);
165  			else				     
166  				*value += static_cast<char>(static_cast<char>(*(p + 4)) - '0');
167  			return p+6;
168  		}
169  	}
170  	for ( i=0; i<NUM_ENTITY; ++i )
171  	{
172  		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
173  		{
174  			assert( strlen( entity[i].str ) == entity[i].strLength );
175  			*value = entity[i].chr;
176  			return ( p + entity[i].strLength );
177  		}
178  	}
179  	*value = *p;	
180  	return p+1;
181  }
182  bool TiXmlBaseA::StringEqual( const char* p,
183  							 const char* tag,
184  							 bool ignoreCase )
185  {
186  	assert( p );
187  	if ( !p || !*p )
188  	{
189  		assert( 0 );
190  		return false;
191  	}
192      if ( tolower( *p ) == tolower( *tag ) )
193  	{
194  		const char* q = p;
195  		if (ignoreCase)
196  		{
197  			while ( *q && *tag && *q == *tag )
198  			{
199  				++q;
200  				++tag;
201  			}
202  			if ( *tag == 0 )		
203  			{
204  				return true;
205  			}
206  		}
207  		else
208  		{
209  			while ( *q && *tag && tolower( *q ) == tolower( *tag ) )
210  			{
211  				++q;
212  				++tag;
213  			}
214  			if ( *tag == 0 )
215  			{
216  				return true;
217  			}
218  		}
219  	}
220  	return false;
221  }
222  const char* TiXmlBaseA::ReadText(	const char* p, 
223  									TIXMLA_STRING * text, 
224  									bool trimWhiteSpace, 
225  									const char* endTag, 
226  									bool caseInsensitive )
227  {
228      *text = "";
229  	if (    !trimWhiteSpace			
230  		 || !condenseWhiteSpace )	
231  	{
232  		while (	   p && *p
233  				&& !StringEqual( p, endTag, caseInsensitive )
234  			  )
235  		{
236  			char c;
237  			p = GetChar( p, &c );
238              (* text) += c;
239  		}
240  	}
241  	else
242  	{
243  		bool whitespace = false;
244  		p = SkipWhiteSpace( p );
245  		while (	   p && *p
246  				&& !StringEqual( p, endTag, caseInsensitive ) )
247  		{
248  			if ( *p == '\r' || *p == '\n' )
249  			{
250  				whitespace = true;
251  				++p;
252  			}
253  			else if ( isspace( *p ) )
254  			{
255  				whitespace = true;
256  				++p;
257  			}
258  			else
259  			{
260  				if ( whitespace )
261  				{
262                 (* text) += ' ';
263  					whitespace = false;
264  				}
265  				char c;
266  				p = GetChar( p, &c );
267              (* text) += c;
268  			}
269  		}
270  	}
271  	return p + strlen( endTag );
272  }
273  #ifdef TIXMLA_USE_STL
274  void TiXmlDocumentA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
275  {
276  	if ( !StreamTo( in, '<', tag ) ) 
277  	{
278  		SetError( TIXMLA_ERROR_PARSING_EMPTY, 0, 0 );
279  		return;
280  	}
281  	while ( in->good() )
282  	{
283  		size_t tagIndex = tag->length();
284  		while ( in->good() && in->peek() != '>' )
285  		{
286  			int c = in->get();
287  			(*tag) += static_cast<char>(c);
288  		}
289  		if ( in->good() )
290  		{
291  			TiXmlNodeA* node = Identify( tag->c_str() + tagIndex );
292  			if ( node )
293  			{
294  				node->StreamIn( in, tag );
295  				bool isElement = node->ToElement() != 0;
296  				delete node;
297  				node = 0;
298  				if ( isElement )
299  				{
300  					return;
301  				}
302  			}
303  			else
304  			{
305  				SetError( TIXMLA_ERROR, 0, 0 );
306  				return;
307  			}
308  		}
309  	}
310  	SetError( TIXMLA_ERROR, 0, 0 );
311  }
312  #endif
313  const char* TiXmlDocumentA::Parse( const char* p, TiXmlParsingDataA* prevData )
314  {
315  	ClearError();
316  	if ( !p || !*p )
317  	{
318  		SetError( TIXMLA_ERROR_DOCUMENT_EMPTY, 0, 0 );
319  		return 0;
320  	}
321  	location.Clear();
322  	if ( prevData )
323  	{
324  		location.row = prevData->cursor.row;
325  		location.col = prevData->cursor.col;
326  	}
327  	else
328  	{
329  		location.row = 0;
330  		location.col = 0;
331  	}
332  	TiXmlParsingDataA data( p, TabSize(), location.row, location.col );
333  	location = data.Cursor();
334      p = SkipWhiteSpace( p );
335  	if ( !p )
336  	{
337  		SetError( TIXMLA_ERROR_DOCUMENT_EMPTY, 0, 0 );
338  		return 0;
339  	}
340  	while ( p && *p )
341  	{
342  		TiXmlNodeA* node = Identify( p );
343  		if ( node )
344  		{
345  			p = node->Parse( p, &data );
346  			LinkEndChild( node );
347  		}
348  		else
349  		{
350  			break;
351  		}
352  		p = SkipWhiteSpace( p );
353  	}
354  	return p;
355  }
356  void TiXmlDocumentA::SetError( int err, const char* pError, TiXmlParsingDataA* data )
357  {	
358  	if ( error )
359  		return;
360  	assert( err > 0 && err < TIXMLA_ERROR_STRING_COUNT );
361  	error   = true;
362  	errorId = err;
363  	errorDesc = errorString[ errorId ];
364  	errorLocation.Clear();
365  	if ( pError && data )
366  	{
367  		data->Stamp( pError );
368  		errorLocation = data->Cursor();
369  	}
370  }
371  TiXmlNodeA* TiXmlNodeA::Identify( const char* p )
372  {
373  	TiXmlNodeA* returnNode = 0;
<span onclick='openModal()' class='match'>374  	p = SkipWhiteSpace( p );
375  	if ( !p || !*p || *p != '<' )
376  	{
377  		return 0;
</span>378  	}
379  	TiXmlDocumentA* doc = GetDocument();
380  	p = SkipWhiteSpace( p );
381  	if ( !p || !*p )
382  	{
383  		return 0;
384  	}
385  	const char* xmlHeader = { "<?xml" };
386  	const char* commentHeader = { "<!--" };
387  	if ( StringEqual( p, xmlHeader, true ) )
388  	{
389  		#ifdef DEBUG_PARSER
390  			TIXMLA_LOG( "XML parsing Declaration\n" );
391  		#endif
392  		returnNode = new TiXmlDeclarationA();
393  	}
394  	else if (    isalpha( *(p+1) )
395  			  || *(p+1) == '_' )
396  	{
397  		#ifdef DEBUG_PARSER
398  			TIXMLA_LOG( "XML parsing Element\n" );
399  		#endif
400  		returnNode = new TiXmlElementA( "" );
401  	}
402  	else if ( StringEqual( p, commentHeader, false ) )
403  	{
404  		#ifdef DEBUG_PARSER
405  			TIXMLA_LOG( "XML parsing Comment\n" );
406  		#endif
407  		returnNode = new TiXmlCommentA();
408  	}
409  	else
410  	{
411  		#ifdef DEBUG_PARSER
412  			TIXMLA_LOG( "XML parsing Unknown\n" );
413  		#endif
414  		returnNode = new TiXmlUnknownA();
415  	}
416  	if ( returnNode )
417  	{
418  		returnNode->parent = this;
419  	}
420  	else
421  	{
422  		if ( doc )
423  			doc->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, 0, 0 );
424  	}
425  	return returnNode;
426  }
427  #ifdef TIXMLA_USE_STL
428  void TiXmlElementA::StreamIn (TIXMLA_ISTREAM * in, TIXMLA_STRING * tag)
429  {
430  	while ( in->good() )
431  	{
432  		int c = in->get();
433  		(*tag) += static_cast<char>(c);
434  		if ( c == '>' )
435  			break;
436  	}
437  	if ( tag->length() < 3 ) return;
438  	if (    tag->at( tag->length() - 1 ) == '>' 
439  		 && tag->at( tag->length() - 2 ) == '/' )
440  	{
441  		return;
442  	}
443  	else if ( tag->at( tag->length() - 1 ) == '>' )
444  	{
445  		for ( ;; )
446  		{
447  			StreamWhiteSpace( in, tag );
448  			if ( in->good() && in->peek() != '<' ) 
449  			{
450  				TiXmlTextA text( "" );
451  				text.StreamIn( in, tag );
452  				continue;
453  			}
454  			if ( !in->good() ) return;
455  			assert( in->peek() == '<' );
456  			size_t tagIndex = tag->length();
457  			bool closingTag = false;
458  			bool firstCharFound = false;
459  			for ( ;; )
460  			{
461  				if ( !in->good() )
462  					return;
463  				int c = in->peek();
464  				if ( c == '>' )
465  					break;
466  				*tag += static_cast<char>(c);
467  				in->get();
468  				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
469  				{
470  					firstCharFound = true;
471  					if ( c == '/' )
472  						closingTag = true;
473  				}
474  			}
475  			if ( closingTag )
476  			{
477  				int c = in->get();
478  				assert( c == '>' );
479  				*tag += static_cast<char>(c);
480  				return;
481  			}
482  			else
483  			{
484  				const char* tagloc = tag->c_str() + tagIndex;
485  				TiXmlNodeA* node = Identify( tagloc );
486  				if ( !node )
487  					return;
488  				node->StreamIn( in, tag );
489  				delete node;
490  				node = 0;
491  			}
492  		}
493  	}
494  }
495  #endif
496  const char* TiXmlElementA::Parse( const char* p, TiXmlParsingDataA* data )
497  {
498  	p = SkipWhiteSpace( p );
499  	TiXmlDocumentA* document = GetDocument();
500  	if ( !p || !*p )
501  	{
502  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, 0, 0 );
503  		return 0;
504  	}
505  	if ( data )
506  	{
507  		data->Stamp( p );
508  		location = data->Cursor();
509  	}
510  	if ( *p != '<' )
511  	{
512  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, p, data );
513  		return 0;
514  	}
515  	p = SkipWhiteSpace( p+1 );
516  	const char* pErr = p;
517      p = ReadName( p, &value );
518  	if ( !p || !*p )
519  	{
520  		if ( document )	document->SetError( TIXMLA_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data );
521  		return 0;
522  	}
523      TIXMLA_STRING endTag ("</");
524  	endTag += value;
525  	endTag += ">";
526  	while ( p && *p )
527  	{
528  		pErr = p;
529  		p = SkipWhiteSpace( p );
530  		if ( !p || !*p )
531  		{
532  			if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, pErr, data );
533  			return 0;
534  		}
535  		if ( *p == '/' )
536  		{
537  			++p;
538  			if ( *p  != '>' )
539  			{
540  				if ( document ) document->SetError( TIXMLA_ERROR_PARSING_EMPTY, p, data );		
541  				return 0;
542  			}
543  			return (p+1);
544  		}
545  		else if ( *p == '>' )
546  		{
547  			++p;
548  			p = ReadValue( p, data );		
549  			if ( !p || !*p )
550  				return 0;
551  			if ( StringEqual( p, endTag.c_str(), false ) )
552  			{
553  				p += endTag.length();
554  				return p;
555  			}
556  			else
557  			{
558  				if ( document ) document->SetError( TIXMLA_ERROR_READING_END_TAG, p, data );
559  				return 0;
560  			}
561  		}
562  		else
563  		{
564  			TiXmlAttributeA* attrib = new TiXmlAttributeA();
565  			if ( !attrib )
566  			{
567  				if ( document ) document->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, pErr, data );
568  				return 0;
569  			}
570  			attrib->SetDocument( document );
571  			const char* pErr = p;
572  			p = attrib->Parse( p, data );
573  			if ( !p || !*p )
574  			{
575  				if ( document ) document->SetError( TIXMLA_ERROR_PARSING_ELEMENT, pErr, data );
576  				delete attrib;
577  				return 0;
578  			}
579  			TiXmlAttributeA* node = attributeSet.Find( attrib->Name() );
580  			if ( node )
581  			{
582  				node->SetValue( attrib->Value() );
583  				delete attrib;
584  				return 0;
585  			}
586  			attributeSet.Add( attrib );
587  		}
588  	}
589  	return p;
590  }
591  const char* TiXmlElementA::ReadValue( const char* p, TiXmlParsingDataA* data )
592  {
593  	TiXmlDocumentA* document = GetDocument();
594  	p = SkipWhiteSpace( p );
595  	while ( p && *p )
596  	{
597  		if ( *p != '<' )
598  		{
599  			TiXmlTextA* textNode = new TiXmlTextA( "" );
600  			if ( !textNode )
601  			{
602  				if ( document ) document->SetError( TIXMLA_ERROR_OUT_OF_MEMORY, 0, 0 );
603  				    return 0;
604  			}
605  			p = textNode->Parse( p, data );
606  			if ( !textNode->Blank() )
607  				LinkEndChild( textNode );
608  			else
609  				delete textNode;
610  		} 
611  		else 
612  		{
613  			if ( StringEqual( p, "</", false ) )
614  			{
615  				return p;
616  			}
617  			else
618  			{
619  				TiXmlNodeA* node = Identify( p );
620  				if ( node )
621  				{
622  					p = node->Parse( p, data );
623  					LinkEndChild( node );
624  				}				
625  				else
626  				{
627  					return 0;
628  				}
629  			}
630  		}
631  		p = SkipWhiteSpace( p );
632  	}
633  	if ( !p )
634  	{
635  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ELEMENT_VALUE, 0, 0 );
636  	}	
637  	return p;
638  }
639  #ifdef TIXMLA_USE_STL
640  void TiXmlUnknownA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
641  {
642  	while ( in->good() )
643  	{
644  		int c = in->get();	
645  		(*tag) += static_cast<char>(c);
646  		if ( c == '>' )
647  		{
648  			return;		
649  		}
650  	}
651  }
652  #endif
653  const char* TiXmlUnknownA::Parse( const char* p, TiXmlParsingDataA* data )
654  {
655  	TiXmlDocumentA* document = GetDocument();
656  	p = SkipWhiteSpace( p );
657  	if ( data )
658  	{
659  		data->Stamp( p );
660  		location = data->Cursor();
661  	}
662  	if ( !p || !*p || *p != '<' )
663  	{
664  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_UNKNOWN, p, data );
665  		return 0;
666  	}
667  	++p;
668      value = "";
669  	while ( p && *p && *p != '>' )
670  	{
671  		value += *p;
672  		++p;
673  	}
674  	if ( !p )
675  	{
676  		if ( document )	document->SetError( TIXMLA_ERROR_PARSING_UNKNOWN, 0, 0 );
677  	}
678  	if ( *p == '>' )
679  		return p+1;
680  	return p;
681  }
682  #ifdef TIXMLA_USE_STL
683  void TiXmlCommentA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
684  {
685  	while ( in->good() )
686  	{
687  		int c = in->get();	
688  		(*tag) += static_cast<char>(c);
689  		if ( c == '>' 
690  			 && tag->at( tag->length() - 2 ) == '-'
691  			 && tag->at( tag->length() - 3 ) == '-' )
692  		{
693  			return;		
694  		}
695  	}
696  }
697  #endif
698  const char* TiXmlCommentA::Parse( const char* p, TiXmlParsingDataA* data )
699  {
700  	TiXmlDocumentA* document = GetDocument();
701  	value = "";
702  	p = SkipWhiteSpace( p );
703  	if ( data )
704  	{
705  		data->Stamp( p );
706  		location = data->Cursor();
707  	}
708  	const char* startTag = "<!--";
709  	const char* endTag   = "-->";
710  	if ( !StringEqual( p, startTag, false ) )
711  	{
712  		document->SetError( TIXMLA_ERROR_PARSING_COMMENT, p, data );
713  		return 0;
714  	}
715  	p += strlen( startTag );
716  	p = ReadText( p, &value, false, endTag, false );
717  	return p;
718  }
719  const char* TiXmlAttributeA::Parse( const char* p, TiXmlParsingDataA* data )
720  {
721  	p = SkipWhiteSpace( p );
722  	if ( !p || !*p ) return 0;
723  	if ( data )
724  	{
725  		data->Stamp( p );
726  		location = data->Cursor();
727  	}
728  	const char* pErr = p;
729  	p = ReadName( p, &name );
730  	if ( !p || !*p )
731  	{
732  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, pErr, data );
733  		return 0;
734  	}
735  	p = SkipWhiteSpace( p );
736  	if ( !p || !*p || *p != '=' )
737  	{
738  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, p, data );
739  		return 0;
740  	}
741  	++p;	
742  	p = SkipWhiteSpace( p );
743  	if ( !p || !*p )
744  	{
745  		if ( document ) document->SetError( TIXMLA_ERROR_READING_ATTRIBUTES, p, data );
746  		return 0;
747  	}
748  	const char* end;
749  	if ( *p == '\'' )
750  	{
751  		++p;
752  		end = "\'";
753  		p = ReadText( p, &value, false, end, false );
754  	}
755  	else if ( *p == '"' )
756  	{
757  		++p;
758  		end = "\"";
759  		p = ReadText( p, &value, false, end, false );
760  	}
761  	else
762  	{
763  		value = "";
764  		while (    p && *p										
765  				&& !isspace( *p ) && *p != '\n' && *p != '\r'	
766  				&& *p != '/' && *p != '>' )						
767  		{
768  			value += *p;
769  			++p;
770  		}
771  	}
772  	return p;
773  }
774  #ifdef TIXMLA_USE_STL
775  void TiXmlTextA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
776  {
777  	while ( in->good() )
778  	{
779  		int c = in->peek();	
780  		if ( c == '<' )
781  			return;
782  		(*tag) += static_cast<char>(c);
783  		in->get();
784  	}
785  }
786  #endif
787  const char* TiXmlTextA::Parse( const char* p, TiXmlParsingDataA* data )
788  {
789  	value = "";
790  	if ( data )
791  	{
792  		data->Stamp( p );
793  		location = data->Cursor();
794  	}
795  	bool ignoreWhite = true;
796  	const char* end = "<";
797  	p = ReadText( p, &value, ignoreWhite, end, false );
798  	if ( p )
799  		return p-1;	
800  	return 0;
801  }
802  #ifdef TIXMLA_USE_STL
803  void TiXmlDeclarationA::StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag )
804  {
805  	while ( in->good() )
806  	{
807  		int c = in->get();
808  		(*tag) += static_cast<char>(c);
809  		if ( c == '>' )
810  		{
811  			return;
812  		}
813  	}
814  }
815  #endif
816  const char* TiXmlDeclarationA::Parse( const char* p, TiXmlParsingDataA* data )
817  {
818  	p = SkipWhiteSpace( p );
819  	TiXmlDocumentA* document = GetDocument();
820  	if ( !p || !*p || !StringEqual( p, "<?xml", true ) )
821  	{
822  		if ( document ) document->SetError( TIXMLA_ERROR_PARSING_DECLARATION, 0, 0 );
823  		return 0;
824  	}
825  	if ( data )
826  	{
827  		data->Stamp( p );
828  		location = data->Cursor();
829  	}
830  	p += 5;
831  	version = "";
832  	encoding = "";
833  	standalone = "";
834  	while ( p && *p )
835  	{
836  		if ( *p == '>' )
837  		{
838  			++p;
839  			return p;
840  		}
841  		p = SkipWhiteSpace( p );
842  		if ( StringEqual( p, "version", true ) )
843  		{
844  			TiXmlAttributeA attrib;
845  			p = attrib.Parse( p, data );		
846  			version = attrib.Value();
847  		}
848  		else if ( StringEqual( p, "encoding", true ) )
849  		{
850  			TiXmlAttributeA attrib;
851  			p = attrib.Parse( p, data );		
852  			encoding = attrib.Value();
853  		}
854  		else if ( StringEqual( p, "standalone", true ) )
855  		{
856  			TiXmlAttributeA attrib;
857  			p = attrib.Parse( p, data );		
858  			standalone = attrib.Value();
859  		}
860  		else
861  		{
862  			while ( p && *p && *p != '>' && !isspace( *p ) )
863  				++p;
864  		}
865  	}
866  	return 0;
867  }
868  bool TiXmlTextA::Blank() const
869  {
870  	for ( size_t i = 0, len = value.length(); i < len; i++ )
871  		if ( !isspace( value[i] ) )
872  			return false;
873  	return true;
874  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlparser.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlparserA.cpp</div>
                </div>
                <div class="column column_space"><pre><code>362  	p = SkipWhiteSpace( p );
363  	if ( !p || !*p || *p != '<' )
364  	{
365  		return 0;
</pre></code></div>
                <div class="column column_space"><pre><code>374  	p = SkipWhiteSpace( p );
375  	if ( !p || !*p || *p != '<' )
376  	{
377  		return 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    