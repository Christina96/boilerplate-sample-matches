
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.719298245614035%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-devGraph_v1.2.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  int main(int argc,char* argv[]) {
3    TTableContext Context;
4    Schema TimeS;
5    TimeS.Add(TPair<TStr,TAttrType>("Source",atInt));
6    TimeS.Add(TPair<TStr,TAttrType>("Dest",atInt));
7    TimeS.Add(TPair<TStr,TAttrType>("Start",atInt));
8    TimeS.Add(TPair<TStr,TAttrType>("Duration",atInt));
9    PTable P1 = TTable::LoadSS(TimeS,"./../../../../datasets/temporal/outsms-A.txt",&Context,' ');
10    TIntV MapV;
11    TStrV SortBy;
12    SortBy.Add("Start");
13    P1->Order(SortBy);
14    TIntV Start; 
15    P1->ReadIntCol("Start",Start);
16    TInt SIdx = P1->GetColIdx("Source");
17    TInt DIdx = P1->GetColIdx("Dest");
18    TInt StIdx = P1->GetColIdx("Start");
19    TInt DuIdx = P1->GetColIdx("Duration");
20    int totalCas = 0;
21    int numCas = 0;
22    int W = atoi(argv[1]);
23    int max = 0;
24    clock_t st,et,gt;
25    st = clock();
26    PNGraph Graph = TNGraph::New();
27    for (TRowIterator RI = P1->BegRI(); RI < P1-> EndRI(); RI++) {
28      Graph->AddNode(RI.GetRowIdx().Val);
29      MapV.Add(RI.GetRowIdx());
30    }
31    for (TRowIterator OI = P1->BegRI(); OI < P1->EndRI(); OI++) {
32      int OIdx = OI.GetRowIdx().Val;
33      int ODest = P1->GetIntValAtRowIdx(DIdx,OIdx).Val;
34      int OStart = P1->GetIntValAtRowIdx(StIdx,OIdx).Val;
35      int ODur = P1->GetIntValAtRowIdx(DuIdx,OIdx).Val;
<span onclick='openModal()' class='match'>36      int val = OStart + ODur;
37      int lo = 0;
38      int hi = Start.Len() - 1;
39      int index = -1;
40      if (val >= Start.GetVal(hi)) { val = Start.GetVal(hi);}
</span>41      while (hi >= lo) {
42        int mid = lo + (hi - lo)/2;
43        if (Start.GetVal(mid) > val) {
44          if (mid - 1 >= lo and Start.GetVal(mid - 1) < val) { index = mid - 1;break;}
45          hi = mid - 1;
46        }
47        else if (Start.GetVal(mid) < val) {
48          if (mid + 1 <= hi and Start.GetVal(mid + 1) > val) { index = mid;break;}
49          lo = mid + 1;
50        }
51        else { index = mid; hi = mid - 1;}
52      }
53      int BIdx = index;
54      for(int i = BIdx; i < Start.Len(); i++) {
55        int InIdx = MapV.GetVal(i).Val;
56        if (InIdx == OIdx) {continue;}
57        int InSource = P1->GetIntValAtRowIdx(SIdx,InIdx).Val;
58        int InStart = P1->GetIntValAtRowIdx(StIdx,InIdx).Val;
59        if (InStart - (ODur + OStart) > W) { break;}
60        if (InSource == ODest && InStart >= (ODur + OStart)) {
61          if (!Graph->IsEdge(OIdx,InIdx)) {
62            Graph->AddEdge(OIdx,InIdx);
63          }
64        }      
65      }
66    }
67    gt = clock();
68    float diffG = ((float)gt - (float)st)/CLOCKS_PER_SEC; 
69    printf("graph Gen: %f,Edges: %d \n",diffG,Graph->GetEdges());
70    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
71      if (NI.GetInDeg() != 0) { continue;}
72      TSnapQueue<TInt> EventQ;
73      THashSet<TInt> VisitedH;
74      EventQ.Push(NI.GetId());
75      VisitedH.AddKey(NI.GetId());
76      while (! EventQ.Empty()) {
77        TNGraph::TNodeI CNI = Graph->GetNI(EventQ.Top().Val); 
78        EventQ.Pop();
79        for (int e = 0; e < CNI.GetOutDeg(); e++) {
80          if ( !VisitedH.IsKey(CNI.GetOutNId(e))) {
81            EventQ.Push(CNI.GetOutNId(e));
82            VisitedH.AddKey(CNI.GetOutNId(e));
83          }
84        }
85      }
86      if (VisitedH.Len() > 1) { numCas++; totalCas += VisitedH.Len();}
87      if (VisitedH.Len() > max) { max = VisitedH.Len();}
88    }
89    et = clock();
90    float diff = ((float)et - (float)st)/CLOCKS_PER_SEC;
91    printf("Total: %d,numCas: %d,max: %d,graph Gen: %f,total time: %f,Edges: %d\n",totalCas,numCas,max,diffG,diff,Graph->GetEdges());
92    return 0;
93  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-poisson_distribution_test.cc</h3>
            <pre><code>1  #include "absl/random/poisson_distribution.h"
2  #include <algorithm>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iterator>
6  #include <random>
7  #include <sstream>
8  #include <string>
9  #include <vector>
10  #include "gmock/gmock.h"
11  #include "gtest/gtest.h"
12  #include "absl/base/macros.h"
13  #include "absl/container/flat_hash_map.h"
14  #include "absl/log/log.h"
15  #include "absl/random/internal/chi_square.h"
16  #include "absl/random/internal/distribution_test_util.h"
17  #include "absl/random/internal/pcg_engine.h"
18  #include "absl/random/internal/sequence_urbg.h"
19  #include "absl/random/random.h"
20  #include "absl/strings/str_cat.h"
21  #include "absl/strings/str_format.h"
22  #include "absl/strings/str_replace.h"
23  #include "absl/strings/strip.h"
24  namespace {
25  using absl::random_internal::kChiSquared;
26  template <typename IntType>
27  class PoissonDistributionInterfaceTest : public ::testing::Test {};
28  using IntTypes = ::testing::Types<int, int8_t, int16_t, int32_t, int64_t,
29                                    uint8_t, uint16_t, uint32_t, uint64_t>;
30  TYPED_TEST_SUITE(PoissonDistributionInterfaceTest, IntTypes);
31  TYPED_TEST(PoissonDistributionInterfaceTest, SerializeTest) {
32    using param_type = typename absl::poisson_distribution<TypeParam>::param_type;
33    const double kMax =
34        std::min(1e10 &bsol;* assertion limit */,
35                 static_cast<double>(std::numeric_limits<TypeParam>::max()));
36    const double kParams[] = {
37        1,                         
38        std::nextafter(1.0, 0.0),  
39        std::nextafter(1.0, 2.0),  
40        1e-8, 1e-4,
41        0.0000005,  
42        0.2,        
43        0.5,        
44        2,          
45        20,         
46        100, 1e4, 1e8, 1.5e9, 1e20,
47        std::numeric_limits<double>::max(),
48        std::numeric_limits<double>::epsilon(),
49        std::nextafter(std::numeric_limits<double>::min(),
50                       1.0),                        
51        std::numeric_limits<double>::min(),         
52        std::numeric_limits<double>::denorm_min(),  
53        std::numeric_limits<double>::min() / 2,     
54        std::nextafter(std::numeric_limits<double>::min(),
55                       0.0),  
56    };
57    constexpr int kCount = 1000;
58    absl::InsecureBitGen gen;
59    for (const double m : kParams) {
60      const double mean = std::min(kMax, m);
61      const param_type param(mean);
62      absl::poisson_distribution<TypeParam> before(mean);
63      EXPECT_EQ(before.mean(), param.mean());
64      {
65        absl::poisson_distribution<TypeParam> via_param(param);
66        EXPECT_EQ(via_param, before);
67        EXPECT_EQ(via_param.param(), before.param());
68      }
69      auto sample_min = before.max();
70      auto sample_max = before.min();
71      for (int i = 0; i < kCount; i++) {
72        auto sample = before(gen);
73        EXPECT_GE(sample, before.min());
74        EXPECT_LE(sample, before.max());
75        if (sample > sample_max) sample_max = sample;
76        if (sample < sample_min) sample_min = sample;
77      }
78      LOG(INFO) << "Range {" << param.mean() << "}: " << sample_min << ", "
79                << sample_max;
80      std::stringstream ss;
81      ss << before;
82      absl::poisson_distribution<TypeParam> after(3.8);
83      EXPECT_NE(before.mean(), after.mean());
84      EXPECT_NE(before.param(), after.param());
85      EXPECT_NE(before, after);
86      ss >> after;
87      EXPECT_EQ(before.mean(), after.mean())  
88          << ss.str() << " "                  
89          << (ss.good() ? "good " : "")       
90          << (ss.bad() ? "bad " : "")         
91          << (ss.eof() ? "eof " : "")         
92          << (ss.fail() ? "fail " : "");
93    }
94  }
95  class PoissonModel {
96   public:
97    explicit PoissonModel(double mean) : mean_(mean) {}
98    double mean() const { return mean_; }
99    double variance() const { return mean_; }
100    double stddev() const { return std::sqrt(variance()); }
101    double skew() const { return 1.0 / mean_; }
102    double kurtosis() const { return 3.0 + 1.0 / mean_; }
103    void InitCDF();
104    struct CDF {
105      size_t index;
106      double pmf;
107      double cdf;
108    };
109    CDF InverseCDF(double p) {
110      CDF target{0, 0, p};
111      auto it = std::upper_bound(
112          std::begin(cdf_), std::end(cdf_), target,
113          [](const CDF& a, const CDF& b) { return a.cdf < b.cdf; });
114      return *it;
115    }
116    void LogCDF() {
117      LOG(INFO) << "CDF (mean = " << mean_ << ")";
118      for (const auto c : cdf_) {
119        LOG(INFO) << c.index << ": pmf=" << c.pmf << " cdf=" << c.cdf;
120      }
121    }
122   private:
123    const double mean_;
124    std::vector<CDF> cdf_;
125  };
126  void PoissonModel::InitCDF() {
127    if (!cdf_.empty()) {
128      return;
129    }
130    ABSL_ASSERT(mean_ < 201.0);
131    const size_t max_i = 50 * stddev() + mean();
<span onclick='openModal()' class='match'>132    const double e_neg_mean = std::exp(-mean());
133    ABSL_ASSERT(e_neg_mean > 0);
134    double d = 1;
135    double last_result = e_neg_mean;
136    double cumulative = e_neg_mean;
137    if (e_neg_mean > 1e-10) {
</span>138      cdf_.push_back({0, e_neg_mean, cumulative});
139    }
140    for (size_t i = 1; i < max_i; i++) {
141      d *= (mean() / i);
142      double result = e_neg_mean * d;
143      cumulative += result;
144      if (result < 1e-10 && result < last_result && cumulative > 0.999999) {
145        break;
146      }
147      if (result > 1e-7) {
148        cdf_.push_back({i, result, cumulative});
149      }
150      last_result = result;
151    }
152    ABSL_ASSERT(!cdf_.empty());
153  }
154  struct ZParam {
155    double mean;
156    double p_fail;   
157    int trials;      
158    size_t samples;  
159  };
160  class PoissonDistributionZTest : public testing::TestWithParam<ZParam>,
161                                   public PoissonModel {
162   public:
163    PoissonDistributionZTest() : PoissonModel(GetParam().mean) {}
164    template <typename D>
165    bool SingleZTest(const double p, const size_t samples);
166    absl::random_internal::pcg64_2018_engine rng_{0x2B7E151628AED2A6};
167  };
168  template <typename D>
169  bool PoissonDistributionZTest::SingleZTest(const double p,
170                                             const size_t samples) {
171    D dis(mean());
172    absl::flat_hash_map<int32_t, int> buckets;
173    std::vector<double> data;
174    data.reserve(samples);
175    for (int j = 0; j < samples; j++) {
176      const auto x = dis(rng_);
177      buckets[x]++;
178      data.push_back(x);
179    }
180    const auto m = absl::random_internal::ComputeDistributionMoments(data);
181    const double max_err = absl::random_internal::MaxErrorTolerance(p);
182    const double z = absl::random_internal::ZScore(mean(), m);
183    const bool pass = absl::random_internal::Near("z", z, 0.0, max_err);
184    if (!pass) {
185      LOG(INFO)
186          << "p=" << p << " max_err=" << max_err << "\n"
187             " mean=" << m.mean << " vs. " << mean() << "\n"
188             " stddev=" << std::sqrt(m.variance) << " vs. " << stddev() << "\n"
189             " skewness=" << m.skewness << " vs. " << skew() << "\n"
190             " kurtosis=" << m.kurtosis << " vs. " << kurtosis() << "\n"
191             " z=" << z;
192    }
193    return pass;
194  }
195  TEST_P(PoissonDistributionZTest, AbslPoissonDistribution) {
196    const auto& param = GetParam();
197    const int expected_failures =
198        std::max(1, static_cast<int>(std::ceil(param.trials * param.p_fail)));
199    const double p = absl::random_internal::RequiredSuccessProbability(
200        param.p_fail, param.trials);
201    int failures = 0;
202    for (int i = 0; i < param.trials; i++) {
203      failures +=
204          SingleZTest<absl::poisson_distribution<int32_t>>(p, param.samples) ? 0
205                                                                             : 1;
206    }
207    EXPECT_LE(failures, expected_failures);
208  }
209  std::vector<ZParam> GetZParams() {
210    return std::vector<ZParam>({
211        ZParam{0.5, 0.01, 100, 1000},
212        ZParam{1.0, 0.01, 100, 1000},
213        ZParam{10.0, 0.01, 100, 5000},
214        ZParam{20.0, 0.01, 100, 10000},
215        ZParam{50.0, 0.01, 100, 10000},
216        ZParam{51.0, 0.01, 100, 10000},
217        ZParam{200.0, 0.05, 10, 100000},
218        ZParam{100000.0, 0.05, 10, 1000000},
219    });
220  }
221  std::string ZParamName(const ::testing::TestParamInfo<ZParam>& info) {
222    const auto& p = info.param;
223    std::string name = absl::StrCat("mean_", absl::SixDigits(p.mean));
224    return absl::StrReplaceAll(name, {{"+", "_"}, {"-", "_"}, {".", "_"}});
225  }
226  INSTANTIATE_TEST_SUITE_P(All, PoissonDistributionZTest,
227                           ::testing::ValuesIn(GetZParams()), ZParamName);
228  class PoissonDistributionChiSquaredTest : public testing::TestWithParam<double>,
229                                            public PoissonModel {
230   public:
231    PoissonDistributionChiSquaredTest() : PoissonModel(GetParam()) {}
232    template <typename D>
233    double ChiSquaredTestImpl();
234   private:
235    void InitChiSquaredTest(const double buckets);
236    std::vector<size_t> cutoffs_;
237    std::vector<double> expected_;
238    absl::random_internal::pcg64_2018_engine rng_{0x2B7E151628AED2A6};
239  };
240  void PoissonDistributionChiSquaredTest::InitChiSquaredTest(
241      const double buckets) {
242    if (!cutoffs_.empty() && !expected_.empty()) {
243      return;
244    }
245    InitCDF();
246    double last_cdf = 0;
247    const double inc = 1.0 / buckets;
248    for (double p = inc; p <= 1.0; p += inc) {
249      auto result = InverseCDF(p);
250      if (!cutoffs_.empty() && cutoffs_.back() == result.index) {
251        continue;
252      }
253      double d = result.cdf - last_cdf;
254      cutoffs_.push_back(result.index);
255      expected_.push_back(d);
256      last_cdf = result.cdf;
257    }
258    cutoffs_.push_back(std::numeric_limits<size_t>::max());
259    expected_.push_back(std::max(0.0, 1.0 - last_cdf));
260  }
261  template <typename D>
262  double PoissonDistributionChiSquaredTest::ChiSquaredTestImpl() {
263    const int kSamples = 2000;
264    const int kBuckets = 50;
265    ABSL_ASSERT(mean() <= 200);
266    InitChiSquaredTest(kBuckets);
267    D dis(mean());
268    std::vector<int32_t> counts(cutoffs_.size(), 0);
269    for (int j = 0; j < kSamples; j++) {
270      const size_t x = dis(rng_);
271      auto it = std::lower_bound(std::begin(cutoffs_), std::end(cutoffs_), x);
272      counts[std::distance(cutoffs_.begin(), it)]++;
273    }
274    std::vector<int32_t> e(expected_.size(), 0);
275    for (int i = 0; i < e.size(); i++) {
276      e[i] = kSamples * expected_[i];
277    }
278    const int dof = static_cast<int>(counts.size()) - 1;
279    const double threshold = absl::random_internal::ChiSquareValue(dof, 0.98);
280    const double chi_square = absl::random_internal::ChiSquare(
281        std::begin(counts), std::end(counts), std::begin(e), std::end(e));
282    const double p = absl::random_internal::ChiSquarePValue(chi_square, dof);
283    if (chi_square > threshold) {
284      LogCDF();
285      LOG(INFO) << "VALUES  buckets=" << counts.size()
286                << "  samples=" << kSamples;
287      for (size_t i = 0; i < counts.size(); i++) {
288        LOG(INFO) << cutoffs_[i] << ": " << counts[i] << " vs. E=" << e[i];
289      }
290      LOG(INFO) << kChiSquared << "(data, dof=" << dof << ") = " << chi_square
291                << " (" << p << ")\n"
292                << " vs.\n"
293                << kChiSquared << " @ 0.98 = " << threshold;
294    }
295    return p;
296  }
297  TEST_P(PoissonDistributionChiSquaredTest, AbslPoissonDistribution) {
298    const int kTrials = 20;
299    ASSERT_LE(mean(), 200.0);
300    if (mean() > 200.0) {
301      return;
302    }
303    int failures = 0;
304    for (int i = 0; i < kTrials; i++) {
305      double p_value = ChiSquaredTestImpl<absl::poisson_distribution<int32_t>>();
306      if (p_value < 0.005) {
307        failures++;
308      }
309    }
310    EXPECT_LE(failures, 4);
311  }
312  INSTANTIATE_TEST_SUITE_P(All, PoissonDistributionChiSquaredTest,
313                           ::testing::Values(0.5, 1.0, 2.0, 10.0, 50.0, 51.0,
314                                             200.0));
315  TEST(PoissonDistributionTest, StabilityTest) {
316    using testing::ElementsAre;
317    absl::random_internal::sequence_urbg urbg({
318        0x035b0dc7e0a18acfull, 0x06cebe0d2653682eull, 0x0061e9b23861596bull,
319        0x0003eb76f6f7f755ull, 0xFFCEA50FDB2F953Bull, 0xC332DDEFBE6C5AA5ull,
320        0x6558218568AB9702ull, 0x2AEF7DAD5B6E2F84ull, 0x1521B62829076170ull,
321        0xECDD4775619F1510ull, 0x13CCA830EB61BD96ull, 0x0334FE1EAA0363CFull,
322        0xB5735C904C70A239ull, 0xD59E9E0BCBAADE14ull, 0xEECC86BC60622CA7ull,
323        0x4864f22c059bf29eull, 0x247856d8b862665cull, 0xe46e86e9a1337e10ull,
324        0xd8c8541f3519b133ull, 0xe75b5162c567b9e4ull, 0xf732e5ded7009c5bull,
325        0xb170b98353121eacull, 0x1ec2e8986d2362caull, 0x814c8e35fe9a961aull,
326        0x0c3cd59c9b638a02ull, 0xcb3bb6478a07715cull, 0x1224e62c978bbc7full,
327        0x671ef2cb04e81f6eull, 0x3c1cbd811eaf1808ull, 0x1bbc23cfa8fac721ull,
328        0xa4c2cda65e596a51ull, 0xb77216fad37adf91ull, 0x836d794457c08849ull,
329        0xe083df03475f49d7ull, 0xbc9feb512e6b0d6cull, 0xb12d74fdd718c8c5ull,
330        0x12ff09653bfbe4caull, 0x8dd03a105bc4ee7eull, 0x5738341045ba0d85ull,
331        0xf3fd722dc65ad09eull, 0xfa14fd21ea2a5705ull, 0xffe6ea4d6edb0c73ull,
332        0xD07E9EFE2BF11FB4ull, 0x95DBDA4DAE909198ull, 0xEAAD8E716B93D5A0ull,
333        0xD08ED1D0AFC725E0ull, 0x8E3C5B2F8E7594B7ull, 0x8FF6E2FBF2122B64ull,
334        0x8888B812900DF01Cull, 0x4FAD5EA0688FC31Cull, 0xD1CFF191B3A8C1ADull,
335        0x2F2F2218BE0E1777ull, 0xEA752DFE8B021FA1ull, 0xE5A0CC0FB56F74E8ull,
336        0x18ACF3D6CE89E299ull, 0xB4A84FE0FD13E0B7ull, 0x7CC43B81D2ADA8D9ull,
337        0x165FA26680957705ull, 0x93CC7314211A1477ull, 0xE6AD206577B5FA86ull,
338        0xC75442F5FB9D35CFull, 0xEBCDAF0C7B3E89A0ull, 0xD6411BD3AE1E7E49ull,
339        0x00250E2D2071B35Eull, 0x226800BB57B8E0AFull, 0x2464369BF009B91Eull,
340        0x5563911D59DFA6AAull, 0x78C14389D95A537Full, 0x207D5BA202E5B9C5ull,
341        0x832603766295CFA9ull, 0x11C819684E734A41ull, 0xB3472DCA7B14A94Aull,
342    });
343    std::vector<int> output(10);
344    {
345      absl::poisson_distribution<int> dist(5);
346      std::generate(std::begin(output), std::end(output),
347                    [&] { return dist(urbg); });
348    }
349    EXPECT_THAT(output,  
350                ElementsAre(1, 0, 0, 4, 2, 10, 3, 3, 7, 12));
351    {
352      urbg.reset();
353      absl::poisson_distribution<int> dist(25);
354      std::generate(std::begin(output), std::end(output),
355                    [&] { return dist(urbg); });
356    }
357    EXPECT_THAT(output,  
358                ElementsAre(9, 35, 18, 10, 35, 18, 10, 35, 18, 10));
359    {
360      urbg.reset();
361      absl::poisson_distribution<int> dist(121);
362      std::generate(std::begin(output), std::end(output),
363                    [&] { return dist(urbg); });
364    }
365    EXPECT_THAT(output,  
366                ElementsAre(161, 122, 129, 124, 112, 112, 117, 120, 130, 114));
367  }
368  TEST(PoissonDistributionTest, AlgorithmExpectedValue_1) {
369    absl::random_internal::sequence_urbg urbg({0x8000000000000001ull});
370    absl::poisson_distribution<int> dist(5);
371    EXPECT_EQ(7, dist(urbg));
372  }
373  TEST(PoissonDistributionTest, AlgorithmExpectedValue_2) {
374    absl::random_internal::sequence_urbg urbg({0x8000000000000001ull});
375    absl::poisson_distribution<int> dist(25);
376    EXPECT_EQ(36, dist(urbg));
377  }
378  TEST(PoissonDistributionTest, AlgorithmExpectedValue_3) {
379    absl::random_internal::sequence_urbg urbg(
380        {0x7fffffffffffffffull, 0x8000000000000000ull});
381    absl::poisson_distribution<int> dist(121);
382    EXPECT_EQ(121, dist(urbg));
383  }
384  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-devGraph_v1.2.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-poisson_distribution_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>36      int val = OStart + ODur;
37      int lo = 0;
38      int hi = Start.Len() - 1;
39      int index = -1;
40      if (val >= Start.GetVal(hi)) { val = Start.GetVal(hi);}
</pre></code></div>
                <div class="column column_space"><pre><code>132    const double e_neg_mean = std::exp(-mean());
133    ABSL_ASSERT(e_neg_mean > 0);
134    double d = 1;
135    double last_result = e_neg_mean;
136    double cumulative = e_neg_mean;
137    if (e_neg_mean > 1e-10) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    