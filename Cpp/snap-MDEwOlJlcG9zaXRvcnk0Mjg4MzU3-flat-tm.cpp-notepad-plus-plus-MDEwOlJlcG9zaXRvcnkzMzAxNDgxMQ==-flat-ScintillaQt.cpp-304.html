
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tm.cpp</h3>
            <pre><code>1  bool TTmInfo::InitP=false;
2  TStrV TTmInfo::UsMonthNmV;
3  TStrV TTmInfo::SiMonthNmV;
4  TStrV TTmInfo::UsDayOfWeekNmV;
5  TStrV TTmInfo::SiDayOfWeekNmV;
6  void TTmInfo::InitMonthNmV(){
7    UsMonthNmV.Add(&quot;jan&quot;); UsMonthNmV.Add(&quot;feb&quot;); UsMonthNmV.Add(&quot;mar&quot;);
8    UsMonthNmV.Add(&quot;apr&quot;); UsMonthNmV.Add(&quot;may&quot;); UsMonthNmV.Add(&quot;jun&quot;);
9    UsMonthNmV.Add(&quot;jul&quot;); UsMonthNmV.Add(&quot;aug&quot;); UsMonthNmV.Add(&quot;sep&quot;);
10    UsMonthNmV.Add(&quot;oct&quot;); UsMonthNmV.Add(&quot;nov&quot;); UsMonthNmV.Add(&quot;dec&quot;);
11    IAssert(UsMonthNmV.Len()==12);
12    SiMonthNmV.Add(&quot;jan&quot;); SiMonthNmV.Add(&quot;feb&quot;); SiMonthNmV.Add(&quot;mar&quot;);
13    SiMonthNmV.Add(&quot;apr&quot;); SiMonthNmV.Add(&quot;maj&quot;); SiMonthNmV.Add(&quot;jun&quot;);
14    SiMonthNmV.Add(&quot;jul&quot;); SiMonthNmV.Add(&quot;avg&quot;); SiMonthNmV.Add(&quot;sep&quot;);
15    SiMonthNmV.Add(&quot;okt&quot;); SiMonthNmV.Add(&quot;nov&quot;); SiMonthNmV.Add(&quot;dec&quot;);
16    IAssert(SiMonthNmV.Len()==12);
17  }
18  void TTmInfo::InitDayOfWeekNmV(){
19    UsDayOfWeekNmV.Add(&quot;sun&quot;); UsDayOfWeekNmV.Add(&quot;mon&quot;);
20    UsDayOfWeekNmV.Add(&quot;tue&quot;); UsDayOfWeekNmV.Add(&quot;wed&quot;);
21    UsDayOfWeekNmV.Add(&quot;thu&quot;); UsDayOfWeekNmV.Add(&quot;fri&quot;);
22    UsDayOfWeekNmV.Add(&quot;sat&quot;);
23    IAssert(UsDayOfWeekNmV.Len()==7);
24    SiDayOfWeekNmV.Add(&quot;ned&quot;); SiDayOfWeekNmV.Add(&quot;pon&quot;);
25    SiDayOfWeekNmV.Add(&quot;tor&quot;); SiDayOfWeekNmV.Add(&quot;sre&quot;);
26    SiDayOfWeekNmV.Add(&quot;cet&quot;); SiDayOfWeekNmV.Add(&quot;pet&quot;);
27    SiDayOfWeekNmV.Add(&quot;sob&quot;);
28    IAssert(SiDayOfWeekNmV.Len()==7);
29  }
30  int TTmInfo::GetMonthN(const TStr&amp; MonthNm, const TLoc&amp; Loc){
31    EnsureInit();
32    int MonthN=-1;
33    switch (Loc){
34      case lUs: MonthN=UsMonthNmV.SearchForw(MonthNm.GetLc()); break;
35      case lSi: MonthN=SiMonthNmV.SearchForw(MonthNm.GetLc()); break;
36      default: Fail;
37    }
38    if (MonthN==-1){return -1;} else {return MonthN+1;}
39  }
40  TStr TTmInfo::GetMonthNm(const int&amp; MonthN, const TLoc&amp; Loc){
41    EnsureInit();
42    IAssert((1&lt;=MonthN)&amp;&amp;(MonthN&lt;=12));
43    switch (Loc){
44      case lUs: return UsMonthNmV[MonthN-1];
45      case lSi: return SiMonthNmV[MonthN-1];
46      default: Fail; return TStr();
47    }
48  }
49  int TTmInfo::GetDayOfWeekN(const TStr&amp; DayOfWeekNm, const TLoc&amp; Loc){
50    EnsureInit();
51    int DayOfWeekN=-1;
52    switch (Loc){
53      case lUs: DayOfWeekN=UsDayOfWeekNmV.SearchForw(DayOfWeekNm.GetLc()); break;
54      case lSi: DayOfWeekN=SiDayOfWeekNmV.SearchForw(DayOfWeekNm.GetLc()); break;
55      default: Fail;
56    }
57    if (DayOfWeekN==-1){return -1;} else {return DayOfWeekN+1;}
58  }
59  TStr TTmInfo::GetDayOfWeekNm(const int&amp; DayOfWeekN, const TLoc&amp; Loc){
60    EnsureInit();
61    IAssert((1&lt;=DayOfWeekN)&amp;&amp;(DayOfWeekN&lt;=7));
62    switch (Loc){
63      case lUs: return UsDayOfWeekNmV[DayOfWeekN-1];
64      case lSi: return SiDayOfWeekNmV[DayOfWeekN-1];
65      default: Fail; return TStr();
66    }
67  }
68  TStr TTmInfo::GetHmFromMins(const int&amp; Mins){
69    return TInt::GetStr(Mins/60, &quot;%02d&quot;)+&quot;:&quot;+TInt::GetStr(Mins%60, &quot;%02d&quot;);
70  }
71  int TTmInfo::GetTmUnitSecs(const TTmUnit&amp; TmUnit) {
72    switch(TmUnit) {
73      case tmuYear : return 365*24*3600;
74      case tmuMonth : return 31*24*3600;
75      case tmuWeek : return 7*24*3600;
76      case tmuDay : return 24*3600;
77      case tmu12Hour : return 12*3600;
78      case tmu6Hour : return 6*3600;
79      case tmu4Hour : return 4*3600;
80      case tmu2Hour : return 2*3600;
81      case tmu1Hour : return 1*3600;
82      case tmu30Min : return 30*60;
83      case tmu15Min : return 15*60;
84      case tmu10Min : return 10*60;
85      case tmu1Min : return 60;
86      case tmu1Sec : return 1;
87      case tmuNodes : Fail;
88      case tmuEdges : Fail;
89      default: Fail;
90    }
91    return -1;
92  }
93  TStr TTmInfo::GetTmUnitStr(const TTmUnit&amp; TmUnit) {
94    switch(TmUnit) {
95      case tmuYear : return &quot;Year&quot;;
96      case tmuMonth : return &quot;Month&quot;;
97      case tmuWeek : return &quot;Week&quot;;
98      case tmuDay : return &quot;Day&quot;;
99      case tmu12Hour : return &quot;12 Hours&quot;;
100      case tmu6Hour : return &quot;6 Hours&quot;;
101      case tmu4Hour : return &quot;4 Hours&quot;;
102      case tmu2Hour : return &quot;2 Hours&quot;;
103      case tmu1Hour : return &quot;1 Hour&quot;;
104      case tmu30Min : return &quot;30 Minutes&quot;;
105      case tmu15Min : return &quot;15 Minutes&quot;;
106      case tmu10Min : return &quot;10 Minutes&quot;;
107      case tmu1Min : return &quot;Minute&quot;;
108      case tmu1Sec : return &quot;Second&quot;;
109      case tmuNodes : return &quot;Nodes&quot;;
110      case tmuEdges : return &quot;Edges&quot;;
111      default: Fail;
112    }
113    return TStr::GetNullStr();
114  }
115  TStr TTmInfo::GetTmZoneDiffStr(const TStr&amp; TmZoneStr){
116    if (TmZoneStr==&quot;A&quot;){&amp;bsol;* Alpha Time Zone Military*/ return &quot;+1000&quot;;}
117    if (TmZoneStr==&quot;ACDT&quot;){&amp;bsol;* Australian Central Daylight Time	Australia */ return &quot;+1030&quot;;}
118    if (TmZoneStr==&quot;ACST&quot;){&amp;bsol;* Australian Central Standard Time	Australia */ return &quot;+0930&quot;;}
119    if (TmZoneStr==&quot;ADT&quot;){&amp;bsol;* Atlantic Daylight Time	North America */ return &quot;-0300&quot;;}
120    if (TmZoneStr==&quot;AEDT&quot;){&amp;bsol;* Australian Eastern Daylight Time or Australian Eastern Summer Time	Australia */ return &quot;+1100&quot;;}
121    if (TmZoneStr==&quot;AEST&quot;){&amp;bsol;* Australian Eastern Standard Time	Australia */ return &quot;+1000&quot;;}
122    if (TmZoneStr==&quot;AKDT&quot;){&amp;bsol;* Alaska Daylight Time	North America */ return &quot;-0800&quot;;}
123    if (TmZoneStr==&quot;AKST&quot;){&amp;bsol;* Alaska Standard Time	North America */ return &quot;-0900&quot;;}
124    if (TmZoneStr==&quot;AST&quot;){&amp;bsol;* Atlantic Standard Time	North America */ return &quot;-0400&quot;;}
125    if (TmZoneStr==&quot;AWDT&quot;){&amp;bsol;* Australian Western Daylight Time	Australia */ return &quot;+0900&quot;;}
126    if (TmZoneStr==&quot;AWST&quot;){&amp;bsol;* Australian Western Standard Time	Australia */ return &quot;+0800&quot;;}
127    if (TmZoneStr==&quot;B&quot;){&amp;bsol;* Bravo Time Zone	Military */ return &quot;+0200&quot;;}
128    if (TmZoneStr==&quot;BST&quot;){&amp;bsol;* British Summer Time	Europe */ return &quot;+0100&quot;;}
129    if (TmZoneStr==&quot;C&quot;){&amp;bsol;* Charlie Time Zone	Military */ return &quot;+0300&quot;;}
130    if (TmZoneStr==&quot;CDT&quot;){&amp;bsol;* Central Daylight Time	North America */ return &quot;-0500&quot;;}
131    if (TmZoneStr==&quot;CDT&quot;){&amp;bsol;* Central Daylight Time	Australia */ return &quot;+1030&quot;;}
132    if (TmZoneStr==&quot;CEDT&quot;){&amp;bsol;* Central European Daylight Time	Europe */ return &quot;+0200&quot;;}
133    if (TmZoneStr==&quot;CEST&quot;){&amp;bsol;* Central European Summer Time	Europe */ return &quot;+0200&quot;;}
134    if (TmZoneStr==&quot;CET&quot;){&amp;bsol;* Central European Time	Europe */ return &quot;+0100&quot;;}
135    if (TmZoneStr==&quot;CST&quot;){&amp;bsol;* Central Standard Time	North America */ return &quot;-0600&quot;;}
136    if (TmZoneStr==&quot;CST&quot;){&amp;bsol;* Central Summer Time	Australia */ return &quot;+1030&quot;;}
137    if (TmZoneStr==&quot;CST&quot;){&amp;bsol;* Central Standard Time	Australia */ return &quot;+0930&quot;;}
138    if (TmZoneStr==&quot;CXT&quot;){&amp;bsol;* Christmas Island Time	Australia */ return &quot;+0700&quot;;}
139    if (TmZoneStr==&quot;D&quot;){&amp;bsol;* Delta Time Zone	Military */ return &quot;+0400&quot;;}
140    if (TmZoneStr==&quot;E&quot;){&amp;bsol;* Echo Time Zone	Military */ return &quot;+0500&quot;;}
141    if (TmZoneStr==&quot;EDT&quot;){&amp;bsol;* Eastern Daylight Time	North America */ return &quot;-0400&quot;;}
142    if (TmZoneStr==&quot;EDT&quot;){&amp;bsol;* Eastern Daylight Time	Australia */ return &quot;+1100&quot;;}
143    if (TmZoneStr==&quot;EEDT&quot;){&amp;bsol;* Eastern European Daylight Time	Europe */ return &quot;+0300&quot;;}
144    if (TmZoneStr==&quot;EEST&quot;){&amp;bsol;* Eastern European Summer Time	Europe */ return &quot;+0300&quot;;}
145    if (TmZoneStr==&quot;EET&quot;){&amp;bsol;* Eastern European Time	Europe */ return &quot;+0200&quot;;}
146    if (TmZoneStr==&quot;EST&quot;){&amp;bsol;* Eastern Standard Time	North America */ return &quot;-0500&quot;;}
147    if (TmZoneStr==&quot;EST&quot;){&amp;bsol;* Eastern Summer Time	Australia */ return &quot;+1100&quot;;}
148    if (TmZoneStr==&quot;EST&quot;){&amp;bsol;* Eastern Standard Time	Australia */ return &quot;+1000&quot;;}
149    if (TmZoneStr==&quot;F&quot;){&amp;bsol;* Foxtrot Time Zone	Military */ return &quot;+0600&quot;;}
150    if (TmZoneStr==&quot;G&quot;){&amp;bsol;* Golf Time Zone	Military */ return &quot;+0700&quot;;}
151    if (TmZoneStr==&quot;GMT&quot;){&amp;bsol;* Greenwich Mean Time	Europe */ return &quot;+0000&quot;;}
152    if (TmZoneStr==&quot;H&quot;){&amp;bsol;* Hotel Time Zone	Military */ return &quot;+0800&quot;;}
153    if (TmZoneStr==&quot;HAA&quot;){&amp;bsol;* Heure Avancee de l&#x27;Atlantique	North America */ return &quot;-0300&quot;;}
154    if (TmZoneStr==&quot;HAC&quot;){&amp;bsol;* Heure Avancee du Centre	North America */ return &quot;-0500&quot;;}
155    if (TmZoneStr==&quot;HADT&quot;){&amp;bsol;* Hawaii-Aleutian Daylight Time	North America */ return &quot;-0900&quot;;}
156    if (TmZoneStr==&quot;HAE&quot;){&amp;bsol;* Heure Avancee de l&#x27;Est	North America */ return &quot;-0400&quot;;}
157    if (TmZoneStr==&quot;HAP&quot;){&amp;bsol;* Heure Avancee du Pacifique	North America */ return &quot;-0700&quot;;}
158    if (TmZoneStr==&quot;HAR&quot;){&amp;bsol;* Heure Avancee des Rocheuses	North America */ return &quot;-0600&quot;;}
159    if (TmZoneStr==&quot;HAST&quot;){&amp;bsol;* Hawaii-Aleutian Standard Time	North America */ return &quot;-1000&quot;;}
160    if (TmZoneStr==&quot;HAT&quot;){&amp;bsol;* Heure Avancee de Terre-Neuve	North America */ return &quot;-0230&quot;;}
161    if (TmZoneStr==&quot;HAY&quot;){&amp;bsol;* Heure Avancee du Yukon	North America */ return &quot;-0800&quot;;}
162    if (TmZoneStr==&quot;HNA&quot;){&amp;bsol;* Heure Normale de l&#x27;Atlantique	North America */ return &quot;-0400&quot;;}
163    if (TmZoneStr==&quot;HNC&quot;){&amp;bsol;* Heure Normale du Centre	North America */ return &quot;-0600&quot;;}
164    if (TmZoneStr==&quot;HNE&quot;){&amp;bsol;* Heure Normale de l&#x27;Est	North America */ return &quot;-0500&quot;;}
165    if (TmZoneStr==&quot;HNP&quot;){&amp;bsol;* Heure Normale du Pacifique	North America */ return &quot;-0800&quot;;}
166    if (TmZoneStr==&quot;HNR&quot;){&amp;bsol;* Heure Normale des Rocheuses	North America */ return &quot;-0700&quot;;}
167    if (TmZoneStr==&quot;HNT&quot;){&amp;bsol;* Heure Normale de Terre-Neuve	North America */ return &quot;-0330&quot;;}
168    if (TmZoneStr==&quot;HNY&quot;){&amp;bsol;* Heure Normale du Yukon	North America */ return &quot;-0900&quot;;}
169    if (TmZoneStr==&quot;I&quot;){&amp;bsol;* India Time Zone	Military */ return &quot;+0900&quot;;}
170    if (TmZoneStr==&quot;IST&quot;){&amp;bsol;* Irish Summer Time	Europe */ return &quot;+0100&quot;;}
171    if (TmZoneStr==&quot;K&quot;){&amp;bsol;* Kilo Time Zone	Military */ return &quot;+1000&quot;;}
172    if (TmZoneStr==&quot;L&quot;){&amp;bsol;* Lima Time Zone	Military */ return &quot;+1100&quot;;}
173    if (TmZoneStr==&quot;M&quot;){&amp;bsol;* Mike Time Zone	Military */ return &quot;+1200&quot;;}
174    if (TmZoneStr==&quot;MDT&quot;){&amp;bsol;* Mountain Daylight Time	North America */ return &quot;-0600&quot;;}
175    if (TmZoneStr==&quot;MESZ&quot;){&amp;bsol;* Mitteleuropeische Sommerzeit	Europe */ return &quot;+0200&quot;;}
176    if (TmZoneStr==&quot;MEZ&quot;){&amp;bsol;* Mitteleuropeische Zeit	Europe */ return &quot;+0100&quot;;}
177    if (TmZoneStr==&quot;MSD&quot;){&amp;bsol;* Moscow Daylight Time	Europe */ return &quot;+0400&quot;;}
178    if (TmZoneStr==&quot;MSK&quot;){&amp;bsol;* Moscow Standard Time	Europe */ return &quot;+0300&quot;;}
179    if (TmZoneStr==&quot;MST&quot;){&amp;bsol;* Mountain Standard Time	North America */ return &quot;-0700&quot;;}
180    if (TmZoneStr==&quot;N&quot;){&amp;bsol;* November Time Zone	Military */ return &quot;-0100&quot;;}
181    if (TmZoneStr==&quot;NDT&quot;){&amp;bsol;* Newfoundland Daylight Time	North America */ return &quot;-0230&quot;;}
182    if (TmZoneStr==&quot;NFT&quot;){&amp;bsol;* Norfolk (Island) Time	Australia */ return &quot;+ 11:30&quot;;}
183    if (TmZoneStr==&quot;NST&quot;){&amp;bsol;* Newfoundland Standard Time	North America */ return &quot;-0330&quot;;}
184    if (TmZoneStr==&quot;O&quot;){&amp;bsol;* Oscar Time Zone	Military */ return &quot;-0200&quot;;}
185    if (TmZoneStr==&quot;P&quot;){&amp;bsol;* Papa Time Zone	Military */ return &quot;-0300&quot;;}
186    if (TmZoneStr==&quot;PDT&quot;){&amp;bsol;* Pacific Daylight Time	North America */ return &quot;-0700&quot;;}
187    if (TmZoneStr==&quot;PST&quot;){&amp;bsol;* Pacific Standard Time	North America */ return &quot;-0800&quot;;}
188    if (TmZoneStr==&quot;Q&quot;){&amp;bsol;* Quebec Time Zone	Military */ return &quot;-0400&quot;;}
189    if (TmZoneStr==&quot;R&quot;){&amp;bsol;* Romeo Time Zone	Military */ return &quot;-0500&quot;;}
190    if (TmZoneStr==&quot;S&quot;){&amp;bsol;* Sierra Time Zone	Military */ return &quot;-0600&quot;;}
191    if (TmZoneStr==&quot;T&quot;){&amp;bsol;* Tango Time Zone	Military */ return &quot;-0700&quot;;}
192    if (TmZoneStr==&quot;U&quot;){&amp;bsol;* Uniform Time Zone	Military */ return &quot;-0800&quot;;}
193    if (TmZoneStr==&quot;UTC&quot;){&amp;bsol;* Coordinated Universal Time Europe */ return &quot;+0000&quot;;}
194    if (TmZoneStr==&quot;V&quot;){&amp;bsol;* Victor Time Zone	Military */ return &quot;-0900&quot;;}
195    if (TmZoneStr==&quot;W&quot;){&amp;bsol;* Whiskey Time Zone	Military */ return &quot;-1000&quot;;}
196    if (TmZoneStr==&quot;WDT&quot;){&amp;bsol;* Western Daylight Time	Australia */ return &quot;+0900&quot;;}
197    if (TmZoneStr==&quot;WEDT&quot;){&amp;bsol;* Western European Daylight Time	Europe */ return &quot;+0100&quot;;}
198    if (TmZoneStr==&quot;WEST&quot;){&amp;bsol;* Western European Summer Time	Europe */ return &quot;+0100&quot;;}
199    if (TmZoneStr==&quot;WET&quot;){&amp;bsol;* Western European Time	Europe */ return &quot;+0000&quot;;}
200    if (TmZoneStr==&quot;WST&quot;){&amp;bsol;* Western Summer Time	Australia */ return &quot;+0900&quot;;}
201    if (TmZoneStr==&quot;WST&quot;){&amp;bsol;* Western Standard Time	Australia */ return &quot;+0800&quot;;}
202    if (TmZoneStr==&quot;X&quot;){&amp;bsol;* X-ray Time Zone	Military */ return &quot;-1100&quot;;}
203    if (TmZoneStr==&quot;Y&quot;){&amp;bsol;* Yankee Time Zone	Military */ return &quot;-1200&quot;;}
204    if (TmZoneStr==&quot;Z&quot;){&amp;bsol;* Zulu Time Zone	Military */ return &quot;+0000&quot;;}
205    return &quot;-0000&quot;;
206  }
207  const int TTmInfo::SunN=1; const int TTmInfo::MonN=2;
208  const int TTmInfo::TueN=3; const int TTmInfo::WedN=4;
209  const int TTmInfo::ThuN=5; const int TTmInfo::FriN=6;
210  const int TTmInfo::SatN=7;
211  const int TTmInfo::JanN=1; const int TTmInfo::FebN=2;
212  const int TTmInfo::MarN=3; const int TTmInfo::AprN=4;
213  const int TTmInfo::MayN=5; const int TTmInfo::JunN=6;
214  const int TTmInfo::JulN=7; const int TTmInfo::AugN=8;
215  const int TTmInfo::SepN=9; const int TTmInfo::OctN=10;
216  const int TTmInfo::NovN=11; const int TTmInfo::DecN=12;
217  int TJulianDate::LastJulianDate=15821004; &amp;bsol;* last day to use Julian calendar */
218  int TJulianDate::LastJulianDateN=2299160; &amp;bsol;* jdn of same */
219  int TJulianDate::GetJulianDateN(int d, int m, int y){
220    IAssert(y != 0);
221    int julian = -1;
222    long jdn;
223    if (julian &lt; 0){ &amp;bsol;* set Julian flag if auto set */
224      julian = (((y * 100L) + m) * 100 + d  &lt;=  LastJulianDate);}
225    if (y &lt; 0){ &amp;bsol;* adjust BC year */
226      y++;}
227    if (julian){
228      jdn = 367L * y - 7 * (y + 5001L + (m - 9) / 7) / 4
229       + 275 * m / 9 + d + 1729777L;
230    } else {
231      jdn = (long)(d - 32076)
232       + 1461L * (y + 4800L + (m - 14) / 12) / 4
233       + 367 * (m - 2 - (m - 14) / 12 * 12) / 12
234       - 3 * ((y + 4900L + (m - 14) / 12) / 100) / 4
235       + 1;            &amp;bsol;* correction by rdg */
236    }
237    return (int) jdn;
238  }
239  void TJulianDate::GetCalendarDate(int jdn, int&amp; dd, int&amp; mm, int&amp; yy){
240    int julian = -1;
241    long x, z, m, d, y;
242    long daysPer400Years = 146097L;
243    long fudgedDaysPer4000Years = 1460970L + 31;
244    if (julian &lt; 0){ &amp;bsol;* set Julian flag if auto set */
245      julian = (jdn &lt;= LastJulianDateN);}
246    x = jdn + 68569L;
247    if (julian){
248      x+=38;
249      daysPer400Years = 146100L;
250      fudgedDaysPer4000Years = 1461000L + 1;
251    }
252    z = 4 * x / daysPer400Years;
253    x = x - (daysPer400Years * z + 3) / 4;
254    y = 4000 * (x + 1) / fudgedDaysPer4000Years;
255    x = x - 1461 * y / 4 + 31;
256    m = 80 * x / 2447;
257    d = x - 2447 * m / 80;
258    x = m / 11;
259    m = m + 2 - 12 * x;
260    y = 100 * (z - 49) + y + x;
261    yy = (int)y;
262    mm = (int)m;
263    dd = (int)d;
264    if (yy &lt;= 0){ &amp;bsol;* adjust BC years */
265     (yy)--;}
266  }
267  bool TSecTm::GetTmSec(const int&amp; YearN, const int&amp; MonthN, const int&amp; DayN, const int&amp; HourN, const int&amp; MinN, const int&amp; SecN, uint&amp; AbsSec) {
268    AbsSec = 0;
269    struct tm Tm;
270    Tm.tm_year=YearN-1900; Tm.tm_mon=MonthN-1; Tm.tm_mday=DayN;
271    Tm.tm_hour=HourN; Tm.tm_min=MinN; Tm.tm_sec=SecN;
272    Tm.tm_wday=1;  Tm.tm_yday=1;
273    Tm.tm_isdst=-1;
274    return TSecTm::GetTmSec(Tm, AbsSec);
275  }
276  time_t TSecTm::MkGmTime(struct tm *t) {
277    static const int m_to_d[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
278    short month, year;
279    time_t result;
280    month = t-&gt;tm_mon;
281    year = t-&gt;tm_year + month / 12 + 1900;
282    month %= 12;
283    if (month &lt; 0) {
284      year -= 1;
285      month += 12; }
286    result = (year - 1970) * 365 + (year - 1969) / 4 + m_to_d[month];
287    result = (year - 1970) * 365 + m_to_d[month];
288    if (month &lt;= 1) { year -= 1; }
289    result += (year - 1968) / 4;
290    result -= (year - 1900) / 100;
291    result += (year - 1600) / 400;
292    result += t-&gt;tm_mday;
293    result -= 1;
294    result *= 24;
295    result += t-&gt;tm_hour;
296    result *= 60;
297    result += t-&gt;tm_min;
298    result *= 60;
299    result += t-&gt;tm_sec;
300    return result;
301  }
302  bool TSecTm::GetTmSec(struct tm&amp; Tm, uint&amp; AbsSec) {
303    const time_t GmtTime = MkGmTime(&amp;Tm);
304    EAssertR(uint(GmtTime) &lt; TUInt::Mx,
305      TStr::Fmt(&quot;Time out of range: %d/%d/%d %02d:%02d:%02d&quot;,
306      Tm.tm_year, Tm.tm_mon, Tm.tm_mday, Tm.tm_hour, Tm.tm_min, Tm.tm_sec).CStr());
307    AbsSec = uint(GmtTime);
308    return GmtTime &gt;= 0;
309  }
310  bool TSecTm::GetTmStruct(const uint&amp; AbsSec, struct tm&amp; Tm) {
311    const time_t TimeT = time_t(AbsSec);
312    #if defined(GLib_MSC)
313    return _gmtime64_s(&amp;Tm, &amp;TimeT) == 0;
314    #elif defined(GLib_BCB)
315    Tm=*gmtime(&amp;TimeT); return true;
316    #else
317    return gmtime_r(&amp;TimeT, &amp;Tm) != NULL;
318    #endif
319  }
320  TSecTm::TSecTm(const int&amp; YearN, const int&amp; MonthN, const int&amp; DayN,
321   const int&amp; HourN, const int&amp; MinN, const int&amp; SecN) : AbsSecs(TUInt::Mx){
322    GetTmSec(YearN, MonthN, DayN, HourN, MinN, SecN, AbsSecs.Val);
323  }
324  TSecTm::TSecTm(const TTm&amp; Tm): AbsSecs(
325   TSecTm(Tm.GetYear(), Tm.GetMonth(), Tm.GetDay(), Tm.GetHour(),
326     Tm.GetMin(), Tm.GetSec()).GetAbsSecs()) { }
327  TSecTm::TSecTm(const PXmlTok&amp; XmlTok) {
328    const int Year = XmlTok-&gt;GetIntArgVal(&quot;Year&quot;);
329    const int Month = XmlTok-&gt;GetIntArgVal(&quot;Month&quot;);
330    const int Day = XmlTok-&gt;GetIntArgVal(&quot;Day&quot;);
331    const int Hour = XmlTok-&gt;GetIntArgVal(&quot;Hour&quot;);
332    const int Min = XmlTok-&gt;GetIntArgVal(&quot;Min&quot;);
333    const int Sec = XmlTok-&gt;GetIntArgVal(&quot;Sec&quot;);
334    AbsSecs = TSecTm(Year, Month, Day, Hour, Min, Sec).GetAbsSecs();
335  }
336  PXmlTok TSecTm::GetXmlTok() const {
337    PXmlTok NodeTok = TXmlTok::New(&quot;NodeTime&quot;);
338    NodeTok-&gt;AddArg(&quot;Year&quot;, GetYearN());
339    NodeTok-&gt;AddArg(&quot;Month&quot;, GetMonthN());
340    NodeTok-&gt;AddArg(&quot;Day&quot;, GetDayN());
341    NodeTok-&gt;AddArg(&quot;Hour&quot;, GetHourN());
342    NodeTok-&gt;AddArg(&quot;Min&quot;, GetMinN());
343    NodeTok-&gt;AddArg(&quot;Sec&quot;, GetSecN());
344    return NodeTok;
345  }
346  TStr TSecTm::GetStr(const TLoc&amp; Loc) const {
347    if (IsDef()) {
348      struct tm Tm;
349      IAssert(GetTmStruct(AbsSecs(), Tm));
350      return TStr::Fmt(&quot;%s %s %d %02d:%02d:%02d %d&quot;,
351        TTmInfo::GetDayOfWeekNm(Tm.tm_wday + 1, Loc).CStr(),
352        TTmInfo::GetMonthNm(Tm.tm_mon + 1, Loc).CStr(),
353        Tm.tm_mday, Tm.tm_hour, Tm.tm_min, Tm.tm_sec, Tm.tm_year+1900);
354    } else {
355      return &quot;Undef&quot;;
356    }
357  }
358  TStr TSecTm::GetStr(const TTmUnit&amp; TmUnit) const {
359    if (TmUnit == tmuYear) {
360      return TInt::GetStr(GetYearN()); }
361    else if (TmUnit == tmuMonth) {
362      return TStr::Fmt(&quot;%04d-%02d&quot;, GetYearN(), GetMonthN()); }
363    else if (TmUnit == tmuDay) {
364      return TStr::Fmt(&quot;%04d-%02d-%02d&quot;, GetYearN(), GetMonthN(), GetDayN()); }
365    else {
366      return TStr::Fmt(&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;,
367        GetYearN(), GetMonthN(), GetDayN(), GetHourN(), GetMinN(), GetSecN());
368    }
369  }
<span onclick='openModal()' class='match'>370  TStr TSecTm::GetDtStr(const TLoc&amp; Loc) const {
371    if (IsDef()){
372      struct tm Tm;
</span>373      IAssert(GetTmStruct(AbsSecs(), Tm));
374      return TStr::Fmt(&quot;%s %s %d %d&quot;,
375        TTmInfo::GetDayOfWeekNm(Tm.tm_wday + 1, Loc).CStr(),
376        TTmInfo::GetMonthNm(Tm.tm_mon + 1, Loc).CStr(), Tm.tm_year+1900);
377    } else {
378      return &quot;Undef&quot;;
379    }
380  }
381  TStr TSecTm::GetDtMdyStr() const {
382    struct tm Tm;
383    IAssert(GetTmStruct(AbsSecs(), Tm));
384    return TStr::Fmt(&quot;%02d/%02d%/%04d&quot;, Tm.tm_mon+1, Tm.tm_mday, Tm.tm_year+1900);
385  }
386  TStr TSecTm::GetDtYmdStr() const {
387    struct tm Tm;
388    IAssert(GetTmStruct(AbsSecs(), Tm));
389    return TStr::Fmt(&quot;%04d-%02d-%02d&quot;, Tm.tm_year+1900, Tm.tm_mon+1, Tm.tm_mday);
390  }
391  TStr TSecTm::GetYmdTmStr() const {
392    struct tm Tm;
393    IAssert(GetTmStruct(AbsSecs(), Tm));
394    return TStr::Fmt(&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, Tm.tm_year+1900, Tm.tm_mon+1, Tm.tm_mday, Tm.tm_hour, Tm.tm_min, Tm.tm_sec);
395  }
396  TStr TSecTm::GetYmdTmStr2() const {
397    struct tm Tm;
398    IAssert(GetTmStruct(AbsSecs(), Tm));
399    return TStr::Fmt(&quot;%04d-%02d-%02d-%02d:%02d:%02d&quot;, Tm.tm_year+1900, Tm.tm_mon+1, Tm.tm_mday, Tm.tm_hour, Tm.tm_min, Tm.tm_sec);
400  }
401  TStr TSecTm::GetTmStr() const {
402    if (IsDef()){
403      struct tm Tm;
404      IAssert(GetTmStruct(AbsSecs(), Tm));
405      return TStr::Fmt(&quot;%02d:%02d:%02d&quot;, Tm.tm_hour, Tm.tm_min, Tm.tm_sec);
406    } else {
407      return &quot;Undef&quot;;
408    }
409  }
410  TStr TSecTm::GetTmMinStr() const {
411    if (IsDef()){
412      struct tm Tm;
413      IAssert(GetTmStruct(AbsSecs(), Tm));
414      return TStr::Fmt(&quot;%02d:%02d&quot;, Tm.tm_min, Tm.tm_sec);
415    } else {
416      return &quot;Undef&quot;;
417    }
418  }
419  TStr TSecTm::GetDtTmSortStr() const {
420    return
421      TInt::GetStr(GetYearN(), &quot;%04d&quot;)+&quot;/&quot;+
422      TInt::GetStr(GetMonthN(), &quot;%02d&quot;)+&quot;/&quot;+
423      TInt::GetStr(GetDayN(), &quot;%02d&quot;)+&quot; &quot;+
424      TInt::GetStr(GetHourN(), &quot;%02d&quot;)+&quot;:&quot;+
425      TInt::GetStr(GetMinN(), &quot;%02d&quot;)+&quot;:&quot;+
426      TInt::GetStr(GetSecN(), &quot;%02d&quot;);
427  }
428  TStr TSecTm::GetDtTmSortFNmStr() const {
429    return
430      TInt::GetStr(GetYearN(), &quot;%04d&quot;)+&quot;-&quot;+
431      TInt::GetStr(GetMonthN(), &quot;%02d&quot;)+&quot;-&quot;+
432      TInt::GetStr(GetDayN(), &quot;%02d&quot;)+&quot;_&quot;+
433      TInt::GetStr(GetHourN(), &quot;%02d&quot;)+&quot;-&quot;+
434      TInt::GetStr(GetMinN(), &quot;%02d&quot;)+&quot;-&quot;+
435      TInt::GetStr(GetSecN(), &quot;%02d&quot;);
436  }
437  int TSecTm::GetYearN() const {
438    struct tm Tm;
439    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
440    return Tm.tm_year+1900;
441  }
442  int TSecTm::GetMonthN() const {
443    struct tm Tm;
444    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
445    return Tm.tm_mon+1;
446  }
447  TStr TSecTm::GetMonthNm(const TLoc&amp; Loc) const {
448    struct tm Tm;
449    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
450    return TTmInfo::GetMonthNm(Tm.tm_mon+1, Loc);
451  }
452  int TSecTm::GetDayN() const {
453    struct tm Tm;
454    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
455    return Tm.tm_mday;
456  }
457  int TSecTm::GetDayOfWeekN() const {
458    struct tm Tm;
459    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
460    return Tm.tm_wday + 1;
461  }
462  TStr TSecTm::GetDayOfWeekNm(const TLoc&amp; Loc) const {
463    struct tm Tm;
464    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
465    return TTmInfo::GetDayOfWeekNm(Tm.tm_wday+1, Loc);
466  }
467  int TSecTm::GetHourN() const {
468    struct tm Tm;
469    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
470    return Tm.tm_hour;
471  }
472  int TSecTm::GetMinN() const {
473    struct tm Tm;
474    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
475    return Tm.tm_min;
476  }
477  int TSecTm::GetSecN() const {
478    struct tm Tm;
479    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
480    return Tm.tm_sec;
481  }
482  void TSecTm::GetComps(int&amp; Year, int&amp; Month, int&amp; Day, int&amp; Hour, int&amp; Min, int&amp; Sec) const {
483    struct tm Tm;
484    EAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Tm));
485    Year = Tm.tm_year+1900;
486    Month = Tm.tm_mon+1;
487    Day = Tm.tm_mday;
488    Hour = Tm.tm_hour;
489    Min = Tm.tm_min;
490    Sec = Tm.tm_sec;
491  }
492  TSecTm TSecTm::Round(const TTmUnit&amp; TmUnit) const {
493    if (TmUnit == tmu1Sec) { return *this; }
494    struct tm Time;
495    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Time));
496    switch (TmUnit) {
497      case tmu1Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, Time.tm_min, 0);
498      case tmu10Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 10*(Time.tm_min/10), 0);
499      case tmu15Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 15*(Time.tm_min/15), 0);
500      case tmu30Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 30*(Time.tm_min/30), 0);
501      case tmu1Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 0, 0);
502      case tmu2Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 2*(Time.tm_hour/2), 0, 0);
503      case tmu4Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 4*(Time.tm_hour/4), 0, 0);
504      case tmu6Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 6*(Time.tm_hour/6), 0, 0);
505      case tmu12Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 12*(Time.tm_hour/12), 0, 0);
506      case tmuDay : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 0, 0, 0);
507      case tmuMonth : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, 1, 0, 0, 0);
508      case tmuYear : return TSecTm(Time.tm_year+1900, 1, 1, 0, 0, 0);
509      case tmuWeek : { int dd=1, mm=1, yy=1;
510        const int Day = TJulianDate::GetJulianDateN(Time.tm_mday, Time.tm_mon+1, 1900+Time.tm_year);
511        TJulianDate::GetCalendarDate(3+7*(Day/7), dd, mm, yy);  return TSecTm(yy, mm, dd, 0, 0, 0); }
512      default : Fail;
513    }
514    return TSecTm();
515  }
516  uint TSecTm::GetInUnits(const TTmUnit&amp; TmUnit) const {
517    static const int DayZero = TJulianDate::GetJulianDateN(1, 1, 1970);
518    if (TmUnit == tmu1Sec) { return AbsSecs; }
519    struct tm Time;
520    IAssert(IsDef() &amp;&amp; GetTmStruct(AbsSecs(), Time));
521    switch (TmUnit) {
522      case tmu1Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, Time.tm_min, 0).GetAbsSecs()/60;
523      case tmu10Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 10*(Time.tm_min/10), 0).GetAbsSecs()/(10*60);
524      case tmu15Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 15*(Time.tm_min/15), 0).GetAbsSecs()/(15*60);
525      case tmu30Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 30*(Time.tm_min/30), 0).GetAbsSecs()/(30*60);
526      case tmu1Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 0, 0).GetAbsSecs()/3600;
527      case tmu2Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 2*(Time.tm_hour/2), 0, 0).GetAbsSecs()/(2*3600);
528      case tmu4Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 4*(Time.tm_hour/4), 0, 0).GetAbsSecs()/(4*3600);
529      case tmu6Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 6*(Time.tm_hour/6), 0, 0).GetAbsSecs()/(6*3600);
530      case tmu12Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 12*(Time.tm_hour/12), 0, 0).GetAbsSecs()/(12*3600);
531      case tmuDay : return TJulianDate::GetJulianDateN(Time.tm_mday, Time.tm_mon+1, 1900+Time.tm_year) - DayZero;
532      case tmuWeek : return (TJulianDate::GetJulianDateN(Time.tm_mday, Time.tm_mon+1, 1900+Time.tm_year)-DayZero)/7;
533      case tmuMonth : return 12*(Time.tm_year-70)+Time.tm_mon+1;
534      case tmuYear : return Time.tm_year+1900;
535      default : Fail;
536    }
537    return TUInt::Mx;
538  }
539  TStr TSecTm::GetDayPart() const {
540    const int Hour = GetHourN();
541    if (0 &lt;= Hour &amp;&amp; Hour &lt; 6) { return &quot;Night&quot;; }
542    else if (6 &lt;= Hour &amp;&amp; Hour &lt; 12) { return &quot;Morning&quot;; }
543    else if (12 &lt;= Hour &amp;&amp; Hour &lt; 18) { return &quot;Afternoon&quot;; }
544    else if (18 &lt;= Hour &amp;&amp; Hour &lt; 24) { return &quot;Evening&quot;; }
545    return &quot;&quot;;
546  }
547  uint TSecTm::GetDSecs(const TSecTm&amp; SecTm1, const TSecTm&amp; SecTm2){
548    IAssert(SecTm1.IsDef()&amp;&amp;SecTm2.IsDef());
549    const time_t Time1= time_t(SecTm1.AbsSecs());
550    const time_t Time2= time_t(SecTm2.AbsSecs());
551    return uint(difftime(Time2, Time1));
552  }
553  TSecTm TSecTm::GetZeroWeekTm(){
554    TSecTm ZeroWeekTm=GetZeroTm();
555    while (ZeroWeekTm.GetDayOfWeekN()!=TTmInfo::MonN){
556      ZeroWeekTm.AddDays(1);}
557    return ZeroWeekTm;
558  }
559  TSecTm TSecTm::GetCurTm(){
560    const time_t TmSec = time(NULL);
561    struct tm LocTm;
562    uint AbsSec = TUInt::Mx;
563    #if defined(GLib_MSN)
564    localtime_s(&amp;LocTm, &amp;TmSec);
565    #elif defined(GLib_BCB)
566    LocTm = *localtime(&amp;TmSec);
567    #else
568    LocTm = *localtime(&amp;TmSec);
569    #endif
570    IAssert(TSecTm::GetTmSec(LocTm, AbsSec));
571    return TSecTm(AbsSec);
572  }
573  TSecTm TSecTm::GetDtTmFromHmsStr(const TStr&amp; HmsStr){
574    int HmsStrLen=HmsStr.Len();
575    TChA ChA; int ChN=0;
576    while ((ChN&lt;HmsStrLen)&amp;&amp;(HmsStr[ChN]!=&#x27;:&#x27;)){ChA+=HmsStr[ChN]; ChN++;}
577    TStr HourStr=ChA;
578    ChA.Clr(); ChN++;
579    while ((ChN&lt;HmsStrLen)&amp;&amp;(HmsStr[ChN]!=&#x27;:&#x27;)){ChA+=HmsStr[ChN]; ChN++;}
580    TStr MinStr=ChA;
581    ChA.Clr(); ChN++;
582    while (ChN&lt;HmsStrLen){ChA+=HmsStr[ChN]; ChN++;}
583    TStr SecStr=ChA;
584    int HourN=HourStr.GetInt();
585    int MinN=MinStr.GetInt();
586    int SecN=SecStr.GetInt();
587    TSecTm Tm=TSecTm::GetZeroTm();
588    Tm.AddHours(HourN);
589    Tm.AddMins(MinN);
590    Tm.AddSecs(SecN);
591    return Tm;
592  }
593  TSecTm TSecTm::GetDtTmFromMdyStr(const TStr&amp; MdyStr){
594    int MdyStrLen=MdyStr.Len();
595    TChA ChA; int ChN=0;
596    while ((ChN&lt;MdyStrLen)&amp;&amp;(MdyStr[ChN]!=&#x27;/&#x27;)){
597      ChA+=MdyStr[ChN]; ChN++;}
598    TStr MonthStr=ChA;
599    ChA.Clr(); ChN++;
600    while ((ChN&lt;MdyStrLen)&amp;&amp;(MdyStr[ChN]!=&#x27;/&#x27;)){
601      ChA+=MdyStr[ChN]; ChN++;}
602    TStr DayStr=ChA;
603    ChA.Clr(); ChN++;
604    while (ChN&lt;MdyStrLen){
605      ChA+=MdyStr[ChN]; ChN++;}
606    TStr YearStr=ChA;
607    int MonthN=MonthStr.GetInt();
608    int DayN=DayStr.GetInt();
609    int YearN=YearStr.GetInt();
610    if (YearN&lt;1000){
611      if (YearN&lt;70){YearN+=2000;} else {YearN+=1900;}}
612    return GetDtTm(YearN, MonthN, DayN);
613  }
614  TSecTm TSecTm::GetDtTmFromDmyStr(const TStr&amp; DmyStr){
615    int DmyStrLen=DmyStr.Len();
616    TChA ChA; int ChN=0;
617    while ((ChN&lt;DmyStrLen)&amp;&amp;(DmyStr[ChN]!=&#x27;/&#x27;)&amp;&amp;(DmyStr[ChN]!=&#x27;-&#x27;)){
618      ChA+=DmyStr[ChN]; ChN++;}
619    TStr DayStr=ChA;
620    ChA.Clr(); ChN++;
621    while ((ChN&lt;DmyStrLen)&amp;&amp;(DmyStr[ChN]!=&#x27;/&#x27;)&amp;&amp;(DmyStr[ChN]!=&#x27;-&#x27;)){
622      ChA+=DmyStr[ChN]; ChN++;}
623    TStr MonthStr=ChA;
624    ChA.Clr(); ChN++;
625    while (ChN&lt;DmyStrLen){
626      ChA+=DmyStr[ChN]; ChN++;}
627    TStr YearStr=ChA;
628    int DayN=DayStr.GetInt(-1);
629    int MonthN=MonthStr.GetInt(-1);
630    int YearN=YearStr.GetInt(-1);
631    if (MonthN == -1){
632      MonthN = TTmInfo::GetMonthN(MonthStr.ToCap()); }
633    if ((DayN==-1)||(MonthN==-1)||(YearN==-1)){
634      return TSecTm();
635    } else {
636      if (YearN&lt;1000){
637        if (YearN&lt;70){YearN+=2000;} else {YearN+=1900;}}
638      return GetDtTm(YearN, MonthN, DayN);
639    }
640    return TSecTm();
641  }
642  TSecTm TSecTm::GetDtTmFromMdyHmsPmStr(const TStr&amp; MdyHmsPmStr,
643   const char&amp; DateSepCh, const char&amp; TimeSepCh){
644    int MdyHmsPmStrLen=MdyHmsPmStr.Len();
645    TChA ChA; int ChN=0;
646    while ((ChN&lt;MdyHmsPmStrLen)&amp;&amp;(MdyHmsPmStr[ChN]!=DateSepCh)){
647      ChA+=MdyHmsPmStr[ChN]; ChN++;}
648    TStr MonthStr=ChA;
649    ChA.Clr(); ChN++;
650    while ((ChN&lt;MdyHmsPmStrLen)&amp;&amp;(MdyHmsPmStr[ChN]!=DateSepCh)){
651      ChA+=MdyHmsPmStr[ChN]; ChN++;}
652    TStr DayStr=ChA;
653    ChA.Clr(); ChN++;
654    while ((ChN&lt;MdyHmsPmStrLen)&amp;&amp;(MdyHmsPmStr[ChN]!=&#x27; &#x27;)){
655      ChA+=MdyHmsPmStr[ChN]; ChN++;}
656    TStr YearStr=ChA;
657    ChA.Clr(); ChN++;
658    while ((ChN&lt;MdyHmsPmStrLen)&amp;&amp;(MdyHmsPmStr[ChN]!=TimeSepCh)){
659      ChA+=MdyHmsPmStr[ChN]; ChN++;}
660    TStr HourStr=ChA;
661    ChA.Clr(); ChN++;
662    while ((ChN&lt;MdyHmsPmStrLen)&amp;&amp;(MdyHmsPmStr[ChN]!=TimeSepCh)){
663      ChA+=MdyHmsPmStr[ChN]; ChN++;}
664    TStr MinStr=ChA;
665    ChA.Clr(); ChN++;
666    while ((ChN&lt;MdyHmsPmStrLen)&amp;&amp;(MdyHmsPmStr[ChN]!=&#x27; &#x27;)){
667      ChA+=MdyHmsPmStr[ChN]; ChN++;}
668    TStr SecStr=ChA;
669    ChA.Clr(); ChN++;
670    while (ChN&lt;MdyHmsPmStrLen){
671      ChA+=MdyHmsPmStr[ChN]; ChN++;}
672    TStr AmPmStr=ChA;
673    int MonthN=MonthStr.GetInt();
674    int DayN=DayStr.GetInt();
675    int YearN=YearStr.GetInt();
676    int HourN; int MinN; int SecN;
677    if (HourStr.IsInt()){
678      HourN=HourStr.GetInt();
679      MinN=MinStr.GetInt();
680      SecN=SecStr.GetInt();
681      if (AmPmStr==&quot;AM&quot;){} else if (AmPmStr==&quot;PM&quot;){HourN+=12;} else {Fail;}
682    } else {
683      HourN=0; MinN=0; SecN=0;
684    }
685    TSecTm Tm=TSecTm::GetDtTm(YearN, MonthN, DayN);
686    Tm.AddHours(HourN);
687    Tm.AddMins(MinN);
688    Tm.AddSecs(SecN);
689    return Tm;
690  }
691  TSecTm TSecTm::GetDtTmFromYmdHmsStr(const TStr&amp; YmdHmsPmStr,
692   const char&amp; DateSepCh, const char&amp; TimeSepCh){
693    int YmdHmsPmStrLen=YmdHmsPmStr.Len();
694    TChA ChA; int ChN=0;
695    while ((ChN&lt;YmdHmsPmStrLen)&amp;&amp;(YmdHmsPmStr[ChN]!=DateSepCh)){
696      ChA+=YmdHmsPmStr[ChN]; ChN++;}
697    TStr YearStr=ChA;
698    ChA.Clr(); ChN++;
699    while ((ChN&lt;YmdHmsPmStrLen)&amp;&amp;(YmdHmsPmStr[ChN]!=DateSepCh)){
700      ChA+=YmdHmsPmStr[ChN]; ChN++;}
701    TStr MonthStr=ChA;
702    ChA.Clr(); ChN++;
703    while ((ChN&lt;YmdHmsPmStrLen)&amp;&amp;(YmdHmsPmStr[ChN]!=&#x27; &#x27;)){
704      ChA+=YmdHmsPmStr[ChN]; ChN++;}
705    TStr DayStr=ChA;
706    ChA.Clr(); ChN++;
707    while ((ChN&lt;YmdHmsPmStrLen)&amp;&amp;(YmdHmsPmStr[ChN]!=TimeSepCh)){
708      ChA+=YmdHmsPmStr[ChN]; ChN++;}
709    TStr HourStr=ChA;
710    ChA.Clr(); ChN++;
711    while ((ChN&lt;YmdHmsPmStrLen)&amp;&amp;(YmdHmsPmStr[ChN]!=TimeSepCh)){
712      ChA+=YmdHmsPmStr[ChN]; ChN++;}
713    TStr MinStr=ChA;
714    ChA.Clr(); ChN++;
715    while (ChN&lt;YmdHmsPmStrLen){
716      ChA+=YmdHmsPmStr[ChN]; ChN++;}
717    TStr SecStr=ChA;
718    int MonthN=MonthStr.GetInt();
719    int DayN=DayStr.GetInt();
720    int YearN=YearStr.GetInt();
721    int HourN; int MinN; int SecN;
722    if (HourStr.IsInt()){
723      HourN=HourStr.GetInt();
724      MinN=MinStr.GetInt();
725      SecN=SecStr.GetInt();
726    } else {
727      HourN=0; MinN=0; SecN=0;
728    }
729    TSecTm Tm=TSecTm::GetDtTm(YearN, MonthN, DayN);
730    Tm.AddHours(HourN);
731    Tm.AddMins(MinN);
732    Tm.AddSecs(SecN);
733    return Tm;
734  }
735  TSecTm TSecTm::GetDtTmFromStr(const TChA&amp; YmdHmsPmStr, const int&amp; YearId, const int&amp; MonId,
736   const int&amp; DayId, const int&amp; HourId, const int&amp; MinId, const int&amp; SecId) {
737    TChA Tmp = YmdHmsPmStr;
738    TVec&lt;char *&gt; FldV;
739    for (char *c = (char *) Tmp.CStr(); *c; c++) {
740      if (TCh::IsNum(*c)) {
741        FldV.Add(c);
742        while (TCh::IsNum(*c)) { c++; }
743        c--;
744      } else { *c = 0; }
745    }
746    const int Y = atoi(FldV[YearId]);
747    const int M = atoi(FldV[MonId]);
748    const int D = atoi(FldV[DayId]);
749    const int H = atoi(FldV[HourId]);
750    const int m = atoi(FldV[MinId]);
751    const int S = atoi(FldV[SecId]);
752    IAssert(Y&gt;0 &amp;&amp; M&gt;0 &amp;&amp; D&gt;0 &amp;&amp; M&lt;13 &amp;&amp; D&lt;32);
753    IAssert(H&gt;=0 &amp;&amp; H&lt;24 &amp;&amp; m&gt;=0 &amp;&amp; m&lt;60 &amp;&amp; S&gt;=0 &amp;&amp; S&lt;60);
754    return TSecTm(Y,M,D,H,m,S);
755  }
756  TSecTm TSecTm::GetDtTm(const int&amp; YearN, const int&amp; MonthN, const int&amp; DayN){
757    uint AbsSecs;
758    TSecTm::GetTmSec(YearN, MonthN, DayN, 0, 0, 0, AbsSecs);
759    return TSecTm(AbsSecs);
760  }
761  TSecTm TSecTm::GetDtTm(const TSecTm&amp; Tm){
762    int DaySecs=Tm.GetHourN()*3600+Tm.GetMinN()*60+Tm.GetSecN();
763    TSecTm DtTm(Tm.AbsSecs-DaySecs);
764    return DtTm;
765  }
766  TSecTm TSecTm::LoadTxt(TILx&amp; Lx){
767    return TSecTm(Lx.GetInt());
768  }
769  void TSecTm::SaveTxt(TOLx&amp; Lx) const {
770    IAssert(int(AbsSecs) &lt; TInt::Mx);
771    Lx.PutInt((int)AbsSecs);
772  }
773  TStr TTm::GetStr(const bool&amp; MSecP) const {
774    TChA ChA;
775    ChA+=TInt::GetStr(Year, &quot;%04d&quot;); ChA+=&#x27;-&#x27;;
776    ChA+=TInt::GetStr(Month, &quot;%02d&quot;); ChA+=&#x27;-&#x27;;
777    ChA+=TInt::GetStr(Day, &quot;%02d&quot;); ChA+=&#x27; &#x27;;
778    ChA+=TInt::GetStr(Hour, &quot;%02d&quot;); ChA+=&#x27;:&#x27;;
779    ChA+=TInt::GetStr(Min, &quot;%02d&quot;); ChA+=&#x27;:&#x27;;
780    ChA+=TInt::GetStr(Sec, &quot;%02d&quot;);
781    if (MSecP){ChA+=&#x27;.&#x27;; ChA+=TInt::GetStr(MSec, &quot;%03d&quot;);}
782    return ChA;
783  }
784  TStr TTm::GetYMDDashStr() const {
785    TChA ChA;
786    ChA+=TInt::GetStr(Year, &quot;%04d&quot;);
787    ChA+=&#x27;-&#x27;; ChA+=TInt::GetStr(Month, &quot;%02d&quot;);
788    ChA+=&#x27;-&#x27;; ChA+=TInt::GetStr(Day, &quot;%02d&quot;);
789    return ChA;
790  }
791  TStr TTm::GetHMSTColonDotStr(const bool&amp; FullP, const bool&amp; MSecP) const {
792    TChA ChA;
793    ChA+=TInt::GetStr(Hour, &quot;%02d&quot;);
794    ChA+=&#x27;:&#x27;; ChA+=TInt::GetStr(Min, &quot;%02d&quot;);
795    if (FullP||((Sec!=0)||(MSec!=0))){
796      ChA+=&#x27;:&#x27;; ChA+=TInt::GetStr(Sec, &quot;%02d&quot;);
797      if ((MSecP)&amp;&amp;(FullP||(MSec!=0))){
798        ChA+=&#x27;.&#x27;; ChA+=TInt::GetStr(MSec, &quot;%d&quot;);
799      }
800    }
801    return ChA;
802  }
803  TStr TTm::GetIdStr() const {
804    TChA ChA;
805    ChA+=TInt::GetStr(Year%100, &quot;%02d&quot;);
806    ChA+=TInt::GetStr(Month, &quot;%02d&quot;);
807    ChA+=TInt::GetStr(Day, &quot;%02d&quot;);
808    ChA+=TInt::GetStr(Hour, &quot;%02d&quot;);
809    ChA+=TInt::GetStr(Min, &quot;%02d&quot;);
810    ChA+=TInt::GetStr(Sec, &quot;%02d&quot;);
811    ChA+=TInt::GetStr(MSec, &quot;%03d&quot;);
812    return ChA;
813  }
814  void TTm::AddTime(const int&amp; Hours,
815   const int&amp; Mins, const int&amp; Secs, const int&amp; MSecs){
816    uint64 TmMSecs=TTm::GetMSecsFromTm(*this);
817    TmMSecs+=(uint64(Hours)*uint64(3600)*uint64(1000));
818    TmMSecs+=(uint64(Mins)*uint64(60)*uint64(1000));
819    TmMSecs+=(uint64(Secs)*uint64(1000));
820    TmMSecs+=uint64(MSecs);
821    *this=GetTmFromMSecs(TmMSecs);
822  }
823  void TTm::SubTime(const int&amp; Hours,
824   const int&amp; Mins, const int&amp; Secs, const int&amp; MSecs){
825    uint64 TmMSecs=TTm::GetMSecsFromTm(*this);
826    TmMSecs-=(uint64(Hours)*uint64(3600)*uint64(1000));
827    TmMSecs-=(uint64(Mins)*uint64(60)*uint64(1000));
828    TmMSecs-=(uint64(Secs)*uint64(1000));
829    TmMSecs-=(uint64(MSecs));
830    *this=GetTmFromMSecs(TmMSecs);
831  }
832  TTm TTm::GetCurUniTm(){
833    return TSysTm::GetCurUniTm();
834  }
835  TTm TTm::GetUniqueCurUniTm(){
836    static TTm LastUniqueTm=TSysTm::GetCurUniTm();
837    TTm CurUniqueTm=TSysTm::GetCurUniTm();
838    if (CurUniqueTm&lt;LastUniqueTm){CurUniqueTm=LastUniqueTm;}
839    if (CurUniqueTm==LastUniqueTm){CurUniqueTm.AddTime(0, 0, 0, 1);}
840    LastUniqueTm=CurUniqueTm;
841    return CurUniqueTm;
842  }
843  TTm TTm::GetUniqueCurUniTm(const int&amp; UniqueSpaces, const int&amp; UniqueSpaceN){
844    static uint64 LastMUniqueTmMSecs=TSysTm::GetCurUniMSecs();
845    Assert(UniqueSpaces&gt;=1&amp;&amp;UniqueSpaceN&gt;=0&amp;&amp;UniqueSpaceN&lt;UniqueSpaces);
846    uint64 CurUniqueTmMSecs=TSysTm::GetCurUniMSecs();
847    if (CurUniqueTmMSecs&lt;LastMUniqueTmMSecs){CurUniqueTmMSecs=LastMUniqueTmMSecs;}
848    CurUniqueTmMSecs-=CurUniqueTmMSecs%UniqueSpaces; CurUniqueTmMSecs+=UniqueSpaceN;
849    if (CurUniqueTmMSecs&lt;=LastMUniqueTmMSecs){
850      CurUniqueTmMSecs+=UniqueSpaces;
851    }
852    LastMUniqueTmMSecs=CurUniqueTmMSecs;
853    return GetTmFromMSecs(CurUniqueTmMSecs);
854  }
855  TTm TTm::GetCurLocTm(){
856    return TSysTm::GetCurLocTm();
857  }
858  uint64 TTm::GetCurUniMSecs(){
859    return TSysTm::GetCurUniMSecs();
860  }
861  uint64 TTm::GetCurLocMSecs(){
862    return TSysTm::GetCurLocMSecs();
863  }
864  uint64 TTm::GetMSecsFromTm(const TTm&amp; Tm){
865    return TSysTm::GetMSecsFromTm(Tm);
866  }
867  TTm TTm::GetTmFromMSecs(const uint64&amp; MSecs){
868    return TSysTm::GetTmFromMSecs(MSecs);
869  }
870  uint TTm::GetMSecsFromOsStart(){
871    return TSysTm::GetMSecsFromOsStart();
872  }
873  uint64 TTm::GetPerfTimerFq(){
874    return TSysTm::GetPerfTimerFq();
875  }
876  uint64 TTm::GetPerfTimerTicks(){
877    return TSysTm::GetPerfTimerTicks();
878  }
879  void TTm::GetDiff(const TTm&amp; Tm1, const TTm&amp; Tm2, int&amp; Days, 
880  	  int&amp; Hours, int&amp; Mins, int&amp; Secs, int&amp; MSecs) {
881  	const uint64 DiffMSecs = TTm::GetDiffMSecs(Tm1, Tm2);
882  	const uint64 DiffSecs = DiffMSecs / 1000;
883  	const uint64 DiffMins = DiffSecs / 60;
884  	const uint64 DiffHours = DiffMins / 60;	
885  	MSecs = int(DiffMSecs % 1000);
886  	Secs = int(DiffSecs % 60);
887  	Mins = int(DiffMins % 60);
888  	Hours = int(DiffHours % 24);
889  	Days = int((int)DiffHours / 24);
890  }
891  uint64 TTm::GetDiffMSecs(const TTm&amp; Tm1, const TTm&amp; Tm2){
892    uint64 Tm1MSecs=GetMSecsFromTm(Tm1);
893    uint64 Tm2MSecs=GetMSecsFromTm(Tm2);
894    if (Tm1MSecs&gt;Tm2MSecs){
895      return Tm1MSecs-Tm2MSecs;
896    } else {
897      return Tm2MSecs-Tm1MSecs;
898    }
899  }
900  TTm TTm::GetLocTmFromUniTm(const TTm&amp; Tm){
901    return TSysTm::GetLocTmFromUniTm(Tm);
902  }
903  TTm TTm::GetUniTmFromLocTm(const TTm&amp; Tm){
904    return TSysTm::GetUniTmFromLocTm(Tm);
905  }
906  TTm TTm::GetTmFromWebLogTimeStr(const TStr&amp; TimeStr,
907   const char TimeSepCh, const char MSecSepCh){
908    int TimeStrLen=TimeStr.Len();
909    TChA ChA; int ChN=0;
910    while ((ChN&lt;TimeStrLen)&amp;&amp;(TimeStr[ChN]!=TimeSepCh)){
911      ChA+=TimeStr[ChN]; ChN++;}
912    TStr HourStr=ChA;
913    ChA.Clr(); ChN++;
914    while ((ChN&lt;TimeStrLen)&amp;&amp;(TimeStr[ChN]!=TimeSepCh)){
915      ChA+=TimeStr[ChN]; ChN++;}
916    TStr MinStr=ChA;
917    ChA.Clr(); ChN++;
918    while ((ChN&lt;TimeStrLen)&amp;&amp;(TimeStr[ChN]!=MSecSepCh)){
919      ChA+=TimeStr[ChN]; ChN++;}
920    TStr SecStr=ChA;
921    ChA.Clr(); ChN++;
922    while (ChN&lt;TimeStrLen){
923      ChA+=TimeStr[ChN]; ChN++;}
924    TStr MSecStr=ChA;
925    int HourN=HourStr.GetInt(0);
926    int MinN=MinStr.GetInt(0);
927    int SecN=SecStr.GetInt(0);
928    int MSecN=MSecStr.GetInt(0);
929    TTm Tm(-1, -1, -1, -1, HourN, MinN, SecN, MSecN);
930    return Tm;
931  }
932  TTm TTm::GetTmFromWebLogDateTimeStr(const TStr&amp; DateTimeStr,
933   const char DateSepCh, const char TimeSepCh, const char MSecSepCh,
934   const char DateTimeSepCh){
935    int DateTimeStrLen=DateTimeStr.Len();
936    TChA ChA; int ChN=0;
937    while ((ChN&lt;DateTimeStrLen)&amp;&amp;(DateTimeStr[ChN]!=DateSepCh)){
938      ChA+=DateTimeStr[ChN]; ChN++;}
939    TStr YearStr=ChA;
940    ChA.Clr(); ChN++;
941    while ((ChN&lt;DateTimeStrLen)&amp;&amp;(DateTimeStr[ChN]!=DateSepCh)){
942      ChA+=DateTimeStr[ChN]; ChN++;}
943    TStr MonthStr=ChA;
944    ChA.Clr(); ChN++;
945    while ((ChN&lt;DateTimeStrLen)&amp;&amp;(DateTimeStr[ChN]!=DateTimeSepCh)){
946      ChA+=DateTimeStr[ChN]; ChN++;}
947    TStr DayStr=ChA;
948    ChA.Clr(); ChN++;
949    while ((ChN&lt;DateTimeStrLen)&amp;&amp;(DateTimeStr[ChN]!=TimeSepCh)){
950      ChA+=DateTimeStr[ChN]; ChN++;}
951    TStr HourStr=ChA;
952    ChA.Clr(); ChN++;
953    while ((ChN&lt;DateTimeStrLen)&amp;&amp;(DateTimeStr[ChN]!=TimeSepCh)){
954      ChA+=DateTimeStr[ChN]; ChN++;}
955    TStr MinStr=ChA;
956    ChA.Clr(); ChN++;
957    while ((ChN&lt;DateTimeStrLen)&amp;&amp;(DateTimeStr[ChN]!=MSecSepCh)){
958      ChA+=DateTimeStr[ChN]; ChN++;}
959    TStr SecStr=ChA;
960    ChA.Clr(); ChN++;
961    while (ChN&lt;DateTimeStrLen){
962      ChA+=DateTimeStr[ChN]; ChN++;}
963    TStr MSecStr=ChA;
964    int YearN=YearStr.GetInt(-1);
965    int MonthN=MonthStr.GetInt(-1);
966    int DayN=DayStr.GetInt(-1);
967    int HourN=HourStr.GetInt(0);
968    int MinN=MinStr.GetInt(0);
969    int SecN=SecStr.GetInt(0);
970    int MSecN=MSecStr.GetInt(0);
971    TTm Tm;
972    if ((YearN!=-1)&amp;&amp;(MonthN!=-1)&amp;&amp;(DayN!=-1)){
973      Tm=TTm(YearN, MonthN, DayN, -1, HourN, MinN, SecN, MSecN);
974    }
975    return Tm;
976  }
977  TTm TTm::GetTmFromIdStr(const TStr&amp; IdStr){
978    TChA IdChA=IdStr;
979    if (IdChA.Len()==14){
980      IdChA.Ins(0, &quot;0&quot;);}
981    IAssert(IdChA.Len()==15);
982    for (int ChN=0; ChN&lt;IdChA.Len(); ChN++){
983      IAssert(TCh::IsNum(IdChA[ChN]));}
984    int YearN=2000+(TStr(IdChA[0])+TStr(IdChA[1])).GetInt();
985    int MonthN=(TStr(IdChA[2])+TStr(IdChA[3])).GetInt();
986    int DayN=(TStr(IdChA[4])+TStr(IdChA[5])).GetInt();
987    int HourN=(TStr(IdChA[6])+TStr(IdChA[7])).GetInt();
988    int MinN=(TStr(IdChA[8])+TStr(IdChA[9])).GetInt();
989    int SecN=(TStr(IdChA[10])+TStr(IdChA[11])).GetInt();
990    int MSecN=(TStr(IdChA[12])+TStr(IdChA[13])+TStr(IdChA[14])).GetInt();
991    TTm Tm=TTm(YearN, MonthN, DayN, -1, HourN, MinN, SecN, MSecN);
992    return Tm;
993  }
994  uint TTm::GetDateTimeInt(const int&amp; Year, const int&amp; Month,
995        const int&amp; Day, const int&amp; Hour, const int&amp; Min, const int&amp; Sec) {
996  	return TSecTm(Year, Month, Day, Hour, Min, Sec).GetAbsSecs();
997  }
998  uint TTm::GetDateIntFromTm(const TTm&amp; Tm) {
999      return Tm.IsDef() ? GetDateTimeInt(Tm.GetYear(), Tm.GetMonth(), Tm.GetDay()) : 0;
1000  }
1001  uint TTm::GetMonthIntFromTm(const TTm&amp; Tm) {
1002      return Tm.IsDef() ? GetDateTimeInt(Tm.GetYear(), Tm.GetMonth()) : 0;
1003  }
1004  uint TTm::GetYearIntFromTm(const TTm&amp; Tm) {
1005      return Tm.IsDef() ? GetDateTimeInt(Tm.GetYear()) : 0;
1006  }
1007  uint TTm::GetDateTimeIntFromTm(const TTm&amp; Tm) {
1008      return Tm.IsDef() ? 
1009  		GetDateTimeInt(Tm.GetYear(), Tm.GetMonth(),
1010          Tm.GetDay(), Tm.GetHour(), Tm.GetMin(), Tm.GetSec()) : 0;
1011  }
1012  TTm TTm::GetTmFromDateTimeInt(const uint&amp; DateTimeInt) {
1013  	if (DateTimeInt == 0) { return TTm(); }
1014  	return TTm(TSecTm(DateTimeInt));
1015  }
1016  TSecTm TTm::GetSecTmFromDateTimeInt(const uint&amp; DateTimeInt) {
1017  	if (DateTimeInt == 0) { return TSecTm(); }
1018  	return TSecTm(DateTimeInt);
1019  }
1020  int TTmProfiler::AddTimer(const TStr&amp; TimerNm) { 
1021  	MxNmLen = TInt::GetMx(MxNmLen, TimerNm.Len());
1022  	return TimerH.AddKey(TimerNm); 
1023  }
1024  void TTmProfiler::ResetAll() {
1025      int TimerId = GetTimerIdFFirst();
1026  	while (GetTimerIdFNext(TimerId)) {
1027  		ResetTimer(TimerId);
1028  	}
1029  }
1030  double TTmProfiler::GetTimerSumSec() const {
1031  	double Sum = 0.0;
1032      int TimerId = GetTimerIdFFirst();
1033  	while (GetTimerIdFNext(TimerId)) {
1034  		Sum += GetTimerSec(TimerId);
1035  	}
1036      return Sum;
1037  }
1038  double TTmProfiler::GetTimerSec(const int&amp; TimerId) const {
1039      return TimerH[TimerId].GetSec();
1040  }
1041  void TTmProfiler::PrintReport(const TStr&amp; ProfileNm) const {
1042      const double TimerSumSec = GetTimerSumSec();
1043  	printf(&quot;-- %s --\n&quot;, ProfileNm.CStr());
1044      printf(&quot;Sum: (%.2f sec):\n&quot;, TimerSumSec);
1045      int TimerId = GetTimerIdFFirst();
1046  	while (GetTimerIdFNext(TimerId)) {
1047          TStr TimerNm = GetTimerNm(TimerId);
1048          TimerNm = TStr::GetSpaceStr(TimerNm.Len() - MxNmLen) + TimerNm;
1049          if (TimerSumSec &gt; 0.0) {
1050              const double TimerSec = GetTimerSec(TimerId);
1051              const double TimerPerc =  TimerSec / TimerSumSec * 100.0;
1052              printf(&quot; %s: %.2fs [%.2f%%]\n&quot;, TimerNm.CStr(), TimerSec, TimerPerc);
1053          } else {
1054              printf(&quot; %s: -\n&quot;, TimerNm.CStr());
1055          }
1056      }
1057  	printf(&quot;--\n&quot;);
1058  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.cpp</h3>
            <pre><code>1  #include &quot;ScintillaQt.h&quot;
2  #include &quot;PlatQt.h&quot;
3  #include &lt;QApplication&gt;
4  #include &lt;QDrag&gt;
5  #if QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
6  #include &lt;QInputContext&gt;
7  #endif
8  #include &lt;QMimeData&gt;
9  #include &lt;QMenu&gt;
10  #include &lt;QTextCodec&gt;
11  #include &lt;QScrollBar&gt;
12  #include &lt;QTimer&gt;
13  using namespace Scintilla;
14  using namespace Scintilla::Internal;
15  ScintillaQt::ScintillaQt(QAbstractScrollArea *parent)
16  : QObject(parent), scrollArea(parent), vMax(0),  hMax(0), vPage(0), hPage(0),
17   haveMouseCapture(false), dragWasDropped(false),
18   rectangularSelectionModifier(SCMOD_ALT)
19  {
20  	wMain = scrollArea-&gt;viewport();
21  	imeInteraction = IMEInteraction::Inline;
22  	view.bufferedDraw = false;
23  	Init();
24  	std::fill(timers, std::end(timers), 0);
25  }
26  ScintillaQt::~ScintillaQt()
27  {
28  	CancelTimers();
29  	ChangeIdle(false);
30  }
31  void ScintillaQt::execCommand(QAction *action)
32  {
33  	const int commandNum = action-&gt;data().toInt();
34  	Command(commandNum);
35  }
36  #if defined(Q_OS_WIN)
37  static const QString sMSDEVColumnSelect(&quot;MSDEVColumnSelect&quot;);
38  static const QString sWrappedMSDEVColumnSelect(&quot;application/x-qt-windows-mime;value=\&quot;MSDEVColumnSelect\&quot;&quot;);
39  static const QString sVSEditorLineCutCopy(&quot;VisualStudioEditorOperationsLineCutCopyClipboardTag&quot;);
40  static const QString sWrappedVSEditorLineCutCopy(&quot;application/x-qt-windows-mime;value=\&quot;VisualStudioEditorOperationsLineCutCopyClipboardTag\&quot;&quot;);
41  #elif defined(Q_OS_MAC)
42  static const QString sScintillaRecPboardType(&quot;com.scintilla.utf16-plain-text.rectangular&quot;);
43  static const QString sScintillaRecMimeType(&quot;text/x-scintilla.utf16-plain-text.rectangular&quot;);
44  #else
45  static const QString sMimeRectangularMarker(&quot;text/x-rectangular-marker&quot;);
46  #endif
47  #if defined(Q_OS_MAC) &amp;&amp; QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
48  class ScintillaRectangularMime : public QMacPasteboardMime {
49  public:
50  	ScintillaRectangularMime() : QMacPasteboardMime(MIME_ALL) {
51  	}
52  	QString convertorName() {
53  		return QString(&quot;ScintillaRectangularMime&quot;);
54  	}
55  	bool canConvert(const QString &amp;mime, QString flav) {
56  		return mimeFor(flav) == mime;
57  	}
58  	QString mimeFor(QString flav) {
59  		if (flav == sScintillaRecPboardType)
60  			return sScintillaRecMimeType;
61  		return QString();
62  	}
63  	QString flavorFor(const QString &amp;mime) {
64  		if (mime == sScintillaRecMimeType)
65  			return sScintillaRecPboardType;
66  		return QString();
67  	}
68  	QVariant convertToMime(const QString &amp; &amp;bsol;* mime */, QList&lt;QByteArray&gt; data, QString &amp;bsol;* flav */) {
69  		QByteArray all;
70  		foreach (QByteArray i, data) {
71  			all += i;
72  		}
73  		return QVariant(all);
74  	}
75  	QList&lt;QByteArray&gt; convertFromMime(const QString &amp; &amp;bsol;* mime */, QVariant data, QString &amp;bsol;* flav */) {
76  		QByteArray a = data.toByteArray();
77  		QList&lt;QByteArray&gt; l;
78  		l.append(a);
79  		return l;
80  	}
81  };
82  static ScintillaRectangularMime *singletonMime = 0;
83  #endif
84  void ScintillaQt::Init()
85  {
86  	rectangularSelectionModifier = SCMOD_ALT;
87  #if defined(Q_OS_MAC) &amp;&amp; QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
88  	if (!singletonMime) {
89  		singletonMime = new ScintillaRectangularMime();
90  		QStringList slTypes(sScintillaRecPboardType);
91  		qRegisterDraggedTypes(slTypes);
92  	}
93  #endif
94  	connect(QApplication::clipboard(), SIGNAL(selectionChanged()),
95  		this, SLOT(SelectionChanged()));
96  }
97  void ScintillaQt::Finalise()
98  {
99  	CancelTimers();
100  	ScintillaBase::Finalise();
101  }
102  void ScintillaQt::SelectionChanged()
103  {
104  	bool nowPrimary = QApplication::clipboard()-&gt;ownsSelection();
105  	if (nowPrimary != primarySelection) {
106  		primarySelection = nowPrimary;
107  		Redraw();
108  	}
109  }
110  bool ScintillaQt::DragThreshold(Point ptStart, Point ptNow)
111  {
112  	int xMove = std::abs(ptStart.x - ptNow.x);
113  	int yMove = std::abs(ptStart.y - ptNow.y);
114  	return (xMove &gt; QApplication::startDragDistance()) ||
115  		(yMove &gt; QApplication::startDragDistance());
116  }
117  static QString StringFromSelectedText(const SelectionText &amp;selectedText)
118  {
119  	if (selectedText.codePage == SC_CP_UTF8) {
120  		return QString::fromUtf8(selectedText.Data(), static_cast&lt;int&gt;(selectedText.Length()));
121  	} else {
122  		QTextCodec *codec = QTextCodec::codecForName(
123  				CharacterSetID(selectedText.characterSet));
124  		return codec-&gt;toUnicode(selectedText.Data(), static_cast&lt;int&gt;(selectedText.Length()));
125  	}
126  }
127  static void AddRectangularToMime(QMimeData *mimeData, [[maybe_unused]] const QString &amp;su)
128  {
129  #if defined(Q_OS_WIN)
130  	mimeData-&gt;setData(sMSDEVColumnSelect, QByteArray());
131  #elif defined(Q_OS_MAC)
132  	mimeData-&gt;setData(sScintillaRecMimeType, su.toUtf8());
133  #else
134  	mimeData-&gt;setData(sMimeRectangularMarker, QByteArray());
135  #endif
136  }
137  static void AddLineCutCopyToMime([[maybe_unused]] QMimeData *mimeData)
138  {
139  #if defined(Q_OS_WIN)
140  	mimeData-&gt;setData(sVSEditorLineCutCopy, QByteArray());
141  #endif
142  }
143  static bool IsRectangularInMime(const QMimeData *mimeData)
144  {
145  	QStringList formats = mimeData-&gt;formats();
146  	for (int i = 0; i &lt; formats.size(); ++i) {
147  #if defined(Q_OS_WIN)
148  		if (formats[i] == sMSDEVColumnSelect)
149  			return true;
150  		if (formats[i] == sWrappedMSDEVColumnSelect)
151  			return true;
152  #elif defined(Q_OS_MAC)
153  		if (formats[i] == sScintillaRecMimeType)
154  			return true;
155  #else
156  		if (formats[i] == sMimeRectangularMarker)
157  			return true;
158  #endif
159  	}
160  	return false;
161  }
162  static bool IsLineCutCopyInMime(const QMimeData *mimeData)
163  {
164  	QStringList formats = mimeData-&gt;formats();
165  	for (int i = 0; i &lt; formats.size(); ++i) {
166  #if defined(Q_OS_WIN)
167  		if (formats[i] == sVSEditorLineCutCopy)
168  			return true;
169  		if (formats[i] == sWrappedVSEditorLineCutCopy)
170  			return true;
171  #endif
172  	}
173  	return false;
174  }
175  bool ScintillaQt::ValidCodePage(int codePage) const
176  {
177  	return codePage == 0
178  	|| codePage == SC_CP_UTF8
179  	|| codePage == 932
180  	|| codePage == 936
181  	|| codePage == 949
182  	|| codePage == 950
183  	|| codePage == 1361;
184  }
185  std::string ScintillaQt::UTF8FromEncoded(std::string_view encoded) const {
186  	if (IsUnicodeMode()) {
187  		return std::string(encoded);
188  	} else {
189  		QTextCodec *codec = QTextCodec::codecForName(
190  				CharacterSetID(CharacterSetOfDocument()));
191  		QString text = codec-&gt;toUnicode(encoded.data(), static_cast&lt;int&gt;(encoded.length()));
192  		return text.toStdString();
193  	}
194  }
195  std::string ScintillaQt::EncodedFromUTF8(std::string_view utf8) const {
196  	if (IsUnicodeMode()) {
197  		return std::string(utf8);
198  	} else {
199  		QString text = QString::fromUtf8(utf8.data(), static_cast&lt;int&gt;(utf8.length()));
200  		QTextCodec *codec = QTextCodec::codecForName(
201  				CharacterSetID(CharacterSetOfDocument()));
202  		QByteArray ba = codec-&gt;fromUnicode(text);
203  		return std::string(ba.data(), ba.length());
204  	}
205  }
206  void ScintillaQt::ScrollText(Sci::Line linesToMove)
207  {
208  	int dy = vs.lineHeight * (linesToMove);
209  	scrollArea-&gt;viewport()-&gt;scroll(0, dy);
210  }
211  void ScintillaQt::SetVerticalScrollPos()
212  {
213  	scrollArea-&gt;verticalScrollBar()-&gt;setValue(topLine);
214  	emit verticalScrolled(topLine);
215  }
216  void ScintillaQt::SetHorizontalScrollPos()
217  {
218  	scrollArea-&gt;horizontalScrollBar()-&gt;setValue(xOffset);
219  	emit horizontalScrolled(xOffset);
220  }
221  bool ScintillaQt::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage)
222  {
223  	bool modified = false;
224  	int vNewPage = nPage;
225  	int vNewMax = nMax - vNewPage + 1;
226  	if (vMax != vNewMax || vPage != vNewPage) {
227  		vMax = vNewMax;
228  		vPage = vNewPage;
229  		modified = true;
230  		scrollArea-&gt;verticalScrollBar()-&gt;setMaximum(vMax);
231  		scrollArea-&gt;verticalScrollBar()-&gt;setPageStep(vPage);
232  		emit verticalRangeChanged(vMax, vPage);
233  	}
234  	int hNewPage = GetTextRectangle().Width();
235  	int hNewMax = (scrollWidth &gt; hNewPage) ? scrollWidth - hNewPage : 0;
236  	int charWidth = vs.styles[STYLE_DEFAULT].aveCharWidth;
237  	if (hMax != hNewMax || hPage != hNewPage ||
238  	    scrollArea-&gt;horizontalScrollBar()-&gt;singleStep() != charWidth) {
239  		hMax = hNewMax;
240  		hPage = hNewPage;
241  		modified = true;
242  		scrollArea-&gt;horizontalScrollBar()-&gt;setMaximum(hMax);
243  		scrollArea-&gt;horizontalScrollBar()-&gt;setPageStep(hPage);
244  		scrollArea-&gt;horizontalScrollBar()-&gt;setSingleStep(charWidth);
245  		emit horizontalRangeChanged(hMax, hPage);
246  	}
247  	return modified;
248  }
249  void ScintillaQt::ReconfigureScrollBars()
250  {
251  	if (verticalScrollBarVisible) {
252  		scrollArea-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
253  	} else {
254  		scrollArea-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
255  	}
256  	if (horizontalScrollBarVisible &amp;&amp; !Wrapping()) {
257  		scrollArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
258  	} else {
259  		scrollArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
260  	}
261  }
262  void ScintillaQt::CopyToModeClipboard(const SelectionText &amp;selectedText, QClipboard::Mode clipboardMode_)
263  {
264  	QClipboard *clipboard = QApplication::clipboard();
265  	QString su = StringFromSelectedText(selectedText);
266  	QMimeData *mimeData = new QMimeData();
267  	mimeData-&gt;setText(su);
268  	if (selectedText.rectangular) {
269  		AddRectangularToMime(mimeData, su);
270  	}
271  	if (selectedText.lineCopy) {
272  		AddLineCutCopyToMime(mimeData);
273  	}
274  	emit aboutToCopy(mimeData);
275  	clipboard-&gt;setMimeData(mimeData, clipboardMode_);
276  }
277  void ScintillaQt::Copy()
278  {
279  	if (!sel.Empty()) {
280  		SelectionText st;
281  		CopySelectionRange(&amp;st);
282  		CopyToClipboard(st);
283  	}
284  }
285  void ScintillaQt::CopyToClipboard(const SelectionText &amp;selectedText)
286  {
287  	CopyToModeClipboard(selectedText, QClipboard::Clipboard);
288  }
289  void ScintillaQt::PasteFromMode(QClipboard::Mode clipboardMode_)
290  {
291  	QClipboard *clipboard = QApplication::clipboard();
292  	const QMimeData *mimeData = clipboard-&gt;mimeData(clipboardMode_);
293  	bool isRectangular = IsRectangularInMime(mimeData);
294  	bool isLine = SelectionEmpty() &amp;&amp; IsLineCutCopyInMime(mimeData);
295  	QString text = clipboard-&gt;text(clipboardMode_);
296  	QByteArray utext = BytesForDocument(text);
297  	std::string dest(utext.constData(), utext.length());
298  	SelectionText selText;
299  	selText.Copy(dest, pdoc-&gt;dbcsCodePage, CharacterSetOfDocument(), isRectangular, false);
300  	UndoGroup ug(pdoc);
301  	ClearSelection(multiPasteMode == MultiPaste::Each);
302  	InsertPasteShape(selText.Data(), selText.Length(),
303  		isRectangular ? PasteShape::rectangular : (isLine ? PasteShape::line : PasteShape::stream));
304  	EnsureCaretVisible();
305  }
306  void ScintillaQt::Paste()
307  {
308  	PasteFromMode(QClipboard::Clipboard);
309  }
310  void ScintillaQt::ClaimSelection()
311  {
312  	if (QApplication::clipboard()-&gt;supportsSelection()) {
313  		if (!sel.Empty()) {
314  			primarySelection = true;
315  			SelectionText st;
316  			CopySelectionRange(&amp;st);
317  			CopyToModeClipboard(st, QClipboard::Selection);
318  		} else {
319  			primarySelection = false;
320  		}
321  	}
322  }
323  void ScintillaQt::NotifyChange()
324  {
325  	emit notifyChange();
326  	emit command(
327  			Platform::LongFromTwoShorts(GetCtrlID(), SCEN_CHANGE),
328  			reinterpret_cast&lt;sptr_t&gt;(wMain.GetID()));
329  }
330  void ScintillaQt::NotifyFocus(bool focus)
331  {
332  	if (commandEvents) {
333  		emit command(
334  				Platform::LongFromTwoShorts
335  						(GetCtrlID(), focus ? SCEN_SETFOCUS : SCEN_KILLFOCUS),
336  				reinterpret_cast&lt;sptr_t&gt;(wMain.GetID()));
337  	}
338  	Editor::NotifyFocus(focus);
339  }
340  void ScintillaQt::NotifyParent(NotificationData scn)
341  {
342  	scn.nmhdr.hwndFrom = wMain.GetID();
343  	scn.nmhdr.idFrom = GetCtrlID();
344  	emit notifyParent(scn);
345  }
346  void ScintillaQt::NotifyURIDropped(const char *uri)
347  {
348  	NotificationData scn = {};
349  	scn.nmhdr.code = Notification::URIDropped;
350  	scn.text = uri;
351  	NotifyParent(scn);
352  }
353  bool ScintillaQt::FineTickerRunning(TickReason reason)
354  {
355  	return timers[static_cast&lt;size_t&gt;(reason)] != 0;
356  }
357  void ScintillaQt::FineTickerStart(TickReason reason, int millis, int &amp;bsol;* tolerance */)
358  {
359  	FineTickerCancel(reason);
360  	timers[static_cast&lt;size_t&gt;(reason)] = startTimer(millis);
361  }
362  void ScintillaQt::CancelTimers()
363  {
364  	for (size_t tr = static_cast&lt;size_t&gt;(TickReason::caret); tr &lt;= static_cast&lt;size_t&gt;(TickReason::dwell); tr++) {
365  		if (timers[tr]) {
366  			killTimer(timers[tr]);
367  			timers[tr] = 0;
368  		}
369  	}
370  }
371  void ScintillaQt::FineTickerCancel(TickReason reason)
372  {
373  	const size_t reasonIndex = static_cast&lt;size_t&gt;(reason);
374  	if (timers[reasonIndex]) {
375  		killTimer(timers[reasonIndex]);
376  		timers[reasonIndex] = 0;
377  	}
378  }
379  void ScintillaQt::onIdle()
380  {
381  	bool continueIdling = Idle();
382  	if (!continueIdling) {
383  		SetIdle(false);
384  	}
385  }
386  bool ScintillaQt::ChangeIdle(bool on)
387  {
388  	if (on) {
389  		if (!idler.state) {
390  			idler.state = true;
391  			QTimer *qIdle = new QTimer;
392  			connect(qIdle, SIGNAL(timeout()), this, SLOT(onIdle()));
393  			qIdle-&gt;start(0);
394  			idler.idlerID = qIdle;
395  		}
396  	} else {
397  		if (idler.state) {
398  			idler.state = false;
399  			QTimer *qIdle = static_cast&lt;QTimer *&gt;(idler.idlerID);
400  			qIdle-&gt;stop();
401  			disconnect(qIdle, SIGNAL(timeout()), nullptr, nullptr);
402  			delete qIdle;
403  			idler.idlerID = {};
404  		}
405  	}
406  	return true;
407  }
408  bool ScintillaQt::SetIdle(bool on)
409  {
410  	return ChangeIdle(on);
411  }
412  CharacterSet ScintillaQt::CharacterSetOfDocument() const
413  {
414  	return vs.styles[STYLE_DEFAULT].characterSet;
415  }
416  const char *ScintillaQt::CharacterSetIDOfDocument() const
417  {
418  	return CharacterSetID(CharacterSetOfDocument());
419  }
420  QString ScintillaQt::StringFromDocument(const char *s) const
421  {
422  	if (IsUnicodeMode()) {
423  		return QString::fromUtf8(s);
424  	} else {
425  		QTextCodec *codec = QTextCodec::codecForName(
426  				CharacterSetID(CharacterSetOfDocument()));
427  		return codec-&gt;toUnicode(s);
428  	}
429  }
<span onclick='openModal()' class='match'>430  QByteArray ScintillaQt::BytesForDocument(const QString &amp;text) const
431  {
432  	if (IsUnicodeMode()) {
433  		return text.toUtf8();
</span>434  	} else {
435  		QTextCodec *codec = QTextCodec::codecForName(
436  				CharacterSetID(CharacterSetOfDocument()));
437  		return codec-&gt;fromUnicode(text);
438  	}
439  }
440  namespace {
441  class CaseFolderDBCS : public CaseFolderTable {
442  	QTextCodec *codec;
443  public:
444  	explicit CaseFolderDBCS(QTextCodec *codec_) : codec(codec_) {
445  	}
446  	size_t Fold(char *folded, size_t sizeFolded, const char *mixed, size_t lenMixed) override {
447  		if ((lenMixed == 1) &amp;&amp; (sizeFolded &gt; 0)) {
448  			folded[0] = mapping[static_cast&lt;unsigned char&gt;(mixed[0])];
449  			return 1;
450  		} else if (codec) {
451  			QString su = codec-&gt;toUnicode(mixed, static_cast&lt;int&gt;(lenMixed));
452  			QString suFolded = su.toCaseFolded();
453  			QByteArray bytesFolded = codec-&gt;fromUnicode(suFolded);
454  			if (bytesFolded.length() &lt; static_cast&lt;int&gt;(sizeFolded)) {
455  				memcpy(folded, bytesFolded,  bytesFolded.length());
456  				return bytesFolded.length();
457  			}
458  		}
459  		folded[0] = &#x27;\0&#x27;;
460  		return 1;
461  	}
462  };
463  }
464  std::unique_ptr&lt;CaseFolder&gt; ScintillaQt::CaseFolderForEncoding()
465  {
466  	if (pdoc-&gt;dbcsCodePage == SC_CP_UTF8) {
467  		return std::make_unique&lt;CaseFolderUnicode&gt;();
468  	} else {
469  		const char *charSetBuffer = CharacterSetIDOfDocument();
470  		if (charSetBuffer) {
471  			if (pdoc-&gt;dbcsCodePage == 0) {
472  				std::unique_ptr&lt;CaseFolderTable&gt; pcf = std::make_unique&lt;CaseFolderTable&gt;();
473  				QTextCodec *codec = QTextCodec::codecForName(charSetBuffer);
474  				for (int i=0x80; i&lt;0x100; i++) {
475  					char sCharacter[2] = &quot;A&quot;;
476  					sCharacter[0] = static_cast&lt;char&gt;(i);
477  					QString su = codec-&gt;toUnicode(sCharacter, 1);
478  					QString suFolded = su.toCaseFolded();
479  					if (codec-&gt;canEncode(suFolded)) {
480  						QByteArray bytesFolded = codec-&gt;fromUnicode(suFolded);
481  						if (bytesFolded.length() == 1) {
482  							pcf-&gt;SetTranslation(sCharacter[0], bytesFolded[0]);
483  						}
484  					}
485  				}
486  				return pcf;
487  			} else {
488  				return std::make_unique&lt;CaseFolderDBCS&gt;(QTextCodec::codecForName(charSetBuffer));
489  			}
490  		}
491  		return nullptr;
492  	}
493  }
494  std::string ScintillaQt::CaseMapString(const std::string &amp;s, CaseMapping caseMapping)
495  {
496  	if (s.empty() || (caseMapping == CaseMapping::same))
497  		return s;
498  	if (IsUnicodeMode()) {
499  		std::string retMapped(s.length() * maxExpansionCaseConversion, 0);
500  		size_t lenMapped = CaseConvertString(&amp;retMapped[0], retMapped.length(), s.c_str(), s.length(),
501  			(caseMapping == CaseMapping::upper) ? CaseConversion::upper : CaseConversion::lower);
502  		retMapped.resize(lenMapped);
503  		return retMapped;
504  	}
505  	QTextCodec *codec = QTextCodec::codecForName(CharacterSetIDOfDocument());
506  	QString text = codec-&gt;toUnicode(s.c_str(), static_cast&lt;int&gt;(s.length()));
507  	if (caseMapping == CaseMapping::upper) {
508  		text = text.toUpper();
509  	} else {
510  		text = text.toLower();
511  	}
512  	QByteArray bytes = BytesForDocument(text);
513  	return std::string(bytes.data(), bytes.length());
514  }
515  void ScintillaQt::SetMouseCapture(bool on)
516  {
517  	if (mouseDownCaptures) {
518  		haveMouseCapture = on;
519  	}
520  }
521  bool ScintillaQt::HaveMouseCapture()
522  {
523  	return haveMouseCapture;
524  }
525  void ScintillaQt::StartDrag()
526  {
527  	inDragDrop = DragDrop::dragging;
528  	dropWentOutside = true;
529  	if (drag.Length()) {
530  		QMimeData *mimeData = new QMimeData;
531  		QString sText = StringFromSelectedText(drag);
532  		mimeData-&gt;setText(sText);
533  		if (drag.rectangular) {
534  			AddRectangularToMime(mimeData, sText);
535  		}
536  		QDrag *dragon = new QDrag(scrollArea);
537  		dragon-&gt;setMimeData(mimeData);
538  		Qt::DropAction dropAction = dragon-&gt;exec(static_cast&lt;Qt::DropActions&gt;(Qt::CopyAction|Qt::MoveAction));
539  		if ((dropAction == Qt::MoveAction) &amp;&amp; dropWentOutside) {
540  			ClearSelection();
541  		}
542  	}
543  	inDragDrop = DragDrop::none;
544  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
545  }
546  class CallTipImpl : public QWidget {
547  public:
548  	explicit CallTipImpl(CallTip *pct_)
549  		: QWidget(nullptr, Qt::ToolTip),
550  		  pct(pct_)
551  	{
552  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 9, 0)
553  		setWindowFlag(Qt::WindowTransparentForInput);
554  #endif
555  	}
556  	void paintEvent(QPaintEvent *) override
557  	{
558  		if (pct-&gt;inCallTipMode) {
559  			std::unique_ptr&lt;Surface&gt; surfaceWindow = Surface::Allocate(Technology::Default);
560  			surfaceWindow-&gt;Init(this);
561  			surfaceWindow-&gt;SetMode(SurfaceMode(pct-&gt;codePage, false));
562  			pct-&gt;PaintCT(surfaceWindow.get());
563  		}
564  	}
565  private:
566  	CallTip *pct;
567  };
568  void ScintillaQt::CreateCallTipWindow(PRectangle rc)
569  {
570  	if (!ct.wCallTip.Created()) {
571  		QWidget *pCallTip = new CallTipImpl(&amp;ct);
572  		ct.wCallTip = pCallTip;
573  		pCallTip-&gt;move(rc.left, rc.top);
574  		pCallTip-&gt;resize(rc.Width(), rc.Height());
575  	}
576  }
577  void ScintillaQt::AddToPopUp(const char *label,
578                               int cmd,
579                               bool enabled)
580  {
581  	QMenu *menu = static_cast&lt;QMenu *&gt;(popup.GetID());
582  	QString text(label);
583  	if (text.isEmpty()) {
584  		menu-&gt;addSeparator();
585  	} else {
586  		QAction *action = menu-&gt;addAction(text);
587  		action-&gt;setData(cmd);
588  		action-&gt;setEnabled(enabled);
589  	}
590  	menu-&gt;disconnect();
591  	connect(menu, SIGNAL(triggered(QAction*)),
592  		this, SLOT(execCommand(QAction*)));
593  }
594  sptr_t ScintillaQt::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam)
595  {
596  	try {
597  		switch (iMessage) {
598  		case Message::SetIMEInteraction:
599  			break;
600  		case Message::GrabFocus:
601  			scrollArea-&gt;setFocus(Qt::OtherFocusReason);
602  			break;
603  		case Message::GetDirectFunction:
604  			return reinterpret_cast&lt;sptr_t&gt;(DirectFunction);
605  		case Message::GetDirectStatusFunction:
606  			return reinterpret_cast&lt;sptr_t&gt;(DirectStatusFunction);
607  		case Message::GetDirectPointer:
608  			return reinterpret_cast&lt;sptr_t&gt;(this);
609  		case Message::SetRectangularSelectionModifier:
610  			rectangularSelectionModifier = static_cast&lt;int&gt;(wParam);
611  			break;
612  		case Message::GetRectangularSelectionModifier:
613  			return rectangularSelectionModifier;
614  		default:
615  			return ScintillaBase::WndProc(iMessage, wParam, lParam);
616  		}
617  	} catch (std::bad_alloc &amp;) {
618  		errorStatus = Status::BadAlloc;
619  	} catch (...) {
620  		errorStatus = Status::Failure;
621  	}
622  	return 0;
623  }
624  sptr_t ScintillaQt::DefWndProc(Message, uptr_t, sptr_t)
625  {
626  	return 0;
627  }
628  sptr_t ScintillaQt::DirectFunction(
629      sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam)
630  {
631  	ScintillaQt *sci = reinterpret_cast&lt;ScintillaQt *&gt;(ptr);
632  	return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
633  }
634  sptr_t ScintillaQt::DirectStatusFunction(
635      sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam, int *pStatus)
636  {
637  	ScintillaQt *sci = reinterpret_cast&lt;ScintillaQt *&gt;(ptr);
638  	const sptr_t returnValue = sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
639  	*pStatus = static_cast&lt;int&gt;(sci-&gt;errorStatus);
640  	return returnValue;
641  }
642  void ScintillaQt::PartialPaint(const PRectangle &amp;rect)
643  {
644  	rcPaint = rect;
645  	paintState = PaintState::painting;
646  	PRectangle rcClient = GetClientRectangle();
647  	paintingAllText = rcPaint.Contains(rcClient);
648  	AutoSurface surfacePaint(this);
649  	Paint(surfacePaint, rcPaint);
650  	surfacePaint-&gt;Release();
651  	if (paintState == PaintState::abandoned) {
652  		paintState = PaintState::painting;
653  		paintingAllText = true;
654  		AutoSurface surface(this);
655  		Paint(surface, rcPaint);
656  		surface-&gt;Release();
657  		scrollArea-&gt;viewport()-&gt;update();
658  	}
659  	paintState = PaintState::notPainting;
660  }
661  void ScintillaQt::DragEnter(const Point &amp;point)
662  {
663  	SetDragPosition(SPositionFromLocation(point,
664  					      false, false, UserVirtualSpace()));
665  }
666  void ScintillaQt::DragMove(const Point &amp;point)
667  {
668  	SetDragPosition(SPositionFromLocation(point,
669  					      false, false, UserVirtualSpace()));
670  }
671  void ScintillaQt::DragLeave()
672  {
673  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
674  }
675  void ScintillaQt::Drop(const Point &amp;point, const QMimeData *data, bool move)
676  {
677  	QString text = data-&gt;text();
678  	bool rectangular = IsRectangularInMime(data);
679  	QByteArray bytes = BytesForDocument(text);
680  	int len = bytes.length();
681  	SelectionPosition movePos = SPositionFromLocation(point,
682  				false, false, UserVirtualSpace());
683  	DropAt(movePos, bytes, len, move, rectangular);
684  }
685  void ScintillaQt::DropUrls(const QMimeData *data)
686  {
687  	foreach(const QUrl &amp;url, data-&gt;urls()) {
688  		NotifyURIDropped(url.toString().toUtf8().constData());
689  	}
690  }
691  void ScintillaQt::timerEvent(QTimerEvent *event)
692  {
693  	for (size_t tr=static_cast&lt;size_t&gt;(TickReason::caret); tr&lt;=static_cast&lt;size_t&gt;(TickReason::dwell); tr++) {
694  		if (timers[tr] == event-&gt;timerId()) {
695  			TickFor(static_cast&lt;TickReason&gt;(tr));
696  		}
697  	}
698  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tm.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>370  TStr TSecTm::GetDtStr(const TLoc&amp; Loc) const {
371    if (IsDef()){
372      struct tm Tm;
</pre></code></div>
                <div class="column column_space"><pre><code>430  QByteArray ScintillaQt::BytesForDocument(const QString &amp;text) const
431  {
432  	if (IsUnicodeMode()) {
433  		return text.toUtf8();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    