
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.5189873417721518%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-spinn3r.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "spinn3r.h"
3  void TSpinn3rFeedItem::Clr() {
4    PostTitleStr.Clr();
5    PostUrlStr.Clr();
6    PubTm = TSecTm();
7    BlogUrlStr.Clr();
8    BlogTitleStr.Clr();
9    BlogDesc.Clr();
10    BlogLang.Clr();
11    ContentStr.Clr();
12    LinkV.Clr(false);
13  }
14  bool TSpinn3rFeedItem::LoadItem(TXmlLx& XmlLx) {
15    static const TSecTm BegOfTm(2007,10,30, 0, 0, 0);
16    try {
17      EAssert(XmlLx.TagNm == "item");
18      PostTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "title");
19      if (! TStrUtil::GetNormalizedUrl(TStrUtil::GetXmlTagVal(XmlLx, "link").ToLc(), TChA(), PostUrlStr)) {
20        TExcept::Throw(TStr("Bad post url:")+PostUrlStr); }
21      TStrUtil::GetXmlTagVal(XmlLx, "guid");
22      const TChA T = TStrUtil::GetXmlTagVal(XmlLx, "pubDate");
23      EAssert(T.IsSuffix("GMT")); 
24      PubTm = TSecTm(atoi(T.GetSubStr(12,15).CStr()), TTmInfo::GetMonthN(T.GetSubStr(8,10).CStr()),
25        atoi(T.GetSubStr(5,6).CStr()), atoi(T.GetSubStr(17,18).CStr()),
26        atoi(T.GetSubStr(20,21).CStr()), atoi(T.GetSubStr(23,24).CStr()));
27      EAssert(PubTm > BegOfTm);
28      BlogUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "dc:source").ToLc();
29      BlogTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "weblog:title");
30      if (BlogUrlStr.Empty()) {
31        const int Slash = PostUrlStr.SearchCh('/', 7);
32        if (Slash > 7) { BlogUrlStr = PostUrlStr.GetSubStr(0, Slash-1); }
33        else { BlogUrlStr = PostUrlStr; }
34      }
35      if (BlogUrlStr.Empty()) { TExcept::Throw("Empty blog url"); }
36      if (PostUrlStr.Empty() || PostUrlStr.CountCh('/') < 3) { 
37        TExcept::Throw(TStr::Fmt("Bad post url: %s\n", PostUrlStr.CStr())); }
38      if (BlogTitleStr.Empty()) { BlogTitleStr="No Blog Title"; }
39      if (PostTitleStr.Empty()) { PostTitleStr="No Post Title"; }
40      BlogDesc = TStrUtil::GetXmlTagVal(XmlLx, "weblog:description");
41      BlogLang = TStrUtil::GetXmlTagVal(XmlLx, "dc:lang");
42      while (XmlLx.GetSym()!=xsyEof) {
43        if (XmlLx.Sym==xsySTag && XmlLx.TagNm=="description") { break; }
44        if (XmlLx.Sym==xsyETag && XmlLx.TagNm=="item") { return false; }
45      }
46      if (XmlLx.Sym == xsyEof) { return false; }
47      const TXmlLxSym NextSym = XmlLx.GetSym();
48      ContentStr = XmlLx.TxtChA.ToLc();
49      if (NextSym == xsyStr) { EAssert(XmlLx.GetSym() == xsyETag); }
50      else { EAssert(NextSym == xsyETag); } 
51      EAssert(XmlLx.TagNm == "description");
52      while (! (XmlLx.GetSym()==xsyETag && XmlLx.TagNm=="item")) { }
53      LinkV.Clr(false);
54      const int Len = ContentStr.Len();
55      int LinkBeg = 0, LinkEnd=0;
56      while (true) {
57        LinkBeg = ContentStr.SearchStr("href=", LinkBeg);
58        if (LinkBeg == -1) { break; } 
59        LinkBeg += 5;
60        for (LinkEnd=LinkBeg+2; LinkEnd<Len && ContentStr[LinkEnd]!='"' && ContentStr[LinkEnd]!=' ' && ContentStr[LinkEnd]!='\''; LinkEnd++) { }
61        if (ContentStr[LinkBeg]=='"' || ContentStr[LinkBeg]=='\'' || ContentStr[LinkBeg]==' ') { LinkBeg++; }
62        if (ContentStr.IsPrefix("&quot")) { LinkBeg += 5; }
63        if (ContentStr.IsSuffix("&quot")) { LinkEnd -= 5; }
64        TChA LinkStr;  TStrUtil::GetNormalizedUrl(ContentStr.GetSubStr(LinkBeg, LinkEnd-1), BlogUrlStr, LinkStr);
65        if (! LinkStr.IsPrefix("http:&bsol;&bsol;")) { continue; }
66        LinkBeg = LinkEnd;
67        LinkV.Add(LinkStr);
68      }
69    }
70    catch (PExcept Except){
71      LinkV.Clr(true);
72      return false;
73    }
74    return true;
75  }
76  bool TSpinn3rFeedItem::Next() {
77    if (SIn.Empty() || SIn->Eof()) {
78      printf("  new file");
79      if (! FFile.Next(CurFNm)) { return false; }
80      printf(" %s\n", CurFNm.GetFMid().CStr());
81      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
82      if (XmlLxPt != NULL) { delete XmlLxPt; }
83      XmlLxPt = new TXmlLx(SIn, xspTruncate);
84    }
85    TXmlLx& XmlLx = *XmlLxPt;
86    while(XmlLx.GetSym() != xsyEof) {
87      if (! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="item")) {
88        while (XmlLx.GetSym()!=xsyEof && ! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="item")) { }
89        if (XmlLx.Sym == xsyEof) { return Next(); }
90      }
91      const bool IsGoodPost = LoadItem(XmlLx);
92      if (IsGoodPost) { return true; }
93    }
94    return Next();
95  }
96  TSpinn3rFullItem::TSpinn3rFullItem(TSIn& SIn) : XmlLxPt(NULL) {
97    Load(SIn);
98  }
99  TSpinn3rFullItem::TSpinn3rFullItem(const TSpinn3rFullItem& Item) : XmlLxPt(NULL) {
100    *this = Item;
101  }
102  void TSpinn3rFullItem::Save(TSOut& SOut) const {
103    PostTitleStr.Save(SOut);
104    PostUrlStr.Save(SOut);
105    PubTm.Save(SOut);
106    BlogUrlStr.Save(SOut);
107    BlogTitleStr.Save(SOut);
108    BlogDesc.Save(SOut);
109    BlogLang.Save(SOut);
110    PageHtmlStr.Save(SOut);
111    ContentStr.Save(SOut);
112    LinkV.Save(SOut);
113  }
114  void TSpinn3rFullItem::Load(TSIn& SIn) {
115    PostTitleStr.Load(SIn);
116    PostUrlStr.Load(SIn);
117    PubTm.Load(SIn);
118    BlogUrlStr.Load(SIn);
119    BlogTitleStr.Load(SIn);
120    BlogDesc.Load(SIn);
121    BlogLang.Load(SIn);
122    PageHtmlStr.Load(SIn);
123    ContentStr.Load(SIn);
124    LinkV.Load(SIn);
125  }
126  TSpinn3rFullItem& TSpinn3rFullItem::operator = (const TSpinn3rFullItem& Item) {
127    PostTitleStr = Item.PostTitleStr;
128    PostUrlStr = Item.PostUrlStr;
129    PubTm = Item.PubTm;
130    BlogUrlStr = Item.BlogUrlStr;
131    BlogTitleStr = Item.BlogTitleStr;
132    BlogDesc = Item.BlogDesc;
133    BlogLang = Item.BlogLang;
134    PageHtmlStr = Item.PageHtmlStr;
135    ContentStr = Item.ContentStr;
136    LinkV = Item.LinkV;
137    return *this;
138  }
139  void TSpinn3rFullItem::Clr() {
140    PostTitleStr.Clr();
141    PostUrlStr.Clr();
142    PubTm = TSecTm();
143    BlogUrlStr.Clr();
144    BlogTitleStr.Clr();
145    BlogDesc.Clr();
146    BlogLang.Clr();
147    PageHtmlStr.Clr();
148    ContentStr.Clr();
149    LinkV.Clr(false);
150  }
151  bool TSpinn3rFullItem::LoadItem(TXmlLx& XmlLx) {
152    static const TSecTm BegOfTm(2008,07, 25, 0, 0, 0);
153    static const TSecTm EndOfTm(2010,10, 1, 0, 0, 0);
154    Clr();
155    try {
156      EAssert(XmlLx.TagNm == "item");
157      PostTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "title");
158      if (! TStrUtil::GetNormalizedUrl(TStrUtil::GetXmlTagVal(XmlLx, "link").ToLc(), TChA(), PostUrlStr)) {
159        TExcept::Throw(TStr("Bad post url:")+PostUrlStr); }
160      TStrUtil::GetXmlTagVal(XmlLx, "guid");
161      const TChA T = TStrUtil::GetXmlTagVal(XmlLx, "pubDate");  
162      EAssert(T.IsSuffix("GMT"));
163      PubTm = TSecTm(atoi(T.GetSubStr(12,15).CStr()), TTmInfo::GetMonthN(T.GetSubStr(8,10).CStr()),
164        atoi(T.GetSubStr(5,6).CStr()), atoi(T.GetSubStr(17,18).CStr()),
165        atoi(T.GetSubStr(20,21).CStr()), atoi(T.GetSubStr(23,24).CStr()));
166      EAssert(PubTm > BegOfTm);
167      BlogUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "dc:source").ToLc();
168      TChA TagNm; TStrUtil::GetXmlTagNmVal(XmlLx, TagNm, BlogTitleStr);
169      if (TagNm != "weblog:title") { 
170        BlogTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "weblog:title"); }
171      if (BlogUrlStr.Empty()) {
172        const int Slash = PostUrlStr.SearchCh('/', 7);
173        if (Slash > 7) { BlogUrlStr = PostUrlStr.GetSubStr(0, Slash-1); }
174        else { BlogUrlStr = PostUrlStr; }
175      }
176      if (BlogUrlStr.Empty()) { TExcept::Throw("Empty blog url"); }
177      if (PostUrlStr.Empty() || PostUrlStr.CountCh('/') < 3) { 
178        TExcept::Throw(TStr::Fmt("Bad post url: %s\n", PostUrlStr.CStr())); }
179      if (BlogTitleStr.Empty()) { BlogTitleStr="No Blog Title"; }
180      if (PostTitleStr.Empty()) { PostTitleStr="No Post Title"; }
181      BlogDesc = TStrUtil::GetXmlTagVal(XmlLx, "weblog:description");
182      BlogLang = TStrUtil::GetXmlTagVal(XmlLx, "dc:lang");
183      if (! PostUrlStr.IsPrefix("http:&bsol;&bsol;twitter.com/")) { &bsol;&bsol;normal post
184        while (XmlLx.GetSym()!=xsyEof) {
185          if (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post:body") { 
186            const TXmlLxSym NextSym = XmlLx.GetSym();
187            ContentStr = XmlLx.TxtChA.ToLc();
188            if (NextSym == xsyStr) { EAssert(XmlLx.GetSym() == xsyETag); }
189            else { EAssert(NextSym == xsyETag); } 
190            EAssert(XmlLx.TagNm == "post:body");
191          }
192          if (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post:content_extract") { 
193            const TXmlLxSym NextSym = XmlLx.GetSym();
194            ContentStr = XmlLx.TxtChA.ToLc();
195            if (NextSym == xsyStr) { EAssert(XmlLx.GetSym() == xsyETag); }
196            else { EAssert(NextSym == xsyETag); } 
197            EAssert(XmlLx.TagNm == "post:content_extract");
198            break;
199          }
200          if (XmlLx.Sym==xsyETag && XmlLx.TagNm=="item") { 
201            if (ContentStr.Len() > 5 && ContentStr.SearchCh('<')==-1) {
202              break; 
203            } 
204            return false;
205          } 
206        }
207      } else { 
208        while (XmlLx.GetSym()!=xsyEof) {
209          if (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post:title") { 
210            const TXmlLxSym NextSym = XmlLx.GetSym();
211            ContentStr = XmlLx.TxtChA.ToLc();
212            if (NextSym == xsyStr) { EAssert(XmlLx.GetSym() == xsyETag); }
213            else { EAssert(NextSym == xsyETag); } 
214            EAssert(XmlLx.TagNm == "post:title");
215          }
216          if (XmlLx.Sym==xsyETag && XmlLx.TagNm=="item") { break; }
217        }
218      }
219      if (XmlLx.Sym == xsyEof) { return false; }
220      LinkV.Clr(false);
221      const int Len = ContentStr.Len();
222      int LinkBeg = 0, LinkEnd=0;
223      TChA LinkStr;
224      while (true) {
225        LinkBeg = ContentStr.SearchStr("http:&bsol;&bsol;", LinkBeg);
226        if (LinkBeg == -1) { break; } 
227        for (LinkEnd=LinkBeg+2; LinkEnd<Len && ContentStr[LinkEnd]!='"' && ContentStr[LinkEnd]!='<' && ContentStr[LinkEnd]!=' ' && ContentStr[LinkEnd]!='\''; LinkEnd++) { }
228        if (ContentStr[LinkBeg]=='"' || ContentStr[LinkBeg]=='\'' || ContentStr[LinkBeg]==' ') { LinkBeg++; }
229        if (ContentStr.IsPrefix("&quot")) { LinkBeg += 5; }
230        if (ContentStr.IsSuffix("&quot")) { LinkEnd -= 5; }
231        TStrUtil::GetNormalizedUrl(ContentStr.GetSubStr(LinkBeg, LinkEnd-1), BlogUrlStr, LinkStr);
232        LinkBeg = LinkEnd;
233        LinkV.Add(LinkStr);
234      }
235      while (XmlLx.GetSym()!=xsyEof) {
236        if (XmlLx.Sym==xsySTag && XmlLx.TagNm=="atom:published") { break; }
237        if (XmlLx.Sym==xsyETag && XmlLx.TagNm=="item") { return true; }
238      }
239      if (XmlLx.Sym == xsyEof) { return false; }
240      const TXmlLxSym NextSym2 = XmlLx.GetSym();
241      const TChA T2 = XmlLx.TxtChA.ToLc();
242      if (NextSym2 == xsyStr) { EAssert(XmlLx.GetSym() == xsyETag); }
243      else { EAssert(NextSym2 == xsyETag); } 
244      EAssert(XmlLx.TagNm == "atom:published");
245      while (! (XmlLx.GetSym()==xsyETag && XmlLx.TagNm=="item")) { }
246    }
247    catch (PExcept Except){
248      LinkV.Clr(true);
249      return false;
250    }
251    return true;
252  }
253  void TSpinn3rFullItem::ProcessPosts(const TStr& XmlFNmWc, int LoadN) {
254    TFFile FFile(XmlFNmWc);  TStr FNm;  PSIn SIn;
255    if (LoadN < 0) { LoadN = TInt::Mx; }
256    TExeTm _ExeTm;
257    StartProcess();
258    for (int f = 1; FFile.Next(FNm); f++) {
259      printf("*** FILE:  %s\n", FNm.GetFMid().CStr());
260      PSIn SIn = TZipIn::IsZipExt(FNm.GetFExt()) ? PSIn(new TZipIn(FNm)) : PSIn(new TFIn(FNm));
261      TXmlLx XmlLx(SIn, xspTruncate);
262      StartProcFile(FNm);
263      int _PostCnt=0, _GoodPostCnt=0, _LinkPostCnt=0, _LinksCnt=0; 
264      while(XmlLx.GetSym() != xsyEof) {
265        if (! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="item")) {
266          while (XmlLx.GetSym()!=xsyEof && ! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="item")) { }
267          if (XmlLx.Sym == xsyEof) { break; }
268        }
269        const bool IsGoodPost = LoadItem(XmlLx);
270        if (IsGoodPost) {
271          if (! LinkV.Empty()) { LinkPostCnt++;  _LinkPostCnt++; }
272          LinksCnt += LinkV.Len();  _LinksCnt += LinkV.Len();
273          GoodPostCnt++;  _GoodPostCnt++; }
274        PostCnt++;  _PostCnt++;
275        ProcessPost(IsGoodPost);
276        if (_PostCnt % Kilo(10) == 0) {
277        }
278        if (PostCnt >= LoadN) { break; }
279      }
280      printf("\n================================================================\n");
281      printf("  file:  %s\n", FNm.GetFMid().CStr());
282      printf("  time:  %s   ", _ExeTm.GetStr());
283      printf("total: %s [%s]\n", TotExeTm.GetStr(), TExeTm::GetCurTm());
284      printf("  all posts:        %d   total: %d\n", _PostCnt, PostCnt());
285      printf("  good posts:       %d   total: %d\n", _GoodPostCnt, GoodPostCnt());
286      printf("  posts with links: %d   total: %d\n", _LinkPostCnt, LinkPostCnt());
287      printf("  links in posts:   %d   total: %d\n", _LinksCnt, LinksCnt());
288      EndProcFile(FNm);
289      fflush(stdout);  _ExeTm.Tick();
290      if (PostCnt >= LoadN) { break; }
291    }
292    EndProcess();
293  }
294  bool TSpinn3rFullItem::Next() {
295    if (SIn.Empty() || SIn->Eof()) {
296  	  if (FFile.Empty()) {
297  	    if (SIn.Empty()) { CurFNm = InFNmWc; }
298  	    else { return false; }
299  	  } else {
300        if (! FFile->Next(CurFNm)) { return false; }
301      }
302      printf("\n*** %s\n", CurFNm.GetFMid().CStr());
303      if (PostCnt>0) {
304        printf("  posts %d, good %d, wLinks %d, Links %d [%s]\n\n",
305          PostCnt(), GoodPostCnt(), LinkPostCnt(), LinksCnt(), ExeTm.GetStr());
306      }
307      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
308      if (XmlLxPt != NULL) { delete XmlLxPt; }
309      XmlLxPt = new TXmlLx(SIn, xspTruncate);
310    }
311    TXmlLx& XmlLx = *XmlLxPt;
312    while(XmlLx.GetSym() != xsyEof) {
313      if (! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="item")) {
314        while (true) { 
315          try {
316            if (! (XmlLx.GetSym()!=xsyEof && ! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="item"))) { break; }
317          } catch (PExcept Except){ }
318        }
319        if (XmlLx.Sym == xsyEof) { return Next(); }
320      }
321      const bool IsGoodPost = LoadItem(XmlLx);
322      PostCnt++;
323      if (IsGoodPost) {
324        GoodPostCnt++;  LinksCnt += LinkV.Len();
325        if (! LinkV.Empty()) { LinkPostCnt++;  }
326        return true;
327      }
328    }
329    return Next();
330  }
331  TQuoteExtractor::TQuoteExtractor(const bool& SaveContent) : DoSave(SaveContent), FOut(NULL) {
332    if (! SaveContent) { printf("\n!!! Not saving the post content with quotes !!!\n"); }
333  }
334  TQuoteExtractor::~TQuoteExtractor() {
335    if (FOut != NULL) { fclose(FOut);  FOut=NULL; }
336    DumpStat();
337  }
338  void TQuoteExtractor::GetInsideQuotes() {
339    char prev;
340    QuoteV.Clr();
341    for (char *e = PostText.CStr(); *e; ) {
342      while (*e && *e != '"') { e++; }
343      if (! *e) { return; }
344      prev = *(e-1);
345      if (! TCh::IsWs(prev) && prev!='(') { e++;
346      continue; }
347      char* b = e+1;  e++;
348      while (*e && *e != '"') { e++; }
349      prev = *(e-1);
350      char next = *(e+1);
351      if ((! (TCh::IsAlNum(prev) || prev=='.' || prev==',' || prev=='!' || prev=='?' || prev==':')) ||
352        (! (TCh::IsWs(next) || next=='.' || next==',' || next=='!' || next=='?' || next==':'))) {
353        char *newE = b;
354        while(*newE && (*newE!=' ' || *(newE-1)!=' ')) { newE++; }
355        if (newE < e && uint(newE-b) < 300) { e = newE;  }
356        else { 
357          newE = b;
358          while(*newE && *newE!='.' && *(newE)!='!'  && *(newE)!='?') { newE++; }
359          if (newE < e) { e = newE; }
360        }
361      }
362      if (uint(e-b) > 2) { 
363        prev = *e;  *e=0;
364        int alNum = 0;
365        for (char *bb = b; *bb; bb++) {
366          if (TCh::IsAlNum(*bb)) { alNum++; } }
367        if (alNum > 0) { QuoteV.Add(b); }
368        *e=prev;
369      }
370      e++;
371    }
372  }
373  bool TQuoteExtractor::Next() {
374    const bool IsOk = TSpinn3rFullItem::Next();
375    PostText.Clr();  QuoteV.Clr();
376    if (! IsOk) { return false; }
377    if (ContentStr.Empty()) { NoContentCnt++;  return true; }
378    TStrUtil::RemoveHtmlTags(ContentStr, PostText);
379    if (! TStrUtil::IsLatinStr(PostText, 0.8)) { NoLatinCnt++;  return true; }
380    GoodLatinCnt++;
381    GetInsideQuotes();
382    PostText = TStrUtil::GetCleanStr(PostText); 
383    if (! QuoteV.Empty()) { QuotePostCnt++; }
384    QuotesCnt += QuoteV.Len();
385    for (int q = 0; q < QuoteV.Len(); q++) {
386      QuoteV[q] = TStrUtil::GetCleanWrdStr(QuoteV[q]); }
387    return true;
388  }
389  void TQuoteExtractor::ProcessPost(const bool& GoodItem) {
390    if (! GoodItem) { BadPostCnt++;  return; }
391    if (ContentStr.Empty()) { NoContentCnt++;  return; }
392    TStrUtil::RemoveHtmlTags(ContentStr, PostText);
393    if (! TStrUtil::IsLatinStr(PostText, 0.8)) { NoLatinCnt++;  return; }
394    GoodLatinCnt++;
395    GetInsideQuotes();
396    PostText = TStrUtil::GetCleanWrdStr(PostText);
397    if (! QuoteV.Empty()) { QuotePostCnt++; }
398    QuotesCnt += QuoteV.Len();
399    for (int q = 0; q < QuoteV.Len(); q++) {
400      QuoteV[q] = TStrUtil::GetCleanWrdStr(QuoteV[q]); }
401    OnQuotesExtracted(*this); 
402    if (DoSave) {
403      SaveToXml();
404      SaveToBin();
405    }
406  }
407  void TQuoteExtractor::StartProcFile(const TStr& FNm) {
408    CurInFNm = FNm;
409    TStr FNmMid = FNm.GetFMid();
410    int lastNumCh = FNmMid.Len()-1;
411    while(lastNumCh>0 && ! TCh::IsNum(FNmMid[lastNumCh])) { lastNumCh--; }
412    if (lastNumCh == 0) { lastNumCh = FNmMid.SearchCh('.')-1; }
413    const TStr NewFNmPref = FNmMid.GetSubStr(0, lastNumCh);
414    if (DoSave && NewFNmPref != OutFNmPref) {
415      OutFNmPref = NewFNmPref;
416      if (FOut != NULL) { fclose(FOut); }
417      FOut = fopen(TStr::Fmt("%s.content", OutFNmPref.CStr()).CStr(), "wt");
418      BinFOut = PSOut(new TFOut(TStr::Fmt("%s.contentBin", OutFNmPref.CStr())));
419    }
420  }
421  void TQuoteExtractor::DumpStat() {
422    printf("== %s\n", XmlLxPt!=NULL?XmlLxPt->GetFPosStr().CStr():CurInFNm.CStr());
423    printf("    %d all posts, %d good posts, %d posts with links, %d links\n", PostCnt(), GoodPostCnt(), LinkPostCnt(), LinksCnt());
424    printf("    %d bad posts, %d no content posts, %d no latin posts ==\n", BadPostCnt(), NoContentCnt(), NoLatinCnt());
425    printf("    %d good latin posts, %d posts with quotes, %d uotes, %.2f quotes/post\n", GoodLatinCnt(), QuotePostCnt(), QuotesCnt(), double(QuotesCnt)/double(GoodLatinCnt));
426    printf("    %.1f s/1000 posts, total time: %s\n\n", (float)ExeTm.GetSecs(), TotExeTm.GetStr());
427  }
<span onclick='openModal()' class='match'>428  void TQuoteExtractor::SaveToXml() {
429    fprintf(FOut, "<post>\n");
430    fprintf(FOut, "<pubDate>%s</pubDate>\n", TXmlLx::GetXmlStrFromPlainStr(PubTm.GetDtTmSortStr()).CStr());
431    fprintf(FOut, "<postUrl>%s</postUrl>\n", TXmlLx::GetXmlStrFromPlainStr(PostUrlStr).CStr());
432    fprintf(FOut, "<postTitle>%s</postTitle>\n", TXmlLx::GetXmlStrFromPlainStr(PostTitleStr).CStr());
433    fprintf(FOut, "<blogUrl>%s</blogUrl>\n", TXmlLx::GetXmlStrFromPlainStr(BlogUrlStr).CStr());
434    fprintf(FOut, "<blogTitle>%s</blogTitle>\n", TXmlLx::GetXmlStrFromPlainStr(BlogTitleStr).CStr());
435    fprintf(FOut, "<content>%s</content>\n", TXmlLx::GetXmlStrFromPlainStr(PostText).CStr());
436    for (int q = 0; q < QuoteV.Len(); q++) {
437      fprintf(FOut, "<q>%s</q>\n", TXmlLx::GetXmlStrFromPlainStr(QuoteV[q]).CStr()); }
438    for (int l = 0; l < LinkV.Len(); l++) {
</span>439      fprintf(FOut, "<l>%s</l>\n", TXmlLx::GetXmlStrFromPlainStr(LinkV[l]).CStr()); }
440    fprintf(FOut, "</post>\n\n");
441  }
442  void TQuoteExtractor::SaveToBin() {
443    PubTm.Save(*BinFOut);
444    PostUrlStr.Save(*BinFOut);
445    PostTitleStr.Save(*BinFOut);
446    BlogUrlStr.Save(*BinFOut);
447    BlogTitleStr.Save(*BinFOut);
448    PostText.Save(*BinFOut);
449    QuoteV.Save(*BinFOut);
450    LinkV.Save(*BinFOut);
451  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tb.cpp</h3>
            <pre><code>1  TStr TTbVarType::GetStr() const {
2    TChA ChA;
3    if (IsDsc()){
4      ChA+="Discrete";
5      ChA+=":[";
6      if (IsDscOrd()){ChA+="Ordered";}
7      ChA+=" Vals:"+TInt::GetStr(GetDscs());
8      if (IsDscInt()){
9        ChA+=" Integer";
10        ChA+=":[";
11        ChA+=" Mn:"+TInt::GetStr(GetMnIntDsc());
12        ChA+=" Mx:"+TInt::GetStr(GetMxIntDsc());
13        ChA+="]";
14      }
15      if (IsDscSym()){
16        ChA+=" Symbolic";
17        ChA+=":[";
18        for (int Dsc=0; Dsc<GetDscs(); Dsc++){
19          ChA+=" "; ChA+=GetDscStr(Dsc);
20        }
21        ChA+="]";
22      }
23      ChA+="]";
24    }
25    if (IsFlt()){
26      ChA+="Continuos";
27      ChA+=":[";
28      ChA+="Range:"+TFlt::GetStr(GetFltRange());
29      ChA+=" Mn:"+TFlt::GetStr(GetMnFlt());
30      ChA+=" Mx:"+TFlt::GetStr(GetMxFlt());
31      ChA+="]";
32    }
33    return ChA;
34  }
35  bool TTbVarType::IsValOk(const TTbVal& Val){
36    TTbValTag ValTag=Val.GetValTag();
37    if (!AlwVTSet.In(ValTag)){return false;}
38    if (ValTag==tvtDsc){
39      int Dsc=Val.GetDsc();
40      return (0<=Dsc)&&(Dsc<GetDscs());
41    } else
42    if (ValTag==tvtFlt){
43      double Flt=Val.GetFlt();
44      if (DefP || FixVTSet.In(tvtFlt)){
45        return (double(MnFlt)<=Flt)&&(Flt<=double(MxFlt));}
46      else {
47        MnFlt=TFlt::GetMn(MnFlt, Flt); MxFlt=TFlt::GetMx(MxFlt, Flt);
48        return true;
49      }
50    } else {
51      return true;
52    }
53  }
54  TTbVal TTbVarType::GetDscVal(const TStr& Str){
55    Assert(AlwVTSet.In(tvtDsc)&&!DscIntP);
56    int KeyId=NmToDscH.GetKeyId(Str);
57    if (KeyId==-1){
58      Assert(!DefP && !FixVTSet.In(tvtDsc));
59      return TTbVal(NmToDscH.AddDat(Str, TInt(DscToNmV.Add(Str))));}
60    else {
61      return TTbVal(NmToDscH[KeyId]);
62    }
63  }
64  TTbVal TTbVarType::GetDscVal(const int& Dsc){
65    Assert(AlwVTSet.In(tvtDsc)&&(0<=Dsc)&&(Dsc<GetDscs()));
66    return TTbVal(Dsc);
67  }
68  TTbVal TTbVarType::GetIntDscVal(const int& Int){
69    Assert(AlwVTSet.In(tvtDsc)&&DscIntP&&(MnIntDsc<=Int)&&(Int<=MxIntDsc));
70    return TTbVal(Int-MnIntDsc);
71  }
72  TTbVal TTbVarType::GetFltVal(const double& Flt){
73    Assert(AlwVTSet.In(tvtFlt));
74    if (DefP || FixVTSet.In(tvtFlt)){
75      Assert((double(MnFlt)<=Flt)&&(Flt<=double(MxFlt)));
76    } else {
77      MnFlt=TFlt::GetMn(MnFlt, Flt); MxFlt=TFlt::GetMx(MxFlt, Flt);
78    }
79    return TTbVal(Flt);
80  }
81  TTbVal TTbVarType::GetVal(const TTbVal& Val){
82    Assert(AlwVTSet.In(Val.GetValTag()));
83    switch (Val.GetValTag()){
84      case tvtUnknw: case tvtUnimp: case tvtUnapp: return Val;
85      case tvtDsc: return GetDscVal(Val.GetDsc());
86      case tvtFlt: return GetFltVal(Val.GetFlt());
87      default: Fail; return TTbVal();
88    }
89  }
90  double TTbVarType::GetNrmFlt(const TTbVal& Val){
91    Assert(DefP && IsValOk(Val));
92    switch (Val.GetValTag()){
93      case tvtDsc:
94        Assert(DscOrdP);
95        if (GetDscs()>1){return double(Val.GetDsc())/double(GetDscs()-1);}
96        else {return 0;}
97      case tvtFlt:
98        Assert(GetFltRange()>0);
99        return (Val.GetFlt()-MnFlt)/GetFltRange();
100      default: Fail; return 0;
101    }
102  }
103  TStr TTbVarType::GetValStr(const TTbVal& Val){
104    Assert(IsValOk(Val));
105    if (Val.GetValTag()==tvtDsc){
106      if (DscIntP){return TInt::GetStr(Val.GetDsc()+MnIntDsc);}
107      else {return DscToNmV[Val.GetDsc()];}
108    } else {
109      return Val.GetStr();
110    }
111  }
112  PTbVarType TTbVarType::GetDscBoolVarType(){
113    static PTbVarType BoolVarType=NULL;
114    if (BoolVarType==NULL){
115      BoolVarType=PTbVarType(new TTbVarType());
116      BoolVarType->SetDscFix(true);
117      BoolVarType->AddDscNm(TBool::GetStr(false));
118      BoolVarType->AddDscNm(TBool::GetStr(true));
119      BoolVarType->SetAlwVTSet(TB32Set(tvtDsc));
120      BoolVarType->Def();
121    }
122    return BoolVarType;
123  }
124  PTbVarType TTbVarType::GetDscIntVarType(const int& MnIntDsc, const int& MxIntDsc){
125    static const int IntVarTypes=10;
126    static TTbVarTypeV DscIntVarTypeV;
127    if (DscIntVarTypeV.Len()!=IntVarTypes){
128      for (int IntVarTypeN=0; IntVarTypeN<IntVarTypes; IntVarTypeN++){
129        PTbVarType VarType=new TTbVarType();
130        VarType->SetDscFix(0, IntVarTypeN);
131        VarType->SetAlwVTSet(TB32Set(tvtDsc));
132        VarType->Def();
133        DscIntVarTypeV.Add(VarType);
134      }
135    }
136    if ((MnIntDsc==0)&&(0<=MxIntDsc)&&(MxIntDsc<DscIntVarTypeV.Len())){
137      return DscIntVarTypeV[MxIntDsc];
138    } else {
139      PTbVarType VarType=new TTbVarType();
140      VarType->SetDscFix(MnIntDsc, MxIntDsc);
141      VarType->SetAlwVTSet(TB32Set(tvtDsc));
142      VarType->Def();
143      return VarType;
144    }
145  }
146  PTbVarType TTbVarType::GetDscNmVVarType(const TStrV& NmV, const bool& DscOrdP){
147    PTbVarType VarType=new TTbVarType();
148    VarType->SetDscFix(DscOrdP);
149    for (int NmN=0; NmN<NmV.Len(); NmN++){VarType->AddDscNm(NmV[NmN]);}
150    VarType->SetAlwVTSet(TB32Set(tvtDsc));
151    VarType->Def();
152    return VarType;
153  }
154  PTbVarType TTbVarType::GetFltVarType(const double& MnFlt, const double& MxFlt){
155    static PTbVarType GFltVarType=NULL;
156    if (GFltVarType.Empty()){
157      GFltVarType=PTbVarType(new TTbVarType());
158      GFltVarType->SetFltFix(TFlt::Mn, TFlt::Mx);
159      GFltVarType->SetAlwVTSet(TB32Set(tvtFlt));
160      GFltVarType->Def();
161    }
162    if ((MnFlt==TFlt::Mn)&&(MxFlt==TFlt::Mx)){
163      return GFltVarType;
164    } else {
165      PTbVarType VarType=new TTbVarType();
166      VarType->SetFltFix(MnFlt, MxFlt);
167      VarType->SetAlwVTSet(TB32Set(tvtFlt));
168      VarType->Def();
169      return VarType;
170    }
171  }
172  TTbSufixVarCat TTbVarType::GetSufixVarCat(const TStr& VarNm){
173    TStr UcVarNm=VarNm.GetUc();
174    if (UcVarNm.IsSuffix(":I")){return tsvcIgnore;}
175    else if (UcVarNm.IsSuffix(":L")){return tsvcLabel;}
176    else if (UcVarNm.IsSuffix(":C")){return tsvcClass;}
177    else if (UcVarNm.IsSuffix(":A")){return tsvcAttr;}
178    else if (UcVarNm=="CLASS"){return tsvcClass;}
179    else {return tsvcUndef;}
180  }
181  bool TTbVarType::IsSuffixVarNm(const PTb& Tb){
182    for (int VarN=0; VarN<Tb->GetVars(); VarN++){
183      TStr VarNm=Tb->GetVar(VarN)->GetNm();
184      if (GetSufixVarCat(VarNm)!=tsvcUndef){return true;}
185    }
186    return false;
187  }
188  PTb TTb::Load(TSIn& SIn){
189    TStr TypeNm(SIn);
190    if (TypeNm==TTypeNm<TGTb>()){return new TGTb(SIn);}
191    else {Fail; return NULL;}
192  }
<span onclick='openModal()' class='match'>193  void TTb::AddTb(const PTb& Tb){
194    Assert(GetVars()==Tb->GetVars());
195    for (int VarN=0; VarN<GetVars(); VarN++){
196      Assert(*GetVar(VarN)==*(Tb->GetVar(VarN)));
197    }
198    for (int SrcTupN=0; SrcTupN<Tb->GetTups(); SrcTupN++){
</span>199      int DstTupN=AddTup(Tb->GetTupNm(SrcTupN));
200      for (int VarN=0; VarN<Tb->GetVars(); VarN++){
201        PutVal(DstTupN, VarN, Tb->GetVal(SrcTupN, VarN));}
202    }
203  }
204  PTb TTb::GetSubTb(const TIntV& TupNV, const TIntV& VarNV, const PTb& Tb){
205    if ((TupNV.Len()==0)||(VarNV.Len()==0)){return NULL;}
206    for (int VarNN=0; VarNN<VarNV.Len(); VarNN++){
207      Tb->AddVar(GetVar(VarNV[VarNN]));}
208    for (int TupNN=0; TupNN<TupNV.Len(); TupNN++){
209      int TupN=TupNV[TupNN]; int NewTupN=Tb->AddTup(GetTupNm(TupN));
210      for (int VarNN=0; VarNN<VarNV.Len(); VarNN++){
211        Tb->PutVal(NewTupN, VarNN, GetVal(TupN, VarNV[VarNN]));}
212    }
213    Tb->DefVarTypes();
214    return Tb;
215  }
216  PTb TTb::LoadFile(const TStr& FNm, const TStr& FType, const TStr& MemRep){
217    PTb Tb;
218    if (MemRep==""){Tb=PTb(new TGTb());}
219    else if (MemRep=="General"){Tb=PTb(new TGTb());}
220    else {Fail; return NULL;}
221    if (FType==""){
222      TStr FExt=FNm.GetFExt().GetUc();
223      if (FExt==".TXT"){LoadTxtSpc(FNm, Tb);}
224      else if (FExt==".TAB"){LoadTxtTab(FNm, Tb);}
225      else if (FExt==".CSV"){LoadTxtCsv(FNm, Tb);}
226      else {Fail;}
227    } else {
228      if (FType=="Txt"){LoadTxtSpc(FNm, Tb);}
229      else if (FType=="TxtTab"){LoadTxtTab(FNm, Tb);}
230      else if (FType=="TxtCsv"){LoadTxtCsv(FNm, Tb);}
231      else {Fail;}
232    }
233    return Tb;
234  }
235  PTb TTb::LoadTxtSpc(const TStr& FNm, const PTb& Tb){
236    PSIn SIn=TFIn::New(FNm);
237    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloUniStr);
238    Lx.GetStr();
239    bool IsTupNm=(Lx.UcStr=="NAME")||(Lx.UcStr=="ID");
240    if (IsTupNm){Lx.GetStr();}
241    do {
242      PTbVarType VarType=PTbVarType(new TTbVarType());
243      PTbVar Var=PTbVar(new TGTbVar(Lx.Str, VarType));
244      Tb->AddVar(Var);
245    } while (Lx.GetSym(syStr, syEoln, syEof)==syStr);
246    TFSet ValSymSet=TFSet()|syQuestion|syAsterisk|sySlash|syFlt|syStr;
247    if (Lx.Sym!=syEof){
248      Lx.GetSym(TFSet(ValSymSet)|syEof);}
249    while (Lx.Sym!=syEof){
250      int TupN;
251      if (IsTupNm){TupN=Tb->AddTup(Lx.GetSymStr()); Lx.GetSym(ValSymSet);}
252      else {TupN=Tb->AddTup();}
253      for (int VarN=0; VarN<Tb->GetVars(); VarN++){
254        if (VarN>0){Lx.GetSym(ValSymSet);}
255        switch (Lx.Sym){
256          case syQuestion: Tb->PutVal(TupN, VarN, TTbVal(tvtUnknw)); break;
257          case syAsterisk: Tb->PutVal(TupN, VarN, TTbVal(tvtUnimp)); break;
258          case sySlash: Tb->PutVal(TupN, VarN, TTbVal(tvtUnapp)); break;
259          case syStr: Tb->PutDsc(TupN, VarN, Lx.Str); break;
260          case syFlt: Tb->PutFlt(TupN, VarN, Lx.Flt); break;
261          default: Fail;
262        }
263      }
264      Lx.GetSym(syEoln, syEof);
265      while (Lx.Sym==syEoln){Lx.GetSym(TFSet(ValSymSet)|syEoln|syEof);}
266    }
267    Tb->DefVarTypes();
268    return Tb;
269  }
270  PTb TTb::LoadTxtTab(const TStr& FNm, const PTb& Tb){
271    PSIn SIn=TFIn::New(FNm);
272    TILx Lx(SIn, TFSet()|iloTabSep);
273    Lx.GetStr();
274    bool IsTupNm=(Lx.UcStr=="NAME")||(Lx.UcStr=="ID");
275    if (IsTupNm){Lx.GetSym(syTab); Lx.GetStr();}
276    do {
277      PTbVarType VarType=PTbVarType(new TTbVarType());
278      PTbVar Var=PTbVar(new TGTbVar(Lx.Str, VarType));
279      Tb->AddVar(Var);
280      if (Lx.GetSym(syTab, syEoln, syEof)==syTab){
281        Lx.GetSym(syStr);}
282    } while (Lx.Sym==syStr);
283    if (Lx.Sym!=syEof){
284      Lx.GetSym(syStr, syEof);}
285    while (Lx.Sym!=syEof){
286      int TupN;
287      if (IsTupNm){
288        TupN=Tb->AddTup(Lx.GetSymStr());
289        Lx.GetSym(syTab); Lx.GetStr();}
290      else {TupN=Tb->AddTup();}
291      for (int VarN=0; VarN<Tb->GetVars(); VarN++){
292        if (VarN>0){Lx.GetSym(syTab); Lx.GetStr();}
293        if (Lx.Str=='?'){Tb->PutVal(TupN, VarN, TTbVal(tvtUnknw));}
294        else if (Lx.Str=='*'){Tb->PutVal(TupN, VarN, TTbVal(tvtUnimp));}
295        else if (Lx.Str=='/'){Tb->PutVal(TupN, VarN, TTbVal(tvtUnapp));}
296        else {
297          double Flt;
298          if (TStr(Lx.Str).IsFlt(Flt)){
299            Tb->PutFlt(TupN, VarN, Flt);
300          } else {
301            Tb->PutDsc(TupN, VarN, Lx.Str);
302          }
303        }
304      }
305      Lx.GetSym(syEoln, syEof);
306      while (Lx.Sym==syEoln){Lx.GetSym(syStr, syEoln, syEof);}
307    }
308    Tb->DefVarTypes();
309    return Tb;
310  }
311  PTb TTb::LoadTxtCsv(const TStr& FNm, const PTb& Tb){
312    PSIn SIn=TFIn::New(FNm);
313    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloUniStr);
314    Lx.GetStr();
315    bool IsTupNm=(Lx.UcStr=="NAME")||(Lx.UcStr=="ID");
316    if (IsTupNm){Lx.GetSym(syComma); Lx.GetStr();}
317    do {
318      PTbVarType VarType=PTbVarType(new TTbVarType());
319      PTbVar Var=PTbVar(new TGTbVar(Lx.Str, VarType));
320      Tb->AddVar(Var);
321      if (Lx.GetSym(syComma, syEoln, syEof)==syComma){
322        Lx.GetSym(syStr);}
323    } while (Lx.Sym==syStr);
324    TFSet ValSymSet=TFSet()|syQuestion|syAsterisk|sySlash|syFlt|syStr;
325    if (Lx.Sym!=syEof){
326      Lx.GetSym(TFSet(ValSymSet)|syEof);}
327    while (Lx.Sym!=syEof){
328      int TupN;
329      if (IsTupNm){
330        TupN=Tb->AddTup(Lx.GetSymStr());
331        Lx.GetSym(syComma); Lx.GetSym(ValSymSet);}
332      else {TupN=Tb->AddTup();}
333      for (int VarN=0; VarN<Tb->GetVars(); VarN++){
334        if (VarN>0){Lx.GetSym(syComma); Lx.GetSym(ValSymSet);}
335        switch (Lx.Sym){
336          case syQuestion: Tb->PutVal(TupN, VarN, TTbVal(tvtUnknw)); break;
337          case syAsterisk: Tb->PutVal(TupN, VarN, TTbVal(tvtUnimp)); break;
338          case sySlash: Tb->PutVal(TupN, VarN, TTbVal(tvtUnapp)); break;
339          case syStr: Tb->PutDsc(TupN, VarN, Lx.Str); break;
340          case syFlt: Tb->PutFlt(TupN, VarN, Lx.Flt); break;
341          default: Fail;
342        }
343      }
344      Lx.GetSym(syEoln, syEof);
345      while (Lx.Sym==syEoln){Lx.GetSym(TFSet(ValSymSet)|syEoln|syEof);}
346    }
347    Tb->DefVarTypes();
348    return Tb;
349  }
350  void TTb::SaveTxt(const TStr& FNm, const bool& SaveTupNm){
351    TOLx Lx(PSOut(new TFOut(FNm)), TFSet()|oloFrcEoln|oloSigNum|oloUniStr|oloTabSep);
352    if (SaveTupNm){Lx.PutStr("Name");}
353    for (int VarN=0; VarN<GetVars(); VarN++){
354      Lx.PutStr(GetVar(VarN)->GetNm());}
355    Lx.PutLn();
356    for (int TupN=0; TupN<GetTups(); TupN++){
357      if (SaveTupNm){Lx.PutStr(GetTupNm(TupN));}
358      for (int VarN=0; VarN<GetVars(); VarN++){
359        TTbVal Val=GetVal(TupN, VarN);
360        switch (Val.GetValTag()){
361          case tvtUnknw: Lx.PutSym(syQuestion); break;
362          case tvtUnimp: Lx.PutSym(syAsterisk); break;
363          case tvtUnapp: Lx.PutSym(sySlash); break;
364          case tvtDsc: Lx.PutStr(GetVar(VarN)->GetVarType()->GetValStr(Val)); break;
365          case tvtFlt: Lx.PutFlt(Val.GetFlt()); break;
366          default: Fail;
367        }
368      }
369      Lx.PutLn();
370    }
371  }
372  void TTb::SaveAssis(const TStr& FNm){
373    TStr DoFNm=FNm.GetFPath()+"AsDo"+FNm.GetFMid().GetSubStr(0, 3)+".Dat";
374    TStr DaFNm=FNm.GetFPath()+"AsDa"+FNm.GetFMid().GetSubStr(0, 3)+".Dat";
375    TOLx DoLx(PSOut(new TFOut(DoFNm)), TFSet()|oloFrcEoln|oloSigNum|oloUniStr);
376    int Dscs=GetVar(0)->GetVarType()->GetDscs(); Assert(Dscs>0);
377    DoLx.PutInt(Dscs); DoLx.PutDosLn();
378    for (int DscN=0; DscN<Dscs; DscN++){
379      TTbVal Val=GetVar(0)->GetVarType()->GetVal(DscN);
380      DoLx.PutStr(GetVar(0)->GetVarType()->GetValStr(Val)); DoLx.PutDosLn();
381    }
382    DoLx.PutInt(TInt(GetVars()-1)); DoLx.PutDosLn();
383    for (int VarN=1; VarN<GetVars(); VarN++){
384      DoLx.PutStr(GetVar(VarN)->GetNm()); DoLx.PutDosLn();
385      int Dscs=GetVar(VarN)->GetVarType()->GetDscs();
386      if (Dscs>0){
387        DoLx.PutInt(Dscs); DoLx.PutDosLn();
388        for (int DscN=0; DscN<Dscs; DscN++){
389          TTbVal Val=GetVar(VarN)->GetVarType()->GetVal(DscN);
390          DoLx.PutStr(GetVar(VarN)->GetVarType()->GetValStr(DscN)); DoLx.PutDosLn();}
391      } else {
392        DoLx.PutInt(TInt(0)); DoLx.PutInt(TInt(100)); DoLx.PutDosLn();
393      }
394    }
395    TOLx DaLx(PSOut(new TFOut(DaFNm)), TFSet()|oloFrcEoln|oloSigNum|oloUniStr);
396    for (int TupN=0; TupN<GetTups(); TupN++){
397      for (int VarN=0; VarN<GetVars(); VarN++){
398        TTbVal Val=GetVal(TupN, VarN);
399        switch (Val.GetValTag()){
400          case tvtUnknw: DaLx.PutSym(syQuestion); break;
401          case tvtUnimp: DaLx.PutSym(syAsterisk); break;
402          case tvtUnapp: DaLx.PutSym(syAsterisk); break;
403          case tvtDsc: DaLx.PutInt(TInt(1+Val.GetDsc())); break;
404          case tvtFlt: DaLx.PutFlt(Val.GetFlt()); break;
405          default: Fail;
406        }
407      }
408      DaLx.PutDosLn();
409    }
410  }
411  int TGTb::AddVar(const PTbVar& TbVar){
412    Assert(GetTups()==0);
413    TStr UniqNm=TbVar->GetNm();
414    if (UniqNm.Empty()){UniqNm=TStr("A")+TInt::GetStr(VarV.Len());}
415    if (VarNmToNH.IsKey(UniqNm)){
416      int CopyN=2;
417      while (VarNmToNH.IsKey(UniqNm+" ("+TInt::GetStr(CopyN)+")")){CopyN++;}
418      UniqNm=UniqNm+" ("+TInt::GetStr(CopyN)+")";
419    }
420    Assert(!VarNmToNH.IsKey(UniqNm));
421    int VarN=VarV.Add(PTbVar(new TGTbVar(UniqNm, TbVar->GetVarType())));
422    VarNmToNH.AddDat(UniqNm, VarN);
423    return VarN;
424  }
425  void TGTb::DefVarTypes(){
426    for (int VarN=0; VarN<GetVars(); VarN++){VarV[VarN]->DefVarType();}
427  }
428  int TGTb::AddTup(const TStr& Nm){
429    Assert(GetVars()>0);
430    TStr UniqNm=Nm;
431    if (UniqNm.Empty()){UniqNm=TStr("E")+TInt::GetStr(TupV.Len());}
432    if (TupNmToNH.IsKey(UniqNm)){
433      int CopyN=2;
434      while (TupNmToNH.IsKey(UniqNm+" ("+TInt::GetStr(CopyN)+")")){CopyN++;}
435      UniqNm=UniqNm+" ("+TInt::GetStr(CopyN)+")";
436    }
437    Assert(!TupNmToNH.IsKey(UniqNm));
438    int TupN=TupV.Add(PTbTup(new TGTbTup(UniqNm, GetVars())));
439    TupNmToNH.AddDat(UniqNm, TupN);
440    return TupN;
441  }
442  TStr TGTb::GetValStr(const int& TupN, const int& VarN){
443    return VarV[VarN]->GetVarType()->GetValStr(TupV[TupN]->GetVal(VarN));
444  }
445  int TBTb::AddVar(const PTbVar& TbVar){
446    Assert(GetTups()==0);
447    TStr UniqNm=TbVar->GetNm();
448    if (UniqNm.Empty()){UniqNm=TStr("A")+TInt::GetStr(VarNmToNH.Len());}
449    if (VarNmToNH.IsKey(UniqNm)){
450      int CopyN=2;
451      while (VarNmToNH.IsKey(UniqNm+" ("+TInt::GetStr(CopyN)+")")){CopyN++;}
452      UniqNm=UniqNm+" ("+TInt::GetStr(CopyN)+")";
453    }
454    Assert(!VarNmToNH.IsKey(UniqNm));
455    IAssert(TbVar->GetVarType()==TTbVarType::GetDscBoolVarType());
456    int VarN=VarNmToNH.Len();
457    VarNmToNH.AddDat(UniqNm, VarN);
458    return VarN;
459  }
460  int TBTb::AddTup(const TStr& Nm){
461    Assert(GetVars()>0);
462    TStr UniqNm=Nm;
463    if (UniqNm.Empty()){UniqNm=TStr("E")+TInt::GetStr(TupV.Len());}
464    if (TupNmToNH.IsKey(UniqNm)){
465      int CopyN=2;
466      while (TupNmToNH.IsKey(UniqNm+" ("+TInt::GetStr(CopyN)+")")){CopyN++;}
467      UniqNm=UniqNm+" ("+TInt::GetStr(CopyN)+")";
468    }
469    Assert(!TupNmToNH.IsKey(UniqNm));
470    int TupN=0;
471    TupNmToNH.AddDat(UniqNm, TupN);
472    return TupN;
473  }
474  TStr TBTb::GetValStr(const int& TupN, const int& VarN){
475    return VarV[VarN]->GetVarType()->GetValStr(TupV[TupN]->GetVal(VarN));
476  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-spinn3r.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tb.cpp</div>
                </div>
                <div class="column column_space"><pre><code>428  void TQuoteExtractor::SaveToXml() {
429    fprintf(FOut, "<post>\n");
430    fprintf(FOut, "<pubDate>%s</pubDate>\n", TXmlLx::GetXmlStrFromPlainStr(PubTm.GetDtTmSortStr()).CStr());
431    fprintf(FOut, "<postUrl>%s</postUrl>\n", TXmlLx::GetXmlStrFromPlainStr(PostUrlStr).CStr());
432    fprintf(FOut, "<postTitle>%s</postTitle>\n", TXmlLx::GetXmlStrFromPlainStr(PostTitleStr).CStr());
433    fprintf(FOut, "<blogUrl>%s</blogUrl>\n", TXmlLx::GetXmlStrFromPlainStr(BlogUrlStr).CStr());
434    fprintf(FOut, "<blogTitle>%s</blogTitle>\n", TXmlLx::GetXmlStrFromPlainStr(BlogTitleStr).CStr());
435    fprintf(FOut, "<content>%s</content>\n", TXmlLx::GetXmlStrFromPlainStr(PostText).CStr());
436    for (int q = 0; q < QuoteV.Len(); q++) {
437      fprintf(FOut, "<q>%s</q>\n", TXmlLx::GetXmlStrFromPlainStr(QuoteV[q]).CStr()); }
438    for (int l = 0; l < LinkV.Len(); l++) {
</pre></code></div>
                <div class="column column_space"><pre><code>193  void TTb::AddTb(const PTb& Tb){
194    Assert(GetVars()==Tb->GetVars());
195    for (int VarN=0; VarN<GetVars(); VarN++){
196      Assert(*GetVar(VarN)==*(Tb->GetVar(VarN)));
197    }
198    for (int SrcTupN=0; SrcTupN<Tb->GetTups(); SrcTupN++){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    