
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</h3>
            <pre><code>1  #ifdef GLib_LINUX
2  extern "C" {
3  	#include <sys/mman.h>
4  }
5  #endif
6  const int TCs::MxMask=0x0FFFFFFF;
7  TCs TCs::GetCsFromBf(char* Bf, const int& BfL){
8    TCs Cs;
9    for (int BfC=0; BfC<BfL; BfC++){Cs+=Bf[BfC];}
10    return Cs;
11  }
12  TStr TSBase::GetSNm() const {
13    return TStr(SNm.CStr());
14  }
15  TSIn::TSIn(const TStr& Str) : TSBase(Str.CStr()), FastMode(false){}
16  void TSIn::LoadCs(){
17    TCs CurCs=Cs; TCs TestCs;
18    Cs+=GetBf(&TestCs, sizeof(TestCs));
19    EAssertR(CurCs==TestCs, "Invalid checksum reading '"+GetSNm()+"'.");
20  }
21  void TSIn::Load(char*& CStr){
22    char Ch; Load(Ch);
23    int CStrLen=int(Ch);
24    EAssertR(CStrLen>=0, "Error reading stream '"+GetSNm()+"'.");
25    CStr=new char[CStrLen+1];
26    if (CStrLen>0){Cs+=GetBf(CStr, CStrLen);}
27    CStr[CStrLen]=TCh::NullCh;
28  }
29  bool TSIn::GetNextLn(TStr& LnStr){
30    TChA LnChA;
31    const bool IsNext=GetNextLn(LnChA);
32    LnStr=LnChA;
33    return IsNext;
34  }
35  bool TSIn::GetNextLn(TChA& LnChA){
36    LnChA.Clr();
37    while (!Eof()){
38      const char Ch=GetCh();
39      if (Ch=='\n'){return true;}
40      if (Ch=='\r' && PeekCh()=='\n'){GetCh(); return true;}
41      LnChA.AddCh(Ch);
42    }
43    return !LnChA.Empty();
44  }
45  const PSIn TSIn::StdIn=PSIn(new TStdIn());
46  TStdIn::TStdIn(): TSBase("Standard input"), TSIn("Standard input") {}
47  TSOut::TSOut(const TStr& Str):
48    TSBase(Str.CStr()), MxLnLen(-1), LnLen(0){}
49  int TSOut::UpdateLnLen(const int& StrLen, const bool& ForceInLn){
50    int Cs=0;
51    if (MxLnLen!=-1){
52      if ((!ForceInLn)&&(LnLen+StrLen>MxLnLen)){Cs+=PutLn();}
53      LnLen+=StrLen;
54    }
55    return Cs;
56  }
57  int TSOut::PutMem(const TMem& Mem){
58    return PutBf(Mem(), Mem.Len());
59  }
60  int TSOut::PutCh(const char& Ch, const int& Chs){
61    int Cs=0;
62    for (int ChN=0; ChN<Chs; ChN++){Cs+=PutCh(Ch);}
63    return Cs;
64  }
65  int TSOut::PutBool(const bool& Bool){
66    return PutStr(TBool::GetStr(Bool));
67  }
68  int TSOut::PutInt(const int& Int){
69    return PutStr(TInt::GetStr(Int));
70  }
71  int TSOut::PutInt(const int& Int, const char* FmtStr){
72    return PutStr(TInt::GetStr(Int, FmtStr));
73  }
74  int TSOut::PutUInt(const uint& UInt){
75    return PutStr(TUInt::GetStr(UInt));
76  }
77  int TSOut::PutUInt(const uint& UInt, const char* FmtStr){
78    return PutStr(TUInt::GetStr(UInt, FmtStr));
79  }
80  int TSOut::PutFlt(const double& Flt){
81    return PutStr(TFlt::GetStr(Flt));
82  }
83  int TSOut::PutFlt(const double& Flt, const char* FmtStr){
84    return PutStr(TFlt::GetStr(Flt, FmtStr));
85  }
86  int TSOut::PutStr(const char* CStr){
87    int Cs=UpdateLnLen(int(strlen(CStr)));
88    return Cs+PutBf(CStr, int(strlen(CStr)));
89  }
90  int TSOut::PutStr(const TChA& ChA){
91    int Cs=UpdateLnLen(ChA.Len());
92    return Cs+PutBf(ChA.CStr(), ChA.Len());
93  }
94  int TSOut::PutStr(const TStr& Str, const char* FmtStr){
95    return PutStr(TStr::GetStr(Str, FmtStr));
96  }
97  int TSOut::PutStr(const TStr& Str, const bool& ForceInLn){
98    int Cs=UpdateLnLen(Str.Len(), ForceInLn);
99    return Cs+PutBf(Str.CStr(), Str.Len());
100  }
101  int TSOut::PutStrFmt(const char *FmtStr, ...){
102    char Bf[10*1024];
103    va_list valist;
104    va_start(valist, FmtStr);
105    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
106    va_end(valist);
107    return RetVal!=-1 ? PutStr(TStr(Bf)) : 0;	
108  }
109  int TSOut::PutStrFmtLn(const char *FmtStr, ...){
110    char Bf[10*1024];
111    va_list valist;
112    va_start(valist, FmtStr);
113    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
114    va_end(valist);
115    return RetVal!=-1 ? PutStrLn(TStr(Bf)) : PutLn();	
116  }
117  int TSOut::PutIndent(const int& IndentLev){
118    return PutCh(' ', IndentLev*2);
119  }
120  int TSOut::PutLn(const int& Lns){
121    LnLen=0; int Cs=0;
122    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh('\n');}
123    return Cs;
124  }
125  int TSOut::PutDosLn(const int& Lns){
126    LnLen=0; int Cs=0;
127    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh(TCh::CrCh)+PutCh(TCh::LfCh);}
128    return Cs;
129  }
130  int TSOut::PutSep(const int& NextStrLen){
131    int Cs=0;
132    if (MxLnLen==-1){
133      Cs+=PutCh(' ');
134    } else {
135      if (LnLen>0){
136        if (LnLen+1+NextStrLen>MxLnLen){Cs+=PutLn();} else {Cs+=PutCh(' ');}
137      }
138    }
139    return Cs;
140  }
141  int TSOut::PutSepLn(const int& Lns){
142    int Cs=0;
143    if (LnLen>0){Cs+=PutLn();}
144    Cs+=PutLn(Lns);
145    return Cs;
146  }
147  void TSOut::Save(const char* CStr){
148    int CStrLen=int(strlen(CStr));
149    EAssertR(CStrLen<=127, "Error writting stream '"+GetSNm()+"'.");
150    Save(char(CStrLen));
151    if (CStrLen>0){Cs+=PutBf(CStr, CStrLen);}
152  }
153  void TSOut::Save(TSIn& SIn, const TSize& BfL){
154    Fail;
155    if (BfL==0){ 
156      while (!SIn.Eof()){Save(SIn.GetCh());}
157    } else {
158      for (TSize BfC=0; BfC<BfL; BfC++){Save(SIn.GetCh());}
159    }
160  }
161  TSOut& TSOut::operator<<(TSIn& SIn) {
162    while (!SIn.Eof())
163      operator<<((char)SIn.GetCh());
164    return *this;
165  }
166  const PSOut TSOut::StdOut=PSOut(new TStdOut());
167  TStdOut::TStdOut(): TSBase(TSStr("Standard output")), TSOut("Standard output"){}
168  int TStdIn::GetBf(const void* LBf, const TSize& LBfL){
169    int LBfS=0;
170    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
171      LBfS+=(((char*)LBf)[LBfC]=GetCh());}
172    return LBfS;
173  }
174  bool TStdIn::GetNextLnBf(TChA& LnChA){
175    FailR(TStr::Fmt("TStdIn::GetNextLnBf: not implemented").CStr());
176    return false;
177  }
178  int TStdOut::PutBf(const void* LBf, const TSize& LBfL){
179    int LBfS=0;
180    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
181      LBfS+=PutCh(((char*)LBf)[LBfC]);}
182    return LBfS;
183  }
184  const int TFIn::MxBfL=16*1024;
185  void TFIn::SetFPos(const int& FPos) const {
186    EAssertR(
187     fseek(FileId, FPos, SEEK_SET)==0,
188     "Error seeking into file '"+GetSNm()+"'.");
189  }
190  int TFIn::GetFPos() const {
191    const int FPos=(int)ftell(FileId);
192    EAssertR(FPos!=-1, "Error seeking into file '"+GetSNm()+"'.");
193    return FPos;
194  }
195  int TFIn::GetFLen() const {
196    const int FPos=GetFPos();
197    EAssertR(
198     fseek(FileId, 0, SEEK_END)==0,
199     "Error seeking into file '"+GetSNm()+"'.");
200    const int FLen=GetFPos(); SetFPos(FPos);
201    return FLen;
202  }
203  void TFIn::FillBf(){
204    EAssertR(
205     (BfC==BfL)&&((BfL==-1)||(BfL==MxBfL)),
206     "Error reading file '"+GetSNm()+"'.");
207    BfL=int(fread(Bf, 1, MxBfL, FileId));
208    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
209    BfC=0;
210  }
211  TFIn::TFIn(const TStr& FNm):
212    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
213    EAssertR(!FNm.Empty(), "Empty file-name.");
214    FileId=fopen(FNm.CStr(), "rb");
215    EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
216    Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();
217  }
218  TFIn::TFIn(const TStr& FNm, bool& OpenedP):
219    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
220    EAssertR(!FNm.Empty(), "Empty file-name.");
221    FileId=fopen(FNm.CStr(), "rb");
222    OpenedP=(FileId!=NULL);
223    if (OpenedP){
224      Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();}
225  }
226  PSIn TFIn::New(const TStr& FNm){
227    try {
228      return PSIn(new TFIn(FNm));
229    } catch (PExcept& Except) {
230      printf("*** Exception: %s\n", Except->GetMsgStr().CStr());
231      EFailR(Except->GetMsgStr());
232    }
233    return PSIn(new TFIn(FNm));
234  }
235  PSIn TFIn::New(const TStr& FNm, bool& OpenedP){
236    return PSIn(new TFIn(FNm, OpenedP));
237  }
238  TFIn::~TFIn(){
239    if (FileId!=NULL){
240      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
241    if (Bf!=NULL){delete[] Bf;}
242  }
243  int TFIn::GetBf(const void* LBf, const TSize& LBfL){
244    int LBfS=0;
245    if (TSize(BfC+LBfL)>TSize(BfL)){
246      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
247        if (BfC==BfL){FillBf();}
248        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
249    } else {
250      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
251        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
252    }
253    return LBfS;
254  }
255  bool TFIn::GetNextLnBf(TChA& LnChA) {
256    int Status;
257    int BfN;        
258    int BfP;        
259    bool CrEnd;     
260    LnChA.Clr();
261    CrEnd = false;
262    do {
263      if (BfC >= BfL) {
264        BfP = 0;
265      } else {
266        BfP = BfC;
267      }
268      Status = FindEol(BfN,CrEnd);
269      if (Status >= 0) {
270        if (BfN-BfP > 0) {
271          LnChA.AddBf(&Bf[BfP],BfN-BfP);
272        }
273        if (Status == 1) {
274          return true;
275        }
276      }
277    } while (Status == 0);
278    return !LnChA.Empty();
279  }
280  int TFIn::FindEol(int& BfN, bool& CrEnd) {
281    char Ch;
282    if (BfC >= BfL) {
283      if (Eof()) {
284        return -1;
285      }
286      if (CrEnd && Bf[BfC]=='\n') {
287        BfC++;
288        BfN = BfC-1;
289        return 1;
290      }
291    }
292    CrEnd = false;
293    while (BfC < BfL) {
294      Ch = Bf[BfC++];
295      if (Ch=='\n') {
296        BfN = BfC-1;
297        return 1;
298      }
299      if (Ch=='\r') {
300        if (BfC == BfL) {
301          CrEnd = true;
302          BfN = BfC-1;
303          return 0;
304        } else if (Bf[BfC]=='\n') {
305          BfC++;
306          BfN = BfC-2;
307          return 1;
308        }
309      }
310    }
311    BfN = BfC;
312    return 0;
313  }
314  const TSize TFOut::MxBfL=16*1024;;
315  void TFOut::FlushBf(){
316    EAssertR(
317     fwrite(Bf, 1, BfL, FileId)==BfL,
318     "Error writting to the file '"+GetSNm()+"'.");
319    BfL=0;
320  }
321  TFOut::TFOut(const TStr& FNm, const bool& Append):
322    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
323    if (FNm.GetUc()=="CON"){
324      FileId=stdout;
325    } else {
326      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
327      else {FileId=fopen(FNm.CStr(), "w+b");}
328      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
329      Bf=new char[MxBfL]; BfL=0;
330    }
331  }
332  TFOut::TFOut(const TStr& FNm, const bool& Append, bool& OpenedP):
333    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
334    if (FNm.GetUc()=="CON"){
335      FileId=stdout;
336    } else {
337      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
338      else {FileId=fopen(FNm.CStr(), "w+b");}
339      OpenedP=(FileId!=NULL);
340      if (OpenedP){
341        Bf=new char[MxBfL]; BfL=0;}
342    }
343  }
344  PSOut TFOut::New(const TStr& FNm, const bool& Append){
345    return PSOut(new TFOut(FNm, Append));
346  }
347  PSOut TFOut::New(const TStr& FNm, const bool& Append, bool& OpenedP){
348    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
349    if (OpenedP){return SOut;} else {return NULL;}
350  }
351  TFOut::~TFOut(){
352    if (FileId!=NULL){FlushBf();}
353    if (Bf!=NULL){delete[] Bf;}
354    if (FileId!=NULL){
355      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
356  }
357  int TFOut::PutCh(const char& Ch){
358    if (BfL==TSize(MxBfL)){FlushBf();}
359    return Bf[BfL++]=Ch;
360  }
361  int TFOut::PutBf(const void* LBf, const TSize& LBfL){
362    int LBfS=0;
363    if (BfL+LBfL>MxBfL){
364      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
365        LBfS+=PutCh(((char*)LBf)[LBfC]);}
366    } else {
367      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
368        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
369    }
370    return LBfS;
371  }
372  void TFOut::Flush(){
373    FlushBf();
374    EAssertR(fflush(FileId)==0, "Can not flush file '"+GetSNm()+"'.");
375  }
376  TFInOut::TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) :
377   TSBase(TSStr(FNm.CStr())), FileId(NULL) {
378    switch (FAccess){
379      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
380      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
381      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
382        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
383      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
384      default: Fail;
385    }
386    if ((FileId==NULL)&&(CreateIfNo)){FileId=fopen(FNm.CStr(), "w+b");}
387    IAssert(FileId!=NULL);
388  }
389  PSInOut TFInOut::New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) {
390    return PSInOut(new TFInOut(FNm, FAccess, CreateIfNo));
391  }
392  int TFInOut::GetSize() const {
393    const int FPos = GetPos();
394    IAssert(fseek(FileId, 0, SEEK_END) == 0);
395    const int FLen = GetPos();
396    IAssert(fseek(FileId, FPos, SEEK_SET) == 0);
397    return FLen;
398  }
399  int TFInOut::PutBf(const void* LBf, const TSize& LBfL) {
400    int LBfS = 0;
401    for (TSize i = 0; i < LBfL; i++) {
402      LBfS += ((char *)LBf)[i];
403    }
404    IAssert(fwrite(LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
405    return LBfS;
406  }
407  int TFInOut::GetBf(const void* LBf, const TSize& LBfL) {
408    IAssert(fread((void *)LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
409    int LBfS = 0;
410    for (TSize i = 0; i < LBfL; i++) {
411      LBfS += ((char *)LBf)[i];
412    }
413    return LBfS;
414  }
415  bool TFInOut::GetNextLnBf(TChA& LnChA){
416    FailR(TStr::Fmt("TFInOut::GetNextLnBf: not implemented").CStr());
417    return false;
418  }
419  TStr TFInOut::GetFNm() const {
420    return GetSNm();
421  }
422  TShMIn::TShMIn(const TStr& Str): TSBase("Input-Shared_Memory"), 
423      TSIn("Input-Shared_Memory"), TotalLength(0),
424      SizeLeft(0) {
425  #ifdef GLib_LINUX
426        TStr FNm = Str;
427        TFileId FileId;
428        int fd;
429        uint64 FLen;
430        EAssertR(!FNm.Empty(), "Empty file-name.");
431        FileId=fopen(FNm.CStr(), "rb");
432        fd = fileno(FileId);
433        EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
434        EAssertR(
435            fseek(FileId, 0, SEEK_END)==0,
436            "Error seeking into file '"+TStr(FNm)+"'.");
437        FLen=(uint64)ftell(FileId);
438        EAssertR(
439            fseek(FileId, 0, SEEK_SET)==0,
440            "Error seeking into file '"+TStr(FNm)+"'.");
441        char *Mapped;
442        Mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
443        EAssertR(Mapped!=MAP_FAILED, "mmap failed in TShMIn.");
444        OriginalBuffer = Mapped;
445        Cursor = OriginalBuffer;
446        SizeLeft = FLen;
447        TotalLength = FLen;
448        IsMemoryMapped = true;
449  #else
450        TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
451  #endif
452      }
453  TShMIn::TShMIn(void* _Bf, const TSize& _BfL): TSBase("Input-Shared_Memory"), 
454    TSIn("Input-Shared_Memory"), TotalLength(_BfL), SizeLeft(_BfL), IsMemoryMapped(false) {
455      OriginalBuffer = (char*)_Bf;
456      Cursor = (char*)_Bf;
457    }
458  void TShMIn::CloseMapping() {
459    if (OriginalBuffer!=NULL){
460      if (IsMemoryMapped) {
461  #ifdef GLib_LINUX
462        munmap(OriginalBuffer, TotalLength);
463        IsMemoryMapped = false;
464        OriginalBuffer = NULL;
465        Cursor = NULL;
466        TotalLength= 0;
467        SizeLeft = 0;
468  #endif
469      }
470    }
471  }
472  TMIn::TMIn(const void* _Bf, const uint64& _BfL, const bool& TakeBf):
473    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(_BfL), IsMemoryMapped(false){
474    if (TakeBf){
475      Bf=(char*)_Bf;
476    } else {
477      Bf=new char[static_cast<size_t>(BfL)]; memmove(Bf, _Bf, static_cast<size_t>(BfL));
478    }
479  }
480  TMIn::TMIn(TSIn& SIn):
481    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
482    BfL=SIn.Len(); Bf=new char[static_cast<size_t>(BfL)];
483    for (uint64 BfC=0; BfC<BfL; BfC++){Bf[BfC]=SIn.GetCh();}
484  }
485  TMIn::TMIn(const char* CStr):
486    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
487    BfL=uint64(strlen(CStr)); Bf=new char[static_cast<size_t>(BfL+1)]; strcpy(Bf, CStr);
488  }
489  TMIn::TMIn(const TStr& Str, bool FromFile):
490    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
491    if (FromFile == false) {
492      BfL=Str.Len(); Bf=new char[static_cast<size_t>(BfL)]; strncpy(Bf, Str.CStr(), static_cast<size_t>(BfL));
493      IsMemoryMapped = false;
494    }
495    else {
496  #ifdef GLib_LINUX
497      TStr FNm = Str;
498      TFileId FileId;
499      int fd;
500      uint64 FLen;
501      EAssertR(!FNm.Empty(), "Empty file-name.");
502      FileId=fopen(FNm.CStr(), "rb");
503      fd = fileno(FileId);
504      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
505      EAssertR(
506          fseek(FileId, 0, SEEK_END)==0,
507          "Error seeking into file '"+TStr(FNm)+"'.");
508      FLen=(uint64)ftell(FileId);
509      EAssertR(
510          fseek(FileId, 0, SEEK_SET)==0,
511          "Error seeking into file '"+TStr(FNm)+"'.");
512      char *mapped;
513      mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
514      IsMemoryMapped = true;
515      if (mapped == MAP_FAILED) {
516        printf("mmap failed: %d %s\n", fd, strerror (errno));
517        Bf = NULL;
518        BfC = BfL = 0;
519      }
520      else {
521        Bf = mapped;
522        BfC = 0;
523        BfL = FLen;
524      }
<span onclick='openModal()' class='match'>525      IsMemoryMapped = true;
526  #else
527      TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
528  #endif
529    }
530  }
</span>531  TMIn::TMIn(const TChA& ChA):
532    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
533    BfL=ChA.Len(); Bf=new char[static_cast<size_t>(BfL)]; strncpy(Bf, ChA.CStr(), static_cast<size_t>(BfL));
534  }
535  PSIn TMIn::New(const void* _Bf, const uint64& _BfL, const bool& TakeBf){
536    return PSIn(new TMIn(_Bf, _BfL, TakeBf));
537  }
538  PSIn TMIn::New(const char* CStr){
539    return PSIn(new TMIn(CStr));
540  }
541  PSIn TMIn::New(const TStr& Str){
542    return PSIn(new TMIn(Str));
543  }
544  PMIn TMIn::New(const TStr& Str, bool FromFile){
545    return new TMIn(Str, FromFile);
546  }
547  PSIn TMIn::New(const TChA& ChA){
548    return PSIn(new TMIn(ChA));
549  }
550  TMIn::~TMIn(){
551    if (Bf!=NULL){
552      if (IsMemoryMapped) {
553  #ifdef GLib_LINUX
554        munmap(Bf, BfL);
555  #endif
556      }
557      else {
558        delete[] Bf;
559      }
560    }
561  }
562  char TMIn::GetCh(){
563    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
564    return Bf[BfC++];
565  }
566  char TMIn::PeekCh(){
567    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
568    return Bf[BfC];
569  }
570  int TMIn::GetBf(const void* LBf, const TSize& LBfL){
571    EAssertR(TSize(BfC+LBfL)<=TSize(BfL), "Reading beyond the end of stream.");
572    int LBfS=0;
573    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
574      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
575    return LBfS;
576  }
577  int TMIn::FindEol(uint64& BfN, bool& CrEnd) {
578    char Ch;
579    if (BfC >= BfL) {
580      if (Eof()) {
581        return -1;
582      }
583      if (CrEnd && Bf[BfC]=='\n') {
584        BfC++;
585        BfN = BfC-1;
586        return 1;
587      }
588    }
589    CrEnd = false;
590    while (BfC < BfL) {
591      Ch = Bf[BfC++];
592      if (Ch=='\n') {
593        BfN = BfC-1;
594        return 1;
595      }
596      if (Ch=='\r') {
597        if (BfC == BfL) {
598          CrEnd = true;
599          BfN = BfC-1;
600          return 0;
601        } else if (Bf[BfC]=='\n') {
602          BfC++;
603          BfN = BfC-2;
604          return 1;
605        }
606      }
607    }
608    BfN = BfC;
609    return 0;
610  }
611  bool TMIn::GetNextLnBf(TChA& LnChA){
612    FailR(TStr::Fmt("TMIn::GetNextLnBf: not implemented").CStr());
613    return false;
614  }
615  uint64 TMIn::GetBfC() {
616    return BfC;
617  }
618  uint64 TMIn::GetBfL() {
619    return BfL;
620  }
621  void TMIn::SetBfC(uint64 Pos) {
622    BfC = Pos;
623  }
624  uint64 TMIn::CountNewLinesInRange(uint64 Lb, uint64 Ub) {
625    uint64 Cnt = 0;
626    if (Lb >= BfL) {
627      return 0;
628    }
629    for (uint64 i = Lb; i < Ub; i++) {
630      if (Bf[i] == '\n') {
631        Cnt += 1;
632      }
633    }
634    return Cnt;
635  }
636  uint64 TMIn::GetLineStartPos(uint64 Ind) {
637    while (Ind > 0 && Bf[Ind-1] != '\n') {
638      Ind--;
639    }
640    return Ind;
641  }
642  uint64 TMIn::GetLineEndPos(uint64 Ind) {
643    while (Ind < BfL && Bf[Ind] != '\n') {
644      Ind++;
645    }
646    if (Ind == BfL) Ind--;
647    return Ind;
648  }
649  char* TMIn::GetLine(uint64 Index) {
650    return &Bf[Index];
651  }
652  void TMIn::SkipCommentLines() {
653    while (BfC < BfL && TCh::IsHashCh(Bf[BfC])) {
654      while (BfC < BfL && Bf[BfC] != '\n') {
655        BfC++;
656      }
657      BfC++;
658    }
659  }
660  void TMOut::Resize(const int& ReqLen){
661    IAssert(OwnBf&&(BfL==MxBfL || ReqLen >= 0));
662    if (Bf==NULL){
663      IAssert(MxBfL==0); 
664      if (ReqLen < 0) Bf=new char[MxBfL=1024];
665      else Bf=new char[MxBfL=ReqLen];
666    } else {
667      if (ReqLen < 0){ MxBfL*=2; }
668      else if (ReqLen < MxBfL){ return; } 
669      else { MxBfL=(2*MxBfL < ReqLen ? ReqLen : 2*MxBfL); }
670      char* NewBf=new char[MxBfL];
671      memmove(NewBf, Bf, BfL); delete[] Bf; Bf=NewBf;
672    }
673  }
674  TMOut::TMOut(const int& _MxBfL):
675    TSBase("Output-Memory"), TSOut("Output-Memory"),
676    Bf(NULL), BfL(0), MxBfL(0), OwnBf(true){
677    MxBfL=_MxBfL>0?_MxBfL:1024;
678    Bf=new char[MxBfL];
679  }
680  TMOut::TMOut(char* _Bf, const int& _MxBfL):
681    TSBase("Output-Memory"), TSOut("Output-Memory"),
682    Bf(_Bf), BfL(0), MxBfL(_MxBfL), OwnBf(false){}
683  void TMOut::AppendBf(const void* LBf, const TSize& LBfL) {
684    Resize(Len() + (int)LBfL);
685    memcpy(Bf + BfL, LBf, LBfL);
686    BfL += (int)LBfL;
687  }
688  int TMOut::PutBf(const void* LBf, const TSize& LBfL){
689    int LBfS=0;
690    if (TSize(BfL+LBfL)>TSize(MxBfL)){
691      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
692        LBfS+=PutCh(((char*)LBf)[LBfC]);}
693    } else {
694      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
695        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
696    }
697    return LBfS;
698  }
699  TStr TMOut::GetAsStr() const {
700    TChA ChA(BfL);
701    for (int BfC=0; BfC<BfL; BfC++){ChA+=Bf[BfC];}
702    return ChA;
703  }
704  void TMOut::CutBf(const int& CutBfL){
705    IAssert((0<=CutBfL)&&(CutBfL<=BfL));
706    if (CutBfL==BfL){BfL=0;}
707    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
708  }
709  PSIn TMOut::GetSIn(const bool& IsCut, const int& CutBfL){
710    IAssert((CutBfL==-1)||((0<=CutBfL)));
711    int SInBfL= (CutBfL==-1) ? BfL : TInt::GetMn(BfL, CutBfL);
712    PSIn SIn;
713    if (OwnBf&&IsCut&&(SInBfL==BfL)){
714      SIn=PSIn(new TMIn(Bf, SInBfL, true));
715      Bf=NULL; BfL=MxBfL=0; OwnBf=true;
716    } else {
717      SIn=PSIn(new TMIn(Bf, SInBfL, false));
718      if (IsCut){CutBf(SInBfL);}
719    }
720    return SIn;
721  }
722  bool TMOut::IsCrLfLn() const {
723    for (int BfC=0; BfC<BfL; BfC++){
724      if ((Bf[BfC]==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){return true;}}
725    return false;
726  }
727  TStr TMOut::GetCrLfLn(){
728    IAssert(IsCrLfLn());
729    TChA Ln;
730    for (int BfC=0; BfC<BfL; BfC++){
731      char Ch=Bf[BfC];
732      if ((Ch==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){
733        Ln+=TCh::CrCh; Ln+=TCh::LfCh; CutBf(BfC+1+1); break;
734      } else {
735        Ln+=Ch;
736      }
737    }
738    return Ln;
739  }
740  bool TMOut::IsEolnLn() const {
741    for (int BfC=0; BfC<BfL; BfC++){
742      if ((Bf[BfC]==TCh::CrCh)||(Bf[BfC]==TCh::LfCh)){return true;}
743    }
744    return false;
745  }
746  TStr TMOut::GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf){
747    IAssert(IsEolnLn());
748    int LnChs=0; TChA Ln;
749    for (int BfC=0; BfC<BfL; BfC++){
750      char Ch=Bf[BfC];
751      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
752        LnChs++; if (DoAddEoln){Ln+=Ch;}
753        if (BfC+1<BfL){
754          char NextCh=Bf[BfC+1];
755          if (((Ch==TCh::CrCh)&&(NextCh==TCh::LfCh))||
756           ((Ch==TCh::LfCh)&&(NextCh==TCh::CrCh))){
757            LnChs++; if (DoAddEoln){Ln+=NextCh;}
758          }
759        }
760        break;
761      } else {
762        LnChs++; Ln+=Ch;
763      }
764    }
765    if (DoCutBf){
766      CutBf(LnChs);
767    }
768    return Ln;
769  }
770  void TMOut::MkEolnLn(){
771    if (!IsEolnLn()){
772      PutCh(TCh::CrCh); PutCh(TCh::LfCh);}
773  }
774  bool TLnRet::NextLn(TStr& LnStr) {
775      if (SIn->Eof()) { return false; }
776      TChA LnChA; char Ch = TCh::EofCh;
777      while (!SIn->Eof() && ((Ch=SIn->GetCh())!='\n')) {
778          if (Ch != '\r') { LnChA += Ch; }
779      }
780      LnStr = LnChA; return true;
781  }
782  #ifndef SEEK_SET
783  #define SEEK_CUR    1
784  #define SEEK_END    2
785  #define SEEK_SET    0
786  #endif
787  void TFRnd::RefreshFPos(){
788    EAssertR(
789     fseek(FileId, 0, SEEK_CUR)==0,
790     "Error seeking into file '"+TStr(FNm)+"'.");
791  }
792  TFRnd::TFRnd(const TStr& _FNm, const TFAccess& FAccess,
793   const bool& CreateIfNo, const int& _HdLen, const int& _RecLen):
794    FileId(NULL), FNm(_FNm.CStr()),
795    RecAct(false), HdLen(_HdLen), RecLen(_RecLen){
796    RecAct=(HdLen>=0)&&(RecLen>0);
797    switch (FAccess){
798      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
799      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
800      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
801        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
802      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
803      default: Fail;
804    }
805    if ((FileId==NULL)&&(CreateIfNo)){
806      FileId=fopen(FNm.CStr(), "w+b");}
807    EAssertR(FileId!=NULL, "Can not open file '"+_FNm+"'.");
808  }
809  TFRnd::~TFRnd(){
810    EAssertR(fclose(FileId)==0, "Can not close file '"+TStr(FNm)+"'.");
811  }
812  TStr TFRnd::GetFNm() const {
813    return FNm.CStr();
814  }
815  void TFRnd::SetFPos(const int& FPos){
816    EAssertR(
817     fseek(FileId, FPos, SEEK_SET)==0,
818     "Error seeking into file '"+TStr(FNm)+"'.");
819  }
820  void TFRnd::MoveFPos(const int& DFPos){
821    EAssertR(
822     fseek(FileId, DFPos, SEEK_CUR)==0,
823     "Error seeking into file '"+TStr(FNm)+"'.");
824  }
825  int TFRnd::GetFPos(){
826    int FPos= (int) ftell(FileId);
827    EAssertR(FPos!=-1, "Error seeking into file '"+TStr(FNm)+"'.");
828    return FPos;
829  }
830  int TFRnd::GetFLen(){
831    int FPos=GetFPos();
832    EAssertR(
833     fseek(FileId, 0, SEEK_END)==0,
834     "Error seeking into file '"+TStr(FNm)+"'.");
835    int FLen=GetFPos(); SetFPos(FPos); return FLen;
836  }
837  void TFRnd::SetRecN(const int& RecN){
838    IAssert(RecAct);
839    SetFPos(HdLen+RecN*RecLen);
840  }
841  int TFRnd::GetRecN(){
842    IAssert(RecAct);
843    int FPos=GetFPos()-HdLen;
844    EAssertR(FPos%RecLen==0, "Invalid position in file'"+TStr(FNm)+"'.");
845    return FPos/RecLen;
846  }
847  int TFRnd::GetRecs(){
848    IAssert(RecAct);
849    int FLen=GetFLen()-HdLen;
850    EAssertR(FLen%RecLen==0, "Invalid length of file'"+TStr(FNm)+"'.");
851    return FLen/RecLen;
852  }
853  void TFRnd::GetBf(void* Bf, const TSize& BfL){
854    RefreshFPos();
855    EAssertR(
856     fread(Bf, 1, BfL, FileId)==BfL,
857     "Error reading file '"+TStr(FNm)+"'.");
858  }
859  void TFRnd::PutBf(const void* Bf, const TSize& BfL){
860    RefreshFPos();
861    EAssertR(
862     fwrite(Bf, 1, BfL, FileId)==BfL,
863     "Error writting to the file '"+TStr(FNm)+"'.");
864  }
865  void TFRnd::Flush(){
866    EAssertR(fflush(FileId)==0, "Can not flush file '"+TStr(FNm)+"'.");
867  }
868  void TFRnd::PutCh(const char& Ch, const int& Chs){
869    if (Chs>0){
870      char* CStr=new char[Chs];
871      for (int ChN=0; ChN<Chs; ChN++){CStr[ChN]=Ch;}
872      PutBf(CStr, Chs);
873      delete[] CStr;
874    }
875  }
876  void TFRnd::PutStr(const TStr& Str){
877    PutBf(Str.CStr(), Str.Len()+1);
878  }
879  TStr TFRnd::GetStr(const int& StrLen, bool& IsOk){
880    IsOk=false; TStr Str;
881    if (GetFPos()+StrLen+1<=GetFLen()){
882      char* CStr=new char[StrLen+1];
883      GetBf(CStr, StrLen+1);
884      if (CStr[StrLen+1-1]==TCh::NullCh){IsOk=true; Str=CStr;}
885      delete[] CStr;
886    }
887    return Str;
888  }
889  TStr TFRnd::GetStr(const int& StrLen){
890    TStr Str;
891    char* CStr=new char[StrLen+1];
892    GetBf(CStr, StrLen+1);
893    EAssertR(CStr[StrLen+1-1]==TCh::NullCh, "Error reading file '"+TStr(FNm)+"'.");
894    Str=CStr;
895    delete[] CStr;
896    return Str;
897  }
898  void TFRnd::PutSIn(const PSIn& SIn, TCs& Cs){
899    int BfL=SIn->Len();
900    char* Bf=new char[BfL];
901    SIn->GetBf(Bf, BfL);
902    Cs=TCs::GetCsFromBf(Bf, BfL);
903    PutBf(Bf, BfL);
904    delete[] Bf;
905  }
906  PSIn TFRnd::GetSIn(const int& BfL, TCs& Cs){
907    char* Bf=new char[BfL];
908    GetBf(Bf, BfL);
909    Cs=TCs::GetCsFromBf(Bf, BfL);
910    PSIn SIn=PSIn(new TMIn(Bf, BfL, true));
911    return SIn;
912  }
913  TStr TFRnd::GetStrFromFAccess(const TFAccess& FAccess){
914    switch (FAccess){
915      case faCreate: return "Create";
916      case faUpdate: return "Update";
917      case faAppend: return "Append";
918      case faRdOnly: return "ReadOnly";
919      case faRestore: return "Restore";
920      default: Fail; return TStr();
921    }
922  }
923  TFAccess TFRnd::GetFAccessFromStr(const TStr& Str){
924    TStr UcStr=Str.GetUc();
925    if (UcStr=="CREATE"){return faCreate;}
926    if (UcStr=="UPDATE"){return faUpdate;}
927    if (UcStr=="APPEND"){return faAppend;}
928    if (UcStr=="READONLY"){return faRdOnly;}
929    if (UcStr=="RESTORE"){return faRestore;}
930    if (UcStr=="NEW"){return faCreate;}
931    if (UcStr=="CONT"){return faUpdate;}
932    if (UcStr=="CONTINUE"){return faUpdate;}
933    if (UcStr=="REST"){return faRestore;}
934    if (UcStr=="RESTORE"){return faRestore;}
935    return faUndef;
936  }
937  const TStr TFile::TxtFExt=".Txt";
938  const TStr TFile::HtmlFExt=".Html";
939  const TStr TFile::HtmFExt=".Htm";
940  const TStr TFile::GifFExt=".Gif";
941  const TStr TFile::JarFExt=".Jar";
942  bool TFile::Exists(const TStr& FNm){
943    if (FNm.Empty()) { return false; }
944    bool DoExists;
945    TFIn FIn(FNm, DoExists);
946    return DoExists;
947  }
948  #if defined(GLib_WIN32)
949  void TFile::Copy(const TStr& SrcFNm, const TStr& DstFNm, 
950   const bool& ThrowExceptP, const bool& FailIfExistsP){
951    if (ThrowExceptP){
952      if (CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP) == 0) {
953          int ErrorCode = (int)GetLastError();
954          TExcept::Throw(TStr::Fmt(
955              "Error %d copying file '%s' to '%s'.", 
956              ErrorCode, SrcFNm.CStr(), DstFNm.CStr()));
957      }
958    } else {
959      CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP);
960    }
961  }
962  #elif defined(GLib_LINUX)
963  void TFile::Copy(const TStr& SrcFNm, const TStr& DstFNm,
964   const bool& ThrowExceptP, const bool& FailIfExistsP){
965  	int input, output;
966  	size_t filesize;
967  	void *source, *target;
968  	if( (input = open(SrcFNm.CStr(), O_RDONLY)) == -1) {
969  		if (ThrowExceptP) {
970  			TExcept::Throw(TStr::Fmt(
971  			            "Error copying file '%s' to '%s': cannot open source file for reading.",
972  			            SrcFNm.CStr(), DstFNm.CStr()));
973  		} else {
974  			return;
975  		}
976  	}
977  	if( (output = open(DstFNm.CStr(), O_RDWR | O_CREAT | O_TRUNC, 0666)) == -1)	{
978  		close(input);
979  		if (ThrowExceptP) {
980  			TExcept::Throw(TStr::Fmt(
981  			            "Error copying file '%s' to '%s': cannot open destination file for writing.",
982  			            SrcFNm.CStr(), DstFNm.CStr()));
983  		} else {
984  			return;
985  		}
986  	}
987  	filesize = lseek(input, 0, SEEK_END);
988  	lseek(output, filesize - 1, SEEK_SET);
989  	write(output, '\0', 1);
990  	if((source = mmap(0, filesize, PROT_READ, MAP_SHARED, input, 0)) == (void *) -1) {
991  		close(input);
992  		close(output);
993  		if (ThrowExceptP) {
994  			TExcept::Throw(TStr::Fmt(
995  						"Error copying file '%s' to '%s': cannot mmap input file.",
996  						SrcFNm.CStr(), DstFNm.CStr()));
997  		} else {
998  			return;
999  		}
1000  	}
1001  	if((target = mmap(0, filesize, PROT_WRITE, MAP_SHARED, output, 0)) == (void *) -1) {
1002  		munmap(source, filesize);
1003  		close(input);
1004  		close(output);
1005  		if (ThrowExceptP) {
1006  			TExcept::Throw(TStr::Fmt(
1007  						"Error copying file '%s' to '%s': cannot mmap output file.",
1008  						SrcFNm.CStr(), DstFNm.CStr()));
1009  		} else {
1010  			return;
1011  		}
1012  	}
1013  	memcpy(target, source, filesize);
1014  	munmap(source, filesize);
1015  	munmap(target, filesize);
1016  	close(input);
1017  	close(output);
1018  }
1019  #endif
1020  void TFile::Del(const TStr& FNm, const bool& ThrowExceptP){
1021    if (ThrowExceptP){
1022      EAssertR(
1023       remove(FNm.CStr())==0,
1024       "Error removing file '"+FNm+"'.");
1025    } else {
1026      remove(FNm.CStr());
1027    }
1028  }
1029  void TFile::DelWc(const TStr& WcStr, const bool& RecurseDirP){
1030    TStrV FNmV;
1031    TFFile FFile(WcStr, RecurseDirP); TStr FNm;
1032    while (FFile.Next(FNm)){
1033      FNmV.Add(FNm);}
1034    for (int FNmN=0; FNmN<FNmV.Len(); FNmN++){
1035      Del(FNmV[FNmN], false);}
1036  }
1037  void TFile::Rename(const TStr& SrcFNm, const TStr& DstFNm){
1038    EAssertR(
1039     rename(SrcFNm.CStr(), DstFNm.CStr())==0,
1040     "Error renaming file '"+SrcFNm+"' to "+DstFNm+"'.");
1041  }
1042  TStr TFile::GetUniqueFNm(const TStr& FNm){
1043    int Cnt=1; int ch;
1044    TStr NewFNm; TStr TmpFNm=FNm;
1045    if (FNm.SearchCh('#') == -1) {
1046      for (ch = FNm.Len()-1; ch >= 0; ch--) if (FNm[ch] == '.') break;
1047      if (ch != -1) TmpFNm.InsStr(ch, ".#");
1048      else TmpFNm += ".#";
1049    }
1050    forever{
1051      NewFNm=TmpFNm;
1052      NewFNm.ChangeStr("#", TStr::Fmt("%03d", Cnt)); Cnt++;
1053      if (!TFile::Exists(NewFNm)){break;}
1054    }
1055    return NewFNm;
1056  }
1057  #ifdef GLib_WIN
1058  uint64 TFile::GetSize(const TStr& FNm) {
1059      HANDLE hFile = CreateFile(
1060         FNm.CStr(),            
1061         GENERIC_READ,          
1062         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1063         NULL,                  
1064         OPEN_EXISTING,         
1065         FILE_ATTRIBUTE_NORMAL, 
1066         NULL);                 
1067      if (hFile == INVALID_HANDLE_VALUE) {
1068          TExcept::Throw("Can not open file " + FNm + "!"); }
1069      LARGE_INTEGER lpFileSizeHigh;
1070  	if (!GetFileSizeEx(hFile, &lpFileSizeHigh)) {
1071          TExcept::Throw("Can not read size of file " + FNm + "!"); }
1072      CloseHandle(hFile);
1073  	return uint64(lpFileSizeHigh.QuadPart);
1074  }
1075  uint64 TFile::GetCreateTm(const TStr& FNm) {
1076      HANDLE hFile = CreateFile(
1077         FNm.CStr(),            
1078         GENERIC_READ,          
1079         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1080         NULL,                  
1081         OPEN_EXISTING,         
1082         FILE_ATTRIBUTE_NORMAL, 
1083         NULL);                 
1084      if (hFile == INVALID_HANDLE_VALUE) {
1085          TExcept::Throw("Can not open file " + FNm + "!"); }
1086      FILETIME lpCreationTime;
1087      if (!GetFileTime(hFile, &lpCreationTime, NULL, NULL)) {
1088          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1089      CloseHandle(hFile);
1090      TUInt64 UInt64(uint(lpCreationTime.dwHighDateTime), 
1091          uint(lpCreationTime.dwLowDateTime));
1092      return UInt64.Val / uint64(10000);
1093  }
1094  uint64 TFile::GetLastAccessTm(const TStr& FNm) {
1095      HANDLE hFile = CreateFile(
1096         FNm.CStr(),            
1097         GENERIC_READ,          
1098         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1099         NULL,                  
1100         OPEN_EXISTING,         
1101         FILE_ATTRIBUTE_NORMAL, 
1102         NULL);                 
1103      if (hFile == INVALID_HANDLE_VALUE) {
1104          TExcept::Throw("Can not open file " + FNm + "!"); }
1105      FILETIME lpLastAccessTime;
1106      if (!GetFileTime(hFile, NULL, &lpLastAccessTime, NULL)) {
1107          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1108      CloseHandle(hFile);
1109      TUInt64 UInt64(uint(lpLastAccessTime.dwHighDateTime), 
1110          uint(lpLastAccessTime.dwLowDateTime));
1111      return UInt64.Val / uint64(10000);
1112  }
1113  uint64 TFile::GetLastWriteTm(const TStr& FNm) {
1114      HANDLE hFile = CreateFile(
1115         FNm.CStr(),            
1116         GENERIC_READ,          
1117         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1118         NULL,                  
1119         OPEN_EXISTING,         
1120         FILE_ATTRIBUTE_NORMAL, 
1121         NULL);                 
1122      if (hFile == INVALID_HANDLE_VALUE) {
1123          TExcept::Throw("Can not open file " + FNm + "!"); }
1124      FILETIME lpLastWriteTime;
1125      if (!GetFileTime(hFile, NULL, NULL, &lpLastWriteTime)) {
1126          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1127      CloseHandle(hFile);
1128      TUInt64 UInt64(uint(lpLastWriteTime.dwHighDateTime), 
1129          uint(lpLastWriteTime.dwLowDateTime));
1130      return UInt64.Val / uint64(10000);
1131  }
1132  #elif defined(GLib_LINUX)
1133  uint64 TFile::GetSize(const TStr& FNm) {
1134  	Fail; return 0;
1135  }
1136  uint64 TFile::GetCreateTm(const TStr& FNm) {
1137  	return GetLastWriteTm(FNm);
1138  }
1139  uint64 TFile::GetLastWriteTm(const TStr& FNm) {
1140  	struct stat st;
1141  	if (stat(FNm.CStr(), &st) != 0) {
1142  		TExcept::Throw("Cannot read tile from file " + FNm + "!");
1143  	}
1144  	return uint64(st.st_mtime);
1145  }
1146  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</h3>
            <pre><code>1  #ifdef GLib_LINUX
2  extern "C" {
3  	#include <sys/mman.h>
4  }
5  #endif
6  const int TCs::MxMask=0x0FFFFFFF;
7  TCs TCs::GetCsFromBf(char* Bf, const int& BfL){
8    TCs Cs;
9    for (int BfC=0; BfC<BfL; BfC++){Cs+=Bf[BfC];}
10    return Cs;
11  }
12  TStr TSBase::GetSNm() const {
13    return TStr(SNm.CStr());
14  }
15  TSIn::TSIn(const TStr& Str) : TSBase(Str.CStr()), FastMode(false){}
16  void TSIn::LoadCs(){
17    TCs CurCs=Cs; TCs TestCs;
18    Cs+=GetBf(&TestCs, sizeof(TestCs));
19    EAssertR(CurCs==TestCs, "Invalid checksum reading '"+GetSNm()+"'.");
20  }
21  void TSIn::Load(char*& CStr){
22    char Ch; Load(Ch);
23    int CStrLen=int(Ch);
24    EAssertR(CStrLen>=0, "Error reading stream '"+GetSNm()+"'.");
25    CStr=new char[CStrLen+1];
26    if (CStrLen>0){Cs+=GetBf(CStr, CStrLen);}
27    CStr[CStrLen]=TCh::NullCh;
28  }
29  bool TSIn::GetNextLn(TStr& LnStr){
30    TChA LnChA;
31    const bool IsNext=GetNextLn(LnChA);
32    LnStr=LnChA;
33    return IsNext;
34  }
35  bool TSIn::GetNextLn(TChA& LnChA){
36    LnChA.Clr();
37    while (!Eof()){
38      const char Ch=GetCh();
39      if (Ch=='\n'){return true;}
40      if (Ch=='\r' && PeekCh()=='\n'){GetCh(); return true;}
41      LnChA.AddCh(Ch);
42    }
43    return !LnChA.Empty();
44  }
45  const PSIn TSIn::StdIn=PSIn(new TStdIn());
46  TStdIn::TStdIn(): TSBase("Standard input"), TSIn("Standard input") {}
47  TSOut::TSOut(const TStr& Str):
48    TSBase(Str.CStr()), MxLnLen(-1), LnLen(0){}
49  int TSOut::UpdateLnLen(const int& StrLen, const bool& ForceInLn){
50    int Cs=0;
51    if (MxLnLen!=-1){
52      if ((!ForceInLn)&&(LnLen+StrLen>MxLnLen)){Cs+=PutLn();}
53      LnLen+=StrLen;
54    }
55    return Cs;
56  }
57  int TSOut::PutMem(const TMem& Mem){
58    return PutBf(Mem(), Mem.Len());
59  }
60  int TSOut::PutCh(const char& Ch, const int& Chs){
61    int Cs=0;
62    for (int ChN=0; ChN<Chs; ChN++){Cs+=PutCh(Ch);}
63    return Cs;
64  }
65  int TSOut::PutBool(const bool& Bool){
66    return PutStr(TBool::GetStr(Bool));
67  }
68  int TSOut::PutInt(const int& Int){
69    return PutStr(TInt::GetStr(Int));
70  }
71  int TSOut::PutInt(const int& Int, const char* FmtStr){
72    return PutStr(TInt::GetStr(Int, FmtStr));
73  }
74  int TSOut::PutUInt(const uint& UInt){
75    return PutStr(TUInt::GetStr(UInt));
76  }
77  int TSOut::PutUInt(const uint& UInt, const char* FmtStr){
78    return PutStr(TUInt::GetStr(UInt, FmtStr));
79  }
80  int TSOut::PutFlt(const double& Flt){
81    return PutStr(TFlt::GetStr(Flt));
82  }
83  int TSOut::PutFlt(const double& Flt, const char* FmtStr){
84    return PutStr(TFlt::GetStr(Flt, FmtStr));
85  }
86  int TSOut::PutStr(const char* CStr){
87    int Cs=UpdateLnLen(int(strlen(CStr)));
88    return Cs+PutBf(CStr, int(strlen(CStr)));
89  }
90  int TSOut::PutStr(const TChA& ChA){
91    int Cs=UpdateLnLen(ChA.Len());
92    return Cs+PutBf(ChA.CStr(), ChA.Len());
93  }
94  int TSOut::PutStr(const TStr& Str, const char* FmtStr){
95    return PutStr(TStr::GetStr(Str, FmtStr));
96  }
97  int TSOut::PutStr(const TStr& Str, const bool& ForceInLn){
98    int Cs=UpdateLnLen(Str.Len(), ForceInLn);
99    return Cs+PutBf(Str.CStr(), Str.Len());
100  }
101  int TSOut::PutStrFmt(const char *FmtStr, ...){
102    char Bf[10*1024];
103    va_list valist;
104    va_start(valist, FmtStr);
105    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
106    va_end(valist);
107    return RetVal!=-1 ? PutStr(TStr(Bf)) : 0;	
108  }
109  int TSOut::PutStrFmtLn(const char *FmtStr, ...){
110    char Bf[10*1024];
111    va_list valist;
112    va_start(valist, FmtStr);
113    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
114    va_end(valist);
115    return RetVal!=-1 ? PutStrLn(TStr(Bf)) : PutLn();	
116  }
117  int TSOut::PutIndent(const int& IndentLev){
118    return PutCh(' ', IndentLev*2);
119  }
120  int TSOut::PutLn(const int& Lns){
121    LnLen=0; int Cs=0;
122    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh('\n');}
123    return Cs;
124  }
125  int TSOut::PutDosLn(const int& Lns){
126    LnLen=0; int Cs=0;
127    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh(TCh::CrCh)+PutCh(TCh::LfCh);}
128    return Cs;
129  }
130  int TSOut::PutSep(const int& NextStrLen){
131    int Cs=0;
132    if (MxLnLen==-1){
133      Cs+=PutCh(' ');
134    } else {
135      if (LnLen>0){
136        if (LnLen+1+NextStrLen>MxLnLen){Cs+=PutLn();} else {Cs+=PutCh(' ');}
137      }
138    }
139    return Cs;
140  }
141  int TSOut::PutSepLn(const int& Lns){
142    int Cs=0;
143    if (LnLen>0){Cs+=PutLn();}
144    Cs+=PutLn(Lns);
145    return Cs;
146  }
147  void TSOut::Save(const char* CStr){
148    int CStrLen=int(strlen(CStr));
149    EAssertR(CStrLen<=127, "Error writting stream '"+GetSNm()+"'.");
150    Save(char(CStrLen));
151    if (CStrLen>0){Cs+=PutBf(CStr, CStrLen);}
152  }
153  void TSOut::Save(TSIn& SIn, const TSize& BfL){
154    Fail;
155    if (BfL==0){ 
156      while (!SIn.Eof()){Save(SIn.GetCh());}
157    } else {
158      for (TSize BfC=0; BfC<BfL; BfC++){Save(SIn.GetCh());}
159    }
160  }
161  TSOut& TSOut::operator<<(TSIn& SIn) {
162    while (!SIn.Eof())
163      operator<<((char)SIn.GetCh());
164    return *this;
165  }
166  const PSOut TSOut::StdOut=PSOut(new TStdOut());
167  TStdOut::TStdOut(): TSBase(TSStr("Standard output")), TSOut("Standard output"){}
168  int TStdIn::GetBf(const void* LBf, const TSize& LBfL){
169    int LBfS=0;
170    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
171      LBfS+=(((char*)LBf)[LBfC]=GetCh());}
172    return LBfS;
173  }
174  bool TStdIn::GetNextLnBf(TChA& LnChA){
175    FailR(TStr::Fmt("TStdIn::GetNextLnBf: not implemented").CStr());
176    return false;
177  }
178  int TStdOut::PutBf(const void* LBf, const TSize& LBfL){
179    int LBfS=0;
180    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
181      LBfS+=PutCh(((char*)LBf)[LBfC]);}
182    return LBfS;
183  }
184  const int TFIn::MxBfL=16*1024;
185  void TFIn::SetFPos(const int& FPos) const {
186    EAssertR(
187     fseek(FileId, FPos, SEEK_SET)==0,
188     "Error seeking into file '"+GetSNm()+"'.");
189  }
190  int TFIn::GetFPos() const {
191    const int FPos=(int)ftell(FileId);
192    EAssertR(FPos!=-1, "Error seeking into file '"+GetSNm()+"'.");
193    return FPos;
194  }
195  int TFIn::GetFLen() const {
196    const int FPos=GetFPos();
197    EAssertR(
198     fseek(FileId, 0, SEEK_END)==0,
199     "Error seeking into file '"+GetSNm()+"'.");
200    const int FLen=GetFPos(); SetFPos(FPos);
201    return FLen;
202  }
203  void TFIn::FillBf(){
204    EAssertR(
205     (BfC==BfL)&&((BfL==-1)||(BfL==MxBfL)),
206     "Error reading file '"+GetSNm()+"'.");
207    BfL=int(fread(Bf, 1, MxBfL, FileId));
208    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
209    BfC=0;
210  }
211  TFIn::TFIn(const TStr& FNm):
212    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
213    EAssertR(!FNm.Empty(), "Empty file-name.");
214    FileId=fopen(FNm.CStr(), "rb");
215    EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
216    Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();
217  }
218  TFIn::TFIn(const TStr& FNm, bool& OpenedP):
219    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
220    EAssertR(!FNm.Empty(), "Empty file-name.");
221    FileId=fopen(FNm.CStr(), "rb");
222    OpenedP=(FileId!=NULL);
223    if (OpenedP){
224      Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();}
225  }
226  PSIn TFIn::New(const TStr& FNm){
227    try {
228      return PSIn(new TFIn(FNm));
229    } catch (PExcept& Except) {
230      printf("*** Exception: %s\n", Except->GetMsgStr().CStr());
231      EFailR(Except->GetMsgStr());
232    }
233    return PSIn(new TFIn(FNm));
234  }
235  PSIn TFIn::New(const TStr& FNm, bool& OpenedP){
236    return PSIn(new TFIn(FNm, OpenedP));
237  }
238  TFIn::~TFIn(){
239    if (FileId!=NULL){
240      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
241    if (Bf!=NULL){delete[] Bf;}
242  }
243  int TFIn::GetBf(const void* LBf, const TSize& LBfL){
244    int LBfS=0;
245    if (TSize(BfC+LBfL)>TSize(BfL)){
246      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
247        if (BfC==BfL){FillBf();}
248        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
249    } else {
250      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
251        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
252    }
253    return LBfS;
254  }
255  bool TFIn::GetNextLnBf(TChA& LnChA) {
256    int Status;
257    int BfN;        
258    int BfP;        
259    bool CrEnd;     
260    LnChA.Clr();
261    CrEnd = false;
262    do {
263      if (BfC >= BfL) {
264        BfP = 0;
265      } else {
266        BfP = BfC;
267      }
268      Status = FindEol(BfN,CrEnd);
269      if (Status >= 0) {
270        if (BfN-BfP > 0) {
271          LnChA.AddBf(&Bf[BfP],BfN-BfP);
272        }
273        if (Status == 1) {
274          return true;
275        }
276      }
277    } while (Status == 0);
278    return !LnChA.Empty();
279  }
280  int TFIn::FindEol(int& BfN, bool& CrEnd) {
281    char Ch;
282    if (BfC >= BfL) {
283      if (Eof()) {
284        return -1;
285      }
286      if (CrEnd && Bf[BfC]=='\n') {
287        BfC++;
288        BfN = BfC-1;
289        return 1;
290      }
291    }
292    CrEnd = false;
293    while (BfC < BfL) {
294      Ch = Bf[BfC++];
295      if (Ch=='\n') {
296        BfN = BfC-1;
297        return 1;
298      }
299      if (Ch=='\r') {
300        if (BfC == BfL) {
301          CrEnd = true;
302          BfN = BfC-1;
303          return 0;
304        } else if (Bf[BfC]=='\n') {
305          BfC++;
306          BfN = BfC-2;
307          return 1;
308        }
309      }
310    }
311    BfN = BfC;
312    return 0;
313  }
314  const TSize TFOut::MxBfL=16*1024;;
315  void TFOut::FlushBf(){
316    EAssertR(
317     fwrite(Bf, 1, BfL, FileId)==BfL,
318     "Error writting to the file '"+GetSNm()+"'.");
319    BfL=0;
320  }
321  TFOut::TFOut(const TStr& FNm, const bool& Append):
322    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
323    if (FNm.GetUc()=="CON"){
324      FileId=stdout;
325    } else {
326      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
327      else {FileId=fopen(FNm.CStr(), "w+b");}
328      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
329      Bf=new char[MxBfL]; BfL=0;
330    }
331  }
332  TFOut::TFOut(const TStr& FNm, const bool& Append, bool& OpenedP):
333    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
334    if (FNm.GetUc()=="CON"){
335      FileId=stdout;
336    } else {
337      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
338      else {FileId=fopen(FNm.CStr(), "w+b");}
339      OpenedP=(FileId!=NULL);
340      if (OpenedP){
341        Bf=new char[MxBfL]; BfL=0;}
342    }
343  }
344  PSOut TFOut::New(const TStr& FNm, const bool& Append){
345    return PSOut(new TFOut(FNm, Append));
346  }
347  PSOut TFOut::New(const TStr& FNm, const bool& Append, bool& OpenedP){
348    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
349    if (OpenedP){return SOut;} else {return NULL;}
350  }
351  TFOut::~TFOut(){
352    if (FileId!=NULL){FlushBf();}
353    if (Bf!=NULL){delete[] Bf;}
354    if (FileId!=NULL){
355      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
356  }
357  int TFOut::PutCh(const char& Ch){
358    if (BfL==TSize(MxBfL)){FlushBf();}
359    return Bf[BfL++]=Ch;
360  }
361  int TFOut::PutBf(const void* LBf, const TSize& LBfL){
362    int LBfS=0;
363    if (BfL+LBfL>MxBfL){
364      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
365        LBfS+=PutCh(((char*)LBf)[LBfC]);}
366    } else {
367      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
368        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
369    }
370    return LBfS;
371  }
372  void TFOut::Flush(){
373    FlushBf();
374    EAssertR(fflush(FileId)==0, "Can not flush file '"+GetSNm()+"'.");
375  }
376  TFInOut::TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) :
377   TSBase(TSStr(FNm.CStr())), FileId(NULL) {
378    switch (FAccess){
379      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
380      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
381      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
382        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
383      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
384      default: Fail;
385    }
386    if ((FileId==NULL)&&(CreateIfNo)){FileId=fopen(FNm.CStr(), "w+b");}
387    IAssert(FileId!=NULL);
388  }
389  PSInOut TFInOut::New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) {
390    return PSInOut(new TFInOut(FNm, FAccess, CreateIfNo));
391  }
392  int TFInOut::GetSize() const {
393    const int FPos = GetPos();
394    IAssert(fseek(FileId, 0, SEEK_END) == 0);
395    const int FLen = GetPos();
396    IAssert(fseek(FileId, FPos, SEEK_SET) == 0);
397    return FLen;
398  }
399  int TFInOut::PutBf(const void* LBf, const TSize& LBfL) {
400    int LBfS = 0;
401    for (TSize i = 0; i < LBfL; i++) {
402      LBfS += ((char *)LBf)[i];
403    }
404    IAssert(fwrite(LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
405    return LBfS;
406  }
407  int TFInOut::GetBf(const void* LBf, const TSize& LBfL) {
408    IAssert(fread((void *)LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
409    int LBfS = 0;
410    for (TSize i = 0; i < LBfL; i++) {
411      LBfS += ((char *)LBf)[i];
412    }
413    return LBfS;
414  }
415  bool TFInOut::GetNextLnBf(TChA& LnChA){
416    FailR(TStr::Fmt("TFInOut::GetNextLnBf: not implemented").CStr());
417    return false;
418  }
419  TStr TFInOut::GetFNm() const {
420    return GetSNm();
421  }
422  TShMIn::TShMIn(const TStr& Str): TSBase("Input-Shared_Memory"), 
423      TSIn("Input-Shared_Memory"), TotalLength(0),
424      SizeLeft(0) {
425  #ifdef GLib_LINUX
426        TStr FNm = Str;
427        TFileId FileId;
428        int fd;
429        uint64 FLen;
430        EAssertR(!FNm.Empty(), "Empty file-name.");
431        FileId=fopen(FNm.CStr(), "rb");
432        fd = fileno(FileId);
433        EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
434        EAssertR(
435            fseek(FileId, 0, SEEK_END)==0,
436            "Error seeking into file '"+TStr(FNm)+"'.");
437        FLen=(uint64)ftell(FileId);
438        EAssertR(
439            fseek(FileId, 0, SEEK_SET)==0,
440            "Error seeking into file '"+TStr(FNm)+"'.");
441        char *Mapped;
442        Mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
443        EAssertR(Mapped!=MAP_FAILED, "mmap failed in TShMIn.");
444        OriginalBuffer = Mapped;
445        Cursor = OriginalBuffer;
446        SizeLeft = FLen;
447        TotalLength = FLen;
448        IsMemoryMapped = true;
449  #else
450        TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
451  #endif
452      }
453  TShMIn::TShMIn(void* _Bf, const TSize& _BfL): TSBase("Input-Shared_Memory"), 
454    TSIn("Input-Shared_Memory"), TotalLength(_BfL), SizeLeft(_BfL), IsMemoryMapped(false) {
455      OriginalBuffer = (char*)_Bf;
456      Cursor = (char*)_Bf;
457    }
458  void TShMIn::CloseMapping() {
459    if (OriginalBuffer!=NULL){
460      if (IsMemoryMapped) {
461  #ifdef GLib_LINUX
462        munmap(OriginalBuffer, TotalLength);
463        IsMemoryMapped = false;
464        OriginalBuffer = NULL;
465        Cursor = NULL;
466        TotalLength= 0;
467        SizeLeft = 0;
468  #endif
469      }
470    }
471  }
472  TMIn::TMIn(const void* _Bf, const uint64& _BfL, const bool& TakeBf):
473    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(_BfL), IsMemoryMapped(false){
474    if (TakeBf){
475      Bf=(char*)_Bf;
476    } else {
477      Bf=new char[static_cast<size_t>(BfL)]; memmove(Bf, _Bf, static_cast<size_t>(BfL));
478    }
479  }
480  TMIn::TMIn(TSIn& SIn):
481    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
482    BfL=SIn.Len(); Bf=new char[static_cast<size_t>(BfL)];
483    for (uint64 BfC=0; BfC<BfL; BfC++){Bf[BfC]=SIn.GetCh();}
484  }
485  TMIn::TMIn(const char* CStr):
486    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
487    BfL=uint64(strlen(CStr)); Bf=new char[static_cast<size_t>(BfL+1)]; strcpy(Bf, CStr);
488  }
489  TMIn::TMIn(const TStr& Str, bool FromFile):
490    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
491    if (FromFile == false) {
492      BfL=Str.Len(); Bf=new char[static_cast<size_t>(BfL)]; strncpy(Bf, Str.CStr(), static_cast<size_t>(BfL));
493      IsMemoryMapped = false;
494    }
495    else {
496  #ifdef GLib_LINUX
497      TStr FNm = Str;
498      TFileId FileId;
499      int fd;
500      uint64 FLen;
501      EAssertR(!FNm.Empty(), "Empty file-name.");
502      FileId=fopen(FNm.CStr(), "rb");
503      fd = fileno(FileId);
504      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
505      EAssertR(
506          fseek(FileId, 0, SEEK_END)==0,
507          "Error seeking into file '"+TStr(FNm)+"'.");
508      FLen=(uint64)ftell(FileId);
509      EAssertR(
510          fseek(FileId, 0, SEEK_SET)==0,
511          "Error seeking into file '"+TStr(FNm)+"'.");
512      char *mapped;
513      mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
514      IsMemoryMapped = true;
515      if (mapped == MAP_FAILED) {
516        printf("mmap failed: %d %s\n", fd, strerror (errno));
517        Bf = NULL;
518        BfC = BfL = 0;
519      }
520      else {
521        Bf = mapped;
522        BfC = 0;
523        BfL = FLen;
524      }
<span onclick='openModal()' class='match'>525      IsMemoryMapped = true;
526  #else
527      TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
528  #endif
529    }
530  }
</span>531  TMIn::TMIn(const TChA& ChA):
532    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
533    BfL=ChA.Len(); Bf=new char[static_cast<size_t>(BfL)]; strncpy(Bf, ChA.CStr(), static_cast<size_t>(BfL));
534  }
535  PSIn TMIn::New(const void* _Bf, const uint64& _BfL, const bool& TakeBf){
536    return PSIn(new TMIn(_Bf, _BfL, TakeBf));
537  }
538  PSIn TMIn::New(const char* CStr){
539    return PSIn(new TMIn(CStr));
540  }
541  PSIn TMIn::New(const TStr& Str){
542    return PSIn(new TMIn(Str));
543  }
544  PMIn TMIn::New(const TStr& Str, bool FromFile){
545    return new TMIn(Str, FromFile);
546  }
547  PSIn TMIn::New(const TChA& ChA){
548    return PSIn(new TMIn(ChA));
549  }
550  TMIn::~TMIn(){
551    if (Bf!=NULL){
552      if (IsMemoryMapped) {
553  #ifdef GLib_LINUX
554        munmap(Bf, BfL);
555  #endif
556      }
557      else {
558        delete[] Bf;
559      }
560    }
561  }
562  char TMIn::GetCh(){
563    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
564    return Bf[BfC++];
565  }
566  char TMIn::PeekCh(){
567    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
568    return Bf[BfC];
569  }
570  int TMIn::GetBf(const void* LBf, const TSize& LBfL){
571    EAssertR(TSize(BfC+LBfL)<=TSize(BfL), "Reading beyond the end of stream.");
572    int LBfS=0;
573    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
574      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
575    return LBfS;
576  }
577  int TMIn::FindEol(uint64& BfN, bool& CrEnd) {
578    char Ch;
579    if (BfC >= BfL) {
580      if (Eof()) {
581        return -1;
582      }
583      if (CrEnd && Bf[BfC]=='\n') {
584        BfC++;
585        BfN = BfC-1;
586        return 1;
587      }
588    }
589    CrEnd = false;
590    while (BfC < BfL) {
591      Ch = Bf[BfC++];
592      if (Ch=='\n') {
593        BfN = BfC-1;
594        return 1;
595      }
596      if (Ch=='\r') {
597        if (BfC == BfL) {
598          CrEnd = true;
599          BfN = BfC-1;
600          return 0;
601        } else if (Bf[BfC]=='\n') {
602          BfC++;
603          BfN = BfC-2;
604          return 1;
605        }
606      }
607    }
608    BfN = BfC;
609    return 0;
610  }
611  bool TMIn::GetNextLnBf(TChA& LnChA){
612    FailR(TStr::Fmt("TMIn::GetNextLnBf: not implemented").CStr());
613    return false;
614  }
615  uint64 TMIn::GetBfC() {
616    return BfC;
617  }
618  uint64 TMIn::GetBfL() {
619    return BfL;
620  }
621  void TMIn::SetBfC(uint64 Pos) {
622    BfC = Pos;
623  }
624  uint64 TMIn::CountNewLinesInRange(uint64 Lb, uint64 Ub) {
625    uint64 Cnt = 0;
626    if (Lb >= BfL) {
627      return 0;
628    }
629    for (uint64 i = Lb; i < Ub; i++) {
630      if (Bf[i] == '\n') {
631        Cnt += 1;
632      }
633    }
634    return Cnt;
635  }
636  uint64 TMIn::GetLineStartPos(uint64 Ind) {
637    while (Ind > 0 && Bf[Ind-1] != '\n') {
638      Ind--;
639    }
640    return Ind;
641  }
642  uint64 TMIn::GetLineEndPos(uint64 Ind) {
643    while (Ind < BfL && Bf[Ind] != '\n') {
644      Ind++;
645    }
646    if (Ind == BfL) Ind--;
647    return Ind;
648  }
649  char* TMIn::GetLine(uint64 Index) {
650    return &Bf[Index];
651  }
652  void TMIn::SkipCommentLines() {
653    while (BfC < BfL && TCh::IsHashCh(Bf[BfC])) {
654      while (BfC < BfL && Bf[BfC] != '\n') {
655        BfC++;
656      }
657      BfC++;
658    }
659  }
660  void TMOut::Resize(const int& ReqLen){
661    IAssert(OwnBf&&(BfL==MxBfL || ReqLen >= 0));
662    if (Bf==NULL){
663      IAssert(MxBfL==0); 
664      if (ReqLen < 0) Bf=new char[MxBfL=1024];
665      else Bf=new char[MxBfL=ReqLen];
666    } else {
667      if (ReqLen < 0){ MxBfL*=2; }
668      else if (ReqLen < MxBfL){ return; } 
669      else { MxBfL=(2*MxBfL < ReqLen ? ReqLen : 2*MxBfL); }
670      char* NewBf=new char[MxBfL];
671      memmove(NewBf, Bf, BfL); delete[] Bf; Bf=NewBf;
672    }
673  }
674  TMOut::TMOut(const int& _MxBfL):
675    TSBase("Output-Memory"), TSOut("Output-Memory"),
676    Bf(NULL), BfL(0), MxBfL(0), OwnBf(true){
677    MxBfL=_MxBfL>0?_MxBfL:1024;
678    Bf=new char[MxBfL];
679  }
680  TMOut::TMOut(char* _Bf, const int& _MxBfL):
681    TSBase("Output-Memory"), TSOut("Output-Memory"),
682    Bf(_Bf), BfL(0), MxBfL(_MxBfL), OwnBf(false){}
683  void TMOut::AppendBf(const void* LBf, const TSize& LBfL) {
684    Resize(Len() + (int)LBfL);
685    memcpy(Bf + BfL, LBf, LBfL);
686    BfL += (int)LBfL;
687  }
688  int TMOut::PutBf(const void* LBf, const TSize& LBfL){
689    int LBfS=0;
690    if (TSize(BfL+LBfL)>TSize(MxBfL)){
691      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
692        LBfS+=PutCh(((char*)LBf)[LBfC]);}
693    } else {
694      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
695        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
696    }
697    return LBfS;
698  }
699  TStr TMOut::GetAsStr() const {
700    TChA ChA(BfL);
701    for (int BfC=0; BfC<BfL; BfC++){ChA+=Bf[BfC];}
702    return ChA;
703  }
704  void TMOut::CutBf(const int& CutBfL){
705    IAssert((0<=CutBfL)&&(CutBfL<=BfL));
706    if (CutBfL==BfL){BfL=0;}
707    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
708  }
709  PSIn TMOut::GetSIn(const bool& IsCut, const int& CutBfL){
710    IAssert((CutBfL==-1)||((0<=CutBfL)));
711    int SInBfL= (CutBfL==-1) ? BfL : TInt::GetMn(BfL, CutBfL);
712    PSIn SIn;
713    if (OwnBf&&IsCut&&(SInBfL==BfL)){
714      SIn=PSIn(new TMIn(Bf, SInBfL, true));
715      Bf=NULL; BfL=MxBfL=0; OwnBf=true;
716    } else {
717      SIn=PSIn(new TMIn(Bf, SInBfL, false));
718      if (IsCut){CutBf(SInBfL);}
719    }
720    return SIn;
721  }
722  bool TMOut::IsCrLfLn() const {
723    for (int BfC=0; BfC<BfL; BfC++){
724      if ((Bf[BfC]==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){return true;}}
725    return false;
726  }
727  TStr TMOut::GetCrLfLn(){
728    IAssert(IsCrLfLn());
729    TChA Ln;
730    for (int BfC=0; BfC<BfL; BfC++){
731      char Ch=Bf[BfC];
732      if ((Ch==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){
733        Ln+=TCh::CrCh; Ln+=TCh::LfCh; CutBf(BfC+1+1); break;
734      } else {
735        Ln+=Ch;
736      }
737    }
738    return Ln;
739  }
740  bool TMOut::IsEolnLn() const {
741    for (int BfC=0; BfC<BfL; BfC++){
742      if ((Bf[BfC]==TCh::CrCh)||(Bf[BfC]==TCh::LfCh)){return true;}
743    }
744    return false;
745  }
746  TStr TMOut::GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf){
747    IAssert(IsEolnLn());
748    int LnChs=0; TChA Ln;
749    for (int BfC=0; BfC<BfL; BfC++){
750      char Ch=Bf[BfC];
751      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
752        LnChs++; if (DoAddEoln){Ln+=Ch;}
753        if (BfC+1<BfL){
754          char NextCh=Bf[BfC+1];
755          if (((Ch==TCh::CrCh)&&(NextCh==TCh::LfCh))||
756           ((Ch==TCh::LfCh)&&(NextCh==TCh::CrCh))){
757            LnChs++; if (DoAddEoln){Ln+=NextCh;}
758          }
759        }
760        break;
761      } else {
762        LnChs++; Ln+=Ch;
763      }
764    }
765    if (DoCutBf){
766      CutBf(LnChs);
767    }
768    return Ln;
769  }
770  void TMOut::MkEolnLn(){
771    if (!IsEolnLn()){
772      PutCh(TCh::CrCh); PutCh(TCh::LfCh);}
773  }
774  bool TLnRet::NextLn(TStr& LnStr) {
775      if (SIn->Eof()) { return false; }
776      TChA LnChA; char Ch = TCh::EofCh;
777      while (!SIn->Eof() && ((Ch=SIn->GetCh())!='\n')) {
778          if (Ch != '\r') { LnChA += Ch; }
779      }
780      LnStr = LnChA; return true;
781  }
782  #ifndef SEEK_SET
783  #define SEEK_CUR    1
784  #define SEEK_END    2
785  #define SEEK_SET    0
786  #endif
787  void TFRnd::RefreshFPos(){
788    EAssertR(
789     fseek(FileId, 0, SEEK_CUR)==0,
790     "Error seeking into file '"+TStr(FNm)+"'.");
791  }
792  TFRnd::TFRnd(const TStr& _FNm, const TFAccess& FAccess,
793   const bool& CreateIfNo, const int& _HdLen, const int& _RecLen):
794    FileId(NULL), FNm(_FNm.CStr()),
795    RecAct(false), HdLen(_HdLen), RecLen(_RecLen){
796    RecAct=(HdLen>=0)&&(RecLen>0);
797    switch (FAccess){
798      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
799      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
800      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
801        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
802      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
803      default: Fail;
804    }
805    if ((FileId==NULL)&&(CreateIfNo)){
806      FileId=fopen(FNm.CStr(), "w+b");}
807    EAssertR(FileId!=NULL, "Can not open file '"+_FNm+"'.");
808  }
809  TFRnd::~TFRnd(){
810    EAssertR(fclose(FileId)==0, "Can not close file '"+TStr(FNm)+"'.");
811  }
812  TStr TFRnd::GetFNm() const {
813    return FNm.CStr();
814  }
815  void TFRnd::SetFPos(const int& FPos){
816    EAssertR(
817     fseek(FileId, FPos, SEEK_SET)==0,
818     "Error seeking into file '"+TStr(FNm)+"'.");
819  }
820  void TFRnd::MoveFPos(const int& DFPos){
821    EAssertR(
822     fseek(FileId, DFPos, SEEK_CUR)==0,
823     "Error seeking into file '"+TStr(FNm)+"'.");
824  }
825  int TFRnd::GetFPos(){
826    int FPos= (int) ftell(FileId);
827    EAssertR(FPos!=-1, "Error seeking into file '"+TStr(FNm)+"'.");
828    return FPos;
829  }
830  int TFRnd::GetFLen(){
831    int FPos=GetFPos();
832    EAssertR(
833     fseek(FileId, 0, SEEK_END)==0,
834     "Error seeking into file '"+TStr(FNm)+"'.");
835    int FLen=GetFPos(); SetFPos(FPos); return FLen;
836  }
837  void TFRnd::SetRecN(const int& RecN){
838    IAssert(RecAct);
839    SetFPos(HdLen+RecN*RecLen);
840  }
841  int TFRnd::GetRecN(){
842    IAssert(RecAct);
843    int FPos=GetFPos()-HdLen;
844    EAssertR(FPos%RecLen==0, "Invalid position in file'"+TStr(FNm)+"'.");
845    return FPos/RecLen;
846  }
847  int TFRnd::GetRecs(){
848    IAssert(RecAct);
849    int FLen=GetFLen()-HdLen;
850    EAssertR(FLen%RecLen==0, "Invalid length of file'"+TStr(FNm)+"'.");
851    return FLen/RecLen;
852  }
853  void TFRnd::GetBf(void* Bf, const TSize& BfL){
854    RefreshFPos();
855    EAssertR(
856     fread(Bf, 1, BfL, FileId)==BfL,
857     "Error reading file '"+TStr(FNm)+"'.");
858  }
859  void TFRnd::PutBf(const void* Bf, const TSize& BfL){
860    RefreshFPos();
861    EAssertR(
862     fwrite(Bf, 1, BfL, FileId)==BfL,
863     "Error writting to the file '"+TStr(FNm)+"'.");
864  }
865  void TFRnd::Flush(){
866    EAssertR(fflush(FileId)==0, "Can not flush file '"+TStr(FNm)+"'.");
867  }
868  void TFRnd::PutCh(const char& Ch, const int& Chs){
869    if (Chs>0){
870      char* CStr=new char[Chs];
871      for (int ChN=0; ChN<Chs; ChN++){CStr[ChN]=Ch;}
872      PutBf(CStr, Chs);
873      delete[] CStr;
874    }
875  }
876  void TFRnd::PutStr(const TStr& Str){
877    PutBf(Str.CStr(), Str.Len()+1);
878  }
879  TStr TFRnd::GetStr(const int& StrLen, bool& IsOk){
880    IsOk=false; TStr Str;
881    if (GetFPos()+StrLen+1<=GetFLen()){
882      char* CStr=new char[StrLen+1];
883      GetBf(CStr, StrLen+1);
884      if (CStr[StrLen+1-1]==TCh::NullCh){IsOk=true; Str=CStr;}
885      delete[] CStr;
886    }
887    return Str;
888  }
889  TStr TFRnd::GetStr(const int& StrLen){
890    TStr Str;
891    char* CStr=new char[StrLen+1];
892    GetBf(CStr, StrLen+1);
893    EAssertR(CStr[StrLen+1-1]==TCh::NullCh, "Error reading file '"+TStr(FNm)+"'.");
894    Str=CStr;
895    delete[] CStr;
896    return Str;
897  }
898  void TFRnd::PutSIn(const PSIn& SIn, TCs& Cs){
899    int BfL=SIn->Len();
900    char* Bf=new char[BfL];
901    SIn->GetBf(Bf, BfL);
902    Cs=TCs::GetCsFromBf(Bf, BfL);
903    PutBf(Bf, BfL);
904    delete[] Bf;
905  }
906  PSIn TFRnd::GetSIn(const int& BfL, TCs& Cs){
907    char* Bf=new char[BfL];
908    GetBf(Bf, BfL);
909    Cs=TCs::GetCsFromBf(Bf, BfL);
910    PSIn SIn=PSIn(new TMIn(Bf, BfL, true));
911    return SIn;
912  }
913  TStr TFRnd::GetStrFromFAccess(const TFAccess& FAccess){
914    switch (FAccess){
915      case faCreate: return "Create";
916      case faUpdate: return "Update";
917      case faAppend: return "Append";
918      case faRdOnly: return "ReadOnly";
919      case faRestore: return "Restore";
920      default: Fail; return TStr();
921    }
922  }
923  TFAccess TFRnd::GetFAccessFromStr(const TStr& Str){
924    TStr UcStr=Str.GetUc();
925    if (UcStr=="CREATE"){return faCreate;}
926    if (UcStr=="UPDATE"){return faUpdate;}
927    if (UcStr=="APPEND"){return faAppend;}
928    if (UcStr=="READONLY"){return faRdOnly;}
929    if (UcStr=="RESTORE"){return faRestore;}
930    if (UcStr=="NEW"){return faCreate;}
931    if (UcStr=="CONT"){return faUpdate;}
932    if (UcStr=="CONTINUE"){return faUpdate;}
933    if (UcStr=="REST"){return faRestore;}
934    if (UcStr=="RESTORE"){return faRestore;}
935    return faUndef;
936  }
937  const TStr TFile::TxtFExt=".Txt";
938  const TStr TFile::HtmlFExt=".Html";
939  const TStr TFile::HtmFExt=".Htm";
940  const TStr TFile::GifFExt=".Gif";
941  const TStr TFile::JarFExt=".Jar";
942  bool TFile::Exists(const TStr& FNm){
943    if (FNm.Empty()) { return false; }
944    bool DoExists;
945    TFIn FIn(FNm, DoExists);
946    return DoExists;
947  }
948  #if defined(GLib_WIN32)
949  void TFile::Copy(const TStr& SrcFNm, const TStr& DstFNm, 
950   const bool& ThrowExceptP, const bool& FailIfExistsP){
951    if (ThrowExceptP){
952      if (CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP) == 0) {
953          int ErrorCode = (int)GetLastError();
954          TExcept::Throw(TStr::Fmt(
955              "Error %d copying file '%s' to '%s'.", 
956              ErrorCode, SrcFNm.CStr(), DstFNm.CStr()));
957      }
958    } else {
959      CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP);
960    }
961  }
962  #elif defined(GLib_LINUX)
963  void TFile::Copy(const TStr& SrcFNm, const TStr& DstFNm,
964   const bool& ThrowExceptP, const bool& FailIfExistsP){
965  	int input, output;
966  	size_t filesize;
967  	void *source, *target;
968  	if( (input = open(SrcFNm.CStr(), O_RDONLY)) == -1) {
969  		if (ThrowExceptP) {
970  			TExcept::Throw(TStr::Fmt(
971  			            "Error copying file '%s' to '%s': cannot open source file for reading.",
972  			            SrcFNm.CStr(), DstFNm.CStr()));
973  		} else {
974  			return;
975  		}
976  	}
977  	if( (output = open(DstFNm.CStr(), O_RDWR | O_CREAT | O_TRUNC, 0666)) == -1)	{
978  		close(input);
979  		if (ThrowExceptP) {
980  			TExcept::Throw(TStr::Fmt(
981  			            "Error copying file '%s' to '%s': cannot open destination file for writing.",
982  			            SrcFNm.CStr(), DstFNm.CStr()));
983  		} else {
984  			return;
985  		}
986  	}
987  	filesize = lseek(input, 0, SEEK_END);
988  	lseek(output, filesize - 1, SEEK_SET);
989  	write(output, '\0', 1);
990  	if((source = mmap(0, filesize, PROT_READ, MAP_SHARED, input, 0)) == (void *) -1) {
991  		close(input);
992  		close(output);
993  		if (ThrowExceptP) {
994  			TExcept::Throw(TStr::Fmt(
995  						"Error copying file '%s' to '%s': cannot mmap input file.",
996  						SrcFNm.CStr(), DstFNm.CStr()));
997  		} else {
998  			return;
999  		}
1000  	}
1001  	if((target = mmap(0, filesize, PROT_WRITE, MAP_SHARED, output, 0)) == (void *) -1) {
1002  		munmap(source, filesize);
1003  		close(input);
1004  		close(output);
1005  		if (ThrowExceptP) {
1006  			TExcept::Throw(TStr::Fmt(
1007  						"Error copying file '%s' to '%s': cannot mmap output file.",
1008  						SrcFNm.CStr(), DstFNm.CStr()));
1009  		} else {
1010  			return;
1011  		}
1012  	}
1013  	memcpy(target, source, filesize);
1014  	munmap(source, filesize);
1015  	munmap(target, filesize);
1016  	close(input);
1017  	close(output);
1018  }
1019  #endif
1020  void TFile::Del(const TStr& FNm, const bool& ThrowExceptP){
1021    if (ThrowExceptP){
1022      EAssertR(
1023       remove(FNm.CStr())==0,
1024       "Error removing file '"+FNm+"'.");
1025    } else {
1026      remove(FNm.CStr());
1027    }
1028  }
1029  void TFile::DelWc(const TStr& WcStr, const bool& RecurseDirP){
1030    TStrV FNmV;
1031    TFFile FFile(WcStr, RecurseDirP); TStr FNm;
1032    while (FFile.Next(FNm)){
1033      FNmV.Add(FNm);}
1034    for (int FNmN=0; FNmN<FNmV.Len(); FNmN++){
1035      Del(FNmV[FNmN], false);}
1036  }
1037  void TFile::Rename(const TStr& SrcFNm, const TStr& DstFNm){
1038    EAssertR(
1039     rename(SrcFNm.CStr(), DstFNm.CStr())==0,
1040     "Error renaming file '"+SrcFNm+"' to "+DstFNm+"'.");
1041  }
1042  TStr TFile::GetUniqueFNm(const TStr& FNm){
1043    int Cnt=1; int ch;
1044    TStr NewFNm; TStr TmpFNm=FNm;
1045    if (FNm.SearchCh('#') == -1) {
1046      for (ch = FNm.Len()-1; ch >= 0; ch--) if (FNm[ch] == '.') break;
1047      if (ch != -1) TmpFNm.InsStr(ch, ".#");
1048      else TmpFNm += ".#";
1049    }
1050    forever{
1051      NewFNm=TmpFNm;
1052      NewFNm.ChangeStr("#", TStr::Fmt("%03d", Cnt)); Cnt++;
1053      if (!TFile::Exists(NewFNm)){break;}
1054    }
1055    return NewFNm;
1056  }
1057  #ifdef GLib_WIN
1058  uint64 TFile::GetSize(const TStr& FNm) {
1059      HANDLE hFile = CreateFile(
1060         FNm.CStr(),            
1061         GENERIC_READ,          
1062         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1063         NULL,                  
1064         OPEN_EXISTING,         
1065         FILE_ATTRIBUTE_NORMAL, 
1066         NULL);                 
1067      if (hFile == INVALID_HANDLE_VALUE) {
1068          TExcept::Throw("Can not open file " + FNm + "!"); }
1069      LARGE_INTEGER lpFileSizeHigh;
1070  	if (!GetFileSizeEx(hFile, &lpFileSizeHigh)) {
1071          TExcept::Throw("Can not read size of file " + FNm + "!"); }
1072      CloseHandle(hFile);
1073  	return uint64(lpFileSizeHigh.QuadPart);
1074  }
1075  uint64 TFile::GetCreateTm(const TStr& FNm) {
1076      HANDLE hFile = CreateFile(
1077         FNm.CStr(),            
1078         GENERIC_READ,          
1079         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1080         NULL,                  
1081         OPEN_EXISTING,         
1082         FILE_ATTRIBUTE_NORMAL, 
1083         NULL);                 
1084      if (hFile == INVALID_HANDLE_VALUE) {
1085          TExcept::Throw("Can not open file " + FNm + "!"); }
1086      FILETIME lpCreationTime;
1087      if (!GetFileTime(hFile, &lpCreationTime, NULL, NULL)) {
1088          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1089      CloseHandle(hFile);
1090      TUInt64 UInt64(uint(lpCreationTime.dwHighDateTime), 
1091          uint(lpCreationTime.dwLowDateTime));
1092      return UInt64.Val / uint64(10000);
1093  }
1094  uint64 TFile::GetLastAccessTm(const TStr& FNm) {
1095      HANDLE hFile = CreateFile(
1096         FNm.CStr(),            
1097         GENERIC_READ,          
1098         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1099         NULL,                  
1100         OPEN_EXISTING,         
1101         FILE_ATTRIBUTE_NORMAL, 
1102         NULL);                 
1103      if (hFile == INVALID_HANDLE_VALUE) {
1104          TExcept::Throw("Can not open file " + FNm + "!"); }
1105      FILETIME lpLastAccessTime;
1106      if (!GetFileTime(hFile, NULL, &lpLastAccessTime, NULL)) {
1107          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1108      CloseHandle(hFile);
1109      TUInt64 UInt64(uint(lpLastAccessTime.dwHighDateTime), 
1110          uint(lpLastAccessTime.dwLowDateTime));
1111      return UInt64.Val / uint64(10000);
1112  }
1113  uint64 TFile::GetLastWriteTm(const TStr& FNm) {
1114      HANDLE hFile = CreateFile(
1115         FNm.CStr(),            
1116         GENERIC_READ,          
1117         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1118         NULL,                  
1119         OPEN_EXISTING,         
1120         FILE_ATTRIBUTE_NORMAL, 
1121         NULL);                 
1122      if (hFile == INVALID_HANDLE_VALUE) {
1123          TExcept::Throw("Can not open file " + FNm + "!"); }
1124      FILETIME lpLastWriteTime;
1125      if (!GetFileTime(hFile, NULL, NULL, &lpLastWriteTime)) {
1126          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1127      CloseHandle(hFile);
1128      TUInt64 UInt64(uint(lpLastWriteTime.dwHighDateTime), 
1129          uint(lpLastWriteTime.dwLowDateTime));
1130      return UInt64.Val / uint64(10000);
1131  }
1132  #elif defined(GLib_LINUX)
1133  uint64 TFile::GetSize(const TStr& FNm) {
1134  	Fail; return 0;
1135  }
1136  uint64 TFile::GetCreateTm(const TStr& FNm) {
1137  	return GetLastWriteTm(FNm);
1138  }
1139  uint64 TFile::GetLastWriteTm(const TStr& FNm) {
1140  	struct stat st;
1141  	if (stat(FNm.CStr(), &st) != 0) {
1142  		TExcept::Throw("Cannot read tile from file " + FNm + "!");
1143  	}
1144  	return uint64(st.st_mtime);
1145  }
1146  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</div>
                </div>
                <div class="column column_space"><pre><code>525      IsMemoryMapped = true;
526  #else
527      TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
528  #endif
529    }
530  }
</pre></code></div>
                <div class="column column_space"><pre><code>525      IsMemoryMapped = true;
526  #else
527      TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
528  #endif
529    }
530  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    