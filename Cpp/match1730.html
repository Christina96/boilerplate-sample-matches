<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ibex_NumConstraint.cpp & ibex_P_ExprGenerator.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ibex_NumConstraint.cpp & ibex_P_ExprGenerator.cpp
      </h3>
      <h1 align="center">
        2.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ibex_NumConstraint.cpp (6.425703%)<TH>ibex_P_ExprGenerator.cpp (1.5311005%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1730-0.html#0',2,'match1730-1.html#0',3)" NAME="0">(174-177)<TD><A HREF="javascript:ZweiFrames('match1730-0.html#0',2,'match1730-1.html#0',3)" NAME="0">(364-367)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_NumConstraint.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X                                   
// File        : ibex_NumConstraint.cpp
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Feb 24, 2013
// Last Update : Feb 24, 2013
//============================================================================

#include &quot;ibex_NumConstraint.h&quot;
#include &quot;ibex_SyntaxError.h&quot;
#include &quot;ibex_System.h&quot;
#include &quot;ibex_ExprCopy.h&quot;
#include &quot;ibex_Id.h&quot;
#include &quot;ibex_P_Struct.h&quot;

#include &lt;sstream&gt;
#include &lt;mutex&gt;

#ifndef _WIN32 // MinGW does not support mutex
#include &lt;mutex&gt;
namespace {
std::mutex mtx;
}
#define LOCK mtx.lock()
#define UNLOCK mtx.unlock()
#else
#define LOCK
#define UNLOCK
#endif

using namespace std;

extern void ibexparse_string(const char* syntax);

namespace ibex {

NumConstraint::NumConstraint(const char* filename) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_system(System(filename));
}

NumConstraint::NumConstraint(const char* x, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_string(Array&lt;const char*&gt;(x),c);
}

NumConstraint::NumConstraint(const char* x1, const char* x2, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_string(Array&lt;const char*&gt;(x1,x2),c);
}

NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_string(Array&lt;const char*&gt;(x1,x2,x3),c);
}

NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4),c);
}

NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4,x5),c);
}

NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4,x5,x6),c);
}

NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4,x5,x6,x7),c);
}

NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4,x5,x6,x7,x8),c);
}

void NumConstraint::build_from_string(const Array&lt;const char*&gt;&amp; _x, const char* c) {

	stringstream s;

	s &lt;&lt; &quot;variables\n  &quot;;
	for (int i=0; i&lt;_x.size(); i++) {
		s &lt;&lt; _x[i];
		if (i&lt;_x.size()-1) s &lt;&lt; &quot;,&quot;;
	}
	s &lt;&lt; &quot;;\n\n&quot;;
	s &lt;&lt; &quot;constraints\n  &quot;;
	s &lt;&lt; c &lt;&lt; '\n';
	s &lt;&lt; &quot;end\n&quot;;

	System* sys=new System(); // temporary system

	char* syntax = strdup(s.str().c_str());

	LOCK;
	try {
		// TODO: should we allow different simplification level?
		parser::pstruct = new parser::P_StructSystem(*sys, ExprNode::default_simpl_level);
		ibexparse_string(syntax);
		delete parser::pstruct;
		parser::pstruct = NULL;
		free(syntax);
	} catch(SyntaxError&amp; e) {
		delete parser::pstruct;
		parser::pstruct = NULL;
		free(syntax);
		UNLOCK;
		throw e;
	}
	UNLOCK;

	build_from_system(*sys);
	delete sys;

}

void NumConstraint::build_from_system(const System&amp; sys) {
	if (sys.nb_ctr==0) {
		throw SyntaxError(&quot;There is no constraint&quot;);
	}
	NumConstraint&amp; c0=sys.ctrs[0]; // other constraints are ignored

	Array&lt;const ExprSymbol&gt; x(sys.f_ctrs.nb_arg());
	varcopy(c0.f.args(),x);
	const ExprNode&amp; y=ExprCopy().copy(c0.f.args(),x,c0.f.expr());

	((Function&amp;) f).init(x,y);

	(CmpOp&amp;) op = c0.op;
}

#define RETURN(a,b) return pair&lt;const ExprNode*, const Interval*&gt;(a,b)

//pair&lt;const ExprNode*, const Interval*&gt; NumConstraint::is_thick_equality() const {
//
//	// an inequality g(x)&lt;=[a,b] is not considered as
//	// a thick equality, although it could...
//	if (op!=EQ) RETURN(NULL,NULL);
//
//	const ExprSub* sub=dynamic_cast&lt;const ExprSub* &gt;(&amp;f.expr());
//
//	if (sub) {
//
//		const ExprConstant* cst=dynamic_cast&lt;const ExprConstant* &gt;(&amp;sub-&gt;right);
//
//		if (cst) {
//			if (cst-&gt;dim.is_scalar() &amp;&amp; cst-&gt;get_value().diam()&gt;0)
//				RETURN(&amp;sub-&gt;left, &amp;cst-&gt;get_value());
//		} else {
//
//			cst=dynamic_cast&lt;const ExprConstant* &gt;(&amp;sub-&gt;left);
//
//			if (cst) {
//				if (cst-&gt;dim.is_scalar() &amp;&amp; cst-&gt;get_value().diam()&gt;0)
//					RETURN(&amp;sub-&gt;right, &amp;cst-&gt;get_value());
//			}
//		}
//	}
//
//	RETURN(NULL,NULL);
//}

Domain NumConstraint::right_hand_side() const {
	Domain d(f.expr().dim);
	Interval right_cst;

	switch (op) {
	case LT :
	case LEQ : right_cst=Interval::neg_reals(); break;
	case EQ  : right_cst=Interval::zero();      break;
	case GEQ :
	case GT : right_cst=Interval::pos_reals();  break;
<A NAME="0"></A>	}

	switch(d.dim.type()) {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1730-1.html#0',3,'match1730-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	case Dim::SCALAR:       d.i()=right_cst; break;
	case Dim::ROW_VECTOR:   d.v()=IntervalVector(d.dim.nb_cols(),right_cst); break;
	case Dim::COL_VECTOR:   d.v()=IntervalVector(d.dim.nb_rows(),right_cst); break;
	case Dim::MATRIX:       d.m()=IntervalMatrix(d.dim.nb_rows(),d.dim.nb_cols(),right_cst); break;</B></FONT>
	}
	return d;
}

} // end namespace
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_P_ExprGenerator.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X                                   
// File        : ibex_ExprExprGenerator.cpp
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Jun 19, 2012
// Last Update : Jun 19, 2012
//============================================================================

#include &quot;ibex_P_ExprGenerator.h&quot;
#include &quot;ibex_P_Struct.h&quot;
#include &quot;ibex_SyntaxError.h&quot;
#include &quot;ibex_Exception.h&quot;
#include &quot;ibex_Expr.h&quot;
#include &quot;ibex_ExprDiff.h&quot;

#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;

using namespace std;

namespace ibex {

namespace parser {

class LabelNode : public Label {
public:
	LabelNode(const ExprNode* node) : _node(node) { }

	virtual ~LabelNode() { }

	virtual const ExprNode&amp; node() const { return *_node; }

	virtual bool is_const() const { return false; }

	virtual const Domain&amp; domain() const {
		throw SyntaxError(&quot;Unexpected symbol inside constant expression&quot;);
	}

	virtual const Dim&amp; dim() const { return _node-&gt;dim; }

	const ExprNode* _node;
};

class LabelConst : public Label {
public:
	// do not use POS_INFINITY to avoid confusion
	typedef enum { NEG_INF=0, POS_INF=1, OTHER=2 } number_type;

	// This constant cannot be represented by a Domain
	// object because (+oo,+oo) is automatically replaced by the empty set.
	static LabelConst* pos_infinity() {
		return new LabelConst(POS_INF);
	}

	static LabelConst* neg_infinity() {
		return new LabelConst(NEG_INF);
	}

	LabelConst(int v) : _domain(Dim::scalar()), num_type(OTHER), scope(NULL), name(NULL), cst(NULL) {
		_domain.i()=Interval(v,v);
	}

	LabelConst(const Interval&amp; itv) : _domain(Dim::scalar()), num_type(OTHER), scope(NULL), name(NULL), cst(NULL) {
		_domain.i()=itv;
	}

	LabelConst(const Domain&amp; d, bool ref=false) : _domain(d,ref), num_type(OTHER), scope(NULL), name(NULL), cst(NULL) {

	}

	// Label of a constant symbol
	LabelConst(P_Scope&amp; scope, const char* name) : _domain(scope.get_cst(name),true), num_type(OTHER), scope(&amp;scope), name(strdup(name)), cst(NULL) {

	}

	~LabelConst() {
		if (name) free(name);
	}

	/**
	 * Create a node associated to the constant.
	 *
	 * Created only when really necessary to avoid memory leaks.
	 * In particular, the node of a constant symbol is not created
	 * automatically in the constructor (that is, when the constant
	 * is &quot;generated&quot;), because this constant may only appear in a
	 * constant expression that do not belong to the final expression.
	 *
	 * E.g., in the bounds of an interval:
	 *   constants c=[0,1];
	 *   variables x in [c,c];
	 *
	 * or in the iterator values:
	 *   constants c=10;
	 *   variables x(10);
	 *   constraints
	 *   for i=1:c
	 *     x(i)=i;
	 *   end
	 *
	 * In both cases, the constant expression is generated and deleted
	 * on-the-fly.
	 */
	virtual const ExprNode&amp; node() const {

		if (name==NULL) {
			if (num_type!=OTHER)
				throw SyntaxError(&quot;Unexpected infinity symbol \&quot;oo\&quot;&quot;);

			((LabelConst*) this)-&gt;cst = &amp;ExprConstant::new_(_domain);

		} else {
			cst = &amp;scope-&gt;get_cst_node(name);
		}

		return *cst;
	}

	virtual bool is_const() const {
		return name==NULL || !scope-&gt;is_mutable_cst_symbol(name);
	}

	virtual const Domain&amp; domain() const { return _domain; }

	virtual const Dim&amp; dim() const { return _domain.dim; }

	Domain _domain;
	number_type num_type;
	P_Scope* scope;            // only for P_ExprCstSymbol (NULL for numeric constants)
	char* name;                // only for P_ExprCstSymbol (NULL for numeric constants)
	mutable const ExprConstant* cst;

private:
	LabelConst(number_type num_type) : _domain(Dim::scalar()), num_type(num_type), scope(NULL), name(NULL), cst(NULL) {
		_domain.set_empty();
	}

};

int to_integer(const Domain&amp; d) {
	assert(d.dim.is_scalar());
	assert(d.i().is_degenerated());
	double x=d.i().mid();
	assert(std::floor(x)==x);
	return (int)x;
}

double to_double(const Domain&amp; d, bool round_downward) {
	assert(d.dim.is_scalar());
	// Note: requiring d.i().is_degenerated() is wrong,
	// the result of a calculus with degenerated intervals
	// may not be degenerated (and large).
	// Second, one may use Minibex interval constant like &quot;pi&quot;
	// in a bound of an interval, ex:
	// variables
	//     x in [0,pi].
	return round_downward? d.i().lb() : d.i().ub();
}

ExprGenerator::ExprGenerator() : scope(pstruct-&gt;scope()) {

}

ExprGenerator::ExprGenerator(P_Scope&amp; scope) : scope(scope) {

}

Domain ExprGenerator::generate_cst(const P_ExprNode&amp; y) {
	visit(y);
	Domain d=y.lab-&gt;domain();

	// cleanup important in case of the same expression
	// evaluated several times in different context
	// (iterator values changing)
	y.cleanup();
	return d;
}

int ExprGenerator::generate_int(const P_ExprNode&amp; y) {
	return to_integer(generate_cst(y));
}

double ExprGenerator::generate_dbl(const P_ExprNode&amp; y, bool round_downward) {
	visit(y);
	const Domain&amp; d=y.lab-&gt;domain();
	double value;

	switch(((LabelConst*) y.lab)-&gt;num_type) {
	case LabelConst::NEG_INF:
		value=NEG_INFINITY;
		break;
	case LabelConst::POS_INF:
		value=POS_INFINITY;
		break;
	default:
		value=to_double(d, round_downward);
	}
	y.cleanup();
	return value;
}

const ExprNode&amp; ExprGenerator::generate(const P_ExprNode&amp; y) {
//	// create the nodes for the constants symbols
//	// by default, all constants are used (see destruction below)
//	int m=scope.cst.size();
//	Array&lt;const ExprConstant&gt; csts(m);
//	for (int i=0; i&lt;m; i++) {
//		const char* id=scope.cst[i];
//		// Domains passed by copy
//		csts.set_ref(i,ExprConstant::new_(*scope.get_cst(id).second));
//		scope.bind_cst_node(id, csts[i]);
//	}

	visit(y);
	const ExprNode&amp; e=y.lab-&gt;node();

	// cleanup important in case of the same expression
	// evaluated several times in different context
	// (iterator values changing)
	y.cleanup();

	// destroy unused constants
//	for (int i=0; i&lt;m; i++) {
//		if (csts[i].fathers.is_empty() // no father
//				&amp;&amp; (&amp;csts[i]!=&amp;(y.lab-&gt;node())) // and not root node
//		)
//			delete &amp;csts[i];
//	}

	return e;
}

void ExprGenerator::visit(const P_ExprNode&amp; e) {

	if (e.lab!=NULL) return;

	if (e.op==P_ExprNode::POWER ||
		e.op==P_ExprNode::EXPR_WITH_IDX ||
		e.op==P_ExprNode::SUM) {
		e.accept_visitor(*this);
		return;
	}

	Array&lt;const Domain&gt; arg_cst(e.arg.size());

	bool all_cst=true;
	for (int i=0; i&lt;e.arg.size(); i++) {
		visit(e.arg[i]);
		all_cst = all_cst &amp;&amp; (e.arg[i].lab-&gt;is_const());
		if (all_cst) arg_cst.set_ref(i,e.arg[i].lab-&gt;domain());
	}

	if (all_cst) {

		if (e.op==P_ExprNode::MINUS) {
			LabelConst&amp; c=*((LabelConst*) e.arg[0].lab);
			switch(c.num_type) {
			case LabelConst::POS_INF:
				e.lab = LabelConst::neg_infinity();
				break;
			case LabelConst::NEG_INF:
				e.lab = LabelConst::pos_infinity();
				break;
			default:
				e.lab = new LabelConst(-arg_cst[0]);
			}
			return;
		}

		try {
			switch(e.op) {
			case P_ExprNode::INFTY:      e.lab=LabelConst::pos_infinity(); break;
			case P_ExprNode::VAR_SYMBOL: e.lab=new LabelNode(scope.get_var(((P_ExprVarSymbol&amp;) e).name).first); break;
			case P_ExprNode::CST_SYMBOL: e.lab=new LabelConst(scope, ((P_ExprCstSymbol&amp;) e).name); break;
			case P_ExprNode::TMP_SYMBOL: e.lab=new LabelNode(scope.get_tmp_expr_node(((P_ExprTmpSymbol&amp;) e).name)); break;
			case P_ExprNode::CST:        e.lab=new LabelConst(((P_ExprConstant&amp;) e).value,true); break;
			case P_ExprNode::ITER:       e.lab=new LabelConst(scope.get_iter_value(((P_ExprIter&amp;) e).name)); break;
			case P_ExprNode::IDX:
			case P_ExprNode::IDX_RANGE:
			case P_ExprNode::IDX_ALL:
			case P_ExprNode::EXPR_WITH_IDX:  assert(false); /* impossible */ break;
			case P_ExprNode::ROW_VEC:  e.lab=new LabelConst(Domain(arg_cst,true)); break;
			case P_ExprNode::COL_VEC:  e.lab=new LabelConst(Domain(arg_cst,false)); break;
			case P_ExprNode::APPLY:    e.lab=new LabelConst((((const P_ExprApply&amp;) e).f).basic_evaluator().eval(arg_cst)); break;
			case P_ExprNode::CHI:      not_implemented(&quot;Chi in constant expressions&quot;); break;
			case P_ExprNode::ADD:      e.lab=new LabelConst(arg_cst[0] + arg_cst[1]); break;
			case P_ExprNode::MUL:      e.lab=new LabelConst(arg_cst[0] * arg_cst[1]); break;
			case P_ExprNode::SUB:      e.lab=new LabelConst(arg_cst[0] - arg_cst[1]); break;
			case P_ExprNode::DIV:      e.lab=new LabelConst(arg_cst[0] / arg_cst[1]); break;
			case P_ExprNode::MAX:      e.lab=new LabelConst(max(arg_cst)); break;
			case P_ExprNode::MIN:      e.lab=new LabelConst(min(arg_cst)); break;
			case P_ExprNode::ATAN2:    e.lab=new LabelConst(atan2(arg_cst[0], arg_cst[1])); break;
			case P_ExprNode::POWER:
			case P_ExprNode::SUM:
			case P_ExprNode::MINUS:    assert(false); /* impossible */ break;
			case P_ExprNode::UNARY_OP: e.lab=new LabelConst(ExprGenericUnaryOp::get_eval(((const P_ExprGenericUnaryOp&amp;) e).name)(arg_cst[0])); break;
			case P_ExprNode::BINARY_OP:e.lab=new LabelConst(ExprGenericBinaryOp::get_eval(((const P_ExprGenericBinaryOp&amp;) e).name)(arg_cst[0],arg_cst[1])); break;
			case P_ExprNode::TRANS:    e.lab=new LabelConst(transpose(arg_cst[0])); break;
			case P_ExprNode::SIGN:     e.lab=new LabelConst(sign (arg_cst[0])); break;
			case P_ExprNode::ABS:      e.lab=new LabelConst(abs  (arg_cst[0])); break;
			case P_ExprNode::SQR:      e.lab=new LabelConst(sqr  (arg_cst[0])); break;
			case P_ExprNode::SQRT:     e.lab=new LabelConst(sqrt (arg_cst[0])); break;
			case P_ExprNode::EXP:      e.lab=new LabelConst(exp  (arg_cst[0])); break;
			case P_ExprNode::LOG:      e.lab=new LabelConst(log  (arg_cst[0])); break;
			case P_ExprNode::COS:      e.lab=new LabelConst(cos  (arg_cst[0])); break;
			case P_ExprNode::SIN:      e.lab=new LabelConst(sin  (arg_cst[0])); break;
			case P_ExprNode::TAN:      e.lab=new LabelConst(tan  (arg_cst[0])); break;
			case P_ExprNode::ACOS:     e.lab=new LabelConst(acos (arg_cst[0])); break;
			case P_ExprNode::ASIN:     e.lab=new LabelConst(asin (arg_cst[0])); break;
			case P_ExprNode::ATAN:     e.lab=new LabelConst(atan (arg_cst[0])); break;
			case P_ExprNode::COSH:     e.lab=new LabelConst(cosh (arg_cst[0])); break;
			case P_ExprNode::SINH:     e.lab=new LabelConst(sinh (arg_cst[0])); break;
			case P_ExprNode::TANH:     e.lab=new LabelConst(tanh (arg_cst[0])); break;
			case P_ExprNode::ACOSH:    e.lab=new LabelConst(acosh(arg_cst[0])); break;
			case P_ExprNode::ASINH:    e.lab=new LabelConst(asinh(arg_cst[0])); break;
			case P_ExprNode::ATANH:    e.lab=new LabelConst(atanh(arg_cst[0])); break;
			case P_ExprNode::FLOOR:    e.lab=new LabelConst(floor(arg_cst[0])); break;
			case P_ExprNode::CEIL:     e.lab=new LabelConst(ceil(arg_cst[0])); break;
			case P_ExprNode::SAW:      e.lab=new LabelConst(saw(arg_cst[0])); break;
			case P_ExprNode::DIFF:
				throw SyntaxError(&quot;\&quot;diff\&quot; cannot be applied to constants&quot;); break;
			case P_ExprNode::INF:
				if (!arg_cst[0].dim.is_scalar()) throw DimException(&quot;\&quot;inf\&quot; expects an interval as argument&quot;);
				e.lab=new LabelConst(arg_cst[0].i().lb()); break;
			case P_ExprNode::MID:
				if (!arg_cst[0].dim.is_scalar()) throw DimException(&quot;\&quot;mid\&quot; expects an interval as argument&quot;);
				e.lab=new LabelConst(arg_cst[0].i().mid()); break;
			case P_ExprNode::SUP:
				if (!arg_cst[0].dim.is_scalar()) throw DimException(&quot;\&quot;sup\&quot; expects an interval as argument&quot;);
				e.lab=new LabelConst(arg_cst[0].i().ub()); break;
			}
		} catch(DimException&amp; exc) {
			throw SyntaxError(exc.message(),NULL,e.line);
		}
		return;
	}

	Array&lt;const ExprNode&gt; arg_node(e.arg.size());

	for (int i=0; i&lt;e.arg.size(); i++) {
		// may force constants to become nodes
		arg_node.set_ref(i,e.arg[i].lab-&gt;node());
	}

	const ExprNode* node;

	try {
		switch(e.op) {
		case P_ExprNode::INFTY:
		case P_ExprNode::VAR_SYMBOL:
		case P_ExprNode::CST_SYMBOL:
		case P_ExprNode::TMP_SYMBOL:
		case P_ExprNode::CST:
		case P_ExprNode::ITER:
		case P_ExprNode::IDX:
		case P_ExprNode::IDX_RANGE:
		case P_ExprNode::IDX_ALL:
		case P_ExprNode::EXPR_WITH_IDX: assert(false); /* impossible */ break;
<A NAME="0"></A>		case P_ExprNode::ROW_VEC:   node=&amp;ExprVector::new_row(arg_node); break;
		case P_ExprNode::COL_VEC:   node=&amp;ExprVector::new_col(arg_node); break;
		case P_ExprNode::APPLY:     node=&amp;(((const P_ExprApply&amp;) e).f)(arg_node); break;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1730-0.html#0',2,'match1730-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		case P_ExprNode::CHI:       node=&amp;chi(arg_node[0], arg_node[1], arg_node[2]); break;
		case P_ExprNode::ADD:       node=&amp;(arg_node[0] + arg_node[1]); break;
		case P_ExprNode::MUL:       node=&amp;(arg_node[0] * arg_node[1]); break;
		case P_ExprNode::SUB:       node=&amp;(arg_node[0] - arg_node[1]); break;</B></FONT>
		case P_ExprNode::DIV:       node=&amp;(arg_node[0] / arg_node[1]); break;
		case P_ExprNode::MAX:       node=&amp;max(arg_node); break;
		case P_ExprNode::MIN:       node=&amp;min(arg_node); break;
		case P_ExprNode::ATAN2:     node=&amp;atan2(arg_node[0], arg_node[1]); break;
		case P_ExprNode::POWER:    
		case P_ExprNode::SUM:
									assert(false); /* impossible */ break;
		case P_ExprNode::MINUS:     node=&amp;(-arg_node[0]); break;
		case P_ExprNode::UNARY_OP:  node=&amp;ExprGenericUnaryOp::new_(((const P_ExprGenericUnaryOp&amp;) e).name, arg_node[0]); break;
		case P_ExprNode::BINARY_OP: node=&amp;ExprGenericBinaryOp::new_(((const P_ExprGenericBinaryOp&amp;) e).name, arg_node[0], arg_node[1]); break;
		case P_ExprNode::TRANS:     node=&amp;transpose(arg_node[0]); break;
		case P_ExprNode::SIGN:      node=&amp;sign (arg_node[0]); break;
		case P_ExprNode::ABS:       node=&amp;abs  (arg_node[0]); break;
		case P_ExprNode::SQR:       node=&amp;sqr  (arg_node[0]); break;
		case P_ExprNode::SQRT:      node=&amp;sqrt (arg_node[0]); break;
		case P_ExprNode::EXP:       node=&amp;exp  (arg_node[0]); break;
		case P_ExprNode::LOG:       node=&amp;log  (arg_node[0]); break;
		case P_ExprNode::COS:       node=&amp;cos  (arg_node[0]); break;
		case P_ExprNode::SIN:       node=&amp;sin  (arg_node[0]); break;
		case P_ExprNode::TAN:       node=&amp;tan  (arg_node[0]); break;
		case P_ExprNode::ACOS:      node=&amp;acos (arg_node[0]); break;
		case P_ExprNode::ASIN:      node=&amp;asin (arg_node[0]); break;
		case P_ExprNode::ATAN:      node=&amp;atan (arg_node[0]); break;
		case P_ExprNode::COSH:      node=&amp;cosh (arg_node[0]); break;
		case P_ExprNode::SINH:      node=&amp;sinh (arg_node[0]); break;
		case P_ExprNode::TANH:      node=&amp;tanh (arg_node[0]); break;
		case P_ExprNode::ACOSH:     node=&amp;acosh(arg_node[0]); break;
		case P_ExprNode::ASINH:     node=&amp;asinh(arg_node[0]); break;
		case P_ExprNode::ATANH:     node=&amp;atanh(arg_node[0]); break;
		case P_ExprNode::FLOOR:     node=&amp;floor(arg_node[0]); break;
		case P_ExprNode::CEIL:      node=&amp;ceil (arg_node[0]); break;
		case P_ExprNode::SAW:       node=&amp;saw  (arg_node[0]); break;
		case P_ExprNode::DIFF:      node=&amp;diff (arg_node); break;
		case P_ExprNode::INF:       throw SyntaxError(&quot;\&quot;inf\&quot; operator requires constant interval&quot;); break;
		case P_ExprNode::MID:       throw SyntaxError(&quot;\&quot;mid\&quot; operator requires constant interval&quot;); break;
		case P_ExprNode::SUP:       throw SyntaxError(&quot;\&quot;sup\&quot; operator requires constant interval&quot;); break;
		}
		e.lab = new LabelNode(node);
	} catch(DimException&amp; exc) {
		throw SyntaxError(exc.message(),NULL,e.line);
	}
}

void ExprGenerator::visit(const P_ExprPower&amp; e) {

	visit(e.arg[0]);
	visit(e.arg[1]);

	Label&amp; left=(*(e.arg[0].lab));
	Label&amp; right=(*(e.arg[1].lab));

	typedef enum { IBEX_INTEGER, IBEX_INTERVAL, IBEX_EXPRNODE } _type;
	_type right_type;
	_type left_type;

	int int_right=0;
	Interval itv_right;
	Interval itv_left;

	if (right.is_const()) {
		if (!right.domain().dim.is_scalar()) throw SyntaxError(&quot;exponent must be scalar&quot;);

		right_type=IBEX_INTERVAL;
		itv_right=right.domain().i();
		//delete cr; // not now (see comment in ExprCopy.h)
		// NOTE: we can delete cr because
		// even in the case where right_type==IBEX_INTERVAL and left_type==IBEX_EXPRNODE
		// we will recreate a ExprConstant node by multiplying itv_right (instead of RIGHT)
		// with LEFT.

		// try to see if the exponent is an integer
		if (itv_right.is_degenerated()) {
			double x=itv_right.mid();
			if (std::floor(x)==x) {
				right_type=IBEX_INTEGER;
				int_right=(int) std::floor(x);
			}
		}
	} else
		right_type=IBEX_EXPRNODE;


	if (left.is_const()) {
		left_type=IBEX_INTERVAL;
		itv_left=left.domain().i();
		//delete cl; // LEFT will no longer be used // not now (see comment in ExprCopy.h)
	} else
		left_type=IBEX_EXPRNODE;


	if (left_type==IBEX_INTERVAL) {
		if (right_type==IBEX_INTEGER) {
			e.lab=new LabelConst(pow(itv_left,int_right));
		} else if (right_type==IBEX_INTERVAL) {
			e.lab=new LabelConst(pow(itv_left,itv_right));
		} else {
			e.lab=new LabelNode(&amp;exp(right.node() * log(itv_left))); // *log(...) will create a new ExprConstant.
		}
	}  else {
		if (right_type==IBEX_INTEGER) {
			e.lab=new LabelNode(&amp;pow(left.node(),int_right));
		} else if (right_type==IBEX_INTERVAL) {
			e.lab=new LabelNode(&amp;exp(itv_right * log(left.node())));
		} else {
			e.lab=new LabelNode(&amp;exp(right.node() * log(left.node())));
		}
	}
}

void ExprGenerator::visit(const P_ExprSum&amp; e) {

	const P_ExprNode&amp; first_value = e.arg[0];
	const P_ExprNode&amp; last_value  = e.arg[1];
	const P_ExprNode&amp; expr        = e.arg[2];

	visit(first_value);
	visit(last_value);

	const char* name     = e.iter;

	int begin=first_value._2int();
	int end=last_value._2int();
	if(end &lt; begin) {
		ostringstream s;
		s &lt;&lt; &quot;first value &lt; end value (&quot; &lt;&lt; begin &lt;&lt; &quot; &lt; &quot; &lt;&lt; end &lt;&lt; &quot;). &quot;;
		s &lt;&lt; &quot;First value must be &gt;= end value.&quot;;
		throw SyntaxError(s.str());
	}
	scope.push();
	scope.add_iterator(name);
	const ExprNode* node;

	bool is_const = true;
	Domain* domain = nullptr;
	// Visit with begin value to initialize the node value
	scope.set_iter_value(name,begin);
	visit(expr);
	if(expr.lab-&gt;is_const()) {
		domain = new Domain(expr.lab-&gt;domain());
	} else {
		is_const = false;
	}
	node = &amp;expr.lab-&gt;node();
	expr.cleanup();
	for (int i=begin+1; i&lt;=end; i++) {
		scope.set_iter_value(name,i);
		visit(expr);
		if(!expr.lab-&gt;is_const()) {
			is_const = false;
		} else if(is_const) {
			*domain = *domain + expr.lab-&gt;domain();
		}
		node =&amp;(*node + expr.lab-&gt;node());
		expr.cleanup();
	}

	if(is_const) {
		e.lab = new LabelConst(*domain);
		cleanup(*node, false);
	} else {
		e.lab = new LabelNode(node);
	}
	delete domain;
	scope.pop();
}

pair&lt;int,int&gt; ExprGenerator::visit_index_tmp(const Dim&amp; dim, const P_ExprNode&amp; idx, bool matlab_style) {
	int i1,i2;

	switch(idx.op) {
	case P_ExprNode::IDX_ALL :
		assert(idx.arg.size()==0);
		i1=i2=-1;
		break;
	case P_ExprNode::IDX_RANGE :
		assert(idx.arg.size()==2);
		visit(idx.arg[0]);
		visit(idx.arg[1]);
		assert(idx.arg[0].lab-&gt;is_const());
		assert(idx.arg[1].lab-&gt;is_const());
		i1=to_integer(idx.arg[0].lab-&gt;domain());
		i2=to_integer(idx.arg[1].lab-&gt;domain());
		if (matlab_style) { i1--; i2--; }
		if (i1&lt;0 || i2&lt;0)
			throw SyntaxError(&quot;negative index. Note: indices in Matlab-style (using parenthesis like in \&quot;x(i)\&quot;) start from 1 (not 0).&quot;);
		break;
	case P_ExprNode::IDX :
		assert(idx.arg.size()==1);
		visit(idx.arg[0]);
		assert(idx.arg[0].lab-&gt;is_const());
		i1=i2=to_integer(idx.arg[0].lab-&gt;domain());
		if (matlab_style) { i1--; i2--; }
		if (i1&lt;0)
			throw SyntaxError(&quot;negative index. Note: indices in Matlab-style (using parenthesis like in \&quot;x(i)\&quot;) start from 1 (not 0).&quot;);
		break;
	default:
		assert(false);
	}

	/**
	 * To be clean, we should create a LabeNode subclass
	 * that contains the returned pair. Meanwhile, we
	 * have to create a dummy label so that
	 * the cleanup will not consider this node as already visited
	 * (and delete properly the labels of the index/indices).
	 */
	idx.lab = new LabelConst(0); // dummy

	return pair&lt;int,int&gt;(i1,i2);
}

DoubleIndex ExprGenerator::visit_index(const Dim&amp; dim, const P_ExprNode&amp; idx1, bool matlab_style) {

	pair&lt;int,int&gt; p=visit_index_tmp(dim,idx1,matlab_style);

	// If only one index is supplied
	// it may corresponds to a row number or
	// a column number (in case of row vector).
	if (p.first==-1) {
		return DoubleIndex::all(dim);
	} else if (p.second==p.first) {
		return DoubleIndex::one_index(dim,p.first);
	} else {
		if (dim.nb_rows()&gt;1)
			return DoubleIndex::rows(dim,p.first,p.second);
		else
			return DoubleIndex::cols(dim,p.first,p.second);
	}
}

DoubleIndex ExprGenerator::visit_index(const Dim&amp; dim, const P_ExprNode&amp; idx1, const P_ExprNode&amp; idx2, bool matlab_style) {

	pair&lt;int,int&gt; r=visit_index_tmp(dim,idx1,matlab_style);
	pair&lt;int,int&gt; c=visit_index_tmp(dim,idx2,matlab_style);

	if (r.first==-1) {
		if (c.first==-1)
			return DoubleIndex::all(dim);
		else if (c.first==c.second)
			return DoubleIndex::one_col(dim,c.first);
		else
			return DoubleIndex::cols(dim,c.first,c.second);
	} else if (r.first==r.second) {
		if (c.first==-1)
			return DoubleIndex::one_row(dim,r.first);
		else if (c.first==c.second)
			return DoubleIndex::one_elt(dim,r.first,c.first);
		else
			return DoubleIndex::subrow(dim,r.first,c.first,c.second);
	} else {
		if (c.first==-1)
			return DoubleIndex::rows(dim,r.first,r.second);
		else if (c.first==c.second)
			return DoubleIndex::subcol(dim,r.first,r.second,c.first);
		else
			return DoubleIndex::submatrix(dim,r.first,r.second,c.first,c.second);
	}
}

void ExprGenerator::visit(const P_ExprWithIndex&amp; e) {
	visit(e.arg[0]);

	Label&amp; expr=(*(e.arg[0].lab));

	DoubleIndex idx=e.arg.size()==2?
			visit_index(expr.dim(), e.arg[1], e.matlab_style)
			:
			visit_index(expr.dim(), e.arg[1], e.arg[2], e.matlab_style);

	if (expr.is_const()) {
		Domain d=expr.domain()[idx];
		e.lab = new LabelConst(d,d.is_reference);
	} else {
		e.lab = new LabelNode(&amp;ExprIndex::new_(expr.node(),idx));
	}
}

const ExprNode&amp; ExprGenerator::diff(const Array&lt;const ExprNode&gt;&amp; args) {
	assert(args.size()&gt;1);

	// get &quot;y&quot;
	const ExprNode&amp; y=args[0];

	// get the expressions &quot;x&quot;
	// (removing the first node, which is &quot;y&quot;)
	Array&lt;const ExprSymbol&gt; x(args.size()-1);
	for (int i=0; i&lt;args.size()-1; i++) {
		const ExprSymbol* xi=dynamic_cast&lt;const ExprSymbol*&gt;(&amp;args[i+1]);
		if (!xi) {
			throw SyntaxError(&quot;\&quot;diff\&quot; can only be applied to symbols&quot;);
		}
		x.set_ref(i,*xi);
	}

	ExprDiff d;
	/*
	 * All expressions (and their sub-expressions) resulting from temporary
	 * symbols or constants generation, should not be deleted by the
	 * simplification process of &quot;diff&quot;.
	 *
	 * TODO: If these symbols are not used elsewhere -&gt; memory leak.
	 * Example:
	 *
	 * constants
	 *   c=1;
	 * variables
	 *   x;
	 * constraints
	 *   diff(x+c,x)=1;  // -&gt; memory leak
	 * end
	 */
	std::vector&lt;const ExprNode*&gt; tmp_expr=scope.get_all_existing_nodes();

	ExprSubNodes tmp_expr_nodes(tmp_expr);
	for (int i=0; i&lt;tmp_expr_nodes.size(); i++)
		d.lock.insert(tmp_expr_nodes[i],true);

	return d.diff(y,x);
}

} // end namespace parser
} // end namespace ibex
</PRE>
</div>
  </div>
</body>
</html>
