<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_NumConstraint.cpp &amp; ibex_P_ExprGenerator.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_NumConstraint.cpp &amp; ibex_P_ExprGenerator.cpp
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_NumConstraint.cpp (6.425703%)<th>ibex_P_ExprGenerator.cpp (1.5311005%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(174-177)<td><a href="#" name="0">(364-367)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_NumConstraint.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_NumConstraint.h"
2 #include "ibex_SyntaxError.h"
3 #include "ibex_System.h"
4 #include "ibex_ExprCopy.h"
5 #include "ibex_Id.h"
6 #include "ibex_P_Struct.h"
7 #include &lt;sstream&gt;
8 #include &lt;mutex&gt;
9 #ifndef _WIN32 #include &lt;mutex&gt;
10 namespace {
11 std::mutex mtx;
12 }
13 #define LOCK mtx.lock()
14 #define UNLOCK mtx.unlock()
15 #else
16 #define LOCK
17 #define UNLOCK
18 #endif
19 using namespace std;
20 extern void ibexparse_string(const char* syntax);
21 namespace ibex {
22 NumConstraint::NumConstraint(const char* filename) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
23 	build_from_system(System(filename));
24 }
25 NumConstraint::NumConstraint(const char* x, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
26 	build_from_string(Array&lt;const char*&gt;(x),c);
27 }
28 NumConstraint::NumConstraint(const char* x1, const char* x2, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
29 	build_from_string(Array&lt;const char*&gt;(x1,x2),c);
30 }
31 NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
32 	build_from_string(Array&lt;const char*&gt;(x1,x2,x3),c);
33 }
34 NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
35 	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4),c);
36 }
37 NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
38 	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4,x5),c);
39 }
40 NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
41 	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4,x5,x6),c);
42 }
43 NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
44 	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4,x5,x6,x7),c);
45 }
46 NumConstraint::NumConstraint(const char* x1, const char* x2, const char* x3, const char* x4, const char* x5, const char* x6, const char* x7, const char* x8, const char* c) : id(next_id()), f(*new Function()), op(EQ), own_f(true) {
47 	build_from_string(Array&lt;const char*&gt;(x1,x2,x3,x4,x5,x6,x7,x8),c);
48 }
49 void NumConstraint::build_from_string(const Array&lt;const char*&gt;&amp; _x, const char* c) {
50 	stringstream s;
51 	s &lt;&lt; "variables\n  ";
52 	for (int i=0; i&lt;_x.size(); i++) {
53 		s &lt;&lt; _x[i];
54 		if (i&lt;_x.size()-1) s &lt;&lt; ",";
55 	}
56 	s &lt;&lt; ";\n\n";
57 	s &lt;&lt; "constraints\n  ";
58 	s &lt;&lt; c &lt;&lt; '\n';
59 	s &lt;&lt; "end\n";
60 	System* sys=new System(); 
61 	char* syntax = strdup(s.str().c_str());
62 	LOCK;
63 	try {
64 		parser::pstruct = new parser::P_StructSystem(*sys, ExprNode::default_simpl_level);
65 		ibexparse_string(syntax);
66 		delete parser::pstruct;
67 		parser::pstruct = NULL;
68 		free(syntax);
69 	} catch(SyntaxError&amp; e) {
70 		delete parser::pstruct;
71 		parser::pstruct = NULL;
72 		free(syntax);
73 		UNLOCK;
74 		throw e;
75 	}
76 	UNLOCK;
77 	build_from_system(*sys);
78 	delete sys;
79 }
80 void NumConstraint::build_from_system(const System&amp; sys) {
81 	if (sys.nb_ctr==0) {
82 		throw SyntaxError("There is no constraint");
83 	}
84 	NumConstraint&amp; c0=sys.ctrs[0]; 
85 	Array&lt;const ExprSymbol&gt; x(sys.f_ctrs.nb_arg());
86 	varcopy(c0.f.args(),x);
87 	const ExprNode&amp; y=ExprCopy().copy(c0.f.args(),x,c0.f.expr());
88 	((Function&amp;) f).init(x,y);
89 	(CmpOp&amp;) op = c0.op;
90 }
91 #define RETURN(a,b) return pair&lt;const ExprNode*, const Interval*&gt;(a,b)
92 //	//	
93 Domain NumConstraint::right_hand_side() const {
94 	Domain d(f.expr().dim);
95 	Interval right_cst;
96 	switch (op) {
97 	case LT :
98 	case LEQ : right_cst=Interval::neg_reals(); break;
99 	case EQ  : right_cst=Interval::zero();      break;
100 	case GEQ :
101 	case GT : right_cst=Interval::pos_reals();  break;
102 <a name="0"></a>	}
103 	switch(d.dim.type()) {
104 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	case Dim::SCALAR:       d.i()=right_cst; break;
105 	case Dim::ROW_VECTOR:   d.v()=IntervalVector(d.dim.nb_cols(),right_cst); break;
106 	case Dim::COL_VECTOR:   d.v()=IntervalVector(d.dim.nb_rows(),right_cst); break;
107 	case Dim::MATRIX:       d.m()=IntervalMatrix(d.dim.nb_rows(),d.dim.nb_cols(),right_cst); break;</b></font>
108 	}
109 	return d;
110 }
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_P_ExprGenerator.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_P_ExprGenerator.h"
2 #include "ibex_P_Struct.h"
3 #include "ibex_SyntaxError.h"
4 #include "ibex_Exception.h"
5 #include "ibex_Expr.h"
6 #include "ibex_ExprDiff.h"
7 #include &lt;sstream&gt;
8 #include &lt;stdlib.h&gt;
9 using namespace std;
10 namespace ibex {
11 namespace parser {
12 class LabelNode : public Label {
13 public:
14 	LabelNode(const ExprNode* node) : _node(node) { }
15 	virtual ~LabelNode() { }
16 	virtual const ExprNode&amp; node() const { return *_node; }
17 	virtual bool is_const() const { return false; }
18 	virtual const Domain&amp; domain() const {
19 		throw SyntaxError("Unexpected symbol inside constant expression");
20 	}
21 	virtual const Dim&amp; dim() const { return _node-&gt;dim; }
22 	const ExprNode* _node;
23 };
24 class LabelConst : public Label {
25 public:
26 	typedef enum { NEG_INF=0, POS_INF=1, OTHER=2 } number_type;
27 	static LabelConst* pos_infinity() {
28 		return new LabelConst(POS_INF);
29 	}
30 	static LabelConst* neg_infinity() {
31 		return new LabelConst(NEG_INF);
32 	}
33 	LabelConst(int v) : _domain(Dim::scalar()), num_type(OTHER), scope(NULL), name(NULL), cst(NULL) {
34 		_domain.i()=Interval(v,v);
35 	}
36 	LabelConst(const Interval&amp; itv) : _domain(Dim::scalar()), num_type(OTHER), scope(NULL), name(NULL), cst(NULL) {
37 		_domain.i()=itv;
38 	}
39 	LabelConst(const Domain&amp; d, bool ref=false) : _domain(d,ref), num_type(OTHER), scope(NULL), name(NULL), cst(NULL) {
40 	}
41 	LabelConst(P_Scope&amp; scope, const char* name) : _domain(scope.get_cst(name),true), num_type(OTHER), scope(&amp;scope), name(strdup(name)), cst(NULL) {
42 	}
43 	~LabelConst() {
44 		if (name) free(name);
45 	}
46 	virtual const ExprNode&amp; node() const {
47 		if (name==NULL) {
48 			if (num_type!=OTHER)
49 				throw SyntaxError("Unexpected infinity symbol \"oo\"");
50 			((LabelConst*) this)-&gt;cst = &amp;ExprConstant::new_(_domain);
51 		} else {
52 			cst = &amp;scope-&gt;get_cst_node(name);
53 		}
54 		return *cst;
55 	}
56 	virtual bool is_const() const {
57 		return name==NULL || !scope-&gt;is_mutable_cst_symbol(name);
58 	}
59 	virtual const Domain&amp; domain() const { return _domain; }
60 	virtual const Dim&amp; dim() const { return _domain.dim; }
61 	Domain _domain;
62 	number_type num_type;
63 	P_Scope* scope;            	char* name;                	mutable const ExprConstant* cst;
64 private:
65 	LabelConst(number_type num_type) : _domain(Dim::scalar()), num_type(num_type), scope(NULL), name(NULL), cst(NULL) {
66 		_domain.set_empty();
67 	}
68 };
69 int to_integer(const Domain&amp; d) {
70 	assert(d.dim.is_scalar());
71 	assert(d.i().is_degenerated());
72 	double x=d.i().mid();
73 	assert(std::floor(x)==x);
74 	return (int)x;
75 }
76 double to_double(const Domain&amp; d, bool round_downward) {
77 	assert(d.dim.is_scalar());
78 	return round_downward? d.i().lb() : d.i().ub();
79 }
80 ExprGenerator::ExprGenerator() : scope(pstruct-&gt;scope()) {
81 }
82 ExprGenerator::ExprGenerator(P_Scope&amp; scope) : scope(scope) {
83 }
84 Domain ExprGenerator::generate_cst(const P_ExprNode&amp; y) {
85 	visit(y);
86 	Domain d=y.lab-&gt;domain();
87 	y.cleanup();
88 	return d;
89 }
90 int ExprGenerator::generate_int(const P_ExprNode&amp; y) {
91 	return to_integer(generate_cst(y));
92 }
93 double ExprGenerator::generate_dbl(const P_ExprNode&amp; y, bool round_downward) {
94 	visit(y);
95 	const Domain&amp; d=y.lab-&gt;domain();
96 	double value;
97 	switch(((LabelConst*) y.lab)-&gt;num_type) {
98 	case LabelConst::NEG_INF:
99 		value=NEG_INFINITY;
100 		break;
101 	case LabelConst::POS_INF:
102 		value=POS_INFINITY;
103 		break;
104 	default:
105 		value=to_double(d, round_downward);
106 	}
107 	y.cleanup();
108 	return value;
109 }
110 const ExprNode&amp; ExprGenerator::generate(const P_ExprNode&amp; y) {
111 //	//	//		
112 	visit(y);
113 	const ExprNode&amp; e=y.lab-&gt;node();
114 	y.cleanup();
115 //		if (csts[i].fathers.is_empty() //				&amp;&amp; (&amp;csts[i]!=&amp;(y.lab-&gt;node())) 
116 	return e;
117 }
118 void ExprGenerator::visit(const P_ExprNode&amp; e) {
119 	if (e.lab!=NULL) return;
120 	if (e.op==P_ExprNode::POWER ||
121 		e.op==P_ExprNode::EXPR_WITH_IDX ||
122 		e.op==P_ExprNode::SUM) {
123 		e.accept_visitor(*this);
124 		return;
125 	}
126 	Array&lt;const Domain&gt; arg_cst(e.arg.size());
127 	bool all_cst=true;
128 	for (int i=0; i&lt;e.arg.size(); i++) {
129 		visit(e.arg[i]);
130 		all_cst = all_cst &amp;&amp; (e.arg[i].lab-&gt;is_const());
131 		if (all_cst) arg_cst.set_ref(i,e.arg[i].lab-&gt;domain());
132 	}
133 	if (all_cst) {
134 		if (e.op==P_ExprNode::MINUS) {
135 			LabelConst&amp; c=*((LabelConst*) e.arg[0].lab);
136 			switch(c.num_type) {
137 			case LabelConst::POS_INF:
138 				e.lab = LabelConst::neg_infinity();
139 				break;
140 			case LabelConst::NEG_INF:
141 				e.lab = LabelConst::pos_infinity();
142 				break;
143 			default:
144 				e.lab = new LabelConst(-arg_cst[0]);
145 			}
146 			return;
147 		}
148 		try {
149 			switch(e.op) {
150 			case P_ExprNode::INFTY:      e.lab=LabelConst::pos_infinity(); break;
151 			case P_ExprNode::VAR_SYMBOL: e.lab=new LabelNode(scope.get_var(((P_ExprVarSymbol&amp;) e).name).first); break;
152 			case P_ExprNode::CST_SYMBOL: e.lab=new LabelConst(scope, ((P_ExprCstSymbol&amp;) e).name); break;
153 			case P_ExprNode::TMP_SYMBOL: e.lab=new LabelNode(scope.get_tmp_expr_node(((P_ExprTmpSymbol&amp;) e).name)); break;
154 			case P_ExprNode::CST:        e.lab=new LabelConst(((P_ExprConstant&amp;) e).value,true); break;
155 			case P_ExprNode::ITER:       e.lab=new LabelConst(scope.get_iter_value(((P_ExprIter&amp;) e).name)); break;
156 			case P_ExprNode::IDX:
157 			case P_ExprNode::IDX_RANGE:
158 			case P_ExprNode::IDX_ALL:
159 			case P_ExprNode::EXPR_WITH_IDX:  assert(false); 			case P_ExprNode::ROW_VEC:  e.lab=new LabelConst(Domain(arg_cst,true)); break;
160 			case P_ExprNode::COL_VEC:  e.lab=new LabelConst(Domain(arg_cst,false)); break;
161 			case P_ExprNode::APPLY:    e.lab=new LabelConst((((const P_ExprApply&amp;) e).f).basic_evaluator().eval(arg_cst)); break;
162 			case P_ExprNode::CHI:      not_implemented("Chi in constant expressions"); break;
163 			case P_ExprNode::ADD:      e.lab=new LabelConst(arg_cst[0] + arg_cst[1]); break;
164 			case P_ExprNode::MUL:      e.lab=new LabelConst(arg_cst[0] * arg_cst[1]); break;
165 			case P_ExprNode::SUB:      e.lab=new LabelConst(arg_cst[0] - arg_cst[1]); break;
166 			case P_ExprNode::DIV:      e.lab=new LabelConst(arg_cst[0] / arg_cst[1]); break;
167 			case P_ExprNode::MAX:      e.lab=new LabelConst(max(arg_cst)); break;
168 			case P_ExprNode::MIN:      e.lab=new LabelConst(min(arg_cst)); break;
169 			case P_ExprNode::ATAN2:    e.lab=new LabelConst(atan2(arg_cst[0], arg_cst[1])); break;
170 			case P_ExprNode::POWER:
171 			case P_ExprNode::SUM:
172 			case P_ExprNode::MINUS:    assert(false); 			case P_ExprNode::UNARY_OP: e.lab=new LabelConst(ExprGenericUnaryOp::get_eval(((const P_ExprGenericUnaryOp&amp;) e).name)(arg_cst[0])); break;
173 			case P_ExprNode::BINARY_OP:e.lab=new LabelConst(ExprGenericBinaryOp::get_eval(((const P_ExprGenericBinaryOp&amp;) e).name)(arg_cst[0],arg_cst[1])); break;
174 			case P_ExprNode::TRANS:    e.lab=new LabelConst(transpose(arg_cst[0])); break;
175 			case P_ExprNode::SIGN:     e.lab=new LabelConst(sign (arg_cst[0])); break;
176 			case P_ExprNode::ABS:      e.lab=new LabelConst(abs  (arg_cst[0])); break;
177 			case P_ExprNode::SQR:      e.lab=new LabelConst(sqr  (arg_cst[0])); break;
178 			case P_ExprNode::SQRT:     e.lab=new LabelConst(sqrt (arg_cst[0])); break;
179 			case P_ExprNode::EXP:      e.lab=new LabelConst(exp  (arg_cst[0])); break;
180 			case P_ExprNode::LOG:      e.lab=new LabelConst(log  (arg_cst[0])); break;
181 			case P_ExprNode::COS:      e.lab=new LabelConst(cos  (arg_cst[0])); break;
182 			case P_ExprNode::SIN:      e.lab=new LabelConst(sin  (arg_cst[0])); break;
183 			case P_ExprNode::TAN:      e.lab=new LabelConst(tan  (arg_cst[0])); break;
184 			case P_ExprNode::ACOS:     e.lab=new LabelConst(acos (arg_cst[0])); break;
185 			case P_ExprNode::ASIN:     e.lab=new LabelConst(asin (arg_cst[0])); break;
186 			case P_ExprNode::ATAN:     e.lab=new LabelConst(atan (arg_cst[0])); break;
187 			case P_ExprNode::COSH:     e.lab=new LabelConst(cosh (arg_cst[0])); break;
188 			case P_ExprNode::SINH:     e.lab=new LabelConst(sinh (arg_cst[0])); break;
189 			case P_ExprNode::TANH:     e.lab=new LabelConst(tanh (arg_cst[0])); break;
190 			case P_ExprNode::ACOSH:    e.lab=new LabelConst(acosh(arg_cst[0])); break;
191 			case P_ExprNode::ASINH:    e.lab=new LabelConst(asinh(arg_cst[0])); break;
192 			case P_ExprNode::ATANH:    e.lab=new LabelConst(atanh(arg_cst[0])); break;
193 			case P_ExprNode::FLOOR:    e.lab=new LabelConst(floor(arg_cst[0])); break;
194 			case P_ExprNode::CEIL:     e.lab=new LabelConst(ceil(arg_cst[0])); break;
195 			case P_ExprNode::SAW:      e.lab=new LabelConst(saw(arg_cst[0])); break;
196 			case P_ExprNode::DIFF:
197 				throw SyntaxError("\"diff\" cannot be applied to constants"); break;
198 			case P_ExprNode::INF:
199 				if (!arg_cst[0].dim.is_scalar()) throw DimException("\"inf\" expects an interval as argument");
200 				e.lab=new LabelConst(arg_cst[0].i().lb()); break;
201 			case P_ExprNode::MID:
202 				if (!arg_cst[0].dim.is_scalar()) throw DimException("\"mid\" expects an interval as argument");
203 				e.lab=new LabelConst(arg_cst[0].i().mid()); break;
204 			case P_ExprNode::SUP:
205 				if (!arg_cst[0].dim.is_scalar()) throw DimException("\"sup\" expects an interval as argument");
206 				e.lab=new LabelConst(arg_cst[0].i().ub()); break;
207 			}
208 		} catch(DimException&amp; exc) {
209 			throw SyntaxError(exc.message(),NULL,e.line);
210 		}
211 		return;
212 	}
213 	Array&lt;const ExprNode&gt; arg_node(e.arg.size());
214 	for (int i=0; i&lt;e.arg.size(); i++) {
215 		arg_node.set_ref(i,e.arg[i].lab-&gt;node());
216 	}
217 	const ExprNode* node;
218 	try {
219 		switch(e.op) {
220 		case P_ExprNode::INFTY:
221 		case P_ExprNode::VAR_SYMBOL:
222 		case P_ExprNode::CST_SYMBOL:
223 		case P_ExprNode::TMP_SYMBOL:
224 		case P_ExprNode::CST:
225 		case P_ExprNode::ITER:
226 		case P_ExprNode::IDX:
227 		case P_ExprNode::IDX_RANGE:
228 		case P_ExprNode::IDX_ALL:
229 		case P_ExprNode::EXPR_WITH_IDX: assert(false); <a name="0"></a>		case P_ExprNode::ROW_VEC:   node=&amp;ExprVector::new_row(arg_node); break;
230 		case P_ExprNode::COL_VEC:   node=&amp;ExprVector::new_col(arg_node); break;
231 		case P_ExprNode::APPLY:     node=&amp;(((const P_ExprApply&amp;) e).f)(arg_node); break;
232 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		case P_ExprNode::CHI:       node=&amp;chi(arg_node[0], arg_node[1], arg_node[2]); break;
233 		case P_ExprNode::ADD:       node=&amp;(arg_node[0] + arg_node[1]); break;
234 		case P_ExprNode::MUL:       node=&amp;(arg_node[0] * arg_node[1]); break;
235 		case P_ExprNode::SUB:       node=&amp;(arg_node[0] - arg_node[1]); break;</b></font>
236 		case P_ExprNode::DIV:       node=&amp;(arg_node[0] / arg_node[1]); break;
237 		case P_ExprNode::MAX:       node=&amp;max(arg_node); break;
238 		case P_ExprNode::MIN:       node=&amp;min(arg_node); break;
239 		case P_ExprNode::ATAN2:     node=&amp;atan2(arg_node[0], arg_node[1]); break;
240 		case P_ExprNode::POWER:    
241 		case P_ExprNode::SUM:
242 									assert(false); 		case P_ExprNode::MINUS:     node=&amp;(-arg_node[0]); break;
243 		case P_ExprNode::UNARY_OP:  node=&amp;ExprGenericUnaryOp::new_(((const P_ExprGenericUnaryOp&amp;) e).name, arg_node[0]); break;
244 		case P_ExprNode::BINARY_OP: node=&amp;ExprGenericBinaryOp::new_(((const P_ExprGenericBinaryOp&amp;) e).name, arg_node[0], arg_node[1]); break;
245 		case P_ExprNode::TRANS:     node=&amp;transpose(arg_node[0]); break;
246 		case P_ExprNode::SIGN:      node=&amp;sign (arg_node[0]); break;
247 		case P_ExprNode::ABS:       node=&amp;abs  (arg_node[0]); break;
248 		case P_ExprNode::SQR:       node=&amp;sqr  (arg_node[0]); break;
249 		case P_ExprNode::SQRT:      node=&amp;sqrt (arg_node[0]); break;
250 		case P_ExprNode::EXP:       node=&amp;exp  (arg_node[0]); break;
251 		case P_ExprNode::LOG:       node=&amp;log  (arg_node[0]); break;
252 		case P_ExprNode::COS:       node=&amp;cos  (arg_node[0]); break;
253 		case P_ExprNode::SIN:       node=&amp;sin  (arg_node[0]); break;
254 		case P_ExprNode::TAN:       node=&amp;tan  (arg_node[0]); break;
255 		case P_ExprNode::ACOS:      node=&amp;acos (arg_node[0]); break;
256 		case P_ExprNode::ASIN:      node=&amp;asin (arg_node[0]); break;
257 		case P_ExprNode::ATAN:      node=&amp;atan (arg_node[0]); break;
258 		case P_ExprNode::COSH:      node=&amp;cosh (arg_node[0]); break;
259 		case P_ExprNode::SINH:      node=&amp;sinh (arg_node[0]); break;
260 		case P_ExprNode::TANH:      node=&amp;tanh (arg_node[0]); break;
261 		case P_ExprNode::ACOSH:     node=&amp;acosh(arg_node[0]); break;
262 		case P_ExprNode::ASINH:     node=&amp;asinh(arg_node[0]); break;
263 		case P_ExprNode::ATANH:     node=&amp;atanh(arg_node[0]); break;
264 		case P_ExprNode::FLOOR:     node=&amp;floor(arg_node[0]); break;
265 		case P_ExprNode::CEIL:      node=&amp;ceil (arg_node[0]); break;
266 		case P_ExprNode::SAW:       node=&amp;saw  (arg_node[0]); break;
267 		case P_ExprNode::DIFF:      node=&amp;diff (arg_node); break;
268 		case P_ExprNode::INF:       throw SyntaxError("\"inf\" operator requires constant interval"); break;
269 		case P_ExprNode::MID:       throw SyntaxError("\"mid\" operator requires constant interval"); break;
270 		case P_ExprNode::SUP:       throw SyntaxError("\"sup\" operator requires constant interval"); break;
271 		}
272 		e.lab = new LabelNode(node);
273 	} catch(DimException&amp; exc) {
274 		throw SyntaxError(exc.message(),NULL,e.line);
275 	}
276 }
277 void ExprGenerator::visit(const P_ExprPower&amp; e) {
278 	visit(e.arg[0]);
279 	visit(e.arg[1]);
280 	Label&amp; left=(*(e.arg[0].lab));
281 	Label&amp; right=(*(e.arg[1].lab));
282 	typedef enum { IBEX_INTEGER, IBEX_INTERVAL, IBEX_EXPRNODE } _type;
283 	_type right_type;
284 	_type left_type;
285 	int int_right=0;
286 	Interval itv_right;
287 	Interval itv_left;
288 	if (right.is_const()) {
289 		if (!right.domain().dim.is_scalar()) throw SyntaxError("exponent must be scalar");
290 		right_type=IBEX_INTERVAL;
291 		itv_right=right.domain().i();
292 		//delete cr; 
293 		if (itv_right.is_degenerated()) {
294 			double x=itv_right.mid();
295 			if (std::floor(x)==x) {
296 				right_type=IBEX_INTEGER;
297 				int_right=(int) std::floor(x);
298 			}
299 		}
300 	} else
301 		right_type=IBEX_EXPRNODE;
302 	if (left.is_const()) {
303 		left_type=IBEX_INTERVAL;
304 		itv_left=left.domain().i();
305 		//delete cl; 	} else
306 		left_type=IBEX_EXPRNODE;
307 	if (left_type==IBEX_INTERVAL) {
308 		if (right_type==IBEX_INTEGER) {
309 			e.lab=new LabelConst(pow(itv_left,int_right));
310 		} else if (right_type==IBEX_INTERVAL) {
311 			e.lab=new LabelConst(pow(itv_left,itv_right));
312 		} else {
313 			e.lab=new LabelNode(&amp;exp(right.node() * log(itv_left))); 		}
314 	}  else {
315 		if (right_type==IBEX_INTEGER) {
316 			e.lab=new LabelNode(&amp;pow(left.node(),int_right));
317 		} else if (right_type==IBEX_INTERVAL) {
318 			e.lab=new LabelNode(&amp;exp(itv_right * log(left.node())));
319 		} else {
320 			e.lab=new LabelNode(&amp;exp(right.node() * log(left.node())));
321 		}
322 	}
323 }
324 void ExprGenerator::visit(const P_ExprSum&amp; e) {
325 	const P_ExprNode&amp; first_value = e.arg[0];
326 	const P_ExprNode&amp; last_value  = e.arg[1];
327 	const P_ExprNode&amp; expr        = e.arg[2];
328 	visit(first_value);
329 	visit(last_value);
330 	const char* name     = e.iter;
331 	int begin=first_value._2int();
332 	int end=last_value._2int();
333 	if(end &lt; begin) {
334 		ostringstream s;
335 		s &lt;&lt; "first value &lt; end value (" &lt;&lt; begin &lt;&lt; " &lt; " &lt;&lt; end &lt;&lt; "). ";
336 		s &lt;&lt; "First value must be &gt;= end value.";
337 		throw SyntaxError(s.str());
338 	}
339 	scope.push();
340 	scope.add_iterator(name);
341 	const ExprNode* node;
342 	bool is_const = true;
343 	Domain* domain = nullptr;
344 	scope.set_iter_value(name,begin);
345 	visit(expr);
346 	if(expr.lab-&gt;is_const()) {
347 		domain = new Domain(expr.lab-&gt;domain());
348 	} else {
349 		is_const = false;
350 	}
351 	node = &amp;expr.lab-&gt;node();
352 	expr.cleanup();
353 	for (int i=begin+1; i&lt;=end; i++) {
354 		scope.set_iter_value(name,i);
355 		visit(expr);
356 		if(!expr.lab-&gt;is_const()) {
357 			is_const = false;
358 		} else if(is_const) {
359 			*domain = *domain + expr.lab-&gt;domain();
360 		}
361 		node =&amp;(*node + expr.lab-&gt;node());
362 		expr.cleanup();
363 	}
364 	if(is_const) {
365 		e.lab = new LabelConst(*domain);
366 		cleanup(*node, false);
367 	} else {
368 		e.lab = new LabelNode(node);
369 	}
370 	delete domain;
371 	scope.pop();
372 }
373 pair&lt;int,int&gt; ExprGenerator::visit_index_tmp(const Dim&amp; dim, const P_ExprNode&amp; idx, bool matlab_style) {
374 	int i1,i2;
375 	switch(idx.op) {
376 	case P_ExprNode::IDX_ALL :
377 		assert(idx.arg.size()==0);
378 		i1=i2=-1;
379 		break;
380 	case P_ExprNode::IDX_RANGE :
381 		assert(idx.arg.size()==2);
382 		visit(idx.arg[0]);
383 		visit(idx.arg[1]);
384 		assert(idx.arg[0].lab-&gt;is_const());
385 		assert(idx.arg[1].lab-&gt;is_const());
386 		i1=to_integer(idx.arg[0].lab-&gt;domain());
387 		i2=to_integer(idx.arg[1].lab-&gt;domain());
388 		if (matlab_style) { i1--; i2--; }
389 		if (i1&lt;0 || i2&lt;0)
390 			throw SyntaxError("negative index. Note: indices in Matlab-style (using parenthesis like in \"x(i)\") start from 1 (not 0).");
391 		break;
392 	case P_ExprNode::IDX :
393 		assert(idx.arg.size()==1);
394 		visit(idx.arg[0]);
395 		assert(idx.arg[0].lab-&gt;is_const());
396 		i1=i2=to_integer(idx.arg[0].lab-&gt;domain());
397 		if (matlab_style) { i1--; i2--; }
398 		if (i1&lt;0)
399 			throw SyntaxError("negative index. Note: indices in Matlab-style (using parenthesis like in \"x(i)\") start from 1 (not 0).");
400 		break;
401 	default:
402 		assert(false);
403 	}
404 	idx.lab = new LabelConst(0); 
405 	return pair&lt;int,int&gt;(i1,i2);
406 }
407 DoubleIndex ExprGenerator::visit_index(const Dim&amp; dim, const P_ExprNode&amp; idx1, bool matlab_style) {
408 	pair&lt;int,int&gt; p=visit_index_tmp(dim,idx1,matlab_style);
409 	if (p.first==-1) {
410 		return DoubleIndex::all(dim);
411 	} else if (p.second==p.first) {
412 		return DoubleIndex::one_index(dim,p.first);
413 	} else {
414 		if (dim.nb_rows()&gt;1)
415 			return DoubleIndex::rows(dim,p.first,p.second);
416 		else
417 			return DoubleIndex::cols(dim,p.first,p.second);
418 	}
419 }
420 DoubleIndex ExprGenerator::visit_index(const Dim&amp; dim, const P_ExprNode&amp; idx1, const P_ExprNode&amp; idx2, bool matlab_style) {
421 	pair&lt;int,int&gt; r=visit_index_tmp(dim,idx1,matlab_style);
422 	pair&lt;int,int&gt; c=visit_index_tmp(dim,idx2,matlab_style);
423 	if (r.first==-1) {
424 		if (c.first==-1)
425 			return DoubleIndex::all(dim);
426 		else if (c.first==c.second)
427 			return DoubleIndex::one_col(dim,c.first);
428 		else
429 			return DoubleIndex::cols(dim,c.first,c.second);
430 	} else if (r.first==r.second) {
431 		if (c.first==-1)
432 			return DoubleIndex::one_row(dim,r.first);
433 		else if (c.first==c.second)
434 			return DoubleIndex::one_elt(dim,r.first,c.first);
435 		else
436 			return DoubleIndex::subrow(dim,r.first,c.first,c.second);
437 	} else {
438 		if (c.first==-1)
439 			return DoubleIndex::rows(dim,r.first,r.second);
440 		else if (c.first==c.second)
441 			return DoubleIndex::subcol(dim,r.first,r.second,c.first);
442 		else
443 			return DoubleIndex::submatrix(dim,r.first,r.second,c.first,c.second);
444 	}
445 }
446 void ExprGenerator::visit(const P_ExprWithIndex&amp; e) {
447 	visit(e.arg[0]);
448 	Label&amp; expr=(*(e.arg[0].lab));
449 	DoubleIndex idx=e.arg.size()==2?
450 			visit_index(expr.dim(), e.arg[1], e.matlab_style)
451 			:
452 			visit_index(expr.dim(), e.arg[1], e.arg[2], e.matlab_style);
453 	if (expr.is_const()) {
454 		Domain d=expr.domain()[idx];
455 		e.lab = new LabelConst(d,d.is_reference);
456 	} else {
457 		e.lab = new LabelNode(&amp;ExprIndex::new_(expr.node(),idx));
458 	}
459 }
460 const ExprNode&amp; ExprGenerator::diff(const Array&lt;const ExprNode&gt;&amp; args) {
461 	assert(args.size()&gt;1);
462 	const ExprNode&amp; y=args[0];
463 	Array&lt;const ExprSymbol&gt; x(args.size()-1);
464 	for (int i=0; i&lt;args.size()-1; i++) {
465 		const ExprSymbol* xi=dynamic_cast&lt;const ExprSymbol*&gt;(&amp;args[i+1]);
466 		if (!xi) {
467 			throw SyntaxError("\"diff\" can only be applied to symbols");
468 		}
469 		x.set_ref(i,*xi);
470 	}
471 	ExprDiff d;
472 	std::vector&lt;const ExprNode*&gt; tmp_expr=scope.get_all_existing_nodes();
473 	ExprSubNodes tmp_expr_nodes(tmp_expr);
474 	for (int i=0; i&lt;tmp_expr_nodes.size(); i++)
475 		d.lock.insert(tmp_expr_nodes[i],true);
476 	return d.diff(y,x);
477 }
} } </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
