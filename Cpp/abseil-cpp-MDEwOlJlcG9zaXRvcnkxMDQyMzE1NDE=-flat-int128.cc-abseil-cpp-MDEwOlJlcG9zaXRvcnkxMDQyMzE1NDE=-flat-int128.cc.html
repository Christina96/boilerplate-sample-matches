
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 33, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-int128.cc</h3>
            <pre><code>1  #include "absl/numeric/int128.h"
2  #include <stddef.h>
3  #include <cassert>
4  #include <iomanip>
5  #include <ostream>  
6  #include <sstream>
7  #include <string>
8  #include <type_traits>
9  #include "absl/base/optimization.h"
10  #include "absl/numeric/bits.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  ABSL_DLL const uint128 kuint128max = MakeUint128(
14      std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max());
15  namespace {
16  inline ABSL_ATTRIBUTE_ALWAYS_INLINE int Fls128(uint128 n) {
17    if (uint64_t hi = Uint128High64(n)) {
18      ABSL_ASSUME(hi != 0);
19      return 127 - countl_zero(hi);
20    }
21    const uint64_t low = Uint128Low64(n);
22    ABSL_ASSUME(low != 0);
23    return 63 - countl_zero(low);
24  }
25  inline void DivModImpl(uint128 dividend, uint128 divisor, uint128* quotient_ret,
26                         uint128* remainder_ret) {
27    assert(divisor != 0);
28    if (divisor > dividend) {
29      *quotient_ret = 0;
30      *remainder_ret = dividend;
31      return;
32    }
33    if (divisor == dividend) {
34      *quotient_ret = 1;
35      *remainder_ret = 0;
36      return;
37    }
38    uint128 denominator = divisor;
39    uint128 quotient = 0;
40    const int shift = Fls128(dividend) - Fls128(denominator);
41    denominator <<= shift;
42    for (int i = 0; i <= shift; ++i) {
43      quotient <<= 1;
44      if (dividend >= denominator) {
45        dividend -= denominator;
46        quotient |= 1;
47      }
48      denominator >>= 1;
49    }
50    *quotient_ret = quotient;
51    *remainder_ret = dividend;
52  }
53  template <typename T>
54  uint128 MakeUint128FromFloat(T v) {
55    static_assert(std::is_floating_point<T>::value, "");
56    assert(std::isfinite(v) && v > -1 &&
57           (std::numeric_limits<T>::max_exponent <= 128 ||
58            v < std::ldexp(static_cast<T>(1), 128)));
59    if (v >= std::ldexp(static_cast<T>(1), 64)) {
60      uint64_t hi = static_cast<uint64_t>(std::ldexp(v, -64));
61      uint64_t lo = static_cast<uint64_t>(v - std::ldexp(static_cast<T>(hi), 64));
62      return MakeUint128(hi, lo);
63    }
64    return MakeUint128(0, static_cast<uint64_t>(v));
65  }
66  #if defined(__clang__) && (__clang_major__ < 9) && !defined(__SSE3__)
67  uint128 MakeUint128FromFloat(long double v) {
68    static_assert(std::numeric_limits<double>::digits >= 50, "");
69    static_assert(std::numeric_limits<long double>::digits <= 150, "");
70    assert(std::isfinite(v) && v > -1 && v < std::ldexp(1.0L, 128));
71    v = std::ldexp(v, -100);
72    uint64_t w0 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
73    v = std::ldexp(v - static_cast<double>(w0), 50);
74    uint64_t w1 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
75    v = std::ldexp(v - static_cast<double>(w1), 50);
76    uint64_t w2 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
77    return (static_cast<uint128>(w0) << 100) | (static_cast<uint128>(w1) << 50) |
78           static_cast<uint128>(w2);
79  }
80  #endif  
81  }  
82  uint128::uint128(float v) : uint128(MakeUint128FromFloat(v)) {}
83  uint128::uint128(double v) : uint128(MakeUint128FromFloat(v)) {}
84  uint128::uint128(long double v) : uint128(MakeUint128FromFloat(v)) {}
85  #if !defined(ABSL_HAVE_INTRINSIC_INT128)
86  uint128 operator/(uint128 lhs, uint128 rhs) {
87    uint128 quotient = 0;
88    uint128 remainder = 0;
89    DivModImpl(lhs, rhs, &quotient, &remainder);
90    return quotient;
91  }
92  uint128 operator%(uint128 lhs, uint128 rhs) {
93    uint128 quotient = 0;
94    uint128 remainder = 0;
95    DivModImpl(lhs, rhs, &quotient, &remainder);
96    return remainder;
97  }
98  #endif  
99  namespace {
100  std::string Uint128ToFormattedString(uint128 v, std::ios_base::fmtflags flags) {
101    uint128 div;
102    int div_base_log;
103    switch (flags & std::ios::basefield) {
104      case std::ios::hex:
105        div = 0x1000000000000000;  
106        div_base_log = 15;
107        break;
108      case std::ios::oct:
109        div = 01000000000000000000000;  
110        div_base_log = 21;
111        break;
112      default:  
113        div = 10000000000000000000u;  
114        div_base_log = 19;
115        break;
116    }
117    std::ostringstream os;
118    std::ios_base::fmtflags copy_mask =
119        std::ios::basefield | std::ios::showbase | std::ios::uppercase;
120    os.setf(flags & copy_mask, copy_mask);
121    uint128 high = v;
122    uint128 low;
123    DivModImpl(high, div, &high, &low);
124    uint128 mid;
125    DivModImpl(high, div, &high, &mid);
126    if (Uint128Low64(high) != 0) {
127      os << Uint128Low64(high);
128      os << std::noshowbase << std::setfill('0') << std::setw(div_base_log);
129      os << Uint128Low64(mid);
130      os << std::setw(div_base_log);
131    } else if (Uint128Low64(mid) != 0) {
132      os << Uint128Low64(mid);
133      os << std::noshowbase << std::setfill('0') << std::setw(div_base_log);
134    }
135    os << Uint128Low64(low);
136    return os.str();
137  }
138  }  
139  std::string uint128::ToString() const {
140    return Uint128ToFormattedString(*this, std::ios_base::dec);
141  }
142  std::ostream& operator<<(std::ostream& os, uint128 v) {
143    std::ios_base::fmtflags flags = os.flags();
144    std::string rep = Uint128ToFormattedString(v, flags);
145    std::streamsize width = os.width(0);
146    if (static_cast<size_t>(width) > rep.size()) {
147      const size_t count = static_cast<size_t>(width) - rep.size();
148      std::ios::fmtflags adjustfield = flags & std::ios::adjustfield;
149      if (adjustfield == std::ios::left) {
150        rep.append(count, os.fill());
151      } else if (adjustfield == std::ios::internal &&
152                 (flags & std::ios::showbase) &&
153                 (flags & std::ios::basefield) == std::ios::hex && v != 0) {
154        rep.insert(size_t{2}, count, os.fill());
155      } else {
156        rep.insert(size_t{0}, count, os.fill());
157      }
158    }
159    return os << rep;
160  }
161  namespace {
162  uint128 UnsignedAbsoluteValue(int128 v) {
163    return Int128High64(v) < 0 ? -uint128(v) : uint128(v);
164  }
165  }  
166  #if !defined(ABSL_HAVE_INTRINSIC_INT128)
167  namespace {
168  template <typename T>
169  int128 MakeInt128FromFloat(T v) {
170    assert(std::isfinite(v) && (std::numeric_limits<T>::max_exponent <= 127 ||
171                                (v >= -std::ldexp(static_cast<T>(1), 127) &&
172                                 v < std::ldexp(static_cast<T>(1), 127))));
173    uint128 result = v < 0 ? -MakeUint128FromFloat(-v) : MakeUint128FromFloat(v);
174    return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(result)),
175                      Uint128Low64(result));
176  }
177  }  
178  int128::int128(float v) : int128(MakeInt128FromFloat(v)) {}
179  int128::int128(double v) : int128(MakeInt128FromFloat(v)) {}
180  int128::int128(long double v) : int128(MakeInt128FromFloat(v)) {}
181  int128 operator/(int128 lhs, int128 rhs) {
182    assert(lhs != Int128Min() || rhs != -1);  
183    uint128 quotient = 0;
184    uint128 remainder = 0;
185    DivModImpl(UnsignedAbsoluteValue(lhs), UnsignedAbsoluteValue(rhs),
186               &quotient, &remainder);
187    if ((Int128High64(lhs) < 0) != (Int128High64(rhs) < 0)) quotient = -quotient;
188    return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(quotient)),
189                      Uint128Low64(quotient));
190  }
191  int128 operator%(int128 lhs, int128 rhs) {
192    assert(lhs != Int128Min() || rhs != -1);  
193    uint128 quotient = 0;
194    uint128 remainder = 0;
195    DivModImpl(UnsignedAbsoluteValue(lhs), UnsignedAbsoluteValue(rhs),
196               &quotient, &remainder);
197    if (Int128High64(lhs) < 0) remainder = -remainder;
198    return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(remainder)),
199                      Uint128Low64(remainder));
200  }
201  #endif  
202  std::string int128::ToString() const {
203    std::string rep;
204    if (Int128High64(*this) < 0) rep = "-";
205    rep.append(Uint128ToFormattedString(UnsignedAbsoluteValue(*this),
206                                        std::ios_base::dec));
207    return rep;
208  }
209  std::ostream& operator<<(std::ostream& os, int128 v) {
210    std::ios_base::fmtflags flags = os.flags();
211    std::string rep;
212    bool print_as_decimal =
213        (flags & std::ios::basefield) == std::ios::dec ||
214        (flags & std::ios::basefield) == std::ios_base::fmtflags();
215    if (print_as_decimal) {
216      if (Int128High64(v) < 0) {
217        rep = "-";
218      } else if (flags & std::ios::showpos) {
219        rep = "+";
220      }
221    }
222    rep.append(Uint128ToFormattedString(
223        print_as_decimal ? UnsignedAbsoluteValue(v) : uint128(v), os.flags()));
224    std::streamsize width = os.width(0);
225    if (static_cast<size_t>(width) > rep.size()) {
226      const size_t count = static_cast<size_t>(width) - rep.size();
227      switch (flags & std::ios::adjustfield) {
228        case std::ios::left:
229          rep.append(count, os.fill());
230          break;
231        case std::ios::internal:
232          if (print_as_decimal && (rep[0] == '+' || rep[0] == '-')) {
233            rep.insert(size_t{1}, count, os.fill());
234          } else if ((flags & std::ios::basefield) == std::ios::hex &&
235                     (flags & std::ios::showbase) && v != 0) {
236            rep.insert(size_t{2}, count, os.fill());
237          } else {
238            rep.insert(size_t{0}, count, os.fill());
239          }
240          break;
241        default:  
242          rep.insert(size_t{0}, count, os.fill());
243          break;
244      }
245    }
246    return os << rep;
247  }
248  ABSL_NAMESPACE_END
249  }  
250  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
251  namespace std {
252  constexpr bool numeric_limits<absl::uint128>::is_specialized;
253  constexpr bool numeric_limits<absl::uint128>::is_signed;
254  constexpr bool numeric_limits<absl::uint128>::is_integer;
255  constexpr bool numeric_limits<absl::uint128>::is_exact;
256  constexpr bool numeric_limits<absl::uint128>::has_infinity;
257  constexpr bool numeric_limits<absl::uint128>::has_quiet_NaN;
258  constexpr bool numeric_limits<absl::uint128>::has_signaling_NaN;
259  constexpr float_denorm_style numeric_limits<absl::uint128>::has_denorm;
260  constexpr bool numeric_limits<absl::uint128>::has_denorm_loss;
261  constexpr float_round_style numeric_limits<absl::uint128>::round_style;
262  constexpr bool numeric_limits<absl::uint128>::is_iec559;
263  constexpr bool numeric_limits<absl::uint128>::is_bounded;
264  constexpr bool numeric_limits<absl::uint128>::is_modulo;
265  constexpr int numeric_limits<absl::uint128>::digits;
266  constexpr int numeric_limits<absl::uint128>::digits10;
267  constexpr int numeric_limits<absl::uint128>::max_digits10;
268  constexpr int numeric_limits<absl::uint128>::radix;
269  constexpr int numeric_limits<absl::uint128>::min_exponent;
270  constexpr int numeric_limits<absl::uint128>::min_exponent10;
271  constexpr int numeric_limits<absl::uint128>::max_exponent;
272  constexpr int numeric_limits<absl::uint128>::max_exponent10;
273  constexpr bool numeric_limits<absl::uint128>::traps;
274  constexpr bool numeric_limits<absl::uint128>::tinyness_before;
275  constexpr bool numeric_limits<absl::int128>::is_specialized;
276  constexpr bool numeric_limits<absl::int128>::is_signed;
277  constexpr bool numeric_limits<absl::int128>::is_integer;
278  constexpr bool numeric_limits<absl::int128>::is_exact;
279  constexpr bool numeric_limits<absl::int128>::has_infinity;
280  constexpr bool numeric_limits<absl::int128>::has_quiet_NaN;
281  constexpr bool numeric_limits<absl::int128>::has_signaling_NaN;
282  constexpr float_denorm_style numeric_limits<absl::int128>::has_denorm;
283  constexpr bool numeric_limits<absl::int128>::has_denorm_loss;
284  constexpr float_round_style numeric_limits<absl::int128>::round_style;
285  constexpr bool numeric_limits<absl::int128>::is_iec559;
286  constexpr bool numeric_limits<absl::int128>::is_bounded;
287  constexpr bool numeric_limits<absl::int128>::is_modulo;
288  constexpr int numeric_limits<absl::int128>::digits;
289  constexpr int numeric_limits<absl::int128>::digits10;
290  constexpr int numeric_limits<absl::int128>::max_digits10;
291  constexpr int numeric_limits<absl::int128>::radix;
292  constexpr int numeric_limits<absl::int128>::min_exponent;
293  constexpr int numeric_limits<absl::int128>::min_exponent10;
294  constexpr int numeric_limits<absl::int128>::max_exponent;
<span onclick='openModal()' class='match'>295  constexpr int numeric_limits<absl::int128>::max_exponent10;
296  constexpr bool numeric_limits<absl::int128>::traps;
297  constexpr bool numeric_limits<absl::int128>::tinyness_before;
298  }  
</span>299  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-int128.cc</h3>
            <pre><code>1  #include "absl/numeric/int128.h"
2  #include <stddef.h>
3  #include <cassert>
4  #include <iomanip>
5  #include <ostream>  
6  #include <sstream>
7  #include <string>
8  #include <type_traits>
9  #include "absl/base/optimization.h"
10  #include "absl/numeric/bits.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  ABSL_DLL const uint128 kuint128max = MakeUint128(
14      std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max());
15  namespace {
16  inline ABSL_ATTRIBUTE_ALWAYS_INLINE int Fls128(uint128 n) {
17    if (uint64_t hi = Uint128High64(n)) {
18      ABSL_ASSUME(hi != 0);
19      return 127 - countl_zero(hi);
20    }
21    const uint64_t low = Uint128Low64(n);
22    ABSL_ASSUME(low != 0);
23    return 63 - countl_zero(low);
24  }
25  inline void DivModImpl(uint128 dividend, uint128 divisor, uint128* quotient_ret,
26                         uint128* remainder_ret) {
27    assert(divisor != 0);
28    if (divisor > dividend) {
29      *quotient_ret = 0;
30      *remainder_ret = dividend;
31      return;
32    }
33    if (divisor == dividend) {
34      *quotient_ret = 1;
35      *remainder_ret = 0;
36      return;
37    }
38    uint128 denominator = divisor;
39    uint128 quotient = 0;
40    const int shift = Fls128(dividend) - Fls128(denominator);
41    denominator <<= shift;
42    for (int i = 0; i <= shift; ++i) {
43      quotient <<= 1;
44      if (dividend >= denominator) {
45        dividend -= denominator;
46        quotient |= 1;
47      }
48      denominator >>= 1;
49    }
50    *quotient_ret = quotient;
51    *remainder_ret = dividend;
52  }
53  template <typename T>
54  uint128 MakeUint128FromFloat(T v) {
55    static_assert(std::is_floating_point<T>::value, "");
56    assert(std::isfinite(v) && v > -1 &&
57           (std::numeric_limits<T>::max_exponent <= 128 ||
58            v < std::ldexp(static_cast<T>(1), 128)));
59    if (v >= std::ldexp(static_cast<T>(1), 64)) {
60      uint64_t hi = static_cast<uint64_t>(std::ldexp(v, -64));
61      uint64_t lo = static_cast<uint64_t>(v - std::ldexp(static_cast<T>(hi), 64));
62      return MakeUint128(hi, lo);
63    }
64    return MakeUint128(0, static_cast<uint64_t>(v));
65  }
66  #if defined(__clang__) && (__clang_major__ < 9) && !defined(__SSE3__)
67  uint128 MakeUint128FromFloat(long double v) {
68    static_assert(std::numeric_limits<double>::digits >= 50, "");
69    static_assert(std::numeric_limits<long double>::digits <= 150, "");
70    assert(std::isfinite(v) && v > -1 && v < std::ldexp(1.0L, 128));
71    v = std::ldexp(v, -100);
72    uint64_t w0 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
73    v = std::ldexp(v - static_cast<double>(w0), 50);
74    uint64_t w1 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
75    v = std::ldexp(v - static_cast<double>(w1), 50);
76    uint64_t w2 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
77    return (static_cast<uint128>(w0) << 100) | (static_cast<uint128>(w1) << 50) |
78           static_cast<uint128>(w2);
79  }
80  #endif  
81  }  
82  uint128::uint128(float v) : uint128(MakeUint128FromFloat(v)) {}
83  uint128::uint128(double v) : uint128(MakeUint128FromFloat(v)) {}
84  uint128::uint128(long double v) : uint128(MakeUint128FromFloat(v)) {}
85  #if !defined(ABSL_HAVE_INTRINSIC_INT128)
86  uint128 operator/(uint128 lhs, uint128 rhs) {
87    uint128 quotient = 0;
88    uint128 remainder = 0;
89    DivModImpl(lhs, rhs, &quotient, &remainder);
90    return quotient;
91  }
92  uint128 operator%(uint128 lhs, uint128 rhs) {
93    uint128 quotient = 0;
94    uint128 remainder = 0;
95    DivModImpl(lhs, rhs, &quotient, &remainder);
96    return remainder;
97  }
98  #endif  
99  namespace {
100  std::string Uint128ToFormattedString(uint128 v, std::ios_base::fmtflags flags) {
101    uint128 div;
102    int div_base_log;
103    switch (flags & std::ios::basefield) {
104      case std::ios::hex:
105        div = 0x1000000000000000;  
106        div_base_log = 15;
107        break;
108      case std::ios::oct:
109        div = 01000000000000000000000;  
110        div_base_log = 21;
111        break;
112      default:  
113        div = 10000000000000000000u;  
114        div_base_log = 19;
115        break;
116    }
117    std::ostringstream os;
118    std::ios_base::fmtflags copy_mask =
119        std::ios::basefield | std::ios::showbase | std::ios::uppercase;
120    os.setf(flags & copy_mask, copy_mask);
121    uint128 high = v;
122    uint128 low;
123    DivModImpl(high, div, &high, &low);
124    uint128 mid;
125    DivModImpl(high, div, &high, &mid);
126    if (Uint128Low64(high) != 0) {
127      os << Uint128Low64(high);
128      os << std::noshowbase << std::setfill('0') << std::setw(div_base_log);
129      os << Uint128Low64(mid);
130      os << std::setw(div_base_log);
131    } else if (Uint128Low64(mid) != 0) {
132      os << Uint128Low64(mid);
133      os << std::noshowbase << std::setfill('0') << std::setw(div_base_log);
134    }
135    os << Uint128Low64(low);
136    return os.str();
137  }
138  }  
139  std::string uint128::ToString() const {
140    return Uint128ToFormattedString(*this, std::ios_base::dec);
141  }
142  std::ostream& operator<<(std::ostream& os, uint128 v) {
143    std::ios_base::fmtflags flags = os.flags();
144    std::string rep = Uint128ToFormattedString(v, flags);
145    std::streamsize width = os.width(0);
146    if (static_cast<size_t>(width) > rep.size()) {
147      const size_t count = static_cast<size_t>(width) - rep.size();
148      std::ios::fmtflags adjustfield = flags & std::ios::adjustfield;
149      if (adjustfield == std::ios::left) {
150        rep.append(count, os.fill());
151      } else if (adjustfield == std::ios::internal &&
152                 (flags & std::ios::showbase) &&
153                 (flags & std::ios::basefield) == std::ios::hex && v != 0) {
154        rep.insert(size_t{2}, count, os.fill());
155      } else {
156        rep.insert(size_t{0}, count, os.fill());
157      }
158    }
159    return os << rep;
160  }
161  namespace {
162  uint128 UnsignedAbsoluteValue(int128 v) {
163    return Int128High64(v) < 0 ? -uint128(v) : uint128(v);
164  }
165  }  
166  #if !defined(ABSL_HAVE_INTRINSIC_INT128)
167  namespace {
168  template <typename T>
169  int128 MakeInt128FromFloat(T v) {
170    assert(std::isfinite(v) && (std::numeric_limits<T>::max_exponent <= 127 ||
171                                (v >= -std::ldexp(static_cast<T>(1), 127) &&
172                                 v < std::ldexp(static_cast<T>(1), 127))));
173    uint128 result = v < 0 ? -MakeUint128FromFloat(-v) : MakeUint128FromFloat(v);
174    return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(result)),
175                      Uint128Low64(result));
176  }
177  }  
178  int128::int128(float v) : int128(MakeInt128FromFloat(v)) {}
179  int128::int128(double v) : int128(MakeInt128FromFloat(v)) {}
180  int128::int128(long double v) : int128(MakeInt128FromFloat(v)) {}
181  int128 operator/(int128 lhs, int128 rhs) {
182    assert(lhs != Int128Min() || rhs != -1);  
183    uint128 quotient = 0;
184    uint128 remainder = 0;
185    DivModImpl(UnsignedAbsoluteValue(lhs), UnsignedAbsoluteValue(rhs),
186               &quotient, &remainder);
187    if ((Int128High64(lhs) < 0) != (Int128High64(rhs) < 0)) quotient = -quotient;
188    return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(quotient)),
189                      Uint128Low64(quotient));
190  }
191  int128 operator%(int128 lhs, int128 rhs) {
192    assert(lhs != Int128Min() || rhs != -1);  
193    uint128 quotient = 0;
194    uint128 remainder = 0;
195    DivModImpl(UnsignedAbsoluteValue(lhs), UnsignedAbsoluteValue(rhs),
196               &quotient, &remainder);
197    if (Int128High64(lhs) < 0) remainder = -remainder;
198    return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(remainder)),
199                      Uint128Low64(remainder));
200  }
201  #endif  
202  std::string int128::ToString() const {
203    std::string rep;
204    if (Int128High64(*this) < 0) rep = "-";
205    rep.append(Uint128ToFormattedString(UnsignedAbsoluteValue(*this),
206                                        std::ios_base::dec));
207    return rep;
208  }
209  std::ostream& operator<<(std::ostream& os, int128 v) {
210    std::ios_base::fmtflags flags = os.flags();
211    std::string rep;
212    bool print_as_decimal =
213        (flags & std::ios::basefield) == std::ios::dec ||
214        (flags & std::ios::basefield) == std::ios_base::fmtflags();
215    if (print_as_decimal) {
216      if (Int128High64(v) < 0) {
217        rep = "-";
218      } else if (flags & std::ios::showpos) {
219        rep = "+";
220      }
221    }
222    rep.append(Uint128ToFormattedString(
223        print_as_decimal ? UnsignedAbsoluteValue(v) : uint128(v), os.flags()));
224    std::streamsize width = os.width(0);
225    if (static_cast<size_t>(width) > rep.size()) {
226      const size_t count = static_cast<size_t>(width) - rep.size();
227      switch (flags & std::ios::adjustfield) {
228        case std::ios::left:
229          rep.append(count, os.fill());
230          break;
231        case std::ios::internal:
232          if (print_as_decimal && (rep[0] == '+' || rep[0] == '-')) {
233            rep.insert(size_t{1}, count, os.fill());
234          } else if ((flags & std::ios::basefield) == std::ios::hex &&
235                     (flags & std::ios::showbase) && v != 0) {
236            rep.insert(size_t{2}, count, os.fill());
237          } else {
238            rep.insert(size_t{0}, count, os.fill());
239          }
240          break;
241        default:  
242          rep.insert(size_t{0}, count, os.fill());
243          break;
244      }
245    }
246    return os << rep;
247  }
248  ABSL_NAMESPACE_END
249  }  
250  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
251  namespace std {
252  constexpr bool numeric_limits<absl::uint128>::is_specialized;
253  constexpr bool numeric_limits<absl::uint128>::is_signed;
254  constexpr bool numeric_limits<absl::uint128>::is_integer;
255  constexpr bool numeric_limits<absl::uint128>::is_exact;
256  constexpr bool numeric_limits<absl::uint128>::has_infinity;
257  constexpr bool numeric_limits<absl::uint128>::has_quiet_NaN;
258  constexpr bool numeric_limits<absl::uint128>::has_signaling_NaN;
259  constexpr float_denorm_style numeric_limits<absl::uint128>::has_denorm;
260  constexpr bool numeric_limits<absl::uint128>::has_denorm_loss;
261  constexpr float_round_style numeric_limits<absl::uint128>::round_style;
262  constexpr bool numeric_limits<absl::uint128>::is_iec559;
263  constexpr bool numeric_limits<absl::uint128>::is_bounded;
264  constexpr bool numeric_limits<absl::uint128>::is_modulo;
265  constexpr int numeric_limits<absl::uint128>::digits;
266  constexpr int numeric_limits<absl::uint128>::digits10;
267  constexpr int numeric_limits<absl::uint128>::max_digits10;
268  constexpr int numeric_limits<absl::uint128>::radix;
269  constexpr int numeric_limits<absl::uint128>::min_exponent;
270  constexpr int numeric_limits<absl::uint128>::min_exponent10;
271  constexpr int numeric_limits<absl::uint128>::max_exponent;
272  constexpr int numeric_limits<absl::uint128>::max_exponent10;
273  constexpr bool numeric_limits<absl::uint128>::traps;
274  constexpr bool numeric_limits<absl::uint128>::tinyness_before;
275  constexpr bool numeric_limits<absl::int128>::is_specialized;
276  constexpr bool numeric_limits<absl::int128>::is_signed;
277  constexpr bool numeric_limits<absl::int128>::is_integer;
278  constexpr bool numeric_limits<absl::int128>::is_exact;
279  constexpr bool numeric_limits<absl::int128>::has_infinity;
280  constexpr bool numeric_limits<absl::int128>::has_quiet_NaN;
281  constexpr bool numeric_limits<absl::int128>::has_signaling_NaN;
282  constexpr float_denorm_style numeric_limits<absl::int128>::has_denorm;
283  constexpr bool numeric_limits<absl::int128>::has_denorm_loss;
284  constexpr float_round_style numeric_limits<absl::int128>::round_style;
285  constexpr bool numeric_limits<absl::int128>::is_iec559;
286  constexpr bool numeric_limits<absl::int128>::is_bounded;
287  constexpr bool numeric_limits<absl::int128>::is_modulo;
288  constexpr int numeric_limits<absl::int128>::digits;
289  constexpr int numeric_limits<absl::int128>::digits10;
290  constexpr int numeric_limits<absl::int128>::max_digits10;
291  constexpr int numeric_limits<absl::int128>::radix;
292  constexpr int numeric_limits<absl::int128>::min_exponent;
293  constexpr int numeric_limits<absl::int128>::min_exponent10;
294  constexpr int numeric_limits<absl::int128>::max_exponent;
<span onclick='openModal()' class='match'>295  constexpr int numeric_limits<absl::int128>::max_exponent10;
296  constexpr bool numeric_limits<absl::int128>::traps;
297  constexpr bool numeric_limits<absl::int128>::tinyness_before;
298  }  
</span>299  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-int128.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-int128.cc</div>
                </div>
                <div class="column column_space"><pre><code>295  constexpr int numeric_limits<absl::int128>::max_exponent10;
296  constexpr bool numeric_limits<absl::int128>::traps;
297  constexpr bool numeric_limits<absl::int128>::tinyness_before;
298  }  
</pre></code></div>
                <div class="column column_space"><pre><code>295  constexpr int numeric_limits<absl::int128>::max_exponent10;
296  constexpr bool numeric_limits<absl::int128>::traps;
297  constexpr bool numeric_limits<absl::int128>::tinyness_before;
298  }  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    