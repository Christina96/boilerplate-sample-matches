
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-scoped_mock_log_test.cc</h3>
            <pre><code>1  #include "absl/log/scoped_mock_log.h"
2  #include <memory>
3  #include <thread>  
4  #include "gmock/gmock.h"
5  #include "gtest/gtest-spi.h"
6  #include "gtest/gtest.h"
7  #include "absl/base/attributes.h"
8  #include "absl/base/log_severity.h"
9  #include "absl/log/globals.h"
10  #include "absl/log/internal/test_helpers.h"
11  #include "absl/log/internal/test_matchers.h"
12  #include "absl/log/log.h"
13  #include "absl/memory/memory.h"
14  #include "absl/strings/match.h"
15  #include "absl/strings/string_view.h"
16  #include "absl/synchronization/barrier.h"
17  #include "absl/synchronization/notification.h"
18  namespace {
19  using ::testing::_;
20  using ::testing::AnyNumber;
21  using ::testing::Eq;
22  using ::testing::HasSubstr;
23  using ::testing::InSequence;
24  using ::testing::Lt;
25  using ::testing::Truly;
26  using absl::log_internal::SourceBasename;
27  using absl::log_internal::SourceFilename;
28  using absl::log_internal::SourceLine;
29  using absl::log_internal::TextMessageWithPrefix;
30  using absl::log_internal::ThreadID;
31  auto* test_env ABSL_ATTRIBUTE_UNUSED = ::testing::AddGlobalTestEnvironment(
32      new absl::log_internal::LogTestEnvironment);
33  #if GTEST_HAS_DEATH_TEST
34  TEST(ScopedMockLogDeathTest,
35       StartCapturingLogsCannotBeCalledWhenAlreadyCapturing) {
36    EXPECT_DEATH(
37        {
38          absl::ScopedMockLog log;
39          log.StartCapturingLogs();
40          log.StartCapturingLogs();
41        },
42        "StartCapturingLogs");
43  }
44  TEST(ScopedMockLogDeathTest, StopCapturingLogsCannotBeCalledWhenNotCapturing) {
45    EXPECT_DEATH(
46        {
47          absl::ScopedMockLog log;
48          log.StopCapturingLogs();
49        },
50        "StopCapturingLogs");
51  }
52  TEST(ScopedMockLogDeathTest, FailsCheckIfStartCapturingLogsIsNeverCalled) {
53    EXPECT_DEATH({ absl::ScopedMockLog log; },
54                 "Did you forget to call StartCapturingLogs");
55  }
56  #endif
57  TEST(ScopedMockLogTest, LogMockCatchAndMatchStrictExpectations) {
58    absl::ScopedMockLog log;
59    InSequence s;
60    EXPECT_CALL(log,
61                Log(absl::LogSeverity::kWarning, HasSubstr(__FILE__), "Danger."));
62    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, "Working...")).Times(2);
63    EXPECT_CALL(log, Log(absl::LogSeverity::kError, _, "Bad!!"));
64    log.StartCapturingLogs();
65    LOG(WARNING) << "Danger.";
66    LOG(INFO) << "Working...";
67    LOG(INFO) << "Working...";
68    LOG(ERROR) << "Bad!!";
69  }
70  TEST(ScopedMockLogTest, LogMockCatchAndMatchSendExpectations) {
71    absl::ScopedMockLog log;
72    EXPECT_CALL(
73        log,
74        Send(AllOf(SourceFilename(Eq("/my/very/very/very_long_source_file.cc")),
75                   SourceBasename(Eq("very_long_source_file.cc")),
76                   SourceLine(Eq(777)), ThreadID(Eq(absl::LogEntry::tid_t{1234})),
77                   TextMessageWithPrefix(Truly([](absl::string_view msg) {
78                     return absl::EndsWith(
79                         msg, " very_long_source_file.cc:777] Info message");
80                   })))));
81    log.StartCapturingLogs();
82    LOG(INFO)
83            .AtLocation("/my/very/very/very_long_source_file.cc", 777)
84            .WithThreadID(1234)
85        << "Info message";
86  }
87  TEST(ScopedMockLogTest, ScopedMockLogCanBeNice) {
88    absl::ScopedMockLog log;
89    InSequence s;
90    EXPECT_CALL(log,
91                Log(absl::LogSeverity::kWarning, HasSubstr(__FILE__), "Danger."));
92    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, "Working...")).Times(2);
93    EXPECT_CALL(log, Log(absl::LogSeverity::kError, _, "Bad!!"));
94    log.StartCapturingLogs();
95    LOG(INFO) << "Info message.";
96    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
97    LOG(WARNING) << "Danger.";
98    LOG(INFO) << "Info message.";
99    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
100    LOG(INFO) << "Working...";
101    LOG(INFO) << "Info message.";
102    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
103    LOG(INFO) << "Working...";
104    LOG(INFO) << "Info message.";
105    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
106    LOG(ERROR) << "Bad!!";
107    LOG(INFO) << "Info message.";
108    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
109  }
110  TEST(ScopedMockLogTest, RejectsUnexpectedLogs) {
111    EXPECT_NONFATAL_FAILURE(
112        {
113          absl::ScopedMockLog log(absl::MockLogDefault::kDisallowUnexpected);
114          EXPECT_CALL(log, Log(Lt(absl::LogSeverity::kError), _, _))
115              .Times(AnyNumber());
116          log.StartCapturingLogs();
117          LOG(INFO) << "Ignored";
118          LOG(WARNING) << "Ignored";
119          LOG(ERROR) << "Should not be ignored";
120        },
121        "Should not be ignored");
122  }
123  TEST(ScopedMockLogTest, CapturesLogsAfterStartCapturingLogs) {
124    absl::SetStderrThreshold(absl::LogSeverityAtLeast::kInfinity);
125    absl::ScopedMockLog log;
126    LOG(INFO) << "Ignored info";
127    LOG(WARNING) << "Ignored warning";
128    LOG(ERROR) << "Ignored error";
129    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, "Expected info"));
130    log.StartCapturingLogs();
131    LOG(INFO) << "Expected info";
132  }
133  TEST(ScopedMockLogTest, DoesNotCaptureLogsAfterStopCapturingLogs) {
134    absl::ScopedMockLog log;
135    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, "Expected info"));
136    log.StartCapturingLogs();
137    LOG(INFO) << "Expected info";
138    log.StopCapturingLogs();
139    LOG(INFO) << "Ignored info";
140    LOG(WARNING) << "Ignored warning";
141    LOG(ERROR) << "Ignored error";
142  }
143  TEST(ScopedMockLogTest, LogFromMultipleThreads) {
144    absl::ScopedMockLog log;
145    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, __FILE__, "Thread 1"));
146    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, __FILE__, "Thread 2"));
147    log.StartCapturingLogs();
148    absl::Barrier barrier(2);
149    std::thread thread1([&barrier]() {
150      barrier.Block();
151      LOG(INFO) << "Thread 1";
152    });
153    std::thread thread2([&barrier]() {
154      barrier.Block();
155      LOG(INFO) << "Thread 2";
<span onclick='openModal()' class='match'>156    });
157    thread1.join();
158    thread2.join();
159  }
</span>160  TEST(ScopedMockLogTest, NoSequenceWithMultipleThreads) {
161    absl::ScopedMockLog log;
162    absl::Barrier barrier(2);
163    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, _))
164        .Times(2)
165        .WillRepeatedly([&barrier]() { barrier.Block(); });
166    log.StartCapturingLogs();
167    std::thread thread1([]() { LOG(INFO) << "Thread 1"; });
168    std::thread thread2([]() { LOG(INFO) << "Thread 2"; });
169    thread1.join();
170    thread2.join();
171  }
172  TEST(ScopedMockLogTsanTest,
173       ScopedMockLogCanBeDeletedWhenAnotherThreadIsLogging) {
174    auto log = absl::make_unique<absl::ScopedMockLog>();
175    EXPECT_CALL(*log, Log(absl::LogSeverity::kInfo, __FILE__, "Thread log"))
176        .Times(AnyNumber());
177    log->StartCapturingLogs();
178    absl::Notification logging_started;
179    std::thread thread([&logging_started]() {
180      for (int i = 0; i < 100; ++i) {
181        if (i == 50) logging_started.Notify();
182        LOG(INFO) << "Thread log";
183      }
184    });
185    logging_started.WaitForNotification();
186    log.reset();
187    thread.join();
188  }
189  TEST(ScopedMockLogTest, AsLocalSink) {
190    absl::ScopedMockLog log(absl::MockLogDefault::kDisallowUnexpected);
191    EXPECT_CALL(log, Log(_, _, "two"));
192    EXPECT_CALL(log, Log(_, _, "three"));
193    LOG(INFO) << "one";
194    LOG(INFO).ToSinkOnly(&log.UseAsLocalSink()) << "two";
195    LOG(INFO).ToSinkAlso(&log.UseAsLocalSink()) << "three";
196  }
197  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-scoped_mock_log_test.cc</h3>
            <pre><code>1  #include "absl/log/scoped_mock_log.h"
2  #include <memory>
3  #include <thread>  
4  #include "gmock/gmock.h"
5  #include "gtest/gtest-spi.h"
6  #include "gtest/gtest.h"
7  #include "absl/base/attributes.h"
8  #include "absl/base/log_severity.h"
9  #include "absl/log/globals.h"
10  #include "absl/log/internal/test_helpers.h"
11  #include "absl/log/internal/test_matchers.h"
12  #include "absl/log/log.h"
13  #include "absl/memory/memory.h"
14  #include "absl/strings/match.h"
15  #include "absl/strings/string_view.h"
16  #include "absl/synchronization/barrier.h"
17  #include "absl/synchronization/notification.h"
18  namespace {
19  using ::testing::_;
20  using ::testing::AnyNumber;
21  using ::testing::Eq;
22  using ::testing::HasSubstr;
23  using ::testing::InSequence;
24  using ::testing::Lt;
25  using ::testing::Truly;
26  using absl::log_internal::SourceBasename;
27  using absl::log_internal::SourceFilename;
28  using absl::log_internal::SourceLine;
29  using absl::log_internal::TextMessageWithPrefix;
30  using absl::log_internal::ThreadID;
31  auto* test_env ABSL_ATTRIBUTE_UNUSED = ::testing::AddGlobalTestEnvironment(
32      new absl::log_internal::LogTestEnvironment);
33  #if GTEST_HAS_DEATH_TEST
34  TEST(ScopedMockLogDeathTest,
35       StartCapturingLogsCannotBeCalledWhenAlreadyCapturing) {
36    EXPECT_DEATH(
37        {
38          absl::ScopedMockLog log;
39          log.StartCapturingLogs();
40          log.StartCapturingLogs();
41        },
42        "StartCapturingLogs");
43  }
44  TEST(ScopedMockLogDeathTest, StopCapturingLogsCannotBeCalledWhenNotCapturing) {
45    EXPECT_DEATH(
46        {
47          absl::ScopedMockLog log;
48          log.StopCapturingLogs();
49        },
50        "StopCapturingLogs");
51  }
52  TEST(ScopedMockLogDeathTest, FailsCheckIfStartCapturingLogsIsNeverCalled) {
53    EXPECT_DEATH({ absl::ScopedMockLog log; },
54                 "Did you forget to call StartCapturingLogs");
55  }
56  #endif
57  TEST(ScopedMockLogTest, LogMockCatchAndMatchStrictExpectations) {
58    absl::ScopedMockLog log;
59    InSequence s;
60    EXPECT_CALL(log,
61                Log(absl::LogSeverity::kWarning, HasSubstr(__FILE__), "Danger."));
62    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, "Working...")).Times(2);
63    EXPECT_CALL(log, Log(absl::LogSeverity::kError, _, "Bad!!"));
64    log.StartCapturingLogs();
65    LOG(WARNING) << "Danger.";
66    LOG(INFO) << "Working...";
67    LOG(INFO) << "Working...";
68    LOG(ERROR) << "Bad!!";
69  }
70  TEST(ScopedMockLogTest, LogMockCatchAndMatchSendExpectations) {
71    absl::ScopedMockLog log;
72    EXPECT_CALL(
73        log,
74        Send(AllOf(SourceFilename(Eq("/my/very/very/very_long_source_file.cc")),
75                   SourceBasename(Eq("very_long_source_file.cc")),
76                   SourceLine(Eq(777)), ThreadID(Eq(absl::LogEntry::tid_t{1234})),
77                   TextMessageWithPrefix(Truly([](absl::string_view msg) {
78                     return absl::EndsWith(
79                         msg, " very_long_source_file.cc:777] Info message");
80                   })))));
81    log.StartCapturingLogs();
82    LOG(INFO)
83            .AtLocation("/my/very/very/very_long_source_file.cc", 777)
84            .WithThreadID(1234)
85        << "Info message";
86  }
87  TEST(ScopedMockLogTest, ScopedMockLogCanBeNice) {
88    absl::ScopedMockLog log;
89    InSequence s;
90    EXPECT_CALL(log,
91                Log(absl::LogSeverity::kWarning, HasSubstr(__FILE__), "Danger."));
92    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, "Working...")).Times(2);
93    EXPECT_CALL(log, Log(absl::LogSeverity::kError, _, "Bad!!"));
94    log.StartCapturingLogs();
95    LOG(INFO) << "Info message.";
96    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
97    LOG(WARNING) << "Danger.";
98    LOG(INFO) << "Info message.";
99    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
100    LOG(INFO) << "Working...";
101    LOG(INFO) << "Info message.";
102    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
103    LOG(INFO) << "Working...";
104    LOG(INFO) << "Info message.";
105    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
106    LOG(ERROR) << "Bad!!";
107    LOG(INFO) << "Info message.";
108    LOG(WARNING).AtLocation("SomeOtherFile.cc", 100) << "Danger ";
109  }
110  TEST(ScopedMockLogTest, RejectsUnexpectedLogs) {
111    EXPECT_NONFATAL_FAILURE(
112        {
113          absl::ScopedMockLog log(absl::MockLogDefault::kDisallowUnexpected);
114          EXPECT_CALL(log, Log(Lt(absl::LogSeverity::kError), _, _))
115              .Times(AnyNumber());
116          log.StartCapturingLogs();
117          LOG(INFO) << "Ignored";
118          LOG(WARNING) << "Ignored";
119          LOG(ERROR) << "Should not be ignored";
120        },
121        "Should not be ignored");
122  }
123  TEST(ScopedMockLogTest, CapturesLogsAfterStartCapturingLogs) {
124    absl::SetStderrThreshold(absl::LogSeverityAtLeast::kInfinity);
125    absl::ScopedMockLog log;
126    LOG(INFO) << "Ignored info";
127    LOG(WARNING) << "Ignored warning";
128    LOG(ERROR) << "Ignored error";
129    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, "Expected info"));
130    log.StartCapturingLogs();
131    LOG(INFO) << "Expected info";
132  }
133  TEST(ScopedMockLogTest, DoesNotCaptureLogsAfterStopCapturingLogs) {
134    absl::ScopedMockLog log;
135    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, "Expected info"));
136    log.StartCapturingLogs();
137    LOG(INFO) << "Expected info";
138    log.StopCapturingLogs();
139    LOG(INFO) << "Ignored info";
140    LOG(WARNING) << "Ignored warning";
141    LOG(ERROR) << "Ignored error";
142  }
143  TEST(ScopedMockLogTest, LogFromMultipleThreads) {
144    absl::ScopedMockLog log;
145    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, __FILE__, "Thread 1"));
146    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, __FILE__, "Thread 2"));
147    log.StartCapturingLogs();
148    absl::Barrier barrier(2);
149    std::thread thread1([&barrier]() {
150      barrier.Block();
151      LOG(INFO) << "Thread 1";
152    });
153    std::thread thread2([&barrier]() {
154      barrier.Block();
155      LOG(INFO) << "Thread 2";
156    });
157    thread1.join();
158    thread2.join();
159  }
160  TEST(ScopedMockLogTest, NoSequenceWithMultipleThreads) {
161    absl::ScopedMockLog log;
162    absl::Barrier barrier(2);
163    EXPECT_CALL(log, Log(absl::LogSeverity::kInfo, _, _))
164        .Times(2)
165        .WillRepeatedly([&barrier]() { barrier.Block(); });
166    log.StartCapturingLogs();
167    std::thread thread1([]() { LOG(INFO) << "Thread 1"; });
168    std::thread thread2([]() { LOG(INFO) << "Thread 2"; });
169    thread1.join();
170    thread2.join();
171  }
172  TEST(ScopedMockLogTsanTest,
173       ScopedMockLogCanBeDeletedWhenAnotherThreadIsLogging) {
174    auto log = absl::make_unique<absl::ScopedMockLog>();
175    EXPECT_CALL(*log, Log(absl::LogSeverity::kInfo, __FILE__, "Thread log"))
176        .Times(AnyNumber());
177    log->StartCapturingLogs();
178    absl::Notification logging_started;
179    std::thread thread([&logging_started]() {
180      for (int i = 0; i < 100; ++i) {
181        if (i == 50) logging_started.Notify();
182        LOG(INFO) << "Thread log";
183      }
<span onclick='openModal()' class='match'>184    });
185    logging_started.WaitForNotification();
186    log.reset();
187    thread.join();
</span>188  }
189  TEST(ScopedMockLogTest, AsLocalSink) {
190    absl::ScopedMockLog log(absl::MockLogDefault::kDisallowUnexpected);
191    EXPECT_CALL(log, Log(_, _, "two"));
192    EXPECT_CALL(log, Log(_, _, "three"));
193    LOG(INFO) << "one";
194    LOG(INFO).ToSinkOnly(&log.UseAsLocalSink()) << "two";
195    LOG(INFO).ToSinkAlso(&log.UseAsLocalSink()) << "three";
196  }
197  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-scoped_mock_log_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-scoped_mock_log_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>156    });
157    thread1.join();
158    thread2.join();
159  }
</pre></code></div>
                <div class="column column_space"><pre><code>184    });
185    logging_started.WaitForNotification();
186    log.reset();
187    thread.join();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    