
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-statusor_test.cc</h3>
            <pre><code>1  #include "absl/status/statusor.h"
2  #include <array>
3  #include <initializer_list>
4  #include <memory>
5  #include <string>
6  #include <type_traits>
7  #include <utility>
8  #include "gmock/gmock.h"
9  #include "gtest/gtest.h"
10  #include "absl/base/casts.h"
11  #include "absl/memory/memory.h"
12  #include "absl/status/status.h"
13  #include "absl/strings/string_view.h"
14  #include "absl/types/any.h"
15  #include "absl/utility/utility.h"
16  namespace {
17  using ::testing::AllOf;
18  using ::testing::AnyWith;
19  using ::testing::ElementsAre;
20  using ::testing::Field;
21  using ::testing::HasSubstr;
22  using ::testing::Ne;
23  using ::testing::Not;
24  using ::testing::Pointee;
25  using ::testing::VariantWith;
26  #ifdef GTEST_HAS_STATUS_MATCHERS
27  using ::testing::status::IsOk;
28  using ::testing::status::IsOkAndHolds;
29  #else  
30  inline const ::absl::Status& GetStatus(const ::absl::Status& status) {
31    return status;
32  }
33  template <typename T>
34  inline const ::absl::Status& GetStatus(const ::absl::StatusOr<T>& status) {
35    return status.status();
36  }
37  template <typename StatusOrType>
38  class IsOkAndHoldsMatcherImpl
39      : public ::testing::MatcherInterface<StatusOrType> {
40   public:
41    typedef
42        typename std::remove_reference<StatusOrType>::type::value_type value_type;
43    template <typename InnerMatcher>
44    explicit IsOkAndHoldsMatcherImpl(InnerMatcher&& inner_matcher)
45        : inner_matcher_(::testing::SafeMatcherCast<const value_type&>(
46              std::forward<InnerMatcher>(inner_matcher))) {}
47    void DescribeTo(std::ostream* os) const override {
48      *os << "is OK and has a value that ";
49      inner_matcher_.DescribeTo(os);
50    }
51    void DescribeNegationTo(std::ostream* os) const override {
52      *os << "isn't OK or has a value that ";
53      inner_matcher_.DescribeNegationTo(os);
54    }
55    bool MatchAndExplain(
56        StatusOrType actual_value,
57        ::testing::MatchResultListener* result_listener) const override {
58      if (!actual_value.ok()) {
59        *result_listener << "which has status " << actual_value.status();
60        return false;
61      }
62      ::testing::StringMatchResultListener inner_listener;
63      const bool matches =
64          inner_matcher_.MatchAndExplain(*actual_value, &inner_listener);
65      const std::string inner_explanation = inner_listener.str();
66      if (!inner_explanation.empty()) {
67        *result_listener << "which contains value "
68                         << ::testing::PrintToString(*actual_value) << ", "
69                         << inner_explanation;
70      }
71      return matches;
72    }
73   private:
74    const ::testing::Matcher<const value_type&> inner_matcher_;
75  };
76  template <typename InnerMatcher>
77  class IsOkAndHoldsMatcher {
78   public:
79    explicit IsOkAndHoldsMatcher(InnerMatcher inner_matcher)
80        : inner_matcher_(std::move(inner_matcher)) {}
81    template <typename StatusOrType>
82    operator ::testing::Matcher<StatusOrType>() const {  
83      return ::testing::Matcher<StatusOrType>(
84          new IsOkAndHoldsMatcherImpl<const StatusOrType&>(inner_matcher_));
85    }
86   private:
87    const InnerMatcher inner_matcher_;
88  };
89  template <typename T>
90  class MonoIsOkMatcherImpl : public ::testing::MatcherInterface<T> {
91   public:
92    void DescribeTo(std::ostream* os) const override { *os << "is OK"; }
93    void DescribeNegationTo(std::ostream* os) const override {
94      *os << "is not OK";
95    }
96    bool MatchAndExplain(T actual_value,
97                         ::testing::MatchResultListener*) const override {
98      return GetStatus(actual_value).ok();
99    }
100  };
101  class IsOkMatcher {
102   public:
103    template <typename T>
104    operator ::testing::Matcher<T>() const {  
105      return ::testing::Matcher<T>(new MonoIsOkMatcherImpl<T>());
106    }
107  };
108  #define EXPECT_OK(expression) EXPECT_THAT(expression, IsOk())
109  template <typename InnerMatcher>
110  IsOkAndHoldsMatcher<typename std::decay<InnerMatcher>::type> IsOkAndHolds(
111      InnerMatcher&& inner_matcher) {
112    return IsOkAndHoldsMatcher<typename std::decay<InnerMatcher>::type>(
113        std::forward<InnerMatcher>(inner_matcher));
114  }
115  inline IsOkMatcher IsOk() { return IsOkMatcher(); }
116  #endif  
117  struct CopyDetector {
118    CopyDetector() = default;
119    explicit CopyDetector(int xx) : x(xx) {}
120    CopyDetector(CopyDetector&& d) noexcept
121        : x(d.x), copied(false), moved(true) {}
122    CopyDetector(const CopyDetector& d) : x(d.x), copied(true), moved(false) {}
123    CopyDetector& operator=(const CopyDetector& c) {
124      x = c.x;
125      copied = true;
126      moved = false;
127      return *this;
128    }
129    CopyDetector& operator=(CopyDetector&& c) noexcept {
130      x = c.x;
131      copied = false;
132      moved = true;
133      return *this;
134    }
135    int x = 0;
136    bool copied = false;
137    bool moved = false;
138  };
139  testing::Matcher<const CopyDetector&> CopyDetectorHas(int a, bool b, bool c) {
140    return AllOf(Field(&CopyDetector::x, a), Field(&CopyDetector::moved, b),
141                 Field(&CopyDetector::copied, c));
142  }
143  class Base1 {
144   public:
145    virtual ~Base1() {}
146    int pad;
147  };
148  class Base2 {
149   public:
150    virtual ~Base2() {}
151    int yetotherpad;
152  };
153  class Derived : public Base1, public Base2 {
154   public:
155    virtual ~Derived() {}
156    int evenmorepad;
157  };
158  class CopyNoAssign {
159   public:
160    explicit CopyNoAssign(int value) : foo(value) {}
161    CopyNoAssign(const CopyNoAssign& other) : foo(other.foo) {}
162    int foo;
163   private:
164    const CopyNoAssign& operator=(const CopyNoAssign&);
165  };
166  absl::StatusOr<std::unique_ptr<int>> ReturnUniquePtr() {
167    return absl::make_unique<int>(0);
168  }
169  TEST(StatusOr, ElementType) {
170    static_assert(std::is_same<absl::StatusOr<int>::value_type, int>(), "");
171    static_assert(std::is_same<absl::StatusOr<char>::value_type, char>(), "");
172  }
173  TEST(StatusOr, TestMoveOnlyInitialization) {
174    absl::StatusOr<std::unique_ptr<int>> thing(ReturnUniquePtr());
175    ASSERT_TRUE(thing.ok());
176    EXPECT_EQ(0, **thing);
177    int* previous = thing->get();
178    thing = ReturnUniquePtr();
179    EXPECT_TRUE(thing.ok());
180    EXPECT_EQ(0, **thing);
181    EXPECT_NE(previous, thing->get());
182  }
183  TEST(StatusOr, TestMoveOnlyValueExtraction) {
184    absl::StatusOr<std::unique_ptr<int>> thing(ReturnUniquePtr());
185    ASSERT_TRUE(thing.ok());
186    std::unique_ptr<int> ptr = *std::move(thing);
187    EXPECT_EQ(0, *ptr);
188    thing = std::move(ptr);
189    ptr = std::move(*thing);
<span onclick='openModal()' class='match'>190    EXPECT_EQ(0, *ptr);
191  }
192  TEST(StatusOr, TestMoveOnlyInitializationFromTemporaryByValueOrDie) {
193    std::unique_ptr<int> ptr(*ReturnUniquePtr());
</span>194    EXPECT_EQ(0, *ptr);
195  }
196  TEST(StatusOr, TestValueOrDieOverloadForConstTemporary) {
197    static_assert(
198        std::is_same<
199            const int&&,
200            decltype(std::declval<const absl::StatusOr<int>&&>().value())>(),
201        "value() for const temporaries should return const T&&");
202  }
203  TEST(StatusOr, TestMoveOnlyConversion) {
204    absl::StatusOr<std::unique_ptr<const int>> const_thing(ReturnUniquePtr());
205    EXPECT_TRUE(const_thing.ok());
206    EXPECT_EQ(0, **const_thing);
207    const int* const_previous = const_thing->get();
208    const_thing = ReturnUniquePtr();
209    EXPECT_TRUE(const_thing.ok());
210    EXPECT_EQ(0, **const_thing);
211    EXPECT_NE(const_previous, const_thing->get());
212  }
213  TEST(StatusOr, TestMoveOnlyVector) {
214    std::vector<absl::StatusOr<std::unique_ptr<int>>> vec;
215    vec.push_back(ReturnUniquePtr());
216    vec.resize(2);
217    auto another_vec = std::move(vec);
218    EXPECT_EQ(0, **another_vec[0]);
219    EXPECT_EQ(absl::UnknownError(""), another_vec[1].status());
220  }
221  TEST(StatusOr, TestDefaultCtor) {
222    absl::StatusOr<int> thing;
223    EXPECT_FALSE(thing.ok());
224    EXPECT_EQ(thing.status().code(), absl::StatusCode::kUnknown);
225  }
226  TEST(StatusOr, StatusCtorForwards) {
227    absl::Status status(absl::StatusCode::kInternal, "Some error");
228    EXPECT_EQ(absl::StatusOr<int>(status).status().message(), "Some error");
229    EXPECT_EQ(status.message(), "Some error");
230    EXPECT_EQ(absl::StatusOr<int>(std::move(status)).status().message(),
231              "Some error");
232    EXPECT_NE(status.message(), "Some error");
233  }
234  TEST(BadStatusOrAccessTest, CopyConstructionWhatOk) {
235    absl::Status error =
236        absl::InternalError("some arbitrary message too big for the sso buffer");
237    absl::BadStatusOrAccess e1{error};
238    absl::BadStatusOrAccess e2{e1};
239    EXPECT_THAT(e1.what(), HasSubstr(error.ToString()));
240    EXPECT_THAT(e2.what(), HasSubstr(error.ToString()));
241  }
242  TEST(BadStatusOrAccessTest, CopyAssignmentWhatOk) {
243    absl::Status error =
244        absl::InternalError("some arbitrary message too big for the sso buffer");
245    absl::BadStatusOrAccess e1{error};
246    absl::BadStatusOrAccess e2{absl::InternalError("other")};
247    e2 = e1;
248    EXPECT_THAT(e1.what(), HasSubstr(error.ToString()));
249    EXPECT_THAT(e2.what(), HasSubstr(error.ToString()));
250  }
251  TEST(BadStatusOrAccessTest, MoveConstructionWhatOk) {
252    absl::Status error =
253        absl::InternalError("some arbitrary message too big for the sso buffer");
254    absl::BadStatusOrAccess e1{error};
255    absl::BadStatusOrAccess e2{std::move(e1)};
256    EXPECT_THAT(e2.what(), HasSubstr(error.ToString()));
257  }
258  TEST(BadStatusOrAccessTest, MoveAssignmentWhatOk) {
259    absl::Status error =
260        absl::InternalError("some arbitrary message too big for the sso buffer");
261    absl::BadStatusOrAccess e1{error};
262    absl::BadStatusOrAccess e2{absl::InternalError("other")};
263    e2 = std::move(e1);
264    EXPECT_THAT(e2.what(), HasSubstr(error.ToString()));
265  }
266  #ifdef ABSL_HAVE_EXCEPTIONS
267  #define EXPECT_DEATH_OR_THROW(statement, status_)                  \
268    EXPECT_THROW(                                                    \
269        {                                                            \
270          try {                                                      \
271            statement;                                               \
272          } catch (const absl::BadStatusOrAccess& e) {               \
273            EXPECT_EQ(e.status(), status_);                          \
274            EXPECT_THAT(e.what(), HasSubstr(e.status().ToString())); \
275            throw;                                                   \
276          }                                                          \
277        },                                                           \
278        absl::BadStatusOrAccess);
279  #else  
280  #define EXPECT_DEATH_OR_THROW(statement, status) \
281    EXPECT_DEATH_IF_SUPPORTED(statement, status.ToString());
282  #endif  
283  TEST(StatusOrDeathTest, TestDefaultCtorValue) {
284    absl::StatusOr<int> thing;
285    EXPECT_DEATH_OR_THROW(thing.value(), absl::UnknownError(""));
286    const absl::StatusOr<int> thing2;
287    EXPECT_DEATH_OR_THROW(thing2.value(), absl::UnknownError(""));
288  }
289  TEST(StatusOrDeathTest, TestValueNotOk) {
290    absl::StatusOr<int> thing(absl::CancelledError());
291    EXPECT_DEATH_OR_THROW(thing.value(), absl::CancelledError());
292  }
293  TEST(StatusOrDeathTest, TestValueNotOkConst) {
294    const absl::StatusOr<int> thing(absl::UnknownError(""));
295    EXPECT_DEATH_OR_THROW(thing.value(), absl::UnknownError(""));
296  }
297  TEST(StatusOrDeathTest, TestPointerDefaultCtorValue) {
298    absl::StatusOr<int*> thing;
299    EXPECT_DEATH_OR_THROW(thing.value(), absl::UnknownError(""));
300  }
301  TEST(StatusOrDeathTest, TestPointerValueNotOk) {
302    absl::StatusOr<int*> thing(absl::CancelledError());
303    EXPECT_DEATH_OR_THROW(thing.value(), absl::CancelledError());
304  }
305  TEST(StatusOrDeathTest, TestPointerValueNotOkConst) {
306    const absl::StatusOr<int*> thing(absl::CancelledError());
307    EXPECT_DEATH_OR_THROW(thing.value(), absl::CancelledError());
308  }
309  #if GTEST_HAS_DEATH_TEST
310  TEST(StatusOrDeathTest, TestStatusCtorStatusOk) {
311    EXPECT_DEBUG_DEATH(
312        {
313          absl::StatusOr<int> thing(absl::OkStatus());
314          EXPECT_FALSE(thing.ok());
315          EXPECT_EQ(thing.status().code(), absl::StatusCode::kInternal);
316        },
317        "An OK status is not a valid constructor argument");
318  }
319  TEST(StatusOrDeathTest, TestPointerStatusCtorStatusOk) {
320    EXPECT_DEBUG_DEATH(
321        {
322          absl::StatusOr<int*> thing(absl::OkStatus());
323          EXPECT_FALSE(thing.ok());
324          EXPECT_EQ(thing.status().code(), absl::StatusCode::kInternal);
325        },
326        "An OK status is not a valid constructor argument");
327  }
328  #endif
329  TEST(StatusOr, ValueAccessor) {
330    const int kIntValue = 110;
331    {
332      absl::StatusOr<int> status_or(kIntValue);
333      EXPECT_EQ(kIntValue, status_or.value());
334      EXPECT_EQ(kIntValue, std::move(status_or).value());
335    }
336    {
337      absl::StatusOr<CopyDetector> status_or(kIntValue);
338      EXPECT_THAT(status_or,
339                  IsOkAndHolds(CopyDetectorHas(kIntValue, false, false)));
340      CopyDetector copy_detector = status_or.value();
341      EXPECT_THAT(copy_detector, CopyDetectorHas(kIntValue, false, true));
342      copy_detector = std::move(status_or).value();
343      EXPECT_THAT(copy_detector, CopyDetectorHas(kIntValue, true, false));
344    }
345  }
346  TEST(StatusOr, BadValueAccess) {
347    const absl::Status kError = absl::CancelledError("message");
348    absl::StatusOr<int> status_or(kError);
349    EXPECT_DEATH_OR_THROW(status_or.value(), kError);
350  }
351  TEST(StatusOr, TestStatusCtor) {
352    absl::StatusOr<int> thing(absl::CancelledError());
353    EXPECT_FALSE(thing.ok());
354    EXPECT_EQ(thing.status().code(), absl::StatusCode::kCancelled);
355  }
356  TEST(StatusOr, TestValueCtor) {
357    const int kI = 4;
358    const absl::StatusOr<int> thing(kI);
359    EXPECT_TRUE(thing.ok());
360    EXPECT_EQ(kI, *thing);
361  }
362  struct Foo {
363    const int x;
364    explicit Foo(int y) : x(y) {}
365  };
366  TEST(StatusOr, InPlaceConstruction) {
367    EXPECT_THAT(absl::StatusOr<Foo>(absl::in_place, 10),
368                IsOkAndHolds(Field(&Foo::x, 10)));
369  }
370  struct InPlaceHelper {
371    InPlaceHelper(std::initializer_list<int> xs, std::unique_ptr<int> yy)
372        : x(xs), y(std::move(yy)) {}
373    const std::vector<int> x;
374    std::unique_ptr<int> y;
375  };
376  TEST(StatusOr, InPlaceInitListConstruction) {
377    absl::StatusOr<InPlaceHelper> status_or(absl::in_place, {10, 11, 12},
378                                            absl::make_unique<int>(13));
379    EXPECT_THAT(status_or, IsOkAndHolds(AllOf(
380                               Field(&InPlaceHelper::x, ElementsAre(10, 11, 12)),
381                               Field(&InPlaceHelper::y, Pointee(13)))));
382  }
383  TEST(StatusOr, Emplace) {
384    absl::StatusOr<Foo> status_or_foo(10);
385    status_or_foo.emplace(20);
386    EXPECT_THAT(status_or_foo, IsOkAndHolds(Field(&Foo::x, 20)));
387    status_or_foo = absl::InvalidArgumentError("msg");
388    EXPECT_FALSE(status_or_foo.ok());
389    EXPECT_EQ(status_or_foo.status().code(), absl::StatusCode::kInvalidArgument);
390    EXPECT_EQ(status_or_foo.status().message(), "msg");
391    status_or_foo.emplace(20);
392    EXPECT_THAT(status_or_foo, IsOkAndHolds(Field(&Foo::x, 20)));
393  }
394  TEST(StatusOr, EmplaceInitializerList) {
395    absl::StatusOr<InPlaceHelper> status_or(absl::in_place, {10, 11, 12},
396                                            absl::make_unique<int>(13));
397    status_or.emplace({1, 2, 3}, absl::make_unique<int>(4));
398    EXPECT_THAT(status_or,
399                IsOkAndHolds(AllOf(Field(&InPlaceHelper::x, ElementsAre(1, 2, 3)),
400                                   Field(&InPlaceHelper::y, Pointee(4)))));
401    status_or = absl::InvalidArgumentError("msg");
402    EXPECT_FALSE(status_or.ok());
403    EXPECT_EQ(status_or.status().code(), absl::StatusCode::kInvalidArgument);
404    EXPECT_EQ(status_or.status().message(), "msg");
405    status_or.emplace({1, 2, 3}, absl::make_unique<int>(4));
406    EXPECT_THAT(status_or,
407                IsOkAndHolds(AllOf(Field(&InPlaceHelper::x, ElementsAre(1, 2, 3)),
408                                   Field(&InPlaceHelper::y, Pointee(4)))));
409  }
410  TEST(StatusOr, TestCopyCtorStatusOk) {
411    const int kI = 4;
412    const absl::StatusOr<int> original(kI);
413    const absl::StatusOr<int> copy(original);
414    EXPECT_OK(copy.status());
415    EXPECT_EQ(*original, *copy);
416  }
417  TEST(StatusOr, TestCopyCtorStatusNotOk) {
418    absl::StatusOr<int> original(absl::CancelledError());
419    absl::StatusOr<int> copy(original);
420    EXPECT_EQ(copy.status().code(), absl::StatusCode::kCancelled);
421  }
422  TEST(StatusOr, TestCopyCtorNonAssignable) {
423    const int kI = 4;
424    CopyNoAssign value(kI);
425    absl::StatusOr<CopyNoAssign> original(value);
426    absl::StatusOr<CopyNoAssign> copy(original);
427    EXPECT_OK(copy.status());
428    EXPECT_EQ(original->foo, copy->foo);
429  }
430  TEST(StatusOr, TestCopyCtorStatusOKConverting) {
431    const int kI = 4;
432    absl::StatusOr<int> original(kI);
433    absl::StatusOr<double> copy(original);
434    EXPECT_OK(copy.status());
435    EXPECT_DOUBLE_EQ(*original, *copy);
436  }
437  TEST(StatusOr, TestCopyCtorStatusNotOkConverting) {
438    absl::StatusOr<int> original(absl::CancelledError());
439    absl::StatusOr<double> copy(original);
440    EXPECT_EQ(copy.status(), original.status());
441  }
442  TEST(StatusOr, TestAssignmentStatusOk) {
443    {
444      const auto p = std::make_shared<int>(17);
445      absl::StatusOr<std::shared_ptr<int>> source(p);
446      absl::StatusOr<std::shared_ptr<int>> target;
447      target = source;
448      ASSERT_TRUE(target.ok());
449      EXPECT_OK(target.status());
450      EXPECT_EQ(p, *target);
451      ASSERT_TRUE(source.ok());
452      EXPECT_OK(source.status());
453      EXPECT_EQ(p, *source);
454    }
455    {
456      const auto p = std::make_shared<int>(17);
457      absl::StatusOr<std::shared_ptr<int>> source(p);
458      absl::StatusOr<std::shared_ptr<int>> target;
459      target = std::move(source);
460      ASSERT_TRUE(target.ok());
461      EXPECT_OK(target.status());
462      EXPECT_EQ(p, *target);
463      ASSERT_TRUE(source.ok());
464      EXPECT_OK(source.status());
465      EXPECT_EQ(nullptr, *source);
466    }
467  }
468  TEST(StatusOr, TestAssignmentStatusNotOk) {
469    {
470      const absl::Status expected = absl::CancelledError();
471      absl::StatusOr<int> source(expected);
472      absl::StatusOr<int> target;
473      target = source;
474      EXPECT_FALSE(target.ok());
475      EXPECT_EQ(expected, target.status());
476      EXPECT_FALSE(source.ok());
477      EXPECT_EQ(expected, source.status());
478    }
479    {
480      const absl::Status expected = absl::CancelledError();
481      absl::StatusOr<int> source(expected);
482      absl::StatusOr<int> target;
483      target = std::move(source);
484      EXPECT_FALSE(target.ok());
485      EXPECT_EQ(expected, target.status());
486      EXPECT_FALSE(source.ok());
487      EXPECT_EQ(source.status().code(), absl::StatusCode::kInternal);
488    }
489  }
490  TEST(StatusOr, TestAssignmentStatusOKConverting) {
491    {
492      const int kI = 4;
493      absl::StatusOr<int> source(kI);
494      absl::StatusOr<double> target;
495      target = source;
496      ASSERT_TRUE(target.ok());
497      EXPECT_OK(target.status());
498      EXPECT_DOUBLE_EQ(kI, *target);
499      ASSERT_TRUE(source.ok());
500      EXPECT_OK(source.status());
501      EXPECT_DOUBLE_EQ(kI, *source);
502    }
503    {
504      const auto p = new int(17);
505      absl::StatusOr<std::unique_ptr<int>> source(absl::WrapUnique(p));
506      absl::StatusOr<std::shared_ptr<int>> target;
507      target = std::move(source);
508      ASSERT_TRUE(target.ok());
509      EXPECT_OK(target.status());
510      EXPECT_EQ(p, target->get());
511      ASSERT_TRUE(source.ok());
512      EXPECT_OK(source.status());
513      EXPECT_EQ(nullptr, source->get());
514    }
515  }
516  struct A {
517    int x;
518  };
519  struct ImplicitConstructibleFromA {
520    int x;
521    bool moved;
522    ImplicitConstructibleFromA(const A& a)  
523        : x(a.x), moved(false) {}
524    ImplicitConstructibleFromA(A&& a)  
525        : x(a.x), moved(true) {}
526  };
527  TEST(StatusOr, ImplicitConvertingConstructor) {
528    EXPECT_THAT(
529        absl::implicit_cast<absl::StatusOr<ImplicitConstructibleFromA>>(
530            absl::StatusOr<A>(A{11})),
531        IsOkAndHolds(AllOf(Field(&ImplicitConstructibleFromA::x, 11),
532                           Field(&ImplicitConstructibleFromA::moved, true))));
533    absl::StatusOr<A> a(A{12});
534    EXPECT_THAT(
535        absl::implicit_cast<absl::StatusOr<ImplicitConstructibleFromA>>(a),
536        IsOkAndHolds(AllOf(Field(&ImplicitConstructibleFromA::x, 12),
537                           Field(&ImplicitConstructibleFromA::moved, false))));
538  }
539  struct ExplicitConstructibleFromA {
540    int x;
541    bool moved;
542    explicit ExplicitConstructibleFromA(const A& a) : x(a.x), moved(false) {}
543    explicit ExplicitConstructibleFromA(A&& a) : x(a.x), moved(true) {}
544  };
545  TEST(StatusOr, ExplicitConvertingConstructor) {
546    EXPECT_FALSE(
547        (std::is_convertible<const absl::StatusOr<A>&,
548                             absl::StatusOr<ExplicitConstructibleFromA>>::value));
549    EXPECT_FALSE(
550        (std::is_convertible<absl::StatusOr<A>&&,
551                             absl::StatusOr<ExplicitConstructibleFromA>>::value));
552    EXPECT_THAT(
553        absl::StatusOr<ExplicitConstructibleFromA>(absl::StatusOr<A>(A{11})),
554        IsOkAndHolds(AllOf(Field(&ExplicitConstructibleFromA::x, 11),
555                           Field(&ExplicitConstructibleFromA::moved, true))));
556    absl::StatusOr<A> a(A{12});
557    EXPECT_THAT(
558        absl::StatusOr<ExplicitConstructibleFromA>(a),
559        IsOkAndHolds(AllOf(Field(&ExplicitConstructibleFromA::x, 12),
560                           Field(&ExplicitConstructibleFromA::moved, false))));
561  }
562  struct ImplicitConstructibleFromBool {
563    ImplicitConstructibleFromBool(bool y) : x(y) {}  
564    bool x = false;
565  };
566  struct ConvertibleToBool {
567    explicit ConvertibleToBool(bool y) : x(y) {}
568    operator bool() const { return x; }  
569    bool x = false;
570  };
571  TEST(StatusOr, ImplicitBooleanConstructionWithImplicitCasts) {
572    EXPECT_THAT(absl::StatusOr<bool>(absl::StatusOr<ConvertibleToBool>(true)),
573                IsOkAndHolds(true));
574    EXPECT_THAT(absl::StatusOr<bool>(absl::StatusOr<ConvertibleToBool>(false)),
575                IsOkAndHolds(false));
576    EXPECT_THAT(
577        absl::implicit_cast<absl::StatusOr<ImplicitConstructibleFromBool>>(
578            absl::StatusOr<bool>(false)),
579        IsOkAndHolds(Field(&ImplicitConstructibleFromBool::x, false)));
580    EXPECT_FALSE((std::is_convertible<
581                  absl::StatusOr<ConvertibleToBool>,
582                  absl::StatusOr<ImplicitConstructibleFromBool>>::value));
583  }
584  TEST(StatusOr, BooleanConstructionWithImplicitCasts) {
585    EXPECT_THAT(absl::StatusOr<bool>(absl::StatusOr<ConvertibleToBool>(true)),
586                IsOkAndHolds(true));
587    EXPECT_THAT(absl::StatusOr<bool>(absl::StatusOr<ConvertibleToBool>(false)),
588                IsOkAndHolds(false));
589    EXPECT_THAT(
590        absl::StatusOr<ImplicitConstructibleFromBool>{
591            absl::StatusOr<bool>(false)},
592        IsOkAndHolds(Field(&ImplicitConstructibleFromBool::x, false)));
593    EXPECT_THAT(
594        absl::StatusOr<ImplicitConstructibleFromBool>{
595            absl::StatusOr<bool>(absl::InvalidArgumentError(""))},
596        Not(IsOk()));
597    EXPECT_THAT(
598        absl::StatusOr<ImplicitConstructibleFromBool>{
599            absl::StatusOr<ConvertibleToBool>(ConvertibleToBool{false})},
600        IsOkAndHolds(Field(&ImplicitConstructibleFromBool::x, false)));
601    EXPECT_THAT(
602        absl::StatusOr<ImplicitConstructibleFromBool>{
603            absl::StatusOr<ConvertibleToBool>(absl::InvalidArgumentError(""))},
604        Not(IsOk()));
605  }
606  TEST(StatusOr, ConstImplicitCast) {
607    EXPECT_THAT(absl::implicit_cast<absl::StatusOr<bool>>(
608                    absl::StatusOr<const bool>(true)),
609                IsOkAndHolds(true));
610    EXPECT_THAT(absl::implicit_cast<absl::StatusOr<bool>>(
611                    absl::StatusOr<const bool>(false)),
612                IsOkAndHolds(false));
613    EXPECT_THAT(absl::implicit_cast<absl::StatusOr<const bool>>(
614                    absl::StatusOr<bool>(true)),
615                IsOkAndHolds(true));
616    EXPECT_THAT(absl::implicit_cast<absl::StatusOr<const bool>>(
617                    absl::StatusOr<bool>(false)),
618                IsOkAndHolds(false));
619    EXPECT_THAT(absl::implicit_cast<absl::StatusOr<const std::string>>(
620                    absl::StatusOr<std::string>("foo")),
621                IsOkAndHolds("foo"));
622    EXPECT_THAT(absl::implicit_cast<absl::StatusOr<std::string>>(
623                    absl::StatusOr<const std::string>("foo")),
624                IsOkAndHolds("foo"));
625    EXPECT_THAT(
626        absl::implicit_cast<absl::StatusOr<std::shared_ptr<const std::string>>>(
627            absl::StatusOr<std::shared_ptr<std::string>>(
628                std::make_shared<std::string>("foo"))),
629        IsOkAndHolds(Pointee(std::string("foo"))));
630  }
631  TEST(StatusOr, ConstExplicitConstruction) {
632    EXPECT_THAT(absl::StatusOr<bool>(absl::StatusOr<const bool>(true)),
633                IsOkAndHolds(true));
634    EXPECT_THAT(absl::StatusOr<bool>(absl::StatusOr<const bool>(false)),
635                IsOkAndHolds(false));
636    EXPECT_THAT(absl::StatusOr<const bool>(absl::StatusOr<bool>(true)),
637                IsOkAndHolds(true));
638    EXPECT_THAT(absl::StatusOr<const bool>(absl::StatusOr<bool>(false)),
639                IsOkAndHolds(false));
640  }
641  struct ExplicitConstructibleFromInt {
642    int x;
643    explicit ExplicitConstructibleFromInt(int y) : x(y) {}
644  };
645  TEST(StatusOr, ExplicitConstruction) {
646    EXPECT_THAT(absl::StatusOr<ExplicitConstructibleFromInt>(10),
647                IsOkAndHolds(Field(&ExplicitConstructibleFromInt::x, 10)));
648  }
649  TEST(StatusOr, ImplicitConstruction) {
650    auto status_or =
651        absl::implicit_cast<absl::StatusOr<absl::variant<int, std::string>>>(10);
652    EXPECT_THAT(status_or, IsOkAndHolds(VariantWith<int>(10)));
653  }
654  TEST(StatusOr, ImplicitConstructionFromInitliazerList) {
655    auto status_or =
656        absl::implicit_cast<absl::StatusOr<std::vector<int>>>({{10, 20, 30}});
657    EXPECT_THAT(status_or, IsOkAndHolds(ElementsAre(10, 20, 30)));
658  }
659  TEST(StatusOr, UniquePtrImplicitConstruction) {
660    auto status_or = absl::implicit_cast<absl::StatusOr<std::unique_ptr<Base1>>>(
661        absl::make_unique<Derived>());
662    EXPECT_THAT(status_or, IsOkAndHolds(Ne(nullptr)));
663  }
664  TEST(StatusOr, NestedStatusOrCopyAndMoveConstructorTests) {
665    absl::StatusOr<absl::StatusOr<CopyDetector>> status_or = CopyDetector(10);
666    absl::StatusOr<absl::StatusOr<CopyDetector>> status_error =
667        absl::InvalidArgumentError("foo");
668    EXPECT_THAT(status_or,
669                IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, true, false))));
670    absl::StatusOr<absl::StatusOr<CopyDetector>> a = status_or;
671    EXPECT_THAT(a, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, false, true))));
672    absl::StatusOr<absl::StatusOr<CopyDetector>> a_err = status_error;
673    EXPECT_THAT(a_err, Not(IsOk()));
674    const absl::StatusOr<absl::StatusOr<CopyDetector>>& cref = status_or;
675    absl::StatusOr<absl::StatusOr<CopyDetector>> b = cref;  
676    EXPECT_THAT(b, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, false, true))));
677    const absl::StatusOr<absl::StatusOr<CopyDetector>>& cref_err = status_error;
678    absl::StatusOr<absl::StatusOr<CopyDetector>> b_err = cref_err;  
679    EXPECT_THAT(b_err, Not(IsOk()));
680    absl::StatusOr<absl::StatusOr<CopyDetector>> c = std::move(status_or);
681    EXPECT_THAT(c, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, true, false))));
682    absl::StatusOr<absl::StatusOr<CopyDetector>> c_err = std::move(status_error);
683    EXPECT_THAT(c_err, Not(IsOk()));
684  }
685  TEST(StatusOr, NestedStatusOrCopyAndMoveAssignment) {
686    absl::StatusOr<absl::StatusOr<CopyDetector>> status_or = CopyDetector(10);
687    absl::StatusOr<absl::StatusOr<CopyDetector>> status_error =
688        absl::InvalidArgumentError("foo");
689    absl::StatusOr<absl::StatusOr<CopyDetector>> a;
690    a = status_or;
691    EXPECT_THAT(a, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, false, true))));
692    a = status_error;
693    EXPECT_THAT(a, Not(IsOk()));
694    const absl::StatusOr<absl::StatusOr<CopyDetector>>& cref = status_or;
695    a = cref;
696    EXPECT_THAT(a, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, false, true))));
697    const absl::StatusOr<absl::StatusOr<CopyDetector>>& cref_err = status_error;
698    a = cref_err;
699    EXPECT_THAT(a, Not(IsOk()));
700    a = std::move(status_or);
701    EXPECT_THAT(a, IsOkAndHolds(IsOkAndHolds(CopyDetectorHas(10, true, false))));
702    a = std::move(status_error);
703    EXPECT_THAT(a, Not(IsOk()));
704  }
705  struct Copyable {
706    Copyable() {}
707    Copyable(const Copyable&) {}
708    Copyable& operator=(const Copyable&) { return *this; }
709  };
710  struct MoveOnly {
711    MoveOnly() {}
712    MoveOnly(MoveOnly&&) {}
713    MoveOnly& operator=(MoveOnly&&) { return *this; }
714  };
715  struct NonMovable {
716    NonMovable() {}
717    NonMovable(const NonMovable&) = delete;
718    NonMovable(NonMovable&&) = delete;
719    NonMovable& operator=(const NonMovable&) = delete;
720    NonMovable& operator=(NonMovable&&) = delete;
721  };
722  TEST(StatusOr, CopyAndMoveAbility) {
723    EXPECT_TRUE(std::is_copy_constructible<Copyable>::value);
724    EXPECT_TRUE(std::is_copy_assignable<Copyable>::value);
725    EXPECT_TRUE(std::is_move_constructible<Copyable>::value);
726    EXPECT_TRUE(std::is_move_assignable<Copyable>::value);
727    EXPECT_FALSE(std::is_copy_constructible<MoveOnly>::value);
728    EXPECT_FALSE(std::is_copy_assignable<MoveOnly>::value);
729    EXPECT_TRUE(std::is_move_constructible<MoveOnly>::value);
730    EXPECT_TRUE(std::is_move_assignable<MoveOnly>::value);
731    EXPECT_FALSE(std::is_copy_constructible<NonMovable>::value);
732    EXPECT_FALSE(std::is_copy_assignable<NonMovable>::value);
733    EXPECT_FALSE(std::is_move_constructible<NonMovable>::value);
734    EXPECT_FALSE(std::is_move_assignable<NonMovable>::value);
735  }
736  TEST(StatusOr, StatusOrAnyCopyAndMoveConstructorTests) {
737    absl::StatusOr<absl::any> status_or = CopyDetector(10);
738    absl::StatusOr<absl::any> status_error = absl::InvalidArgumentError("foo");
739    EXPECT_THAT(
740        status_or,
741        IsOkAndHolds(AnyWith<CopyDetector>(CopyDetectorHas(10, true, false))));
742    absl::StatusOr<absl::any> a = status_or;
743    EXPECT_THAT(
744        a, IsOkAndHolds(AnyWith<CopyDetector>(CopyDetectorHas(10, false, true))));
745    absl::StatusOr<absl::any> a_err = status_error;
746    EXPECT_THAT(a_err, Not(IsOk()));
747    const absl::StatusOr<absl::any>& cref = status_or;
748    absl::StatusOr<absl::any> b = cref;  
749    EXPECT_THAT(
750        b, IsOkAndHolds(AnyWith<CopyDetector>(CopyDetectorHas(10, false, true))));
751    const absl::StatusOr<absl::any>& cref_err = status_error;
752    absl::StatusOr<absl::any> b_err = cref_err;  
753    EXPECT_THAT(b_err, Not(IsOk()));
754    absl::StatusOr<absl::any> c = std::move(status_or);
755    EXPECT_THAT(
756        c, IsOkAndHolds(AnyWith<CopyDetector>(CopyDetectorHas(10, true, false))));
757    absl::StatusOr<absl::any> c_err = std::move(status_error);
758    EXPECT_THAT(c_err, Not(IsOk()));
759  }
760  TEST(StatusOr, StatusOrAnyCopyAndMoveAssignment) {
761    absl::StatusOr<absl::any> status_or = CopyDetector(10);
762    absl::StatusOr<absl::any> status_error = absl::InvalidArgumentError("foo");
763    absl::StatusOr<absl::any> a;
764    a = status_or;
765    EXPECT_THAT(
766        a, IsOkAndHolds(AnyWith<CopyDetector>(CopyDetectorHas(10, false, true))));
767    a = status_error;
768    EXPECT_THAT(a, Not(IsOk()));
769    const absl::StatusOr<absl::any>& cref = status_or;
770    a = cref;
771    EXPECT_THAT(
772        a, IsOkAndHolds(AnyWith<CopyDetector>(CopyDetectorHas(10, false, true))));
773    const absl::StatusOr<absl::any>& cref_err = status_error;
774    a = cref_err;
775    EXPECT_THAT(a, Not(IsOk()));
776    a = std::move(status_or);
777    EXPECT_THAT(
778        a, IsOkAndHolds(AnyWith<CopyDetector>(CopyDetectorHas(10, true, false))));
779    a = std::move(status_error);
780    EXPECT_THAT(a, Not(IsOk()));
781  }
782  TEST(StatusOr, StatusOrCopyAndMoveTestsConstructor) {
783    absl::StatusOr<CopyDetector> status_or(10);
784    ASSERT_THAT(status_or, IsOkAndHolds(CopyDetectorHas(10, false, false)));
785    absl::StatusOr<CopyDetector> a(status_or);
786    EXPECT_THAT(a, IsOkAndHolds(CopyDetectorHas(10, false, true)));
787    const absl::StatusOr<CopyDetector>& cref = status_or;
788    absl::StatusOr<CopyDetector> b(cref);  
789    EXPECT_THAT(b, IsOkAndHolds(CopyDetectorHas(10, false, true)));
790    absl::StatusOr<CopyDetector> c(std::move(status_or));
791    EXPECT_THAT(c, IsOkAndHolds(CopyDetectorHas(10, true, false)));
792  }
793  TEST(StatusOr, StatusOrCopyAndMoveTestsAssignment) {
794    absl::StatusOr<CopyDetector> status_or(10);
795    ASSERT_THAT(status_or, IsOkAndHolds(CopyDetectorHas(10, false, false)));
796    absl::StatusOr<CopyDetector> a;
797    a = status_or;
798    EXPECT_THAT(a, IsOkAndHolds(CopyDetectorHas(10, false, true)));
799    const absl::StatusOr<CopyDetector>& cref = status_or;
800    absl::StatusOr<CopyDetector> b;
801    b = cref;
802    EXPECT_THAT(b, IsOkAndHolds(CopyDetectorHas(10, false, true)));
803    absl::StatusOr<CopyDetector> c;
804    c = std::move(status_or);
805    EXPECT_THAT(c, IsOkAndHolds(CopyDetectorHas(10, true, false)));
806  }
807  TEST(StatusOr, AbslAnyAssignment) {
808    EXPECT_FALSE((std::is_assignable<absl::StatusOr<absl::any>,
809                                     absl::StatusOr<int>>::value));
810    absl::StatusOr<absl::any> status_or;
811    status_or = absl::InvalidArgumentError("foo");
812    EXPECT_THAT(status_or, Not(IsOk()));
813  }
814  TEST(StatusOr, ImplicitAssignment) {
815    absl::StatusOr<absl::variant<int, std::string>> status_or;
816    status_or = 10;
817    EXPECT_THAT(status_or, IsOkAndHolds(VariantWith<int>(10)));
818  }
819  TEST(StatusOr, SelfDirectInitAssignment) {
820    absl::StatusOr<std::vector<int>> status_or = {{10, 20, 30}};
821    status_or = *status_or;
822    EXPECT_THAT(status_or, IsOkAndHolds(ElementsAre(10, 20, 30)));
823  }
824  TEST(StatusOr, ImplicitCastFromInitializerList) {
825    absl::StatusOr<std::vector<int>> status_or = {{10, 20, 30}};
826    EXPECT_THAT(status_or, IsOkAndHolds(ElementsAre(10, 20, 30)));
827  }
828  TEST(StatusOr, UniquePtrImplicitAssignment) {
829    absl::StatusOr<std::unique_ptr<Base1>> status_or;
830    status_or = absl::make_unique<Derived>();
831    EXPECT_THAT(status_or, IsOkAndHolds(Ne(nullptr)));
832  }
833  TEST(StatusOr, Pointer) {
834    struct A {};
835    struct B : public A {};
836    struct C : private A {};
837    EXPECT_TRUE((std::is_constructible<absl::StatusOr<A*>, B*>::value));
838    EXPECT_TRUE((std::is_convertible<B*, absl::StatusOr<A*>>::value));
839    EXPECT_FALSE((std::is_constructible<absl::StatusOr<A*>, C*>::value));
840    EXPECT_FALSE((std::is_convertible<C*, absl::StatusOr<A*>>::value));
841  }
842  TEST(StatusOr, TestAssignmentStatusNotOkConverting) {
843    {
844      const absl::Status expected = absl::CancelledError();
845      absl::StatusOr<int> source(expected);
846      absl::StatusOr<double> target;
847      target = source;
848      EXPECT_FALSE(target.ok());
849      EXPECT_EQ(expected, target.status());
850      EXPECT_FALSE(source.ok());
851      EXPECT_EQ(expected, source.status());
852    }
853    {
854      const absl::Status expected = absl::CancelledError();
855      absl::StatusOr<int> source(expected);
856      absl::StatusOr<double> target;
857      target = std::move(source);
858      EXPECT_FALSE(target.ok());
859      EXPECT_EQ(expected, target.status());
860      EXPECT_FALSE(source.ok());
861      EXPECT_EQ(source.status().code(), absl::StatusCode::kInternal);
862    }
863  }
864  TEST(StatusOr, SelfAssignment) {
865    {
866      const std::string long_str(128, 'a');
867      absl::StatusOr<std::string> so = long_str;
868      so = *&so;
869      ASSERT_TRUE(so.ok());
870      EXPECT_OK(so.status());
871      EXPECT_EQ(long_str, *so);
872    }
873    {
874      absl::StatusOr<int> so = absl::NotFoundError("taco");
875      so = *&so;
876      EXPECT_FALSE(so.ok());
877      EXPECT_EQ(so.status().code(), absl::StatusCode::kNotFound);
878      EXPECT_EQ(so.status().message(), "taco");
879    }
880    {
881      absl::StatusOr<int> so = 17;
882      auto& same = so;
883      so = std::move(same);
884      ASSERT_TRUE(so.ok());
885      EXPECT_OK(so.status());
886      EXPECT_EQ(17, *so);
887    }
888    {
889      absl::StatusOr<int> so = absl::NotFoundError("taco");
890      auto& same = so;
891      so = std::move(same);
892      EXPECT_FALSE(so.ok());
893      EXPECT_EQ(so.status().code(), absl::StatusCode::kNotFound);
894      EXPECT_EQ(so.status().message(), "taco");
895    }
896    {
897      const auto raw = new int(17);
898      absl::StatusOr<std::unique_ptr<int>> so = absl::WrapUnique(raw);
899      auto& same = so;
900      so = std::move(same);
901      ASSERT_TRUE(so.ok());
902      EXPECT_OK(so.status());
903      EXPECT_EQ(raw, so->get());
904    }
905    {
906      absl::StatusOr<std::unique_ptr<int>> so = absl::NotFoundError("taco");
907      auto& same = so;
908      so = std::move(same);
909      EXPECT_FALSE(so.ok());
910      EXPECT_EQ(so.status().code(), absl::StatusCode::kNotFound);
911      EXPECT_EQ(so.status().message(), "taco");
912    }
913  }
914  struct FromConstructibleAssignableLvalue {};
915  struct FromConstructibleAssignableRvalue {};
916  struct FromImplicitConstructibleOnly {};
917  struct FromAssignableOnly {};
918  struct MockValue {
919    MockValue(const FromConstructibleAssignableLvalue&)  
920        : from_rvalue(false), assigned(false) {}
921    MockValue(FromConstructibleAssignableRvalue&&)  
922        : from_rvalue(true), assigned(false) {}
923    MockValue(const FromImplicitConstructibleOnly&)  
924        : from_rvalue(false), assigned(false) {}
925    MockValue& operator=(const FromConstructibleAssignableLvalue&) {
926      from_rvalue = false;
927      assigned = true;
928      return *this;
929    }
930    MockValue& operator=(FromConstructibleAssignableRvalue&&) {
931      from_rvalue = true;
932      assigned = true;
933      return *this;
934    }
935    MockValue& operator=(const FromAssignableOnly&) {
936      from_rvalue = false;
937      assigned = true;
938      return *this;
939    }
940    bool from_rvalue;
941    bool assigned;
942  };
943  TEST(StatusOr, PerfectForwardingAssignment) {
944    constexpr int kValue1 = 10, kValue2 = 20;
945    absl::StatusOr<CopyDetector> status_or;
946    CopyDetector lvalue(kValue1);
947    status_or = lvalue;
948    EXPECT_THAT(status_or, IsOkAndHolds(CopyDetectorHas(kValue1, false, true)));
949    status_or = CopyDetector(kValue2);
950    EXPECT_THAT(status_or, IsOkAndHolds(CopyDetectorHas(kValue2, true, false)));
951    EXPECT_TRUE(
952        (std::is_assignable<absl::StatusOr<MockValue>&,
953                            const FromConstructibleAssignableLvalue&>::value));
954    EXPECT_TRUE((std::is_assignable<absl::StatusOr<MockValue>&,
955                                    FromConstructibleAssignableLvalue&&>::value));
956    EXPECT_FALSE(
957        (std::is_assignable<absl::StatusOr<MockValue>&,
958                            const FromConstructibleAssignableRvalue&>::value));
959    EXPECT_TRUE((std::is_assignable<absl::StatusOr<MockValue>&,
960                                    FromConstructibleAssignableRvalue&&>::value));
961    EXPECT_TRUE(
962        (std::is_assignable<absl::StatusOr<MockValue>&,
963                            const FromImplicitConstructibleOnly&>::value));
964    EXPECT_FALSE((std::is_assignable<absl::StatusOr<MockValue>&,
965                                     const FromAssignableOnly&>::value));
966    absl::StatusOr<MockValue> from_lvalue(FromConstructibleAssignableLvalue{});
967    EXPECT_FALSE(from_lvalue->from_rvalue);
968    EXPECT_FALSE(from_lvalue->assigned);
969    from_lvalue = FromConstructibleAssignableLvalue{};
970    EXPECT_FALSE(from_lvalue->from_rvalue);
971    EXPECT_TRUE(from_lvalue->assigned);
972    absl::StatusOr<MockValue> from_rvalue(FromConstructibleAssignableRvalue{});
973    EXPECT_TRUE(from_rvalue->from_rvalue);
974    EXPECT_FALSE(from_rvalue->assigned);
975    from_rvalue = FromConstructibleAssignableRvalue{};
976    EXPECT_TRUE(from_rvalue->from_rvalue);
977    EXPECT_TRUE(from_rvalue->assigned);
978    absl::StatusOr<MockValue> from_implicit_constructible(
979        FromImplicitConstructibleOnly{});
980    EXPECT_FALSE(from_implicit_constructible->from_rvalue);
981    EXPECT_FALSE(from_implicit_constructible->assigned);
982    from_implicit_constructible = FromImplicitConstructibleOnly{};
983    EXPECT_FALSE(from_implicit_constructible->from_rvalue);
984    EXPECT_FALSE(from_implicit_constructible->assigned);
985  }
986  TEST(StatusOr, TestStatus) {
987    absl::StatusOr<int> good(4);
988    EXPECT_TRUE(good.ok());
989    absl::StatusOr<int> bad(absl::CancelledError());
990    EXPECT_FALSE(bad.ok());
991    EXPECT_EQ(bad.status().code(), absl::StatusCode::kCancelled);
992  }
993  TEST(StatusOr, OperatorStarRefQualifiers) {
994    static_assert(
995        std::is_same<const int&,
996                     decltype(*std::declval<const absl::StatusOr<int>&>())>(),
997        "Unexpected ref-qualifiers");
998    static_assert(
999        std::is_same<int&, decltype(*std::declval<absl::StatusOr<int>&>())>(),
1000        "Unexpected ref-qualifiers");
1001    static_assert(
1002        std::is_same<const int&&,
1003                     decltype(*std::declval<const absl::StatusOr<int>&&>())>(),
1004        "Unexpected ref-qualifiers");
1005    static_assert(
1006        std::is_same<int&&, decltype(*std::declval<absl::StatusOr<int>&&>())>(),
1007        "Unexpected ref-qualifiers");
1008  }
1009  TEST(StatusOr, OperatorStar) {
1010    const absl::StatusOr<std::string> const_lvalue("hello");
1011    EXPECT_EQ("hello", *const_lvalue);
1012    absl::StatusOr<std::string> lvalue("hello");
1013    EXPECT_EQ("hello", *lvalue);
1014    const absl::StatusOr<std::string> const_rvalue("hello");
1015    EXPECT_EQ("hello", *std::move(const_rvalue));  
1016    absl::StatusOr<std::string> rvalue("hello");
1017    EXPECT_EQ("hello", *std::move(rvalue));
1018  }
1019  TEST(StatusOr, OperatorArrowQualifiers) {
1020    static_assert(
1021        std::is_same<
1022            const int*,
1023            decltype(std::declval<const absl::StatusOr<int>&>().operator->())>(),
1024        "Unexpected qualifiers");
1025    static_assert(
1026        std::is_same<
1027            int*, decltype(std::declval<absl::StatusOr<int>&>().operator->())>(),
1028        "Unexpected qualifiers");
1029    static_assert(
1030        std::is_same<
1031            const int*,
1032            decltype(std::declval<const absl::StatusOr<int>&&>().operator->())>(),
1033        "Unexpected qualifiers");
1034    static_assert(
1035        std::is_same<
1036            int*, decltype(std::declval<absl::StatusOr<int>&&>().operator->())>(),
1037        "Unexpected qualifiers");
1038  }
1039  TEST(StatusOr, OperatorArrow) {
1040    const absl::StatusOr<std::string> const_lvalue("hello");
1041    EXPECT_EQ(std::string("hello"), const_lvalue->c_str());
1042    absl::StatusOr<std::string> lvalue("hello");
1043    EXPECT_EQ(std::string("hello"), lvalue->c_str());
1044  }
1045  TEST(StatusOr, RValueStatus) {
1046    absl::StatusOr<int> so(absl::NotFoundError("taco"));
1047    const absl::Status s = std::move(so).status();
1048    EXPECT_EQ(s.code(), absl::StatusCode::kNotFound);
1049    EXPECT_EQ(s.message(), "taco");
1050    EXPECT_FALSE(so.ok());  
1051    EXPECT_FALSE(so.status().ok());
1052    EXPECT_EQ(so.status().code(), absl::StatusCode::kInternal);
1053    EXPECT_EQ(so.status().message(), "Status accessed after move.");
1054  }
1055  TEST(StatusOr, TestValue) {
1056    const int kI = 4;
1057    absl::StatusOr<int> thing(kI);
1058    EXPECT_EQ(kI, *thing);
1059  }
1060  TEST(StatusOr, TestValueConst) {
1061    const int kI = 4;
1062    const absl::StatusOr<int> thing(kI);
1063    EXPECT_EQ(kI, *thing);
1064  }
1065  TEST(StatusOr, TestPointerDefaultCtor) {
1066    absl::StatusOr<int*> thing;
1067    EXPECT_FALSE(thing.ok());
1068    EXPECT_EQ(thing.status().code(), absl::StatusCode::kUnknown);
1069  }
1070  TEST(StatusOr, TestPointerStatusCtor) {
1071    absl::StatusOr<int*> thing(absl::CancelledError());
1072    EXPECT_FALSE(thing.ok());
1073    EXPECT_EQ(thing.status().code(), absl::StatusCode::kCancelled);
1074  }
1075  TEST(StatusOr, TestPointerValueCtor) {
1076    const int kI = 4;
1077    {
1078      absl::StatusOr<const int*> so(&kI);
1079      EXPECT_TRUE(so.ok());
1080      EXPECT_OK(so.status());
1081      EXPECT_EQ(&kI, *so);
1082    }
1083    {
1084      absl::StatusOr<const int*> so(nullptr);
1085      EXPECT_TRUE(so.ok());
1086      EXPECT_OK(so.status());
1087      EXPECT_EQ(nullptr, *so);
1088    }
1089    {
1090      const int* const p = nullptr;
1091      absl::StatusOr<const int*> so(p);
1092      EXPECT_TRUE(so.ok());
1093      EXPECT_OK(so.status());
1094      EXPECT_EQ(nullptr, *so);
1095    }
1096  }
1097  TEST(StatusOr, TestPointerCopyCtorStatusOk) {
1098    const int kI = 0;
1099    absl::StatusOr<const int*> original(&kI);
1100    absl::StatusOr<const int*> copy(original);
1101    EXPECT_OK(copy.status());
1102    EXPECT_EQ(*original, *copy);
1103  }
1104  TEST(StatusOr, TestPointerCopyCtorStatusNotOk) {
1105    absl::StatusOr<int*> original(absl::CancelledError());
1106    absl::StatusOr<int*> copy(original);
1107    EXPECT_EQ(copy.status().code(), absl::StatusCode::kCancelled);
1108  }
1109  TEST(StatusOr, TestPointerCopyCtorStatusOKConverting) {
1110    Derived derived;
1111    absl::StatusOr<Derived*> original(&derived);
1112    absl::StatusOr<Base2*> copy(original);
1113    EXPECT_OK(copy.status());
1114    EXPECT_EQ(static_cast<const Base2*>(*original), *copy);
1115  }
1116  TEST(StatusOr, TestPointerCopyCtorStatusNotOkConverting) {
1117    absl::StatusOr<Derived*> original(absl::CancelledError());
1118    absl::StatusOr<Base2*> copy(original);
1119    EXPECT_EQ(copy.status().code(), absl::StatusCode::kCancelled);
1120  }
1121  TEST(StatusOr, TestPointerAssignmentStatusOk) {
1122    const int kI = 0;
1123    absl::StatusOr<const int*> source(&kI);
1124    absl::StatusOr<const int*> target;
1125    target = source;
1126    EXPECT_OK(target.status());
1127    EXPECT_EQ(*source, *target);
1128  }
1129  TEST(StatusOr, TestPointerAssignmentStatusNotOk) {
1130    absl::StatusOr<int*> source(absl::CancelledError());
1131    absl::StatusOr<int*> target;
1132    target = source;
1133    EXPECT_EQ(target.status().code(), absl::StatusCode::kCancelled);
1134  }
1135  TEST(StatusOr, TestPointerAssignmentStatusOKConverting) {
1136    Derived derived;
1137    absl::StatusOr<Derived*> source(&derived);
1138    absl::StatusOr<Base2*> target;
1139    target = source;
1140    EXPECT_OK(target.status());
1141    EXPECT_EQ(static_cast<const Base2*>(*source), *target);
1142  }
1143  TEST(StatusOr, TestPointerAssignmentStatusNotOkConverting) {
1144    absl::StatusOr<Derived*> source(absl::CancelledError());
1145    absl::StatusOr<Base2*> target;
1146    target = source;
1147    EXPECT_EQ(target.status(), source.status());
1148  }
1149  TEST(StatusOr, TestPointerStatus) {
1150    const int kI = 0;
1151    absl::StatusOr<const int*> good(&kI);
1152    EXPECT_TRUE(good.ok());
1153    absl::StatusOr<const int*> bad(absl::CancelledError());
1154    EXPECT_EQ(bad.status().code(), absl::StatusCode::kCancelled);
1155  }
1156  TEST(StatusOr, TestPointerValue) {
1157    const int kI = 0;
1158    absl::StatusOr<const int*> thing(&kI);
1159    EXPECT_EQ(&kI, *thing);
1160  }
1161  TEST(StatusOr, TestPointerValueConst) {
1162    const int kI = 0;
1163    const absl::StatusOr<const int*> thing(&kI);
1164    EXPECT_EQ(&kI, *thing);
1165  }
1166  TEST(StatusOr, StatusOrVectorOfUniquePointerCanReserveAndResize) {
1167    using EvilType = std::vector<std::unique_ptr<int>>;
1168    static_assert(std::is_copy_constructible<EvilType>::value, "");
1169    std::vector<::absl::StatusOr<EvilType>> v(5);
1170    v.reserve(v.capacity() + 10);
1171    v.resize(v.capacity() + 10);
1172  }
1173  TEST(StatusOr, ConstPayload) {
1174    absl::StatusOr<const int> a;
1175    absl::StatusOr<const int> b(a);
1176    EXPECT_FALSE(std::is_copy_assignable<absl::StatusOr<const int>>::value);
1177    absl::StatusOr<const int> c(std::move(a));
1178    EXPECT_FALSE(std::is_move_assignable<absl::StatusOr<const int>>::value);
1179  }
1180  TEST(StatusOr, MapToStatusOrUniquePtr) {
1181    using MapType = std::map<std::string, absl::StatusOr<std::unique_ptr<int>>>;
1182    MapType a;
1183    MapType b(std::move(a));
1184    a = std::move(b);
1185  }
1186  TEST(StatusOr, ValueOrOk) {
1187    const absl::StatusOr<int> status_or = 0;
1188    EXPECT_EQ(status_or.value_or(-1), 0);
1189  }
1190  TEST(StatusOr, ValueOrDefault) {
1191    const absl::StatusOr<int> status_or = absl::CancelledError();
1192    EXPECT_EQ(status_or.value_or(-1), -1);
1193  }
1194  TEST(StatusOr, MoveOnlyValueOrOk) {
1195    EXPECT_THAT(absl::StatusOr<std::unique_ptr<int>>(absl::make_unique<int>(0))
1196                    .value_or(absl::make_unique<int>(-1)),
1197                Pointee(0));
1198  }
1199  TEST(StatusOr, MoveOnlyValueOrDefault) {
1200    EXPECT_THAT(absl::StatusOr<std::unique_ptr<int>>(absl::CancelledError())
1201                    .value_or(absl::make_unique<int>(-1)),
1202                Pointee(-1));
1203  }
1204  static absl::StatusOr<int> MakeStatus() { return 100; }
1205  TEST(StatusOr, TestIgnoreError) { MakeStatus().IgnoreError(); }
1206  TEST(StatusOr, EqualityOperator) {
1207    constexpr size_t kNumCases = 4;
1208    std::array<absl::StatusOr<int>, kNumCases> group1 = {
1209        absl::StatusOr<int>(1), absl::StatusOr<int>(2),
1210        absl::StatusOr<int>(absl::InvalidArgumentError("msg")),
1211        absl::StatusOr<int>(absl::InternalError("msg"))};
1212    std::array<absl::StatusOr<int>, kNumCases> group2 = {
1213        absl::StatusOr<int>(1), absl::StatusOr<int>(2),
1214        absl::StatusOr<int>(absl::InvalidArgumentError("msg")),
1215        absl::StatusOr<int>(absl::InternalError("msg"))};
1216    for (size_t i = 0; i < kNumCases; ++i) {
1217      for (size_t j = 0; j < kNumCases; ++j) {
1218        if (i == j) {
1219          EXPECT_TRUE(group1[i] == group2[j]);
1220          EXPECT_FALSE(group1[i] != group2[j]);
1221        } else {
1222          EXPECT_FALSE(group1[i] == group2[j]);
1223          EXPECT_TRUE(group1[i] != group2[j]);
1224        }
1225      }
1226    }
1227  }
1228  struct MyType {
1229    bool operator==(const MyType&) const { return true; }
1230  };
1231  enum class ConvTraits { kNone = 0, kImplicit = 1, kExplicit = 2 };
1232  template <typename T, ConvTraits conv_traits = ConvTraits::kNone>
1233  struct StatusOrConversionBase {};
1234  template <typename T>
1235  struct StatusOrConversionBase<T, ConvTraits::kImplicit> {
1236    operator absl::StatusOr<T>() const& {  
1237      return absl::InvalidArgumentError("conversion to absl::StatusOr");
1238    }
1239    operator absl::StatusOr<T>() && {  
1240      return absl::InvalidArgumentError("conversion to absl::StatusOr");
1241    }
1242  };
1243  template <typename T>
1244  struct StatusOrConversionBase<T, ConvTraits::kExplicit> {
1245    explicit operator absl::StatusOr<T>() const& {
1246      return absl::InvalidArgumentError("conversion to absl::StatusOr");
1247    }
1248    explicit operator absl::StatusOr<T>() && {
1249      return absl::InvalidArgumentError("conversion to absl::StatusOr");
1250    }
1251  };
1252  template <typename T, ConvTraits conv_traits = ConvTraits::kNone>
1253  struct ConversionBase {};
1254  template <typename T>
1255  struct ConversionBase<T, ConvTraits::kImplicit> {
1256    operator T() const& { return t; }         
1257    operator T() && { return std::move(t); }  
1258    T t;
1259  };
1260  template <typename T>
1261  struct ConversionBase<T, ConvTraits::kExplicit> {
1262    explicit operator T() const& { return t; }
1263    explicit operator T() && { return std::move(t); }
1264    T t;
1265  };
1266  template <ConvTraits conv_traits = ConvTraits::kNone>
1267  struct StatusConversionBase {};
1268  template <>
1269  struct StatusConversionBase<ConvTraits::kImplicit> {
1270    operator absl::Status() const& {  
1271      return absl::InternalError("conversion to Status");
1272    }
1273    operator absl::Status() && {  
1274      return absl::InternalError("conversion to Status");
1275    }
1276  };
1277  template <>
1278  struct StatusConversionBase<ConvTraits::kExplicit> {
1279    explicit operator absl::Status() const& {  
1280      return absl::InternalError("conversion to Status");
1281    }
1282    explicit operator absl::Status() && {  
1283      return absl::InternalError("conversion to Status");
1284    }
1285  };
1286  static constexpr int kConvToStatus = 1;
1287  static constexpr int kConvToStatusOr = 2;
1288  static constexpr int kConvToT = 4;
1289  static constexpr int kConvExplicit = 8;
1290  constexpr ConvTraits GetConvTraits(int bit, int config) {
1291    return (config & bit) == 0
1292               ? ConvTraits::kNone
1293               : ((config & kConvExplicit) == 0 ? ConvTraits::kImplicit
1294                                                : ConvTraits::kExplicit);
1295  }
1296  template <typename T, int config>
1297  struct CustomType
1298      : StatusOrConversionBase<T, GetConvTraits(kConvToStatusOr, config)>,
1299        ConversionBase<T, GetConvTraits(kConvToT, config)>,
1300        StatusConversionBase<GetConvTraits(kConvToStatus, config)> {};
1301  struct ConvertibleToAnyStatusOr {
1302    template <typename T>
1303    operator absl::StatusOr<T>() const {  
1304      return absl::InvalidArgumentError("Conversion to absl::StatusOr");
1305    }
1306  };
1307  TEST(StatusOr, ConstructionFromT) {
1308    {
1309      ConvertibleToAnyStatusOr v;
1310      absl::StatusOr<ConvertibleToAnyStatusOr> statusor(v);
1311      EXPECT_TRUE(statusor.ok());
1312    }
1313    {
1314      ConvertibleToAnyStatusOr v;
1315      absl::StatusOr<ConvertibleToAnyStatusOr> statusor = v;
1316      EXPECT_TRUE(statusor.ok());
1317    }
1318    {
1319      CustomType<MyType, kConvToStatus | kConvExplicit> v;
1320      absl::StatusOr<CustomType<MyType, kConvToStatus | kConvExplicit>> statusor(
1321          v);
1322      EXPECT_TRUE(statusor.ok());
1323    }
1324    {
1325      CustomType<MyType, kConvToStatus | kConvExplicit> v;
1326      absl::StatusOr<CustomType<MyType, kConvToStatus | kConvExplicit>> statusor =
1327          v;
1328      EXPECT_TRUE(statusor.ok());
1329    }
1330  }
1331  TEST(StatusOr, ConstructionFromTypeConvertibleToT) {
1332    {
1333      CustomType<MyType, kConvToT | kConvExplicit> v;
1334      absl::StatusOr<MyType> statusor(v);
1335      EXPECT_TRUE(statusor.ok());
1336    }
1337    {
1338      CustomType<MyType, kConvToT> v;
1339      absl::StatusOr<MyType> statusor = v;
1340      EXPECT_TRUE(statusor.ok());
1341    }
1342  }
1343  TEST(StatusOr, ConstructionFromTypeWithConversionOperatorToStatusOrT) {
1344    {
1345      CustomType<MyType, kConvToStatusOr | kConvExplicit> v;
1346      absl::StatusOr<MyType> statusor(v);
1347      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1348    }
1349    {
1350      CustomType<MyType, kConvToT | kConvToStatusOr | kConvExplicit> v;
1351      absl::StatusOr<MyType> statusor(v);
1352      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1353    }
1354    {
1355      CustomType<MyType, kConvToStatusOr | kConvToStatus | kConvExplicit> v;
1356      absl::StatusOr<MyType> statusor(v);
1357      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1358    }
1359    {
1360      CustomType<MyType,
1361                 kConvToT | kConvToStatusOr | kConvToStatus | kConvExplicit>
1362          v;
1363      absl::StatusOr<MyType> statusor(v);
1364      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1365    }
1366    {
1367      CustomType<MyType, kConvToStatusOr> v;
1368      absl::StatusOr<MyType> statusor = v;
1369      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1370    }
1371    {
1372      CustomType<MyType, kConvToT | kConvToStatusOr> v;
1373      absl::StatusOr<MyType> statusor = v;
1374      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1375    }
1376    {
1377      CustomType<MyType, kConvToStatusOr | kConvToStatus> v;
1378      absl::StatusOr<MyType> statusor = v;
1379      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1380    }
1381    {
1382      CustomType<MyType, kConvToT | kConvToStatusOr | kConvToStatus> v;
1383      absl::StatusOr<MyType> statusor = v;
1384      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1385    }
1386  }
1387  TEST(StatusOr, ConstructionFromTypeConvertibleToStatus) {
1388    {
1389      CustomType<MyType, kConvToStatus | kConvExplicit> v;
1390      absl::StatusOr<MyType> statusor(v);
1391      EXPECT_FALSE(statusor.ok());
1392      EXPECT_EQ(statusor.status(), static_cast<absl::Status>(v));
1393    }
1394    {
1395      CustomType<MyType, kConvToT | kConvToStatus | kConvExplicit> v;
1396      absl::StatusOr<MyType> statusor(v);
1397      EXPECT_FALSE(statusor.ok());
1398      EXPECT_EQ(statusor.status(), static_cast<absl::Status>(v));
1399    }
1400    {
1401      CustomType<MyType, kConvToStatus> v;
1402      absl::StatusOr<MyType> statusor = v;
1403      EXPECT_FALSE(statusor.ok());
1404      EXPECT_EQ(statusor.status(), static_cast<absl::Status>(v));
1405    }
1406    {
1407      CustomType<MyType, kConvToT | kConvToStatus> v;
1408      absl::StatusOr<MyType> statusor = v;
1409      EXPECT_FALSE(statusor.ok());
1410      EXPECT_EQ(statusor.status(), static_cast<absl::Status>(v));
1411    }
1412  }
1413  TEST(StatusOr, AssignmentFromT) {
1414    {
1415      ConvertibleToAnyStatusOr v;
1416      absl::StatusOr<ConvertibleToAnyStatusOr> statusor;
1417      statusor = v;
1418      EXPECT_TRUE(statusor.ok());
1419    }
1420    {
1421      CustomType<MyType, kConvToStatus> v;
1422      absl::StatusOr<CustomType<MyType, kConvToStatus>> statusor;
1423      statusor = v;
1424      EXPECT_TRUE(statusor.ok());
1425    }
1426  }
1427  TEST(StatusOr, AssignmentFromTypeConvertibleToT) {
1428    {
1429      CustomType<MyType, kConvToT> v;
1430      absl::StatusOr<MyType> statusor;
1431      statusor = v;
1432      EXPECT_TRUE(statusor.ok());
1433    }
1434  }
1435  TEST(StatusOr, AssignmentFromTypeWithConversionOperatortoStatusOrT) {
1436    {
1437      CustomType<MyType, kConvToStatusOr> v;
1438      absl::StatusOr<MyType> statusor;
1439      statusor = v;
1440      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1441    }
1442    {
1443      CustomType<MyType, kConvToT | kConvToStatusOr> v;
1444      absl::StatusOr<MyType> statusor;
1445      statusor = v;
1446      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1447    }
1448    {
1449      CustomType<MyType, kConvToStatusOr | kConvToStatus> v;
1450      absl::StatusOr<MyType> statusor;
1451      statusor = v;
1452      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1453    }
1454    {
1455      CustomType<MyType, kConvToT | kConvToStatusOr | kConvToStatus> v;
1456      absl::StatusOr<MyType> statusor;
1457      statusor = v;
1458      EXPECT_EQ(statusor, v.operator absl::StatusOr<MyType>());
1459    }
1460  }
1461  TEST(StatusOr, AssignmentFromTypeConvertibleToStatus) {
1462    {
1463      CustomType<MyType, kConvToStatus> v;
1464      absl::StatusOr<MyType> statusor;
1465      statusor = v;
1466      EXPECT_FALSE(statusor.ok());
1467      EXPECT_EQ(statusor.status(), static_cast<absl::Status>(v));
1468    }
1469    {
1470      CustomType<MyType, kConvToT | kConvToStatus> v;
1471      absl::StatusOr<MyType> statusor;
1472      statusor = v;
1473      EXPECT_FALSE(statusor.ok());
1474      EXPECT_EQ(statusor.status(), static_cast<absl::Status>(v));
1475    }
1476  }
1477  TEST(StatusOr, StatusAssignmentFromStatusError) {
1478    absl::StatusOr<absl::Status> statusor;
1479    statusor.AssignStatus(absl::CancelledError());
1480    EXPECT_FALSE(statusor.ok());
1481    EXPECT_EQ(statusor.status(), absl::CancelledError());
1482  }
1483  #if GTEST_HAS_DEATH_TEST
1484  TEST(StatusOr, StatusAssignmentFromStatusOk) {
1485    EXPECT_DEBUG_DEATH(
1486        {
1487          absl::StatusOr<absl::Status> statusor;
1488          statusor.AssignStatus(absl::OkStatus());
1489          EXPECT_FALSE(statusor.ok());
1490          EXPECT_EQ(statusor.status().code(), absl::StatusCode::kInternal);
1491        },
1492        "An OK status is not a valid constructor argument to StatusOr<T>");
1493  }
1494  #endif
1495  TEST(StatusOr, StatusAssignmentFromTypeConvertibleToStatus) {
1496    CustomType<MyType, kConvToStatus> v;
1497    absl::StatusOr<MyType> statusor;
1498    statusor.AssignStatus(v);
1499    EXPECT_FALSE(statusor.ok());
1500    EXPECT_EQ(statusor.status(), static_cast<absl::Status>(v));
1501  }
1502  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-utility_test.cc</h3>
            <pre><code>1  #include "absl/utility/utility.h"
2  #include <memory>
3  #include <sstream>
4  #include <string>
5  #include <tuple>
6  #include <type_traits>
7  #include <utility>
8  #include <vector>
9  #include "gmock/gmock.h"
10  #include "gtest/gtest.h"
11  #include "absl/base/attributes.h"
12  #include "absl/memory/memory.h"
13  #include "absl/strings/str_cat.h"
14  namespace {
15  #ifdef _MSC_VER
16  #pragma warning(push)
17  #pragma warning(disable : 4503)  
18  #pragma warning(disable : 4101)  
19  #endif                           
20  using ::testing::ElementsAre;
21  using ::testing::Pointee;
22  using ::testing::StaticAssertTypeEq;
23  TEST(IntegerSequenceTest, ValueType) {
24    StaticAssertTypeEq<int, absl::integer_sequence<int>::value_type>();
25    StaticAssertTypeEq<char, absl::integer_sequence<char>::value_type>();
26  }
27  TEST(IntegerSequenceTest, Size) {
28    EXPECT_EQ(0, (absl::integer_sequence<int>::size()));
29    EXPECT_EQ(1, (absl::integer_sequence<int, 0>::size()));
30    EXPECT_EQ(1, (absl::integer_sequence<int, 1>::size()));
31    EXPECT_EQ(2, (absl::integer_sequence<int, 1, 2>::size()));
32    EXPECT_EQ(3, (absl::integer_sequence<int, 0, 1, 2>::size()));
33    EXPECT_EQ(3, (absl::integer_sequence<int, -123, 123, 456>::size()));
34    constexpr size_t sz = absl::integer_sequence<int, 0, 1>::size();
35    EXPECT_EQ(2, sz);
36  }
37  TEST(IntegerSequenceTest, MakeIndexSequence) {
38    StaticAssertTypeEq<absl::index_sequence<>, absl::make_index_sequence<0>>();
39    StaticAssertTypeEq<absl::index_sequence<0>, absl::make_index_sequence<1>>();
40    StaticAssertTypeEq<absl::index_sequence<0, 1>,
41                       absl::make_index_sequence<2>>();
42    StaticAssertTypeEq<absl::index_sequence<0, 1, 2>,
43                       absl::make_index_sequence<3>>();
44  }
45  TEST(IntegerSequenceTest, MakeIntegerSequence) {
46    StaticAssertTypeEq<absl::integer_sequence<int>,
47                       absl::make_integer_sequence<int, 0>>();
48    StaticAssertTypeEq<absl::integer_sequence<int, 0>,
49                       absl::make_integer_sequence<int, 1>>();
50    StaticAssertTypeEq<absl::integer_sequence<int, 0, 1>,
51                       absl::make_integer_sequence<int, 2>>();
52    StaticAssertTypeEq<absl::integer_sequence<int, 0, 1, 2>,
53                       absl::make_integer_sequence<int, 3>>();
54  }
55  template <typename... Ts>
56  class Counter {};
57  template <size_t... Is>
58  void CountAll(absl::index_sequence<Is...>) {
59    ABSL_ATTRIBUTE_UNUSED Counter<absl::make_index_sequence<Is>...> seq;
60  }
61  TEST(IntegerSequenceTest, MakeIndexSequencePerformance) {
62    ABSL_ATTRIBUTE_UNUSED absl::make_index_sequence<(1 << 16) - 1> seq;
63    CountAll(absl::make_index_sequence<(1 << 8) - 1>());
64  }
65  template <typename F, typename Tup, size_t... Is>
66  auto ApplyFromTupleImpl(F f, const Tup& tup, absl::index_sequence<Is...>)
67      -> decltype(f(std::get<Is>(tup)...)) {
68    return f(std::get<Is>(tup)...);
69  }
70  template <typename Tup>
71  using TupIdxSeq = absl::make_index_sequence<std::tuple_size<Tup>::value>;
72  template <typename F, typename Tup>
73  auto ApplyFromTuple(F f, const Tup& tup)
74      -> decltype(ApplyFromTupleImpl(f, tup, TupIdxSeq<Tup>{})) {
75    return ApplyFromTupleImpl(f, tup, TupIdxSeq<Tup>{});
76  }
77  template <typename T>
78  std::string Fmt(const T& x) {
79    std::ostringstream os;
80    os << x;
81    return os.str();
82  }
83  struct PoorStrCat {
84    template <typename... Args>
85    std::string operator()(const Args&... args) const {
86      std::string r;
87      for (const auto& e : {Fmt(args)...}) r += e;
88      return r;
89    }
90  };
91  template <typename Tup, size_t... Is>
92  std::vector<std::string> TupStringVecImpl(const Tup& tup,
93                                            absl::index_sequence<Is...>) {
94    return {Fmt(std::get<Is>(tup))...};
95  }
96  template <typename... Ts>
97  std::vector<std::string> TupStringVec(const std::tuple<Ts...>& tup) {
98    return TupStringVecImpl(tup, absl::index_sequence_for<Ts...>());
99  }
100  TEST(MakeIndexSequenceTest, ApplyFromTupleExample) {
101    PoorStrCat f{};
102    EXPECT_EQ("12abc3.14", f(12, "abc", 3.14));
103    EXPECT_EQ("12abc3.14", ApplyFromTuple(f, std::make_tuple(12, "abc", 3.14)));
104  }
105  TEST(IndexSequenceForTest, Basic) {
106    StaticAssertTypeEq<absl::index_sequence<>, absl::index_sequence_for<>>();
107    StaticAssertTypeEq<absl::index_sequence<0>, absl::index_sequence_for<int>>();
108    StaticAssertTypeEq<absl::index_sequence<0, 1, 2, 3>,
109                       absl::index_sequence_for<int, void, char, int>>();
110  }
111  TEST(IndexSequenceForTest, Example) {
112    EXPECT_THAT(TupStringVec(std::make_tuple(12, "abc", 3.14)),
113                ElementsAre("12", "abc", "3.14"));
114  }
115  int Function(int a, int b) { return a - b; }
116  int Sink(std::unique_ptr<int> p) { return *p; }
117  std::unique_ptr<int> Factory(int n) { return absl::make_unique<int>(n); }
118  void NoOp() {}
119  struct ConstFunctor {
120    int operator()(int a, int b) const { return a - b; }
121  };
122  struct MutableFunctor {
123    int operator()(int a, int b) { return a - b; }
124  };
125  struct EphemeralFunctor {
126    EphemeralFunctor() {}
127    EphemeralFunctor(const EphemeralFunctor&) {}
128    EphemeralFunctor(EphemeralFunctor&&) {}
129    int operator()(int a, int b) && { return a - b; }
130  };
131  struct OverloadedFunctor {
132    OverloadedFunctor() {}
133    OverloadedFunctor(const OverloadedFunctor&) {}
134    OverloadedFunctor(OverloadedFunctor&&) {}
135    template <typename... Args>
136    std::string operator()(const Args&... args) & {
137      return absl::StrCat("&", args...);
138    }
139    template <typename... Args>
140    std::string operator()(const Args&... args) const& {
141      return absl::StrCat("const&", args...);
142    }
143    template <typename... Args>
144    std::string operator()(const Args&... args) && {
145      return absl::StrCat("&&", args...);
146    }
147  };
148  struct Class {
149    int Method(int a, int b) { return a - b; }
150    int ConstMethod(int a, int b) const { return a - b; }
151    int member;
152  };
153  struct FlipFlop {
154    int ConstMethod() const { return member; }
155    FlipFlop operator*() const { return {-member}; }
156    int member;
157  };
158  TEST(ApplyTest, Function) {
159    EXPECT_EQ(1, absl::apply(Function, std::make_tuple(3, 2)));
160    EXPECT_EQ(1, absl::apply(&Function, std::make_tuple(3, 2)));
161  }
162  TEST(ApplyTest, NonCopyableArgument) {
163    EXPECT_EQ(42, absl::apply(Sink, std::make_tuple(absl::make_unique<int>(42))));
164  }
165  TEST(ApplyTest, NonCopyableResult) {
166    EXPECT_THAT(absl::apply(Factory, std::make_tuple(42)), Pointee(42));
167  }
168  TEST(ApplyTest, VoidResult) { absl::apply(NoOp, std::tuple<>()); }
169  TEST(ApplyTest, ConstFunctor) {
170    EXPECT_EQ(1, absl::apply(ConstFunctor(), std::make_tuple(3, 2)));
171  }
172  TEST(ApplyTest, MutableFunctor) {
173    MutableFunctor f;
174    EXPECT_EQ(1, absl::apply(f, std::make_tuple(3, 2)));
175    EXPECT_EQ(1, absl::apply(MutableFunctor(), std::make_tuple(3, 2)));
176  }
177  TEST(ApplyTest, EphemeralFunctor) {
178    EphemeralFunctor f;
179    EXPECT_EQ(1, absl::apply(std::move(f), std::make_tuple(3, 2)));
180    EXPECT_EQ(1, absl::apply(EphemeralFunctor(), std::make_tuple(3, 2)));
181  }
182  TEST(ApplyTest, OverloadedFunctor) {
183    OverloadedFunctor f;
184    const OverloadedFunctor& cf = f;
185    EXPECT_EQ("&", absl::apply(f, std::tuple<>{}));
186    EXPECT_EQ("& 42", absl::apply(f, std::make_tuple(" 42")));
187    EXPECT_EQ("const&", absl::apply(cf, std::tuple<>{}));
188    EXPECT_EQ("const& 42", absl::apply(cf, std::make_tuple(" 42")));
189    EXPECT_EQ("&&", absl::apply(std::move(f), std::tuple<>{}));
190    OverloadedFunctor f2;
191    EXPECT_EQ("&& 42", absl::apply(std::move(f2), std::make_tuple(" 42")));
192  }
193  TEST(ApplyTest, ReferenceWrapper) {
194    ConstFunctor cf;
195    MutableFunctor mf;
196    EXPECT_EQ(1, absl::apply(std::cref(cf), std::make_tuple(3, 2)));
197    EXPECT_EQ(1, absl::apply(std::ref(cf), std::make_tuple(3, 2)));
198    EXPECT_EQ(1, absl::apply(std::ref(mf), std::make_tuple(3, 2)));
199  }
200  TEST(ApplyTest, MemberFunction) {
201    std::unique_ptr<Class> p(new Class);
202    std::unique_ptr<const Class> cp(new Class);
203    EXPECT_EQ(
204        1, absl::apply(&Class::Method,
205                       std::tuple<std::unique_ptr<Class>&, int, int>(p, 3, 2)));
206    EXPECT_EQ(1, absl::apply(&Class::Method,
207                             std::tuple<Class*, int, int>(p.get(), 3, 2)));
208    EXPECT_EQ(
209        1, absl::apply(&Class::Method, std::tuple<Class&, int, int>(*p, 3, 2)));
210    EXPECT_EQ(
211        1, absl::apply(&Class::ConstMethod,
212                       std::tuple<std::unique_ptr<Class>&, int, int>(p, 3, 2)));
213    EXPECT_EQ(1, absl::apply(&Class::ConstMethod,
214                             std::tuple<Class*, int, int>(p.get(), 3, 2)));
215    EXPECT_EQ(1, absl::apply(&Class::ConstMethod,
216                             std::tuple<Class&, int, int>(*p, 3, 2)));
217    EXPECT_EQ(1, absl::apply(&Class::ConstMethod,
218                             std::tuple<std::unique_ptr<const Class>&, int, int>(
219                                 cp, 3, 2)));
220    EXPECT_EQ(1, absl::apply(&Class::ConstMethod,
221                             std::tuple<const Class*, int, int>(cp.get(), 3, 2)));
222    EXPECT_EQ(1, absl::apply(&Class::ConstMethod,
223                             std::tuple<const Class&, int, int>(*cp, 3, 2)));
224    EXPECT_EQ(1, absl::apply(&Class::Method,
225                             std::make_tuple(absl::make_unique<Class>(), 3, 2)));
226    EXPECT_EQ(1, absl::apply(&Class::ConstMethod,
227                             std::make_tuple(absl::make_unique<Class>(), 3, 2)));
228    EXPECT_EQ(
229        1, absl::apply(&Class::ConstMethod,
230                       std::make_tuple(absl::make_unique<const Class>(), 3, 2)));
231  }
232  TEST(ApplyTest, DataMember) {
233    std::unique_ptr<Class> p(new Class{42});
234    std::unique_ptr<const Class> cp(new Class{42});
235    EXPECT_EQ(
236        42, absl::apply(&Class::member, std::tuple<std::unique_ptr<Class>&>(p)));
237    EXPECT_EQ(42, absl::apply(&Class::member, std::tuple<Class&>(*p)));
238    EXPECT_EQ(42, absl::apply(&Class::member, std::tuple<Class*>(p.get())));
239    absl::apply(&Class::member, std::tuple<std::unique_ptr<Class>&>(p)) = 42;
240    absl::apply(&Class::member, std::tuple<Class*>(p.get())) = 42;
241    absl::apply(&Class::member, std::tuple<Class&>(*p)) = 42;
242    EXPECT_EQ(42, absl::apply(&Class::member,
243                              std::tuple<std::unique_ptr<const Class>&>(cp)));
244    EXPECT_EQ(42, absl::apply(&Class::member, std::tuple<const Class&>(*cp)));
245    EXPECT_EQ(42,
246              absl::apply(&Class::member, std::tuple<const Class*>(cp.get())));
247  }
248  TEST(ApplyTest, FlipFlop) {
249    FlipFlop obj = {42};
250    EXPECT_EQ(42, absl::apply(&FlipFlop::ConstMethod, std::make_tuple(obj)));
251    EXPECT_EQ(42, absl::apply(&FlipFlop::member, std::make_tuple(obj)));
252  }
253  TEST(ExchangeTest, MoveOnly) {
254    auto a = Factory(1);
255    EXPECT_EQ(1, *a);
256    auto b = absl::exchange(a, Factory(2));
257    EXPECT_EQ(2, *a);
<span onclick='openModal()' class='match'>258    EXPECT_EQ(1, *b);
259  }
260  TEST(MakeFromTupleTest, String) {
261    EXPECT_EQ(
</span>262        absl::make_from_tuple<std::string>(std::make_tuple("hello world", 5)),
263        "hello");
264  }
265  TEST(MakeFromTupleTest, MoveOnlyParameter) {
266    struct S {
267      S(std::unique_ptr<int> n, std::unique_ptr<int> m) : value(*n + *m) {}
268      int value = 0;
269    };
270    auto tup =
271        std::make_tuple(absl::make_unique<int>(3), absl::make_unique<int>(4));
272    auto s = absl::make_from_tuple<S>(std::move(tup));
273    EXPECT_EQ(s.value, 7);
274  }
275  TEST(MakeFromTupleTest, NoParameters) {
276    struct S {
277      S() : value(1) {}
278      int value = 2;
279    };
280    EXPECT_EQ(absl::make_from_tuple<S>(std::make_tuple()).value, 1);
281  }
282  TEST(MakeFromTupleTest, Pair) {
283    EXPECT_EQ(
284        (absl::make_from_tuple<std::pair<bool, int>>(std::make_tuple(true, 17))),
285        std::make_pair(true, 17));
286  }
287  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-statusor_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-utility_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>190    EXPECT_EQ(0, *ptr);
191  }
192  TEST(StatusOr, TestMoveOnlyInitializationFromTemporaryByValueOrDie) {
193    std::unique_ptr<int> ptr(*ReturnUniquePtr());
</pre></code></div>
                <div class="column column_space"><pre><code>258    EXPECT_EQ(1, *b);
259  }
260  TEST(MakeFromTupleTest, String) {
261    EXPECT_EQ(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    