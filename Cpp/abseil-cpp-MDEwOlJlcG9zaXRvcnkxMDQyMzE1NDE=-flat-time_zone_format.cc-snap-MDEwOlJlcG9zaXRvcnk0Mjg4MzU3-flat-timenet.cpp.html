
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.469593378913278%, Tokens: 11</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</h3>
            <pre><code>1  #if !defined(HAS_STRPTIME)
2  #if !defined(_MSC_VER) && !defined(__MINGW32__)
3  #define HAS_STRPTIME 1  
4  #endif
5  #endif
6  #if defined(HAS_STRPTIME) && HAS_STRPTIME
7  #if !defined(_XOPEN_SOURCE) && !defined(__OpenBSD__)
8  #define _XOPEN_SOURCE  
9  #endif
10  #endif
11  #include "absl/base/config.h"
12  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
13  #include <time.h>
14  #include <cctype>
15  #include <chrono>
16  #include <cstddef>
17  #include <cstdint>
18  #include <cstring>
19  #include <ctime>
20  #include <limits>
21  #include <string>
22  #include <vector>
23  #if !HAS_STRPTIME
24  #include <iomanip>
25  #include <sstream>
26  #endif
27  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
28  #include "time_zone_if.h"
29  namespace absl {
30  ABSL_NAMESPACE_BEGIN
31  namespace time_internal {
32  namespace cctz {
33  namespace detail {
34  namespace {
35  #if !HAS_STRPTIME
36  char* strptime(const char* s, const char* fmt, std::tm* tm) {
37    std::istringstream input(s);
38    input >> std::get_time(tm, fmt);
39    if (input.fail()) return nullptr;
40    return const_cast<char*>(s) +
41           (input.eof() ? strlen(s) : static_cast<std::size_t>(input.tellg()));
42  }
43  #endif
44  int ToTmWday(weekday wd) {
45    switch (wd) {
46      case weekday::sunday:
47        return 0;
48      case weekday::monday:
49        return 1;
50      case weekday::tuesday:
51        return 2;
52      case weekday::wednesday:
53        return 3;
54      case weekday::thursday:
55        return 4;
56      case weekday::friday:
57        return 5;
58      case weekday::saturday:
59        return 6;
60    }
61    return 0; &bsol;*NOTREACHED*/
62  }
63  weekday FromTmWday(int tm_wday) {
64    switch (tm_wday) {
65      case 0:
66        return weekday::sunday;
67      case 1:
68        return weekday::monday;
69      case 2:
70        return weekday::tuesday;
71      case 3:
72        return weekday::wednesday;
73      case 4:
74        return weekday::thursday;
75      case 5:
76        return weekday::friday;
77      case 6:
78        return weekday::saturday;
79    }
80    return weekday::sunday; &bsol;*NOTREACHED*/
81  }
82  std::tm ToTM(const time_zone::absolute_lookup& al) {
83    std::tm tm{};
84    tm.tm_sec = al.cs.second();
85    tm.tm_min = al.cs.minute();
86    tm.tm_hour = al.cs.hour();
87    tm.tm_mday = al.cs.day();
88    tm.tm_mon = al.cs.month() - 1;
89    if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
90      tm.tm_year = std::numeric_limits<int>::min();
91    } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
92      tm.tm_year = std::numeric_limits<int>::max();
93    } else {
94      tm.tm_year = static_cast<int>(al.cs.year() - 1900);
95    }
96    tm.tm_wday = ToTmWday(get_weekday(al.cs));
97    tm.tm_yday = get_yearday(al.cs) - 1;
98    tm.tm_isdst = al.is_dst ? 1 : 0;
99    return tm;
100  }
101  int ToWeek(const civil_day& cd, weekday week_start) {
102    const civil_day d(cd.year() % 400, cd.month(), cd.day());
103    return static_cast<int>((d - prev_weekday(civil_year(d), week_start)) / 7);
104  }
105  const char kDigits[] = "0123456789";
106  char* Format64(char* ep, int width, std::int_fast64_t v) {
107    bool neg = false;
108    if (v < 0) {
109      --width;
110      neg = true;
111      if (v == std::numeric_limits<std::int_fast64_t>::min()) {
112        std::int_fast64_t last_digit = -(v % 10);
113        v /= 10;
114        if (last_digit < 0) {
115          ++v;
116          last_digit += 10;
117        }
118        --width;
119        *--ep = kDigits[last_digit];
120      }
121      v = -v;
122    }
123    do {
124      --width;
125      *--ep = kDigits[v % 10];
126    } while (v /= 10);
127    while (--width >= 0) *--ep = '0';  
128    if (neg) *--ep = '-';
129    return ep;
130  }
131  char* Format02d(char* ep, int v) {
132    *--ep = kDigits[v % 10];
133    *--ep = kDigits[(v / 10) % 10];
134    return ep;
135  }
136  char* FormatOffset(char* ep, int offset, const char* mode) {
137    char sign = '+';
138    if (offset < 0) {
139      offset = -offset;  
140      sign = '-';
141    }
142    const int seconds = offset % 60;
143    const int minutes = (offset /= 60) % 60;
144    const int hours = offset /= 60;
145    const char sep = mode[0];
146    const bool ext = (sep != '\0' && mode[1] == '*');
147    const bool ccc = (ext && mode[2] == ':');
148    if (ext && (!ccc || seconds != 0)) {
149      ep = Format02d(ep, seconds);
150      *--ep = sep;
151    } else {
152      if (hours == 0 && minutes == 0) sign = '+';
153    }
154    if (!ccc || minutes != 0 || seconds != 0) {
155      ep = Format02d(ep, minutes);
156      if (sep != '\0') *--ep = sep;
157    }
158    ep = Format02d(ep, hours);
159    *--ep = sign;
160    return ep;
161  }
162  void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
163    for (std::size_t i = 2; i != 32; i *= 2) {
164      std::size_t buf_size = fmt.size() * i;
165      std::vector<char> buf(buf_size);
166      if (std::size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
167        out->append(&buf[0], len);
168        return;
169      }
170    }
171  }
172  template <typename T>
173  const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
174    if (dp != nullptr) {
175      const T kmin = std::numeric_limits<T>::min();
176      bool erange = false;
177      bool neg = false;
178      T value = 0;
179      if (*dp == '-') {
180        neg = true;
181        if (width <= 0 || --width != 0) {
182          ++dp;
183        } else {
184          dp = nullptr;  
185        }
186      }
187      if (const char* const bp = dp) {
188        while (const char* cp = strchr(kDigits, *dp)) {
189          int d = static_cast<int>(cp - kDigits);
190          if (d >= 10) break;
191          if (value < kmin / 10) {
192            erange = true;
193            break;
194          }
195          value *= 10;
196          if (value < kmin + d) {
197            erange = true;
198            break;
199          }
200          value -= d;
201          dp += 1;
202          if (width > 0 && --width == 0) break;
203        }
204        if (dp != bp && !erange && (neg || value != kmin)) {
205          if (!neg || value != 0) {
206            if (!neg) value = -value;  
207            if (min <= value && value <= max) {
208              *vp = value;
209            } else {
210              dp = nullptr;
211            }
212          } else {
213            dp = nullptr;
214          }
215        } else {
216          dp = nullptr;
217        }
218      }
219    }
220    return dp;
221  }
222  const int kDigits10_64 = 18;
223  const std::int_fast64_t kExp10[kDigits10_64 + 1] = {
224      1,
225      10,
226      100,
227      1000,
228      10000,
229      100000,
230      1000000,
231      10000000,
232      100000000,
233      1000000000,
234      10000000000,
235      100000000000,
236      1000000000000,
237      10000000000000,
238      100000000000000,
239      1000000000000000,
240      10000000000000000,
241      100000000000000000,
242      1000000000000000000,
243  };
244  }  
245  std::string format(const std::string& format, const time_point<seconds>& tp,
246                     const detail::femtoseconds& fs, const time_zone& tz) {
247    std::string result;
248    result.reserve(format.size());  
249    const time_zone::absolute_lookup al = tz.lookup(tp);
250    const std::tm tm = ToTM(al);
251    char buf[3 + kDigits10_64];  
252    char* const ep = buf + sizeof(buf);
253    char* bp;  
254    const char* pending = format.c_str();  
255    const char* cur = pending;
256    const char* end = pending + format.length();
257    while (cur != end) {  
258      const char* start = cur;
259      while (cur != end && *cur != '%') ++cur;
260      if (cur != start && pending == start) {
261        result.append(pending, static_cast<std::size_t>(cur - pending));
262        pending = start = cur;
263      }
264      const char* percent = cur;
265      while (cur != end && *cur == '%') ++cur;
266      if (cur != start && pending == start) {
267        std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;
268        result.append(pending, escaped);
269        pending += escaped * 2;
270        if (pending != cur && cur == end) {
271          result.push_back(*pending++);
272        }
273      }
274      if (cur == end || (cur - percent) % 2 == 0) continue;
275      if (strchr("YmdeUuWwHMSzZs%", *cur)) {
276        if (cur - 1 != pending) {
277          FormatTM(&result, std::string(pending, cur - 1), tm);
278        }
279        switch (*cur) {
280          case 'Y':
281            bp = Format64(ep, 0, al.cs.year());
282            result.append(bp, static_cast<std::size_t>(ep - bp));
283            break;
284          case 'm':
285            bp = Format02d(ep, al.cs.month());
286            result.append(bp, static_cast<std::size_t>(ep - bp));
287            break;
288          case 'd':
289          case 'e':
290            bp = Format02d(ep, al.cs.day());
291            if (*cur == 'e' && *bp == '0') *bp = ' ';  
292            result.append(bp, static_cast<std::size_t>(ep - bp));
293            break;
294          case 'U':
295            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::sunday));
296            result.append(bp, static_cast<std::size_t>(ep - bp));
297            break;
298          case 'u':
299            bp = Format64(ep, 0, tm.tm_wday ? tm.tm_wday : 7);
300            result.append(bp, static_cast<std::size_t>(ep - bp));
301            break;
302          case 'W':
303            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::monday));
304            result.append(bp, static_cast<std::size_t>(ep - bp));
305            break;
306          case 'w':
307            bp = Format64(ep, 0, tm.tm_wday);
308            result.append(bp, static_cast<std::size_t>(ep - bp));
309            break;
310          case 'H':
311            bp = Format02d(ep, al.cs.hour());
312            result.append(bp, static_cast<std::size_t>(ep - bp));
313            break;
314          case 'M':
315            bp = Format02d(ep, al.cs.minute());
316            result.append(bp, static_cast<std::size_t>(ep - bp));
317            break;
318          case 'S':
319            bp = Format02d(ep, al.cs.second());
320            result.append(bp, static_cast<std::size_t>(ep - bp));
321            break;
322          case 'z':
323            bp = FormatOffset(ep, al.offset, "");
324            result.append(bp, static_cast<std::size_t>(ep - bp));
325            break;
326          case 'Z':
327            result.append(al.abbr);
328            break;
329          case 's':
330            bp = Format64(ep, 0, ToUnixSeconds(tp));
331            result.append(bp, static_cast<std::size_t>(ep - bp));
332            break;
333          case '%':
334            result.push_back('%');
335            break;
336        }
337        pending = ++cur;
338        continue;
339      }
340      if (*cur == ':' && cur + 1 != end) {
341        if (*(cur + 1) == 'z') {
342          if (cur - 1 != pending) {
343            FormatTM(&result, std::string(pending, cur - 1), tm);
344          }
345          bp = FormatOffset(ep, al.offset, ":");
346          result.append(bp, static_cast<std::size_t>(ep - bp));
347          pending = cur += 2;
348          continue;
349        }
350        if (*(cur + 1) == ':' && cur + 2 != end) {
351          if (*(cur + 2) == 'z') {
352            if (cur - 1 != pending) {
353              FormatTM(&result, std::string(pending, cur - 1), tm);
354            }
355            bp = FormatOffset(ep, al.offset, ":*");
356            result.append(bp, static_cast<std::size_t>(ep - bp));
357            pending = cur += 3;
358            continue;
359          }
360          if (*(cur + 2) == ':' && cur + 3 != end) {
361            if (*(cur + 3) == 'z') {
362              if (cur - 1 != pending) {
363                FormatTM(&result, std::string(pending, cur - 1), tm);
364              }
365              bp = FormatOffset(ep, al.offset, ":*:");
366              result.append(bp, static_cast<std::size_t>(ep - bp));
367              pending = cur += 4;
368              continue;
369            }
370          }
371        }
372      }
373      if (*cur != 'E' || ++cur == end) continue;
374      if (*cur == 'T') {
375        if (cur - 2 != pending) {
376          FormatTM(&result, std::string(pending, cur - 2), tm);
377        }
378        result.append("T");
379        pending = ++cur;
380      } else if (*cur == 'z') {
381        if (cur - 2 != pending) {
382          FormatTM(&result, std::string(pending, cur - 2), tm);
383        }
384        bp = FormatOffset(ep, al.offset, ":");
385        result.append(bp, static_cast<std::size_t>(ep - bp));
386        pending = ++cur;
387      } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {
388        if (cur - 2 != pending) {
389          FormatTM(&result, std::string(pending, cur - 2), tm);
390        }
391        bp = FormatOffset(ep, al.offset, ":*");
392        result.append(bp, static_cast<std::size_t>(ep - bp));
393        pending = cur += 2;
394      } else if (*cur == '*' && cur + 1 != end &&
395                 (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
396        if (cur - 2 != pending) {
397          FormatTM(&result, std::string(pending, cur - 2), tm);
398        }
399        char* cp = ep;
400        bp = Format64(cp, 15, fs.count());
401        while (cp != bp && cp[-1] == '0') --cp;
402        switch (*(cur + 1)) {
403          case 'S':
404            if (cp != bp) *--bp = '.';
405            bp = Format02d(bp, al.cs.second());
406            break;
407          case 'f':
408            if (cp == bp) *--bp = '0';
409            break;
410        }
411        result.append(bp, static_cast<std::size_t>(cp - bp));
412        pending = cur += 2;
413      } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
414        if (cur - 2 != pending) {
415          FormatTM(&result, std::string(pending, cur - 2), tm);
416        }
417        bp = Format64(ep, 4, al.cs.year());
418        result.append(bp, static_cast<std::size_t>(ep - bp));
419        pending = cur += 2;
420      } else if (std::isdigit(*cur)) {
421        int n = 0;
422        if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
423          if (*np == 'S' || *np == 'f') {
424            if (cur - 2 != pending) {
425              FormatTM(&result, std::string(pending, cur - 2), tm);
426            }
427            bp = ep;
428            if (n > 0) {
429              if (n > kDigits10_64) n = kDigits10_64;
430              bp = Format64(bp, n,
431                            (n > 15) ? fs.count() * kExp10[n - 15]
432                                     : fs.count() / kExp10[15 - n]);
433              if (*np == 'S') *--bp = '.';
434            }
435            if (*np == 'S') bp = Format02d(bp, al.cs.second());
436            result.append(bp, static_cast<std::size_t>(ep - bp));
437            pending = cur = ++np;
438          }
439        }
440      }
441    }
442    if (end != pending) {
443      FormatTM(&result, std::string(pending, end), tm);
444    }
445    return result;
446  }
447  namespace {
448  const char* ParseOffset(const char* dp, const char* mode, int* offset) {
449    if (dp != nullptr) {
450      const char first = *dp++;
451      if (first == '+' || first == '-') {
452        char sep = mode[0];
453        int hours = 0;
454        int minutes = 0;
455        int seconds = 0;
456        const char* ap = ParseInt(dp, 2, 0, 23, &hours);
457        if (ap != nullptr && ap - dp == 2) {
458          dp = ap;
459          if (sep != '\0' && *ap == sep) ++ap;
460          const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
461          if (bp != nullptr && bp - ap == 2) {
462            dp = bp;
463            if (sep != '\0' && *bp == sep) ++bp;
464            const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
465            if (cp != nullptr && cp - bp == 2) dp = cp;
466          }
467          *offset = ((hours * 60 + minutes) * 60) + seconds;
468          if (first == '-') *offset = -*offset;
469        } else {
470          dp = nullptr;
471        }
472      } else if (first == 'Z' || first == 'z') {  
473        *offset = 0;
<span onclick='openModal()' class='match'>474      } else {
475        dp = nullptr;
476      }
477    }
478    return dp;
479  }
480  const char* ParseZone(const char* dp, std::string* zone) {
</span>481    zone->clear();
482    if (dp != nullptr) {
483      while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
484      if (zone->empty()) dp = nullptr;
485    }
486    return dp;
487  }
488  const char* ParseSubSeconds(const char* dp, detail::femtoseconds* subseconds) {
489    if (dp != nullptr) {
490      std::int_fast64_t v = 0;
491      std::int_fast64_t exp = 0;
492      const char* const bp = dp;
493      while (const char* cp = strchr(kDigits, *dp)) {
494        int d = static_cast<int>(cp - kDigits);
495        if (d >= 10) break;
496        if (exp < 15) {
497          exp += 1;
498          v *= 10;
499          v += d;
500        }
501        ++dp;
502      }
503      if (dp != bp) {
504        v *= kExp10[15 - exp];
505        *subseconds = detail::femtoseconds(v);
506      } else {
507        dp = nullptr;
508      }
509    }
510    return dp;
511  }
512  const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
513    if (dp != nullptr) {
514      dp = strptime(dp, fmt, tm);
515    }
516    return dp;
517  }
518  bool FromWeek(int week_num, weekday week_start, year_t* year, std::tm* tm) {
519    const civil_year y(*year % 400);
520    civil_day cd = prev_weekday(y, week_start);  
521    cd = next_weekday(cd - 1, FromTmWday(tm->tm_wday)) + (week_num * 7);
522    if (const year_t shift = cd.year() - y.year()) {
523      if (shift > 0) {
524        if (*year > std::numeric_limits<year_t>::max() - shift) return false;
525      } else {
526        if (*year < std::numeric_limits<year_t>::min() - shift) return false;
527      }
528      *year += shift;
529    }
530    tm->tm_mon = cd.month() - 1;
531    tm->tm_mday = cd.day();
532    return true;
533  }
534  }  
535  bool parse(const std::string& format, const std::string& input,
536             const time_zone& tz, time_point<seconds>* sec,
537             detail::femtoseconds* fs, std::string* err) {
538    const char* data = input.c_str();  
539    while (std::isspace(*data)) ++data;
540    const year_t kyearmax = std::numeric_limits<year_t>::max();
541    const year_t kyearmin = std::numeric_limits<year_t>::min();
542    bool saw_year = false;
543    year_t year = 1970;
544    std::tm tm{};
545    tm.tm_year = 1970 - 1900;
546    tm.tm_mon = 1 - 1;  
547    tm.tm_mday = 1;
548    tm.tm_hour = 0;
549    tm.tm_min = 0;
550    tm.tm_sec = 0;
551    tm.tm_wday = 4;  
552    tm.tm_yday = 0;
553    tm.tm_isdst = 0;
554    auto subseconds = detail::femtoseconds::zero();
555    bool saw_offset = false;
556    int offset = 0;  
557    std::string zone = "UTC";
558    const char* fmt = format.c_str();  
559    bool twelve_hour = false;
560    bool afternoon = false;
561    int week_num = -1;
562    weekday week_start = weekday::sunday;
563    bool saw_percent_s = false;
564    std::int_fast64_t percent_s = 0;
565    while (data != nullptr && *fmt != '\0') {
566      if (std::isspace(*fmt)) {
567        while (std::isspace(*data)) ++data;
568        while (std::isspace(*++fmt)) continue;
569        continue;
570      }
571      if (*fmt != '%') {
572        if (*data == *fmt) {
573          ++data;
574          ++fmt;
575        } else {
576          data = nullptr;
577        }
578        continue;
579      }
580      const char* percent = fmt;
581      if (*++fmt == '\0') {
582        data = nullptr;
583        continue;
584      }
585      switch (*fmt++) {
586        case 'Y':
587          data = ParseInt(data, 0, kyearmin, kyearmax, &year);
588          if (data != nullptr) saw_year = true;
589          continue;
590        case 'm':
591          data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
592          if (data != nullptr) tm.tm_mon -= 1;
593          week_num = -1;
594          continue;
595        case 'd':
596        case 'e':
597          data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
598          week_num = -1;
599          continue;
600        case 'U':
601          data = ParseInt(data, 0, 0, 53, &week_num);
602          week_start = weekday::sunday;
603          continue;
604        case 'W':
605          data = ParseInt(data, 0, 0, 53, &week_num);
606          week_start = weekday::monday;
607          continue;
608        case 'u':
609          data = ParseInt(data, 0, 1, 7, &tm.tm_wday);
610          if (data != nullptr) tm.tm_wday %= 7;
611          continue;
612        case 'w':
613          data = ParseInt(data, 0, 0, 6, &tm.tm_wday);
614          continue;
615        case 'H':
616          data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
617          twelve_hour = false;
618          continue;
619        case 'M':
620          data = ParseInt(data, 2, 0, 59, &tm.tm_min);
621          continue;
622        case 'S':
623          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
624          continue;
625        case 'I':
626        case 'l':
627        case 'r':  
628          twelve_hour = true;
629          break;
630        case 'R':  
631        case 'T':  
632        case 'c':  
633        case 'X':  
634          twelve_hour = false;
635          break;
636        case 'z':
637          data = ParseOffset(data, "", &offset);
638          if (data != nullptr) saw_offset = true;
639          continue;
640        case 'Z':  
641          data = ParseZone(data, &zone);
642          continue;
643        case 's':
644          data =
645              ParseInt(data, 0, std::numeric_limits<std::int_fast64_t>::min(),
646                       std::numeric_limits<std::int_fast64_t>::max(), &percent_s);
647          if (data != nullptr) saw_percent_s = true;
648          continue;
649        case ':':
650          if (fmt[0] == 'z' ||
651              (fmt[0] == ':' &&
652               (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {
653            data = ParseOffset(data, ":", &offset);
654            if (data != nullptr) saw_offset = true;
655            fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;
656            continue;
657          }
658          break;
659        case '%':
660          data = (*data == '%' ? data + 1 : nullptr);
661          continue;
662        case 'E':
663          if (fmt[0] == 'T') {
664            if (*data == 'T' || *data == 't') {
665              ++data;
666              ++fmt;
667            } else {
668              data = nullptr;
669            }
670            continue;
671          }
672          if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {
673            data = ParseOffset(data, ":", &offset);
674            if (data != nullptr) saw_offset = true;
675            fmt += (fmt[0] == 'z') ? 1 : 2;
676            continue;
677          }
678          if (fmt[0] == '*' && fmt[1] == 'S') {
679            data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
680            if (data != nullptr && *data == '.') {
681              data = ParseSubSeconds(data + 1, &subseconds);
682            }
683            fmt += 2;
684            continue;
685          }
686          if (fmt[0] == '*' && fmt[1] == 'f') {
687            if (data != nullptr && std::isdigit(*data)) {
688              data = ParseSubSeconds(data, &subseconds);
689            }
690            fmt += 2;
691            continue;
692          }
693          if (fmt[0] == '4' && fmt[1] == 'Y') {
694            const char* bp = data;
695            data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);
696            if (data != nullptr) {
697              if (data - bp == 4) {
698                saw_year = true;
699              } else {
700                data = nullptr;  
701              }
702            }
703            fmt += 2;
704            continue;
705          }
706          if (std::isdigit(*fmt)) {
707            int n = 0;  
708            if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
709              if (*np == 'S') {
710                data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
711                if (data != nullptr && *data == '.') {
712                  data = ParseSubSeconds(data + 1, &subseconds);
713                }
714                fmt = ++np;
715                continue;
716              }
717              if (*np == 'f') {
718                if (data != nullptr && std::isdigit(*data)) {
719                  data = ParseSubSeconds(data, &subseconds);
720                }
721                fmt = ++np;
722                continue;
723              }
724            }
725          }
726          if (*fmt == 'c') twelve_hour = false;  
727          if (*fmt == 'X') twelve_hour = false;  
728          if (*fmt != '\0') ++fmt;
729          break;
730        case 'O':
731          if (*fmt == 'H') twelve_hour = false;
732          if (*fmt == 'I') twelve_hour = true;
733          if (*fmt != '\0') ++fmt;
734          break;
735      }
736      const char* orig_data = data;
737      std::string spec(percent, static_cast<std::size_t>(fmt - percent));
738      data = ParseTM(data, spec.c_str(), &tm);
739      if (spec == "%p" && data != nullptr) {
740        std::string test_input = "1";
741        test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));
742        const char* test_data = test_input.c_str();
743        std::tm tmp{};
744        ParseTM(test_data, "%I%p", &tmp);
745        afternoon = (tmp.tm_hour == 13);
746      }
747    }
748    if (twelve_hour && afternoon && tm.tm_hour < 12) {
749      tm.tm_hour += 12;
750    }
751    if (data == nullptr) {
752      if (err != nullptr) *err = "Failed to parse input";
753      return false;
754    }
755    while (std::isspace(*data)) ++data;
756    if (*data != '\0') {
757      if (err != nullptr) *err = "Illegal trailing data in input string";
758      return false;
759    }
760    if (saw_percent_s) {
761      *sec = FromUnixSeconds(percent_s);
762      *fs = detail::femtoseconds::zero();
763      return true;
764    }
765    time_zone ptz = saw_offset ? utc_time_zone() : tz;
766    if (tm.tm_sec == 60) {
767      tm.tm_sec -= 1;
768      offset -= 1;
769      subseconds = detail::femtoseconds::zero();
770    }
771    if (!saw_year) {
772      year = year_t{tm.tm_year};
773      if (year > kyearmax - 1900) {
774        if (err != nullptr) *err = "Out-of-range year";
775        return false;
776      }
777      year += 1900;
778    }
779    if (week_num != -1) {
780      if (!FromWeek(week_num, week_start, &year, &tm)) {
781        if (err != nullptr) *err = "Out-of-range field";
782        return false;
783      }
784    }
785    const int month = tm.tm_mon + 1;
786    civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
787    if (cs.month() != month || cs.day() != tm.tm_mday) {
788      if (err != nullptr) *err = "Out-of-range field";
789      return false;
790    }
791    if ((offset < 0 && cs > civil_second::max() + offset) ||
792        (offset > 0 && cs < civil_second::min() + offset)) {
793      if (err != nullptr) *err = "Out-of-range field";
794      return false;
795    }
796    cs -= offset;
797    const auto tp = ptz.lookup(cs).pre;
798    if (tp == time_point<seconds>::max()) {
799      const auto al = ptz.lookup(time_point<seconds>::max());
800      if (cs > al.cs) {
801        if (err != nullptr) *err = "Out-of-range field";
802        return false;
803      }
804    }
805    if (tp == time_point<seconds>::min()) {
806      const auto al = ptz.lookup(time_point<seconds>::min());
807      if (cs < al.cs) {
808        if (err != nullptr) *err = "Out-of-range field";
809        return false;
810      }
811    }
812    *sec = tp;
813    *fs = subseconds;
814    return true;
815  }
816  }  
817  }  
818  }  
819  ABSL_NAMESPACE_END
820  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</h3>
            <pre><code>1  TTimeNet& TTimeNet::operator = (const TTimeNet& TimeNet) {
2    if (this != &TimeNet) {
3      TNet::operator=(TimeNet);
4    }
5    return *this;
6  }
7  PTimeNet TTimeNet::GetSubGraph(const TIntV& NIdV) const {
8    PTimeNet NewNetPt = TTimeNet::New();
9    TTimeNet& NewNet = *NewNetPt;
10    NewNet.Reserve(NIdV.Len(), -1);
11    int node, edge;
12    TNodeI NI;
13    for (node = 0; node < NIdV.Len(); node++) {
14      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
15    }
16    for (node = 0; node < NIdV.Len(); node++) {
17      NI = GetNI(NIdV[node]);
18      const int SrcNId = NI.GetId();
19      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
20        const int OutNId = NI.GetOutNId(edge);
21        if (NewNet.IsNode(OutNId)) {
22          NewNet.AddEdge(SrcNId, OutNId); }
23      }
24    }
25    NewNet.Defrag();
26    return NewNetPt;
27  }
28  PTimeNENet TTimeNet::GetTimeNENet() const {
29    TIntV NIdV;  GetNIdByTm(NIdV);
30    PTimeNENet OutNet = TTimeNENet::New(GetNodes(), GetEdges());
31    for (int i = 0; i < NIdV.Len(); i++) {
32      const int Src = NIdV[i];
33      const TTimeNet::TNodeI NI = GetNI(Src);
34      const TSecTm SrcTm = NI.GetDat();
35      if (! OutNet->IsNode(Src)) { OutNet->AddNode(Src, SrcTm); }
36      for (int e = 0; e < NI.GetOutDeg(); e++) {
37        if (! OutNet->IsNode(NI.GetOutNId(e))) { OutNet->AddNode(NI.GetOutNId(e), SrcTm); }
38        OutNet->AddEdge(Src, NI.GetOutNId(e), -1, SrcTm);
39      }
40    }
41    return OutNet;
42  }
43  void TTimeNet::GetNIdByTm(TIntV& NIdV) const {
44    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
45    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
46      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
47    TmToNIdV.Sort();
48    NIdV.Gen(GetNodes(), 0);
49    for (int i = 0; i < TmToNIdV.Len(); i++) {
50      NIdV.Add(TmToNIdV[i].Dat); }
51  }
52  void TTimeNet::GetTmBuckets(const TTmUnit& TmUnit, TTmBucketV& TmBucketV) const {
53    THash<TInt, TIntV> TmIdToNIdVH;
54    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
55      const int TmId = NodeI().Round(TmUnit);
56      if (! TmIdToNIdVH.IsKey(TmId)) TmIdToNIdVH.AddKey(TmId);
57      TmIdToNIdVH.GetDat(TmId).Add(NodeI.GetId());
58    }
59    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
60    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
61    TmIdNIdVV.Sort();
62    TmBucketV.Gen(TmIdNIdVV.Len());
63    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
64      TTmBucket& Bucket = TmBucketV[i];
65      Bucket.BegTm = TmIdNIdVV[i].Val1;
66      Bucket.NIdV = TmIdNIdVV[i].Val2;
67    }
68  }
69  void TTimeNet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
70    TIntV NIdV;
71    GetNIdByTm(NIdV);
72    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
73    for (int i = 0; i < NIdV.Len(); i++) {
74      const int b = i/NodesPerBucket;
75      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
76      TmBucketV[b].NIdV.Add(NIdV[i]);
77    }
78  }
79  PGStatVec TTimeNet::TimeGrowth(const TTmUnit& TmUnit, const TFSet& TakeStat, const TSecTm& StartTm) const {
80    PGStatVec GrowthStat = new TGStatVec(TmUnit, TakeStat);
81    TTmBucketV TmBucketV;
82    GetTmBuckets(TmUnit, TmBucketV);
83    TIntV NodeIdV;
84    TExeTm ExeTm;
85    for (int t = 0; t < TmBucketV.Len(); t++) {
86      NodeIdV.AddV(TmBucketV[t].NIdV); 
87      printf("\n=== %d/%d] %s (%d nodes)\n", t+1, TmBucketV.Len(),
88        TmBucketV[t].BegTm.GetStr().CStr(), NodeIdV.Len());  ExeTm.Tick();
89      if (TmBucketV[t].BegTm < StartTm) continue;
90      PNGraph PreGraph = TSnap::ConvertSubGraph<PNGraph>(PTimeNet((TTimeNet*)this), NodeIdV); 
91      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
92    }
93    return GrowthStat;
94  }
95  void TTimeNet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
96                             const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc, const bool& AlsoRewire) const {
97    const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
98    TTmBucketV TmBucketV;
99    GetTmBuckets(TmUnit, TmBucketV);
100    TIntV NodeIdV;
101    TExeTm ExeTm, Run1Tm;
102    TFltTrV TmDiamV, NdsDiamV;
103    TFltTrV RwTmDiamV, RwNdsDiamV;
104    for (int t = 0; t < TmBucketV.Len(); t++) {
105      NodeIdV.AddV(TmBucketV[t].NIdV); 
106      printf("\n*** %d/%d] at %s (%d nodes)\n", t+1, TmBucketV.Len(),
107        TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), NodeIdV.Len());  ExeTm.Tick();
108      if (TmBucketV[t].BegTm < StartTm) continue;
109      PUNGraph PreGraph = TSnap::ConvertSubGraph<PUNGraph>(PTimeNet((TTimeNet*)this), NodeIdV);
110      { TMom Mom;
111      for (int r = 0; r < NDiamRuns; r++) {
112        printf("%d...", r+1);  Run1Tm.Tick();
113        const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph) : PreGraph);
114        Mom.Add(EffDiam);  printf("[%s]\r", Run1Tm.GetTmStr());
115      }
116      Mom.Def();
117      TmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
118      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
119      NdsDiamV.Sort();
120      printf("  [%s]          \n", ExeTm.GetTmStr()); }
121      if (AlsoRewire) {
122        TIntV DegSeqV(PreGraph->GetNodes(), 0);
123        for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) { DegSeqV.Add(NI.GetDeg()); }
124        PUNGraph RwGraph = TSnap::GenConfModel(DegSeqV, TInt::Rnd);
125        printf("Configuration model: (%d, %d) --> (%d, %d)\n", PreGraph->GetNodes(), PreGraph->GetEdges(), RwGraph->GetNodes(), RwGraph->GetEdges());
126        TMom Mom;
127        for (int r = 0; r < NDiamRuns; r++) {
128          printf("  diam run %d...", r+1);  Run1Tm.Tick();
129          const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph):PreGraph);
130          Mom.Add(EffDiam);  printf(" current run [%s]\n", Run1Tm.GetTmStr());
131        }
132        Mom.Def();
133        RwTmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
134        RwNdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
135        RwNdsDiamV.Sort();
136        printf("done with diameter. Total time [%s] \n", ExeTm.GetTmStr());
137      }
138      { TGnuPlot GnuPlot("diamEff-T."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
139      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), WccStr+"Effective Diameter");
140      GnuPlot.AddErrBar(TmDiamV, "True", "");
141      if (! RwTmDiamV.Empty()) { GnuPlot.AddErrBar(RwTmDiamV, "Rewired", "");}
142      GnuPlot.SavePng(); }
143      { TGnuPlot GnuPlot("diamEff-N."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
144      GnuPlot.SetXYLabel("NODES", WccStr+"Effective Diameter");
145      GnuPlot.AddErrBar(NdsDiamV, "True", "");
146      if (! RwNdsDiamV.Empty()) { GnuPlot.AddErrBar(RwNdsDiamV, "Rewired", "");}
147      GnuPlot.SavePng(); }
148    }
149  }
150  void TTimeNet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
151                                 const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam) const {
152    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
153      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
154    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
155      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
156    const int NDiamRuns = 10;
157    const int NSamples = 100;
158    PUNGraph FullGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
159    if (DelPreTmEdges.IsDef()) {
160      int NDelNodes = 0, NDelEdges = 0;
161      printf("Deleting pre-%s node out-links\n", DelPreTmEdges.GetStr().CStr());
162      for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
163        if (NodeI() < DelPreTmEdges) {
164          const int NodeId = NodeI.GetId();
165          for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
166            FullGraph->DelEdge(NodeId, NodeI.GetOutNId(edge)); }
167          NDelEdges += NodeI.GetOutDeg();  NDelNodes++;
168        }
169      }
170      printf("  Deleted %d nodes out-edges (%d edges total).\n", NDelNodes, NDelEdges);
171      FullGraph->Defrag(true);
172    }
173    PGStatVec GrowthStat = TGStatVec::New(TmUnit);
174    TFltV PreDiamSDev, PreEffDiamSDev, WccDiamSDev, WccEffDiamSDev;
175    TIntV NodeIdV;
176    TExeTm ExeTm;
177    TTmBucketV TmBucketV;
178    GetTmBuckets(TmUnit, TmBucketV);
179    for (int t = 0; t < TmBucketV.Len(); t++) {
180      printf("\nGraph: %s (%d / %d) [%s]\n", TmBucketV[t].BegTm.GetTmStr().CStr(),
181        t+1, TmBucketV.Len(), TExeTm::GetCurTm());
182      NodeIdV.AddV(TmBucketV[t].NIdV); 
183      if (TmBucketV[t].BegTm < PostTmDiam) { continue; }
184      const PUNGraph PreGraph = TSnap::GetSubGraph(FullGraph, NodeIdV, true);
185      const PUNGraph WccGraph = TSnap::GetMxWcc(PreGraph);
186      TIntV PostYearNIdV, WccPostYearNIdV;
187      for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) {
188        if (GetNDat(NI.GetId()) >= PostTmDiam) {
189          PostYearNIdV.Add(NI.GetId());
190          if (WccGraph->IsNode(NI.GetId())) { WccPostYearNIdV.Add(NI.GetId()); }
191        }
192      }
193      TMom PreDiamMom, PreEffDiamMom, WccDiamMom, WccEffDiamMom;
194      int FullDiam; double EffDiam;
195      for (int r = 0; r < NDiamRuns; r++) {
196        if (! PostYearNIdV.Empty()) {
197          TSnap::GetBfsEffDiam(PreGraph, NSamples, PostYearNIdV, false, EffDiam, FullDiam);
198          PreDiamMom.Add(FullDiam);  PreEffDiamMom.Add(EffDiam);
199        }
200        if (! WccPostYearNIdV.Empty()) {
201          TSnap::GetBfsEffDiam(WccGraph, NSamples, WccPostYearNIdV, false, EffDiam, FullDiam);
202          WccDiamMom.Add(FullDiam);  WccEffDiamMom.Add(EffDiam);
203        }
204        printf("  diam: %d  [%s]  \r", r+1, ExeTm.GetTmStr());  ExeTm.Tick();
205      }
206      PreDiamMom.Def();  PreEffDiamMom.Def();
207      WccDiamMom.Def();  WccEffDiamMom.Def();
208      PGStat GraphStatPt = GrowthStat->Add(TmBucketV[t].BegTm);
209      TGStat& GS = *GraphStatPt;
210      GS.TakeBasicStat(PreGraph, false);
211      GS.TakeBasicStat(WccGraph, true);
212      GS.SetVal(gsvFullDiam, PreDiamMom.GetMean()); 
213      GS.SetVal(gsvEffDiam, PreEffDiamMom.GetMean());
214      GS.SetVal(gsvFullWccDiam, WccDiamMom.GetMean());
215      GS.SetVal(gsvEffWccDiam, WccEffDiamMom.GetMean());
216      GS.SetVal(gsvFullDiamDev, PreDiamMom.GetSDev()); 
217      GS.SetVal(gsvEffDiamDev, PreEffDiamMom.GetSDev());
218      GS.SetVal(gsvFullWccDiamDev, WccDiamMom.GetSDev());
219      GS.SetVal(gsvEffWccDiamDev, WccEffDiamMom.GetSDev());
220      { TFOut FOut("growth."+FNmPref+".gStatVec");  GrowthStat->Save(FOut); }
221      GrowthStat->SaveTxt(FNmPref, TStr::Fmt("%s. MISSING PAST DIAMETER\nDelPreEdges\t%s\nPostYearDiam\t%s\n",
222        Desc.CStr(), DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr()));
223    }
224  }
225  void TTimeNet::PlotCCfOverTm(const TStr& FNmPref, TStr Desc, const TTmUnit& TmUnit, const int& NodesBucket) const {
226    if (Desc.Empty()) { Desc = FNmPref; }
227    TTimeNet::TTmBucketV TmBucketV;
228    TStr XLbl;
229    if (TmUnit == tmuNodes) {
230      XLbl = "Number of nodes (time)";
231      IAssert(NodesBucket > 0);
232      GetNodeBuckets(NodesBucket, TmBucketV); }
233    else {
234      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
235      GetTmBuckets(TmUnit, TmBucketV);
236    }
237    TIntV NodeIdV;
238    TFltPrV DegToCCfV, CcfV, OpClV, OpV;
239    TVec<TTuple<TFlt, 4> > OpenClsV;
240    TTuple<TFlt, 4> Tuple;
241    TExeTm ExeTm;
242    int XVal = 0;
243    printf("Clustering coefficient over time:\n  %d edges, %d edges per bucket, %d buckets \n", GetEdges(), 100000, TmBucketV.Len());
244    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
245    for (int t = 0; t < TmBucketV.Len(); t++) {
246      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
247      NodeIdV.AddV(TmBucketV[t].NIdV); 
248      int64 Open=0, Close=0;
249      const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);
250      const double CCf = TSnap::GetClustCf(Graph, DegToCCfV, Open, Close);
251      if (TmUnit == tmuNodes) { XVal = Graph->GetNodes(); }
252      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
253      CcfV.Add(TFltPr(XVal, CCf));
254      double FltOpen = static_cast<double>(Open);
255      double FltClose = static_cast<double>(Close);
256      OpClV.Add(TFltPr(XVal, (Open+Close==0 ? 0.0 : FltClose/(FltOpen+FltClose))));
257      OpV.Add(TFltPr(XVal, (Open==0 ? 0.0 : FltClose/FltOpen)));
258      Tuple[0]=Graph->GetNodes();
259      Tuple[1]=Graph->GetEdges();
260      Tuple[2]=FltClose;  Tuple[3]=FltOpen;
261      OpenClsV.Add(Tuple);
262      printf(" %s", ExeTm.GetStr());
263      TGnuPlot::PlotValV(DegToCCfV, TStr::Fmt("ccfAt%02dtm.%s", t+1, FNmPref.CStr()),
264        TStr::Fmt("%s. At time %d. Clustering Coefficient. G(%d,%d)", Desc.CStr(), t+1, Graph->GetNodes(), Graph->GetEdges()),
265        "Degree", "Clustering coefficient", gpsLog10XY, false);
266    }
267    TGnuPlot::PlotValV(CcfV, "ccfOverTm."+FNmPref, Desc+". Average Clustering Coefficient", XLbl, "Average clustering coefficient", gpsAuto, false);
268    TGnuPlot::PlotValV(OpClV, "ClsOpnTr1."+FNmPref, Desc+". Close/(Open+Closed) triads", XLbl, "Close / (Open+Closed) triads", gpsAuto, false);
269    TGnuPlot::PlotValV(OpV, "ClsOpnTr2."+FNmPref, Desc+". Close/Open triads", XLbl, "Close / Open triads", gpsAuto, false);
270    TGnuPlot::SaveTs(OpenClsV, "ClsOpnTr."+FNmPref+".tab", TStr::Fmt("#%s\n#Nodes\tEdges\tClosed\tOpenTriads", Desc.CStr()));
271    printf("\n");
272  }
273  void TTimeNet::PlotMedianDegOverTm(const TStr& FNmPref, const TTmUnit& TmUnit, const int& NodesPerBucket) const {
274    TTimeNet::TTmBucketV TmBucketV;
275    TStr XLbl;
276    if (TmUnit == tmuNodes) {
277      XLbl = "Number of nodes (time)";  IAssert(NodesPerBucket > 0);
278      GetNodeBuckets(NodesPerBucket, TmBucketV); }
279    else {
280      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
281      GetTmBuckets(TmUnit, TmBucketV); }
282    printf("\n\n%s\nMedian degree over time:\n  %d edges, %d edges per bucket, %d buckets \n", FNmPref.CStr(), GetEdges(), NodesPerBucket, TmBucketV.Len());
283    TFltPrV MedDegV, MedInDegV, MedOutDegV;
284    TIntV NodeIdV;
285    int XVal;
286    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
287    PNGraph NGraph = TSnap::ConvertGraph<PNGraph>(PTimeNet((TTimeNet*)this));
288    FILE  *F = fopen(("gStat-"+FNmPref+".tab").CStr(), "wt");
289    fprintf(F, "UndirNodes\tUndirEdges\tUndirNonZNodes\tMedianDeg\tMeanDeg\tDirNodes\tDirEdges\tDirNonzNodes\tMedInDeg\tMedOutDeg\tMeanInDeg\tMeanOutDeg\n");
290    for (int t = 0; t < TmBucketV.Len(); t++) {
291      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
292      NodeIdV.AddV(TmBucketV[t].NIdV); 
293      if (TmUnit == tmuNodes) { XVal = NodeIdV.Len(); }
294      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
295      { const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);  TMom Mom;
296      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) { if (NI.GetOutDeg()>0) { Mom.Add(NI.GetOutDeg());} }
297      Mom.Def();  MedDegV.Add(TFltPr(XVal, Mom.GetMedian()));
298      fprintf(F, "%d\t%d\t%d\t%f\t%f", Graph->GetNodes(), Graph->GetEdges(), TSnap::CntNonZNodes(Graph), (float)Mom.GetMedian(), (float)Mom.GetMean()); }
299      { const PNGraph Graph = TSnap::GetSubGraph<PNGraph>(NGraph, NodeIdV); TMom MomOut, MomIn;
300      for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
301        if (NI.GetOutDeg()>0) { MomOut.Add(NI.GetOutDeg()); }
302        if (NI.GetInDeg()>0) { MomIn.Add(NI.GetInDeg()); } }
303      MomOut.Def();  MedOutDegV.Add(TFltPr(XVal, MomOut.GetMedian()));
304      MomIn.Def();  MedInDegV.Add(TFltPr(XVal, MomIn.GetMedian()));
305      fprintf(F, "\t%d\t%d\t%d\t%f\t%f\t%f\t%f\n", Graph->GetNodes(), Graph->GetEdges(), (int)TSnap::CntNonZNodes(Graph), (float)MomIn.GetMedian(), (float)MomOut.GetMedian(), (float)MomIn.GetMean(), (float)MomOut.GetMean()); }
306    }
307    fclose(F);
308    TGnuPlot::PlotValV(MedDegV, "medDeg."+FNmPref, FNmPref+" Median degree", TTmInfo::GetTmUnitStr(TmUnit), "Median degree");
309    TGnuPlot::PlotValV(MedOutDegV, "medOutDeg."+FNmPref, FNmPref+" Median OUT degree", TTmInfo::GetTmUnitStr(TmUnit), "Median OUT degree");
310    TGnuPlot::PlotValV(MedInDegV, "medInDeg."+FNmPref, FNmPref+" Median IN degree", TTmInfo::GetTmUnitStr(TmUnit), "Median IN degree");
311  }
312  PTimeNet TTimeNet::LoadBipartite(const TStr& InFNm) {
313    PTimeNet TimeNetPt = TTimeNet::New();
314    TTimeNet& TimeNet = *TimeNetPt;
315    PSs Ss = TSs::LoadTxt(ssfTabSep, InFNm.CStr());
316    TIntH Set1IdH; 
317    TStrV StrTimeV;
318    for (int y = 0; y < Ss->GetYLen(); y++) {
319      if (Ss->At(0, y)[0] == '#') continue; 
320      if (Ss->GetXLen(y) < 3) continue;     
321      const int& SrcId = Ss->At(0, y).GetInt();
322      IAssert(! Set1IdH.IsKey(SrcId));
323      IAssert(! TimeNet.IsNode(SrcId));
324      Set1IdH.AddKey(SrcId);
325      Ss->At(1, y).SplitOnAllCh('-', StrTimeV);
326      const int Year = StrTimeV[0].GetInt();
327      const int Month = StrTimeV[1].GetInt();
328      const int Day = StrTimeV[2].GetInt();
329      const TSecTm NodeTm(Year, Month, Day);
330      TimeNet.AddNode(SrcId, NodeTm);
331      for (int dst = 2; dst < Ss->GetXLen(y); dst++) {
332        const int DstId = Ss->At(dst, y).GetInt();
333        IAssert(! Set1IdH.IsKey(DstId));
334        if (! TimeNet.IsNode(DstId)) { TimeNet.AddNode(DstId, NodeTm); }
335        else { TimeNet.GetNDat(DstId) = TMath::Mn(NodeTm, TimeNet.GetNDat(DstId)); }
336        if (! TimeNet.IsEdge(SrcId, DstId)) { TimeNet.AddEdge(SrcId, DstId); }
337      }
338    }
339    TimeNet.Defrag();
340    printf("Bipartate graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
341    printf("  Bipartate sets: %d nodes --> %d nodes\n", TSnap::CntInDegNodes(TimeNetPt, 0),
342      TSnap::CntOutDegNodes(TimeNetPt, 0));
343    return TimeNetPt;
344  }
345  PTimeNet TTimeNet::LoadArxiv(const TStr& PaperFNm, const TStr& CiteFNm) {
346    TExeTm ExeTm;
347    PTimeNet TimeNetPt = TTimeNet::New();
348    TTimeNet& TimeNet = *TimeNetPt;
349    printf("Arxiv citation graph (paper publication year)...\n");
350    char Line [1024];
351    FILE *PprF = fopen(PaperFNm.CStr(), "rt");
352    TStr StrId, StrTime;
353    TStrV StrV, StrTimeV;
354    int N = 0, DuplicateNode = 0;
355    while (! feof(PprF)) {
356      Line[0] = 0;
357      fgets(Line, 1024, PprF);
358      if (strlen(Line) == 0 || Line[0] == '#') continue;
359      Line[strlen(Line)-1] = 0; 
360      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
361      StrId = StrV[0];  StrTime = StrV[1];  IAssert(!StrId.Empty() && !StrTime.Empty());
362      StrTime.SplitOnAllCh('-', StrTimeV);  IAssert(StrTimeV.Len() == 3);
363      const int NodeId = StrId.GetInt();
364      if (! TimeNet.IsNode(NodeId)) {
365        const int Year = StrTimeV[0].GetInt();
366        const int Month = StrTimeV[1].GetInt();
367        const int Day = StrTimeV[2].GetInt();
368        TimeNet.AddNode(NodeId, TSecTm(Year, Month, Day));
369      } else { DuplicateNode++; }
370      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
371    }
372    printf("\r  %d nodes read. %d duplicate nodes. %s\n", N, DuplicateNode, ExeTm.GetTmStr());
373    fclose(PprF);
374    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
375    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
376    N = 0;  ExeTm.Tick();
377    printf("Loading Arxiv citations...\n");
378    TIntPrV EdgeV;
379    THash<TInt, TSecTm> NIdToTimeH;
380    while (! feof(CiteF)) {
381      Line[0] = 0;
382      fgets(Line, 1024, CiteF);
383      if (strlen(Line) == 0 || Line[0] == '#') continue;
384      Line[strlen(Line)-1] = 0; 
385      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
386      const int SrcNId = StrV[0].GetInt();
387      const int DstNId = StrV[1].GetInt();
388      EdgeV.Add(TIntPr(SrcNId, DstNId));
389      if (! TimeNet.IsNode(DstNId) && TimeNet.IsNode(SrcNId)) {
390        const TSecTm& SrcTm = TimeNet.GetNDat(SrcNId);
391        if (! NIdToTimeH.IsKey(DstNId)) {
392          NIdToTimeH.AddDat(DstNId, SrcTm);
393          NewDstIds++;
394        }
395        else if (NIdToTimeH.GetDat(DstNId) < SrcTm) {
396          NIdToTimeH.GetDat(DstNId) = SrcTm; }
397      }
398      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
399    }
400    fclose(CiteF);
401    for (int i = 0; i < NIdToTimeH.Len(); i++) {
402      TimeNet.AddNode(NIdToTimeH.GetKey(i), NIdToTimeH[i]);
403    }
404    for (int i = 0; i < EdgeV.Len(); i++) {
405      const int SrcNId = EdgeV[i].Val1;
406      const int DstNId = EdgeV[i].Val2;
407      if (TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
408        if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
409        else { DupLinks++; }
410      } else {
411        if (! TimeNet.IsNode(SrcNId)) {
412          NewSrcIds++;
413          if (! TimeNet.IsNode(DstNId)) { NewCits++; }
414        }
415      }
416    }
417    printf("\r  %d citations read. %s\n", N, ExeTm.GetTmStr());
418    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
419    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
420    TIntV RmNIdV;
421    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
422      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
423    }
424    for (int i = 0; i < RmNIdV.Len(); i++) {
425      TimeNet.DelNode(RmNIdV[i]);
426    }
427    TimeNet.Defrag(true);
428    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
429    printf("  Duplicate citations                    : %d\n", DupLinks);
430    printf("  Nodes without time which are cited     : %d (add them to graph, use time of the earliest source node)\n", NewDstIds);
431    printf("  Citations between unknown time nodes   : %d\n", NewCits);
432    printf("  Nodes without time which make citations: %d (do not add them into the graph)\n", NewSrcIds);
433    return TimeNetPt;
434  }
435  PTimeNet TTimeNet::LoadPatents(const TStr& PatentFNm, const TStr& CiteFNm) {
436    int N = 0;
437    TExeTm ExeTm;
438    PTimeNet TimeNetPt = TTimeNet::New();
439    TTimeNet& TimeNet = *TimeNetPt;
440    TimeNet.Reserve(4000000, 160000000);
441    printf("parsing patent data (patent grant year)...\n");
442    const int& PatIdCol = 0;
443    const int& GYearCol = 1;
444    TStrV ColV;
445    char Line [1024];
446    FILE *PatF = fopen(PatentFNm.CStr(), "rt");
447    fgets(Line, 1024, PatF); 
448    while (! feof(PatF)) {
449      Line[0] = 0;
450      fgets(Line, 1024, PatF);
451      if (strlen(Line) == 0) break;
452      TStr(Line).SplitOnAllCh(',', ColV, false);
453      IAssert(ColV.Len() == 23);
454      const int PatentId = ColV[PatIdCol].GetInt();
455      const int GrantYear = ColV[GYearCol].GetInt();
456      IAssert(! TimeNet.IsNode(PatentId));
457      TimeNet.AddNode(PatentId, TSecTm(GrantYear)); 
458      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
459    }
460    printf("\r  %d patents read. %s\n", N, ExeTm.GetTmStr());
461    fclose(PatF);
462    printf("\nLoading patent citations...\n");
463    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
464    N = 0;  ExeTm.Tick();
465    TStr SrcId, DstId;
466    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
467    fgets(Line, 1024, CiteF); 
468    while (! feof(CiteF)) {
469      Line[0] = 0;
470      fgets(Line, 1024, CiteF);
471      if (strlen(Line) == 0) break;
472      Line[strlen(Line)-1] = 0; 
473      TStr(Line).SplitOnCh(SrcId, ',', DstId);
474      const int SrcNId = SrcId.GetInt();
475      const int DstNId = DstId.GetInt();
476      if (! TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
477        NewCits++;
478        continue;
479      }
480      else if (TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
481        TimeNet.AddNode(DstNId, TimeNet.GetNDat(SrcNId));  NewDstIds++;
482      }
483      else if (! TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
484        TimeNet.AddNode(SrcNId, TimeNet.GetNDat(DstNId));  NewSrcIds++;
485      }
486      if (! TimeNet.IsEdge(SrcNId, DstNId)) {
487        TimeNet.AddEdge(SrcNId, DstNId);
488      } else { DupLinks++; }
489      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
490    }
491    fclose(CiteF);
492    printf("\r  %d citations read. %s\n\n", N, ExeTm.GetTmStr());
493    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
494    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
495    TIntV RmNIdV;
496    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
497      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
498    }
499    for (int i = 0; i < RmNIdV.Len(); i++) {
500      TimeNet.DelNode(RmNIdV[i]);
501    }
502    TimeNet.Defrag(true);
503    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
504    printf("  Duplicate citations                    : %d\n", DupLinks);
505    printf("  Citations between unknown time nodes   : %d\n", NewCits);
506    printf("  Nodes without time which make citations: %d\n", NewSrcIds);
507    printf("  Nodes without time which are cited     : %d\n", NewDstIds);
508    return TimeNetPt;
509  }
510  PTimeNet TTimeNet::LoadAmazon(const TStr& StlFNm) {
511    PTimeNet TimeNetPt = TTimeNet::New();
512    TTimeNet& TimeNet = *TimeNetPt;
513    TimeNet.Reserve(3953993, -1);
514    printf("Amazon Share-the-Love...\n");
515    char line [2024], MonthStr[4];
516    int NLines=0;
517    TStrV ColV;
518    FILE *F = fopen(StlFNm.CStr(), "rt");
519    while (! feof(F)) {
520      memset(line, 0, 2024);
521      fgets(line, 2024, F);
522      if (strlen(line) == 0) break;
523      TStr(line).SplitOnAllCh(',', ColV);
524      const int SrcNId = ColV[0].GetInt();
525      const int DstNId = ColV[1].GetInt();
526      TStr TmStr = ColV[2]; 
527      int Year = TmStr.GetSubStr(5, 6).GetInt();
528      if (Year < 10) { Year += 2000; } else { Year += 1900; }
529      MonthStr[0]=toupper(TmStr[2]);  MonthStr[1]=tolower(TmStr[3]);
530      MonthStr[2]=tolower(TmStr[4]);  MonthStr[3]=0;
531      const int Month = TTmInfo::GetMonthN(MonthStr, lUs);
532      const int Day = TmStr.GetSubStr(0, 1).GetInt();
533      const int Hour = TmStr.GetSubStr(8, 9).GetInt();
534      const int Min = TmStr.GetSubStr(11, 12).GetInt();
535      const int Sec = TmStr.GetSubStr(14, 15).GetInt();
536      if (! TimeNet.IsNode(SrcNId)) { TimeNet.AddNode(SrcNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
537      if (! TimeNet.IsNode(DstNId)) { TimeNet.AddNode(DstNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
538      if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
539      if (++NLines % 100000 == 0) printf("\r  %dk", NLines/1000);
540    }
541    fclose(F);
542    printf("\r  %d lines read\n", NLines);
543    printf("Graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
544    TimeNet.Defrag(true);
545    return TimeNetPt;
546  }
547  TTimeNENet& TTimeNENet::operator = (const TTimeNENet& TimeNet) {
548    if (this != &TimeNet) {
549      TNet::operator=(TimeNet);
550    }
551    return *this;
552  }
553  PTimeNet TTimeNENet::GetTimeNet() const {
554    PTimeNet NewNet = TTimeNet::New();
555    NewNet->Reserve(GetNodes(), -1);
556    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
557      NewNet->AddNode(NI.GetId(), NI.GetDat());
558    }
559    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
560      const int src = EI.GetSrcNId();
561      const int dst = EI.GetDstNId();
562      if (! NewNet->IsEdge(src, dst)) {
563        NewNet->AddEdge(src, dst); }
564    }
565    NewNet->Defrag();
566    return NewNet;
567  }
568  PTimeNENet TTimeNENet::Get1stEdgeNet() const {
569    PTimeNENet Net = TTimeNENet::New();
570    Net->Reserve(GetNodes(), -1);
571    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
572      Net->AddNode(NI.GetId(), NI.GetDat()); }
573    TIntV EIdV;  GetEIdByTm(EIdV);
574    TIntPrSet EdgeSet(GetEdges());
575    for (int edge = 0; edge < EIdV.Len(); edge++) {
576      const TEdgeI EI = GetEI(EIdV[edge]);
577      const int Src = EI.GetSrcNId();
578      const int Dst = EI.GetDstNId();
579      if (Src==Dst || EdgeSet.IsKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)))) { continue; } 
580      EdgeSet.AddKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)));
581      Net->AddEdge(EI);
582    }
583    return Net;
584  }
585  PTimeNENet TTimeNENet::GetSubGraph(const TIntV& NIdV) const {
586    PTimeNENet NewNetPt = TTimeNENet::New();
587    TTimeNENet& NewNet = *NewNetPt;
588    NewNet.Reserve(NIdV.Len(), -1);
589    int node, edge;
590    TNodeI NI;
591    for (node = 0; node < NIdV.Len(); node++) {
592      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node]));
593    }
594    for (node = 0; node < NIdV.Len(); node++) {
595      NI = GetNI(NIdV[node]);
596      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
597        const TEdgeI EI = GetEI(NI.GetOutEId(edge));
598        if (NewNet.IsNode(EI.GetDstNId())) {
599          NewNet.AddEdge(EI); }
600      }
601    }
602    NewNet.Defrag();
603    return NewNetPt;
604  }
605  PTimeNENet TTimeNENet::GetESubGraph(const TIntV& EIdV) const {
606    PTimeNENet NewNetPt = TTimeNENet::New();
607    TTimeNENet& NewNet = *NewNetPt;
608    NewNet.Reserve(-1, EIdV.Len());
609    for (int edge = 0; edge < EIdV.Len(); edge++) {
610      const TEdgeI Edge = GetEI(EIdV[edge]);
611      if (! NewNet.IsNode(Edge.GetSrcNId()))
612        NewNet.AddNode(GetNI(Edge.GetSrcNId()));
613      if (! NewNet.IsNode(Edge.GetDstNId()))
614        NewNet.AddNode(GetNI(Edge.GetDstNId()));
615      NewNet.AddEdge(Edge);
616    }
617    NewNet.Defrag();
618    return NewNetPt;
619  }
620  PTimeNENet TTimeNENet::GetGraphUpToTm(const TSecTm& MaxEdgeTm) const {
621    PTimeNENet NewNetPt = TTimeNENet::New();
622    TTimeNENet& NewNet = *NewNetPt;
623    TSecTm PrevTm;
624    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
625      if (EI() > MaxEdgeTm) { break; }
626      if (! NewNet.IsNode(EI.GetSrcNId()))
627        NewNet.AddNode(GetNI(EI.GetSrcNId()));
628      if (! NewNet.IsNode(EI.GetDstNId()))
629        NewNet.AddNode(GetNI(EI.GetDstNId()));
630      NewNet.AddEdge(EI);
631      IAssert(! PrevTm.IsDef() || PrevTm <= EI()); 
632      PrevTm = EI();
633    }
634    NewNet.Defrag();
635    return NewNetPt;
636  }
637  void TTimeNENet::SortNodeEdgeTimes() {
638    NodeH.SortByDat(true);
639    EdgeH.SortByDat(true);
640  }
641  void TTimeNENet::UpdateNodeTimes() {
642    int Cnt = 0;
643    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
644      TSecTm& NodeTm = NI();
645      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
646        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));
647        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
648      }
649      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
650        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));
651        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
652      }
653    }
654    printf("Update node times: %d/%d updates\n", Cnt, GetNodes());
655  }
656  void TTimeNENet::SetNodeTmToFirstEdgeTm() {
657    int Cnt = 0;
658    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
659      if (NI.GetDeg() == 0) { continue; }
660      TSecTm NodeTm;
661      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
662        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));  IAssert(EdgeTm.IsDef());
663        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
664      }
665      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
666        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));  IAssert(EdgeTm.IsDef());
667        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
668      }
669      GetNDat(NI.GetId()) = NodeTm;
670    }
671    printf("Node times set: %d/%d updates\n", Cnt, GetNodes());
672  }
673  void TTimeNENet::SetRndEdgeTimes(const int& MinTmEdge) {
674    printf("Shuffling last %d (%d%%) edge arrival times..\n", GetEdges()-MinTmEdge, int(100.0*(GetEdges()-MinTmEdge)/double(GetEdges())));
675    TIntV RndEIdV;  GetEIdByTm(RndEIdV);
676    TIntV TrueEIdV = RndEIdV;
677    TSecTmV TrueTmV;
678    const int SwapLen = RndEIdV.Len()-MinTmEdge;
679    for (int R = 0; R < 10; R++) {
680      for (int i = MinTmEdge; i < RndEIdV.Len(); i++) {
681        RndEIdV.Swap(TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge, TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge); }
682    }
683    for (int e = 0; e < TrueEIdV.Len(); e++) {
684      TrueTmV.Add(GetEDat(TrueEIdV[e])); }
685    for (int e = 0; e < RndEIdV.Len(); e++) {
686      GetEDat(RndEIdV[e]) = TrueTmV[e]; }
687    UpdateNodeTimes();
688  }
689  void TTimeNENet::DumpTimeStat() const {
690    TSecTm MnNodeTm, MxNodeTm;
691    TSecTm MnEdgeTm, MxEdgeTm;
692    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
693      const TSecTm NodeTm = NI();
694      if (! MnNodeTm.IsDef() || MnNodeTm>NodeTm) { MnNodeTm = NodeTm; }
695      if (! MxNodeTm.IsDef() || MxNodeTm<NodeTm) { MxNodeTm = NodeTm; }
696    }
697    printf("Node times:\n  %s\n  %s\n", MnNodeTm.GetStr().CStr(), MxNodeTm.GetStr().CStr());
698    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
699      const TSecTm EdgeTm = EI();
700      if (! MnEdgeTm.IsDef() || MnEdgeTm>EdgeTm) { MnEdgeTm = EdgeTm; }
701      if (! MxEdgeTm.IsDef() || MxEdgeTm<EdgeTm) { MxEdgeTm = EdgeTm; }
702    }
703    printf("Edge times:\n  %s\n  %s\n", MnEdgeTm.GetStr().CStr(), MxEdgeTm.GetStr().CStr());
704  }
705  void TTimeNENet::GetNIdByTm(TIntV& NIdV) const {
706    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
707    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
708      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
709    TmToNIdV.Sort();
710    NIdV.Gen(GetNodes(), 0);
711    for (int i = 0; i < TmToNIdV.Len(); i++) {
712      NIdV.Add(TmToNIdV[i].Dat); }
713  }
714  void TTimeNENet::GetEIdByTm(TIntV& EIdV) const {
715    TVec<TKeyDat<TSecTm, TInt> > TmToEIdV(GetEdges(), 0);
716    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
717      TmToEIdV.Add(TKeyDat<TSecTm, TInt>(EI.GetDat(), EI.GetId())); }
718    TmToEIdV.Sort();
719    EIdV.Gen(GetEdges(), 0);
720    for (int i = 0; i < TmToEIdV.Len(); i++) {
721      EIdV.Add(TmToEIdV[i].Dat); }
722  }
723  void TTimeNENet::GetTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
724    THash<TInt, TIntV> TmIdToNIdVH;
725    TIntV NIdV;  GetNIdByTm(NIdV);
726    for (int n = 0; n < NIdV.Len(); n++) {
727      const int TmId = GetNDat(NIdV[n]).Round(TmUnit).GetAbsSecs();
728      if (! TmIdToNIdVH.IsKey(TmId)) { TmIdToNIdVH.AddKey(TmId); }
729      TmIdToNIdVH.GetDat(TmId).Add(NIdV[n]);
730    }
731    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
732    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
733    TmIdNIdVV.Sort();
734    TmBucketV.Gen(TmIdNIdVV.Len());
735    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
736      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
737      Bucket.BegTm = TmIdNIdVV[i].Val1;
738      Bucket.NIdV = TmIdNIdVV[i].Val2;
739    }
740  }
741  void TTimeNENet::GetEdgeTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
742    THash<TInt, TIntV> TmIdToEIdVH;
743    TIntV EIdV;  GetEIdByTm(EIdV);
744    for (int e = 0; e < EIdV.Len(); e++) {
745      const int TmId = GetEDat(EIdV[e]).Round(TmUnit).GetAbsSecs();
746      if (! TmIdToEIdVH.IsKey(TmId)) { TmIdToEIdVH.AddKey(TmId); }
747      TmIdToEIdVH.GetDat(TmId).Add(EIdV[e]);
748    }
749    TVec<TPair<TInt, TIntV> > TmIdEIdVV;
750    TmIdToEIdVH.GetKeyDatPrV(TmIdEIdVV);
751    TmIdEIdVV.Sort();
752    TmBucketV.Gen(TmIdEIdVV.Len());
753    for (int i = 0; i < TmIdEIdVV.Len(); i++) {
754      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
755      Bucket.BegTm = TmIdEIdVV[i].Val1;
756      Bucket.NIdV = TmIdEIdVV[i].Val2;
757    }
758  }
759  void TTimeNENet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
760    TIntV NIdV;  GetNIdByTm(NIdV);
761    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
762    for (int i = 0; i < NIdV.Len(); i++) {
763      const int b = i/NodesPerBucket;
764      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
765      TmBucketV[b].NIdV.Add(NIdV[i]);
766    }
767  }
768  void TTimeNENet::GetEdgeBuckets(const int EdgesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
769    TIntV EIdV;  GetEIdByTm(EIdV);
770    TmBucketV.Gen(EIdV.Len()/EdgesPerBucket + 1, 0);
771    for (int i = 0; i < EIdV.Len(); i++) {
772      const int b = i/EdgesPerBucket;
773      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
774      TmBucketV[b].NIdV.Add(EIdV[i]);
775    }
776  }
777  int TTimeNENet::GetTriadEdges(TIntV& TriadEIdV) const {
778    PUNGraph Graph = TUNGraph::New(GetNodes(), GetEdges());
779    TIntV EIdV;  GetEIdByTm(EIdV);
780    TriadEIdV.Clr();
781    TExeTm ExeTm;
782    for (int edge = 0; edge < EIdV.Len(); edge++) {
783      const TEdgeI EI = GetEI(EIdV[edge]);
784      const int Src = EI.GetSrcNId();
785      const int Dst = EI.GetDstNId();
786      if (Src==Dst || Graph->IsEdge(Src, Dst)) { continue; } 
787      if (! Graph->IsNode(Src)) { Graph->AddNode(Src); }
788      if (! Graph->IsNode(Dst)) { Graph->AddNode(Dst); }
789      if (TSnap::GetCmnNbrs(Graph, Src, Dst) > 0) { TriadEIdV.Add(EIdV[edge]); }
790      Graph->AddEdge(Src, Dst);
791      if (edge % 10000 == 0) {
792        printf("\redges %dk / %dk: triangle edges: %dk [total %s]", edge/1000, EIdV.Len()/1000,
793          TriadEIdV.Len()/1000, ExeTm.GetStr()); }
794    }
795    return Graph->GetEdges();
796  }
797  PGStatVec TTimeNENet::TimeGrowth(const TTmUnit& TimeStep, const TFSet& TakeStat, const TSecTm& StartTm) const {
798    TExeTm ExeTm;
799    PGStatVec GStatVec = TGStatVec::New(TimeStep, TakeStat);
800    TTimeNet::TTmBucketV TmBucketV;
801    GetEdgeTmBuckets(TimeStep, TmBucketV);
802    const PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
803    TIntV EdgeIdV;
804    for (int t = 0; t < TmBucketV.Len(); t++) {
805      EdgeIdV.AddV(TmBucketV[t].NIdV); 
806      printf("\n***%d/%d: %s (%d edges) ", t+1, TmBucketV.Len(), TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
807      if (TmBucketV[t].BegTm < StartTm) { continue; }
808      const PNEGraph PreGraph = TSnap::GetESubGraph(FullGraph, EdgeIdV);
809      GStatVec->Add(PreGraph, TmBucketV[t].BegTm);
810      printf("  [%s]\n", ExeTm.GetTmStr());
811    }
812    return GStatVec;
813  }
814  PGStatVec TTimeNENet::TimeGrowth(const TStr& FNmPref, const TStr& Desc, const TFSet& TakeStat, const int& NDiamRuns,
815                              const TTmUnit& TmUnit, const int& TakeNTmUnits, const bool& LinkBWays) const {
816    TGStat::NDiamRuns = NDiamRuns;
817    PGStatVec GrowthStat = TGStatVec::New(TmUnit, TakeStat);
818    TTimeNet::TTmBucketV TmBucketV;
819    GetEdgeTmBuckets(TmUnit, TmBucketV);
820    TIntV EdgeIdV;
821    TExeTm ExeTm;
822    for (int t = 0; t < TmBucketV.Len(); t++) {
823      if (TakeNTmUnits == -1) {
824        EdgeIdV.AddV(TmBucketV[t].NIdV); }
825      else {
826        if (t < TakeNTmUnits) { continue; }
827        EdgeIdV.Clr(false);
828        for (int i = t-TakeNTmUnits; i < t; i++) { EdgeIdV.AddV(TmBucketV[i].NIdV); }
829      }
830      printf("*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
831      PNEGraph PreGraph = TSnap::ConvertESubGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this), EdgeIdV);
832      if (LinkBWays) {
833        TIntV KeepEIdV; 
834        for (TNEGraph::TEdgeI EI = PreGraph->BegEI(); EI < PreGraph->EndEI(); EI++) {
835          if (PreGraph->IsEdge(EI.GetDstNId(), EI.GetSrcNId(), true)) { KeepEIdV.Add(EI.GetId()); }
836        }
837        PreGraph = TSnap::GetESubGraph(PreGraph, KeepEIdV);
838      }
839      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
840      { TFOut FOut(TStr::Fmt("growth.%s.gStatVec", FNmPref.CStr()));
841      GrowthStat->Save(FOut); }
842      GrowthStat->SaveTxt(FNmPref, Desc);
843      printf("  [%s]\n", ExeTm.GetTmStr());
844    }
845    return GrowthStat;
846  }
847  void TTimeNENet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
848                               const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc) const {
849    TTimeNet::TTmBucketV TmBucketV;
850    GetEdgeTmBuckets(TmUnit, TmBucketV);
851    PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
852    TIntV EdgeIdV;
853    TExeTm ExeTm, Run1Tm;
854    TFltTrV TmDiamV, NdsDiamV;
855    for (int t = 0; t < TmBucketV.Len(); t++) {
856      EdgeIdV.AddV(TmBucketV[t].NIdV); 
857      printf("\n*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), EdgeIdV.Len());  ExeTm.Tick();
858      if (TmBucketV[t].BegTm < StartTm) continue;
859      PNGraph PreGraph = TSnap::ConvertESubGraph<PNGraph>(FullGraph, EdgeIdV);
860      TMom Mom;
861      double EffDiam = 0.0;
862      for (int r = 0; r < NDiamRuns; r++) {
863        printf("%d...", r+1);  Run1Tm.Tick();
864        if (OnlyWcc) { EffDiam = TSnap::GetAnfEffDiam(TSnap::GetMxWcc(PreGraph)); }
865        else { EffDiam = TSnap::GetAnfEffDiam(PreGraph); }
866        Mom.Add(EffDiam);
867        printf("[%s]\r", Run1Tm.GetTmStr());
868      }
869      Mom.Def();
870      TmDiamV.Add(TFltTr(TmBucketV[t].BegTm.Round(TmUnit).GetAbsSecs(), Mom.GetMean(), Mom.GetSDev()));
871      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
872      NdsDiamV.Sort();
873      printf("  [%s]          \n", ExeTm.GetTmStr());
874      const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
875      { TGnuPlot GnuPlot("diamEff1."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
876      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), "AVERAGE "+WccStr+"Effective Diameter");
877      GnuPlot.AddErrBar(TmDiamV, "", "");
878      GnuPlot.SavePng(); }
879      { TGnuPlot GnuPlot("diamEff2."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
880      GnuPlot.SetXYLabel("NODES", "AVERAGE "+WccStr+"Effective Diameter");
881      GnuPlot.AddErrBar(NdsDiamV, "", "");
882      GnuPlot.SavePng(); }
883    }
884  }
885  void TTimeNENet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
886                                   const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam, const bool& LinkBWays) {
887    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
888      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
889    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
890      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
891  }
892  PTimeNENet TTimeNENet::GetGnmRndNet(const int& Nodes, const int& Edges) {
893    printf("Generating G_nm(%d, %d)\n", Nodes, Edges);
894    int Src, Dst;
895    PTimeNENet Net = TTimeNENet::New();
896    Net->Reserve(Nodes, Edges);
897    for (int e = 0; e < Edges; e++) {
898      Src = TInt::Rnd.GetUniDevInt(Nodes);
899      Dst = TInt::Rnd.GetUniDevInt(Nodes);
900      while (Dst == Src || Net->IsEdge(Src, Dst)) {
901        Dst = TInt::Rnd.GetUniDevInt(Nodes); }
902      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(e)); }
903      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(e)); }
904      Net->AddEdge(Src, Dst, -1, TSecTm(e));
905    }
906    return Net;
907  }
908  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& Edges, const double& GammaIn, const double& GammaOut) {
909    const double Alpha = Nodes/double(Edges);
910    printf("Generating PA(%d, %d), with slope in:%.1f, out: %.1f\n", Nodes, Edges,
911      2+GammaIn/(Alpha/(1-Alpha)), 2+GammaOut/(Alpha/(1-Alpha)));
912    int nodes=0, edges=0, time=0, iter=0;
913    TIntV OutW(Edges, 0), InW(Edges, 0);
914    PTimeNENet Net = TTimeNENet::New();
915    Net->Reserve(Nodes, Edges);
916    Net->AddNode(0, TSecTm(time++));  nodes++;
917    OutW.Add(0);  InW.Add(0);
918    while (edges < Edges) {
919      int Src=-1, Dst=-1;  iter++;
920      if (TInt::Rnd.GetUniDev() < Alpha) {
921        if (nodes < Nodes) {
922          IAssert(Net->AddNode(nodes, TSecTm(time++)));
923          nodes++; }
924      } else {
925        if (TInt::Rnd.GetUniDev() < nodes*GammaIn/double(edges+nodes*GammaIn)) {
926          Src = TInt::Rnd.GetUniDevInt(nodes); }
927        else { Src = OutW[TInt::Rnd.GetUniDevInt(OutW.Len())]; }
928        if (TInt::Rnd.GetUniDev() < nodes*GammaOut/double(edges+nodes*GammaOut)) {
929          Dst = TInt::Rnd.GetUniDevInt(nodes); }
930        else { Dst = InW[TInt::Rnd.GetUniDevInt(InW.Len())]; }
931      }
932      if (Src == Dst || Net->IsEdge(Src, Dst)) {
933        continue;
934      }
935      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(time++)); nodes++; }
936      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(time++)); nodes++; }
937      Net->AddEdge(Src, Dst, -1, TSecTm(time++));
938      OutW.Add(Src); InW.Add(Dst); edges++;
939    }
940    for (int node = 0; node < Nodes; node++) {
<span onclick='openModal()' class='match'>941      if (! Net->IsNode(node)) {
942        Net->AddNode(node, TSecTm(time++)); }
943    }
944    return Net;
945  }
946  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& OutDeg) {
</span>947    printf("Generating PA, nodes:%d, out-deg:%d\n", Nodes, OutDeg);
948    int time=0;
949    PTimeNENet Net = TTimeNENet::New();
950    Net->Reserve(Nodes, OutDeg*Nodes);
951    Net->AddNode(0, TSecTm(++time));  Net->AddNode(1, TSecTm(++time));
952    Net->AddEdge(0, 1, -1, TSecTm(++time));
953    TIntV NIdV;  NIdV.Add(0);  NIdV.Add(1);
954    TIntSet NodeSet;
955    for (int node = 2; node <= Nodes; node++) {
956      NodeSet.Clr(false);
957      while (NodeSet.Len() < OutDeg && NodeSet.Len() < node) {
958        NodeSet.AddKey(NIdV[TInt::Rnd.GetUniDevInt(NIdV.Len())]);
959      }
960      const int N = Net->AddNode(node, TSecTm(++time));
961      for (int i = 0; i < NodeSet.Len(); i++) {
962        Net->AddEdge(node, NodeSet[i], -1, TSecTm(++time));
963        NIdV.Add(N);  NIdV.Add(NodeSet[i]);
964      }
965    }
966    return Net;
967  }
968  void TTimeNENet::SaveEdgeTm(const TStr& EdgeFNm, const bool& RenumberNId, const bool& RelativeTm) const {
969    TIntV EIdV;  GetEIdByTm(EIdV);
970    const int BegTm = RelativeTm ? GetEDat(EIdV[0]).GetAbsSecs() : 0;
971    TIntSet NIdMap;
972    if (RenumberNId) { NIdMap.Gen(GetNodes()); }
973    FILE *F = fopen(EdgeFNm.CStr(), "wt");
974    for (int e =0; e < EIdV.Len(); e++) {
975      const TEdgeI EI = GetEI(EIdV[e]);
976      if (RenumberNId) {
977        const int src = EI.GetSrcNId();
978        const int dst = EI.GetDstNId();
979        NIdMap.AddKey(src);  NIdMap.AddKey(dst);
980        fprintf(F, "%d\t%d\t%d\n", NIdMap.GetKeyId(src), NIdMap.GetKeyId(dst), EI().GetAbsSecs()-BegTm);
981      }else {
982        fprintf(F, "%d\t%d\t%d\n", EI.GetSrcNId(), EI.GetDstNId(), EI().GetAbsSecs()-BegTm); }
983    }
984    fclose(F);
985  }
986  PTimeNENet TTimeNENet::GetSmallNet() {
987    PTimeNENet Net = TTimeNENet::New();
988    for (int i = 1; i <= 6; i++) {
989      Net->AddNode(i, TSecTm(0)); }
990    int tm = 1;
991    Net->AddEdge(1, 2, -1, TSecTm(tm++));
992    Net->AddEdge(3, 4, -1, TSecTm(tm++));
993    Net->AddEdge(3, 1, -1, TSecTm(tm++));
994    Net->AddEdge(5, 6, -1, TSecTm(tm++));
995    Net->AddEdge(6, 4, -1, TSecTm(tm++));
996    Net->AddEdge(5, 3, -1, TSecTm(tm++));
997    Net->AddEdge(5, 4, -1, TSecTm(tm++));
998    Net->AddEdge(5, 2, -1, TSecTm(tm++));
999    return Net;
1000  }
1001  PTimeNENet TTimeNENet::LoadFlickr(const TStr& NodeFNm, const TStr& EdgeFNm) {
1002    const int BegOfTm = 1047369600; 
1003    PTimeNENet Net = TTimeNENet::New();
1004    printf("Adding nodes...");
1005    { TSsParser Ss(NodeFNm, ssfWhiteSep);
1006    while (Ss.Next()) {
1007      const int NId = Ss.GetInt(0);
1008      const int Tm = Ss.GetInt(1)+BegOfTm;
1009      if (TSecTm(Tm) < TSecTm(2002, 1, 1)) {
1010        printf("  skip node %g (time %d)\n", (double) Ss.GetLineNo(), Ss.GetInt(1)); continue; }
1011      Net->AddNode(NId, TSecTm(Tm));
1012    } }
1013    printf(" %d nodes\n", Net->GetNodes());
1014    printf("Adding edges...");
1015    int SkipCnt=0;
1016    { TSsParser Ss(EdgeFNm, ssfWhiteSep);
1017    while (Ss.Next()) {
1018      const int NId1 = Ss.GetInt(0);
1019      const int NId2 = Ss.GetInt(1);
1020      const TSecTm Tm = TSecTm(Ss.GetInt(2)+BegOfTm);
1021      if (! Net->IsNode(NId1) || ! Net->IsNode(NId2)) { printf("not node\n"); continue; }
1022      if (Tm < TSecTm(2002, 1, 1)) { SkipCnt++;
1023        printf("  skip edge %g (time %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr()); continue; }
1024      if (Tm+600 < Net->GetNDat(NId1)) {
1025        printf("  1:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId1).GetStr().CStr());
1026        SkipCnt++;  continue; }
1027      if (Tm+600 < Net->GetNDat(NId2)) { SkipCnt++;
1028        printf("  2:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId2).GetStr().CStr());
1029        SkipCnt++;  continue; }
1030      Net->AddEdge(NId1, NId2, -1, TSecTm(Tm));
1031    } }
1032    printf("  %d edges\n", Net->GetEdges());
1033    printf("  %d edges skipped (edge time < node time)\n", SkipCnt);
1034    Net->UpdateNodeTimes();
1035    return Net;
1036  }
1037  PTimeNENet TTimeNENet::LoadEdgeTm(const TStr& EdgeFNm, const int& SrcFld, const int& DstFld, const int& TimeFld, const TSsFmt& Separator) {
1038    printf("Loading %s\n", EdgeFNm.CStr());
1039    PTimeNENet Net = TTimeNENet::New();
1040    TStrHash<TInt> StrToId(Mega(1), true); 
1041    int LineCnt=0;
1042    TExeTm ExeTm;
1043    TSsParser Ss(EdgeFNm, Separator);
1044    TSecTm MinTm=TSecTm::GetCurTm(), MaxTm=TSecTm(100);
1045    while (Ss.Next()) {
1046      if (Ss.IsCmt()) { continue; }
1047      IAssert(Ss.Len() > TimeFld);
1048      const char* Node1 = Ss.GetFld(SrcFld);
1049      const char* Node2 = Ss.GetFld(DstFld);
1050      const char* TmStr = Ss.GetFld(TimeFld);
1051      if (strcmp(TmStr,"NULL")==0) { continue; }
1052      const TSecTm Tm(atoi(TmStr));
1053      const int NId1 = StrToId.AddKey(Node1);
1054      const int NId2 = StrToId.AddKey(Node2);
1055      if (! Net->IsNode(NId1)) { Net->AddNode(NId1, TSecTm()); }
1056      if (! Net->IsNode(NId2)) { Net->AddNode(NId2, TSecTm()); }
1057      MinTm=TMath::Mn(MinTm, Tm);
1058      MaxTm=TMath::Mx(MaxTm, Tm);
1059      Net->AddEdge(NId1, NId2, -1, Tm);
1060      if (++LineCnt % 1000 == 0) {
1061        printf("\r  %dk lines processed: %d %d [%s]", LineCnt/1000, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr()); }
1062    }
1063    printf("\r  %d lines processed: %d %d [%s]\n", LineCnt, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr());
1064    printf("  Data range %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1065    Net->UpdateNodeTimes();
1066    return Net;
1067  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</div>
                <div class="column column_space"><pre><code>474      } else {
475        dp = nullptr;
476      }
477    }
478    return dp;
479  }
480  const char* ParseZone(const char* dp, std::string* zone) {
</pre></code></div>
                <div class="column column_space"><pre><code>941      if (! Net->IsNode(node)) {
942        Net->AddNode(node, TSecTm(time++)); }
943    }
944    return Net;
945  }
946  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& OutDeg) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    