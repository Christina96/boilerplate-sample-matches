
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container_test.cc</h3>
            <pre><code>1  #include "absl/algorithm/container.h"
2  #include <functional>
3  #include <initializer_list>
4  #include <iterator>
5  #include <list>
6  #include <memory>
7  #include <ostream>
8  #include <random>
9  #include <set>
10  #include <unordered_set>
11  #include <utility>
12  #include <valarray>
13  #include <vector>
14  #include "gmock/gmock.h"
15  #include "gtest/gtest.h"
16  #include "absl/base/casts.h"
17  #include "absl/base/macros.h"
18  #include "absl/memory/memory.h"
19  #include "absl/types/span.h"
20  namespace {
21  using ::testing::Each;
22  using ::testing::ElementsAre;
23  using ::testing::Gt;
24  using ::testing::IsNull;
25  using ::testing::Lt;
26  using ::testing::Pointee;
27  using ::testing::Truly;
28  using ::testing::UnorderedElementsAre;
29  class NonMutatingTest : public testing::Test {
30   protected:
31    std::unordered_set<int> container_ = {1, 2, 3};
32    std::list<int> sequence_ = {1, 2, 3};
33    std::vector<int> vector_ = {1, 2, 3};
34    int array_[3] = {1, 2, 3};
35  };
36  struct AccumulateCalls {
37    void operator()(int value) { calls.push_back(value); }
38    std::vector<int> calls;
39  };
40  bool Predicate(int value) { return value < 3; }
41  bool BinPredicate(int v1, int v2) { return v1 < v2; }
42  bool Equals(int v1, int v2) { return v1 == v2; }
43  bool IsOdd(int x) { return x % 2 != 0; }
44  TEST_F(NonMutatingTest, Distance) {
45    EXPECT_EQ(container_.size(),
46              static_cast<size_t>(absl::c_distance(container_)));
47    EXPECT_EQ(sequence_.size(), static_cast<size_t>(absl::c_distance(sequence_)));
48    EXPECT_EQ(vector_.size(), static_cast<size_t>(absl::c_distance(vector_)));
49    EXPECT_EQ(ABSL_ARRAYSIZE(array_),
50              static_cast<size_t>(absl::c_distance(array_)));
51    EXPECT_EQ(vector_.size(),
52              static_cast<size_t>(absl::c_distance(std::vector<int>(vector_))));
53  }
54  TEST_F(NonMutatingTest, Distance_OverloadedBeginEnd) {
55    std::initializer_list<int> a = {1, 2, 3};
56    std::valarray<int> b = {1, 2, 3};
57    EXPECT_EQ(3, absl::c_distance(a));
58    EXPECT_EQ(3, absl::c_distance(b));
59  }
60  TEST_F(NonMutatingTest, ForEach) {
61    AccumulateCalls c = absl::c_for_each(container_, AccumulateCalls());
62    std::sort(c.calls.begin(), c.calls.end());
63    EXPECT_EQ(vector_, c.calls);
64    AccumulateCalls c2 =
65        absl::c_for_each(std::unordered_set<int>(container_), AccumulateCalls());
66    std::sort(c2.calls.begin(), c2.calls.end());
67    EXPECT_EQ(vector_, c2.calls);
68  }
69  TEST_F(NonMutatingTest, FindReturnsCorrectType) {
70    auto it = absl::c_find(container_, 3);
71    EXPECT_EQ(3, *it);
72    absl::c_find(absl::implicit_cast<const std::list<int>&>(sequence_), 3);
73  }
74  TEST_F(NonMutatingTest, FindIf) { absl::c_find_if(container_, Predicate); }
75  TEST_F(NonMutatingTest, FindIfNot) {
76    absl::c_find_if_not(container_, Predicate);
77  }
78  TEST_F(NonMutatingTest, FindEnd) {
79    absl::c_find_end(sequence_, vector_);
80    absl::c_find_end(vector_, sequence_);
81  }
82  TEST_F(NonMutatingTest, FindEndWithPredicate) {
83    absl::c_find_end(sequence_, vector_, BinPredicate);
84    absl::c_find_end(vector_, sequence_, BinPredicate);
85  }
86  TEST_F(NonMutatingTest, FindFirstOf) {
87    absl::c_find_first_of(container_, sequence_);
88    absl::c_find_first_of(sequence_, container_);
89  }
90  TEST_F(NonMutatingTest, FindFirstOfWithPredicate) {
91    absl::c_find_first_of(container_, sequence_, BinPredicate);
92    absl::c_find_first_of(sequence_, container_, BinPredicate);
93  }
94  TEST_F(NonMutatingTest, AdjacentFind) { absl::c_adjacent_find(sequence_); }
95  TEST_F(NonMutatingTest, AdjacentFindWithPredicate) {
96    absl::c_adjacent_find(sequence_, BinPredicate);
97  }
98  TEST_F(NonMutatingTest, Count) { EXPECT_EQ(1, absl::c_count(container_, 3)); }
99  TEST_F(NonMutatingTest, CountIf) {
100    EXPECT_EQ(2, absl::c_count_if(container_, Predicate));
101    const std::unordered_set<int>& const_container = container_;
102    EXPECT_EQ(2, absl::c_count_if(const_container, Predicate));
103  }
104  TEST_F(NonMutatingTest, Mismatch) {
105    {
106      auto result = absl::c_mismatch(vector_, sequence_);
107      EXPECT_EQ(result.first, vector_.end());
108      EXPECT_EQ(result.second, sequence_.end());
109    }
110    {
111      auto result = absl::c_mismatch(sequence_, vector_);
112      EXPECT_EQ(result.first, sequence_.end());
113      EXPECT_EQ(result.second, vector_.end());
114    }
115    sequence_.back() = 5;
116    {
117      auto result = absl::c_mismatch(vector_, sequence_);
118      EXPECT_EQ(result.first, std::prev(vector_.end()));
119      EXPECT_EQ(result.second, std::prev(sequence_.end()));
120    }
121    {
122      auto result = absl::c_mismatch(sequence_, vector_);
123      EXPECT_EQ(result.first, std::prev(sequence_.end()));
124      EXPECT_EQ(result.second, std::prev(vector_.end()));
125    }
126    sequence_.pop_back();
127    {
128      auto result = absl::c_mismatch(vector_, sequence_);
129      EXPECT_EQ(result.first, std::prev(vector_.end()));
130      EXPECT_EQ(result.second, sequence_.end());
131    }
132    {
133      auto result = absl::c_mismatch(sequence_, vector_);
134      EXPECT_EQ(result.first, sequence_.end());
135      EXPECT_EQ(result.second, std::prev(vector_.end()));
136    }
137    {
138      struct NoNotEquals {
139        constexpr bool operator==(NoNotEquals) const { return true; }
140        constexpr bool operator!=(NoNotEquals) const = delete;
141      };
142      std::vector<NoNotEquals> first;
143      std::list<NoNotEquals> second;
144      absl::c_mismatch(first, second);
145    }
146  }
147  TEST_F(NonMutatingTest, MismatchWithPredicate) {
148    {
149      auto result = absl::c_mismatch(vector_, sequence_, BinPredicate);
150      EXPECT_EQ(result.first, vector_.begin());
151      EXPECT_EQ(result.second, sequence_.begin());
152    }
153    {
154      auto result = absl::c_mismatch(sequence_, vector_, BinPredicate);
155      EXPECT_EQ(result.first, sequence_.begin());
156      EXPECT_EQ(result.second, vector_.begin());
157    }
158    sequence_.front() = 0;
159    {
160      auto result = absl::c_mismatch(vector_, sequence_, BinPredicate);
161      EXPECT_EQ(result.first, vector_.begin());
162      EXPECT_EQ(result.second, sequence_.begin());
163    }
164    {
165      auto result = absl::c_mismatch(sequence_, vector_, BinPredicate);
166      EXPECT_EQ(result.first, std::next(sequence_.begin()));
167      EXPECT_EQ(result.second, std::next(vector_.begin()));
168    }
169    sequence_.clear();
170    {
171      auto result = absl::c_mismatch(vector_, sequence_, BinPredicate);
172      EXPECT_EQ(result.first, vector_.begin());
173      EXPECT_EQ(result.second, sequence_.end());
174    }
175    {
176      auto result = absl::c_mismatch(sequence_, vector_, BinPredicate);
177      EXPECT_EQ(result.first, sequence_.end());
178      EXPECT_EQ(result.second, vector_.begin());
179    }
180  }
181  TEST_F(NonMutatingTest, Equal) {
182    EXPECT_TRUE(absl::c_equal(vector_, sequence_));
183    EXPECT_TRUE(absl::c_equal(sequence_, vector_));
184    EXPECT_TRUE(absl::c_equal(sequence_, array_));
185    EXPECT_TRUE(absl::c_equal(array_, vector_));
186    std::vector<int> vector_plus = {1, 2, 3};
187    vector_plus.push_back(4);
188    EXPECT_FALSE(absl::c_equal(vector_plus, sequence_));
189    EXPECT_FALSE(absl::c_equal(sequence_, vector_plus));
190    EXPECT_FALSE(absl::c_equal(array_, vector_plus));
191  }
192  TEST_F(NonMutatingTest, EqualWithPredicate) {
193    EXPECT_TRUE(absl::c_equal(vector_, sequence_, Equals));
194    EXPECT_TRUE(absl::c_equal(sequence_, vector_, Equals));
195    EXPECT_TRUE(absl::c_equal(array_, sequence_, Equals));
196    EXPECT_TRUE(absl::c_equal(vector_, array_, Equals));
197    std::vector<int> vector_plus = {1, 2, 3};
198    vector_plus.push_back(4);
199    EXPECT_FALSE(absl::c_equal(vector_plus, sequence_, Equals));
200    EXPECT_FALSE(absl::c_equal(sequence_, vector_plus, Equals));
201    EXPECT_FALSE(absl::c_equal(vector_plus, array_, Equals));
202  }
203  TEST_F(NonMutatingTest, IsPermutation) {
204    auto vector_permut_ = vector_;
205    std::next_permutation(vector_permut_.begin(), vector_permut_.end());
206    EXPECT_TRUE(absl::c_is_permutation(vector_permut_, sequence_));
207    EXPECT_TRUE(absl::c_is_permutation(sequence_, vector_permut_));
208    std::vector<int> vector_plus = {1, 2, 3};
209    vector_plus.push_back(4);
210    EXPECT_FALSE(absl::c_is_permutation(vector_plus, sequence_));
211    EXPECT_FALSE(absl::c_is_permutation(sequence_, vector_plus));
212  }
213  TEST_F(NonMutatingTest, IsPermutationWithPredicate) {
214    auto vector_permut_ = vector_;
215    std::next_permutation(vector_permut_.begin(), vector_permut_.end());
216    EXPECT_TRUE(absl::c_is_permutation(vector_permut_, sequence_, Equals));
217    EXPECT_TRUE(absl::c_is_permutation(sequence_, vector_permut_, Equals));
218    std::vector<int> vector_plus = {1, 2, 3};
219    vector_plus.push_back(4);
220    EXPECT_FALSE(absl::c_is_permutation(vector_plus, sequence_, Equals));
221    EXPECT_FALSE(absl::c_is_permutation(sequence_, vector_plus, Equals));
222  }
223  TEST_F(NonMutatingTest, Search) {
224    absl::c_search(sequence_, vector_);
225    absl::c_search(vector_, sequence_);
226    absl::c_search(array_, sequence_);
227  }
228  TEST_F(NonMutatingTest, SearchWithPredicate) {
229    absl::c_search(sequence_, vector_, BinPredicate);
230    absl::c_search(vector_, sequence_, BinPredicate);
231  }
232  TEST_F(NonMutatingTest, SearchN) { absl::c_search_n(sequence_, 3, 1); }
233  TEST_F(NonMutatingTest, SearchNWithPredicate) {
234    absl::c_search_n(sequence_, 3, 1, BinPredicate);
235  }
236  TEST_F(NonMutatingTest, LowerBound) {
237    std::list<int>::iterator i = absl::c_lower_bound(sequence_, 3);
238    ASSERT_TRUE(i != sequence_.end());
239    EXPECT_EQ(2, std::distance(sequence_.begin(), i));
240    EXPECT_EQ(3, *i);
241  }
242  TEST_F(NonMutatingTest, LowerBoundWithPredicate) {
243    std::vector<int> v(vector_);
244    std::sort(v.begin(), v.end(), std::greater<int>());
245    std::vector<int>::iterator i = absl::c_lower_bound(v, 3, std::greater<int>());
246    EXPECT_TRUE(i == v.begin());
247    EXPECT_EQ(3, *i);
248  }
249  TEST_F(NonMutatingTest, UpperBound) {
250    std::list<int>::iterator i = absl::c_upper_bound(sequence_, 1);
251    ASSERT_TRUE(i != sequence_.end());
252    EXPECT_EQ(1, std::distance(sequence_.begin(), i));
253    EXPECT_EQ(2, *i);
254  }
255  TEST_F(NonMutatingTest, UpperBoundWithPredicate) {
256    std::vector<int> v(vector_);
257    std::sort(v.begin(), v.end(), std::greater<int>());
258    std::vector<int>::iterator i = absl::c_upper_bound(v, 1, std::greater<int>());
259    EXPECT_EQ(3, i - v.begin());
260    EXPECT_TRUE(i == v.end());
261  }
262  TEST_F(NonMutatingTest, EqualRange) {
263    std::pair<std::list<int>::iterator, std::list<int>::iterator> p =
264        absl::c_equal_range(sequence_, 2);
265    EXPECT_EQ(1, std::distance(sequence_.begin(), p.first));
266    EXPECT_EQ(2, std::distance(sequence_.begin(), p.second));
267  }
268  TEST_F(NonMutatingTest, EqualRangeArray) {
269    auto p = absl::c_equal_range(array_, 2);
270    EXPECT_EQ(1, std::distance(std::begin(array_), p.first));
271    EXPECT_EQ(2, std::distance(std::begin(array_), p.second));
272  }
273  TEST_F(NonMutatingTest, EqualRangeWithPredicate) {
274    std::vector<int> v(vector_);
275    std::sort(v.begin(), v.end(), std::greater<int>());
276    std::pair<std::vector<int>::iterator, std::vector<int>::iterator> p =
277        absl::c_equal_range(v, 2, std::greater<int>());
278    EXPECT_EQ(1, std::distance(v.begin(), p.first));
279    EXPECT_EQ(2, std::distance(v.begin(), p.second));
280  }
281  TEST_F(NonMutatingTest, BinarySearch) {
282    EXPECT_TRUE(absl::c_binary_search(vector_, 2));
283    EXPECT_TRUE(absl::c_binary_search(std::vector<int>(vector_), 2));
284  }
285  TEST_F(NonMutatingTest, BinarySearchWithPredicate) {
286    std::vector<int> v(vector_);
287    std::sort(v.begin(), v.end(), std::greater<int>());
288    EXPECT_TRUE(absl::c_binary_search(v, 2, std::greater<int>()));
289    EXPECT_TRUE(
290        absl::c_binary_search(std::vector<int>(v), 2, std::greater<int>()));
291  }
292  TEST_F(NonMutatingTest, MinElement) {
293    std::list<int>::iterator i = absl::c_min_element(sequence_);
294    ASSERT_TRUE(i != sequence_.end());
295    EXPECT_EQ(*i, 1);
296  }
297  TEST_F(NonMutatingTest, MinElementWithPredicate) {
298    std::list<int>::iterator i =
299        absl::c_min_element(sequence_, std::greater<int>());
300    ASSERT_TRUE(i != sequence_.end());
301    EXPECT_EQ(*i, 3);
302  }
303  TEST_F(NonMutatingTest, MaxElement) {
304    std::list<int>::iterator i = absl::c_max_element(sequence_);
305    ASSERT_TRUE(i != sequence_.end());
306    EXPECT_EQ(*i, 3);
307  }
308  TEST_F(NonMutatingTest, MaxElementWithPredicate) {
309    std::list<int>::iterator i =
310        absl::c_max_element(sequence_, std::greater<int>());
311    ASSERT_TRUE(i != sequence_.end());
312    EXPECT_EQ(*i, 1);
313  }
314  TEST_F(NonMutatingTest, LexicographicalCompare) {
315    EXPECT_FALSE(absl::c_lexicographical_compare(sequence_, sequence_));
316    std::vector<int> v;
317    v.push_back(1);
318    v.push_back(2);
319    v.push_back(4);
320    EXPECT_TRUE(absl::c_lexicographical_compare(sequence_, v));
321    EXPECT_TRUE(absl::c_lexicographical_compare(std::list<int>(sequence_), v));
322  }
323  TEST_F(NonMutatingTest, LexicographicalCopmareWithPredicate) {
324    EXPECT_FALSE(absl::c_lexicographical_compare(sequence_, sequence_,
325                                                 std::greater<int>()));
326    std::vector<int> v;
327    v.push_back(1);
328    v.push_back(2);
329    v.push_back(4);
330    EXPECT_TRUE(
331        absl::c_lexicographical_compare(v, sequence_, std::greater<int>()));
332    EXPECT_TRUE(absl::c_lexicographical_compare(
333        std::vector<int>(v), std::list<int>(sequence_), std::greater<int>()));
334  }
335  TEST_F(NonMutatingTest, Includes) {
336    std::set<int> s(vector_.begin(), vector_.end());
337    s.insert(4);
338    EXPECT_TRUE(absl::c_includes(s, vector_));
339  }
340  TEST_F(NonMutatingTest, IncludesWithPredicate) {
341    std::vector<int> v = {3, 2, 1};
342    std::set<int, std::greater<int>> s(v.begin(), v.end());
343    s.insert(4);
344    EXPECT_TRUE(absl::c_includes(s, v, std::greater<int>()));
345  }
346  class NumericMutatingTest : public testing::Test {
347   protected:
348    std::list<int> list_ = {1, 2, 3};
349    std::vector<int> output_;
350  };
351  TEST_F(NumericMutatingTest, Iota) {
352    absl::c_iota(list_, 5);
353    std::list<int> expected{5, 6, 7};
354    EXPECT_EQ(list_, expected);
355  }
356  TEST_F(NonMutatingTest, Accumulate) {
357    EXPECT_EQ(absl::c_accumulate(sequence_, 4), 1 + 2 + 3 + 4);
358  }
359  TEST_F(NonMutatingTest, AccumulateWithBinaryOp) {
360    EXPECT_EQ(absl::c_accumulate(sequence_, 4, std::multiplies<int>()),
361              1 * 2 * 3 * 4);
362  }
363  TEST_F(NonMutatingTest, AccumulateLvalueInit) {
364    int lvalue = 4;
365    EXPECT_EQ(absl::c_accumulate(sequence_, lvalue), 1 + 2 + 3 + 4);
366  }
367  TEST_F(NonMutatingTest, AccumulateWithBinaryOpLvalueInit) {
368    int lvalue = 4;
369    EXPECT_EQ(absl::c_accumulate(sequence_, lvalue, std::multiplies<int>()),
370              1 * 2 * 3 * 4);
371  }
372  TEST_F(NonMutatingTest, InnerProduct) {
373    EXPECT_EQ(absl::c_inner_product(sequence_, vector_, 1000),
374              1000 + 1 * 1 + 2 * 2 + 3 * 3);
375  }
376  TEST_F(NonMutatingTest, InnerProductWithBinaryOps) {
377    EXPECT_EQ(absl::c_inner_product(sequence_, vector_, 10,
378                                    std::multiplies<int>(), std::plus<int>()),
379              10 * (1 + 1) * (2 + 2) * (3 + 3));
380  }
381  TEST_F(NonMutatingTest, InnerProductLvalueInit) {
382    int lvalue = 1000;
383    EXPECT_EQ(absl::c_inner_product(sequence_, vector_, lvalue),
384              1000 + 1 * 1 + 2 * 2 + 3 * 3);
385  }
386  TEST_F(NonMutatingTest, InnerProductWithBinaryOpsLvalueInit) {
387    int lvalue = 10;
388    EXPECT_EQ(absl::c_inner_product(sequence_, vector_, lvalue,
389                                    std::multiplies<int>(), std::plus<int>()),
390              10 * (1 + 1) * (2 + 2) * (3 + 3));
391  }
392  TEST_F(NumericMutatingTest, AdjacentDifference) {
393    auto last = absl::c_adjacent_difference(list_, std::back_inserter(output_));
394    *last = 1000;
395    std::vector<int> expected{1, 2 - 1, 3 - 2, 1000};
396    EXPECT_EQ(output_, expected);
397  }
398  TEST_F(NumericMutatingTest, AdjacentDifferenceWithBinaryOp) {
399    auto last = absl::c_adjacent_difference(list_, std::back_inserter(output_),
400                                            std::multiplies<int>());
401    *last = 1000;
402    std::vector<int> expected{1, 2 * 1, 3 * 2, 1000};
403    EXPECT_EQ(output_, expected);
404  }
405  TEST_F(NumericMutatingTest, PartialSum) {
406    auto last = absl::c_partial_sum(list_, std::back_inserter(output_));
407    *last = 1000;
408    std::vector<int> expected{1, 1 + 2, 1 + 2 + 3, 1000};
409    EXPECT_EQ(output_, expected);
410  }
411  TEST_F(NumericMutatingTest, PartialSumWithBinaryOp) {
412    auto last = absl::c_partial_sum(list_, std::back_inserter(output_),
413                                    std::multiplies<int>());
414    *last = 1000;
415    std::vector<int> expected{1, 1 * 2, 1 * 2 * 3, 1000};
416    EXPECT_EQ(output_, expected);
417  }
418  TEST_F(NonMutatingTest, LinearSearch) {
419    EXPECT_TRUE(absl::c_linear_search(container_, 3));
420    EXPECT_FALSE(absl::c_linear_search(container_, 4));
421  }
422  TEST_F(NonMutatingTest, AllOf) {
423    const std::vector<int>& v = vector_;
424    EXPECT_FALSE(absl::c_all_of(v, [](int x) { return x > 1; }));
425    EXPECT_TRUE(absl::c_all_of(v, [](int x) { return x > 0; }));
426  }
427  TEST_F(NonMutatingTest, AnyOf) {
428    const std::vector<int>& v = vector_;
429    EXPECT_TRUE(absl::c_any_of(v, [](int x) { return x > 2; }));
430    EXPECT_FALSE(absl::c_any_of(v, [](int x) { return x > 5; }));
431  }
432  TEST_F(NonMutatingTest, NoneOf) {
433    const std::vector<int>& v = vector_;
434    EXPECT_FALSE(absl::c_none_of(v, [](int x) { return x > 2; }));
435    EXPECT_TRUE(absl::c_none_of(v, [](int x) { return x > 5; }));
436  }
437  TEST_F(NonMutatingTest, MinMaxElementLess) {
438    std::pair<std::vector<int>::const_iterator, std::vector<int>::const_iterator>
439        p = absl::c_minmax_element(vector_, std::less<int>());
440    EXPECT_TRUE(p.first == vector_.begin());
441    EXPECT_TRUE(p.second == vector_.begin() + 2);
442  }
443  TEST_F(NonMutatingTest, MinMaxElementGreater) {
444    std::pair<std::vector<int>::const_iterator, std::vector<int>::const_iterator>
445        p = absl::c_minmax_element(vector_, std::greater<int>());
446    EXPECT_TRUE(p.first == vector_.begin() + 2);
447    EXPECT_TRUE(p.second == vector_.begin());
448  }
449  TEST_F(NonMutatingTest, MinMaxElementNoPredicate) {
450    std::pair<std::vector<int>::const_iterator, std::vector<int>::const_iterator>
451        p = absl::c_minmax_element(vector_);
452    EXPECT_TRUE(p.first == vector_.begin());
453    EXPECT_TRUE(p.second == vector_.begin() + 2);
454  }
455  class SortingTest : public testing::Test {
456   protected:
457    std::list<int> sorted_ = {1, 2, 3, 4};
458    std::list<int> unsorted_ = {2, 4, 1, 3};
459    std::list<int> reversed_ = {4, 3, 2, 1};
460  };
461  TEST_F(SortingTest, IsSorted) {
462    EXPECT_TRUE(absl::c_is_sorted(sorted_));
463    EXPECT_FALSE(absl::c_is_sorted(unsorted_));
464    EXPECT_FALSE(absl::c_is_sorted(reversed_));
465  }
466  TEST_F(SortingTest, IsSortedWithPredicate) {
467    EXPECT_FALSE(absl::c_is_sorted(sorted_, std::greater<int>()));
468    EXPECT_FALSE(absl::c_is_sorted(unsorted_, std::greater<int>()));
469    EXPECT_TRUE(absl::c_is_sorted(reversed_, std::greater<int>()));
470  }
471  TEST_F(SortingTest, IsSortedUntil) {
472    EXPECT_EQ(1, *absl::c_is_sorted_until(unsorted_));
473    EXPECT_EQ(4, *absl::c_is_sorted_until(unsorted_, std::greater<int>()));
474  }
475  TEST_F(SortingTest, NthElement) {
476    std::vector<int> unsorted = {2, 4, 1, 3};
477    absl::c_nth_element(unsorted, unsorted.begin() + 2);
478    EXPECT_THAT(unsorted, ElementsAre(Lt(3), Lt(3), 3, Gt(3)));
479    absl::c_nth_element(unsorted, unsorted.begin() + 2, std::greater<int>());
480    EXPECT_THAT(unsorted, ElementsAre(Gt(2), Gt(2), 2, Lt(2)));
481  }
482  TEST(MutatingTest, IsPartitioned) {
483    EXPECT_TRUE(
484        absl::c_is_partitioned(std::vector<int>{1, 3, 5, 2, 4, 6}, IsOdd));
485    EXPECT_FALSE(
486        absl::c_is_partitioned(std::vector<int>{1, 2, 3, 4, 5, 6}, IsOdd));
487    EXPECT_FALSE(
488        absl::c_is_partitioned(std::vector<int>{2, 4, 6, 1, 3, 5}, IsOdd));
489  }
490  TEST(MutatingTest, Partition) {
491    std::vector<int> actual = {1, 2, 3, 4, 5};
492    absl::c_partition(actual, IsOdd);
493    EXPECT_THAT(actual, Truly([](const std::vector<int>& c) {
494                  return absl::c_is_partitioned(c, IsOdd);
495                }));
496  }
497  TEST(MutatingTest, StablePartition) {
498    std::vector<int> actual = {1, 2, 3, 4, 5};
499    absl::c_stable_partition(actual, IsOdd);
500    EXPECT_THAT(actual, ElementsAre(1, 3, 5, 2, 4));
501  }
502  TEST(MutatingTest, PartitionCopy) {
503    const std::vector<int> initial = {1, 2, 3, 4, 5};
504    std::vector<int> odds, evens;
505    auto ends = absl::c_partition_copy(initial, back_inserter(odds),
506                                       back_inserter(evens), IsOdd);
507    *ends.first = 7;
508    *ends.second = 6;
509    EXPECT_THAT(odds, ElementsAre(1, 3, 5, 7));
510    EXPECT_THAT(evens, ElementsAre(2, 4, 6));
511  }
512  TEST(MutatingTest, PartitionPoint) {
513    const std::vector<int> initial = {1, 3, 5, 2, 4};
514    auto middle = absl::c_partition_point(initial, IsOdd);
515    EXPECT_EQ(2, *middle);
516  }
517  TEST(MutatingTest, CopyMiddle) {
518    const std::vector<int> initial = {4, -1, -2, -3, 5};
519    const std::list<int> input = {1, 2, 3};
520    const std::vector<int> expected = {4, 1, 2, 3, 5};
521    std::list<int> test_list(initial.begin(), initial.end());
522    absl::c_copy(input, ++test_list.begin());
523    EXPECT_EQ(std::list<int>(expected.begin(), expected.end()), test_list);
524    std::vector<int> test_vector = initial;
525    absl::c_copy(input, test_vector.begin() + 1);
526    EXPECT_EQ(expected, test_vector);
527  }
528  TEST(MutatingTest, CopyFrontInserter) {
529    const std::list<int> initial = {4, 5};
530    const std::list<int> input = {1, 2, 3};
531    const std::list<int> expected = {3, 2, 1, 4, 5};
532    std::list<int> test_list = initial;
533    absl::c_copy(input, std::front_inserter(test_list));
534    EXPECT_EQ(expected, test_list);
535  }
536  TEST(MutatingTest, CopyBackInserter) {
537    const std::vector<int> initial = {4, 5};
538    const std::list<int> input = {1, 2, 3};
539    const std::vector<int> expected = {4, 5, 1, 2, 3};
540    std::list<int> test_list(initial.begin(), initial.end());
541    absl::c_copy(input, std::back_inserter(test_list));
542    EXPECT_EQ(std::list<int>(expected.begin(), expected.end()), test_list);
543    std::vector<int> test_vector = initial;
544    absl::c_copy(input, std::back_inserter(test_vector));
545    EXPECT_EQ(expected, test_vector);
546  }
547  TEST(MutatingTest, CopyN) {
548    const std::vector<int> initial = {1, 2, 3, 4, 5};
549    const std::vector<int> expected = {1, 2};
550    std::vector<int> actual;
551    absl::c_copy_n(initial, 2, back_inserter(actual));
552    EXPECT_EQ(expected, actual);
553  }
554  TEST(MutatingTest, CopyIf) {
555    const std::list<int> input = {1, 2, 3};
556    std::vector<int> output;
557    absl::c_copy_if(input, std::back_inserter(output),
558                    [](int i) { return i != 2; });
559    EXPECT_THAT(output, ElementsAre(1, 3));
560  }
561  TEST(MutatingTest, CopyBackward) {
562    std::vector<int> actual = {1, 2, 3, 4, 5};
563    std::vector<int> expected = {1, 2, 1, 2, 3};
564    absl::c_copy_backward(absl::MakeSpan(actual.data(), 3), actual.end());
565    EXPECT_EQ(expected, actual);
566  }
567  TEST(MutatingTest, Move) {
568    std::vector<std::unique_ptr<int>> src;
569    src.emplace_back(absl::make_unique<int>(1));
570    src.emplace_back(absl::make_unique<int>(2));
571    src.emplace_back(absl::make_unique<int>(3));
572    src.emplace_back(absl::make_unique<int>(4));
573    src.emplace_back(absl::make_unique<int>(5));
574    std::vector<std::unique_ptr<int>> dest = {};
575    absl::c_move(src, std::back_inserter(dest));
576    EXPECT_THAT(src, Each(IsNull()));
577    EXPECT_THAT(dest, ElementsAre(Pointee(1), Pointee(2), Pointee(3), Pointee(4),
578                                  Pointee(5)));
579  }
580  TEST(MutatingTest, MoveBackward) {
581    std::vector<std::unique_ptr<int>> actual;
582    actual.emplace_back(absl::make_unique<int>(1));
583    actual.emplace_back(absl::make_unique<int>(2));
584    actual.emplace_back(absl::make_unique<int>(3));
585    actual.emplace_back(absl::make_unique<int>(4));
586    actual.emplace_back(absl::make_unique<int>(5));
587    auto subrange = absl::MakeSpan(actual.data(), 3);
588    absl::c_move_backward(subrange, actual.end());
589    EXPECT_THAT(actual, ElementsAre(IsNull(), IsNull(), Pointee(1), Pointee(2),
590                                    Pointee(3)));
591  }
592  TEST(MutatingTest, MoveWithRvalue) {
593    auto MakeRValueSrc = [] {
594      std::vector<std::unique_ptr<int>> src;
595      src.emplace_back(absl::make_unique<int>(1));
596      src.emplace_back(absl::make_unique<int>(2));
597      src.emplace_back(absl::make_unique<int>(3));
598      return src;
599    };
600    std::vector<std::unique_ptr<int>> dest = MakeRValueSrc();
601    absl::c_move(MakeRValueSrc(), std::back_inserter(dest));
602    EXPECT_THAT(dest, ElementsAre(Pointee(1), Pointee(2), Pointee(3), Pointee(1),
603                                  Pointee(2), Pointee(3)));
604  }
605  TEST(MutatingTest, SwapRanges) {
606    std::vector<int> odds = {2, 4, 6};
607    std::vector<int> evens = {1, 3, 5};
608    absl::c_swap_ranges(odds, evens);
609    EXPECT_THAT(odds, ElementsAre(1, 3, 5));
610    EXPECT_THAT(evens, ElementsAre(2, 4, 6));
611    odds.pop_back();
612    absl::c_swap_ranges(odds, evens);
613    EXPECT_THAT(odds, ElementsAre(2, 4));
614    EXPECT_THAT(evens, ElementsAre(1, 3, 6));
615    absl::c_swap_ranges(evens, odds);
616    EXPECT_THAT(odds, ElementsAre(1, 3));
617    EXPECT_THAT(evens, ElementsAre(2, 4, 6));
618  }
619  TEST_F(NonMutatingTest, Transform) {
620    std::vector<int> x{0, 2, 4}, y, z;
621    auto end = absl::c_transform(x, back_inserter(y), std::negate<int>());
622    EXPECT_EQ(std::vector<int>({0, -2, -4}), y);
623    *end = 7;
624    EXPECT_EQ(std::vector<int>({0, -2, -4, 7}), y);
625    y = {1, 3, 0};
626    end = absl::c_transform(x, y, back_inserter(z), std::plus<int>());
627    EXPECT_EQ(std::vector<int>({1, 5, 4}), z);
628    *end = 7;
629    EXPECT_EQ(std::vector<int>({1, 5, 4, 7}), z);
630    z.clear();
631    y.pop_back();
632    end = absl::c_transform(x, y, std::back_inserter(z), std::plus<int>());
633    EXPECT_EQ(std::vector<int>({1, 5}), z);
634    *end = 7;
635    EXPECT_EQ(std::vector<int>({1, 5, 7}), z);
636    z.clear();
637    std::swap(x, y);
638    end = absl::c_transform(x, y, std::back_inserter(z), std::plus<int>());
639    EXPECT_EQ(std::vector<int>({1, 5}), z);
640    *end = 7;
641    EXPECT_EQ(std::vector<int>({1, 5, 7}), z);
642  }
643  TEST(MutatingTest, Replace) {
644    const std::vector<int> initial = {1, 2, 3, 1, 4, 5};
645    const std::vector<int> expected = {4, 2, 3, 4, 4, 5};
646    std::vector<int> test_vector = initial;
647    absl::c_replace(test_vector, 1, 4);
648    EXPECT_EQ(expected, test_vector);
649    std::list<int> test_list(initial.begin(), initial.end());
650    absl::c_replace(test_list, 1, 4);
651    EXPECT_EQ(std::list<int>(expected.begin(), expected.end()), test_list);
652  }
653  TEST(MutatingTest, ReplaceIf) {
654    std::vector<int> actual = {1, 2, 3, 4, 5};
655    const std::vector<int> expected = {0, 2, 0, 4, 0};
656    absl::c_replace_if(actual, IsOdd, 0);
657    EXPECT_EQ(expected, actual);
658  }
659  TEST(MutatingTest, ReplaceCopy) {
660    const std::vector<int> initial = {1, 2, 3, 1, 4, 5};
661    const std::vector<int> expected = {4, 2, 3, 4, 4, 5};
662    std::vector<int> actual;
663    absl::c_replace_copy(initial, back_inserter(actual), 1, 4);
664    EXPECT_EQ(expected, actual);
665  }
666  TEST(MutatingTest, Sort) {
667    std::vector<int> test_vector = {2, 3, 1, 4};
668    absl::c_sort(test_vector);
669    EXPECT_THAT(test_vector, ElementsAre(1, 2, 3, 4));
670  }
671  TEST(MutatingTest, SortWithPredicate) {
672    std::vector<int> test_vector = {2, 3, 1, 4};
673    absl::c_sort(test_vector, std::greater<int>());
674    EXPECT_THAT(test_vector, ElementsAre(4, 3, 2, 1));
675  }
676  struct Element {
677    int key;
678    int value;
679    friend bool operator<(const Element& e1, const Element& e2) {
680      return e1.key < e2.key;
681    }
682    friend std::ostream& operator<<(std::ostream& o, const Element& e) {
683      return o << "{" << e.key << ", " << e.value << "}";
684    }
685  };
686  MATCHER_P2(IsElement, key, value, "") {
687    return arg.key == key && arg.value == value;
688  }
689  TEST(MutatingTest, StableSort) {
690    std::vector<Element> test_vector = {{1, 1}, {2, 1}, {2, 0}, {1, 0}, {2, 2}};
691    absl::c_stable_sort(test_vector);
692    EXPECT_THAT(test_vector,
693                ElementsAre(IsElement(1, 1), IsElement(1, 0), IsElement(2, 1),
694                            IsElement(2, 0), IsElement(2, 2)));
695  }
696  TEST(MutatingTest, StableSortWithPredicate) {
697    std::vector<Element> test_vector = {{1, 1}, {2, 1}, {2, 0}, {1, 0}, {2, 2}};
698    absl::c_stable_sort(test_vector, [](const Element& e1, const Element& e2) {
699      return e2 < e1;
700    });
701    EXPECT_THAT(test_vector,
702                ElementsAre(IsElement(2, 1), IsElement(2, 0), IsElement(2, 2),
703                            IsElement(1, 1), IsElement(1, 0)));
704  }
705  TEST(MutatingTest, ReplaceCopyIf) {
706    const std::vector<int> initial = {1, 2, 3, 4, 5};
707    const std::vector<int> expected = {0, 2, 0, 4, 0};
708    std::vector<int> actual;
709    absl::c_replace_copy_if(initial, back_inserter(actual), IsOdd, 0);
710    EXPECT_EQ(expected, actual);
711  }
712  TEST(MutatingTest, Fill) {
713    std::vector<int> actual(5);
714    absl::c_fill(actual, 1);
715    EXPECT_THAT(actual, ElementsAre(1, 1, 1, 1, 1));
716  }
717  TEST(MutatingTest, FillN) {
718    std::vector<int> actual(5, 0);
719    absl::c_fill_n(actual, 2, 1);
720    EXPECT_THAT(actual, ElementsAre(1, 1, 0, 0, 0));
721  }
722  TEST(MutatingTest, Generate) {
723    std::vector<int> actual(5);
724    int x = 0;
725    absl::c_generate(actual, [&x]() { return ++x; });
<span onclick='openModal()' class='match'>726    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 4, 5));
727  }
</span>728  TEST(MutatingTest, GenerateN) {
729    std::vector<int> actual(5, 0);
730    int x = 0;
731    absl::c_generate_n(actual, 3, [&x]() { return ++x; });
732    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 0, 0));
733  }
734  TEST(MutatingTest, RemoveCopy) {
735    std::vector<int> actual;
736    absl::c_remove_copy(std::vector<int>{1, 2, 3}, back_inserter(actual), 2);
737    EXPECT_THAT(actual, ElementsAre(1, 3));
738  }
739  TEST(MutatingTest, RemoveCopyIf) {
740    std::vector<int> actual;
741    absl::c_remove_copy_if(std::vector<int>{1, 2, 3}, back_inserter(actual),
742                           IsOdd);
743    EXPECT_THAT(actual, ElementsAre(2));
744  }
745  TEST(MutatingTest, UniqueCopy) {
746    std::vector<int> actual;
747    absl::c_unique_copy(std::vector<int>{1, 2, 2, 2, 3, 3, 2},
748                        back_inserter(actual));
749    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 2));
750  }
751  TEST(MutatingTest, UniqueCopyWithPredicate) {
752    std::vector<int> actual;
753    absl::c_unique_copy(std::vector<int>{1, 2, 3, -1, -2, -3, 1},
754                        back_inserter(actual),
755                        [](int x, int y) { return (x < 0) == (y < 0); });
756    EXPECT_THAT(actual, ElementsAre(1, -1, 1));
757  }
758  TEST(MutatingTest, Reverse) {
759    std::vector<int> test_vector = {1, 2, 3, 4};
760    absl::c_reverse(test_vector);
761    EXPECT_THAT(test_vector, ElementsAre(4, 3, 2, 1));
762    std::list<int> test_list = {1, 2, 3, 4};
763    absl::c_reverse(test_list);
764    EXPECT_THAT(test_list, ElementsAre(4, 3, 2, 1));
765  }
766  TEST(MutatingTest, ReverseCopy) {
767    std::vector<int> actual;
768    absl::c_reverse_copy(std::vector<int>{1, 2, 3, 4}, back_inserter(actual));
769    EXPECT_THAT(actual, ElementsAre(4, 3, 2, 1));
770  }
771  TEST(MutatingTest, Rotate) {
772    std::vector<int> actual = {1, 2, 3, 4};
773    auto it = absl::c_rotate(actual, actual.begin() + 2);
774    EXPECT_THAT(actual, testing::ElementsAreArray({3, 4, 1, 2}));
775    EXPECT_EQ(*it, 1);
776  }
777  TEST(MutatingTest, RotateCopy) {
778    std::vector<int> initial = {1, 2, 3, 4};
779    std::vector<int> actual;
780    auto end =
781        absl::c_rotate_copy(initial, initial.begin() + 2, back_inserter(actual));
782    *end = 5;
783    EXPECT_THAT(actual, ElementsAre(3, 4, 1, 2, 5));
784  }
785  TEST(MutatingTest, Shuffle) {
786    std::vector<int> actual = {1, 2, 3, 4, 5};
787    absl::c_shuffle(actual, std::random_device());
788    EXPECT_THAT(actual, UnorderedElementsAre(1, 2, 3, 4, 5));
789  }
790  TEST(MutatingTest, PartialSort) {
791    std::vector<int> sequence{5, 3, 42, 0};
792    absl::c_partial_sort(sequence, sequence.begin() + 2);
793    EXPECT_THAT(absl::MakeSpan(sequence.data(), 2), ElementsAre(0, 3));
794    absl::c_partial_sort(sequence, sequence.begin() + 2, std::greater<int>());
795    EXPECT_THAT(absl::MakeSpan(sequence.data(), 2), ElementsAre(42, 5));
796  }
797  TEST(MutatingTest, PartialSortCopy) {
798    const std::vector<int> initial = {5, 3, 42, 0};
799    std::vector<int> actual(2);
800    absl::c_partial_sort_copy(initial, actual);
801    EXPECT_THAT(actual, ElementsAre(0, 3));
802    absl::c_partial_sort_copy(initial, actual, std::greater<int>());
803    EXPECT_THAT(actual, ElementsAre(42, 5));
804  }
805  TEST(MutatingTest, Merge) {
806    std::vector<int> actual;
807    absl::c_merge(std::vector<int>{1, 3, 5}, std::vector<int>{2, 4},
808                  back_inserter(actual));
809    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 4, 5));
810  }
811  TEST(MutatingTest, MergeWithComparator) {
812    std::vector<int> actual;
813    absl::c_merge(std::vector<int>{5, 3, 1}, std::vector<int>{4, 2},
814                  back_inserter(actual), std::greater<int>());
815    EXPECT_THAT(actual, ElementsAre(5, 4, 3, 2, 1));
816  }
817  TEST(MutatingTest, InplaceMerge) {
818    std::vector<int> actual = {1, 3, 5, 2, 4};
819    absl::c_inplace_merge(actual, actual.begin() + 3);
820    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 4, 5));
821  }
822  TEST(MutatingTest, InplaceMergeWithComparator) {
823    std::vector<int> actual = {5, 3, 1, 4, 2};
824    absl::c_inplace_merge(actual, actual.begin() + 3, std::greater<int>());
825    EXPECT_THAT(actual, ElementsAre(5, 4, 3, 2, 1));
826  }
827  class SetOperationsTest : public testing::Test {
828   protected:
829    std::vector<int> a_ = {1, 2, 3};
830    std::vector<int> b_ = {1, 3, 5};
831    std::vector<int> a_reversed_ = {3, 2, 1};
832    std::vector<int> b_reversed_ = {5, 3, 1};
833  };
834  TEST_F(SetOperationsTest, SetUnion) {
835    std::vector<int> actual;
836    absl::c_set_union(a_, b_, back_inserter(actual));
837    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 5));
838  }
839  TEST_F(SetOperationsTest, SetUnionWithComparator) {
840    std::vector<int> actual;
841    absl::c_set_union(a_reversed_, b_reversed_, back_inserter(actual),
842                      std::greater<int>());
843    EXPECT_THAT(actual, ElementsAre(5, 3, 2, 1));
844  }
845  TEST_F(SetOperationsTest, SetIntersection) {
846    std::vector<int> actual;
847    absl::c_set_intersection(a_, b_, back_inserter(actual));
848    EXPECT_THAT(actual, ElementsAre(1, 3));
849  }
850  TEST_F(SetOperationsTest, SetIntersectionWithComparator) {
851    std::vector<int> actual;
852    absl::c_set_intersection(a_reversed_, b_reversed_, back_inserter(actual),
853                             std::greater<int>());
854    EXPECT_THAT(actual, ElementsAre(3, 1));
855  }
856  TEST_F(SetOperationsTest, SetDifference) {
857    std::vector<int> actual;
858    absl::c_set_difference(a_, b_, back_inserter(actual));
859    EXPECT_THAT(actual, ElementsAre(2));
860  }
861  TEST_F(SetOperationsTest, SetDifferenceWithComparator) {
862    std::vector<int> actual;
863    absl::c_set_difference(a_reversed_, b_reversed_, back_inserter(actual),
864                           std::greater<int>());
865    EXPECT_THAT(actual, ElementsAre(2));
866  }
867  TEST_F(SetOperationsTest, SetSymmetricDifference) {
868    std::vector<int> actual;
869    absl::c_set_symmetric_difference(a_, b_, back_inserter(actual));
870    EXPECT_THAT(actual, ElementsAre(2, 5));
871  }
872  TEST_F(SetOperationsTest, SetSymmetricDifferenceWithComparator) {
873    std::vector<int> actual;
874    absl::c_set_symmetric_difference(a_reversed_, b_reversed_,
875                                     back_inserter(actual), std::greater<int>());
876    EXPECT_THAT(actual, ElementsAre(5, 2));
877  }
878  TEST(HeapOperationsTest, WithoutComparator) {
879    std::vector<int> heap = {1, 2, 3};
880    EXPECT_FALSE(absl::c_is_heap(heap));
881    absl::c_make_heap(heap);
882    EXPECT_TRUE(absl::c_is_heap(heap));
883    heap.push_back(4);
884    EXPECT_EQ(3, absl::c_is_heap_until(heap) - heap.begin());
885    absl::c_push_heap(heap);
886    EXPECT_EQ(4, heap[0]);
887    absl::c_pop_heap(heap);
888    EXPECT_EQ(4, heap[3]);
889    absl::c_make_heap(heap);
890    absl::c_sort_heap(heap);
891    EXPECT_THAT(heap, ElementsAre(1, 2, 3, 4));
892    EXPECT_FALSE(absl::c_is_heap(heap));
893  }
894  TEST(HeapOperationsTest, WithComparator) {
895    using greater = std::greater<int>;
896    std::vector<int> heap = {3, 2, 1};
897    EXPECT_FALSE(absl::c_is_heap(heap, greater()));
898    absl::c_make_heap(heap, greater());
899    EXPECT_TRUE(absl::c_is_heap(heap, greater()));
900    heap.push_back(0);
901    EXPECT_EQ(3, absl::c_is_heap_until(heap, greater()) - heap.begin());
902    absl::c_push_heap(heap, greater());
903    EXPECT_EQ(0, heap[0]);
904    absl::c_pop_heap(heap, greater());
905    EXPECT_EQ(0, heap[3]);
906    absl::c_make_heap(heap, greater());
907    absl::c_sort_heap(heap, greater());
908    EXPECT_THAT(heap, ElementsAre(3, 2, 1, 0));
909    EXPECT_FALSE(absl::c_is_heap(heap, greater()));
910  }
911  TEST(MutatingTest, PermutationOperations) {
912    std::vector<int> initial = {1, 2, 3, 4};
913    std::vector<int> permuted = initial;
914    absl::c_next_permutation(permuted);
915    EXPECT_TRUE(absl::c_is_permutation(initial, permuted));
916    EXPECT_TRUE(absl::c_is_permutation(initial, permuted, std::equal_to<int>()));
917    std::vector<int> permuted2 = initial;
918    absl::c_prev_permutation(permuted2, std::greater<int>());
919    EXPECT_EQ(permuted, permuted2);
920    absl::c_prev_permutation(permuted);
921    EXPECT_EQ(initial, permuted);
922  }
923  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container_test.cc</h3>
            <pre><code>1  #include "absl/algorithm/container.h"
2  #include <functional>
3  #include <initializer_list>
4  #include <iterator>
5  #include <list>
6  #include <memory>
7  #include <ostream>
8  #include <random>
9  #include <set>
10  #include <unordered_set>
11  #include <utility>
12  #include <valarray>
13  #include <vector>
14  #include "gmock/gmock.h"
15  #include "gtest/gtest.h"
16  #include "absl/base/casts.h"
17  #include "absl/base/macros.h"
18  #include "absl/memory/memory.h"
19  #include "absl/types/span.h"
20  namespace {
21  using ::testing::Each;
22  using ::testing::ElementsAre;
23  using ::testing::Gt;
24  using ::testing::IsNull;
25  using ::testing::Lt;
26  using ::testing::Pointee;
27  using ::testing::Truly;
28  using ::testing::UnorderedElementsAre;
29  class NonMutatingTest : public testing::Test {
30   protected:
31    std::unordered_set<int> container_ = {1, 2, 3};
32    std::list<int> sequence_ = {1, 2, 3};
33    std::vector<int> vector_ = {1, 2, 3};
34    int array_[3] = {1, 2, 3};
35  };
36  struct AccumulateCalls {
37    void operator()(int value) { calls.push_back(value); }
38    std::vector<int> calls;
39  };
40  bool Predicate(int value) { return value < 3; }
41  bool BinPredicate(int v1, int v2) { return v1 < v2; }
42  bool Equals(int v1, int v2) { return v1 == v2; }
43  bool IsOdd(int x) { return x % 2 != 0; }
44  TEST_F(NonMutatingTest, Distance) {
45    EXPECT_EQ(container_.size(),
46              static_cast<size_t>(absl::c_distance(container_)));
47    EXPECT_EQ(sequence_.size(), static_cast<size_t>(absl::c_distance(sequence_)));
48    EXPECT_EQ(vector_.size(), static_cast<size_t>(absl::c_distance(vector_)));
49    EXPECT_EQ(ABSL_ARRAYSIZE(array_),
50              static_cast<size_t>(absl::c_distance(array_)));
51    EXPECT_EQ(vector_.size(),
52              static_cast<size_t>(absl::c_distance(std::vector<int>(vector_))));
53  }
54  TEST_F(NonMutatingTest, Distance_OverloadedBeginEnd) {
55    std::initializer_list<int> a = {1, 2, 3};
56    std::valarray<int> b = {1, 2, 3};
57    EXPECT_EQ(3, absl::c_distance(a));
58    EXPECT_EQ(3, absl::c_distance(b));
59  }
60  TEST_F(NonMutatingTest, ForEach) {
61    AccumulateCalls c = absl::c_for_each(container_, AccumulateCalls());
62    std::sort(c.calls.begin(), c.calls.end());
63    EXPECT_EQ(vector_, c.calls);
64    AccumulateCalls c2 =
65        absl::c_for_each(std::unordered_set<int>(container_), AccumulateCalls());
66    std::sort(c2.calls.begin(), c2.calls.end());
67    EXPECT_EQ(vector_, c2.calls);
68  }
69  TEST_F(NonMutatingTest, FindReturnsCorrectType) {
70    auto it = absl::c_find(container_, 3);
71    EXPECT_EQ(3, *it);
72    absl::c_find(absl::implicit_cast<const std::list<int>&>(sequence_), 3);
73  }
74  TEST_F(NonMutatingTest, FindIf) { absl::c_find_if(container_, Predicate); }
75  TEST_F(NonMutatingTest, FindIfNot) {
76    absl::c_find_if_not(container_, Predicate);
77  }
78  TEST_F(NonMutatingTest, FindEnd) {
79    absl::c_find_end(sequence_, vector_);
80    absl::c_find_end(vector_, sequence_);
81  }
82  TEST_F(NonMutatingTest, FindEndWithPredicate) {
83    absl::c_find_end(sequence_, vector_, BinPredicate);
84    absl::c_find_end(vector_, sequence_, BinPredicate);
85  }
86  TEST_F(NonMutatingTest, FindFirstOf) {
87    absl::c_find_first_of(container_, sequence_);
88    absl::c_find_first_of(sequence_, container_);
89  }
90  TEST_F(NonMutatingTest, FindFirstOfWithPredicate) {
91    absl::c_find_first_of(container_, sequence_, BinPredicate);
92    absl::c_find_first_of(sequence_, container_, BinPredicate);
93  }
94  TEST_F(NonMutatingTest, AdjacentFind) { absl::c_adjacent_find(sequence_); }
95  TEST_F(NonMutatingTest, AdjacentFindWithPredicate) {
96    absl::c_adjacent_find(sequence_, BinPredicate);
97  }
98  TEST_F(NonMutatingTest, Count) { EXPECT_EQ(1, absl::c_count(container_, 3)); }
99  TEST_F(NonMutatingTest, CountIf) {
100    EXPECT_EQ(2, absl::c_count_if(container_, Predicate));
101    const std::unordered_set<int>& const_container = container_;
102    EXPECT_EQ(2, absl::c_count_if(const_container, Predicate));
103  }
104  TEST_F(NonMutatingTest, Mismatch) {
105    {
106      auto result = absl::c_mismatch(vector_, sequence_);
107      EXPECT_EQ(result.first, vector_.end());
108      EXPECT_EQ(result.second, sequence_.end());
109    }
110    {
111      auto result = absl::c_mismatch(sequence_, vector_);
112      EXPECT_EQ(result.first, sequence_.end());
113      EXPECT_EQ(result.second, vector_.end());
114    }
115    sequence_.back() = 5;
116    {
117      auto result = absl::c_mismatch(vector_, sequence_);
118      EXPECT_EQ(result.first, std::prev(vector_.end()));
119      EXPECT_EQ(result.second, std::prev(sequence_.end()));
120    }
121    {
122      auto result = absl::c_mismatch(sequence_, vector_);
123      EXPECT_EQ(result.first, std::prev(sequence_.end()));
124      EXPECT_EQ(result.second, std::prev(vector_.end()));
125    }
126    sequence_.pop_back();
127    {
128      auto result = absl::c_mismatch(vector_, sequence_);
129      EXPECT_EQ(result.first, std::prev(vector_.end()));
130      EXPECT_EQ(result.second, sequence_.end());
131    }
132    {
133      auto result = absl::c_mismatch(sequence_, vector_);
134      EXPECT_EQ(result.first, sequence_.end());
135      EXPECT_EQ(result.second, std::prev(vector_.end()));
136    }
137    {
138      struct NoNotEquals {
139        constexpr bool operator==(NoNotEquals) const { return true; }
140        constexpr bool operator!=(NoNotEquals) const = delete;
141      };
142      std::vector<NoNotEquals> first;
143      std::list<NoNotEquals> second;
144      absl::c_mismatch(first, second);
145    }
146  }
147  TEST_F(NonMutatingTest, MismatchWithPredicate) {
148    {
149      auto result = absl::c_mismatch(vector_, sequence_, BinPredicate);
150      EXPECT_EQ(result.first, vector_.begin());
151      EXPECT_EQ(result.second, sequence_.begin());
152    }
153    {
154      auto result = absl::c_mismatch(sequence_, vector_, BinPredicate);
155      EXPECT_EQ(result.first, sequence_.begin());
156      EXPECT_EQ(result.second, vector_.begin());
157    }
158    sequence_.front() = 0;
159    {
160      auto result = absl::c_mismatch(vector_, sequence_, BinPredicate);
161      EXPECT_EQ(result.first, vector_.begin());
162      EXPECT_EQ(result.second, sequence_.begin());
163    }
164    {
165      auto result = absl::c_mismatch(sequence_, vector_, BinPredicate);
166      EXPECT_EQ(result.first, std::next(sequence_.begin()));
167      EXPECT_EQ(result.second, std::next(vector_.begin()));
168    }
169    sequence_.clear();
170    {
171      auto result = absl::c_mismatch(vector_, sequence_, BinPredicate);
172      EXPECT_EQ(result.first, vector_.begin());
173      EXPECT_EQ(result.second, sequence_.end());
174    }
175    {
176      auto result = absl::c_mismatch(sequence_, vector_, BinPredicate);
177      EXPECT_EQ(result.first, sequence_.end());
178      EXPECT_EQ(result.second, vector_.begin());
179    }
180  }
181  TEST_F(NonMutatingTest, Equal) {
182    EXPECT_TRUE(absl::c_equal(vector_, sequence_));
183    EXPECT_TRUE(absl::c_equal(sequence_, vector_));
184    EXPECT_TRUE(absl::c_equal(sequence_, array_));
185    EXPECT_TRUE(absl::c_equal(array_, vector_));
186    std::vector<int> vector_plus = {1, 2, 3};
187    vector_plus.push_back(4);
188    EXPECT_FALSE(absl::c_equal(vector_plus, sequence_));
189    EXPECT_FALSE(absl::c_equal(sequence_, vector_plus));
190    EXPECT_FALSE(absl::c_equal(array_, vector_plus));
191  }
192  TEST_F(NonMutatingTest, EqualWithPredicate) {
193    EXPECT_TRUE(absl::c_equal(vector_, sequence_, Equals));
194    EXPECT_TRUE(absl::c_equal(sequence_, vector_, Equals));
195    EXPECT_TRUE(absl::c_equal(array_, sequence_, Equals));
196    EXPECT_TRUE(absl::c_equal(vector_, array_, Equals));
197    std::vector<int> vector_plus = {1, 2, 3};
198    vector_plus.push_back(4);
199    EXPECT_FALSE(absl::c_equal(vector_plus, sequence_, Equals));
200    EXPECT_FALSE(absl::c_equal(sequence_, vector_plus, Equals));
201    EXPECT_FALSE(absl::c_equal(vector_plus, array_, Equals));
202  }
203  TEST_F(NonMutatingTest, IsPermutation) {
204    auto vector_permut_ = vector_;
205    std::next_permutation(vector_permut_.begin(), vector_permut_.end());
206    EXPECT_TRUE(absl::c_is_permutation(vector_permut_, sequence_));
207    EXPECT_TRUE(absl::c_is_permutation(sequence_, vector_permut_));
208    std::vector<int> vector_plus = {1, 2, 3};
209    vector_plus.push_back(4);
210    EXPECT_FALSE(absl::c_is_permutation(vector_plus, sequence_));
211    EXPECT_FALSE(absl::c_is_permutation(sequence_, vector_plus));
212  }
213  TEST_F(NonMutatingTest, IsPermutationWithPredicate) {
214    auto vector_permut_ = vector_;
215    std::next_permutation(vector_permut_.begin(), vector_permut_.end());
216    EXPECT_TRUE(absl::c_is_permutation(vector_permut_, sequence_, Equals));
217    EXPECT_TRUE(absl::c_is_permutation(sequence_, vector_permut_, Equals));
218    std::vector<int> vector_plus = {1, 2, 3};
219    vector_plus.push_back(4);
220    EXPECT_FALSE(absl::c_is_permutation(vector_plus, sequence_, Equals));
221    EXPECT_FALSE(absl::c_is_permutation(sequence_, vector_plus, Equals));
222  }
223  TEST_F(NonMutatingTest, Search) {
224    absl::c_search(sequence_, vector_);
225    absl::c_search(vector_, sequence_);
226    absl::c_search(array_, sequence_);
227  }
228  TEST_F(NonMutatingTest, SearchWithPredicate) {
229    absl::c_search(sequence_, vector_, BinPredicate);
230    absl::c_search(vector_, sequence_, BinPredicate);
231  }
232  TEST_F(NonMutatingTest, SearchN) { absl::c_search_n(sequence_, 3, 1); }
233  TEST_F(NonMutatingTest, SearchNWithPredicate) {
234    absl::c_search_n(sequence_, 3, 1, BinPredicate);
235  }
236  TEST_F(NonMutatingTest, LowerBound) {
237    std::list<int>::iterator i = absl::c_lower_bound(sequence_, 3);
238    ASSERT_TRUE(i != sequence_.end());
239    EXPECT_EQ(2, std::distance(sequence_.begin(), i));
240    EXPECT_EQ(3, *i);
241  }
242  TEST_F(NonMutatingTest, LowerBoundWithPredicate) {
243    std::vector<int> v(vector_);
244    std::sort(v.begin(), v.end(), std::greater<int>());
245    std::vector<int>::iterator i = absl::c_lower_bound(v, 3, std::greater<int>());
246    EXPECT_TRUE(i == v.begin());
247    EXPECT_EQ(3, *i);
248  }
249  TEST_F(NonMutatingTest, UpperBound) {
250    std::list<int>::iterator i = absl::c_upper_bound(sequence_, 1);
251    ASSERT_TRUE(i != sequence_.end());
252    EXPECT_EQ(1, std::distance(sequence_.begin(), i));
253    EXPECT_EQ(2, *i);
254  }
255  TEST_F(NonMutatingTest, UpperBoundWithPredicate) {
256    std::vector<int> v(vector_);
257    std::sort(v.begin(), v.end(), std::greater<int>());
258    std::vector<int>::iterator i = absl::c_upper_bound(v, 1, std::greater<int>());
259    EXPECT_EQ(3, i - v.begin());
260    EXPECT_TRUE(i == v.end());
261  }
262  TEST_F(NonMutatingTest, EqualRange) {
263    std::pair<std::list<int>::iterator, std::list<int>::iterator> p =
264        absl::c_equal_range(sequence_, 2);
265    EXPECT_EQ(1, std::distance(sequence_.begin(), p.first));
266    EXPECT_EQ(2, std::distance(sequence_.begin(), p.second));
267  }
268  TEST_F(NonMutatingTest, EqualRangeArray) {
269    auto p = absl::c_equal_range(array_, 2);
270    EXPECT_EQ(1, std::distance(std::begin(array_), p.first));
271    EXPECT_EQ(2, std::distance(std::begin(array_), p.second));
272  }
273  TEST_F(NonMutatingTest, EqualRangeWithPredicate) {
274    std::vector<int> v(vector_);
275    std::sort(v.begin(), v.end(), std::greater<int>());
276    std::pair<std::vector<int>::iterator, std::vector<int>::iterator> p =
277        absl::c_equal_range(v, 2, std::greater<int>());
278    EXPECT_EQ(1, std::distance(v.begin(), p.first));
279    EXPECT_EQ(2, std::distance(v.begin(), p.second));
280  }
281  TEST_F(NonMutatingTest, BinarySearch) {
282    EXPECT_TRUE(absl::c_binary_search(vector_, 2));
283    EXPECT_TRUE(absl::c_binary_search(std::vector<int>(vector_), 2));
284  }
285  TEST_F(NonMutatingTest, BinarySearchWithPredicate) {
286    std::vector<int> v(vector_);
287    std::sort(v.begin(), v.end(), std::greater<int>());
288    EXPECT_TRUE(absl::c_binary_search(v, 2, std::greater<int>()));
289    EXPECT_TRUE(
290        absl::c_binary_search(std::vector<int>(v), 2, std::greater<int>()));
291  }
292  TEST_F(NonMutatingTest, MinElement) {
293    std::list<int>::iterator i = absl::c_min_element(sequence_);
294    ASSERT_TRUE(i != sequence_.end());
295    EXPECT_EQ(*i, 1);
296  }
297  TEST_F(NonMutatingTest, MinElementWithPredicate) {
298    std::list<int>::iterator i =
299        absl::c_min_element(sequence_, std::greater<int>());
300    ASSERT_TRUE(i != sequence_.end());
301    EXPECT_EQ(*i, 3);
302  }
303  TEST_F(NonMutatingTest, MaxElement) {
304    std::list<int>::iterator i = absl::c_max_element(sequence_);
305    ASSERT_TRUE(i != sequence_.end());
306    EXPECT_EQ(*i, 3);
307  }
308  TEST_F(NonMutatingTest, MaxElementWithPredicate) {
309    std::list<int>::iterator i =
310        absl::c_max_element(sequence_, std::greater<int>());
311    ASSERT_TRUE(i != sequence_.end());
312    EXPECT_EQ(*i, 1);
313  }
314  TEST_F(NonMutatingTest, LexicographicalCompare) {
315    EXPECT_FALSE(absl::c_lexicographical_compare(sequence_, sequence_));
316    std::vector<int> v;
317    v.push_back(1);
318    v.push_back(2);
319    v.push_back(4);
320    EXPECT_TRUE(absl::c_lexicographical_compare(sequence_, v));
321    EXPECT_TRUE(absl::c_lexicographical_compare(std::list<int>(sequence_), v));
322  }
323  TEST_F(NonMutatingTest, LexicographicalCopmareWithPredicate) {
324    EXPECT_FALSE(absl::c_lexicographical_compare(sequence_, sequence_,
325                                                 std::greater<int>()));
326    std::vector<int> v;
327    v.push_back(1);
328    v.push_back(2);
329    v.push_back(4);
330    EXPECT_TRUE(
331        absl::c_lexicographical_compare(v, sequence_, std::greater<int>()));
332    EXPECT_TRUE(absl::c_lexicographical_compare(
333        std::vector<int>(v), std::list<int>(sequence_), std::greater<int>()));
334  }
335  TEST_F(NonMutatingTest, Includes) {
336    std::set<int> s(vector_.begin(), vector_.end());
337    s.insert(4);
338    EXPECT_TRUE(absl::c_includes(s, vector_));
339  }
340  TEST_F(NonMutatingTest, IncludesWithPredicate) {
341    std::vector<int> v = {3, 2, 1};
342    std::set<int, std::greater<int>> s(v.begin(), v.end());
343    s.insert(4);
344    EXPECT_TRUE(absl::c_includes(s, v, std::greater<int>()));
345  }
346  class NumericMutatingTest : public testing::Test {
347   protected:
348    std::list<int> list_ = {1, 2, 3};
349    std::vector<int> output_;
350  };
351  TEST_F(NumericMutatingTest, Iota) {
352    absl::c_iota(list_, 5);
353    std::list<int> expected{5, 6, 7};
354    EXPECT_EQ(list_, expected);
355  }
356  TEST_F(NonMutatingTest, Accumulate) {
357    EXPECT_EQ(absl::c_accumulate(sequence_, 4), 1 + 2 + 3 + 4);
358  }
359  TEST_F(NonMutatingTest, AccumulateWithBinaryOp) {
360    EXPECT_EQ(absl::c_accumulate(sequence_, 4, std::multiplies<int>()),
361              1 * 2 * 3 * 4);
362  }
363  TEST_F(NonMutatingTest, AccumulateLvalueInit) {
364    int lvalue = 4;
365    EXPECT_EQ(absl::c_accumulate(sequence_, lvalue), 1 + 2 + 3 + 4);
366  }
367  TEST_F(NonMutatingTest, AccumulateWithBinaryOpLvalueInit) {
368    int lvalue = 4;
369    EXPECT_EQ(absl::c_accumulate(sequence_, lvalue, std::multiplies<int>()),
370              1 * 2 * 3 * 4);
371  }
372  TEST_F(NonMutatingTest, InnerProduct) {
373    EXPECT_EQ(absl::c_inner_product(sequence_, vector_, 1000),
374              1000 + 1 * 1 + 2 * 2 + 3 * 3);
375  }
376  TEST_F(NonMutatingTest, InnerProductWithBinaryOps) {
377    EXPECT_EQ(absl::c_inner_product(sequence_, vector_, 10,
378                                    std::multiplies<int>(), std::plus<int>()),
379              10 * (1 + 1) * (2 + 2) * (3 + 3));
380  }
381  TEST_F(NonMutatingTest, InnerProductLvalueInit) {
382    int lvalue = 1000;
383    EXPECT_EQ(absl::c_inner_product(sequence_, vector_, lvalue),
384              1000 + 1 * 1 + 2 * 2 + 3 * 3);
385  }
386  TEST_F(NonMutatingTest, InnerProductWithBinaryOpsLvalueInit) {
387    int lvalue = 10;
388    EXPECT_EQ(absl::c_inner_product(sequence_, vector_, lvalue,
389                                    std::multiplies<int>(), std::plus<int>()),
390              10 * (1 + 1) * (2 + 2) * (3 + 3));
391  }
392  TEST_F(NumericMutatingTest, AdjacentDifference) {
393    auto last = absl::c_adjacent_difference(list_, std::back_inserter(output_));
394    *last = 1000;
395    std::vector<int> expected{1, 2 - 1, 3 - 2, 1000};
396    EXPECT_EQ(output_, expected);
397  }
398  TEST_F(NumericMutatingTest, AdjacentDifferenceWithBinaryOp) {
399    auto last = absl::c_adjacent_difference(list_, std::back_inserter(output_),
400                                            std::multiplies<int>());
401    *last = 1000;
402    std::vector<int> expected{1, 2 * 1, 3 * 2, 1000};
403    EXPECT_EQ(output_, expected);
404  }
405  TEST_F(NumericMutatingTest, PartialSum) {
406    auto last = absl::c_partial_sum(list_, std::back_inserter(output_));
407    *last = 1000;
408    std::vector<int> expected{1, 1 + 2, 1 + 2 + 3, 1000};
409    EXPECT_EQ(output_, expected);
410  }
411  TEST_F(NumericMutatingTest, PartialSumWithBinaryOp) {
412    auto last = absl::c_partial_sum(list_, std::back_inserter(output_),
413                                    std::multiplies<int>());
414    *last = 1000;
415    std::vector<int> expected{1, 1 * 2, 1 * 2 * 3, 1000};
416    EXPECT_EQ(output_, expected);
417  }
418  TEST_F(NonMutatingTest, LinearSearch) {
419    EXPECT_TRUE(absl::c_linear_search(container_, 3));
420    EXPECT_FALSE(absl::c_linear_search(container_, 4));
421  }
422  TEST_F(NonMutatingTest, AllOf) {
423    const std::vector<int>& v = vector_;
424    EXPECT_FALSE(absl::c_all_of(v, [](int x) { return x > 1; }));
425    EXPECT_TRUE(absl::c_all_of(v, [](int x) { return x > 0; }));
426  }
427  TEST_F(NonMutatingTest, AnyOf) {
428    const std::vector<int>& v = vector_;
429    EXPECT_TRUE(absl::c_any_of(v, [](int x) { return x > 2; }));
430    EXPECT_FALSE(absl::c_any_of(v, [](int x) { return x > 5; }));
431  }
432  TEST_F(NonMutatingTest, NoneOf) {
433    const std::vector<int>& v = vector_;
434    EXPECT_FALSE(absl::c_none_of(v, [](int x) { return x > 2; }));
435    EXPECT_TRUE(absl::c_none_of(v, [](int x) { return x > 5; }));
436  }
437  TEST_F(NonMutatingTest, MinMaxElementLess) {
438    std::pair<std::vector<int>::const_iterator, std::vector<int>::const_iterator>
439        p = absl::c_minmax_element(vector_, std::less<int>());
440    EXPECT_TRUE(p.first == vector_.begin());
441    EXPECT_TRUE(p.second == vector_.begin() + 2);
442  }
443  TEST_F(NonMutatingTest, MinMaxElementGreater) {
444    std::pair<std::vector<int>::const_iterator, std::vector<int>::const_iterator>
445        p = absl::c_minmax_element(vector_, std::greater<int>());
446    EXPECT_TRUE(p.first == vector_.begin() + 2);
447    EXPECT_TRUE(p.second == vector_.begin());
448  }
449  TEST_F(NonMutatingTest, MinMaxElementNoPredicate) {
450    std::pair<std::vector<int>::const_iterator, std::vector<int>::const_iterator>
451        p = absl::c_minmax_element(vector_);
452    EXPECT_TRUE(p.first == vector_.begin());
453    EXPECT_TRUE(p.second == vector_.begin() + 2);
454  }
455  class SortingTest : public testing::Test {
456   protected:
457    std::list<int> sorted_ = {1, 2, 3, 4};
458    std::list<int> unsorted_ = {2, 4, 1, 3};
459    std::list<int> reversed_ = {4, 3, 2, 1};
460  };
461  TEST_F(SortingTest, IsSorted) {
462    EXPECT_TRUE(absl::c_is_sorted(sorted_));
463    EXPECT_FALSE(absl::c_is_sorted(unsorted_));
464    EXPECT_FALSE(absl::c_is_sorted(reversed_));
465  }
466  TEST_F(SortingTest, IsSortedWithPredicate) {
467    EXPECT_FALSE(absl::c_is_sorted(sorted_, std::greater<int>()));
468    EXPECT_FALSE(absl::c_is_sorted(unsorted_, std::greater<int>()));
469    EXPECT_TRUE(absl::c_is_sorted(reversed_, std::greater<int>()));
470  }
471  TEST_F(SortingTest, IsSortedUntil) {
472    EXPECT_EQ(1, *absl::c_is_sorted_until(unsorted_));
473    EXPECT_EQ(4, *absl::c_is_sorted_until(unsorted_, std::greater<int>()));
474  }
475  TEST_F(SortingTest, NthElement) {
476    std::vector<int> unsorted = {2, 4, 1, 3};
477    absl::c_nth_element(unsorted, unsorted.begin() + 2);
478    EXPECT_THAT(unsorted, ElementsAre(Lt(3), Lt(3), 3, Gt(3)));
479    absl::c_nth_element(unsorted, unsorted.begin() + 2, std::greater<int>());
480    EXPECT_THAT(unsorted, ElementsAre(Gt(2), Gt(2), 2, Lt(2)));
481  }
482  TEST(MutatingTest, IsPartitioned) {
483    EXPECT_TRUE(
484        absl::c_is_partitioned(std::vector<int>{1, 3, 5, 2, 4, 6}, IsOdd));
485    EXPECT_FALSE(
486        absl::c_is_partitioned(std::vector<int>{1, 2, 3, 4, 5, 6}, IsOdd));
487    EXPECT_FALSE(
488        absl::c_is_partitioned(std::vector<int>{2, 4, 6, 1, 3, 5}, IsOdd));
489  }
490  TEST(MutatingTest, Partition) {
491    std::vector<int> actual = {1, 2, 3, 4, 5};
492    absl::c_partition(actual, IsOdd);
493    EXPECT_THAT(actual, Truly([](const std::vector<int>& c) {
494                  return absl::c_is_partitioned(c, IsOdd);
495                }));
496  }
497  TEST(MutatingTest, StablePartition) {
498    std::vector<int> actual = {1, 2, 3, 4, 5};
499    absl::c_stable_partition(actual, IsOdd);
500    EXPECT_THAT(actual, ElementsAre(1, 3, 5, 2, 4));
501  }
502  TEST(MutatingTest, PartitionCopy) {
503    const std::vector<int> initial = {1, 2, 3, 4, 5};
504    std::vector<int> odds, evens;
505    auto ends = absl::c_partition_copy(initial, back_inserter(odds),
506                                       back_inserter(evens), IsOdd);
507    *ends.first = 7;
508    *ends.second = 6;
509    EXPECT_THAT(odds, ElementsAre(1, 3, 5, 7));
510    EXPECT_THAT(evens, ElementsAre(2, 4, 6));
511  }
512  TEST(MutatingTest, PartitionPoint) {
513    const std::vector<int> initial = {1, 3, 5, 2, 4};
514    auto middle = absl::c_partition_point(initial, IsOdd);
515    EXPECT_EQ(2, *middle);
516  }
517  TEST(MutatingTest, CopyMiddle) {
518    const std::vector<int> initial = {4, -1, -2, -3, 5};
519    const std::list<int> input = {1, 2, 3};
520    const std::vector<int> expected = {4, 1, 2, 3, 5};
521    std::list<int> test_list(initial.begin(), initial.end());
522    absl::c_copy(input, ++test_list.begin());
523    EXPECT_EQ(std::list<int>(expected.begin(), expected.end()), test_list);
524    std::vector<int> test_vector = initial;
525    absl::c_copy(input, test_vector.begin() + 1);
526    EXPECT_EQ(expected, test_vector);
527  }
528  TEST(MutatingTest, CopyFrontInserter) {
529    const std::list<int> initial = {4, 5};
530    const std::list<int> input = {1, 2, 3};
531    const std::list<int> expected = {3, 2, 1, 4, 5};
532    std::list<int> test_list = initial;
533    absl::c_copy(input, std::front_inserter(test_list));
534    EXPECT_EQ(expected, test_list);
535  }
536  TEST(MutatingTest, CopyBackInserter) {
537    const std::vector<int> initial = {4, 5};
538    const std::list<int> input = {1, 2, 3};
539    const std::vector<int> expected = {4, 5, 1, 2, 3};
540    std::list<int> test_list(initial.begin(), initial.end());
541    absl::c_copy(input, std::back_inserter(test_list));
542    EXPECT_EQ(std::list<int>(expected.begin(), expected.end()), test_list);
543    std::vector<int> test_vector = initial;
544    absl::c_copy(input, std::back_inserter(test_vector));
545    EXPECT_EQ(expected, test_vector);
546  }
547  TEST(MutatingTest, CopyN) {
548    const std::vector<int> initial = {1, 2, 3, 4, 5};
549    const std::vector<int> expected = {1, 2};
550    std::vector<int> actual;
551    absl::c_copy_n(initial, 2, back_inserter(actual));
552    EXPECT_EQ(expected, actual);
553  }
554  TEST(MutatingTest, CopyIf) {
555    const std::list<int> input = {1, 2, 3};
556    std::vector<int> output;
557    absl::c_copy_if(input, std::back_inserter(output),
558                    [](int i) { return i != 2; });
559    EXPECT_THAT(output, ElementsAre(1, 3));
560  }
561  TEST(MutatingTest, CopyBackward) {
562    std::vector<int> actual = {1, 2, 3, 4, 5};
563    std::vector<int> expected = {1, 2, 1, 2, 3};
564    absl::c_copy_backward(absl::MakeSpan(actual.data(), 3), actual.end());
565    EXPECT_EQ(expected, actual);
566  }
567  TEST(MutatingTest, Move) {
568    std::vector<std::unique_ptr<int>> src;
569    src.emplace_back(absl::make_unique<int>(1));
570    src.emplace_back(absl::make_unique<int>(2));
571    src.emplace_back(absl::make_unique<int>(3));
572    src.emplace_back(absl::make_unique<int>(4));
573    src.emplace_back(absl::make_unique<int>(5));
574    std::vector<std::unique_ptr<int>> dest = {};
575    absl::c_move(src, std::back_inserter(dest));
576    EXPECT_THAT(src, Each(IsNull()));
577    EXPECT_THAT(dest, ElementsAre(Pointee(1), Pointee(2), Pointee(3), Pointee(4),
578                                  Pointee(5)));
579  }
580  TEST(MutatingTest, MoveBackward) {
581    std::vector<std::unique_ptr<int>> actual;
582    actual.emplace_back(absl::make_unique<int>(1));
583    actual.emplace_back(absl::make_unique<int>(2));
584    actual.emplace_back(absl::make_unique<int>(3));
585    actual.emplace_back(absl::make_unique<int>(4));
586    actual.emplace_back(absl::make_unique<int>(5));
587    auto subrange = absl::MakeSpan(actual.data(), 3);
588    absl::c_move_backward(subrange, actual.end());
589    EXPECT_THAT(actual, ElementsAre(IsNull(), IsNull(), Pointee(1), Pointee(2),
590                                    Pointee(3)));
591  }
592  TEST(MutatingTest, MoveWithRvalue) {
593    auto MakeRValueSrc = [] {
594      std::vector<std::unique_ptr<int>> src;
595      src.emplace_back(absl::make_unique<int>(1));
596      src.emplace_back(absl::make_unique<int>(2));
597      src.emplace_back(absl::make_unique<int>(3));
598      return src;
599    };
600    std::vector<std::unique_ptr<int>> dest = MakeRValueSrc();
601    absl::c_move(MakeRValueSrc(), std::back_inserter(dest));
602    EXPECT_THAT(dest, ElementsAre(Pointee(1), Pointee(2), Pointee(3), Pointee(1),
603                                  Pointee(2), Pointee(3)));
604  }
605  TEST(MutatingTest, SwapRanges) {
606    std::vector<int> odds = {2, 4, 6};
607    std::vector<int> evens = {1, 3, 5};
608    absl::c_swap_ranges(odds, evens);
609    EXPECT_THAT(odds, ElementsAre(1, 3, 5));
610    EXPECT_THAT(evens, ElementsAre(2, 4, 6));
611    odds.pop_back();
612    absl::c_swap_ranges(odds, evens);
613    EXPECT_THAT(odds, ElementsAre(2, 4));
614    EXPECT_THAT(evens, ElementsAre(1, 3, 6));
615    absl::c_swap_ranges(evens, odds);
616    EXPECT_THAT(odds, ElementsAre(1, 3));
617    EXPECT_THAT(evens, ElementsAre(2, 4, 6));
618  }
619  TEST_F(NonMutatingTest, Transform) {
620    std::vector<int> x{0, 2, 4}, y, z;
621    auto end = absl::c_transform(x, back_inserter(y), std::negate<int>());
622    EXPECT_EQ(std::vector<int>({0, -2, -4}), y);
623    *end = 7;
624    EXPECT_EQ(std::vector<int>({0, -2, -4, 7}), y);
625    y = {1, 3, 0};
626    end = absl::c_transform(x, y, back_inserter(z), std::plus<int>());
627    EXPECT_EQ(std::vector<int>({1, 5, 4}), z);
628    *end = 7;
629    EXPECT_EQ(std::vector<int>({1, 5, 4, 7}), z);
630    z.clear();
631    y.pop_back();
632    end = absl::c_transform(x, y, std::back_inserter(z), std::plus<int>());
633    EXPECT_EQ(std::vector<int>({1, 5}), z);
634    *end = 7;
635    EXPECT_EQ(std::vector<int>({1, 5, 7}), z);
636    z.clear();
637    std::swap(x, y);
638    end = absl::c_transform(x, y, std::back_inserter(z), std::plus<int>());
639    EXPECT_EQ(std::vector<int>({1, 5}), z);
640    *end = 7;
641    EXPECT_EQ(std::vector<int>({1, 5, 7}), z);
642  }
643  TEST(MutatingTest, Replace) {
644    const std::vector<int> initial = {1, 2, 3, 1, 4, 5};
645    const std::vector<int> expected = {4, 2, 3, 4, 4, 5};
646    std::vector<int> test_vector = initial;
647    absl::c_replace(test_vector, 1, 4);
648    EXPECT_EQ(expected, test_vector);
649    std::list<int> test_list(initial.begin(), initial.end());
650    absl::c_replace(test_list, 1, 4);
651    EXPECT_EQ(std::list<int>(expected.begin(), expected.end()), test_list);
652  }
653  TEST(MutatingTest, ReplaceIf) {
654    std::vector<int> actual = {1, 2, 3, 4, 5};
655    const std::vector<int> expected = {0, 2, 0, 4, 0};
656    absl::c_replace_if(actual, IsOdd, 0);
657    EXPECT_EQ(expected, actual);
658  }
659  TEST(MutatingTest, ReplaceCopy) {
660    const std::vector<int> initial = {1, 2, 3, 1, 4, 5};
661    const std::vector<int> expected = {4, 2, 3, 4, 4, 5};
662    std::vector<int> actual;
663    absl::c_replace_copy(initial, back_inserter(actual), 1, 4);
664    EXPECT_EQ(expected, actual);
665  }
666  TEST(MutatingTest, Sort) {
667    std::vector<int> test_vector = {2, 3, 1, 4};
668    absl::c_sort(test_vector);
669    EXPECT_THAT(test_vector, ElementsAre(1, 2, 3, 4));
670  }
671  TEST(MutatingTest, SortWithPredicate) {
672    std::vector<int> test_vector = {2, 3, 1, 4};
673    absl::c_sort(test_vector, std::greater<int>());
674    EXPECT_THAT(test_vector, ElementsAre(4, 3, 2, 1));
675  }
676  struct Element {
677    int key;
678    int value;
679    friend bool operator<(const Element& e1, const Element& e2) {
680      return e1.key < e2.key;
681    }
682    friend std::ostream& operator<<(std::ostream& o, const Element& e) {
683      return o << "{" << e.key << ", " << e.value << "}";
684    }
685  };
686  MATCHER_P2(IsElement, key, value, "") {
687    return arg.key == key && arg.value == value;
688  }
689  TEST(MutatingTest, StableSort) {
690    std::vector<Element> test_vector = {{1, 1}, {2, 1}, {2, 0}, {1, 0}, {2, 2}};
691    absl::c_stable_sort(test_vector);
692    EXPECT_THAT(test_vector,
693                ElementsAre(IsElement(1, 1), IsElement(1, 0), IsElement(2, 1),
694                            IsElement(2, 0), IsElement(2, 2)));
695  }
696  TEST(MutatingTest, StableSortWithPredicate) {
697    std::vector<Element> test_vector = {{1, 1}, {2, 1}, {2, 0}, {1, 0}, {2, 2}};
698    absl::c_stable_sort(test_vector, [](const Element& e1, const Element& e2) {
699      return e2 < e1;
700    });
701    EXPECT_THAT(test_vector,
702                ElementsAre(IsElement(2, 1), IsElement(2, 0), IsElement(2, 2),
703                            IsElement(1, 1), IsElement(1, 0)));
704  }
705  TEST(MutatingTest, ReplaceCopyIf) {
706    const std::vector<int> initial = {1, 2, 3, 4, 5};
707    const std::vector<int> expected = {0, 2, 0, 4, 0};
708    std::vector<int> actual;
709    absl::c_replace_copy_if(initial, back_inserter(actual), IsOdd, 0);
710    EXPECT_EQ(expected, actual);
711  }
712  TEST(MutatingTest, Fill) {
713    std::vector<int> actual(5);
714    absl::c_fill(actual, 1);
715    EXPECT_THAT(actual, ElementsAre(1, 1, 1, 1, 1));
716  }
717  TEST(MutatingTest, FillN) {
718    std::vector<int> actual(5, 0);
719    absl::c_fill_n(actual, 2, 1);
720    EXPECT_THAT(actual, ElementsAre(1, 1, 0, 0, 0));
721  }
722  TEST(MutatingTest, Generate) {
723    std::vector<int> actual(5);
724    int x = 0;
725    absl::c_generate(actual, [&x]() { return ++x; });
726    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 4, 5));
727  }
728  TEST(MutatingTest, GenerateN) {
729    std::vector<int> actual(5, 0);
730    int x = 0;
731    absl::c_generate_n(actual, 3, [&x]() { return ++x; });
732    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 0, 0));
733  }
734  TEST(MutatingTest, RemoveCopy) {
735    std::vector<int> actual;
736    absl::c_remove_copy(std::vector<int>{1, 2, 3}, back_inserter(actual), 2);
737    EXPECT_THAT(actual, ElementsAre(1, 3));
738  }
739  TEST(MutatingTest, RemoveCopyIf) {
740    std::vector<int> actual;
741    absl::c_remove_copy_if(std::vector<int>{1, 2, 3}, back_inserter(actual),
742                           IsOdd);
743    EXPECT_THAT(actual, ElementsAre(2));
744  }
745  TEST(MutatingTest, UniqueCopy) {
746    std::vector<int> actual;
747    absl::c_unique_copy(std::vector<int>{1, 2, 2, 2, 3, 3, 2},
748                        back_inserter(actual));
749    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 2));
750  }
751  TEST(MutatingTest, UniqueCopyWithPredicate) {
752    std::vector<int> actual;
753    absl::c_unique_copy(std::vector<int>{1, 2, 3, -1, -2, -3, 1},
754                        back_inserter(actual),
755                        [](int x, int y) { return (x < 0) == (y < 0); });
756    EXPECT_THAT(actual, ElementsAre(1, -1, 1));
757  }
758  TEST(MutatingTest, Reverse) {
759    std::vector<int> test_vector = {1, 2, 3, 4};
760    absl::c_reverse(test_vector);
761    EXPECT_THAT(test_vector, ElementsAre(4, 3, 2, 1));
762    std::list<int> test_list = {1, 2, 3, 4};
763    absl::c_reverse(test_list);
764    EXPECT_THAT(test_list, ElementsAre(4, 3, 2, 1));
765  }
766  TEST(MutatingTest, ReverseCopy) {
767    std::vector<int> actual;
768    absl::c_reverse_copy(std::vector<int>{1, 2, 3, 4}, back_inserter(actual));
769    EXPECT_THAT(actual, ElementsAre(4, 3, 2, 1));
770  }
771  TEST(MutatingTest, Rotate) {
772    std::vector<int> actual = {1, 2, 3, 4};
773    auto it = absl::c_rotate(actual, actual.begin() + 2);
774    EXPECT_THAT(actual, testing::ElementsAreArray({3, 4, 1, 2}));
775    EXPECT_EQ(*it, 1);
776  }
777  TEST(MutatingTest, RotateCopy) {
778    std::vector<int> initial = {1, 2, 3, 4};
779    std::vector<int> actual;
780    auto end =
781        absl::c_rotate_copy(initial, initial.begin() + 2, back_inserter(actual));
782    *end = 5;
783    EXPECT_THAT(actual, ElementsAre(3, 4, 1, 2, 5));
784  }
785  TEST(MutatingTest, Shuffle) {
786    std::vector<int> actual = {1, 2, 3, 4, 5};
787    absl::c_shuffle(actual, std::random_device());
<span onclick='openModal()' class='match'>788    EXPECT_THAT(actual, UnorderedElementsAre(1, 2, 3, 4, 5));
789  }
</span>790  TEST(MutatingTest, PartialSort) {
791    std::vector<int> sequence{5, 3, 42, 0};
792    absl::c_partial_sort(sequence, sequence.begin() + 2);
793    EXPECT_THAT(absl::MakeSpan(sequence.data(), 2), ElementsAre(0, 3));
794    absl::c_partial_sort(sequence, sequence.begin() + 2, std::greater<int>());
795    EXPECT_THAT(absl::MakeSpan(sequence.data(), 2), ElementsAre(42, 5));
796  }
797  TEST(MutatingTest, PartialSortCopy) {
798    const std::vector<int> initial = {5, 3, 42, 0};
799    std::vector<int> actual(2);
800    absl::c_partial_sort_copy(initial, actual);
801    EXPECT_THAT(actual, ElementsAre(0, 3));
802    absl::c_partial_sort_copy(initial, actual, std::greater<int>());
803    EXPECT_THAT(actual, ElementsAre(42, 5));
804  }
805  TEST(MutatingTest, Merge) {
806    std::vector<int> actual;
807    absl::c_merge(std::vector<int>{1, 3, 5}, std::vector<int>{2, 4},
808                  back_inserter(actual));
809    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 4, 5));
810  }
811  TEST(MutatingTest, MergeWithComparator) {
812    std::vector<int> actual;
813    absl::c_merge(std::vector<int>{5, 3, 1}, std::vector<int>{4, 2},
814                  back_inserter(actual), std::greater<int>());
815    EXPECT_THAT(actual, ElementsAre(5, 4, 3, 2, 1));
816  }
817  TEST(MutatingTest, InplaceMerge) {
818    std::vector<int> actual = {1, 3, 5, 2, 4};
819    absl::c_inplace_merge(actual, actual.begin() + 3);
820    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 4, 5));
821  }
822  TEST(MutatingTest, InplaceMergeWithComparator) {
823    std::vector<int> actual = {5, 3, 1, 4, 2};
824    absl::c_inplace_merge(actual, actual.begin() + 3, std::greater<int>());
825    EXPECT_THAT(actual, ElementsAre(5, 4, 3, 2, 1));
826  }
827  class SetOperationsTest : public testing::Test {
828   protected:
829    std::vector<int> a_ = {1, 2, 3};
830    std::vector<int> b_ = {1, 3, 5};
831    std::vector<int> a_reversed_ = {3, 2, 1};
832    std::vector<int> b_reversed_ = {5, 3, 1};
833  };
834  TEST_F(SetOperationsTest, SetUnion) {
835    std::vector<int> actual;
836    absl::c_set_union(a_, b_, back_inserter(actual));
837    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 5));
838  }
839  TEST_F(SetOperationsTest, SetUnionWithComparator) {
840    std::vector<int> actual;
841    absl::c_set_union(a_reversed_, b_reversed_, back_inserter(actual),
842                      std::greater<int>());
843    EXPECT_THAT(actual, ElementsAre(5, 3, 2, 1));
844  }
845  TEST_F(SetOperationsTest, SetIntersection) {
846    std::vector<int> actual;
847    absl::c_set_intersection(a_, b_, back_inserter(actual));
848    EXPECT_THAT(actual, ElementsAre(1, 3));
849  }
850  TEST_F(SetOperationsTest, SetIntersectionWithComparator) {
851    std::vector<int> actual;
852    absl::c_set_intersection(a_reversed_, b_reversed_, back_inserter(actual),
853                             std::greater<int>());
854    EXPECT_THAT(actual, ElementsAre(3, 1));
855  }
856  TEST_F(SetOperationsTest, SetDifference) {
857    std::vector<int> actual;
858    absl::c_set_difference(a_, b_, back_inserter(actual));
859    EXPECT_THAT(actual, ElementsAre(2));
860  }
861  TEST_F(SetOperationsTest, SetDifferenceWithComparator) {
862    std::vector<int> actual;
863    absl::c_set_difference(a_reversed_, b_reversed_, back_inserter(actual),
864                           std::greater<int>());
865    EXPECT_THAT(actual, ElementsAre(2));
866  }
867  TEST_F(SetOperationsTest, SetSymmetricDifference) {
868    std::vector<int> actual;
869    absl::c_set_symmetric_difference(a_, b_, back_inserter(actual));
870    EXPECT_THAT(actual, ElementsAre(2, 5));
871  }
872  TEST_F(SetOperationsTest, SetSymmetricDifferenceWithComparator) {
873    std::vector<int> actual;
874    absl::c_set_symmetric_difference(a_reversed_, b_reversed_,
875                                     back_inserter(actual), std::greater<int>());
876    EXPECT_THAT(actual, ElementsAre(5, 2));
877  }
878  TEST(HeapOperationsTest, WithoutComparator) {
879    std::vector<int> heap = {1, 2, 3};
880    EXPECT_FALSE(absl::c_is_heap(heap));
881    absl::c_make_heap(heap);
882    EXPECT_TRUE(absl::c_is_heap(heap));
883    heap.push_back(4);
884    EXPECT_EQ(3, absl::c_is_heap_until(heap) - heap.begin());
885    absl::c_push_heap(heap);
886    EXPECT_EQ(4, heap[0]);
887    absl::c_pop_heap(heap);
888    EXPECT_EQ(4, heap[3]);
889    absl::c_make_heap(heap);
890    absl::c_sort_heap(heap);
891    EXPECT_THAT(heap, ElementsAre(1, 2, 3, 4));
892    EXPECT_FALSE(absl::c_is_heap(heap));
893  }
894  TEST(HeapOperationsTest, WithComparator) {
895    using greater = std::greater<int>;
896    std::vector<int> heap = {3, 2, 1};
897    EXPECT_FALSE(absl::c_is_heap(heap, greater()));
898    absl::c_make_heap(heap, greater());
899    EXPECT_TRUE(absl::c_is_heap(heap, greater()));
900    heap.push_back(0);
901    EXPECT_EQ(3, absl::c_is_heap_until(heap, greater()) - heap.begin());
902    absl::c_push_heap(heap, greater());
903    EXPECT_EQ(0, heap[0]);
904    absl::c_pop_heap(heap, greater());
905    EXPECT_EQ(0, heap[3]);
906    absl::c_make_heap(heap, greater());
907    absl::c_sort_heap(heap, greater());
908    EXPECT_THAT(heap, ElementsAre(3, 2, 1, 0));
909    EXPECT_FALSE(absl::c_is_heap(heap, greater()));
910  }
911  TEST(MutatingTest, PermutationOperations) {
912    std::vector<int> initial = {1, 2, 3, 4};
913    std::vector<int> permuted = initial;
914    absl::c_next_permutation(permuted);
915    EXPECT_TRUE(absl::c_is_permutation(initial, permuted));
916    EXPECT_TRUE(absl::c_is_permutation(initial, permuted, std::equal_to<int>()));
917    std::vector<int> permuted2 = initial;
918    absl::c_prev_permutation(permuted2, std::greater<int>());
919    EXPECT_EQ(permuted, permuted2);
920    absl::c_prev_permutation(permuted);
921    EXPECT_EQ(initial, permuted);
922  }
923  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>726    EXPECT_THAT(actual, ElementsAre(1, 2, 3, 4, 5));
727  }
</pre></code></div>
                <div class="column column_space"><pre><code>788    EXPECT_THAT(actual, UnorderedElementsAre(1, 2, 3, 4, 5));
789  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    