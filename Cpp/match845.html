<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_fileref.cpp & test_id3v2.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_fileref.cpp & test_id3v2.cpp
      </h3>
      <h1 align="center">
        12.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_fileref.cpp (32.88288%)<TH>test_id3v2.cpp (7.8579116%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match845-0.html#0',2,'match845-1.html#0',3)" NAME="0">(255-295)<TD><A HREF="javascript:ZweiFrames('match845-0.html#0',2,'match845-1.html#0',3)" NAME="0">(467-572)</A><TD ALIGN=center><FONT COLOR="#ff0000">34</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match845-0.html#1',2,'match845-1.html#1',3)" NAME="1">(295-310)<TD><A HREF="javascript:ZweiFrames('match845-0.html#1',2,'match845-1.html#1',3)" NAME="1">(715-765)</A><TD ALIGN=center><FONT COLOR="#700000">15</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match845-0.html#2',2,'match845-1.html#2',3)" NAME="2">(321-334)<TD><A HREF="javascript:ZweiFrames('match845-0.html#2',2,'match845-1.html#2',3)" NAME="2">(322-361)</A><TD ALIGN=center><FONT COLOR="#5a0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match845-0.html#3',2,'match845-1.html#3',3)" NAME="3">(236-250)<TD><A HREF="javascript:ZweiFrames('match845-0.html#3',2,'match845-1.html#3',3)" NAME="3">(773-800)</A><TD ALIGN=center><FONT COLOR="#5a0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_fileref.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/***************************************************************************
    copyright           : (C) 2007 by Lukas Lalinsky
    email               : lukas@oxygene.sk
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;tag.h&gt;
#include &lt;fileref.h&gt;
#include &lt;oggflacfile.h&gt;
#include &lt;vorbisfile.h&gt;
#include &lt;mpegfile.h&gt;
#include &lt;mpcfile.h&gt;
#include &lt;asffile.h&gt;
#include &lt;speexfile.h&gt;
#include &lt;flacfile.h&gt;
#include &lt;trueaudiofile.h&gt;
#include &lt;mp4file.h&gt;
#include &lt;wavfile.h&gt;
#include &lt;apefile.h&gt;
#include &lt;aifffile.h&gt;
#include &lt;wavpackfile.h&gt;
#include &lt;opusfile.h&gt;
#include &lt;xmfile.h&gt;
#include &lt;tfilestream.h&gt;
#include &lt;tbytevectorstream.h&gt;
#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &quot;utils.h&quot;

using namespace std;
using namespace TagLib;

namespace
{
  class DummyResolver : public FileRef::FileTypeResolver
  {
  public:
    virtual File *createFile(FileName fileName, bool, AudioProperties::ReadStyle) const
    {
      return new Ogg::Vorbis::File(fileName);
    }
  };

  class DummyStreamResolver : public FileRef::StreamTypeResolver
  {
  public:
    virtual File *createFile(FileName, bool, AudioProperties::ReadStyle) const
    {
      return 0;
    }

    virtual File *createFileFromStream(IOStream *s, bool, AudioProperties::ReadStyle) const
    {
      return new MP4::File(s);
    }
  };
}

class TestFileRef : public CppUnit::TestFixture
{
  CPPUNIT_TEST_SUITE(TestFileRef);
  CPPUNIT_TEST(testASF);
  CPPUNIT_TEST(testMusepack);
  CPPUNIT_TEST(testVorbis);
  CPPUNIT_TEST(testSpeex);
  CPPUNIT_TEST(testFLAC);
  CPPUNIT_TEST(testMP3);
  CPPUNIT_TEST(testOGA_FLAC);
  CPPUNIT_TEST(testOGA_Vorbis);
  CPPUNIT_TEST(testMP4_1);
  CPPUNIT_TEST(testMP4_2);
  CPPUNIT_TEST(testMP4_3);
  CPPUNIT_TEST(testMP4_4);
  CPPUNIT_TEST(testTrueAudio);
  CPPUNIT_TEST(testAPE);
  CPPUNIT_TEST(testWav);
  CPPUNIT_TEST(testAIFF_1);
  CPPUNIT_TEST(testAIFF_2);
  CPPUNIT_TEST(testWavPack);
  CPPUNIT_TEST(testOpus);
  CPPUNIT_TEST(testUnsupported);
  CPPUNIT_TEST(testCreate);
  CPPUNIT_TEST(testAudioProperties);
  CPPUNIT_TEST(testDefaultFileExtensions);
  CPPUNIT_TEST(testFileResolver);
  CPPUNIT_TEST_SUITE_END();

public:

  template &lt;typename T&gt;
  void fileRefSave(const string &amp;filename, const string &amp;ext)
  {
    ScopedFileCopy copy(filename, ext);
    string newname = copy.fileName();

    {
      FileRef f(newname.c_str());
      CPPUNIT_ASSERT(dynamic_cast&lt;T*&gt;(f.file()));
      CPPUNIT_ASSERT(!f.isNull());
      f.tag()-&gt;setArtist(&quot;test artist&quot;);
      f.tag()-&gt;setTitle(&quot;test title&quot;);
      f.tag()-&gt;setGenre(&quot;Test!&quot;);
      f.tag()-&gt;setAlbum(&quot;albummmm&quot;);
      f.tag()-&gt;setComment(&quot;a comment&quot;);
      f.tag()-&gt;setTrack(5);
      f.tag()-&gt;setYear(2020);
      f.save();
    }
    {
      FileRef f(newname.c_str());
      CPPUNIT_ASSERT(!f.isNull());
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;artist(), String(&quot;test artist&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;title(), String(&quot;test title&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;genre(), String(&quot;Test!&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;album(), String(&quot;albummmm&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;comment(), String(&quot;a comment&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;track(), (unsigned int)5);
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;year(), (unsigned int)2020);
      f.tag()-&gt;setArtist(&quot;ttest artist&quot;);
      f.tag()-&gt;setTitle(&quot;ytest title&quot;);
      f.tag()-&gt;setGenre(&quot;uTest!&quot;);
      f.tag()-&gt;setAlbum(&quot;ialbummmm&quot;);
      f.tag()-&gt;setComment(&quot;another comment&quot;);
      f.tag()-&gt;setTrack(7);
      f.tag()-&gt;setYear(2080);
      f.save();
    }
    {
      FileRef f(newname.c_str());
      CPPUNIT_ASSERT(!f.isNull());
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;artist(), String(&quot;ttest artist&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;title(), String(&quot;ytest title&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;genre(), String(&quot;uTest!&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;album(), String(&quot;ialbummmm&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;comment(), String(&quot;another comment&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;track(), (unsigned int)7);
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;year(), (unsigned int)2080);
    }

    {
      FileStream fs(newname.c_str());
      FileRef f(&amp;fs);
      CPPUNIT_ASSERT(dynamic_cast&lt;T*&gt;(f.file()));
      CPPUNIT_ASSERT(!f.isNull());
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;artist(), String(&quot;ttest artist&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;title(), String(&quot;ytest title&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;genre(), String(&quot;uTest!&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;album(), String(&quot;ialbummmm&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;comment(), String(&quot;another comment&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;track(), (unsigned int)7);
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;year(), (unsigned int)2080);
      f.tag()-&gt;setArtist(&quot;test artist&quot;);
      f.tag()-&gt;setTitle(&quot;test title&quot;);
      f.tag()-&gt;setGenre(&quot;Test!&quot;);
      f.tag()-&gt;setAlbum(&quot;albummmm&quot;);
      f.tag()-&gt;setComment(&quot;a comment&quot;);
      f.tag()-&gt;setTrack(5);
      f.tag()-&gt;setYear(2020);
      f.save();
    }

    ByteVector fileContent;
    {
      FileStream fs(newname.c_str());
      FileRef f(&amp;fs);
      CPPUNIT_ASSERT(dynamic_cast&lt;T*&gt;(f.file()));
      CPPUNIT_ASSERT(!f.isNull());
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;artist(), String(&quot;test artist&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;title(), String(&quot;test title&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;genre(), String(&quot;Test!&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;album(), String(&quot;albummmm&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;comment(), String(&quot;a comment&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;track(), (unsigned int)5);
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;year(), (unsigned int)2020);

      fs.seek(0);
      fileContent = fs.readBlock(fs.length());
    }

    {
      ByteVectorStream bs(fileContent);
      FileRef f(&amp;bs);
      CPPUNIT_ASSERT(dynamic_cast&lt;T*&gt;(f.file()));
      CPPUNIT_ASSERT(!f.isNull());
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;artist(), String(&quot;test artist&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;title(), String(&quot;test title&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;genre(), String(&quot;Test!&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;album(), String(&quot;albummmm&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;comment(), String(&quot;a comment&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;track(), (unsigned int)5);
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;year(), (unsigned int)2020);
      f.tag()-&gt;setArtist(&quot;ttest artist&quot;);
      f.tag()-&gt;setTitle(&quot;ytest title&quot;);
      f.tag()-&gt;setGenre(&quot;uTest!&quot;);
      f.tag()-&gt;setAlbum(&quot;ialbummmm&quot;);
      f.tag()-&gt;setComment(&quot;another comment&quot;);
      f.tag()-&gt;setTrack(7);
      f.tag()-&gt;setYear(2080);
      f.save();

      fileContent = *bs.data();
    }
    {
      ByteVectorStream bs(fileContent);
      FileRef f(&amp;bs);
      CPPUNIT_ASSERT(dynamic_cast&lt;T*&gt;(f.file()));
      CPPUNIT_ASSERT(!f.isNull());
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;artist(), String(&quot;ttest artist&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;title(), String(&quot;ytest title&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;genre(), String(&quot;uTest!&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;album(), String(&quot;ialbummmm&quot;));
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;comment(), String(&quot;another comment&quot;));
<A NAME="3"></A>      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;track(), (unsigned int)7);
      CPPUNIT_ASSERT_EQUAL(f.tag()-&gt;year(), (unsigned int)2080);
    }
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match845-1.html#3',3,'match845-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  }

  void testMusepack()
  {
    fileRefSave&lt;MPC::File&gt;(&quot;click&quot;, &quot;.mpc&quot;);
  }

  void testASF()
  {
    fileRefSave&lt;ASF::File&gt;(&quot;silence-1&quot;, &quot;.wma&quot;);
  }

  void testVorbis()
  {
    fileRefSave&lt;Ogg::Vorbis::File&gt;(&quot;empty&quot;, &quot;.ogg&quot;);</B></FONT>
  }
<A NAME="0"></A>
  void testSpeex()
  {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match845-1.html#0',3,'match845-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    fileRefSave&lt;Ogg::Speex::File&gt;(&quot;empty&quot;, &quot;.spx&quot;);
  }

  void testFLAC()
  {
    fileRefSave&lt;FLAC::File&gt;(&quot;no-tags&quot;, &quot;.flac&quot;);
  }

  void testMP3()
  {
    fileRefSave&lt;MPEG::File&gt;(&quot;xing&quot;, &quot;.mp3&quot;);
  }

  void testTrueAudio()
  {
    fileRefSave&lt;TrueAudio::File&gt;(&quot;empty&quot;, &quot;.tta&quot;);
  }

  void testMP4_1()
  {
    fileRefSave&lt;MP4::File&gt;(&quot;has-tags&quot;, &quot;.m4a&quot;);
  }

  void testMP4_2()
  {
    fileRefSave&lt;MP4::File&gt;(&quot;no-tags&quot;, &quot;.m4a&quot;);
  }

  void testMP4_3()
  {
    fileRefSave&lt;MP4::File&gt;(&quot;no-tags&quot;, &quot;.3g2&quot;);
  }

  void testMP4_4()
  {
    fileRefSave&lt;MP4::File&gt;(&quot;blank_video&quot;, &quot;.m4v&quot;);
  }
<A NAME="1"></A>
  void testWav()
  {
    fileRefSave&lt;RIFF::WAV::File&gt;(&quot;empty&quot;, &quot;.wav&quot;);</B></FONT><FONT color="#f63526"><A HREF="javascript:ZweiFrames('match845-1.html#1',3,'match845-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>
  }

  void testOGA_FLAC()
  {
    fileRefSave&lt;Ogg::FLAC::File&gt;(&quot;empty_flac&quot;, &quot;.oga&quot;);
  }

  void testOGA_Vorbis()
  {
    fileRefSave&lt;Ogg::Vorbis::File&gt;(&quot;empty_vorbis&quot;, &quot;.oga&quot;);
  }

  void testAPE()
  {
    fileRefSave&lt;APE::File&gt;(&quot;mac-399&quot;, &quot;.ape&quot;);</B></FONT>
  }

  void testAIFF_1()
  {
    fileRefSave&lt;RIFF::AIFF::File&gt;(&quot;empty&quot;, &quot;.aiff&quot;);
  }

<A NAME="2"></A>  void testAIFF_2()
  {
    fileRefSave&lt;RIFF::AIFF::File&gt;(&quot;alaw&quot;, &quot;.aifc&quot;);
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match845-1.html#2',3,'match845-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  }

  void testWavPack()
  {
    fileRefSave&lt;WavPack::File&gt;(&quot;click&quot;, &quot;.wv&quot;);
  }

  void testOpus()
  {
    fileRefSave&lt;Ogg::Opus::File&gt;(&quot;correctness_gain_silent_output&quot;, &quot;.opus&quot;);
  }

  void testUnsupported()
  {</B></FONT>
    FileRef f1(TEST_FILE_PATH_C(&quot;no-extension&quot;));
    CPPUNIT_ASSERT(f1.isNull());

    FileRef f2(TEST_FILE_PATH_C(&quot;unsupported-extension.xx&quot;));
    CPPUNIT_ASSERT(f2.isNull());
  }

  void testCreate()
  {
    // This is deprecated. But worth it to test.

    File *f = FileRef::create(TEST_FILE_PATH_C(&quot;empty_vorbis.oga&quot;));
    CPPUNIT_ASSERT(dynamic_cast&lt;Ogg::Vorbis::File*&gt;(f));
    delete f;

    f = FileRef::create(TEST_FILE_PATH_C(&quot;xing.mp3&quot;));
    CPPUNIT_ASSERT(dynamic_cast&lt;MPEG::File*&gt;(f));
    delete f;

    f = FileRef::create(TEST_FILE_PATH_C(&quot;test.xm&quot;));
    CPPUNIT_ASSERT(dynamic_cast&lt;XM::File*&gt;(f));
    delete f;
  }

  void testAudioProperties()
  {
    FileRef f(TEST_FILE_PATH_C(&quot;xing.mp3&quot;));
    const AudioProperties *audioProperties = f.audioProperties();
    CPPUNIT_ASSERT_EQUAL(2, audioProperties-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(2064, audioProperties-&gt;lengthInMilliseconds());
  }

  void testDefaultFileExtensions()
  {
    const StringList extensions = FileRef::defaultFileExtensions();
    CPPUNIT_ASSERT(extensions.contains(&quot;mpc&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;wma&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;ogg&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;spx&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;flac&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;mp3&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;tta&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;m4a&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;3g2&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;m4v&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;wav&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;oga&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;ape&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;aiff&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;aifc&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;wv&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;opus&quot;));
    CPPUNIT_ASSERT(extensions.contains(&quot;xm&quot;));
  }

  void testFileResolver()
  {
    {
      FileRef f(TEST_FILE_PATH_C(&quot;xing.mp3&quot;));
      CPPUNIT_ASSERT(dynamic_cast&lt;MPEG::File *&gt;(f.file()) != NULL);
    }

    DummyResolver resolver;
    FileRef::addFileTypeResolver(&amp;resolver);

    {
      FileRef f(TEST_FILE_PATH_C(&quot;xing.mp3&quot;));
      CPPUNIT_ASSERT(dynamic_cast&lt;Ogg::Vorbis::File *&gt;(f.file()) != NULL);
    }

    DummyStreamResolver streamResolver;
    FileRef::addFileTypeResolver(&amp;streamResolver);

    {
      FileStream s(TEST_FILE_PATH_C(&quot;xing.mp3&quot;));
      FileRef f(&amp;s);
      CPPUNIT_ASSERT(dynamic_cast&lt;MP4::File *&gt;(f.file()) != NULL);
    }
  }

};

CPPUNIT_TEST_SUITE_REGISTRATION(TestFileRef);
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_id3v2.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
 /***************************************************************************
    copyright           : (C) 2007 by Lukas Lalinsky
    email               : lukas@oxygene.sk
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;id3v2tag.h&gt;
#include &lt;mpegfile.h&gt;
#include &lt;id3v2frame.h&gt;
#include &lt;uniquefileidentifierframe.h&gt;
#include &lt;textidentificationframe.h&gt;
#include &lt;attachedpictureframe.h&gt;
#include &lt;unsynchronizedlyricsframe.h&gt;
#include &lt;synchronizedlyricsframe.h&gt;
#include &lt;eventtimingcodesframe.h&gt;
#include &lt;generalencapsulatedobjectframe.h&gt;
#include &lt;relativevolumeframe.h&gt;
#include &lt;popularimeterframe.h&gt;
#include &lt;urllinkframe.h&gt;
#include &lt;ownershipframe.h&gt;
#include &lt;unknownframe.h&gt;
#include &lt;chapterframe.h&gt;
#include &lt;tableofcontentsframe.h&gt;
#include &lt;commentsframe.h&gt;
#include &lt;podcastframe.h&gt;
#include &lt;privateframe.h&gt;
#include &lt;tdebug.h&gt;
#include &lt;tpropertymap.h&gt;
#include &lt;tzlib.h&gt;
#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &quot;plainfile.h&quot;
#include &quot;utils.h&quot;

using namespace std;
using namespace TagLib;

class PublicFrame : public ID3v2::Frame
{
  public:
    PublicFrame() : ID3v2::Frame(ByteVector(&quot;XXXX\0\0\0\0\0\0&quot;, 10)) {}
    String readStringField(const ByteVector &amp;data, String::Type encoding,
                           int *position = 0)
      { return ID3v2::Frame::readStringField(data, encoding, position); }
    virtual String toString() const { return String(); }
    virtual void parseFields(const ByteVector &amp;) {}
    virtual ByteVector renderFields() const { return ByteVector(); }
};

class TestID3v2 : public CppUnit::TestFixture
{
  CPPUNIT_TEST_SUITE(TestID3v2);
  CPPUNIT_TEST(testUnsynchDecode);
  CPPUNIT_TEST(testDowngradeUTF8ForID3v23_1);
  CPPUNIT_TEST(testDowngradeUTF8ForID3v23_2);
  CPPUNIT_TEST(testUTF16BEDelimiter);
  CPPUNIT_TEST(testUTF16Delimiter);
  CPPUNIT_TEST(testReadStringField);
  CPPUNIT_TEST(testParseAPIC);
  CPPUNIT_TEST(testParseAPIC_UTF16_BOM);
  CPPUNIT_TEST(testParseAPICv22);
  CPPUNIT_TEST(testRenderAPIC);
  CPPUNIT_TEST(testDontRender22);
  CPPUNIT_TEST(testParseGEOB);
  CPPUNIT_TEST(testRenderGEOB);
  CPPUNIT_TEST(testPOPMtoString);
  CPPUNIT_TEST(testParsePOPM);
  CPPUNIT_TEST(testParsePOPMWithoutCounter);
  CPPUNIT_TEST(testRenderPOPM);
  CPPUNIT_TEST(testPOPMFromFile);
  CPPUNIT_TEST(testParseRelativeVolumeFrame);
  CPPUNIT_TEST(testRenderRelativeVolumeFrame);
  CPPUNIT_TEST(testParseUniqueFileIdentifierFrame);
  CPPUNIT_TEST(testParseEmptyUniqueFileIdentifierFrame);
  CPPUNIT_TEST(testRenderUniqueFileIdentifierFrame);
  CPPUNIT_TEST(testBrokenFrame1);
  CPPUNIT_TEST(testItunes24FrameSize);
  CPPUNIT_TEST(testParseUrlLinkFrame);
  CPPUNIT_TEST(testRenderUrlLinkFrame);
  CPPUNIT_TEST(testParseUserUrlLinkFrame);
  CPPUNIT_TEST(testRenderUserUrlLinkFrame);
  CPPUNIT_TEST(testParseOwnershipFrame);
  CPPUNIT_TEST(testRenderOwnershipFrame);
  CPPUNIT_TEST(testParseSynchronizedLyricsFrame);
  CPPUNIT_TEST(testParseSynchronizedLyricsFrameWithEmptyDescritpion);
  CPPUNIT_TEST(testRenderSynchronizedLyricsFrame);
  CPPUNIT_TEST(testParseEventTimingCodesFrame);
  CPPUNIT_TEST(testRenderEventTimingCodesFrame);
  CPPUNIT_TEST(testParseCommentsFrame);
  CPPUNIT_TEST(testRenderCommentsFrame);
  CPPUNIT_TEST(testParsePodcastFrame);
  CPPUNIT_TEST(testRenderPodcastFrame);
  CPPUNIT_TEST(testParsePrivateFrame);
  CPPUNIT_TEST(testRenderPrivateFrame);
  CPPUNIT_TEST(testSaveUTF16Comment);
  CPPUNIT_TEST(testUpdateGenre23_1);
  CPPUNIT_TEST(testUpdateGenre23_2);
  CPPUNIT_TEST(testUpdateGenre23_3);
  CPPUNIT_TEST(testUpdateGenre24);
  CPPUNIT_TEST(testUpdateDate22);
  CPPUNIT_TEST(testDowngradeTo23);
  // CPPUNIT_TEST(testUpdateFullDate22); TODO TYE+TDA should be upgraded to TDRC together
  CPPUNIT_TEST(testCompressedFrameWithBrokenLength);
  CPPUNIT_TEST(testW000);
  CPPUNIT_TEST(testPropertyInterface);
  CPPUNIT_TEST(testPropertyInterface2);
  CPPUNIT_TEST(testPropertiesMovement);
  CPPUNIT_TEST(testPropertyGrouping);
  CPPUNIT_TEST(testDeleteFrame);
  CPPUNIT_TEST(testSaveAndStripID3v1ShouldNotAddFrameFromID3v1ToId3v2);
  CPPUNIT_TEST(testParseChapterFrame);
  CPPUNIT_TEST(testRenderChapterFrame);
  CPPUNIT_TEST(testParseTableOfContentsFrame);
  CPPUNIT_TEST(testRenderTableOfContentsFrame);
  CPPUNIT_TEST(testShrinkPadding);
  CPPUNIT_TEST(testEmptyFrame);
  CPPUNIT_TEST(testDuplicateTags);
  CPPUNIT_TEST(testParseTOCFrameWithManyChildren);
  CPPUNIT_TEST_SUITE_END();

public:

  void testUnsynchDecode()
  {
    MPEG::File f(TEST_FILE_PATH_C(&quot;unsynch.id3&quot;), false);
    CPPUNIT_ASSERT(f.tag());
    CPPUNIT_ASSERT_EQUAL(String(&quot;My babe just cares for me&quot;), f.tag()-&gt;title());
  }

  void testDowngradeUTF8ForID3v23_1()
  {
    ScopedFileCopy copy(&quot;xing&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();

    ID3v2::TextIdentificationFrame *f
      = new ID3v2::TextIdentificationFrame(ByteVector(&quot;TPE1&quot;), String::UTF8);
    StringList sl;
    sl.append(&quot;Foo&quot;);
    f-&gt;setText(sl);

    MPEG::File file(newname.c_str());
    file.ID3v2Tag(true)-&gt;addFrame(f);
    file.save(MPEG::File::ID3v2, File::StripOthers, ID3v2::v3);
    CPPUNIT_ASSERT_EQUAL(true, file.hasID3v2Tag());

    ByteVector data = f-&gt;render();
    CPPUNIT_ASSERT_EQUAL((unsigned int)(4+4+2+1+6+2), data.size());

    ID3v2::TextIdentificationFrame f2(data);
    CPPUNIT_ASSERT_EQUAL(sl, f2.fieldList());
    CPPUNIT_ASSERT_EQUAL(String::UTF16, f2.textEncoding());
  }

  void testDowngradeUTF8ForID3v23_2()
  {
    ScopedFileCopy copy(&quot;xing&quot;, &quot;.mp3&quot;);

    ID3v2::UnsynchronizedLyricsFrame *f
      = new ID3v2::UnsynchronizedLyricsFrame(String::UTF8);
    f-&gt;setText(&quot;Foo&quot;);

    MPEG::File file(copy.fileName().c_str());
    file.ID3v2Tag(true)-&gt;addFrame(f);
    file.save(MPEG::File::ID3v2, File::StripOthers, ID3v2::v3);
    CPPUNIT_ASSERT(file.hasID3v2Tag());

    ByteVector data = f-&gt;render();
    CPPUNIT_ASSERT_EQUAL((unsigned int)(4+4+2+1+3+2+2+6+2), data.size());

    ID3v2::UnsynchronizedLyricsFrame f2(data);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Foo&quot;), f2.text());
    CPPUNIT_ASSERT_EQUAL(String::UTF16, f2.textEncoding());
  }

  void testUTF16BEDelimiter()
  {
    ID3v2::TextIdentificationFrame f(ByteVector(&quot;TPE1&quot;), String::UTF16BE);
    StringList sl;
    sl.append(&quot;Foo&quot;);
    sl.append(&quot;Bar&quot;);
    f.setText(sl);
    CPPUNIT_ASSERT_EQUAL((unsigned int)(4+4+2+1+6+2+6), f.render().size());
  }

  void testUTF16Delimiter()
  {
    ID3v2::TextIdentificationFrame f(ByteVector(&quot;TPE1&quot;), String::UTF16);
    StringList sl;
    sl.append(&quot;Foo&quot;);
    sl.append(&quot;Bar&quot;);
    f.setText(sl);
    CPPUNIT_ASSERT_EQUAL((unsigned int)(4+4+2+1+8+2+8), f.render().size());
  }

  void testBrokenFrame1()
  {
    MPEG::File f(TEST_FILE_PATH_C(&quot;broken-tenc.id3&quot;), false);
    CPPUNIT_ASSERT(f.tag());
    CPPUNIT_ASSERT(!f.ID3v2Tag()-&gt;frameListMap().contains(&quot;TENC&quot;));
  }

  void testReadStringField()
  {
    PublicFrame f;
    ByteVector data(&quot;abc\0&quot;, 4);
    String str = f.readStringField(data, String::Latin1);
    CPPUNIT_ASSERT_EQUAL(String(&quot;abc&quot;), str);
  }

  // http://bugs.kde.org/show_bug.cgi?id=151078
  void testParseAPIC()
  {
    ID3v2::AttachedPictureFrame f(ByteVector(&quot;APIC&quot;
                                             &quot;\x00\x00\x00\x07&quot;
                                             &quot;\x00\x00&quot;
                                             &quot;\x00&quot;
                                             &quot;m\x00&quot;
                                             &quot;\x01&quot;
                                             &quot;d\x00&quot;
                                             &quot;\x00&quot;, 17));
    CPPUNIT_ASSERT_EQUAL(String(&quot;m&quot;), f.mimeType());
    CPPUNIT_ASSERT_EQUAL(ID3v2::AttachedPictureFrame::FileIcon, f.type());
    CPPUNIT_ASSERT_EQUAL(String(&quot;d&quot;), f.description());
  }

  void testParseAPIC_UTF16_BOM()
  {
    ID3v2::AttachedPictureFrame f(ByteVector(
      &quot;\x41\x50\x49\x43\x00\x02\x0c\x59\x00\x00\x01\x69\x6d\x61\x67\x65&quot;
      &quot;\x2f\x6a\x70\x65\x67\x00\x00\xfe\xff\x00\x63\x00\x6f\x00\x76\x00&quot;
      &quot;\x65\x00\x72\x00\x2e\x00\x6a\x00\x70\x00\x67\x00\x00\xff\xd8\xff&quot;,
      16 * 3));
    CPPUNIT_ASSERT_EQUAL(String(&quot;image/jpeg&quot;), f.mimeType());
    CPPUNIT_ASSERT_EQUAL(ID3v2::AttachedPictureFrame::Other, f.type());
    CPPUNIT_ASSERT_EQUAL(String(&quot;cover.jpg&quot;), f.description());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;\xff\xd8\xff&quot;, 3), f.picture());
  }

  void testParseAPICv22()
  {
    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();
    ByteVector data = ByteVector(&quot;PIC&quot;
                                 &quot;\x00\x00\x08&quot;
                                 &quot;\x00&quot;
                                 &quot;JPG&quot;
                                 &quot;\x01&quot;
                                 &quot;d\x00&quot;
                                 &quot;\x00&quot;, 14);
    ID3v2::Header header;
    header.setMajorVersion(2);
    ID3v2::AttachedPictureFrame *frame =
      dynamic_cast&lt;TagLib::ID3v2::AttachedPictureFrame *&gt;(factory-&gt;createFrame(data, &amp;header));

    CPPUNIT_ASSERT(frame);
    CPPUNIT_ASSERT_EQUAL(String(&quot;image/jpeg&quot;), frame-&gt;mimeType());
    CPPUNIT_ASSERT_EQUAL(ID3v2::AttachedPictureFrame::FileIcon, frame-&gt;type());
    CPPUNIT_ASSERT_EQUAL(String(&quot;d&quot;), frame-&gt;description());

    delete frame;
  }

  void testRenderAPIC()
  {
    ID3v2::AttachedPictureFrame f;
    f.setTextEncoding(String::UTF8);
    f.setMimeType(&quot;image/png&quot;);
    f.setType(ID3v2::AttachedPictureFrame::BackCover);
    f.setDescription(&quot;Description&quot;);
    f.setPicture(&quot;PNG data&quot;);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;APIC&quot;
                 &quot;\x00\x00\x00\x20&quot;
                 &quot;\x00\x00&quot;
                 &quot;\x03&quot;
                 &quot;image/png\x00&quot;
                 &quot;\x04&quot;
                 &quot;Description\x00&quot;
                 &quot;PNG data&quot;, 42),
      f.render());
  }

  void testDontRender22()
  {
    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();
    ByteVector data = ByteVector(&quot;FOO&quot;
                                 &quot;\x00\x00\x08&quot;
                                 &quot;\x00&quot;
                                 &quot;JPG&quot;
                                 &quot;\x01&quot;
                                 &quot;d\x00&quot;
                                 &quot;\x00&quot;, 14);
    ID3v2::Header header;
    header.setMajorVersion(2);
    ID3v2::UnknownFrame *frame =
      dynamic_cast&lt;TagLib::ID3v2::UnknownFrame*&gt;(factory-&gt;createFrame(data, &amp;header));

    CPPUNIT_ASSERT(frame);

<A NAME="2"></A>    ID3v2::Tag tag;
    tag.addFrame(frame);
    CPPUNIT_ASSERT_EQUAL((unsigned int)1034, tag.render().size());
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match845-0.html#2',2,'match845-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  }

  // http://bugs.kde.org/show_bug.cgi?id=151078
  void testParseGEOB()
  {
    ID3v2::GeneralEncapsulatedObjectFrame f(ByteVector(&quot;GEOB&quot;
                                             &quot;\x00\x00\x00\x08&quot;
                                             &quot;\x00\x00&quot;
                                             &quot;\x00&quot;
                                             &quot;m\x00&quot;
                                             &quot;f\x00&quot;
                                             &quot;d\x00&quot;
                                             &quot;\x00&quot;, 18));
    CPPUNIT_ASSERT_EQUAL(String(&quot;m&quot;), f.mimeType());
    CPPUNIT_ASSERT_EQUAL(String(&quot;f&quot;), f.fileName());
    CPPUNIT_ASSERT_EQUAL(String(&quot;d&quot;), f.description());
  }

  void testRenderGEOB()
  {
    ID3v2::GeneralEncapsulatedObjectFrame f;
    f.setTextEncoding(String::Latin1);
    f.setMimeType(&quot;application/octet-stream&quot;);
    f.setFileName(&quot;test.bin&quot;);
    f.setDescription(&quot;Description&quot;);
    f.setObject(ByteVector(3, '\x01'));
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;GEOB&quot;
                 &quot;\x00\x00\x00\x32&quot;
                 &quot;\x00\x00&quot;
                 &quot;\x00&quot;
                 &quot;application/octet-stream\x00&quot;
                 &quot;test.bin\x00&quot;
                 &quot;Description\x00&quot;
                 &quot;\x01\x01\x01&quot;, 60),
      f.render());
  }

  void testParsePOPM()
  {</B></FONT>
    ID3v2::PopularimeterFrame f(ByteVector(&quot;POPM&quot;
                                           &quot;\x00\x00\x00\x17&quot;
                                           &quot;\x00\x00&quot;
                                           &quot;email@example.com\x00&quot;
                                           &quot;\x02&quot;
                                           &quot;\x00\x00\x00\x03&quot;, 33));
    CPPUNIT_ASSERT_EQUAL(String(&quot;email@example.com&quot;), f.email());
    CPPUNIT_ASSERT_EQUAL(2, f.rating());
    CPPUNIT_ASSERT_EQUAL((unsigned int)3, f.counter());
  }

  void testParsePOPMWithoutCounter()
  {
    ID3v2::PopularimeterFrame f(ByteVector(&quot;POPM&quot;
                                           &quot;\x00\x00\x00\x13&quot;
                                           &quot;\x00\x00&quot;
                                           &quot;email@example.com\x00&quot;
                                           &quot;\x02&quot;, 29));
    CPPUNIT_ASSERT_EQUAL(String(&quot;email@example.com&quot;), f.email());
    CPPUNIT_ASSERT_EQUAL(2, f.rating());
    CPPUNIT_ASSERT_EQUAL((unsigned int)0, f.counter());
  }

  void testRenderPOPM()
  {
    ID3v2::PopularimeterFrame f;
    f.setEmail(&quot;email@example.com&quot;);
    f.setRating(2);
    f.setCounter(3);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;POPM&quot;
                 &quot;\x00\x00\x00\x17&quot;
                 &quot;\x00\x00&quot;
                 &quot;email@example.com\x00&quot;
                 &quot;\x02&quot;
                 &quot;\x00\x00\x00\x03&quot;, 33),
      f.render());
  }

  void testPOPMtoString()
  {
    ID3v2::PopularimeterFrame f;
    f.setEmail(&quot;email@example.com&quot;);
    f.setRating(2);
    f.setCounter(3);
    CPPUNIT_ASSERT_EQUAL(
      String(&quot;email@example.com rating=2 counter=3&quot;), f.toString());
  }

  void testPOPMFromFile()
  {
    ScopedFileCopy copy(&quot;xing&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();

    ID3v2::PopularimeterFrame *f = new ID3v2::PopularimeterFrame();
    f-&gt;setEmail(&quot;email@example.com&quot;);
    f-&gt;setRating(200);
    f-&gt;setCounter(3);

    {
      MPEG::File foo(newname.c_str());
      foo.ID3v2Tag()-&gt;addFrame(f);
      foo.save();
    }
    {
      MPEG::File bar(newname.c_str());
      CPPUNIT_ASSERT_EQUAL(String(&quot;email@example.com&quot;), dynamic_cast&lt;ID3v2::PopularimeterFrame *&gt;(bar.ID3v2Tag()-&gt;frameList(&quot;POPM&quot;).front())-&gt;email());
      CPPUNIT_ASSERT_EQUAL(200, dynamic_cast&lt;ID3v2::PopularimeterFrame *&gt;(bar.ID3v2Tag()-&gt;frameList(&quot;POPM&quot;).front())-&gt;rating());
    }
  }

  // http://bugs.kde.org/show_bug.cgi?id=150481
  void testParseRelativeVolumeFrame()
  {
    ID3v2::RelativeVolumeFrame f(
      ByteVector(&quot;RVA2&quot;              // Frame ID
                 &quot;\x00\x00\x00\x0B&quot;  // Frame size
                 &quot;\x00\x00&quot;          // Frame flags
                 &quot;ident\x00&quot;         // Identification
                 &quot;\x02&quot;              // Type of channel
                 &quot;\x00\x0F&quot;          // Volume adjustment
                 &quot;\x08&quot;              // Bits representing peak
                 &quot;\x45&quot;, 21));       // Peak volume
    CPPUNIT_ASSERT_EQUAL(String(&quot;ident&quot;), f.identification());
    CPPUNIT_ASSERT_EQUAL(15.0f / 512.0f,
                         f.volumeAdjustment(ID3v2::RelativeVolumeFrame::FrontRight));
    CPPUNIT_ASSERT_EQUAL(static_cast&lt;short&gt;(15),
                         f.volumeAdjustmentIndex(ID3v2::RelativeVolumeFrame::FrontRight));
    CPPUNIT_ASSERT_EQUAL((unsigned char)8,
                         f.peakVolume(ID3v2::RelativeVolumeFrame::FrontRight).bitsRepresentingPeak);
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;\x45&quot;),
                         f.peakVolume(ID3v2::RelativeVolumeFrame::FrontRight).peakVolume);
    const List&lt;ID3v2::RelativeVolumeFrame::ChannelType&gt; channels = f.channels();
    CPPUNIT_ASSERT_EQUAL(1U, channels.size());
    CPPUNIT_ASSERT_EQUAL(ID3v2::RelativeVolumeFrame::FrontRight, channels[0]);
  }

  void testRenderRelativeVolumeFrame()
  {
    ID3v2::RelativeVolumeFrame f;
    f.setIdentification(&quot;ident&quot;);
    f.setVolumeAdjustment(15.0f / 512.0f, ID3v2::RelativeVolumeFrame::FrontRight);
<A NAME="0"></A>    ID3v2::RelativeVolumeFrame::PeakVolume peakVolume;
    peakVolume.bitsRepresentingPeak = 8;
    peakVolume.peakVolume.setData(&quot;\x45&quot;);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match845-0.html#0',2,'match845-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    f.setPeakVolume(peakVolume, ID3v2::RelativeVolumeFrame::FrontRight);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;RVA2&quot;
                 &quot;\x00\x00\x00\x0B&quot;
                 &quot;\x00\x00&quot;
                 &quot;ident\x00&quot;
                 &quot;\x02&quot;
                 &quot;\x00\x0F&quot;
                 &quot;\x08&quot;
                 &quot;\x45&quot;, 21),
      f.render());
  }

  void testParseUniqueFileIdentifierFrame()
  {
    ID3v2::UniqueFileIdentifierFrame f(
      ByteVector(&quot;UFID&quot;                 // Frame ID
                 &quot;\x00\x00\x00\x09&quot;     // Frame size
                 &quot;\x00\x00&quot;             // Frame flags
                 &quot;owner\x00&quot;            // Owner identifier
                 &quot;\x00\x01\x02&quot;, 19));  // Identifier
    CPPUNIT_ASSERT_EQUAL(String(&quot;owner&quot;),
                         f.owner());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;\x00\x01\x02&quot;, 3),
                         f.identifier());
  }

  void testParseEmptyUniqueFileIdentifierFrame()
  {
    ID3v2::UniqueFileIdentifierFrame f(
      ByteVector(&quot;UFID&quot;                 // Frame ID
                 &quot;\x00\x00\x00\x01&quot;     // Frame size
                 &quot;\x00\x00&quot;             // Frame flags
                 &quot;\x00&quot;                 // Owner identifier
                 &quot;&quot;, 11));              // Identifier
    CPPUNIT_ASSERT_EQUAL(String(),
                         f.owner());
    CPPUNIT_ASSERT_EQUAL(ByteVector(),
                         f.identifier());
  }

  void testRenderUniqueFileIdentifierFrame()
  {
    ID3v2::UniqueFileIdentifierFrame f(&quot;owner&quot;, &quot;\x01\x02\x03&quot;);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;UFID&quot;
                 &quot;\x00\x00\x00\x09&quot;
                 &quot;\x00\x00&quot;
                 &quot;owner\x00&quot;
                 &quot;\x01\x02\x03&quot;, 19),
      f.render());
  }

  void testParseUrlLinkFrame()
  {
    ID3v2::UrlLinkFrame f(
      ByteVector(&quot;WOAF&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x12&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;http://example.com&quot;, 28)); // URL
    CPPUNIT_ASSERT_EQUAL(String(&quot;http://example.com&quot;), f.url());
  }

  void testRenderUrlLinkFrame()
  {
    ID3v2::UrlLinkFrame f(&quot;WOAF&quot;);
    f.setUrl(&quot;http://example.com&quot;);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;WOAF&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x12&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;http://example.com&quot;, 28),  // URL
      f.render());
  }

  void testParseUserUrlLinkFrame()
  {
    ID3v2::UserUrlLinkFrame f(
      ByteVector(&quot;WXXX&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x17&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;\x00&quot;                      // Text encoding
                 &quot;foo\x00&quot;                   // Description
                 &quot;http://example.com&quot;, 33)); // URL
    CPPUNIT_ASSERT_EQUAL(String(&quot;foo&quot;), f.description());
    CPPUNIT_ASSERT_EQUAL(String(&quot;http://example.com&quot;), f.url());
  }

  void testRenderUserUrlLinkFrame()
  {
    ID3v2::UserUrlLinkFrame f;
    f.setDescription(&quot;foo&quot;);
    f.setUrl(&quot;http://example.com&quot;);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;WXXX&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x17&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;\x00&quot;                      // Text encoding
                 &quot;foo\x00&quot;                   // Description
                 &quot;http://example.com&quot;, 33),  // URL
      f.render());
  }

  void testParseOwnershipFrame()
  {
    ID3v2::OwnershipFrame f(</B></FONT>
                            ByteVector(&quot;OWNE&quot;                      // Frame ID
                                       &quot;\x00\x00\x00\x19&quot;          // Frame size
                                       &quot;\x00\x00&quot;                  // Frame flags
                                       &quot;\x00&quot;                      // Text encoding
                                       &quot;GBP1.99\x00&quot;               // Price paid
                                       &quot;20120905&quot;                  // Date of purchase
                                       &quot;Beatport&quot;, 35));           // Seller
    CPPUNIT_ASSERT_EQUAL(String(&quot;GBP1.99&quot;), f.pricePaid());
    CPPUNIT_ASSERT_EQUAL(String(&quot;20120905&quot;), f.datePurchased());
    CPPUNIT_ASSERT_EQUAL(String(&quot;Beatport&quot;), f.seller());
  }

  void testRenderOwnershipFrame()
  {
    ID3v2::OwnershipFrame f;
    f.setPricePaid(&quot;GBP1.99&quot;);
    f.setDatePurchased(&quot;20120905&quot;);
    f.setSeller(&quot;Beatport&quot;);
    CPPUNIT_ASSERT_EQUAL(
                         ByteVector(&quot;OWNE&quot;                      // Frame ID
                                    &quot;\x00\x00\x00\x19&quot;          // Frame size
                                    &quot;\x00\x00&quot;                  // Frame flags
                                    &quot;\x00&quot;                      // Text encoding
                                    &quot;GBP1.99\x00&quot;               // Price paid
                                    &quot;20120905&quot;                  // Date of purchase
                                    &quot;Beatport&quot;, 35),  // URL
                         f.render());
  }

  void testParseSynchronizedLyricsFrame()
  {
    ID3v2::SynchronizedLyricsFrame f(
      ByteVector(&quot;SYLT&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x21&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;\x00&quot;                      // Text encoding
                 &quot;eng&quot;                       // Language
                 &quot;\x02&quot;                      // Time stamp format
                 &quot;\x01&quot;                      // Content type
                 &quot;foo\x00&quot;                   // Content descriptor
                 &quot;Example\x00&quot;               // 1st text
                 &quot;\x00\x00\x04\xd2&quot;          // 1st time stamp
                 &quot;Lyrics\x00&quot;                // 2nd text
                 &quot;\x00\x00\x11\xd7&quot;, 43));   // 2nd time stamp
    CPPUNIT_ASSERT_EQUAL(String::Latin1, f.textEncoding());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;eng&quot;, 3), f.language());
    CPPUNIT_ASSERT_EQUAL(ID3v2::SynchronizedLyricsFrame::AbsoluteMilliseconds,
                         f.timestampFormat());
    CPPUNIT_ASSERT_EQUAL(ID3v2::SynchronizedLyricsFrame::Lyrics, f.type());
    CPPUNIT_ASSERT_EQUAL(String(&quot;foo&quot;), f.description());
    ID3v2::SynchronizedLyricsFrame::SynchedTextList stl = f.synchedText();
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, stl.size());
    CPPUNIT_ASSERT_EQUAL(String(&quot;Example&quot;), stl[0].text);
    CPPUNIT_ASSERT_EQUAL((unsigned int)1234, stl[0].time);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Lyrics&quot;), stl[1].text);
    CPPUNIT_ASSERT_EQUAL((unsigned int)4567, stl[1].time);
  }

  void testParseSynchronizedLyricsFrameWithEmptyDescritpion()
  {
    ID3v2::SynchronizedLyricsFrame f(
      ByteVector(&quot;SYLT&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x21&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;\x00&quot;                      // Text encoding
                 &quot;eng&quot;                       // Language
                 &quot;\x02&quot;                      // Time stamp format
                 &quot;\x01&quot;                      // Content type
                 &quot;\x00&quot;                      // Content descriptor
                 &quot;Example\x00&quot;               // 1st text
                 &quot;\x00\x00\x04\xd2&quot;          // 1st time stamp
                 &quot;Lyrics\x00&quot;                // 2nd text
                 &quot;\x00\x00\x11\xd7&quot;, 40));   // 2nd time stamp
    CPPUNIT_ASSERT_EQUAL(String::Latin1, f.textEncoding());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;eng&quot;, 3), f.language());
    CPPUNIT_ASSERT_EQUAL(ID3v2::SynchronizedLyricsFrame::AbsoluteMilliseconds,
                         f.timestampFormat());
    CPPUNIT_ASSERT_EQUAL(ID3v2::SynchronizedLyricsFrame::Lyrics, f.type());
    CPPUNIT_ASSERT(f.description().isEmpty());
    ID3v2::SynchronizedLyricsFrame::SynchedTextList stl = f.synchedText();
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, stl.size());
    CPPUNIT_ASSERT_EQUAL(String(&quot;Example&quot;), stl[0].text);
    CPPUNIT_ASSERT_EQUAL((unsigned int)1234, stl[0].time);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Lyrics&quot;), stl[1].text);
    CPPUNIT_ASSERT_EQUAL((unsigned int)4567, stl[1].time);
  }

  void testRenderSynchronizedLyricsFrame()
  {
    ID3v2::SynchronizedLyricsFrame f;
    f.setTextEncoding(String::Latin1);
    f.setLanguage(ByteVector(&quot;eng&quot;, 3));
    f.setTimestampFormat(ID3v2::SynchronizedLyricsFrame::AbsoluteMilliseconds);
    f.setType(ID3v2::SynchronizedLyricsFrame::Lyrics);
    f.setDescription(&quot;foo&quot;);
    ID3v2::SynchronizedLyricsFrame::SynchedTextList stl;
    stl.append(ID3v2::SynchronizedLyricsFrame::SynchedText(1234, &quot;Example&quot;));
    stl.append(ID3v2::SynchronizedLyricsFrame::SynchedText(4567, &quot;Lyrics&quot;));
    f.setSynchedText(stl);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;SYLT&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x21&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;\x00&quot;                      // Text encoding
                 &quot;eng&quot;                       // Language
                 &quot;\x02&quot;                      // Time stamp format
                 &quot;\x01&quot;                      // Content type
                 &quot;foo\x00&quot;                   // Content descriptor
                 &quot;Example\x00&quot;               // 1st text
                 &quot;\x00\x00\x04\xd2&quot;          // 1st time stamp
                 &quot;Lyrics\x00&quot;                // 2nd text
                 &quot;\x00\x00\x11\xd7&quot;, 43),    // 2nd time stamp
      f.render());
  }

  void testParseEventTimingCodesFrame()
  {
    ID3v2::EventTimingCodesFrame f(
      ByteVector(&quot;ETCO&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x0b&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;\x02&quot;                      // Time stamp format
                 &quot;\x02&quot;                      // 1st event
                 &quot;\x00\x00\xf3\x5c&quot;          // 1st time stamp
                 &quot;\xfe&quot;                      // 2nd event
                 &quot;\x00\x36\xee\x80&quot;, 21));   // 2nd time stamp
    CPPUNIT_ASSERT_EQUAL(ID3v2::EventTimingCodesFrame::AbsoluteMilliseconds,
                         f.timestampFormat());
    ID3v2::EventTimingCodesFrame::SynchedEventList sel = f.synchedEvents();
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, sel.size());
    CPPUNIT_ASSERT_EQUAL(ID3v2::EventTimingCodesFrame::IntroStart, sel[0].type);
    CPPUNIT_ASSERT_EQUAL((unsigned int)62300, sel[0].time);
    CPPUNIT_ASSERT_EQUAL(ID3v2::EventTimingCodesFrame::AudioFileEnds, sel[1].type);
    CPPUNIT_ASSERT_EQUAL((unsigned int)3600000, sel[1].time);
  }

  void testRenderEventTimingCodesFrame()
  {
    ID3v2::EventTimingCodesFrame f;
<A NAME="1"></A>    f.setTimestampFormat(ID3v2::EventTimingCodesFrame::AbsoluteMilliseconds);
    ID3v2::EventTimingCodesFrame::SynchedEventList sel;
    sel.append(ID3v2::EventTimingCodesFrame::SynchedEvent(62300, ID3v2::EventTimingCodesFrame::IntroStart));
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match845-0.html#1',2,'match845-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    sel.append(ID3v2::EventTimingCodesFrame::SynchedEvent(3600000, ID3v2::EventTimingCodesFrame::AudioFileEnds));
    f.setSynchedEvents(sel);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;ETCO&quot;                      // Frame ID
                 &quot;\x00\x00\x00\x0b&quot;          // Frame size
                 &quot;\x00\x00&quot;                  // Frame flags
                 &quot;\x02&quot;                      // Time stamp format
                 &quot;\x02&quot;                      // 1st event
                 &quot;\x00\x00\xf3\x5c&quot;          // 1st time stamp
                 &quot;\xfe&quot;                      // 2nd event
                 &quot;\x00\x36\xee\x80&quot;, 21),    // 2nd time stamp
      f.render());
  }

  void testParseCommentsFrame()
  {
    ID3v2::CommentsFrame f(
      ByteVector(&quot;COMM&quot;
                 &quot;\x00\x00\x00\x14&quot;
                 &quot;\x00\x00&quot;
                 &quot;\x03&quot;
                 &quot;deu&quot;
                 &quot;Description\x00&quot;
                 &quot;Text&quot;, 30));
    CPPUNIT_ASSERT_EQUAL(String::UTF8, f.textEncoding());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;deu&quot;), f.language());
    CPPUNIT_ASSERT_EQUAL(String(&quot;Description&quot;), f.description());
    CPPUNIT_ASSERT_EQUAL(String(&quot;Text&quot;), f.text());
  }

  void testRenderCommentsFrame()
  {
    ID3v2::CommentsFrame f;
    f.setTextEncoding(String::UTF16);
    f.setLanguage(&quot;eng&quot;);
    f.setDescription(&quot;Description&quot;);
    f.setText(&quot;Text&quot;);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;COMM&quot;
                 &quot;\x00\x00\x00\x28&quot;
                 &quot;\x00\x00&quot;
                 &quot;\x01&quot;
                 &quot;eng&quot;
                 &quot;\xff\xfe&quot; &quot;D\0e\0s\0c\0r\0i\0p\0t\0i\0o\0n\0&quot; &quot;\x00\x00&quot;
                 &quot;\xff\xfe&quot; &quot;T\0e\0x\0t\0&quot;, 50),
      f.render());
  }

  void testParsePodcastFrame()
  {
    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();</B></FONT>
    ByteVector data = ByteVector(&quot;PCST&quot;
                                 &quot;\x00\x00\x00\x04&quot;
                                 &quot;\x00\x00&quot;
                                 &quot;\x00\x00\x00\x00&quot;, 14);
<A NAME="3"></A>    const ID3v2::Header header;
    CPPUNIT_ASSERT(dynamic_cast&lt;ID3v2::PodcastFrame *&gt;(
                     factory-&gt;createFrame(data, &amp;header)));
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match845-0.html#3',2,'match845-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  }

  void testRenderPodcastFrame()
  {
    ID3v2::PodcastFrame f;
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;PCST&quot;
                 &quot;\x00\x00\x00\x04&quot;
                 &quot;\x00\x00&quot;
                 &quot;\x00\x00\x00\x00&quot;, 14),
      f.render());
  }

  void testParsePrivateFrame()
  {
    ID3v2::PrivateFrame f(
      ByteVector(&quot;PRIV&quot;
                 &quot;\x00\x00\x00\x0e&quot;
                 &quot;\x00\x00&quot;
                 &quot;WM/Provider\x00&quot;
                 &quot;TL&quot;, 24));
    CPPUNIT_ASSERT_EQUAL(String(&quot;WM/Provider&quot;), f.owner());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;TL&quot;), f.data());
  }

  void testRenderPrivateFrame()
  {
    ID3v2::PrivateFrame f;</B></FONT>
    f.setOwner(&quot;WM/Provider&quot;);
    f.setData(&quot;TL&quot;);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;PRIV&quot;
                 &quot;\x00\x00\x00\x0e&quot;
                 &quot;\x00\x00&quot;
                 &quot;WM/Provider\x00&quot;
                 &quot;TL&quot;, 24),
      f.render());
  }

  void testItunes24FrameSize()
  {
    MPEG::File f(TEST_FILE_PATH_C(&quot;005411.id3&quot;), false);
    CPPUNIT_ASSERT(f.tag());
    CPPUNIT_ASSERT(f.ID3v2Tag()-&gt;frameListMap().contains(&quot;TIT2&quot;));
    CPPUNIT_ASSERT_EQUAL(String(&quot;Sunshine Superman&quot;), f.ID3v2Tag()-&gt;frameListMap()[&quot;TIT2&quot;].front()-&gt;toString());
  }

  void testSaveUTF16Comment()
  {
    String::Type defaultEncoding = ID3v2::FrameFactory::instance()-&gt;defaultTextEncoding();
    ScopedFileCopy copy(&quot;xing&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();
    ID3v2::FrameFactory::instance()-&gt;setDefaultTextEncoding(String::UTF16);
    {
      MPEG::File foo(newname.c_str());
      foo.strip();
      foo.tag()-&gt;setComment(&quot;Test comment!&quot;);
      foo.save();
    }
    {
      MPEG::File bar(newname.c_str());
      CPPUNIT_ASSERT_EQUAL(String(&quot;Test comment!&quot;), bar.tag()-&gt;comment());
      ID3v2::FrameFactory::instance()-&gt;setDefaultTextEncoding(defaultEncoding);
    }
  }

  void testUpdateGenre23_1()
  {
    // &quot;Refinement&quot; is the same as the ID3v1 genre - duplicate
    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();
    ByteVector data = ByteVector(&quot;TCON&quot;                 // Frame ID
                                 &quot;\x00\x00\x00\x10&quot;     // Frame size
                                 &quot;\x00\x00&quot;             // Frame flags
                                 &quot;\x00&quot;                 // Encoding
                                 &quot;(22)Death Metal&quot;, 26);     // Text
    ID3v2::Header header;
    header.setMajorVersion(3);
    ID3v2::TextIdentificationFrame *frame =
      dynamic_cast&lt;TagLib::ID3v2::TextIdentificationFrame*&gt;(factory-&gt;createFrame(data, &amp;header));
    CPPUNIT_ASSERT_EQUAL((unsigned int)1, frame-&gt;fieldList().size());
    CPPUNIT_ASSERT_EQUAL(String(&quot;Death Metal&quot;), frame-&gt;fieldList()[0]);

    ID3v2::Tag tag;
    tag.addFrame(frame);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Death Metal&quot;), tag.genre());
  }

  void testUpdateGenre23_2()
  {
    // &quot;Refinement&quot; is different from the ID3v1 genre
    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();
    ByteVector data = ByteVector(&quot;TCON&quot;                 // Frame ID
                                 &quot;\x00\x00\x00\x0d&quot;     // Frame size
                                 &quot;\x00\x00&quot;             // Frame flags
                                 &quot;\x00&quot;                 // Encoding
                                 &quot;(4)Eurodisco&quot;, 23);   // Text
    ID3v2::Header header;
    header.setMajorVersion(3);
    ID3v2::TextIdentificationFrame *frame =
      dynamic_cast&lt;TagLib::ID3v2::TextIdentificationFrame*&gt;(factory-&gt;createFrame(data, &amp;header));
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, frame-&gt;fieldList().size());
    CPPUNIT_ASSERT_EQUAL(String(&quot;4&quot;), frame-&gt;fieldList()[0]);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Eurodisco&quot;), frame-&gt;fieldList()[1]);

    ID3v2::Tag tag;
    tag.addFrame(frame);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Disco Eurodisco&quot;), tag.genre());
  }

  void testUpdateGenre23_3()
  {
    // Multiple references and a refinement
    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();
    ByteVector data = ByteVector(&quot;TCON&quot;                 // Frame ID
                                 &quot;\x00\x00\x00\x15&quot;     // Frame size
                                 &quot;\x00\x00&quot;             // Frame flags
                                 &quot;\x00&quot;                 // Encoding
                                 &quot;(9)(138)Viking Metal&quot;, 31);   // Text
    ID3v2::Header header;
    header.setMajorVersion(3);
    ID3v2::TextIdentificationFrame *frame =
      dynamic_cast&lt;TagLib::ID3v2::TextIdentificationFrame*&gt;(factory-&gt;createFrame(data, &amp;header));
    CPPUNIT_ASSERT_EQUAL(3U, frame-&gt;fieldList().size());
    CPPUNIT_ASSERT_EQUAL(String(&quot;9&quot;), frame-&gt;fieldList()[0]);
    CPPUNIT_ASSERT_EQUAL(String(&quot;138&quot;), frame-&gt;fieldList()[1]);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Viking Metal&quot;), frame-&gt;fieldList()[2]);

    ID3v2::Tag tag;
    tag.addFrame(frame);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Metal Black Metal Viking Metal&quot;), tag.genre());
  }

  void testUpdateGenre24()
  {
    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();
    ByteVector data = ByteVector(&quot;TCON&quot;                   // Frame ID
                                 &quot;\x00\x00\x00\x0D&quot;       // Frame size
                                 &quot;\x00\x00&quot;               // Frame flags
                                 &quot;\0&quot;                   // Encoding
                                 &quot;14\0Eurodisco&quot;, 23);     // Text
    ID3v2::Header header;
    ID3v2::TextIdentificationFrame *frame =
      dynamic_cast&lt;TagLib::ID3v2::TextIdentificationFrame*&gt;(factory-&gt;createFrame(data, &amp;header));
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, frame-&gt;fieldList().size());
    CPPUNIT_ASSERT_EQUAL(String(&quot;14&quot;), frame-&gt;fieldList()[0]);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Eurodisco&quot;), frame-&gt;fieldList()[1]);

    ID3v2::Tag tag;
    tag.addFrame(frame);
    CPPUNIT_ASSERT_EQUAL(String(&quot;R&amp;B Eurodisco&quot;), tag.genre());
  }

  void testUpdateDate22()
  {
    MPEG::File f(TEST_FILE_PATH_C(&quot;id3v22-tda.mp3&quot;), false);
    CPPUNIT_ASSERT(f.tag());
    CPPUNIT_ASSERT_EQUAL((unsigned int)2010, f.tag()-&gt;year());
  }

  void testUpdateFullDate22()
  {
    MPEG::File f(TEST_FILE_PATH_C(&quot;id3v22-tda.mp3&quot;), false);
    CPPUNIT_ASSERT(f.tag());
    CPPUNIT_ASSERT_EQUAL(String(&quot;2010-04-03&quot;), f.ID3v2Tag()-&gt;frameListMap()[&quot;TDRC&quot;].front()-&gt;toString());
  }

  void testDowngradeTo23()
  {
    ScopedFileCopy copy(&quot;xing&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();

    ID3v2::TextIdentificationFrame *tf;
    {
      MPEG::File foo(newname.c_str());
      tf = new ID3v2::TextIdentificationFrame(&quot;TDOR&quot;, String::Latin1);
      tf-&gt;setText(&quot;2011-03-16&quot;);
      foo.ID3v2Tag()-&gt;addFrame(tf);
      tf = new ID3v2::TextIdentificationFrame(&quot;TDRC&quot;, String::Latin1);
      tf-&gt;setText(&quot;2012-04-17T12:01&quot;);
      foo.ID3v2Tag()-&gt;addFrame(tf);
      tf = new ID3v2::TextIdentificationFrame(&quot;TMCL&quot;, String::Latin1);
      tf-&gt;setText(StringList().append(&quot;Guitar&quot;).append(&quot;Artist 1&quot;).append(&quot;Drums&quot;).append(&quot;Artist 2&quot;));
      foo.ID3v2Tag()-&gt;addFrame(tf);
      tf = new ID3v2::TextIdentificationFrame(&quot;TIPL&quot;, String::Latin1);
      tf-&gt;setText(StringList().append(&quot;Producer&quot;).append(&quot;Artist 3&quot;).append(&quot;Mastering&quot;).append(&quot;Artist 4&quot;));
      foo.ID3v2Tag()-&gt;addFrame(tf);
      tf = new ID3v2::TextIdentificationFrame(&quot;TCON&quot;, String::Latin1);
      tf-&gt;setText(StringList().append(&quot;51&quot;).append(&quot;Noise&quot;).append(&quot;Power Noise&quot;));
      foo.ID3v2Tag()-&gt;addFrame(tf);
      foo.ID3v2Tag()-&gt;addFrame(new ID3v2::TextIdentificationFrame(&quot;TDRL&quot;, String::Latin1));
      foo.ID3v2Tag()-&gt;addFrame(new ID3v2::TextIdentificationFrame(&quot;TDTG&quot;, String::Latin1));
      foo.ID3v2Tag()-&gt;addFrame(new ID3v2::TextIdentificationFrame(&quot;TMOO&quot;, String::Latin1));
      foo.ID3v2Tag()-&gt;addFrame(new ID3v2::TextIdentificationFrame(&quot;TPRO&quot;, String::Latin1));
      foo.ID3v2Tag()-&gt;addFrame(new ID3v2::TextIdentificationFrame(&quot;TSOA&quot;, String::Latin1));
      foo.ID3v2Tag()-&gt;addFrame(new ID3v2::TextIdentificationFrame(&quot;TSOT&quot;, String::Latin1));
      foo.ID3v2Tag()-&gt;addFrame(new ID3v2::TextIdentificationFrame(&quot;TSST&quot;, String::Latin1));
      foo.ID3v2Tag()-&gt;addFrame(new ID3v2::TextIdentificationFrame(&quot;TSOP&quot;, String::Latin1));
      foo.save(MPEG::File::AllTags, File::StripOthers, ID3v2::v3);
    }
    {
      MPEG::File bar(newname.c_str());
      tf = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(bar.ID3v2Tag()-&gt;frameList(&quot;TDOR&quot;).front());
      CPPUNIT_ASSERT(tf);
      CPPUNIT_ASSERT_EQUAL((unsigned int)1, tf-&gt;fieldList().size());
      CPPUNIT_ASSERT_EQUAL(String(&quot;2011&quot;), tf-&gt;fieldList().front());
      tf = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(bar.ID3v2Tag()-&gt;frameList(&quot;TDRC&quot;).front());
      CPPUNIT_ASSERT(tf);
      CPPUNIT_ASSERT_EQUAL((unsigned int)1, tf-&gt;fieldList().size());
      CPPUNIT_ASSERT_EQUAL(String(&quot;2012-04-17T12:01&quot;), tf-&gt;fieldList().front());
      tf = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(bar.ID3v2Tag()-&gt;frameList(&quot;TIPL&quot;).front());
      CPPUNIT_ASSERT(tf);
      CPPUNIT_ASSERT_EQUAL((unsigned int)8, tf-&gt;fieldList().size());
      CPPUNIT_ASSERT_EQUAL(String(&quot;Guitar&quot;), tf-&gt;fieldList()[0]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;Artist 1&quot;), tf-&gt;fieldList()[1]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;Drums&quot;), tf-&gt;fieldList()[2]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;Artist 2&quot;), tf-&gt;fieldList()[3]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;Producer&quot;), tf-&gt;fieldList()[4]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;Artist 3&quot;), tf-&gt;fieldList()[5]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;Mastering&quot;), tf-&gt;fieldList()[6]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;Artist 4&quot;), tf-&gt;fieldList()[7]);
      tf = dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(bar.ID3v2Tag()-&gt;frameList(&quot;TCON&quot;).front());
      CPPUNIT_ASSERT(tf);
      CPPUNIT_ASSERT_EQUAL(3U, tf-&gt;fieldList().size());
      CPPUNIT_ASSERT_EQUAL(String(&quot;51&quot;), tf-&gt;fieldList()[0]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;39&quot;), tf-&gt;fieldList()[1]);
      CPPUNIT_ASSERT_EQUAL(String(&quot;Power Noise&quot;), tf-&gt;fieldList()[2]);
      CPPUNIT_ASSERT(!bar.ID3v2Tag()-&gt;frameListMap().contains(&quot;TDRL&quot;));
      CPPUNIT_ASSERT(!bar.ID3v2Tag()-&gt;frameListMap().contains(&quot;TDTG&quot;));
      CPPUNIT_ASSERT(!bar.ID3v2Tag()-&gt;frameListMap().contains(&quot;TMOO&quot;));
      CPPUNIT_ASSERT(!bar.ID3v2Tag()-&gt;frameListMap().contains(&quot;TPRO&quot;));
#ifdef NO_ITUNES_HACKS
      CPPUNIT_ASSERT(!bar.ID3v2Tag()-&gt;frameListMap().contains(&quot;TSOA&quot;));
      CPPUNIT_ASSERT(!bar.ID3v2Tag()-&gt;frameListMap().contains(&quot;TSOT&quot;));
      CPPUNIT_ASSERT(!bar.ID3v2Tag()-&gt;frameListMap().contains(&quot;TSOP&quot;));
#endif
      CPPUNIT_ASSERT(!bar.ID3v2Tag()-&gt;frameListMap().contains(&quot;TSST&quot;));
    }
    {
      const ByteVector expectedId3v23Data(
            &quot;ID3&quot; &quot;\x03\x00\x00\x00\x00\x09\x49&quot;
            &quot;TSOA&quot; &quot;\x00\x00\x00\x01\x00\x00\x00&quot;
            &quot;TSOT&quot; &quot;\x00\x00\x00\x01\x00\x00\x00&quot;
            &quot;TSOP&quot; &quot;\x00\x00\x00\x01\x00\x00\x00&quot;
            &quot;TORY&quot; &quot;\x00\x00\x00\x05\x00\x00\x00&quot; &quot;2011&quot;
            &quot;TYER&quot; &quot;\x00\x00\x00\x05\x00\x00\x00&quot; &quot;2012&quot;
            &quot;TDAT&quot; &quot;\x00\x00\x00\x05\x00\x00\x00&quot; &quot;1704&quot;
            &quot;TIME&quot; &quot;\x00\x00\x00\x05\x00\x00\x00&quot; &quot;1201&quot;
            &quot;IPLS&quot; &quot;\x00\x00\x00\x44\x00\x00\x00&quot; &quot;Guitar&quot; &quot;\x00&quot;
            &quot;Artist 1&quot; &quot;\x00&quot; &quot;Drums&quot; &quot;\x00&quot; &quot;Artist 2&quot; &quot;\x00&quot; &quot;Producer&quot; &quot;\x00&quot;
            &quot;Artist 3&quot; &quot;\x00&quot; &quot;Mastering&quot; &quot;\x00&quot; &quot;Artist 4&quot;
            &quot;TCON&quot; &quot;\x00\x00\x00\x14\x00\x00\x00&quot; &quot;(51)(39)Power Noise&quot;, 211);
      const ByteVector actualId3v23Data =
          PlainFile(newname.c_str()).readBlock(expectedId3v23Data.size());
      CPPUNIT_ASSERT_EQUAL(expectedId3v23Data, actualId3v23Data);
    }

    ScopedFileCopy rareFramesCopy(&quot;rare_frames&quot;, &quot;.mp3&quot;);

    {
      MPEG::File f(rareFramesCopy.fileName().c_str());
      f.save(MPEG::File::AllTags, File::StripOthers, ID3v2::v3);
      f.seek(f.find(&quot;TCON&quot;) + 11);
      CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;(13)&quot;), f.readBlock(4));
    }
  }

  void testCompressedFrameWithBrokenLength()
  {
    MPEG::File f(TEST_FILE_PATH_C(&quot;compressed_id3_frame.mp3&quot;), false);
    CPPUNIT_ASSERT(f.ID3v2Tag()-&gt;frameListMap().contains(&quot;APIC&quot;));

    if(zlib::isAvailable()) {
      ID3v2::AttachedPictureFrame *frame
        = dynamic_cast&lt;TagLib::ID3v2::AttachedPictureFrame*&gt;(f.ID3v2Tag()-&gt;frameListMap()[&quot;APIC&quot;].front());
      CPPUNIT_ASSERT(frame);
      CPPUNIT_ASSERT_EQUAL(String(&quot;image/bmp&quot;), frame-&gt;mimeType());
      CPPUNIT_ASSERT_EQUAL(ID3v2::AttachedPictureFrame::Other, frame-&gt;type());
      CPPUNIT_ASSERT_EQUAL(String(&quot;&quot;), frame-&gt;description());
      CPPUNIT_ASSERT_EQUAL((unsigned int)86414, frame-&gt;picture().size());
    }
    else {
      // Skip the test if ZLIB is not installed.
      // The message &quot;Compressed frames are currently not supported.&quot; will be displayed.

      ID3v2::UnknownFrame *frame
        = dynamic_cast&lt;TagLib::ID3v2::UnknownFrame*&gt;(f.ID3v2Tag()-&gt;frameListMap()[&quot;APIC&quot;].front());
      CPPUNIT_ASSERT(frame);
    }
  }

  void testW000()
  {
    MPEG::File f(TEST_FILE_PATH_C(&quot;w000.mp3&quot;), false);
    CPPUNIT_ASSERT(f.ID3v2Tag()-&gt;frameListMap().contains(&quot;W000&quot;));
    ID3v2::UrlLinkFrame *frame =
    dynamic_cast&lt;TagLib::ID3v2::UrlLinkFrame*&gt;(f.ID3v2Tag()-&gt;frameListMap()[&quot;W000&quot;].front());
    CPPUNIT_ASSERT(frame);
    CPPUNIT_ASSERT_EQUAL(String(&quot;lukas.lalinsky@example.com____&quot;), frame-&gt;url());
  }

  void testPropertyInterface()
  {
    ScopedFileCopy copy(&quot;rare_frames&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();
    MPEG::File f(newname.c_str());
    PropertyMap dict = f.ID3v2Tag(false)-&gt;properties();
    CPPUNIT_ASSERT_EQUAL((unsigned int)6, dict.size());

    CPPUNIT_ASSERT(dict.contains(&quot;USERTEXTDESCRIPTION1&quot;));
    CPPUNIT_ASSERT(dict.contains(&quot;QuodLibet::USERTEXTDESCRIPTION2&quot;));
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, dict[&quot;USERTEXTDESCRIPTION1&quot;].size());
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, dict[&quot;QuodLibet::USERTEXTDESCRIPTION2&quot;].size());
    CPPUNIT_ASSERT_EQUAL(String(&quot;userTextData1&quot;), dict[&quot;USERTEXTDESCRIPTION1&quot;][0]);
    CPPUNIT_ASSERT_EQUAL(String(&quot;userTextData2&quot;), dict[&quot;USERTEXTDESCRIPTION1&quot;][1]);
    CPPUNIT_ASSERT_EQUAL(String(&quot;userTextData1&quot;), dict[&quot;QuodLibet::USERTEXTDESCRIPTION2&quot;][0]);
    CPPUNIT_ASSERT_EQUAL(String(&quot;userTextData2&quot;), dict[&quot;QuodLibet::USERTEXTDESCRIPTION2&quot;][1]);

    CPPUNIT_ASSERT_EQUAL(String(&quot;Pop&quot;), dict[&quot;GENRE&quot;].front());

    CPPUNIT_ASSERT_EQUAL(String(&quot;http://a.user.url&quot;), dict[&quot;URL:USERURL&quot;].front());

    CPPUNIT_ASSERT_EQUAL(String(&quot;http://a.user.url/with/empty/description&quot;), dict[&quot;URL&quot;].front());
    CPPUNIT_ASSERT_EQUAL(String(&quot;A COMMENT&quot;), dict[&quot;COMMENT&quot;].front());

    CPPUNIT_ASSERT_EQUAL(1u, dict.unsupportedData().size());
    CPPUNIT_ASSERT_EQUAL(String(&quot;UFID/supermihi@web.de&quot;), dict.unsupportedData().front());
  }

  void testPropertyInterface2()
  {
    ID3v2::Tag tag;
    ID3v2::UnsynchronizedLyricsFrame *frame1 = new ID3v2::UnsynchronizedLyricsFrame();
    frame1-&gt;setDescription(&quot;test&quot;);
    frame1-&gt;setText(&quot;la-la-la test&quot;);
    tag.addFrame(frame1);

    ID3v2::UnsynchronizedLyricsFrame *frame2 = new ID3v2::UnsynchronizedLyricsFrame();
    frame2-&gt;setDescription(&quot;&quot;);
    frame2-&gt;setText(&quot;la-la-la nodescription&quot;);
    tag.addFrame(frame2);

    ID3v2::AttachedPictureFrame *frame3 = new ID3v2::AttachedPictureFrame();
    frame3-&gt;setDescription(&quot;test picture&quot;);
    tag.addFrame(frame3);

    ID3v2::TextIdentificationFrame *frame4 = new ID3v2::TextIdentificationFrame(&quot;TIPL&quot;);
    frame4-&gt;setText(&quot;single value is invalid for TIPL&quot;);
    tag.addFrame(frame4);

    ID3v2::TextIdentificationFrame *frame5 = new ID3v2::TextIdentificationFrame(&quot;TMCL&quot;);
    StringList tmclData;
    tmclData.append(&quot;VIOLIN&quot;);
    tmclData.append(&quot;a violinist&quot;);
    tmclData.append(&quot;PIANO&quot;);
    tmclData.append(&quot;a pianist&quot;);
    frame5-&gt;setText(tmclData);
    tag.addFrame(frame5);

    ID3v2::UniqueFileIdentifierFrame *frame6 = new ID3v2::UniqueFileIdentifierFrame(&quot;http://musicbrainz.org&quot;, &quot;152454b9-19ba-49f3-9fc9-8fc26545cf41&quot;);
    tag.addFrame(frame6);

    ID3v2::UniqueFileIdentifierFrame *frame7 = new ID3v2::UniqueFileIdentifierFrame(&quot;http://example.com&quot;, &quot;123&quot;);
    tag.addFrame(frame7);

    ID3v2::UserTextIdentificationFrame *frame8 = new ID3v2::UserTextIdentificationFrame();
    frame8-&gt;setDescription(&quot;MusicBrainz Album Id&quot;);
    frame8-&gt;setText(&quot;95c454a5-d7e0-4d8f-9900-db04aca98ab3&quot;);
    tag.addFrame(frame8);

    PropertyMap properties = tag.properties();

    CPPUNIT_ASSERT_EQUAL(3u, properties.unsupportedData().size());
    CPPUNIT_ASSERT(properties.unsupportedData().contains(&quot;TIPL&quot;));
    CPPUNIT_ASSERT(properties.unsupportedData().contains(&quot;APIC&quot;));
    CPPUNIT_ASSERT(properties.unsupportedData().contains(&quot;UFID/http://example.com&quot;));

    CPPUNIT_ASSERT(properties.contains(&quot;PERFORMER:VIOLIN&quot;));
    CPPUNIT_ASSERT(properties.contains(&quot;PERFORMER:PIANO&quot;));
    CPPUNIT_ASSERT_EQUAL(String(&quot;a violinist&quot;), properties[&quot;PERFORMER:VIOLIN&quot;].front());
    CPPUNIT_ASSERT_EQUAL(String(&quot;a pianist&quot;), properties[&quot;PERFORMER:PIANO&quot;].front());

    CPPUNIT_ASSERT(properties.contains(&quot;LYRICS&quot;));
    CPPUNIT_ASSERT(properties.contains(&quot;LYRICS:TEST&quot;));

    CPPUNIT_ASSERT(properties.contains(&quot;MUSICBRAINZ_TRACKID&quot;));
    CPPUNIT_ASSERT_EQUAL(String(&quot;152454b9-19ba-49f3-9fc9-8fc26545cf41&quot;), properties[&quot;MUSICBRAINZ_TRACKID&quot;].front());

    CPPUNIT_ASSERT(properties.contains(&quot;MUSICBRAINZ_ALBUMID&quot;));
    CPPUNIT_ASSERT_EQUAL(String(&quot;95c454a5-d7e0-4d8f-9900-db04aca98ab3&quot;), properties[&quot;MUSICBRAINZ_ALBUMID&quot;].front());

    tag.removeUnsupportedProperties(properties.unsupportedData());
    CPPUNIT_ASSERT(tag.frameList(&quot;APIC&quot;).isEmpty());
    CPPUNIT_ASSERT(tag.frameList(&quot;TIPL&quot;).isEmpty());
    CPPUNIT_ASSERT_EQUAL((ID3v2::UniqueFileIdentifierFrame *)0, ID3v2::UniqueFileIdentifierFrame::findByOwner(&amp;tag, &quot;http://example.com&quot;));
    CPPUNIT_ASSERT_EQUAL(frame6, ID3v2::UniqueFileIdentifierFrame::findByOwner(&amp;tag, &quot;http://musicbrainz.org&quot;));
  }

  void testPropertiesMovement()
  {
    ID3v2::Tag tag;
    ID3v2::TextIdentificationFrame *frameMvnm = new ID3v2::TextIdentificationFrame(&quot;MVNM&quot;);
    frameMvnm-&gt;setText(&quot;Movement Name&quot;);
    tag.addFrame(frameMvnm);

    ID3v2::TextIdentificationFrame *frameMvin = new ID3v2::TextIdentificationFrame(&quot;MVIN&quot;);
    frameMvin-&gt;setText(&quot;2/3&quot;);
    tag.addFrame(frameMvin);

    PropertyMap properties = tag.properties();
    CPPUNIT_ASSERT(properties.contains(&quot;MOVEMENTNAME&quot;));
    CPPUNIT_ASSERT(properties.contains(&quot;MOVEMENTNUMBER&quot;));
    CPPUNIT_ASSERT_EQUAL(String(&quot;Movement Name&quot;), properties[&quot;MOVEMENTNAME&quot;].front());
    CPPUNIT_ASSERT_EQUAL(String(&quot;2/3&quot;), properties[&quot;MOVEMENTNUMBER&quot;].front());

    ByteVector frameDataMvnm(&quot;MVNM&quot;
                             &quot;\x00\x00\x00\x0e&quot;
                             &quot;\x00\x00&quot;
                             &quot;\x00&quot;
                             &quot;Movement Name&quot;, 24);
    CPPUNIT_ASSERT_EQUAL(frameDataMvnm, frameMvnm-&gt;render());
    ByteVector frameDataMvin(&quot;MVIN&quot;
                             &quot;\x00\x00\x00\x04&quot;
                             &quot;\x00\x00&quot;
                             &quot;\x00&quot;
                             &quot;2/3&quot;, 14);
    CPPUNIT_ASSERT_EQUAL(frameDataMvin, frameMvin-&gt;render());

    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();
    ID3v2::Header header;
    ID3v2::TextIdentificationFrame *parsedFrameMvnm =
      dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(
        factory-&gt;createFrame(frameDataMvnm, &amp;header));
    ID3v2::TextIdentificationFrame *parsedFrameMvin =
      dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(
        factory-&gt;createFrame(frameDataMvin, &amp;header));
    CPPUNIT_ASSERT(parsedFrameMvnm);
    CPPUNIT_ASSERT(parsedFrameMvin);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Movement Name&quot;), parsedFrameMvnm-&gt;toString());
    CPPUNIT_ASSERT_EQUAL(String(&quot;2/3&quot;), parsedFrameMvin-&gt;toString());

    tag.addFrame(parsedFrameMvnm);
    tag.addFrame(parsedFrameMvin);
  }

  void testPropertyGrouping()
  {
    ID3v2::Tag tag;
    ID3v2::TextIdentificationFrame *frameGrp1 = new ID3v2::TextIdentificationFrame(&quot;GRP1&quot;);
    frameGrp1-&gt;setText(&quot;Grouping&quot;);
    tag.addFrame(frameGrp1);

    PropertyMap properties = tag.properties();
    CPPUNIT_ASSERT(properties.contains(&quot;GROUPING&quot;));
    CPPUNIT_ASSERT_EQUAL(String(&quot;Grouping&quot;), properties[&quot;GROUPING&quot;].front());

    ByteVector frameDataGrp1(&quot;GRP1&quot;
                             &quot;\x00\x00\x00\x09&quot;
                             &quot;\x00\x00&quot;
                             &quot;\x00&quot;
                             &quot;Grouping&quot;, 19);
    CPPUNIT_ASSERT_EQUAL(frameDataGrp1, frameGrp1-&gt;render());

    ID3v2::FrameFactory *factory = ID3v2::FrameFactory::instance();
    ID3v2::Header header;
    ID3v2::TextIdentificationFrame *parsedFrameGrp1 =
      dynamic_cast&lt;ID3v2::TextIdentificationFrame *&gt;(
        factory-&gt;createFrame(frameDataGrp1, &amp;header));
    CPPUNIT_ASSERT(parsedFrameGrp1);
    CPPUNIT_ASSERT_EQUAL(String(&quot;Grouping&quot;), parsedFrameGrp1-&gt;toString());

    tag.addFrame(parsedFrameGrp1);
  }

  void testDeleteFrame()
  {
    ScopedFileCopy copy(&quot;rare_frames&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();

    {
      MPEG::File f(newname.c_str());
      ID3v2::Tag *t = f.ID3v2Tag();
      ID3v2::Frame *frame = t-&gt;frameList(&quot;TCON&quot;)[0];
      CPPUNIT_ASSERT_EQUAL(1u, t-&gt;frameList(&quot;TCON&quot;).size());
      t-&gt;removeFrame(frame, true);
      f.save(MPEG::File::ID3v2);
    }
    {
      MPEG::File f2(newname.c_str());
      ID3v2::Tag *t = f2.ID3v2Tag();
      CPPUNIT_ASSERT(t-&gt;frameList(&quot;TCON&quot;).isEmpty());
    }
  }

  void testSaveAndStripID3v1ShouldNotAddFrameFromID3v1ToId3v2()
  {
    ScopedFileCopy copy(&quot;xing&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();

    {
      MPEG::File foo(newname.c_str());
      foo.tag()-&gt;setArtist(&quot;Artist&quot;);
      foo.save(MPEG::File::ID3v1 | MPEG::File::ID3v2);
    }

    {
      MPEG::File bar(newname.c_str());
      bar.ID3v2Tag()-&gt;removeFrames(&quot;TPE1&quot;);
      // Should strip ID3v1 here and not add old values to ID3v2 again
      bar.save(MPEG::File::ID3v2, File::StripOthers);
    }

    MPEG::File f(newname.c_str());
    CPPUNIT_ASSERT(!f.ID3v2Tag()-&gt;frameListMap().contains(&quot;TPE1&quot;));
  }

  void testParseChapterFrame()
  {
    ID3v2::Header header;

    ByteVector chapterData =
      ByteVector(&quot;CHAP&quot;                     // Frame ID
                 &quot;\x00\x00\x00\x20&quot;         // Frame size
                 &quot;\x00\x00&quot;                 // Frame flags
                 &quot;\x43\x00&quot;                 // Element ID (&quot;C&quot;)
                 &quot;\x00\x00\x00\x03&quot;         // Start time
                 &quot;\x00\x00\x00\x05&quot;         // End time
                 &quot;\x00\x00\x00\x02&quot;         // Start offset
                 &quot;\x00\x00\x00\x03&quot;, 28);   // End offset
    ByteVector embeddedFrameData =
      ByteVector(&quot;TIT2&quot;                     // Embedded frame ID
                 &quot;\x00\x00\x00\x04&quot;         // Embedded frame size
                 &quot;\x00\x00&quot;                 // Embedded frame flags
                 &quot;\x00&quot;                     // TIT2 frame text encoding
                 &quot;CH1&quot;, 14);                // Chapter title

    ID3v2::ChapterFrame f1(&amp;header, chapterData);

    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;C&quot;), f1.elementID());
    CPPUNIT_ASSERT((unsigned int)0x03 == f1.startTime());
    CPPUNIT_ASSERT((unsigned int)0x05 == f1.endTime());
    CPPUNIT_ASSERT((unsigned int)0x02 == f1.startOffset());
    CPPUNIT_ASSERT((unsigned int)0x03 == f1.endOffset());
    CPPUNIT_ASSERT((unsigned int)0x00 == f1.embeddedFrameList().size());

    ID3v2::ChapterFrame f2(&amp;header, chapterData + embeddedFrameData);

    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;C&quot;), f2.elementID());
    CPPUNIT_ASSERT((unsigned int)0x03 == f2.startTime());
    CPPUNIT_ASSERT((unsigned int)0x05 == f2.endTime());
    CPPUNIT_ASSERT((unsigned int)0x02 == f2.startOffset());
    CPPUNIT_ASSERT((unsigned int)0x03 == f2.endOffset());
    CPPUNIT_ASSERT((unsigned int)0x01 == f2.embeddedFrameList().size());
    CPPUNIT_ASSERT(f2.embeddedFrameList(&quot;TIT2&quot;).size() == 1);
    CPPUNIT_ASSERT(f2.embeddedFrameList(&quot;TIT2&quot;)[0]-&gt;toString() == &quot;CH1&quot;);
  }

  void testRenderChapterFrame()
  {
    ID3v2::Header header;
    ID3v2::ChapterFrame f1(&amp;header, &quot;CHAP&quot;);
    f1.setElementID(ByteVector(&quot;\x43\x00&quot;, 2));
    f1.setStartTime(3);
    f1.setEndTime(5);
    f1.setStartOffset(2);
    f1.setEndOffset(3);
    ID3v2::TextIdentificationFrame *eF = new ID3v2::TextIdentificationFrame(&quot;TIT2&quot;);
    eF-&gt;setText(&quot;CH1&quot;);
    f1.addEmbeddedFrame(eF);

    ByteVector expected =
      ByteVector(&quot;CHAP&quot;                     // Frame ID
                 &quot;\x00\x00\x00\x20&quot;         // Frame size
                 &quot;\x00\x00&quot;                 // Frame flags
                 &quot;\x43\x00&quot;                 // Element ID
                 &quot;\x00\x00\x00\x03&quot;         // Start time
                 &quot;\x00\x00\x00\x05&quot;         // End time
                 &quot;\x00\x00\x00\x02&quot;         // Start offset
                 &quot;\x00\x00\x00\x03&quot;         // End offset
                 &quot;TIT2&quot;                     // Embedded frame ID
                 &quot;\x00\x00\x00\x04&quot;         // Embedded frame size
                 &quot;\x00\x00&quot;                 // Embedded frame flags
                 &quot;\x00&quot;                     // TIT2 frame text encoding
                 &quot;CH1&quot;, 42);                // Chapter title

    CPPUNIT_ASSERT_EQUAL(expected, f1.render());

    f1.setElementID(&quot;C&quot;);

    CPPUNIT_ASSERT_EQUAL(expected, f1.render());

    ID3v2::FrameList frames;
    eF = new ID3v2::TextIdentificationFrame(&quot;TIT2&quot;);
    eF-&gt;setText(&quot;CH1&quot;);
    frames.append(eF);

    ID3v2::ChapterFrame f2(ByteVector(&quot;\x43\x00&quot;, 2), 3, 5, 2, 3, frames);
    CPPUNIT_ASSERT_EQUAL(expected, f2.render());

    frames.clear();
    eF = new ID3v2::TextIdentificationFrame(&quot;TIT2&quot;);
    eF-&gt;setText(&quot;CH1&quot;);
    frames.append(eF);

    ID3v2::ChapterFrame f3(ByteVector(&quot;C\x00&quot;, 2), 3, 5, 2, 3, frames);
    CPPUNIT_ASSERT_EQUAL(expected, f3.render());

    frames.clear();
    eF = new ID3v2::TextIdentificationFrame(&quot;TIT2&quot;);
    eF-&gt;setText(&quot;CH1&quot;);
    frames.append(eF);

    ID3v2::ChapterFrame f4(&quot;C&quot;, 3, 5, 2, 3, frames);
    CPPUNIT_ASSERT_EQUAL(expected, f4.render());

    CPPUNIT_ASSERT(!f4.toString().isEmpty());

    ID3v2::ChapterFrame f5(&quot;C&quot;, 3, 5, 2, 3);
    eF = new ID3v2::TextIdentificationFrame(&quot;TIT2&quot;);
    eF-&gt;setText(&quot;CH1&quot;);
    f5.addEmbeddedFrame(eF);
    CPPUNIT_ASSERT_EQUAL(expected, f5.render());
  }

  void testParseTableOfContentsFrame()
  {
    ID3v2::Header header;
    ID3v2::TableOfContentsFrame f(
      &amp;header,
      ByteVector(&quot;CTOC&quot;                     // Frame ID
                 &quot;\x00\x00\x00\x16&quot;         // Frame size
                 &quot;\x00\x00&quot;                 // Frame flags
                 &quot;\x54\x00&quot;                 // Element ID (&quot;T&quot;)
                 &quot;\x01&quot;                     // CTOC flags
                 &quot;\x02&quot;                     // Entry count
                 &quot;\x43\x00&quot;                 // First entry (&quot;C&quot;)
                 &quot;\x44\x00&quot;                 // Second entry (&quot;D&quot;)
                 &quot;TIT2&quot;                     // Embedded frame ID
                 &quot;\x00\x00\x00\x04&quot;         // Embedded frame size
                 &quot;\x00\x00&quot;                 // Embedded frame flags
                 &quot;\x00&quot;                     // TIT2 frame text encoding
                 &quot;TC1&quot;, 32));               // Table of contents title
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;T&quot;), f.elementID());
    CPPUNIT_ASSERT(!f.isTopLevel());
    CPPUNIT_ASSERT(f.isOrdered());
    CPPUNIT_ASSERT((unsigned int)0x02 == f.entryCount());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;C&quot;), f.childElements()[0]);
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;D&quot;), f.childElements()[1]);
    CPPUNIT_ASSERT((unsigned int)0x01 == f.embeddedFrameList().size());
    CPPUNIT_ASSERT(f.embeddedFrameList(&quot;TIT2&quot;).size() == 1);
    CPPUNIT_ASSERT(f.embeddedFrameList(&quot;TIT2&quot;)[0]-&gt;toString() == &quot;TC1&quot;);

    f.removeChildElement(&quot;E&quot;); // not existing
    CPPUNIT_ASSERT_EQUAL(2U, f.entryCount());
    f.removeChildElement(&quot;C&quot;);
    CPPUNIT_ASSERT_EQUAL(1U, f.entryCount());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;D&quot;), f.childElements()[0]);

    ID3v2::Frame *frame = f.embeddedFrameList(&quot;TIT2&quot;)[0];
    f.removeEmbeddedFrame(frame);
    CPPUNIT_ASSERT(f.embeddedFrameList(&quot;TIT2&quot;).isEmpty());
  }

  void testRenderTableOfContentsFrame()
  {
    ID3v2::Header header;
    ID3v2::TableOfContentsFrame f(&amp;header, &quot;CTOC&quot;);
    f.setElementID(ByteVector(&quot;\x54\x00&quot;, 2));
    f.setIsTopLevel(false);
    f.setIsOrdered(true);
    f.addChildElement(ByteVector(&quot;\x43\x00&quot;, 2));
    f.addChildElement(ByteVector(&quot;\x44\x00&quot;, 2));
    ID3v2::TextIdentificationFrame *eF = new ID3v2::TextIdentificationFrame(&quot;TIT2&quot;);
    eF-&gt;setText(&quot;TC1&quot;);
    f.addEmbeddedFrame(eF);
    CPPUNIT_ASSERT_EQUAL(
      ByteVector(&quot;CTOC&quot;                     // Frame ID
                 &quot;\x00\x00\x00\x16&quot;         // Frame size
                 &quot;\x00\x00&quot;                 // Frame flags
                 &quot;\x54\x00&quot;                 // Element ID
                 &quot;\x01&quot;                     // CTOC flags
                 &quot;\x02&quot;                     // Entry count
                 &quot;\x43\x00&quot;                 // First entry
                 &quot;\x44\x00&quot;                 // Second entry
                 &quot;TIT2&quot;                     // Embedded frame ID
                 &quot;\x00\x00\x00\x04&quot;         // Embedded frame size
                 &quot;\x00\x00&quot;                 // Embedded frame flags
                 &quot;\x00&quot;                     // TIT2 frame text encoding
                 &quot;TC1&quot;, 32),                // Table of contents title
      f.render());
  }

  void testShrinkPadding()
  {
    ScopedFileCopy copy(&quot;xing&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();

    {
      MPEG::File f(newname.c_str());
      f.ID3v2Tag()-&gt;setTitle(longText(64 * 1024));
      f.save(MPEG::File::ID3v2, File::StripOthers);
    }
    {
      MPEG::File f(newname.c_str());
      CPPUNIT_ASSERT(f.hasID3v2Tag());
      CPPUNIT_ASSERT_EQUAL(74789L, f.length());
      f.ID3v2Tag()-&gt;setTitle(&quot;ABCDEFGHIJ&quot;);
      f.save(MPEG::File::ID3v2, File::StripOthers);
    }
    {
      MPEG::File f(newname.c_str());
      CPPUNIT_ASSERT(f.hasID3v2Tag());
      CPPUNIT_ASSERT_EQUAL(9263L, f.length());
    }
  }

  void testEmptyFrame()
  {
    ScopedFileCopy copy(&quot;xing&quot;, &quot;.mp3&quot;);
    string newname = copy.fileName();

    {
      MPEG::File f(newname.c_str());
      ID3v2::Tag *tag = f.ID3v2Tag(true);

      ID3v2::UrlLinkFrame *frame1 = new ID3v2::UrlLinkFrame(
        ByteVector(&quot;WOAF\x00\x00\x00\x01\x00\x00\x00&quot;, 11));
      tag-&gt;addFrame(frame1);

      ID3v2::TextIdentificationFrame *frame2 = new ID3v2::TextIdentificationFrame(&quot;TIT2&quot;);
      frame2-&gt;setText(&quot;Title&quot;);
      tag-&gt;addFrame(frame2);

      f.save();
    }

    {
      MPEG::File f(newname.c_str());
      CPPUNIT_ASSERT_EQUAL(true, f.hasID3v2Tag());

      ID3v2::Tag *tag = f.ID3v2Tag();
      CPPUNIT_ASSERT_EQUAL(String(&quot;Title&quot;), tag-&gt;title());
      CPPUNIT_ASSERT_EQUAL(true, tag-&gt;frameListMap()[&quot;WOAF&quot;].isEmpty());
    }
  }

  void testDuplicateTags()
  {
    ScopedFileCopy copy(&quot;duplicate_id3v2&quot;, &quot;.mp3&quot;);

    ByteVector audioStream;
    {
      MPEG::File f(copy.fileName().c_str());
      f.seek(f.ID3v2Tag()-&gt;header()-&gt;completeTagSize());
      audioStream = f.readBlock(2089);

      // duplicate_id3v2.mp3 has duplicate ID3v2 tags.
      // Sample rate will be 32000 if we can't skip the second tag.

      CPPUNIT_ASSERT(f.hasID3v2Tag());
      CPPUNIT_ASSERT_EQUAL((unsigned int)8049, f.ID3v2Tag()-&gt;header()-&gt;completeTagSize());

      CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());

      f.ID3v2Tag()-&gt;setArtist(&quot;Artist A&quot;);
      f.save(MPEG::File::ID3v2, File::StripOthers);
    }
    {
      MPEG::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.hasID3v2Tag());
      CPPUNIT_ASSERT_EQUAL((long)3594, f.length());
      CPPUNIT_ASSERT_EQUAL((unsigned int)1505, f.ID3v2Tag()-&gt;header()-&gt;completeTagSize());
      CPPUNIT_ASSERT_EQUAL(String(&quot;Artist A&quot;), f.ID3v2Tag()-&gt;artist());
      CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());

      f.seek(f.ID3v2Tag()-&gt;header()-&gt;completeTagSize());
      CPPUNIT_ASSERT_EQUAL(f.readBlock(2089), audioStream);

    }
  }

  void testParseTOCFrameWithManyChildren()
  {
    MPEG::File f(TEST_FILE_PATH_C(&quot;toc_many_children.mp3&quot;));
    CPPUNIT_ASSERT(f.isValid());

    ID3v2::Tag *tag = f.ID3v2Tag();
    const ID3v2::FrameList &amp;frames = tag-&gt;frameList();
    CPPUNIT_ASSERT_EQUAL(130U, frames.size());
    int i = 0;
    for(ID3v2::FrameList::ConstIterator it = frames.begin(); it != frames.end();
        ++it, ++i) {
      if(i &gt; 0) {
        CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;CHAP&quot;), (*it)-&gt;frameID());
        const ID3v2::ChapterFrame *chapFrame =
            dynamic_cast&lt;const ID3v2::ChapterFrame *&gt;(*it);
        CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;chapter&quot;) +
                             ByteVector(String::number(i - 1).toCString()),
                             chapFrame-&gt;elementID());
        CPPUNIT_ASSERT_EQUAL(static_cast&lt;unsigned int&gt;(100 * i),
                             chapFrame-&gt;startTime());
        CPPUNIT_ASSERT_EQUAL(static_cast&lt;unsigned int&gt;(100 * i),
                             chapFrame-&gt;endTime());
        const ID3v2::FrameList &amp;embeddedFrames = chapFrame-&gt;embeddedFrameList();
        CPPUNIT_ASSERT_EQUAL(1U, embeddedFrames.size());
        const ID3v2::TextIdentificationFrame *tit2Frame =
            dynamic_cast&lt;const ID3v2::TextIdentificationFrame *&gt;(
              embeddedFrames.front());
        CPPUNIT_ASSERT(tit2Frame);
        CPPUNIT_ASSERT_EQUAL(String(&quot;Marker &quot;) + String::number(i),
                             tit2Frame-&gt;fieldList().front());
      }
      else {
        CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;CTOC&quot;), (*it)-&gt;frameID());
        const ID3v2::TableOfContentsFrame *ctocFrame =
            dynamic_cast&lt;const ID3v2::TableOfContentsFrame *&gt;(*it);
        CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;toc&quot;), ctocFrame-&gt;elementID());
        CPPUNIT_ASSERT(!ctocFrame-&gt;isTopLevel());
        CPPUNIT_ASSERT(!ctocFrame-&gt;isOrdered());
        CPPUNIT_ASSERT_EQUAL(129U, ctocFrame-&gt;entryCount());
        const ID3v2::FrameList &amp;embeddedFrames = ctocFrame-&gt;embeddedFrameList();
        CPPUNIT_ASSERT_EQUAL(1U, embeddedFrames.size());
        const ID3v2::TextIdentificationFrame *tit2Frame =
            dynamic_cast&lt;const ID3v2::TextIdentificationFrame *&gt;(
              embeddedFrames.front());
        CPPUNIT_ASSERT(tit2Frame);
        CPPUNIT_ASSERT_EQUAL(StringList(&quot;toplevel toc&quot;), tit2Frame-&gt;fieldList());
      }
    }

    CPPUNIT_ASSERT(!ID3v2::ChapterFrame::findByElementID(tag, &quot;chap2&quot;));
    CPPUNIT_ASSERT(ID3v2::ChapterFrame::findByElementID(tag, &quot;chapter2&quot;));

    CPPUNIT_ASSERT(!ID3v2::TableOfContentsFrame::findTopLevel(tag));
    CPPUNIT_ASSERT(!ID3v2::TableOfContentsFrame::findByElementID(tag, &quot;ctoc&quot;));
    CPPUNIT_ASSERT(ID3v2::TableOfContentsFrame::findByElementID(tag, &quot;toc&quot;));
  }

};

CPPUNIT_TEST_SUITE_REGISTRATION(TestID3v2);

</PRE>
</div>
  </div>
</body>
</html>
