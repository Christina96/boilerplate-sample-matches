
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.717314487632509%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-amazon.cpp</h3>
            <pre><code>1  #include "amazon.h"
2  #include "net.h"
3  TStr TAmazonItem::GetStr() const {
4    TChA ChA;
5    ChA+=ItemId;
6    ChA+=' ';
7    ChA+=TitleStr;
8    for (int AuthorNmN=0; AuthorNmN<AuthorNmV.Len(); AuthorNmN++){
9      if (AuthorNmN==0){ChA+=": ";} else {ChA+=", ";}
10      ChA+=AuthorNmV[AuthorNmN];
11    }
12    return ChA;
13  }
14  PAmazonItem TAmazonItem::New(const PXmlDoc& XmlDoc){
15    PAmazonItem AmazonItem=PAmazonItem(new TAmazonItem());
16    AmazonItem->ItemId=XmlDoc->GetTagTok("AmazonItem|ItemId")->GetTokStr(false);
17    AmazonItem->TitleStr=XmlDoc->GetTagTok("AmazonItem|Title")->GetTokStr(false);
18    TXmlTokV AuthorNmTokV;
19    XmlDoc->GetTagTokV("AmazonItem|Authors|Name", AuthorNmTokV);
20    for (int AuthorNmTokN=0; AuthorNmTokN<AuthorNmTokV.Len(); AuthorNmTokN++){
21      PXmlTok AuthorNmTok=AuthorNmTokV[AuthorNmTokN];
22      TStr AuthorNm=AuthorNmTok->GetTokStr(false);
23      AmazonItem->AuthorNmV.Add(AuthorNm);
24    }
25    TXmlTokV NextItemIdTokV;
26    XmlDoc->GetTagTokV("AmazonItem|XSell|ItemId", NextItemIdTokV);
27    for (int ItemIdTokN=0; ItemIdTokN<NextItemIdTokV.Len(); ItemIdTokN++){
28      PXmlTok NextItemIdTok=NextItemIdTokV[ItemIdTokN];
29      TStr NextItemId=NextItemIdTok->GetTokStr(false);
30      AmazonItem->NextItemIdV.Add(NextItemId);
31    }
32    return AmazonItem;
33  }
34  PXmlDoc TAmazonItem::GetXmlDoc() const {
35    PXmlTok ItemXmlTok=TXmlTok::New(xsyTag, "AmazonItem");
36    PXmlTok ItemIdTxtXmlTok=TXmlTok::New(xsyStr, ItemId);
37    PXmlTok ItemIdXmlTok=TXmlTok::New(xsyTag, "ItemId");
38    ItemIdXmlTok->AddSubTok(ItemIdTxtXmlTok);
39    ItemXmlTok->AddSubTok(ItemIdXmlTok);
40    PXmlTok TitleTxtXmlTok=TXmlTok::New(xsyStr, TitleStr);
41    PXmlTok TitleXmlTok=TXmlTok::New(xsyTag, "Title");
42    TitleXmlTok->AddSubTok(TitleTxtXmlTok);
43    ItemXmlTok->AddSubTok(TitleXmlTok);
44    PXmlTok AuthorsXmlTok=TXmlTok::New(xsyTag, "Authors");
45    ItemXmlTok->AddSubTok(AuthorsXmlTok);
46    for (int AuthorNmN=0; AuthorNmN<GetAuthorNms(); AuthorNmN++){
47      PXmlTok NameXmlTok=TXmlTok::New(xsyTag, "Name");
48      AuthorsXmlTok->AddSubTok(NameXmlTok);
49      PXmlTok NameTxtXmlTok=TXmlTok::New(xsyStr, GetAuthorNm(AuthorNmN));
50      NameXmlTok->AddSubTok(NameTxtXmlTok);
51    }
52    PXmlTok XSellXmlTok=TXmlTok::New(xsyTag, "XSell");
53    ItemXmlTok->AddSubTok(XSellXmlTok);
54    for (int NextItemId=0; NextItemId<GetNextItemIds(); NextItemId++){
55      PXmlTok ItemIdXmlTok=TXmlTok::New(xsyTag, "ItemId");
56      XSellXmlTok->AddSubTok(ItemIdXmlTok);
57      PXmlTok ItemIdTxtXmlTok=TXmlTok::New(xsyStr, GetNextItemId(NextItemId));
58      ItemIdXmlTok->AddSubTok(ItemIdTxtXmlTok);
59    }
60    PXmlDoc ItemXmlDoc=TXmlDoc::New(ItemXmlTok);
61    return ItemXmlDoc;
62  }
63  PAmazonItem TAmazonItem::GetFromWebPg(const PWebPg& WebPg){
64    TStr UrlStr=WebPg->GetUrlStr();
65    TStr ItemId=TAmazonItem::GetItemId(WebPg->GetUrl());
66    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
67    PSIn HtmlSIn=TStrIn::New(HtmlStr);
68    THtmlLx HtmlLx(HtmlSIn);
69    THtmlLxSym Sym; TChA ChA;
70    while (HtmlLx.GetSym()!=hsyEof){
71      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
72      if ((Sym==hsyBTag)&&(ChA=="<FONT>")){
73        TStr FaceArg=HtmlLx.GetArg("FACE", "");
74        TStr SizeArg=HtmlLx.GetArg("SIZE", "");
75        if ((FaceArg=="verdana,arial,helvetica")&&(SizeArg.Empty())){break;}
76      }
77    }
78    TChA TitleChA;
79    while (HtmlLx.GetSym()!=hsyEof){
80      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
81      if ((Sym==hsyETag)&&(ChA=="<FONT>")){break;}
82      if (!TitleChA.Empty()){TitleChA+=HtmlLx.GetPreSpaceStr();}
83      TitleChA+=ChA;
84    }
85    TStr TitleStr=TitleChA;
86    TStrV AuthorNmV;
87    TChA AuthorNmChA;
88    while (HtmlLx.GetSym()!=hsyEof){
89      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
90      if ((Sym==hsyBTag)&&(ChA=="<A>")){
91        do {
92          HtmlLx.GetSym();
93          Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
94          if (Sym==hsyStr){
95            if (!AuthorNmChA.Empty()){AuthorNmChA+=HtmlLx.GetPreSpaceStr();}
96            AuthorNmChA+=ChA;
97          }
98        } while (!((Sym==hsyETag)&&(ChA=="<A>")));
99        AuthorNmV.Add(AuthorNmChA); AuthorNmChA.Clr();
100      }
101      if ((Sym==hsyETag)&&(ChA=="<FONT>")){break;}
102    }
103    for (int AuthorNmN=0; AuthorNmN<AuthorNmV.Len(); AuthorNmN++){
104    }
105    TStrQ PrevStrQ(3);
106    while (HtmlLx.GetSym()!=hsyEof){
107      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
108      if (Sym==hsyStr){
109        PrevStrQ.Push(ChA);
110        if ((PrevStrQ.Len()==3)&&(PrevStrQ[0]=="Customers")
111         &&(PrevStrQ[1]=="who")&&(PrevStrQ[2]=="bought")){break;}
112      } else {
113        PrevStrQ.Clr();
114      }
115    }
116    TStrV NextItemIdV;
117    while (HtmlLx.GetSym()!=hsyEof){
118      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
119      if ((Sym==hsyBTag)&&(ChA=="<A>")){
120        TStr RelUrlStr=HtmlLx.GetArg("HREF");
121        PUrl Url=TUrl::New(RelUrlStr, UrlStr);
122        TStr NextItemId=TAmazonItem::GetItemId(Url);
123        NextItemIdV.Add(NextItemId);
124      }
125      if ((Sym==hsyETag)&&(ChA=="<UL>")){break;}
126    }
127    for (int NextItemIdN=0; NextItemIdN<NextItemIdV.Len(); NextItemIdN++){
128    }
129    PAmazonItem AmazonItem=PAmazonItem(new
130     TAmazonItem(ItemId, TitleStr, AuthorNmV, NextItemIdV));
131    return AmazonItem;
132  }
133  void TAmazonItemBs::AddItemBs(const PAmazonItemBs& AmazonItemBs){
134    for (int ItemIdN=0; ItemIdN<AmazonItemBs->GetItems(); ItemIdN++){
135      PAmazonItem Item=AmazonItemBs->GetItem(ItemIdN);
136      AddItem(Item);
137    }
138  }
139  void TAmazonItemBs::GetVoidItemIdV(TStrV& VoidItemIdV) const {
140    VoidItemIdV.Clr();
141    for (int ItemIdN=0; ItemIdN<GetItems(); ItemIdN++){
142      PAmazonItem Item=GetItem(ItemIdN);
143      for (int NextItemIdN=0; NextItemIdN<Item->GetNextItemIds(); NextItemIdN++){
144        TStr NextItemId=Item->GetNextItemId(NextItemIdN);
145        if (!IsItem(NextItemId)){VoidItemIdV.AddUnique(NextItemId);}
146      }
<span onclick='openModal()' class='match'>147    }
148  }
149  PGraph TAmazonItemBs::GetGraph() const {
150    PGraph Graph=TGGraph::New();
151    for (int ItemIdN=0; ItemIdN<GetItems(); ItemIdN++){
152      PAmazonItem Item=GetItem(ItemIdN);
153      TStr VrtxNm=Item->GetStr();
</span>154      PVrtx Vrtx=PVrtx(new TGVrtx(ItemIdN, VrtxNm));
155      Graph->AddVrtx(Vrtx);
156    }
157    for (int SrcItemIdN=0; SrcItemIdN<GetItems(); SrcItemIdN++){
158      PVrtx SrcVrtx=Graph->GetVrtx(SrcItemIdN);
159      PAmazonItem SrcItem=GetItem(SrcItemIdN);
160      for (int NextItemIdN=0; NextItemIdN<SrcItem->GetNextItemIds(); NextItemIdN++){
161        TStr DstItemId=SrcItem->GetNextItemId(NextItemIdN);
162        if (IsItem(DstItemId)){
163          int DstItemIdN=GetItemIdN(DstItemId);
164          PVrtx DstVrtx=Graph->GetVrtx(DstItemIdN);
165          PEdge Edge=PEdge(new TGEdge(SrcVrtx, DstVrtx));
166          Graph->AddEdge(Edge);
167        }
168      }
169      if (SrcItemIdN%1000==0){printf("%d items converted\r", SrcItemIdN);}
170    }
171    printf("%d items converted\n", GetItems());
172    return Graph;
173  }
174  PAmazonItemBs TAmazonItemBs::LoadXml(const TStr& FNm, const int& MxItems){
175    PAmazonItemBs AmazonItemBs=TAmazonItemBs::New();
176    PSIn XmlSIn=TFIn::New(FNm);
177    forever {
178      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
179      if (!XmlDoc->IsOk()){break;}
180      PAmazonItem AmazonItem=TAmazonItem::New(XmlDoc);
181      AmazonItemBs->AddItem(AmazonItem);
182      if (AmazonItemBs->GetItems()%1000==0){
183        printf("%d items loaded\r", AmazonItemBs->GetItems());}
184      if ((MxItems!=-1)&&(AmazonItemBs->GetItems()>=MxItems)){break;}
185    }
186    printf("%d items loaded\n", AmazonItemBs->GetItems());
187    return AmazonItemBs;
188  }
189  void TAmazonItemBs::SaveXml(const TStr& FNm){
190    PSOut XmlSOut=TFOut::New(FNm);
191    for (int ItemIdN=0; ItemIdN<GetItems(); ItemIdN++){
192      PAmazonItem Item=GetItem(ItemIdN);
193      PXmlDoc XmlDoc=Item->GetXmlDoc();
194      XmlDoc->SaveTxt(XmlSOut); XmlSOut->PutDosLn();
195    }
196  }
197  TAmazonFetch::TAmazonFetch():
198    TWebPgFetch(), ItemItemIdH(100000), XmlSOut(){
199    PutMxConns(30);
200    XmlSOut=TFOut::New("amazon.xml");
201  }
202  PAmazonFetch TAmazonFetch::New(const TStr& FNm){
203    PAmazonFetch AmazonFetch=New();
204    if (!FNm.Empty()){
205      PSIn XmlSIn=TFIn::New(FNm);
206      forever {
207        PXmlDoc XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
208        if (!XmlDoc->IsOk()){break;}
209        TStr ItemId=XmlDoc->GetTagTok("AmazonItem|ItemId")->GetTokStr(false);
210        AmazonFetch->AddItem(ItemId);
211        if (AmazonFetch->GetItems()%1000==0){
212          printf("%d items loaded\r", AmazonFetch->GetItems());}
213      }
214      printf("%d items loaded\n", AmazonFetch->GetItems());
215    }
216    return AmazonFetch;
217  }
218  PAmazonFetch TAmazonFetch::New(const PAmazonItemBs& AmazonItemBs){
219    PAmazonFetch AmazonFetch=New();
220    for (int ItemIdN=0; ItemIdN<AmazonItemBs->GetItems(); ItemIdN++){
221      TStr ItemId=AmazonItemBs->GetItemId(ItemIdN);
222      AmazonFetch->AddItem(ItemId);
223    }
224    return AmazonFetch;
225  }
226  void TAmazonFetch::FetchItemIdV(const TStrV& ItemIdV){
227    for (int ItemIdN=0; ItemIdN<ItemIdV.Len(); ItemIdN++){
228      TStr UrlStr=TAmazonItem::GetUrlStr(ItemIdV[ItemIdN]);
229      FetchUrl(UrlStr);
230    }
231  }
232  void TAmazonFetch::OnFetch(const int&, const PWebPg& WebPg){
233    PAmazonItem AmazonItem=TAmazonItem::GetFromWebPg(WebPg);
234    if (!IsItem(AmazonItem->GetItemId())){
235      printf("'%s'\n", AmazonItem->GetTitleStr().CStr());
236      AddItem(AmazonItem->GetItemId());
237      PXmlDoc ItemXmlDoc=AmazonItem->GetXmlDoc();
238      ItemXmlDoc->SaveTxt(XmlSOut); XmlSOut->PutDosLn(); XmlSOut->Flush();
239      for (int ItemIdN=0; ItemIdN<AmazonItem->GetNextItemIds(); ItemIdN++){
240        TStr ItemId=AmazonItem->GetNextItemId(ItemIdN);
241        if (!IsItem(ItemId)){
242          TStr UrlStr=TAmazonItem::GetUrlStr(ItemId);
243          FetchUrl(UrlStr);
244        }
245      }
246    }
247    printf("Active:%i Queue:%i Pages:%i\r",
248     GetConnUrls(), GetWaitUrls(), GetItems());
249    if (GetConnUrls()==0){TSysMsg::Quit();}
250  }
251  void TAmazonFetch::OnError(const int&, const TStr& MsgStr){
252    printf("*** Error: %s\n", MsgStr.CStr());
253    printf("Active:%i Queue:%i Pages:%i\r",
254     GetConnUrls(), GetWaitUrls(), GetItems());
255    if (GetConnUrls()==0){TSysMsg::Quit();}
256  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webbsfetch.cpp</h3>
            <pre><code>1  const int TWebFilter::MxMxConns=1000;
2  const int TWebFilter::MxMxConnsPerSrv=100;
3  const int TWebFilter::MxMxDocSize=100000000;
4  const int TWebFilter::MxMxPathSegs=100;
5  const TStr TWebFilter::FExt=".wbf";
6  void TWebFilter::AddBadFExt(const TStr& BadFExt){
7    BadFExtH.AddKey(TStr::GetNrFExt(BadFExt.GetUc()));
8  }
9  void TWebFilter::GenDfBadFExtH(){
10    AddBadFExt(".AIFF");
11    AddBadFExt(".AU");
12    AddBadFExt(".AVI");
13    AddBadFExt(".MID");
14    AddBadFExt(".MOV");
15    AddBadFExt(".MV");
16    AddBadFExt(".MP2");
17    AddBadFExt(".MP3");
18    AddBadFExt(".M3U");
19    AddBadFExt(".MPG");
20    AddBadFExt(".MPEG");
21    AddBadFExt(".WAV");
22    AddBadFExt(".RA");
23    AddBadFExt(".RAM");
24    AddBadFExt(".RM");
25    AddBadFExt(".RMD");
26    AddBadFExt(".BMP");
27    AddBadFExt(".CDR");
28    AddBadFExt(".DWG");
29    AddBadFExt(".EPS");
30    AddBadFExt(".GIF");
31    AddBadFExt(".JPEG");
32    AddBadFExt(".JPG");
33    AddBadFExt(".TIF");
34    AddBadFExt(".TIFF");
35    AddBadFExt(".PCX");
36    AddBadFExt(".WRL");
37    AddBadFExt(".VRML");
38    AddBadFExt(".VRL");
39    AddBadFExt(".XBM");
40    AddBadFExt(".ARJ");
41    AddBadFExt(".CAB");
42    AddBadFExt(".GZ");
43    AddBadFExt(".LHA");
44    AddBadFExt(".RAR");
45    AddBadFExt(".TAR");
46    AddBadFExt(".TGZ");
47    AddBadFExt(".UU");
48    AddBadFExt(".UUE");
49    AddBadFExt(".Z");
50    AddBadFExt(".ZIP");
51    AddBadFExt(".DEB");
52    AddBadFExt(".CHANGES");
53    AddBadFExt(".1-M68K");
54    AddBadFExt(".SIGN");
55    AddBadFExt(".RPM");
56    AddBadFExt(".BAT"); 
57    AddBadFExt(".CGI"); 
58    AddBadFExt(".CMD"); 
59    AddBadFExt(".COM"); 
60    AddBadFExt(".LIB"); 
61    AddBadFExt(".OBJ"); 
62    AddBadFExt(".DLL"); 
63    AddBadFExt(".DOC"); 
64    AddBadFExt(".DOT"); 
65    AddBadFExt(".XLS"); 
66    AddBadFExt(".PPT"); 
67    AddBadFExt(".PPS"); 
68    AddBadFExt(".RTF"); 
69    AddBadFExt(".TEX"); 
70    AddBadFExt(".STY"); 
71    AddBadFExt(".DVI"); 
72    AddBadFExt(".DEF"); 
73    AddBadFExt(".TOC"); 
74    AddBadFExt(".IDX"); 
75    AddBadFExt(".IND"); 
76    AddBadFExt(".ILG"); 
77    AddBadFExt(".AUX"); 
78    AddBadFExt(".BBL"); 
79    AddBadFExt(".DVI"); 
80    AddBadFExt(".PS"); 
81    AddBadFExt(".PDF"); 
82    AddBadFExt(".HLP"); 
83    AddBadFExt(".DCL");
84    AddBadFExt(".DTD");
85    AddBadFExt(".ASM"); 
86    AddBadFExt(".A"); 
87    AddBadFExt(".LST"); 
88    AddBadFExt(".AWK"); 
89    AddBadFExt(".H"); 
90    AddBadFExt(".C"); 
91    AddBadFExt(".CC"); 
92    AddBadFExt(".CPP"); 
93    AddBadFExt(".INC"); 
94    AddBadFExt(".PRJ"); 
95    AddBadFExt(".RES"); 
96    AddBadFExt(".PAS"); 
97    AddBadFExt(".P"); 
98    AddBadFExt(".DPR"); 
99    AddBadFExt(".DFM"); 
100    AddBadFExt(".DCU"); 
101    AddBadFExt(".DSK"); 
102    AddBadFExt(".BGI"); 
103    AddBadFExt(".TPU"); 
104    AddBadFExt(".JAVA"); 
105    AddBadFExt(".CLASS"); 
106    AddBadFExt(".LGO"); 
107    AddBadFExt(".LG");
108    AddBadFExt(".LOG"); 
109    AddBadFExt(".PRO"); 
110    AddBadFExt(".ARI"); 
111    AddBadFExt(".PL"); 
112    AddBadFExt(".PERL"); 
113    AddBadFExt(".COB"); 
114    AddBadFExt(".CBL"); 
115    AddBadFExt(".F"); 
116    AddBadFExt(".FOR"); 
117    AddBadFExt(".M"); 
118    AddBadFExt(".BAS"); 
119    AddBadFExt(".JS"); 
120    AddBadFExt(".SPS"); 
121    AddBadFExt(".SH"); 
122    AddBadFExt(".KSH"); 
123    AddBadFExt(".BAK"); 
124    AddBadFExt(".$$$"); 
125    AddBadFExt(".DAT"); 
126    AddBadFExt(".OUT"); 
127    AddBadFExt(".BIN"); 
128    AddBadFExt(".IMG"); 
129    AddBadFExt(".MSG"); 
130    AddBadFExt(".TMP"); 
131    AddBadFExt(".PRN"); 
132    AddBadFExt(".PX");
133    AddBadFExt(".DB");
134    AddBadFExt(".DBF");
135    AddBadFExt(".MDB");
136    AddBadFExt(".FON"); 
137    AddBadFExt(".TTF"); 
138    AddBadFExt(".AFM"); 
139    AddBadFExt(".IDB"); 
140    AddBadFExt(".VGR"); 
141    AddBadFExt(".VG2"); 
142    AddBadFExt(".NET"); 
143    AddBadFExt(".HASH");
144    AddBadFExt(".WFL");
145    AddBadFExt(".CS");
146    AddBadFExt(".EL");
147    AddBadFExt(".LEX");
148    AddBadFExt(".TOK");
149    AddBadFExt(".BLG");
150    AddBadFExt(".RO");
151    AddBadFExt(".HU");
152    AddBadFExt(".TT"); 
153    AddBadFExt(".GED"); 
154    AddBadFExt(".INI"); 
155    AddBadFExt(".CFG"); 
156    AddBadFExt(".CONF"); 
157    AddBadFExt(".CDF"); 
158    AddBadFExt(".ASC"); 
159    AddBadFExt(".DSC"); 
160    AddBadFExt(".INF"); 
161    AddBadFExt(".CIR"); 
162    AddBadFExt(".MOT"); 
163    AddBadFExt(".PUD");
164    AddBadFExt(".UID");
165    AddBadFExt(".PPZ");
166    AddBadFExt(".HQX");
167    AddBadFExt(".HLB");
168    AddBadFExt(".FLI");
169    AddBadFExt(".MCD");
170    AddBadFExt(".SKR");
171    AddBadFExt(".SCR");
172  }
173  bool TWebFilter::IsOkFExt(const TStr& FExt){
174    return
175     (!BadFExtH.IsKey(TStr::GetNrFExt(FExt.GetUc()))) &&
176     (!FExt.IsChIn(';'));
177  }
178  bool TWebFilter::IsUrlTok(const PHtmlTok& Tok, TStr& RelUrlStr){
179    if (Tok->GetSym()==hsyBTag){
180      TStr TagNm=Tok->GetStr();
181      if ((TagNm==THtmlTok::ATagNm)&&(Tok->IsArg(THtmlTok::HRefArgNm))){
182        RelUrlStr=Tok->GetArg(THtmlTok::HRefArgNm); return true;}
183      else if ((TagNm==THtmlTok::AreaTagNm)&&(Tok->IsArg(THtmlTok::HRefArgNm))){
184        RelUrlStr=Tok->GetArg(THtmlTok::HRefArgNm); return true;}
185      else if ((TagNm==THtmlTok::FrameTagNm)&&(Tok->IsArg(THtmlTok::SrcArgNm))){
186        RelUrlStr=Tok->GetArg(THtmlTok::SrcArgNm); return true;}
187      else if ((TagNm==THtmlTok::ImgTagNm)&&(Tok->IsArg(THtmlTok::SrcArgNm))){
188        RelUrlStr=Tok->GetArg(THtmlTok::SrcArgNm); return true;}
189      else if ((TagNm==THtmlTok::MetaTagNm)&&(Tok->IsArg(THtmlTok::HttpEquivArgNm))){
190        TStr HttpEquivArgVal=Tok->GetArg(THtmlTok::HttpEquivArgNm).GetUc();
191        if (HttpEquivArgVal=="REFRESH"){
192          TStr ContentStr=Tok->GetArg("CONTENT");
193          TStr LeftStr; TStr RightStr; TStr UrlEqStr="URL=";
194          ContentStr.GetUc().SplitOnStr(LeftStr, UrlEqStr, RightStr);
195          RelUrlStr=ContentStr.GetSubStr(
196           LeftStr.Len()+UrlEqStr.Len(), ContentStr.Len());
197          return !RelUrlStr.Empty();
198        } else {
199          return false;
200        }
201      }
202    }
203    return false;
204  }
205  bool TWebFilter::IsUrlOk(const PUrl& Url){
206    if (!Url->IsOk(usHttp)){return false;}
207    if (IsOkPassConstrUrl(Url->GetAsFinalUrlStr())){return true;}
208    if (!IsOkDoAllowScripts(Url->GetAsFinalUrlStr())){return false;}
209    if (!IsOkDmConstr(Url->GetHostNm())){return false;}
210    if (Url->GetPathSegs()>int(MxPathSegs)){return false;}
211    if (Url->IsDefFinalUrl()){
212      return
213       IsOkPosConstrUrl(Url->GetFinalUrlStr())&&
214       IsOkNegConstrUrl(Url->GetFinalUrlStr());
215    } else {
216      return true;
217    }
218  }
219  PWebFilter TWebFilter::LoadTxt(const PSIn& SIn){
220    PWebFilter WebFilter=PWebFilter(new TWebFilter());
221    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloCsSens);
222    Lx.GetVar("WebFilter", true, true);
223    WebFilter->MxConns=Lx.GetVarInt("MxConns");
224    WebFilter->MxConnsPerSrv=Lx.GetVarInt("MxConnsPerSrv");
225    WebFilter->MxDocSize=Lx.GetVarInt("MxDocSize");
226    WebFilter->MxPathSegs=Lx.GetVarInt("MxPathSegs");
227    WebFilter->DoAllowScripts=Lx.GetVarBool("DoAllowScripts");
228    Lx.GetVarStrV("StartUrlStrV", WebFilter->StartUrlStrV);
229    Lx.GetVarStrV("DmConstrStrV", WebFilter->DmConstrStrV);
230    Lx.GetVarStrV("PassConstrUrlStrV", WebFilter->PassConstrUrlStrV);
231    Lx.GetVarStrV("PosConstrUrlStrV", WebFilter->PosConstrUrlStrV);
232    Lx.GetVarStrV("NegConstrUrlStrV", WebFilter->NegConstrUrlStrV);
233    Lx.GetVarEnd(true, true);
234    return WebFilter;
235  }
236  void TWebFilter::SaveTxt(const PSOut& SOut){
237    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens|oloVarIndent);
238    Lx.PutVar("WebFilter", true, true);
239    Lx.PutVarInt("MxConns", MxConns);
240    Lx.PutVarInt("MxConnsPerSrv", MxConnsPerSrv);
241    Lx.PutVarInt("MxDocSize", MxDocSize);
242    Lx.PutVarInt("MxPathSegs", MxPathSegs);
243    Lx.PutVarBool("DoAllowScripts", DoAllowScripts);
244    Lx.PutVarStrV("StartUrlStrV", StartUrlStrV);
245    Lx.PutVarStrV("DmConstrStrV", DmConstrStrV);
246    Lx.PutVarStrV("PassConstrUrlStrV", PassConstrUrlStrV);
247    Lx.PutVarStrV("PosConstrUrlStrV", PosConstrUrlStrV);
248    Lx.PutVarStrV("NegConstrUrlStrV", NegConstrUrlStrV);
249    Lx.PutVarEnd(true, true);
250  }
251  class TWebBsFetchEvent: public TSockEvent{
252  private:
253    static const int MxRetries;
254    TWebBsFetch* Fetch;
255    TBlobPt UrlStrId;
256    int FId;
257    PUrl TopUrl;
258    PUrl CurUrl;
259    TStrV UrlStrV;
260    TStrV IpNumV;
261    TStrStrH CookieNmToValH;
262    PSockHost SockHost;
263    PSock Sock;
264    int Retries;
265    TBool OppSockClosed;
266    TMOut SockMOut;
267    void ChangeLastUrlToLc(const PHttpResp& HttpResp);
268    void CloseConn(){SockHost.Clr(); Sock.Clr();}
269  public:
270    TWebBsFetchEvent(TWebBsFetch* _WebBsFetch,
271     const TBlobPt& _UrlStrId, const TInt& _FId, const PUrl& _Url);
272    ~TWebBsFetchEvent(){CloseConn();}
273    TSockEvent& operator=(const TSockEvent&){Fail; return *this;}
274    void OnFetchError(const TStr& MsgStr);
275    void OnFetchEnd(const PHttpResp& HttpResp);
276    void OnFetchEnd();
277    void OnRead(const int& SockId, const PSIn& SIn);
278    void OnWrite(const int&){}
279    void OnOob(const int&){Fail;}
280    void OnAccept(const int&, const PSock&){Fail;}
281    void OnConnect(const int&);
282    void OnClose(const int&);
283    void OnTimeOut(const int&);
284    void OnError(const int&, const int&, const TStr&);
285    void OnGetHost(const PSockHost& _SockHost);
286  };
287  const int TWebBsFetchEvent::MxRetries=5;
288  void TWebBsFetchEvent::ChangeLastUrlToLc(const PHttpResp& HttpResp){
289    static TStr MsNm="Microsoft";
290    static TStr HttpsNm="HTTPS";
291    TStr SrvNm=HttpResp->GetSrvNm();
292    if ((SrvNm.IsPrefix(MsNm))||(SrvNm.IsPrefix(HttpsNm))){
293      if (!UrlStrV.Last().IsLc()){
294        PUrl Url=TUrl::New(UrlStrV.Last());
295        Url->ToLcPath();
296        UrlStrV.Last()=Url->GetUrlStr();
297      }
298    }
299  }
300  TWebBsFetchEvent::TWebBsFetchEvent(TWebBsFetch* _Fetch,
301   const TBlobPt& _UrlStrId, const TInt& _FId, const PUrl& _Url):
302    TSockEvent(),
303    Fetch(_Fetch), UrlStrId(_UrlStrId), FId(_FId),
304    TopUrl(_Url), CurUrl(_Url), UrlStrV(), IpNumV(),
305    SockHost(NULL), Sock(NULL),
306    Retries(0), OppSockClosed(true),
307    SockMOut(10000){}
308  void TWebBsFetchEvent::OnFetchError(const TStr& MsgStr){
309    Fetch->DequeueUrl(UrlStrId, TopUrl);
310    CloseConn();
311    Fetch->OnError(FId, MsgStr+" ["+CurUrl->GetUrlStr()+"]");
312    Fetch->OnStatus(Fetch->GetStatusStr());
313  }
314  void TWebBsFetchEvent::OnFetchEnd(const PHttpResp& HttpResp){
315    IAssert(HttpResp->IsOk());
316    int StatusCd=HttpResp->GetStatusCd();
317    if (StatusCd/100==2){ 
318      ChangeLastUrlToLc(HttpResp);
319      PWebPg WebPg=TWebPg::New(UrlStrV, IpNumV, HttpResp);
320      Fetch->DequeueUrl(UrlStrId, TopUrl);
321      Fetch->OnFetch(FId, WebPg);
322      Fetch->OnInfo(FId, WebPg->GetUrlStr());
323      Fetch->OnStatus(Fetch->GetStatusStr());
324      CloseConn();
325    } else
326    if (StatusCd/100==3){ 
327      ChangeLastUrlToLc(HttpResp);
328      if (UrlStrV.Len()<5){
329        TStr RedirUrlStr=HttpResp->GetFldVal(THttp::LocFldNm);
330        PUrl RedirUrl=TUrl::New(RedirUrlStr, CurUrl->GetUrlStr());
331        if (RedirUrl->IsOk(usHttp)){
332          CurUrl=RedirUrl; Retries=0;
333          CloseConn();
334          Fetch->SetUrlAsFinal(CurUrl);
335          if (Fetch->DoStillFetchUrl(CurUrl)){
336            TSockHost::GetAsyncSockHost(CurUrl->GetIpNumOrHostNm(), this);
337          } else {
338            Fetch->OnInfo(FId,
339             TStr("Redirection already fetched [")+CurUrl->GetUrlStr()+"]");
340            Fetch->OnStatus(Fetch->GetStatusStr());
341            Fetch->DequeueUrl(UrlStrId, TopUrl);
342          }
343        } else {
344          OnFetchError(TStr("Invalid Redirection URL (")+RedirUrlStr+")");
345        }
346      } else {
347        OnFetchError("Cycling Redirection");
348      }
349    } else { 
350      TStr MsgStr=TStr("Http Error (")+HttpResp->GetReasonPhrase()+")";
351      OnFetchError(MsgStr);
352    }
353  }
354  void TWebBsFetchEvent::OnFetchEnd(){
355    int MxDocSize=-1;
356    if (!Fetch->WebFilter->IsOkDocSize(SockMOut.Len())){
357      if (!Fetch->WebFilter->IsOkPassConstrUrl(CurUrl->GetFinalUrlStr())){
358        MxDocSize=Fetch->WebFilter->GetMxDocSize();
359      }
360    }
361    PSIn SIn=SockMOut.GetSIn(true, MxDocSize);
362    PHttpResp HttpResp=THttpResp::LoadTxt(SIn);
363    if (HttpResp->IsOk()){
364      OnFetchEnd(HttpResp);
365    } else {
366      OnFetchError("Invalid Http Response");
367    }
368  }
369  void TWebBsFetchEvent::OnRead(const int&, const PSIn& SIn){
370    SockMOut.Save(*SIn);
371    if (!Fetch->WebFilter->IsOkDocSize(SockMOut.Len())){
372      if (!Fetch->WebFilter->IsOkPassConstrUrl(CurUrl->GetFinalUrlStr())){
373        OnFetchEnd();
374      }
375    }
376  }
377  void TWebBsFetchEvent::OnConnect(const int&){
378    TStr HostNm=CurUrl->GetHostNm();
379    TStr AbsPath=CurUrl->GetPathStr()+CurUrl->GetSearchStr();
380    TChA RqChA;
381    RqChA+="GET "; RqChA+=AbsPath; RqChA+=" HTTP/1.0\r\n";
382    RqChA+="Host: "; RqChA+=HostNm; RqChA+="\r\n";
383    RqChA+="\r\n";
384    PSIn RqSIn=TMIn::New(RqChA);
385    bool Ok; int ErrCd; Sock->Send(RqSIn, Ok, ErrCd);
386    if (Ok){
387      Sock->PutTimeOut(10000);
388    } else {
389      OnFetchError("Unable to send the data");
390    }
391  }
392  void TWebBsFetchEvent::OnClose(const int&){
393    OppSockClosed=true;
394    Sock->PutTimeOut(1);
395  }
396  void TWebBsFetchEvent::OnTimeOut(const int&){
397    if (OppSockClosed){
398      OnFetchEnd();
399    } else {
400      Retries++;
401      if (Retries<MxRetries){
402        OnGetHost(SockHost);
403      } else {
404        OnFetchError("Timeout");
405      }
406    }
407  }
408  void TWebBsFetchEvent::OnError(const int&, const int&, const TStr& SockErrStr){
409    Retries++;
410    if (Retries<MxRetries){
411      OnGetHost(SockHost);
412    } else {
413      OnFetchError(TStr("Socket Error (")+SockErrStr+")");
414    }
415  }
416  void TWebBsFetchEvent::OnGetHost(const PSockHost& _SockHost){
417    if (_SockHost->IsOk()){
418      SockHost=_SockHost;
419      TStr FinalHostNm=SockHost->GetHostNm();
420      Fetch->SetUrlAsFinal(CurUrl);
421      if (CurUrl->IsDefFinalUrl()){
422        if (FinalHostNm!=CurUrl->GetFinalHostNm()){
423          TChA MsgChA="Different final host names [";
424          MsgChA+=FinalHostNm; MsgChA+="] [";
425          MsgChA+=CurUrl->GetFinalHostNm(); MsgChA+="]";
426          Fetch->OnError(FId, MsgChA);
427        }
428      } else {
429        Fetch->DefFinalHostDesc(CurUrl->GetHostNm(), FinalHostNm);
430        CurUrl->DefFinalUrl(FinalHostNm);
431      }
432      if (Fetch->DoStillFetchUrl(CurUrl)){
433        UrlStrV.Add(CurUrl->GetFinalUrlStr());
434        IpNumV.Add(SockHost->GetIpNum());
435        OppSockClosed=false;
436        SockMOut.Clr();
437        Sock=TSock::New(this);
438        Sock->Connect(SockHost, CurUrl->GetPortN());
439        Sock->PutTimeOut(10000);
440      } else {
441        Fetch->DequeueUrl(UrlStrId, TopUrl);
442        CloseConn();
443        Fetch->OnError(FId, TStr("Bad host name [")+CurUrl->GetUrlStr()+"]");
444        Fetch->OnStatus(Fetch->GetStatusStr());
445      }
446    } else
447    if (_SockHost->GetStatus()==shsTryAgain){
448      Retries++;
449      if (Retries<MxRetries){
450        TSockHost::GetAsyncSockHost(CurUrl->GetIpNumOrHostNm(), this);
451      } else {
452        OnFetchError("Can't get host info");
453      }
454    } else {
455      OnFetchError("Invalid Host");
<span onclick='openModal()' class='match'>456    }
457  }
458  PWebHostNmBs TWebHostNmBs::LoadTxt(const PSIn& SIn){
459    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloCsSens);
460    TStrPrV HostNmPrV;
461    Lx.GetVarStrPrV("HostNmPrV", HostNmPrV);
462    PWebHostNmBs WebHostNmBs=PWebHostNmBs(new TWebHostNmBs());
463    for (int HostNmPrN=0; HostNmPrN<HostNmPrV.Len(); HostNmPrN++){
464      TStr AliasNm=HostNmPrV[HostNmPrN].Val1;
465      TStr FinalNm=HostNmPrV[HostNmPrN].Val2;
</span>466      WebHostNmBs->AddAliasToFinalNm(AliasNm, FinalNm);
467    }
468    return WebHostNmBs;
469  }
470  void TWebHostNmBs::SaveTxt(const PSOut& SOut) const {
471    TStrPrV HostNmPrV(AliasToFinalNmH.Len(), 0);
472    int HostNmP=AliasToFinalNmH.FFirstKeyId();
473    while (AliasToFinalNmH.FNextKeyId(HostNmP)){
474      TStr AliasNm=AliasToFinalNmH.GetKey(HostNmP);
475      TStr FinalNm=AliasToFinalNmH[HostNmP];
476      HostNmPrV.Add(TStrPr(AliasNm, FinalNm));
477    }
478    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens|oloVarIndent);
479    Lx.PutVarStrPrV("HostNmPrV", HostNmPrV);
480  }
481  const TStr TWebBsFetch::WebBsFetchFExt=".wfm";
482  const TStr TWebBsFetch::WebBsFetchUrlFExt=".wfu";
483  const TStr TWebBsFetch::WebHostBsFExt=".whb";
484  const int TWebBsFetch::EstWebPgs=10000;
485  const int TWebBsFetch::EstHostNms=10000;
486  const int TWebBsFetch::UrlStrHCacheSize=10000000;
487  void TWebBsFetch::DefFinalHostDesc(
488   const TStr& AliasHostNm, const TStr& FinalHostNm){
489    TWebBsFetchHostDesc& AliasHostDesc=HostNmToDescH.GetDat(AliasHostNm);
490    IAssert(!AliasHostDesc.IsDefFinalHostNm());
491    AliasHostDesc.PutFinalHostNm(FinalHostNm);
492    if (AliasHostNm!=FinalHostNm){
493      TWebBsFetchHostDesc& FinalHostDesc=HostNmToDescH.AddDat(FinalHostNm);
494      if (!FinalHostDesc.IsDefFinalHostNm()){
495        FinalHostDesc.PutFinalHostNm(FinalHostNm);
496      } else {
497        IAssert(FinalHostNm==FinalHostDesc.GetFinalHostNm());
498      }
499      FinalHostDesc.AddConns(AliasHostDesc.GetConns());
500      AliasHostDesc.UndefConns();
501    }
502  }
503  TWebBsFetchHostDesc& TWebBsFetch::GetAsFinalHostDesc(const PUrl& Url){
504    SetUrlAsFinal(Url);
505    TStr HostNm=Url->GetHostNm();
506    if (Url->IsDefFinalUrl()){
507      TStr FinalHostNm=Url->GetFinalHostNm(); int HostId;
508      if (HostNmToDescH.IsKey(FinalHostNm, HostId)){
509        return HostNmToDescH[HostId];
510      } else {
511        HostNmToDescH.AddDat(HostNm).PutFinalHostNm(FinalHostNm);
512        TWebBsFetchHostDesc& HostDesc=HostNmToDescH.AddDat(FinalHostNm);
513        HostDesc.PutFinalHostNm(FinalHostNm);
514        return HostDesc;
515      }
516    } else {
517      return HostNmToDescH.AddDat(HostNm);
518    }
519  }
520  void TWebBsFetch::EnqueueUrl(const int& FId, const PUrl& Url){
521    TStr UrlStr=Url->GetUrlStr();
522    TBlobPt UrlStrId; UrlStrToFIdH->IsKey(UrlStr, UrlStrId);
523    TBlobPt FinalUrlStrId;
524    if (SetUrlAsFinal(Url)){
525      TStr FinalUrlStr=Url->GetFinalUrlStr();
526      UrlStrToFIdH->IsKey(FinalUrlStr, FinalUrlStrId);
527    }
528    if ((UrlStrId.Empty())&&(FinalUrlStrId.Empty())){
529      UrlStrId=UrlStrToFIdH->AddFDat(UrlStr, FId);
530      UrlStrIdQ.Push(UrlStrId);
531    }
532  }
533  void TWebBsFetch::DequeueUrl(const TBlobPt& UrlStrId, const PUrl& Url){
534    UrlStrToFIdH->DelKeyId(UrlStrId);
535    TWebBsFetchHostDesc& HostDesc=GetAsFinalHostDesc(Url);
536    HostDesc.DecConns();
537    PSockEvent SockEvent=UrlStrIdToSockEventH.GetDat(UrlStrId);
538    TSockEvent::UnReg(SockEvent);
539    UrlStrIdToSockEventH.DelKey(UrlStrId);
540    GoFetch();
541    if (GetConns()==0){OnInfo("No Connections.");}
542  }
543  int TWebBsFetch::FetchUrl(const PUrl& Url, const bool& GoFetching){
544    int FId=-1;
545    if (Url->IsOk(usHttp)){
546      FId=GetNextFId();
547      EnqueueUrl(FId, Url);
548      if (GoFetching){GoFetch();}
549    } else {
550      TStr MsgStr=TStr("Invalid URL [")+
551       Url->GetRelUrlStr()+"] + ["+Url->GetBaseUrlStr()+"]";
552      OnError(FId, MsgStr);
553    }
554    return FId;
555  }
556  bool TWebBsFetch::DoStillFetchUrl(const PUrl& Url){
557    if (!Url->IsDefFinalUrl()){return true;}
558    return WebFilter->IsUrlOk(Url)&&(!WebBs->IsUrlStr(Url->GetFinalUrlStr()));
559  }
560  TWebBsFetch::TWebBsFetch(
561   const TStr& Nm, const TStr& FPath, const TFAccess& _Access, TWebBs* _WebBs,
562   const PWebFilter& _WebFilter, const bool& _IndexTxtBsP):
563    WebBs(_WebBs), WebBsFetchFNm(), WebHostBsFNm(), Access(_Access),
564    LastFId(-1), WebFilter(_WebFilter), IndexTxtBsP(_IndexTxtBsP),
565    UrlStrToFIdH(),
566    UrlStrIdQ(EstWebPgs),
567    UrlStrIdToSockEventH(TWebFilter::MxMxConns),
568    HostNmToDescH(EstHostNms){
569    TStr WebBsFetchUrlFNm;
570    GetFNms(Nm, FPath, WebBsFetchFNm, WebBsFetchUrlFNm, WebHostBsFNm);
571    if (Access==faCreate){
572      IAssert(!WebFilter.Empty());
573      LastFId=0;
574      TFOut WebBsFetchFOut(WebBsFetchFNm);
575      LastFId.Save(WebBsFetchFOut);
576      WebFilter->Save(WebBsFetchFOut);
577      UrlStrToFIdH=PUrlStrToFIdH(new
578       TUrlStrToFIdH(WebBsFetchUrlFNm, Access, EstWebPgs, UrlStrHCacheSize));
579      for (int UrlN=0; UrlN<WebFilter->GetStartUrls(); UrlN++){
580        AddFetchUrl(WebFilter->GetStartUrl(UrlN));}
581    } else {
582      IAssert(Access==faUpdate);
583      IAssert(Exists(Nm, FPath));
584      IAssert(WebFilter.Empty());
585      TFIn WebBsFetchFIn(WebBsFetchFNm);
586      LastFId=TInt(WebBsFetchFIn);
587      WebFilter=TWebFilter::Load(WebBsFetchFIn);
588      UrlStrToFIdH=PUrlStrToFIdH(new
589       TUrlStrToFIdH(WebBsFetchUrlFNm, Access, -1, UrlStrHCacheSize));
590      TBlobPt UrlStrToStatusP=UrlStrToFIdH->FFirstKeyId(); TBlobPt UrlStrId;
591      while (UrlStrToFIdH->FNextKeyId(UrlStrToStatusP, UrlStrId)){
592        UrlStrIdQ.Push(UrlStrId);}
593    }
594  }
595  TWebBsFetch::~TWebBsFetch(){
596    int UrlStrIdP=UrlStrIdToSockEventH.FFirstKeyId();
597    while (UrlStrIdToSockEventH.FNextKeyId(UrlStrIdP)){
598      PSockEvent SockEvent=UrlStrIdToSockEventH[UrlStrIdP];
599      UrlStrIdToSockEventH[UrlStrIdP].Clr();
600      TSockEvent::UnReg(SockEvent);
601      SockEvent->CloseConn();
602    }
603    TFOut WebBsFetchFOut(WebBsFetchFNm);
604    LastFId.Save(WebBsFetchFOut);
605    WebFilter->Save(WebBsFetchFOut);
606    PWebHostNmBs WebHostNmBs=GetHostNmBs();
607    PSOut WebHostBsSOut=TFOut::New(WebHostBsFNm);
608    WebHostNmBs->SaveTxt(WebHostBsSOut);
609  }
610  bool TWebBsFetch::SetUrlAsFinal(const PUrl& Url){
611    if (Url->IsDefFinalUrl()){
612      return true;
613    } else {
614      TStr HostNm=Url->GetHostNm(); int HostId;
615      if (HostNmToDescH.IsKey(HostNm, HostId)){
616        TWebBsFetchHostDesc& HostDesc=HostNmToDescH[HostId];
617        if (HostDesc.IsDefFinalHostNm()){
618          if (HostDesc.IsAliasHostNm(HostNm)){
619            Url->DefFinalUrl(HostDesc.GetFinalHostNm());
620          } else {
621            Url->DefUrlAsFinal();
622          }
623          return true;
624        } else {
625          return false;
626        }
627      } else {
628        HostNmToDescH.AddDat(HostNm);
629        return false;
630      }
631    }
632  }
633  PWebHostNmBs TWebBsFetch::GetHostNmBs() const {
634    PWebHostNmBs WebHostNmBs=PWebHostNmBs(new TWebHostNmBs());
635    int HostNmToDescP=HostNmToDescH.FFirstKeyId();
636    while (HostNmToDescH.FNextKeyId(HostNmToDescP)){
637      TStr AliasHostNm=HostNmToDescH.GetKey(HostNmToDescP);
638      const TWebBsFetchHostDesc& HostDesc=HostNmToDescH[HostNmToDescP];
639      if ((HostDesc.IsDefFinalHostNm())
640       ){
641        TStr FinalHostNm=HostDesc.GetFinalHostNm();
642        WebHostNmBs->AddAliasToFinalNm(AliasHostNm, FinalHostNm);
643      }
644    }
645    return WebHostNmBs;
646  }
647  void TWebBsFetch::GetHostNmConnsPrV(TStrIntPrV& HostNmConnsPrV) const {
648    TStrIntH HostNmToConnsH(UrlStrIdToSockEventH.Len()+1);
649    int UrlStrIdP=UrlStrIdToSockEventH.FFirstKeyId();
650    while (UrlStrIdToSockEventH.FNextKeyId(UrlStrIdP)){
651      TBlobPt UrlStrId=UrlStrIdToSockEventH.GetKey(UrlStrIdP);
652      TStr UrlStr; TInt FId;
653      UrlStrToFIdH->GetKeyFDat(UrlStrId, UrlStr, FId);
654      PUrl Url=TUrl::New(UrlStr); IAssert(Url->IsOk());
655      HostNmToConnsH.AddDat(Url->GetHostNm())++;
656    }
657    TIntStrPrV ConnsHostNmPrV(HostNmToConnsH.Len(), 0);
658    int HostNmP=HostNmToConnsH.FFirstKeyId();
659    while (HostNmToConnsH.FNextKeyId(HostNmP)){
660      TStr HostNm=HostNmToConnsH.GetKey(HostNmP);
661      int Conns=HostNmToConnsH[HostNmP];
662      ConnsHostNmPrV.Add(TIntStrPr(Conns, HostNm));
663    }
664    ConnsHostNmPrV.Sort();
665    HostNmConnsPrV.Gen(ConnsHostNmPrV.Len(), 0);
666    for (int ConnsN=0; ConnsN<ConnsHostNmPrV.Len(); ConnsN++){
667      int Conns=ConnsHostNmPrV[ConnsN].Val1;
668      TStr HostNm=ConnsHostNmPrV[ConnsN].Val2;
669      HostNmConnsPrV.Add(TStrIntPr(HostNm, Conns));
670    }
671  }
672  TStr TWebBsFetch::GetHostNmConnsPrVStr() const {
673    TStrIntPrV HostNmConnsPrV; GetHostNmConnsPrV(HostNmConnsPrV);
674    TChA ChA;
675    for (int HostNmN=0; HostNmN<HostNmConnsPrV.Len(); HostNmN++){
676      TStr HostNm=HostNmConnsPrV[HostNmN].Val1;
677      int Conns=HostNmConnsPrV[HostNmN].Val2;
678      ChA+=HostNm; ChA+=":"; ChA+=TInt::GetStr(Conns); ChA+="   "; 
679    }
680    return ChA;
681  }
682  void TWebBsFetch::GetHostNmQueuedPrV(TStrIntPrV& HostNmQueuedPrV) const {
683    TStrIntH HostNmToQueuedH(UrlStrIdQ.Len()/10+1);
684    for (int UrlStrIdN=0; UrlStrIdN<UrlStrIdQ.Len() ; UrlStrIdN++){
685      TBlobPt UrlStrId=UrlStrIdQ[UrlStrIdN];
686      TStr UrlStr; TInt FId;
687      UrlStrToFIdH->GetKeyFDat(UrlStrId, UrlStr, FId);
688      PUrl Url=TUrl::New(UrlStr); IAssert(Url->IsOk());
689      HostNmToQueuedH.AddDat(Url->GetHostNm())++;
690    }
691    TIntStrPrV QueuedHostNmPrV(HostNmToQueuedH.Len(), 0);
692    int HostNmP=HostNmToQueuedH.FFirstKeyId();
693    while (HostNmToQueuedH.FNextKeyId(HostNmP)){
694      TStr HostNm=HostNmToQueuedH.GetKey(HostNmP);
695      int Queued=HostNmToQueuedH[HostNmP];
696      QueuedHostNmPrV.Add(TIntStrPr(Queued, HostNm));
697    }
698    QueuedHostNmPrV.Sort(false);
699    HostNmQueuedPrV.Gen(QueuedHostNmPrV.Len(), 0);
700    for (int QueuedN=0; QueuedN<QueuedHostNmPrV.Len(); QueuedN++){
701      int Queued=QueuedHostNmPrV[QueuedN].Val1;
702      TStr HostNm=QueuedHostNmPrV[QueuedN].Val2;
703      HostNmQueuedPrV.Add(TStrIntPr(HostNm, Queued));
704    }
705  }
706  TStr TWebBsFetch::GetHostNmQueuedPrVStr(const int& ShowLen) const {
707    TStrIntPrV HostNmQueuedPrV; GetHostNmQueuedPrV(HostNmQueuedPrV);
708    int UpHostNmN=TInt::GetMn(ShowLen, HostNmQueuedPrV.Len());
709    TChA ChA;
710    for (int HostNmN=0; HostNmN<UpHostNmN; HostNmN++){
711      TStr HostNm=HostNmQueuedPrV[HostNmN].Val1;
712      int Queued=HostNmQueuedPrV[HostNmN].Val2;
713      ChA+=HostNm; ChA+=":"; ChA+=TInt::GetStr(Queued); ChA+="\r\n";
714    }
715    return ChA;
716  }
717  void TWebBsFetch::GoFetch(){
718    TBlobPtV RepushedUrlStrIdV;
719    while ((WebFilter->IsOkConns(GetConns()))&&(UrlStrIdQ.Len()>0)){
720      TBlobPt UrlStrId=UrlStrIdQ.Top(); UrlStrIdQ.Pop();
721      TStr UrlStr; TInt FId;
722      UrlStrToFIdH->GetKeyFDat(UrlStrId, UrlStr, FId);
723      PUrl Url=TUrl::New(UrlStr); IAssert(Url->IsOk());
724      SetUrlAsFinal(Url);
725      if (DoStillFetchUrl(Url)){
726        TWebBsFetchHostDesc& HostDesc=GetAsFinalHostDesc(Url);
727        IAssert(HostDesc.IsDefConns());
728        if (WebFilter->IsOkConnsPerSrv(HostDesc.GetConns())){
729          HostDesc.IncConns();
730          PSockEvent SockEvent=PSockEvent(new
731           TWebBsFetchEvent(this, UrlStrId, FId, Url));
732          TSockEvent::Reg(SockEvent);
733          UrlStrIdToSockEventH.AddDat(UrlStrId, SockEvent);
734          TSockHost::GetAsyncSockHost(Url->GetIpNumOrHostNm(), SockEvent);
735        } else {
736          UrlStrIdQ.Push(UrlStrId); 
737          if ((RepushedUrlStrIdV.Len()>100)||
738           (RepushedUrlStrIdV.IsIn(UrlStrId))){break;} 
739          RepushedUrlStrIdV.Add(UrlStrId); 
740        }
741      } else {
742        UrlStrToFIdH->DelKeyId(UrlStrId);
743      }
744    }
745  }
746  void TWebBsFetch::GetFNms(
747   const TStr& Nm, const TStr& FPath,
748   TStr& WebBsFetchFNm, TStr& WebBsFetchUrlFNm, TStr& WebHostBsFNm){
749    TStr NrFPath=TStr::GetNrFPath(FPath);
750    TStr NrNm=TStr::GetNrFMid(Nm);
751    WebBsFetchFNm=NrFPath+NrNm+WebBsFetchFExt;
752    WebBsFetchUrlFNm=NrFPath+NrNm+WebBsFetchUrlFExt;
753    WebHostBsFNm=NrFPath+NrNm+WebHostBsFExt;
754  }
755  bool TWebBsFetch::Exists(const TStr& Nm, const TStr& FPath){
756    TStr WebBsFetchFNm; TStr WebBsFetchUrlFNm; TStr WebHostBsFNm;
757    GetFNms(Nm, FPath, WebBsFetchFNm, WebBsFetchUrlFNm, WebHostBsFNm);
758    return
759     TFile::Exists(WebBsFetchFNm)&&
760     TFile::Exists(WebBsFetchUrlFNm)&&
761     TFile::Exists(WebHostBsFNm);
762  }
763  void TWebBsFetch::Del(const TStr& Nm, const TStr& FPath){
764    if (Exists(Nm, FPath)){
765      TStr WebBsFetchFNm; TStr WebBsFetchUrlFNm; TStr WebHostBsFNm;
766      GetFNms(Nm, FPath, WebBsFetchFNm, WebBsFetchUrlFNm, WebHostBsFNm);
767      TFile::Del(WebBsFetchFNm);
768      TFile::Del(WebBsFetchUrlFNm);
769      TFile::Del(WebHostBsFNm);
770    }
771  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-amazon.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webbsfetch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>147    }
148  }
149  PGraph TAmazonItemBs::GetGraph() const {
150    PGraph Graph=TGGraph::New();
151    for (int ItemIdN=0; ItemIdN<GetItems(); ItemIdN++){
152      PAmazonItem Item=GetItem(ItemIdN);
153      TStr VrtxNm=Item->GetStr();
</pre></code></div>
                <div class="column column_space"><pre><code>456    }
457  }
458  PWebHostNmBs TWebHostNmBs::LoadTxt(const PSIn& SIn){
459    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloCsSens);
460    TStrPrV HostNmPrV;
461    Lx.GetVarStrPrV("HostNmPrV", HostNmPrV);
462    PWebHostNmBs WebHostNmBs=PWebHostNmBs(new TWebHostNmBs());
463    for (int HostNmPrN=0; HostNmPrN<HostNmPrV.Len(); HostNmPrN++){
464      TStr AliasNm=HostNmPrV[HostNmPrN].Val1;
465      TStr FinalNm=HostNmPrV[HostNmPrN].Val2;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    