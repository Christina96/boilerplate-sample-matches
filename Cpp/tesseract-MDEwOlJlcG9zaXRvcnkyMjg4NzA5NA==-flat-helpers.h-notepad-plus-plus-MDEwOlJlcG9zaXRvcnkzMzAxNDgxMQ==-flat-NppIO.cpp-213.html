
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-helpers.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCUTIL_HELPERS_H_
2  #define TESSERACT_CCUTIL_HELPERS_H_
3  #include &lt;cassert&gt;
4  #include &lt;climits&gt; 
5  #include &lt;cmath&gt; 
6  #include &lt;cstdio&gt;
7  #include &lt;cstring&gt;
8  #include &lt;algorithm&gt;  
9  #include &lt;functional&gt;
10  #include &lt;random&gt;
11  #include &lt;string&gt;
12  #include &lt;vector&gt;
13  #include &quot;serialis.h&quot;
14  namespace tesseract {
15  template &lt;class T&gt;
16  inline bool contains(const std::vector&lt;T&gt; &amp;data, const T &amp;value) {
17    return std::find(data.begin(), data.end(), value) != data.end();
18  }
19  inline const std::vector&lt;std::string&gt; split(const std::string &amp;s, char c) {
20    std::string buff;
21    std::vector&lt;std::string&gt; v;
22    for (auto n : s) {
23      if (n != c) {
24        buff += n;
25      } else if (n == c &amp;&amp; !buff.empty()) {
26        v.push_back(buff);
27        buff.clear();
28      }
29    }
30    if (!buff.empty()) {
31      v.push_back(buff);
32    }
33    return v;
34  }
35  class TRand {
36  public:
37    void set_seed(uint64_t seed) {
38      e.seed(seed);
39    }
40    void set_seed(const std::string &amp;str) {
41      std::hash&lt;std::string&gt; hasher;
42      set_seed(static_cast&lt;uint64_t&gt;(hasher(str)));
43    }
44    int32_t IntRand() {
45      return e();
46    }
47    double SignedRand(double range) {
48      return range * 2.0 * IntRand() / INT32_MAX - range;
49    }
50    double UnsignedRand(double range) {
51      return range * IntRand() / INT32_MAX;
52    }
53  private:
54    std::minstd_rand e;
55  };
56  inline void chomp_string(char *str) {
57    int last_index = static_cast&lt;int&gt;(strlen(str)) - 1;
58    while (last_index &gt;= 0 &amp;&amp; (str[last_index] == &#x27;\n&#x27; || str[last_index] == &#x27;\r&#x27;)) {
59      str[last_index--] = &#x27;\0&#x27;;
60    }
61  }
62  inline int RoundUp(int n, int block_size) {
63    return block_size * ((n + block_size - 1) / block_size);
64  }
65  template &lt;typename T&gt;
66  inline T ClipToRange(const T &amp;x, const T &amp;lower_bound, const T &amp;upper_bound) {
67    if (x &lt; lower_bound) {
<span onclick='openModal()' class='match'>68      return lower_bound;
69    }
70    if (x &gt; upper_bound) {
71      return upper_bound;
72    }
73    return x;
</span>74  }
75  template &lt;typename T1, typename T2&gt;
76  inline void UpdateRange(const T1 &amp;x, T2 *lower_bound, T2 *upper_bound) {
77    if (x &lt; *lower_bound) {
78      *lower_bound = x;
79    }
80    if (x &gt; *upper_bound) {
81      *upper_bound = x;
82    }
83  }
84  template &lt;typename T1, typename T2&gt;
85  inline void UpdateRange(const T1 &amp;x_lo, const T1 &amp;x_hi, T2 *lower_bound, T2 *upper_bound) {
86    if (x_lo &lt; *lower_bound) {
87      *lower_bound = x_lo;
88    }
89    if (x_hi &gt; *upper_bound) {
90      *upper_bound = x_hi;
91    }
92  }
93  template &lt;typename T&gt;
94  inline void IntersectRange(const T &amp;lower1, const T &amp;upper1, T *lower2, T *upper2) {
95    if (lower1 &gt; *lower2) {
96      *lower2 = lower1;
97    }
98    if (upper1 &lt; *upper2) {
99      *upper2 = upper1;
100    }
101  }
102  inline int Modulo(int a, int b) {
103    return (a % b + b) % b;
104  }
105  inline int DivRounded(int a, int b) {
106    if (b &lt; 0) {
107      return -DivRounded(a, -b);
108    }
109    return a &gt;= 0 ? (a + b / 2) / b : (a - b / 2) / b;
110  }
111  inline int IntCastRounded(double x) {
112    assert(std::isfinite(x));
113    assert(x &lt; INT_MAX);
114    assert(x &gt; INT_MIN);
115    return x &gt;= 0.0 ? static_cast&lt;int&gt;(x + 0.5) : -static_cast&lt;int&gt;(-x + 0.5);
116  }
117  inline int IntCastRounded(float x) {
118    assert(std::isfinite(x));
119    return x &gt;= 0.0F ? static_cast&lt;int&gt;(x + 0.5F) : -static_cast&lt;int&gt;(-x + 0.5F);
120  }
121  inline void ReverseN(void *ptr, int num_bytes) {
122    assert(num_bytes == 1 || num_bytes == 2 || num_bytes == 4 || num_bytes == 8);
123    char *cptr = static_cast&lt;char *&gt;(ptr);
124    int halfsize = num_bytes / 2;
125    for (int i = 0; i &lt; halfsize; ++i) {
126      char tmp = cptr[i];
127      cptr[i] = cptr[num_bytes - 1 - i];
128      cptr[num_bytes - 1 - i] = tmp;
129    }
130  }
131  inline void Reverse32(void *ptr) {
132    ReverseN(ptr, 4);
133  }
134  template &lt;typename T&gt;
135  bool DeSerialize(bool swap, FILE *fp, std::vector&lt;T&gt; &amp;data) {
136    uint32_t size;
137    if (fread(&amp;size, sizeof(size), 1, fp) != 1) {
138      return false;
139    }
140    if (swap) {
141      Reverse32(&amp;size);
142    }
143    assert(size &lt;= UINT16_MAX);
144    if (size &gt; UINT16_MAX) {
145      return false;
146    }
147    data.resize(size);
148    if (size &gt; 0) {
149      if (fread(&amp;data[0], sizeof(T), size, fp) != size) {
150        return false;
151      }
152      if (swap) {
153        for (uint32_t i = 0; i &lt; size; ++i) {
154          ReverseN(&amp;data[i], sizeof(T));
155        }
156      }
157    }
158    return true;
159  }
160  template &lt;typename T&gt;
161  bool Serialize(FILE *fp, const std::vector&lt;T&gt; &amp;data) {
162    uint32_t size = data.size();
163    if (fwrite(&amp;size, sizeof(size), 1, fp) != 1) {
164      return false;
165    } else if constexpr (std::is_class&lt;T&gt;::value) {
166      for (auto &amp;item : data) {
167        if (!item.Serialize(fp)) {
168          return false;
169        }
170      }
171    } else if constexpr (std::is_pointer&lt;T&gt;::value) {
172      for (auto &amp;item : data) {
173        uint8_t non_null = (item != nullptr);
174        if (!Serialize(fp, &amp;non_null)) {
175          return false;
176        }
177        if (non_null) {
178          if (!item-&gt;Serialize(fp)) {
179            return false;
180          }
181        }
182      }
183    } else if (size &gt; 0) {
184      if (fwrite(&amp;data[0], sizeof(T), size, fp) != size) {
185        return false;
186      }
187    }
188    return true;
189  }
190  } 
191  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppIO.cpp</h3>
            <pre><code>1  #include &lt;time.h&gt;
2  #include &lt;shlwapi.h&gt;
3  #include &lt;shlobj.h&gt;
4  #include &quot;Notepad_plus_Window.h&quot;
5  #include &quot;CustomFileDialog.h&quot;
6  #include &quot;EncodingMapper.h&quot;
7  #include &quot;VerticalFileSwitcher.h&quot;
8  #include &quot;functionListPanel.h&quot;
9  #include &quot;ReadDirectoryChanges.h&quot;
10  #include &quot;ReadFileChanges.h&quot;
11  #include &quot;fileBrowser.h&quot;
12  #include &lt;tchar.h&gt;
13  #include &lt;unordered_set&gt;
14  #include &quot;Common.h&quot;
15  using namespace std;
16  DWORD WINAPI Notepad_plus::monitorFileOnChange(void * params)
17  {
18  	MonitorInfo *monitorInfo = static_cast&lt;MonitorInfo *&gt;(params);
19  	Buffer *buf = monitorInfo-&gt;_buffer;
20  	HWND h = monitorInfo-&gt;_nppHandle;
21  	const TCHAR *fullFileName = (const TCHAR *)buf-&gt;getFullPathName();
22  	WCHAR folderToMonitor[MAX_PATH];
23  	wcscpy_s(folderToMonitor, fullFileName);
24  	::PathRemoveFileSpecW(folderToMonitor);
25  	const DWORD dwNotificationFlags = FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_SIZE;
26  	CReadDirectoryChanges dirChanges;
27  	dirChanges.AddDirectory(folderToMonitor, true, dwNotificationFlags);
28  	CReadFileChanges fileChanges;
29  	fileChanges.AddFile(fullFileName, FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_SIZE);
30  	HANDLE changeHandles[] = { buf-&gt;getMonitoringEvent(), dirChanges.GetWaitHandle() };
31  	bool toBeContinued = true;
32  	while (toBeContinued)
33  	{
34  		DWORD waitStatus = ::WaitForMultipleObjects(_countof(changeHandles), changeHandles, FALSE, 250);
35  		switch (waitStatus)
36  		{
37  			case WAIT_OBJECT_0 + 0:
38  			{
39  				toBeContinued = false;
40  			}
41  			break;
42  			case WAIT_OBJECT_0 + 1:
43  			{
44  				DWORD dwAction;
45  				generic_string fn;
46  				while (dirChanges.Pop(dwAction, fn))
47  				{
48  					size_t pos = fn.find(TEXT(&quot;\\\\&quot;));
49  					if (pos == 2)
50  						fn.replace(pos, 2, TEXT(&quot;\\&quot;));
51  					if (OrdinalIgnoreCaseCompareStrings(fullFileName, fn.c_str()) == 0)
52  					{
53  						if (dwAction == FILE_ACTION_MODIFIED)
54  						{
55  							::PostMessage(h, NPPM_INTERNAL_RELOADSCROLLTOEND, reinterpret_cast&lt;WPARAM&gt;(buf), 0);
56  						}
57  						else if ((dwAction == FILE_ACTION_REMOVED) || (dwAction == FILE_ACTION_RENAMED_OLD_NAME))
58  						{
59  							::PostMessage(h, NPPM_INTERNAL_STOPMONITORING, reinterpret_cast&lt;WPARAM&gt;(buf), 0);
60  						}
61  					}
62  				}
63  			}
64  			break;
65  			case WAIT_TIMEOUT:
66  			{
67  				if (fileChanges.DetectChanges())
68  					::PostMessage(h, NPPM_INTERNAL_RELOADSCROLLTOEND, reinterpret_cast&lt;WPARAM&gt;(buf), 0);
69  			}
70  			break;
71  			case WAIT_IO_COMPLETION:
72  			break;
73  		}
74  	}
75  	dirChanges.Terminate();
76  	fileChanges.Terminate();
77  	delete monitorInfo;
78  	return EXIT_SUCCESS;
79  }
80  bool resolveLinkFile(generic_string&amp; linkFilePath)
81  {
82  	bool isResolved = false;
83  	IShellLink* psl;
84  	WCHAR targetFilePath[MAX_PATH];
85  	WIN32_FIND_DATA wfd = {};
86  	HRESULT hres = CoInitialize(NULL);
87  	if (SUCCEEDED(hres))
88  	{
89  		hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID*)&amp;psl);
90  		if (SUCCEEDED(hres))
91  		{
92  			IPersistFile* ppf;
93  			hres = psl-&gt;QueryInterface(IID_IPersistFile, (void**)&amp;ppf);
94  			if (SUCCEEDED(hres))
95  			{
96  				hres = ppf-&gt;Load(linkFilePath.c_str(), STGM_READ);
97  				if (SUCCEEDED(hres) &amp;&amp; hres != S_FALSE)
98  				{
99  					hres = psl-&gt;Resolve(NULL, 0);
100  					if (SUCCEEDED(hres) &amp;&amp; hres != S_FALSE)
101  					{
102  						hres = psl-&gt;GetPath(targetFilePath, MAX_PATH, (WIN32_FIND_DATA*)&amp;wfd, SLGP_SHORTPATH);
103  						if (SUCCEEDED(hres) &amp;&amp; hres != S_FALSE)
104  						{
105  							linkFilePath = targetFilePath;
106  							isResolved = true;
107  						}
108  					}
109  				}
110  				ppf-&gt;Release();
111  			}
112  			psl-&gt;Release();
113  		}
114  		CoUninitialize();
115  	}
116  	return isResolved;
117  }
118  BufferID Notepad_plus::doOpen(const generic_string&amp; fileName, bool isRecursive, bool isReadOnly, int encoding, const TCHAR *backupFileName, FILETIME fileNameTimestamp)
119  {
120  	const rsize_t longFileNameBufferSize = MAX_PATH; 
121  	if (fileName.size() &gt;= longFileNameBufferSize - 1) 
122  		return BUFFER_INVALID;
123  	generic_string targetFileName = fileName;
124  	bool isResolvedLinkFileName = resolveLinkFile(targetFileName);
125  	bool isRawFileName;
126  	if (isResolvedLinkFileName)
127  		isRawFileName = false;
128  	else
129  		isRawFileName = isWin32NamespacePrefixedFileName(fileName);
130  	if (isUnsupportedFileName(isResolvedLinkFileName ? targetFileName : fileName))
131  	{
132  			_nativeLangSpeaker.messageBox(&quot;OpenFileError&quot;,
133  				_pPublicInterface-&gt;getHSelf(),
134  				TEXT(&quot;Cannot open file \&quot;$STR_REPLACE$\&quot;.&quot;),
135  				TEXT(&quot;ERROR&quot;),
136  				MB_OK,
137  				0,
138  				isResolvedLinkFileName ? targetFileName.c_str() : fileName.c_str());
139  			return BUFFER_INVALID;
140  	}
141  	NppParameters&amp; nppParam = NppParameters::getInstance();
142  	WCHAR longFileName[longFileNameBufferSize] = { 0 };
143  	if (isRawFileName)
144  	{
145  		wcsncpy_s(longFileName, _countof(longFileName), fileName.c_str(), _TRUNCATE);
146  	}
147  	else
148  	{
149  		const DWORD getFullPathNameResult = ::GetFullPathName(targetFileName.c_str(), longFileNameBufferSize, longFileName, NULL);
150  		if (getFullPathNameResult == 0)
151  		{
<span onclick='openModal()' class='match'>152  			return BUFFER_INVALID;
153  		}
154  		if (getFullPathNameResult &gt; longFileNameBufferSize)
155  		{
156  			return BUFFER_INVALID;
157  		}
158  		assert(wcslen(longFileName) == getFullPathNameResult);
</span>159  		if (wcschr(longFileName, &#x27;~&#x27;))
160  		{
161  			::GetLongPathName(longFileName, longFileName, longFileNameBufferSize);
162  		}
163  	}
164  	bool isSnapshotMode = backupFileName != NULL &amp;&amp; PathFileExists(backupFileName);
165  	if (isSnapshotMode &amp;&amp; !PathFileExists(longFileName)) 
166  	{
167  		wcscpy_s(longFileName, targetFileName.c_str());
168  	}
169      _lastRecentFileList.remove(longFileName);
170  	generic_string fileName2Find;
171  	generic_string gs_fileName{ targetFileName };
172  	BufferID foundBufID = MainFileManager.getBufferFromName(targetFileName.c_str());
173  	if (foundBufID == BUFFER_INVALID)
174  		fileName2Find = longFileName;
175  	if (foundBufID == BUFFER_INVALID)
176  		foundBufID = MainFileManager.getBufferFromName(fileName2Find.c_str());
177      if (foundBufID != BUFFER_INVALID &amp;&amp; !isSnapshotMode)
178      {
179          if (_pTrayIco)
180          {
181              if (_pTrayIco-&gt;isInTray())
182              {
183                  ::ShowWindow(_pPublicInterface-&gt;getHSelf(), SW_SHOW);
184                  if (!_pPublicInterface-&gt;isPrelaunch())
185                      _pTrayIco-&gt;doTrayIcon(REMOVE);
186                  ::SendMessage(_pPublicInterface-&gt;getHSelf(), WM_SIZE, 0, 0);
187              }
188          }
189          return foundBufID;
190      }
191      if (isFileSession(longFileName) &amp;&amp; PathFileExists(longFileName))
192      {
193          fileLoadSession(longFileName);
194          return BUFFER_INVALID;
195      }
196  	if (isFileWorkspace(longFileName) &amp;&amp; PathFileExists(longFileName))
197  	{
198  		nppParam.setWorkSpaceFilePath(0, longFileName);
199  		launchProjectPanel(IDM_VIEW_PROJECT_PANEL_1, &amp;_pProjectPanel_1, 0);
200  		return BUFFER_INVALID;
201  	}
202      bool isWow64Off = false;
203      if (!PathFileExists(longFileName))
204      {
205          nppParam.safeWow64EnableWow64FsRedirection(FALSE);
206          isWow64Off = true;
207      }
208  	bool globbing;
209  	if (isRawFileName)
210  		globbing = (wcsrchr(longFileName, TCHAR(&#x27;*&#x27;)) || (abs(longFileName - wcsrchr(longFileName, TCHAR(&#x27;?&#x27;))) &gt; 3));
211  	else
212  		globbing = (wcsrchr(longFileName, TCHAR(&#x27;*&#x27;)) || wcsrchr(longFileName, TCHAR(&#x27;?&#x27;)));
213  	if (!isSnapshotMode) 
214  	{
215  		if (!PathFileExists(longFileName) &amp;&amp; !globbing)
216  		{
217  			generic_string longFileDir(longFileName);
218  			PathRemoveFileSpec(longFileDir);
219  			bool isCreateFileSuccessful = false;
220  			if (PathFileExists(longFileDir.c_str()))
221  			{
222  				int res = _nativeLangSpeaker.messageBox(&quot;CreateNewFileOrNot&quot;,
223  					_pPublicInterface-&gt;getHSelf(),
224  					TEXT(&quot;\&quot;$STR_REPLACE$\&quot; doesn&#x27;t exist. Create it?&quot;),
225  					TEXT(&quot;Create new file&quot;),
226  					MB_YESNO,
227  					0,
228  					longFileName);
229  				if (res == IDYES)
230  				{
231  					bool isOK = MainFileManager.createEmptyFile(longFileName);
232  					if (isOK)
233  					{
234  						isCreateFileSuccessful = true;
235  					}
236  					else
237  					{
238  						_nativeLangSpeaker.messageBox(&quot;CreateNewFileError&quot;,
239  							_pPublicInterface-&gt;getHSelf(),
240  							TEXT(&quot;Cannot create the file \&quot;$STR_REPLACE$\&quot;.&quot;),
241  							TEXT(&quot;Create new file&quot;),
242  							MB_OK,
243  							0,
244  							longFileName);
245  					}
246  				}
247  			}
248  			else
249  			{
250  				generic_string msg, title;
251  				if (!_nativeLangSpeaker.getMsgBoxLang(&quot;OpenFileNoFolderError&quot;, title, msg))
252  				{
253  					title = TEXT(&quot;Cannot open file&quot;);
254  					msg = TEXT(&quot;\&quot;&quot;);
255  					msg += longFileName;
256  					msg += TEXT(&quot;\&quot; cannot be opened:\nFolder \&quot;&quot;);
257  					msg += longFileDir;
258  					msg += TEXT(&quot;\&quot; doesn&#x27;t exist.&quot;);
259  				}
260  				else
261  				{
262  					msg = stringReplace(msg, TEXT(&quot;$STR_REPLACE1$&quot;), longFileName);
263  					msg = stringReplace(msg, TEXT(&quot;$STR_REPLACE2$&quot;), longFileDir);
264  				}
265  				::MessageBox(_pPublicInterface-&gt;getHSelf(), msg.c_str(), title.c_str(), MB_OK);
266  			}
267  			if (!isCreateFileSuccessful)
268  			{
269  				if (isWow64Off)
270  				{
271  					nppParam.safeWow64EnableWow64FsRedirection(TRUE);
272  					isWow64Off = false;
273  				}
274  				return BUFFER_INVALID;
275  			}
276  		}
277  	}
278  	SCNotification scnN{};
279      scnN.nmhdr.code = NPPN_FILEBEFORELOAD;
280      scnN.nmhdr.hwndFrom = _pPublicInterface-&gt;getHSelf();
281      scnN.nmhdr.idFrom = 0;
282      _pluginsManager.notify(&amp;scnN);
283      if (encoding == -1)
284      {
285  		encoding = getHtmlXmlEncoding(longFileName);
286      }
287  	BufferID buffer;
288  	if (isSnapshotMode)
289  	{
290  		buffer = MainFileManager.loadFile(longFileName, static_cast&lt;Document&gt;(NULL), encoding, backupFileName, fileNameTimestamp);
291  		if (buffer != BUFFER_INVALID)
292  		{
293  			isSnapshotMode = (backupFileName != NULL &amp;&amp; ::PathFileExists(backupFileName));
294  			if (isSnapshotMode)
295  			{
296  				SCNotification scnN2{};
297  				scnN2.nmhdr.hwndFrom = 0;
298  				scnN2.nmhdr.idFrom = (uptr_t)buffer;
299  				scnN2.nmhdr.code = NPPN_SNAPSHOTDIRTYFILELOADED;
300  				_pluginsManager.notify(&amp;scnN2);
301  				buffer-&gt;setLoadedDirty(true);
302  			}
303  		}
304  	}
305  	else
306  	{
307  		buffer = MainFileManager.loadFile(longFileName, static_cast&lt;Document&gt;(NULL), encoding);
308  	}
309      if (buffer != BUFFER_INVALID)
310      {
311          _isFileOpening = true;
312          Buffer * buf = MainFileManager.getBufferByID(buffer);
313          if (isReadOnly)
314              buf-&gt;setUserReadOnly(true);
315          scnN.nmhdr.code = NPPN_FILEBEFOREOPEN;
316          scnN.nmhdr.idFrom = (uptr_t)buffer;
317          _pluginsManager.notify(&amp;scnN);
318          loadBufferIntoView(buffer, currentView());
319          if (_pTrayIco)
320          {
321              if (_pTrayIco-&gt;isInTray())
322              {
323                  ::ShowWindow(_pPublicInterface-&gt;getHSelf(), SW_SHOW);
324                  if (!_pPublicInterface-&gt;isPrelaunch())
325                      _pTrayIco-&gt;doTrayIcon(REMOVE);
326                  ::SendMessage(_pPublicInterface-&gt;getHSelf(), WM_SIZE, 0, 0);
327              }
328          }
329          PathRemoveFileSpec(longFileName);
330          _linkTriggered = true;
331          _isFileOpening = false;
332          scnN.nmhdr.code = NPPN_FILEOPENED;
333          _pluginsManager.notify(&amp;scnN);
334          if (_pDocumentListPanel)
335              _pDocumentListPanel-&gt;newItem(buf, currentView());
336      }
337      else
338      {
339          if (globbing || ::PathIsDirectory(targetFileName.c_str()))
340          {
341              vector&lt;generic_string&gt; fileNames;
342              vector&lt;generic_string&gt; patterns;
343              if (globbing)
344              {
345                  const TCHAR * substring = wcsrchr(targetFileName.c_str(), TCHAR(&#x27;\\&#x27;));
346  				if (substring)
347  				{
348  					size_t pos = substring - targetFileName.c_str();
349  					patterns.push_back(substring + 1);
350  					generic_string dir(targetFileName.c_str(), pos + 1); 
351  					getMatchedFileNames(dir.c_str(), 0, patterns, fileNames, isRecursive, false);
352  				}
353              }
354              else
355              {
356                  generic_string fileNameStr = targetFileName;
357                  if (targetFileName[targetFileName.size() - 1] != &#x27;\\&#x27;)
358                      fileNameStr += TEXT(&quot;\\&quot;);
359                  patterns.push_back(TEXT(&quot;*&quot;));
360                  getMatchedFileNames(fileNameStr.c_str(), 0, patterns, fileNames, true, false);
361              }
362              bool ok2Open = true;
363              size_t nbFiles2Open = fileNames.size();
364              if (nbFiles2Open &gt; 200)
365              {
366                  ok2Open = IDYES == _nativeLangSpeaker.messageBox(&quot;NbFileToOpenImportantWarning&quot;,
367  					_pPublicInterface-&gt;getHSelf(),
368                      TEXT(&quot;$INT_REPLACE$ files are about to be opened.\rAre you sure to open them?&quot;),
369                      TEXT(&quot;Amount of files to open is too large&quot;),
370                      MB_YESNO|MB_APPLMODAL,
371  					static_cast&lt;int32_t&gt;(nbFiles2Open));
372              }
373              if (ok2Open)
374              {
375                  for (size_t i = 0 ; i &lt; nbFiles2Open ; ++i)
376                      doOpen(fileNames[i]);
377              }
378          }
379          else
380          {
381  			_nativeLangSpeaker.messageBox(&quot;OpenFileError&quot;,
382  				_pPublicInterface-&gt;getHSelf(),
383  				TEXT(&quot;Can not open file \&quot;$STR_REPLACE$\&quot;.&quot;),
384  				TEXT(&quot;ERROR&quot;),
385  				MB_OK,
386  				0,
387  				longFileName);
388              _isFileOpening = false;
389              scnN.nmhdr.code = NPPN_FILELOADFAILED;
390              _pluginsManager.notify(&amp;scnN);
391          }
392      }
393      if (isWow64Off)
394      {
395          nppParam.safeWow64EnableWow64FsRedirection(TRUE);
396      }
397      return buffer;
398  }
399  bool Notepad_plus::doReload(BufferID id, bool alert)
400  {
401  	if (alert)
402  	{
403  		int answer = _nativeLangSpeaker.messageBox(&quot;DocReloadWarning&quot;,
404  			_pPublicInterface-&gt;getHSelf(),
405  			TEXT(&quot;Are you sure you want to reload the current file and lose the changes made in Notepad++?&quot;),
406  			TEXT(&quot;Reload&quot;),
407  			MB_YESNO | MB_ICONEXCLAMATION | MB_APPLMODAL);
408  		if (answer != IDYES)
409  			return false;
410  	}
411  	bool mainVisisble = (_mainEditView.getCurrentBufferID() == id);
412  	bool subVisisble = (_subEditView.getCurrentBufferID() == id);
413  	if (mainVisisble)
414  	{
415  		_mainEditView.saveCurrentPos();
416  		_mainEditView.execute(SCI_SETDOCPOINTER, 0, 0);
417  	}
418  	if (subVisisble)
419  	{
420  		_subEditView.saveCurrentPos();
421  		_subEditView.execute(SCI_SETDOCPOINTER, 0, 0);
422  	}
423  	if (!mainVisisble &amp;&amp; !subVisisble)
424  	{
425  		return MainFileManager.reloadBufferDeferred(id);
426  	}
427  	bool res = MainFileManager.reloadBuffer(id);
428  	Buffer * pBuf = MainFileManager.getBufferByID(id);
429  	if (mainVisisble)
430  	{
431  		_mainEditView.execute(SCI_SETDOCPOINTER, 0, pBuf-&gt;getDocument());
432  		_mainEditView.restoreCurrentPosPreStep();
433  	}
434  	if (subVisisble)
435  	{
436  		_subEditView.execute(SCI_SETDOCPOINTER, 0, pBuf-&gt;getDocument());
437  		_subEditView.restoreCurrentPosPreStep();
438  	}
439  	activateBuffer(id, currentView(), true);
440  	return res;
441  }
442  bool Notepad_plus::doSave(BufferID id, const TCHAR * filename, bool isCopy)
443  {
444  	const int index = MainFileManager.getBufferIndexByID(id);
445  	if (index == -1)
446  	{
447  		_nativeLangSpeaker.messageBox(&quot;BufferInvalidWarning&quot;,
448  			_pPublicInterface-&gt;getHSelf(),
449  			TEXT(&quot;Cannot save: Buffer is invalid.&quot;),
450  			TEXT(&quot;Save failed&quot;),
451  			MB_OK | MB_ICONWARNING);
452  		return false;
453  	}
454  	SCNotification scnN{};
455  	if (!isCopy)
456  	{
457  		scnN.nmhdr.code = NPPN_FILEBEFORESAVE;
458  		scnN.nmhdr.hwndFrom = _pPublicInterface-&gt;getHSelf();
459  		scnN.nmhdr.idFrom = (uptr_t)id;
460  		_pluginsManager.notify(&amp;scnN);
461  	}
462  	SavingStatus res = MainFileManager.saveBuffer(id, filename, isCopy);
463  	if (!isCopy)
464  	{
465  		scnN.nmhdr.code = NPPN_FILESAVED;
466  		_pluginsManager.notify(&amp;scnN);
467  	}
468  	if (res == SavingStatus::SaveWritingFailed)
469  	{
470  		_nativeLangSpeaker.messageBox(&quot;NotEnoughRoom4Saving&quot;,
471  			_pPublicInterface-&gt;getHSelf(),
472  			TEXT(&quot;Failed to save file.\nIt seems there&#x27;s not enough space on disk to save file.&quot;),
473  			TEXT(&quot;Save failed&quot;),
474  			MB_OK);
475  	}
476  	else if (res == SavingStatus::SaveOpenFailed)
477  	{
478  		if (_isAdministrator)
479  		{
480  			_nativeLangSpeaker.messageBox(&quot;FileLockedWarning&quot;,
481  				_pPublicInterface-&gt;getHSelf(),
482  				TEXT(&quot;Please check whether if this file is opened in another program&quot;),
483  				TEXT(&quot;Save failed&quot;),
484  				MB_OK | MB_ICONWARNING);
485  		}
486  		else
487  		{
488  			bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
489  			if (isSnapshotMode) 
490  			{                   
491  				int openInAdminModeRes = _nativeLangSpeaker.messageBox(&quot;OpenInAdminMode&quot;,
492  				_pPublicInterface-&gt;getHSelf(),
493  				TEXT(&quot;This file cannot be saved and it may be protected.\rDo you want to launch Notepad++ in Administrator mode?&quot;),
494  				TEXT(&quot;Save failed&quot;),
495  				MB_YESNO);
496  				if (openInAdminModeRes == IDYES)
497  				{
498  					TCHAR nppFullPath[MAX_PATH];
499  					::GetModuleFileName(NULL, nppFullPath, MAX_PATH);
500  					generic_string args = TEXT(&quot;-multiInst&quot;);
501  					size_t shellExecRes = (size_t)::ShellExecute(_pPublicInterface-&gt;getHSelf(), TEXT(&quot;runas&quot;), nppFullPath, args.c_str(), TEXT(&quot;.&quot;), SW_SHOW);
502  					if (shellExecRes &lt;= 32)
503  					{
504  						_nativeLangSpeaker.messageBox(&quot;OpenInAdminModeFailed&quot;,
505  							_pPublicInterface-&gt;getHSelf(),
506  							TEXT(&quot;Notepad++ cannot be opened in Administrator mode.&quot;),
507  							TEXT(&quot;Open in Administrator mode failed&quot;),
508  							MB_OK);
509  					}
510  					else
511  					{
512  						::SendMessage(_pPublicInterface-&gt;getHSelf(), WM_CLOSE, 0, 0);
513  					}
514  				}
515  			}
516  			else 
517  			{    
518  				int openInAdminModeRes = _nativeLangSpeaker.messageBox(&quot;OpenInAdminModeWithoutCloseCurrent&quot;,
519  				_pPublicInterface-&gt;getHSelf(),
520  				TEXT(&quot;The file cannot be saved and it may be protected.\rDo you want to launch Notepad++ in Administrator mode?&quot;),
521  				TEXT(&quot;Save failed&quot;),
522  				MB_YESNO);
523  				if (openInAdminModeRes == IDYES)
524  				{
525  					TCHAR nppFullPath[MAX_PATH];
526  					::GetModuleFileName(NULL, nppFullPath, MAX_PATH);
527  					BufferID bufferID = _pEditView-&gt;getCurrentBufferID();
528  					Buffer * buf = MainFileManager.getBufferByID(bufferID);
529  					generic_string fileNamePath = buf-&gt;getFullPathName();
530  					generic_string args = TEXT(&quot;-multiInst -nosession &quot;);
531  					args += TEXT(&quot;\&quot;&quot;);
532  					args += fileNamePath;
533  					args += TEXT(&quot;\&quot;&quot;);
534  					size_t shellExecRes = (size_t)::ShellExecute(_pPublicInterface-&gt;getHSelf(), TEXT(&quot;runas&quot;), nppFullPath, args.c_str(), TEXT(&quot;.&quot;), SW_SHOW);
535  					if (shellExecRes &lt;= 32)
536  					{
537  						_nativeLangSpeaker.messageBox(&quot;OpenInAdminModeFailed&quot;,
538  							_pPublicInterface-&gt;getHSelf(),
539  							TEXT(&quot;Notepad++ cannot be opened in Administrator mode.&quot;),
540  							TEXT(&quot;Open in Administrator mode failed&quot;),
541  							MB_OK);
542  					}
543  				}
544  			}
545  		}
546  	}
547  	if (res == SavingStatus::SaveOK &amp;&amp; _pFuncList &amp;&amp; (!_pFuncList-&gt;isClosed()) &amp;&amp; _pFuncList-&gt;isVisible())
548  	{
549  		_pFuncList-&gt;reload();
550  	}
551  	return res == SavingStatus::SaveOK;
552  }
553  void Notepad_plus::doClose(BufferID id, int whichOne, bool doDeleteBackup)
554  {
555  	DocTabView *tabToClose = (whichOne == MAIN_VIEW)?&amp;_mainDocTab:&amp;_subDocTab;
556  	int i = tabToClose-&gt;getIndexByBuffer(id);
557  	if (i == -1)
558  		return;
559  	size_t numInitialOpenBuffers =
560  		((_mainWindowStatus &amp; WindowMainActive) == WindowMainActive ? _mainDocTab.nbItem() : 0) +
561  		((_mainWindowStatus &amp; WindowSubActive) == WindowSubActive ? _subDocTab.nbItem() : 0);
562  	if (doDeleteBackup)
563  		MainFileManager.deleteBufferBackup(id);
564  	Buffer * buf = MainFileManager.getBufferByID(id);
565  	SCNotification scnN{};
566  	scnN.nmhdr.code = NPPN_FILEBEFORECLOSE;
567  	scnN.nmhdr.hwndFrom = _pPublicInterface-&gt;getHSelf();
568  	scnN.nmhdr.idFrom = (uptr_t)id;
569  	_pluginsManager.notify(&amp;scnN);
570  	generic_string fileFullPath;
571  	if (!buf-&gt;isUntitled())
572  	{
573  		bool isWow64Off = false;
574  		NppParameters&amp; nppParam = NppParameters::getInstance();
575  		const TCHAR *fn = buf-&gt;getFullPathName();
576  		if (!PathFileExists(fn))
577  		{
578  			nppParam.safeWow64EnableWow64FsRedirection(FALSE);
579  			isWow64Off = true;
580  		}
581  		if (PathFileExists(buf-&gt;getFullPathName()))
582  			fileFullPath = buf-&gt;getFullPathName();
583  		if (isWow64Off)
584  		{
585  			nppParam.safeWow64EnableWow64FsRedirection(TRUE);
586  		}
587  	}
588  	size_t nbDocs = whichOne==MAIN_VIEW?(_mainDocTab.nbItem()):(_subDocTab.nbItem());
589  	if (buf-&gt;isMonitoringOn())
590  	{
591  		monitoringStartOrStopAndUpdateUI(buf, false);
592  	}
593  	bool isBufRemoved = removeBufferFromView(id, whichOne);
594  	BufferID hiddenBufferID = BUFFER_INVALID;
595  	if (nbDocs == 1 &amp;&amp; canHideView(whichOne))
596  	{	
597  		hideView(whichOne);
598  		hiddenBufferID = reinterpret_cast&lt;BufferID&gt;(::SendMessage(_pPublicInterface-&gt;getHSelf(), NPPM_GETBUFFERIDFROMPOS, 0, whichOne));
599  		if (!isBufRemoved &amp;&amp; hiddenBufferID != BUFFER_INVALID &amp;&amp; _pDocumentListPanel)
600  			_pDocumentListPanel-&gt;closeItem(hiddenBufferID, whichOne);
601  	}
602  	checkSyncState();
603  	if (isBufRemoved)
604  	{
605  		scnN.nmhdr.code = NPPN_FILECLOSED;
606  		_pluginsManager.notify(&amp;scnN);
607  		if (_pDocumentListPanel)
608  		{
609  			_pDocumentListPanel-&gt;closeItem(id, whichOne);
610  			if (hiddenBufferID != BUFFER_INVALID)
611  				_pDocumentListPanel-&gt;closeItem(hiddenBufferID, whichOne);
612  		}
613  		BufferID buffID = MainFileManager.getBufferFromName(fileFullPath.c_str());
614  		if (buffID == BUFFER_INVALID &amp;&amp; fileFullPath.length() &gt; 0)
615  			_lastRecentFileList.add(fileFullPath.c_str());
616  	}
617  	command(IDM_VIEW_REFRESHTABAR);
618  	if (NppParameters::getInstance().getNppGUI()._tabStatus &amp; TAB_QUITONEMPTY)
619  	{
620  		if (numInitialOpenBuffers == 1 &amp;&amp; isEmpty() &amp;&amp; !_isAttemptingCloseOnQuit)
621  		{
622  			command(IDM_FILE_EXIT);
623  		}
624  	}
625  	return;
626  }
627  generic_string Notepad_plus::exts2Filters(const generic_string&amp; exts, int maxExtsLen) const
628  {
629  	const TCHAR *extStr = exts.c_str();
630  	TCHAR aExt[MAX_PATH] = { &#x27;\0&#x27; };
631  	generic_string filters(TEXT(&quot;&quot;));
632  	int j = 0;
633  	bool stop = false;
634  	for (size_t i = 0, len = exts.length(); i &lt; len &amp;&amp; j &lt; MAX_PATH - 1; ++i)
635  	{
636  		if (extStr[i] == &#x27; &#x27;)
637  		{
638  			if (!stop)
639  			{
640  				aExt[j] = &#x27;\0&#x27;;
641  				stop = true;
642  				if (aExt[0])
643  				{
644  					filters += TEXT(&quot;*.&quot;);
645  					filters += aExt;
646  					filters += TEXT(&quot;;&quot;);
647  				}
648  				j = 0;
649  				if (maxExtsLen != -1 &amp;&amp; i &gt;= static_cast&lt;size_t&gt;(maxExtsLen))
650  				{
651  					filters += TEXT(&quot; ... &quot;);
652  					break;
653  				}
654  			}
655  		}
656  		else
657  		{
658  			aExt[j] = extStr[i];
659  			stop = false;
660  			++j;
661  		}
662  	}
663  	if (j &gt; 0)
664  	{
665  		aExt[j] = &#x27;\0&#x27;;
666  		if (aExt[0])
667  		{
668  			filters += TEXT(&quot;*.&quot;);
669  			filters += aExt;
670  			filters += TEXT(&quot;;&quot;);
671  		}
672  	}
673      filters = filters.substr(0, filters.length()-1);
674  	return filters;
675  }
676  int Notepad_plus::setFileOpenSaveDlgFilters(CustomFileDialog &amp; fDlg, bool showAllExt, int langType)
677  {
678  	NppParameters&amp; nppParam = NppParameters::getInstance();
679  	NppGUI &amp; nppGUI = (NppGUI &amp; )nppParam.getNppGUI();
680  	int i = 0;
681  	Lang *l = NppParameters::getInstance().getLangFromIndex(i++);
682      int ltIndex = 0;
683      bool ltFound = false;
684  	while (l)
685  	{
686  		LangType lid = l-&gt;getLangID();
687  		bool inExcludedList = false;
688  		for (size_t j = 0, len = nppGUI._excludedLangList.size() ; j &lt; len ; ++j)
689  		{
690  			if (lid == nppGUI._excludedLangList[j]._langType)
691  			{
692  				inExcludedList = true;
693  				break;
694  			}
695  		}
696  		if (!inExcludedList)
697  		{
698  			const TCHAR *defList = l-&gt;getDefaultExtList();
699  			const TCHAR *userList = NULL;
700  			LexerStylerArray &amp;lsa = (NppParameters::getInstance()).getLStylerArray();
701  			const TCHAR *lName = l-&gt;getLangName();
702  			LexerStyler *pLS = lsa.getLexerStylerByName(lName);
703  			if (pLS)
704  				userList = pLS-&gt;getLexerUserExt();
705  			generic_string list(TEXT(&quot;&quot;));
706  			if (defList)
707  				list += defList;
708  			if (userList)
709  			{
710  				list += TEXT(&quot; &quot;);
711  				list += userList;
712  			}
713  			generic_string stringFilters = exts2Filters(list, showAllExt ? -1 : 40);
714  			const TCHAR *filters = stringFilters.c_str();
715  			if (filters[0])
716  			{
717  				fDlg.setExtFilter(getLangDesc(lid, false).c_str(), filters);
718                  if (langType != -1 &amp;&amp; !ltFound)
719                  {
720                      ltFound = langType == lid;
721                  }
722                  if (langType != -1 &amp;&amp; !ltFound)
723                  {
724                      ++ltIndex;
725                  }
726  			}
727  		}
728  		l = (NppParameters::getInstance()).getLangFromIndex(i++);
729  	}
730      if (!ltFound)
731          return -1;
732      return ltIndex;
733  }
734  bool Notepad_plus::fileClose(BufferID id, int curView)
735  {
736  	BufferID bufferID = id;
737  	if (id == BUFFER_INVALID)
738  		bufferID = _pEditView-&gt;getCurrentBufferID();
739  	Buffer * buf = MainFileManager.getBufferByID(bufferID);
740  	if (buf-&gt;isUntitled() &amp;&amp; buf-&gt;docLength() == 0)
741  	{
742  	}
743  	else if (buf-&gt;isDirty())
744  	{
745  		const TCHAR* fileNamePath = buf-&gt;getFullPathName();
746  		int res = doSaveOrNot(fileNamePath);
747  		if (res == IDYES)
748  		{
749  			if (!fileSave(id)) 
750  				return false;
751  		}
752  		else if (res == IDCANCEL)
753  		{
754  			return false;	
755  		}
756  		else
757  		{
758  		}
759  	}
760  	int viewToClose = currentView();
761  	if (curView != -1)
762  		viewToClose = curView;
763  	bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
764  	doClose(bufferID, viewToClose, isSnapshotMode);
765  	return true;
766  }
767  bool Notepad_plus::fileCloseAll(bool doDeleteBackup, bool isSnapshotMode)
768  {
769  	bool noSaveToAll = false;
770  	bool saveToAll = false;
771  	std::unordered_set&lt;BufferID&gt; uniqueBuffers;
772  	for (size_t i = 0; i &lt; _mainDocTab.nbItem() &amp;&amp; !noSaveToAll; ++i)
773  	{
774  		BufferID id = _mainDocTab.getBufferByIndex(i);
775  		Buffer * buf = MainFileManager.getBufferByID(id);
776  		uniqueBuffers.insert(id);
777  		if (buf-&gt;isUntitled() &amp;&amp; buf-&gt;docLength() == 0)
778  		{
779  		}
780  		else if (buf-&gt;isDirty())
781  		{
782  			if (isSnapshotMode)
783  			{
784  				if (buf-&gt;getBackupFileName() == TEXT(&quot;&quot;) || !::PathFileExists(buf-&gt;getBackupFileName().c_str())) 
785  				{
786  					activateBuffer(id, MAIN_VIEW);
787  					if (!activateBuffer(id, SUB_VIEW))
788  						switchEditViewTo(MAIN_VIEW);
789  					int res = _nativeLangSpeaker.messageBox(&quot;NoBackupDoSaveFile&quot;,
790  						_pPublicInterface-&gt;getHSelf(),
791  						TEXT(&quot;Your backup file cannot be found (deleted from outside).\rSave it otherwise your data will be lost\rDo you want to save file \&quot;$STR_REPLACE$\&quot; ?&quot;),
792  						TEXT(&quot;Save&quot;),
793  						MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL,
794  						0, 
795  						buf-&gt;getFullPathName());
796  					if (res == IDYES)
797  					{
798  						if (!fileSave(id))
799  							return false;	
800  					}
801  					else if (res == IDCANCEL)
802  					{
803  						return false;
804  					}
805  				}
806  			}
807  			else
808  			{
809  				activateBuffer(id, MAIN_VIEW);
810  				if (!activateBuffer(id, SUB_VIEW))
811  					switchEditViewTo(MAIN_VIEW);
812  				int res = -1;
813  				if (saveToAll)
814  				{
815  					res = IDYES;
816  				}
817  				else
818  				{
819  					size_t nbDirtyFiles = MainFileManager.getNbDirtyBuffers();
820  					res = doSaveOrNot(buf-&gt;getFullPathName(), nbDirtyFiles &gt; 1);
821  				}
822  				if (res == IDYES)
823  				{
824  					if (!fileSave(id))
825  						return false;	
826  				}
827  				else if (res == IDCANCEL)
828  				{
829  					return false;
830  				}
831  				else if (res == IDIGNORE)
832  				{
833  					noSaveToAll = true;
834  				}
835  				else if (res == IDRETRY)
836  				{
837  					if (!fileSave(id))
838  						return false;	
839  					saveToAll = true;
840  				}
841  			}
842  		}
843  	}
844  	for (size_t i = 0; i &lt; _subDocTab.nbItem() &amp;&amp; !noSaveToAll; ++i)
845  	{
846  		BufferID id = _subDocTab.getBufferByIndex(i);
847  		Buffer * buf = MainFileManager.getBufferByID(id);
848  		if (uniqueBuffers.find(id) != uniqueBuffers.end())
849  			continue;
850  		if (buf-&gt;isUntitled() &amp;&amp; buf-&gt;docLength() == 0)
851  		{
852  		}
853  		else if (buf-&gt;isDirty())
854  		{
855  			if (isSnapshotMode)
856  			{
857  				if (buf-&gt;getBackupFileName() == TEXT(&quot;&quot;) || !::PathFileExists(buf-&gt;getBackupFileName().c_str())) 
858  				{
859  					activateBuffer(id, SUB_VIEW);
860  					switchEditViewTo(SUB_VIEW);
861  					int res = _nativeLangSpeaker.messageBox(&quot;NoBackupDoSaveFile&quot;,
862  						_pPublicInterface-&gt;getHSelf(),
863  						TEXT(&quot;Your backup file cannot be found (deleted from outside).\rSave it otherwise your data will be lost\rDo you want to save file \&quot;$STR_REPLACE$\&quot; ?&quot;),
864  						TEXT(&quot;Save&quot;),
865  						MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL,
866  						0, 
867  						buf-&gt;getFullPathName());
868  					if (res == IDYES)
869  					{
870  						if (!fileSave(id))
871  							return false;	
872  					}
873  					else if (res == IDCANCEL)
874  					{
875  						return false;
876  					}
877  				}
878  			}
879  			else
880  			{
881  				activateBuffer(id, SUB_VIEW);
882  				switchEditViewTo(SUB_VIEW);
883  				int res = -1;
884  				if (saveToAll)
885  				{
886  					res = IDYES;
887  				}
888  				else
889  				{
890  					size_t nbDirtyFiles = MainFileManager.getNbDirtyBuffers();
891  					res = doSaveOrNot(buf-&gt;getFullPathName(), nbDirtyFiles &gt; 1);
892  				}
893  				if (res == IDYES)
894  				{
895  					if (!fileSave(id))
896  						return false;	
897  				}
898  				else if (res == IDCANCEL)
899  				{
900  					return false;
901  				}
902  				else if (res == IDIGNORE)
903  				{
904  					noSaveToAll = true;
905  				}
906  				else if (res == IDRETRY)
907  				{
908  					if (!fileSave(id))
909  						return false;	
910  					saveToAll = true;
911  				}
912  			}
913  		}
914  	}
915      if (bothActive())
916      {
917  		activateBuffer(_pNonDocTab-&gt;getBufferByIndex(0), otherView());
918  		for (int32_t i = static_cast&lt;int32_t&gt;(_pNonDocTab-&gt;nbItem()) - 1; i &gt;= 0; i--) 
919  		{
920  			doClose(_pNonDocTab-&gt;getBufferByIndex(i), otherView(), doDeleteBackup);
921  		}
922      }
923  	activateBuffer(_pDocTab-&gt;getBufferByIndex(0), currentView());
924  	for (int32_t i = static_cast&lt;int32_t&gt;(_pDocTab-&gt;nbItem()) - 1; i &gt;= 0; i--)
925  	{	
926  		doClose(_pDocTab-&gt;getBufferByIndex(i), currentView(), doDeleteBackup);
927  	}
928  	return true;
929  }
930  bool Notepad_plus::fileCloseAllGiven(const std::vector&lt;BufferViewInfo&gt;&amp; fileInfos)
931  {
932  	bool noSaveToAll = false;
933  	bool saveToAll = false;
934  	std::vector&lt;BufferViewInfo&gt; buffersToClose;
935  	size_t nbDirtyFiles = 0;
936  	for (const auto&amp; i : fileInfos)
937  	{
938  		Buffer* buf = MainFileManager.getBufferByID(i._bufID);
939  		if (buf-&gt;isDirty())
940  			++nbDirtyFiles;
941  	}
942  	for (const auto&amp; i : fileInfos)
943  	{
944  		Buffer* buf = MainFileManager.getBufferByID(i._bufID);
945  		if ((buf-&gt;isUntitled() &amp;&amp; buf-&gt;docLength() == 0) || noSaveToAll || !buf-&gt;isDirty())
946  		{
947  			buffersToClose.push_back(i);
948  		}
949  		else if (buf-&gt;isDirty() &amp;&amp; !noSaveToAll)
950  		{
951  			if (_activeView == MAIN_VIEW)
952  			{
953  				activateBuffer(i._bufID, MAIN_VIEW);
954  				if (!activateBuffer(i._bufID, SUB_VIEW))
955  					switchEditViewTo(MAIN_VIEW);
956  			}
957  			else
958  			{
959  				activateBuffer(i._bufID, SUB_VIEW);
960  				switchEditViewTo(SUB_VIEW);
961  			}
962  			int res = saveToAll ? IDYES : doSaveOrNot(buf-&gt;getFullPathName(), nbDirtyFiles &gt; 1);
963  			if (res == IDYES || res == IDRETRY)
964  			{
965  				if (!fileSave(i._bufID))
966  					break;	
967  				buffersToClose.push_back(i);
968  				if (res == IDRETRY)
969  					saveToAll = true;
970  			}
971  			else if (res == IDNO || res == IDIGNORE)
972  			{
973  				buffersToClose.push_back(i);
974  				if (res == IDIGNORE)
975  					noSaveToAll = true;
976  			}
977  			else if (res == IDCANCEL)
978  			{
979  				break;
980  			}
981  		}
982  	}
983  	bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
984  	for (const auto&amp; i : buffersToClose)
985  	{
986  		doClose(i._bufID, i._iView, isSnapshotMode);
987  	}
988  	return true;
989  }
990  bool Notepad_plus::fileCloseAllToLeft()
991  {
992  	std::vector&lt;BufferViewInfo&gt; bufsToClose;
993  	for (int i = _pDocTab-&gt;getCurrentTabIndex() - 1; i &gt;= 0; i--)
994  	{
995  		bufsToClose.push_back(BufferViewInfo(_pDocTab-&gt;getBufferByIndex(i), currentView()));
996  	}
997  	return fileCloseAllGiven(bufsToClose);
998  }
999  bool Notepad_plus::fileCloseAllToRight()
1000  {
1001  	const int iActive = _pDocTab-&gt;getCurrentTabIndex();
1002  	std::vector&lt;BufferViewInfo&gt; bufsToClose;
1003  	for (int i = int(_pDocTab-&gt;nbItem()) - 1; i &gt; iActive; i--)
1004  	{
1005  		bufsToClose.push_back(BufferViewInfo(_pDocTab-&gt;getBufferByIndex(i), currentView()));
1006  	}
1007  	return fileCloseAllGiven(bufsToClose);
1008  }
1009  bool Notepad_plus::fileCloseAllUnchanged()
1010  {
1011  	std::vector&lt;BufferViewInfo&gt; bufsToClose;
1012  	for (int i = int(_pDocTab-&gt;nbItem()) - 1; i &gt;= 0; i--)
1013  	{
1014  		BufferID id = _pDocTab-&gt;getBufferByIndex(i);
1015  		Buffer* buf = MainFileManager.getBufferByID(id);
1016  		if ((buf-&gt;isUntitled() &amp;&amp; buf-&gt;docLength() == 0) || !buf-&gt;isDirty())
1017  		{
1018  			bufsToClose.push_back(BufferViewInfo(_pDocTab-&gt;getBufferByIndex(i), currentView()));
1019  		}
1020  	}
1021  	return fileCloseAllGiven(bufsToClose);
1022  }
1023  bool Notepad_plus::fileCloseAllButCurrent()
1024  {
1025  	BufferID current = _pEditView-&gt;getCurrentBufferID();
1026  	const int activeViewID = currentView();
1027  	int active = _pDocTab-&gt;getCurrentTabIndex();
1028  	bool noSaveToAll = false;
1029  	bool saveToAll = false;
1030  	std::vector&lt;unsigned int&gt; mainSaveOpIndex, subSaveOpIndex;
1031  	bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
1032  	for (size_t i = 0; i &lt; _mainDocTab.nbItem() &amp;&amp; !noSaveToAll; ++i)
1033  	{
1034  		BufferID id = _mainDocTab.getBufferByIndex(i);
1035  		if (id == current)
1036  			continue;
1037  		Buffer * buf = MainFileManager.getBufferByID(id);
1038  		if (buf-&gt;isUntitled() &amp;&amp; buf-&gt;docLength() == 0)
1039  		{
1040  		}
1041  		else if (buf-&gt;isDirty())
1042  		{
1043  			activateBuffer(id, MAIN_VIEW);
1044  			if (!activateBuffer(id, SUB_VIEW))
1045  				switchEditViewTo(MAIN_VIEW);
1046  			int res = -1;
1047  			if (saveToAll)
1048  			{
1049  				res = IDYES;
1050  			}
1051  			else
1052  			{
1053  				size_t nbDirtyFiles = MainFileManager.getNbDirtyBuffers();
1054  				Buffer* currentBuf = MainFileManager.getBufferByID(current);
1055  				nbDirtyFiles -= currentBuf-&gt;isDirty() ? 1 : 0;
1056  				res = doSaveOrNot(buf-&gt;getFullPathName(), nbDirtyFiles &gt; 1);
1057  			}
1058  			if (res == IDYES)
1059  			{
1060  				bool isSaved = fileSave(id);
1061  				if (isSaved)
1062  					mainSaveOpIndex.push_back((unsigned int)i);
1063  				else
1064  					res = IDCANCEL;	
1065  			}
1066  			else if (res == IDNO)
1067  			{
1068  				mainSaveOpIndex.push_back((unsigned int)i);
1069  			}
1070  			else if (res == IDIGNORE)
1071  			{
1072  				noSaveToAll = true;
1073  			}
1074  			else if (res == IDRETRY)
1075  			{
1076  				if (!fileSave(id))
1077  					return false;	
1078  				saveToAll = true;
1079  			}
1080  			if (res == IDCANCEL)
1081  			{
1082  				for (int32_t j = static_cast&lt;int32_t&gt;(mainSaveOpIndex.size()) - 1; j &gt;= 0; j--) 	
1083  				{
1084  					doClose(_mainDocTab.getBufferByIndex(mainSaveOpIndex[j]), MAIN_VIEW, isSnapshotMode);
1085  				}
1086  				return false;
1087  			}
1088  		}
1089  	}
1090  	for (size_t i = 0; i &lt; _subDocTab.nbItem() &amp;&amp; !noSaveToAll; ++i)
1091  	{
1092  		BufferID id = _subDocTab.getBufferByIndex(i);
1093  		Buffer * buf = MainFileManager.getBufferByID(id);
1094  		if (id == current)
1095  			continue;
1096  		if (buf-&gt;isUntitled() &amp;&amp; buf-&gt;docLength() == 0)
1097  		{
1098  		}
1099  		else if (buf-&gt;isDirty())
1100  		{
1101  			activateBuffer(id, SUB_VIEW);
1102  			switchEditViewTo(SUB_VIEW);
1103  			int res = -1;
1104  			if (saveToAll)
1105  			{
1106  				res = IDYES;
1107  			}
1108  			else
1109  			{
1110  				size_t nbDirtyFiles = MainFileManager.getNbDirtyBuffers();
1111  				Buffer* currentBuf = MainFileManager.getBufferByID(current);
1112  				nbDirtyFiles -= currentBuf-&gt;isDirty() ? 1 : 0;
1113  				res = doSaveOrNot(buf-&gt;getFullPathName(), nbDirtyFiles &gt; 1);
1114  			}
1115  			if (res == IDYES)
1116  			{
1117  				bool isSaved = fileSave(id);
1118  				if (isSaved)
1119  					subSaveOpIndex.push_back((unsigned int)i);
1120  				else
1121  					res = IDCANCEL;	
1122  			}
1123  			else if (res == IDNO)
1124  			{
1125  				subSaveOpIndex.push_back((unsigned int)i);
1126  			}
1127  			else if (res == IDIGNORE)
1128  			{
1129  				noSaveToAll = true;
1130  			}
1131  			else if (res == IDRETRY)
1132  			{
1133  				if (!fileSave(id))
1134  					return false;	
1135  				saveToAll = true;
1136  			}
1137  			if (res == IDCANCEL)
1138  			{
1139  				for (int32_t j = static_cast&lt;int32_t&gt;(mainSaveOpIndex.size()) - 1; j &gt;= 0; j--) 	
1140  				{
1141  					doClose(_mainDocTab.getBufferByIndex(mainSaveOpIndex[j]), MAIN_VIEW, isSnapshotMode);
1142  				}
1143  				for (int32_t j = static_cast&lt;int32_t&gt;(subSaveOpIndex.size()) - 1; j &gt;= 0; j--) 	
1144  				{
1145  					doClose(_subDocTab.getBufferByIndex(subSaveOpIndex[j]), SUB_VIEW, isSnapshotMode);
1146  				}
1147  				return false;
1148  			}
1149  		}
1150  	}
1151  	switchEditViewTo(activeViewID);
1152      if (bothActive())
1153      {
1154  		const int viewNo = otherView();
1155  		activateBuffer(_pNonDocTab-&gt;getBufferByIndex(0), viewNo);
1156  		for (int32_t i = static_cast&lt;int32_t&gt;(_pNonDocTab-&gt;nbItem()) - 1; i &gt;= 0; i--) 	
1157  		{
1158  			doClose(_pNonDocTab-&gt;getBufferByIndex(i), viewNo, isSnapshotMode);
1159  		}
1160      }
1161  	const int viewNo = currentView();
1162  	size_t nbItems = _pDocTab-&gt;nbItem();
1163  	activateBuffer(_pDocTab-&gt;getBufferByIndex(0), viewNo);
1164  	size_t newNbItems = _pDocTab-&gt;nbItem();
1165  	if (nbItems &gt; newNbItems) 
1166  	{
1167  		active -= 1;
1168  	}
1169  	for (int32_t i = static_cast&lt;int32_t&gt;(newNbItems) - 1; i &gt;= 0; i--)	
1170  	{
1171  		if (i == active)	
1172  		{
1173  			continue;
1174  		}
1175  		doClose(_pDocTab-&gt;getBufferByIndex(i), viewNo, isSnapshotMode);
1176  	}
1177  	return true;
1178  }
1179  bool Notepad_plus::fileSave(BufferID id)
1180  {
1181  	BufferID bufferID = id;
1182  	if (id == BUFFER_INVALID)
1183  		bufferID = _pEditView-&gt;getCurrentBufferID();
1184  	Buffer * buf = MainFileManager.getBufferByID(bufferID);
1185  	if (!buf-&gt;getFileReadOnly() &amp;&amp; buf-&gt;isDirty())	
1186  	{
1187  		if (buf-&gt;isUntitled())
1188  		{
1189  			return fileSaveAs(bufferID);
1190  		}
1191  		const NppGUI &amp; nppgui = (NppParameters::getInstance()).getNppGUI();
1192  		BackupFeature backup = nppgui._backup;
1193  		if (backup != bak_none &amp;&amp; !buf-&gt;isLargeFile())
1194  		{
1195  			const TCHAR *fn = buf-&gt;getFullPathName();
1196  			TCHAR *name = ::PathFindFileName(fn);
1197  			generic_string fn_bak;
1198  			if (nppgui._useDir &amp;&amp; !nppgui._backupDir.empty())
1199  			{
1200  				fn_bak = nppgui._backupDir;
1201  				if (fn_bak.back() != TEXT(&#x27;\\&#x27;))
1202  					fn_bak += TEXT(&quot;\\&quot;);
1203  			}
1204  			else
1205  			{
1206  				generic_string path = fn;
1207  				::PathRemoveFileSpec(path);
1208  				fn_bak = path.c_str();
1209  				fn_bak += TEXT(&quot;\\&quot;);
1210  				if (backup == bak_verbose)
1211  				{
1212  					fn_bak += TEXT(&quot;nppBackup\\&quot;);
1213  				}
1214  			}
1215  			TCHAR fn_bak_expanded[MAX_PATH] = { &#x27;\0&#x27; };
1216  			::ExpandEnvironmentStrings(fn_bak.c_str(), fn_bak_expanded, MAX_PATH);
1217  			fn_bak = fn_bak_expanded;
1218  			if (!::PathFileExists(fn_bak.c_str()))
1219  			{
1220  				SHCreateDirectory(NULL, fn_bak.c_str());
1221  			}
1222  			if (backup == bak_simple)
1223  			{
1224  				fn_bak += name;
1225  				fn_bak += TEXT(&quot;.bak&quot;);
1226  			}
1227  			else if (backup == bak_verbose)
1228  			{
1229  				const int temBufLen = 32;
1230  				TCHAR tmpbuf[temBufLen];
1231  				time_t ltime = time(0);
1232  				struct tm *today;
1233  				today = localtime(&amp;ltime);
1234  				if (today)
1235  				{
1236  					wcsftime(tmpbuf, temBufLen, L&quot;%Y-%m-%d_%H%M%S&quot;, today);
1237  					fn_bak += name;
1238  					fn_bak += TEXT(&quot;.&quot;);
1239  					fn_bak += tmpbuf;
1240  					fn_bak += TEXT(&quot;.bak&quot;);
1241  				}
1242  			}
1243  			BOOL doCancel = FALSE;
1244  			if (!::CopyFileEx(fn, fn_bak.c_str(), nullptr, nullptr, &amp;doCancel, COPY_FILE_NO_BUFFERING))
1245  			{
1246  				int res = _nativeLangSpeaker.messageBox(&quot;FileBackupFailed&quot;,
1247  					_pPublicInterface-&gt;getHSelf(),
1248  					TEXT(&quot;The previous version of the file could not be saved into the backup directory at \&quot;$STR_REPLACE$\&quot;.\r\rDo you want to save the current file anyways?&quot;),
1249  					TEXT(&quot;File Backup Failed&quot;),
1250  					MB_YESNO | MB_ICONERROR,
1251  					0,
1252  					fn_bak.c_str());
1253  				if (res == IDNO)
1254  				{
1255  					return false;
1256  				}
1257  			}
1258  		}
1259  		return doSave(bufferID, buf-&gt;getFullPathName(), false);
1260  	}
1261  	return false;
1262  }
1263  bool Notepad_plus::fileSaveSpecific(const generic_string&amp; fileNameToSave)
1264  {
1265  	BufferID idToSave = _mainDocTab.findBufferByName(fileNameToSave.c_str());
1266  	if (idToSave == BUFFER_INVALID)
1267  	{
1268  		idToSave = _subDocTab.findBufferByName(fileNameToSave.c_str());
1269  	}
1270  	if (idToSave != BUFFER_INVALID)
1271  	{
1272  		fileSave(idToSave);
1273  		checkDocState();
1274  		return true;
1275  	}
1276  	else
1277  	{
1278  		return false;
1279  	}
1280  }
1281  bool Notepad_plus::fileSaveAllConfirm()
1282  {
1283  	bool confirmed = false;
1284  	if (NppParameters::getInstance().getNppGUI()._saveAllConfirm)
1285  	{
1286  		int answer = doSaveAll();
1287  		if (answer == IDYES)
1288  		{
1289  			confirmed = true;
1290  		}
1291  		if (answer == IDRETRY)
1292  		{
1293  			NppParameters::getInstance().getNppGUI()._saveAllConfirm = false;
1294  			_preference._miscSubDlg.setChecked(IDC_CHECK_SAVEALLCONFIRM, false);
1295  			confirmed = true;
1296  		}
1297  	}
1298  	else
1299  	{
1300  		confirmed = true;
1301  	}
1302  	return confirmed;
1303  }
1304  size_t Notepad_plus::getNbDirtyBuffer(int view)
1305  {
1306  	if (view != MAIN_VIEW &amp;&amp; view != SUB_VIEW)
1307  		return 0;
1308  	DocTabView* pDocTabView = &amp;_mainDocTab;
1309  	if (view == SUB_VIEW)
1310  		pDocTabView = &amp;_subDocTab;
1311  	size_t count = 0;
1312  	for (size_t i = 0; i &lt; pDocTabView-&gt;nbItem(); ++i)
1313  	{
1314  		BufferID id = pDocTabView-&gt;getBufferByIndex(i);
1315  		Buffer* buf = MainFileManager.getBufferByID(id);
1316  		if (buf-&gt;isDirty())
1317  		{
1318  			++count;
1319  		}
1320  	}
1321  	return count;
1322  }
1323  bool Notepad_plus::fileSaveAll()
1324  {
1325  	size_t nbDirty = getNbDirtyBuffer(MAIN_VIEW) + getNbDirtyBuffer(SUB_VIEW);
1326  	if (!nbDirty)
1327  		return false;
1328  	Buffer* curBuf = _pEditView-&gt;getCurrentBuffer();
1329  	if (nbDirty == 1 &amp;&amp; curBuf-&gt;isDirty())
1330  	{
1331  		fileSave(curBuf);
1332  	}
1333  	else if (fileSaveAllConfirm())
1334  	{
1335  		if (viewVisible(MAIN_VIEW))
1336  		{
1337  			for (size_t i = 0; i &lt; _mainDocTab.nbItem(); ++i)
1338  			{
1339  				BufferID idToSave = _mainDocTab.getBufferByIndex(i);
1340  				fileSave(idToSave);
1341  			}
1342  		}
1343  		if (viewVisible(SUB_VIEW))
1344  		{
1345  			for (size_t i = 0; i &lt; _subDocTab.nbItem(); ++i)
1346  			{
1347  				BufferID idToSave = _subDocTab.getBufferByIndex(i);
1348  				fileSave(idToSave);
1349  			}
1350  		}
1351  		checkDocState();
1352  	}
1353  	return true;
1354  }
1355  bool Notepad_plus::fileSaveAs(BufferID id, bool isSaveCopy)
1356  {
1357  	BufferID bufferID = id;
1358  	if (id == BUFFER_INVALID)
1359  		bufferID = _pEditView-&gt;getCurrentBufferID();
1360  	Buffer * buf = MainFileManager.getBufferByID(bufferID);
1361  	generic_string origPathname = buf-&gt;getFullPathName();
1362  	bool wasUntitled = buf-&gt;isUntitled();
1363  	CustomFileDialog fDlg(_pPublicInterface-&gt;getHSelf());
1364  	fDlg.setExtFilter(TEXT(&quot;All types&quot;), TEXT(&quot;.*&quot;));
1365  	LangType langType = buf-&gt;getLangType();
1366  	const bool defaultAllTypes = NppParameters::getInstance().getNppGUI()._setSaveDlgExtFiltToAllTypes;
1367  	const int langTypeIndex = setFileOpenSaveDlgFilters(fDlg, false, langType);
1368  	fDlg.setDefFileName(buf-&gt;getFileName());
1369  	fDlg.setExtIndex(langTypeIndex + 1); 
1370  	const generic_string checkboxLabel = _nativeLangSpeaker.getLocalizedStrFromID(&quot;file-save-assign-type&quot;,
1371  		TEXT(&quot;&amp;Append extension&quot;));
1372  	fDlg.enableFileTypeCheckbox(checkboxLabel, !defaultAllTypes);
1373  	NppParameters&amp; nppParam = NppParameters::getInstance();
1374  	auto cdBefore = nppParam.getNppGUI()._fileAutoDetection;
1375  	(nppParam.getNppGUI())._fileAutoDetection = cdDisabled;
1376  	generic_string fn = fDlg.doSaveDlg();
1377  	(nppParam.getNppGUI())._setSaveDlgExtFiltToAllTypes = !fDlg.getFileTypeCheckboxValue();
1378  	(nppParam.getNppGUI())._fileAutoDetection = cdBefore;
1379  	if (!fn.empty())
1380  	{
1381  		BufferID other = _pDocTab-&gt;findBufferByName(fn.c_str());
1382  		if (other == BUFFER_INVALID)
1383  			other = _pNonDocTab-&gt;findBufferByName(fn.c_str());
1384  		if (other == BUFFER_INVALID 
1385  			|| other-&gt;getID() == bufferID-&gt;getID()) 
1386  		{
1387  			bool res = doSave(bufferID, fn.c_str(), isSaveCopy);
1388  			if (!wasUntitled &amp;&amp; !isSaveCopy)
1389  			{
1390  				_lastRecentFileList.add(origPathname.c_str());
1391  			}
1392  			if (res &amp;&amp; !isSaveCopy)
1393  			{
1394  				_lastRecentFileList.remove(fn.c_str());
1395  			}
1396  			return res;
1397  		}
1398  		else		
1399  		{
1400  			_nativeLangSpeaker.messageBox(&quot;FileAlreadyOpenedInNpp&quot;,
1401  				_pPublicInterface-&gt;getHSelf(),
1402  				TEXT(&quot;The file is already opened in Notepad++.&quot;),
1403  				TEXT(&quot;ERROR&quot;),
1404  				MB_OK | MB_ICONSTOP);
1405  			switchToFile(other);
1406  			return false;
1407  		}
1408  	}
1409  	else 
1410  	{
1411  		checkModifiedDocument(true);
1412  		return false;
1413  	}
1414  }
1415  bool Notepad_plus::fileRename(BufferID id)
1416  {
1417  	BufferID bufferID = id;
1418  	if (id == BUFFER_INVALID)
1419  		bufferID = _pEditView-&gt;getCurrentBufferID();
1420  	Buffer * buf = MainFileManager.getBufferByID(bufferID);
1421  	SCNotification scnN{};
1422  	scnN.nmhdr.code = NPPN_FILEBEFORERENAME;
1423  	scnN.nmhdr.hwndFrom = _pPublicInterface-&gt;getHSelf();
1424  	scnN.nmhdr.idFrom = (uptr_t)bufferID;
1425  	_pluginsManager.notify(&amp;scnN);
1426  	bool success = false;
1427  	bool isFileExisting = PathFileExists(buf-&gt;getFullPathName()) != FALSE;
1428  	if (isFileExisting)
1429  	{
1430  		CustomFileDialog fDlg(_pPublicInterface-&gt;getHSelf());
1431  		fDlg.setExtFilter(TEXT(&quot;All types&quot;), TEXT(&quot;.*&quot;));
1432  		setFileOpenSaveDlgFilters(fDlg, false);
1433  		fDlg.setFolder(buf-&gt;getFullPathName());
1434  		fDlg.setDefFileName(buf-&gt;getFileName());
1435  		generic_string title = _nativeLangSpeaker.getLocalizedStrFromID(&quot;file-rename-title&quot;, TEXT(&quot;Rename&quot;));
1436  		fDlg.setTitle(title.c_str());
1437  		generic_string fn = fDlg.doSaveDlg();
1438  		if (!fn.empty())
1439  			success = MainFileManager.moveFile(bufferID, fn.c_str());
1440  	}
1441  	else
1442  	{
1443  		std::wstring reservedChars = TEXT(&quot;&lt;&gt;:\&quot;/\\|\?*&quot;);
1444  		generic_string staticName = _nativeLangSpeaker.getLocalizedStrFromID(&quot;tabrename-newname&quot;, TEXT(&quot;New name&quot;));
1445  		StringDlg strDlg;
1446  		generic_string title = _nativeLangSpeaker.getLocalizedStrFromID(&quot;tabrename-title&quot;, TEXT(&quot;Rename Current Tab&quot;));
1447  		strDlg.init(_pPublicInterface-&gt;getHinst(), _pPublicInterface-&gt;getHSelf(), title.c_str(), staticName.c_str(), buf-&gt;getFileName(), langNameLenMax - 1, reservedChars.c_str(), true);
1448  		TCHAR *tabNewName = reinterpret_cast&lt;TCHAR *&gt;(strDlg.doDialog());
1449  		if (tabNewName)
1450  		{
1451  			BufferID sameNamedBufferId = _pDocTab-&gt;findBufferByName(tabNewName);
1452  			if (sameNamedBufferId == BUFFER_INVALID)
1453  			{
1454  				sameNamedBufferId = _pNonDocTab-&gt;findBufferByName(tabNewName);
1455  			}
1456  			if (sameNamedBufferId != BUFFER_INVALID)
1457  			{
1458  				_nativeLangSpeaker.messageBox(&quot;RenameTabTemporaryNameAlreadyInUse&quot;,
1459  					_pPublicInterface-&gt;getHSelf(),
1460  					TEXT(&quot;The specified name is already in use on another tab.&quot;),
1461  					TEXT(&quot;Rename failed&quot;),
1462  					MB_OK | MB_ICONSTOP);
1463  			}
1464  			else
1465  			{
1466  				success = true;
1467  				buf-&gt;setFileName(tabNewName);
1468  				bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
1469  				if (isSnapshotMode)
1470  				{
1471  					generic_string oldBackUpFile = buf-&gt;getBackupFileName();
1472  					buf-&gt;setBackupFileName(TEXT(&quot;&quot;));
1473  					buf-&gt;setModifiedStatus(true);
1474  					bool bRes = MainFileManager.backupCurrentBuffer();
1475  					if (bRes)
1476  						::DeleteFile(oldBackUpFile.c_str());
1477  				}
1478  			}
1479  		}
1480  	}
1481  	scnN.nmhdr.code = success ? NPPN_FILERENAMED : NPPN_FILERENAMECANCEL;
1482  	_pluginsManager.notify(&amp;scnN);
1483  	return success;
1484  }
1485  bool Notepad_plus::fileDelete(BufferID id)
1486  {
1487  	BufferID bufferID = id;
1488  	if (id == BUFFER_INVALID)
1489  		bufferID = _pEditView-&gt;getCurrentBufferID();
1490  	Buffer * buf = MainFileManager.getBufferByID(bufferID);
1491  	const TCHAR *fileNamePath = buf-&gt;getFullPathName();
1492  	winVer winVersion = (NppParameters::getInstance()).getWinVersion();
1493  	bool goAhead = true;
1494  	if (winVersion &gt;= WV_WIN8 || winVersion == WV_UNKNOWN)
1495  	{
1496  		goAhead = (doDeleteOrNot(fileNamePath) == IDOK);
1497  	}
1498  	if (goAhead)
1499  	{
1500  		SCNotification scnN{};
1501  		scnN.nmhdr.code = NPPN_FILEBEFOREDELETE;
1502  		scnN.nmhdr.hwndFrom = _pPublicInterface-&gt;getHSelf();
1503  		scnN.nmhdr.idFrom = (uptr_t)bufferID;
1504  		_pluginsManager.notify(&amp;scnN);
1505  		if (!MainFileManager.deleteFile(bufferID))
1506  		{
1507  			_nativeLangSpeaker.messageBox(&quot;DeleteFileFailed&quot;,
1508  				_pPublicInterface-&gt;getHSelf(),
1509  				TEXT(&quot;Delete File failed&quot;),
1510  				TEXT(&quot;Delete File&quot;),
1511  				MB_OK);
1512  			scnN.nmhdr.code = NPPN_FILEDELETEFAILED;
1513  			_pluginsManager.notify(&amp;scnN);
1514  			return false;
1515  		}
1516  		bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
1517  		doClose(bufferID, MAIN_VIEW, isSnapshotMode);
1518  		doClose(bufferID, SUB_VIEW, isSnapshotMode);
1519  		scnN.nmhdr.code = NPPN_FILEDELETED;
1520  		scnN.nmhdr.idFrom = (uptr_t)-1;
1521  		_pluginsManager.notify(&amp;scnN);
1522  		return true;
1523  	}
1524  	return false;
1525  }
1526  void Notepad_plus::fileOpen()
1527  {
1528  	CustomFileDialog fDlg(_pPublicInterface-&gt;getHSelf());
1529  	fDlg.setExtFilter(TEXT(&quot;All types&quot;), TEXT(&quot;.*&quot;));
1530  	setFileOpenSaveDlgFilters(fDlg, true);
1531  	BufferID lastOpened = BUFFER_INVALID;
1532  	const auto&amp; fns = fDlg.doOpenMultiFilesDlg();
1533  	size_t sz = fns.size();
1534  	for (size_t i = 0 ; i &lt; sz ; ++i)
1535  	{
1536  		BufferID test = doOpen(fns.at(i).c_str());
1537  		if (test != BUFFER_INVALID)
1538  			lastOpened = test;
1539  	}
1540  	if (lastOpened != BUFFER_INVALID)
1541  	{
1542  		switchToFile(lastOpened);
1543  	}
1544  }
1545  void Notepad_plus::fileNew()
1546  {
1547      BufferID newBufID = MainFileManager.newEmptyDocument();
1548      loadBufferIntoView(newBufID, currentView(), true);	
1549      switchToFile(newBufID);
1550  }
1551  bool Notepad_plus::fileReload()
1552  {
1553  	assert(_pEditView != nullptr);
1554  	BufferID buf = _pEditView-&gt;getCurrentBufferID();
1555  	return doReload(buf, buf-&gt;isDirty());
1556  }
1557  bool Notepad_plus::isFileSession(const TCHAR * filename)
1558  {
1559  	const TCHAR *definedSessionExt = NppParameters::getInstance().getNppGUI()._definedSessionExt.c_str();
1560  	if (*definedSessionExt != &#x27;\0&#x27;)
1561  	{
1562  		generic_string fncp = filename;
1563  		TCHAR *pExt = PathFindExtension(fncp.c_str());
1564  		generic_string usrSessionExt = TEXT(&quot;&quot;);
1565  		if (*definedSessionExt != &#x27;.&#x27;)
1566  		{
1567  			usrSessionExt += TEXT(&quot;.&quot;);
1568  		}
1569  		usrSessionExt += definedSessionExt;
1570  		if (!wcsicmp(pExt, usrSessionExt.c_str()))
1571  		{
1572  			return true;
1573  		}
1574  	}
1575  	return false;
1576  }
1577  bool Notepad_plus::isFileWorkspace(const TCHAR * filename)
1578  {
1579  	const TCHAR *definedWorkspaceExt = NppParameters::getInstance().getNppGUI()._definedWorkspaceExt.c_str();
1580  	if (*definedWorkspaceExt != &#x27;\0&#x27;)
1581  	{
1582  		generic_string fncp = filename;
1583  		TCHAR *pExt = PathFindExtension(fncp.c_str());
1584  		generic_string usrWorkspaceExt = TEXT(&quot;&quot;);
1585  		if (*definedWorkspaceExt != &#x27;.&#x27;)
1586  		{
1587  			usrWorkspaceExt += TEXT(&quot;.&quot;);
1588  		}
1589  		usrWorkspaceExt += definedWorkspaceExt;
1590  		if (!wcsicmp(pExt, usrWorkspaceExt.c_str()))
1591  		{
1592  			return true;
1593  		}
1594  	}
1595  	return false;
1596  }
1597  void Notepad_plus::loadLastSession()
1598  {
1599  	NppParameters&amp; nppParams = NppParameters::getInstance();
1600  	const NppGUI &amp; nppGui = nppParams.getNppGUI();
1601  	Session lastSession = nppParams.getSession();
1602  	bool isSnapshotMode = nppGui.isSnapshotMode();
1603  	_isFolding = true;
1604      loadSession(lastSession, isSnapshotMode);
1605  	_isFolding = false;
1606  }
1607  bool Notepad_plus::loadSession(Session &amp; session, bool isSnapshotMode, bool shouldLoadFileBrowser)
1608  {
1609  	NppParameters&amp; nppParam = NppParameters::getInstance();
1610  	bool allSessionFilesLoaded = true;
1611  	BufferID lastOpened = BUFFER_INVALID;
1612  	showView(MAIN_VIEW);
1613  	switchEditViewTo(MAIN_VIEW);	
1614  	int mainIndex2Update = -1;
1615  	for (size_t i = 0; i &lt; session.nbMainFiles() ; )
1616  	{
1617  		const TCHAR *pFn = session._mainViewFiles[i]._fileName.c_str();
1618  		if (isFileSession(pFn) || isFileWorkspace(pFn))
1619  		{
1620  			vector&lt;sessionFileInfo&gt;::iterator posIt = session._mainViewFiles.begin() + i;
1621  			session._mainViewFiles.erase(posIt);
1622  			continue;	
1623  		}
1624  		bool isWow64Off = false;
1625  		if (!PathFileExists(pFn))
1626  		{
1627  			nppParam.safeWow64EnableWow64FsRedirection(FALSE);
1628  			isWow64Off = true;
1629  		}
1630  		if (PathFileExists(pFn))
1631  		{
1632  			if (isSnapshotMode &amp;&amp; session._mainViewFiles[i]._backupFilePath != TEXT(&quot;&quot;))
1633  				lastOpened = doOpen(pFn, false, false, session._mainViewFiles[i]._encoding, session._mainViewFiles[i]._backupFilePath.c_str(), session._mainViewFiles[i]._originalFileLastModifTimestamp);
1634  			else
1635  				lastOpened = doOpen(pFn, false, false, session._mainViewFiles[i]._encoding);
1636  		}
1637  		else if (isSnapshotMode &amp;&amp; PathFileExists(session._mainViewFiles[i]._backupFilePath.c_str()))
1638  		{
1639  			lastOpened = doOpen(pFn, false, false, session._mainViewFiles[i]._encoding, session._mainViewFiles[i]._backupFilePath.c_str(), session._mainViewFiles[i]._originalFileLastModifTimestamp);
1640  		}
1641  		else
1642  		{
1643  			lastOpened = BUFFER_INVALID;
1644  		}
1645  		if (isWow64Off)
1646  		{
1647  			nppParam.safeWow64EnableWow64FsRedirection(TRUE);
1648  			isWow64Off = false;
1649  		}
1650  		if (lastOpened != BUFFER_INVALID)
1651  		{
1652  			showView(MAIN_VIEW);
1653  			const wchar_t* pLn = nullptr;
1654  			LangType langTypeToSet = L_TEXT;
1655  			Buffer* buf = MainFileManager.getBufferByID(lastOpened);
1656  			if (!buf-&gt;isLargeFile())
1657  			{
1658  				pLn = session._mainViewFiles[i]._langName.c_str();
1659  				int id = getLangFromMenuName(pLn);
1660  				if (!id) 
1661  				{
1662  					const NppGUI&amp; nppGUI = nppParam.getNppGUI();
1663  					for (size_t k = 0; k &lt; nppGUI._excludedLangList.size(); ++k) 
1664  					{
1665  						if (nppGUI._excludedLangList[k]._langName == pLn)
1666  						{
1667  							langTypeToSet = nppGUI._excludedLangList[k]._langType;
1668  							break;
1669  						}
1670  					}
1671  				}
1672  				else if (id != IDM_LANG_USER)
1673  					langTypeToSet = menuID2LangType(id);
1674  				if (langTypeToSet == L_EXTERNAL)
1675  					langTypeToSet = (LangType)(id - IDM_LANG_EXTERNAL + L_EXTERNAL);
1676  			}
1677  			if (session._mainViewFiles[i]._foldStates.size() &gt; 0)
1678  			{
1679  				if (buf == _mainEditView.getCurrentBuffer()) 
1680  					mainIndex2Update = static_cast&lt;int32_t&gt;(i);
1681  				else
1682  					buf-&gt;setHeaderLineState(session._mainViewFiles[i]._foldStates, &amp;_mainEditView);
1683  			}
1684  			buf-&gt;setPosition(session._mainViewFiles[i], &amp;_mainEditView);
1685  			buf-&gt;setMapPosition(session._mainViewFiles[i]._mapPos);
1686  			buf-&gt;setLangType(langTypeToSet, pLn);
1687  			if (session._mainViewFiles[i]._encoding != -1)
1688  				buf-&gt;setEncoding(session._mainViewFiles[i]._encoding);
1689  			buf-&gt;setUserReadOnly(session._mainViewFiles[i]._isUserReadOnly);
1690  			if (isSnapshotMode &amp;&amp; session._mainViewFiles[i]._backupFilePath != TEXT(&quot;&quot;) &amp;&amp; PathFileExists(session._mainViewFiles[i]._backupFilePath.c_str()))
1691  				buf-&gt;setDirty(true);
1692  			_mainDocTab.setIndividualTabColour(lastOpened, session._mainViewFiles[i]._individualTabColour);
1693  			Document prevDoc = _mainEditView.execute(SCI_GETDOCPOINTER);
1694  			_mainEditView.execute(SCI_SETDOCPOINTER, 0, buf-&gt;getDocument());
1695  			for (size_t j = 0, len = session._mainViewFiles[i]._marks.size(); j &lt; len ; ++j)
1696  			{
1697  				_mainEditView.execute(SCI_MARKERADD, session._mainViewFiles[i]._marks[j], MARK_BOOKMARK);
1698  			}
1699  			_mainEditView.execute(SCI_SETDOCPOINTER, 0, prevDoc);
1700  			++i;
1701  		}
1702  		else
1703  		{
1704  			vector&lt;sessionFileInfo&gt;::iterator posIt = session._mainViewFiles.begin() + i;
1705  			session._mainViewFiles.erase(posIt);
1706  			allSessionFilesLoaded = false;
1707  		}
1708  	}
1709  	if (mainIndex2Update != -1)
1710  	{
1711  		_isFolding = true;
1712  		_mainEditView.syncFoldStateWith(session._mainViewFiles[mainIndex2Update]._foldStates);
1713  		_isFolding = false;
1714  	}
1715  	showView(SUB_VIEW);
1716  	switchEditViewTo(SUB_VIEW);	
1717  	int subIndex2Update = -1;
1718  	for (size_t k = 0 ; k &lt; session.nbSubFiles() ; )
1719  	{
1720  		const TCHAR *pFn = session._subViewFiles[k]._fileName.c_str();
1721  		if (isFileSession(pFn) || isFileWorkspace(pFn))
1722  		{
1723  			vector&lt;sessionFileInfo&gt;::iterator posIt = session._subViewFiles.begin() + k;
1724  			session._subViewFiles.erase(posIt);
1725  			continue;	
1726  		}
1727  		bool isWow64Off = false;
1728  		if (!PathFileExists(pFn))
1729  		{
1730  			nppParam.safeWow64EnableWow64FsRedirection(FALSE);
1731  			isWow64Off = true;
1732  		}
1733  		if (PathFileExists(pFn))
1734  		{
1735  			if (isSnapshotMode &amp;&amp; session._subViewFiles[k]._backupFilePath != TEXT(&quot;&quot;))
1736  				lastOpened = doOpen(pFn, false, false, session._subViewFiles[k]._encoding, session._subViewFiles[k]._backupFilePath.c_str(), session._subViewFiles[k]._originalFileLastModifTimestamp);
1737  			else
1738  				lastOpened = doOpen(pFn, false, false, session._subViewFiles[k]._encoding);
1739  			if (_mainDocTab.getIndexByBuffer(lastOpened) != -1)
1740  			{
1741  				loadBufferIntoView(lastOpened, SUB_VIEW);
1742  			}
1743  		}
1744  		else if (isSnapshotMode &amp;&amp; PathFileExists(session._subViewFiles[k]._backupFilePath.c_str()))
1745  		{
1746  			lastOpened = doOpen(pFn, false, false, session._subViewFiles[k]._encoding, session._subViewFiles[k]._backupFilePath.c_str(), session._subViewFiles[k]._originalFileLastModifTimestamp);
1747  		}
1748  		else
1749  		{
1750  			lastOpened = BUFFER_INVALID;
1751  		}
1752  		if (isWow64Off)
1753  		{
1754  			nppParam.safeWow64EnableWow64FsRedirection(TRUE);
1755  			isWow64Off = false;
1756  		}
1757  		if (lastOpened != BUFFER_INVALID)
1758  		{
1759  			showView(SUB_VIEW);
1760  			if (canHideView(MAIN_VIEW))
1761  				hideView(MAIN_VIEW);
1762  			const TCHAR *pLn = session._subViewFiles[k]._langName.c_str();
1763  			int id = getLangFromMenuName(pLn);
1764  			LangType typeToSet = L_TEXT;
1765  			if (id != 0)
1766  				typeToSet = menuID2LangType(id);
1767  			if (typeToSet == L_EXTERNAL )
1768  				typeToSet = (LangType)(id - IDM_LANG_EXTERNAL + L_EXTERNAL);
1769  			Buffer * buf = MainFileManager.getBufferByID(lastOpened);
1770  			if (session._subViewFiles[k]._foldStates.size() &gt; 0)
1771  			{
1772  				if (buf == _subEditView.getCurrentBuffer()) 
1773  					subIndex2Update = static_cast&lt;int32_t&gt;(k);
1774  				else
1775  					buf-&gt;setHeaderLineState(session._subViewFiles[k]._foldStates, &amp;_subEditView);
1776  			}
1777  			buf-&gt;setPosition(session._subViewFiles[k], &amp;_subEditView);
1778  			buf-&gt;setMapPosition(session._subViewFiles[k]._mapPos);
1779  			if (typeToSet == L_USER)
1780  			{
1781  				if (!lstrcmp(pLn, TEXT(&quot;User Defined&quot;)))
1782  				{
1783  					pLn = TEXT(&quot;&quot;);	
1784  				}
1785  			}
1786  			buf-&gt;setLangType(typeToSet, pLn);
1787  			buf-&gt;setEncoding(session._subViewFiles[k]._encoding);
1788  			buf-&gt;setUserReadOnly(session._subViewFiles[k]._isUserReadOnly);
1789  			if (isSnapshotMode &amp;&amp; session._subViewFiles[k]._backupFilePath != TEXT(&quot;&quot;) &amp;&amp; PathFileExists(session._subViewFiles[k]._backupFilePath.c_str()))
1790  				buf-&gt;setDirty(true);
1791  			_subDocTab.setIndividualTabColour(lastOpened, session._subViewFiles[k]._individualTabColour);
1792  			Document prevDoc = _subEditView.execute(SCI_GETDOCPOINTER);
1793  			_subEditView.execute(SCI_SETDOCPOINTER, 0, buf-&gt;getDocument());
1794  			for (size_t j = 0, len = session._subViewFiles[k]._marks.size(); j &lt; len ; ++j)
1795  			{
1796  				_subEditView.execute(SCI_MARKERADD, session._subViewFiles[k]._marks[j], MARK_BOOKMARK);
1797  			}
1798  			_subEditView.execute(SCI_SETDOCPOINTER, 0, prevDoc);
1799  			++k;
1800  		}
1801  		else
1802  		{
1803  			vector&lt;sessionFileInfo&gt;::iterator posIt = session._subViewFiles.begin() + k;
1804  			session._subViewFiles.erase(posIt);
1805  			allSessionFilesLoaded = false;
1806  		}
1807  	}
1808  	if (subIndex2Update != -1)
1809  	{
1810  		_isFolding = true;
1811  		_subEditView.syncFoldStateWith(session._subViewFiles[subIndex2Update]._foldStates);
1812  		_isFolding = false;
1813  	}
1814  	_mainEditView.restoreCurrentPosPreStep();
1815  	_subEditView.restoreCurrentPosPreStep();
1816  	if (session._activeMainIndex &lt; _mainDocTab.nbItem())
1817  		activateBuffer(_mainDocTab.getBufferByIndex(session._activeMainIndex), MAIN_VIEW);
1818  	if (session._activeSubIndex &lt; _subDocTab.nbItem())
1819  		activateBuffer(_subDocTab.getBufferByIndex(session._activeSubIndex), SUB_VIEW);
1820  	if ((session.nbSubFiles() &gt; 0) &amp;&amp; (session._activeView == MAIN_VIEW || session._activeView == SUB_VIEW))
1821  		switchEditViewTo(static_cast&lt;int32_t&gt;(session._activeView));
1822  	else
1823  		switchEditViewTo(MAIN_VIEW);
1824  	if (canHideView(otherView()))
1825  		hideView(otherView());
1826  	else if (canHideView(currentView()))
1827  		hideView(currentView());
1828  	checkSyncState();
1829  	if (_pDocumentListPanel)
1830  		_pDocumentListPanel-&gt;reload();
1831  	if (shouldLoadFileBrowser &amp;&amp; !session._fileBrowserRoots.empty())
1832  	{
1833  		launchFileBrowser(session._fileBrowserRoots, session._fileBrowserSelectedItem, true);
1834  	}
1835  	return allSessionFilesLoaded;
1836  }
1837  bool Notepad_plus::fileLoadSession(const TCHAR *fn)
1838  {
1839  	bool result = false;
1840  	generic_string sessionFileName;
1841  	if (fn == NULL)
1842  	{
1843  		CustomFileDialog fDlg(_pPublicInterface-&gt;getHSelf());
1844  		const TCHAR *ext = NppParameters::getInstance().getNppGUI()._definedSessionExt.c_str();
1845  		generic_string sessionExt = TEXT(&quot;&quot;);
1846  		if (*ext != &#x27;\0&#x27;)
1847  		{
1848  			if (*ext != &#x27;.&#x27;)
1849  				sessionExt += TEXT(&quot;.&quot;);
1850  			sessionExt += ext;
1851  			fDlg.setExtFilter(TEXT(&quot;Session file&quot;), sessionExt.c_str());
1852  			fDlg.setDefExt(ext);
1853  		}
1854  		fDlg.setExtFilter(TEXT(&quot;All types&quot;), TEXT(&quot;.*&quot;));
1855  		sessionFileName = fDlg.doOpenSingleFileDlg();
1856  	}
1857  	else
1858  	{
1859  		if (PathFileExists(fn))
1860  			sessionFileName = fn;
1861  	}
1862  	NppParameters&amp; nppParam = NppParameters::getInstance();
1863  	const NppGUI &amp; nppGUI = nppParam.getNppGUI();
1864  	if (!sessionFileName.empty())
1865  	{
1866  		bool isEmptyNpp = false;
1867  		if (_mainDocTab.nbItem() == 1 &amp;&amp; _subDocTab.nbItem() == 1)
1868  		{
1869  			Buffer * buf1 = MainFileManager.getBufferByID(_mainDocTab.getBufferByIndex(0));
1870  			Buffer * buf2 = MainFileManager.getBufferByID(_subDocTab.getBufferByIndex(0));
1871  			isEmptyNpp = (!buf1-&gt;isDirty() &amp;&amp; buf1-&gt;isUntitled() &amp;&amp; !buf2-&gt;isDirty() &amp;&amp; buf2-&gt;isUntitled());
1872  		}
1873  		if (!isEmptyNpp &amp;&amp; (nppGUI._multiInstSetting == multiInstOnSession || nppGUI._multiInstSetting == multiInst))
1874  		{
1875  			TCHAR nppFullPath[MAX_PATH];
1876  			::GetModuleFileName(NULL, nppFullPath, MAX_PATH);
1877  			generic_string args = TEXT(&quot;-multiInst -nosession -openSession &quot;);
1878  			args += TEXT(&quot;\&quot;&quot;);
1879  			args += sessionFileName;
1880  			args += TEXT(&quot;\&quot;&quot;);
1881  			::ShellExecute(_pPublicInterface-&gt;getHSelf(), TEXT(&quot;open&quot;), nppFullPath, args.c_str(), TEXT(&quot;.&quot;), SW_SHOW);
1882  			result = true;
1883  		}
1884  		else
1885  		{
1886  			bool isAllSuccessful = true;
1887  			Session session2Load;
1888  			if (nppParam.loadSession(session2Load, sessionFileName.c_str()))
1889  			{
1890  				const bool isSnapshotMode = false;
1891  				const bool shouldLoadFileBrowser = true;
1892  				isAllSuccessful = loadSession(session2Load, isSnapshotMode, shouldLoadFileBrowser);
1893  				result = true;
1894  				if (isEmptyNpp &amp;&amp; (nppGUI._multiInstSetting == multiInstOnSession || nppGUI._multiInstSetting == multiInst))
1895  					nppParam.setLoadedSessionFilePath(sessionFileName);
1896  			}
1897  			if (!isAllSuccessful)
1898  				nppParam.writeSession(session2Load, sessionFileName.c_str());
1899  		}
1900  		if (result == false)
1901  		{
1902  			_nativeLangSpeaker.messageBox(&quot;SessionFileInvalidError&quot;,
1903  				NULL,
1904  				TEXT(&quot;Session file is either corrupted or not valid.&quot;),
1905  				TEXT(&quot;Could not Load Session&quot;),
1906  				MB_OK);
1907  		}
1908  	}
1909  	return result;
1910  }
1911  const TCHAR * Notepad_plus::fileSaveSession(size_t nbFile, TCHAR ** fileNames, const TCHAR *sessionFile2save, bool includeFileBrowser)
1912  {
1913  	if (sessionFile2save)
1914  	{
1915  		Session currentSession;
1916  		if ((nbFile) &amp;&amp; (fileNames))
1917  		{
1918  			for (size_t i = 0 ; i &lt; nbFile ; ++i)
1919  			{
1920  				if (PathFileExists(fileNames[i]))
1921  					currentSession._mainViewFiles.push_back(generic_string(fileNames[i]));
1922  			}
1923  		}
1924  		else
1925  			getCurrentOpenedFiles(currentSession);
1926  		currentSession._includeFileBrowser = includeFileBrowser;
1927  		if (includeFileBrowser &amp;&amp; _pFileBrowser &amp;&amp; !_pFileBrowser-&gt;isClosed())
1928  		{
1929  			currentSession._fileBrowserSelectedItem = _pFileBrowser-&gt;getSelectedItemPath();
1930  			for (auto&amp;&amp; rootFileName : _pFileBrowser-&gt;getRoots())
1931  			{
1932  				currentSession._fileBrowserRoots.push_back({ rootFileName });
1933  			}
1934  		}
1935  		(NppParameters::getInstance()).writeSession(currentSession, sessionFile2save);
1936  		return sessionFile2save;
1937  	}
1938  	return NULL;
1939  }
1940  const TCHAR * Notepad_plus::fileSaveSession(size_t nbFile, TCHAR ** fileNames)
1941  {
1942  	CustomFileDialog fDlg(_pPublicInterface-&gt;getHSelf());
1943  	const TCHAR *ext = NppParameters::getInstance().getNppGUI()._definedSessionExt.c_str();
1944  	generic_string sessionExt = TEXT(&quot;&quot;);
1945  	if (*ext != &#x27;\0&#x27;)
1946  	{
1947  		if (*ext != &#x27;.&#x27;)
1948  			sessionExt += TEXT(&quot;.&quot;);
1949  		sessionExt += ext;
1950  		fDlg.setExtFilter(TEXT(&quot;Session file&quot;), sessionExt.c_str());
1951  		fDlg.setDefExt(ext);
1952  		fDlg.setExtIndex(0);		
1953  	}
1954  	fDlg.setExtFilter(TEXT(&quot;All types&quot;), TEXT(&quot;.*&quot;));
1955  	const bool isCheckboxActive = _pFileBrowser &amp;&amp; !_pFileBrowser-&gt;isClosed();
1956  	const generic_string checkboxLabel = _nativeLangSpeaker.getLocalizedStrFromID(&quot;session-save-folder-as-workspace&quot;,
1957  		TEXT(&quot;Save Folder as Workspace&quot;));
1958  	fDlg.setCheckbox(checkboxLabel.c_str(), isCheckboxActive);
1959  	generic_string sessionFileName = fDlg.doSaveDlg();
1960  	return fileSaveSession(nbFile, fileNames, sessionFileName.c_str(), fDlg.getCheckboxState());
1961  }
1962  void Notepad_plus::saveSession(const Session &amp; session)
1963  {
1964  	(NppParameters::getInstance()).writeSession(session);
1965  }
1966  void Notepad_plus::saveCurrentSession()
1967  {
1968  	::SendMessage(_pPublicInterface-&gt;getHSelf(), NPPM_INTERNAL_SAVECURRENTSESSION, 0, 0);
1969  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-helpers.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppIO.cpp</div>
                </div>
                <div class="column column_space"><pre><code>68      return lower_bound;
69    }
70    if (x &gt; upper_bound) {
71      return upper_bound;
72    }
73    return x;
</pre></code></div>
                <div class="column column_space"><pre><code>152  			return BUFFER_INVALID;
153  		}
154  		if (getFullPathNameResult &gt; longFileNameBufferSize)
155  		{
156  			return BUFFER_INVALID;
157  		}
158  		assert(wcslen(longFileName) == getFullPathNameResult);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    