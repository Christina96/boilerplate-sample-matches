
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.7739251040221915%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-numpy.cpp</h3>
            <pre><code>1  namespace TSnap {
<span onclick='openModal()' class='match'>2  void TIntVToNumpy(TIntV& IntV, int* IntNumpyVecOut, int n) {
3  		int limit = MIN(IntV.Len(), n);
4      for (int i=0; i < limit; i++) {
</span>5          IntNumpyVecOut[i] = IntV[i];
6  		}
7  }
8  void TFltVToNumpy(TFltV& FltV, float* FltNumpyVecOut, int n) {
9  		int limit = MIN(FltV.Len(), n);
10      for (int i=0; i < limit; i++) {
11          FltNumpyVecOut[i] = static_cast<float>(FltV[i]);
12  		}
13  }
14  void NumpyToTIntV(TIntV& IntV, int* IntNumpyVecIn, int n) {
15  		for (int i = 0; i < n; ++i) {
16  				IntV[i] = IntNumpyVecIn[i];
17  		}
18  }
19  void NumpyToTFltV(TFltV& FltV, float* FltNumpyVecIn, int n) {
20  		for (int i = 0; i < n; ++i) {
21  				FltV[i] = FltNumpyVecIn[i];
22  		}
23  }
24  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-imagedata.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "imagedata.h"
5  #include "boxread.h"    
6  #include "rect.h"       
7  #include "scrollview.h" 
8  #include "tprintf.h"    
9  #include "helpers.h"  
10  #include "serialis.h" 
11  #include <allheaders.h> 
12  #include <cinttypes> 
13  namespace tesseract {
14  const int kMaxReadAhead = 8;
15  ImageData::ImageData() : page_number_(-1), vertical_text_(false) {}
16  ImageData::ImageData(bool vertical, Image pix)
17      : page_number_(0), vertical_text_(vertical) {
18    SetPix(pix);
19  }
20  ImageData::~ImageData() {
21  #ifdef TESSERACT_IMAGEDATA_AS_PIX
22    internal_pix_.destroy();
23  #endif
24  }
25  ImageData *ImageData::Build(const char *name, int page_number, const char *lang,
26                              const char *imagedata, int imagedatasize,
27                              const char *truth_text, const char *box_text) {
28    auto *image_data = new ImageData();
29    image_data->imagefilename_ = name;
30    image_data->page_number_ = page_number;
31    image_data->language_ = lang;
32    image_data->image_data_.resize(imagedatasize);
33    memcpy(&image_data->image_data_[0], imagedata, imagedatasize);
34    if (!image_data->AddBoxes(box_text)) {
35      if (truth_text == nullptr || truth_text[0] == '\0') {
36        tprintf("Error: No text corresponding to page %d from image %s!\n",
37                page_number, name);
38        delete image_data;
39        return nullptr;
40      }
41      image_data->transcription_ = truth_text;
42      image_data->box_texts_.emplace_back(truth_text);
43    } else if (truth_text != nullptr && truth_text[0] != '\0' &&
44               image_data->transcription_ != truth_text) {
45      image_data->transcription_ = truth_text;
46    }
47    return image_data;
48  }
49  bool ImageData::Serialize(TFile *fp) const {
50    if (!fp->Serialize(imagefilename_)) {
51      return false;
52    }
53    if (!fp->Serialize(&page_number_)) {
54      return false;
55    }
56    if (!fp->Serialize(image_data_)) {
57      return false;
58    }
59    if (!fp->Serialize(language_)) {
60      return false;
61    }
62    if (!fp->Serialize(transcription_)) {
63      return false;
64    }
65    if (!fp->Serialize(boxes_)) {
66      return false;
67    }
68    if (!fp->Serialize(box_texts_)) {
69      return false;
70    }
71    int8_t vertical = vertical_text_;
72    return fp->Serialize(&vertical);
73  }
74  bool ImageData::DeSerialize(TFile *fp) {
75    if (!fp->DeSerialize(imagefilename_)) {
76      return false;
77    }
78    if (!fp->DeSerialize(&page_number_)) {
79      return false;
80    }
81    if (!fp->DeSerialize(image_data_)) {
82      return false;
83    }
84    if (!fp->DeSerialize(language_)) {
85      return false;
86    }
87    if (!fp->DeSerialize(transcription_)) {
88      return false;
89    }
90    if (!fp->DeSerialize(boxes_)) {
91      return false;
92    }
93    if (!fp->DeSerialize(box_texts_)) {
94      return false;
95    }
96    int8_t vertical = 0;
97    if (!fp->DeSerialize(&vertical)) {
98      return false;
99    }
100    vertical_text_ = vertical != 0;
101    return true;
102  }
103  bool ImageData::SkipDeSerialize(TFile *fp) {
104    if (!fp->DeSerializeSkip()) {
105      return false;
106    }
107    int32_t page_number;
108    if (!fp->DeSerialize(&page_number)) {
109      return false;
110    }
111    if (!fp->DeSerializeSkip()) {
112      return false;
113    }
114    if (!fp->DeSerializeSkip()) {
115      return false;
116    }
117    if (!fp->DeSerializeSkip()) {
118      return false;
119    }
120    if (!fp->DeSerializeSkip(sizeof(TBOX))) {
121      return false;
122    }
123    int32_t number;
124    if (!fp->DeSerialize(&number)) {
125      return false;
126    }
127    for (int i = 0; i < number; i++) {
128      if (!fp->DeSerializeSkip()) {
129        return false;
130      }
131    }
132    int8_t vertical = 0;
133    return fp->DeSerialize(&vertical);
134  }
135  void ImageData::SetPix(Image pix) {
136  #ifdef TESSERACT_IMAGEDATA_AS_PIX
137    internal_pix_ = pix;
138  #else
139    SetPixInternal(pix, &image_data_);
140  #endif
141  }
142  Image ImageData::GetPix() const {
143  #ifdef TESSERACT_IMAGEDATA_AS_PIX
144  #  ifdef GRAPHICS_DISABLED
145    return internal_pix_.clone();
146  #  else
147    return internal_pix_.copy();
148  #  endif
149  #else
150    return GetPixInternal(image_data_);
151  #endif
152  }
153  Image ImageData::PreScale(int target_height, int max_height,
154                            float *scale_factor, int *scaled_width,
155                            int *scaled_height, std::vector<TBOX> *boxes) const {
156    int input_width = 0;
157    int input_height = 0;
158    Image src_pix = GetPix();
159    ASSERT_HOST(src_pix != nullptr);
160    input_width = pixGetWidth(src_pix);
161    input_height = pixGetHeight(src_pix);
162    if (target_height == 0) {
163      target_height = std::min(input_height, max_height);
164    }
165    float im_factor = static_cast<float>(target_height) / input_height;
166    if (scaled_width != nullptr) {
167      *scaled_width = IntCastRounded(im_factor * input_width);
168    }
169    if (scaled_height != nullptr) {
170      *scaled_height = target_height;
171    }
172    Image pix = pixScale(src_pix, im_factor, im_factor);
173    if (pix == nullptr) {
174      tprintf("Scaling pix of size %d, %d by factor %g made null pix!!\n",
175              input_width, input_height, im_factor);
176      src_pix.destroy();
177      return nullptr;
178    }
179    if (scaled_width != nullptr) {
180      *scaled_width = pixGetWidth(pix);
181    }
182    if (scaled_height != nullptr) {
183      *scaled_height = pixGetHeight(pix);
184    }
185    src_pix.destroy();
186    if (boxes != nullptr) {
187      boxes->clear();
188      for (auto box : boxes_) {
189        box.scale(im_factor);
190        boxes->push_back(box);
191      }
192      if (boxes->empty()) {
193        TBOX box(0, 0, im_factor * input_width, target_height);
194        boxes->push_back(box);
195      }
196    }
197    if (scale_factor != nullptr) {
198      *scale_factor = im_factor;
199    }
200    return pix;
201  }
202  int ImageData::MemoryUsed() const {
203    return image_data_.size();
204  }
205  #ifndef GRAPHICS_DISABLED
206  void ImageData::Display() const {
207    const int kTextSize = 64;
208    Image pix = GetPix();
209    if (pix == nullptr) {
210      return;
211    }
212    int width = pixGetWidth(pix);
213    int height = pixGetHeight(pix);
214    auto *win = new ScrollView("Imagedata", 100, 100, 2 * (width + 2 * kTextSize),
215                               2 * (height + 4 * kTextSize), width + 10,
216                               height + 3 * kTextSize, true);
217    win->Draw(pix, 0, height - 1);
218    pix.destroy();
219    win->Pen(ScrollView::RED);
220    win->Brush(ScrollView::NONE);
221    int text_size = kTextSize;
222    if (!boxes_.empty() && boxes_[0].height() * 2 < text_size) {
223      text_size = boxes_[0].height() * 2;
224    }
225    win->TextAttributes("Arial", text_size, false, false, false);
226    if (!boxes_.empty()) {
227      for (unsigned b = 0; b < boxes_.size(); ++b) {
228        boxes_[b].plot(win);
229        win->Text(boxes_[b].left(), height + kTextSize, box_texts_[b].c_str());
230      }
231    } else {
232      win->Pen(ScrollView::CYAN);
233      win->Text(0, height + kTextSize * 2, transcription_.c_str());
234    }
235    win->Update();
236    win->Wait();
237  }
238  #endif
239  void ImageData::AddBoxes(const std::vector<TBOX> &boxes,
240                           const std::vector<std::string> &texts,
241                           const std::vector<int> &box_pages) {
242    for (unsigned i = 0; i < box_pages.size(); ++i) {
243      if (page_number_ >= 0 && box_pages[i] != page_number_) {
244        continue;
245      }
246      transcription_ += texts[i];
247      boxes_.push_back(boxes[i]);
248      box_texts_.push_back(texts[i]);
249    }
250  }
251  #ifndef TESSERACT_IMAGEDATA_AS_PIX
252  void ImageData::SetPixInternal(Image pix, std::vector<char> *image_data) {
253    l_uint8 *data;
254    size_t size;
255    l_int32 ret;
256    ret = pixWriteMem(&data, &size, pix, IFF_PNG);
257    if (ret) {
258      ret = pixWriteMem(&data, &size, pix, IFF_PNM);
259    }
260    pix.destroy();
261    image_data->resize(size);
262    memcpy(&(*image_data)[0], data, size);
263    lept_free(data);
264  }
265  Image ImageData::GetPixInternal(const std::vector<char> &image_data) {
266    Image pix = nullptr;
267    if (!image_data.empty()) {
268      const auto *u_data =
269          reinterpret_cast<const unsigned char *>(&image_data[0]);
270      pix = pixReadMem(u_data, image_data.size());
271    }
272    return pix;
273  }
274  #endif
275  bool ImageData::AddBoxes(const char *box_text) {
276    if (box_text != nullptr && box_text[0] != '\0') {
277      std::vector<TBOX> boxes;
278      std::vector<std::string> texts;
279      std::vector<int> box_pages;
280      if (ReadMemBoxes(page_number_, &bsol;*skip_blanks*/ false, box_text,
281                        true, &boxes, &texts, nullptr,
282                       &box_pages)) {
283        AddBoxes(boxes, texts, box_pages);
284        return true;
285      } else {
286        tprintf("Error: No boxes for page %d from image %s!\n", page_number_,
287                imagefilename_.c_str());
288      }
289    }
290    return false;
291  }
292  DocumentData::DocumentData(const std::string &name)
293      : document_name_(name),
294        pages_offset_(-1),
295        total_pages_(-1),
296        memory_used_(0),
297        max_memory_(0),
298        reader_(nullptr) {}
299  DocumentData::~DocumentData() {
300    if (thread.joinable()) {
301      thread.join();
302    }
303    std::lock_guard<std::mutex> lock_p(pages_mutex_);
304    std::lock_guard<std::mutex> lock_g(general_mutex_);
305    for (auto data : pages_) {
306      delete data;
307    }
308  }
309  bool DocumentData::LoadDocument(const char *filename, int start_page,
310                                  int64_t max_memory, FileReader reader) {
311    SetDocument(filename, max_memory, reader);
312    pages_offset_ = start_page;
313    return ReCachePages();
314  }
315  void DocumentData::SetDocument(const char *filename, int64_t max_memory,
316                                 FileReader reader) {
317    std::lock_guard<std::mutex> lock_p(pages_mutex_);
318    std::lock_guard<std::mutex> lock(general_mutex_);
319    document_name_ = filename;
320    pages_offset_ = -1;
321    max_memory_ = max_memory;
322    reader_ = reader;
323  }
324  bool DocumentData::SaveDocument(const char *filename, FileWriter writer) {
325    std::lock_guard<std::mutex> lock(pages_mutex_);
326    TFile fp;
327    fp.OpenWrite(nullptr);
328    if (!fp.Serialize(pages_) || !fp.CloseWrite(filename, writer)) {
329      tprintf("Serialize failed: %s\n", filename);
330      return false;
331    }
332    return true;
333  }
334  void DocumentData::AddPageToDocument(ImageData *page) {
335    std::lock_guard<std::mutex> lock(pages_mutex_);
336    pages_.push_back(page);
337    set_memory_used(memory_used() + page->MemoryUsed());
338  }
339  void DocumentData::LoadPageInBackground(int index) {
340    ImageData *page = nullptr;
341    if (IsPageAvailable(index, &page)) {
342      return;
343    }
344    {
345      std::lock_guard<std::mutex> lock(pages_mutex_);
346      if (pages_offset_ == index) {
347        return;
348      }
349      pages_offset_ = index;
350      for (auto page : pages_) {
351        delete page;
352      }
353      pages_.clear();
354    }
355    if (thread.joinable()) {
356      thread.join();
357    }
358    ReCachePages();
359  }
360  const ImageData *DocumentData::GetPage(int index) {
361    ImageData *page = nullptr;
362    while (!IsPageAvailable(index, &page)) {
363      pages_mutex_.lock();
364      bool needs_loading = pages_offset_ != index;
365      pages_mutex_.unlock();
366      if (needs_loading) {
367        LoadPageInBackground(index);
368      }
369      std::this_thread::yield();
370    }
371    return page;
372  }
373  bool DocumentData::IsPageAvailable(int index, ImageData **page) {
374    std::lock_guard<std::mutex> lock(pages_mutex_);
375    int num_pages = NumPages();
376    if (num_pages == 0 || index < 0) {
377      *page = nullptr; 
378      return true;
379    }
380    if (num_pages > 0) {
381      index = Modulo(index, num_pages);
382      if (pages_offset_ <= index &&
383          static_cast<unsigned>(index) < pages_offset_ + pages_.size()) {
384        *page = pages_[index - pages_offset_]; 
385        return true;
386      }
387    }
388    return false;
389  }
390  int64_t DocumentData::UnCache() {
391    std::lock_guard<std::mutex> lock(pages_mutex_);
392    int64_t memory_saved = memory_used();
393    for (auto page : pages_) {
394      delete page;
395    }
396    pages_.clear();
397    pages_offset_ = -1;
398    set_total_pages(-1);
399    set_memory_used(0);
400    tprintf("Unloaded document %s, saving %" PRId64 " memory\n",
401            document_name_.c_str(), memory_saved);
402    return memory_saved;
403  }
404  void DocumentData::Shuffle() {
405    TRand random;
406    random.set_seed(document_name_.c_str());
407    int num_pages = pages_.size();
408    for (int i = 0; i < num_pages; ++i) {
409      int src = random.IntRand() % num_pages;
410      int dest = random.IntRand() % num_pages;
411      std::swap(pages_[src], pages_[dest]);
412    }
413  }
414  bool DocumentData::ReCachePages() {
415    std::lock_guard<std::mutex> lock(pages_mutex_);
416    set_total_pages(0);
417    set_memory_used(0);
418    int loaded_pages = 0;
419    for (auto page : pages_) {
420      delete page;
421    }
422    pages_.clear();
423    TFile fp;
424    if (!fp.Open(document_name_.c_str(), reader_) ||
425        !fp.DeSerializeSize(&loaded_pages) || loaded_pages <= 0) {
426      tprintf("Deserialize header failed: %s\n", document_name_.c_str());
427      return false;
428    }
429    pages_offset_ %= loaded_pages;
430    int page;
431    for (page = 0; page < loaded_pages; ++page) {
432      uint8_t non_null;
433      if (!fp.DeSerialize(&non_null)) {
434        break;
435      }
436      if (page < pages_offset_ ||
437          (max_memory_ > 0 && memory_used() > max_memory_)) {
438        if (non_null && !ImageData::SkipDeSerialize(&fp)) {
439          break;
440        }
441      } else {
442        ImageData *image_data = nullptr;
443        if (non_null) {
444          image_data = new ImageData;
445          if (!image_data->DeSerialize(&fp)) {
446            delete image_data;
447            break;
448          }
449        }
450        pages_.push_back(image_data);
451        if (image_data->imagefilename().empty()) {
452          image_data->set_imagefilename(document_name_);
453          image_data->set_page_number(page);
454        }
455        set_memory_used(memory_used() + image_data->MemoryUsed());
456      }
457    }
458    if (page < loaded_pages) {
459      tprintf("Deserialize failed: %s read %d/%d lines\n", document_name_.c_str(),
460              page, loaded_pages);
461      for (auto page : pages_) {
462        delete page;
463      }
464      pages_.clear();
465    } else if (loaded_pages > 1) {
466      tprintf("Loaded %zu/%d lines (%d-%zu) of document %s\n", pages_.size(),
467              loaded_pages, pages_offset_ + 1, pages_offset_ + pages_.size(),
468              document_name_.c_str());
469    }
470    set_total_pages(loaded_pages);
471    return !pages_.empty();
472  }
473  DocumentCache::DocumentCache(int64_t max_memory) : max_memory_(max_memory) {}
474  DocumentCache::~DocumentCache() {
475    for (auto *document : documents_) {
476      delete document;
477    }
478  }
479  bool DocumentCache::LoadDocuments(const std::vector<std::string> &filenames,
480                                    CachingStrategy cache_strategy,
481                                    FileReader reader) {
482    cache_strategy_ = cache_strategy;
483    int64_t fair_share_memory = 0;
484    if (cache_strategy_ == CS_ROUND_ROBIN) {
485      fair_share_memory = max_memory_ / filenames.size();
486    }
487    for (const auto &filename : filenames) {
488      auto *document = new DocumentData(filename);
489      document->SetDocument(filename.c_str(), fair_share_memory, reader);
490      AddToCache(document);
491    }
492    if (!documents_.empty()) {
493      if (GetPageBySerial(0) != nullptr) {
494        return true;
495      }
496      tprintf("Load of page 0 failed!\n");
497    }
498    return false;
499  }
500  bool DocumentCache::AddToCache(DocumentData *data) {
501    documents_.push_back(data);
502    return true;
503  }
504  DocumentData *DocumentCache::FindDocument(
505      const std::string &document_name) const {
506    for (auto *document : documents_) {
507      if (document->document_name() == document_name) {
508        return document;
509      }
510    }
511    return nullptr;
512  }
513  int DocumentCache::TotalPages() {
514    if (cache_strategy_ == CS_SEQUENTIAL) {
515      if (num_pages_per_doc_ == 0) {
516        GetPageSequential(0);
517      }
518      return num_pages_per_doc_ * documents_.size();
519    }
520    int total_pages = 0;
521    for (auto *document : documents_) {
522      document->GetPage(0);
523      total_pages += document->NumPages();
524    }
525    return total_pages;
526  }
527  const ImageData *DocumentCache::GetPageRoundRobin(int serial) {
528    int num_docs = documents_.size();
529    int doc_index = serial % num_docs;
530    const ImageData *doc = documents_[doc_index]->GetPage(serial / num_docs);
531    for (int offset = 1; offset <= kMaxReadAhead && offset < num_docs; ++offset) {
532      doc_index = (serial + offset) % num_docs;
533      int page = (serial + offset) / num_docs;
534      documents_[doc_index]->LoadPageInBackground(page);
535    }
536    return doc;
537  }
538  const ImageData *DocumentCache::GetPageSequential(int serial) {
539    int num_docs = documents_.size();
540    ASSERT_HOST(num_docs > 0);
541    if (num_pages_per_doc_ == 0) {
542      documents_[0]->GetPage(0);
543      num_pages_per_doc_ = documents_[0]->NumPages();
544      if (num_pages_per_doc_ == 0) {
545        tprintf("First document cannot be empty!!\n");
546        ASSERT_HOST(num_pages_per_doc_ > 0);
547      }
548      if (serial / num_pages_per_doc_ % num_docs > 0) {
549        documents_[0]->UnCache();
550      }
551    }
552    int doc_index = serial / num_pages_per_doc_ % num_docs;
553    const ImageData *doc =
554        documents_[doc_index]->GetPage(serial % num_pages_per_doc_);
555    int64_t total_memory = 0;
556    for (auto *document : documents_) {
557      total_memory += document->memory_used();
558    }
559    if (total_memory >= max_memory_) {
560      int num_in_front = CountNeighbourDocs(doc_index, 1);
561      for (int offset = num_in_front - 2;
562           offset > 1 && total_memory >= max_memory_; --offset) {
563        int next_index = (doc_index + offset) % num_docs;
564        total_memory -= documents_[next_index]->UnCache();
565      }
566      int num_behind = CountNeighbourDocs(doc_index, -1);
567      for (int offset = num_behind; offset < 0 && total_memory >= max_memory_;
568           ++offset) {
569        int next_index = (doc_index + offset + num_docs) % num_docs;
570        total_memory -= documents_[next_index]->UnCache();
571      }
572    }
573    int next_index = (doc_index + 1) % num_docs;
574    if (!documents_[next_index]->IsCached() && total_memory < max_memory_) {
575      documents_[next_index]->LoadPageInBackground(0);
576    }
577    return doc;
578  }
<span onclick='openModal()' class='match'>579  int DocumentCache::CountNeighbourDocs(int index, int dir) {
580    int num_docs = documents_.size();
581    for (int offset = dir; abs(offset) < num_docs; offset += dir) {
</span>582      int offset_index = (index + offset + num_docs) % num_docs;
583      if (!documents_[offset_index]->IsCached()) {
584        return offset - dir;
585      }
586    }
587    return num_docs;
588  }
589  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-numpy.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-imagedata.cpp</div>
                </div>
                <div class="column column_space"><pre><code>2  void TIntVToNumpy(TIntV& IntV, int* IntNumpyVecOut, int n) {
3  		int limit = MIN(IntV.Len(), n);
4      for (int i=0; i < limit; i++) {
</pre></code></div>
                <div class="column column_space"><pre><code>579  int DocumentCache::CountNeighbourDocs(int index, int dir) {
580    int num_docs = documents_.size();
581    for (int offset = dir; abs(offset) < num_docs; offset += dir) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    