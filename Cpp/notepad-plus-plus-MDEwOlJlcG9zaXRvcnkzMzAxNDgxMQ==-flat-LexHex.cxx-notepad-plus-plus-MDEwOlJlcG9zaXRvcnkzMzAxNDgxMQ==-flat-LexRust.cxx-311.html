
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHex.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Scintilla.h&quot;
11  #include &quot;SciLexer.h&quot;
12  #include &quot;WordList.h&quot;
13  #include &quot;LexAccessor.h&quot;
14  #include &quot;Accessor.h&quot;
15  #include &quot;StyleContext.h&quot;
16  #include &quot;CharacterSet.h&quot;
17  #include &quot;LexerModule.h&quot;
18  using namespace Lexilla;
19  static inline bool IsNewline(const int ch);
20  static int GetHexaNibble(char hd);
21  static int GetHexaChar(char hd1, char hd2);
22  static int GetHexaChar(Sci_PositionU pos, Accessor &amp;styler);
23  static bool ForwardWithinLine(StyleContext &amp;sc, Sci_Position nb = 1);
24  static bool PosInSameRecord(Sci_PositionU pos1, Sci_PositionU pos2, Accessor &amp;styler);
25  static Sci_Position CountByteCount(Sci_PositionU startPos, Sci_Position uncountedDigits, Accessor &amp;styler);
26  static int CalcChecksum(Sci_PositionU startPos, Sci_Position cnt, bool twosCompl, Accessor &amp;styler);
27  static Sci_PositionU GetSrecRecStartPosition(Sci_PositionU pos, Accessor &amp;styler);
28  static int GetSrecByteCount(Sci_PositionU recStartPos, Accessor &amp;styler);
29  static Sci_Position CountSrecByteCount(Sci_PositionU recStartPos, Accessor &amp;styler);
30  static int GetSrecAddressFieldSize(Sci_PositionU recStartPos, Accessor &amp;styler);
31  static int GetSrecAddressFieldType(Sci_PositionU recStartPos, Accessor &amp;styler);
32  static int GetSrecDataFieldType(Sci_PositionU recStartPos, Accessor &amp;styler);
33  static Sci_Position GetSrecRequiredDataFieldSize(Sci_PositionU recStartPos, Accessor &amp;styler);
34  static int GetSrecChecksum(Sci_PositionU recStartPos, Accessor &amp;styler);
35  static int CalcSrecChecksum(Sci_PositionU recStartPos, Accessor &amp;styler);
36  static Sci_PositionU GetIHexRecStartPosition(Sci_PositionU pos, Accessor &amp;styler);
37  static int GetIHexByteCount(Sci_PositionU recStartPos, Accessor &amp;styler);
38  static Sci_Position CountIHexByteCount(Sci_PositionU recStartPos, Accessor &amp;styler);
39  static int GetIHexAddressFieldType(Sci_PositionU recStartPos, Accessor &amp;styler);
40  static int GetIHexDataFieldType(Sci_PositionU recStartPos, Accessor &amp;styler);
41  static int GetIHexRequiredDataFieldSize(Sci_PositionU recStartPos, Accessor &amp;styler);
42  static int GetIHexChecksum(Sci_PositionU recStartPos, Accessor &amp;styler);
43  static int CalcIHexChecksum(Sci_PositionU recStartPos, Accessor &amp;styler);
44  static int GetTEHexDigitCount(Sci_PositionU recStartPos, Accessor &amp;styler);
45  static Sci_Position CountTEHexDigitCount(Sci_PositionU recStartPos, Accessor &amp;styler);
46  static int GetTEHexAddressFieldType(Sci_PositionU recStartPos, Accessor &amp;styler);
47  static int GetTEHexChecksum(Sci_PositionU recStartPos, Accessor &amp;styler);
48  static int CalcTEHexChecksum(Sci_PositionU recStartPos, Accessor &amp;styler);
49  static inline bool IsNewline(const int ch)
50  {
51      return (ch == &#x27;\n&#x27; || ch == &#x27;\r&#x27;);
52  }
53  static int GetHexaNibble(char hd)
54  {
55  	int hexValue = 0;
56  	if (hd &gt;= &#x27;0&#x27; &amp;&amp; hd &lt;= &#x27;9&#x27;) {
57  		hexValue += hd - &#x27;0&#x27;;
58  	} else if (hd &gt;= &#x27;A&#x27; &amp;&amp; hd &lt;= &#x27;F&#x27;) {
59  		hexValue += hd - &#x27;A&#x27; + 10;
60  	} else if (hd &gt;= &#x27;a&#x27; &amp;&amp; hd &lt;= &#x27;f&#x27;) {
61  		hexValue += hd - &#x27;a&#x27; + 10;
62  	} else {
63  		return -1;
64  	}
65  	return hexValue;
66  }
67  static int GetHexaChar(char hd1, char hd2)
68  {
69  	int hexValue = 0;
70  	if (hd1 &gt;= &#x27;0&#x27; &amp;&amp; hd1 &lt;= &#x27;9&#x27;) {
71  		hexValue += 16 * (hd1 - &#x27;0&#x27;);
72  	} else if (hd1 &gt;= &#x27;A&#x27; &amp;&amp; hd1 &lt;= &#x27;F&#x27;) {
73  		hexValue += 16 * (hd1 - &#x27;A&#x27; + 10);
74  	} else if (hd1 &gt;= &#x27;a&#x27; &amp;&amp; hd1 &lt;= &#x27;f&#x27;) {
75  		hexValue += 16 * (hd1 - &#x27;a&#x27; + 10);
76  	} else {
77  		return -1;
78  	}
79  	if (hd2 &gt;= &#x27;0&#x27; &amp;&amp; hd2 &lt;= &#x27;9&#x27;) {
80  		hexValue += hd2 - &#x27;0&#x27;;
81  	} else if (hd2 &gt;= &#x27;A&#x27; &amp;&amp; hd2 &lt;= &#x27;F&#x27;) {
82  		hexValue += hd2 - &#x27;A&#x27; + 10;
83  	} else if (hd2 &gt;= &#x27;a&#x27; &amp;&amp; hd2 &lt;= &#x27;f&#x27;) {
84  		hexValue += hd2 - &#x27;a&#x27; + 10;
85  	} else {
86  		return -1;
87  	}
88  	return hexValue;
89  }
90  static int GetHexaChar(Sci_PositionU pos, Accessor &amp;styler)
91  {
92  	char highNibble, lowNibble;
93  	highNibble = styler.SafeGetCharAt(pos);
94  	lowNibble = styler.SafeGetCharAt(pos + 1);
95  	return GetHexaChar(highNibble, lowNibble);
96  }
97  static bool ForwardWithinLine(StyleContext &amp;sc, Sci_Position nb)
98  {
99  	for (Sci_Position i = 0; i &lt; nb; i++) {
100  		if (sc.atLineEnd) {
101  			sc.SetState(SCE_HEX_DEFAULT);
102  			sc.Forward();
103  			return false;
104  		} else {
105  			sc.Forward();
106  		}
107  	}
108  	return true;
109  }
110  static bool PosInSameRecord(Sci_PositionU pos1, Sci_PositionU pos2, Accessor &amp;styler)
111  {
112  	return styler.GetLine(pos1) == styler.GetLine(pos2);
113  }
114  static Sci_Position CountByteCount(Sci_PositionU startPos, Sci_Position uncountedDigits, Accessor &amp;styler)
115  {
116  	Sci_Position cnt;
117  	Sci_PositionU pos;
118  	pos = startPos;
119  	while (!IsNewline(styler.SafeGetCharAt(pos, &#x27;\n&#x27;))) {
120  		pos++;
121  	}
122  	cnt = static_cast&lt;Sci_Position&gt;(pos - startPos) - uncountedDigits;
123  	if (cnt &gt;= 0) {
124  		cnt++;
125  	}
126  	cnt /= 2;
127  	return cnt;
128  }
129  static int CalcChecksum(Sci_PositionU startPos, Sci_Position cnt, bool twosCompl, Accessor &amp;styler)
130  {
131  	int cs = 0;
132  	for (Sci_PositionU pos = startPos; pos &lt; startPos + cnt; pos += 2) {
133  		int val = GetHexaChar(pos, styler);
134  		if (val &lt; 0) {
135  			return val;
136  		}
137  		cs += val;
138  	}
139  	if (twosCompl) {
140  		return -cs &amp; 0xFF;
141  	} else {
142  		return ~cs &amp; 0xFF;
143  	}
144  }
145  static Sci_PositionU GetSrecRecStartPosition(Sci_PositionU pos, Accessor &amp;styler)
146  {
147  	while (styler.SafeGetCharAt(pos) != &#x27;S&#x27;) {
148  		pos--;
149  	}
150  	return pos;
151  }
152  static int GetSrecByteCount(Sci_PositionU recStartPos, Accessor &amp;styler)
153  {
154  	int val;
155  	val = GetHexaChar(recStartPos + 2, styler);
156  	if (val &lt; 0) {
157  	       val = 0;
158  	}
159  	return val;
160  }
161  static Sci_Position CountSrecByteCount(Sci_PositionU recStartPos, Accessor &amp;styler)
162  {
163  	return CountByteCount(recStartPos, 4, styler);
164  }
165  static int GetSrecAddressFieldSize(Sci_PositionU recStartPos, Accessor &amp;styler)
166  {
167  	switch (styler.SafeGetCharAt(recStartPos + 1)) {
168  		case &#x27;0&#x27;:
169  		case &#x27;1&#x27;:
170  		case &#x27;5&#x27;:
171  		case &#x27;9&#x27;:
172  			return 2; 
173  		case &#x27;2&#x27;:
174  		case &#x27;6&#x27;:
175  		case &#x27;8&#x27;:
176  			return 3; 
177  		case &#x27;3&#x27;:
178  		case &#x27;7&#x27;:
179  			return 4; 
180  		default:
181  			return 0;
182  	}
183  }
184  static int GetSrecAddressFieldType(Sci_PositionU recStartPos, Accessor &amp;styler)
185  {
186  	switch (styler.SafeGetCharAt(recStartPos + 1)) {
187  		case &#x27;0&#x27;:
188  			return SCE_HEX_NOADDRESS;
189  		case &#x27;1&#x27;:
190  		case &#x27;2&#x27;:
191  		case &#x27;3&#x27;:
192  			return SCE_HEX_DATAADDRESS;
193  		case &#x27;5&#x27;:
194  		case &#x27;6&#x27;:
195  			return SCE_HEX_RECCOUNT;
196  		case &#x27;7&#x27;:
197  		case &#x27;8&#x27;:
198  		case &#x27;9&#x27;:
199  			return SCE_HEX_STARTADDRESS;
200  		default: 
201  			return SCE_HEX_ADDRESSFIELD_UNKNOWN;
202  	}
203  }
204  static int GetSrecDataFieldType(Sci_PositionU recStartPos, Accessor &amp;styler)
205  {
206  	switch (styler.SafeGetCharAt(recStartPos + 1)) {
207  		case &#x27;0&#x27;:
208  		case &#x27;1&#x27;:
209  		case &#x27;2&#x27;:
210  		case &#x27;3&#x27;:
211  			return SCE_HEX_DATA_ODD;
212  		case &#x27;5&#x27;:
213  		case &#x27;6&#x27;:
214  		case &#x27;7&#x27;:
215  		case &#x27;8&#x27;:
216  		case &#x27;9&#x27;:
217  			return SCE_HEX_DATA_EMPTY;
218  		default: 
219  			return SCE_HEX_DATA_UNKNOWN;
220  	}
221  }
222  static Sci_Position GetSrecRequiredDataFieldSize(Sci_PositionU recStartPos, Accessor &amp;styler)
223  {
224  	switch (styler.SafeGetCharAt(recStartPos + 1)) {
225  		case &#x27;5&#x27;:
226  		case &#x27;6&#x27;:
227  		case &#x27;7&#x27;:
228  		case &#x27;8&#x27;:
229  		case &#x27;9&#x27;:
230  			return 0;
231  		default:
232  			return GetSrecByteCount(recStartPos, styler)
233  				- GetSrecAddressFieldSize(recStartPos, styler)
234  				- 1; 
235  	}
236  }
237  static int GetSrecChecksum(Sci_PositionU recStartPos, Accessor &amp;styler)
238  {
239  	int byteCount;
240  	byteCount = GetSrecByteCount(recStartPos, styler);
241  	return GetHexaChar(recStartPos + 2 + byteCount * 2, styler);
242  }
243  static int CalcSrecChecksum(Sci_PositionU recStartPos, Accessor &amp;styler)
244  {
245  	Sci_Position byteCount;
246  	byteCount = GetSrecByteCount(recStartPos, styler);
247  	return CalcChecksum(recStartPos + 2, byteCount * 2, false, styler);
248  }
249  static Sci_PositionU GetIHexRecStartPosition(Sci_PositionU pos, Accessor &amp;styler)
250  {
251  	while (styler.SafeGetCharAt(pos) != &#x27;:&#x27;) {
252  		pos--;
253  	}
254  	return pos;
255  }
256  static int GetIHexByteCount(Sci_PositionU recStartPos, Accessor &amp;styler)
257  {
258  	int val;
259  	val = GetHexaChar(recStartPos + 1, styler);
260  	if (val &lt; 0) {
261  	       val = 0;
262  	}
263  	return val;
264  }
265  static Sci_Position CountIHexByteCount(Sci_PositionU recStartPos, Accessor &amp;styler)
266  {
267  	return CountByteCount(recStartPos, 11, styler);
268  }
269  static int GetIHexAddressFieldType(Sci_PositionU recStartPos, Accessor &amp;styler)
270  {
271  	if (!PosInSameRecord(recStartPos, recStartPos + 7, styler)) {
272  		return SCE_HEX_ADDRESSFIELD_UNKNOWN;
273  	}
274  	switch (GetHexaChar(recStartPos + 7, styler)) {
275  		case 0x00:
276  			return SCE_HEX_DATAADDRESS;
277  		case 0x01:
278  		case 0x02:
279  		case 0x03:
280  		case 0x04:
281  		case 0x05:
282  			return SCE_HEX_NOADDRESS;
283  		default: 
284  			return SCE_HEX_ADDRESSFIELD_UNKNOWN;
285  	}
286  }
287  static int GetIHexDataFieldType(Sci_PositionU recStartPos, Accessor &amp;styler)
288  {
289  	switch (GetHexaChar(recStartPos + 7, styler)) {
290  		case 0x00:
291  			return SCE_HEX_DATA_ODD;
292  		case 0x01:
293  			return SCE_HEX_DATA_EMPTY;
294  		case 0x02:
295  		case 0x04:
296  			return SCE_HEX_EXTENDEDADDRESS;
297  		case 0x03:
298  		case 0x05:
299  			return SCE_HEX_STARTADDRESS;
300  		default: 
301  			return SCE_HEX_DATA_UNKNOWN;
302  	}
303  }
304  static int GetIHexRequiredDataFieldSize(Sci_PositionU recStartPos, Accessor &amp;styler)
305  {
306  	switch (GetHexaChar(recStartPos + 7, styler)) {
307  		case 0x01:
308  			return 0;
309  		case 0x02:
310  		case 0x04:
311  			return 2;
312  		case 0x03:
313  		case 0x05:
314  			return 4;
315  		default:
316  			return GetIHexByteCount(recStartPos, styler);
317  	}
318  }
319  static int GetIHexChecksum(Sci_PositionU recStartPos, Accessor &amp;styler)
320  {
321  	int byteCount;
322  	byteCount = GetIHexByteCount(recStartPos, styler);
323  	return GetHexaChar(recStartPos + 9 + byteCount * 2, styler);
324  }
325  static int CalcIHexChecksum(Sci_PositionU recStartPos, Accessor &amp;styler)
326  {
327  	int byteCount;
328  	byteCount = GetIHexByteCount(recStartPos, styler);
329  	return CalcChecksum(recStartPos + 1, 8 + byteCount * 2, true, styler);
330  }
331  static int GetTEHexDigitCount(Sci_PositionU recStartPos, Accessor &amp;styler)
332  {
333  	int val = GetHexaChar(recStartPos + 1, styler);
334  	if (val &lt; 0)
335  	       val = 0;
336  	return val;
337  }
338  static Sci_Position CountTEHexDigitCount(Sci_PositionU recStartPos, Accessor &amp;styler)
339  {
340  	Sci_PositionU pos;
341  	pos = recStartPos+1;
342  	while (!IsNewline(styler.SafeGetCharAt(pos, &#x27;\n&#x27;))) {
343  		pos++;
344  	}
345  	return static_cast&lt;Sci_Position&gt;(pos - (recStartPos+1));
346  }
347  static int GetTEHexAddressFieldType(Sci_PositionU recStartPos, Accessor &amp;styler)
348  {
349  	switch (styler.SafeGetCharAt(recStartPos + 3)) {
350  		case &#x27;6&#x27;:
351  			return SCE_HEX_DATAADDRESS;
352  		case &#x27;8&#x27;:
353  			return SCE_HEX_STARTADDRESS;
354  		default: 
355  			return SCE_HEX_ADDRESSFIELD_UNKNOWN;
356  	}
357  }
358  static int GetTEHexChecksum(Sci_PositionU recStartPos, Accessor &amp;styler)
359  {
360  	return GetHexaChar(recStartPos+4, styler);
361  }
362  static int CalcTEHexChecksum(Sci_PositionU recStartPos, Accessor &amp;styler)
363  {
364  	Sci_PositionU pos = recStartPos +1;
365  	Sci_PositionU length = GetTEHexDigitCount(recStartPos, styler);
366  	int cs = GetHexaNibble(styler.SafeGetCharAt(pos++));
367  	cs += GetHexaNibble(styler.SafeGetCharAt(pos++));
368  	cs += GetHexaNibble(styler.SafeGetCharAt(pos++));
369  	pos += 2;
370  	for (; pos &lt;= recStartPos + length; ++pos) {
371  		int val = GetHexaNibble(styler.SafeGetCharAt(pos));
372  		if (val &lt; 0) {
373  			return val;
374  		}
375  		cs += val;
376  	}
377  	return cs &amp; 0xFF;
378  }
379  static void ColouriseSrecDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[], Accessor &amp;styler)
380  {
381  	StyleContext sc(startPos, length, initStyle, styler);
382  	while (sc.More()) {
383  		Sci_PositionU recStartPos;
384  		Sci_Position reqByteCount;
385  		Sci_Position dataFieldSize;
386  		int byteCount, addrFieldSize, addrFieldType, dataFieldType;
387  		int cs1, cs2;
388  		switch (sc.state) {
389  			case SCE_HEX_DEFAULT:
390  				if (sc.atLineStart &amp;&amp; sc.Match(&#x27;S&#x27;)) {
391  					sc.SetState(SCE_HEX_RECSTART);
392  				}
393  				ForwardWithinLine(sc);
394  				break;
395  			case SCE_HEX_RECSTART:
396  				recStartPos = sc.currentPos - 1;
397  				addrFieldType = GetSrecAddressFieldType(recStartPos, styler);
398  				if (addrFieldType == SCE_HEX_ADDRESSFIELD_UNKNOWN) {
399  					sc.SetState(SCE_HEX_RECTYPE_UNKNOWN);
400  				} else {
401  					sc.SetState(SCE_HEX_RECTYPE);
402  				}
403  				ForwardWithinLine(sc);
404  				break;
405  			case SCE_HEX_RECTYPE:
406  			case SCE_HEX_RECTYPE_UNKNOWN:
407  				recStartPos = sc.currentPos - 2;
408  				byteCount = GetSrecByteCount(recStartPos, styler);
409  				reqByteCount = GetSrecAddressFieldSize(recStartPos, styler)
410  						+ GetSrecRequiredDataFieldSize(recStartPos, styler)
411  						+ 1; 
412  				if (byteCount == CountSrecByteCount(recStartPos, styler)
413  						&amp;&amp; byteCount == reqByteCount) {
414  					sc.SetState(SCE_HEX_BYTECOUNT);
415  				} else {
416  					sc.SetState(SCE_HEX_BYTECOUNT_WRONG);
417  				}
418  				ForwardWithinLine(sc, 2);
419  				break;
420  			case SCE_HEX_BYTECOUNT:
421  			case SCE_HEX_BYTECOUNT_WRONG:
422  				recStartPos = sc.currentPos - 4;
423  				addrFieldSize = GetSrecAddressFieldSize(recStartPos, styler);
424  				addrFieldType = GetSrecAddressFieldType(recStartPos, styler);
425  				sc.SetState(addrFieldType);
426  				ForwardWithinLine(sc, addrFieldSize * 2);
427  				break;
428  			case SCE_HEX_NOADDRESS:
429  			case SCE_HEX_DATAADDRESS:
430  			case SCE_HEX_RECCOUNT:
431  			case SCE_HEX_STARTADDRESS:
432  			case SCE_HEX_ADDRESSFIELD_UNKNOWN:
433  				recStartPos = GetSrecRecStartPosition(sc.currentPos, styler);
434  				dataFieldType = GetSrecDataFieldType(recStartPos, styler);
435  				dataFieldSize = GetSrecRequiredDataFieldSize(recStartPos, styler);
436  				sc.SetState(dataFieldType);
437  				if (dataFieldType == SCE_HEX_DATA_ODD) {
438  					for (int i = 0; i &lt; dataFieldSize * 2; i++) {
439  						if ((i &amp; 0x3) == 0) {
440  							sc.SetState(SCE_HEX_DATA_ODD);
441  						} else if ((i &amp; 0x3) == 2) {
442  							sc.SetState(SCE_HEX_DATA_EVEN);
443  						}
444  						if (!ForwardWithinLine(sc)) {
445  							break;
446  						}
447  					}
448  				} else {
449  					ForwardWithinLine(sc, dataFieldSize * 2);
450  				}
451  				break;
452  			case SCE_HEX_DATA_ODD:
453  			case SCE_HEX_DATA_EVEN:
454  			case SCE_HEX_DATA_EMPTY:
455  			case SCE_HEX_DATA_UNKNOWN:
456  				recStartPos = GetSrecRecStartPosition(sc.currentPos, styler);
457  				cs1 = CalcSrecChecksum(recStartPos, styler);
458  				cs2 = GetSrecChecksum(recStartPos, styler);
459  				if (cs1 != cs2 || cs1 &lt; 0 || cs2 &lt; 0) {
460  					sc.SetState(SCE_HEX_CHECKSUM_WRONG);
461  				} else {
462  					sc.SetState(SCE_HEX_CHECKSUM);
463  				}
464  				ForwardWithinLine(sc, 2);
465  				break;
466  			case SCE_HEX_CHECKSUM:
467  			case SCE_HEX_CHECKSUM_WRONG:
468  			case SCE_HEX_GARBAGE:
469  				sc.SetState(SCE_HEX_GARBAGE);
470  				ForwardWithinLine(sc);
471  				break;
472  			default:
473  				sc.SetState(SCE_HEX_DEFAULT);
474  				break;
475  		}
476  	}
477  	sc.Complete();
478  }
479  static void ColouriseIHexDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[], Accessor &amp;styler)
480  {
481  	StyleContext sc(startPos, length, initStyle, styler);
482  	while (sc.More()) {
483  		Sci_PositionU recStartPos;
484  		int byteCount, addrFieldType, dataFieldSize, dataFieldType;
485  		int cs1, cs2;
486  		switch (sc.state) {
487  			case SCE_HEX_DEFAULT:
488  				if (sc.atLineStart &amp;&amp; sc.Match(&#x27;:&#x27;)) {
489  					sc.SetState(SCE_HEX_RECSTART);
490  				}
491  				ForwardWithinLine(sc);
492  				break;
493  			case SCE_HEX_RECSTART:
494  				recStartPos = sc.currentPos - 1;
495  				byteCount = GetIHexByteCount(recStartPos, styler);
496  				dataFieldSize = GetIHexRequiredDataFieldSize(recStartPos, styler);
497  				if (byteCount == CountIHexByteCount(recStartPos, styler)
498  						&amp;&amp; byteCount == dataFieldSize) {
499  					sc.SetState(SCE_HEX_BYTECOUNT);
500  				} else {
501  					sc.SetState(SCE_HEX_BYTECOUNT_WRONG);
502  				}
503  				ForwardWithinLine(sc, 2);
504  				break;
505  			case SCE_HEX_BYTECOUNT:
506  			case SCE_HEX_BYTECOUNT_WRONG:
507  				recStartPos = sc.currentPos - 3;
508  				addrFieldType = GetIHexAddressFieldType(recStartPos, styler);
509  				sc.SetState(addrFieldType);
510  				ForwardWithinLine(sc, 4);
511  				break;
512  			case SCE_HEX_NOADDRESS:
513  			case SCE_HEX_DATAADDRESS:
514  			case SCE_HEX_ADDRESSFIELD_UNKNOWN:
515  				recStartPos = sc.currentPos - 7;
516  				addrFieldType = GetIHexAddressFieldType(recStartPos, styler);
517  				if (addrFieldType == SCE_HEX_ADDRESSFIELD_UNKNOWN) {
518  					sc.SetState(SCE_HEX_RECTYPE_UNKNOWN);
519  				} else {
520  					sc.SetState(SCE_HEX_RECTYPE);
521  				}
522  				ForwardWithinLine(sc, 2);
523  				break;
524  			case SCE_HEX_RECTYPE:
525  			case SCE_HEX_RECTYPE_UNKNOWN:
526  				recStartPos = sc.currentPos - 9;
527  				dataFieldType = GetIHexDataFieldType(recStartPos, styler);
528  				dataFieldSize = GetIHexRequiredDataFieldSize(recStartPos, styler);
529  				sc.SetState(dataFieldType);
530  				if (dataFieldType == SCE_HEX_DATA_ODD) {
531  					for (int i = 0; i &lt; dataFieldSize * 2; i++) {
532  						if ((i &amp; 0x3) == 0) {
533  							sc.SetState(SCE_HEX_DATA_ODD);
534  						} else if ((i &amp; 0x3) == 2) {
535  							sc.SetState(SCE_HEX_DATA_EVEN);
536  						}
537  						if (!ForwardWithinLine(sc)) {
538  							break;
539  						}
540  					}
541  				} else {
542  					ForwardWithinLine(sc, dataFieldSize * 2);
543  				}
544  				break;
545  			case SCE_HEX_DATA_ODD:
546  			case SCE_HEX_DATA_EVEN:
547  			case SCE_HEX_DATA_EMPTY:
548  			case SCE_HEX_EXTENDEDADDRESS:
549  			case SCE_HEX_STARTADDRESS:
550  			case SCE_HEX_DATA_UNKNOWN:
551  				recStartPos = GetIHexRecStartPosition(sc.currentPos, styler);
552  				cs1 = CalcIHexChecksum(recStartPos, styler);
553  				cs2 = GetIHexChecksum(recStartPos, styler);
554  				if (cs1 != cs2 || cs1 &lt; 0 || cs2 &lt; 0) {
555  					sc.SetState(SCE_HEX_CHECKSUM_WRONG);
556  				} else {
557  					sc.SetState(SCE_HEX_CHECKSUM);
558  				}
559  				ForwardWithinLine(sc, 2);
560  				break;
561  			case SCE_HEX_CHECKSUM:
562  			case SCE_HEX_CHECKSUM_WRONG:
563  			case SCE_HEX_GARBAGE:
564  				sc.SetState(SCE_HEX_GARBAGE);
565  				ForwardWithinLine(sc);
566  				break;
567  			default:
568  				sc.SetState(SCE_HEX_DEFAULT);
569  				break;
570  		}
571  	}
572  	sc.Complete();
573  }
574  static void FoldIHexDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &amp;styler)
575  {
576  	Sci_PositionU endPos = startPos + length;
577  	Sci_Position lineCurrent = styler.GetLine(startPos);
578  	int levelCurrent = SC_FOLDLEVELBASE;
579  	if (lineCurrent &gt; 0)
580  		levelCurrent = styler.LevelAt(lineCurrent - 1);
<span onclick='openModal()' class='match'>581  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
582  	int levelNext = SC_FOLDLEVELBASE; 
583  	for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
</span>584  		bool atEOL = i == (lineStartNext - 1);
585  		int style = styler.StyleAt(i);
586  		if (style == SCE_HEX_EXTENDEDADDRESS) {
587  			levelNext = SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG;
588  		} else if (style == SCE_HEX_DATAADDRESS
589  			|| (style == SCE_HEX_DEFAULT
590  				&amp;&amp; i == (Sci_PositionU)styler.LineStart(lineCurrent))) {
591  			if (levelCurrent &amp; SC_FOLDLEVELHEADERFLAG) {
592  				levelNext = SC_FOLDLEVELBASE + 1;
593  			} else {
594  				levelNext = levelCurrent;
595  			}
596  		}
597  		if (atEOL || (i == endPos - 1)) {
598  			styler.SetLevel(lineCurrent, levelNext);
599  			lineCurrent++;
600  			lineStartNext = styler.LineStart(lineCurrent + 1);
601  			levelCurrent = levelNext;
602  			levelNext = SC_FOLDLEVELBASE;
603  		}
604  	}
605  }
606  static void ColouriseTEHexDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[], Accessor &amp;styler)
607  {
608  	StyleContext sc(startPos, length, initStyle, styler);
609  	while (sc.More()) {
610  		Sci_PositionU recStartPos;
611  		int digitCount, addrFieldType;
612  		int cs1, cs2;
613  		switch (sc.state) {
614  			case SCE_HEX_DEFAULT:
615  				if (sc.atLineStart &amp;&amp; sc.Match(&#x27;%&#x27;)) {
616  					sc.SetState(SCE_HEX_RECSTART);
617  				}
618  				ForwardWithinLine(sc);
619  				break;
620  			case SCE_HEX_RECSTART:
621  				recStartPos = sc.currentPos - 1;
622  				if (GetTEHexDigitCount(recStartPos, styler) == CountTEHexDigitCount(recStartPos, styler)) {
623  					sc.SetState(SCE_HEX_BYTECOUNT);
624  				} else {
625  					sc.SetState(SCE_HEX_BYTECOUNT_WRONG);
626  				}
627  				ForwardWithinLine(sc, 2);
628  				break;
629  			case SCE_HEX_BYTECOUNT:
630  			case SCE_HEX_BYTECOUNT_WRONG:
631  				recStartPos = sc.currentPos - 3;
632  				addrFieldType = GetTEHexAddressFieldType(recStartPos, styler);
633  				if (addrFieldType == SCE_HEX_ADDRESSFIELD_UNKNOWN) {
634  					sc.SetState(SCE_HEX_RECTYPE_UNKNOWN);
635  				} else {
636  					sc.SetState(SCE_HEX_RECTYPE);
637  				}
638  				ForwardWithinLine(sc);
639  				break;
640  			case SCE_HEX_RECTYPE:
641  			case SCE_HEX_RECTYPE_UNKNOWN:
642  				recStartPos = sc.currentPos - 4;
643  				cs1 = CalcTEHexChecksum(recStartPos, styler);
644  				cs2 = GetTEHexChecksum(recStartPos, styler);
645  				if (cs1 != cs2 || cs1 &lt; 0 || cs2 &lt; 0) {
646  					sc.SetState(SCE_HEX_CHECKSUM_WRONG);
647  				} else {
648  					sc.SetState(SCE_HEX_CHECKSUM);
649  				}
650  				ForwardWithinLine(sc, 2);
651  				break;
652  			case SCE_HEX_CHECKSUM:
653  			case SCE_HEX_CHECKSUM_WRONG:
654  				recStartPos = sc.currentPos - 6;
655  				addrFieldType = GetTEHexAddressFieldType(recStartPos, styler);
656  				sc.SetState(addrFieldType);
657  				ForwardWithinLine(sc, 9);
658  				break;
659  			case SCE_HEX_DATAADDRESS:
660  			case SCE_HEX_STARTADDRESS:
661  			case SCE_HEX_ADDRESSFIELD_UNKNOWN:
662  				recStartPos = sc.currentPos - 15;
663  				digitCount = GetTEHexDigitCount(recStartPos, styler) - 14;
664  				sc.SetState(SCE_HEX_DATA_ODD);
665  				for (int i = 0; i &lt; digitCount; i++) {
666  					if ((i &amp; 0x3) == 0) {
667  						sc.SetState(SCE_HEX_DATA_ODD);
668  					} else if ((i &amp; 0x3) == 2) {
669  						sc.SetState(SCE_HEX_DATA_EVEN);
670  					}
671  					if (!ForwardWithinLine(sc)) {
672  						break;
673  					}
674  				}
675  				break;
676  			case SCE_HEX_DATA_ODD:
677  			case SCE_HEX_DATA_EVEN:
678  			case SCE_HEX_GARBAGE:
679  				sc.SetState(SCE_HEX_GARBAGE);
680  				ForwardWithinLine(sc);
681  				break;
682  			default:
683  				sc.SetState(SCE_HEX_DEFAULT);
684  				break;
685  		}
686  	}
687  	sc.Complete();
688  }
689  LexerModule lmSrec(SCLEX_SREC, ColouriseSrecDoc, &quot;srec&quot;, 0, NULL);
690  LexerModule lmIHex(SCLEX_IHEX, ColouriseIHexDoc, &quot;ihex&quot;, FoldIHexDoc, NULL);
691  LexerModule lmTEHex(SCLEX_TEHEX, ColouriseTEHexDoc, &quot;tehex&quot;, 0, NULL);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRust.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &lt;map&gt;
10  #include &lt;functional&gt;
11  #include &quot;ILexer.h&quot;
12  #include &quot;Scintilla.h&quot;
13  #include &quot;SciLexer.h&quot;
14  #include &quot;PropSetSimple.h&quot;
15  #include &quot;WordList.h&quot;
16  #include &quot;LexAccessor.h&quot;
17  #include &quot;Accessor.h&quot;
18  #include &quot;StyleContext.h&quot;
19  #include &quot;CharacterSet.h&quot;
20  #include &quot;LexerModule.h&quot;
21  #include &quot;OptionSet.h&quot;
22  #include &quot;DefaultLexer.h&quot;
23  using namespace Scintilla;
24  using namespace Lexilla;
25  static const int NUM_RUST_KEYWORD_LISTS = 7;
26  static const int MAX_RUST_IDENT_CHARS = 1023;
27  static bool IsStreamCommentStyle(int style) {
28  	return style == SCE_RUST_COMMENTBLOCK ||
29  		   style == SCE_RUST_COMMENTBLOCKDOC;
30  }
31  struct OptionsRust {
32  	bool fold;
33  	bool foldSyntaxBased;
34  	bool foldComment;
35  	bool foldCommentMultiline;
36  	bool foldCommentExplicit;
37  	std::string foldExplicitStart;
38  	std::string foldExplicitEnd;
39  	bool foldExplicitAnywhere;
40  	bool foldCompact;
41  	int  foldAtElseInt;
42  	bool foldAtElse;
43  	OptionsRust() {
44  		fold = false;
45  		foldSyntaxBased = true;
46  		foldComment = false;
47  		foldCommentMultiline = true;
48  		foldCommentExplicit = true;
49  		foldExplicitStart = &quot;&quot;;
50  		foldExplicitEnd   = &quot;&quot;;
51  		foldExplicitAnywhere = false;
52  		foldCompact = true;
53  		foldAtElseInt = -1;
54  		foldAtElse = false;
55  	}
56  };
57  static const char * const rustWordLists[NUM_RUST_KEYWORD_LISTS + 1] = {
58  			&quot;Primary keywords and identifiers&quot;,
59  			&quot;Built in types&quot;,
60  			&quot;Other keywords&quot;,
61  			&quot;Keywords 4&quot;,
62  			&quot;Keywords 5&quot;,
63  			&quot;Keywords 6&quot;,
64  			&quot;Keywords 7&quot;,
65  			0,
66  		};
67  struct OptionSetRust : public OptionSet&lt;OptionsRust&gt; {
68  	OptionSetRust() {
69  		DefineProperty(&quot;fold&quot;, &amp;OptionsRust::fold);
70  		DefineProperty(&quot;fold.comment&quot;, &amp;OptionsRust::foldComment);
71  		DefineProperty(&quot;fold.compact&quot;, &amp;OptionsRust::foldCompact);
72  		DefineProperty(&quot;fold.at.else&quot;, &amp;OptionsRust::foldAtElse);
73  		DefineProperty(&quot;fold.rust.syntax.based&quot;, &amp;OptionsRust::foldSyntaxBased,
74  			&quot;Set this property to 0 to disable syntax based folding.&quot;);
75  		DefineProperty(&quot;fold.rust.comment.multiline&quot;, &amp;OptionsRust::foldCommentMultiline,
76  			&quot;Set this property to 0 to disable folding multi-line comments when fold.comment=1.&quot;);
77  		DefineProperty(&quot;fold.rust.comment.explicit&quot;, &amp;OptionsRust::foldCommentExplicit,
78  			&quot;Set this property to 0 to disable folding explicit fold points when fold.comment=1.&quot;);
79  		DefineProperty(&quot;fold.rust.explicit.start&quot;, &amp;OptionsRust::foldExplicitStart,
80  			&quot;The string to use for explicit fold start points, replacing the standard 
81  		DefineProperty(&quot;fold.rust.explicit.end&quot;, &amp;OptionsRust::foldExplicitEnd,
82  			&quot;The string to use for explicit fold end points, replacing the standard 
83  		DefineProperty(&quot;fold.rust.explicit.anywhere&quot;, &amp;OptionsRust::foldExplicitAnywhere,
84  			&quot;Set this property to 1 to enable explicit fold points anywhere, not just in line comments.&quot;);
85  		DefineProperty(&quot;lexer.rust.fold.at.else&quot;, &amp;OptionsRust::foldAtElseInt,
86  			&quot;This option enables Rust folding on a \&quot;} else {\&quot; line of an if statement.&quot;);
87  		DefineWordListSets(rustWordLists);
88  	}
89  };
90  class LexerRust : public DefaultLexer {
91  	WordList keywords[NUM_RUST_KEYWORD_LISTS];
92  	OptionsRust options;
93  	OptionSetRust osRust;
94  public:
95  	LexerRust() : DefaultLexer(&quot;rust&quot;, SCLEX_RUST) {
96  	}
97  	virtual ~LexerRust() {
98  	}
99  	void SCI_METHOD Release() override {
100  		delete this;
101  	}
102  	int SCI_METHOD Version() const override {
103  		return lvRelease5;
104  	}
105  	const char * SCI_METHOD PropertyNames() override {
106  		return osRust.PropertyNames();
107  	}
108  	int SCI_METHOD PropertyType(const char *name) override {
109  		return osRust.PropertyType(name);
110  	}
111  	const char * SCI_METHOD DescribeProperty(const char *name) override {
112  		return osRust.DescribeProperty(name);
113  	}
114  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
115  	const char * SCI_METHOD PropertyGet(const char *key) override {
116  		return osRust.PropertyGet(key);
117  	}
118  	const char * SCI_METHOD DescribeWordListSets() override {
119  		return osRust.DescribeWordListSets();
120  	}
121  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
122  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
123  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
124  	void * SCI_METHOD PrivateCall(int, void *) override {
125  		return 0;
126  	}
127  	static ILexer5 *LexerFactoryRust() {
128  		return new LexerRust();
129  	}
130  };
131  Sci_Position SCI_METHOD LexerRust::PropertySet(const char *key, const char *val) {
132  	if (osRust.PropertySet(&amp;options, key, val)) {
133  		return 0;
134  	}
135  	return -1;
136  }
137  Sci_Position SCI_METHOD LexerRust::WordListSet(int n, const char *wl) {
138  	Sci_Position firstModification = -1;
139  	if (n &lt; NUM_RUST_KEYWORD_LISTS) {
140  		WordList *wordListN = &amp;keywords[n];
141  		WordList wlNew;
142  		wlNew.Set(wl);
143  		if (*wordListN != wlNew) {
144  			wordListN-&gt;Set(wl);
145  			firstModification = 0;
146  		}
147  	}
148  	return firstModification;
149  }
150  static bool IsWhitespace(int c) {
151      return c == &#x27; &#x27; || c == &#x27;\t&#x27; || c == &#x27;\r&#x27; || c == &#x27;\n&#x27;;
152  }
153  static bool IsIdentifierStart(int ch) {
154  	return (IsASCII(ch) &amp;&amp; (isalpha(ch) || ch == &#x27;_&#x27;)) || !IsASCII(ch);
155  }
156  static bool IsIdentifierContinue(int ch) {
157  	return (IsASCII(ch) &amp;&amp; (isalnum(ch) || ch == &#x27;_&#x27;)) || !IsASCII(ch);
158  }
159  static void ScanWhitespace(Accessor&amp; styler, Sci_Position&amp; pos, Sci_Position max) {
160  	while (IsWhitespace(styler.SafeGetCharAt(pos, &#x27;\0&#x27;)) &amp;&amp; pos &lt; max) {
161  		if (pos == styler.LineEnd(styler.GetLine(pos)))
162  			styler.SetLineState(styler.GetLine(pos), 0);
163  		pos++;
164  	}
165  	styler.ColourTo(pos-1, SCE_RUST_DEFAULT);
166  }
167  static void GrabString(char* s, Accessor&amp; styler, Sci_Position start, Sci_Position len) {
168  	for (Sci_Position ii = 0; ii &lt; len; ii++)
169  		s[ii] = styler[ii + start];
170  	s[len] = &#x27;\0&#x27;;
171  }
172  static void ScanIdentifier(Accessor&amp; styler, Sci_Position&amp; pos, WordList *keywords) {
173  	Sci_Position start = pos;
174  	while (IsIdentifierContinue(styler.SafeGetCharAt(pos, &#x27;\0&#x27;)))
175  		pos++;
176  	if (styler.SafeGetCharAt(pos, &#x27;\0&#x27;) == &#x27;!&#x27;) {
177  		pos++;
178  		styler.ColourTo(pos - 1, SCE_RUST_MACRO);
179  	} else {
180  		char s[MAX_RUST_IDENT_CHARS + 1];
181  		Sci_Position len = pos - start;
182  		len = len &gt; MAX_RUST_IDENT_CHARS ? MAX_RUST_IDENT_CHARS : len;
183  		GrabString(s, styler, start, len);
184  		bool keyword = false;
185  		for (int ii = 0; ii &lt; NUM_RUST_KEYWORD_LISTS; ii++) {
186  			if (keywords[ii].InList(s)) {
187  				styler.ColourTo(pos - 1, SCE_RUST_WORD + ii);
188  				keyword = true;
189  				break;
190  			}
191  		}
192  		if (!keyword) {
193  			styler.ColourTo(pos - 1, SCE_RUST_IDENTIFIER);
194  		}
195  	}
196  }
197  static bool ScanDigits(Accessor&amp; styler, Sci_Position&amp; pos, int base) {
198  	Sci_Position old_pos = pos;
199  	for (;;) {
200  		int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
201  		if (IsADigit(c, base) || c == &#x27;_&#x27;)
202  			pos++;
203  		else
204  			break;
205  	}
206  	return old_pos != pos;
207  }
208  static void ScanNumber(Accessor&amp; styler, Sci_Position&amp; pos) {
209  	int base = 10;
210  	int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
211  	int n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
212  	bool error = false;
213  	if (c == &#x27;0&#x27; &amp;&amp; n == &#x27;x&#x27;) {
214  		pos += 2;
215  		base = 16;
216  	} else if (c == &#x27;0&#x27; &amp;&amp; n == &#x27;b&#x27;) {
217  		pos += 2;
218  		base = 2;
219  	} else if (c == &#x27;0&#x27; &amp;&amp; n == &#x27;o&#x27;) {
220  		pos += 2;
221  		base = 8;
222  	}
223  	error |= !ScanDigits(styler, pos, base);
224  	c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
225  	if (c == &#x27;u&#x27; || c == &#x27;i&#x27;) {
226  		pos++;
227  		c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
228  		n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
229  		if (c == &#x27;8&#x27;) {
230  			pos++;
231  		} else if (c == &#x27;1&#x27; &amp;&amp; n == &#x27;6&#x27;) {
232  			pos += 2;
233  		} else if (c == &#x27;3&#x27; &amp;&amp; n == &#x27;2&#x27;) {
234  			pos += 2;
235  		} else if (c == &#x27;6&#x27; &amp;&amp; n == &#x27;4&#x27;) {
236  			pos += 2;
237  		} else if (styler.Match(pos, &quot;128&quot;)) {
238  			pos += 3;
239  		} else if (styler.Match(pos, &quot;size&quot;)) {
240  			pos += 4;
241  		} else {
242  			error = true;
243  		}
244  	} else if (!error) {
245  		n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
246  		if (c == &#x27;.&#x27; &amp;&amp; !(IsIdentifierStart(n) || n == &#x27;.&#x27;)) {
247  			error |= base != 10;
248  			pos++;
249  			ScanDigits(styler, pos, 10);
250  		}
251  		c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
252  		if (c == &#x27;e&#x27; || c == &#x27;E&#x27;) {
253  			error |= base != 10;
254  			pos++;
255  			c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
256  			if (c == &#x27;-&#x27; || c == &#x27;+&#x27;)
257  				pos++;
258  			error |= !ScanDigits(styler, pos, 10);
259  		}
260  		c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
261  		if (c == &#x27;f&#x27;) {
262  			error |= base != 10;
263  			pos++;
264  			c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
265  			n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
266  			if (c == &#x27;3&#x27; &amp;&amp; n == &#x27;2&#x27;) {
267  				pos += 2;
268  			} else if (c == &#x27;6&#x27; &amp;&amp; n == &#x27;4&#x27;) {
269  				pos += 2;
270  			} else {
271  				error = true;
272  			}
273  		}
274  	}
275  	if (error)
276  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
277  	else
278  		styler.ColourTo(pos - 1, SCE_RUST_NUMBER);
279  }
280  static bool IsOneCharOperator(int c) {
281  	return c == &#x27;;&#x27; || c == &#x27;,&#x27; || c == &#x27;(&#x27; || c == &#x27;)&#x27;
282  	    || c == &#x27;{&#x27; || c == &#x27;}&#x27; || c == &#x27;[&#x27; || c == &#x27;]&#x27;
283  	    || c == &#x27;@&#x27; || c == &#x27;#&#x27; || c == &#x27;~&#x27; || c == &#x27;+&#x27;
284  	    || c == &#x27;*&#x27; || c == &#x27;/&#x27; || c == &#x27;^&#x27; || c == &#x27;%&#x27;
285  	    || c == &#x27;.&#x27; || c == &#x27;:&#x27; || c == &#x27;!&#x27; || c == &#x27;&lt;&#x27;
286  	    || c == &#x27;&gt;&#x27; || c == &#x27;=&#x27; || c == &#x27;-&#x27; || c == &#x27;&amp;&#x27;
287  	    || c == &#x27;|&#x27; || c == &#x27;$&#x27; || c == &#x27;?&#x27;;
288  }
289  static bool IsTwoCharOperator(int c, int n) {
290  	return (c == &#x27;.&#x27; &amp;&amp; n == &#x27;.&#x27;) || (c == &#x27;:&#x27; &amp;&amp; n == &#x27;:&#x27;)
291  	    || (c == &#x27;!&#x27; &amp;&amp; n == &#x27;=&#x27;) || (c == &#x27;&lt;&#x27; &amp;&amp; n == &#x27;&lt;&#x27;)
292  	    || (c == &#x27;&lt;&#x27; &amp;&amp; n == &#x27;=&#x27;) || (c == &#x27;&gt;&#x27; &amp;&amp; n == &#x27;&gt;&#x27;)
293  	    || (c == &#x27;&gt;&#x27; &amp;&amp; n == &#x27;=&#x27;) || (c == &#x27;=&#x27; &amp;&amp; n == &#x27;=&#x27;)
294  	    || (c == &#x27;=&#x27; &amp;&amp; n == &#x27;&gt;&#x27;) || (c == &#x27;-&#x27; &amp;&amp; n == &#x27;&gt;&#x27;)
295  	    || (c == &#x27;&amp;&#x27; &amp;&amp; n == &#x27;&amp;&#x27;) || (c == &#x27;|&#x27; &amp;&amp; n == &#x27;|&#x27;)
296  	    || (c == &#x27;-&#x27; &amp;&amp; n == &#x27;=&#x27;) || (c == &#x27;&amp;&#x27; &amp;&amp; n == &#x27;=&#x27;)
297  	    || (c == &#x27;|&#x27; &amp;&amp; n == &#x27;=&#x27;) || (c == &#x27;+&#x27; &amp;&amp; n == &#x27;=&#x27;)
298  	    || (c == &#x27;*&#x27; &amp;&amp; n == &#x27;=&#x27;) || (c == &#x27;/&#x27; &amp;&amp; n == &#x27;=&#x27;)
299  	    || (c == &#x27;^&#x27; &amp;&amp; n == &#x27;=&#x27;) || (c == &#x27;%&#x27; &amp;&amp; n == &#x27;=&#x27;);
300  }
301  static bool IsThreeCharOperator(int c, int n, int n2) {
302  	return (c == &#x27;&lt;&#x27; &amp;&amp; n == &#x27;&lt;&#x27; &amp;&amp; n2 == &#x27;=&#x27;)
303  	    || (c == &#x27;&gt;&#x27; &amp;&amp; n == &#x27;&gt;&#x27; &amp;&amp; n2 == &#x27;=&#x27;);
304  }
305  static bool IsValidCharacterEscape(int c) {
306  	return c == &#x27;n&#x27;  || c == &#x27;r&#x27; || c == &#x27;t&#x27; || c == &#x27;\\&#x27;
307  	    || c == &#x27;\&#x27;&#x27; || c == &#x27;&quot;&#x27; || c == &#x27;0&#x27;;
308  }
309  static bool IsValidStringEscape(int c) {
310  	return IsValidCharacterEscape(c) || c == &#x27;\n&#x27; || c == &#x27;\r&#x27;;
311  }
312  static bool ScanNumericEscape(Accessor &amp;styler, Sci_Position&amp; pos, Sci_Position num_digits, bool stop_asap) {
313  	for (;;) {
314  		int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
315  		if (!IsADigit(c, 16))
316  			break;
317  		num_digits--;
318  		pos++;
319  		if (num_digits == 0 &amp;&amp; stop_asap)
320  			return true;
321  	}
322  	if (num_digits == 0) {
323  		return true;
324  	} else {
325  		return false;
326  	}
327  }
328  static void ScanCharacterLiteralOrLifetime(Accessor &amp;styler, Sci_Position&amp; pos, bool ascii_only) {
329  	pos++;
330  	int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
331  	int n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
332  	bool done = false;
333  	bool valid_lifetime = !ascii_only &amp;&amp; IsIdentifierStart(c);
334  	bool valid_char = true;
335  	bool first = true;
336  	while (!done) {
337  		switch (c) {
338  			case &#x27;\\&#x27;:
339  				done = true;
340  				if (IsValidCharacterEscape(n)) {
341  					pos += 2;
342  				} else if (n == &#x27;x&#x27;) {
343  					pos += 2;
344  					valid_char = ScanNumericEscape(styler, pos, 2, false);
345  				} else if (n == &#x27;u&#x27; &amp;&amp; !ascii_only) {
346  					pos += 2;
347  					if (styler.SafeGetCharAt(pos, &#x27;\0&#x27;) != &#x27;{&#x27;) {
348  						valid_char = ScanNumericEscape(styler, pos, 4, false);
349  					} else {
350  						int n_digits = 0;
351  						while (IsADigit(styler.SafeGetCharAt(++pos, &#x27;\0&#x27;), 16) &amp;&amp; n_digits++ &lt; 6) {
352  						}
353  						if (n_digits &gt; 0 &amp;&amp; styler.SafeGetCharAt(pos, &#x27;\0&#x27;) == &#x27;}&#x27;)
354  							pos++;
355  						else
356  							valid_char = false;
357  					}
358  				} else if (n == &#x27;U&#x27; &amp;&amp; !ascii_only) {
359  					pos += 2;
360  					valid_char = ScanNumericEscape(styler, pos, 8, false);
361  				} else {
362  					valid_char = false;
363  				}
364  				break;
365  			case &#x27;\&#x27;&#x27;:
366  				valid_char = !first;
367  				done = true;
368  				break;
369  			case &#x27;\t&#x27;:
370  			case &#x27;\n&#x27;:
371  			case &#x27;\r&#x27;:
372  			case &#x27;\0&#x27;:
373  				valid_char = false;
374  				done = true;
375  				break;
376  			default:
377  				if (ascii_only &amp;&amp; !IsASCII((char)c)) {
378  					done = true;
379  					valid_char = false;
380  				} else if (!IsIdentifierContinue(c) &amp;&amp; !first) {
381  					done = true;
382  				} else {
383  					pos++;
384  				}
385  				break;
386  		}
387  		c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
388  		n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
389  		first = false;
390  	}
391  	if (styler.SafeGetCharAt(pos, &#x27;\0&#x27;) == &#x27;\&#x27;&#x27;) {
392  		valid_lifetime = false;
393  	} else {
394  		valid_char = false;
395  	}
396  	if (valid_lifetime) {
397  		styler.ColourTo(pos - 1, SCE_RUST_LIFETIME);
398  	} else if (valid_char) {
399  		pos++;
400  		styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTECHARACTER : SCE_RUST_CHARACTER);
401  	} else {
402  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
403  	}
404  }
405  enum CommentState {
406  	UnknownComment,
407  	DocComment,
408  	NotDocComment
409  };
410  static void ResumeBlockComment(Accessor &amp;styler, Sci_Position&amp; pos, Sci_Position max, CommentState state, int level) {
411  	int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
412  	bool maybe_doc_comment = false;
413  	if (c == &#x27;*&#x27;) {
414  		int n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
415  		if (n != &#x27;*&#x27; &amp;&amp; n != &#x27;/&#x27;) {
416  			maybe_doc_comment = true;
417  		}
418  	} else if (c == &#x27;!&#x27;) {
419  		maybe_doc_comment = true;
420  	}
421  	for (;;) {
422  		int n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
423  		if (pos == styler.LineEnd(styler.GetLine(pos)))
424  			styler.SetLineState(styler.GetLine(pos), level);
425  		if (c == &#x27;*&#x27;) {
426  			pos++;
427  			if (n == &#x27;/&#x27;) {
428  				pos++;
429  				level--;
430  				if (level == 0) {
431  					styler.SetLineState(styler.GetLine(pos), 0);
432  					if (state == DocComment || (state == UnknownComment &amp;&amp; maybe_doc_comment))
433  						styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCKDOC);
434  					else
435  						styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCK);
436  					break;
437  				}
438  			}
439  		} else if (c == &#x27;/&#x27;) {
440  			pos++;
441  			if (n == &#x27;*&#x27;) {
442  				pos++;
443  				level++;
444  			}
445  		}
446  		else if (pos &lt; max) {
447  			pos++;
448  		}
449  		if (pos &gt;= max) {
450  			if (state == DocComment || (state == UnknownComment &amp;&amp; maybe_doc_comment))
451  				styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCKDOC);
452  			else
453  				styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCK);
454  			break;
455  		}
456  		c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
457  	}
458  }
459  static void ResumeLineComment(Accessor &amp;styler, Sci_Position&amp; pos, Sci_Position max, CommentState state) {
460  	bool maybe_doc_comment = false;
461  	int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
462  	if (c == &#x27;/&#x27;) {
463  		if (pos &lt; max) {
464  			pos++;
465  			c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
466  			if (c != &#x27;/&#x27;) {
467  				maybe_doc_comment = true;
468  			}
469  		}
470  	} else if (c == &#x27;!&#x27;) {
471  		maybe_doc_comment = true;
472  	}
473  	pos = styler.LineEnd(styler.GetLine(pos));
474  	styler.SetLineState(styler.GetLine(pos), SCE_RUST_DEFAULT);
475  	if (state == DocComment || (state == UnknownComment &amp;&amp; maybe_doc_comment))
476  		styler.ColourTo(pos - 1, SCE_RUST_COMMENTLINEDOC);
477  	else
478  		styler.ColourTo(pos - 1, SCE_RUST_COMMENTLINE);
479  }
480  static void ScanComments(Accessor &amp;styler, Sci_Position&amp; pos, Sci_Position max) {
481  	pos++;
482  	int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
483  	pos++;
484  	if (c == &#x27;/&#x27;)
485  		ResumeLineComment(styler, pos, max, UnknownComment);
486  	else if (c == &#x27;*&#x27;)
487  		ResumeBlockComment(styler, pos, max, UnknownComment, 1);
488  }
489  static void ResumeString(Accessor &amp;styler, Sci_Position&amp; pos, Sci_Position max, bool ascii_only) {
490  	int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
491  	bool error = false;
492  	while (c != &#x27;&quot;&#x27; &amp;&amp; !error) {
493  		if (pos &gt;= max) {
494  			error = true;
495  			break;
496  		}
497  		if (pos == styler.LineEnd(styler.GetLine(pos)))
498  			styler.SetLineState(styler.GetLine(pos), 0);
499  		if (c == &#x27;\\&#x27;) {
500  			int n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
501  			if (IsValidStringEscape(n)) {
502  				pos += 2;
503  			} else if (n == &#x27;x&#x27;) {
504  				pos += 2;
505  				error = !ScanNumericEscape(styler, pos, 2, true);
506  			} else if (n == &#x27;u&#x27; &amp;&amp; !ascii_only) {
507  				pos += 2;
508  				if (styler.SafeGetCharAt(pos, &#x27;\0&#x27;) != &#x27;{&#x27;) {
509  					error = !ScanNumericEscape(styler, pos, 4, true);
510  				} else {
511  					int n_digits = 0;
512  					while (IsADigit(styler.SafeGetCharAt(++pos, &#x27;\0&#x27;), 16) &amp;&amp; n_digits++ &lt; 6) {
513  					}
514  					if (n_digits &gt; 0 &amp;&amp; styler.SafeGetCharAt(pos, &#x27;\0&#x27;) == &#x27;}&#x27;)
515  						pos++;
516  					else
517  						error = true;
518  				}
519  			} else if (n == &#x27;U&#x27; &amp;&amp; !ascii_only) {
520  				pos += 2;
521  				error = !ScanNumericEscape(styler, pos, 8, true);
522  			} else {
523  				pos += 1;
524  				error = true;
525  			}
526  		} else {
527  			if (ascii_only &amp;&amp; !IsASCII((char)c))
528  				error = true;
529  			else
530  				pos++;
531  		}
532  		c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
533  	}
534  	if (!error)
535  		pos++;
536  	styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTESTRING : SCE_RUST_STRING);
537  }
538  static void ResumeRawString(Accessor &amp;styler, Sci_Position&amp; pos, Sci_Position max, int num_hashes, bool ascii_only) {
539  	for (;;) {
540  		if (pos == styler.LineEnd(styler.GetLine(pos)))
541  			styler.SetLineState(styler.GetLine(pos), num_hashes);
542  		int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
543  		if (c == &#x27;&quot;&#x27;) {
544  			pos++;
545  			int trailing_num_hashes = 0;
546  			while (styler.SafeGetCharAt(pos, &#x27;\0&#x27;) == &#x27;#&#x27; &amp;&amp; trailing_num_hashes &lt; num_hashes) {
547  				trailing_num_hashes++;
548  				pos++;
549  			}
550  			if (trailing_num_hashes == num_hashes) {
551  				styler.SetLineState(styler.GetLine(pos), 0);
552  				break;
553  			}
554  		} else if (pos &gt;= max) {
555  			break;
556  		} else {
557  			if (ascii_only &amp;&amp; !IsASCII((char)c))
558  				break;
559  			pos++;
560  		}
561  	}
562  	styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTESTRINGR : SCE_RUST_STRINGR);
563  }
564  static void ScanRawString(Accessor &amp;styler, Sci_Position&amp; pos, Sci_Position max, bool ascii_only) {
565  	pos++;
566  	int num_hashes = 0;
567  	while (styler.SafeGetCharAt(pos, &#x27;\0&#x27;) == &#x27;#&#x27;) {
568  		num_hashes++;
569  		pos++;
570  	}
571  	if (styler.SafeGetCharAt(pos, &#x27;\0&#x27;) != &#x27;&quot;&#x27;) {
572  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
573  	} else {
574  		pos++;
575  		ResumeRawString(styler, pos, max, num_hashes, ascii_only);
576  	}
577  }
578  void SCI_METHOD LexerRust::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
579  	PropSetSimple props;
580  	Accessor styler(pAccess, &amp;props);
581  	Sci_Position pos = startPos;
582  	Sci_Position max = pos + length;
583  	styler.StartAt(pos);
584  	styler.StartSegment(pos);
585  	if (initStyle == SCE_RUST_COMMENTBLOCK || initStyle == SCE_RUST_COMMENTBLOCKDOC) {
586  		ResumeBlockComment(styler, pos, max, initStyle == SCE_RUST_COMMENTBLOCKDOC ? DocComment : NotDocComment, styler.GetLineState(styler.GetLine(pos) - 1));
587  	} else if (initStyle == SCE_RUST_COMMENTLINE || initStyle == SCE_RUST_COMMENTLINEDOC) {
588  		ResumeLineComment(styler, pos, max, initStyle == SCE_RUST_COMMENTLINEDOC ? DocComment : NotDocComment);
589  	} else if (initStyle == SCE_RUST_STRING) {
590  		ResumeString(styler, pos, max, false);
591  	} else if (initStyle == SCE_RUST_BYTESTRING) {
592  		ResumeString(styler, pos, max, true);
593  	} else if (initStyle == SCE_RUST_STRINGR) {
594  		ResumeRawString(styler, pos, max, styler.GetLineState(styler.GetLine(pos) - 1), false);
595  	} else if (initStyle == SCE_RUST_BYTESTRINGR) {
596  		ResumeRawString(styler, pos, max, styler.GetLineState(styler.GetLine(pos) - 1), true);
597  	}
598  	while (pos &lt; max) {
599  		int c = styler.SafeGetCharAt(pos, &#x27;\0&#x27;);
600  		int n = styler.SafeGetCharAt(pos + 1, &#x27;\0&#x27;);
601  		int n2 = styler.SafeGetCharAt(pos + 2, &#x27;\0&#x27;);
602  		if (pos == 0 &amp;&amp; c == &#x27;#&#x27; &amp;&amp; n == &#x27;!&#x27; &amp;&amp; n2 != &#x27;[&#x27;) {
603  			pos += 2;
604  			ResumeLineComment(styler, pos, max, NotDocComment);
605  		} else if (IsWhitespace(c)) {
606  			ScanWhitespace(styler, pos, max);
607  		} else if (c == &#x27;/&#x27; &amp;&amp; (n == &#x27;/&#x27; || n == &#x27;*&#x27;)) {
608  			ScanComments(styler, pos, max);
609  		} else if (c == &#x27;r&#x27; &amp;&amp; (n == &#x27;#&#x27; || n == &#x27;&quot;&#x27;)) {
610  			ScanRawString(styler, pos, max, false);
611  		} else if (c == &#x27;b&#x27; &amp;&amp; n == &#x27;r&#x27; &amp;&amp; (n2 == &#x27;#&#x27; || n2 == &#x27;&quot;&#x27;)) {
612  			pos++;
613  			ScanRawString(styler, pos, max, true);
614  		} else if (c == &#x27;b&#x27; &amp;&amp; n == &#x27;&quot;&#x27;) {
615  			pos += 2;
616  			ResumeString(styler, pos, max, true);
617  		} else if (c == &#x27;b&#x27; &amp;&amp; n == &#x27;\&#x27;&#x27;) {
618  			pos++;
619  			ScanCharacterLiteralOrLifetime(styler, pos, true);
620  		} else if (IsIdentifierStart(c)) {
621  			ScanIdentifier(styler, pos, keywords);
622  		} else if (IsADigit(c)) {
623  			ScanNumber(styler, pos);
624  		} else if (IsThreeCharOperator(c, n, n2)) {
625  			pos += 3;
626  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
627  		} else if (IsTwoCharOperator(c, n)) {
628  			pos += 2;
629  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
630  		} else if (IsOneCharOperator(c)) {
631  			pos++;
632  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
633  		} else if (c == &#x27;\&#x27;&#x27;) {
634  			ScanCharacterLiteralOrLifetime(styler, pos, false);
635  		} else if (c == &#x27;&quot;&#x27;) {
636  			pos++;
637  			ResumeString(styler, pos, max, false);
638  		} else {
639  			pos++;
640  			styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
641  		}
642  	}
643  	styler.ColourTo(pos - 1, SCE_RUST_DEFAULT);
644  	styler.Flush();
645  }
646  void SCI_METHOD LexerRust::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
647  	if (!options.fold)
648  		return;
649  	LexAccessor styler(pAccess);
650  	Sci_PositionU endPos = startPos + length;
651  	int visibleChars = 0;
652  	bool inLineComment = false;
653  	Sci_Position lineCurrent = styler.GetLine(startPos);
654  	int levelCurrent = SC_FOLDLEVELBASE;
655  	if (lineCurrent &gt; 0)
656  		levelCurrent = styler.LevelAt(lineCurrent-1) &gt;&gt; 16;
<span onclick='openModal()' class='match'>657  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
658  	int levelMinCurrent = levelCurrent;
659  	int levelNext = levelCurrent;
</span>660  	char chNext = styler[startPos];
661  	int styleNext = styler.StyleAt(startPos);
662  	int style = initStyle;
663  	const bool userDefinedFoldMarkers = !options.foldExplicitStart.empty() &amp;&amp; !options.foldExplicitEnd.empty();
664  	for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
665  		char ch = chNext;
666  		chNext = styler.SafeGetCharAt(i + 1);
667  		int stylePrev = style;
668  		style = styleNext;
669  		styleNext = styler.StyleAt(i + 1);
670  		bool atEOL = i == (lineStartNext-1);
671  		if ((style == SCE_RUST_COMMENTLINE) || (style == SCE_RUST_COMMENTLINEDOC))
672  			inLineComment = true;
673  		if (options.foldComment &amp;&amp; options.foldCommentMultiline &amp;&amp; IsStreamCommentStyle(style) &amp;&amp; !inLineComment) {
674  			if (!IsStreamCommentStyle(stylePrev)) {
675  				levelNext++;
676  			} else if (!IsStreamCommentStyle(styleNext) &amp;&amp; !atEOL) {
677  				levelNext--;
678  			}
679  		}
680  		if (options.foldComment &amp;&amp; options.foldCommentExplicit &amp;&amp; ((style == SCE_RUST_COMMENTLINE) || options.foldExplicitAnywhere)) {
681  			if (userDefinedFoldMarkers) {
682  				if (styler.Match(i, options.foldExplicitStart.c_str())) {
683  					levelNext++;
684  				} else if (styler.Match(i, options.foldExplicitEnd.c_str())) {
685  					levelNext--;
686  				}
687  			} else {
688  				if ((ch == &#x27;/&#x27;) &amp;&amp; (chNext == &#x27;/&#x27;)) {
689  					char chNext2 = styler.SafeGetCharAt(i + 2);
690  					if (chNext2 == &#x27;{&#x27;) {
691  						levelNext++;
692  					} else if (chNext2 == &#x27;}&#x27;) {
693  						levelNext--;
694  					}
695  				}
696  			}
697  		}
698  		if (options.foldSyntaxBased &amp;&amp; (style == SCE_RUST_OPERATOR)) {
699  			if (ch == &#x27;{&#x27;) {
700  				if (levelMinCurrent &gt; levelNext) {
701  					levelMinCurrent = levelNext;
702  				}
703  				levelNext++;
704  			} else if (ch == &#x27;}&#x27;) {
705  				levelNext--;
706  			}
707  		}
708  		if (!IsASpace(ch))
709  			visibleChars++;
710  		if (atEOL || (i == endPos-1)) {
711  			int levelUse = levelCurrent;
712  			if (options.foldSyntaxBased &amp;&amp; options.foldAtElse) {
713  				levelUse = levelMinCurrent;
714  			}
715  			int lev = levelUse | levelNext &lt;&lt; 16;
716  			if (visibleChars == 0 &amp;&amp; options.foldCompact)
717  				lev |= SC_FOLDLEVELWHITEFLAG;
718  			if (levelUse &lt; levelNext)
719  				lev |= SC_FOLDLEVELHEADERFLAG;
720  			if (lev != styler.LevelAt(lineCurrent)) {
721  				styler.SetLevel(lineCurrent, lev);
722  			}
723  			lineCurrent++;
724  			lineStartNext = styler.LineStart(lineCurrent+1);
725  			levelCurrent = levelNext;
726  			levelMinCurrent = levelCurrent;
727  			if (atEOL &amp;&amp; (i == static_cast&lt;Sci_PositionU&gt;(styler.Length()-1))) {
728  				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent &lt;&lt; 16) | SC_FOLDLEVELWHITEFLAG);
729  			}
730  			visibleChars = 0;
731  			inLineComment = false;
732  		}
733  	}
734  }
735  LexerModule lmRust(SCLEX_RUST, LexerRust::LexerFactoryRust, &quot;rust&quot;, rustWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHex.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRust.cxx</div>
                </div>
                <div class="column column_space"><pre><code>581  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
582  	int levelNext = SC_FOLDLEVELBASE; 
583  	for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
</pre></code></div>
                <div class="column column_space"><pre><code>657  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
658  	int levelMinCurrent = levelCurrent;
659  	int levelNext = levelCurrent;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    