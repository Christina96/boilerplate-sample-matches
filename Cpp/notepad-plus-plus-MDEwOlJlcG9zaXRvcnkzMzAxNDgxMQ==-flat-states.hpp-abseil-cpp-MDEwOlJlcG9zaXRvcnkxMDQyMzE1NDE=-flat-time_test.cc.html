
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.856341189674524%, Tokens: 35, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-states.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_STATES_HPP
2  #define BOOST_REGEX_V5_STATES_HPP
3  namespace boost{
4  namespace BOOST_REGEX_DETAIL_NS{
5  enum mask_type
6  {
7     mask_take = 1,
8     mask_skip = 2,
9     mask_init = 4,
10     mask_any = mask_skip | mask_take,
11     mask_all = mask_any
12  };
13  struct _narrow_type{};
14  struct _wide_type{};
15  template <class charT> struct is_byte;
16  template<>             struct is_byte<char>         { typedef _narrow_type width_type; };
17  template<>             struct is_byte<unsigned char>{ typedef _narrow_type width_type; };
18  template<>             struct is_byte<signed char>  { typedef _narrow_type width_type; };
19  template <class charT> struct is_byte               { typedef _wide_type width_type; };
20  enum syntax_element_type
21  {
<span onclick='openModal()' class='match'>22     syntax_element_startmark = 0,
23     syntax_element_endmark = syntax_element_startmark + 1,
24     syntax_element_literal = syntax_element_endmark + 1,
25     syntax_element_start_line = syntax_element_literal + 1,
26     syntax_element_end_line = syntax_element_start_line + 1,
27     syntax_element_wild = syntax_element_end_line + 1,
28     syntax_element_match = syntax_element_wild + 1,
29     syntax_element_word_boundary = syntax_element_match + 1,
30     syntax_element_within_word = syntax_element_word_boundary + 1,
31     syntax_element_word_start = syntax_element_within_word + 1,
32     syntax_element_word_end = syntax_element_word_start + 1,
33     syntax_element_buffer_start = syntax_element_word_end + 1,
34     syntax_element_buffer_end = syntax_element_buffer_start + 1,
35     syntax_element_backref = syntax_element_buffer_end + 1,
36     syntax_element_long_set = syntax_element_backref + 1,
37     syntax_element_set = syntax_element_long_set + 1,
38     syntax_element_jump = syntax_element_set + 1,
39     syntax_element_alt = syntax_element_jump + 1,
40     syntax_element_rep = syntax_element_alt + 1,
41     syntax_element_combining = syntax_element_rep + 1,
42     syntax_element_soft_buffer_end = syntax_element_combining + 1,
43     syntax_element_restart_continue = syntax_element_soft_buffer_end + 1,
44     syntax_element_dot_rep = syntax_element_restart_continue + 1,
45     syntax_element_char_rep = syntax_element_dot_rep + 1,
46     syntax_element_short_set_rep = syntax_element_char_rep + 1,
47     syntax_element_long_set_rep = syntax_element_short_set_rep + 1,
48     syntax_element_backstep = syntax_element_long_set_rep + 1,
49     syntax_element_assert_backref = syntax_element_backstep + 1,
50     syntax_element_toggle_case = syntax_element_assert_backref + 1,
51     syntax_element_recurse = syntax_element_toggle_case + 1,
52     syntax_element_fail = syntax_element_recurse + 1,
53     syntax_element_accept = syntax_element_fail + 1,
54     syntax_element_commit = syntax_element_accept + 1,
55     syntax_element_then = syntax_element_commit + 1
56  };
</span>57  #ifdef BOOST_REGEX_DEBUG
58  std::ostream& operator<<(std::ostream&, syntax_element_type);
59  #endif
60  struct re_syntax_base;
61  union offset_type
62  {
63     re_syntax_base*   p;
64     std::ptrdiff_t    i;
65  };
66  struct re_syntax_base
67  {
68     syntax_element_type   type;         
69     offset_type           next;         
70  };
71  struct re_brace : public re_syntax_base
72  {
73     int index;
74     bool icase;
75  };
76  enum
77  {
78     dont_care = 1,
79     force_not_newline = 0,
80     force_newline = 2,
81     test_not_newline = 2,
82     test_newline = 3
83  };
84  struct re_dot : public re_syntax_base
85  {
86     unsigned char mask;
87  };
88  struct re_literal : public re_syntax_base
89  {
90     unsigned int length;
91  };
92  struct re_case : public re_syntax_base
93  {
94     bool icase;
95  };
96  template <class mask_type>
97  struct re_set_long : public re_syntax_base
98  {
99     unsigned int            csingles, cranges, cequivalents;
100     mask_type               cclasses;
101     mask_type               cnclasses;
102     bool                    isnot;
103     bool                    singleton;
104  };
105  struct re_set : public re_syntax_base
106  {
107     unsigned char _map[1 << CHAR_BIT];
108  };
109  struct re_jump : public re_syntax_base
110  {
111     offset_type     alt;                 
112  };
113  struct re_alt : public re_jump
114  {
115     unsigned char   _map[1 << CHAR_BIT]; 
116     unsigned int    can_be_null;         
117  };
118  struct re_repeat : public re_alt
119  {
120     std::size_t   min, max;  
121     int           state_id;        
122     bool          leading;   
123     bool          greedy;    
124  };
125  struct re_recurse : public re_jump
126  {
127     int state_id;             
128  };
129  enum commit_type
130  {
131     commit_prune,
132     commit_skip,
133     commit_commit
134  };
135  struct re_commit : public re_syntax_base
136  {
137     commit_type action;
138  };
139  enum re_jump_size_type
140  {
141     re_jump_size = (sizeof(re_jump) + padding_mask) & ~(padding_mask),
142     re_repeater_size = (sizeof(re_repeat) + padding_mask) & ~(padding_mask),
143     re_alt_size = (sizeof(re_alt) + padding_mask) & ~(padding_mask)
144  };
145  template<class charT, class traits>
146  struct regex_data;
147  template <class iterator, class charT, class traits_type, class char_classT>
148  iterator  re_is_set_member(iterator next, 
149                            iterator last, 
150                            const re_set_long<char_classT>* set_, 
151                            const regex_data<charT, traits_type>& e, bool icase);
152  } 
153  } 
154  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_test.cc</h3>
            <pre><code>1  #include "absl/time/time.h"
2  #if defined(_MSC_VER)
3  #include <winsock2.h>  
4  #endif
5  #include <chrono>  
6  #include <cstring>
7  #include <ctime>
8  #include <iomanip>
9  #include <limits>
10  #include <string>
11  #include "gmock/gmock.h"
12  #include "gtest/gtest.h"
13  #include "absl/numeric/int128.h"
14  #include "absl/strings/str_format.h"
15  #include "absl/time/clock.h"
16  #include "absl/time/internal/test_util.h"
17  namespace {
18  #if defined(GTEST_USES_SIMPLE_RE) && GTEST_USES_SIMPLE_RE
19  const char kZoneAbbrRE[] = ".*";  
20  #else
21  const char kZoneAbbrRE[] = "[A-Za-z]{3,4}|[-+][0-9]{2}([0-9]{2})?";
22  #endif
23  #define EXPECT_CIVIL_INFO(ci, y, m, d, h, min, s, off, isdst)      \
24    do {                                                             \
25      EXPECT_EQ(y, ci.cs.year());                                    \
26      EXPECT_EQ(m, ci.cs.month());                                   \
27      EXPECT_EQ(d, ci.cs.day());                                     \
28      EXPECT_EQ(h, ci.cs.hour());                                    \
29      EXPECT_EQ(min, ci.cs.minute());                                \
30      EXPECT_EQ(s, ci.cs.second());                                  \
31      EXPECT_EQ(off, ci.offset);                                     \
32      EXPECT_EQ(isdst, ci.is_dst);                                   \
33      EXPECT_THAT(ci.zone_abbr, testing::MatchesRegex(kZoneAbbrRE)); \
34    } while (0)
35  MATCHER_P(TimespecMatcher, ts, "") {
36    if (ts.tv_sec == arg.tv_sec && ts.tv_nsec == arg.tv_nsec) return true;
37    *result_listener << "expected: {" << ts.tv_sec << ", " << ts.tv_nsec << "} ";
38    *result_listener << "actual: {" << arg.tv_sec << ", " << arg.tv_nsec << "}";
39    return false;
40  }
41  MATCHER_P(TimevalMatcher, tv, "") {
42    if (tv.tv_sec == arg.tv_sec && tv.tv_usec == arg.tv_usec) return true;
43    *result_listener << "expected: {" << tv.tv_sec << ", " << tv.tv_usec << "} ";
44    *result_listener << "actual: {" << arg.tv_sec << ", " << arg.tv_usec << "}";
45    return false;
46  }
47  TEST(Time, ConstExpr) {
48    constexpr absl::Time t0 = absl::UnixEpoch();
49    static_assert(t0 == absl::Time(), "UnixEpoch");
50    constexpr absl::Time t1 = absl::InfiniteFuture();
51    static_assert(t1 != absl::Time(), "InfiniteFuture");
52    constexpr absl::Time t2 = absl::InfinitePast();
53    static_assert(t2 != absl::Time(), "InfinitePast");
54    constexpr absl::Time t3 = absl::FromUnixNanos(0);
55    static_assert(t3 == absl::Time(), "FromUnixNanos");
56    constexpr absl::Time t4 = absl::FromUnixMicros(0);
57    static_assert(t4 == absl::Time(), "FromUnixMicros");
58    constexpr absl::Time t5 = absl::FromUnixMillis(0);
59    static_assert(t5 == absl::Time(), "FromUnixMillis");
60    constexpr absl::Time t6 = absl::FromUnixSeconds(0);
61    static_assert(t6 == absl::Time(), "FromUnixSeconds");
62    constexpr absl::Time t7 = absl::FromTimeT(0);
63    static_assert(t7 == absl::Time(), "FromTimeT");
64  }
65  TEST(Time, ValueSemantics) {
66    absl::Time a;      
67    absl::Time b = a;  
68    EXPECT_EQ(a, b);
69    absl::Time c(a);  
70    EXPECT_EQ(a, b);
71    EXPECT_EQ(a, c);
72    EXPECT_EQ(b, c);
73    b = c;  
74    EXPECT_EQ(a, b);
75    EXPECT_EQ(a, c);
76    EXPECT_EQ(b, c);
77  }
78  TEST(Time, UnixEpoch) {
79    const auto ci = absl::UTCTimeZone().At(absl::UnixEpoch());
80    EXPECT_EQ(absl::CivilSecond(1970, 1, 1, 0, 0, 0), ci.cs);
81    EXPECT_EQ(absl::ZeroDuration(), ci.subsecond);
82    EXPECT_EQ(absl::Weekday::thursday, absl::GetWeekday(ci.cs));
83  }
84  TEST(Time, Breakdown) {
85    absl::TimeZone tz = absl::time_internal::LoadTimeZone("America/New_York");
86    absl::Time t = absl::UnixEpoch();
87    auto ci = tz.At(t);
88    EXPECT_CIVIL_INFO(ci, 1969, 12, 31, 19, 0, 0, -18000, false);
89    EXPECT_EQ(absl::ZeroDuration(), ci.subsecond);
90    EXPECT_EQ(absl::Weekday::wednesday, absl::GetWeekday(ci.cs));
91    t -= absl::Nanoseconds(1);
92    ci = tz.At(t);
93    EXPECT_CIVIL_INFO(ci, 1969, 12, 31, 18, 59, 59, -18000, false);
94    EXPECT_EQ(absl::Nanoseconds(999999999), ci.subsecond);
95    EXPECT_EQ(absl::Weekday::wednesday, absl::GetWeekday(ci.cs));
96    t += absl::Hours(24) * 2735;
97    t += absl::Hours(18) + absl::Minutes(30) + absl::Seconds(15) +
98         absl::Nanoseconds(9);
99    ci = tz.At(t);
100    EXPECT_CIVIL_INFO(ci, 1977, 6, 28, 14, 30, 15, -14400, true);
101    EXPECT_EQ(8, ci.subsecond / absl::Nanoseconds(1));
102    EXPECT_EQ(absl::Weekday::tuesday, absl::GetWeekday(ci.cs));
103  }
104  TEST(Time, AdditiveOperators) {
105    const absl::Duration d = absl::Nanoseconds(1);
106    const absl::Time t0;
107    const absl::Time t1 = t0 + d;
108    EXPECT_EQ(d, t1 - t0);
109    EXPECT_EQ(-d, t0 - t1);
110    EXPECT_EQ(t0, t1 - d);
111    absl::Time t(t0);
112    EXPECT_EQ(t0, t);
113    t += d;
114    EXPECT_EQ(t0 + d, t);
115    EXPECT_EQ(d, t - t0);
116    t -= d;
117    EXPECT_EQ(t0, t);
118    t = absl::UnixEpoch();
119    t += absl::Milliseconds(500);
120    EXPECT_EQ(absl::UnixEpoch() + absl::Milliseconds(500), t);
121    t += absl::Milliseconds(600);
122    EXPECT_EQ(absl::UnixEpoch() + absl::Milliseconds(1100), t);
123    t -= absl::Milliseconds(600);
124    EXPECT_EQ(absl::UnixEpoch() + absl::Milliseconds(500), t);
125    t -= absl::Milliseconds(500);
126    EXPECT_EQ(absl::UnixEpoch(), t);
127  }
128  TEST(Time, RelationalOperators) {
129    constexpr absl::Time t1 = absl::FromUnixNanos(0);
130    constexpr absl::Time t2 = absl::FromUnixNanos(1);
131    constexpr absl::Time t3 = absl::FromUnixNanos(2);
132    static_assert(absl::Time() == t1, "");
133    static_assert(t1 == t1, "");
134    static_assert(t2 == t2, "");
135    static_assert(t3 == t3, "");
136    static_assert(t1 < t2, "");
137    static_assert(t2 < t3, "");
138    static_assert(t1 < t3, "");
139    static_assert(t1 <= t1, "");
140    static_assert(t1 <= t2, "");
141    static_assert(t2 <= t2, "");
142    static_assert(t2 <= t3, "");
143    static_assert(t3 <= t3, "");
144    static_assert(t1 <= t3, "");
145    static_assert(t2 > t1, "");
146    static_assert(t3 > t2, "");
147    static_assert(t3 > t1, "");
148    static_assert(t2 >= t2, "");
149    static_assert(t2 >= t1, "");
150    static_assert(t3 >= t3, "");
151    static_assert(t3 >= t2, "");
152    static_assert(t1 >= t1, "");
153    static_assert(t3 >= t1, "");
154  }
155  TEST(Time, Infinity) {
156    constexpr absl::Time ifuture = absl::InfiniteFuture();
157    constexpr absl::Time ipast = absl::InfinitePast();
158    static_assert(ifuture == ifuture, "");
159    static_assert(ipast == ipast, "");
160    static_assert(ipast < ifuture, "");
161    static_assert(ifuture > ipast, "");
162    EXPECT_EQ(ifuture, ifuture + absl::Seconds(1));
163    EXPECT_EQ(ifuture, ifuture - absl::Seconds(1));
164    EXPECT_EQ(ipast, ipast + absl::Seconds(1));
165    EXPECT_EQ(ipast, ipast - absl::Seconds(1));
166    EXPECT_EQ(absl::InfiniteDuration(), ifuture - ifuture);
167    EXPECT_EQ(absl::InfiniteDuration(), ifuture - ipast);
168    EXPECT_EQ(-absl::InfiniteDuration(), ipast - ifuture);
169    EXPECT_EQ(-absl::InfiniteDuration(), ipast - ipast);
170    constexpr absl::Time t = absl::UnixEpoch();  
171    static_assert(t < ifuture, "");
172    static_assert(t > ipast, "");
173    EXPECT_EQ(ifuture, t + absl::InfiniteDuration());
174    EXPECT_EQ(ipast, t - absl::InfiniteDuration());
175  }
176  TEST(Time, FloorConversion) {
177  #define TEST_FLOOR_CONVERSION(TO, FROM) \
178    EXPECT_EQ(1, TO(FROM(1001)));         \
179    EXPECT_EQ(1, TO(FROM(1000)));         \
180    EXPECT_EQ(0, TO(FROM(999)));          \
181    EXPECT_EQ(0, TO(FROM(1)));            \
182    EXPECT_EQ(0, TO(FROM(0)));            \
183    EXPECT_EQ(-1, TO(FROM(-1)));          \
184    EXPECT_EQ(-1, TO(FROM(-999)));        \
185    EXPECT_EQ(-1, TO(FROM(-1000)));       \
186    EXPECT_EQ(-2, TO(FROM(-1001)));
187    TEST_FLOOR_CONVERSION(absl::ToUnixMicros, absl::FromUnixNanos);
188    TEST_FLOOR_CONVERSION(absl::ToUnixMillis, absl::FromUnixMicros);
189    TEST_FLOOR_CONVERSION(absl::ToUnixSeconds, absl::FromUnixMillis);
190    TEST_FLOOR_CONVERSION(absl::ToTimeT, absl::FromUnixMillis);
191  #undef TEST_FLOOR_CONVERSION
192    EXPECT_EQ(1, absl::ToUnixNanos(absl::UnixEpoch() + absl::Nanoseconds(3) / 2));
193    EXPECT_EQ(1, absl::ToUnixNanos(absl::UnixEpoch() + absl::Nanoseconds(1)));
194    EXPECT_EQ(0, absl::ToUnixNanos(absl::UnixEpoch() + absl::Nanoseconds(1) / 2));
195    EXPECT_EQ(0, absl::ToUnixNanos(absl::UnixEpoch() + absl::Nanoseconds(0)));
196    EXPECT_EQ(-1,
197              absl::ToUnixNanos(absl::UnixEpoch() - absl::Nanoseconds(1) / 2));
198    EXPECT_EQ(-1, absl::ToUnixNanos(absl::UnixEpoch() - absl::Nanoseconds(1)));
199    EXPECT_EQ(-2,
200              absl::ToUnixNanos(absl::UnixEpoch() - absl::Nanoseconds(3) / 2));
201    EXPECT_EQ(1,
202              absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(101)));
203    EXPECT_EQ(1,
204              absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(100)));
205    EXPECT_EQ(0,
206              absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(99)));
207    EXPECT_EQ(0,
208              absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(1)));
209    EXPECT_EQ(0,
210              absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(0)));
211    EXPECT_EQ(-1,
212              absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(-1)));
213    EXPECT_EQ(-1,
214              absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(-99)));
215    EXPECT_EQ(
216        -1, absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(-100)));
217    EXPECT_EQ(
218        -2, absl::ToUniversal(absl::UniversalEpoch() + absl::Nanoseconds(-101)));
219    const struct {
220      absl::Time t;
221      timespec ts;
222    } to_ts[] = {
223        {absl::FromUnixSeconds(1) + absl::Nanoseconds(1), {1, 1}},
224        {absl::FromUnixSeconds(1) + absl::Nanoseconds(1) / 2, {1, 0}},
225        {absl::FromUnixSeconds(1) + absl::Nanoseconds(0), {1, 0}},
226        {absl::FromUnixSeconds(0) + absl::Nanoseconds(0), {0, 0}},
227        {absl::FromUnixSeconds(0) - absl::Nanoseconds(1) / 2, {-1, 999999999}},
228        {absl::FromUnixSeconds(0) - absl::Nanoseconds(1), {-1, 999999999}},
229        {absl::FromUnixSeconds(-1) + absl::Nanoseconds(1), {-1, 1}},
230        {absl::FromUnixSeconds(-1) + absl::Nanoseconds(1) / 2, {-1, 0}},
231        {absl::FromUnixSeconds(-1) + absl::Nanoseconds(0), {-1, 0}},
232        {absl::FromUnixSeconds(-1) - absl::Nanoseconds(1) / 2, {-2, 999999999}},
233    };
234    for (const auto& test : to_ts) {
235      EXPECT_THAT(absl::ToTimespec(test.t), TimespecMatcher(test.ts));
236    }
237    const struct {
238      timespec ts;
239      absl::Time t;
240    } from_ts[] = {
241        {{1, 1}, absl::FromUnixSeconds(1) + absl::Nanoseconds(1)},
242        {{1, 0}, absl::FromUnixSeconds(1) + absl::Nanoseconds(0)},
243        {{0, 0}, absl::FromUnixSeconds(0) + absl::Nanoseconds(0)},
244        {{0, -1}, absl::FromUnixSeconds(0) - absl::Nanoseconds(1)},
245        {{-1, 999999999}, absl::FromUnixSeconds(0) - absl::Nanoseconds(1)},
246        {{-1, 1}, absl::FromUnixSeconds(-1) + absl::Nanoseconds(1)},
247        {{-1, 0}, absl::FromUnixSeconds(-1) + absl::Nanoseconds(0)},
248        {{-1, -1}, absl::FromUnixSeconds(-1) - absl::Nanoseconds(1)},
249        {{-2, 999999999}, absl::FromUnixSeconds(-1) - absl::Nanoseconds(1)},
250    };
251    for (const auto& test : from_ts) {
252      EXPECT_EQ(test.t, absl::TimeFromTimespec(test.ts));
253    }
254    const struct {
255      absl::Time t;
256      timeval tv;
257    } to_tv[] = {
258        {absl::FromUnixSeconds(1) + absl::Microseconds(1), {1, 1}},
259        {absl::FromUnixSeconds(1) + absl::Microseconds(1) / 2, {1, 0}},
260        {absl::FromUnixSeconds(1) + absl::Microseconds(0), {1, 0}},
261        {absl::FromUnixSeconds(0) + absl::Microseconds(0), {0, 0}},
262        {absl::FromUnixSeconds(0) - absl::Microseconds(1) / 2, {-1, 999999}},
263        {absl::FromUnixSeconds(0) - absl::Microseconds(1), {-1, 999999}},
264        {absl::FromUnixSeconds(-1) + absl::Microseconds(1), {-1, 1}},
265        {absl::FromUnixSeconds(-1) + absl::Microseconds(1) / 2, {-1, 0}},
266        {absl::FromUnixSeconds(-1) + absl::Microseconds(0), {-1, 0}},
267        {absl::FromUnixSeconds(-1) - absl::Microseconds(1) / 2, {-2, 999999}},
268    };
269    for (const auto& test : to_tv) {
270      EXPECT_THAT(ToTimeval(test.t), TimevalMatcher(test.tv));
271    }
272    const struct {
273      timeval tv;
274      absl::Time t;
275    } from_tv[] = {
276        {{1, 1}, absl::FromUnixSeconds(1) + absl::Microseconds(1)},
277        {{1, 0}, absl::FromUnixSeconds(1) + absl::Microseconds(0)},
278        {{0, 0}, absl::FromUnixSeconds(0) + absl::Microseconds(0)},
279        {{0, -1}, absl::FromUnixSeconds(0) - absl::Microseconds(1)},
280        {{-1, 999999}, absl::FromUnixSeconds(0) - absl::Microseconds(1)},
281        {{-1, 1}, absl::FromUnixSeconds(-1) + absl::Microseconds(1)},
282        {{-1, 0}, absl::FromUnixSeconds(-1) + absl::Microseconds(0)},
283        {{-1, -1}, absl::FromUnixSeconds(-1) - absl::Microseconds(1)},
284        {{-2, 999999}, absl::FromUnixSeconds(-1) - absl::Microseconds(1)},
285    };
286    for (const auto& test : from_tv) {
287      EXPECT_EQ(test.t, absl::TimeFromTimeval(test.tv));
288    }
289    const int64_t min_plus_1 = std::numeric_limits<int64_t>::min() + 1;
290    EXPECT_EQ(min_plus_1, absl::ToUnixSeconds(absl::FromUnixSeconds(min_plus_1)));
291    EXPECT_EQ(std::numeric_limits<int64_t>::min(),
292              absl::ToUnixSeconds(absl::FromUnixSeconds(min_plus_1) -
293                                  absl::Nanoseconds(1) / 2));
294    EXPECT_EQ(std::numeric_limits<int64_t>::max(),
295              absl::ToUnixSeconds(
296                  absl::FromUnixSeconds(std::numeric_limits<int64_t>::max()) +
297                  absl::Nanoseconds(1) / 2));
298    EXPECT_EQ(std::numeric_limits<int64_t>::max(),
299              absl::ToUnixSeconds(
300                  absl::FromUnixSeconds(std::numeric_limits<int64_t>::max())));
301    EXPECT_EQ(std::numeric_limits<int64_t>::max() - 1,
302              absl::ToUnixSeconds(
303                  absl::FromUnixSeconds(std::numeric_limits<int64_t>::max()) -
304                  absl::Nanoseconds(1) / 2));
305  }
306  TEST(Time, RoundtripConversion) {
307  #define TEST_CONVERSION_ROUND_TRIP(SOURCE, FROM, TO, MATCHER) \
308    EXPECT_THAT(TO(FROM(SOURCE)), MATCHER(SOURCE))
309    int64_t now_ns = absl::GetCurrentTimeNanos();
310    TEST_CONVERSION_ROUND_TRIP(-1, absl::FromUnixNanos, absl::ToUnixNanos,
311                               testing::Eq);
312    TEST_CONVERSION_ROUND_TRIP(0, absl::FromUnixNanos, absl::ToUnixNanos,
313                               testing::Eq);
314    TEST_CONVERSION_ROUND_TRIP(1, absl::FromUnixNanos, absl::ToUnixNanos,
315                               testing::Eq);
316    TEST_CONVERSION_ROUND_TRIP(now_ns, absl::FromUnixNanos, absl::ToUnixNanos,
317                               testing::Eq)
318        << now_ns;
319    int64_t now_us = absl::GetCurrentTimeNanos() / 1000;
320    TEST_CONVERSION_ROUND_TRIP(-1, absl::FromUnixMicros, absl::ToUnixMicros,
321                               testing::Eq);
322    TEST_CONVERSION_ROUND_TRIP(0, absl::FromUnixMicros, absl::ToUnixMicros,
323                               testing::Eq);
324    TEST_CONVERSION_ROUND_TRIP(1, absl::FromUnixMicros, absl::ToUnixMicros,
325                               testing::Eq);
326    TEST_CONVERSION_ROUND_TRIP(now_us, absl::FromUnixMicros, absl::ToUnixMicros,
327                               testing::Eq)
328        << now_us;
329    int64_t now_ms = absl::GetCurrentTimeNanos() / 1000000;
330    TEST_CONVERSION_ROUND_TRIP(-1, absl::FromUnixMillis, absl::ToUnixMillis,
331                               testing::Eq);
332    TEST_CONVERSION_ROUND_TRIP(0, absl::FromUnixMillis, absl::ToUnixMillis,
333                               testing::Eq);
334    TEST_CONVERSION_ROUND_TRIP(1, absl::FromUnixMillis, absl::ToUnixMillis,
335                               testing::Eq);
336    TEST_CONVERSION_ROUND_TRIP(now_ms, absl::FromUnixMillis, absl::ToUnixMillis,
337                               testing::Eq)
338        << now_ms;
339    int64_t now_s = std::time(nullptr);
340    TEST_CONVERSION_ROUND_TRIP(-1, absl::FromUnixSeconds, absl::ToUnixSeconds,
341                               testing::Eq);
342    TEST_CONVERSION_ROUND_TRIP(0, absl::FromUnixSeconds, absl::ToUnixSeconds,
343                               testing::Eq);
344    TEST_CONVERSION_ROUND_TRIP(1, absl::FromUnixSeconds, absl::ToUnixSeconds,
345                               testing::Eq);
346    TEST_CONVERSION_ROUND_TRIP(now_s, absl::FromUnixSeconds, absl::ToUnixSeconds,
347                               testing::Eq)
348        << now_s;
349    time_t now_time_t = std::time(nullptr);
350    TEST_CONVERSION_ROUND_TRIP(-1, absl::FromTimeT, absl::ToTimeT, testing::Eq);
351    TEST_CONVERSION_ROUND_TRIP(0, absl::FromTimeT, absl::ToTimeT, testing::Eq);
352    TEST_CONVERSION_ROUND_TRIP(1, absl::FromTimeT, absl::ToTimeT, testing::Eq);
353    TEST_CONVERSION_ROUND_TRIP(now_time_t, absl::FromTimeT, absl::ToTimeT,
354                               testing::Eq)
355        << now_time_t;
356    timeval tv;
357    tv.tv_sec = -1;
358    tv.tv_usec = 0;
359    TEST_CONVERSION_ROUND_TRIP(tv, absl::TimeFromTimeval, absl::ToTimeval,
360                               TimevalMatcher);
361    tv.tv_sec = -1;
362    tv.tv_usec = 999999;
363    TEST_CONVERSION_ROUND_TRIP(tv, absl::TimeFromTimeval, absl::ToTimeval,
364                               TimevalMatcher);
365    tv.tv_sec = 0;
366    tv.tv_usec = 0;
367    TEST_CONVERSION_ROUND_TRIP(tv, absl::TimeFromTimeval, absl::ToTimeval,
368                               TimevalMatcher);
369    tv.tv_sec = 0;
370    tv.tv_usec = 1;
371    TEST_CONVERSION_ROUND_TRIP(tv, absl::TimeFromTimeval, absl::ToTimeval,
372                               TimevalMatcher);
373    tv.tv_sec = 1;
374    tv.tv_usec = 0;
375    TEST_CONVERSION_ROUND_TRIP(tv, absl::TimeFromTimeval, absl::ToTimeval,
376                               TimevalMatcher);
377    timespec ts;
378    ts.tv_sec = -1;
379    ts.tv_nsec = 0;
380    TEST_CONVERSION_ROUND_TRIP(ts, absl::TimeFromTimespec, absl::ToTimespec,
381                               TimespecMatcher);
382    ts.tv_sec = -1;
383    ts.tv_nsec = 999999999;
384    TEST_CONVERSION_ROUND_TRIP(ts, absl::TimeFromTimespec, absl::ToTimespec,
385                               TimespecMatcher);
386    ts.tv_sec = 0;
387    ts.tv_nsec = 0;
388    TEST_CONVERSION_ROUND_TRIP(ts, absl::TimeFromTimespec, absl::ToTimespec,
389                               TimespecMatcher);
390    ts.tv_sec = 0;
391    ts.tv_nsec = 1;
392    TEST_CONVERSION_ROUND_TRIP(ts, absl::TimeFromTimespec, absl::ToTimespec,
393                               TimespecMatcher);
394    ts.tv_sec = 1;
395    ts.tv_nsec = 0;
396    TEST_CONVERSION_ROUND_TRIP(ts, absl::TimeFromTimespec, absl::ToTimespec,
397                               TimespecMatcher);
398    double now_ud = absl::GetCurrentTimeNanos() / 1000000;
399    TEST_CONVERSION_ROUND_TRIP(-1.5, absl::FromUDate, absl::ToUDate,
400                               testing::DoubleEq);
401    TEST_CONVERSION_ROUND_TRIP(-1, absl::FromUDate, absl::ToUDate,
402                               testing::DoubleEq);
403    TEST_CONVERSION_ROUND_TRIP(-0.5, absl::FromUDate, absl::ToUDate,
404                               testing::DoubleEq);
405    TEST_CONVERSION_ROUND_TRIP(0, absl::FromUDate, absl::ToUDate,
406                               testing::DoubleEq);
407    TEST_CONVERSION_ROUND_TRIP(0.5, absl::FromUDate, absl::ToUDate,
408                               testing::DoubleEq);
409    TEST_CONVERSION_ROUND_TRIP(1, absl::FromUDate, absl::ToUDate,
410                               testing::DoubleEq);
411    TEST_CONVERSION_ROUND_TRIP(1.5, absl::FromUDate, absl::ToUDate,
412                               testing::DoubleEq);
413    TEST_CONVERSION_ROUND_TRIP(now_ud, absl::FromUDate, absl::ToUDate,
414                               testing::DoubleEq)
415        << std::fixed << std::setprecision(17) << now_ud;
416    int64_t now_uni = ((719162LL * (24 * 60 * 60)) * (1000 * 1000 * 10)) +
417                      (absl::GetCurrentTimeNanos() / 100);
418    TEST_CONVERSION_ROUND_TRIP(-1, absl::FromUniversal, absl::ToUniversal,
419                               testing::Eq);
420    TEST_CONVERSION_ROUND_TRIP(0, absl::FromUniversal, absl::ToUniversal,
421                               testing::Eq);
422    TEST_CONVERSION_ROUND_TRIP(1, absl::FromUniversal, absl::ToUniversal,
423                               testing::Eq);
424    TEST_CONVERSION_ROUND_TRIP(now_uni, absl::FromUniversal, absl::ToUniversal,
425                               testing::Eq)
426        << now_uni;
427  #undef TEST_CONVERSION_ROUND_TRIP
428  }
429  template <typename Duration>
430  std::chrono::system_clock::time_point MakeChronoUnixTime(const Duration& d) {
431    return std::chrono::system_clock::from_time_t(0) + d;
432  }
433  TEST(Time, FromChrono) {
434    EXPECT_EQ(absl::FromTimeT(-1),
435              absl::FromChrono(std::chrono::system_clock::from_time_t(-1)));
436    EXPECT_EQ(absl::FromTimeT(0),
437              absl::FromChrono(std::chrono::system_clock::from_time_t(0)));
438    EXPECT_EQ(absl::FromTimeT(1),
439              absl::FromChrono(std::chrono::system_clock::from_time_t(1)));
440    EXPECT_EQ(
441        absl::FromUnixMillis(-1),
442        absl::FromChrono(MakeChronoUnixTime(std::chrono::milliseconds(-1))));
443    EXPECT_EQ(absl::FromUnixMillis(0),
444              absl::FromChrono(MakeChronoUnixTime(std::chrono::milliseconds(0))));
445    EXPECT_EQ(absl::FromUnixMillis(1),
446              absl::FromChrono(MakeChronoUnixTime(std::chrono::milliseconds(1))));
447    const auto century_sec = 60 * 60 * 24 * 365 * int64_t{100};
448    const auto century = std::chrono::seconds(century_sec);
449    const auto chrono_future = MakeChronoUnixTime(century);
450    const auto chrono_past = MakeChronoUnixTime(-century);
451    EXPECT_EQ(absl::FromUnixSeconds(century_sec),
452              absl::FromChrono(chrono_future));
453    EXPECT_EQ(absl::FromUnixSeconds(-century_sec), absl::FromChrono(chrono_past));
454    EXPECT_EQ(chrono_future,
455              absl::ToChronoTime(absl::FromUnixSeconds(century_sec)));
456    EXPECT_EQ(chrono_past,
457              absl::ToChronoTime(absl::FromUnixSeconds(-century_sec)));
458  }
459  TEST(Time, ToChronoTime) {
460    EXPECT_EQ(std::chrono::system_clock::from_time_t(-1),
461              absl::ToChronoTime(absl::FromTimeT(-1)));
462    EXPECT_EQ(std::chrono::system_clock::from_time_t(0),
463              absl::ToChronoTime(absl::FromTimeT(0)));
464    EXPECT_EQ(std::chrono::system_clock::from_time_t(1),
465              absl::ToChronoTime(absl::FromTimeT(1)));
466    EXPECT_EQ(MakeChronoUnixTime(std::chrono::milliseconds(-1)),
467              absl::ToChronoTime(absl::FromUnixMillis(-1)));
468    EXPECT_EQ(MakeChronoUnixTime(std::chrono::milliseconds(0)),
469              absl::ToChronoTime(absl::FromUnixMillis(0)));
470    EXPECT_EQ(MakeChronoUnixTime(std::chrono::milliseconds(1)),
471              absl::ToChronoTime(absl::FromUnixMillis(1)));
472    const auto tick = absl::Nanoseconds(1) / 4;
473    EXPECT_EQ(std::chrono::system_clock::from_time_t(0) -
474                  std::chrono::system_clock::duration(1),
475              absl::ToChronoTime(absl::UnixEpoch() - tick));
476  }
477  TEST(Time, Chrono128) {
478    using Timestamp =
479        std::chrono::time_point<std::chrono::system_clock,
480                                std::chrono::duration<absl::int128, std::atto>>;
481    for (const auto tp : {std::chrono::system_clock::time_point::min(),
482                          std::chrono::system_clock::time_point::max()}) {
483      EXPECT_EQ(tp, absl::ToChronoTime(absl::FromChrono(tp)));
484      EXPECT_EQ(tp, std::chrono::time_point_cast<
485                        std::chrono::system_clock::time_point::duration>(
486                        std::chrono::time_point_cast<Timestamp::duration>(tp)));
487    }
488    Timestamp::duration::rep v = std::numeric_limits<int64_t>::min();
489    v *= Timestamp::duration::period::den;
490    auto ts = Timestamp(Timestamp::duration(v));
491    ts += std::chrono::duration<int64_t, std::atto>(0);
492    EXPECT_EQ(std::numeric_limits<int64_t>::min(),
493              ts.time_since_epoch().count() / Timestamp::duration::period::den);
494    EXPECT_EQ(0,
495              ts.time_since_epoch().count() % Timestamp::duration::period::den);
496    v = std::numeric_limits<int64_t>::max();
497    v *= Timestamp::duration::period::den;
498    ts = Timestamp(Timestamp::duration(v));
499    ts += std::chrono::duration<int64_t, std::atto>(999999999750000000);
500    EXPECT_EQ(std::numeric_limits<int64_t>::max(),
501              ts.time_since_epoch().count() / Timestamp::duration::period::den);
502    EXPECT_EQ(999999999750000000,
503              ts.time_since_epoch().count() % Timestamp::duration::period::den);
504  }
505  TEST(Time, TimeZoneAt) {
506    const absl::TimeZone nyc =
507        absl::time_internal::LoadTimeZone("America/New_York");
508    const std::string fmt = "%a, %e %b %Y %H:%M:%S %z (%Z)";
509    absl::CivilSecond nov01(2013, 11, 1, 8, 30, 0);
510    const auto nov01_ci = nyc.At(nov01);
511    EXPECT_EQ(absl::TimeZone::TimeInfo::UNIQUE, nov01_ci.kind);
512    EXPECT_EQ("Fri,  1 Nov 2013 08:30:00 -0400 (EDT)",
513              absl::FormatTime(fmt, nov01_ci.pre, nyc));
514    EXPECT_EQ(nov01_ci.pre, nov01_ci.trans);
515    EXPECT_EQ(nov01_ci.pre, nov01_ci.post);
516    EXPECT_EQ(nov01_ci.pre, absl::FromCivil(nov01, nyc));
517    absl::CivilSecond mar13(2011, 3, 13, 2, 15, 0);
518    const auto mar_ci = nyc.At(mar13);
519    EXPECT_EQ(absl::TimeZone::TimeInfo::SKIPPED, mar_ci.kind);
520    EXPECT_EQ("Sun, 13 Mar 2011 03:15:00 -0400 (EDT)",
521              absl::FormatTime(fmt, mar_ci.pre, nyc));
522    EXPECT_EQ("Sun, 13 Mar 2011 03:00:00 -0400 (EDT)",
523              absl::FormatTime(fmt, mar_ci.trans, nyc));
524    EXPECT_EQ("Sun, 13 Mar 2011 01:15:00 -0500 (EST)",
525              absl::FormatTime(fmt, mar_ci.post, nyc));
526    EXPECT_EQ(mar_ci.trans, absl::FromCivil(mar13, nyc));
527    absl::CivilSecond nov06(2011, 11, 6, 1, 15, 0);
528    const auto nov06_ci = nyc.At(nov06);
529    EXPECT_EQ(absl::TimeZone::TimeInfo::REPEATED, nov06_ci.kind);
530    EXPECT_EQ("Sun,  6 Nov 2011 01:15:00 -0400 (EDT)",
531              absl::FormatTime(fmt, nov06_ci.pre, nyc));
532    EXPECT_EQ("Sun,  6 Nov 2011 01:00:00 -0500 (EST)",
533              absl::FormatTime(fmt, nov06_ci.trans, nyc));
534    EXPECT_EQ("Sun,  6 Nov 2011 01:15:00 -0500 (EST)",
535              absl::FormatTime(fmt, nov06_ci.post, nyc));
536    EXPECT_EQ(nov06_ci.pre, absl::FromCivil(nov06, nyc));
537    absl::CivilSecond minus1(1969, 12, 31, 18, 59, 59);
538    const auto minus1_cl = nyc.At(minus1);
539    EXPECT_EQ(absl::TimeZone::TimeInfo::UNIQUE, minus1_cl.kind);
540    EXPECT_EQ(-1, absl::ToTimeT(minus1_cl.pre));
541    EXPECT_EQ("Wed, 31 Dec 1969 18:59:59 -0500 (EST)",
542              absl::FormatTime(fmt, minus1_cl.pre, nyc));
543    EXPECT_EQ("Wed, 31 Dec 1969 23:59:59 +0000 (UTC)",
544              absl::FormatTime(fmt, minus1_cl.pre, absl::UTCTimeZone()));
545  }
546  TEST(Time, FromCivilUTC) {
547    const absl::TimeZone utc = absl::UTCTimeZone();
548    const std::string fmt = "%a, %e %b %Y %H:%M:%S %z (%Z)";
549    const int kMax = std::numeric_limits<int>::max();
550    const int kMin = std::numeric_limits<int>::min();
551    absl::Time t;
552    t = absl::FromCivil(
553        absl::CivilSecond(292091940881, kMax, kMax, kMax, kMax, kMax), utc);
554    EXPECT_EQ("Fri, 25 Nov 292277026596 12:21:07 +0000 (UTC)",
555              absl::FormatTime(fmt, t, utc));
556    t = absl::FromCivil(
557        absl::CivilSecond(292091940882, kMax, kMax, kMax, kMax, kMax), utc);
558    EXPECT_EQ("infinite-future", absl::FormatTime(fmt, t, utc));  
559    t = absl::FromCivil(
560        absl::CivilSecond(-292091936940, kMin, kMin, kMin, kMin, kMin), utc);
561    EXPECT_EQ("Fri,  1 Nov -292277022657 10:37:52 +0000 (UTC)",
562              absl::FormatTime(fmt, t, utc));
563    t = absl::FromCivil(
564        absl::CivilSecond(-292091936941, kMin, kMin, kMin, kMin, kMin), utc);
565    EXPECT_EQ("infinite-past", absl::FormatTime(fmt, t, utc));  
566    t = absl::FromCivil(absl::CivilSecond(1900, 2, 28, 23, 59, 59), utc);
567    EXPECT_EQ("Wed, 28 Feb 1900 23:59:59 +0000 (UTC)",
568              absl::FormatTime(fmt, t, utc));
569    t = absl::FromCivil(absl::CivilSecond(1900, 3, 1, 0, 0, 0), utc);
570    EXPECT_EQ("Thu,  1 Mar 1900 00:00:00 +0000 (UTC)",
571              absl::FormatTime(fmt, t, utc));
572    t = absl::FromCivil(absl::CivilSecond(2000, 2, 29, 23, 59, 59), utc);
573    EXPECT_EQ("Tue, 29 Feb 2000 23:59:59 +0000 (UTC)",
574              absl::FormatTime(fmt, t, utc));
575    t = absl::FromCivil(absl::CivilSecond(2000, 3, 1, 0, 0, 0), utc);
576    EXPECT_EQ("Wed,  1 Mar 2000 00:00:00 +0000 (UTC)",
577              absl::FormatTime(fmt, t, utc));
578  }
579  TEST(Time, ToTM) {
580    const absl::TimeZone utc = absl::UTCTimeZone();
581    const absl::Time start =
582        absl::FromCivil(absl::CivilSecond(2014, 1, 2, 3, 4, 5), utc);
583    const absl::Time end =
584        absl::FromCivil(absl::CivilSecond(2014, 1, 5, 3, 4, 5), utc);
585    for (absl::Time t = start; t < end; t += absl::Seconds(30)) {
586      const struct tm tm_bt = ToTM(t, utc);
587      const time_t tt = absl::ToTimeT(t);
588      struct tm tm_lc;
589  #ifdef _WIN32
590      gmtime_s(&tm_lc, &tt);
591  #else
592      gmtime_r(&tt, &tm_lc);
593  #endif
594      EXPECT_EQ(tm_lc.tm_year, tm_bt.tm_year);
595      EXPECT_EQ(tm_lc.tm_mon, tm_bt.tm_mon);
596      EXPECT_EQ(tm_lc.tm_mday, tm_bt.tm_mday);
597      EXPECT_EQ(tm_lc.tm_hour, tm_bt.tm_hour);
598      EXPECT_EQ(tm_lc.tm_min, tm_bt.tm_min);
599      EXPECT_EQ(tm_lc.tm_sec, tm_bt.tm_sec);
600      EXPECT_EQ(tm_lc.tm_wday, tm_bt.tm_wday);
601      EXPECT_EQ(tm_lc.tm_yday, tm_bt.tm_yday);
602      EXPECT_EQ(tm_lc.tm_isdst, tm_bt.tm_isdst);
603      ASSERT_FALSE(HasFailure());
604    }
605    const absl::TimeZone nyc =
606        absl::time_internal::LoadTimeZone("America/New_York");
607    absl::Time t = absl::FromCivil(absl::CivilSecond(2014, 3, 1, 0, 0, 0), nyc);
608    struct tm tm = ToTM(t, nyc);
609    EXPECT_FALSE(tm.tm_isdst);
610    t = absl::FromCivil(absl::CivilSecond(2014, 4, 1, 0, 0, 0), nyc);
611    tm = ToTM(t, nyc);
612    EXPECT_TRUE(tm.tm_isdst);
613    tm = ToTM(absl::InfiniteFuture(), nyc);
614    EXPECT_EQ(std::numeric_limits<int>::max() - 1900, tm.tm_year);
615    EXPECT_EQ(11, tm.tm_mon);
616    EXPECT_EQ(31, tm.tm_mday);
617    EXPECT_EQ(23, tm.tm_hour);
618    EXPECT_EQ(59, tm.tm_min);
619    EXPECT_EQ(59, tm.tm_sec);
620    EXPECT_EQ(4, tm.tm_wday);
621    EXPECT_EQ(364, tm.tm_yday);
622    EXPECT_FALSE(tm.tm_isdst);
623    tm = ToTM(absl::InfinitePast(), nyc);
624    EXPECT_EQ(std::numeric_limits<int>::min(), tm.tm_year);
625    EXPECT_EQ(0, tm.tm_mon);
626    EXPECT_EQ(1, tm.tm_mday);
627    EXPECT_EQ(0, tm.tm_hour);
628    EXPECT_EQ(0, tm.tm_min);
629    EXPECT_EQ(0, tm.tm_sec);
630    EXPECT_EQ(0, tm.tm_wday);
631    EXPECT_EQ(0, tm.tm_yday);
632    EXPECT_FALSE(tm.tm_isdst);
633  }
634  TEST(Time, FromTM) {
635    const absl::TimeZone nyc =
636        absl::time_internal::LoadTimeZone("America/New_York");
637    struct tm tm;
638    std::memset(&tm, 0, sizeof(tm));
639    tm.tm_year = 2014 - 1900;
640    tm.tm_mon = 6 - 1;
641    tm.tm_mday = 28;
642    tm.tm_hour = 1;
643    tm.tm_min = 2;
644    tm.tm_sec = 3;
645    tm.tm_isdst = -1;
646    absl::Time t = FromTM(tm, nyc);
647    EXPECT_EQ("2014-06-28T01:02:03-04:00", absl::FormatTime(t, nyc));  
648    tm.tm_isdst = 0;
649    t = FromTM(tm, nyc);
650    EXPECT_EQ("2014-06-28T01:02:03-04:00", absl::FormatTime(t, nyc));  
651    tm.tm_isdst = 1;
652    t = FromTM(tm, nyc);
653    EXPECT_EQ("2014-06-28T01:02:03-04:00", absl::FormatTime(t, nyc));  
654    tm.tm_year = 2014 - 1900;
655    tm.tm_mon = 11 - 1;
656    tm.tm_mday = 2;
657    tm.tm_hour = 1;
658    tm.tm_min = 30;
659    tm.tm_sec = 42;
<span onclick='openModal()' class='match'>660    tm.tm_isdst = -1;
661    t = FromTM(tm, nyc);
662    EXPECT_EQ("2014-11-02T01:30:42-04:00", absl::FormatTime(t, nyc));  
663    tm.tm_isdst = 0;
664    t = FromTM(tm, nyc);
665    EXPECT_EQ("2014-11-02T01:30:42-05:00", absl::FormatTime(t, nyc));  
666    tm.tm_isdst = 1;
667    t = FromTM(tm, nyc);
668    EXPECT_EQ("2014-11-02T01:30:42-04:00", absl::FormatTime(t, nyc));  
669    tm.tm_year = 2014 - 1900;
670    tm.tm_mon = 3 - 1;
671    tm.tm_mday = 9;
672    tm.tm_hour = 2;
673    tm.tm_min = 30;
674    tm.tm_sec = 42;
675    tm.tm_isdst = -1;
676    t = FromTM(tm, nyc);
677    EXPECT_EQ("2014-03-09T03:30:42-04:00", absl::FormatTime(t, nyc));  
678    tm.tm_isdst = 0;
679    t = FromTM(tm, nyc);
680    EXPECT_EQ("2014-03-09T01:30:42-05:00", absl::FormatTime(t, nyc));  
681    tm.tm_isdst = 1;
682    t = FromTM(tm, nyc);
683    EXPECT_EQ("2014-03-09T03:30:42-04:00", absl::FormatTime(t, nyc));  
684    tm.tm_year = 2147483647 - 1900 + 1;
685    tm.tm_mon = 6 - 1;
686    tm.tm_mday = 28;
687    tm.tm_hour = 1;
688    tm.tm_min = 2;
689    tm.tm_sec = 3;
690    tm.tm_isdst = -1;
691    t = FromTM(tm, absl::UTCTimeZone());
692    EXPECT_EQ("2147483648-06-28T01:02:03+00:00",
693              absl::FormatTime(t, absl::UTCTimeZone()));
694    tm.tm_year = 2019 - 1900;
695    tm.tm_mon = 2147483647;
696    tm.tm_mday = 28;
697    tm.tm_hour = 1;
698    tm.tm_min = 2;
699    tm.tm_sec = 3;
700    tm.tm_isdst = -1;
701    t = FromTM(tm, absl::UTCTimeZone());
702    EXPECT_EQ("178958989-08-28T01:02:03+00:00",
703              absl::FormatTime(t, absl::UTCTimeZone()));
704  }
</span>705  TEST(Time, TMRoundTrip) {
706    const absl::TimeZone nyc =
707        absl::time_internal::LoadTimeZone("America/New_York");
708    absl::Time start = absl::FromCivil(absl::CivilHour(2014, 3, 9, 0), nyc);
709    absl::Time end = absl::FromCivil(absl::CivilHour(2014, 3, 9, 4), nyc);
710    for (absl::Time t = start; t < end; t += absl::Minutes(1)) {
711      struct tm tm = ToTM(t, nyc);
712      absl::Time rt = FromTM(tm, nyc);
713      EXPECT_EQ(rt, t);
714    }
715    start = absl::FromCivil(absl::CivilHour(2014, 11, 2, 0), nyc);
716    end = absl::FromCivil(absl::CivilHour(2014, 11, 2, 4), nyc);
717    for (absl::Time t = start; t < end; t += absl::Minutes(1)) {
718      struct tm tm = ToTM(t, nyc);
719      absl::Time rt = FromTM(tm, nyc);
720      EXPECT_EQ(rt, t);
721    }
722    start = absl::FromCivil(absl::CivilHour(2014, 6, 27, 22), nyc);
723    end = absl::FromCivil(absl::CivilHour(2014, 6, 28, 4), nyc);
724    for (absl::Time t = start; t < end; t += absl::Minutes(1)) {
725      struct tm tm = ToTM(t, nyc);
726      absl::Time rt = FromTM(tm, nyc);
727      EXPECT_EQ(rt, t);
728    }
729  }
730  TEST(Time, Range) {
731    const absl::Duration range = absl::Hours(24) * 365.2425 * 100000000000;
732    absl::Time bases[2] = {absl::UnixEpoch(), absl::Now()};
733    for (const auto base : bases) {
734      absl::Time bottom = base - range;
735      EXPECT_GT(bottom, bottom - absl::Nanoseconds(1));
736      EXPECT_LT(bottom, bottom + absl::Nanoseconds(1));
737      absl::Time top = base + range;
738      EXPECT_GT(top, top - absl::Nanoseconds(1));
739      EXPECT_LT(top, top + absl::Nanoseconds(1));
740      absl::Duration full_range = 2 * range;
741      EXPECT_EQ(full_range, top - bottom);
742      EXPECT_EQ(-full_range, bottom - top);
743    }
744  }
745  TEST(Time, Limits) {
746    const absl::Time zero;
747    const absl::Time max =
748        zero + absl::Seconds(std::numeric_limits<int64_t>::max()) +
749        absl::Nanoseconds(999999999) + absl::Nanoseconds(3) / 4;
750    const absl::Time min =
751        zero + absl::Seconds(std::numeric_limits<int64_t>::min());
752    EXPECT_LT(max, absl::InfiniteFuture());
753    EXPECT_GT(min, absl::InfinitePast());
754    EXPECT_LT(zero, max);
755    EXPECT_GT(zero, min);
756    EXPECT_GE(absl::UnixEpoch(), min);
757    EXPECT_LT(absl::UnixEpoch(), max);
758    EXPECT_LT(absl::ZeroDuration(), max - zero);
759    EXPECT_LT(absl::ZeroDuration(),
760              zero - absl::Nanoseconds(1) / 4 - min);  
761    EXPECT_GT(max, max - absl::Nanoseconds(1) / 4);
762    EXPECT_LT(min, min + absl::Nanoseconds(1) / 4);
763  }
764  TEST(Time, ConversionSaturation) {
765    const absl::TimeZone utc = absl::UTCTimeZone();
766    absl::Time t;
767    const auto max_time_t = std::numeric_limits<time_t>::max();
768    const auto min_time_t = std::numeric_limits<time_t>::min();
769    time_t tt = max_time_t - 1;
770    t = absl::FromTimeT(tt);
771    tt = absl::ToTimeT(t);
772    EXPECT_EQ(max_time_t - 1, tt);
773    t += absl::Seconds(1);
774    tt = absl::ToTimeT(t);
775    EXPECT_EQ(max_time_t, tt);
776    t += absl::Seconds(1);  
777    tt = absl::ToTimeT(t);
778    EXPECT_EQ(max_time_t, tt);
779    tt = min_time_t + 1;
780    t = absl::FromTimeT(tt);
781    tt = absl::ToTimeT(t);
782    EXPECT_EQ(min_time_t + 1, tt);
783    t -= absl::Seconds(1);
784    tt = absl::ToTimeT(t);
785    EXPECT_EQ(min_time_t, tt);
786    t -= absl::Seconds(1);  
787    tt = absl::ToTimeT(t);
788    EXPECT_EQ(min_time_t, tt);
789    const auto max_timeval_sec =
790        std::numeric_limits<decltype(timeval::tv_sec)>::max();
791    const auto min_timeval_sec =
792        std::numeric_limits<decltype(timeval::tv_sec)>::min();
793    timeval tv;
794    tv.tv_sec = max_timeval_sec;
795    tv.tv_usec = 999998;
796    t = absl::TimeFromTimeval(tv);
797    tv = ToTimeval(t);
798    EXPECT_EQ(max_timeval_sec, tv.tv_sec);
799    EXPECT_EQ(999998, tv.tv_usec);
800    t += absl::Microseconds(1);
801    tv = ToTimeval(t);
802    EXPECT_EQ(max_timeval_sec, tv.tv_sec);
803    EXPECT_EQ(999999, tv.tv_usec);
804    t += absl::Microseconds(1);  
805    tv = ToTimeval(t);
806    EXPECT_EQ(max_timeval_sec, tv.tv_sec);
807    EXPECT_EQ(999999, tv.tv_usec);
808    tv.tv_sec = min_timeval_sec;
809    tv.tv_usec = 1;
810    t = absl::TimeFromTimeval(tv);
811    tv = ToTimeval(t);
812    EXPECT_EQ(min_timeval_sec, tv.tv_sec);
813    EXPECT_EQ(1, tv.tv_usec);
814    t -= absl::Microseconds(1);
815    tv = ToTimeval(t);
816    EXPECT_EQ(min_timeval_sec, tv.tv_sec);
817    EXPECT_EQ(0, tv.tv_usec);
818    t -= absl::Microseconds(1);  
819    tv = ToTimeval(t);
820    EXPECT_EQ(min_timeval_sec, tv.tv_sec);
821    EXPECT_EQ(0, tv.tv_usec);
822    const auto max_timespec_sec =
823        std::numeric_limits<decltype(timespec::tv_sec)>::max();
824    const auto min_timespec_sec =
825        std::numeric_limits<decltype(timespec::tv_sec)>::min();
826    timespec ts;
827    ts.tv_sec = max_timespec_sec;
828    ts.tv_nsec = 999999998;
829    t = absl::TimeFromTimespec(ts);
830    ts = absl::ToTimespec(t);
831    EXPECT_EQ(max_timespec_sec, ts.tv_sec);
832    EXPECT_EQ(999999998, ts.tv_nsec);
833    t += absl::Nanoseconds(1);
834    ts = absl::ToTimespec(t);
835    EXPECT_EQ(max_timespec_sec, ts.tv_sec);
836    EXPECT_EQ(999999999, ts.tv_nsec);
837    t += absl::Nanoseconds(1);  
838    ts = absl::ToTimespec(t);
839    EXPECT_EQ(max_timespec_sec, ts.tv_sec);
840    EXPECT_EQ(999999999, ts.tv_nsec);
841    ts.tv_sec = min_timespec_sec;
842    ts.tv_nsec = 1;
843    t = absl::TimeFromTimespec(ts);
844    ts = absl::ToTimespec(t);
845    EXPECT_EQ(min_timespec_sec, ts.tv_sec);
846    EXPECT_EQ(1, ts.tv_nsec);
847    t -= absl::Nanoseconds(1);
848    ts = absl::ToTimespec(t);
849    EXPECT_EQ(min_timespec_sec, ts.tv_sec);
850    EXPECT_EQ(0, ts.tv_nsec);
851    t -= absl::Nanoseconds(1);  
852    ts = absl::ToTimespec(t);
853    EXPECT_EQ(min_timespec_sec, ts.tv_sec);
854    EXPECT_EQ(0, ts.tv_nsec);
855    auto ci = utc.At(absl::InfiniteFuture());
856    EXPECT_CIVIL_INFO(ci, std::numeric_limits<int64_t>::max(), 12, 31, 23, 59, 59,
857                      0, false);
858    EXPECT_EQ(absl::InfiniteDuration(), ci.subsecond);
859    EXPECT_EQ(absl::Weekday::thursday, absl::GetWeekday(ci.cs));
860    EXPECT_EQ(365, absl::GetYearDay(ci.cs));
861    EXPECT_STREQ("-00", ci.zone_abbr);  
862    ci = utc.At(absl::InfinitePast());
863    EXPECT_CIVIL_INFO(ci, std::numeric_limits<int64_t>::min(), 1, 1, 0, 0, 0, 0,
864                      false);
865    EXPECT_EQ(-absl::InfiniteDuration(), ci.subsecond);
866    EXPECT_EQ(absl::Weekday::sunday, absl::GetWeekday(ci.cs));
867    EXPECT_EQ(1, absl::GetYearDay(ci.cs));
868    EXPECT_STREQ("-00", ci.zone_abbr);  
869    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 4, 15, 30, 6), utc);
870    EXPECT_EQ("292277026596-12-04T15:30:06+00:00",
871              absl::FormatTime(absl::RFC3339_full, t, utc));
872    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 4, 15, 30, 7), utc);
873    EXPECT_EQ("292277026596-12-04T15:30:07+00:00",
874              absl::FormatTime(absl::RFC3339_full, t, utc));
875    EXPECT_EQ(
876        absl::UnixEpoch() + absl::Seconds(std::numeric_limits<int64_t>::max()),
877        t);
878    const absl::TimeZone plus14 = absl::FixedTimeZone(14 * 60 * 60);
879    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 5, 5, 30, 7), plus14);
880    EXPECT_EQ("292277026596-12-05T05:30:07+14:00",
881              absl::FormatTime(absl::RFC3339_full, t, plus14));
882    EXPECT_EQ(
883        absl::UnixEpoch() + absl::Seconds(std::numeric_limits<int64_t>::max()),
884        t);
885    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 4, 15, 30, 8), utc);
886    EXPECT_EQ("infinite-future", absl::FormatTime(absl::RFC3339_full, t, utc));
887    t = absl::FromCivil(absl::CivilSecond(-292277022657, 1, 27, 8, 29, 53), utc);
888    EXPECT_EQ("-292277022657-01-27T08:29:53+00:00",
889              absl::FormatTime(absl::RFC3339_full, t, utc));
890    t = absl::FromCivil(absl::CivilSecond(-292277022657, 1, 27, 8, 29, 52), utc);
891    EXPECT_EQ("-292277022657-01-27T08:29:52+00:00",
892              absl::FormatTime(absl::RFC3339_full, t, utc));
893    EXPECT_EQ(
894        absl::UnixEpoch() + absl::Seconds(std::numeric_limits<int64_t>::min()),
895        t);
896    const absl::TimeZone minus12 = absl::FixedTimeZone(-12 * 60 * 60);
897    t = absl::FromCivil(absl::CivilSecond(-292277022657, 1, 26, 20, 29, 52),
898                        minus12);
899    EXPECT_EQ("-292277022657-01-26T20:29:52-12:00",
900              absl::FormatTime(absl::RFC3339_full, t, minus12));
901    EXPECT_EQ(
902        absl::UnixEpoch() + absl::Seconds(std::numeric_limits<int64_t>::min()),
903        t);
904    t = absl::FromCivil(absl::CivilSecond(-292277022657, 1, 27, 8, 29, 51), utc);
905    EXPECT_EQ("infinite-past", absl::FormatTime(absl::RFC3339_full, t, utc));
906  }
907  TEST(Time, ExtendedConversionSaturation) {
908    const absl::TimeZone syd =
909        absl::time_internal::LoadTimeZone("Australia/Sydney");
910    const absl::TimeZone nyc =
911        absl::time_internal::LoadTimeZone("America/New_York");
912    const absl::Time max =
913        absl::FromUnixSeconds(std::numeric_limits<int64_t>::max());
914    absl::TimeZone::CivilInfo ci;
915    absl::Time t;
916    ci = syd.At(max);
917    EXPECT_CIVIL_INFO(ci, 292277026596, 12, 5, 2, 30, 7, 39600, true);
918    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 5, 2, 30, 7), syd);
919    EXPECT_EQ(max, t);
920    ci = nyc.At(max);
921    EXPECT_CIVIL_INFO(ci, 292277026596, 12, 4, 10, 30, 7, -18000, false);
922    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 4, 10, 30, 7), nyc);
923    EXPECT_EQ(max, t);
924    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 5, 2, 30, 8), syd);
925    EXPECT_EQ(absl::InfiniteFuture(), t);
926    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 4, 10, 30, 8), nyc);
927    EXPECT_EQ(absl::InfiniteFuture(), t);
928    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 5, 2, 30, 9), syd);
929    EXPECT_EQ(absl::InfiniteFuture(), t);
930    t = absl::FromCivil(absl::CivilSecond(292277026596, 12, 4, 10, 30, 9), nyc);
931    EXPECT_EQ(absl::InfiniteFuture(), t);
932    t = absl::FromCivil(absl::CivilSecond::max(), syd);
933    EXPECT_EQ(absl::InfiniteFuture(), t);
934    t = absl::FromCivil(absl::CivilSecond::max(), nyc);
935    EXPECT_EQ(absl::InfiniteFuture(), t);
936  }
937  TEST(Time, FromCivilAlignment) {
938    const absl::TimeZone utc = absl::UTCTimeZone();
939    const absl::CivilSecond cs(2015, 2, 3, 4, 5, 6);
940    absl::Time t = absl::FromCivil(cs, utc);
941    EXPECT_EQ("2015-02-03T04:05:06+00:00", absl::FormatTime(t, utc));
942    t = absl::FromCivil(absl::CivilMinute(cs), utc);
943    EXPECT_EQ("2015-02-03T04:05:00+00:00", absl::FormatTime(t, utc));
944    t = absl::FromCivil(absl::CivilHour(cs), utc);
945    EXPECT_EQ("2015-02-03T04:00:00+00:00", absl::FormatTime(t, utc));
946    t = absl::FromCivil(absl::CivilDay(cs), utc);
947    EXPECT_EQ("2015-02-03T00:00:00+00:00", absl::FormatTime(t, utc));
948    t = absl::FromCivil(absl::CivilMonth(cs), utc);
949    EXPECT_EQ("2015-02-01T00:00:00+00:00", absl::FormatTime(t, utc));
950    t = absl::FromCivil(absl::CivilYear(cs), utc);
951    EXPECT_EQ("2015-01-01T00:00:00+00:00", absl::FormatTime(t, utc));
952  }
953  TEST(Time, LegacyDateTime) {
954    const absl::TimeZone utc = absl::UTCTimeZone();
955    const std::string ymdhms = "%Y-%m-%d %H:%M:%S";
956    const int kMax = std::numeric_limits<int>::max();
957    const int kMin = std::numeric_limits<int>::min();
958    absl::Time t;
959    t = absl::FromDateTime(std::numeric_limits<absl::civil_year_t>::max(), kMax,
960                           kMax, kMax, kMax, kMax, utc);
961    EXPECT_EQ("infinite-future",
962              absl::FormatTime(ymdhms, t, utc));  
963    t = absl::FromDateTime(std::numeric_limits<absl::civil_year_t>::min(), kMin,
964                           kMin, kMin, kMin, kMin, utc);
965    EXPECT_EQ("infinite-past", absl::FormatTime(ymdhms, t, utc));  
966    EXPECT_TRUE(absl::ConvertDateTime(2013, 10, 32, 8, 30, 0, utc).normalized);
967    t = absl::FromDateTime(2015, 1, 1, 0, 0, 60, utc);
968    EXPECT_EQ("2015-01-01 00:01:00", absl::FormatTime(ymdhms, t, utc));
969    t = absl::FromDateTime(2015, 1, 1, 0, 60, 0, utc);
970    EXPECT_EQ("2015-01-01 01:00:00", absl::FormatTime(ymdhms, t, utc));
971    t = absl::FromDateTime(2015, 1, 1, 24, 0, 0, utc);
972    EXPECT_EQ("2015-01-02 00:00:00", absl::FormatTime(ymdhms, t, utc));
973    t = absl::FromDateTime(2015, 1, 32, 0, 0, 0, utc);
974    EXPECT_EQ("2015-02-01 00:00:00", absl::FormatTime(ymdhms, t, utc));
975    t = absl::FromDateTime(2015, 13, 1, 0, 0, 0, utc);
976    EXPECT_EQ("2016-01-01 00:00:00", absl::FormatTime(ymdhms, t, utc));
977    t = absl::FromDateTime(2015, 13, 32, 60, 60, 60, utc);
978    EXPECT_EQ("2016-02-03 13:01:00", absl::FormatTime(ymdhms, t, utc));
979    t = absl::FromDateTime(2015, 1, 1, 0, 0, -1, utc);
980    EXPECT_EQ("2014-12-31 23:59:59", absl::FormatTime(ymdhms, t, utc));
981    t = absl::FromDateTime(2015, 1, 1, 0, -1, 0, utc);
982    EXPECT_EQ("2014-12-31 23:59:00", absl::FormatTime(ymdhms, t, utc));
983    t = absl::FromDateTime(2015, 1, 1, -1, 0, 0, utc);
984    EXPECT_EQ("2014-12-31 23:00:00", absl::FormatTime(ymdhms, t, utc));
985    t = absl::FromDateTime(2015, 1, -1, 0, 0, 0, utc);
986    EXPECT_EQ("2014-12-30 00:00:00", absl::FormatTime(ymdhms, t, utc));
987    t = absl::FromDateTime(2015, -1, 1, 0, 0, 0, utc);
988    EXPECT_EQ("2014-11-01 00:00:00", absl::FormatTime(ymdhms, t, utc));
989    t = absl::FromDateTime(2015, -1, -1, -1, -1, -1, utc);
990    EXPECT_EQ("2014-10-29 22:58:59", absl::FormatTime(ymdhms, t, utc));
991  }
992  TEST(Time, NextTransitionUTC) {
993    const auto tz = absl::UTCTimeZone();
994    absl::TimeZone::CivilTransition trans;
995    auto t = absl::InfinitePast();
996    EXPECT_FALSE(tz.NextTransition(t, &trans));
997    t = absl::InfiniteFuture();
998    EXPECT_FALSE(tz.NextTransition(t, &trans));
999  }
1000  TEST(Time, PrevTransitionUTC) {
1001    const auto tz = absl::UTCTimeZone();
1002    absl::TimeZone::CivilTransition trans;
1003    auto t = absl::InfiniteFuture();
1004    EXPECT_FALSE(tz.PrevTransition(t, &trans));
1005    t = absl::InfinitePast();
1006    EXPECT_FALSE(tz.PrevTransition(t, &trans));
1007  }
1008  TEST(Time, NextTransitionNYC) {
1009    const auto tz = absl::time_internal::LoadTimeZone("America/New_York");
1010    absl::TimeZone::CivilTransition trans;
1011    auto t = absl::FromCivil(absl::CivilSecond(2018, 6, 30, 0, 0, 0), tz);
1012    EXPECT_TRUE(tz.NextTransition(t, &trans));
1013    EXPECT_EQ(absl::CivilSecond(2018, 11, 4, 2, 0, 0), trans.from);
1014    EXPECT_EQ(absl::CivilSecond(2018, 11, 4, 1, 0, 0), trans.to);
1015    t = absl::InfiniteFuture();
1016    EXPECT_FALSE(tz.NextTransition(t, &trans));
1017    t = absl::InfinitePast();
1018    EXPECT_TRUE(tz.NextTransition(t, &trans));
1019    if (trans.from == absl::CivilSecond(1918, 03, 31, 2, 0, 0)) {
1020      EXPECT_EQ(absl::CivilSecond(1918, 3, 31, 3, 0, 0), trans.to);
1021    } else {
1022      EXPECT_EQ(absl::CivilSecond(1883, 11, 18, 12, 3, 58), trans.from);
1023      EXPECT_EQ(absl::CivilSecond(1883, 11, 18, 12, 0, 0), trans.to);
1024    }
1025  }
1026  TEST(Time, PrevTransitionNYC) {
1027    const auto tz = absl::time_internal::LoadTimeZone("America/New_York");
1028    absl::TimeZone::CivilTransition trans;
1029    auto t = absl::FromCivil(absl::CivilSecond(2018, 6, 30, 0, 0, 0), tz);
1030    EXPECT_TRUE(tz.PrevTransition(t, &trans));
1031    EXPECT_EQ(absl::CivilSecond(2018, 3, 11, 2, 0, 0), trans.from);
1032    EXPECT_EQ(absl::CivilSecond(2018, 3, 11, 3, 0, 0), trans.to);
1033    t = absl::InfinitePast();
1034    EXPECT_FALSE(tz.PrevTransition(t, &trans));
1035    t = absl::InfiniteFuture();
1036    EXPECT_TRUE(tz.PrevTransition(t, &trans));
1037  }
1038  TEST(Time, AbslStringify) {
1039    absl::Time t = absl::Now();
1040    EXPECT_EQ(absl::StrFormat("%v", t), absl::FormatTime(t));
1041  }
1042  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-states.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>22     syntax_element_startmark = 0,
23     syntax_element_endmark = syntax_element_startmark + 1,
24     syntax_element_literal = syntax_element_endmark + 1,
25     syntax_element_start_line = syntax_element_literal + 1,
26     syntax_element_end_line = syntax_element_start_line + 1,
27     syntax_element_wild = syntax_element_end_line + 1,
28     syntax_element_match = syntax_element_wild + 1,
29     syntax_element_word_boundary = syntax_element_match + 1,
30     syntax_element_within_word = syntax_element_word_boundary + 1,
31     syntax_element_word_start = syntax_element_within_word + 1,
32     syntax_element_word_end = syntax_element_word_start + 1,
33     syntax_element_buffer_start = syntax_element_word_end + 1,
34     syntax_element_buffer_end = syntax_element_buffer_start + 1,
35     syntax_element_backref = syntax_element_buffer_end + 1,
36     syntax_element_long_set = syntax_element_backref + 1,
37     syntax_element_set = syntax_element_long_set + 1,
38     syntax_element_jump = syntax_element_set + 1,
39     syntax_element_alt = syntax_element_jump + 1,
40     syntax_element_rep = syntax_element_alt + 1,
41     syntax_element_combining = syntax_element_rep + 1,
42     syntax_element_soft_buffer_end = syntax_element_combining + 1,
43     syntax_element_restart_continue = syntax_element_soft_buffer_end + 1,
44     syntax_element_dot_rep = syntax_element_restart_continue + 1,
45     syntax_element_char_rep = syntax_element_dot_rep + 1,
46     syntax_element_short_set_rep = syntax_element_char_rep + 1,
47     syntax_element_long_set_rep = syntax_element_short_set_rep + 1,
48     syntax_element_backstep = syntax_element_long_set_rep + 1,
49     syntax_element_assert_backref = syntax_element_backstep + 1,
50     syntax_element_toggle_case = syntax_element_assert_backref + 1,
51     syntax_element_recurse = syntax_element_toggle_case + 1,
52     syntax_element_fail = syntax_element_recurse + 1,
53     syntax_element_accept = syntax_element_fail + 1,
54     syntax_element_commit = syntax_element_accept + 1,
55     syntax_element_then = syntax_element_commit + 1
56  };
</pre></code></div>
                <div class="column column_space"><pre><code>660    tm.tm_isdst = -1;
661    t = FromTM(tm, nyc);
662    EXPECT_EQ("2014-11-02T01:30:42-04:00", absl::FormatTime(t, nyc));  
663    tm.tm_isdst = 0;
664    t = FromTM(tm, nyc);
665    EXPECT_EQ("2014-11-02T01:30:42-05:00", absl::FormatTime(t, nyc));  
666    tm.tm_isdst = 1;
667    t = FromTM(tm, nyc);
668    EXPECT_EQ("2014-11-02T01:30:42-04:00", absl::FormatTime(t, nyc));  
669    tm.tm_year = 2014 - 1900;
670    tm.tm_mon = 3 - 1;
671    tm.tm_mday = 9;
672    tm.tm_hour = 2;
673    tm.tm_min = 30;
674    tm.tm_sec = 42;
675    tm.tm_isdst = -1;
676    t = FromTM(tm, nyc);
677    EXPECT_EQ("2014-03-09T03:30:42-04:00", absl::FormatTime(t, nyc));  
678    tm.tm_isdst = 0;
679    t = FromTM(tm, nyc);
680    EXPECT_EQ("2014-03-09T01:30:42-05:00", absl::FormatTime(t, nyc));  
681    tm.tm_isdst = 1;
682    t = FromTM(tm, nyc);
683    EXPECT_EQ("2014-03-09T03:30:42-04:00", absl::FormatTime(t, nyc));  
684    tm.tm_year = 2147483647 - 1900 + 1;
685    tm.tm_mon = 6 - 1;
686    tm.tm_mday = 28;
687    tm.tm_hour = 1;
688    tm.tm_min = 2;
689    tm.tm_sec = 3;
690    tm.tm_isdst = -1;
691    t = FromTM(tm, absl::UTCTimeZone());
692    EXPECT_EQ("2147483648-06-28T01:02:03+00:00",
693              absl::FormatTime(t, absl::UTCTimeZone()));
694    tm.tm_year = 2019 - 1900;
695    tm.tm_mon = 2147483647;
696    tm.tm_mday = 28;
697    tm.tm_hour = 1;
698    tm.tm_min = 2;
699    tm.tm_sec = 3;
700    tm.tm_isdst = -1;
701    t = FromTM(tm, absl::UTCTimeZone());
702    EXPECT_EQ("178958989-08-28T01:02:03+00:00",
703              absl::FormatTime(t, absl::UTCTimeZone()));
704  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    