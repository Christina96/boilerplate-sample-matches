
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.0373831775700935%, Tokens: 13</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ccutil.cpp</h3>
            <pre><code>1  #if defined(_WIN32)
2  #  include <io.h> 
3  #endif
4  #include "ccutil.h"
5  #include <cstdlib>
6  #include <cstring> 
7  namespace tesseract {
8  CCUtil::CCUtil()
9      : params_()
10        , INT_INIT_MEMBER(ambigs_debug_level, 0, "Debug level for unichar ambiguities", &params_)
11        , BOOL_MEMBER(use_ambigs_for_adaption, false,
12                    "Use ambigs for deciding"
13                    " whether to adapt to a character",
14                    &params_) {}
15  CCUtil::~CCUtil() = default;
16  void CCUtil::main_setup(const std::string &argv0, const std::string &basename) {
17    imagebasename = basename; &bsol;**< name of image */
<span onclick='openModal()' class='match'>18    char *tessdata_prefix = getenv("TESSDATA_PREFIX");
19    if (!argv0.empty()) {
20      datadir = argv0;
21    } else if (tessdata_prefix) {
22      datadir = tessdata_prefix;
23  #if defined(_WIN32)
24    } else if (datadir.empty() || _access(datadir.c_str(), 0) != 0) {
</span>25      char path[_MAX_PATH];
26      DWORD length = GetModuleFileName(nullptr, path, sizeof(path));
27      if (length > 0 && length < sizeof(path)) {
28        char *separator = std::strrchr(path, '\\');
29        if (separator != nullptr) {
30          *separator = '\0';
31          std::string subdir = path;
32          subdir += "/tessdata";
33          if (_access(subdir.c_str(), 0) == 0) {
34            datadir = subdir;
35          }
36        }
37      }
38  #endif &bsol;* _WIN32 */
39    }
40    if (datadir.empty()) {
41  #if defined(TESSDATA_PREFIX)
42      datadir = TESSDATA_PREFIX "/tessdata";
43  #else
44      datadir = "./";
45  #endif &bsol;* TESSDATA_PREFIX */
46    }
47    const char *lastchar = datadir.c_str();
48    lastchar += datadir.length() - 1;
49    if ((strcmp(lastchar, "/") != 0) && (strcmp(lastchar, "\\") != 0)) {
50      datadir += "/";
51    }
52  }
53  } 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-websocket_59.cpp</h3>
            <pre><code>1  #include <nano/boost/asio/bind_executor.hpp>
2  #include <nano/boost/asio/dispatch.hpp>
3  #include <nano/boost/asio/strand.hpp>
4  #include <nano/lib/tlsconfig.hpp>
5  #include <nano/lib/work.hpp>
6  #include <nano/node/node_observers.hpp>
7  #include <nano/node/transport/channel.hpp>
8  #include <nano/node/transport/transport.hpp>
9  #include <nano/node/wallet.hpp>
10  #include <nano/node/websocket.hpp>
11  #include <boost/algorithm/string.hpp>
12  #include <boost/property_tree/json_parser.hpp>
13  #include <algorithm>
14  #include <chrono>
15  nano::websocket::confirmation_options::confirmation_options (nano::wallets & wallets_a) :
16  	wallets (wallets_a)
17  {
18  }
19  nano::websocket::confirmation_options::confirmation_options (boost::property_tree::ptree const & options_a, nano::wallets & wallets_a, nano::logger_mt & logger_a) :
20  	wallets (wallets_a),
21  	logger (logger_a)
22  {
23  	include_block = options_a.get<bool> ("include_block", true);
24  	include_election_info = options_a.get<bool> ("include_election_info", false);
25  	include_election_info_with_votes = options_a.get<bool> ("include_election_info_with_votes", false);
26  	include_sideband_info = options_a.get<bool> ("include_sideband_info", false);
27  	confirmation_types = 0;
28  	auto type_l (options_a.get<std::string> ("confirmation_type", "all"));
29  	if (boost::iequals (type_l, "active"))
30  	{
31  		confirmation_types = type_all_active;
32  	}
33  	else if (boost::iequals (type_l, "active_quorum"))
34  	{
35  		confirmation_types = type_active_quorum;
36  	}
37  	else if (boost::iequals (type_l, "active_confirmation_height"))
38  	{
39  		confirmation_types = type_active_confirmation_height;
40  	}
41  	else if (boost::iequals (type_l, "inactive"))
42  	{
43  		confirmation_types = type_inactive;
44  	}
45  	else
46  	{
47  		confirmation_types = type_all;
48  	}
49  	auto all_local_accounts_l (options_a.get_optional<bool> ("all_local_accounts"));
50  	if (all_local_accounts_l.is_initialized ())
51  	{
52  		all_local_accounts = all_local_accounts_l.get ();
53  		has_account_filtering_options = true;
54  		if (!include_block)
55  		{
56  			logger_a.always_log ("Websocket: Filtering option \"all_local_accounts\" requires that \"include_block\" is set to true to be effective");
57  		}
58  	}
59  	auto accounts_l (options_a.get_child_optional ("accounts"));
60  	if (accounts_l)
61  	{
62  		has_account_filtering_options = true;
63  		for (auto account_l : *accounts_l)
64  		{
65  			nano::account result_l{};
66  			if (!result_l.decode_account (account_l.second.data ()))
67  			{
68  				accounts.insert (result_l.to_account ());
69  			}
70  			else
71  			{
72  				logger_a.always_log ("Websocket: invalid account provided for filtering blocks: ", account_l.second.data ());
73  			}
74  		}
75  		if (!include_block)
76  		{
77  			logger_a.always_log ("Websocket: Filtering option \"accounts\" requires that \"include_block\" is set to true to be effective");
78  		}
79  	}
80  	check_filter_empty ();
81  }
82  bool nano::websocket::confirmation_options::should_filter (nano::websocket::message const & message_a) const
83  {
84  	bool should_filter_conf_type_l (true);
85  	auto type_text_l (message_a.contents.get<std::string> ("message.confirmation_type"));
86  	if (type_text_l == "active_quorum" && confirmation_types & type_active_quorum)
87  	{
88  		should_filter_conf_type_l = false;
89  	}
90  	else if (type_text_l == "active_confirmation_height" && confirmation_types & type_active_confirmation_height)
91  	{
92  		should_filter_conf_type_l = false;
93  	}
94  	else if (type_text_l == "inactive" && confirmation_types & type_inactive)
95  	{
96  		should_filter_conf_type_l = false;
97  	}
98  	bool should_filter_account (has_account_filtering_options);
99  	auto destination_opt_l (message_a.contents.get_optional<std::string> ("message.block.link_as_account"));
100  	if (destination_opt_l)
101  	{
102  		auto source_text_l (message_a.contents.get<std::string> ("message.account"));
103  		if (all_local_accounts)
104  		{
105  			auto transaction_l (wallets.tx_begin_read ());
106  			nano::account source_l{};
107  			nano::account destination_l{};
108  			auto decode_source_ok_l (!source_l.decode_account (source_text_l));
109  			auto decode_destination_ok_l (!destination_l.decode_account (destination_opt_l.get ()));
110  			(void)decode_source_ok_l;
111  			(void)decode_destination_ok_l;
112  			debug_assert (decode_source_ok_l && decode_destination_ok_l);
113  			if (wallets.exists (transaction_l, source_l) || wallets.exists (transaction_l, destination_l))
114  			{
115  				should_filter_account = false;
116  			}
117  		}
118  		if (accounts.find (source_text_l) != accounts.end () || accounts.find (destination_opt_l.get ()) != accounts.end ())
119  		{
120  			should_filter_account = false;
121  		}
122  	}
123  	return should_filter_conf_type_l || should_filter_account;
124  }
125  bool nano::websocket::confirmation_options::update (boost::property_tree::ptree const & options_a)
126  {
127  	auto update_accounts = [this] (boost::property_tree::ptree const & accounts_text_a, bool insert_a) {
128  		this->has_account_filtering_options = true;
129  		for (auto const & account_l : accounts_text_a)
130  		{
131  			nano::account result_l{};
132  			if (!result_l.decode_account (account_l.second.data ()))
133  			{
134  				auto encoded_l (result_l.to_account ());
135  				if (insert_a)
136  				{
137  					this->accounts.insert (encoded_l);
138  				}
139  				else
140  				{
141  					this->accounts.erase (encoded_l);
142  				}
143  			}
144  			else if (this->logger.is_initialized ())
145  			{
146  				this->logger->always_log ("Websocket: invalid account provided for filtering blocks: ", account_l.second.data ());
147  			}
148  		}
149  	};
150  	auto accounts_add_l (options_a.get_child_optional ("accounts_add"));
151  	if (accounts_add_l)
152  	{
153  		update_accounts (*accounts_add_l, true);
154  	}
155  	auto accounts_del_l (options_a.get_child_optional ("accounts_del"));
156  	if (accounts_del_l)
157  	{
158  		update_accounts (*accounts_del_l, false);
159  	}
160  	check_filter_empty ();
161  	return false;
162  }
163  void nano::websocket::confirmation_options::check_filter_empty () const
164  {
165  	if (logger.is_initialized () && has_account_filtering_options && !all_local_accounts && accounts.empty ())
166  	{
167  		logger->always_log ("Websocket: provided options resulted in an empty block confirmation filter");
168  	}
169  }
170  nano::websocket::vote_options::vote_options (boost::property_tree::ptree const & options_a, nano::logger_mt & logger_a)
171  {
172  	include_replays = options_a.get<bool> ("include_replays", false);
173  	include_indeterminate = options_a.get<bool> ("include_indeterminate", false);
174  	auto representatives_l (options_a.get_child_optional ("representatives"));
175  	if (representatives_l)
176  	{
177  		for (auto representative_l : *representatives_l)
178  		{
179  			nano::account result_l{};
180  			if (!result_l.decode_account (representative_l.second.data ()))
181  			{
182  				representatives.insert (result_l.to_account ());
183  			}
184  			else
185  			{
186  				logger_a.always_log ("Websocket: invalid account given to filter votes: ", representative_l.second.data ());
187  			}
188  		}
189  		if (representatives.empty ())
190  		{
191  			logger_a.always_log ("Websocket: account filter for votes is empty, no messages will be filtered");
192  		}
193  	}
194  }
195  bool nano::websocket::vote_options::should_filter (nano::websocket::message const & message_a) const
196  {
197  	auto type (message_a.contents.get<std::string> ("message.type"));
198  	bool should_filter_l = (!include_replays && type == "replay") || (!include_indeterminate && type == "indeterminate");
199  	if (!should_filter_l && !representatives.empty ())
200  	{
201  		auto representative_text_l (message_a.contents.get<std::string> ("message.account"));
202  		if (representatives.find (representative_text_l) == representatives.end ())
203  		{
204  			should_filter_l = true;
205  		}
206  	}
207  	return should_filter_l;
208  }
209  #ifdef NANO_SECURE_RPC
210  nano::websocket::session::session (nano::websocket::listener & listener_a, socket_type socket_a, boost::asio::ssl::context & ctx_a) :
211  	ws_listener (listener_a), ws (std::move (socket_a), ctx_a)
212  {
213  	ws_listener.get_logger ().try_log ("Websocket: secure session started");
214  }
215  #endif
216  nano::websocket::session::session (nano::websocket::listener & listener_a, socket_type socket_a) :
217  	ws_listener (listener_a), ws (std::move (socket_a))
218  {
219  	ws_listener.get_logger ().try_log ("Websocket: session started");
220  }
221  nano::websocket::session::~session ()
222  {
223  	{
224  		nano::unique_lock<nano::mutex> lk (subscriptions_mutex);
225  		for (auto & subscription : subscriptions)
226  		{
227  			ws_listener.decrease_subscriber_count (subscription.first);
228  		}
229  	}
230  }
231  void nano::websocket::session::handshake ()
232  {
233  	auto this_l (shared_from_this ());
234  	ws.handshake ([this_l] (boost::system::error_code const & ec) {
235  		if (!ec)
236  		{
237  			this_l->read ();
238  		}
239  		else
240  		{
241  			this_l->ws_listener.get_logger ().always_log ("Websocket: handshake failed: ", ec.message ());
242  		}
243  	});
244  }
245  void nano::websocket::session::close ()
246  {
247  	ws_listener.get_logger ().try_log ("Websocket: session closing");
248  	auto this_l (shared_from_this ());
249  	boost::asio::dispatch (ws.get_strand (),
250  	[this_l] () {
251  		boost::beast::websocket::close_reason reason;
252  		reason.code = boost::beast::websocket::close_code::normal;
253  		reason.reason = "Shutting down";
254  		boost::system::error_code ec_ignore;
255  		this_l->ws.close (reason, ec_ignore);
256  	});
257  }
258  void nano::websocket::session::write (nano::websocket::message message_a)
259  {
260  	nano::unique_lock<nano::mutex> lk (subscriptions_mutex);
261  	auto subscription (subscriptions.find (message_a.topic));
262  	if (message_a.topic == nano::websocket::topic::ack || (subscription != subscriptions.end () && !subscription->second->should_filter (message_a)))
263  	{
264  		lk.unlock ();
265  		auto this_l (shared_from_this ());
266  		boost::asio::post (ws.get_strand (),
267  		[message_a, this_l] () {
268  			bool write_in_progress = !this_l->send_queue.empty ();
269  			this_l->send_queue.emplace_back (message_a);
270  			if (!write_in_progress)
271  			{
272  				this_l->write_queued_messages ();
273  			}
274  		});
275  	}
276  }
277  void nano::websocket::session::write_queued_messages ()
278  {
279  	auto msg (send_queue.front ().to_string ());
280  	auto this_l (shared_from_this ());
281  	ws.async_write (nano::shared_const_buffer (msg),
282  	[this_l] (boost::system::error_code ec, std::size_t bytes_transferred) {
283  		this_l->send_queue.pop_front ();
284  		if (!ec)
285  		{
286  			if (!this_l->send_queue.empty ())
287  			{
288  				this_l->write_queued_messages ();
289  			}
290  		}
291  	});
292  }
293  void nano::websocket::session::read ()
294  {
295  	auto this_l (shared_from_this ());
296  	boost::asio::post (ws.get_strand (), [this_l] () {
297  		this_l->ws.async_read (this_l->read_buffer,
298  		[this_l] (boost::system::error_code ec, std::size_t bytes_transferred) {
299  			if (!ec)
300  			{
301  				std::stringstream os;
302  				os << beast_buffers (this_l->read_buffer.data ());
303  				std::string incoming_message = os.str ();
304  				this_l->read_buffer.consume (this_l->read_buffer.size ());
305  				boost::property_tree::ptree tree_msg;
306  				try
307  				{
308  					boost::property_tree::read_json (os, tree_msg);
309  					this_l->handle_message (tree_msg);
310  					this_l->read ();
311  				}
312  				catch (boost::property_tree::json_parser::json_parser_error const & ex)
313  				{
314  					this_l->ws_listener.get_logger ().try_log ("Websocket: json parsing failed: ", ex.what ());
315  				}
316  			}
317  			else if (ec != boost::asio::error::eof)
318  			{
319  				this_l->ws_listener.get_logger ().try_log ("Websocket: read failed: ", ec.message ());
320  			}
321  		});
322  	});
323  }
324  namespace
325  {
326  nano::websocket::topic to_topic (std::string const & topic_a)
327  {
<span onclick='openModal()' class='match'>328  	nano::websocket::topic topic = nano::websocket::topic::invalid;
329  	if (topic_a == "confirmation")
330  	{
331  		topic = nano::websocket::topic::confirmation;
332  	}
333  	else if (topic_a == "started_election")
334  	{
335  		topic = nano::websocket::topic::started_election;
336  	}
337  	else if (topic_a == "stopped_election")
338  	{
</span>339  		topic = nano::websocket::topic::stopped_election;
340  	}
341  	else if (topic_a == "vote")
342  	{
343  		topic = nano::websocket::topic::vote;
344  	}
345  	else if (topic_a == "ack")
346  	{
347  		topic = nano::websocket::topic::ack;
348  	}
349  	else if (topic_a == "work")
350  	{
351  		topic = nano::websocket::topic::work;
352  	}
353  	else if (topic_a == "bootstrap")
354  	{
355  		topic = nano::websocket::topic::bootstrap;
356  	}
357  	else if (topic_a == "telemetry")
358  	{
359  		topic = nano::websocket::topic::telemetry;
360  	}
361  	else if (topic_a == "new_unconfirmed_block")
362  	{
363  		topic = nano::websocket::topic::new_unconfirmed_block;
364  	}
365  	return topic;
366  }
367  std::string from_topic (nano::websocket::topic topic_a)
368  {
369  	std::string topic = "invalid";
370  	if (topic_a == nano::websocket::topic::confirmation)
371  	{
372  		topic = "confirmation";
373  	}
374  	else if (topic_a == nano::websocket::topic::started_election)
375  	{
376  		topic = "started_election";
377  	}
378  	else if (topic_a == nano::websocket::topic::stopped_election)
379  	{
380  		topic = "stopped_election";
381  	}
382  	else if (topic_a == nano::websocket::topic::vote)
383  	{
384  		topic = "vote";
385  	}
386  	else if (topic_a == nano::websocket::topic::ack)
387  	{
388  		topic = "ack";
389  	}
390  	else if (topic_a == nano::websocket::topic::work)
391  	{
392  		topic = "work";
393  	}
394  	else if (topic_a == nano::websocket::topic::bootstrap)
395  	{
396  		topic = "bootstrap";
397  	}
398  	else if (topic_a == nano::websocket::topic::telemetry)
399  	{
400  		topic = "telemetry";
401  	}
402  	else if (topic_a == nano::websocket::topic::new_unconfirmed_block)
403  	{
404  		topic = "new_unconfirmed_block";
405  	}
406  	return topic;
407  }
408  }
409  void nano::websocket::session::send_ack (std::string action_a, std::string id_a)
410  {
411  	nano::websocket::message msg (nano::websocket::topic::ack);
412  	boost::property_tree::ptree & message_l = msg.contents;
413  	message_l.add ("ack", action_a);
414  	message_l.add ("time", std::to_string (nano::milliseconds_since_epoch ()));
415  	if (!id_a.empty ())
416  	{
417  		message_l.add ("id", id_a);
418  	}
419  	write (msg);
420  }
421  void nano::websocket::session::handle_message (boost::property_tree::ptree const & message_a)
422  {
423  	std::string action (message_a.get<std::string> ("action", ""));
424  	auto topic_l (to_topic (message_a.get<std::string> ("topic", "")));
425  	auto ack_l (message_a.get<bool> ("ack", false));
426  	auto id_l (message_a.get<std::string> ("id", ""));
427  	auto action_succeeded (false);
428  	if (action == "subscribe" && topic_l != nano::websocket::topic::invalid)
429  	{
430  		auto options_text_l (message_a.get_child_optional ("options"));
431  		nano::lock_guard<nano::mutex> lk (subscriptions_mutex);
432  		std::unique_ptr<nano::websocket::options> options_l{ nullptr };
433  		if (options_text_l && topic_l == nano::websocket::topic::confirmation)
434  		{
435  			options_l = std::make_unique<nano::websocket::confirmation_options> (options_text_l.get (), ws_listener.get_wallets (), ws_listener.get_logger ());
436  		}
437  		else if (options_text_l && topic_l == nano::websocket::topic::vote)
438  		{
439  			options_l = std::make_unique<nano::websocket::vote_options> (options_text_l.get (), ws_listener.get_logger ());
440  		}
441  		else
442  		{
443  			options_l = std::make_unique<nano::websocket::options> ();
444  		}
445  		auto existing (subscriptions.find (topic_l));
446  		if (existing != subscriptions.end ())
447  		{
448  			existing->second = std::move (options_l);
449  			ws_listener.get_logger ().always_log ("Websocket: updated subscription to topic: ", from_topic (topic_l));
450  		}
451  		else
452  		{
453  			subscriptions.emplace (topic_l, std::move (options_l));
454  			ws_listener.get_logger ().always_log ("Websocket: new subscription to topic: ", from_topic (topic_l));
455  			ws_listener.increase_subscriber_count (topic_l);
456  		}
457  		action_succeeded = true;
458  	}
459  	else if (action == "update")
460  	{
461  		nano::lock_guard<nano::mutex> lk (subscriptions_mutex);
462  		auto existing (subscriptions.find (topic_l));
463  		if (existing != subscriptions.end ())
464  		{
465  			auto options_text_l (message_a.get_child_optional ("options"));
466  			if (options_text_l.is_initialized () && !existing->second->update (*options_text_l))
467  			{
468  				action_succeeded = true;
469  			}
470  		}
471  	}
472  	else if (action == "unsubscribe" && topic_l != nano::websocket::topic::invalid)
473  	{
474  		nano::lock_guard<nano::mutex> lk (subscriptions_mutex);
475  		if (subscriptions.erase (topic_l))
476  		{
477  			ws_listener.get_logger ().always_log ("Websocket: removed subscription to topic: ", from_topic (topic_l));
478  			ws_listener.decrease_subscriber_count (topic_l);
479  		}
480  		action_succeeded = true;
481  	}
482  	else if (action == "ping")
483  	{
484  		action_succeeded = true;
485  		ack_l = "true";
486  		action = "pong";
487  	}
488  	if (ack_l && action_succeeded)
489  	{
490  		send_ack (action, id_l);
491  	}
492  }
493  void nano::websocket::listener::stop ()
494  {
495  	stopped = true;
496  	acceptor.close ();
497  	nano::lock_guard<nano::mutex> lk (sessions_mutex);
498  	for (auto & weak_session : sessions)
499  	{
500  		auto session_ptr (weak_session.lock ());
501  		if (session_ptr)
502  		{
503  			session_ptr->close ();
504  		}
505  	}
506  	sessions.clear ();
507  }
508  nano::websocket::listener::listener (std::shared_ptr<nano::tls_config> const & tls_config_a, nano::logger_mt & logger_a, nano::wallets & wallets_a, boost::asio::io_context & io_ctx_a, boost::asio::ip::tcp::endpoint endpoint_a) :
509  	tls_config (tls_config_a),
510  	logger (logger_a),
511  	wallets (wallets_a),
512  	acceptor (io_ctx_a),
513  	socket (io_ctx_a)
514  {
515  	try
516  	{
517  		for (std::atomic<std::size_t> & item : topic_subscriber_count)
518  		{
519  			item = std::size_t (0);
520  		}
521  		acceptor.open (endpoint_a.protocol ());
522  		acceptor.set_option (boost::asio::socket_base::reuse_address (true));
523  		acceptor.bind (endpoint_a);
524  		acceptor.listen (boost::asio::socket_base::max_listen_connections);
525  	}
526  	catch (std::exception const & ex)
527  	{
528  		logger.always_log ("Websocket: listen failed: ", ex.what ());
529  	}
530  }
531  void nano::websocket::listener::run ()
532  {
533  	if (acceptor.is_open ())
534  	{
535  		accept ();
536  	}
537  }
538  void nano::websocket::listener::accept ()
539  {
540  	auto this_l (shared_from_this ());
541  	acceptor.async_accept (socket,
542  	[this_l] (boost::system::error_code const & ec) {
543  		this_l->on_accept (ec);
544  	});
545  }
546  void nano::websocket::listener::on_accept (boost::system::error_code ec)
547  {
548  	if (ec)
549  	{
550  		logger.always_log ("Websocket: accept failed: ", ec.message ());
551  	}
552  	else
553  	{
554  		std::shared_ptr<nano::websocket::session> session;
555  		if (tls_config && tls_config->enable_wss)
556  		{
557  #ifdef NANO_SECURE_RPC
558  			session = std::make_shared<nano::websocket::session> (*this, std::move (socket), tls_config->ssl_context);
559  #endif
560  		}
561  		else
562  		{
563  			session = std::make_shared<nano::websocket::session> (*this, std::move (socket));
564  		}
565  		sessions_mutex.lock ();
566  		sessions.push_back (session);
567  		sessions.erase (std::remove_if (sessions.begin (), sessions.end (), [] (auto & elem) { return elem.expired (); }), sessions.end ());
568  		sessions_mutex.unlock ();
569  		session->handshake ();
570  	}
571  	if (!stopped)
572  	{
573  		accept ();
574  	}
575  }
576  void nano::websocket::listener::broadcast_confirmation (std::shared_ptr<nano::block> const & block_a, nano::account const & account_a, nano::amount const & amount_a, std::string const & subtype, nano::election_status const & election_status_a, std::vector<nano::vote_with_weight_info> const & election_votes_a)
577  {
578  	nano::websocket::message_builder builder;
579  	nano::lock_guard<nano::mutex> lk (sessions_mutex);
580  	boost::optional<nano::websocket::message> msg_with_block;
581  	boost::optional<nano::websocket::message> msg_without_block;
582  	for (auto & weak_session : sessions)
583  	{
584  		auto session_ptr (weak_session.lock ());
585  		if (session_ptr)
586  		{
587  			auto subscription (session_ptr->subscriptions.find (nano::websocket::topic::confirmation));
588  			if (subscription != session_ptr->subscriptions.end ())
589  			{
590  				nano::websocket::confirmation_options default_options (wallets);
591  				auto conf_options (dynamic_cast<nano::websocket::confirmation_options *> (subscription->second.get ()));
592  				if (conf_options == nullptr)
593  				{
594  					conf_options = &default_options;
595  				}
596  				auto include_block (conf_options == nullptr ? true : conf_options->get_include_block ());
597  				if (include_block && !msg_with_block)
598  				{
599  					msg_with_block = builder.block_confirmed (block_a, account_a, amount_a, subtype, include_block, election_status_a, election_votes_a, *conf_options);
600  				}
601  				else if (!include_block && !msg_without_block)
602  				{
603  					msg_without_block = builder.block_confirmed (block_a, account_a, amount_a, subtype, include_block, election_status_a, election_votes_a, *conf_options);
604  				}
605  				session_ptr->write (include_block ? msg_with_block.get () : msg_without_block.get ());
606  			}
607  		}
608  	}
609  }
610  void nano::websocket::listener::broadcast (nano::websocket::message message_a)
611  {
612  	nano::lock_guard<nano::mutex> lk (sessions_mutex);
613  	for (auto & weak_session : sessions)
614  	{
615  		auto session_ptr (weak_session.lock ());
616  		if (session_ptr)
617  		{
618  			session_ptr->write (message_a);
619  		}
620  	}
621  }
622  void nano::websocket::listener::increase_subscriber_count (nano::websocket::topic const & topic_a)
623  {
624  	topic_subscriber_count[static_cast<std::size_t> (topic_a)] += 1;
625  }
626  void nano::websocket::listener::decrease_subscriber_count (nano::websocket::topic const & topic_a)
627  {
628  	auto & count (topic_subscriber_count[static_cast<std::size_t> (topic_a)]);
629  	release_assert (count > 0);
630  	count -= 1;
631  }
632  nano::websocket::message nano::websocket::message_builder::started_election (nano::block_hash const & hash_a)
633  {
634  	nano::websocket::message message_l (nano::websocket::topic::started_election);
635  	set_common_fields (message_l);
636  	boost::property_tree::ptree message_node_l;
637  	message_node_l.add ("hash", hash_a.to_string ());
638  	message_l.contents.add_child ("message", message_node_l);
639  	return message_l;
640  }
641  nano::websocket::message nano::websocket::message_builder::stopped_election (nano::block_hash const & hash_a)
642  {
643  	nano::websocket::message message_l (nano::websocket::topic::stopped_election);
644  	set_common_fields (message_l);
645  	boost::property_tree::ptree message_node_l;
646  	message_node_l.add ("hash", hash_a.to_string ());
647  	message_l.contents.add_child ("message", message_node_l);
648  	return message_l;
649  }
650  nano::websocket::message nano::websocket::message_builder::block_confirmed (std::shared_ptr<nano::block> const & block_a, nano::account const & account_a, nano::amount const & amount_a, std::string subtype, bool include_block_a, nano::election_status const & election_status_a, std::vector<nano::vote_with_weight_info> const & election_votes_a, nano::websocket::confirmation_options const & options_a)
651  {
652  	nano::websocket::message message_l (nano::websocket::topic::confirmation);
653  	set_common_fields (message_l);
654  	boost::property_tree::ptree message_node_l;
655  	message_node_l.add ("account", account_a.to_account ());
656  	message_node_l.add ("amount", amount_a.to_string_dec ());
657  	message_node_l.add ("hash", block_a->hash ().to_string ());
658  	std::string confirmation_type = "unknown";
659  	switch (election_status_a.type)
660  	{
661  		case nano::election_status_type::active_confirmed_quorum:
662  			confirmation_type = "active_quorum";
663  			break;
664  		case nano::election_status_type::active_confirmation_height:
665  			confirmation_type = "active_confirmation_height";
666  			break;
667  		case nano::election_status_type::inactive_confirmation_height:
668  			confirmation_type = "inactive";
669  			break;
670  		default:
671  			break;
672  	};
673  	message_node_l.add ("confirmation_type", confirmation_type);
674  	if (options_a.get_include_election_info () || options_a.get_include_election_info_with_votes ())
675  	{
676  		boost::property_tree::ptree election_node_l;
677  		election_node_l.add ("duration", election_status_a.election_duration.count ());
678  		election_node_l.add ("time", election_status_a.election_end.count ());
679  		election_node_l.add ("tally", election_status_a.tally.to_string_dec ());
680  		election_node_l.add ("final", election_status_a.final_tally.to_string_dec ());
681  		election_node_l.add ("blocks", std::to_string (election_status_a.block_count));
682  		election_node_l.add ("voters", std::to_string (election_status_a.voter_count));
683  		election_node_l.add ("request_count", std::to_string (election_status_a.confirmation_request_count));
684  		if (options_a.get_include_election_info_with_votes ())
685  		{
686  			boost::property_tree::ptree election_votes_l;
687  			for (auto const & vote_l : election_votes_a)
688  			{
689  				boost::property_tree::ptree entry;
690  				entry.put ("representative", vote_l.representative.to_account ());
691  				entry.put ("timestamp", vote_l.timestamp);
692  				entry.put ("hash", vote_l.hash.to_string ());
693  				entry.put ("weight", vote_l.weight.convert_to<std::string> ());
694  				election_votes_l.push_back (std::make_pair ("", entry));
695  			}
696  			election_node_l.add_child ("votes", election_votes_l);
697  		}
698  		message_node_l.add_child ("election_info", election_node_l);
699  	}
700  	if (include_block_a)
701  	{
702  		boost::property_tree::ptree block_node_l;
703  		block_a->serialize_json (block_node_l);
704  		if (!subtype.empty ())
705  		{
706  			block_node_l.add ("subtype", subtype);
707  		}
708  		message_node_l.add_child ("block", block_node_l);
709  	}
710  	if (options_a.get_include_sideband_info ())
711  	{
712  		boost::property_tree::ptree sideband_node_l;
713  		sideband_node_l.add ("height", std::to_string (block_a->sideband ().height));
714  		sideband_node_l.add ("local_timestamp", std::to_string (block_a->sideband ().timestamp));
715  		message_node_l.add_child ("sideband", sideband_node_l);
716  	}
717  	message_l.contents.add_child ("message", message_node_l);
718  	return message_l;
719  }
720  nano::websocket::message nano::websocket::message_builder::vote_received (std::shared_ptr<nano::vote> const & vote_a, nano::vote_code code_a)
721  {
722  	nano::websocket::message message_l (nano::websocket::topic::vote);
723  	set_common_fields (message_l);
724  	boost::property_tree::ptree vote_node_l;
725  	vote_a->serialize_json (vote_node_l);
726  	std::string vote_type = "invalid";
727  	switch (code_a)
728  	{
729  		case nano::vote_code::vote:
730  			vote_type = "vote";
731  			break;
732  		case nano::vote_code::replay:
733  			vote_type = "replay";
734  			break;
735  		case nano::vote_code::indeterminate:
736  			vote_type = "indeterminate";
737  			break;
738  		case nano::vote_code::invalid:
739  			debug_assert (false);
740  			break;
741  	}
742  	vote_node_l.put ("type", vote_type);
743  	message_l.contents.add_child ("message", vote_node_l);
744  	return message_l;
745  }
746  nano::websocket::message nano::websocket::message_builder::work_generation (nano::work_version const version_a, nano::block_hash const & root_a, uint64_t work_a, uint64_t difficulty_a, uint64_t publish_threshold_a, std::chrono::milliseconds const & duration_a, std::string const & peer_a, std::vector<std::string> const & bad_peers_a, bool completed_a, bool cancelled_a)
747  {
748  	nano::websocket::message message_l (nano::websocket::topic::work);
749  	set_common_fields (message_l);
750  	boost::property_tree::ptree work_l;
751  	work_l.put ("success", completed_a ? "true" : "false");
752  	work_l.put ("reason", completed_a ? "" : cancelled_a ? "cancelled"
753  														 : "failure");
754  	work_l.put ("duration", duration_a.count ());
755  	boost::property_tree::ptree request_l;
756  	request_l.put ("version", nano::to_string (version_a));
757  	request_l.put ("hash", root_a.to_string ());
758  	request_l.put ("difficulty", nano::to_string_hex (difficulty_a));
759  	auto request_multiplier_l (nano::difficulty::to_multiplier (difficulty_a, publish_threshold_a));
760  	request_l.put ("multiplier", nano::to_string (request_multiplier_l));
761  	work_l.add_child ("request", request_l);
762  	if (completed_a)
763  	{
764  		boost::property_tree::ptree result_l;
765  		result_l.put ("source", peer_a);
766  		result_l.put ("work", nano::to_string_hex (work_a));
767  		auto result_difficulty_l (nano::dev::network_params.work.difficulty (version_a, root_a, work_a));
768  		result_l.put ("difficulty", nano::to_string_hex (result_difficulty_l));
769  		auto result_multiplier_l (nano::difficulty::to_multiplier (result_difficulty_l, publish_threshold_a));
770  		result_l.put ("multiplier", nano::to_string (result_multiplier_l));
771  		work_l.add_child ("result", result_l);
772  	}
773  	boost::property_tree::ptree bad_peers_l;
774  	for (auto & peer_text : bad_peers_a)
775  	{
776  		boost::property_tree::ptree entry;
777  		entry.put ("", peer_text);
778  		bad_peers_l.push_back (std::make_pair ("", entry));
779  	}
780  	work_l.add_child ("bad_peers", bad_peers_l);
781  	message_l.contents.add_child ("message", work_l);
782  	return message_l;
783  }
784  nano::websocket::message nano::websocket::message_builder::work_cancelled (nano::work_version const version_a, nano::block_hash const & root_a, uint64_t const difficulty_a, uint64_t const publish_threshold_a, std::chrono::milliseconds const & duration_a, std::vector<std::string> const & bad_peers_a)
785  {
786  	return work_generation (version_a, root_a, 0, difficulty_a, publish_threshold_a, duration_a, "", bad_peers_a, false, true);
787  }
788  nano::websocket::message nano::websocket::message_builder::work_failed (nano::work_version const version_a, nano::block_hash const & root_a, uint64_t const difficulty_a, uint64_t const publish_threshold_a, std::chrono::milliseconds const & duration_a, std::vector<std::string> const & bad_peers_a)
789  {
790  	return work_generation (version_a, root_a, 0, difficulty_a, publish_threshold_a, duration_a, "", bad_peers_a, false, false);
791  }
792  nano::websocket::message nano::websocket::message_builder::bootstrap_started (std::string const & id_a, std::string const & mode_a)
793  {
794  	nano::websocket::message message_l (nano::websocket::topic::bootstrap);
795  	set_common_fields (message_l);
796  	boost::property_tree::ptree bootstrap_l;
797  	bootstrap_l.put ("reason", "started");
798  	bootstrap_l.put ("id", id_a);
799  	bootstrap_l.put ("mode", mode_a);
800  	message_l.contents.add_child ("message", bootstrap_l);
801  	return message_l;
802  }
803  nano::websocket::message nano::websocket::message_builder::bootstrap_exited (std::string const & id_a, std::string const & mode_a, std::chrono::steady_clock::time_point const start_time_a, uint64_t const total_blocks_a)
804  {
805  	nano::websocket::message message_l (nano::websocket::topic::bootstrap);
806  	set_common_fields (message_l);
807  	boost::property_tree::ptree bootstrap_l;
808  	bootstrap_l.put ("reason", "exited");
809  	bootstrap_l.put ("id", id_a);
810  	bootstrap_l.put ("mode", mode_a);
811  	bootstrap_l.put ("total_blocks", total_blocks_a);
812  	bootstrap_l.put ("duration", std::chrono::duration_cast<std::chrono::seconds> (std::chrono::steady_clock::now () - start_time_a).count ());
813  	message_l.contents.add_child ("message", bootstrap_l);
814  	return message_l;
815  }
816  nano::websocket::message nano::websocket::message_builder::telemetry_received (nano::telemetry_data const & telemetry_data_a, nano::endpoint const & endpoint_a)
817  {
818  	nano::websocket::message message_l (nano::websocket::topic::telemetry);
819  	set_common_fields (message_l);
820  	nano::jsonconfig telemetry_l;
821  	telemetry_data_a.serialize_json (telemetry_l, false);
822  	telemetry_l.put ("address", endpoint_a.address ());
823  	telemetry_l.put ("port", endpoint_a.port ());
824  	message_l.contents.add_child ("message", telemetry_l.get_tree ());
825  	return message_l;
826  }
827  nano::websocket::message nano::websocket::message_builder::new_block_arrived (nano::block const & block_a)
828  {
829  	nano::websocket::message message_l (nano::websocket::topic::new_unconfirmed_block);
830  	set_common_fields (message_l);
831  	boost::property_tree::ptree block_l;
832  	block_a.serialize_json (block_l);
833  	auto subtype (nano::state_subtype (block_a.sideband ().details));
834  	block_l.put ("subtype", subtype);
835  	message_l.contents.add_child ("message", block_l);
836  	return message_l;
837  }
838  void nano::websocket::message_builder::set_common_fields (nano::websocket::message & message_a)
839  {
840  	message_a.contents.add ("topic", from_topic (message_a.topic));
841  	message_a.contents.add ("time", std::to_string (nano::milliseconds_since_epoch ()));
842  }
843  std::string nano::websocket::message::to_string () const
844  {
845  	std::ostringstream ostream;
846  	boost::property_tree::write_json (ostream, contents);
847  	ostream.flush ();
848  	return ostream.str ();
849  }
850  nano::websocket_server::websocket_server (nano::websocket::config & config_a, nano::node_observers & observers_a, nano::wallets & wallets_a, nano::ledger & ledger_a, boost::asio::io_context & io_ctx_a, nano::logger_mt & logger_a) :
851  	config{ config_a },
852  	observers{ observers_a },
853  	wallets{ wallets_a },
854  	ledger{ ledger_a },
855  	io_ctx{ io_ctx_a },
856  	logger{ logger_a }
857  {
858  	if (!config.enabled)
859  	{
860  		return;
861  	}
862  	auto endpoint = nano::tcp_endpoint{ boost::asio::ip::make_address_v6 (config.address), config.port };
863  	server = std::make_shared<nano::websocket::listener> (config.tls_config, logger, wallets, io_ctx, endpoint);
864  	observers.blocks.add ([this] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const & votes_a, nano::account const & account_a, nano::amount const & amount_a, bool is_state_send_a, bool is_state_epoch_a) {
865  		debug_assert (status_a.type != nano::election_status_type::ongoing);
866  		if (server->any_subscriber (nano::websocket::topic::confirmation))
867  		{
868  			auto block_a = status_a.winner;
869  			std::string subtype;
870  			if (is_state_send_a)
871  			{
872  				subtype = "send";
873  			}
874  			else if (block_a->type () == nano::block_type::state)
875  			{
876  				if (block_a->link ().is_zero ())
877  				{
878  					subtype = "change";
879  				}
880  				else if (is_state_epoch_a)
881  				{
882  					debug_assert (amount_a == 0 && ledger.is_epoch_link (block_a->link ()));
883  					subtype = "epoch";
884  				}
885  				else
886  				{
887  					subtype = "receive";
888  				}
889  			}
890  			server->broadcast_confirmation (block_a, account_a, amount_a, subtype, status_a, votes_a);
891  		}
892  	});
893  	observers.active_started.add ([this] (nano::block_hash const & hash_a) {
894  		if (server->any_subscriber (nano::websocket::topic::started_election))
895  		{
896  			nano::websocket::message_builder builder;
897  			server->broadcast (builder.started_election (hash_a));
898  		}
899  	});
900  	observers.active_stopped.add ([this] (nano::block_hash const & hash_a) {
901  		if (server->any_subscriber (nano::websocket::topic::stopped_election))
902  		{
903  			nano::websocket::message_builder builder;
904  			server->broadcast (builder.stopped_election (hash_a));
905  		}
906  	});
907  	observers.telemetry.add ([this] (nano::telemetry_data const & telemetry_data, std::shared_ptr<nano::transport::channel> const & channel) {
908  		if (server->any_subscriber (nano::websocket::topic::telemetry))
909  		{
910  			nano::websocket::message_builder builder;
911  			server->broadcast (builder.telemetry_received (telemetry_data, channel->get_endpoint ()));
912  		}
913  	});
914  	observers.vote.add ([this] (std::shared_ptr<nano::vote> vote_a, std::shared_ptr<nano::transport::channel> const & channel_a, nano::vote_code code_a) {
915  		if (server->any_subscriber (nano::websocket::topic::vote))
916  		{
917  			nano::websocket::message_builder builder;
918  			auto msg{ builder.vote_received (vote_a, code_a) };
919  			server->broadcast (msg);
920  		}
921  	});
922  }
923  void nano::websocket_server::start ()
924  {
925  	if (server)
926  	{
927  		server->run ();
928  	}
929  }
930  void nano::websocket_server::stop ()
931  {
932  	if (server)
933  	{
934  		server->stop ();
935  	}
936  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ccutil.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-websocket_59.cpp</div>
                </div>
                <div class="column column_space"><pre><code>18    char *tessdata_prefix = getenv("TESSDATA_PREFIX");
19    if (!argv0.empty()) {
20      datadir = argv0;
21    } else if (tessdata_prefix) {
22      datadir = tessdata_prefix;
23  #if defined(_WIN32)
24    } else if (datadir.empty() || _access(datadir.c_str(), 0) != 0) {
</pre></code></div>
                <div class="column column_space"><pre><code>328  	nano::websocket::topic topic = nano::websocket::topic::invalid;
329  	if (topic_a == "confirmation")
330  	{
331  		topic = nano::websocket::topic::confirmation;
332  	}
333  	else if (topic_a == "started_election")
334  	{
335  		topic = nano::websocket::topic::started_election;
336  	}
337  	else if (topic_a == "stopped_election")
338  	{
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    