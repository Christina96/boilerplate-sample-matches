<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for gmock-actions.h &amp; gmock-matchers.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for gmock-actions.h &amp; gmock-matchers.h
      </h3>
<h1 align="center">
        3.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>gmock-actions.h (9.1277895%)<th>gmock-matchers.h (2.0463848%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1015-1037)<td><a href="#" name="0">(3993-4023)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(822-843)<td><a href="#" name="1">(3043-3057)</a><td align="center"><font color="#d80000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(427-437)<td><a href="#" name="2">(573-588)</a><td align="center"><font color="#bf0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1005-1015)<td><a href="#" name="3">(3907-3920)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(665-685)<td><a href="#" name="4">(1580-1601)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1110-1131)<td><a href="#" name="5">(3683-3701)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>gmock-actions.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
2 #define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
3 #ifndef _WIN32_WCE
4 # include &lt;errno.h&gt;
5 #endif
6 #include &lt;algorithm&gt;
7 #include &lt;functional&gt;
8 #include &lt;memory&gt;
9 #include &lt;string&gt;
10 #include &lt;type_traits&gt;
11 #include &lt;utility&gt;
12 #include "gmock/internal/gmock-internal-utils.h"
13 #include "gmock/internal/gmock-port.h"
14 #ifdef _MSC_VER
15 # pragma warning(push)
16 # pragma warning(disable:4100)
17 #endif
18 namespace testing {
19 namespace internal {
20 template &lt;typename T, bool kDefaultConstructible&gt;
21 struct BuiltInDefaultValueGetter {
22   static T Get() { return T(); }
23 };
24 template &lt;typename T&gt;
25 struct BuiltInDefaultValueGetter&lt;T, false&gt; {
26   static T Get() {
27     Assert(false, __FILE__, __LINE__,
28            "Default action undefined for the function return type.");
29     return internal::Invalid&lt;T&gt;();
30   }
31 };
32 template &lt;typename T&gt;
33 class BuiltInDefaultValue {
34  public:
35   static bool Exists() {
36     return ::std::is_default_constructible&lt;T&gt;::value;
37   }
38   static T Get() {
39     return BuiltInDefaultValueGetter&lt;
40         T, ::std::is_default_constructible&lt;T&gt;::value&gt;::Get();
41   }
42 };
43 template &lt;typename T&gt;
44 class BuiltInDefaultValue&lt;const T&gt; {
45  public:
46   static bool Exists() { return BuiltInDefaultValue&lt;T&gt;::Exists(); }
47   static T Get() { return BuiltInDefaultValue&lt;T&gt;::Get(); }
48 };
49 template &lt;typename T&gt;
50 class BuiltInDefaultValue&lt;T*&gt; {
51  public:
52   static bool Exists() { return true; }
53   static T* Get() { return nullptr; }
54 };
55 #define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \
56   template &lt;&gt; \
57   class BuiltInDefaultValue&lt;type&gt; { \
58    public: \
59     static bool Exists() { return true; } \
60     static type Get() { return value; } \
61   }
62 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, );  GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, "");
63 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);
64 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, '\0');
65 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed char, '\0');
66 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(char, '\0');
67 #if GMOCK_WCHAR_T_IS_NATIVE_
68 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(wchar_t, 0U);  #endif
69 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned short, 0U);  GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed short, 0);     GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);
70 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);
71 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL);  GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L);     GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(UInt64, 0);
72 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(Int64, 0);
73 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);
74 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);
75 #undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_
76 }  
77 template &lt;typename T&gt;
78 class DefaultValue {
79  public:
80   static void Set(T x) {
81     delete producer_;
82     producer_ = new FixedValueProducer(x);
83   }
84   typedef T (*FactoryFunction)();
85   static void SetFactory(FactoryFunction factory) {
86     delete producer_;
87     producer_ = new FactoryValueProducer(factory);
88   }
89   static void Clear() {
90     delete producer_;
91     producer_ = nullptr;
92   }
93   static bool IsSet() { return producer_ != nullptr; }
94   static bool Exists() {
95     return IsSet() || internal::BuiltInDefaultValue&lt;T&gt;::Exists();
96   }
97   static T Get() {
98     return producer_ == nullptr ? internal::BuiltInDefaultValue&lt;T&gt;::Get()
99                                 : producer_-&gt;Produce();
100   }
101  private:
102   class ValueProducer {
103    public:
104     virtual ~ValueProducer() {}
105     virtual T Produce() = 0;
106   };
107   class FixedValueProducer : public ValueProducer {
108    public:
109     explicit FixedValueProducer(T value) : value_(value) {}
110     T Produce() override { return value_; }
111    private:
112     const T value_;
113     GTEST_DISALLOW_COPY_AND_ASSIGN_(FixedValueProducer);
114   };
115   class FactoryValueProducer : public ValueProducer {
116    public:
117     explicit FactoryValueProducer(FactoryFunction factory)
118         : factory_(factory) {}
119     T Produce() override { return factory_(); }
120    private:
121     const FactoryFunction factory_;
122     GTEST_DISALLOW_COPY_AND_ASSIGN_(FactoryValueProducer);
123   };
124   static ValueProducer* producer_;
125 };
126 template &lt;typename T&gt;
127 class DefaultValue&lt;T&amp;&gt; {
128  public:
129   static void Set(T&amp; x) {      address_ = &amp;x;
130   }
131   static void Clear() { address_ = nullptr; }
132   static bool IsSet() { return address_ != nullptr; }
133   static bool Exists() {
134     return IsSet() || internal::BuiltInDefaultValue&lt;T&amp;&gt;::Exists();
135   }
136   static T&amp; Get() {
137     return address_ == nullptr ? internal::BuiltInDefaultValue&lt;T&amp;&gt;::Get()
138                                : *address_;
139   }
140  private:
141   static T* address_;
142 };
143 template &lt;&gt;
144 class DefaultValue&lt;void&gt; {
145  public:
146   static bool Exists() { return true; }
147   static void Get() {}
148 };
149 template &lt;typename T&gt;
150 typename DefaultValue&lt;T&gt;::ValueProducer* DefaultValue&lt;T&gt;::producer_ = nullptr;
151 template &lt;typename T&gt;
152 T* DefaultValue&lt;T&amp;&gt;::address_ = nullptr;
153 template &lt;typename F&gt;
154 class ActionInterface {
155  public:
156   typedef typename internal::Function&lt;F&gt;::Result Result;
157   typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
158   ActionInterface() {}
159   virtual ~ActionInterface() {}
160   virtual Result Perform(const ArgumentTuple&amp; args) = 0;
161  private:
162   GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface);
163 };
164 template &lt;typename F&gt;
165 class Action {
166   struct ActionAdapter {
167     ::std::shared_ptr&lt;ActionInterface&lt;F&gt;&gt; impl_;
168     template &lt;typename... Args&gt;
169     typename internal::Function&lt;F&gt;::Result operator()(Args&amp;&amp;... args) {
170       return impl_-&gt;Perform(
171           ::std::forward_as_tuple(::std::forward&lt;Args&gt;(args)...));
172     }
173   };
174  public:
175   typedef typename internal::Function&lt;F&gt;::Result Result;
176   typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
177   Action() {}
178   template &lt;typename G,
179             typename = typename ::std::enable_if&lt;
180                 ::std::is_constructible&lt;::std::function&lt;F&gt;, G&gt;::value&gt;::type&gt;
181   Action(G&amp;&amp; fun) : fun_(::std::forward&lt;G&gt;(fun)) {}  
182   explicit Action(ActionInterface&lt;F&gt;* impl)
183       : fun_(ActionAdapter{::std::shared_ptr&lt;ActionInterface&lt;F&gt;&gt;(impl)}) {}
184   template &lt;typename Func&gt;
185   explicit Action(const Action&lt;Func&gt;&amp; action) : fun_(action.fun_) {}
186   bool IsDoDefault() const { return fun_ == nullptr; }
187   Result Perform(ArgumentTuple args) const {
188     if (IsDoDefault()) {
189       internal::IllegalDoDefault(__FILE__, __LINE__);
190     }
191     return internal::Apply(fun_, ::std::move(args));
192   }
193  private:
194   template &lt;typename G&gt;
195   friend class Action;
196   ::std::function&lt;F&gt; fun_;
197 };
198 <a name="2"></a>template &lt;typename Impl&gt;
199 class PolymorphicAction {
200  public:
201 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  explicit PolymorphicAction(const Impl&amp; impl) : impl_(impl) {}
202   template &lt;typename F&gt;
203   operator Action&lt;F&gt;() const {
204     return Action&lt;F&gt;(new MonomorphicImpl&lt;F&gt;(impl_));
205   }
206  private:
207   template &lt;typename F&gt;
208   class MonomorphicImpl : public ActionInterface&lt;F&gt; {
209    public:</b></font>
210     typedef typename internal::Function&lt;F&gt;::Result Result;
211     typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
212     explicit MonomorphicImpl(const Impl&amp; impl) : impl_(impl) {}
213     Result Perform(const ArgumentTuple&amp; args) override {
214       return impl_.template Perform&lt;Result&gt;(args);
215     }
216    private:
217     Impl impl_;
218     GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);
219   };
220   Impl impl_;
221   GTEST_DISALLOW_ASSIGN_(PolymorphicAction);
222 };
223 template &lt;typename F&gt;
224 Action&lt;F&gt; MakeAction(ActionInterface&lt;F&gt;* impl) {
225   return Action&lt;F&gt;(impl);
226 }
227 template &lt;typename Impl&gt;
228 inline PolymorphicAction&lt;Impl&gt; MakePolymorphicAction(const Impl&amp; impl) {
229   return PolymorphicAction&lt;Impl&gt;(impl);
230 }
231 namespace internal {
232 template &lt;typename T&gt;
233 struct ByMoveWrapper {
234   explicit ByMoveWrapper(T value) : payload(std::move(value)) {}
235   T payload;
236 };
237 template &lt;typename R&gt;
238 class ReturnAction {
239  public:
240   explicit ReturnAction(R value) : value_(new R(std::move(value))) {}
241   template &lt;typename F&gt;
242   operator Action&lt;F&gt;() const {      typedef typename Function&lt;F&gt;::Result Result;
243     GTEST_COMPILE_ASSERT_(
244         !std::is_reference&lt;Result&gt;::value,
245         use_ReturnRef_instead_of_Return_to_return_a_reference);
246     static_assert(!std::is_void&lt;Result&gt;::value,
247                   "Can't use Return() on an action expected to return `void`.");
248     return Action&lt;F&gt;(new Impl&lt;R, F&gt;(value_));
249   }
250  private:
251   template &lt;typename R_, typename F&gt;
252   class Impl : public ActionInterface&lt;F&gt; {
253    public:
254     typedef typename Function&lt;F&gt;::Result Result;
255     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
256     explicit Impl(const std::shared_ptr&lt;R&gt;&amp; value)
257         : value_before_cast_(*value),
258           value_(ImplicitCast_&lt;Result&gt;(value_before_cast_)) {}
259     Result Perform(const ArgumentTuple&amp;) override { return value_; }
260    private:
261     GTEST_COMPILE_ASSERT_(!std::is_reference&lt;Result&gt;::value,
262                           Result_cannot_be_a_reference_type);
263     R value_before_cast_;
264     Result value_;
265     GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
266   };
267   template &lt;typename R_, typename F&gt;
268   class Impl&lt;ByMoveWrapper&lt;R_&gt;, F&gt; : public ActionInterface&lt;F&gt; {
269    public:
270     typedef typename Function&lt;F&gt;::Result Result;
271     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
272     explicit Impl(const std::shared_ptr&lt;R&gt;&amp; wrapper)
273         : performed_(false), wrapper_(wrapper) {}
274     Result Perform(const ArgumentTuple&amp;) override {
275       GTEST_CHECK_(!performed_)
276           &lt;&lt; "A ByMove() action should only be performed once.";
277       performed_ = true;
278       return std::move(wrapper_-&gt;payload);
279     }
280    private:
281     bool performed_;
282     const std::shared_ptr&lt;R&gt; wrapper_;
283     GTEST_DISALLOW_ASSIGN_(Impl);
284   };
285   const std::shared_ptr&lt;R&gt; value_;
286   GTEST_DISALLOW_ASSIGN_(ReturnAction);
287 };
288 class ReturnNullAction {
289  public:
290   template &lt;typename Result, typename ArgumentTuple&gt;
291   static Result Perform(const ArgumentTuple&amp;) {
292     return nullptr;
293   }
294 };
295 class ReturnVoidAction {
296  public:
297   template &lt;typename Result, typename ArgumentTuple&gt;
298   static void Perform(const ArgumentTuple&amp;) {
299     static_assert(std::is_void&lt;Result&gt;::value, "Result should be void.");
300   }
301 };
302 template &lt;typename T&gt;
303 class ReturnRefAction {
304  public:
305   explicit ReturnRefAction(T&amp; ref) : ref_(ref) {}  
306   template &lt;typename F&gt;
307   operator Action&lt;F&gt;() const {
308     typedef typename Function&lt;F&gt;::Result Result;
309     GTEST_COMPILE_ASSERT_(std::is_reference&lt;Result&gt;::value,
310                           use_Return_instead_of_ReturnRef_to_return_a_value);
311     return Action&lt;F&gt;(new Impl&lt;F&gt;(ref_));
312   }
313  private:
314   template &lt;typename F&gt;
315   class Impl : public ActionInterface&lt;F&gt; {
316    public:
317     typedef typename Function&lt;F&gt;::Result Result;
318     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
319     explicit Impl(T&amp; ref) : ref_(ref) {}  
320     Result Perform(const ArgumentTuple&amp;) override { return ref_; }
321    private:
322 <a name="4"></a>    T&amp; ref_;
323     GTEST_DISALLOW_ASSIGN_(Impl);
324 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  };
325   T&amp; ref_;
326   GTEST_DISALLOW_ASSIGN_(ReturnRefAction);
327 };
328 template &lt;typename T&gt;
329 class ReturnRefOfCopyAction {
330  public:
331   explicit ReturnRefOfCopyAction(const T&amp; value) : value_(value) {}  
332   template &lt;typename F&gt;
333   operator Action&lt;F&gt;() const {</b></font>
334     typedef typename Function&lt;F&gt;::Result Result;
335     GTEST_COMPILE_ASSERT_(
336         std::is_reference&lt;Result&gt;::value,
337         use_Return_instead_of_ReturnRefOfCopy_to_return_a_value);
338     return Action&lt;F&gt;(new Impl&lt;F&gt;(value_));
339   }
340  private:
341   template &lt;typename F&gt;
342   class Impl : public ActionInterface&lt;F&gt; {
343    public:
344     typedef typename Function&lt;F&gt;::Result Result;
345     typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
346     explicit Impl(const T&amp; value) : value_(value) {}  
347     Result Perform(const ArgumentTuple&amp;) override { return value_; }
348    private:
349     T value_;
350     GTEST_DISALLOW_ASSIGN_(Impl);
351   };
352   const T value_;
353   GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction);
354 };
355 class DoDefaultAction {
356  public:
357   template &lt;typename F&gt;
358   operator Action&lt;F&gt;() const { return Action&lt;F&gt;(); }  };
359 template &lt;typename T1, typename T2&gt;
360 class AssignAction {
361  public:
362   AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}
363   template &lt;typename Result, typename ArgumentTuple&gt;
364   void Perform(const ArgumentTuple&amp;     *ptr_ = value_;
365   }
366  private:
367   T1* const ptr_;
368   const T2 value_;
369   GTEST_DISALLOW_ASSIGN_(AssignAction);
370 };
371 #if !GTEST_OS_WINDOWS_MOBILE
372 template &lt;typename T&gt;
373 class SetErrnoAndReturnAction {
374  public:
375   SetErrnoAndReturnAction(int errno_value, T result)
376       : errno_(errno_value),
377         result_(result) {}
378   template &lt;typename Result, typename ArgumentTuple&gt;
379   Result Perform(const ArgumentTuple&amp;     errno = errno_;
380     return result_;
381   }
382  private:
383   const int errno_;
384   const T result_;
385   GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction);
386 };
387 #endif  
388 template &lt;size_t N, typename A, typename = void&gt;
389 struct SetArgumentPointeeAction {
390   A value;
391   template &lt;typename... Args&gt;
392   void operator()(const Args&amp;... args) const {
393     *::std::get&lt;N&gt;(std::tie(args...)) = value;
394   }
395 };
396 template &lt;class Class, typename MethodPtr&gt;
397 struct InvokeMethodAction {
398   Class* const obj_ptr;
399   const MethodPtr method_ptr;
400   template &lt;typename... Args&gt;
401   auto operator()(Args&amp;&amp;... args) const
402       -&gt; decltype((obj_ptr-&gt;*method_ptr)(std::forward&lt;Args&gt;(args)...)) {
403     return (obj_ptr-&gt;*method_ptr)(std::forward&lt;Args&gt;(args)...);
404   }
405 };
406 template &lt;typename FunctionImpl&gt;
407 struct InvokeWithoutArgsAction {
408   FunctionImpl function_impl;
409   template &lt;typename... Args&gt;
410   auto operator()(const Args&amp;...) -&gt; decltype(function_impl()) {
411     return function_impl();
412   }
413 };
414 template &lt;class Class, typename MethodPtr&gt;
415 struct InvokeMethodWithoutArgsAction {
416   Class* const obj_ptr;
417   const MethodPtr method_ptr;
418 <a name="1"></a>  using ReturnType = typename std::result_of&lt;MethodPtr(Class*)&gt;::type;
419   template &lt;typename... Args&gt;
420 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  ReturnType operator()(const Args&amp;...) const {
421     return (obj_ptr-&gt;*method_ptr)();
422   }
423 };
424 template &lt;typename A&gt;
425 class IgnoreResultAction {
426  public:
427   explicit IgnoreResultAction(const A&amp; action) : action_(action) {}
428   template &lt;typename F&gt;
429   operator Action&lt;F&gt;() const {
430     typedef typename internal::Function&lt;F&gt;::Result Result;</b></font>
431     static_assert(std::is_void&lt;Result&gt;::value, "Result type should be void.");
432     return Action&lt;F&gt;(new Impl&lt;F&gt;(action_));
433   }
434  private:
435   template &lt;typename F&gt;
436   class Impl : public ActionInterface&lt;F&gt; {
437    public:
438     typedef typename internal::Function&lt;F&gt;::Result Result;
439     typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
440     explicit Impl(const A&amp; action) : action_(action) {}
441     void Perform(const ArgumentTuple&amp; args) override {
442       action_.Perform(args);
443     }
444    private:
445     typedef typename internal::Function&lt;F&gt;::MakeResultIgnoredValue
446         OriginalFunction;
447     const Action&lt;OriginalFunction&gt; action_;
448     GTEST_DISALLOW_ASSIGN_(Impl);
449   };
450   const A action_;
451   GTEST_DISALLOW_ASSIGN_(IgnoreResultAction);
452 };
453 template &lt;typename InnerAction, size_t... I&gt;
454 struct WithArgsAction {
455   InnerAction action;
456   template &lt;typename R, typename... Args&gt;
457   operator Action&lt;R(Args...)&gt;() const {      Action&lt;R(typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type...)&gt;
458         converted(action);
459     return [converted](Args... args) -&gt; R {
460       return converted.Perform(std::forward_as_tuple(
461         std::get&lt;I&gt;(std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))...));
462     };
463   }
464 };
465 template &lt;typename... Actions&gt;
466 struct DoAllAction {
467  private:
468   template &lt;typename... Args, size_t... I&gt;
469   std::vector&lt;Action&lt;void(Args...)&gt;&gt; Convert(IndexSequence&lt;I...&gt;) const {
470     return {std::get&lt;I&gt;(actions)...};
471   }
472  public:
473   std::tuple&lt;Actions...&gt; actions;
474   template &lt;typename R, typename... Args&gt;
475   operator Action&lt;R(Args...)&gt;() const {      struct Op {
476       std::vector&lt;Action&lt;void(Args...)&gt;&gt; converted;
477       Action&lt;R(Args...)&gt; last;
478       R operator()(Args... args) const {
479         auto tuple_args = std::forward_as_tuple(std::forward&lt;Args&gt;(args)...);
480         for (auto&amp; a : converted) {
481           a.Perform(tuple_args);
482         }
483         return last.Perform(tuple_args);
484       }
485     };
486     return Op{Convert&lt;Args...&gt;(MakeIndexSequence&lt;sizeof...(Actions) - 1&gt;()),
487               std::get&lt;sizeof...(Actions) - 1&gt;(actions)};
488   }
489 };
490 }  
491 typedef internal::IgnoredValue Unused;
492 template &lt;typename... Action&gt;
493 internal::DoAllAction&lt;typename std::decay&lt;Action&gt;::type...&gt; DoAll(
494     Action&amp;&amp;... action) {
495   return {std::forward_as_tuple(std::forward&lt;Action&gt;(action)...)};
496 }
497 template &lt;size_t k, typename InnerAction&gt;
498 internal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type, k&gt;
499 WithArg(InnerAction&amp;&amp; action) {
500   return {std::forward&lt;InnerAction&gt;(action)};
501 }
502 template &lt;size_t k, size_t... ks, typename InnerAction&gt;
503 internal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type, k, ks...&gt;
504 WithArgs(InnerAction&amp;&amp; action) {
505   return {std::forward&lt;InnerAction&gt;(action)};
506 }
507 template &lt;typename InnerAction&gt;
508 internal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type&gt;
509 WithoutArgs(InnerAction&amp;&amp; action) {
510   return {std::forward&lt;InnerAction&gt;(action)};
511 }
512 <a name="3"></a>template &lt;typename R&gt;
513 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>internal::ReturnAction&lt;R&gt; Return(R value) {
514   return internal::ReturnAction&lt;R&gt;(std::move(value));
515 }
516 inline PolymorphicAction&lt;internal::ReturnNullAction&gt; ReturnNull() {
517   return MakePolymorphicAction(internal::ReturnNullAction());
518 <a name="0"></a>}
519 </b></font><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inline PolymorphicAction&lt;internal::ReturnVoidAction&gt; Return() {
520   return MakePolymorphicAction(internal::ReturnVoidAction());
521 }
522 template &lt;typename R&gt;
523 inline internal::ReturnRefAction&lt;R&gt; ReturnRef(R&amp; x) {    return internal::ReturnRefAction&lt;R&gt;(x);
524 }
525 template &lt;typename R&gt;
526 inline internal::ReturnRefOfCopyAction&lt;R&gt; ReturnRefOfCopy(const R&amp; x) {
527   return internal::ReturnRefOfCopyAction&lt;R&gt;(x);
528 }
529 template &lt;typename R&gt;</b></font>
530 internal::ByMoveWrapper&lt;R&gt; ByMove(R x) {
531   return internal::ByMoveWrapper&lt;R&gt;(std::move(x));
532 }
533 inline internal::DoDefaultAction DoDefault() {
534   return internal::DoDefaultAction();
535 }
536 template &lt;size_t N, typename T&gt;
537 internal::SetArgumentPointeeAction&lt;N, T&gt; SetArgPointee(T x) {
538   return {std::move(x)};
539 }
540 template &lt;size_t N, typename T&gt;
541 internal::SetArgumentPointeeAction&lt;N, T&gt; SetArgumentPointee(T x) {
542   return {std::move(x)};
543 }
544 template &lt;typename T1, typename T2&gt;
545 PolymorphicAction&lt;internal::AssignAction&lt;T1, T2&gt; &gt; Assign(T1* ptr, T2 val) {
546   return MakePolymorphicAction(internal::AssignAction&lt;T1, T2&gt;(ptr, val));
547 }
548 #if !GTEST_OS_WINDOWS_MOBILE
549 template &lt;typename T&gt;
550 PolymorphicAction&lt;internal::SetErrnoAndReturnAction&lt;T&gt; &gt;
551 SetErrnoAndReturn(int errval, T result) {
552   return MakePolymorphicAction(
553       internal::SetErrnoAndReturnAction&lt;T&gt;(errval, result));
554 }
555 #endif  
556 template &lt;typename FunctionImpl&gt;
557 typename std::decay&lt;FunctionImpl&gt;::type Invoke(FunctionImpl&amp;&amp; function_impl) {
558   return std::forward&lt;FunctionImpl&gt;(function_impl);
559 }
560 template &lt;class Class, typename MethodPtr&gt;
561 internal::InvokeMethodAction&lt;Class, MethodPtr&gt; Invoke(Class* obj_ptr,
562                                                       MethodPtr method_ptr) {
563   return {obj_ptr, method_ptr};
564 }
565 template &lt;typename FunctionImpl&gt;
566 internal::InvokeWithoutArgsAction&lt;typename std::decay&lt;FunctionImpl&gt;::type&gt;
567 InvokeWithoutArgs(FunctionImpl function_impl) {
568   return {std::move(function_impl)};
569 }
570 template &lt;class Class, typename MethodPtr&gt;
571 <a name="5"></a>internal::InvokeMethodWithoutArgsAction&lt;Class, MethodPtr&gt; InvokeWithoutArgs(
572     Class* obj_ptr, MethodPtr method_ptr) {
573   return {obj_ptr, method_ptr};
574 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
575 template &lt;typename A&gt;
576 inline internal::IgnoreResultAction&lt;A&gt; IgnoreResult(const A&amp; an_action) {
577   return internal::IgnoreResultAction&lt;A&gt;(an_action);
578 }
579 template &lt;typename T&gt;
580 inline ::std::reference_wrapper&lt;T&gt; ByRef(T&amp; l_value) {    return ::std::reference_wrapper&lt;T&gt;(l_value);
581 }
582 }  
583 #ifdef _MSC_VER
584 # pragma warning(pop)
585 #endif
#endif  </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>gmock-matchers.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
2 #define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
3 #include &lt;math.h&gt;
4 #include &lt;algorithm&gt;
5 #include &lt;initializer_list&gt;
6 #include &lt;iterator&gt;
7 #include &lt;limits&gt;
8 #include &lt;memory&gt;
9 #include &lt;ostream&gt;  #include &lt;sstream&gt;
10 #include &lt;string&gt;
11 #include &lt;type_traits&gt;
12 #include &lt;utility&gt;
13 #include &lt;vector&gt;
14 #include "gmock/internal/gmock-internal-utils.h"
15 #include "gmock/internal/gmock-port.h"
16 #include "gtest/gtest.h"
17 #if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1915
18 #define GMOCK_MAYBE_5046_ 5046
19 #else
20 #define GMOCK_MAYBE_5046_
21 #endif
22 GTEST_DISABLE_MSC_WARNINGS_PUSH_(
23 namespace testing {
24 class StringMatchResultListener : public MatchResultListener {
25  public:
26   StringMatchResultListener() : MatchResultListener(&amp;ss_) {}
27   std::string str() const { return ss_.str(); }
28   void Clear() { ss_.str(""); }
29  private:
30   ::std::stringstream ss_;
31   GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);
32 };
33 namespace internal {
34 template &lt;typename T, typename M&gt;
35 class MatcherCastImpl {
36  public:
37   static Matcher&lt;T&gt; Cast(const M&amp; polymorphic_matcher_or_value) {
38     return CastImpl(polymorphic_matcher_or_value,
39                     std::is_convertible&lt;M, Matcher&lt;T&gt;&gt;{},
40                     std::is_convertible&lt;M, T&gt;{});
41   }
42  private:
43   template &lt;bool Ignore&gt;
44   static Matcher&lt;T&gt; CastImpl(const M&amp; polymorphic_matcher_or_value,
45                              std::true_type                              bool_constant&lt;Ignore&gt;) {
46     return polymorphic_matcher_or_value;
47   }
48   static Matcher&lt;T&gt; CastImpl(const M&amp; value,
49                              std::false_type                              std::true_type     return Matcher&lt;T&gt;(ImplicitCast_&lt;T&gt;(value));
50   }
51   static Matcher&lt;T&gt; CastImpl(const M&amp; value,
52                              std::false_type                              std::false_type };
53 template &lt;typename T, typename U&gt;
54 class MatcherCastImpl&lt;T, Matcher&lt;U&gt; &gt; {
55  public:
56   static Matcher&lt;T&gt; Cast(const Matcher&lt;U&gt;&amp; source_matcher) {
57     return Matcher&lt;T&gt;(new Impl(source_matcher));
58   }
59  private:
60   class Impl : public MatcherInterface&lt;T&gt; {
61    public:
62     explicit Impl(const Matcher&lt;U&gt;&amp; source_matcher)
63         : source_matcher_(source_matcher) {}
64     bool MatchAndExplain(T x, MatchResultListener* listener) const override {
65       using FromType = typename std::remove_cv&lt;typename std::remove_pointer&lt;
66           typename std::remove_reference&lt;T&gt;::type&gt;::type&gt;::type;
67       using ToType = typename std::remove_cv&lt;typename std::remove_pointer&lt;
68           typename std::remove_reference&lt;U&gt;::type&gt;::type&gt;::type;
69       static_assert(
70           (std::is_pointer&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value !=
71            std::is_pointer&lt;typename std::remove_reference&lt;U&gt;::type&gt;::value) ||
72               std::is_same&lt;FromType, ToType&gt;::value ||
73               !std::is_base_of&lt;FromType, ToType&gt;::value,
74           "Can't implicitly convert from &lt;base&gt; to &lt;derived&gt;");
75       return source_matcher_.MatchAndExplain(static_cast&lt;U&gt;(x), listener);
76     }
77     void DescribeTo(::std::ostream* os) const override {
78       source_matcher_.DescribeTo(os);
79     }
80     void DescribeNegationTo(::std::ostream* os) const override {
81       source_matcher_.DescribeNegationTo(os);
82     }
83    private:
84     const Matcher&lt;U&gt; source_matcher_;
85     GTEST_DISALLOW_ASSIGN_(Impl);
86   };
87 };
88 template &lt;typename T&gt;
89 class MatcherCastImpl&lt;T, Matcher&lt;T&gt; &gt; {
90  public:
91   static Matcher&lt;T&gt; Cast(const Matcher&lt;T&gt;&amp; matcher) { return matcher; }
92 };
93 }  
94 template &lt;typename T, typename M&gt;
95 inline Matcher&lt;T&gt; MatcherCast(const M&amp; matcher) {
96   return internal::MatcherCastImpl&lt;T, M&gt;::Cast(matcher);
97 }
98 template &lt;typename T&gt;
99 class SafeMatcherCastImpl {
100  public:
101   template &lt;typename M&gt;
102   static inline Matcher&lt;T&gt; Cast(const M&amp; polymorphic_matcher_or_value) {
103     return internal::MatcherCastImpl&lt;T, M&gt;::Cast(polymorphic_matcher_or_value);
104   }
105   template &lt;typename U&gt;
106   static inline Matcher&lt;T&gt; Cast(const Matcher&lt;U&gt;&amp; matcher) {
107     GTEST_COMPILE_ASSERT_((std::is_convertible&lt;T, U&gt;::value),
108                           "T must be implicitly convertible to U");
109     GTEST_COMPILE_ASSERT_(
110         std::is_reference&lt;T&gt;::value || !std::is_reference&lt;U&gt;::value,
111         cannot_convert_non_reference_arg_to_reference);
112     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;
113     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;
114     const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;
115     const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;
116     GTEST_COMPILE_ASSERT_(
117         kTIsOther || kUIsOther ||
118         (internal::LosslessArithmeticConvertible&lt;RawT, RawU&gt;::value),
119         conversion_of_arithmetic_types_must_be_lossless);
120     return MatcherCast&lt;T&gt;(matcher);
121   }
122 };
123 template &lt;typename T, typename M&gt;
124 inline Matcher&lt;T&gt; SafeMatcherCast(const M&amp; polymorphic_matcher) {
125   return SafeMatcherCastImpl&lt;T&gt;::Cast(polymorphic_matcher);
126 }
127 template &lt;typename T&gt;
128 Matcher&lt;T&gt; A();
129 namespace internal {
130 inline void PrintIfNotEmpty(const std::string&amp; explanation,
131                             ::std::ostream* os) {
132   if (explanation != "" &amp;&amp; os != nullptr) {
133     *os &lt;&lt; ", " &lt;&lt; explanation;
134   }
135 }
136 inline bool IsReadableTypeName(const std::string&amp; type_name) {
137   return (type_name.length() &lt;= 20 ||
138           type_name.find_first_of("&lt;(") == std::string::npos);
139 }
140 template &lt;typename Value, typename T&gt;
141 bool MatchPrintAndExplain(Value&amp; value, const Matcher&lt;T&gt;&amp; matcher,
142                           MatchResultListener* listener) {
143   if (!listener-&gt;IsInterested()) {
144     return matcher.Matches(value);
145   }
146   StringMatchResultListener inner_listener;
147   const bool match = matcher.MatchAndExplain(value, &amp;inner_listener);
148   UniversalPrint(value, listener-&gt;stream());
149 #if GTEST_HAS_RTTI
150   const std::string&amp; type_name = GetTypeName&lt;Value&gt;();
151   if (IsReadableTypeName(type_name))
152     *listener-&gt;stream() &lt;&lt; " (of type " &lt;&lt; type_name &lt;&lt; ")";
153 #endif
154   PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
155   return match;
156 }
157 template &lt;size_t N&gt;
158 class TuplePrefix {
159  public:
160   template &lt;typename MatcherTuple, typename ValueTuple&gt;
161   static bool Matches(const MatcherTuple&amp; matcher_tuple,
162                       const ValueTuple&amp; value_tuple) {
163     return TuplePrefix&lt;N - 1&gt;::Matches(matcher_tuple, value_tuple) &amp;&amp;
164            std::get&lt;N - 1&gt;(matcher_tuple).Matches(std::get&lt;N - 1&gt;(value_tuple));
165   }
166   template &lt;typename MatcherTuple, typename ValueTuple&gt;
167   static void ExplainMatchFailuresTo(const MatcherTuple&amp; matchers,
168                                      const ValueTuple&amp; values,
169                                      ::std::ostream* os) {
170     TuplePrefix&lt;N - 1&gt;::ExplainMatchFailuresTo(matchers, values, os);
171     typename std::tuple_element&lt;N - 1, MatcherTuple&gt;::type matcher =
172         std::get&lt;N - 1&gt;(matchers);
173     typedef typename std::tuple_element&lt;N - 1, ValueTuple&gt;::type Value;
174     const Value&amp; value = std::get&lt;N - 1&gt;(values);
175     StringMatchResultListener listener;
176     if (!matcher.MatchAndExplain(value, &amp;listener)) {
177       *os &lt;&lt; "  Expected arg #" &lt;&lt; N - 1 &lt;&lt; ": ";
178       std::get&lt;N - 1&gt;(matchers).DescribeTo(os);
179       *os &lt;&lt; "\n           Actual: ";
180       internal::UniversalPrint(value, os);
181       PrintIfNotEmpty(listener.str(), os);
182       *os &lt;&lt; "\n";
183     }
184   }
185 };
186 template &lt;&gt;
187 class TuplePrefix&lt;0&gt; {
188  public:
189   template &lt;typename MatcherTuple, typename ValueTuple&gt;
190   static bool Matches(const MatcherTuple&amp;                       const ValueTuple&amp;     return true;
191   }
192   template &lt;typename MatcherTuple, typename ValueTuple&gt;
193   static void ExplainMatchFailuresTo(const MatcherTuple&amp;                                      const ValueTuple&amp;                                      ::std::ostream* };
194 template &lt;typename MatcherTuple, typename ValueTuple&gt;
195 bool TupleMatches(const MatcherTuple&amp; matcher_tuple,
196                   const ValueTuple&amp; value_tuple) {
197   GTEST_COMPILE_ASSERT_(std::tuple_size&lt;MatcherTuple&gt;::value ==
198                             std::tuple_size&lt;ValueTuple&gt;::value,
199                         matcher_and_value_have_different_numbers_of_fields);
200   return TuplePrefix&lt;std::tuple_size&lt;ValueTuple&gt;::value&gt;::Matches(matcher_tuple,
201                                                                   value_tuple);
202 }
203 template &lt;typename MatcherTuple, typename ValueTuple&gt;
204 void ExplainMatchFailureTupleTo(const MatcherTuple&amp; matchers,
205                                 const ValueTuple&amp; values,
206                                 ::std::ostream* os) {
207   TuplePrefix&lt;std::tuple_size&lt;MatcherTuple&gt;::value&gt;::ExplainMatchFailuresTo(
208       matchers, values, os);
209 }
210 template &lt;typename Tuple, typename Func, typename OutIter&gt;
211 class TransformTupleValuesHelper {
212  private:
213   typedef ::std::tuple_size&lt;Tuple&gt; TupleSize;
214  public:
215   static OutIter Run(Func f, const Tuple&amp; t, OutIter out) {
216     return IterateOverTuple&lt;Tuple, TupleSize::value&gt;()(f, t, out);
217   }
218  private:
219   template &lt;typename Tup, size_t kRemainingSize&gt;
220   struct IterateOverTuple {
221     OutIter operator() (Func f, const Tup&amp; t, OutIter out) const {
222       *out++ = f(::std::get&lt;TupleSize::value - kRemainingSize&gt;(t));
223       return IterateOverTuple&lt;Tup, kRemainingSize - 1&gt;()(f, t, out);
224     }
225   };
226   template &lt;typename Tup&gt;
227   struct IterateOverTuple&lt;Tup, 0&gt; {
228     OutIter operator() (Func       return out;
229     }
230   };
231 };
232 template &lt;typename Tuple, typename Func, typename OutIter&gt;
233 OutIter TransformTupleValues(Func f, const Tuple&amp; t, OutIter out) {
234   return TransformTupleValuesHelper&lt;Tuple, Func, OutIter&gt;::Run(f, t, out);
235 }
236 template &lt;typename T&gt;
237 class AnyMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
238  public:
239   bool MatchAndExplain(const T&amp;                        MatchResultListener*     return true;
240   }
241   void DescribeTo(::std::ostream* os) const override { *os &lt;&lt; "is anything"; }
242   void DescribeNegationTo(::std::ostream* os) const override {
243     *os &lt;&lt; "never matches";
244   }
245 };
246 class AnythingMatcher {
247  public:
248   template &lt;typename T&gt;
249   operator Matcher&lt;T&gt;() const { return A&lt;T&gt;(); }
250 };
251 class IsNullMatcher {
252  public:
253   template &lt;typename Pointer&gt;
254   bool MatchAndExplain(const Pointer&amp; p,
255                        MatchResultListener*     return p == nullptr;
256   }
257   void DescribeTo(::std::ostream* os) const { *os &lt;&lt; "is NULL"; }
258   void DescribeNegationTo(::std::ostream* os) const {
259     *os &lt;&lt; "isn't NULL";
260   }
261 };
262 class NotNullMatcher {
263  public:
264   template &lt;typename Pointer&gt;
265   bool MatchAndExplain(const Pointer&amp; p,
266                        MatchResultListener*     return p != nullptr;
267   }
268   void DescribeTo(::std::ostream* os) const { *os &lt;&lt; "isn't NULL"; }
269   void DescribeNegationTo(::std::ostream* os) const {
270     *os &lt;&lt; "is NULL";
271   }
272 };
273 template &lt;typename T&gt;
274 class RefMatcher;
275 template &lt;typename T&gt;
276 class RefMatcher&lt;T&amp;&gt; {
277  public:
278 <a name="2"></a>  <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  explicit RefMatcher(T&amp; x) : object_(x) {}  
279   template &lt;typename Super&gt;
280   operator Matcher&lt;Super&amp;&gt;() const {
281     return MakeMatcher(new Impl&lt;Super&gt;(object_));
282   }
283  private:
284   template &lt;typename Super&gt;
285   class Impl : public MatcherInterface&lt;Super&amp;&gt; {
286    public:</b></font>
287     explicit Impl(Super&amp; x) : object_(x) {}  
288     bool MatchAndExplain(Super&amp; x,
289                          MatchResultListener* listener) const override {
290       *listener &lt;&lt; "which is located @" &lt;&lt; static_cast&lt;const void*&gt;(&amp;x);
291       return &amp;x == &amp;object_;
292     }
293     void DescribeTo(::std::ostream* os) const override {
294       *os &lt;&lt; "references the variable ";
295       UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);
296     }
297     void DescribeNegationTo(::std::ostream* os) const override {
298       *os &lt;&lt; "does not reference the variable ";
299       UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);
300     }
301    private:
302     const Super&amp; object_;
303     GTEST_DISALLOW_ASSIGN_(Impl);
304   };
305   T&amp; object_;
306   GTEST_DISALLOW_ASSIGN_(RefMatcher);
307 };
308 inline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {
309   return String::CaseInsensitiveCStringEquals(lhs, rhs);
310 }
311 inline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,
312                                          const wchar_t* rhs) {
313   return String::CaseInsensitiveWideCStringEquals(lhs, rhs);
314 }
315 template &lt;typename StringType&gt;
316 bool CaseInsensitiveStringEquals(const StringType&amp; s1,
317                                  const StringType&amp; s2) {
318   if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {
319     return false;
320   }
321   const typename StringType::value_type nul = 0;
322   const size_t i1 = s1.find(nul), i2 = s2.find(nul);
323   if (i1 == StringType::npos || i2 == StringType::npos) {
324     return i1 == i2;
325   }
326   return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));
327 }
328 template &lt;typename StringType&gt;
329 class StrEqualityMatcher {
330  public:
331   StrEqualityMatcher(const StringType&amp; str, bool expect_eq,
332                      bool case_sensitive)
333       : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}
334 #if GTEST_HAS_ABSL
335   bool MatchAndExplain(const absl::string_view&amp; s,
336                        MatchResultListener* listener) const {
337     const StringType&amp; str = std::string(s);
338     return MatchAndExplain(str, listener);
339   }
340 #endif  
341   template &lt;typename CharType&gt;
342   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
343     if (s == nullptr) {
344       return !expect_eq_;
345     }
346     return MatchAndExplain(StringType(s), listener);
347   }
348   template &lt;typename MatcheeStringType&gt;
349   bool MatchAndExplain(const MatcheeStringType&amp; s,
350                        MatchResultListener*     const StringType&amp; s2(s);
351     const bool eq = case_sensitive_ ? s2 == string_ :
352         CaseInsensitiveStringEquals(s2, string_);
353     return expect_eq_ == eq;
354   }
355   void DescribeTo(::std::ostream* os) const {
356     DescribeToHelper(expect_eq_, os);
357   }
358   void DescribeNegationTo(::std::ostream* os) const {
359     DescribeToHelper(!expect_eq_, os);
360   }
361  private:
362   void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {
363     *os &lt;&lt; (expect_eq ? "is " : "isn't ");
364     *os &lt;&lt; "equal to ";
365     if (!case_sensitive_) {
366       *os &lt;&lt; "(ignoring case) ";
367     }
368     UniversalPrint(string_, os);
369   }
370   const StringType string_;
371   const bool expect_eq_;
372   const bool case_sensitive_;
373   GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);
374 };
375 template &lt;typename StringType&gt;
376 class HasSubstrMatcher {
377  public:
378   explicit HasSubstrMatcher(const StringType&amp; substring)
379       : substring_(substring) {}
380 #if GTEST_HAS_ABSL
381   bool MatchAndExplain(const absl::string_view&amp; s,
382                        MatchResultListener* listener) const {
383     const StringType&amp; str = std::string(s);
384     return MatchAndExplain(str, listener);
385   }
386 #endif  
387   template &lt;typename CharType&gt;
388   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
389     return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
390   }
391   template &lt;typename MatcheeStringType&gt;
392   bool MatchAndExplain(const MatcheeStringType&amp; s,
393                        MatchResultListener*     const StringType&amp; s2(s);
394     return s2.find(substring_) != StringType::npos;
395   }
396   void DescribeTo(::std::ostream* os) const {
397     *os &lt;&lt; "has substring ";
398     UniversalPrint(substring_, os);
399   }
400   void DescribeNegationTo(::std::ostream* os) const {
401     *os &lt;&lt; "has no substring ";
402     UniversalPrint(substring_, os);
403   }
404  private:
405   const StringType substring_;
406   GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);
407 };
408 template &lt;typename StringType&gt;
409 class StartsWithMatcher {
410  public:
411   explicit StartsWithMatcher(const StringType&amp; prefix) : prefix_(prefix) {
412   }
413 #if GTEST_HAS_ABSL
414   bool MatchAndExplain(const absl::string_view&amp; s,
415                        MatchResultListener* listener) const {
416     const StringType&amp; str = std::string(s);
417     return MatchAndExplain(str, listener);
418   }
419 #endif  
420   template &lt;typename CharType&gt;
421   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
422     return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
423   }
424   template &lt;typename MatcheeStringType&gt;
425   bool MatchAndExplain(const MatcheeStringType&amp; s,
426                        MatchResultListener*     const StringType&amp; s2(s);
427     return s2.length() &gt;= prefix_.length() &amp;&amp;
428         s2.substr(0, prefix_.length()) == prefix_;
429   }
430   void DescribeTo(::std::ostream* os) const {
431     *os &lt;&lt; "starts with ";
432     UniversalPrint(prefix_, os);
433   }
434   void DescribeNegationTo(::std::ostream* os) const {
435     *os &lt;&lt; "doesn't start with ";
436     UniversalPrint(prefix_, os);
437   }
438  private:
439   const StringType prefix_;
440   GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);
441 };
442 template &lt;typename StringType&gt;
443 class EndsWithMatcher {
444  public:
445   explicit EndsWithMatcher(const StringType&amp; suffix) : suffix_(suffix) {}
446 #if GTEST_HAS_ABSL
447   bool MatchAndExplain(const absl::string_view&amp; s,
448                        MatchResultListener* listener) const {
449     const StringType&amp; str = std::string(s);
450     return MatchAndExplain(str, listener);
451   }
452 #endif  
453   template &lt;typename CharType&gt;
454   bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
455     return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
456   }
457   template &lt;typename MatcheeStringType&gt;
458   bool MatchAndExplain(const MatcheeStringType&amp; s,
459                        MatchResultListener*     const StringType&amp; s2(s);
460     return s2.length() &gt;= suffix_.length() &amp;&amp;
461         s2.substr(s2.length() - suffix_.length()) == suffix_;
462   }
463   void DescribeTo(::std::ostream* os) const {
464     *os &lt;&lt; "ends with ";
465     UniversalPrint(suffix_, os);
466   }
467   void DescribeNegationTo(::std::ostream* os) const {
468     *os &lt;&lt; "doesn't end with ";
469     UniversalPrint(suffix_, os);
470   }
471  private:
472   const StringType suffix_;
473   GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);
474 };
475 template &lt;typename D, typename Op&gt;
476 class PairMatchBase {
477  public:
478   template &lt;typename T1, typename T2&gt;
479   operator Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;() const {
480     return Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;(new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;);
481   }
482   template &lt;typename T1, typename T2&gt;
483   operator Matcher&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;() const {
484     return MakeMatcher(new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;);
485   }
486  private:
487   static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {      return os &lt;&lt; D::Desc();
488   }
489   template &lt;typename Tuple&gt;
490   class Impl : public MatcherInterface&lt;Tuple&gt; {
491    public:
492     bool MatchAndExplain(Tuple args,
493                          MatchResultListener*       return Op()(::std::get&lt;0&gt;(args), ::std::get&lt;1&gt;(args));
494     }
495     void DescribeTo(::std::ostream* os) const override {
496       *os &lt;&lt; "are " &lt;&lt; GetDesc;
497     }
498     void DescribeNegationTo(::std::ostream* os) const override {
499       *os &lt;&lt; "aren't " &lt;&lt; GetDesc;
500     }
501   };
502 };
503 class Eq2Matcher : public PairMatchBase&lt;Eq2Matcher, AnyEq&gt; {
504  public:
505   static const char* Desc() { return "an equal pair"; }
506 };
507 class Ne2Matcher : public PairMatchBase&lt;Ne2Matcher, AnyNe&gt; {
508  public:
509   static const char* Desc() { return "an unequal pair"; }
510 };
511 class Lt2Matcher : public PairMatchBase&lt;Lt2Matcher, AnyLt&gt; {
512  public:
513   static const char* Desc() { return "a pair where the first &lt; the second"; }
514 };
515 class Gt2Matcher : public PairMatchBase&lt;Gt2Matcher, AnyGt&gt; {
516  public:
517   static const char* Desc() { return "a pair where the first &gt; the second"; }
518 };
519 class Le2Matcher : public PairMatchBase&lt;Le2Matcher, AnyLe&gt; {
520  public:
521   static const char* Desc() { return "a pair where the first &lt;= the second"; }
522 };
523 class Ge2Matcher : public PairMatchBase&lt;Ge2Matcher, AnyGe&gt; {
524  public:
525   static const char* Desc() { return "a pair where the first &gt;= the second"; }
526 };
527 template &lt;typename T&gt;
528 class NotMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
529  public:
530   explicit NotMatcherImpl(const Matcher&lt;T&gt;&amp; matcher)
531       : matcher_(matcher) {}
532   bool MatchAndExplain(const T&amp; x,
533                        MatchResultListener* listener) const override {
534     return !matcher_.MatchAndExplain(x, listener);
535   }
536   void DescribeTo(::std::ostream* os) const override {
537     matcher_.DescribeNegationTo(os);
538   }
539   void DescribeNegationTo(::std::ostream* os) const override {
540     matcher_.DescribeTo(os);
541   }
542  private:
543   const Matcher&lt;T&gt; matcher_;
544   GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);
545 };
546 template &lt;typename InnerMatcher&gt;
547 class NotMatcher {
548  public:
549   explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}
550   template &lt;typename T&gt;
551   operator Matcher&lt;T&gt;() const {
552     return Matcher&lt;T&gt;(new NotMatcherImpl&lt;T&gt;(SafeMatcherCast&lt;T&gt;(matcher_)));
553   }
554  private:
555   InnerMatcher matcher_;
556   GTEST_DISALLOW_ASSIGN_(NotMatcher);
557 };
558 template &lt;typename T&gt;
559 class AllOfMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
560  public:
561   explicit AllOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt; &gt; matchers)
562       : matchers_(std::move(matchers)) {}
563   void DescribeTo(::std::ostream* os) const override {
564     *os &lt;&lt; "(";
565     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
566       if (i != 0) *os &lt;&lt; ") and (";
567       matchers_[i].DescribeTo(os);
568     }
569     *os &lt;&lt; ")";
570   }
571   void DescribeNegationTo(::std::ostream* os) const override {
572     *os &lt;&lt; "(";
573     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
574       if (i != 0) *os &lt;&lt; ") or (";
575       matchers_[i].DescribeNegationTo(os);
576     }
577     *os &lt;&lt; ")";
578   }
579   bool MatchAndExplain(const T&amp; x,
580                        MatchResultListener* listener) const override {
581     std::string all_match_result;
582     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
583       StringMatchResultListener slistener;
584       if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {
585         if (all_match_result.empty()) {
586           all_match_result = slistener.str();
587         } else {
588           std::string result = slistener.str();
589           if (!result.empty()) {
590             all_match_result += ", and ";
591             all_match_result += result;
592           }
593         }
594       } else {
595         *listener &lt;&lt; slistener.str();
596         return false;
597       }
598     }
599     *listener &lt;&lt; all_match_result;
600     return true;
601   }
602  private:
603   const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_;
604   GTEST_DISALLOW_ASSIGN_(AllOfMatcherImpl);
605 };
606 template &lt;template &lt;typename T&gt; class CombiningMatcher, typename... Args&gt;
607 class VariadicMatcher {
608  public:
609   VariadicMatcher(const Args&amp;... matchers)        : matchers_(matchers...) {
610     static_assert(sizeof...(Args) &gt; 0, "Must have at least one matcher.");
611   }
612   template &lt;typename T&gt;
613   operator Matcher&lt;T&gt;() const {
614     std::vector&lt;Matcher&lt;T&gt; &gt; values;
615     CreateVariadicMatcher&lt;T&gt;(&amp;values, std::integral_constant&lt;size_t, 0&gt;());
616     return Matcher&lt;T&gt;(new CombiningMatcher&lt;T&gt;(std::move(values)));
617   }
618  private:
619   template &lt;typename T, size_t I&gt;
620   void CreateVariadicMatcher(std::vector&lt;Matcher&lt;T&gt; &gt;* values,
621                              std::integral_constant&lt;size_t, I&gt;) const {
622     values-&gt;push_back(SafeMatcherCast&lt;T&gt;(std::get&lt;I&gt;(matchers_)));
623     CreateVariadicMatcher&lt;T&gt;(values, std::integral_constant&lt;size_t, I + 1&gt;());
624   }
625   template &lt;typename T&gt;
626   void CreateVariadicMatcher(
627       std::vector&lt;Matcher&lt;T&gt; &gt;*,
628       std::integral_constant&lt;size_t, sizeof...(Args)&gt;) const {}
629   std::tuple&lt;Args...&gt; matchers_;
630   GTEST_DISALLOW_ASSIGN_(VariadicMatcher);
631 };
632 template &lt;typename... Args&gt;
633 using AllOfMatcher = VariadicMatcher&lt;AllOfMatcherImpl, Args...&gt;;
634 template &lt;typename T&gt;
635 class AnyOfMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
636  public:
637   explicit AnyOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt; &gt; matchers)
638       : matchers_(std::move(matchers)) {}
639   void DescribeTo(::std::ostream* os) const override {
640     *os &lt;&lt; "(";
641     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
642       if (i != 0) *os &lt;&lt; ") or (";
643       matchers_[i].DescribeTo(os);
644     }
645     *os &lt;&lt; ")";
646   }
647   void DescribeNegationTo(::std::ostream* os) const override {
648     *os &lt;&lt; "(";
649     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
650       if (i != 0) *os &lt;&lt; ") and (";
651       matchers_[i].DescribeNegationTo(os);
652     }
653     *os &lt;&lt; ")";
654   }
655   bool MatchAndExplain(const T&amp; x,
656                        MatchResultListener* listener) const override {
657     std::string no_match_result;
658     for (size_t i = 0; i &lt; matchers_.size(); ++i) {
659       StringMatchResultListener slistener;
660       if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {
661         *listener &lt;&lt; slistener.str();
662         return true;
663       } else {
664         if (no_match_result.empty()) {
665           no_match_result = slistener.str();
666         } else {
667           std::string result = slistener.str();
668           if (!result.empty()) {
669             no_match_result += ", and ";
670             no_match_result += result;
671           }
672         }
673       }
674     }
675     *listener &lt;&lt; no_match_result;
676     return false;
677   }
678  private:
679   const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_;
680   GTEST_DISALLOW_ASSIGN_(AnyOfMatcherImpl);
681 };
682 template &lt;typename... Args&gt;
683 using AnyOfMatcher = VariadicMatcher&lt;AnyOfMatcherImpl, Args...&gt;;
684 template &lt;template &lt;class&gt; class MatcherImpl, typename T&gt;
685 class SomeOfArrayMatcher {
686  public:
687   template &lt;typename Iter&gt;
688   SomeOfArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}
689   template &lt;typename U&gt;
690   operator Matcher&lt;U&gt;() const {      using RawU = typename std::decay&lt;U&gt;::type;
691     std::vector&lt;Matcher&lt;RawU&gt;&gt; matchers;
692     for (const auto&amp; matcher : matchers_) {
693       matchers.push_back(MatcherCast&lt;RawU&gt;(matcher));
694     }
695     return Matcher&lt;U&gt;(new MatcherImpl&lt;RawU&gt;(std::move(matchers)));
696   }
697  private:
698   const ::std::vector&lt;T&gt; matchers_;
699   GTEST_DISALLOW_ASSIGN_(SomeOfArrayMatcher);
700 };
701 template &lt;typename T&gt;
702 using AllOfArrayMatcher = SomeOfArrayMatcher&lt;AllOfMatcherImpl, T&gt;;
703 template &lt;typename T&gt;
704 using AnyOfArrayMatcher = SomeOfArrayMatcher&lt;AnyOfMatcherImpl, T&gt;;
705 template &lt;typename Predicate&gt;
706 class TrulyMatcher {
707  public:
708   explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}
709   template &lt;typename T&gt;
710   bool MatchAndExplain(T&amp; x,                         MatchResultListener*     if (predicate_(x))
711       return true;
712     return false;
713   }
714   void DescribeTo(::std::ostream* os) const {
715     *os &lt;&lt; "satisfies the given predicate";
716   }
717   void DescribeNegationTo(::std::ostream* os) const {
718     *os &lt;&lt; "doesn't satisfy the given predicate";
719   }
720  private:
721   Predicate predicate_;
722   GTEST_DISALLOW_ASSIGN_(TrulyMatcher);
723 };
724 template &lt;typename M&gt;
725 class MatcherAsPredicate {
726  public:
727   explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}
728   template &lt;typename T&gt;
729   bool operator()(const T&amp; x) const {
730     return MatcherCast&lt;const T&amp;&gt;(matcher_).Matches(x);
731   }
732  private:
733   M matcher_;
734   GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);
735 };
736 template &lt;typename M&gt;
737 class PredicateFormatterFromMatcher {
738  public:
739   explicit PredicateFormatterFromMatcher(M m) : matcher_(std::move(m)) {}
740   template &lt;typename T&gt;
741   AssertionResult operator()(const char* value_text, const T&amp; x) const {
742     const Matcher&lt;const T&amp;&gt; matcher = SafeMatcherCast&lt;const T&amp;&gt;(matcher_);
743     if (matcher.Matches(x)) {
744       return AssertionSuccess();
745     }
746     ::std::stringstream ss;
747     ss &lt;&lt; "Value of: " &lt;&lt; value_text &lt;&lt; "\n"
748        &lt;&lt; "Expected: ";
749     matcher.DescribeTo(&amp;ss);
750     StringMatchResultListener listener;
751     if (MatchPrintAndExplain(x, matcher, &amp;listener)) {
752       ss &lt;&lt; "\n  The matcher failed on the initial attempt; but passed when "
753             "rerun to generate the explanation.";
754     }
755     ss &lt;&lt; "\n  Actual: " &lt;&lt; listener.str();
756     return AssertionFailure() &lt;&lt; ss.str();
757   }
758  private:
759   const M matcher_;
760   GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);
761 };
762 template &lt;typename M&gt;
763 inline PredicateFormatterFromMatcher&lt;M&gt;
764 MakePredicateFormatterFromMatcher(M matcher) {
765   return PredicateFormatterFromMatcher&lt;M&gt;(std::move(matcher));
766 }
767 template &lt;typename FloatType&gt;
768 class FloatingEqMatcher {
769  public:
770   FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :
771     expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {
772   }
773   FloatingEqMatcher(FloatType expected, bool nan_eq_nan,
774                     FloatType max_abs_error)
775       : expected_(expected),
776         nan_eq_nan_(nan_eq_nan),
777         max_abs_error_(max_abs_error) {
778     GTEST_CHECK_(max_abs_error &gt;= 0)
779         &lt;&lt; ", where max_abs_error is" &lt;&lt; max_abs_error;
780   }
781   template &lt;typename T&gt;
782   class Impl : public MatcherInterface&lt;T&gt; {
783    public:
784     Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)
785         : expected_(expected),
786           nan_eq_nan_(nan_eq_nan),
787           max_abs_error_(max_abs_error) {}
788     bool MatchAndExplain(T value,
789                          MatchResultListener* listener) const override {
790       const FloatingPoint&lt;FloatType&gt; actual(value), expected(expected_);
791       if (actual.is_nan() || expected.is_nan()) {
792         if (actual.is_nan() &amp;&amp; expected.is_nan()) {
793           return nan_eq_nan_;
794         }
795         return false;
796       }
797       if (HasMaxAbsError()) {
798         if (value == expected_) {
799           return true;
800         }
801         const FloatType diff = value - expected_;
802         if (fabs(diff) &lt;= max_abs_error_) {
803           return true;
804         }
805         if (listener-&gt;IsInterested()) {
806           *listener &lt;&lt; "which is " &lt;&lt; diff &lt;&lt; " from " &lt;&lt; expected_;
807         }
808         return false;
809       } else {
810         return actual.AlmostEquals(expected);
811       }
812     }
813     void DescribeTo(::std::ostream* os) const override {
814       const ::std::streamsize old_precision = os-&gt;precision(
815           ::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);
816       if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {
817         if (nan_eq_nan_) {
818           *os &lt;&lt; "is NaN";
819         } else {
820           *os &lt;&lt; "never matches";
821         }
822       } else {
823         *os &lt;&lt; "is approximately " &lt;&lt; expected_;
824         if (HasMaxAbsError()) {
825           *os &lt;&lt; " (absolute error &lt;= " &lt;&lt; max_abs_error_ &lt;&lt; ")";
826         }
827       }
828       os-&gt;precision(old_precision);
829     }
830     void DescribeNegationTo(::std::ostream* os) const override {
831       const ::std::streamsize old_precision = os-&gt;precision(
832           ::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);
833       if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {
834         if (nan_eq_nan_) {
835           *os &lt;&lt; "isn't NaN";
836         } else {
837           *os &lt;&lt; "is anything";
838         }
839       } else {
840         *os &lt;&lt; "isn't approximately " &lt;&lt; expected_;
841         if (HasMaxAbsError()) {
842           *os &lt;&lt; " (absolute error &gt; " &lt;&lt; max_abs_error_ &lt;&lt; ")";
843         }
844       }
845       os-&gt;precision(old_precision);
846     }
847    private:
848     bool HasMaxAbsError() const {
849       return max_abs_error_ &gt;= 0;
850     }
851     const FloatType expected_;
852     const bool nan_eq_nan_;
853     const FloatType max_abs_error_;
854     GTEST_DISALLOW_ASSIGN_(Impl);
855   };
856   operator Matcher&lt;FloatType&gt;() const {
857     return MakeMatcher(
858         new Impl&lt;FloatType&gt;(expected_, nan_eq_nan_, max_abs_error_));
859   }
860   operator Matcher&lt;const FloatType&amp;&gt;() const {
861     return MakeMatcher(
862         new Impl&lt;const FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));
863   }
864   operator Matcher&lt;FloatType&amp;&gt;() const {
865     return MakeMatcher(
866         new Impl&lt;FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));
867   }
868  private:
869   const FloatType expected_;
870   const bool nan_eq_nan_;
871   const FloatType max_abs_error_;
872   GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);
873 };
874 template &lt;typename FloatType&gt;
875 class FloatingEq2Matcher {
876  public:
877   FloatingEq2Matcher() { Init(-1, false); }
878   explicit FloatingEq2Matcher(bool nan_eq_nan) { Init(-1, nan_eq_nan); }
879   explicit FloatingEq2Matcher(FloatType max_abs_error) {
880     Init(max_abs_error, false);
881   }
882   FloatingEq2Matcher(FloatType max_abs_error, bool nan_eq_nan) {
883     Init(max_abs_error, nan_eq_nan);
884   }
885   template &lt;typename T1, typename T2&gt;
886   operator Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;() const {
887     return MakeMatcher(
888         new Impl&lt;::std::tuple&lt;T1, T2&gt;&gt;(max_abs_error_, nan_eq_nan_));
889   }
890   template &lt;typename T1, typename T2&gt;
891   operator Matcher&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;() const {
892     return MakeMatcher(
893         new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;(max_abs_error_, nan_eq_nan_));
894   }
895  private:
896   static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {      return os &lt;&lt; "an almost-equal pair";
897   }
898   template &lt;typename Tuple&gt;
899   class Impl : public MatcherInterface&lt;Tuple&gt; {
900    public:
901     Impl(FloatType max_abs_error, bool nan_eq_nan) :
902         max_abs_error_(max_abs_error),
903         nan_eq_nan_(nan_eq_nan) {}
904     bool MatchAndExplain(Tuple args,
905                          MatchResultListener* listener) const override {
906       if (max_abs_error_ == -1) {
907         FloatingEqMatcher&lt;FloatType&gt; fm(::std::get&lt;0&gt;(args), nan_eq_nan_);
908         return static_cast&lt;Matcher&lt;FloatType&gt;&gt;(fm).MatchAndExplain(
909             ::std::get&lt;1&gt;(args), listener);
910       } else {
911         FloatingEqMatcher&lt;FloatType&gt; fm(::std::get&lt;0&gt;(args), nan_eq_nan_,
912                                         max_abs_error_);
913         return static_cast&lt;Matcher&lt;FloatType&gt;&gt;(fm).MatchAndExplain(
914             ::std::get&lt;1&gt;(args), listener);
915       }
916     }
917     void DescribeTo(::std::ostream* os) const override {
918       *os &lt;&lt; "are " &lt;&lt; GetDesc;
919     }
920     void DescribeNegationTo(::std::ostream* os) const override {
921       *os &lt;&lt; "aren't " &lt;&lt; GetDesc;
922     }
923    private:
924     FloatType max_abs_error_;
925     const bool nan_eq_nan_;
926   };
927 <a name="4"></a>  void Init(FloatType max_abs_error_val, bool nan_eq_nan_val) {
928     max_abs_error_ = max_abs_error_val;
929     nan_eq_nan_ = nan_eq_nan_val;
930 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
931   FloatType max_abs_error_;
932   bool nan_eq_nan_;
933 };
934 template &lt;typename InnerMatcher&gt;
935 class PointeeMatcher {
936  public:
937   explicit PointeeMatcher(const InnerMatcher&amp; matcher) : matcher_(matcher) {}
938   template &lt;typename Pointer&gt;
939   operator Matcher&lt;Pointer&gt;() const {</b></font>
940     return Matcher&lt;Pointer&gt;(new Impl&lt;const Pointer&amp;&gt;(matcher_));
941   }
942  private:
943   template &lt;typename Pointer&gt;
944   class Impl : public MatcherInterface&lt;Pointer&gt; {
945    public:
946     typedef typename PointeeOf&lt;typename std::remove_const&lt;
947         typename std::remove_reference&lt;Pointer&gt;::type&gt;::type&gt;::type Pointee;
948     explicit Impl(const InnerMatcher&amp; matcher)
949         : matcher_(MatcherCast&lt;const Pointee&amp;&gt;(matcher)) {}
950     void DescribeTo(::std::ostream* os) const override {
951       *os &lt;&lt; "points to a value that ";
952       matcher_.DescribeTo(os);
953     }
954     void DescribeNegationTo(::std::ostream* os) const override {
955       *os &lt;&lt; "does not point to a value that ";
956       matcher_.DescribeTo(os);
957     }
958     bool MatchAndExplain(Pointer pointer,
959                          MatchResultListener* listener) const override {
960       if (GetRawPointer(pointer) == nullptr) return false;
961       *listener &lt;&lt; "which points to ";
962       return MatchPrintAndExplain(*pointer, matcher_, listener);
963     }
964    private:
965     const Matcher&lt;const Pointee&amp;&gt; matcher_;
966     GTEST_DISALLOW_ASSIGN_(Impl);
967   };
968   const InnerMatcher matcher_;
969   GTEST_DISALLOW_ASSIGN_(PointeeMatcher);
970 };
971 #if GTEST_HAS_RTTI
972 template &lt;typename To&gt;
973 class WhenDynamicCastToMatcherBase {
974  public:
975   explicit WhenDynamicCastToMatcherBase(const Matcher&lt;To&gt;&amp; matcher)
976       : matcher_(matcher) {}
977   void DescribeTo(::std::ostream* os) const {
978     GetCastTypeDescription(os);
979     matcher_.DescribeTo(os);
980   }
981   void DescribeNegationTo(::std::ostream* os) const {
982     GetCastTypeDescription(os);
983     matcher_.DescribeNegationTo(os);
984   }
985  protected:
986   const Matcher&lt;To&gt; matcher_;
987   static std::string GetToName() {
988     return GetTypeName&lt;To&gt;();
989   }
990  private:
991   static void GetCastTypeDescription(::std::ostream* os) {
992     *os &lt;&lt; "when dynamic_cast to " &lt;&lt; GetToName() &lt;&lt; ", ";
993   }
994   GTEST_DISALLOW_ASSIGN_(WhenDynamicCastToMatcherBase);
995 };
996 template &lt;typename To&gt;
997 class WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase&lt;To&gt; {
998  public:
999   explicit WhenDynamicCastToMatcher(const Matcher&lt;To&gt;&amp; matcher)
1000       : WhenDynamicCastToMatcherBase&lt;To&gt;(matcher) {}
1001   template &lt;typename From&gt;
1002   bool MatchAndExplain(From from, MatchResultListener* listener) const {
1003     To to = dynamic_cast&lt;To&gt;(from);
1004     return MatchPrintAndExplain(to, this-&gt;matcher_, listener);
1005   }
1006 };
1007 template &lt;typename To&gt;
1008 class WhenDynamicCastToMatcher&lt;To&amp;&gt; : public WhenDynamicCastToMatcherBase&lt;To&amp;&gt; {
1009  public:
1010   explicit WhenDynamicCastToMatcher(const Matcher&lt;To&amp;&gt;&amp; matcher)
1011       : WhenDynamicCastToMatcherBase&lt;To&amp;&gt;(matcher) {}
1012   template &lt;typename From&gt;
1013   bool MatchAndExplain(From&amp; from, MatchResultListener* listener) const {
1014     To* to = dynamic_cast&lt;To*&gt;(&amp;from);
1015     if (to == nullptr) {
1016       *listener &lt;&lt; "which cannot be dynamic_cast to " &lt;&lt; this-&gt;GetToName();
1017       return false;
1018     }
1019     return MatchPrintAndExplain(*to, this-&gt;matcher_, listener);
1020   }
1021 };
1022 #endif  
1023 template &lt;typename Class, typename FieldType&gt;
1024 class FieldMatcher {
1025  public:
1026   FieldMatcher(FieldType Class::*field,
1027                const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)
1028       : field_(field), matcher_(matcher), whose_field_("whose given field ") {}
1029   FieldMatcher(const std::string&amp; field_name, FieldType Class::*field,
1030                const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)
1031       : field_(field),
1032         matcher_(matcher),
1033         whose_field_("whose field `" + field_name + "` ") {}
1034   void DescribeTo(::std::ostream* os) const {
1035     *os &lt;&lt; "is an object " &lt;&lt; whose_field_;
1036     matcher_.DescribeTo(os);
1037   }
1038   void DescribeNegationTo(::std::ostream* os) const {
1039     *os &lt;&lt; "is an object " &lt;&lt; whose_field_;
1040     matcher_.DescribeNegationTo(os);
1041   }
1042   template &lt;typename T&gt;
1043   bool MatchAndExplain(const T&amp; value, MatchResultListener* listener) const {
1044     return MatchAndExplainImpl(
1045         typename std::is_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type(),
1046         value, listener);
1047   }
1048  private:
1049   bool MatchAndExplainImpl(std::false_type                            const Class&amp; obj,
1050                            MatchResultListener* listener) const {
1051     *listener &lt;&lt; whose_field_ &lt;&lt; "is ";
1052     return MatchPrintAndExplain(obj.*field_, matcher_, listener);
1053   }
1054   bool MatchAndExplainImpl(std::true_type                            MatchResultListener* listener) const {
1055     if (p == nullptr) return false;
1056     *listener &lt;&lt; "which points to an object ";
1057     return MatchAndExplainImpl(std::false_type(), *p, listener);
1058   }
1059   const FieldType Class::*field_;
1060   const Matcher&lt;const FieldType&amp;&gt; matcher_;
1061   const std::string whose_field_;
1062   GTEST_DISALLOW_ASSIGN_(FieldMatcher);
1063 };
1064 template &lt;typename Class, typename PropertyType, typename Property&gt;
1065 class PropertyMatcher {
1066  public:
1067   typedef const PropertyType&amp; RefToConstProperty;
1068   PropertyMatcher(Property property, const Matcher&lt;RefToConstProperty&gt;&amp; matcher)
1069       : property_(property),
1070         matcher_(matcher),
1071         whose_property_("whose given property ") {}
1072   PropertyMatcher(const std::string&amp; property_name, Property property,
1073                   const Matcher&lt;RefToConstProperty&gt;&amp; matcher)
1074       : property_(property),
1075         matcher_(matcher),
1076         whose_property_("whose property `" + property_name + "` ") {}
1077   void DescribeTo(::std::ostream* os) const {
1078     *os &lt;&lt; "is an object " &lt;&lt; whose_property_;
1079     matcher_.DescribeTo(os);
1080   }
1081   void DescribeNegationTo(::std::ostream* os) const {
1082     *os &lt;&lt; "is an object " &lt;&lt; whose_property_;
1083     matcher_.DescribeNegationTo(os);
1084   }
1085   template &lt;typename T&gt;
1086   bool MatchAndExplain(const T&amp;value, MatchResultListener* listener) const {
1087     return MatchAndExplainImpl(
1088         typename std::is_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type(),
1089         value, listener);
1090   }
1091  private:
1092   bool MatchAndExplainImpl(std::false_type                            const Class&amp; obj,
1093                            MatchResultListener* listener) const {
1094     *listener &lt;&lt; whose_property_ &lt;&lt; "is ";
1095     RefToConstProperty result = (obj.*property_)();
1096     return MatchPrintAndExplain(result, matcher_, listener);
1097   }
1098   bool MatchAndExplainImpl(std::true_type                            MatchResultListener* listener) const {
1099     if (p == nullptr) return false;
1100     *listener &lt;&lt; "which points to an object ";
1101     return MatchAndExplainImpl(std::false_type(), *p, listener);
1102   }
1103   Property property_;
1104   const Matcher&lt;RefToConstProperty&gt; matcher_;
1105   const std::string whose_property_;
1106   GTEST_DISALLOW_ASSIGN_(PropertyMatcher);
1107 };
1108 template &lt;typename Functor&gt;
1109 struct CallableTraits {
1110   typedef Functor StorageType;
1111   static void CheckIsValid(Functor 
1112   template &lt;typename T&gt;
1113   static auto Invoke(Functor f, const T&amp; arg) -&gt; decltype(f(arg)) {
1114     return f(arg);
1115   }
1116 };
1117 template &lt;typename ArgType, typename ResType&gt;
1118 struct CallableTraits&lt;ResType(*)(ArgType)&gt; {
1119   typedef ResType ResultType;
1120   typedef ResType(*StorageType)(ArgType);
1121   static void CheckIsValid(ResType(*f)(ArgType)) {
1122     GTEST_CHECK_(f != nullptr)
1123         &lt;&lt; "NULL function pointer is passed into ResultOf().";
1124   }
1125   template &lt;typename T&gt;
1126   static ResType Invoke(ResType(*f)(ArgType), T arg) {
1127     return (*f)(arg);
1128   }
1129 };
1130 template &lt;typename Callable, typename InnerMatcher&gt;
1131 class ResultOfMatcher {
1132  public:
1133   ResultOfMatcher(Callable callable, InnerMatcher matcher)
1134       : callable_(std::move(callable)), matcher_(std::move(matcher)) {
1135     CallableTraits&lt;Callable&gt;::CheckIsValid(callable_);
1136   }
1137   template &lt;typename T&gt;
1138   operator Matcher&lt;T&gt;() const {
1139     return Matcher&lt;T&gt;(new Impl&lt;const T&amp;&gt;(callable_, matcher_));
1140   }
1141  private:
1142   typedef typename CallableTraits&lt;Callable&gt;::StorageType CallableStorageType;
1143   template &lt;typename T&gt;
1144   class Impl : public MatcherInterface&lt;T&gt; {
1145     using ResultType = decltype(CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(
1146         std::declval&lt;CallableStorageType&gt;(), std::declval&lt;T&gt;()));
1147    public:
1148     template &lt;typename M&gt;
1149     Impl(const CallableStorageType&amp; callable, const M&amp; matcher)
1150         : callable_(callable), matcher_(MatcherCast&lt;ResultType&gt;(matcher)) {}
1151     void DescribeTo(::std::ostream* os) const override {
1152       *os &lt;&lt; "is mapped by the given callable to a value that ";
1153       matcher_.DescribeTo(os);
1154     }
1155     void DescribeNegationTo(::std::ostream* os) const override {
1156       *os &lt;&lt; "is mapped by the given callable to a value that ";
1157       matcher_.DescribeNegationTo(os);
1158     }
1159     bool MatchAndExplain(T obj, MatchResultListener* listener) const override {
1160       *listener &lt;&lt; "which is mapped by the given callable to ";
1161       ResultType result =
1162           CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(callable_, obj);
1163       return MatchPrintAndExplain(result, matcher_, listener);
1164     }
1165    private:
1166     mutable CallableStorageType callable_;
1167     const Matcher&lt;ResultType&gt; matcher_;
1168     GTEST_DISALLOW_ASSIGN_(Impl);
1169   };  
1170   const CallableStorageType callable_;
1171   const InnerMatcher matcher_;
1172   GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);
1173 };
1174 template &lt;typename SizeMatcher&gt;
1175 class SizeIsMatcher {
1176  public:
1177   explicit SizeIsMatcher(const SizeMatcher&amp; size_matcher)
1178        : size_matcher_(size_matcher) {
1179   }
1180   template &lt;typename Container&gt;
1181   operator Matcher&lt;Container&gt;() const {
1182     return Matcher&lt;Container&gt;(new Impl&lt;const Container&amp;&gt;(size_matcher_));
1183   }
1184   template &lt;typename Container&gt;
1185   class Impl : public MatcherInterface&lt;Container&gt; {
1186    public:
1187     using SizeType = decltype(std::declval&lt;Container&gt;().size());
1188     explicit Impl(const SizeMatcher&amp; size_matcher)
1189         : size_matcher_(MatcherCast&lt;SizeType&gt;(size_matcher)) {}
1190     void DescribeTo(::std::ostream* os) const override {
1191       *os &lt;&lt; "size ";
1192       size_matcher_.DescribeTo(os);
1193     }
1194     void DescribeNegationTo(::std::ostream* os) const override {
1195       *os &lt;&lt; "size ";
1196       size_matcher_.DescribeNegationTo(os);
1197     }
1198     bool MatchAndExplain(Container container,
1199                          MatchResultListener* listener) const override {
1200       SizeType size = container.size();
1201       StringMatchResultListener size_listener;
1202       const bool result = size_matcher_.MatchAndExplain(size, &amp;size_listener);
1203       *listener
1204           &lt;&lt; "whose size " &lt;&lt; size &lt;&lt; (result ? " matches" : " doesn't match");
1205       PrintIfNotEmpty(size_listener.str(), listener-&gt;stream());
1206       return result;
1207     }
1208    private:
1209     const Matcher&lt;SizeType&gt; size_matcher_;
1210     GTEST_DISALLOW_ASSIGN_(Impl);
1211   };
1212  private:
1213   const SizeMatcher size_matcher_;
1214   GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);
1215 };
1216 template &lt;typename DistanceMatcher&gt;
1217 class BeginEndDistanceIsMatcher {
1218  public:
1219   explicit BeginEndDistanceIsMatcher(const DistanceMatcher&amp; distance_matcher)
1220       : distance_matcher_(distance_matcher) {}
1221   template &lt;typename Container&gt;
1222   operator Matcher&lt;Container&gt;() const {
1223     return Matcher&lt;Container&gt;(new Impl&lt;const Container&amp;&gt;(distance_matcher_));
1224   }
1225   template &lt;typename Container&gt;
1226   class Impl : public MatcherInterface&lt;Container&gt; {
1227    public:
1228     typedef internal::StlContainerView&lt;
1229         GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt; ContainerView;
1230     typedef typename std::iterator_traits&lt;
1231         typename ContainerView::type::const_iterator&gt;::difference_type
1232         DistanceType;
1233     explicit Impl(const DistanceMatcher&amp; distance_matcher)
1234         : distance_matcher_(MatcherCast&lt;DistanceType&gt;(distance_matcher)) {}
1235     void DescribeTo(::std::ostream* os) const override {
1236       *os &lt;&lt; "distance between begin() and end() ";
1237       distance_matcher_.DescribeTo(os);
1238     }
1239     void DescribeNegationTo(::std::ostream* os) const override {
1240       *os &lt;&lt; "distance between begin() and end() ";
1241       distance_matcher_.DescribeNegationTo(os);
1242     }
1243     bool MatchAndExplain(Container container,
1244                          MatchResultListener* listener) const override {
1245       using std::begin;
1246       using std::end;
1247       DistanceType distance = std::distance(begin(container), end(container));
1248       StringMatchResultListener distance_listener;
1249       const bool result =
1250           distance_matcher_.MatchAndExplain(distance, &amp;distance_listener);
1251       *listener &lt;&lt; "whose distance between begin() and end() " &lt;&lt; distance
1252                 &lt;&lt; (result ? " matches" : " doesn't match");
1253       PrintIfNotEmpty(distance_listener.str(), listener-&gt;stream());
1254       return result;
1255     }
1256    private:
1257     const Matcher&lt;DistanceType&gt; distance_matcher_;
1258     GTEST_DISALLOW_ASSIGN_(Impl);
1259   };
1260  private:
1261   const DistanceMatcher distance_matcher_;
1262   GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher);
1263 };
1264 template &lt;typename Container&gt;
1265 class ContainerEqMatcher {
1266  public:
1267   typedef internal::StlContainerView&lt;Container&gt; View;
1268   typedef typename View::type StlContainer;
1269   typedef typename View::const_reference StlContainerReference;
1270   static_assert(!std::is_const&lt;Container&gt;::value,
1271                 "Container type must not be const");
1272   static_assert(!std::is_reference&lt;Container&gt;::value,
1273                 "Container type must not be a reference");
1274   explicit ContainerEqMatcher(const Container&amp; expected)
1275       : expected_(View::Copy(expected)) {}
1276   void DescribeTo(::std::ostream* os) const {
1277     *os &lt;&lt; "equals ";
1278     UniversalPrint(expected_, os);
1279   }
1280   void DescribeNegationTo(::std::ostream* os) const {
1281     *os &lt;&lt; "does not equal ";
1282     UniversalPrint(expected_, os);
1283   }
1284   template &lt;typename LhsContainer&gt;
1285   bool MatchAndExplain(const LhsContainer&amp; lhs,
1286                        MatchResultListener* listener) const {
1287     typedef internal::StlContainerView&lt;
1288         typename std::remove_const&lt;LhsContainer&gt;::type&gt;
1289         LhsView;
1290     typedef typename LhsView::type LhsStlContainer;
1291     StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
1292     if (lhs_stl_container == expected_)
1293       return true;
1294     ::std::ostream* const os = listener-&gt;stream();
1295     if (os != nullptr) {
1296       bool printed_header = false;
1297       for (typename LhsStlContainer::const_iterator it =
1298                lhs_stl_container.begin();
1299            it != lhs_stl_container.end(); ++it) {
1300         if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==
1301             expected_.end()) {
1302           if (printed_header) {
1303             *os &lt;&lt; ", ";
1304           } else {
1305             *os &lt;&lt; "which has these unexpected elements: ";
1306             printed_header = true;
1307           }
1308           UniversalPrint(*it, os);
1309         }
1310       }
1311       bool printed_header2 = false;
1312       for (typename StlContainer::const_iterator it = expected_.begin();
1313            it != expected_.end(); ++it) {
1314         if (internal::ArrayAwareFind(
1315                 lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==
1316             lhs_stl_container.end()) {
1317           if (printed_header2) {
1318             *os &lt;&lt; ", ";
1319           } else {
1320             *os &lt;&lt; (printed_header ? ",\nand" : "which")
1321                 &lt;&lt; " doesn't have these expected elements: ";
1322             printed_header2 = true;
1323           }
1324           UniversalPrint(*it, os);
1325         }
1326       }
1327     }
1328     return false;
1329   }
1330  private:
1331   const StlContainer expected_;
1332   GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);
1333 };
1334 struct LessComparator {
1335   template &lt;typename T, typename U&gt;
1336   bool operator()(const T&amp; lhs, const U&amp; rhs) const { return lhs &lt; rhs; }
1337 };
1338 template &lt;typename Comparator, typename ContainerMatcher&gt;
1339 class WhenSortedByMatcher {
1340  public:
1341   WhenSortedByMatcher(const Comparator&amp; comparator,
1342                       const ContainerMatcher&amp; matcher)
1343       : comparator_(comparator), matcher_(matcher) {}
1344   template &lt;typename LhsContainer&gt;
1345   operator Matcher&lt;LhsContainer&gt;() const {
1346     return MakeMatcher(new Impl&lt;LhsContainer&gt;(comparator_, matcher_));
1347   }
1348   template &lt;typename LhsContainer&gt;
1349   class Impl : public MatcherInterface&lt;LhsContainer&gt; {
1350    public:
1351     typedef internal::StlContainerView&lt;
1352          GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt; LhsView;
1353     typedef typename LhsView::type LhsStlContainer;
1354     typedef typename LhsView::const_reference LhsStlContainerReference;
1355     typedef typename RemoveConstFromKey&lt;
1356         typename LhsStlContainer::value_type&gt;::type LhsValue;
1357     Impl(const Comparator&amp; comparator, const ContainerMatcher&amp; matcher)
1358         : comparator_(comparator), matcher_(matcher) {}
1359     void DescribeTo(::std::ostream* os) const override {
1360       *os &lt;&lt; "(when sorted) ";
1361       matcher_.DescribeTo(os);
1362     }
1363     void DescribeNegationTo(::std::ostream* os) const override {
1364       *os &lt;&lt; "(when sorted) ";
1365       matcher_.DescribeNegationTo(os);
1366     }
1367     bool MatchAndExplain(LhsContainer lhs,
1368                          MatchResultListener* listener) const override {
1369       LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
1370       ::std::vector&lt;LhsValue&gt; sorted_container(lhs_stl_container.begin(),
1371                                                lhs_stl_container.end());
1372       ::std::sort(
1373            sorted_container.begin(), sorted_container.end(), comparator_);
1374       if (!listener-&gt;IsInterested()) {
1375         return matcher_.Matches(sorted_container);
1376       }
1377       *listener &lt;&lt; "which is ";
1378       UniversalPrint(sorted_container, listener-&gt;stream());
1379       *listener &lt;&lt; " when sorted";
1380       StringMatchResultListener inner_listener;
1381       const bool match = matcher_.MatchAndExplain(sorted_container,
1382                                                   &amp;inner_listener);
1383       PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
1384       return match;
1385     }
1386    private:
1387     const Comparator comparator_;
1388     const Matcher&lt;const ::std::vector&lt;LhsValue&gt;&amp;&gt; matcher_;
1389     GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
1390   };
1391  private:
1392   const Comparator comparator_;
1393   const ContainerMatcher matcher_;
1394   GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);
1395 };
1396 template &lt;typename TupleMatcher, typename RhsContainer&gt;
1397 class PointwiseMatcher {
1398   GTEST_COMPILE_ASSERT_(
1399       !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)&gt;::value,
1400       use_UnorderedPointwise_with_hash_tables);
1401  public:
1402   typedef internal::StlContainerView&lt;RhsContainer&gt; RhsView;
1403   typedef typename RhsView::type RhsStlContainer;
1404   typedef typename RhsStlContainer::value_type RhsValue;
1405   static_assert(!std::is_const&lt;RhsContainer&gt;::value,
1406                 "RhsContainer type must not be const");
1407   static_assert(!std::is_reference&lt;RhsContainer&gt;::value,
1408                 "RhsContainer type must not be a reference");
1409   PointwiseMatcher(const TupleMatcher&amp; tuple_matcher, const RhsContainer&amp; rhs)
1410       : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {}
1411   template &lt;typename LhsContainer&gt;
1412   operator Matcher&lt;LhsContainer&gt;() const {
1413     GTEST_COMPILE_ASSERT_(
1414         !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt;::value,
1415         use_UnorderedPointwise_with_hash_tables);
1416     return Matcher&lt;LhsContainer&gt;(
1417         new Impl&lt;const LhsContainer&amp;&gt;(tuple_matcher_, rhs_));
1418   }
1419   template &lt;typename LhsContainer&gt;
1420   class Impl : public MatcherInterface&lt;LhsContainer&gt; {
1421    public:
1422     typedef internal::StlContainerView&lt;
1423          GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt; LhsView;
1424     typedef typename LhsView::type LhsStlContainer;
1425     typedef typename LhsView::const_reference LhsStlContainerReference;
1426     typedef typename LhsStlContainer::value_type LhsValue;
1427     typedef ::std::tuple&lt;const LhsValue&amp;, const RhsValue&amp;&gt; InnerMatcherArg;
1428     Impl(const TupleMatcher&amp; tuple_matcher, const RhsStlContainer&amp; rhs)
1429         : mono_tuple_matcher_(SafeMatcherCast&lt;InnerMatcherArg&gt;(tuple_matcher)),
1430           rhs_(rhs) {}
1431     void DescribeTo(::std::ostream* os) const override {
1432       *os &lt;&lt; "contains " &lt;&lt; rhs_.size()
1433           &lt;&lt; " values, where each value and its corresponding value in ";
1434       UniversalPrinter&lt;RhsStlContainer&gt;::Print(rhs_, os);
1435       *os &lt;&lt; " ";
1436       mono_tuple_matcher_.DescribeTo(os);
1437     }
1438     void DescribeNegationTo(::std::ostream* os) const override {
1439       *os &lt;&lt; "doesn't contain exactly " &lt;&lt; rhs_.size()
1440           &lt;&lt; " values, or contains a value x at some index i"
1441           &lt;&lt; " where x and the i-th value of ";
1442       UniversalPrint(rhs_, os);
1443       *os &lt;&lt; " ";
1444       mono_tuple_matcher_.DescribeNegationTo(os);
1445     }
1446     bool MatchAndExplain(LhsContainer lhs,
1447                          MatchResultListener* listener) const override {
1448       LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
1449       const size_t actual_size = lhs_stl_container.size();
1450       if (actual_size != rhs_.size()) {
1451         *listener &lt;&lt; "which contains " &lt;&lt; actual_size &lt;&lt; " values";
1452         return false;
1453       }
1454       typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();
1455       typename RhsStlContainer::const_iterator right = rhs_.begin();
1456       for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {
1457         if (listener-&gt;IsInterested()) {
1458           StringMatchResultListener inner_listener;
1459           if (!mono_tuple_matcher_.MatchAndExplain(
1460                   InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),
1461                                   ImplicitCast_&lt;const RhsValue&amp;&gt;(*right)),
1462                   &amp;inner_listener)) {
1463             *listener &lt;&lt; "where the value pair (";
1464             UniversalPrint(*left, listener-&gt;stream());
1465             *listener &lt;&lt; ", ";
1466             UniversalPrint(*right, listener-&gt;stream());
1467             *listener &lt;&lt; ") at index #" &lt;&lt; i &lt;&lt; " don't match";
1468             PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
1469             return false;
1470           }
1471         } else {
1472           if (!mono_tuple_matcher_.Matches(
1473                   InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),
1474                                   ImplicitCast_&lt;const RhsValue&amp;&gt;(*right))))
1475             return false;
1476         }
1477       }
1478       return true;
1479     }
1480    private:
1481     const Matcher&lt;InnerMatcherArg&gt; mono_tuple_matcher_;
1482     const RhsStlContainer rhs_;
1483     GTEST_DISALLOW_ASSIGN_(Impl);
1484   };
1485  private:
1486   const TupleMatcher tuple_matcher_;
1487   const RhsStlContainer rhs_;
1488   GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);
1489 };
1490 template &lt;typename Container&gt;
1491 class QuantifierMatcherImpl : public MatcherInterface&lt;Container&gt; {
1492  public:
1493   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
1494   typedef StlContainerView&lt;RawContainer&gt; View;
1495   typedef typename View::type StlContainer;
1496   typedef typename View::const_reference StlContainerReference;
1497   typedef typename StlContainer::value_type Element;
1498   template &lt;typename InnerMatcher&gt;
1499   explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)
1500       : inner_matcher_(
1501            testing::SafeMatcherCast&lt;const Element&amp;&gt;(inner_matcher)) {}
1502   bool MatchAndExplainImpl(bool all_elements_should_match,
1503                            Container container,
1504                            MatchResultListener* listener) const {
1505     StlContainerReference stl_container = View::ConstReference(container);
1506     size_t i = 0;
1507     for (typename StlContainer::const_iterator it = stl_container.begin();
1508          it != stl_container.end(); ++it, ++i) {
1509       StringMatchResultListener inner_listener;
1510       const bool matches = inner_matcher_.MatchAndExplain(*it, &amp;inner_listener);
1511       if (matches != all_elements_should_match) {
1512         *listener &lt;&lt; "whose element #" &lt;&lt; i
1513                   &lt;&lt; (matches ? " matches" : " doesn't match");
1514         PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
1515         return !all_elements_should_match;
1516       }
1517     }
1518     return all_elements_should_match;
1519   }
1520  protected:
1521   const Matcher&lt;const Element&amp;&gt; inner_matcher_;
1522   GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);
1523 };
1524 template &lt;typename Container&gt;
1525 class ContainsMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {
1526  public:
1527   template &lt;typename InnerMatcher&gt;
1528   explicit ContainsMatcherImpl(InnerMatcher inner_matcher)
1529       : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}
1530   void DescribeTo(::std::ostream* os) const override {
1531     *os &lt;&lt; "contains at least one element that ";
1532     this-&gt;inner_matcher_.DescribeTo(os);
1533   }
1534   void DescribeNegationTo(::std::ostream* os) const override {
1535     *os &lt;&lt; "doesn't contain any element that ";
1536     this-&gt;inner_matcher_.DescribeTo(os);
1537   }
1538   bool MatchAndExplain(Container container,
1539                        MatchResultListener* listener) const override {
1540     return this-&gt;MatchAndExplainImpl(false, container, listener);
1541   }
1542  private:
1543   GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);
1544 };
1545 template &lt;typename Container&gt;
1546 class EachMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {
1547  public:
1548   template &lt;typename InnerMatcher&gt;
1549   explicit EachMatcherImpl(InnerMatcher inner_matcher)
1550       : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}
1551   void DescribeTo(::std::ostream* os) const override {
1552     *os &lt;&lt; "only contains elements that ";
1553     this-&gt;inner_matcher_.DescribeTo(os);
1554   }
1555   void DescribeNegationTo(::std::ostream* os) const override {
1556     *os &lt;&lt; "contains some element that ";
1557     this-&gt;inner_matcher_.DescribeNegationTo(os);
1558   }
1559   bool MatchAndExplain(Container container,
1560                        MatchResultListener* listener) const override {
1561     return this-&gt;MatchAndExplainImpl(true, container, listener);
1562   }
1563  private:
1564   GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);
1565 };
1566 template &lt;typename M&gt;
1567 class ContainsMatcher {
1568  public:
1569   explicit ContainsMatcher(M m) : inner_matcher_(m) {}
1570   template &lt;typename Container&gt;
1571   operator Matcher&lt;Container&gt;() const {
1572     return Matcher&lt;Container&gt;(
1573         new ContainsMatcherImpl&lt;const Container&amp;&gt;(inner_matcher_));
1574   }
1575  private:
1576   const M inner_matcher_;
1577   GTEST_DISALLOW_ASSIGN_(ContainsMatcher);
1578 };
1579 template &lt;typename M&gt;
1580 class EachMatcher {
1581  public:
1582   explicit EachMatcher(M m) : inner_matcher_(m) {}
1583   template &lt;typename Container&gt;
1584   operator Matcher&lt;Container&gt;() const {
1585     return Matcher&lt;Container&gt;(
1586         new EachMatcherImpl&lt;const Container&amp;&gt;(inner_matcher_));
1587   }
1588  private:
1589   const M inner_matcher_;
1590   GTEST_DISALLOW_ASSIGN_(EachMatcher);
1591 };
1592 struct Rank1 {};
1593 struct Rank0 : Rank1 {};
1594 namespace pair_getters {
1595 using std::get;
1596 template &lt;typename T&gt;
1597 auto First(T&amp; x, Rank1) -&gt; decltype(get&lt;0&gt;(x)) {    return get&lt;0&gt;(x);
1598 }
1599 template &lt;typename T&gt;
1600 auto First(T&amp; x, Rank0) -&gt; decltype((x.first)) {    return x.first;
1601 }
1602 template &lt;typename T&gt;
1603 auto Second(T&amp; x, Rank1) -&gt; decltype(get&lt;1&gt;(x)) {    return get&lt;1&gt;(x);
1604 }
1605 template &lt;typename T&gt;
1606 auto Second(T&amp; x, Rank0) -&gt; decltype((x.second)) {    return x.second;
1607 }
1608 }  
1609 template &lt;typename PairType&gt;
1610 class KeyMatcherImpl : public MatcherInterface&lt;PairType&gt; {
1611  public:
1612   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
1613   typedef typename RawPairType::first_type KeyType;
1614   template &lt;typename InnerMatcher&gt;
1615   explicit KeyMatcherImpl(InnerMatcher inner_matcher)
1616       : inner_matcher_(
1617           testing::SafeMatcherCast&lt;const KeyType&amp;&gt;(inner_matcher)) {
1618   }
1619   bool MatchAndExplain(PairType key_value,
1620                        MatchResultListener* listener) const override {
1621     StringMatchResultListener inner_listener;
1622     const bool match = inner_matcher_.MatchAndExplain(
1623         pair_getters::First(key_value, Rank0()), &amp;inner_listener);
1624     const std::string explanation = inner_listener.str();
1625     if (explanation != "") {
1626       *listener &lt;&lt; "whose first field is a value " &lt;&lt; explanation;
1627     }
1628     return match;
1629   }
1630   void DescribeTo(::std::ostream* os) const override {
1631     *os &lt;&lt; "has a key that ";
1632     inner_matcher_.DescribeTo(os);
1633   }
1634   void DescribeNegationTo(::std::ostream* os) const override {
1635     *os &lt;&lt; "doesn't have a key that ";
1636     inner_matcher_.DescribeTo(os);
1637   }
1638  private:
1639   const Matcher&lt;const KeyType&amp;&gt; inner_matcher_;
1640   GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);
1641 };
1642 template &lt;typename M&gt;
1643 class KeyMatcher {
1644  public:
1645   explicit KeyMatcher(M m) : matcher_for_key_(m) {}
1646   template &lt;typename PairType&gt;
1647   operator Matcher&lt;PairType&gt;() const {
1648     return Matcher&lt;PairType&gt;(
1649         new KeyMatcherImpl&lt;const PairType&amp;&gt;(matcher_for_key_));
1650   }
1651  private:
1652   const M matcher_for_key_;
1653   GTEST_DISALLOW_ASSIGN_(KeyMatcher);
1654 };
1655 template &lt;typename PairType&gt;
1656 class PairMatcherImpl : public MatcherInterface&lt;PairType&gt; {
1657  public:
1658   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
1659   typedef typename RawPairType::first_type FirstType;
1660   typedef typename RawPairType::second_type SecondType;
1661   template &lt;typename FirstMatcher, typename SecondMatcher&gt;
1662   PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)
1663       : first_matcher_(
1664             testing::SafeMatcherCast&lt;const FirstType&amp;&gt;(first_matcher)),
1665         second_matcher_(
1666             testing::SafeMatcherCast&lt;const SecondType&amp;&gt;(second_matcher)) {
1667   }
1668   void DescribeTo(::std::ostream* os) const override {
1669     *os &lt;&lt; "has a first field that ";
1670     first_matcher_.DescribeTo(os);
1671     *os &lt;&lt; ", and has a second field that ";
1672     second_matcher_.DescribeTo(os);
1673   }
1674   void DescribeNegationTo(::std::ostream* os) const override {
1675     *os &lt;&lt; "has a first field that ";
1676     first_matcher_.DescribeNegationTo(os);
1677     *os &lt;&lt; ", or has a second field that ";
1678     second_matcher_.DescribeNegationTo(os);
1679   }
1680   bool MatchAndExplain(PairType a_pair,
1681                        MatchResultListener* listener) const override {
1682     if (!listener-&gt;IsInterested()) {
1683       return first_matcher_.Matches(pair_getters::First(a_pair, Rank0())) &amp;&amp;
1684              second_matcher_.Matches(pair_getters::Second(a_pair, Rank0()));
1685     }
1686     StringMatchResultListener first_inner_listener;
1687     if (!first_matcher_.MatchAndExplain(pair_getters::First(a_pair, Rank0()),
1688                                         &amp;first_inner_listener)) {
1689       *listener &lt;&lt; "whose first field does not match";
1690       PrintIfNotEmpty(first_inner_listener.str(), listener-&gt;stream());
1691       return false;
1692     }
1693     StringMatchResultListener second_inner_listener;
1694     if (!second_matcher_.MatchAndExplain(pair_getters::Second(a_pair, Rank0()),
1695                                          &amp;second_inner_listener)) {
1696       *listener &lt;&lt; "whose second field does not match";
1697       PrintIfNotEmpty(second_inner_listener.str(), listener-&gt;stream());
1698       return false;
1699     }
1700     ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),
1701                    listener);
1702     return true;
1703   }
1704  private:
1705   void ExplainSuccess(const std::string&amp; first_explanation,
1706                       const std::string&amp; second_explanation,
1707                       MatchResultListener* listener) const {
1708     *listener &lt;&lt; "whose both fields match";
1709     if (first_explanation != "") {
1710       *listener &lt;&lt; ", where the first field is a value " &lt;&lt; first_explanation;
1711     }
1712     if (second_explanation != "") {
1713       *listener &lt;&lt; ", ";
1714       if (first_explanation != "") {
1715         *listener &lt;&lt; "and ";
1716       } else {
1717         *listener &lt;&lt; "where ";
1718       }
1719       *listener &lt;&lt; "the second field is a value " &lt;&lt; second_explanation;
1720     }
1721   }
1722   const Matcher&lt;const FirstType&amp;&gt; first_matcher_;
1723   const Matcher&lt;const SecondType&amp;&gt; second_matcher_;
1724   GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);
1725 };
1726 template &lt;typename FirstMatcher, typename SecondMatcher&gt;
1727 class PairMatcher {
1728  public:
1729   PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)
1730       : first_matcher_(first_matcher), second_matcher_(second_matcher) {}
1731   template &lt;typename PairType&gt;
1732   operator Matcher&lt;PairType&gt; () const {
1733     return Matcher&lt;PairType&gt;(
1734         new PairMatcherImpl&lt;const PairType&amp;&gt;(first_matcher_, second_matcher_));
1735   }
1736  private:
1737   const FirstMatcher first_matcher_;
1738   const SecondMatcher second_matcher_;
1739   GTEST_DISALLOW_ASSIGN_(PairMatcher);
1740 };
1741 template &lt;typename Container&gt;
1742 class ElementsAreMatcherImpl : public MatcherInterface&lt;Container&gt; {
1743  public:
1744   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
1745   typedef internal::StlContainerView&lt;RawContainer&gt; View;
1746   typedef typename View::type StlContainer;
1747   typedef typename View::const_reference StlContainerReference;
1748   typedef typename StlContainer::value_type Element;
1749   template &lt;typename InputIter&gt;
1750   ElementsAreMatcherImpl(InputIter first, InputIter last) {
1751     while (first != last) {
1752       matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first++));
1753     }
1754   }
1755   void DescribeTo(::std::ostream* os) const override {
1756     if (count() == 0) {
1757       *os &lt;&lt; "is empty";
1758     } else if (count() == 1) {
1759       *os &lt;&lt; "has 1 element that ";
1760       matchers_[0].DescribeTo(os);
1761     } else {
1762       *os &lt;&lt; "has " &lt;&lt; Elements(count()) &lt;&lt; " where\n";
1763       for (size_t i = 0; i != count(); ++i) {
1764         *os &lt;&lt; "element #" &lt;&lt; i &lt;&lt; " ";
1765         matchers_[i].DescribeTo(os);
1766         if (i + 1 &lt; count()) {
1767           *os &lt;&lt; ",\n";
1768         }
1769       }
1770     }
1771   }
1772   void DescribeNegationTo(::std::ostream* os) const override {
1773     if (count() == 0) {
1774       *os &lt;&lt; "isn't empty";
1775       return;
1776     }
1777     *os &lt;&lt; "doesn't have " &lt;&lt; Elements(count()) &lt;&lt; ", or\n";
1778     for (size_t i = 0; i != count(); ++i) {
1779       *os &lt;&lt; "element #" &lt;&lt; i &lt;&lt; " ";
1780       matchers_[i].DescribeNegationTo(os);
1781       if (i + 1 &lt; count()) {
1782         *os &lt;&lt; ", or\n";
1783       }
1784     }
1785   }
1786   bool MatchAndExplain(Container container,
1787                        MatchResultListener* listener) const override {
1788     const bool listener_interested = listener-&gt;IsInterested();
1789     ::std::vector&lt;std::string&gt; explanations(count());
1790     StlContainerReference stl_container = View::ConstReference(container);
1791     typename StlContainer::const_iterator it = stl_container.begin();
1792     size_t exam_pos = 0;
1793     bool mismatch_found = false;  
1794     for (; it != stl_container.end() &amp;&amp; exam_pos != count(); ++it, ++exam_pos) {
1795       bool match;        if (listener_interested) {
1796         StringMatchResultListener s;
1797         match = matchers_[exam_pos].MatchAndExplain(*it, &amp;s);
1798         explanations[exam_pos] = s.str();
1799       } else {
1800         match = matchers_[exam_pos].Matches(*it);
1801       }
1802       if (!match) {
1803         mismatch_found = true;
1804         break;
1805       }
1806     }
1807     size_t actual_count = exam_pos;
1808     for (; it != stl_container.end(); ++it) {
1809       ++actual_count;
1810     }
1811     if (actual_count != count()) {
1812       if (listener_interested &amp;&amp; (actual_count != 0)) {
1813         *listener &lt;&lt; "which has " &lt;&lt; Elements(actual_count);
1814       }
1815       return false;
1816     }
1817     if (mismatch_found) {
1818       if (listener_interested) {
1819         *listener &lt;&lt; "whose element #" &lt;&lt; exam_pos &lt;&lt; " doesn't match";
1820         PrintIfNotEmpty(explanations[exam_pos], listener-&gt;stream());
1821       }
1822       return false;
1823     }
1824     if (listener_interested) {
1825       bool reason_printed = false;
1826       for (size_t i = 0; i != count(); ++i) {
1827         const std::string&amp; s = explanations[i];
1828         if (!s.empty()) {
1829           if (reason_printed) {
1830             *listener &lt;&lt; ",\nand ";
1831           }
1832           *listener &lt;&lt; "whose element #" &lt;&lt; i &lt;&lt; " matches, " &lt;&lt; s;
1833           reason_printed = true;
1834         }
1835       }
1836     }
1837     return true;
1838   }
1839  private:
1840   static Message Elements(size_t count) {
1841     return Message() &lt;&lt; count &lt;&lt; (count == 1 ? " element" : " elements");
1842   }
1843   size_t count() const { return matchers_.size(); }
1844   ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; matchers_;
1845   GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);
1846 };
1847 class GTEST_API_ MatchMatrix {
1848  public:
1849   MatchMatrix(size_t num_elements, size_t num_matchers)
1850       : num_elements_(num_elements),
1851         num_matchers_(num_matchers),
1852         matched_(num_elements_* num_matchers_, 0) {
1853   }
1854   size_t LhsSize() const { return num_elements_; }
1855   size_t RhsSize() const { return num_matchers_; }
1856   bool HasEdge(size_t ilhs, size_t irhs) const {
1857     return matched_[SpaceIndex(ilhs, irhs)] == 1;
1858   }
1859   void SetEdge(size_t ilhs, size_t irhs, bool b) {
1860     matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;
1861   }
1862   bool NextGraph();
1863   void Randomize();
1864   std::string DebugString() const;
1865  private:
1866   size_t SpaceIndex(size_t ilhs, size_t irhs) const {
1867     return ilhs * num_matchers_ + irhs;
1868   }
1869   size_t num_elements_;
1870   size_t num_matchers_;
1871   ::std::vector&lt;char&gt; matched_;
1872 };
1873 typedef ::std::pair&lt;size_t, size_t&gt; ElementMatcherPair;
1874 typedef ::std::vector&lt;ElementMatcherPair&gt; ElementMatcherPairs;
1875 GTEST_API_ ElementMatcherPairs
1876 FindMaxBipartiteMatching(const MatchMatrix&amp; g);
1877 struct UnorderedMatcherRequire {
1878   enum Flags {
1879     Superset = 1 &lt;&lt; 0,
1880     Subset = 1 &lt;&lt; 1,
1881     ExactMatch = Superset | Subset,
1882   };
1883 };
1884 class GTEST_API_ UnorderedElementsAreMatcherImplBase {
1885  protected:
1886   explicit UnorderedElementsAreMatcherImplBase(
1887       UnorderedMatcherRequire::Flags matcher_flags)
1888       : match_flags_(matcher_flags) {}
1889   typedef ::std::vector&lt;const MatcherDescriberInterface*&gt; MatcherDescriberVec;
1890   void DescribeToImpl(::std::ostream* os) const;
1891   void DescribeNegationToImpl(::std::ostream* os) const;
1892   bool VerifyMatchMatrix(const ::std::vector&lt;std::string&gt;&amp; element_printouts,
1893                          const MatchMatrix&amp; matrix,
1894                          MatchResultListener* listener) const;
1895   bool FindPairing(const MatchMatrix&amp; matrix,
1896                    MatchResultListener* listener) const;
1897   MatcherDescriberVec&amp; matcher_describers() {
1898     return matcher_describers_;
1899   }
1900   static Message Elements(size_t n) {
1901     return Message() &lt;&lt; n &lt;&lt; " element" &lt;&lt; (n == 1 ? "" : "s");
1902   }
1903   UnorderedMatcherRequire::Flags match_flags() const { return match_flags_; }
1904  private:
1905   UnorderedMatcherRequire::Flags match_flags_;
1906   MatcherDescriberVec matcher_describers_;
1907   GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);
1908 };
1909 template &lt;typename Container&gt;
1910 class UnorderedElementsAreMatcherImpl
1911     : public MatcherInterface&lt;Container&gt;,
1912       public UnorderedElementsAreMatcherImplBase {
1913  public:
1914   typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
1915   typedef internal::StlContainerView&lt;RawContainer&gt; View;
1916   typedef typename View::type StlContainer;
1917   typedef typename View::const_reference StlContainerReference;
1918   typedef typename StlContainer::const_iterator StlContainerConstIterator;
1919   typedef typename StlContainer::value_type Element;
1920   template &lt;typename InputIter&gt;
1921   UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags matcher_flags,
1922                                   InputIter first, InputIter last)
1923       : UnorderedElementsAreMatcherImplBase(matcher_flags) {
1924     for (; first != last; ++first) {
1925       matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first));
1926       matcher_describers().push_back(matchers_.back().GetDescriber());
1927     }
1928   }
1929   void DescribeTo(::std::ostream* os) const override {
1930     return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);
1931   }
1932   void DescribeNegationTo(::std::ostream* os) const override {
1933     return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);
1934   }
1935   bool MatchAndExplain(Container container,
1936                        MatchResultListener* listener) const override {
1937     StlContainerReference stl_container = View::ConstReference(container);
1938     ::std::vector&lt;std::string&gt; element_printouts;
1939     MatchMatrix matrix =
1940         AnalyzeElements(stl_container.begin(), stl_container.end(),
1941                         &amp;element_printouts, listener);
1942     if (matrix.LhsSize() == 0 &amp;&amp; matrix.RhsSize() == 0) {
1943       return true;
1944     }
1945     if (match_flags() == UnorderedMatcherRequire::ExactMatch) {
1946       if (matrix.LhsSize() != matrix.RhsSize()) {
1947         if (matrix.LhsSize() != 0 &amp;&amp; listener-&gt;IsInterested()) {
1948           *listener &lt;&lt; "which has " &lt;&lt; Elements(matrix.LhsSize());
1949         }
1950         return false;
1951       }
1952     }
1953     return VerifyMatchMatrix(element_printouts, matrix, listener) &amp;&amp;
1954            FindPairing(matrix, listener);
1955   }
1956  private:
1957   template &lt;typename ElementIter&gt;
1958   MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,
1959                               ::std::vector&lt;std::string&gt;* element_printouts,
1960                               MatchResultListener* listener) const {
1961     element_printouts-&gt;clear();
1962     ::std::vector&lt;char&gt; did_match;
1963     size_t num_elements = 0;
1964     for (; elem_first != elem_last; ++num_elements, ++elem_first) {
1965       if (listener-&gt;IsInterested()) {
1966         element_printouts-&gt;push_back(PrintToString(*elem_first));
1967       }
1968       for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
1969         did_match.push_back(Matches(matchers_[irhs])(*elem_first));
1970       }
1971     }
1972     MatchMatrix matrix(num_elements, matchers_.size());
1973     ::std::vector&lt;char&gt;::const_iterator did_match_iter = did_match.begin();
1974     for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {
1975       for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
1976         matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);
1977       }
1978     }
1979     return matrix;
1980   }
1981   ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; matchers_;
1982   GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);
1983 };
1984 <a name="1"></a>template &lt;typename Target&gt;
1985 struct CastAndAppendTransform {
1986   template &lt;typename Arg&gt;
1987 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  Matcher&lt;Target&gt; operator()(const Arg&amp; a) const {
1988     return MatcherCast&lt;Target&gt;(a);
1989   }
1990 };
1991 template &lt;typename MatcherTuple&gt;
1992 class UnorderedElementsAreMatcher {
1993  public:
1994   explicit UnorderedElementsAreMatcher(const MatcherTuple&amp; args)
1995       : matchers_(args) {}
1996   template &lt;typename Container&gt;
1997   operator Matcher&lt;Container&gt;() const {
1998     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;</b></font>
1999     typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;
2000     typedef typename View::value_type Element;
2001     typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; MatcherVec;
2002     MatcherVec matchers;
2003     matchers.reserve(::std::tuple_size&lt;MatcherTuple&gt;::value);
2004     TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,
2005                          ::std::back_inserter(matchers));
2006     return Matcher&lt;Container&gt;(
2007         new UnorderedElementsAreMatcherImpl&lt;const Container&amp;&gt;(
2008             UnorderedMatcherRequire::ExactMatch, matchers.begin(),
2009             matchers.end()));
2010   }
2011  private:
2012   const MatcherTuple matchers_;
2013   GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);
2014 };
2015 template &lt;typename MatcherTuple&gt;
2016 class ElementsAreMatcher {
2017  public:
2018   explicit ElementsAreMatcher(const MatcherTuple&amp; args) : matchers_(args) {}
2019   template &lt;typename Container&gt;
2020   operator Matcher&lt;Container&gt;() const {
2021     GTEST_COMPILE_ASSERT_(
2022         !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value ||
2023             ::std::tuple_size&lt;MatcherTuple&gt;::value &lt; 2,
2024         use_UnorderedElementsAre_with_hash_tables);
2025     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
2026     typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;
2027     typedef typename View::value_type Element;
2028     typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; MatcherVec;
2029     MatcherVec matchers;
2030     matchers.reserve(::std::tuple_size&lt;MatcherTuple&gt;::value);
2031     TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,
2032                          ::std::back_inserter(matchers));
2033     return Matcher&lt;Container&gt;(new ElementsAreMatcherImpl&lt;const Container&amp;&gt;(
2034         matchers.begin(), matchers.end()));
2035   }
2036  private:
2037   const MatcherTuple matchers_;
2038   GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);
2039 };
2040 template &lt;typename T&gt;
2041 class UnorderedElementsAreArrayMatcher {
2042  public:
2043   template &lt;typename Iter&gt;
2044   UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags match_flags,
2045                                    Iter first, Iter last)
2046       : match_flags_(match_flags), matchers_(first, last) {}
2047   template &lt;typename Container&gt;
2048   operator Matcher&lt;Container&gt;() const {
2049     return Matcher&lt;Container&gt;(
2050         new UnorderedElementsAreMatcherImpl&lt;const Container&amp;&gt;(
2051             match_flags_, matchers_.begin(), matchers_.end()));
2052   }
2053  private:
2054   UnorderedMatcherRequire::Flags match_flags_;
2055   ::std::vector&lt;T&gt; matchers_;
2056   GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);
2057 };
2058 template &lt;typename T&gt;
2059 class ElementsAreArrayMatcher {
2060  public:
2061   template &lt;typename Iter&gt;
2062   ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}
2063   template &lt;typename Container&gt;
2064   operator Matcher&lt;Container&gt;() const {
2065     GTEST_COMPILE_ASSERT_(
2066         !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value,
2067         use_UnorderedElementsAreArray_with_hash_tables);
2068     return Matcher&lt;Container&gt;(new ElementsAreMatcherImpl&lt;const Container&amp;&gt;(
2069         matchers_.begin(), matchers_.end()));
2070   }
2071  private:
2072   const ::std::vector&lt;T&gt; matchers_;
2073   GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);
2074 };
2075 template &lt;typename Tuple2Matcher, typename Second&gt;
2076 class BoundSecondMatcher {
2077  public:
2078   BoundSecondMatcher(const Tuple2Matcher&amp; tm, const Second&amp; second)
2079       : tuple2_matcher_(tm), second_value_(second) {}
2080   template &lt;typename T&gt;
2081   operator Matcher&lt;T&gt;() const {
2082     return MakeMatcher(new Impl&lt;T&gt;(tuple2_matcher_, second_value_));
2083   }
2084     GTEST_LOG_(FATAL) &lt;&lt; "BoundSecondMatcher should never be assigned.";
2085   }
2086  private:
2087   template &lt;typename T&gt;
2088   class Impl : public MatcherInterface&lt;T&gt; {
2089    public:
2090     typedef ::std::tuple&lt;T, Second&gt; ArgTuple;
2091     Impl(const Tuple2Matcher&amp; tm, const Second&amp; second)
2092         : mono_tuple2_matcher_(SafeMatcherCast&lt;const ArgTuple&amp;&gt;(tm)),
2093           second_value_(second) {}
2094     void DescribeTo(::std::ostream* os) const override {
2095       *os &lt;&lt; "and ";
2096       UniversalPrint(second_value_, os);
2097       *os &lt;&lt; " ";
2098       mono_tuple2_matcher_.DescribeTo(os);
2099     }
2100     bool MatchAndExplain(T x, MatchResultListener* listener) const override {
2101       return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),
2102                                                   listener);
2103     }
2104    private:
2105     const Matcher&lt;const ArgTuple&amp;&gt; mono_tuple2_matcher_;
2106     const Second second_value_;
2107     GTEST_DISALLOW_ASSIGN_(Impl);
2108   };
2109   const Tuple2Matcher tuple2_matcher_;
2110   const Second second_value_;
2111 };
2112 template &lt;typename Tuple2Matcher, typename Second&gt;
2113 BoundSecondMatcher&lt;Tuple2Matcher, Second&gt; MatcherBindSecond(
2114     const Tuple2Matcher&amp; tm, const Second&amp; second) {
2115   return BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;(tm, second);
2116 }
2117 GTEST_API_ std::string FormatMatcherDescription(bool negation,
2118                                                 const char* matcher_name,
2119                                                 const Strings&amp; param_values);
2120 template &lt;typename ValueMatcher&gt;
2121 class OptionalMatcher {
2122  public:
2123   explicit OptionalMatcher(const ValueMatcher&amp; value_matcher)
2124       : value_matcher_(value_matcher) {}
2125   template &lt;typename Optional&gt;
2126   operator Matcher&lt;Optional&gt;() const {
2127     return Matcher&lt;Optional&gt;(new Impl&lt;const Optional&amp;&gt;(value_matcher_));
2128   }
2129   template &lt;typename Optional&gt;
2130   class Impl : public MatcherInterface&lt;Optional&gt; {
2131    public:
2132     typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Optional) OptionalView;
2133     typedef typename OptionalView::value_type ValueType;
2134     explicit Impl(const ValueMatcher&amp; value_matcher)
2135         : value_matcher_(MatcherCast&lt;ValueType&gt;(value_matcher)) {}
2136     void DescribeTo(::std::ostream* os) const override {
2137       *os &lt;&lt; "value ";
2138       value_matcher_.DescribeTo(os);
2139     }
2140     void DescribeNegationTo(::std::ostream* os) const override {
2141       *os &lt;&lt; "value ";
2142       value_matcher_.DescribeNegationTo(os);
2143     }
2144     bool MatchAndExplain(Optional optional,
2145                          MatchResultListener* listener) const override {
2146       if (!optional) {
2147         *listener &lt;&lt; "which is not engaged";
2148         return false;
2149       }
2150       const ValueType&amp; value = *optional;
2151       StringMatchResultListener value_listener;
2152       const bool match = value_matcher_.MatchAndExplain(value, &amp;value_listener);
2153       *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(value)
2154                 &lt;&lt; (match ? " matches" : " doesn't match");
2155       PrintIfNotEmpty(value_listener.str(), listener-&gt;stream());
2156       return match;
2157     }
2158    private:
2159     const Matcher&lt;ValueType&gt; value_matcher_;
2160     GTEST_DISALLOW_ASSIGN_(Impl);
2161   };
2162  private:
2163   const ValueMatcher value_matcher_;
2164   GTEST_DISALLOW_ASSIGN_(OptionalMatcher);
2165 };
2166 namespace variant_matcher {
2167 template &lt;typename T&gt;
2168 void holds_alternative() {}
2169 template &lt;typename T&gt;
2170 void get() {}
2171 template &lt;typename T&gt;
2172 class VariantMatcher {
2173  public:
2174   explicit VariantMatcher(::testing::Matcher&lt;const T&amp;&gt; matcher)
2175       : matcher_(std::move(matcher)) {}
2176   template &lt;typename Variant&gt;
2177   bool MatchAndExplain(const Variant&amp; value,
2178                        ::testing::MatchResultListener* listener) const {
2179     using std::get;
2180     if (!listener-&gt;IsInterested()) {
2181       return holds_alternative&lt;T&gt;(value) &amp;&amp; matcher_.Matches(get&lt;T&gt;(value));
2182     }
2183     if (!holds_alternative&lt;T&gt;(value)) {
2184       *listener &lt;&lt; "whose value is not of type '" &lt;&lt; GetTypeName() &lt;&lt; "'";
2185       return false;
2186     }
2187     const T&amp; elem = get&lt;T&gt;(value);
2188     StringMatchResultListener elem_listener;
2189     const bool match = matcher_.MatchAndExplain(elem, &amp;elem_listener);
2190     *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(elem)
2191               &lt;&lt; (match ? " matches" : " doesn't match");
2192     PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());
2193     return match;
2194   }
2195   void DescribeTo(std::ostream* os) const {
2196     *os &lt;&lt; "is a variant&lt;&gt; with value of type '" &lt;&lt; GetTypeName()
2197         &lt;&lt; "' and the value ";
2198     matcher_.DescribeTo(os);
2199   }
2200   void DescribeNegationTo(std::ostream* os) const {
2201     *os &lt;&lt; "is a variant&lt;&gt; with value of type other than '" &lt;&lt; GetTypeName()
2202         &lt;&lt; "' or the value ";
2203     matcher_.DescribeNegationTo(os);
2204   }
2205  private:
2206   static std::string GetTypeName() {
2207 #if GTEST_HAS_RTTI
2208     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
2209         return internal::GetTypeName&lt;T&gt;());
2210 #endif
2211     return "the element type";
2212   }
2213   const ::testing::Matcher&lt;const T&amp;&gt; matcher_;
2214 };
2215 }  
2216 namespace any_cast_matcher {
2217 template &lt;typename T&gt;
2218 void any_cast() {}
2219 template &lt;typename T&gt;
2220 class AnyCastMatcher {
2221  public:
2222   explicit AnyCastMatcher(const ::testing::Matcher&lt;const T&amp;&gt;&amp; matcher)
2223       : matcher_(matcher) {}
2224   template &lt;typename AnyType&gt;
2225   bool MatchAndExplain(const AnyType&amp; value,
2226                        ::testing::MatchResultListener* listener) const {
2227     if (!listener-&gt;IsInterested()) {
2228       const T* ptr = any_cast&lt;T&gt;(&amp;value);
2229       return ptr != nullptr &amp;&amp; matcher_.Matches(*ptr);
2230     }
2231     const T* elem = any_cast&lt;T&gt;(&amp;value);
2232     if (elem == nullptr) {
2233       *listener &lt;&lt; "whose value is not of type '" &lt;&lt; GetTypeName() &lt;&lt; "'";
2234       return false;
2235     }
2236     StringMatchResultListener elem_listener;
2237     const bool match = matcher_.MatchAndExplain(*elem, &amp;elem_listener);
2238     *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(*elem)
2239               &lt;&lt; (match ? " matches" : " doesn't match");
2240     PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());
2241     return match;
2242   }
2243   void DescribeTo(std::ostream* os) const {
2244     *os &lt;&lt; "is an 'any' type with value of type '" &lt;&lt; GetTypeName()
2245         &lt;&lt; "' and the value ";
2246     matcher_.DescribeTo(os);
2247   }
2248   void DescribeNegationTo(std::ostream* os) const {
2249     *os &lt;&lt; "is an 'any' type with value of type other than '" &lt;&lt; GetTypeName()
2250         &lt;&lt; "' or the value ";
2251     matcher_.DescribeNegationTo(os);
2252   }
2253  private:
2254   static std::string GetTypeName() {
2255 #if GTEST_HAS_RTTI
2256     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
2257         return internal::GetTypeName&lt;T&gt;());
2258 #endif
2259     return "the element type";
2260   }
2261   const ::testing::Matcher&lt;const T&amp;&gt; matcher_;
2262 };
2263 }  
2264 template &lt;class ArgsTuple, size_t... k&gt;
2265 class ArgsMatcherImpl : public MatcherInterface&lt;ArgsTuple&gt; {
2266  public:
2267   using RawArgsTuple = typename std::decay&lt;ArgsTuple&gt;::type;
2268   using SelectedArgs =
2269       std::tuple&lt;typename std::tuple_element&lt;k, RawArgsTuple&gt;::type...&gt;;
2270   using MonomorphicInnerMatcher = Matcher&lt;const SelectedArgs&amp;&gt;;
2271   template &lt;typename InnerMatcher&gt;
2272   explicit ArgsMatcherImpl(const InnerMatcher&amp; inner_matcher)
2273       : inner_matcher_(SafeMatcherCast&lt;const SelectedArgs&amp;&gt;(inner_matcher)) {}
2274   bool MatchAndExplain(ArgsTuple args,
2275                        MatchResultListener* listener) const override {
2276     (void)args;
2277     const SelectedArgs&amp; selected_args =
2278         std::forward_as_tuple(std::get&lt;k&gt;(args)...);
2279     if (!listener-&gt;IsInterested()) return inner_matcher_.Matches(selected_args);
2280     PrintIndices(listener-&gt;stream());
2281     *listener &lt;&lt; "are " &lt;&lt; PrintToString(selected_args);
2282     StringMatchResultListener inner_listener;
2283     const bool match =
2284         inner_matcher_.MatchAndExplain(selected_args, &amp;inner_listener);
2285     PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
2286     return match;
2287   }
2288   void DescribeTo(::std::ostream* os) const override {
2289     *os &lt;&lt; "are a tuple ";
2290     PrintIndices(os);
2291     inner_matcher_.DescribeTo(os);
2292   }
2293   void DescribeNegationTo(::std::ostream* os) const override {
2294     *os &lt;&lt; "are a tuple ";
2295     PrintIndices(os);
2296     inner_matcher_.DescribeNegationTo(os);
2297   }
2298  private:
2299   static void PrintIndices(::std::ostream* os) {
2300     *os &lt;&lt; "whose fields (";
2301     const char* sep = "";
2302     (void)sep;
2303     const char* dummy[] = {"", (*os &lt;&lt; sep &lt;&lt; "#" &lt;&lt; k, sep = ", ")...};
2304     (void)dummy;
2305     *os &lt;&lt; ") ";
2306   }
2307   MonomorphicInnerMatcher inner_matcher_;
2308 };
2309 template &lt;class InnerMatcher, size_t... k&gt;
2310 class ArgsMatcher {
2311  public:
2312   explicit ArgsMatcher(InnerMatcher inner_matcher)
2313       : inner_matcher_(std::move(inner_matcher)) {}
2314   template &lt;typename ArgsTuple&gt;
2315   operator Matcher&lt;ArgsTuple&gt;() const {      return MakeMatcher(new ArgsMatcherImpl&lt;ArgsTuple, k...&gt;(inner_matcher_));
2316   }
2317  private:
2318   InnerMatcher inner_matcher_;
2319 };
2320 }  
2321 template &lt;typename Iter&gt;
2322 inline internal::ElementsAreArrayMatcher&lt;
2323     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
2324 ElementsAreArray(Iter first, Iter last) {
2325   typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
2326   return internal::ElementsAreArrayMatcher&lt;T&gt;(first, last);
2327 }
2328 template &lt;typename T&gt;
2329 inline internal::ElementsAreArrayMatcher&lt;T&gt; ElementsAreArray(
2330     const T* pointer, size_t count) {
2331   return ElementsAreArray(pointer, pointer + count);
2332 }
2333 template &lt;typename T, size_t N&gt;
2334 inline internal::ElementsAreArrayMatcher&lt;T&gt; ElementsAreArray(
2335     const T (&amp;array)[N]) {
2336   return ElementsAreArray(array, N);
2337 }
2338 template &lt;typename Container&gt;
2339 inline internal::ElementsAreArrayMatcher&lt;typename Container::value_type&gt;
2340 ElementsAreArray(const Container&amp; container) {
2341   return ElementsAreArray(container.begin(), container.end());
2342 }
2343 template &lt;typename T&gt;
2344 inline internal::ElementsAreArrayMatcher&lt;T&gt;
2345 ElementsAreArray(::std::initializer_list&lt;T&gt; xs) {
2346   return ElementsAreArray(xs.begin(), xs.end());
2347 }
2348 template &lt;typename Iter&gt;
2349 inline internal::UnorderedElementsAreArrayMatcher&lt;
2350     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
2351 UnorderedElementsAreArray(Iter first, Iter last) {
2352   typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
2353   return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
2354       internal::UnorderedMatcherRequire::ExactMatch, first, last);
2355 }
2356 template &lt;typename T&gt;
2357 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
2358 UnorderedElementsAreArray(const T* pointer, size_t count) {
2359   return UnorderedElementsAreArray(pointer, pointer + count);
2360 }
2361 template &lt;typename T, size_t N&gt;
2362 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
2363 UnorderedElementsAreArray(const T (&amp;array)[N]) {
2364   return UnorderedElementsAreArray(array, N);
2365 }
2366 template &lt;typename Container&gt;
2367 inline internal::UnorderedElementsAreArrayMatcher&lt;
2368     typename Container::value_type&gt;
2369 UnorderedElementsAreArray(const Container&amp; container) {
2370   return UnorderedElementsAreArray(container.begin(), container.end());
2371 }
2372 template &lt;typename T&gt;
2373 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
2374 UnorderedElementsAreArray(::std::initializer_list&lt;T&gt; xs) {
2375   return UnorderedElementsAreArray(xs.begin(), xs.end());
2376 }
2377 const internal::AnythingMatcher _ = {};
2378 template &lt;typename T&gt;
2379 inline Matcher&lt;T&gt; A() {
2380   return Matcher&lt;T&gt;(new internal::AnyMatcherImpl&lt;T&gt;());
2381 }
2382 template &lt;typename T&gt;
2383 inline Matcher&lt;T&gt; An() { return A&lt;T&gt;(); }
2384 template &lt;typename T, typename M&gt;
2385 Matcher&lt;T&gt; internal::MatcherCastImpl&lt;T, M&gt;::CastImpl(
2386     const M&amp; value, std::false_type     std::false_type   return Eq(value);
2387 }
2388 inline PolymorphicMatcher&lt;internal::IsNullMatcher &gt; IsNull() {
2389   return MakePolymorphicMatcher(internal::IsNullMatcher());
2390 }
2391 inline PolymorphicMatcher&lt;internal::NotNullMatcher &gt; NotNull() {
2392   return MakePolymorphicMatcher(internal::NotNullMatcher());
2393 }
2394 template &lt;typename T&gt;
2395 inline internal::RefMatcher&lt;T&amp;&gt; Ref(T&amp; x) {    return internal::RefMatcher&lt;T&amp;&gt;(x);
2396 }
2397 inline internal::FloatingEqMatcher&lt;double&gt; DoubleEq(double rhs) {
2398   return internal::FloatingEqMatcher&lt;double&gt;(rhs, false);
2399 }
2400 inline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleEq(double rhs) {
2401   return internal::FloatingEqMatcher&lt;double&gt;(rhs, true);
2402 }
2403 inline internal::FloatingEqMatcher&lt;double&gt; DoubleNear(
2404     double rhs, double max_abs_error) {
2405   return internal::FloatingEqMatcher&lt;double&gt;(rhs, false, max_abs_error);
2406 }
2407 inline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleNear(
2408     double rhs, double max_abs_error) {
2409   return internal::FloatingEqMatcher&lt;double&gt;(rhs, true, max_abs_error);
2410 }
2411 inline internal::FloatingEqMatcher&lt;float&gt; FloatEq(float rhs) {
2412   return internal::FloatingEqMatcher&lt;float&gt;(rhs, false);
2413 }
2414 inline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatEq(float rhs) {
2415   return internal::FloatingEqMatcher&lt;float&gt;(rhs, true);
2416 }
2417 inline internal::FloatingEqMatcher&lt;float&gt; FloatNear(
2418     float rhs, float max_abs_error) {
2419   return internal::FloatingEqMatcher&lt;float&gt;(rhs, false, max_abs_error);
2420 }
2421 <a name="5"></a>inline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatNear(
2422     float rhs, float max_abs_error) {
2423   return internal::FloatingEqMatcher&lt;float&gt;(rhs, true, max_abs_error);
2424 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
2425 template &lt;typename InnerMatcher&gt;
2426 inline internal::PointeeMatcher&lt;InnerMatcher&gt; Pointee(
2427     const InnerMatcher&amp; inner_matcher) {
2428   return internal::PointeeMatcher&lt;InnerMatcher&gt;(inner_matcher);
2429 }
2430 #if GTEST_HAS_RTTI
2431 template &lt;typename To&gt;
2432 inline PolymorphicMatcher&lt;internal::WhenDynamicCastToMatcher&lt;To&gt; &gt;</b></font>
2433 WhenDynamicCastTo(const Matcher&lt;To&gt;&amp; inner_matcher) {
2434   return MakePolymorphicMatcher(
2435       internal::WhenDynamicCastToMatcher&lt;To&gt;(inner_matcher));
2436 }
2437 #endif  
2438 template &lt;typename Class, typename FieldType, typename FieldMatcher&gt;
2439 inline PolymorphicMatcher&lt;
2440   internal::FieldMatcher&lt;Class, FieldType&gt; &gt; Field(
2441     FieldType Class::*field, const FieldMatcher&amp; matcher) {
2442   return MakePolymorphicMatcher(
2443       internal::FieldMatcher&lt;Class, FieldType&gt;(
2444           field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));
2445 }
2446 template &lt;typename Class, typename FieldType, typename FieldMatcher&gt;
2447 inline PolymorphicMatcher&lt;internal::FieldMatcher&lt;Class, FieldType&gt; &gt; Field(
2448     const std::string&amp; field_name, FieldType Class::*field,
2449     const FieldMatcher&amp; matcher) {
2450   return MakePolymorphicMatcher(internal::FieldMatcher&lt;Class, FieldType&gt;(
2451       field_name, field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));
2452 }
2453 template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
2454 inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
2455     Class, PropertyType, PropertyType (Class::*)() const&gt; &gt;
2456 Property(PropertyType (Class::*property)() const,
2457          const PropertyMatcher&amp; matcher) {
2458   return MakePolymorphicMatcher(
2459       internal::PropertyMatcher&lt;Class, PropertyType,
2460                                 PropertyType (Class::*)() const&gt;(
2461           property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
2462 }
2463 template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
2464 inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
2465     Class, PropertyType, PropertyType (Class::*)() const&gt; &gt;
2466 Property(const std::string&amp; property_name,
2467          PropertyType (Class::*property)() const,
2468          const PropertyMatcher&amp; matcher) {
2469   return MakePolymorphicMatcher(
2470       internal::PropertyMatcher&lt;Class, PropertyType,
2471                                 PropertyType (Class::*)() const&gt;(
2472           property_name, property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
2473 }
2474 template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
2475 inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
2476     Class, PropertyType, PropertyType (Class::*)() const &amp;&gt; &gt;
2477 Property(PropertyType (Class::*property)() const &amp;,
2478          const PropertyMatcher&amp; matcher) {
2479   return MakePolymorphicMatcher(
2480       internal::PropertyMatcher&lt;Class, PropertyType,
2481                                 PropertyType (Class::*)() const&amp;&gt;(
2482           property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
2483 }
2484 template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
2485 inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
2486     Class, PropertyType, PropertyType (Class::*)() const &amp;&gt; &gt;
2487 Property(const std::string&amp; property_name,
2488          PropertyType (Class::*property)() const &amp;,
2489          const PropertyMatcher&amp; matcher) {
2490   return MakePolymorphicMatcher(
2491       internal::PropertyMatcher&lt;Class, PropertyType,
2492                                 PropertyType (Class::*)() const&amp;&gt;(
2493           property_name, property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
2494 }
2495 template &lt;typename Callable, typename InnerMatcher&gt;
2496 internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt; ResultOf(
2497     Callable callable, InnerMatcher matcher) {
2498   return internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt;(
2499       std::move(callable), std::move(matcher));
2500 }
2501 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrEq(
2502     const std::string&amp; str) {
2503   return MakePolymorphicMatcher(
2504       internal::StrEqualityMatcher&lt;std::string&gt;(str, true, true));
2505 }
2506 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrNe(
2507     const std::string&amp; str) {
2508   return MakePolymorphicMatcher(
2509       internal::StrEqualityMatcher&lt;std::string&gt;(str, false, true));
2510 }
2511 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrCaseEq(
2512     const std::string&amp; str) {
2513   return MakePolymorphicMatcher(
2514       internal::StrEqualityMatcher&lt;std::string&gt;(str, true, false));
2515 }
2516 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrCaseNe(
2517     const std::string&amp; str) {
2518   return MakePolymorphicMatcher(
2519       internal::StrEqualityMatcher&lt;std::string&gt;(str, false, false));
2520 }
2521 inline PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::string&gt; &gt; HasSubstr(
2522     const std::string&amp; substring) {
2523   return MakePolymorphicMatcher(
2524       internal::HasSubstrMatcher&lt;std::string&gt;(substring));
2525 }
2526 inline PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::string&gt; &gt; StartsWith(
2527     const std::string&amp; prefix) {
2528   return MakePolymorphicMatcher(
2529       internal::StartsWithMatcher&lt;std::string&gt;(prefix));
2530 }
2531 inline PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::string&gt; &gt; EndsWith(
2532     const std::string&amp; suffix) {
2533   return MakePolymorphicMatcher(internal::EndsWithMatcher&lt;std::string&gt;(suffix));
2534 }
2535 #if GTEST_HAS_STD_WSTRING
2536 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt; StrEq(
2537     const std::wstring&amp; str) {
2538   return MakePolymorphicMatcher(
2539       internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, true));
2540 }
2541 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt; StrNe(
2542     const std::wstring&amp; str) {
2543   return MakePolymorphicMatcher(
2544       internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, true));
2545 }
2546 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt;
2547 StrCaseEq(const std::wstring&amp; str) {
2548   return MakePolymorphicMatcher(
2549       internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, false));
2550 }
2551 inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt;
2552 StrCaseNe(const std::wstring&amp; str) {
2553   return MakePolymorphicMatcher(
2554       internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, false));
2555 }
2556 inline PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::wstring&gt; &gt; HasSubstr(
2557     const std::wstring&amp; substring) {
2558   return MakePolymorphicMatcher(
2559       internal::HasSubstrMatcher&lt;std::wstring&gt;(substring));
2560 }
2561 inline PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::wstring&gt; &gt;
2562 StartsWith(const std::wstring&amp; prefix) {
2563   return MakePolymorphicMatcher(
2564       internal::StartsWithMatcher&lt;std::wstring&gt;(prefix));
2565 }
2566 <a name="3"></a>
2567 inline PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::wstring&gt; &gt; EndsWith(
2568 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    const std::wstring&amp; suffix) {
2569   return MakePolymorphicMatcher(
2570       internal::EndsWithMatcher&lt;std::wstring&gt;(suffix));
2571 }
2572 #endif  
2573 inline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }
2574 inline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }</b></font>
2575 inline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }
2576 inline internal::Le2Matcher Le() { return internal::Le2Matcher(); }
2577 inline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }
2578 inline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }
2579 inline internal::FloatingEq2Matcher&lt;float&gt; FloatEq() {
2580   return internal::FloatingEq2Matcher&lt;float&gt;();
2581 }
2582 inline internal::FloatingEq2Matcher&lt;double&gt; DoubleEq() {
2583   return internal::FloatingEq2Matcher&lt;double&gt;();
2584 }
2585 inline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatEq() {
2586   return internal::FloatingEq2Matcher&lt;float&gt;(true);
2587 }
2588 inline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleEq() {
2589   return internal::FloatingEq2Matcher&lt;double&gt;(true);
2590 }
2591 inline internal::FloatingEq2Matcher&lt;float&gt; FloatNear(float max_abs_error) {
2592   return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error);
2593 }
2594 inline internal::FloatingEq2Matcher&lt;double&gt; DoubleNear(double max_abs_error) {
2595   return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error);
2596 }
2597 inline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatNear(
2598     float max_abs_error) {
2599   return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error, true);
2600 }
2601 inline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleNear(
2602     double max_abs_error) {
2603   return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error, true);
2604 }
2605 <a name="0"></a>template &lt;typename InnerMatcher&gt;
2606 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>inline internal::NotMatcher&lt;InnerMatcher&gt; Not(InnerMatcher m) {
2607   return internal::NotMatcher&lt;InnerMatcher&gt;(m);
2608 }
2609 template &lt;typename Predicate&gt;
2610 inline PolymorphicMatcher&lt;internal::TrulyMatcher&lt;Predicate&gt; &gt;
2611 Truly(Predicate pred) {
2612   return MakePolymorphicMatcher(internal::TrulyMatcher&lt;Predicate&gt;(pred));
2613 }
2614 template &lt;typename SizeMatcher&gt;
2615 inline internal::SizeIsMatcher&lt;SizeMatcher&gt;
2616 SizeIs(const SizeMatcher&amp; size_matcher) {
2617   return internal::SizeIsMatcher&lt;SizeMatcher&gt;(size_matcher);
2618 }
2619 template &lt;typename DistanceMatcher&gt;</b></font>
2620 inline internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;
2621 BeginEndDistanceIs(const DistanceMatcher&amp; distance_matcher) {
2622   return internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;(distance_matcher);
2623 }
2624 template &lt;typename Container&gt;
2625 inline PolymorphicMatcher&lt;internal::ContainerEqMatcher&lt;
2626     typename std::remove_const&lt;Container&gt;::type&gt;&gt;
2627 ContainerEq(const Container&amp; rhs) {
2628   typedef typename std::remove_const&lt;Container&gt;::type RawContainer;
2629   return MakePolymorphicMatcher(
2630       internal::ContainerEqMatcher&lt;RawContainer&gt;(rhs));
2631 }
2632 template &lt;typename Comparator, typename ContainerMatcher&gt;
2633 inline internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;
2634 WhenSortedBy(const Comparator&amp; comparator,
2635              const ContainerMatcher&amp; container_matcher) {
2636   return internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;(
2637       comparator, container_matcher);
2638 }
2639 template &lt;typename ContainerMatcher&gt;
2640 inline internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;
2641 WhenSorted(const ContainerMatcher&amp; container_matcher) {
2642   return
2643       internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;(
2644           internal::LessComparator(), container_matcher);
2645 }
2646 template &lt;typename TupleMatcher, typename Container&gt;
2647 inline internal::PointwiseMatcher&lt;TupleMatcher,
2648                                   typename std::remove_const&lt;Container&gt;::type&gt;
2649 Pointwise(const TupleMatcher&amp; tuple_matcher, const Container&amp; rhs) {
2650   typedef typename std::remove_const&lt;Container&gt;::type RawContainer;
2651   return internal::PointwiseMatcher&lt;TupleMatcher, RawContainer&gt;(
2652       tuple_matcher, rhs);
2653 }
2654 template &lt;typename TupleMatcher, typename T&gt;
2655 inline internal::PointwiseMatcher&lt;TupleMatcher, std::vector&lt;T&gt; &gt; Pointwise(
2656     const TupleMatcher&amp; tuple_matcher, std::initializer_list&lt;T&gt; rhs) {
2657   return Pointwise(tuple_matcher, std::vector&lt;T&gt;(rhs));
2658 }
2659 template &lt;typename Tuple2Matcher, typename RhsContainer&gt;
2660 inline internal::UnorderedElementsAreArrayMatcher&lt;
2661     typename internal::BoundSecondMatcher&lt;
2662         Tuple2Matcher,
2663         typename internal::StlContainerView&lt;
2664             typename std::remove_const&lt;RhsContainer&gt;::type&gt;::type::value_type&gt;&gt;
2665 UnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,
2666                    const RhsContainer&amp; rhs_container) {
2667   typedef typename std::remove_const&lt;RhsContainer&gt;::type RawRhsContainer;
2668   typedef typename internal::StlContainerView&lt;RawRhsContainer&gt; RhsView;
2669   typedef typename RhsView::type RhsStlContainer;
2670   typedef typename RhsStlContainer::value_type Second;
2671   const RhsStlContainer&amp; rhs_stl_container =
2672       RhsView::ConstReference(rhs_container);
2673   ::std::vector&lt;internal::BoundSecondMatcher&lt;Tuple2Matcher, Second&gt; &gt; matchers;
2674   for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();
2675        it != rhs_stl_container.end(); ++it) {
2676     matchers.push_back(
2677         internal::MatcherBindSecond(tuple2_matcher, *it));
2678   }
2679   return UnorderedElementsAreArray(matchers);
2680 }
2681 template &lt;typename Tuple2Matcher, typename T&gt;
2682 inline internal::UnorderedElementsAreArrayMatcher&lt;
2683     typename internal::BoundSecondMatcher&lt;Tuple2Matcher, T&gt; &gt;
2684 UnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,
2685                    std::initializer_list&lt;T&gt; rhs) {
2686   return UnorderedPointwise(tuple2_matcher, std::vector&lt;T&gt;(rhs));
2687 }
2688 template &lt;typename M&gt;
2689 inline internal::ContainsMatcher&lt;M&gt; Contains(M matcher) {
2690   return internal::ContainsMatcher&lt;M&gt;(matcher);
2691 }
2692 template &lt;typename Iter&gt;
2693 inline internal::UnorderedElementsAreArrayMatcher&lt;
2694     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
2695 IsSupersetOf(Iter first, Iter last) {
2696   typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
2697   return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
2698       internal::UnorderedMatcherRequire::Superset, first, last);
2699 }
2700 template &lt;typename T&gt;
2701 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
2702     const T* pointer, size_t count) {
2703   return IsSupersetOf(pointer, pointer + count);
2704 }
2705 template &lt;typename T, size_t N&gt;
2706 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
2707     const T (&amp;array)[N]) {
2708   return IsSupersetOf(array, N);
2709 }
2710 template &lt;typename Container&gt;
2711 inline internal::UnorderedElementsAreArrayMatcher&lt;
2712     typename Container::value_type&gt;
2713 IsSupersetOf(const Container&amp; container) {
2714   return IsSupersetOf(container.begin(), container.end());
2715 }
2716 template &lt;typename T&gt;
2717 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
2718     ::std::initializer_list&lt;T&gt; xs) {
2719   return IsSupersetOf(xs.begin(), xs.end());
2720 }
2721 template &lt;typename Iter&gt;
2722 inline internal::UnorderedElementsAreArrayMatcher&lt;
2723     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
2724 IsSubsetOf(Iter first, Iter last) {
2725   typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
2726   return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
2727       internal::UnorderedMatcherRequire::Subset, first, last);
2728 }
2729 template &lt;typename T&gt;
2730 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
2731     const T* pointer, size_t count) {
2732   return IsSubsetOf(pointer, pointer + count);
2733 }
2734 template &lt;typename T, size_t N&gt;
2735 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
2736     const T (&amp;array)[N]) {
2737   return IsSubsetOf(array, N);
2738 }
2739 template &lt;typename Container&gt;
2740 inline internal::UnorderedElementsAreArrayMatcher&lt;
2741     typename Container::value_type&gt;
2742 IsSubsetOf(const Container&amp; container) {
2743   return IsSubsetOf(container.begin(), container.end());
2744 }
2745 template &lt;typename T&gt;
2746 inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
2747     ::std::initializer_list&lt;T&gt; xs) {
2748   return IsSubsetOf(xs.begin(), xs.end());
2749 }
2750 template &lt;typename M&gt;
2751 inline internal::EachMatcher&lt;M&gt; Each(M matcher) {
2752   return internal::EachMatcher&lt;M&gt;(matcher);
2753 }
2754 template &lt;typename M&gt;
2755 inline internal::KeyMatcher&lt;M&gt; Key(M inner_matcher) {
2756   return internal::KeyMatcher&lt;M&gt;(inner_matcher);
2757 }
2758 template &lt;typename FirstMatcher, typename SecondMatcher&gt;
2759 inline internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;
2760 Pair(FirstMatcher first_matcher, SecondMatcher second_matcher) {
2761   return internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;(
2762       first_matcher, second_matcher);
2763 }
2764 template &lt;typename M&gt;
2765 inline internal::MatcherAsPredicate&lt;M&gt; Matches(M matcher) {
2766   return internal::MatcherAsPredicate&lt;M&gt;(matcher);
2767 }
2768 template &lt;typename T, typename M&gt;
2769 inline bool Value(const T&amp; value, M matcher) {
2770   return testing::Matches(matcher)(value);
2771 }
2772 template &lt;typename T, typename M&gt;
2773 inline bool ExplainMatchResult(
2774     M matcher, const T&amp; value, MatchResultListener* listener) {
2775   return SafeMatcherCast&lt;const T&amp;&gt;(matcher).MatchAndExplain(value, listener);
2776 }
2777 template &lt;typename T, typename M&gt;
2778 std::string DescribeMatcher(const M&amp; matcher, bool negation = false) {
2779   ::std::stringstream ss;
2780   Matcher&lt;T&gt; monomorphic_matcher = SafeMatcherCast&lt;T&gt;(matcher);
2781   if (negation) {
2782     monomorphic_matcher.DescribeNegationTo(&amp;ss);
2783   } else {
2784     monomorphic_matcher.DescribeTo(&amp;ss);
2785   }
2786   return ss.str();
2787 }
2788 template &lt;typename... Args&gt;
2789 internal::ElementsAreMatcher&lt;
2790     std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;
2791 ElementsAre(const Args&amp;... matchers) {
2792   return internal::ElementsAreMatcher&lt;
2793       std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(
2794       std::make_tuple(matchers...));
2795 }
2796 template &lt;typename... Args&gt;
2797 internal::UnorderedElementsAreMatcher&lt;
2798     std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;
2799 UnorderedElementsAre(const Args&amp;... matchers) {
2800   return internal::UnorderedElementsAreMatcher&lt;
2801       std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(
2802       std::make_tuple(matchers...));
2803 }
2804 template &lt;typename... Args&gt;
2805 internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AllOf(
2806     const Args&amp;... matchers) {
2807   return internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(
2808       matchers...);
2809 }
2810 template &lt;typename... Args&gt;
2811 internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AnyOf(
2812     const Args&amp;... matchers) {
2813   return internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(
2814       matchers...);
2815 }
2816 template &lt;typename Iter&gt;
2817 inline internal::AnyOfArrayMatcher&lt;
2818     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
2819 AnyOfArray(Iter first, Iter last) {
2820   return internal::AnyOfArrayMatcher&lt;
2821       typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;(first, last);
2822 }
2823 template &lt;typename Iter&gt;
2824 inline internal::AllOfArrayMatcher&lt;
2825     typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
2826 AllOfArray(Iter first, Iter last) {
2827   return internal::AllOfArrayMatcher&lt;
2828       typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;(first, last);
2829 }
2830 template &lt;typename T&gt;
2831 inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(const T* ptr, size_t count) {
2832   return AnyOfArray(ptr, ptr + count);
2833 }
2834 template &lt;typename T&gt;
2835 inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(const T* ptr, size_t count) {
2836   return AllOfArray(ptr, ptr + count);
2837 }
2838 template &lt;typename T, size_t N&gt;
2839 inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(const T (&amp;array)[N]) {
2840   return AnyOfArray(array, N);
2841 }
2842 template &lt;typename T, size_t N&gt;
2843 inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(const T (&amp;array)[N]) {
2844   return AllOfArray(array, N);
2845 }
2846 template &lt;typename Container&gt;
2847 inline internal::AnyOfArrayMatcher&lt;typename Container::value_type&gt; AnyOfArray(
2848     const Container&amp; container) {
2849   return AnyOfArray(container.begin(), container.end());
2850 }
2851 template &lt;typename Container&gt;
2852 inline internal::AllOfArrayMatcher&lt;typename Container::value_type&gt; AllOfArray(
2853     const Container&amp; container) {
2854   return AllOfArray(container.begin(), container.end());
2855 }
2856 template &lt;typename T&gt;
2857 inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(
2858     ::std::initializer_list&lt;T&gt; xs) {
2859   return AnyOfArray(xs.begin(), xs.end());
2860 }
2861 template &lt;typename T&gt;
2862 inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(
2863     ::std::initializer_list&lt;T&gt; xs) {
2864   return AllOfArray(xs.begin(), xs.end());
2865 }
2866 template &lt;size_t... k, typename InnerMatcher&gt;
2867 internal::ArgsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type, k...&gt; Args(
2868     InnerMatcher&amp;&amp; matcher) {
2869   return internal::ArgsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type, k...&gt;(
2870       std::forward&lt;InnerMatcher&gt;(matcher));
2871 }
2872 template &lt;typename InnerMatcher&gt;
2873 inline InnerMatcher AllArgs(const InnerMatcher&amp; matcher) { return matcher; }
2874 template &lt;typename ValueMatcher&gt;
2875 inline internal::OptionalMatcher&lt;ValueMatcher&gt; Optional(
2876     const ValueMatcher&amp; value_matcher) {
2877   return internal::OptionalMatcher&lt;ValueMatcher&gt;(value_matcher);
2878 }
2879 template &lt;typename T&gt;
2880 PolymorphicMatcher&lt;internal::any_cast_matcher::AnyCastMatcher&lt;T&gt; &gt; AnyWith(
2881     const Matcher&lt;const T&amp;&gt;&amp; matcher) {
2882   return MakePolymorphicMatcher(
2883       internal::any_cast_matcher::AnyCastMatcher&lt;T&gt;(matcher));
2884 }
2885 template &lt;typename T&gt;
2886 PolymorphicMatcher&lt;internal::variant_matcher::VariantMatcher&lt;T&gt; &gt; VariantWith(
2887     const Matcher&lt;const T&amp;&gt;&amp; matcher) {
2888   return MakePolymorphicMatcher(
2889       internal::variant_matcher::VariantMatcher&lt;T&gt;(matcher));
2890 }
2891 #define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\
2892     ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
2893 #define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\
2894     ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
2895 }  
2896 GTEST_DISABLE_MSC_WARNINGS_POP_()  
2897 #include "gmock/internal/custom/gmock-matchers.h"
#endif  </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
