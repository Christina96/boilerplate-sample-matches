<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for gmock-actions.h &amp; gmock-matchers.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for gmock-actions.h &amp; gmock-matchers.h
      </h3>
<h1 align="center">
        3.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>gmock-actions.h (9.1277895%)<th>gmock-matchers.h (2.0463848%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1015-1037)<td><a href="#" name="0">(3993-4023)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(822-843)<td><a href="#" name="1">(3043-3057)</a><td align="center"><font color="#d80000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(427-437)<td><a href="#" name="2">(573-588)</a><td align="center"><font color="#bf0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1005-1015)<td><a href="#" name="3">(3907-3920)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(665-685)<td><a href="#" name="4">(1580-1601)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1110-1131)<td><a href="#" name="5">(3683-3701)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>gmock-actions.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
#define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
#ifndef _WIN32_WCE
# include &lt;errno.h&gt;
#endif
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;
#include "gmock/internal/gmock-internal-utils.h"
#include "gmock/internal/gmock-port.h"
#ifdef _MSC_VER
# pragma warning(push)
# pragma warning(disable:4100)
#endif
namespace testing {
namespace internal {
template &lt;typename T, bool kDefaultConstructible&gt;
struct BuiltInDefaultValueGetter {
  static T Get() { return T(); }
};
template &lt;typename T&gt;
struct BuiltInDefaultValueGetter&lt;T, false&gt; {
  static T Get() {
    Assert(false, __FILE__, __LINE__,
           "Default action undefined for the function return type.");
    return internal::Invalid&lt;T&gt;();
  }
};
template &lt;typename T&gt;
class BuiltInDefaultValue {
 public:
  static bool Exists() {
    return ::std::is_default_constructible&lt;T&gt;::value;
  }
  static T Get() {
    return BuiltInDefaultValueGetter&lt;
        T, ::std::is_default_constructible&lt;T&gt;::value&gt;::Get();
  }
};
template &lt;typename T&gt;
class BuiltInDefaultValue&lt;const T&gt; {
 public:
  static bool Exists() { return BuiltInDefaultValue&lt;T&gt;::Exists(); }
  static T Get() { return BuiltInDefaultValue&lt;T&gt;::Get(); }
};
template &lt;typename T&gt;
class BuiltInDefaultValue&lt;T*&gt; {
 public:
  static bool Exists() { return true; }
  static T* Get() { return nullptr; }
};
#define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \
  template &lt;&gt; \
  class BuiltInDefaultValue&lt;type&gt; { \
   public: \
    static bool Exists() { return true; } \
    static type Get() { return value; } \
  }
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, );  GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, "");
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, '\0');
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed char, '\0');
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(char, '\0');
#if GMOCK_WCHAR_T_IS_NATIVE_
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(wchar_t, 0U);  #endif
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned short, 0U);  GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed short, 0);     GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL);  GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L);     GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(UInt64, 0);
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(Int64, 0);
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);
GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);
#undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_
}  
template &lt;typename T&gt;
class DefaultValue {
 public:
  static void Set(T x) {
    delete producer_;
    producer_ = new FixedValueProducer(x);
  }
  typedef T (*FactoryFunction)();
  static void SetFactory(FactoryFunction factory) {
    delete producer_;
    producer_ = new FactoryValueProducer(factory);
  }
  static void Clear() {
    delete producer_;
    producer_ = nullptr;
  }
  static bool IsSet() { return producer_ != nullptr; }
  static bool Exists() {
    return IsSet() || internal::BuiltInDefaultValue&lt;T&gt;::Exists();
  }
  static T Get() {
    return producer_ == nullptr ? internal::BuiltInDefaultValue&lt;T&gt;::Get()
                                : producer_-&gt;Produce();
  }
 private:
  class ValueProducer {
   public:
    virtual ~ValueProducer() {}
    virtual T Produce() = 0;
  };
  class FixedValueProducer : public ValueProducer {
   public:
    explicit FixedValueProducer(T value) : value_(value) {}
    T Produce() override { return value_; }
   private:
    const T value_;
    GTEST_DISALLOW_COPY_AND_ASSIGN_(FixedValueProducer);
  };
  class FactoryValueProducer : public ValueProducer {
   public:
    explicit FactoryValueProducer(FactoryFunction factory)
        : factory_(factory) {}
    T Produce() override { return factory_(); }
   private:
    const FactoryFunction factory_;
    GTEST_DISALLOW_COPY_AND_ASSIGN_(FactoryValueProducer);
  };
  static ValueProducer* producer_;
};
template &lt;typename T&gt;
class DefaultValue&lt;T&amp;&gt; {
 public:
  static void Set(T&amp; x) {      address_ = &amp;x;
  }
  static void Clear() { address_ = nullptr; }
  static bool IsSet() { return address_ != nullptr; }
  static bool Exists() {
    return IsSet() || internal::BuiltInDefaultValue&lt;T&amp;&gt;::Exists();
  }
  static T&amp; Get() {
    return address_ == nullptr ? internal::BuiltInDefaultValue&lt;T&amp;&gt;::Get()
                               : *address_;
  }
 private:
  static T* address_;
};
template &lt;&gt;
class DefaultValue&lt;void&gt; {
 public:
  static bool Exists() { return true; }
  static void Get() {}
};
template &lt;typename T&gt;
typename DefaultValue&lt;T&gt;::ValueProducer* DefaultValue&lt;T&gt;::producer_ = nullptr;
template &lt;typename T&gt;
T* DefaultValue&lt;T&amp;&gt;::address_ = nullptr;
template &lt;typename F&gt;
class ActionInterface {
 public:
  typedef typename internal::Function&lt;F&gt;::Result Result;
  typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
  ActionInterface() {}
  virtual ~ActionInterface() {}
  virtual Result Perform(const ArgumentTuple&amp; args) = 0;
 private:
  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface);
};
template &lt;typename F&gt;
class Action {
  struct ActionAdapter {
    ::std::shared_ptr&lt;ActionInterface&lt;F&gt;&gt; impl_;
    template &lt;typename... Args&gt;
    typename internal::Function&lt;F&gt;::Result operator()(Args&amp;&amp;... args) {
      return impl_-&gt;Perform(
          ::std::forward_as_tuple(::std::forward&lt;Args&gt;(args)...));
    }
  };
 public:
  typedef typename internal::Function&lt;F&gt;::Result Result;
  typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
  Action() {}
  template &lt;typename G,
            typename = typename ::std::enable_if&lt;
                ::std::is_constructible&lt;::std::function&lt;F&gt;, G&gt;::value&gt;::type&gt;
  Action(G&amp;&amp; fun) : fun_(::std::forward&lt;G&gt;(fun)) {}  
  explicit Action(ActionInterface&lt;F&gt;* impl)
      : fun_(ActionAdapter{::std::shared_ptr&lt;ActionInterface&lt;F&gt;&gt;(impl)}) {}
  template &lt;typename Func&gt;
  explicit Action(const Action&lt;Func&gt;&amp; action) : fun_(action.fun_) {}
  bool IsDoDefault() const { return fun_ == nullptr; }
  Result Perform(ArgumentTuple args) const {
    if (IsDoDefault()) {
      internal::IllegalDoDefault(__FILE__, __LINE__);
    }
    return internal::Apply(fun_, ::std::move(args));
  }
 private:
  template &lt;typename G&gt;
  friend class Action;
  ::std::function&lt;F&gt; fun_;
};
<a name="2"></a>template &lt;typename Impl&gt;
class PolymorphicAction {
 public:
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  explicit PolymorphicAction(const Impl&amp; impl) : impl_(impl) {}
  template &lt;typename F&gt;
  operator Action&lt;F&gt;() const {
    return Action&lt;F&gt;(new MonomorphicImpl&lt;F&gt;(impl_));
  }
 private:
  template &lt;typename F&gt;
  class MonomorphicImpl : public ActionInterface&lt;F&gt; {
   public:</b></font>
    typedef typename internal::Function&lt;F&gt;::Result Result;
    typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
    explicit MonomorphicImpl(const Impl&amp; impl) : impl_(impl) {}
    Result Perform(const ArgumentTuple&amp; args) override {
      return impl_.template Perform&lt;Result&gt;(args);
    }
   private:
    Impl impl_;
    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);
  };
  Impl impl_;
  GTEST_DISALLOW_ASSIGN_(PolymorphicAction);
};
template &lt;typename F&gt;
Action&lt;F&gt; MakeAction(ActionInterface&lt;F&gt;* impl) {
  return Action&lt;F&gt;(impl);
}
template &lt;typename Impl&gt;
inline PolymorphicAction&lt;Impl&gt; MakePolymorphicAction(const Impl&amp; impl) {
  return PolymorphicAction&lt;Impl&gt;(impl);
}
namespace internal {
template &lt;typename T&gt;
struct ByMoveWrapper {
  explicit ByMoveWrapper(T value) : payload(std::move(value)) {}
  T payload;
};
template &lt;typename R&gt;
class ReturnAction {
 public:
  explicit ReturnAction(R value) : value_(new R(std::move(value))) {}
  template &lt;typename F&gt;
  operator Action&lt;F&gt;() const {      typedef typename Function&lt;F&gt;::Result Result;
    GTEST_COMPILE_ASSERT_(
        !std::is_reference&lt;Result&gt;::value,
        use_ReturnRef_instead_of_Return_to_return_a_reference);
    static_assert(!std::is_void&lt;Result&gt;::value,
                  "Can't use Return() on an action expected to return `void`.");
    return Action&lt;F&gt;(new Impl&lt;R, F&gt;(value_));
  }
 private:
  template &lt;typename R_, typename F&gt;
  class Impl : public ActionInterface&lt;F&gt; {
   public:
    typedef typename Function&lt;F&gt;::Result Result;
    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
    explicit Impl(const std::shared_ptr&lt;R&gt;&amp; value)
        : value_before_cast_(*value),
          value_(ImplicitCast_&lt;Result&gt;(value_before_cast_)) {}
    Result Perform(const ArgumentTuple&amp;) override { return value_; }
   private:
    GTEST_COMPILE_ASSERT_(!std::is_reference&lt;Result&gt;::value,
                          Result_cannot_be_a_reference_type);
    R value_before_cast_;
    Result value_;
    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
  };
  template &lt;typename R_, typename F&gt;
  class Impl&lt;ByMoveWrapper&lt;R_&gt;, F&gt; : public ActionInterface&lt;F&gt; {
   public:
    typedef typename Function&lt;F&gt;::Result Result;
    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
    explicit Impl(const std::shared_ptr&lt;R&gt;&amp; wrapper)
        : performed_(false), wrapper_(wrapper) {}
    Result Perform(const ArgumentTuple&amp;) override {
      GTEST_CHECK_(!performed_)
          &lt;&lt; "A ByMove() action should only be performed once.";
      performed_ = true;
      return std::move(wrapper_-&gt;payload);
    }
   private:
    bool performed_;
    const std::shared_ptr&lt;R&gt; wrapper_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
  const std::shared_ptr&lt;R&gt; value_;
  GTEST_DISALLOW_ASSIGN_(ReturnAction);
};
class ReturnNullAction {
 public:
  template &lt;typename Result, typename ArgumentTuple&gt;
  static Result Perform(const ArgumentTuple&amp;) {
    return nullptr;
  }
};
class ReturnVoidAction {
 public:
  template &lt;typename Result, typename ArgumentTuple&gt;
  static void Perform(const ArgumentTuple&amp;) {
    static_assert(std::is_void&lt;Result&gt;::value, "Result should be void.");
  }
};
template &lt;typename T&gt;
class ReturnRefAction {
 public:
  explicit ReturnRefAction(T&amp; ref) : ref_(ref) {}  
  template &lt;typename F&gt;
  operator Action&lt;F&gt;() const {
    typedef typename Function&lt;F&gt;::Result Result;
    GTEST_COMPILE_ASSERT_(std::is_reference&lt;Result&gt;::value,
                          use_Return_instead_of_ReturnRef_to_return_a_value);
    return Action&lt;F&gt;(new Impl&lt;F&gt;(ref_));
  }
 private:
  template &lt;typename F&gt;
  class Impl : public ActionInterface&lt;F&gt; {
   public:
    typedef typename Function&lt;F&gt;::Result Result;
    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
    explicit Impl(T&amp; ref) : ref_(ref) {}  
    Result Perform(const ArgumentTuple&amp;) override { return ref_; }
   private:
<a name="4"></a>    T&amp; ref_;
    GTEST_DISALLOW_ASSIGN_(Impl);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  };
  T&amp; ref_;
  GTEST_DISALLOW_ASSIGN_(ReturnRefAction);
};
template &lt;typename T&gt;
class ReturnRefOfCopyAction {
 public:
  explicit ReturnRefOfCopyAction(const T&amp; value) : value_(value) {}  
  template &lt;typename F&gt;
  operator Action&lt;F&gt;() const {</b></font>
    typedef typename Function&lt;F&gt;::Result Result;
    GTEST_COMPILE_ASSERT_(
        std::is_reference&lt;Result&gt;::value,
        use_Return_instead_of_ReturnRefOfCopy_to_return_a_value);
    return Action&lt;F&gt;(new Impl&lt;F&gt;(value_));
  }
 private:
  template &lt;typename F&gt;
  class Impl : public ActionInterface&lt;F&gt; {
   public:
    typedef typename Function&lt;F&gt;::Result Result;
    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
    explicit Impl(const T&amp; value) : value_(value) {}  
    Result Perform(const ArgumentTuple&amp;) override { return value_; }
   private:
    T value_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
  const T value_;
  GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction);
};
class DoDefaultAction {
 public:
  template &lt;typename F&gt;
  operator Action&lt;F&gt;() const { return Action&lt;F&gt;(); }  };
template &lt;typename T1, typename T2&gt;
class AssignAction {
 public:
  AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}
  template &lt;typename Result, typename ArgumentTuple&gt;
  void Perform(const ArgumentTuple&amp;     *ptr_ = value_;
  }
 private:
  T1* const ptr_;
  const T2 value_;
  GTEST_DISALLOW_ASSIGN_(AssignAction);
};
#if !GTEST_OS_WINDOWS_MOBILE
template &lt;typename T&gt;
class SetErrnoAndReturnAction {
 public:
  SetErrnoAndReturnAction(int errno_value, T result)
      : errno_(errno_value),
        result_(result) {}
  template &lt;typename Result, typename ArgumentTuple&gt;
  Result Perform(const ArgumentTuple&amp;     errno = errno_;
    return result_;
  }
 private:
  const int errno_;
  const T result_;
  GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction);
};
#endif  
template &lt;size_t N, typename A, typename = void&gt;
struct SetArgumentPointeeAction {
  A value;
  template &lt;typename... Args&gt;
  void operator()(const Args&amp;... args) const {
    *::std::get&lt;N&gt;(std::tie(args...)) = value;
  }
};
template &lt;class Class, typename MethodPtr&gt;
struct InvokeMethodAction {
  Class* const obj_ptr;
  const MethodPtr method_ptr;
  template &lt;typename... Args&gt;
  auto operator()(Args&amp;&amp;... args) const
      -&gt; decltype((obj_ptr-&gt;*method_ptr)(std::forward&lt;Args&gt;(args)...)) {
    return (obj_ptr-&gt;*method_ptr)(std::forward&lt;Args&gt;(args)...);
  }
};
template &lt;typename FunctionImpl&gt;
struct InvokeWithoutArgsAction {
  FunctionImpl function_impl;
  template &lt;typename... Args&gt;
  auto operator()(const Args&amp;...) -&gt; decltype(function_impl()) {
    return function_impl();
  }
};
template &lt;class Class, typename MethodPtr&gt;
struct InvokeMethodWithoutArgsAction {
  Class* const obj_ptr;
  const MethodPtr method_ptr;
<a name="1"></a>  using ReturnType = typename std::result_of&lt;MethodPtr(Class*)&gt;::type;
  template &lt;typename... Args&gt;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  ReturnType operator()(const Args&amp;...) const {
    return (obj_ptr-&gt;*method_ptr)();
  }
};
template &lt;typename A&gt;
class IgnoreResultAction {
 public:
  explicit IgnoreResultAction(const A&amp; action) : action_(action) {}
  template &lt;typename F&gt;
  operator Action&lt;F&gt;() const {
    typedef typename internal::Function&lt;F&gt;::Result Result;</b></font>
    static_assert(std::is_void&lt;Result&gt;::value, "Result type should be void.");
    return Action&lt;F&gt;(new Impl&lt;F&gt;(action_));
  }
 private:
  template &lt;typename F&gt;
  class Impl : public ActionInterface&lt;F&gt; {
   public:
    typedef typename internal::Function&lt;F&gt;::Result Result;
    typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
    explicit Impl(const A&amp; action) : action_(action) {}
    void Perform(const ArgumentTuple&amp; args) override {
      action_.Perform(args);
    }
   private:
    typedef typename internal::Function&lt;F&gt;::MakeResultIgnoredValue
        OriginalFunction;
    const Action&lt;OriginalFunction&gt; action_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
  const A action_;
  GTEST_DISALLOW_ASSIGN_(IgnoreResultAction);
};
template &lt;typename InnerAction, size_t... I&gt;
struct WithArgsAction {
  InnerAction action;
  template &lt;typename R, typename... Args&gt;
  operator Action&lt;R(Args...)&gt;() const {      Action&lt;R(typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type...)&gt;
        converted(action);
    return [converted](Args... args) -&gt; R {
      return converted.Perform(std::forward_as_tuple(
        std::get&lt;I&gt;(std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))...));
    };
  }
};
template &lt;typename... Actions&gt;
struct DoAllAction {
 private:
  template &lt;typename... Args, size_t... I&gt;
  std::vector&lt;Action&lt;void(Args...)&gt;&gt; Convert(IndexSequence&lt;I...&gt;) const {
    return {std::get&lt;I&gt;(actions)...};
  }
 public:
  std::tuple&lt;Actions...&gt; actions;
  template &lt;typename R, typename... Args&gt;
  operator Action&lt;R(Args...)&gt;() const {      struct Op {
      std::vector&lt;Action&lt;void(Args...)&gt;&gt; converted;
      Action&lt;R(Args...)&gt; last;
      R operator()(Args... args) const {
        auto tuple_args = std::forward_as_tuple(std::forward&lt;Args&gt;(args)...);
        for (auto&amp; a : converted) {
          a.Perform(tuple_args);
        }
        return last.Perform(tuple_args);
      }
    };
    return Op{Convert&lt;Args...&gt;(MakeIndexSequence&lt;sizeof...(Actions) - 1&gt;()),
              std::get&lt;sizeof...(Actions) - 1&gt;(actions)};
  }
};
}  
typedef internal::IgnoredValue Unused;
template &lt;typename... Action&gt;
internal::DoAllAction&lt;typename std::decay&lt;Action&gt;::type...&gt; DoAll(
    Action&amp;&amp;... action) {
  return {std::forward_as_tuple(std::forward&lt;Action&gt;(action)...)};
}
template &lt;size_t k, typename InnerAction&gt;
internal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type, k&gt;
WithArg(InnerAction&amp;&amp; action) {
  return {std::forward&lt;InnerAction&gt;(action)};
}
template &lt;size_t k, size_t... ks, typename InnerAction&gt;
internal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type, k, ks...&gt;
WithArgs(InnerAction&amp;&amp; action) {
  return {std::forward&lt;InnerAction&gt;(action)};
}
template &lt;typename InnerAction&gt;
internal::WithArgsAction&lt;typename std::decay&lt;InnerAction&gt;::type&gt;
WithoutArgs(InnerAction&amp;&amp; action) {
  return {std::forward&lt;InnerAction&gt;(action)};
}
<a name="3"></a>template &lt;typename R&gt;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>internal::ReturnAction&lt;R&gt; Return(R value) {
  return internal::ReturnAction&lt;R&gt;(std::move(value));
}
inline PolymorphicAction&lt;internal::ReturnNullAction&gt; ReturnNull() {
  return MakePolymorphicAction(internal::ReturnNullAction());
<a name="0"></a>}
</b></font><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inline PolymorphicAction&lt;internal::ReturnVoidAction&gt; Return() {
  return MakePolymorphicAction(internal::ReturnVoidAction());
}
template &lt;typename R&gt;
inline internal::ReturnRefAction&lt;R&gt; ReturnRef(R&amp; x) {    return internal::ReturnRefAction&lt;R&gt;(x);
}
template &lt;typename R&gt;
inline internal::ReturnRefOfCopyAction&lt;R&gt; ReturnRefOfCopy(const R&amp; x) {
  return internal::ReturnRefOfCopyAction&lt;R&gt;(x);
}
template &lt;typename R&gt;</b></font>
internal::ByMoveWrapper&lt;R&gt; ByMove(R x) {
  return internal::ByMoveWrapper&lt;R&gt;(std::move(x));
}
inline internal::DoDefaultAction DoDefault() {
  return internal::DoDefaultAction();
}
template &lt;size_t N, typename T&gt;
internal::SetArgumentPointeeAction&lt;N, T&gt; SetArgPointee(T x) {
  return {std::move(x)};
}
template &lt;size_t N, typename T&gt;
internal::SetArgumentPointeeAction&lt;N, T&gt; SetArgumentPointee(T x) {
  return {std::move(x)};
}
template &lt;typename T1, typename T2&gt;
PolymorphicAction&lt;internal::AssignAction&lt;T1, T2&gt; &gt; Assign(T1* ptr, T2 val) {
  return MakePolymorphicAction(internal::AssignAction&lt;T1, T2&gt;(ptr, val));
}
#if !GTEST_OS_WINDOWS_MOBILE
template &lt;typename T&gt;
PolymorphicAction&lt;internal::SetErrnoAndReturnAction&lt;T&gt; &gt;
SetErrnoAndReturn(int errval, T result) {
  return MakePolymorphicAction(
      internal::SetErrnoAndReturnAction&lt;T&gt;(errval, result));
}
#endif  
template &lt;typename FunctionImpl&gt;
typename std::decay&lt;FunctionImpl&gt;::type Invoke(FunctionImpl&amp;&amp; function_impl) {
  return std::forward&lt;FunctionImpl&gt;(function_impl);
}
template &lt;class Class, typename MethodPtr&gt;
internal::InvokeMethodAction&lt;Class, MethodPtr&gt; Invoke(Class* obj_ptr,
                                                      MethodPtr method_ptr) {
  return {obj_ptr, method_ptr};
}
template &lt;typename FunctionImpl&gt;
internal::InvokeWithoutArgsAction&lt;typename std::decay&lt;FunctionImpl&gt;::type&gt;
InvokeWithoutArgs(FunctionImpl function_impl) {
  return {std::move(function_impl)};
}
template &lt;class Class, typename MethodPtr&gt;
<a name="5"></a>internal::InvokeMethodWithoutArgsAction&lt;Class, MethodPtr&gt; InvokeWithoutArgs(
    Class* obj_ptr, MethodPtr method_ptr) {
  return {obj_ptr, method_ptr};
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
template &lt;typename A&gt;
inline internal::IgnoreResultAction&lt;A&gt; IgnoreResult(const A&amp; an_action) {
  return internal::IgnoreResultAction&lt;A&gt;(an_action);
}
template &lt;typename T&gt;
inline ::std::reference_wrapper&lt;T&gt; ByRef(T&amp; l_value) {    return ::std::reference_wrapper&lt;T&gt;(l_value);
}
}  
#ifdef _MSC_VER
# pragma warning(pop)
#endif
#endif  </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>gmock-matchers.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
#define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;initializer_list&gt;
#include &lt;iterator&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;ostream&gt;  #include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include "gmock/internal/gmock-internal-utils.h"
#include "gmock/internal/gmock-port.h"
#include "gtest/gtest.h"
#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1915
#define GMOCK_MAYBE_5046_ 5046
#else
#define GMOCK_MAYBE_5046_
#endif
GTEST_DISABLE_MSC_WARNINGS_PUSH_(
namespace testing {
class StringMatchResultListener : public MatchResultListener {
 public:
  StringMatchResultListener() : MatchResultListener(&amp;ss_) {}
  std::string str() const { return ss_.str(); }
  void Clear() { ss_.str(""); }
 private:
  ::std::stringstream ss_;
  GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);
};
namespace internal {
template &lt;typename T, typename M&gt;
class MatcherCastImpl {
 public:
  static Matcher&lt;T&gt; Cast(const M&amp; polymorphic_matcher_or_value) {
    return CastImpl(polymorphic_matcher_or_value,
                    std::is_convertible&lt;M, Matcher&lt;T&gt;&gt;{},
                    std::is_convertible&lt;M, T&gt;{});
  }
 private:
  template &lt;bool Ignore&gt;
  static Matcher&lt;T&gt; CastImpl(const M&amp; polymorphic_matcher_or_value,
                             std::true_type                              bool_constant&lt;Ignore&gt;) {
    return polymorphic_matcher_or_value;
  }
  static Matcher&lt;T&gt; CastImpl(const M&amp; value,
                             std::false_type                              std::true_type     return Matcher&lt;T&gt;(ImplicitCast_&lt;T&gt;(value));
  }
  static Matcher&lt;T&gt; CastImpl(const M&amp; value,
                             std::false_type                              std::false_type };
template &lt;typename T, typename U&gt;
class MatcherCastImpl&lt;T, Matcher&lt;U&gt; &gt; {
 public:
  static Matcher&lt;T&gt; Cast(const Matcher&lt;U&gt;&amp; source_matcher) {
    return Matcher&lt;T&gt;(new Impl(source_matcher));
  }
 private:
  class Impl : public MatcherInterface&lt;T&gt; {
   public:
    explicit Impl(const Matcher&lt;U&gt;&amp; source_matcher)
        : source_matcher_(source_matcher) {}
    bool MatchAndExplain(T x, MatchResultListener* listener) const override {
      using FromType = typename std::remove_cv&lt;typename std::remove_pointer&lt;
          typename std::remove_reference&lt;T&gt;::type&gt;::type&gt;::type;
      using ToType = typename std::remove_cv&lt;typename std::remove_pointer&lt;
          typename std::remove_reference&lt;U&gt;::type&gt;::type&gt;::type;
      static_assert(
          (std::is_pointer&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value !=
           std::is_pointer&lt;typename std::remove_reference&lt;U&gt;::type&gt;::value) ||
              std::is_same&lt;FromType, ToType&gt;::value ||
              !std::is_base_of&lt;FromType, ToType&gt;::value,
          "Can't implicitly convert from &lt;base&gt; to &lt;derived&gt;");
      return source_matcher_.MatchAndExplain(static_cast&lt;U&gt;(x), listener);
    }
    void DescribeTo(::std::ostream* os) const override {
      source_matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      source_matcher_.DescribeNegationTo(os);
    }
   private:
    const Matcher&lt;U&gt; source_matcher_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
};
template &lt;typename T&gt;
class MatcherCastImpl&lt;T, Matcher&lt;T&gt; &gt; {
 public:
  static Matcher&lt;T&gt; Cast(const Matcher&lt;T&gt;&amp; matcher) { return matcher; }
};
}  
template &lt;typename T, typename M&gt;
inline Matcher&lt;T&gt; MatcherCast(const M&amp; matcher) {
  return internal::MatcherCastImpl&lt;T, M&gt;::Cast(matcher);
}
template &lt;typename T&gt;
class SafeMatcherCastImpl {
 public:
  template &lt;typename M&gt;
  static inline Matcher&lt;T&gt; Cast(const M&amp; polymorphic_matcher_or_value) {
    return internal::MatcherCastImpl&lt;T, M&gt;::Cast(polymorphic_matcher_or_value);
  }
  template &lt;typename U&gt;
  static inline Matcher&lt;T&gt; Cast(const Matcher&lt;U&gt;&amp; matcher) {
    GTEST_COMPILE_ASSERT_((std::is_convertible&lt;T, U&gt;::value),
                          "T must be implicitly convertible to U");
    GTEST_COMPILE_ASSERT_(
        std::is_reference&lt;T&gt;::value || !std::is_reference&lt;U&gt;::value,
        cannot_convert_non_reference_arg_to_reference);
    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;
    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;
    const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;
    const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;
    GTEST_COMPILE_ASSERT_(
        kTIsOther || kUIsOther ||
        (internal::LosslessArithmeticConvertible&lt;RawT, RawU&gt;::value),
        conversion_of_arithmetic_types_must_be_lossless);
    return MatcherCast&lt;T&gt;(matcher);
  }
};
template &lt;typename T, typename M&gt;
inline Matcher&lt;T&gt; SafeMatcherCast(const M&amp; polymorphic_matcher) {
  return SafeMatcherCastImpl&lt;T&gt;::Cast(polymorphic_matcher);
}
template &lt;typename T&gt;
Matcher&lt;T&gt; A();
namespace internal {
inline void PrintIfNotEmpty(const std::string&amp; explanation,
                            ::std::ostream* os) {
  if (explanation != "" &amp;&amp; os != nullptr) {
    *os &lt;&lt; ", " &lt;&lt; explanation;
  }
}
inline bool IsReadableTypeName(const std::string&amp; type_name) {
  return (type_name.length() &lt;= 20 ||
          type_name.find_first_of("&lt;(") == std::string::npos);
}
template &lt;typename Value, typename T&gt;
bool MatchPrintAndExplain(Value&amp; value, const Matcher&lt;T&gt;&amp; matcher,
                          MatchResultListener* listener) {
  if (!listener-&gt;IsInterested()) {
    return matcher.Matches(value);
  }
  StringMatchResultListener inner_listener;
  const bool match = matcher.MatchAndExplain(value, &amp;inner_listener);
  UniversalPrint(value, listener-&gt;stream());
#if GTEST_HAS_RTTI
  const std::string&amp; type_name = GetTypeName&lt;Value&gt;();
  if (IsReadableTypeName(type_name))
    *listener-&gt;stream() &lt;&lt; " (of type " &lt;&lt; type_name &lt;&lt; ")";
#endif
  PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
  return match;
}
template &lt;size_t N&gt;
class TuplePrefix {
 public:
  template &lt;typename MatcherTuple, typename ValueTuple&gt;
  static bool Matches(const MatcherTuple&amp; matcher_tuple,
                      const ValueTuple&amp; value_tuple) {
    return TuplePrefix&lt;N - 1&gt;::Matches(matcher_tuple, value_tuple) &amp;&amp;
           std::get&lt;N - 1&gt;(matcher_tuple).Matches(std::get&lt;N - 1&gt;(value_tuple));
  }
  template &lt;typename MatcherTuple, typename ValueTuple&gt;
  static void ExplainMatchFailuresTo(const MatcherTuple&amp; matchers,
                                     const ValueTuple&amp; values,
                                     ::std::ostream* os) {
    TuplePrefix&lt;N - 1&gt;::ExplainMatchFailuresTo(matchers, values, os);
    typename std::tuple_element&lt;N - 1, MatcherTuple&gt;::type matcher =
        std::get&lt;N - 1&gt;(matchers);
    typedef typename std::tuple_element&lt;N - 1, ValueTuple&gt;::type Value;
    const Value&amp; value = std::get&lt;N - 1&gt;(values);
    StringMatchResultListener listener;
    if (!matcher.MatchAndExplain(value, &amp;listener)) {
      *os &lt;&lt; "  Expected arg #" &lt;&lt; N - 1 &lt;&lt; ": ";
      std::get&lt;N - 1&gt;(matchers).DescribeTo(os);
      *os &lt;&lt; "\n           Actual: ";
      internal::UniversalPrint(value, os);
      PrintIfNotEmpty(listener.str(), os);
      *os &lt;&lt; "\n";
    }
  }
};
template &lt;&gt;
class TuplePrefix&lt;0&gt; {
 public:
  template &lt;typename MatcherTuple, typename ValueTuple&gt;
  static bool Matches(const MatcherTuple&amp;                       const ValueTuple&amp;     return true;
  }
  template &lt;typename MatcherTuple, typename ValueTuple&gt;
  static void ExplainMatchFailuresTo(const MatcherTuple&amp;                                      const ValueTuple&amp;                                      ::std::ostream* };
template &lt;typename MatcherTuple, typename ValueTuple&gt;
bool TupleMatches(const MatcherTuple&amp; matcher_tuple,
                  const ValueTuple&amp; value_tuple) {
  GTEST_COMPILE_ASSERT_(std::tuple_size&lt;MatcherTuple&gt;::value ==
                            std::tuple_size&lt;ValueTuple&gt;::value,
                        matcher_and_value_have_different_numbers_of_fields);
  return TuplePrefix&lt;std::tuple_size&lt;ValueTuple&gt;::value&gt;::Matches(matcher_tuple,
                                                                  value_tuple);
}
template &lt;typename MatcherTuple, typename ValueTuple&gt;
void ExplainMatchFailureTupleTo(const MatcherTuple&amp; matchers,
                                const ValueTuple&amp; values,
                                ::std::ostream* os) {
  TuplePrefix&lt;std::tuple_size&lt;MatcherTuple&gt;::value&gt;::ExplainMatchFailuresTo(
      matchers, values, os);
}
template &lt;typename Tuple, typename Func, typename OutIter&gt;
class TransformTupleValuesHelper {
 private:
  typedef ::std::tuple_size&lt;Tuple&gt; TupleSize;
 public:
  static OutIter Run(Func f, const Tuple&amp; t, OutIter out) {
    return IterateOverTuple&lt;Tuple, TupleSize::value&gt;()(f, t, out);
  }
 private:
  template &lt;typename Tup, size_t kRemainingSize&gt;
  struct IterateOverTuple {
    OutIter operator() (Func f, const Tup&amp; t, OutIter out) const {
      *out++ = f(::std::get&lt;TupleSize::value - kRemainingSize&gt;(t));
      return IterateOverTuple&lt;Tup, kRemainingSize - 1&gt;()(f, t, out);
    }
  };
  template &lt;typename Tup&gt;
  struct IterateOverTuple&lt;Tup, 0&gt; {
    OutIter operator() (Func       return out;
    }
  };
};
template &lt;typename Tuple, typename Func, typename OutIter&gt;
OutIter TransformTupleValues(Func f, const Tuple&amp; t, OutIter out) {
  return TransformTupleValuesHelper&lt;Tuple, Func, OutIter&gt;::Run(f, t, out);
}
template &lt;typename T&gt;
class AnyMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
 public:
  bool MatchAndExplain(const T&amp;                        MatchResultListener*     return true;
  }
  void DescribeTo(::std::ostream* os) const override { *os &lt;&lt; "is anything"; }
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "never matches";
  }
};
class AnythingMatcher {
 public:
  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const { return A&lt;T&gt;(); }
};
class IsNullMatcher {
 public:
  template &lt;typename Pointer&gt;
  bool MatchAndExplain(const Pointer&amp; p,
                       MatchResultListener*     return p == nullptr;
  }
  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; "is NULL"; }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "isn't NULL";
  }
};
class NotNullMatcher {
 public:
  template &lt;typename Pointer&gt;
  bool MatchAndExplain(const Pointer&amp; p,
                       MatchResultListener*     return p != nullptr;
  }
  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; "isn't NULL"; }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "is NULL";
  }
};
template &lt;typename T&gt;
class RefMatcher;
template &lt;typename T&gt;
class RefMatcher&lt;T&amp;&gt; {
 public:
<a name="2"></a>  <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  explicit RefMatcher(T&amp; x) : object_(x) {}  
  template &lt;typename Super&gt;
  operator Matcher&lt;Super&amp;&gt;() const {
    return MakeMatcher(new Impl&lt;Super&gt;(object_));
  }
 private:
  template &lt;typename Super&gt;
  class Impl : public MatcherInterface&lt;Super&amp;&gt; {
   public:</b></font>
    explicit Impl(Super&amp; x) : object_(x) {}  
    bool MatchAndExplain(Super&amp; x,
                         MatchResultListener* listener) const override {
      *listener &lt;&lt; "which is located @" &lt;&lt; static_cast&lt;const void*&gt;(&amp;x);
      return &amp;x == &amp;object_;
    }
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "references the variable ";
      UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "does not reference the variable ";
      UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);
    }
   private:
    const Super&amp; object_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
  T&amp; object_;
  GTEST_DISALLOW_ASSIGN_(RefMatcher);
};
inline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {
  return String::CaseInsensitiveCStringEquals(lhs, rhs);
}
inline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,
                                         const wchar_t* rhs) {
  return String::CaseInsensitiveWideCStringEquals(lhs, rhs);
}
template &lt;typename StringType&gt;
bool CaseInsensitiveStringEquals(const StringType&amp; s1,
                                 const StringType&amp; s2) {
  if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {
    return false;
  }
  const typename StringType::value_type nul = 0;
  const size_t i1 = s1.find(nul), i2 = s2.find(nul);
  if (i1 == StringType::npos || i2 == StringType::npos) {
    return i1 == i2;
  }
  return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));
}
template &lt;typename StringType&gt;
class StrEqualityMatcher {
 public:
  StrEqualityMatcher(const StringType&amp; str, bool expect_eq,
                     bool case_sensitive)
      : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}
#if GTEST_HAS_ABSL
  bool MatchAndExplain(const absl::string_view&amp; s,
                       MatchResultListener* listener) const {
    const StringType&amp; str = std::string(s);
    return MatchAndExplain(str, listener);
  }
#endif  
  template &lt;typename CharType&gt;
  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
    if (s == nullptr) {
      return !expect_eq_;
    }
    return MatchAndExplain(StringType(s), listener);
  }
  template &lt;typename MatcheeStringType&gt;
  bool MatchAndExplain(const MatcheeStringType&amp; s,
                       MatchResultListener*     const StringType&amp; s2(s);
    const bool eq = case_sensitive_ ? s2 == string_ :
        CaseInsensitiveStringEquals(s2, string_);
    return expect_eq_ == eq;
  }
  void DescribeTo(::std::ostream* os) const {
    DescribeToHelper(expect_eq_, os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    DescribeToHelper(!expect_eq_, os);
  }
 private:
  void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {
    *os &lt;&lt; (expect_eq ? "is " : "isn't ");
    *os &lt;&lt; "equal to ";
    if (!case_sensitive_) {
      *os &lt;&lt; "(ignoring case) ";
    }
    UniversalPrint(string_, os);
  }
  const StringType string_;
  const bool expect_eq_;
  const bool case_sensitive_;
  GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);
};
template &lt;typename StringType&gt;
class HasSubstrMatcher {
 public:
  explicit HasSubstrMatcher(const StringType&amp; substring)
      : substring_(substring) {}
#if GTEST_HAS_ABSL
  bool MatchAndExplain(const absl::string_view&amp; s,
                       MatchResultListener* listener) const {
    const StringType&amp; str = std::string(s);
    return MatchAndExplain(str, listener);
  }
#endif  
  template &lt;typename CharType&gt;
  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
  }
  template &lt;typename MatcheeStringType&gt;
  bool MatchAndExplain(const MatcheeStringType&amp; s,
                       MatchResultListener*     const StringType&amp; s2(s);
    return s2.find(substring_) != StringType::npos;
  }
  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "has substring ";
    UniversalPrint(substring_, os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "has no substring ";
    UniversalPrint(substring_, os);
  }
 private:
  const StringType substring_;
  GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);
};
template &lt;typename StringType&gt;
class StartsWithMatcher {
 public:
  explicit StartsWithMatcher(const StringType&amp; prefix) : prefix_(prefix) {
  }
#if GTEST_HAS_ABSL
  bool MatchAndExplain(const absl::string_view&amp; s,
                       MatchResultListener* listener) const {
    const StringType&amp; str = std::string(s);
    return MatchAndExplain(str, listener);
  }
#endif  
  template &lt;typename CharType&gt;
  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
  }
  template &lt;typename MatcheeStringType&gt;
  bool MatchAndExplain(const MatcheeStringType&amp; s,
                       MatchResultListener*     const StringType&amp; s2(s);
    return s2.length() &gt;= prefix_.length() &amp;&amp;
        s2.substr(0, prefix_.length()) == prefix_;
  }
  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "starts with ";
    UniversalPrint(prefix_, os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "doesn't start with ";
    UniversalPrint(prefix_, os);
  }
 private:
  const StringType prefix_;
  GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);
};
template &lt;typename StringType&gt;
class EndsWithMatcher {
 public:
  explicit EndsWithMatcher(const StringType&amp; suffix) : suffix_(suffix) {}
#if GTEST_HAS_ABSL
  bool MatchAndExplain(const absl::string_view&amp; s,
                       MatchResultListener* listener) const {
    const StringType&amp; str = std::string(s);
    return MatchAndExplain(str, listener);
  }
#endif  
  template &lt;typename CharType&gt;
  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
  }
  template &lt;typename MatcheeStringType&gt;
  bool MatchAndExplain(const MatcheeStringType&amp; s,
                       MatchResultListener*     const StringType&amp; s2(s);
    return s2.length() &gt;= suffix_.length() &amp;&amp;
        s2.substr(s2.length() - suffix_.length()) == suffix_;
  }
  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "ends with ";
    UniversalPrint(suffix_, os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "doesn't end with ";
    UniversalPrint(suffix_, os);
  }
 private:
  const StringType suffix_;
  GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);
};
template &lt;typename D, typename Op&gt;
class PairMatchBase {
 public:
  template &lt;typename T1, typename T2&gt;
  operator Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;() const {
    return Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;(new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;);
  }
  template &lt;typename T1, typename T2&gt;
  operator Matcher&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;() const {
    return MakeMatcher(new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;);
  }
 private:
  static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {      return os &lt;&lt; D::Desc();
  }
  template &lt;typename Tuple&gt;
  class Impl : public MatcherInterface&lt;Tuple&gt; {
   public:
    bool MatchAndExplain(Tuple args,
                         MatchResultListener*       return Op()(::std::get&lt;0&gt;(args), ::std::get&lt;1&gt;(args));
    }
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "are " &lt;&lt; GetDesc;
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "aren't " &lt;&lt; GetDesc;
    }
  };
};
class Eq2Matcher : public PairMatchBase&lt;Eq2Matcher, AnyEq&gt; {
 public:
  static const char* Desc() { return "an equal pair"; }
};
class Ne2Matcher : public PairMatchBase&lt;Ne2Matcher, AnyNe&gt; {
 public:
  static const char* Desc() { return "an unequal pair"; }
};
class Lt2Matcher : public PairMatchBase&lt;Lt2Matcher, AnyLt&gt; {
 public:
  static const char* Desc() { return "a pair where the first &lt; the second"; }
};
class Gt2Matcher : public PairMatchBase&lt;Gt2Matcher, AnyGt&gt; {
 public:
  static const char* Desc() { return "a pair where the first &gt; the second"; }
};
class Le2Matcher : public PairMatchBase&lt;Le2Matcher, AnyLe&gt; {
 public:
  static const char* Desc() { return "a pair where the first &lt;= the second"; }
};
class Ge2Matcher : public PairMatchBase&lt;Ge2Matcher, AnyGe&gt; {
 public:
  static const char* Desc() { return "a pair where the first &gt;= the second"; }
};
template &lt;typename T&gt;
class NotMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
 public:
  explicit NotMatcherImpl(const Matcher&lt;T&gt;&amp; matcher)
      : matcher_(matcher) {}
  bool MatchAndExplain(const T&amp; x,
                       MatchResultListener* listener) const override {
    return !matcher_.MatchAndExplain(x, listener);
  }
  void DescribeTo(::std::ostream* os) const override {
    matcher_.DescribeNegationTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    matcher_.DescribeTo(os);
  }
 private:
  const Matcher&lt;T&gt; matcher_;
  GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);
};
template &lt;typename InnerMatcher&gt;
class NotMatcher {
 public:
  explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}
  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const {
    return Matcher&lt;T&gt;(new NotMatcherImpl&lt;T&gt;(SafeMatcherCast&lt;T&gt;(matcher_)));
  }
 private:
  InnerMatcher matcher_;
  GTEST_DISALLOW_ASSIGN_(NotMatcher);
};
template &lt;typename T&gt;
class AllOfMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
 public:
  explicit AllOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt; &gt; matchers)
      : matchers_(std::move(matchers)) {}
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "(";
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      if (i != 0) *os &lt;&lt; ") and (";
      matchers_[i].DescribeTo(os);
    }
    *os &lt;&lt; ")";
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "(";
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      if (i != 0) *os &lt;&lt; ") or (";
      matchers_[i].DescribeNegationTo(os);
    }
    *os &lt;&lt; ")";
  }
  bool MatchAndExplain(const T&amp; x,
                       MatchResultListener* listener) const override {
    std::string all_match_result;
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      StringMatchResultListener slistener;
      if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {
        if (all_match_result.empty()) {
          all_match_result = slistener.str();
        } else {
          std::string result = slistener.str();
          if (!result.empty()) {
            all_match_result += ", and ";
            all_match_result += result;
          }
        }
      } else {
        *listener &lt;&lt; slistener.str();
        return false;
      }
    }
    *listener &lt;&lt; all_match_result;
    return true;
  }
 private:
  const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_;
  GTEST_DISALLOW_ASSIGN_(AllOfMatcherImpl);
};
template &lt;template &lt;typename T&gt; class CombiningMatcher, typename... Args&gt;
class VariadicMatcher {
 public:
  VariadicMatcher(const Args&amp;... matchers)        : matchers_(matchers...) {
    static_assert(sizeof...(Args) &gt; 0, "Must have at least one matcher.");
  }
  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const {
    std::vector&lt;Matcher&lt;T&gt; &gt; values;
    CreateVariadicMatcher&lt;T&gt;(&amp;values, std::integral_constant&lt;size_t, 0&gt;());
    return Matcher&lt;T&gt;(new CombiningMatcher&lt;T&gt;(std::move(values)));
  }
 private:
  template &lt;typename T, size_t I&gt;
  void CreateVariadicMatcher(std::vector&lt;Matcher&lt;T&gt; &gt;* values,
                             std::integral_constant&lt;size_t, I&gt;) const {
    values-&gt;push_back(SafeMatcherCast&lt;T&gt;(std::get&lt;I&gt;(matchers_)));
    CreateVariadicMatcher&lt;T&gt;(values, std::integral_constant&lt;size_t, I + 1&gt;());
  }
  template &lt;typename T&gt;
  void CreateVariadicMatcher(
      std::vector&lt;Matcher&lt;T&gt; &gt;*,
      std::integral_constant&lt;size_t, sizeof...(Args)&gt;) const {}
  std::tuple&lt;Args...&gt; matchers_;
  GTEST_DISALLOW_ASSIGN_(VariadicMatcher);
};
template &lt;typename... Args&gt;
using AllOfMatcher = VariadicMatcher&lt;AllOfMatcherImpl, Args...&gt;;
template &lt;typename T&gt;
class AnyOfMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
 public:
  explicit AnyOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt; &gt; matchers)
      : matchers_(std::move(matchers)) {}
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "(";
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      if (i != 0) *os &lt;&lt; ") or (";
      matchers_[i].DescribeTo(os);
    }
    *os &lt;&lt; ")";
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "(";
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      if (i != 0) *os &lt;&lt; ") and (";
      matchers_[i].DescribeNegationTo(os);
    }
    *os &lt;&lt; ")";
  }
  bool MatchAndExplain(const T&amp; x,
                       MatchResultListener* listener) const override {
    std::string no_match_result;
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      StringMatchResultListener slistener;
      if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {
        *listener &lt;&lt; slistener.str();
        return true;
      } else {
        if (no_match_result.empty()) {
          no_match_result = slistener.str();
        } else {
          std::string result = slistener.str();
          if (!result.empty()) {
            no_match_result += ", and ";
            no_match_result += result;
          }
        }
      }
    }
    *listener &lt;&lt; no_match_result;
    return false;
  }
 private:
  const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_;
  GTEST_DISALLOW_ASSIGN_(AnyOfMatcherImpl);
};
template &lt;typename... Args&gt;
using AnyOfMatcher = VariadicMatcher&lt;AnyOfMatcherImpl, Args...&gt;;
template &lt;template &lt;class&gt; class MatcherImpl, typename T&gt;
class SomeOfArrayMatcher {
 public:
  template &lt;typename Iter&gt;
  SomeOfArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}
  template &lt;typename U&gt;
  operator Matcher&lt;U&gt;() const {      using RawU = typename std::decay&lt;U&gt;::type;
    std::vector&lt;Matcher&lt;RawU&gt;&gt; matchers;
    for (const auto&amp; matcher : matchers_) {
      matchers.push_back(MatcherCast&lt;RawU&gt;(matcher));
    }
    return Matcher&lt;U&gt;(new MatcherImpl&lt;RawU&gt;(std::move(matchers)));
  }
 private:
  const ::std::vector&lt;T&gt; matchers_;
  GTEST_DISALLOW_ASSIGN_(SomeOfArrayMatcher);
};
template &lt;typename T&gt;
using AllOfArrayMatcher = SomeOfArrayMatcher&lt;AllOfMatcherImpl, T&gt;;
template &lt;typename T&gt;
using AnyOfArrayMatcher = SomeOfArrayMatcher&lt;AnyOfMatcherImpl, T&gt;;
template &lt;typename Predicate&gt;
class TrulyMatcher {
 public:
  explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}
  template &lt;typename T&gt;
  bool MatchAndExplain(T&amp; x,                         MatchResultListener*     if (predicate_(x))
      return true;
    return false;
  }
  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "satisfies the given predicate";
  }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "doesn't satisfy the given predicate";
  }
 private:
  Predicate predicate_;
  GTEST_DISALLOW_ASSIGN_(TrulyMatcher);
};
template &lt;typename M&gt;
class MatcherAsPredicate {
 public:
  explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}
  template &lt;typename T&gt;
  bool operator()(const T&amp; x) const {
    return MatcherCast&lt;const T&amp;&gt;(matcher_).Matches(x);
  }
 private:
  M matcher_;
  GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);
};
template &lt;typename M&gt;
class PredicateFormatterFromMatcher {
 public:
  explicit PredicateFormatterFromMatcher(M m) : matcher_(std::move(m)) {}
  template &lt;typename T&gt;
  AssertionResult operator()(const char* value_text, const T&amp; x) const {
    const Matcher&lt;const T&amp;&gt; matcher = SafeMatcherCast&lt;const T&amp;&gt;(matcher_);
    if (matcher.Matches(x)) {
      return AssertionSuccess();
    }
    ::std::stringstream ss;
    ss &lt;&lt; "Value of: " &lt;&lt; value_text &lt;&lt; "\n"
       &lt;&lt; "Expected: ";
    matcher.DescribeTo(&amp;ss);
    StringMatchResultListener listener;
    if (MatchPrintAndExplain(x, matcher, &amp;listener)) {
      ss &lt;&lt; "\n  The matcher failed on the initial attempt; but passed when "
            "rerun to generate the explanation.";
    }
    ss &lt;&lt; "\n  Actual: " &lt;&lt; listener.str();
    return AssertionFailure() &lt;&lt; ss.str();
  }
 private:
  const M matcher_;
  GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);
};
template &lt;typename M&gt;
inline PredicateFormatterFromMatcher&lt;M&gt;
MakePredicateFormatterFromMatcher(M matcher) {
  return PredicateFormatterFromMatcher&lt;M&gt;(std::move(matcher));
}
template &lt;typename FloatType&gt;
class FloatingEqMatcher {
 public:
  FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :
    expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {
  }
  FloatingEqMatcher(FloatType expected, bool nan_eq_nan,
                    FloatType max_abs_error)
      : expected_(expected),
        nan_eq_nan_(nan_eq_nan),
        max_abs_error_(max_abs_error) {
    GTEST_CHECK_(max_abs_error &gt;= 0)
        &lt;&lt; ", where max_abs_error is" &lt;&lt; max_abs_error;
  }
  template &lt;typename T&gt;
  class Impl : public MatcherInterface&lt;T&gt; {
   public:
    Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)
        : expected_(expected),
          nan_eq_nan_(nan_eq_nan),
          max_abs_error_(max_abs_error) {}
    bool MatchAndExplain(T value,
                         MatchResultListener* listener) const override {
      const FloatingPoint&lt;FloatType&gt; actual(value), expected(expected_);
      if (actual.is_nan() || expected.is_nan()) {
        if (actual.is_nan() &amp;&amp; expected.is_nan()) {
          return nan_eq_nan_;
        }
        return false;
      }
      if (HasMaxAbsError()) {
        if (value == expected_) {
          return true;
        }
        const FloatType diff = value - expected_;
        if (fabs(diff) &lt;= max_abs_error_) {
          return true;
        }
        if (listener-&gt;IsInterested()) {
          *listener &lt;&lt; "which is " &lt;&lt; diff &lt;&lt; " from " &lt;&lt; expected_;
        }
        return false;
      } else {
        return actual.AlmostEquals(expected);
      }
    }
    void DescribeTo(::std::ostream* os) const override {
      const ::std::streamsize old_precision = os-&gt;precision(
          ::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);
      if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {
        if (nan_eq_nan_) {
          *os &lt;&lt; "is NaN";
        } else {
          *os &lt;&lt; "never matches";
        }
      } else {
        *os &lt;&lt; "is approximately " &lt;&lt; expected_;
        if (HasMaxAbsError()) {
          *os &lt;&lt; " (absolute error &lt;= " &lt;&lt; max_abs_error_ &lt;&lt; ")";
        }
      }
      os-&gt;precision(old_precision);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      const ::std::streamsize old_precision = os-&gt;precision(
          ::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);
      if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {
        if (nan_eq_nan_) {
          *os &lt;&lt; "isn't NaN";
        } else {
          *os &lt;&lt; "is anything";
        }
      } else {
        *os &lt;&lt; "isn't approximately " &lt;&lt; expected_;
        if (HasMaxAbsError()) {
          *os &lt;&lt; " (absolute error &gt; " &lt;&lt; max_abs_error_ &lt;&lt; ")";
        }
      }
      os-&gt;precision(old_precision);
    }
   private:
    bool HasMaxAbsError() const {
      return max_abs_error_ &gt;= 0;
    }
    const FloatType expected_;
    const bool nan_eq_nan_;
    const FloatType max_abs_error_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
  operator Matcher&lt;FloatType&gt;() const {
    return MakeMatcher(
        new Impl&lt;FloatType&gt;(expected_, nan_eq_nan_, max_abs_error_));
  }
  operator Matcher&lt;const FloatType&amp;&gt;() const {
    return MakeMatcher(
        new Impl&lt;const FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));
  }
  operator Matcher&lt;FloatType&amp;&gt;() const {
    return MakeMatcher(
        new Impl&lt;FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));
  }
 private:
  const FloatType expected_;
  const bool nan_eq_nan_;
  const FloatType max_abs_error_;
  GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);
};
template &lt;typename FloatType&gt;
class FloatingEq2Matcher {
 public:
  FloatingEq2Matcher() { Init(-1, false); }
  explicit FloatingEq2Matcher(bool nan_eq_nan) { Init(-1, nan_eq_nan); }
  explicit FloatingEq2Matcher(FloatType max_abs_error) {
    Init(max_abs_error, false);
  }
  FloatingEq2Matcher(FloatType max_abs_error, bool nan_eq_nan) {
    Init(max_abs_error, nan_eq_nan);
  }
  template &lt;typename T1, typename T2&gt;
  operator Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;() const {
    return MakeMatcher(
        new Impl&lt;::std::tuple&lt;T1, T2&gt;&gt;(max_abs_error_, nan_eq_nan_));
  }
  template &lt;typename T1, typename T2&gt;
  operator Matcher&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;() const {
    return MakeMatcher(
        new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;(max_abs_error_, nan_eq_nan_));
  }
 private:
  static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {      return os &lt;&lt; "an almost-equal pair";
  }
  template &lt;typename Tuple&gt;
  class Impl : public MatcherInterface&lt;Tuple&gt; {
   public:
    Impl(FloatType max_abs_error, bool nan_eq_nan) :
        max_abs_error_(max_abs_error),
        nan_eq_nan_(nan_eq_nan) {}
    bool MatchAndExplain(Tuple args,
                         MatchResultListener* listener) const override {
      if (max_abs_error_ == -1) {
        FloatingEqMatcher&lt;FloatType&gt; fm(::std::get&lt;0&gt;(args), nan_eq_nan_);
        return static_cast&lt;Matcher&lt;FloatType&gt;&gt;(fm).MatchAndExplain(
            ::std::get&lt;1&gt;(args), listener);
      } else {
        FloatingEqMatcher&lt;FloatType&gt; fm(::std::get&lt;0&gt;(args), nan_eq_nan_,
                                        max_abs_error_);
        return static_cast&lt;Matcher&lt;FloatType&gt;&gt;(fm).MatchAndExplain(
            ::std::get&lt;1&gt;(args), listener);
      }
    }
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "are " &lt;&lt; GetDesc;
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "aren't " &lt;&lt; GetDesc;
    }
   private:
    FloatType max_abs_error_;
    const bool nan_eq_nan_;
  };
<a name="4"></a>  void Init(FloatType max_abs_error_val, bool nan_eq_nan_val) {
    max_abs_error_ = max_abs_error_val;
    nan_eq_nan_ = nan_eq_nan_val;
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
  FloatType max_abs_error_;
  bool nan_eq_nan_;
};
template &lt;typename InnerMatcher&gt;
class PointeeMatcher {
 public:
  explicit PointeeMatcher(const InnerMatcher&amp; matcher) : matcher_(matcher) {}
  template &lt;typename Pointer&gt;
  operator Matcher&lt;Pointer&gt;() const {</b></font>
    return Matcher&lt;Pointer&gt;(new Impl&lt;const Pointer&amp;&gt;(matcher_));
  }
 private:
  template &lt;typename Pointer&gt;
  class Impl : public MatcherInterface&lt;Pointer&gt; {
   public:
    typedef typename PointeeOf&lt;typename std::remove_const&lt;
        typename std::remove_reference&lt;Pointer&gt;::type&gt;::type&gt;::type Pointee;
    explicit Impl(const InnerMatcher&amp; matcher)
        : matcher_(MatcherCast&lt;const Pointee&amp;&gt;(matcher)) {}
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "points to a value that ";
      matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "does not point to a value that ";
      matcher_.DescribeTo(os);
    }
    bool MatchAndExplain(Pointer pointer,
                         MatchResultListener* listener) const override {
      if (GetRawPointer(pointer) == nullptr) return false;
      *listener &lt;&lt; "which points to ";
      return MatchPrintAndExplain(*pointer, matcher_, listener);
    }
   private:
    const Matcher&lt;const Pointee&amp;&gt; matcher_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
  const InnerMatcher matcher_;
  GTEST_DISALLOW_ASSIGN_(PointeeMatcher);
};
#if GTEST_HAS_RTTI
template &lt;typename To&gt;
class WhenDynamicCastToMatcherBase {
 public:
  explicit WhenDynamicCastToMatcherBase(const Matcher&lt;To&gt;&amp; matcher)
      : matcher_(matcher) {}
  void DescribeTo(::std::ostream* os) const {
    GetCastTypeDescription(os);
    matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    GetCastTypeDescription(os);
    matcher_.DescribeNegationTo(os);
  }
 protected:
  const Matcher&lt;To&gt; matcher_;
  static std::string GetToName() {
    return GetTypeName&lt;To&gt;();
  }
 private:
  static void GetCastTypeDescription(::std::ostream* os) {
    *os &lt;&lt; "when dynamic_cast to " &lt;&lt; GetToName() &lt;&lt; ", ";
  }
  GTEST_DISALLOW_ASSIGN_(WhenDynamicCastToMatcherBase);
};
template &lt;typename To&gt;
class WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase&lt;To&gt; {
 public:
  explicit WhenDynamicCastToMatcher(const Matcher&lt;To&gt;&amp; matcher)
      : WhenDynamicCastToMatcherBase&lt;To&gt;(matcher) {}
  template &lt;typename From&gt;
  bool MatchAndExplain(From from, MatchResultListener* listener) const {
    To to = dynamic_cast&lt;To&gt;(from);
    return MatchPrintAndExplain(to, this-&gt;matcher_, listener);
  }
};
template &lt;typename To&gt;
class WhenDynamicCastToMatcher&lt;To&amp;&gt; : public WhenDynamicCastToMatcherBase&lt;To&amp;&gt; {
 public:
  explicit WhenDynamicCastToMatcher(const Matcher&lt;To&amp;&gt;&amp; matcher)
      : WhenDynamicCastToMatcherBase&lt;To&amp;&gt;(matcher) {}
  template &lt;typename From&gt;
  bool MatchAndExplain(From&amp; from, MatchResultListener* listener) const {
    To* to = dynamic_cast&lt;To*&gt;(&amp;from);
    if (to == nullptr) {
      *listener &lt;&lt; "which cannot be dynamic_cast to " &lt;&lt; this-&gt;GetToName();
      return false;
    }
    return MatchPrintAndExplain(*to, this-&gt;matcher_, listener);
  }
};
#endif  
template &lt;typename Class, typename FieldType&gt;
class FieldMatcher {
 public:
  FieldMatcher(FieldType Class::*field,
               const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)
      : field_(field), matcher_(matcher), whose_field_("whose given field ") {}
  FieldMatcher(const std::string&amp; field_name, FieldType Class::*field,
               const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)
      : field_(field),
        matcher_(matcher),
        whose_field_("whose field `" + field_name + "` ") {}
  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "is an object " &lt;&lt; whose_field_;
    matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "is an object " &lt;&lt; whose_field_;
    matcher_.DescribeNegationTo(os);
  }
  template &lt;typename T&gt;
  bool MatchAndExplain(const T&amp; value, MatchResultListener* listener) const {
    return MatchAndExplainImpl(
        typename std::is_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type(),
        value, listener);
  }
 private:
  bool MatchAndExplainImpl(std::false_type                            const Class&amp; obj,
                           MatchResultListener* listener) const {
    *listener &lt;&lt; whose_field_ &lt;&lt; "is ";
    return MatchPrintAndExplain(obj.*field_, matcher_, listener);
  }
  bool MatchAndExplainImpl(std::true_type                            MatchResultListener* listener) const {
    if (p == nullptr) return false;
    *listener &lt;&lt; "which points to an object ";
    return MatchAndExplainImpl(std::false_type(), *p, listener);
  }
  const FieldType Class::*field_;
  const Matcher&lt;const FieldType&amp;&gt; matcher_;
  const std::string whose_field_;
  GTEST_DISALLOW_ASSIGN_(FieldMatcher);
};
template &lt;typename Class, typename PropertyType, typename Property&gt;
class PropertyMatcher {
 public:
  typedef const PropertyType&amp; RefToConstProperty;
  PropertyMatcher(Property property, const Matcher&lt;RefToConstProperty&gt;&amp; matcher)
      : property_(property),
        matcher_(matcher),
        whose_property_("whose given property ") {}
  PropertyMatcher(const std::string&amp; property_name, Property property,
                  const Matcher&lt;RefToConstProperty&gt;&amp; matcher)
      : property_(property),
        matcher_(matcher),
        whose_property_("whose property `" + property_name + "` ") {}
  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "is an object " &lt;&lt; whose_property_;
    matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "is an object " &lt;&lt; whose_property_;
    matcher_.DescribeNegationTo(os);
  }
  template &lt;typename T&gt;
  bool MatchAndExplain(const T&amp;value, MatchResultListener* listener) const {
    return MatchAndExplainImpl(
        typename std::is_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type(),
        value, listener);
  }
 private:
  bool MatchAndExplainImpl(std::false_type                            const Class&amp; obj,
                           MatchResultListener* listener) const {
    *listener &lt;&lt; whose_property_ &lt;&lt; "is ";
    RefToConstProperty result = (obj.*property_)();
    return MatchPrintAndExplain(result, matcher_, listener);
  }
  bool MatchAndExplainImpl(std::true_type                            MatchResultListener* listener) const {
    if (p == nullptr) return false;
    *listener &lt;&lt; "which points to an object ";
    return MatchAndExplainImpl(std::false_type(), *p, listener);
  }
  Property property_;
  const Matcher&lt;RefToConstProperty&gt; matcher_;
  const std::string whose_property_;
  GTEST_DISALLOW_ASSIGN_(PropertyMatcher);
};
template &lt;typename Functor&gt;
struct CallableTraits {
  typedef Functor StorageType;
  static void CheckIsValid(Functor 
  template &lt;typename T&gt;
  static auto Invoke(Functor f, const T&amp; arg) -&gt; decltype(f(arg)) {
    return f(arg);
  }
};
template &lt;typename ArgType, typename ResType&gt;
struct CallableTraits&lt;ResType(*)(ArgType)&gt; {
  typedef ResType ResultType;
  typedef ResType(*StorageType)(ArgType);
  static void CheckIsValid(ResType(*f)(ArgType)) {
    GTEST_CHECK_(f != nullptr)
        &lt;&lt; "NULL function pointer is passed into ResultOf().";
  }
  template &lt;typename T&gt;
  static ResType Invoke(ResType(*f)(ArgType), T arg) {
    return (*f)(arg);
  }
};
template &lt;typename Callable, typename InnerMatcher&gt;
class ResultOfMatcher {
 public:
  ResultOfMatcher(Callable callable, InnerMatcher matcher)
      : callable_(std::move(callable)), matcher_(std::move(matcher)) {
    CallableTraits&lt;Callable&gt;::CheckIsValid(callable_);
  }
  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const {
    return Matcher&lt;T&gt;(new Impl&lt;const T&amp;&gt;(callable_, matcher_));
  }
 private:
  typedef typename CallableTraits&lt;Callable&gt;::StorageType CallableStorageType;
  template &lt;typename T&gt;
  class Impl : public MatcherInterface&lt;T&gt; {
    using ResultType = decltype(CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(
        std::declval&lt;CallableStorageType&gt;(), std::declval&lt;T&gt;()));
   public:
    template &lt;typename M&gt;
    Impl(const CallableStorageType&amp; callable, const M&amp; matcher)
        : callable_(callable), matcher_(MatcherCast&lt;ResultType&gt;(matcher)) {}
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "is mapped by the given callable to a value that ";
      matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "is mapped by the given callable to a value that ";
      matcher_.DescribeNegationTo(os);
    }
    bool MatchAndExplain(T obj, MatchResultListener* listener) const override {
      *listener &lt;&lt; "which is mapped by the given callable to ";
      ResultType result =
          CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(callable_, obj);
      return MatchPrintAndExplain(result, matcher_, listener);
    }
   private:
    mutable CallableStorageType callable_;
    const Matcher&lt;ResultType&gt; matcher_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };  
  const CallableStorageType callable_;
  const InnerMatcher matcher_;
  GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);
};
template &lt;typename SizeMatcher&gt;
class SizeIsMatcher {
 public:
  explicit SizeIsMatcher(const SizeMatcher&amp; size_matcher)
       : size_matcher_(size_matcher) {
  }
  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(new Impl&lt;const Container&amp;&gt;(size_matcher_));
  }
  template &lt;typename Container&gt;
  class Impl : public MatcherInterface&lt;Container&gt; {
   public:
    using SizeType = decltype(std::declval&lt;Container&gt;().size());
    explicit Impl(const SizeMatcher&amp; size_matcher)
        : size_matcher_(MatcherCast&lt;SizeType&gt;(size_matcher)) {}
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "size ";
      size_matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "size ";
      size_matcher_.DescribeNegationTo(os);
    }
    bool MatchAndExplain(Container container,
                         MatchResultListener* listener) const override {
      SizeType size = container.size();
      StringMatchResultListener size_listener;
      const bool result = size_matcher_.MatchAndExplain(size, &amp;size_listener);
      *listener
          &lt;&lt; "whose size " &lt;&lt; size &lt;&lt; (result ? " matches" : " doesn't match");
      PrintIfNotEmpty(size_listener.str(), listener-&gt;stream());
      return result;
    }
   private:
    const Matcher&lt;SizeType&gt; size_matcher_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
 private:
  const SizeMatcher size_matcher_;
  GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);
};
template &lt;typename DistanceMatcher&gt;
class BeginEndDistanceIsMatcher {
 public:
  explicit BeginEndDistanceIsMatcher(const DistanceMatcher&amp; distance_matcher)
      : distance_matcher_(distance_matcher) {}
  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(new Impl&lt;const Container&amp;&gt;(distance_matcher_));
  }
  template &lt;typename Container&gt;
  class Impl : public MatcherInterface&lt;Container&gt; {
   public:
    typedef internal::StlContainerView&lt;
        GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt; ContainerView;
    typedef typename std::iterator_traits&lt;
        typename ContainerView::type::const_iterator&gt;::difference_type
        DistanceType;
    explicit Impl(const DistanceMatcher&amp; distance_matcher)
        : distance_matcher_(MatcherCast&lt;DistanceType&gt;(distance_matcher)) {}
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "distance between begin() and end() ";
      distance_matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "distance between begin() and end() ";
      distance_matcher_.DescribeNegationTo(os);
    }
    bool MatchAndExplain(Container container,
                         MatchResultListener* listener) const override {
      using std::begin;
      using std::end;
      DistanceType distance = std::distance(begin(container), end(container));
      StringMatchResultListener distance_listener;
      const bool result =
          distance_matcher_.MatchAndExplain(distance, &amp;distance_listener);
      *listener &lt;&lt; "whose distance between begin() and end() " &lt;&lt; distance
                &lt;&lt; (result ? " matches" : " doesn't match");
      PrintIfNotEmpty(distance_listener.str(), listener-&gt;stream());
      return result;
    }
   private:
    const Matcher&lt;DistanceType&gt; distance_matcher_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
 private:
  const DistanceMatcher distance_matcher_;
  GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher);
};
template &lt;typename Container&gt;
class ContainerEqMatcher {
 public:
  typedef internal::StlContainerView&lt;Container&gt; View;
  typedef typename View::type StlContainer;
  typedef typename View::const_reference StlContainerReference;
  static_assert(!std::is_const&lt;Container&gt;::value,
                "Container type must not be const");
  static_assert(!std::is_reference&lt;Container&gt;::value,
                "Container type must not be a reference");
  explicit ContainerEqMatcher(const Container&amp; expected)
      : expected_(View::Copy(expected)) {}
  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "equals ";
    UniversalPrint(expected_, os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "does not equal ";
    UniversalPrint(expected_, os);
  }
  template &lt;typename LhsContainer&gt;
  bool MatchAndExplain(const LhsContainer&amp; lhs,
                       MatchResultListener* listener) const {
    typedef internal::StlContainerView&lt;
        typename std::remove_const&lt;LhsContainer&gt;::type&gt;
        LhsView;
    typedef typename LhsView::type LhsStlContainer;
    StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
    if (lhs_stl_container == expected_)
      return true;
    ::std::ostream* const os = listener-&gt;stream();
    if (os != nullptr) {
      bool printed_header = false;
      for (typename LhsStlContainer::const_iterator it =
               lhs_stl_container.begin();
           it != lhs_stl_container.end(); ++it) {
        if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==
            expected_.end()) {
          if (printed_header) {
            *os &lt;&lt; ", ";
          } else {
            *os &lt;&lt; "which has these unexpected elements: ";
            printed_header = true;
          }
          UniversalPrint(*it, os);
        }
      }
      bool printed_header2 = false;
      for (typename StlContainer::const_iterator it = expected_.begin();
           it != expected_.end(); ++it) {
        if (internal::ArrayAwareFind(
                lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==
            lhs_stl_container.end()) {
          if (printed_header2) {
            *os &lt;&lt; ", ";
          } else {
            *os &lt;&lt; (printed_header ? ",\nand" : "which")
                &lt;&lt; " doesn't have these expected elements: ";
            printed_header2 = true;
          }
          UniversalPrint(*it, os);
        }
      }
    }
    return false;
  }
 private:
  const StlContainer expected_;
  GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);
};
struct LessComparator {
  template &lt;typename T, typename U&gt;
  bool operator()(const T&amp; lhs, const U&amp; rhs) const { return lhs &lt; rhs; }
};
template &lt;typename Comparator, typename ContainerMatcher&gt;
class WhenSortedByMatcher {
 public:
  WhenSortedByMatcher(const Comparator&amp; comparator,
                      const ContainerMatcher&amp; matcher)
      : comparator_(comparator), matcher_(matcher) {}
  template &lt;typename LhsContainer&gt;
  operator Matcher&lt;LhsContainer&gt;() const {
    return MakeMatcher(new Impl&lt;LhsContainer&gt;(comparator_, matcher_));
  }
  template &lt;typename LhsContainer&gt;
  class Impl : public MatcherInterface&lt;LhsContainer&gt; {
   public:
    typedef internal::StlContainerView&lt;
         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt; LhsView;
    typedef typename LhsView::type LhsStlContainer;
    typedef typename LhsView::const_reference LhsStlContainerReference;
    typedef typename RemoveConstFromKey&lt;
        typename LhsStlContainer::value_type&gt;::type LhsValue;
    Impl(const Comparator&amp; comparator, const ContainerMatcher&amp; matcher)
        : comparator_(comparator), matcher_(matcher) {}
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "(when sorted) ";
      matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "(when sorted) ";
      matcher_.DescribeNegationTo(os);
    }
    bool MatchAndExplain(LhsContainer lhs,
                         MatchResultListener* listener) const override {
      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
      ::std::vector&lt;LhsValue&gt; sorted_container(lhs_stl_container.begin(),
                                               lhs_stl_container.end());
      ::std::sort(
           sorted_container.begin(), sorted_container.end(), comparator_);
      if (!listener-&gt;IsInterested()) {
        return matcher_.Matches(sorted_container);
      }
      *listener &lt;&lt; "which is ";
      UniversalPrint(sorted_container, listener-&gt;stream());
      *listener &lt;&lt; " when sorted";
      StringMatchResultListener inner_listener;
      const bool match = matcher_.MatchAndExplain(sorted_container,
                                                  &amp;inner_listener);
      PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
      return match;
    }
   private:
    const Comparator comparator_;
    const Matcher&lt;const ::std::vector&lt;LhsValue&gt;&amp;&gt; matcher_;
    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
  };
 private:
  const Comparator comparator_;
  const ContainerMatcher matcher_;
  GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);
};
template &lt;typename TupleMatcher, typename RhsContainer&gt;
class PointwiseMatcher {
  GTEST_COMPILE_ASSERT_(
      !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)&gt;::value,
      use_UnorderedPointwise_with_hash_tables);
 public:
  typedef internal::StlContainerView&lt;RhsContainer&gt; RhsView;
  typedef typename RhsView::type RhsStlContainer;
  typedef typename RhsStlContainer::value_type RhsValue;
  static_assert(!std::is_const&lt;RhsContainer&gt;::value,
                "RhsContainer type must not be const");
  static_assert(!std::is_reference&lt;RhsContainer&gt;::value,
                "RhsContainer type must not be a reference");
  PointwiseMatcher(const TupleMatcher&amp; tuple_matcher, const RhsContainer&amp; rhs)
      : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {}
  template &lt;typename LhsContainer&gt;
  operator Matcher&lt;LhsContainer&gt;() const {
    GTEST_COMPILE_ASSERT_(
        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt;::value,
        use_UnorderedPointwise_with_hash_tables);
    return Matcher&lt;LhsContainer&gt;(
        new Impl&lt;const LhsContainer&amp;&gt;(tuple_matcher_, rhs_));
  }
  template &lt;typename LhsContainer&gt;
  class Impl : public MatcherInterface&lt;LhsContainer&gt; {
   public:
    typedef internal::StlContainerView&lt;
         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt; LhsView;
    typedef typename LhsView::type LhsStlContainer;
    typedef typename LhsView::const_reference LhsStlContainerReference;
    typedef typename LhsStlContainer::value_type LhsValue;
    typedef ::std::tuple&lt;const LhsValue&amp;, const RhsValue&amp;&gt; InnerMatcherArg;
    Impl(const TupleMatcher&amp; tuple_matcher, const RhsStlContainer&amp; rhs)
        : mono_tuple_matcher_(SafeMatcherCast&lt;InnerMatcherArg&gt;(tuple_matcher)),
          rhs_(rhs) {}
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "contains " &lt;&lt; rhs_.size()
          &lt;&lt; " values, where each value and its corresponding value in ";
      UniversalPrinter&lt;RhsStlContainer&gt;::Print(rhs_, os);
      *os &lt;&lt; " ";
      mono_tuple_matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "doesn't contain exactly " &lt;&lt; rhs_.size()
          &lt;&lt; " values, or contains a value x at some index i"
          &lt;&lt; " where x and the i-th value of ";
      UniversalPrint(rhs_, os);
      *os &lt;&lt; " ";
      mono_tuple_matcher_.DescribeNegationTo(os);
    }
    bool MatchAndExplain(LhsContainer lhs,
                         MatchResultListener* listener) const override {
      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
      const size_t actual_size = lhs_stl_container.size();
      if (actual_size != rhs_.size()) {
        *listener &lt;&lt; "which contains " &lt;&lt; actual_size &lt;&lt; " values";
        return false;
      }
      typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();
      typename RhsStlContainer::const_iterator right = rhs_.begin();
      for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {
        if (listener-&gt;IsInterested()) {
          StringMatchResultListener inner_listener;
          if (!mono_tuple_matcher_.MatchAndExplain(
                  InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),
                                  ImplicitCast_&lt;const RhsValue&amp;&gt;(*right)),
                  &amp;inner_listener)) {
            *listener &lt;&lt; "where the value pair (";
            UniversalPrint(*left, listener-&gt;stream());
            *listener &lt;&lt; ", ";
            UniversalPrint(*right, listener-&gt;stream());
            *listener &lt;&lt; ") at index #" &lt;&lt; i &lt;&lt; " don't match";
            PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
            return false;
          }
        } else {
          if (!mono_tuple_matcher_.Matches(
                  InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),
                                  ImplicitCast_&lt;const RhsValue&amp;&gt;(*right))))
            return false;
        }
      }
      return true;
    }
   private:
    const Matcher&lt;InnerMatcherArg&gt; mono_tuple_matcher_;
    const RhsStlContainer rhs_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
 private:
  const TupleMatcher tuple_matcher_;
  const RhsStlContainer rhs_;
  GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);
};
template &lt;typename Container&gt;
class QuantifierMatcherImpl : public MatcherInterface&lt;Container&gt; {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
  typedef StlContainerView&lt;RawContainer&gt; View;
  typedef typename View::type StlContainer;
  typedef typename View::const_reference StlContainerReference;
  typedef typename StlContainer::value_type Element;
  template &lt;typename InnerMatcher&gt;
  explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)
      : inner_matcher_(
           testing::SafeMatcherCast&lt;const Element&amp;&gt;(inner_matcher)) {}
  bool MatchAndExplainImpl(bool all_elements_should_match,
                           Container container,
                           MatchResultListener* listener) const {
    StlContainerReference stl_container = View::ConstReference(container);
    size_t i = 0;
    for (typename StlContainer::const_iterator it = stl_container.begin();
         it != stl_container.end(); ++it, ++i) {
      StringMatchResultListener inner_listener;
      const bool matches = inner_matcher_.MatchAndExplain(*it, &amp;inner_listener);
      if (matches != all_elements_should_match) {
        *listener &lt;&lt; "whose element #" &lt;&lt; i
                  &lt;&lt; (matches ? " matches" : " doesn't match");
        PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
        return !all_elements_should_match;
      }
    }
    return all_elements_should_match;
  }
 protected:
  const Matcher&lt;const Element&amp;&gt; inner_matcher_;
  GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);
};
template &lt;typename Container&gt;
class ContainsMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {
 public:
  template &lt;typename InnerMatcher&gt;
  explicit ContainsMatcherImpl(InnerMatcher inner_matcher)
      : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "contains at least one element that ";
    this-&gt;inner_matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "doesn't contain any element that ";
    this-&gt;inner_matcher_.DescribeTo(os);
  }
  bool MatchAndExplain(Container container,
                       MatchResultListener* listener) const override {
    return this-&gt;MatchAndExplainImpl(false, container, listener);
  }
 private:
  GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);
};
template &lt;typename Container&gt;
class EachMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {
 public:
  template &lt;typename InnerMatcher&gt;
  explicit EachMatcherImpl(InnerMatcher inner_matcher)
      : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "only contains elements that ";
    this-&gt;inner_matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "contains some element that ";
    this-&gt;inner_matcher_.DescribeNegationTo(os);
  }
  bool MatchAndExplain(Container container,
                       MatchResultListener* listener) const override {
    return this-&gt;MatchAndExplainImpl(true, container, listener);
  }
 private:
  GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);
};
template &lt;typename M&gt;
class ContainsMatcher {
 public:
  explicit ContainsMatcher(M m) : inner_matcher_(m) {}
  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(
        new ContainsMatcherImpl&lt;const Container&amp;&gt;(inner_matcher_));
  }
 private:
  const M inner_matcher_;
  GTEST_DISALLOW_ASSIGN_(ContainsMatcher);
};
template &lt;typename M&gt;
class EachMatcher {
 public:
  explicit EachMatcher(M m) : inner_matcher_(m) {}
  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(
        new EachMatcherImpl&lt;const Container&amp;&gt;(inner_matcher_));
  }
 private:
  const M inner_matcher_;
  GTEST_DISALLOW_ASSIGN_(EachMatcher);
};
struct Rank1 {};
struct Rank0 : Rank1 {};
namespace pair_getters {
using std::get;
template &lt;typename T&gt;
auto First(T&amp; x, Rank1) -&gt; decltype(get&lt;0&gt;(x)) {    return get&lt;0&gt;(x);
}
template &lt;typename T&gt;
auto First(T&amp; x, Rank0) -&gt; decltype((x.first)) {    return x.first;
}
template &lt;typename T&gt;
auto Second(T&amp; x, Rank1) -&gt; decltype(get&lt;1&gt;(x)) {    return get&lt;1&gt;(x);
}
template &lt;typename T&gt;
auto Second(T&amp; x, Rank0) -&gt; decltype((x.second)) {    return x.second;
}
}  
template &lt;typename PairType&gt;
class KeyMatcherImpl : public MatcherInterface&lt;PairType&gt; {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
  typedef typename RawPairType::first_type KeyType;
  template &lt;typename InnerMatcher&gt;
  explicit KeyMatcherImpl(InnerMatcher inner_matcher)
      : inner_matcher_(
          testing::SafeMatcherCast&lt;const KeyType&amp;&gt;(inner_matcher)) {
  }
  bool MatchAndExplain(PairType key_value,
                       MatchResultListener* listener) const override {
    StringMatchResultListener inner_listener;
    const bool match = inner_matcher_.MatchAndExplain(
        pair_getters::First(key_value, Rank0()), &amp;inner_listener);
    const std::string explanation = inner_listener.str();
    if (explanation != "") {
      *listener &lt;&lt; "whose first field is a value " &lt;&lt; explanation;
    }
    return match;
  }
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "has a key that ";
    inner_matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "doesn't have a key that ";
    inner_matcher_.DescribeTo(os);
  }
 private:
  const Matcher&lt;const KeyType&amp;&gt; inner_matcher_;
  GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);
};
template &lt;typename M&gt;
class KeyMatcher {
 public:
  explicit KeyMatcher(M m) : matcher_for_key_(m) {}
  template &lt;typename PairType&gt;
  operator Matcher&lt;PairType&gt;() const {
    return Matcher&lt;PairType&gt;(
        new KeyMatcherImpl&lt;const PairType&amp;&gt;(matcher_for_key_));
  }
 private:
  const M matcher_for_key_;
  GTEST_DISALLOW_ASSIGN_(KeyMatcher);
};
template &lt;typename PairType&gt;
class PairMatcherImpl : public MatcherInterface&lt;PairType&gt; {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
  typedef typename RawPairType::first_type FirstType;
  typedef typename RawPairType::second_type SecondType;
  template &lt;typename FirstMatcher, typename SecondMatcher&gt;
  PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)
      : first_matcher_(
            testing::SafeMatcherCast&lt;const FirstType&amp;&gt;(first_matcher)),
        second_matcher_(
            testing::SafeMatcherCast&lt;const SecondType&amp;&gt;(second_matcher)) {
  }
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "has a first field that ";
    first_matcher_.DescribeTo(os);
    *os &lt;&lt; ", and has a second field that ";
    second_matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "has a first field that ";
    first_matcher_.DescribeNegationTo(os);
    *os &lt;&lt; ", or has a second field that ";
    second_matcher_.DescribeNegationTo(os);
  }
  bool MatchAndExplain(PairType a_pair,
                       MatchResultListener* listener) const override {
    if (!listener-&gt;IsInterested()) {
      return first_matcher_.Matches(pair_getters::First(a_pair, Rank0())) &amp;&amp;
             second_matcher_.Matches(pair_getters::Second(a_pair, Rank0()));
    }
    StringMatchResultListener first_inner_listener;
    if (!first_matcher_.MatchAndExplain(pair_getters::First(a_pair, Rank0()),
                                        &amp;first_inner_listener)) {
      *listener &lt;&lt; "whose first field does not match";
      PrintIfNotEmpty(first_inner_listener.str(), listener-&gt;stream());
      return false;
    }
    StringMatchResultListener second_inner_listener;
    if (!second_matcher_.MatchAndExplain(pair_getters::Second(a_pair, Rank0()),
                                         &amp;second_inner_listener)) {
      *listener &lt;&lt; "whose second field does not match";
      PrintIfNotEmpty(second_inner_listener.str(), listener-&gt;stream());
      return false;
    }
    ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),
                   listener);
    return true;
  }
 private:
  void ExplainSuccess(const std::string&amp; first_explanation,
                      const std::string&amp; second_explanation,
                      MatchResultListener* listener) const {
    *listener &lt;&lt; "whose both fields match";
    if (first_explanation != "") {
      *listener &lt;&lt; ", where the first field is a value " &lt;&lt; first_explanation;
    }
    if (second_explanation != "") {
      *listener &lt;&lt; ", ";
      if (first_explanation != "") {
        *listener &lt;&lt; "and ";
      } else {
        *listener &lt;&lt; "where ";
      }
      *listener &lt;&lt; "the second field is a value " &lt;&lt; second_explanation;
    }
  }
  const Matcher&lt;const FirstType&amp;&gt; first_matcher_;
  const Matcher&lt;const SecondType&amp;&gt; second_matcher_;
  GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);
};
template &lt;typename FirstMatcher, typename SecondMatcher&gt;
class PairMatcher {
 public:
  PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)
      : first_matcher_(first_matcher), second_matcher_(second_matcher) {}
  template &lt;typename PairType&gt;
  operator Matcher&lt;PairType&gt; () const {
    return Matcher&lt;PairType&gt;(
        new PairMatcherImpl&lt;const PairType&amp;&gt;(first_matcher_, second_matcher_));
  }
 private:
  const FirstMatcher first_matcher_;
  const SecondMatcher second_matcher_;
  GTEST_DISALLOW_ASSIGN_(PairMatcher);
};
template &lt;typename Container&gt;
class ElementsAreMatcherImpl : public MatcherInterface&lt;Container&gt; {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
  typedef internal::StlContainerView&lt;RawContainer&gt; View;
  typedef typename View::type StlContainer;
  typedef typename View::const_reference StlContainerReference;
  typedef typename StlContainer::value_type Element;
  template &lt;typename InputIter&gt;
  ElementsAreMatcherImpl(InputIter first, InputIter last) {
    while (first != last) {
      matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first++));
    }
  }
  void DescribeTo(::std::ostream* os) const override {
    if (count() == 0) {
      *os &lt;&lt; "is empty";
    } else if (count() == 1) {
      *os &lt;&lt; "has 1 element that ";
      matchers_[0].DescribeTo(os);
    } else {
      *os &lt;&lt; "has " &lt;&lt; Elements(count()) &lt;&lt; " where\n";
      for (size_t i = 0; i != count(); ++i) {
        *os &lt;&lt; "element #" &lt;&lt; i &lt;&lt; " ";
        matchers_[i].DescribeTo(os);
        if (i + 1 &lt; count()) {
          *os &lt;&lt; ",\n";
        }
      }
    }
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    if (count() == 0) {
      *os &lt;&lt; "isn't empty";
      return;
    }
    *os &lt;&lt; "doesn't have " &lt;&lt; Elements(count()) &lt;&lt; ", or\n";
    for (size_t i = 0; i != count(); ++i) {
      *os &lt;&lt; "element #" &lt;&lt; i &lt;&lt; " ";
      matchers_[i].DescribeNegationTo(os);
      if (i + 1 &lt; count()) {
        *os &lt;&lt; ", or\n";
      }
    }
  }
  bool MatchAndExplain(Container container,
                       MatchResultListener* listener) const override {
    const bool listener_interested = listener-&gt;IsInterested();
    ::std::vector&lt;std::string&gt; explanations(count());
    StlContainerReference stl_container = View::ConstReference(container);
    typename StlContainer::const_iterator it = stl_container.begin();
    size_t exam_pos = 0;
    bool mismatch_found = false;  
    for (; it != stl_container.end() &amp;&amp; exam_pos != count(); ++it, ++exam_pos) {
      bool match;        if (listener_interested) {
        StringMatchResultListener s;
        match = matchers_[exam_pos].MatchAndExplain(*it, &amp;s);
        explanations[exam_pos] = s.str();
      } else {
        match = matchers_[exam_pos].Matches(*it);
      }
      if (!match) {
        mismatch_found = true;
        break;
      }
    }
    size_t actual_count = exam_pos;
    for (; it != stl_container.end(); ++it) {
      ++actual_count;
    }
    if (actual_count != count()) {
      if (listener_interested &amp;&amp; (actual_count != 0)) {
        *listener &lt;&lt; "which has " &lt;&lt; Elements(actual_count);
      }
      return false;
    }
    if (mismatch_found) {
      if (listener_interested) {
        *listener &lt;&lt; "whose element #" &lt;&lt; exam_pos &lt;&lt; " doesn't match";
        PrintIfNotEmpty(explanations[exam_pos], listener-&gt;stream());
      }
      return false;
    }
    if (listener_interested) {
      bool reason_printed = false;
      for (size_t i = 0; i != count(); ++i) {
        const std::string&amp; s = explanations[i];
        if (!s.empty()) {
          if (reason_printed) {
            *listener &lt;&lt; ",\nand ";
          }
          *listener &lt;&lt; "whose element #" &lt;&lt; i &lt;&lt; " matches, " &lt;&lt; s;
          reason_printed = true;
        }
      }
    }
    return true;
  }
 private:
  static Message Elements(size_t count) {
    return Message() &lt;&lt; count &lt;&lt; (count == 1 ? " element" : " elements");
  }
  size_t count() const { return matchers_.size(); }
  ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; matchers_;
  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);
};
class GTEST_API_ MatchMatrix {
 public:
  MatchMatrix(size_t num_elements, size_t num_matchers)
      : num_elements_(num_elements),
        num_matchers_(num_matchers),
        matched_(num_elements_* num_matchers_, 0) {
  }
  size_t LhsSize() const { return num_elements_; }
  size_t RhsSize() const { return num_matchers_; }
  bool HasEdge(size_t ilhs, size_t irhs) const {
    return matched_[SpaceIndex(ilhs, irhs)] == 1;
  }
  void SetEdge(size_t ilhs, size_t irhs, bool b) {
    matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;
  }
  bool NextGraph();
  void Randomize();
  std::string DebugString() const;
 private:
  size_t SpaceIndex(size_t ilhs, size_t irhs) const {
    return ilhs * num_matchers_ + irhs;
  }
  size_t num_elements_;
  size_t num_matchers_;
  ::std::vector&lt;char&gt; matched_;
};
typedef ::std::pair&lt;size_t, size_t&gt; ElementMatcherPair;
typedef ::std::vector&lt;ElementMatcherPair&gt; ElementMatcherPairs;
GTEST_API_ ElementMatcherPairs
FindMaxBipartiteMatching(const MatchMatrix&amp; g);
struct UnorderedMatcherRequire {
  enum Flags {
    Superset = 1 &lt;&lt; 0,
    Subset = 1 &lt;&lt; 1,
    ExactMatch = Superset | Subset,
  };
};
class GTEST_API_ UnorderedElementsAreMatcherImplBase {
 protected:
  explicit UnorderedElementsAreMatcherImplBase(
      UnorderedMatcherRequire::Flags matcher_flags)
      : match_flags_(matcher_flags) {}
  typedef ::std::vector&lt;const MatcherDescriberInterface*&gt; MatcherDescriberVec;
  void DescribeToImpl(::std::ostream* os) const;
  void DescribeNegationToImpl(::std::ostream* os) const;
  bool VerifyMatchMatrix(const ::std::vector&lt;std::string&gt;&amp; element_printouts,
                         const MatchMatrix&amp; matrix,
                         MatchResultListener* listener) const;
  bool FindPairing(const MatchMatrix&amp; matrix,
                   MatchResultListener* listener) const;
  MatcherDescriberVec&amp; matcher_describers() {
    return matcher_describers_;
  }
  static Message Elements(size_t n) {
    return Message() &lt;&lt; n &lt;&lt; " element" &lt;&lt; (n == 1 ? "" : "s");
  }
  UnorderedMatcherRequire::Flags match_flags() const { return match_flags_; }
 private:
  UnorderedMatcherRequire::Flags match_flags_;
  MatcherDescriberVec matcher_describers_;
  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);
};
template &lt;typename Container&gt;
class UnorderedElementsAreMatcherImpl
    : public MatcherInterface&lt;Container&gt;,
      public UnorderedElementsAreMatcherImplBase {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
  typedef internal::StlContainerView&lt;RawContainer&gt; View;
  typedef typename View::type StlContainer;
  typedef typename View::const_reference StlContainerReference;
  typedef typename StlContainer::const_iterator StlContainerConstIterator;
  typedef typename StlContainer::value_type Element;
  template &lt;typename InputIter&gt;
  UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags matcher_flags,
                                  InputIter first, InputIter last)
      : UnorderedElementsAreMatcherImplBase(matcher_flags) {
    for (; first != last; ++first) {
      matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first));
      matcher_describers().push_back(matchers_.back().GetDescriber());
    }
  }
  void DescribeTo(::std::ostream* os) const override {
    return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);
  }
  bool MatchAndExplain(Container container,
                       MatchResultListener* listener) const override {
    StlContainerReference stl_container = View::ConstReference(container);
    ::std::vector&lt;std::string&gt; element_printouts;
    MatchMatrix matrix =
        AnalyzeElements(stl_container.begin(), stl_container.end(),
                        &amp;element_printouts, listener);
    if (matrix.LhsSize() == 0 &amp;&amp; matrix.RhsSize() == 0) {
      return true;
    }
    if (match_flags() == UnorderedMatcherRequire::ExactMatch) {
      if (matrix.LhsSize() != matrix.RhsSize()) {
        if (matrix.LhsSize() != 0 &amp;&amp; listener-&gt;IsInterested()) {
          *listener &lt;&lt; "which has " &lt;&lt; Elements(matrix.LhsSize());
        }
        return false;
      }
    }
    return VerifyMatchMatrix(element_printouts, matrix, listener) &amp;&amp;
           FindPairing(matrix, listener);
  }
 private:
  template &lt;typename ElementIter&gt;
  MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,
                              ::std::vector&lt;std::string&gt;* element_printouts,
                              MatchResultListener* listener) const {
    element_printouts-&gt;clear();
    ::std::vector&lt;char&gt; did_match;
    size_t num_elements = 0;
    for (; elem_first != elem_last; ++num_elements, ++elem_first) {
      if (listener-&gt;IsInterested()) {
        element_printouts-&gt;push_back(PrintToString(*elem_first));
      }
      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
        did_match.push_back(Matches(matchers_[irhs])(*elem_first));
      }
    }
    MatchMatrix matrix(num_elements, matchers_.size());
    ::std::vector&lt;char&gt;::const_iterator did_match_iter = did_match.begin();
    for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {
      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
        matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);
      }
    }
    return matrix;
  }
  ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; matchers_;
  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);
};
<a name="1"></a>template &lt;typename Target&gt;
struct CastAndAppendTransform {
  template &lt;typename Arg&gt;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  Matcher&lt;Target&gt; operator()(const Arg&amp; a) const {
    return MatcherCast&lt;Target&gt;(a);
  }
};
template &lt;typename MatcherTuple&gt;
class UnorderedElementsAreMatcher {
 public:
  explicit UnorderedElementsAreMatcher(const MatcherTuple&amp; args)
      : matchers_(args) {}
  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;</b></font>
    typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;
    typedef typename View::value_type Element;
    typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; MatcherVec;
    MatcherVec matchers;
    matchers.reserve(::std::tuple_size&lt;MatcherTuple&gt;::value);
    TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,
                         ::std::back_inserter(matchers));
    return Matcher&lt;Container&gt;(
        new UnorderedElementsAreMatcherImpl&lt;const Container&amp;&gt;(
            UnorderedMatcherRequire::ExactMatch, matchers.begin(),
            matchers.end()));
  }
 private:
  const MatcherTuple matchers_;
  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);
};
template &lt;typename MatcherTuple&gt;
class ElementsAreMatcher {
 public:
  explicit ElementsAreMatcher(const MatcherTuple&amp; args) : matchers_(args) {}
  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    GTEST_COMPILE_ASSERT_(
        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value ||
            ::std::tuple_size&lt;MatcherTuple&gt;::value &lt; 2,
        use_UnorderedElementsAre_with_hash_tables);
    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
    typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;
    typedef typename View::value_type Element;
    typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; MatcherVec;
    MatcherVec matchers;
    matchers.reserve(::std::tuple_size&lt;MatcherTuple&gt;::value);
    TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,
                         ::std::back_inserter(matchers));
    return Matcher&lt;Container&gt;(new ElementsAreMatcherImpl&lt;const Container&amp;&gt;(
        matchers.begin(), matchers.end()));
  }
 private:
  const MatcherTuple matchers_;
  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);
};
template &lt;typename T&gt;
class UnorderedElementsAreArrayMatcher {
 public:
  template &lt;typename Iter&gt;
  UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags match_flags,
                                   Iter first, Iter last)
      : match_flags_(match_flags), matchers_(first, last) {}
  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(
        new UnorderedElementsAreMatcherImpl&lt;const Container&amp;&gt;(
            match_flags_, matchers_.begin(), matchers_.end()));
  }
 private:
  UnorderedMatcherRequire::Flags match_flags_;
  ::std::vector&lt;T&gt; matchers_;
  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);
};
template &lt;typename T&gt;
class ElementsAreArrayMatcher {
 public:
  template &lt;typename Iter&gt;
  ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}
  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    GTEST_COMPILE_ASSERT_(
        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value,
        use_UnorderedElementsAreArray_with_hash_tables);
    return Matcher&lt;Container&gt;(new ElementsAreMatcherImpl&lt;const Container&amp;&gt;(
        matchers_.begin(), matchers_.end()));
  }
 private:
  const ::std::vector&lt;T&gt; matchers_;
  GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);
};
template &lt;typename Tuple2Matcher, typename Second&gt;
class BoundSecondMatcher {
 public:
  BoundSecondMatcher(const Tuple2Matcher&amp; tm, const Second&amp; second)
      : tuple2_matcher_(tm), second_value_(second) {}
  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const {
    return MakeMatcher(new Impl&lt;T&gt;(tuple2_matcher_, second_value_));
  }
    GTEST_LOG_(FATAL) &lt;&lt; "BoundSecondMatcher should never be assigned.";
  }
 private:
  template &lt;typename T&gt;
  class Impl : public MatcherInterface&lt;T&gt; {
   public:
    typedef ::std::tuple&lt;T, Second&gt; ArgTuple;
    Impl(const Tuple2Matcher&amp; tm, const Second&amp; second)
        : mono_tuple2_matcher_(SafeMatcherCast&lt;const ArgTuple&amp;&gt;(tm)),
          second_value_(second) {}
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "and ";
      UniversalPrint(second_value_, os);
      *os &lt;&lt; " ";
      mono_tuple2_matcher_.DescribeTo(os);
    }
    bool MatchAndExplain(T x, MatchResultListener* listener) const override {
      return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),
                                                  listener);
    }
   private:
    const Matcher&lt;const ArgTuple&amp;&gt; mono_tuple2_matcher_;
    const Second second_value_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
  const Tuple2Matcher tuple2_matcher_;
  const Second second_value_;
};
template &lt;typename Tuple2Matcher, typename Second&gt;
BoundSecondMatcher&lt;Tuple2Matcher, Second&gt; MatcherBindSecond(
    const Tuple2Matcher&amp; tm, const Second&amp; second) {
  return BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;(tm, second);
}
GTEST_API_ std::string FormatMatcherDescription(bool negation,
                                                const char* matcher_name,
                                                const Strings&amp; param_values);
template &lt;typename ValueMatcher&gt;
class OptionalMatcher {
 public:
  explicit OptionalMatcher(const ValueMatcher&amp; value_matcher)
      : value_matcher_(value_matcher) {}
  template &lt;typename Optional&gt;
  operator Matcher&lt;Optional&gt;() const {
    return Matcher&lt;Optional&gt;(new Impl&lt;const Optional&amp;&gt;(value_matcher_));
  }
  template &lt;typename Optional&gt;
  class Impl : public MatcherInterface&lt;Optional&gt; {
   public:
    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Optional) OptionalView;
    typedef typename OptionalView::value_type ValueType;
    explicit Impl(const ValueMatcher&amp; value_matcher)
        : value_matcher_(MatcherCast&lt;ValueType&gt;(value_matcher)) {}
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "value ";
      value_matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "value ";
      value_matcher_.DescribeNegationTo(os);
    }
    bool MatchAndExplain(Optional optional,
                         MatchResultListener* listener) const override {
      if (!optional) {
        *listener &lt;&lt; "which is not engaged";
        return false;
      }
      const ValueType&amp; value = *optional;
      StringMatchResultListener value_listener;
      const bool match = value_matcher_.MatchAndExplain(value, &amp;value_listener);
      *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(value)
                &lt;&lt; (match ? " matches" : " doesn't match");
      PrintIfNotEmpty(value_listener.str(), listener-&gt;stream());
      return match;
    }
   private:
    const Matcher&lt;ValueType&gt; value_matcher_;
    GTEST_DISALLOW_ASSIGN_(Impl);
  };
 private:
  const ValueMatcher value_matcher_;
  GTEST_DISALLOW_ASSIGN_(OptionalMatcher);
};
namespace variant_matcher {
template &lt;typename T&gt;
void holds_alternative() {}
template &lt;typename T&gt;
void get() {}
template &lt;typename T&gt;
class VariantMatcher {
 public:
  explicit VariantMatcher(::testing::Matcher&lt;const T&amp;&gt; matcher)
      : matcher_(std::move(matcher)) {}
  template &lt;typename Variant&gt;
  bool MatchAndExplain(const Variant&amp; value,
                       ::testing::MatchResultListener* listener) const {
    using std::get;
    if (!listener-&gt;IsInterested()) {
      return holds_alternative&lt;T&gt;(value) &amp;&amp; matcher_.Matches(get&lt;T&gt;(value));
    }
    if (!holds_alternative&lt;T&gt;(value)) {
      *listener &lt;&lt; "whose value is not of type '" &lt;&lt; GetTypeName() &lt;&lt; "'";
      return false;
    }
    const T&amp; elem = get&lt;T&gt;(value);
    StringMatchResultListener elem_listener;
    const bool match = matcher_.MatchAndExplain(elem, &amp;elem_listener);
    *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(elem)
              &lt;&lt; (match ? " matches" : " doesn't match");
    PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());
    return match;
  }
  void DescribeTo(std::ostream* os) const {
    *os &lt;&lt; "is a variant&lt;&gt; with value of type '" &lt;&lt; GetTypeName()
        &lt;&lt; "' and the value ";
    matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(std::ostream* os) const {
    *os &lt;&lt; "is a variant&lt;&gt; with value of type other than '" &lt;&lt; GetTypeName()
        &lt;&lt; "' or the value ";
    matcher_.DescribeNegationTo(os);
  }
 private:
  static std::string GetTypeName() {
#if GTEST_HAS_RTTI
    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
        return internal::GetTypeName&lt;T&gt;());
#endif
    return "the element type";
  }
  const ::testing::Matcher&lt;const T&amp;&gt; matcher_;
};
}  
namespace any_cast_matcher {
template &lt;typename T&gt;
void any_cast() {}
template &lt;typename T&gt;
class AnyCastMatcher {
 public:
  explicit AnyCastMatcher(const ::testing::Matcher&lt;const T&amp;&gt;&amp; matcher)
      : matcher_(matcher) {}
  template &lt;typename AnyType&gt;
  bool MatchAndExplain(const AnyType&amp; value,
                       ::testing::MatchResultListener* listener) const {
    if (!listener-&gt;IsInterested()) {
      const T* ptr = any_cast&lt;T&gt;(&amp;value);
      return ptr != nullptr &amp;&amp; matcher_.Matches(*ptr);
    }
    const T* elem = any_cast&lt;T&gt;(&amp;value);
    if (elem == nullptr) {
      *listener &lt;&lt; "whose value is not of type '" &lt;&lt; GetTypeName() &lt;&lt; "'";
      return false;
    }
    StringMatchResultListener elem_listener;
    const bool match = matcher_.MatchAndExplain(*elem, &amp;elem_listener);
    *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(*elem)
              &lt;&lt; (match ? " matches" : " doesn't match");
    PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());
    return match;
  }
  void DescribeTo(std::ostream* os) const {
    *os &lt;&lt; "is an 'any' type with value of type '" &lt;&lt; GetTypeName()
        &lt;&lt; "' and the value ";
    matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(std::ostream* os) const {
    *os &lt;&lt; "is an 'any' type with value of type other than '" &lt;&lt; GetTypeName()
        &lt;&lt; "' or the value ";
    matcher_.DescribeNegationTo(os);
  }
 private:
  static std::string GetTypeName() {
#if GTEST_HAS_RTTI
    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
        return internal::GetTypeName&lt;T&gt;());
#endif
    return "the element type";
  }
  const ::testing::Matcher&lt;const T&amp;&gt; matcher_;
};
}  
template &lt;class ArgsTuple, size_t... k&gt;
class ArgsMatcherImpl : public MatcherInterface&lt;ArgsTuple&gt; {
 public:
  using RawArgsTuple = typename std::decay&lt;ArgsTuple&gt;::type;
  using SelectedArgs =
      std::tuple&lt;typename std::tuple_element&lt;k, RawArgsTuple&gt;::type...&gt;;
  using MonomorphicInnerMatcher = Matcher&lt;const SelectedArgs&amp;&gt;;
  template &lt;typename InnerMatcher&gt;
  explicit ArgsMatcherImpl(const InnerMatcher&amp; inner_matcher)
      : inner_matcher_(SafeMatcherCast&lt;const SelectedArgs&amp;&gt;(inner_matcher)) {}
  bool MatchAndExplain(ArgsTuple args,
                       MatchResultListener* listener) const override {
    (void)args;
    const SelectedArgs&amp; selected_args =
        std::forward_as_tuple(std::get&lt;k&gt;(args)...);
    if (!listener-&gt;IsInterested()) return inner_matcher_.Matches(selected_args);
    PrintIndices(listener-&gt;stream());
    *listener &lt;&lt; "are " &lt;&lt; PrintToString(selected_args);
    StringMatchResultListener inner_listener;
    const bool match =
        inner_matcher_.MatchAndExplain(selected_args, &amp;inner_listener);
    PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
    return match;
  }
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "are a tuple ";
    PrintIndices(os);
    inner_matcher_.DescribeTo(os);
  }
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "are a tuple ";
    PrintIndices(os);
    inner_matcher_.DescribeNegationTo(os);
  }
 private:
  static void PrintIndices(::std::ostream* os) {
    *os &lt;&lt; "whose fields (";
    const char* sep = "";
    (void)sep;
    const char* dummy[] = {"", (*os &lt;&lt; sep &lt;&lt; "#" &lt;&lt; k, sep = ", ")...};
    (void)dummy;
    *os &lt;&lt; ") ";
  }
  MonomorphicInnerMatcher inner_matcher_;
};
template &lt;class InnerMatcher, size_t... k&gt;
class ArgsMatcher {
 public:
  explicit ArgsMatcher(InnerMatcher inner_matcher)
      : inner_matcher_(std::move(inner_matcher)) {}
  template &lt;typename ArgsTuple&gt;
  operator Matcher&lt;ArgsTuple&gt;() const {      return MakeMatcher(new ArgsMatcherImpl&lt;ArgsTuple, k...&gt;(inner_matcher_));
  }
 private:
  InnerMatcher inner_matcher_;
};
}  
template &lt;typename Iter&gt;
inline internal::ElementsAreArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
ElementsAreArray(Iter first, Iter last) {
  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
  return internal::ElementsAreArrayMatcher&lt;T&gt;(first, last);
}
template &lt;typename T&gt;
inline internal::ElementsAreArrayMatcher&lt;T&gt; ElementsAreArray(
    const T* pointer, size_t count) {
  return ElementsAreArray(pointer, pointer + count);
}
template &lt;typename T, size_t N&gt;
inline internal::ElementsAreArrayMatcher&lt;T&gt; ElementsAreArray(
    const T (&amp;array)[N]) {
  return ElementsAreArray(array, N);
}
template &lt;typename Container&gt;
inline internal::ElementsAreArrayMatcher&lt;typename Container::value_type&gt;
ElementsAreArray(const Container&amp; container) {
  return ElementsAreArray(container.begin(), container.end());
}
template &lt;typename T&gt;
inline internal::ElementsAreArrayMatcher&lt;T&gt;
ElementsAreArray(::std::initializer_list&lt;T&gt; xs) {
  return ElementsAreArray(xs.begin(), xs.end());
}
template &lt;typename Iter&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
UnorderedElementsAreArray(Iter first, Iter last) {
  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
      internal::UnorderedMatcherRequire::ExactMatch, first, last);
}
template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
UnorderedElementsAreArray(const T* pointer, size_t count) {
  return UnorderedElementsAreArray(pointer, pointer + count);
}
template &lt;typename T, size_t N&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
UnorderedElementsAreArray(const T (&amp;array)[N]) {
  return UnorderedElementsAreArray(array, N);
}
template &lt;typename Container&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename Container::value_type&gt;
UnorderedElementsAreArray(const Container&amp; container) {
  return UnorderedElementsAreArray(container.begin(), container.end());
}
template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
UnorderedElementsAreArray(::std::initializer_list&lt;T&gt; xs) {
  return UnorderedElementsAreArray(xs.begin(), xs.end());
}
const internal::AnythingMatcher _ = {};
template &lt;typename T&gt;
inline Matcher&lt;T&gt; A() {
  return Matcher&lt;T&gt;(new internal::AnyMatcherImpl&lt;T&gt;());
}
template &lt;typename T&gt;
inline Matcher&lt;T&gt; An() { return A&lt;T&gt;(); }
template &lt;typename T, typename M&gt;
Matcher&lt;T&gt; internal::MatcherCastImpl&lt;T, M&gt;::CastImpl(
    const M&amp; value, std::false_type     std::false_type   return Eq(value);
}
inline PolymorphicMatcher&lt;internal::IsNullMatcher &gt; IsNull() {
  return MakePolymorphicMatcher(internal::IsNullMatcher());
}
inline PolymorphicMatcher&lt;internal::NotNullMatcher &gt; NotNull() {
  return MakePolymorphicMatcher(internal::NotNullMatcher());
}
template &lt;typename T&gt;
inline internal::RefMatcher&lt;T&amp;&gt; Ref(T&amp; x) {    return internal::RefMatcher&lt;T&amp;&gt;(x);
}
inline internal::FloatingEqMatcher&lt;double&gt; DoubleEq(double rhs) {
  return internal::FloatingEqMatcher&lt;double&gt;(rhs, false);
}
inline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleEq(double rhs) {
  return internal::FloatingEqMatcher&lt;double&gt;(rhs, true);
}
inline internal::FloatingEqMatcher&lt;double&gt; DoubleNear(
    double rhs, double max_abs_error) {
  return internal::FloatingEqMatcher&lt;double&gt;(rhs, false, max_abs_error);
}
inline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleNear(
    double rhs, double max_abs_error) {
  return internal::FloatingEqMatcher&lt;double&gt;(rhs, true, max_abs_error);
}
inline internal::FloatingEqMatcher&lt;float&gt; FloatEq(float rhs) {
  return internal::FloatingEqMatcher&lt;float&gt;(rhs, false);
}
inline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatEq(float rhs) {
  return internal::FloatingEqMatcher&lt;float&gt;(rhs, true);
}
inline internal::FloatingEqMatcher&lt;float&gt; FloatNear(
    float rhs, float max_abs_error) {
  return internal::FloatingEqMatcher&lt;float&gt;(rhs, false, max_abs_error);
}
<a name="5"></a>inline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatNear(
    float rhs, float max_abs_error) {
  return internal::FloatingEqMatcher&lt;float&gt;(rhs, true, max_abs_error);
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
template &lt;typename InnerMatcher&gt;
inline internal::PointeeMatcher&lt;InnerMatcher&gt; Pointee(
    const InnerMatcher&amp; inner_matcher) {
  return internal::PointeeMatcher&lt;InnerMatcher&gt;(inner_matcher);
}
#if GTEST_HAS_RTTI
template &lt;typename To&gt;
inline PolymorphicMatcher&lt;internal::WhenDynamicCastToMatcher&lt;To&gt; &gt;</b></font>
WhenDynamicCastTo(const Matcher&lt;To&gt;&amp; inner_matcher) {
  return MakePolymorphicMatcher(
      internal::WhenDynamicCastToMatcher&lt;To&gt;(inner_matcher));
}
#endif  
template &lt;typename Class, typename FieldType, typename FieldMatcher&gt;
inline PolymorphicMatcher&lt;
  internal::FieldMatcher&lt;Class, FieldType&gt; &gt; Field(
    FieldType Class::*field, const FieldMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::FieldMatcher&lt;Class, FieldType&gt;(
          field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));
}
template &lt;typename Class, typename FieldType, typename FieldMatcher&gt;
inline PolymorphicMatcher&lt;internal::FieldMatcher&lt;Class, FieldType&gt; &gt; Field(
    const std::string&amp; field_name, FieldType Class::*field,
    const FieldMatcher&amp; matcher) {
  return MakePolymorphicMatcher(internal::FieldMatcher&lt;Class, FieldType&gt;(
      field_name, field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));
}
template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
    Class, PropertyType, PropertyType (Class::*)() const&gt; &gt;
Property(PropertyType (Class::*property)() const,
         const PropertyMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::PropertyMatcher&lt;Class, PropertyType,
                                PropertyType (Class::*)() const&gt;(
          property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
}
template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
    Class, PropertyType, PropertyType (Class::*)() const&gt; &gt;
Property(const std::string&amp; property_name,
         PropertyType (Class::*property)() const,
         const PropertyMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::PropertyMatcher&lt;Class, PropertyType,
                                PropertyType (Class::*)() const&gt;(
          property_name, property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
}
template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
    Class, PropertyType, PropertyType (Class::*)() const &amp;&gt; &gt;
Property(PropertyType (Class::*property)() const &amp;,
         const PropertyMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::PropertyMatcher&lt;Class, PropertyType,
                                PropertyType (Class::*)() const&amp;&gt;(
          property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
}
template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
    Class, PropertyType, PropertyType (Class::*)() const &amp;&gt; &gt;
Property(const std::string&amp; property_name,
         PropertyType (Class::*property)() const &amp;,
         const PropertyMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::PropertyMatcher&lt;Class, PropertyType,
                                PropertyType (Class::*)() const&amp;&gt;(
          property_name, property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
}
template &lt;typename Callable, typename InnerMatcher&gt;
internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt; ResultOf(
    Callable callable, InnerMatcher matcher) {
  return internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt;(
      std::move(callable), std::move(matcher));
}
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrEq(
    const std::string&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::string&gt;(str, true, true));
}
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrNe(
    const std::string&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::string&gt;(str, false, true));
}
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrCaseEq(
    const std::string&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::string&gt;(str, true, false));
}
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrCaseNe(
    const std::string&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::string&gt;(str, false, false));
}
inline PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::string&gt; &gt; HasSubstr(
    const std::string&amp; substring) {
  return MakePolymorphicMatcher(
      internal::HasSubstrMatcher&lt;std::string&gt;(substring));
}
inline PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::string&gt; &gt; StartsWith(
    const std::string&amp; prefix) {
  return MakePolymorphicMatcher(
      internal::StartsWithMatcher&lt;std::string&gt;(prefix));
}
inline PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::string&gt; &gt; EndsWith(
    const std::string&amp; suffix) {
  return MakePolymorphicMatcher(internal::EndsWithMatcher&lt;std::string&gt;(suffix));
}
#if GTEST_HAS_STD_WSTRING
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt; StrEq(
    const std::wstring&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, true));
}
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt; StrNe(
    const std::wstring&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, true));
}
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt;
StrCaseEq(const std::wstring&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, false));
}
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt;
StrCaseNe(const std::wstring&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, false));
}
inline PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::wstring&gt; &gt; HasSubstr(
    const std::wstring&amp; substring) {
  return MakePolymorphicMatcher(
      internal::HasSubstrMatcher&lt;std::wstring&gt;(substring));
}
inline PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::wstring&gt; &gt;
StartsWith(const std::wstring&amp; prefix) {
  return MakePolymorphicMatcher(
      internal::StartsWithMatcher&lt;std::wstring&gt;(prefix));
}
<a name="3"></a>
inline PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::wstring&gt; &gt; EndsWith(
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    const std::wstring&amp; suffix) {
  return MakePolymorphicMatcher(
      internal::EndsWithMatcher&lt;std::wstring&gt;(suffix));
}
#endif  
inline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }
inline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }</b></font>
inline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }
inline internal::Le2Matcher Le() { return internal::Le2Matcher(); }
inline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }
inline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }
inline internal::FloatingEq2Matcher&lt;float&gt; FloatEq() {
  return internal::FloatingEq2Matcher&lt;float&gt;();
}
inline internal::FloatingEq2Matcher&lt;double&gt; DoubleEq() {
  return internal::FloatingEq2Matcher&lt;double&gt;();
}
inline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatEq() {
  return internal::FloatingEq2Matcher&lt;float&gt;(true);
}
inline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleEq() {
  return internal::FloatingEq2Matcher&lt;double&gt;(true);
}
inline internal::FloatingEq2Matcher&lt;float&gt; FloatNear(float max_abs_error) {
  return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error);
}
inline internal::FloatingEq2Matcher&lt;double&gt; DoubleNear(double max_abs_error) {
  return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error);
}
inline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatNear(
    float max_abs_error) {
  return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error, true);
}
inline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleNear(
    double max_abs_error) {
  return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error, true);
}
<a name="0"></a>template &lt;typename InnerMatcher&gt;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>inline internal::NotMatcher&lt;InnerMatcher&gt; Not(InnerMatcher m) {
  return internal::NotMatcher&lt;InnerMatcher&gt;(m);
}
template &lt;typename Predicate&gt;
inline PolymorphicMatcher&lt;internal::TrulyMatcher&lt;Predicate&gt; &gt;
Truly(Predicate pred) {
  return MakePolymorphicMatcher(internal::TrulyMatcher&lt;Predicate&gt;(pred));
}
template &lt;typename SizeMatcher&gt;
inline internal::SizeIsMatcher&lt;SizeMatcher&gt;
SizeIs(const SizeMatcher&amp; size_matcher) {
  return internal::SizeIsMatcher&lt;SizeMatcher&gt;(size_matcher);
}
template &lt;typename DistanceMatcher&gt;</b></font>
inline internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;
BeginEndDistanceIs(const DistanceMatcher&amp; distance_matcher) {
  return internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;(distance_matcher);
}
template &lt;typename Container&gt;
inline PolymorphicMatcher&lt;internal::ContainerEqMatcher&lt;
    typename std::remove_const&lt;Container&gt;::type&gt;&gt;
ContainerEq(const Container&amp; rhs) {
  typedef typename std::remove_const&lt;Container&gt;::type RawContainer;
  return MakePolymorphicMatcher(
      internal::ContainerEqMatcher&lt;RawContainer&gt;(rhs));
}
template &lt;typename Comparator, typename ContainerMatcher&gt;
inline internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;
WhenSortedBy(const Comparator&amp; comparator,
             const ContainerMatcher&amp; container_matcher) {
  return internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;(
      comparator, container_matcher);
}
template &lt;typename ContainerMatcher&gt;
inline internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;
WhenSorted(const ContainerMatcher&amp; container_matcher) {
  return
      internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;(
          internal::LessComparator(), container_matcher);
}
template &lt;typename TupleMatcher, typename Container&gt;
inline internal::PointwiseMatcher&lt;TupleMatcher,
                                  typename std::remove_const&lt;Container&gt;::type&gt;
Pointwise(const TupleMatcher&amp; tuple_matcher, const Container&amp; rhs) {
  typedef typename std::remove_const&lt;Container&gt;::type RawContainer;
  return internal::PointwiseMatcher&lt;TupleMatcher, RawContainer&gt;(
      tuple_matcher, rhs);
}
template &lt;typename TupleMatcher, typename T&gt;
inline internal::PointwiseMatcher&lt;TupleMatcher, std::vector&lt;T&gt; &gt; Pointwise(
    const TupleMatcher&amp; tuple_matcher, std::initializer_list&lt;T&gt; rhs) {
  return Pointwise(tuple_matcher, std::vector&lt;T&gt;(rhs));
}
template &lt;typename Tuple2Matcher, typename RhsContainer&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename internal::BoundSecondMatcher&lt;
        Tuple2Matcher,
        typename internal::StlContainerView&lt;
            typename std::remove_const&lt;RhsContainer&gt;::type&gt;::type::value_type&gt;&gt;
UnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,
                   const RhsContainer&amp; rhs_container) {
  typedef typename std::remove_const&lt;RhsContainer&gt;::type RawRhsContainer;
  typedef typename internal::StlContainerView&lt;RawRhsContainer&gt; RhsView;
  typedef typename RhsView::type RhsStlContainer;
  typedef typename RhsStlContainer::value_type Second;
  const RhsStlContainer&amp; rhs_stl_container =
      RhsView::ConstReference(rhs_container);
  ::std::vector&lt;internal::BoundSecondMatcher&lt;Tuple2Matcher, Second&gt; &gt; matchers;
  for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();
       it != rhs_stl_container.end(); ++it) {
    matchers.push_back(
        internal::MatcherBindSecond(tuple2_matcher, *it));
  }
  return UnorderedElementsAreArray(matchers);
}
template &lt;typename Tuple2Matcher, typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename internal::BoundSecondMatcher&lt;Tuple2Matcher, T&gt; &gt;
UnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,
                   std::initializer_list&lt;T&gt; rhs) {
  return UnorderedPointwise(tuple2_matcher, std::vector&lt;T&gt;(rhs));
}
template &lt;typename M&gt;
inline internal::ContainsMatcher&lt;M&gt; Contains(M matcher) {
  return internal::ContainsMatcher&lt;M&gt;(matcher);
}
template &lt;typename Iter&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
IsSupersetOf(Iter first, Iter last) {
  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
      internal::UnorderedMatcherRequire::Superset, first, last);
}
template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
    const T* pointer, size_t count) {
  return IsSupersetOf(pointer, pointer + count);
}
template &lt;typename T, size_t N&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
    const T (&amp;array)[N]) {
  return IsSupersetOf(array, N);
}
template &lt;typename Container&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename Container::value_type&gt;
IsSupersetOf(const Container&amp; container) {
  return IsSupersetOf(container.begin(), container.end());
}
template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
    ::std::initializer_list&lt;T&gt; xs) {
  return IsSupersetOf(xs.begin(), xs.end());
}
template &lt;typename Iter&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
IsSubsetOf(Iter first, Iter last) {
  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
      internal::UnorderedMatcherRequire::Subset, first, last);
}
template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
    const T* pointer, size_t count) {
  return IsSubsetOf(pointer, pointer + count);
}
template &lt;typename T, size_t N&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
    const T (&amp;array)[N]) {
  return IsSubsetOf(array, N);
}
template &lt;typename Container&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename Container::value_type&gt;
IsSubsetOf(const Container&amp; container) {
  return IsSubsetOf(container.begin(), container.end());
}
template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
    ::std::initializer_list&lt;T&gt; xs) {
  return IsSubsetOf(xs.begin(), xs.end());
}
template &lt;typename M&gt;
inline internal::EachMatcher&lt;M&gt; Each(M matcher) {
  return internal::EachMatcher&lt;M&gt;(matcher);
}
template &lt;typename M&gt;
inline internal::KeyMatcher&lt;M&gt; Key(M inner_matcher) {
  return internal::KeyMatcher&lt;M&gt;(inner_matcher);
}
template &lt;typename FirstMatcher, typename SecondMatcher&gt;
inline internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;
Pair(FirstMatcher first_matcher, SecondMatcher second_matcher) {
  return internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;(
      first_matcher, second_matcher);
}
template &lt;typename M&gt;
inline internal::MatcherAsPredicate&lt;M&gt; Matches(M matcher) {
  return internal::MatcherAsPredicate&lt;M&gt;(matcher);
}
template &lt;typename T, typename M&gt;
inline bool Value(const T&amp; value, M matcher) {
  return testing::Matches(matcher)(value);
}
template &lt;typename T, typename M&gt;
inline bool ExplainMatchResult(
    M matcher, const T&amp; value, MatchResultListener* listener) {
  return SafeMatcherCast&lt;const T&amp;&gt;(matcher).MatchAndExplain(value, listener);
}
template &lt;typename T, typename M&gt;
std::string DescribeMatcher(const M&amp; matcher, bool negation = false) {
  ::std::stringstream ss;
  Matcher&lt;T&gt; monomorphic_matcher = SafeMatcherCast&lt;T&gt;(matcher);
  if (negation) {
    monomorphic_matcher.DescribeNegationTo(&amp;ss);
  } else {
    monomorphic_matcher.DescribeTo(&amp;ss);
  }
  return ss.str();
}
template &lt;typename... Args&gt;
internal::ElementsAreMatcher&lt;
    std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;
ElementsAre(const Args&amp;... matchers) {
  return internal::ElementsAreMatcher&lt;
      std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(
      std::make_tuple(matchers...));
}
template &lt;typename... Args&gt;
internal::UnorderedElementsAreMatcher&lt;
    std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;
UnorderedElementsAre(const Args&amp;... matchers) {
  return internal::UnorderedElementsAreMatcher&lt;
      std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(
      std::make_tuple(matchers...));
}
template &lt;typename... Args&gt;
internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AllOf(
    const Args&amp;... matchers) {
  return internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(
      matchers...);
}
template &lt;typename... Args&gt;
internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AnyOf(
    const Args&amp;... matchers) {
  return internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(
      matchers...);
}
template &lt;typename Iter&gt;
inline internal::AnyOfArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
AnyOfArray(Iter first, Iter last) {
  return internal::AnyOfArrayMatcher&lt;
      typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;(first, last);
}
template &lt;typename Iter&gt;
inline internal::AllOfArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
AllOfArray(Iter first, Iter last) {
  return internal::AllOfArrayMatcher&lt;
      typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;(first, last);
}
template &lt;typename T&gt;
inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(const T* ptr, size_t count) {
  return AnyOfArray(ptr, ptr + count);
}
template &lt;typename T&gt;
inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(const T* ptr, size_t count) {
  return AllOfArray(ptr, ptr + count);
}
template &lt;typename T, size_t N&gt;
inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(const T (&amp;array)[N]) {
  return AnyOfArray(array, N);
}
template &lt;typename T, size_t N&gt;
inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(const T (&amp;array)[N]) {
  return AllOfArray(array, N);
}
template &lt;typename Container&gt;
inline internal::AnyOfArrayMatcher&lt;typename Container::value_type&gt; AnyOfArray(
    const Container&amp; container) {
  return AnyOfArray(container.begin(), container.end());
}
template &lt;typename Container&gt;
inline internal::AllOfArrayMatcher&lt;typename Container::value_type&gt; AllOfArray(
    const Container&amp; container) {
  return AllOfArray(container.begin(), container.end());
}
template &lt;typename T&gt;
inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(
    ::std::initializer_list&lt;T&gt; xs) {
  return AnyOfArray(xs.begin(), xs.end());
}
template &lt;typename T&gt;
inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(
    ::std::initializer_list&lt;T&gt; xs) {
  return AllOfArray(xs.begin(), xs.end());
}
template &lt;size_t... k, typename InnerMatcher&gt;
internal::ArgsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type, k...&gt; Args(
    InnerMatcher&amp;&amp; matcher) {
  return internal::ArgsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type, k...&gt;(
      std::forward&lt;InnerMatcher&gt;(matcher));
}
template &lt;typename InnerMatcher&gt;
inline InnerMatcher AllArgs(const InnerMatcher&amp; matcher) { return matcher; }
template &lt;typename ValueMatcher&gt;
inline internal::OptionalMatcher&lt;ValueMatcher&gt; Optional(
    const ValueMatcher&amp; value_matcher) {
  return internal::OptionalMatcher&lt;ValueMatcher&gt;(value_matcher);
}
template &lt;typename T&gt;
PolymorphicMatcher&lt;internal::any_cast_matcher::AnyCastMatcher&lt;T&gt; &gt; AnyWith(
    const Matcher&lt;const T&amp;&gt;&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::any_cast_matcher::AnyCastMatcher&lt;T&gt;(matcher));
}
template &lt;typename T&gt;
PolymorphicMatcher&lt;internal::variant_matcher::VariantMatcher&lt;T&gt; &gt; VariantWith(
    const Matcher&lt;const T&amp;&gt;&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::variant_matcher::VariantMatcher&lt;T&gt;(matcher));
}
#define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\
    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
#define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\
    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
}  
GTEST_DISABLE_MSC_WARNINGS_POP_()  
#include "gmock/internal/custom/gmock-matchers.h"
#endif  </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
