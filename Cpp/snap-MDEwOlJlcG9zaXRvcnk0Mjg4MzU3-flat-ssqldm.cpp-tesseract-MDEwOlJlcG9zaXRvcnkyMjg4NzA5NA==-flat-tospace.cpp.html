
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.995245641838352%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssqldm.cpp</h3>
            <pre><code>1  #include "sqldm.h"
2  void TSqlDmChDef::SetUcCh(const TStr& Str){
3    for (int CC=1; CC<Str.Len(); CC++){
4      uchar Ch=Str[CC];
5      UcChV[Ch]=Str[0];
6    }
7  }
8  void TSqlDmChDef::SetChTy(const TSqlDmChTy& ChTy, const TStr& Str){
9    for (int CC=0; CC<Str.Len(); CC++){
10      uchar Ch=Str[CC];
11      ChTyV[Ch]=ChTy;
12    }
13  }
14  TSqlDmChDef::TSqlDmChDef():
15    ChTyV(TUCh::Vals), UcChV(TUCh::Vals){
16    ChTyV.PutAll(TInt(dmctUndef));
17    SetChTy(dmctLetter, "ABCDEFGHIJKLMNOPQRSTUVWXYZ_");
18    SetChTy(dmctLetter, "abcdefghijklmnopqrstuvwxyz");
19    SetChTy(dmctDigit, "0123456789");
20    SetChTy(dmctSpace, " \t\r\n");
21    SetChTy(dmctEof, TCh::EofCh);
22    for (int Ch=0; Ch<=TUCh::Mx; Ch++){UcChV[Ch]=uchar(Ch);}
23    SetUcCh("Aa"); SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("Dd"); SetUcCh("Ee");
24    SetUcCh("Ff"); SetUcCh("Gg"); SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("Jj");
25    SetUcCh("Kk"); SetUcCh("Ll"); SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("Oo");
26    SetUcCh("Pp"); SetUcCh("Qq"); SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("Tt");
27    SetUcCh("Uu"); SetUcCh("Vv"); SetUcCh("Ww"); SetUcCh("Xx"); SetUcCh("Yy");
28    SetUcCh("Zz");
29  }
30  TStrIntH TSqlDmLxSymStr::RwStrToSymH;
31  void TSqlDmLxSymStr::InitRwStrToSymH(){
32    AddRw("create", dsyRw_Create);
33    AddRw("insert", dsyRw_Insert);
34    AddRw("select", dsyRw_Select);
35    AddRw("delete", dsyRw_Delete);
36    AddRw("drop", dsyRw_Drop);
37    AddRw("rename", dsyRw_Rename);
38    AddRw("mining", dsyRw_Mining);
39    AddRw("model", dsyRw_Model);
40    AddRw("using", dsyRw_Using);
41    AddRw("into", dsyRw_Into);
42    AddRw("column_values", dsyRw_ColumnValues);
43    AddRw("content", dsyRw_Content);
44    AddRw("from", dsyRw_From);
45    AddRw("predict", dsyRw_Predict);
46    AddRw("prediction", dsyRw_Prediction);
47    AddRw("join", dsyRw_Join);
48    AddRw("on", dsyRw_On);
49    AddRw("natural", dsyRw_Natural);
50    AddRw("where", dsyRw_Where);
51    AddRw("flattened", dsyRw_Flattened);
52    AddRw("distinct", dsyRw_Distinct);
53    AddRw("union", dsyRw_Union);
54    AddRw("pmml", dsyRw_Pmml);
55    AddRw("or", dsyRw_Or);
56    AddRw("and", dsyRw_And);
57    AddRw("not", dsyRw_Not);
58    AddRw("long", dsyRw_Long);
59    AddRw("boolean", dsyRw_Boolean);
60    AddRw("text", dsyRw_Text);
61    AddRw("nvarchar", dsyRw_Text);
62    AddRw("ntext", dsyRw_Text);
63    AddRw("double", dsyRw_Double);
64    AddRw("date", dsyRw_Date);
65    AddRw("table", dsyRw_Table);
66    AddRw("normal", dsyRw_Normal);
67    AddRw("uniform", dsyRw_Uniform);
68    AddRw("model_existence_only", dsyRw_Binary);
69    AddRw("null", dsyRw_Null);
70    AddRw("discrete", dsyRw_Discrete);
71    AddRw("continuous", dsyRw_Continuous);
72    AddRw("ordered", dsyRw_Ordered);
73    AddRw("sequence_time", dsyRw_SeqTime);
74    AddRw("cyclical", dsyRw_Cyclical);
75    AddRw("discretized", dsyRw_Discretized);
76    AddRw("automatic", dsyRw_Automatic);
77    AddRw("eqal_areas", dsyRw_EqualAreas);
78    AddRw("tresholds", dsyRw_Thresholds);
79    AddRw("clusters", dsyRw_Clusters);
80    AddRw("key", dsyRw_Key);
81    AddRw("probability", dsyRw_Probability);
82    AddRw("variance", dsyRw_Variance);
83    AddRw("stdev", dsyRw_StDev);
84    AddRw("stddev", dsyRw_StDev);
85    AddRw("probability_variance", dsyRw_ProbabilityVariance);
86    AddRw("probability_stdev", dsyRw_ProbabilityStDev);
87    AddRw("probability_stddev", dsyRw_ProbabilityStDev);
88    AddRw("support", dsyRw_Support);
89    AddRw("skip", dsyRw_Skip);
90    AddRw("predictstdev", dsyRw_PredictStDev);
91    AddRw("predictstddev", dsyRw_PredictStDev);
92    AddRw("predictvariance", dsyRw_PredictVariance);
93    AddRw("predictsupport", dsyRw_PredictSupport);
94    AddRw("predictprobability", dsyRw_PredictProbability);
95    AddRw("predictadjustedprobability", dsyRw_PredictAdjustedProbability);
96    AddRw("predictprobabilitystdev", dsyRw_PredictProbabilityStDev);
97    AddRw("predictprobabilitystddev", dsyRw_PredictProbabilityStDev);
98    AddRw("predictprobabilityvariance", dsyRw_PredictProbabilityVariance);
99    AddRw("predicthistogram", dsyRw_PredictHistogram);
100    AddRw("$support", dsyRw_HSupport);
101    AddRw("$variance", dsyRw_HVariance);
102    AddRw("$stdev", dsyRw_HStDev);
103    AddRw("$probability", dsyRw_HProbability);
104    AddRw("$adjustedprobability", dsyRw_HAdjustedProbability);
105    AddRw("$probabilityvariance", dsyRw_HProbabilityVariance);
106    AddRw("$probabilitystdev", dsyRw_HProbabilityStDev);
107    AddRw("$distance", dsyRw_HDistance);
108    AddRw("predict_only", dsyRw_PredictOnly);
109    AddRw("related", dsyRw_Related);
110    AddRw("to", dsyRw_To);
111    AddRw("of", dsyRw_Of);
112    AddRw("openrowset", dsyRw_OpenQuery);
113    AddRw("cluster", dsyRw_Cluster);
114    AddRw("clusterdistance", dsyRw_ClusterDistance);
115    AddRw("clusterprobability", dsyRw_ClusterProbability);
116    AddRw("as", dsyRw_As);
117    AddRw("shape", dsyRw_Shape);
118    AddRw("append", dsyRw_Append);
119    AddRw("relate", dsyRw_Relate);
120    AddRw("exclude_null", dsyRw_ExcludeNull);
121    AddRw("include_null", dsyRw_IncludeNull);
122    AddRw("exclusive", dsyRw_Exclusive);
123    AddRw("inclusive", dsyRw_Inclusive);
124    AddRw("input_only", dsyRw_InputOnly);
125    AddRw("include_statistics", dsyRw_IncludeStatistics);
126    AddRw("topcount", dsyRw_TopCount);
127    AddRw("topsum", dsyRw_TopSum);
128    AddRw("toppercent", dsyRw_TopPercent);
129    AddRw("bottomcount", dsyRw_BottomCount);
130    AddRw("bottomsum", dsyRw_BottomSum);
131    AddRw("bottompercent", dsyRw_BottomPercent);
132    AddRw("rangemin", dsyRw_RangeMin);
133    AddRw("rangemid", dsyRw_RangeMid);
134    AddRw("rangemax", dsyRw_RangeMax);
135  }
136  TSqlDmLxSym TSqlDmLxSymStr::GetRwSym(const TStr& RwStr){
137    if (RwStrToSymH.Empty()){InitRwStrToSymH();}
138    TInt SymInt;
139    if (RwStrToSymH.IsKeyGetDat(RwStr, SymInt)){
140      TSqlDmLxSym Sym=TSqlDmLxSym(SymInt.Val);
141      return Sym;
142    } else {
143      return dsyUndef;
144    }
145  }
146  TStr TSqlDmLxSymStr::GetRwStr(const TSqlDmLxSym& Sym){
147    for (int RwN=0; RwN<RwStrToSymH.Len(); RwN++){
148      TSqlDmLxSym RwSym=TSqlDmLxSym(int(RwStrToSymH[RwN]));
149      if (Sym==RwSym){
150        TStr RwStr=RwStrToSymH.GetKey(RwN);
151        return RwStr;
152      }
153    }
154    Fail; return TStr::NullStr;
155  }
156  TStr TSqlDmLxSymStr::GetSymStr(const TSqlDmLxSym& Sym){
157    switch (Sym){
158      case dsyUndef: return "<Undef>";
159      case dsyEof: return "<Eof>";
160      case dsyName: return "<Name>";
161      case dsyStr: return "<String>";
162      case dsyInt: return "<Int>";
163      case dsyFlt: return "<Float>";
164      case dsyComma: return ",";
165      case dsyPeriod: return ".";
166      case dsySemicolon: return ";";
167      case dsyLss: return "<";
168      case dsyLEq: return "<=";
169      case dsyEq: return "=";
170      case dsyNEq: return "<>";
171      case dsyGtr: return ">";
172      case dsyGEq: return ">=";
173      case dsyPlus: return "+";
174      case dsyMinus: return "-";
175      case dsyAsterisk: return "*";
176      case dsySlash: return "/";
177      case dsyLParen: return "(";
178      case dsyRParen: return ")";
179      case dsyLBrace: return "{";
180      case dsyRBrace: return "}";
181      default: return GetRwStr(Sym);
182    }
183  }
184  TSqlDmLxSymSt::TSqlDmLxSymSt():
185    Sym(dsyUndef), Str(), UcStr(), Int(0), Flt(0),
186    SymLnN(-1), SymLnChN(-1), SymChN(-1){}
187  TSqlDmLxSymSt::TSqlDmLxSymSt(const TSqlDmLxSymSt& SymSt):
188    Sym(SymSt.Sym),
189    Str(SymSt.Str), UcStr(SymSt.UcStr), Int(SymSt.Int), Flt(SymSt.Flt),
190    SymLnN(SymSt.SymLnN), SymLnChN(SymSt.SymLnChN), SymChN(SymSt.SymChN){Fail;}
191  TSqlDmLxSymSt::TSqlDmLxSymSt(TSqlDmLx& Lx):
192    Sym(Lx.Sym), Str(Lx.Str), UcStr(Lx.UcStr), Int(Lx.Int), Flt(Lx.Flt),
193    SymLnN(Lx.SymLnN), SymLnChN(Lx.SymLnChN), SymChN(Lx.SymChN){}
194  void TSqlDmLxSymSt::Restore(TSqlDmLx& Lx){
195    Lx.Sym=Sym; Lx.Str=Str; Lx.UcStr=UcStr; Lx.Int=Int; Lx.Flt=Flt;
196    Lx.SymLnN=SymLnN; Lx.SymLnChN=SymLnChN; Lx.SymChN=Lx.SymChN;}
197  TSqlDmChDef TSqlDmLx::ChDef;
198  uchar TSqlDmLx::GetCh(){
199    IAssert(Ch!=TCh::EofCh);
200    PrevCh=Ch;
201    if (ChStack.Empty()){Ch=(SIn->Eof()) ? TCh::EofCh : SIn->GetCh();}
202    else {Ch=ChStack.Pop();}
203    ChN++; if (Ch==TCh::LfCh){LnN++; LnChN=0;} else {LnChN++;}
204    printf("%c", Ch);
205    return Ch;
206  }
207  TSqlDmLx::TSqlDmLx(const PSIn& _SIn):
208    SIn(_SIn),
209    ChStack(), PrevCh(' '), Ch(' '),
210    LnN(0), LnChN(0-1), ChN(0-1),
211    PrevSymStStack(),
212    Sym(dsyUndef), Str(), UcStr(), Int(0), Flt(0),
213    SymLnN(-1), SymLnChN(-1), SymChN(-1){
214  }
215  TStr TSqlDmLx::GetFPosStr() const {
216    TChA ChA;
217    ChA+="File:"; ChA+=SIn->GetSNm();
218    ChA+=" Line:"; ChA+=TInt::GetStr(LnN+1);
219    ChA+=" Char:"; ChA+=TInt::GetStr(LnChN);
220    return ChA;
221  }
222  TSqlDmLxSym TSqlDmLx::GetSym(const TFSet& Expect){
223    if (!PrevSymStStack.Empty()){
224      PrevSymStStack.Top().Restore(*this); PrevSymStStack.Pop();
225    } else {
226      while (ChDef.IsSpace(Ch)){GetCh();}
227      SymLnN=LnN; SymLnChN=LnChN; SymChN=ChN;
228      if (ChDef.IsAlpha(Ch)){ 
229        Str.Clr(); UcStr.Clr();
230        do {Str.AddCh(Ch); UcStr.AddCh(ChDef.GetUc(Ch));}
231        while (ChDef.IsAlNum(GetCh()));
232        Sym=TSqlDmLxSymStr::GetRwSym(UcStr);
233        if (Sym==dsyUndef){Sym=dsyName;}
234      } else
235      if (Ch=='['){ 
236        Str.Clr(); UcStr.Clr(); GetCh();
237        while ((Ch!=']')&&(Ch!=TCh::EofCh)){
238          Str.AddCh(Ch); UcStr.AddCh(ChDef.GetUc(Ch)); GetCh();}
239        if (Ch==TCh::EofCh){Sym=dsyUndef;}
240        else {Sym=dsyName; GetCh();}
241      } else
242      if (Ch=='\''){ 
243        Str.Clr(); UcStr.Clr(); GetCh();
244        while ((Ch!='\'')&&(Ch!=TCh::EofCh)){
245          Str.AddCh(Ch); UcStr.AddCh(ChDef.GetUc(Ch)); GetCh();}
246        if (Ch==TCh::EofCh){Sym=dsyUndef;}
247        else {Sym=dsyStr; GetCh();}
248      } else
249      if (ChDef.IsNum(Ch)){ 
250        Str.Clr();
251        do {Str.AddCh(Ch);} while (ChDef.IsNum(GetCh()));
252        if (Ch=='.'){
253          Str.AddCh(Ch);
254          while (ChDef.IsNum(GetCh())){Str.AddCh(Ch);}
255        }
256        if ((Ch=='e')||(Ch=='E')){
257          Str.AddCh(Ch); GetCh();
258          if ((Ch=='+')||(Ch=='-')){Str.AddCh(Ch); GetCh();}
259          while (ChDef.IsNum(Ch)){Str.AddCh(Ch); GetCh();}
260        }
<span onclick='openModal()' class='match'>261        UcStr=Str;
262        if (Expect.In(syFlt)){Sym=dsyFlt; Flt=atof(Str.CStr());}
263        else {Sym=dsyInt; Int=atoi(Str.CStr());}
</span>264      } else
265      if (Ch=='/'){ 
266        GetCh();
267        if (Ch=='/'){
268          do {GetCh();} while (!ChDef.IsEof(Ch));
269          if (Ch==TCh::CrCh){
270            if (GetCh()==TCh::LfCh){GetCh();}
271          } else
272          if (Ch==TCh::LfCh){
273            if (GetCh()==TCh::CrCh){GetCh();}
274          }
275          GetSym(Expect);
276        } else
277        if (Ch=='*'){
278          do {while (GetCh()!='*'){}} while (GetCh()!='/');
279          GetCh(); GetSym(Expect);
280        } else {
281          Sym=dsySlash;
282        }
283      } else
284      if (Ch=='-'){ 
285        GetCh();
286        if (Ch=='-'){
287          do {GetCh();} while (!ChDef.IsEof(Ch));
288          if (Ch==TCh::CrCh){
289            if (GetCh()==TCh::LfCh){GetCh();}
290          } else
291          if (Ch==TCh::LfCh){
292            if (GetCh()==TCh::CrCh){GetCh();}
293          }
294          GetSym(Expect);
295        } else {
296          Sym=dsyMinus;
297        }
298      } else
299      if (Ch==TCh::EofCh){ 
300        Sym=dsyEof;
301      } else { 
302        switch (Ch){
303          case ',': Sym=dsyComma; GetCh(); break;
304          case '.':
305            if (ChDef.IsNum(GetCh())){
306              PutCh('.'); PutCh('0'); return GetSym(Expect);}
307            else {Sym=dsyPeriod;}
308            break;
309          case ';': Sym=dsySemicolon; GetCh(); break;
310          case '<':
311            GetCh();
312            if (Ch=='='){Sym=dsyLEq; GetCh();}
313            else if (Ch=='>'){Sym=dsyNEq; GetCh();}
314            else {Sym=dsyLss;} break;
315          case '=': Sym=dsyEq; GetCh(); break;
316          case '>':
317            if (GetCh()=='='){Sym=dsyGEq; GetCh();}
318            else {Sym=dsyGtr;} break;
319          case '+': Sym=dsyPlus; GetCh(); break;
320          case '-': Sym=dsyMinus; GetCh(); break;
321          case '*': Sym=dsyAsterisk; GetCh(); break;
322          case '/': Sym=dsySlash; GetCh(); break;
323          case '(': Sym=dsyLParen; GetCh(); break;
324          case ')': Sym=dsyRParen; GetCh(); break;
325          case '{': Sym=dsyLBrace; GetCh(); break;
326          case '}': Sym=dsyRBrace; GetCh(); break;
327          default: Sym=dsyUndef; GetCh(); break;
328        }
329      }
330    }
331    if ((!Expect.In(Sym))&&(!Expect.Empty())){
332     TStr MsgStr=
333      TStr("Unexpected symbol (")+Str+") ["+GetFPosStr()+"]";
334     throw TExcept::Throw(MsgStr);
335    }
336    return Sym;
337  }
338  PSqlDmStat_Delete TSqlDmStat_Delete::LoadTxt(TSqlDmLx& Lx, const TFSet& Expect){
339    PSqlDmStat_Delete Stat=TSqlDmStat_Delete::New();
340    IAssert(Lx.Sym==dsyRw_Delete);
341    Lx.GetSym(dsyAsterisk);
342    Lx.GetSym(dsyRw_From);
343    Stat->MdNm=Lx.GetName();
344    Lx.GetSym(TFSet(Expect)|dsyPeriod);
345    if (Lx.Sym==dsyPeriod){
346      Lx.GetSym(dsyRw_Content); Stat->ContentP=false;
347      Lx.GetSym(Expect);
348    } else {
349      Stat->ContentP=false;
350    }
351    return Stat;
352  }
353  PSqlDmStat_Drop TSqlDmStat_Drop::LoadTxt(TSqlDmLx& Lx, const TFSet& Expect){
354    PSqlDmStat_Drop Stat=TSqlDmStat_Drop::New();
355    IAssert(Lx.Sym==dsyRw_Drop);
356    Lx.GetSym(dsyRw_Mining);
357    Lx.GetSym(dsyRw_Model);
358    Stat->MdNm=Lx.GetName();
359    Lx.GetSym(Expect);
360    return Stat;
361  }
362  PSqlDmStat_Rename TSqlDmStat_Rename::LoadTxt(TSqlDmLx& Lx, const TFSet& Expect){
363    PSqlDmStat_Rename Stat=TSqlDmStat_Rename::New();
364    IAssert(Lx.Sym==dsyRw_Rename);
365    Lx.GetSym(dsyRw_Mining);
366    Lx.GetSym(dsyRw_Model);
367    Stat->SrcMdNm=Lx.GetName();
368    Lx.GetSym(dsyRw_To);
369    Stat->DstMdNm=Lx.GetName();
370    Lx.GetSym(Expect);
371    return Stat;
372  }
373  const TFSet TSqlDmStat::StatExpect(
374   dsyRw_Create, dsyRw_Insert, dsyRw_Select,
375   dsyRw_Delete, dsyRw_Drop, dsyRw_Rename);
376  PSqlDmStat TSqlDmStat::LoadTxt(TSqlDmLx& Lx, const TFSet& Expect){
377    PSqlDmStat Stat=TSqlDmStat::New();
378    switch (Lx.Sym){
379      case dsyRw_Create: break;
380      case dsyRw_Insert: break;
381      case dsyRw_Select: break;
382      case dsyRw_Delete:
383        Stat->Type=dstDelete;
384        Stat->Delete=TSqlDmStat_Delete::LoadTxt(Lx, Expect);
385        break;
386      case dsyRw_Drop:
387        Stat->Type=dstDrop;
388        Stat->Drop=TSqlDmStat_Drop::LoadTxt(Lx, Expect);
389        break;
390      case dsyRw_Rename:
391        Stat->Type=dstRename;
392        Stat->Rename=TSqlDmStat_Rename::LoadTxt(Lx, Expect);
393        break;
394      default: Fail;
395    }
396    return Stat;
397  }
398  PSqlDmProg TSqlDmProg::LoadTxt(PSIn& SIn){
399    PSqlDmProg Prog=TSqlDmProg::New();
400    TSqlDmLx Lx(SIn);
401    Lx.GetSym(TFSet(TSqlDmStat::StatExpect)|dsyEof);
402    while (Lx.Sym!=dsyEof){
403      PSqlDmStat Stat=TSqlDmStat::LoadTxt(Lx, TFSet(dsySemicolon, dsyEof));
404      Prog->StatV.Add(Stat);
405      Lx.GetSym(TFSet(TSqlDmStat::StatExpect)|dsyEof);
406    }
407    return Prog;
408  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tospace.cpp</h3>
            <pre><code>1  #include "drawtord.h"
2  #include "statistc.h"
3  #include "textord.h"
4  #include "tovars.h"
5  #ifdef HAVE_CONFIG_H
6  #  include "config_auto.h"
7  #endif
8  #include <algorithm>
9  #include <cmath>
10  #include <memory>
11  #define MAXSPACING 128 &bsol;*max expected spacing in pix */
12  namespace tesseract {
13  void Textord::to_spacing(ICOORD page_tr,       
14                           TO_BLOCK_LIST *blocks 
15  ) {
16    TO_BLOCK_IT block_it; 
17    TO_BLOCK *block;      
18    TO_ROW *row;          
19    int block_index;      
20    int row_index;        
21    int16_t block_space_gap_width;
22    int16_t block_non_space_gap_width;
23    bool old_text_ord_proportional; 
24    block_it.set_to_list(blocks);
25    block_index = 1;
26    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
27      block = block_it.data();
28      std::unique_ptr<GAPMAP> gapmap(new GAPMAP(block)); 
29      block_spacing_stats(block, gapmap.get(), old_text_ord_proportional, block_space_gap_width,
30                          block_non_space_gap_width);
31      if (tosp_old_to_method && tosp_old_to_constrain_sp_kn &&
32          block_non_space_gap_width > block_space_gap_width / 3) {
33        block_non_space_gap_width = block_space_gap_width / 3;
34      }
35      TO_ROW_IT row_it(block->get_rows());
36      row_index = 1;
37      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
38        row = row_it.data();
39        if ((row->pitch_decision == PITCH_DEF_PROP) || (row->pitch_decision == PITCH_CORR_PROP)) {
40          if ((tosp_debug_level > 0) && !old_text_ord_proportional) {
41            tprintf("Block %d Row %d: Now Proportional\n", block_index, row_index);
42          }
43          row_spacing_stats(row, gapmap.get(), block_index, row_index, block_space_gap_width,
44                            block_non_space_gap_width);
45        } else {
46          if ((tosp_debug_level > 0) && old_text_ord_proportional) {
47            tprintf("Block %d Row %d: Now Fixed Pitch Decision:%d fp flag:%f\n", block_index,
48                    row_index, row->pitch_decision, row->fixed_pitch);
49          }
50        }
51  #ifndef GRAPHICS_DISABLED
52        if (textord_show_initial_words) {
53          plot_word_decisions(to_win, static_cast<int16_t>(row->fixed_pitch), row);
54        }
55  #endif
56        row_index++;
57      }
58      block_index++;
59    }
60  }
61  void Textord::block_spacing_stats(TO_BLOCK *block, GAPMAP *gapmap, bool &old_text_ord_proportional,
62                                    int16_t &block_space_gap_width,    
63                                    int16_t &block_non_space_gap_width 
64  ) {
65    TO_ROW *row;         
66    BLOBNBOX_IT blob_it; 
67    STATS centre_to_centre_stats(0, MAXSPACING - 1);
68    STATS all_gap_stats(0, MAXSPACING - 1);
69    STATS space_gap_stats(0, MAXSPACING - 1);
70    int16_t minwidth = MAXSPACING; 
71    TBOX blob_box;
72    TBOX prev_blob_box;
73    int16_t centre_to_centre;
74    int16_t gap_width;
75    float real_space_threshold;
76    float iqr_centre_to_centre; 
77    float iqr_all_gap_stats;    
78    int32_t end_of_row;
79    int32_t row_length;
80    TO_ROW_IT row_it(block->get_rows());
81    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
82      row = row_it.data();
83      if (!row->blob_list()->empty() &&
84          (!tosp_only_use_prop_rows || (row->pitch_decision == PITCH_DEF_PROP) ||
85           (row->pitch_decision == PITCH_CORR_PROP))) {
86        blob_it.set_to_list(row->blob_list());
87        blob_it.mark_cycle_pt();
88        end_of_row = blob_it.data_relative(-1)->bounding_box().right();
89        if (tosp_use_pre_chopping) {
90          blob_box = box_next_pre_chopped(&blob_it);
91        } else if (tosp_stats_use_xht_gaps) {
92          blob_box = reduced_box_next(row, &blob_it);
93        } else {
94          blob_box = box_next(&blob_it);
95        }
96        row_length = end_of_row - blob_box.left();
97        if (blob_box.width() < minwidth) {
98          minwidth = blob_box.width();
99        }
100        prev_blob_box = blob_box;
101        while (!blob_it.cycled_list()) {
102          if (tosp_use_pre_chopping) {
103            blob_box = box_next_pre_chopped(&blob_it);
104          } else if (tosp_stats_use_xht_gaps) {
105            blob_box = reduced_box_next(row, &blob_it);
106          } else {
107            blob_box = box_next(&blob_it);
108          }
109          if (blob_box.width() < minwidth) {
110            minwidth = blob_box.width();
111          }
112          int16_t left = prev_blob_box.right();
113          int16_t right = blob_box.left();
114          gap_width = right - left;
115          if (!ignore_big_gap(row, row_length, gapmap, left, right)) {
116            all_gap_stats.add(gap_width, 1);
117            centre_to_centre = (right + blob_box.right() - (prev_blob_box.left() + left)) / 2;
118            centre_to_centre_stats.add(centre_to_centre, 1);
119          }
120          prev_blob_box = blob_box;
121        }
122      }
123    }
124    if (all_gap_stats.get_total() <= 1) {
125      block_non_space_gap_width = minwidth;
126      block_space_gap_width = -1; 
127      old_text_ord_proportional = true;
128    } else {
129      iqr_centre_to_centre = centre_to_centre_stats.ile(0.75) - centre_to_centre_stats.ile(0.25);
130      iqr_all_gap_stats = all_gap_stats.ile(0.75) - all_gap_stats.ile(0.25);
131      old_text_ord_proportional = iqr_centre_to_centre * 2 > iqr_all_gap_stats;
132      block_non_space_gap_width = static_cast<int16_t>(floor(all_gap_stats.median()));
133      row_it.set_to_list(block->get_rows());
134      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
135        row = row_it.data();
136        if (!row->blob_list()->empty() &&
137            (!tosp_only_use_prop_rows || (row->pitch_decision == PITCH_DEF_PROP) ||
138             (row->pitch_decision == PITCH_CORR_PROP))) {
139          real_space_threshold = std::max(tosp_init_guess_kn_mult * block_non_space_gap_width,
140                                          tosp_init_guess_xht_mult * row->xheight);
141          blob_it.set_to_list(row->blob_list());
142          blob_it.mark_cycle_pt();
143          end_of_row = blob_it.data_relative(-1)->bounding_box().right();
144          if (tosp_use_pre_chopping) {
145            blob_box = box_next_pre_chopped(&blob_it);
146          } else if (tosp_stats_use_xht_gaps) {
147            blob_box = reduced_box_next(row, &blob_it);
148          } else {
149            blob_box = box_next(&blob_it);
150          }
151          row_length = blob_box.left() - end_of_row;
152          prev_blob_box = blob_box;
153          while (!blob_it.cycled_list()) {
154            if (tosp_use_pre_chopping) {
155              blob_box = box_next_pre_chopped(&blob_it);
156            } else if (tosp_stats_use_xht_gaps) {
157              blob_box = reduced_box_next(row, &blob_it);
158            } else {
159              blob_box = box_next(&blob_it);
160            }
161            int16_t left = prev_blob_box.right();
162            int16_t right = blob_box.left();
163            gap_width = right - left;
164            if ((gap_width > real_space_threshold) &&
165                !ignore_big_gap(row, row_length, gapmap, left, right)) {
166              if (!tosp_block_use_cert_spaces ||
167                  (gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
168                  ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
169                   (!tosp_narrow_blobs_not_cert ||
170                    (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
171                  (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
172                space_gap_stats.add(gap_width, 1);
173              }
174            }
175            prev_blob_box = blob_box;
176          }
177        }
178      }
179      if (space_gap_stats.get_total() <= 2) {
180        block_space_gap_width = -1; 
181      } else {
182        block_space_gap_width = std::max(static_cast<int16_t>(floor(space_gap_stats.median())),
183                                         static_cast<int16_t>(3 * block_non_space_gap_width));
184      }
185    }
186  }
187  void Textord::row_spacing_stats(TO_ROW *row, GAPMAP *gapmap, int16_t block_idx, int16_t row_idx,
188                                  int16_t block_space_gap_width,    
189                                  int16_t block_non_space_gap_width 
190  ) {
191    BLOBNBOX_IT blob_it = row->blob_list();
192    STATS all_gap_stats(0, MAXSPACING - 1);
193    STATS cert_space_gap_stats(0, MAXSPACING - 1);
194    STATS all_space_gap_stats(0, MAXSPACING - 1);
195    STATS small_gap_stats(0, MAXSPACING - 1);
196    TBOX blob_box;
197    TBOX prev_blob_box;
198    int16_t gap_width;
199    int16_t real_space_threshold = 0;
200    int16_t max = 0;
201    int16_t index;
202    int16_t large_gap_count = 0;
203    bool suspected_table;
204    int32_t max_max_nonspace; 
205    bool good_block_space_estimate = block_space_gap_width > 0;
206    int32_t end_of_row;
207    int32_t row_length = 0;
208    float sane_space;
209    int32_t sane_threshold;
210    if (!good_block_space_estimate) {
211      block_space_gap_width = int16_t(std::floor(row->xheight / 2));
212    }
213    if (!row->blob_list()->empty()) {
214      if (tosp_threshold_bias1 > 0) {
215        real_space_threshold =
216            block_non_space_gap_width +
217            int16_t(floor(0.5 + tosp_threshold_bias1 *
218                                    (block_space_gap_width - block_non_space_gap_width)));
219      } else {
220        real_space_threshold = 
221            (block_space_gap_width + block_non_space_gap_width) / 2;
222      }
223      blob_it.set_to_list(row->blob_list());
224      blob_it.mark_cycle_pt();
225      end_of_row = blob_it.data_relative(-1)->bounding_box().right();
226      if (tosp_use_pre_chopping) {
227        blob_box = box_next_pre_chopped(&blob_it);
228      } else if (tosp_stats_use_xht_gaps) {
229        blob_box = reduced_box_next(row, &blob_it);
230      } else {
231        blob_box = box_next(&blob_it);
232      }
233      row_length = end_of_row - blob_box.left();
234      prev_blob_box = blob_box;
235      while (!blob_it.cycled_list()) {
236        if (tosp_use_pre_chopping) {
237          blob_box = box_next_pre_chopped(&blob_it);
238        } else if (tosp_stats_use_xht_gaps) {
239          blob_box = reduced_box_next(row, &blob_it);
240        } else {
241          blob_box = box_next(&blob_it);
242        }
243        int16_t left = prev_blob_box.right();
244        int16_t right = blob_box.left();
245        gap_width = right - left;
246        if (ignore_big_gap(row, row_length, gapmap, left, right)) {
247          large_gap_count++;
248        } else {
249          if (gap_width >= real_space_threshold) {
250            if (!tosp_row_use_cert_spaces || (gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
251                ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
252                 (!tosp_narrow_blobs_not_cert ||
253                  (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
254                (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
255              cert_space_gap_stats.add(gap_width, 1);
256            }
257            all_space_gap_stats.add(gap_width, 1);
258          } else {
259            small_gap_stats.add(gap_width, 1);
260          }
261          all_gap_stats.add(gap_width, 1);
262        }
263        prev_blob_box = blob_box;
264      }
265    }
266    suspected_table = (large_gap_count > 1) ||
267                      ((large_gap_count > 0) && (all_gap_stats.get_total() <= tosp_few_samples));
268    if ((cert_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) ||
269        ((suspected_table || all_gap_stats.get_total() <= tosp_short_row) &&
270         cert_space_gap_stats.get_total() > 0)) {
271      old_to_method(row, &all_gap_stats, &cert_space_gap_stats, &small_gap_stats,
272                    block_space_gap_width, block_non_space_gap_width);
273    } else {
274      if (!tosp_recovery_isolated_row_stats ||
275          !isolated_row_stats(row, gapmap, &all_gap_stats, suspected_table, block_idx, row_idx)) {
276        if (tosp_row_use_cert_spaces && (tosp_debug_level > 5)) {
277          tprintf("B:%d R:%d -- Inadequate certain spaces.\n", block_idx, row_idx);
278        }
279        if (tosp_row_use_cert_spaces1 && good_block_space_estimate) {
280          row->space_size = block_space_gap_width;
281          if (all_gap_stats.get_total() > tosp_redo_kern_limit) {
282            row->kern_size = all_gap_stats.median();
283          } else {
284            row->kern_size = block_non_space_gap_width;
285          }
286          row->space_threshold =
287              int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
288        } else {
289          old_to_method(row, &all_gap_stats, &all_space_gap_stats, &small_gap_stats,
290                        block_space_gap_width, block_non_space_gap_width);
291        }
292      }
293    }
294    if (tosp_improve_thresh && !suspected_table) {
295      improve_row_threshold(row, &all_gap_stats);
296    }
297    if (tosp_sanity_method == 0) {
298      if (suspected_table && (row->space_size < tosp_table_kn_sp_ratio * row->kern_size)) {
299        if (tosp_debug_level > 5) {
300          tprintf("B:%d R:%d -- DON'T BELIEVE SPACE %3.2f %d %3.2f.\n", block_idx, row_idx,
301                  row->kern_size, row->space_threshold, row->space_size);
302        }
303        row->space_threshold = static_cast<int32_t>(tosp_table_kn_sp_ratio * row->kern_size);
304        row->space_size = std::max(row->space_threshold + 1.0f, row->xheight);
305      }
306    } else if (tosp_sanity_method == 1) {
307      sane_space = row->space_size;
308      if ((row->space_size < tosp_min_sane_kn_sp * std::max(row->kern_size, 2.5f)) ||
309          ((row->space_size - row->kern_size) < (tosp_silly_kn_sp_gap * row->xheight))) {
310        if (good_block_space_estimate &&
311            (block_space_gap_width >= tosp_min_sane_kn_sp * row->kern_size)) {
312          sane_space = block_space_gap_width;
313        } else {
314          sane_space =
315              std::max(static_cast<float>(tosp_min_sane_kn_sp) * std::max(row->kern_size, 2.5f),
316                       row->xheight / 2.0f);
317        }
318        if (tosp_debug_level > 5) {
319          tprintf("B:%d R:%d -- DON'T BELIEVE SPACE %3.2f %d %3.2f -> %3.2f.\n", block_idx, row_idx,
320                  row->kern_size, row->space_threshold, row->space_size, sane_space);
321        }
322        row->space_size = sane_space;
323        row->space_threshold =
324            int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
325      }
326      sane_threshold = int32_t(floor(tosp_max_sane_kn_thresh * std::max(row->kern_size, 2.5f)));
327      if (row->space_threshold > sane_threshold) {
328        if (tosp_debug_level > 5) {
329          tprintf("B:%d R:%d -- DON'T BELIEVE THRESH %3.2f %d %3.2f->%d.\n", block_idx, row_idx,
330                  row->kern_size, row->space_threshold, row->space_size, sane_threshold);
331        }
332        row->space_threshold = sane_threshold;
333        if (row->space_size <= sane_threshold) {
334          row->space_size = row->space_threshold + 1.0f;
335        }
336      }
337      if (suspected_table) {
338        sane_space =
339            std::max(tosp_table_kn_sp_ratio * row->kern_size, tosp_table_xht_sp_ratio * row->xheight);
340        sane_threshold = int32_t(std::floor((sane_space + row->kern_size) / 2));
341        if ((row->space_size < sane_space) || (row->space_threshold < sane_threshold)) {
342          if (tosp_debug_level > 5) {
343            tprintf("B:%d R:%d -- SUSPECT NO SPACES %3.2f %d %3.2f.\n", block_idx, row_idx,
344                    row->kern_size, row->space_threshold, row->space_size);
345          }
346          row->space_threshold = static_cast<int32_t>(sane_space);
347          row->space_size = std::max(row->space_threshold + 1.0f, row->xheight);
348        }
349      }
350    }
351    if (tosp_old_to_method) {
352      row->max_nonspace = row->space_threshold;
353      row->min_space = row->space_threshold + 1;
354    } else {
355      row->min_space =
356          std::min(int32_t(ceil(tosp_fuzzy_space_factor * row->xheight)), int32_t(row->space_size));
357      if (row->min_space <= row->space_threshold) {
358        row->min_space = row->space_threshold + 1;
359      }
360      max_max_nonspace = int32_t((row->space_threshold + row->kern_size) / 2);
361      row->max_nonspace = max_max_nonspace;
362      for (index = 0; index <= max_max_nonspace; index++) {
363        if (all_gap_stats.pile_count(index) > max) {
364          max = all_gap_stats.pile_count(index);
365        }
366        if ((index > row->kern_size) && (all_gap_stats.pile_count(index) < 0.1 * max)) {
367          row->max_nonspace = index;
368          break;
369        }
370      }
371    }
372    if ((tosp_fuzzy_sp_fraction > 0) && (row->space_size > row->space_threshold)) {
373      row->min_space = std::max(
374          row->min_space, static_cast<int32_t>(ceil(row->space_threshold +
375                                                    tosp_fuzzy_sp_fraction *
376                                                        (row->space_size - row->space_threshold))));
377    }
378    if ((tosp_table_fuzzy_kn_sp_ratio > 0) && (suspected_table || tosp_fuzzy_limit_all)) {
379      row->min_space = std::max(
380          row->min_space, static_cast<int32_t>(ceil(tosp_table_fuzzy_kn_sp_ratio * row->kern_size)));
381    }
382    if ((tosp_fuzzy_kn_fraction > 0) && (row->kern_size < row->space_threshold)) {
383      row->max_nonspace = static_cast<int32_t>(floor(
384          0.5 + row->kern_size + tosp_fuzzy_kn_fraction * (row->space_threshold - row->kern_size)));
385    }
386    if (row->max_nonspace > row->space_threshold) {
387      row->max_nonspace = row->space_threshold;
388    }
389    if (tosp_debug_level > 5) {
390      tprintf(
391          "B:%d R:%d L:%d-- Kn:%d Sp:%d Thr:%d -- Kn:%3.2f (%d) Thr:%d (%d) "
392          "Sp:%3.2f\n",
393          block_idx, row_idx, row_length, block_non_space_gap_width, block_space_gap_width,
394          real_space_threshold, row->kern_size, row->max_nonspace, row->space_threshold,
395          row->min_space, row->space_size);
396    }
397    if (tosp_debug_level > 10) {
398      tprintf(
399          "row->kern_size = %3.2f, row->space_size = %3.2f, "
400          "row->space_threshold = %d\n",
401          row->kern_size, row->space_size, row->space_threshold);
402    }
403  }
404  void Textord::old_to_method(TO_ROW *row, STATS *all_gap_stats, STATS *space_gap_stats,
405                              STATS *small_gap_stats,
406                              int16_t block_space_gap_width,    
407                              int16_t block_non_space_gap_width 
408  ) {
409    if (space_gap_stats->get_total() >= tosp_enough_space_samples_for_median) {
410      row->space_size = space_gap_stats->median();
411      if (row->space_size > block_space_gap_width * 1.5) {
412        if (tosp_old_to_bug_fix) {
413          row->space_size = block_space_gap_width * 1.5;
414        } else {
415          row->space_size = block_space_gap_width;
416        }
417      }
418      if (row->space_size < (block_non_space_gap_width * 2) + 1) {
419        row->space_size = (block_non_space_gap_width * 2) + 1;
420      }
421    }
422    else if (space_gap_stats->get_total() >= 1) {
423      row->space_size = space_gap_stats->mean();
424      if (row->space_size > block_space_gap_width * 1.5) {
425        if (tosp_old_to_bug_fix) {
426          row->space_size = block_space_gap_width * 1.5;
427        } else {
428          row->space_size = block_space_gap_width;
429        }
430      }
431      if (row->space_size < (block_non_space_gap_width * 3) + 1) {
432        row->space_size = (block_non_space_gap_width * 3) + 1;
433      }
434    } else {
435      row->space_size = block_space_gap_width;
436    }
437    if ((tosp_only_small_gaps_for_kern) && (small_gap_stats->get_total() > tosp_redo_kern_limit)) {
438      row->kern_size = small_gap_stats->median();
439    } else if (all_gap_stats->get_total() > tosp_redo_kern_limit) {
440      row->kern_size = all_gap_stats->median();
441    } else { 
442      row->kern_size = block_non_space_gap_width;
443    }
444    if (tosp_threshold_bias2 > 0) {
445      row->space_threshold = int32_t(
446          floor(0.5 + row->kern_size + tosp_threshold_bias2 * (row->space_size - row->kern_size)));
447    } else {
448      row->space_threshold = int32_t(std::floor((row->space_size + row->kern_size) / 2));
449    }
450    if (tosp_old_to_constrain_sp_kn && tosp_sanity_method == 1 &&
451        ((row->space_size < tosp_min_sane_kn_sp * std::max(row->kern_size, 2.5f)) ||
452         ((row->space_size - row->kern_size) < tosp_silly_kn_sp_gap * row->xheight))) {
453      if (row->kern_size > 2.5) {
454        row->kern_size = row->space_size / tosp_min_sane_kn_sp;
455      }
456      row->space_threshold =
457          int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
458    }
459  }
460  bool Textord::isolated_row_stats(TO_ROW *row, GAPMAP *gapmap, STATS *all_gap_stats,
461                                   bool suspected_table, int16_t block_idx, int16_t row_idx) {
462    float kern_estimate;
463    float crude_threshold_estimate;
464    int16_t small_gaps_count;
465    int16_t total;
466    BLOBNBOX_IT blob_it = row->blob_list();
467    STATS cert_space_gap_stats(0, MAXSPACING - 1);
468    STATS all_space_gap_stats(0, MAXSPACING - 1);
469    STATS small_gap_stats(0, MAXSPACING - 1);
470    TBOX blob_box;
471    TBOX prev_blob_box;
472    int16_t gap_width;
473    int32_t end_of_row;
474    int32_t row_length;
475    kern_estimate = all_gap_stats->median();
476    crude_threshold_estimate =
477        std::max(tosp_init_guess_kn_mult * kern_estimate, tosp_init_guess_xht_mult * row->xheight);
478    small_gaps_count =
479        stats_count_under(all_gap_stats, static_cast<int16_t>(std::ceil(crude_threshold_estimate)));
480    total = all_gap_stats->get_total();
481    if ((total <= tosp_redo_kern_limit) ||
482        ((small_gaps_count / static_cast<float>(total)) < tosp_enough_small_gaps) ||
483        (total - small_gaps_count < 1)) {
484      if (tosp_debug_level > 5) {
485        tprintf("B:%d R:%d -- Can't do isolated row stats.\n", block_idx, row_idx);
486      }
487      return false;
488    }
489    blob_it.set_to_list(row->blob_list());
490    blob_it.mark_cycle_pt();
491    end_of_row = blob_it.data_relative(-1)->bounding_box().right();
492    if (tosp_use_pre_chopping) {
493      blob_box = box_next_pre_chopped(&blob_it);
494    } else if (tosp_stats_use_xht_gaps) {
495      blob_box = reduced_box_next(row, &blob_it);
496    } else {
497      blob_box = box_next(&blob_it);
498    }
499    row_length = end_of_row - blob_box.left();
500    prev_blob_box = blob_box;
501    while (!blob_it.cycled_list()) {
502      if (tosp_use_pre_chopping) {
503        blob_box = box_next_pre_chopped(&blob_it);
504      } else if (tosp_stats_use_xht_gaps) {
505        blob_box = reduced_box_next(row, &blob_it);
506      } else {
507        blob_box = box_next(&blob_it);
508      }
509      int16_t left = prev_blob_box.right();
510      int16_t right = blob_box.left();
511      gap_width = right - left;
512      if (!ignore_big_gap(row, row_length, gapmap, left, right) &&
513          (gap_width > crude_threshold_estimate)) {
514        if ((gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
515            ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
516             (!tosp_narrow_blobs_not_cert ||
517              (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
518            (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
519          cert_space_gap_stats.add(gap_width, 1);
520        }
521        all_space_gap_stats.add(gap_width, 1);
522      }
523      if (gap_width < crude_threshold_estimate) {
524        small_gap_stats.add(gap_width, 1);
525      }
526      prev_blob_box = blob_box;
527    }
528    if (cert_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) {
529      row->space_size = cert_space_gap_stats.median();
530    } else if (suspected_table && (cert_space_gap_stats.get_total() > 0)) {
531      row->space_size = cert_space_gap_stats.mean();
532    } else if (all_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) {
533      row->space_size = all_space_gap_stats.median();
534    } else {
535      row->space_size = all_space_gap_stats.mean();
536    }
537    if (tosp_only_small_gaps_for_kern) {
538      row->kern_size = small_gap_stats.median();
539    } else {
540      row->kern_size = all_gap_stats->median();
541    }
542    row->space_threshold = int32_t(std::floor((row->space_size + row->kern_size) / 2));
543    if ((row->kern_size >= row->space_threshold) || (row->space_threshold >= row->space_size) ||
544        (row->space_threshold <= 0)) {
545      if (tosp_debug_level > 5) {
546        tprintf("B:%d R:%d -- Isolated row stats SANITY FAILURE: %f %d %f\n", block_idx, row_idx,
547                row->kern_size, row->space_threshold, row->space_size);
548      }
549      row->kern_size = 0.0f;
550      row->space_threshold = 0;
551      row->space_size = 0.0f;
552      return false;
553    }
554    if (tosp_debug_level > 5) {
555      tprintf("B:%d R:%d -- Isolated row stats: %f %d %f\n", block_idx, row_idx, row->kern_size,
556              row->space_threshold, row->space_size);
557    }
558    return true;
559  }
560  int16_t Textord::stats_count_under(STATS *stats, int16_t threshold) {
561    int16_t index;
562    int16_t total = 0;
563    for (index = 0; index < threshold; index++) {
564      total += stats->pile_count(index);
565    }
566    return total;
567  }
568  void Textord::improve_row_threshold(TO_ROW *row, STATS *all_gap_stats) {
569    float sp = row->space_size;
570    float kn = row->kern_size;
571    int16_t reqd_zero_width = 0;
572    int16_t zero_width = 0;
573    int16_t zero_start = 0;
574    int16_t index = 0;
575    if (tosp_debug_level > 10) {
576      tprintf("Improve row threshold 0");
577    }
578    if ((all_gap_stats->get_total() <= 25) || (sp <= 10) || (sp <= 3 * kn) ||
579        (stats_count_under(all_gap_stats, static_cast<int16_t>(ceil(kn + (sp - kn) / 3 + 0.5))) <
580         (0.75 * all_gap_stats->get_total()))) {
581      return;
582    }
583    if (tosp_debug_level > 10) {
584      tprintf(" 1");
585    }
586    reqd_zero_width = static_cast<int16_t>(floor((sp - kn) / 3 + 0.5));
587    if (reqd_zero_width < 3) {
588      reqd_zero_width = 3;
589    }
590    for (index = int16_t(std::ceil(kn)); index < int16_t(std::floor(sp)); index++) {
591      if (all_gap_stats->pile_count(index) == 0) {
592        if (zero_width == 0) {
593          zero_start = index;
594        }
595        zero_width++;
596      } else {
597        if (zero_width >= reqd_zero_width) {
598          break;
599        } else {
600          zero_width = 0;
601        }
602      }
603    }
604    index--;
605    if (tosp_debug_level > 10) {
606      tprintf(" reqd_z_width: %d found %d 0's, starting %d; thresh: %d/n", reqd_zero_width,
607              zero_width, zero_start, row->space_threshold);
608    }
609    if ((zero_width < reqd_zero_width) ||
610        ((row->space_threshold >= zero_start) && (row->space_threshold <= index))) {
611      return;
612    }
613    if (tosp_debug_level > 10) {
614      tprintf(" 2");
615    }
616    if (row->space_threshold < zero_start) {
617      if (tosp_debug_level > 5) {
618        tprintf("Improve row kn:%5.2f sp:%5.2f 0's: %d -> %d  thresh:%d -> %d\n", kn, sp, zero_start,
619                index, row->space_threshold, zero_start);
620      }
621      row->space_threshold = zero_start;
622    }
623    if (row->space_threshold > index) {
624      if (tosp_debug_level > 5) {
625        tprintf("Improve row kn:%5.2f sp:%5.2f 0's: %d -> %d  thresh:%d -> %d\n", kn, sp, zero_start,
626                index, row->space_threshold, index);
627      }
628      row->space_threshold = index;
629    }
630  }
631  ROW *Textord::make_prop_words(TO_ROW *row,    
632                                FCOORD rotation 
633  ) {
634    bool bol; 
635    bool prev_fuzzy_sp;     
636    bool prev_fuzzy_non;    
637    uint8_t prev_blanks;    
638    bool fuzzy_sp = false;  
639    bool fuzzy_non = false; 
640    uint8_t blanks = 0;     
641    bool prev_gap_was_a_space = false;
642    bool break_at_next_gap = false;
643    ROW *real_row; 
644    C_OUTLINE_IT cout_it;
645    C_BLOB_LIST cblobs;
646    C_BLOB_IT cblob_it = &cblobs;
647    WERD_LIST words;
648    WERD *word; 
649    int32_t next_rep_char_word_right = INT32_MAX;
650    float repetition_spacing; 
651    int32_t xstarts[2];       
652    int32_t prev_x;           
653    BLOBNBOX_IT box_it;       
654    TBOX prev_blob_box;
655    TBOX next_blob_box;
656    int16_t prev_gap = INT16_MAX;
657    int16_t current_gap = INT16_MAX;
658    int16_t next_gap = INT16_MAX;
659    int16_t prev_within_xht_gap = INT16_MAX;
660    int16_t current_within_xht_gap = INT16_MAX;
661    int16_t next_within_xht_gap = INT16_MAX;
662    int16_t word_count = 0;
663    WERD_IT rep_char_it(&(row->rep_words));
664    if (!rep_char_it.empty()) {
665      next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
666    }
667    prev_x = -INT16_MAX;
668    cblob_it.set_to_list(&cblobs);
669    box_it.set_to_list(row->blob_list());
670    WERD_IT word_it(&words);
671    bol = true;
672    prev_blanks = 0;
673    prev_fuzzy_sp = false;
674    prev_fuzzy_non = false;
675    if (!box_it.empty()) {
676      xstarts[0] = box_it.data()->bounding_box().left();
677      if (xstarts[0] > next_rep_char_word_right) {
678        word = rep_char_it.extract();
679        word_it.add_after_then_move(word);
680        word->set_flag(W_BOL, true);
681        bol = false;
682        word->set_blanks(0);
683        word->set_flag(W_FUZZY_SP, false);
684        word->set_flag(W_FUZZY_NON, false);
685        xstarts[0] = word->bounding_box().left();
686        repetition_spacing = find_mean_blob_spacing(word);
687        current_gap = box_it.data()->bounding_box().left() - next_rep_char_word_right;
688        current_within_xht_gap = current_gap;
689        if (current_gap > tosp_rep_space * repetition_spacing) {
690          prev_blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
691          if (prev_blanks < 1) {
692            prev_blanks = 1;
693          }
694        } else {
695          prev_blanks = 0;
696        }
697        if (tosp_debug_level > 5) {
698          tprintf("Repch wd at BOL(%d, %d). rep spacing %5.2f;  Rgap:%d  ",
699                  box_it.data()->bounding_box().left(), box_it.data()->bounding_box().bottom(),
700                  repetition_spacing, current_gap);
701        }
702        prev_fuzzy_sp = false;
703        prev_fuzzy_non = false;
704        if (rep_char_it.empty()) {
705          next_rep_char_word_right = INT32_MAX;
706        } else {
707          rep_char_it.forward();
708          next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
709        }
710      }
711      peek_at_next_gap(row, box_it, next_blob_box, next_gap, next_within_xht_gap);
712      do {
713        auto bblob = box_it.data();
714        auto blob_box = bblob->bounding_box();
715        if (bblob->joined_to_prev()) {
716          auto cblob = bblob->remove_cblob();
717          if (cblob != nullptr) {
718            cout_it.set_to_list(cblob_it.data()->out_list());
719            cout_it.move_to_last();
720            cout_it.add_list_after(cblob->out_list());
721            delete cblob;
722          }
723        } else {
724          auto cblob = bblob->cblob();
725          if (cblob != nullptr) {
726            bblob->set_owns_cblob(false);
727            cblob_it.add_after_then_move(cblob);
728          }
729          prev_x = blob_box.right();
730        }
731        box_it.forward(); 
732        bblob = box_it.data();
733        blob_box = bblob->bounding_box();
734        if (!bblob->joined_to_prev() && bblob->cblob() != nullptr) {
735          prev_gap = current_gap;
736          prev_within_xht_gap = current_within_xht_gap;
737          prev_blob_box = next_blob_box;
738          current_gap = next_gap;
739          current_within_xht_gap = next_within_xht_gap;
740          peek_at_next_gap(row, box_it, next_blob_box, next_gap, next_within_xht_gap);
741          int16_t prev_gap_arg = prev_gap;
742          int16_t next_gap_arg = next_gap;
743          if (tosp_only_use_xht_gaps) {
744            prev_gap_arg = prev_within_xht_gap;
745            next_gap_arg = next_within_xht_gap;
746          }
747          if (blob_box.left() > next_rep_char_word_right ||
748              make_a_word_break(row, blob_box, prev_gap_arg, prev_blob_box, current_gap,
749                                current_within_xht_gap, next_blob_box, next_gap_arg, blanks, fuzzy_sp,
750                                fuzzy_non, prev_gap_was_a_space, break_at_next_gap) ||
751              box_it.at_first()) {
752            word = new WERD(&cblobs, prev_blanks, nullptr);
753            word_count++;
754            word_it.add_after_then_move(word);
755            if (bol) {
756              word->set_flag(W_BOL, true);
757              bol = false;
758            }
759            if (prev_fuzzy_sp) {
760              word->set_flag(W_FUZZY_SP, true);
761            } else if (prev_fuzzy_non) {
762              word->set_flag(W_FUZZY_NON, true);
763            }
764            if (blob_box.left() > next_rep_char_word_right) {
765              word = rep_char_it.extract();
766              word_it.add_after_then_move(word);
767              repetition_spacing = find_mean_blob_spacing(word);
768              current_gap = word->bounding_box().left() - prev_x;
769              current_within_xht_gap = current_gap;
770              if (current_gap > tosp_rep_space * repetition_spacing) {
771                blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
772                if (blanks < 1) {
773                  blanks = 1;
774                }
775              } else {
776                blanks = 0;
777              }
778              if (tosp_debug_level > 5) {
779                tprintf("Repch wd (%d,%d) rep gap %5.2f;  Lgap:%d (%d blanks);",
780                        word->bounding_box().left(), word->bounding_box().bottom(),
781                        repetition_spacing, current_gap, blanks);
782              }
783              word->set_blanks(blanks);
784              word->set_flag(W_FUZZY_SP, false);
785              word->set_flag(W_FUZZY_NON, false);
786              current_gap = blob_box.left() - next_rep_char_word_right;
787              if (current_gap > tosp_rep_space * repetition_spacing) {
788                blanks = static_cast<uint8_t>(current_gap / row->space_size);
789                if (blanks < 1) {
790                  blanks = 1;
791                }
792              } else {
793                blanks = 0;
794              }
795              if (tosp_debug_level > 5) {
796                tprintf(" Rgap:%d (%d blanks)\n", current_gap, blanks);
797              }
798              fuzzy_sp = false;
799              fuzzy_non = false;
800              if (rep_char_it.empty()) {
801                next_rep_char_word_right = INT32_MAX;
802              } else {
803                rep_char_it.forward();
804                next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
805              }
806            }
807            if (box_it.at_first() && rep_char_it.empty()) {
808              word->set_flag(W_EOL, true);
809              xstarts[1] = prev_x;
810            } else {
811              prev_blanks = blanks;
812              prev_fuzzy_sp = fuzzy_sp;
813              prev_fuzzy_non = fuzzy_non;
814            }
815          }
816        }
817      } while (!box_it.at_first()); 
818      while (!rep_char_it.empty()) {
819        word = rep_char_it.extract();
820        word_it.add_after_then_move(word);
821        repetition_spacing = find_mean_blob_spacing(word);
822        current_gap = word->bounding_box().left() - prev_x;
823        if (current_gap > tosp_rep_space * repetition_spacing) {
824          blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
825          if (blanks < 1) {
826            blanks = 1;
827          }
828        } else {
829          blanks = 0;
830        }
831        if (tosp_debug_level > 5) {
832          tprintf("Repch wd at EOL (%d,%d). rep spacing %5.2f; Lgap:%d (%d blanks)\n",
833                  word->bounding_box().left(), word->bounding_box().bottom(), repetition_spacing,
834                  current_gap, blanks);
835        }
836        word->set_blanks(blanks);
837        word->set_flag(W_FUZZY_SP, false);
838        word->set_flag(W_FUZZY_NON, false);
839        prev_x = word->bounding_box().right();
840        if (rep_char_it.empty()) {
841          word->set_flag(W_EOL, true);
842          xstarts[1] = prev_x;
843        } else {
844          rep_char_it.forward();
845        }
846      }
847      real_row =
848          new ROW(row, static_cast<int16_t>(row->kern_size), static_cast<int16_t>(row->space_size));
849      word_it.set_to_list(real_row->word_list());
850      word_it.add_list_after(&words);
851      real_row->recalc_bounding_box();
852      if (tosp_debug_level > 4) {
853        tprintf("Row: Made %d words in row ((%d,%d)(%d,%d))\n", word_count,
854                real_row->bounding_box().left(), real_row->bounding_box().bottom(),
855                real_row->bounding_box().right(), real_row->bounding_box().top());
856      }
857      return real_row;
858    }
859    return nullptr;
860  }
861  ROW *Textord::make_blob_words(TO_ROW *row,    
862                                FCOORD rotation 
863  ) {
864    bool bol;      
865    ROW *real_row; 
866    C_OUTLINE_IT cout_it;
867    C_BLOB_LIST cblobs;
868    C_BLOB_IT cblob_it = &cblobs;
869    WERD_LIST words;
870    WERD *word;         
871    BLOBNBOX_IT box_it; 
872    int16_t word_count = 0;
873    cblob_it.set_to_list(&cblobs);
874    box_it.set_to_list(row->blob_list());
875    WERD_IT word_it(&words);
876    bol = true;
877    if (!box_it.empty()) {
878      do {
879        auto bblob = box_it.data();
880        auto blob_box = bblob->bounding_box();
881        if (bblob->joined_to_prev()) {
882          auto cblob = bblob->remove_cblob();
883          if (cblob != nullptr) {
884            cout_it.set_to_list(cblob_it.data()->out_list());
885            cout_it.move_to_last();
886            cout_it.add_list_after(cblob->out_list());
887            delete cblob;
888          }
889        } else {
890          auto cblob = bblob->cblob();
891          if (cblob != nullptr) {
892            bblob->set_owns_cblob(false);
893            cblob_it.add_after_then_move(cblob);
894          }
895        }
896        box_it.forward(); 
897        bblob = box_it.data();
898        blob_box = bblob->bounding_box();
899        if (!bblob->joined_to_prev() && !cblobs.empty()) {
900          word = new WERD(&cblobs, 1, nullptr);
901          word_count++;
902          word_it.add_after_then_move(word);
903          if (bol) {
904            word->set_flag(W_BOL, true);
905            bol = false;
906          }
907          if (box_it.at_first()) { 
908            word->set_flag(W_EOL, true);
909          }
910        }
911      } while (!box_it.at_first()); 
912      real_row =
913          new ROW(row, static_cast<int16_t>(row->kern_size), static_cast<int16_t>(row->space_size));
914      word_it.set_to_list(real_row->word_list());
915      word_it.add_list_after(&words);
916      real_row->recalc_bounding_box();
917      if (tosp_debug_level > 4) {
918        tprintf("Row:Made %d words in row ((%d,%d)(%d,%d))\n", word_count,
919                real_row->bounding_box().left(), real_row->bounding_box().bottom(),
920                real_row->bounding_box().right(), real_row->bounding_box().top());
921      }
922      return real_row;
923    }
924    return nullptr;
925  }
926  bool Textord::make_a_word_break(TO_ROW *row,   
927                                  TBOX blob_box, 
928                                  int16_t prev_gap, TBOX prev_blob_box, int16_t real_current_gap,
929                                  int16_t within_xht_current_gap, TBOX next_blob_box,
930                                  int16_t next_gap, uint8_t &blanks, bool &fuzzy_sp, bool &fuzzy_non,
931                                  bool &prev_gap_was_a_space, bool &break_at_next_gap) {
932    bool space;
933    int16_t current_gap;
934    float fuzzy_sp_to_kn_limit;
935    if (break_at_next_gap) {
936      break_at_next_gap = false;
937      return true;
938    }
939    if ((row->kern_size > tosp_large_kerning * row->xheight) ||
940        ((tosp_dont_fool_with_small_kerns >= 0) &&
941         (real_current_gap < tosp_dont_fool_with_small_kerns * row->kern_size))) {
942      within_xht_current_gap = real_current_gap;
943    }
944    if (tosp_use_xht_gaps && tosp_only_use_xht_gaps) {
945      current_gap = within_xht_current_gap;
946    } else {
947      current_gap = real_current_gap;
948    }
949    if (tosp_old_to_method) {
950      space = current_gap > row->max_nonspace;
951      if (space && (current_gap < INT16_MAX)) {
952        if (current_gap < row->min_space) {
953          if (current_gap > row->space_threshold) {
954            blanks = 1;
955            fuzzy_sp = true;
956            fuzzy_non = false;
957          } else {
958            blanks = 0;
959            fuzzy_sp = false;
960            fuzzy_non = true;
961          }
962        } else {
963          if (row->space_size == 0.0f) {
964            blanks = 1;
965          } else {
966            blanks = static_cast<uint8_t>(current_gap / row->space_size);
967            if (blanks < 1) {
968              blanks = 1;
969            }
970          }
971          fuzzy_sp = false;
972          fuzzy_non = false;
973        }
974      }
975      return space;
976    } else {
977      if (prev_blob_box.null_box()) { 
978        prev_gap_was_a_space = true;
979      }
980      space = current_gap > row->space_threshold;
981      int num_blanks = current_gap;
982      if (row->space_size > 1.0f) {
983        num_blanks = IntCastRounded(current_gap / row->space_size);
984      }
985      blanks = static_cast<uint8_t>(ClipToRange<int>(num_blanks, 1, UINT8_MAX));
986      fuzzy_sp = false;
987      fuzzy_non = false;
988      if (tosp_use_xht_gaps && (real_current_gap <= row->max_nonspace) &&
989          (within_xht_current_gap > row->max_nonspace)) {
990        space = true;
991        fuzzy_non = true;
992  #ifndef GRAPHICS_DISABLED
993        mark_gap(blob_box, 20, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
994                 next_gap);
995  #endif
996      } else if (tosp_use_xht_gaps && (real_current_gap <= row->space_threshold) &&
997                 (within_xht_current_gap > row->space_threshold)) {
998        space = true;
999        if (tosp_flip_fuzz_kn_to_sp) {
1000          fuzzy_sp = true;
1001        } else {
1002          fuzzy_non = true;
1003        }
1004  #ifndef GRAPHICS_DISABLED
1005        mark_gap(blob_box, 21, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1006                 next_gap);
1007  #endif
1008      } else if (tosp_use_xht_gaps && (real_current_gap < row->min_space) &&
1009                 (within_xht_current_gap >= row->min_space)) {
1010        space = true;
1011  #ifndef GRAPHICS_DISABLED
1012        mark_gap(blob_box, 22, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1013                 next_gap);
1014  #endif
1015      } else if (tosp_force_wordbreak_on_punct && !suspected_punct_blob(row, prev_blob_box) &&
1016                 suspected_punct_blob(row, blob_box)) {
1017        break_at_next_gap = true;
1018      }
1019      else if ((current_gap < row->min_space) && (current_gap > row->space_threshold)) {
1020        if (tosp_pass_wide_fuzz_sp_to_context > 0) {
1021          fuzzy_sp_to_kn_limit =
1022              row->kern_size + tosp_pass_wide_fuzz_sp_to_context * (row->space_size - row->kern_size);
1023        } else {
1024          fuzzy_sp_to_kn_limit = 99999.0f;
1025        }
1026        if ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box) && prev_gap_was_a_space &&
1027            (current_gap <= tosp_gap_factor * prev_gap)) {
1028          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1029            if (tosp_flip_fuzz_sp_to_kn) {
1030              fuzzy_non = true;
1031            } else {
1032              fuzzy_sp = true;
1033            }
1034          } else {
1035            space = false;
1036          }
1037  #ifndef GRAPHICS_DISABLED
1038          mark_gap(blob_box, 1, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1039                   next_gap);
1040  #endif
1041        }
1042        else if ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box) &&
1043                 !prev_gap_was_a_space && (current_gap * tosp_gap_factor <= prev_gap)) {
1044          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1045            if (tosp_flip_fuzz_sp_to_kn) {
1046              fuzzy_non = true;
1047            } else {
1048              fuzzy_sp = true;
1049            }
1050          } else {
1051            space = false;
1052          }
1053  #ifndef GRAPHICS_DISABLED
1054          mark_gap(blob_box, 2, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1055                   next_gap);
1056  #endif
1057        } else if ((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box) &&
1058                   (next_gap > row->space_threshold) && (current_gap <= tosp_gap_factor * next_gap)) {
1059          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1060            if (tosp_flip_fuzz_sp_to_kn) {
1061              fuzzy_non = true;
1062            } else {
1063              fuzzy_sp = true;
1064            }
1065          } else {
1066            space = false;
1067          }
1068  #ifndef GRAPHICS_DISABLED
1069          mark_gap(blob_box, 3, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1070                   next_gap);
1071  #endif
1072        } else if ((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box) &&
1073                   (next_gap <= row->space_threshold) &&
1074                   (current_gap * tosp_gap_factor <= next_gap)) {
1075          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1076            if (tosp_flip_fuzz_sp_to_kn) {
1077              fuzzy_non = true;
1078            } else {
1079              fuzzy_sp = true;
1080            }
1081          } else {
1082            space = false;
1083          }
1084  #ifndef GRAPHICS_DISABLED
1085          mark_gap(blob_box, 4, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1086                   next_gap);
1087  #endif
1088        } else if ((((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box)) ||
1089                    ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box)))) {
1090          fuzzy_sp = true;
1091  #ifndef GRAPHICS_DISABLED
1092          mark_gap(blob_box, 6, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1093                   next_gap);
1094  #endif
1095        }
1096      } else if ((current_gap > row->max_nonspace) && (current_gap <= row->space_threshold)) {
1097        if ((prev_blob_box.width() > 0) && (next_blob_box.width() > 0) &&
1098            (current_gap >= tosp_kern_gap_factor1 * std::max(prev_gap, next_gap)) &&
1099            wide_blob(row, prev_blob_box) && wide_blob(row, next_blob_box)) {
1100          space = true;
1101          if ((tosp_flip_fuzz_kn_to_sp) &&
1102              ((tosp_flip_caution <= 0) || (tosp_flip_caution * row->kern_size > row->space_size))) {
1103            fuzzy_sp = true;
1104          } else {
1105            fuzzy_non = true;
1106          }
1107  #ifndef GRAPHICS_DISABLED
1108          mark_gap(blob_box, 7, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1109                   next_gap);
1110  #endif
1111        } else if (prev_blob_box.width() > 0 && next_blob_box.width() > 0 &&
1112                   current_gap > 5 && 
1113                   current_gap >= tosp_kern_gap_factor2 * std::max(prev_gap, next_gap) &&
1114                   !(narrow_blob(row, prev_blob_box) || suspected_punct_blob(row, prev_blob_box)) &&
1115                   !(narrow_blob(row, next_blob_box) || suspected_punct_blob(row, next_blob_box))) {
1116          space = true;
1117          fuzzy_non = true;
1118  #ifndef GRAPHICS_DISABLED
1119          mark_gap(blob_box, 8, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1120                   next_gap);
1121  #endif
1122        } else if ((tosp_kern_gap_factor3 > 0) && (prev_blob_box.width() > 0) &&
1123                   (next_blob_box.width() > 0) &&
1124                   (current_gap >= tosp_kern_gap_factor3 * std::max(prev_gap, next_gap)) &&
1125                   (!tosp_rule_9_test_punct || (!suspected_punct_blob(row, prev_blob_box) &&
1126                                                !suspected_punct_blob(row, next_blob_box)))) {
1127          space = true;
1128          fuzzy_non = true;
1129  #ifndef GRAPHICS_DISABLED
1130          mark_gap(blob_box, 9, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1131                   next_gap);
1132  #endif
1133        }
1134      }
1135      if (tosp_debug_level > 10) {
1136        tprintf(
1137            "word break = %d current_gap = %d, prev_gap = %d, "
1138            "next_gap = %d\n",
1139            space ? 1 : 0, current_gap, prev_gap, next_gap);
1140      }
1141      prev_gap_was_a_space = space && !(fuzzy_non);
1142      return space;
1143    }
1144  }
1145  bool Textord::narrow_blob(TO_ROW *row, TBOX blob_box) {
1146    bool result;
1147    result =
1148        ((blob_box.width() <= tosp_narrow_fraction * row->xheight) ||
1149         ((static_cast<float>(blob_box.width()) / blob_box.height()) <= tosp_narrow_aspect_ratio));
1150    return result;
1151  }
1152  bool Textord::wide_blob(TO_ROW *row, TBOX blob_box) {
1153    bool result;
1154    if (tosp_wide_fraction > 0) {
1155      if (tosp_wide_aspect_ratio > 0) {
1156        result =
1157            ((blob_box.width() >= tosp_wide_fraction * row->xheight) &&
1158             ((static_cast<float>(blob_box.width()) / blob_box.height()) > tosp_wide_aspect_ratio));
1159      } else {
1160        result = (blob_box.width() >= tosp_wide_fraction * row->xheight);
1161      }
1162    } else {
1163      result = !narrow_blob(row, blob_box);
1164    }
1165    return result;
1166  }
1167  bool Textord::suspected_punct_blob(TO_ROW *row, TBOX box) {
1168    bool result;
1169    float baseline;
1170    float blob_x_centre;
1171    blob_x_centre = (box.right() + box.left()) / 2.0;
1172    baseline = row->baseline.y(blob_x_centre);
1173    result = (box.height() <= 0.66 * row->xheight) || (box.top() < baseline + row->xheight / 2.0) ||
1174             (box.bottom() > baseline + row->xheight / 2.0);
1175    return result;
1176  }
1177  void Textord::peek_at_next_gap(TO_ROW *row, BLOBNBOX_IT box_it, TBOX &next_blob_box,
1178                                 int16_t &next_gap, int16_t &next_within_xht_gap) {
1179    TBOX next_reduced_blob_box;
1180    TBOX bit_beyond;
1181    BLOBNBOX_IT reduced_box_it = box_it;
1182    next_blob_box = box_next(&box_it);
<span onclick='openModal()' class='match'>1183    next_reduced_blob_box = reduced_box_next(row, &reduced_box_it);
1184    if (box_it.at_first()) {
1185      next_gap = INT16_MAX;
1186      next_within_xht_gap = INT16_MAX;
1187    } else {
1188      bit_beyond = box_it.data()->bounding_box();
</span>1189      next_gap = bit_beyond.left() - next_blob_box.right();
1190      bit_beyond = reduced_box_next(row, &reduced_box_it);
1191      next_within_xht_gap = bit_beyond.left() - next_reduced_blob_box.right();
1192    }
1193  }
1194  #ifndef GRAPHICS_DISABLED
1195  void Textord::mark_gap(TBOX blob,    
1196                         int16_t rule, 
1197                         int16_t prev_gap, int16_t prev_blob_width, int16_t current_gap,
1198                         int16_t next_blob_width, int16_t next_gap) {
1199    ScrollView::Color col; 
1200    switch (rule) {
1201      case 1:
1202        col = ScrollView::RED;
1203        break;
1204      case 2:
1205        col = ScrollView::CYAN;
1206        break;
1207      case 3:
1208        col = ScrollView::GREEN;
1209        break;
1210      case 4:
1211        col = ScrollView::BLACK;
1212        break;
1213      case 5:
1214        col = ScrollView::MAGENTA;
1215        break;
1216      case 6:
1217        col = ScrollView::BLUE;
1218        break;
1219      case 7:
1220        col = ScrollView::WHITE;
1221        break;
1222      case 8:
1223        col = ScrollView::YELLOW;
1224        break;
1225      case 9:
1226        col = ScrollView::BLACK;
1227        break;
1228      case 20:
1229        col = ScrollView::CYAN;
1230        break;
1231      case 21:
1232        col = ScrollView::GREEN;
1233        break;
1234      case 22:
1235        col = ScrollView::MAGENTA;
1236        break;
1237      default:
1238        col = ScrollView::BLACK;
1239    }
1240    if (textord_show_initial_words) {
1241      to_win->Pen(col);
1242      to_win->Ellipse(current_gap / 2.0f,
1243                      blob.height() / 2.0f, 
1244                      blob.left() - current_gap / 2.0f,
1245                      blob.bottom() + blob.height() / 2.0f);
1246    }
1247    if (tosp_debug_level > 5) {
1248      tprintf("  (%d,%d) Sp<->Kn Rule %d %d %d %d %d %d\n", blob.left() - current_gap / 2,
1249              blob.bottom(), rule, prev_gap, prev_blob_width, current_gap, next_blob_width, next_gap);
1250    }
1251  }
1252  #endif
1253  float Textord::find_mean_blob_spacing(WERD *word) {
1254    C_BLOB_IT cblob_it;
1255    TBOX blob_box;
1256    int32_t gap_sum = 0;
1257    int16_t gap_count = 0;
1258    int16_t prev_right;
1259    cblob_it.set_to_list(word->cblob_list());
1260    if (!cblob_it.empty()) {
1261      cblob_it.mark_cycle_pt();
1262      prev_right = cblob_it.data()->bounding_box().right();
1263      cblob_it.forward();
1264      for (; !cblob_it.cycled_list(); cblob_it.forward()) {
1265        blob_box = cblob_it.data()->bounding_box();
1266        gap_sum += blob_box.left() - prev_right;
1267        gap_count++;
1268        prev_right = blob_box.right();
1269      }
1270    }
1271    if (gap_count > 0) {
1272      return (gap_sum / static_cast<float>(gap_count));
1273    } else {
1274      return 0.0f;
1275    }
1276  }
1277  bool Textord::ignore_big_gap(TO_ROW *row, int32_t row_length, GAPMAP *gapmap, int16_t left,
1278                               int16_t right) {
1279    int16_t gap = right - left + 1;
1280    if (tosp_ignore_big_gaps > 999) {
1281      return false; 
1282    }
1283    if (tosp_ignore_big_gaps > 0) {
1284      return (gap > tosp_ignore_big_gaps * row->xheight);
1285    }
1286    if (gap > tosp_ignore_very_big_gaps * row->xheight) {
1287      return true;
1288    }
1289    if (tosp_ignore_big_gaps == 0) {
1290      if ((gap > 2.1 * row->xheight) && (row_length > 20 * row->xheight)) {
1291        return true;
1292      }
1293      if ((gap > 1.75 * row->xheight) &&
1294          ((row_length > 35 * row->xheight) || gapmap->table_gap(left, right))) {
1295        return true;
1296      }
1297    } else {
1298      if ((gap > gapmap_big_gaps * row->xheight) && gapmap->table_gap(left, right)) {
1299        return true;
1300      }
1301    }
1302    return false;
1303  }
1304  TBOX Textord::reduced_box_next(TO_ROW *row,    
1305                                 BLOBNBOX_IT *it 
1306  ) {
1307    BLOBNBOX *blob;             
1308    BLOBNBOX *head_blob;        
1309    TBOX full_box;              
1310    TBOX reduced_box;           
1311    int16_t left_above_xht;     
1312    int16_t new_left_above_xht; 
1313    blob = it->data();
1314    if (blob->red_box_set()) {
1315      reduced_box = blob->reduced_box();
1316      do {
1317        it->forward();
1318        blob = it->data();
1319      } while (blob->cblob() == nullptr || blob->joined_to_prev());
1320      return reduced_box;
1321    }
1322    head_blob = blob;
1323    full_box = blob->bounding_box();
1324    reduced_box = reduced_box_for_blob(blob, row, &left_above_xht);
1325    do {
1326      it->forward();
1327      blob = it->data();
1328      if (blob->cblob() == nullptr) {
1329        full_box += blob->bounding_box();
1330      } else if (blob->joined_to_prev()) {
1331        reduced_box += reduced_box_for_blob(blob, row, &new_left_above_xht);
1332        left_above_xht = std::min(left_above_xht, new_left_above_xht);
1333      }
1334    }
1335    while (blob->cblob() == nullptr || blob->joined_to_prev());
1336    if ((reduced_box.width() > 0) &&
1337        ((reduced_box.left() + tosp_near_lh_edge * reduced_box.width()) < left_above_xht) &&
1338        (reduced_box.height() > 0.7 * row->xheight)) {
1339  #ifndef GRAPHICS_DISABLED
1340      if (textord_show_initial_words) {
1341        reduced_box.plot(to_win, ScrollView::YELLOW, ScrollView::YELLOW);
1342      }
1343  #endif
1344    } else {
1345      reduced_box = full_box;
1346    }
1347    head_blob->set_reduced_box(reduced_box);
1348    return reduced_box;
1349  }
1350  TBOX Textord::reduced_box_for_blob(BLOBNBOX *blob, TO_ROW *row, int16_t *left_above_xht) {
1351    float baseline;
1352    float blob_x_centre;
1353    float left_limit;
1354    float right_limit;
1355    float junk;
1356    TBOX blob_box;
1357    blob_box = blob->bounding_box();
1358    blob_x_centre = (blob_box.left() + blob_box.right()) / 2.0;
1359    baseline = row->baseline.y(blob_x_centre);
1360    left_limit = static_cast<float>(INT32_MAX);
1361    junk = static_cast<float>(-INT32_MAX);
1362    find_cblob_hlimits(blob->cblob(), (baseline + 1.1 * row->xheight), static_cast<float>(INT16_MAX),
1363                       left_limit, junk);
1364    if (left_limit > junk) {
1365      *left_above_xht = INT16_MAX; 
1366    } else {
1367      *left_above_xht = static_cast<int16_t>(std::floor(left_limit));
1368    }
1369    left_limit = static_cast<float>(INT32_MAX);
1370    junk = static_cast<float>(-INT32_MAX);
1371    find_cblob_hlimits(blob->cblob(), baseline, static_cast<float>(INT16_MAX), left_limit, junk);
1372    if (left_limit > junk) {
1373      return TBOX(); 
1374    }
1375    junk = static_cast<float>(INT32_MAX);
1376    right_limit = static_cast<float>(-INT32_MAX);
1377    find_cblob_hlimits(blob->cblob(), static_cast<float>(-INT16_MAX), (baseline + row->xheight), junk,
1378                       right_limit);
1379    if (junk > right_limit) {
1380      return TBOX(); 
1381    }
1382    return TBOX(ICOORD(static_cast<int16_t>(std::floor(left_limit)), blob_box.bottom()),
1383                ICOORD(static_cast<int16_t>(std::ceil(right_limit)), blob_box.top()));
1384  }
1385  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssqldm.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tospace.cpp</div>
                </div>
                <div class="column column_space"><pre><code>261        UcStr=Str;
262        if (Expect.In(syFlt)){Sym=dsyFlt; Flt=atof(Str.CStr());}
263        else {Sym=dsyInt; Int=atoi(Str.CStr());}
</pre></code></div>
                <div class="column column_space"><pre><code>1183    next_reduced_blob_box = reduced_box_next(row, &reduced_box_it);
1184    if (box_it.at_first()) {
1185      next_gap = INT16_MAX;
1186      next_within_xht_gap = INT16_MAX;
1187    } else {
1188      bit_beyond = box_it.data()->bounding_box();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    