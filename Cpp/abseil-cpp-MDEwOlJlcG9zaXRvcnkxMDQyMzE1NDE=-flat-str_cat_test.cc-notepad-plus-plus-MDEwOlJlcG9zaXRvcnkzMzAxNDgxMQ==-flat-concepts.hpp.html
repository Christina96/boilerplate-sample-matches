
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_cat_test.cc</h3>
            <pre><code>1  #include "absl/strings/str_cat.h"
2  #include <cstdint>
3  #include <string>
4  #include <vector>
5  #include "gtest/gtest.h"
6  #include "absl/strings/str_format.h"
7  #include "absl/strings/substitute.h"
8  #ifdef __ANDROID__
9  #define ABSL_EXPECT_DEBUG_DEATH(statement, regex) \
10    EXPECT_DEBUG_DEATH(statement, ".*")
11  #else
12  #define ABSL_EXPECT_DEBUG_DEATH(statement, regex) \
13    EXPECT_DEBUG_DEATH(statement, regex)
14  #endif
15  namespace {
16  TEST(StrCat, Ints) {
17    const short s = -1;  
18    const uint16_t us = 2;
19    const int i = -3;
20    const unsigned int ui = 4;
21    const long l = -5;                 
22    const unsigned long ul = 6;        
23    const long long ll = -7;           
24    const unsigned long long ull = 8;  
25    const ptrdiff_t ptrdiff = -9;
26    const size_t size = 10;
27    const intptr_t intptr = -12;
28    const uintptr_t uintptr = 13;
29    std::string answer;
30    answer = absl::StrCat(s, us);
31    EXPECT_EQ(answer, "-12");
32    answer = absl::StrCat(i, ui);
33    EXPECT_EQ(answer, "-34");
34    answer = absl::StrCat(l, ul);
35    EXPECT_EQ(answer, "-56");
36    answer = absl::StrCat(ll, ull);
37    EXPECT_EQ(answer, "-78");
38    answer = absl::StrCat(ptrdiff, size);
39    EXPECT_EQ(answer, "-910");
40    answer = absl::StrCat(ptrdiff, intptr);
41    EXPECT_EQ(answer, "-9-12");
42    answer = absl::StrCat(uintptr, 0);
43    EXPECT_EQ(answer, "130");
44  }
45  TEST(StrCat, Enums) {
46    enum SmallNumbers { One = 1, Ten = 10 } e = Ten;
47    EXPECT_EQ("10", absl::StrCat(e));
48    EXPECT_EQ("-5", absl::StrCat(SmallNumbers(-5)));
49    enum class Option { Boxers = 1, Briefs = -1 };
50    EXPECT_EQ("-1", absl::StrCat(Option::Briefs));
51    enum class Airplane : uint64_t {
52      Airbus = 1,
53      Boeing = 1000,
54      Canary = 10000000000  
55    };
56    EXPECT_EQ("10000000000", absl::StrCat(Airplane::Canary));
57    enum class TwoGig : int32_t {
58      TwoToTheZero = 1,
59      TwoToTheSixteenth = 1 << 16,
60      TwoToTheThirtyFirst = INT32_MIN
61    };
62    EXPECT_EQ("65536", absl::StrCat(TwoGig::TwoToTheSixteenth));
63    EXPECT_EQ("-2147483648", absl::StrCat(TwoGig::TwoToTheThirtyFirst));
64    EXPECT_EQ("-1", absl::StrCat(static_cast<TwoGig>(-1)));
65    enum class FourGig : uint32_t {
66      TwoToTheZero = 1,
67      TwoToTheSixteenth = 1 << 16,
68      TwoToTheThirtyFirst = 1U << 31  
69    };
70    EXPECT_EQ("65536", absl::StrCat(FourGig::TwoToTheSixteenth));
71    EXPECT_EQ("2147483648", absl::StrCat(FourGig::TwoToTheThirtyFirst));
72    EXPECT_EQ("4294967295", absl::StrCat(static_cast<FourGig>(-1)));
73    EXPECT_EQ("10000000000", absl::StrCat(Airplane::Canary));
74  }
75  TEST(StrCat, Basics) {
76    std::string result;
77    std::string strs[] = {"Hello", "Cruel", "World"};
78    std::string stdstrs[] = {
79      "std::Hello",
80      "std::Cruel",
81      "std::World"
82    };
83    absl::string_view pieces[] = {"Hello", "Cruel", "World"};
84    const char* c_strs[] = {
85      "Hello",
86      "Cruel",
87      "World"
88    };
89    int32_t i32s[] = {'H', 'C', 'W'};
90    uint64_t ui64s[] = {12345678910LL, 10987654321LL};
91    EXPECT_EQ(absl::StrCat(), "");
92    result = absl::StrCat(false, true, 2, 3);
93    EXPECT_EQ(result, "0123");
94    result = absl::StrCat(-1);
95    EXPECT_EQ(result, "-1");
96    result = absl::StrCat(absl::SixDigits(0.5));
97    EXPECT_EQ(result, "0.5");
98    result = absl::StrCat(strs[1], pieces[2]);
99    EXPECT_EQ(result, "CruelWorld");
100    result = absl::StrCat(stdstrs[1], " ", stdstrs[2]);
101    EXPECT_EQ(result, "std::Cruel std::World");
102    result = absl::StrCat(strs[0], ", ", pieces[2]);
103    EXPECT_EQ(result, "Hello, World");
104    result = absl::StrCat(strs[0], ", ", strs[1], " ", strs[2], "!");
105    EXPECT_EQ(result, "Hello, Cruel World!");
106    result = absl::StrCat(pieces[0], ", ", pieces[1], " ", pieces[2]);
107    EXPECT_EQ(result, "Hello, Cruel World");
108    result = absl::StrCat(c_strs[0], ", ", c_strs[1], " ", c_strs[2]);
109    EXPECT_EQ(result, "Hello, Cruel World");
110    result = absl::StrCat("ASCII ", i32s[0], ", ", i32s[1], " ", i32s[2], "!");
111    EXPECT_EQ(result, "ASCII 72, 67 87!");
112    result = absl::StrCat(ui64s[0], ", ", ui64s[1], "!");
113    EXPECT_EQ(result, "12345678910, 10987654321!");
114    std::string one =
115        "1";  
116    result = absl::StrCat("And a ", one.size(), " and a ",
117                          &result[2] - &result[0], " and a ", one, " 2 3 4", "!");
118    EXPECT_EQ(result, "And a 1 and a 2 and a 1 2 3 4!");
119    result =
120        absl::StrCat("To output a char by ASCII/numeric value, use +: ", '!' + 0);
121    EXPECT_EQ(result, "To output a char by ASCII/numeric value, use +: 33");
122    float f = 100000.5;
123    result = absl::StrCat("A hundred K and a half is ", absl::SixDigits(f));
124    EXPECT_EQ(result, "A hundred K and a half is 100000");
125    f = 100001.5;
126    result =
127        absl::StrCat("A hundred K and one and a half is ", absl::SixDigits(f));
128    EXPECT_EQ(result, "A hundred K and one and a half is 100002");
129    double d = 100000.5;
130    d *= d;
131    result =
132        absl::StrCat("A hundred K and a half squared is ", absl::SixDigits(d));
133    EXPECT_EQ(result, "A hundred K and a half squared is 1.00001e+10");
134    result = absl::StrCat(1, 2, 333, 4444, 55555, 666666, 7777777, 88888888,
135                          999999999);
136    EXPECT_EQ(result, "12333444455555666666777777788888888999999999");
137  }
138  TEST(StrCat, CornerCases) {
139    std::string result;
140    result = absl::StrCat("");  
141    EXPECT_EQ(result, "");
142    result = absl::StrCat("", "");
143    EXPECT_EQ(result, "");
144    result = absl::StrCat("", "", "");
145    EXPECT_EQ(result, "");
146    result = absl::StrCat("", "", "", "");
147    EXPECT_EQ(result, "");
148    result = absl::StrCat("", "", "", "", "");
149    EXPECT_EQ(result, "");
150  }
151  TEST(StrCat, NullConstCharPtr) {
152    const char* null = nullptr;
153    EXPECT_EQ(absl::StrCat("mon", null, "key"), "monkey");
154  }
155  template <typename T>
156  struct Mallocator {
157    typedef T value_type;
158    typedef size_t size_type;
159    typedef ptrdiff_t difference_type;
160    typedef T* pointer;
161    typedef const T* const_pointer;
162    typedef T& reference;
163    typedef const T& const_reference;
164    size_type max_size() const {
165      return size_t(std::numeric_limits<size_type>::max()) / sizeof(value_type);
166    }
167    template <typename U>
168    struct rebind {
169      typedef Mallocator<U> other;
170    };
171    Mallocator() = default;
<span onclick='openModal()' class='match'>172    template <class U>
173    Mallocator(const Mallocator<U>&) {}  
174    T* allocate(size_t n) { return static_cast<T*>(std::malloc(n * sizeof(T))); }
</span>175    void deallocate(T* p, size_t) { std::free(p); }
176  };
177  template <typename T, typename U>
178  bool operator==(const Mallocator<T>&, const Mallocator<U>&) {
179    return true;
180  }
181  template <typename T, typename U>
182  bool operator!=(const Mallocator<T>&, const Mallocator<U>&) {
183    return false;
184  }
185  TEST(StrCat, CustomAllocator) {
186    using mstring =
187        std::basic_string<char, std::char_traits<char>, Mallocator<char>>;
188    const mstring str1("PARACHUTE OFF A BLIMP INTO MOSCONE!!");
189    const mstring str2("Read this book about coffee tables");
190    std::string result = absl::StrCat(str1, str2);
191    EXPECT_EQ(result,
192              "PARACHUTE OFF A BLIMP INTO MOSCONE!!"
193              "Read this book about coffee tables");
194  }
195  TEST(StrCat, MaxArgs) {
196    std::string result;
197    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a");
198    EXPECT_EQ(result, "123456789a");
199    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b");
200    EXPECT_EQ(result, "123456789ab");
201    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c");
202    EXPECT_EQ(result, "123456789abc");
203    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d");
204    EXPECT_EQ(result, "123456789abcd");
205    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e");
206    EXPECT_EQ(result, "123456789abcde");
207    result =
208        absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f");
209    EXPECT_EQ(result, "123456789abcdef");
210    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
211                          "g");
212    EXPECT_EQ(result, "123456789abcdefg");
213    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
214                          "g", "h");
215    EXPECT_EQ(result, "123456789abcdefgh");
216    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
217                          "g", "h", "i");
218    EXPECT_EQ(result, "123456789abcdefghi");
219    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
220                          "g", "h", "i", "j");
221    EXPECT_EQ(result, "123456789abcdefghij");
222    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
223                          "g", "h", "i", "j", "k");
224    EXPECT_EQ(result, "123456789abcdefghijk");
225    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
226                          "g", "h", "i", "j", "k", "l");
227    EXPECT_EQ(result, "123456789abcdefghijkl");
228    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
229                          "g", "h", "i", "j", "k", "l", "m");
230    EXPECT_EQ(result, "123456789abcdefghijklm");
231    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
232                          "g", "h", "i", "j", "k", "l", "m", "n");
233    EXPECT_EQ(result, "123456789abcdefghijklmn");
234    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
235                          "g", "h", "i", "j", "k", "l", "m", "n", "o");
236    EXPECT_EQ(result, "123456789abcdefghijklmno");
237    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
238                          "g", "h", "i", "j", "k", "l", "m", "n", "o", "p");
239    EXPECT_EQ(result, "123456789abcdefghijklmnop");
240    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
241                          "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q");
242    EXPECT_EQ(result, "123456789abcdefghijklmnopq");
243    result = absl::StrCat(
244        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, "a", "b", "c", "d", "e", "f", "g", "h",
245        "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w",
246        "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L",
247        "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z");
248    EXPECT_EQ(result,
249              "12345678910abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
250  }
251  TEST(StrAppend, Basics) {
252    std::string result = "existing text";
253    std::string strs[] = {"Hello", "Cruel", "World"};
254    std::string stdstrs[] = {
255      "std::Hello",
256      "std::Cruel",
257      "std::World"
258    };
259    absl::string_view pieces[] = {"Hello", "Cruel", "World"};
260    const char* c_strs[] = {
261      "Hello",
262      "Cruel",
263      "World"
264    };
265    int32_t i32s[] = {'H', 'C', 'W'};
266    uint64_t ui64s[] = {12345678910LL, 10987654321LL};
267    std::string::size_type old_size = result.size();
268    absl::StrAppend(&result);
269    EXPECT_EQ(result.size(), old_size);
270    old_size = result.size();
271    absl::StrAppend(&result, strs[0]);
272    EXPECT_EQ(result.substr(old_size), "Hello");
273    old_size = result.size();
274    absl::StrAppend(&result, strs[1], pieces[2]);
275    EXPECT_EQ(result.substr(old_size), "CruelWorld");
276    old_size = result.size();
277    absl::StrAppend(&result, stdstrs[0], ", ", pieces[2]);
278    EXPECT_EQ(result.substr(old_size), "std::Hello, World");
279    old_size = result.size();
280    absl::StrAppend(&result, strs[0], ", ", stdstrs[1], " ", strs[2], "!");
281    EXPECT_EQ(result.substr(old_size), "Hello, std::Cruel World!");
282    old_size = result.size();
283    absl::StrAppend(&result, pieces[0], ", ", pieces[1], " ", pieces[2]);
284    EXPECT_EQ(result.substr(old_size), "Hello, Cruel World");
285    old_size = result.size();
286    absl::StrAppend(&result, c_strs[0], ", ", c_strs[1], " ", c_strs[2]);
287    EXPECT_EQ(result.substr(old_size), "Hello, Cruel World");
288    old_size = result.size();
289    absl::StrAppend(&result, "ASCII ", i32s[0], ", ", i32s[1], " ", i32s[2], "!");
290    EXPECT_EQ(result.substr(old_size), "ASCII 72, 67 87!");
291    old_size = result.size();
292    absl::StrAppend(&result, ui64s[0], ", ", ui64s[1], "!");
293    EXPECT_EQ(result.substr(old_size), "12345678910, 10987654321!");
294    std::string one =
295        "1";  
296    old_size = result.size();
297    absl::StrAppend(&result, "And a ", one.size(), " and a ",
298                    &result[2] - &result[0], " and a ", one, " 2 3 4", "!");
299    EXPECT_EQ(result.substr(old_size), "And a 1 and a 2 and a 1 2 3 4!");
300    old_size = result.size();
301    absl::StrAppend(&result,
302                    "To output a char by ASCII/numeric value, use +: ", '!' + 0);
303    EXPECT_EQ(result.substr(old_size),
304              "To output a char by ASCII/numeric value, use +: 33");
305    old_size = result.size();
306    absl::StrAppend(&result, 1, 22, 333, 4444, 55555, 666666, 7777777, 88888888,
307                    9);
308    EXPECT_EQ(result.substr(old_size), "1223334444555556666667777777888888889");
309    old_size = result.size();
310    absl::StrAppend(
311        &result, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,                           
312        "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",  
313        "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",  
314        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",  
315        "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",  
316        "No limit thanks to C++11's variadic templates");
317    EXPECT_EQ(result.substr(old_size),
318              "12345678910abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
319              "No limit thanks to C++11's variadic templates");
320  }
321  TEST(StrCat, VectorBoolReferenceTypes) {
322    std::vector<bool> v;
323    v.push_back(true);
324    v.push_back(false);
325    std::vector<bool> const& cv = v;
326    std::string result = absl::StrCat(v[0], v[1], cv[0], cv[1]); 
327    EXPECT_EQ(result, "1010");
328  }
329  TEST(StrCat, AvoidsMemcpyWithNullptr) {
330    EXPECT_EQ(absl::StrCat(42, absl::string_view{}), "42");
331    EXPECT_EQ(absl::StrCat(1, 2, 3, 4, 5, absl::string_view{}), "12345");
332    std::string result;
333    absl::StrAppend(&result, 1, 2, 3, 4, 5, absl::string_view{});
334    EXPECT_EQ(result, "12345");
335  }
336  #if GTEST_HAS_DEATH_TEST
337  TEST(StrAppend, Death) {
338    std::string s = "self";
339    ABSL_EXPECT_DEBUG_DEATH(absl::StrAppend(&s, s.c_str() + 1),
340                            "ssertion.*failed");
341    ABSL_EXPECT_DEBUG_DEATH(absl::StrAppend(&s, s), "ssertion.*failed");
342  }
343  #endif  
344  TEST(StrAppend, CornerCases) {
345    std::string result;
346    absl::StrAppend(&result, "");
347    EXPECT_EQ(result, "");
348    absl::StrAppend(&result, "", "");
349    EXPECT_EQ(result, "");
350    absl::StrAppend(&result, "", "", "");
351    EXPECT_EQ(result, "");
352    absl::StrAppend(&result, "", "", "", "");
353    EXPECT_EQ(result, "");
354    absl::StrAppend(&result, "", "", "", "", "");
355    EXPECT_EQ(result, "");
356  }
357  TEST(StrAppend, CornerCasesNonEmptyAppend) {
358    for (std::string result : {"hello", "a string too long to fit in the SSO"}) {
359      const std::string expected = result;
360      absl::StrAppend(&result, "");
361      EXPECT_EQ(result, expected);
362      absl::StrAppend(&result, "", "");
363      EXPECT_EQ(result, expected);
364      absl::StrAppend(&result, "", "", "");
365      EXPECT_EQ(result, expected);
366      absl::StrAppend(&result, "", "", "", "");
367      EXPECT_EQ(result, expected);
368      absl::StrAppend(&result, "", "", "", "", "");
369      EXPECT_EQ(result, expected);
370    }
371  }
372  template <typename IntType>
373  void CheckHex(IntType v, const char* nopad_format, const char* zeropad_format,
374                const char* spacepad_format) {
375    char expected[256];
376    std::string actual = absl::StrCat(absl::Hex(v, absl::kNoPad));
377    snprintf(expected, sizeof(expected), nopad_format, v);
378    EXPECT_EQ(expected, actual) << " decimal value " << v;
379    for (int spec = absl::kZeroPad2; spec <= absl::kZeroPad20; ++spec) {
380      std::string actual =
381          absl::StrCat(absl::Hex(v, static_cast<absl::PadSpec>(spec)));
382      snprintf(expected, sizeof(expected), zeropad_format,
383               spec - absl::kZeroPad2 + 2, v);
384      EXPECT_EQ(expected, actual) << " decimal value " << v;
385    }
386    for (int spec = absl::kSpacePad2; spec <= absl::kSpacePad20; ++spec) {
387      std::string actual =
388          absl::StrCat(absl::Hex(v, static_cast<absl::PadSpec>(spec)));
389      snprintf(expected, sizeof(expected), spacepad_format,
390               spec - absl::kSpacePad2 + 2, v);
391      EXPECT_EQ(expected, actual) << " decimal value " << v;
392    }
393  }
394  template <typename IntType>
395  void CheckDec(IntType v, const char* nopad_format, const char* zeropad_format,
396                const char* spacepad_format) {
397    char expected[256];
398    std::string actual = absl::StrCat(absl::Dec(v, absl::kNoPad));
399    snprintf(expected, sizeof(expected), nopad_format, v);
400    EXPECT_EQ(expected, actual) << " decimal value " << v;
401    for (int spec = absl::kZeroPad2; spec <= absl::kZeroPad20; ++spec) {
402      std::string actual =
403          absl::StrCat(absl::Dec(v, static_cast<absl::PadSpec>(spec)));
404      snprintf(expected, sizeof(expected), zeropad_format,
405               spec - absl::kZeroPad2 + 2, v);
406      EXPECT_EQ(expected, actual)
407          << " decimal value " << v << " format '" << zeropad_format
408          << "' digits " << (spec - absl::kZeroPad2 + 2);
409    }
410    for (int spec = absl::kSpacePad2; spec <= absl::kSpacePad20; ++spec) {
411      std::string actual =
412          absl::StrCat(absl::Dec(v, static_cast<absl::PadSpec>(spec)));
413      snprintf(expected, sizeof(expected), spacepad_format,
414               spec - absl::kSpacePad2 + 2, v);
415      EXPECT_EQ(expected, actual)
416          << " decimal value " << v << " format '" << spacepad_format
417          << "' digits " << (spec - absl::kSpacePad2 + 2);
418    }
419  }
420  void CheckHexDec64(uint64_t v) {
421    unsigned long long ullv = v;  
422    CheckHex(ullv, "%llx", "%0*llx", "%*llx");
423    CheckDec(ullv, "%llu", "%0*llu", "%*llu");
424    long long llv = static_cast<long long>(ullv);  
425    CheckDec(llv, "%lld", "%0*lld", "%*lld");
426    if (sizeof(v) == sizeof(&v)) {
427      auto uintptr = static_cast<uintptr_t>(v);
428      void* ptr = reinterpret_cast<void*>(uintptr);
429      CheckHex(ptr, "%llx", "%0*llx", "%*llx");
430    }
431  }
432  void CheckHexDec32(uint32_t uv) {
433    CheckHex(uv, "%x", "%0*x", "%*x");
434    CheckDec(uv, "%u", "%0*u", "%*u");
435    int32_t v = static_cast<int32_t>(uv);
436    CheckDec(v, "%d", "%0*d", "%*d");
437    if (sizeof(v) == sizeof(&v)) {
438      auto uintptr = static_cast<uintptr_t>(v);
439      void* ptr = reinterpret_cast<void*>(uintptr);
440      CheckHex(ptr, "%x", "%0*x", "%*x");
441    }
442  }
443  void CheckAll(uint64_t v) {
444    CheckHexDec64(v);
445    CheckHexDec32(static_cast<uint32_t>(v));
446  }
447  void TestFastPrints() {
448    for (int i = 0; i < 10000; i++) {
449      CheckAll(i);
450    }
451    CheckAll(std::numeric_limits<uint64_t>::max());
452    CheckAll(std::numeric_limits<uint64_t>::max() - 1);
453    CheckAll(std::numeric_limits<int64_t>::min());
454    CheckAll(std::numeric_limits<int64_t>::min() + 1);
455    CheckAll(std::numeric_limits<uint32_t>::max());
456    CheckAll(std::numeric_limits<uint32_t>::max() - 1);
457    CheckAll(std::numeric_limits<int32_t>::min());
458    CheckAll(std::numeric_limits<int32_t>::min() + 1);
459    CheckAll(999999999);              
460    CheckAll(1000000000);             
461    CheckAll(9999999999);             
462    CheckAll(10000000000);            
463    CheckAll(999999999999999999);     
464    CheckAll(9999999999999999999u);   
465    CheckAll(1000000000000000000);    
466    CheckAll(10000000000000000000u);  
467    CheckAll(999999999876543210);    
468    CheckAll(9999999999876543210u);  
469    CheckAll(0x123456789abcdef0);    
470    CheckAll(0x12345678);
471    int8_t minus_one_8bit = -1;
472    EXPECT_EQ("ff", absl::StrCat(absl::Hex(minus_one_8bit)));
473    int16_t minus_one_16bit = -1;
474    EXPECT_EQ("ffff", absl::StrCat(absl::Hex(minus_one_16bit)));
475  }
476  TEST(Numbers, TestFunctionsMovedOverFromNumbersMain) {
477    TestFastPrints();
478  }
479  struct PointStringify {
480    template <typename FormatSink>
481    friend void AbslStringify(FormatSink& sink, const PointStringify& p) {
482      sink.Append("(");
483      sink.Append(absl::StrCat(p.x));
484      sink.Append(", ");
485      sink.Append(absl::StrCat(p.y));
486      sink.Append(")");
487    }
488    double x = 10.0;
489    double y = 20.0;
490  };
491  TEST(StrCat, AbslStringifyExample) {
492    PointStringify p;
493    EXPECT_EQ(absl::StrCat(p), "(10, 20)");
494    EXPECT_EQ(absl::StrCat("a ", p, " z"), "a (10, 20) z");
495  }
496  struct PointStringifyUsingFormat {
497    template <typename FormatSink>
498    friend void AbslStringify(FormatSink& sink,
499                              const PointStringifyUsingFormat& p) {
500      absl::Format(&sink, "(%g, %g)", p.x, p.y);
501    }
502    double x = 10.0;
503    double y = 20.0;
504  };
505  TEST(StrCat, AbslStringifyExampleUsingFormat) {
506    PointStringifyUsingFormat p;
507    EXPECT_EQ(absl::StrCat(p), "(10, 20)");
508    EXPECT_EQ(absl::StrCat("a ", p, " z"), "a (10, 20) z");
509  }
510  enum class EnumWithStringify { Many = 0, Choices = 1 };
511  template <typename Sink>
512  void AbslStringify(Sink& sink, EnumWithStringify e) {
513    absl::Format(&sink, "%s", e == EnumWithStringify::Many ? "Many" : "Choices");
514  }
515  TEST(StrCat, AbslStringifyWithEnum) {
516    const auto e = EnumWithStringify::Choices;
517    EXPECT_EQ(absl::StrCat(e), "Choices");
518  }
519  }  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-concepts.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_CONCEPTS_HPP_INCLUDED
2  #define BOOST_REGEX_CONCEPTS_HPP_INCLUDED
3  #include <boost/concept_archetype.hpp>
4  #include <boost/concept_check.hpp>
5  #include <boost/type_traits/is_enum.hpp>
6  #include <boost/type_traits/is_base_and_derived.hpp>
7  #include <boost/static_assert.hpp>
8  #ifndef BOOST_TEST_TR1_REGEX
9  #include <boost/regex.hpp>
10  #endif
11  #include <bitset>
12  #include <vector>
13  #include <ostream>
14  #ifdef BOOST_REGEX_CXX03
15  #define RW_NS boost
16  #else
17  #define RW_NS std
18  #endif
19  namespace boost{
20  typedef std::bitset<512> bitmask_archetype;
21  struct char_architype
22  {
23     char_architype();
24     char_architype(const char_architype&);
25     char_architype& operator=(const char_architype&);
26     char_architype(unsigned long val);
27     bool operator==(const char_architype&)const;
28     bool operator!=(const char_architype&)const;
29     bool operator<(const char_architype&)const;
30     bool operator<=(const char_architype&)const;
31     bool operator>=(const char_architype&)const;
32     bool operator>(const char_architype&)const;
33     operator long()const;
34  };
35  inline long hash_value(char_architype val)
36  {  return val;  }
37  } 
38  namespace std{
39     template<> struct char_traits<boost::char_architype>
40     {
41        typedef boost::char_architype char_type;
42     };
43  }
44  template <class T>
45  class allocator_architype
46  {
47  public:
48     typedef T* pointer;
49     typedef const T* const_pointer;
50     typedef T& reference;
51     typedef const T& const_reference;
52     typedef T value_type;
53     typedef unsigned size_type;
54     typedef int difference_type;
55     template <class U>
56     struct rebind
57     {
58        typedef allocator_architype<U> other;
59     };
60     pointer address(reference r){ return &r; }
61     const_pointer address(const_reference r) { return &r; }
62     pointer allocate(size_type n) { return static_cast<pointer>(std::malloc(n)); }
63     pointer allocate(size_type n, pointer) { return static_cast<pointer>(std::malloc(n)); }
64     void deallocate(pointer p, size_type) { std::free(p); }
65     size_type max_size()const { return UINT_MAX; }
66     allocator_architype(){}
67     allocator_architype(const allocator_architype&){}
<span onclick='openModal()' class='match'>68     template <class Other>
69     allocator_architype(const allocator_architype<Other>&){}
70     void construct(pointer p, const_reference r) { new (p)T(r); }
</span>71     void destroy(pointer p) { p->~T(); }
72  };
73  template <class T>
74  bool operator == (const allocator_architype<T>&, const allocator_architype<T>&) {return true; }
75  template <class T>
76  bool operator != (const allocator_architype<T>&, const allocator_architype<T>&) { return false; }
77  namespace boost{
78  template <class charT>
79  struct regex_traits_architype
80  {
81  public:
82     regex_traits_architype(){}
83     typedef charT char_type;
84     typedef std::vector<char_type> string_type;
85     typedef copy_constructible_archetype<assignable_archetype<> > locale_type;
86     typedef bitmask_archetype char_class_type;
87     static std::size_t length(const char_type* ) { return 0; }
88     charT translate(charT ) const { return charT(); }
89     charT translate_nocase(charT ) const { return static_object<charT>::get(); }
90     template <class ForwardIterator>
91     string_type transform(ForwardIterator , ForwardIterator ) const
92     { return static_object<string_type>::get(); }
93     template <class ForwardIterator>
94     string_type transform_primary(ForwardIterator , ForwardIterator ) const
95     { return static_object<string_type>::get(); }
96     template <class ForwardIterator>
97     char_class_type lookup_classname(ForwardIterator , ForwardIterator ) const
98     { return static_object<char_class_type>::get(); }
99     template <class ForwardIterator>
100     string_type lookup_collatename(ForwardIterator , ForwardIterator ) const
101     { return static_object<string_type>::get(); }
102     bool isctype(charT, char_class_type) const
103     { return false; }
104     int value(charT, int) const
105     { return 0; }
106     locale_type imbue(locale_type l)
107     { return l; }
108     locale_type getloc()const
109     { return static_object<locale_type>::get(); }
110  private:
111     regex_traits_architype(const regex_traits_architype&){}
112     regex_traits_architype& operator=(const regex_traits_architype&){ return *this; }
113  };
114  #ifndef BOOST_TEST_TR1_REGEX
115  namespace global_regex_namespace = ::boost;
116  #else
117  namespace global_regex_namespace = ::std::tr1;
118  #endif
119  template <class Bitmask>
120  struct BitmaskConcept
121  {
122     void constraints() 
123     {
124        function_requires<CopyConstructibleConcept<Bitmask> >();
125        function_requires<AssignableConcept<Bitmask> >();
126        m_mask1 = m_mask2 | m_mask3;
127        m_mask1 = m_mask2 & m_mask3;
128        m_mask1 = m_mask2 ^ m_mask3;
129        m_mask1 = ~m_mask2;
130        m_mask1 |= m_mask2;
131        m_mask1 &= m_mask2;
132        m_mask1 ^= m_mask2;
133     }
134     Bitmask m_mask1, m_mask2, m_mask3;
135  };
136  template <class traits>
137  struct RegexTraitsConcept
138  {
139     RegexTraitsConcept();
140     typedef typename traits::char_type char_type;
141     typedef typename traits::string_type string_type;
142     typedef typename traits::locale_type locale_type;
143     typedef typename traits::char_class_type char_class_type;
144     void constraints() 
145     {
146        function_requires<RandomAccessContainerConcept<string_type> >();
147        function_requires<DefaultConstructibleConcept<locale_type> >();
148        function_requires<CopyConstructibleConcept<locale_type> >();
149        function_requires<AssignableConcept<locale_type> >();
150        function_requires<BitmaskConcept<char_class_type> >();
151        std::size_t n = traits::length(m_pointer);
152        ignore_unused_variable_warning(n);
153        char_type c = m_ctraits.translate(m_char);
154        ignore_unused_variable_warning(c);
155        c = m_ctraits.translate_nocase(m_char);
156        string_type s1 = m_ctraits.transform(m_pointer, m_pointer);
157        ignore_unused_variable_warning(s1);
158        string_type s2 = m_ctraits.transform_primary(m_pointer, m_pointer);
159        ignore_unused_variable_warning(s2);
160        char_class_type cc = m_ctraits.lookup_classname(m_pointer, m_pointer);
161        ignore_unused_variable_warning(cc);
162        string_type s3 = m_ctraits.lookup_collatename(m_pointer, m_pointer);
163        ignore_unused_variable_warning(s3);
164        bool b = m_ctraits.isctype(m_char, cc);
165        ignore_unused_variable_warning(b);
166        int v = m_ctraits.value(m_char, 16);
167        ignore_unused_variable_warning(v);
168        locale_type l(m_ctraits.getloc());
169        m_traits.imbue(l);
170        ignore_unused_variable_warning(l);
171     }
172     traits m_traits;
173     const traits m_ctraits;
174     const char_type* m_pointer;
175     char_type m_char;
176  private:
177     RegexTraitsConcept& operator=(RegexTraitsConcept&);
178  };
179  template <class Regex>
180  struct regex_traits_computer;
181  template <class charT, class traits>
182  struct regex_traits_computer< global_regex_namespace::basic_regex<charT, traits> >
183  {
184     typedef traits type;
185  };
186  template <class Regex>
187  struct BaseRegexConcept
188  {
189     typedef typename Regex::value_type value_type;
190     typedef typename Regex::flag_type flag_type;
191     typedef typename Regex::locale_type locale_type;
192     typedef input_iterator_archetype<value_type> input_iterator_type;
193     typedef const value_type* pointer_type;
194     typedef bidirectional_iterator_archetype<value_type> BidiIterator;
195     typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;
196     typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;
197     typedef global_regex_namespace::match_results<BidiIterator> match_results_default_type;
198     typedef output_iterator_archetype<value_type> OutIterator;
199     typedef typename regex_traits_computer<Regex>::type traits_type;
200     typedef global_regex_namespace::regex_iterator<BidiIterator, value_type, traits_type> regex_iterator_type;
201     typedef global_regex_namespace::regex_token_iterator<BidiIterator, value_type, traits_type> regex_token_iterator_type;
202     void global_constraints()
203     {
204        function_requires<BitmaskConcept<global_regex_namespace::regex_constants::syntax_option_type> >();
205        global_regex_namespace::regex_constants::syntax_option_type opts
206           = global_regex_namespace::regex_constants::icase
207           | global_regex_namespace::regex_constants::nosubs
208           | global_regex_namespace::regex_constants::optimize
209           | global_regex_namespace::regex_constants::collate
210           | global_regex_namespace::regex_constants::ECMAScript
211           | global_regex_namespace::regex_constants::basic
212           | global_regex_namespace::regex_constants::extended
213           | global_regex_namespace::regex_constants::awk
214           | global_regex_namespace::regex_constants::grep
215           | global_regex_namespace::regex_constants::egrep;
216        ignore_unused_variable_warning(opts);
217        function_requires<BitmaskConcept<global_regex_namespace::regex_constants::match_flag_type> >();
218        global_regex_namespace::regex_constants::match_flag_type mopts
219           = global_regex_namespace::regex_constants::match_default
220           | global_regex_namespace::regex_constants::match_not_bol
221           | global_regex_namespace::regex_constants::match_not_eol
222           | global_regex_namespace::regex_constants::match_not_bow
223           | global_regex_namespace::regex_constants::match_not_eow
224           | global_regex_namespace::regex_constants::match_any
225           | global_regex_namespace::regex_constants::match_not_null
226           | global_regex_namespace::regex_constants::match_continuous
227           | global_regex_namespace::regex_constants::match_prev_avail
228           | global_regex_namespace::regex_constants::format_default
229           | global_regex_namespace::regex_constants::format_sed
230           | global_regex_namespace::regex_constants::format_no_copy
231           | global_regex_namespace::regex_constants::format_first_only;
232        ignore_unused_variable_warning(mopts);
233        BOOST_STATIC_ASSERT((::boost::is_enum<global_regex_namespace::regex_constants::error_type>::value));
234        global_regex_namespace::regex_constants::error_type e1 = global_regex_namespace::regex_constants::error_collate;
235        ignore_unused_variable_warning(e1);
236        e1 = global_regex_namespace::regex_constants::error_ctype;
237        ignore_unused_variable_warning(e1);
238        e1 = global_regex_namespace::regex_constants::error_escape;
239        ignore_unused_variable_warning(e1);
240        e1 = global_regex_namespace::regex_constants::error_backref;
241        ignore_unused_variable_warning(e1);
242        e1 = global_regex_namespace::regex_constants::error_brack;
243        ignore_unused_variable_warning(e1);
244        e1 = global_regex_namespace::regex_constants::error_paren;
245        ignore_unused_variable_warning(e1);
246        e1 = global_regex_namespace::regex_constants::error_brace;
247        ignore_unused_variable_warning(e1);
248        e1 = global_regex_namespace::regex_constants::error_badbrace;
249        ignore_unused_variable_warning(e1);
250        e1 = global_regex_namespace::regex_constants::error_range;
251        ignore_unused_variable_warning(e1);
252        e1 = global_regex_namespace::regex_constants::error_space;
253        ignore_unused_variable_warning(e1);
254        e1 = global_regex_namespace::regex_constants::error_badrepeat;
255        ignore_unused_variable_warning(e1);
256        e1 = global_regex_namespace::regex_constants::error_complexity;
257        ignore_unused_variable_warning(e1);
258        e1 = global_regex_namespace::regex_constants::error_stack;
259        ignore_unused_variable_warning(e1);
260        BOOST_STATIC_ASSERT((::boost::is_base_and_derived<std::runtime_error, global_regex_namespace::regex_error>::value  ));
261        const global_regex_namespace::regex_error except(e1);
262        e1 = except.code();
263        typedef typename Regex::value_type regex_value_type;
264        function_requires< RegexTraitsConcept<global_regex_namespace::regex_traits<char> > >();
265        function_requires< BaseRegexConcept<global_regex_namespace::basic_regex<char> > >();
266     }
267     void constraints() 
268     {
269        global_constraints();
270        BOOST_STATIC_ASSERT((::boost::is_same< flag_type, global_regex_namespace::regex_constants::syntax_option_type>::value));
271        flag_type opts
272           = Regex::icase
273           | Regex::nosubs
274           | Regex::optimize
275           | Regex::collate
276           | Regex::ECMAScript
277           | Regex::basic
278           | Regex::extended
279           | Regex::awk
280           | Regex::grep
281           | Regex::egrep;
282        ignore_unused_variable_warning(opts);
283        function_requires<DefaultConstructibleConcept<Regex> >();
284        function_requires<CopyConstructibleConcept<Regex> >();
285        Regex e1(m_pointer);
286        ignore_unused_variable_warning(e1);
287        Regex e2(m_pointer, m_flags);
288        ignore_unused_variable_warning(e2);
289        Regex e3(m_pointer, m_size, m_flags);
290        ignore_unused_variable_warning(e3);
291        Regex e4(in1, in2);
292        ignore_unused_variable_warning(e4);
293        Regex e5(in1, in2, m_flags);
294        ignore_unused_variable_warning(e5);
295        Regex e;
296        e = m_pointer;
297        e = e1;
298        e.assign(e1);
299        e.assign(m_pointer);
300        e.assign(m_pointer, m_flags);
301        e.assign(m_pointer, m_size, m_flags);
302        e.assign(in1, in2);
303        e.assign(in1, in2, m_flags);
304        const Regex ce;
305        typename Regex::size_type i = ce.mark_count();
306        ignore_unused_variable_warning(i);
307        m_flags = ce.flags();
308        e.imbue(ce.getloc());
309        e.swap(e1);
310        global_regex_namespace::swap(e, e1);
311        BOOST_STATIC_ASSERT((::boost::is_base_and_derived<std::pair<BidiIterator, BidiIterator>, sub_match_type>::value));
312        typedef typename sub_match_type::value_type sub_value_type;
313        typedef typename sub_match_type::difference_type sub_diff_type;
314        typedef typename sub_match_type::iterator sub_iter_type;
315        BOOST_STATIC_ASSERT((::boost::is_same<sub_value_type, value_type>::value));
316        BOOST_STATIC_ASSERT((::boost::is_same<sub_iter_type, BidiIterator>::value));
317        bool b = m_sub.matched;
318        ignore_unused_variable_warning(b);
319        BidiIterator bi = m_sub.first;
320        ignore_unused_variable_warning(bi);
321        bi = m_sub.second;
322        ignore_unused_variable_warning(bi);
323        sub_diff_type diff = m_sub.length();
324        ignore_unused_variable_warning(diff);
325        typedef typename match_results_type::value_type mr_value_type;
326        typedef typename match_results_type::const_reference mr_const_reference;
327        typedef typename match_results_type::reference mr_reference;
328        typedef typename match_results_type::const_iterator mr_const_iterator;
329        typedef typename match_results_type::iterator mr_iterator;
330        typedef typename match_results_type::difference_type mr_difference_type;
331        typedef typename match_results_type::size_type mr_size_type;
332        typedef typename match_results_type::allocator_type mr_allocator_type;
333        typedef typename match_results_type::char_type mr_char_type;
334        typedef typename match_results_type::string_type mr_string_type;
335        match_results_type m1;
336        mr_allocator_type at;
337        match_results_type m2(at);
338        match_results_type m3(m1);
339        m1 = m2;
340        int ival = 0;
341        mr_size_type mrs = m_cresults.size();
342        ignore_unused_variable_warning(mrs);
343        mrs = m_cresults.max_size();
344        ignore_unused_variable_warning(mrs);
345        b = m_cresults.empty();
346        ignore_unused_variable_warning(b);
347        mr_difference_type mrd = m_cresults.length();
348        ignore_unused_variable_warning(mrd);
349        mrd = m_cresults.length(ival);
350        ignore_unused_variable_warning(mrd);
351        mrd = m_cresults.position();
352        ignore_unused_variable_warning(mrd);
353        mrd = m_cresults.position(mrs);
354        ignore_unused_variable_warning(mrd);
355        mr_const_reference mrcr = m_cresults[ival];
356        ignore_unused_variable_warning(mrcr);
357        mr_const_reference mrcr2 = m_cresults.prefix();
358        ignore_unused_variable_warning(mrcr2);
359        mr_const_reference mrcr3 = m_cresults.suffix();
360        ignore_unused_variable_warning(mrcr3);
361        mr_const_iterator mrci = m_cresults.begin();
362        ignore_unused_variable_warning(mrci);
363        mrci = m_cresults.end();
364        ignore_unused_variable_warning(mrci);
365        (void) m_cresults.get_allocator();
366        m_results.swap(m_results);
367        global_regex_namespace::swap(m_results, m_results);
368        b = global_regex_namespace::regex_match(m_in, m_in, m_results, e);
369        ignore_unused_variable_warning(b);
370        b = global_regex_namespace::regex_match(m_in, m_in, m_results, e, m_mft);
371        ignore_unused_variable_warning(b);
372        b = global_regex_namespace::regex_match(m_in, m_in, e);
373        ignore_unused_variable_warning(b);
374        b = global_regex_namespace::regex_match(m_in, m_in, e, m_mft);
375        ignore_unused_variable_warning(b);
376        b = global_regex_namespace::regex_match(m_pointer, m_pmatch, e);
377        ignore_unused_variable_warning(b);
378        b = global_regex_namespace::regex_match(m_pointer, m_pmatch, e, m_mft);
379        ignore_unused_variable_warning(b);
380        b = global_regex_namespace::regex_match(m_pointer, e);
381        ignore_unused_variable_warning(b);
382        b = global_regex_namespace::regex_match(m_pointer, e, m_mft);
383        ignore_unused_variable_warning(b);
384        b = global_regex_namespace::regex_search(m_in, m_in, m_results, e);
385        ignore_unused_variable_warning(b);
386        b = global_regex_namespace::regex_search(m_in, m_in, m_results, e, m_mft);
387        ignore_unused_variable_warning(b);
388        b = global_regex_namespace::regex_search(m_in, m_in, e);
389        ignore_unused_variable_warning(b);
390        b = global_regex_namespace::regex_search(m_in, m_in, e, m_mft);
391        ignore_unused_variable_warning(b);
392        b = global_regex_namespace::regex_search(m_pointer, m_pmatch, e);
393        ignore_unused_variable_warning(b);
394        b = global_regex_namespace::regex_search(m_pointer, m_pmatch, e, m_mft);
395        ignore_unused_variable_warning(b);
396        b = global_regex_namespace::regex_search(m_pointer, e);
397        ignore_unused_variable_warning(b);
398        b = global_regex_namespace::regex_search(m_pointer, e, m_mft);
399        ignore_unused_variable_warning(b);
400        typedef typename regex_iterator_type::regex_type rit_regex_type;
401        typedef typename regex_iterator_type::value_type rit_value_type;
402        typedef typename regex_iterator_type::difference_type rit_difference_type;
403        typedef typename regex_iterator_type::pointer rit_pointer;
404        typedef typename regex_iterator_type::reference rit_reference;
405        typedef typename regex_iterator_type::iterator_category rit_iterator_category;
406        BOOST_STATIC_ASSERT((::boost::is_same<rit_regex_type, Regex>::value));
407        BOOST_STATIC_ASSERT((::boost::is_same<rit_value_type, match_results_default_type>::value));
408        BOOST_STATIC_ASSERT((::boost::is_same<rit_difference_type, std::ptrdiff_t>::value));
409        BOOST_STATIC_ASSERT((::boost::is_same<rit_pointer, const match_results_default_type*>::value));
410        BOOST_STATIC_ASSERT((::boost::is_same<rit_reference, const match_results_default_type&>::value));
411        BOOST_STATIC_ASSERT((::boost::is_convertible<rit_iterator_category*, std::forward_iterator_tag*>::value));
412        function_requires<ForwardIteratorConcept<regex_iterator_type> >();
413        regex_iterator_type iter1(m_in, m_in, e);
414        ignore_unused_variable_warning(iter1);
415        regex_iterator_type iter2(m_in, m_in, e, m_mft);
416        ignore_unused_variable_warning(iter2);
417        typedef typename regex_token_iterator_type::regex_type rtit_regex_type;
418        typedef typename regex_token_iterator_type::value_type rtit_value_type;
419        typedef typename regex_token_iterator_type::difference_type rtit_difference_type;
420        typedef typename regex_token_iterator_type::pointer rtit_pointer;
421        typedef typename regex_token_iterator_type::reference rtit_reference;
422        typedef typename regex_token_iterator_type::iterator_category rtit_iterator_category;
423        BOOST_STATIC_ASSERT((::boost::is_same<rtit_regex_type, Regex>::value));
424        BOOST_STATIC_ASSERT((::boost::is_same<rtit_value_type, sub_match_type>::value));
425        BOOST_STATIC_ASSERT((::boost::is_same<rtit_difference_type, std::ptrdiff_t>::value));
426        BOOST_STATIC_ASSERT((::boost::is_same<rtit_pointer, const sub_match_type*>::value));
427        BOOST_STATIC_ASSERT((::boost::is_same<rtit_reference, const sub_match_type&>::value));
428        BOOST_STATIC_ASSERT((::boost::is_convertible<rtit_iterator_category*, std::forward_iterator_tag*>::value));
429        function_requires<ForwardIteratorConcept<regex_token_iterator_type> >();
430        regex_token_iterator_type ti1(m_in, m_in, e);
431        ignore_unused_variable_warning(ti1);
432        regex_token_iterator_type ti2(m_in, m_in, e, 0);
433        ignore_unused_variable_warning(ti2);
434        regex_token_iterator_type ti3(m_in, m_in, e, 0, m_mft);
435        ignore_unused_variable_warning(ti3);
436        std::vector<int> subs;
437        regex_token_iterator_type ti4(m_in, m_in, e, subs);
438        ignore_unused_variable_warning(ti4);
439        regex_token_iterator_type ti5(m_in, m_in, e, subs, m_mft);
440        ignore_unused_variable_warning(ti5);
441        static const int i_array[3] = { 1, 2, 3, };
442        regex_token_iterator_type ti6(m_in, m_in, e, i_array);
443        ignore_unused_variable_warning(ti6);
444        regex_token_iterator_type ti7(m_in, m_in, e, i_array, m_mft);
445        ignore_unused_variable_warning(ti7);
446     }
447     pointer_type m_pointer;
448     flag_type m_flags;
449     std::size_t m_size;
450     input_iterator_type in1, in2;
451     const sub_match_type m_sub;
452     const value_type m_char;
453     match_results_type m_results;
454     const match_results_type m_cresults;
455     OutIterator m_out;
456     BidiIterator m_in;
457     global_regex_namespace::regex_constants::match_flag_type m_mft;
458     global_regex_namespace::match_results<
459        pointer_type, 
460        allocator_architype<global_regex_namespace::sub_match<pointer_type> > > 
461        m_pmatch;
462     BaseRegexConcept();
463     BaseRegexConcept(const BaseRegexConcept&);
464     BaseRegexConcept& operator=(const BaseRegexConcept&);
465  };
466  template <class Regex>
467  struct RegexConcept
468  {
469     typedef typename Regex::value_type value_type;
470     typedef typename Regex::flag_type flag_type;
471     typedef typename Regex::locale_type locale_type;
472     typedef const value_type* pointer_type;
473     typedef std::basic_string<value_type> string_type;
474     typedef boost::bidirectional_iterator_archetype<value_type> BidiIterator;
475     typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;
476     typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;
477     typedef output_iterator_archetype<value_type> OutIterator;
478     void constraints() 
479     {
480        function_requires<BaseRegexConcept<Regex> >();
481        Regex e1(m_string);
482        ignore_unused_variable_warning(e1);
483        Regex e2(m_string, m_flags);
484        ignore_unused_variable_warning(e2);
485        Regex e;
486        e = m_string;
487        e.assign(m_string);
488        e.assign(m_string, m_flags);
489        string_type s(m_sub);
490        ignore_unused_variable_warning(s);
491        s = m_sub.str();
492        ignore_unused_variable_warning(s);
493        int i = m_sub.compare(m_string);
494        ignore_unused_variable_warning(i);
495        int i2 = m_sub.compare(m_sub);
496        ignore_unused_variable_warning(i2);
497        i2 = m_sub.compare(m_pointer);
498        ignore_unused_variable_warning(i2);
499        bool b = m_sub == m_sub;
500        ignore_unused_variable_warning(b);
501        b = m_sub != m_sub;
502        ignore_unused_variable_warning(b);
503        b = m_sub <= m_sub;
504        ignore_unused_variable_warning(b);
505        b = m_sub <= m_sub;
506        ignore_unused_variable_warning(b);
507        b = m_sub > m_sub;
508        ignore_unused_variable_warning(b);
509        b = m_sub >= m_sub;
510        ignore_unused_variable_warning(b);
511        b = m_sub == m_pointer;
512        ignore_unused_variable_warning(b);
513        b = m_sub != m_pointer;
514        ignore_unused_variable_warning(b);
515        b = m_sub <= m_pointer;
516        ignore_unused_variable_warning(b);
517        b = m_sub <= m_pointer;
518        ignore_unused_variable_warning(b);
519        b = m_sub > m_pointer;
520        ignore_unused_variable_warning(b);
521        b = m_sub >= m_pointer;
522        ignore_unused_variable_warning(b);
523        b = m_pointer == m_sub;
524        ignore_unused_variable_warning(b);
525        b = m_pointer != m_sub;
526        ignore_unused_variable_warning(b);
527        b = m_pointer <= m_sub;
528        ignore_unused_variable_warning(b);
529        b = m_pointer <= m_sub;
530        ignore_unused_variable_warning(b);
531        b = m_pointer > m_sub;
532        ignore_unused_variable_warning(b);
533        b = m_pointer >= m_sub;
534        ignore_unused_variable_warning(b);
535        b = m_sub == m_char;
536        ignore_unused_variable_warning(b);
537        b = m_sub != m_char;
538        ignore_unused_variable_warning(b);
539        b = m_sub <= m_char;
540        ignore_unused_variable_warning(b);
541        b = m_sub <= m_char;
542        ignore_unused_variable_warning(b);
543        b = m_sub > m_char;
544        ignore_unused_variable_warning(b);
545        b = m_sub >= m_char;
546        ignore_unused_variable_warning(b);
547        b = m_char == m_sub;
548        ignore_unused_variable_warning(b);
549        b = m_char != m_sub;
550        ignore_unused_variable_warning(b);
551        b = m_char <= m_sub;
552        ignore_unused_variable_warning(b);
553        b = m_char <= m_sub;
554        ignore_unused_variable_warning(b);
555        b = m_char > m_sub;
556        ignore_unused_variable_warning(b);
557        b = m_char >= m_sub;
558        ignore_unused_variable_warning(b);
559        b = m_sub == m_string;
560        ignore_unused_variable_warning(b);
561        b = m_sub != m_string;
562        ignore_unused_variable_warning(b);
563        b = m_sub <= m_string;
564        ignore_unused_variable_warning(b);
565        b = m_sub <= m_string;
566        ignore_unused_variable_warning(b);
567        b = m_sub > m_string;
568        ignore_unused_variable_warning(b);
569        b = m_sub >= m_string;
570        ignore_unused_variable_warning(b);
571        b = m_string == m_sub;
572        ignore_unused_variable_warning(b);
573        b = m_string != m_sub;
574        ignore_unused_variable_warning(b);
575        b = m_string <= m_sub;
576        ignore_unused_variable_warning(b);
577        b = m_string <= m_sub;
578        ignore_unused_variable_warning(b);
579        b = m_string > m_sub;
580        ignore_unused_variable_warning(b);
581        b = m_string >= m_sub;
582        ignore_unused_variable_warning(b);
583        m_string = m_results.str();
584        ignore_unused_variable_warning(m_string);
585        m_string = m_results.str(0);
586        ignore_unused_variable_warning(m_string);
587        m_out = m_cresults.format(m_out, m_string);
588        m_out = m_cresults.format(m_out, m_string, m_mft);
589        m_string = m_cresults.format(m_string);
590        ignore_unused_variable_warning(m_string);
591        m_string = m_cresults.format(m_string, m_mft);
592        ignore_unused_variable_warning(m_string);
593        b = global_regex_namespace::regex_match(m_string, m_smatch, e);
594        ignore_unused_variable_warning(b);
595        b = global_regex_namespace::regex_match(m_string, m_smatch, e, m_mft);
596        ignore_unused_variable_warning(b);
597        b = global_regex_namespace::regex_match(m_string, e);
598        ignore_unused_variable_warning(b);
599        b = global_regex_namespace::regex_match(m_string, e, m_mft);
600        ignore_unused_variable_warning(b);
601        b = global_regex_namespace::regex_search(m_string, m_smatch, e);
602        ignore_unused_variable_warning(b);
603        b = global_regex_namespace::regex_search(m_string, m_smatch, e, m_mft);
604        ignore_unused_variable_warning(b);
605        b = global_regex_namespace::regex_search(m_string, e);
606        ignore_unused_variable_warning(b);
607        b = global_regex_namespace::regex_search(m_string, e, m_mft);
608        ignore_unused_variable_warning(b);
609        m_out = global_regex_namespace::regex_replace(m_out, m_in, m_in, e, m_string, m_mft);
610        m_out = global_regex_namespace::regex_replace(m_out, m_in, m_in, e, m_string);
611        m_string = global_regex_namespace::regex_replace(m_string, e, m_string, m_mft);
612        ignore_unused_variable_warning(m_string);
613        m_string = global_regex_namespace::regex_replace(m_string, e, m_string);
614        ignore_unused_variable_warning(m_string);
615     }
616     flag_type m_flags;
617     string_type m_string;
618     const sub_match_type m_sub;
619     match_results_type m_results;
620     pointer_type m_pointer;
621     value_type m_char;
622     const match_results_type m_cresults;
623     OutIterator m_out;
624     BidiIterator m_in;
625     global_regex_namespace::regex_constants::match_flag_type m_mft;
626     global_regex_namespace::match_results<typename string_type::const_iterator, allocator_architype<global_regex_namespace::sub_match<typename string_type::const_iterator> > > m_smatch;
627     RegexConcept();
628     RegexConcept(const RegexConcept&);
629     RegexConcept& operator=(const RegexConcept&);
630  };
631  #ifndef BOOST_REGEX_TEST_STD
632  template <class M>
633  struct functor1
634  {
635     typedef typename M::char_type char_type;
636     const char_type* operator()(const M&)const
637     {
638        static const char_type c = static_cast<char_type>(0);
639        return &c;
640     }
641  };
642  template <class M>
643  struct functor1b
644  {
645     typedef typename M::char_type char_type;
646     std::vector<char_type> operator()(const M&)const
647     {
648        static const std::vector<char_type> c;
649        return c;
650     }
651  };
652  template <class M>
653  struct functor2
654  {
655     template <class O>
656     O operator()(const M& &bsol;*m*/, O i)const
657     {
658        return i;
659     }
660  };
661  template <class M>
662  struct functor3
663  {
664     template <class O>
665     O operator()(const M& &bsol;*m*/, O i, regex_constants::match_flag_type)const
666     {
667        return i;
668     }
669  };
670  template <class Regex>
671  struct BoostRegexConcept
672  {
673     typedef typename Regex::value_type value_type;
674     typedef typename Regex::size_type size_type;
675     typedef typename Regex::flag_type flag_type;
676     typedef typename Regex::locale_type locale_type;
677     typedef const value_type* pointer_type;
678     typedef std::basic_string<value_type> string_type;
679     typedef typename Regex::const_iterator const_iterator;
680     typedef bidirectional_iterator_archetype<value_type> BidiIterator;
681     typedef output_iterator_archetype<value_type> OutputIterator;
682     typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;
683     typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;
684     typedef global_regex_namespace::match_results<BidiIterator> match_results_default_type;
685     void constraints() 
686     {
687        global_regex_namespace::regex_constants::match_flag_type mopts
688           = global_regex_namespace::regex_constants::match_default
689           | global_regex_namespace::regex_constants::match_not_bol
690           | global_regex_namespace::regex_constants::match_not_eol
691           | global_regex_namespace::regex_constants::match_not_bow
692           | global_regex_namespace::regex_constants::match_not_eow
693           | global_regex_namespace::regex_constants::match_any
694           | global_regex_namespace::regex_constants::match_not_null
695           | global_regex_namespace::regex_constants::match_continuous
696           | global_regex_namespace::regex_constants::match_partial
697           | global_regex_namespace::regex_constants::match_prev_avail
698           | global_regex_namespace::regex_constants::format_default
699           | global_regex_namespace::regex_constants::format_sed
700           | global_regex_namespace::regex_constants::format_perl
701           | global_regex_namespace::regex_constants::format_no_copy
702           | global_regex_namespace::regex_constants::format_first_only;
703        (void)mopts;
704        function_requires<RegexConcept<Regex> >();
705        const global_regex_namespace::regex_error except(global_regex_namespace::regex_constants::error_collate);
706        std::ptrdiff_t pt = except.position();
707        ignore_unused_variable_warning(pt);
708        const Regex ce, ce2;
709  #ifndef BOOST_NO_STD_LOCALE
710        m_stream << ce;
711  #endif
712        unsigned i = ce.error_code();
713        ignore_unused_variable_warning(i);
714        pointer_type p = ce.expression();
715        ignore_unused_variable_warning(p);
716        int i2 = ce.compare(ce2);
717        ignore_unused_variable_warning(i2);
718        bool b = ce == ce2;
719        ignore_unused_variable_warning(b);
720        b = ce.empty();
721        ignore_unused_variable_warning(b);
722        b = ce != ce2;
723        ignore_unused_variable_warning(b);
724        b = ce < ce2;
725        ignore_unused_variable_warning(b);
726        b = ce > ce2;
727        ignore_unused_variable_warning(b);
728        b = ce <= ce2;
729        ignore_unused_variable_warning(b);
730        b = ce >= ce2;
731        ignore_unused_variable_warning(b);
732        i = ce.status();
733        ignore_unused_variable_warning(i);
734        size_type s = ce.max_size();
735        ignore_unused_variable_warning(s);
736        s = ce.size();
737        ignore_unused_variable_warning(s);
738        const_iterator pi = ce.begin();
739        ignore_unused_variable_warning(pi);
740        pi = ce.end();
741        ignore_unused_variable_warning(pi);
742        string_type s2 = ce.str();
743        ignore_unused_variable_warning(s2);
744        m_string = m_sub + m_sub;
745        ignore_unused_variable_warning(m_string);
746        m_string = m_sub + m_pointer;
747        ignore_unused_variable_warning(m_string);
748        m_string = m_pointer + m_sub;
749        ignore_unused_variable_warning(m_string);
750        m_string = m_sub + m_string;
751        ignore_unused_variable_warning(m_string);
752        m_string = m_string + m_sub;
753        ignore_unused_variable_warning(m_string);
754        m_string = m_sub + m_char;
755        ignore_unused_variable_warning(m_string);
756        m_string = m_char + m_sub;
757        ignore_unused_variable_warning(m_string);
758        m_sub = m_cresults[&m_char];
759        ignore_unused_variable_warning(m_sub);
760        m_sub = m_cresults[m_string];
761        ignore_unused_variable_warning(m_sub);
762        m_sub = m_cresults[""];
763        ignore_unused_variable_warning(m_sub);
764        m_sub = m_cresults[std::string("")];
765        ignore_unused_variable_warning(m_sub);
766        m_string = m_cresults.str(&m_char);
767        ignore_unused_variable_warning(m_string);
768        m_string = m_cresults.str(m_string);
769        ignore_unused_variable_warning(m_string);
770        m_string = m_cresults.str("");
771        ignore_unused_variable_warning(m_string);
772        m_string = m_cresults.str(std::string(""));
773        ignore_unused_variable_warning(m_string);
774        typename match_results_type::difference_type diff;
775        diff = m_cresults.length(&m_char);
776        ignore_unused_variable_warning(diff);
777        diff = m_cresults.length(m_string);
778        ignore_unused_variable_warning(diff);
779        diff = m_cresults.length("");
780        ignore_unused_variable_warning(diff);
781        diff = m_cresults.length(std::string(""));
782        ignore_unused_variable_warning(diff);
783        diff = m_cresults.position(&m_char);
784        ignore_unused_variable_warning(diff);
785        diff = m_cresults.position(m_string);
786        ignore_unused_variable_warning(diff);
787        diff = m_cresults.position("");
788        ignore_unused_variable_warning(diff);
789        diff = m_cresults.position(std::string(""));
790        ignore_unused_variable_warning(diff);
791  #ifndef BOOST_NO_STD_LOCALE
792        m_stream << m_sub;
793        m_stream << m_cresults;
794  #endif
795        regex_constants::match_flag_type f = regex_constants::match_default;
796        OutputIterator out = static_object<OutputIterator>::get();
797        functor3<match_results_default_type> func3;
798        functor2<match_results_default_type> func2;
799        functor1<match_results_default_type> func1;
800        functor3<match_results_type> func3b;
801        functor2<match_results_type> func2b;
802        functor1<match_results_type> func1b;
803        out = regex_format(out, m_cresults, func3b, f);
804        out = regex_format(out, m_cresults, func3b);
805        out = regex_format(out, m_cresults, func2b, f);
806        out = regex_format(out, m_cresults, func2b);
807        out = regex_format(out, m_cresults, func1b, f);
808        out = regex_format(out, m_cresults, func1b);
809        out = regex_format(out, m_cresults, RW_NS::ref(func3b), f);
810        out = regex_format(out, m_cresults, RW_NS::ref(func3b));
811        out = regex_format(out, m_cresults, RW_NS::ref(func2b), f);
812        out = regex_format(out, m_cresults, RW_NS::ref(func2b));
813        out = regex_format(out, m_cresults, RW_NS::ref(func1b), f);
814        out = regex_format(out, m_cresults, RW_NS::ref(func1b));
815        out = regex_format(out, m_cresults, RW_NS::cref(func3b), f);
816        out = regex_format(out, m_cresults, RW_NS::cref(func3b));
817        out = regex_format(out, m_cresults, RW_NS::cref(func2b), f);
818        out = regex_format(out, m_cresults, RW_NS::cref(func2b));
819        out = regex_format(out, m_cresults, RW_NS::cref(func1b), f);
820        out = regex_format(out, m_cresults, RW_NS::cref(func1b));
821        m_string += regex_format(m_cresults, func3b, f);
822        m_string += regex_format(m_cresults, func3b);
823        m_string += regex_format(m_cresults, func2b, f);
824        m_string += regex_format(m_cresults, func2b);
825        m_string += regex_format(m_cresults, func1b, f);
826        m_string += regex_format(m_cresults, func1b);
827        m_string += regex_format(m_cresults, RW_NS::ref(func3b), f);
828        m_string += regex_format(m_cresults, RW_NS::ref(func3b));
829        m_string += regex_format(m_cresults, RW_NS::ref(func2b), f);
830        m_string += regex_format(m_cresults, RW_NS::ref(func2b));
831        m_string += regex_format(m_cresults, RW_NS::ref(func1b), f);
832        m_string += regex_format(m_cresults, RW_NS::ref(func1b));
833        m_string += regex_format(m_cresults, RW_NS::cref(func3b), f);
834        m_string += regex_format(m_cresults, RW_NS::cref(func3b));
835        m_string += regex_format(m_cresults, RW_NS::cref(func2b), f);
836        m_string += regex_format(m_cresults, RW_NS::cref(func2b));
837        m_string += regex_format(m_cresults, RW_NS::cref(func1b), f);
838        m_string += regex_format(m_cresults, RW_NS::cref(func1b));
839        out = m_cresults.format(out, func3b, f);
840        out = m_cresults.format(out, func3b);
841        out = m_cresults.format(out, func2b, f);
842        out = m_cresults.format(out, func2b);
843        out = m_cresults.format(out, func1b, f);
844        out = m_cresults.format(out, func1b);
845        out = m_cresults.format(out, RW_NS::ref(func3b), f);
846        out = m_cresults.format(out, RW_NS::ref(func3b));
847        out = m_cresults.format(out, RW_NS::ref(func2b), f);
848        out = m_cresults.format(out, RW_NS::ref(func2b));
849        out = m_cresults.format(out, RW_NS::ref(func1b), f);
850        out = m_cresults.format(out, RW_NS::ref(func1b));
851        out = m_cresults.format(out, RW_NS::cref(func3b), f);
852        out = m_cresults.format(out, RW_NS::cref(func3b));
853        out = m_cresults.format(out, RW_NS::cref(func2b), f);
854        out = m_cresults.format(out, RW_NS::cref(func2b));
855        out = m_cresults.format(out, RW_NS::cref(func1b), f);
856        out = m_cresults.format(out, RW_NS::cref(func1b));
857        m_string += m_cresults.format(func3b, f);
858        m_string += m_cresults.format(func3b);
859        m_string += m_cresults.format(func2b, f);
860        m_string += m_cresults.format(func2b);
861        m_string += m_cresults.format(func1b, f);
862        m_string += m_cresults.format(func1b);
863        m_string += m_cresults.format(RW_NS::ref(func3b), f);
864        m_string += m_cresults.format(RW_NS::ref(func3b));
865        m_string += m_cresults.format(RW_NS::ref(func2b), f);
866        m_string += m_cresults.format(RW_NS::ref(func2b));
867        m_string += m_cresults.format(RW_NS::ref(func1b), f);
868        m_string += m_cresults.format(RW_NS::ref(func1b));
869        m_string += m_cresults.format(RW_NS::cref(func3b), f);
870        m_string += m_cresults.format(RW_NS::cref(func3b));
871        m_string += m_cresults.format(RW_NS::cref(func2b), f);
872        m_string += m_cresults.format(RW_NS::cref(func2b));
873        m_string += m_cresults.format(RW_NS::cref(func1b), f);
874        m_string += m_cresults.format(RW_NS::cref(func1b));
875        out = regex_replace(out, m_in, m_in, ce, func3, f);
876        out = regex_replace(out, m_in, m_in, ce, func3);
877        out = regex_replace(out, m_in, m_in, ce, func2, f);
878        out = regex_replace(out, m_in, m_in, ce, func2);
879        out = regex_replace(out, m_in, m_in, ce, func1, f);
880        out = regex_replace(out, m_in, m_in, ce, func1);
881        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func3), f);
882        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func3));
883        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func2), f);
884        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func2));
885        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func1), f);
886        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func1));
887        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func3), f);
888        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func3));
889        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func2), f);
890        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func2));
891        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func1), f);
892        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func1));
893        functor3<match_results<typename string_type::const_iterator> > func3s;
894        functor2<match_results<typename string_type::const_iterator> > func2s;
895        functor1<match_results<typename string_type::const_iterator> > func1s;
896        m_string += regex_replace(m_string, ce, func3s, f);
897        m_string += regex_replace(m_string, ce, func3s);
898        m_string += regex_replace(m_string, ce, func2s, f);
899        m_string += regex_replace(m_string, ce, func2s);
900        m_string += regex_replace(m_string, ce, func1s, f);
901        m_string += regex_replace(m_string, ce, func1s);
902        m_string += regex_replace(m_string, ce, RW_NS::ref(func3s), f);
903        m_string += regex_replace(m_string, ce, RW_NS::ref(func3s));
904        m_string += regex_replace(m_string, ce, RW_NS::ref(func2s), f);
905        m_string += regex_replace(m_string, ce, RW_NS::ref(func2s));
906        m_string += regex_replace(m_string, ce, RW_NS::ref(func1s), f);
907        m_string += regex_replace(m_string, ce, RW_NS::ref(func1s));
908        m_string += regex_replace(m_string, ce, RW_NS::cref(func3s), f);
909        m_string += regex_replace(m_string, ce, RW_NS::cref(func3s));
910        m_string += regex_replace(m_string, ce, RW_NS::cref(func2s), f);
911        m_string += regex_replace(m_string, ce, RW_NS::cref(func2s));
912        m_string += regex_replace(m_string, ce, RW_NS::cref(func1s), f);
913        m_string += regex_replace(m_string, ce, RW_NS::cref(func1s));
914     }
915     std::basic_ostream<value_type> m_stream;
916     sub_match_type m_sub;
917     pointer_type m_pointer;
918     string_type m_string;
919     const value_type m_char;
920     match_results_type m_results;
921     const match_results_type m_cresults;
922     BidiIterator m_in;
923     BoostRegexConcept();
924     BoostRegexConcept(const BoostRegexConcept&);
925     BoostRegexConcept& operator=(const BoostRegexConcept&);
926  };
927  #endif 
928  }
929  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_cat_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-concepts.hpp</div>
                </div>
                <div class="column column_space"><pre><code>172    template <class U>
173    Mallocator(const Mallocator<U>&) {}  
174    T* allocate(size_t n) { return static_cast<T*>(std::malloc(n * sizeof(T))); }
</pre></code></div>
                <div class="column column_space"><pre><code>68     template <class Other>
69     allocator_architype(const allocator_architype<Other>&){}
70     void construct(pointer p, const_reference r) { new (p)T(r); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    