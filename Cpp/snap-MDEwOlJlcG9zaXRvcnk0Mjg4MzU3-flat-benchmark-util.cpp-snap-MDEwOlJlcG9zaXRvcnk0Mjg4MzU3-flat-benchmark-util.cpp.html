
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-benchmark-util.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include <Snap.h>
3  #include <stdio.h>
4  #include <omp.h>
5  double Tick() {
6  #ifdef USE_OPENMP
7    return omp_get_wtime();
8  #else
9    struct rusage rusage;
10    getrusage(RUSAGE_SELF, &rusage);
11    float cputime =
12    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
13    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
14    return cputime;
15  #endif
16  }
17  double GetCPUTimeUsage(double tick1, double tick2) {
18    return tick2 - tick1;
19  }
20  PTable Load(const Schema& TblSchema, const int nCols, const TStr& TsvFileName, TTableContext& TableContext, const TFlt DefaultWeight = 0.0) {
21    TIntV RelColV;
22    for (int i = 0; i < min(nCols, TblSchema.Len()); i++) {
23      RelColV.Add(i);
24    }
25    PTable PTbl = TTable::LoadSS(TblSchema, TsvFileName, TableContext, RelColV);
26    if (DefaultWeight != 0.0) {
27      TFltV WeightCol(PTbl->GetNumRows());
28      for (int i = 0; i < PTbl->GetNumRows(); i++) {
29        WeightCol[i] = DefaultWeight;
30      }
31      PTbl->StoreFltCol(TStr("Weight"), WeightCol);
32    }
33    return PTbl;
34  }
35  void LoadFlickrTables(const TStr& PrefixPath, TTableContext& Context,
36    TVec<TPair<PTable,TStr> >& NodeTblV, Schema& NodeSchema, TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV, Schema& EdgeSchema) {
37    Schema PhotoSchema;
38    PhotoSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
39    PhotoSchema.Add(TPair<TStr,TAttrType>("UploadedDate", atInt));
40    PhotoSchema.Add(TPair<TStr,TAttrType>("LastUpdatedDate", atInt));
41    PhotoSchema.Add(TPair<TStr,TAttrType>("Views", atInt));
42    PhotoSchema.Add(TPair<TStr,TAttrType>("Media", atStr));
43    PhotoSchema.Add(TPair<TStr,TAttrType>("URL", atStr));
44    PTable PPhotoTbl = Load(PhotoSchema, 1, PrefixPath + TStr("photos.tsv"), Context);
45    NodeTblV.Add(TPair<PTable,TStr>(PPhotoTbl, TStr("Photos")));
46    Schema UserSchema;
47    UserSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
48    UserSchema.Add(TPair<TStr,TAttrType>("UserName", atStr));
49    UserSchema.Add(TPair<TStr,TAttrType>("RealName", atStr));
50    UserSchema.Add(TPair<TStr,TAttrType>("Location", atStr));
51    PTable PUserTbl = Load(UserSchema, 1, PrefixPath + TStr("users.tsv"), Context);
52    NodeTblV.Add(TPair<PTable,TStr>(PUserTbl, TStr("Users")));
53    Schema TagSchema;
54    TagSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
55    TagSchema.Add(TPair<TStr,TAttrType>("MachineTag", atStr));
56    TagSchema.Add(TPair<TStr,TAttrType>("Text", atStr));
57    TagSchema.Add(TPair<TStr,TAttrType>("DisplayedText", atStr));
58    PTable PTagTbl = Load(TagSchema, 1, PrefixPath + TStr("tags.tsv"), Context);
59    NodeTblV.Add(TPair<PTable,TStr>(PTagTbl, TStr("Tags")));
60    Schema CommentSchema;
61    CommentSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
62    CommentSchema.Add(TPair<TStr,TAttrType>("CreatedDate", atInt));
63    CommentSchema.Add(TPair<TStr,TAttrType>("PermanentLink", atStr));
64    CommentSchema.Add(TPair<TStr,TAttrType>("Text", atStr));
65    PTable PCommentTbl = Load(CommentSchema, 1, PrefixPath + TStr("comments.tsv"), Context);
66    NodeTblV.Add(TPair<PTable,TStr>(PCommentTbl, TStr("Comments")));
67    Schema LocationSchema;
68    LocationSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
69    LocationSchema.Add(TPair<TStr,TAttrType>("WoeId", atInt));
70    LocationSchema.Add(TPair<TStr,TAttrType>("Accuracy", atInt));
71    LocationSchema.Add(TPair<TStr,TAttrType>("Context", atInt));
72    LocationSchema.Add(TPair<TStr,TAttrType>("Latitude", atFlt));
73    LocationSchema.Add(TPair<TStr,TAttrType>("Longitude", atFlt));
74    LocationSchema.Add(TPair<TStr,TAttrType>("NeighborhoodId", atStr));
75    LocationSchema.Add(TPair<TStr,TAttrType>("NeighborhoodWoeId", atStr));
76    LocationSchema.Add(TPair<TStr,TAttrType>("NeighborhoodName", atStr));
77    LocationSchema.Add(TPair<TStr,TAttrType>("LocalityId", atStr));
78    LocationSchema.Add(TPair<TStr,TAttrType>("LocalityWoeId", atStr));
79    LocationSchema.Add(TPair<TStr,TAttrType>("LocalityName", atStr));
80    LocationSchema.Add(TPair<TStr,TAttrType>("CountyId", atStr));
81    LocationSchema.Add(TPair<TStr,TAttrType>("CountyWoeId", atStr));
82    LocationSchema.Add(TPair<TStr,TAttrType>("CountyName", atStr));
83    LocationSchema.Add(TPair<TStr,TAttrType>("RegionId", atStr));
84    LocationSchema.Add(TPair<TStr,TAttrType>("RegionWoeId", atStr));
85    LocationSchema.Add(TPair<TStr,TAttrType>("RegionName", atStr));
86    LocationSchema.Add(TPair<TStr,TAttrType>("CountryId", atStr));
87    LocationSchema.Add(TPair<TStr,TAttrType>("CountryWoeId", atStr));
88    LocationSchema.Add(TPair<TStr,TAttrType>("CountryName", atStr));
89    PTable PLocationTbl = Load(LocationSchema, 1, PrefixPath + TStr("locations.tsv"), Context);
90    NodeTblV.Add(TPair<PTable,TStr>(PLocationTbl, TStr("Locations")));
91    NodeSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
92    Schema StdEdgeSchema = Schema();
93    StdEdgeSchema.Add(TPair<TStr,TAttrType>("SrcId", atStr));
94    StdEdgeSchema.Add(TPair<TStr,TAttrType>("DstId", atStr));
95    PTable PPhotoOwnerTbl = Load(StdEdgeSchema, 2, PrefixPath + "photo_owner_edges.tsv", Context, 1.0);
96    PTable PPhotoCommentTbl = Load(StdEdgeSchema, 2, PrefixPath + "photo_comment_edges.tsv", Context, 0.2);
97    PTable PPhotoLocationTbl = Load(StdEdgeSchema, 2, PrefixPath + "photo_location_edges.tsv", Context, 0.05);
98    PTable PCommentUserTbl = Load(StdEdgeSchema, 2, PrefixPath + "comment_user_edges.tsv", Context, 0.2);
99    Schema PhotoTagSchema;
100    PhotoTagSchema.Add(TPair<TStr,TAttrType>("SrcId", atStr));
101    PhotoTagSchema.Add(TPair<TStr,TAttrType>("DstId", atStr));
102    PhotoTagSchema.Add(TPair<TStr,TAttrType>("UserId", atStr));
103    PTable PPhotoTagTbl = Load(PhotoTagSchema, 2, PrefixPath + "photo_tag_edges.tsv", Context, 0.1);
104    Schema TaggerTagSchema;
105    TaggerTagSchema.Add(TPair<TStr,TAttrType>("SrcId", atStr));
106    TaggerTagSchema.Add(TPair<TStr,TAttrType>("DstId", atStr));
107    TaggerTagSchema.Add(TPair<TStr,TAttrType>("PhotoId", atStr));
108    PTable PTaggerTagTbl = Load(TaggerTagSchema, 2, PrefixPath + "tagger_tag_edges.tsv", Context, 0.1);
109    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoOwnerTbl, "Photos", "Users", false));
110    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoOwnerTbl, "Users", "Photos", true));
111    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoCommentTbl, "Photos", "Comments", false));
112    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoLocationTbl, "Photos", "Locations", false));
113    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoLocationTbl, "Locations", "Photos", true));
114    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PCommentUserTbl, "Comments", "Users", false));
115    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoTagTbl, "Photos", "Tags", false));
116    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PTaggerTagTbl, "Tags", "Users", true));
117    EdgeSchema.Add(TPair<TStr,TAttrType>("SrcId", atStr));
118    EdgeSchema.Add(TPair<TStr,TAttrType>("DstId", atStr));
119    EdgeSchema.Add(TPair<TStr,TAttrType>("Weight", atFlt));
120  }
121  void LoadMixedTypeNodeList(const TStr& PrefixPath, const TStr& RandNodeFileName, THash<TStr,TStrV>& NodeH) {
122    Schema RandNodeListSchema;
123    RandNodeListSchema.Add(TPair<TStr,TAttrType>("NTypeName", atStr));
124    RandNodeListSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
125    TTableContext Context;
126    PTable RandNTbl = Load(RandNodeListSchema, 2, PrefixPath+RandNodeFileName, Context);
127    for (int i = 0; i < RandNTbl->GetNumRows(); i++) {
128      TStr NTypeStr = RandNTbl->GetStrVal(RandNodeListSchema.GetVal(0).GetVal1(), i);
129      TStr NStr = RandNTbl->GetStrVal(RandNodeListSchema.GetVal(1).GetVal1(), i);
130      if (!NodeH.IsKey(NTypeStr)) {
131        NodeH.AddDat(NTypeStr).Gen(RandNTbl->GetNumRows().Val, 0); 
132      }
133      NodeH.GetDat(NTypeStr).Add(NStr);
134    }
135  }
136  void LoadNodeList(const TStr& PrefixPath, const TStr& NodeFileName, TVec<TPair<TStr,TStr> >& RandNV) {
137    Schema NodeListSchema;
138    NodeListSchema.Add(TPair<TStr,TAttrType>("NTypeName", atStr));
139    NodeListSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
140    TTableContext Context;
141    PTable RandNTbl = Load(NodeListSchema, 2, PrefixPath+NodeFileName, Context);
142    int n = RandNTbl->GetNumRows();
143    RandNV.Gen(n, n);
144    for (int i = 0; i < n; i++) {
145      TStr NTypeStr = RandNTbl->GetStrVal(NodeListSchema.GetVal(0).GetVal1(), i);
146      TStr NStr = RandNTbl->GetStrVal(NodeListSchema.GetVal(1).GetVal1(), i);
147      TPair<TStr,TStr> Node(NTypeStr, NStr);
148      RandNV[i] = Node;
149    }
150  }
151  void CreateIdHashes(const TVec<TPair<PTable,TStr> >& NodeTblV, THash<TStr,TStrH>& NStrH, TIntStrH& NIdH) {
152    int ExpectedSz = 0;
153    for (TVec<TPair<PTable,TStr> >::TIter it = NodeTblV.BegI(); it < NodeTblV.EndI(); it++) {
154      ExpectedSz += (*it).GetVal1()->GetNumRows();
155    }
156    NStrH.Gen(NodeTblV.Len());
157    NIdH.Gen(ExpectedSz);
158  }
159  template <class PGraph>
160  PGraph LoadGraph(const TVec<PTable>& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV, TStrIntH& NStrH, TIntStrH& NIdH) {
161    PGraph Graph = PGraph::TObj::New();
162    TStr IdColName("Id");
163    for (int i = 0; i < NodeTblV.Len(); i++) {
164      PTable Table = NodeTblV[i];
165      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
166        TStr NStr = Table->GetStrVal(IdColName, CurrRowIdx);
167        int NId = Graph->AddNode();
168        NStrH.AddDat(NStr, NId);
169        NIdH.AddDat(NId, NStr);
170      }
171    }
172    TStr IdColName1("SrcId");
173    TStr IdColName2("DstId");
174    for (int i = 0; i < EdgeTblV.Len(); i++) {
175      PTable Table;
176      TStr SrcETypeName;
177      TStr DstETypeName;
178      TBool IsDirectionReverse;
179      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
180      TStr SrcIdColName, DstIdColName;
181      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
182      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
183      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
184        TStr SrcNStr = Table->GetStrVal(SrcIdColName, CurrRowIdx);
185        IAssertR(NStrH.IsKey(SrcNStr), "SrcId of edges must be a node Id");
186        TInt SrcNId = NStrH.GetDat(SrcNStr);
187        TStr DstNStr = Table->GetStrVal(DstIdColName, CurrRowIdx);
188        IAssertR(NStrH.IsKey(DstNStr), "DstId of edges must be a node Id");
189        TInt DstNId = NStrH.GetDat(DstNStr);
190        Graph->AddEdge(SrcNId, DstNId);
191      }
192    }
193    return Graph;
194  }
195  template <class PGraph>
196  PGraph LoadGraphMNet(const TVec<TPair<PTable,TStr> >& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV, THash<TStr,TStrH>& NStrH, TIntStrH& NIdH) {
197    PGraph Graph = PGraph::TObj::New();
198    TStr IdColName("Id");
199    for (int i = 0; i < NodeTblV.Len(); i++) {
<span onclick='openModal()' class='match'>200      Graph->AddNType(NodeTblV[i].GetVal2());
201      NStrH.AddDat(NodeTblV[i].GetVal2());
</span>202    }
203    THash<TPair<TStr,TStr>, TInt> ETypeIdH;
204    for (int i = 0; i < EdgeTblV.Len(); i++) {
205      TStr SrcETypeName = EdgeTblV[i].GetVal2();
206      TStr DstETypeName = EdgeTblV[i].GetVal3();
207      int Id = Graph->AddEType(TStr("Edge") + SrcETypeName.CStr() + DstETypeName.CStr(), SrcETypeName, DstETypeName);
208      TInt ETypeId(Id);
209      TPair<TStr,TStr> ETypeNamePair(SrcETypeName,DstETypeName);
210      ETypeIdH.AddDat(ETypeNamePair, ETypeId);
211    }
212    for (int i = 0; i < NodeTblV.Len(); i++) {
213      PTable Table = NodeTblV[i].GetVal1();
214      int NTypeId = Graph->GetNTypeId(NodeTblV[i].GetVal2());
215      TStrH* PNStrH = &(NStrH.GetDat(NodeTblV[i].GetVal2()));
216      PNStrH->Gen(Table->GetNumRows());
217      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
218        TStr NStr = Table->GetStrVal(IdColName, CurrRowIdx);
219        int NId = Graph->AddNode(NTypeId);
220        PNStrH->AddDat(NStr, NId);
221        NIdH.AddDat(NId, NStr);
222      }
223    }
224    TStr IdColName1("SrcId");
225    TStr IdColName2("DstId");
226    for (int i = 0; i < EdgeTblV.Len(); i++) {
227      PTable Table;
228      TStr SrcETypeName;
229      TStr DstETypeName;
230      TBool IsDirectionReverse;
231      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
232      TPair<TStr,TStr> ETypeNamePair(SrcETypeName,DstETypeName);
233      TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
234      TStr SrcIdColName, DstIdColName;
235      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
236      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
237      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
238        TStr SrcNStr = Table->GetStrVal(SrcIdColName, CurrRowIdx);
239        TInt SrcNId = NStrH.GetDat(SrcETypeName).GetDat(SrcNStr);
240        TStr DstNStr = Table->GetStrVal(DstIdColName, CurrRowIdx);
241        TInt DstNId = NStrH.GetDat(DstETypeName).GetDat(DstNStr);
242        Graph->AddEdge(SrcNId, DstNId, ETypeId);
243      }
244    }
245    return Graph;
246  }
247  void CreateNborList(const TVec<TPair<PTable,TStr> >& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV,
248                        const TVec<TPair<TStr,TStr> >& NodeV, TVec<TVec<TTriple<TStr,TStr,TBool> > >& NbrVV) {
249    PSOut StdOut = TStdOut::New();
250    THash<TPair<TStr,TStr>, TInt> NOrderH;
251    int order = 0;
252    for (TVec<TPair<TStr,TStr> >::TIter iter = NodeV.BegI(); iter < NodeV.EndI(); iter++) {
253      NOrderH.AddDat(*iter, order++);
254    }
255    NbrVV.Gen(order);
256    for (int i = 0; i < order; i++) {
257      TVec<TTriple<TStr,TStr,TBool> > NbrV;
258      NbrVV[i] = NbrV;
259    }
260    TStr IdColName1("SrcId");
261    TStr IdColName2("DstId");
262    for (int i = 0; i < EdgeTblV.Len(); i++) {
263      PTable Table;
264      TStr SrcETypeName;
265      TStr DstETypeName;
266      TBool IsDirectionReverse;
267      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
268      TStr SrcIdColName, DstIdColName;
269      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
270      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
271      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
272        TStr SrcNStr = Table->GetStrVal(SrcIdColName, CurrRowIdx);
273        TPair<TStr,TStr> Src(SrcETypeName, SrcNStr);
274        TInt SrcOrder = NOrderH.GetDat(Src);
275        TStr DstNStr = Table->GetStrVal(DstIdColName, CurrRowIdx);
276        TPair<TStr,TStr> Dst(DstETypeName, DstNStr);
277        TInt DstOrder = NOrderH.GetDat(Dst);
278        if (SrcOrder < DstOrder) {
279          TTriple<TStr,TStr,TBool> Nbr(SrcETypeName, SrcNStr, false);
280          NbrVV[DstOrder.Val].Add(Nbr);
281        } else {
282          TTriple<TStr,TStr,TBool> Nbr(DstETypeName, DstNStr, true);
283          NbrVV[SrcOrder.Val].Add(Nbr);
284        }
285      }
286    }
287  }
288  template <class PGraph>
289  PGraph LoadGraphMNetRandom(const TVec<TPair<PTable,TStr> >& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV,
290                              const TVec<TPair<TStr,TStr> >& RandNV, const TVec<TVec<TTriple<TStr,TStr,TBool> > >& RandNbrVV,
291                              THash<TStr,TStrH>& NStrH, TIntStrH& NIdH) {
292    PGraph Graph = PGraph::TObj::New();
293    TStr IdColName("Id");
294    for (int i = 0; i < NodeTblV.Len(); i++) {
295      Graph->AddNType(NodeTblV[i].GetVal2());
296      TStrH StrH;
297      NStrH.AddDat(NodeTblV[i].GetVal2(), StrH);
298    }
299    THash<TPair<TStr,TStr>, TInt> ETypeIdH;
300    for (int i = 0; i < EdgeTblV.Len(); i++) {
301      TStr SrcETypeName = EdgeTblV[i].GetVal2();
302      TStr DstETypeName = EdgeTblV[i].GetVal3();
303      int Id = Graph->AddEType(TStr("Edge") + SrcETypeName.CStr() + DstETypeName.CStr(), SrcETypeName, DstETypeName);
304      TInt ETypeId(Id);
305      TPair<TStr,TStr> ETypeNamePair(SrcETypeName,DstETypeName);
306      ETypeIdH.AddDat(ETypeNamePair, ETypeId);
307    }
308    int order = 0;
309    for (TVec<TPair<TStr,TStr> >::TIter iter = RandNV.BegI(); iter < RandNV.EndI(); iter++) {
310      int NId = Graph->AddNode((*iter).GetVal1());
311      NStrH.GetDat((*iter).GetVal1()).AddDat((*iter).GetVal2(), NId);
312      NIdH.AddDat(NId, (*iter).GetVal2());
313      const TVec<TTriple<TStr,TStr,TBool> >* Nbrs = &(RandNbrVV[order++]);
314      for (TVec<TTriple<TStr,TStr,TBool> >::TIter iter2 = Nbrs->BegI(); iter2 < Nbrs->EndI(); iter2++) {
315        TTriple<TStr,TStr,TBool>* Nbr = iter2;
316        if (Nbr->GetVal3()) {
317          TPair<TStr,TStr> ETypeNamePair((*iter).GetVal1(), Nbr->GetVal1());
318          TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
319          Graph->AddEdge(NId, NStrH.GetDat(Nbr->GetVal1()).GetDat(Nbr->GetVal2()), ETypeId);
320        } else {
321          TPair<TStr,TStr> ETypeNamePair(Nbr->GetVal1(), (*iter).GetVal1());
322          TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
323          Graph->AddEdge(NStrH.GetDat(Nbr->GetVal1()).GetDat(Nbr->GetVal2()), NId, ETypeId);
324        }
325      }
326    }
327    return Graph;
328  }
329  void BuildCombinedEdgeTable(const TVec<TPair<PTable,TStr> >& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV, THash<TStr,TStrH>& NStrH, TIntStrH& NIdH, PTable CombinedEdgeTbl) {
330    TStr IdColName("Id");
331    TInt NId(0);
332    for (int i = 0; i < NodeTblV.Len(); i++) {
333      PTable Table = NodeTblV[i].GetVal1();
334      TStrH StrH(Table->GetNumRows());
335      NStrH.AddDat(NodeTblV[i].GetVal2(), StrH);
336      TStrH* PNStrH = &(NStrH.GetDat(NodeTblV[i].GetVal2()));
337      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
338        TStr NStr = Table->GetStrVal(IdColName, CurrRowIdx);
339        PNStrH->AddDat(NStr, NId);
340        NIdH.AddDat(NId, NStr);
341        NId += 1;
342      }
343    }
344    TStr IdColName1("SrcId");
345    TStr IdColName2("DstId");
346    for (int i = 0; i < EdgeTblV.Len(); i++) {
347      PTable Table;
348      TStr SrcETypeName;
349      TStr DstETypeName;
350      TBool IsDirectionReverse;
351      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
352      TStr SrcIdColName, DstIdColName;
353      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
354      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
355      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
356        TStr SrcNStr = Table->GetStrVal(SrcIdColName, CurrRowIdx);
357        TInt SrcNId = NStrH.GetDat(SrcETypeName).GetDat(SrcNStr);
358        TStr DstNStr = Table->GetStrVal(DstIdColName, CurrRowIdx);
359        TInt DstNId = NStrH.GetDat(DstETypeName).GetDat(DstNStr);
360        TTableRow Row;
361        Row.AddInt(SrcNId);
362        Row.AddInt(DstNId);
363        CombinedEdgeTbl->AddRow(Row);
364      }
365    }
366  }
367  template <class PGraph>
368  void PageRankExp(const PGraph& Graph, const int nExps, TIntFltH& PageRankResults) {
369    for (int i = 0; i < nExps; i++) {
370  #ifdef USE_OPENMP
371      TSnap::GetPageRankMNetMP(Graph, PageRankResults, 0.849999999999998, 0.0001, 10);
372  #else
373      TSnap::GetPageRank(Graph, PageRankResults, 0.849999999999998, 0.0001, 10);
374  #endif
375    }
376  }
377  template <class PGraph>
378  void BFSExp(const PGraph& Graph, const TStrV& RandNStrs, const TStrIntH& NStrH,
379              const int nExps, TIntV& BFSResults) {
380    for (int i = 0; i < nExps; i++) {
381      TStr NStr = RandNStrs[i];
382      TInt NId = NStrH.GetDat(NStr);
383  #ifdef USE_OPENMP
384      TSnap::GetShortestDistancesMP2(Graph, NId.Val, true, false, BFSResults);
385  #else
386      TSnap::GetShortestDistances(Graph, NId.Val, true, false, BFSResults);
387  #endif
388    }
389  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-benchmark-util.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include <Snap.h>
3  #include <stdio.h>
4  #include <omp.h>
5  double Tick() {
6  #ifdef USE_OPENMP
7    return omp_get_wtime();
8  #else
9    struct rusage rusage;
10    getrusage(RUSAGE_SELF, &rusage);
11    float cputime =
12    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
13    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
14    return cputime;
15  #endif
16  }
17  double GetCPUTimeUsage(double tick1, double tick2) {
18    return tick2 - tick1;
19  }
20  PTable Load(const Schema& TblSchema, const int nCols, const TStr& TsvFileName, TTableContext& TableContext, const TFlt DefaultWeight = 0.0) {
21    TIntV RelColV;
22    for (int i = 0; i < min(nCols, TblSchema.Len()); i++) {
23      RelColV.Add(i);
24    }
25    PTable PTbl = TTable::LoadSS(TblSchema, TsvFileName, TableContext, RelColV);
26    if (DefaultWeight != 0.0) {
27      TFltV WeightCol(PTbl->GetNumRows());
28      for (int i = 0; i < PTbl->GetNumRows(); i++) {
29        WeightCol[i] = DefaultWeight;
30      }
31      PTbl->StoreFltCol(TStr("Weight"), WeightCol);
32    }
33    return PTbl;
34  }
35  void LoadFlickrTables(const TStr& PrefixPath, TTableContext& Context,
36    TVec<TPair<PTable,TStr> >& NodeTblV, Schema& NodeSchema, TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV, Schema& EdgeSchema) {
37    Schema PhotoSchema;
38    PhotoSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
39    PhotoSchema.Add(TPair<TStr,TAttrType>("UploadedDate", atInt));
40    PhotoSchema.Add(TPair<TStr,TAttrType>("LastUpdatedDate", atInt));
41    PhotoSchema.Add(TPair<TStr,TAttrType>("Views", atInt));
42    PhotoSchema.Add(TPair<TStr,TAttrType>("Media", atStr));
43    PhotoSchema.Add(TPair<TStr,TAttrType>("URL", atStr));
44    PTable PPhotoTbl = Load(PhotoSchema, 1, PrefixPath + TStr("photos.tsv"), Context);
45    NodeTblV.Add(TPair<PTable,TStr>(PPhotoTbl, TStr("Photos")));
46    Schema UserSchema;
47    UserSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
48    UserSchema.Add(TPair<TStr,TAttrType>("UserName", atStr));
49    UserSchema.Add(TPair<TStr,TAttrType>("RealName", atStr));
50    UserSchema.Add(TPair<TStr,TAttrType>("Location", atStr));
51    PTable PUserTbl = Load(UserSchema, 1, PrefixPath + TStr("users.tsv"), Context);
52    NodeTblV.Add(TPair<PTable,TStr>(PUserTbl, TStr("Users")));
53    Schema TagSchema;
54    TagSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
55    TagSchema.Add(TPair<TStr,TAttrType>("MachineTag", atStr));
56    TagSchema.Add(TPair<TStr,TAttrType>("Text", atStr));
57    TagSchema.Add(TPair<TStr,TAttrType>("DisplayedText", atStr));
58    PTable PTagTbl = Load(TagSchema, 1, PrefixPath + TStr("tags.tsv"), Context);
59    NodeTblV.Add(TPair<PTable,TStr>(PTagTbl, TStr("Tags")));
60    Schema CommentSchema;
61    CommentSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
62    CommentSchema.Add(TPair<TStr,TAttrType>("CreatedDate", atInt));
63    CommentSchema.Add(TPair<TStr,TAttrType>("PermanentLink", atStr));
64    CommentSchema.Add(TPair<TStr,TAttrType>("Text", atStr));
65    PTable PCommentTbl = Load(CommentSchema, 1, PrefixPath + TStr("comments.tsv"), Context);
66    NodeTblV.Add(TPair<PTable,TStr>(PCommentTbl, TStr("Comments")));
67    Schema LocationSchema;
68    LocationSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
69    LocationSchema.Add(TPair<TStr,TAttrType>("WoeId", atInt));
70    LocationSchema.Add(TPair<TStr,TAttrType>("Accuracy", atInt));
71    LocationSchema.Add(TPair<TStr,TAttrType>("Context", atInt));
72    LocationSchema.Add(TPair<TStr,TAttrType>("Latitude", atFlt));
73    LocationSchema.Add(TPair<TStr,TAttrType>("Longitude", atFlt));
74    LocationSchema.Add(TPair<TStr,TAttrType>("NeighborhoodId", atStr));
75    LocationSchema.Add(TPair<TStr,TAttrType>("NeighborhoodWoeId", atStr));
76    LocationSchema.Add(TPair<TStr,TAttrType>("NeighborhoodName", atStr));
77    LocationSchema.Add(TPair<TStr,TAttrType>("LocalityId", atStr));
78    LocationSchema.Add(TPair<TStr,TAttrType>("LocalityWoeId", atStr));
79    LocationSchema.Add(TPair<TStr,TAttrType>("LocalityName", atStr));
80    LocationSchema.Add(TPair<TStr,TAttrType>("CountyId", atStr));
81    LocationSchema.Add(TPair<TStr,TAttrType>("CountyWoeId", atStr));
82    LocationSchema.Add(TPair<TStr,TAttrType>("CountyName", atStr));
83    LocationSchema.Add(TPair<TStr,TAttrType>("RegionId", atStr));
84    LocationSchema.Add(TPair<TStr,TAttrType>("RegionWoeId", atStr));
85    LocationSchema.Add(TPair<TStr,TAttrType>("RegionName", atStr));
86    LocationSchema.Add(TPair<TStr,TAttrType>("CountryId", atStr));
87    LocationSchema.Add(TPair<TStr,TAttrType>("CountryWoeId", atStr));
88    LocationSchema.Add(TPair<TStr,TAttrType>("CountryName", atStr));
89    PTable PLocationTbl = Load(LocationSchema, 1, PrefixPath + TStr("locations.tsv"), Context);
90    NodeTblV.Add(TPair<PTable,TStr>(PLocationTbl, TStr("Locations")));
91    NodeSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
92    Schema StdEdgeSchema = Schema();
93    StdEdgeSchema.Add(TPair<TStr,TAttrType>("SrcId", atStr));
94    StdEdgeSchema.Add(TPair<TStr,TAttrType>("DstId", atStr));
95    PTable PPhotoOwnerTbl = Load(StdEdgeSchema, 2, PrefixPath + "photo_owner_edges.tsv", Context, 1.0);
96    PTable PPhotoCommentTbl = Load(StdEdgeSchema, 2, PrefixPath + "photo_comment_edges.tsv", Context, 0.2);
97    PTable PPhotoLocationTbl = Load(StdEdgeSchema, 2, PrefixPath + "photo_location_edges.tsv", Context, 0.05);
98    PTable PCommentUserTbl = Load(StdEdgeSchema, 2, PrefixPath + "comment_user_edges.tsv", Context, 0.2);
99    Schema PhotoTagSchema;
100    PhotoTagSchema.Add(TPair<TStr,TAttrType>("SrcId", atStr));
101    PhotoTagSchema.Add(TPair<TStr,TAttrType>("DstId", atStr));
102    PhotoTagSchema.Add(TPair<TStr,TAttrType>("UserId", atStr));
103    PTable PPhotoTagTbl = Load(PhotoTagSchema, 2, PrefixPath + "photo_tag_edges.tsv", Context, 0.1);
104    Schema TaggerTagSchema;
105    TaggerTagSchema.Add(TPair<TStr,TAttrType>("SrcId", atStr));
106    TaggerTagSchema.Add(TPair<TStr,TAttrType>("DstId", atStr));
107    TaggerTagSchema.Add(TPair<TStr,TAttrType>("PhotoId", atStr));
108    PTable PTaggerTagTbl = Load(TaggerTagSchema, 2, PrefixPath + "tagger_tag_edges.tsv", Context, 0.1);
109    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoOwnerTbl, "Photos", "Users", false));
110    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoOwnerTbl, "Users", "Photos", true));
111    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoCommentTbl, "Photos", "Comments", false));
112    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoLocationTbl, "Photos", "Locations", false));
113    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoLocationTbl, "Locations", "Photos", true));
114    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PCommentUserTbl, "Comments", "Users", false));
115    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PPhotoTagTbl, "Photos", "Tags", false));
116    EdgeTblV.Add(TQuad<PTable,TStr,TStr,TBool>(PTaggerTagTbl, "Tags", "Users", true));
117    EdgeSchema.Add(TPair<TStr,TAttrType>("SrcId", atStr));
118    EdgeSchema.Add(TPair<TStr,TAttrType>("DstId", atStr));
119    EdgeSchema.Add(TPair<TStr,TAttrType>("Weight", atFlt));
120  }
121  void LoadMixedTypeNodeList(const TStr& PrefixPath, const TStr& RandNodeFileName, THash<TStr,TStrV>& NodeH) {
122    Schema RandNodeListSchema;
123    RandNodeListSchema.Add(TPair<TStr,TAttrType>("NTypeName", atStr));
124    RandNodeListSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
125    TTableContext Context;
126    PTable RandNTbl = Load(RandNodeListSchema, 2, PrefixPath+RandNodeFileName, Context);
127    for (int i = 0; i < RandNTbl->GetNumRows(); i++) {
128      TStr NTypeStr = RandNTbl->GetStrVal(RandNodeListSchema.GetVal(0).GetVal1(), i);
129      TStr NStr = RandNTbl->GetStrVal(RandNodeListSchema.GetVal(1).GetVal1(), i);
130      if (!NodeH.IsKey(NTypeStr)) {
131        NodeH.AddDat(NTypeStr).Gen(RandNTbl->GetNumRows().Val, 0); 
132      }
133      NodeH.GetDat(NTypeStr).Add(NStr);
134    }
135  }
136  void LoadNodeList(const TStr& PrefixPath, const TStr& NodeFileName, TVec<TPair<TStr,TStr> >& RandNV) {
137    Schema NodeListSchema;
138    NodeListSchema.Add(TPair<TStr,TAttrType>("NTypeName", atStr));
139    NodeListSchema.Add(TPair<TStr,TAttrType>("Id", atStr));
140    TTableContext Context;
141    PTable RandNTbl = Load(NodeListSchema, 2, PrefixPath+NodeFileName, Context);
142    int n = RandNTbl->GetNumRows();
143    RandNV.Gen(n, n);
144    for (int i = 0; i < n; i++) {
145      TStr NTypeStr = RandNTbl->GetStrVal(NodeListSchema.GetVal(0).GetVal1(), i);
146      TStr NStr = RandNTbl->GetStrVal(NodeListSchema.GetVal(1).GetVal1(), i);
147      TPair<TStr,TStr> Node(NTypeStr, NStr);
148      RandNV[i] = Node;
149    }
150  }
151  void CreateIdHashes(const TVec<TPair<PTable,TStr> >& NodeTblV, THash<TStr,TStrH>& NStrH, TIntStrH& NIdH) {
152    int ExpectedSz = 0;
153    for (TVec<TPair<PTable,TStr> >::TIter it = NodeTblV.BegI(); it < NodeTblV.EndI(); it++) {
154      ExpectedSz += (*it).GetVal1()->GetNumRows();
155    }
156    NStrH.Gen(NodeTblV.Len());
157    NIdH.Gen(ExpectedSz);
158  }
159  template <class PGraph>
160  PGraph LoadGraph(const TVec<PTable>& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV, TStrIntH& NStrH, TIntStrH& NIdH) {
161    PGraph Graph = PGraph::TObj::New();
162    TStr IdColName("Id");
163    for (int i = 0; i < NodeTblV.Len(); i++) {
164      PTable Table = NodeTblV[i];
165      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
166        TStr NStr = Table->GetStrVal(IdColName, CurrRowIdx);
167        int NId = Graph->AddNode();
168        NStrH.AddDat(NStr, NId);
169        NIdH.AddDat(NId, NStr);
170      }
171    }
172    TStr IdColName1("SrcId");
173    TStr IdColName2("DstId");
174    for (int i = 0; i < EdgeTblV.Len(); i++) {
175      PTable Table;
176      TStr SrcETypeName;
177      TStr DstETypeName;
178      TBool IsDirectionReverse;
179      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
180      TStr SrcIdColName, DstIdColName;
181      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
182      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
183      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
184        TStr SrcNStr = Table->GetStrVal(SrcIdColName, CurrRowIdx);
185        IAssertR(NStrH.IsKey(SrcNStr), "SrcId of edges must be a node Id");
186        TInt SrcNId = NStrH.GetDat(SrcNStr);
187        TStr DstNStr = Table->GetStrVal(DstIdColName, CurrRowIdx);
188        IAssertR(NStrH.IsKey(DstNStr), "DstId of edges must be a node Id");
189        TInt DstNId = NStrH.GetDat(DstNStr);
190        Graph->AddEdge(SrcNId, DstNId);
191      }
192    }
193    return Graph;
194  }
195  template <class PGraph>
196  PGraph LoadGraphMNet(const TVec<TPair<PTable,TStr> >& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV, THash<TStr,TStrH>& NStrH, TIntStrH& NIdH) {
197    PGraph Graph = PGraph::TObj::New();
198    TStr IdColName("Id");
199    for (int i = 0; i < NodeTblV.Len(); i++) {
200      Graph->AddNType(NodeTblV[i].GetVal2());
201      NStrH.AddDat(NodeTblV[i].GetVal2());
202    }
203    THash<TPair<TStr,TStr>, TInt> ETypeIdH;
204    for (int i = 0; i < EdgeTblV.Len(); i++) {
205      TStr SrcETypeName = EdgeTblV[i].GetVal2();
206      TStr DstETypeName = EdgeTblV[i].GetVal3();
207      int Id = Graph->AddEType(TStr("Edge") + SrcETypeName.CStr() + DstETypeName.CStr(), SrcETypeName, DstETypeName);
208      TInt ETypeId(Id);
209      TPair<TStr,TStr> ETypeNamePair(SrcETypeName,DstETypeName);
210      ETypeIdH.AddDat(ETypeNamePair, ETypeId);
211    }
212    for (int i = 0; i < NodeTblV.Len(); i++) {
213      PTable Table = NodeTblV[i].GetVal1();
214      int NTypeId = Graph->GetNTypeId(NodeTblV[i].GetVal2());
215      TStrH* PNStrH = &(NStrH.GetDat(NodeTblV[i].GetVal2()));
216      PNStrH->Gen(Table->GetNumRows());
217      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
218        TStr NStr = Table->GetStrVal(IdColName, CurrRowIdx);
219        int NId = Graph->AddNode(NTypeId);
220        PNStrH->AddDat(NStr, NId);
221        NIdH.AddDat(NId, NStr);
222      }
223    }
224    TStr IdColName1("SrcId");
225    TStr IdColName2("DstId");
226    for (int i = 0; i < EdgeTblV.Len(); i++) {
227      PTable Table;
228      TStr SrcETypeName;
229      TStr DstETypeName;
230      TBool IsDirectionReverse;
231      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
232      TPair<TStr,TStr> ETypeNamePair(SrcETypeName,DstETypeName);
233      TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
234      TStr SrcIdColName, DstIdColName;
235      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
236      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
237      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
238        TStr SrcNStr = Table->GetStrVal(SrcIdColName, CurrRowIdx);
239        TInt SrcNId = NStrH.GetDat(SrcETypeName).GetDat(SrcNStr);
240        TStr DstNStr = Table->GetStrVal(DstIdColName, CurrRowIdx);
241        TInt DstNId = NStrH.GetDat(DstETypeName).GetDat(DstNStr);
242        Graph->AddEdge(SrcNId, DstNId, ETypeId);
243      }
244    }
245    return Graph;
246  }
247  void CreateNborList(const TVec<TPair<PTable,TStr> >& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV,
248                        const TVec<TPair<TStr,TStr> >& NodeV, TVec<TVec<TTriple<TStr,TStr,TBool> > >& NbrVV) {
249    PSOut StdOut = TStdOut::New();
250    THash<TPair<TStr,TStr>, TInt> NOrderH;
251    int order = 0;
252    for (TVec<TPair<TStr,TStr> >::TIter iter = NodeV.BegI(); iter < NodeV.EndI(); iter++) {
253      NOrderH.AddDat(*iter, order++);
254    }
255    NbrVV.Gen(order);
256    for (int i = 0; i < order; i++) {
257      TVec<TTriple<TStr,TStr,TBool> > NbrV;
258      NbrVV[i] = NbrV;
259    }
260    TStr IdColName1("SrcId");
261    TStr IdColName2("DstId");
262    for (int i = 0; i < EdgeTblV.Len(); i++) {
263      PTable Table;
264      TStr SrcETypeName;
265      TStr DstETypeName;
266      TBool IsDirectionReverse;
267      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
268      TStr SrcIdColName, DstIdColName;
269      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
270      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
271      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
272        TStr SrcNStr = Table->GetStrVal(SrcIdColName, CurrRowIdx);
273        TPair<TStr,TStr> Src(SrcETypeName, SrcNStr);
274        TInt SrcOrder = NOrderH.GetDat(Src);
275        TStr DstNStr = Table->GetStrVal(DstIdColName, CurrRowIdx);
276        TPair<TStr,TStr> Dst(DstETypeName, DstNStr);
277        TInt DstOrder = NOrderH.GetDat(Dst);
278        if (SrcOrder < DstOrder) {
279          TTriple<TStr,TStr,TBool> Nbr(SrcETypeName, SrcNStr, false);
280          NbrVV[DstOrder.Val].Add(Nbr);
281        } else {
282          TTriple<TStr,TStr,TBool> Nbr(DstETypeName, DstNStr, true);
283          NbrVV[SrcOrder.Val].Add(Nbr);
284        }
285      }
286    }
287  }
288  template <class PGraph>
289  PGraph LoadGraphMNetRandom(const TVec<TPair<PTable,TStr> >& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV,
290                              const TVec<TPair<TStr,TStr> >& RandNV, const TVec<TVec<TTriple<TStr,TStr,TBool> > >& RandNbrVV,
291                              THash<TStr,TStrH>& NStrH, TIntStrH& NIdH) {
292    PGraph Graph = PGraph::TObj::New();
293    TStr IdColName("Id");
294    for (int i = 0; i < NodeTblV.Len(); i++) {
<span onclick='openModal()' class='match'>295      Graph->AddNType(NodeTblV[i].GetVal2());
296      TStrH StrH;
</span>297      NStrH.AddDat(NodeTblV[i].GetVal2(), StrH);
298    }
299    THash<TPair<TStr,TStr>, TInt> ETypeIdH;
300    for (int i = 0; i < EdgeTblV.Len(); i++) {
301      TStr SrcETypeName = EdgeTblV[i].GetVal2();
302      TStr DstETypeName = EdgeTblV[i].GetVal3();
303      int Id = Graph->AddEType(TStr("Edge") + SrcETypeName.CStr() + DstETypeName.CStr(), SrcETypeName, DstETypeName);
304      TInt ETypeId(Id);
305      TPair<TStr,TStr> ETypeNamePair(SrcETypeName,DstETypeName);
306      ETypeIdH.AddDat(ETypeNamePair, ETypeId);
307    }
308    int order = 0;
309    for (TVec<TPair<TStr,TStr> >::TIter iter = RandNV.BegI(); iter < RandNV.EndI(); iter++) {
310      int NId = Graph->AddNode((*iter).GetVal1());
311      NStrH.GetDat((*iter).GetVal1()).AddDat((*iter).GetVal2(), NId);
312      NIdH.AddDat(NId, (*iter).GetVal2());
313      const TVec<TTriple<TStr,TStr,TBool> >* Nbrs = &(RandNbrVV[order++]);
314      for (TVec<TTriple<TStr,TStr,TBool> >::TIter iter2 = Nbrs->BegI(); iter2 < Nbrs->EndI(); iter2++) {
315        TTriple<TStr,TStr,TBool>* Nbr = iter2;
316        if (Nbr->GetVal3()) {
317          TPair<TStr,TStr> ETypeNamePair((*iter).GetVal1(), Nbr->GetVal1());
318          TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
319          Graph->AddEdge(NId, NStrH.GetDat(Nbr->GetVal1()).GetDat(Nbr->GetVal2()), ETypeId);
320        } else {
321          TPair<TStr,TStr> ETypeNamePair(Nbr->GetVal1(), (*iter).GetVal1());
322          TInt ETypeId = ETypeIdH.GetDat(ETypeNamePair);
323          Graph->AddEdge(NStrH.GetDat(Nbr->GetVal1()).GetDat(Nbr->GetVal2()), NId, ETypeId);
324        }
325      }
326    }
327    return Graph;
328  }
329  void BuildCombinedEdgeTable(const TVec<TPair<PTable,TStr> >& NodeTblV, const TVec<TQuad<PTable,TStr,TStr,TBool> >& EdgeTblV, THash<TStr,TStrH>& NStrH, TIntStrH& NIdH, PTable CombinedEdgeTbl) {
330    TStr IdColName("Id");
331    TInt NId(0);
332    for (int i = 0; i < NodeTblV.Len(); i++) {
333      PTable Table = NodeTblV[i].GetVal1();
334      TStrH StrH(Table->GetNumRows());
335      NStrH.AddDat(NodeTblV[i].GetVal2(), StrH);
336      TStrH* PNStrH = &(NStrH.GetDat(NodeTblV[i].GetVal2()));
337      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
338        TStr NStr = Table->GetStrVal(IdColName, CurrRowIdx);
339        PNStrH->AddDat(NStr, NId);
340        NIdH.AddDat(NId, NStr);
341        NId += 1;
342      }
343    }
344    TStr IdColName1("SrcId");
345    TStr IdColName2("DstId");
346    for (int i = 0; i < EdgeTblV.Len(); i++) {
347      PTable Table;
348      TStr SrcETypeName;
349      TStr DstETypeName;
350      TBool IsDirectionReverse;
351      EdgeTblV[i].GetVal(Table, SrcETypeName, DstETypeName, IsDirectionReverse);
352      TStr SrcIdColName, DstIdColName;
353      if (!IsDirectionReverse) { SrcIdColName = IdColName1; DstIdColName = IdColName2; }
354      else { SrcIdColName = IdColName2; DstIdColName = IdColName1; }
355      for (int CurrRowIdx = 0; CurrRowIdx < Table->GetNumRows(); CurrRowIdx++) {
356        TStr SrcNStr = Table->GetStrVal(SrcIdColName, CurrRowIdx);
357        TInt SrcNId = NStrH.GetDat(SrcETypeName).GetDat(SrcNStr);
358        TStr DstNStr = Table->GetStrVal(DstIdColName, CurrRowIdx);
359        TInt DstNId = NStrH.GetDat(DstETypeName).GetDat(DstNStr);
360        TTableRow Row;
361        Row.AddInt(SrcNId);
362        Row.AddInt(DstNId);
363        CombinedEdgeTbl->AddRow(Row);
364      }
365    }
366  }
367  template <class PGraph>
368  void PageRankExp(const PGraph& Graph, const int nExps, TIntFltH& PageRankResults) {
369    for (int i = 0; i < nExps; i++) {
370  #ifdef USE_OPENMP
371      TSnap::GetPageRankMNetMP(Graph, PageRankResults, 0.849999999999998, 0.0001, 10);
372  #else
373      TSnap::GetPageRank(Graph, PageRankResults, 0.849999999999998, 0.0001, 10);
374  #endif
375    }
376  }
377  template <class PGraph>
378  void BFSExp(const PGraph& Graph, const TStrV& RandNStrs, const TStrIntH& NStrH,
379              const int nExps, TIntV& BFSResults) {
380    for (int i = 0; i < nExps; i++) {
381      TStr NStr = RandNStrs[i];
382      TInt NId = NStrH.GetDat(NStr);
383  #ifdef USE_OPENMP
384      TSnap::GetShortestDistancesMP2(Graph, NId.Val, true, false, BFSResults);
385  #else
386      TSnap::GetShortestDistances(Graph, NId.Val, true, false, BFSResults);
387  #endif
388    }
389  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-benchmark-util.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-benchmark-util.cpp</div>
                </div>
                <div class="column column_space"><pre><code>200      Graph->AddNType(NodeTblV[i].GetVal2());
201      NStrH.AddDat(NodeTblV[i].GetVal2());
</pre></code></div>
                <div class="column column_space"><pre><code>295      Graph->AddNType(NodeTblV[i].GetVal2());
296      TStrH StrH;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    