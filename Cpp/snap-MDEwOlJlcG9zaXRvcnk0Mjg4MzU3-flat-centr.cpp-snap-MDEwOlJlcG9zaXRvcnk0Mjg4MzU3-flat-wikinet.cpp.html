
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.184162671515955%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-centr.cpp</h3>
            <pre><code>1  namespace TSnap {
2  double GetDegreeCentr(const PUNGraph& Graph, const int& NId) {
3    if (Graph->GetNodes() > 1) {
4      return double(Graph->GetNI(NId).GetDeg())/double(Graph->GetNodes()-1); }
5    else { return 0.0; }
6  }
7  void GetEigenVectorCentr(const PUNGraph& Graph, TIntFltH& NIdEigenH, const double& Eps, const int& MaxIter) {
8    const int NNodes = Graph->GetNodes();
9    NIdEigenH.Gen(NNodes);
10    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
11      NIdEigenH.AddDat(NI.GetId(), 1.0/NNodes);
12      IAssert(NI.GetId() == NIdEigenH.GetKey(NIdEigenH.Len()-1));
13    }
14    TFltV TmpV(NNodes);
15    for (int iter = 0; iter < MaxIter; iter++) {
16      int j = 0;
17      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++, j++) {
18        TmpV[j] = 0;
19        for (int e = 0; e < NI.GetOutDeg(); e++) {
20          TmpV[j] += NIdEigenH.GetDat(NI.GetOutNId(e)); }
21      }
22      double sum = 0;
23      for (int i = 0; i < TmpV.Len(); i++) {
24        sum += (TmpV[i]*TmpV[i]);
25      }
26      sum = sqrt(sum);
27      for (int i = 0; i < TmpV.Len(); i++) {
28        TmpV[i] /= sum;
29      }
30      double diff = 0.0;
31      j = 0;
32      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++, j++) {
33        diff += fabs(NIdEigenH.GetDat(NI.GetId())-TmpV[j]);
34      }
35      j = 0;
36      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++, j++) {
37        NIdEigenH.AddDat(NI.GetId(), TmpV[j]);
38      }
39      if (diff < Eps) {
40        break;
41      }
42    }
43  }
44  double GetGroupDegreeCentr(const PUNGraph& Graph, const PUNGraph& Group) {
45    int deg;
46    TIntH NN;
47    for (TUNGraph::TNodeI NI = Group->BegNI(); NI < Group->EndNI(); NI++) { 
48      deg = Graph->GetNI(NI.GetId()).GetDeg();
49      for (int i=0; i<deg; i++) {
50        if (Group->IsNode(Graph->GetNI(NI.GetId()).GetNbrNId(i))==0)
51        NN.AddDat(Graph->GetNI(NI.GetId()).GetNbrNId(i),NI.GetId());
52      }
53    }
54    return (double)NN.Len();
55  }
56  double GetGroupDegreeCentr0(const PUNGraph& Graph, const TIntH& GroupNodes) {
57    int deg;
58    TIntH NN;
59    for (int i = 0; i<GroupNodes.Len(); i++) { 
60      deg = Graph->GetNI(GroupNodes.GetDat(i)).GetDeg();
61      for (int j = 0; j < deg; j++) {
62        if (GroupNodes.IsKey(Graph->GetNI(GroupNodes.GetDat(i)).GetNbrNId(j))==0)
63        NN.AddDat(Graph->GetNI(GroupNodes.GetDat(i)).GetNbrNId(j),GroupNodes.GetDat(i));
64      }
65    }
66    return (double)NN.Len();
67  }
68  double GetGroupDegreeCentr(const PUNGraph& Graph, const TIntH& GroupNodes) {
69    int deg;
70    TIntH NN;
71    TIntH GroupNodes1;
72    for (THashKeyDatI<TInt,TInt> NI = GroupNodes.BegI(); NI < GroupNodes.EndI(); NI++)
73      GroupNodes1.AddDat(NI.GetDat(),NI.GetDat());
74    for (THashKeyDatI<TInt,TInt> NI = GroupNodes1.BegI(); NI < GroupNodes1.EndI(); NI++){
75      TUNGraph::TNodeI node = Graph->GetNI(NI.GetKey());
76      deg = node.GetDeg();
77      for (int j = 0; j < deg; j++){
78        if (GroupNodes1.IsKey(node.GetNbrNId(j))==0 && NN.IsKey(node.GetNbrNId(j))==0)
79          NN.AddDat(node.GetNbrNId(j),NI.GetKey());
80      }
81    }
82    return (double)NN.Len();
83  }
84  double GetGroupFarnessCentr(const PUNGraph& Graph, const TIntH& GroupNodes) {
85    TIntH* NDistH = new TIntH[GroupNodes.Len()];
86    for (int i=0; i<GroupNodes.Len(); i++){
87      NDistH[i](Graph->GetNodes());
88    TSnap::GetShortPath<PUNGraph>(Graph, GroupNodes.GetDat(i), NDistH[i], true, TInt::Mx);
89    }
90    int min, dist, sum=0, len=0;
91    for (PUNGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++){
92      if(NDistH[0].IsKey(NI.GetId()))
93        min = NDistH[0].GetDat(NI.GetId());
94      else
95        min = -1;
96      for (int j=1; j<GroupNodes.Len(); j++){
97      if (NDistH[j].IsKey(NI.GetId()))
98        dist = NDistH[j].GetDat(NI.GetId());
99        else
100        dist = -1;
101      if ((dist < min && dist != -1) || (dist > min && min == -1))
102        min = dist;
103      }
104      if (min>0){  
105        sum += min;
106        len++;
107    }
108    }
109    if (len > 0) { return sum/double(len); }
110    else { return 0.0; }
111  }
112  PUNGraph *AllGraphsWithNNodes(int n){
113    PUNGraph* g = new PUNGraph[(((n*n)-n)/2)+1];
114    PUNGraph g0;
115    for(int i=0; i<n; i++)
116      g0->AddNode(i);
117    g[0] = g0;
118    int br=1;
119    for(int i=0; i<n; i++)
120    for(int j=i; j<n; j++){
121        g0->AddEdge(i,j);
122      g[br] = g0;
123      br++;
124    }
125    return g;
126  }
127  TIntH *AllCombinationsMN(int m, int n){
128    float N = 1;
129    for(int i=n; i>0; i--){
130      N *= (float)m/(float)n;
131      m--;
132    n--;
133    }
134    TIntH* C = new TIntH[(int)N];
135    return C;
136  }
137  double GetGroupClosenessCentr(const PUNGraph& Graph, const TIntH& GroupNodes) {
138    const double Farness = GetGroupFarnessCentr(Graph, GroupNodes);
139    if (Farness != 0.0) { return 1.0/Farness; }
140    else { return 0.0; }
141  }
142  TIntH MaxCPGreedyBetter(const PUNGraph& Graph, const int k) {
143    TIntH GroupNodes; 
144    TIntH NNodes; 
145    TIntH Nodes; 
146    double gc = 0, gc0 = 0;
147    int addId = 0, addIdPrev = 0;
148    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
149      Nodes.AddDat(NI.GetId(),NI.GetDeg());
150    }
151    Nodes.SortByDat(false);
152    int br = 0;
153    while (br < k) {
154      for (THashKeyDatI<TInt,TInt> NI = Nodes.BegI(); NI < Nodes.EndI(); NI++) {
155        if ((NI.GetDat() <= (int)gc0))
156          break;
157        gc = NI.GetDat()-Intersect(Graph->GetNI(NI.GetKey()),NNodes);
158        if (gc>gc0) {
159          gc0 = gc;
160          addId = NI.GetKey();
161        }
162      }
163      if (addId != addIdPrev){
164        GroupNodes.AddDat(br,addId);
165        br++;
166        gc0=0;
167        NNodes.AddDat(addId,0);
168        for (int i=0; i<Graph->GetNI(addId).GetDeg(); i++) {
169          NNodes.AddDat(Graph->GetNI(addId).GetNbrNId(i),0);
170        }
171        addIdPrev = addId;
172        Nodes.DelKey(addId);
173      } else {
174        br = k;
175      }
176      printf("%i,",br);
177    }
178    return GroupNodes;
179  }
180  TIntH MaxCPGreedyBetter1(const PUNGraph& Graph, const int k) {
181    TIntH GroupNodes;
182    TIntH NNodes;
183    TIntH Nodes;
184    double gc = 0, gc0 = 0;
185    int addId = 0, addIdPrev = 0;
186    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++){
187      Nodes.AddDat(NI.GetId(),NI.GetDeg());
188    }
189    Nodes.SortByDat(false);
190    int br = 0;
191    while (br < k) {
192      for (THashKeyDatI<TInt,TInt> NI = Nodes.BegI(); NI < Nodes.EndI(); NI++){
193        if((NI.GetDat() < (int)gc0))
194          break;
195        gc = NI.GetDat()-Intersect(Graph->GetNI(NI.GetKey()),NNodes);
196        if (gc>gc0) {
197          gc0 = gc;
198          addId = NI.GetKey();
199        }
200      }
201      if (addId != addIdPrev){
202        GroupNodes.AddDat(br,addId);
203        br++;
204        gc0=-10000000;
205        NNodes.AddDat(addId,0);
206        for (int i=0; i<Graph->GetNI(addId).GetDeg(); i++) {
207          NNodes.AddDat(Graph->GetNI(addId).GetNbrNId(i),0);
208        }
209        addIdPrev = addId;
210        Nodes.DelKey(addId);
211      }
212    }
213    return GroupNodes;
214  }
215  TIntH MaxCPGreedyBetter2(const PUNGraph& Graph, const int k) {
216    TIntH GroupNodes; 
217    TStr NNodes; 
218    TIntH Nodes; 
219    double gc = 0, gc0 = 0;
220    int addId = 0, addIdPrev=0;
221    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++){
222      Nodes.AddDat(NI.GetId(),NI.GetDeg());
223    }
224    Nodes.SortByDat(false);
225    int br=0;
226    while (br < k) {
227      for (THashKeyDatI<TInt,TInt> NI = Nodes.BegI(); NI < Nodes.EndI(); NI++){
228        if((NI.GetDat() <= (int)gc0))
229          break;
230        gc = NI.GetDat()-Intersect(Graph->GetNI(NI.GetKey()),NNodes);
231        if (gc>gc0) {
232          gc0 = gc;
233          addId = NI.GetKey();
234        }
235      }
236      if (addId != addIdPrev) {
237        GroupNodes.AddDat(br,addId);
238        br++;
239        gc0=0;
240        TInt digi = addId;
241        TStr buf = digi.GetStr();
242        NNodes += " "+buf;
243        for (int i=0; i<Graph->GetNI(addId).GetDeg(); i++) {
244          TInt digi = Graph->GetNI(addId).GetNbrNId(i);
245          TStr buf = digi.GetStr();
246          NNodes += " "+buf;
247        }
248        addIdPrev = addId;
249        Nodes.DelKey(addId);
250      } else {
251        br = k;
252      }
253      printf("%i,",br);
254    }
255    return GroupNodes;
256  }
257  TIntH MaxCPGreedyBetter3(const PUNGraph& Graph, const int k) {
258    TIntH GroupNodes; 
259    const int n = Graph->GetNodes();
260    int *NNodes = new int[n]; 
261    int NNodes_br = 0;
262    TIntH Nodes; 
263    double gc = 0, gc0 = 0;
264    int addId = 0, addIdPrev = 0;
265    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++){
266      Nodes.AddDat(NI.GetId(),NI.GetDeg());
267    }
268    Nodes.SortByDat(false);
269    int br = 0;
270    while (br < k) {
271      for (THashKeyDatI<TInt,TInt> NI = Nodes.BegI(); NI < Nodes.EndI(); NI++){
272        if((NI.GetDat() <= (int)gc0))
273          break;
274        gc = NI.GetDat()-Intersect(Graph->GetNI(NI.GetKey()),NNodes,NNodes_br);
275        if (gc>gc0){
276          gc0 = gc;
277          addId = NI.GetKey();
278        }
279      }
280      if (addId != addIdPrev) {
281        GroupNodes.AddDat(br,addId);
282        br++;
283        gc0=0;
284        int nn = addId;
285        bool nnnew = true;
286        for (int j=0; j<NNodes_br; j++)
287          if (NNodes[j] == nn){
288            nnnew = false;
289            j = NNodes_br;
290          }
291        if (nnnew){
292          NNodes[NNodes_br] = nn;
293          NNodes_br++;
294        }
295        for (int i=0; i<Graph->GetNI(addId).GetDeg(); i++) {
296          int nn = Graph->GetNI(addId).GetNbrNId(i);
297          bool nnnew = true;
298          for (int j=0; j<NNodes_br; j++) {
299            if (NNodes[j] == nn){
300              nnnew = false;
301              j = NNodes_br;
302            }
303          }
304          if (nnnew){
305            NNodes[NNodes_br] = nn;
306            NNodes_br++;
307          }
308        }
309        addIdPrev = addId;
310        Nodes.DelKey(addId);
311      } else {
312        br = k;
313      }
314      printf("%i,",br);
315    }
316    delete NNodes;
317    return GroupNodes;
318  }
319  int GetWeightedPageRank(const PNEANet Graph, TIntFltH& PRankH, const TStr& Attr, const double& C, const double& Eps, const int& MaxIter) {
320    if (!Graph->IsFltAttrE(Attr)) return -1;
321    TFltV Weights = Graph->GetFltAttrVecE(Attr);
322    int mxid = Graph->GetMxNId();
323    TFltV OutWeights(mxid);
324    Graph->GetWeightOutEdgesV(OutWeights, Weights);
325    const int NNodes = Graph->GetNodes();
326    PRankH.Gen(NNodes);
327    for (TNEANet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
328      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
329    }
330    TFltV TmpV(NNodes);
331    for (int iter = 0; iter < MaxIter; iter++) {
332      int j = 0;
333      for (TNEANet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++, j++) {
334        TmpV[j] = 0;
335        for (int e = 0; e < NI.GetInDeg(); e++) {
336          const int InNId = NI.GetInNId(e);
337          const TFlt OutWeight = OutWeights[InNId];
338          int EId = Graph->GetEId(InNId, NI.GetId());
339          const TFlt Weight = Weights[Graph->GetFltKeyIdE(EId)];
340          if (OutWeight > 0) {
341            TmpV[j] += PRankH.GetDat(InNId) * Weight / OutWeight; }
342        }
343        TmpV[j] =  C*TmpV[j]; 
344      }
345      double diff=0, sum=0, NewVal;
346      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
347      const double Leaked = (1.0-sum) / double(NNodes);
348      for (int i = 0; i < PRankH.Len(); i++) { 
349        NewVal = TmpV[i] + Leaked; 
350        diff += fabs(NewVal-PRankH[i]);
351        PRankH[i] = NewVal;
352      }
353      if (diff < Eps) { break; }
354    }
355    return 0;
356  }
357  #ifdef USE_OPENMP
358  int GetWeightedPageRankMP(const PNEANet Graph, TIntFltH& PRankH, const TStr& Attr, const double& C, const double& Eps, const int& MaxIter) {
359    if (!Graph->IsFltAttrE(Attr)) return -1;
360    const int NNodes = Graph->GetNodes();
361    TVec<TNEANet::TNodeI> NV;
362    PRankH.Gen(NNodes);
363    int MxId = 0;
364    for (TNEANet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
365      NV.Add(NI);
366      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
367      int Id = NI.GetId();
368      if (Id > MxId) {
369        MxId = Id;
370      }
371    }
372    TFltV PRankV(MxId+1);
373    TFltV OutWeights(MxId+1);
374    TFltV Weights = Graph->GetFltAttrVecE(Attr);
375    #pragma omp parallel for schedule(dynamic,10000)
376    for (int j = 0; j < NNodes; j++) {
377      TNEANet::TNodeI NI = NV[j];
378      int Id = NI.GetId();
379      OutWeights[Id] = Graph->GetWeightOutEdges(NI, Attr);
380      PRankV[Id] = 1/NNodes;
381    }
382    TFltV TmpV(NNodes);
383    for (int iter = 0; iter < MaxIter; iter++) {
384      #pragma omp parallel for schedule(dynamic,10000)
385      for (int j = 0; j < NNodes; j++) {
386        TNEANet::TNodeI NI = NV[j];
387        TFlt Tmp = 0;
388        for (int e = 0; e < NI.GetInDeg(); e++) {
389          const int InNId = NI.GetInNId(e);
390          const TFlt OutWeight = OutWeights[InNId];
391          int EId = Graph->GetEId(InNId, NI.GetId());
392          const TFlt Weight = Weights[Graph->GetFltKeyIdE(EId)];
393          if (OutWeight > 0) {
394            Tmp += PRankH.GetDat(InNId) * Weight / OutWeight;
395          }
396        }
<span onclick='openModal()' class='match'>397        TmpV[j] =  C*Tmp; 
398      }
399      double sum = 0;
400      #pragma omp parallel for reduction(+:sum) schedule(dynamic,10000)
401      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
</span>402      const double Leaked = (1.0-sum) / double(NNodes);
403      double diff = 0;
404      #pragma omp parallel for reduction(+:diff) schedule(dynamic,10000)
405      for (int i = 0; i < NNodes; i++) {
406        TNEANet::TNodeI NI = NV[i];
407        double NewVal = TmpV[i] + Leaked; 
408        int Id = NI.GetId();
409        diff += fabs(NewVal-PRankV[Id]);
410        PRankV[Id] = NewVal;
411      }
412      if (diff < Eps) { break; }
413    }
414    #pragma omp parallel for schedule(dynamic,10000)
415    for (int i = 0; i < NNodes; i++) {
416      TNEANet::TNodeI NI = NV[i];
417      PRankH[i] = PRankV[NI.GetId()];
418    }
419    return 0;
420  }
421  #endif 
422  TIntFltH EventImportance(const PNGraph& Graph, const int k) {
423    TIntFltH NodeList; 
424    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++){
425      NodeList.AddDat(NI.GetId(),NI.GetOutDeg());
426    }
427    for (THashKeyDatI<TInt,TFlt> NI = NodeList.BegI(); NI < NodeList.EndI(); NI++){
428      int outdeg = Graph->GetNI(NI.GetKey()).GetOutDeg();
429      int indeg = Graph->GetNI(NI.GetKey()).GetInDeg();
430      if (outdeg>1 && indeg>0){
431        double val = (1-(1/(double)outdeg))/(double)indeg;
432        for(int i=0; i<(outdeg+indeg);i++){
433          int NId = Graph->GetNI(NI.GetKey()).GetNbrNId(i);
434          if (Graph->GetNI(NI.GetKey()).IsInNId(NId) == true){
435          NodeList.AddDat(NId,NodeList.GetDat(NId)+val);
436          }
437        }
438      }
439    }
440    return NodeList;
441  }
442  TIntFltH EventImportance1 (const PNGraph& Graph, const int k) {
443    TIntFltH NodeList; 
444    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++){
445      NodeList.AddDat(NI.GetId(),NI.GetOutDeg());
446    }
447    for (THashKeyDatI<TInt,TFlt> NI = NodeList.BegI(); NI < NodeList.EndI(); NI++){
448      int outdeg = Graph->GetNI(NI.GetKey()).GetOutDeg();
449      int indeg = Graph->GetNI(NI.GetKey()).GetInDeg();
450      if (outdeg>1 && indeg>0){
451        double val = (1-(1/(double)outdeg))/(double)indeg;
452        for(int i=0; i<(outdeg+indeg);i++){
453          int NId = Graph->GetNI(NI.GetKey()).GetNbrNId(i);
454          if (Graph->GetNI(NI.GetKey()).IsInNId(NId) == true){
455          NodeList.AddDat(NId,NodeList.GetDat(NId)+val);
456          }
457        }
458      }
459    }
460    return NodeList;
461  }
462  int Intersect(TUNGraph::TNodeI Node, TIntH NNodes){
463    int br=0;
464    for (int i=0; i<Node.GetDeg(); i++)
465    {
466      if (NNodes.IsKey(Node.GetNbrNId(i)))
467        br++;
468    }
469    if (NNodes.IsKey(Node.GetId()))
470      br++;
471    return br;
472  }
473  int Intersect(TUNGraph::TNodeI Node, TStr NNodes){
474    int br=0;
475    TInt digi = -1;
476    TStr buf = "";
477    for (int i=0; i<Node.GetDeg(); i++)
478    {
479      digi = Node.GetNbrNId(i);
480      TStr buf = digi.GetStr();
481      if (NNodes.IsStrIn(buf.CStr()))
482      br++;
483    }
484    digi = Node.GetId();
485    buf = digi.GetStr();
486    if (NNodes.IsStrIn(buf.CStr()))
487      br++;
488    return br;
489  }
490  int Intersect(TUNGraph::TNodeI Node, int *NNodes, int NNodes_br){
491    int br = 0;
492    int neig;
493    for (int i=0; i<Node.GetDeg(); i++)
494    {
495      neig = Node.GetNbrNId(i);
496      for (int j=0; j<NNodes_br; j++)
497      {
498      if (neig == NNodes[j])
499      {
500        br++;
501        j = NNodes_br;
502      }
503      }
504    }
505    neig = Node.GetId();
506    for (int j=0; j<NNodes_br; j++)
507    {
508      if (neig == NNodes[j])
509      {
510        br++;
511        j = NNodes_br;
512      }
513    }
514    return br;
515  }
516  int Intersect1(TUNGraph::TNodeI Node, TStr NNodes){
517    int br=0;
518    for (int i=0; i<Node.GetDeg(); i++)
519    {
520      TInt digi = Node.GetNbrNId(i);
521      TStr buf = "";
522      buf = digi.GetStr();
523      if (NNodes.SearchStr(buf.CStr())!=-1)
524      br++;
525    }
526    TInt digi = Node.GetId();
527    TStr buf = digi.GetStr();
528    if (NNodes.SearchStr(buf.CStr())!=-1)
529      br++;
530    return br;
531  }
532  TIntH LoadNodeList(TStr InFNmNodes){
533    TSsParser Ss(InFNmNodes, ssfWhiteSep, true, true, true);
534    TIntIntH Nodes;
535    int br = 0, NId;
536    while (Ss.Next()) {
537      if (Ss.GetInt(0, NId)) { 
538      Nodes.AddDat(br,NId);
539      br++;
540    }
541    }
542    return Nodes;
543  }
544  int findMinimum(TIntV& Frontier, TIntFltH& NIdDistH) {
545    TFlt minimum = TInt::Mx;
546    int min_index = 0;
547    for (int i = 0; i < Frontier.Len(); i++) {
548      int NId = Frontier.GetVal(i);
549      if (NIdDistH.GetDat(NId) < minimum) {
550        minimum = NIdDistH.GetDat(NId);
551        min_index = i;
552      }
553    }
554    const int NId = Frontier.GetVal(min_index);
555    Frontier.Del(min_index);
556    return NId;
557  }
558  int GetWeightedShortestPath(
559  const PNEANet Graph, const int& SrcNId, TIntFltH& NIdDistH, const TFltV& Attr) {
560    TIntV frontier;
561    NIdDistH.Clr(false); NIdDistH.AddDat(SrcNId, 0);
562    frontier.Add(SrcNId);
563    while (! frontier.Empty()) {
564      const int NId = findMinimum(frontier, NIdDistH);
565      const PNEANet::TObj::TNodeI NodeI = Graph->GetNI(NId);
566      for (int v = 0; v < NodeI.GetOutDeg(); v++) {
567        int DstNId = NodeI.GetOutNId(v);
568        int EId = NodeI.GetOutEId(v);
569        if (! NIdDistH.IsKey(DstNId)) {
570          NIdDistH.AddDat(DstNId, NIdDistH.GetDat(NId) + Attr[EId]);
571          frontier.Add(DstNId);
572        } else {
573          if (NIdDistH.GetDat(DstNId) > NIdDistH.GetDat(NId) + Attr[EId]) {
574            NIdDistH.GetDat(DstNId) = NIdDistH.GetDat(NId) + Attr[EId]; 
575          }
576        }
577      }
578    }
579    return 0;
580  }
581  double GetWeightedFarnessCentr(const PNEANet Graph, const int& NId, const TFltV& Attr, const bool& Normalized, const bool& IsDir) {
582    TIntFltH NDistH(Graph->GetNodes());
583    GetWeightedShortestPath(Graph, NId, NDistH, Attr);
584    double sum = 0;
585    for (TIntFltH::TIter I = NDistH.BegI(); I < NDistH.EndI(); I++) {
586      sum += I->Dat();
587    }
588    if (NDistH.Len() > 1) { 
589      double centr = sum/double(NDistH.Len()-1); 
590      if (Normalized) {
591        centr *= (Graph->GetNodes() - 1)/double(NDistH.Len()-1);
592      }
593      return centr;
594    }
595    else { return 0.0; }
596  }
597  double GetWeightedClosenessCentr(const PNEANet Graph, const int& NId, const TFltV& Attr, const bool& Normalized, const bool& IsDir) {
598    const double Farness = GetWeightedFarnessCentr(Graph, NId, Attr, Normalized, IsDir);
599    if (Farness != 0.0) { return 1.0/Farness; }
600    else { return 0.0; }
601    return 0.0;
602  }
603  void GetWeightedBetweennessCentr(const PNEANet Graph, const TIntV& BtwNIdV, TIntFltH& NodeBtwH, const bool& DoNodeCent, TIntPrFltH& EdgeBtwH, const bool& DoEdgeCent, const TFltV& Attr, const bool& IsDir) {
604    if (DoNodeCent) { NodeBtwH.Clr(); }
605    if (DoEdgeCent) { EdgeBtwH.Clr(); }
606    const int nodes = Graph->GetNodes();
607    TIntS S(nodes);
608    TIntQ Q(nodes);
609    TIntIntVH P(nodes); 
610    TIntFltH delta(nodes);
611    TIntFltH sigma(nodes), d(nodes);
612    for (PNEANet::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
613      if (DoNodeCent) {
614        NodeBtwH.AddDat(NI.GetId(), 0); }
615      if (DoEdgeCent) {
616        for (int e = 0; e < NI.GetOutDeg(); e++) {
617          if (Graph->HasFlag(gfDirected) && IsDir) {
618            EdgeBtwH.AddDat(TIntPr(NI.GetId(), NI.GetOutNId(e)), 0);
619          } else {
620            if (NI.GetId() < NI.GetOutNId(e)) {
621              EdgeBtwH.AddDat(TIntPr(NI.GetId(), NI.GetOutNId(e)), 0); 
622            }
623          }
624        }
625        if (Graph->HasFlag(gfDirected) && !IsDir) {
626          for (int e = 0; e < NI.GetInDeg(); e++) {
627            if (NI.GetId() < NI.GetInNId(e)  &&
628                !Graph->IsEdge(NI.GetId(), NI.GetInNId(e))) {
629              EdgeBtwH.AddDat(TIntPr(NI.GetId(), NI.GetInNId(e)), 0);  
630            } 
631          }
632        }
633      }
634      sigma.AddDat(NI.GetId(), 0);
635      d.AddDat(NI.GetId(), -1);
636      P.AddDat(NI.GetId(), TIntV());
637      delta.AddDat(NI.GetId(), 0);
638    }
639    for (int k=0; k < BtwNIdV.Len(); k++) {
640      const PNEANet::TObj::TNodeI NI = Graph->GetNI(BtwNIdV[k]);
641      for (int i = 0; i < sigma.Len(); i++) {
642        sigma[i]=0;  d[i]=-1;  delta[i]=0;  P[i].Clr(false);
643      }
644      S.Clr(false);
645      Q.Clr(false);
646      sigma.AddDat(NI.GetId(), 1);
647      d.AddDat(NI.GetId(), 0);
648      Q.Push(NI.GetId());
649      while (! Q.Empty()) {
650        const int v = Q.Top();  Q.Pop();
651        const PNEANet::TObj::TNodeI NI2 = Graph->GetNI(v);
652        S.Push(v);
653        const double VDat = d.GetDat(v);
654        for (int e = 0; e < NI2.GetOutDeg(); e++) {
655          const int w = NI2.GetOutNId(e);
656          const int eid = NI2.GetOutEId(e);
657          if (d.GetDat(w) < 0) { 
658            Q.Push(w);
659            d.AddDat(w, VDat+Attr[eid]);
660          }
661          if (d.GetDat(w) == VDat+Attr[eid]) {
662            sigma.AddDat(w) += sigma.GetDat(v);
663            P.GetDat(w).Add(v);
664          }
665        }
666        if (Graph->HasFlag(gfDirected) && !IsDir) {
667          for (int e = 0; e < NI2.GetInDeg(); e++) {
668            const int w = NI2.GetInNId(e);
669            if (Graph->IsEdge(NI2.GetId(), w)) {
670              continue;
671            }
672            const int eid = NI2.GetInEId(e);
673            if (d.GetDat(w) < 0) { 
674              Q.Push(w);
675              d.AddDat(w, VDat+Attr[eid]);
676            }
677            if (d.GetDat(w) == VDat+Attr[eid]) {
678              sigma.AddDat(w) += sigma.GetDat(v);
679              P.GetDat(w).Add(v);
680            }
681          }
682        }
683      }
684      while (! S.Empty()) {
685        const int w = S.Top();
686        const double SigmaW = sigma.GetDat(w);
687        const double DeltaW = delta.GetDat(w);
688        const TIntV NIdV = P.GetDat(w);
689        S.Pop();
690        for (int i = 0; i < NIdV.Len(); i++) {
691          const int NId = NIdV[i];
692          const double c = (sigma.GetDat(NId)*1.0/SigmaW) * (1+DeltaW);
693          delta.AddDat(NId) += c;
694          if (DoEdgeCent) {
695            if (Graph->HasFlag(gfDirected) && IsDir) {
696              EdgeBtwH.AddDat(TIntPr(NId, w)) += c;
697            } else {
698              EdgeBtwH.AddDat(TIntPr(TMath::Mn(NId, w), TMath::Mx(NId, w))) += c;
699            }
700          }
701        }
702        if (DoNodeCent && w != NI.GetId()) {
703          NodeBtwH.AddDat(w) += delta.GetDat(w)/2.0; }
704      }
705    }
706  }
707  void GetWeightedBetweennessCentr(const PNEANet Graph, TIntFltH& NodeBtwH, TIntPrFltH& EdgeBtwH, const TFltV& Attr, const double& NodeFrac, const bool& IsDir) {
708    TIntV NIdV;  Graph->GetNIdV(NIdV);
709    if (NodeFrac < 1.0) { 
710      NIdV.Shuffle(TInt::Rnd);
711      for (int i = int((1.0-NodeFrac)*NIdV.Len()); i > 0; i--) {
712        NIdV.DelLast(); }
713    }
714    GetWeightedBetweennessCentr(Graph, NIdV, NodeBtwH, true, EdgeBtwH, true,
715      Attr, IsDir);
716  }
717  void GetWeightedBetweennessCentr(const PNEANet Graph, TIntFltH& NodeBtwH, const TFltV& Attr, const double& NodeFrac, const bool& IsDir) {
718    TIntPrFltH EdgeBtwH;
719    TIntV NIdV;  Graph->GetNIdV(NIdV);
720    if (NodeFrac < 1.0) { 
721      NIdV.Shuffle(TInt::Rnd);
722      for (int i = int((1.0-NodeFrac)*NIdV.Len()); i > 0; i--) {
723        NIdV.DelLast(); }
724    }
725    GetWeightedBetweennessCentr(Graph, NIdV, NodeBtwH, true, EdgeBtwH, false,
726      Attr, IsDir);
727  }
728  void GetWeightedBetweennessCentr(const PNEANet Graph, TIntPrFltH& EdgeBtwH, const TFltV& Attr, const double& NodeFrac, const bool& IsDir) {
729    TIntFltH NodeBtwH;
730    TIntV NIdV;  Graph->GetNIdV(NIdV);
731    if (NodeFrac < 1.0) { 
732      NIdV.Shuffle(TInt::Rnd);
733      for (int i = int((1.0-NodeFrac)*NIdV.Len()); i > 0; i--) {
734        NIdV.DelLast(); }
735    }
736    GetWeightedBetweennessCentr(Graph, NIdV, NodeBtwH, false, EdgeBtwH, true,
737      Attr, IsDir);
738  }
739  TTableIterator GetMapPageRank(
740      const TVec<PNEANet>& GraphSeq,
741      TTableContext* Context,
742      const double& C = 0.85, const double& Eps = 1e-4, const int& MaxIter = 100) {
743    TVec<PTable> TableSeq(GraphSeq.Len());
744    TSnap::MapPageRank(GraphSeq, TableSeq, Context, C, Eps, MaxIter);
745    return TTableIterator(TableSeq);
746  }
747  TTableIterator GetMapHitsIterator(
748      const TVec<PNEANet>& GraphSeq,
749      TTableContext* Context,
750      const int& MaxIter = 20) {
751    TVec<PTable> TableSeq(GraphSeq.Len());
752    TSnap::MapHits(GraphSeq, TableSeq, Context, MaxIter);
753    return TTableIterator(TableSeq);
754  }
755  }; 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wikinet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "wikinet.h"
3  #include "trawling.h"
4  TWikiUsr::TWikiUsr() : Usr(), Admin(false), ElecTm(), BarnStars(), MnEdCnt(), MnEdWrds(), MnTkEdCnt(), MnTkEdWrds(),
5    WkEdCnt(), WkEdWrds(), WkTkEdCnt(), WkTkEdWrds(), MnRevCnt(), MnRevWrds() {
6  }
7  TWikiUsr::TWikiUsr(const TChA& UsrStr) : Usr(UsrStr), Admin(false), ElecTm(), BarnStars(), MnEdCnt(), MnEdWrds(),
8    MnTkEdCnt(), MnTkEdWrds(), WkEdCnt(), WkEdWrds(), WkTkEdCnt(), WkTkEdWrds(), MnRevCnt(), MnRevWrds() {
9  }
10  TWikiUsr::TWikiUsr(const TWikiUsr& WikiUsr) : Usr(WikiUsr.Usr), Admin(WikiUsr.Admin), ElecTm(WikiUsr.ElecTm),
11    BarnStars(WikiUsr.BarnStars), MnEdCnt(WikiUsr.MnEdCnt), MnEdWrds(WikiUsr.MnEdWrds),
12    MnTkEdCnt(WikiUsr.MnTkEdCnt), MnTkEdWrds(WikiUsr.MnTkEdWrds), WkEdCnt(WikiUsr.WkEdCnt),
13    WkEdWrds(WikiUsr.WkEdWrds), WkTkEdCnt(WikiUsr.WkTkEdCnt), WkTkEdWrds(WikiUsr.WkTkEdWrds),
14    MnRevCnt(WikiUsr.MnRevCnt), MnRevWrds(WikiUsr.MnRevCnt) {
15  }
16  TWikiUsr::TWikiUsr(TSIn& SIn) : Usr(SIn), Admin(SIn), ElecTm(SIn), BarnStars(SIn), MnEdCnt(SIn),
17    MnEdWrds(SIn), MnTkEdCnt(SIn), MnTkEdWrds(SIn), WkEdCnt(SIn), WkEdWrds(SIn), WkTkEdCnt(SIn), WkTkEdWrds(SIn)
18    , MnRevCnt(SIn), MnRevWrds(SIn)
19  {
20  }
21  void TWikiUsr::Save(TSOut& SOut) const {
22    Usr.Save(SOut);  Admin.Save(SOut);  ElecTm.Save(SOut);
23    BarnStars.Save(SOut);  MnEdCnt.Save(SOut);  MnEdWrds.Save(SOut);
24    MnTkEdCnt.Save(SOut);  MnTkEdWrds.Save(SOut);  WkEdCnt.Save(SOut);  WkEdWrds.Save(SOut);
25    WkTkEdCnt.Save(SOut);  WkTkEdWrds.Save(SOut);
26    MnRevCnt.Save(SOut);   MnRevWrds.Save(SOut);
27  }
28  TWikiTalkEdge::TWikiTalkEdge() : TotTalks(), TotWords(), TalksBE(), WordsBE(), TalksAE(), WordsAE(), VoteSign(0), FirstTalk(), LastTalk(), VoteTm() {
29  }
30  TWikiTalkEdge::TWikiTalkEdge(const int& _VoteSign) : TotTalks(), TotWords(), TalksBE(), WordsBE(), TalksAE(), WordsAE(),
31    VoteSign(_VoteSign), FirstTalk(), LastTalk(), VoteTm() {
32  }
33  TWikiTalkEdge::TWikiTalkEdge(const TSecTm& FTalk, const TSecTm& LTalk, const int& NTalks, const int& NWords) :
34    TotTalks(NTalks), TotWords(NWords), TalksBE(), WordsBE(), TalksAE(), WordsAE(), VoteSign(0), FirstTalk(FTalk), LastTalk(LTalk), VoteTm() {
35  }
36  TWikiTalkEdge::TWikiTalkEdge(const TWikiTalkEdge& Talk) : TotTalks(Talk.TotTalks), TotWords(Talk.TotWords),
37    TalksBE(Talk.TalksBE), WordsBE(Talk.WordsBE), TalksAE(Talk.TalksAE), WordsAE(Talk.WordsAE),
38    VoteSign(Talk.VoteSign), FirstTalk(Talk.FirstTalk), LastTalk(Talk.LastTalk), VoteTm(Talk.VoteTm) {
39  }
40  TWikiTalkEdge::TWikiTalkEdge(TSIn& SIn) : TotTalks(SIn), TotWords(SIn), TalksBE(SIn), WordsBE(SIn),
41    TalksAE(SIn), WordsAE(SIn), VoteSign(SIn), FirstTalk(SIn), LastTalk(SIn), VoteTm(SIn) {
42  }
43  void TWikiTalkEdge::Save(TSOut& SOut) const {
44    TotTalks.Save(SOut);  TotWords.Save(SOut);
45    TalksBE.Save(SOut);   WordsBE.Save(SOut);
46    TalksAE.Save(SOut);   WordsAE.Save(SOut);
47    VoteSign.Save(SOut);  FirstTalk.Save(SOut);
48    LastTalk.Save(SOut);  VoteTm.Save(SOut);
49  }
50  int TWikiTalkNet::GetUsrNId(const TStr& UsrStr) const {
51    const int KeyId = UsrNIdH.GetKeyId(UsrStr);
52    if (KeyId==-1) { return -1; }
53    else { return UsrNIdH[KeyId]; }
54  }
55  bool TWikiTalkNet::IsUsr(const TStr& UsrStr) const {
56    return UsrNIdH.IsKey(UsrStr);
57  }
58  void TWikiTalkNet::PermuteAllVoteSigns(const bool& OnlyVotes) {
59    printf("\nPermuting %s edge signs\n", OnlyVotes?"VOTE":"ALL");
60    TVec<TWikiTalkEdge> EDatV;
61    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
62      if (OnlyVotes && EI().GetVote() != 0) { EDatV.Add(EI()); }
63      else if (! OnlyVotes){ EDatV.Add(EI()); }
64    }
65    EDatV.Shuffle(TInt::Rnd);
66    int cnt = 0;
67    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
68      if (OnlyVotes && EI().GetVote() != 0) { EI() = EDatV[cnt++]; }
69      else if (! OnlyVotes){ EI() = EDatV[cnt++]; }
70    }
71  }
72  void TWikiTalkNet::PermuteOutVoteSigns(const bool& OnlyVotes) {
73    TIntV VoteSignV;
74    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
75      for (int e = 0; e < NI.GetOutDeg(); e++) {
76        if (OnlyVotes && NI.GetOutEDat(e).GetVote() != 0) {
77          VoteSignV.Add(NI.GetOutEDat(e).GetVote()); }
78        else if (! OnlyVotes) {
79          VoteSignV.Add(NI.GetOutEDat(e).GetVote()); }
80      }
81    }
82    VoteSignV.Shuffle(TInt::Rnd);
83    int cnt = 0;
84    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
85      for (int e = 0; e < NI.GetOutDeg(); e++) {
86        if (OnlyVotes && NI.GetOutEDat(e).GetVote() != 0) {
87          NI.GetOutEDat(e).VoteSign = VoteSignV[cnt++]; }
88        else if (! OnlyVotes) {
89          NI.GetOutEDat(e).VoteSign = VoteSignV[cnt++]; }
90      }
91    }
92  }
93  void TWikiTalkNet::CountStructBalance() const {
94    TIntSet NbrIdSet;
95    THash<TIntTr, TInt> TriadCntH;
96    TIntH SignH;
97    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
98      SignH.AddDat(EI().VoteSign()) += 1;
99    }
100    printf("Structural balance triads:\n  background sign distribution:\n");
101    SignH.SortByKey(false);
102    for (int i = 0; i < SignH.Len(); i++) {
103      printf("\t%2d\t%d\n", SignH.GetKey(i), SignH[i]);
104    }
105    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
106      const TNodeI SrcNI = GetNI(EI.GetSrcNId());
107      const TNodeI DstNI = GetNI(EI.GetDstNId());
108      const TInt E1Dat = EI().VoteSign();
109      NbrIdSet.Clr(false);
110      for (int es = 0; es < SrcNI.GetDeg(); es++) {
111        NbrIdSet.AddKey(SrcNI.GetNbrNId(es)); }
112      for (int ed = 0; ed < DstNI.GetDeg(); ed++) {
113        const int nbr = DstNI.GetNbrNId(ed);
114        if (! NbrIdSet.IsKey(nbr)) { continue; }
115        const TInt E2Dat = SrcNI.GetNbrEDat(NbrIdSet.GetKeyId(nbr)).VoteSign();
116        const TInt E3Dat = DstNI.GetNbrEDat(ed).VoteSign();
117        TriadCntH.AddDat(TIntTr(TMath::Mx(E1Dat, E2Dat, E3Dat),
118          TMath::Median(E1Dat, E2Dat, E3Dat), TMath::Mn(E1Dat, E2Dat, E3Dat))) += 1;
119      }
120    }
121    TriadCntH.SortByKey(false);
122    printf("triad counts (all counts times 3):\n");
123    int SumTriad = 0, SignTriad=0;
124    for (int i = 0; i < TriadCntH.Len(); i++) {
125      SumTriad += TriadCntH[i];
126      TIntTr SignTr = TriadCntH.GetKey(i);
127      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
128        SignTriad += TriadCntH[i];; }
129    }
130    for (int i = 0; i < TriadCntH.Len(); i++) {
131      TIntTr SignTr = TriadCntH.GetKey(i);
132      printf("\t%2d %2d %2d\t%8d\t%f", SignTr.Val1, SignTr.Val2, SignTr.Val3,
133        TriadCntH[i], TriadCntH[i]/double(SumTriad));
134      if (SignTr.Val1!=0 && SignTr.Val2!=0 && SignTr.Val3!=0) {
135        printf("\t%f", TriadCntH[i]/double(SignTriad)); }
136      printf("\n");
137    }
138  }
139  void TWikiTalkNet::FindPartitions(const int& NPart, const bool& OnlyMinus) const {
140    printf("\nFind %d partitions use %s edges\n", NPart, OnlyMinus?"NEGATIVE":"ALL");
141    TIntV NIdV(GetNodes(), 0);
142    TIntH NIdPartH;
143    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
144      NIdPartH.AddDat(NI.GetId(), TInt::Rnd.GetUniDevInt(NPart));
145      NIdV.Add(NI.GetId());
146    }
147    int Flips = 0;
148    TIntPrV CntPartV;
149    for (int p = 0; p < NPart; p++) {
150      CntPartV.Add(TIntPr(0, p)); }
151    for (int iter = 0; iter < 100; iter++) {
152      NIdV.Shuffle(TInt::Rnd);
153      Flips = 0;
154      for (int n = 0; n < NIdV.Len(); n++) {
155        TNodeI NI = GetNI(NIdV[n]);
156        for (int p = 0; p < NPart; p++) {
157          CntPartV[p].Val1=0;  CntPartV[p].Val2=p; }
158        for (int e = 0; e < NI.GetOutDeg(); e++) {
159          const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
160          const int Vote = NI.GetOutEDat(e).GetVote();
161          if (OnlyMinus && Vote==-1) { CntPartV[DstPart].Val1 += -1; }
162          else if (! OnlyMinus) { CntPartV[DstPart].Val1 += Vote; }
163        }
164        CntPartV.Sort(false); 
165        const int NewPart = CntPartV[0].Val2;
166        if (NIdPartH.GetDat(NI.GetId()) != NewPart) {
167          NIdPartH.AddDat(NI.GetId(), NewPart);
168          Flips++;
169        }
170      }
171    }
172    int OkMns=0, OkPls=0, AllMns=0, AllPls=0;
173    TIntH OkPlsH, AllPlsH, OkMnsH, AllMnsH;
174    for (int p = 0; p < NPart; p++) {
175      OkPlsH.AddDat(p,0); AllPlsH.AddDat(p,0);
176      OkMnsH.AddDat(p,0); AllMnsH.AddDat(p,0);
177    }
178    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
179      const int SrcPart = NIdPartH.GetDat(NI.GetId());
180      for (int e = 0; e < NI.GetOutDeg(); e++) {
181        const int DstPart = NIdPartH.GetDat(NI.GetOutNId(e));
182        const int Vote = NI.GetOutEDat(e).GetVote();
183        if (Vote == -1) {
184          if (DstPart != SrcPart) { OkMnsH.AddDat(SrcPart) += 1;  OkMns++; }
185          AllMnsH.AddDat(SrcPart) += 1;  AllMns++; }
186        if (Vote == +1) {
187          if (DstPart == SrcPart) { OkPlsH.AddDat(SrcPart) += 1;  OkPls++; }
188          AllPlsH.AddDat(SrcPart) += 1;  AllPls++;
189        }
190      }
191    }
192    printf("\nSatisfied edges: + : %5d / %5d  = %f\n", OkPls, AllPls, double(OkPls)/double(AllPls));
193    printf(  "                 - : %5d / %5d  = %f\n", OkMns, AllMns, double(OkMns)/double(AllMns));
194    TIntH PartCntH;
195    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
196      PartCntH.AddDat(NIdPartH.GetDat(NI.GetId())) += 1; }
197    PartCntH.SortByKey();
198    for (int p = 0; p < PartCntH.Len(); p++) {
199      printf("  part %2d : %5d (%.4f) nodes: +: %25s    -: %25s\n", p, PartCntH[p], PartCntH[p]/double(NIdPartH.Len()),
200        TStr::Fmt("%5d/%d=%.4f", OkPlsH.GetDat(PartCntH.GetKey(p)), AllPlsH.GetDat(PartCntH.GetKey(p)), OkPlsH.GetDat(PartCntH.GetKey(p))/double(AllPlsH.GetDat(PartCntH.GetKey(p)))).CStr(),
201        TStr::Fmt("%5d/%d=%.4f", OkMnsH.GetDat(PartCntH.GetKey(p)), AllMnsH.GetDat(PartCntH.GetKey(p)), OkMnsH.GetDat(PartCntH.GetKey(p))/double(AllMnsH.GetDat(PartCntH.GetKey(p)))).CStr() );
202    }
203  }
204  void TWikiTalkNet::GetPartStat(const TVec<TIntV>& PartNIdV) const {
205    THash<TIntPr, TIntPr> PartEdgeH;
206    TIntH NIdPartH;
207    for (int p = 0; p < PartNIdV.Len(); p++) {
208      for (int n = 0; n < PartNIdV[p].Len(); n++) {
209        NIdPartH.AddDat(PartNIdV[p][n], p);
210      }
211    }
212    TInt DstPart;
213    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
214      if (! NIdPartH.IsKey(NI.GetId())) { continue; }
215      const int p = NIdPartH.GetDat(NI.GetId());
216      for (int e = 0; e < NI.GetOutDeg(); e++) {
217        const int Vote = NI.GetOutEDat(e).GetVote();
218        TIntPr& IOCnt = PartEdgeH.AddDat(TIntPr(p, Vote));
219        if (NIdPartH.IsKeyGetDat(NI.GetOutNId(e), DstPart) && DstPart==p) {
220          if (Vote==1) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
221        else {
222          if (Vote==-1) { IOCnt.Val1++; } else { IOCnt.Val2++; } }
223      }
224    }
225    PartEdgeH.SortByKey();
226    printf("Partition statistics (satisfied edges):\n");
227    for (int p = 0; p < PartEdgeH.Len(); p++) {
228      printf("  %2d  %2d : %6d : %6d  =  %f\n", PartEdgeH.GetKey(p).Val1, PartEdgeH.GetKey(p).Val2,
229        PartEdgeH[p].Val1(), PartEdgeH[p].Val2(), PartEdgeH[p].Val1/double(PartEdgeH[p].Val1+PartEdgeH[p].Val2));
230    }
231  }
232  PWikiTalkNet TWikiTalkNet::GetVoteSubNet(const int& VoteSign, const bool& VoteOnly, const bool& TalkOnly) const {
233    PWikiTalkNet Net = TWikiTalkNet::New();
234    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
235      if (! (EI().GetVote()==VoteSign || (VoteSign==11 && EI().GetVote()!=0))) { continue; }
236      if (VoteOnly && ! EI().IsVoteE()) { continue; }
237      if (TalkOnly && ! EI().IsTalkE()) { continue; }
238      if (! Net->IsNode(EI.GetSrcNId())) {
239        Net->UsrNIdH.AddDat(EI.GetSrcNDat().Usr, EI.GetSrcNId());
240        Net->AddNode(EI.GetSrcNId(), EI.GetSrcNDat());
241      }
242      if (! Net->IsNode(EI.GetDstNId())) {
243        Net->UsrNIdH.AddDat(EI.GetDstNDat().Usr, EI.GetDstNId());
244        Net->AddNode(EI.GetDstNId(), EI.GetDstNDat());
245      }
246      Net->AddEdge(EI);
247    }
248    TSnap::PrintInfo(Net, TStr::Fmt("Vote network: sign %d %s %s",
249      VoteSign, VoteOnly?"OnlyVote":"", TalkOnly?"OnlyTalk":""));
250    return Net;
251  }
252  PSignNet TWikiTalkNet::GetSignNet(const int& VoteSign, const bool& VoteOnly, const bool& TalkOnly) const {
253    PSignNet Net = TSignNet::New();
254    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
255      if (EI.GetSrcNId() == EI.GetDstNId()) { continue; }
256      if (! (EI().GetVote()==VoteSign || (VoteSign==11 && EI().GetVote()!=0))) { continue; }
257      if (VoteOnly && ! EI().IsVoteE()) { continue; }
258      if (TalkOnly && ! EI().IsTalkE()) { continue; }
259      if (! Net->IsNode(EI.GetSrcNId())) {
260        Net->AddNode(EI.GetSrcNId(), 0); }
261      if (! Net->IsNode(EI.GetDstNId())) {
262        Net->AddNode(EI.GetDstNId(), 0); }
263      Net->AddEdge(EI.GetSrcNId(), EI.GetDstNId(), EI().GetVote());
264    }
265    return Net;
266  }
267  void TWikiTalkNet::TestPartitions(const TStr& OutFNm) {
268    { PSignNet MnsNet = GetSignNet(-1, true, false);
269    PSignNet AllNet = GetSignNet(11, true, false);
270    PSignNet CoreNet = TSnap::GetKCore(TSnap::GetMxWcc(MnsNet), 2);
271    TSnap::PrintInfo(CoreNet, "MINUS K-CORE");
272    for (int npart  = 2; npart < 5; npart++) {
273      printf("\n**** %d-partitions\n", npart);
274      THopfield Hopfield(CoreNet);
275      Hopfield.FindStableSet(npart, 1000);
276      TVec<TIntV> PartNIdV;
277      Hopfield.GetStableSet(990, PartNIdV);
278      Hopfield.PlotPartStab(TStr::Fmt("%s-c2-p%d", OutFNm.CStr(), npart));
279      CoreNet->GetPartStat(PartNIdV, "NETWORK 2-CORE");
280      MnsNet->GetPartStat(PartNIdV, "FULL MINUS NET");
281      AllNet->GetPartStat(PartNIdV, "FULL PLUS-MINUS NET");
282    } }
283    PermuteAllVoteSigns(false);
284    printf("\n*** PERMUTE EDGE SIGNS ************************************************************************************\n");
285    { PSignNet MnsNet = GetSignNet(-1, true, false);
286    PSignNet AllNet = GetSignNet(11, true, false);
287    PSignNet CoreNet = TSnap::GetKCore(TSnap::GetMxWcc(MnsNet), 2);
288    TSnap::PrintInfo(CoreNet, "MINUS K-CORE");
289    for (int npart  = 2; npart < 6; npart++) {
290      printf("\n**** %d-partitions\n", npart);
291      THopfield Hopfield(CoreNet);
292      Hopfield.FindStableSet(npart, 1000);
293      TVec<TIntV> PartNIdV;
294      Hopfield.GetStableSet(990, PartNIdV);
295      Hopfield.PlotPartStab(TStr::Fmt("%s-c2-Rp%d", OutFNm.CStr(), npart));
296      CoreNet->GetPartStat(PartNIdV, "NETWORK 2-CORE");
297      MnsNet->GetPartStat(PartNIdV, "FULL MINUS NET");
298      AllNet->GetPartStat(PartNIdV, "FULL PLUS-MINUS NET");
299    } }
300  }
301  void TWikiTalkNet::PlotBarnStarDelta(const TStr& OutFNm) const {
302    THash<TInt, TMom> DiffMomH;
303    TIntH DiffCntH;
304    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
305      if (EI().GetVote() == 0) { continue; }
306      DiffMomH.AddDat(EI.GetSrcNDat().GetStars()-EI.GetDstNDat().GetStars()).Add(EI().GetVote()==1?1:0);
307      DiffCntH.AddDat(EI.GetSrcNDat().GetStars()-EI.GetDstNDat().GetStars()) += 1;
308    }
309    TGnuPlot::PlotValMomH(DiffMomH, "dBarnStars-"+OutFNm, "Number of BarnStars (over ALL VOTES): "+OutFNm, "Barnstars delta (source - destination)",
310      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, true);
311    TGnuPlot::PlotValCntH(DiffCntH, "dBarnStarts2-"+OutFNm, "Number of BarnSTars (over aLL VOES): "+OutFNm, "Barnstars delta (source - destination)",
312      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
313  }
314  int log10Delta(const int& Delta) {
315    if (Delta == 0) { return 0; }
316    else if (Delta > 0) { return (int)log10((double)Delta)+1; }
317    else if (Delta < 0) { return -(int)log10((double)-Delta)+1; }
318    Fail; return -1;
319  }
320  void TWikiTalkNet::PlotFracPosVsWords(const TStr& OutFNm) const {
321    THash<TInt, TMom> DiffMomH, DiffMomH2, WrdAE, WrdBE, TlkAE, TlkBE;
322    TIntH DiffCntH, DiffCntH2, CWrdAE, CWrdBE, CTlkAE, CTlkBE;
323    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
324      if (EI().GetVote() == 0) { continue; }
325      if (! EI().IsVoteTalkE()) { continue; }
326      if (EI().GetTalks() < 50) {
327        DiffMomH.AddDat(EI().GetTalks()).Add(EI().GetVote()==1?1:0);
328        DiffCntH.AddDat(EI().GetTalks()) += 1;
329        TlkBE.AddDat((EI().GetTalksBE())).Add(EI().GetVote()==1?1:0);
330        CTlkBE.AddDat((EI().GetTalksBE())) += 1;
331        TlkAE.AddDat((EI().GetTalksAE())).Add(EI().GetVote()==1?1:0);
332        CTlkAE.AddDat((EI().GetTalksAE())) += 1;
333      }
334      DiffMomH2.AddDat(log10Delta(EI().GetWords())).Add(EI().GetVote()==1?1:0);
335      DiffCntH2.AddDat(log10Delta(EI().GetWords())) += 1;
336      WrdBE.AddDat(log10Delta(EI().GetWordsBE())).Add(EI().GetVote()==1?1:0);
337      CWrdBE.AddDat(log10Delta(EI().GetWordsBE())) += 1;
338      WrdAE.AddDat(log10Delta(EI().GetWordsAE())).Add(EI().GetVote()==1?1:0);
339      CWrdAE.AddDat(log10Delta(EI().GetWordsAE())) += 1;
340    }
341    TGnuPlot::PlotValMomH(DiffMomH, "talks-"+OutFNm, "Number of talks: "+OutFNm, "Number of times users talked",
342      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
343    TGnuPlot::PlotValCntH(DiffCntH, "talks2-"+OutFNm, "Number of talks: "+OutFNm, "Number of times users talked",
344      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
345    TGnuPlot::PlotValMomH(DiffMomH2, "words-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited",
346      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
347    TGnuPlot::PlotValCntH(DiffCntH2, "words2-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited",
348      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
349    TGnuPlot::PlotValMomH(WrdAE, "wordsBE-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited BEFORE the election (on talk page between a pair)",
350      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
351    TGnuPlot::PlotValCntH(CWrdAE, "wordsBE2-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited BEFORE the election (on talk page between a pair)",
352      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
353    TGnuPlot::PlotValMomH(WrdBE, "wordsAE-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited AFTER the election (on talk page between a pair)",
354      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
355    TGnuPlot::PlotValCntH(CWrdBE, "wordsAE2-"+OutFNm, "Number of words edited: "+OutFNm, "Number of words edited AFTER the election (on talk page between a pair)",
356      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
357    TGnuPlot::PlotValMomH(TlkAE, "talksBE-"+OutFNm, "Number of talks edited: "+OutFNm, "Number of talks BEFORE the election (on talk page between a pair)",
358      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
359    TGnuPlot::PlotValCntH(CTlkAE, "talksBE2-"+OutFNm, "Number of talks edited: "+OutFNm, "Number of talks BEFORE the election (on talk page between a pair)",
360      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
361    TGnuPlot::PlotValMomH(TlkBE, "talksAE-"+OutFNm, "Number of talks edited: "+OutFNm, "Number of talks AFTER the election (on talk page between a pair)",
362      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
363    TGnuPlot::PlotValCntH(CTlkBE, "talksAE2-"+OutFNm, "Number of talks edited: "+OutFNm, "Number of talks AFTER the election (on talk page between a pair)",
364      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
365  }
366  void TWikiTalkNet::PlotFracPosVsWords2(const TStr& OutFNm) const {
367    THash<TInt, TMom> TlkAll, WrdAll, WrdAE, WrdBE, TlkAE, TlkBE, EdtAll, EdtAll2, EdtAll3;
368    TIntH NIdTAE, NIdTBE, NIdTalks, NIdWAE, NIdWBE, NIdWords;
369    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
370      NIdTAE.AddDat(EI.GetDstNId()) += EI().GetTalksAE();
371      NIdTBE.AddDat(EI.GetDstNId()) += EI().GetTalksBE();
372      NIdTalks.AddDat(EI.GetDstNId()) += EI().GetTalks();
373      NIdWAE.AddDat(EI.GetDstNId()) += EI().GetWordsAE();
374      NIdWBE.AddDat(EI.GetDstNId()) += EI().GetWordsBE();
375      NIdWords.AddDat(EI.GetDstNId()) += EI().GetWords();
376    }
377    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
378      if (EI().GetVote() == 0) { continue; }
379      const int C = EI.GetDstNId(); 
380      if (NIdTAE.GetDat(C)<1000) TlkAE.AddDat(NIdTAE.GetDat(C)).Add(EI().GetVote()==1?1:0);
381      if (NIdTBE.GetDat(C)<1000) TlkBE.AddDat(NIdTBE.GetDat(C)).Add(EI().GetVote()==1?1:0);
382      if (NIdTalks.GetDat(C)<1000) TlkAll.AddDat(NIdTalks.GetDat(C)).Add(EI().GetVote()==1?1:0);
383      WrdAE.AddDat(log10Delta(NIdWAE.GetDat(C))).Add(EI().GetVote()==1?1:0);
384      WrdBE.AddDat(log10Delta(NIdWBE.GetDat(C))).Add(EI().GetVote()==1?1:0);
385      WrdAll.AddDat(log10Delta(NIdWords.GetDat(C))).Add(EI().GetVote()==1?1:0);
386      EdtAll.AddDat(log10Delta(EI.GetDstNDat().GetEdCnt())).Add(EI().GetVote()==1?1:0);
387      EdtAll2.AddDat(log10Delta(EI.GetDstNDat().GetAllEdCnt())).Add(EI().GetVote()==1?1:0);
388      EdtAll3.AddDat(log10Delta(EI.GetDstNDat().GetTkEdCnt())).Add(EI().GetVote()==1?1:0);
389    }
390    TGnuPlot::PlotValMomH(EdtAll, "editsTot-"+OutFNm, "Number of edits: "+OutFNm, "Total number of times candidate edited",
391      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
392    TGnuPlot::PlotValMomH(EdtAll2, "editsTot2-"+OutFNm, "Number of edits: "+OutFNm, "Total number of times candidate edited",
393      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
394    TGnuPlot::PlotValMomH(EdtAll3, "editsTot3-"+OutFNm, "Number of edits: "+OutFNm, "Total number of times candidate edited",
395      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
396    TGnuPlot::PlotValMomH(TlkAll, "talksTot-"+OutFNm, "Number of talks: "+OutFNm, "Total number of times candidate talked",
397      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
398    TGnuPlot::PlotValMomH(WrdAE, "wordsBETot-"+OutFNm, "Number of words edited: "+OutFNm, "1+Log_10 Total number of words edited of candidate BEFORE the election",
399      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
400    TGnuPlot::PlotValMomH(WrdBE, "wordsAETot-"+OutFNm, "Number of words edited: "+OutFNm, "1+Log_10 Total number of words edited of candidate AFTER the election",
401      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
402    TGnuPlot::PlotValMomH(WrdAll, "wordsTot-"+OutFNm, "Number of words edited: "+OutFNm, "1+Log_10 Total number of words candidate edited",
403      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
404    TGnuPlot::PlotValMomH(TlkAE, "talksBETot-"+OutFNm, "Number of talks edited: "+OutFNm, "Total number of talks of candidate BEFORE the election",
405      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
406    TGnuPlot::PlotValMomH(TlkBE, "talksAETot-"+OutFNm, "Number of talks edited: "+OutFNm, "Total number of talks of candidate AFTER the election",
407      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
408  }
409  void TWikiTalkNet::PlotNodeAttrDistr(const TStr& OutFNm) const {
410    TIntH BarnStars, AllEdCnt, AllEdWrds, MnEdCnt, MnEdWrds, TkEdCnt, TkEdWrds;
411    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
412      const TWikiUsr& N = NI();
413      BarnStars.AddDat(N.GetStars()) += 1;
414      AllEdCnt.AddDat(N.GetAllEdCnt()) += 1;
415      AllEdWrds.AddDat(1*(N.GetAllWrdCnt()/1)) += 1;
416      MnEdCnt.AddDat(N.GetEdCnt()) += 1;
417      MnEdWrds.AddDat(1*(N.GetWrdCnt()/1)) += 1;
418      TkEdCnt.AddDat(N.GetTkEdCnt()) += 1;
419      TkEdWrds.AddDat(1*(N.GetTkWrdCnt()/1)) += 1;
420    }
421    TGnuPlot::PlotValCntH(BarnStars, "barnStars-"+OutFNm, OutFNm, "Number of barn stars", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
422    TGnuPlot::PlotValCntH(AllEdCnt, "allEdCnt-"+OutFNm, OutFNm, "Number of edits", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
423    TGnuPlot::PlotValCntH(AllEdWrds, "allEdWrds-"+OutFNm, OutFNm, "Number of edited words", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
424    TGnuPlot::PlotValCntH(MnEdCnt, "MnEdCnt-"+OutFNm, OutFNm, "Number of edits on MAIN pages", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
425    TGnuPlot::PlotValCntH(MnEdWrds, "MnEdWrds-"+OutFNm, OutFNm, "Number of edited words onmain pages", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
426    TGnuPlot::PlotValCntH(TkEdCnt, "tkEdCnt-"+OutFNm, OutFNm, "Number of edits on TALK pages", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
427    TGnuPlot::PlotValCntH(TkEdWrds, "tkEdWrds-"+OutFNm, OutFNm, "Number of edited words onmain pages", "Number of users", gpsLog, false, gpwLinesPoints, false, false);
428  }
429  void TWikiTalkNet::PlotFracPosVsEdgeAttr(const TStr& OutFNm) const {
430    THash<TInt, TMom> EdgeTalksH, EdgeTalksH2, EdgeWordsH;
431    THash<TInt, TMom> dBarnStars, dAllEdCnt, dAllEdWrds;
432    TIntH dBarnStarsCnt, dAllEdCntCnt, dAllEdWrdsCnt;
433    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
434      const int Val = EI().GetVote() ==1 ? 1 : 0;
435      if (EI().GetTalks() < 100) {
436        EdgeTalksH.AddDat(int(EI().GetTalks())).Add(Val);
437      }
438      EdgeTalksH2.AddDat((int)log10((double)EI().GetTalks())).Add(Val);
439      EdgeWordsH.AddDat((int)log10((double)EI().GetWords())).Add(Val);
440      const TWikiUsr& S = EI.GetSrcNDat();
441      const TWikiUsr& D = EI.GetDstNDat();
442      if (abs(S.GetStars()-D.GetStars()) < 10) {
443        dBarnStars.AddDat(S.GetStars()-D.GetStars()).Add(Val);
444        dBarnStarsCnt.AddDat(S.GetStars()-D.GetStars())++;
445      }
446      dAllEdCnt.AddDat(log10Delta(S.GetAllEdCnt()-D.GetAllEdCnt())).Add(Val);
447      dAllEdCntCnt.AddDat(log10Delta(S.GetAllEdCnt()-D.GetAllEdCnt()))++;
448      dAllEdWrds.AddDat(log10Delta(S.GetAllWrdCnt()-D.GetAllWrdCnt())).Add(Val);
449      dAllEdWrdsCnt.AddDat(log10Delta(S.GetAllWrdCnt()-D.GetAllWrdCnt()))++;
450    }
451    const bool SDev = true;
452    TGnuPlot::PlotValMomH(EdgeTalksH, "edgeTks"+OutFNm, OutFNm, "Number of talks over the edge", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
453    TGnuPlot::PlotValMomH(EdgeTalksH2, "edgeTks2"+OutFNm, OutFNm, "1+Log_{10} Number of talks over the edge", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
454    TGnuPlot::PlotValMomH(EdgeWordsH, "edgeWrds"+OutFNm, OutFNm, "1+Log_{10} Number of words over all talks over the edge", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
455    TGnuPlot::PlotValMomH(dBarnStars, "dBarnStars-"+OutFNm, OutFNm, "delta BarnStars", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
456    TGnuPlot::PlotValMomH(dAllEdCnt, "dAllEdCnt-"+OutFNm, OutFNm, "delta AllEdCnt", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
457    TGnuPlot::PlotValMomH(dAllEdWrds, "dAllEdWrds-"+OutFNm, OutFNm, "delta AllEdWrds", "Fraction of positive edges", gpsAuto, gpwLinesPoints, true, false, false, false, false, SDev);
458    TGnuPlot::PlotValCntH(dBarnStarsCnt, "dBarnStarsCnt-"+OutFNm, OutFNm, "delta BarnStars", "Count", gpsAuto);
459    TGnuPlot::PlotValCntH(dAllEdCntCnt, "dAllEdCntCnt-"+OutFNm, OutFNm, "delta AllEdCnt", "Count", gpsAuto);
460    TGnuPlot::PlotValCntH(dAllEdWrdsCnt, "dAllEdWrdsCnt-"+OutFNm, OutFNm, "delta AllEdWrds", "Count", gpsAuto);
461  }
462  void TWikiTalkNet::PlotVoteSignCmnFriends(const TStr& OutFNm) const {
463    TFltFltH SupRngH, OppRngH; 
464    TFltFltH SupCmnH, OppCmnH; 
465    THash<TFlt, TMom> RngFracH, CmnFracH; 
466    PWikiTalkNet ThisPt = PWikiTalkNet((TWikiTalkNet*) this);
467    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
468      const int C = -1; Fail;
469      const int R = -1; 
470      if (EI().GetVote() == 1) {
471        SupRngH.AddDat(R)++;  RngFracH.AddDat(R).Add(1);
472        SupCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(1);
473      } else if (EI().GetVote() == -1) {
474        OppRngH.AddDat(R)++;  RngFracH.AddDat(R).Add(0);
475        OppCmnH.AddDat(C)++;  CmnFracH.AddDat(C).Add(0);
476      }
477    }
478    TGnuPlot::PlotValCntH(SupRngH, "rngSup-"+OutFNm, "range of support votes", "range (path length after edge is removed)", "count");
479    TGnuPlot::PlotValCntH(OppRngH, "rngOpp-"+OutFNm, "range of opposing votes", "range (path length after edge is removed)", "count");
480    TGnuPlot::PlotValCntH(SupCmnH, "cmnSup-"+OutFNm, "number of common friends of support votes", "number of common friends", "count", gpsLog);
481    TGnuPlot::PlotValCntH(OppCmnH, "cmnOpp-"+OutFNm, "number of common friends of opposing votes", "number of common friends", "count", gpsLog);
482    TGnuPlot::PlotValMomH(RngFracH, "fracRng-"+OutFNm, "fraction of support edges spanning range X", "range", "fraction of support edges");
483    TGnuPlot::PlotValMomH(CmnFracH, "fracCmn-"+OutFNm, "fraction of support edges having X common neighbors", "number of common neighbors", "fraction of support edges", gpsLog);
484  }
485  void TWikiTalkNet::SaveAreaUTrailAttr(const TStr& OutFNm, const int& MinUsrVotes, const TWikiElecBs& ElecBs) const {
486    TIntV UIdV;
487    TFltV AreaV;
488    TIntSet AdminSet, ElecUsrV;
489    { TIntSet FqVoterSet; ElecBs.GetFqVoters(FqVoterSet, MinUsrVotes, 10, false); FqVoterSet.GetKeyV(UIdV);
490    TIntV ElecUIdV; ElecBs.GetElecUsrV(ElecUIdV); ElecUsrV=TIntSet(ElecUIdV); }
491    ElecBs.GetUsrAreaUTrail(UIdV, AreaV);
492    ElecBs.GetAdminSet(AdminSet);
493    FILE *F = fopen(OutFNm.CStr(), "wt");
494    fprintf(F, "Area\tUser\tIsAdmin\tIsElec\tTalkOutDeg\tInDeg\tTalkTriads\tBarnStars\tInAdmins\tOutAdmins\tAllEdCnt\tAllWrdCnt\tRevCnt\tRevWrds\n");
495    printf("%d users", UIdV.Len());
496    int skip=0;
497    for (int u = 0; u < UIdV.Len(); u++) {
498      TStr Usr = ElecBs.GetUsr(UIdV[u]);
499      if (! IsUsr(Usr)) {  printf("x"); skip++; continue; } else { printf("."); }
500      fprintf(F, "%f\t%s\t%d\t%d", AreaV[u], Usr.CStr(), AdminSet.IsKey(UIdV[u])?1:0, ElecUsrV.IsKey(UIdV[u])?1:0);
501      TNodeI U =  GetNI(GetUsrNId(Usr));
502      fprintf(F, "\t%d\t%d\t%d", U.GetOutDeg(), U.GetInDeg(), TSnap::GetNodeTriads<PWikiTalkNet>((TWikiTalkNet*)this, U.GetId()));
503      int OutAdmins=0, InAdmins=0;
504      for (int i = 0; i < U.GetOutDeg(); i++) {
505        if (U.GetOutNDat(i).IsAdmin()) { OutAdmins++; } }
506      for (int i = 0; i < U.GetInDeg(); i++) {
507        if (U.GetInNDat(i).IsAdmin()) { InAdmins++; } }
508      fprintf(F, "\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", U().GetStars(), OutAdmins, InAdmins,
509        U().GetAllEdCnt(), U().GetAllWrdCnt(), U().GetRevCnt(), U().GetRevWrds());
510      fflush(F);
511    }
512    fclose(F);
513    printf("\n%d users, %d skip\n", UIdV.Len(), skip);
514  }
515  void TWikiTalkNet::DumpEdgeStat() const {
516    TIntH VoteE, TalkE, AllE, VtTkE;
517    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
518      const TWikiTalkEdge& E = EI();
519      const int V = E.GetVote();
520      AllE.AddDat(V) += 1;
521      if (E.IsTalkE()) { TalkE.AddDat(V)+=1; }
522      if (E.IsVoteE()) { VoteE.AddDat(V)+=1; }
523      if (E.IsVoteTalkE()) { VtTkE.AddDat(V)+=1; }
524    }
525    VoteE.SortByKey(); TalkE.SortByKey(); AllE.SortByKey(); VtTkE.SortByKey();
526    printf("Edge\tAll\tTalk\tVote\tVoteTalk\n");
527    for (int e = 0; e < AllE.Len(); e++) {
528      const int v = AllE.GetKey(e);
529      printf("%4d\t%7d\t%7d\t%7d\t%7d\n", v, AllE[e], TalkE.IsKey(v)?TalkE.GetDat(v):0,
530        VoteE.IsKey(v)?VoteE.GetDat(v):0, VtTkE.IsKey(v)?VtTkE.GetDat(v):0);
531    }
532    printf("\n");
533  }
534  void TWikiTalkNet::ClearElecData() {
535    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
536      EI().VoteSign = -1;
537      EI().VoteTm = TSecTm();
538    }
539    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
540      NI().Admin = false;
541      NI().ElecTm = TSecTm();
542    }
543  }
544  void TWikiTalkNet::ImposeElecNet(const TWikiElecBs& ElecBs, const THash<TChA, TChA>& UsrChageH, const bool& AddVoteOnlyEdges) {
545    int GoodEl=0, ESet=0, ESkip=0, GoodVotes=0, AllCmts=0, VoteEdge=0;
546    int DstNf=0, SrcNf=0;
547    for (int e = 0; e < ElecBs.Len(); e++) {
548      const TWikiElec& E = ElecBs[e];
549      TChA DstUsr = ElecBs.GetUsr(E.GetUId());  DstUsr.ToLc();
550      if (UsrChageH.IsKey(DstUsr)) { DstUsr = UsrChageH.GetDat(DstUsr); }
551      if (! UsrNIdH.IsKey(DstUsr)) { DstNf++; continue; }
552      GoodEl++;
553      TWikiElec Votes;
554      E.GetOnlyVotes(Votes, false);
555      AllCmts += E.Len();
556      GoodVotes += Votes.Len();
557      for (int v = 0; v < Votes.Len(); v++) {
558        TChA SrcUsr = ElecBs.GetUsr(E.GetVote(v).GetUId());  SrcUsr.ToLc();
559        if (UsrChageH.IsKey(SrcUsr)) { SrcUsr = UsrChageH.GetDat(SrcUsr); }
560        if (! UsrNIdH.IsKey(SrcUsr)) { SrcNf++;  continue; }
561        const int SrcId = UsrNIdH.GetDat(SrcUsr);
562        const int DstId = UsrNIdH.GetDat(DstUsr);
563        if (SrcId==DstId) { continue; }
564        if (IsEdge(SrcId, DstId)) {
565          GetEDat(SrcId, DstId).VoteSign = E.GetVote(v).GetVote();
566          GetEDat(SrcId, DstId).VoteTm = E.GetVote(v).GetTm();
567          ESet++;
568        }
569        else if (AddVoteOnlyEdges) {
570          AddEdge(SrcId, DstId);
571          TWikiTalkEdge& EdgeDat = GetEDat(SrcId, DstId);
572          EdgeDat.VoteSign = E[v].GetVote();
573          EdgeDat.VoteTm = E[v].GetTm();
574          VoteEdge++;
575        }
576        else { ESkip++; }
577      }
578    }
579    printf("admins that talk (good elections): %d / %d\n", GoodEl, ElecBs.Len());
580    printf("actual votes vs. comments in elections: %d / %d : %f\n", GoodVotes, AllCmts, GoodVotes/double(AllCmts));
581    printf("votes where both users talk %d (%f of votes where nodes exist)\n", ESet, ESet/double(ESet+ESkip));
582    printf("fraction of all votes found in the graph: %d/%d : %f\n", ESet, GoodVotes, ESet/double(GoodVotes));
583    printf("destination not found: %d\n", DstNf);
584    printf("source not found: %d\n", SrcNf);
585    printf("talk+vote: %d  vote: %d  skip: %d\n", ESet, VoteEdge, ESkip);
586  }
587  PWikiTalkNet TWikiTalkNet::LoadTalkNet(const TStr& ParsedWikiDir, const TWikiElecBs& ElecBs) {
588    const TStr WikiUsrTalk = "enwiki-20080103.user_talk.7z"; 
589    const TStr WikiMain = "enwiki-20080103.main.7z";
590    const TStr WikiMainTalk = "enwiki-20080103.talk.7z";
591    const TStr WikiWiki = "enwiki-20080103.wikipedia.7z";
592    const TStr WikiWikiTalk = "enwiki-20080103.wikipedia_talk.7z";
593    const TStr BarnStartList = "barnstars.history.unsorted";
594    const TStr AdminList = "enwiki.admins2009.txt";
595    const TStr BotList = "enwiki.botlist.2007-03";
596    const TStr UsrChanges = "enwiki.important-username-changes.2007-08-06.txt";
597    THash<TChA, TChA> UsrMapH;
598    THashSet<TChA> BotSet;
599    THash<TChA, TInt> UsrElecId; 
600    TChA Ln;
601    TExeTm ExeTm;
602    for (TFIn FIn(ParsedWikiDir+BotList); FIn.GetNextLn(Ln); ) {
603      BotSet.AddKey(Ln.ToLc()); }
604    printf("Bots: %d bots\n", BotSet.Len());
605    for (TSsParser Ss(ParsedWikiDir+UsrChanges, ssfSpaceSep); Ss.Next(); ) {
606      TChA U1=Ss[0], U2=Ss[1]; if (U1.ToLc()!=U2.ToLc()) { UsrMapH.AddDat(U1,U2); }
607    }
608    printf("User changes: %d chages\n", UsrMapH.Len());
609    for (int e = 0; e < ElecBs.Len(); e++) {
610      UsrElecId.AddDat(ElecBs.GetUsr(ElecBs[e].GetUId()), e); }
611    printf("Elections: %d users up for election\n", UsrElecId.Len());
612    printf("Load WikiTalk network:");
613    PWikiTalkNet Net = TWikiTalkNet::New();
614    printf("  Load %s ", WikiUsrTalk.CStr());
615    { TWikiMetaLoader WML(ParsedWikiDir+WikiUsrTalk);
616    int src, dst, k, elecSet=0;
617    for (int edges=0; WML.Next(); edges++) {
618      if (! WML.Title.IsPrefix("User_talk:")) { printf("."); continue; }
619      const int b = (int) strlen("User_talk:");
620      int e2 = WML.Title.SearchCh('/', b)-1;
621      if (e2<0) { e2=TInt::Mx; }
622      TChA Dst = WML.Title.GetSubStr(b, e2).ToLc();
623      TChA Src = WML.Usr.ToLc();
624      if (BotSet.IsKey(Src) || BotSet.IsKey(Dst)) { printf(""); continue; }
625      if (TWikiMetaLoader::IsIpAddr(Src) || TWikiMetaLoader::IsIpAddr(Dst)) { printf(""); continue; }
626      if (Src != Dst) { 
627        k = UsrMapH.GetKeyId(Src);
628        if (k != -1) { Src = UsrMapH[k]; }
629        k = UsrMapH.GetKeyId(Dst);
630        if (k != -1) { Dst = UsrMapH[k]; }
631        src = Net->UsrNIdH.AddDatId(Src);
632        dst = Net->UsrNIdH.AddDatId(Dst);
633        IAssert(src != dst);
634        if (! Net->IsNode(src)) {
635          Net->AddNode(src, TWikiUsr(Src));
636          if (UsrElecId.IsKey(Src)) { printf("T"); elecSet++; 
637            Net->GetNDat(src).ElecTm = ElecBs.GetElec(UsrElecId.GetDat(Src)).GetTm();  }
638        }
639        if (! Net->IsNode(dst)) {
640          Net->AddNode(dst, TWikiUsr(Dst));
641          if (UsrElecId.IsKey(Dst)) { printf("T"); elecSet++; 
642            Net->GetNDat(dst).ElecTm = ElecBs.GetElec(UsrElecId.GetDat(Dst)).GetTm(); }
643        }
644        if (! Net->IsEdge(src, dst)) {
645          Net->AddEdge(src, dst, TWikiTalkEdge(WML.RevTm, WML.RevTm, 1, WML.RevWrds));
646        }
647        TWikiTalkEdge& TalkEdge = Net->GetEDat(src, dst);
648        if (TalkEdge.FirstTalk > WML.RevTm) { TalkEdge.FirstTalk = WML.RevTm; }
649        if (TalkEdge.LastTalk < WML.RevTm) { TalkEdge.LastTalk = WML.RevTm; }
650        TalkEdge.TotWords += WML.RevWrds;
651        TalkEdge.TotTalks += 1;
652        const TSecTm DstElecTm = Net->GetNDat(dst).ElecTm;
653        if (DstElecTm.IsDef()) { 
654          if (WML.RevTm < DstElecTm) { TalkEdge.TalksBE++; TalkEdge.WordsBE+=WML.RevWrds; }
655          else { TalkEdge.TalksAE++; TalkEdge.WordsAE+=WML.RevWrds; }
656        }
657      }
658    }
659    printf("DONE NET[%s]\n", ExeTm.GetStr());  ExeTm.Tick();
660    printf("node election time %d / %d (%f)\n", elecSet, UsrElecId.Len(), elecSet/double(UsrElecId.Len())); }
661    TSnap::PrintInfo(Net, "WikiUserTalk network.");
662    printf(" [%s]\n  Loading %s\n", ExeTm.GetStr(), BarnStartList.CStr());  ExeTm.Tick();
663    int cnt=0, cnt2=0;
664    for (TSsParser Ss(ParsedWikiDir+BarnStartList, ssfSpaceSep); Ss.Next(); cnt2++) { TChA U1=Ss[3]; U1.ToLc();
665      if (UsrMapH.IsKey(U1)) { U1 = UsrMapH.GetDat(U1); }
666      if (Net->UsrNIdH.IsKey(U1)) { cnt++;
667        Net->GetNDat(Net->UsrNIdH.GetDat(U1)).BarnStars += 1; }
668    }
669    printf("    %d / %d stars set [%s]\n  Loading %s\n", cnt, cnt2, ExeTm.GetStr(), AdminList.CStr());  ExeTm.Tick();
670    cnt=0; cnt2=0;
671    for (TFIn FIn(ParsedWikiDir+AdminList); FIn.GetNextLn(Ln); cnt2++) { Ln.ToLc();
672      if (UsrMapH.IsKey(Ln)) { Ln = UsrMapH.GetDat(Ln); }
673      if (Net->UsrNIdH.IsKey(Ln)) { cnt++;
674        Net->GetNDat(Net->UsrNIdH.GetDat(Ln)).Admin = true; }
675    }/&bsol;*/
676    printf("    %d / %d admins set [%s]\n", cnt, cnt2, ExeTm.GetStr());
677    TIntSet AdminSet; ElecBs.GetAdminSet(AdminSet);
678    for (int a = 0; a < AdminSet.Len(); a++, cnt2++) {
679      TChA Ln = ElecBs.GetUsr(AdminSet[a]);
680      if (Net->UsrNIdH.IsKey(Ln)) { cnt++;
681        Net->GetNDat(Net->UsrNIdH.GetDat(Ln)).Admin = true; }
682    }
683    printf("    %d / %d admins set [%s]\n", cnt, cnt2, ExeTm.GetStr());
684    Net->ImposeElecNet(ElecBs, UsrMapH, true); 
685    TSnap::PrintInfo(Net);
686    printf("SAVE DONE.\n\nLoading user edit statistics:\n");
687    printf("  Loading %s ", WikiMain.CStr());
688    { TWikiMetaLoader WML(ParsedWikiDir+WikiMain);
689    for (int rec=0; WML.Next(); rec++) {
690      const TChA& U = WML.Usr;
691      const int keyId = Net->UsrNIdH.GetKeyId(U);
692      if (keyId == -1) { continue; }
693      TWikiUsr& WU = Net->GetNDat(Net->UsrNIdH[keyId]);
694      WU.MnEdCnt += 1;  WU.MnEdWrds += WML.RevWrds;
695      WML.CommentStr.ToLc();
696      if (WML.CommentStr.IsPrefix("rv") || WML.CommentStr.SearchStr("revert")!=-1) {
697        WU.MnRevCnt+=1; WU.MnRevWrds+=WML.RevWrds; }
698    } }
699    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiMainTalk.CStr());  ExeTm.Tick();
700    { TWikiMetaLoader WML(ParsedWikiDir+WikiMainTalk);
701    for (int rec=0; WML.Next(); rec++) {
702      const TChA& U = WML.Usr.ToLc();
703      const int keyId = Net->UsrNIdH.GetKeyId(U);
704      if (keyId == -1) { continue; }
705      TWikiUsr& WU = Net->GetNDat(Net->UsrNIdH[keyId]);
706      WU.MnTkEdCnt += 1;  WU.MnTkEdWrds += WML.RevWrds;
707    } }
708    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWiki.CStr());  ExeTm.Tick();
709    { TWikiMetaLoader WML(ParsedWikiDir+WikiWiki);
710    for (int rec=0; WML.Next(); rec++) {
711      const TChA& U = WML.Usr.ToLc();
712      const int keyId = Net->UsrNIdH.GetKeyId(U);
713      if (keyId == -1) { continue; }
714      TWikiUsr& WU = Net->GetNDat(Net->UsrNIdH[keyId]);
715      WU.WkEdCnt += 1;  WU.WkEdWrds += WML.RevWrds;
716    } }
717    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWikiTalk.CStr());  ExeTm.Tick();
718    { TWikiMetaLoader WML(ParsedWikiDir+WikiWikiTalk);
719    for (int rec=0; WML.Next(); rec++) {
720      const TChA& U = WML.Usr.ToLc();
721      const int keyId = Net->UsrNIdH.GetKeyId(U);
722      if (keyId == -1) { continue; }
723      TWikiUsr& WU = Net->GetNDat(Net->UsrNIdH[keyId]);
724      WU.WkTkEdCnt += 1;  WU.WkTkEdWrds += WML.RevWrds;
725    } }
726    TSnap::PrintInfo(Net, "WikiUserTalk network.");
727    printf("\n[%s]\nDONE.\n", ExeTm.GetStr());
728    return Net;
729  }
730  PWikiTalkNet TWikiTalkNet::LoadSlashdot(const TStr& InFNm) {
731    THashSet<TChA> NIdSet;
732    TChA LnStr;
733    TVec<char *> WrdV;
734    int Sign;
735    PWikiTalkNet Net = TWikiTalkNet::New();
736    for (TFIn FIn(InFNm); FIn.GetNextLn(LnStr); ) {
737      if (LnStr.Empty() || LnStr[0]=='#') { continue; }
738      LnStr.ToLc();
739      TStrUtil::SplitOnCh(LnStr, WrdV, '\t', false);
740      NIdSet.AddKey(WrdV[0]);
741      if (strcmp(WrdV[1], "friends")==0) { Sign = 1; }
742      else if (strcmp(WrdV[1], "fans")==0) { continue; } 
743      else if (strcmp(WrdV[1], "foes")==0) { Sign = -1; }
744      else { Fail; }
745      const int SrcNId = NIdSet.AddKey(WrdV[0]);
746      if (! Net->IsNode(SrcNId)) {
747        Net->AddNode(SrcNId, TWikiUsr(WrdV[0]));
748        Net->UsrNIdH.AddDat(WrdV[0], SrcNId);
749      }
750      for (int e = 2; e < WrdV.Len(); e++) {
751        const int DstNId = NIdSet.AddKey(WrdV[e]);
752        if (! Net->IsNode(DstNId)) {
753          Net->AddNode(DstNId, TWikiUsr(WrdV[e]));
754          Net->UsrNIdH.AddDat(WrdV[e], DstNId);
755        }
756        if (SrcNId != DstNId && ! Net->IsEdge(SrcNId, DstNId)) {
757          Net->AddEdge(SrcNId, DstNId, TWikiTalkEdge(Sign));
758        }
759      }
760    }
761    TSnap::PrintInfo(Net, InFNm);
762    return Net;
763  }
764  PWikiTalkNet TWikiTalkNet::LoadOldNet(const TStr& InFNm) {
765    typedef TNodeEDatNet<TStr, TInt> TOldNet;
766    PWikiTalkNet Net = TWikiTalkNet::New();
767    TPt<TOldNet> ON = TOldNet::Load(TZipIn(InFNm));
768    TSnap::PrintInfo(ON);
769    for(TOldNet::TEdgeI EI = ON->BegEI(); EI<ON->EndEI(); EI++) {
770      if (! Net->IsNode(EI.GetSrcNId())) {
771        Net->AddNode(EI.GetSrcNId(), TWikiUsr(EI.GetSrcNDat().GetLc()));
772        Net->UsrNIdH.AddDat(EI.GetDstNDat().GetLc(), EI.GetSrcNId());
773      }
774      if (! Net->IsNode(EI.GetDstNId())) {
775        Net->AddNode(EI.GetDstNId(), TWikiUsr(EI.GetDstNDat().GetLc()));
776        Net->UsrNIdH.AddDat(EI.GetDstNDat().GetLc(), EI.GetDstNId());
777      }
778      Net->AddEdge(EI.GetSrcNId(), EI.GetDstNId(), TWikiTalkEdge(EI()));
779    }
780    TSnap::PrintInfo(Net);
781    return Net;
782  }
783  PNGraph TWikiTimeTalkNet::GetBeforeTimeG(const TSecTm& EdgeTm) const {
784    PNGraph G = TNGraph::New();
785    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
786      if (EI().Tm <= EdgeTm) {
787        if (! G->IsNode(EI.GetSrcNId())) { G->AddNode(EI.GetSrcNId()); }
788        if (! G->IsNode(EI.GetDstNId())) { G->AddNode(EI.GetDstNId()); }
789        G->AddEdge(EI.GetSrcNId(), EI.GetDstNId());
790      }
791    }
792    return G;
793  }
794  PSignNet TWikiTimeTalkNet::GetBeforeTimeNet(const TSecTm& EdgeTm) const {
795    PSignNet Net = TSignNet::New();
796    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
797      if (EI().Tm <= EdgeTm) {
798        if (! Net->IsNode(EI.GetSrcNId())) { Net->AddNode(EI.GetSrcNId()); }
799        if (! Net->IsNode(EI.GetDstNId())) { Net->AddNode(EI.GetDstNId()); }
800        Net->AddEdge(EI.GetSrcNId(), EI.GetDstNId());
801        Net->GetEDat(EI.GetSrcNId(), EI.GetDstNId()) += EI().Words;
802      }
803    }
804    return Net;
805  }
806  void TWikiTimeTalkNet::SaveDataset(const TWikiElecBs& ElecBs, const TStr& OutFNm) const {
807    FILE *F = fopen(OutFNm.CStr(), "wt");
808    fprintf(F, "SuccElec\tRfa\tNetNodes\tNetEdges\tNetConstraint\tBarnStars\tTalkOutDeg\tTalkInDeg\tTalkTriads\tInWords\tOutWords\tInAdmins\tOutAdmins\tAdminTriads\tInAdminWords\tOutAdminWords\n");
809    TStrSet AdminSet;
810    for (TSsParser Ss("W:\\Data\\wiki20080103-parseByGuerogy\\enwiki.admins2009.txt", ssfTabSep); Ss.Next(); ) {
811      TStr A=Ss[0]; AdminSet.AddKey(A.GetTrunc().GetLc());
812    }
813    TExeTm ExeTm;
814    TBarnStars  BarnStars;
815    TIntSet AdminNIdSet;
816    printf("Admin list: %d\n", AdminSet.Len());
817    for (int e = 0; e < ElecBs.Len(); e++) {
818      const TWikiElec& E = ElecBs.GetElec(e);
819      const TStr Usr = ElecBs.GetUsr(E.UsrId);
820      printf("%s: %s   ", Usr.CStr(), E.RfaTitle.CStr());
821      if (! UsrNIdH.IsKey(Usr)) {
822        printf(" DOES NOT TALK\n", Usr.CStr()); continue;
823      }
824      PSignNet Net = GetBeforeTimeNet(E.ElecTm);
825      const int NId = UsrNIdH.GetDat(Usr);
826      if (! Net->IsNode(NId)) {
827        printf(" TALKS AFTER ELECTION\n"); continue;
828      }
829      const TSignNet::TNodeI NI = Net->GetNI(NId);
830      printf(" deg %d:%d ", NI.GetInDeg(), NI.GetOutDeg());
831      int InWgt=0, OutWgt=0, InAdmins=0, OutAdmins=0, InAWgt=0, OutAWgt=0;
832      AdminNIdSet.Clr(false);
833      AdminNIdSet.AddKey(NI.GetId());
834      for (int i = 0; i < NI.GetOutDeg(); i++) {
835        OutWgt += NI.GetOutEDat(i);
836        if (AdminSet.IsKey(UsrNIdH.GetKey(NI.GetOutNId(i)))) {
837          OutAWgt += NI.GetOutEDat(i);
838          OutAdmins++;
839          AdminNIdSet.AddKey(NI.GetOutNId(e));
840        }
841      }
842      for (int i = 0; i < NI.GetInDeg(); i++) {
843        InWgt += NI.GetInEDat(i);
844        if (AdminSet.IsKey(UsrNIdH.GetKey(NI.GetInNId(i)))) {
845          InAWgt += NI.GetInEDat(i);
846          InAdmins++;
847          AdminNIdSet.AddKey(NI.GetInNId(e));
848        }
849      }
850      TSnap::TNetConstraint<PSignNet> NetC(Net, false);
851      NetC.CalcConstraints(NId);
852      TIntV AdminV; AdminNIdSet.GetKeyV(AdminV);
853      const double C = NetC.GetNodeC(NId);
854      const int BS = BarnStars.GetBarnStars(Usr, E.GetTm());
855      const int Triads = TSnap::GetNodeTriads(Net, NI.GetId());
856      const int AdmintTriads = TSnap::GetNodeTriads(TSnap::GetSubGraph(Net, AdminV), NI.GetId());
857      fprintf(F, "%d\t%s\t%d\t%d\t%f\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", E.IsSucc?1:0, E.RfaTitle.CStr(), Net->GetNodes(), Net->GetEdges(), C, BS,
858        NI.GetOutDeg(), NI.GetInDeg(), Triads, InWgt, OutWgt, InAdmins, OutAdmins, AdmintTriads, InAWgt, OutAWgt);
859      fflush(F);
860      printf(" [%s]\n", ExeTm.GetStr());
861    }
862    fclose(F);
863  }
864  PWikiTimeTalkNet TWikiTimeTalkNet::LoadWikiTimeTalkNet() {
865    const TStr WikiUsrTalk = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki-20080103.user_talk.7z"; 
866    const TStr UsrChanges = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki.important-username-changes.2007-08-06";
867    const TStr BotList = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki.botlist.2007-03";
868    THash<TChA, TChA> UsrMapH;
869    THashSet<TChA> BotSet;
870    TChA Ln;
871    TExeTm ExeTm;
872    for (TFIn FIn(BotList); FIn.GetNextLn(Ln); ) {
873      BotSet.AddKey(Ln.ToLc()); }
874    printf("Bots: %d bots\n", BotSet.Len());
875    for (TSsParser Ss(UsrChanges, ssfSpaceSep); Ss.Next(); ) {
876      TChA U1=Ss[3], U2=Ss[4]; if (U1.ToLc()!=U2.ToLc()) { UsrMapH.AddDat(U1,U2); } }
877    printf("User changes: %d chages\n", UsrMapH.Len());
878    printf("Load Take network before the election:");
879    PWikiTimeTalkNet Net = TWikiTimeTalkNet::New();
880    printf("  Load %s ", WikiUsrTalk.CStr());
881    TWikiMetaLoader WML(WikiUsrTalk);
882    int src, dst, k;
883    for (int edges=0; WML.Next(); edges++) {
884      if (! WML.Title.IsPrefix("User_talk:")) { printf("."); continue; }
885      const int b = (int) strlen("User_talk:");
886      int e2 = WML.Title.SearchCh('/', b)-1;
887      if (e2<0) { e2=TInt::Mx; }
888      TChA Dst = WML.Title.GetSubStr(b, e2).ToLc();
889      TChA Src = WML.Usr.ToLc();
890      if (BotSet.IsKey(Src) || BotSet.IsKey(Dst)) { printf(""); continue; }
891      if (TWikiMetaLoader::IsIpAddr(Src) || TWikiMetaLoader::IsIpAddr(Dst)) { printf(""); continue; }
892      if (Src != Dst) { 
893        k = UsrMapH.GetKeyId(Src);
894        if (k != -1) { Src = UsrMapH[k]; }
895        k = UsrMapH.GetKeyId(Dst);
896        if (k != -1) { Dst = UsrMapH[k]; }
897        src = Net->UsrNIdH.AddDatId(Src);
898        dst = Net->UsrNIdH.AddDatId(Dst);
899        if (src != dst) {
900          if (! Net->IsNode(src)) { Net->AddNode(src, Src); }
901          if (! Net->IsNode(dst)) { Net->AddNode(dst, Dst); }
902          Net->AddEdge(src, dst, -1, TWikiTalkEdge2(WML.RevTm, WML.RevWrds));
903        }
904      }
905    }
906    printf("DONE NET[%s]\n", ExeTm.GetStr());  ExeTm.Tick();
907    return Net;
908  }
909  void TWikiEditCnt::LoadTxtBeforeElec(const TWikiElecBs& ElecBs) {
910    const TStr WikiMain = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.main.7z";
911    const TStr WikiMainTalk = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.talk.7z";
912    const TStr WikiWiki = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.wikipedia.7z";
913    const TStr WikiWikiTalk = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.wikipedia_talk.7z";
914    const TStr UsrChanges = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki.important-username-changes.2007-08-06";
915    THash<TChA, TChA> UsrMapH;
916    for (TSsParser Ss(UsrChanges, ssfSpaceSep); Ss.Next(); ) {
917      TChA U1=Ss[3], U2=Ss[4]; if (U1.ToLc()!=U2.ToLc()) { UsrMapH.AddDat(U1,U2); } }
918    THash<TChA, TVec<TPair<TChA, TSecTm> > > UsrToRfaTmH;
919    for (int e = 0; e < ElecBs.Len(); e++) {
920      UsrToRfaTmH.AddDat(ElecBs.GetUsr(ElecBs[e].GetUId())).Add(TPair<TChA, TSecTm>(ElecBs[e].RfaTitle, ElecBs[e].GetTm()));
921    }
922    TExeTm ExeTm;
923    printf("  Loading %s ", WikiMain.GetFMid().CStr());
924    { TWikiMetaLoader WML(WikiMain);
925    for (int rec=0; WML.Next(); rec++) {
926      TChA U = WML.Usr;
927      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
928      if (! UsrToRfaTmH.IsKey(U)) { continue; }
929      const TVec<TPair<TChA, TSecTm> >& V = UsrToRfaTmH.GetDat(U);
930      for (int t = 0; t < V.Len(); t++) {
931        if (WML.RevTm <= V[t].Val2 ) { 
932          TEditCnt& EC = RfaEdCntH.AddDat(V[t].Val1);
933          EC.MainE+=1; EC.MainW+=WML.RevWrds;
934          WML.CommentStr.ToLc();
935          if (WML.CommentStr.IsPrefix("rv") || WML.CommentStr.SearchStr("revert")!=-1) {
936            EC.RevE+=1; EC.RevW+=WML.RevWrds;
937          }
938        }
939      }
940    } }
941    Save(TZipOut("wikiEditCounts.BeforeElec.rar"));
942    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiMainTalk.GetFMid().CStr());  ExeTm.Tick();
943    { TWikiMetaLoader WML(WikiMainTalk);
944    for (int rec=0; WML.Next(); rec++) {
945      TChA U = WML.Usr;
946      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
947      if (! UsrToRfaTmH.IsKey(U)) { continue; }
948      const TVec<TPair<TChA, TSecTm> >& V = UsrToRfaTmH.GetDat(U);
949      for (int t = 0; t < V.Len(); t++) {
950        if (WML.RevTm <= V[t].Val2 ) {
951          TEditCnt& EC = RfaEdCntH.AddDat(V[t].Val1);
952          EC.MainTE+=1; EC.MainTW+=WML.RevWrds;
953        }
954      }
955    } }
956    Save(TZipOut("wikiEditCounts.BeforeElec.rar"));
957    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWiki.GetFMid().CStr());  ExeTm.Tick();
958    { TWikiMetaLoader WML(WikiWiki);
959    for (int rec=0; WML.Next(); rec++) {
960      TChA U = WML.Usr;
961      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
962      if (! UsrToRfaTmH.IsKey(U)) { continue; }
963      const TVec<TPair<TChA, TSecTm> >& V = UsrToRfaTmH.GetDat(U);
964      for (int t = 0; t < V.Len(); t++) {
965        if (WML.RevTm <= V[t].Val2 ) {
966          TEditCnt& EC = RfaEdCntH.AddDat(V[t].Val1);
967          EC.WikiE+=1; EC.WikiW+=WML.RevWrds;
968        }
969      }
970    } }
971    Save(TZipOut("wikiEditCounts.BeforeElec.rar"));
972    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWikiTalk.GetFMid().CStr());  ExeTm.Tick();
973    { TWikiMetaLoader WML(WikiWikiTalk);
974    for (int rec=0; WML.Next(); rec++) {
975      TChA U = WML.Usr;
976      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
977      if (! UsrToRfaTmH.IsKey(U)) { continue; }
978      const TVec<TPair<TChA, TSecTm> >& V = UsrToRfaTmH.GetDat(U);
979      for (int t = 0; t < V.Len(); t++) {
980        if (WML.RevTm <= V[t].Val2 ) {
981          TEditCnt& EC = RfaEdCntH.AddDat(V[t].Val1);
982          EC.WikiTE+=1; EC.WikiTW+=WML.RevWrds;
983        }
984      }
985    } }
986    Save(TZipOut("wikiEditCounts.BeforeElec.rar"));
987    printf(" [%s]\n", ExeTm.GetStr());
988  }
989  void TWikiEditCnt::LoadTxtAll(const TWikiElecBs& ElecBs) {
990    const TStr WikiMain = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.main.7z";
991    const TStr WikiMainTalk = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.talk.7z";
992    const TStr WikiWiki = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.wikipedia.7z";
993    const TStr WikiWikiTalk = "W:\\Data\\wiki20080103-parseByGuerogy\\enwiki-20080103.wikipedia_talk.7z";
994    const TStr UsrChanges = "W:\\data\\wiki20080103-parseByGuerogy\\enwiki.important-username-changes.2007-08-06";
995    TExeTm ExeTm;
996    printf("  Loading %s ", WikiMain.GetFMid().CStr());
997    { TWikiMetaLoader WML(WikiMain);
998    for (int rec=0; WML.Next(); rec++) {
999      if (! ElecBs.IsUsr(WML.Usr)) { continue; }
1000      TEditCnt& EC = RfaEdCntH.AddDat(WML.Usr);
1001      EC.MainE+=1; EC.MainW+=WML.RevWrds;
1002      WML.CommentStr.ToLc();
1003      if (WML.CommentStr.IsPrefix("rv") || WML.CommentStr.SearchStr("revert")!=-1) {
1004        EC.RevE+=1; EC.RevW+=WML.RevWrds;
1005      }
1006    } }
1007    Save(TZipOut("wikiEditCounts.All.rar"));
1008    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiMainTalk.GetFMid().CStr());  ExeTm.Tick();
1009    { TWikiMetaLoader WML(WikiMainTalk);
1010    for (int rec=0; WML.Next(); rec++) {
1011      if (! ElecBs.IsUsr(WML.Usr)) { continue; }
1012      TEditCnt& EC = RfaEdCntH.AddDat(WML.Usr);
1013      EC.MainTE+=1; EC.MainTW+=WML.RevWrds;
1014    } }
1015    Save(TZipOut("wikiEditCounts.All.rar"));
1016    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWiki.GetFMid().CStr());  ExeTm.Tick();
1017    { TWikiMetaLoader WML(WikiWiki);
1018    for (int rec=0; WML.Next(); rec++) {
1019      TChA U = WML.Usr;
1020      if (! ElecBs.IsUsr(WML.Usr)) { continue; }
1021      TEditCnt& EC = RfaEdCntH.AddDat(WML.Usr);
1022      EC.WikiE+=1; EC.WikiW+=WML.RevWrds;
1023    } }
1024    Save(TZipOut("wikiEditCounts.All.rar"));
1025    printf(" [%s]\n  Loading %s", ExeTm.GetStr(), WikiWikiTalk.GetFMid().CStr());  ExeTm.Tick();
1026    { TWikiMetaLoader WML(WikiWikiTalk);
1027    for (int rec=0; WML.Next(); rec++) {
1028      if (! ElecBs.IsUsr(WML.Usr)) { continue; }
1029      TEditCnt& EC = RfaEdCntH.AddDat(WML.Usr);
1030      EC.WikiTE+=1; EC.WikiTW+=WML.RevWrds;
1031    } }
1032    Save(TZipOut("wikiEditCounts.All.rar"));
1033    printf(" [%s]\n", ExeTm.GetStr());
1034  }
1035  void TWikiEditCnt::SaveTxt(const TWikiElecBs& ElecBs, const TStr& OutFNm) {
1036    FILE *F = fopen(OutFNm.CStr(), "wt");
1037    fprintf(F, "Rfat\tMainE\tMainW\tMainTE\tMainTW\tWikiE\tWikiW\tWikiTE\tWikiTW\n");
1038    for (TSsParser Ss("isSuccVote-TalkNet3.tab", ssfTabSep); Ss.Next(); ) {
1039      TStr Rfa = Ss[1];
1040      if (! RfaEdCntH.IsKey(Rfa)) {
1041        printf("%s\n", Rfa.CStr());
1042        fprintf(F, "%s\t0\t0\t0\t0\t0\t0\t0\t0\n", Rfa.CStr());
1043      } else {
1044        const TEditCnt& EC = RfaEdCntH.GetDat(Rfa);
1045        fprintf(F, "%s\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", Rfa.CStr(),
1046          EC.MainE(), EC.MainW(), EC.MainTE(), EC.MainTW(), EC.WikiE(), EC.WikiW(), EC.WikiTE(), EC.WikiTW());
1047      }
1048    }
1049    fclose(F);
1050  }
1051  TWikiElec::TWikiElec(TSIn& SIn) : RfaTitle(SIn), UsrId(SIn), NomUId(SIn), BurUId(SIn), IsSucc(SIn), ElecTm(SIn), VoteV(SIn) {
1052  }
1053  void TWikiElec::Save(TSOut& SOut) const {
1054    RfaTitle.Save(SOut); UsrId.Save(SOut); NomUId.Save(SOut);
1055    BurUId.Save(SOut); IsSucc.Save(SOut); ElecTm.Save(SOut);
1056    VoteV.Save(SOut);
1057  }
1058  bool TWikiElec::operator < (const TWikiElec& WE) const {
1059    return ElecTm<WE.ElecTm || (ElecTm==WE.ElecTm && UsrId<WE.UsrId);
1060  }
1061  void TWikiElec::SetIsVoteFlag() {
1062    THash<TInt, TIntPr> UsrVoteH(Len());
1063    for (int i = 0; i < VoteV.Len(); i++) {
1064      if (VoteV[i].GetIndent() != 0) { continue; } 
1065      if (VoteV[i].GetUId() == UsrId) { continue; }  
1066      if (! UsrVoteH.IsKey(VoteV[i].GetUId())) {
1067        UsrVoteH.AddDat(VoteV[i].GetUId(), TIntPr(VoteV[i].GetTm().GetAbsSecs(), i));
1068      } else {
1069        TIntPr& Dat = UsrVoteH.GetDat(VoteV[i].GetUId());
1070        if (Dat.Val1 > (int)VoteV[i].GetTm().GetAbsSecs()) { 
1071          Dat = TIntPr(VoteV[i].GetTm().GetAbsSecs(), i);
1072        }
1073      }
1074    }
1075    for (int v = 0; v < VoteV.Len(); v++) {
1076      VoteV[v].IsAVote = false;
1077    }
1078    for (int v = 0; v < UsrVoteH.Len(); v++) {
1079      VoteV[UsrVoteH[v].Val2].IsAVote = true;
1080    }
1081  }
1082  double TWikiElec::GetFracSup(const bool& OnlyVotes) const {
1083    const TIntTr Votes = GetVotes(OnlyVotes);
1084    return double(Votes.Val1)/double(Votes.Val1+Votes.Val3);
1085  }
1086  double TWikiElec::GetFracSup(int VoteId1, int VoteId2) const {
1087    double Sup=0;
1088    for (int v = VoteId1; v < TMath::Mn(VoteId2, Len()); v++) {
1089      if (VoteV[v].GetVote()==1) { Sup+=1; }
1090    }
1091    if (VoteId1==VoteId2) { return 0.0; }
1092    return Sup/double(VoteId2-VoteId1);
1093  }
1094  double TWikiElec::GetTrend(int VoteId1, int VoteId2) const {
1095    TFltPrV XY;
1096    for (int v = VoteId1; v < VoteId2; v++) {
1097      XY.Add(TFltPr(v, (double)VoteV[v].GetVote()));
1098    }
1099    double A, B, SigA, SigB, Chi2, R2;
1100    TSpecFunc::LinearFit(XY, A, B, SigA, SigB, Chi2, R2);
1101    return B;
1102  }
1103  TIntTr TWikiElec::GetVotes(const bool& OnlyVotes) const {
1104    int Sup=0, Opp=0, Neu=0;
1105    for (int i = 0; i < VoteV.Len(); i++) {
1106      if (OnlyVotes && ! VoteV[i].IsVote()) { continue; }
1107      if (VoteV[i].GetVote()==1) { Sup++; }
1108      else if (VoteV[i].GetVote()==0) { Neu++; }
1109      else if (VoteV[i].GetVote()==-1) { Opp++; }
1110    }
1111    return TIntTr(Sup, Neu, Opp);
1112  }
1113  void TWikiElec::GetVotesOt(TWikiVoteV& WVoteV, const bool& OnlyVotes) const {
1114    if (! OnlyVotes) {
1115      WVoteV = VoteV;
1116      WVoteV.Sort();
1117      return;
1118    }
1119    TIntPrV TmIdV;
1120    for (int i = 0; i < VoteV.Len(); i++) {
1121      if (OnlyVotes && ! VoteV[i].IsVote()) { continue; }
1122      TmIdV.Add(TIntPr(VoteV[i].VoteTm.GetAbsSecs(), i));
1123    }
1124    TmIdV.Sort();
1125    WVoteV.Clr(false);
1126    for (int v = 0; v < TmIdV.Len(); v++) {
1127      WVoteV.Add(VoteV[TmIdV[v].Val2]);
1128    }
1129    WVoteV.Sort();
1130  }
1131  int TWikiElec::GetAvgVoteOt(TFltV& AvgVoteV, const bool& OnlyVotes) const {
1132    TWikiVoteV WVoteV;  GetVotesOt(WVoteV, OnlyVotes);
1133    double VoteSum = 0;
1134    AvgVoteV.Clr(false);
1135    for (int i = 0; i < WVoteV.Len(); i++) {
1136      VoteSum += WVoteV[i].GetVote() > 0 ? 1 : 0;
1137      AvgVoteV.Add(VoteSum/double(i+1));
1138    }
1139    return AvgVoteV.Len();
1140  }
1141  int TWikiElec::GetAvgVoteDevOt(TFltV& AvgVoteV, const bool& OnlyVotes) const {
1142    TWikiVoteV WVoteV;  GetVotesOt(WVoteV, OnlyVotes);
1143    double XBar = WVoteV[0].GetVote() > 0 ? 1 : 0;
1144    AvgVoteV.Clr(false);
1145    for (int i = 1; i < WVoteV.Len(); i++) {
1146      const double CurVote = WVoteV[i].GetVote() > 0 ? 1 : 0;
1147      AvgVoteV.Add(fabs(CurVote-XBar)/double(i+1));
1148      XBar = (i*XBar+CurVote)/double(i+1);
1149    }
1150    return AvgVoteV.Len();
1151  }
1152  int TWikiElec::GetRunLen(const int& VoteId) const {
1153    const int V = VoteV[VoteId].GetVote();
1154    int runL=0;
1155    for (int v = VoteId+1; v < Len(); v++) {
1156      if (VoteV[v].GetVote() == V) { runL++; }
1157      else { return runL; }
1158    }
1159    return runL;
1160  }
1161  void TWikiElec::PermuteVotes() {
1162    TIntV ValV(VoteV.Len(), 0);
1163    for (int i = 0; i < VoteV.Len(); i++) {
1164      ValV.Add(VoteV[i].UsrVote); }
1165    ValV.Shuffle(TInt::Rnd);
1166    for (int i = 0; i < ValV.Len(); i++) {
1167      VoteV[i].UsrVote=ValV[i]; }
1168  }
1169  void TWikiElec::KeepVotes(const TIntSet& UIdSet) {
1170    TWikiVoteV NewVoteV;
1171    for (int v = 0; v < VoteV.Len(); v++) {
1172      if (UIdSet.IsKey(VoteV[v].GetUId())) {
1173        NewVoteV.Add(VoteV[v]);
1174      }
1175    }
1176    VoteV=NewVoteV;
1177  }
1178  void TWikiElec::GetOnlyVotes(TWikiElec& NewElec, const bool& OnlySupOpp) const {
1179    NewElec.RfaTitle = RfaTitle;
1180    NewElec.UsrId = UsrId;
1181    NewElec.NomUId = NomUId;
1182    NewElec.BurUId = BurUId;
1183    NewElec.IsSucc = IsSucc;
1184    NewElec.ElecTm = ElecTm;
1185    NewElec.VoteV.Clr(false);
1186    for (int i = 0; i < VoteV.Len(); i++) {
1187      if (! VoteV[i].IsVote()) { continue; }
1188      if (OnlySupOpp && VoteV[i].GetVote()==0) { continue; }
1189      NewElec.VoteV.Add(VoteV[i]);
1190    }
1191  }
1192  void TWikiElec::RemoveSelfVotes() {
1193    TWikiVoteV VoteV2(Len(), 0);
1194    for (int v = 0; v < VoteV.Len(); v++) {
1195      if (VoteV[v].GetIndent()==0 && VoteV[v].GetUId()==UsrId) { continue; } 
1196      VoteV2.Add(VoteV[v]);
1197    }
1198    VoteV.Swap(VoteV2);
1199  }
1200  void TWikiElec::Dump(const TStrHash<TInt>& UsrH) const {
1201    TIntTr V = GetVotes(true);
1202    if (UsrH.IsKeyId(UsrId)) {
1203      printf("\nELEC %s : %s %d vote at %s votes %d\n", RfaTitle.CStr(), UsrH.GetKey(UsrId), UsrId, ElecTm.GetYmdTmStr().CStr(), VoteV.Len()); }
1204    else {
1205       printf("\nELEC %s : %d  %d vote at %s votes %d\n", RfaTitle.CStr(), UsrId, ElecTm.GetYmdTmStr().CStr(), VoteV.Len()); }
1206    printf("    %d / %d / %d  =  %f\n", V.Val1, V.Val2, V.Val3, V.Val1/double(V.Val1+V.Val3));
1207    for (int v = 0; v < VoteV.Len(); v++) {
1208      if (UsrH.IsKeyId(VoteV[v].UsrId)) {
1209        printf("  %2d  %2d %s: %s (%d)  %s  t:%d  i: %d\n", v+1, VoteV[v].UsrVote, VoteV[v].IsVote()?"V":" ", UsrH.GetKey(VoteV[v].UsrId), VoteV[v].UsrId, VoteV[v].VoteTm.GetYmdTmStr().CStr(), VoteV[v].TxtLen, VoteV[v].UsrIndent);
1210      } else {
1211        printf("  %2d  %2d %s: %d  %s  t:%d  i: %d\n", v+1, VoteV[v].UsrVote, VoteV[v].IsVote()?"V":" ", VoteV[v].UsrId, VoteV[v].VoteTm.GetYmdTmStr().CStr(), VoteV[v].TxtLen, VoteV[v].UsrIndent);
1212      }
1213    }
1214  }
1215  void TWikiElecBs::GetEIdByVotes(TIntV& EIdV, const bool& AscNumVotes) const {
1216    TIntPrV V(Len(), 0);
1217    for (int u = 0; u < Len(); u++) {
1218      const TWikiElec& E = GetElec(u);
1219      V.Add(TIntPr(E.Len(), E.UsrId));
1220    }
1221    V.Sort(AscNumVotes);
1222    EIdV.Clr(false);
1223    for (int u = 0; u < V.Len(); u++) {
1224      EIdV.Add(V[u].Val2); }
1225  }
1226  void TWikiElecBs::GetEIdByVotes(TIntV& EIdV, const int& MinLen, const double& FracPos, const double AboveFrac, const bool& AscNumVotes) const {
1227    TFltIntPrV V(Len(), 0);
1228    for (int u = 0; u < Len(); u++) {
1229      const TWikiElec& E = GetElec(u);
1230      if (E.Len() < MinLen) { continue; }
1231      if ((AboveFrac && E.GetFracSup() > FracPos) || (!AboveFrac && E.GetFracSup() < FracPos)) {
1232        V.Add(TFltIntPr(E.Len(), E.UsrId)); }
1233    }
1234    V.Sort(AscNumVotes);
1235    EIdV.Clr(false);
1236    for (int u = 0; u < V.Len(); u++) {
1237      EIdV.Add(V[u].Val2); }
1238  }
1239  void TWikiElecBs::GetEIdByFrac(TIntV& EIdV, const int& MinLen, const double& MnFracSup, const double& MxFracSup) const {
1240    TFltIntPrV V(Len(), 0);
1241    for (int u = 0; u < Len(); u++) {
1242      const TWikiElec& E = GetElec(u);
1243      if (E.Len() < MinLen) { continue; }
1244      const double FracSup = E.GetFracSup();
1245      if (FracSup==1) { continue; }
1246      if (FracSup >= MnFracSup && FracSup <= MxFracSup) {
1247        V.Add(TFltIntPr(FracSup, E.UsrId)); }
1248    }
1249    V.Sort(true);
1250    EIdV.Clr(false);
1251    for (int u = 0; u < V.Len(); u++) {
1252      EIdV.Add(V[u].Val2); }
1253  }
1254  void TWikiElecBs::GetUsrV(TIntV& UIdV) const {
1255    TIntSet UIdSet;
1256    for (int e = 0; e < Len(); e++) {
1257      const TWikiElec& E = GetElec(e);
1258      UIdSet.AddKey(E.GetUId());
1259      for (int v = 0; v < E.Len(); v++) {
1260        UIdSet.AddKey(E.GetVote(v).GetUId());
1261      }
1262    }
1263    UIdSet.GetKeyV(UIdV);
1264  }
1265  void TWikiElecBs::GetElecUsrV(TIntV& ElecUsrV) const {
1266    ElecUsrV.Clr(false);
1267    for (int e = 0; e < Len(); e++) {
1268      const TWikiElec& E = GetElec(e);
1269      ElecUsrV.Add(E.UsrId);
1270    }
1271  }
1272  void TWikiElecBs::GetElecAdminUsrV(TIntV& ElecAdminUsrV) const {
1273    ElecAdminUsrV.Clr(false);
1274    for (int e = 0; e < Len(); e++) {
1275      const TWikiElec& E = GetElec(e);
1276      if (E.IsSucc) {
1277        ElecAdminUsrV.Add(E.UsrId);
1278      }
1279    }
1280  }
1281  void TWikiElecBs::GetElecNonAdminUsrV(TIntV& ElecNonAdminUsrV) const {
1282    ElecNonAdminUsrV.Clr(false);
1283    for (int e = 0; e < Len(); e++) {
1284      const TWikiElec& E = GetElec(e);
1285      if (! E.IsSucc) {
1286        ElecNonAdminUsrV.Add(E.UsrId);
1287      }
1288    }
1289  }
1290  void TWikiElecBs::GetFqVoters(TIntSet& FqVoterSet, const int& MinVotes, const int& MinElecLen, const bool& OnlyAdmins) const {
1291    TIntH UsrCntH, CntH;
1292    printf("%d\n", Len());
1293    TIntSet AdminSet;
1294    if (OnlyAdmins) {
1295      GetAdminSet(AdminSet);
1296    }
1297    for (int e = 0; e < Len(); e++) {
1298      const TWikiElec& E = GetElec(e);
1299      if (E.Len() < MinElecLen) { continue; }
1300      for (int v = 0; v < E.Len(); v++) {
1301        if (OnlyAdmins && ! AdminSet.IsKey(E[v].GetUId())) {
1302          continue; } 
1303        UsrCntH.AddDat(E[v].GetUId()) += 1;
1304      }
1305    }
1306    for (int i = 0; i < UsrCntH.Len(); i++) {
1307      CntH.AddDat(UsrCntH[i]) += 1; }
1308    FqVoterSet.Clr(false);
1309    UsrCntH.SortByDat(false);
1310    for (int i = 0; i < UsrCntH.Len(); i++) {
1311      if (UsrCntH[i] >= MinVotes) {
1312        FqVoterSet.AddKey(UsrCntH.GetKey(i));
1313      }
1314    }
1315  }
1316  void TWikiElecBs::GetUsrVotes(TIntPrV& VoteUIdV) const {
1317    TIntH UsrCntH;
1318    for (int e = 0; e < Len(); e++) {
1319      const TWikiElec& E = GetElec(e);
1320      for (int v = 0; v < E.Len(); v++) {
1321        UsrCntH.AddDat(E[v].GetUId()) += 1;
1322      }
1323    }
1324    VoteUIdV.Clr();
1325    for (int i = 0; i < UsrCntH.Len(); i++) {
1326      VoteUIdV.Add(TIntPr(UsrCntH[i], UsrCntH.GetKey(i)));
1327    }
1328    VoteUIdV.Sort(false);
1329  }
1330  void TWikiElecBs::GetAdminSet(TIntSet& AdminSet) const {
1331    AdminSet.Clr(false);
1332    for (int e = 0; e < Len(); e++) {
1333      const TWikiElec& E = GetElec(e);
1334      if (E.IsSucc) {
1335        AdminSet.AddKey(E.UsrId);
1336      }
1337    }
1338    printf("  %d admins from elecs. ", AdminSet.Len());
1339    if (TFile::Exists("../../admin-list.txt")) {
1340      for (TSsParser Ss("../../admin-list.txt", ssfTabSep); Ss.Next(); ) {
1341        TStr U = Ss[0];
1342        if (IsUsr(U)) { AdminSet.AddKey(GetUId(U)); }
1343        if(IsUsr(U.GetLc())) { AdminSet.AddKey(GetUId(U.GetLc())); }
1344      }
1345    }
1346    printf("  %d admins after admin-list.txt\n", AdminSet.Len());
1347  }
1348  void TWikiElecBs::GetFqVoterSet(TIntSet& FqVoterSet) const {
1349    TIntPrV VoteUIdV;
1350    GetUsrVotes(VoteUIdV);
1351    int HalfVotes = GetVotes()/2, SoFar=0;
1352    FqVoterSet.Clr(false);
1353    for (int i = 0; i < VoteUIdV.Len() && SoFar < HalfVotes; i++) {
1354      FqVoterSet.AddKey(VoteUIdV[i].Val2);
1355      SoFar+=VoteUIdV[i].Val1;
1356    }
1357    printf("Users:%d (%d votes) FqVoters:%d (%d votes)\n", VoteUIdV.Len(), HalfVotes*2, FqVoterSet.Len(), SoFar);
1358  }
1359  void TWikiElecBs::GetAdminTmSet(THash<TInt, TSecTm>& AdminSet) const {
1360    AdminSet.Clr(false);
1361    for (int e = 0; e < Len(); e++) {
1362      const TWikiElec& E = GetElec(e);
1363      if (E.IsSucc) {
1364        AdminSet.AddDat(E.UsrId, E.GetTm());
1365      }
1366    }
1367  }
1368  void TWikiElecBs::KeepFqVoters(const int& MinVotes, const int& MinElecLen, const bool& OnlyAdmins) {
1369    TIntSet Voters;
1370    GetFqVoters(Voters, MinVotes, MinElecLen, OnlyAdmins);
1371    printf("freq  voters %d\n", Voters.Len());
1372    int VotesB=0, VotesA=0;
1373    for (int e = 0; e < Len(); e++) {
1374      TWikiElec& E = GetElec(e);
1375      VotesB += E.Len();
1376      if (E.Len() < MinElecLen) { E.VoteV.Clr(); }
1377      E.KeepVotes(Voters);
1378      VotesA += E.Len();
1379    }
1380    printf("Votes: %d --> %d\n", VotesB, VotesA);
1381  }
1382  void TWikiElecBs::KeepVoters(const bool& KeepAdmins, const bool& KeepNonAdmins) {
1383    TIntSet KeepVoters, Admins;
1384    GetAdminSet(Admins);
1385    if (KeepAdmins) {
1386      KeepVoters = Admins; }
1387    if (KeepNonAdmins) {
1388      TIntV UIdV; GetUsrV(UIdV);
1389      for (int i = 0; i < UIdV.Len(); i++) {
1390        if (! Admins.IsKey(UIdV[i])) {
1391          KeepVoters.AddKey(UIdV[i]); } }
1392    }
1393    int VotesB=0, VotesA=0;
1394    printf("voters %d\n", KeepVoters.Len());
1395    for (int e = 0; e < Len(); e++) {
1396      TWikiElec& E = GetElec(e);
1397      VotesB += E.Len();
1398      E.KeepVotes(KeepVoters);
1399      VotesA += E.Len();
1400    }
1401    printf("  votes: %d --> %d\n", VotesB, VotesA);
1402  }
1403  void TWikiElecBs::KeepTopVoters(const int& Votes, const bool& KeepTop) {
1404  }
1405  void TWikiElecBs::PermuteVotes() {
1406    printf("Permute election entries...");
1407    for (int u = 0; u < Len(); u++) {
1408      GetElec(u).PermuteVotes();
1409    }
1410    printf("done.\n");
1411  }
1412  void TWikiElecBs::SortVotesByTm() {
1413    for (int e = 0; e < Len(); e++) {
1414      GetElec(e).VoteV.Sort();
1415    }
1416  }
1417  int TWikiElecBs::GetVoteTrails(const int& MinUsrVotes, const bool& No01Prob, TIntV& UIdV, TVec<TFltPrV>& ProbSupTmV,
1418                                  TVec<TFltPrV>& FracSupTmV, TVec<TFltPrV>& ProbSupFracSupV, TVec<TFltPrV>& VotesTmV) const {
1419    UIdV.Clr();  ProbSupTmV.Clr();  FracSupTmV.Clr();
1420    ProbSupFracSupV.Clr();  VotesTmV.Clr();
1421    THash<TInt, TIntPrV> UIdVotesH;
1422    TIntFltH FracSupH;
1423    for (int e = 0; e < Len(); e++) {
1424      const TWikiElec& E = GetElec(e);
1425      if (E.Len() < 10) { continue; } 
1426      for (int v = 0; v < E.Len(); v++) {
1427        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1428      }
1429      FracSupH.AddDat(e, E.GetFracSup());
1430    }
1431    int Votes = 0;
1432    UIdVotesH.SortByDat(false);
1433    TIntH AllCntH, AllCntHS, AllCntHF;
1434    for (int u = 0; u < UIdVotesH.Len(); u++) {
1435      THash<TInt, TMom> TProbH, TFracH, UFPH;
1436      THash<TFlt, TFlt> TVotesH;
1437      TIntPrV& EV = UIdVotesH[u];
1438      EV.Sort();
1439      const int UId = UIdVotesH.GetKey(u);
1440      if (EV.Len() < MinUsrVotes) { continue; }
1441      EV.Del(EV.Len()/2, EV.Len()-1);
1442      for (int ev = 0; ev < EV.Len(); ev++) { 
1443        const TWikiElec& E = GetElec(EV[ev].Val1);
1444        const int v = EV[ev].Val2;
1445        if (v < 10) { continue; } 
1446        const int Vote = E[v].GetVote()==1 ? 1:0;
1447        const double Frac = E.GetFracSup(0, v); 
1448        if (v < 110) { 
1449          TProbH.AddDat(10*(v/10)).Add(Vote);
1450          TFracH.AddDat(10*(v/10)).Add(Frac);
1451          TVotesH.AddDat(10*(v/10)) += 1;
1452        }
1453        UFPH.AddDat(10*(int)TMath::Round(10*Frac)).Add(Vote);
1454        Votes++;
1455      }
1456      double M;
1457      TFltPrV TPV, TFV, TFPV, TVV;
1458      for (int i = 0; i < TProbH.Len(); i++) {
1459        TProbH[i].Def();   M = TProbH[i].GetMean();
1460        if (No01Prob && M!=0 && M!=1) { TPV.Add(TFltPr(TProbH.GetKey(i).Val, M)); }
1461        else if (! No01Prob) { TPV.Add(TFltPr(TProbH.GetKey(i).Val, M)); }
1462      }
1463      for (int i = 0; i < TFracH.Len(); i++) {
1464        TFracH[i].Def();   M = TFracH[i].GetMean();
1465        if (No01Prob && M!=0 && M!=1) { TFV.Add(TFltPr(TFracH.GetKey(i).Val, M)); }
1466        else if (! No01Prob) { TFV.Add(TFltPr(TFracH.GetKey(i).Val, M)); }
1467      }
1468      for (int i = 0; i < UFPH.Len(); i++) {
1469        UFPH[i].Def();   M = UFPH[i].GetMean();
1470        if (No01Prob && M!=0 && M!=1) { TFPV.Add(TFltPr(UFPH.GetKey(i).Val, M)); }
1471        else if (! No01Prob) { TFPV.Add(TFltPr(UFPH.GetKey(i).Val, M)); }
1472      }
1473      TVotesH.GetKeyDatPrV(TVV);  TVV.Sort();
1474      TFPV.Sort(); TPV.Sort(); TFV.Sort();
1475      if (TFPV[0].Val1!=0.0) { TFPV.Ins(0, TFltPr(0,0)); printf("Z");} 
1476      if (TFPV.Last().Val1!=100.0) { TFPV.Add(TFltPr(100,1)); printf("O");} 
1477      UIdV.Add(UId);
1478      ProbSupTmV.Add(TPV);
1479      FracSupTmV.Add(TFV);
1480      ProbSupFracSupV.Add(TFPV);
1481      VotesTmV.Add(TVV);
1482    }
1483    IAssert(UIdV.Len() == ProbSupTmV.Len());
1484    return Votes;
1485  }
1486  void TWikiElecBs::GetVoteTrails2(const int& MinUsrVotes, const bool& No01Prob, TIntV& UIdV, TVec<TFltPrV>& VoteIdxFracSupV, TVec<TFltPrV>& NVotesFracSupV) const {
1487    UIdV.Clr();  VoteIdxFracSupV.Clr();  NVotesFracSupV.Clr();
1488    THash<TInt, TIntPrV> UIdVotesH;
1489    TIntFltH FracSupH;
1490    for (int e = 0; e < Len(); e++) {
1491      const TWikiElec& E = GetElec(e);
1492      if (E.Len() < 10) { continue; } 
1493      for (int v = 0; v < E.Len(); v++) {
1494        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1495      }
1496      FracSupH.AddDat(e, E.GetFracSup());
1497    }
1498    UIdVotesH.SortByDat(false);
1499    TIntH AllCntH, AllCntHS, AllCntHF;
1500    for (int u = 0; u < UIdVotesH.Len(); u++) {
1501      THash<TInt, TMom> FSVIdxH;
1502      TFltFltH FSVotesH;
1503      const TIntPrV& EV = UIdVotesH[u];
1504      const int UId = UIdVotesH.GetKey(u);
1505      if (EV.Len() < MinUsrVotes) { continue; }
1506      for (int ev = 0; ev < EV.Len(); ev++) { 
1507        const TWikiElec& E = GetElec(EV[ev].Val1);
1508        const int v = EV[ev].Val2;
1509        const int Vote = E[v].GetVote()==1 ? 1:0;
1510        const double Frac = E.GetFracSup(0, v); 
1511        FSVotesH.AddDat(10*int(10*Frac)) += 1;
1512        FSVIdxH.AddDat(10*int(10*Frac)).Add(v);
1513      }
1514      UIdV.Add(UId);
1515      double M = 0;
1516      VoteIdxFracSupV.Add();
1517      TFltPrV& VoteIdxV = VoteIdxFracSupV.Last();
1518      for (int i = 0; i < FSVIdxH.Len(); i++) {
1519        FSVIdxH[i].Def();   M = FSVIdxH[i].GetMean();
1520        if (No01Prob && M!=0 && M!=1) { VoteIdxV.Add(TFltPr(FSVIdxH.GetKey(i).Val, M)); }
1521        else if (! No01Prob) { VoteIdxV.Add(TFltPr(FSVIdxH.GetKey(i).Val, M)); }
1522      }
1523      VoteIdxV.Sort();
1524      NVotesFracSupV.Add();
1525      FSVotesH.GetKeyDatPrV(NVotesFracSupV.Last());
1526      NVotesFracSupV.Last().Sort();
1527    }
1528  }
1529  void TWikiElecBs::GetUsrVoteTrail(const TIntV& UIdV, TVec<TFltPrV>& ProbPosFracPosV) const {
1530    ProbPosFracPosV.Clr();
1531    THash<TInt, TIntPrV> UIdVotesH;
1532    for (int e = 0; e < Len(); e++) {
1533      const TWikiElec& E = GetElec(e);
1534      if (E.Len() < 10) { continue; } 
1535      for (int v = 0; v < E.Len(); v++) {
1536        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1537      }
1538    }
1539    for (int u = 0; u < UIdV.Len(); u++) {
1540      ProbPosFracPosV.Add();
1541      if (! UIdVotesH.IsKey(UIdV[u])) { continue; }
1542      const TIntPrV& EV = UIdVotesH.GetDat(UIdV[u]);
1543      THash<TInt, TMom> FracProbH;
1544      for (int ev = 0; ev < EV.Len(); ev++) { 
1545        const TWikiElec& E = GetElec(EV[ev].Val1);
1546        const int v = EV[ev].Val2;
1547        const int Vote = E[v].GetVote()==1 ? 1:0;
1548        const double Frac = E.GetFracSup(0, v); 
1549        FracProbH.AddDat(10*int(10*Frac)).Add(Vote);
1550      }
1551      FracProbH.SortByKey();
1552      TFltPrV& ProbFracV = ProbPosFracPosV.Last();
1553      for (int i = 0; i < FracProbH.Len(); i++) {
1554        FracProbH[i].Def();
1555        const double M = FracProbH[i].GetMean();
1556        ProbFracV.Add(TFltPr(FracProbH.GetKey(i).Val, M));
1557      }
1558      ProbFracV.Sort();
1559    }
1560  }
1561  void TWikiElecBs::GetUsrAreaUTrail(const TIntV& UIdV, TFltV& AreaV) const {
1562    TVec<TFltPrV> ProbPosFracPosV;
1563    GetUsrVoteTrail(UIdV, ProbPosFracPosV);
1564    AreaV.Clr();
1565    for (int u = 0; u < ProbPosFracPosV.Len(); u++) {
1566      double Area = 0;
1567      TFltPrV& V = ProbPosFracPosV[u];
1568      for (int f = 0; f < V.Len(); f++) {
1569        IAssert(V[f].Val1>= 0 && V[f].Val1<=100);
1570        Area += (V[f].Val2 - V[f].Val1/100.0);
1571      }
1572      AreaV.Add(Area);
1573    }
1574  }
1575  void TWikiElecBs::PlotElecLenDistr(const TStr& OutFNm) const {
1576    TIntH SupCntHS, OppCntHS, VotesCntHS, 
1577          SupCntHF, OppCntHF, VotesCntHF, 
1578          SupCntHA, OppCntHA, VotesCntHA; 
1579    TIntH VotesPerUser;
1580    THashSet<TFltPr> SupOppHS, SupOppHF;
1581    THash<TInt, TMom> ElLenVsSucc;
1582    TIntH SupFracA, SupFracS, SupFracF;
1583    for (int e = 0; e < Len(); e++) {
1584      const TWikiElec& E = GetElec(e);
1585      const int SupFrac = (int)TMath::Round(E.GetFracSup()*10)*10;
1586      TIntTr V = E.GetVotes();
1587      int len = (E.Len()/5)*5;
1588      V.Val1 = (V.Val1/5)*5;
1589      V.Val2 = (V.Val2/5)*5;
1590      V.Val3 = (V.Val3/5)*5;
1591      SupFracA.AddDat(SupFrac) +=1;
1592      if (E.IsSucc) {
1593        SupFracS.AddDat(SupFrac) += 1;
1594        VotesCntHS.AddDat(len) += 1;
1595        SupCntHS.AddDat(V.Val1) += 1;
1596        OppCntHS.AddDat(V.Val3) += 1;
1597        SupOppHS.AddKey(TFltPr(V.Val1+0.1+TInt::Rnd.GetNrmDev(), V.Val3+0.1+TInt::Rnd.GetNrmDev()));
1598        ElLenVsSucc.AddDat(len).Add(1);
1599      } else {
1600        SupFracF.AddDat(SupFrac) += 1;
1601        VotesCntHF.AddDat(len) += 1;
1602        SupCntHF.AddDat(V.Val1) += 1;
1603        OppCntHF.AddDat(V.Val3) += 1;
1604        SupOppHF.AddKey(TFltPr(V.Val1+0.1+TInt::Rnd.GetNrmDev(), V.Val3+0.1+TInt::Rnd.GetNrmDev()));
1605        ElLenVsSucc.AddDat(len).Add(0);
1606      }
1607      VotesCntHA.AddDat(len) += 1;
1608      SupCntHA.AddDat(V.Val1) += 1;
1609      OppCntHA.AddDat(V.Val3) += 1;
1610    }
1611    TIntPrV VotesUIdV; GetUsrVotes(VotesUIdV);
1612    for (int i = 0; i < VotesUIdV.Len(); i++) {
1613      VotesPerUser.AddDat(10*(VotesUIdV[i].Val1/10))+=1;
1614    }
1615    TGnuPlot::PlotValCntH(VotesPerUser, "userVotes-"+OutFNm, "", "Number of votes", "Number of such users");
1616    TGnuPlot::PlotValMomH(ElLenVsSucc, "elLenSucc-"+OutFNm, "", "Election length", "Probability of success");
1617    { TGnuPlot GP("suppOppScatter-"+OutFNm); GP.SetXYLabel("Support votes", "Oppose votes");
1618    TFltPrV SuccV, FailV;  SupOppHS.GetKeyV(SuccV);  SupOppHF.GetKeyV(FailV);
1619    GP.AddPlot(FailV, gpwPoints, "FAIL");  GP.AddPlot(SuccV, gpwPoints, "SUCC");
1620    GP.SavePng(); }
1621    { TGnuPlot GP("countSup-"+OutFNm); GP.SetXYLabel("Support votes", "Count");
1622    GP.AddPlot(SupCntHA, gpwLinesPoints, "ALL elections");
1623    GP.AddPlot(SupCntHS, gpwLinesPoints, "SUCC elections");
1624    GP.AddPlot(SupCntHF, gpwLinesPoints, "FAIL elections");
1625    GP.SavePng(); }
1626    { TGnuPlot GP("countOpp-"+OutFNm); GP.SetXYLabel("Oppose votes", "Count");
1627    GP.AddPlot(OppCntHA, gpwLinesPoints, "ALL elections");
1628    GP.AddPlot(OppCntHS, gpwLinesPoints, "SUCC elections");
1629    GP.AddPlot(OppCntHF, gpwLinesPoints, "FAIL elections");
1630    GP.SavePng(); }
1631    { TGnuPlot GP("countVot-"+OutFNm); GP.SetXYLabel("Votes", "Count");
1632    GP.AddPlot(VotesCntHA, gpwLinesPoints, "ALL elections");
1633    GP.AddPlot(VotesCntHS, gpwLinesPoints, "SUCC elections");
1634    GP.AddPlot(VotesCntHF, gpwLinesPoints, "FAIL elections");
1635    GP.SavePng(); }
1636    { TGnuPlot GP("supFrac-"+OutFNm); GP.SetXYLabel("Final Fraction of support votes", "Number of such elections");
1637    GP.AddPlot(SupFracA, gpwLinesPoints, "ALL elections");
1638    GP.AddPlot(SupFracS, gpwLinesPoints, "SUCC elections");
1639    GP.AddPlot(SupFracF, gpwLinesPoints, "FAIL elections");
1640    GP.SavePng(); }
1641  }
1642  void TWikiElecBs::PlotElecSupOppOt(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
1643    int ElecCnt=0;
1644    TGnuPlot GP("supOppOT-"+OutFNm);
1645    for (int e = 0; e < Len(); e++) {
1646      const TWikiElec& E = GetElec(e);
1647      if (E.Len() < MinVotes || E.Len() > MaxVotes) { continue; }
1648      TFltPrV OppSupV; OppSupV.Add(TFltPr(0,0));
1649      for (int v = 0; v < E.Len(); v++) {
1650        const int S = E[v].GetVote();
1651        OppSupV.Add(TFltPr(OppSupV.Last().Val1+(S<0?1:0)+0.1*TInt::Rnd.GetNrmDev(),
1652                           OppSupV.Last().Val2+(S>0?1:0)+0.1*TInt::Rnd.GetNrmDev()));
1653      }
1654      GP.AddPlot(OppSupV, gpwLines, "", TStr::Fmt("lt %d", E.IsSucc?2:1));
1655      ElecCnt++;
1656    }
1657    GP.SetXYLabel("oppose votes", "support votes");
1658    GP.SetTitle(TStr::Fmt("elections with %d -- %d votes: %d elections", MinVotes, MaxVotes, ElecCnt));
1659    GP.SavePng();
1660  }
1661  void TWikiElecBs::PlotRunLenStat(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
1662    THash<TInt, TTriple<TMom, TMom, TMom> > UsrMomH;
1663    THash<TInt, TMom> TxtLenH;
1664    TPair<TMom, TMom> RunLStat;
1665    THash<TInt, TInt> SupH, OppH;
1666    int Cnt=0;
1667    for (int e = 0; e < Len(); e++) {
1668      const TWikiElec& E = GetElec(e);
1669      if (E.Len() < MinVotes || E.Len() > MaxVotes) { continue; }
1670      for (int v = 0; v < E.Len(); v++) {
1671        const int V = E.GetVote(v).GetVote();
1672        const int RunL = E.GetRunLen(v);
1673        if (V == 1) {
1674          UsrMomH.AddDat(E.GetVote(v).GetUId()).Val1.Add(RunL);
1675          RunLStat.Val1.Add(RunL);
1676          SupH.AddDat(RunL)++;
1677        } else {
1678          UsrMomH.AddDat(E.GetVote(v).GetUId()).Val2.Add(RunL);
1679          RunLStat.Val2.Add(RunL);
1680          OppH.AddDat(RunL)++;
1681        }
1682        UsrMomH.AddDat(E.GetVote(v).GetUId()).Val3.Add(E[v].GetTxtLen());
1683        TxtLenH.AddDat(10*(E[v].GetTxtLen()/10)).Add(RunL);
1684      }
1685      Cnt++;
1686    }
1687    TGnuPlot::PlotValMomH(TxtLenH, "runLenTxtLen-"+OutFNm, "", "Length of the text supporting the vote", "Run length",
1688      gpsAuto, gpwLinesPoints, true, true, false, false, false);
1689    RunLStat.Val1.Def();
1690    RunLStat.Val2.Def();
1691    printf("SUP run len: A:%g  M:%g\n", RunLStat.Val1.GetMean(), RunLStat.Val1.GetMedian());
1692    printf("OPP run len: A:%g  M:%g\n", RunLStat.Val2.GetMean(), RunLStat.Val2.GetMedian());
1693    TGnuPlot GP("runLen-"+OutFNm, TStr::Fmt("Elecs %d--%d: %d. SUP run len: A:%g  M:%g  OPP: A:%g  M:%g", MinVotes, MaxVotes, Cnt,
1694      RunLStat.Val1.GetMean(), RunLStat.Val1.GetMedian(), RunLStat.Val2.GetMean(), RunLStat.Val2.GetMedian()));
1695    GP.AddPlot(OppH, gpwLinesPoints, "OPP");
1696    GP.AddPlot(SupH, gpwLinesPoints, "SUP");
1697    GP.SetXYLabel("run length", "count");
1698    GP.SavePng();
1699    FILE *F = fopen(TStr::Fmt("runLenUsers-%s.tab", OutFNm.CStr()).CStr(), "wt");
1700    fprintf(F, "#UsrId\tUser\tVotes\tSup-Votes\tOpp-Votes\tSup-Avg\tSup-Med\tOpp-Avg\tOpp-Med\tTxtLen-Avg\tTxtLen-Med\n");
1701    for (int u = 0; u < UsrMomH.Len(); u++) {
1702      TMom& MS = UsrMomH[u].Val1;  MS.Def();
1703      TMom& MO = UsrMomH[u].Val2;  MO.Def();
1704      TMom& TL = UsrMomH[u].Val3;  TL.Def();
1705      fprintf(F, "%d\t%s\t%d\t%d\t%d\t%g\t%g\t%g\t%g\t%g\t%g\n", UsrMomH.GetKey(u), GetUsr(UsrMomH.GetKey(u)),
1706        MS.GetVals()+MO.GetVals(), MS.GetVals(), MO.GetVals(), MS.GetMean(), MS.GetMedian(), MO.GetMean(), MO.GetMedian(),
1707        TL.GetMean(), TL.GetMedian());
1708    }
1709    fclose(F);
1710  }
1711  void TWikiElecBs::DrawElecTree(const TStr& OutFNm, const int& MinVotes) const {
1712    TIntV UIdV;  GetEIdByVotes(UIdV);
1713    TWikiVoteV VoteV;
1714    THash<TInt, TIntQu> TreeH;  
1715    const int TakeVotes = 3;
1716    for (int e = 0; e < Len(); e++) {
1717      const TWikiElec& E = GetElec(e);
1718      if (E.Len() < MinVotes) { continue; }
1719      TInt BegVote=1;
1720      const TIntTr SNO = E.GetVotes();
1721      { TIntQu& V = TreeH.AddDat(BegVote);
1722      V.Val1 += SNO.Val1; V.Val2 += SNO.Val3;  V.Val3 += 1;
1723      V.Val4 += E.IsSucc() ? 1:0; }
1724      for (int v = 0; v < TakeVotes; v++) {
1725        if (E[v].GetVote() == 1) { BegVote = 2*BegVote+1; } 
1726        else { BegVote = 2*BegVote; } 
1727        TIntQu& V = TreeH.AddDat(BegVote);
1728        V.Val1 += SNO.Val1;
1729        V.Val2 += SNO.Val3;
1730        V.Val3 += 1;
1731        V.Val4 += E.IsSucc() ? 1:0;
1732      }
1733    }
1734    PNGraph G = TNGraph::New();
1735    TIntStrH LabelH;
1736    TreeH.SortByKey();
1737    for (int i = 0; i < TreeH.Len(); i++) {
1738      printf("%d\n", TreeH.GetKey(i));
1739      const int id = TreeH.GetKey(i);
1740      const int nid = G->AddNode(i+1);
1741      LabelH.AddDat(nid, TStr::Fmt("%sElections: %d\\nSuccessful: %.3f", id==1?"":(id%2==1 ?"SUPPORT\\n":"OPPOSE\\n"), TreeH[i].Val3, TreeH[i].Val4/double(TreeH[i].Val3)));
1742      if (id > 1) {
1743        G->AddEdge(id/2, nid);
1744        printf("link  %d <-- %d\n", id/2, nid);
1745      }
1746    }
1747    TGraphViz::Plot(G, gvlDot, "elecTree-"+OutFNm+".gif", "", LabelH);
1748  }
1749  void TWikiElecBs::PlotVotesOt(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
1750    THash<TInt, TMom> FSupOtA, PSupOtA, DevOtA,
1751      FSupOtS, PSupOtS, DevOtS, FSupOtF, PSupOtF, DevOtF;
1752    int Cnt=0;
1753    for (int e = 0; e < Len(); e++) {
1754      const TWikiElec& E = GetElec(e);
1755      if (E.Len() < MinVotes || E.Len() > MaxVotes) { continue; }
1756      int S = 0;
1757      double Dev = 0;
1758      for (int v = 0; v < E.Len(); v++) {
1759        const int V = E.GetVote(v).GetVote()==1? 1:0;
1760        if (v > 0) {
1761          Dev = fabs(V - S/double(v))/double(v+1); }
1762        S += V; 
1763        if (E.IsSucc) {
1764          FSupOtS.AddDat(v+1).Add(S/double(v+1));
1765          PSupOtS.AddDat(v+1).Add(V);
1766          DevOtS.AddDat(v+1).Add(Dev);
1767        } else {
1768          FSupOtF.AddDat(v+1).Add(S/double(v+1));
1769          PSupOtF.AddDat(v+1).Add(V);
1770          DevOtF.AddDat(v+1).Add(Dev);
1771        }
1772        FSupOtA.AddDat(v+1).Add(S/double(v+1));
1773        PSupOtA.AddDat(v+1).Add(V);
1774        DevOtA.AddDat(v+1).Add(Dev);
1775      }
1776      Cnt++;
1777    }
1778    { TGnuPlot GP("votesOT-Frac-"+OutFNm, TStr::Fmt("Elections %d--%d: %d", MinVotes, MaxVotes, Cnt));
1779    GP.SetXYLabel("Time (vote index)", "Fraction of support votes so far");
1780    GP.AddPlot(FSupOtA, gpwLinesPoints, "ALL elections", "", true, false);
1781    GP.AddPlot(FSupOtS, gpwLinesPoints, "SUCC elections", "", true, false);
1782    GP.AddPlot(FSupOtF, gpwLinesPoints, "FAIL elections", "", true, false);
1783    if (MinVotes>10) { GP.SetXRange(0, MinVotes); }  GP.SavePng(); }
1784    { TGnuPlot GP("votesOT-Sup-"+OutFNm, TStr::Fmt("Elections %d--%d: %d", MinVotes, MaxVotes, Cnt));
1785    GP.SetXYLabel("Time (vote index)", "Probability i-th vote is Support");
1786    GP.AddPlot(PSupOtA, gpwLinesPoints, "ALL elections", "", true, false);
1787    GP.AddPlot(PSupOtS, gpwLinesPoints, "SUCC elections", "", true, false);
1788    GP.AddPlot(PSupOtF, gpwLinesPoints, "FAIL elections", "", true, false);
1789    if (MinVotes>10) { GP.SetXRange(0, MinVotes); }  GP.SavePng(); }
1790    { TGnuPlot GP("votesOT-Dev-"+OutFNm, TStr::Fmt("Elections %d--%d: %d", MinVotes, MaxVotes, Cnt));
1791    GP.SetXYLabel("Time (vote index)", "Vote deviation: avg |avg(V,t+1) - avg(V,t)|");
1792    GP.AddPlot(DevOtA, gpwLinesPoints, "ALL elections", "", true, false);
1793    GP.AddPlot(DevOtS, gpwLinesPoints, "SUCC elections", "", true, false);
1794    GP.AddPlot(DevOtF, gpwLinesPoints, "FAIL elections", "", true, false);
1795    if (MinVotes>10) { GP.SetXRange(0, MinVotes); }  GP.SavePng(); }
1796  }
1797  void TWikiElecBs::PlotCovotingUsers(const TStr& OutFNm, const TStr& MinSupStr, const int& TakeOnlyVotes) const {
1798    PNGraph G = TNGraph::New();
1799    TStrSet RfaSet;
1800    for (int e = 0; e < Len(); e++) {
1801      const TWikiElec& E = GetElec(e);
1802      const int RfaId = Kilo(100)+RfaSet.AddKey(E.RfaTitle);
1803      if (G->IsNode(RfaId)) { printf("%s\n", E.RfaTitle.CStr()); continue; }
1804      IAssertR(! G->IsNode(RfaId), E.RfaTitle);
1805      G->AddNode(RfaId);
1806      for (int v = 0; v < E.Len(); v++) {
1807        if (TakeOnlyVotes==1 && E[v].GetVote() != 1) { continue; } 
1808        else if (TakeOnlyVotes==-1 && E[v].GetVote() != -1) { continue; } 
1809        const int usr = E[v].GetUId();
1810        if (! G->IsNode(usr)) { G->AddNode(usr); }
1811        IAssert(! G->IsEdge(usr, RfaId));
1812        G->AddEdge(usr, RfaId);
1813      }
1814    }
1815    TSnap::PrintInfo(G);
1816    printf("\n*** ALL VOTES\n");
1817    TStrV MinSupV;
1818    TStr(MinSupStr).SplitOnAllCh(',', MinSupV);
1819    TGnuPlot GP(TStr::Fmt("itemSet-%s", OutFNm.CStr()), "Number and size of frequent itemsets");
1820    for (int i = 0; i < MinSupV.Len(); i++) {
1821      printf("\n*** MinSup = %s\n", MinSupV[i].CStr());
1822      TTrawling Trawl(G, MinSupV[i].GetInt());
1823      const TIntPrV SzCntV = Trawl.PlotMinFqVsMaxSet(TStr::Fmt("%s-%02d", OutFNm.CStr(), MinSupV[i].GetInt()));
1824      GP.AddPlot(SzCntV, gpwLinesPoints, TStr::Fmt("MinSup = %d", MinSupV[i].GetInt()));
1825    }
1826    GP.SetXYLabel("Itemset size", "Number of itemsets");
1827    GP.SavePng();
1828  }
1829  void TWikiElecBs::PlotFracBeforeAfterVote(const TStr& OutFNm) const {
1830    THash<TInt, TIntPrV> UIdVotesH;
1831    for (int e = 0; e < Len(); e++) {
1832      const TWikiElec& E = GetElec(e);
1833      if (E.Len() < 10) { continue; } 
1834      for (int v = 0; v < E.Len(); v++) {
1835        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1836      }
1837    }
1838    THash<TFlt, TInt> DeltaCntHA, DeltaCntHS, DeltaCntHO, DeltaCntHA2, DeltaCntHS2, DeltaCntHO2;
1839    FILE *F = fopen(TStr::Fmt("deltabBAUsr-%s.tab", OutFNm.CStr()).CStr(), "wt");
1840    fprintf(F, "#Usr\tVotes\tAvgDSup\tMedDSup\tSupVotes\tAvgDOpp\tMedDOpp\tOppVotes\tAvgTrendSup\tMedTrendSup\tAvgTrendOpp\tMedTrendOpp\n");
1841    for (int u = 0; u < UIdVotesH.Len(); u++) {
1842      const TIntPrV& EV = UIdVotesH[u];
1843      if (EV.Len() < 10) { continue; } 
1844      TMom MomS, MomO, MomS2, MomO2;
1845      for (int ev = 0; ev < EV.Len(); ev++) {
1846        const TWikiElec& E = GetElec(EV[ev].Val1);
1847        const int v = EV[ev].Val2;
1848        if (v < 5 || v+5 >= E.Len()) { continue; }
1849        const double Bef = E.GetFracSup(0, v); 
1850        const double Aft = E.GetFracSup(v+1, E.Len()); 
1851        const double Bef2 = E.GetTrend(0, v);
1852        const double Aft2 = E.GetTrend(v+1, E.Len()); 
1853        DeltaCntHA.AddDat(TMath::Round(Aft-Bef, 2)) += 1;
1854        DeltaCntHA2.AddDat(TMath::Round(Aft2-Bef2, 2)) += 1;
1855        if (E[v].GetVote() == 1) {
1856          DeltaCntHS.AddDat(TMath::Round(Aft-Bef, 2)) += 1;
1857          DeltaCntHS2.AddDat(TMath::Round(Aft2-Bef2, 2)) += 1;
1858          MomS.Add(Aft-Bef);
1859          MomS2.Add(Aft2-Bef2);
1860        } else {
1861          DeltaCntHO.AddDat(TMath::Round(Aft-Bef, 2)) += 1;
1862          DeltaCntHO2.AddDat(TMath::Round(Aft2-Bef2, 2)) += 1;
1863          MomO.Add(Aft-Bef);
1864          MomO2.Add(Aft2-Bef2);
1865        }
1866      }
1867      MomS.Def(); MomO.Def();  MomS2.Def(); MomO2.Def();
1868      if (! MomS.IsUsable() || ! MomO.IsUsable()) { continue; }
1869      fprintf(F, "%s\t%d\t%f\t%f\t%d\t%f\t%f\t%d\n", GetUsr(UIdVotesH.GetKey(u)), EV.Len(),
1870        MomS.GetMean(), MomS.GetMedian(), MomS.GetVals(), MomO.GetMean(), MomO.GetMedian(), MomO.GetVals(),
1871        MomS2.GetMean(), MomS2.GetMedian(), MomO2.GetMean(), MomO2.GetMedian());
1872    }
1873    fclose(F);
1874    TGnuPlot::PlotValCntH(DeltaCntHA, "deltaBA-"+OutFNm, "Fraction of support votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1875      "After - Before fraction of support votes. Any vote.", "Count");
1876    TGnuPlot::PlotValCntH(DeltaCntHS, "deltaBASup-"+OutFNm, "Fraction of support votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1877      "After - Before fraction of support votes. User voted +1.", "Count");
1878    TGnuPlot::PlotValCntH(DeltaCntHO, "deltaBAOpp-"+OutFNm, "Fraction of support votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1879      "After - Before fraction of support votes. User voted -1.", "Count");
1880    TGnuPlot::PlotValCntH(DeltaCntHA2, "deltaTrBA-"+OutFNm, "Trend of fraction ofsupport votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1881      "After - Before trend (linear fit coefficient) fraction of support votes. Any vote.", "Count");
1882    TGnuPlot::PlotValCntH(DeltaCntHS2, "deltaTrBASup-"+OutFNm, "Trend of fraction ofsupport votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1883      "After - Before trend (linear fit coefficient) fraction of support votes. User voted +1.", "Count");
1884    TGnuPlot::PlotValCntH(DeltaCntHO2, "deltaTrBAOpp-"+OutFNm, "Trend of fraction of support votes After-Before user casted a vote. (min 10 votes per user, min 10 vote elections, min 5 votes before/after",
1885      "After - Before trend (linear fit coefficient) fraction of support votes. User voted -1.", "Count");
1886  }
1887  void TWikiElecBs::PlotDeltaFracSupOt(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
1888    THash<TInt, TMom> DeltaOtA, DeltaOtS, DeltaOtF;
1889    int Cnt = 0, CntS=0, CntF=0;
1890    for (int e = 0; e < Len(); e++) {
1891      const TWikiElec& E = GetElec(e);
1892      if (E.Len() < MinVotes || E.Len() > MaxVotes) { continue; }
1893      TIntTr SNO = E.GetVotes();
1894      const double FinalF = SNO.Val1/double(SNO.Val1+SNO.Val3);
1895      int S = 0;
1896      for (int v = 0; v < E.Len(); v++) {
1897        const int V = E.GetVote(v).GetVote()==1? 1:0;
1898        S += V; 
1899        if (E.IsSucc) { DeltaOtS.AddDat(v).Add(S/double(v+1)-FinalF); }
1900        else { DeltaOtF.AddDat(v).Add(S/double(v+1)-FinalF); }
1901        DeltaOtA.AddDat(v).Add(S/double(v+1)-FinalF);
1902      }
1903      if (E.IsSucc) { CntS++; }
1904      else { CntF++; }
1905      Cnt++;
1906    }
1907    TGnuPlot::PlotValMomH(DeltaOtA, "deltaFracSup-A-"+OutFNm, TStr::Fmt("ALL Elections %d--%d: %d", MinVotes, MaxVotes, Cnt),
1908      "Vote index", "Deviation from the final fraction of support votes");
1909    TGnuPlot::PlotValMomH(DeltaOtS, "deltaFracSup-S-"+OutFNm, TStr::Fmt("SUCC Elections %d--%d: %d", MinVotes, MaxVotes, CntS),
1910      "Vote index", "Deviation from the final fraction of support votes");
1911    TGnuPlot::PlotValMomH(DeltaOtF, "deltaFracSup-F-"+OutFNm, TStr::Fmt("FAIL Elections %d--%d: %d", MinVotes, MaxVotes, CntF),
1912      "Vote index", "Deviation from the final fraction of support votes");
1913  }
1914  void TWikiElecBs::PlotUsrVoteVsTime(const TStr& OutFNm, const int& MinUsrVotes, const TIntSet& UsrSplitSet) const {
1915    THash<TInt, TIntPrV> UIdVotesH;
1916    TIntFltH FracSupH;
1917    for (int e = 0; e < Len(); e++) {
1918      const TWikiElec& E = GetElec(e);
1919      for (int v = 0; v < E.Len(); v++) {
1920        UIdVotesH.AddDat(E[v].GetUId()).Add(TIntPr(e,v));
1921      }
1922      FracSupH.AddDat(e, E.GetFracSup());
1923    }
1924    UIdVotesH.SortByDat(false);
1925    THash<TInt, TMom> AllMomH, AllMomHS, AllMomHF, AdmMomH, NAdmMomH;
1926    TIntH AllCntH, AllCntHS, AllCntHF, AdmCntH, NAdmCntH;
1927    int Cnt=0, UCnt=0;
1928    for (int e = 0; e < Len(); e++) {
1929      const TWikiElec& E = GetElec(e);
1930      for (int v = 0; v < TMath::Mn(E.Len(),101); v++) {
1931        const int Vote = E.GetVote(v).GetVote()==1?1:0;
1932        AllMomH.AddDat(v).Add(Vote);
1933        AllCntH.AddDat(v) += 1;
1934        if (E.IsSucc) {
1935          AllMomHS.AddDat(v).Add(Vote);
1936          AllCntHS.AddDat(v) += 1; }
1937        else {
1938          AllMomHF.AddDat(v).Add(Vote);
1939          AllCntHF.AddDat(v) += 1;
1940        }
1941        if (UsrSplitSet.IsKey(E[v].GetUId())) {
1942          AdmMomH.AddDat(v).Add(Vote);
1943          AdmCntH.AddDat(v) += 1;
1944        } else {
1945          NAdmMomH.AddDat(v).Add(Vote);
1946          NAdmCntH.AddDat(v) += 1;
1947        }
1948      }
1949    }
1950    TGnuPlot::PlotValMomH(AllMomH, TStr::Fmt("usrVoteVsTm-%s-all", OutFNm.CStr()),
1951      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1952      "time when user voted", "fraction of positive votes",
1953      gpsAuto, gpwLinesPoints, true, false, false, false, false, false);
1954    TGnuPlot::PlotValCntH(AllCntH, TStr::Fmt("usrVoteVsTm-%s-CNT-all", OutFNm.CStr()),
1955      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1956      "time when user voted", "number of votes");
1957    TGnuPlot::PlotValMomH(AdmMomH, TStr::Fmt("usrVoteVsTm-%s-admin", OutFNm.CStr()),
1958      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1959      "time when user voted", "fraction of positive votes",
1960      gpsAuto, gpwLinesPoints, true, false, false, false, false, false);
1961    TGnuPlot::PlotValCntH(AdmCntH, TStr::Fmt("usrVoteVsTm-%s-CNT-admin", OutFNm.CStr()),
1962      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1963      "time when user voted", "number of votes");
1964    TGnuPlot::PlotValMomH(NAdmMomH, TStr::Fmt("usrVoteVsTm-%s-nonadmin", OutFNm.CStr()),
1965      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1966      "time when user voted", "fraction of positive votes",
1967      gpsAuto, gpwLinesPoints, true, false, false, false, false, false);
1968    TGnuPlot::PlotValCntH(NAdmCntH, TStr::Fmt("usrVoteVsTm-%s-CNT-nonadmin", OutFNm.CStr()),
1969      TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", Cnt, UCnt, MinUsrVotes),
1970      "time when user voted", "number of votes");
1971  }
1972  void TWikiElecBs::PlotFirstOppOutcome(const TStr& OutFNm, const int& NVotes) const {
1973    THash<TInt, TMom> FOppH, FOpp2H;
1974    TIntH FOppCntH;
1975    int NElec=0;
1976    for (int e = 0; e < Len(); e++) {
1977      const TWikiElec& E = GetElec(e);
1978      if (E.Len() < 10 || E.Len() < NVotes) { continue; } 
1979      int FirstOpp=-1, VoteSum=0;
1980      for (int v = 0; v < NVotes; v++) {
1981        if (E[v].GetVote()==-1 && FirstOpp==-1) { FirstOpp = v+1; }
1982        VoteSum += E[v].GetVote();
1983      }
1984      if (VoteSum != NVotes-2) { continue; }
1985      FOppCntH.AddDat(FirstOpp) += 1;
1986      FOppH.AddDat(FirstOpp).Add(E.IsSucc?1:0);
1987      FOpp2H.AddDat(FirstOpp).Add(E.GetFracSup());
1988      NElec++;
1989    }
1990    TGnuPlot::PlotValMomH(FOppH, "firstOpp1-"+OutFNm, TStr::Fmt("Take first %d votes of an election, where %d Sup and 1 Opp. %d such elections", NVotes, NVotes-1, NElec),
1991      "Index of the oppose vote", "Fraction of successful elections", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
1992    TGnuPlot::PlotValMomH(FOpp2H, "firstOpp2-"+OutFNm, TStr::Fmt("Take first %d votes of an election, where %d Sup and 1 Opp. %d such elections", NVotes, NVotes-1, NElec),
1993      "Index of the oppose vote", "Final fraction of support votes in the election", gpsAuto, gpwLinesPoints, true, false, false, false, true, false);
1994    TGnuPlot::PlotValCntH(FOppCntH, "firstOppCnt-"+OutFNm, TStr::Fmt("Take first %d votes of an election, where %d Sup and 1 Opp. %d such elections", NVotes, NVotes-1, NElec),
1995      "Index of the oppose vote", "Number of such elections");
1996  }
1997  void TWikiElecBs::PlotVoteTrails(const TStr& OutFNm, const int& MinUsrVotes, const bool& No01Prob) const {
1998    TIntSet AdminSet;
1999    TIntV UIdV;
2000    TVec<TFltPrV> ProbSupTmV, FracSupTmV, ProbSupFracSupV, VotesTmV, VoteIdxFracSupV, NVotesFracSupV;
2001    const int TotalVotes = GetVoteTrails(MinUsrVotes, No01Prob, UIdV, ProbSupTmV, FracSupTmV, ProbSupFracSupV, VotesTmV);
2002    GetVoteTrails2(MinUsrVotes, No01Prob, UIdV, VoteIdxFracSupV, NVotesFracSupV);
2003    GetAdminSet(AdminSet);
2004    TIntH UsrLnTy;
2005    for (int u = 0; u < UIdV.Len(); u++) { UsrLnTy.AddDat(UIdV[u], AdminSet.IsKey(UIdV[u])?2:1); }
2006    TGnuPlot GPP("voteTrailP-"+OutFNm+"-r10"); 
2007    TGnuPlot GPF("voteTrailF-"+OutFNm+"-r10");
2008    TGnuPlot GPPF("voteTrailPF-"+OutFNm+"-r10");
2009    TGnuPlot GPV("voteHist-"+OutFNm+"-r10"); 
2010    TGnuPlot GPFI("voteFIdx-"+OutFNm+"-r10");
2011    TGnuPlot GPFC("voteFCnt-"+OutFNm+"-r10");
2012    THash<TFlt, TMom> AvgAdm, AvgNAdm;
2013    bool FirstA=true, FirstNA=true;
2014    for (int u = 0; u < UIdV.Len(); u++) {
2015      const int UId = UIdV[u];
2016      TStr Tit;
2017      if (FirstA && UsrLnTy.GetDat(UId) == 2) { Tit="Admin (HIGH)"; FirstA=false; }
2018      if (FirstNA && UsrLnTy.GetDat(UId) == 1) { Tit="NonAdmin (LOW)"; FirstNA=false; }
2019      GPP.AddPlot(ProbSupTmV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2020      GPF.AddPlot(FracSupTmV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2021      GPV.AddPlot(VotesTmV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2022      GPPF.AddPlot(ProbSupFracSupV[u], gpwLinesPoints, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2023      GPFI.AddPlot(VoteIdxFracSupV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2024      GPFC.AddPlot(NVotesFracSupV[u], gpwLines, Tit, TStr::Fmt("lt %d lw 1 smooth bezier", UsrLnTy.GetDat(UId)));
2025      for (int i = 0; i < ProbSupFracSupV[u].Len(); i++) {
2026        if (AdminSet.IsKey(UId) || AdminSet.Empty()) { 
2027          AvgAdm.AddDat(ProbSupFracSupV[u][i].Val1).Add(ProbSupFracSupV[u][i].Val2); }
2028        else { 
2029          AvgNAdm.AddDat(ProbSupFracSupV[u][i].Val1).Add(ProbSupFracSupV[u][i].Val2); }
2030      }
2031    }
2032    TFltPrV AvgAdmV, AvgNAdmV;
2033    for (int i =0; i < AvgAdm.Len(); i++) { AvgAdm[i].Def();
2034      AvgAdmV.Add(TFltPr(AvgAdm.GetKey(i), AvgAdm[i].GetMean())); }
2035    for (int i =0; i < AvgNAdm.Len(); i++) { AvgNAdm[i].Def();
2036      AvgNAdmV.Add(TFltPr(AvgNAdm.GetKey(i), AvgNAdm[i].GetMean())); }
2037    AvgAdmV.Sort();  AvgNAdmV.Sort();
2038    GPPF.AddPlot(AvgAdmV, gpwLinesPoints, "AVG ADMIN (HIGH)", TStr::Fmt("lt %d lw 5 smooth bezier", 4));
2039    GPPF.AddPlot(AvgNAdmV, gpwLinesPoints, "AVG NON-ADMIN (LOW)", TStr::Fmt("lt %d lw 5 smooth bezier", 3));
2040    GPP.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2041    GPP.SetXYLabel("vote index", "probability of support vote");
2042    GPP.SetYRange(0,1.01);
2043    GPF.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2044    GPF.SetXYLabel("vote index", "fraction of support votes so far");
2045    GPF.SetYRange(0,1.01);
2046    GPPF.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2047    GPPF.SetXYLabel("Fraction of support votes at time of vote", "Probability of voting positively");
2048    GPPF.SetYRange(0,1.01);
2049    GPPF.SavePng();
2050    GPV.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2051    GPV.SetXYLabel("vote index", "number of votes");
2052    GPFI.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2053    GPFI.SetXYLabel("Fraction of support votes at time of vote", "Average vote index (time) of a user voting");
2054    GPFC.SetTitle(TStr::Fmt("%d votes of %d users with more than %d votes. ALL ELEC.", TotalVotes, UIdV.Len(), MinUsrVotes));
2055    GPFC.SetXYLabel("Fraction of support votes at time of vote", "Number of times user voted at that fraction");
2056  }
2057  void TWikiElecBs::PlotVoteTrailGlobal(const TStr& OutFNm) const {
2058    THash<TInt, TMom> SuppVoteH, Set1, Set2;
2059    TIntSet UIdSet;
2060    GetAdminSet(UIdSet);
2061    for (int e = 0; e < Len(); e++) {
2062      const TWikiElec& E = GetElec(e);
2063      int nsup=0;
2064      if (E.Len()<10) { continue; }
2065      for (int v = 0; v < E.Len(); v++) {
2066        const int supFrac = v==0? 0 : int(TMath::Round(10.0*nsup/double(v)))*10;
2067        nsup += E.GetVote(v).GetVote()==1?1:0;
2068        if (v<10) { continue; } 
2069        SuppVoteH.AddDat(supFrac).Add(E.GetVote(v).GetVote()==1?1:0);
2070        if (UIdSet.IsKey(E.GetVote(v).GetUId())) { 
2071          Set1.AddDat(supFrac).Add(E.GetVote(v).GetVote()==1?1:0);
2072        } else { 
2073          Set2.AddDat(supFrac).Add(E.GetVote(v).GetVote()==1?1:0);
2074        }
2075      }
2076    }
2077    TGnuPlot::PlotValMomH(SuppVoteH, "voteTrailAll-"+OutFNm, "Global vote trail", "Fraction of support votes at time of vote", "Probability of voting positively", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
2078    TGnuPlot::PlotValMomH(Set1, "voteTrailAll1-"+OutFNm, "Global vote trail. Set1", "Fraction of support votes at time of vote", "Probability of voting positively", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
2079    TGnuPlot::PlotValMomH(Set2, "voteTrailAll2-"+OutFNm, "Global vote trail. Set2", "Fraction of support votes at time of vote", "Probability of voting positively", gpsAuto, gpwLinesPoints, true, false, false, false, false, true);
2080  }
2081  void TWikiElecBs::PlotFinalFracVoteCnt(const TStr& OutFNm, const int& MinUsrVotes, const TIntSet& UsrSplitSet) const {
2082    TIntPrV VoteUIdV; GetUsrVotes(VoteUIdV);
2083    THash<TInt, TIntH> UIdVoteCntH;
2084    TIntH FracVotesH, Set1, Set2;
2085    VoteUIdV.Sort(false);
2086    for (int i = 0; i < VoteUIdV.Len() && VoteUIdV[i].Val1>MinUsrVotes; i++) {
2087      UIdVoteCntH.AddKey(VoteUIdV[i].Val2); }
2088    for (int e = 0; e < Len(); e++) {
2089      const TWikiElec& E = GetElec(e);
2090      const int SupFrac= (int(100*E.GetFracSup())/10)*10;
2091      for (int v = 0; v < E.Len(); v++) {
2092        const int V = E[v].GetVote()==1?1:0;
2093        const int U = E[v].GetUId();
2094        FracVotesH.AddDat(SupFrac) += 1;
2095        if (UsrSplitSet.IsKey(U)) { Set1.AddDat(SupFrac) += 1; }
2096        else { Set2.AddDat(SupFrac) += 1; }
2097        if (UIdVoteCntH.IsKey(U)) { UIdVoteCntH.AddDat(U).AddDat(SupFrac) += 1; }
2098      }
2099    }
2100    TGnuPlot::PlotValCntH(FracVotesH, "voteFrac-"+OutFNm+"-all", "All users", "Final fraction of support votes", "Number of votes");
2101    TGnuPlot::PlotValCntH(Set1, "voteFrac-"+OutFNm+"-set1", "UsrSplitSet users", "Final fraction of support votes", "Number of votes");
2102    TGnuPlot::PlotValCntH(Set2, "voteFrac-"+OutFNm+"-set2", "Users no in UsrSplitSet", "Final fraction of support votes", "Number of votes");
2103    TGnuPlot GP("voteFrac-"+OutFNm);
2104    for (int u = 0; u < UIdVoteCntH.Len(); u++) {
2105      TIntPrV ValV;
2106      UIdVoteCntH[u].GetKeyDatPrV(ValV);
2107      ValV.Sort();
2108      GP.AddPlot(ValV, gpwLinesPoints, "", TStr::Fmt("lw 1 smooth bezier"));
2109    }
2110    GP.SetXYLabel("Final fraction of support votes", "Number of votes");
2111    GP.SavePng();
2112  }
2113  void TWikiElecBs::PlotConfusionMatrix(const TStr& OutFNm, const int& MinUsrVotes) const {
2114    THash<TInt, TTuple<TFlt, 4> > TupH;
2115    for (int e = 0; e < Len(); e++) {
2116      const TWikiElec& E = GetElec(e);
2117      const int R = E.IsSucc?1:0;
2118      for (int v = 0; v < E.Len(); v++) {
2119        const int V = E[v].GetVote()==1?1:0;
2120        TupH.AddDat(E[v].GetUId())[2*R+V] += 1;
2121      }
2122    }
2123    FILE *F=fopen(TStr::Fmt("confusion-%s.tab", OutFNm.CStr()).CStr(), "wt");
2124    for (int u = 0; u < TupH.Len(); u++) {
2125      const double S = TupH[u][0]+TupH[u][1]+TupH[u][2]+TupH[u][3];
2126      if (S < MinUsrVotes) { continue; }
2127      fprintf(F, "%f\t%f\t%f\t%f\n", TupH[u][0], TupH[u][1], TupH[u][2], TupH[u][3]);
2128    }
2129    fclose(F);
2130  }
2131  void TWikiElecBs::PlotSlopeHist(const TStr& OutFNm, const int& MinElecLen) const {
2132    const double BPrec = 1000;
2133    TIntH R21A, R22A, K1A, K2A;
2134    TIntH R21S, R22S, K1S, K2S;
2135    TIntH R21F, R22F, K1F, K2F;
2136    int Cnt=0;
2137    for (int e = 0; e < Len(); e++) {
2138      const TWikiElec& E = GetElec(e);
2139      if (E.Len() < MinElecLen) { continue; }
2140      TFltPrV XyV, Xy2;
2141      for (int v = 0; v < E.Len(); v++) {
2142        XyV.Add(TFltPr(v, E[v].GetVote()));
2143        Xy2.Add(TFltPr(v, E.GetFracSup(0, v+1)));
2144      }
2145      double A, B, SigA, SigB, Chi2, R2=0;
2146      TSpecFunc::LinearFit(XyV, A, B, SigA, SigB, Chi2, R2);
2147      if (R2 < -1 || _isnan(R2)) R2 = 0;
2148      K1A.AddDat(int(BPrec*B))+=1;
2149      R21A.AddDat(int(100*R2))+=1;
2150      if (E.IsSucc) {
2151        K1S.AddDat(int(BPrec*B))+=1;
2152        R21S.AddDat(int(100*R2))+=1;
2153      } else {
2154        K1F.AddDat(int(BPrec*B))+=1;
2155        R21F.AddDat(int(100*R2))+=1;
2156      }
2157      TSpecFunc::LinearFit(Xy2, A, B, SigA, SigB, Chi2, R2);
2158      if (R2 < -1 || _isnan(R2)) R2 = 0;
2159      K2A.AddDat(int(BPrec*B))+=1;
2160      R22A.AddDat(int(100*R2))+=1;
2161      if (E.IsSucc) {
2162        K2S.AddDat(int(BPrec*B))+=1;
2163        R22S.AddDat(int(100*R2))+=1;
2164      } else {
2165        K2F.AddDat(int(BPrec*B))+=1;
2166        R22F.AddDat(int(100*R2))+=1;
2167      }
2168      Cnt++;
2169    }
2170    TGnuPlot::PlotValCntH(K1A, "ALL ELEC", K1S, "SUCC ELEC", K1F, "FAIL ELEC", "slopeK1-"+OutFNm, TStr::Fmt("%d elections with >%d votes", Cnt, MinElecLen),  "slope (fit of Prob(+|t) vs t)", "count", gpsLog10Y);
2171    TGnuPlot::PlotValCntH(K2A, "ALL ELEC", K2S, "SUCC ELEC", K2F, "FAIL ELEC", "slopeK2-"+OutFNm, TStr::Fmt("%d elections with >%d votes", Cnt, MinElecLen),  "slope (fit of FracSup(1..t) vs t)", "count", gpsLog10Y);
2172    TGnuPlot::PlotValCntH(R21A, "ALL ELEC", R21S, "SUCC ELEC", R21F, "FAIL ELEC", "slopeR1-"+OutFNm, TStr::Fmt("%d elections with >%d votes", Cnt, MinElecLen),  "R2 (fit of Prob(+|t) vs t)", "count", gpsLog10Y);
2173    TGnuPlot::PlotValCntH(R22A, "ALL ELEC", R22S, "SUCC ELEC", R22F, "FAIL ELEC", "slopeR2-"+OutFNm, TStr::Fmt("%d elections with >%d votes", Cnt, MinElecLen),  "R2 (fit of FracSup(1..t) vs t)", "count", gpsLog10Y);
2174  }
2175  void TWikiElecBs::PlotBarnStarsDelta(const TStr& OutFNm) const {
2176    TBarnStars BarnStars;
2177    THash<TInt, TMom> DiffMomH;
2178    TIntH DiffCntH;
2179    for (int e = 0; e < Len(); e++) {
2180      const TWikiElec& E = GetElec(e);
2181      const TStr TargetUsr = GetUsr(E.GetUId());
2182      const int TB = BarnStars.GetBarnStars(TargetUsr, E.GetTm());
2183      for (int v = 0; v < E.Len(); v++) {
2184        if (! E[v].IsVote()) { continue; }
2185        const int DeltaStars = BarnStars.GetBarnStars(GetUsr(E[v].GetUId()), E[v].GetTm()) - TB;
2186        DiffMomH.AddDat(DeltaStars).Add(E[v].GetVote()==1?1:0);
2187        DiffCntH.AddDat(DeltaStars) += 1;
2188      }
2189    }
2190    TGnuPlot::PlotValMomH(DiffMomH, "dBarnStars-"+OutFNm, "Number of BarnStars (over ALL VOTES): "+OutFNm, "Barnstars delta (source - destination)",
2191      "Fraction of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2192    TGnuPlot::PlotValCntH(DiffCntH, "dBarnStarts2-"+OutFNm, "Number of BarnSTars (over aLL VOES): "+OutFNm, "Barnstars delta (source - destination)",
2193      "Number of such users", gpsAuto, false, gpwLinesPoints, false, false);
2194  }
2195  void TWikiElecBs::PlotAdminVotes(const TStr& OutFNm) const {
2196    TIntH APos, NAPos, ANeg, NANeg;
2197    TIntPrSet AVotes, NAVotes;
2198    for (int e = 0; e < Len(); e++) {
2199      const TIntTr V = GetElec(e).GetVotes(true);
2200      if (GetElec(e).IsSucc) {
2201        APos.AddDat(V.Val1) += 1;
2202        ANeg.AddDat(V.Val3) += 1;
2203        AVotes.AddKey(TIntPr(V.Val1, V.Val3));
2204      } else {
2205        NAPos.AddDat(V.Val1) += 1;
2206        NANeg.AddDat(V.Val3) += 1;
2207        NAVotes.AddKey(TIntPr(V.Val1, V.Val3));
2208      }
2209    }
2210    { TGnuPlot GP("adminSup-"+OutFNm, OutFNm);
2211    GP.AddPlot(APos, gpwLinesPoints, "Support votes for ADMINS");
2212    GP.AddPlot(NAPos, gpwLinesPoints, "Support votes for NON-ADMINS");
2213    GP.SetXYLabel("Number of support votes", "Number of elections");
2214    GP.SavePng(); }
2215    { TGnuPlot GP("adminOpp-"+OutFNm, OutFNm);
2216    GP.AddPlot(ANeg, gpwLinesPoints, "Oppose votes for ADMINS");
2217    GP.AddPlot(NANeg, gpwLinesPoints, "Oppose votes for NON-ADMINS");
2218    GP.SetXYLabel("Number of oppose votes", "Number of elections");
2219    GP.SavePng(); }
2220    { TGnuPlot GP("adminSupOpp-"+OutFNm, OutFNm);
2221    TIntPrV V;  AVotes.GetKeyV(V);
2222    GP.AddPlot(V, gpwPoints, "Votes for ADMINS");
2223    NAVotes.GetKeyV(V);
2224    GP.AddPlot(V, gpwPoints, "Votes for NON-ADMINS");
2225    GP.SetXYLabel("Number of support votes", "Number of oppose votes");
2226    GP.SavePng(); }
2227  }
2228  void TWikiElecBs::PlotAvgVote(const TStr& OutFNm, const int& MinVotes, const int& MaxVotes) const {
2229    TIntV ElecV;
2230    for (int e = 0; e < Len(); e++) {
2231      if (! GetElec(e).IsSucc()) {
2232        ElecV.Add(e); }
2233    }
2234    PlotAvgVote(ElecV, OutFNm, TStr::Fmt("Elections with %d--%d votes, %d elections", MinVotes, MaxVotes, ElecV.Len()));
2235  }
2236  void TWikiElecBs::PlotAvgVote(const TIntV& ElecIdV, const TStr& OutFNm, const TStr& Desc) const {
2237    THash<TInt, TMom> MomH;
2238    THash<TInt, TMom> Mom2H;
2239    TFltV AvgVoteV;
2240    for (int i = 0; i < ElecIdV.Len(); i++) {
2241      GetElec(ElecIdV[i]).GetAvgVoteOt(AvgVoteV, true);
2242      for (int v = 0; v < AvgVoteV.Len(); v++) {
2243        MomH.AddDat(v+1).Add(AvgVoteV[v]); }
2244      const TWikiElec& E = GetElec(ElecIdV[i]);
2245      for (int v = 0; v < E.Len(); v++) {
2246        Mom2H.AddDat(v).Add(E.GetVote(v).GetVote()==1?1:0);
2247      }
2248    }
2249    TGnuPlot::PlotValMomH(MomH, "voteAvg-"+OutFNm, TStr::Fmt("%s. %d elections", Desc.CStr(), ElecIdV.Len()),
2250      "n (vote index, time)", "Running average of positive votes", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2251    TGnuPlot::PlotValMomH(Mom2H, "voteAvg2-"+OutFNm, TStr::Fmt("%s. %d elections", Desc.CStr(), ElecIdV.Len()),
2252      "n (vote index, time)", "Probability of positive vote", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2253  }
2254  void TWikiElecBs::PlotAvgVoteDev(const TIntV& ElecIdV, const TStr& OutFNm, const TStr& Desc) const {
2255    THash<TInt, TMom> MomH;
2256    TFltV AvgVoteV;
2257    for (int i = 0; i < ElecIdV.Len(); i++) {
2258      GetElec(ElecIdV[i]).GetAvgVoteDevOt(AvgVoteV, true);
2259      for (int v = 0; v < AvgVoteV.Len(); v++) {
2260        MomH.AddDat(v+1).Add(AvgVoteV[v]); }
2261    }
2262    TGnuPlot::PlotValMomH(MomH, "voteDev-"+OutFNm, TStr::Fmt("%s. %d elections", Desc.CStr(), ElecIdV.Len()),
2263      "n (vote index, time)", "Deviation of the running average", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2264    MomH.SortByKey();
2265    for (int v = 0; v < MomH.Len(); v+=10) {
2266      printf("  %d\t%g\n", v, MomH[v].GetWgt());
2267    }
2268  }
2269  void TWikiElecBs::PlotAvgSupFrac(const TIntV& ElecIdV, const TStr& OutFNm, const TStr& Desc) const {
2270    THash<TInt, TMom> MomH;
2271    TFltV AvgVoteV;
2272    for (int i = 0; i < ElecIdV.Len(); i++) {
2273      TWikiVoteV VoteV;
2274      GetElec(ElecIdV[i]).GetVotesOt(VoteV);
2275      for (int v = 0; v < VoteV.Len(); v++) {
2276        MomH.AddDat(v+1).Add(VoteV[v].GetVote()==1?1:0); }
2277    }
2278    TGnuPlot::PlotValMomH(MomH, "voteFrac-"+OutFNm, TStr::Fmt("%s. %d elections", Desc.CStr(), ElecIdV.Len()),
2279      "T (vote index, time)", "Fraction of all votes casted at time T that were supporting", gpsAuto, gpwLinesPoints, true, false, false, false, false);
2280  }
2281  void TWikiElecBs::PlotOutcomes(const TStr& OutFNm) const {
2282    TWikiVoteV VoteV;
2283    TIntV UIdV;  GetEIdByVotes(UIdV);
2284    TGnuPlot GP("votes-otime3-0"), GP2("votes-otime4-0");
2285    for (int u = 0; u < 100; u++) {
2286      const TWikiElec& E = GetElec(UIdV[u]);
2287      E.GetVotesOt(VoteV, true);
2288      const int b = VoteV[0].GetTm().GetAbsSecs();
2289      TFltPrV FracV, FracV2;
2290      int pos=0, neg=0;
2291      for (int v = 0; v < VoteV.Len(); v++) {
2292        if (VoteV[v].GetVote()==1) { pos++; }
2293        else if (VoteV[v].GetVote()==-1) { neg++; } else { continue; }
2294        FracV.Add(TFltPr(v, pos/double(pos+neg)));
2295        FracV2.Add(TFltPr(v/double(VoteV.Len()), pos/double(pos+neg)));
2296      }
2297      GP.AddPlot(FracV, gpwLines);
2298      GP2.AddPlot(FracV2, gpwLines);
2299      if ((u+1) % 10 == 0) {
2300        GP.SavePng();
2301        GP2.SavePng();
2302        GP = TGnuPlot(TStr::Fmt("votes-otime3-%d", u/10));
2303        GP2 = TGnuPlot(TStr::Fmt("votes-otime4-%d", u/10));
2304      }
2305    }
2306    GP.SavePng();
2307    GP2.SavePng();
2308  }
2309  void TWikiElecBs::PlotSupFracVsElecLen(const TStr& OutFNm) const {
2310    THash<TInt, TMom> ElecMom;
2311    THash<TInt, TMom> ElecMom5;
2312    THash<TInt, TMom> ElecMom10;
2313    for (int e = 0; e < Len(); e++) {
2314      ElecMom.AddDat(GetElec(e).Len()).Add(GetElec(e).GetFracSup());
2315      ElecMom5.AddDat(5*(GetElec(e).Len()/5)).Add(GetElec(e).GetFracSup());
2316      ElecMom10.AddDat(10*(GetElec(e).Len()/10)).Add(GetElec(e).GetFracSup());
2317    }
2318    TGnuPlot::PlotValMomH(ElecMom, "fracSupLen-"+OutFNm, "Bucket size 1", "Number of votes in the election", "Final fraction of support votes");
2319    TGnuPlot::PlotValMomH(ElecMom5, "fracSupLen-"+OutFNm+"5", "Bucket size 5", "Number of votes in the election", "Final fraction of support votes");
2320    TGnuPlot::PlotValMomH(ElecMom10, "fracSupLen-"+OutFNm+"10", "Bucket size 10", "Number of votes in the election", "Final fraction of support votes");
2321  }
2322  void TWikiElecBs::PlotSupOpp(const TStr& OutFNm) const {
2323  }
2324  void TWikiElecBs::PlotVoteDistr(const TStr& OutFNm) const {
2325    TWikiVoteV VoteV;
2326    TIntV UIdV;  GetEIdByVotes(UIdV);
2327    TVec<TMom> SupV, OppV;
2328    THash<TInt, TIntH> PosH, NegH;
2329    for (int u = 0; u < 2000; u++) {
2330      const TWikiElec& E = GetElec(UIdV[u]);
2331      const TIntTr PON = E.GetVotes(true);
2332      if ((PON.Val1+2*PON.Val2) < 50)  {
2333        PosH.AddDat((PON.Val1+PON.Val2)/10).AddDat((PON.Val1))++;
2334        NegH.AddDat((PON.Val1+PON.Val2)/10).AddDat((PON.Val1-PON.Val2))++;
2335        printf("%d ", PON.Val1+PON.Val2);
2336      }
2337    }
2338    PosH.SortByKey(); NegH.SortByKey();
2339    for (int i = 0; i < PosH.Len(); i++) {
2340      TGnuPlot GP(TStr::Fmt("voteX-distr%02d", PosH.GetKey(i)));
2341      TFltPrV PrV1, PrV2;
2342      IAssert(PosH.GetKey(i) == NegH.GetKey(i));
2343      TIntH& CntH1 = PosH[i];  CntH1.SortByKey();
2344      TIntH& CntH2 = NegH[i];  CntH2.SortByKey();
2345      for (int j = 0; j < CntH1.Len(); j++) {
2346        PrV1.Add(TFltPr(CntH1.GetKey(j).Val, CntH1[j].Val)); }
2347      for (int j = 0; j < CntH2.Len(); j++) {
2348        PrV2.Add(TFltPr(CntH2.GetKey(j).Val, CntH2[j].Val)); }
2349      GP.AddPlot(PrV1, gpwLinesPoints, "Pos");
2350      GP.AddCmd("set yzeroaxis lt -1");
2351      GP.SavePng();
2352    }
2353  }
2354  PSignNet TWikiElecBs::GetAdminUsrVoteNet() const {
2355    TIntV UIdV;
2356    GetElecAdminUsrV(UIdV);
2357    return GetVoteNet(UIdV);
2358  }
2359  PSignNet TWikiElecBs::GetElecUsrVoteNet() const {
2360    TIntV UIdV;
2361    GetElecUsrV(UIdV);
2362    return GetVoteNet(UIdV);
2363  }
2364  PSignNet TWikiElecBs::GetAllUsrVoteNet() const {
2365    TIntV UIdV;
2366    GetUsrV(UIdV);
2367    return GetVoteNet(UIdV);
2368  }
2369  PSignNet TWikiElecBs::GetVoteNet(const TIntV& UsrIdV) const {
2370    TIntSet UsrSet;
2371    for (int u = 0; u < UsrIdV.Len(); u++) {
2372      UsrSet.AddKey(UsrIdV[u]);
2373    }
2374    PSignNet Net = TSignNet::New();
2375    THash<TIntPr, TStr> EdgeElecH;
2376    for (int e = 0; e < Len(); e++) {
2377      const TWikiElec& FullE = GetElec(e);
2378      const int Dst = FullE.GetUId();
2379      if (! UsrSet.IsKey(Dst)) { continue; }
2380      TWikiElec NewElec;
2381      FullE.GetOnlyVotes(NewElec, true);
2382      for (int v = 0; v < NewElec.Len(); v++) {
2383        const int Src = NewElec[v].GetUId();
2384        if (! UsrSet.IsKey(Src)) { continue; }
2385        if (Src == Dst) { continue; }
2386        if (! Net->IsNode(Dst)) {
2387          Net->AddNode(Dst); }
2388        if (! Net->IsNode(Src)) {
2389          Net->AddNode(Src); }
2390        if (Net->IsEdge(Src, Dst)) { 
2391        }
2392        Net->AddEdge(Src, Dst, NewElec[v].GetVote());
2393      }
2394    }
2395    return Net;
2396  }
2397  void TWikiElecBs::GetOnlyVoteElecBs(TWikiElecBs& NewElecBs, const bool& OnlySupOpp) const {
2398    NewElecBs.UsrH = UsrH;
2399    NewElecBs.ElecV = ElecV;
2400    for (int e = 0; e < ElecV.Len(); e++) {
2401      ElecV[e].GetOnlyVotes(NewElecBs.ElecV[e], OnlySupOpp);  
2402    }
2403  }
2404  bool TWikiElecBs::AddElecRes(const TWikiMetaHist& WMH, const THash<TStr, TStr>& UsrMapH, const THash<TStr, TWikiElecBs::TElecSum>& ElecSumH) {
2405    if (! WMH.Title.IsPrefix("Wikipedia:Requests_for_adminship/")) { return false; }
2406    const int b = WMH.Title.SearchCh('/')+1;
2407    const int e = WMH.Title.SearchCh('/', b+1)-1;
2408    TChA RfaTitle = WMH.Title.GetSubStr(b, e>b?e:TInt::Mx);
2409    TWikiElec WikiElec(-1, WMH.RevTm); 
2410    ParseVotes(WMH, UsrMapH, WikiElec);
2411    WikiElec.SetIsVoteFlag();
2412    WikiElec.RfaTitle = RfaTitle;
2413    TIntTr V = WikiElec.GetVotes();
2414    if (RfaTitle.IsSuffix("_Couriano")) { RfaTitle = "Couriano"; } 
2415    if (ElecSumH.IsKey(RfaTitle)) {
2416      const TElecSum& ElSum = ElecSumH.GetDat(RfaTitle);
2417      WikiElec.IsSucc = true;
2418      TChA U = ElSum.Usr;
2419      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
2420      WikiElec.UsrId = AddUsr(ElSum.Usr.CStr()); 
2421      if (! ElSum.Bureaucrat.Empty()) {
2422        TChA U = ElSum.Bureaucrat;
2423        if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
2424        WikiElec.BurUId = AddUsr(U);
2425      }
2426      if (! ElSum.NominatedBy.Empty()) {
2427        TChA U = ElSum.NominatedBy;
2428        if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
2429        WikiElec.NomUId = AddUsr(U);
2430      }
2431      if (abs(V.Val1-ElSum.Sup) > 0) { printf("SUP VOTES: %d != %d\n", V.Val1, ElSum.Sup);  }
2432      if (abs(V.Val2-ElSum.Neu) > 0) { printf("NEU VOTES: %d != %d\n", V.Val2, ElSum.Neu);  }
2433      if (abs(V.Val3-ElSum.Opp) > 0) { printf("OPP VOTES: %d != %d\n", V.Val3, ElSum.Opp);  }
2434    } else {
2435      TChA U = RfaTitle.ToLc(); 
2436      if (UsrMapH.IsKey(U)) { U = UsrMapH.GetDat(U); }
2437      WikiElec.UsrId = AddUsr(U); 
2438    }
2439    if (V.Val1+V.Val2+V.Val3 == 0) {
2440      printf("no votes\n"); return false;
2441    }
2442    ElecV.Add(WikiElec);
2443    return true;
2444  }
2445  int TWikiElecBs::GetWikiTxtLen(char* LineStr) {
2446    int Len=0;
2447    for (char *ch=LineStr+1; *ch != NULL; ch++) {
2448      if (TCh::IsAlNum(*ch)) { Len++; }
2449      if (*ch=='[' && *(ch-1)=='[') {
2450        while (*ch && *ch!=']' && *(ch-1)!=']') { ch++; }
2451      }
2452    }
2453    return Len;
2454  }
2455  void TWikiElecBs::LoadElecSumTxt(const TStr& FNm, THash<TStr, TWikiElecBs::TElecSum>& ElecSumH) {
2456    ElecSumH.Clr();
2457    for (TSsParser SS(FNm, ssfTabSep); SS.Next(); ) {
2458      IAssert(SS.Len() == 9);
2459      TElecSum& S = ElecSumH.AddDat(SS[1]); 
2460      S.Usr = SS[0];          S.Usr.ToLc();
2461      S.RfA = SS[1];
2462      S.Sup = SS.GetInt(2);
2463      S.Opp = SS.GetInt(3);
2464      S.Neu = SS.GetInt(4);
2465      S.NominatedBy = SS[7];  S.NominatedBy.ToLc();
2466      S.Bureaucrat = SS[8];   S.Bureaucrat.ToLc();
2467    }
2468  }
2469  bool EndOfSection(char* Line, const TStr& WhatStr) {
2470    if (Line[0]=='#' || Line[0]==':') { return false; }
2471    TChA LnStr(Line);
2472    LnStr.ToTrunc();
2473    if (LnStr.SearchStr(TStr::Fmt("'''%s'''", WhatStr.CStr()))!=-1) { return true; }
2474    if (LnStr.SearchStr(TStr::Fmt("====%s====", WhatStr.CStr()))!=-1) { return true; }
2475    if (LnStr.SearchStr(TStr::Fmt("==== %s ====", WhatStr.CStr()))!=-1) { return true; }
2476    if (LnStr.SearchStr(TStr::Fmt("'''%s:'''", WhatStr.CStr()))!=-1) { return true; }
2477    if (LnStr.SearchStr(TStr::Fmt("====%s:====", WhatStr.CStr()))!=-1) { return true; }
2478    if (LnStr.IsPrefix(TStr::Fmt("; %s", WhatStr.CStr()))) { return true; }
2479    if (LnStr.IsPrefix(TStr::Fmt(";%s", WhatStr.CStr()))) { return true; }
2480    if (LnStr==TStr::Fmt("%s", WhatStr.CStr())) { return true; }
2481    if (LnStr==TStr::Fmt("%s:", WhatStr.CStr())) { return true; }
2482    return false;
2483  }
2484  void TWikiElecBs::ParseVotes(const TWikiMetaHist& WMH, const THash<TStr, TStr>& UsrMapH, TWikiElec& WikiElec) {
2485    TVec<char *> LineV;  TChA Tmp = WMH.Text;
2486    Tmp.ToLc();
2487    TStrUtil::SplitLines(Tmp, LineV);
2488    int l = 0, goodVote=0;
2489    int NSup=0, NOpp=0, NNeu=0;
2490    for (; l < LineV.Len(); l++) {
2491      if (EndOfSection(LineV[l], "support")) { l++; break; }
2492      char *vote=strstr(LineV[l], ") end");
2493      if (vote == NULL) { vote=strstr(LineV[l], ") end"); }
2494      if (vote != NULL && TCh::IsNum(*(vote-1)) && NSup==-1) {
2495        *vote=0;  vote--;
2496        while(TCh::IsNum(*vote)) { vote--; }
2497        if (*vote == '/') {
2498          NNeu = atoi(vote+1);  *vote=0;  vote--;
2499          while(TCh::IsNum(*vote)) { vote--; }
2500          if (*vote == '/') {
2501            NOpp = atoi(vote+1);  *vote=0;  vote--;
2502            while(TCh::IsNum(*vote)) { vote--; }
2503            if (*vote == '(') { NSup = atoi(vote+1); } }
2504      } }/&bsol;*/
2505    }
2506    TChA Usr;  TSecTm Tm;  int Indent;
2507    for (; l < LineV.Len(); l++) {
2508      if(GetUsrTm(LineV[l], Usr, Tm, Indent)) {  goodVote++;
2509      if (UsrMapH.IsKey(Usr)) { Usr = UsrMapH.GetDat(Usr);  }
2510        WikiElec.VoteV.Add(TWikiVote(AddUsr(Usr), +1, Indent, GetWikiTxtLen(LineV[l]), Tm));
2511      }
2512      if (EndOfSection(LineV[l], "oppose")) { l++; break; }
2513    }
2514    for (; l < LineV.Len(); l++) {
2515      if(GetUsrTm(LineV[l], Usr, Tm, Indent)) {  goodVote++;
2516        if (UsrMapH.IsKey(Usr)) { Usr = UsrMapH.GetDat(Usr); }
2517        WikiElec.VoteV.Add(TWikiVote(AddUsr(Usr), -1, Indent, GetWikiTxtLen(LineV[l]), Tm));
2518      }
2519      if (EndOfSection(LineV[l], "neutral")) { l++; break; }
2520    }
2521    for (; l < LineV.Len(); l++) {
2522      if(GetUsrTm(LineV[l], Usr, Tm, Indent)) {  goodVote++;
2523        if (UsrMapH.IsKey(Usr)) { Usr = UsrMapH.GetDat(Usr); printf("u"); }
2524        WikiElec.VoteV.Add(TWikiVote(AddUsr(Usr), 0, Indent, GetWikiTxtLen(LineV[l]), Tm));
2525      }
2526      if (LineV[l][0]!='#' && (strstr(LineV[l], "'''comments")!=NULL || strstr(LineV[l], "'''no vote")!=NULL
2527        || strstr(LineV[l], "====")!=NULL || strstr(LineV[l], ";comments")!=NULL || strstr(LineV[l], "; comments")!=NULL ||
2528        strcmp(LineV[l],"comment")==0 || strcmp(LineV[l],"comments")==0)) { l++; break; }
2529    }
2530    const TIntTr SON = WikiElec.GetVotes(true);
2531    if (SON.Val1+SON.Val2+SON.Val3 > 100 && (SON.Val1==0 || SON.Val2==0)) {
2532    }
2533  }
2534  void TWikiElecBs::SetUserIdFromRfa() {
2535    THash<TChA, TChA> RfaUsrMapH;
2536    RfaUsrMapH.AddDat("White_Cat_(01)", "White_Cat");
2537    RfaUsrMapH.AddDat("White_Cat_(02)", "White_Cat");
2538    RfaUsrMapH.AddDat("White_Cat_(03)", "White_Cat");
2539    RfaUsrMapH.AddDat("White_Cat_(04)", "White_Cat");
2540    RfaUsrMapH.AddDat("Computerjoe_(4)", "Computerjoe");
2541    RfaUsrMapH.AddDat("Purplefeltangel2", "Purplefeltangel");
2542    RfaUsrMapH.AddDat("Haham_Hanuka_(3)", "Haham_Hanuka");
2543    RfaUsrMapH.AddDat("dbertman_(archive)", "dbertman");
2544    RfaUsrMapH.AddDat("Agentsoo_(archive)", "Agentsoo");
2545    RfaUsrMapH.AddDat("Guanaco3", "Guanaco");
2546    RfaUsrMapH.AddDat("Brendenhull2", "Brendenhull");
2547    RfaUsrMapH.AddDat("Xerocs2", "Xerocs");
2548    RfaUsrMapH.AddDat("Wikiwoohoo2", "Wikiwoohoo");
2549    RfaUsrMapH.AddDat("Folajimi2", "Folajimi");
2550    RfaUsrMapH.AddDat("FuriousFreddy_r1", "FuriousFreddy");
2551    RfaUsrMapH.AddDat("General_Eisenhower3", "General_Eisenhower");
2552    RfaUsrMapH.AddDat("HolyRomanEmperor2", "HolyRomanEmperor");
2553    RfaUsrMapH.AddDat("HolyRomanEmperor3", "HolyRomanEmperor");
2554    RfaUsrMapH.AddDat("HolyRomanEmperor3a", "HolyRomanEmperor");
2555    RfaUsrMapH.AddDat("Jet123_(2nd_nom)", "Jet123");
2556    RfaUsrMapH.AddDat("Natl1_(2nd_nom)", "Natl1");
2557    RfaUsrMapH.AddDat("NickCatal2", "NickCatal");
2558    RfaUsrMapH.AddDat("P.B._Pilhet_2nd_Nomination", "P.B._Pilhet");
2559    RfaUsrMapH.AddDat("Patchouli2", "Patchouli");
2560    RfaUsrMapH.AddDat("Patchouli3", "Patchouli");
2561    RfaUsrMapH.AddDat("The_Wookieepedian2", "The_Wookieepedian");
2562    RfaUsrMapH.AddDat("Son_of_a_Peach_II", "Son_of_a_Peach");
2563    RfaUsrMapH.AddDat("SVera1NY_(second_nomination)", "SVera1NY");
2564    RfaUsrMapH.AddDat("Tellyaddict2", "Tellyaddict");
2565    RfaUsrMapH.AddDat("Tenebrae2", "Tenebrae");
2566    RfaUsrMapH.AddDat("Poccil2", "Poccil");
2567    RfaUsrMapH.AddDat("Purplefeltangel2", "Purplefeltangel");
2568    RfaUsrMapH.AddDat("Ramsquire2", "Ramsquire");
2569    RfaUsrMapH.AddDat("ScienceApologist2", "ScienceApologist");
2570    RfaUsrMapH.AddDat("Jor2", "Jor");
2571    for (int e = 0; e < Len(); e++) {
2572      TWikiElec& E = GetElec(e);
2573      if (E.IsSucc()) { continue; }
2574      TChA Rfa = E.RfaTitle;
2575      const int l = Rfa.Len();
2576      TChA User;
2577      if (l>2 && Rfa[l-2]=='_' && TCh::IsNum(Rfa[l-1])) { User = Rfa.GetSubStr(0, l-3); } 
2578      else if (Rfa.IsSuffix(".08") || Rfa.IsSuffix(".09") || Rfa.IsSuffix(".10")) { User = Rfa.GetSubStr(0, l-4); }
2579      else if (Rfa.IsSuffix("_(renomination)")) { User = Rfa.GetSubStr(0, l-(int)strlen("_(renomination)")-1); }
2580      else if (Rfa.IsSuffix("_(2)")) { User = Rfa.GetSubStr(0, l-5); }
2581      else if (Rfa.IsSuffix("_(2nd)")) { User = Rfa.GetSubStr(0, l-7); }
2582      else if (Rfa.IsSuffix("_(2nd_nomination)")) { User = Rfa.GetSubStr(0, l-(int)strlen("_(2nd_nomination)")-1); }
2583      else if (RfaUsrMapH.IsKey(Rfa)) { User = RfaUsrMapH.GetDat(Rfa); }
2584      else { continue; }
2585      User.ToLc();
2586      printf("%20s\t->\t%s\n", Rfa.CStr(), User.CStr());
2587      E.UsrId = AddUsr(User.CStr());
2588    }
2589  }
2590  void TWikiElecBs::Dump() const {
2591    int v=0, Sup=0, Opp=0, Neu=0;
2592    int VSup=0, VOpp=0, VNeu=0;
2593    for (int e=0; e< Len(); e++) {
2594      v += GetElec(e).Len();
2595      TIntTr Votes = GetElec(e).GetVotes(false);
2596      Sup += Votes.Val1;  Neu += Votes.Val2;  Opp += Votes.Val3;
2597      Votes = GetElec(e).GetVotes(true);
<span onclick='openModal()' class='match'>2598      VSup += Votes.Val1;  VNeu += Votes.Val2;  VOpp += Votes.Val3;
2599    }
2600    printf("%5d users, %3d elections, %d all votes (%d/%d/%d)\n", UsrH.Len(), Len(), v, Sup, Opp, Neu);
2601    printf("                             %d all votes (%d/%d/%d)\n", VSup+VOpp+VNeu, VSup, VOpp, VNeu);
2602    TIntSet AdminSet, NAdminSet;
2603    TMom SupA, OppA, NeuA, SupNA, OppNA, NeuNA, ASupFrac, NASupFrac;
2604    TFltIntPrV AElecV, NAElecV;
2605    int nsucc=0;
2606    for (int e = 0; e < Len(); e++) {
</span>2607      const TWikiElec& E = GetElec(e);
2608      const TIntTr V = E.GetVotes(true);
2609      double SupFrac = V.Val1+V.Val3>0 ? V.Val1/double(V.Val1+V.Val3) : 0;
2610      if (V.Val1+V.Val3 == 0) { continue; }
2611      if (E.IsSucc) {
2612        AdminSet.AddKey(E.UsrId);
2613        SupA.Add(V.Val1());  NeuA.Add(V.Val2());  OppA.Add(V.Val3());
2614        AElecV.Add(TFltIntPr(SupFrac, e));
2615        ASupFrac.Add(SupFrac);
2616        nsucc++;
2617      } else {
2618        NAdminSet.AddKey(E.UsrId());
2619        SupNA.Add(V.Val1());  NeuNA.Add(V.Val2());  OppNA.Add(V.Val3());
2620        NAElecV.Add(TFltIntPr(SupFrac, e));
2621        NASupFrac.Add(SupFrac);
2622      }
2623    }
2624    printf("succ elecs %d\n", nsucc);
2625    SupA.Def(); OppA.Def(); NeuA.Def(); SupNA.Def(); OppNA.Def(); NeuNA.Def();
2626    ASupFrac.Def();  NASupFrac.Def();
2627    printf("succ elecs vs. failed elecs: %d admins. Votes:\n", AdminSet.Len());
2628    printf("  sup: %.1f : %.1f\n", SupA.GetMean(), SupNA.GetMean());
2629    printf("  neu:  %.1f : %.1f\n", NeuA.GetMean(), NeuNA.GetMean());
2630    printf("  fail: %.1f : %.1f\n", OppA.GetMean(), OppNA.GetMean());
2631    printf("  support fraction: %f : %f\n", ASupFrac.GetMean(), NASupFrac.GetMean());
2632    TInt ASup, AOpp, NASup, NAOpp, OSup, OOpp, AllSup, AllOpp; 
2633    TInt AEl, NAEl, OEl;
2634    TIntPrV TmV;
2635    for (int e = 0; e < Len(); e++) {
2636      const TWikiElec& E = GetElec(e);
2637      TWikiElec NewElec;  E.GetOnlyVotes(NewElec, true);
2638      bool IsA=false, IsNA=false, IsO=false;
2639      TmV.Add(TIntPr(E.GetTm().GetAbsSecs(), e));
2640      for (int v = 0; v < NewElec.Len(); v++) {
2641        const int vote = NewElec[v].GetVote();
2642        const int uid = NewElec[v].GetUId();
2643        if (AdminSet.IsKey(uid)) {
2644          if (vote == 1) { ASup++; } else { AOpp++; }
2645          IsA=true; }
2646        else if (NAdminSet.IsKey(uid)) {
2647          if (vote == 1) { NASup++; } else { NAOpp++; }
2648          IsNA=true; }
2649        else {
2650          if (vote == 1) { OSup++; } else { OOpp++; }
2651          IsO=true; }
2652        if (vote == 1) { AllSup++; }
2653        if (vote == -1) { AllOpp++; }
2654      }
2655      if (IsA) { AEl++; }
2656      if (IsNA) { NAEl++; }
2657      if (IsO) { OEl++; }
2658    }
2659    TmV.Sort();
2660    printf("elections from:\t%s\n\t%s\n", TSecTm(TmV[0].Val1()).GetStr().CStr(), TSecTm(TmV.Last().Val1()).GetStr().CStr());
2661    for (int i = 0; i <100; i++) { printf("%d\n", TmV[i].Val2); }
2662    for (int i = TmV.Len()-100; i <TmV.Len(); i++) { printf("%d\n", TmV[i].Val2); }
2663    TIntV UsrV; GetUsrV(UsrV);
2664    printf("voters: %d\n", UsrV.Len());
2665    printf("votes by:\n");
2666    printf("  all:         %5d : %5d = %f    elecs: %d    users: %d\n", AllSup, AllOpp, AllSup/double(AllSup+AllOpp), Len(), UsrV.Len());
2667    printf("  admins:      %5d : %5d = %f    elecs: %d    users: %d\n", ASup, AOpp, ASup/double(ASup+AOpp), AEl, AdminSet.Len());
2668    printf("  non-admins:  %5d : %5d = %f    elecs: %d    users: %d\n", NASup, NAOpp, NASup/double(NASup+NAOpp), NAEl, NAdminSet.Len());
2669    printf("  others:      %5d : %5d = %f    elecs: %d    users: %d\n\n", OSup, OOpp, OSup/double(OSup+OOpp), OEl, UsrH.Len()-AdminSet.Len()-NAdminSet.Len());
2670  }
2671  void TWikiElecBs::SaveElecUserVotes(const TStr& OutFNm) const {
2672    TIntSet USet;
2673    for (int e = 0; e < Len(); e++) {
2674      const TWikiElec& E = GetElec(e);
2675      if (E.Len() < 10) { continue; }
2676      for (int v = 0; v < E.Len(); v++) {
2677        USet.AddKey(E[v].GetUId()); }
2678    }
2679    FILE *F = fopen(OutFNm.CStr(), "wt");
2680    fprintf(F, "IsSucc");
2681    for (int u = 0; u < USet.Len(); u++) {
2682      fprintf(F, "\tu%d", USet[u]);
2683    }
2684    fprintf(F, "\n");
2685    for (int e = 0; e < Len(); e++) {
2686      const TWikiElec& E = GetElec(e);
2687      if (E.Len() < 10) { continue; }
2688      TIntSet Voters;
2689      for (int v = 0; v < E.Len(); v++) {
2690        Voters.AddKey(E[v].GetUId()); }
2691      fprintf(F, "%d", E.IsSucc?1:0);
2692      for (int u = 0; u < USet.Len(); u++) {
2693        if (Voters.IsKey(USet[u])) { fprintf(F, "\t1"); }
2694        else { fprintf(F, "\t0"); }
2695      }
2696      fprintf(F, "\n");
2697    }
2698    fclose(F);
2699  }
2700  void TWikiElecBs::SaveTxt(const TStr& OutFNm) {
2701    SortVotesByTm();
2702    FILE *F = fopen(OutFNm.CStr(), "wt");
2703    fprintf(F, "# Wikipedia elections (http:&bsol;&bsol;cs.stanford.edu/people/jure/pubs/triads-chi10.pdf). Data format:\n");
2704    fprintf(F, "#   E: is election succesful (1) or not (0)\n");
2705    fprintf(F, "#   T: time election was closed\n");
2706    fprintf(F, "#   U: user id (and username) of editor that is being considered for promotion\n");
2707    fprintf(F, "#   N: user id (and username) of the nominator\n");
2708    fprintf(F, "#   V: <vote(1:support, 0:neutral, -1:oppose)> <user_id> <time> <username>\n");
2709    for (int e = 0; e < Len(); e++) {
2710      const TWikiElec& E = GetElec(e);
2711      fprintf(F, "E\t%d\n", E.IsSucc?1:0);
2712      fprintf(F, "T\t%s\n", E.ElecTm.GetYmdTmStr().CStr());
2713      fprintf(F, "U\t%d\t%s\n", E.UsrId, GetUsr(E.UsrId));
2714      fprintf(F, "N\t%d\t%s\n", E.NomUId, E.NomUId==-1?"UNKNOWN":GetUsr(E.NomUId));
2715      for (int v = 0; v < E.Len(); v++) {
2716        if (! E[v].IsVote()) { continue; }
2717        fprintf(F, "V\t%d\t%d\t%s\t%s\n", E[v].GetVote(), E[v].GetUId(), E[v].GetTm().GetYmdTmStr().CStr(), GetUsr(E[v].GetUId()));
2718      }
2719      fprintf(F, "\n");
2720    }
2721    fclose(F);
2722  }
2723  void TWikiElecBs::SaveOnlyVotes() {
2724    TWikiElecBs NewElBs;
2725    GetOnlyVoteElecBs(NewElBs, true);
2726    NewElBs.SortVotesByTm();
2727    TStrSet RfaSet;
2728    for (int e = 0; e < NewElBs.Len(); e++) {
2729      TWikiElec& E = NewElBs.GetElec(e);
2730      if (RfaSet.IsKey(E.RfaTitle)) {
2731        for (int i = 2; ; i++) {
2732          TStr NewRfa = TStr::Fmt("%s_%d", E.RfaTitle.CStr(), i);
2733          if (! RfaSet.IsKey(NewRfa)) {
2734            printf("  %s --> %s\n", E.RfaTitle.CStr(), NewRfa.CStr());
2735            E.RfaTitle= NewRfa;
2736            break;
2737          }
2738        }
2739      }
2740      RfaSet.AddKey(E.RfaTitle);
2741    }
2742    NewElBs.Save(TZipOut("wikiElec-Votes.ElecBs3.rar"));
2743  }
2744  bool TWikiElecBs::GetUsrTm(char* LineStr, TChA& Usr, TSecTm& Tm, int& Indent) {
2745    TChA TmpLine=LineStr;
2746    TChA SearchStr = "[[user:";
2747    char *UsrId = NULL;
2748    for (char *next=LineStr; next=strstr(next, SearchStr.CStr()); ) {
2749      UsrId=next; next++; }
2750    if (UsrId == NULL) {
2751      SearchStr = "[[user talk:";
2752      for (char *next=LineStr; next=strstr(next, SearchStr.CStr()); ) {
2753        UsrId=next; next++; }
2754    }
2755    if (UsrId == NULL) {
2756      SearchStr = "[[user_talk:";
2757      for (char *next=LineStr; next=strstr(next, SearchStr.CStr()); ) {
2758        UsrId=next; next++; }
2759    }
2760    if (UsrId == NULL) {
2761      return false;
2762    }
2763    UsrId += SearchStr.Len();
2764    while (*UsrId && TCh::IsWs(*UsrId)) { UsrId++; }
2765    char *c = UsrId;
2766    while (*c && *c!='|' && *c!=']' && *c!='/' && *c!='#' && *c!=' ' && *c!='&') {
2767      if (*c==' ') { *c='_'; }
2768      c++;
2769    }
2770    *c = 0; c++;
2771    Usr = UsrId;  Usr.ToLc();
2772    char *utc = strstr(c, " (utc)");
2773    if (utc == NULL) { return false; }
2774    while (strstr(utc+1, "(utc)")!=NULL) { utc = strstr(utc+1, "(utc)"); }
2775    *utc = 0; utc--;
2776    int FldCnt=0;
2777    char *e = utc;
2778    while (e>c && (*e==' ' || *e=='-' || *e==',')) { e--; }
2779    while(e>c) {
2780      while (e>c && ! (*e==' ' || *e=='-' || *e==',')) { e--; }
2781      if (++FldCnt==4) { break; }
2782      while (e>c && (*e==' ' || *e=='-' || *e==',')) { e--; }
2783    }
2784    e += 1;
2785    if (! TStrUtil::GetTmFromStr(e, Tm)) {
2786      return false; }
2787    Indent=0;
2788    for (char *ch=LineStr; *ch && ! TCh::IsAlNum(*ch); ch++) {
2789      if (*ch == ':' || *ch == '*') { Indent++; }
2790    }
2791    return true;
2792  }
2793  TWikiMetaLoader::TWikiMetaLoader(const TStr& InFNm) {
2794    if (TZipIn::IsZipExt(InFNm.GetFExt())) { SInPt = TZipIn::New(InFNm); }
2795    else if (! InFNm.Empty()) { SInPt = TFIn::New(InFNm); }
2796    else { SInPt = TStdIn::New(); } 
2797  }
2798  bool TWikiMetaLoader::IsIpAddrUsr() const {
2799    return IsIpAddr(Usr);
2800  }
2801  bool TWikiMetaLoader::Next() {
2802    TSIn& SIn = *SInPt;
2803    static TChA LnStr;
2804    for (int rec=0; SIn.GetNextLn(LnStr); rec++) {
2805      if (! LnStr.IsPrefix("REVISION ")) {
2806        continue;
2807      }
2808      TChA Tmp = LnStr;
2809      TVec<char *> FldV; TStrUtil::SplitWords(Tmp, FldV);
2810      if (FldV.Len() != 7) {
2811        continue;
2812      }
2813      IAssert(FldV.Len() == 7);
2814      ArticleId = atoi(FldV[1]);
2815      RevisionId = atoi(FldV[2]);
2816      Title = FldV[3];
2817      RevTm = TSecTm::GetDtTmFromStr(FldV[4]);
2818      Usr = FldV[5];  Usr.ToLc();  Usr.ChangeCh(' ', '_');  
2819      UsrId = atoi(FldV[6]);
2820      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("CATEGORY"));
2821      CatStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2822      IAssert(SIn.GetNextLn(LnStr)); IAssert(LnStr.IsPrefix("IMAGE"));
2823      ImgStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2824      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("MAIN"));
2825      MainLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2826      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("TALK"));
2827      TalkLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2828      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("USER"));
2829      UserLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2830      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("USER_TALK"));
2831      UserTalkLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2832      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("OTHER"));
2833      OtherLStr =  LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2834      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("EXTERNAL"));
2835      ExternalLStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2836      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("TEMPLATE"));
2837      TemplateStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2838      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("COMMENT"));
2839      CommentStr = LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx);
2840      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("MINOR"));
2841      MonorEdit = LnStr[LnStr.SearchCh(' ')+1] == '1';
2842      IAssert(SIn.GetNextLn(LnStr));  IAssert(LnStr.IsPrefix("TEXTDATA"));
2843      RevWrds = atoi(LnStr.GetSubStr(LnStr.SearchCh(' ')+1, TInt::Mx).CStr());
2844      return true;
2845    }
2846    return false;
2847  }
2848  bool TWikiMetaLoader::IsIpAddr(const TChA& Usr) {
2849    if (Usr.IsPrefix("ip:")) { return true; }
2850    int i = 0, Len=Usr.Len();
2851    while (i<Len && TCh::IsNum(Usr[i])) { i++; }
2852    if (! (i<Len && Usr[i]=='.')) { return false; }
2853    i++;
2854    while (i<Len && TCh::IsNum(Usr[i])) { i++; }
2855    if (! (i<Len && Usr[i]=='.')) { return false; }
2856    i++;
2857    while (i<Len && TCh::IsNum(Usr[i])) { i++; }
2858    if (i==Len) { return true; }
2859    return false;
2860  }
2861  TWikiMetaHist::TWikiMetaHist(const TStr& InFNm) : SInPt(TZipIn::IsZipFNm(InFNm) ? TZipIn::New(InFNm) : TFIn::New(InFNm)), XmlInPt(TXmlParser::New(SInPt)), PageCnt(0) {
2862    printf("Init from %s\n skip till <page>...", InFNm.CStr());
2863    XmlInPt->SkipTillTag("page");
2864    printf("done\n");
2865  }
2866  TWikiMetaHist::TWikiMetaHist(const PSIn& SIn) : SInPt(SIn), XmlInPt() {
2867  }
2868  void TWikiMetaHist::Save(TSOut& SOut) const {
2869    SOut.Save(PageId);
2870    SOut.Save(RevId);
2871    SOut.Save(UsrId);
2872    RevTm.Save(SOut);
2873    Usr.Save(SOut);
2874    Cmt.Save(SOut);
2875    Title.Save(SOut);
2876    Text.Save(SOut);
2877  }
2878  void TWikiMetaHist::Clr() {
2879    PageId = RevId = UsrId = -1;
2880    RevTm = TSecTm();
2881    Usr.Clr();  Cmt.Clr();
2882    Title.Clr();  Text.Clr();  Tmp.Clr();
2883  }
2884  bool TWikiMetaHist::LoadNextBin() {
2885    TSIn& SIn = *SInPt;
2886    if (SIn.Eof()) { Clr(); return false; }
2887    SIn.Load(PageId);
2888    SIn.Load(RevId);
2889    SIn.Load(UsrId);
2890    RevTm.Load(SIn);
2891    Usr.Load(SIn);
2892    Cmt.Load(SIn);
2893    Title.Load(SIn);
2894    Text.Load(SIn);
2895    for (int i = 0; i < Usr.Len(); i++) {
2896      if (Usr[i]==' ') { Usr[i]='_'; }
2897    }
2898    for (int i = 0; i < Title.Len(); i++) {
2899      if (Title[i]==' ') { Title[i]='_'; }
2900    }
2901    return true;
2902  }
2903  bool TWikiMetaHist::LoadNextTxt() {
2904    IAssert(! XmlInPt.Empty());
2905    TXmlParser& XmlIn = *XmlInPt;
2906    while (! (XmlIn.Sym == xsySTag && (XmlIn.SymStr == "page" || XmlIn.SymStr == "revision"))) {
2907      XmlIn.GetSym();
2908      if (XmlIn.Sym == xsyEof) { return false; }
2909    }
2910    if (XmlIn.SymStr == "page") {
2911      XmlIn.GetTagVal("title", Title);
2912      XmlIn.GetTagVal("id", Tmp);
2913      PageId = atoi(Tmp.CStr());
2914      XmlIn.GetSym();
2915      if (XmlIn.SymStr != "revision") {
2916        while (XmlIn.SymStr != "revision") { printf("NEW_TAG:  %s\n", XmlIn.SymStr.CStr()); XmlIn.GetSym(); }
2917      }
2918    }
2919    EAssertR(XmlIn.SymStr == "revision", XmlIn.SymStr); 
2920    XmlIn.GetTagVal("id", Tmp);
2921    RevId = atoi(Tmp.CStr());          
2922    XmlIn.GetTagVal("timestamp", Tmp); 
2923    Tmp[4]=0; Tmp[7]=0; Tmp[10]=0; Tmp[13]=0; Tmp[16]=0; Tmp[19]=0;
2924    RevTm = TSecTm(atoi(Tmp.CStr()), atoi(Tmp.CStr()+5), atoi(Tmp.CStr()+8),
2925      atoi(Tmp.CStr()+11), atoi(Tmp.CStr()+14), atoi(Tmp.CStr()+17));
2926    EAssert(XmlIn.GetTag("contributor") == xsySTag);
2927    XmlIn.GetSym();
2928    if (XmlIn.SymStr == "ip" && XmlIn.Sym==xsySTag) {
2929      XmlIn.GetSym();  Usr="ip:"; Usr+=XmlIn.SymStr;
2930      XmlIn.GetTag("ip");  IAssert(! XmlIn.SymStr.IsPrefix("ip:")); }
2931    else if (XmlIn.SymStr == "username") {
2932      if (XmlIn.Sym == xsySTag) { XmlIn.GetSym(); Usr=XmlIn.SymStr;  EAssert(XmlIn.GetTag("username") == xsyETag); } 
2933      else { EAssert(XmlIn.Sym == xsyETag && XmlIn.SymStr == "username"); } 
2934      XmlIn.GetTagVal("id", Tmp);  UsrId = atoi(Tmp.CStr());
2935    }
2936    for (int i = 0; i < Usr.Len(); i++) {
2937      if (Usr[i]==' ') { Usr[i]='_'; }
2938    }
2939    EAssert(XmlIn.GetTag("contributor") == xsyETag);
2940    XmlIn.GetSym();
2941    if (XmlIn.Sym == xsyETag && XmlIn.SymStr == "minor") { XmlIn.GetSym(); }
2942    if (XmlIn.Sym == xsySTag && XmlIn.SymStr == "comment") {
2943      XmlIn.GetSym();
2944      if (XmlIn.Sym == xsyStr) { Cmt=XmlIn.SymStr;  EAssert(XmlIn.GetTag("comment") == xsyETag); } 
2945      else { EAssert(XmlIn.Sym == xsyETag && XmlIn.SymStr == "comment"); } 
2946      XmlIn.GetSym();
2947    }
2948    EAssertR(XmlIn.SymStr.IsPrefix("text"), XmlIn.SymStr);
2949    if (XmlIn.Sym == xsySTag) {
2950      XmlIn.GetSym(Text);
2951      if (XmlIn.Sym == xsyStr) { EAssert(XmlIn.GetTag("text") == xsyETag); } 
2952      else { EAssert(XmlIn.Sym == xsyETag && XmlIn.SymStr == "text"); } 
2953    }
2954    EAssert(XmlIn.GetTag("revision") == xsyETag);
2955    if (++PageCnt % 10000 == 0) {
2956      printf("** %dk items: %s time %f\n", PageCnt/1000, ExeTm.GetStr(), ExeTm.GetSecs()); fflush(stdout); }
2957    return true;
2958  }
2959  void TWikiMetaHist::Dump(const bool& AlsoText) const {
2960    printf("page: %d %s\n", PageId, Title.CStr());
2961    printf("rev:  %d %s\n", RevId, RevTm.GetYmdTmStr().CStr());
2962    printf("user: %d %s\n", UsrId, Usr.CStr());
2963    printf("cmt:  %s\n", Cmt.CStr());
2964    if (AlsoText) { printf("text:\n%s\n", Text.CStr()); }
2965    printf("\n");
2966  }
2967  void TWikiMetaHist::DumpNextXmlTags(const int& DumpN) {
2968    TXmlParser& XmlIn = *XmlInPt;
2969    for (int i = 0; i < DumpN; i++) {
2970      printf("%s\n", XmlIn.SymStr.CStr());
2971      XmlIn.GetSym();
2972      if (XmlIn.Sym == xsyEof) { return; }
2973    }
2974  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-centr.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wikinet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>397        TmpV[j] =  C*Tmp; 
398      }
399      double sum = 0;
400      #pragma omp parallel for reduction(+:sum) schedule(dynamic,10000)
401      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
</pre></code></div>
                <div class="column column_space"><pre><code>2598      VSup += Votes.Val1;  VNeu += Votes.Val2;  VOpp += Votes.Val3;
2599    }
2600    printf("%5d users, %3d elections, %d all votes (%d/%d/%d)\n", UsrH.Len(), Len(), v, Sup, Opp, Neu);
2601    printf("                             %d all votes (%d/%d/%d)\n", VSup+VOpp+VNeu, VSup, VOpp, VNeu);
2602    TIntSet AdminSet, NAdminSet;
2603    TMom SupA, OppA, NeuA, SupNA, OppNA, NeuNA, ASupFrac, NASupFrac;
2604    TFltIntPrV AElecV, NAElecV;
2605    int nsucc=0;
2606    for (int e = 0; e < Len(); e++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    