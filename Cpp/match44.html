<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for box3.hpp &amp; vec3.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for box3.hpp &amp; vec3.hpp
      </h3>
<h1 align="center">
        10.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>box3.hpp (10.204082%)<th>vec3.hpp (11.406844%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(302-315)<td><a href="#" name="0">(216-227)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(59-76)<td><a href="#" name="1">(80-97)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>box3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include &lt;gtl/gtl.hpp&gt;
3 #include &lt;gtl/matrix4.hpp&gt;
4 #include &lt;gtl/plane.hpp&gt;
5 #include &lt;gtl/ray.hpp&gt;
6 #include &lt;gtl/vec3.hpp&gt;
7 namespace gtl {
8     template &lt;typename Type&gt;
9     class plane;
10     template &lt;typename Type&gt;
11     class ray;
12     template &lt;typename Type&gt;
13     class box3 {
14     public:
15         box3()
16         {
17             makeEmpty();
18         }
19         box3(const vec3&lt;Type&gt;&amp; a_min, const vec3&lt;Type&gt;&amp; a_max)
20             : m_min(a_min)
21             , m_max(a_max)
22         {
23         }
24         void setBounds(const vec3&lt;Type&gt;&amp; a_min, const vec3&lt;Type&gt;&amp; a_max)
25         {
26             m_min = a_min;
27             m_max = a_max;
28         }
29         bool isEmpty() const
30         {
31             return (m_max[0] &lt; m_min[0] || m_max[1] &lt; m_min[1] || m_max[2] &lt; m_min[2]);
32         }
33         void makeEmpty()
34 <a name="1"></a>        {
35             m_min = vec3&lt;Type&gt;::max();
36             m_max = -vec3&lt;Type&gt;::max();
37 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        }
38         const vec3&lt;Type&gt;&amp; getMin() const
39         {
40             return m_min;
41         }
42         const vec3&lt;Type&gt;&amp; getMax() const
43         {
44             return m_max;
45         }
46         vec3&lt;Type&gt; getSize() const
47         {
48             return m_max - m_min;</b></font>
49         }
50         vec3&lt;Type&gt; getCenter() const
51         {
52             return vec3&lt;Type&gt;((m_max[0] + m_min[0]) * 0.5f,
53                               (m_max[1] + m_min[1]) * 0.5f,
54                               (m_max[2] + m_min[2]) * 0.5f);
55         }
56         void extendBy(const vec3&lt;Type&gt;&amp; a_point)
57         {
58             if (isEmpty()) {
59                 setBounds(a_point, a_point);
60             } else {
61                 if (a_point[0] &lt; m_min[0])
62                     m_min[0] = a_point[0];
63                 if (a_point[1] &lt; m_min[1])
64                     m_min[1] = a_point[1];
65                 if (a_point[2] &lt; m_min[2])
66                     m_min[2] = a_point[2];
67                 if (a_point[0] &gt; m_max[0])
68                     m_max[0] = a_point[0];
69                 if (a_point[1] &gt; m_max[1])
70                     m_max[1] = a_point[1];
71                 if (a_point[2] &gt; m_max[2])
72                     m_max[2] = a_point[2];
73             }
74         }
75         void extendBy(const box3&lt;Type&gt;&amp; a_box)
76         {
77             if (isEmpty()) {
78                 *this = a_box;
79             } else {
80                 extendBy(a_box.getMin());
81                 extendBy(a_box.getMax());
82             }
83         }
84         Type getVolume() const
85         {
86             if (isEmpty())
87                 return 0.0;
88             return (m_max[0] - m_min[0]) * (m_max[1] - m_min[1]) * (m_max[2] - m_min[2]);
89         }
90         void transform(const matrix4&lt;Type&gt;&amp; m)
91         {
92             if (isEmpty())
93                 return;
94             vec3&lt;Type&gt; corners[8];
95             corners[0] = m_min;
96             corners[1][0] = m_min[0];
97             corners[1][1] = m_max[1];
98             corners[1][2] = m_min[2];
99             corners[2][0] = m_max[0];
100             corners[2][1] = m_max[1];
101             corners[2][2] = m_min[2];
102             corners[3][0] = m_max[0];
103             corners[3][1] = m_min[1];
104             corners[3][2] = m_min[2];
105             corners[4] = m_max;
106             corners[5][0] = m_min[0];
107             corners[5][1] = m_max[1];
108             corners[5][2] = m_max[2];
109             corners[6][0] = m_min[0];
110             corners[6][1] = m_min[1];
111             corners[6][2] = m_max[2];
112             corners[7][0] = m_max[0];
113             corners[7][1] = m_min[1];
114             corners[7][2] = m_max[2];
115             box3&lt;Type&gt; newbox;
116             for (int i = 0; i &lt; 8; ++i) {
117                 m.multVecMatrix(corners[i], corners[i]);
118                 newbox.extendBy(corners[i]);
119             }
120             setBounds(newbox.m_min, newbox.m_max);
121         }
122         bool intersect(const vec3&lt;Type&gt;&amp; a_point) const
123         {
124             return !(a_point[0] &lt; m_min[0] || a_point[0] &gt; m_max[0] || a_point[1] &lt; m_min[1] || a_point[1] &gt; m_max[1] || a_point[2] &lt; m_min[2] || a_point[2] &gt; m_max[2]);
125         }
126         bool intersect(const box3&lt;Type&gt;&amp; a_box) const
127         {
128             if ((m_max[0] &lt; a_box.m_min[0]) || (m_min[0] &gt; a_box.m_max[0]) || (m_max[1] &lt; a_box.m_min[1]) || (m_min[1] &gt; a_box.m_max[1]) || (m_max[2] &lt; a_box.m_min[2]) || (m_min[2] &gt; a_box.m_max[2])) {
129                 return false;
130             }
131             return true;
132         }
133         bool intersect(const ray&lt;Type&gt;&amp; a_ray, Type&amp; tmin, Type&amp; tmax) const
134         {
135             if (isEmpty())
136                 return false;
137             const vec3&lt;Type&gt; inv_direction(1 / a_ray.getDirection()[0], 1 / a_ray.getDirection()[1], 1 / a_ray.getDirection()[2]);
138             const vec3&lt;int&gt; sign(inv_direction[0] &lt; 0, inv_direction[1] &lt; 0, inv_direction[2] &lt; 0);
139             tmin = ((sign[0] ? m_max : m_min).x - a_ray.getOrigin().x) * inv_direction.x;
140             tmax = (((1 - sign[0]) ? m_max : m_min).x - a_ray.getOrigin().x) * inv_direction.x;
141             const Type tymin = ((sign[1] ? m_max : m_min).y - a_ray.getOrigin().y) * inv_direction.y;
142             const Type tymax = (((1 - sign[1]) ? m_max : m_min).y - a_ray.getOrigin().y) * inv_direction.y;
143             if ((tmin &gt; tymax) || (tymin &gt; tmax))
144                 return false;
145             if (tymin &gt; tmin)
146                 tmin = tymin;
147             if (tymax &lt; tmax)
148                 tmax = tymax;
149             const Type tzmin = ((sign[2] ? m_max : m_min).z - a_ray.getOrigin().z) * inv_direction.z;
150             const Type tzmax = (((1 - sign[2]) ? m_max : m_min).z - a_ray.getOrigin().z) * inv_direction.z;
151             if ((tmin &gt; tzmax) || (tzmin &gt; tmax))
152                 return false;
153             if (tzmin &gt; tmin)
154                 tmin = tzmin;
155             if (tzmax &lt; tmax)
156                 tmax = tzmax;
157             return (tmin &gt;= 0 &amp;&amp; tmax &gt;= 1);
158         }
159         bool intersect(const plane&lt;Type&gt;&amp; a_plane) const
160         {
161             if (isEmpty())
162                 return false;
163             const vec3&lt;Type&gt;&amp; pnorm = a_plane.getNormal();
164             const vec3&lt;Type&gt; vmin(pnorm[0] &gt; 0.0 ? m_min[0] : m_max[0],
165                                   pnorm[1] &gt; 0.0 ? m_min[1] : m_max[1],
166                                   pnorm[2] &gt; 0.0 ? m_min[2] : m_max[2]);
167             if (a_plane.isInHalfSpace(vmin))
168                 return false;
169             const vec3&lt;Type&gt; vmax(pnorm[0] &gt; 0.0 ? m_max[0] : m_min[0],
170                                   pnorm[1] &gt; 0.0 ? m_max[1] : m_min[1],
171                                   pnorm[2] &gt; 0.0 ? m_max[2] : m_min[2]);
172             if (a_plane.isInHalfSpace(vmax))
173                 return true;
174             return false;
175         }
176         bool intersect(const vec3&lt;Type&gt;&amp; a_p0, const vec3&lt;Type&gt;&amp; a_p1, const vec3&lt;Type&gt;&amp; a_p2) const
177         {
178             box3&lt;Type&gt; tribox;
179             tribox.extendBy(a_p0);
180             tribox.extendBy(a_p1);
181             tribox.extendBy(a_p2);
182             if (!this-&gt;intersect(tribox))
183                 return false;
184             const vec3&lt;Type&gt; boxcenter = this-&gt;getCenter();
185             const vec3&lt;Type&gt; v[3] = { a_p0 - boxcenter,
186                                       a_p1 - boxcenter,
187                                       a_p2 - boxcenter };
188             const vec3&lt;Type&gt; e[3] = { v[1] - v[0],
189                                       v[2] - v[1],
190                                       v[0] - v[2] };
191             const vec3&lt;Type&gt; normal = e[0].cross(e[1]);
192             if (!this-&gt;intersect(plane&lt;Type&gt;(normal, a_p0)))
193                 return false;
194             const vec3&lt;Type&gt; boxhalfsize = this-&gt;getSize() * 0.5f;
195             const Type f[3][3] = { { 1.0f, 0.0f, 0.0f },
196                                    { 0.0f, 1.0f, 0.0f },
197                                    { 0.0f, 0.0f, 1.0f } };
198             for (int i = 0; i &lt; 3; i++) {
199                 for (int j = 0; j &lt; 3; j++) {
200                     const vec3&lt;Type&gt; a = e[i].cross(f[j]);
201                     const float p0 = a.dot(v[0]);
202                     const float p1 = a.dot(v[1]);
203                     const float p2 = a.dot(v[2]);
204                     const float min = min3(p0, p1, p2);
205                     const float max = max3(p0, p1, p2);
206                     float radius = std::abs(a[0]) * boxhalfsize[0] + std::abs(a[1]) * boxhalfsize[1] + std::abs(a[2]) * boxhalfsize[2];
207                     if (min &gt; radius || max &lt; -radius)
208                         return false;
209 <a name="0"></a>                }
210             }
211 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            return true;
212         }
213         friend bool operator==(const box3&lt;Type&gt;&amp; b1, const box3&lt;Type&gt;&amp; b2)
214         {
215             return b1.getMin() == b2.getMin() &amp;&amp; b1.getMax() == b2.getMax();
216         }
217         friend bool operator!=(const box3&lt;Type&gt;&amp; b1, const box3&lt;Type&gt;&amp; b2)
218         {
219             return !(b1 == b2);
220         }</b></font>
221     private:
222         vec3&lt;Type&gt; m_min;
223         vec3&lt;Type&gt; m_max;
224     };
225     typedef box3&lt;int&gt; box3i;
226     typedef box3&lt;float&gt; box3f;
227     typedef box3&lt;double&gt; box3d;
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vec3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include &lt;gtl/gtl.hpp&gt;
3 namespace gtl {
4     template &lt;typename Type&gt;
5     struct vec3 {
6         union {
7             struct {
8                 Type x, y, z;
9             };
10             struct {
11                 Type r, g, b;
12             };
13             struct {
14                 Type u, v, w;
15             };
16             Type data[3];
17         };
18         vec3()
19             : x(0)
20             , y(0)
21             , z(0)
22         {
23         }
24         vec3(const Type v[3])
25             : x(v[0])
26             , y(v[1])
27             , z(v[2])
28         {
29         }
30         vec3(Type a_x, Type a_y, Type a_z)
31             : x(a_x)
32             , y(a_y)
33             , z(a_z)
34         {
35         }
36         vec3(const vec3&lt;Type&gt;&amp; a_vec)
37             : x(a_vec.x)
38             , y(a_vec.y)
39             , z(a_vec.z)
40         {
41         }
42         vec3&lt;Type&gt;&amp; setValue(const Type v[3])
43         {
44             x = v[0];
45             y = v[1];
46             z = v[2];
47             return *this;
48         }
49         vec3&lt;Type&gt;&amp; setValue(Type a_x, Type a_y, Type a_z)
50         {
51             x = a_x;
52             y = a_y;
53 <a name="1"></a>            z = a_z;
54             return *this;
55 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        }
56         const Type* getValue() const
57         {
58             return data;
59         }
60         Type dot(const vec3&lt;Type&gt;&amp; a_vec) const
61         {
62             return (x * a_vec.x + y * a_vec.y + z * a_vec.z);
63         }
64         Type length() const
65         {
66             return (Type)std::sqrt(x * x + y * y + z * z);</b></font>
67         }
68         Type sqrLength() const
69         {
70             return (x * x + y * y + z * z);
71         }
72         Type normalize()
73         {
74             const Type magnitude = length();
75             if (magnitude &gt; 0)
76                 *this /= magnitude;
77             return magnitude;
78         }
79         vec3&lt;Type&gt; normalized() const
80         {
81             vec3&lt;Type&gt; v(*this);
82             v.normalize();
83             return v;
84         }
85         vec3&lt;Type&gt; cross(const vec3&lt;Type&gt;&amp; a_vec) const
86         {
87             return vec3&lt;Type&gt;(y * a_vec.z - a_vec.y * z,
88                               z * a_vec.x - a_vec.z * x,
89                               x * a_vec.y - a_vec.x * y);
90         }
91         void negate()
92         {
93             x = -x;
94             y = -y;
95             z = -z;
96         }
97         vec3&lt;Type&gt; reflect(const vec3&lt;Type&gt;&amp; N) const
98         {
99             const vec3&lt;Type&gt;&amp; I(*this);
100             return I - 2 * N.dot(I) * N;
101         }
102         vec3&lt;Type&gt; refract(const vec3&lt;Type&gt;&amp; N, Type eta) const
103         {
104             const vec3&lt;Type&gt;&amp; I(*this);
105             const Type k = 1.0 - eta * eta * (1.0 - N.dot(I) * N.dot(I));
106             return (k &lt; 0.0) ? 0 : eta * I - (eta * N.dot(I) + std::sqrt(k)) * N;
107         }
108         Type&amp; operator[](int i) { return reinterpret_cast&lt;Type*&gt;(this)[i]; }
109         const Type&amp; operator[](int i) const { return reinterpret_cast&lt;const Type*&gt;(this)[i]; }
110         vec3&lt;Type&gt;&amp; operator*=(const Type d)
111         {
112             x *= d;
113             y *= d;
114             z *= d;
115             return *this;
116         }
117         vec3&lt;Type&gt;&amp; operator/=(const Type d)
118         {
119             *this *= (1.0f / d);
120             return *this;
121         }
122         vec3&lt;Type&gt;&amp; operator*=(const vec3&lt;Type&gt;&amp; a_vec)
123         {
124             x *= a_vec.x;
125             y *= a_vec.y;
126             z *= a_vec.z;
127             return *this;
128         }
129         vec3&lt;Type&gt;&amp; operator+=(const vec3&lt;Type&gt;&amp; a_vec)
130         {
131             x += a_vec.x;
132             y += a_vec.y;
133             z += a_vec.z;
134             return *this;
135         }
136         vec3&lt;Type&gt;&amp; operator-=(const vec3&lt;Type&gt;&amp; a_vec)
137         {
138             x -= a_vec.x;
139             y -= a_vec.y;
140             z -= a_vec.z;
141             return *this;
142         }
143 <a name="0"></a>        //! Non-destructive negation operator.
144         vec3&lt;Type&gt; operator-() const
145         {
146 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            return vec3&lt;Type&gt;(-x, -y, -z);
147         }
148         friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
149         {
150             return vec3&lt;Type&gt;(a_vec.x * d, a_vec.y * d, a_vec.z * d);
151         }
152         friend vec3&lt;Type&gt; operator*(const Type d, const vec3&lt;Type&gt;&amp; a_vec)
153         {
154             return a_vec * d;
155         }</b></font>
156         friend vec3&lt;Type&gt; operator/(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
157         {
158             return vec3&lt;Type&gt;(a_vec.x / d, a_vec.y / d, a_vec.z / d);
159         }
160         friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
161         {
162             return vec3&lt;Type&gt;(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
163         }
164         friend inline vec3&lt;Type&gt; operator+(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
165         {
166             return vec3&lt;Type&gt;(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
167         }
168         friend inline vec3&lt;Type&gt; operator-(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
169         {
170             return vec3&lt;Type&gt;(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
171         }
172         friend bool operator==(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
173         {
174             return (v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z);
175         }
176         friend bool operator!=(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
177         {
178             return !(v1 == v2);
179         }
180         bool equals(const vec3&lt;Type&gt;&amp; a_vec, const Type a_tolerance = 1E-2) const
181         {
182             return ((*this - a_vec).sqrLength() &lt;= a_tolerance * a_tolerance);
183         }
184         friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vec3&lt;Type&gt;&amp; vect)
185         {
186             return os &lt;&lt; vect.x &lt;&lt; " " &lt;&lt; vect.y &lt;&lt; " " &lt;&lt; vect.z;
187         }
188         static vec3&lt;Type&gt; max()
189         {
190             return vec3&lt;Type&gt;(std::numeric_limits&lt;Type&gt;::max(),
191                               std::numeric_limits&lt;Type&gt;::max(),
192                               std::numeric_limits&lt;Type&gt;::max());
193         }
194     };
195     typedef vec3&lt;int&gt; vec3i;
196     typedef vec3&lt;float&gt; vec3f;
197     typedef vec3&lt;double&gt; vec3d;
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
