<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for box3.hpp & vec3.hpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for box3.hpp & vec3.hpp
      </h3>
      <h1 align="center">
        10.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>box3.hpp (10.204082%)<TH>vec3.hpp (11.406844%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match44-0.html#0',2,'match44-1.html#0',3)" NAME="0">(302-315)<TD><A HREF="javascript:ZweiFrames('match44-0.html#0',2,'match44-1.html#0',3)" NAME="0">(216-227)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match44-0.html#1',2,'match44-1.html#1',3)" NAME="1">(59-76)<TD><A HREF="javascript:ZweiFrames('match44-0.html#1',2,'match44-1.html#1',3)" NAME="1">(80-97)</A><TD ALIGN=center><FONT COLOR="#df0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>box3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#pragma once

#include &lt;gtl/gtl.hpp&gt;
#include &lt;gtl/matrix4.hpp&gt;
#include &lt;gtl/plane.hpp&gt;
#include &lt;gtl/ray.hpp&gt;
#include &lt;gtl/vec3.hpp&gt;

namespace gtl {
    // forward declaration
    template &lt;typename Type&gt;
    class plane;
    template &lt;typename Type&gt;
    class ray;

    /*!
    \class box3 box3.hpp geometry/box3.hpp
    \brief Axis-Aligned 3D Bounding Box Class..
    \ingroup base

    This box class is used by many other classes.

    \sa xfbox3
    */
    template &lt;typename Type&gt;
    class box3 {
    public:
        //! The default constructor makes an empty box.
        box3()
        {
            makeEmpty();
        }

        //! Constructs a box with the given corners.
        box3(const vec3&lt;Type&gt;&amp; a_min, const vec3&lt;Type&gt;&amp; a_max)
            : m_min(a_min)
            , m_max(a_max)
        {
        }

        //! Reset the boundaries of the box with the given corners.
        void setBounds(const vec3&lt;Type&gt;&amp; a_min, const vec3&lt;Type&gt;&amp; a_max)
        {
            m_min = a_min;
            m_max = a_max;
        }

        //! Check if this has been marked as an empty box. \sa makeEmpty().
        bool isEmpty() const
        {
            return (m_max[0] &lt; m_min[0] || m_max[1] &lt; m_min[1] || m_max[2] &lt; m_min[2]);
        }

        //! Marks this as an empty box.	\sa isEmpty().
        void makeEmpty()
<A NAME="1"></A>        {
            m_min = vec3&lt;Type&gt;::max();
            m_max = -vec3&lt;Type&gt;::max();
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match44-1.html#1',3,'match44-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        }

        //! Returns the lower left corner of the box. \sa getCenter(), getMax().
        const vec3&lt;Type&gt;&amp; getMin() const
        {
            return m_min;
        }

        //! Returns the upper right corner of the box. \sa getMin().
        const vec3&lt;Type&gt;&amp; getMax() const
        {
            return m_max;
        }

        //! Returns width, height and depth of box.
        vec3&lt;Type&gt; getSize() const
        {
            return m_max - m_min;</B></FONT>
        }

        //! Returns the center point of the box.
        vec3&lt;Type&gt; getCenter() const
        {
            return vec3&lt;Type&gt;((m_max[0] + m_min[0]) * 0.5f,
                              (m_max[1] + m_min[1]) * 0.5f,
                              (m_max[2] + m_min[2]) * 0.5f);
        }

        //! Extend the boundaries of the box by the given point.
        void extendBy(const vec3&lt;Type&gt;&amp; a_point)
        {
            if (isEmpty()) {
                setBounds(a_point, a_point);
            } else {
                if (a_point[0] &lt; m_min[0])
                    m_min[0] = a_point[0];
                if (a_point[1] &lt; m_min[1])
                    m_min[1] = a_point[1];
                if (a_point[2] &lt; m_min[2])
                    m_min[2] = a_point[2];

                if (a_point[0] &gt; m_max[0])
                    m_max[0] = a_point[0];
                if (a_point[1] &gt; m_max[1])
                    m_max[1] = a_point[1];
                if (a_point[2] &gt; m_max[2])
                    m_max[2] = a_point[2];
            }
        }

        //! Extend the boundaries of the box by the given \a a_box parameter.
        void extendBy(const box3&lt;Type&gt;&amp; a_box)
        {
            if (isEmpty()) {
                *this = a_box;
            } else {
                extendBy(a_box.getMin());
                extendBy(a_box.getMax());
            }
        }

        //! Give the volume of the box (0 for an empty box)
        Type getVolume() const
        {
            if (isEmpty())
                return 0.0;

            return (m_max[0] - m_min[0]) * (m_max[1] - m_min[1]) * (m_max[2] - m_min[2]);
        }

        //! Transforms box3 by matrix, enlarging box3 to contain result.
        void transform(const matrix4&lt;Type&gt;&amp; m)
        {
            // a transformed empty box is still empty
            if (isEmpty())
                return;

            vec3&lt;Type&gt; corners[8];
            corners[0] = m_min;
            corners[1][0] = m_min[0];
            corners[1][1] = m_max[1];
            corners[1][2] = m_min[2];
            corners[2][0] = m_max[0];
            corners[2][1] = m_max[1];
            corners[2][2] = m_min[2];
            corners[3][0] = m_max[0];
            corners[3][1] = m_min[1];
            corners[3][2] = m_min[2];
            corners[4] = m_max;
            corners[5][0] = m_min[0];
            corners[5][1] = m_max[1];
            corners[5][2] = m_max[2];
            corners[6][0] = m_min[0];
            corners[6][1] = m_min[1];
            corners[6][2] = m_max[2];
            corners[7][0] = m_max[0];
            corners[7][1] = m_min[1];
            corners[7][2] = m_max[2];

            box3&lt;Type&gt; newbox;
            for (int i = 0; i &lt; 8; ++i) {
                m.multVecMatrix(corners[i], corners[i]);
                newbox.extendBy(corners[i]);
            }

            setBounds(newbox.m_min, newbox.m_max);
        }

        //! Check if \a a_point lies within the boundaries of this box.
        bool intersect(const vec3&lt;Type&gt;&amp; a_point) const
        {
            return !(a_point[0] &lt; m_min[0] || a_point[0] &gt; m_max[0] || a_point[1] &lt; m_min[1] || a_point[1] &gt; m_max[1] || a_point[2] &lt; m_min[2] || a_point[2] &gt; m_max[2]);
        }

        //! Check if the given box lies wholly or partly within the boundaries of this box.
        bool intersect(const box3&lt;Type&gt;&amp; a_box) const
        {
            if ((m_max[0] &lt; a_box.m_min[0]) || (m_min[0] &gt; a_box.m_max[0]) || (m_max[1] &lt; a_box.m_min[1]) || (m_min[1] &gt; a_box.m_max[1]) || (m_max[2] &lt; a_box.m_min[2]) || (m_min[2] &gt; a_box.m_max[2])) {
                return false;
            }
            return true;
        }

        //! Check if the given ray intersect the box.
        bool intersect(const ray&lt;Type&gt;&amp; a_ray, Type&amp; tmin, Type&amp; tmax) const
        {
            // Amy Williams, Steve Barrus, R. Keith Morley, and Peter Shirley
            // &quot;An Efficient and Robust ray-Box Intersection Algorithm&quot;
            //  Journal of graphics tools, 10(1):49-54, 2005
            if (isEmpty())
                return false;

            const vec3&lt;Type&gt; inv_direction(1 / a_ray.getDirection()[0], 1 / a_ray.getDirection()[1], 1 / a_ray.getDirection()[2]);

            const vec3&lt;int&gt; sign(inv_direction[0] &lt; 0, inv_direction[1] &lt; 0, inv_direction[2] &lt; 0);

            tmin = ((sign[0] ? m_max : m_min).x - a_ray.getOrigin().x) * inv_direction.x;
            tmax = (((1 - sign[0]) ? m_max : m_min).x - a_ray.getOrigin().x) * inv_direction.x;

            const Type tymin = ((sign[1] ? m_max : m_min).y - a_ray.getOrigin().y) * inv_direction.y;
            const Type tymax = (((1 - sign[1]) ? m_max : m_min).y - a_ray.getOrigin().y) * inv_direction.y;

            if ((tmin &gt; tymax) || (tymin &gt; tmax))
                return false;

            if (tymin &gt; tmin)
                tmin = tymin;
            if (tymax &lt; tmax)
                tmax = tymax;

            const Type tzmin = ((sign[2] ? m_max : m_min).z - a_ray.getOrigin().z) * inv_direction.z;
            const Type tzmax = (((1 - sign[2]) ? m_max : m_min).z - a_ray.getOrigin().z) * inv_direction.z;

            if ((tmin &gt; tzmax) || (tzmin &gt; tmax))
                return false;

            if (tzmin &gt; tmin)
                tmin = tzmin;
            if (tzmax &lt; tmax)
                tmax = tzmax;

            return (tmin &gt;= 0 &amp;&amp; tmax &gt;= 1);
        }

        //! Check if the given plane intersect the box.
        bool intersect(const plane&lt;Type&gt;&amp; a_plane) const
        {
            // Empty boxes can cause problems.
            if (isEmpty())
                return false;

            const vec3&lt;Type&gt;&amp; pnorm = a_plane.getNormal();

            // Use separating axis theorem to test overlap.
            const vec3&lt;Type&gt; vmin(pnorm[0] &gt; 0.0 ? m_min[0] : m_max[0],
                                  pnorm[1] &gt; 0.0 ? m_min[1] : m_max[1],
                                  pnorm[2] &gt; 0.0 ? m_min[2] : m_max[2]);
            if (a_plane.isInHalfSpace(vmin))
                return false;

            const vec3&lt;Type&gt; vmax(pnorm[0] &gt; 0.0 ? m_max[0] : m_min[0],
                                  pnorm[1] &gt; 0.0 ? m_max[1] : m_min[1],
                                  pnorm[2] &gt; 0.0 ? m_max[2] : m_min[2]);
            if (a_plane.isInHalfSpace(vmax))
                return true;

            return false;
        }

        //! Check if the given triangle intersect the box.
        bool intersect(const vec3&lt;Type&gt;&amp; a_p0, const vec3&lt;Type&gt;&amp; a_p1, const vec3&lt;Type&gt;&amp; a_p2) const
        {
            // &quot;Fast 3D Triangle-Box Overlap Testing&quot;
            // Tomas Akenine-Moller
            // Journal of Graphics Tools

            // Bullet 1:
            box3&lt;Type&gt; tribox;
            tribox.extendBy(a_p0);
            tribox.extendBy(a_p1);
            tribox.extendBy(a_p2);

            if (!this-&gt;intersect(tribox))
                return false;

            const vec3&lt;Type&gt; boxcenter = this-&gt;getCenter();

            // move everything so that the boxcenter is in (0,0,0)
            const vec3&lt;Type&gt; v[3] = { a_p0 - boxcenter,
                                      a_p1 - boxcenter,
                                      a_p2 - boxcenter };

            // compute triangle edges
            const vec3&lt;Type&gt; e[3] = { v[1] - v[0],
                                      v[2] - v[1],
                                      v[0] - v[2] };

            // Bullet 2:
            const vec3&lt;Type&gt; normal = e[0].cross(e[1]);

            if (!this-&gt;intersect(plane&lt;Type&gt;(normal, a_p0)))
                return false;

            // Bullet 3:
            const vec3&lt;Type&gt; boxhalfsize = this-&gt;getSize() * 0.5f;
            const Type f[3][3] = { { 1.0f, 0.0f, 0.0f },
                                   { 0.0f, 1.0f, 0.0f },
                                   { 0.0f, 0.0f, 1.0f } };

            for (int i = 0; i &lt; 3; i++) {
                for (int j = 0; j &lt; 3; j++) {
                    const vec3&lt;Type&gt; a = e[i].cross(f[j]);
                    const float p0 = a.dot(v[0]);
                    const float p1 = a.dot(v[1]);
                    const float p2 = a.dot(v[2]);
                    const float min = min3(p0, p1, p2);
                    const float max = max3(p0, p1, p2);
                    float radius = std::abs(a[0]) * boxhalfsize[0] + std::abs(a[1]) * boxhalfsize[1] + std::abs(a[2]) * boxhalfsize[2];
                    if (min &gt; radius || max &lt; -radius)
                        return false;
<A NAME="0"></A>                }
            }

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match44-1.html#0',3,'match44-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>            return true;
        }

        //! Check \a b1 and \a b2 for equality.
        friend bool operator==(const box3&lt;Type&gt;&amp; b1, const box3&lt;Type&gt;&amp; b2)
        {
            return b1.getMin() == b2.getMin() &amp;&amp; b1.getMax() == b2.getMax();
        }

        //! Check \a b1 and \a b2 for inequality.
        friend bool operator!=(const box3&lt;Type&gt;&amp; b1, const box3&lt;Type&gt;&amp; b2)
        {
            return !(b1 == b2);
        }</B></FONT>

    private:
        vec3&lt;Type&gt; m_min;
        vec3&lt;Type&gt; m_max;
    };

    typedef box3&lt;int&gt; box3i;
    typedef box3&lt;float&gt; box3f;
    typedef box3&lt;double&gt; box3d;
} // namespace gtl
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vec3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#pragma once

#include &lt;gtl/gtl.hpp&gt;

namespace gtl {
    /*!
    \class vec3 vec3.hpp geometry/vec3.hpp
    \brief 3 dimensional vector.
    \ingroup base

    This class is used by many other classes.

    \sa vec2
    */
    template &lt;typename Type&gt;
    struct vec3 {
        union {
            struct {
                Type x, y, z;
            };
            struct {
                Type r, g, b;
            };
            struct {
                Type u, v, w;
            };
            Type data[3];
        };

        //! The default constructor.The vector will be null.
        vec3()
            : x(0)
            , y(0)
            , z(0)
        {
        }

        //! Constructs an instance with initial values from \a v.
        vec3(const Type v[3])
            : x(v[0])
            , y(v[1])
            , z(v[2])
        {
        }

        //! Constructs an instance with the initial values from \a a_x, \a a_y and \a a_z.
        vec3(Type a_x, Type a_y, Type a_z)
            : x(a_x)
            , y(a_y)
            , z(a_z)
        {
        }

        //! Constructs an instance with initial values from \a a_vec.
        vec3(const vec3&lt;Type&gt;&amp; a_vec)
            : x(a_vec.x)
            , y(a_vec.y)
            , z(a_vec.z)
        {
        }

        //! Set new x, y and z values for the vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; setValue(const Type v[3])
        {
            x = v[0];
            y = v[1];
            z = v[2];

            return *this;
        }

        //! Set new x, y and z values for the vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; setValue(Type a_x, Type a_y, Type a_z)
        {
            x = a_x;
            y = a_y;
<A NAME="1"></A>            z = a_z;

            return *this;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#1',2,'match44-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        }

        //! Returns a pointer to an array containing the coordinates of the vector.
        const Type* getValue() const
        {
            return data;
        }

        //! Calculates and returns the dot product of this vector with \a a_vec.
        Type dot(const vec3&lt;Type&gt;&amp; a_vec) const
        {
            return (x * a_vec.x + y * a_vec.y + z * a_vec.z);
        }

        //! Return length of vector.
        Type length() const
        {
            return (Type)std::sqrt(x * x + y * y + z * z);</B></FONT>
        }

        //! Return squared length of vector.
        Type sqrLength() const
        {
            return (x * x + y * y + z * z);
        }

        //! Normalize the vector to unit length. Return value is the original length of the vector before normalization.
        Type normalize()
        {
            const Type magnitude = length();

            if (magnitude &gt; 0)
                *this /= magnitude;

            return magnitude;
        }

        //! Returns the normalized unit vector form of this vector.
        vec3&lt;Type&gt; normalized() const
        {
            vec3&lt;Type&gt; v(*this);
            v.normalize();

            return v;
        }

        //! Returns the cross product of this vector with \a a_vec.
        vec3&lt;Type&gt; cross(const vec3&lt;Type&gt;&amp; a_vec) const
        {
            return vec3&lt;Type&gt;(y * a_vec.z - a_vec.y * z,
                              z * a_vec.x - a_vec.z * x,
                              x * a_vec.y - a_vec.x * y);
        }

        //! Negate the vector (i.e. point it in the opposite direction).
        void negate()
        {
            x = -x;
            y = -y;
            z = -z;
        }

        //! Return this vector reflected off the surface with the given normal \a N. N should be normalized.
        vec3&lt;Type&gt; reflect(const vec3&lt;Type&gt;&amp; N) const
        {
            const vec3&lt;Type&gt;&amp; I(*this);

            return I - 2 * N.dot(I) * N;
        }

        //! Refract this vector through a surface with the given normal \a N and ratio of indices of refraction \a eta.
        vec3&lt;Type&gt; refract(const vec3&lt;Type&gt;&amp; N, Type eta) const
        {
            const vec3&lt;Type&gt;&amp; I(*this);
            const Type k = 1.0 - eta * eta * (1.0 - N.dot(I) * N.dot(I));

            return (k &lt; 0.0) ? 0 : eta * I - (eta * N.dot(I) + std::sqrt(k)) * N;
        }

        //! Index operator. Returns modifiable x, y or z value.
        Type&amp; operator[](int i) { return reinterpret_cast&lt;Type*&gt;(this)[i]; }

        //! Index operator. Returns x, y or z value.
        const Type&amp; operator[](int i) const { return reinterpret_cast&lt;const Type*&gt;(this)[i]; }

        //! Multiply components of vector with value \a d. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator*=(const Type d)
        {
            x *= d;
            y *= d;
            z *= d;

            return *this;
        }

        //! Divides components of vector with value \a d. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator/=(const Type d)
        {
            *this *= (1.0f / d);

            return *this;
        }

        //! Multiply components of vector with value \a a_vec.
        vec3&lt;Type&gt;&amp; operator*=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x *= a_vec.x;
            y *= a_vec.y;
            z *= a_vec.z;

            return *this;
        }

        //! Adds this vector and vector \a a_vec. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator+=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x += a_vec.x;
            y += a_vec.y;
            z += a_vec.z;

            return *this;
        }

        //! Subtracts vector \a a_vec from this vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator-=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x -= a_vec.x;
            y -= a_vec.y;
            z -= a_vec.z;

            return *this;
        }

<A NAME="0"></A>        //! Non-destructive negation operator.
        vec3&lt;Type&gt; operator-() const
        {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44-0.html#0',2,'match44-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>            return vec3&lt;Type&gt;(-x, -y, -z);
        }

        friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
        {
            return vec3&lt;Type&gt;(a_vec.x * d, a_vec.y * d, a_vec.z * d);
        }

        friend vec3&lt;Type&gt; operator*(const Type d, const vec3&lt;Type&gt;&amp; a_vec)
        {
            return a_vec * d;
        }</B></FONT>

        friend vec3&lt;Type&gt; operator/(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
        {
            return vec3&lt;Type&gt;(a_vec.x / d, a_vec.y / d, a_vec.z / d);
        }

        friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
        }

        friend inline vec3&lt;Type&gt; operator+(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
        }

        friend inline vec3&lt;Type&gt; operator-(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
        }

        //! Check the two given vector for equality.
        friend bool operator==(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return (v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z);
        }

        //! Check the two given vector for inequality.
        friend bool operator!=(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return !(v1 == v2);
        }

        //! Check for equality with given tolerance.
        bool equals(const vec3&lt;Type&gt;&amp; a_vec, const Type a_tolerance = 1E-2) const
        {
            return ((*this - a_vec).sqrLength() &lt;= a_tolerance * a_tolerance);
        }

        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vec3&lt;Type&gt;&amp; vect)
        {
            return os &lt;&lt; vect.x &lt;&lt; &quot; &quot; &lt;&lt; vect.y &lt;&lt; &quot; &quot; &lt;&lt; vect.z;
        }

        //! Largest representable vector
        static vec3&lt;Type&gt; max()
        {
            return vec3&lt;Type&gt;(std::numeric_limits&lt;Type&gt;::max(),
                              std::numeric_limits&lt;Type&gt;::max(),
                              std::numeric_limits&lt;Type&gt;::max());
        }
    };

    typedef vec3&lt;int&gt; vec3i;
    typedef vec3&lt;float&gt; vec3f;
    typedef vec3&lt;double&gt; vec3d;
} // namespace gtl
</PRE>
</div>
  </div>
</body>
</html>
