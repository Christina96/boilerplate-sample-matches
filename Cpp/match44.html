<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for box3.hpp &amp; vec3.hpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for box3.hpp &amp; vec3.hpp
      </h3>
<h1 align="center">
        10.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>box3.hpp (10.204082%)<th>vec3.hpp (11.406844%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(302-315)<td><a href="#" name="0">(216-227)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(59-76)<td><a href="#" name="1">(80-97)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>box3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#pragma once

#include &lt;gtl/gtl.hpp&gt;
#include &lt;gtl/matrix4.hpp&gt;
#include &lt;gtl/plane.hpp&gt;
#include &lt;gtl/ray.hpp&gt;
#include &lt;gtl/vec3.hpp&gt;

namespace gtl {
    // forward declaration
    template &lt;typename Type&gt;
    class plane;
    template &lt;typename Type&gt;
    class ray;

    /*!
    \class box3 box3.hpp geometry/box3.hpp
    \brief Axis-Aligned 3D Bounding Box Class..
    \ingroup base

    This box class is used by many other classes.

    \sa xfbox3
    */
    template &lt;typename Type&gt;
    class box3 {
    public:
        //! The default constructor makes an empty box.
        box3()
        {
            makeEmpty();
        }

        //! Constructs a box with the given corners.
        box3(const vec3&lt;Type&gt;&amp; a_min, const vec3&lt;Type&gt;&amp; a_max)
            : m_min(a_min)
            , m_max(a_max)
        {
        }

        //! Reset the boundaries of the box with the given corners.
        void setBounds(const vec3&lt;Type&gt;&amp; a_min, const vec3&lt;Type&gt;&amp; a_max)
        {
            m_min = a_min;
            m_max = a_max;
        }

        //! Check if this has been marked as an empty box. \sa makeEmpty().
        bool isEmpty() const
        {
            return (m_max[0] &lt; m_min[0] || m_max[1] &lt; m_min[1] || m_max[2] &lt; m_min[2]);
        }

        //! Marks this as an empty box.	\sa isEmpty().
        void makeEmpty()
<a name="1"></a>        {
            m_min = vec3&lt;Type&gt;::max();
            m_max = -vec3&lt;Type&gt;::max();
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        }

        //! Returns the lower left corner of the box. \sa getCenter(), getMax().
        const vec3&lt;Type&gt;&amp; getMin() const
        {
            return m_min;
        }

        //! Returns the upper right corner of the box. \sa getMin().
        const vec3&lt;Type&gt;&amp; getMax() const
        {
            return m_max;
        }

        //! Returns width, height and depth of box.
        vec3&lt;Type&gt; getSize() const
        {
            return m_max - m_min;</b></font>
        }

        //! Returns the center point of the box.
        vec3&lt;Type&gt; getCenter() const
        {
            return vec3&lt;Type&gt;((m_max[0] + m_min[0]) * 0.5f,
                              (m_max[1] + m_min[1]) * 0.5f,
                              (m_max[2] + m_min[2]) * 0.5f);
        }

        //! Extend the boundaries of the box by the given point.
        void extendBy(const vec3&lt;Type&gt;&amp; a_point)
        {
            if (isEmpty()) {
                setBounds(a_point, a_point);
            } else {
                if (a_point[0] &lt; m_min[0])
                    m_min[0] = a_point[0];
                if (a_point[1] &lt; m_min[1])
                    m_min[1] = a_point[1];
                if (a_point[2] &lt; m_min[2])
                    m_min[2] = a_point[2];

                if (a_point[0] &gt; m_max[0])
                    m_max[0] = a_point[0];
                if (a_point[1] &gt; m_max[1])
                    m_max[1] = a_point[1];
                if (a_point[2] &gt; m_max[2])
                    m_max[2] = a_point[2];
            }
        }

        //! Extend the boundaries of the box by the given \a a_box parameter.
        void extendBy(const box3&lt;Type&gt;&amp; a_box)
        {
            if (isEmpty()) {
                *this = a_box;
            } else {
                extendBy(a_box.getMin());
                extendBy(a_box.getMax());
            }
        }

        //! Give the volume of the box (0 for an empty box)
        Type getVolume() const
        {
            if (isEmpty())
                return 0.0;

            return (m_max[0] - m_min[0]) * (m_max[1] - m_min[1]) * (m_max[2] - m_min[2]);
        }

        //! Transforms box3 by matrix, enlarging box3 to contain result.
        void transform(const matrix4&lt;Type&gt;&amp; m)
        {
            // a transformed empty box is still empty
            if (isEmpty())
                return;

            vec3&lt;Type&gt; corners[8];
            corners[0] = m_min;
            corners[1][0] = m_min[0];
            corners[1][1] = m_max[1];
            corners[1][2] = m_min[2];
            corners[2][0] = m_max[0];
            corners[2][1] = m_max[1];
            corners[2][2] = m_min[2];
            corners[3][0] = m_max[0];
            corners[3][1] = m_min[1];
            corners[3][2] = m_min[2];
            corners[4] = m_max;
            corners[5][0] = m_min[0];
            corners[5][1] = m_max[1];
            corners[5][2] = m_max[2];
            corners[6][0] = m_min[0];
            corners[6][1] = m_min[1];
            corners[6][2] = m_max[2];
            corners[7][0] = m_max[0];
            corners[7][1] = m_min[1];
            corners[7][2] = m_max[2];

            box3&lt;Type&gt; newbox;
            for (int i = 0; i &lt; 8; ++i) {
                m.multVecMatrix(corners[i], corners[i]);
                newbox.extendBy(corners[i]);
            }

            setBounds(newbox.m_min, newbox.m_max);
        }

        //! Check if \a a_point lies within the boundaries of this box.
        bool intersect(const vec3&lt;Type&gt;&amp; a_point) const
        {
            return !(a_point[0] &lt; m_min[0] || a_point[0] &gt; m_max[0] || a_point[1] &lt; m_min[1] || a_point[1] &gt; m_max[1] || a_point[2] &lt; m_min[2] || a_point[2] &gt; m_max[2]);
        }

        //! Check if the given box lies wholly or partly within the boundaries of this box.
        bool intersect(const box3&lt;Type&gt;&amp; a_box) const
        {
            if ((m_max[0] &lt; a_box.m_min[0]) || (m_min[0] &gt; a_box.m_max[0]) || (m_max[1] &lt; a_box.m_min[1]) || (m_min[1] &gt; a_box.m_max[1]) || (m_max[2] &lt; a_box.m_min[2]) || (m_min[2] &gt; a_box.m_max[2])) {
                return false;
            }
            return true;
        }

        //! Check if the given ray intersect the box.
        bool intersect(const ray&lt;Type&gt;&amp; a_ray, Type&amp; tmin, Type&amp; tmax) const
        {
            // Amy Williams, Steve Barrus, R. Keith Morley, and Peter Shirley
            // "An Efficient and Robust ray-Box Intersection Algorithm"
            //  Journal of graphics tools, 10(1):49-54, 2005
            if (isEmpty())
                return false;

            const vec3&lt;Type&gt; inv_direction(1 / a_ray.getDirection()[0], 1 / a_ray.getDirection()[1], 1 / a_ray.getDirection()[2]);

            const vec3&lt;int&gt; sign(inv_direction[0] &lt; 0, inv_direction[1] &lt; 0, inv_direction[2] &lt; 0);

            tmin = ((sign[0] ? m_max : m_min).x - a_ray.getOrigin().x) * inv_direction.x;
            tmax = (((1 - sign[0]) ? m_max : m_min).x - a_ray.getOrigin().x) * inv_direction.x;

            const Type tymin = ((sign[1] ? m_max : m_min).y - a_ray.getOrigin().y) * inv_direction.y;
            const Type tymax = (((1 - sign[1]) ? m_max : m_min).y - a_ray.getOrigin().y) * inv_direction.y;

            if ((tmin &gt; tymax) || (tymin &gt; tmax))
                return false;

            if (tymin &gt; tmin)
                tmin = tymin;
            if (tymax &lt; tmax)
                tmax = tymax;

            const Type tzmin = ((sign[2] ? m_max : m_min).z - a_ray.getOrigin().z) * inv_direction.z;
            const Type tzmax = (((1 - sign[2]) ? m_max : m_min).z - a_ray.getOrigin().z) * inv_direction.z;

            if ((tmin &gt; tzmax) || (tzmin &gt; tmax))
                return false;

            if (tzmin &gt; tmin)
                tmin = tzmin;
            if (tzmax &lt; tmax)
                tmax = tzmax;

            return (tmin &gt;= 0 &amp;&amp; tmax &gt;= 1);
        }

        //! Check if the given plane intersect the box.
        bool intersect(const plane&lt;Type&gt;&amp; a_plane) const
        {
            // Empty boxes can cause problems.
            if (isEmpty())
                return false;

            const vec3&lt;Type&gt;&amp; pnorm = a_plane.getNormal();

            // Use separating axis theorem to test overlap.
            const vec3&lt;Type&gt; vmin(pnorm[0] &gt; 0.0 ? m_min[0] : m_max[0],
                                  pnorm[1] &gt; 0.0 ? m_min[1] : m_max[1],
                                  pnorm[2] &gt; 0.0 ? m_min[2] : m_max[2]);
            if (a_plane.isInHalfSpace(vmin))
                return false;

            const vec3&lt;Type&gt; vmax(pnorm[0] &gt; 0.0 ? m_max[0] : m_min[0],
                                  pnorm[1] &gt; 0.0 ? m_max[1] : m_min[1],
                                  pnorm[2] &gt; 0.0 ? m_max[2] : m_min[2]);
            if (a_plane.isInHalfSpace(vmax))
                return true;

            return false;
        }

        //! Check if the given triangle intersect the box.
        bool intersect(const vec3&lt;Type&gt;&amp; a_p0, const vec3&lt;Type&gt;&amp; a_p1, const vec3&lt;Type&gt;&amp; a_p2) const
        {
            // "Fast 3D Triangle-Box Overlap Testing"
            // Tomas Akenine-Moller
            // Journal of Graphics Tools

            // Bullet 1:
            box3&lt;Type&gt; tribox;
            tribox.extendBy(a_p0);
            tribox.extendBy(a_p1);
            tribox.extendBy(a_p2);

            if (!this-&gt;intersect(tribox))
                return false;

            const vec3&lt;Type&gt; boxcenter = this-&gt;getCenter();

            // move everything so that the boxcenter is in (0,0,0)
            const vec3&lt;Type&gt; v[3] = { a_p0 - boxcenter,
                                      a_p1 - boxcenter,
                                      a_p2 - boxcenter };

            // compute triangle edges
            const vec3&lt;Type&gt; e[3] = { v[1] - v[0],
                                      v[2] - v[1],
                                      v[0] - v[2] };

            // Bullet 2:
            const vec3&lt;Type&gt; normal = e[0].cross(e[1]);

            if (!this-&gt;intersect(plane&lt;Type&gt;(normal, a_p0)))
                return false;

            // Bullet 3:
            const vec3&lt;Type&gt; boxhalfsize = this-&gt;getSize() * 0.5f;
            const Type f[3][3] = { { 1.0f, 0.0f, 0.0f },
                                   { 0.0f, 1.0f, 0.0f },
                                   { 0.0f, 0.0f, 1.0f } };

            for (int i = 0; i &lt; 3; i++) {
                for (int j = 0; j &lt; 3; j++) {
                    const vec3&lt;Type&gt; a = e[i].cross(f[j]);
                    const float p0 = a.dot(v[0]);
                    const float p1 = a.dot(v[1]);
                    const float p2 = a.dot(v[2]);
                    const float min = min3(p0, p1, p2);
                    const float max = max3(p0, p1, p2);
                    float radius = std::abs(a[0]) * boxhalfsize[0] + std::abs(a[1]) * boxhalfsize[1] + std::abs(a[2]) * boxhalfsize[2];
                    if (min &gt; radius || max &lt; -radius)
                        return false;
<a name="0"></a>                }
            }

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            return true;
        }

        //! Check \a b1 and \a b2 for equality.
        friend bool operator==(const box3&lt;Type&gt;&amp; b1, const box3&lt;Type&gt;&amp; b2)
        {
            return b1.getMin() == b2.getMin() &amp;&amp; b1.getMax() == b2.getMax();
        }

        //! Check \a b1 and \a b2 for inequality.
        friend bool operator!=(const box3&lt;Type&gt;&amp; b1, const box3&lt;Type&gt;&amp; b2)
        {
            return !(b1 == b2);
        }</b></font>

    private:
        vec3&lt;Type&gt; m_min;
        vec3&lt;Type&gt; m_max;
    };

    typedef box3&lt;int&gt; box3i;
    typedef box3&lt;float&gt; box3f;
    typedef box3&lt;double&gt; box3d;
} // namespace gtl
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vec3.hpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#pragma once

#include &lt;gtl/gtl.hpp&gt;

namespace gtl {
    /*!
    \class vec3 vec3.hpp geometry/vec3.hpp
    \brief 3 dimensional vector.
    \ingroup base

    This class is used by many other classes.

    \sa vec2
    */
    template &lt;typename Type&gt;
    struct vec3 {
        union {
            struct {
                Type x, y, z;
            };
            struct {
                Type r, g, b;
            };
            struct {
                Type u, v, w;
            };
            Type data[3];
        };

        //! The default constructor.The vector will be null.
        vec3()
            : x(0)
            , y(0)
            , z(0)
        {
        }

        //! Constructs an instance with initial values from \a v.
        vec3(const Type v[3])
            : x(v[0])
            , y(v[1])
            , z(v[2])
        {
        }

        //! Constructs an instance with the initial values from \a a_x, \a a_y and \a a_z.
        vec3(Type a_x, Type a_y, Type a_z)
            : x(a_x)
            , y(a_y)
            , z(a_z)
        {
        }

        //! Constructs an instance with initial values from \a a_vec.
        vec3(const vec3&lt;Type&gt;&amp; a_vec)
            : x(a_vec.x)
            , y(a_vec.y)
            , z(a_vec.z)
        {
        }

        //! Set new x, y and z values for the vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; setValue(const Type v[3])
        {
            x = v[0];
            y = v[1];
            z = v[2];

            return *this;
        }

        //! Set new x, y and z values for the vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; setValue(Type a_x, Type a_y, Type a_z)
        {
            x = a_x;
            y = a_y;
<a name="1"></a>            z = a_z;

            return *this;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        }

        //! Returns a pointer to an array containing the coordinates of the vector.
        const Type* getValue() const
        {
            return data;
        }

        //! Calculates and returns the dot product of this vector with \a a_vec.
        Type dot(const vec3&lt;Type&gt;&amp; a_vec) const
        {
            return (x * a_vec.x + y * a_vec.y + z * a_vec.z);
        }

        //! Return length of vector.
        Type length() const
        {
            return (Type)std::sqrt(x * x + y * y + z * z);</b></font>
        }

        //! Return squared length of vector.
        Type sqrLength() const
        {
            return (x * x + y * y + z * z);
        }

        //! Normalize the vector to unit length. Return value is the original length of the vector before normalization.
        Type normalize()
        {
            const Type magnitude = length();

            if (magnitude &gt; 0)
                *this /= magnitude;

            return magnitude;
        }

        //! Returns the normalized unit vector form of this vector.
        vec3&lt;Type&gt; normalized() const
        {
            vec3&lt;Type&gt; v(*this);
            v.normalize();

            return v;
        }

        //! Returns the cross product of this vector with \a a_vec.
        vec3&lt;Type&gt; cross(const vec3&lt;Type&gt;&amp; a_vec) const
        {
            return vec3&lt;Type&gt;(y * a_vec.z - a_vec.y * z,
                              z * a_vec.x - a_vec.z * x,
                              x * a_vec.y - a_vec.x * y);
        }

        //! Negate the vector (i.e. point it in the opposite direction).
        void negate()
        {
            x = -x;
            y = -y;
            z = -z;
        }

        //! Return this vector reflected off the surface with the given normal \a N. N should be normalized.
        vec3&lt;Type&gt; reflect(const vec3&lt;Type&gt;&amp; N) const
        {
            const vec3&lt;Type&gt;&amp; I(*this);

            return I - 2 * N.dot(I) * N;
        }

        //! Refract this vector through a surface with the given normal \a N and ratio of indices of refraction \a eta.
        vec3&lt;Type&gt; refract(const vec3&lt;Type&gt;&amp; N, Type eta) const
        {
            const vec3&lt;Type&gt;&amp; I(*this);
            const Type k = 1.0 - eta * eta * (1.0 - N.dot(I) * N.dot(I));

            return (k &lt; 0.0) ? 0 : eta * I - (eta * N.dot(I) + std::sqrt(k)) * N;
        }

        //! Index operator. Returns modifiable x, y or z value.
        Type&amp; operator[](int i) { return reinterpret_cast&lt;Type*&gt;(this)[i]; }

        //! Index operator. Returns x, y or z value.
        const Type&amp; operator[](int i) const { return reinterpret_cast&lt;const Type*&gt;(this)[i]; }

        //! Multiply components of vector with value \a d. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator*=(const Type d)
        {
            x *= d;
            y *= d;
            z *= d;

            return *this;
        }

        //! Divides components of vector with value \a d. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator/=(const Type d)
        {
            *this *= (1.0f / d);

            return *this;
        }

        //! Multiply components of vector with value \a a_vec.
        vec3&lt;Type&gt;&amp; operator*=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x *= a_vec.x;
            y *= a_vec.y;
            z *= a_vec.z;

            return *this;
        }

        //! Adds this vector and vector \a a_vec. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator+=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x += a_vec.x;
            y += a_vec.y;
            z += a_vec.z;

            return *this;
        }

        //! Subtracts vector \a a_vec from this vector. Returns reference to self.
        vec3&lt;Type&gt;&amp; operator-=(const vec3&lt;Type&gt;&amp; a_vec)
        {
            x -= a_vec.x;
            y -= a_vec.y;
            z -= a_vec.z;

            return *this;
        }

<a name="0"></a>        //! Non-destructive negation operator.
        vec3&lt;Type&gt; operator-() const
        {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            return vec3&lt;Type&gt;(-x, -y, -z);
        }

        friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
        {
            return vec3&lt;Type&gt;(a_vec.x * d, a_vec.y * d, a_vec.z * d);
        }

        friend vec3&lt;Type&gt; operator*(const Type d, const vec3&lt;Type&gt;&amp; a_vec)
        {
            return a_vec * d;
        }</b></font>

        friend vec3&lt;Type&gt; operator/(const vec3&lt;Type&gt;&amp; a_vec, const Type d)
        {
            return vec3&lt;Type&gt;(a_vec.x / d, a_vec.y / d, a_vec.z / d);
        }

        friend vec3&lt;Type&gt; operator*(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
        }

        friend inline vec3&lt;Type&gt; operator+(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
        }

        friend inline vec3&lt;Type&gt; operator-(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return vec3&lt;Type&gt;(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
        }

        //! Check the two given vector for equality.
        friend bool operator==(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return (v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z);
        }

        //! Check the two given vector for inequality.
        friend bool operator!=(const vec3&lt;Type&gt;&amp; v1, const vec3&lt;Type&gt;&amp; v2)
        {
            return !(v1 == v2);
        }

        //! Check for equality with given tolerance.
        bool equals(const vec3&lt;Type&gt;&amp; a_vec, const Type a_tolerance = 1E-2) const
        {
            return ((*this - a_vec).sqrLength() &lt;= a_tolerance * a_tolerance);
        }

        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vec3&lt;Type&gt;&amp; vect)
        {
            return os &lt;&lt; vect.x &lt;&lt; " " &lt;&lt; vect.y &lt;&lt; " " &lt;&lt; vect.z;
        }

        //! Largest representable vector
        static vec3&lt;Type&gt; max()
        {
            return vec3&lt;Type&gt;(std::numeric_limits&lt;Type&gt;::max(),
                              std::numeric_limits&lt;Type&gt;::max(),
                              std::numeric_limits&lt;Type&gt;::max());
        }
    };

    typedef vec3&lt;int&gt; vec3i;
    typedef vec3&lt;float&gt; vec3f;
    typedef vec3&lt;double&gt; vec3d;
} // namespace gtl
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
