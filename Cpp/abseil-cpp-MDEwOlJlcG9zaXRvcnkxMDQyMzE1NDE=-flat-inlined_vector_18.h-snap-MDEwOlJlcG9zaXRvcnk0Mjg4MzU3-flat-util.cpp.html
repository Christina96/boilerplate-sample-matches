
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.194805194805195%, Tokens: 11</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_18.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_INLINED_VECTOR_H_
2  #define ABSL_CONTAINER_INTERNAL_INLINED_VECTOR_H_
3  #include <algorithm>
4  #include <cstddef>
5  #include <cstring>
6  #include <iterator>
7  #include <limits>
8  #include <memory>
9  #include <new>
10  #include <type_traits>
11  #include <utility>
12  #include "absl/base/attributes.h"
13  #include "absl/base/macros.h"
14  #include "absl/container/internal/compressed_tuple.h"
15  #include "absl/memory/memory.h"
16  #include "absl/meta/type_traits.h"
17  #include "absl/types/span.h"
18  namespace absl {
19  ABSL_NAMESPACE_BEGIN
20  namespace inlined_vector_internal {
21  #if !defined(__clang__) && defined(__GNUC__)
22  #pragma GCC diagnostic push
23  #pragma GCC diagnostic ignored "-Warray-bounds"
24  #endif
25  template <typename A>
26  using AllocatorTraits = std::allocator_traits<A>;
27  template <typename A>
28  using ValueType = typename AllocatorTraits<A>::value_type;
29  template <typename A>
30  using SizeType = typename AllocatorTraits<A>::size_type;
31  template <typename A>
32  using Pointer = typename AllocatorTraits<A>::pointer;
33  template <typename A>
34  using ConstPointer = typename AllocatorTraits<A>::const_pointer;
35  template <typename A>
36  using SizeType = typename AllocatorTraits<A>::size_type;
37  template <typename A>
38  using DifferenceType = typename AllocatorTraits<A>::difference_type;
39  template <typename A>
40  using Reference = ValueType<A>&;
41  template <typename A>
42  using ConstReference = const ValueType<A>&;
43  template <typename A>
44  using Iterator = Pointer<A>;
45  template <typename A>
46  using ConstIterator = ConstPointer<A>;
47  template <typename A>
48  using ReverseIterator = typename std::reverse_iterator<Iterator<A>>;
49  template <typename A>
50  using ConstReverseIterator = typename std::reverse_iterator<ConstIterator<A>>;
51  template <typename A>
52  using MoveIterator = typename std::move_iterator<Iterator<A>>;
53  template <typename Iterator>
54  using IsAtLeastForwardIterator = std::is_convertible<
55      typename std::iterator_traits<Iterator>::iterator_category,
56      std::forward_iterator_tag>;
57  template <typename A>
58  using IsMoveAssignOk = std::is_move_assignable<ValueType<A>>;
59  template <typename A>
60  using IsSwapOk = absl::type_traits_internal::IsSwappable<ValueType<A>>;
61  template <typename T>
62  struct TypeIdentity {
63    using type = T;
64  };
65  template <typename T>
66  using NoTypeDeduction = typename TypeIdentity<T>::type;
67  template <typename A, bool IsTriviallyDestructible =
68                            absl::is_trivially_destructible<ValueType<A>>::value>
69  struct DestroyAdapter;
70  template <typename A>
71  struct DestroyAdapter<A, &bsol;* IsTriviallyDestructible */ false> {
72    static void DestroyElements(A& allocator, Pointer<A> destroy_first,
73                                SizeType<A> destroy_size) {
74      for (SizeType<A> i = destroy_size; i != 0;) {
75        --i;
76        AllocatorTraits<A>::destroy(allocator, destroy_first + i);
77      }
78    }
79  };
80  template <typename A>
81  struct DestroyAdapter<A, &bsol;* IsTriviallyDestructible */ true> {
82    static void DestroyElements(A& allocator, Pointer<A> destroy_first,
83                                SizeType<A> destroy_size) {
84      static_cast<void>(allocator);
85      static_cast<void>(destroy_first);
86      static_cast<void>(destroy_size);
87    }
88  };
89  template <typename A>
90  struct Allocation {
91    Pointer<A> data = nullptr;
92    SizeType<A> capacity = 0;
93  };
94  template <typename A,
95            bool IsOverAligned =
96                (alignof(ValueType<A>) > ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT)>
97  struct MallocAdapter {
98    static Allocation<A> Allocate(A& allocator, SizeType<A> requested_capacity) {
99      return {AllocatorTraits<A>::allocate(allocator, requested_capacity),
100              requested_capacity};
101    }
102    static void Deallocate(A& allocator, Pointer<A> pointer,
103                           SizeType<A> capacity) {
104      AllocatorTraits<A>::deallocate(allocator, pointer, capacity);
105    }
106  };
107  template <typename A, typename ValueAdapter>
108  void ConstructElements(NoTypeDeduction<A>& allocator,
109                         Pointer<A> construct_first, ValueAdapter& values,
110                         SizeType<A> construct_size) {
111    for (SizeType<A> i = 0; i < construct_size; ++i) {
112      ABSL_INTERNAL_TRY { values.ConstructNext(allocator, construct_first + i); }
113      ABSL_INTERNAL_CATCH_ANY {
114        DestroyAdapter<A>::DestroyElements(allocator, construct_first, i);
115        ABSL_INTERNAL_RETHROW;
116      }
117    }
118  }
119  template <typename A, typename ValueAdapter>
120  void AssignElements(Pointer<A> assign_first, ValueAdapter& values,
121                      SizeType<A> assign_size) {
122    for (SizeType<A> i = 0; i < assign_size; ++i) {
123      values.AssignNext(assign_first + i);
124    }
125  }
126  template <typename A>
127  struct StorageView {
128    Pointer<A> data;
129    SizeType<A> size;
130    SizeType<A> capacity;
131  };
132  template <typename A, typename Iterator>
133  class IteratorValueAdapter {
134   public:
135    explicit IteratorValueAdapter(const Iterator& it) : it_(it) {}
136    void ConstructNext(A& allocator, Pointer<A> construct_at) {
137      AllocatorTraits<A>::construct(allocator, construct_at, *it_);
138      ++it_;
139    }
140    void AssignNext(Pointer<A> assign_at) {
141      *assign_at = *it_;
142      ++it_;
143    }
144   private:
145    Iterator it_;
146  };
147  template <typename A>
148  class CopyValueAdapter {
149   public:
150    explicit CopyValueAdapter(ConstPointer<A> p) : ptr_(p) {}
151    void ConstructNext(A& allocator, Pointer<A> construct_at) {
152      AllocatorTraits<A>::construct(allocator, construct_at, *ptr_);
153    }
154    void AssignNext(Pointer<A> assign_at) { *assign_at = *ptr_; }
155   private:
156    ConstPointer<A> ptr_;
157  };
158  template <typename A>
159  class DefaultValueAdapter {
160   public:
161    explicit DefaultValueAdapter() {}
162    void ConstructNext(A& allocator, Pointer<A> construct_at) {
163      AllocatorTraits<A>::construct(allocator, construct_at);
164    }
165    void AssignNext(Pointer<A> assign_at) { *assign_at = ValueType<A>(); }
166  };
167  template <typename A>
168  class AllocationTransaction {
169   public:
170    explicit AllocationTransaction(A& allocator)
171        : allocator_data_(allocator, nullptr), capacity_(0) {}
172    ~AllocationTransaction() {
173      if (DidAllocate()) {
174        MallocAdapter<A>::Deallocate(GetAllocator(), GetData(), GetCapacity());
175      }
176    }
177    AllocationTransaction(const AllocationTransaction&) = delete;
178    void operator=(const AllocationTransaction&) = delete;
179    A& GetAllocator() { return allocator_data_.template get<0>(); }
180    Pointer<A>& GetData() { return allocator_data_.template get<1>(); }
181    SizeType<A>& GetCapacity() { return capacity_; }
182    bool DidAllocate() { return GetData() != nullptr; }
183    Pointer<A> Allocate(SizeType<A> requested_capacity) {
184      Allocation<A> result =
185          MallocAdapter<A>::Allocate(GetAllocator(), requested_capacity);
186      GetData() = result.data;
187      GetCapacity() = result.capacity;
188      return result.data;
189    }
190    ABSL_MUST_USE_RESULT Allocation<A> Release() && {
191      Allocation<A> result = {GetData(), GetCapacity()};
192      Reset();
193      return result;
194    }
195   private:
196    void Reset() {
197      GetData() = nullptr;
198      GetCapacity() = 0;
199    }
200    container_internal::CompressedTuple<A, Pointer<A>> allocator_data_;
201    SizeType<A> capacity_;
202  };
203  template <typename A>
204  class ConstructionTransaction {
205   public:
206    explicit ConstructionTransaction(A& allocator)
207        : allocator_data_(allocator, nullptr), size_(0) {}
208    ~ConstructionTransaction() {
209      if (DidConstruct()) {
210        DestroyAdapter<A>::DestroyElements(GetAllocator(), GetData(), GetSize());
211      }
212    }
213    ConstructionTransaction(const ConstructionTransaction&) = delete;
214    void operator=(const ConstructionTransaction&) = delete;
215    A& GetAllocator() { return allocator_data_.template get<0>(); }
216    Pointer<A>& GetData() { return allocator_data_.template get<1>(); }
217    SizeType<A>& GetSize() { return size_; }
218    bool DidConstruct() { return GetData() != nullptr; }
219    template <typename ValueAdapter>
220    void Construct(Pointer<A> data, ValueAdapter& values, SizeType<A> size) {
221      ConstructElements<A>(GetAllocator(), data, values, size);
222      GetData() = data;
223      GetSize() = size;
224    }
225    void Commit() && {
226      GetData() = nullptr;
227      GetSize() = 0;
228    }
229   private:
230    container_internal::CompressedTuple<A, Pointer<A>> allocator_data_;
231    SizeType<A> size_;
232  };
233  template <typename T, size_t N, typename A>
234  class Storage {
235   public:
236    struct MemcpyPolicy {};
237    struct ElementwiseAssignPolicy {};
238    struct ElementwiseSwapPolicy {};
239    struct ElementwiseConstructPolicy {};
240    using MoveAssignmentPolicy = absl::conditional_t<
241        absl::conjunction<absl::is_trivially_move_assignable<ValueType<A>>,
242                          absl::is_trivially_destructible<ValueType<A>>,
243                          std::is_same<A, std::allocator<ValueType<A>>>>::value,
244        MemcpyPolicy,
245        absl::conditional_t<IsMoveAssignOk<A>::value, ElementwiseAssignPolicy,
246                            ElementwiseConstructPolicy>>;
247    using SwapInlinedElementsPolicy = absl::conditional_t<
248        absl::conjunction<absl::is_trivially_move_constructible<ValueType<A>>,
249                          absl::is_trivially_move_assignable<ValueType<A>>,
250                          absl::is_trivially_destructible<ValueType<A>>,
251                          std::is_same<A, std::allocator<ValueType<A>>>>::value,
252        MemcpyPolicy,
253        absl::conditional_t<IsSwapOk<A>::value, ElementwiseSwapPolicy,
254                            ElementwiseConstructPolicy>>;
255    static SizeType<A> NextCapacity(SizeType<A> current_capacity) {
256      return current_capacity * 2;
257    }
258    static SizeType<A> ComputeCapacity(SizeType<A> current_capacity,
259                                       SizeType<A> requested_capacity) {
260      return (std::max)(NextCapacity(current_capacity), requested_capacity);
261    }
262    Storage() : metadata_(A(), &bsol;* size and is_allocated */ 0u) {}
263    explicit Storage(const A& allocator)
264        : metadata_(allocator, &bsol;* size and is_allocated */ 0u) {}
265    ~Storage() {
266      if (GetSizeAndIsAllocated() == 0) {
267        return;
268      }
269      if (absl::is_trivially_destructible<ValueType<A>>::value &&
270          std::is_same<A, std::allocator<ValueType<A>>>::value) {
271        DeallocateIfAllocated();
272        return;
273      }
274      DestroyContents();
275    }
276    SizeType<A>& GetSizeAndIsAllocated() { return metadata_.template get<1>(); }
277    const SizeType<A>& GetSizeAndIsAllocated() const {
278      return metadata_.template get<1>();
279    }
280    SizeType<A> GetSize() const { return GetSizeAndIsAllocated() >> 1; }
281    bool GetIsAllocated() const { return GetSizeAndIsAllocated() & 1; }
282    Pointer<A> GetAllocatedData() { return data_.allocated.allocated_data; }
283    ConstPointer<A> GetAllocatedData() const {
284      return data_.allocated.allocated_data;
285    }
286    Pointer<A> GetInlinedData() {
287      return reinterpret_cast<Pointer<A>>(
288          std::addressof(data_.inlined.inlined_data[0]));
<span onclick='openModal()' class='match'>289    }
290    ConstPointer<A> GetInlinedData() const {
291      return reinterpret_cast<ConstPointer<A>>(
292          std::addressof(data_.inlined.inlined_data[0]));
293    }
294    SizeType<A> GetAllocatedCapacity() const {
295      return data_.allocated.allocated_capacity;
296    }
297    SizeType<A> GetInlinedCapacity() const {
</span>298      return static_cast<SizeType<A>>(kOptimalInlinedSize);
299    }
300    StorageView<A> MakeStorageView() {
301      return GetIsAllocated() ? StorageView<A>{GetAllocatedData(), GetSize(),
302                                               GetAllocatedCapacity()}
303                              : StorageView<A>{GetInlinedData(), GetSize(),
304                                               GetInlinedCapacity()};
305    }
306    A& GetAllocator() { return metadata_.template get<0>(); }
307    const A& GetAllocator() const { return metadata_.template get<0>(); }
308    ABSL_ATTRIBUTE_NOINLINE void InitFrom(const Storage& other);
309    template <typename ValueAdapter>
310    void Initialize(ValueAdapter values, SizeType<A> new_size);
311    template <typename ValueAdapter>
312    void Assign(ValueAdapter values, SizeType<A> new_size);
313    template <typename ValueAdapter>
314    void Resize(ValueAdapter values, SizeType<A> new_size);
315    template <typename ValueAdapter>
316    Iterator<A> Insert(ConstIterator<A> pos, ValueAdapter values,
317                       SizeType<A> insert_count);
318    template <typename... Args>
319    Reference<A> EmplaceBack(Args&&... args);
320    Iterator<A> Erase(ConstIterator<A> from, ConstIterator<A> to);
321    void Reserve(SizeType<A> requested_capacity);
322    void ShrinkToFit();
323    void Swap(Storage* other_storage_ptr);
324    void SetIsAllocated() {
325      GetSizeAndIsAllocated() |= static_cast<SizeType<A>>(1);
326    }
327    void UnsetIsAllocated() {
328      GetSizeAndIsAllocated() &= ((std::numeric_limits<SizeType<A>>::max)() - 1);
329    }
330    void SetSize(SizeType<A> size) {
331      GetSizeAndIsAllocated() =
332          (size << 1) | static_cast<SizeType<A>>(GetIsAllocated());
333    }
334    void SetAllocatedSize(SizeType<A> size) {
335      GetSizeAndIsAllocated() = (size << 1) | static_cast<SizeType<A>>(1);
336    }
337    void SetInlinedSize(SizeType<A> size) {
338      GetSizeAndIsAllocated() = size << static_cast<SizeType<A>>(1);
339    }
340    void AddSize(SizeType<A> count) {
341      GetSizeAndIsAllocated() += count << static_cast<SizeType<A>>(1);
342    }
343    void SubtractSize(SizeType<A> count) {
344      ABSL_HARDENING_ASSERT(count <= GetSize());
345      GetSizeAndIsAllocated() -= count << static_cast<SizeType<A>>(1);
346    }
347    void SetAllocation(Allocation<A> allocation) {
348      data_.allocated.allocated_data = allocation.data;
349      data_.allocated.allocated_capacity = allocation.capacity;
350    }
351    void MemcpyFrom(const Storage& other_storage) {
352      {
353        using V = ValueType<A>;
354        ABSL_HARDENING_ASSERT(
355            other_storage.GetIsAllocated() ||
356            (std::is_same<A, std::allocator<V>>::value &&
357             (
358                 absl::is_trivially_relocatable<V>::value ||
359                 (absl::is_trivially_move_assignable<V>::value &&
360                  absl::is_trivially_destructible<V>::value) ||
361                 (absl::is_trivially_copy_constructible<V>::value ||
362                  absl::is_trivially_copy_assignable<V>::value))));
363      }
364      GetSizeAndIsAllocated() = other_storage.GetSizeAndIsAllocated();
365      data_ = other_storage.data_;
366    }
367    void DeallocateIfAllocated() {
368      if (GetIsAllocated()) {
369        MallocAdapter<A>::Deallocate(GetAllocator(), GetAllocatedData(),
370                                     GetAllocatedCapacity());
371      }
372    }
373   private:
374    ABSL_ATTRIBUTE_NOINLINE void DestroyContents();
375    using Metadata = container_internal::CompressedTuple<A, SizeType<A>>;
376    struct Allocated {
377      Pointer<A> allocated_data;
378      SizeType<A> allocated_capacity;
379    };
380    static constexpr size_t kOptimalInlinedSize =
381        (std::max)(N, sizeof(Allocated) / sizeof(ValueType<A>));
382    struct Inlined {
383      alignas(ValueType<A>) char inlined_data[sizeof(
384          ValueType<A>[kOptimalInlinedSize])];
385    };
386    union Data {
387      Allocated allocated;
388      Inlined inlined;
389    };
390    void SwapN(ElementwiseSwapPolicy, Storage* other, SizeType<A> n);
391    void SwapN(ElementwiseConstructPolicy, Storage* other, SizeType<A> n);
392    void SwapInlinedElements(MemcpyPolicy, Storage* other);
393    template <typename NotMemcpyPolicy>
394    void SwapInlinedElements(NotMemcpyPolicy, Storage* other);
395    template <typename... Args>
396    ABSL_ATTRIBUTE_NOINLINE Reference<A> EmplaceBackSlow(Args&&... args);
397    Metadata metadata_;
398    Data data_;
399  };
400  template <typename T, size_t N, typename A>
401  void Storage<T, N, A>::DestroyContents() {
402    Pointer<A> data = GetIsAllocated() ? GetAllocatedData() : GetInlinedData();
403    DestroyAdapter<A>::DestroyElements(GetAllocator(), data, GetSize());
404    DeallocateIfAllocated();
405  }
406  template <typename T, size_t N, typename A>
407  void Storage<T, N, A>::InitFrom(const Storage& other) {
408    const SizeType<A> n = other.GetSize();
409    ABSL_HARDENING_ASSERT(n > 0);  
410    ConstPointer<A> src;
411    Pointer<A> dst;
412    if (!other.GetIsAllocated()) {
413      dst = GetInlinedData();
414      src = other.GetInlinedData();
415    } else {
416      SizeType<A> requested_capacity = ComputeCapacity(GetInlinedCapacity(), n);
417      Allocation<A> allocation =
418          MallocAdapter<A>::Allocate(GetAllocator(), requested_capacity);
419      SetAllocation(allocation);
420      dst = allocation.data;
421      src = other.GetAllocatedData();
422    }
423    if (absl::is_trivially_copy_constructible<ValueType<A>>::value &&
424        std::is_same<A, std::allocator<ValueType<A>>>::value) {
425      std::memcpy(reinterpret_cast<char*>(dst),
426                  reinterpret_cast<const char*>(src), n * sizeof(ValueType<A>));
427    } else {
428      auto values = IteratorValueAdapter<A, ConstPointer<A>>(src);
429      ConstructElements<A>(GetAllocator(), dst, values, n);
430    }
431    GetSizeAndIsAllocated() = other.GetSizeAndIsAllocated();
432  }
433  template <typename T, size_t N, typename A>
434  template <typename ValueAdapter>
435  auto Storage<T, N, A>::Initialize(ValueAdapter values, SizeType<A> new_size)
436      -> void {
437    ABSL_HARDENING_ASSERT(!GetIsAllocated());
438    ABSL_HARDENING_ASSERT(GetSize() == 0);
439    Pointer<A> construct_data;
440    if (new_size > GetInlinedCapacity()) {
441      SizeType<A> requested_capacity =
442          ComputeCapacity(GetInlinedCapacity(), new_size);
443      Allocation<A> allocation =
444          MallocAdapter<A>::Allocate(GetAllocator(), requested_capacity);
445      construct_data = allocation.data;
446      SetAllocation(allocation);
447      SetIsAllocated();
448    } else {
449      construct_data = GetInlinedData();
450    }
451    ConstructElements<A>(GetAllocator(), construct_data, values, new_size);
452    AddSize(new_size);
453  }
454  template <typename T, size_t N, typename A>
455  template <typename ValueAdapter>
456  auto Storage<T, N, A>::Assign(ValueAdapter values, SizeType<A> new_size)
457      -> void {
458    StorageView<A> storage_view = MakeStorageView();
459    AllocationTransaction<A> allocation_tx(GetAllocator());
460    absl::Span<ValueType<A>> assign_loop;
461    absl::Span<ValueType<A>> construct_loop;
462    absl::Span<ValueType<A>> destroy_loop;
463    if (new_size > storage_view.capacity) {
464      SizeType<A> requested_capacity =
465          ComputeCapacity(storage_view.capacity, new_size);
466      construct_loop = {allocation_tx.Allocate(requested_capacity), new_size};
467      destroy_loop = {storage_view.data, storage_view.size};
468    } else if (new_size > storage_view.size) {
469      assign_loop = {storage_view.data, storage_view.size};
470      construct_loop = {storage_view.data + storage_view.size,
471                        new_size - storage_view.size};
472    } else {
473      assign_loop = {storage_view.data, new_size};
474      destroy_loop = {storage_view.data + new_size, storage_view.size - new_size};
475    }
476    AssignElements<A>(assign_loop.data(), values, assign_loop.size());
477    ConstructElements<A>(GetAllocator(), construct_loop.data(), values,
478                         construct_loop.size());
479    DestroyAdapter<A>::DestroyElements(GetAllocator(), destroy_loop.data(),
480                                       destroy_loop.size());
481    if (allocation_tx.DidAllocate()) {
482      DeallocateIfAllocated();
483      SetAllocation(std::move(allocation_tx).Release());
484      SetIsAllocated();
485    }
486    SetSize(new_size);
487  }
488  template <typename T, size_t N, typename A>
489  template <typename ValueAdapter>
490  auto Storage<T, N, A>::Resize(ValueAdapter values, SizeType<A> new_size)
491      -> void {
492    StorageView<A> storage_view = MakeStorageView();
493    Pointer<A> const base = storage_view.data;
494    const SizeType<A> size = storage_view.size;
495    A& alloc = GetAllocator();
496    if (new_size <= size) {
497      DestroyAdapter<A>::DestroyElements(alloc, base + new_size, size - new_size);
498    } else if (new_size <= storage_view.capacity) {
499      ConstructElements<A>(alloc, base + size, values, new_size - size);
500    } else {
501      AllocationTransaction<A> allocation_tx(alloc);
502      SizeType<A> requested_capacity =
503          ComputeCapacity(storage_view.capacity, new_size);
504      Pointer<A> new_data = allocation_tx.Allocate(requested_capacity);
505      ConstructionTransaction<A> construction_tx(alloc);
506      construction_tx.Construct(new_data + size, values, new_size - size);
507      IteratorValueAdapter<A, MoveIterator<A>> move_values(
508          (MoveIterator<A>(base)));
509      ConstructElements<A>(alloc, new_data, move_values, size);
510      DestroyAdapter<A>::DestroyElements(alloc, base, size);
511      std::move(construction_tx).Commit();
512      DeallocateIfAllocated();
513      SetAllocation(std::move(allocation_tx).Release());
514      SetIsAllocated();
515    }
516    SetSize(new_size);
517  }
518  template <typename T, size_t N, typename A>
519  template <typename ValueAdapter>
520  auto Storage<T, N, A>::Insert(ConstIterator<A> pos, ValueAdapter values,
521                                SizeType<A> insert_count) -> Iterator<A> {
522    StorageView<A> storage_view = MakeStorageView();
523    auto insert_index = static_cast<SizeType<A>>(
524        std::distance(ConstIterator<A>(storage_view.data), pos));
525    SizeType<A> insert_end_index = insert_index + insert_count;
526    SizeType<A> new_size = storage_view.size + insert_count;
527    if (new_size > storage_view.capacity) {
528      AllocationTransaction<A> allocation_tx(GetAllocator());
529      ConstructionTransaction<A> construction_tx(GetAllocator());
530      ConstructionTransaction<A> move_construction_tx(GetAllocator());
531      IteratorValueAdapter<A, MoveIterator<A>> move_values(
532          MoveIterator<A>(storage_view.data));
533      SizeType<A> requested_capacity =
534          ComputeCapacity(storage_view.capacity, new_size);
535      Pointer<A> new_data = allocation_tx.Allocate(requested_capacity);
536      construction_tx.Construct(new_data + insert_index, values, insert_count);
537      move_construction_tx.Construct(new_data, move_values, insert_index);
538      ConstructElements<A>(GetAllocator(), new_data + insert_end_index,
539                           move_values, storage_view.size - insert_index);
540      DestroyAdapter<A>::DestroyElements(GetAllocator(), storage_view.data,
541                                         storage_view.size);
542      std::move(construction_tx).Commit();
543      std::move(move_construction_tx).Commit();
544      DeallocateIfAllocated();
545      SetAllocation(std::move(allocation_tx).Release());
546      SetAllocatedSize(new_size);
547      return Iterator<A>(new_data + insert_index);
548    } else {
549      SizeType<A> move_construction_destination_index =
550          (std::max)(insert_end_index, storage_view.size);
551      ConstructionTransaction<A> move_construction_tx(GetAllocator());
552      IteratorValueAdapter<A, MoveIterator<A>> move_construction_values(
553          MoveIterator<A>(storage_view.data +
554                          (move_construction_destination_index - insert_count)));
555      absl::Span<ValueType<A>> move_construction = {
556          storage_view.data + move_construction_destination_index,
557          new_size - move_construction_destination_index};
558      Pointer<A> move_assignment_values = storage_view.data + insert_index;
559      absl::Span<ValueType<A>> move_assignment = {
560          storage_view.data + insert_end_index,
561          move_construction_destination_index - insert_end_index};
562      absl::Span<ValueType<A>> insert_assignment = {move_assignment_values,
563                                                    move_construction.size()};
564      absl::Span<ValueType<A>> insert_construction = {
565          insert_assignment.data() + insert_assignment.size(),
566          insert_count - insert_assignment.size()};
567      move_construction_tx.Construct(move_construction.data(),
568                                     move_construction_values,
569                                     move_construction.size());
570      for (Pointer<A>
571               destination = move_assignment.data() + move_assignment.size(),
572               last_destination = move_assignment.data(),
573               source = move_assignment_values + move_assignment.size();
574           ;) {
575        --destination;
576        --source;
577        if (destination < last_destination) break;
578        *destination = std::move(*source);
579      }
580      AssignElements<A>(insert_assignment.data(), values,
581                        insert_assignment.size());
582      ConstructElements<A>(GetAllocator(), insert_construction.data(), values,
583                           insert_construction.size());
584      std::move(move_construction_tx).Commit();
585      AddSize(insert_count);
586      return Iterator<A>(storage_view.data + insert_index);
587    }
588  }
589  template <typename T, size_t N, typename A>
590  template <typename... Args>
591  auto Storage<T, N, A>::EmplaceBack(Args&&... args) -> Reference<A> {
592    StorageView<A> storage_view = MakeStorageView();
593    const SizeType<A> n = storage_view.size;
594    if (ABSL_PREDICT_TRUE(n != storage_view.capacity)) {
595      Pointer<A> last_ptr = storage_view.data + n;
596      AllocatorTraits<A>::construct(GetAllocator(), last_ptr,
597                                    std::forward<Args>(args)...);
598      AddSize(1);
599      return *last_ptr;
600    }
601    return EmplaceBackSlow(std::forward<Args>(args)...);
602  }
603  template <typename T, size_t N, typename A>
604  template <typename... Args>
605  auto Storage<T, N, A>::EmplaceBackSlow(Args&&... args) -> Reference<A> {
606    StorageView<A> storage_view = MakeStorageView();
607    AllocationTransaction<A> allocation_tx(GetAllocator());
608    IteratorValueAdapter<A, MoveIterator<A>> move_values(
609        MoveIterator<A>(storage_view.data));
610    SizeType<A> requested_capacity = NextCapacity(storage_view.capacity);
611    Pointer<A> construct_data = allocation_tx.Allocate(requested_capacity);
612    Pointer<A> last_ptr = construct_data + storage_view.size;
613    AllocatorTraits<A>::construct(GetAllocator(), last_ptr,
614                                  std::forward<Args>(args)...);
615    ABSL_INTERNAL_TRY {
616      ConstructElements<A>(GetAllocator(), allocation_tx.GetData(), move_values,
617                           storage_view.size);
618    }
619    ABSL_INTERNAL_CATCH_ANY {
620      AllocatorTraits<A>::destroy(GetAllocator(), last_ptr);
621      ABSL_INTERNAL_RETHROW;
622    }
623    DestroyAdapter<A>::DestroyElements(GetAllocator(), storage_view.data,
624                                       storage_view.size);
625    DeallocateIfAllocated();
626    SetAllocation(std::move(allocation_tx).Release());
627    SetIsAllocated();
628    AddSize(1);
629    return *last_ptr;
630  }
631  template <typename T, size_t N, typename A>
632  auto Storage<T, N, A>::Erase(ConstIterator<A> from, ConstIterator<A> to)
633      -> Iterator<A> {
634    StorageView<A> storage_view = MakeStorageView();
635    auto erase_size = static_cast<SizeType<A>>(std::distance(from, to));
636    auto erase_index = static_cast<SizeType<A>>(
637        std::distance(ConstIterator<A>(storage_view.data), from));
638    SizeType<A> erase_end_index = erase_index + erase_size;
639    IteratorValueAdapter<A, MoveIterator<A>> move_values(
640        MoveIterator<A>(storage_view.data + erase_end_index));
641    AssignElements<A>(storage_view.data + erase_index, move_values,
642                      storage_view.size - erase_end_index);
643    DestroyAdapter<A>::DestroyElements(
644        GetAllocator(), storage_view.data + (storage_view.size - erase_size),
645        erase_size);
646    SubtractSize(erase_size);
647    return Iterator<A>(storage_view.data + erase_index);
648  }
649  template <typename T, size_t N, typename A>
650  auto Storage<T, N, A>::Reserve(SizeType<A> requested_capacity) -> void {
651    StorageView<A> storage_view = MakeStorageView();
652    if (ABSL_PREDICT_FALSE(requested_capacity <= storage_view.capacity)) return;
653    AllocationTransaction<A> allocation_tx(GetAllocator());
654    IteratorValueAdapter<A, MoveIterator<A>> move_values(
655        MoveIterator<A>(storage_view.data));
656    SizeType<A> new_requested_capacity =
657        ComputeCapacity(storage_view.capacity, requested_capacity);
658    Pointer<A> new_data = allocation_tx.Allocate(new_requested_capacity);
659    ConstructElements<A>(GetAllocator(), new_data, move_values,
660                         storage_view.size);
661    DestroyAdapter<A>::DestroyElements(GetAllocator(), storage_view.data,
662                                       storage_view.size);
663    DeallocateIfAllocated();
664    SetAllocation(std::move(allocation_tx).Release());
665    SetIsAllocated();
666  }
667  template <typename T, size_t N, typename A>
668  auto Storage<T, N, A>::ShrinkToFit() -> void {
669    ABSL_HARDENING_ASSERT(GetIsAllocated());
670    StorageView<A> storage_view{GetAllocatedData(), GetSize(),
671                                GetAllocatedCapacity()};
672    if (ABSL_PREDICT_FALSE(storage_view.size == storage_view.capacity)) return;
673    AllocationTransaction<A> allocation_tx(GetAllocator());
674    IteratorValueAdapter<A, MoveIterator<A>> move_values(
675        MoveIterator<A>(storage_view.data));
676    Pointer<A> construct_data;
677    if (storage_view.size > GetInlinedCapacity()) {
678      SizeType<A> requested_capacity = storage_view.size;
679      construct_data = allocation_tx.Allocate(requested_capacity);
680      if (allocation_tx.GetCapacity() >= storage_view.capacity) {
681        return;
682      }
683    } else {
684      construct_data = GetInlinedData();
685    }
686    ABSL_INTERNAL_TRY {
687      ConstructElements<A>(GetAllocator(), construct_data, move_values,
688                           storage_view.size);
689    }
690    ABSL_INTERNAL_CATCH_ANY {
691      SetAllocation({storage_view.data, storage_view.capacity});
692      ABSL_INTERNAL_RETHROW;
693    }
694    DestroyAdapter<A>::DestroyElements(GetAllocator(), storage_view.data,
695                                       storage_view.size);
696    MallocAdapter<A>::Deallocate(GetAllocator(), storage_view.data,
697                                 storage_view.capacity);
698    if (allocation_tx.DidAllocate()) {
699      SetAllocation(std::move(allocation_tx).Release());
700    } else {
701      UnsetIsAllocated();
702    }
703  }
704  template <typename T, size_t N, typename A>
705  auto Storage<T, N, A>::Swap(Storage* other_storage_ptr) -> void {
706    using std::swap;
707    ABSL_HARDENING_ASSERT(this != other_storage_ptr);
708    if (GetIsAllocated() && other_storage_ptr->GetIsAllocated()) {
709      swap(data_.allocated, other_storage_ptr->data_.allocated);
710    } else if (!GetIsAllocated() && !other_storage_ptr->GetIsAllocated()) {
711      SwapInlinedElements(SwapInlinedElementsPolicy{}, other_storage_ptr);
712    } else {
713      Storage* allocated_ptr = this;
714      Storage* inlined_ptr = other_storage_ptr;
715      if (!allocated_ptr->GetIsAllocated()) swap(allocated_ptr, inlined_ptr);
716      StorageView<A> allocated_storage_view{
717          allocated_ptr->GetAllocatedData(), allocated_ptr->GetSize(),
718          allocated_ptr->GetAllocatedCapacity()};
719      IteratorValueAdapter<A, MoveIterator<A>> move_values(
720          MoveIterator<A>(inlined_ptr->GetInlinedData()));
721      ABSL_INTERNAL_TRY {
722        ConstructElements<A>(inlined_ptr->GetAllocator(),
723                             allocated_ptr->GetInlinedData(), move_values,
724                             inlined_ptr->GetSize());
725      }
726      ABSL_INTERNAL_CATCH_ANY {
727        allocated_ptr->SetAllocation(Allocation<A>{
728            allocated_storage_view.data, allocated_storage_view.capacity});
729        ABSL_INTERNAL_RETHROW;
730      }
731      DestroyAdapter<A>::DestroyElements(inlined_ptr->GetAllocator(),
732                                         inlined_ptr->GetInlinedData(),
733                                         inlined_ptr->GetSize());
734      inlined_ptr->SetAllocation(Allocation<A>{allocated_storage_view.data,
735                                               allocated_storage_view.capacity});
736    }
737    swap(GetSizeAndIsAllocated(), other_storage_ptr->GetSizeAndIsAllocated());
738    swap(GetAllocator(), other_storage_ptr->GetAllocator());
739  }
740  template <typename T, size_t N, typename A>
741  void Storage<T, N, A>::SwapN(ElementwiseSwapPolicy, Storage* other,
742                               SizeType<A> n) {
743    std::swap_ranges(GetInlinedData(), GetInlinedData() + n,
744                     other->GetInlinedData());
745  }
746  template <typename T, size_t N, typename A>
747  void Storage<T, N, A>::SwapN(ElementwiseConstructPolicy, Storage* other,
748                               SizeType<A> n) {
749    Pointer<A> a = GetInlinedData();
750    Pointer<A> b = other->GetInlinedData();
751    A& allocator_a = GetAllocator();
752    A& allocator_b = other->GetAllocator();
753    for (SizeType<A> i = 0; i < n; ++i, ++a, ++b) {
754      ValueType<A> tmp(std::move(*a));
755      AllocatorTraits<A>::destroy(allocator_a, a);
756      AllocatorTraits<A>::construct(allocator_b, a, std::move(*b));
757      AllocatorTraits<A>::destroy(allocator_b, b);
758      AllocatorTraits<A>::construct(allocator_a, b, std::move(tmp));
759    }
760  }
761  template <typename T, size_t N, typename A>
762  void Storage<T, N, A>::SwapInlinedElements(MemcpyPolicy, Storage* other) {
763    Data tmp = data_;
764    data_ = other->data_;
765    other->data_ = tmp;
766  }
767  template <typename T, size_t N, typename A>
768  template <typename NotMemcpyPolicy>
769  void Storage<T, N, A>::SwapInlinedElements(NotMemcpyPolicy policy,
770                                             Storage* other) {
771    Storage* small_ptr = this;
772    Storage* large_ptr = other;
773    if (small_ptr->GetSize() > large_ptr->GetSize()) {
774      std::swap(small_ptr, large_ptr);
775    }
776    auto small_size = small_ptr->GetSize();
777    auto diff = large_ptr->GetSize() - small_size;
778    SwapN(policy, other, small_size);
779    IteratorValueAdapter<A, MoveIterator<A>> move_values(
780        MoveIterator<A>(large_ptr->GetInlinedData() + small_size));
781    ConstructElements<A>(large_ptr->GetAllocator(),
782                         small_ptr->GetInlinedData() + small_size, move_values,
783                         diff);
784    DestroyAdapter<A>::DestroyElements(large_ptr->GetAllocator(),
785                                       large_ptr->GetInlinedData() + small_size,
786                                       diff);
787  }
788  #if !defined(__clang__) && defined(__GNUC__)
789  #pragma GCC diagnostic pop
790  #endif
791  }  
792  ABSL_NAMESPACE_END
793  }  
794  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</h3>
            <pre><code>1  void TGUtil::GetCdf(const TIntPrV& PdfV, TIntPrV& CdfV) {
2    CdfV = PdfV;
3    for (int i = 1; i < CdfV.Len(); i++) {
4      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
5  }
6  void TGUtil::GetCdf(const TFltPrV& PdfV, TFltPrV& CdfV) {
7    CdfV = PdfV;
8    for (int i = 1; i < CdfV.Len(); i++) {
9      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
10  }
11  void TGUtil::GetCdf(const TIntFltKdV& PdfV, TIntFltKdV& CdfV) {
12    CdfV = PdfV;
13    for (int i = 1; i < CdfV.Len(); i++) {
14      CdfV[i].Dat = CdfV[i-1].Dat + CdfV[i].Dat; }
<span onclick='openModal()' class='match'>15  }
16  TIntPrV TGUtil::GetCdf(const TIntPrV& PdfV) {
17    TIntPrV CdfV;
18    GetCdf(PdfV, CdfV);
19    return CdfV;
20  }
21  TFltPrV TGUtil::GetCdf(const TFltPrV& PdfV) {
22    TFltPrV CdfV;
23    GetCdf(PdfV, CdfV);
24    return CdfV;
25  }
26  void TGUtil::GetCCdf(const TIntPrV& PdfV, TIntPrV& CCdfV) {
</span>27    CCdfV = PdfV;
28    for (int i = CCdfV.Len()-2; i >= 0; i--) {
29      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
30  }
31  void TGUtil::GetCCdf(const TFltPrV& PdfV, TFltPrV& CCdfV) {
32    CCdfV = PdfV;
33    for (int i = CCdfV.Len()-2; i >= 0; i--) {
34      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
35  }
36  void TGUtil::GetCCdf(const TIntFltKdV& PdfV, TIntFltKdV& CCdfV) {
37    CCdfV = PdfV;
38    for (int i = CCdfV.Len()-2; i >= 0; i--) {
39      CCdfV[i].Dat = CCdfV[i+1].Dat + CCdfV[i].Dat; }
40  }
41  TIntPrV TGUtil::GetCCdf(const TIntPrV& PdfV) {
42    TIntPrV CCdfV;
43    GetCCdf(PdfV, CCdfV);
44    return CCdfV;
45  }
46  TFltPrV TGUtil::GetCCdf(const TFltPrV& PdfV) {
47    TFltPrV CCdfV;
48    GetCCdf(PdfV, CCdfV);
49    return CCdfV;
50  }
51  void TGUtil::GetPdf(const TIntPrV& CdfV, TIntPrV& PdfV) {
52    PdfV = CdfV;
53    for (int i = PdfV.Len()-1; i > 0; i--) {
54      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
55  }
56  void TGUtil::GetPdf(const TFltPrV& CdfV, TFltPrV& PdfV) {
57    PdfV = CdfV;
58    for (int i = PdfV.Len()-1; i > 0; i--) {
59      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
60  }
61  void TGUtil::GetPdf(const TIntFltKdV& CdfV, TIntFltKdV& PdfV) {
62    PdfV = CdfV;
63    for (int i = PdfV.Len()-1; i > 0; i--) {
64      PdfV[i].Dat = PdfV[i].Dat - PdfV[i-1].Dat; }
65  }
66  void TGUtil::Normalize(TFltPrV& PdfV) {
67    double Sum = 0.0;
68    for (int i = 0; i < PdfV.Len(); i++) {
69      Sum += PdfV[i].Val2; }
70    if (Sum <= 0.0) { return; }
71    for (int i = 0; i < PdfV.Len(); i++) {
72      PdfV[i].Val2 /= Sum; }
73  }
74  void TGUtil::Normalize(TIntFltKdV& PdfV) {
75    double Sum = 0.0;
76    for (int i = 0; i < PdfV.Len(); i++) {
77      Sum += PdfV[i].Dat; }
78    if (Sum <= 0.0) { return; }
79    for (int i = 0; i < PdfV.Len(); i++) {
80      PdfV[i].Dat /= Sum; }
81  }
82  void TGUtil::MakeExpBins(const TFltPrV& XYValV, TFltPrV& ExpXYValV, const double& BinFactor, const double& MinYVal) {
83    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
84  }
85  void TGUtil::MakeExpBins(const TFltKdV& XYValV, TFltKdV& ExpXYValV, const double& BinFactor, const double& MinYVal) {
86    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
87  }
88  void TGUtil::MakeExpBins(const TFltV& YValV, TFltV& ExpYValV, const double& BinFactor) {
89    ExpYValV.Clr(true);
90    int prevI=0;
91    for (int i = 0; i < YValV.Len(); ) {
92      ExpYValV.Add(YValV[i]);
93      i = int(i*BinFactor);
94      if (i==prevI) { i++; }
95      prevI = i;
96    }
97  }
98  void TGUtil::MakeExpBins(const TIntV& YValV, TIntV& ExpYValV, const double& BinFactor) {
99    ExpYValV.Clr(true);
100    int prevI=0;
101    for (int i = 0; i < YValV.Len(); ) {
102      ExpYValV.Add(YValV[i]);
103      i = int(i*BinFactor);
104      if (i==prevI) { i++; }
105      prevI = i;
106    }
107  }
108  TChA& TStrUtil::GetXmlTagVal(TXmlLx& XmlLx, const TChA& TagNm) {
109    static TChA TagVal;
110    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
111    EAssertR(TagNm == XmlLx.TagNm.CStr(), TagNm);
112    const TXmlLxSym NextSym = XmlLx.GetSym();
113    TagVal = XmlLx.TxtChA;
114    if (NextSym == xsyStr) {
115      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
116    } else {
117      EAssertR(NextSym == xsyETag, TagNm); 
118    }
119    EAssertR(XmlLx.TagNm == TagNm, TagNm);
120    return TagVal;
121  }
122  void TStrUtil::GetXmlTagNmVal(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal) {
123    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
124    TagNm = XmlLx.TagNm;
125    const TXmlLxSym NextSym = XmlLx.GetSym();
126    TagVal = XmlLx.TxtChA;
127    if (NextSym == xsyStr) {
128      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
129    } else {
130      EAssertR(NextSym == xsyETag, TagNm); 
131    }
132  }
133  bool TStrUtil::GetXmlTagNmVal2(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal, const bool& TakeTagNms) {
134    if (XmlLx.GetSym() != xsySTag) {
135      return false; }
136    TagVal.Clr();
137    TagNm = XmlLx.TagNm;
138    while (XmlLx.Sym != xsyETag || XmlLx.TagNm != TagNm.CStr()) {
139      if (TakeTagNms) {
140        TagVal += XmlLx.TxtChA; }
141      else if (XmlLx.Sym == xsyStr) {
142        TagVal += XmlLx.TxtChA; }
143      XmlLx.GetSym();
144    }
145    return true;
146  }
147  TChA TStrUtil::GetDomNm(const TChA& UrlChA) {
148    int EndSlash = UrlChA.SearchCh('/', 7)-1; 
149    if (EndSlash > 0) {
150      const int BegSlash = UrlChA.SearchChBack('/', EndSlash);
151      if (BegSlash > 0) { return UrlChA.GetSubStr(BegSlash+1, EndSlash).ToLc(); }
152      else { return UrlChA.GetSubStr(0, UrlChA.SearchCh('/', 0)-1).ToLc(); }
153    } else {
154      if (UrlChA.IsPrefix("http:&bsol;&bsol;")) { return UrlChA.GetSubStr(7, UrlChA.Len()-1).ToLc(); }
155      EndSlash = UrlChA.SearchCh('/', 0);
156      if (EndSlash > 0) { return UrlChA.GetSubStr(0, EndSlash-1).ToLc(); }
157      else { return TChA(UrlChA).ToLc(); }
158    }
159  }
160  TChA TStrUtil::GetDomNm2(const TChA& UrlChA) {
161    TChA Dom = GetDomNm(UrlChA);
162    if (Dom.IsPrefix("www.")) { return Dom.GetSubStr(4, TInt::Mx); }
163    else { return Dom; }
164  }
165  int GetNthOccurence(const TChA& Url, const int& Count, const char Ch='/') {
166    const char *c = Url.CStr();
167    int cnt = 0;
168    while (*c && cnt != Count) {
169      if (*c == Ch) { cnt++; }
170      c++;
171    }
172    return int(c-Url.CStr()-1);
173  }
174  TChA TStrUtil::GetWebsiteNm(const TChA& PostUrlStr) {
175    TChA DomNm = TStrUtil::GetDomNm2(PostUrlStr);
176    if (DomNm == "blog.myspace.com") {
177      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 2, '&')-1);
178    }
179    if (DomNm=="blogs.msdn.com" || DomNm=="ameblo.jp" || DomNm=="xfruits.com" || DomNm=="scienceblogs.com" || DomNm=="blogs.sun.com"
180      || DomNm=="blog.wired.com" || DomNm=="weblogs.asp.net" || DomNm=="blogs.technet.com" || DomNm=="blogs.guardian.co"
181      || DomNm=="blogs.clarin.com" || DomNm=="blogs.sun.com" || DomNm=="blog.wired.com" || DomNm=="weblogs.asp.net"
182      || DomNm=="blogs.technet.com" || DomNm=="blogs.guardian.com" || DomNm=="blogs.clarin.com" || DomNm=="blogs.zdnet.com"
183      || DomNm=="blogs.citypages.com" || DomNm=="voices.washingtonpost.com" || DomNm=="blog.tv2.dk"
184      || DomNm=="blogs.menomoneefallsnow.com" || DomNm=="weblogs.baltimoresun.com" || DomNm=="eonline.com") {
185        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1);
186    }
187    if (DomNm == "digg.com") {
188      if (PostUrlStr.IsPrefix("http:&bsol;&bsol;digg.com/submit?")) {
189        const int Url = PostUrlStr.SearchStr(";url=");
190        if (Url != -1) {
191          return GetWebsiteNm(PostUrlStr.GetSubStr(Url+5, PostUrlStr.SearchCh('&', Url+5))); }
192      } else {
193        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1); }
194    }
195    if (PostUrlStr.IsPrefix("http:&bsol;&bsol;nydailynews.com/blogs/") || PostUrlStr.IsPrefix("http:&bsol;&bsol;bbc.co.uk/blogs/")
196      || PostUrlStr.IsPrefix("http:&bsol;&bsol;nydailynews.com/blogs/") || PostUrlStr.IsPrefix("http:&bsol;&bsol;newsbusters.org/blogs/")) {
197      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
198    }
199    if (DomNm=="feeds.feedburner.com") {
200      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
201    }
202    if (DomNm=="groups.google.com") {
203      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
204    }
205    if (DomNm=="news.google.com") { 
206      const int UrlPos = PostUrlStr.SearchStr("&url=");
207      if (UrlPos != -1) {
208        return GetWebsiteNm(PostUrlStr.GetSubStr(UrlPos+5, PostUrlStr.SearchCh('&', UrlPos+5))); }
209    }
210    if (DomNm == "bloggrevyen.no") { 
211      const int Http2 = PostUrlStr.SearchStr("/http:&bsol;&bsol;");
212      if (Http2!=-1) {
213        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+1, PostUrlStr.Len()-1)); }
214    }
215    if (DomNm.IsSuffix(".rd.yahoo.com")) {
216      const int Http2 = PostUrlStr.SearchStr("&bsol;*");
217      if (Http2!=-1) {
218        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+9, PostUrlStr.Len()-1)); }
219    }
220    return DomNm;
221  }
222  bool TStrUtil::GetNormalizedUrl(const TChA& UrlIn, const TChA& BaseUrl, TChA& UrlOut) {
223    UrlOut = UrlIn;
224    if (StripEnd(UrlIn, "/", UrlOut)) {}
225    else if (StripEnd(UrlIn, "/index.html", UrlOut)) {}
226    else if (StripEnd(UrlIn, "/index.htm", UrlOut)) {}
227    else if (StripEnd(UrlIn, "/index.php", UrlOut)) {}
228    if (! (UrlOut.IsPrefix("http:&bsol;&bsol;") || UrlOut.IsPrefix("ftp:&bsol;&bsol;"))) {
229      if (UrlIn.Empty() || ! (BaseUrl.IsPrefix("http:&bsol;&bsol;") || BaseUrl.IsPrefix("ftp:&bsol;&bsol;"))) {
230        return false; }
231      TChA Out;
232      if (! GetNormalizedUrl(BaseUrl, TChA(), Out)) { return false; }
233      if (UrlIn[0] != '/') { Out.AddCh('/'); }
234      Out += UrlOut;
235      UrlOut = Out;
236    }
237    if (UrlOut.IsPrefix("http:&bsol;&bsol;www.")) {
238      UrlOut = TChA("http:&bsol;&bsol;") + UrlOut.GetSubStr(11, TInt::Mx);
239    }
240    UrlOut.ToLc();
241    return true;
242  }
243  bool TStrUtil::StripEnd(const TChA& Str, const TChA& SearchStr, TChA& NewStr) {
244    const int StrLen = Str.Len();
245    const int SearchStrLen = SearchStr.Len();
246    if (StrLen < SearchStrLen) { return false; }
247    for (int i = 0; i < SearchStrLen; i++) {
248      if (Str[StrLen-i-1] != SearchStr[SearchStrLen-i-1]) { return false; }
249    }
250    NewStr = Str.GetSubStr(0, StrLen-SearchStrLen-1);
251    return true;
252  }
253  TChA TStrUtil::GetShorStr(const TChA& LongStr, const int MaxLen) {
254    if (LongStr.Len() < MaxLen) { return LongStr; }
255    TChA Str = LongStr.GetSubStr(0, MaxLen-1);
256    Str += "...";
257    return Str;
258  }
259  TChA TStrUtil::GetCleanWrdStr(const TChA& ChA) {
260    char *b = (char *) ChA.CStr();
261    while (*b && ! TCh::IsAlNum(*b)) { b++; }
262    if (*b == 0) { return TChA(); }
263    TChA OutChA(ChA.Len());
264    char *e = b, tmp;
265    while (*e) {
266      b = e;
267      while (*e && (TCh::IsAlNum(*e) || ((*e=='\'' || *e=='-') && TCh::IsAlNum(*(e+1))))) { e++; }
268      if (b < e) {
269        tmp = *e; *e=0;
270        OutChA += b;  OutChA.AddCh(' ');
271        *e = tmp;
272      }
273      while (*e && ! TCh::IsAlNum(*e)) { e++; }
274      if (! *e) { break; }
275    }
276    OutChA.DelLastCh();  OutChA.ToLc();
277    return OutChA;
278  }
279  TChA TStrUtil::GetCleanStr(const TChA& ChA) {
280    char *b = (char *) ChA.CStr();
281    while (*b && ! TCh::IsAlNum(*b)) { b++; }
282    if (*b == 0) { return TChA(); }
283    TChA OutChA(ChA.Len());
284    char *e = b;
285    bool ws=false;
286    while (*e) {
287      while (*e && TCh::IsWs(*e)) { e++; ws=true; }
288      if (! *e) { break; }
289      if (ws) { OutChA.AddCh(' '); ws=false; }
290      OutChA.AddCh(*e);
291      e++;
292    }
293    return OutChA;
294  }
295  int TStrUtil::CountWords(const TChA& ChA) {
296    return CountWords(ChA.CStr());
297  }
298  int TStrUtil::CountWords(const char* CStr) {
299    int WrdCnt = 1;
300    for (const char *c = CStr; *c; c++) {
301      if (TCh::IsWs(*c)) { WrdCnt++; }
302    }
303    return WrdCnt;
304  }
305  int TStrUtil::CountWords(const TChA& ChA, const TStrHash<TInt>& StopWordH) {
306    TChA Tmp;
307    TVec<char *> WrdV;
308    SplitWords(Tmp, WrdV);
309    int SWordCnt = 0;
310    for (int w = 0; w < WrdV.Len(); w++) {
311      if (StopWordH.IsKey(WrdV[w])) { SWordCnt++; }
312    }
313    return WrdV.Len() - SWordCnt;
314  }
315  int TStrUtil::SplitWords(TChA& ChA, TVec<char *>& WrdV, const bool& SplitOnWs) {
316    WrdV.Clr(false);
317    WrdV.Add(ChA.CStr());
318    for (char *c = (char *) ChA.CStr(); *c; c++) {
319      if ((SplitOnWs && *c == ' ') || (! SplitOnWs && ! TCh::IsAlNum(*c))) {
320        *c = 0;
321        if (! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
322        WrdV.Add(c+1);
323      }
324    }
325    return WrdV.Len();
326  }
327  int TStrUtil::SplitOnCh(TChA& ChA, TVec<char *>& WrdV, const char& Ch, const bool& SkipEmpty) {
328    WrdV.Clr(false);
329    WrdV.Add(ChA.CStr());
330    for (char *c = (char *) ChA.CStr(); *c; c++) {
331      if (*c == Ch) {
332        *c = 0;
333        if (SkipEmpty && ! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
334        WrdV.Add(c+1);
335      }
336    }
337    if (SkipEmpty && ! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
338    return WrdV.Len();
339  }
340  int TStrUtil::SplitLines(TChA& ChA, TVec<char *>& LineV, const bool& SkipEmpty) {
341    LineV.Clr(false);
342    LineV.Add(ChA.CStr());
343    bool IsChs=false;
344    for (char *c = (char *) ChA.CStr(); *c; c++) {
345      if (*c == '\n') {
346        if (c > ChA.CStr() && *(c-1)=='\r') { *(c-1)=0; } 
347        *c=0;
348        if (SkipEmpty) {
349          if (IsChs) { LineV.Add(c+1); }
350        } else {
351          LineV.Add(c+1);
352        }
353        IsChs=false;
354      } else {
355        IsChs=true;
356      }
357    }
358    return LineV.Len();
359  }
360  int TStrUtil::SplitSentences(TChA& ChA, TVec<char *>& SentenceV) {
361    SentenceV.Clr();
362    const char *B = ChA.CStr();
363    const char *E = B+ChA.Len();
364    char *c = (char *) B;
365    while (*c && TCh::IsWs(*c)) { c++; }
366    if (*c) { SentenceV.Add(c); } else { return 0; }
367    for (; c < E; c++) {
368      if (c<E && (*c == '.' || *c == '!' || *c == '?') && ! TCh::IsAlNum(*(c+1))) { 
369        if (c<E && *(c+1)=='"') { *c='"';  c++; } 
370        if (c>=E) { continue; }
371        *c=0;  c++;
372        char *e = c-1;
373        while (e>B && *e!='"' && ! TCh::IsAlNum(*e)) { *e=0; e--; } 
374        while (c<E && ! (TCh::IsAlNum(*c) || (*c=='"' && TCh::IsAlNum(*(c+1))))) { c++; } 
375        if (c<E) { SentenceV.Add(c); }
376      }
377    }
378    return SentenceV.Len();
379  }
380  void TStrUtil::RemoveHtmlTags(const TChA& HtmlStr, TChA& TextStr) {
381    TextStr.Clr();
382    char *StrB, *StrE;
383    StrB = (char *) HtmlStr.CStr();
384    StrE = (char *) StrB+HtmlStr.Len(); 
385    for (char *e = StrB; e < StrE; ) {
386      char* b = e;
387      while (e<StrE && *e != '<') { e++; }
388      char tmp=*e;  *e = 0;
389      TextStr+= b; TextStr.AddCh(' ');  *e = tmp;
390      if (e >= StrE) { return; }
391      if (e[1]=='!' && e[2]=='-' && e[3]=='-') { 
392        e += 3;
393        while(e<StrE && !(*(e-2)=='-' && *(e-1)=='-' && *e=='>')) { e++; }
394        e++;  continue;
395      }
396      if (e[1]=='s' && e[2]=='c' && e[3]=='r' && e[4]=='i' && e[5]=='p' && e[6]=='t') {
397        e += 5;
398        while(e<StrE && !(*(e-6)=='s' && *(e-5)=='c' && *(e-4)=='r' && *(e-3)=='i' && *(e-2)=='p' && *(e-1)=='t' && *e=='>')) { e++; }
399        e++;  continue;
400      }
401      while (e < StrE && *e != '>') { e++; }
402      if (e>=StrE) { return; }
403      e++;
404    }
405  }
406  bool TStrUtil::IsLatinStr(const TChA& Str, const double& MinAlFrac) {
407    int AlNumCnt=0, ChCnt=0;
408    for (const char *c = Str.CStr(); *c; c++) {
409      if (TCh::IsWs(*c)) { continue; }
410      if (*c > 0 && TCh::IsAlNum(*c)) { AlNumCnt++; }
411      ChCnt++;
412    }
413    if (double(AlNumCnt)/double(ChCnt) > MinAlFrac) { return true; }
414    return false;
415  }
416  void TStrUtil::GetWIdV(const TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV) {
417    const int NotWId = -1;
418    TChA ChA(CStr);
419    TVec<char *> WrdV;
420    TInt WId;
421    TStrUtil::SplitWords(ChA, WrdV);
422    WIdV.Clr(false);
423    for (int w = 0; w < WrdV.Len(); w++) {
424      if (StrH.IsKeyGetDat(WrdV[w], WId)) { WIdV.Add(WId); }
425      else { WIdV.Add(NotWId); }
426    }
427  }
428  void TStrUtil::GetAddWIdV(TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV) {
429    TChA ChA(CStr);
430    TVec<char *> WrdV;
431    TInt WId;
432    TStrUtil::SplitWords(ChA, WrdV);
433    WIdV.Clr(false);
434    for (int w = 0; w < WrdV.Len(); w++) {
435      WIdV.Add(StrH.AddDatId(WrdV[w]));
436    }
437  }
438  bool TStrUtil::GetTmFromStr(const char* TmStr, TSecTm& Tm) {
439    static TStrV MonthV1, MonthV2;
440    if (MonthV1.Empty()) {
441      TStr("january|february|march|april|may|june|july|august|september|october|november|december").SplitOnAllCh('|', MonthV1);
442      TStr("jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec").SplitOnAllCh('|', MonthV2);
443    }
444    TChA Tmp(TmStr);
445    Tmp.ToLc();
446    TVec<char *> WrdV;
447    const char* End = Tmp.CStr()+Tmp.Len();
448    int Col = -1, Cols=0;
449    for (char *b = Tmp.CStr(); b <End; ) {
450      WrdV.Add(b);
451      while (*b && ! (*b==' ' || *b=='-' || *b==':' || *b==',')) { b++; }
452      if (*b==':') { if(Col==-1) { Col=WrdV.Len(); } Cols++;  }
453      *b=0; b++;
454      while (*b && (*b==' ' || *b=='-' || *b==':' || *b==',')) { b++; }
455    }
456    if (Cols == 2) {
457      if (Col+1 >= WrdV.Len()) { return false; }
458      WrdV.Del(Col+1);
459    }
460    if (Col<1) { return false; }
461    const int Hr = atoi(WrdV[Col-1]);
462    const int Min = atoi(WrdV[Col]);
463    WrdV.Del(Col);  WrdV.Del(Col-1);
464    if (WrdV.Len() != 3) { return false; }
465    int y=0,m=1,d=2, Mon=-1;
466    if (TCh::IsAlpha(WrdV[0][0])) {
467      y=2; m=0; d=1;
468    } else if (TCh::IsAlpha(WrdV[1][0])) {
469      y=2; m=1; d=0;
470    } else if (TCh::IsAlpha(WrdV[2][0])) {
471      y=0; m=2; d=1;
472    } else {
473      y=0; m=1; d=2;
474      Mon = atoi(WrdV[m]);
475    }
476    int Day = atoi(WrdV[d]);
477    if (Mon <= 0) { Mon = MonthV1.SearchForw(WrdV[m])+1; }
478    if (Mon <= 0) { Mon = MonthV2.SearchForw(WrdV[m])+1; }
479    if (Mon == 0) { return false; }
480    int Year = atoi(WrdV[y]);
481    if (Day > Year) { ::Swap(Day, Year); }
482    Tm = TSecTm(Year, Mon, Day, Hr, Min, 0);
483    return true;
484  }
485  TStr TStrUtil::GetStdName(TStr AuthorName) {
486    TStr StdName;
487    AuthorName.ToLc();
488    AuthorName.ChangeChAll('\n', ' ');
489    AuthorName.ChangeChAll('.', ' ');
490    int i, pos = 0;
491    while (pos<AuthorName.Len() && (AuthorName[pos]!='#' && !TCh::IsNum(AuthorName[pos]))) {
492      pos++; }
493    if (pos < AuthorName.Len()) {
494      AuthorName = AuthorName.GetSubStr(0, pos-1).ToTrunc(); }
495    if (AuthorName.Empty()) { return TStr::GetNullStr(); }
496    int b = AuthorName.SearchCh('(');
497    if (b != -1) {
498      AuthorName = AuthorName.GetSubStr(0, b-1).ToTrunc(); }
499    if (AuthorName .SearchCh(')')!=-1) { return TStr::GetNullStr(); }
500    if (AuthorName .SearchStr("figures")!=-1 || AuthorName .SearchStr("macros")!=-1
501     || AuthorName .SearchStr("univ")!=-1 || AuthorName .SearchStr("institute")!=-1) {
502      return TStr::GetNullStr();
503    }
504    TChA NewName;
505    for (i = 0; i < AuthorName.Len(); i++) {
506      const char Ch = AuthorName[i];
507      if (TCh::IsAlpha(Ch) || TCh::IsWs(Ch) || Ch=='-') { NewName += Ch; }
508    }
509    StdName = NewName;  StdName.ToTrunc();
510    TStrV AuthNmV; StdName.SplitOnWs(AuthNmV);
511    if (! AuthNmV.Empty() && AuthNmV.Last() == "jr") AuthNmV.DelLast();
512    if (AuthNmV.Len() < 2) return TStr::GetNullStr();
513    const TStr LastNm = AuthNmV.Last();
514    if (! TCh::IsAlpha(LastNm[0]) || LastNm.Len() == 1) return TStr::GetNullStr();
515    IAssert(isalpha(AuthNmV[0][0]));
516    return TStr::Fmt("%s_%c", LastNm.CStr(), AuthNmV[0][0]);
517  }
518  void TStrUtil::GetStdNameV(TStr AuthorNames, TStrV& StdNameV) {
519    AuthorNames.ChangeChAll('\n', ' ');
520    AuthorNames.ToLc();
521    TStrV AuthV, TmpV, Tmp2V;
522    AuthorNames.SplitOnStr(" and ", TmpV);
523    int i;
524    for (i = 0; i < TmpV.Len(); i++) {
525      TmpV[i].SplitOnAllCh(',', Tmp2V);  AuthV.AddV(Tmp2V); }
526    TmpV = AuthV;  AuthV.Clr();
527    for (i = 0; i < TmpV.Len(); i++) {
528      TmpV[i].SplitOnAllCh('&', Tmp2V);  AuthV.AddV(Tmp2V); }
529    TmpV = AuthV;  AuthV.Clr();
530    for (i = 0; i < TmpV.Len(); i++) {
531      TmpV[i].SplitOnAllCh(',', Tmp2V);  AuthV.AddV(Tmp2V); }
532    TmpV = AuthV;  AuthV.Clr();
533    for (i = 0; i < TmpV.Len(); i++) {
534      TmpV[i].SplitOnAllCh(';', Tmp2V);  AuthV.AddV(Tmp2V); }
535    StdNameV.Clr();
536    for (i = 0; i < AuthV.Len(); i++) {
537      TStr StdName = GetStdName(AuthV[i]);
538      if (! StdName.Empty()) {
539        StdNameV.Add(StdName);
540      }
541    }
542  }
543  double TStopwatch::Tick() {
544  #ifdef USE_OPENMP
545    return omp_get_wtime();
546  #else
547  #ifdef GLib_WIN32
548    return GetTickCount() / 1000.0;
549  #else
550    struct rusage rusage;
551    getrusage(RUSAGE_SELF, &rusage);
552    float cputime =
553    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
554    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
555    return cputime;
556  #endif
557  #endif
558  }
559  void TStopwatch::Start(const TExperiment Exp) {
560    Starts[Exp] = Tick();
561  }
562  void TStopwatch::Stop(const TExperiment Exp) {
563    double Duration = Tick() - Starts[Exp];
564    Sums[Exp] += Duration;
565    Maxs[Exp] = Maxs[Exp] >= Duration ? Maxs[Exp] : Duration;
566    Mins[Exp] = Mins[Exp] <= Duration ? Mins[Exp] : Duration;
567    Cnts[Exp]++;
568  }
569  int TStopwatch::Cnt(const TExperiment Exp) const {
570    return Cnts[Exp];
571  }
572  double TStopwatch::Sum(const TExperiment Exp) const {
573    return Sums[Exp];
574  }
575  double TStopwatch::Avg(const TExperiment Exp) const {
576    return Sums[Exp] / Cnts[Exp];
577  }
578  double TStopwatch::Max(const TExperiment Exp) const {
579    return Maxs[Exp];
580  }
581  double TStopwatch::Min(const TExperiment Exp) const {
582    return Mins[Exp];
583  }
584  #if defined(SW_WRITEN)
585  int WriteN(int fd, char *ptr, int nbytes) {
586    int nleft;
587    int nwritten;
588    nleft = nbytes;
589    while (nleft > 0) {
590      nwritten = (int) write(fd, ptr, nleft);
591      if (nwritten <= 0) {
592        return nwritten;
593      }
594      nleft -= nwritten;
595      ptr += nwritten;
596    }
597    return (nbytes-nleft);
598  }
599  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_18.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</div>
                <div class="column column_space"><pre><code>289    }
290    ConstPointer<A> GetInlinedData() const {
291      return reinterpret_cast<ConstPointer<A>>(
292          std::addressof(data_.inlined.inlined_data[0]));
293    }
294    SizeType<A> GetAllocatedCapacity() const {
295      return data_.allocated.allocated_capacity;
296    }
297    SizeType<A> GetInlinedCapacity() const {
</pre></code></div>
                <div class="column column_space"><pre><code>15  }
16  TIntPrV TGUtil::GetCdf(const TIntPrV& PdfV) {
17    TIntPrV CdfV;
18    GetCdf(PdfV, CdfV);
19    return CdfV;
20  }
21  TFltPrV TGUtil::GetCdf(const TFltPrV& PdfV) {
22    TFltPrV CdfV;
23    GetCdf(PdfV, CdfV);
24    return CdfV;
25  }
26  void TGUtil::GetCCdf(const TIntPrV& PdfV, TIntPrV& CCdfV) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    