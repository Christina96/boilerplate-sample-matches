
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.947282386595832%, Tokens: 13</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmdirected.h</h3>
            <pre><code>1  #ifndef yanglib_agmdirected_h
2  #define yanglib_agmdirected_h
3  #include "Snap.h"
4  #include "agm.h"
5  #include "agmfast.h"
6  class TCoda { 
7  private:
8    PNGraph G; 
9    TVec<TIntFltH> F; 
10    TVec<TIntFltH> H; 
11    TRnd Rnd; 
12    TIntV NIDV; 
13    TFlt RegCoef; 
14    TFltV SumFV; 
15    TFltV SumHV; 
16    TBool NodesOk; 
17    TInt NumComs; 
18    TVec<TIntSet> HOVIDSV; 
19  public:
20    TFlt MinVal; 
21    TFlt MaxVal; 
22    TFlt NegWgt; 
23    TFlt PNoCom; 
24    TBool DoParallel; 
25    TCoda(const PNGraph& GraphPt, const int& InitComs, const int RndSeed = 0): Rnd(RndSeed), RegCoef(0), 
26      NodesOk(true), MinVal(0.0), MaxVal(1000.0), NegWgt(1.0) { SetGraph(GraphPt); RandomInit(InitComs); }
27    TCoda() { G = TNGraph::New(); }
28    void SetGraph(const PNGraph& GraphPt);
29    PNGraph GetGraph() { return G; }
30    PNGraph GetGraphRawNID();
31    void SetRegCoef(const double _RegCoef) { RegCoef = _RegCoef; }
32    double GetRegCoef() { return RegCoef; }
33    void RandomInit(const int InitComs);
34    int GetNumComs() { return NumComs.Val; }
35    void NeighborComInit(const int InitComs);
36    void NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs);
37    void SetCmtyVV(const TVec<TIntV>& CmtyVVOut, const TVec<TIntV>& CmtyVVIn);
38    double Likelihood(const bool DoParallel = false);
39    double LikelihoodForNode(const bool IsRow, const int UID);
40    double LikelihoodForNode(const bool IsRow, const int UID, const TIntFltH& FU);
41    void GetNonEdgePairScores(TFltIntIntTrV& ScoreV);
42    void GetNIDValH(TIntFltH& NIdValInOutH, TIntFltH& NIdValOutH, TIntFltH& NIdValInH, const int CID, const double Thres);
43    void DumpMemberships(const TStr& OutFNm, const TStrHash<TInt>& NodeNameH) { DumpMemberships(OutFNm, NodeNameH, sqrt(PNoCom)); }
44    void DumpMemberships(const TStr& OutFNm, const TStrHash<TInt>& NodeNameH, const double Thres);
45    void GetCmtyS(TIntSet& CmtySOut, TIntSet& CmtySIn, const int CID, const double Thres);
46    void DumpMemberships(const TStr& OutFNm, const double Thres);
47    void DumpMemberships(const TStr& OutFNm) { DumpMemberships(OutFNm, sqrt(PNoCom)); }
48    void GetCommunity(TIntV& CmtyVIn, TIntV& CmtyVOut, const int CID) { GetCommunity(CmtyVIn, CmtyVOut, CID, sqrt(PNoCom)); }
49    void GetCommunity(TIntV& CmtyVIn, TIntV& CmtyVOut, const int CID, const double Thres);
50    void GetTopCIDs(TIntV& CIdV, const int TopK, const int IsAverage = 1, const int MinSz = 1);
51    void GradientForNode(const bool IsRow, const int UID, TIntFltH& GradU, const TIntSet& CIDSet);
52    void SetHoldOut(const double HOFrac) { TVec<TIntSet> HoldOut; TAGMFastUtil::GenHoldOutPairs(G, HoldOut, HOFrac, Rnd); HOVIDSV = HoldOut; }
53    void GetCmtyVV(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn, const int MinSz = 3);
54    void GetCmtyVV(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn, const double ThresOut, const double ThresIn, const int MinSz = 3);
55    void GetCmtyVV(const bool IsOut, TVec<TIntV>& CmtyVV);
56    void GetCmtyVV(const bool IsOut, TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
57    void GetCmtyVVUnSorted(const bool IsOut, TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
58    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn);
59    int FindComsByCV(TIntV& ComsV, const double HOFrac = 0.2, const int NumThreads = 20, const TStr PlotLFNm = TStr(), const int EdgesForCV = 100, const double StepAlpha = 0.3, const double StepBeta = 0.1);
60    int FindComsByCV(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const int EdgesForCV = 100, const double StepAlpha = 0.3, const double StepBeta = 0.3);
61    double LikelihoodHoldOut(const bool DoParallel = false);
62    double GetStepSizeByLineSearch(const bool IsRow, const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10);
63    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
64    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
65    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const TStr PlotNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1) {
66      int ChunkSize = G->GetNodes() / 10 / ChunkNum;
67      if (ChunkSize == 0) { ChunkSize = 1; }
68      return MLEGradAscentParallel(Thres, MaxIter, ChunkNum, ChunkSize, PlotNm, StepAlpha, StepBeta);
69    }
70    void Save(TSOut& SOut);
71    void Load(TSIn& SIn, const int& RndSeed = 0);
72    TFlt& GetSumVal(const bool IsOut, const int CID) { 
73      if (IsOut) {
74        return SumFV[CID];
75      } else {
76        return SumHV[CID];
77      }
78    }
79    double inline GetCom(const bool IsOut, const int& NID, const int& CID) {
80      if (IsOut) {
81        return GetComOut(NID, CID);
82      } else {
83        return GetComIn(NID, CID);
84      }
85    }
86    double inline GetComOut(const int& NID, const int& CID) {
87      if (F[NID].IsKey(CID)) {
88        return F[NID].GetDat(CID);
89      } else {
90        return 0.0;
91      }
92    }
93    double inline GetComIn(const int& NID, const int& CID) {
94      if (H[NID].IsKey(CID)) {
95        return H[NID].GetDat(CID);
96      } else {
97        return 0.0;
98      }
99    }
100    void inline AddCom(const bool IsOut, const int& NID, const int& CID, const double& Val) {
101      if (IsOut) {
102        AddComOut(NID, CID, Val);
103      } else {
104        AddComIn(NID, CID, Val);
105      }
106    }
107    void inline AddComOut(const int& NID, const int& CID, const double& Val) {
108      if (F[NID].IsKey(CID)) {
109        SumFV[CID] -= F[NID].GetDat(CID);
110      }
111      F[NID].AddDat(CID) = Val;
112      SumFV[CID] += Val;
113    }
114    void inline AddComIn(const int& NID, const int& CID, const double& Val) {
115      if (H[NID].IsKey(CID)) {
116        SumHV[CID] -= H[NID].GetDat(CID);
117      }
118      H[NID].AddDat(CID) = Val;
119      SumHV[CID] += Val;
120    }
121    void inline DelCom(const bool IsOut, const int& NID, const int& CID) {
122      if (IsOut) {
123        return DelComOut(NID, CID);
124      } else {
125        return DelComIn(NID, CID);
126      }
127    }
128    void inline DelComOut(const int& NID, const int& CID) {
129      if (F[NID].IsKey(CID)) {
130        SumFV[CID] -= F[NID].GetDat(CID);
131        F[NID].DelKey(CID);
132      }
133    }
134    void inline DelComIn(const int& NID, const int& CID) {
135      if (H[NID].IsKey(CID)) {
136        SumHV[CID] -= H[NID].GetDat(CID);
137        H[NID].DelKey(CID);
138      }
139    }
140    double inline DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
141      double DP = 0;
142      if (UV.Len() > VV.Len()) {
143        for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
144          if (VV.IsKey(HI.GetKey())) { 
145            DP += VV.GetDat(HI.GetKey()) * HI.GetDat(); 
146          }
147        }
148      } else {
149        for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
150          if (UV.IsKey(HI.GetKey())) { 
151            DP += UV.GetDat(HI.GetKey()) * HI.GetDat(); 
152          }
153        }
154      }
155      return DP;
156    }
157    double inline DotProductUtoV(const int& UID, const int& VID) {
158      return DotProduct(F[UID], H[VID]);
159    }
160    double inline Prediction(const TIntFltH& FU, const TIntFltH& HV) {
161      double DP = log (1.0 / (1.0 - PNoCom)) + DotProduct(FU, HV);
162      IAssertR(DP > 0.0, TStr::Fmt("DP: %f", DP));
163      return exp(- DP);
164    }
165    double inline Prediction(const int& UID, const int& VID) {
166      return Prediction(F[UID], H[VID]);
167    }
168    double inline Sum(const TIntFltH& UV) {
169      double N = 0.0;
170      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
171        N += HI.GetDat();
172      }
173      return N;
174    }
175    double inline Norm2(const TIntFltH& UV) {
176      double N = 0.0;
177      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
178        N += HI.GetDat() * HI.GetDat();
179      }
180      return N;
181    }
182  };
183  class TCodaAnalyzer {
184  public:
185    PNGraph G;
186    TVec<TIntFltH> InCmtyValHV;
187    TVec<TIntFltH> OutCmtyValHV;
188    TVec<TIntFltH> InOutCmtyValHV;
189    TCodaAnalyzer() { G = TNGraph::New(); }
190    TCodaAnalyzer(TCoda& Coda, const double MemThres = -1.0) {
191      G = Coda.GetGraphRawNID();
192      printf("graph copied (%d nodes %d edges)\n", G->GetNodes(), G->GetEdges());
193      TIntV CIdV;
194      Coda.GetTopCIDs(CIdV, Coda.GetNumComs());
195      double Delta = MemThres == -1.0 ? sqrt(Coda.PNoCom): MemThres;
196      for (int c = 0; c < CIdV.Len(); c++) {
197        int CID = CIdV[c];
198        TIntFltH InMemH, OutMemH, InOutMemH;
199        Coda.GetNIDValH(InOutMemH, OutMemH, InMemH, CID, Delta);
200        InCmtyValHV.Add(InMemH);
201        OutCmtyValHV.Add(OutMemH);
202        InOutCmtyValHV.Add(InOutMemH);
203      }
204      printf("Communities copied (%d communities)\n", InCmtyValHV.Len());
205    }
206    void GetAllCmtyVV(TVec<TIntV>& CmtyVV, const int MinSz) {
207      for (int c = 0; c < InCmtyValHV.Len(); c++) {
208        TIntV CmtyVIn, CmtyVOut, CmtyVInOut;
209        if (InCmtyValHV[c].Len() < MinSz || OutCmtyValHV[c].Len() < MinSz) { continue; }
210        InOutCmtyValHV[c].GetKeyV(CmtyVInOut);
211        InCmtyValHV[c].GetKeyV(CmtyVIn);
212        OutCmtyValHV[c].GetKeyV(CmtyVOut);
213        CmtyVV.Add(CmtyVInOut);
214        CmtyVV.Add(CmtyVOut);
215        CmtyVV.Add(CmtyVIn);
216      }
217    }
218    double GetFrac2Mode(const double Thres2Mode = 0.2, const int MinSzEach = 2) {
219      int Cnt2Mode = 0;
220      int CntAll = 0;
221      for (int c = 0; c < InCmtyValHV.Len(); c++) {
222        double Jacc = (double) InOutCmtyValHV[c].Len() / (double) (InCmtyValHV[c].Len() + OutCmtyValHV[c].Len() - InOutCmtyValHV[c].Len());
223        if (InCmtyValHV[c].Len() < MinSzEach || OutCmtyValHV[c].Len() < MinSzEach) { continue; }
224        if (Jacc <= Thres2Mode) { Cnt2Mode++; }
225        CntAll++;
226      }
227      return (double) Cnt2Mode / (double) CntAll;
228    }
229    void Summary(const int TopK = 10, const double Thres2Mode = 0.2) {
230      int Cnt2Mode = 0;
231      double SumJacc = 0.0;
232      for (int c = 0; c < InCmtyValHV.Len(); c++) {
233        double Jacc = (double) InOutCmtyValHV[c].Len() / (double) (InCmtyValHV[c].Len() + OutCmtyValHV[c].Len() - InOutCmtyValHV[c].Len());
234        if (Jacc <= Thres2Mode) { Cnt2Mode++; }
235        SumJacc += Jacc;
236        if (c < TopK) {
237          printf("Cmty %d: InOut: %d, In:%d, Out:%d, Jacc;%.3f\n", c, InCmtyValHV[c].Len(), InCmtyValHV[c].Len(), OutCmtyValHV[c].Len(), Jacc);
238        }
239      }
240      double AvgJacc = SumJacc / (double) InCmtyValHV.Len();
241      printf("Average jaccard similarity = %.3f. (%d / %d communities are 2-mode)\n", AvgJacc, Cnt2Mode, InCmtyValHV.Len());
242    }
243    int GetNumComs() { return InCmtyValHV.Len(); }
244    void GetCmtyVAll(TIntV& CmtyVAll, const int CID) {
245      TIntV CmtyVIn, CmtyVOut;
246      InCmtyValHV[CID].GetKeyV(CmtyVIn);
247      OutCmtyValHV[CID].GetKeyV(CmtyVOut);
248      CmtyVIn.Sort();
249      CmtyVOut.Sort();
250      CmtyVAll.Gen(CmtyVIn.Len() + CmtyVOut.Len(), 0);
251      CmtyVIn.Union(CmtyVOut, CmtyVAll);
252    }
253    PNGraph Net2ModeCommunities(const double MaxJac, const double JacEdge, const bool GetWcc = true) {
254      int Coms = InCmtyValHV.Len();
255      PNGraph ComG = TNGraph::New(Coms, -1);
256      for (int c = 0; c < InCmtyValHV.Len(); c++) {
257        double Jacc = (double) InOutCmtyValHV[c].Len() / (double) (InCmtyValHV[c].Len() + OutCmtyValHV[c].Len() - InOutCmtyValHV[c].Len());
<span onclick='openModal()' class='match'>258        if (Jacc > MaxJac) { continue; }
259        ComG->AddNode(c);
260      }
261      TVec<TIntSet> CmtySVIn, CmtySVOut;
262      for (int c = 0; c < Coms; c++) {
263        TIntV CmtyVIn, CmtyVOut;
264        InCmtyValHV[c].GetKeyV(CmtyVIn);
265        OutCmtyValHV[c].GetKeyV(CmtyVOut);
266        TIntSet CmtySIn(CmtyVIn), CmtySOut(CmtyVOut);
267        CmtySVIn.Add(CmtySIn);
268        CmtySVOut.Add(CmtySOut);
269      }
270      for (int c1 = 0; c1 < Coms; c1++) {
</span>271        if (! ComG->IsNode(c1)) { continue; }
272        for (int c2 = 0; c2 < Coms; c2++) {
273          if (! ComG->IsNode(c2)) { continue; }
274          int IntC1C2 = TAGMUtil::Intersection(CmtySVIn[c1], CmtySVOut[c2]);
275          double Jac = (double) IntC1C2 / (CmtySVIn[c1].Len() + CmtySVOut[c2].Len() - IntC1C2);
276          if (Jac >= JacEdge) {
277            ComG->AddEdge(c1, c2);
278          }
279        }
280      }
281      TIntV NIDV;
282      ComG->GetNIdV(NIDV);
283      for (int u = 0; u < NIDV.Len(); u++) {
284        int NID = NIDV[u];
285        TNGraph::TNodeI NI = ComG->GetNI(NID);
286        if (NI.GetDeg() == 0) { ComG->DelNode(NID); }
287        if (NI.GetInDeg() == 1 && NI.GetOutDeg() == 1 && NI.GetOutNId(0) == NID) { ComG->DelNode(NID); }
288      }
289      printf("Community graph made (Jaccard similarity for edges: %f, %d nodes, %d edges)\n", JacEdge, ComG->GetNodes(), ComG->GetEdges());
290      return ComG;
291    }
292    void Dump2ModeCommunities(const TStr& OutFNm, const double MaxJac, const TIntStrH& NIDNameH) {
293      FILE* F = fopen(OutFNm.CStr(), "wt");
294      for (int c = 0; c < InCmtyValHV.Len(); c++) {
295        double Jacc = (double) InOutCmtyValHV[c].Len() / (double) (InCmtyValHV[c].Len() + OutCmtyValHV[c].Len() - InOutCmtyValHV[c].Len());
296        if (Jacc > MaxJac) { continue; }
297        TIntV CmtyVIn, CmtyVOut, CmtyVAll;
298        InCmtyValHV[c].GetKeyV(CmtyVIn);
299        OutCmtyValHV[c].GetKeyV(CmtyVOut);
300        GetCmtyVAll(CmtyVAll, c);
301        for (int u = 0; u < InOutCmtyValHV[c].Len(); u++) {
302          int UID = InOutCmtyValHV[c].GetKey(u);
303          if (CmtyVIn.Len() >= CmtyVOut.Len()) {
304            CmtyVIn.DelIfIn(UID); 
305          } else {
306            CmtyVOut.DelIfIn(UID); 
307          }
308        }
309        if (CmtyVAll.Len() == 0) { continue; }
310        fprintf(F, "Com %d\n", c);
311        for (int u = 0; u < CmtyVOut.Len(); u++) {
312          int NID = CmtyVOut[u];
313          TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): TStr::Fmt("Concept %d", NID);
314          fprintf(F, "%s:%f\n", Label.CStr(), OutCmtyValHV[c].GetDat(NID).Val);
315        }
316        fprintf(F, "||==>||\n");
317        for (int u = 0; u < CmtyVIn.Len(); u++) {
318          int NID = CmtyVIn[u];
319          TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): TStr::Fmt("Concept %d", NID);
320          fprintf(F, "%s:%f\n", Label.CStr(), InCmtyValHV[c].GetDat(NID).Val);
321        }
322        fprintf(F, "\n");
323      }
324      fclose(F);
325    }
326    void Draw2ModeCommunity(const int CID, const TStr& OutFNm, const TIntStrH& NIDNameH, const THash<TInt, TIntTr>& NIDColorH) {
327      TIntV CmtyVIn, CmtyVOut, CmtyVAll;
328      InCmtyValHV[CID].GetKeyV(CmtyVIn);
329      OutCmtyValHV[CID].GetKeyV(CmtyVOut);
330      GetCmtyVAll(CmtyVAll, CID);
331      for (int u = 0; u < InOutCmtyValHV[CID].Len(); u++) {
332        int UID = InOutCmtyValHV[CID].GetKey(u);
333        if (CmtyVIn.Len() >= CmtyVOut.Len()) {
334          CmtyVIn.DelIfIn(UID); 
335        } else {
336          CmtyVOut.DelIfIn(UID); 
337        }
338      }
339      PNGraph SG = TSnap::GetSubGraph(G, CmtyVAll);
340      if (CmtyVAll.Len() == 0) { return; }
341      double OXMin = 0.1, YMin = 0.1, OXMax = 2500.00, YMax = 1000.0, IXMin = 0.1, IXMax = 2500.00;
342      double OStep = (OXMax - OXMin) / (double) CmtyVOut.Len(), IStep = (IXMax - IXMin) / (double) CmtyVIn.Len();
343      FILE* F = fopen(OutFNm.CStr(), "wt");
344      fprintf(F, "<?xml version='1.0' encoding='UTF-8'?>\n");
345      fprintf(F, "<gexf xmlns='http:&bsol;&bsol;www.gexf.net/1.2draft' xmlns:viz='http:&bsol;&bsol;www.gexf.net/1.1draft/viz' xmlns:xsi='http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance' xsi:schemaLocation='http:&bsol;&bsol;www.gexf.net/1.2draft http:&bsol;&bsol;www.gexf.net/1.2draft/gexf.xsd' version='1.2'>\n");
346      fprintf(F, "\t<graph mode='static' defaultedgetype='directed'>\n");
347      fprintf(F, "\t\t<nodes>\n");
348      for (int c = 0; c < CmtyVOut.Len(); c++) {
349        int NID = CmtyVOut[c];
350        double XPos = c * OStep + OXMin;
351        TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): "";
352        Label.ChangeChAll('<', ' ');
353        Label.ChangeChAll('>', ' ');
354        Label.ChangeChAll('&', ' ');
355        Label.ChangeChAll('\'', ' ');
356        TIntTr Color = NIDColorH.IsKey(NID)? NIDColorH.GetDat(NID) : TIntTr(120, 120, 120);
357        fprintf(F, "\t\t\t<node id='%d' label='%s'>\n", NID, Label.CStr());
358        fprintf(F, "\t\t\t\t<viz:color r='%d' g='%d' b='%d'/>\n", Color.Val1.Val, Color.Val2.Val, Color.Val3.Val);
359        fprintf(F, "\t\t\t\t<viz:size value='4.0'/>\n");
360        fprintf(F, "\t\t\t\t<viz:shape value='square'/>\n");
361        fprintf(F, "\t\t\t\t<viz:position x='%f' y='%f' z='0.0'/>\n", XPos, YMax); 
362        fprintf(F, "\t\t\t</node>\n");
363      }
364      for (int u = 0; u < CmtyVIn.Len(); u++) {
365        int NID = CmtyVIn[u];
366        TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): "";
367        Label.ChangeChAll('<', ' ');
368        Label.ChangeChAll('>', ' ');
369        Label.ChangeChAll('&', ' ');
370        Label.ChangeChAll('\'', ' ');
371        double XPos = IXMin + u * IStep;
372        TIntTr Color = NIDColorH.IsKey(NID)? NIDColorH.GetDat(NID) : TIntTr(120, 120, 120);
373        double Alpha = 1.0;
374        fprintf(F, "\t\t\t<node id='%d' label='%s'>\n", NID, Label.CStr());
375        fprintf(F, "\t\t\t\t<viz:color r='%d' g='%d' b='%d' a='%.1f'/>\n", Color.Val1.Val, Color.Val2.Val, Color.Val3.Val, Alpha);
376        fprintf(F, "\t\t\t\t<viz:size value='4.0'/>\n");
377        fprintf(F, "\t\t\t\t<viz:shape value='square'/>\n");
378        fprintf(F, "\t\t\t\t<viz:position x='%f' y='%f' z='0.0'/>\n", XPos, YMin); 
379        fprintf(F, "\t\t\t</node>\n");
380      }
381      fprintf(F, "\t\t</nodes>\n");
382      int EID = 0;
383      fprintf(F, "\t\t<edges>\n");
384      for (TNGraph::TNodeI NI = SG->BegNI(); NI < SG->EndNI(); NI++) {
385        if (NI.GetOutDeg() == 0 && NI.GetInDeg() == 0  ) { continue; }
386        for (int e = 0; e < NI.GetOutDeg(); e++) {
387          fprintf(F, "\t\t\t<edge id='%d' source='%d' target='%d'/>\n", EID++, NI.GetId(), NI.GetOutNId(e));
388        }
389      }
390      fprintf(F, "\t\t</edges>\n");
391      fprintf(F, "\t</graph>\n");
392      fprintf(F, "</gexf>\n");
393      fclose(F);
394    }
395  };
396  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</h3>
            <pre><code>1  TTimeNet& TTimeNet::operator = (const TTimeNet& TimeNet) {
2    if (this != &TimeNet) {
3      TNet::operator=(TimeNet);
4    }
5    return *this;
6  }
7  PTimeNet TTimeNet::GetSubGraph(const TIntV& NIdV) const {
8    PTimeNet NewNetPt = TTimeNet::New();
9    TTimeNet& NewNet = *NewNetPt;
10    NewNet.Reserve(NIdV.Len(), -1);
11    int node, edge;
12    TNodeI NI;
13    for (node = 0; node < NIdV.Len(); node++) {
14      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
15    }
16    for (node = 0; node < NIdV.Len(); node++) {
17      NI = GetNI(NIdV[node]);
18      const int SrcNId = NI.GetId();
19      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
20        const int OutNId = NI.GetOutNId(edge);
21        if (NewNet.IsNode(OutNId)) {
22          NewNet.AddEdge(SrcNId, OutNId); }
23      }
24    }
25    NewNet.Defrag();
26    return NewNetPt;
27  }
28  PTimeNENet TTimeNet::GetTimeNENet() const {
29    TIntV NIdV;  GetNIdByTm(NIdV);
30    PTimeNENet OutNet = TTimeNENet::New(GetNodes(), GetEdges());
31    for (int i = 0; i < NIdV.Len(); i++) {
32      const int Src = NIdV[i];
33      const TTimeNet::TNodeI NI = GetNI(Src);
34      const TSecTm SrcTm = NI.GetDat();
35      if (! OutNet->IsNode(Src)) { OutNet->AddNode(Src, SrcTm); }
36      for (int e = 0; e < NI.GetOutDeg(); e++) {
37        if (! OutNet->IsNode(NI.GetOutNId(e))) { OutNet->AddNode(NI.GetOutNId(e), SrcTm); }
38        OutNet->AddEdge(Src, NI.GetOutNId(e), -1, SrcTm);
39      }
40    }
41    return OutNet;
42  }
43  void TTimeNet::GetNIdByTm(TIntV& NIdV) const {
44    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
45    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
46      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
47    TmToNIdV.Sort();
48    NIdV.Gen(GetNodes(), 0);
49    for (int i = 0; i < TmToNIdV.Len(); i++) {
50      NIdV.Add(TmToNIdV[i].Dat); }
51  }
52  void TTimeNet::GetTmBuckets(const TTmUnit& TmUnit, TTmBucketV& TmBucketV) const {
53    THash<TInt, TIntV> TmIdToNIdVH;
54    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
55      const int TmId = NodeI().Round(TmUnit);
56      if (! TmIdToNIdVH.IsKey(TmId)) TmIdToNIdVH.AddKey(TmId);
57      TmIdToNIdVH.GetDat(TmId).Add(NodeI.GetId());
58    }
59    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
60    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
61    TmIdNIdVV.Sort();
62    TmBucketV.Gen(TmIdNIdVV.Len());
63    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
64      TTmBucket& Bucket = TmBucketV[i];
65      Bucket.BegTm = TmIdNIdVV[i].Val1;
66      Bucket.NIdV = TmIdNIdVV[i].Val2;
67    }
68  }
69  void TTimeNet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
70    TIntV NIdV;
71    GetNIdByTm(NIdV);
72    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
73    for (int i = 0; i < NIdV.Len(); i++) {
74      const int b = i/NodesPerBucket;
75      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
76      TmBucketV[b].NIdV.Add(NIdV[i]);
77    }
78  }
79  PGStatVec TTimeNet::TimeGrowth(const TTmUnit& TmUnit, const TFSet& TakeStat, const TSecTm& StartTm) const {
80    PGStatVec GrowthStat = new TGStatVec(TmUnit, TakeStat);
81    TTmBucketV TmBucketV;
82    GetTmBuckets(TmUnit, TmBucketV);
83    TIntV NodeIdV;
84    TExeTm ExeTm;
85    for (int t = 0; t < TmBucketV.Len(); t++) {
86      NodeIdV.AddV(TmBucketV[t].NIdV); 
87      printf("\n=== %d/%d] %s (%d nodes)\n", t+1, TmBucketV.Len(),
88        TmBucketV[t].BegTm.GetStr().CStr(), NodeIdV.Len());  ExeTm.Tick();
89      if (TmBucketV[t].BegTm < StartTm) continue;
90      PNGraph PreGraph = TSnap::ConvertSubGraph<PNGraph>(PTimeNet((TTimeNet*)this), NodeIdV); 
91      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
92    }
93    return GrowthStat;
94  }
95  void TTimeNet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
96                             const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc, const bool& AlsoRewire) const {
97    const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
98    TTmBucketV TmBucketV;
99    GetTmBuckets(TmUnit, TmBucketV);
100    TIntV NodeIdV;
101    TExeTm ExeTm, Run1Tm;
102    TFltTrV TmDiamV, NdsDiamV;
103    TFltTrV RwTmDiamV, RwNdsDiamV;
104    for (int t = 0; t < TmBucketV.Len(); t++) {
105      NodeIdV.AddV(TmBucketV[t].NIdV); 
106      printf("\n*** %d/%d] at %s (%d nodes)\n", t+1, TmBucketV.Len(),
107        TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), NodeIdV.Len());  ExeTm.Tick();
108      if (TmBucketV[t].BegTm < StartTm) continue;
109      PUNGraph PreGraph = TSnap::ConvertSubGraph<PUNGraph>(PTimeNet((TTimeNet*)this), NodeIdV);
110      { TMom Mom;
111      for (int r = 0; r < NDiamRuns; r++) {
112        printf("%d...", r+1);  Run1Tm.Tick();
113        const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph) : PreGraph);
114        Mom.Add(EffDiam);  printf("[%s]\r", Run1Tm.GetTmStr());
115      }
116      Mom.Def();
117      TmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
118      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
119      NdsDiamV.Sort();
120      printf("  [%s]          \n", ExeTm.GetTmStr()); }
121      if (AlsoRewire) {
122        TIntV DegSeqV(PreGraph->GetNodes(), 0);
123        for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) { DegSeqV.Add(NI.GetDeg()); }
124        PUNGraph RwGraph = TSnap::GenConfModel(DegSeqV, TInt::Rnd);
125        printf("Configuration model: (%d, %d) --> (%d, %d)\n", PreGraph->GetNodes(), PreGraph->GetEdges(), RwGraph->GetNodes(), RwGraph->GetEdges());
126        TMom Mom;
127        for (int r = 0; r < NDiamRuns; r++) {
128          printf("  diam run %d...", r+1);  Run1Tm.Tick();
129          const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph):PreGraph);
130          Mom.Add(EffDiam);  printf(" current run [%s]\n", Run1Tm.GetTmStr());
131        }
132        Mom.Def();
133        RwTmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
134        RwNdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
135        RwNdsDiamV.Sort();
136        printf("done with diameter. Total time [%s] \n", ExeTm.GetTmStr());
137      }
138      { TGnuPlot GnuPlot("diamEff-T."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
139      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), WccStr+"Effective Diameter");
140      GnuPlot.AddErrBar(TmDiamV, "True", "");
141      if (! RwTmDiamV.Empty()) { GnuPlot.AddErrBar(RwTmDiamV, "Rewired", "");}
142      GnuPlot.SavePng(); }
143      { TGnuPlot GnuPlot("diamEff-N."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
144      GnuPlot.SetXYLabel("NODES", WccStr+"Effective Diameter");
145      GnuPlot.AddErrBar(NdsDiamV, "True", "");
146      if (! RwNdsDiamV.Empty()) { GnuPlot.AddErrBar(RwNdsDiamV, "Rewired", "");}
147      GnuPlot.SavePng(); }
148    }
149  }
150  void TTimeNet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
151                                 const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam) const {
152    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
153      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
154    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
155      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
156    const int NDiamRuns = 10;
157    const int NSamples = 100;
158    PUNGraph FullGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
159    if (DelPreTmEdges.IsDef()) {
160      int NDelNodes = 0, NDelEdges = 0;
161      printf("Deleting pre-%s node out-links\n", DelPreTmEdges.GetStr().CStr());
162      for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
163        if (NodeI() < DelPreTmEdges) {
164          const int NodeId = NodeI.GetId();
165          for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
166            FullGraph->DelEdge(NodeId, NodeI.GetOutNId(edge)); }
167          NDelEdges += NodeI.GetOutDeg();  NDelNodes++;
168        }
169      }
170      printf("  Deleted %d nodes out-edges (%d edges total).\n", NDelNodes, NDelEdges);
171      FullGraph->Defrag(true);
172    }
173    PGStatVec GrowthStat = TGStatVec::New(TmUnit);
174    TFltV PreDiamSDev, PreEffDiamSDev, WccDiamSDev, WccEffDiamSDev;
175    TIntV NodeIdV;
176    TExeTm ExeTm;
177    TTmBucketV TmBucketV;
178    GetTmBuckets(TmUnit, TmBucketV);
179    for (int t = 0; t < TmBucketV.Len(); t++) {
180      printf("\nGraph: %s (%d / %d) [%s]\n", TmBucketV[t].BegTm.GetTmStr().CStr(),
181        t+1, TmBucketV.Len(), TExeTm::GetCurTm());
182      NodeIdV.AddV(TmBucketV[t].NIdV); 
183      if (TmBucketV[t].BegTm < PostTmDiam) { continue; }
184      const PUNGraph PreGraph = TSnap::GetSubGraph(FullGraph, NodeIdV, true);
185      const PUNGraph WccGraph = TSnap::GetMxWcc(PreGraph);
186      TIntV PostYearNIdV, WccPostYearNIdV;
187      for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) {
188        if (GetNDat(NI.GetId()) >= PostTmDiam) {
189          PostYearNIdV.Add(NI.GetId());
190          if (WccGraph->IsNode(NI.GetId())) { WccPostYearNIdV.Add(NI.GetId()); }
191        }
192      }
193      TMom PreDiamMom, PreEffDiamMom, WccDiamMom, WccEffDiamMom;
194      int FullDiam; double EffDiam;
195      for (int r = 0; r < NDiamRuns; r++) {
196        if (! PostYearNIdV.Empty()) {
197          TSnap::GetBfsEffDiam(PreGraph, NSamples, PostYearNIdV, false, EffDiam, FullDiam);
198          PreDiamMom.Add(FullDiam);  PreEffDiamMom.Add(EffDiam);
199        }
200        if (! WccPostYearNIdV.Empty()) {
201          TSnap::GetBfsEffDiam(WccGraph, NSamples, WccPostYearNIdV, false, EffDiam, FullDiam);
202          WccDiamMom.Add(FullDiam);  WccEffDiamMom.Add(EffDiam);
203        }
204        printf("  diam: %d  [%s]  \r", r+1, ExeTm.GetTmStr());  ExeTm.Tick();
205      }
206      PreDiamMom.Def();  PreEffDiamMom.Def();
207      WccDiamMom.Def();  WccEffDiamMom.Def();
208      PGStat GraphStatPt = GrowthStat->Add(TmBucketV[t].BegTm);
209      TGStat& GS = *GraphStatPt;
210      GS.TakeBasicStat(PreGraph, false);
211      GS.TakeBasicStat(WccGraph, true);
212      GS.SetVal(gsvFullDiam, PreDiamMom.GetMean()); 
213      GS.SetVal(gsvEffDiam, PreEffDiamMom.GetMean());
214      GS.SetVal(gsvFullWccDiam, WccDiamMom.GetMean());
215      GS.SetVal(gsvEffWccDiam, WccEffDiamMom.GetMean());
216      GS.SetVal(gsvFullDiamDev, PreDiamMom.GetSDev()); 
217      GS.SetVal(gsvEffDiamDev, PreEffDiamMom.GetSDev());
218      GS.SetVal(gsvFullWccDiamDev, WccDiamMom.GetSDev());
219      GS.SetVal(gsvEffWccDiamDev, WccEffDiamMom.GetSDev());
220      { TFOut FOut("growth."+FNmPref+".gStatVec");  GrowthStat->Save(FOut); }
221      GrowthStat->SaveTxt(FNmPref, TStr::Fmt("%s. MISSING PAST DIAMETER\nDelPreEdges\t%s\nPostYearDiam\t%s\n",
222        Desc.CStr(), DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr()));
223    }
224  }
225  void TTimeNet::PlotCCfOverTm(const TStr& FNmPref, TStr Desc, const TTmUnit& TmUnit, const int& NodesBucket) const {
226    if (Desc.Empty()) { Desc = FNmPref; }
227    TTimeNet::TTmBucketV TmBucketV;
228    TStr XLbl;
229    if (TmUnit == tmuNodes) {
230      XLbl = "Number of nodes (time)";
231      IAssert(NodesBucket > 0);
232      GetNodeBuckets(NodesBucket, TmBucketV); }
233    else {
234      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
235      GetTmBuckets(TmUnit, TmBucketV);
236    }
237    TIntV NodeIdV;
238    TFltPrV DegToCCfV, CcfV, OpClV, OpV;
239    TVec<TTuple<TFlt, 4> > OpenClsV;
240    TTuple<TFlt, 4> Tuple;
241    TExeTm ExeTm;
242    int XVal = 0;
243    printf("Clustering coefficient over time:\n  %d edges, %d edges per bucket, %d buckets \n", GetEdges(), 100000, TmBucketV.Len());
244    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
245    for (int t = 0; t < TmBucketV.Len(); t++) {
246      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
247      NodeIdV.AddV(TmBucketV[t].NIdV); 
248      int64 Open=0, Close=0;
249      const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);
250      const double CCf = TSnap::GetClustCf(Graph, DegToCCfV, Open, Close);
251      if (TmUnit == tmuNodes) { XVal = Graph->GetNodes(); }
252      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
253      CcfV.Add(TFltPr(XVal, CCf));
254      double FltOpen = static_cast<double>(Open);
255      double FltClose = static_cast<double>(Close);
256      OpClV.Add(TFltPr(XVal, (Open+Close==0 ? 0.0 : FltClose/(FltOpen+FltClose))));
257      OpV.Add(TFltPr(XVal, (Open==0 ? 0.0 : FltClose/FltOpen)));
258      Tuple[0]=Graph->GetNodes();
259      Tuple[1]=Graph->GetEdges();
260      Tuple[2]=FltClose;  Tuple[3]=FltOpen;
261      OpenClsV.Add(Tuple);
262      printf(" %s", ExeTm.GetStr());
263      TGnuPlot::PlotValV(DegToCCfV, TStr::Fmt("ccfAt%02dtm.%s", t+1, FNmPref.CStr()),
264        TStr::Fmt("%s. At time %d. Clustering Coefficient. G(%d,%d)", Desc.CStr(), t+1, Graph->GetNodes(), Graph->GetEdges()),
265        "Degree", "Clustering coefficient", gpsLog10XY, false);
266    }
267    TGnuPlot::PlotValV(CcfV, "ccfOverTm."+FNmPref, Desc+". Average Clustering Coefficient", XLbl, "Average clustering coefficient", gpsAuto, false);
268    TGnuPlot::PlotValV(OpClV, "ClsOpnTr1."+FNmPref, Desc+". Close/(Open+Closed) triads", XLbl, "Close / (Open+Closed) triads", gpsAuto, false);
269    TGnuPlot::PlotValV(OpV, "ClsOpnTr2."+FNmPref, Desc+". Close/Open triads", XLbl, "Close / Open triads", gpsAuto, false);
270    TGnuPlot::SaveTs(OpenClsV, "ClsOpnTr."+FNmPref+".tab", TStr::Fmt("#%s\n#Nodes\tEdges\tClosed\tOpenTriads", Desc.CStr()));
271    printf("\n");
272  }
273  void TTimeNet::PlotMedianDegOverTm(const TStr& FNmPref, const TTmUnit& TmUnit, const int& NodesPerBucket) const {
274    TTimeNet::TTmBucketV TmBucketV;
275    TStr XLbl;
276    if (TmUnit == tmuNodes) {
277      XLbl = "Number of nodes (time)";  IAssert(NodesPerBucket > 0);
278      GetNodeBuckets(NodesPerBucket, TmBucketV); }
279    else {
280      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
281      GetTmBuckets(TmUnit, TmBucketV); }
282    printf("\n\n%s\nMedian degree over time:\n  %d edges, %d edges per bucket, %d buckets \n", FNmPref.CStr(), GetEdges(), NodesPerBucket, TmBucketV.Len());
283    TFltPrV MedDegV, MedInDegV, MedOutDegV;
284    TIntV NodeIdV;
285    int XVal;
286    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
287    PNGraph NGraph = TSnap::ConvertGraph<PNGraph>(PTimeNet((TTimeNet*)this));
288    FILE  *F = fopen(("gStat-"+FNmPref+".tab").CStr(), "wt");
289    fprintf(F, "UndirNodes\tUndirEdges\tUndirNonZNodes\tMedianDeg\tMeanDeg\tDirNodes\tDirEdges\tDirNonzNodes\tMedInDeg\tMedOutDeg\tMeanInDeg\tMeanOutDeg\n");
290    for (int t = 0; t < TmBucketV.Len(); t++) {
291      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
292      NodeIdV.AddV(TmBucketV[t].NIdV); 
293      if (TmUnit == tmuNodes) { XVal = NodeIdV.Len(); }
294      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
295      { const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);  TMom Mom;
296      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) { if (NI.GetOutDeg()>0) { Mom.Add(NI.GetOutDeg());} }
297      Mom.Def();  MedDegV.Add(TFltPr(XVal, Mom.GetMedian()));
298      fprintf(F, "%d\t%d\t%d\t%f\t%f", Graph->GetNodes(), Graph->GetEdges(), TSnap::CntNonZNodes(Graph), (float)Mom.GetMedian(), (float)Mom.GetMean()); }
299      { const PNGraph Graph = TSnap::GetSubGraph<PNGraph>(NGraph, NodeIdV); TMom MomOut, MomIn;
300      for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
301        if (NI.GetOutDeg()>0) { MomOut.Add(NI.GetOutDeg()); }
302        if (NI.GetInDeg()>0) { MomIn.Add(NI.GetInDeg()); } }
303      MomOut.Def();  MedOutDegV.Add(TFltPr(XVal, MomOut.GetMedian()));
304      MomIn.Def();  MedInDegV.Add(TFltPr(XVal, MomIn.GetMedian()));
305      fprintf(F, "\t%d\t%d\t%d\t%f\t%f\t%f\t%f\n", Graph->GetNodes(), Graph->GetEdges(), (int)TSnap::CntNonZNodes(Graph), (float)MomIn.GetMedian(), (float)MomOut.GetMedian(), (float)MomIn.GetMean(), (float)MomOut.GetMean()); }
306    }
307    fclose(F);
308    TGnuPlot::PlotValV(MedDegV, "medDeg."+FNmPref, FNmPref+" Median degree", TTmInfo::GetTmUnitStr(TmUnit), "Median degree");
309    TGnuPlot::PlotValV(MedOutDegV, "medOutDeg."+FNmPref, FNmPref+" Median OUT degree", TTmInfo::GetTmUnitStr(TmUnit), "Median OUT degree");
310    TGnuPlot::PlotValV(MedInDegV, "medInDeg."+FNmPref, FNmPref+" Median IN degree", TTmInfo::GetTmUnitStr(TmUnit), "Median IN degree");
311  }
312  PTimeNet TTimeNet::LoadBipartite(const TStr& InFNm) {
313    PTimeNet TimeNetPt = TTimeNet::New();
314    TTimeNet& TimeNet = *TimeNetPt;
315    PSs Ss = TSs::LoadTxt(ssfTabSep, InFNm.CStr());
316    TIntH Set1IdH; 
317    TStrV StrTimeV;
318    for (int y = 0; y < Ss->GetYLen(); y++) {
319      if (Ss->At(0, y)[0] == '#') continue; 
320      if (Ss->GetXLen(y) < 3) continue;     
321      const int& SrcId = Ss->At(0, y).GetInt();
322      IAssert(! Set1IdH.IsKey(SrcId));
323      IAssert(! TimeNet.IsNode(SrcId));
324      Set1IdH.AddKey(SrcId);
325      Ss->At(1, y).SplitOnAllCh('-', StrTimeV);
326      const int Year = StrTimeV[0].GetInt();
327      const int Month = StrTimeV[1].GetInt();
328      const int Day = StrTimeV[2].GetInt();
329      const TSecTm NodeTm(Year, Month, Day);
330      TimeNet.AddNode(SrcId, NodeTm);
331      for (int dst = 2; dst < Ss->GetXLen(y); dst++) {
332        const int DstId = Ss->At(dst, y).GetInt();
333        IAssert(! Set1IdH.IsKey(DstId));
334        if (! TimeNet.IsNode(DstId)) { TimeNet.AddNode(DstId, NodeTm); }
335        else { TimeNet.GetNDat(DstId) = TMath::Mn(NodeTm, TimeNet.GetNDat(DstId)); }
336        if (! TimeNet.IsEdge(SrcId, DstId)) { TimeNet.AddEdge(SrcId, DstId); }
337      }
338    }
339    TimeNet.Defrag();
340    printf("Bipartate graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
341    printf("  Bipartate sets: %d nodes --> %d nodes\n", TSnap::CntInDegNodes(TimeNetPt, 0),
342      TSnap::CntOutDegNodes(TimeNetPt, 0));
343    return TimeNetPt;
344  }
345  PTimeNet TTimeNet::LoadArxiv(const TStr& PaperFNm, const TStr& CiteFNm) {
346    TExeTm ExeTm;
347    PTimeNet TimeNetPt = TTimeNet::New();
348    TTimeNet& TimeNet = *TimeNetPt;
349    printf("Arxiv citation graph (paper publication year)...\n");
350    char Line [1024];
351    FILE *PprF = fopen(PaperFNm.CStr(), "rt");
352    TStr StrId, StrTime;
353    TStrV StrV, StrTimeV;
354    int N = 0, DuplicateNode = 0;
355    while (! feof(PprF)) {
356      Line[0] = 0;
357      fgets(Line, 1024, PprF);
358      if (strlen(Line) == 0 || Line[0] == '#') continue;
359      Line[strlen(Line)-1] = 0; 
360      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
361      StrId = StrV[0];  StrTime = StrV[1];  IAssert(!StrId.Empty() && !StrTime.Empty());
362      StrTime.SplitOnAllCh('-', StrTimeV);  IAssert(StrTimeV.Len() == 3);
363      const int NodeId = StrId.GetInt();
364      if (! TimeNet.IsNode(NodeId)) {
365        const int Year = StrTimeV[0].GetInt();
366        const int Month = StrTimeV[1].GetInt();
367        const int Day = StrTimeV[2].GetInt();
368        TimeNet.AddNode(NodeId, TSecTm(Year, Month, Day));
369      } else { DuplicateNode++; }
370      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
371    }
372    printf("\r  %d nodes read. %d duplicate nodes. %s\n", N, DuplicateNode, ExeTm.GetTmStr());
373    fclose(PprF);
374    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
375    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
376    N = 0;  ExeTm.Tick();
377    printf("Loading Arxiv citations...\n");
378    TIntPrV EdgeV;
379    THash<TInt, TSecTm> NIdToTimeH;
380    while (! feof(CiteF)) {
381      Line[0] = 0;
382      fgets(Line, 1024, CiteF);
383      if (strlen(Line) == 0 || Line[0] == '#') continue;
384      Line[strlen(Line)-1] = 0; 
385      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
386      const int SrcNId = StrV[0].GetInt();
387      const int DstNId = StrV[1].GetInt();
388      EdgeV.Add(TIntPr(SrcNId, DstNId));
389      if (! TimeNet.IsNode(DstNId) && TimeNet.IsNode(SrcNId)) {
390        const TSecTm& SrcTm = TimeNet.GetNDat(SrcNId);
391        if (! NIdToTimeH.IsKey(DstNId)) {
392          NIdToTimeH.AddDat(DstNId, SrcTm);
393          NewDstIds++;
394        }
395        else if (NIdToTimeH.GetDat(DstNId) < SrcTm) {
396          NIdToTimeH.GetDat(DstNId) = SrcTm; }
397      }
398      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
399    }
400    fclose(CiteF);
401    for (int i = 0; i < NIdToTimeH.Len(); i++) {
402      TimeNet.AddNode(NIdToTimeH.GetKey(i), NIdToTimeH[i]);
403    }
404    for (int i = 0; i < EdgeV.Len(); i++) {
405      const int SrcNId = EdgeV[i].Val1;
406      const int DstNId = EdgeV[i].Val2;
407      if (TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
408        if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
409        else { DupLinks++; }
410      } else {
411        if (! TimeNet.IsNode(SrcNId)) {
412          NewSrcIds++;
413          if (! TimeNet.IsNode(DstNId)) { NewCits++; }
414        }
415      }
416    }
417    printf("\r  %d citations read. %s\n", N, ExeTm.GetTmStr());
418    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
419    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
420    TIntV RmNIdV;
421    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
422      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
423    }
424    for (int i = 0; i < RmNIdV.Len(); i++) {
425      TimeNet.DelNode(RmNIdV[i]);
426    }
427    TimeNet.Defrag(true);
428    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
429    printf("  Duplicate citations                    : %d\n", DupLinks);
430    printf("  Nodes without time which are cited     : %d (add them to graph, use time of the earliest source node)\n", NewDstIds);
431    printf("  Citations between unknown time nodes   : %d\n", NewCits);
432    printf("  Nodes without time which make citations: %d (do not add them into the graph)\n", NewSrcIds);
433    return TimeNetPt;
434  }
435  PTimeNet TTimeNet::LoadPatents(const TStr& PatentFNm, const TStr& CiteFNm) {
436    int N = 0;
437    TExeTm ExeTm;
438    PTimeNet TimeNetPt = TTimeNet::New();
439    TTimeNet& TimeNet = *TimeNetPt;
440    TimeNet.Reserve(4000000, 160000000);
441    printf("parsing patent data (patent grant year)...\n");
442    const int& PatIdCol = 0;
443    const int& GYearCol = 1;
444    TStrV ColV;
445    char Line [1024];
446    FILE *PatF = fopen(PatentFNm.CStr(), "rt");
447    fgets(Line, 1024, PatF); 
448    while (! feof(PatF)) {
449      Line[0] = 0;
450      fgets(Line, 1024, PatF);
451      if (strlen(Line) == 0) break;
452      TStr(Line).SplitOnAllCh(',', ColV, false);
453      IAssert(ColV.Len() == 23);
454      const int PatentId = ColV[PatIdCol].GetInt();
455      const int GrantYear = ColV[GYearCol].GetInt();
456      IAssert(! TimeNet.IsNode(PatentId));
457      TimeNet.AddNode(PatentId, TSecTm(GrantYear)); 
458      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
459    }
460    printf("\r  %d patents read. %s\n", N, ExeTm.GetTmStr());
461    fclose(PatF);
462    printf("\nLoading patent citations...\n");
463    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
464    N = 0;  ExeTm.Tick();
465    TStr SrcId, DstId;
466    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
467    fgets(Line, 1024, CiteF); 
468    while (! feof(CiteF)) {
469      Line[0] = 0;
470      fgets(Line, 1024, CiteF);
471      if (strlen(Line) == 0) break;
472      Line[strlen(Line)-1] = 0; 
473      TStr(Line).SplitOnCh(SrcId, ',', DstId);
474      const int SrcNId = SrcId.GetInt();
475      const int DstNId = DstId.GetInt();
476      if (! TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
477        NewCits++;
478        continue;
479      }
480      else if (TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
481        TimeNet.AddNode(DstNId, TimeNet.GetNDat(SrcNId));  NewDstIds++;
482      }
483      else if (! TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
484        TimeNet.AddNode(SrcNId, TimeNet.GetNDat(DstNId));  NewSrcIds++;
485      }
486      if (! TimeNet.IsEdge(SrcNId, DstNId)) {
487        TimeNet.AddEdge(SrcNId, DstNId);
488      } else { DupLinks++; }
489      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
490    }
491    fclose(CiteF);
492    printf("\r  %d citations read. %s\n\n", N, ExeTm.GetTmStr());
493    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
494    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
495    TIntV RmNIdV;
496    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
497      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
498    }
499    for (int i = 0; i < RmNIdV.Len(); i++) {
500      TimeNet.DelNode(RmNIdV[i]);
501    }
502    TimeNet.Defrag(true);
503    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
504    printf("  Duplicate citations                    : %d\n", DupLinks);
505    printf("  Citations between unknown time nodes   : %d\n", NewCits);
506    printf("  Nodes without time which make citations: %d\n", NewSrcIds);
507    printf("  Nodes without time which are cited     : %d\n", NewDstIds);
508    return TimeNetPt;
509  }
510  PTimeNet TTimeNet::LoadAmazon(const TStr& StlFNm) {
511    PTimeNet TimeNetPt = TTimeNet::New();
512    TTimeNet& TimeNet = *TimeNetPt;
513    TimeNet.Reserve(3953993, -1);
514    printf("Amazon Share-the-Love...\n");
515    char line [2024], MonthStr[4];
516    int NLines=0;
517    TStrV ColV;
518    FILE *F = fopen(StlFNm.CStr(), "rt");
519    while (! feof(F)) {
520      memset(line, 0, 2024);
521      fgets(line, 2024, F);
522      if (strlen(line) == 0) break;
523      TStr(line).SplitOnAllCh(',', ColV);
524      const int SrcNId = ColV[0].GetInt();
525      const int DstNId = ColV[1].GetInt();
526      TStr TmStr = ColV[2]; 
527      int Year = TmStr.GetSubStr(5, 6).GetInt();
528      if (Year < 10) { Year += 2000; } else { Year += 1900; }
529      MonthStr[0]=toupper(TmStr[2]);  MonthStr[1]=tolower(TmStr[3]);
530      MonthStr[2]=tolower(TmStr[4]);  MonthStr[3]=0;
531      const int Month = TTmInfo::GetMonthN(MonthStr, lUs);
532      const int Day = TmStr.GetSubStr(0, 1).GetInt();
533      const int Hour = TmStr.GetSubStr(8, 9).GetInt();
534      const int Min = TmStr.GetSubStr(11, 12).GetInt();
535      const int Sec = TmStr.GetSubStr(14, 15).GetInt();
536      if (! TimeNet.IsNode(SrcNId)) { TimeNet.AddNode(SrcNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
537      if (! TimeNet.IsNode(DstNId)) { TimeNet.AddNode(DstNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
538      if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
539      if (++NLines % 100000 == 0) printf("\r  %dk", NLines/1000);
540    }
541    fclose(F);
542    printf("\r  %d lines read\n", NLines);
543    printf("Graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
544    TimeNet.Defrag(true);
545    return TimeNetPt;
546  }
547  TTimeNENet& TTimeNENet::operator = (const TTimeNENet& TimeNet) {
548    if (this != &TimeNet) {
549      TNet::operator=(TimeNet);
550    }
551    return *this;
552  }
553  PTimeNet TTimeNENet::GetTimeNet() const {
554    PTimeNet NewNet = TTimeNet::New();
555    NewNet->Reserve(GetNodes(), -1);
556    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
557      NewNet->AddNode(NI.GetId(), NI.GetDat());
558    }
559    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
560      const int src = EI.GetSrcNId();
561      const int dst = EI.GetDstNId();
562      if (! NewNet->IsEdge(src, dst)) {
563        NewNet->AddEdge(src, dst); }
564    }
565    NewNet->Defrag();
566    return NewNet;
567  }
568  PTimeNENet TTimeNENet::Get1stEdgeNet() const {
569    PTimeNENet Net = TTimeNENet::New();
570    Net->Reserve(GetNodes(), -1);
571    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
572      Net->AddNode(NI.GetId(), NI.GetDat()); }
573    TIntV EIdV;  GetEIdByTm(EIdV);
574    TIntPrSet EdgeSet(GetEdges());
575    for (int edge = 0; edge < EIdV.Len(); edge++) {
576      const TEdgeI EI = GetEI(EIdV[edge]);
577      const int Src = EI.GetSrcNId();
578      const int Dst = EI.GetDstNId();
579      if (Src==Dst || EdgeSet.IsKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)))) { continue; } 
580      EdgeSet.AddKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)));
581      Net->AddEdge(EI);
582    }
583    return Net;
584  }
585  PTimeNENet TTimeNENet::GetSubGraph(const TIntV& NIdV) const {
586    PTimeNENet NewNetPt = TTimeNENet::New();
587    TTimeNENet& NewNet = *NewNetPt;
588    NewNet.Reserve(NIdV.Len(), -1);
589    int node, edge;
590    TNodeI NI;
591    for (node = 0; node < NIdV.Len(); node++) {
592      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node]));
593    }
594    for (node = 0; node < NIdV.Len(); node++) {
595      NI = GetNI(NIdV[node]);
596      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
597        const TEdgeI EI = GetEI(NI.GetOutEId(edge));
598        if (NewNet.IsNode(EI.GetDstNId())) {
599          NewNet.AddEdge(EI); }
600      }
601    }
602    NewNet.Defrag();
603    return NewNetPt;
604  }
605  PTimeNENet TTimeNENet::GetESubGraph(const TIntV& EIdV) const {
606    PTimeNENet NewNetPt = TTimeNENet::New();
607    TTimeNENet& NewNet = *NewNetPt;
608    NewNet.Reserve(-1, EIdV.Len());
609    for (int edge = 0; edge < EIdV.Len(); edge++) {
610      const TEdgeI Edge = GetEI(EIdV[edge]);
611      if (! NewNet.IsNode(Edge.GetSrcNId()))
612        NewNet.AddNode(GetNI(Edge.GetSrcNId()));
613      if (! NewNet.IsNode(Edge.GetDstNId()))
614        NewNet.AddNode(GetNI(Edge.GetDstNId()));
615      NewNet.AddEdge(Edge);
616    }
617    NewNet.Defrag();
618    return NewNetPt;
619  }
620  PTimeNENet TTimeNENet::GetGraphUpToTm(const TSecTm& MaxEdgeTm) const {
621    PTimeNENet NewNetPt = TTimeNENet::New();
622    TTimeNENet& NewNet = *NewNetPt;
623    TSecTm PrevTm;
624    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
625      if (EI() > MaxEdgeTm) { break; }
626      if (! NewNet.IsNode(EI.GetSrcNId()))
627        NewNet.AddNode(GetNI(EI.GetSrcNId()));
628      if (! NewNet.IsNode(EI.GetDstNId()))
629        NewNet.AddNode(GetNI(EI.GetDstNId()));
630      NewNet.AddEdge(EI);
631      IAssert(! PrevTm.IsDef() || PrevTm <= EI()); 
632      PrevTm = EI();
633    }
634    NewNet.Defrag();
635    return NewNetPt;
636  }
637  void TTimeNENet::SortNodeEdgeTimes() {
638    NodeH.SortByDat(true);
639    EdgeH.SortByDat(true);
640  }
641  void TTimeNENet::UpdateNodeTimes() {
642    int Cnt = 0;
643    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
644      TSecTm& NodeTm = NI();
645      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
646        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));
647        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
648      }
649      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
650        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));
651        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
652      }
653    }
654    printf("Update node times: %d/%d updates\n", Cnt, GetNodes());
655  }
656  void TTimeNENet::SetNodeTmToFirstEdgeTm() {
657    int Cnt = 0;
658    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
659      if (NI.GetDeg() == 0) { continue; }
660      TSecTm NodeTm;
661      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
662        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));  IAssert(EdgeTm.IsDef());
663        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
664      }
665      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
666        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));  IAssert(EdgeTm.IsDef());
667        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
668      }
669      GetNDat(NI.GetId()) = NodeTm;
670    }
671    printf("Node times set: %d/%d updates\n", Cnt, GetNodes());
672  }
673  void TTimeNENet::SetRndEdgeTimes(const int& MinTmEdge) {
674    printf("Shuffling last %d (%d%%) edge arrival times..\n", GetEdges()-MinTmEdge, int(100.0*(GetEdges()-MinTmEdge)/double(GetEdges())));
675    TIntV RndEIdV;  GetEIdByTm(RndEIdV);
676    TIntV TrueEIdV = RndEIdV;
677    TSecTmV TrueTmV;
678    const int SwapLen = RndEIdV.Len()-MinTmEdge;
679    for (int R = 0; R < 10; R++) {
680      for (int i = MinTmEdge; i < RndEIdV.Len(); i++) {
<span onclick='openModal()' class='match'>681        RndEIdV.Swap(TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge, TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge); }
682    }
683    for (int e = 0; e < TrueEIdV.Len(); e++) {
684      TrueTmV.Add(GetEDat(TrueEIdV[e])); }
685    for (int e = 0; e < RndEIdV.Len(); e++) {
</span>686      GetEDat(RndEIdV[e]) = TrueTmV[e]; }
687    UpdateNodeTimes();
688  }
689  void TTimeNENet::DumpTimeStat() const {
690    TSecTm MnNodeTm, MxNodeTm;
691    TSecTm MnEdgeTm, MxEdgeTm;
692    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
693      const TSecTm NodeTm = NI();
694      if (! MnNodeTm.IsDef() || MnNodeTm>NodeTm) { MnNodeTm = NodeTm; }
695      if (! MxNodeTm.IsDef() || MxNodeTm<NodeTm) { MxNodeTm = NodeTm; }
696    }
697    printf("Node times:\n  %s\n  %s\n", MnNodeTm.GetStr().CStr(), MxNodeTm.GetStr().CStr());
698    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
699      const TSecTm EdgeTm = EI();
700      if (! MnEdgeTm.IsDef() || MnEdgeTm>EdgeTm) { MnEdgeTm = EdgeTm; }
701      if (! MxEdgeTm.IsDef() || MxEdgeTm<EdgeTm) { MxEdgeTm = EdgeTm; }
702    }
703    printf("Edge times:\n  %s\n  %s\n", MnEdgeTm.GetStr().CStr(), MxEdgeTm.GetStr().CStr());
704  }
705  void TTimeNENet::GetNIdByTm(TIntV& NIdV) const {
706    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
707    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
708      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
709    TmToNIdV.Sort();
710    NIdV.Gen(GetNodes(), 0);
711    for (int i = 0; i < TmToNIdV.Len(); i++) {
712      NIdV.Add(TmToNIdV[i].Dat); }
713  }
714  void TTimeNENet::GetEIdByTm(TIntV& EIdV) const {
715    TVec<TKeyDat<TSecTm, TInt> > TmToEIdV(GetEdges(), 0);
716    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
717      TmToEIdV.Add(TKeyDat<TSecTm, TInt>(EI.GetDat(), EI.GetId())); }
718    TmToEIdV.Sort();
719    EIdV.Gen(GetEdges(), 0);
720    for (int i = 0; i < TmToEIdV.Len(); i++) {
721      EIdV.Add(TmToEIdV[i].Dat); }
722  }
723  void TTimeNENet::GetTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
724    THash<TInt, TIntV> TmIdToNIdVH;
725    TIntV NIdV;  GetNIdByTm(NIdV);
726    for (int n = 0; n < NIdV.Len(); n++) {
727      const int TmId = GetNDat(NIdV[n]).Round(TmUnit).GetAbsSecs();
728      if (! TmIdToNIdVH.IsKey(TmId)) { TmIdToNIdVH.AddKey(TmId); }
729      TmIdToNIdVH.GetDat(TmId).Add(NIdV[n]);
730    }
731    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
732    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
733    TmIdNIdVV.Sort();
734    TmBucketV.Gen(TmIdNIdVV.Len());
735    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
736      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
737      Bucket.BegTm = TmIdNIdVV[i].Val1;
738      Bucket.NIdV = TmIdNIdVV[i].Val2;
739    }
740  }
741  void TTimeNENet::GetEdgeTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
742    THash<TInt, TIntV> TmIdToEIdVH;
743    TIntV EIdV;  GetEIdByTm(EIdV);
744    for (int e = 0; e < EIdV.Len(); e++) {
745      const int TmId = GetEDat(EIdV[e]).Round(TmUnit).GetAbsSecs();
746      if (! TmIdToEIdVH.IsKey(TmId)) { TmIdToEIdVH.AddKey(TmId); }
747      TmIdToEIdVH.GetDat(TmId).Add(EIdV[e]);
748    }
749    TVec<TPair<TInt, TIntV> > TmIdEIdVV;
750    TmIdToEIdVH.GetKeyDatPrV(TmIdEIdVV);
751    TmIdEIdVV.Sort();
752    TmBucketV.Gen(TmIdEIdVV.Len());
753    for (int i = 0; i < TmIdEIdVV.Len(); i++) {
754      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
755      Bucket.BegTm = TmIdEIdVV[i].Val1;
756      Bucket.NIdV = TmIdEIdVV[i].Val2;
757    }
758  }
759  void TTimeNENet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
760    TIntV NIdV;  GetNIdByTm(NIdV);
761    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
762    for (int i = 0; i < NIdV.Len(); i++) {
763      const int b = i/NodesPerBucket;
764      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
765      TmBucketV[b].NIdV.Add(NIdV[i]);
766    }
767  }
768  void TTimeNENet::GetEdgeBuckets(const int EdgesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
769    TIntV EIdV;  GetEIdByTm(EIdV);
770    TmBucketV.Gen(EIdV.Len()/EdgesPerBucket + 1, 0);
771    for (int i = 0; i < EIdV.Len(); i++) {
772      const int b = i/EdgesPerBucket;
773      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
774      TmBucketV[b].NIdV.Add(EIdV[i]);
775    }
776  }
777  int TTimeNENet::GetTriadEdges(TIntV& TriadEIdV) const {
778    PUNGraph Graph = TUNGraph::New(GetNodes(), GetEdges());
779    TIntV EIdV;  GetEIdByTm(EIdV);
780    TriadEIdV.Clr();
781    TExeTm ExeTm;
782    for (int edge = 0; edge < EIdV.Len(); edge++) {
783      const TEdgeI EI = GetEI(EIdV[edge]);
784      const int Src = EI.GetSrcNId();
785      const int Dst = EI.GetDstNId();
786      if (Src==Dst || Graph->IsEdge(Src, Dst)) { continue; } 
787      if (! Graph->IsNode(Src)) { Graph->AddNode(Src); }
788      if (! Graph->IsNode(Dst)) { Graph->AddNode(Dst); }
789      if (TSnap::GetCmnNbrs(Graph, Src, Dst) > 0) { TriadEIdV.Add(EIdV[edge]); }
790      Graph->AddEdge(Src, Dst);
791      if (edge % 10000 == 0) {
792        printf("\redges %dk / %dk: triangle edges: %dk [total %s]", edge/1000, EIdV.Len()/1000,
793          TriadEIdV.Len()/1000, ExeTm.GetStr()); }
794    }
795    return Graph->GetEdges();
796  }
797  PGStatVec TTimeNENet::TimeGrowth(const TTmUnit& TimeStep, const TFSet& TakeStat, const TSecTm& StartTm) const {
798    TExeTm ExeTm;
799    PGStatVec GStatVec = TGStatVec::New(TimeStep, TakeStat);
800    TTimeNet::TTmBucketV TmBucketV;
801    GetEdgeTmBuckets(TimeStep, TmBucketV);
802    const PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
803    TIntV EdgeIdV;
804    for (int t = 0; t < TmBucketV.Len(); t++) {
805      EdgeIdV.AddV(TmBucketV[t].NIdV); 
806      printf("\n***%d/%d: %s (%d edges) ", t+1, TmBucketV.Len(), TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
807      if (TmBucketV[t].BegTm < StartTm) { continue; }
808      const PNEGraph PreGraph = TSnap::GetESubGraph(FullGraph, EdgeIdV);
809      GStatVec->Add(PreGraph, TmBucketV[t].BegTm);
810      printf("  [%s]\n", ExeTm.GetTmStr());
811    }
812    return GStatVec;
813  }
814  PGStatVec TTimeNENet::TimeGrowth(const TStr& FNmPref, const TStr& Desc, const TFSet& TakeStat, const int& NDiamRuns,
815                              const TTmUnit& TmUnit, const int& TakeNTmUnits, const bool& LinkBWays) const {
816    TGStat::NDiamRuns = NDiamRuns;
817    PGStatVec GrowthStat = TGStatVec::New(TmUnit, TakeStat);
818    TTimeNet::TTmBucketV TmBucketV;
819    GetEdgeTmBuckets(TmUnit, TmBucketV);
820    TIntV EdgeIdV;
821    TExeTm ExeTm;
822    for (int t = 0; t < TmBucketV.Len(); t++) {
823      if (TakeNTmUnits == -1) {
824        EdgeIdV.AddV(TmBucketV[t].NIdV); }
825      else {
826        if (t < TakeNTmUnits) { continue; }
827        EdgeIdV.Clr(false);
828        for (int i = t-TakeNTmUnits; i < t; i++) { EdgeIdV.AddV(TmBucketV[i].NIdV); }
829      }
830      printf("*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
831      PNEGraph PreGraph = TSnap::ConvertESubGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this), EdgeIdV);
832      if (LinkBWays) {
833        TIntV KeepEIdV; 
834        for (TNEGraph::TEdgeI EI = PreGraph->BegEI(); EI < PreGraph->EndEI(); EI++) {
835          if (PreGraph->IsEdge(EI.GetDstNId(), EI.GetSrcNId(), true)) { KeepEIdV.Add(EI.GetId()); }
836        }
837        PreGraph = TSnap::GetESubGraph(PreGraph, KeepEIdV);
838      }
839      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
840      { TFOut FOut(TStr::Fmt("growth.%s.gStatVec", FNmPref.CStr()));
841      GrowthStat->Save(FOut); }
842      GrowthStat->SaveTxt(FNmPref, Desc);
843      printf("  [%s]\n", ExeTm.GetTmStr());
844    }
845    return GrowthStat;
846  }
847  void TTimeNENet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
848                               const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc) const {
849    TTimeNet::TTmBucketV TmBucketV;
850    GetEdgeTmBuckets(TmUnit, TmBucketV);
851    PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
852    TIntV EdgeIdV;
853    TExeTm ExeTm, Run1Tm;
854    TFltTrV TmDiamV, NdsDiamV;
855    for (int t = 0; t < TmBucketV.Len(); t++) {
856      EdgeIdV.AddV(TmBucketV[t].NIdV); 
857      printf("\n*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), EdgeIdV.Len());  ExeTm.Tick();
858      if (TmBucketV[t].BegTm < StartTm) continue;
859      PNGraph PreGraph = TSnap::ConvertESubGraph<PNGraph>(FullGraph, EdgeIdV);
860      TMom Mom;
861      double EffDiam = 0.0;
862      for (int r = 0; r < NDiamRuns; r++) {
863        printf("%d...", r+1);  Run1Tm.Tick();
864        if (OnlyWcc) { EffDiam = TSnap::GetAnfEffDiam(TSnap::GetMxWcc(PreGraph)); }
865        else { EffDiam = TSnap::GetAnfEffDiam(PreGraph); }
866        Mom.Add(EffDiam);
867        printf("[%s]\r", Run1Tm.GetTmStr());
868      }
869      Mom.Def();
870      TmDiamV.Add(TFltTr(TmBucketV[t].BegTm.Round(TmUnit).GetAbsSecs(), Mom.GetMean(), Mom.GetSDev()));
871      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
872      NdsDiamV.Sort();
873      printf("  [%s]          \n", ExeTm.GetTmStr());
874      const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
875      { TGnuPlot GnuPlot("diamEff1."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
876      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), "AVERAGE "+WccStr+"Effective Diameter");
877      GnuPlot.AddErrBar(TmDiamV, "", "");
878      GnuPlot.SavePng(); }
879      { TGnuPlot GnuPlot("diamEff2."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
880      GnuPlot.SetXYLabel("NODES", "AVERAGE "+WccStr+"Effective Diameter");
881      GnuPlot.AddErrBar(NdsDiamV, "", "");
882      GnuPlot.SavePng(); }
883    }
884  }
885  void TTimeNENet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
886                                   const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam, const bool& LinkBWays) {
887    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
888      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
889    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
890      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
891  }
892  PTimeNENet TTimeNENet::GetGnmRndNet(const int& Nodes, const int& Edges) {
893    printf("Generating G_nm(%d, %d)\n", Nodes, Edges);
894    int Src, Dst;
895    PTimeNENet Net = TTimeNENet::New();
896    Net->Reserve(Nodes, Edges);
897    for (int e = 0; e < Edges; e++) {
898      Src = TInt::Rnd.GetUniDevInt(Nodes);
899      Dst = TInt::Rnd.GetUniDevInt(Nodes);
900      while (Dst == Src || Net->IsEdge(Src, Dst)) {
901        Dst = TInt::Rnd.GetUniDevInt(Nodes); }
902      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(e)); }
903      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(e)); }
904      Net->AddEdge(Src, Dst, -1, TSecTm(e));
905    }
906    return Net;
907  }
908  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& Edges, const double& GammaIn, const double& GammaOut) {
909    const double Alpha = Nodes/double(Edges);
910    printf("Generating PA(%d, %d), with slope in:%.1f, out: %.1f\n", Nodes, Edges,
911      2+GammaIn/(Alpha/(1-Alpha)), 2+GammaOut/(Alpha/(1-Alpha)));
912    int nodes=0, edges=0, time=0, iter=0;
913    TIntV OutW(Edges, 0), InW(Edges, 0);
914    PTimeNENet Net = TTimeNENet::New();
915    Net->Reserve(Nodes, Edges);
916    Net->AddNode(0, TSecTm(time++));  nodes++;
917    OutW.Add(0);  InW.Add(0);
918    while (edges < Edges) {
919      int Src=-1, Dst=-1;  iter++;
920      if (TInt::Rnd.GetUniDev() < Alpha) {
921        if (nodes < Nodes) {
922          IAssert(Net->AddNode(nodes, TSecTm(time++)));
923          nodes++; }
924      } else {
925        if (TInt::Rnd.GetUniDev() < nodes*GammaIn/double(edges+nodes*GammaIn)) {
926          Src = TInt::Rnd.GetUniDevInt(nodes); }
927        else { Src = OutW[TInt::Rnd.GetUniDevInt(OutW.Len())]; }
928        if (TInt::Rnd.GetUniDev() < nodes*GammaOut/double(edges+nodes*GammaOut)) {
929          Dst = TInt::Rnd.GetUniDevInt(nodes); }
930        else { Dst = InW[TInt::Rnd.GetUniDevInt(InW.Len())]; }
931      }
932      if (Src == Dst || Net->IsEdge(Src, Dst)) {
933        continue;
934      }
935      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(time++)); nodes++; }
936      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(time++)); nodes++; }
937      Net->AddEdge(Src, Dst, -1, TSecTm(time++));
938      OutW.Add(Src); InW.Add(Dst); edges++;
939    }
940    for (int node = 0; node < Nodes; node++) {
941      if (! Net->IsNode(node)) {
942        Net->AddNode(node, TSecTm(time++)); }
943    }
944    return Net;
945  }
946  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& OutDeg) {
947    printf("Generating PA, nodes:%d, out-deg:%d\n", Nodes, OutDeg);
948    int time=0;
949    PTimeNENet Net = TTimeNENet::New();
950    Net->Reserve(Nodes, OutDeg*Nodes);
951    Net->AddNode(0, TSecTm(++time));  Net->AddNode(1, TSecTm(++time));
952    Net->AddEdge(0, 1, -1, TSecTm(++time));
953    TIntV NIdV;  NIdV.Add(0);  NIdV.Add(1);
954    TIntSet NodeSet;
955    for (int node = 2; node <= Nodes; node++) {
956      NodeSet.Clr(false);
957      while (NodeSet.Len() < OutDeg && NodeSet.Len() < node) {
958        NodeSet.AddKey(NIdV[TInt::Rnd.GetUniDevInt(NIdV.Len())]);
959      }
960      const int N = Net->AddNode(node, TSecTm(++time));
961      for (int i = 0; i < NodeSet.Len(); i++) {
962        Net->AddEdge(node, NodeSet[i], -1, TSecTm(++time));
963        NIdV.Add(N);  NIdV.Add(NodeSet[i]);
964      }
965    }
966    return Net;
967  }
968  void TTimeNENet::SaveEdgeTm(const TStr& EdgeFNm, const bool& RenumberNId, const bool& RelativeTm) const {
969    TIntV EIdV;  GetEIdByTm(EIdV);
970    const int BegTm = RelativeTm ? GetEDat(EIdV[0]).GetAbsSecs() : 0;
971    TIntSet NIdMap;
972    if (RenumberNId) { NIdMap.Gen(GetNodes()); }
973    FILE *F = fopen(EdgeFNm.CStr(), "wt");
974    for (int e =0; e < EIdV.Len(); e++) {
975      const TEdgeI EI = GetEI(EIdV[e]);
976      if (RenumberNId) {
977        const int src = EI.GetSrcNId();
978        const int dst = EI.GetDstNId();
979        NIdMap.AddKey(src);  NIdMap.AddKey(dst);
980        fprintf(F, "%d\t%d\t%d\n", NIdMap.GetKeyId(src), NIdMap.GetKeyId(dst), EI().GetAbsSecs()-BegTm);
981      }else {
982        fprintf(F, "%d\t%d\t%d\n", EI.GetSrcNId(), EI.GetDstNId(), EI().GetAbsSecs()-BegTm); }
983    }
984    fclose(F);
985  }
986  PTimeNENet TTimeNENet::GetSmallNet() {
987    PTimeNENet Net = TTimeNENet::New();
988    for (int i = 1; i <= 6; i++) {
989      Net->AddNode(i, TSecTm(0)); }
990    int tm = 1;
991    Net->AddEdge(1, 2, -1, TSecTm(tm++));
992    Net->AddEdge(3, 4, -1, TSecTm(tm++));
993    Net->AddEdge(3, 1, -1, TSecTm(tm++));
994    Net->AddEdge(5, 6, -1, TSecTm(tm++));
995    Net->AddEdge(6, 4, -1, TSecTm(tm++));
996    Net->AddEdge(5, 3, -1, TSecTm(tm++));
997    Net->AddEdge(5, 4, -1, TSecTm(tm++));
998    Net->AddEdge(5, 2, -1, TSecTm(tm++));
999    return Net;
1000  }
1001  PTimeNENet TTimeNENet::LoadFlickr(const TStr& NodeFNm, const TStr& EdgeFNm) {
1002    const int BegOfTm = 1047369600; 
1003    PTimeNENet Net = TTimeNENet::New();
1004    printf("Adding nodes...");
1005    { TSsParser Ss(NodeFNm, ssfWhiteSep);
1006    while (Ss.Next()) {
1007      const int NId = Ss.GetInt(0);
1008      const int Tm = Ss.GetInt(1)+BegOfTm;
1009      if (TSecTm(Tm) < TSecTm(2002, 1, 1)) {
1010        printf("  skip node %g (time %d)\n", (double) Ss.GetLineNo(), Ss.GetInt(1)); continue; }
1011      Net->AddNode(NId, TSecTm(Tm));
1012    } }
1013    printf(" %d nodes\n", Net->GetNodes());
1014    printf("Adding edges...");
1015    int SkipCnt=0;
1016    { TSsParser Ss(EdgeFNm, ssfWhiteSep);
1017    while (Ss.Next()) {
1018      const int NId1 = Ss.GetInt(0);
1019      const int NId2 = Ss.GetInt(1);
1020      const TSecTm Tm = TSecTm(Ss.GetInt(2)+BegOfTm);
1021      if (! Net->IsNode(NId1) || ! Net->IsNode(NId2)) { printf("not node\n"); continue; }
1022      if (Tm < TSecTm(2002, 1, 1)) { SkipCnt++;
1023        printf("  skip edge %g (time %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr()); continue; }
1024      if (Tm+600 < Net->GetNDat(NId1)) {
1025        printf("  1:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId1).GetStr().CStr());
1026        SkipCnt++;  continue; }
1027      if (Tm+600 < Net->GetNDat(NId2)) { SkipCnt++;
1028        printf("  2:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId2).GetStr().CStr());
1029        SkipCnt++;  continue; }
1030      Net->AddEdge(NId1, NId2, -1, TSecTm(Tm));
1031    } }
1032    printf("  %d edges\n", Net->GetEdges());
1033    printf("  %d edges skipped (edge time < node time)\n", SkipCnt);
1034    Net->UpdateNodeTimes();
1035    return Net;
1036  }
1037  PTimeNENet TTimeNENet::LoadEdgeTm(const TStr& EdgeFNm, const int& SrcFld, const int& DstFld, const int& TimeFld, const TSsFmt& Separator) {
1038    printf("Loading %s\n", EdgeFNm.CStr());
1039    PTimeNENet Net = TTimeNENet::New();
1040    TStrHash<TInt> StrToId(Mega(1), true); 
1041    int LineCnt=0;
1042    TExeTm ExeTm;
1043    TSsParser Ss(EdgeFNm, Separator);
1044    TSecTm MinTm=TSecTm::GetCurTm(), MaxTm=TSecTm(100);
1045    while (Ss.Next()) {
1046      if (Ss.IsCmt()) { continue; }
1047      IAssert(Ss.Len() > TimeFld);
1048      const char* Node1 = Ss.GetFld(SrcFld);
1049      const char* Node2 = Ss.GetFld(DstFld);
1050      const char* TmStr = Ss.GetFld(TimeFld);
1051      if (strcmp(TmStr,"NULL")==0) { continue; }
1052      const TSecTm Tm(atoi(TmStr));
1053      const int NId1 = StrToId.AddKey(Node1);
1054      const int NId2 = StrToId.AddKey(Node2);
1055      if (! Net->IsNode(NId1)) { Net->AddNode(NId1, TSecTm()); }
1056      if (! Net->IsNode(NId2)) { Net->AddNode(NId2, TSecTm()); }
1057      MinTm=TMath::Mn(MinTm, Tm);
1058      MaxTm=TMath::Mx(MaxTm, Tm);
1059      Net->AddEdge(NId1, NId2, -1, Tm);
1060      if (++LineCnt % 1000 == 0) {
1061        printf("\r  %dk lines processed: %d %d [%s]", LineCnt/1000, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr()); }
1062    }
1063    printf("\r  %d lines processed: %d %d [%s]\n", LineCnt, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr());
1064    printf("  Data range %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1065    Net->UpdateNodeTimes();
1066    return Net;
1067  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmdirected.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</div>
                <div class="column column_space"><pre><code>258        if (Jacc > MaxJac) { continue; }
259        ComG->AddNode(c);
260      }
261      TVec<TIntSet> CmtySVIn, CmtySVOut;
262      for (int c = 0; c < Coms; c++) {
263        TIntV CmtyVIn, CmtyVOut;
264        InCmtyValHV[c].GetKeyV(CmtyVIn);
265        OutCmtyValHV[c].GetKeyV(CmtyVOut);
266        TIntSet CmtySIn(CmtyVIn), CmtySOut(CmtyVOut);
267        CmtySVIn.Add(CmtySIn);
268        CmtySVOut.Add(CmtySOut);
269      }
270      for (int c1 = 0; c1 < Coms; c1++) {
</pre></code></div>
                <div class="column column_space"><pre><code>681        RndEIdV.Swap(TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge, TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge); }
682    }
683    for (int e = 0; e < TrueEIdV.Len(); e++) {
684      TrueTmV.Add(GetEDat(TrueEIdV[e])); }
685    for (int e = 0; e < RndEIdV.Len(); e++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    