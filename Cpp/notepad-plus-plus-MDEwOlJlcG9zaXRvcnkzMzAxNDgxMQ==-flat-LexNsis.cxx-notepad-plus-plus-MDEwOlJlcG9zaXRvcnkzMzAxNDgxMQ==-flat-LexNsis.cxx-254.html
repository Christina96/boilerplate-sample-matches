
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Scintilla.h&quot;
11  #include &quot;SciLexer.h&quot;
12  #include &quot;WordList.h&quot;
13  #include &quot;LexAccessor.h&quot;
14  #include &quot;Accessor.h&quot;
15  #include &quot;StyleContext.h&quot;
16  #include &quot;CharacterSet.h&quot;
17  #include &quot;LexerModule.h&quot;
18  using namespace Lexilla;
19  static bool isNsisNumber(char ch)
20  {
21    return (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;);
22  }
23  static bool isNsisChar(char ch)
24  {
25    return (ch == &#x27;.&#x27; ) || (ch == &#x27;_&#x27; ) || isNsisNumber(ch) || (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) || (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;);
26  }
27  static bool isNsisLetter(char ch)
28  {
29    return (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) || (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;);
30  }
31  static bool NsisNextLineHasElse(Sci_PositionU start, Sci_PositionU end, Accessor &amp;styler)
32  {
33    Sci_Position nNextLine = -1;
34    for( Sci_PositionU i = start; i &lt; end; i++ )
35    {
36      char cNext = styler.SafeGetCharAt( i );
37      if( cNext == &#x27;\n&#x27; )
38      {
39        nNextLine = i+1;
40        break;
41      }
42    }
43    if( nNextLine == -1 ) 
44      return false;
45    for( Sci_PositionU firstChar = nNextLine; firstChar &lt; end; firstChar++ )
46    {
47      char cNext = styler.SafeGetCharAt( firstChar );
48      if( cNext == &#x27; &#x27; )
49        continue;
50      if( cNext == &#x27;\t&#x27; )
51        continue;
52      if( cNext == &#x27;!&#x27; )
53      {
54        if( styler.Match(firstChar, &quot;!else&quot;) )
55          return true;
56      }
57      break;
58    }
59    return false;
60  }
61  static int NsisCmp( const char *s1, const char *s2, bool bIgnoreCase )
62  {
63    if( bIgnoreCase )
64       return CompareCaseInsensitive( s1, s2);
65    return strcmp( s1, s2 );
66  }
67  static int calculateFoldNsis(Sci_PositionU start, Sci_PositionU end, int foldlevel, Accessor &amp;styler, bool bElse, bool foldUtilityCmd )
68  {
69    int style = styler.StyleAt(end);
70    if( end - start &gt; 20 )
71      return foldlevel;
72    if( foldUtilityCmd )
73    {
74      if( style != SCE_NSIS_FUNCTIONDEF &amp;&amp; style != SCE_NSIS_SECTIONDEF &amp;&amp;
75          style != SCE_NSIS_SUBSECTIONDEF &amp;&amp; style != SCE_NSIS_IFDEFINEDEF &amp;&amp;
76          style != SCE_NSIS_MACRODEF &amp;&amp; style != SCE_NSIS_SECTIONGROUP &amp;&amp;
77          style != SCE_NSIS_PAGEEX )
78            return foldlevel;
79    }
80    else
81    {
82      if( style != SCE_NSIS_FUNCTIONDEF &amp;&amp; style != SCE_NSIS_SECTIONDEF &amp;&amp;
83          style != SCE_NSIS_SUBSECTIONDEF &amp;&amp; style != SCE_NSIS_SECTIONGROUP &amp;&amp;
84          style != SCE_NSIS_PAGEEX )
85            return foldlevel;
86    }
87    int newFoldlevel = foldlevel;
88    bool bIgnoreCase = false;
89    if( styler.GetPropertyInt(&quot;nsis.ignorecase&quot;) == 1 )
<span onclick='openModal()' class='match'>90      bIgnoreCase = true;
91    char s[20]; 
92    s[0] = &#x27;\0&#x27;;
93    for (Sci_PositionU i = 0; i &lt; end - start + 1 &amp;&amp; i &lt; 19; i++)
</span>94  	{
95  		s[i] = static_cast&lt;char&gt;( styler[ start + i ] );
96  		s[i + 1] = &#x27;\0&#x27;;
97  	}
98    if( s[0] == &#x27;!&#x27; )
99    {
100      if( NsisCmp(s, &quot;!ifndef&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;!ifdef&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!ifmacrodef&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!ifmacrondef&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!if&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!macro&quot;, bIgnoreCase ) == 0 )
101        newFoldlevel++;
102      else if( NsisCmp(s, &quot;!endif&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;!macroend&quot;, bIgnoreCase ) == 0 )
103        newFoldlevel--;
104      else if( bElse &amp;&amp; NsisCmp(s, &quot;!else&quot;, bIgnoreCase) == 0 )
105        newFoldlevel++;
106    }
107    else
108    {
109      if( NsisCmp(s, &quot;Section&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;SectionGroup&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;Function&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;SubSection&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;PageEx&quot;, bIgnoreCase ) == 0 )
110        newFoldlevel++;
111      else if( NsisCmp(s, &quot;SectionGroupEnd&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;SubSectionEnd&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;FunctionEnd&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;SectionEnd&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;PageExEnd&quot;, bIgnoreCase ) == 0 )
112        newFoldlevel--;
113    }
114    return newFoldlevel;
115  }
116  static int classifyWordNsis(Sci_PositionU start, Sci_PositionU end, WordList *keywordLists[], Accessor &amp;styler )
117  {
118    bool bIgnoreCase = false;
119    if( styler.GetPropertyInt(&quot;nsis.ignorecase&quot;) == 1 )
120      bIgnoreCase = true;
121    bool bUserVars = false;
122    if( styler.GetPropertyInt(&quot;nsis.uservars&quot;) == 1 )
123      bUserVars = true;
124  	char s[100];
125  	s[0] = &#x27;\0&#x27;;
126  	s[1] = &#x27;\0&#x27;;
127  	WordList &amp;Functions = *keywordLists[0];
128  	WordList &amp;Variables = *keywordLists[1];
129  	WordList &amp;Lables = *keywordLists[2];
130  	WordList &amp;UserDefined = *keywordLists[3];
131  	for (Sci_PositionU i = 0; i &lt; end - start + 1 &amp;&amp; i &lt; 99; i++)
132  	{
133      if( bIgnoreCase )
134        s[i] = static_cast&lt;char&gt;( tolower(styler[ start + i ] ) );
135      else
136  		  s[i] = static_cast&lt;char&gt;( styler[ start + i ] );
137  		s[i + 1] = &#x27;\0&#x27;;
138  	}
139  	if( NsisCmp(s, &quot;!macro&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!macroend&quot;, bIgnoreCase) == 0 ) 
140  		return SCE_NSIS_MACRODEF;
141  	if( NsisCmp(s, &quot;!ifdef&quot;, bIgnoreCase ) == 0 ||  NsisCmp(s, &quot;!ifndef&quot;, bIgnoreCase) == 0 ||  NsisCmp(s, &quot;!endif&quot;, bIgnoreCase) == 0 ) 
142  		return SCE_NSIS_IFDEFINEDEF;
143  	if( NsisCmp(s, &quot;!if&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!else&quot;, bIgnoreCase )  == 0 ) 
144  		return SCE_NSIS_IFDEFINEDEF;
145  	if (NsisCmp(s, &quot;!ifmacrodef&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!ifmacrondef&quot;, bIgnoreCase )  == 0 ) 
146  		return SCE_NSIS_IFDEFINEDEF;
147    if( NsisCmp(s, &quot;SectionGroup&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;SectionGroupEnd&quot;, bIgnoreCase) == 0 ) 
148      return SCE_NSIS_SECTIONGROUP;
149  	if( NsisCmp(s, &quot;Section&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;SectionEnd&quot;, bIgnoreCase) == 0 ) 
150  		return SCE_NSIS_SECTIONDEF;
151  	if( NsisCmp(s, &quot;SubSection&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;SubSectionEnd&quot;, bIgnoreCase) == 0 ) 
152  		return SCE_NSIS_SUBSECTIONDEF;
153    if( NsisCmp(s, &quot;PageEx&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;PageExEnd&quot;, bIgnoreCase) == 0 ) 
154      return SCE_NSIS_PAGEEX;
155  	if( NsisCmp(s, &quot;Function&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;FunctionEnd&quot;, bIgnoreCase) == 0 ) 
156  		return SCE_NSIS_FUNCTIONDEF;
157  	if ( Functions.InList(s) )
158  		return SCE_NSIS_FUNCTION;
159  	if ( Variables.InList(s) )
160  		return SCE_NSIS_VARIABLE;
161  	if ( Lables.InList(s) )
162  		return SCE_NSIS_LABEL;
163  	if( UserDefined.InList(s) )
164  		return SCE_NSIS_USERDEFINED;
165  	if( strlen(s) &gt; 3 )
166  	{
167  		if( s[1] == &#x27;{&#x27; &amp;&amp; s[strlen(s)-1] == &#x27;}&#x27; )
168  			return SCE_NSIS_VARIABLE;
169  	}
170    if( s[0] == &#x27;$&#x27; &amp;&amp; bUserVars )
171    {
172      bool bHasSimpleNsisChars = true;
173      for (Sci_PositionU j = 1; j &lt; end - start + 1 &amp;&amp; j &lt; 99; j++)
174  	  {
175        if( !isNsisChar( s[j] ) )
176        {
177          bHasSimpleNsisChars = false;
178          break;
179        }
180  	  }
181      if( bHasSimpleNsisChars )
182        return SCE_NSIS_VARIABLE;
183    }
184    if( isNsisNumber( s[0] ) )
185    {
186      bool bHasSimpleNsisNumber = true;
187      for (Sci_PositionU j = 1; j &lt; end - start + 1 &amp;&amp; j &lt; 99; j++)
188  	  {
189        if( !isNsisNumber( s[j] ) )
190        {
191          bHasSimpleNsisNumber = false;
192          break;
193        }
194  	  }
195      if( bHasSimpleNsisNumber )
196        return SCE_NSIS_NUMBER;
197    }
198  	return SCE_NSIS_DEFAULT;
199  }
200  static void ColouriseNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *keywordLists[], Accessor &amp;styler)
201  {
202  	int state = SCE_NSIS_DEFAULT;
203    if( startPos &gt; 0 )
204      state = styler.StyleAt(startPos-1); 
205  	styler.StartAt( startPos );
206  	styler.GetLine( startPos );
207  	Sci_PositionU nLengthDoc = startPos + length;
208  	styler.StartSegment( startPos );
209  	char cCurrChar;
210  	bool bVarInString = false;
211    bool bClassicVarInString = false;
212  	Sci_PositionU i;
213  	for( i = startPos; i &lt; nLengthDoc; i++ )
214  	{
215  		cCurrChar = styler.SafeGetCharAt( i );
216  		char cNextChar = styler.SafeGetCharAt(i+1);
217  		switch(state)
218  		{
219  			case SCE_NSIS_DEFAULT:
220  				if( cCurrChar == &#x27;;&#x27; || cCurrChar == &#x27;#&#x27; ) 
221  				{
222  					styler.ColourTo(i-1, state );
223  					state = SCE_NSIS_COMMENT;
224  					break;
225  				}
226  				if( cCurrChar == &#x27;&quot;&#x27; )
227  				{
228  					styler.ColourTo(i-1, state );
229  					state = SCE_NSIS_STRINGDQ;
230  					bVarInString = false;
231            bClassicVarInString = false;
232  					break;
233  				}
234  				if( cCurrChar == &#x27;\&#x27;&#x27; )
235  				{
236  					styler.ColourTo(i-1, state );
237  					state = SCE_NSIS_STRINGRQ;
238  					bVarInString = false;
239            bClassicVarInString = false;
240  					break;
241  				}
242  				if( cCurrChar == &#x27;`&#x27; )
243  				{
244  					styler.ColourTo(i-1, state );
245  					state = SCE_NSIS_STRINGLQ;
246  					bVarInString = false;
247            bClassicVarInString = false;
248  					break;
249  				}
250  				if( cCurrChar == &#x27;$&#x27; || isNsisChar(cCurrChar) || cCurrChar == &#x27;!&#x27; )
251  				{
252  					styler.ColourTo(i-1,state);
253  				  state = SCE_NSIS_FUNCTION;
254            if( isNsisNumber(cCurrChar) &amp;&amp; (cNextChar == &#x27;\t&#x27; || cNextChar == &#x27; &#x27; || cNextChar == &#x27;\r&#x27; || cNextChar == &#x27;\n&#x27; ) )
255                styler.ColourTo( i, SCE_NSIS_NUMBER);
256  					break;
257  				}
258          if( cCurrChar == &#x27;/&#x27; &amp;&amp; cNextChar == &#x27;*&#x27; )
259          {
260            styler.ColourTo(i-1,state);
261            state = SCE_NSIS_COMMENTBOX;
262            break;
263          }
264  				break;
265  			case SCE_NSIS_COMMENT:
266  				if( cNextChar == &#x27;\n&#x27; || cNextChar == &#x27;\r&#x27; )
267          {
268            if( cCurrChar == &#x27;\\&#x27; )
269            {
270              styler.ColourTo(i-2,state);
271              styler.ColourTo(i,SCE_NSIS_DEFAULT);
272            }
273            else
274            {
275  				    styler.ColourTo(i,state);
276              state = SCE_NSIS_DEFAULT;
277            }
278          }
279  				break;
280  			case SCE_NSIS_STRINGDQ:
281        case SCE_NSIS_STRINGLQ:
282        case SCE_NSIS_STRINGRQ:
283          if( styler.SafeGetCharAt(i-1) == &#x27;\\&#x27; &amp;&amp; styler.SafeGetCharAt(i-2) == &#x27;$&#x27; )
284            break; 
285          if( cCurrChar == &#x27;&quot;&#x27; &amp;&amp; state == SCE_NSIS_STRINGDQ )
286  				{
287  					styler.ColourTo(i,state);
288  				  state = SCE_NSIS_DEFAULT;
289            break;
290  				}
291          if( cCurrChar == &#x27;`&#x27; &amp;&amp; state == SCE_NSIS_STRINGLQ )
292          {
293  					styler.ColourTo(i,state);
294  				  state = SCE_NSIS_DEFAULT;
295            break;
296  				}
297          if( cCurrChar == &#x27;\&#x27;&#x27; &amp;&amp; state == SCE_NSIS_STRINGRQ )
298  				{
299  					styler.ColourTo(i,state);
300  				  state = SCE_NSIS_DEFAULT;
301            break;
302  				}
303          if( cNextChar == &#x27;\r&#x27; || cNextChar == &#x27;\n&#x27; )
304          {
305            Sci_Position nCurLine = styler.GetLine(i+1);
306            Sci_Position nBack = i;
307            bool bNextLine = false;
308            while( nBack &gt; 0 )
309            {
310              if( styler.GetLine(nBack) != nCurLine )
311                break;
312              char cTemp = styler.SafeGetCharAt(nBack, &#x27;a&#x27;); 
313              if( cTemp == &#x27;\\&#x27; )
314              {
315                bNextLine = true;
316                break;
317              }
318              if( cTemp != &#x27;\r&#x27; &amp;&amp; cTemp != &#x27;\n&#x27; &amp;&amp; cTemp != &#x27;\t&#x27; &amp;&amp; cTemp != &#x27; &#x27; )
319                break;
320              nBack--;
321            }
322            if( bNextLine )
323            {
324              styler.ColourTo(i+1,state);
325            }
326            if( bNextLine == false )
327            {
328              styler.ColourTo(i,state);
329  				    state = SCE_NSIS_DEFAULT;
330            }
331          }
332  				break;
333  			case SCE_NSIS_FUNCTION:
334          if( cCurrChar == &#x27;$&#x27; )
335            state = SCE_NSIS_DEFAULT;
336          else if( cCurrChar == &#x27;\\&#x27; &amp;&amp; (cNextChar == &#x27;n&#x27; || cNextChar == &#x27;r&#x27; || cNextChar == &#x27;t&#x27; ) )
337            state = SCE_NSIS_DEFAULT;
338  				else if( (isNsisChar(cCurrChar) &amp;&amp; !isNsisChar( cNextChar) &amp;&amp; cNextChar != &#x27;}&#x27;) || cCurrChar == &#x27;}&#x27; )
339  				{
340  					state = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler );
341  					styler.ColourTo( i, state);
342  					state = SCE_NSIS_DEFAULT;
343  				}
344  				else if( !isNsisChar( cCurrChar ) &amp;&amp; cCurrChar != &#x27;{&#x27; &amp;&amp; cCurrChar != &#x27;}&#x27; )
345  				{
346            if( classifyWordNsis( styler.GetStartSegment(), i-1, keywordLists, styler) == SCE_NSIS_NUMBER )
347               styler.ColourTo( i-1, SCE_NSIS_NUMBER );
348  					state = SCE_NSIS_DEFAULT;
349  					if( cCurrChar == &#x27;&quot;&#x27; )
350  					{
351  						state = SCE_NSIS_STRINGDQ;
352  						bVarInString = false;
353              bClassicVarInString = false;
354  					}
355  					else if( cCurrChar == &#x27;`&#x27; )
356  					{
357  						state = SCE_NSIS_STRINGLQ;
358  						bVarInString = false;
359              bClassicVarInString = false;
360  					}
361  					else if( cCurrChar == &#x27;\&#x27;&#x27; )
362  					{
363  						state = SCE_NSIS_STRINGRQ;
364  						bVarInString = false;
365              bClassicVarInString = false;
366  					}
367  					else if( cCurrChar == &#x27;#&#x27; || cCurrChar == &#x27;;&#x27; )
368            {
369  						state = SCE_NSIS_COMMENT;
370            }
371  				}
372  				break;
373        case SCE_NSIS_COMMENTBOX:
374          if( styler.SafeGetCharAt(i-1) == &#x27;*&#x27; &amp;&amp; cCurrChar == &#x27;/&#x27; )
375          {
376            styler.ColourTo(i,state);
377            state = SCE_NSIS_DEFAULT;
378          }
379          break;
380  		}
381  		if( state == SCE_NSIS_COMMENT || state == SCE_NSIS_COMMENTBOX )
382  		{
383  			styler.ColourTo(i,state);
384  		}
385  		else if( state == SCE_NSIS_STRINGDQ || state == SCE_NSIS_STRINGLQ || state == SCE_NSIS_STRINGRQ )
386  		{
387        bool bIngoreNextDollarSign = false;
388        bool bUserVars = false;
389        if( styler.GetPropertyInt(&quot;nsis.uservars&quot;) == 1 )
390          bUserVars = true;
391        if( bVarInString &amp;&amp; cCurrChar == &#x27;$&#x27; )
392        {
393          bVarInString = false;
394          bIngoreNextDollarSign = true;
395        }
396        else if( bVarInString &amp;&amp; cCurrChar == &#x27;\\&#x27; &amp;&amp; (cNextChar == &#x27;n&#x27; || cNextChar == &#x27;r&#x27; || cNextChar == &#x27;t&#x27; || cNextChar == &#x27;&quot;&#x27; || cNextChar == &#x27;`&#x27; || cNextChar == &#x27;\&#x27;&#x27; ) )
397        {
398          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
399          bVarInString = false;
400          bIngoreNextDollarSign = false;
401        }
402        else if( bVarInString &amp;&amp; !isNsisChar(cNextChar) )
403        {
404          int nWordState = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler);
405  				if( nWordState == SCE_NSIS_VARIABLE )
406  					styler.ColourTo( i, SCE_NSIS_STRINGVAR);
407          else if( bUserVars )
408            styler.ColourTo( i, SCE_NSIS_STRINGVAR);
409          bVarInString = false;
410        }
411        else if( bClassicVarInString &amp;&amp; cNextChar == &#x27;}&#x27; )
412        {
413          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
414  				bClassicVarInString = false;
415        }
416  			if( !bIngoreNextDollarSign &amp;&amp; cCurrChar == &#x27;$&#x27; &amp;&amp; cNextChar == &#x27;{&#x27; )
417  			{
418  				styler.ColourTo( i-1, state);
419  				bClassicVarInString = true;
420          bVarInString = false;
421  			}
422        else if( !bIngoreNextDollarSign &amp;&amp; cCurrChar == &#x27;$&#x27; )
423        {
424          styler.ColourTo( i-1, state);
425          bVarInString = true;
426          bClassicVarInString = false;
427        }
428  		}
429  	}
430  	styler.ColourTo(nLengthDoc-1,state);
431  }
432  static void FoldNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &amp;styler)
433  {
434  	if( styler.GetPropertyInt(&quot;fold&quot;) == 0 )
435  		return;
436    bool foldAtElse = styler.GetPropertyInt(&quot;fold.at.else&quot;, 0) == 1;
437    bool foldUtilityCmd = styler.GetPropertyInt(&quot;nsis.foldutilcmd&quot;, 1) == 1;
438    bool blockComment = false;
439    Sci_Position lineCurrent = styler.GetLine(startPos);
440    Sci_PositionU safeStartPos = styler.LineStart( lineCurrent );
441    bool bArg1 = true;
442    Sci_Position nWordStart = -1;
443    int levelCurrent = SC_FOLDLEVELBASE;
444  	if (lineCurrent &gt; 0)
445  		levelCurrent = styler.LevelAt(lineCurrent-1) &gt;&gt; 16;
446  	int levelNext = levelCurrent;
447    int style = styler.StyleAt(safeStartPos);
448    if( style == SCE_NSIS_COMMENTBOX )
449    {
450      if( styler.SafeGetCharAt(safeStartPos) == &#x27;/&#x27; &amp;&amp; styler.SafeGetCharAt(safeStartPos+1) == &#x27;*&#x27; )
451        levelNext++;
452      blockComment = true;
453    }
454    for (Sci_PositionU i = safeStartPos; i &lt; startPos + length; i++)
455  	{
456      char chCurr = styler.SafeGetCharAt(i);
457      style = styler.StyleAt(i);
458      if( blockComment &amp;&amp; style != SCE_NSIS_COMMENTBOX )
459      {
460        levelNext--;
461        blockComment = false;
462      }
463      else if( !blockComment &amp;&amp; style == SCE_NSIS_COMMENTBOX )
464      {
465        levelNext++;
466        blockComment = true;
467      }
468      if( bArg1 &amp;&amp; !blockComment)
469      {
470        if( nWordStart == -1 &amp;&amp; (isNsisLetter(chCurr) || chCurr == &#x27;!&#x27;) )
471        {
472          nWordStart = i;
473        }
474        else if( isNsisLetter(chCurr) == false &amp;&amp; nWordStart &gt; -1 )
475        {
476          int newLevel = calculateFoldNsis( nWordStart, i-1, levelNext, styler, foldAtElse, foldUtilityCmd );
477          if( newLevel == levelNext )
478          {
479            if( foldAtElse &amp;&amp; foldUtilityCmd )
480            {
481              if( NsisNextLineHasElse(i, startPos + length, styler) )
482                levelNext--;
483            }
484          }
485          else
486            levelNext = newLevel;
487          bArg1 = false;
488        }
489      }
490      if( chCurr == &#x27;\n&#x27; )
491      {
492        if( bArg1 &amp;&amp; foldAtElse &amp;&amp; foldUtilityCmd &amp;&amp; !blockComment )
493        {
494          if( NsisNextLineHasElse(i, startPos + length, styler) )
495            levelNext--;
496        }
497        int levelUse = levelCurrent;
498  			int lev = levelUse | levelNext &lt;&lt; 16;
499        if (levelUse &lt; levelNext )
500  				lev |= SC_FOLDLEVELHEADERFLAG;
501  			if (lev != styler.LevelAt(lineCurrent))
502  				styler.SetLevel(lineCurrent, lev);
503  			lineCurrent++;
504  			levelCurrent = levelNext;
505        bArg1 = true; 
506        nWordStart = -1;
507      }
508    }
509  	int levelUse = levelCurrent;
510  	int lev = levelUse | levelNext &lt;&lt; 16;
511  	if (levelUse &lt; levelNext)
512  		lev |= SC_FOLDLEVELHEADERFLAG;
513  	if (lev != styler.LevelAt(lineCurrent))
514  		styler.SetLevel(lineCurrent, lev);
515  }
516  static const char * const nsisWordLists[] = {
517  	&quot;Functions&quot;,
518  	&quot;Variables&quot;,
519  	&quot;Lables&quot;,
520  	&quot;UserDefined&quot;,
521  	0, };
522  LexerModule lmNsis(SCLEX_NSIS, ColouriseNsisDoc, &quot;nsis&quot;, FoldNsisDoc, nsisWordLists);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Scintilla.h&quot;
11  #include &quot;SciLexer.h&quot;
12  #include &quot;WordList.h&quot;
13  #include &quot;LexAccessor.h&quot;
14  #include &quot;Accessor.h&quot;
15  #include &quot;StyleContext.h&quot;
16  #include &quot;CharacterSet.h&quot;
17  #include &quot;LexerModule.h&quot;
18  using namespace Lexilla;
19  static bool isNsisNumber(char ch)
20  {
21    return (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;);
22  }
23  static bool isNsisChar(char ch)
24  {
25    return (ch == &#x27;.&#x27; ) || (ch == &#x27;_&#x27; ) || isNsisNumber(ch) || (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) || (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;);
26  }
27  static bool isNsisLetter(char ch)
28  {
29    return (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) || (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;);
30  }
31  static bool NsisNextLineHasElse(Sci_PositionU start, Sci_PositionU end, Accessor &amp;styler)
32  {
33    Sci_Position nNextLine = -1;
34    for( Sci_PositionU i = start; i &lt; end; i++ )
35    {
36      char cNext = styler.SafeGetCharAt( i );
37      if( cNext == &#x27;\n&#x27; )
38      {
39        nNextLine = i+1;
40        break;
41      }
42    }
43    if( nNextLine == -1 ) 
44      return false;
45    for( Sci_PositionU firstChar = nNextLine; firstChar &lt; end; firstChar++ )
46    {
47      char cNext = styler.SafeGetCharAt( firstChar );
48      if( cNext == &#x27; &#x27; )
49        continue;
50      if( cNext == &#x27;\t&#x27; )
51        continue;
52      if( cNext == &#x27;!&#x27; )
53      {
54        if( styler.Match(firstChar, &quot;!else&quot;) )
55          return true;
56      }
57      break;
58    }
59    return false;
60  }
61  static int NsisCmp( const char *s1, const char *s2, bool bIgnoreCase )
62  {
63    if( bIgnoreCase )
64       return CompareCaseInsensitive( s1, s2);
65    return strcmp( s1, s2 );
66  }
67  static int calculateFoldNsis(Sci_PositionU start, Sci_PositionU end, int foldlevel, Accessor &amp;styler, bool bElse, bool foldUtilityCmd )
68  {
69    int style = styler.StyleAt(end);
70    if( end - start &gt; 20 )
71      return foldlevel;
72    if( foldUtilityCmd )
73    {
74      if( style != SCE_NSIS_FUNCTIONDEF &amp;&amp; style != SCE_NSIS_SECTIONDEF &amp;&amp;
75          style != SCE_NSIS_SUBSECTIONDEF &amp;&amp; style != SCE_NSIS_IFDEFINEDEF &amp;&amp;
76          style != SCE_NSIS_MACRODEF &amp;&amp; style != SCE_NSIS_SECTIONGROUP &amp;&amp;
77          style != SCE_NSIS_PAGEEX )
78            return foldlevel;
79    }
80    else
81    {
82      if( style != SCE_NSIS_FUNCTIONDEF &amp;&amp; style != SCE_NSIS_SECTIONDEF &amp;&amp;
83          style != SCE_NSIS_SUBSECTIONDEF &amp;&amp; style != SCE_NSIS_SECTIONGROUP &amp;&amp;
84          style != SCE_NSIS_PAGEEX )
85            return foldlevel;
86    }
87    int newFoldlevel = foldlevel;
88    bool bIgnoreCase = false;
89    if( styler.GetPropertyInt(&quot;nsis.ignorecase&quot;) == 1 )
90      bIgnoreCase = true;
91    char s[20]; 
92    s[0] = &#x27;\0&#x27;;
93    for (Sci_PositionU i = 0; i &lt; end - start + 1 &amp;&amp; i &lt; 19; i++)
94  	{
95  		s[i] = static_cast&lt;char&gt;( styler[ start + i ] );
96  		s[i + 1] = &#x27;\0&#x27;;
97  	}
98    if( s[0] == &#x27;!&#x27; )
99    {
100      if( NsisCmp(s, &quot;!ifndef&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;!ifdef&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!ifmacrodef&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!ifmacrondef&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!if&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!macro&quot;, bIgnoreCase ) == 0 )
101        newFoldlevel++;
102      else if( NsisCmp(s, &quot;!endif&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;!macroend&quot;, bIgnoreCase ) == 0 )
103        newFoldlevel--;
104      else if( bElse &amp;&amp; NsisCmp(s, &quot;!else&quot;, bIgnoreCase) == 0 )
105        newFoldlevel++;
106    }
107    else
108    {
109      if( NsisCmp(s, &quot;Section&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;SectionGroup&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;Function&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;SubSection&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;PageEx&quot;, bIgnoreCase ) == 0 )
110        newFoldlevel++;
111      else if( NsisCmp(s, &quot;SectionGroupEnd&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;SubSectionEnd&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;FunctionEnd&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;SectionEnd&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;PageExEnd&quot;, bIgnoreCase ) == 0 )
112        newFoldlevel--;
113    }
114    return newFoldlevel;
115  }
116  static int classifyWordNsis(Sci_PositionU start, Sci_PositionU end, WordList *keywordLists[], Accessor &amp;styler )
117  {
118    bool bIgnoreCase = false;
119    if( styler.GetPropertyInt(&quot;nsis.ignorecase&quot;) == 1 )
120      bIgnoreCase = true;
121    bool bUserVars = false;
122    if( styler.GetPropertyInt(&quot;nsis.uservars&quot;) == 1 )
<span onclick='openModal()' class='match'>123      bUserVars = true;
124  	char s[100];
125  	s[0] = &#x27;\0&#x27;;
126  	s[1] = &#x27;\0&#x27;;
</span>127  	WordList &amp;Functions = *keywordLists[0];
128  	WordList &amp;Variables = *keywordLists[1];
129  	WordList &amp;Lables = *keywordLists[2];
130  	WordList &amp;UserDefined = *keywordLists[3];
131  	for (Sci_PositionU i = 0; i &lt; end - start + 1 &amp;&amp; i &lt; 99; i++)
132  	{
133      if( bIgnoreCase )
134        s[i] = static_cast&lt;char&gt;( tolower(styler[ start + i ] ) );
135      else
136  		  s[i] = static_cast&lt;char&gt;( styler[ start + i ] );
137  		s[i + 1] = &#x27;\0&#x27;;
138  	}
139  	if( NsisCmp(s, &quot;!macro&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!macroend&quot;, bIgnoreCase) == 0 ) 
140  		return SCE_NSIS_MACRODEF;
141  	if( NsisCmp(s, &quot;!ifdef&quot;, bIgnoreCase ) == 0 ||  NsisCmp(s, &quot;!ifndef&quot;, bIgnoreCase) == 0 ||  NsisCmp(s, &quot;!endif&quot;, bIgnoreCase) == 0 ) 
142  		return SCE_NSIS_IFDEFINEDEF;
143  	if( NsisCmp(s, &quot;!if&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!else&quot;, bIgnoreCase )  == 0 ) 
144  		return SCE_NSIS_IFDEFINEDEF;
145  	if (NsisCmp(s, &quot;!ifmacrodef&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;!ifmacrondef&quot;, bIgnoreCase )  == 0 ) 
146  		return SCE_NSIS_IFDEFINEDEF;
147    if( NsisCmp(s, &quot;SectionGroup&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;SectionGroupEnd&quot;, bIgnoreCase) == 0 ) 
148      return SCE_NSIS_SECTIONGROUP;
149  	if( NsisCmp(s, &quot;Section&quot;, bIgnoreCase ) == 0 || NsisCmp(s, &quot;SectionEnd&quot;, bIgnoreCase) == 0 ) 
150  		return SCE_NSIS_SECTIONDEF;
151  	if( NsisCmp(s, &quot;SubSection&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;SubSectionEnd&quot;, bIgnoreCase) == 0 ) 
152  		return SCE_NSIS_SUBSECTIONDEF;
153    if( NsisCmp(s, &quot;PageEx&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;PageExEnd&quot;, bIgnoreCase) == 0 ) 
154      return SCE_NSIS_PAGEEX;
155  	if( NsisCmp(s, &quot;Function&quot;, bIgnoreCase) == 0 || NsisCmp(s, &quot;FunctionEnd&quot;, bIgnoreCase) == 0 ) 
156  		return SCE_NSIS_FUNCTIONDEF;
157  	if ( Functions.InList(s) )
158  		return SCE_NSIS_FUNCTION;
159  	if ( Variables.InList(s) )
160  		return SCE_NSIS_VARIABLE;
161  	if ( Lables.InList(s) )
162  		return SCE_NSIS_LABEL;
163  	if( UserDefined.InList(s) )
164  		return SCE_NSIS_USERDEFINED;
165  	if( strlen(s) &gt; 3 )
166  	{
167  		if( s[1] == &#x27;{&#x27; &amp;&amp; s[strlen(s)-1] == &#x27;}&#x27; )
168  			return SCE_NSIS_VARIABLE;
169  	}
170    if( s[0] == &#x27;$&#x27; &amp;&amp; bUserVars )
171    {
172      bool bHasSimpleNsisChars = true;
173      for (Sci_PositionU j = 1; j &lt; end - start + 1 &amp;&amp; j &lt; 99; j++)
174  	  {
175        if( !isNsisChar( s[j] ) )
176        {
177          bHasSimpleNsisChars = false;
178          break;
179        }
180  	  }
181      if( bHasSimpleNsisChars )
182        return SCE_NSIS_VARIABLE;
183    }
184    if( isNsisNumber( s[0] ) )
185    {
186      bool bHasSimpleNsisNumber = true;
187      for (Sci_PositionU j = 1; j &lt; end - start + 1 &amp;&amp; j &lt; 99; j++)
188  	  {
189        if( !isNsisNumber( s[j] ) )
190        {
191          bHasSimpleNsisNumber = false;
192          break;
193        }
194  	  }
195      if( bHasSimpleNsisNumber )
196        return SCE_NSIS_NUMBER;
197    }
198  	return SCE_NSIS_DEFAULT;
199  }
200  static void ColouriseNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *keywordLists[], Accessor &amp;styler)
201  {
202  	int state = SCE_NSIS_DEFAULT;
203    if( startPos &gt; 0 )
204      state = styler.StyleAt(startPos-1); 
205  	styler.StartAt( startPos );
206  	styler.GetLine( startPos );
207  	Sci_PositionU nLengthDoc = startPos + length;
208  	styler.StartSegment( startPos );
209  	char cCurrChar;
210  	bool bVarInString = false;
211    bool bClassicVarInString = false;
212  	Sci_PositionU i;
213  	for( i = startPos; i &lt; nLengthDoc; i++ )
214  	{
215  		cCurrChar = styler.SafeGetCharAt( i );
216  		char cNextChar = styler.SafeGetCharAt(i+1);
217  		switch(state)
218  		{
219  			case SCE_NSIS_DEFAULT:
220  				if( cCurrChar == &#x27;;&#x27; || cCurrChar == &#x27;#&#x27; ) 
221  				{
222  					styler.ColourTo(i-1, state );
223  					state = SCE_NSIS_COMMENT;
224  					break;
225  				}
226  				if( cCurrChar == &#x27;&quot;&#x27; )
227  				{
228  					styler.ColourTo(i-1, state );
229  					state = SCE_NSIS_STRINGDQ;
230  					bVarInString = false;
231            bClassicVarInString = false;
232  					break;
233  				}
234  				if( cCurrChar == &#x27;\&#x27;&#x27; )
235  				{
236  					styler.ColourTo(i-1, state );
237  					state = SCE_NSIS_STRINGRQ;
238  					bVarInString = false;
239            bClassicVarInString = false;
240  					break;
241  				}
242  				if( cCurrChar == &#x27;`&#x27; )
243  				{
244  					styler.ColourTo(i-1, state );
245  					state = SCE_NSIS_STRINGLQ;
246  					bVarInString = false;
247            bClassicVarInString = false;
248  					break;
249  				}
250  				if( cCurrChar == &#x27;$&#x27; || isNsisChar(cCurrChar) || cCurrChar == &#x27;!&#x27; )
251  				{
252  					styler.ColourTo(i-1,state);
253  				  state = SCE_NSIS_FUNCTION;
254            if( isNsisNumber(cCurrChar) &amp;&amp; (cNextChar == &#x27;\t&#x27; || cNextChar == &#x27; &#x27; || cNextChar == &#x27;\r&#x27; || cNextChar == &#x27;\n&#x27; ) )
255                styler.ColourTo( i, SCE_NSIS_NUMBER);
256  					break;
257  				}
258          if( cCurrChar == &#x27;/&#x27; &amp;&amp; cNextChar == &#x27;*&#x27; )
259          {
260            styler.ColourTo(i-1,state);
261            state = SCE_NSIS_COMMENTBOX;
262            break;
263          }
264  				break;
265  			case SCE_NSIS_COMMENT:
266  				if( cNextChar == &#x27;\n&#x27; || cNextChar == &#x27;\r&#x27; )
267          {
268            if( cCurrChar == &#x27;\\&#x27; )
269            {
270              styler.ColourTo(i-2,state);
271              styler.ColourTo(i,SCE_NSIS_DEFAULT);
272            }
273            else
274            {
275  				    styler.ColourTo(i,state);
276              state = SCE_NSIS_DEFAULT;
277            }
278          }
279  				break;
280  			case SCE_NSIS_STRINGDQ:
281        case SCE_NSIS_STRINGLQ:
282        case SCE_NSIS_STRINGRQ:
283          if( styler.SafeGetCharAt(i-1) == &#x27;\\&#x27; &amp;&amp; styler.SafeGetCharAt(i-2) == &#x27;$&#x27; )
284            break; 
285          if( cCurrChar == &#x27;&quot;&#x27; &amp;&amp; state == SCE_NSIS_STRINGDQ )
286  				{
287  					styler.ColourTo(i,state);
288  				  state = SCE_NSIS_DEFAULT;
289            break;
290  				}
291          if( cCurrChar == &#x27;`&#x27; &amp;&amp; state == SCE_NSIS_STRINGLQ )
292          {
293  					styler.ColourTo(i,state);
294  				  state = SCE_NSIS_DEFAULT;
295            break;
296  				}
297          if( cCurrChar == &#x27;\&#x27;&#x27; &amp;&amp; state == SCE_NSIS_STRINGRQ )
298  				{
299  					styler.ColourTo(i,state);
300  				  state = SCE_NSIS_DEFAULT;
301            break;
302  				}
303          if( cNextChar == &#x27;\r&#x27; || cNextChar == &#x27;\n&#x27; )
304          {
305            Sci_Position nCurLine = styler.GetLine(i+1);
306            Sci_Position nBack = i;
307            bool bNextLine = false;
308            while( nBack &gt; 0 )
309            {
310              if( styler.GetLine(nBack) != nCurLine )
311                break;
312              char cTemp = styler.SafeGetCharAt(nBack, &#x27;a&#x27;); 
313              if( cTemp == &#x27;\\&#x27; )
314              {
315                bNextLine = true;
316                break;
317              }
318              if( cTemp != &#x27;\r&#x27; &amp;&amp; cTemp != &#x27;\n&#x27; &amp;&amp; cTemp != &#x27;\t&#x27; &amp;&amp; cTemp != &#x27; &#x27; )
319                break;
320              nBack--;
321            }
322            if( bNextLine )
323            {
324              styler.ColourTo(i+1,state);
325            }
326            if( bNextLine == false )
327            {
328              styler.ColourTo(i,state);
329  				    state = SCE_NSIS_DEFAULT;
330            }
331          }
332  				break;
333  			case SCE_NSIS_FUNCTION:
334          if( cCurrChar == &#x27;$&#x27; )
335            state = SCE_NSIS_DEFAULT;
336          else if( cCurrChar == &#x27;\\&#x27; &amp;&amp; (cNextChar == &#x27;n&#x27; || cNextChar == &#x27;r&#x27; || cNextChar == &#x27;t&#x27; ) )
337            state = SCE_NSIS_DEFAULT;
338  				else if( (isNsisChar(cCurrChar) &amp;&amp; !isNsisChar( cNextChar) &amp;&amp; cNextChar != &#x27;}&#x27;) || cCurrChar == &#x27;}&#x27; )
339  				{
340  					state = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler );
341  					styler.ColourTo( i, state);
342  					state = SCE_NSIS_DEFAULT;
343  				}
344  				else if( !isNsisChar( cCurrChar ) &amp;&amp; cCurrChar != &#x27;{&#x27; &amp;&amp; cCurrChar != &#x27;}&#x27; )
345  				{
346            if( classifyWordNsis( styler.GetStartSegment(), i-1, keywordLists, styler) == SCE_NSIS_NUMBER )
347               styler.ColourTo( i-1, SCE_NSIS_NUMBER );
348  					state = SCE_NSIS_DEFAULT;
349  					if( cCurrChar == &#x27;&quot;&#x27; )
350  					{
351  						state = SCE_NSIS_STRINGDQ;
352  						bVarInString = false;
353              bClassicVarInString = false;
354  					}
355  					else if( cCurrChar == &#x27;`&#x27; )
356  					{
357  						state = SCE_NSIS_STRINGLQ;
358  						bVarInString = false;
359              bClassicVarInString = false;
360  					}
361  					else if( cCurrChar == &#x27;\&#x27;&#x27; )
362  					{
363  						state = SCE_NSIS_STRINGRQ;
364  						bVarInString = false;
365              bClassicVarInString = false;
366  					}
367  					else if( cCurrChar == &#x27;#&#x27; || cCurrChar == &#x27;;&#x27; )
368            {
369  						state = SCE_NSIS_COMMENT;
370            }
371  				}
372  				break;
373        case SCE_NSIS_COMMENTBOX:
374          if( styler.SafeGetCharAt(i-1) == &#x27;*&#x27; &amp;&amp; cCurrChar == &#x27;/&#x27; )
375          {
376            styler.ColourTo(i,state);
377            state = SCE_NSIS_DEFAULT;
378          }
379          break;
380  		}
381  		if( state == SCE_NSIS_COMMENT || state == SCE_NSIS_COMMENTBOX )
382  		{
383  			styler.ColourTo(i,state);
384  		}
385  		else if( state == SCE_NSIS_STRINGDQ || state == SCE_NSIS_STRINGLQ || state == SCE_NSIS_STRINGRQ )
386  		{
387        bool bIngoreNextDollarSign = false;
388        bool bUserVars = false;
389        if( styler.GetPropertyInt(&quot;nsis.uservars&quot;) == 1 )
390          bUserVars = true;
391        if( bVarInString &amp;&amp; cCurrChar == &#x27;$&#x27; )
392        {
393          bVarInString = false;
394          bIngoreNextDollarSign = true;
395        }
396        else if( bVarInString &amp;&amp; cCurrChar == &#x27;\\&#x27; &amp;&amp; (cNextChar == &#x27;n&#x27; || cNextChar == &#x27;r&#x27; || cNextChar == &#x27;t&#x27; || cNextChar == &#x27;&quot;&#x27; || cNextChar == &#x27;`&#x27; || cNextChar == &#x27;\&#x27;&#x27; ) )
397        {
398          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
399          bVarInString = false;
400          bIngoreNextDollarSign = false;
401        }
402        else if( bVarInString &amp;&amp; !isNsisChar(cNextChar) )
403        {
404          int nWordState = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler);
405  				if( nWordState == SCE_NSIS_VARIABLE )
406  					styler.ColourTo( i, SCE_NSIS_STRINGVAR);
407          else if( bUserVars )
408            styler.ColourTo( i, SCE_NSIS_STRINGVAR);
409          bVarInString = false;
410        }
411        else if( bClassicVarInString &amp;&amp; cNextChar == &#x27;}&#x27; )
412        {
413          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
414  				bClassicVarInString = false;
415        }
416  			if( !bIngoreNextDollarSign &amp;&amp; cCurrChar == &#x27;$&#x27; &amp;&amp; cNextChar == &#x27;{&#x27; )
417  			{
418  				styler.ColourTo( i-1, state);
419  				bClassicVarInString = true;
420          bVarInString = false;
421  			}
422        else if( !bIngoreNextDollarSign &amp;&amp; cCurrChar == &#x27;$&#x27; )
423        {
424          styler.ColourTo( i-1, state);
425          bVarInString = true;
426          bClassicVarInString = false;
427        }
428  		}
429  	}
430  	styler.ColourTo(nLengthDoc-1,state);
431  }
432  static void FoldNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &amp;styler)
433  {
434  	if( styler.GetPropertyInt(&quot;fold&quot;) == 0 )
435  		return;
436    bool foldAtElse = styler.GetPropertyInt(&quot;fold.at.else&quot;, 0) == 1;
437    bool foldUtilityCmd = styler.GetPropertyInt(&quot;nsis.foldutilcmd&quot;, 1) == 1;
438    bool blockComment = false;
439    Sci_Position lineCurrent = styler.GetLine(startPos);
440    Sci_PositionU safeStartPos = styler.LineStart( lineCurrent );
441    bool bArg1 = true;
442    Sci_Position nWordStart = -1;
443    int levelCurrent = SC_FOLDLEVELBASE;
444  	if (lineCurrent &gt; 0)
445  		levelCurrent = styler.LevelAt(lineCurrent-1) &gt;&gt; 16;
446  	int levelNext = levelCurrent;
447    int style = styler.StyleAt(safeStartPos);
448    if( style == SCE_NSIS_COMMENTBOX )
449    {
450      if( styler.SafeGetCharAt(safeStartPos) == &#x27;/&#x27; &amp;&amp; styler.SafeGetCharAt(safeStartPos+1) == &#x27;*&#x27; )
451        levelNext++;
452      blockComment = true;
453    }
454    for (Sci_PositionU i = safeStartPos; i &lt; startPos + length; i++)
455  	{
456      char chCurr = styler.SafeGetCharAt(i);
457      style = styler.StyleAt(i);
458      if( blockComment &amp;&amp; style != SCE_NSIS_COMMENTBOX )
459      {
460        levelNext--;
461        blockComment = false;
462      }
463      else if( !blockComment &amp;&amp; style == SCE_NSIS_COMMENTBOX )
464      {
465        levelNext++;
466        blockComment = true;
467      }
468      if( bArg1 &amp;&amp; !blockComment)
469      {
470        if( nWordStart == -1 &amp;&amp; (isNsisLetter(chCurr) || chCurr == &#x27;!&#x27;) )
471        {
472          nWordStart = i;
473        }
474        else if( isNsisLetter(chCurr) == false &amp;&amp; nWordStart &gt; -1 )
475        {
476          int newLevel = calculateFoldNsis( nWordStart, i-1, levelNext, styler, foldAtElse, foldUtilityCmd );
477          if( newLevel == levelNext )
478          {
479            if( foldAtElse &amp;&amp; foldUtilityCmd )
480            {
481              if( NsisNextLineHasElse(i, startPos + length, styler) )
482                levelNext--;
483            }
484          }
485          else
486            levelNext = newLevel;
487          bArg1 = false;
488        }
489      }
490      if( chCurr == &#x27;\n&#x27; )
491      {
492        if( bArg1 &amp;&amp; foldAtElse &amp;&amp; foldUtilityCmd &amp;&amp; !blockComment )
493        {
494          if( NsisNextLineHasElse(i, startPos + length, styler) )
495            levelNext--;
496        }
497        int levelUse = levelCurrent;
498  			int lev = levelUse | levelNext &lt;&lt; 16;
499        if (levelUse &lt; levelNext )
500  				lev |= SC_FOLDLEVELHEADERFLAG;
501  			if (lev != styler.LevelAt(lineCurrent))
502  				styler.SetLevel(lineCurrent, lev);
503  			lineCurrent++;
504  			levelCurrent = levelNext;
505        bArg1 = true; 
506        nWordStart = -1;
507      }
508    }
509  	int levelUse = levelCurrent;
510  	int lev = levelUse | levelNext &lt;&lt; 16;
511  	if (levelUse &lt; levelNext)
512  		lev |= SC_FOLDLEVELHEADERFLAG;
513  	if (lev != styler.LevelAt(lineCurrent))
514  		styler.SetLevel(lineCurrent, lev);
515  }
516  static const char * const nsisWordLists[] = {
517  	&quot;Functions&quot;,
518  	&quot;Variables&quot;,
519  	&quot;Lables&quot;,
520  	&quot;UserDefined&quot;,
521  	0, };
522  LexerModule lmNsis(SCLEX_NSIS, ColouriseNsisDoc, &quot;nsis&quot;, FoldNsisDoc, nsisWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</div>
                </div>
                <div class="column column_space"><pre><code>90      bIgnoreCase = true;
91    char s[20]; 
92    s[0] = &#x27;\0&#x27;;
93    for (Sci_PositionU i = 0; i &lt; end - start + 1 &amp;&amp; i &lt; 19; i++)
</pre></code></div>
                <div class="column column_space"><pre><code>123      bUserVars = true;
124  	char s[100];
125  	s[0] = &#x27;\0&#x27;;
126  	s[1] = &#x27;\0&#x27;;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    