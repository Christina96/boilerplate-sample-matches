
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.709047900650503%, Tokens: 12</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fa.cpp</h3>
            <pre><code>1  #include "fa.h"
2  PFaTrans TFaTrans::LoadCustomXml(const PXmlTok& XmlTok){
3    IAssert(XmlTok->IsTag("Trans"));
4    TStr MsgNm=XmlTok->GetArgVal("Msg");
5    TStr DstStateNm=XmlTok->GetArgVal("DstState");
6    TStr ScriptStr;
7    if (XmlTok->IsSubTag("Script")){
8      ScriptStr=XmlTok->GetTagTok("Script")->GetTokStr(false);}
9    PFaTrans Trans=TFaTrans::New(MsgNm, DstStateNm, ScriptStr);
10    return Trans;
11  }
12  void TFaTrans::_ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
13    if (SrcStateNm==OldStateNm){SrcStateNm=NewStateNm;}
14    if (DstStateNm==OldStateNm){DstStateNm=NewStateNm;}
15  }
16  PFaState TFaState::LoadCustomXml(const PXmlTok& XmlTok){
17    IAssert(XmlTok->IsTag("State"));
18    TStr Nm=XmlTok->GetArgVal("Nm");
19    TStr ScriptStr;
20    if (XmlTok->IsSubTag("Script")){
21      ScriptStr=XmlTok->GetTagTok("Script")->GetTokStr(false);}
22    TXmlTokV TransTokV; XmlTok->GetTagTokV("Trans", TransTokV);
23    TFaTransV TransV;
24    for (int TransN=0; TransN<TransTokV.Len(); TransN++){
25      PFaTrans Trans=TFaTrans::LoadCustomXml(TransTokV[TransN]);
26      TransV.Add(Trans);
27    }
28    PFaState State=TFaState::New(Nm, ScriptStr);
29    for (int TransN=0; TransN<TransV.Len(); TransN++){
30      State->AddTrans(TransV[TransN]);}
31    return State;
32  }
33  void TFaState::_ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
34    if (Nm==OldStateNm){Nm=NewStateNm;}
35    for (int TransN=0; TransN<FaTransV.Len(); TransN++){
36      FaTransV[TransN]->_ChangeStateNm(OldStateNm, NewStateNm);}
37  }
38  bool TFaState::IsTransTo(const TStr& StateNm) const {
39    for (int TransN=0; TransN<FaTransV.Len(); TransN++){
40      if (FaTransV[TransN]->GetDstStateNm()==StateNm){return true;}
41    }
42    return false;
43  }
44  void TFaState::DelTrans(const PFaTrans& Trans){
45    for (int TransN=FaTransV.Len()-1; TransN>=0; TransN--){
46      if (FaTransV[TransN]()==Trans()){
47        FaTransV.Del(TransN);}
48    }
49  }
50  void TFaState::DelTransIfDstState(const TStr& DstStateNm){
51    for (int TransN=FaTransV.Len()-1; TransN>=0; TransN--){
52      if (FaTransV[TransN]->GetDstStateNm()==DstStateNm){
53        FaTransV.Del(TransN);}
54    }
55  }
56  TStr TFaDef::GetNewStateNm() const {
57    int StateN=0;
58    while (IsState(TInt::GetStr(StateN, "State%d"))){StateN++;}
59    return TInt::GetStr(StateN, "State%d");
60  }
61  void TFaDef::ChangeStateNm(const TStr& OldStateNm, const TStr& NewStateNm){
62    if (OldStateNm==NewStateNm){return;}
63    PFaState State=GetState(OldStateNm);
64    IAssert(!IsState(NewStateNm));
65    IAssert(State()!=GetStartState()());
66    IAssert(State()!=GetEndState()());
67    TFaStateV StateV; GetStateV(StateV);
68    for (int StateN=0; StateN<StateV.Len(); StateN++){
69      StateV[StateN]->_ChangeStateNm(OldStateNm, NewStateNm);}
70    for (int TransN=0; TransN<GlobalTransV.Len(); TransN++){
71      GlobalTransV[TransN]->_ChangeStateNm(OldStateNm, NewStateNm);}
72    NmToFaStateH.DelKey(OldStateNm);
73    NmToFaStateH.AddDat(State->GetNm(), State);
74  }
75  void TFaDef::DelState(const TStr& StateNm){
76    IAssert(StateNm!=GetStartState()->GetNm());
77    IAssert(StateNm!=GetEndState()->GetNm());
78    PFaState State=GetState(StateNm);
79    TFaStateV StateV; GetStateV(StateV);
80    for (int StateN=0; StateN<StateV.Len(); StateN++){
81      StateV[StateN]->DelTransIfDstState(StateNm);}
82    for (int TransN=GlobalTransV.Len()-1; TransN>=0; TransN--){
83      PFaTrans Trans=GlobalTransV[TransN];
84      if ((Trans->GetSrcStateNm()==StateNm)||(Trans->GetDstStateNm()==StateNm)){
85        GlobalTransV.Del(TransN);}
86    }
87    NmToFaStateH.DelKey(StateNm);
88  }
89  TStr TFaDef::GetStateNmAtXY(const double& X, const double& Y) const {
90    TFaStateV StateV; GetStateV(StateV);
91    for (int StateN=StateV.Len()-1; StateN>=0; StateN--){
92      if (StateV[StateN]->GetRect().IsXYIn(X, Y)){
93        return StateV[StateN]->GetNm();}
94    }
95    return "";
96  }
97  void TFaDef::DelTrans(const PFaTrans& Trans){
98    TFaStateV StateV; GetStateV(StateV);
99    for (int StateN=0; StateN<StateV.Len(); StateN++){
100      StateV[StateN]->DelTrans(Trans);}
101    for (int TransN=GlobalTransV.Len()-1; TransN>=0; TransN--){
102      if (GlobalTransV[TransN]()==Trans()){
103        GlobalTransV.Del(TransN);}
104    }
105  }
106  PFaTrans TFaDef::GetTransAtXY(const double& X, const double& Y) const {
107    TFaStateV StateV; GetStateV(StateV);
108    for (int StateN=0; StateN<StateV.Len(); StateN++){
109      PFaState SrcFaState=StateV[StateN];
110      for (int TransN=0; TransN<SrcFaState->GetTranss(); TransN++){
111        PFaTrans FaTrans=SrcFaState->GetTrans(TransN);
112        if (FaTrans->GetRect().IsXYIn(X, Y)){return FaTrans;}
113      }
114    }
115    return NULL;
116  }
117  const TStr TFaDef::FaDefVerStr="Automaton Definition / 09.03.2004";
118  const TStr TFaDef::DfFNm="Automaton.Xml";
119  const TStr TFaDef::FExt=".Xml";
120  PFaDef TFaDef::LoadBin(const TStr& FNm){
121    PSIn SIn=TFIn::New(FNm);
122    char* VerCStr;
123    SIn->Load(VerCStr, FaDefVerStr.Len(), FaDefVerStr.Len());
124    if (FaDefVerStr!=VerCStr){
125      TExcept::Throw("Invalid version of Faulation Definition file.");}
126    return TFaDef::Load(*SIn);
127  }
128  void TFaDef::SaveBin(const TStr& FNm) const {
129    PSOut SOut=TFOut::New(FNm);
130    SOut->Save(FaDefVerStr.CStr(), FaDefVerStr.Len());
131    Save(*SOut);
132  }
133  PFaDef TFaDef::LoadXml(const TStr& FNm){
134    PFaDef FaDef=TFaDef::New();
135    XLoadFromFile(FNm, "FaDef", *FaDef);
136    return FaDef;
137  }
138  void TFaDef::SaveXml(const TStr& FNm){
139    PSOut SOut=TFOut::New(FNm);
140    SaveXml(*SOut, "FaDef");
141  }
142  PFaDef TFaDef::LoadCustomXml(const TStr& FNm){
143    PFaDef FaDef=TFaDef::New();
144    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(FNm);
145    TXmlTokV GlobalTransTokV;
146    XmlDoc->GetTagTokV("FinAut|Trans", GlobalTransTokV);
<span onclick='openModal()' class='match'>147    for (int TransN=0; TransN<GlobalTransTokV.Len(); TransN++){
148      PFaTrans Trans=TFaTrans::LoadCustomXml(GlobalTransTokV[TransN]);
149      FaDef->AddGlobalTrans(Trans);
150    }
151    TXmlTokV StateTokV; XmlDoc->GetTagTokV("FinAut|State", StateTokV);
152    for (int StateN=0; StateN<StateTokV.Len(); StateN++){
</span>153      PFaState State=TFaState::LoadCustomXml(StateTokV[StateN]);
154      FaDef->AddState(State);
155    }
156    TStr StartStateNm=XmlDoc->GetTagVal("StartState", false);
157    FaDef->PutStartState(FaDef->GetState(StartStateNm));
158    TStr EndStateNm=XmlDoc->GetTagVal("EndState", false);
159    FaDef->PutEndState(FaDef->GetState(EndStateNm));
160    return FaDef;
161  }
162  void TFaExpEnv::PutVarVal(const TStr& VarNm, const PExpVal& ExpVal){
163    VarNmToValH.AddDat(VarNm.GetUc(), ExpVal);
164  }
165  PExpVal TFaExpEnv::GetVarVal(const TStr& VarNm, bool& IsVar){
166    int VarNmToValP;
167    if (VarNmToValH.IsKey(VarNm.GetUc(), VarNmToValP)){
168      IsVar=true; return VarNmToValH[VarNmToValP];
169    } else {
170      printf("Variable '%s' does not exist\n", VarNm.CStr());
171      IsVar=false; return TExpVal::GetUndefExpVal();
172    }
173  }
174  PExpVal TFaExpEnv::GetFuncVal(
175   const TStr& FuncNm, const TExpValV& ArgValV, bool& IsFunc){
176    IsFunc=true; PExpVal ExpVal=TExpVal::GetUndefExpVal();
177    if (TExpEnv::IsFuncOk("Assign", efatStrAny, FuncNm, ArgValV)){
178      TStr VarNm=ArgValV[0]->GetStrVal();
179      PutVarVal(VarNm, ArgValV[1]);
180    } else
181    if (TExpEnv::IsFuncOk("OnProb", efatFlt, FuncNm, ArgValV)){
182      double RqPrb=ArgValV[0]->GetFltVal();
183      double Prb=GetVarVal("_Prb")->GetFltVal();
184      double PrbUsed=GetVarVal("_PrbUsed")->GetFltVal();
185      bool Ok=(PrbUsed<=Prb)&&(Prb<PrbUsed+RqPrb);
186      PutVarVal("_PrbUsed", TExpVal::New(PrbUsed+RqPrb));
187      ExpVal=TExpVal::New(double(Ok)); IsFunc=true;
188    } else
189    if (TExpEnv::IsFuncOk("AfterTime", efatFlt, FuncNm, ArgValV)){
190      double MxSecs=ArgValV[0]->GetFltVal();
191      TSecTm StartStateTm=FaExe->GetActStateStartTm();
192      bool Ok=TSecTm::GetDSecs(StartStateTm, TSecTm::GetCurTm())>MxSecs;
193      ExpVal=TExpVal::New(double(Ok)); IsFunc=true;
194    } else
195    if (TExpEnv::IsFuncOk("SendMsg", efatStr, FuncNm, ArgValV)){
196      TStr MsgNm=ArgValV[0]->GetStrVal();
197      PFaMsg Msg=TFaMsg::New(MsgNm);
198      FaExe->PushMsg(Msg);
199    } else
200    if (TExpEnv::IsFuncOk("SaveMsgArg", efatStrFlt, FuncNm, ArgValV)){
201      TStr VarNm=ArgValV[0]->GetStrVal();
202      int ArgN=ArgValV[1]->GetFltValAsInt()-1;
203      PFaMsg Msg=FaExe->GetLastMsg();
204      if ((!Msg.Empty())&&(0<=ArgN)&&(ArgN<Msg->GetArgs())){
205        TStr MsgArgValStr=Msg->GetArgVal(ArgN);
206        PExpVal ExpVal=TExpVal::New(MsgArgValStr);
207        PutVarVal(VarNm, ExpVal);
208        printf("Assign '%s'='%s'\n", VarNm.CStr(), MsgArgValStr.CStr());
209      }
210    } else
211    if (TExpEnv::IsFuncOk("SaveMsgArg", efatStr, FuncNm, ArgValV)){
212      TStr VarNm=ArgValV[0]->GetStrVal();
213      int ArgN=0;
214      PFaMsg Msg=FaExe->GetLastMsg();
215      if ((!Msg.Empty())&&(0<=ArgN)&&(ArgN<Msg->GetArgs())){
216        TStr MsgArgValStr=Msg->GetArgVal(ArgN);
217        PExpVal ExpVal=TExpVal::New(MsgArgValStr);
218        PutVarVal(VarNm, ExpVal);
219        printf("Assign '%s'='%s'\n", VarNm.CStr(), MsgArgValStr.CStr());
220      }
221    } else
222    if (TExpEnv::IsFuncOk("PlayIntro", efatStr, FuncNm, ArgValV)){
223      TStr CallNumStr=ArgValV[0]->GetStrVal();
224      printf(".....Playing Intro for '%s'.....\n", CallNumStr.CStr());
225    } else
226    if (TExpEnv::IsFuncOk("PlayCm", efatStrStr, FuncNm, ArgValV)){
227      TStr CallNumStr=ArgValV[0]->GetStrVal();
228      TStr CmNm=ArgValV[1]->GetStrVal();
229      printf(".....Playing Command '%s' for '%s'.....\n",
230       CmNm.CStr(), CallNumStr.CStr());
231    } else {
232      printf("Bad env. function call %s/%d\n", FuncNm.CStr(), ArgValV.Len());
233      IsFunc=false;
234    }
235    return ExpVal;
236  }
237  PExpVal TFaExe::EvalExpStr(const TStr& ExpStr){
238    bool Ok; TStr MsgStr; bool DbgP; TStr DbgStr; PExpVal ExpVal;
239    PExp Exp=TExp::LoadTxt(ExpStr, Ok, MsgStr);
240    if (Ok){
241      ExpVal=Exp->Eval(Ok, MsgStr, DbgP, DbgStr, ExpEnv);
242      if (!Ok){Notify->OnNotify(ntErr, MsgStr);}
243    } else {
244      Notify->OnNotify(ntErr, MsgStr);
245      ExpVal=TExpVal::GetUndefExpVal();
246    }
247    return ExpVal;
248  }
249  TFaExe::TFaExe(const PFaDef& _FaDef, const PNotify& _Notify):
250    FaDef(_FaDef), Notify(_Notify),
251    ActState(FaDef->GetStartState()), ActTrans(),
252    ActStateStartTm(TSecTm::GetCurTm()), MsgQ(),
253    ExpEnv(TFaExpEnv::New(this)),
254    LastMsg(){
255    Notify->OnNotify(ntInfo, TStr("Starting at state: ")+ActState->GetNm());
256    if (!ActState->GetScriptStr().Empty()){
257      EvalExpStr(ActState->GetScriptStr());
258    }
259  }
260  TFaExe::~TFaExe(){
261    Notify->OnNotify(ntInfo, TStr("Terminating at state: ")+ActState->GetNm());
262  }
263  void TFaExe::ExeStep(){
264    double Prb=ExpEnv->GetRnd().GetUniDev();
265    ExpEnv->PutVarVal("_Prb", TExpVal::New(Prb));
266    ExpEnv->PutVarVal("_PrbUsed", TExpVal::New(0));
267    TFaTransV EmptyTransV; TFaTransV CondTransV;
268    for (int TransN=0; TransN<ActState->GetTranss(); TransN++){
269      PFaTrans Trans=ActState->GetTrans(TransN);
270      if (Trans->GetCondStr().GetTrunc().Empty()){EmptyTransV.Add(Trans);}
271      else {CondTransV.Add(Trans);}
272    }
273    PFaState NewActState; ActTrans=NULL;
274    for (int CondTransN=0; CondTransN<CondTransV.Len(); CondTransN++){
275      PFaTrans CondTrans=CondTransV[CondTransN];
276      PExpVal ExpVal=EvalExpStr(CondTrans->GetCondStr());
277      if (ExpVal->GetFltVal()!=0){
278        ActTrans=CondTrans;
279        TStr NewActStateNm=CondTransV[CondTransN]->GetDstStateNm();
280        if (FaDef->IsState(NewActStateNm)){
281          NewActState=FaDef->GetState(NewActStateNm);
282        } else {
283          Notify->OnNotify(ntErr, TStr("Invalid state name (")+NewActStateNm+")");
284        }
285        break;
286      }
287    }
288    if (NewActState.Empty()){
289      if (EmptyTransV.Len()>0){
290        ActTrans=EmptyTransV[0];
291        TStr NewActStateNm=ActTrans->GetDstStateNm();
292        if (FaDef->IsState(NewActStateNm)){
293          NewActState=FaDef->GetState(NewActStateNm);
294        } else {
295          Notify->OnNotify(ntErr, TStr("Invalid state name (")+NewActStateNm+")");
296        }
297      }
298    }
299    TStr OldStateNm=ActState->GetNm();
300    if (!NewActState.Empty()){
301      ActState=NewActState; ActStateStartTm=TSecTm::GetCurTm();
302      if (!ActState->GetScriptStr().Empty()){
303        EvalExpStr(ActState->GetScriptStr());
304      }
305      TStr NewStateNm=ActState->GetNm();
306      Notify->OnNotify(ntInfo, TStr("Transition: ")+OldStateNm+" -> "+NewStateNm);
307    }
308  }
309  void TFaExe::SendMsg(const PFaMsg& Msg){
310    if (!Msg.Empty()){
311      MsgQ.Push(Msg);}
312    while ((ActState()!=FaDef->GetEndState()())&&(!MsgQ.Empty())){
313      if (!MsgQ.Empty()){
314        LastMsg=MsgQ.Top(); MsgQ.Pop();
315        printf("Msg: '%s'\n", LastMsg->GetNm()());
316        PFaTrans Trans;/&bsol;**=FaDef->GetTrans(State, LastMsg);
317        if (!Trans.Empty()){
318          if (!Trans->GetScriptStr().Empty()){
319            bool Ok; TStr MsgStr;
320            TExp::LoadAndEvalExpL(Trans->GetScriptStr(), Ok, MsgStr, ExpEnv);
321          }
322          ActState=FaDef->GetState(Trans->GetDstStateNm());
323          if (!ActState->GetScriptStr().Empty()){
324            bool Ok; TStr MsgStr;
325            TExp::LoadAndEvalExpL(ActState->GetScriptStr(), Ok, MsgStr, ExpEnv);
326          }
327        } else {
328          printf("No transition for Msg: '%s'\n", LastMsg->GetNm()());
329        }
330      }
331      printf("State: '%s'\n", ActState->GetNm().CStr());
332    }
333  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmattr.h"
3  #include "Snap.h"
4  #include "agm.h"
5  void TCesna::RandomInit(const int InitComs) {
6    F.Gen(G->GetNodes());
7    SumFV.Gen(InitComs);
8    NumComs = InitComs;
9    for (int u = 0; u < F.Len(); u++) {
10      int Mem = G->GetNI(u).GetDeg();
11      if (Mem > 10) { Mem = 10; }
12      for (int c = 0; c < Mem; c++) {
13        int CID = Rnd.GetUniDevInt(InitComs);
14        AddCom(u, CID, Rnd.GetUniDev());
15      }
16    }
17    for (int c = 0; c < SumFV.Len(); c++) {
18      if (SumFV[c] == 0.0) {
19        int UID = Rnd.GetUniDevInt(G->GetNodes());
20        AddCom(UID, c, Rnd.GetUniDev());
21      }
22    }
23    InitW();
24  }
25  void TCesna::NeighborComInit(const int InitComs) {
26    TFltIntPrV NIdPhiV(F.Len(), 0);
27    TCesnaUtil::GetNIdPhiV<PUNGraph>(G, NIdPhiV);
28    NeighborComInit(NIdPhiV, InitComs);
29  }
30  void TCesna::NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs) {
31    NIdPhiV.Sort(true);
32    F.Gen(G->GetNodes());
33    SumFV.Gen(InitComs);
34    NumComs = InitComs;
35    TIntSet InvalidNIDS(F.Len());
36    TIntV ChosenNIDV(InitComs, 0); 
37    int CurCID = 0;
38    for (int ui = 0; ui < NIdPhiV.Len(); ui++) {
39      int UID = NIdPhiV[ui].Val2;
40      fflush(stdout);
41      if (InvalidNIDS.IsKey(UID)) { continue; }
42      ChosenNIDV.Add(UID); 
43      AddCom(UID, CurCID, 1.0);
44      TUNGraph::TNodeI NI = G->GetNI(UID);
45      fflush(stdout);
46      for (int e = 0; e < NI.GetDeg(); e++) {
47        AddCom(NI.GetNbrNId(e), CurCID, 1.0);
48      }
49      for (int e = 0; e < NI.GetDeg(); e++) {
50        InvalidNIDS.AddKey(NI.GetNbrNId(e));
51      }
52      CurCID++;
53      fflush(stdout);
54      if (CurCID >= NumComs) { break;  }
55    }
56    if (NumComs > CurCID) {
57      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
58    }
59    for (int c = 0; c < SumFV.Len(); c++) {
60      if (SumFV[c] == 0.0) {
61        int ComSz = 10;
62        for (int u = 0; u < ComSz; u++) {
63          int UID = Rnd.GetUniDevInt(G->GetNodes());
64          AddCom(UID, c, Rnd.GetUniDev());
65        }
66      }
67    }
68    InitW();
69  }
70  void TCesna::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
71    F.Gen(G->GetNodes());
72    SumFV.Gen(CmtyVV.Len());
73    NumComs = CmtyVV.Len();
74    InitW();
75    for (int c = 0; c < CmtyVV.Len(); c++) {
76      for (int u = 0; u < CmtyVV[c].Len(); u++) {
77        int UID = CmtyVV[c][u];
78        if (! NIDToIdx.IsKey(UID)) { continue; }
79        AddCom(NIDToIdx.GetKeyId(UID), c, 1.0);
80      }
81    }
82  }
83  void TCesna::SetGraph(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH) {
84    HOVIDSV.Gen(GraphPt->GetNodes());  
85    HOKIDSV.Gen(GraphPt->GetNodes());  
86    X.Gen(GraphPt->GetNodes());
87    TIntV NIDV;
88    GraphPt->GetNIdV(NIDV);
89    NIDToIdx.Gen(NIDV.Len());
90    NIDToIdx.AddKeyV(NIDV);
91    printf("rearrage nodes\n");
92    G = TSnap::GetSubGraph(GraphPt, NIDV, true);
93    for (int nid = 0; nid < G->GetNodes(); nid++) {
94      IAssert(G->IsNode(nid)); 
95    }
96    TSnap::DelSelfEdges(G);
97    PNoCom = 1.0 / (double) G->GetNodes();
98    DoParallel = false;
99    if (1.0 / PNoCom > sqrt(TFlt::Mx)) { PNoCom = 0.99 / sqrt(TFlt::Mx); } 
100    NegWgt = 1.0;
101    int NumAttr = 0;
102    for (int u = 0; u < NIDAttrH.Len(); u++) {
103      int UID = NIDAttrH.GetKey(u);
104      if (! NIDToIdx.IsKey(UID)) { continue; }
105      X[NIDToIdx.GetKeyId(UID)].Gen(NIDAttrH[u].Len());
106      for (int k = 0; k < NIDAttrH[u].Len(); k++) {
107        int KID = NIDAttrH[u][k];
108        IAssert (KID >= 0);
109        X[NIDToIdx.GetKeyId(UID)].AddKey(KID);
110        if (NumAttr < KID + 1) { NumAttr = KID + 1; } 
111      }
112    }
113    Attrs = NumAttr;
114    InitW();
115  }
116  double TCesna::Likelihood(const bool _DoParallel) { 
117    TExeTm ExeTm;
118    double L = 0.0;
119    if (_DoParallel) {
120    #pragma omp parallel for 
121      for (int u = 0; u < F.Len(); u++) {
122        double LU = LikelihoodForRow(u);
123        #pragma omp atomic
124          L += LU;
125      }
126    }
127    else {
128      for (int u = 0; u < F.Len(); u++) {
129        double LU = LikelihoodForRow(u);
130          L += LU;
131      }
132    }
133    return L;
134  }
135  double TCesna::LikelihoodForRow(const int UID) {
136    return LikelihoodForRow(UID, F[UID]);
137  }
138  double TCesna::LikelihoodForRow(const int UID, const TIntFltH& FU) {
139    double L = 0.0;
140    TFltV HOSumFV; 
141    if (HOVIDSV[UID].Len() > 0) {
142      HOSumFV.Gen(SumFV.Len());
143      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
144        for (int c = 0; c < SumFV.Len(); c++) {
145          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
146        }
147      }
148    }
149    TUNGraph::TNodeI NI = G->GetNI(UID);
150    for (int e = 0; e < NI.GetDeg(); e++) {
151      int v = NI.GetNbrNId(e);
152      if (v == UID) { continue; }
153      if (HOVIDSV[UID].IsKey(v)) { continue; }
154      L += log (1.0 - Prediction(FU, F[v])) + NegWgt * DotProduct(FU, F[v]);
155    }
156    for (TIntFltH::TIter HI = FU.BegI(); HI < FU.EndI(); HI++) {
157      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[HI.GetKey()].Val: 0.0;
158      L -= NegWgt * (SumFV[HI.GetKey()] - HOSum - GetCom(UID, HI.GetKey())) * HI.GetDat();
159    }
160    if (RegCoef > 0.0) { 
161      L -= RegCoef * Sum(FU);
162    }
163    if (RegCoef < 0.0) { 
164      L += RegCoef * Norm2(FU);
165    }
166    L *= (1.0 - WeightAttr);
167    for (int k = 0; k < Attrs; k++) {
168      if (HOKIDSV[UID].IsKey(k)) { continue; }
169      L += WeightAttr * LikelihoodAttrKForRow(UID, k, FU);
170    }
171    return L;
172  }
173  double TCesna::LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU, const TFltV& WK) {
174    double Prob = PredictAttrK(FU, WK);
175    double L = 0.0;
176    if (GetAttr(UID, K)) { 
177      L = Prob == 0.0? -100.0: log(Prob);
178    } else {
179      L = Prob == 1.0? -100.0: log(1.0 - Prob);
180    }
181    return L;
182  }
183  void TCesna::GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet) {
184    GradU.Gen(CIDSet.Len());
185    TFltV HOSumFV; 
186    if (HOVIDSV[UID].Len() > 0) {
187      HOSumFV.Gen(SumFV.Len());
188      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
189        for (int c = 0; c < SumFV.Len(); c++) {
190          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
191        }
192      }
193    }
194    TUNGraph::TNodeI NI = G->GetNI(UID);
195    int Deg = NI.GetDeg();
196    TFltV PredV(Deg), GradV(CIDSet.Len());
197    TIntV CIDV(CIDSet.Len());
198    for (int e = 0; e < Deg; e++) {
199      if (NI.GetNbrNId(e) == UID) { continue; }
200      if (HOVIDSV[UID].IsKey(NI.GetNbrNId(e))) { continue; }
201      PredV[e] = Prediction(UID, NI.GetNbrNId(e));
202    }
203    for (int c = 0; c < CIDSet.Len(); c++) {
204      int CID = CIDSet.GetKey(c);
205      double Val = 0.0;
206      for (int e = 0; e < Deg; e++) {
207        int VID = NI.GetNbrNId(e);
208        if (VID == UID) { continue; }
209        if (HOVIDSV[UID].IsKey(VID)) { continue; }
210        Val += PredV[e] * GetCom(VID, CID) / (1.0 - PredV[e]) + NegWgt * GetCom(VID, CID);
211      }
212      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[CID].Val: 0.0;
213      Val -= NegWgt * (SumFV[CID] - HOSum - GetCom(UID, CID));
214      CIDV[c] = CID;
215      GradV[c] = Val;
216    }
217    if (RegCoef > 0.0) { 
218      for (int c = 0; c < GradV.Len(); c++) {
219        GradV[c] -= RegCoef; 
220      }
221    }
222    if (RegCoef < 0.0) { 
223      for (int c = 0; c < GradV.Len(); c++) {
224        GradV[c] += 2 * RegCoef * GetCom(UID, CIDV[c]); 
225      }
226    }
<span onclick='openModal()' class='match'>227    for (int c = 0; c < GradV.Len(); c++) {
228      GradV[c] *= (1.0 - WeightAttr);
229    }
230    TFltV AttrPredV(Attrs);
231    for (int k = 0; k < Attrs; k++) {
</span>232      if (HOKIDSV[UID].IsKey(k)) { continue; }
233      AttrPredV[k] = PredictAttrK(F[UID], W[k]);
234    }
235    for (int c = 0; c < GradV.Len(); c++) {
236      for (int k = 0; k < Attrs; k++) {
237        if (HOKIDSV[UID].IsKey(k)) { continue; }
238        GradV[c] += WeightAttr * (GetAttr(UID, k) - AttrPredV[k]) * GetW(CIDV[c], k);
239      }
240    }
241    for (int c = 0; c < GradV.Len(); c++) {
242      if (GetCom(UID, CIDV[c]) == 0.0 && GradV[c] < 0.0) { continue; }
243      if (fabs(GradV[c]) < 0.0001) { continue; }
244      GradU.AddDat(CIDV[c], GradV[c]);
245    }
246    for (int c = 0; c < GradU.Len(); c++) {
247      if (GradU[c] >= 10) { GradU[c] = 10; }
248      if (GradU[c] <= -10) { GradU[c] = -10; }
249      IAssert(GradU[c] >= -10);
250    }
251  }
252  void TCesna::GetCmtyVV(TVec<TIntV>& CmtyVV) {
253    TVec<TFltV> TmpV;
254    GetCmtyVV(CmtyVV, TmpV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
255  }
256  void TCesna::GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck, const double Thres, const int MinSz) {
257    CmtyVV.Gen(NumComs, 0);
258    Wck.Gen(NumComs, 0);
259    TIntFltH CIDSumFH(NumComs);
260    for (int c = 0; c < SumFV.Len(); c++) {
261      CIDSumFH.AddDat(c, SumFV[c]);
262    }
263    CIDSumFH.SortByDat(false);
264    for (int c = 0; c < NumComs; c++) {
265      int CID = CIDSumFH.GetKey(c);
266      TIntFltH NIDFucH(F.Len() / 10);
267      TIntV CmtyV;
268      IAssert(SumFV[CID] == CIDSumFH.GetDat(CID));
269      if (SumFV[CID] < Thres) { continue; }
270      for (int u = 0; u < F.Len(); u++) {
271        int NID = NIDToIdx[u];
272        if (GetCom(u, CID) >= Thres) { NIDFucH.AddDat(NID, GetCom(u, CID)); }
273      }
274      NIDFucH.SortByDat(false);
275      NIDFucH.GetKeyV(CmtyV);
276      if (CmtyV.Len() < MinSz) { continue; }
277      CmtyVV.Add(CmtyV); 
278      TFltV WV(Attrs);
279      for (int k = 0; k < Attrs; k++) {
280        WV[k] = GetW(CID, k);
281      }
282      Wck.Add(WV);
283    }
284    if ( NumComs != CmtyVV.Len()) {
285      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
286    }
287  }
288  void TCesna::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV) {
289    GetCmtyVVUnSorted(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
290  }
291  void TCesna::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
292    CmtyVV.Gen(NumComs, 0);
293    for (int c = 0; c < NumComs; c++) {
294      TIntV CmtyV;
295      for (int u = 0; u < G->GetNodes(); u++) {
296        if (GetCom(u, c) > Thres) { CmtyV.Add(NIDToIdx[u]); }
297      }
298      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
299    }
300    if ( NumComs != CmtyVV.Len()) {
301      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
302    }
303  }
304  int TCesna::FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC, const double HOFrac, const double StepAlpha, const double StepBeta) {
305      double ComsGap = exp(TMath::Log((double) MaxComs / (double) MinComs) / (double) DivComs);
306      TIntV ComsV;
307      ComsV.Add(MinComs);
308      while (ComsV.Len() < DivComs) {
309        int NewComs = int(ComsV.Last() * ComsGap);
310        if (NewComs == ComsV.Last().Val) { NewComs++; }
311        ComsV.Add(NewComs);
312      }
313      if (ComsV.Last() < MaxComs) { ComsV.Add(MaxComs); }
314      return FindComs(ComsV, UseBIC, HOFrac, NumThreads, OutFNm, StepAlpha, StepBeta);
315  }
316  int TCesna::FindComs(TIntV& ComsV, const bool UseBIC, const double HOFrac, const int NumThreads, const TStr PlotLFNm, const double StepAlpha, const double StepBeta) {
317    if (ComsV.Len() == 0) {
318      int MaxComs = G->GetNodes() / 5;
319      ComsV.Add(2);
320      while(ComsV.Last() < MaxComs) { ComsV.Add(ComsV.Last() * 2); }
321    }
322    int MaxIterCV = 3;
323    TVec<TVec<TIntSet> > HoldOutSets(MaxIterCV), HoldOutSetsAttr(MaxIterCV);
324    TFltIntPrV NIdPhiV;
325    TCesnaUtil::GetNIdPhiV<PUNGraph>(G, NIdPhiV);
326    if (! UseBIC) { 
327      TIntV NIdV1, NIdV2;
328      G->GetNIdV(NIdV1);
329      G->GetNIdV(NIdV2);
330      for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
331        TCesnaUtil::GenHoldOutPairs(G, HoldOutSets[IterCV], HOFrac, Rnd);
332        GenHoldOutAttr(HOFrac, HoldOutSetsAttr[IterCV]);
333      }
334    }
335    TFltV HOLV(ComsV.Len());
336    TIntFltPrV ComsLV;
337    for (int c = 0; c < ComsV.Len(); c++) {
338      const int Coms = ComsV[c];
339      if (! UseBIC) { 
340        for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
341          HOVIDSV = HoldOutSets[IterCV];
342          HOKIDSV = HoldOutSetsAttr[IterCV];
343          NeighborComInit(NIdPhiV, Coms);
344          if (NumThreads == 1) {
345            MLEGradAscent(0.01, 100 * G->GetNodes(), "", StepAlpha, StepBeta);
346          } else {
347            MLEGradAscentParallel(0.01, 100, NumThreads, "", StepAlpha, StepBeta);
348          }
349          double HOL = LikelihoodHoldOut();
350          HOL = HOL < 0? HOL: TFlt::Mn;
351          HOLV[c] += HOL;
352        }
353      }
354      else {
355        HOVIDSV.Gen(G->GetNodes());
356        HOKIDSV.Gen(G->GetNodes());
357        if (NumThreads == 1) {
358          MLEGradAscent(0.005, 100 * G->GetNodes(), "", StepAlpha, StepBeta);
359          printf("likelihood: train:%f, attr:%f, hold:%f\n", Likelihood(), LikelihoodAttr(), LikelihoodHoldOut());
360        } else {
361          MLEGradAscentParallel(0.005, 100, NumThreads, "", StepAlpha, StepBeta);
362        }
363        double NumParams = (1.0 - WeightAttr) * Coms + WeightAttr * Coms * Attrs;
364        double Observations = (1.0 - WeightAttr) * G->GetNodes() * (G->GetNodes() - 1) / 2 + WeightAttr * G->GetNodes() * Attrs;
365        double BIC = 2 * Likelihood() - NumParams * log (Observations);
366        HOLV[c] = BIC;
367      }
368    }
369    int EstComs = 2;
370    double MaxL = TFlt::Mn;
371    if (UseBIC) {
372      printf("Number of communities vs likelihood (criterion: BIC)\n");
373    } else {
374      printf("Number of communities vs likelihood (criterion: Cross validation)\n");
375    }
376    for (int c = 0; c < ComsV.Len(); c++) {
377      ComsLV.Add(TIntFltPr(ComsV[c].Val, HOLV[c].Val));
378      printf("%d(%f)\t", ComsV[c].Val, HOLV[c].Val);
379      if (MaxL < HOLV[c]) {
380        MaxL = HOLV[c];
381        EstComs = ComsV[c];
382      }
383    }
384    printf("\n");
385    RandomInit(EstComs);
386    HOVIDSV.Gen(G->GetNodes());
387    HOKIDSV.Gen(G->GetNodes());
388    if (! PlotLFNm.Empty()) {
389      TGnuPlot::PlotValV(ComsLV, PlotLFNm, "hold-out likelihood", "communities", "likelihood");
390    }
391    return EstComs;
392  }
393  double TCesna::LikelihoodHoldOut() { 
394    double L = 0.0;
395    for (int u = 0; u < HOVIDSV.Len(); u++) {
396      for (int e = 0; e < HOVIDSV[u].Len(); e++) {
397        int VID = HOVIDSV[u][e];
398        if (VID == u) { continue; } 
399        double Pred = Prediction(u, VID);
400        if (G->IsEdge(u, VID)) {
401          L += log(1.0 - Pred);
402        }
403        else {
404          L += NegWgt * log(Pred);
405        }
406      } 
407    }
408    L *= (1.0 - WeightAttr);
409    for (int u = 0; u < HOKIDSV.Len(); u++) {
410      for (int e = 0; e < HOKIDSV[u].Len(); e++) {
411        IAssert(HOKIDSV[u][e] < Attrs);
412        L += WeightAttr * LikelihoodAttrKForRow(u, HOKIDSV[u][e]);
413      }
414    }
415    return L;
416  }
417  double TCesna::GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter) {
418    double StepSize = 1.0;
419    double InitLikelihood = LikelihoodForRow(UID);
420    TIntFltH NewVarV(DeltaV.Len());
421    for(int iter = 0; iter < MaxIter; iter++) {
422      for (int i = 0; i < DeltaV.Len(); i++){
423        int CID = DeltaV.GetKey(i);
424        double NewVal = GetCom(UID, CID) + StepSize * DeltaV.GetDat(CID);
425        if (NewVal < MinVal) { NewVal = MinVal; }
426        if (NewVal > MaxVal) { NewVal = MaxVal; }
427        NewVarV.AddDat(CID, NewVal);
428      }
429      if (LikelihoodForRow(UID, NewVarV) < InitLikelihood + Alpha * StepSize * DotProduct(GradV, DeltaV)) {
430        StepSize *= Beta;
431      } else {
432        break;
433      }
434      if (iter == MaxIter - 1) { 
435        StepSize = 0.0;
436        break;
437      }
438    }
439    return StepSize;
440  }
441  int TCesna::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
442    time_t InitTime = time(NULL);
443    TExeTm ExeTm, CheckTm;
444    int iter = 0, PrevIter = 0;
445    TIntFltPrV IterLV;
446    TUNGraph::TNodeI UI;
447    double PrevL = TFlt::Mn, CurL = 0.0;
448    TIntV NIdxV(F.Len(), 0);
449    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
450    TIntFltH GradV;
451    TIntSet CIDSet(NumComs);
452    for (int c = 0; c < NumComs; c++) { CIDSet.AddKey(c); }
453    while(iter < MaxIter) {
454      NIdxV.Shuffle(Rnd);
455      for (int ui = 0; ui < F.Len(); ui++, iter++) {
456        int u = NIdxV[ui]; 
457        GradientForRow(u, GradV, CIDSet);
458        if (Norm2(GradV) < 1e-4) { continue; }
459        double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
460        if (LearnRate == 0.0) { continue; }
461        for (int ci = 0; ci < GradV.Len(); ci++) {
462          int CID = GradV.GetKey(ci);
463          double Change = LearnRate * GradV.GetDat(CID);
464          double NewFuc = GetCom(u, CID) + Change;
465          if (NewFuc <= 0.0) {
466            DelCom(u, CID);
467          } else {
468            AddCom(u, CID, NewFuc);
469          }
470        }
471        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
472          IterLV.Add(TIntFltPr(iter, Likelihood(false)));
473        }
474      }
475      for (int k = 0; k < Attrs; k++) {
476        TFltV GradWV(NumComs);
477        GradientForWK(GradWV, k);
478        if (TLinAlg::Norm2(GradWV) < 1e-4) { continue; }
479        double LearnRate = GetStepSizeByLineSearchForWK(k, GradWV, GradWV, StepAlpha, StepBeta);
480        if (LearnRate == 0.0) { continue; }
481        for (int c = 0; c < GradWV.Len(); c++){
482          W[k][c] += LearnRate * GradWV[c];
483          if (W[k][c] < MinValW) { W[k][c] = MinValW; }
484          if (W[k][c] > MaxValW) { W[k][c] = MaxValW; }
485        }
486      }
487      printf("\r%d iterations (%f) [%lu sec]", iter, CurL, time(NULL) - InitTime);
488      fflush(stdout);
489      if (iter - PrevIter >= 2 * G->GetNodes() && iter > 10000) {
490        PrevIter = iter;
491        CurL = Likelihood();
492        if (PrevL > TFlt::Mn && ! PlotNm.Empty()) {
493          printf("\r%d iterations, Likelihood: %f, Diff: %f", iter, CurL,  CurL - PrevL);
494        }
495        fflush(stdout);
496        if (CurL - PrevL <= Thres * fabs(PrevL)) { break; }
497        else { PrevL = CurL; }
498      }
499    }
500    printf("\n");
501    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
502    if (! PlotNm.Empty()) {
503      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
504    }
505    return iter;
506  }
507  int TCesna::MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
508    time_t InitTime = time(NULL);
509    uint64 StartTm = TSecTm::GetCurTm().GetAbsSecs();
510    TExeTm ExeTm, CheckTm;
511    double PrevL = Likelihood(true);
512    TIntFltPrV IterLV;
513    int PrevIter = 0;
514    int iter = 0;
515    TIntV NIdxV(F.Len(), 0);
516    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
517    TIntV NIDOPTV(F.Len()); 
518    NIDOPTV.PutAll(0);
519    TVec<TIntFltH> NewF(ChunkNum * ChunkSize);
520    TIntV NewNIDV(ChunkNum * ChunkSize);
521    for (iter = 0; iter < MaxIter; iter++) {
522      NIdxV.Clr(false);
523      for (int i = 0; i < F.Len(); i++) { 
524        if (NIDOPTV[i] == 0) {  NIdxV.Add(i); }
525      }
526      IAssert (NIdxV.Len() <= F.Len());
527      NIdxV.Shuffle(Rnd);
528  #pragma omp parallel for schedule(static, 1)
529      for (int TIdx = 0; TIdx < ChunkNum; TIdx++) {
530        TIntFltH GradV;
531        for (int ui = TIdx * ChunkSize; ui < (TIdx + 1) * ChunkSize; ui++) {
532          NewNIDV[ui] = -1;
533          if (ui >= NIdxV.Len()) { continue; }
534          int u = NIdxV[ui]; 
535          TUNGraph::TNodeI UI = G->GetNI(u);
536          TIntSet CIDSet(5 * UI.GetDeg());
537          TIntFltH CurFU = F[u];
538          for (int e = 0; e < UI.GetDeg(); e++) {
539            if (HOVIDSV[u].IsKey(UI.GetNbrNId(e))) { continue; }
540            TIntFltH& NbhCIDH = F[UI.GetNbrNId(e)];
541            for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
542              CIDSet.AddKey(CI.GetKey());
543            }
544          }
545          if (CIDSet.Empty()) { 
546            CurFU.Clr();
547          }
548          else {
549            for (TIntFltH::TIter CI = CurFU.BegI(); CI < CurFU.EndI(); CI++) { 
550              if (! CIDSet.IsKey(CI.GetKey())) {
551                CurFU.DelIfKey(CI.GetKey());
552              }
553            }
554            GradientForRow(u, GradV, CIDSet);
555            if (Norm2(GradV) < 1e-4) { NIDOPTV[u] = 1; continue; }
556            double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
557            if (LearnRate == 0.0) { NewNIDV[ui] = -2; continue; }
558            for (int ci = 0; ci < GradV.Len(); ci++) {
559              int CID = GradV.GetKey(ci);
560              double Change = LearnRate * GradV.GetDat(CID);
561              double NewFuc = CurFU.IsKey(CID)? CurFU.GetDat(CID) + Change : Change;
562              if (NewFuc <= 0.0) {
563                CurFU.DelIfKey(CID);
564              } else {
565                CurFU.AddDat(CID) = NewFuc;
566              }
567            }
568            CurFU.Defrag();
569          }
570          NewF[ui] = CurFU;
571          NewNIDV[ui] = u;
572        }
573      }
574      int NumNoChangeGrad = 0;
575      int NumNoChangeStepSize = 0;
576      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
577        int NewNID = NewNIDV[ui];
578        if (NewNID == -1) { NumNoChangeGrad++; continue; }
579        if (NewNID == -2) { NumNoChangeStepSize++; continue; }
580        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
581          SumFV[CI.GetKey()] -= CI.GetDat();
582        }
583      }
584  #pragma omp parallel for
585      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
586        int NewNID = NewNIDV[ui];
587        if (NewNID < 0) { continue; }
588        F[NewNID] = NewF[ui];
589      }
590      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
591        int NewNID = NewNIDV[ui];
592        if (NewNID < 0) { continue; }
593        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
594          SumFV[CI.GetKey()] += CI.GetDat();
595        }
596      }
597      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
598        int NewNID = NewNIDV[ui];
599        if (NewNID < 0) { continue; }
600        TUNGraph::TNodeI UI = G->GetNI(NewNID);
601        NIDOPTV[NewNID] = 0;
602        for (int e = 0; e < UI.GetDeg(); e++) {
603          NIDOPTV[UI.GetNbrNId(e)] = 0;
604        }
605      }
606      int OPTCnt = 0;
607      for (int i = 0; i < NIDOPTV.Len(); i++) { if (NIDOPTV[i] == 1) { OPTCnt++; } }
608      if (! PlotNm.Empty()) {
609        printf("\r%d iterations [%s] %s secs", iter * ChunkSize * ChunkNum, ExeTm.GetTmStr(), TUInt64::GetStr(TSecTm::GetCurTm().GetAbsSecs()-StartTm).CStr());
610        if (PrevL > TFlt::Mn) { printf(" (%f) %d g %d s %d OPT", PrevL, NumNoChangeGrad, NumNoChangeStepSize, OPTCnt); }
611        fflush(stdout);
612      }
613      if (iter == 0 || (iter - PrevIter) * ChunkSize * ChunkNum >= G->GetNodes()) {
614    #pragma omp parallel for
615        for (int k = 0; k < Attrs; k++) {
616          TFltV GradWV(NumComs);
617          GradientForWK(GradWV, k);
618          if (TLinAlg::Norm2(GradWV) < 1e-4) { continue; }
619          double LearnRate = GetStepSizeByLineSearchForWK(k, GradWV, GradWV, StepAlpha, StepBeta);
620          if (LearnRate == 0.0) { continue; }
621          for (int c = 0; c < GradWV.Len(); c++){
622            W[k][c] += LearnRate * GradWV[c];
623            if (W[k][c] < MinValW) { W[k][c] = MinValW; }
624            if (W[k][c] > MaxValW) { W[k][c] = MaxValW; }
625          }
626        }
627        PrevIter = iter;
628        double CurL = Likelihood(true);
629        IterLV.Add(TIntFltPr(iter * ChunkSize * ChunkNum, CurL));
630        printf("\r%d iterations, Likelihood: %f, Diff: %f [%lu secs]", iter, CurL,  CurL - PrevL, time(NULL) - InitTime);
631         fflush(stdout);
632        if (CurL - PrevL <= Thres * fabs(PrevL)) { 
633          break;
634        }
635        else {
636          PrevL = CurL;
637        }
638      }
639    }
640    if (! PlotNm.Empty()) {
641      printf("\nMLE completed with %d iterations(%s secs)\n", iter, TUInt64::GetStr(TSecTm::GetCurTm().GetAbsSecs()-StartTm).CStr());
642      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
643    } else {
644      printf("\rMLE completed with %d iterations(%lu secs)", iter, time(NULL) - InitTime);
645      fflush(stdout);
646    }
647    return iter;
648  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fa.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.cpp</div>
                <div class="column column_space"><pre><code>147    for (int TransN=0; TransN<GlobalTransTokV.Len(); TransN++){
148      PFaTrans Trans=TFaTrans::LoadCustomXml(GlobalTransTokV[TransN]);
149      FaDef->AddGlobalTrans(Trans);
150    }
151    TXmlTokV StateTokV; XmlDoc->GetTagTokV("FinAut|State", StateTokV);
152    for (int StateN=0; StateN<StateTokV.Len(); StateN++){
</pre></code></div>
                <div class="column column_space"><pre><code>227    for (int c = 0; c < GradV.Len(); c++) {
228      GradV[c] *= (1.0 - WeightAttr);
229    }
230    TFltV AttrPredV(Attrs);
231    for (int k = 0; k < Attrs; k++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    