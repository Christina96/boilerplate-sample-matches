<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for layer1_25.py &amp; __init__.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for layer1_25.py &amp; __init__.py
      </h3>
<h1 align="center">
        10.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>layer1_25.py (16.796875%)<th>__init__.py (8.067542%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(567-575)<td><a href="#" name="0">(744-752)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(513-521)<td><a href="#" name="1">(676-684)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(429-459)<td><a href="#" name="2">(1600-1621)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(387-423)<td><a href="#" name="3">(1154-1179)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(348-381)<td><a href="#" name="4">(1029-1049)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(279-306)<td><a href="#" name="5">(112-133)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>layer1_25.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import time
from binascii import crc32
import boto
from boto.connection import AWSAuthConnection
from boto.exception import DynamoDBResponseError
from boto.provider import Provider
from boto.dynamodb import exceptions as dynamodb_exceptions
from boto.compat import json
class Layer1(AWSAuthConnection):
    DefaultRegionName = 'us-east-1'
    ServiceName = 'DynamoDB'
    Version = '20111205'
    ThruputError = "ProvisionedThroughputExceededException"
    SessionExpiredError = 'com.amazon.coral.service#ExpiredTokenException'
    ConditionalCheckFailedError = 'ConditionalCheckFailedException'
    ValidationError = 'ValidationException'
    ResponseError = DynamoDBResponseError
    NumberRetries = 10
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 debug=0, security_token=None, region=None,
                 validate_certs=True, validate_checksums=True, profile_name=None):
        if not region:
            region_name = boto.config.get('DynamoDB', 'region',
                                          self.DefaultRegionName)
            for reg in boto.dynamodb.regions():
                if reg.name == region_name:
                    region = reg
                    break
        self.region = region
        super(Layer1, self).__init__(self.region.endpoint,
                                   aws_access_key_id,
                                   aws_secret_access_key,
                                   is_secure, port, proxy, proxy_port,
                                   debug=debug, security_token=security_token,
                                   validate_certs=validate_certs,
                                   profile_name=profile_name)
        self.throughput_exceeded_events = 0
        self._validate_checksums = boto.config.getbool(
            'DynamoDB', 'validate_checksums', validate_checksums)
    def _get_session_token(self):
        self.provider = Provider(self._provider_type)
        self._auth_handler.update_provider(self.provider)
    def _required_auth_capability(self):
        return ['hmac-v4']
    def make_request(self, action, body='', object_hook=None):
        headers = {'X-Amz-Target': '%s_%s.%s' % (self.ServiceName,
                                                 self.Version, action),
                   'Host': self.region.endpoint,
                   'Content-Type': 'application/x-amz-json-1.0',
                   'Content-Length': str(len(body))}
        http_request = self.build_base_http_request('POST', '/', '/',
                                                    {}, headers, body, None)
        start = time.time()
        response = self._mexe(http_request, sender=None,
                              override_num_retries=self.NumberRetries,
                              retry_handler=self._retry_handler)
        elapsed = (time.time() - start) * 1000
        request_id = response.getheader('x-amzn-RequestId')
        boto.log.debug('RequestId: %s' % request_id)
        boto.perflog.debug('%s: id=%s time=%sms',
                           headers['X-Amz-Target'], request_id, int(elapsed))
        response_body = response.read().decode('utf-8')
        boto.log.debug(response_body)
        return json.loads(response_body, object_hook=object_hook)
    def _retry_handler(self, response, i, next_sleep):
        status = None
        if response.status == 400:
            response_body = response.read().decode('utf-8')
            boto.log.debug(response_body)
            data = json.loads(response_body)
            if self.ThruputError in data.get('__type'):
                self.throughput_exceeded_events += 1
                msg = "%s, retry attempt %s" % (self.ThruputError, i)
                next_sleep = self._exponential_time(i)
                i += 1
                status = (msg, i, next_sleep)
                if i == self.NumberRetries:
                    raise dynamodb_exceptions.DynamoDBThroughputExceededError(
                        response.status, response.reason, data)
            elif self.SessionExpiredError in data.get('__type'):
                msg = 'Renewing Session Token'
                self._get_session_token()
                status = (msg, i + self.num_retries - 1, 0)
            elif self.ConditionalCheckFailedError in data.get('__type'):
                raise dynamodb_exceptions.DynamoDBConditionalCheckFailedError(
                    response.status, response.reason, data)
            elif self.ValidationError in data.get('__type'):
                raise dynamodb_exceptions.DynamoDBValidationError(
                    response.status, response.reason, data)
            else:
                raise self.ResponseError(response.status, response.reason,
                                         data)
        expected_crc32 = response.getheader('x-amz-crc32')
        if self._validate_checksums and expected_crc32 is not None:
            boto.log.debug('Validating crc32 checksum for body: %s',
                           response.read().decode('utf-8'))
            actual_crc32 = crc32(response.read()) &amp; 0xffffffff
            expected_crc32 = int(expected_crc32)
            if actual_crc32 != expected_crc32:
                msg = ("The calculated checksum %s did not match the expected "
                       "checksum %s" % (actual_crc32, expected_crc32))
                status = (msg, i + 1, self._exponential_time(i))
        return status
    def _exponential_time(self, i):
        if i == 0:
            next_sleep = 0
        else:
            next_sleep = min(0.05 * (2 ** i),
                             boto.config.get('Boto', 'max_retry_delay', 60))
        return next_sleep
    def list_tables(self, limit=None, start_table=None):
        data = {}
        if limit:
            data['Limit'] = limit
        if start_table:
            data['ExclusiveStartTableName'] = start_table
        json_input = json.dumps(data)
        return self.make_request('ListTables', json_input)
    def describe_table(self, table_name):
        data = {'TableName': table_name}
        json_input = json.dumps(data)
        return self.make_request('DescribeTable', json_input)
    def create_table(self, table_name, schema, provisioned_throughput):
        data = {'TableName': table_name,
                'KeySchema': schema,
                'ProvisionedThroughput': provisioned_throughput}
        json_input = json.dumps(data)
        response_dict = self.make_request('CreateTable', json_input)
        return response_dict
    def update_table(self, table_name, provisioned_throughput):
        data = {'TableName': table_name,
                'ProvisionedThroughput': provisioned_throughput}
        json_input = json.dumps(data)
        return self.make_request('UpdateTable', json_input)
    def delete_table(self, table_name):
        data = {'TableName': table_name}
        json_input = json.dumps(data)
<a name="5"></a>        return self.make_request('DeleteTable', json_input)
    def get_item(self, table_name, key, attributes_to_get=None,
                 consistent_read<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=False, object_hook=None):
        data = {'TableName': table_name,
                'Key': key}
        if attributes_to_get:
            data['AttributesToGet'] = attributes_to_get
        if consistent_read:
            data['ConsistentRead'] =</b></font> True
        json_input = json.dumps(data)
        response = self.make_request('GetItem', json_input,
                                     object_hook=object_hook)
        if 'Item' not in response:
            raise dynamodb_exceptions.DynamoDBKeyNotFoundError(
                "Key does not exist."
            )
        return response
    def batch_get_item(self, request_items, object_hook=None):
        if not request_items:
            return {}
        data = {'RequestItems': request_items}
        json_input = json.dumps(data)
        return self.make_request('BatchGetItem', json_input,
                                 object_hook=object_hook)
    def batch_write_item(self, request_items, object_hook=None):
        data = {'RequestItems': request_items}
        json_input = json.dumps(data)
        return self.make_request('BatchWriteItem', json_input,
<a name="4"></a>                                 object_hook=object_hook)
    def put_item(self, table_name, item,
                 expected=None, return_values<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
                 object_hook=None):
        data = {'TableName': table_name,
                'Item': item}
        if expected:
            data['Expected'] = expected
        if return_values:
            data['ReturnValues'] =</b></font> return_values
        json_input = json.dumps(data)
        return self.make_request('PutItem', json_input,
<a name="3"></a>                                 object_hook=object_hook)
    def update_item(self, table_name, key, attribute_updates,
                    expected=None, return_values<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
                    object_hook=None):
        data = {'TableName': table_name,
                'Key': key,
                'AttributeUpdates': attribute_updates}
        if expected:
            data['Expected'] = expected
        if return_values:
            data['ReturnValues'] =</b></font> return_values
        json_input = json.dumps(data)
        return self.make_request('UpdateItem', json_input,
<a name="2"></a>                                 object_hook=object_hook)
    def delete_item(self, table_name, key,
                    expected=None, return_values<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
                    object_hook=None):
        data = {'TableName': table_name,
                'Key': key}
        if expected:
            data['Expected'] = expected
        if return_values:
            data['ReturnValues'] =</b></font> return_values
        json_input = json.dumps(data)
        return self.make_request('DeleteItem', json_input,
                                 object_hook=object_hook)
    def query(self, table_name, hash_key_value, range_key_conditions=None,
              attributes_to_get=None, limit=None, consistent_read=False,
              scan_index_forward=True, exclusive_start_key=None,
              object_hook=None, count=False):
<a name="1"></a>        data = {'TableName': table_name,
                'HashKeyValue': hash_key_value}
        if range_key_conditions:
            data<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>['RangeKeyCondition'] = range_key_conditions
        if attributes_to_get:
            data['AttributesToGet'] = attributes_to_get
        if limit:
            data['Limit'] = limit
        if count:
            data['Count'] = True
        if consistent_read:
            data['ConsistentRead'] =</b></font> True
        if scan_index_forward:
            data['ScanIndexForward'] = True
        else:
            data['ScanIndexForward'] = False
        if exclusive_start_key:
            data['ExclusiveStartKey'] = exclusive_start_key
        json_input = json.dumps(data)
        return self.make_request('Query', json_input,
                                 object_hook=object_hook)
    def scan(self, table_name, scan_filter=None,
             attributes_to_get=None, limit=None,
             exclusive_start_key=None, object_hook=None, count=False):
            data<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>['ScanFilter'] = scan_filter
        if attributes_to_get:
            data['AttributesToGet'] = attributes_to_get
        if limit:
            data['Limit'] = limit
        if count:
            data['Count'] = True
        if exclusive_start_key:
            data['ExclusiveStartKey'] =</b></font> exclusive_start_key
        json_input = json.dumps(data)
        return self.make_request('Scan', json_input, object_hook=object_hook)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init__.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
from boto.ec2.connection import EC2Connection
from boto.resultset import ResultSet
from boto.vpc.vpc import VPC
from boto.vpc.customergateway import CustomerGateway
from boto.vpc.networkacl import NetworkAcl
from boto.vpc.routetable import RouteTable
from boto.vpc.internetgateway import InternetGateway
from boto.vpc.vpngateway import VpnGateway, Attachment
from boto.vpc.dhcpoptions import DhcpOptions
from boto.vpc.subnet import Subnet
from boto.vpc.vpnconnection import VpnConnection
from boto.vpc.vpc_peering_connection import VpcPeeringConnection
from boto.ec2 import RegionData
from boto.regioninfo import RegionInfo, get_regions
from boto.regioninfo import connect
def regions(**kw_params):
    return get_regions('ec2', connection_cls=VPCConnection)
def connect_to_region(region_name, **kw_params):
    return connect('ec2', region_name, connection_cls=VPCConnection,
                   **kw_params)
class VPCConnection(EC2Connection):
    def get_all_vpcs(self, vpc_ids=None, filters=None, dry_run=False):
        params = {}
        if vpc_ids:
            self.build_list_params(params, vpc_ids, 'VpcId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
<a name="5"></a>            params['DryRun'] = 'true'
        return self.get_list('DescribeVpcs', params, [('item', VPC)])
    def create_vpc(self, cidr_block, instance_tenancy<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, dry_run=False):
        params = {'CidrBlock': cidr_block}
        if instance_tenancy:
            params['InstanceTenancy'] = instance_tenancy
        if dry_run:
            params['DryRun'] =</b></font> 'true'
        return self.get_object('CreateVpc', params, VPC)
    def delete_vpc(self, vpc_id, dry_run=False):
        params = {'VpcId': vpc_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteVpc', params)
    def modify_vpc_attribute(self, vpc_id,
                             enable_dns_support=None,
                             enable_dns_hostnames=None, dry_run=False):
        params = {'VpcId': vpc_id}
        if enable_dns_support is not None:
            if enable_dns_support:
                params['EnableDnsSupport.Value'] = 'true'
            else:
                params['EnableDnsSupport.Value'] = 'false'
        if enable_dns_hostnames is not None:
            if enable_dns_hostnames:
                params['EnableDnsHostnames.Value'] = 'true'
            else:
                params['EnableDnsHostnames.Value'] = 'false'
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('ModifyVpcAttribute', params)
    def get_all_route_tables(self, route_table_ids=None, filters=None,
                             dry_run=False):
        params = {}
        if route_table_ids:
            self.build_list_params(params, route_table_ids, "RouteTableId")
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeRouteTables', params,
                             [('item', RouteTable)])
    def associate_route_table(self, route_table_id, subnet_id, dry_run=False):
        params = {
            'RouteTableId': route_table_id,
            'SubnetId': subnet_id
        }
        if dry_run:
            params['DryRun'] = 'true'
        result = self.get_object('AssociateRouteTable', params, ResultSet)
        return result.associationId
    def disassociate_route_table(self, association_id, dry_run=False):
        params = {'AssociationId': association_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DisassociateRouteTable', params)
    def create_route_table(self, vpc_id, dry_run=False):
        params = {'VpcId': vpc_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('CreateRouteTable', params, RouteTable)
    def delete_route_table(self, route_table_id, dry_run=False):
        params = {'RouteTableId': route_table_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteRouteTable', params)
    def _replace_route_table_association(self, association_id,
                                        route_table_id, dry_run=False):
        params = {
            'AssociationId': association_id,
            'RouteTableId': route_table_id
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('ReplaceRouteTableAssociation', params,
                               ResultSet)
    def replace_route_table_assocation(self, association_id,
                                       route_table_id, dry_run=False):
        return self._replace_route_table_association(
            association_id, route_table_id, dry_run=dry_run).status
    def replace_route_table_association_with_assoc(self, association_id,
                                                   route_table_id,
                                                   dry_run=False):
        return self._replace_route_table_association(
            association_id, route_table_id, dry_run=dry_run).newAssociationId
    def create_route(self, route_table_id, destination_cidr_block,
                     gateway_id=None, instance_id=None, interface_id=None,
                     vpc_peering_connection_id=None,
                     dry_run=False):
        params = {
            'RouteTableId': route_table_id,
            'DestinationCidrBlock': destination_cidr_block
        }
        if gateway_id is not None:
            params['GatewayId'] = gateway_id
        elif instance_id is not None:
            params['InstanceId'] = instance_id
        elif interface_id is not None:
            params['NetworkInterfaceId'] = interface_id
        elif vpc_peering_connection_id is not None:
            params['VpcPeeringConnectionId'] = vpc_peering_connection_id
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('CreateRoute', params)
    def replace_route(self, route_table_id, destination_cidr_block,
                      gateway_id=None, instance_id=None, interface_id=None,
                      vpc_peering_connection_id=None,
                      dry_run=False):
        params = {
            'RouteTableId': route_table_id,
            'DestinationCidrBlock': destination_cidr_block
        }
        if gateway_id is not None:
            params['GatewayId'] = gateway_id
        elif instance_id is not None:
            params['InstanceId'] = instance_id
        elif interface_id is not None:
            params['NetworkInterfaceId'] = interface_id
        elif vpc_peering_connection_id is not None:
            params['VpcPeeringConnectionId'] = vpc_peering_connection_id
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('ReplaceRoute', params)
    def delete_route(self, route_table_id, destination_cidr_block,
                     dry_run=False):
        params = {
            'RouteTableId': route_table_id,
            'DestinationCidrBlock': destination_cidr_block
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteRoute', params)
    def get_all_network_acls(self, network_acl_ids=None, filters=None):
        params = {}
        if network_acl_ids:
            self.build_list_params(params, network_acl_ids, "NetworkAclId")
        if filters:
            self.build_filter_params(params, filters)
        return self.get_list('DescribeNetworkAcls', params,
                             [('item', NetworkAcl)])
    def associate_network_acl(self, network_acl_id, subnet_id):
        acl = self.get_all_network_acls(filters=[('association.subnet-id', subnet_id)])[0]
        association = [ association for association in acl.associations if association.subnet_id == subnet_id ][0]
        params = {
            'AssociationId': association.id,
            'NetworkAclId': network_acl_id
        }
        result = self.get_object('ReplaceNetworkAclAssociation', params, ResultSet)
        return result.newAssociationId
    def disassociate_network_acl(self, subnet_id, vpc_id=None):
        if not vpc_id:
            vpc_id = self.get_all_subnets([subnet_id])[0].vpc_id
        acls = self.get_all_network_acls(filters=[('vpc-id', vpc_id), ('default', 'true')])
        default_acl_id = acls[0].id
        return self.associate_network_acl(default_acl_id, subnet_id)
    def create_network_acl(self, vpc_id):
        params = {'VpcId': vpc_id}
        return self.get_object('CreateNetworkAcl', params, NetworkAcl)
    def delete_network_acl(self, network_acl_id):
        params = {'NetworkAclId': network_acl_id}
        return self.get_status('DeleteNetworkAcl', params)
    def create_network_acl_entry(self, network_acl_id, rule_number, protocol, rule_action,
                                 cidr_block, egress=None, icmp_code=None, icmp_type=None,
                                 port_range_from=None, port_range_to=None):
        params = {
            'NetworkAclId': network_acl_id,
            'RuleNumber': rule_number,
            'Protocol': protocol,
            'RuleAction': rule_action,
            'CidrBlock': cidr_block
        }
<a name="1"></a>        if egress is not None:
            if isinstance(egress, bool):
                egress = str(egress).lower()
            params<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>['Egress'] = egress
        if icmp_code is not None:
            params['Icmp.Code'] = icmp_code
        if icmp_type is not None:
            params['Icmp.Type'] = icmp_type
        if port_range_from is not None:
            params['PortRange.From'] = port_range_from
        if port_range_to is not None:
            params['PortRange.To'] =</b></font> port_range_to
        return self.get_status('CreateNetworkAclEntry', params)
    def replace_network_acl_entry(self, network_acl_id, rule_number, protocol, rule_action,
                                  cidr_block, egress=None, icmp_code=None, icmp_type=None,
                                  port_range_from=None, port_range_to=None):
        params = {
            'NetworkAclId': network_acl_id,
            'RuleNumber': rule_number,
            'Protocol': protocol,
            'RuleAction': rule_action,
            'CidrBlock': cidr_block
        }
<a name="0"></a>        if egress is not None:
            if isinstance(egress, bool):
                egress = str(egress).lower()
            params<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>['Egress'] = egress
        if icmp_code is not None:
            params['Icmp.Code'] = icmp_code
        if icmp_type is not None:
            params['Icmp.Type'] = icmp_type
        if port_range_from is not None:
            params['PortRange.From'] = port_range_from
        if port_range_to is not None:
            params['PortRange.To'] =</b></font> port_range_to
        return self.get_status('ReplaceNetworkAclEntry', params)
    def delete_network_acl_entry(self, network_acl_id, rule_number, egress=None):
        params = {
            'NetworkAclId': network_acl_id,
            'RuleNumber': rule_number
        }
        if egress is not None:
            if isinstance(egress, bool):
                egress = str(egress).lower()
            params['Egress'] = egress
        return self.get_status('DeleteNetworkAclEntry', params)
    def get_all_internet_gateways(self, internet_gateway_ids=None,
                                  filters=None, dry_run=False):
        params = {}
        if internet_gateway_ids:
            self.build_list_params(params, internet_gateway_ids,
                                   'InternetGatewayId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeInternetGateways', params,
                             [('item', InternetGateway)])
    def create_internet_gateway(self, dry_run=False):
        params = {}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('CreateInternetGateway', params, InternetGateway)
    def delete_internet_gateway(self, internet_gateway_id, dry_run=False):
        params = {'InternetGatewayId': internet_gateway_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteInternetGateway', params)
    def attach_internet_gateway(self, internet_gateway_id, vpc_id,
                                dry_run=False):
        params = {
            'InternetGatewayId': internet_gateway_id,
            'VpcId': vpc_id
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('AttachInternetGateway', params)
    def detach_internet_gateway(self, internet_gateway_id, vpc_id,
                                dry_run=False):
        params = {
            'InternetGatewayId': internet_gateway_id,
            'VpcId': vpc_id
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DetachInternetGateway', params)
    def get_all_customer_gateways(self, customer_gateway_ids=None,
                                  filters=None, dry_run=False):
        params = {}
        if customer_gateway_ids:
            self.build_list_params(params, customer_gateway_ids,
                                   'CustomerGatewayId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeCustomerGateways', params,
                             [('item', CustomerGateway)])
    def create_customer_gateway(self, type, ip_address, bgp_asn, dry_run=False):
        params = {'Type': type,
                  'IpAddress': ip_address,
                  'BgpAsn': bgp_asn}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('CreateCustomerGateway', params, CustomerGateway)
    def delete_customer_gateway(self, customer_gateway_id, dry_run=False):
        params = {'CustomerGatewayId': customer_gateway_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteCustomerGateway', params)
    def get_all_vpn_gateways(self, vpn_gateway_ids=None, filters=None,
                             dry_run=False):
        params = {}
        if vpn_gateway_ids:
            self.build_list_params(params, vpn_gateway_ids, 'VpnGatewayId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
<a name="4"></a>        return self.get_list('DescribeVpnGateways', params,
                             [('item', VpnGateway)])
    def create_vpn_gateway(self, type, availability_zone<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, dry_run=False):
        params = {'Type': type}
        if availability_zone:
            params['AvailabilityZone'] = availability_zone
        if dry_run:
            params['DryRun'] =</b></font> 'true'
        return self.get_object('CreateVpnGateway', params, VpnGateway)
    def delete_vpn_gateway(self, vpn_gateway_id, dry_run=False):
        params = {'VpnGatewayId': vpn_gateway_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteVpnGateway', params)
    def attach_vpn_gateway(self, vpn_gateway_id, vpc_id, dry_run=False):
        params = {'VpnGatewayId': vpn_gateway_id,
                  'VpcId': vpc_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('AttachVpnGateway', params, Attachment)
    def detach_vpn_gateway(self, vpn_gateway_id, vpc_id, dry_run=False):
        params = {'VpnGatewayId': vpn_gateway_id,
                  'VpcId': vpc_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DetachVpnGateway', params)
    def get_all_subnets(self, subnet_ids=None, filters=None, dry_run=False):
        params = {}
        if subnet_ids:
            self.build_list_params(params, subnet_ids, 'SubnetId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
<a name="3"></a>            params['DryRun'] = 'true'
        return self.get_list('DescribeSubnets', params, [('item', Subnet)])
    def create_subnet(self, vpc_id, cidr_block, availability_zone<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
                      dry_run=False):
        params = {'VpcId': vpc_id,
                  'CidrBlock': cidr_block}
        if availability_zone:
            params['AvailabilityZone'] = availability_zone
        if dry_run:
            params['DryRun'] =</b></font> 'true'
        return self.get_object('CreateSubnet', params, Subnet)
    def delete_subnet(self, subnet_id, dry_run=False):
        params = {'SubnetId': subnet_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteSubnet', params)
    def get_all_dhcp_options(self, dhcp_options_ids=None, filters=None, dry_run=False):
        params = {}
        if dhcp_options_ids:
            self.build_list_params(params, dhcp_options_ids, 'DhcpOptionsId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeDhcpOptions', params,
                             [('item', DhcpOptions)])
    def create_dhcp_options(self, domain_name=None, domain_name_servers=None,
                            ntp_servers=None, netbios_name_servers=None,
                            netbios_node_type=None, dry_run=False):
        key_counter = 1
        params = {}
        def insert_option(params, name, value):
            params['DhcpConfiguration.%d.Key' % (key_counter,)] = name
            if isinstance(value, (list, tuple)):
                for idx, value in enumerate(value, 1):
                    key_name = 'DhcpConfiguration.%d.Value.%d' % (
                        key_counter, idx)
                    params[key_name] = value
            else:
                key_name = 'DhcpConfiguration.%d.Value.1' % (key_counter,)
                params[key_name] = value
            return key_counter + 1
        if domain_name:
            key_counter = insert_option(params,
                                        'domain-name', domain_name)
        if domain_name_servers:
            key_counter = insert_option(params,
                                        'domain-name-servers', domain_name_servers)
        if ntp_servers:
            key_counter = insert_option(params,
                                        'ntp-servers', ntp_servers)
        if netbios_name_servers:
            key_counter = insert_option(params,
                                        'netbios-name-servers', netbios_name_servers)
        if netbios_node_type:
            key_counter = insert_option(params,
                                        'netbios-node-type', netbios_node_type)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('CreateDhcpOptions', params, DhcpOptions)
    def delete_dhcp_options(self, dhcp_options_id, dry_run=False):
        params = {'DhcpOptionsId': dhcp_options_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteDhcpOptions', params)
    def associate_dhcp_options(self, dhcp_options_id, vpc_id, dry_run=False):
        params = {'DhcpOptionsId': dhcp_options_id,
                  'VpcId': vpc_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('AssociateDhcpOptions', params)
    def get_all_vpn_connections(self, vpn_connection_ids=None, filters=None,
                                dry_run=False):
        params = {}
        if vpn_connection_ids:
            self.build_list_params(params, vpn_connection_ids,
                                   'VpnConnectionId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeVpnConnections', params,
                             [('item', VpnConnection)])
    def create_vpn_connection(self, type, customer_gateway_id, vpn_gateway_id,
                              static_routes_only=None, dry_run=False):
        params = {'Type': type,
                  'CustomerGatewayId': customer_gateway_id,
                  'VpnGatewayId': vpn_gateway_id}
        if static_routes_only is not None:
            if isinstance(static_routes_only, bool):
                static_routes_only = str(static_routes_only).lower()
            params['Options.StaticRoutesOnly'] = static_routes_only
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('CreateVpnConnection', params, VpnConnection)
    def delete_vpn_connection(self, vpn_connection_id, dry_run=False):
        params = {'VpnConnectionId': vpn_connection_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteVpnConnection', params)
    def disable_vgw_route_propagation(self, route_table_id, gateway_id,
                                      dry_run=False):
        params = {
            'RouteTableId': route_table_id,
            'GatewayId': gateway_id,
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DisableVgwRoutePropagation', params)
    def enable_vgw_route_propagation(self, route_table_id, gateway_id,
                                     dry_run=False):
        params = {
            'RouteTableId': route_table_id,
            'GatewayId': gateway_id,
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('EnableVgwRoutePropagation', params)
    def create_vpn_connection_route(self, destination_cidr_block,
                                    vpn_connection_id, dry_run=False):
        params = {
            'DestinationCidrBlock': destination_cidr_block,
            'VpnConnectionId': vpn_connection_id,
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('CreateVpnConnectionRoute', params)
    def delete_vpn_connection_route(self, destination_cidr_block,
                                    vpn_connection_id, dry_run=False):
        params = {
            'DestinationCidrBlock': destination_cidr_block,
            'VpnConnectionId': vpn_connection_id,
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteVpnConnectionRoute', params)
    def get_all_vpc_peering_connections(self, vpc_peering_connection_ids=None, 
                                        filters=None, dry_run=False):
        params = {}
        if vpc_peering_connection_ids:
            self.build_list_params(params, vpc_peering_connection_ids, 'VpcPeeringConnectionId')
        if filters:
            self.build_filter_params(params, dict(filters))
        if dry_run:
            params['DryRun'] = 'true'
<a name="2"></a>        return self.get_list('DescribeVpcPeeringConnections', params, [('item', VpcPeeringConnection)])
    def create_vpc_peering_connection(self, vpc_id, peer_vpc_id, 
                                      peer_owner_id<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, dry_run=False):
        params = {'VpcId': vpc_id,
                  'PeerVpcId': peer_vpc_id }
        if peer_owner_id is not None:
            params['PeerOwnerId'] = peer_owner_id
        if dry_run:
            params['DryRun'] =</b></font> 'true'
        return self.get_object('CreateVpcPeeringConnection', params, 
                               VpcPeeringConnection)
    def delete_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
        params = {
            'VpcPeeringConnectionId': vpc_peering_connection_id
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DeleteVpcPeeringConnection', params)
    def reject_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
        params = {
            'VpcPeeringConnectionId': vpc_peering_connection_id
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('RejectVpcPeeringConnection', params)
    def accept_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
        params = {
            'VpcPeeringConnectionId': vpc_peering_connection_id
        }
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_object('AcceptVpcPeeringConnection', params, 
                               VpcPeeringConnection)
    def get_all_classic_link_vpcs(self, vpc_ids=None, filters=None,
                                   dry_run=False):
        params = {}
        if vpc_ids:
            self.build_list_params(params, vpc_ids, 'VpcId')
        if filters:
            self.build_filter_params(params, filters)
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_list('DescribeVpcClassicLink', params, [('item', VPC)],
                             verb='POST')
    def attach_classic_link_vpc(self, vpc_id, instance_id, groups,
                                dry_run=False):
        params = {'VpcId': vpc_id, 'InstanceId': instance_id}
        if dry_run:
            params['DryRun'] = 'true'
        l = []
        for group in groups:
            if hasattr(group, 'id'):
                l.append(group.id)
            else:
                l.append(group)
        self.build_list_params(params, l, 'SecurityGroupId')
        return self.get_status('AttachClassicLinkVpc', params)
    def detach_classic_link_vpc(self, vpc_id, instance_id, dry_run=False):
        params = {'VpcId': vpc_id, 'InstanceId': instance_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DetachClassicLinkVpc', params)
    def disable_vpc_classic_link(self, vpc_id, dry_run=False):
        params = {'VpcId': vpc_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('DisableVpcClassicLink', params)
    def enable_vpc_classic_link(self, vpc_id, dry_run=False):
        params = {'VpcId': vpc_id}
        if dry_run:
            params['DryRun'] = 'true'
        return self.get_status('EnableVpcClassicLink', params)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
