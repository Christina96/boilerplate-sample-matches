<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for layer1_25.py &amp; __init__.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for layer1_25.py &amp; __init__.py
      </h3>
<h1 align="center">
        10.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>layer1_25.py (16.796875%)<th>__init__.py (8.067542%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(567-575)<td><a href="#" name="0">(744-752)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(513-521)<td><a href="#" name="1">(676-684)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(429-459)<td><a href="#" name="2">(1600-1621)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(387-423)<td><a href="#" name="3">(1154-1179)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(348-381)<td><a href="#" name="4">(1029-1049)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(279-306)<td><a href="#" name="5">(112-133)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>layer1_25.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import time
2 from binascii import crc32
3 import boto
4 from boto.connection import AWSAuthConnection
5 from boto.exception import DynamoDBResponseError
6 from boto.provider import Provider
7 from boto.dynamodb import exceptions as dynamodb_exceptions
8 from boto.compat import json
9 class Layer1(AWSAuthConnection):
10     DefaultRegionName = 'us-east-1'
11     ServiceName = 'DynamoDB'
12     Version = '20111205'
13     ThruputError = "ProvisionedThroughputExceededException"
14     SessionExpiredError = 'com.amazon.coral.service#ExpiredTokenException'
15     ConditionalCheckFailedError = 'ConditionalCheckFailedException'
16     ValidationError = 'ValidationException'
17     ResponseError = DynamoDBResponseError
18     NumberRetries = 10
19     def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
20                  is_secure=True, port=None, proxy=None, proxy_port=None,
21                  debug=0, security_token=None, region=None,
22                  validate_certs=True, validate_checksums=True, profile_name=None):
23         if not region:
24             region_name = boto.config.get('DynamoDB', 'region',
25                                           self.DefaultRegionName)
26             for reg in boto.dynamodb.regions():
27                 if reg.name == region_name:
28                     region = reg
29                     break
30         self.region = region
31         super(Layer1, self).__init__(self.region.endpoint,
32                                    aws_access_key_id,
33                                    aws_secret_access_key,
34                                    is_secure, port, proxy, proxy_port,
35                                    debug=debug, security_token=security_token,
36                                    validate_certs=validate_certs,
37                                    profile_name=profile_name)
38         self.throughput_exceeded_events = 0
39         self._validate_checksums = boto.config.getbool(
40             'DynamoDB', 'validate_checksums', validate_checksums)
41     def _get_session_token(self):
42         self.provider = Provider(self._provider_type)
43         self._auth_handler.update_provider(self.provider)
44     def _required_auth_capability(self):
45         return ['hmac-v4']
46     def make_request(self, action, body='', object_hook=None):
47         headers = {'X-Amz-Target': '%s_%s.%s' % (self.ServiceName,
48                                                  self.Version, action),
49                    'Host': self.region.endpoint,
50                    'Content-Type': 'application/x-amz-json-1.0',
51                    'Content-Length': str(len(body))}
52         http_request = self.build_base_http_request('POST', '/', '/',
53                                                     {}, headers, body, None)
54         start = time.time()
55         response = self._mexe(http_request, sender=None,
56                               override_num_retries=self.NumberRetries,
57                               retry_handler=self._retry_handler)
58         elapsed = (time.time() - start) * 1000
59         request_id = response.getheader('x-amzn-RequestId')
60         boto.log.debug('RequestId: %s' % request_id)
61         boto.perflog.debug('%s: id=%s time=%sms',
62                            headers['X-Amz-Target'], request_id, int(elapsed))
63         response_body = response.read().decode('utf-8')
64         boto.log.debug(response_body)
65         return json.loads(response_body, object_hook=object_hook)
66     def _retry_handler(self, response, i, next_sleep):
67         status = None
68         if response.status == 400:
69             response_body = response.read().decode('utf-8')
70             boto.log.debug(response_body)
71             data = json.loads(response_body)
72             if self.ThruputError in data.get('__type'):
73                 self.throughput_exceeded_events += 1
74                 msg = "%s, retry attempt %s" % (self.ThruputError, i)
75                 next_sleep = self._exponential_time(i)
76                 i += 1
77                 status = (msg, i, next_sleep)
78                 if i == self.NumberRetries:
79                     raise dynamodb_exceptions.DynamoDBThroughputExceededError(
80                         response.status, response.reason, data)
81             elif self.SessionExpiredError in data.get('__type'):
82                 msg = 'Renewing Session Token'
83                 self._get_session_token()
84                 status = (msg, i + self.num_retries - 1, 0)
85             elif self.ConditionalCheckFailedError in data.get('__type'):
86                 raise dynamodb_exceptions.DynamoDBConditionalCheckFailedError(
87                     response.status, response.reason, data)
88             elif self.ValidationError in data.get('__type'):
89                 raise dynamodb_exceptions.DynamoDBValidationError(
90                     response.status, response.reason, data)
91             else:
92                 raise self.ResponseError(response.status, response.reason,
93                                          data)
94         expected_crc32 = response.getheader('x-amz-crc32')
95         if self._validate_checksums and expected_crc32 is not None:
96             boto.log.debug('Validating crc32 checksum for body: %s',
97                            response.read().decode('utf-8'))
98             actual_crc32 = crc32(response.read()) &amp; 0xffffffff
99             expected_crc32 = int(expected_crc32)
100             if actual_crc32 != expected_crc32:
101                 msg = ("The calculated checksum %s did not match the expected "
102                        "checksum %s" % (actual_crc32, expected_crc32))
103                 status = (msg, i + 1, self._exponential_time(i))
104         return status
105     def _exponential_time(self, i):
106         if i == 0:
107             next_sleep = 0
108         else:
109             next_sleep = min(0.05 * (2 ** i),
110                              boto.config.get('Boto', 'max_retry_delay', 60))
111         return next_sleep
112     def list_tables(self, limit=None, start_table=None):
113         data = {}
114         if limit:
115             data['Limit'] = limit
116         if start_table:
117             data['ExclusiveStartTableName'] = start_table
118         json_input = json.dumps(data)
119         return self.make_request('ListTables', json_input)
120     def describe_table(self, table_name):
121         data = {'TableName': table_name}
122         json_input = json.dumps(data)
123         return self.make_request('DescribeTable', json_input)
124     def create_table(self, table_name, schema, provisioned_throughput):
125         data = {'TableName': table_name,
126                 'KeySchema': schema,
127                 'ProvisionedThroughput': provisioned_throughput}
128         json_input = json.dumps(data)
129         response_dict = self.make_request('CreateTable', json_input)
130         return response_dict
131     def update_table(self, table_name, provisioned_throughput):
132         data = {'TableName': table_name,
133                 'ProvisionedThroughput': provisioned_throughput}
134         json_input = json.dumps(data)
135         return self.make_request('UpdateTable', json_input)
136     def delete_table(self, table_name):
137         data = {'TableName': table_name}
138         json_input = json.dumps(data)
139     def get_item(self, table_name, key, attributes_to_get=None,
140                  consistent_read<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=False, object_hook=None):
141         data = {'TableName': table_name,
142                 'Key': key}
143         if attributes_to_get:
144             data['AttributesToGet'] = attributes_to_get
145         if consistent_read:
146             data['ConsistentRead'] =</b></font> True
147         json_input = json.dumps(data)
148         response = self.make_request('GetItem', json_input,
149                                      object_hook=object_hook)
150         if 'Item' not in response:
151             raise dynamodb_exceptions.DynamoDBKeyNotFoundError(
152                 "Key does not exist."
153             )
154         return response
155     def batch_get_item(self, request_items, object_hook=None):
156         if not request_items:
157             return {}
158         data = {'RequestItems': request_items}
159         json_input = json.dumps(data)
160         return self.make_request('BatchGetItem', json_input,
161                                  object_hook=object_hook)
162     def batch_write_item(self, request_items, object_hook=None):
163         data = {'RequestItems': request_items}
164         json_input = json.dumps(data)
165         return self.make_request('BatchWriteItem', json_input,
166     def put_item(self, table_name, item,
167                  expected=None, return_values<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
168                  object_hook=None):
169         data = {'TableName': table_name,
170                 'Item': item}
171         if expected:
172             data['Expected'] = expected
173         if return_values:
174             data['ReturnValues'] =</b></font> return_values
175         json_input = json.dumps(data)
176         return self.make_request('PutItem', json_input,
177     def update_item(self, table_name, key, attribute_updates,
178                     expected=None, return_values<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
179                     object_hook=None):
180         data = {'TableName': table_name,
181                 'Key': key,
182                 'AttributeUpdates': attribute_updates}
183         if expected:
184             data['Expected'] = expected
185         if return_values:
186             data['ReturnValues'] =</b></font> return_values
187         json_input = json.dumps(data)
188         return self.make_request('UpdateItem', json_input,
189     def delete_item(self, table_name, key,
190                     expected=None, return_values<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
191                     object_hook=None):
192         data = {'TableName': table_name,
193                 'Key': key}
194         if expected:
195             data['Expected'] = expected
196         if return_values:
197             data['ReturnValues'] =</b></font> return_values
198         json_input = json.dumps(data)
199         return self.make_request('DeleteItem', json_input,
200                                  object_hook=object_hook)
201     def query(self, table_name, hash_key_value, range_key_conditions=None,
202               attributes_to_get=None, limit=None, consistent_read=False,
203               scan_index_forward=True, exclusive_start_key=None,
204               object_hook=None, count=False):
205                 'HashKeyValue': hash_key_value}
206         if range_key_conditions:
207             data<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>['RangeKeyCondition'] = range_key_conditions
208         if attributes_to_get:
209             data['AttributesToGet'] = attributes_to_get
210         if limit:
211             data['Limit'] = limit
212         if count:
213             data['Count'] = True
214         if consistent_read:
215             data['ConsistentRead'] =</b></font> True
216         if scan_index_forward:
217             data['ScanIndexForward'] = True
218         else:
219             data['ScanIndexForward'] = False
220         if exclusive_start_key:
221             data['ExclusiveStartKey'] = exclusive_start_key
222         json_input = json.dumps(data)
223         return self.make_request('Query', json_input,
224                                  object_hook=object_hook)
225     def scan(self, table_name, scan_filter=None,
226              attributes_to_get=None, limit=None,
227              exclusive_start_key=None, object_hook=None, count=False):
228         """
229             data<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>['ScanFilter'] = scan_filter
230         if attributes_to_get:
231             data['AttributesToGet'] = attributes_to_get
232         if limit:
233             data['Limit'] = limit
234         if count:
235             data['Count'] = True
236         if exclusive_start_key:
237             data['ExclusiveStartKey'] =</b></font> exclusive_start_key
238         json_input = json.dumps(data)
239         return self.make_request('Scan', json_input, object_hook=object_hook)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init__.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Represents a connection to the EC2 service.
3 """
4 from boto.ec2.connection import EC2Connection
5 from boto.resultset import ResultSet
6 from boto.vpc.vpc import VPC
7 from boto.vpc.customergateway import CustomerGateway
8 from boto.vpc.networkacl import NetworkAcl
9 from boto.vpc.routetable import RouteTable
10 from boto.vpc.internetgateway import InternetGateway
11 from boto.vpc.vpngateway import VpnGateway, Attachment
12 from boto.vpc.dhcpoptions import DhcpOptions
13 from boto.vpc.subnet import Subnet
14 from boto.vpc.vpnconnection import VpnConnection
15 from boto.vpc.vpc_peering_connection import VpcPeeringConnection
16 from boto.ec2 import RegionData
17 from boto.regioninfo import RegionInfo, get_regions
18 from boto.regioninfo import connect
19 def regions(**kw_params):
20     """
21     Get all available regions for the EC2 service.
22     You may pass any of the arguments accepted by the VPCConnection
23     object's constructor as keyword arguments and they will be
24     passed along to the VPCConnection object.
25     :rtype: list
26     :return: A list of :class:`boto.ec2.regioninfo.RegionInfo`
27     """
28     return get_regions('ec2', connection_cls=VPCConnection)
29 def connect_to_region(region_name, **kw_params):
30     """
31     Given a valid region name, return a
32     :class:`boto.vpc.VPCConnection`.
33     Any additional parameters after the region_name are passed on to
34     the connect method of the region object.
35     :type: str
36     :param region_name: The name of the region to connect to.
37     :rtype: :class:`boto.vpc.VPCConnection` or ``None``
38     :return: A connection to the given region, or None if an invalid region
39              name is given
40     """
41     return connect('ec2', region_name, connection_cls=VPCConnection,
42                    **kw_params)
43 class VPCConnection(EC2Connection):
44     def get_all_vpcs(self, vpc_ids=None, filters=None, dry_run=False):
45         """
46         Retrieve information about your VPCs.  You can filter results to
47         return information only about those VPCs that match your search
48         parameters.  Otherwise, all VPCs associated with your account
49         are returned.
50         :type vpc_ids: list
51         :param vpc_ids: A list of strings with the desired VPC ID's
52         :type filters: list of tuples or dict
53         :param filters: A list of tuples or dict containing filters.  Each tuple
54             or dict item consists of a filter key and a filter value.
55             Possible filter keys are:
56             * *state* - a list of states of the VPC (pending or available)
57             * *cidrBlock* - a list CIDR blocks of the VPC
58             * *dhcpOptionsId* - a list of IDs of a set of DHCP options
59         :type dry_run: bool
60         :param dry_run: Set to True if the operation should not actually run.
61         :rtype: list
62         :return: A list of :class:`boto.vpc.vpc.VPC`
63         """
64         params = {}
65         if vpc_ids:
66             self.build_list_params(params, vpc_ids, 'VpcId')
67         if filters:
68             self.build_filter_params(params, filters)
69         if dry_run:
70         return self.get_list('DescribeVpcs', params, [('item', VPC)])
71     def create_vpc(self, cidr_block, instance_tenancy<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, dry_run=False):
72         """
73         Create a new Virtual Private Cloud.
74         :type cidr_block: str
75         :param cidr_block: A valid CIDR block
76         :type instance_tenancy: str
77         :param instance_tenancy: The supported tenancy options for instances
78             launched into the VPC. Valid values are 'default' and 'dedicated'.
79         :type dry_run: bool
80         :param dry_run: Set to True if the operation should not actually run.
81         :rtype: The newly created VPC
82         :return: A :class:`boto.vpc.vpc.VPC` object
83         """
84         params = {'CidrBlock': cidr_block}
85         if instance_tenancy:
86             params['InstanceTenancy'] = instance_tenancy
87         if dry_run:
88             params['DryRun'] =</b></font> 'true'
89         return self.get_object('CreateVpc', params, VPC)
90     def delete_vpc(self, vpc_id, dry_run=False):
91         """
92         Delete a Virtual Private Cloud.
93         :type vpc_id: str
94         :param vpc_id: The ID of the vpc to be deleted.
95         :type dry_run: bool
96         :param dry_run: Set to True if the operation should not actually run.
97         :rtype: bool
98         :return: True if successful
99         """
100         params = {'VpcId': vpc_id}
101         if dry_run:
102             params['DryRun'] = 'true'
103         return self.get_status('DeleteVpc', params)
104     def modify_vpc_attribute(self, vpc_id,
105                              enable_dns_support=None,
106                              enable_dns_hostnames=None, dry_run=False):
107         """
108         Modifies the specified attribute of the specified VPC.
109         You can only modify one attribute at a time.
110         :type vpc_id: str
111         :param vpc_id: The ID of the vpc to be deleted.
112         :type enable_dns_support: bool
113         :param enable_dns_support: Specifies whether the DNS server
114             provided by Amazon is enabled for the VPC.
115         :type enable_dns_hostnames: bool
116         :param enable_dns_hostnames: Specifies whether DNS hostnames are
117             provided for the instances launched in this VPC. You can only
118             set this attribute to ``true`` if EnableDnsSupport
119             is also ``true``.
120         :type dry_run: bool
121         :param dry_run: Set to True if the operation should not actually run.
122         """
123         params = {'VpcId': vpc_id}
124         if enable_dns_support is not None:
125             if enable_dns_support:
126                 params['EnableDnsSupport.Value'] = 'true'
127             else:
128                 params['EnableDnsSupport.Value'] = 'false'
129         if enable_dns_hostnames is not None:
130             if enable_dns_hostnames:
131                 params['EnableDnsHostnames.Value'] = 'true'
132             else:
133                 params['EnableDnsHostnames.Value'] = 'false'
134         if dry_run:
135             params['DryRun'] = 'true'
136         return self.get_status('ModifyVpcAttribute', params)
137     def get_all_route_tables(self, route_table_ids=None, filters=None,
138                              dry_run=False):
139         """
140         Retrieve information about your routing tables. You can filter results
141         to return information only about those route tables that match your
142         search parameters. Otherwise, all route tables associated with your
143         account are returned.
144         :type route_table_ids: list
145         :param route_table_ids: A list of strings with the desired route table
146                                 IDs.
147         :type filters: list of tuples or dict
148         :param filters: A list of tuples or dict containing filters. Each tuple
149                         or dict item consists of a filter key and a filter value.
150         :type dry_run: bool
151         :param dry_run: Set to True if the operation should not actually run.
152         :rtype: list
153         :return: A list of :class:`boto.vpc.routetable.RouteTable`
154         """
155         params = {}
156         if route_table_ids:
157             self.build_list_params(params, route_table_ids, "RouteTableId")
158         if filters:
159             self.build_filter_params(params, filters)
160         if dry_run:
161             params['DryRun'] = 'true'
162         return self.get_list('DescribeRouteTables', params,
163                              [('item', RouteTable)])
164     def associate_route_table(self, route_table_id, subnet_id, dry_run=False):
165         """
166         Associates a route table with a specific subnet.
167         :type route_table_id: str
168         :param route_table_id: The ID of the route table to associate.
169         :type subnet_id: str
170         :param subnet_id: The ID of the subnet to associate with.
171         :type dry_run: bool
172         :param dry_run: Set to True if the operation should not actually run.
173         :rtype: str
174         :return: The ID of the association created
175         """
176         params = {
177             'RouteTableId': route_table_id,
178             'SubnetId': subnet_id
179         }
180         if dry_run:
181             params['DryRun'] = 'true'
182         result = self.get_object('AssociateRouteTable', params, ResultSet)
183         return result.associationId
184     def disassociate_route_table(self, association_id, dry_run=False):
185         """
186         Removes an association from a route table. This will cause all subnets
187         that would've used this association to now use the main routing
188         association instead.
189         :type association_id: str
190         :param association_id: The ID of the association to disassociate.
191         :type dry_run: bool
192         :param dry_run: Set to True if the operation should not actually run.
193         :rtype: bool
194         :return: True if successful
195         """
196         params = {'AssociationId': association_id}
197         if dry_run:
198             params['DryRun'] = 'true'
199         return self.get_status('DisassociateRouteTable', params)
200     def create_route_table(self, vpc_id, dry_run=False):
201         """
202         Creates a new route table.
203         :type vpc_id: str
204         :param vpc_id: The VPC ID to associate this route table with.
205         :type dry_run: bool
206         :param dry_run: Set to True if the operation should not actually run.
207         :rtype: The newly created route table
208         :return: A :class:`boto.vpc.routetable.RouteTable` object
209         """
210         params = {'VpcId': vpc_id}
211         if dry_run:
212             params['DryRun'] = 'true'
213         return self.get_object('CreateRouteTable', params, RouteTable)
214     def delete_route_table(self, route_table_id, dry_run=False):
215         """
216         Delete a route table.
217         :type route_table_id: str
218         :param route_table_id: The ID of the route table to delete.
219         :type dry_run: bool
220         :param dry_run: Set to True if the operation should not actually run.
221         :rtype: bool
222         :return: True if successful
223         """
224         params = {'RouteTableId': route_table_id}
225         if dry_run:
226             params['DryRun'] = 'true'
227         return self.get_status('DeleteRouteTable', params)
228     def _replace_route_table_association(self, association_id,
229                                         route_table_id, dry_run=False):
230         """
231         Helper function for replace_route_table_association and
232         replace_route_table_association_with_assoc. Should not be used directly.
233         :type association_id: str
234         :param association_id: The ID of the existing association to replace.
235         :type route_table_id: str
236         :param route_table_id: The route table to ID to be used in the
237             association.
238         :type dry_run: bool
239         :param dry_run: Set to True if the operation should not actually run.
240         :rtype: ResultSet
241         :return: ResultSet of Amazon resposne
242         """
243         params = {
244             'AssociationId': association_id,
245             'RouteTableId': route_table_id
246         }
247         if dry_run:
248             params['DryRun'] = 'true'
249         return self.get_object('ReplaceRouteTableAssociation', params,
250                                ResultSet)
251     def replace_route_table_assocation(self, association_id,
252                                        route_table_id, dry_run=False):
253         """
254         Replaces a route association with a new route table.  This can be
255         used to replace the 'main' route table by using the main route
256         table association instead of the more common subnet type
257         association.
258         NOTE: It may be better to use replace_route_table_association_with_assoc
259         instead of this function; this function does not return the new
260         association ID. This function is retained for backwards compatibility.
261         :type association_id: str
262         :param association_id: The ID of the existing association to replace.
263         :type route_table_id: str
264         :param route_table_id: The route table to ID to be used in the
265             association.
266         :type dry_run: bool
267         :param dry_run: Set to True if the operation should not actually run.
268         :rtype: bool
269         :return: True if successful
270         """
271         return self._replace_route_table_association(
272             association_id, route_table_id, dry_run=dry_run).status
273     def replace_route_table_association_with_assoc(self, association_id,
274                                                    route_table_id,
275                                                    dry_run=False):
276         """
277         Replaces a route association with a new route table.  This can be
278         used to replace the 'main' route table by using the main route
279         table association instead of the more common subnet type
280         association. Returns the new association ID.
281         :type association_id: str
282         :param association_id: The ID of the existing association to replace.
283         :type route_table_id: str
284         :param route_table_id: The route table to ID to be used in the
285             association.
286         :type dry_run: bool
287         :param dry_run: Set to True if the operation should not actually run.
288         :rtype: str
289         :return: New association ID
290         """
291         return self._replace_route_table_association(
292             association_id, route_table_id, dry_run=dry_run).newAssociationId
293     def create_route(self, route_table_id, destination_cidr_block,
294                      gateway_id=None, instance_id=None, interface_id=None,
295                      vpc_peering_connection_id=None,
296                      dry_run=False):
297         """
298         Creates a new route in the route table within a VPC. The route's target
299         can be either a gateway attached to the VPC or a NAT instance in the
300         VPC.
301         :type route_table_id: str
302         :param route_table_id: The ID of the route table for the route.
303         :type destination_cidr_block: str
304         :param destination_cidr_block: The CIDR address block used for the
305                                        destination match.
306         :type gateway_id: str
307         :param gateway_id: The ID of the gateway attached to your VPC.
308         :type instance_id: str
309         :param instance_id: The ID of a NAT instance in your VPC.
310         :type interface_id: str
311         :param interface_id: Allows routing to network interface attachments.
312         :type vpc_peering_connection_id: str
313         :param vpc_peering_connection_id: Allows routing to VPC peering
314                                           connection.
315         :type dry_run: bool
316         :param dry_run: Set to True if the operation should not actually run.
317         :rtype: bool
318         :return: True if successful
319         """
320         params = {
321             'RouteTableId': route_table_id,
322             'DestinationCidrBlock': destination_cidr_block
323         }
324         if gateway_id is not None:
325             params['GatewayId'] = gateway_id
326         elif instance_id is not None:
327             params['InstanceId'] = instance_id
328         elif interface_id is not None:
329             params['NetworkInterfaceId'] = interface_id
330         elif vpc_peering_connection_id is not None:
331             params['VpcPeeringConnectionId'] = vpc_peering_connection_id
332         if dry_run:
333             params['DryRun'] = 'true'
334         return self.get_status('CreateRoute', params)
335     def replace_route(self, route_table_id, destination_cidr_block,
336                       gateway_id=None, instance_id=None, interface_id=None,
337                       vpc_peering_connection_id=None,
338                       dry_run=False):
339         """
340         Replaces an existing route within a route table in a VPC.
341         :type route_table_id: str
342         :param route_table_id: The ID of the route table for the route.
343         :type destination_cidr_block: str
344         :param destination_cidr_block: The CIDR address block used for the
345                                        destination match.
346         :type gateway_id: str
347         :param gateway_id: The ID of the gateway attached to your VPC.
348         :type instance_id: str
349         :param instance_id: The ID of a NAT instance in your VPC.
350         :type interface_id: str
351         :param interface_id: Allows routing to network interface attachments.
352         :type vpc_peering_connection_id: str
353         :param vpc_peering_connection_id: Allows routing to VPC peering
354                                           connection.
355         :type dry_run: bool
356         :param dry_run: Set to True if the operation should not actually run.
357         :rtype: bool
358         :return: True if successful
359         """
360         params = {
361             'RouteTableId': route_table_id,
362             'DestinationCidrBlock': destination_cidr_block
363         }
364         if gateway_id is not None:
365             params['GatewayId'] = gateway_id
366         elif instance_id is not None:
367             params['InstanceId'] = instance_id
368         elif interface_id is not None:
369             params['NetworkInterfaceId'] = interface_id
370         elif vpc_peering_connection_id is not None:
371             params['VpcPeeringConnectionId'] = vpc_peering_connection_id
372         if dry_run:
373             params['DryRun'] = 'true'
374         return self.get_status('ReplaceRoute', params)
375     def delete_route(self, route_table_id, destination_cidr_block,
376                      dry_run=False):
377         """
378         Deletes a route from a route table within a VPC.
379         :type route_table_id: str
380         :param route_table_id: The ID of the route table with the route.
381         :type destination_cidr_block: str
382         :param destination_cidr_block: The CIDR address block used for
383                                        destination match.
384         :type dry_run: bool
385         :param dry_run: Set to True if the operation should not actually run.
386         :rtype: bool
387         :return: True if successful
388         """
389         params = {
390             'RouteTableId': route_table_id,
391             'DestinationCidrBlock': destination_cidr_block
392         }
393         if dry_run:
394             params['DryRun'] = 'true'
395         return self.get_status('DeleteRoute', params)
396     def get_all_network_acls(self, network_acl_ids=None, filters=None):
397         """
398         Retrieve information about your network acls. You can filter results
399         to return information only about those network acls that match your
400         search parameters. Otherwise, all network acls associated with your
401         account are returned.
402         :type network_acl_ids: list
403         :param network_acl_ids: A list of strings with the desired network ACL
404                                 IDs.
405         :type filters: list of tuples or dict
406         :param filters: A list of tuples or dict containing filters. Each tuple
407                         or dict item consists of a filter key and a filter value.
408         :rtype: list
409         :return: A list of :class:`boto.vpc.networkacl.NetworkAcl`
410         """
411         params = {}
412         if network_acl_ids:
413             self.build_list_params(params, network_acl_ids, "NetworkAclId")
414         if filters:
415             self.build_filter_params(params, filters)
416         return self.get_list('DescribeNetworkAcls', params,
417                              [('item', NetworkAcl)])
418     def associate_network_acl(self, network_acl_id, subnet_id):
419         """
420         Associates a network acl with a specific subnet.
421         :type network_acl_id: str
422         :param network_acl_id: The ID of the network ACL to associate.
423         :type subnet_id: str
424         :param subnet_id: The ID of the subnet to associate with.
425         :rtype: str
426         :return: The ID of the association created
427         """
428         acl = self.get_all_network_acls(filters=[('association.subnet-id', subnet_id)])[0]
429         association = [ association for association in acl.associations if association.subnet_id == subnet_id ][0]
430         params = {
431             'AssociationId': association.id,
432             'NetworkAclId': network_acl_id
433         }
434         result = self.get_object('ReplaceNetworkAclAssociation', params, ResultSet)
435         return result.newAssociationId
436     def disassociate_network_acl(self, subnet_id, vpc_id=None):
437         """
438         Figures out what the default ACL is for the VPC, and associates
439         current network ACL with the default.
440         :type subnet_id: str
441         :param subnet_id: The ID of the subnet to which the ACL belongs.
442         :type vpc_id: str
443         :param vpc_id: The ID of the VPC to which the ACL/subnet belongs. Queries EC2 if omitted.
444         :rtype: str
445         :return: The ID of the association created
446         """
447         if not vpc_id:
448             vpc_id = self.get_all_subnets([subnet_id])[0].vpc_id
449         acls = self.get_all_network_acls(filters=[('vpc-id', vpc_id), ('default', 'true')])
450         default_acl_id = acls[0].id
451         return self.associate_network_acl(default_acl_id, subnet_id)
452     def create_network_acl(self, vpc_id):
453         """
454         Creates a new network ACL.
455         :type vpc_id: str
456         :param vpc_id: The VPC ID to associate this network ACL with.
457         :rtype: The newly created network ACL
458         :return: A :class:`boto.vpc.networkacl.NetworkAcl` object
459         """
460         params = {'VpcId': vpc_id}
461         return self.get_object('CreateNetworkAcl', params, NetworkAcl)
462     def delete_network_acl(self, network_acl_id):
463         """
464         Delete a network ACL
465         :type network_acl_id: str
466         :param network_acl_id: The ID of the network_acl to delete.
467         :rtype: bool
468         :return: True if successful
469         """
470         params = {'NetworkAclId': network_acl_id}
471         return self.get_status('DeleteNetworkAcl', params)
472     def create_network_acl_entry(self, network_acl_id, rule_number, protocol, rule_action,
473                                  cidr_block, egress=None, icmp_code=None, icmp_type=None,
474                                  port_range_from=None, port_range_to=None):
475         """
476         Creates a new network ACL entry in a network ACL within a VPC.
477         :type network_acl_id: str
478         :param network_acl_id: The ID of the network ACL for this network ACL entry.
479         :type rule_number: int
480         :param rule_number: The rule number to assign to the entry (for example, 100).
481         :type protocol: int
482         :param protocol: Valid values: -1 or a protocol number
483         (http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
484         :type rule_action: str
485         :param rule_action: Indicates whether to allow or deny traffic that matches the rule.
486         :type cidr_block: str
487         :param cidr_block: The CIDR range to allow or deny, in CIDR notation (for example,
488         172.16.0.0/24).
489         :type egress: bool
490         :param egress: Indicates whether this rule applies to egress traffic from the subnet (true)
491         or ingress traffic to the subnet (false).
492         :type icmp_type: int
493         :param icmp_type: For the ICMP protocol, the ICMP type. You can use -1 to specify
494          all ICMP types.
495         :type icmp_code: int
496         :param icmp_code: For the ICMP protocol, the ICMP code. You can use -1 to specify
497         all ICMP codes for the given ICMP type.
498         :type port_range_from: int
499         :param port_range_from: The first port in the range.
500         :type port_range_to: int
501         :param port_range_to: The last port in the range.
502         :rtype: bool
503         :return: True if successful
504         """
505         params = {
506             'NetworkAclId': network_acl_id,
507             'RuleNumber': rule_number,
508             'Protocol': protocol,
509             'RuleAction': rule_action,
510             'CidrBlock': cidr_block
511         }
512             if isinstance(egress, bool):
513                 egress = str(egress).lower()
514             params<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>['Egress'] = egress
515         if icmp_code is not None:
516             params['Icmp.Code'] = icmp_code
517         if icmp_type is not None:
518             params['Icmp.Type'] = icmp_type
519         if port_range_from is not None:
520             params['PortRange.From'] = port_range_from
521         if port_range_to is not None:
522             params['PortRange.To'] =</b></font> port_range_to
523         return self.get_status('CreateNetworkAclEntry', params)
524     def replace_network_acl_entry(self, network_acl_id, rule_number, protocol, rule_action,
525                                   cidr_block, egress=None, icmp_code=None, icmp_type=None,
526                                   port_range_from=None, port_range_to=None):
527         """
528         Creates a new network ACL entry in a network ACL within a VPC.
529         :type network_acl_id: str
530         :param network_acl_id: The ID of the network ACL for the id you want to replace
531         :type rule_number: int
532         :param rule_number: The rule number that you want to replace(for example, 100).
533         :type protocol: int
534         :param protocol: Valid values: -1 or a protocol number
535         (http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
536         :type rule_action: str
537         :param rule_action: Indicates whether to allow or deny traffic that matches the rule.
538         :type cidr_block: str
539         :param cidr_block: The CIDR range to allow or deny, in CIDR notation (for example,
540         172.16.0.0/24).
541         :type egress: bool
542         :param egress: Indicates whether this rule applies to egress traffic from the subnet (true)
543         or ingress traffic to the subnet (false).
544         :type icmp_type: int
545         :param icmp_type: For the ICMP protocol, the ICMP type. You can use -1 to specify
546          all ICMP types.
547         :type icmp_code: int
548         :param icmp_code: For the ICMP protocol, the ICMP code. You can use -1 to specify
549         all ICMP codes for the given ICMP type.
550         :type port_range_from: int
551         :param port_range_from: The first port in the range.
552         :type port_range_to: int
553         :param port_range_to: The last port in the range.
554         :rtype: bool
555         :return: True if successful
556         """
557         params = {
558             'NetworkAclId': network_acl_id,
559             'RuleNumber': rule_number,
560             'Protocol': protocol,
561             'RuleAction': rule_action,
562             'CidrBlock': cidr_block
563         }
564             if isinstance(egress, bool):
565                 egress = str(egress).lower()
566             params<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>['Egress'] = egress
567         if icmp_code is not None:
568             params['Icmp.Code'] = icmp_code
569         if icmp_type is not None:
570             params['Icmp.Type'] = icmp_type
571         if port_range_from is not None:
572             params['PortRange.From'] = port_range_from
573         if port_range_to is not None:
574             params['PortRange.To'] =</b></font> port_range_to
575         return self.get_status('ReplaceNetworkAclEntry', params)
576     def delete_network_acl_entry(self, network_acl_id, rule_number, egress=None):
577         """
578         Deletes a network ACL entry from a network ACL within a VPC.
579         :type network_acl_id: str
580         :param network_acl_id: The ID of the network ACL with the network ACL entry.
581         :type rule_number: int
582         :param rule_number: The rule number for the entry to delete.
583         :type egress: bool
584         :param egress: Specifies whether the rule to delete is an egress rule (true)
585         or ingress rule (false).
586         :rtype: bool
587         :return: True if successful
588         """
589         params = {
590             'NetworkAclId': network_acl_id,
591             'RuleNumber': rule_number
592         }
593         if egress is not None:
594             if isinstance(egress, bool):
595                 egress = str(egress).lower()
596             params['Egress'] = egress
597         return self.get_status('DeleteNetworkAclEntry', params)
598     def get_all_internet_gateways(self, internet_gateway_ids=None,
599                                   filters=None, dry_run=False):
600         """
601         Get a list of internet gateways. You can filter results to return information
602         about only those gateways that you're interested in.
603         :type internet_gateway_ids: list
604         :param internet_gateway_ids: A list of strings with the desired gateway IDs.
605         :type filters: list of tuples or dict
606         :param filters: A list of tuples or dict containing filters.  Each tuple
607                         or dict item consists of a filter key and a filter value.
608         :type dry_run: bool
609         :param dry_run: Set to True if the operation should not actually run.
610         """
611         params = {}
612         if internet_gateway_ids:
613             self.build_list_params(params, internet_gateway_ids,
614                                    'InternetGatewayId')
615         if filters:
616             self.build_filter_params(params, filters)
617         if dry_run:
618             params['DryRun'] = 'true'
619         return self.get_list('DescribeInternetGateways', params,
620                              [('item', InternetGateway)])
621     def create_internet_gateway(self, dry_run=False):
622         """
623         Creates an internet gateway for VPC.
624         :type dry_run: bool
625         :param dry_run: Set to True if the operation should not actually run.
626         :rtype: Newly created internet gateway.
627         :return: `boto.vpc.internetgateway.InternetGateway`
628         """
629         params = {}
630         if dry_run:
631             params['DryRun'] = 'true'
632         return self.get_object('CreateInternetGateway', params, InternetGateway)
633     def delete_internet_gateway(self, internet_gateway_id, dry_run=False):
634         """
635         Deletes an internet gateway from the VPC.
636         :type internet_gateway_id: str
637         :param internet_gateway_id: The ID of the internet gateway to delete.
638         :type dry_run: bool
639         :param dry_run: Set to True if the operation should not actually run.
640         :rtype: Bool
641         :return: True if successful
642         """
643         params = {'InternetGatewayId': internet_gateway_id}
644         if dry_run:
645             params['DryRun'] = 'true'
646         return self.get_status('DeleteInternetGateway', params)
647     def attach_internet_gateway(self, internet_gateway_id, vpc_id,
648                                 dry_run=False):
649         """
650         Attach an internet gateway to a specific VPC.
651         :type internet_gateway_id: str
652         :param internet_gateway_id: The ID of the internet gateway to attach.
653         :type vpc_id: str
654         :param vpc_id: The ID of the VPC to attach to.
655         :type dry_run: bool
656         :param dry_run: Set to True if the operation should not actually run.
657         :rtype: Bool
658         :return: True if successful
659         """
660         params = {
661             'InternetGatewayId': internet_gateway_id,
662             'VpcId': vpc_id
663         }
664         if dry_run:
665             params['DryRun'] = 'true'
666         return self.get_status('AttachInternetGateway', params)
667     def detach_internet_gateway(self, internet_gateway_id, vpc_id,
668                                 dry_run=False):
669         """
670         Detach an internet gateway from a specific VPC.
671         :type internet_gateway_id: str
672         :param internet_gateway_id: The ID of the internet gateway to detach.
673         :type vpc_id: str
674         :param vpc_id: The ID of the VPC to attach to.
675         :type dry_run: bool
676         :param dry_run: Set to True if the operation should not actually run.
677         :rtype: Bool
678         :return: True if successful
679         """
680         params = {
681             'InternetGatewayId': internet_gateway_id,
682             'VpcId': vpc_id
683         }
684         if dry_run:
685             params['DryRun'] = 'true'
686         return self.get_status('DetachInternetGateway', params)
687     def get_all_customer_gateways(self, customer_gateway_ids=None,
688                                   filters=None, dry_run=False):
689         """
690         Retrieve information about your CustomerGateways.  You can filter
691         results to return information only about those CustomerGateways that
692         match your search parameters.  Otherwise, all CustomerGateways
693         associated with your account are returned.
694         :type customer_gateway_ids: list
695         :param customer_gateway_ids: A list of strings with the desired
696             CustomerGateway ID's.
697         :type filters: list of tuples or dict
698         :param filters: A list of tuples or dict containing filters.  Each tuple
699                         or dict item consists of a filter key and a filter value.
700                         Possible filter keys are:
701                          - *state*, the state of the CustomerGateway
702                            (pending,available,deleting,deleted)
703                          - *type*, the type of customer gateway (ipsec.1)
704                          - *ipAddress* the IP address of customer gateway's
705                            internet-routable external inteface
706         :type dry_run: bool
707         :param dry_run: Set to True if the operation should not actually run.
708         :rtype: list
709         :return: A list of :class:`boto.vpc.customergateway.CustomerGateway`
710         """
711         params = {}
712         if customer_gateway_ids:
713             self.build_list_params(params, customer_gateway_ids,
714                                    'CustomerGatewayId')
715         if filters:
716             self.build_filter_params(params, filters)
717         if dry_run:
718             params['DryRun'] = 'true'
719         return self.get_list('DescribeCustomerGateways', params,
720                              [('item', CustomerGateway)])
721     def create_customer_gateway(self, type, ip_address, bgp_asn, dry_run=False):
722         """
723         Create a new Customer Gateway
724         :type type: str
725         :param type: Type of VPN Connection.  Only valid value currently is 'ipsec.1'
726         :type ip_address: str
727         :param ip_address: Internet-routable IP address for customer's gateway.
728                            Must be a static address.
729         :type bgp_asn: int
730         :param bgp_asn: Customer gateway's Border Gateway Protocol (BGP)
731                         Autonomous System Number (ASN)
732         :type dry_run: bool
733         :param dry_run: Set to True if the operation should not actually run.
734         :rtype: The newly created CustomerGateway
735         :return: A :class:`boto.vpc.customergateway.CustomerGateway` object
736         """
737         params = {'Type': type,
738                   'IpAddress': ip_address,
739                   'BgpAsn': bgp_asn}
740         if dry_run:
741             params['DryRun'] = 'true'
742         return self.get_object('CreateCustomerGateway', params, CustomerGateway)
743     def delete_customer_gateway(self, customer_gateway_id, dry_run=False):
744         """
745         Delete a Customer Gateway.
746         :type customer_gateway_id: str
747         :param customer_gateway_id: The ID of the customer_gateway to be deleted.
748         :type dry_run: bool
749         :param dry_run: Set to True if the operation should not actually run.
750         :rtype: bool
751         :return: True if successful
752         """
753         params = {'CustomerGatewayId': customer_gateway_id}
754         if dry_run:
755             params['DryRun'] = 'true'
756         return self.get_status('DeleteCustomerGateway', params)
757     def get_all_vpn_gateways(self, vpn_gateway_ids=None, filters=None,
758                              dry_run=False):
759         """
760         Retrieve information about your VpnGateways.  You can filter results to
761         return information only about those VpnGateways that match your search
762         parameters.  Otherwise, all VpnGateways associated with your account
763         are returned.
764         :type vpn_gateway_ids: list
765         :param vpn_gateway_ids: A list of strings with the desired VpnGateway ID's
766         :type filters: list of tuples or dict
767         :param filters: A list of tuples or dict containing filters.  Each tuple
768                         or dict item consists of a filter key and a filter value.
769                         Possible filter keys are:
770                         - *state*, a list of states of the VpnGateway
771                           (pending,available,deleting,deleted)
772                         - *type*, a list types of customer gateway (ipsec.1)
773                         - *availabilityZone*, a list of  Availability zones the
774                           VPN gateway is in.
775         :type dry_run: bool
776         :param dry_run: Set to True if the operation should not actually run.
777         :rtype: list
778         :return: A list of :class:`boto.vpc.customergateway.VpnGateway`
779         """
780         params = {}
781         if vpn_gateway_ids:
782             self.build_list_params(params, vpn_gateway_ids, 'VpnGatewayId')
783         if filters:
784             self.build_filter_params(params, filters)
785         if dry_run:
786             params['DryRun'] = 'true'
787                              [('item', VpnGateway)])
788     def create_vpn_gateway(self, type, availability_zone<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, dry_run=False):
789         """
790         Create a new Vpn Gateway
791         :type type: str
792         :param type: Type of VPN Connection.  Only valid value currently is 'ipsec.1'
793         :type availability_zone: str
794         :param availability_zone: The Availability Zone where you want the VPN gateway.
795         :type dry_run: bool
796         :param dry_run: Set to True if the operation should not actually run.
797         :rtype: The newly created VpnGateway
798         :return: A :class:`boto.vpc.vpngateway.VpnGateway` object
799         """
800         params = {'Type': type}
801         if availability_zone:
802             params['AvailabilityZone'] = availability_zone
803         if dry_run:
804             params['DryRun'] =</b></font> 'true'
805         return self.get_object('CreateVpnGateway', params, VpnGateway)
806     def delete_vpn_gateway(self, vpn_gateway_id, dry_run=False):
807         """
808         Delete a Vpn Gateway.
809         :type vpn_gateway_id: str
810         :param vpn_gateway_id: The ID of the vpn_gateway to be deleted.
811         :type dry_run: bool
812         :param dry_run: Set to True if the operation should not actually run.
813         :rtype: bool
814         :return: True if successful
815         """
816         params = {'VpnGatewayId': vpn_gateway_id}
817         if dry_run:
818             params['DryRun'] = 'true'
819         return self.get_status('DeleteVpnGateway', params)
820     def attach_vpn_gateway(self, vpn_gateway_id, vpc_id, dry_run=False):
821         """
822         Attaches a VPN gateway to a VPC.
823         :type vpn_gateway_id: str
824         :param vpn_gateway_id: The ID of the vpn_gateway to attach
825         :type vpc_id: str
826         :param vpc_id: The ID of the VPC you want to attach the gateway to.
827         :type dry_run: bool
828         :param dry_run: Set to True if the operation should not actually run.
829         :rtype: An attachment
830         :return: a :class:`boto.vpc.vpngateway.Attachment`
831         """
832         params = {'VpnGatewayId': vpn_gateway_id,
833                   'VpcId': vpc_id}
834         if dry_run:
835             params['DryRun'] = 'true'
836         return self.get_object('AttachVpnGateway', params, Attachment)
837     def detach_vpn_gateway(self, vpn_gateway_id, vpc_id, dry_run=False):
838         """
839         Detaches a VPN gateway from a VPC.
840         :type vpn_gateway_id: str
841         :param vpn_gateway_id: The ID of the vpn_gateway to detach
842         :type vpc_id: str
843         :param vpc_id: The ID of the VPC you want to detach the gateway from.
844         :type dry_run: bool
845         :param dry_run: Set to True if the operation should not actually run.
846         :rtype: bool
847         :return: True if successful
848         """
849         params = {'VpnGatewayId': vpn_gateway_id,
850                   'VpcId': vpc_id}
851         if dry_run:
852             params['DryRun'] = 'true'
853         return self.get_status('DetachVpnGateway', params)
854     def get_all_subnets(self, subnet_ids=None, filters=None, dry_run=False):
855         """
856         Retrieve information about your Subnets.  You can filter results to
857         return information only about those Subnets that match your search
858         parameters.  Otherwise, all Subnets associated with your account
859         are returned.
860         :type subnet_ids: list
861         :param subnet_ids: A list of strings with the desired Subnet ID's
862         :type filters: list of tuples or dict
863         :param filters: A list of tuples or dict containing filters.  Each tuple
864                         or dict item consists of a filter key and a filter value.
865                         Possible filter keys are:
866                         - *state*, a list of states of the Subnet
867                           (pending,available)
868                         - *vpcId*, a list of IDs of the VPC that the subnet is in.
869                         - *cidrBlock*, a list of CIDR blocks of the subnet
870                         - *availabilityZone*, list of the Availability Zones
871                           the subnet is in.
872         :type dry_run: bool
873         :param dry_run: Set to True if the operation should not actually run.
874         :rtype: list
875         :return: A list of :class:`boto.vpc.subnet.Subnet`
876         """
877         params = {}
878         if subnet_ids:
879             self.build_list_params(params, subnet_ids, 'SubnetId')
880         if filters:
881             self.build_filter_params(params, filters)
882         if dry_run:
883         return self.get_list('DescribeSubnets', params, [('item', Subnet)])
884     def create_subnet(self, vpc_id, cidr_block, availability_zone<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
885                       dry_run=False):
886         """
887         Create a new Subnet
888         :type vpc_id: str
889         :param vpc_id: The ID of the VPC where you want to create the subnet.
890         :type cidr_block: str
891         :param cidr_block: The CIDR block you want the subnet to cover.
892         :type availability_zone: str
893         :param availability_zone: The AZ you want the subnet in
894         :type dry_run: bool
895         :param dry_run: Set to True if the operation should not actually run.
896         :rtype: The newly created Subnet
897         :return: A :class:`boto.vpc.customergateway.Subnet` object
898         """
899         params = {'VpcId': vpc_id,
900                   'CidrBlock': cidr_block}
901         if availability_zone:
902             params['AvailabilityZone'] = availability_zone
903         if dry_run:
904             params['DryRun'] =</b></font> 'true'
905         return self.get_object('CreateSubnet', params, Subnet)
906     def delete_subnet(self, subnet_id, dry_run=False):
907         """
908         Delete a subnet.
909         :type subnet_id: str
910         :param subnet_id: The ID of the subnet to be deleted.
911         :type dry_run: bool
912         :param dry_run: Set to True if the operation should not actually run.
913         :rtype: bool
914         :return: True if successful
915         """
916         params = {'SubnetId': subnet_id}
917         if dry_run:
918             params['DryRun'] = 'true'
919         return self.get_status('DeleteSubnet', params)
920     def get_all_dhcp_options(self, dhcp_options_ids=None, filters=None, dry_run=False):
921         """
922         Retrieve information about your DhcpOptions.
923         :type dhcp_options_ids: list
924         :param dhcp_options_ids: A list of strings with the desired DhcpOption ID's
925         :type filters: list of tuples or dict
926         :param filters: A list of tuples or dict containing filters.  Each tuple
927             or dict item consists of a filter key and a filter value.
928         :type dry_run: bool
929         :param dry_run: Set to True if the operation should not actually run.
930         :rtype: list
931         :return: A list of :class:`boto.vpc.dhcpoptions.DhcpOptions`
932         """
933         params = {}
934         if dhcp_options_ids:
935             self.build_list_params(params, dhcp_options_ids, 'DhcpOptionsId')
936         if filters:
937             self.build_filter_params(params, filters)
938         if dry_run:
939             params['DryRun'] = 'true'
940         return self.get_list('DescribeDhcpOptions', params,
941                              [('item', DhcpOptions)])
942     def create_dhcp_options(self, domain_name=None, domain_name_servers=None,
943                             ntp_servers=None, netbios_name_servers=None,
944                             netbios_node_type=None, dry_run=False):
945         """
946         Create a new DhcpOption
947         This corresponds to
948         http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateDhcpOptions.html
949         :type domain_name: str
950         :param domain_name: A domain name of your choice (for example,
951             example.com)
952         :type domain_name_servers: list of strings
953         :param domain_name_servers: The IP address of a domain name server. You
954             can specify up to four addresses.
955         :type ntp_servers: list of strings
956         :param ntp_servers: The IP address of a Network Time Protocol (NTP)
957             server. You can specify up to four addresses.
958         :type netbios_name_servers: list of strings
959         :param netbios_name_servers: The IP address of a NetBIOS name server.
960             You can specify up to four addresses.
961         :type netbios_node_type: str
962         :param netbios_node_type: The NetBIOS node type (1, 2, 4, or 8). For
963             more information about the values, see RFC 2132. We recommend you
964             only use 2 at this time (broadcast and multicast are currently not
965             supported).
966         :type dry_run: bool
967         :param dry_run: Set to True if the operation should not actually run.
968         :rtype: The newly created DhcpOption
969         :return: A :class:`boto.vpc.customergateway.DhcpOption` object
970         """
971         key_counter = 1
972         params = {}
973         def insert_option(params, name, value):
974             params['DhcpConfiguration.%d.Key' % (key_counter,)] = name
975             if isinstance(value, (list, tuple)):
976                 for idx, value in enumerate(value, 1):
977                     key_name = 'DhcpConfiguration.%d.Value.%d' % (
978                         key_counter, idx)
979                     params[key_name] = value
980             else:
981                 key_name = 'DhcpConfiguration.%d.Value.1' % (key_counter,)
982                 params[key_name] = value
983             return key_counter + 1
984         if domain_name:
985             key_counter = insert_option(params,
986                                         'domain-name', domain_name)
987         if domain_name_servers:
988             key_counter = insert_option(params,
989                                         'domain-name-servers', domain_name_servers)
990         if ntp_servers:
991             key_counter = insert_option(params,
992                                         'ntp-servers', ntp_servers)
993         if netbios_name_servers:
994             key_counter = insert_option(params,
995                                         'netbios-name-servers', netbios_name_servers)
996         if netbios_node_type:
997             key_counter = insert_option(params,
998                                         'netbios-node-type', netbios_node_type)
999         if dry_run:
1000             params['DryRun'] = 'true'
1001         return self.get_object('CreateDhcpOptions', params, DhcpOptions)
1002     def delete_dhcp_options(self, dhcp_options_id, dry_run=False):
1003         """
1004         Delete a DHCP Options
1005         :type dhcp_options_id: str
1006         :param dhcp_options_id: The ID of the DHCP Options to be deleted.
1007         :type dry_run: bool
1008         :param dry_run: Set to True if the operation should not actually run.
1009         :rtype: bool
1010         :return: True if successful
1011         """
1012         params = {'DhcpOptionsId': dhcp_options_id}
1013         if dry_run:
1014             params['DryRun'] = 'true'
1015         return self.get_status('DeleteDhcpOptions', params)
1016     def associate_dhcp_options(self, dhcp_options_id, vpc_id, dry_run=False):
1017         """
1018         Associate a set of Dhcp Options with a VPC.
1019         :type dhcp_options_id: str
1020         :param dhcp_options_id: The ID of the Dhcp Options
1021         :type vpc_id: str
1022         :param vpc_id: The ID of the VPC.
1023         :type dry_run: bool
1024         :param dry_run: Set to True if the operation should not actually run.
1025         :rtype: bool
1026         :return: True if successful
1027         """
1028         params = {'DhcpOptionsId': dhcp_options_id,
1029                   'VpcId': vpc_id}
1030         if dry_run:
1031             params['DryRun'] = 'true'
1032         return self.get_status('AssociateDhcpOptions', params)
1033     def get_all_vpn_connections(self, vpn_connection_ids=None, filters=None,
1034                                 dry_run=False):
1035         """
1036         Retrieve information about your VPN_CONNECTIONs.  You can filter results to
1037         return information only about those VPN_CONNECTIONs that match your search
1038         parameters.  Otherwise, all VPN_CONNECTIONs associated with your account
1039         are returned.
1040         :type vpn_connection_ids: list
1041         :param vpn_connection_ids: A list of strings with the desired VPN_CONNECTION ID's
1042         :type filters: list of tuples or dict
1043         :param filters: A list of tuples or dict containing filters.  Each tuple
1044                         or dict item consists of a filter key and a filter value.
1045                         Possible filter keys are:
1046                         - *state*, a list of states of the VPN_CONNECTION
1047                           pending,available,deleting,deleted
1048                         - *type*, a list of types of connection, currently 'ipsec.1'
1049                         - *customerGatewayId*, a list of IDs of the customer gateway
1050                           associated with the VPN
1051                         - *vpnGatewayId*, a list of IDs of the VPN gateway associated
1052                           with the VPN connection
1053         :type dry_run: bool
1054         :param dry_run: Set to True if the operation should not actually run.
1055         :rtype: list
1056         :return: A list of :class:`boto.vpn_connection.vpnconnection.VpnConnection`
1057         """
1058         params = {}
1059         if vpn_connection_ids:
1060             self.build_list_params(params, vpn_connection_ids,
1061                                    'VpnConnectionId')
1062         if filters:
1063             self.build_filter_params(params, filters)
1064         if dry_run:
1065             params['DryRun'] = 'true'
1066         return self.get_list('DescribeVpnConnections', params,
1067                              [('item', VpnConnection)])
1068     def create_vpn_connection(self, type, customer_gateway_id, vpn_gateway_id,
1069                               static_routes_only=None, dry_run=False):
1070         """
1071         Create a new VPN Connection.
1072         :type type: str
1073         :param type: The type of VPN Connection.  Currently only 'ipsec.1'
1074                      is supported
1075         :type customer_gateway_id: str
1076         :param customer_gateway_id: The ID of the customer gateway.
1077         :type vpn_gateway_id: str
1078         :param vpn_gateway_id: The ID of the VPN gateway.
1079         :type static_routes_only: bool
1080         :param static_routes_only: Indicates whether the VPN connection
1081         requires static routes. If you are creating a VPN connection
1082         for a device that does not support BGP, you must specify true.
1083         :type dry_run: bool
1084         :param dry_run: Set to True if the operation should not actually run.
1085         :rtype: The newly created VpnConnection
1086         :return: A :class:`boto.vpc.vpnconnection.VpnConnection` object
1087         """
1088         params = {'Type': type,
1089                   'CustomerGatewayId': customer_gateway_id,
1090                   'VpnGatewayId': vpn_gateway_id}
1091         if static_routes_only is not None:
1092             if isinstance(static_routes_only, bool):
1093                 static_routes_only = str(static_routes_only).lower()
1094             params['Options.StaticRoutesOnly'] = static_routes_only
1095         if dry_run:
1096             params['DryRun'] = 'true'
1097         return self.get_object('CreateVpnConnection', params, VpnConnection)
1098     def delete_vpn_connection(self, vpn_connection_id, dry_run=False):
1099         """
1100         Delete a VPN Connection.
1101         :type vpn_connection_id: str
1102         :param vpn_connection_id: The ID of the vpn_connection to be deleted.
1103         :type dry_run: bool
1104         :param dry_run: Set to True if the operation should not actually run.
1105         :rtype: bool
1106         :return: True if successful
1107         """
1108         params = {'VpnConnectionId': vpn_connection_id}
1109         if dry_run:
1110             params['DryRun'] = 'true'
1111         return self.get_status('DeleteVpnConnection', params)
1112     def disable_vgw_route_propagation(self, route_table_id, gateway_id,
1113                                       dry_run=False):
1114         """
1115         Disables a virtual private gateway (VGW) from propagating routes to the
1116         routing tables of an Amazon VPC.
1117         :type route_table_id: str
1118         :param route_table_id: The ID of the routing table.
1119         :type gateway_id: str
1120         :param gateway_id: The ID of the virtual private gateway.
1121         :type dry_run: bool
1122         :param dry_run: Set to True if the operation should not actually run.
1123         :rtype: bool
1124         :return: True if successful
1125         """
1126         params = {
1127             'RouteTableId': route_table_id,
1128             'GatewayId': gateway_id,
1129         }
1130         if dry_run:
1131             params['DryRun'] = 'true'
1132         return self.get_status('DisableVgwRoutePropagation', params)
1133     def enable_vgw_route_propagation(self, route_table_id, gateway_id,
1134                                      dry_run=False):
1135         """
1136         Enables a virtual private gateway (VGW) to propagate routes to the
1137         routing tables of an Amazon VPC.
1138         :type route_table_id: str
1139         :param route_table_id: The ID of the routing table.
1140         :type gateway_id: str
1141         :param gateway_id: The ID of the virtual private gateway.
1142         :type dry_run: bool
1143         :param dry_run: Set to True if the operation should not actually run.
1144         :rtype: bool
1145         :return: True if successful
1146         """
1147         params = {
1148             'RouteTableId': route_table_id,
1149             'GatewayId': gateway_id,
1150         }
1151         if dry_run:
1152             params['DryRun'] = 'true'
1153         return self.get_status('EnableVgwRoutePropagation', params)
1154     def create_vpn_connection_route(self, destination_cidr_block,
1155                                     vpn_connection_id, dry_run=False):
1156         """
1157         Creates a new static route associated with a VPN connection between an
1158         existing virtual private gateway and a VPN customer gateway. The static
1159         route allows traffic to be routed from the virtual private gateway to
1160         the VPN customer gateway.
1161         :type destination_cidr_block: str
1162         :param destination_cidr_block: The CIDR block associated with the local
1163             subnet of the customer data center.
1164         :type vpn_connection_id: str
1165         :param vpn_connection_id: The ID of the VPN connection.
1166         :type dry_run: bool
1167         :param dry_run: Set to True if the operation should not actually run.
1168         :rtype: bool
1169         :return: True if successful
1170         """
1171         params = {
1172             'DestinationCidrBlock': destination_cidr_block,
1173             'VpnConnectionId': vpn_connection_id,
1174         }
1175         if dry_run:
1176             params['DryRun'] = 'true'
1177         return self.get_status('CreateVpnConnectionRoute', params)
1178     def delete_vpn_connection_route(self, destination_cidr_block,
1179                                     vpn_connection_id, dry_run=False):
1180         """
1181         Deletes a static route associated with a VPN connection between an
1182         existing virtual private gateway and a VPN customer gateway. The static
1183         route allows traffic to be routed from the virtual private gateway to
1184         the VPN customer gateway.
1185         :type destination_cidr_block: str
1186         :param destination_cidr_block: The CIDR block associated with the local
1187             subnet of the customer data center.
1188         :type vpn_connection_id: str
1189         :param vpn_connection_id: The ID of the VPN connection.
1190         :type dry_run: bool
1191         :param dry_run: Set to True if the operation should not actually run.
1192         :rtype: bool
1193         :return: True if successful
1194         """
1195         params = {
1196             'DestinationCidrBlock': destination_cidr_block,
1197             'VpnConnectionId': vpn_connection_id,
1198         }
1199         if dry_run:
1200             params['DryRun'] = 'true'
1201         return self.get_status('DeleteVpnConnectionRoute', params)
1202     def get_all_vpc_peering_connections(self, vpc_peering_connection_ids=None, 
1203                                         filters=None, dry_run=False):
1204         """
1205         Retrieve information about your VPC peering connections. You
1206         can filter results to return information only about those VPC
1207         peering connections that match your search parameters.
1208         Otherwise, all VPC peering connections associated with your
1209         account are returned.
1210         :type vpc_peering_connection_ids: list
1211         :param vpc_peering_connection_ids: A list of strings with the desired VPC
1212             peering connection ID's
1213         :type filters: list of tuples
1214         :param filters: A list of tuples containing filters. Each tuple
1215             consists of a filter key and a filter value.
1216             Possible filter keys are:
1217             * *accepter-vpc-info.cidr-block* - The CIDR block of the peer VPC.
1218             * *accepter-vpc-info.owner-id* - The AWS account ID of the owner 
1219                 of the peer VPC.
1220             * *accepter-vpc-info.vpc-id* - The ID of the peer VPC.
1221             * *expiration-time* - The expiration date and time for the VPC 
1222                 peering connection.
1223             * *requester-vpc-info.cidr-block* - The CIDR block of the 
1224                 requester's VPC.
1225             * *requester-vpc-info.owner-id* - The AWS account ID of the 
1226                 owner of the requester VPC.
1227             * *requester-vpc-info.vpc-id* - The ID of the requester VPC.
1228             * *status-code* - The status of the VPC peering connection.
1229             * *status-message* - A message that provides more information 
1230                 about the status of the VPC peering connection, if applicable.
1231         :type dry_run: bool
1232         :param dry_run: Set to True if the operation should not actually run.
1233         :rtype: list
1234         :return: A list of :class:`boto.vpc.vpc.VPC`
1235         """
1236         params = {}
1237         if vpc_peering_connection_ids:
1238             self.build_list_params(params, vpc_peering_connection_ids, 'VpcPeeringConnectionId')
1239         if filters:
1240             self.build_filter_params(params, dict(filters))
1241         if dry_run:
1242             params['DryRun'] = 'true'
1243     def create_vpc_peering_connection(self, vpc_id, peer_vpc_id, 
1244                                       peer_owner_id<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, dry_run=False):
1245         """
1246         Create a new VPN Peering connection.
1247         :type vpc_id: str
1248         :param vpc_id: The ID of the requester VPC.
1249         :type peer_vpc_id: str
1250         :param vpc_peer_id: The ID of the VPC with which you are creating the peering connection.
1251         :type peer_owner_id: str
1252         :param peer_owner_id: The AWS account ID of the owner of the peer VPC.
1253         :rtype: The newly created VpcPeeringConnection
1254         :return: A :class:`boto.vpc.vpc_peering_connection.VpcPeeringConnection` object
1255         """
1256         params = {'VpcId': vpc_id,
1257                   'PeerVpcId': peer_vpc_id }
1258         if peer_owner_id is not None:
1259             params['PeerOwnerId'] = peer_owner_id
1260         if dry_run:
1261             params['DryRun'] =</b></font> 'true'
1262         return self.get_object('CreateVpcPeeringConnection', params, 
1263                                VpcPeeringConnection)
1264     def delete_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
1265         """
1266         Deletes a VPC peering connection. Either the owner of the requester 
1267         VPC or the owner of the peer VPC can delete the VPC peering connection 
1268         if it's in the active state. The owner of the requester VPC can delete 
1269         a VPC peering connection in the pending-acceptance state.
1270         :type vpc_peering_connection_id: str
1271         :param vpc_peering_connection_id: The ID of the VPC peering connection.
1272         :rtype: bool
1273         :return: True if successful
1274         """
1275         params = {
1276             'VpcPeeringConnectionId': vpc_peering_connection_id
1277         }
1278         if dry_run:
1279             params['DryRun'] = 'true'
1280         return self.get_status('DeleteVpcPeeringConnection', params)
1281     def reject_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
1282         """
1283         Rejects a VPC peering connection request. The VPC peering connection 
1284         must be in the pending-acceptance state. 
1285         :type vpc_peering_connection_id: str
1286         :param vpc_peering_connection_id: The ID of the VPC peering connection.
1287         :rtype: bool
1288         :return: True if successful
1289         """
1290         params = {
1291             'VpcPeeringConnectionId': vpc_peering_connection_id
1292         }
1293         if dry_run:
1294             params['DryRun'] = 'true'
1295         return self.get_status('RejectVpcPeeringConnection', params)
1296     def accept_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
1297         """
1298         Acceptss a VPC peering connection request. The VPC peering connection 
1299         must be in the pending-acceptance state. 
1300         :type vpc_peering_connection_id: str
1301         :param vpc_peering_connection_id: The ID of the VPC peering connection.
1302         :rtype: Accepted VpcPeeringConnection
1303         :return: A :class:`boto.vpc.vpc_peering_connection.VpcPeeringConnection` object
1304         """
1305         params = {
1306             'VpcPeeringConnectionId': vpc_peering_connection_id
1307         }
1308         if dry_run:
1309             params['DryRun'] = 'true'
1310         return self.get_object('AcceptVpcPeeringConnection', params, 
1311                                VpcPeeringConnection)
1312     def get_all_classic_link_vpcs(self, vpc_ids=None, filters=None,
1313                                    dry_run=False):
1314         """
1315         Describes the ClassicLink status of one or more VPCs.
1316         :type vpc_ids: list
1317         :param vpc_ids: A list of strings with the desired VPC ID's
1318         :type dry_run: bool
1319         :param dry_run: Set to True if the operation should not actually run.
1320         :type filters: list of tuples or dict
1321         :param filters: A list of tuples or dict containing filters. Each tuple
1322             or dict item consists of a filter key and a filter value.
1323         :rtype: list
1324         :return: A list of :class:`boto.vpc.vpc.VPC`
1325         """
1326         params = {}
1327         if vpc_ids:
1328             self.build_list_params(params, vpc_ids, 'VpcId')
1329         if filters:
1330             self.build_filter_params(params, filters)
1331         if dry_run:
1332             params['DryRun'] = 'true'
1333         return self.get_list('DescribeVpcClassicLink', params, [('item', VPC)],
1334                              verb='POST')
1335     def attach_classic_link_vpc(self, vpc_id, instance_id, groups,
1336                                 dry_run=False):
1337         """
1338         Links  an EC2-Classic instance to a ClassicLink-enabled VPC through one
1339         or more of the VPC's security groups. You cannot link an EC2-Classic
1340         instance to more than one VPC at a time. You can only link an instance
1341         that's in the running state. An instance is automatically unlinked from
1342         a VPC when it's stopped. You can link it to the VPC again when you
1343         restart it.
1344         After you've linked an instance, you cannot  change  the VPC security
1345         groups  that are associated with it. To change the security groups, you
1346         must first unlink the instance, and then link it again.
1347         Linking your instance to a VPC is sometimes referred  to  as  attaching
1348         your instance.
1349         :type vpc_id: str
1350         :param vpc_id: The ID of a ClassicLink-enabled VPC.
1351         :type intance_id: str
1352         :param instance_is: The ID of a ClassicLink-enabled VPC.
1353         :tye groups: list
1354         :param groups: The ID of one or more of the VPC's security groups.
1355             You cannot specify security groups from a different VPC. The
1356             members of the list can be
1357             :class:`boto.ec2.securitygroup.SecurityGroup` objects or
1358             strings of the id's of the security groups.
1359         :type dry_run: bool
1360         :param dry_run: Set to True if the operation should not actually run.
1361         :rtype: bool
1362         :return: True if successful
1363         """
1364         params = {'VpcId': vpc_id, 'InstanceId': instance_id}
1365         if dry_run:
1366             params['DryRun'] = 'true'
1367         l = []
1368         for group in groups:
1369             if hasattr(group, 'id'):
1370                 l.append(group.id)
1371             else:
1372                 l.append(group)
1373         self.build_list_params(params, l, 'SecurityGroupId')
1374         return self.get_status('AttachClassicLinkVpc', params)
1375     def detach_classic_link_vpc(self, vpc_id, instance_id, dry_run=False):
1376         """
1377         Unlinks a linked EC2-Classic instance from a VPC. After the instance
1378         has been unlinked, the VPC security groups are no longer associated
1379         with it. An instance is automatically unlinked from a VPC when
1380         it's stopped.
1381         :type vpc_id: str
1382         :param vpc_id: The ID of the instance to unlink from the VPC.
1383         :type intance_id: str
1384         :param instance_is: The ID of the VPC to which the instance is linked.
1385         :type dry_run: bool
1386         :param dry_run: Set to True if the operation should not actually run.
1387         :rtype: bool
1388         :return: True if successful
1389         """
1390         params = {'VpcId': vpc_id, 'InstanceId': instance_id}
1391         if dry_run:
1392             params['DryRun'] = 'true'
1393         return self.get_status('DetachClassicLinkVpc', params)
1394     def disable_vpc_classic_link(self, vpc_id, dry_run=False):
1395         """
1396         Disables  ClassicLink  for  a VPC. You cannot disable ClassicLink for a
1397         VPC that has EC2-Classic instances linked to it.
1398         :type vpc_id: str
1399         :param vpc_id: The ID of the VPC.
1400         :type dry_run: bool
1401         :param dry_run: Set to True if the operation should not actually run.
1402         :rtype: bool
1403         :return: True if successful
1404         """
1405         params = {'VpcId': vpc_id}
1406         if dry_run:
1407             params['DryRun'] = 'true'
1408         return self.get_status('DisableVpcClassicLink', params)
1409     def enable_vpc_classic_link(self, vpc_id, dry_run=False):
1410         """
1411         Enables a VPC for ClassicLink. You can then link EC2-Classic instances
1412         to your ClassicLink-enabled VPC to allow communication over private IP
1413         addresses. You cannot enable your VPC for ClassicLink if any of your
1414         VPC's route tables have existing routes for address ranges within the
1415         10.0.0.0/8 IP address range, excluding local routes for VPCs in the
1416         10.0.0.0/16 and 10.1.0.0/16 IP address ranges.
1417         :type vpc_id: str
1418         :param vpc_id: The ID of the VPC.
1419         :type dry_run: bool
1420         :param dry_run: Set to True if the operation should not actually run.
1421         :rtype: bool
1422         :return: True if successful
1423         """
1424         params = {'VpcId': vpc_id}
1425         if dry_run:
1426             params['DryRun'] = 'true'
1427         return self.get_status('EnableVpcClassicLink', params)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
