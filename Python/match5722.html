<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for layer1_9.py &amp; connection_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for layer1_9.py &amp; connection_2.py
      </h3>
<h1 align="center">
        9.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>layer1_9.py (21.40351%)<th>connection_2.py (6.0098524%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(291-343)<td><a href="#" name="0">(721-739)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(359-364)<td><a href="#" name="1">(182-186)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(100-145)<td><a href="#" name="2">(378-414)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(147-152)<td><a href="#" name="3">(750-759)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>layer1_9.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import boto
2 from boto.connection import AWSQueryConnection
3 from boto.regioninfo import RegionInfo
4 from boto.exception import JSONResponseError
5 from boto.cloudtrail import exceptions
6 from boto.compat import json
7 class CloudTrailConnection(AWSQueryConnection):
8     APIVersion = "2013-11-01"
9     DefaultRegionName = "us-east-1"
10     DefaultRegionEndpoint = "cloudtrail.us-east-1.amazonaws.com"
11     ServiceName = "CloudTrail"
12     TargetPrefix = "com.amazonaws.cloudtrail.v20131101.CloudTrail_20131101"
13     ResponseError = JSONResponseError
14     _faults = {
15         "InvalidMaxResultsException": exceptions.InvalidMaxResultsException,
16         "InvalidSnsTopicNameException": exceptions.InvalidSnsTopicNameException,
17         "InvalidS3BucketNameException": exceptions.InvalidS3BucketNameException,
18         "TrailAlreadyExistsException": exceptions.TrailAlreadyExistsException,
19         "InvalidTimeRangeException": exceptions.InvalidTimeRangeException,
20         "InvalidLookupAttributesException": exceptions.InvalidLookupAttributesException,
21         "InsufficientSnsTopicPolicyException": exceptions.InsufficientSnsTopicPolicyException,
22         "InvalidCloudWatchLogsLogGroupArnException": exceptions.InvalidCloudWatchLogsLogGroupArnException,
23         "InvalidCloudWatchLogsRoleArnException": exceptions.InvalidCloudWatchLogsRoleArnException,
24         "InvalidTrailNameException": exceptions.InvalidTrailNameException,
25         "CloudWatchLogsDeliveryUnavailableException": exceptions.CloudWatchLogsDeliveryUnavailableException,
26         "TrailNotFoundException": exceptions.TrailNotFoundException,
27         "S3BucketDoesNotExistException": exceptions.S3BucketDoesNotExistException,
28         "InvalidNextTokenException": exceptions.InvalidNextTokenException,
29         "InvalidS3PrefixException": exceptions.InvalidS3PrefixException,
30         "MaximumNumberOfTrailsExceededException": exceptions.MaximumNumberOfTrailsExceededException,
31         "InsufficientS3BucketPolicyException": exceptions.InsufficientS3BucketPolicyException,
32     }
33     def __init__(self, **kwargs):
34         region = kwargs.pop('region', None)
35         if not region:
36             region = RegionInfo(self, self.DefaultRegionName,
37                                 self.DefaultRegionEndpoint)
38         if 'host' not in kwargs or kwargs['host'] is None:
39             kwargs['host'] = region.endpoint
40         super(CloudTrailConnection, self).__init__(**kwargs)
41         self.region = region
42         return ['hmac-v4']
43     def create_trail(self, name, s3_bucket_name, s3_key_prefix<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
44                      sns_topic_name=None, include_global_service_events=None,
45                      cloud_watch_logs_log_group_arn=None,
46                      cloud_watch_logs_role_arn=None):
47         params = {'Name': name, 'S3BucketName': s3_bucket_name, }
48         if s3_key_prefix is not None:
49             params['S3KeyPrefix'] = s3_key_prefix
50             params[</b></font>'SnsTopicName'] = sns_topic_name
51         if include_global_service_events is not None:
52             params['IncludeGlobalServiceEvents'] =<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b> include_global_service_events
53         if cloud_watch_logs_log_group_arn is not None:
54             params['CloudWatchLogsLogGroupArn'] = cloud_watch_logs_log_group_arn
55         if cloud_watch_logs_role_arn is not None:
56             params['CloudWatchLogsRoleArn'] = cloud_watch_logs_role_arn
57         return self.make_request(</b></font>action='CreateTrail',
58                                  body=json.dumps(params))
59     def delete_trail(self, name):
60         params = {'Name': name, }
61         return self.make_request(action='DeleteTrail',
62                                  body=json.dumps(params))
63     def describe_trails(self, trail_name_list=None):
64         params = {}
65         if trail_name_list is not None:
66             params['trailNameList'] = trail_name_list
67         return self.make_request(action='DescribeTrails',
68                                  body=json.dumps(params))
69     def get_trail_status(self, name):
70         params = {'Name': name, }
71         return self.make_request(action='GetTrailStatus',
72                                  body=json.dumps(params))
73     def lookup_events(self, lookup_attributes=None, start_time=None,
74                       end_time=None, max_results=None, next_token=None):
75         params = {}
76         if lookup_attributes is not None:
77             params['LookupAttributes'] = lookup_attributes
78         if start_time is not None:
79             params['StartTime'] = start_time
80         if end_time is not None:
81             params['EndTime'] = end_time
82         if max_results is not None:
83             params['MaxResults'] = max_results
84         if next_token is not None:
85             params['NextToken'] = next_token
86         return self.make_request(action='LookupEvents',
87                                  body=json.dumps(params))
88     def start_logging(self, name):
89         params = {'Name': name, }
90         return self.make_request(action='StartLogging',
91                                  body=json.dumps(params))
92     def stop_logging(self, name):
93         params = {'Name': name, }
94                                  body=json.dumps(params))
95     def update_trail(self, name, s3_bucket_name<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, s3_key_prefix=None,
96                      sns_topic_name=None, include_global_service_events=None,
97                      cloud_watch_logs_log_group_arn=None,
98                      cloud_watch_logs_role_arn=None):
99         params = {'Name': name, }
100         if s3_bucket_name is not None:
101             params['S3BucketName'] = s3_bucket_name
102         if s3_key_prefix is not None:
103             params['S3KeyPrefix'] = s3_key_prefix
104         if sns_topic_name is not None:
105             params['SnsTopicName'] = sns_topic_name
106         if</b></font> include_global_service_events is not None:
107             params['IncludeGlobalServiceEvents'] = include_global_service_events
108         if cloud_watch_logs_log_group_arn is not None:
109             params['CloudWatchLogsLogGroupArn'] = cloud_watch_logs_log_group_arn
110         if cloud_watch_logs_role_arn is not None:
111             params['CloudWatchLogsRoleArn'] = cloud_watch_logs_role_arn
112         return self.make_request(action='UpdateTrail',
113                                  body=json.dumps(params))
114     def make_request(self, action, body):
115         headers = {
116             'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
117             'Host': self.region.endpoint,
118             'Content-Length': str(len(body)),
119         }
120         http_request <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.build_base_http_request(
121             method='POST', path='/', auth_path='/', params={},
122             headers=headers, data=body)
123         response = self._mexe(http_request, sender=None,
124                               override_num_retries=10)
125         response_body =</b></font> response.read().decode('utf-8')
126         boto.log.debug(response_body)
127         if response.status == 200:
128             if response_body:
129                 return json.loads(response_body)
130         else:
131             json_body = json.loads(response_body)
132             fault_name = json_body.get('__type', None)
133             exception_class = self._faults.get(fault_name, self.ResponseError)
134             raise exception_class(response.status, response.reason,
135                                   body=json_body)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>connection_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import xml.sax
2 import datetime
3 import itertools
4 from boto import handler
5 from boto import config
6 from boto.mturk.price import Price
7 import boto.mturk.notification
8 from boto.connection import AWSQueryConnection
9 from boto.exception import EC2ResponseError
10 from boto.resultset import ResultSet
11 from boto.mturk.question import QuestionForm, ExternalQuestion, HTMLQuestion
12 class MTurkRequestError(EC2ResponseError):
13     "Error for MTurk Requests"
14 class MTurkConnection(AWSQueryConnection):
15     APIVersion = '2014-08-15'
16     def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
17                  is_secure=True, port=None, proxy=None, proxy_port=None,
18                  proxy_user=None, proxy_pass=None,
19                  host=None, debug=0,
20                  https_connection_factory=None, security_token=None,
21                  profile_name=None):
22         if not host:
23             if config.has_option('MTurk', 'sandbox') and config.get('MTurk', 'sandbox') == 'True':
24                 host = 'mechanicalturk.sandbox.amazonaws.com'
25             else:
26                 host = 'mechanicalturk.amazonaws.com'
27         self.debug = debug
28         super(MTurkConnection, self).__init__(aws_access_key_id,
29                                     aws_secret_access_key,
30                                     is_secure, port, proxy, proxy_port,
31                                     proxy_user, proxy_pass, host, debug,
32                                     https_connection_factory,
33                                     security_token=security_token,
34                                     profile_name=profile_name)
35     def _required_auth_capability(self):
36         return ['mturk']
37     def get_account_balance(self):
38         params = {}
39         return self._process_request('GetAccountBalance', params,
40                                      [('AvailableBalance', Price),
41                                       ('OnHoldBalance', Price)])
42     def register_hit_type(self, title, description, reward, duration,
43                           keywords=None, approval_delay=None, qual_req=None):
44         params = dict(
45             Title=title,
46             Description=description,
47             AssignmentDurationInSeconds=self.duration_as_seconds(duration),
48             )
49         params.update(MTurkConnection.get_price_as_price(reward).get_as_params('Reward'))
50         if keywords:
51             params['Keywords'] = self.get_keywords_as_string(keywords)
52         if approval_delay is not None:
53             d = self.duration_as_seconds(approval_delay)
54             params['AutoApprovalDelayInSeconds'] = d
55         if qual_req is not None:
56             params.update(qual_req.get_as_params())
57         return self._process_request('RegisterHITType', params,
58                                      [('HITTypeId', HITTypeId)])
59     def set_email_notification(self, hit_type, email, event_types=None):
60         return self._set_notification(hit_type, 'Email', email,
61                                       'SetHITTypeNotification', event_types)
62     def set_rest_notification(self, hit_type, url, event_types=None):
63         return self._set_notification(hit_type, 'REST', url,
64                                       'SetHITTypeNotification', event_types)
65     def set_sqs_notification(self, hit_type, queue_url, event_types=None):
66         return self._set_notification(hit_type, "SQS", queue_url,
67                                       'SetHITTypeNotification', event_types)
68     def send_test_event_notification(self, hit_type, url,
69                                      event_types=None,
70                                      test_event_type='Ping'):
71         return self._set_notification(hit_type, 'REST', url,
72                                       'SendTestEventNotification',
73                                       event_types, test_event_type)
74     def _set_notification(self, hit_type, transport,
75                           destination, request_type,
76                           event_types=None, test_event_type=None):
77         params = {'HITTypeId': hit_type}
78         notification_params = {'Destination': destination,
79                                'Transport': transport,
80                                'Version': boto.mturk.notification.NotificationMessage.NOTIFICATION_VERSION,
81                                'Active': True,
82                                }
83         if event_types:
84             self.build_list_params(notification_params, event_types,
85                                    'EventType')
86         notification_rest_params = {}
87         num = 1
88         for key in notification_params:
89             notification_rest_params['Notification.%d.%s' % (num, key)] = notification_params[key]
90         params.update(notification_rest_params)
91         if test_event_type:
92             params.update({'TestEventType': test_event_type})
93     def create_hit(self, hit_type=None, question=None, hit_layout=None,
94                    lifetime<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=datetime.timedelta(days=7),
95                    max_assignments=1,
96                    title=None, description=None, keywords=None,
97                    reward=None, duration=datetime.timedelta(days=7),
98                    approval_delay=None, annotation=</b></font>None,
99                    questions=None, qualifications=None,
100                    layout_params=None, response_groups=None):
101         params = {'LifetimeInSeconds':
102                       self.duration_as_seconds(lifetime),
103                   'MaxAssignments': max_assignments,
104                  }
105         neither = question is None and questions is None
106         if hit_layout is None:
107             both = question is not None and questions is not None
108             if neither or both:
109                 raise ValueError("Must specify question (single Question instance) or questions (list or QuestionForm instance), but not both")
110             if question:
111                 questions = [question]
112             question_param = QuestionForm(questions)
113             if isinstance(question, QuestionForm):
114                 question_param = question
115             elif isinstance(question, ExternalQuestion):
116                 question_param = question
117             elif isinstance(question, HTMLQuestion):
118                 question_param = question
119             params['Question'] = question_param.get_as_xml()
120         else:
121             if not neither:
122                 raise ValueError("Must not specify question (single Question instance) or questions (list or QuestionForm instance) when specifying hit_layout")
123             params['HITLayoutId'] = hit_layout
124             if layout_params:
125                 params.update(layout_params.get_as_params())
126         if hit_type:
127             params['HITTypeId'] = hit_type
128         else:
129             final_keywords = MTurkConnection.get_keywords_as_string(keywords)
130             final_price = MTurkConnection.get_price_as_price(reward)
131             final_duration = self.duration_as_seconds(duration)
132             additional_params = dict(
133                 Title=title,
134                 Description=description,
135                 Keywords=final_keywords,
136                 AssignmentDurationInSeconds=final_duration,
137                 )
138             additional_params.update(final_price.get_as_params('Reward'))
139             if approval_delay is not None:
140                 d = self.duration_as_seconds(approval_delay)
141                 additional_params['AutoApprovalDelayInSeconds'] = d
142             params.update(additional_params)
143         if annotation is not None:
144             params['RequesterAnnotation'] = annotation
145         if qualifications is not None:
146             params.update(qualifications.get_as_params())
147         if response_groups:
148             self.build_list_params(params, response_groups, 'ResponseGroup')
149         return self._process_request('CreateHIT', params, [('HIT', HIT)])
150     def change_hit_type_of_hit(self, hit_id, hit_type):
151         params = {'HITId': hit_id,
152                   'HITTypeId': hit_type}
153         return self._process_request('ChangeHITTypeOfHIT', params)
154     def get_reviewable_hits(self, hit_type=None, status='Reviewable',
155                             sort_by='Expiration', sort_direction='Ascending',
156                             page_size=10, page_number=1):
157         params = {'Status': status,
158                   'SortProperty': sort_by,
159                   'SortDirection': sort_direction,
160                   'PageSize': page_size,
161                   'PageNumber': page_number}
162         if hit_type is not None:
163             params.update({'HITTypeId': hit_type})
164         return self._process_request('GetReviewableHITs', params,
165                                      [('HIT', HIT)])
166     @staticmethod
167     def _get_pages(page_size, total_records):
168         pages = total_records / page_size + bool(total_records % page_size)
169         return list(range(1, pages + 1))
170     def get_all_hits(self):
171         page_size = 100
172         search_rs = self.search_hits(page_size=page_size)
173         total_records = int(search_rs.TotalNumResults)
174         get_page_hits = lambda page: self.search_hits(page_size=page_size, page_number=page)
175         page_nums = self._get_pages(page_size, total_records)
176         hit_sets = itertools.imap(get_page_hits, page_nums)
177         return itertools.chain.from_iterable(hit_sets)
178     def search_hits(self, sort_by='CreationTime', sort_direction='Ascending',
179                     page_size=10, page_number=1, response_groups=None):
180         params = {'SortProperty': sort_by,
181                   'SortDirection': sort_direction,
182                   'PageSize': page_size,
183                   'PageNumber': page_number}
184         if response_groups:
185             self.build_list_params(params, response_groups, 'ResponseGroup')
186         return self._process_request('SearchHITs', params, [('HIT', HIT)])
187     def get_assignment(self, assignment_id, response_groups=None):
188         params = {'AssignmentId': assignment_id}
189         if response_groups:
190             self.build_list_params(params, response_groups, 'ResponseGroup')
191         return self._process_request('GetAssignment', params,
192                                      [('Assignment', Assignment),
193     def get_assignments(self, hit_id, status=None,
194                             sort_by<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>='SubmitTime', sort_direction='Ascending',
195                             page_size=10, page_number=1, response_groups=None):
196         params = {'HITId': hit_id,
197                   'SortProperty': sort_by,
198                   'SortDirection': sort_direction,
199                   'PageSize': page_size,
200                   'PageNumber': page_number}
201         if status is not None:
202             params['AssignmentStatus'] = status
203         if response_groups:
204             self.</b></font>build_list_params(params, response_groups, 'ResponseGroup')
205         return self._process_request('GetAssignmentsForHIT', params,
206                                      [('Assignment', Assignment)])
207     def approve_assignment(self, assignment_id, feedback=None):
208         params = {'AssignmentId': assignment_id}
209         if feedback:
210             params['RequesterFeedback'] = feedback
211         return self._process_request('ApproveAssignment', params)
212     def reject_assignment(self, assignment_id, feedback=None):
213         params = {'AssignmentId': assignment_id}
214         if feedback:
215             params['RequesterFeedback'] = feedback
216         return self._process_request('RejectAssignment', params)
217     def approve_rejected_assignment(self, assignment_id, feedback=None):
218         params = {'AssignmentId': assignment_id}
219         if feedback:
220             params['RequesterFeedback'] = feedback
221         return self._process_request('ApproveRejectedAssignment', params)
222     def get_file_upload_url(self, assignment_id, question_identifier):
223         params = {'AssignmentId': assignment_id,
224                   'QuestionIdentifier': question_identifier}
225         return self._process_request('GetFileUploadURL', params,
226                                      [('FileUploadURL', FileUploadURL)])
227     def get_hit(self, hit_id, response_groups=None):
228         params = {'HITId': hit_id}
229         if response_groups:
230             self.build_list_params(params, response_groups, 'ResponseGroup')
231         return self._process_request('GetHIT', params, [('HIT', HIT)])
232     def set_reviewing(self, hit_id, revert=None):
233         params = {'HITId': hit_id}
234         if revert:
235             params['Revert'] = revert
236         return self._process_request('SetHITAsReviewing', params)
237     def disable_hit(self, hit_id, response_groups=None):
238         params = {'HITId': hit_id}
239         if response_groups:
240             self.build_list_params(params, response_groups, 'ResponseGroup')
241         return self._process_request('DisableHIT', params)
242     def dispose_hit(self, hit_id):
243         Expire a HIT that is no longer needed.
244         The effect is identical to the HIT expiring on its own. The
245         HIT no longer appears on the Mechanical Turk web site, and no
246         new Workers are allowed to accept the HIT. Workers who have
247         accepted the HIT prior to expiration are allowed to complete
248         it or return it, or allow the assignment duration to elapse
249         (abandon the HIT). Once all remaining assignments have been
250         submitted, the expired HIT becomes"reviewable", and will be
251         returned by a call to GetReviewableHITs.
252         Increase the maximum number of assignments, or extend the
253         expiration date, of an existing HIT.
254         NOTE: If a HIT has a status of Reviewable and the HIT is
255         extended to make it Available, the HIT will not be returned by
256         GetReviewableHITs, and its submitted assignments will not be
257         returned by GetAssignmentsForHIT, until the HIT is Reviewable
258         again.  Assignment auto-approval will still happen on its
259         original schedule, even if the HIT has been extended. Be sure
260         to retrieve and approve (or reject) submitted assignments
261         before extending the HIT, if so desired.
262         Return information about the Mechanical Turk Service
263         operations and response group NOTE - this is basically useless
264         as it just returns the URL of the documentation
265         help_type: either 'Operation' or 'ResponseGroup'
266         Issues a payment of money from your account to a Worker.  To
267         be eligible for a bonus, the Worker must have submitted
268         results for one of your HITs, and have had those results
269         approved or rejected. This payment happens separately from the
270         reward you pay to the Worker when you approve the Worker's
271         assignment.  The Bonus must be passed in as an instance of the
272         Price object.
273         Block a worker from working on my tasks.
274         Unblock a worker from working on my tasks.
275         Send a text message to workers.
276         Create a new Qualification Type.
277         name: This will be visible to workers and must be unique for a
278            given requester.
279         description: description shown to workers.  Max 2000 characters.
280         status: 'Active' or 'Inactive'
281         keywords: list of keyword strings or comma separated string.
282            Max length of 1000 characters when concatenated with commas.
283         retry_delay: number of seconds after requesting a
284            qualification the worker must wait before they can ask again.
285            If not specified, workers can only request this qualification
286            once.
287         test: a QuestionForm
288         answer_key: an XML string of your answer key, for automatically
289            scored qualification tests.
290            (Consider implementing an AnswerKey class for this to support.)
291         test_duration: the number of seconds a worker has to complete the test.
292         auto_granted: if True, requests for the Qualification are granted
293            immediately.  Can't coexist with a test.
294         auto_granted_value: auto_granted qualifications are given this value.
295         """
296                                   retry_delay<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
297                                   test=None,
298                                   answer_key=None,
299                                   test_duration=None,
300                                   auto_granted=None,
301                                   auto_granted_value=None):
302         params = {'QualificationTypeId': qualification_type_id}
303         if description is not None:
304             params['Description'] = description
305         if status is not None:
306             params['QualificationTypeStatus'] = status
307         if retry_delay is not None:
308             params['RetryDelayInSeconds'] = retry_delay
309         if</b></font> test is not None:
310             assert(isinstance(test, QuestionForm))
311             params['Test'] = test.get_as_xml()
312         if test_duration is not None:
313             params['TestDurationInSeconds'] = test_duration
314         if answer_key is not None:
315                 params['AnswerKey'] = answer_key  # xml
316             else:
317                 ra<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ise TypeError
318         if auto_granted is not None:
319             params['AutoGranted'] = auto_granted
320         if auto_granted_value is not None:
321             params['AutoGrantedValue'] = auto_granted_value
322         return self._process_request(</b></font>'UpdateQualificationType', params,
323                                      [('QualificationType', QualificationType)])
324     def dispose_qualification_type(self, qualification_type_id):
325         params = {'QualificationTypeId': qualification_type_id}
326         return self._process_request('DisposeQualificationType', params)
327     def search_qualification_types(self, query=None, sort_by='Name',
328                                    sort_direction='Ascending', page_size=10,
329                                    page_number=1, must_be_requestable=True,
330                                    must_be_owned_by_caller=True):
331         params = {'Query': query,
332                   'SortProperty': sort_by,
333                   'SortDirection': sort_direction,
334                   'PageSize': page_size,
335                   'PageNumber': page_number,
336                   'MustBeRequestable': must_be_requestable,
337                   'MustBeOwnedByCaller': must_be_owned_by_caller}
338         return self._process_request('SearchQualificationTypes', params,
339                     [('QualificationType', QualificationType)])
340     def get_qualification_requests(self, qualification_type_id,
341                                    sort_by='Expiration',
342                                    sort_direction='Ascending', page_size=10,
343                                    page_number=1):
344         params = {'QualificationTypeId': qualification_type_id,
345                   'SortProperty': sort_by,
346                   'SortDirection': sort_direction,
347                   'PageSize': page_size,
348                   'PageNumber': page_number}
349         return self._process_request('GetQualificationRequests', params,
350                     [('QualificationRequest', QualificationRequest)])
351     def grant_qualification(self, qualification_request_id, integer_value=1):
352         params = {'QualificationRequestId': qualification_request_id,
353                   'IntegerValue': integer_value}
354         return self._process_request('GrantQualification', params)
355     def revoke_qualification(self, subject_id, qualification_type_id,
356                              reason=None):
357         params = {'SubjectId': subject_id,
358                   'QualificationTypeId': qualification_type_id,
359                   'Reason': reason}
360         return self._process_request('RevokeQualification', params)
361     def assign_qualification(self, qualification_type_id, worker_id,
362                              value=1, send_notification=True):
363         params = {'QualificationTypeId': qualification_type_id,
364                   'WorkerId' : worker_id,
365                   'IntegerValue' : value,
366                   'SendNotification' : send_notification}
367         return self._process_request('AssignQualification', params)
368     def get_qualification_score(self, qualification_type_id, worker_id):
369         params = {'QualificationTypeId' : qualification_type_id,
370                   'SubjectId' : worker_id}
371         return self._process_request('GetQualificationScore', params,
372                     [('Qualification', Qualification)])
373     def update_qualification_score(self, qualification_type_id, worker_id,
374                                    value):
375         params = {'QualificationTypeId' : qualification_type_id,
376                   'SubjectId' : worker_id,
377                   'IntegerValue' : value}
378         return self._process_request('UpdateQualificationScore', params)
379     def _process_request(self, request_type, params, marker_elems=None):
380         """
381         Helper to process the xml response from AWS
382         """
383         params['Operation'] = request_type
384         response = self.make_request(None, params, verb='POST')
385         return self._process_response(response, marker_elems)
386     def _process_response(self, response, marker_elems=None):
387         """
388         Helper to process the xml response from AWS
389         """
390         body = response.read()
391         if self.debug == 2:
392             print(body)
393         if '&lt;Errors&gt;' not in body.decode('utf-8'):
394             rs = ResultSet(marker_elems)
395             h = handler.XmlHandler(rs, self)
396             xml.sax.parseString(body, h)
397             return rs
398         else:
399             raise MTurkRequestError(response.status, response.reason, body)
400     @staticmethod
401     def get_keywords_as_string(keywords):
402         """
403         Returns a comma+space-separated string of keywords from either
404         a list or a string
405         """
406         if isinstance(keywords, list):
407             keywords = ', '.join(keywords)
408         if isinstance(keywords, str):
409             final_keywords = keywords
410         elif isinstance(keywords, unicode):
411             final_keywords = keywords.encode('utf-8')
412         elif keywords is None:
413             final_keywords = ""
414         else:
415             raise TypeError("keywords argument must be a string or a list of strings; got a %s" % type(keywords))
416         return final_keywords
417     @staticmethod
418     def get_price_as_price(reward):
419         """
420         Returns a Price data structure from either a float or a Price
421         """
422         if isinstance(reward, Price):
423             final_price = reward
424         else:
425             final_price = Price(reward)
426         return final_price
427     @staticmethod
428     def duration_as_seconds(duration):
429         if isinstance(duration, datetime.timedelta):
430             duration = duration.days * 86400 + duration.seconds
431         try:
432             duration = int(duration)
433         except TypeError:
434             raise TypeError("Duration must be a timedelta or int-castable, got %s" % type(duration))
435         return duration
436 class BaseAutoResultElement(object):
437     """
438     Base class to automatically add attributes when parsing XML
439     """
440     def __init__(self, connection):
441         pass
442     def startElement(self, name, attrs, connection):
443         return None
444     def endElement(self, name, value, connection):
445         setattr(self, name, value)
446 class HIT(BaseAutoResultElement):
447     """
448     Class to extract a HIT structure from a response (used in ResultSet)
449     Will have attributes named as per the Developer Guide,
450     e.g. HITId, HITTypeId, CreationTime
451     """
452     def _has_expired(self):
453         expired = False
454         if hasattr(self, 'Expiration'):
455             now = datetime.datetime.utcnow()
456             expiration = datetime.datetime.strptime(self.Expiration, '%Y-%m-%dT%H:%M:%SZ')
457             expired = (now &gt;= expiration)
458         else:
459             raise ValueError("ERROR: Request for expired property, but no Expiration in HIT!")
460         return expired
461     expired = property(_has_expired)
462 class FileUploadURL(BaseAutoResultElement):
463     """
464     Class to extract an FileUploadURL structure from a response
465     """
466     pass
467 class HITTypeId(BaseAutoResultElement):
468     """
469     Class to extract an HITTypeId structure from a response
470     """
471     pass
472 class Qualification(BaseAutoResultElement):
473     """
474     Class to extract an Qualification structure from a response (used in
475     ResultSet)
476     Will have attributes named as per the Developer Guide such as
477     QualificationTypeId, IntegerValue. Does not seem to contain GrantTime.
478     """
479     pass
480 class QualificationType(BaseAutoResultElement):
481     """
482     Class to extract an QualificationType structure from a response (used in
483     ResultSet)
484     Will have attributes named as per the Developer Guide,
485     e.g. QualificationTypeId, CreationTime, Name, etc
486     """
487     pass
488 class QualificationRequest(BaseAutoResultElement):
489     """
490     Class to extract an QualificationRequest structure from a response (used in
491     ResultSet)
492     Will have attributes named as per the Developer Guide,
493     e.g. QualificationRequestId, QualificationTypeId, SubjectId, etc
494     """
495     def __init__(self, connection):
496         super(QualificationRequest, self).__init__(connection)
497         self.answers = []
498     def endElement(self, name, value, connection):
499         if name == 'Answer':
500             answer_rs = ResultSet([('Answer', QuestionFormAnswer)])
501             h = handler.XmlHandler(answer_rs, connection)
502             value = connection.get_utf8able_str(value)
503             xml.sax.parseString(value, h)
504             self.answers.append(answer_rs)
505         else:
506             super(QualificationRequest, self).endElement(name, value, connection)
507 class Assignment(BaseAutoResultElement):
508     """
509     Class to extract an Assignment structure from a response (used in
510     ResultSet)
511     Will have attributes named as per the Developer Guide,
512     e.g. AssignmentId, WorkerId, HITId, Answer, etc
513     """
514     def __init__(self, connection):
515         super(Assignment, self).__init__(connection)
516         self.answers = []
517     def endElement(self, name, value, connection):
518         if name == 'Answer':
519             answer_rs = ResultSet([('Answer', QuestionFormAnswer)])
520             h = handler.XmlHandler(answer_rs, connection)
521             value = connection.get_utf8able_str(value)
522             xml.sax.parseString(value, h)
523             self.answers.append(answer_rs)
524         else:
525             super(Assignment, self).endElement(name, value, connection)
526 class QuestionFormAnswer(BaseAutoResultElement):
527     """
528     Class to extract Answers from inside the embedded XML
529     QuestionFormAnswers element inside the Answer element which is
530     part of the Assignment and QualificationRequest structures
531     A QuestionFormAnswers element contains an Answer element for each
532     question in the HIT or Qualification test for which the Worker
533     provided an answer. Each Answer contains a QuestionIdentifier
534     element whose value corresponds to the QuestionIdentifier of a
535     Question in the QuestionForm. See the QuestionForm data structure
536     for more information about questions and answer specifications.
537     If the question expects a free-text answer, the Answer element
538     contains a FreeText element. This element contains the Worker's
539     answer
540     *NOTE* - currently really only supports free-text and selection answers
541     """
542     def __init__(self, connection):
543         super(QuestionFormAnswer, self).__init__(connection)
544         self.fields = []
545         self.qid = None
546     def endElement(self, name, value, connection):
547         if name == 'QuestionIdentifier':
548             self.qid = value
549         elif name in ['FreeText', 'SelectionIdentifier', 'OtherSelectionText'] and self.qid:
550             self.fields.append(value)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
