<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for layer1_9.py &amp; connection_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for layer1_9.py &amp; connection_2.py
      </h3>
<h1 align="center">
        9.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>layer1_9.py (21.40351%)<th>connection_2.py (6.0098524%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(291-343)<td><a href="#" name="0">(721-739)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(359-364)<td><a href="#" name="1">(182-186)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(100-145)<td><a href="#" name="2">(378-414)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(147-152)<td><a href="#" name="3">(750-759)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>layer1_9.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import boto
2 from boto.connection import AWSQueryConnection
3 from boto.regioninfo import RegionInfo
4 from boto.exception import JSONResponseError
5 from boto.cloudtrail import exceptions
6 from boto.compat import json
7 class CloudTrailConnection(AWSQueryConnection):
8     APIVersion = "2013-11-01"
9     DefaultRegionName = "us-east-1"
10     DefaultRegionEndpoint = "cloudtrail.us-east-1.amazonaws.com"
11     ServiceName = "CloudTrail"
12     TargetPrefix = "com.amazonaws.cloudtrail.v20131101.CloudTrail_20131101"
13     ResponseError = JSONResponseError
14     _faults = {
15         "InvalidMaxResultsException": exceptions.InvalidMaxResultsException,
16         "InvalidSnsTopicNameException": exceptions.InvalidSnsTopicNameException,
17         "InvalidS3BucketNameException": exceptions.InvalidS3BucketNameException,
18         "TrailAlreadyExistsException": exceptions.TrailAlreadyExistsException,
19         "InvalidTimeRangeException": exceptions.InvalidTimeRangeException,
20         "InvalidLookupAttributesException": exceptions.InvalidLookupAttributesException,
21         "InsufficientSnsTopicPolicyException": exceptions.InsufficientSnsTopicPolicyException,
22         "InvalidCloudWatchLogsLogGroupArnException": exceptions.InvalidCloudWatchLogsLogGroupArnException,
23         "InvalidCloudWatchLogsRoleArnException": exceptions.InvalidCloudWatchLogsRoleArnException,
24         "InvalidTrailNameException": exceptions.InvalidTrailNameException,
25         "CloudWatchLogsDeliveryUnavailableException": exceptions.CloudWatchLogsDeliveryUnavailableException,
26         "TrailNotFoundException": exceptions.TrailNotFoundException,
27         "S3BucketDoesNotExistException": exceptions.S3BucketDoesNotExistException,
28         "InvalidNextTokenException": exceptions.InvalidNextTokenException,
29         "InvalidS3PrefixException": exceptions.InvalidS3PrefixException,
30         "MaximumNumberOfTrailsExceededException": exceptions.MaximumNumberOfTrailsExceededException,
31         "InsufficientS3BucketPolicyException": exceptions.InsufficientS3BucketPolicyException,
32     }
33     def __init__(self, **kwargs):
34         region = kwargs.pop('region', None)
35         if not region:
36             region = RegionInfo(self, self.DefaultRegionName,
37                                 self.DefaultRegionEndpoint)
38         if 'host' not in kwargs or kwargs['host'] is None:
39             kwargs['host'] = region.endpoint
40         super(CloudTrailConnection, self).__init__(**kwargs)
41         self.region = region
42 <a name="2"></a>    def _required_auth_capability(self):
43         return ['hmac-v4']
44     def create_trail(self, name, s3_bucket_name, s3_key_prefix<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
45                      sns_topic_name=None, include_global_service_events=None,
46                      cloud_watch_logs_log_group_arn=None,
47                      cloud_watch_logs_role_arn=None):
48         params = {'Name': name, 'S3BucketName': s3_bucket_name, }
49         if s3_key_prefix is not None:
50             params['S3KeyPrefix'] = s3_key_prefix
51 <a name="3"></a>        if sns_topic_name is not None:
52             params[</b></font>'SnsTopicName'] = sns_topic_name
53         if include_global_service_events is not None:
54             params['IncludeGlobalServiceEvents'] =<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b> include_global_service_events
55         if cloud_watch_logs_log_group_arn is not None:
56             params['CloudWatchLogsLogGroupArn'] = cloud_watch_logs_log_group_arn
57         if cloud_watch_logs_role_arn is not None:
58             params['CloudWatchLogsRoleArn'] = cloud_watch_logs_role_arn
59         return self.make_request(</b></font>action='CreateTrail',
60                                  body=json.dumps(params))
61     def delete_trail(self, name):
62         params = {'Name': name, }
63         return self.make_request(action='DeleteTrail',
64                                  body=json.dumps(params))
65     def describe_trails(self, trail_name_list=None):
66         params = {}
67         if trail_name_list is not None:
68             params['trailNameList'] = trail_name_list
69         return self.make_request(action='DescribeTrails',
70                                  body=json.dumps(params))
71     def get_trail_status(self, name):
72         params = {'Name': name, }
73         return self.make_request(action='GetTrailStatus',
74                                  body=json.dumps(params))
75     def lookup_events(self, lookup_attributes=None, start_time=None,
76                       end_time=None, max_results=None, next_token=None):
77         params = {}
78         if lookup_attributes is not None:
79             params['LookupAttributes'] = lookup_attributes
80         if start_time is not None:
81             params['StartTime'] = start_time
82         if end_time is not None:
83             params['EndTime'] = end_time
84         if max_results is not None:
85             params['MaxResults'] = max_results
86         if next_token is not None:
87             params['NextToken'] = next_token
88         return self.make_request(action='LookupEvents',
89                                  body=json.dumps(params))
90     def start_logging(self, name):
91         params = {'Name': name, }
92         return self.make_request(action='StartLogging',
93                                  body=json.dumps(params))
94     def stop_logging(self, name):
95         params = {'Name': name, }
96 <a name="0"></a>        return self.make_request(action='StopLogging',
97                                  body=json.dumps(params))
98     def update_trail(self, name, s3_bucket_name<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, s3_key_prefix=None,
99                      sns_topic_name=None, include_global_service_events=None,
100                      cloud_watch_logs_log_group_arn=None,
101                      cloud_watch_logs_role_arn=None):
102         params = {'Name': name, }
103         if s3_bucket_name is not None:
104             params['S3BucketName'] = s3_bucket_name
105         if s3_key_prefix is not None:
106             params['S3KeyPrefix'] = s3_key_prefix
107         if sns_topic_name is not None:
108             params['SnsTopicName'] = sns_topic_name
109         if</b></font> include_global_service_events is not None:
110             params['IncludeGlobalServiceEvents'] = include_global_service_events
111         if cloud_watch_logs_log_group_arn is not None:
112             params['CloudWatchLogsLogGroupArn'] = cloud_watch_logs_log_group_arn
113         if cloud_watch_logs_role_arn is not None:
114             params['CloudWatchLogsRoleArn'] = cloud_watch_logs_role_arn
115         return self.make_request(action='UpdateTrail',
116                                  body=json.dumps(params))
117     def make_request(self, action, body):
118         headers = {
119             'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
120             'Host': self.region.endpoint,
121 <a name="1"></a>            'Content-Type': 'application/x-amz-json-1.1',
122             'Content-Length': str(len(body)),
123         }
124         http_request <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.build_base_http_request(
125             method='POST', path='/', auth_path='/', params={},
126             headers=headers, data=body)
127         response = self._mexe(http_request, sender=None,
128                               override_num_retries=10)
129         response_body =</b></font> response.read().decode('utf-8')
130         boto.log.debug(response_body)
131         if response.status == 200:
132             if response_body:
133                 return json.loads(response_body)
134         else:
135             json_body = json.loads(response_body)
136             fault_name = json_body.get('__type', None)
137             exception_class = self._faults.get(fault_name, self.ResponseError)
138             raise exception_class(response.status, response.reason,
139                                   body=json_body)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>connection_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import xml.sax
2 import datetime
3 import itertools
4 from boto import handler
5 from boto import config
6 from boto.mturk.price import Price
7 import boto.mturk.notification
8 from boto.connection import AWSQueryConnection
9 from boto.exception import EC2ResponseError
10 from boto.resultset import ResultSet
11 from boto.mturk.question import QuestionForm, ExternalQuestion, HTMLQuestion
12 class MTurkRequestError(EC2ResponseError):
13     "Error for MTurk Requests"
14 class MTurkConnection(AWSQueryConnection):
15     APIVersion = '2014-08-15'
16     def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
17                  is_secure=True, port=None, proxy=None, proxy_port=None,
18                  proxy_user=None, proxy_pass=None,
19                  host=None, debug=0,
20                  https_connection_factory=None, security_token=None,
21                  profile_name=None):
22         if not host:
23             if config.has_option('MTurk', 'sandbox') and config.get('MTurk', 'sandbox') == 'True':
24                 host = 'mechanicalturk.sandbox.amazonaws.com'
25             else:
26                 host = 'mechanicalturk.amazonaws.com'
27         self.debug = debug
28         super(MTurkConnection, self).__init__(aws_access_key_id,
29                                     aws_secret_access_key,
30                                     is_secure, port, proxy, proxy_port,
31                                     proxy_user, proxy_pass, host, debug,
32                                     https_connection_factory,
33                                     security_token=security_token,
34                                     profile_name=profile_name)
35     def _required_auth_capability(self):
36         return ['mturk']
37     def get_account_balance(self):
38         params = {}
39         return self._process_request('GetAccountBalance', params,
40                                      [('AvailableBalance', Price),
41                                       ('OnHoldBalance', Price)])
42     def register_hit_type(self, title, description, reward, duration,
43                           keywords=None, approval_delay=None, qual_req=None):
44         params = dict(
45             Title=title,
46             Description=description,
47             AssignmentDurationInSeconds=self.duration_as_seconds(duration),
48             )
49         params.update(MTurkConnection.get_price_as_price(reward).get_as_params('Reward'))
50         if keywords:
51             params['Keywords'] = self.get_keywords_as_string(keywords)
52         if approval_delay is not None:
53             d = self.duration_as_seconds(approval_delay)
54             params['AutoApprovalDelayInSeconds'] = d
55         if qual_req is not None:
56             params.update(qual_req.get_as_params())
57         return self._process_request('RegisterHITType', params,
58                                      [('HITTypeId', HITTypeId)])
59     def set_email_notification(self, hit_type, email, event_types=None):
60         return self._set_notification(hit_type, 'Email', email,
61                                       'SetHITTypeNotification', event_types)
62     def set_rest_notification(self, hit_type, url, event_types=None):
63         return self._set_notification(hit_type, 'REST', url,
64                                       'SetHITTypeNotification', event_types)
65     def set_sqs_notification(self, hit_type, queue_url, event_types=None):
66         return self._set_notification(hit_type, "SQS", queue_url,
67                                       'SetHITTypeNotification', event_types)
68     def send_test_event_notification(self, hit_type, url,
69                                      event_types=None,
70                                      test_event_type='Ping'):
71         return self._set_notification(hit_type, 'REST', url,
72                                       'SendTestEventNotification',
73                                       event_types, test_event_type)
74     def _set_notification(self, hit_type, transport,
75                           destination, request_type,
76                           event_types=None, test_event_type=None):
77         params = {'HITTypeId': hit_type}
78         notification_params = {'Destination': destination,
79                                'Transport': transport,
80                                'Version': boto.mturk.notification.NotificationMessage.NOTIFICATION_VERSION,
81                                'Active': True,
82                                }
83         if event_types:
84             self.build_list_params(notification_params, event_types,
85                                    'EventType')
86         notification_rest_params = {}
87         num = 1
88         for key in notification_params:
89             notification_rest_params['Notification.%d.%s' % (num, key)] = notification_params[key]
90         params.update(notification_rest_params)
91         if test_event_type:
92             params.update({'TestEventType': test_event_type})
93 <a name="1"></a>        return self._process_request(request_type, params)
94     def create_hit(self, hit_type=None, question=None, hit_layout=None,
95                    lifetime<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=datetime.timedelta(days=7),
96                    max_assignments=1,
97                    title=None, description=None, keywords=None,
98                    reward=None, duration=datetime.timedelta(days=7),
99                    approval_delay=None, annotation=</b></font>None,
100                    questions=None, qualifications=None,
101                    layout_params=None, response_groups=None):
102         params = {'LifetimeInSeconds':
103                       self.duration_as_seconds(lifetime),
104                   'MaxAssignments': max_assignments,
105                  }
106         neither = question is None and questions is None
107         if hit_layout is None:
108             both = question is not None and questions is not None
109             if neither or both:
110                 raise ValueError("Must specify question (single Question instance) or questions (list or QuestionForm instance), but not both")
111             if question:
112                 questions = [question]
113             question_param = QuestionForm(questions)
114             if isinstance(question, QuestionForm):
115                 question_param = question
116             elif isinstance(question, ExternalQuestion):
117                 question_param = question
118             elif isinstance(question, HTMLQuestion):
119                 question_param = question
120             params['Question'] = question_param.get_as_xml()
121         else:
122             if not neither:
123                 raise ValueError("Must not specify question (single Question instance) or questions (list or QuestionForm instance) when specifying hit_layout")
124             params['HITLayoutId'] = hit_layout
125             if layout_params:
126                 params.update(layout_params.get_as_params())
127         if hit_type:
128             params['HITTypeId'] = hit_type
129         else:
130             final_keywords = MTurkConnection.get_keywords_as_string(keywords)
131             final_price = MTurkConnection.get_price_as_price(reward)
132             final_duration = self.duration_as_seconds(duration)
133             additional_params = dict(
134                 Title=title,
135                 Description=description,
136                 Keywords=final_keywords,
137                 AssignmentDurationInSeconds=final_duration,
138                 )
139             additional_params.update(final_price.get_as_params('Reward'))
140             if approval_delay is not None:
141                 d = self.duration_as_seconds(approval_delay)
142                 additional_params['AutoApprovalDelayInSeconds'] = d
143             params.update(additional_params)
144         if annotation is not None:
145             params['RequesterAnnotation'] = annotation
146         if qualifications is not None:
147             params.update(qualifications.get_as_params())
148         if response_groups:
149             self.build_list_params(params, response_groups, 'ResponseGroup')
150         return self._process_request('CreateHIT', params, [('HIT', HIT)])
151     def change_hit_type_of_hit(self, hit_id, hit_type):
152         params = {'HITId': hit_id,
153                   'HITTypeId': hit_type}
154         return self._process_request('ChangeHITTypeOfHIT', params)
155     def get_reviewable_hits(self, hit_type=None, status='Reviewable',
156                             sort_by='Expiration', sort_direction='Ascending',
157                             page_size=10, page_number=1):
158         params = {'Status': status,
159                   'SortProperty': sort_by,
160                   'SortDirection': sort_direction,
161                   'PageSize': page_size,
162                   'PageNumber': page_number}
163         if hit_type is not None:
164             params.update({'HITTypeId': hit_type})
165         return self._process_request('GetReviewableHITs', params,
166                                      [('HIT', HIT)])
167     @staticmethod
168     def _get_pages(page_size, total_records):
169         pages = total_records / page_size + bool(total_records % page_size)
170         return list(range(1, pages + 1))
171     def get_all_hits(self):
172         page_size = 100
173         search_rs = self.search_hits(page_size=page_size)
174         total_records = int(search_rs.TotalNumResults)
175         get_page_hits = lambda page: self.search_hits(page_size=page_size, page_number=page)
176         page_nums = self._get_pages(page_size, total_records)
177         hit_sets = itertools.imap(get_page_hits, page_nums)
178         return itertools.chain.from_iterable(hit_sets)
179     def search_hits(self, sort_by='CreationTime', sort_direction='Ascending',
180                     page_size=10, page_number=1, response_groups=None):
181         params = {'SortProperty': sort_by,
182                   'SortDirection': sort_direction,
183                   'PageSize': page_size,
184                   'PageNumber': page_number}
185         if response_groups:
186             self.build_list_params(params, response_groups, 'ResponseGroup')
187         return self._process_request('SearchHITs', params, [('HIT', HIT)])
188     def get_assignment(self, assignment_id, response_groups=None):
189         params = {'AssignmentId': assignment_id}
190         if response_groups:
191             self.build_list_params(params, response_groups, 'ResponseGroup')
192         return self._process_request('GetAssignment', params,
193                                      [('Assignment', Assignment),
194 <a name="2"></a>                                      ('HIT', HIT)])
195     def get_assignments(self, hit_id, status=None,
196                             sort_by<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>='SubmitTime', sort_direction='Ascending',
197                             page_size=10, page_number=1, response_groups=None):
198         params = {'HITId': hit_id,
199                   'SortProperty': sort_by,
200                   'SortDirection': sort_direction,
201                   'PageSize': page_size,
202                   'PageNumber': page_number}
203         if status is not None:
204             params['AssignmentStatus'] = status
205         if response_groups:
206             self.</b></font>build_list_params(params, response_groups, 'ResponseGroup')
207         return self._process_request('GetAssignmentsForHIT', params,
208                                      [('Assignment', Assignment)])
209     def approve_assignment(self, assignment_id, feedback=None):
210         params = {'AssignmentId': assignment_id}
211         if feedback:
212             params['RequesterFeedback'] = feedback
213         return self._process_request('ApproveAssignment', params)
214     def reject_assignment(self, assignment_id, feedback=None):
215         params = {'AssignmentId': assignment_id}
216         if feedback:
217             params['RequesterFeedback'] = feedback
218         return self._process_request('RejectAssignment', params)
219     def approve_rejected_assignment(self, assignment_id, feedback=None):
220         params = {'AssignmentId': assignment_id}
221         if feedback:
222             params['RequesterFeedback'] = feedback
223         return self._process_request('ApproveRejectedAssignment', params)
224     def get_file_upload_url(self, assignment_id, question_identifier):
225         params = {'AssignmentId': assignment_id,
226                   'QuestionIdentifier': question_identifier}
227         return self._process_request('GetFileUploadURL', params,
228                                      [('FileUploadURL', FileUploadURL)])
229     def get_hit(self, hit_id, response_groups=None):
230         params = {'HITId': hit_id}
231         if response_groups:
232             self.build_list_params(params, response_groups, 'ResponseGroup')
233         return self._process_request('GetHIT', params, [('HIT', HIT)])
234     def set_reviewing(self, hit_id, revert=None):
235         params = {'HITId': hit_id}
236         if revert:
237             params['Revert'] = revert
238         return self._process_request('SetHITAsReviewing', params)
239     def disable_hit(self, hit_id, response_groups=None):
240         params = {'HITId': hit_id}
241         if response_groups:
242             self.build_list_params(params, response_groups, 'ResponseGroup')
243         return self._process_request('DisableHIT', params)
244     def dispose_hit(self, hit_id):
245         Expire a HIT that is no longer needed.
246         The effect is identical to the HIT expiring on its own. The
247         HIT no longer appears on the Mechanical Turk web site, and no
248         new Workers are allowed to accept the HIT. Workers who have
249         accepted the HIT prior to expiration are allowed to complete
250         it or return it, or allow the assignment duration to elapse
251         (abandon the HIT). Once all remaining assignments have been
252         submitted, the expired HIT becomes"reviewable", and will be
253         returned by a call to GetReviewableHITs.
254         Increase the maximum number of assignments, or extend the
255         expiration date, of an existing HIT.
256         NOTE: If a HIT has a status of Reviewable and the HIT is
257         extended to make it Available, the HIT will not be returned by
258         GetReviewableHITs, and its submitted assignments will not be
259         returned by GetAssignmentsForHIT, until the HIT is Reviewable
260         again.  Assignment auto-approval will still happen on its
261         original schedule, even if the HIT has been extended. Be sure
262         to retrieve and approve (or reject) submitted assignments
263         before extending the HIT, if so desired.
264         Return information about the Mechanical Turk Service
265         operations and response group NOTE - this is basically useless
266         as it just returns the URL of the documentation
267         help_type: either 'Operation' or 'ResponseGroup'
268         Issues a payment of money from your account to a Worker.  To
269         be eligible for a bonus, the Worker must have submitted
270         results for one of your HITs, and have had those results
271         approved or rejected. This payment happens separately from the
272         reward you pay to the Worker when you approve the Worker's
273         assignment.  The Bonus must be passed in as an instance of the
274         Price object.
275         Block a worker from working on my tasks.
276         Unblock a worker from working on my tasks.
277         Send a text message to workers.
278         Create a new Qualification Type.
279         name: This will be visible to workers and must be unique for a
280            given requester.
281         description: description shown to workers.  Max 2000 characters.
282         status: 'Active' or 'Inactive'
283         keywords: list of keyword strings or comma separated string.
284            Max length of 1000 characters when concatenated with commas.
285         retry_delay: number of seconds after requesting a
286            qualification the worker must wait before they can ask again.
287            If not specified, workers can only request this qualification
288            once.
289         test: a QuestionForm
290         answer_key: an XML string of your answer key, for automatically
291            scored qualification tests.
292            (Consider implementing an AnswerKey class for this to support.)
293         test_duration: the number of seconds a worker has to complete the test.
294         auto_granted: if True, requests for the Qualification are granted
295            immediately.  Can't coexist with a test.
296         auto_granted_value: auto_granted qualifications are given this value.
297                                   retry_delay<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
298                                   test=None,
299                                   answer_key=None,
300                                   test_duration=None,
301                                   auto_granted=None,
302                                   auto_granted_value=None):
303         params = {'QualificationTypeId': qualification_type_id}
304         if description is not None:
305             params['Description'] = description
306         if status is not None:
307             params['QualificationTypeStatus'] = status
308         if retry_delay is not None:
309             params['RetryDelayInSeconds'] = retry_delay
310         if</b></font> test is not None:
311             assert(isinstance(test, QuestionForm))
312             params['Test'] = test.get_as_xml()
313         if test_duration is not None:
314             params['TestDurationInSeconds'] = test_duration
315         if answer_key is not None:
316 <a name="3"></a>            if isinstance(answer_key, basestring):
317                 params['AnswerKey'] = answer_key  # xml
318             else:
319                 ra<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ise TypeError
320         if auto_granted is not None:
321             params['AutoGranted'] = auto_granted
322         if auto_granted_value is not None:
323             params['AutoGrantedValue'] = auto_granted_value
324         return self._process_request(</b></font>'UpdateQualificationType', params,
325                                      [('QualificationType', QualificationType)])
326     def dispose_qualification_type(self, qualification_type_id):
327         params = {'QualificationTypeId': qualification_type_id}
328         return self._process_request('DisposeQualificationType', params)
329     def search_qualification_types(self, query=None, sort_by='Name',
330                                    sort_direction='Ascending', page_size=10,
331                                    page_number=1, must_be_requestable=True,
332                                    must_be_owned_by_caller=True):
333         params = {'Query': query,
334                   'SortProperty': sort_by,
335                   'SortDirection': sort_direction,
336                   'PageSize': page_size,
337                   'PageNumber': page_number,
338                   'MustBeRequestable': must_be_requestable,
339                   'MustBeOwnedByCaller': must_be_owned_by_caller}
340         return self._process_request('SearchQualificationTypes', params,
341                     [('QualificationType', QualificationType)])
342     def get_qualification_requests(self, qualification_type_id,
343                                    sort_by='Expiration',
344                                    sort_direction='Ascending', page_size=10,
345                                    page_number=1):
346         params = {'QualificationTypeId': qualification_type_id,
347                   'SortProperty': sort_by,
348                   'SortDirection': sort_direction,
349                   'PageSize': page_size,
350                   'PageNumber': page_number}
351         return self._process_request('GetQualificationRequests', params,
352                     [('QualificationRequest', QualificationRequest)])
353     def grant_qualification(self, qualification_request_id, integer_value=1):
354         params = {'QualificationRequestId': qualification_request_id,
355                   'IntegerValue': integer_value}
356         return self._process_request('GrantQualification', params)
357     def revoke_qualification(self, subject_id, qualification_type_id,
358                              reason=None):
359         params = {'SubjectId': subject_id,
360                   'QualificationTypeId': qualification_type_id,
361                   'Reason': reason}
362         return self._process_request('RevokeQualification', params)
363     def assign_qualification(self, qualification_type_id, worker_id,
364                              value=1, send_notification=True):
365         params = {'QualificationTypeId': qualification_type_id,
366                   'WorkerId' : worker_id,
367                   'IntegerValue' : value,
368                   'SendNotification' : send_notification}
369         return self._process_request('AssignQualification', params)
370     def get_qualification_score(self, qualification_type_id, worker_id):
371         params = {'QualificationTypeId' : qualification_type_id,
372                   'SubjectId' : worker_id}
373         return self._process_request('GetQualificationScore', params,
374                     [('Qualification', Qualification)])
375     def update_qualification_score(self, qualification_type_id, worker_id,
376                                    value):
377         params = {'QualificationTypeId' : qualification_type_id,
378                   'SubjectId' : worker_id,
379                   'IntegerValue' : value}
380         return self._process_request('UpdateQualificationScore', params)
381     def _process_request(self, request_type, params, marker_elems=None):
382         params['Operation'] = request_type
383         response = self.make_request(None, params, verb='POST')
384         return self._process_response(response, marker_elems)
385     def _process_response(self, response, marker_elems=None):
386         body = response.read()
387         if self.debug == 2:
388             print(body)
389         if '&lt;Errors&gt;' not in body.decode('utf-8'):
390             rs = ResultSet(marker_elems)
391             h = handler.XmlHandler(rs, self)
392             xml.sax.parseString(body, h)
393             return rs
394         else:
395             raise MTurkRequestError(response.status, response.reason, body)
396     @staticmethod
397     def get_keywords_as_string(keywords):
398         if isinstance(keywords, list):
399             keywords = ', '.join(keywords)
400         if isinstance(keywords, str):
401             final_keywords = keywords
402         elif isinstance(keywords, unicode):
403             final_keywords = keywords.encode('utf-8')
404         elif keywords is None:
405             final_keywords = ""
406         else:
407             raise TypeError("keywords argument must be a string or a list of strings; got a %s" % type(keywords))
408         return final_keywords
409     @staticmethod
410     def get_price_as_price(reward):
411         if isinstance(reward, Price):
412             final_price = reward
413         else:
414             final_price = Price(reward)
415         return final_price
416     @staticmethod
417     def duration_as_seconds(duration):
418         if isinstance(duration, datetime.timedelta):
419             duration = duration.days * 86400 + duration.seconds
420         try:
421             duration = int(duration)
422         except TypeError:
423             raise TypeError("Duration must be a timedelta or int-castable, got %s" % type(duration))
424         return duration
425 class BaseAutoResultElement(object):
426     def __init__(self, connection):
427         pass
428     def startElement(self, name, attrs, connection):
429         return None
430     def endElement(self, name, value, connection):
431         setattr(self, name, value)
432 class HIT(BaseAutoResultElement):
433     def _has_expired(self):
434         expired = False
435         if hasattr(self, 'Expiration'):
436             now = datetime.datetime.utcnow()
437             expiration = datetime.datetime.strptime(self.Expiration, '%Y-%m-%dT%H:%M:%SZ')
438             expired = (now &gt;= expiration)
439         else:
440             raise ValueError("ERROR: Request for expired property, but no Expiration in HIT!")
441         return expired
442     expired = property(_has_expired)
443 class FileUploadURL(BaseAutoResultElement):
444     pass
445 class HITTypeId(BaseAutoResultElement):
446     pass
447 class Qualification(BaseAutoResultElement):
448     pass
449 class QualificationType(BaseAutoResultElement):
450     pass
451 class QualificationRequest(BaseAutoResultElement):
452     def __init__(self, connection):
453         super(QualificationRequest, self).__init__(connection)
454         self.answers = []
455     def endElement(self, name, value, connection):
456         if name == 'Answer':
457             answer_rs = ResultSet([('Answer', QuestionFormAnswer)])
458             h = handler.XmlHandler(answer_rs, connection)
459             value = connection.get_utf8able_str(value)
460             xml.sax.parseString(value, h)
461             self.answers.append(answer_rs)
462         else:
463             super(QualificationRequest, self).endElement(name, value, connection)
464 class Assignment(BaseAutoResultElement):
465     def __init__(self, connection):
466         super(Assignment, self).__init__(connection)
467         self.answers = []
468     def endElement(self, name, value, connection):
469         if name == 'Answer':
470             answer_rs = ResultSet([('Answer', QuestionFormAnswer)])
471             h = handler.XmlHandler(answer_rs, connection)
472             value = connection.get_utf8able_str(value)
473             xml.sax.parseString(value, h)
474             self.answers.append(answer_rs)
475         else:
476             super(Assignment, self).endElement(name, value, connection)
477 class QuestionFormAnswer(BaseAutoResultElement):
478     def __init__(self, connection):
479         super(QuestionFormAnswer, self).__init__(connection)
480         self.fields = []
481         self.qid = None
482     def endElement(self, name, value, connection):
483         if name == 'QuestionIdentifier':
484             self.qid = value
485         elif name in ['FreeText', 'SelectionIdentifier', 'OtherSelectionText'] and self.qid:
486             self.fields.append(value)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
