<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for layer1_9.py &amp; connection_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for layer1_9.py &amp; connection_2.py
      </h3>
<h1 align="center">
        9.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>layer1_9.py (21.40351%)<th>connection_2.py (6.0098524%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(291-343)<td><a href="#" name="0">(721-739)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(359-364)<td><a href="#" name="1">(182-186)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(100-145)<td><a href="#" name="2">(378-414)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(147-152)<td><a href="#" name="3">(750-759)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>layer1_9.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import boto
from boto.connection import AWSQueryConnection
from boto.regioninfo import RegionInfo
from boto.exception import JSONResponseError
from boto.cloudtrail import exceptions
from boto.compat import json
class CloudTrailConnection(AWSQueryConnection):
    APIVersion = "2013-11-01"
    DefaultRegionName = "us-east-1"
    DefaultRegionEndpoint = "cloudtrail.us-east-1.amazonaws.com"
    ServiceName = "CloudTrail"
    TargetPrefix = "com.amazonaws.cloudtrail.v20131101.CloudTrail_20131101"
    ResponseError = JSONResponseError
    _faults = {
        "InvalidMaxResultsException": exceptions.InvalidMaxResultsException,
        "InvalidSnsTopicNameException": exceptions.InvalidSnsTopicNameException,
        "InvalidS3BucketNameException": exceptions.InvalidS3BucketNameException,
        "TrailAlreadyExistsException": exceptions.TrailAlreadyExistsException,
        "InvalidTimeRangeException": exceptions.InvalidTimeRangeException,
        "InvalidLookupAttributesException": exceptions.InvalidLookupAttributesException,
        "InsufficientSnsTopicPolicyException": exceptions.InsufficientSnsTopicPolicyException,
        "InvalidCloudWatchLogsLogGroupArnException": exceptions.InvalidCloudWatchLogsLogGroupArnException,
        "InvalidCloudWatchLogsRoleArnException": exceptions.InvalidCloudWatchLogsRoleArnException,
        "InvalidTrailNameException": exceptions.InvalidTrailNameException,
        "CloudWatchLogsDeliveryUnavailableException": exceptions.CloudWatchLogsDeliveryUnavailableException,
        "TrailNotFoundException": exceptions.TrailNotFoundException,
        "S3BucketDoesNotExistException": exceptions.S3BucketDoesNotExistException,
        "InvalidNextTokenException": exceptions.InvalidNextTokenException,
        "InvalidS3PrefixException": exceptions.InvalidS3PrefixException,
        "MaximumNumberOfTrailsExceededException": exceptions.MaximumNumberOfTrailsExceededException,
        "InsufficientS3BucketPolicyException": exceptions.InsufficientS3BucketPolicyException,
    }
    def __init__(self, **kwargs):
        region = kwargs.pop('region', None)
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        if 'host' not in kwargs or kwargs['host'] is None:
            kwargs['host'] = region.endpoint
        super(CloudTrailConnection, self).__init__(**kwargs)
        self.region = region
<a name="2"></a>    def _required_auth_capability(self):
        return ['hmac-v4']
    def create_trail(self, name, s3_bucket_name, s3_key_prefix<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
                     sns_topic_name=None, include_global_service_events=None,
                     cloud_watch_logs_log_group_arn=None,
                     cloud_watch_logs_role_arn=None):
        params = {'Name': name, 'S3BucketName': s3_bucket_name, }
        if s3_key_prefix is not None:
            params['S3KeyPrefix'] = s3_key_prefix
<a name="3"></a>        if sns_topic_name is not None:
            params[</b></font>'SnsTopicName'] = sns_topic_name
        if include_global_service_events is not None:
            params['IncludeGlobalServiceEvents'] =<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b> include_global_service_events
        if cloud_watch_logs_log_group_arn is not None:
            params['CloudWatchLogsLogGroupArn'] = cloud_watch_logs_log_group_arn
        if cloud_watch_logs_role_arn is not None:
            params['CloudWatchLogsRoleArn'] = cloud_watch_logs_role_arn
        return self.make_request(</b></font>action='CreateTrail',
                                 body=json.dumps(params))
    def delete_trail(self, name):
        params = {'Name': name, }
        return self.make_request(action='DeleteTrail',
                                 body=json.dumps(params))
    def describe_trails(self, trail_name_list=None):
        params = {}
        if trail_name_list is not None:
            params['trailNameList'] = trail_name_list
        return self.make_request(action='DescribeTrails',
                                 body=json.dumps(params))
    def get_trail_status(self, name):
        params = {'Name': name, }
        return self.make_request(action='GetTrailStatus',
                                 body=json.dumps(params))
    def lookup_events(self, lookup_attributes=None, start_time=None,
                      end_time=None, max_results=None, next_token=None):
        params = {}
        if lookup_attributes is not None:
            params['LookupAttributes'] = lookup_attributes
        if start_time is not None:
            params['StartTime'] = start_time
        if end_time is not None:
            params['EndTime'] = end_time
        if max_results is not None:
            params['MaxResults'] = max_results
        if next_token is not None:
            params['NextToken'] = next_token
        return self.make_request(action='LookupEvents',
                                 body=json.dumps(params))
    def start_logging(self, name):
        params = {'Name': name, }
        return self.make_request(action='StartLogging',
                                 body=json.dumps(params))
    def stop_logging(self, name):
        params = {'Name': name, }
<a name="0"></a>        return self.make_request(action='StopLogging',
                                 body=json.dumps(params))
    def update_trail(self, name, s3_bucket_name<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, s3_key_prefix=None,
                     sns_topic_name=None, include_global_service_events=None,
                     cloud_watch_logs_log_group_arn=None,
                     cloud_watch_logs_role_arn=None):
        params = {'Name': name, }
        if s3_bucket_name is not None:
            params['S3BucketName'] = s3_bucket_name
        if s3_key_prefix is not None:
            params['S3KeyPrefix'] = s3_key_prefix
        if sns_topic_name is not None:
            params['SnsTopicName'] = sns_topic_name
        if</b></font> include_global_service_events is not None:
            params['IncludeGlobalServiceEvents'] = include_global_service_events
        if cloud_watch_logs_log_group_arn is not None:
            params['CloudWatchLogsLogGroupArn'] = cloud_watch_logs_log_group_arn
        if cloud_watch_logs_role_arn is not None:
            params['CloudWatchLogsRoleArn'] = cloud_watch_logs_role_arn
        return self.make_request(action='UpdateTrail',
                                 body=json.dumps(params))
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
<a name="1"></a>            'Content-Type': 'application/x-amz-json-1.1',
            'Content-Length': str(len(body)),
        }
        http_request <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=10)
        response_body =</b></font> response.read().decode('utf-8')
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>connection_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import xml.sax
import datetime
import itertools
from boto import handler
from boto import config
from boto.mturk.price import Price
import boto.mturk.notification
from boto.connection import AWSQueryConnection
from boto.exception import EC2ResponseError
from boto.resultset import ResultSet
from boto.mturk.question import QuestionForm, ExternalQuestion, HTMLQuestion
class MTurkRequestError(EC2ResponseError):
    "Error for MTurk Requests"
class MTurkConnection(AWSQueryConnection):
    APIVersion = '2014-08-15'
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None,
                 host=None, debug=0,
                 https_connection_factory=None, security_token=None,
                 profile_name=None):
        if not host:
            if config.has_option('MTurk', 'sandbox') and config.get('MTurk', 'sandbox') == 'True':
                host = 'mechanicalturk.sandbox.amazonaws.com'
            else:
                host = 'mechanicalturk.amazonaws.com'
        self.debug = debug
        super(MTurkConnection, self).__init__(aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass, host, debug,
                                    https_connection_factory,
                                    security_token=security_token,
                                    profile_name=profile_name)
    def _required_auth_capability(self):
        return ['mturk']
    def get_account_balance(self):
        params = {}
        return self._process_request('GetAccountBalance', params,
                                     [('AvailableBalance', Price),
                                      ('OnHoldBalance', Price)])
    def register_hit_type(self, title, description, reward, duration,
                          keywords=None, approval_delay=None, qual_req=None):
        params = dict(
            Title=title,
            Description=description,
            AssignmentDurationInSeconds=self.duration_as_seconds(duration),
            )
        params.update(MTurkConnection.get_price_as_price(reward).get_as_params('Reward'))
        if keywords:
            params['Keywords'] = self.get_keywords_as_string(keywords)
        if approval_delay is not None:
            d = self.duration_as_seconds(approval_delay)
            params['AutoApprovalDelayInSeconds'] = d
        if qual_req is not None:
            params.update(qual_req.get_as_params())
        return self._process_request('RegisterHITType', params,
                                     [('HITTypeId', HITTypeId)])
    def set_email_notification(self, hit_type, email, event_types=None):
        return self._set_notification(hit_type, 'Email', email,
                                      'SetHITTypeNotification', event_types)
    def set_rest_notification(self, hit_type, url, event_types=None):
        return self._set_notification(hit_type, 'REST', url,
                                      'SetHITTypeNotification', event_types)
    def set_sqs_notification(self, hit_type, queue_url, event_types=None):
        return self._set_notification(hit_type, "SQS", queue_url,
                                      'SetHITTypeNotification', event_types)
    def send_test_event_notification(self, hit_type, url,
                                     event_types=None,
                                     test_event_type='Ping'):
        return self._set_notification(hit_type, 'REST', url,
                                      'SendTestEventNotification',
                                      event_types, test_event_type)
    def _set_notification(self, hit_type, transport,
                          destination, request_type,
                          event_types=None, test_event_type=None):
        params = {'HITTypeId': hit_type}
        notification_params = {'Destination': destination,
                               'Transport': transport,
                               'Version': boto.mturk.notification.NotificationMessage.NOTIFICATION_VERSION,
                               'Active': True,
                               }
        if event_types:
            self.build_list_params(notification_params, event_types,
                                   'EventType')
        notification_rest_params = {}
        num = 1
        for key in notification_params:
            notification_rest_params['Notification.%d.%s' % (num, key)] = notification_params[key]
        params.update(notification_rest_params)
        if test_event_type:
            params.update({'TestEventType': test_event_type})
<a name="1"></a>        return self._process_request(request_type, params)
    def create_hit(self, hit_type=None, question=None, hit_layout=None,
                   lifetime<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=datetime.timedelta(days=7),
                   max_assignments=1,
                   title=None, description=None, keywords=None,
                   reward=None, duration=datetime.timedelta(days=7),
                   approval_delay=None, annotation=</b></font>None,
                   questions=None, qualifications=None,
                   layout_params=None, response_groups=None):
        params = {'LifetimeInSeconds':
                      self.duration_as_seconds(lifetime),
                  'MaxAssignments': max_assignments,
                 }
        neither = question is None and questions is None
        if hit_layout is None:
            both = question is not None and questions is not None
            if neither or both:
                raise ValueError("Must specify question (single Question instance) or questions (list or QuestionForm instance), but not both")
            if question:
                questions = [question]
            question_param = QuestionForm(questions)
            if isinstance(question, QuestionForm):
                question_param = question
            elif isinstance(question, ExternalQuestion):
                question_param = question
            elif isinstance(question, HTMLQuestion):
                question_param = question
            params['Question'] = question_param.get_as_xml()
        else:
            if not neither:
                raise ValueError("Must not specify question (single Question instance) or questions (list or QuestionForm instance) when specifying hit_layout")
            params['HITLayoutId'] = hit_layout
            if layout_params:
                params.update(layout_params.get_as_params())
        if hit_type:
            params['HITTypeId'] = hit_type
        else:
            final_keywords = MTurkConnection.get_keywords_as_string(keywords)
            final_price = MTurkConnection.get_price_as_price(reward)
            final_duration = self.duration_as_seconds(duration)
            additional_params = dict(
                Title=title,
                Description=description,
                Keywords=final_keywords,
                AssignmentDurationInSeconds=final_duration,
                )
            additional_params.update(final_price.get_as_params('Reward'))
            if approval_delay is not None:
                d = self.duration_as_seconds(approval_delay)
                additional_params['AutoApprovalDelayInSeconds'] = d
            params.update(additional_params)
        if annotation is not None:
            params['RequesterAnnotation'] = annotation
        if qualifications is not None:
            params.update(qualifications.get_as_params())
        if response_groups:
            self.build_list_params(params, response_groups, 'ResponseGroup')
        return self._process_request('CreateHIT', params, [('HIT', HIT)])
    def change_hit_type_of_hit(self, hit_id, hit_type):
        params = {'HITId': hit_id,
                  'HITTypeId': hit_type}
        return self._process_request('ChangeHITTypeOfHIT', params)
    def get_reviewable_hits(self, hit_type=None, status='Reviewable',
                            sort_by='Expiration', sort_direction='Ascending',
                            page_size=10, page_number=1):
        params = {'Status': status,
                  'SortProperty': sort_by,
                  'SortDirection': sort_direction,
                  'PageSize': page_size,
                  'PageNumber': page_number}
        if hit_type is not None:
            params.update({'HITTypeId': hit_type})
        return self._process_request('GetReviewableHITs', params,
                                     [('HIT', HIT)])
    @staticmethod
    def _get_pages(page_size, total_records):
        pages = total_records / page_size + bool(total_records % page_size)
        return list(range(1, pages + 1))
    def get_all_hits(self):
        page_size = 100
        search_rs = self.search_hits(page_size=page_size)
        total_records = int(search_rs.TotalNumResults)
        get_page_hits = lambda page: self.search_hits(page_size=page_size, page_number=page)
        page_nums = self._get_pages(page_size, total_records)
        hit_sets = itertools.imap(get_page_hits, page_nums)
        return itertools.chain.from_iterable(hit_sets)
    def search_hits(self, sort_by='CreationTime', sort_direction='Ascending',
                    page_size=10, page_number=1, response_groups=None):
        params = {'SortProperty': sort_by,
                  'SortDirection': sort_direction,
                  'PageSize': page_size,
                  'PageNumber': page_number}
        if response_groups:
            self.build_list_params(params, response_groups, 'ResponseGroup')
        return self._process_request('SearchHITs', params, [('HIT', HIT)])
    def get_assignment(self, assignment_id, response_groups=None):
        params = {'AssignmentId': assignment_id}
        if response_groups:
            self.build_list_params(params, response_groups, 'ResponseGroup')
        return self._process_request('GetAssignment', params,
                                     [('Assignment', Assignment),
<a name="2"></a>                                      ('HIT', HIT)])
    def get_assignments(self, hit_id, status=None,
                            sort_by<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>='SubmitTime', sort_direction='Ascending',
                            page_size=10, page_number=1, response_groups=None):
        params = {'HITId': hit_id,
                  'SortProperty': sort_by,
                  'SortDirection': sort_direction,
                  'PageSize': page_size,
                  'PageNumber': page_number}
        if status is not None:
            params['AssignmentStatus'] = status
        if response_groups:
            self.</b></font>build_list_params(params, response_groups, 'ResponseGroup')
        return self._process_request('GetAssignmentsForHIT', params,
                                     [('Assignment', Assignment)])
    def approve_assignment(self, assignment_id, feedback=None):
        params = {'AssignmentId': assignment_id}
        if feedback:
            params['RequesterFeedback'] = feedback
        return self._process_request('ApproveAssignment', params)
    def reject_assignment(self, assignment_id, feedback=None):
        params = {'AssignmentId': assignment_id}
        if feedback:
            params['RequesterFeedback'] = feedback
        return self._process_request('RejectAssignment', params)
    def approve_rejected_assignment(self, assignment_id, feedback=None):
        params = {'AssignmentId': assignment_id}
        if feedback:
            params['RequesterFeedback'] = feedback
        return self._process_request('ApproveRejectedAssignment', params)
    def get_file_upload_url(self, assignment_id, question_identifier):
        params = {'AssignmentId': assignment_id,
                  'QuestionIdentifier': question_identifier}
        return self._process_request('GetFileUploadURL', params,
                                     [('FileUploadURL', FileUploadURL)])
    def get_hit(self, hit_id, response_groups=None):
        params = {'HITId': hit_id}
        if response_groups:
            self.build_list_params(params, response_groups, 'ResponseGroup')
        return self._process_request('GetHIT', params, [('HIT', HIT)])
    def set_reviewing(self, hit_id, revert=None):
        params = {'HITId': hit_id}
        if revert:
            params['Revert'] = revert
        return self._process_request('SetHITAsReviewing', params)
    def disable_hit(self, hit_id, response_groups=None):
        params = {'HITId': hit_id}
        if response_groups:
            self.build_list_params(params, response_groups, 'ResponseGroup')
        return self._process_request('DisableHIT', params)
    def dispose_hit(self, hit_id):
        Expire a HIT that is no longer needed.
        The effect is identical to the HIT expiring on its own. The
        HIT no longer appears on the Mechanical Turk web site, and no
        new Workers are allowed to accept the HIT. Workers who have
        accepted the HIT prior to expiration are allowed to complete
        it or return it, or allow the assignment duration to elapse
        (abandon the HIT). Once all remaining assignments have been
        submitted, the expired HIT becomes"reviewable", and will be
        returned by a call to GetReviewableHITs.
        Increase the maximum number of assignments, or extend the
        expiration date, of an existing HIT.
        NOTE: If a HIT has a status of Reviewable and the HIT is
        extended to make it Available, the HIT will not be returned by
        GetReviewableHITs, and its submitted assignments will not be
        returned by GetAssignmentsForHIT, until the HIT is Reviewable
        again.  Assignment auto-approval will still happen on its
        original schedule, even if the HIT has been extended. Be sure
        to retrieve and approve (or reject) submitted assignments
        before extending the HIT, if so desired.
        Return information about the Mechanical Turk Service
        operations and response group NOTE - this is basically useless
        as it just returns the URL of the documentation
        help_type: either 'Operation' or 'ResponseGroup'
        Issues a payment of money from your account to a Worker.  To
        be eligible for a bonus, the Worker must have submitted
        results for one of your HITs, and have had those results
        approved or rejected. This payment happens separately from the
        reward you pay to the Worker when you approve the Worker's
        assignment.  The Bonus must be passed in as an instance of the
        Price object.
        Block a worker from working on my tasks.
        Unblock a worker from working on my tasks.
        Send a text message to workers.
        Create a new Qualification Type.
        name: This will be visible to workers and must be unique for a
           given requester.
        description: description shown to workers.  Max 2000 characters.
        status: 'Active' or 'Inactive'
        keywords: list of keyword strings or comma separated string.
           Max length of 1000 characters when concatenated with commas.
        retry_delay: number of seconds after requesting a
           qualification the worker must wait before they can ask again.
           If not specified, workers can only request this qualification
           once.
        test: a QuestionForm
        answer_key: an XML string of your answer key, for automatically
           scored qualification tests.
           (Consider implementing an AnswerKey class for this to support.)
        test_duration: the number of seconds a worker has to complete the test.
        auto_granted: if True, requests for the Qualification are granted
           immediately.  Can't coexist with a test.
        auto_granted_value: auto_granted qualifications are given this value.
                                  retry_delay<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
                                  test=None,
                                  answer_key=None,
                                  test_duration=None,
                                  auto_granted=None,
                                  auto_granted_value=None):
        params = {'QualificationTypeId': qualification_type_id}
        if description is not None:
            params['Description'] = description
        if status is not None:
            params['QualificationTypeStatus'] = status
        if retry_delay is not None:
            params['RetryDelayInSeconds'] = retry_delay
        if</b></font> test is not None:
            assert(isinstance(test, QuestionForm))
            params['Test'] = test.get_as_xml()
        if test_duration is not None:
            params['TestDurationInSeconds'] = test_duration
        if answer_key is not None:
<a name="3"></a>            if isinstance(answer_key, basestring):
                params['AnswerKey'] = answer_key  # xml
            else:
                ra<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ise TypeError
        if auto_granted is not None:
            params['AutoGranted'] = auto_granted
        if auto_granted_value is not None:
            params['AutoGrantedValue'] = auto_granted_value
        return self._process_request(</b></font>'UpdateQualificationType', params,
                                     [('QualificationType', QualificationType)])
    def dispose_qualification_type(self, qualification_type_id):
        params = {'QualificationTypeId': qualification_type_id}
        return self._process_request('DisposeQualificationType', params)
    def search_qualification_types(self, query=None, sort_by='Name',
                                   sort_direction='Ascending', page_size=10,
                                   page_number=1, must_be_requestable=True,
                                   must_be_owned_by_caller=True):
        params = {'Query': query,
                  'SortProperty': sort_by,
                  'SortDirection': sort_direction,
                  'PageSize': page_size,
                  'PageNumber': page_number,
                  'MustBeRequestable': must_be_requestable,
                  'MustBeOwnedByCaller': must_be_owned_by_caller}
        return self._process_request('SearchQualificationTypes', params,
                    [('QualificationType', QualificationType)])
    def get_qualification_requests(self, qualification_type_id,
                                   sort_by='Expiration',
                                   sort_direction='Ascending', page_size=10,
                                   page_number=1):
        params = {'QualificationTypeId': qualification_type_id,
                  'SortProperty': sort_by,
                  'SortDirection': sort_direction,
                  'PageSize': page_size,
                  'PageNumber': page_number}
        return self._process_request('GetQualificationRequests', params,
                    [('QualificationRequest', QualificationRequest)])
    def grant_qualification(self, qualification_request_id, integer_value=1):
        params = {'QualificationRequestId': qualification_request_id,
                  'IntegerValue': integer_value}
        return self._process_request('GrantQualification', params)
    def revoke_qualification(self, subject_id, qualification_type_id,
                             reason=None):
        params = {'SubjectId': subject_id,
                  'QualificationTypeId': qualification_type_id,
                  'Reason': reason}
        return self._process_request('RevokeQualification', params)
    def assign_qualification(self, qualification_type_id, worker_id,
                             value=1, send_notification=True):
        params = {'QualificationTypeId': qualification_type_id,
                  'WorkerId' : worker_id,
                  'IntegerValue' : value,
                  'SendNotification' : send_notification}
        return self._process_request('AssignQualification', params)
    def get_qualification_score(self, qualification_type_id, worker_id):
        params = {'QualificationTypeId' : qualification_type_id,
                  'SubjectId' : worker_id}
        return self._process_request('GetQualificationScore', params,
                    [('Qualification', Qualification)])
    def update_qualification_score(self, qualification_type_id, worker_id,
                                   value):
        params = {'QualificationTypeId' : qualification_type_id,
                  'SubjectId' : worker_id,
                  'IntegerValue' : value}
        return self._process_request('UpdateQualificationScore', params)
    def _process_request(self, request_type, params, marker_elems=None):
        params['Operation'] = request_type
        response = self.make_request(None, params, verb='POST')
        return self._process_response(response, marker_elems)
    def _process_response(self, response, marker_elems=None):
        body = response.read()
        if self.debug == 2:
            print(body)
        if '&lt;Errors&gt;' not in body.decode('utf-8'):
            rs = ResultSet(marker_elems)
            h = handler.XmlHandler(rs, self)
            xml.sax.parseString(body, h)
            return rs
        else:
            raise MTurkRequestError(response.status, response.reason, body)
    @staticmethod
    def get_keywords_as_string(keywords):
        if isinstance(keywords, list):
            keywords = ', '.join(keywords)
        if isinstance(keywords, str):
            final_keywords = keywords
        elif isinstance(keywords, unicode):
            final_keywords = keywords.encode('utf-8')
        elif keywords is None:
            final_keywords = ""
        else:
            raise TypeError("keywords argument must be a string or a list of strings; got a %s" % type(keywords))
        return final_keywords
    @staticmethod
    def get_price_as_price(reward):
        if isinstance(reward, Price):
            final_price = reward
        else:
            final_price = Price(reward)
        return final_price
    @staticmethod
    def duration_as_seconds(duration):
        if isinstance(duration, datetime.timedelta):
            duration = duration.days * 86400 + duration.seconds
        try:
            duration = int(duration)
        except TypeError:
            raise TypeError("Duration must be a timedelta or int-castable, got %s" % type(duration))
        return duration
class BaseAutoResultElement(object):
    def __init__(self, connection):
        pass
    def startElement(self, name, attrs, connection):
        return None
    def endElement(self, name, value, connection):
        setattr(self, name, value)
class HIT(BaseAutoResultElement):
    def _has_expired(self):
        expired = False
        if hasattr(self, 'Expiration'):
            now = datetime.datetime.utcnow()
            expiration = datetime.datetime.strptime(self.Expiration, '%Y-%m-%dT%H:%M:%SZ')
            expired = (now &gt;= expiration)
        else:
            raise ValueError("ERROR: Request for expired property, but no Expiration in HIT!")
        return expired
    expired = property(_has_expired)
class FileUploadURL(BaseAutoResultElement):
    pass
class HITTypeId(BaseAutoResultElement):
    pass
class Qualification(BaseAutoResultElement):
    pass
class QualificationType(BaseAutoResultElement):
    pass
class QualificationRequest(BaseAutoResultElement):
    def __init__(self, connection):
        super(QualificationRequest, self).__init__(connection)
        self.answers = []
    def endElement(self, name, value, connection):
        if name == 'Answer':
            answer_rs = ResultSet([('Answer', QuestionFormAnswer)])
            h = handler.XmlHandler(answer_rs, connection)
            value = connection.get_utf8able_str(value)
            xml.sax.parseString(value, h)
            self.answers.append(answer_rs)
        else:
            super(QualificationRequest, self).endElement(name, value, connection)
class Assignment(BaseAutoResultElement):
    def __init__(self, connection):
        super(Assignment, self).__init__(connection)
        self.answers = []
    def endElement(self, name, value, connection):
        if name == 'Answer':
            answer_rs = ResultSet([('Answer', QuestionFormAnswer)])
            h = handler.XmlHandler(answer_rs, connection)
            value = connection.get_utf8able_str(value)
            xml.sax.parseString(value, h)
            self.answers.append(answer_rs)
        else:
            super(Assignment, self).endElement(name, value, connection)
class QuestionFormAnswer(BaseAutoResultElement):
    def __init__(self, connection):
        super(QuestionFormAnswer, self).__init__(connection)
        self.fields = []
        self.qid = None
    def endElement(self, name, value, connection):
        if name == 'QuestionIdentifier':
            self.qid = value
        elif name in ['FreeText', 'SelectionIdentifier', 'OtherSelectionText'] and self.qid:
            self.fields.append(value)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
