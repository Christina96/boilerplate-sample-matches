<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for connection_4.py &amp; __init___99.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for connection_4.py &amp; __init___99.py
      </h3>
<h1 align="center">
        21.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>connection_4.py (28.380953%)<th>__init___99.py (16.666666%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(176-217)<td><a href="#" name="0">(1161-1258)</a><td align="center"><font color="#ff0000">29</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(57-65)<td><a href="#" name="1">(79-87)</a><td align="center"><font color="#b80000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(635-680)<td><a href="#" name="2">(1039-1074)</a><td align="center"><font color="#af0000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(440-485)<td><a href="#" name="3">(745-776)</a><td align="center"><font color="#a70000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(267-276)<td><a href="#" name="4">(1103-1117)</a><td align="center"><font color="#a70000">19</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(289-345)<td><a href="#" name="5">(877-892)</a><td align="center"><font color="#830000">15</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(396-419)<td><a href="#" name="6">(1420-1438)</a><td align="center"><font color="#7b0000">14</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(756-759)<td><a href="#" name="7">(157-419)</a><td align="center"><font color="#690000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>connection_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
# Copyright (c) 2010-2012 Mitch Garnaat http://garnaat.org/
# Copyright (c) 2012 Amazon.com, Inc. or its affiliates.  All Rights Reserved
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish, dis-
# tribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the fol-
# lowing conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
# ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
# SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import uuid
import hashlib

from boto.connection import AWSQueryConnection
from boto.regioninfo import RegionInfo
from boto.compat import json
import boto


class SNSConnection(AWSQueryConnection):
    """
    Amazon Simple Notification Service
    Amazon Simple Notification Service (Amazon SNS) is a web service
    that enables you to build distributed web-enabled applications.
    Applications can use Amazon SNS to easily push real-time
    notification messages to interested subscribers over multiple
    delivery protocols. For more information about this product see
    `http://aws.amazon.com/sns`_. For detailed information about
    Amazon SNS features and their associated API calls, see the
    `Amazon SNS Developer Guide`_.

    We also provide SDKs that enable you to access Amazon SNS from
    your preferred programming language. The SDKs contain
    functionality that automatically takes care of tasks such as:
    cryptographically signing your service requests, retrying
    requests, and handling error responses. For a list of available
    SDKs, go to `Tools for Amazon Web Services`_.
    """
    DefaultRegionName = boto.config.get('Boto', 'sns_region_name', 'us-east-1')
    DefaultRegionEndpoint = boto.config.get('Boto', 'sns_region_endpoint', 
                                            'sns.us-east-1.amazonaws.com')
<a name="1"></a>    APIVersion = boto.config.get('Boto', 'sns_version', '2010-03-31')


    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True,
                 profile_name=None):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.</b></font>DefaultRegionEndpoint,
                                connection_cls=SNSConnection)
        self.region = region
        super(SNSConnection, self).__init__(aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token=security_token,
                                    validate_certs=validate_certs,
                                    profile_name=profile_name)

    def _build_dict_as_list_params(self, params, dictionary, name):
      """
            Serialize a parameter 'name' which value is a 'dictionary' into a list of parameters.

            See: http://docs.aws.amazon.com/sns/latest/api/API_SetPlatformApplicationAttributes.html
            For example::

                dictionary = {'PlatformPrincipal': 'foo', 'PlatformCredential': 'bar'}
                name = 'Attributes'

            would result in params dict being populated with:
                Attributes.entry.1.key    = PlatformPrincipal
                Attributes.entry.1.value  = foo
                Attributes.entry.2.key    = PlatformCredential
                Attributes.entry.2.value  = bar

      :param params: the resulting parameters will be added to this dict
      :param dictionary: dict - value of the serialized parameter
      :param name: name of the serialized parameter
      """
      items = sorted(dictionary.items(), key=lambda x:x[0])
      for kv, index in zip(items, list(range(1, len(items)+1))):
        key, value = kv
        prefix = '%s.entry.%s' % (name, index)
        params['%s.key' % prefix] = key
        params['%s.value' % prefix] = value

    def _required_auth_capability(self):
        return ['hmac-v4']

    def get_all_topics(self, next_token=None):
        """
        :type next_token: string
        :param next_token: Token returned by the previous call to
                           this method.

        """
        params = {}
        if next_token:
            params['NextToken'] = next_token
        return self._make_request('ListTopics', params)

    def get_topic_attributes(self, topic):
        """
        Get attributes of a Topic

        :type topic: string
        :param topic: The ARN of the topic.

        """
        params = {'TopicArn': topic}
        return self._make_request('GetTopicAttributes', params)

    def set_topic_attributes(self, topic, attr_name, attr_value):
        """
        Get attributes of a Topic

        :type topic: string
        :param topic: The ARN of the topic.

        :type attr_name: string
        :param attr_name: The name of the attribute you want to set.
                          Only a subset of the topic's attributes are mutable.
                          Valid values: Policy | DisplayName

        :type attr_value: string
        :param attr_value: The new value for the attribute.

        """
        params = {'TopicArn': topic,
                  'AttributeName': attr_name,
                  'AttributeValue': attr_value}
        return self._make_request('SetTopicAttributes', params)

    def add_permission(self, topic, label, account_ids, actions):
        """
        Adds a statement to a topic's access control policy, granting
        access for the specified AWS accounts to the specified actions.

        :type topic: string
        :param topic: The ARN of the topic.

        :type label: string
        :param label: A unique identifier for the new policy statement.

        :type account_ids: list of strings
        :param account_ids: The AWS account ids of the users who will be
                            give access to the specified actions.

        :type actions: list of strings
        :param actions: The actions you want to allow for each of the
                        specified principal(s).

        """
        params = {'TopicArn': topic,
<a name="0"></a>                  'Label': label}
        self.build_list_params(params, account_ids, 'AWSAccountId.member')
        self.build_list_params(params, actions, 'ActionName.member')
        return self._make_request(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'AddPermission', params)

    def remove_permission(self, topic, label):
        """
        Removes a statement from a topic's access control policy.

        :type topic: string
        :param topic: The ARN of the topic.

        :type label: string
        :param label: A unique identifier for the policy statement
                      to be removed.

        """
        params = {'TopicArn': topic,
                  'Label': label}
        return self._make_request('RemovePermission', params)

    def create_topic(self, topic):
        """
        Create a new Topic.

        :type topic: string
        :param topic: The name of the new topic.

        """
        params = {'Name': topic}
        return self._make_request('CreateTopic', params)

    def delete_topic(self, topic):
        """
        Delete an existing topic

        :type topic: string
        :param topic: The ARN of the topic

        """
        params = {'TopicArn': topic}
        return self._make_request('DeleteTopic', params, '/', 'GET')

    def publish(self, topic=None, message=None, subject=None, target_arn=None,
                message_structure=None, message_attributes=</b></font>None):
        """
        Sends a message to all of a topic's subscribed endpoints

        :type topic: string
        :param topic: The topic you want to publish to.

        :type message: string
        :param message: The message you want to send to the topic.
                        Messages must be UTF-8 encoded strings and
                        be at most 4KB in size.

        :type message_structure: string
        :param message_structure: Optional parameter. If left as ``None``,
                                  plain text will be sent. If set to ``json``,
                                  your message should be a JSON string that
                                  matches the structure described at
                                  http://docs.aws.amazon.com/sns/latest/dg/PublishTopic.html#sns-message-formatting-by-protocol

        :type message_attributes: dict
        :param message_attributes: Message attributes to set. Should be
            of the form:

            .. code-block:: python

                {
                    "name1": {
                        "data_type": "Number",
                        "string_value": "42"
                    },
                    "name2": {
                        "data_type": "String",
                        "string_value": "Bob"
                    }
                }

        :type subject: string
        :param subject: Optional parameter to be used as the "Subject"
                        line of the email notifications.

        :type target_arn: string
        :param target_arn: Optional parameter for either TopicArn or
                           EndpointArn, but not both.

        """
        if message is None:
            # To be backwards compatible when message did not have
<a name="4"></a>            # a default value and topic and message were required
            # args.
            raise TypeError("'message' is a required parameter")
        params <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {'Message': message}
        if subject is not None:
            params['Subject'] = subject
        if topic is not None:
            params['TopicArn'] = topic
        if target_arn is not None:
            params['TargetArn'] = target_arn
        if message_structure is not None:
            params['MessageStructure'] = message_structure
        if</b></font> message_attributes is not None:
            keys = sorted(message_attributes.keys())
            for i, name in enumerate(keys, start=1):
                attribute = message_attributes[name]
                params['MessageAttributes.entry.{0}.Name'.format(i)] = name
                if 'data_type' in attribute:
                    params['MessageAttributes.entry.{0}.Value.DataType'.format(i)] = \
                        attribute['data_type']
                if 'string_value' in attribute:
                    params['MessageAttributes.entry.{0}.Value.StringValue'.format(i)] = \
<a name="5"></a>                        attribute['string_value']
                if 'binary_value' in attribute:
                    params['MessageAttributes.entry.{0}.Value.BinaryValue'.format(i)] = \
                        attribute['<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>binary_value']
        return self._make_request('Publish', params, '/', 'POST')

    def subscribe(self, topic, protocol, endpoint):
        """
        Subscribe to a Topic.

        :type topic: string
        :param topic: The ARN of the new topic.

        :type protocol: string
        :param protocol: The protocol used to communicate with
                         the subscriber.  Current choices are:
                         email|email-json|http|https|sqs|sms|application

        :type endpoint: string
        :param endpoint: The location of the endpoint for
                         the subscriber.
                         * For email, this would be a valid email address
                         * For email-json, this would be a valid email address
                         * For http, this would be a URL beginning with http
                         * For https, this would be a URL beginning with https
                         * For sqs, this would be the ARN of an SQS Queue
                         * For sms, this would be a phone number of an
                           SMS-enabled device
                         * For application, the endpoint is the EndpointArn
                           of a mobile app and device.
        """
        params = {'TopicArn': topic,
                  'Protocol': protocol,
                  'Endpoint': endpoint}
        return self._make_request('Subscribe', params)

    def subscribe_sqs_queue(self, topic, queue):
        """
        Subscribe an SQS queue to a topic.

        This is convenience method that handles most of the complexity involved
        in using an SQS queue as an endpoint for an SNS topic.  To achieve this
        the following operations are performed:

        * The correct ARN is constructed for the SQS queue and that ARN is
          then subscribed to the topic.
        * A JSON policy document is contructed that grants permission to
          the SNS topic to send messages to the SQS queue.
        * This JSON policy is then associated with the SQS queue using
          the queue's set_attribute method.  If the queue already has
          a policy associated with it, this process will add a Statement to
          that policy.  If no policy exists, a new policy will be created.

        :type topic: string
        :param topic: The ARN of the new topic.

        :type queue: A boto Queue object
        :param queue: The queue you wish to subscribe to the SNS Topic.
        """
        t =</b></font> queue.id.split('/')
        q_arn = queue.arn
        sid = hashlib.md5((topic + q_arn).encode('utf-8')).hexdigest()
        sid_exists = False
        resp = self.subscribe(topic, 'sqs', q_arn)
        attr = queue.get_attributes('Policy')
        if 'Policy' in attr:
            policy = json.loads(attr['Policy'])
        else:
            policy = {}
        if 'Version' not in policy:
            policy['Version'] = '2008-10-17'
        if 'Statement' not in policy:
            policy['Statement'] = []
        # See if a Statement with the Sid exists already.
        for s in policy['Statement']:
            if s['Sid'] == sid:
                sid_exists = True
        if not sid_exists:
            statement = {'Action': 'SQS:SendMessage',
                         'Effect': 'Allow',
                         'Principal': {'AWS': '*'},
                         'Resource': q_arn,
                         'Sid': sid,
                         'Condition': {'StringLike': {'aws:SourceArn': topic}}}
            policy['Statement'].append(statement)
        queue.set_attribute('Policy', json.dumps(policy))
        return resp

    def confirm_subscription(self, topic, token,
                             authenticate_on_unsubscribe=False):
        """
        Get properties of a Topic

        :type topic: string
        :param topic: The ARN of the new topic.

        :type token: string
        :param token: Short-lived token sent to and endpoint during
                      the Subscribe operation.

        :type authenticate_on_unsubscribe: bool
        :param authenticate_on_unsubscribe: Optional parameter indicating
                                            that you wish to disable
                                            unauthenticated unsubscription
                                            of the subscription.

        """
<a name="6"></a>        params = {'TopicArn': topic, 'Token': token}
        if authenticate_on_unsubscribe:
            params['AuthenticateOnUnsubscribe'] = 'true'
        <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return self._make_request('ConfirmSubscription', params)

    def unsubscribe(self, subscription):
        """
        Allows endpoint owner to delete subscription.
        Confirmation message will be delivered.

        :type subscription: string
        :param subscription: The ARN of the subscription to be deleted.

        """
        params = {'SubscriptionArn': subscription}
        return self._make_request('Unsubscribe', params)

    def get_all_subscriptions(self, next_token=None):
        """
        Get list of all subscriptions.

        :type next_token: string
        :param next_token: Token returned by the previous call to
                           this method.

        """
        params =</b></font> {}
        if next_token:
            params['NextToken'] = next_token
        return self._make_request('ListSubscriptions', params)

    def get_all_subscriptions_by_topic(self, topic, next_token=None):
        """
        Get list of all subscriptions to a specific topic.

        :type topic: string
        :param topic: The ARN of the topic for which you wish to
                      find subscriptions.

        :type next_token: string
        :param next_token: Token returned by the previous call to
                           this method.

        """
<a name="3"></a>        params = {'TopicArn': topic}
        if next_token:
            params['NextToken'] = next_token
        <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return self._make_request('ListSubscriptionsByTopic', params)

    def create_platform_application(self, name=None, platform=None,
                                    attributes=None):
        """
        The `CreatePlatformApplication` action creates a platform
        application object for one of the supported push notification
        services, such as APNS and GCM, to which devices and mobile
        apps may register. You must specify PlatformPrincipal and
        PlatformCredential attributes when using the
        `CreatePlatformApplication` action. The PlatformPrincipal is
        received from the notification service. For APNS/APNS_SANDBOX,
        PlatformPrincipal is "SSL certificate". For GCM,
        PlatformPrincipal is not applicable. For ADM,
        PlatformPrincipal is "client id". The PlatformCredential is
        also received from the notification service. For
        APNS/APNS_SANDBOX, PlatformCredential is "private key". For
        GCM, PlatformCredential is "API key". For ADM,
        PlatformCredential is "client secret". The
        PlatformApplicationArn that is returned when using
        `CreatePlatformApplication` is then used as an attribute for
        the `CreatePlatformEndpoint` action. For more information, see
        `Using Amazon SNS Mobile Push Notifications`_.

        :type name: string
        :param name: Application names must be made up of only uppercase and
            lowercase ASCII letters, numbers, underscores, hyphens, and
            periods, and must be between 1 and 256 characters long.

        :type platform: string
        :param platform: The following platforms are supported: ADM (Amazon
            Device Messaging), APNS (Apple Push Notification Service),
            APNS_SANDBOX, and GCM (Google Cloud Messaging).

        :type attributes: map
        :param attributes: For a list of attributes, see
            `SetPlatformApplicationAttributes`_

        """
        params = {}
        if name is not None:
            params['Name'] = name
        if platform is not None:
            params['Platform'] = platform
        if attributes is not None:
            self.</b></font>_build_dict_as_list_params(params, attributes, 'Attributes')
        return self._make_request(action='CreatePlatformApplication',
                                  params=params)

    def set_platform_application_attributes(self,
                                            platform_application_arn=None,
                                            attributes=None):
        """
        The `SetPlatformApplicationAttributes` action sets the
        attributes of the platform application object for the
        supported push notification services, such as APNS and GCM.
        For more information, see `Using Amazon SNS Mobile Push
        Notifications`_.

        :type platform_application_arn: string
        :param platform_application_arn: PlatformApplicationArn for
            SetPlatformApplicationAttributes action.

        :type attributes: map
        :param attributes:
        A map of the platform application attributes. Attributes in this map
            include the following:


        + `PlatformCredential` -- The credential received from the notification
              service. For APNS/APNS_SANDBOX, PlatformCredential is "private
              key". For GCM, PlatformCredential is "API key". For ADM,
              PlatformCredential is "client secret".
        + `PlatformPrincipal` -- The principal received from the notification
              service. For APNS/APNS_SANDBOX, PlatformPrincipal is "SSL
              certificate". For GCM, PlatformPrincipal is not applicable. For
              ADM, PlatformPrincipal is "client id".
        + `EventEndpointCreated` -- Topic ARN to which EndpointCreated event
              notifications should be sent.
        + `EventEndpointDeleted` -- Topic ARN to which EndpointDeleted event
              notifications should be sent.
        + `EventEndpointUpdated` -- Topic ARN to which EndpointUpdate event
              notifications should be sent.
        + `EventDeliveryFailure` -- Topic ARN to which DeliveryFailure event
              notifications should be sent upon Direct Publish delivery failure
              (permanent) to one of the application's endpoints.

        """
        params = {}
        if platform_application_arn is not None:
            params['PlatformApplicationArn'] = platform_application_arn
        if attributes is not None:
            self._build_dict_as_list_params(params, attributes, 'Attributes')
        return self._make_request(action='SetPlatformApplicationAttributes',
                                  params=params)

    def get_platform_application_attributes(self,
                                            platform_application_arn=None):
        """
        The `GetPlatformApplicationAttributes` action retrieves the
        attributes of the platform application object for the
        supported push notification services, such as APNS and GCM.
        For more information, see `Using Amazon SNS Mobile Push
        Notifications`_.

        :type platform_application_arn: string
        :param platform_application_arn: PlatformApplicationArn for
            GetPlatformApplicationAttributesInput.

        """
        params = {}
        if platform_application_arn is not None:
            params['PlatformApplicationArn'] = platform_application_arn
        return self._make_request(action='GetPlatformApplicationAttributes',
                                  params=params)

    def list_platform_applications(self, next_token=None):
        """
        The `ListPlatformApplications` action lists the platform
        application objects for the supported push notification
        services, such as APNS and GCM. The results for
        `ListPlatformApplications` are paginated and return a limited
        list of applications, up to 100. If additional records are
        available after the first page results, then a NextToken
        string will be returned. To receive the next page, you call
        `ListPlatformApplications` using the NextToken string received
        from the previous call. When there are no more records to
        return, NextToken will be null. For more information, see
        `Using Amazon SNS Mobile Push Notifications`_.

        :type next_token: string
        :param next_token: NextToken string is used when calling
            ListPlatformApplications action to retrieve additional records that
            are available after the first page results.

        """
        params = {}
        if next_token is not None:
            params['NextToken'] = next_token
        return self._make_request(action='ListPlatformApplications',
                                  params=params)

    def list_endpoints_by_platform_application(self,
                                               platform_application_arn=None,
                                               next_token=None):
        """
        The `ListEndpointsByPlatformApplication` action lists the
        endpoints and endpoint attributes for devices in a supported
        push notification service, such as GCM and APNS. The results
        for `ListEndpointsByPlatformApplication` are paginated and
        return a limited list of endpoints, up to 100. If additional
        records are available after the first page results, then a
        NextToken string will be returned. To receive the next page,
        you call `ListEndpointsByPlatformApplication` again using the
        NextToken string received from the previous call. When there
        are no more records to return, NextToken will be null. For
        more information, see `Using Amazon SNS Mobile Push
        Notifications`_.

        :type platform_application_arn: string
        :param platform_application_arn: PlatformApplicationArn for
            ListEndpointsByPlatformApplicationInput action.

        :type next_token: string
        :param next_token: NextToken string is used when calling
            ListEndpointsByPlatformApplication action to retrieve additional
            records that are available after the first page results.

        """
        params = {}
        if platform_application_arn is not None:
            params['PlatformApplicationArn'] = platform_application_arn
        if next_token is not None:
            params['NextToken'] = next_token
        return self._make_request(action='ListEndpointsByPlatformApplication',
                                  params=params)

    def delete_platform_application(self, platform_application_arn=None):
        """
        The `DeletePlatformApplication` action deletes a platform
        application object for one of the supported push notification
        services, such as APNS and GCM. For more information, see
        `Using Amazon SNS Mobile Push Notifications`_.

        :type platform_application_arn: string
        :param platform_application_arn: PlatformApplicationArn of platform
            application object to delete.

        """
        params = {}
        if platform_application_arn is not None:
            params['PlatformApplicationArn'] = platform_application_arn
<a name="2"></a>        return self._make_request(action='DeletePlatformApplication',
                                  params=params)

    <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def create_platform_endpoint(self, platform_application_arn=None,
                                 token=None, custom_user_data=None,
                                 attributes=None):
        """
        The `CreatePlatformEndpoint` creates an endpoint for a device
        and mobile app on one of the supported push notification
        services, such as GCM and APNS. `CreatePlatformEndpoint`
        requires the PlatformApplicationArn that is returned from
        `CreatePlatformApplication`. The EndpointArn that is returned
        when using `CreatePlatformEndpoint` can then be used by the
        `Publish` action to send a message to a mobile app or by the
        `Subscribe` action for subscription to a topic. For more
        information, see `Using Amazon SNS Mobile Push
        Notifications`_.

        :type platform_application_arn: string
        :param platform_application_arn: PlatformApplicationArn returned from
            CreatePlatformApplication is used to create a an endpoint.

        :type token: string
        :param token: Unique identifier created by the notification service for
            an app on a device. The specific name for Token will vary,
            depending on which notification service is being used. For example,
            when using APNS as the notification service, you need the device
            token. Alternatively, when using GCM or ADM, the device token
            equivalent is called the registration ID.

        :type custom_user_data: string
        :param custom_user_data: Arbitrary user data to associate with the
            endpoint. SNS does not use this data. The data must be in UTF-8
            format and less than 2KB.

        :type attributes: map
        :param attributes: For a list of attributes, see
            `SetEndpointAttributes`_.

        """
        params = {}
        if platform_application_arn is not None:
            params['PlatformApplicationArn'] = platform_application_arn
        if token is not None:
            params['Token'] = token
        if custom_user_data is not None:
            params['CustomUserData'] = custom_user_data
        if attributes is not None:
            self.</b></font>_build_dict_as_list_params(params, attributes, 'Attributes')
        return self._make_request(action='CreatePlatformEndpoint',
                                  params=params)

    def delete_endpoint(self, endpoint_arn=None):
        """
        The `DeleteEndpoint` action, which is idempotent, deletes the
        endpoint from SNS. For more information, see `Using Amazon SNS
        Mobile Push Notifications`_.

        :type endpoint_arn: string
        :param endpoint_arn: EndpointArn of endpoint to delete.

        """
        params = {}
        if endpoint_arn is not None:
            params['EndpointArn'] = endpoint_arn
        return self._make_request(action='DeleteEndpoint', params=params)

    def set_endpoint_attributes(self, endpoint_arn=None, attributes=None):
        """
        The `SetEndpointAttributes` action sets the attributes for an
        endpoint for a device on one of the supported push
        notification services, such as GCM and APNS. For more
        information, see `Using Amazon SNS Mobile Push
        Notifications`_.

        :type endpoint_arn: string
        :param endpoint_arn: EndpointArn used for SetEndpointAttributes action.

        :type attributes: map
        :param attributes:
        A map of the endpoint attributes. Attributes in this map include the
            following:


        + `CustomUserData` -- arbitrary user data to associate with the
              endpoint. SNS does not use this data. The data must be in UTF-8
              format and less than 2KB.
        + `Enabled` -- flag that enables/disables delivery to the endpoint.
              Message Processor will set this to false when a notification
              service indicates to SNS that the endpoint is invalid. Users can
              set it back to true, typically after updating Token.
        + `Token` -- device token, also referred to as a registration id, for
              an app and mobile device. This is returned from the notification
              service when an app and mobile device are registered with the
              notification service.

        """
        params = {}
        if endpoint_arn is not None:
            params['EndpointArn'] = endpoint_arn
        if attributes is not None:
            self._build_dict_as_list_params(params, attributes, 'Attributes')
        return self._make_request(action='SetEndpointAttributes',
                                  params=params)

    def get_endpoint_attributes(self, endpoint_arn=None):
        """
        The `GetEndpointAttributes` retrieves the endpoint attributes
        for a device on one of the supported push notification
        services, such as GCM and APNS. For more information, see
        `Using Amazon SNS Mobile Push Notifications`_.

        :type endpoint_arn: string
        :param endpoint_arn: EndpointArn for GetEndpointAttributes input.

        """
        params = {}
        if endpoint_arn is not None:
            params['EndpointArn'] = endpoint_arn
        return self._make_request(action='GetEndpointAttributes',
                                  params=params)
<a name="7"></a>
    def _make_request(self, action, params, path='/', verb='GET'):
        params['ContentType'] = 'JSON'
        response = self.make_request(action<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=action, verb=verb,
                                     path=path, params=params)
        body = response.read().decode('utf-8')
        boto.log.debug(</b></font>body)
        if response.status == 200:
            return json.loads(body)
        else:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self.ResponseError(response.status, response.reason, body)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___99.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
# Copyright (c) 2009-2012 Mitch Garnaat http://garnaat.org/
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish, dis-
# tribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the fol-
# lowing conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
# ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
# SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import urllib
from boto.connection import AWSQueryConnection
from boto.rds.dbinstance import DBInstance
from boto.rds.dbsecuritygroup import DBSecurityGroup
from boto.rds.optiongroup  import OptionGroup, OptionGroupOption
from boto.rds.parametergroup import ParameterGroup
from boto.rds.dbsnapshot import DBSnapshot
from boto.rds.event import Event
from boto.rds.regioninfo import RDSRegionInfo
from boto.rds.dbsubnetgroup import DBSubnetGroup
from boto.rds.vpcsecuritygroupmembership import VPCSecurityGroupMembership
from boto.regioninfo import get_regions
from boto.regioninfo import connect
from boto.rds.logfile import LogFile, LogFileObject


def regions():
    """
    Get all available regions for the RDS service.

    :rtype: list
    :return: A list of :class:`boto.rds.regioninfo.RDSRegionInfo`
    """
    return get_regions(
        'rds',
        region_cls=RDSRegionInfo,
        connection_cls=RDSConnection
    )


def connect_to_region(region_name, **kw_params):
    """
    Given a valid region name, return a
    :class:`boto.rds.RDSConnection`.
    Any additional parameters after the region_name are passed on to
    the connect method of the region object.

    :type: str
    :param region_name: The name of the region to connect to.

    :rtype: :class:`boto.rds.RDSConnection` or ``None``
    :return: A connection to the given region, or None if an invalid region
             name is given
    """
    return connect('rds', region_name, region_cls=RDSRegionInfo,
                   connection_cls=RDSConnection, **kw_params)

#boto.set_stream_logger('rds')


class RDSConnection(AWSQueryConnection):

    DefaultRegionName = 'us-east-1'
<a name="1"></a>    DefaultRegionEndpoint = 'rds.amazonaws.com'
    APIVersion = '2013-05-15'

    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True,
                 profile_name=None):
        if not region:
            region = RDSRegionInfo(self, self.DefaultRegionName,
                                   self.</b></font>DefaultRegionEndpoint)
        self.region = region
        super(RDSConnection, self).__init__(aws_access_key_id,
                                    aws_secret_access_key,
                                    is_secure, port, proxy, proxy_port,
                                    proxy_user, proxy_pass,
                                    self.region.endpoint, debug,
                                    https_connection_factory, path,
                                    security_token,
                                    validate_certs=validate_certs,
                                    profile_name=profile_name)

    def _required_auth_capability(self):
        return ['hmac-v4']

    # DB Instance methods

    def get_all_dbinstances(self, instance_id=None, max_records=None,
                            marker=None):
        """
        Retrieve all the DBInstances in your account.

        :type instance_id: str
        :param instance_id: DB Instance identifier.  If supplied, only
                            information this instance will be returned.
                            Otherwise, info about all DB Instances will
                            be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbinstance.DBInstance`
        """
        params = {}
        if instance_id:
            params['DBInstanceIdentifier'] = instance_id
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBInstances', params,
                             [('DBInstance', DBInstance)])

    def create_dbinstance(self,
                          id,
                          allocated_storage,
                          instance_class,
                          master_username,
                          master_password,
                          port=3306,
                          engine='MySQL5.1',
                          db_name=None,
                          param_group=None,
                          security_groups=None,
                          availability_zone=None,
                          preferred_maintenance_window=None,
                          backup_retention_period=None,
                          preferred_backup_window=None,
                          multi_az=False,
                          engine_version=None,
<a name="7"></a>                          auto_minor_version_upgrade=True,
                          character_set_name = None,
                          db_subnet_group_name = None,
                          license_model <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= None,
                          option_group_name = None,
                          iops=None,
                          vpc_security_groups=None,
                          ):
        # API version: 2013-09-09
        # Parameter notes:
        # =================
        # id should be db_instance_identifier according to API docs but has been left
        # id for backwards compatibility
        #
        # security_groups should be db_security_groups according to API docs but has been left
        # security_groups for backwards compatibility
        #
        # master_password should be master_user_password according to API docs but has been left
        # master_password for backwards compatibility
        #
        # instance_class should be db_instance_class according to API docs but has been left
        # instance_class for backwards compatibility
        """
        Create a new DBInstance.

        :type id: str
        :param id: Unique identifier for the new instance.
                   Must contain 1-63 alphanumeric characters.
                   First character must be a letter.
                   May not end with a hyphen or contain two consecutive hyphens

        :type allocated_storage: int
        :param allocated_storage: Initially allocated storage size, in GBs.
                                  Valid values are depending on the engine value.

                                  * MySQL = 5--3072
                                  * oracle-se1 = 10--3072
                                  * oracle-se = 10--3072
                                  * oracle-ee = 10--3072
                                  * sqlserver-ee = 200--1024
                                  * sqlserver-se = 200--1024
                                  * sqlserver-ex = 30--1024
                                  * sqlserver-web = 30--1024
                                  * postgres = 5--3072

        :type instance_class: str
        :param instance_class: The compute and memory capacity of
                               the DBInstance. Valid values are:

                               * db.t1.micro
                               * db.m1.small
                               * db.m1.medium
                               * db.m1.large
                               * db.m1.xlarge
                               * db.m2.xlarge
                               * db.m2.2xlarge
                               * db.m2.4xlarge

        :type engine: str
        :param engine: Name of database engine. Defaults to MySQL but can be;

                       * MySQL
                       * oracle-se1
                       * oracle-se
                       * oracle-ee
                       * sqlserver-ee
                       * sqlserver-se
                       * sqlserver-ex
                       * sqlserver-web
                       * postgres

        :type master_username: str
        :param master_username: Name of master user for the DBInstance.

                                * MySQL must be;
                                  - 1--16 alphanumeric characters
                                  - first character must be a letter
                                  - cannot be a reserved MySQL word

                                * Oracle must be:
                                  - 1--30 alphanumeric characters
                                  - first character must be a letter
                                  - cannot be a reserved Oracle word

                                * SQL Server must be:
                                  - 1--128 alphanumeric characters
                                  - first character must be a letter
                                  - cannot be a reserver SQL Server word

        :type master_password: str
        :param master_password: Password of master user for the DBInstance.

                                * MySQL must be 8--41 alphanumeric characters

                                * Oracle must be 8--30 alphanumeric characters

                                * SQL Server must be 8--128 alphanumeric characters.

        :type port: int
        :param port: Port number on which database accepts connections.
                     Valid values [1115-65535].

                     * MySQL defaults to 3306

                     * Oracle defaults to 1521

                     * SQL Server defaults to 1433 and _cannot_ be 1434, 3389,
                       47001, 49152, and 49152 through 49156.

                     * PostgreSQL defaults to 5432

        :type db_name: str
        :param db_name: * MySQL:
                          Name of a database to create when the DBInstance
                          is created. Default is to create no databases.

                          Must contain 1--64 alphanumeric characters and cannot
                          be a reserved MySQL word.

                        * Oracle:
                          The Oracle System ID (SID) of the created DB instances.
                          Default is ORCL. Cannot be longer than 8 characters.

                        * SQL Server:
                          Not applicable and must be None.

                        * PostgreSQL:
                          Name of a database to create when the DBInstance
                          is created. Default is to create no databases.

                          Must contain 1--63 alphanumeric characters. Must
                          begin with a letter or an underscore. Subsequent
                          characters can be letters, underscores, or digits (0-9)
                          and cannot be a reserved PostgreSQL word.

        :type param_group: str or ParameterGroup object
        :param param_group: Name of DBParameterGroup or ParameterGroup instance
                            to associate with this DBInstance.  If no groups are
                            specified no parameter groups will be used.

        :type security_groups: list of str or list of DBSecurityGroup objects
        :param security_groups: List of names of DBSecurityGroup to
            authorize on this DBInstance.

        :type availability_zone: str
        :param availability_zone: Name of the availability zone to place
                                  DBInstance into.

        :type preferred_maintenance_window: str
        :param preferred_maintenance_window: The weekly time range (in UTC)
                                             during which maintenance can occur.
                                             Default is Sun:05:00-Sun:09:00

        :type backup_retention_period: int
        :param backup_retention_period: The number of days for which automated
                                        backups are retained.  Setting this to
                                        zero disables automated backups.

        :type preferred_backup_window: str
        :param preferred_backup_window: The daily time range during which
                                        automated backups are created (if
                                        enabled).  Must be in h24:mi-hh24:mi
                                        format (UTC).

        :type multi_az: bool
        :param multi_az: If True, specifies the DB Instance will be
                         deployed in multiple availability zones.

                         For Microsoft SQL Server, must be set to false. You cannot set
                         the AvailabilityZone parameter if the MultiAZ parameter is
                         set to true.

        :type engine_version: str
        :param engine_version: The version number of the database engine to use.

                               * MySQL format example: 5.1.42

                               * Oracle format example: 11.2.0.2.v2

                               * SQL Server format example: 10.50.2789.0.v1

                               * PostgreSQL format example: 9.3

        :type auto_minor_version_upgrade: bool
        :param auto_minor_version_upgrade: Indicates that minor engine
                                           upgrades will be applied
                                           automatically to the Read Replica
                                           during the maintenance window.
                                           Default is True.
        :type character_set_name: str
        :param character_set_name: For supported engines, indicates that the DB Instance
                                   should be associated with the specified CharacterSet.

        :type db_subnet_group_name: str
        :param db_subnet_group_name: A DB Subnet Group to associate with this DB Instance.
                                     If there is no DB Subnet Group, then it is a non-VPC DB
                                     instance.

        :type license_model: str
        :param license_model: License model information for this DB Instance.

                              Valid values are;
                              - license-included
                              - bring-your-own-license
                              - general-public-license

                              All license types are not supported on all engines.

        :type option_group_name: str
        :param option_group_name: Indicates that the DB Instance should be associated
                                  with the specified option group.

        :type iops: int
        :param iops:  The amount of IOPS (input/output operations per second) to Provisioned
                      for the DB Instance. Can be modified at a later date.

                      Must scale linearly. For every 1000 IOPS provision, you must allocated
                      100 GB of storage space. This scales up to 1 TB / 10 000 IOPS for MySQL
                      and Oracle. MSSQL is limited to 700 GB / 7 000 IOPS.

                      If you specify a value, it must be at least 1000 IOPS and you must
                      allocate 100 GB of storage.

        :type vpc_security_groups: list of str or a VPCSecurityGroupMembership object
        :param vpc_security_groups: List of VPC security group ids or a list of
            VPCSecurityGroupMembership objects this DBInstance should be a member of

        :rtype: :class:`boto.rds.dbinstance.DBInstance`
        :return: The new db instance.
        """
        # boto argument alignment with AWS API parameter names:
        # =====================================================
        # arg =&gt; AWS parameter
        # allocated_storage =&gt; AllocatedStorage
        # auto_minor_version_update =&gt; AutoMinorVersionUpgrade
        # availability_zone =&gt; AvailabilityZone
        # backup_retention_period =&gt; BackupRetentionPeriod
        # character_set_name =&gt; CharacterSetName
        # db_instance_class =&gt; DBInstanceClass
        # db_instance_identifier =&gt; DBInstanceIdentifier
        # db_name =&gt; DBName
        # db_parameter_group_name =&gt; DBParameterGroupName
        # db_security_groups =&gt; DBSecurityGroups.member.N
        # db_subnet_group_name =&gt; DBSubnetGroupName
        # engine =&gt; Engine
        # engine_version =&gt; EngineVersion
        # license_model =&gt; LicenseModel
        # master_username =&gt; MasterUsername
        # master_user_password =&gt; MasterUserPassword
        # multi_az =&gt; MultiAZ
        # option_group_name =&gt; OptionGroupName
        # port =&gt; Port
        # preferred_backup_window =&gt; PreferredBackupWindow
        # preferred_maintenance_window =&gt; PreferredMaintenanceWindow
        # vpc_security_groups =&gt; VpcSecurityGroupIds.member.N
        params = {
                  'AllocatedStorage': allocated_storage,
                  'AutoMinorVersionUpgrade': str(auto_minor_version_upgrade).lower() if auto_minor_version_upgrade else None,
                  'AvailabilityZone': availability_zone,
                  'BackupRetentionPeriod': backup_retention_period,
                  'CharacterSetName': character_set_name,
                  'DBInstanceClass': instance_class,
                  'DBInstanceIdentifier': id,
                  'DBName': db_name,
                  'DBParameterGroupName': (param_group.name
                                           if isinstance(</b></font>param_group, ParameterGroup)
                                           else param_group),
                  'DBSubnetGroupName': db_subnet_group_name,
                  'Engine': engine,
                  'EngineVersion': engine_version,
                  'Iops': iops,
                  'LicenseModel': license_model,
                  'MasterUsername': master_username,
                  'MasterUserPassword': master_password,
                  'MultiAZ': str(multi_az).lower() if multi_az else None,
                  'OptionGroupName': option_group_name,
                  'Port': port,
                  'PreferredBackupWindow': preferred_backup_window,
                  'PreferredMaintenanceWindow': preferred_maintenance_window,
                  }
        if security_groups:
            l = []
            for group in security_groups:
                if isinstance(group, DBSecurityGroup):
                    l.append(group.name)
                else:
                    l.append(group)
            self.build_list_params(params, l, 'DBSecurityGroups.member')

        if vpc_security_groups:
            l = []
            for vpc_grp in vpc_security_groups:
                if isinstance(vpc_grp, VPCSecurityGroupMembership):
                    l.append(vpc_grp.vpc_group)
                else:
                    l.append(vpc_grp)
            self.build_list_params(params, l, 'VpcSecurityGroupIds.member')

        # Remove any params set to None
        for k, v in list(params.items()):
          if v is None: del(params[k])

        return self.get_object('CreateDBInstance', params, DBInstance)

    def create_dbinstance_read_replica(self, id, source_id,
                                       instance_class=None,
                                       port=3306,
                                       availability_zone=None,
                                       auto_minor_version_upgrade=None):
        """
        Create a new DBInstance Read Replica.

        :type id: str
        :param id: Unique identifier for the new instance.
                   Must contain 1-63 alphanumeric characters.
                   First character must be a letter.
                   May not end with a hyphen or contain two consecutive hyphens

        :type source_id: str
        :param source_id: Unique identifier for the DB Instance for which this
                          DB Instance will act as a Read Replica.

        :type instance_class: str
        :param instance_class: The compute and memory capacity of the
                               DBInstance.  Default is to inherit from
                               the source DB Instance.

                               Valid values are:

                               * db.m1.small
                               * db.m1.large
                               * db.m1.xlarge
                               * db.m2.xlarge
                               * db.m2.2xlarge
                               * db.m2.4xlarge

        :type port: int
        :param port: Port number on which database accepts connections.
                     Default is to inherit from source DB Instance.
                     Valid values [1115-65535].  Defaults to 3306.

        :type availability_zone: str
        :param availability_zone: Name of the availability zone to place
                                  DBInstance into.

        :type auto_minor_version_upgrade: bool
        :param auto_minor_version_upgrade: Indicates that minor engine
                                           upgrades will be applied
                                           automatically to the Read Replica
                                           during the maintenance window.
                                           Default is to inherit this value
                                           from the source DB Instance.

        :rtype: :class:`boto.rds.dbinstance.DBInstance`
        :return: The new db instance.
        """
        params = {'DBInstanceIdentifier': id,
                  'SourceDBInstanceIdentifier': source_id}
        if instance_class:
            params['DBInstanceClass'] = instance_class
        if port:
            params['Port'] = port
        if availability_zone:
            params['AvailabilityZone'] = availability_zone
        if auto_minor_version_upgrade is not None:
            if auto_minor_version_upgrade is True:
                params['AutoMinorVersionUpgrade'] = 'true'
            else:
                params['AutoMinorVersionUpgrade'] = 'false'

        return self.get_object('CreateDBInstanceReadReplica',
                               params, DBInstance)


    def promote_read_replica(self, id,
                          backup_retention_period=None,
                          preferred_backup_window=None):
        """
        Promote a Read Replica to a standalone DB Instance.

        :type id: str
        :param id: Unique identifier for the new instance.
                   Must contain 1-63 alphanumeric characters.
                   First character must be a letter.
                   May not end with a hyphen or contain two consecutive hyphens

        :type backup_retention_period: int
        :param backup_retention_period: The number of days for which automated
                                        backups are retained.  Setting this to
                                        zero disables automated backups.

        :type preferred_backup_window: str
        :param preferred_backup_window: The daily time range during which
                                        automated backups are created (if
                                        enabled).  Must be in h24:mi-hh24:mi
                                        format (UTC).

        :rtype: :class:`boto.rds.dbinstance.DBInstance`
        :return: The new db instance.
        """
        params = {'DBInstanceIdentifier': id}
        if backup_retention_period is not None:
            params['BackupRetentionPeriod'] = backup_retention_period
        if preferred_backup_window:
            params['PreferredBackupWindow'] = preferred_backup_window

        return self.get_object('PromoteReadReplica', params, DBInstance)


    def modify_dbinstance(self, id, param_group=None, security_groups=None,
                          preferred_maintenance_window=None,
                          master_password=None, allocated_storage=None,
                          instance_class=None,
                          backup_retention_period=None,
                          preferred_backup_window=None,
                          multi_az=False,
                          apply_immediately=False,
                          iops=None,
                          vpc_security_groups=None,
                          new_instance_id=None,
                          ):
        """
        Modify an existing DBInstance.

        :type id: str
        :param id: Unique identifier for the new instance.

        :type param_group: str or ParameterGroup object
        :param param_group: Name of DBParameterGroup or ParameterGroup instance
                            to associate with this DBInstance.  If no groups are
                            specified no parameter groups will be used.

        :type security_groups: list of str or list of DBSecurityGroup objects
        :param security_groups: List of names of DBSecurityGroup to authorize on
                                this DBInstance.

        :type preferred_maintenance_window: str
        :param preferred_maintenance_window: The weekly time range (in UTC)
                                             during which maintenance can
                                             occur.
                                             Default is Sun:05:00-Sun:09:00

        :type master_password: str
        :param master_password: Password of master user for the DBInstance.
                                Must be 4-15 alphanumeric characters.

        :type allocated_storage: int
        :param allocated_storage: The new allocated storage size, in GBs.
                                  Valid values are [5-1024]

        :type instance_class: str
        :param instance_class: The compute and memory capacity of the
                               DBInstance.  Changes will be applied at
                               next maintenance window unless
                               apply_immediately is True.

                               Valid values are:

                               * db.m1.small
                               * db.m1.large
                               * db.m1.xlarge
                               * db.m2.xlarge
                               * db.m2.2xlarge
                               * db.m2.4xlarge

        :type apply_immediately: bool
        :param apply_immediately: If true, the modifications will be applied
                                  as soon as possible rather than waiting for
                                  the next preferred maintenance window.

        :type backup_retention_period: int
        :param backup_retention_period: The number of days for which automated
                                        backups are retained.  Setting this to
                                        zero disables automated backups.

        :type preferred_backup_window: str
        :param preferred_backup_window: The daily time range during which
                                        automated backups are created (if
                                        enabled).  Must be in h24:mi-hh24:mi
                                        format (UTC).

        :type multi_az: bool
        :param multi_az: If True, specifies the DB Instance will be
                         deployed in multiple availability zones.

        :type iops: int
        :param iops:  The amount of IOPS (input/output operations per second) to Provisioned
                      for the DB Instance. Can be modified at a later date.

                      Must scale linearly. For every 1000 IOPS provision, you must allocated
                      100 GB of storage space. This scales up to 1 TB / 10 000 IOPS for MySQL
                      and Oracle. MSSQL is limited to 700 GB / 7 000 IOPS.

                      If you specify a value, it must be at least 1000 IOPS and you must
                      allocate 100 GB of storage.

        :type vpc_security_groups: list of str or a VPCSecurityGroupMembership object
        :param vpc_security_groups: List of VPC security group ids or a
            VPCSecurityGroupMembership object this DBInstance should be a member of

        :type new_instance_id: str
        :param new_instance_id: New name to rename the DBInstance to.

        :rtype: :class:`boto.rds.dbinstance.DBInstance`
        :return: The modified db instance.
        """
        params = {'DBInstanceIdentifier': id}
        if param_group:
            params['DBParameterGroupName'] = (param_group.name
                                              if isinstance(param_group, ParameterGroup)
                                              else param_group)
        if security_groups:
            l = []
            for group in security_groups:
                if isinstance(group, DBSecurityGroup):
                    l.append(group.name)
                else:
                    l.append(group)
            self.build_list_params(params, l, 'DBSecurityGroups.member')
        if vpc_security_groups:
            l = []
            for vpc_grp in vpc_security_groups:
                if isinstance(vpc_grp, VPCSecurityGroupMembership):
                    l.append(vpc_grp.vpc_group)
                else:
                    l.append(vpc_grp)
            self.build_list_params(params, l, 'VpcSecurityGroupIds.member')
        if preferred_maintenance_window:
            params['PreferredMaintenanceWindow'] = preferred_maintenance_window
        if master_password:
            params['MasterUserPassword'] = master_password
        if allocated_storage:
            params['AllocatedStorage'] = allocated_storage
        if instance_class:
            params['DBInstanceClass'] = instance_class
        if backup_retention_period is not None:
            params['BackupRetentionPeriod'] = backup_retention_period
        if preferred_backup_window:
            params['PreferredBackupWindow'] = preferred_backup_window
        if multi_az:
            params['MultiAZ'] = 'true'
        if apply_immediately:
            params['ApplyImmediately'] = 'true'
        if iops:
            params['Iops'] = iops
        if new_instance_id:
            params['NewDBInstanceIdentifier'] = new_instance_id

        return self.get_object('ModifyDBInstance', params, DBInstance)

    def delete_dbinstance(self, id, skip_final_snapshot=False,
                          final_snapshot_id=''):
        """
        Delete an existing DBInstance.

        :type id: str
        :param id: Unique identifier for the new instance.

        :type skip_final_snapshot: bool
        :param skip_final_snapshot: This parameter determines whether a final
                                    db snapshot is created before the instance
                                    is deleted.  If True, no snapshot
                                    is created.  If False, a snapshot
                                    is created before deleting the instance.

        :type final_snapshot_id: str
        :param final_snapshot_id: If a final snapshot is requested, this
                                  is the identifier used for that snapshot.

        :rtype: :class:`boto.rds.dbinstance.DBInstance`
        :return: The deleted db instance.
        """
        params = {'DBInstanceIdentifier': id}
        if skip_final_snapshot:
            params['SkipFinalSnapshot'] = 'true'
        else:
            params['SkipFinalSnapshot'] = 'false'
            params['FinalDBSnapshotIdentifier'] = final_snapshot_id
        return self.get_object('DeleteDBInstance', params, DBInstance)

    def reboot_dbinstance(self, id):
        """
        Reboot DBInstance.

        :type id: str
        :param id: Unique identifier of the instance.

        :rtype: :class:`boto.rds.dbinstance.DBInstance`
<a name="3"></a>        :return: The rebooting db instance.
        """
        params = {'DBInstanceIdentifier': id}
        <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return self.get_object('RebootDBInstance', params, DBInstance)

    # DBParameterGroup methods

    def get_all_dbparameter_groups(self, groupname=None, max_records=None,
                                  marker=None):
        """
        Get all parameter groups associated with your account in a region.

        :type groupname: str
        :param groupname: The name of the DBParameter group to retrieve.
                          If not provided, all DBParameter groups will be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.ec2.parametergroup.ParameterGroup`
        """
        params = {}
        if groupname:
            params['DBParameterGroupName'] = groupname
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params[</b></font>'Marker'] = marker
        return self.get_list('DescribeDBParameterGroups', params,
                             [('DBParameterGroup', ParameterGroup)])

    def get_all_dbparameters(self, groupname, source=None,
                             max_records=None, marker=None):
        """
        Get all parameters associated with a ParameterGroup

        :type groupname: str
        :param groupname: The name of the DBParameter group to retrieve.

        :type source: str
        :param source: Specifies which parameters to return.
                       If not specified, all parameters will be returned.
                       Valid values are: user|system|engine-default

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: :class:`boto.ec2.parametergroup.ParameterGroup`
        :return: The ParameterGroup
        """
        params = {'DBParameterGroupName': groupname}
        if source:
            params['Source'] = source
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        pg = self.get_object('DescribeDBParameters', params, ParameterGroup)
        pg.name = groupname
        return pg

    def create_parameter_group(self, name, engine='MySQL5.1', description=''):
        """
        Create a new dbparameter group for your account.

        :type name: string
        :param name: The name of the new dbparameter group

        :type engine: str
        :param engine: Name of database engine.

        :type description: string
        :param description: The description of the new dbparameter group

        :rtype: :class:`boto.rds.parametergroup.ParameterGroup`
        :return: The newly created ParameterGroup
        """
        params = {'DBParameterGroupName': name,
                  'DBParameterGroupFamily': engine,
                  'Description': description}
        return self.get_object('CreateDBParameterGroup', params, ParameterGroup)

    def modify_parameter_group(self, name, parameters=None):
        """
        Modify a ParameterGroup for your account.

        :type name: string
        :param name: The name of the new ParameterGroup

        :type parameters: list of :class:`boto.rds.parametergroup.Parameter`
        :param parameters: The new parameters

        :rtype: :class:`boto.rds.parametergroup.ParameterGroup`
        :return: The newly created ParameterGroup
        """
        params = {'DBParameterGroupName': name}
        for i in range(0, len(parameters)):
            parameter = parameters[i]
            parameter.merge(params, i+1)
        return self.get_list('ModifyDBParameterGroup', params,
                             ParameterGroup, verb='POST')

    def reset_parameter_group(self, name, reset_all_params=False,
                              parameters=None):
        """
        Resets some or all of the parameters of a ParameterGroup to the
        default value

        :type key_name: string
        :param key_name: The name of the ParameterGroup to reset

        :type parameters: list of :class:`boto.rds.parametergroup.Parameter`
        :param parameters: The parameters to reset.  If not supplied,
                           all parameters will be reset.
        """
        params = {'DBParameterGroupName': name}
        if reset_all_params:
            params['ResetAllParameters'] = 'true'
        else:
<a name="5"></a>            params['ResetAllParameters'] = 'false'
            for i in range(0, len(parameters)):
                parameter = parameters[i]
                parameter.merge(<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>params, i+1)
        return self.get_status('ResetDBParameterGroup', params)

    def delete_parameter_group(self, name):
        """
        Delete a ParameterGroup from your account.

        :type key_name: string
        :param key_name: The name of the ParameterGroup to delete
        """
        params = {'DBParameterGroupName': name}
        return self.get_status('DeleteDBParameterGroup', params)

    # DBSecurityGroup methods

    def get_all_dbsecurity_groups(self, groupname=</b></font>None, max_records=None,
                                  marker=None):
        """
        Get all security groups associated with your account in a region.

        :type groupnames: list
        :param groupnames: A list of the names of security groups to retrieve.
                           If not provided, all security groups will
                           be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbsecuritygroup.DBSecurityGroup`
        """
        params = {}
        if groupname:
            params['DBSecurityGroupName'] = groupname
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeDBSecurityGroups', params,
                             [('DBSecurityGroup', DBSecurityGroup)])

    def create_dbsecurity_group(self, name, description=None):
        """
        Create a new security group for your account.
        This will create the security group within the region you
        are currently connected to.

        :type name: string
        :param name: The name of the new security group

        :type description: string
        :param description: The description of the new security group

        :rtype: :class:`boto.rds.dbsecuritygroup.DBSecurityGroup`
        :return: The newly created DBSecurityGroup
        """
        params = {'DBSecurityGroupName': name}
        if description:
            params['DBSecurityGroupDescription'] = description
        group = self.get_object('CreateDBSecurityGroup', params,
                                DBSecurityGroup)
        group.name = name
        group.description = description
        return group

    def delete_dbsecurity_group(self, name):
        """
        Delete a DBSecurityGroup from your account.

        :type key_name: string
        :param key_name: The name of the DBSecurityGroup to delete
        """
        params = {'DBSecurityGroupName': name}
        return self.get_status('DeleteDBSecurityGroup', params)

    def authorize_dbsecurity_group(self, group_name, cidr_ip=None,
                                   ec2_security_group_name=None,
                                   ec2_security_group_owner_id=None):
        """
        Add a new rule to an existing security group.
        You need to pass in either src_security_group_name and
        src_security_group_owner_id OR a CIDR block but not both.

        :type group_name: string
        :param group_name: The name of the security group you are adding
                           the rule to.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The name of the EC2 security group
                                        you are granting access to.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The ID of the owner of the EC2
                                            security group you are granting
                                            access to.

        :type cidr_ip: string
        :param cidr_ip: The CIDR block you are providing access to.
                        See http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

        :rtype: bool
        :return: True if successful.
        """
        params = {'DBSecurityGroupName': group_name}
        if ec2_security_group_name:
            params['EC2SecurityGroupName'] = ec2_security_group_name
        if ec2_security_group_owner_id:
            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id
        if cidr_ip:
            params['CIDRIP'] = urllib.quote(cidr_ip)
        return self.get_object('AuthorizeDBSecurityGroupIngress', params,
                               DBSecurityGroup)

    def revoke_dbsecurity_group(self, group_name, ec2_security_group_name=None,
                                ec2_security_group_owner_id=None, cidr_ip=None):
        """
        Remove an existing rule from an existing security group.
        You need to pass in either ec2_security_group_name and
        ec2_security_group_owner_id OR a CIDR block.

        :type group_name: string
        :param group_name: The name of the security group you are removing
                           the rule from.

        :type ec2_security_group_name: string
        :param ec2_security_group_name: The name of the EC2 security group
                                        from which you are removing access.

        :type ec2_security_group_owner_id: string
        :param ec2_security_group_owner_id: The ID of the owner of the EC2
                                            security from which you are
                                            removing access.

        :type cidr_ip: string
        :param cidr_ip: The CIDR block from which you are removing access.
                        See http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

        :rtype: bool
        :return: True if successful.
        """
        params = {'DBSecurityGroupName': group_name}
        if ec2_security_group_name:
            params['EC2SecurityGroupName'] = ec2_security_group_name
        if ec2_security_group_owner_id:
            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id
        if cidr_ip:
            params['CIDRIP'] = cidr_ip
        return self.get_object('RevokeDBSecurityGroupIngress', params,
                               DBSecurityGroup)

    # For backwards compatibility.  This method was improperly named
    # in previous versions.  I have renamed it to match the others.
    revoke_security_group = revoke_dbsecurity_group
<a name="2"></a>
    # DBSnapshot methods

    <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def get_all_dbsnapshots(self, snapshot_id=None, instance_id=None,
                            max_records=None, marker=None):
        """
        Get information about DB Snapshots.

        :type snapshot_id: str
        :param snapshot_id: The unique identifier of an RDS snapshot.
                            If not provided, all RDS snapshots will be returned.

        :type instance_id: str
        :param instance_id: The identifier of a DBInstance.  If provided,
                            only the DBSnapshots related to that instance will
                            be returned.
                            If not provided, all RDS snapshots will be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbsnapshot.DBSnapshot`
        """
        params = {}
        if snapshot_id:
            params['DBSnapshotIdentifier'] = snapshot_id
        if instance_id:
            params['DBInstanceIdentifier'] = instance_id
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params[</b></font>'Marker'] = marker
        return self.get_list('DescribeDBSnapshots', params,
                             [('DBSnapshot', DBSnapshot)])

    def get_all_logs(self, dbinstance_id, max_records=None, marker=None, file_size=None, filename_contains=None, file_last_written=None):
        """
        Get all log files

        :type instance_id: str
        :param instance_id: The identifier of a DBInstance.

        :type max_records: int
        :param max_records: Number of log file names to return.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :file_size: int
        :param file_size: Filter results to files large than this size in bytes.

        :filename_contains: str
        :param filename_contains: Filter results to files with filename containing this string

        :file_last_written: int
        :param file_last_written: Filter results to files written after this time (POSIX timestamp)

<a name="4"></a>        :rtype: list
        :return: A list of :class:`boto.rds.logfile.LogFile`
        """
        params <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {'DBInstanceIdentifier': dbinstance_id}

        if file_size:
            params['FileSize'] = file_size

        if filename_contains:
            params['FilenameContains'] = filename_contains

        if file_last_written:
            params['FileLastWritten'] = file_last_written

        if marker:
            params['Marker'] = marker

        if</b></font> max_records:
            params['MaxRecords'] = max_records

        return self.get_list('DescribeDBLogFiles', params,
                             [('DescribeDBLogFilesDetails',LogFile)])

    def get_log_file(self, dbinstance_id, log_file_name, marker=None, number_of_lines=None, max_records=None):
        """
        Download a log file from RDS

        :type instance_id: str
        :param instance_id: The identifier of a DBInstance.

        :type log_file_name: str
        :param log_file_name: The name of the log file to retrieve

        :type marker: str
        :param marker: A marker returned from a previous call to this method, or 0 to indicate the start of file. If
                       no marker is specified, this will fetch log lines from the end of file instead.

        :type number_of_lines: int
        :param marker: The maximium number of lines to be returned.
        """

        params = {
                'DBInstanceIdentifier': dbinstance_id,
                'LogFileName': log_file_name,
                }

        if marker:
            params['Marker'] = marker

        if number_of_lines:
            params['NumberOfLines'] = number_of_lines

        if max_records:
            params['MaxRecords'] = max_records

        logfile =  self.get_object('DownloadDBLogFilePortion', params, LogFileObject)

        if logfile:
<a name="0"></a>            logfile.log_filename = log_file_name
            logfile.dbinstance_id = dbinstance_id

        r<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn logfile

    def create_dbsnapshot(self, snapshot_id, dbinstance_id):
        """
        Create a new DB snapshot.

        :type snapshot_id: string
        :param snapshot_id: The identifier for the DBSnapshot

        :type dbinstance_id: string
        :param dbinstance_id: The source identifier for the RDS instance from
                              which the snapshot is created.

        :rtype: :class:`boto.rds.dbsnapshot.DBSnapshot`
        :return: The newly created DBSnapshot
        """
        params = {'DBSnapshotIdentifier': snapshot_id,
                  'DBInstanceIdentifier': dbinstance_id}
        return self.get_object('CreateDBSnapshot', params, DBSnapshot)

    def copy_dbsnapshot(self, source_snapshot_id, target_snapshot_id):
        """
        Copies the specified DBSnapshot.

        :type source_snapshot_id: string
        :param source_snapshot_id: The identifier for the source DB snapshot.

        :type target_snapshot_id: string
        :param target_snapshot_id: The identifier for the copied snapshot.

        :rtype: :class:`boto.rds.dbsnapshot.DBSnapshot`
        :return: The newly created DBSnapshot.
        """
        params = {'SourceDBSnapshotIdentifier': source_snapshot_id,
                  'TargetDBSnapshotIdentifier': target_snapshot_id}
        return self.get_object('CopyDBSnapshot', params, DBSnapshot)

    def delete_dbsnapshot(self, identifier):
        """
        Delete a DBSnapshot

        :type identifier: string
        :param identifier: The identifier of the DBSnapshot to delete
        """
        params = {'DBSnapshotIdentifier': identifier}
        return self.get_object('DeleteDBSnapshot', params, DBSnapshot)

    def restore_dbinstance_from_dbsnapshot(self, identifier, instance_id,
                                           instance_class, port=None,
                                           availability_zone=None,
                                           multi_az=None,
                                           auto_minor_version_upgrade=None,
                                           db_subnet_group_name=None):
        """
        Create a new DBInstance from a DB snapshot.

        :type identifier: string
        :param identifier: The identifier for the DBSnapshot

        :type instance_id: string
        :param instance_id: The source identifier for the RDS instance from
                              which the snapshot is created.

        :type instance_class: str
        :param instance_class: The compute and memory capacity of the
                               DBInstance.  Valid values are:
                               db.m1.small | db.m1.large | db.m1.xlarge |
                               db.m2.2xlarge | db.m2.4xlarge

        :type port: int
        :param port: Port number on which database accepts connections.
                     Valid values [1115-65535].  Defaults to 3306.

        :type availability_zone: str
        :param availability_zone: Name of the availability zone to place
                                  DBInstance into.

        :type multi_az: bool
        :param multi_az: If True, specifies the DB Instance will be
                         deployed in multiple availability zones.
                         Default is the API default.

        :type auto_minor_version_upgrade: bool
        :param auto_minor_version_upgrade: Indicates that minor engine
                                           upgrades will be applied
                                           automatically to the Read Replica
                                           during the maintenance window.
                                           Default is the API default.

        :type db_subnet_group_name: str
        :param db_subnet_group_name: A DB Subnet Group to associate with this DB Instance.
                                     If there is no DB Subnet Group, then it is a non-VPC DB
                                     instance.

        :rtype: :class:`boto.rds.dbinstance.DBInstance`
        :return: The newly created DBInstance
        """
        params =</b></font> {'DBSnapshotIdentifier': identifier,
                  'DBInstanceIdentifier': instance_id,
                  'DBInstanceClass': instance_class}
        if port:
            params['Port'] = port
        if availability_zone:
            params['AvailabilityZone'] = availability_zone
        if multi_az is not None:
            params['MultiAZ'] = str(multi_az).lower()
        if auto_minor_version_upgrade is not None:
            params['AutoMinorVersionUpgrade'] = str(auto_minor_version_upgrade).lower()
        if db_subnet_group_name is not None:
            params['DBSubnetGroupName'] = db_subnet_group_name
        return self.get_object('RestoreDBInstanceFromDBSnapshot',
                               params, DBInstance)

    def restore_dbinstance_from_point_in_time(self, source_instance_id,
                                              target_instance_id,
                                              use_latest=False,
                                              restore_time=None,
                                              dbinstance_class=None,
                                              port=None,
                                              availability_zone=None,
                                              db_subnet_group_name=None):

        """
        Create a new DBInstance from a point in time.

        :type source_instance_id: string
        :param source_instance_id: The identifier for the source DBInstance.

        :type target_instance_id: string
        :param target_instance_id: The identifier of the new DBInstance.

        :type use_latest: bool
        :param use_latest: If True, the latest snapshot availabile will
                           be used.

        :type restore_time: datetime
        :param restore_time: The date and time to restore from.  Only
                             used if use_latest is False.

        :type instance_class: str
        :param instance_class: The compute and memory capacity of the
                               DBInstance.  Valid values are:
                               db.m1.small | db.m1.large | db.m1.xlarge |
                               db.m2.2xlarge | db.m2.4xlarge

        :type port: int
        :param port: Port number on which database accepts connections.
                     Valid values [1115-65535].  Defaults to 3306.

        :type availability_zone: str
        :param availability_zone: Name of the availability zone to place
                                  DBInstance into.

        :type db_subnet_group_name: str
        :param db_subnet_group_name: A DB Subnet Group to associate with this DB Instance.
                                     If there is no DB Subnet Group, then it is a non-VPC DB
                                     instance.

        :rtype: :class:`boto.rds.dbinstance.DBInstance`
        :return: The newly created DBInstance
        """
        params = {'SourceDBInstanceIdentifier': source_instance_id,
                  'TargetDBInstanceIdentifier': target_instance_id}
        if use_latest:
            params['UseLatestRestorableTime'] = 'true'
        elif restore_time:
            params['RestoreTime'] = restore_time.isoformat()
        if dbinstance_class:
            params['DBInstanceClass'] = dbinstance_class
        if port:
            params['Port'] = port
        if availability_zone:
            params['AvailabilityZone'] = availability_zone
        if db_subnet_group_name is not None:
            params['DBSubnetGroupName'] = db_subnet_group_name
        return self.get_object('RestoreDBInstanceToPointInTime',
                               params, DBInstance)

    # Events

    def get_all_events(self, source_identifier=None, source_type=None,
                       start_time=None, end_time=None,
                       max_records=None, marker=None):
        """
        Get information about events related to your DBInstances,
        DBSecurityGroups and DBParameterGroups.

        :type source_identifier: str
        :param source_identifier: If supplied, the events returned will be
                                  limited to those that apply to the identified
                                  source.  The value of this parameter depends
                                  on the value of source_type.  If neither
                                  parameter is specified, all events in the time
                                  span will be returned.

        :type source_type: str
        :param source_type: Specifies how the source_identifier should
                            be interpreted.  Valid values are:
                            b-instance | db-security-group |
                            db-parameter-group | db-snapshot

        :type start_time: datetime
        :param start_time: The beginning of the time interval for events.
                           If not supplied, all available events will
                           be returned.

        :type end_time: datetime
        :param end_time: The ending of the time interval for events.
                         If not supplied, all available events will
                         be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of class:`boto.rds.event.Event`
        """
        params = {}
        if source_identifier and source_type:
            params['SourceIdentifier'] = source_identifier
            params['SourceType'] = source_type
        if start_time:
            params['StartTime'] = start_time.isoformat()
        if end_time:
            params['EndTime'] = end_time.isoformat()
        if max_records:
            params['MaxRecords'] = max_records
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeEvents', params, [('Event', Event)])

    def create_db_subnet_group(self, name, desc, subnet_ids):
        """
        Create a new Database Subnet Group.

        :type name: string
        :param name: The identifier for the db_subnet_group

        :type desc: string
        :param desc: A description of the db_subnet_group

        :type subnet_ids: list
        :param subnets: A list of the subnet identifiers to include in the
                        db_subnet_group

        :rtype: :class:`boto.rds.dbsubnetgroup.DBSubnetGroup
        :return: the created db_subnet_group
        """

        params = {'DBSubnetGroupName': name,
<a name="6"></a>                  'DBSubnetGroupDescription': desc}
        self.build_list_params(params, subnet_ids, 'SubnetIds.member')

        <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return self.get_object('CreateDBSubnetGroup', params, DBSubnetGroup)

    def delete_db_subnet_group(self, name):
        """
        Delete a Database Subnet Group.

        :type name: string
        :param name: The identifier of the db_subnet_group to delete

        :rtype: :class:`boto.rds.dbsubnetgroup.DBSubnetGroup`
        :return: The deleted db_subnet_group.
        """

        params = {'DBSubnetGroupName': name}

        return self.get_object('DeleteDBSubnetGroup', params, DBSubnetGroup)


    def get_all_db_subnet_groups(self, name=None, max_records=</b></font>None, marker=None):
        """
        Retrieve all the DBSubnetGroups in your account.

        :type name: str
        :param name: DBSubnetGroup name If supplied, only information about
                     this DBSubnetGroup will be returned. Otherwise, info
                     about all DBSubnetGroups will be returned.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a Token will be
                            returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of :class:`boto.rds.dbsubnetgroup.DBSubnetGroup`
        """
        params = dict()
        if name is not None:
            params['DBSubnetGroupName'] = name
        if max_records is not None:
            params['MaxRecords'] = max_records
        if marker is not None:
            params['Marker'] = marker

        return self.get_list('DescribeDBSubnetGroups', params, [('DBSubnetGroup',DBSubnetGroup)])

    def modify_db_subnet_group(self, name, description=None, subnet_ids=None):
        """
        Modify a parameter group for your account.

        :type name: string
        :param name: The name of the new parameter group

        :type parameters: list of :class:`boto.rds.parametergroup.Parameter`
        :param parameters: The new parameters

        :rtype: :class:`boto.rds.parametergroup.ParameterGroup`
        :return: The newly created ParameterGroup
        """
        params = {'DBSubnetGroupName': name}
        if description is not None:
            params['DBSubnetGroupDescription'] = description
        if subnet_ids is not None:
            self.build_list_params(params, subnet_ids, 'SubnetIds.member')

        return self.get_object('ModifyDBSubnetGroup', params, DBSubnetGroup)

    def create_option_group(self, name, engine_name, major_engine_version,
                            description=None):
        """
        Create a new option group for your account.
        This will create the option group within the region you
        are currently connected to.

        :type name: string
        :param name: The name of the new option group

        :type engine_name: string
        :param engine_name: Specifies the name of the engine that this option
                            group should be associated with.

        :type major_engine_version: string
        :param major_engine_version: Specifies the major version of the engine
                                     that this option group should be
                                     associated with.

        :type description: string
        :param description: The description of the new option group

        :rtype: :class:`boto.rds.optiongroup.OptionGroup`
        :return: The newly created OptionGroup
        """
        params = {
            'OptionGroupName': name,
            'EngineName': engine_name,
            'MajorEngineVersion': major_engine_version,
            'OptionGroupDescription': description,
        }
        group = self.get_object('CreateOptionGroup', params, OptionGroup)
        group.name = name
        group.engine_name = engine_name
        group.major_engine_version = major_engine_version
        group.description = description
        return group

    def delete_option_group(self, name):
        """
        Delete an OptionGroup from your account.

        :type key_name: string
        :param key_name: The name of the OptionGroup to delete
        """
        params = {'OptionGroupName': name}
        return self.get_status('DeleteOptionGroup', params)

    def describe_option_groups(self, name=None, engine_name=None,
                               major_engine_version=None, max_records=100,
                               marker=None):
        """
        Describes the available option groups.

        :type name: str
        :param name: The name of the option group to describe. Cannot be
                     supplied together with engine_name or major_engine_version.

        :type engine_name: str
        :param engine_name: Filters the list of option groups to only include
                            groups associated with a specific database engine.

        :type major_engine_version: datetime
        :param major_engine_version: Filters the list of option groups to only
                                     include groups associated with a specific
                                     database engine version. If specified, then
                                     engine_name must also be specified.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of class:`boto.rds.optiongroup.OptionGroup`
        """
        params = {}
        if name:
            params['OptionGroupName'] = name
        elif engine_name and major_engine_version:
            params['EngineName'] = engine_name
            params['MajorEngineVersion'] = major_engine_version
        if max_records:
            params['MaxRecords'] = int(max_records)
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeOptionGroups', params, [
            ('OptionGroup', OptionGroup)
        ])

    def describe_option_group_options(self, engine_name=None,
                               major_engine_version=None, max_records=100,
                               marker=None):
        """
        Describes the available option group options.

        :type engine_name: str
        :param engine_name: Filters the list of option groups to only include
                            groups associated with a specific database engine.

        :type major_engine_version: datetime
        :param major_engine_version: Filters the list of option groups to only
                                     include groups associated with a specific
                                     database engine version. If specified, then
                                     engine_name must also be specified.

        :type max_records: int
        :param max_records: The maximum number of records to be returned.
                            If more results are available, a MoreToken will
                            be returned in the response that can be used to
                            retrieve additional records.  Default is 100.

        :type marker: str
        :param marker: The marker provided by a previous request.

        :rtype: list
        :return: A list of class:`boto.rds.optiongroup.Option`
        """
        params = {}
        if engine_name and major_engine_version:
            params['EngineName'] = engine_name
            params['MajorEngineVersion'] = major_engine_version
        if max_records:
            params['MaxRecords'] = int(max_records)
        if marker:
            params['Marker'] = marker
        return self.get_list('DescribeOptionGroupOptions', params, [
            ('OptionGroupOptions', OptionGroupOption)
        ])
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
