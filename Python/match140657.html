<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_status.py &amp; tls_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_status.py &amp; tls_1.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_status.py (5.863192%)<th>tls_1.py (1.5964524%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(580-584)<td><a href="#" name="0">(799-811)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(253-258)<td><a href="#" name="1">(1685-1691)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(12-28)<td><a href="#" name="2">(103-119)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import ctypes
import datetime
import logging
import subprocess
import salt.utils.event
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.win_pdh
from salt.modules.status import ping_master, time_
from salt.utils.functools import namespaced_function as _namespaced_function
from salt.utils.network import host_to_ips as _host_to_ips
log =</b></font> logging.getLogger(__name__)
try:
    if salt.utils.platform.is_windows():
        import wmi
        import salt.utils.winapi
        HAS_WMI = True
    else:
        HAS_WMI = False
except ImportError:
    HAS_WMI = False
HAS_PSUTIL = False
if salt.utils.platform.is_windows():
    import psutil
    HAS_PSUTIL = True
__opts__ = {}
__virtualname__ = "status"
class SYSTEM_PERFORMANCE_INFORMATION(ctypes.Structure):
    _fields_ = [
        ("IdleProcessTime", ctypes.c_int64),
        ("IoReadTransferCount", ctypes.c_int64),
        ("IoWriteTransferCount", ctypes.c_int64),
        ("IoOtherTransferCount", ctypes.c_int64),
        ("IoReadOperationCount", ctypes.c_ulong),
        ("IoWriteOperationCount", ctypes.c_ulong),
        ("IoOtherOperationCount", ctypes.c_ulong),
        ("AvailablePages", ctypes.c_ulong),
        ("CommittedPages", ctypes.c_ulong),
        ("CommitLimit", ctypes.c_ulong),
        ("PeakCommitment", ctypes.c_ulong),
        ("PageFaultCount", ctypes.c_ulong),
        ("CopyOnWriteCount", ctypes.c_ulong),
        ("TransitionCount", ctypes.c_ulong),
        ("CacheTransitionCount", ctypes.c_ulong),
        ("DemandZeroCount", ctypes.c_ulong),
        ("PageReadCount", ctypes.c_ulong),
        ("PageReadIoCount", ctypes.c_ulong),
        ("CacheReadCount", ctypes.c_ulong),  # Was c_ulong ** 2
        ("CacheIoCount", ctypes.c_ulong),
        ("DirtyPagesWriteCount", ctypes.c_ulong),
        ("DirtyWriteIoCount", ctypes.c_ulong),
        ("MappedPagesWriteCount", ctypes.c_ulong),
        ("MappedWriteIoCount", ctypes.c_ulong),
        ("PagedPoolPages", ctypes.c_ulong),
        ("NonPagedPoolPages", ctypes.c_ulong),
        ("PagedPoolAllocs", ctypes.c_ulong),
        ("PagedPoolFrees", ctypes.c_ulong),
        ("NonPagedPoolAllocs", ctypes.c_ulong),
        ("NonPagedPoolFrees", ctypes.c_ulong),
        ("FreeSystemPtes", ctypes.c_ulong),
        ("ResidentSystemCodePage", ctypes.c_ulong),
        ("TotalSystemDriverPages", ctypes.c_ulong),
        ("TotalSystemCodePages", ctypes.c_ulong),
        ("NonPagedPoolLookasideHits", ctypes.c_ulong),
        ("PagedPoolLookasideHits", ctypes.c_ulong),
        ("AvailablePagedPoolPages", ctypes.c_ulong),
        ("ResidentSystemCachePage", ctypes.c_ulong),
        ("ResidentPagedPoolPage", ctypes.c_ulong),
        ("ResidentSystemDriverPage", ctypes.c_ulong),
        ("CcFastReadNoWait", ctypes.c_ulong),
        ("CcFastReadWait", ctypes.c_ulong),
        ("CcFastReadResourceMiss", ctypes.c_ulong),
        ("CcFastReadNotPossible", ctypes.c_ulong),
        ("CcFastMdlReadNoWait", ctypes.c_ulong),
        ("CcFastMdlReadWait", ctypes.c_ulong),
        ("CcFastMdlReadResourceMiss", ctypes.c_ulong),
        ("CcFastMdlReadNotPossible", ctypes.c_ulong),
        ("CcMapDataNoWait", ctypes.c_ulong),
        ("CcMapDataWait", ctypes.c_ulong),
        ("CcMapDataNoWaitMiss", ctypes.c_ulong),
        ("CcMapDataWaitMiss", ctypes.c_ulong),
        ("CcPinMappedDataCount", ctypes.c_ulong),
        ("CcPinReadNoWait", ctypes.c_ulong),
        ("CcPinReadWait", ctypes.c_ulong),
        ("CcPinReadNoWaitMiss", ctypes.c_ulong),
        ("CcPinReadWaitMiss", ctypes.c_ulong),
        ("CcCopyReadNoWait", ctypes.c_ulong),
        ("CcCopyReadWait", ctypes.c_ulong),
        ("CcCopyReadNoWaitMiss", ctypes.c_ulong),
        ("CcCopyReadWaitMiss", ctypes.c_ulong),
        ("CcMdlReadNoWait", ctypes.c_ulong),
        ("CcMdlReadWait", ctypes.c_ulong),
        ("CcMdlReadNoWaitMiss", ctypes.c_ulong),
        ("CcMdlReadWaitMiss", ctypes.c_ulong),
        ("CcReadAheadIos", ctypes.c_ulong),
        ("CcLazyWriteIos", ctypes.c_ulong),
        ("CcLazyWritePages", ctypes.c_ulong),
        ("CcDataFlushes", ctypes.c_ulong),
        ("CcDataPages", ctypes.c_ulong),
        ("ContextSwitches", ctypes.c_ulong),
        ("FirstLevelTbFills", ctypes.c_ulong),
        ("SecondLevelTbFills", ctypes.c_ulong),
        ("SystemCalls", ctypes.c_ulong),
        ("CcTotalDirtyPages", ctypes.c_ulonglong),
        ("CcDirtyPagesThreshold", ctypes.c_ulonglong),
        ("ResidentAvailablePages", ctypes.c_longlong),
        ("SharedCommittedPages", ctypes.c_ulonglong),
    ]
def __virtual__():
    if not salt.utils.platform.is_windows():
        return False, "win_status.py: Requires Windows"
    if not HAS_WMI:
        return False, "win_status.py: Requires WMI and WinAPI"
    if not HAS_PSUTIL:
        return False, "win_status.py: Requires psutil"
    global ping_master, time_
    ping_master = _namespaced_function(ping_master, globals())
    time_ = _namespaced_function(time_, globals())
    return __virtualname__
__func_alias__ = {"time_": "time"}
def cpustats():
    user, system, idle, interrupt, dpc = psutil.cpu_times()
    cpu = {"user": user, "system": system, "idle": idle, "irq": interrupt, "dpc": dpc}
    ctx_switches, interrupts, soft_interrupts, sys_calls = psutil.cpu_stats()
    intr = {"irqs": {"irqs": [], "total": interrupts}}
    soft_irq = {"softirqs": [], "total": soft_interrupts}
    return {
        "btime": psutil.boot_time(),
        "cpu": cpu,
        "ctxt": ctx_switches,
        "intr": intr,
        "processes": len(psutil.pids()),
        "softirq": soft_irq,
        "syscalls": sys_calls,
    }
def meminfo():
    vm_total, vm_available, vm_percent, vm_used, vm_free = psutil.virtual_memory()
    swp_total, swp_used, swp_free, swp_percent, _, _ = psutil.swap_memory()
    def get_unit_value(memory):
        symbols = ("K", "M", "G", "T", "P", "E", "Z", "Y")
        prefix = {}
        for i, s in enumerate(symbols):
            prefix[s] = 1 &lt;&lt; (i + 1) * 10
        for s in reversed(symbols):
            if memory &gt;= prefix[s]:
                value = float(memory) / prefix[s]
                return {"unit": s, "value": value}
        return {"unit": "B", "value": memory}
    return {
        "VmallocTotal": get_unit_value(vm_total),
        "VmallocUsed": get_unit_value(vm_used),
        "VmallocFree": get_unit_value(vm_free),
        "VmallocAvail": get_unit_value(vm_available),
        "SwapTotal": get_unit_value(swp_total),
        "SwapUsed": get_unit_value(swp_used),
        "SwapFree": get_unit_value(swp_free),
    }
def vmstats():
    retlen = ctypes<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.c_ulong()
    ctypes.windll.ntdll.NtQuerySystemInformation(
        2, ctypes.byref(spi), ctypes.sizeof(spi), ctypes.byref(</b></font>retlen)
    )
    ret = {}
    for field in spi._fields_:
        ret.update({field[0]: getattr(spi, field[0])})
    return ret
def loadavg():
    counter_list = [
        ("Memory", None, "Available Bytes"),
        ("Memory", None, "Pages/sec"),
        ("Paging File", "*", "% Usage"),
        ("Processor", "*", "% Processor Time"),
        ("Processor", "*", "DPCs Queued/sec"),
        ("Processor", "*", "% Privileged Time"),
        ("Processor", "*", "% User Time"),
        ("Processor", "*", "% DPC Time"),
        ("Processor", "*", "% Interrupt Time"),
        ("Server", None, "Work Item Shortages"),
        ("Server Work Queues", "*", "Queue Length"),
        ("System", None, "Processor Queue Length"),
        ("System", None, "Context Switches/sec"),
    ]
    return salt.utils.win_pdh.get_counters(counter_list=counter_list)
def cpuload():
    return psutil.cpu_percent()
def diskusage(human_readable=False, path=None):
    if not path:
        path = "c:/"
    disk_stats = psutil.disk_usage(path)
    total_val = disk_stats.total
    used_val = disk_stats.used
    free_val = disk_stats.free
    percent = disk_stats.percent
    if human_readable:
        total_val = _byte_calc(total_val)
        used_val = _byte_calc(used_val)
        free_val = _byte_calc(free_val)
    return {"total": total_val, "used": used_val, "free": free_val, "percent": percent}
def procs(count=False):
    with salt.utils.winapi.Com():
        wmi_obj = wmi.WMI()
        processes = wmi_obj.win32_process()
    if count:
        return len(processes)
    process_info = {}
    for proc in processes:
        process_info[proc.ProcessId] = _get_process_info(proc)
    return process_info
def saltmem(human_readable=False):
    p = psutil.Process()
    with p.oneshot():
        mem = p.memory_info().rss
    if human_readable:
        return _byte_calc(mem)
    return mem
def uptime(human_readable=False):
    startup_time = datetime.datetime.fromtimestamp(psutil.boot_time())
    uptime = datetime.datetime.now() - startup_time
    return str(uptime) if human_readable else uptime.total_seconds()
def _get_process_info(proc):
    cmd = salt.utils.stringutils.to_unicode(proc.CommandLine or "")
    name = salt.utils.stringutils.to_unicode(proc.Name)
    info = dict(cmd=cmd, name=name, **_get_process_owner(proc))
    return info
def _get_process_owner(process):
    owner = {}
    domain, error_code, user = None, None, None
    try:
        domain, error_code, user = process.GetOwner()
        owner["user"] = salt.utils.stringutils.to_unicode(user)
        owner["user_domain"] = salt.utils.stringutils.to_unicode(domain)
    except Exception as exc:  # pylint: disable=broad-except
        pass
    if not error_code and all((user, domain)):
        owner["user"] = salt.utils.stringutils.to_unicode(user)
        owner["user_domain"] = salt.utils.stringutils.to_unicode(domain)
    elif process.ProcessId in [0, 4] and error_code == 2:
        owner["user"] = "SYSTEM"
        owner["user_domain"] = "NT AUTHORITY"
    else:
        log.warning(
            "Error getting owner of process; PID='%s'; Error: %s",
            process.ProcessId,
            error_code,
        )
    return owner
def _byte_calc(val):
    if val &lt; 1024:
        tstr = str(val) + "B"
    elif val &lt; 1038336:
        tstr = str(val / 1024) + "KB"
    elif val &lt; 1073741824:
        tstr = str(val / 1038336) + "MB"
    elif val &lt; 1099511627776:
        tstr = str(val / 1073741824) + "GB"
    else:
        tstr = str(val / 1099511627776) + "TB"
    return tstr
def master(master=None, connected=True):
    def _win_remotes_on(port):
        remotes = set()
        try:
            data = subprocess.check_output(
                ["netstat", "-n", "-p", "TCP"]
            )  # pylint: disable=minimum-python-version
        except subprocess.CalledProcessError:
            log.error("Failed netstat")
            raise
        lines = salt.utils.stringutils.to_unicode(data).split("\n")
        for line in lines:
            if "ESTABLISHED" not in line:
                continue
            chunks = line.split()
            remote_host, remote_port = chunks[2].rsplit(":", 1)
            if int(remote_port) != port:
                continue
            remotes.add(remote_host)
        return remotes
    port = 4505
    master_ips = None
    if master:
        master_ips = _host_to_ips(master)
    if not master_ips:
        return
    if __salt__["config.get"]("publish_port") != "":
        port = int(__salt__["config.get"]("publish_port"))
    master_connection_status = False
    connected_ips = _win_remotes_on(port)
    for master_ip in master_ips:
        if master_ip in connected_ips:
            master_connection_status = True
            break
    if master_connection_status is not connected:
        with salt.utils.event.get_event(
            "minion", opts=__opts__, listen=False
<a name="0"></a>        ) as event_bus:
            if master_connection_status:
                event_bus.fire_event(
                    {"master": master}, salt<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.minion.master_event(type="connected")
                )
            else:
                event_bus.fire_event(
                    {"master": master}, salt.minion.master_event(type=</b></font>"disconnected")
                )
    return master_connection_status
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
r"""
A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
or use Self-Signed certificates.
:depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
    extension support)
:configuration: Add the following values in /etc/salt/minion for the CA module
    to function properly:
    .. code-block:: yaml
        ca.cert_base_path: '/etc/pki'
CLI Example #1:
Creating a CA, a server request and its signed certificate:
.. code-block:: bash
    days=5 \
    CN='My Little CA' \
    C=US \
    ST=Utah \
    L=Salt Lake City \
    O=Saltstack \
    emailAddress=pleasedontemail@example.com
    Created Private Key: "/etc/pki/my_little/my_little_ca_cert.key"
    Created CA "my_little_ca": "/etc/pki/my_little_ca/my_little_ca_cert.crt"
    Created Private Key: "/etc/pki/my_little/certs/www.example.com.key
    Created CSR for "www.example.com": "/etc/pki/my_little/certs/www.example.com.csr"
    Created Certificate for "www.example.com": /etc/pki/my_little/certs/www.example.com.crt"
CLI Example #2:
Creating a client request and its signed certificate
.. code-block:: bash
    Created Private Key: "/etc/pki/my_little/certs//DBReplica_No.1.key."
    Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.csr."
    Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
CLI Example #3:
Creating both a server and client req + cert for the same CN
.. code-block:: bash
        cert_type=client
    Created Private Key: "/etc/pki/my_little/certs/MasterDBReplica_No.2.key."
    Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/MasterDBReplica_No.2.csr."
    Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
        cert_type=server
    Certificate "MasterDBReplica_No.2" already exists
    (doh!)
        cert_type=server type_ext=True
    Created Private Key: "/etc/pki/my_little/certs/DBReplica_No.1_client.key."
    Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1_client.csr."
    Certificate "MasterDBReplica_No.2" already exists
    (DOH!)
        cert_type=server type_ext=True
    Created Certificate for "MasterDBReplica_No.2": "/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt"
CLI Example #4:
Create a server req + cert with non-CN filename for the cert
.. code-block:: bash
        cert_type=server type_ext=True
    Created Private Key: "/etc/pki/my_little/certs/www.anothersometh.ing_server.key."
    Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/www.anothersometh.ing_server.csr."
        cert_type=server cert_filename="something_completely_different"
    Created Certificate for "www.anothersometh.ing": /etc/pki/my_little/certs/something_completely_different.crt
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
import math
import os
import re
import time
from datetime import datetime
import salt.utils.data
import salt.utils.files
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError
from salt.utils.versions import LooseVersion as _LooseVersion
HAS_SSL =</b></font> False
X509_EXT_ENABLED = True
try:
    import OpenSSL
    HAS_SSL = True
    OpenSSL_version = _LooseVersion(OpenSSL.__dict__.get("__version__", "0.0"))
except ImportError:
    pass
log = logging.getLogger(__name__)
two_digit_year_fmt = "%y%m%d%H%M%SZ"
four_digit_year_fmt = "%Y%m%d%H%M%SZ"
def __virtual__():
    global X509_EXT_ENABLED
    if HAS_SSL and OpenSSL_version &gt;= _LooseVersion("0.10"):
        if OpenSSL_version &lt; _LooseVersion("0.14"):
            X509_EXT_ENABLED = False
            log.debug(
                "You should upgrade pyOpenSSL to at least 0.14.1 to "
                "enable the use of X509 extensions in the tls module"
            )
        elif OpenSSL_version &lt;= _LooseVersion("0.15"):
            log.debug(
                "You should upgrade pyOpenSSL to at least 0.15.1 to "
                "enable the full use of X509 extensions in the tls module"
            )
        return True
    else:
        X509_EXT_ENABLED = False
        return (
            False,
            "PyOpenSSL version 0.10 or later must be installed "
            "before this module can be used.",
        )
def _microtime():
    val1, val2 = math.modf(time.time())
    val2 = int(val2)
    return "{:f}{}".format(val1, val2)
def cert_base_path(cacert_path=None):
    if not cacert_path:
        cacert_path = __context__.get(
            "ca.contextual_cert_base_path",
            __salt__["config.option"]("ca.contextual_cert_base_path"),
        )
    if not cacert_path:
        cacert_path = __context__.get(
            "ca.cert_base_path", __salt__["config.option"]("ca.cert_base_path")
        )
    return cacert_path
def _cert_base_path(cacert_path=None):
    return cert_base_path(cacert_path)
def set_ca_path(cacert_path):
    if cacert_path:
        __context__["ca.contextual_cert_base_path"] = cacert_path
    return cert_base_path()
def _new_serial(ca_name):
    hashnum = int(
        binascii.hexlify(
            b"_".join(
                (
                    salt.utils.stringutils.to_bytes(_microtime()),
                    os.urandom(5),
                )
            )
        ),
        16,
    )
    log.debug("Hashnum: %s", hashnum)
    cachedir = __opts__["cachedir"]
    log.debug("cachedir: %s", cachedir)
    serial_file = "{}/{}.serial".format(cachedir, ca_name)
    if not os.path.exists(cachedir):
        os.makedirs(cachedir)
    if not os.path.exists(serial_file):
        mode = "w"
    else:
        mode = "a+"
    with salt.utils.files.fopen(serial_file, mode) as ofile:
        ofile.write(str(hashnum))
    return hashnum
def _four_digit_year_to_two_digit(datetimeObj):
    return datetimeObj.strftime(two_digit_year_fmt)
def _get_basic_info(ca_name, cert, ca_dir=None):
    if ca_dir is None:
        ca_dir = "{}/{}".format(_cert_base_path(), ca_name)
    index_file = "{}/index.txt".format(ca_dir)
    cert = _read_cert(cert)
    expire_date = _four_digit_year_to_two_digit(_get_expiration_date(cert))
    serial_number = format(cert.get_serial_number(), "X")
    subject = "/"
    subject += "/".join(
        ["{}={}".format(x, y) for x, y in cert.get_subject().get_components()]
    )
    subject += "\n"
    return (index_file, expire_date, serial_number, subject)
def _write_cert_to_database(ca_name, cert, cacert_path=None, status="V"):
    set_ca_path(cacert_path)
    ca_dir = "{}/{}".format(cert_base_path(), ca_name)
    index_file, expire_date, serial_number, subject = _get_basic_info(
        ca_name, cert, ca_dir
    )
    index_data = "{}\t{}\t\t{}\tunknown\t{}".format(
        status, expire_date, serial_number, subject
    )
    with salt.utils.files.fopen(index_file, "a+") as ofile:
        ofile.write(salt.utils.stringutils.to_str(index_data))
def maybe_fix_ssl_version(ca_name, cacert_path=None, ca_filename=None):
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
    ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
    with salt.utils.files.fopen(certp) as fic:
        cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, fic.read())
        if cert.get_version() == 3:
            log.info("Regenerating wrong x509 version for certificate %s", certp)
            with salt.utils.files.fopen(ca_keyp) as fic2:
                try:
                    key = OpenSSL.crypto.load_privatekey(
                        OpenSSL.crypto.FILETYPE_PEM, fic2.read()
                    )
                    bits = key.bits()
                except Exception:  # pylint: disable=broad-except
                    bits = 2048
                try:
                    days = (
                        datetime.strptime(cert.get_notAfter(), "%Y%m%d%H%M%SZ")
                        - datetime.utcnow()
                    ).days
                except (ValueError, TypeError):
                    days = 365
                subj = cert.get_subject()
                create_ca(
                    ca_name,
                    bits=bits,
                    days=days,
                    CN=subj.CN,
                    C=subj.C,
                    ST=subj.ST,
                    L=subj.L,
                    O=subj.O,
                    OU=subj.OU,
                    emailAddress=subj.emailAddress,
                    fixmode=True,
                )
def ca_exists(ca_name, cacert_path=None, ca_filename=None):
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
    if os.path.exists(certp):
        maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
        return True
    return False
def _ca_exists(ca_name, cacert_path=None):
    return ca_exists(ca_name, cacert_path)
def get_ca(ca_name, as_text=False, cacert_path=None):
    set_ca_path(cacert_path)
    certp = "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
    if not os.path.exists(certp):
        raise ValueError("Certificate does not exist for {}".format(ca_name))
    else:
        if as_text:
            with salt.utils.files.fopen(certp) as fic:
                certp = salt.utils.stringutils.to_unicode(fic.read())
    return certp
def get_ca_signed_cert(
    ca_name, CN="localhost", as_text=False, cacert_path=None, cert_filename=None
):
    set_ca_path(cacert_path)
    if not cert_filename:
        cert_filename = CN
    certp = "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, cert_filename)
    if not os.path.exists(certp):
        raise ValueError("Certificate does not exists for {}".format(CN))
    else:
        if as_text:
            with salt.utils.files.fopen(certp) as fic:
                certp = salt.utils.stringutils.to_unicode(fic.read())
    return certp
def get_ca_signed_key(
    ca_name, CN="localhost", as_text=False, cacert_path=None, key_filename=None
):
    set_ca_path(cacert_path)
    if not key_filename:
        key_filename = CN
    keyp = "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, key_filename)
    if not os.path.exists(keyp):
        raise ValueError("Certificate does not exists for {}".format(CN))
    else:
        if as_text:
            with salt.utils.files.fopen(keyp) as fic:
                keyp = salt.utils.stringutils.to_unicode(fic.read())
    return keyp
def _read_cert(cert):
    if isinstance(cert, str):
        try:
            with salt.utils.files.fopen(cert) as rfh:
                return OpenSSL.crypto.load_certificate(
                    OpenSSL.crypto.FILETYPE_PEM, rfh.read()
                )
        except Exception:  # pylint: disable=broad-except
            log.exception("Failed to read cert from path %s", cert)
            return None
    else:
        if not hasattr(cert, "get_notAfter"):
            log.error("%s is not a valid cert path/object", cert)
            return None
        else:
            return cert
def validate(cert, ca_name, crl_file):
    store = OpenSSL.crypto.X509Store()
    cert_obj = _read_cert(cert)
    if cert_obj is None:
        raise CommandExecutionError(
            "Failed to read cert from {}, see log for details".format(cert)
        )
    ca_dir = "{}/{}".format(cert_base_path(), ca_name)
    ca_cert = _read_cert("{}/{}_ca_cert.crt".format(ca_dir, ca_name))
    store.add_cert(ca_cert)
    X509StoreFlags = OpenSSL.crypto.X509StoreFlags
    store.set_flags(X509StoreFlags.CRL_CHECK | X509StoreFlags.CRL_CHECK_ALL)
    if crl_file is None:
        crl = OpenSSL.crypto.CRL()
    else:
        with salt.utils.files.fopen(crl_file) as fhr:
            crl = OpenSSL.crypto.load_crl(OpenSSL.crypto.FILETYPE_PEM, fhr.read())
    store.add_crl(crl)
    context = OpenSSL.crypto.X509StoreContext(store, cert_obj)
    ret = {}
    try:
        context.verify_certificate()
        ret["valid"] = True
    except OpenSSL.crypto.X509StoreContextError as e:
        ret["error"] = str(e)
        ret["error_cert"] = e.certificate
        ret["valid"] = False
    return ret
def _get_expiration_date(cert):
    cert_obj = _read_cert(cert)
    if cert_obj is None:
        raise CommandExecutionError(
            "Failed to read cert from {}, see log for details".format(cert)
        )
    return datetime.strptime(
        salt.utils.stringutils.to_str(cert_obj.get_notAfter()), four_digit_year_fmt
    )
def get_expiration_date(cert, date_format="%Y-%m-%d"):
    return _get_expiration_date(cert).strftime(date_format)
def _check_onlyif_unless(onlyif, unless):
    ret = None
    retcode = __salt__["cmd.retcode"]
    if onlyif is not None:
        if not isinstance(onlyif, str):
            if not onlyif:
                ret = {"comment": "onlyif condition is false", "result": True}
        elif isinstance(onlyif, str):
            if retcode(onlyif) != 0:
                ret = {"comment": "onlyif condition is false", "result": True}
                log.debug("onlyif condition is false")
    if unless is not None:
        if not isinstance(unless, str):
            if unless:
                ret = {"comment": "unless condition is true", "result": True}
        elif isinstance(unless, str):
            if retcode(unless) == 0:
                ret = {"comment": "unless condition is true", "result": True}
                log.debug("unless condition is true")
    return ret
def create_ca(
    ca_name,
    bits=2048,
    days=365,
    CN="localhost",
    C="US",
    ST="Utah",
    L="Salt Lake City",
    O="SaltStack",
    OU=None,
    emailAddress=None,
    fixmode=False,
    cacert_path=None,
    ca_filename=None,
    digest="sha256",
    onlyif=None,
    unless=None,
    replace=False,
):
    status = _check_onlyif_unless(onlyif, unless)
    if status is not None:
        return None
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
    ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
    if not replace and not fixmode and ca_exists(ca_name, ca_filename=ca_filename):
        return 'Certificate for CA named "{}" already exists'.format(ca_name)
    if fixmode and not os.path.exists(certp):
        raise ValueError("{} does not exists, can't fix".format(certp))
    if not os.path.exists("{}/{}".format(cert_base_path(), ca_name)):
        os.makedirs("{}/{}".format(cert_base_path(), ca_name))
    key = None
    if os.path.exists(ca_keyp):
        with salt.utils.files.fopen(ca_keyp) as fic2:
            try:
                key = OpenSSL.crypto.load_privatekey(
                    OpenSSL.crypto.FILETYPE_PEM, fic2.read()
                )
            except OpenSSL.crypto.Error as err:
                log.warning(
                    "Error loading existing private key %s, generating a new key: %s",
                    ca_keyp,
                    err,
                )
                bck = "{}.unloadable.{}".format(
                    ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S")
                )
                log.info("Saving unloadable CA ssl key in %s", bck)
                os.rename(ca_keyp, bck)
    if not key:
        key = OpenSSL.crypto.PKey()
        key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
    ca = OpenSSL.crypto.X509()
    ca.set_version(2)
    ca.set_serial_number(_new_serial(ca_name))
    ca.get_subject().C = C
    ca.get_subject().ST = ST
    ca.get_subject().L = L
    ca.get_subject().O = O
    if OU:
        ca.get_subject().OU = OU
    ca.get_subject().CN = CN
    if emailAddress:
        ca.get_subject().emailAddress = emailAddress
    ca.gmtime_adj_notBefore(0)
    ca.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
    ca.set_issuer(ca.get_subject())
    ca.set_pubkey(key)
    if X509_EXT_ENABLED:
        ca.add_extensions(
            [
                OpenSSL.crypto.X509Extension(
                    b"basicConstraints", True, b"CA:TRUE, pathlen:0"
                ),
<a name="0"></a>                OpenSSL.crypto.X509Extension(
                    b"keyUsage", True, b"keyCertSign, cRLSign"
                ),
                OpenSSL<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.crypto.X509Extension(
                    b"subjectKeyIdentifier", False, b"hash", subject=ca
                ),
            ]
        )
        ca.add_extensions(
            [
                OpenSSL.crypto.X509Extension(
                    b"authorityKeyIdentifier",
                    False,
                    b"issuer:always,keyid:always",
                    issuer=</b></font>ca,
                )
            ]
        )
    ca.sign(key, salt.utils.stringutils.to_str(digest))
    keycontent = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
    write_key = True
    if os.path.exists(ca_keyp):
        bck = "{}.{}".format(ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S"))
        with salt.utils.files.fopen(ca_keyp) as fic:
            old_key = salt.utils.stringutils.to_unicode(fic.read()).strip()
            if old_key.strip() == keycontent.strip():
                write_key = False
            else:
                log.info("Saving old CA ssl key in %s", bck)
                fp = os.open(bck, os.O_CREAT | os.O_RDWR, 0o600)
                with salt.utils.files.fopen(fp, "w") as bckf:
                    bckf.write(old_key)
    if write_key:
        fp = os.open(ca_keyp, os.O_CREAT | os.O_RDWR, 0o600)
        with salt.utils.files.fopen(fp, "wb") as ca_key:
            ca_key.write(salt.utils.stringutils.to_bytes(keycontent))
    with salt.utils.files.fopen(certp, "wb") as ca_crt:
        ca_crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, ca)
            )
        )
    _write_cert_to_database(ca_name, ca)
    ret = 'Created Private Key: "{}/{}/{}.key." '.format(
        cert_base_path(), ca_name, ca_filename
    )
    ret += 'Created CA "{0}": "{1}/{0}/{2}.crt."'.format(
        ca_name, cert_base_path(), ca_filename
    )
    return ret
def get_extensions(cert_type):
    assert X509_EXT_ENABLED, (
        "X509 extensions are not supported in "
        "pyOpenSSL prior to version 0.15.1. Your "
        "version: {}".format(OpenSSL_version)
    )
    ext = {}
    if cert_type == "":
        log.error(
            "cert_type set to empty in tls_ca.get_extensions(); "
            "defaulting to ``server``"
        )
        cert_type = "server"
    try:
        ext["common"] = __salt__["pillar.get"]("tls.extensions:common", False)
    except NameError as err:
        log.debug(err)
    if not ext["common"] or ext["common"] == "":
        ext["common"] = {
            "csr": {"basicConstraints": "CA:FALSE"},
            "cert": {
                "authorityKeyIdentifier": "keyid,issuer:always",
                "subjectKeyIdentifier": "hash",
            },
        }
    try:
        ext["server"] = __salt__["pillar.get"]("tls.extensions:server", False)
    except NameError as err:
        log.debug(err)
    if not ext["server"] or ext["server"] == "":
        ext["server"] = {
            "csr": {
                "extendedKeyUsage": "serverAuth",
                "keyUsage": "digitalSignature, keyEncipherment",
            },
            "cert": {},
        }
    try:
        ext["client"] = __salt__["pillar.get"]("tls.extensions:client", False)
    except NameError as err:
        log.debug(err)
    if not ext["client"] or ext["client"] == "":
        ext["client"] = {
            "csr": {
                "extendedKeyUsage": "clientAuth",
                "keyUsage": "nonRepudiation, digitalSignature, keyEncipherment",
            },
            "cert": {},
        }
    if cert_type not in ext:
        try:
            ext[cert_type] = __salt__["pillar.get"](
                "tls.extensions:{}".format(cert_type)
            )
        except NameError as e:
            log.debug(
                "pillar, tls:extensions:%s not available or "
                "not operating in a salt context\n%s",
                cert_type,
                e,
            )
    retval = ext["common"]
    for Use in retval:
        retval[Use].update(ext[cert_type][Use])
    return retval
def create_csr(
    ca_name,
    bits=2048,
    CN="localhost",
    C="US",
    ST="Utah",
    L="Salt Lake City",
    O="SaltStack",
    OU=None,
    emailAddress=None,
    subjectAltName=None,
    cacert_path=None,
    ca_filename=None,
    csr_path=None,
    csr_filename=None,
    digest="sha256",
    type_ext=False,
    cert_type="server",
    replace=False,
):
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    if not ca_exists(ca_name, ca_filename=ca_filename):
        return 'Certificate for CA named "{}" does not exist, please create it first.'.format(
            ca_name
        )
    if not csr_path:
        csr_path = "{}/{}/certs/".format(cert_base_path(), ca_name)
    if not os.path.exists(csr_path):
        os.makedirs(csr_path)
    CN_ext = "_{}".format(cert_type) if type_ext else ""
    if not csr_filename:
        csr_filename = "{}{}".format(CN, CN_ext)
    csr_f = "{}/{}.csr".format(csr_path, csr_filename)
    if not replace and os.path.exists(csr_f):
        return 'Certificate Request "{}" already exists'.format(csr_f)
    key = OpenSSL.crypto.PKey()
    key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
    req = OpenSSL.crypto.X509Req()
    req.get_subject().C = C
    req.get_subject().ST = ST
    req.get_subject().L = L
    req.get_subject().O = O
    if OU:
        req.get_subject().OU = OU
    req.get_subject().CN = CN
    if emailAddress:
        req.get_subject().emailAddress = emailAddress
    try:
        extensions = get_extensions(cert_type)["csr"]
        extension_adds = []
        for ext, value in extensions.items():
            if isinstance(value, str):
                value = salt.utils.stringutils.to_bytes(value)
            extension_adds.append(
                OpenSSL.crypto.X509Extension(
                    salt.utils.stringutils.to_bytes(ext), False, value
                )
            )
    except AssertionError as err:
        log.error(err)
        extensions = []
    if subjectAltName:
        if X509_EXT_ENABLED:
            if isinstance(subjectAltName, str):
                subjectAltName = [subjectAltName]
            extension_adds.append(
                OpenSSL.crypto.X509Extension(
                    b"subjectAltName",
                    False,
                    b", ".join(salt.utils.data.encode(subjectAltName)),
                )
            )
        else:
            raise ValueError(
                "subjectAltName cannot be set as X509 "
                "extensions are not supported in pyOpenSSL "
                "prior to version 0.15.1. Your "
                "version: {}.".format(OpenSSL_version)
            )
    if X509_EXT_ENABLED:
        req.add_extensions(extension_adds)
    req.set_pubkey(key)
    req.sign(key, salt.utils.stringutils.to_str(digest))
    priv_keyp = "{}/{}.key".format(csr_path, csr_filename)
    fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
    with salt.utils.files.fopen(fp, "wb+") as priv_key:
        priv_key.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
            )
        )
    with salt.utils.files.fopen(csr_f, "wb+") as csr:
        csr.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate_request(
                    OpenSSL.crypto.FILETYPE_PEM, req
                )
            )
        )
    ret = 'Created Private Key: "{}{}.key." '.format(csr_path, csr_filename)
    ret += 'Created CSR for "{}": "{}{}.csr."'.format(CN, csr_path, csr_filename)
    return ret
def create_self_signed_cert(
    tls_dir="tls",
    bits=2048,
    days=365,
    CN="localhost",
    C="US",
    ST="Utah",
    L="Salt Lake City",
    O="SaltStack",
    OU=None,
    emailAddress=None,
    cacert_path=None,
    cert_filename=None,
    digest="sha256",
    replace=False,
):
    set_ca_path(cacert_path)
    if not os.path.exists("{}/{}/certs/".format(cert_base_path(), tls_dir)):
        os.makedirs("{}/{}/certs/".format(cert_base_path(), tls_dir))
    if not cert_filename:
        cert_filename = CN
    if not replace and os.path.exists(
        "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
    ):
        return 'Certificate "{}" already exists'.format(cert_filename)
    key = OpenSSL.crypto.PKey()
    key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
    cert = OpenSSL.crypto.X509()
    cert.set_version(2)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
    cert.get_subject().C = C
    cert.get_subject().ST = ST
    cert.get_subject().L = L
    cert.get_subject().O = O
    if OU:
        cert.get_subject().OU = OU
    cert.get_subject().CN = CN
    if emailAddress:
        cert.get_subject().emailAddress = emailAddress
    cert.set_serial_number(_new_serial(tls_dir))
    cert.set_issuer(cert.get_subject())
    cert.set_pubkey(key)
    cert.sign(key, salt.utils.stringutils.to_str(digest))
    priv_key_path = "{}/{}/certs/{}.key".format(
        cert_base_path(), tls_dir, cert_filename
    )
    fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
    with salt.utils.files.fopen(fp, "wb+") as priv_key:
        priv_key.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
            )
        )
    crt_path = "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
    with salt.utils.files.fopen(crt_path, "wb+") as crt:
        crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            )
        )
    _write_cert_to_database(tls_dir, cert)
    ret = 'Created Private Key: "{}/{}/certs/{}.key." '.format(
        cert_base_path(), tls_dir, cert_filename
    )
    ret += 'Created Certificate: "{}/{}/certs/{}.crt."'.format(
        cert_base_path(), tls_dir, cert_filename
    )
    return ret
def create_ca_signed_cert(
    ca_name,
    CN,
    days=365,
    cacert_path=None,
    ca_filename=None,
    cert_path=None,
    cert_filename=None,
    digest="sha256",
    cert_type=None,
    type_ext=False,
    replace=False,
):
    ret = {}
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    if not cert_path:
        cert_path = "{}/{}/certs".format(cert_base_path(), ca_name)
    if type_ext:
        if not cert_type:
            log.error(
                "type_ext = True but cert_type is unset. Certificate not written."
            )
            return ret
        elif cert_type:
            CN_ext = "_{}".format(cert_type)
    else:
        CN_ext = ""
    csr_filename = "{}{}".format(CN, CN_ext)
    if not cert_filename:
        cert_filename = "{}{}".format(CN, CN_ext)
    if not replace and os.path.exists(
        os.path.join(
            os.path.sep.join(
                "{}/{}/certs/{}.crt".format(
                    cert_base_path(), ca_name, cert_filename
                ).split("/")
            )
        )
    ):
        return 'Certificate "{}" already exists'.format(cert_filename)
    try:
        maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
        with salt.utils.files.fopen(
            "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
        ) as fhr:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
        with salt.utils.files.fopen(
            "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
        ) as fhr:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        ret["retcode"] = 1
        ret["comment"] = 'There is no CA named "{}"'.format(ca_name)
        return ret
    try:
        csr_path = "{}/{}.csr".format(cert_path, csr_filename)
        with salt.utils.files.fopen(csr_path) as fhr:
            req = OpenSSL.crypto.load_certificate_request(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        ret["retcode"] = 1
        ret["comment"] = 'There is no CSR that matches the CN "{}"'.format(
            cert_filename
        )
        return ret
    exts = []
    try:
        exts.extend(req.get_extensions())
    except AttributeError:
        try:
            log.info(
                "req.get_extensions() not supported in pyOpenSSL versions "
                "prior to 0.15. Processing extensions internally. "
                "Your version: %s",
                OpenSSL_version,
            )
            native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
            for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
                ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
                ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
                    native_exts_obj, i
                )
                exts.append(ext)
        except Exception:  # pylint: disable=broad-except
            log.error(
                "X509 extensions are unsupported in pyOpenSSL "
                "versions prior to 0.14. Upgrade required to "
                "use extensions. Current version: %s",
                OpenSSL_version,
            )
    cert = OpenSSL.crypto.X509()
    cert.set_version(2)
    cert.set_subject(req.get_subject())
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
    cert.set_serial_number(_new_serial(ca_name))
    cert.set_issuer(ca_cert.get_subject())
    cert.set_pubkey(req.get_pubkey())
    cert.add_extensions(exts)
    cert.sign(ca_key, salt.utils.stringutils.to_str(digest))
    cert_full_path = "{}/{}.crt".format(cert_path, cert_filename)
    with salt.utils.files.fopen(cert_full_path, "wb+") as crt:
        crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            )
        )
    _write_cert_to_database(ca_name, cert)
    return 'Created Certificate for "{}": "{}/{}.crt"'.format(
        CN, cert_path, cert_filename
    )
def create_pkcs12(ca_name, CN, passphrase="", cacert_path=None, replace=False):
    set_ca_path(cacert_path)
    if not replace and os.path.exists(
        "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN)
    ):
        return 'Certificate "{}" already exists'.format(CN)
    try:
        with salt.utils.files.fopen(
            "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
        ) as fhr:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        return 'There is no CA named "{}"'.format(ca_name)
    try:
        with salt.utils.files.fopen(
            "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, CN)
        ) as fhr:
            cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
        with salt.utils.files.fopen(
            "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, CN)
        ) as fhr:
            key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        return 'There is no certificate that matches the CN "{}"'.format(CN)
    pkcs12 = OpenSSL.crypto.PKCS12()
    pkcs12.set_certificate(cert)
    pkcs12.set_ca_certificates([ca_cert])
    pkcs12.set_privatekey(key)
    with salt.utils.files.fopen(
        "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN), "wb"
    ) as ofile:
        ofile.write(
            pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
        )
    return 'Created PKCS#12 Certificate for "{0}": "{1}/{2}/certs/{0}.p12"'.format(
        CN,
        cert_base_path(),
        ca_name,
    )
def cert_info(cert, digest="sha256"):
    date_fmt = "%Y%m%d%H%M%SZ"
    if "-----BEGIN" not in cert:
        with salt.utils.files.fopen(cert) as cert_file:
            cert = cert_file.read()
    cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
    issuer = {}
    for key, value in cert.get_issuer().get_components():
        if isinstance(key, bytes):
            key = salt.utils.stringutils.to_unicode(key)
        if isinstance(value, bytes):
            value = salt.utils.stringutils.to_unicode(value)
        issuer[key] = value
    subject = {}
    for key, value in cert.get_subject().get_components():
        if isinstance(key, bytes):
            key = salt.utils.stringutils.to_unicode(key)
        if isinstance(value, bytes):
            value = salt.utils.stringutils.to_unicode(value)
        subject[key] = value
<a name="1"></a>
    ret = {
        "fingerprint": salt.utils.stringutils.to_unicode(
            cert<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.digest(salt.utils.stringutils.to_str(digest))
        ),
        "subject": subject,
        "issuer": issuer,
        "serial_number": cert.get_serial_number(),
        "not_before": calendar.timegm(
            time.strptime(</b></font>
                str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
            )
        ),
        "not_after": calendar.timegm(
            time.strptime(
                cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
            )
        ),
    }
    if hasattr(cert, "get_extension_count"):
        ret["extensions"] = {}
        for i in range(cert.get_extension_count()):
            try:
                ext = cert.get_extension(i)
                key = salt.utils.stringutils.to_unicode(ext.get_short_name())
                ret["extensions"][key] = str(ext).strip()
            except AttributeError:
                continue
    if "subjectAltName" in ret.get("extensions", {}):
        valid_entries = ("DNS", "IP Address")
        valid_names = set()
        for name in str(ret["extensions"]["subjectAltName"]).split(", "):
            entry, name = name.split(":", 1)
            if entry not in valid_entries:
                log.error(
                    "Cert %s has an entry (%s) which does not start with %s",
                    ret["subject"],
                    name,
                    "/".join(valid_entries),
                )
            else:
                valid_names.add(name)
        ret["subject_alt_names"] = list(valid_names)
    if hasattr(cert, "get_signature_algorithm"):
        try:
            value = cert.get_signature_algorithm()
            if isinstance(value, bytes):
                value = salt.utils.stringutils.to_unicode(value)
            ret["signature_algorithm"] = value
        except AttributeError:
            pass
    return ret
def create_empty_crl(
    ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest="sha256"
):
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    if not crl_file:
        crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
    if os.path.exists("{}".format(crl_file)):
        return 'CRL "{}" already exists'.format(crl_file)
    try:
        with salt.utils.files.fopen(
            "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
        with salt.utils.files.fopen(
            "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
    except OSError:
        return 'There is no CA named "{}"'.format(ca_name)
    crl = OpenSSL.crypto.CRL()
    crl_text = crl.export(
        ca_cert,
        ca_key,
        digest=salt.utils.stringutils.to_bytes(digest),
    )
    with salt.utils.files.fopen(crl_file, "w") as f:
        f.write(salt.utils.stringutils.to_str(crl_text))
    return 'Created an empty CRL: "{}"'.format(crl_file)
def revoke_cert(
    ca_name,
    CN,
    cacert_path=None,
    ca_filename=None,
    cert_path=None,
    cert_filename=None,
    crl_file=None,
    digest="sha256",
):
    set_ca_path(cacert_path)
    ca_dir = "{}/{}".format(cert_base_path(), ca_name)
    if ca_filename is None:
        ca_filename = "{}_ca_cert".format(ca_name)
    if cert_path is None:
        cert_path = "{}/{}/certs".format(_cert_base_path(), ca_name)
    if cert_filename is None:
        cert_filename = "{}".format(CN)
    try:
        with salt.utils.files.fopen(
            "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
        with salt.utils.files.fopen(
            "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
    except OSError:
        return 'There is no CA named "{}"'.format(ca_name)
    client_cert = _read_cert("{}/{}.crt".format(cert_path, cert_filename))
    if client_cert is None:
        return 'There is no client certificate named "{}"'.format(CN)
    index_file, expire_date, serial_number, subject = _get_basic_info(
        ca_name, client_cert, ca_dir
    )
    index_serial_subject = "{}\tunknown\t{}".format(serial_number, subject)
    index_v_data = "V\t{}\t\t{}".format(expire_date, index_serial_subject)
    index_r_data_pattern = re.compile(
        r"R\t" + expire_date + r"\t\d{12}Z\t" + re.escape(index_serial_subject)
    )
    index_r_data = "R\t{}\t{}\t{}".format(
        expire_date,
        _four_digit_year_to_two_digit(datetime.utcnow()),
        index_serial_subject,
    )
    ret = {}
    with salt.utils.files.fopen(index_file) as fp_:
        for line in fp_:
            line = salt.utils.stringutils.to_unicode(line)
            if index_r_data_pattern.match(line):
                revoke_date = line.split("\t")[2]
                try:
                    datetime.strptime(revoke_date, two_digit_year_fmt)
                    return '"{}/{}.crt" was already revoked, serial number: {}'.format(
                        cert_path, cert_filename, serial_number
                    )
                except ValueError:
                    ret["retcode"] = 1
                    ret[
                        "comment"
                    ] = "Revocation date '{}' does not matchformat '{}'".format(
                        revoke_date, two_digit_year_fmt
                    )
                    return ret
            elif index_serial_subject in line:
                __salt__["file.replace"](
                    index_file, index_v_data, index_r_data, backup=False
                )
                break
    crl = OpenSSL.crypto.CRL()
    with salt.utils.files.fopen(index_file) as fp_:
        for line in fp_:
            line = salt.utils.stringutils.to_unicode(line)
            if line.startswith("R"):
                fields = line.split("\t")
                revoked = OpenSSL.crypto.Revoked()
                revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
                revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
                revoked.set_rev_date(
                    salt.utils.stringutils.to_bytes(
                        revoke_date_2_digit.strftime(four_digit_year_fmt)
                    )
                )
                crl.add_revoked(revoked)
    crl_text = crl.export(
        ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
    )
    if crl_file is None:
        crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
    if os.path.isdir(crl_file):
        ret["retcode"] = 1
        ret["comment"] = 'crl_file "{}" is an existing directory'.format(crl_file)
        return ret
    with salt.utils.files.fopen(crl_file, "w") as fp_:
        fp_.write(salt.utils.stringutils.to_str(crl_text))
    return 'Revoked Certificate: "{}/{}.crt", serial number: {}'.format(
        cert_path, cert_filename, serial_number
    )
if __name__ == "__main__":
    create_csr(
        "koji",
        CN="test_system",
        C="US",
        ST="Utah",
        L="Centerville",
        O="SaltStack",
        OU=None,
        emailAddress="test_system@saltstack.org",
    )
    create_ca_signed_cert("koji", "test_system")
    create_pkcs12("koji", "test_system", passphrase="test")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
