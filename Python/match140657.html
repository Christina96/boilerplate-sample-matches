<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_status.py &amp; tls_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_status.py &amp; tls_1.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_status.py (5.863192%)<th>tls_1.py (1.5964524%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(580-584)<td><a href="#" name="0">(799-811)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(253-258)<td><a href="#" name="1">(1685-1691)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(12-28)<td><a href="#" name="2">(103-119)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import ctypes
3 import datetime
4 import logging
5 import subprocess
6 import salt.utils.event
7 import salt.utils.platform
8 import salt.utils.stringutils
9 import salt.utils.win_pdh
10 from salt.modules.status import ping_master, time_
11 from salt.utils.functools import namespaced_function as _namespaced_function
12 from salt.utils.network import host_to_ips as _host_to_ips
13 log =</b></font> logging.getLogger(__name__)
14 try:
15     if salt.utils.platform.is_windows():
16         import wmi
17         import salt.utils.winapi
18         HAS_WMI = True
19     else:
20         HAS_WMI = False
21 except ImportError:
22     HAS_WMI = False
23 HAS_PSUTIL = False
24 if salt.utils.platform.is_windows():
25     import psutil
26     HAS_PSUTIL = True
27 __opts__ = {}
28 __virtualname__ = "status"
29 class SYSTEM_PERFORMANCE_INFORMATION(ctypes.Structure):
30     _fields_ = [
31         ("IdleProcessTime", ctypes.c_int64),
32         ("IoReadTransferCount", ctypes.c_int64),
33         ("IoWriteTransferCount", ctypes.c_int64),
34         ("IoOtherTransferCount", ctypes.c_int64),
35         ("IoReadOperationCount", ctypes.c_ulong),
36         ("IoWriteOperationCount", ctypes.c_ulong),
37         ("IoOtherOperationCount", ctypes.c_ulong),
38         ("AvailablePages", ctypes.c_ulong),
39         ("CommittedPages", ctypes.c_ulong),
40         ("CommitLimit", ctypes.c_ulong),
41         ("PeakCommitment", ctypes.c_ulong),
42         ("PageFaultCount", ctypes.c_ulong),
43         ("CopyOnWriteCount", ctypes.c_ulong),
44         ("TransitionCount", ctypes.c_ulong),
45         ("CacheTransitionCount", ctypes.c_ulong),
46         ("DemandZeroCount", ctypes.c_ulong),
47         ("PageReadCount", ctypes.c_ulong),
48         ("PageReadIoCount", ctypes.c_ulong),
49         ("CacheReadCount", ctypes.c_ulong),  # Was c_ulong ** 2
50         ("CacheIoCount", ctypes.c_ulong),
51         ("DirtyPagesWriteCount", ctypes.c_ulong),
52         ("DirtyWriteIoCount", ctypes.c_ulong),
53         ("MappedPagesWriteCount", ctypes.c_ulong),
54         ("MappedWriteIoCount", ctypes.c_ulong),
55         ("PagedPoolPages", ctypes.c_ulong),
56         ("NonPagedPoolPages", ctypes.c_ulong),
57         ("PagedPoolAllocs", ctypes.c_ulong),
58         ("PagedPoolFrees", ctypes.c_ulong),
59         ("NonPagedPoolAllocs", ctypes.c_ulong),
60         ("NonPagedPoolFrees", ctypes.c_ulong),
61         ("FreeSystemPtes", ctypes.c_ulong),
62         ("ResidentSystemCodePage", ctypes.c_ulong),
63         ("TotalSystemDriverPages", ctypes.c_ulong),
64         ("TotalSystemCodePages", ctypes.c_ulong),
65         ("NonPagedPoolLookasideHits", ctypes.c_ulong),
66         ("PagedPoolLookasideHits", ctypes.c_ulong),
67         ("AvailablePagedPoolPages", ctypes.c_ulong),
68         ("ResidentSystemCachePage", ctypes.c_ulong),
69         ("ResidentPagedPoolPage", ctypes.c_ulong),
70         ("ResidentSystemDriverPage", ctypes.c_ulong),
71         ("CcFastReadNoWait", ctypes.c_ulong),
72         ("CcFastReadWait", ctypes.c_ulong),
73         ("CcFastReadResourceMiss", ctypes.c_ulong),
74         ("CcFastReadNotPossible", ctypes.c_ulong),
75         ("CcFastMdlReadNoWait", ctypes.c_ulong),
76         ("CcFastMdlReadWait", ctypes.c_ulong),
77         ("CcFastMdlReadResourceMiss", ctypes.c_ulong),
78         ("CcFastMdlReadNotPossible", ctypes.c_ulong),
79         ("CcMapDataNoWait", ctypes.c_ulong),
80         ("CcMapDataWait", ctypes.c_ulong),
81         ("CcMapDataNoWaitMiss", ctypes.c_ulong),
82         ("CcMapDataWaitMiss", ctypes.c_ulong),
83         ("CcPinMappedDataCount", ctypes.c_ulong),
84         ("CcPinReadNoWait", ctypes.c_ulong),
85         ("CcPinReadWait", ctypes.c_ulong),
86         ("CcPinReadNoWaitMiss", ctypes.c_ulong),
87         ("CcPinReadWaitMiss", ctypes.c_ulong),
88         ("CcCopyReadNoWait", ctypes.c_ulong),
89         ("CcCopyReadWait", ctypes.c_ulong),
90         ("CcCopyReadNoWaitMiss", ctypes.c_ulong),
91         ("CcCopyReadWaitMiss", ctypes.c_ulong),
92         ("CcMdlReadNoWait", ctypes.c_ulong),
93         ("CcMdlReadWait", ctypes.c_ulong),
94         ("CcMdlReadNoWaitMiss", ctypes.c_ulong),
95         ("CcMdlReadWaitMiss", ctypes.c_ulong),
96         ("CcReadAheadIos", ctypes.c_ulong),
97         ("CcLazyWriteIos", ctypes.c_ulong),
98         ("CcLazyWritePages", ctypes.c_ulong),
99         ("CcDataFlushes", ctypes.c_ulong),
100         ("CcDataPages", ctypes.c_ulong),
101         ("ContextSwitches", ctypes.c_ulong),
102         ("FirstLevelTbFills", ctypes.c_ulong),
103         ("SecondLevelTbFills", ctypes.c_ulong),
104         ("SystemCalls", ctypes.c_ulong),
105         ("CcTotalDirtyPages", ctypes.c_ulonglong),
106         ("CcDirtyPagesThreshold", ctypes.c_ulonglong),
107         ("ResidentAvailablePages", ctypes.c_longlong),
108         ("SharedCommittedPages", ctypes.c_ulonglong),
109     ]
110 def __virtual__():
111     """
112     Only works on Windows systems with WMI and WinAPI
113     """
114     if not salt.utils.platform.is_windows():
115         return False, "win_status.py: Requires Windows"
116     if not HAS_WMI:
117         return False, "win_status.py: Requires WMI and WinAPI"
118     if not HAS_PSUTIL:
119         return False, "win_status.py: Requires psutil"
120     global ping_master, time_
121     ping_master = _namespaced_function(ping_master, globals())
122     time_ = _namespaced_function(time_, globals())
123     return __virtualname__
124 __func_alias__ = {"time_": "time"}
125 def cpustats():
126     """
127     Return information about the CPU.
128     Returns
129         dict: A dictionary containing information about the CPU stats
130     CLI Example:
131     .. code-block:: bash
132         salt * status.cpustats
133     """
134     user, system, idle, interrupt, dpc = psutil.cpu_times()
135     cpu = {"user": user, "system": system, "idle": idle, "irq": interrupt, "dpc": dpc}
136     ctx_switches, interrupts, soft_interrupts, sys_calls = psutil.cpu_stats()
137     intr = {"irqs": {"irqs": [], "total": interrupts}}
138     soft_irq = {"softirqs": [], "total": soft_interrupts}
139     return {
140         "btime": psutil.boot_time(),
141         "cpu": cpu,
142         "ctxt": ctx_switches,
143         "intr": intr,
144         "processes": len(psutil.pids()),
145         "softirq": soft_irq,
146         "syscalls": sys_calls,
147     }
148 def meminfo():
149     """
150     Return information about physical and virtual memory on the system
151     Returns:
152         dict: A dictionary of information about memory on the system
153     CLI Example:
154     .. code-block:: bash
155         salt * status.meminfo
156     """
157     vm_total, vm_available, vm_percent, vm_used, vm_free = psutil.virtual_memory()
158     swp_total, swp_used, swp_free, swp_percent, _, _ = psutil.swap_memory()
159     def get_unit_value(memory):
160         symbols = ("K", "M", "G", "T", "P", "E", "Z", "Y")
161         prefix = {}
162         for i, s in enumerate(symbols):
163             prefix[s] = 1 &lt;&lt; (i + 1) * 10
164         for s in reversed(symbols):
165             if memory &gt;= prefix[s]:
166                 value = float(memory) / prefix[s]
167                 return {"unit": s, "value": value}
168         return {"unit": "B", "value": memory}
169     return {
170         "VmallocTotal": get_unit_value(vm_total),
171         "VmallocUsed": get_unit_value(vm_used),
172         "VmallocFree": get_unit_value(vm_free),
173         "VmallocAvail": get_unit_value(vm_available),
174         "SwapTotal": get_unit_value(swp_total),
175         "SwapUsed": get_unit_value(swp_used),
176         "SwapFree": get_unit_value(swp_free),
177     }
178 def vmstats():
179     """
180     Return information about the virtual memory on the machine
181     Returns:
182         dict: A dictionary of virtual memory stats
183     CLI Example:
184     .. code-block:: bash
185         salt * status.vmstats
186     spi = SYSTEM_PERFORMANCE_INFORMATION()
187     retlen = ctypes<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.c_ulong()
188     ctypes.windll.ntdll.NtQuerySystemInformation(
189         2, ctypes.byref(spi), ctypes.sizeof(spi), ctypes.byref(</b></font>retlen)
190     )
191     ret = {}
192     for field in spi._fields_:
193         ret.update({field[0]: getattr(spi, field[0])})
194     return ret
195 def loadavg():
196     """
197     Returns counter information related to the load of the machine
198     Returns:
199         dict: A dictionary of counters
200     CLI Example:
201     .. code-block:: bash
202         salt * status.loadavg
203     """
204     counter_list = [
205         ("Memory", None, "Available Bytes"),
206         ("Memory", None, "Pages/sec"),
207         ("Paging File", "*", "% Usage"),
208         ("Processor", "*", "% Processor Time"),
209         ("Processor", "*", "DPCs Queued/sec"),
210         ("Processor", "*", "% Privileged Time"),
211         ("Processor", "*", "% User Time"),
212         ("Processor", "*", "% DPC Time"),
213         ("Processor", "*", "% Interrupt Time"),
214         ("Server", None, "Work Item Shortages"),
215         ("Server Work Queues", "*", "Queue Length"),
216         ("System", None, "Processor Queue Length"),
217         ("System", None, "Context Switches/sec"),
218     ]
219     return salt.utils.win_pdh.get_counters(counter_list=counter_list)
220 def cpuload():
221     """
222     .. versionadded:: 2015.8.0
223     Return the processor load as a percentage
224     CLI Example:
225     .. code-block:: bash
226        salt '*' status.cpuload
227     """
228     return psutil.cpu_percent()
229 def diskusage(human_readable=False, path=None):
230     """
231     .. versionadded:: 2015.8.0
232     Return the disk usage for this minion
233     human_readable : False
234         If ``True``, usage will be in KB/MB/GB etc.
235     CLI Example:
236     .. code-block:: bash
237         salt '*' status.diskusage path=c:/salt
238     """
239     if not path:
240         path = "c:/"
241     disk_stats = psutil.disk_usage(path)
242     total_val = disk_stats.total
243     used_val = disk_stats.used
244     free_val = disk_stats.free
245     percent = disk_stats.percent
246     if human_readable:
247         total_val = _byte_calc(total_val)
248         used_val = _byte_calc(used_val)
249         free_val = _byte_calc(free_val)
250     return {"total": total_val, "used": used_val, "free": free_val, "percent": percent}
251 def procs(count=False):
252     """
253     Return the process data
254     count : False
255         If ``True``, this function will simply return the number of processes.
256         .. versionadded:: 2015.8.0
257     CLI Example:
258     .. code-block:: bash
259         salt '*' status.procs
260         salt '*' status.procs count
261     """
262     with salt.utils.winapi.Com():
263         wmi_obj = wmi.WMI()
264         processes = wmi_obj.win32_process()
265     if count:
266         return len(processes)
267     process_info = {}
268     for proc in processes:
269         process_info[proc.ProcessId] = _get_process_info(proc)
270     return process_info
271 def saltmem(human_readable=False):
272     """
273     .. versionadded:: 2015.8.0
274     Returns the amount of memory that salt is using
275     human_readable : False
276         return the value in a nicely formatted number
277     CLI Example:
278     .. code-block:: bash
279         salt '*' status.saltmem
280         salt '*' status.saltmem human_readable=True
281     """
282     p = psutil.Process()
283     with p.oneshot():
284         mem = p.memory_info().rss
285     if human_readable:
286         return _byte_calc(mem)
287     return mem
288 def uptime(human_readable=False):
289     """
290     .. versionadded:: 2015.8.0
291     Return the system uptime for the machine
292     Args:
293         human_readable (bool):
294             Return uptime in human readable format if ``True``, otherwise
295             return seconds. Default is ``False``
296             .. note::
297                 Human readable format is ``days, hours:min:sec``. Days will only
298                 be displayed if more than 0
299     Returns:
300         str:
301             The uptime in seconds or human readable format depending on the
302             value of ``human_readable``
303     CLI Example:
304     .. code-block:: bash
305         salt '*' status.uptime
306         salt '*' status.uptime human_readable=True
307     """
308     startup_time = datetime.datetime.fromtimestamp(psutil.boot_time())
309     uptime = datetime.datetime.now() - startup_time
310     return str(uptime) if human_readable else uptime.total_seconds()
311 def _get_process_info(proc):
312     """
313     Return  process information
314     """
315     cmd = salt.utils.stringutils.to_unicode(proc.CommandLine or "")
316     name = salt.utils.stringutils.to_unicode(proc.Name)
317     info = dict(cmd=cmd, name=name, **_get_process_owner(proc))
318     return info
319 def _get_process_owner(process):
320     owner = {}
321     domain, error_code, user = None, None, None
322     try:
323         domain, error_code, user = process.GetOwner()
324         owner["user"] = salt.utils.stringutils.to_unicode(user)
325         owner["user_domain"] = salt.utils.stringutils.to_unicode(domain)
326     except Exception as exc:  # pylint: disable=broad-except
327         pass
328     if not error_code and all((user, domain)):
329         owner["user"] = salt.utils.stringutils.to_unicode(user)
330         owner["user_domain"] = salt.utils.stringutils.to_unicode(domain)
331     elif process.ProcessId in [0, 4] and error_code == 2:
332         owner["user"] = "SYSTEM"
333         owner["user_domain"] = "NT AUTHORITY"
334     else:
335         log.warning(
336             "Error getting owner of process; PID='%s'; Error: %s",
337             process.ProcessId,
338             error_code,
339         )
340     return owner
341 def _byte_calc(val):
342     if val &lt; 1024:
343         tstr = str(val) + "B"
344     elif val &lt; 1038336:
345         tstr = str(val / 1024) + "KB"
346     elif val &lt; 1073741824:
347         tstr = str(val / 1038336) + "MB"
348     elif val &lt; 1099511627776:
349         tstr = str(val / 1073741824) + "GB"
350     else:
351         tstr = str(val / 1099511627776) + "TB"
352     return tstr
353 def master(master=None, connected=True):
354     """
355     .. versionadded:: 2015.5.0
356     Fire an event if the minion gets disconnected from its master. This
357     function is meant to be run via a scheduled job from the minion. If
358     master_ip is an FQDN/Hostname, is must be resolvable to a valid IPv4
359     address.
360     CLI Example:
361     .. code-block:: bash
362         salt '*' status.master
363     """
364     def _win_remotes_on(port):
365         """
366         Windows specific helper function.
367         Returns set of ipv4 host addresses of remote established connections
368         on local or remote tcp port.
369         Parses output of shell 'netstat' to get connections
370         PS C:&gt; netstat -n -p TCP
371         Active Connections
372           Proto  Local Address          Foreign Address        State
373           TCP    10.1.1.26:3389         10.1.1.1:4505          ESTABLISHED
374           TCP    10.1.1.26:56862        10.1.1.10:49155        TIME_WAIT
375           TCP    10.1.1.26:56868        169.254.169.254:80     CLOSE_WAIT
376           TCP    127.0.0.1:49197        127.0.0.1:49198        ESTABLISHED
377           TCP    127.0.0.1:49198        127.0.0.1:49197        ESTABLISHED
378         """
379         remotes = set()
380         try:
381             data = subprocess.check_output(
382                 ["netstat", "-n", "-p", "TCP"]
383             )  # pylint: disable=minimum-python-version
384         except subprocess.CalledProcessError:
385             log.error("Failed netstat")
386             raise
387         lines = salt.utils.stringutils.to_unicode(data).split("\n")
388         for line in lines:
389             if "ESTABLISHED" not in line:
390                 continue
391             chunks = line.split()
392             remote_host, remote_port = chunks[2].rsplit(":", 1)
393             if int(remote_port) != port:
394                 continue
395             remotes.add(remote_host)
396         return remotes
397     port = 4505
398     master_ips = None
399     if master:
400         master_ips = _host_to_ips(master)
401     if not master_ips:
402         return
403     if __salt__["config.get"]("publish_port") != "":
404         port = int(__salt__["config.get"]("publish_port"))
405     master_connection_status = False
406     connected_ips = _win_remotes_on(port)
407     for master_ip in master_ips:
408         if master_ip in connected_ips:
409             master_connection_status = True
410             break
411     if master_connection_status is not connected:
412         with salt.utils.event.get_event(
413             "minion", opts=__opts__, listen=False
414             if master_connection_status:
415                 event_bus.fire_event(
416                     {"master": master}, salt<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.minion.master_event(type="connected")
417                 )
418             else:
419                 event_bus.fire_event(
420                     {"master": master}, salt.minion.master_event(type=</b></font>"disconnected")
421                 )
422     return master_connection_status
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 r"""
2 A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
3 or use Self-Signed certificates.
4 :depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
5     extension support)
6 :configuration: Add the following values in /etc/salt/minion for the CA module
7     to function properly:
8     .. code-block:: yaml
9         ca.cert_base_path: '/etc/pki'
10 CLI Example #1:
11 Creating a CA, a server request and its signed certificate:
12 .. code-block:: bash
13     days=5 \
14     CN='My Little CA' \
15     C=US \
16     ST=Utah \
17     L=Salt Lake City \
18     O=Saltstack \
19     emailAddress=pleasedontemail@example.com
20     Created Private Key: "/etc/pki/my_little/my_little_ca_cert.key"
21     Created CA "my_little_ca": "/etc/pki/my_little_ca/my_little_ca_cert.crt"
22     Created Private Key: "/etc/pki/my_little/certs/www.example.com.key
23     Created CSR for "www.example.com": "/etc/pki/my_little/certs/www.example.com.csr"
24     Created Certificate for "www.example.com": /etc/pki/my_little/certs/www.example.com.crt"
25 CLI Example #2:
26 Creating a client request and its signed certificate
27 .. code-block:: bash
28     Created Private Key: "/etc/pki/my_little/certs//DBReplica_No.1.key."
29     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.csr."
30     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
31 CLI Example #3:
32 Creating both a server and client req + cert for the same CN
33 .. code-block:: bash
34         cert_type=client
35     Created Private Key: "/etc/pki/my_little/certs/MasterDBReplica_No.2.key."
36     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/MasterDBReplica_No.2.csr."
37     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
38         cert_type=server
39     Certificate "MasterDBReplica_No.2" already exists
40     (doh!)
41         cert_type=server type_ext=True
42     Created Private Key: "/etc/pki/my_little/certs/DBReplica_No.1_client.key."
43     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1_client.csr."
44     Certificate "MasterDBReplica_No.2" already exists
45     (DOH!)
46         cert_type=server type_ext=True
47     Created Certificate for "MasterDBReplica_No.2": "/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt"
48 CLI Example #4:
49 Create a server req + cert with non-CN filename for the cert
50 .. code-block:: bash
51         cert_type=server type_ext=True
52     Created Private Key: "/etc/pki/my_little/certs/www.anothersometh.ing_server.key."
53     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/www.anothersometh.ing_server.csr."
54         cert_type=server cert_filename="something_completely_different"
55     Created Certificate for "www.anothersometh.ing": /etc/pki/my_little/certs/something_completely_different.crt
56 """
57 import binascii
58 import calendar
59 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
60 import math
61 import os
62 import re
63 import time
64 from datetime import datetime
65 import salt.utils.data
66 import salt.utils.files
67 import salt.utils.stringutils
68 from salt.exceptions import CommandExecutionError
69 from salt.utils.versions import LooseVersion as _LooseVersion
70 HAS_SSL =</b></font> False
71 X509_EXT_ENABLED = True
72 try:
73     import OpenSSL
74     HAS_SSL = True
75     OpenSSL_version = _LooseVersion(OpenSSL.__dict__.get("__version__", "0.0"))
76 except ImportError:
77     pass
78 log = logging.getLogger(__name__)
79 two_digit_year_fmt = "%y%m%d%H%M%SZ"
80 four_digit_year_fmt = "%Y%m%d%H%M%SZ"
81 def __virtual__():
82     """
83     Only load this module if the ca config options are set
84     """
85     global X509_EXT_ENABLED
86     if HAS_SSL and OpenSSL_version &gt;= _LooseVersion("0.10"):
87         if OpenSSL_version &lt; _LooseVersion("0.14"):
88             X509_EXT_ENABLED = False
89             log.debug(
90                 "You should upgrade pyOpenSSL to at least 0.14.1 to "
91                 "enable the use of X509 extensions in the tls module"
92             )
93         elif OpenSSL_version &lt;= _LooseVersion("0.15"):
94             log.debug(
95                 "You should upgrade pyOpenSSL to at least 0.15.1 to "
96                 "enable the full use of X509 extensions in the tls module"
97             )
98         return True
99     else:
100         X509_EXT_ENABLED = False
101         return (
102             False,
103             "PyOpenSSL version 0.10 or later must be installed "
104             "before this module can be used.",
105         )
106 def _microtime():
107     """
108     Return a Unix timestamp as a string of digits
109     :return:
110     """
111     val1, val2 = math.modf(time.time())
112     val2 = int(val2)
113     return "{:f}{}".format(val1, val2)
114 def cert_base_path(cacert_path=None):
115     """
116     Return the base path for certs from CLI or from options
117     cacert_path
118         absolute path to ca certificates root directory
119     CLI Example:
120     .. code-block:: bash
121         salt '*' tls.cert_base_path
122     """
123     if not cacert_path:
124         cacert_path = __context__.get(
125             "ca.contextual_cert_base_path",
126             __salt__["config.option"]("ca.contextual_cert_base_path"),
127         )
128     if not cacert_path:
129         cacert_path = __context__.get(
130             "ca.cert_base_path", __salt__["config.option"]("ca.cert_base_path")
131         )
132     return cacert_path
133 def _cert_base_path(cacert_path=None):
134     """
135     Retrocompatible wrapper
136     """
137     return cert_base_path(cacert_path)
138 def set_ca_path(cacert_path):
139     """
140     If wanted, store the aforementioned cacert_path in context
141     to be used as the basepath for further operations
142     CLI Example:
143     .. code-block:: bash
144         salt '*' tls.set_ca_path /etc/certs
145     """
146     if cacert_path:
147         __context__["ca.contextual_cert_base_path"] = cacert_path
148     return cert_base_path()
149 def _new_serial(ca_name):
150     """
151     Return a serial number in hex using os.urandom() and a Unix timestamp
152     in microseconds.
153     ca_name
154         name of the CA
155     CN
156         common name in the request
157     """
158     hashnum = int(
159         binascii.hexlify(
160             b"_".join(
161                 (
162                     salt.utils.stringutils.to_bytes(_microtime()),
163                     os.urandom(5),
164                 )
165             )
166         ),
167         16,
168     )
169     log.debug("Hashnum: %s", hashnum)
170     cachedir = __opts__["cachedir"]
171     log.debug("cachedir: %s", cachedir)
172     serial_file = "{}/{}.serial".format(cachedir, ca_name)
173     if not os.path.exists(cachedir):
174         os.makedirs(cachedir)
175     if not os.path.exists(serial_file):
176         mode = "w"
177     else:
178         mode = "a+"
179     with salt.utils.files.fopen(serial_file, mode) as ofile:
180         ofile.write(str(hashnum))
181     return hashnum
182 def _four_digit_year_to_two_digit(datetimeObj):
183     return datetimeObj.strftime(two_digit_year_fmt)
184 def _get_basic_info(ca_name, cert, ca_dir=None):
185     """
186     Get basic info to write out to the index.txt
187     """
188     if ca_dir is None:
189         ca_dir = "{}/{}".format(_cert_base_path(), ca_name)
190     index_file = "{}/index.txt".format(ca_dir)
191     cert = _read_cert(cert)
192     expire_date = _four_digit_year_to_two_digit(_get_expiration_date(cert))
193     serial_number = format(cert.get_serial_number(), "X")
194     subject = "/"
195     subject += "/".join(
196         ["{}={}".format(x, y) for x, y in cert.get_subject().get_components()]
197     )
198     subject += "\n"
199     return (index_file, expire_date, serial_number, subject)
200 def _write_cert_to_database(ca_name, cert, cacert_path=None, status="V"):
201     """
202     write out the index.txt database file in the appropriate directory to
203     track certificates
204     ca_name
205         name of the CA
206     cert
207         certificate to be recorded
208     """
209     set_ca_path(cacert_path)
210     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
211     index_file, expire_date, serial_number, subject = _get_basic_info(
212         ca_name, cert, ca_dir
213     )
214     index_data = "{}\t{}\t\t{}\tunknown\t{}".format(
215         status, expire_date, serial_number, subject
216     )
217     with salt.utils.files.fopen(index_file, "a+") as ofile:
218         ofile.write(salt.utils.stringutils.to_str(index_data))
219 def maybe_fix_ssl_version(ca_name, cacert_path=None, ca_filename=None):
220     """
221     Check that the X509 version is correct
222     (was incorrectly set in previous salt versions).
223     This will fix the version if needed.
224     ca_name
225         ca authority name
226     cacert_path
227         absolute path to ca certificates root directory
228     ca_filename
229         alternative filename for the CA
230         .. versionadded:: 2015.5.3
231     CLI Example:
232     .. code-block:: bash
233         salt '*' tls.maybe_fix_ssl_version test_ca /etc/certs
234     """
235     set_ca_path(cacert_path)
236     if not ca_filename:
237         ca_filename = "{}_ca_cert".format(ca_name)
238     certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
239     ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
240     with salt.utils.files.fopen(certp) as fic:
241         cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, fic.read())
242         if cert.get_version() == 3:
243             log.info("Regenerating wrong x509 version for certificate %s", certp)
244             with salt.utils.files.fopen(ca_keyp) as fic2:
245                 try:
246                     key = OpenSSL.crypto.load_privatekey(
247                         OpenSSL.crypto.FILETYPE_PEM, fic2.read()
248                     )
249                     bits = key.bits()
250                 except Exception:  # pylint: disable=broad-except
251                     bits = 2048
252                 try:
253                     days = (
254                         datetime.strptime(cert.get_notAfter(), "%Y%m%d%H%M%SZ")
255                         - datetime.utcnow()
256                     ).days
257                 except (ValueError, TypeError):
258                     days = 365
259                 subj = cert.get_subject()
260                 create_ca(
261                     ca_name,
262                     bits=bits,
263                     days=days,
264                     CN=subj.CN,
265                     C=subj.C,
266                     ST=subj.ST,
267                     L=subj.L,
268                     O=subj.O,
269                     OU=subj.OU,
270                     emailAddress=subj.emailAddress,
271                     fixmode=True,
272                 )
273 def ca_exists(ca_name, cacert_path=None, ca_filename=None):
274     """
275     Verify whether a Certificate Authority (CA) already exists
276     ca_name
277         name of the CA
278     cacert_path
279         absolute path to ca certificates root directory
280     ca_filename
281         alternative filename for the CA
282         .. versionadded:: 2015.5.3
283     CLI Example:
284     .. code-block:: bash
285         salt '*' tls.ca_exists test_ca /etc/certs
286     """
287     set_ca_path(cacert_path)
288     if not ca_filename:
289         ca_filename = "{}_ca_cert".format(ca_name)
290     certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
291     if os.path.exists(certp):
292         maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
293         return True
294     return False
295 def _ca_exists(ca_name, cacert_path=None):
296     return ca_exists(ca_name, cacert_path)
297 def get_ca(ca_name, as_text=False, cacert_path=None):
298     """
299     Get the certificate path or content
300     ca_name
301         name of the CA
302     as_text
303         if true, return the certificate content instead of the path
304     cacert_path
305         absolute path to ca certificates root directory
306     CLI Example:
307     .. code-block:: bash
308         salt '*' tls.get_ca test_ca as_text=False cacert_path=/etc/certs
309     """
310     set_ca_path(cacert_path)
311     certp = "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
312     if not os.path.exists(certp):
313         raise ValueError("Certificate does not exist for {}".format(ca_name))
314     else:
315         if as_text:
316             with salt.utils.files.fopen(certp) as fic:
317                 certp = salt.utils.stringutils.to_unicode(fic.read())
318     return certp
319 def get_ca_signed_cert(
320     ca_name, CN="localhost", as_text=False, cacert_path=None, cert_filename=None
321 ):
322     """
323     Get the certificate path or content
324     ca_name
325         name of the CA
326     CN
327         common name of the certificate
328     as_text
329         if true, return the certificate content instead of the path
330     cacert_path
331         absolute path to certificates root directory
332     cert_filename
333         alternative filename for the certificate, useful when using special characters in the CN
334         .. versionadded:: 2015.5.3
335     CLI Example:
336     .. code-block:: bash
337         salt '*' tls.get_ca_signed_cert test_ca CN=localhost as_text=False cacert_path=/etc/certs
338     """
339     set_ca_path(cacert_path)
340     if not cert_filename:
341         cert_filename = CN
342     certp = "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, cert_filename)
343     if not os.path.exists(certp):
344         raise ValueError("Certificate does not exists for {}".format(CN))
345     else:
346         if as_text:
347             with salt.utils.files.fopen(certp) as fic:
348                 certp = salt.utils.stringutils.to_unicode(fic.read())
349     return certp
350 def get_ca_signed_key(
351     ca_name, CN="localhost", as_text=False, cacert_path=None, key_filename=None
352 ):
353     """
354     Get the certificate path or content
355     ca_name
356         name of the CA
357     CN
358         common name of the certificate
359     as_text
360         if true, return the certificate content instead of the path
361     cacert_path
362         absolute path to certificates root directory
363     key_filename
364         alternative filename for the key, useful when using special characters
365         .. versionadded:: 2015.5.3
366         in the CN
367     CLI Example:
368     .. code-block:: bash
369         salt '*' tls.get_ca_signed_key \
370                 test_ca CN=localhost \
371                 as_text=False \
372                 cacert_path=/etc/certs
373     """
374     set_ca_path(cacert_path)
375     if not key_filename:
376         key_filename = CN
377     keyp = "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, key_filename)
378     if not os.path.exists(keyp):
379         raise ValueError("Certificate does not exists for {}".format(CN))
380     else:
381         if as_text:
382             with salt.utils.files.fopen(keyp) as fic:
383                 keyp = salt.utils.stringutils.to_unicode(fic.read())
384     return keyp
385 def _read_cert(cert):
386     if isinstance(cert, str):
387         try:
388             with salt.utils.files.fopen(cert) as rfh:
389                 return OpenSSL.crypto.load_certificate(
390                     OpenSSL.crypto.FILETYPE_PEM, rfh.read()
391                 )
392         except Exception:  # pylint: disable=broad-except
393             log.exception("Failed to read cert from path %s", cert)
394             return None
395     else:
396         if not hasattr(cert, "get_notAfter"):
397             log.error("%s is not a valid cert path/object", cert)
398             return None
399         else:
400             return cert
401 def validate(cert, ca_name, crl_file):
402     """
403     .. versionadded:: 3000
404     Validate a certificate against a given CA/CRL.
405     cert
406         path to the certifiate PEM file or string
407     ca_name
408         name of the CA
409     crl_file
410         full path to the CRL file
411     """
412     store = OpenSSL.crypto.X509Store()
413     cert_obj = _read_cert(cert)
414     if cert_obj is None:
415         raise CommandExecutionError(
416             "Failed to read cert from {}, see log for details".format(cert)
417         )
418     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
419     ca_cert = _read_cert("{}/{}_ca_cert.crt".format(ca_dir, ca_name))
420     store.add_cert(ca_cert)
421     X509StoreFlags = OpenSSL.crypto.X509StoreFlags
422     store.set_flags(X509StoreFlags.CRL_CHECK | X509StoreFlags.CRL_CHECK_ALL)
423     if crl_file is None:
424         crl = OpenSSL.crypto.CRL()
425     else:
426         with salt.utils.files.fopen(crl_file) as fhr:
427             crl = OpenSSL.crypto.load_crl(OpenSSL.crypto.FILETYPE_PEM, fhr.read())
428     store.add_crl(crl)
429     context = OpenSSL.crypto.X509StoreContext(store, cert_obj)
430     ret = {}
431     try:
432         context.verify_certificate()
433         ret["valid"] = True
434     except OpenSSL.crypto.X509StoreContextError as e:
435         ret["error"] = str(e)
436         ret["error_cert"] = e.certificate
437         ret["valid"] = False
438     return ret
439 def _get_expiration_date(cert):
440     """
441     Returns a datetime.datetime object
442     """
443     cert_obj = _read_cert(cert)
444     if cert_obj is None:
445         raise CommandExecutionError(
446             "Failed to read cert from {}, see log for details".format(cert)
447         )
448     return datetime.strptime(
449         salt.utils.stringutils.to_str(cert_obj.get_notAfter()), four_digit_year_fmt
450     )
451 def get_expiration_date(cert, date_format="%Y-%m-%d"):
452     """
453     .. versionadded:: 2019.2.0
454     Get a certificate's expiration date
455     cert
456         Full path to the certificate
457     date_format
458         By default this will return the expiration date in YYYY-MM-DD format,
459         use this to specify a different strftime format string. Note that the
460         expiration time will be in UTC.
461     CLI Examples:
462     .. code-block:: bash
463         salt '*' tls.get_expiration_date /path/to/foo.crt
464         salt '*' tls.get_expiration_date /path/to/foo.crt date_format='%d/%m/%Y'
465     """
466     return _get_expiration_date(cert).strftime(date_format)
467 def _check_onlyif_unless(onlyif, unless):
468     ret = None
469     retcode = __salt__["cmd.retcode"]
470     if onlyif is not None:
471         if not isinstance(onlyif, str):
472             if not onlyif:
473                 ret = {"comment": "onlyif condition is false", "result": True}
474         elif isinstance(onlyif, str):
475             if retcode(onlyif) != 0:
476                 ret = {"comment": "onlyif condition is false", "result": True}
477                 log.debug("onlyif condition is false")
478     if unless is not None:
479         if not isinstance(unless, str):
480             if unless:
481                 ret = {"comment": "unless condition is true", "result": True}
482         elif isinstance(unless, str):
483             if retcode(unless) == 0:
484                 ret = {"comment": "unless condition is true", "result": True}
485                 log.debug("unless condition is true")
486     return ret
487 def create_ca(
488     ca_name,
489     bits=2048,
490     days=365,
491     CN="localhost",
492     C="US",
493     ST="Utah",
494     L="Salt Lake City",
495     O="SaltStack",
496     OU=None,
497     emailAddress=None,
498     fixmode=False,
499     cacert_path=None,
500     ca_filename=None,
501     digest="sha256",
502     onlyif=None,
503     unless=None,
504     replace=False,
505 ):
506     """
507     Create a Certificate Authority (CA)
508     ca_name
509         name of the CA
510     bits
511         number of RSA key bits, default is 2048
512     days
513         number of days the CA will be valid, default is 365
514     CN
515         common name in the request, default is "localhost"
516     C
517         country, default is "US"
518     ST
519         state, default is "Utah"
520     L
521         locality, default is "Centerville", the city where SaltStack originated
522     O
523         organization, default is "SaltStack"
524     OU
525         organizational unit, default is None
526     emailAddress
527         email address for the CA owner, default is None
528     cacert_path
529         absolute path to ca certificates root directory
530     ca_filename
531         alternative filename for the CA
532         .. versionadded:: 2015.5.3
533     digest
534         The message digest algorithm. Must be a string describing a digest
535         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
536         For example, "md5" or "sha1". Default: 'sha256'
537     replace
538         Replace this certificate even if it exists
539         .. versionadded:: 2015.5.1
540     Writes out a CA certificate based upon defined config values. If the file
541     already exists, the function just returns assuming the CA certificate
542     already exists.
543     If the following values were set::
544         ca.cert_base_path='/etc/pki'
545         ca_name='koji'
546     the resulting CA, and corresponding key, would be written in the following
547     location with appropriate permissions::
548         /etc/pki/koji/koji_ca_cert.crt
549         /etc/pki/koji/koji_ca_cert.key
550     CLI Example:
551     .. code-block:: bash
552         salt '*' tls.create_ca test_ca
553     """
554     status = _check_onlyif_unless(onlyif, unless)
555     if status is not None:
556         return None
557     set_ca_path(cacert_path)
558     if not ca_filename:
559         ca_filename = "{}_ca_cert".format(ca_name)
560     certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
561     ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
562     if not replace and not fixmode and ca_exists(ca_name, ca_filename=ca_filename):
563         return 'Certificate for CA named "{}" already exists'.format(ca_name)
564     if fixmode and not os.path.exists(certp):
565         raise ValueError("{} does not exists, can't fix".format(certp))
566     if not os.path.exists("{}/{}".format(cert_base_path(), ca_name)):
567         os.makedirs("{}/{}".format(cert_base_path(), ca_name))
568     key = None
569     if os.path.exists(ca_keyp):
570         with salt.utils.files.fopen(ca_keyp) as fic2:
571             try:
572                 key = OpenSSL.crypto.load_privatekey(
573                     OpenSSL.crypto.FILETYPE_PEM, fic2.read()
574                 )
575             except OpenSSL.crypto.Error as err:
576                 log.warning(
577                     "Error loading existing private key %s, generating a new key: %s",
578                     ca_keyp,
579                     err,
580                 )
581                 bck = "{}.unloadable.{}".format(
582                     ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S")
583                 )
584                 log.info("Saving unloadable CA ssl key in %s", bck)
585                 os.rename(ca_keyp, bck)
586     if not key:
587         key = OpenSSL.crypto.PKey()
588         key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
589     ca = OpenSSL.crypto.X509()
590     ca.set_version(2)
591     ca.set_serial_number(_new_serial(ca_name))
592     ca.get_subject().C = C
593     ca.get_subject().ST = ST
594     ca.get_subject().L = L
595     ca.get_subject().O = O
596     if OU:
597         ca.get_subject().OU = OU
598     ca.get_subject().CN = CN
599     if emailAddress:
600         ca.get_subject().emailAddress = emailAddress
601     ca.gmtime_adj_notBefore(0)
602     ca.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
603     ca.set_issuer(ca.get_subject())
604     ca.set_pubkey(key)
605     if X509_EXT_ENABLED:
606         ca.add_extensions(
607             [
608                 OpenSSL.crypto.X509Extension(
609                     b"basicConstraints", True, b"CA:TRUE, pathlen:0"
610                 ),
611                     b"keyUsage", True, b"keyCertSign, cRLSign"
612                 ),
613                 OpenSSL<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.crypto.X509Extension(
614                     b"subjectKeyIdentifier", False, b"hash", subject=ca
615                 ),
616             ]
617         )
618         ca.add_extensions(
619             [
620                 OpenSSL.crypto.X509Extension(
621                     b"authorityKeyIdentifier",
622                     False,
623                     b"issuer:always,keyid:always",
624                     issuer=</b></font>ca,
625                 )
626             ]
627         )
628     ca.sign(key, salt.utils.stringutils.to_str(digest))
629     keycontent = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
630     write_key = True
631     if os.path.exists(ca_keyp):
632         bck = "{}.{}".format(ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S"))
633         with salt.utils.files.fopen(ca_keyp) as fic:
634             old_key = salt.utils.stringutils.to_unicode(fic.read()).strip()
635             if old_key.strip() == keycontent.strip():
636                 write_key = False
637             else:
638                 log.info("Saving old CA ssl key in %s", bck)
639                 fp = os.open(bck, os.O_CREAT | os.O_RDWR, 0o600)
640                 with salt.utils.files.fopen(fp, "w") as bckf:
641                     bckf.write(old_key)
642     if write_key:
643         fp = os.open(ca_keyp, os.O_CREAT | os.O_RDWR, 0o600)
644         with salt.utils.files.fopen(fp, "wb") as ca_key:
645             ca_key.write(salt.utils.stringutils.to_bytes(keycontent))
646     with salt.utils.files.fopen(certp, "wb") as ca_crt:
647         ca_crt.write(
648             salt.utils.stringutils.to_bytes(
649                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, ca)
650             )
651         )
652     _write_cert_to_database(ca_name, ca)
653     ret = 'Created Private Key: "{}/{}/{}.key." '.format(
654         cert_base_path(), ca_name, ca_filename
655     )
656     ret += 'Created CA "{0}": "{1}/{0}/{2}.crt."'.format(
657         ca_name, cert_base_path(), ca_filename
658     )
659     return ret
660 def get_extensions(cert_type):
661     """
662     Fetch X509 and CSR extension definitions from tls:extensions:
663     (common|server|client) or set them to standard defaults.
664     .. versionadded:: 2015.8.0
665     cert_type:
666         The type of certificate such as ``server`` or ``client``.
667     CLI Example:
668     .. code-block:: bash
669         salt '*' tls.get_extensions client
670     """
671     assert X509_EXT_ENABLED, (
672         "X509 extensions are not supported in "
673         "pyOpenSSL prior to version 0.15.1. Your "
674         "version: {}".format(OpenSSL_version)
675     )
676     ext = {}
677     if cert_type == "":
678         log.error(
679             "cert_type set to empty in tls_ca.get_extensions(); "
680             "defaulting to ``server``"
681         )
682         cert_type = "server"
683     try:
684         ext["common"] = __salt__["pillar.get"]("tls.extensions:common", False)
685     except NameError as err:
686         log.debug(err)
687     if not ext["common"] or ext["common"] == "":
688         ext["common"] = {
689             "csr": {"basicConstraints": "CA:FALSE"},
690             "cert": {
691                 "authorityKeyIdentifier": "keyid,issuer:always",
692                 "subjectKeyIdentifier": "hash",
693             },
694         }
695     try:
696         ext["server"] = __salt__["pillar.get"]("tls.extensions:server", False)
697     except NameError as err:
698         log.debug(err)
699     if not ext["server"] or ext["server"] == "":
700         ext["server"] = {
701             "csr": {
702                 "extendedKeyUsage": "serverAuth",
703                 "keyUsage": "digitalSignature, keyEncipherment",
704             },
705             "cert": {},
706         }
707     try:
708         ext["client"] = __salt__["pillar.get"]("tls.extensions:client", False)
709     except NameError as err:
710         log.debug(err)
711     if not ext["client"] or ext["client"] == "":
712         ext["client"] = {
713             "csr": {
714                 "extendedKeyUsage": "clientAuth",
715                 "keyUsage": "nonRepudiation, digitalSignature, keyEncipherment",
716             },
717             "cert": {},
718         }
719     if cert_type not in ext:
720         try:
721             ext[cert_type] = __salt__["pillar.get"](
722                 "tls.extensions:{}".format(cert_type)
723             )
724         except NameError as e:
725             log.debug(
726                 "pillar, tls:extensions:%s not available or "
727                 "not operating in a salt context\n%s",
728                 cert_type,
729                 e,
730             )
731     retval = ext["common"]
732     for Use in retval:
733         retval[Use].update(ext[cert_type][Use])
734     return retval
735 def create_csr(
736     ca_name,
737     bits=2048,
738     CN="localhost",
739     C="US",
740     ST="Utah",
741     L="Salt Lake City",
742     O="SaltStack",
743     OU=None,
744     emailAddress=None,
745     subjectAltName=None,
746     cacert_path=None,
747     ca_filename=None,
748     csr_path=None,
749     csr_filename=None,
750     digest="sha256",
751     type_ext=False,
752     cert_type="server",
753     replace=False,
754 ):
755     """
756     Create a Certificate Signing Request (CSR) for a
757     particular Certificate Authority (CA)
758     ca_name
759         name of the CA
760     bits
761         number of RSA key bits, default is 2048
762     CN
763         common name in the request, default is "localhost"
764     C
765         country, default is "US"
766     ST
767         state, default is "Utah"
768     L
769         locality, default is "Centerville", the city where SaltStack originated
770     O
771         organization, default is "SaltStack"
772         NOTE: Must the same as CA certificate or an error will be raised
773     OU
774         organizational unit, default is None
775     emailAddress
776         email address for the request, default is None
777     subjectAltName
778         valid subjectAltNames in full form, e.g. to add DNS entry you would call
779         this function with this value:
780         examples: ['DNS:somednsname.com',
781                 'DNS:1.2.3.4',
782                 'IP:1.2.3.4',
783                 'IP:2001:4801:7821:77:be76:4eff:fe11:e51',
784                 'email:me@i.like.pie.com']
785     .. note::
786         some libraries do not properly query IP: prefixes, instead looking
787         for the given req. source with a DNS: prefix. To be thorough, you
788         may want to include both DNS: and IP: entries if you are using
789         subjectAltNames for destinations for your TLS connections.
790         e.g.:
791         requests to https://1.2.3.4 will fail from python's
792         requests library w/out the second entry in the above list
793     .. versionadded:: 2015.8.0
794     cert_type
795         Specify the general certificate type. Can be either `server` or
796         `client`. Indicates the set of common extensions added to the CSR.
797         .. code-block:: cfg
798             server: {
799                'basicConstraints': 'CA:FALSE',
800                'extendedKeyUsage': 'serverAuth',
801                'keyUsage': 'digitalSignature, keyEncipherment'
802             }
803             client: {
804                'basicConstraints': 'CA:FALSE',
805                'extendedKeyUsage': 'clientAuth',
806                'keyUsage': 'nonRepudiation, digitalSignature, keyEncipherment'
807             }
808     type_ext
809         boolean.  Whether or not to extend the filename with CN_[cert_type]
810         This can be useful if a server and client certificate are needed for
811         the same CN. Defaults to False to avoid introducing an unexpected file
812         naming pattern
813         The files normally named some_subject_CN.csr and some_subject_CN.key
814         will then be saved
815     replace
816         Replace this signing request even if it exists
817         .. versionadded:: 2015.5.1
818     Writes out a Certificate Signing Request (CSR) If the file already
819     exists, the function just returns assuming the CSR already exists.
820     If the following values were set::
821         ca.cert_base_path='/etc/pki'
822         ca_name='koji'
823         CN='test.egavas.org'
824     the resulting CSR, and corresponding key, would be written in the
825     following location with appropriate permissions::
826         /etc/pki/koji/certs/test.egavas.org.csr
827         /etc/pki/koji/certs/test.egavas.org.key
828     CLI Example:
829     .. code-block:: bash
830         salt '*' tls.create_csr test
831     """
832     set_ca_path(cacert_path)
833     if not ca_filename:
834         ca_filename = "{}_ca_cert".format(ca_name)
835     if not ca_exists(ca_name, ca_filename=ca_filename):
836         return 'Certificate for CA named "{}" does not exist, please create it first.'.format(
837             ca_name
838         )
839     if not csr_path:
840         csr_path = "{}/{}/certs/".format(cert_base_path(), ca_name)
841     if not os.path.exists(csr_path):
842         os.makedirs(csr_path)
843     CN_ext = "_{}".format(cert_type) if type_ext else ""
844     if not csr_filename:
845         csr_filename = "{}{}".format(CN, CN_ext)
846     csr_f = "{}/{}.csr".format(csr_path, csr_filename)
847     if not replace and os.path.exists(csr_f):
848         return 'Certificate Request "{}" already exists'.format(csr_f)
849     key = OpenSSL.crypto.PKey()
850     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
851     req = OpenSSL.crypto.X509Req()
852     req.get_subject().C = C
853     req.get_subject().ST = ST
854     req.get_subject().L = L
855     req.get_subject().O = O
856     if OU:
857         req.get_subject().OU = OU
858     req.get_subject().CN = CN
859     if emailAddress:
860         req.get_subject().emailAddress = emailAddress
861     try:
862         extensions = get_extensions(cert_type)["csr"]
863         extension_adds = []
864         for ext, value in extensions.items():
865             if isinstance(value, str):
866                 value = salt.utils.stringutils.to_bytes(value)
867             extension_adds.append(
868                 OpenSSL.crypto.X509Extension(
869                     salt.utils.stringutils.to_bytes(ext), False, value
870                 )
871             )
872     except AssertionError as err:
873         log.error(err)
874         extensions = []
875     if subjectAltName:
876         if X509_EXT_ENABLED:
877             if isinstance(subjectAltName, str):
878                 subjectAltName = [subjectAltName]
879             extension_adds.append(
880                 OpenSSL.crypto.X509Extension(
881                     b"subjectAltName",
882                     False,
883                     b", ".join(salt.utils.data.encode(subjectAltName)),
884                 )
885             )
886         else:
887             raise ValueError(
888                 "subjectAltName cannot be set as X509 "
889                 "extensions are not supported in pyOpenSSL "
890                 "prior to version 0.15.1. Your "
891                 "version: {}.".format(OpenSSL_version)
892             )
893     if X509_EXT_ENABLED:
894         req.add_extensions(extension_adds)
895     req.set_pubkey(key)
896     req.sign(key, salt.utils.stringutils.to_str(digest))
897     priv_keyp = "{}/{}.key".format(csr_path, csr_filename)
898     fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
899     with salt.utils.files.fopen(fp, "wb+") as priv_key:
900         priv_key.write(
901             salt.utils.stringutils.to_bytes(
902                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
903             )
904         )
905     with salt.utils.files.fopen(csr_f, "wb+") as csr:
906         csr.write(
907             salt.utils.stringutils.to_bytes(
908                 OpenSSL.crypto.dump_certificate_request(
909                     OpenSSL.crypto.FILETYPE_PEM, req
910                 )
911             )
912         )
913     ret = 'Created Private Key: "{}{}.key." '.format(csr_path, csr_filename)
914     ret += 'Created CSR for "{}": "{}{}.csr."'.format(CN, csr_path, csr_filename)
915     return ret
916 def create_self_signed_cert(
917     tls_dir="tls",
918     bits=2048,
919     days=365,
920     CN="localhost",
921     C="US",
922     ST="Utah",
923     L="Salt Lake City",
924     O="SaltStack",
925     OU=None,
926     emailAddress=None,
927     cacert_path=None,
928     cert_filename=None,
929     digest="sha256",
930     replace=False,
931 ):
932     """
933     Create a Self-Signed Certificate (CERT)
934     tls_dir
935         location appended to the ca.cert_base_path, default is 'tls'
936     bits
937         number of RSA key bits, default is 2048
938     CN
939         common name in the request, default is "localhost"
940     C
941         country, default is "US"
942     ST
943         state, default is "Utah"
944     L
945         locality, default is "Centerville", the city where SaltStack originated
946     O
947         organization, default is "SaltStack"
948         NOTE: Must the same as CA certificate or an error will be raised
949     OU
950         organizational unit, default is None
951     emailAddress
952         email address for the request, default is None
953     cacert_path
954         absolute path to ca certificates root directory
955     digest
956         The message digest algorithm. Must be a string describing a digest
957         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
958         For example, "md5" or "sha1". Default: 'sha256'
959     replace
960         Replace this certificate even if it exists
961         .. versionadded:: 2015.5.1
962     Writes out a Self-Signed Certificate (CERT). If the file already
963     exists, the function just returns.
964     If the following values were set::
965         ca.cert_base_path='/etc/pki'
966         tls_dir='koji'
967         CN='test.egavas.org'
968     the resulting CERT, and corresponding key, would be written in the
969     following location with appropriate permissions::
970         /etc/pki/koji/certs/test.egavas.org.crt
971         /etc/pki/koji/certs/test.egavas.org.key
972     CLI Example:
973     .. code-block:: bash
974         salt '*' tls.create_self_signed_cert
975     Passing options from the command line:
976     .. code-block:: bash
977         salt 'minion' tls.create_self_signed_cert CN='test.mysite.org'
978     """
979     set_ca_path(cacert_path)
980     if not os.path.exists("{}/{}/certs/".format(cert_base_path(), tls_dir)):
981         os.makedirs("{}/{}/certs/".format(cert_base_path(), tls_dir))
982     if not cert_filename:
983         cert_filename = CN
984     if not replace and os.path.exists(
985         "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
986     ):
987         return 'Certificate "{}" already exists'.format(cert_filename)
988     key = OpenSSL.crypto.PKey()
989     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
990     cert = OpenSSL.crypto.X509()
991     cert.set_version(2)
992     cert.gmtime_adj_notBefore(0)
993     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
994     cert.get_subject().C = C
995     cert.get_subject().ST = ST
996     cert.get_subject().L = L
997     cert.get_subject().O = O
998     if OU:
999         cert.get_subject().OU = OU
1000     cert.get_subject().CN = CN
1001     if emailAddress:
1002         cert.get_subject().emailAddress = emailAddress
1003     cert.set_serial_number(_new_serial(tls_dir))
1004     cert.set_issuer(cert.get_subject())
1005     cert.set_pubkey(key)
1006     cert.sign(key, salt.utils.stringutils.to_str(digest))
1007     priv_key_path = "{}/{}/certs/{}.key".format(
1008         cert_base_path(), tls_dir, cert_filename
1009     )
1010     fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
1011     with salt.utils.files.fopen(fp, "wb+") as priv_key:
1012         priv_key.write(
1013             salt.utils.stringutils.to_bytes(
1014                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
1015             )
1016         )
1017     crt_path = "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
1018     with salt.utils.files.fopen(crt_path, "wb+") as crt:
1019         crt.write(
1020             salt.utils.stringutils.to_bytes(
1021                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
1022             )
1023         )
1024     _write_cert_to_database(tls_dir, cert)
1025     ret = 'Created Private Key: "{}/{}/certs/{}.key." '.format(
1026         cert_base_path(), tls_dir, cert_filename
1027     )
1028     ret += 'Created Certificate: "{}/{}/certs/{}.crt."'.format(
1029         cert_base_path(), tls_dir, cert_filename
1030     )
1031     return ret
1032 def create_ca_signed_cert(
1033     ca_name,
1034     CN,
1035     days=365,
1036     cacert_path=None,
1037     ca_filename=None,
1038     cert_path=None,
1039     cert_filename=None,
1040     digest="sha256",
1041     cert_type=None,
1042     type_ext=False,
1043     replace=False,
1044 ):
1045     """
1046     Create a Certificate (CERT) signed by a named Certificate Authority (CA)
1047     If the certificate file already exists, the function just returns assuming
1048     the CERT already exists.
1049     The CN *must* match an existing CSR generated by create_csr. If it
1050     does not, this method does nothing.
1051     ca_name
1052         name of the CA
1053     CN
1054         common name matching the certificate signing request
1055     days
1056         number of days certificate is valid, default is 365 (1 year)
1057     cacert_path
1058         absolute path to ca certificates root directory
1059     ca_filename
1060         alternative filename for the CA
1061         .. versionadded:: 2015.5.3
1062     cert_path
1063         full path to the certificates directory
1064     cert_filename
1065         alternative filename for the certificate, useful when using special
1066         characters in the CN. If this option is set it will override
1067         the certificate filename output effects of ``cert_type``.
1068         ``type_ext`` will be completely overridden.
1069         .. versionadded:: 2015.5.3
1070     digest
1071         The message digest algorithm. Must be a string describing a digest
1072         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
1073         For example, "md5" or "sha1". Default: 'sha256'
1074     replace
1075         Replace this certificate even if it exists
1076         .. versionadded:: 2015.5.1
1077     cert_type
1078         string. Either 'server' or 'client' (see create_csr() for details).
1079         If create_csr(type_ext=True) this function **must** be called with the
1080         same cert_type so it can find the CSR file.
1081     .. note::
1082         create_csr() defaults to cert_type='server'; therefore, if it was also
1083         called with type_ext, cert_type becomes a required argument for
1084         create_ca_signed_cert()
1085     type_ext
1086         bool. If set True, use ``cert_type`` as an extension to the CN when
1087         formatting the filename.
1088         e.g.: some_subject_CN_server.crt or some_subject_CN_client.crt
1089         This facilitates the context where both types are required for the same
1090         subject
1091         If ``cert_filename`` is `not None`, setting ``type_ext`` has no
1092         effect
1093     If the following values were set:
1094     .. code-block:: text
1095         ca.cert_base_path='/etc/pki'
1096         ca_name='koji'
1097         CN='test.egavas.org'
1098     the resulting signed certificate would be written in the following
1099     location:
1100     .. code-block:: text
1101         /etc/pki/koji/certs/test.egavas.org.crt
1102     CLI Example:
1103     .. code-block:: bash
1104         salt '*' tls.create_ca_signed_cert test localhost
1105     """
1106     ret = {}
1107     set_ca_path(cacert_path)
1108     if not ca_filename:
1109         ca_filename = "{}_ca_cert".format(ca_name)
1110     if not cert_path:
1111         cert_path = "{}/{}/certs".format(cert_base_path(), ca_name)
1112     if type_ext:
1113         if not cert_type:
1114             log.error(
1115                 "type_ext = True but cert_type is unset. Certificate not written."
1116             )
1117             return ret
1118         elif cert_type:
1119             CN_ext = "_{}".format(cert_type)
1120     else:
1121         CN_ext = ""
1122     csr_filename = "{}{}".format(CN, CN_ext)
1123     if not cert_filename:
1124         cert_filename = "{}{}".format(CN, CN_ext)
1125     if not replace and os.path.exists(
1126         os.path.join(
1127             os.path.sep.join(
1128                 "{}/{}/certs/{}.crt".format(
1129                     cert_base_path(), ca_name, cert_filename
1130                 ).split("/")
1131             )
1132         )
1133     ):
1134         return 'Certificate "{}" already exists'.format(cert_filename)
1135     try:
1136         maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
1137         with salt.utils.files.fopen(
1138             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
1139         ) as fhr:
1140             ca_cert = OpenSSL.crypto.load_certificate(
1141                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
1142             )
1143         with salt.utils.files.fopen(
1144             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
1145         ) as fhr:
1146             ca_key = OpenSSL.crypto.load_privatekey(
1147                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
1148             )
1149     except OSError:
1150         ret["retcode"] = 1
1151         ret["comment"] = 'There is no CA named "{}"'.format(ca_name)
1152         return ret
1153     try:
1154         csr_path = "{}/{}.csr".format(cert_path, csr_filename)
1155         with salt.utils.files.fopen(csr_path) as fhr:
1156             req = OpenSSL.crypto.load_certificate_request(
1157                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
1158             )
1159     except OSError:
1160         ret["retcode"] = 1
1161         ret["comment"] = 'There is no CSR that matches the CN "{}"'.format(
1162             cert_filename
1163         )
1164         return ret
1165     exts = []
1166     try:
1167         exts.extend(req.get_extensions())
1168     except AttributeError:
1169         try:
1170             log.info(
1171                 "req.get_extensions() not supported in pyOpenSSL versions "
1172                 "prior to 0.15. Processing extensions internally. "
1173                 "Your version: %s",
1174                 OpenSSL_version,
1175             )
1176             native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
1177             for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
1178                 ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
1179                 ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
1180                     native_exts_obj, i
1181                 )
1182                 exts.append(ext)
1183         except Exception:  # pylint: disable=broad-except
1184             log.error(
1185                 "X509 extensions are unsupported in pyOpenSSL "
1186                 "versions prior to 0.14. Upgrade required to "
1187                 "use extensions. Current version: %s",
1188                 OpenSSL_version,
1189             )
1190     cert = OpenSSL.crypto.X509()
1191     cert.set_version(2)
1192     cert.set_subject(req.get_subject())
1193     cert.gmtime_adj_notBefore(0)
1194     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
1195     cert.set_serial_number(_new_serial(ca_name))
1196     cert.set_issuer(ca_cert.get_subject())
1197     cert.set_pubkey(req.get_pubkey())
1198     cert.add_extensions(exts)
1199     cert.sign(ca_key, salt.utils.stringutils.to_str(digest))
1200     cert_full_path = "{}/{}.crt".format(cert_path, cert_filename)
1201     with salt.utils.files.fopen(cert_full_path, "wb+") as crt:
1202         crt.write(
1203             salt.utils.stringutils.to_bytes(
1204                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
1205             )
1206         )
1207     _write_cert_to_database(ca_name, cert)
1208     return 'Created Certificate for "{}": "{}/{}.crt"'.format(
1209         CN, cert_path, cert_filename
1210     )
1211 def create_pkcs12(ca_name, CN, passphrase="", cacert_path=None, replace=False):
1212     """
1213     Create a PKCS#12 browser certificate for a particular Certificate (CN)
1214     ca_name
1215         name of the CA
1216     CN
1217         common name matching the certificate signing request
1218     passphrase
1219         used to unlock the PKCS#12 certificate when loaded into the browser
1220     cacert_path
1221         absolute path to ca certificates root directory
1222     replace
1223         Replace this certificate even if it exists
1224         .. versionadded:: 2015.5.1
1225     If the following values were set::
1226         ca.cert_base_path='/etc/pki'
1227         ca_name='koji'
1228         CN='test.egavas.org'
1229     the resulting signed certificate would be written in the
1230     following location::
1231         /etc/pki/koji/certs/test.egavas.org.p12
1232     CLI Example:
1233     .. code-block:: bash
1234         salt '*' tls.create_pkcs12 test localhost
1235     """
1236     set_ca_path(cacert_path)
1237     if not replace and os.path.exists(
1238         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN)
1239     ):
1240         return 'Certificate "{}" already exists'.format(CN)
1241     try:
1242         with salt.utils.files.fopen(
1243             "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
1244         ) as fhr:
1245             ca_cert = OpenSSL.crypto.load_certificate(
1246                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
1247             )
1248     except OSError:
1249         return 'There is no CA named "{}"'.format(ca_name)
1250     try:
1251         with salt.utils.files.fopen(
1252             "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, CN)
1253         ) as fhr:
1254             cert = OpenSSL.crypto.load_certificate(
1255                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
1256             )
1257         with salt.utils.files.fopen(
1258             "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, CN)
1259         ) as fhr:
1260             key = OpenSSL.crypto.load_privatekey(
1261                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
1262             )
1263     except OSError:
1264         return 'There is no certificate that matches the CN "{}"'.format(CN)
1265     pkcs12 = OpenSSL.crypto.PKCS12()
1266     pkcs12.set_certificate(cert)
1267     pkcs12.set_ca_certificates([ca_cert])
1268     pkcs12.set_privatekey(key)
1269     with salt.utils.files.fopen(
1270         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN), "wb"
1271     ) as ofile:
1272         ofile.write(
1273             pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
1274         )
1275     return 'Created PKCS#12 Certificate for "{0}": "{1}/{2}/certs/{0}.p12"'.format(
1276         CN,
1277         cert_base_path(),
1278         ca_name,
1279     )
1280 def cert_info(cert, digest="sha256"):
1281     """
1282     Return information for a particular certificate
1283     cert
1284         path to the certifiate PEM file or string
1285         .. versionchanged:: 2018.3.4
1286     digest
1287         what digest to use for fingerprinting
1288     CLI Example:
1289     .. code-block:: bash
1290         salt '*' tls.cert_info /dir/for/certs/cert.pem
1291     """
1292     date_fmt = "%Y%m%d%H%M%SZ"
1293     if "-----BEGIN" not in cert:
1294         with salt.utils.files.fopen(cert) as cert_file:
1295             cert = cert_file.read()
1296     cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
1297     issuer = {}
1298     for key, value in cert.get_issuer().get_components():
1299         if isinstance(key, bytes):
1300             key = salt.utils.stringutils.to_unicode(key)
1301         if isinstance(value, bytes):
1302             value = salt.utils.stringutils.to_unicode(value)
1303         issuer[key] = value
1304     subject = {}
1305     for key, value in cert.get_subject().get_components():
1306         if isinstance(key, bytes):
1307             key = salt.utils.stringutils.to_unicode(key)
1308         if isinstance(value, bytes):
1309             value = salt.utils.stringutils.to_unicode(value)
1310         subject[key] = value
1311     ret = {
1312         "fingerprint": salt.utils.stringutils.to_unicode(
1313             cert<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.digest(salt.utils.stringutils.to_str(digest))
1314         ),
1315         "subject": subject,
1316         "issuer": issuer,
1317         "serial_number": cert.get_serial_number(),
1318         "not_before": calendar.timegm(
1319             time.strptime(</b></font>
1320                 str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
1321             )
1322         ),
1323         "not_after": calendar.timegm(
1324             time.strptime(
1325                 cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
1326             )
1327         ),
1328     }
1329     if hasattr(cert, "get_extension_count"):
1330         ret["extensions"] = {}
1331         for i in range(cert.get_extension_count()):
1332             try:
1333                 ext = cert.get_extension(i)
1334                 key = salt.utils.stringutils.to_unicode(ext.get_short_name())
1335                 ret["extensions"][key] = str(ext).strip()
1336             except AttributeError:
1337                 continue
1338     if "subjectAltName" in ret.get("extensions", {}):
1339         valid_entries = ("DNS", "IP Address")
1340         valid_names = set()
1341         for name in str(ret["extensions"]["subjectAltName"]).split(", "):
1342             entry, name = name.split(":", 1)
1343             if entry not in valid_entries:
1344                 log.error(
1345                     "Cert %s has an entry (%s) which does not start with %s",
1346                     ret["subject"],
1347                     name,
1348                     "/".join(valid_entries),
1349                 )
1350             else:
1351                 valid_names.add(name)
1352         ret["subject_alt_names"] = list(valid_names)
1353     if hasattr(cert, "get_signature_algorithm"):
1354         try:
1355             value = cert.get_signature_algorithm()
1356             if isinstance(value, bytes):
1357                 value = salt.utils.stringutils.to_unicode(value)
1358             ret["signature_algorithm"] = value
1359         except AttributeError:
1360             pass
1361     return ret
1362 def create_empty_crl(
1363     ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest="sha256"
1364 ):
1365     """
1366     Create an empty Certificate Revocation List.
1367     .. versionadded:: 2015.8.0
1368     ca_name
1369         name of the CA
1370     cacert_path
1371         absolute path to ca certificates root directory
1372     ca_filename
1373         alternative filename for the CA
1374         .. versionadded:: 2015.5.3
1375     crl_file
1376         full path to the CRL file
1377     digest
1378         The message digest algorithm. Must be a string describing a digest
1379         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
1380         For example, "md5" or "sha1". Default: 'sha256'
1381     CLI Example:
1382     .. code-block:: bash
1383         salt '*' tls.create_empty_crl ca_name='koji' \
1384                 ca_filename='ca' \
1385                 crl_file='/etc/openvpn/team1/crl.pem'
1386     """
1387     set_ca_path(cacert_path)
1388     if not ca_filename:
1389         ca_filename = "{}_ca_cert".format(ca_name)
1390     if not crl_file:
1391         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
1392     if os.path.exists("{}".format(crl_file)):
1393         return 'CRL "{}" already exists'.format(crl_file)
1394     try:
1395         with salt.utils.files.fopen(
1396             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
1397         ) as fp_:
1398             ca_cert = OpenSSL.crypto.load_certificate(
1399                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1400             )
1401         with salt.utils.files.fopen(
1402             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
1403         ) as fp_:
1404             ca_key = OpenSSL.crypto.load_privatekey(
1405                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1406             )
1407     except OSError:
1408         return 'There is no CA named "{}"'.format(ca_name)
1409     crl = OpenSSL.crypto.CRL()
1410     crl_text = crl.export(
1411         ca_cert,
1412         ca_key,
1413         digest=salt.utils.stringutils.to_bytes(digest),
1414     )
1415     with salt.utils.files.fopen(crl_file, "w") as f:
1416         f.write(salt.utils.stringutils.to_str(crl_text))
1417     return 'Created an empty CRL: "{}"'.format(crl_file)
1418 def revoke_cert(
1419     ca_name,
1420     CN,
1421     cacert_path=None,
1422     ca_filename=None,
1423     cert_path=None,
1424     cert_filename=None,
1425     crl_file=None,
1426     digest="sha256",
1427 ):
1428     """
1429     Revoke a certificate.
1430     .. versionadded:: 2015.8.0
1431     ca_name
1432         Name of the CA.
1433     CN
1434         Common name matching the certificate signing request.
1435     cacert_path
1436         Absolute path to ca certificates root directory.
1437     ca_filename
1438         Alternative filename for the CA.
1439     cert_path
1440         Path to the cert file.
1441     cert_filename
1442         Alternative filename for the certificate, useful when using special
1443         characters in the CN.
1444     crl_file
1445         Full path to the CRL file.
1446     digest
1447         The message digest algorithm. Must be a string describing a digest
1448         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
1449         For example, "md5" or "sha1". Default: 'sha256'
1450     CLI Example:
1451     .. code-block:: bash
1452         salt '*' tls.revoke_cert ca_name='koji' \
1453                 ca_filename='ca' \
1454                 crl_file='/etc/openvpn/team1/crl.pem'
1455     """
1456     set_ca_path(cacert_path)
1457     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
1458     if ca_filename is None:
1459         ca_filename = "{}_ca_cert".format(ca_name)
1460     if cert_path is None:
1461         cert_path = "{}/{}/certs".format(_cert_base_path(), ca_name)
1462     if cert_filename is None:
1463         cert_filename = "{}".format(CN)
1464     try:
1465         with salt.utils.files.fopen(
1466             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
1467         ) as fp_:
1468             ca_cert = OpenSSL.crypto.load_certificate(
1469                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1470             )
1471         with salt.utils.files.fopen(
1472             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
1473         ) as fp_:
1474             ca_key = OpenSSL.crypto.load_privatekey(
1475                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1476             )
1477     except OSError:
1478         return 'There is no CA named "{}"'.format(ca_name)
1479     client_cert = _read_cert("{}/{}.crt".format(cert_path, cert_filename))
1480     if client_cert is None:
1481         return 'There is no client certificate named "{}"'.format(CN)
1482     index_file, expire_date, serial_number, subject = _get_basic_info(
1483         ca_name, client_cert, ca_dir
1484     )
1485     index_serial_subject = "{}\tunknown\t{}".format(serial_number, subject)
1486     index_v_data = "V\t{}\t\t{}".format(expire_date, index_serial_subject)
1487     index_r_data_pattern = re.compile(
1488         r"R\t" + expire_date + r"\t\d{12}Z\t" + re.escape(index_serial_subject)
1489     )
1490     index_r_data = "R\t{}\t{}\t{}".format(
1491         expire_date,
1492         _four_digit_year_to_two_digit(datetime.utcnow()),
1493         index_serial_subject,
1494     )
1495     ret = {}
1496     with salt.utils.files.fopen(index_file) as fp_:
1497         for line in fp_:
1498             line = salt.utils.stringutils.to_unicode(line)
1499             if index_r_data_pattern.match(line):
1500                 revoke_date = line.split("\t")[2]
1501                 try:
1502                     datetime.strptime(revoke_date, two_digit_year_fmt)
1503                     return '"{}/{}.crt" was already revoked, serial number: {}'.format(
1504                         cert_path, cert_filename, serial_number
1505                     )
1506                 except ValueError:
1507                     ret["retcode"] = 1
1508                     ret[
1509                         "comment"
1510                     ] = "Revocation date '{}' does not matchformat '{}'".format(
1511                         revoke_date, two_digit_year_fmt
1512                     )
1513                     return ret
1514             elif index_serial_subject in line:
1515                 __salt__["file.replace"](
1516                     index_file, index_v_data, index_r_data, backup=False
1517                 )
1518                 break
1519     crl = OpenSSL.crypto.CRL()
1520     with salt.utils.files.fopen(index_file) as fp_:
1521         for line in fp_:
1522             line = salt.utils.stringutils.to_unicode(line)
1523             if line.startswith("R"):
1524                 fields = line.split("\t")
1525                 revoked = OpenSSL.crypto.Revoked()
1526                 revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
1527                 revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
1528                 revoked.set_rev_date(
1529                     salt.utils.stringutils.to_bytes(
1530                         revoke_date_2_digit.strftime(four_digit_year_fmt)
1531                     )
1532                 )
1533                 crl.add_revoked(revoked)
1534     crl_text = crl.export(
1535         ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
1536     )
1537     if crl_file is None:
1538         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
1539     if os.path.isdir(crl_file):
1540         ret["retcode"] = 1
1541         ret["comment"] = 'crl_file "{}" is an existing directory'.format(crl_file)
1542         return ret
1543     with salt.utils.files.fopen(crl_file, "w") as fp_:
1544         fp_.write(salt.utils.stringutils.to_str(crl_text))
1545     return 'Revoked Certificate: "{}/{}.crt", serial number: {}'.format(
1546         cert_path, cert_filename, serial_number
1547     )
1548 if __name__ == "__main__":
1549     create_csr(
1550         "koji",
1551         CN="test_system",
1552         C="US",
1553         ST="Utah",
1554         L="Centerville",
1555         O="SaltStack",
1556         OU=None,
1557         emailAddress="test_system@saltstack.org",
1558     )
1559     create_ca_signed_cert("koji", "test_system")
1560     create_pkcs12("koji", "test_system", passphrase="test")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
