<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_status.py &amp; tls_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_status.py &amp; tls_1.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_status.py (5.863192%)<th>tls_1.py (1.5964524%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(580-584)<td><a href="#" name="0">(799-811)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(253-258)<td><a href="#" name="1">(1685-1691)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(12-28)<td><a href="#" name="2">(103-119)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import ctypes
2 import datetime
3 import logging
4 import subprocess
5 import salt.utils.event
6 import salt.utils.platform
7 import salt.utils.stringutils
8 import salt.utils.win_pdh
9 from salt.modules.status import ping_master, time_
10 from salt.utils.functools import namespaced_function as _namespaced_function
11 from salt.utils.network import host_to_ips as _host_to_ips
12 log =</b></font> logging.getLogger(__name__)
13 try:
14     if salt.utils.platform.is_windows():
15         import wmi
16         import salt.utils.winapi
17         HAS_WMI = True
18     else:
19         HAS_WMI = False
20 except ImportError:
21     HAS_WMI = False
22 HAS_PSUTIL = False
23 if salt.utils.platform.is_windows():
24     import psutil
25     HAS_PSUTIL = True
26 __opts__ = {}
27 __virtualname__ = "status"
28 class SYSTEM_PERFORMANCE_INFORMATION(ctypes.Structure):
29     _fields_ = [
30         ("IdleProcessTime", ctypes.c_int64),
31         ("IoReadTransferCount", ctypes.c_int64),
32         ("IoWriteTransferCount", ctypes.c_int64),
33         ("IoOtherTransferCount", ctypes.c_int64),
34         ("IoReadOperationCount", ctypes.c_ulong),
35         ("IoWriteOperationCount", ctypes.c_ulong),
36         ("IoOtherOperationCount", ctypes.c_ulong),
37         ("AvailablePages", ctypes.c_ulong),
38         ("CommittedPages", ctypes.c_ulong),
39         ("CommitLimit", ctypes.c_ulong),
40         ("PeakCommitment", ctypes.c_ulong),
41         ("PageFaultCount", ctypes.c_ulong),
42         ("CopyOnWriteCount", ctypes.c_ulong),
43         ("TransitionCount", ctypes.c_ulong),
44         ("CacheTransitionCount", ctypes.c_ulong),
45         ("DemandZeroCount", ctypes.c_ulong),
46         ("PageReadCount", ctypes.c_ulong),
47         ("PageReadIoCount", ctypes.c_ulong),
48         ("CacheReadCount", ctypes.c_ulong),  # Was c_ulong ** 2
49         ("CacheIoCount", ctypes.c_ulong),
50         ("DirtyPagesWriteCount", ctypes.c_ulong),
51         ("DirtyWriteIoCount", ctypes.c_ulong),
52         ("MappedPagesWriteCount", ctypes.c_ulong),
53         ("MappedWriteIoCount", ctypes.c_ulong),
54         ("PagedPoolPages", ctypes.c_ulong),
55         ("NonPagedPoolPages", ctypes.c_ulong),
56         ("PagedPoolAllocs", ctypes.c_ulong),
57         ("PagedPoolFrees", ctypes.c_ulong),
58         ("NonPagedPoolAllocs", ctypes.c_ulong),
59         ("NonPagedPoolFrees", ctypes.c_ulong),
60         ("FreeSystemPtes", ctypes.c_ulong),
61         ("ResidentSystemCodePage", ctypes.c_ulong),
62         ("TotalSystemDriverPages", ctypes.c_ulong),
63         ("TotalSystemCodePages", ctypes.c_ulong),
64         ("NonPagedPoolLookasideHits", ctypes.c_ulong),
65         ("PagedPoolLookasideHits", ctypes.c_ulong),
66         ("AvailablePagedPoolPages", ctypes.c_ulong),
67         ("ResidentSystemCachePage", ctypes.c_ulong),
68         ("ResidentPagedPoolPage", ctypes.c_ulong),
69         ("ResidentSystemDriverPage", ctypes.c_ulong),
70         ("CcFastReadNoWait", ctypes.c_ulong),
71         ("CcFastReadWait", ctypes.c_ulong),
72         ("CcFastReadResourceMiss", ctypes.c_ulong),
73         ("CcFastReadNotPossible", ctypes.c_ulong),
74         ("CcFastMdlReadNoWait", ctypes.c_ulong),
75         ("CcFastMdlReadWait", ctypes.c_ulong),
76         ("CcFastMdlReadResourceMiss", ctypes.c_ulong),
77         ("CcFastMdlReadNotPossible", ctypes.c_ulong),
78         ("CcMapDataNoWait", ctypes.c_ulong),
79         ("CcMapDataWait", ctypes.c_ulong),
80         ("CcMapDataNoWaitMiss", ctypes.c_ulong),
81         ("CcMapDataWaitMiss", ctypes.c_ulong),
82         ("CcPinMappedDataCount", ctypes.c_ulong),
83         ("CcPinReadNoWait", ctypes.c_ulong),
84         ("CcPinReadWait", ctypes.c_ulong),
85         ("CcPinReadNoWaitMiss", ctypes.c_ulong),
86         ("CcPinReadWaitMiss", ctypes.c_ulong),
87         ("CcCopyReadNoWait", ctypes.c_ulong),
88         ("CcCopyReadWait", ctypes.c_ulong),
89         ("CcCopyReadNoWaitMiss", ctypes.c_ulong),
90         ("CcCopyReadWaitMiss", ctypes.c_ulong),
91         ("CcMdlReadNoWait", ctypes.c_ulong),
92         ("CcMdlReadWait", ctypes.c_ulong),
93         ("CcMdlReadNoWaitMiss", ctypes.c_ulong),
94         ("CcMdlReadWaitMiss", ctypes.c_ulong),
95         ("CcReadAheadIos", ctypes.c_ulong),
96         ("CcLazyWriteIos", ctypes.c_ulong),
97         ("CcLazyWritePages", ctypes.c_ulong),
98         ("CcDataFlushes", ctypes.c_ulong),
99         ("CcDataPages", ctypes.c_ulong),
100         ("ContextSwitches", ctypes.c_ulong),
101         ("FirstLevelTbFills", ctypes.c_ulong),
102         ("SecondLevelTbFills", ctypes.c_ulong),
103         ("SystemCalls", ctypes.c_ulong),
104         ("CcTotalDirtyPages", ctypes.c_ulonglong),
105         ("CcDirtyPagesThreshold", ctypes.c_ulonglong),
106         ("ResidentAvailablePages", ctypes.c_longlong),
107         ("SharedCommittedPages", ctypes.c_ulonglong),
108     ]
109 def __virtual__():
110     if not salt.utils.platform.is_windows():
111         return False, "win_status.py: Requires Windows"
112     if not HAS_WMI:
113         return False, "win_status.py: Requires WMI and WinAPI"
114     if not HAS_PSUTIL:
115         return False, "win_status.py: Requires psutil"
116     global ping_master, time_
117     ping_master = _namespaced_function(ping_master, globals())
118     time_ = _namespaced_function(time_, globals())
119     return __virtualname__
120 __func_alias__ = {"time_": "time"}
121 def cpustats():
122     user, system, idle, interrupt, dpc = psutil.cpu_times()
123     cpu = {"user": user, "system": system, "idle": idle, "irq": interrupt, "dpc": dpc}
124     ctx_switches, interrupts, soft_interrupts, sys_calls = psutil.cpu_stats()
125     intr = {"irqs": {"irqs": [], "total": interrupts}}
126     soft_irq = {"softirqs": [], "total": soft_interrupts}
127     return {
128         "btime": psutil.boot_time(),
129         "cpu": cpu,
130         "ctxt": ctx_switches,
131         "intr": intr,
132         "processes": len(psutil.pids()),
133         "softirq": soft_irq,
134         "syscalls": sys_calls,
135     }
136 def meminfo():
137     vm_total, vm_available, vm_percent, vm_used, vm_free = psutil.virtual_memory()
138     swp_total, swp_used, swp_free, swp_percent, _, _ = psutil.swap_memory()
139     def get_unit_value(memory):
140         symbols = ("K", "M", "G", "T", "P", "E", "Z", "Y")
141         prefix = {}
142         for i, s in enumerate(symbols):
143             prefix[s] = 1 &lt;&lt; (i + 1) * 10
144         for s in reversed(symbols):
145             if memory &gt;= prefix[s]:
146                 value = float(memory) / prefix[s]
147                 return {"unit": s, "value": value}
148         return {"unit": "B", "value": memory}
149     return {
150         "VmallocTotal": get_unit_value(vm_total),
151         "VmallocUsed": get_unit_value(vm_used),
152         "VmallocFree": get_unit_value(vm_free),
153         "VmallocAvail": get_unit_value(vm_available),
154         "SwapTotal": get_unit_value(swp_total),
155         "SwapUsed": get_unit_value(swp_used),
156         "SwapFree": get_unit_value(swp_free),
157     }
158 def vmstats():
159     retlen = ctypes<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.c_ulong()
160     ctypes.windll.ntdll.NtQuerySystemInformation(
161         2, ctypes.byref(spi), ctypes.sizeof(spi), ctypes.byref(</b></font>retlen)
162     )
163     ret = {}
164     for field in spi._fields_:
165         ret.update({field[0]: getattr(spi, field[0])})
166     return ret
167 def loadavg():
168     counter_list = [
169         ("Memory", None, "Available Bytes"),
170         ("Memory", None, "Pages/sec"),
171         ("Paging File", "*", "% Usage"),
172         ("Processor", "*", "% Processor Time"),
173         ("Processor", "*", "DPCs Queued/sec"),
174         ("Processor", "*", "% Privileged Time"),
175         ("Processor", "*", "% User Time"),
176         ("Processor", "*", "% DPC Time"),
177         ("Processor", "*", "% Interrupt Time"),
178         ("Server", None, "Work Item Shortages"),
179         ("Server Work Queues", "*", "Queue Length"),
180         ("System", None, "Processor Queue Length"),
181         ("System", None, "Context Switches/sec"),
182     ]
183     return salt.utils.win_pdh.get_counters(counter_list=counter_list)
184 def cpuload():
185     return psutil.cpu_percent()
186 def diskusage(human_readable=False, path=None):
187     if not path:
188         path = "c:/"
189     disk_stats = psutil.disk_usage(path)
190     total_val = disk_stats.total
191     used_val = disk_stats.used
192     free_val = disk_stats.free
193     percent = disk_stats.percent
194     if human_readable:
195         total_val = _byte_calc(total_val)
196         used_val = _byte_calc(used_val)
197         free_val = _byte_calc(free_val)
198     return {"total": total_val, "used": used_val, "free": free_val, "percent": percent}
199 def procs(count=False):
200     with salt.utils.winapi.Com():
201         wmi_obj = wmi.WMI()
202         processes = wmi_obj.win32_process()
203     if count:
204         return len(processes)
205     process_info = {}
206     for proc in processes:
207         process_info[proc.ProcessId] = _get_process_info(proc)
208     return process_info
209 def saltmem(human_readable=False):
210     p = psutil.Process()
211     with p.oneshot():
212         mem = p.memory_info().rss
213     if human_readable:
214         return _byte_calc(mem)
215     return mem
216 def uptime(human_readable=False):
217     startup_time = datetime.datetime.fromtimestamp(psutil.boot_time())
218     uptime = datetime.datetime.now() - startup_time
219     return str(uptime) if human_readable else uptime.total_seconds()
220 def _get_process_info(proc):
221     cmd = salt.utils.stringutils.to_unicode(proc.CommandLine or "")
222     name = salt.utils.stringutils.to_unicode(proc.Name)
223     info = dict(cmd=cmd, name=name, **_get_process_owner(proc))
224     return info
225 def _get_process_owner(process):
226     owner = {}
227     domain, error_code, user = None, None, None
228     try:
229         domain, error_code, user = process.GetOwner()
230         owner["user"] = salt.utils.stringutils.to_unicode(user)
231         owner["user_domain"] = salt.utils.stringutils.to_unicode(domain)
232     except Exception as exc:  # pylint: disable=broad-except
233         pass
234     if not error_code and all((user, domain)):
235         owner["user"] = salt.utils.stringutils.to_unicode(user)
236         owner["user_domain"] = salt.utils.stringutils.to_unicode(domain)
237     elif process.ProcessId in [0, 4] and error_code == 2:
238         owner["user"] = "SYSTEM"
239         owner["user_domain"] = "NT AUTHORITY"
240     else:
241         log.warning(
242             "Error getting owner of process; PID='%s'; Error: %s",
243             process.ProcessId,
244             error_code,
245         )
246     return owner
247 def _byte_calc(val):
248     if val &lt; 1024:
249         tstr = str(val) + "B"
250     elif val &lt; 1038336:
251         tstr = str(val / 1024) + "KB"
252     elif val &lt; 1073741824:
253         tstr = str(val / 1038336) + "MB"
254     elif val &lt; 1099511627776:
255         tstr = str(val / 1073741824) + "GB"
256     else:
257         tstr = str(val / 1099511627776) + "TB"
258     return tstr
259 def master(master=None, connected=True):
260     def _win_remotes_on(port):
261         remotes = set()
262         try:
263             data = subprocess.check_output(
264                 ["netstat", "-n", "-p", "TCP"]
265             )  # pylint: disable=minimum-python-version
266         except subprocess.CalledProcessError:
267             log.error("Failed netstat")
268             raise
269         lines = salt.utils.stringutils.to_unicode(data).split("\n")
270         for line in lines:
271             if "ESTABLISHED" not in line:
272                 continue
273             chunks = line.split()
274             remote_host, remote_port = chunks[2].rsplit(":", 1)
275             if int(remote_port) != port:
276                 continue
277             remotes.add(remote_host)
278         return remotes
279     port = 4505
280     master_ips = None
281     if master:
282         master_ips = _host_to_ips(master)
283     if not master_ips:
284         return
285     if __salt__["config.get"]("publish_port") != "":
286         port = int(__salt__["config.get"]("publish_port"))
287     master_connection_status = False
288     connected_ips = _win_remotes_on(port)
289     for master_ip in master_ips:
290         if master_ip in connected_ips:
291             master_connection_status = True
292             break
293     if master_connection_status is not connected:
294         with salt.utils.event.get_event(
295             "minion", opts=__opts__, listen=False
296 <a name="0"></a>        ) as event_bus:
297             if master_connection_status:
298                 event_bus.fire_event(
299                     {"master": master}, salt<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.minion.master_event(type="connected")
300                 )
301             else:
302                 event_bus.fire_event(
303                     {"master": master}, salt.minion.master_event(type=</b></font>"disconnected")
304                 )
305     return master_connection_status
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 r"""
2 A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
3 or use Self-Signed certificates.
4 :depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
5     extension support)
6 :configuration: Add the following values in /etc/salt/minion for the CA module
7     to function properly:
8     .. code-block:: yaml
9         ca.cert_base_path: '/etc/pki'
10 CLI Example #1:
11 Creating a CA, a server request and its signed certificate:
12 .. code-block:: bash
13     days=5 \
14     CN='My Little CA' \
15     C=US \
16     ST=Utah \
17     L=Salt Lake City \
18     O=Saltstack \
19     emailAddress=pleasedontemail@example.com
20     Created Private Key: "/etc/pki/my_little/my_little_ca_cert.key"
21     Created CA "my_little_ca": "/etc/pki/my_little_ca/my_little_ca_cert.crt"
22     Created Private Key: "/etc/pki/my_little/certs/www.example.com.key
23     Created CSR for "www.example.com": "/etc/pki/my_little/certs/www.example.com.csr"
24     Created Certificate for "www.example.com": /etc/pki/my_little/certs/www.example.com.crt"
25 CLI Example #2:
26 Creating a client request and its signed certificate
27 .. code-block:: bash
28     Created Private Key: "/etc/pki/my_little/certs//DBReplica_No.1.key."
29     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.csr."
30     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
31 CLI Example #3:
32 Creating both a server and client req + cert for the same CN
33 .. code-block:: bash
34         cert_type=client
35     Created Private Key: "/etc/pki/my_little/certs/MasterDBReplica_No.2.key."
36     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/MasterDBReplica_No.2.csr."
37     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
38         cert_type=server
39     Certificate "MasterDBReplica_No.2" already exists
40     (doh!)
41         cert_type=server type_ext=True
42     Created Private Key: "/etc/pki/my_little/certs/DBReplica_No.1_client.key."
43     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1_client.csr."
44     Certificate "MasterDBReplica_No.2" already exists
45     (DOH!)
46         cert_type=server type_ext=True
47     Created Certificate for "MasterDBReplica_No.2": "/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt"
48 CLI Example #4:
49 Create a server req + cert with non-CN filename for the cert
50 .. code-block:: bash
51         cert_type=server type_ext=True
52     Created Private Key: "/etc/pki/my_little/certs/www.anothersometh.ing_server.key."
53     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/www.anothersometh.ing_server.csr."
54         cert_type=server cert_filename="something_completely_different"
55     Created Certificate for "www.anothersometh.ing": /etc/pki/my_little/certs/something_completely_different.crt
56 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
57 import math
58 import os
59 import re
60 import time
61 from datetime import datetime
62 import salt.utils.data
63 import salt.utils.files
64 import salt.utils.stringutils
65 from salt.exceptions import CommandExecutionError
66 from salt.utils.versions import LooseVersion as _LooseVersion
67 HAS_SSL =</b></font> False
68 X509_EXT_ENABLED = True
69 try:
70     import OpenSSL
71     HAS_SSL = True
72     OpenSSL_version = _LooseVersion(OpenSSL.__dict__.get("__version__", "0.0"))
73 except ImportError:
74     pass
75 log = logging.getLogger(__name__)
76 two_digit_year_fmt = "%y%m%d%H%M%SZ"
77 four_digit_year_fmt = "%Y%m%d%H%M%SZ"
78 def __virtual__():
79     global X509_EXT_ENABLED
80     if HAS_SSL and OpenSSL_version &gt;= _LooseVersion("0.10"):
81         if OpenSSL_version &lt; _LooseVersion("0.14"):
82             X509_EXT_ENABLED = False
83             log.debug(
84                 "You should upgrade pyOpenSSL to at least 0.14.1 to "
85                 "enable the use of X509 extensions in the tls module"
86             )
87         elif OpenSSL_version &lt;= _LooseVersion("0.15"):
88             log.debug(
89                 "You should upgrade pyOpenSSL to at least 0.15.1 to "
90                 "enable the full use of X509 extensions in the tls module"
91             )
92         return True
93     else:
94         X509_EXT_ENABLED = False
95         return (
96             False,
97             "PyOpenSSL version 0.10 or later must be installed "
98             "before this module can be used.",
99         )
100 def _microtime():
101     val1, val2 = math.modf(time.time())
102     val2 = int(val2)
103     return "{:f}{}".format(val1, val2)
104 def cert_base_path(cacert_path=None):
105     if not cacert_path:
106         cacert_path = __context__.get(
107             "ca.contextual_cert_base_path",
108             __salt__["config.option"]("ca.contextual_cert_base_path"),
109         )
110     if not cacert_path:
111         cacert_path = __context__.get(
112             "ca.cert_base_path", __salt__["config.option"]("ca.cert_base_path")
113         )
114     return cacert_path
115 def _cert_base_path(cacert_path=None):
116     return cert_base_path(cacert_path)
117 def set_ca_path(cacert_path):
118     if cacert_path:
119         __context__["ca.contextual_cert_base_path"] = cacert_path
120     return cert_base_path()
121 def _new_serial(ca_name):
122     hashnum = int(
123         binascii.hexlify(
124             b"_".join(
125                 (
126                     salt.utils.stringutils.to_bytes(_microtime()),
127                     os.urandom(5),
128                 )
129             )
130         ),
131         16,
132     )
133     log.debug("Hashnum: %s", hashnum)
134     cachedir = __opts__["cachedir"]
135     log.debug("cachedir: %s", cachedir)
136     serial_file = "{}/{}.serial".format(cachedir, ca_name)
137     if not os.path.exists(cachedir):
138         os.makedirs(cachedir)
139     if not os.path.exists(serial_file):
140         mode = "w"
141     else:
142         mode = "a+"
143     with salt.utils.files.fopen(serial_file, mode) as ofile:
144         ofile.write(str(hashnum))
145     return hashnum
146 def _four_digit_year_to_two_digit(datetimeObj):
147     return datetimeObj.strftime(two_digit_year_fmt)
148 def _get_basic_info(ca_name, cert, ca_dir=None):
149     if ca_dir is None:
150         ca_dir = "{}/{}".format(_cert_base_path(), ca_name)
151     index_file = "{}/index.txt".format(ca_dir)
152     cert = _read_cert(cert)
153     expire_date = _four_digit_year_to_two_digit(_get_expiration_date(cert))
154     serial_number = format(cert.get_serial_number(), "X")
155     subject = "/"
156     subject += "/".join(
157         ["{}={}".format(x, y) for x, y in cert.get_subject().get_components()]
158     )
159     subject += "\n"
160     return (index_file, expire_date, serial_number, subject)
161 def _write_cert_to_database(ca_name, cert, cacert_path=None, status="V"):
162     set_ca_path(cacert_path)
163     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
164     index_file, expire_date, serial_number, subject = _get_basic_info(
165         ca_name, cert, ca_dir
166     )
167     index_data = "{}\t{}\t\t{}\tunknown\t{}".format(
168         status, expire_date, serial_number, subject
169     )
170     with salt.utils.files.fopen(index_file, "a+") as ofile:
171         ofile.write(salt.utils.stringutils.to_str(index_data))
172 def maybe_fix_ssl_version(ca_name, cacert_path=None, ca_filename=None):
173     set_ca_path(cacert_path)
174     if not ca_filename:
175         ca_filename = "{}_ca_cert".format(ca_name)
176     certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
177     ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
178     with salt.utils.files.fopen(certp) as fic:
179         cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, fic.read())
180         if cert.get_version() == 3:
181             log.info("Regenerating wrong x509 version for certificate %s", certp)
182             with salt.utils.files.fopen(ca_keyp) as fic2:
183                 try:
184                     key = OpenSSL.crypto.load_privatekey(
185                         OpenSSL.crypto.FILETYPE_PEM, fic2.read()
186                     )
187                     bits = key.bits()
188                 except Exception:  # pylint: disable=broad-except
189                     bits = 2048
190                 try:
191                     days = (
192                         datetime.strptime(cert.get_notAfter(), "%Y%m%d%H%M%SZ")
193                         - datetime.utcnow()
194                     ).days
195                 except (ValueError, TypeError):
196                     days = 365
197                 subj = cert.get_subject()
198                 create_ca(
199                     ca_name,
200                     bits=bits,
201                     days=days,
202                     CN=subj.CN,
203                     C=subj.C,
204                     ST=subj.ST,
205                     L=subj.L,
206                     O=subj.O,
207                     OU=subj.OU,
208                     emailAddress=subj.emailAddress,
209                     fixmode=True,
210                 )
211 def ca_exists(ca_name, cacert_path=None, ca_filename=None):
212     set_ca_path(cacert_path)
213     if not ca_filename:
214         ca_filename = "{}_ca_cert".format(ca_name)
215     certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
216     if os.path.exists(certp):
217         maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
218         return True
219     return False
220 def _ca_exists(ca_name, cacert_path=None):
221     return ca_exists(ca_name, cacert_path)
222 def get_ca(ca_name, as_text=False, cacert_path=None):
223     set_ca_path(cacert_path)
224     certp = "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
225     if not os.path.exists(certp):
226         raise ValueError("Certificate does not exist for {}".format(ca_name))
227     else:
228         if as_text:
229             with salt.utils.files.fopen(certp) as fic:
230                 certp = salt.utils.stringutils.to_unicode(fic.read())
231     return certp
232 def get_ca_signed_cert(
233     ca_name, CN="localhost", as_text=False, cacert_path=None, cert_filename=None
234 ):
235     set_ca_path(cacert_path)
236     if not cert_filename:
237         cert_filename = CN
238     certp = "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, cert_filename)
239     if not os.path.exists(certp):
240         raise ValueError("Certificate does not exists for {}".format(CN))
241     else:
242         if as_text:
243             with salt.utils.files.fopen(certp) as fic:
244                 certp = salt.utils.stringutils.to_unicode(fic.read())
245     return certp
246 def get_ca_signed_key(
247     ca_name, CN="localhost", as_text=False, cacert_path=None, key_filename=None
248 ):
249     set_ca_path(cacert_path)
250     if not key_filename:
251         key_filename = CN
252     keyp = "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, key_filename)
253     if not os.path.exists(keyp):
254         raise ValueError("Certificate does not exists for {}".format(CN))
255     else:
256         if as_text:
257             with salt.utils.files.fopen(keyp) as fic:
258                 keyp = salt.utils.stringutils.to_unicode(fic.read())
259     return keyp
260 def _read_cert(cert):
261     if isinstance(cert, str):
262         try:
263             with salt.utils.files.fopen(cert) as rfh:
264                 return OpenSSL.crypto.load_certificate(
265                     OpenSSL.crypto.FILETYPE_PEM, rfh.read()
266                 )
267         except Exception:  # pylint: disable=broad-except
268             log.exception("Failed to read cert from path %s", cert)
269             return None
270     else:
271         if not hasattr(cert, "get_notAfter"):
272             log.error("%s is not a valid cert path/object", cert)
273             return None
274         else:
275             return cert
276 def validate(cert, ca_name, crl_file):
277     store = OpenSSL.crypto.X509Store()
278     cert_obj = _read_cert(cert)
279     if cert_obj is None:
280         raise CommandExecutionError(
281             "Failed to read cert from {}, see log for details".format(cert)
282         )
283     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
284     ca_cert = _read_cert("{}/{}_ca_cert.crt".format(ca_dir, ca_name))
285     store.add_cert(ca_cert)
286     X509StoreFlags = OpenSSL.crypto.X509StoreFlags
287     store.set_flags(X509StoreFlags.CRL_CHECK | X509StoreFlags.CRL_CHECK_ALL)
288     if crl_file is None:
289         crl = OpenSSL.crypto.CRL()
290     else:
291         with salt.utils.files.fopen(crl_file) as fhr:
292             crl = OpenSSL.crypto.load_crl(OpenSSL.crypto.FILETYPE_PEM, fhr.read())
293     store.add_crl(crl)
294     context = OpenSSL.crypto.X509StoreContext(store, cert_obj)
295     ret = {}
296     try:
297         context.verify_certificate()
298         ret["valid"] = True
299     except OpenSSL.crypto.X509StoreContextError as e:
300         ret["error"] = str(e)
301         ret["error_cert"] = e.certificate
302         ret["valid"] = False
303     return ret
304 def _get_expiration_date(cert):
305     cert_obj = _read_cert(cert)
306     if cert_obj is None:
307         raise CommandExecutionError(
308             "Failed to read cert from {}, see log for details".format(cert)
309         )
310     return datetime.strptime(
311         salt.utils.stringutils.to_str(cert_obj.get_notAfter()), four_digit_year_fmt
312     )
313 def get_expiration_date(cert, date_format="%Y-%m-%d"):
314     return _get_expiration_date(cert).strftime(date_format)
315 def _check_onlyif_unless(onlyif, unless):
316     ret = None
317     retcode = __salt__["cmd.retcode"]
318     if onlyif is not None:
319         if not isinstance(onlyif, str):
320             if not onlyif:
321                 ret = {"comment": "onlyif condition is false", "result": True}
322         elif isinstance(onlyif, str):
323             if retcode(onlyif) != 0:
324                 ret = {"comment": "onlyif condition is false", "result": True}
325                 log.debug("onlyif condition is false")
326     if unless is not None:
327         if not isinstance(unless, str):
328             if unless:
329                 ret = {"comment": "unless condition is true", "result": True}
330         elif isinstance(unless, str):
331             if retcode(unless) == 0:
332                 ret = {"comment": "unless condition is true", "result": True}
333                 log.debug("unless condition is true")
334     return ret
335 def create_ca(
336     ca_name,
337     bits=2048,
338     days=365,
339     CN="localhost",
340     C="US",
341     ST="Utah",
342     L="Salt Lake City",
343     O="SaltStack",
344     OU=None,
345     emailAddress=None,
346     fixmode=False,
347     cacert_path=None,
348     ca_filename=None,
349     digest="sha256",
350     onlyif=None,
351     unless=None,
352     replace=False,
353 ):
354     status = _check_onlyif_unless(onlyif, unless)
355     if status is not None:
356         return None
357     set_ca_path(cacert_path)
358     if not ca_filename:
359         ca_filename = "{}_ca_cert".format(ca_name)
360     certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
361     ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
362     if not replace and not fixmode and ca_exists(ca_name, ca_filename=ca_filename):
363         return 'Certificate for CA named "{}" already exists'.format(ca_name)
364     if fixmode and not os.path.exists(certp):
365         raise ValueError("{} does not exists, can't fix".format(certp))
366     if not os.path.exists("{}/{}".format(cert_base_path(), ca_name)):
367         os.makedirs("{}/{}".format(cert_base_path(), ca_name))
368     key = None
369     if os.path.exists(ca_keyp):
370         with salt.utils.files.fopen(ca_keyp) as fic2:
371             try:
372                 key = OpenSSL.crypto.load_privatekey(
373                     OpenSSL.crypto.FILETYPE_PEM, fic2.read()
374                 )
375             except OpenSSL.crypto.Error as err:
376                 log.warning(
377                     "Error loading existing private key %s, generating a new key: %s",
378                     ca_keyp,
379                     err,
380                 )
381                 bck = "{}.unloadable.{}".format(
382                     ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S")
383                 )
384                 log.info("Saving unloadable CA ssl key in %s", bck)
385                 os.rename(ca_keyp, bck)
386     if not key:
387         key = OpenSSL.crypto.PKey()
388         key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
389     ca = OpenSSL.crypto.X509()
390     ca.set_version(2)
391     ca.set_serial_number(_new_serial(ca_name))
392     ca.get_subject().C = C
393     ca.get_subject().ST = ST
394     ca.get_subject().L = L
395     ca.get_subject().O = O
396     if OU:
397         ca.get_subject().OU = OU
398     ca.get_subject().CN = CN
399     if emailAddress:
400         ca.get_subject().emailAddress = emailAddress
401     ca.gmtime_adj_notBefore(0)
402     ca.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
403     ca.set_issuer(ca.get_subject())
404     ca.set_pubkey(key)
405     if X509_EXT_ENABLED:
406         ca.add_extensions(
407             [
408                 OpenSSL.crypto.X509Extension(
409                     b"basicConstraints", True, b"CA:TRUE, pathlen:0"
410                 ),
411 <a name="0"></a>                OpenSSL.crypto.X509Extension(
412                     b"keyUsage", True, b"keyCertSign, cRLSign"
413                 ),
414                 OpenSSL<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.crypto.X509Extension(
415                     b"subjectKeyIdentifier", False, b"hash", subject=ca
416                 ),
417             ]
418         )
419         ca.add_extensions(
420             [
421                 OpenSSL.crypto.X509Extension(
422                     b"authorityKeyIdentifier",
423                     False,
424                     b"issuer:always,keyid:always",
425                     issuer=</b></font>ca,
426                 )
427             ]
428         )
429     ca.sign(key, salt.utils.stringutils.to_str(digest))
430     keycontent = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
431     write_key = True
432     if os.path.exists(ca_keyp):
433         bck = "{}.{}".format(ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S"))
434         with salt.utils.files.fopen(ca_keyp) as fic:
435             old_key = salt.utils.stringutils.to_unicode(fic.read()).strip()
436             if old_key.strip() == keycontent.strip():
437                 write_key = False
438             else:
439                 log.info("Saving old CA ssl key in %s", bck)
440                 fp = os.open(bck, os.O_CREAT | os.O_RDWR, 0o600)
441                 with salt.utils.files.fopen(fp, "w") as bckf:
442                     bckf.write(old_key)
443     if write_key:
444         fp = os.open(ca_keyp, os.O_CREAT | os.O_RDWR, 0o600)
445         with salt.utils.files.fopen(fp, "wb") as ca_key:
446             ca_key.write(salt.utils.stringutils.to_bytes(keycontent))
447     with salt.utils.files.fopen(certp, "wb") as ca_crt:
448         ca_crt.write(
449             salt.utils.stringutils.to_bytes(
450                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, ca)
451             )
452         )
453     _write_cert_to_database(ca_name, ca)
454     ret = 'Created Private Key: "{}/{}/{}.key." '.format(
455         cert_base_path(), ca_name, ca_filename
456     )
457     ret += 'Created CA "{0}": "{1}/{0}/{2}.crt."'.format(
458         ca_name, cert_base_path(), ca_filename
459     )
460     return ret
461 def get_extensions(cert_type):
462     assert X509_EXT_ENABLED, (
463         "X509 extensions are not supported in "
464         "pyOpenSSL prior to version 0.15.1. Your "
465         "version: {}".format(OpenSSL_version)
466     )
467     ext = {}
468     if cert_type == "":
469         log.error(
470             "cert_type set to empty in tls_ca.get_extensions(); "
471             "defaulting to ``server``"
472         )
473         cert_type = "server"
474     try:
475         ext["common"] = __salt__["pillar.get"]("tls.extensions:common", False)
476     except NameError as err:
477         log.debug(err)
478     if not ext["common"] or ext["common"] == "":
479         ext["common"] = {
480             "csr": {"basicConstraints": "CA:FALSE"},
481             "cert": {
482                 "authorityKeyIdentifier": "keyid,issuer:always",
483                 "subjectKeyIdentifier": "hash",
484             },
485         }
486     try:
487         ext["server"] = __salt__["pillar.get"]("tls.extensions:server", False)
488     except NameError as err:
489         log.debug(err)
490     if not ext["server"] or ext["server"] == "":
491         ext["server"] = {
492             "csr": {
493                 "extendedKeyUsage": "serverAuth",
494                 "keyUsage": "digitalSignature, keyEncipherment",
495             },
496             "cert": {},
497         }
498     try:
499         ext["client"] = __salt__["pillar.get"]("tls.extensions:client", False)
500     except NameError as err:
501         log.debug(err)
502     if not ext["client"] or ext["client"] == "":
503         ext["client"] = {
504             "csr": {
505                 "extendedKeyUsage": "clientAuth",
506                 "keyUsage": "nonRepudiation, digitalSignature, keyEncipherment",
507             },
508             "cert": {},
509         }
510     if cert_type not in ext:
511         try:
512             ext[cert_type] = __salt__["pillar.get"](
513                 "tls.extensions:{}".format(cert_type)
514             )
515         except NameError as e:
516             log.debug(
517                 "pillar, tls:extensions:%s not available or "
518                 "not operating in a salt context\n%s",
519                 cert_type,
520                 e,
521             )
522     retval = ext["common"]
523     for Use in retval:
524         retval[Use].update(ext[cert_type][Use])
525     return retval
526 def create_csr(
527     ca_name,
528     bits=2048,
529     CN="localhost",
530     C="US",
531     ST="Utah",
532     L="Salt Lake City",
533     O="SaltStack",
534     OU=None,
535     emailAddress=None,
536     subjectAltName=None,
537     cacert_path=None,
538     ca_filename=None,
539     csr_path=None,
540     csr_filename=None,
541     digest="sha256",
542     type_ext=False,
543     cert_type="server",
544     replace=False,
545 ):
546     set_ca_path(cacert_path)
547     if not ca_filename:
548         ca_filename = "{}_ca_cert".format(ca_name)
549     if not ca_exists(ca_name, ca_filename=ca_filename):
550         return 'Certificate for CA named "{}" does not exist, please create it first.'.format(
551             ca_name
552         )
553     if not csr_path:
554         csr_path = "{}/{}/certs/".format(cert_base_path(), ca_name)
555     if not os.path.exists(csr_path):
556         os.makedirs(csr_path)
557     CN_ext = "_{}".format(cert_type) if type_ext else ""
558     if not csr_filename:
559         csr_filename = "{}{}".format(CN, CN_ext)
560     csr_f = "{}/{}.csr".format(csr_path, csr_filename)
561     if not replace and os.path.exists(csr_f):
562         return 'Certificate Request "{}" already exists'.format(csr_f)
563     key = OpenSSL.crypto.PKey()
564     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
565     req = OpenSSL.crypto.X509Req()
566     req.get_subject().C = C
567     req.get_subject().ST = ST
568     req.get_subject().L = L
569     req.get_subject().O = O
570     if OU:
571         req.get_subject().OU = OU
572     req.get_subject().CN = CN
573     if emailAddress:
574         req.get_subject().emailAddress = emailAddress
575     try:
576         extensions = get_extensions(cert_type)["csr"]
577         extension_adds = []
578         for ext, value in extensions.items():
579             if isinstance(value, str):
580                 value = salt.utils.stringutils.to_bytes(value)
581             extension_adds.append(
582                 OpenSSL.crypto.X509Extension(
583                     salt.utils.stringutils.to_bytes(ext), False, value
584                 )
585             )
586     except AssertionError as err:
587         log.error(err)
588         extensions = []
589     if subjectAltName:
590         if X509_EXT_ENABLED:
591             if isinstance(subjectAltName, str):
592                 subjectAltName = [subjectAltName]
593             extension_adds.append(
594                 OpenSSL.crypto.X509Extension(
595                     b"subjectAltName",
596                     False,
597                     b", ".join(salt.utils.data.encode(subjectAltName)),
598                 )
599             )
600         else:
601             raise ValueError(
602                 "subjectAltName cannot be set as X509 "
603                 "extensions are not supported in pyOpenSSL "
604                 "prior to version 0.15.1. Your "
605                 "version: {}.".format(OpenSSL_version)
606             )
607     if X509_EXT_ENABLED:
608         req.add_extensions(extension_adds)
609     req.set_pubkey(key)
610     req.sign(key, salt.utils.stringutils.to_str(digest))
611     priv_keyp = "{}/{}.key".format(csr_path, csr_filename)
612     fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
613     with salt.utils.files.fopen(fp, "wb+") as priv_key:
614         priv_key.write(
615             salt.utils.stringutils.to_bytes(
616                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
617             )
618         )
619     with salt.utils.files.fopen(csr_f, "wb+") as csr:
620         csr.write(
621             salt.utils.stringutils.to_bytes(
622                 OpenSSL.crypto.dump_certificate_request(
623                     OpenSSL.crypto.FILETYPE_PEM, req
624                 )
625             )
626         )
627     ret = 'Created Private Key: "{}{}.key." '.format(csr_path, csr_filename)
628     ret += 'Created CSR for "{}": "{}{}.csr."'.format(CN, csr_path, csr_filename)
629     return ret
630 def create_self_signed_cert(
631     tls_dir="tls",
632     bits=2048,
633     days=365,
634     CN="localhost",
635     C="US",
636     ST="Utah",
637     L="Salt Lake City",
638     O="SaltStack",
639     OU=None,
640     emailAddress=None,
641     cacert_path=None,
642     cert_filename=None,
643     digest="sha256",
644     replace=False,
645 ):
646     set_ca_path(cacert_path)
647     if not os.path.exists("{}/{}/certs/".format(cert_base_path(), tls_dir)):
648         os.makedirs("{}/{}/certs/".format(cert_base_path(), tls_dir))
649     if not cert_filename:
650         cert_filename = CN
651     if not replace and os.path.exists(
652         "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
653     ):
654         return 'Certificate "{}" already exists'.format(cert_filename)
655     key = OpenSSL.crypto.PKey()
656     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
657     cert = OpenSSL.crypto.X509()
658     cert.set_version(2)
659     cert.gmtime_adj_notBefore(0)
660     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
661     cert.get_subject().C = C
662     cert.get_subject().ST = ST
663     cert.get_subject().L = L
664     cert.get_subject().O = O
665     if OU:
666         cert.get_subject().OU = OU
667     cert.get_subject().CN = CN
668     if emailAddress:
669         cert.get_subject().emailAddress = emailAddress
670     cert.set_serial_number(_new_serial(tls_dir))
671     cert.set_issuer(cert.get_subject())
672     cert.set_pubkey(key)
673     cert.sign(key, salt.utils.stringutils.to_str(digest))
674     priv_key_path = "{}/{}/certs/{}.key".format(
675         cert_base_path(), tls_dir, cert_filename
676     )
677     fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
678     with salt.utils.files.fopen(fp, "wb+") as priv_key:
679         priv_key.write(
680             salt.utils.stringutils.to_bytes(
681                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
682             )
683         )
684     crt_path = "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
685     with salt.utils.files.fopen(crt_path, "wb+") as crt:
686         crt.write(
687             salt.utils.stringutils.to_bytes(
688                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
689             )
690         )
691     _write_cert_to_database(tls_dir, cert)
692     ret = 'Created Private Key: "{}/{}/certs/{}.key." '.format(
693         cert_base_path(), tls_dir, cert_filename
694     )
695     ret += 'Created Certificate: "{}/{}/certs/{}.crt."'.format(
696         cert_base_path(), tls_dir, cert_filename
697     )
698     return ret
699 def create_ca_signed_cert(
700     ca_name,
701     CN,
702     days=365,
703     cacert_path=None,
704     ca_filename=None,
705     cert_path=None,
706     cert_filename=None,
707     digest="sha256",
708     cert_type=None,
709     type_ext=False,
710     replace=False,
711 ):
712     ret = {}
713     set_ca_path(cacert_path)
714     if not ca_filename:
715         ca_filename = "{}_ca_cert".format(ca_name)
716     if not cert_path:
717         cert_path = "{}/{}/certs".format(cert_base_path(), ca_name)
718     if type_ext:
719         if not cert_type:
720             log.error(
721                 "type_ext = True but cert_type is unset. Certificate not written."
722             )
723             return ret
724         elif cert_type:
725             CN_ext = "_{}".format(cert_type)
726     else:
727         CN_ext = ""
728     csr_filename = "{}{}".format(CN, CN_ext)
729     if not cert_filename:
730         cert_filename = "{}{}".format(CN, CN_ext)
731     if not replace and os.path.exists(
732         os.path.join(
733             os.path.sep.join(
734                 "{}/{}/certs/{}.crt".format(
735                     cert_base_path(), ca_name, cert_filename
736                 ).split("/")
737             )
738         )
739     ):
740         return 'Certificate "{}" already exists'.format(cert_filename)
741     try:
742         maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
743         with salt.utils.files.fopen(
744             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
745         ) as fhr:
746             ca_cert = OpenSSL.crypto.load_certificate(
747                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
748             )
749         with salt.utils.files.fopen(
750             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
751         ) as fhr:
752             ca_key = OpenSSL.crypto.load_privatekey(
753                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
754             )
755     except OSError:
756         ret["retcode"] = 1
757         ret["comment"] = 'There is no CA named "{}"'.format(ca_name)
758         return ret
759     try:
760         csr_path = "{}/{}.csr".format(cert_path, csr_filename)
761         with salt.utils.files.fopen(csr_path) as fhr:
762             req = OpenSSL.crypto.load_certificate_request(
763                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
764             )
765     except OSError:
766         ret["retcode"] = 1
767         ret["comment"] = 'There is no CSR that matches the CN "{}"'.format(
768             cert_filename
769         )
770         return ret
771     exts = []
772     try:
773         exts.extend(req.get_extensions())
774     except AttributeError:
775         try:
776             log.info(
777                 "req.get_extensions() not supported in pyOpenSSL versions "
778                 "prior to 0.15. Processing extensions internally. "
779                 "Your version: %s",
780                 OpenSSL_version,
781             )
782             native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
783             for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
784                 ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
785                 ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
786                     native_exts_obj, i
787                 )
788                 exts.append(ext)
789         except Exception:  # pylint: disable=broad-except
790             log.error(
791                 "X509 extensions are unsupported in pyOpenSSL "
792                 "versions prior to 0.14. Upgrade required to "
793                 "use extensions. Current version: %s",
794                 OpenSSL_version,
795             )
796     cert = OpenSSL.crypto.X509()
797     cert.set_version(2)
798     cert.set_subject(req.get_subject())
799     cert.gmtime_adj_notBefore(0)
800     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
801     cert.set_serial_number(_new_serial(ca_name))
802     cert.set_issuer(ca_cert.get_subject())
803     cert.set_pubkey(req.get_pubkey())
804     cert.add_extensions(exts)
805     cert.sign(ca_key, salt.utils.stringutils.to_str(digest))
806     cert_full_path = "{}/{}.crt".format(cert_path, cert_filename)
807     with salt.utils.files.fopen(cert_full_path, "wb+") as crt:
808         crt.write(
809             salt.utils.stringutils.to_bytes(
810                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
811             )
812         )
813     _write_cert_to_database(ca_name, cert)
814     return 'Created Certificate for "{}": "{}/{}.crt"'.format(
815         CN, cert_path, cert_filename
816     )
817 def create_pkcs12(ca_name, CN, passphrase="", cacert_path=None, replace=False):
818     set_ca_path(cacert_path)
819     if not replace and os.path.exists(
820         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN)
821     ):
822         return 'Certificate "{}" already exists'.format(CN)
823     try:
824         with salt.utils.files.fopen(
825             "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
826         ) as fhr:
827             ca_cert = OpenSSL.crypto.load_certificate(
828                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
829             )
830     except OSError:
831         return 'There is no CA named "{}"'.format(ca_name)
832     try:
833         with salt.utils.files.fopen(
834             "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, CN)
835         ) as fhr:
836             cert = OpenSSL.crypto.load_certificate(
837                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
838             )
839         with salt.utils.files.fopen(
840             "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, CN)
841         ) as fhr:
842             key = OpenSSL.crypto.load_privatekey(
843                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
844             )
845     except OSError:
846         return 'There is no certificate that matches the CN "{}"'.format(CN)
847     pkcs12 = OpenSSL.crypto.PKCS12()
848     pkcs12.set_certificate(cert)
849     pkcs12.set_ca_certificates([ca_cert])
850     pkcs12.set_privatekey(key)
851     with salt.utils.files.fopen(
852         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN), "wb"
853     ) as ofile:
854         ofile.write(
855             pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
856         )
857     return 'Created PKCS#12 Certificate for "{0}": "{1}/{2}/certs/{0}.p12"'.format(
858         CN,
859         cert_base_path(),
860         ca_name,
861     )
862 def cert_info(cert, digest="sha256"):
863     date_fmt = "%Y%m%d%H%M%SZ"
864     if "-----BEGIN" not in cert:
865         with salt.utils.files.fopen(cert) as cert_file:
866             cert = cert_file.read()
867     cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
868     issuer = {}
869     for key, value in cert.get_issuer().get_components():
870         if isinstance(key, bytes):
871             key = salt.utils.stringutils.to_unicode(key)
872         if isinstance(value, bytes):
873             value = salt.utils.stringutils.to_unicode(value)
874         issuer[key] = value
875     subject = {}
876     for key, value in cert.get_subject().get_components():
877         if isinstance(key, bytes):
878             key = salt.utils.stringutils.to_unicode(key)
879         if isinstance(value, bytes):
880             value = salt.utils.stringutils.to_unicode(value)
881         subject[key] = value
882 <a name="1"></a>
883     ret = {
884         "fingerprint": salt.utils.stringutils.to_unicode(
885             cert<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.digest(salt.utils.stringutils.to_str(digest))
886         ),
887         "subject": subject,
888         "issuer": issuer,
889         "serial_number": cert.get_serial_number(),
890         "not_before": calendar.timegm(
891             time.strptime(</b></font>
892                 str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
893             )
894         ),
895         "not_after": calendar.timegm(
896             time.strptime(
897                 cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
898             )
899         ),
900     }
901     if hasattr(cert, "get_extension_count"):
902         ret["extensions"] = {}
903         for i in range(cert.get_extension_count()):
904             try:
905                 ext = cert.get_extension(i)
906                 key = salt.utils.stringutils.to_unicode(ext.get_short_name())
907                 ret["extensions"][key] = str(ext).strip()
908             except AttributeError:
909                 continue
910     if "subjectAltName" in ret.get("extensions", {}):
911         valid_entries = ("DNS", "IP Address")
912         valid_names = set()
913         for name in str(ret["extensions"]["subjectAltName"]).split(", "):
914             entry, name = name.split(":", 1)
915             if entry not in valid_entries:
916                 log.error(
917                     "Cert %s has an entry (%s) which does not start with %s",
918                     ret["subject"],
919                     name,
920                     "/".join(valid_entries),
921                 )
922             else:
923                 valid_names.add(name)
924         ret["subject_alt_names"] = list(valid_names)
925     if hasattr(cert, "get_signature_algorithm"):
926         try:
927             value = cert.get_signature_algorithm()
928             if isinstance(value, bytes):
929                 value = salt.utils.stringutils.to_unicode(value)
930             ret["signature_algorithm"] = value
931         except AttributeError:
932             pass
933     return ret
934 def create_empty_crl(
935     ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest="sha256"
936 ):
937     set_ca_path(cacert_path)
938     if not ca_filename:
939         ca_filename = "{}_ca_cert".format(ca_name)
940     if not crl_file:
941         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
942     if os.path.exists("{}".format(crl_file)):
943         return 'CRL "{}" already exists'.format(crl_file)
944     try:
945         with salt.utils.files.fopen(
946             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
947         ) as fp_:
948             ca_cert = OpenSSL.crypto.load_certificate(
949                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
950             )
951         with salt.utils.files.fopen(
952             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
953         ) as fp_:
954             ca_key = OpenSSL.crypto.load_privatekey(
955                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
956             )
957     except OSError:
958         return 'There is no CA named "{}"'.format(ca_name)
959     crl = OpenSSL.crypto.CRL()
960     crl_text = crl.export(
961         ca_cert,
962         ca_key,
963         digest=salt.utils.stringutils.to_bytes(digest),
964     )
965     with salt.utils.files.fopen(crl_file, "w") as f:
966         f.write(salt.utils.stringutils.to_str(crl_text))
967     return 'Created an empty CRL: "{}"'.format(crl_file)
968 def revoke_cert(
969     ca_name,
970     CN,
971     cacert_path=None,
972     ca_filename=None,
973     cert_path=None,
974     cert_filename=None,
975     crl_file=None,
976     digest="sha256",
977 ):
978     set_ca_path(cacert_path)
979     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
980     if ca_filename is None:
981         ca_filename = "{}_ca_cert".format(ca_name)
982     if cert_path is None:
983         cert_path = "{}/{}/certs".format(_cert_base_path(), ca_name)
984     if cert_filename is None:
985         cert_filename = "{}".format(CN)
986     try:
987         with salt.utils.files.fopen(
988             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
989         ) as fp_:
990             ca_cert = OpenSSL.crypto.load_certificate(
991                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
992             )
993         with salt.utils.files.fopen(
994             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
995         ) as fp_:
996             ca_key = OpenSSL.crypto.load_privatekey(
997                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
998             )
999     except OSError:
1000         return 'There is no CA named "{}"'.format(ca_name)
1001     client_cert = _read_cert("{}/{}.crt".format(cert_path, cert_filename))
1002     if client_cert is None:
1003         return 'There is no client certificate named "{}"'.format(CN)
1004     index_file, expire_date, serial_number, subject = _get_basic_info(
1005         ca_name, client_cert, ca_dir
1006     )
1007     index_serial_subject = "{}\tunknown\t{}".format(serial_number, subject)
1008     index_v_data = "V\t{}\t\t{}".format(expire_date, index_serial_subject)
1009     index_r_data_pattern = re.compile(
1010         r"R\t" + expire_date + r"\t\d{12}Z\t" + re.escape(index_serial_subject)
1011     )
1012     index_r_data = "R\t{}\t{}\t{}".format(
1013         expire_date,
1014         _four_digit_year_to_two_digit(datetime.utcnow()),
1015         index_serial_subject,
1016     )
1017     ret = {}
1018     with salt.utils.files.fopen(index_file) as fp_:
1019         for line in fp_:
1020             line = salt.utils.stringutils.to_unicode(line)
1021             if index_r_data_pattern.match(line):
1022                 revoke_date = line.split("\t")[2]
1023                 try:
1024                     datetime.strptime(revoke_date, two_digit_year_fmt)
1025                     return '"{}/{}.crt" was already revoked, serial number: {}'.format(
1026                         cert_path, cert_filename, serial_number
1027                     )
1028                 except ValueError:
1029                     ret["retcode"] = 1
1030                     ret[
1031                         "comment"
1032                     ] = "Revocation date '{}' does not matchformat '{}'".format(
1033                         revoke_date, two_digit_year_fmt
1034                     )
1035                     return ret
1036             elif index_serial_subject in line:
1037                 __salt__["file.replace"](
1038                     index_file, index_v_data, index_r_data, backup=False
1039                 )
1040                 break
1041     crl = OpenSSL.crypto.CRL()
1042     with salt.utils.files.fopen(index_file) as fp_:
1043         for line in fp_:
1044             line = salt.utils.stringutils.to_unicode(line)
1045             if line.startswith("R"):
1046                 fields = line.split("\t")
1047                 revoked = OpenSSL.crypto.Revoked()
1048                 revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
1049                 revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
1050                 revoked.set_rev_date(
1051                     salt.utils.stringutils.to_bytes(
1052                         revoke_date_2_digit.strftime(four_digit_year_fmt)
1053                     )
1054                 )
1055                 crl.add_revoked(revoked)
1056     crl_text = crl.export(
1057         ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
1058     )
1059     if crl_file is None:
1060         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
1061     if os.path.isdir(crl_file):
1062         ret["retcode"] = 1
1063         ret["comment"] = 'crl_file "{}" is an existing directory'.format(crl_file)
1064         return ret
1065     with salt.utils.files.fopen(crl_file, "w") as fp_:
1066         fp_.write(salt.utils.stringutils.to_str(crl_text))
1067     return 'Revoked Certificate: "{}/{}.crt", serial number: {}'.format(
1068         cert_path, cert_filename, serial_number
1069     )
1070 if __name__ == "__main__":
1071     create_csr(
1072         "koji",
1073         CN="test_system",
1074         C="US",
1075         ST="Utah",
1076         L="Centerville",
1077         O="SaltStack",
1078         OU=None,
1079         emailAddress="test_system@saltstack.org",
1080     )
1081     create_ca_signed_cert("koji", "test_system")
1082     create_pkcs12("koji", "test_system", passphrase="test")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
