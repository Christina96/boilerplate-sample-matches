<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for win_status.py & tls_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for win_status.py & tls_1.py
      </h3>
      <h1 align="center">
        2.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>win_status.py (5.863192%)<TH>tls_1.py (1.5964524%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match140657-0.html#0',2,'match140657-1.html#0',3)" NAME="0">(580-584)<TD><A HREF="javascript:ZweiFrames('match140657-0.html#0',2,'match140657-1.html#0',3)" NAME="0">(799-811)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match140657-0.html#1',2,'match140657-1.html#1',3)" NAME="1">(253-258)<TD><A HREF="javascript:ZweiFrames('match140657-0.html#1',2,'match140657-1.html#1',3)" NAME="1">(1685-1691)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match140657-0.html#2',2,'match140657-1.html#2',3)" NAME="2">(12-28)<TD><A HREF="javascript:ZweiFrames('match140657-0.html#2',2,'match140657-1.html#2',3)" NAME="2">(103-119)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Module for returning various status data about a minion.
These data can be useful for compiling into stats later,
or for problem solving if your minion is having problems.

.. versionadded:: 0.12.0

:depends:  - wmi
<A NAME="2"></A>&quot;&quot;&quot;


<FONT color="#980517"><A HREF="javascript:ZweiFrames('match140657-1.html#2',3,'match140657-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import ctypes
import datetime
import logging
import subprocess

import salt.utils.event
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.win_pdh

# These imports needed for namespaced functions
# pylint: disable=W0611
from salt.modules.status import ping_master, time_
from salt.utils.functools import namespaced_function as _namespaced_function
from salt.utils.network import host_to_ips as _host_to_ips

log =</B></FONT> logging.getLogger(__name__)


# pylint: enable=W0611

try:
    if salt.utils.platform.is_windows():
        import wmi
        import salt.utils.winapi

        HAS_WMI = True
    else:
        HAS_WMI = False
except ImportError:
    HAS_WMI = False

HAS_PSUTIL = False
if salt.utils.platform.is_windows():
    import psutil

    HAS_PSUTIL = True

__opts__ = {}
__virtualname__ = &quot;status&quot;


# Taken from https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/performance.htm
class SYSTEM_PERFORMANCE_INFORMATION(ctypes.Structure):
    _fields_ = [
        (&quot;IdleProcessTime&quot;, ctypes.c_int64),
        (&quot;IoReadTransferCount&quot;, ctypes.c_int64),
        (&quot;IoWriteTransferCount&quot;, ctypes.c_int64),
        (&quot;IoOtherTransferCount&quot;, ctypes.c_int64),
        (&quot;IoReadOperationCount&quot;, ctypes.c_ulong),
        (&quot;IoWriteOperationCount&quot;, ctypes.c_ulong),
        (&quot;IoOtherOperationCount&quot;, ctypes.c_ulong),
        (&quot;AvailablePages&quot;, ctypes.c_ulong),
        (&quot;CommittedPages&quot;, ctypes.c_ulong),
        (&quot;CommitLimit&quot;, ctypes.c_ulong),
        (&quot;PeakCommitment&quot;, ctypes.c_ulong),
        (&quot;PageFaultCount&quot;, ctypes.c_ulong),
        (&quot;CopyOnWriteCount&quot;, ctypes.c_ulong),
        (&quot;TransitionCount&quot;, ctypes.c_ulong),
        (&quot;CacheTransitionCount&quot;, ctypes.c_ulong),
        (&quot;DemandZeroCount&quot;, ctypes.c_ulong),
        (&quot;PageReadCount&quot;, ctypes.c_ulong),
        (&quot;PageReadIoCount&quot;, ctypes.c_ulong),
        (&quot;CacheReadCount&quot;, ctypes.c_ulong),  # Was c_ulong ** 2
        (&quot;CacheIoCount&quot;, ctypes.c_ulong),
        (&quot;DirtyPagesWriteCount&quot;, ctypes.c_ulong),
        (&quot;DirtyWriteIoCount&quot;, ctypes.c_ulong),
        (&quot;MappedPagesWriteCount&quot;, ctypes.c_ulong),
        (&quot;MappedWriteIoCount&quot;, ctypes.c_ulong),
        (&quot;PagedPoolPages&quot;, ctypes.c_ulong),
        (&quot;NonPagedPoolPages&quot;, ctypes.c_ulong),
        (&quot;PagedPoolAllocs&quot;, ctypes.c_ulong),
        (&quot;PagedPoolFrees&quot;, ctypes.c_ulong),
        (&quot;NonPagedPoolAllocs&quot;, ctypes.c_ulong),
        (&quot;NonPagedPoolFrees&quot;, ctypes.c_ulong),
        (&quot;FreeSystemPtes&quot;, ctypes.c_ulong),
        (&quot;ResidentSystemCodePage&quot;, ctypes.c_ulong),
        (&quot;TotalSystemDriverPages&quot;, ctypes.c_ulong),
        (&quot;TotalSystemCodePages&quot;, ctypes.c_ulong),
        (&quot;NonPagedPoolLookasideHits&quot;, ctypes.c_ulong),
        (&quot;PagedPoolLookasideHits&quot;, ctypes.c_ulong),
        (&quot;AvailablePagedPoolPages&quot;, ctypes.c_ulong),
        (&quot;ResidentSystemCachePage&quot;, ctypes.c_ulong),
        (&quot;ResidentPagedPoolPage&quot;, ctypes.c_ulong),
        (&quot;ResidentSystemDriverPage&quot;, ctypes.c_ulong),
        (&quot;CcFastReadNoWait&quot;, ctypes.c_ulong),
        (&quot;CcFastReadWait&quot;, ctypes.c_ulong),
        (&quot;CcFastReadResourceMiss&quot;, ctypes.c_ulong),
        (&quot;CcFastReadNotPossible&quot;, ctypes.c_ulong),
        (&quot;CcFastMdlReadNoWait&quot;, ctypes.c_ulong),
        (&quot;CcFastMdlReadWait&quot;, ctypes.c_ulong),
        (&quot;CcFastMdlReadResourceMiss&quot;, ctypes.c_ulong),
        (&quot;CcFastMdlReadNotPossible&quot;, ctypes.c_ulong),
        (&quot;CcMapDataNoWait&quot;, ctypes.c_ulong),
        (&quot;CcMapDataWait&quot;, ctypes.c_ulong),
        (&quot;CcMapDataNoWaitMiss&quot;, ctypes.c_ulong),
        (&quot;CcMapDataWaitMiss&quot;, ctypes.c_ulong),
        (&quot;CcPinMappedDataCount&quot;, ctypes.c_ulong),
        (&quot;CcPinReadNoWait&quot;, ctypes.c_ulong),
        (&quot;CcPinReadWait&quot;, ctypes.c_ulong),
        (&quot;CcPinReadNoWaitMiss&quot;, ctypes.c_ulong),
        (&quot;CcPinReadWaitMiss&quot;, ctypes.c_ulong),
        (&quot;CcCopyReadNoWait&quot;, ctypes.c_ulong),
        (&quot;CcCopyReadWait&quot;, ctypes.c_ulong),
        (&quot;CcCopyReadNoWaitMiss&quot;, ctypes.c_ulong),
        (&quot;CcCopyReadWaitMiss&quot;, ctypes.c_ulong),
        (&quot;CcMdlReadNoWait&quot;, ctypes.c_ulong),
        (&quot;CcMdlReadWait&quot;, ctypes.c_ulong),
        (&quot;CcMdlReadNoWaitMiss&quot;, ctypes.c_ulong),
        (&quot;CcMdlReadWaitMiss&quot;, ctypes.c_ulong),
        (&quot;CcReadAheadIos&quot;, ctypes.c_ulong),
        (&quot;CcLazyWriteIos&quot;, ctypes.c_ulong),
        (&quot;CcLazyWritePages&quot;, ctypes.c_ulong),
        (&quot;CcDataFlushes&quot;, ctypes.c_ulong),
        (&quot;CcDataPages&quot;, ctypes.c_ulong),
        (&quot;ContextSwitches&quot;, ctypes.c_ulong),
        (&quot;FirstLevelTbFills&quot;, ctypes.c_ulong),
        (&quot;SecondLevelTbFills&quot;, ctypes.c_ulong),
        (&quot;SystemCalls&quot;, ctypes.c_ulong),
        # Windows 8 and above
        (&quot;CcTotalDirtyPages&quot;, ctypes.c_ulonglong),
        (&quot;CcDirtyPagesThreshold&quot;, ctypes.c_ulonglong),
        (&quot;ResidentAvailablePages&quot;, ctypes.c_longlong),
        # Windows 10 and above
        (&quot;SharedCommittedPages&quot;, ctypes.c_ulonglong),
    ]


def __virtual__():
    &quot;&quot;&quot;
    Only works on Windows systems with WMI and WinAPI
    &quot;&quot;&quot;
    if not salt.utils.platform.is_windows():
        return False, &quot;win_status.py: Requires Windows&quot;

    if not HAS_WMI:
        return False, &quot;win_status.py: Requires WMI and WinAPI&quot;

    if not HAS_PSUTIL:
        return False, &quot;win_status.py: Requires psutil&quot;

    # Namespace modules from `status.py`
    global ping_master, time_
    ping_master = _namespaced_function(ping_master, globals())
    time_ = _namespaced_function(time_, globals())

    return __virtualname__


__func_alias__ = {&quot;time_&quot;: &quot;time&quot;}


def cpustats():
    &quot;&quot;&quot;
    Return information about the CPU.

    Returns
        dict: A dictionary containing information about the CPU stats

    CLI Example:

    .. code-block:: bash

        salt * status.cpustats
    &quot;&quot;&quot;
    # Tries to gather information similar to that returned by a Linux machine
    # Avoid using WMI as there's a lot of overhead

    # Time related info
    user, system, idle, interrupt, dpc = psutil.cpu_times()
    cpu = {&quot;user&quot;: user, &quot;system&quot;: system, &quot;idle&quot;: idle, &quot;irq&quot;: interrupt, &quot;dpc&quot;: dpc}
    # Count related info
    ctx_switches, interrupts, soft_interrupts, sys_calls = psutil.cpu_stats()
    intr = {&quot;irqs&quot;: {&quot;irqs&quot;: [], &quot;total&quot;: interrupts}}
    soft_irq = {&quot;softirqs&quot;: [], &quot;total&quot;: soft_interrupts}
    return {
        &quot;btime&quot;: psutil.boot_time(),
        &quot;cpu&quot;: cpu,
        &quot;ctxt&quot;: ctx_switches,
        &quot;intr&quot;: intr,
        &quot;processes&quot;: len(psutil.pids()),
        &quot;softirq&quot;: soft_irq,
        &quot;syscalls&quot;: sys_calls,
    }


def meminfo():
    &quot;&quot;&quot;
    Return information about physical and virtual memory on the system

    Returns:
        dict: A dictionary of information about memory on the system

    CLI Example:

    .. code-block:: bash

        salt * status.meminfo
    &quot;&quot;&quot;
    # Get physical memory
    vm_total, vm_available, vm_percent, vm_used, vm_free = psutil.virtual_memory()
    # Get swap memory
    swp_total, swp_used, swp_free, swp_percent, _, _ = psutil.swap_memory()

    def get_unit_value(memory):
        symbols = (&quot;K&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;, &quot;P&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;Y&quot;)
        prefix = {}
        for i, s in enumerate(symbols):
            prefix[s] = 1 &lt;&lt; (i + 1) * 10
        for s in reversed(symbols):
            if memory &gt;= prefix[s]:
                value = float(memory) / prefix[s]
                return {&quot;unit&quot;: s, &quot;value&quot;: value}
        return {&quot;unit&quot;: &quot;B&quot;, &quot;value&quot;: memory}

    return {
        &quot;VmallocTotal&quot;: get_unit_value(vm_total),
        &quot;VmallocUsed&quot;: get_unit_value(vm_used),
        &quot;VmallocFree&quot;: get_unit_value(vm_free),
        &quot;VmallocAvail&quot;: get_unit_value(vm_available),
        &quot;SwapTotal&quot;: get_unit_value(swp_total),
        &quot;SwapUsed&quot;: get_unit_value(swp_used),
        &quot;SwapFree&quot;: get_unit_value(swp_free),
    }


def vmstats():
    &quot;&quot;&quot;
    Return information about the virtual memory on the machine

    Returns:
        dict: A dictionary of virtual memory stats

    CLI Example:

    .. code-block:: bash

        salt * status.vmstats
<A NAME="1"></A>    &quot;&quot;&quot;
    # Setup the SPI Structure
    spi = SYSTEM_PERFORMANCE_INFORMATION()
    retlen = ctypes<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match140657-1.html#1',3,'match140657-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.c_ulong()

    # 2 means to query System Performance Information and return it in a
    # SYSTEM_PERFORMANCE_INFORMATION Structure
    ctypes.windll.ntdll.NtQuerySystemInformation(
        2, ctypes.byref(spi), ctypes.sizeof(spi), ctypes.byref(</B></FONT>retlen)
    )

    # Return each defined field in a dict
    ret = {}
    for field in spi._fields_:
        ret.update({field[0]: getattr(spi, field[0])})

    return ret


def loadavg():
    &quot;&quot;&quot;
    Returns counter information related to the load of the machine

    Returns:
        dict: A dictionary of counters

    CLI Example:

    .. code-block:: bash

        salt * status.loadavg
    &quot;&quot;&quot;
    # Counter List (obj, instance, counter)
    counter_list = [
        (&quot;Memory&quot;, None, &quot;Available Bytes&quot;),
        (&quot;Memory&quot;, None, &quot;Pages/sec&quot;),
        (&quot;Paging File&quot;, &quot;*&quot;, &quot;% Usage&quot;),
        (&quot;Processor&quot;, &quot;*&quot;, &quot;% Processor Time&quot;),
        (&quot;Processor&quot;, &quot;*&quot;, &quot;DPCs Queued/sec&quot;),
        (&quot;Processor&quot;, &quot;*&quot;, &quot;% Privileged Time&quot;),
        (&quot;Processor&quot;, &quot;*&quot;, &quot;% User Time&quot;),
        (&quot;Processor&quot;, &quot;*&quot;, &quot;% DPC Time&quot;),
        (&quot;Processor&quot;, &quot;*&quot;, &quot;% Interrupt Time&quot;),
        (&quot;Server&quot;, None, &quot;Work Item Shortages&quot;),
        (&quot;Server Work Queues&quot;, &quot;*&quot;, &quot;Queue Length&quot;),
        (&quot;System&quot;, None, &quot;Processor Queue Length&quot;),
        (&quot;System&quot;, None, &quot;Context Switches/sec&quot;),
    ]
    return salt.utils.win_pdh.get_counters(counter_list=counter_list)


def cpuload():
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Return the processor load as a percentage

    CLI Example:

    .. code-block:: bash

       salt '*' status.cpuload
    &quot;&quot;&quot;
    return psutil.cpu_percent()


def diskusage(human_readable=False, path=None):
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Return the disk usage for this minion

    human_readable : False
        If ``True``, usage will be in KB/MB/GB etc.

    CLI Example:

    .. code-block:: bash

        salt '*' status.diskusage path=c:/salt
    &quot;&quot;&quot;
    if not path:
        path = &quot;c:/&quot;

    disk_stats = psutil.disk_usage(path)

    total_val = disk_stats.total
    used_val = disk_stats.used
    free_val = disk_stats.free
    percent = disk_stats.percent

    if human_readable:
        total_val = _byte_calc(total_val)
        used_val = _byte_calc(used_val)
        free_val = _byte_calc(free_val)

    return {&quot;total&quot;: total_val, &quot;used&quot;: used_val, &quot;free&quot;: free_val, &quot;percent&quot;: percent}


def procs(count=False):
    &quot;&quot;&quot;
    Return the process data

    count : False
        If ``True``, this function will simply return the number of processes.

        .. versionadded:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' status.procs
        salt '*' status.procs count
    &quot;&quot;&quot;
    with salt.utils.winapi.Com():
        wmi_obj = wmi.WMI()
        processes = wmi_obj.win32_process()

    # this short circuit's the function to get a short simple proc count.
    if count:
        return len(processes)

    # a propper run of the function, creating a nonsensically long out put.
    process_info = {}
    for proc in processes:
        process_info[proc.ProcessId] = _get_process_info(proc)

    return process_info


def saltmem(human_readable=False):
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Returns the amount of memory that salt is using

    human_readable : False
        return the value in a nicely formatted number

    CLI Example:

    .. code-block:: bash

        salt '*' status.saltmem
        salt '*' status.saltmem human_readable=True
    &quot;&quot;&quot;
    # psutil.Process defaults to current process (`os.getpid()`)
    p = psutil.Process()

    # Use oneshot to get a snapshot
    with p.oneshot():
        mem = p.memory_info().rss

    if human_readable:
        return _byte_calc(mem)

    return mem


def uptime(human_readable=False):
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Return the system uptime for the machine

    Args:

        human_readable (bool):
            Return uptime in human readable format if ``True``, otherwise
            return seconds. Default is ``False``

            .. note::
                Human readable format is ``days, hours:min:sec``. Days will only
                be displayed if more than 0

    Returns:
        str:
            The uptime in seconds or human readable format depending on the
            value of ``human_readable``

    CLI Example:

    .. code-block:: bash

        salt '*' status.uptime
        salt '*' status.uptime human_readable=True
    &quot;&quot;&quot;
    # Get startup time
    startup_time = datetime.datetime.fromtimestamp(psutil.boot_time())

    # Subtract startup time from current time to get the uptime of the system
    uptime = datetime.datetime.now() - startup_time

    return str(uptime) if human_readable else uptime.total_seconds()


def _get_process_info(proc):
    &quot;&quot;&quot;
    Return  process information
    &quot;&quot;&quot;
    cmd = salt.utils.stringutils.to_unicode(proc.CommandLine or &quot;&quot;)
    name = salt.utils.stringutils.to_unicode(proc.Name)
    info = dict(cmd=cmd, name=name, **_get_process_owner(proc))
    return info


def _get_process_owner(process):
    owner = {}
    domain, error_code, user = None, None, None
    try:
        domain, error_code, user = process.GetOwner()
        owner[&quot;user&quot;] = salt.utils.stringutils.to_unicode(user)
        owner[&quot;user_domain&quot;] = salt.utils.stringutils.to_unicode(domain)
    except Exception as exc:  # pylint: disable=broad-except
        pass
    if not error_code and all((user, domain)):
        owner[&quot;user&quot;] = salt.utils.stringutils.to_unicode(user)
        owner[&quot;user_domain&quot;] = salt.utils.stringutils.to_unicode(domain)
    elif process.ProcessId in [0, 4] and error_code == 2:
        # Access Denied for System Idle Process and System
        owner[&quot;user&quot;] = &quot;SYSTEM&quot;
        owner[&quot;user_domain&quot;] = &quot;NT AUTHORITY&quot;
    else:
        log.warning(
            &quot;Error getting owner of process; PID='%s'; Error: %s&quot;,
            process.ProcessId,
            error_code,
        )
    return owner


def _byte_calc(val):
    if val &lt; 1024:
        tstr = str(val) + &quot;B&quot;
    elif val &lt; 1038336:
        tstr = str(val / 1024) + &quot;KB&quot;
    elif val &lt; 1073741824:
        tstr = str(val / 1038336) + &quot;MB&quot;
    elif val &lt; 1099511627776:
        tstr = str(val / 1073741824) + &quot;GB&quot;
    else:
        tstr = str(val / 1099511627776) + &quot;TB&quot;
    return tstr


def master(master=None, connected=True):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0

    Fire an event if the minion gets disconnected from its master. This
    function is meant to be run via a scheduled job from the minion. If
    master_ip is an FQDN/Hostname, is must be resolvable to a valid IPv4
    address.

    CLI Example:

    .. code-block:: bash

        salt '*' status.master
    &quot;&quot;&quot;

    def _win_remotes_on(port):
        &quot;&quot;&quot;
        Windows specific helper function.
        Returns set of ipv4 host addresses of remote established connections
        on local or remote tcp port.

        Parses output of shell 'netstat' to get connections

        PS C:&gt; netstat -n -p TCP

        Active Connections

          Proto  Local Address          Foreign Address        State
          TCP    10.1.1.26:3389         10.1.1.1:4505          ESTABLISHED
          TCP    10.1.1.26:56862        10.1.1.10:49155        TIME_WAIT
          TCP    10.1.1.26:56868        169.254.169.254:80     CLOSE_WAIT
          TCP    127.0.0.1:49197        127.0.0.1:49198        ESTABLISHED
          TCP    127.0.0.1:49198        127.0.0.1:49197        ESTABLISHED
        &quot;&quot;&quot;
        remotes = set()
        try:
            data = subprocess.check_output(
                [&quot;netstat&quot;, &quot;-n&quot;, &quot;-p&quot;, &quot;TCP&quot;]
            )  # pylint: disable=minimum-python-version
        except subprocess.CalledProcessError:
            log.error(&quot;Failed netstat&quot;)
            raise

        lines = salt.utils.stringutils.to_unicode(data).split(&quot;\n&quot;)
        for line in lines:
            if &quot;ESTABLISHED&quot; not in line:
                continue
            chunks = line.split()
            remote_host, remote_port = chunks[2].rsplit(&quot;:&quot;, 1)
            if int(remote_port) != port:
                continue
            remotes.add(remote_host)
        return remotes

    # the default publishing port
    port = 4505
    master_ips = None

    if master:
        master_ips = _host_to_ips(master)

    if not master_ips:
        return

    if __salt__[&quot;config.get&quot;](&quot;publish_port&quot;) != &quot;&quot;:
        port = int(__salt__[&quot;config.get&quot;](&quot;publish_port&quot;))

    master_connection_status = False
    connected_ips = _win_remotes_on(port)

    # Get connection status for master
    for master_ip in master_ips:
        if master_ip in connected_ips:
            master_connection_status = True
            break

    # Connection to master is not as expected
    if master_connection_status is not connected:
        with salt.utils.event.get_event(
            &quot;minion&quot;, opts=__opts__, listen=False
<A NAME="0"></A>        ) as event_bus:
            if master_connection_status:
                event_bus.fire_event(
                    {&quot;master&quot;: master}, salt<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match140657-1.html#0',3,'match140657-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.minion.master_event(type=&quot;connected&quot;)
                )
            else:
                event_bus.fire_event(
                    {&quot;master&quot;: master}, salt.minion.master_event(type=</B></FONT>&quot;disconnected&quot;)
                )

    return master_connection_status
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
r&quot;&quot;&quot;
A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
or use Self-Signed certificates.

:depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
    extension support)

:configuration: Add the following values in /etc/salt/minion for the CA module
    to function properly:

    .. code-block:: yaml

        ca.cert_base_path: '/etc/pki'


CLI Example #1:
Creating a CA, a server request and its signed certificate:

.. code-block:: bash

    # salt-call tls.create_ca my_little \
    days=5 \
    CN='My Little CA' \
    C=US \
    ST=Utah \
    L=Salt Lake City \
    O=Saltstack \
    emailAddress=pleasedontemail@example.com

    Created Private Key: &quot;/etc/pki/my_little/my_little_ca_cert.key&quot;
    Created CA &quot;my_little_ca&quot;: &quot;/etc/pki/my_little_ca/my_little_ca_cert.crt&quot;

    # salt-call tls.create_csr my_little CN=www.example.com
    Created Private Key: &quot;/etc/pki/my_little/certs/www.example.com.key
    Created CSR for &quot;www.example.com&quot;: &quot;/etc/pki/my_little/certs/www.example.com.csr&quot;

    # salt-call tls.create_ca_signed_cert my_little CN=www.example.com
    Created Certificate for &quot;www.example.com&quot;: /etc/pki/my_little/certs/www.example.com.crt&quot;

CLI Example #2:
Creating a client request and its signed certificate

.. code-block:: bash

    # salt-call tls.create_csr my_little CN=DBReplica_No.1 cert_type=client
    Created Private Key: &quot;/etc/pki/my_little/certs//DBReplica_No.1.key.&quot;
    Created CSR for &quot;DBReplica_No.1&quot;: &quot;/etc/pki/my_little/certs/DBReplica_No.1.csr.&quot;

    # salt-call tls.create_ca_signed_cert my_little CN=DBReplica_No.1
    Created Certificate for &quot;DBReplica_No.1&quot;: &quot;/etc/pki/my_little/certs/DBReplica_No.1.crt&quot;

CLI Example #3:
Creating both a server and client req + cert for the same CN

.. code-block:: bash

    # salt-call tls.create_csr my_little CN=MasterDBReplica_No.2  \
        cert_type=client
    Created Private Key: &quot;/etc/pki/my_little/certs/MasterDBReplica_No.2.key.&quot;
    Created CSR for &quot;DBReplica_No.1&quot;: &quot;/etc/pki/my_little/certs/MasterDBReplica_No.2.csr.&quot;

    # salt-call tls.create_ca_signed_cert my_little CN=MasterDBReplica_No.2
    Created Certificate for &quot;DBReplica_No.1&quot;: &quot;/etc/pki/my_little/certs/DBReplica_No.1.crt&quot;

    # salt-call tls.create_csr my_little CN=MasterDBReplica_No.2 \
        cert_type=server
    Certificate &quot;MasterDBReplica_No.2&quot; already exists

    (doh!)

    # salt-call tls.create_csr my_little CN=MasterDBReplica_No.2 \
        cert_type=server type_ext=True
    Created Private Key: &quot;/etc/pki/my_little/certs/DBReplica_No.1_client.key.&quot;
    Created CSR for &quot;DBReplica_No.1&quot;: &quot;/etc/pki/my_little/certs/DBReplica_No.1_client.csr.&quot;

    # salt-call tls.create_ca_signed_cert my_little CN=MasterDBReplica_No.2
    Certificate &quot;MasterDBReplica_No.2&quot; already exists

    (DOH!)

    # salt-call tls.create_ca_signed_cert my_little CN=MasterDBReplica_No.2 \
        cert_type=server type_ext=True
    Created Certificate for &quot;MasterDBReplica_No.2&quot;: &quot;/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt&quot;


CLI Example #4:
Create a server req + cert with non-CN filename for the cert

.. code-block:: bash

    # salt-call tls.create_csr my_little CN=www.anothersometh.ing \
        cert_type=server type_ext=True
    Created Private Key: &quot;/etc/pki/my_little/certs/www.anothersometh.ing_server.key.&quot;
    Created CSR for &quot;DBReplica_No.1&quot;: &quot;/etc/pki/my_little/certs/www.anothersometh.ing_server.csr.&quot;

    # salt-call tls_create_ca_signed_cert my_little CN=www.anothersometh.ing \
        cert_type=server cert_filename=&quot;something_completely_different&quot;
    Created Certificate for &quot;www.anothersometh.ing&quot;: /etc/pki/my_little/certs/something_completely_different.crt
&quot;&quot;&quot;
<A NAME="2"></A>
import binascii
import calendar
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match140657-0.html#2',2,'match140657-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import logging
import math
import os
import re
import time
from datetime import datetime

import salt.utils.data
import salt.utils.files
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError
from salt.utils.versions import LooseVersion as _LooseVersion

# pylint: disable=C0103


HAS_SSL =</B></FONT> False
X509_EXT_ENABLED = True
try:
    import OpenSSL

    HAS_SSL = True
    OpenSSL_version = _LooseVersion(OpenSSL.__dict__.get(&quot;__version__&quot;, &quot;0.0&quot;))
except ImportError:
    pass


log = logging.getLogger(__name__)

two_digit_year_fmt = &quot;%y%m%d%H%M%SZ&quot;
four_digit_year_fmt = &quot;%Y%m%d%H%M%SZ&quot;


def __virtual__():
    &quot;&quot;&quot;
    Only load this module if the ca config options are set
    &quot;&quot;&quot;
    global X509_EXT_ENABLED
    if HAS_SSL and OpenSSL_version &gt;= _LooseVersion(&quot;0.10&quot;):
        if OpenSSL_version &lt; _LooseVersion(&quot;0.14&quot;):
            X509_EXT_ENABLED = False
            log.debug(
                &quot;You should upgrade pyOpenSSL to at least 0.14.1 to &quot;
                &quot;enable the use of X509 extensions in the tls module&quot;
            )
        elif OpenSSL_version &lt;= _LooseVersion(&quot;0.15&quot;):
            log.debug(
                &quot;You should upgrade pyOpenSSL to at least 0.15.1 to &quot;
                &quot;enable the full use of X509 extensions in the tls module&quot;
            )
        # NOTE: Not having configured a cert path should not prevent this
        # module from loading as it provides methods to configure the path.
        return True
    else:
        X509_EXT_ENABLED = False
        return (
            False,
            &quot;PyOpenSSL version 0.10 or later must be installed &quot;
            &quot;before this module can be used.&quot;,
        )


def _microtime():
    &quot;&quot;&quot;
    Return a Unix timestamp as a string of digits
    :return:
    &quot;&quot;&quot;
    val1, val2 = math.modf(time.time())
    val2 = int(val2)
    return &quot;{:f}{}&quot;.format(val1, val2)


def cert_base_path(cacert_path=None):
    &quot;&quot;&quot;
    Return the base path for certs from CLI or from options

    cacert_path
        absolute path to ca certificates root directory

    CLI Example:

    .. code-block:: bash

        salt '*' tls.cert_base_path
    &quot;&quot;&quot;
    if not cacert_path:
        cacert_path = __context__.get(
            &quot;ca.contextual_cert_base_path&quot;,
            __salt__[&quot;config.option&quot;](&quot;ca.contextual_cert_base_path&quot;),
        )
    if not cacert_path:
        cacert_path = __context__.get(
            &quot;ca.cert_base_path&quot;, __salt__[&quot;config.option&quot;](&quot;ca.cert_base_path&quot;)
        )
    return cacert_path


def _cert_base_path(cacert_path=None):
    &quot;&quot;&quot;
    Retrocompatible wrapper
    &quot;&quot;&quot;
    return cert_base_path(cacert_path)


def set_ca_path(cacert_path):
    &quot;&quot;&quot;
    If wanted, store the aforementioned cacert_path in context
    to be used as the basepath for further operations

    CLI Example:

    .. code-block:: bash

        salt '*' tls.set_ca_path /etc/certs
    &quot;&quot;&quot;
    if cacert_path:
        __context__[&quot;ca.contextual_cert_base_path&quot;] = cacert_path
    return cert_base_path()


def _new_serial(ca_name):
    &quot;&quot;&quot;
    Return a serial number in hex using os.urandom() and a Unix timestamp
    in microseconds.

    ca_name
        name of the CA
    CN
        common name in the request
    &quot;&quot;&quot;
    hashnum = int(
        binascii.hexlify(
            b&quot;_&quot;.join(
                (
                    salt.utils.stringutils.to_bytes(_microtime()),
                    os.urandom(5),
                )
            )
        ),
        16,
    )
    log.debug(&quot;Hashnum: %s&quot;, hashnum)

    # record the hash somewhere
    cachedir = __opts__[&quot;cachedir&quot;]
    log.debug(&quot;cachedir: %s&quot;, cachedir)
    serial_file = &quot;{}/{}.serial&quot;.format(cachedir, ca_name)
    if not os.path.exists(cachedir):
        os.makedirs(cachedir)
    if not os.path.exists(serial_file):
        mode = &quot;w&quot;
    else:
        mode = &quot;a+&quot;
    with salt.utils.files.fopen(serial_file, mode) as ofile:
        ofile.write(str(hashnum))

    return hashnum


def _four_digit_year_to_two_digit(datetimeObj):
    return datetimeObj.strftime(two_digit_year_fmt)


def _get_basic_info(ca_name, cert, ca_dir=None):
    &quot;&quot;&quot;
    Get basic info to write out to the index.txt
    &quot;&quot;&quot;
    if ca_dir is None:
        ca_dir = &quot;{}/{}&quot;.format(_cert_base_path(), ca_name)

    index_file = &quot;{}/index.txt&quot;.format(ca_dir)

    cert = _read_cert(cert)
    expire_date = _four_digit_year_to_two_digit(_get_expiration_date(cert))
    serial_number = format(cert.get_serial_number(), &quot;X&quot;)

    # gotta prepend a /
    subject = &quot;/&quot;

    # then we can add the rest of the subject
    subject += &quot;/&quot;.join(
        [&quot;{}={}&quot;.format(x, y) for x, y in cert.get_subject().get_components()]
    )
    subject += &quot;\n&quot;

    return (index_file, expire_date, serial_number, subject)


def _write_cert_to_database(ca_name, cert, cacert_path=None, status=&quot;V&quot;):
    &quot;&quot;&quot;
    write out the index.txt database file in the appropriate directory to
    track certificates

    ca_name
        name of the CA
    cert
        certificate to be recorded
    &quot;&quot;&quot;
    set_ca_path(cacert_path)
    ca_dir = &quot;{}/{}&quot;.format(cert_base_path(), ca_name)
    index_file, expire_date, serial_number, subject = _get_basic_info(
        ca_name, cert, ca_dir
    )

    index_data = &quot;{}\t{}\t\t{}\tunknown\t{}&quot;.format(
        status, expire_date, serial_number, subject
    )

    with salt.utils.files.fopen(index_file, &quot;a+&quot;) as ofile:
        ofile.write(salt.utils.stringutils.to_str(index_data))


def maybe_fix_ssl_version(ca_name, cacert_path=None, ca_filename=None):
    &quot;&quot;&quot;
    Check that the X509 version is correct
    (was incorrectly set in previous salt versions).
    This will fix the version if needed.

    ca_name
        ca authority name
    cacert_path
        absolute path to ca certificates root directory
    ca_filename
        alternative filename for the CA

        .. versionadded:: 2015.5.3

    CLI Example:

    .. code-block:: bash

        salt '*' tls.maybe_fix_ssl_version test_ca /etc/certs
    &quot;&quot;&quot;
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = &quot;{}_ca_cert&quot;.format(ca_name)
    certp = &quot;{}/{}/{}.crt&quot;.format(cert_base_path(), ca_name, ca_filename)
    ca_keyp = &quot;{}/{}/{}.key&quot;.format(cert_base_path(), ca_name, ca_filename)
    with salt.utils.files.fopen(certp) as fic:
        cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, fic.read())
        if cert.get_version() == 3:
            log.info(&quot;Regenerating wrong x509 version for certificate %s&quot;, certp)
            with salt.utils.files.fopen(ca_keyp) as fic2:
                try:
                    # try to determine the key bits
                    key = OpenSSL.crypto.load_privatekey(
                        OpenSSL.crypto.FILETYPE_PEM, fic2.read()
                    )
                    bits = key.bits()
                except Exception:  # pylint: disable=broad-except
                    bits = 2048
                try:
                    days = (
                        datetime.strptime(cert.get_notAfter(), &quot;%Y%m%d%H%M%SZ&quot;)
                        - datetime.utcnow()
                    ).days
                except (ValueError, TypeError):
                    days = 365
                subj = cert.get_subject()
                create_ca(
                    ca_name,
                    bits=bits,
                    days=days,
                    CN=subj.CN,
                    C=subj.C,
                    ST=subj.ST,
                    L=subj.L,
                    O=subj.O,
                    OU=subj.OU,
                    emailAddress=subj.emailAddress,
                    fixmode=True,
                )


def ca_exists(ca_name, cacert_path=None, ca_filename=None):
    &quot;&quot;&quot;
    Verify whether a Certificate Authority (CA) already exists

    ca_name
        name of the CA
    cacert_path
        absolute path to ca certificates root directory
    ca_filename
        alternative filename for the CA

        .. versionadded:: 2015.5.3

    CLI Example:

    .. code-block:: bash

        salt '*' tls.ca_exists test_ca /etc/certs
    &quot;&quot;&quot;
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = &quot;{}_ca_cert&quot;.format(ca_name)
    certp = &quot;{}/{}/{}.crt&quot;.format(cert_base_path(), ca_name, ca_filename)
    if os.path.exists(certp):
        maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
        return True
    return False


def _ca_exists(ca_name, cacert_path=None):
    &quot;&quot;&quot;Retrocompatible wrapper&quot;&quot;&quot;
    return ca_exists(ca_name, cacert_path)


def get_ca(ca_name, as_text=False, cacert_path=None):
    &quot;&quot;&quot;
    Get the certificate path or content

    ca_name
        name of the CA
    as_text
        if true, return the certificate content instead of the path
    cacert_path
        absolute path to ca certificates root directory

    CLI Example:

    .. code-block:: bash

        salt '*' tls.get_ca test_ca as_text=False cacert_path=/etc/certs
    &quot;&quot;&quot;
    set_ca_path(cacert_path)
    certp = &quot;{0}/{1}/{1}_ca_cert.crt&quot;.format(cert_base_path(), ca_name)
    if not os.path.exists(certp):
        raise ValueError(&quot;Certificate does not exist for {}&quot;.format(ca_name))
    else:
        if as_text:
            with salt.utils.files.fopen(certp) as fic:
                certp = salt.utils.stringutils.to_unicode(fic.read())
    return certp


def get_ca_signed_cert(
    ca_name, CN=&quot;localhost&quot;, as_text=False, cacert_path=None, cert_filename=None
):
    &quot;&quot;&quot;
    Get the certificate path or content

    ca_name
        name of the CA
    CN
        common name of the certificate
    as_text
        if true, return the certificate content instead of the path
    cacert_path
        absolute path to certificates root directory
    cert_filename
        alternative filename for the certificate, useful when using special characters in the CN

        .. versionadded:: 2015.5.3

    CLI Example:

    .. code-block:: bash

        salt '*' tls.get_ca_signed_cert test_ca CN=localhost as_text=False cacert_path=/etc/certs
    &quot;&quot;&quot;
    set_ca_path(cacert_path)
    if not cert_filename:
        cert_filename = CN

    certp = &quot;{}/{}/certs/{}.crt&quot;.format(cert_base_path(), ca_name, cert_filename)
    if not os.path.exists(certp):
        raise ValueError(&quot;Certificate does not exists for {}&quot;.format(CN))
    else:
        if as_text:
            with salt.utils.files.fopen(certp) as fic:
                certp = salt.utils.stringutils.to_unicode(fic.read())
    return certp


def get_ca_signed_key(
    ca_name, CN=&quot;localhost&quot;, as_text=False, cacert_path=None, key_filename=None
):
    &quot;&quot;&quot;
    Get the certificate path or content

    ca_name
        name of the CA
    CN
        common name of the certificate
    as_text
        if true, return the certificate content instead of the path
    cacert_path
        absolute path to certificates root directory
    key_filename
        alternative filename for the key, useful when using special characters

        .. versionadded:: 2015.5.3

        in the CN

    CLI Example:

    .. code-block:: bash

        salt '*' tls.get_ca_signed_key \
                test_ca CN=localhost \
                as_text=False \
                cacert_path=/etc/certs
    &quot;&quot;&quot;
    set_ca_path(cacert_path)
    if not key_filename:
        key_filename = CN

    keyp = &quot;{}/{}/certs/{}.key&quot;.format(cert_base_path(), ca_name, key_filename)
    if not os.path.exists(keyp):
        raise ValueError(&quot;Certificate does not exists for {}&quot;.format(CN))
    else:
        if as_text:
            with salt.utils.files.fopen(keyp) as fic:
                keyp = salt.utils.stringutils.to_unicode(fic.read())
    return keyp


def _read_cert(cert):
    if isinstance(cert, str):
        try:
            with salt.utils.files.fopen(cert) as rfh:
                return OpenSSL.crypto.load_certificate(
                    OpenSSL.crypto.FILETYPE_PEM, rfh.read()
                )
        except Exception:  # pylint: disable=broad-except
            log.exception(&quot;Failed to read cert from path %s&quot;, cert)
            return None
    else:
        if not hasattr(cert, &quot;get_notAfter&quot;):
            log.error(&quot;%s is not a valid cert path/object&quot;, cert)
            return None
        else:
            return cert


def validate(cert, ca_name, crl_file):
    &quot;&quot;&quot;
    .. versionadded:: 3000

    Validate a certificate against a given CA/CRL.

    cert
        path to the certifiate PEM file or string

    ca_name
        name of the CA

    crl_file
        full path to the CRL file
    &quot;&quot;&quot;
    store = OpenSSL.crypto.X509Store()
    cert_obj = _read_cert(cert)
    if cert_obj is None:
        raise CommandExecutionError(
            &quot;Failed to read cert from {}, see log for details&quot;.format(cert)
        )
    ca_dir = &quot;{}/{}&quot;.format(cert_base_path(), ca_name)
    ca_cert = _read_cert(&quot;{}/{}_ca_cert.crt&quot;.format(ca_dir, ca_name))
    store.add_cert(ca_cert)
    # These flags tell OpenSSL to check the leaf as well as the
    # entire cert chain.
    X509StoreFlags = OpenSSL.crypto.X509StoreFlags
    store.set_flags(X509StoreFlags.CRL_CHECK | X509StoreFlags.CRL_CHECK_ALL)
    if crl_file is None:
        crl = OpenSSL.crypto.CRL()
    else:
        with salt.utils.files.fopen(crl_file) as fhr:
            crl = OpenSSL.crypto.load_crl(OpenSSL.crypto.FILETYPE_PEM, fhr.read())
    store.add_crl(crl)
    context = OpenSSL.crypto.X509StoreContext(store, cert_obj)
    ret = {}
    try:
        context.verify_certificate()
        ret[&quot;valid&quot;] = True
    except OpenSSL.crypto.X509StoreContextError as e:
        ret[&quot;error&quot;] = str(e)
        ret[&quot;error_cert&quot;] = e.certificate
        ret[&quot;valid&quot;] = False
    return ret


def _get_expiration_date(cert):
    &quot;&quot;&quot;
    Returns a datetime.datetime object
    &quot;&quot;&quot;
    cert_obj = _read_cert(cert)

    if cert_obj is None:
        raise CommandExecutionError(
            &quot;Failed to read cert from {}, see log for details&quot;.format(cert)
        )

    return datetime.strptime(
        salt.utils.stringutils.to_str(cert_obj.get_notAfter()), four_digit_year_fmt
    )


def get_expiration_date(cert, date_format=&quot;%Y-%m-%d&quot;):
    &quot;&quot;&quot;
    .. versionadded:: 2019.2.0

    Get a certificate's expiration date

    cert
        Full path to the certificate

    date_format
        By default this will return the expiration date in YYYY-MM-DD format,
        use this to specify a different strftime format string. Note that the
        expiration time will be in UTC.

    CLI Examples:

    .. code-block:: bash

        salt '*' tls.get_expiration_date /path/to/foo.crt
        salt '*' tls.get_expiration_date /path/to/foo.crt date_format='%d/%m/%Y'
    &quot;&quot;&quot;
    return _get_expiration_date(cert).strftime(date_format)


def _check_onlyif_unless(onlyif, unless):
    ret = None
    retcode = __salt__[&quot;cmd.retcode&quot;]
    if onlyif is not None:
        if not isinstance(onlyif, str):
            if not onlyif:
                ret = {&quot;comment&quot;: &quot;onlyif condition is false&quot;, &quot;result&quot;: True}
        elif isinstance(onlyif, str):
            if retcode(onlyif) != 0:
                ret = {&quot;comment&quot;: &quot;onlyif condition is false&quot;, &quot;result&quot;: True}
                log.debug(&quot;onlyif condition is false&quot;)
    if unless is not None:
        if not isinstance(unless, str):
            if unless:
                ret = {&quot;comment&quot;: &quot;unless condition is true&quot;, &quot;result&quot;: True}
        elif isinstance(unless, str):
            if retcode(unless) == 0:
                ret = {&quot;comment&quot;: &quot;unless condition is true&quot;, &quot;result&quot;: True}
                log.debug(&quot;unless condition is true&quot;)
    return ret


def create_ca(
    ca_name,
    bits=2048,
    days=365,
    CN=&quot;localhost&quot;,
    C=&quot;US&quot;,
    ST=&quot;Utah&quot;,
    L=&quot;Salt Lake City&quot;,
    O=&quot;SaltStack&quot;,
    OU=None,
    emailAddress=None,
    fixmode=False,
    cacert_path=None,
    ca_filename=None,
    digest=&quot;sha256&quot;,
    onlyif=None,
    unless=None,
    replace=False,
):
    &quot;&quot;&quot;
    Create a Certificate Authority (CA)

    ca_name
        name of the CA
    bits
        number of RSA key bits, default is 2048
    days
        number of days the CA will be valid, default is 365
    CN
        common name in the request, default is &quot;localhost&quot;
    C
        country, default is &quot;US&quot;
    ST
        state, default is &quot;Utah&quot;
    L
        locality, default is &quot;Centerville&quot;, the city where SaltStack originated
    O
        organization, default is &quot;SaltStack&quot;
    OU
        organizational unit, default is None
    emailAddress
        email address for the CA owner, default is None
    cacert_path
        absolute path to ca certificates root directory
    ca_filename
        alternative filename for the CA

        .. versionadded:: 2015.5.3

    digest
        The message digest algorithm. Must be a string describing a digest
        algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
        For example, &quot;md5&quot; or &quot;sha1&quot;. Default: 'sha256'
    replace
        Replace this certificate even if it exists

        .. versionadded:: 2015.5.1

    Writes out a CA certificate based upon defined config values. If the file
    already exists, the function just returns assuming the CA certificate
    already exists.

    If the following values were set::

        ca.cert_base_path='/etc/pki'
        ca_name='koji'

    the resulting CA, and corresponding key, would be written in the following
    location with appropriate permissions::

        /etc/pki/koji/koji_ca_cert.crt
        /etc/pki/koji/koji_ca_cert.key

    CLI Example:

    .. code-block:: bash

        salt '*' tls.create_ca test_ca
    &quot;&quot;&quot;
    status = _check_onlyif_unless(onlyif, unless)
    if status is not None:
        return None

    set_ca_path(cacert_path)

    if not ca_filename:
        ca_filename = &quot;{}_ca_cert&quot;.format(ca_name)

    certp = &quot;{}/{}/{}.crt&quot;.format(cert_base_path(), ca_name, ca_filename)
    ca_keyp = &quot;{}/{}/{}.key&quot;.format(cert_base_path(), ca_name, ca_filename)
    if not replace and not fixmode and ca_exists(ca_name, ca_filename=ca_filename):
        return 'Certificate for CA named &quot;{}&quot; already exists'.format(ca_name)

    if fixmode and not os.path.exists(certp):
        raise ValueError(&quot;{} does not exists, can't fix&quot;.format(certp))

    if not os.path.exists(&quot;{}/{}&quot;.format(cert_base_path(), ca_name)):
        os.makedirs(&quot;{}/{}&quot;.format(cert_base_path(), ca_name))

    # try to reuse existing ssl key
    key = None
    if os.path.exists(ca_keyp):
        with salt.utils.files.fopen(ca_keyp) as fic2:
            # try to determine the key bits
            try:
                key = OpenSSL.crypto.load_privatekey(
                    OpenSSL.crypto.FILETYPE_PEM, fic2.read()
                )
            except OpenSSL.crypto.Error as err:
                log.warning(
                    &quot;Error loading existing private key %s, generating a new key: %s&quot;,
                    ca_keyp,
                    err,
                )
                bck = &quot;{}.unloadable.{}&quot;.format(
                    ca_keyp, datetime.utcnow().strftime(&quot;%Y%m%d%H%M%S&quot;)
                )
                log.info(&quot;Saving unloadable CA ssl key in %s&quot;, bck)
                os.rename(ca_keyp, bck)

    if not key:
        key = OpenSSL.crypto.PKey()
        key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)

    ca = OpenSSL.crypto.X509()
    ca.set_version(2)
    ca.set_serial_number(_new_serial(ca_name))
    ca.get_subject().C = C
    ca.get_subject().ST = ST
    ca.get_subject().L = L
    ca.get_subject().O = O
    if OU:
        ca.get_subject().OU = OU
    ca.get_subject().CN = CN
    if emailAddress:
        ca.get_subject().emailAddress = emailAddress

    ca.gmtime_adj_notBefore(0)
    ca.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
    ca.set_issuer(ca.get_subject())
    ca.set_pubkey(key)

    if X509_EXT_ENABLED:
        ca.add_extensions(
            [
                OpenSSL.crypto.X509Extension(
                    b&quot;basicConstraints&quot;, True, b&quot;CA:TRUE, pathlen:0&quot;
                ),
<A NAME="0"></A>                OpenSSL.crypto.X509Extension(
                    b&quot;keyUsage&quot;, True, b&quot;keyCertSign, cRLSign&quot;
                ),
                OpenSSL<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match140657-0.html#0',2,'match140657-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.crypto.X509Extension(
                    b&quot;subjectKeyIdentifier&quot;, False, b&quot;hash&quot;, subject=ca
                ),
            ]
        )

        ca.add_extensions(
            [
                OpenSSL.crypto.X509Extension(
                    b&quot;authorityKeyIdentifier&quot;,
                    False,
                    b&quot;issuer:always,keyid:always&quot;,
                    issuer=</B></FONT>ca,
                )
            ]
        )
    ca.sign(key, salt.utils.stringutils.to_str(digest))

    # always backup existing keys in case
    keycontent = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
    write_key = True
    if os.path.exists(ca_keyp):
        bck = &quot;{}.{}&quot;.format(ca_keyp, datetime.utcnow().strftime(&quot;%Y%m%d%H%M%S&quot;))
        with salt.utils.files.fopen(ca_keyp) as fic:
            old_key = salt.utils.stringutils.to_unicode(fic.read()).strip()
            if old_key.strip() == keycontent.strip():
                write_key = False
            else:
                log.info(&quot;Saving old CA ssl key in %s&quot;, bck)
                fp = os.open(bck, os.O_CREAT | os.O_RDWR, 0o600)
                with salt.utils.files.fopen(fp, &quot;w&quot;) as bckf:
                    bckf.write(old_key)
    if write_key:
        fp = os.open(ca_keyp, os.O_CREAT | os.O_RDWR, 0o600)
        with salt.utils.files.fopen(fp, &quot;wb&quot;) as ca_key:
            ca_key.write(salt.utils.stringutils.to_bytes(keycontent))

    with salt.utils.files.fopen(certp, &quot;wb&quot;) as ca_crt:
        ca_crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, ca)
            )
        )

    _write_cert_to_database(ca_name, ca)

    ret = 'Created Private Key: &quot;{}/{}/{}.key.&quot; '.format(
        cert_base_path(), ca_name, ca_filename
    )
    ret += 'Created CA &quot;{0}&quot;: &quot;{1}/{0}/{2}.crt.&quot;'.format(
        ca_name, cert_base_path(), ca_filename
    )

    return ret


def get_extensions(cert_type):
    &quot;&quot;&quot;
    Fetch X509 and CSR extension definitions from tls:extensions:
    (common|server|client) or set them to standard defaults.

    .. versionadded:: 2015.8.0

    cert_type:
        The type of certificate such as ``server`` or ``client``.

    CLI Example:

    .. code-block:: bash

        salt '*' tls.get_extensions client

    &quot;&quot;&quot;

    assert X509_EXT_ENABLED, (
        &quot;X509 extensions are not supported in &quot;
        &quot;pyOpenSSL prior to version 0.15.1. Your &quot;
        &quot;version: {}&quot;.format(OpenSSL_version)
    )

    ext = {}
    if cert_type == &quot;&quot;:
        log.error(
            &quot;cert_type set to empty in tls_ca.get_extensions(); &quot;
            &quot;defaulting to ``server``&quot;
        )
        cert_type = &quot;server&quot;

    try:
        ext[&quot;common&quot;] = __salt__[&quot;pillar.get&quot;](&quot;tls.extensions:common&quot;, False)
    except NameError as err:
        log.debug(err)

    if not ext[&quot;common&quot;] or ext[&quot;common&quot;] == &quot;&quot;:
        ext[&quot;common&quot;] = {
            &quot;csr&quot;: {&quot;basicConstraints&quot;: &quot;CA:FALSE&quot;},
            &quot;cert&quot;: {
                &quot;authorityKeyIdentifier&quot;: &quot;keyid,issuer:always&quot;,
                &quot;subjectKeyIdentifier&quot;: &quot;hash&quot;,
            },
        }

    try:
        ext[&quot;server&quot;] = __salt__[&quot;pillar.get&quot;](&quot;tls.extensions:server&quot;, False)
    except NameError as err:
        log.debug(err)

    if not ext[&quot;server&quot;] or ext[&quot;server&quot;] == &quot;&quot;:
        ext[&quot;server&quot;] = {
            &quot;csr&quot;: {
                &quot;extendedKeyUsage&quot;: &quot;serverAuth&quot;,
                &quot;keyUsage&quot;: &quot;digitalSignature, keyEncipherment&quot;,
            },
            &quot;cert&quot;: {},
        }

    try:
        ext[&quot;client&quot;] = __salt__[&quot;pillar.get&quot;](&quot;tls.extensions:client&quot;, False)
    except NameError as err:
        log.debug(err)

    if not ext[&quot;client&quot;] or ext[&quot;client&quot;] == &quot;&quot;:
        ext[&quot;client&quot;] = {
            &quot;csr&quot;: {
                &quot;extendedKeyUsage&quot;: &quot;clientAuth&quot;,
                &quot;keyUsage&quot;: &quot;nonRepudiation, digitalSignature, keyEncipherment&quot;,
            },
            &quot;cert&quot;: {},
        }

    # possible user-defined profile or a typo
    if cert_type not in ext:
        try:
            ext[cert_type] = __salt__[&quot;pillar.get&quot;](
                &quot;tls.extensions:{}&quot;.format(cert_type)
            )
        except NameError as e:
            log.debug(
                &quot;pillar, tls:extensions:%s not available or &quot;
                &quot;not operating in a salt context\n%s&quot;,
                cert_type,
                e,
            )

    retval = ext[&quot;common&quot;]

    for Use in retval:
        retval[Use].update(ext[cert_type][Use])

    return retval


def create_csr(
    ca_name,
    bits=2048,
    CN=&quot;localhost&quot;,
    C=&quot;US&quot;,
    ST=&quot;Utah&quot;,
    L=&quot;Salt Lake City&quot;,
    O=&quot;SaltStack&quot;,
    OU=None,
    emailAddress=None,
    subjectAltName=None,
    cacert_path=None,
    ca_filename=None,
    csr_path=None,
    csr_filename=None,
    digest=&quot;sha256&quot;,
    type_ext=False,
    cert_type=&quot;server&quot;,
    replace=False,
):
    &quot;&quot;&quot;
    Create a Certificate Signing Request (CSR) for a
    particular Certificate Authority (CA)

    ca_name
        name of the CA
    bits
        number of RSA key bits, default is 2048
    CN
        common name in the request, default is &quot;localhost&quot;
    C
        country, default is &quot;US&quot;
    ST
        state, default is &quot;Utah&quot;
    L
        locality, default is &quot;Centerville&quot;, the city where SaltStack originated
    O
        organization, default is &quot;SaltStack&quot;
        NOTE: Must the same as CA certificate or an error will be raised
    OU
        organizational unit, default is None
    emailAddress
        email address for the request, default is None
    subjectAltName
        valid subjectAltNames in full form, e.g. to add DNS entry you would call
        this function with this value:

        examples: ['DNS:somednsname.com',
                'DNS:1.2.3.4',
                'IP:1.2.3.4',
                'IP:2001:4801:7821:77:be76:4eff:fe11:e51',
                'email:me@i.like.pie.com']

    .. note::
        some libraries do not properly query IP: prefixes, instead looking
        for the given req. source with a DNS: prefix. To be thorough, you
        may want to include both DNS: and IP: entries if you are using
        subjectAltNames for destinations for your TLS connections.
        e.g.:
        requests to https://1.2.3.4 will fail from python's
        requests library w/out the second entry in the above list

    .. versionadded:: 2015.8.0

    cert_type
        Specify the general certificate type. Can be either `server` or
        `client`. Indicates the set of common extensions added to the CSR.

        .. code-block:: cfg

            server: {
               'basicConstraints': 'CA:FALSE',
               'extendedKeyUsage': 'serverAuth',
               'keyUsage': 'digitalSignature, keyEncipherment'
            }

            client: {
               'basicConstraints': 'CA:FALSE',
               'extendedKeyUsage': 'clientAuth',
               'keyUsage': 'nonRepudiation, digitalSignature, keyEncipherment'
            }

    type_ext
        boolean.  Whether or not to extend the filename with CN_[cert_type]
        This can be useful if a server and client certificate are needed for
        the same CN. Defaults to False to avoid introducing an unexpected file
        naming pattern

        The files normally named some_subject_CN.csr and some_subject_CN.key
        will then be saved

    replace
        Replace this signing request even if it exists

        .. versionadded:: 2015.5.1

    Writes out a Certificate Signing Request (CSR) If the file already
    exists, the function just returns assuming the CSR already exists.

    If the following values were set::

        ca.cert_base_path='/etc/pki'
        ca_name='koji'
        CN='test.egavas.org'

    the resulting CSR, and corresponding key, would be written in the
    following location with appropriate permissions::

        /etc/pki/koji/certs/test.egavas.org.csr
        /etc/pki/koji/certs/test.egavas.org.key

    CLI Example:

    .. code-block:: bash

        salt '*' tls.create_csr test
    &quot;&quot;&quot;
    set_ca_path(cacert_path)

    if not ca_filename:
        ca_filename = &quot;{}_ca_cert&quot;.format(ca_name)

    if not ca_exists(ca_name, ca_filename=ca_filename):
        return 'Certificate for CA named &quot;{}&quot; does not exist, please create it first.'.format(
            ca_name
        )

    if not csr_path:
        csr_path = &quot;{}/{}/certs/&quot;.format(cert_base_path(), ca_name)

    if not os.path.exists(csr_path):
        os.makedirs(csr_path)

    CN_ext = &quot;_{}&quot;.format(cert_type) if type_ext else &quot;&quot;

    if not csr_filename:
        csr_filename = &quot;{}{}&quot;.format(CN, CN_ext)

    csr_f = &quot;{}/{}.csr&quot;.format(csr_path, csr_filename)

    if not replace and os.path.exists(csr_f):
        return 'Certificate Request &quot;{}&quot; already exists'.format(csr_f)

    key = OpenSSL.crypto.PKey()
    key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)

    req = OpenSSL.crypto.X509Req()

    req.get_subject().C = C
    req.get_subject().ST = ST
    req.get_subject().L = L
    req.get_subject().O = O
    if OU:
        req.get_subject().OU = OU
    req.get_subject().CN = CN
    if emailAddress:
        req.get_subject().emailAddress = emailAddress

    try:
        extensions = get_extensions(cert_type)[&quot;csr&quot;]

        extension_adds = []

        for ext, value in extensions.items():
            if isinstance(value, str):
                value = salt.utils.stringutils.to_bytes(value)
            extension_adds.append(
                OpenSSL.crypto.X509Extension(
                    salt.utils.stringutils.to_bytes(ext), False, value
                )
            )
    except AssertionError as err:
        log.error(err)
        extensions = []

    if subjectAltName:
        if X509_EXT_ENABLED:
            if isinstance(subjectAltName, str):
                subjectAltName = [subjectAltName]

            extension_adds.append(
                OpenSSL.crypto.X509Extension(
                    b&quot;subjectAltName&quot;,
                    False,
                    b&quot;, &quot;.join(salt.utils.data.encode(subjectAltName)),
                )
            )
        else:
            raise ValueError(
                &quot;subjectAltName cannot be set as X509 &quot;
                &quot;extensions are not supported in pyOpenSSL &quot;
                &quot;prior to version 0.15.1. Your &quot;
                &quot;version: {}.&quot;.format(OpenSSL_version)
            )

    if X509_EXT_ENABLED:
        req.add_extensions(extension_adds)

    req.set_pubkey(key)
    req.sign(key, salt.utils.stringutils.to_str(digest))

    # Write private key and request
    priv_keyp = &quot;{}/{}.key&quot;.format(csr_path, csr_filename)
    fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
    with salt.utils.files.fopen(fp, &quot;wb+&quot;) as priv_key:
        priv_key.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
            )
        )

    with salt.utils.files.fopen(csr_f, &quot;wb+&quot;) as csr:
        csr.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate_request(
                    OpenSSL.crypto.FILETYPE_PEM, req
                )
            )
        )

    ret = 'Created Private Key: &quot;{}{}.key.&quot; '.format(csr_path, csr_filename)
    ret += 'Created CSR for &quot;{}&quot;: &quot;{}{}.csr.&quot;'.format(CN, csr_path, csr_filename)

    return ret


def create_self_signed_cert(
    tls_dir=&quot;tls&quot;,
    bits=2048,
    days=365,
    CN=&quot;localhost&quot;,
    C=&quot;US&quot;,
    ST=&quot;Utah&quot;,
    L=&quot;Salt Lake City&quot;,
    O=&quot;SaltStack&quot;,
    OU=None,
    emailAddress=None,
    cacert_path=None,
    cert_filename=None,
    digest=&quot;sha256&quot;,
    replace=False,
):
    &quot;&quot;&quot;
    Create a Self-Signed Certificate (CERT)

    tls_dir
        location appended to the ca.cert_base_path, default is 'tls'
    bits
        number of RSA key bits, default is 2048
    CN
        common name in the request, default is &quot;localhost&quot;
    C
        country, default is &quot;US&quot;
    ST
        state, default is &quot;Utah&quot;
    L
        locality, default is &quot;Centerville&quot;, the city where SaltStack originated
    O
        organization, default is &quot;SaltStack&quot;
        NOTE: Must the same as CA certificate or an error will be raised
    OU
        organizational unit, default is None
    emailAddress
        email address for the request, default is None
    cacert_path
        absolute path to ca certificates root directory
    digest
        The message digest algorithm. Must be a string describing a digest
        algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
        For example, &quot;md5&quot; or &quot;sha1&quot;. Default: 'sha256'
    replace
        Replace this certificate even if it exists

        .. versionadded:: 2015.5.1

    Writes out a Self-Signed Certificate (CERT). If the file already
    exists, the function just returns.

    If the following values were set::

        ca.cert_base_path='/etc/pki'
        tls_dir='koji'
        CN='test.egavas.org'

    the resulting CERT, and corresponding key, would be written in the
    following location with appropriate permissions::

        /etc/pki/koji/certs/test.egavas.org.crt
        /etc/pki/koji/certs/test.egavas.org.key

    CLI Example:

    .. code-block:: bash

        salt '*' tls.create_self_signed_cert

    Passing options from the command line:

    .. code-block:: bash

        salt 'minion' tls.create_self_signed_cert CN='test.mysite.org'
    &quot;&quot;&quot;
    set_ca_path(cacert_path)

    if not os.path.exists(&quot;{}/{}/certs/&quot;.format(cert_base_path(), tls_dir)):
        os.makedirs(&quot;{}/{}/certs/&quot;.format(cert_base_path(), tls_dir))

    if not cert_filename:
        cert_filename = CN

    if not replace and os.path.exists(
        &quot;{}/{}/certs/{}.crt&quot;.format(cert_base_path(), tls_dir, cert_filename)
    ):
        return 'Certificate &quot;{}&quot; already exists'.format(cert_filename)

    key = OpenSSL.crypto.PKey()
    key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)

    # create certificate
    cert = OpenSSL.crypto.X509()
    cert.set_version(2)

    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)

    cert.get_subject().C = C
    cert.get_subject().ST = ST
    cert.get_subject().L = L
    cert.get_subject().O = O
    if OU:
        cert.get_subject().OU = OU
    cert.get_subject().CN = CN
    if emailAddress:
        cert.get_subject().emailAddress = emailAddress

    cert.set_serial_number(_new_serial(tls_dir))
    cert.set_issuer(cert.get_subject())
    cert.set_pubkey(key)
    cert.sign(key, salt.utils.stringutils.to_str(digest))

    # Write private key and cert
    priv_key_path = &quot;{}/{}/certs/{}.key&quot;.format(
        cert_base_path(), tls_dir, cert_filename
    )
    fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
    with salt.utils.files.fopen(fp, &quot;wb+&quot;) as priv_key:
        priv_key.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
            )
        )

    crt_path = &quot;{}/{}/certs/{}.crt&quot;.format(cert_base_path(), tls_dir, cert_filename)
    with salt.utils.files.fopen(crt_path, &quot;wb+&quot;) as crt:
        crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            )
        )

    _write_cert_to_database(tls_dir, cert)

    ret = 'Created Private Key: &quot;{}/{}/certs/{}.key.&quot; '.format(
        cert_base_path(), tls_dir, cert_filename
    )
    ret += 'Created Certificate: &quot;{}/{}/certs/{}.crt.&quot;'.format(
        cert_base_path(), tls_dir, cert_filename
    )

    return ret


def create_ca_signed_cert(
    ca_name,
    CN,
    days=365,
    cacert_path=None,
    ca_filename=None,
    cert_path=None,
    cert_filename=None,
    digest=&quot;sha256&quot;,
    cert_type=None,
    type_ext=False,
    replace=False,
):
    &quot;&quot;&quot;
    Create a Certificate (CERT) signed by a named Certificate Authority (CA)

    If the certificate file already exists, the function just returns assuming
    the CERT already exists.

    The CN *must* match an existing CSR generated by create_csr. If it
    does not, this method does nothing.

    ca_name
        name of the CA
    CN
        common name matching the certificate signing request
    days
        number of days certificate is valid, default is 365 (1 year)

    cacert_path
        absolute path to ca certificates root directory

    ca_filename
        alternative filename for the CA

        .. versionadded:: 2015.5.3


    cert_path
        full path to the certificates directory

    cert_filename
        alternative filename for the certificate, useful when using special
        characters in the CN. If this option is set it will override
        the certificate filename output effects of ``cert_type``.
        ``type_ext`` will be completely overridden.

        .. versionadded:: 2015.5.3


    digest
        The message digest algorithm. Must be a string describing a digest
        algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
        For example, &quot;md5&quot; or &quot;sha1&quot;. Default: 'sha256'
    replace
        Replace this certificate even if it exists

        .. versionadded:: 2015.5.1

    cert_type
        string. Either 'server' or 'client' (see create_csr() for details).

        If create_csr(type_ext=True) this function **must** be called with the
        same cert_type so it can find the CSR file.

    .. note::
        create_csr() defaults to cert_type='server'; therefore, if it was also
        called with type_ext, cert_type becomes a required argument for
        create_ca_signed_cert()

    type_ext
        bool. If set True, use ``cert_type`` as an extension to the CN when
        formatting the filename.

        e.g.: some_subject_CN_server.crt or some_subject_CN_client.crt

        This facilitates the context where both types are required for the same
        subject

        If ``cert_filename`` is `not None`, setting ``type_ext`` has no
        effect

    If the following values were set:

    .. code-block:: text

        ca.cert_base_path='/etc/pki'
        ca_name='koji'
        CN='test.egavas.org'

    the resulting signed certificate would be written in the following
    location:

    .. code-block:: text

        /etc/pki/koji/certs/test.egavas.org.crt

    CLI Example:

    .. code-block:: bash

        salt '*' tls.create_ca_signed_cert test localhost
    &quot;&quot;&quot;
    ret = {}

    set_ca_path(cacert_path)

    if not ca_filename:
        ca_filename = &quot;{}_ca_cert&quot;.format(ca_name)

    if not cert_path:
        cert_path = &quot;{}/{}/certs&quot;.format(cert_base_path(), ca_name)

    if type_ext:
        if not cert_type:
            log.error(
                &quot;type_ext = True but cert_type is unset. Certificate not written.&quot;
            )
            return ret
        elif cert_type:
            CN_ext = &quot;_{}&quot;.format(cert_type)
    else:
        CN_ext = &quot;&quot;

    csr_filename = &quot;{}{}&quot;.format(CN, CN_ext)

    if not cert_filename:
        cert_filename = &quot;{}{}&quot;.format(CN, CN_ext)

    if not replace and os.path.exists(
        os.path.join(
            os.path.sep.join(
                &quot;{}/{}/certs/{}.crt&quot;.format(
                    cert_base_path(), ca_name, cert_filename
                ).split(&quot;/&quot;)
            )
        )
    ):
        return 'Certificate &quot;{}&quot; already exists'.format(cert_filename)

    try:
        maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
        with salt.utils.files.fopen(
            &quot;{}/{}/{}.crt&quot;.format(cert_base_path(), ca_name, ca_filename)
        ) as fhr:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
        with salt.utils.files.fopen(
            &quot;{}/{}/{}.key&quot;.format(cert_base_path(), ca_name, ca_filename)
        ) as fhr:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        ret[&quot;retcode&quot;] = 1
        ret[&quot;comment&quot;] = 'There is no CA named &quot;{}&quot;'.format(ca_name)
        return ret

    try:
        csr_path = &quot;{}/{}.csr&quot;.format(cert_path, csr_filename)
        with salt.utils.files.fopen(csr_path) as fhr:
            req = OpenSSL.crypto.load_certificate_request(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        ret[&quot;retcode&quot;] = 1
        ret[&quot;comment&quot;] = 'There is no CSR that matches the CN &quot;{}&quot;'.format(
            cert_filename
        )
        return ret

    exts = []
    try:
        exts.extend(req.get_extensions())
    except AttributeError:
        try:
            # see: http://bazaar.launchpad.net/~exarkun/pyopenssl/master/revision/189
            # support is there from quite a long time, but without API
            # so we mimic the newly get_extensions method present in ultra
            # recent pyopenssl distros
            log.info(
                &quot;req.get_extensions() not supported in pyOpenSSL versions &quot;
                &quot;prior to 0.15. Processing extensions internally. &quot;
                &quot;Your version: %s&quot;,
                OpenSSL_version,
            )

            native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
            for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
                ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
                ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
                    native_exts_obj, i
                )
                exts.append(ext)
        except Exception:  # pylint: disable=broad-except
            log.error(
                &quot;X509 extensions are unsupported in pyOpenSSL &quot;
                &quot;versions prior to 0.14. Upgrade required to &quot;
                &quot;use extensions. Current version: %s&quot;,
                OpenSSL_version,
            )

    cert = OpenSSL.crypto.X509()
    cert.set_version(2)
    cert.set_subject(req.get_subject())
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
    cert.set_serial_number(_new_serial(ca_name))
    cert.set_issuer(ca_cert.get_subject())
    cert.set_pubkey(req.get_pubkey())

    cert.add_extensions(exts)

    cert.sign(ca_key, salt.utils.stringutils.to_str(digest))

    cert_full_path = &quot;{}/{}.crt&quot;.format(cert_path, cert_filename)

    with salt.utils.files.fopen(cert_full_path, &quot;wb+&quot;) as crt:
        crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            )
        )

    _write_cert_to_database(ca_name, cert)

    return 'Created Certificate for &quot;{}&quot;: &quot;{}/{}.crt&quot;'.format(
        CN, cert_path, cert_filename
    )


def create_pkcs12(ca_name, CN, passphrase=&quot;&quot;, cacert_path=None, replace=False):
    &quot;&quot;&quot;
    Create a PKCS#12 browser certificate for a particular Certificate (CN)

    ca_name
        name of the CA
    CN
        common name matching the certificate signing request
    passphrase
        used to unlock the PKCS#12 certificate when loaded into the browser
    cacert_path
        absolute path to ca certificates root directory
    replace
        Replace this certificate even if it exists

        .. versionadded:: 2015.5.1

    If the following values were set::

        ca.cert_base_path='/etc/pki'
        ca_name='koji'
        CN='test.egavas.org'

    the resulting signed certificate would be written in the
    following location::

        /etc/pki/koji/certs/test.egavas.org.p12

    CLI Example:

    .. code-block:: bash

        salt '*' tls.create_pkcs12 test localhost
    &quot;&quot;&quot;
    set_ca_path(cacert_path)
    if not replace and os.path.exists(
        &quot;{}/{}/certs/{}.p12&quot;.format(cert_base_path(), ca_name, CN)
    ):
        return 'Certificate &quot;{}&quot; already exists'.format(CN)

    try:
        with salt.utils.files.fopen(
            &quot;{0}/{1}/{1}_ca_cert.crt&quot;.format(cert_base_path(), ca_name)
        ) as fhr:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        return 'There is no CA named &quot;{}&quot;'.format(ca_name)

    try:
        with salt.utils.files.fopen(
            &quot;{}/{}/certs/{}.crt&quot;.format(cert_base_path(), ca_name, CN)
        ) as fhr:
            cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
        with salt.utils.files.fopen(
            &quot;{}/{}/certs/{}.key&quot;.format(cert_base_path(), ca_name, CN)
        ) as fhr:
            key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        return 'There is no certificate that matches the CN &quot;{}&quot;'.format(CN)

    pkcs12 = OpenSSL.crypto.PKCS12()

    pkcs12.set_certificate(cert)
    pkcs12.set_ca_certificates([ca_cert])
    pkcs12.set_privatekey(key)

    with salt.utils.files.fopen(
        &quot;{}/{}/certs/{}.p12&quot;.format(cert_base_path(), ca_name, CN), &quot;wb&quot;
    ) as ofile:
        ofile.write(
            pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
        )

    return 'Created PKCS#12 Certificate for &quot;{0}&quot;: &quot;{1}/{2}/certs/{0}.p12&quot;'.format(
        CN,
        cert_base_path(),
        ca_name,
    )


def cert_info(cert, digest=&quot;sha256&quot;):
    &quot;&quot;&quot;
    Return information for a particular certificate

    cert
        path to the certifiate PEM file or string

        .. versionchanged:: 2018.3.4

    digest
        what digest to use for fingerprinting

    CLI Example:

    .. code-block:: bash

        salt '*' tls.cert_info /dir/for/certs/cert.pem

    &quot;&quot;&quot;
    # format that OpenSSL returns dates in
    date_fmt = &quot;%Y%m%d%H%M%SZ&quot;
    if &quot;-----BEGIN&quot; not in cert:
        with salt.utils.files.fopen(cert) as cert_file:
            cert = cert_file.read()
    cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)

    issuer = {}
    for key, value in cert.get_issuer().get_components():
        if isinstance(key, bytes):
            key = salt.utils.stringutils.to_unicode(key)
        if isinstance(value, bytes):
            value = salt.utils.stringutils.to_unicode(value)
        issuer[key] = value

    subject = {}
    for key, value in cert.get_subject().get_components():
        if isinstance(key, bytes):
            key = salt.utils.stringutils.to_unicode(key)
        if isinstance(value, bytes):
            value = salt.utils.stringutils.to_unicode(value)
        subject[key] = value
<A NAME="1"></A>
    ret = {
        &quot;fingerprint&quot;: salt.utils.stringutils.to_unicode(
            cert<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match140657-0.html#1',2,'match140657-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.digest(salt.utils.stringutils.to_str(digest))
        ),
        &quot;subject&quot;: subject,
        &quot;issuer&quot;: issuer,
        &quot;serial_number&quot;: cert.get_serial_number(),
        &quot;not_before&quot;: calendar.timegm(
            time.strptime(</B></FONT>
                str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
            )
        ),
        &quot;not_after&quot;: calendar.timegm(
            time.strptime(
                cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
            )
        ),
    }

    # add additional info if your version of pyOpenSSL supports it
    if hasattr(cert, &quot;get_extension_count&quot;):
        ret[&quot;extensions&quot;] = {}
        for i in range(cert.get_extension_count()):
            try:
                ext = cert.get_extension(i)
                key = salt.utils.stringutils.to_unicode(ext.get_short_name())
                ret[&quot;extensions&quot;][key] = str(ext).strip()
            except AttributeError:
                continue

    if &quot;subjectAltName&quot; in ret.get(&quot;extensions&quot;, {}):
        valid_entries = (&quot;DNS&quot;, &quot;IP Address&quot;)
        valid_names = set()
        for name in str(ret[&quot;extensions&quot;][&quot;subjectAltName&quot;]).split(&quot;, &quot;):
            entry, name = name.split(&quot;:&quot;, 1)
            if entry not in valid_entries:
                log.error(
                    &quot;Cert %s has an entry (%s) which does not start with %s&quot;,
                    ret[&quot;subject&quot;],
                    name,
                    &quot;/&quot;.join(valid_entries),
                )
            else:
                valid_names.add(name)
        ret[&quot;subject_alt_names&quot;] = list(valid_names)

    if hasattr(cert, &quot;get_signature_algorithm&quot;):
        try:
            value = cert.get_signature_algorithm()
            if isinstance(value, bytes):
                value = salt.utils.stringutils.to_unicode(value)
            ret[&quot;signature_algorithm&quot;] = value
        except AttributeError:
            # On py3 at least
            # AttributeError: cdata 'X509 *' points to an opaque type: cannot read fields
            pass

    return ret


def create_empty_crl(
    ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest=&quot;sha256&quot;
):
    &quot;&quot;&quot;
    Create an empty Certificate Revocation List.

    .. versionadded:: 2015.8.0

    ca_name
        name of the CA
    cacert_path
        absolute path to ca certificates root directory
    ca_filename
        alternative filename for the CA

        .. versionadded:: 2015.5.3

    crl_file
        full path to the CRL file

    digest
        The message digest algorithm. Must be a string describing a digest
        algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
        For example, &quot;md5&quot; or &quot;sha1&quot;. Default: 'sha256'

    CLI Example:

    .. code-block:: bash

        salt '*' tls.create_empty_crl ca_name='koji' \
                ca_filename='ca' \
                crl_file='/etc/openvpn/team1/crl.pem'
    &quot;&quot;&quot;

    set_ca_path(cacert_path)

    if not ca_filename:
        ca_filename = &quot;{}_ca_cert&quot;.format(ca_name)

    if not crl_file:
        crl_file = &quot;{}/{}/crl.pem&quot;.format(_cert_base_path(), ca_name)

    if os.path.exists(&quot;{}&quot;.format(crl_file)):
        return 'CRL &quot;{}&quot; already exists'.format(crl_file)

    try:
        with salt.utils.files.fopen(
            &quot;{}/{}/{}.crt&quot;.format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
        with salt.utils.files.fopen(
            &quot;{}/{}/{}.key&quot;.format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
    except OSError:
        return 'There is no CA named &quot;{}&quot;'.format(ca_name)

    crl = OpenSSL.crypto.CRL()
    crl_text = crl.export(
        ca_cert,
        ca_key,
        digest=salt.utils.stringutils.to_bytes(digest),
    )

    with salt.utils.files.fopen(crl_file, &quot;w&quot;) as f:
        f.write(salt.utils.stringutils.to_str(crl_text))

    return 'Created an empty CRL: &quot;{}&quot;'.format(crl_file)


def revoke_cert(
    ca_name,
    CN,
    cacert_path=None,
    ca_filename=None,
    cert_path=None,
    cert_filename=None,
    crl_file=None,
    digest=&quot;sha256&quot;,
):
    &quot;&quot;&quot;
    Revoke a certificate.

    .. versionadded:: 2015.8.0

    ca_name
        Name of the CA.

    CN
        Common name matching the certificate signing request.

    cacert_path
        Absolute path to ca certificates root directory.

    ca_filename
        Alternative filename for the CA.

    cert_path
        Path to the cert file.

    cert_filename
        Alternative filename for the certificate, useful when using special
        characters in the CN.

    crl_file
        Full path to the CRL file.

    digest
        The message digest algorithm. Must be a string describing a digest
        algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
        For example, &quot;md5&quot; or &quot;sha1&quot;. Default: 'sha256'

    CLI Example:

    .. code-block:: bash

        salt '*' tls.revoke_cert ca_name='koji' \
                ca_filename='ca' \
                crl_file='/etc/openvpn/team1/crl.pem'

    &quot;&quot;&quot;

    set_ca_path(cacert_path)
    ca_dir = &quot;{}/{}&quot;.format(cert_base_path(), ca_name)

    if ca_filename is None:
        ca_filename = &quot;{}_ca_cert&quot;.format(ca_name)

    if cert_path is None:
        cert_path = &quot;{}/{}/certs&quot;.format(_cert_base_path(), ca_name)

    if cert_filename is None:
        cert_filename = &quot;{}&quot;.format(CN)

    try:
        with salt.utils.files.fopen(
            &quot;{}/{}/{}.crt&quot;.format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
        with salt.utils.files.fopen(
            &quot;{}/{}/{}.key&quot;.format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
    except OSError:
        return 'There is no CA named &quot;{}&quot;'.format(ca_name)

    client_cert = _read_cert(&quot;{}/{}.crt&quot;.format(cert_path, cert_filename))
    if client_cert is None:
        return 'There is no client certificate named &quot;{}&quot;'.format(CN)

    index_file, expire_date, serial_number, subject = _get_basic_info(
        ca_name, client_cert, ca_dir
    )

    index_serial_subject = &quot;{}\tunknown\t{}&quot;.format(serial_number, subject)
    index_v_data = &quot;V\t{}\t\t{}&quot;.format(expire_date, index_serial_subject)
    index_r_data_pattern = re.compile(
        r&quot;R\t&quot; + expire_date + r&quot;\t\d{12}Z\t&quot; + re.escape(index_serial_subject)
    )
    index_r_data = &quot;R\t{}\t{}\t{}&quot;.format(
        expire_date,
        _four_digit_year_to_two_digit(datetime.utcnow()),
        index_serial_subject,
    )

    ret = {}
    with salt.utils.files.fopen(index_file) as fp_:
        for line in fp_:
            line = salt.utils.stringutils.to_unicode(line)
            if index_r_data_pattern.match(line):
                revoke_date = line.split(&quot;\t&quot;)[2]
                try:
                    datetime.strptime(revoke_date, two_digit_year_fmt)
                    return '&quot;{}/{}.crt&quot; was already revoked, serial number: {}'.format(
                        cert_path, cert_filename, serial_number
                    )
                except ValueError:
                    ret[&quot;retcode&quot;] = 1
                    ret[
                        &quot;comment&quot;
                    ] = &quot;Revocation date '{}' does not matchformat '{}'&quot;.format(
                        revoke_date, two_digit_year_fmt
                    )
                    return ret
            elif index_serial_subject in line:
                __salt__[&quot;file.replace&quot;](
                    index_file, index_v_data, index_r_data, backup=False
                )
                break

    crl = OpenSSL.crypto.CRL()

    with salt.utils.files.fopen(index_file) as fp_:
        for line in fp_:
            line = salt.utils.stringutils.to_unicode(line)
            if line.startswith(&quot;R&quot;):
                fields = line.split(&quot;\t&quot;)
                revoked = OpenSSL.crypto.Revoked()
                revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
                revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
                revoked.set_rev_date(
                    salt.utils.stringutils.to_bytes(
                        revoke_date_2_digit.strftime(four_digit_year_fmt)
                    )
                )
                crl.add_revoked(revoked)

    crl_text = crl.export(
        ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
    )

    if crl_file is None:
        crl_file = &quot;{}/{}/crl.pem&quot;.format(_cert_base_path(), ca_name)

    if os.path.isdir(crl_file):
        ret[&quot;retcode&quot;] = 1
        ret[&quot;comment&quot;] = 'crl_file &quot;{}&quot; is an existing directory'.format(crl_file)
        return ret

    with salt.utils.files.fopen(crl_file, &quot;w&quot;) as fp_:
        fp_.write(salt.utils.stringutils.to_str(crl_text))

    return 'Revoked Certificate: &quot;{}/{}.crt&quot;, serial number: {}'.format(
        cert_path, cert_filename, serial_number
    )


if __name__ == &quot;__main__&quot;:
    # create_ca('koji', days=365, **cert_sample_meta)
    create_csr(
        &quot;koji&quot;,
        CN=&quot;test_system&quot;,
        C=&quot;US&quot;,
        ST=&quot;Utah&quot;,
        L=&quot;Centerville&quot;,
        O=&quot;SaltStack&quot;,
        OU=None,
        emailAddress=&quot;test_system@saltstack.org&quot;,
    )
    create_ca_signed_cert(&quot;koji&quot;, &quot;test_system&quot;)
    create_pkcs12(&quot;koji&quot;, &quot;test_system&quot;, passphrase=&quot;test&quot;)
</PRE>
</div>
  </div>
</body>
</html>
