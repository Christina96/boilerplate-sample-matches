<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tcp.py &amp; debian_ip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tcp.py &amp; debian_ip.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tcp.py (2.2803113%)<th>debian_ip.py (1.5763168%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(10-25)<td><a href="#" name="0">(8-23)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(334-340)<td><a href="#" name="1">(1241-1244)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1046-1048)<td><a href="#" name="2">(1216-1220)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tcp.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
3 import logging
4 import os
5 import queue
6 import socket
7 import threading
8 import urllib
9 import salt.ext.tornado
10 import salt.ext.tornado.concurrent
11 import salt.ext.tornado.gen
12 import salt.ext.tornado.iostream
13 import salt.ext.tornado.netutil
14 import salt.ext.tornado.tcpclient
15 import salt.ext.tornado.tcpserver
16 import</b></font> salt.master
17 import salt.payload
18 import salt.transport.client
19 import salt.transport.frame
20 import salt.transport.ipc
21 import salt.transport.server
22 import salt.utils.asynchronous
23 import salt.utils.files
24 import salt.utils.msgpack
25 import salt.utils.platform
26 import salt.utils.versions
27 from salt.exceptions import SaltClientError, SaltReqTimeoutError
28 if salt.utils.platform.is_windows():
29     USE_LOAD_BALANCER = True
30 else:
31     USE_LOAD_BALANCER = False
32 if USE_LOAD_BALANCER:
33     import threading
34     import multiprocessing
35     import salt.ext.tornado.util
36     from salt.utils.process import SignalHandlingProcess
37 log = logging.getLogger(__name__)
38 class ClosingError(Exception):
39 def _set_tcp_keepalive(sock, opts):
40     """
41     Ensure that TCP keepalives are set for the socket.
42     """
43     if hasattr(socket, "SO_KEEPALIVE"):
44         if opts.get("tcp_keepalive", False):
45             sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
46             if hasattr(socket, "SOL_TCP"):
47                 if hasattr(socket, "TCP_KEEPIDLE"):
48                     tcp_keepalive_idle = opts.get("tcp_keepalive_idle", -1)
49                     if tcp_keepalive_idle &gt; 0:
50                         sock.setsockopt(
51                             socket.SOL_TCP, socket.TCP_KEEPIDLE, int(tcp_keepalive_idle)
52                         )
53                 if hasattr(socket, "TCP_KEEPCNT"):
54                     tcp_keepalive_cnt = opts.get("tcp_keepalive_cnt", -1)
55                     if tcp_keepalive_cnt &gt; 0:
56                         sock.setsockopt(
57                             socket.SOL_TCP, socket.TCP_KEEPCNT, int(tcp_keepalive_cnt)
58                         )
59                 if hasattr(socket, "TCP_KEEPINTVL"):
60                     tcp_keepalive_intvl = opts.get("tcp_keepalive_intvl", -1)
61                     if tcp_keepalive_intvl &gt; 0:
62                         sock.setsockopt(
63                             socket.SOL_TCP,
64                             socket.TCP_KEEPINTVL,
65                             int(tcp_keepalive_intvl),
66                         )
67             if hasattr(socket, "SIO_KEEPALIVE_VALS"):
68                 tcp_keepalive_idle = opts.get("tcp_keepalive_idle", -1)
69                 tcp_keepalive_intvl = opts.get("tcp_keepalive_intvl", -1)
70                 if tcp_keepalive_idle &gt; 0 or tcp_keepalive_intvl &gt; 0:
71                     if tcp_keepalive_idle &lt;= 0:
72                         tcp_keepalive_idle = 7200
73                     if tcp_keepalive_intvl &lt;= 0:
74                         tcp_keepalive_intvl = 1
75                     sock.ioctl(
76                         socket.SIO_KEEPALIVE_VALS,
77                         (
78                             1,
79                             int(tcp_keepalive_idle * 1000),
80                             int(tcp_keepalive_intvl * 1000),
81                         ),
82                     )
83         else:
84             sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 0)
85 if USE_LOAD_BALANCER:
86     class LoadBalancerServer(SignalHandlingProcess):
87         """
88         Raw TCP server which runs in its own process and will listen
89         for incoming connections. Each incoming connection will be
90         sent via multiprocessing queue to the workers.
91         Since the queue is shared amongst workers, only one worker will
92         handle a given connection.
93         """
94         backlog = 128
95         def __init__(self, opts, socket_queue, **kwargs):
96             super().__init__(**kwargs)
97             self.opts = opts
98             self.socket_queue = socket_queue
99             self._socket = None
100         def close(self):
101             if self._socket is not None:
102                 self._socket.shutdown(socket.SHUT_RDWR)
103                 self._socket.close()
104                 self._socket = None
105         def __del__(self):
106             self.close()
107         def run(self):
108             """
109             Start the load balancer
110             """
111             self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
112             self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
113             _set_tcp_keepalive(self._socket, self.opts)
114             self._socket.setblocking(1)
115             self._socket.bind((self.opts["interface"], int(self.opts["ret_port"])))
116             self._socket.listen(self.backlog)
117             while True:
118                 try:
119                     connection, address = self._socket.accept()
120                     self.socket_queue.put((connection, address), True, None)
121                 except OSError as e:
122                     if (
123                         salt.ext.tornado.util.errno_from_exception(e)
124                         == errno.ECONNABORTED
125                     ):
126                         continue
127                     raise
128 class Resolver:
129     _resolver_configured = False
130     @classmethod
131     def _config_resolver(cls, num_threads=10):
132         salt.ext.tornado.netutil.Resolver.configure(
133             "salt.ext.tornado.netutil.ThreadedResolver", num_threads=num_threads
134         )
135         cls._resolver_configured = True
136     def __init__(self, *args, **kwargs):
137         if not self._resolver_configured:
138             self._config_resolver()
139 class TCPPubClient(salt.transport.base.PublishClient):
140     """
141     Tornado based TCP Pub Client
142     """
143     ttype = "tcp"
144     def __init__(self, opts, io_loop, **kwargs):  # pylint: disable=W0231
145         self.opts = opts
146         self.io_loop = io_loop
147         self.message_client = None
148         self.connected = False
149         self._closing = False
150         self.resolver = Resolver()
151     def close(self):
152         if self._closing:
153             return
154         self._closing = True
155         if self.message_client is not None:
156             self.message_client.close()
157             self.message_client = None
158     def __del__(self):
159         self.close()
160     @salt.ext.tornado.gen.coroutine
161     def connect(self, publish_port, connect_callback=None, disconnect_callback=None):
162         self.publish_port = publish_port
163         self.message_client = MessageClient(
164             self.opts,
165             self.opts["master_ip"],
166             int(self.publish_port),
167             io_loop=self.io_loop,
168             connect_callback=connect_callback,
169             disconnect_callback=disconnect_callback,
170             source_ip=self.opts.get("source_ip"),
171             source_port=self.opts.get("source_publish_port"),
172         )
173         yield self.message_client.connect()  # wait for the client to be connected
174         self.connected = True
175     @salt.ext.tornado.gen.coroutine
176     def _decode_messages(self, messages):
177         if not isinstance(messages, dict):
178             body = salt.utils.msgpack.loads(messages)
179             body = salt.transport.frame.decode_embedded_strs(body)
180         else:
181             body = messages
182         raise salt.ext.tornado.gen.Return(body)
183     @salt.ext.tornado.gen.coroutine
184     def send(self, msg):
185         yield self.message_client._stream.write(msg)
186     def on_recv(self, callback):
187         """
188         Register an on_recv callback
189         """
190         return self.message_client.on_recv(callback)
191     def __enter__(self):
192         return self
193     def __exit__(self, exc_type, exc_val, exc_tb):
194         self.close()
195 class TCPReqServer(salt.transport.base.DaemonizedRequestServer):
196     """
197     Tornado based TCP Request/Reply Server
198     :param dict opts: Salt master config options.
199     """
200     backlog = 5
201     def __init__(self, opts):  # pylint: disable=W0231
202         self.opts = opts
203         self._socket = None
204         self.req_server = None
205     @property
206     def socket(self):
207         return self._socket
208     def close(self):
209         if self._socket is not None:
210             try:
211                 self._socket.shutdown(socket.SHUT_RDWR)
212             except OSError as exc:
213                 if exc.errno == errno.ENOTCONN:
214                     pass
215                 else:
216                     raise
217             if self.req_server is None:
218                 self._socket.close()
219             self._socket = None
220         if self.req_server is not None:
221             try:
222                 self.req_server.close()
223             except OSError as exc:
224                 if exc.errno != 9:
225                     raise
226                 log.exception(
227                     "TCPReqServerChannel close generated an exception: %s", str(exc)
228                 )
229             self.req_server = None
230     def __enter__(self):
231         return self
232     def __exit__(self, *args):
233         self.close()
234     def pre_fork(self, process_manager):
235         """
236         Pre-fork we need to create the zmq router device
237         if USE_LOAD_BALANCER:
238             self.socket_queue = multiprocessing.Queue()
239             process_manager<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_process(
240                 LoadBalancerServer,
241                 args=(self.opts, self.socket_queue),
242                 name="LoadBalancerServer",
243             )
244         elif not salt.utils.platform.is_windows():
245             self._socket = socket.</b></font>socket(socket.AF_INET, socket.SOCK_STREAM)
246             self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
247             _set_tcp_keepalive(self._socket, self.opts)
248             self._socket.setblocking(0)
249             self._socket.bind((self.opts["interface"], int(self.opts["ret_port"])))
250     def post_fork(self, message_handler, io_loop):
251         """
252         After forking we need to create all of the local sockets to listen to the
253         router
254         message_handler: function to call with your payloads
255         """
256         self.message_handler = message_handler
257         with salt.utils.asynchronous.current_ioloop(io_loop):
258             if USE_LOAD_BALANCER:
259                 self.req_server = LoadBalancerWorker(
260                     self.socket_queue,
261                     self.handle_message,
262                     ssl_options=self.opts.get("ssl"),
263                 )
264             else:
265                 if salt.utils.platform.is_windows():
266                     self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
267                     self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
268                     _set_tcp_keepalive(self._socket, self.opts)
269                     self._socket.setblocking(0)
270                     self._socket.bind(
271                         (self.opts["interface"], int(self.opts["ret_port"]))
272                     )
273                 self.req_server = SaltMessageServer(
274                     self.handle_message,
275                     ssl_options=self.opts.get("ssl"),
276                     io_loop=io_loop,
277                 )
278                 self.req_server.add_socket(self._socket)
279                 self._socket.listen(self.backlog)
280     @salt.ext.tornado.gen.coroutine
281     def handle_message(self, stream, payload, header=None):
282         payload = self.decode_payload(payload)
283         reply = yield self.message_handler(payload)
284         stream.write(salt.transport.frame.frame_msg(reply, header=header))
285     def decode_payload(self, payload):
286         return payload
287 class SaltMessageServer(salt.ext.tornado.tcpserver.TCPServer):
288     """
289     Raw TCP server which will receive all of the TCP streams and re-assemble
290     messages that are sent through to us
291     """
292     def __init__(self, message_handler, *args, **kwargs):
293         io_loop = (
294             kwargs.pop("io_loop", None) or salt.ext.tornado.ioloop.IOLoop.current()
295         )
296         self._closing = False
297         super().__init__(*args, **kwargs)
298         self.io_loop = io_loop
299         self.clients = []
300         self.message_handler = message_handler
301     @salt.ext.tornado.gen.coroutine
302     def handle_stream(self, stream, address):
303         """
304         Handle incoming streams and add messages to the incoming queue
305         """
306         log.trace("Req client %s connected", address)
307         self.clients.append((stream, address))
308         unpacker = salt.utils.msgpack.Unpacker()
309         try:
310             while True:
311                 wire_bytes = yield stream.read_bytes(4096, partial=True)
312                 unpacker.feed(wire_bytes)
313                 for framed_msg in unpacker:
314                     framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
315                     header = framed_msg["head"]
316                     self.io_loop.spawn_callback(
317                         self.message_handler, stream, framed_msg["body"], header
318                     )
319         except salt.ext.tornado.iostream.StreamClosedError:
320             log.trace("req client disconnected %s", address)
321             self.remove_client((stream, address))
322         except Exception as e:  # pylint: disable=broad-except
323             log.trace("other master-side exception: %s", e, exc_info=True)
324             self.remove_client((stream, address))
325             stream.close()
326     def remove_client(self, client):
327         try:
328             self.clients.remove(client)
329         except ValueError:
330             log.trace("Message server client was not in list to remove")
331     def close(self):
332         """
333         Close the server
334         """
335         if self._closing:
336             return
337         self._closing = True
338         for item in self.clients:
339             client, address = item
340             client.close()
341             self.remove_client(item)
342         try:
343             self.stop()
344         except OSError as exc:
345             if exc.errno != 9:
346                 raise
347 if USE_LOAD_BALANCER:
348     class LoadBalancerWorker(SaltMessageServer):
349         """
350         This will receive TCP connections from 'LoadBalancerServer' via
351         a multiprocessing queue.
352         Since the queue is shared amongst workers, only one worker will handle
353         a given connection.
354         """
355         def __init__(self, socket_queue, message_handler, *args, **kwargs):
356             super().__init__(message_handler, *args, **kwargs)
357             self.socket_queue = socket_queue
358             self._stop = threading.Event()
359             self.thread = threading.Thread(target=self.socket_queue_thread)
360             self.thread.start()
361         def close(self):
362             self._stop.set()
363             self.thread.join()
364             super().close()
365         def socket_queue_thread(self):
366             try:
367                 while True:
368                     try:
369                         client_socket, address = self.socket_queue.get(True, 1)
370                     except queue.Empty:
371                         if self._stop.is_set():
372                             break
373                         continue
374                     self.io_loop.spawn_callback(
375                         self._handle_connection, client_socket, address
376                     )
377             except (KeyboardInterrupt, SystemExit):
378                 pass
379 class TCPClientKeepAlive(salt.ext.tornado.tcpclient.TCPClient):
380     """
381     Override _create_stream() in TCPClient to enable keep alive support.
382     """
383     def __init__(self, opts, resolver=None):
384         self.opts = opts
385         super().__init__(resolver=resolver)
386     def _create_stream(
387         self, max_buffer_size, af, addr, **kwargs
388     ):  # pylint: disable=unused-argument,arguments-differ
389         """
390         Override _create_stream() in TCPClient.
391         Tornado 4.5 added the kwargs 'source_ip' and 'source_port'.
392         Due to this, use **kwargs to swallow these and any future
393         kwargs to maintain compatibility.
394         """
395         sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
396         _set_tcp_keepalive(sock, self.opts)
397         stream = salt.ext.tornado.iostream.IOStream(
398             sock, max_buffer_size=max_buffer_size
399         )
400         if salt.ext.tornado.version_info &lt; (5,):
401             return stream.connect(addr)
402         return stream, stream.connect(addr)
403 class MessageClient:
404     """
405     Low-level message sending client
406     """
407     def __init__(
408         self,
409         opts,
410         host,
411         port,
412         io_loop=None,
413         resolver=None,
414         connect_callback=None,
415         disconnect_callback=None,
416         source_ip=None,
417         source_port=None,
418     ):
419         self.opts = opts
420         self.host = host
421         self.port = port
422         self.source_ip = source_ip
423         self.source_port = source_port
424         self.connect_callback = connect_callback
425         self.disconnect_callback = disconnect_callback
426         self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
427         with salt.utils.asynchronous.current_ioloop(self.io_loop):
428             self._tcp_client = TCPClientKeepAlive(opts, resolver=resolver)
429         self._mid = 1
430         self._max_messages = int((1 &lt;&lt; 31) - 2)  # number of IDs before we wrap
431         self.send_queue = []  # queue of messages to be sent
432         self.send_future_map = {}  # mapping of request_id -&gt; Future
433         self._read_until_future = None
434         self._on_recv = None
435         self._closing = False
436         self._closed = False
437         self._connecting_future = salt.ext.tornado.concurrent.Future()
438         self._stream_return_running = False
439         self._stream = None
440         self.backoff = opts.get("tcp_reconnect_backoff", 1)
441     def _stop_io_loop(self):
442         if self.io_loop is not None:
443             self.io_loop.stop()
444     def close(self):
445         if self._closing:
446             return
447         self._closing = True
448         self.io_loop.add_timeout(1, self.check_close)
449     @salt.ext.tornado.gen.coroutine
450     def check_close(self):
451         if not self.send_future_map:
452             self._tcp_client.close()
453             self._stream = None
454             self._closing = False
455             self._closed = True
456         else:
457             self.io_loop.add_timeout(1, self.check_close)
458     def __del__(self):
459         self.close()
460     @salt.ext.tornado.gen.coroutine
461     def getstream(self, **kwargs):
462         if self.source_ip or self.source_port:
463             kwargs = {
464                 "source_ip": self.source_ip,
465                 "source_port": self.source_port,
466             }
467         stream = None
468         while stream is None and (not self._closed and not self._closing):
469             try:
470                 stream = yield self._tcp_client.connect(
471                     self.host, self.port, ssl_options=self.opts.get("ssl"), **kwargs
472                 )
473             except Exception as exc:  # pylint: disable=broad-except
474                 log.warning(
475                     "TCP Message Client encountered an exception while connecting to"
476                     " %s:%s: %r, will reconnect in %d seconds",
477                     self.host,
478                     self.port,
479                     exc,
480                     self.backoff,
481                 )
482                 yield salt.ext.tornado.gen.sleep(self.backoff)
483         raise salt.ext.tornado.gen.Return(stream)
484     @salt.ext.tornado.gen.coroutine
485     def connect(self):
486         if self._stream is None:
487             self._stream = yield self.getstream()
488             if self._stream:
489                 if not self._stream_return_running:
490                     self.io_loop.spawn_callback(self._stream_return)
491                 if self.connect_callback:
492                     self.connect_callback(True)
493     @salt.ext.tornado.gen.coroutine
494     def _stream_return(self):
495         self._stream_return_running = True
496         unpacker = salt.utils.msgpack.Unpacker()
497         while not self._closing:
498             try:
499                 wire_bytes = yield self._stream.read_bytes(4096, partial=True)
500                 unpacker.feed(wire_bytes)
501                 for framed_msg in unpacker:
502                     framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
503                     header = framed_msg["head"]
504                     body = framed_msg["body"]
505                     message_id = header.get("mid")
506                     if message_id in self.send_future_map:
507                         self.send_future_map.pop(message_id).set_result(body)
508                     else:
509                         if self._on_recv is not None:
510                             self.io_loop.spawn_callback(self._on_recv, header, body)
511                         else:
512                             log.error(
513                                 "Got response for message_id %s that we are not"
514                                 " tracking",
515                                 message_id,
516                             )
517             except salt.ext.tornado.iostream.StreamClosedError as e:
518                 log.debug(
519                     "tcp stream to %s:%s closed, unable to recv",
520                     self.host,
521                     self.port,
522                 )
523                 for future in self.send_future_map.values():
524                     future.set_exception(e)
525                 self.send_future_map = {}
526                 if self._closing or self._closed:
527                     return
528                 if self.disconnect_callback:
529                     self.disconnect_callback()
530                 stream = self._stream
531                 self._stream = None
532                 if stream:
533                     stream.close()
534                 yield self.connect()
535             except TypeError:
536                 if "detect_mode" in self.opts:
537                     log.info(
538                         "There was an error trying to use TCP transport; "
539                         "attempting to fallback to another transport"
540                     )
541                 else:
542                     raise SaltClientError
543             except Exception as e:  # pylint: disable=broad-except
544                 log.error("Exception parsing response", exc_info=True)
545                 for future in self.send_future_map.values():
546                     future.set_exception(e)
547                 self.send_future_map = {}
548                 if self._closing or self._closed:
549                     return
550                 if self.disconnect_callback:
551                     self.disconnect_callback()
552                 stream = self._stream
553                 self._stream = None
554                 if stream:
555                     stream.close()
556                 yield self.connect()
557         self._stream_return_running = False
558     def _message_id(self):
559         wrap = False
560         while self._mid in self.send_future_map:
561             if self._mid &gt;= self._max_messages:
562                 if wrap:
563                     raise Exception("Unable to find available messageid")
564                 self._mid = 1
565                 wrap = True
566             else:
567                 self._mid += 1
568         return self._mid
569     def on_recv(self, callback):
570         """
571         Register a callback for received messages (that we didn't initiate)
572         """
573         if callback is None:
574             self._on_recv = callback
575         else:
576             def wrap_recv(header, body):
577                 callback(body)
578             self._on_recv = wrap_recv
579     def remove_message_timeout(self, message_id):
580         if message_id not in self.send_timeout_map:
581             return
582         timeout = self.send_timeout_map.pop(message_id)
583         self.io_loop.remove_timeout(timeout)
584     def timeout_message(self, message_id, msg):
585         if message_id not in self.send_future_map:
586             return
587         future = self.send_future_map.pop(message_id)
588         if future is not None:
589             future.set_exception(SaltReqTimeoutError("Message timed out"))
590     @salt.ext.tornado.gen.coroutine
591     def send(self, msg, timeout=None, callback=None, raw=False):
592         if self._closing:
593             raise ClosingError()
594         message_id = self._message_id()
595         header = {"mid": message_id}
596         future = salt.ext.tornado.concurrent.Future()
597         if callback is not None:
598             def handle_future(future):
599                 response = future.result()
600                 self.io_loop.add_callback(callback, response)
601             future.add_done_callback(handle_future)
602         self.send_future_map[message_id] = future
603         if self.opts.get("detect_mode") is True:
604             timeout = 1
605         if timeout is not None:
606             self.io_loop.call_later(timeout, self.timeout_message, message_id, msg)
607         item = salt.transport.frame.frame_msg(msg, header=header)
608         @salt.ext.tornado.gen.coroutine
609         def _do_send():
610             yield self.connect()
611             if self._stream:
612                 yield self._stream.write(item)
613         self.io_loop.add_callback(_do_send)
614         recv = yield future
615         raise salt.ext.tornado.gen.Return(recv)
616 class Subscriber:
617     """
618     Client object for use with the TCP publisher server
619     """
620     def __init__(self, stream, address):
621         self.stream = stream
622         self.address = address
623         self._closing = False
624         self._read_until_future = None
625         self.id_ = None
626     def close(self):
627         if self._closing:
628             return
629         self._closing = True
630         if not self.stream.closed():
631             self.stream.close()
632             if self._read_until_future is not None and self._read_until_future.done():
633                 self._read_until_future.exception()
634     def __del__(self):
635         self.close()
636 class PubServer(salt.ext.tornado.tcpserver.TCPServer):
637     """
638     TCP publisher
639     """
640     def __init__(
641         self, opts, io_loop=None, presence_callback=None, remove_presence_callback=None
642     ):
643         super().__init__(ssl_options=opts.get("ssl"))
644         self.io_loop = io_loop
645         self.opts = opts
646         self._closing = False
647         self.clients = set()
648         self.presence_events = False
649         if presence_callback:
650             self.presence_callback = presence_callback
651         else:
652             self.presence_callback = lambda subscriber, msg: msg
653         if remove_presence_callback:
654             self.remove_presence_callback = remove_presence_callback
655         else:
656             self.remove_presence_callback = lambda subscriber: subscriber
657     def close(self):
658         if self._closing:
659             return
660         self._closing = True
661         for client in self.clients:
662             client.stream.disconnect()
663     def __del__(self):
664         self.close()
665     @salt.ext.tornado.gen.coroutine
666     def _stream_read(self, client):
667         unpacker = salt.utils.msgpack.Unpacker()
668         while not self._closing:
669             try:
670                 client._read_until_future = client.stream.read_bytes(4096, partial=True)
671                 wire_bytes = yield client._read_until_future
672                 unpacker.feed(wire_bytes)
673                 for framed_msg in unpacker:
674                     framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
675                     body = framed_msg["body"]
676                     if self.presence_callback:
677                         self.presence_callback(client, body)
678             except salt.ext.tornado.iostream.StreamClosedError as e:
679                 log.debug("tcp stream to %s closed, unable to recv", client.address)
680                 client.close()
681                 self.remove_presence_callback(client)
682                 self.clients.discard(client)
683                 break
684             except Exception as e:  # pylint: disable=broad-except
685                 log.error(
686                     "Exception parsing response from %s", client.address, exc_info=True
687                 )
688                 continue
689     def handle_stream(self, stream, address):
690         log.debug("Subscriber at %s connected", address)
691         client = Subscriber(stream, address)
692         self.clients.add(client)
693         self.io_loop.spawn_callback(self._stream_read, client)
694     @salt.ext.tornado.gen.coroutine
695     def publish_payload(self, package, topic_list=None):
696         log.trace("TCP PubServer sending payload: %s \n\n %r", package, topic_list)
697         payload = salt.transport.frame.frame_msg(package)
698         to_remove = []
699         if topic_list:
700             for topic in topic_list:
701                 sent = False
702                 for client in self.clients:
703                     if topic == client.id_:
704                         try:
705                             yield client.stream.write(payload)
706                             sent = True
707                         except salt.ext.tornado.iostream.StreamClosedError:
708                             to_remove.append(client)
709                 if not sent:
710                     log.debug("Publish target %s not connected %r", topic, self.clients)
711         else:
712             for client in self.clients:
713                 try:
714                     yield client.stream.write(payload)
715                 except salt.ext.tornado.iostream.StreamClosedError:
716                     to_remove.append(client)
717         for client in to_remove:
718             log.debug(
719                 "Subscriber at %s has disconnected from publisher", client.address
720             )
721             client.close()
722             self._remove_client_present(client)
723             self.clients.discard(client)
724         log.trace("TCP PubServer finished publishing payload")
725 class TCPPublishServer(salt.transport.base.DaemonizedPublishServer):
726     """
727     Tornado based TCP PublishServer
728     """
729     backlog = 128
730     def __init__(self, opts):
731         self.opts = opts
732         self.pub_sock = None
733     @property
734     def topic_support(self):
735         return not self.opts.get("order_masters", False)
736     def __setstate__(self, state):
737         self.__init__(state["opts"])
738     def __getstate__(self):
739         return {"opts": self.opts}
740     def publish_daemon(
741         self,
742         publish_payload,
743         presence_callback=None,
744         remove_presence_callback=None,
745     ):
746         """
747         Bind to the interface specified in the configuration file
748         """
749         io_loop = salt.ext.tornado.ioloop.IOLoop()
750         io_loop.make_current()
751         self.pub_server = pub_server = PubServer(
752             self.opts,
753             io_loop=io_loop,
754             presence_callback=presence_callback,
755             remove_presence_callback=remove_presence_callback,
756         )
757         sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
758         sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
759         _set_tcp_keepalive(sock, self.opts)
760         sock.setblocking(0)
761         sock.bind((self.opts["interface"], int(self.opts["publish_port"])))
762         sock.listen(self.backlog)
763         pub_server.add_socket(sock)
764         if self.opts.get("ipc_mode", "") == "tcp":
765             pull_uri = int(self.opts.get("tcp_master_publish_pull", 4514))
766         else:
767             pull_uri = os.path.join(self.opts["sock_dir"], "publish_pull.ipc")
768         self.pub_server = pub_server
769         pull_sock = salt.transport.ipc.IPCMessageServer(
770             pull_uri,
771             io_loop=io_loop,
772             payload_handler=publish_payload,
773         )
774         log.warn("Starting the Salt Puller on %s", pull_uri)
775         with salt.utils.files.set_umask(0o177):
776             pull_sock.start()
777         try:
778             io_loop.start()
779         except (KeyboardInterrupt, SystemExit):
780             pass
781         finally:
782             pull_sock.close()
783     def pre_fork(self, process_manager):
784         """
785         Do anything necessary pre-fork. Since this is on the master side this will
786         primarily be used to create IPC channels and create our daemon process to
787         do the actual publishing
788         """
789         process_manager.add_process(self.publish_daemon, name=self.__class__.__name__)
790     @salt.ext.tornado.gen.coroutine
791     def publish_payload(self, payload, *args):
792         ret = yield self.pub_server.publish_payload(payload, *args)
793         raise salt.ext.tornado.gen.Return(ret)
794     def publish(self, payload, **kwargs):
795         """
796         Publish "load" to minions
797         """
798         if self.opts.get("ipc_mode", "") == "tcp":
799             pull_uri = int(self.opts.get("tcp_master_publish_pull", 4514))
800         else:
801             pull_uri = os.path.join(self.opts["sock_dir"], "publish_pull.ipc")
802         if not self.pub_sock:
803             self.pub_sock = salt.utils.asynchronous.SyncWrapper(
804                 salt.transport.ipc.IPCMessageClient,
805                 (pull_uri,),
806                 loop_kwarg="io_loop",
807             )
808             self.pub_sock.connect()
809         self.pub_sock.send(payload)
810     def close(self):
811         if self.pub_sock:
812             self.pub_sock.close()
813             self.pub_sock = None
814 class TCPReqClient(salt.transport.base.RequestClient):
815     """
816     Tornado based TCP RequestClient
817     """
818     ttype = "tcp"
819         self.opts = opts
820         self.io_loop = io_loop
821         parse = urllib<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.parse.urlparse(self.opts["master_uri"])
822         master_host, master_port = parse.netloc.rsplit(":", 1)
823         master_addr = (master_host, int(</b></font>master_port))
824         resolver = kwargs.get("resolver")
825         self.message_client = salt.transport.tcp.MessageClient(
826             opts,
827             master_host,
828             int(master_port),
829             io_loop=io_loop,
830             resolver=resolver,
831             source_ip=opts.get("source_ip"),
832             source_port=opts.get("source_ret_port"),
833         )
834     @salt.ext.tornado.gen.coroutine
835     def connect(self):
836         yield self.message_client.connect()
837     @salt.ext.tornado.gen.coroutine
838     def send(self, load, timeout=60):
839         ret = yield self.message_client.send(load, timeout=timeout)
840         raise salt.ext.tornado.gen.Return(ret)
841     def close(self):
842         self.message_client.close()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>debian_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 The networking module for Debian-based distros
3 References:
4 * http://www.debian.org/doc/manuals/debian-reference/ch05.en.html
5 """
6 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import functools
7 import io
8 import logging
9 import os
10 import os.path
11 import re
12 import time
13 import jinja2
14 import jinja2.exceptions
15 import salt.utils.dns
16 import salt.utils.files
17 import salt.utils.odict
18 import salt.utils.stringutils
19 import salt.utils.templates
20 import</b></font> salt.utils.validate.net
21 log = logging.getLogger(__name__)
22 JINJA = jinja2.Environment(
23     loader=jinja2.FileSystemLoader(
24         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "debian_ip")
25     )
26 )
27 __virtualname__ = "ip"
28 def __virtual__():
29     """
30     Confine this module to Debian-based distros
31     """
32     if __grains__["os_family"] == "Debian":
33         return __virtualname__
34     return (False, "The debian_ip module could not be loaded: unsupported OS family")
35 _ETHTOOL_CONFIG_OPTS = {
36     "speed": "link-speed",
37     "duplex": "link-duplex",
38     "autoneg": "ethernet-autoneg",
39     "ethernet-port": "ethernet-port",
40     "wol": "ethernet-wol",
41     "driver-message-level": "driver-message-level",
42     "ethernet-pause-rx": "ethernet-pause-rx",
43     "ethernet-pause-tx": "ethernet-pause-tx",
44     "ethernet-pause-autoneg": "ethernet-pause-autoneg",
45     "rx": "offload-rx",
46     "tx": "offload-tx",
47     "sg": "offload-sg",
48     "tso": "offload-tso",
49     "ufo": "offload-ufo",
50     "gso": "offload-gso",
51     "gro": "offload-gro",
52     "lro": "offload-lro",
53     "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
54     "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
55     "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
56     "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
57     "hardware-dma-ring-rx": "hardware-dma-ring-rx",
58     "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
59     "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
60     "hardware-dma-ring-tx": "hardware-dma-ring-tx",
61 }
62 _REV_ETHTOOL_CONFIG_OPTS = {
63     "link-speed": "speed",
64     "link-duplex": "duplex",
65     "ethernet-autoneg": "autoneg",
66     "ethernet-port": "ethernet-port",
67     "ethernet-wol": "wol",
68     "driver-message-level": "driver-message-level",
69     "ethernet-pause-rx": "ethernet-pause-rx",
70     "ethernet-pause-tx": "ethernet-pause-tx",
71     "ethernet-pause-autoneg": "ethernet-pause-autoneg",
72     "offload-rx": "rx",
73     "offload-tx": "tx",
74     "offload-sg": "sg",
75     "offload-tso": "tso",
76     "offload-ufo": "ufo",
77     "offload-gso": "gso",
78     "offload-lro": "lro",
79     "offload-gro": "gro",
80     "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
81     "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
82     "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
83     "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
84     "hardware-dma-ring-rx": "hardware-dma-ring-rx",
85     "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
86     "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
87     "hardware-dma-ring-tx": "hardware-dma-ring-tx",
88 }
89 _DEB_CONFIG_PPPOE_OPTS = {
90     "user": "user",
91     "password": "password",
92     "provider": "provider",
93     "pppoe_iface": "pppoe_iface",
94     "noipdefault": "noipdefault",
95     "usepeerdns": "usepeerdns",
96     "defaultroute": "defaultroute",
97     "holdoff": "holdoff",
98     "maxfail": "maxfail",
99     "hide-password": "hide-password",
100     "lcp-echo-interval": "lcp-echo-interval",
101     "lcp-echo-failure": "lcp-echo-failure",
102     "connect": "connect",
103     "noauth": "noauth",
104     "persist": "persist",
105     "mtu": "mtu",
106     "noaccomp": "noaccomp",
107     "linkname": "linkname",
108 }
109 _DEB_ROUTES_FILE = "/etc/network/routes"
110 _DEB_NETWORK_FILE = "/etc/network/interfaces"
111 _DEB_NETWORK_DIR = "/etc/network/interfaces.d/"
112 _DEB_NETWORK_UP_DIR = "/etc/network/if-up.d/"
113 _DEB_NETWORK_DOWN_DIR = "/etc/network/if-down.d/"
114 _DEB_NETWORK_CONF_FILES = "/etc/modprobe.d/"
115 _DEB_NETWORKING_FILE = "/etc/default/networking"
116 _DEB_HOSTNAME_FILE = "/etc/hostname"
117 _DEB_RESOLV_FILE = "/etc/resolv.conf"
118 _DEB_PPP_DIR = "/etc/ppp/peers/"
119 _CONFIG_TRUE = ["yes", "on", "true", "1", True]
120 _CONFIG_FALSE = ["no", "off", "false", "0", False]
121 _IFACE_TYPES = [
122     "eth",
123     "bond",
124     "alias",
125     "clone",
126     "ipsec",
127     "dialup",
128     "bridge",
129     "slave",
130     "vlan",
131     "pppoe",
132     "source",
133 ]
134 def _error_msg_iface(iface, option, expected):
135     """
136     Build an appropriate error message from a given option and
137     a list of expected values.
138     """
139     msg = "Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]"
140     return msg.format(iface, option, "|".join(str(e) for e in expected))
141 def _error_msg_routes(iface, option, expected):
142     """
143     Build an appropriate error message from a given option and
144     a list of expected values.
145     """
146     msg = "Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]"
147     return msg.format(iface, option, expected)
148 def _log_default_iface(iface, opt, value):
149     log.info(
150         "Using default option -- Interface: %s Option: %s Value: %s", iface, opt, value
151     )
152 def _error_msg_network(option, expected):
153     """
154     Build an appropriate error message from a given option and
155     a list of expected values.
156     """
157     msg = "Invalid network setting -- Setting: {0}, Expected: [{1}]"
158     return msg.format(option, "|".join(str(e) for e in expected))
159 def _log_default_network(opt, value):
160     log.info("Using existing setting -- Setting: %s Value: %s", opt, value)
161 def _raise_error_iface(iface, option, expected):
162     """
163     Log and raise an error with a logical formatted message.
164     """
165     msg = _error_msg_iface(iface, option, expected)
166     log.error(msg)
167     raise AttributeError(msg)
168 def _raise_error_network(option, expected):
169     """
170     Log and raise an error with a logical formatted message.
171     """
172     msg = _error_msg_network(option, expected)
173     log.error(msg)
174     raise AttributeError(msg)
175 def _raise_error_routes(iface, option, expected):
176     """
177     Log and raise an error with a logical formatted message.
178     """
179     msg = _error_msg_routes(iface, option, expected)
180     log.error(msg)
181     raise AttributeError(msg)
182 def _read_file(path):
183     """
184     Reads and returns the contents of a text file
185     """
186     try:
187         with salt.utils.files.flopen(path, "rb") as contents:
188             return [
189                 salt.utils.stringutils.to_str(line) for line in contents.readlines()
190             ]
191     except OSError:
192         return ""
193 def _parse_resolve():
194     """
195     Parse /etc/resolv.conf
196     """
197     return salt.utils.dns.parse_resolv(_DEB_RESOLV_FILE)
198 def _parse_domainname():
199     """
200     Parse /etc/resolv.conf and return domainname
201     """
202     return _parse_resolve().get("domain", "")
203 def _parse_searchdomain():
204     """
205     Parse /etc/resolv.conf and return searchdomain
206     """
207     return _parse_resolve().get("search", "")
208 def _parse_hostname():
209     """
210     Parse /etc/hostname and return hostname
211     """
212     contents = _read_file(_DEB_HOSTNAME_FILE)
213     if contents:
214         return contents[0].split("\n")[0]
215     else:
216         return ""
217 def _parse_current_network_settings():
218     """
219     Parse /etc/default/networking and return current configuration
220     """
221     opts = salt.utils.odict.OrderedDict()
222     opts["networking"] = ""
223     if os.path.isfile(_DEB_NETWORKING_FILE):
224         with salt.utils.files.fopen(_DEB_NETWORKING_FILE) as contents:
225             for line in contents:
226                 salt.utils.stringutils.to_unicode(line)
227                 if line.startswith("#"):
228                     continue
229                 elif line.startswith("CONFIGURE_INTERFACES"):
230                     opts["networking"] = line.split("=", 1)[1].strip()
231     hostname = _parse_hostname()
232     domainname = _parse_domainname()
233     searchdomain = _parse_searchdomain()
234     opts["hostname"] = hostname
235     opts["domainname"] = domainname
236     opts["searchdomain"] = searchdomain
237     return opts
238 def __ipv4_quad(value):
239     return (salt.utils.validate.net.ipv4_addr(value), value, "dotted IPv4 address")
240 def __ipv6(value):
241     return (salt.utils.validate.net.ipv6_addr(value), value, "IPv6 address")
242 def __mac(value):
243     return (salt.utils.validate.net.mac(value), value, "MAC address")
244 def __anything(value):
245     return (True, value, None)
246 def __int(value):
247     valid, _value = False, value
248     try:
249         _value = int(value)
250         valid = True
251     except ValueError:
252         pass
253     return (valid, _value, "integer")
254 def __float(value):
255     valid, _value = False, value
256     try:
257         _value = float(value)
258         valid = True
259     except ValueError:
260         pass
261     return (valid, _value, "float")
262 def __ipv4_netmask(value):
263     valid, errmsg = False, "dotted quad or integer CIDR (0-&gt;32)"
264     valid, value, _ = __int(value)
265     if not (valid and 0 &lt;= value &lt;= 32):
266         valid = salt.utils.validate.net.netmask(value)
267     return (valid, value, errmsg)
268 def __ipv6_netmask(value):
269     valid, errmsg = False, "IPv6 netmask (0-&gt;128)"
270     valid, value, _ = __int(value)
271     valid = valid and 0 &lt;= value &lt;= 128
272     return (valid, value, errmsg)
273 def __within2(value, within=None, errmsg=None, dtype=None):
274     valid, _value = False, value
275     if dtype:
276         try:
277             _value = dtype(value)  # TODO: this is a bit loose when dtype is a class
278             valid = _value in within
279         except ValueError:
280             pass
281     else:
282         valid = _value in within
283     if errmsg is None:
284         if dtype:
285             typename = getattr(
286                 dtype,
287                 "__name__",
288                 hasattr(dtype, "__class__") and getattr(dtype.__class__, "name", dtype),
289             )
290             errmsg = "{} within '{}'".format(typename, within)
291         else:
292             errmsg = "within '{}'".format(within)
293     return (valid, _value, errmsg)
294 def __within(within=None, errmsg=None, dtype=None):
295     return functools.partial(__within2, within=within, errmsg=errmsg, dtype=dtype)
296 def __space_delimited_list(value):
297     if isinstance(value, str):
298         value = value.strip().split()
299     if hasattr(value, "__iter__") and value != []:
300         return (True, value, "space-delimited string")
301     else:
302         return (
303             False,
304             value,
305             "{} is not a valid space-delimited value.\n".format(value),
306         )
307 SALT_ATTR_TO_DEBIAN_ATTR_MAP = {
308     "dns": "dns-nameservers",
309     "search": "dns-search",
310     "hwaddr": "hwaddress",  # TODO: this limits bootp functionality
311     "ipaddr": "address",
312     "ipaddrs": "addresses",
313 }
314 DEBIAN_ATTR_TO_SALT_ATTR_MAP = {v: k for (k, v) in SALT_ATTR_TO_DEBIAN_ATTR_MAP.items()}
315 DEBIAN_ATTR_TO_SALT_ATTR_MAP["address"] = "address"
316 DEBIAN_ATTR_TO_SALT_ATTR_MAP["hwaddress"] = "hwaddress"
317 IPV4_VALID_PROTO = ["bootp", "dhcp", "static", "manual", "loopback", "ppp"]
318 IPV4_ATTR_MAP = {
319     "proto": __within(IPV4_VALID_PROTO, dtype=str),
320     "address": __ipv4_quad,
321     "addresses": __anything,
322     "netmask": __ipv4_netmask,
323     "broadcast": __ipv4_quad,
324     "metric": __int,
325     "gateway": __ipv4_quad,  # supports a colon-delimited list
326     "pointopoint": __ipv4_quad,
327     "hwaddress": __mac,
328     "mtu": __int,
329     "scope": __within(["global", "link", "host"], dtype=str),
330     "hostname": __anything,
331     "leasehours": __int,
332     "leasetime": __int,
333     "vendor": __anything,
334     "client": __anything,
335     "bootfile": __anything,
336     "server": __ipv4_quad,
337     "hwaddr": __mac,
338     "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
339     "endpoint": __ipv4_quad,
340     "dstaddr": __ipv4_quad,
341     "local": __ipv4_quad,
342     "ttl": __int,
343     "slaves": __anything,
344     "provider": __anything,
345     "unit": __int,
346     "options": __anything,
347     "dns-nameservers": __space_delimited_list,
348     "dns-search": __space_delimited_list,
349     "vlan-raw-device": __anything,
350     "network": __anything,  # i don't know what this is
351     "test": __anything,  # TODO
352     "enable_ipv4": __anything,  # TODO
353     "enable_ipv6": __anything,  # TODO
354 }
355 IPV6_VALID_PROTO = ["auto", "loopback", "static", "manual", "dhcp", "v4tunnel", "6to4"]
356 IPV6_ATTR_MAP = {
357     "proto": __within(IPV6_VALID_PROTO),
358     "address": __ipv6,
359     "addresses": __anything,
360     "netmask": __ipv6_netmask,
361     "broadcast": __ipv6,
362     "gateway": __ipv6,  # supports a colon-delimited list
363     "hwaddress": __mac,
364     "mtu": __int,
365     "scope": __within(["global", "site", "link", "host"], dtype=str),
366     "privext": __within([0, 1, 2], dtype=int),
367     "dhcp": __within([0, 1], dtype=int),
368     "media": __anything,
369     "accept_ra": __within([0, 1, 2], dtype=int),
370     "autoconf": __within([0, 1], dtype=int),
371     "preferred-lifetime": __int,
372     "dad-attempts": __int,  # 0 to disable
373     "dad-interval": __float,
374     "slaves": __anything,
375     "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
376     "endpoint": __ipv4_quad,
377     "local": __ipv4_quad,
378     "ttl": __int,
379     "dns-nameservers": __space_delimited_list,
380     "dns-search": __space_delimited_list,
381     "vlan-raw-device": __anything,
382     "test": __anything,  # TODO
383     "enable_ipv4": __anything,  # TODO
384     "enable_ipv6": __anything,  # TODO
385 }
386 WIRELESS_ATTR_MAP = {
387     "wireless-essid": __anything,
388     "wireless-mode": __anything,  # TODO
389     "wpa-ap-scan": __within([0, 1, 2], dtype=int),  # TODO
390     "wpa-conf": __anything,
391     "wpa-driver": __anything,
392     "wpa-group": __anything,
393     "wpa-key-mgmt": __anything,
394     "wpa-pairwise": __anything,
395     "wpa-psk": __anything,
396     "wpa-proto": __anything,  # partial(__within,
397     "wpa-roam": __anything,
398     "wpa-ssid": __anything,  # TODO
399 }
400 ATTRMAPS = {
401     "inet": [IPV4_ATTR_MAP, WIRELESS_ATTR_MAP],
402     "inet6": [IPV6_ATTR_MAP, WIRELESS_ATTR_MAP],
403 }
404 def _validate_interface_option(attr, value, addrfam="inet"):
405     """lookup the validation function for a [addrfam][attr] and
406     return the results
407     :param attr: attribute name
408     :param value: raw setting value
409     :param addrfam: address family (inet, inet6,
410     """
411     valid, _value, errmsg = False, value, "Unknown validator"
412     attrmaps = ATTRMAPS.get(addrfam, [])
413     for attrmap in attrmaps:
414         if attr in attrmap:
415             validate_func = attrmap[attr]
416             (valid, _value, errmsg) = validate_func(value)
417             break
418     return (valid, _value, errmsg)
419 def _attrmaps_contain_attr(attr):
420     return attr in WIRELESS_ATTR_MAP or attr in IPV4_ATTR_MAP or attr in IPV6_ATTR_MAP
421 def _parse_interfaces(interface_files=None):
422     """
423     Parse /etc/network/interfaces and return current configured interfaces
424     """
425     if interface_files is None:
426         interface_files = []
427         if os.path.exists(_DEB_NETWORK_DIR):
428             interface_files += [
429                 "{}/{}".format(_DEB_NETWORK_DIR, dir)
430                 for dir in os.listdir(_DEB_NETWORK_DIR)
431             ]
432         if os.path.isfile(_DEB_NETWORK_FILE):
433             interface_files.insert(0, _DEB_NETWORK_FILE)
434     adapters = salt.utils.odict.OrderedDict()
435     method = -1
436     for interface_file in interface_files:
437         with salt.utils.files.fopen(interface_file) as interfaces:
438             iface_dict = {}
439             for line in interfaces:
440                 line = salt.utils.stringutils.to_unicode(line)
441                 if line.lstrip().startswith("#") or line.isspace():
442                     continue
443                 if line.startswith("iface"):
444                     sline = line.split()
445                     if len(sline) != 4:
446                         msg = "Interface file malformed: {0}."
447                         msg = msg.format(sline)
448                         log.error(msg)
449                         raise AttributeError(msg)
450                     iface_name = sline[1]
451                     addrfam = sline[2]
452                     method = sline[3]
453                     if iface_name not in adapters:
454                         adapters[iface_name] = salt.utils.odict.OrderedDict()
455                     if "data" not in adapters[iface_name]:
456                         adapters[iface_name]["data"] = salt.utils.odict.OrderedDict()
457                     if addrfam not in adapters[iface_name]["data"]:
458                         adapters[iface_name]["data"][
459                             addrfam
460                         ] = salt.utils.odict.OrderedDict()
461                     iface_dict = adapters[iface_name]["data"][addrfam]
462                     iface_dict["addrfam"] = addrfam
463                     iface_dict["proto"] = method
464                     iface_dict["filename"] = interface_file
465                 elif line[0].isspace():
466                     sline = line.split()
467                     attr, valuestr = line.rstrip().split(None, 1)
468                     if _attrmaps_contain_attr(attr):
469                         if "-" in attr:
470                             attrname = attr.replace("-", "_")
471                         else:
472                             attrname = attr
473                         (valid, value, errmsg) = _validate_interface_option(
474                             attr, valuestr, addrfam
475                         )
476                         if attrname == "address" and "address" in iface_dict:
477                             if "addresses" not in iface_dict:
478                                 iface_dict["addresses"] = []
479                             iface_dict["addresses"].append(value)
480                         else:
481                             iface_dict[attrname] = value
482                     elif attr in _REV_ETHTOOL_CONFIG_OPTS:
483                         if "ethtool" not in iface_dict:
484                             iface_dict["ethtool"] = salt.utils.odict.OrderedDict()
485                         iface_dict["ethtool"][attr] = valuestr
486                     elif attr.startswith("bond"):
487                         opt = re.split(r"[_-]", attr, maxsplit=1)[1]
488                         if "bonding" not in iface_dict:
489                             iface_dict["bonding"] = salt.utils.odict.OrderedDict()
490                         iface_dict["bonding"][opt] = valuestr
491                     elif attr.startswith("bridge"):
492                         opt = re.split(r"[_-]", attr, maxsplit=1)[1]
493                         if "bridging" not in iface_dict:
494                             iface_dict["bridging"] = salt.utils.odict.OrderedDict()
495                         iface_dict["bridging"][opt] = valuestr
496                     elif attr in [
497                         "up",
498                         "pre-up",
499                         "post-up",
500                         "down",
501                         "pre-down",
502                         "post-down",
503                     ]:
504                         cmd = valuestr
505                         cmd_key = "{}_cmds".format(re.sub("-", "_", attr))
506                         if cmd_key not in iface_dict:
507                             iface_dict[cmd_key] = []
508                         iface_dict[cmd_key].append(cmd)
509                 elif line.startswith("auto"):
510                     for word in line.split()[1:]:
511                         if word not in adapters:
512                             adapters[word] = salt.utils.odict.OrderedDict()
513                         adapters[word]["enabled"] = True
514                 elif line.startswith("allow-hotplug"):
515                     for word in line.split()[1:]:
516                         if word not in adapters:
517                             adapters[word] = salt.utils.odict.OrderedDict()
518                         adapters[word]["hotplug"] = True
519                 elif line.startswith("source"):
520                     if "source" not in adapters:
521                         adapters["source"] = salt.utils.odict.OrderedDict()
522                     if "data" not in adapters["source"]:
523                         adapters["source"]["data"] = salt.utils.odict.OrderedDict()
524                         adapters["source"]["data"]["sources"] = []
525                     adapters["source"]["data"]["sources"].append(line.split()[1])
526     adapters = _filter_malformed_interfaces(adapters=adapters)
527     return adapters
528 def _filter_malformed_interfaces(*, adapters):
529     for iface_name in list(adapters):
530         if iface_name == "source":
531             continue
532         if "data" not in adapters[iface_name]:
533             msg = "Interface file malformed for interface: {}.".format(iface_name)
534             log.error(msg)
535             adapters.pop(iface_name)
536             continue
537         for opt in ["ethtool", "bonding", "bridging"]:
538             for inet in ["inet", "inet6"]:
539                 if inet in adapters[iface_name]["data"]:
540                     if opt in adapters[iface_name]["data"][inet]:
541                         opt_keys = sorted(
542                             adapters[iface_name]["data"][inet][opt].keys()
543                         )
544                         adapters[iface_name]["data"][inet][opt + "_keys"] = opt_keys
545     return adapters
546 def _parse_ethtool_opts(opts, iface):
547     """
548     Filters given options and outputs valid settings for ETHTOOLS_OPTS
549     If an option has a value that is not expected, this
550     function will log what the Interface, Setting and what it was
551     expecting.
552     """
553     config = {}
554     if "autoneg" in opts:
555         if opts["autoneg"] in _CONFIG_TRUE:
556             config.update({"autoneg": "on"})
557         elif opts["autoneg"] in _CONFIG_FALSE:
558             config.update({"autoneg": "off"})
559         else:
560             _raise_error_iface(iface, "autoneg", _CONFIG_TRUE + _CONFIG_FALSE)
561     if "duplex" in opts:
562         valid = ["full", "half"]
563         if opts["duplex"] in valid:
564             config.update({"duplex": opts["duplex"]})
565         else:
566             _raise_error_iface(iface, "duplex", valid)
567     if "speed" in opts:
568         valid = ["10", "100", "1000", "10000"]
569         if str(opts["speed"]) in valid:
570             config.update({"speed": opts["speed"]})
571         else:
572             _raise_error_iface(iface, opts["speed"], valid)
573     valid = _CONFIG_TRUE + _CONFIG_FALSE
574     for option in ("rx", "tx", "sg", "tso", "ufo", "gso", "gro", "lro"):
575         if option in opts:
576             if opts[option] in _CONFIG_TRUE:
577                 config.update({option: "on"})
578             elif opts[option] in _CONFIG_FALSE:
579                 config.update({option: "off"})
580             else:
581                 _raise_error_iface(iface, option, valid)
582     return config
583 def _parse_ethtool_pppoe_opts(opts, iface):
584     """
585     Filters given options and outputs valid settings for ETHTOOLS_PPPOE_OPTS
586     If an option has a value that is not expected, this
587     function will log what the Interface, Setting and what it was
588     expecting.
589     """
590     config = {}
591     for opt in _DEB_CONFIG_PPPOE_OPTS:
592         if opt in opts:
593             config[opt] = opts[opt]
594     if "provider" in opts and not opts["provider"]:
595         _raise_error_iface(iface, "provider", _CONFIG_TRUE + _CONFIG_FALSE)
596     valid = _CONFIG_TRUE + _CONFIG_FALSE
597     for option in (
598         "noipdefault",
599         "usepeerdns",
600         "defaultroute",
601         "hide-password",
602         "noauth",
603         "persist",
604         "noaccomp",
605     ):
606         if option in opts:
607             if opts[option] in _CONFIG_TRUE:
608                 config.update({option: "True"})
609             elif opts[option] in _CONFIG_FALSE:
610                 config.update({option: "False"})
611             else:
612                 _raise_error_iface(iface, option, valid)
613     return config
614 def _parse_settings_bond(opts, iface):
615     """
616     Filters given options and outputs valid settings for requested
617     operation. If an option has a value that is not expected, this
618     function will log what the Interface, Setting and what it was
619     expecting.
620     """
621     bond_def = {
622         "ad_select": "0",
623         "tx_queues": "16",
624         "miimon": "100",
625         "arp_interval": "250",
626         "downdelay": "200",
627         "lacp_rate": "0",
628         "max_bonds": "1",
629         "updelay": "0",
630         "use_carrier": "on",
631         "xmit_hash_policy": "layer2",
632     }
633     if opts["mode"] in ["balance-rr", "0"]:
634         log.info("Device: %s Bonding Mode: load balancing (round-robin)", iface)
635         return _parse_settings_bond_0(opts, iface, bond_def)
636     elif opts["mode"] in ["active-backup", "1"]:
637         log.info("Device: %s Bonding Mode: fault-tolerance (active-backup)", iface)
638         return _parse_settings_bond_1(opts, iface, bond_def)
639     elif opts["mode"] in ["balance-xor", "2"]:
640         log.info("Device: %s Bonding Mode: load balancing (xor)", iface)
641         return _parse_settings_bond_2(opts, iface, bond_def)
642     elif opts["mode"] in ["broadcast", "3"]:
643         log.info("Device: %s Bonding Mode: fault-tolerance (broadcast)", iface)
644         return _parse_settings_bond_3(opts, iface, bond_def)
645     elif opts["mode"] in ["802.3ad", "4"]:
646         log.info(
647             "Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation", iface
648         )
649         return _parse_settings_bond_4(opts, iface, bond_def)
650     elif opts["mode"] in ["balance-tlb", "5"]:
651         log.info("Device: %s Bonding Mode: transmit load balancing", iface)
652         return _parse_settings_bond_5(opts, iface, bond_def)
653     elif opts["mode"] in ["balance-alb", "6"]:
654         log.info("Device: %s Bonding Mode: adaptive load balancing", iface)
655         return _parse_settings_bond_6(opts, iface, bond_def)
656     else:
657         valid = [
658             "0",
659             "1",
660             "2",
661             "3",
662             "4",
663             "5",
664             "6",
665             "balance-rr",
666             "active-backup",
667             "balance-xor",
668             "broadcast",
669             "802.3ad",
670             "balance-tlb",
671             "balance-alb",
672         ]
673         _raise_error_iface(iface, "mode", valid)
674 def _parse_settings_bond_0(opts, iface, bond_def):
675     """
676     Filters given options and outputs valid settings for bond0.
677     If an option has a value that is not expected, this
678     function will log what the Interface, Setting and what it was
679     expecting.
680     """
681     bond = {"mode": "0"}
682     valid = ["list of ips (up to 16)"]
683     if "arp_ip_target" in opts:
684         if isinstance(opts["arp_ip_target"], list):
685             if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
686                 bond.update({"arp_ip_target": ""})
687                 for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
688                     if len(bond["arp_ip_target"]) &gt; 0:
689                         bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
690                     else:
691                         bond["arp_ip_target"] = ip
692             else:
693                 _raise_error_iface(iface, "arp_ip_target", valid)
694         else:
695             _raise_error_iface(iface, "arp_ip_target", valid)
696     else:
697         _raise_error_iface(iface, "arp_ip_target", valid)
698     if "arp_interval" in opts:
699         try:
700             int(opts["arp_interval"])
701             bond.update({"arp_interval": opts["arp_interval"]})
702         except ValueError:
703             _raise_error_iface(iface, "arp_interval", ["integer"])
704     else:
705         _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
706         bond.update({"arp_interval": bond_def["arp_interval"]})
707     return bond
708 def _parse_settings_bond_1(opts, iface, bond_def):
709     """
710     Filters given options and outputs valid settings for bond1.
711     If an option has a value that is not expected, this
712     function will log what the Interface, Setting and what it was
713     expecting.
714     """
715     bond = {"mode": "1"}
716     for binding in ["miimon", "downdelay", "updelay"]:
717         if binding in opts:
718             try:
719                 int(opts[binding])
720                 bond.update({binding: opts[binding]})
721             except ValueError:
722                 _raise_error_iface(iface, binding, ["integer"])
723         else:
724             _log_default_iface(iface, binding, bond_def[binding])
725             bond.update({binding: bond_def[binding]})
726     if "primary" in opts:
727         bond.update({"primary": opts["primary"]})
728     if not (__grains__["os"] == "Ubuntu" and __grains__["osrelease_info"][0] &gt;= 16):
729         if "use_carrier" in opts:
730             if opts["use_carrier"] in _CONFIG_TRUE:
731                 bond.update({"use_carrier": "1"})
732             elif opts["use_carrier"] in _CONFIG_FALSE:
733                 bond.update({"use_carrier": "0"})
734             else:
735                 valid = _CONFIG_TRUE + _CONFIG_FALSE
736                 _raise_error_iface(iface, "use_carrier", valid)
737         else:
738             _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
739             bond.update({"use_carrier": bond_def["use_carrier"]})
740     return bond
741 def _parse_settings_bond_2(opts, iface, bond_def):
742     """
743     Filters given options and outputs valid settings for bond2.
744     If an option has a value that is not expected, this
745     function will log what the Interface, Setting and what it was
746     expecting.
747     """
748     bond = {"mode": "2"}
749     valid = ["list of ips (up to 16)"]
750     if "arp_ip_target" in opts:
751         if isinstance(opts["arp_ip_target"], list):
752             if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
753                 bond.update({"arp_ip_target": ""})
754                 for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
755                     if len(bond["arp_ip_target"]) &gt; 0:
756                         bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
757                     else:
758                         bond["arp_ip_target"] = ip
759             else:
760                 _raise_error_iface(iface, "arp_ip_target", valid)
761         else:
762             _raise_error_iface(iface, "arp_ip_target", valid)
763     else:
764         _raise_error_iface(iface, "arp_ip_target", valid)
765     if "arp_interval" in opts:
766         try:
767             int(opts["arp_interval"])
768             bond.update({"arp_interval": opts["arp_interval"]})
769         except ValueError:
770             _raise_error_iface(iface, "arp_interval", ["integer"])
771     else:
772         _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
773         bond.update({"arp_interval": bond_def["arp_interval"]})
774     if "hashing-algorithm" in opts:
775         valid = ["layer2", "layer2+3", "layer3+4"]
776         if opts["hashing-algorithm"] in valid:
777             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
778         else:
779             _raise_error_iface(iface, "hashing-algorithm", valid)
780     return bond
781 def _parse_settings_bond_3(opts, iface, bond_def):
782     """
783     Filters given options and outputs valid settings for bond3.
784     If an option has a value that is not expected, this
785     function will log what the Interface, Setting and what it was
786     expecting.
787     """
788     bond = {"mode": "3"}
789     for binding in ["miimon", "downdelay", "updelay"]:
790         if binding in opts:
791             try:
792                 int(opts[binding])
793                 bond.update({binding: opts[binding]})
794             except ValueError:
795                 _raise_error_iface(iface, binding, ["integer"])
796         else:
797             _log_default_iface(iface, binding, bond_def[binding])
798             bond.update({binding: bond_def[binding]})
799     if "use_carrier" in opts:
800         if opts["use_carrier"] in _CONFIG_TRUE:
801             bond.update({"use_carrier": "1"})
802         elif opts["use_carrier"] in _CONFIG_FALSE:
803             bond.update({"use_carrier": "0"})
804         else:
805             valid = _CONFIG_TRUE + _CONFIG_FALSE
806             _raise_error_iface(iface, "use_carrier", valid)
807     else:
808         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
809         bond.update({"use_carrier": bond_def["use_carrier"]})
810     return bond
811 def _parse_settings_bond_4(opts, iface, bond_def):
812     """
813     Filters given options and outputs valid settings for bond4.
814     If an option has a value that is not expected, this
815     function will log what the Interface, Setting and what it was
816     expecting.
817     """
818     bond = {"mode": "4"}
819     for binding in ["miimon", "downdelay", "updelay", "lacp_rate", "ad_select"]:
820         if binding in opts:
821             if binding == "lacp_rate":
822                 if opts[binding] == "fast":
823                     opts.update({binding: "1"})
824                 if opts[binding] == "slow":
825                     opts.update({binding: "0"})
826                 valid = ["fast", "1", "slow", "0"]
827             else:
828                 valid = ["integer"]
829             try:
830                 int(opts[binding])
831                 bond.update({binding: opts[binding]})
832             except ValueError:
833                 _raise_error_iface(iface, binding, valid)
834         else:
835             _log_default_iface(iface, binding, bond_def[binding])
836             bond.update({binding: bond_def[binding]})
837     if "use_carrier" in opts:
838         if opts["use_carrier"] in _CONFIG_TRUE:
839             bond.update({"use_carrier": "1"})
840         elif opts["use_carrier"] in _CONFIG_FALSE:
841             bond.update({"use_carrier": "0"})
842         else:
843             valid = _CONFIG_TRUE + _CONFIG_FALSE
844             _raise_error_iface(iface, "use_carrier", valid)
845     else:
846         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
847         bond.update({"use_carrier": bond_def["use_carrier"]})
848     if "hashing-algorithm" in opts:
849         valid = ["layer2", "layer2+3", "layer3+4"]
850         if opts["hashing-algorithm"] in valid:
851             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
852         else:
853             _raise_error_iface(iface, "hashing-algorithm", valid)
854     return bond
855 def _parse_settings_bond_5(opts, iface, bond_def):
856     """
857     Filters given options and outputs valid settings for bond5.
858     If an option has a value that is not expected, this
859     function will log what the Interface, Setting and what it was
860     expecting.
861     """
862     bond = {"mode": "5"}
863     for binding in ["miimon", "downdelay", "updelay"]:
864         if binding in opts:
865             try:
866                 int(opts[binding])
867                 bond.update({binding: opts[binding]})
868             except ValueError:
869                 _raise_error_iface(iface, binding, ["integer"])
870         else:
871             _log_default_iface(iface, binding, bond_def[binding])
872             bond.update({binding: bond_def[binding]})
873     if "use_carrier" in opts:
874         if opts["use_carrier"] in _CONFIG_TRUE:
875             bond.update({"use_carrier": "1"})
876         elif opts["use_carrier"] in _CONFIG_FALSE:
877             bond.update({"use_carrier": "0"})
878         else:
879             valid = _CONFIG_TRUE + _CONFIG_FALSE
880             _raise_error_iface(iface, "use_carrier", valid)
881     else:
882         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
883         bond.update({"use_carrier": bond_def["use_carrier"]})
884     if "primary" in opts:
885         bond.update({"primary": opts["primary"]})
886     return bond
887 def _parse_settings_bond_6(opts, iface, bond_def):
888     """
889     Filters given options and outputs valid settings for bond6.
890     If an option has a value that is not expected, this
891     function will log what the Interface, Setting and what it was
892     expecting.
893     """
894     bond = {"mode": "6"}
895     for binding in ["miimon", "downdelay", "updelay"]:
896         if binding in opts:
897             try:
898                 int(opts[binding])
899                 bond.update({binding: opts[binding]})
900             except ValueError:
901                 _raise_error_iface(iface, binding, ["integer"])
902         else:
903             _log_default_iface(iface, binding, bond_def[binding])
904             bond.update({binding: bond_def[binding]})
905     if "use_carrier" in opts:
906         if opts["use_carrier"] in _CONFIG_TRUE:
907             bond.update({"use_carrier": "1"})
908         elif opts["use_carrier"] in _CONFIG_FALSE:
909             bond.update({"use_carrier": "0"})
910         else:
911             valid = _CONFIG_TRUE + _CONFIG_FALSE
912             _raise_error_iface(iface, "use_carrier", valid)
913     else:
914         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
915         bond.update({"use_carrier": bond_def["use_carrier"]})
916     if "primary" in opts:
917         bond.update({"primary": opts["primary"]})
918     return bond
919 def _parse_bridge_opts(opts, iface):
920     """
921     Filters given options and outputs valid settings for BRIDGING_OPTS
922     If an option has a value that is not expected, this
923     function will log the Interface, Setting and what was expected.
924     """
925     config = {}
926     if "ports" in opts:
927         if isinstance(opts["ports"], list):
928             opts["ports"] = " ".join(opts["ports"])
929         config.update({"ports": opts["ports"]})
930     for opt in ["ageing", "fd", "gcint", "hello", "maxage"]:
931         if opt in opts:
932             try:
933                 float(opts[opt])
934                 config.update({opt: opts[opt]})
935             except ValueError:
936                 _raise_error_iface(iface, opt, ["float"])
937     for opt in ["bridgeprio", "maxwait"]:
938         if opt in opts:
939             if isinstance(opts[opt], int):
940                 config.update({opt: opts[opt]})
941             else:
942                 _raise_error_iface(iface, opt, ["integer"])
943     if "hw" in opts:
944         if re.match(
945             "[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", opts["hw"].lower()
946         ):
947             config.update({"hw": opts["hw"]})
948         else:
949             _raise_error_iface(iface, "hw", ["valid MAC address"])
950     for opt in ["pathcost", "portprio"]:
951         if opt in opts:
952             try:
953                 port, cost_or_prio = opts[opt].split()
954                 int(cost_or_prio)
955                 config.update({opt: "{} {}".format(port, cost_or_prio)})
956             except ValueError:
957                 _raise_error_iface(iface, opt, ["interface integer"])
958     if "stp" in opts:
959         if opts["stp"] in _CONFIG_TRUE:
960             config.update({"stp": "on"})
961         elif opts["stp"] in _CONFIG_FALSE:
962             config.update({"stp": "off"})
963         else:
964     if "waitport" in opts:
965         if isinstance(opts<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["waitport"], int):
966             config.update({"waitport": opts["waitport"]})
967         else:
968             values = opts["waitport"].split()
969             waitport_time = values.pop(</b></font>0)
970             if waitport_time.isdigit() and values:
971                 config.update(
972                     {"waitport": "{} {}".format(waitport_time, " ".join(values))}
973                 )
974             else:
975                 _raise_error_iface(iface, opt, ["integer [interfaces]"])
976     return config
977 def _parse_settings_eth(opts, iface_type, enabled, iface):
978     """
979     Filters given options and outputs valid settings for a
980     network interface.
981     """
982     adapters = salt.utils.odict.OrderedDict()
983     adapters[iface] = salt.utils.odict.OrderedDict()
984     adapters[iface]["type"] = iface_type
985     adapters[iface]["data"] = salt.utils.odict<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.OrderedDict()
986     iface_data = adapters[iface]["data"]
987     iface_data["inet"] = salt.utils.odict.OrderedDict()
988     iface_data["inet6"] = salt.</b></font>utils.odict.OrderedDict()
989     if enabled:
990         adapters[iface]["enabled"] = True
991     if opts.get("hotplug", False):
992         adapters[iface]["hotplug"] = True
993     if opts.get("enable_ipv6", None) and opts.get("iface_type", "") == "vlan":
994         iface_data["inet6"]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
995     for addrfam in ["inet", "inet6"]:
996         if iface_type not in ["bridge"]:
997             tmp_ethtool = _parse_ethtool_opts(opts, iface)
998             if tmp_ethtool:
999                 ethtool = {}
1000                 for item in tmp_ethtool:
1001                     ethtool[_ETHTOOL_CONFIG_OPTS[item]] = tmp_ethtool[item]
1002                 iface_data[addrfam]["ethtool"] = ethtool
1003                 iface_data[addrfam]["ethtool_keys"] = sorted(ethtool)
1004         if iface_type == "bridge":
1005             bridging = _parse_bridge_opts(opts, iface)
1006             if bridging:
1007                 iface_data[addrfam]["bridging"] = bridging
1008                 iface_data[addrfam]["bridging_keys"] = sorted(bridging)
1009                 iface_data[addrfam]["addrfam"] = addrfam
1010         elif iface_type == "bond":
1011             bonding = _parse_settings_bond(opts, iface)
1012             if bonding:
1013                 iface_data[addrfam]["bonding"] = bonding
1014                 iface_data[addrfam]["bonding"]["slaves"] = opts["slaves"]
1015                 iface_data[addrfam]["bonding_keys"] = sorted(bonding)
1016                 iface_data[addrfam]["addrfam"] = addrfam
1017         elif iface_type == "slave":
1018             adapters[iface]["master"] = opts["master"]
1019             opts["proto"] = "manual"
1020             iface_data[addrfam]["master"] = adapters[iface]["master"]
1021             iface_data[addrfam]["addrfam"] = addrfam
1022         elif iface_type == "vlan":
1023             iface_data[addrfam]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
1024             iface_data[addrfam]["addrfam"] = addrfam
1025         elif iface_type == "pppoe":
1026             tmp_ethtool = _parse_ethtool_pppoe_opts(opts, iface)
1027             if tmp_ethtool:
1028                 for item in tmp_ethtool:
1029                     adapters[iface]["data"][addrfam][
1030                         _DEB_CONFIG_PPPOE_OPTS[item]
1031                     ] = tmp_ethtool[item]
1032             iface_data[addrfam]["addrfam"] = addrfam
1033     opts.pop("mode", None)
1034     for opt, val in opts.items():
1035         inet = None
1036         if opt.startswith("ipv4"):
1037             opt = opt[4:]
1038             inet = "inet"
1039             iface_data["inet"]["addrfam"] = "inet"
1040         elif opt.startswith("ipv6"):
1041             iface_data["inet6"]["addrfam"] = "inet6"
1042             opt = opt[4:]
1043             inet = "inet6"
1044         elif opt in [
1045             "ipaddr",
1046             "address",
1047             "ipaddresses",
1048             "addresses",
1049             "gateway",
1050             "proto",
1051         ]:
1052             iface_data["inet"]["addrfam"] = "inet"
1053             inet = "inet"
1054         _opt = SALT_ATTR_TO_DEBIAN_ATTR_MAP.get(opt, opt)
1055         _debopt = _opt.replace("-", "_")
1056         for addrfam in ["inet", "inet6"]:
1057             (valid, value, errmsg) = _validate_interface_option(
1058                 _opt, val, addrfam=addrfam
1059             )
1060             if not valid:
1061                 continue
1062             if inet is None and _debopt not in iface_data[addrfam]:
1063                 iface_data[addrfam][_debopt] = value
1064             elif inet == addrfam:
1065                 iface_data[addrfam][_debopt] = value
1066     for opt in [
1067         "up_cmds",
1068         "pre_up_cmds",
1069         "post_up_cmds",
1070         "down_cmds",
1071         "pre_down_cmds",
1072         "post_down_cmds",
1073     ]:
1074         if opt in opts:
1075             iface_data["inet"][opt] = opts[opt]
1076             iface_data["inet6"][opt] = opts[opt]
1077     for (addrfam, opt) in [("inet", "enable_ipv4"), ("inet6", "enable_ipv6")]:
1078         if opts.get(opt, None) is False:
1079             iface_data.pop(addrfam)
1080         elif iface_data[addrfam].get("addrfam", "") != addrfam:
1081             iface_data.pop(addrfam)
1082     return adapters
1083 def _parse_settings_source(opts, iface_type, enabled, iface):
1084     """
1085     Filters given options and outputs valid settings for a
1086     network interface.
1087     """
1088     adapters = salt.utils.odict.OrderedDict()
1089     adapters[iface] = salt.utils.odict.OrderedDict()
1090     adapters[iface]["type"] = iface_type
1091     adapters[iface]["data"] = salt.utils.odict.OrderedDict()
1092     iface_data = adapters[iface]["data"]
1093     iface_data["sources"] = [opts["source"]]
1094     return adapters
1095 def _parse_network_settings(opts, current):
1096     """
1097     Filters given options and outputs valid settings for
1098     the global network settings file.
1099     """
1100     opts = {k.lower(): v for (k, v) in opts.items()}
1101     current = {k.lower(): v for (k, v) in current.items()}
1102     result = {}
1103     valid = _CONFIG_TRUE + _CONFIG_FALSE
1104     if "enabled" not in opts:
1105         try:
1106             opts["networking"] = current["networking"]
1107             _log_default_network("networking", current["networking"])
1108         except ValueError:
1109             _raise_error_network("networking", valid)
1110     else:
1111         opts["networking"] = opts["enabled"]
1112     if opts["networking"] in valid:
1113         if opts["networking"] in _CONFIG_TRUE:
1114             result["networking"] = "yes"
1115         elif opts["networking"] in _CONFIG_FALSE:
1116             result["networking"] = "no"
1117     else:
1118         _raise_error_network("networking", valid)
1119     if "hostname" not in opts:
1120         try:
1121             opts["hostname"] = current["hostname"]
1122             _log_default_network("hostname", current["hostname"])
1123         except ValueError:
1124             _raise_error_network("hostname", ["server1.example.com"])
1125     if opts["hostname"]:
1126         result["hostname"] = opts["hostname"]
1127     else:
1128         _raise_error_network("hostname", ["server1.example.com"])
1129     if "search" in opts:
1130         result["search"] = opts["search"]
1131     return result
1132 def _parse_routes(iface, opts):
1133     """
1134     Filters given options and outputs valid settings for
1135     the route settings file.
1136     """
1137     opts = {k.lower(): v for (k, v) in opts.items()}
1138     result = {}
1139     if "routes" not in opts:
1140         _raise_error_routes(iface, "routes", "List of routes")
1141     for opt in opts:
1142         result[opt] = opts[opt]
1143     return result
1144 def _write_file(iface, data, folder, pattern):
1145     """
1146     Writes a file to disk
1147     """
1148     filename = os.path.join(folder, pattern.format(iface))
1149     if not os.path.exists(folder):
1150         msg = "{0} cannot be written. {1} does not exist"
1151         msg = msg.format(filename, folder)
1152         log.error(msg)
1153         raise AttributeError(msg)
1154     with salt.utils.files.flopen(filename, "w") as fout:
1155         fout.write(salt.utils.stringutils.to_str(data))
1156     return filename
1157 def _write_file_routes(iface, data, folder, pattern):
1158     """
1159     Writes a file to disk
1160     """
1161     iface = iface.replace(".", "_")
1162     filename = os.path.join(folder, pattern.format(iface))
1163     if not os.path.exists(folder):
1164         msg = "{0} cannot be written. {1} does not exist"
1165         msg = msg.format(filename, folder)
1166         log.error(msg)
1167         raise AttributeError(msg)
1168     with salt.utils.files.flopen(filename, "w") as fout:
1169         fout.write(salt.utils.stringutils.to_str(data))
1170     __salt__["file.set_mode"](filename, "0755")
1171     return filename
1172 def _write_file_network(data, filename, create=False):
1173     """
1174     Writes a file to disk
1175     If file does not exist, only create if create
1176     argument is True
1177     """
1178     if not os.path.exists(filename) and not create:
1179         msg = "{0} cannot be written. {0} does not exist and create is setto False".format(
1180             filename
1181         )
1182         log.error(msg)
1183         raise AttributeError(msg)
1184     with salt.utils.files.flopen(filename, "w") as fout:
1185         fout.write(salt.utils.stringutils.to_str(data))
1186 def _read_temp(data):
1187     """
1188     Return what would be written to disk
1189     """
1190     tout = io.StringIO()
1191     tout.write(data)
1192     tout.seek(0)
1193     output = tout.readlines()
1194     tout.close()
1195     return output
1196 def _read_temp_ifaces(iface, data):
1197     """
1198     Return what would be written to disk for interfaces
1199     """
1200     try:
1201         template = JINJA.get_template("debian_eth.jinja")
1202     except jinja2.exceptions.TemplateNotFound:
1203         log.error("Could not load template debian_eth.jinja")
1204         return ""
1205     ifcfg = template.render({"name": iface, "data": data})
1206     return [item + "\n" for item in ifcfg.split("\n")]
1207 def _write_file_ifaces(iface, data, **settings):
1208     """
1209     Writes a file to disk
1210     """
1211     try:
1212         eth_template = JINJA.get_template("debian_eth.jinja")
1213         source_template = JINJA.get_template("debian_source.jinja")
1214     except jinja2.exceptions.TemplateNotFound:
1215         log.error("Could not load template debian_eth.jinja")
1216         return ""
1217     adapters = _parse_interfaces()
1218     adapters[iface] = data
1219     ifcfg = ""
1220     for adapter in adapters:
1221         if "type" in adapters[adapter] and adapters[adapter]["type"] == "source":
1222             tmp = source_template.render({"name": adapter, "data": adapters[adapter]})
1223         else:
1224             tmp = eth_template.render({"name": adapter, "data": adapters[adapter]})
1225         ifcfg = ifcfg + tmp
1226         if adapter == iface:
1227             saved_ifcfg = tmp
1228     _SEPARATE_FILE = False
1229     if "filename" in settings:
1230         if not settings["filename"].startswith("/"):
1231             filename = "{}/{}".format(_DEB_NETWORK_DIR, settings["filename"])
1232         else:
1233             filename = settings["filename"]
1234         _SEPARATE_FILE = True
1235     else:
1236         if "filename" in adapters[adapter]["data"]:
1237             filename = adapters[adapter]["data"]
1238         else:
1239             filename = _DEB_NETWORK_FILE
1240     if not os.path.exists(os.path.dirname(filename)):
1241         msg = "{0} cannot be written."
1242         msg = msg.format(os.path.dirname(filename))
1243         log.error(msg)
1244         raise AttributeError(msg)
1245     with salt.utils.files.flopen(filename, "w") as fout:
1246         if _SEPARATE_FILE:
1247             fout.write(salt.utils.stringutils.to_str(saved_ifcfg))
1248         else:
1249             fout.write(salt.utils.stringutils.to_str(ifcfg))
1250     return saved_ifcfg.split("\n")
1251 def _write_file_ppp_ifaces(iface, data):
1252     """
1253     Writes a file to disk
1254     """
1255     try:
1256         template = JINJA.get_template("debian_ppp_eth.jinja")
1257     except jinja2.exceptions.TemplateNotFound:
1258         log.error("Could not load template debian_ppp_eth.jinja")
1259         return ""
1260     adapters = _parse_interfaces()
1261     adapters[iface] = data
1262     ifcfg = ""
1263     tmp = template.render({"data": adapters[iface]})
1264     ifcfg = tmp + ifcfg
1265     filename = _DEB_PPP_DIR + "/" + adapters[iface]["data"]["inet"]["provider"]
1266     if not os.path.exists(os.path.dirname(filename)):
1267         msg = "{0} cannot be written."
1268         msg = msg.format(os.path.dirname(filename))
1269         log.error(msg)
1270         raise AttributeError(msg)
1271     with salt.utils.files.fopen(filename, "w") as fout:
1272         fout.write(salt.utils.stringutils.to_str(ifcfg))
1273     return filename
1274 def build_bond(iface, **settings):
1275     """
1276     Create a bond script in /etc/modprobe.d with the passed settings
1277     and load the bonding kernel module.
1278     CLI Example:
1279     .. code-block:: bash
1280         salt '*' ip.build_bond bond0 mode=balance-alb
1281     """
1282     deb_major = __grains__["osrelease"][:1]
1283     opts = _parse_settings_bond(settings, iface)
1284     try:
1285         template = JINJA.get_template("conf.jinja")
1286     except jinja2.exceptions.TemplateNotFound:
1287         log.error("Could not load template conf.jinja")
1288         return ""
1289     data = template.render({"name": iface, "bonding": opts})
1290     if "test" in settings and settings["test"]:
1291         return _read_temp(data)
1292     _write_file(iface, data, _DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1293     path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1294     if deb_major == "5":
1295         for line_type in ("alias", "options"):
1296             cmd = [
1297                 "sed",
1298                 "-i",
1299                 "-e",
1300                 r"/^{}\s{}.*/d".format(line_type, iface),
1301                 "/etc/modprobe.conf",
1302             ]
1303             __salt__["cmd.run"](cmd, python_shell=False)
1304         __salt__["file.append"]("/etc/modprobe.conf", path)
1305     __salt__["kmod.load"]("bonding")
1306     __salt__["pkg.install"]("ifenslave")
1307     return _read_file(path)
1308 def build_interface(iface, iface_type, enabled, **settings):
1309     """
1310     Build an interface script for a network interface.
1311     CLI Example:
1312     .. code-block:: bash
1313         salt '*' ip.build_interface eth0 eth &lt;settings&gt;
1314     """
1315     iface_type = iface_type.lower()
1316     if iface_type not in _IFACE_TYPES:
1317         _raise_error_iface(iface, iface_type, _IFACE_TYPES)
1318     if iface_type == "slave":
1319         settings["slave"] = "yes"
1320         if "master" not in settings:
1321             msg = "master is a required setting for slave interfaces"
1322             log.error(msg)
1323             raise AttributeError(msg)
1324     elif iface_type == "vlan":
1325         settings["vlan"] = "yes"
1326         __salt__["pkg.install"]("vlan")
1327     elif iface_type == "pppoe":
1328         settings["pppoe"] = "yes"
1329         if not __salt__["pkg.version"]("ppp"):
1330             inst = __salt__["pkg.install"]("ppp")
1331     elif iface_type == "bond":
1332         if "slaves" not in settings:
1333             msg = "slaves is a required setting for bond interfaces"
1334             log.error(msg)
1335             raise AttributeError(msg)
1336     elif iface_type == "bridge":
1337         if "ports" not in settings:
1338             msg = (
1339                 "ports is a required setting for bridge interfaces on Debian "
1340                 "or Ubuntu based systems"
1341             )
1342             log.error(msg)
1343             raise AttributeError(msg)
1344         __salt__["pkg.install"]("bridge-utils")
1345     if iface_type in ["eth", "bond", "bridge", "slave", "vlan", "pppoe"]:
1346         opts = _parse_settings_eth(settings, iface_type, enabled, iface)
1347     if iface_type in ["source"]:
1348         opts = _parse_settings_source(settings, iface_type, enabled, iface)
1349     if "test" in settings and settings["test"]:
1350         return _read_temp_ifaces(iface, opts[iface])
1351     ifcfg = _write_file_ifaces(iface, opts[iface], **settings)
1352     if iface_type == "pppoe":
1353         _write_file_ppp_ifaces(iface, opts[iface])
1354     return [item + "\n" for item in ifcfg]
1355 def build_routes(iface, **settings):
1356     """
1357     Add route scripts for a network interface using up commands.
1358     CLI Example:
1359     .. code-block:: bash
1360         salt '*' ip.build_routes eth0 &lt;settings&gt;
1361     """
1362     opts = _parse_routes(iface, settings)
1363     try:
1364         template = JINJA.get_template("route_eth.jinja")
1365     except jinja2.exceptions.TemplateNotFound:
1366         log.error("Could not load template route_eth.jinja")
1367         return ""
1368     add_routecfg = template.render(route_type="add", routes=opts["routes"], iface=iface)
1369     del_routecfg = template.render(route_type="del", routes=opts["routes"], iface=iface)
1370     if "test" in settings and settings["test"]:
1371         return _read_temp(add_routecfg + del_routecfg)
1372     filename = _write_file_routes(iface, add_routecfg, _DEB_NETWORK_UP_DIR, "route-{0}")
1373     results = _read_file(filename)
1374     filename = _write_file_routes(
1375         iface, del_routecfg, _DEB_NETWORK_DOWN_DIR, "route-{0}"
1376     )
1377     results += _read_file(filename)
1378     return results
1379 def down(iface, iface_type):
1380     """
1381     Shutdown a network interface
1382     CLI Example:
1383     .. code-block:: bash
1384         salt '*' ip.down eth0 eth
1385     """
1386     if iface_type not in ["slave", "source"]:
1387         return __salt__["cmd.run"](["ifdown", iface])
1388     return None
1389 def get_bond(iface):
1390     """
1391     Return the content of a bond script
1392     CLI Example:
1393     .. code-block:: bash
1394         salt '*' ip.get_bond bond0
1395     """
1396     path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1397     return _read_file(path)
1398 def get_interface(iface):
1399     """
1400     Return the contents of an interface script
1401     CLI Example:
1402     .. code-block:: bash
1403         salt '*' ip.get_interface eth0
1404     """
1405     adapters = _parse_interfaces()
1406     if iface in adapters:
1407         try:
1408             if iface == "source":
1409                 template = JINJA.get_template("debian_source.jinja")
1410             else:
1411                 template = JINJA.get_template("debian_eth.jinja")
1412         except jinja2.exceptions.TemplateNotFound:
1413             log.error("Could not load template debian_eth.jinja")
1414             return ""
1415         ifcfg = template.render({"name": iface, "data": adapters[iface]})
1416         return [item + "\n" for item in ifcfg.split("\n")]
1417     else:
1418         return []
1419 def up(iface, iface_type):  # pylint: disable=C0103
1420     """
1421     Start up a network interface
1422     CLI Example:
1423     .. code-block:: bash
1424         salt '*' ip.up eth0 eth
1425     """
1426     if iface_type not in ("slave", "source"):
1427         return __salt__["cmd.run"](["ifup", iface])
1428     return None
1429 def get_network_settings():
1430     """
1431     Return the contents of the global network script.
1432     CLI Example:
1433     .. code-block:: bash
1434         salt '*' ip.get_network_settings
1435     """
1436     skip_etc_default_networking = (
1437         __grains__["osfullname"] == "Ubuntu"
1438         and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
1439     )
1440     if skip_etc_default_networking:
1441         settings = {}
1442         if __salt__["service.available"]("networking"):
1443             if __salt__["service.status"]("networking"):
1444                 settings["networking"] = "yes"
1445             else:
1446                 settings["networking"] = "no"
1447         else:
1448             settings["networking"] = "no"
1449         hostname = _parse_hostname()
1450         domainname = _parse_domainname()
1451         settings["hostname"] = hostname
1452         settings["domainname"] = domainname
1453     else:
1454         settings = _parse_current_network_settings()
1455     try:
1456         template = JINJA.get_template("display-network.jinja")
1457     except jinja2.exceptions.TemplateNotFound:
1458         log.error("Could not load template display-network.jinja")
1459         return ""
1460     network = template.render(settings)
1461     return _read_temp(network)
1462 def get_routes(iface):
1463     """
1464     Return the routes for the interface
1465     CLI Example:
1466     .. code-block:: bash
1467         salt '*' ip.get_routes eth0
1468     """
1469     filename = os.path.join(_DEB_NETWORK_UP_DIR, "route-{}".format(iface))
1470     results = _read_file(filename)
1471     filename = os.path.join(_DEB_NETWORK_DOWN_DIR, "route-{}".format(iface))
1472     results += _read_file(filename)
1473     return results
1474 def apply_network_settings(**settings):
1475     """
1476     Apply global network configuration.
1477     CLI Example:
1478     .. code-block:: bash
1479         salt '*' ip.apply_network_settings
1480     """
1481     if "require_reboot" not in settings:
1482         settings["require_reboot"] = False
1483     if "apply_hostname" not in settings:
1484         settings["apply_hostname"] = False
1485     hostname_res = True
1486     if settings["apply_hostname"] in _CONFIG_TRUE:
1487         if "hostname" in settings:
1488             hostname_res = __salt__["network.mod_hostname"](settings["hostname"])
1489         else:
1490             log.warning(
1491                 "The network state sls is trying to apply hostname "
1492                 "changes but no hostname is defined."
1493             )
1494             hostname_res = False
1495     res = True
1496     if settings["require_reboot"] in _CONFIG_TRUE:
1497         log.warning(
1498             "The network state sls is requiring a reboot of the system to "
1499             "properly apply network configuration."
1500         )
1501         res = True
1502     else:
1503         stop = __salt__["service.stop"]("networking")
1504         time.sleep(2)
1505         res = stop and __salt__["service.start"]("networking")
1506     return hostname_res and res
1507 def build_network_settings(**settings):
1508     """
1509     Build the global network script.
1510     CLI Example:
1511     .. code-block:: bash
1512         salt '*' ip.build_network_settings &lt;settings&gt;
1513     """
1514     changes = []
1515     current_network_settings = _parse_current_network_settings()
1516     opts = _parse_network_settings(settings, current_network_settings)
1517     skip_etc_default_networking = (
1518         __grains__["osfullname"] == "Ubuntu"
1519         and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
1520     )
1521     if skip_etc_default_networking:
1522         if opts["networking"] == "yes":
1523             service_cmd = "service.enable"
1524         else:
1525             service_cmd = "service.disable"
1526         if __salt__["service.available"]("NetworkManager"):
1527             __salt__[service_cmd]("NetworkManager")
1528         if __salt__["service.available"]("networking"):
1529             __salt__[service_cmd]("networking")
1530     else:
1531         try:
1532             template = JINJA.get_template("network.jinja")
1533         except jinja2.exceptions.TemplateNotFound:
1534             log.error("Could not load template network.jinja")
1535             return ""
1536         network = template.render(opts)
1537         if "test" in settings and settings["test"]:
1538             return _read_temp(network)
1539         _write_file_network(network, _DEB_NETWORKING_FILE, True)
1540     sline = opts["hostname"].split(".", 1)
1541     opts["hostname"] = sline[0]
1542     current_domainname = current_network_settings["domainname"]
1543     current_searchdomain = current_network_settings["searchdomain"]
1544     new_domain = False
1545     if len(sline) &gt; 1:
1546         new_domainname = sline[1]
1547         if new_domainname != current_domainname:
1548             domainname = new_domainname
1549             opts["domainname"] = new_domainname
1550             new_domain = True
1551         else:
1552             domainname = current_domainname
1553             opts["domainname"] = domainname
1554     else:
1555         domainname = current_domainname
1556         opts["domainname"] = domainname
1557     new_search = False
1558     if "search" in opts:
1559         new_searchdomain = opts["search"]
1560         if new_searchdomain != current_searchdomain:
1561             searchdomain = new_searchdomain
1562             opts["searchdomain"] = new_searchdomain
1563             new_search = True
1564         else:
1565             searchdomain = current_searchdomain
1566             opts["searchdomain"] = searchdomain
1567     else:
1568         searchdomain = current_searchdomain
1569         opts["searchdomain"] = searchdomain
1570     if new_domain or new_search:
1571         resolve = _parse_resolve()
1572         domain_prog = re.compile(r"domain\s+")
1573         search_prog = re.compile(r"search\s+")
1574         new_contents = []
1575         for item in _read_file(_DEB_RESOLV_FILE):
1576             if domain_prog.match(item):
1577                 item = "domain {}".format(domainname)
1578             elif search_prog.match(item):
1579                 item = "search {}".format(searchdomain)
1580             new_contents.append(item)
1581         if "domain" not in resolve:
1582             new_contents.insert(0, "domain {}".format(domainname))
1583         if "search" not in resolve:
1584             new_contents.insert("domain" in resolve, "search {}".format(searchdomain))
1585         new_resolv = "\n".join(new_contents)
1586         if not ("test" in settings and settings["test"]):
1587             _write_file_network(new_resolv, _DEB_RESOLV_FILE)
1588     try:
1589         template = JINJA.get_template("display-network.jinja")
1590     except jinja2.exceptions.TemplateNotFound:
1591         log.error("Could not load template display-network.jinja")
1592         return ""
1593     network = template.render(opts)
1594     changes.extend(_read_temp(network))
1595     return changes
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
