<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tcp.py &amp; debian_ip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tcp.py &amp; debian_ip.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tcp.py (2.2803113%)<th>debian_ip.py (1.5763168%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(10-25)<td><a href="#" name="0">(8-23)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(334-340)<td><a href="#" name="1">(1241-1244)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1046-1048)<td><a href="#" name="2">(1216-1220)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tcp.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
TCP transport classes
Wire protocol: "len(payload) msgpack({'head': SOMEHEADER, 'body': SOMEBODY})"
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
import logging
import os
import queue
import socket
import threading
import urllib
import salt.ext.tornado
import salt.ext.tornado.concurrent
import salt.ext.tornado.gen
import salt.ext.tornado.iostream
import salt.ext.tornado.netutil
import salt.ext.tornado.tcpclient
import salt.ext.tornado.tcpserver
import</b></font> salt.master
import salt.payload
import salt.transport.client
import salt.transport.frame
import salt.transport.ipc
import salt.transport.server
import salt.utils.asynchronous
import salt.utils.files
import salt.utils.msgpack
import salt.utils.platform
import salt.utils.versions
from salt.exceptions import SaltClientError, SaltReqTimeoutError
if salt.utils.platform.is_windows():
    USE_LOAD_BALANCER = True
else:
    USE_LOAD_BALANCER = False
if USE_LOAD_BALANCER:
    import threading
    import multiprocessing
    import salt.ext.tornado.util
    from salt.utils.process import SignalHandlingProcess
log = logging.getLogger(__name__)
class ClosingError(Exception):
def _set_tcp_keepalive(sock, opts):
    """
    Ensure that TCP keepalives are set for the socket.
    """
    if hasattr(socket, "SO_KEEPALIVE"):
        if opts.get("tcp_keepalive", False):
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            if hasattr(socket, "SOL_TCP"):
                if hasattr(socket, "TCP_KEEPIDLE"):
                    tcp_keepalive_idle = opts.get("tcp_keepalive_idle", -1)
                    if tcp_keepalive_idle &gt; 0:
                        sock.setsockopt(
                            socket.SOL_TCP, socket.TCP_KEEPIDLE, int(tcp_keepalive_idle)
                        )
                if hasattr(socket, "TCP_KEEPCNT"):
                    tcp_keepalive_cnt = opts.get("tcp_keepalive_cnt", -1)
                    if tcp_keepalive_cnt &gt; 0:
                        sock.setsockopt(
                            socket.SOL_TCP, socket.TCP_KEEPCNT, int(tcp_keepalive_cnt)
                        )
                if hasattr(socket, "TCP_KEEPINTVL"):
                    tcp_keepalive_intvl = opts.get("tcp_keepalive_intvl", -1)
                    if tcp_keepalive_intvl &gt; 0:
                        sock.setsockopt(
                            socket.SOL_TCP,
                            socket.TCP_KEEPINTVL,
                            int(tcp_keepalive_intvl),
                        )
            if hasattr(socket, "SIO_KEEPALIVE_VALS"):
                tcp_keepalive_idle = opts.get("tcp_keepalive_idle", -1)
                tcp_keepalive_intvl = opts.get("tcp_keepalive_intvl", -1)
                if tcp_keepalive_idle &gt; 0 or tcp_keepalive_intvl &gt; 0:
                    if tcp_keepalive_idle &lt;= 0:
                        tcp_keepalive_idle = 7200
                    if tcp_keepalive_intvl &lt;= 0:
                        tcp_keepalive_intvl = 1
                    sock.ioctl(
                        socket.SIO_KEEPALIVE_VALS,
                        (
                            1,
                            int(tcp_keepalive_idle * 1000),
                            int(tcp_keepalive_intvl * 1000),
                        ),
                    )
        else:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 0)
if USE_LOAD_BALANCER:
    class LoadBalancerServer(SignalHandlingProcess):
        """
        Raw TCP server which runs in its own process and will listen
        for incoming connections. Each incoming connection will be
        sent via multiprocessing queue to the workers.
        Since the queue is shared amongst workers, only one worker will
        handle a given connection.
        """
        backlog = 128
        def __init__(self, opts, socket_queue, **kwargs):
            super().__init__(**kwargs)
            self.opts = opts
            self.socket_queue = socket_queue
            self._socket = None
        def close(self):
            if self._socket is not None:
                self._socket.shutdown(socket.SHUT_RDWR)
                self._socket.close()
                self._socket = None
        def __del__(self):
            self.close()
        def run(self):
            """
            Start the load balancer
            """
            self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            _set_tcp_keepalive(self._socket, self.opts)
            self._socket.setblocking(1)
            self._socket.bind((self.opts["interface"], int(self.opts["ret_port"])))
            self._socket.listen(self.backlog)
            while True:
                try:
                    connection, address = self._socket.accept()
                    self.socket_queue.put((connection, address), True, None)
                except OSError as e:
                    if (
                        salt.ext.tornado.util.errno_from_exception(e)
                        == errno.ECONNABORTED
                    ):
                        continue
                    raise
class Resolver:
    _resolver_configured = False
    @classmethod
    def _config_resolver(cls, num_threads=10):
        salt.ext.tornado.netutil.Resolver.configure(
            "salt.ext.tornado.netutil.ThreadedResolver", num_threads=num_threads
        )
        cls._resolver_configured = True
    def __init__(self, *args, **kwargs):
        if not self._resolver_configured:
            self._config_resolver()
class TCPPubClient(salt.transport.base.PublishClient):
    """
    Tornado based TCP Pub Client
    """
    ttype = "tcp"
    def __init__(self, opts, io_loop, **kwargs):  # pylint: disable=W0231
        self.opts = opts
        self.io_loop = io_loop
        self.message_client = None
        self.connected = False
        self._closing = False
        self.resolver = Resolver()
    def close(self):
        if self._closing:
            return
        self._closing = True
        if self.message_client is not None:
            self.message_client.close()
            self.message_client = None
    def __del__(self):
        self.close()
    @salt.ext.tornado.gen.coroutine
    def connect(self, publish_port, connect_callback=None, disconnect_callback=None):
        self.publish_port = publish_port
        self.message_client = MessageClient(
            self.opts,
            self.opts["master_ip"],
            int(self.publish_port),
            io_loop=self.io_loop,
            connect_callback=connect_callback,
            disconnect_callback=disconnect_callback,
            source_ip=self.opts.get("source_ip"),
            source_port=self.opts.get("source_publish_port"),
        )
        yield self.message_client.connect()  # wait for the client to be connected
        self.connected = True
    @salt.ext.tornado.gen.coroutine
    def _decode_messages(self, messages):
        if not isinstance(messages, dict):
            body = salt.utils.msgpack.loads(messages)
            body = salt.transport.frame.decode_embedded_strs(body)
        else:
            body = messages
        raise salt.ext.tornado.gen.Return(body)
    @salt.ext.tornado.gen.coroutine
    def send(self, msg):
        yield self.message_client._stream.write(msg)
    def on_recv(self, callback):
        """
        Register an on_recv callback
        """
        return self.message_client.on_recv(callback)
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
class TCPReqServer(salt.transport.base.DaemonizedRequestServer):
    """
    Tornado based TCP Request/Reply Server
    :param dict opts: Salt master config options.
    """
    backlog = 5
    def __init__(self, opts):  # pylint: disable=W0231
        self.opts = opts
        self._socket = None
        self.req_server = None
    @property
    def socket(self):
        return self._socket
    def close(self):
        if self._socket is not None:
            try:
                self._socket.shutdown(socket.SHUT_RDWR)
            except OSError as exc:
                if exc.errno == errno.ENOTCONN:
                    pass
                else:
                    raise
            if self.req_server is None:
                self._socket.close()
            self._socket = None
        if self.req_server is not None:
            try:
                self.req_server.close()
            except OSError as exc:
                if exc.errno != 9:
                    raise
                log.exception(
                    "TCPReqServerChannel close generated an exception: %s", str(exc)
                )
            self.req_server = None
    def __enter__(self):
        return self
    def __exit__(self, *args):
        self.close()
    def pre_fork(self, process_manager):
        """
        Pre-fork we need to create the zmq router device
        if USE_LOAD_BALANCER:
            self.socket_queue = multiprocessing.Queue()
            process_manager<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_process(
                LoadBalancerServer,
                args=(self.opts, self.socket_queue),
                name="LoadBalancerServer",
            )
        elif not salt.utils.platform.is_windows():
            self._socket = socket.</b></font>socket(socket.AF_INET, socket.SOCK_STREAM)
            self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            _set_tcp_keepalive(self._socket, self.opts)
            self._socket.setblocking(0)
            self._socket.bind((self.opts["interface"], int(self.opts["ret_port"])))
    def post_fork(self, message_handler, io_loop):
        """
        After forking we need to create all of the local sockets to listen to the
        router
        message_handler: function to call with your payloads
        """
        self.message_handler = message_handler
        with salt.utils.asynchronous.current_ioloop(io_loop):
            if USE_LOAD_BALANCER:
                self.req_server = LoadBalancerWorker(
                    self.socket_queue,
                    self.handle_message,
                    ssl_options=self.opts.get("ssl"),
                )
            else:
                if salt.utils.platform.is_windows():
                    self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                    _set_tcp_keepalive(self._socket, self.opts)
                    self._socket.setblocking(0)
                    self._socket.bind(
                        (self.opts["interface"], int(self.opts["ret_port"]))
                    )
                self.req_server = SaltMessageServer(
                    self.handle_message,
                    ssl_options=self.opts.get("ssl"),
                    io_loop=io_loop,
                )
                self.req_server.add_socket(self._socket)
                self._socket.listen(self.backlog)
    @salt.ext.tornado.gen.coroutine
    def handle_message(self, stream, payload, header=None):
        payload = self.decode_payload(payload)
        reply = yield self.message_handler(payload)
        stream.write(salt.transport.frame.frame_msg(reply, header=header))
    def decode_payload(self, payload):
        return payload
class SaltMessageServer(salt.ext.tornado.tcpserver.TCPServer):
    """
    Raw TCP server which will receive all of the TCP streams and re-assemble
    messages that are sent through to us
    """
    def __init__(self, message_handler, *args, **kwargs):
        io_loop = (
            kwargs.pop("io_loop", None) or salt.ext.tornado.ioloop.IOLoop.current()
        )
        self._closing = False
        super().__init__(*args, **kwargs)
        self.io_loop = io_loop
        self.clients = []
        self.message_handler = message_handler
    @salt.ext.tornado.gen.coroutine
    def handle_stream(self, stream, address):
        """
        Handle incoming streams and add messages to the incoming queue
        """
        log.trace("Req client %s connected", address)
        self.clients.append((stream, address))
        unpacker = salt.utils.msgpack.Unpacker()
        try:
            while True:
                wire_bytes = yield stream.read_bytes(4096, partial=True)
                unpacker.feed(wire_bytes)
                for framed_msg in unpacker:
                    framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
                    header = framed_msg["head"]
                    self.io_loop.spawn_callback(
                        self.message_handler, stream, framed_msg["body"], header
                    )
        except salt.ext.tornado.iostream.StreamClosedError:
            log.trace("req client disconnected %s", address)
            self.remove_client((stream, address))
        except Exception as e:  # pylint: disable=broad-except
            log.trace("other master-side exception: %s", e, exc_info=True)
            self.remove_client((stream, address))
            stream.close()
    def remove_client(self, client):
        try:
            self.clients.remove(client)
        except ValueError:
            log.trace("Message server client was not in list to remove")
    def close(self):
        """
        Close the server
        """
        if self._closing:
            return
        self._closing = True
        for item in self.clients:
            client, address = item
            client.close()
            self.remove_client(item)
        try:
            self.stop()
        except OSError as exc:
            if exc.errno != 9:
                raise
if USE_LOAD_BALANCER:
    class LoadBalancerWorker(SaltMessageServer):
        """
        This will receive TCP connections from 'LoadBalancerServer' via
        a multiprocessing queue.
        Since the queue is shared amongst workers, only one worker will handle
        a given connection.
        """
        def __init__(self, socket_queue, message_handler, *args, **kwargs):
            super().__init__(message_handler, *args, **kwargs)
            self.socket_queue = socket_queue
            self._stop = threading.Event()
            self.thread = threading.Thread(target=self.socket_queue_thread)
            self.thread.start()
        def close(self):
            self._stop.set()
            self.thread.join()
            super().close()
        def socket_queue_thread(self):
            try:
                while True:
                    try:
                        client_socket, address = self.socket_queue.get(True, 1)
                    except queue.Empty:
                        if self._stop.is_set():
                            break
                        continue
                    self.io_loop.spawn_callback(
                        self._handle_connection, client_socket, address
                    )
            except (KeyboardInterrupt, SystemExit):
                pass
class TCPClientKeepAlive(salt.ext.tornado.tcpclient.TCPClient):
    """
    Override _create_stream() in TCPClient to enable keep alive support.
    """
    def __init__(self, opts, resolver=None):
        self.opts = opts
        super().__init__(resolver=resolver)
    def _create_stream(
        self, max_buffer_size, af, addr, **kwargs
    ):  # pylint: disable=unused-argument,arguments-differ
        """
        Override _create_stream() in TCPClient.
        Tornado 4.5 added the kwargs 'source_ip' and 'source_port'.
        Due to this, use **kwargs to swallow these and any future
        kwargs to maintain compatibility.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        _set_tcp_keepalive(sock, self.opts)
        stream = salt.ext.tornado.iostream.IOStream(
            sock, max_buffer_size=max_buffer_size
        )
        if salt.ext.tornado.version_info &lt; (5,):
            return stream.connect(addr)
        return stream, stream.connect(addr)
class MessageClient:
    """
    Low-level message sending client
    """
    def __init__(
        self,
        opts,
        host,
        port,
        io_loop=None,
        resolver=None,
        connect_callback=None,
        disconnect_callback=None,
        source_ip=None,
        source_port=None,
    ):
        self.opts = opts
        self.host = host
        self.port = port
        self.source_ip = source_ip
        self.source_port = source_port
        self.connect_callback = connect_callback
        self.disconnect_callback = disconnect_callback
        self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
        with salt.utils.asynchronous.current_ioloop(self.io_loop):
            self._tcp_client = TCPClientKeepAlive(opts, resolver=resolver)
        self._mid = 1
        self._max_messages = int((1 &lt;&lt; 31) - 2)  # number of IDs before we wrap
        self.send_queue = []  # queue of messages to be sent
        self.send_future_map = {}  # mapping of request_id -&gt; Future
        self._read_until_future = None
        self._on_recv = None
        self._closing = False
        self._closed = False
        self._connecting_future = salt.ext.tornado.concurrent.Future()
        self._stream_return_running = False
        self._stream = None
        self.backoff = opts.get("tcp_reconnect_backoff", 1)
    def _stop_io_loop(self):
        if self.io_loop is not None:
            self.io_loop.stop()
    def close(self):
        if self._closing:
            return
        self._closing = True
        self.io_loop.add_timeout(1, self.check_close)
    @salt.ext.tornado.gen.coroutine
    def check_close(self):
        if not self.send_future_map:
            self._tcp_client.close()
            self._stream = None
            self._closing = False
            self._closed = True
        else:
            self.io_loop.add_timeout(1, self.check_close)
    def __del__(self):
        self.close()
    @salt.ext.tornado.gen.coroutine
    def getstream(self, **kwargs):
        if self.source_ip or self.source_port:
            kwargs = {
                "source_ip": self.source_ip,
                "source_port": self.source_port,
            }
        stream = None
        while stream is None and (not self._closed and not self._closing):
            try:
                stream = yield self._tcp_client.connect(
                    self.host, self.port, ssl_options=self.opts.get("ssl"), **kwargs
                )
            except Exception as exc:  # pylint: disable=broad-except
                log.warning(
                    "TCP Message Client encountered an exception while connecting to"
                    " %s:%s: %r, will reconnect in %d seconds",
                    self.host,
                    self.port,
                    exc,
                    self.backoff,
                )
                yield salt.ext.tornado.gen.sleep(self.backoff)
        raise salt.ext.tornado.gen.Return(stream)
    @salt.ext.tornado.gen.coroutine
    def connect(self):
        if self._stream is None:
            self._stream = yield self.getstream()
            if self._stream:
                if not self._stream_return_running:
                    self.io_loop.spawn_callback(self._stream_return)
                if self.connect_callback:
                    self.connect_callback(True)
    @salt.ext.tornado.gen.coroutine
    def _stream_return(self):
        self._stream_return_running = True
        unpacker = salt.utils.msgpack.Unpacker()
        while not self._closing:
            try:
                wire_bytes = yield self._stream.read_bytes(4096, partial=True)
                unpacker.feed(wire_bytes)
                for framed_msg in unpacker:
                    framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
                    header = framed_msg["head"]
                    body = framed_msg["body"]
                    message_id = header.get("mid")
                    if message_id in self.send_future_map:
                        self.send_future_map.pop(message_id).set_result(body)
                    else:
                        if self._on_recv is not None:
                            self.io_loop.spawn_callback(self._on_recv, header, body)
                        else:
                            log.error(
                                "Got response for message_id %s that we are not"
                                " tracking",
                                message_id,
                            )
            except salt.ext.tornado.iostream.StreamClosedError as e:
                log.debug(
                    "tcp stream to %s:%s closed, unable to recv",
                    self.host,
                    self.port,
                )
                for future in self.send_future_map.values():
                    future.set_exception(e)
                self.send_future_map = {}
                if self._closing or self._closed:
                    return
                if self.disconnect_callback:
                    self.disconnect_callback()
                stream = self._stream
                self._stream = None
                if stream:
                    stream.close()
                yield self.connect()
            except TypeError:
                if "detect_mode" in self.opts:
                    log.info(
                        "There was an error trying to use TCP transport; "
                        "attempting to fallback to another transport"
                    )
                else:
                    raise SaltClientError
            except Exception as e:  # pylint: disable=broad-except
                log.error("Exception parsing response", exc_info=True)
                for future in self.send_future_map.values():
                    future.set_exception(e)
                self.send_future_map = {}
                if self._closing or self._closed:
                    return
                if self.disconnect_callback:
                    self.disconnect_callback()
                stream = self._stream
                self._stream = None
                if stream:
                    stream.close()
                yield self.connect()
        self._stream_return_running = False
    def _message_id(self):
        wrap = False
        while self._mid in self.send_future_map:
            if self._mid &gt;= self._max_messages:
                if wrap:
                    raise Exception("Unable to find available messageid")
                self._mid = 1
                wrap = True
            else:
                self._mid += 1
        return self._mid
    def on_recv(self, callback):
        """
        Register a callback for received messages (that we didn't initiate)
        """
        if callback is None:
            self._on_recv = callback
        else:
            def wrap_recv(header, body):
                callback(body)
            self._on_recv = wrap_recv
    def remove_message_timeout(self, message_id):
        if message_id not in self.send_timeout_map:
            return
        timeout = self.send_timeout_map.pop(message_id)
        self.io_loop.remove_timeout(timeout)
    def timeout_message(self, message_id, msg):
        if message_id not in self.send_future_map:
            return
        future = self.send_future_map.pop(message_id)
        if future is not None:
            future.set_exception(SaltReqTimeoutError("Message timed out"))
    @salt.ext.tornado.gen.coroutine
    def send(self, msg, timeout=None, callback=None, raw=False):
        if self._closing:
            raise ClosingError()
        message_id = self._message_id()
        header = {"mid": message_id}
        future = salt.ext.tornado.concurrent.Future()
        if callback is not None:
            def handle_future(future):
                response = future.result()
                self.io_loop.add_callback(callback, response)
            future.add_done_callback(handle_future)
        self.send_future_map[message_id] = future
        if self.opts.get("detect_mode") is True:
            timeout = 1
        if timeout is not None:
            self.io_loop.call_later(timeout, self.timeout_message, message_id, msg)
        item = salt.transport.frame.frame_msg(msg, header=header)
        @salt.ext.tornado.gen.coroutine
        def _do_send():
            yield self.connect()
            if self._stream:
                yield self._stream.write(item)
        self.io_loop.add_callback(_do_send)
        recv = yield future
        raise salt.ext.tornado.gen.Return(recv)
class Subscriber:
    """
    Client object for use with the TCP publisher server
    """
    def __init__(self, stream, address):
        self.stream = stream
        self.address = address
        self._closing = False
        self._read_until_future = None
        self.id_ = None
    def close(self):
        if self._closing:
            return
        self._closing = True
        if not self.stream.closed():
            self.stream.close()
            if self._read_until_future is not None and self._read_until_future.done():
                self._read_until_future.exception()
    def __del__(self):
        self.close()
class PubServer(salt.ext.tornado.tcpserver.TCPServer):
    """
    TCP publisher
    """
    def __init__(
        self, opts, io_loop=None, presence_callback=None, remove_presence_callback=None
    ):
        super().__init__(ssl_options=opts.get("ssl"))
        self.io_loop = io_loop
        self.opts = opts
        self._closing = False
        self.clients = set()
        self.presence_events = False
        if presence_callback:
            self.presence_callback = presence_callback
        else:
            self.presence_callback = lambda subscriber, msg: msg
        if remove_presence_callback:
            self.remove_presence_callback = remove_presence_callback
        else:
            self.remove_presence_callback = lambda subscriber: subscriber
    def close(self):
        if self._closing:
            return
        self._closing = True
        for client in self.clients:
            client.stream.disconnect()
    def __del__(self):
        self.close()
    @salt.ext.tornado.gen.coroutine
    def _stream_read(self, client):
        unpacker = salt.utils.msgpack.Unpacker()
        while not self._closing:
            try:
                client._read_until_future = client.stream.read_bytes(4096, partial=True)
                wire_bytes = yield client._read_until_future
                unpacker.feed(wire_bytes)
                for framed_msg in unpacker:
                    framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
                    body = framed_msg["body"]
                    if self.presence_callback:
                        self.presence_callback(client, body)
            except salt.ext.tornado.iostream.StreamClosedError as e:
                log.debug("tcp stream to %s closed, unable to recv", client.address)
                client.close()
                self.remove_presence_callback(client)
                self.clients.discard(client)
                break
            except Exception as e:  # pylint: disable=broad-except
                log.error(
                    "Exception parsing response from %s", client.address, exc_info=True
                )
                continue
    def handle_stream(self, stream, address):
        log.debug("Subscriber at %s connected", address)
        client = Subscriber(stream, address)
        self.clients.add(client)
        self.io_loop.spawn_callback(self._stream_read, client)
    @salt.ext.tornado.gen.coroutine
    def publish_payload(self, package, topic_list=None):
        log.trace("TCP PubServer sending payload: %s \n\n %r", package, topic_list)
        payload = salt.transport.frame.frame_msg(package)
        to_remove = []
        if topic_list:
            for topic in topic_list:
                sent = False
                for client in self.clients:
                    if topic == client.id_:
                        try:
                            yield client.stream.write(payload)
                            sent = True
                        except salt.ext.tornado.iostream.StreamClosedError:
                            to_remove.append(client)
                if not sent:
                    log.debug("Publish target %s not connected %r", topic, self.clients)
        else:
            for client in self.clients:
                try:
                    yield client.stream.write(payload)
                except salt.ext.tornado.iostream.StreamClosedError:
                    to_remove.append(client)
        for client in to_remove:
            log.debug(
                "Subscriber at %s has disconnected from publisher", client.address
            )
            client.close()
            self._remove_client_present(client)
            self.clients.discard(client)
        log.trace("TCP PubServer finished publishing payload")
class TCPPublishServer(salt.transport.base.DaemonizedPublishServer):
    """
    Tornado based TCP PublishServer
    """
    backlog = 128
    def __init__(self, opts):
        self.opts = opts
        self.pub_sock = None
    @property
    def topic_support(self):
        return not self.opts.get("order_masters", False)
    def __setstate__(self, state):
        self.__init__(state["opts"])
    def __getstate__(self):
        return {"opts": self.opts}
    def publish_daemon(
        self,
        publish_payload,
        presence_callback=None,
        remove_presence_callback=None,
    ):
        """
        Bind to the interface specified in the configuration file
        """
        io_loop = salt.ext.tornado.ioloop.IOLoop()
        io_loop.make_current()
        self.pub_server = pub_server = PubServer(
            self.opts,
            io_loop=io_loop,
            presence_callback=presence_callback,
            remove_presence_callback=remove_presence_callback,
        )
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        _set_tcp_keepalive(sock, self.opts)
        sock.setblocking(0)
        sock.bind((self.opts["interface"], int(self.opts["publish_port"])))
        sock.listen(self.backlog)
        pub_server.add_socket(sock)
        if self.opts.get("ipc_mode", "") == "tcp":
            pull_uri = int(self.opts.get("tcp_master_publish_pull", 4514))
        else:
            pull_uri = os.path.join(self.opts["sock_dir"], "publish_pull.ipc")
        self.pub_server = pub_server
        pull_sock = salt.transport.ipc.IPCMessageServer(
            pull_uri,
            io_loop=io_loop,
            payload_handler=publish_payload,
        )
        log.warn("Starting the Salt Puller on %s", pull_uri)
        with salt.utils.files.set_umask(0o177):
            pull_sock.start()
        try:
            io_loop.start()
        except (KeyboardInterrupt, SystemExit):
            pass
        finally:
            pull_sock.close()
    def pre_fork(self, process_manager):
        """
        Do anything necessary pre-fork. Since this is on the master side this will
        primarily be used to create IPC channels and create our daemon process to
        do the actual publishing
        """
        process_manager.add_process(self.publish_daemon, name=self.__class__.__name__)
    @salt.ext.tornado.gen.coroutine
    def publish_payload(self, payload, *args):
        ret = yield self.pub_server.publish_payload(payload, *args)
        raise salt.ext.tornado.gen.Return(ret)
    def publish(self, payload, **kwargs):
        """
        Publish "load" to minions
        """
        if self.opts.get("ipc_mode", "") == "tcp":
            pull_uri = int(self.opts.get("tcp_master_publish_pull", 4514))
        else:
            pull_uri = os.path.join(self.opts["sock_dir"], "publish_pull.ipc")
        if not self.pub_sock:
            self.pub_sock = salt.utils.asynchronous.SyncWrapper(
                salt.transport.ipc.IPCMessageClient,
                (pull_uri,),
                loop_kwarg="io_loop",
            )
            self.pub_sock.connect()
        self.pub_sock.send(payload)
    def close(self):
        if self.pub_sock:
            self.pub_sock.close()
            self.pub_sock = None
class TCPReqClient(salt.transport.base.RequestClient):
    """
    Tornado based TCP RequestClient
    """
    ttype = "tcp"
        self.opts = opts
        self.io_loop = io_loop
        parse = urllib<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.parse.urlparse(self.opts["master_uri"])
        master_host, master_port = parse.netloc.rsplit(":", 1)
        master_addr = (master_host, int(</b></font>master_port))
        resolver = kwargs.get("resolver")
        self.message_client = salt.transport.tcp.MessageClient(
            opts,
            master_host,
            int(master_port),
            io_loop=io_loop,
            resolver=resolver,
            source_ip=opts.get("source_ip"),
            source_port=opts.get("source_ret_port"),
        )
    @salt.ext.tornado.gen.coroutine
    def connect(self):
        yield self.message_client.connect()
    @salt.ext.tornado.gen.coroutine
    def send(self, load, timeout=60):
        ret = yield self.message_client.send(load, timeout=timeout)
        raise salt.ext.tornado.gen.Return(ret)
    def close(self):
        self.message_client.close()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>debian_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
The networking module for Debian-based distros
References:
* http://www.debian.org/doc/manuals/debian-reference/ch05.en.html
"""
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import functools
import io
import logging
import os
import os.path
import re
import time
import jinja2
import jinja2.exceptions
import salt.utils.dns
import salt.utils.files
import salt.utils.odict
import salt.utils.stringutils
import salt.utils.templates
import</b></font> salt.utils.validate.net
log = logging.getLogger(__name__)
JINJA = jinja2.Environment(
    loader=jinja2.FileSystemLoader(
        os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "debian_ip")
    )
)
__virtualname__ = "ip"
def __virtual__():
    """
    Confine this module to Debian-based distros
    """
    if __grains__["os_family"] == "Debian":
        return __virtualname__
    return (False, "The debian_ip module could not be loaded: unsupported OS family")
_ETHTOOL_CONFIG_OPTS = {
    "speed": "link-speed",
    "duplex": "link-duplex",
    "autoneg": "ethernet-autoneg",
    "ethernet-port": "ethernet-port",
    "wol": "ethernet-wol",
    "driver-message-level": "driver-message-level",
    "ethernet-pause-rx": "ethernet-pause-rx",
    "ethernet-pause-tx": "ethernet-pause-tx",
    "ethernet-pause-autoneg": "ethernet-pause-autoneg",
    "rx": "offload-rx",
    "tx": "offload-tx",
    "sg": "offload-sg",
    "tso": "offload-tso",
    "ufo": "offload-ufo",
    "gso": "offload-gso",
    "gro": "offload-gro",
    "lro": "offload-lro",
    "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
    "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
    "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
    "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
    "hardware-dma-ring-rx": "hardware-dma-ring-rx",
    "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
    "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
    "hardware-dma-ring-tx": "hardware-dma-ring-tx",
}
_REV_ETHTOOL_CONFIG_OPTS = {
    "link-speed": "speed",
    "link-duplex": "duplex",
    "ethernet-autoneg": "autoneg",
    "ethernet-port": "ethernet-port",
    "ethernet-wol": "wol",
    "driver-message-level": "driver-message-level",
    "ethernet-pause-rx": "ethernet-pause-rx",
    "ethernet-pause-tx": "ethernet-pause-tx",
    "ethernet-pause-autoneg": "ethernet-pause-autoneg",
    "offload-rx": "rx",
    "offload-tx": "tx",
    "offload-sg": "sg",
    "offload-tso": "tso",
    "offload-ufo": "ufo",
    "offload-gso": "gso",
    "offload-lro": "lro",
    "offload-gro": "gro",
    "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
    "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
    "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
    "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
    "hardware-dma-ring-rx": "hardware-dma-ring-rx",
    "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
    "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
    "hardware-dma-ring-tx": "hardware-dma-ring-tx",
}
_DEB_CONFIG_PPPOE_OPTS = {
    "user": "user",
    "password": "password",
    "provider": "provider",
    "pppoe_iface": "pppoe_iface",
    "noipdefault": "noipdefault",
    "usepeerdns": "usepeerdns",
    "defaultroute": "defaultroute",
    "holdoff": "holdoff",
    "maxfail": "maxfail",
    "hide-password": "hide-password",
    "lcp-echo-interval": "lcp-echo-interval",
    "lcp-echo-failure": "lcp-echo-failure",
    "connect": "connect",
    "noauth": "noauth",
    "persist": "persist",
    "mtu": "mtu",
    "noaccomp": "noaccomp",
    "linkname": "linkname",
}
_DEB_ROUTES_FILE = "/etc/network/routes"
_DEB_NETWORK_FILE = "/etc/network/interfaces"
_DEB_NETWORK_DIR = "/etc/network/interfaces.d/"
_DEB_NETWORK_UP_DIR = "/etc/network/if-up.d/"
_DEB_NETWORK_DOWN_DIR = "/etc/network/if-down.d/"
_DEB_NETWORK_CONF_FILES = "/etc/modprobe.d/"
_DEB_NETWORKING_FILE = "/etc/default/networking"
_DEB_HOSTNAME_FILE = "/etc/hostname"
_DEB_RESOLV_FILE = "/etc/resolv.conf"
_DEB_PPP_DIR = "/etc/ppp/peers/"
_CONFIG_TRUE = ["yes", "on", "true", "1", True]
_CONFIG_FALSE = ["no", "off", "false", "0", False]
_IFACE_TYPES = [
    "eth",
    "bond",
    "alias",
    "clone",
    "ipsec",
    "dialup",
    "bridge",
    "slave",
    "vlan",
    "pppoe",
    "source",
]
def _error_msg_iface(iface, option, expected):
    """
    Build an appropriate error message from a given option and
    a list of expected values.
    """
    msg = "Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]"
    return msg.format(iface, option, "|".join(str(e) for e in expected))
def _error_msg_routes(iface, option, expected):
    """
    Build an appropriate error message from a given option and
    a list of expected values.
    """
    msg = "Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]"
    return msg.format(iface, option, expected)
def _log_default_iface(iface, opt, value):
    log.info(
        "Using default option -- Interface: %s Option: %s Value: %s", iface, opt, value
    )
def _error_msg_network(option, expected):
    """
    Build an appropriate error message from a given option and
    a list of expected values.
    """
    msg = "Invalid network setting -- Setting: {0}, Expected: [{1}]"
    return msg.format(option, "|".join(str(e) for e in expected))
def _log_default_network(opt, value):
    log.info("Using existing setting -- Setting: %s Value: %s", opt, value)
def _raise_error_iface(iface, option, expected):
    """
    Log and raise an error with a logical formatted message.
    """
    msg = _error_msg_iface(iface, option, expected)
    log.error(msg)
    raise AttributeError(msg)
def _raise_error_network(option, expected):
    """
    Log and raise an error with a logical formatted message.
    """
    msg = _error_msg_network(option, expected)
    log.error(msg)
    raise AttributeError(msg)
def _raise_error_routes(iface, option, expected):
    """
    Log and raise an error with a logical formatted message.
    """
    msg = _error_msg_routes(iface, option, expected)
    log.error(msg)
    raise AttributeError(msg)
def _read_file(path):
    """
    Reads and returns the contents of a text file
    """
    try:
        with salt.utils.files.flopen(path, "rb") as contents:
            return [
                salt.utils.stringutils.to_str(line) for line in contents.readlines()
            ]
    except OSError:
        return ""
def _parse_resolve():
    """
    Parse /etc/resolv.conf
    """
    return salt.utils.dns.parse_resolv(_DEB_RESOLV_FILE)
def _parse_domainname():
    """
    Parse /etc/resolv.conf and return domainname
    """
    return _parse_resolve().get("domain", "")
def _parse_searchdomain():
    """
    Parse /etc/resolv.conf and return searchdomain
    """
    return _parse_resolve().get("search", "")
def _parse_hostname():
    """
    Parse /etc/hostname and return hostname
    """
    contents = _read_file(_DEB_HOSTNAME_FILE)
    if contents:
        return contents[0].split("\n")[0]
    else:
        return ""
def _parse_current_network_settings():
    """
    Parse /etc/default/networking and return current configuration
    """
    opts = salt.utils.odict.OrderedDict()
    opts["networking"] = ""
    if os.path.isfile(_DEB_NETWORKING_FILE):
        with salt.utils.files.fopen(_DEB_NETWORKING_FILE) as contents:
            for line in contents:
                salt.utils.stringutils.to_unicode(line)
                if line.startswith("#"):
                    continue
                elif line.startswith("CONFIGURE_INTERFACES"):
                    opts["networking"] = line.split("=", 1)[1].strip()
    hostname = _parse_hostname()
    domainname = _parse_domainname()
    searchdomain = _parse_searchdomain()
    opts["hostname"] = hostname
    opts["domainname"] = domainname
    opts["searchdomain"] = searchdomain
    return opts
def __ipv4_quad(value):
    return (salt.utils.validate.net.ipv4_addr(value), value, "dotted IPv4 address")
def __ipv6(value):
    return (salt.utils.validate.net.ipv6_addr(value), value, "IPv6 address")
def __mac(value):
    return (salt.utils.validate.net.mac(value), value, "MAC address")
def __anything(value):
    return (True, value, None)
def __int(value):
    valid, _value = False, value
    try:
        _value = int(value)
        valid = True
    except ValueError:
        pass
    return (valid, _value, "integer")
def __float(value):
    valid, _value = False, value
    try:
        _value = float(value)
        valid = True
    except ValueError:
        pass
    return (valid, _value, "float")
def __ipv4_netmask(value):
    valid, errmsg = False, "dotted quad or integer CIDR (0-&gt;32)"
    valid, value, _ = __int(value)
    if not (valid and 0 &lt;= value &lt;= 32):
        valid = salt.utils.validate.net.netmask(value)
    return (valid, value, errmsg)
def __ipv6_netmask(value):
    valid, errmsg = False, "IPv6 netmask (0-&gt;128)"
    valid, value, _ = __int(value)
    valid = valid and 0 &lt;= value &lt;= 128
    return (valid, value, errmsg)
def __within2(value, within=None, errmsg=None, dtype=None):
    valid, _value = False, value
    if dtype:
        try:
            _value = dtype(value)  # TODO: this is a bit loose when dtype is a class
            valid = _value in within
        except ValueError:
            pass
    else:
        valid = _value in within
    if errmsg is None:
        if dtype:
            typename = getattr(
                dtype,
                "__name__",
                hasattr(dtype, "__class__") and getattr(dtype.__class__, "name", dtype),
            )
            errmsg = "{} within '{}'".format(typename, within)
        else:
            errmsg = "within '{}'".format(within)
    return (valid, _value, errmsg)
def __within(within=None, errmsg=None, dtype=None):
    return functools.partial(__within2, within=within, errmsg=errmsg, dtype=dtype)
def __space_delimited_list(value):
    if isinstance(value, str):
        value = value.strip().split()
    if hasattr(value, "__iter__") and value != []:
        return (True, value, "space-delimited string")
    else:
        return (
            False,
            value,
            "{} is not a valid space-delimited value.\n".format(value),
        )
SALT_ATTR_TO_DEBIAN_ATTR_MAP = {
    "dns": "dns-nameservers",
    "search": "dns-search",
    "hwaddr": "hwaddress",  # TODO: this limits bootp functionality
    "ipaddr": "address",
    "ipaddrs": "addresses",
}
DEBIAN_ATTR_TO_SALT_ATTR_MAP = {v: k for (k, v) in SALT_ATTR_TO_DEBIAN_ATTR_MAP.items()}
DEBIAN_ATTR_TO_SALT_ATTR_MAP["address"] = "address"
DEBIAN_ATTR_TO_SALT_ATTR_MAP["hwaddress"] = "hwaddress"
IPV4_VALID_PROTO = ["bootp", "dhcp", "static", "manual", "loopback", "ppp"]
IPV4_ATTR_MAP = {
    "proto": __within(IPV4_VALID_PROTO, dtype=str),
    "address": __ipv4_quad,
    "addresses": __anything,
    "netmask": __ipv4_netmask,
    "broadcast": __ipv4_quad,
    "metric": __int,
    "gateway": __ipv4_quad,  # supports a colon-delimited list
    "pointopoint": __ipv4_quad,
    "hwaddress": __mac,
    "mtu": __int,
    "scope": __within(["global", "link", "host"], dtype=str),
    "hostname": __anything,
    "leasehours": __int,
    "leasetime": __int,
    "vendor": __anything,
    "client": __anything,
    "bootfile": __anything,
    "server": __ipv4_quad,
    "hwaddr": __mac,
    "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
    "endpoint": __ipv4_quad,
    "dstaddr": __ipv4_quad,
    "local": __ipv4_quad,
    "ttl": __int,
    "slaves": __anything,
    "provider": __anything,
    "unit": __int,
    "options": __anything,
    "dns-nameservers": __space_delimited_list,
    "dns-search": __space_delimited_list,
    "vlan-raw-device": __anything,
    "network": __anything,  # i don't know what this is
    "test": __anything,  # TODO
    "enable_ipv4": __anything,  # TODO
    "enable_ipv6": __anything,  # TODO
}
IPV6_VALID_PROTO = ["auto", "loopback", "static", "manual", "dhcp", "v4tunnel", "6to4"]
IPV6_ATTR_MAP = {
    "proto": __within(IPV6_VALID_PROTO),
    "address": __ipv6,
    "addresses": __anything,
    "netmask": __ipv6_netmask,
    "broadcast": __ipv6,
    "gateway": __ipv6,  # supports a colon-delimited list
    "hwaddress": __mac,
    "mtu": __int,
    "scope": __within(["global", "site", "link", "host"], dtype=str),
    "privext": __within([0, 1, 2], dtype=int),
    "dhcp": __within([0, 1], dtype=int),
    "media": __anything,
    "accept_ra": __within([0, 1, 2], dtype=int),
    "autoconf": __within([0, 1], dtype=int),
    "preferred-lifetime": __int,
    "dad-attempts": __int,  # 0 to disable
    "dad-interval": __float,
    "slaves": __anything,
    "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
    "endpoint": __ipv4_quad,
    "local": __ipv4_quad,
    "ttl": __int,
    "dns-nameservers": __space_delimited_list,
    "dns-search": __space_delimited_list,
    "vlan-raw-device": __anything,
    "test": __anything,  # TODO
    "enable_ipv4": __anything,  # TODO
    "enable_ipv6": __anything,  # TODO
}
WIRELESS_ATTR_MAP = {
    "wireless-essid": __anything,
    "wireless-mode": __anything,  # TODO
    "wpa-ap-scan": __within([0, 1, 2], dtype=int),  # TODO
    "wpa-conf": __anything,
    "wpa-driver": __anything,
    "wpa-group": __anything,
    "wpa-key-mgmt": __anything,
    "wpa-pairwise": __anything,
    "wpa-psk": __anything,
    "wpa-proto": __anything,  # partial(__within,
    "wpa-roam": __anything,
    "wpa-ssid": __anything,  # TODO
}
ATTRMAPS = {
    "inet": [IPV4_ATTR_MAP, WIRELESS_ATTR_MAP],
    "inet6": [IPV6_ATTR_MAP, WIRELESS_ATTR_MAP],
}
def _validate_interface_option(attr, value, addrfam="inet"):
    """lookup the validation function for a [addrfam][attr] and
    return the results
    :param attr: attribute name
    :param value: raw setting value
    :param addrfam: address family (inet, inet6,
    """
    valid, _value, errmsg = False, value, "Unknown validator"
    attrmaps = ATTRMAPS.get(addrfam, [])
    for attrmap in attrmaps:
        if attr in attrmap:
            validate_func = attrmap[attr]
            (valid, _value, errmsg) = validate_func(value)
            break
    return (valid, _value, errmsg)
def _attrmaps_contain_attr(attr):
    return attr in WIRELESS_ATTR_MAP or attr in IPV4_ATTR_MAP or attr in IPV6_ATTR_MAP
def _parse_interfaces(interface_files=None):
    """
    Parse /etc/network/interfaces and return current configured interfaces
    """
    if interface_files is None:
        interface_files = []
        if os.path.exists(_DEB_NETWORK_DIR):
            interface_files += [
                "{}/{}".format(_DEB_NETWORK_DIR, dir)
                for dir in os.listdir(_DEB_NETWORK_DIR)
            ]
        if os.path.isfile(_DEB_NETWORK_FILE):
            interface_files.insert(0, _DEB_NETWORK_FILE)
    adapters = salt.utils.odict.OrderedDict()
    method = -1
    for interface_file in interface_files:
        with salt.utils.files.fopen(interface_file) as interfaces:
            iface_dict = {}
            for line in interfaces:
                line = salt.utils.stringutils.to_unicode(line)
                if line.lstrip().startswith("#") or line.isspace():
                    continue
                if line.startswith("iface"):
                    sline = line.split()
                    if len(sline) != 4:
                        msg = "Interface file malformed: {0}."
                        msg = msg.format(sline)
                        log.error(msg)
                        raise AttributeError(msg)
                    iface_name = sline[1]
                    addrfam = sline[2]
                    method = sline[3]
                    if iface_name not in adapters:
                        adapters[iface_name] = salt.utils.odict.OrderedDict()
                    if "data" not in adapters[iface_name]:
                        adapters[iface_name]["data"] = salt.utils.odict.OrderedDict()
                    if addrfam not in adapters[iface_name]["data"]:
                        adapters[iface_name]["data"][
                            addrfam
                        ] = salt.utils.odict.OrderedDict()
                    iface_dict = adapters[iface_name]["data"][addrfam]
                    iface_dict["addrfam"] = addrfam
                    iface_dict["proto"] = method
                    iface_dict["filename"] = interface_file
                elif line[0].isspace():
                    sline = line.split()
                    attr, valuestr = line.rstrip().split(None, 1)
                    if _attrmaps_contain_attr(attr):
                        if "-" in attr:
                            attrname = attr.replace("-", "_")
                        else:
                            attrname = attr
                        (valid, value, errmsg) = _validate_interface_option(
                            attr, valuestr, addrfam
                        )
                        if attrname == "address" and "address" in iface_dict:
                            if "addresses" not in iface_dict:
                                iface_dict["addresses"] = []
                            iface_dict["addresses"].append(value)
                        else:
                            iface_dict[attrname] = value
                    elif attr in _REV_ETHTOOL_CONFIG_OPTS:
                        if "ethtool" not in iface_dict:
                            iface_dict["ethtool"] = salt.utils.odict.OrderedDict()
                        iface_dict["ethtool"][attr] = valuestr
                    elif attr.startswith("bond"):
                        opt = re.split(r"[_-]", attr, maxsplit=1)[1]
                        if "bonding" not in iface_dict:
                            iface_dict["bonding"] = salt.utils.odict.OrderedDict()
                        iface_dict["bonding"][opt] = valuestr
                    elif attr.startswith("bridge"):
                        opt = re.split(r"[_-]", attr, maxsplit=1)[1]
                        if "bridging" not in iface_dict:
                            iface_dict["bridging"] = salt.utils.odict.OrderedDict()
                        iface_dict["bridging"][opt] = valuestr
                    elif attr in [
                        "up",
                        "pre-up",
                        "post-up",
                        "down",
                        "pre-down",
                        "post-down",
                    ]:
                        cmd = valuestr
                        cmd_key = "{}_cmds".format(re.sub("-", "_", attr))
                        if cmd_key not in iface_dict:
                            iface_dict[cmd_key] = []
                        iface_dict[cmd_key].append(cmd)
                elif line.startswith("auto"):
                    for word in line.split()[1:]:
                        if word not in adapters:
                            adapters[word] = salt.utils.odict.OrderedDict()
                        adapters[word]["enabled"] = True
                elif line.startswith("allow-hotplug"):
                    for word in line.split()[1:]:
                        if word not in adapters:
                            adapters[word] = salt.utils.odict.OrderedDict()
                        adapters[word]["hotplug"] = True
                elif line.startswith("source"):
                    if "source" not in adapters:
                        adapters["source"] = salt.utils.odict.OrderedDict()
                    if "data" not in adapters["source"]:
                        adapters["source"]["data"] = salt.utils.odict.OrderedDict()
                        adapters["source"]["data"]["sources"] = []
                    adapters["source"]["data"]["sources"].append(line.split()[1])
    adapters = _filter_malformed_interfaces(adapters=adapters)
    return adapters
def _filter_malformed_interfaces(*, adapters):
    for iface_name in list(adapters):
        if iface_name == "source":
            continue
        if "data" not in adapters[iface_name]:
            msg = "Interface file malformed for interface: {}.".format(iface_name)
            log.error(msg)
            adapters.pop(iface_name)
            continue
        for opt in ["ethtool", "bonding", "bridging"]:
            for inet in ["inet", "inet6"]:
                if inet in adapters[iface_name]["data"]:
                    if opt in adapters[iface_name]["data"][inet]:
                        opt_keys = sorted(
                            adapters[iface_name]["data"][inet][opt].keys()
                        )
                        adapters[iface_name]["data"][inet][opt + "_keys"] = opt_keys
    return adapters
def _parse_ethtool_opts(opts, iface):
    """
    Filters given options and outputs valid settings for ETHTOOLS_OPTS
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    config = {}
    if "autoneg" in opts:
        if opts["autoneg"] in _CONFIG_TRUE:
            config.update({"autoneg": "on"})
        elif opts["autoneg"] in _CONFIG_FALSE:
            config.update({"autoneg": "off"})
        else:
            _raise_error_iface(iface, "autoneg", _CONFIG_TRUE + _CONFIG_FALSE)
    if "duplex" in opts:
        valid = ["full", "half"]
        if opts["duplex"] in valid:
            config.update({"duplex": opts["duplex"]})
        else:
            _raise_error_iface(iface, "duplex", valid)
    if "speed" in opts:
        valid = ["10", "100", "1000", "10000"]
        if str(opts["speed"]) in valid:
            config.update({"speed": opts["speed"]})
        else:
            _raise_error_iface(iface, opts["speed"], valid)
    valid = _CONFIG_TRUE + _CONFIG_FALSE
    for option in ("rx", "tx", "sg", "tso", "ufo", "gso", "gro", "lro"):
        if option in opts:
            if opts[option] in _CONFIG_TRUE:
                config.update({option: "on"})
            elif opts[option] in _CONFIG_FALSE:
                config.update({option: "off"})
            else:
                _raise_error_iface(iface, option, valid)
    return config
def _parse_ethtool_pppoe_opts(opts, iface):
    """
    Filters given options and outputs valid settings for ETHTOOLS_PPPOE_OPTS
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    config = {}
    for opt in _DEB_CONFIG_PPPOE_OPTS:
        if opt in opts:
            config[opt] = opts[opt]
    if "provider" in opts and not opts["provider"]:
        _raise_error_iface(iface, "provider", _CONFIG_TRUE + _CONFIG_FALSE)
    valid = _CONFIG_TRUE + _CONFIG_FALSE
    for option in (
        "noipdefault",
        "usepeerdns",
        "defaultroute",
        "hide-password",
        "noauth",
        "persist",
        "noaccomp",
    ):
        if option in opts:
            if opts[option] in _CONFIG_TRUE:
                config.update({option: "True"})
            elif opts[option] in _CONFIG_FALSE:
                config.update({option: "False"})
            else:
                _raise_error_iface(iface, option, valid)
    return config
def _parse_settings_bond(opts, iface):
    """
    Filters given options and outputs valid settings for requested
    operation. If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    bond_def = {
        "ad_select": "0",
        "tx_queues": "16",
        "miimon": "100",
        "arp_interval": "250",
        "downdelay": "200",
        "lacp_rate": "0",
        "max_bonds": "1",
        "updelay": "0",
        "use_carrier": "on",
        "xmit_hash_policy": "layer2",
    }
    if opts["mode"] in ["balance-rr", "0"]:
        log.info("Device: %s Bonding Mode: load balancing (round-robin)", iface)
        return _parse_settings_bond_0(opts, iface, bond_def)
    elif opts["mode"] in ["active-backup", "1"]:
        log.info("Device: %s Bonding Mode: fault-tolerance (active-backup)", iface)
        return _parse_settings_bond_1(opts, iface, bond_def)
    elif opts["mode"] in ["balance-xor", "2"]:
        log.info("Device: %s Bonding Mode: load balancing (xor)", iface)
        return _parse_settings_bond_2(opts, iface, bond_def)
    elif opts["mode"] in ["broadcast", "3"]:
        log.info("Device: %s Bonding Mode: fault-tolerance (broadcast)", iface)
        return _parse_settings_bond_3(opts, iface, bond_def)
    elif opts["mode"] in ["802.3ad", "4"]:
        log.info(
            "Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation", iface
        )
        return _parse_settings_bond_4(opts, iface, bond_def)
    elif opts["mode"] in ["balance-tlb", "5"]:
        log.info("Device: %s Bonding Mode: transmit load balancing", iface)
        return _parse_settings_bond_5(opts, iface, bond_def)
    elif opts["mode"] in ["balance-alb", "6"]:
        log.info("Device: %s Bonding Mode: adaptive load balancing", iface)
        return _parse_settings_bond_6(opts, iface, bond_def)
    else:
        valid = [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "balance-rr",
            "active-backup",
            "balance-xor",
            "broadcast",
            "802.3ad",
            "balance-tlb",
            "balance-alb",
        ]
        _raise_error_iface(iface, "mode", valid)
def _parse_settings_bond_0(opts, iface, bond_def):
    """
    Filters given options and outputs valid settings for bond0.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    bond = {"mode": "0"}
    valid = ["list of ips (up to 16)"]
    if "arp_ip_target" in opts:
        if isinstance(opts["arp_ip_target"], list):
            if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
                bond.update({"arp_ip_target": ""})
                for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
                    if len(bond["arp_ip_target"]) &gt; 0:
                        bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
                    else:
                        bond["arp_ip_target"] = ip
            else:
                _raise_error_iface(iface, "arp_ip_target", valid)
        else:
            _raise_error_iface(iface, "arp_ip_target", valid)
    else:
        _raise_error_iface(iface, "arp_ip_target", valid)
    if "arp_interval" in opts:
        try:
            int(opts["arp_interval"])
            bond.update({"arp_interval": opts["arp_interval"]})
        except ValueError:
            _raise_error_iface(iface, "arp_interval", ["integer"])
    else:
        _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
        bond.update({"arp_interval": bond_def["arp_interval"]})
    return bond
def _parse_settings_bond_1(opts, iface, bond_def):
    """
    Filters given options and outputs valid settings for bond1.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    bond = {"mode": "1"}
    for binding in ["miimon", "downdelay", "updelay"]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, ["integer"])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})
    if "primary" in opts:
        bond.update({"primary": opts["primary"]})
    if not (__grains__["os"] == "Ubuntu" and __grains__["osrelease_info"][0] &gt;= 16):
        if "use_carrier" in opts:
            if opts["use_carrier"] in _CONFIG_TRUE:
                bond.update({"use_carrier": "1"})
            elif opts["use_carrier"] in _CONFIG_FALSE:
                bond.update({"use_carrier": "0"})
            else:
                valid = _CONFIG_TRUE + _CONFIG_FALSE
                _raise_error_iface(iface, "use_carrier", valid)
        else:
            _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
            bond.update({"use_carrier": bond_def["use_carrier"]})
    return bond
def _parse_settings_bond_2(opts, iface, bond_def):
    """
    Filters given options and outputs valid settings for bond2.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    bond = {"mode": "2"}
    valid = ["list of ips (up to 16)"]
    if "arp_ip_target" in opts:
        if isinstance(opts["arp_ip_target"], list):
            if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
                bond.update({"arp_ip_target": ""})
                for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
                    if len(bond["arp_ip_target"]) &gt; 0:
                        bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
                    else:
                        bond["arp_ip_target"] = ip
            else:
                _raise_error_iface(iface, "arp_ip_target", valid)
        else:
            _raise_error_iface(iface, "arp_ip_target", valid)
    else:
        _raise_error_iface(iface, "arp_ip_target", valid)
    if "arp_interval" in opts:
        try:
            int(opts["arp_interval"])
            bond.update({"arp_interval": opts["arp_interval"]})
        except ValueError:
            _raise_error_iface(iface, "arp_interval", ["integer"])
    else:
        _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
        bond.update({"arp_interval": bond_def["arp_interval"]})
    if "hashing-algorithm" in opts:
        valid = ["layer2", "layer2+3", "layer3+4"]
        if opts["hashing-algorithm"] in valid:
            bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
        else:
            _raise_error_iface(iface, "hashing-algorithm", valid)
    return bond
def _parse_settings_bond_3(opts, iface, bond_def):
    """
    Filters given options and outputs valid settings for bond3.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    bond = {"mode": "3"}
    for binding in ["miimon", "downdelay", "updelay"]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, ["integer"])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})
    if "use_carrier" in opts:
        if opts["use_carrier"] in _CONFIG_TRUE:
            bond.update({"use_carrier": "1"})
        elif opts["use_carrier"] in _CONFIG_FALSE:
            bond.update({"use_carrier": "0"})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, "use_carrier", valid)
    else:
        _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
        bond.update({"use_carrier": bond_def["use_carrier"]})
    return bond
def _parse_settings_bond_4(opts, iface, bond_def):
    """
    Filters given options and outputs valid settings for bond4.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    bond = {"mode": "4"}
    for binding in ["miimon", "downdelay", "updelay", "lacp_rate", "ad_select"]:
        if binding in opts:
            if binding == "lacp_rate":
                if opts[binding] == "fast":
                    opts.update({binding: "1"})
                if opts[binding] == "slow":
                    opts.update({binding: "0"})
                valid = ["fast", "1", "slow", "0"]
            else:
                valid = ["integer"]
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, valid)
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})
    if "use_carrier" in opts:
        if opts["use_carrier"] in _CONFIG_TRUE:
            bond.update({"use_carrier": "1"})
        elif opts["use_carrier"] in _CONFIG_FALSE:
            bond.update({"use_carrier": "0"})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, "use_carrier", valid)
    else:
        _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
        bond.update({"use_carrier": bond_def["use_carrier"]})
    if "hashing-algorithm" in opts:
        valid = ["layer2", "layer2+3", "layer3+4"]
        if opts["hashing-algorithm"] in valid:
            bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
        else:
            _raise_error_iface(iface, "hashing-algorithm", valid)
    return bond
def _parse_settings_bond_5(opts, iface, bond_def):
    """
    Filters given options and outputs valid settings for bond5.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    bond = {"mode": "5"}
    for binding in ["miimon", "downdelay", "updelay"]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, ["integer"])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})
    if "use_carrier" in opts:
        if opts["use_carrier"] in _CONFIG_TRUE:
            bond.update({"use_carrier": "1"})
        elif opts["use_carrier"] in _CONFIG_FALSE:
            bond.update({"use_carrier": "0"})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, "use_carrier", valid)
    else:
        _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
        bond.update({"use_carrier": bond_def["use_carrier"]})
    if "primary" in opts:
        bond.update({"primary": opts["primary"]})
    return bond
def _parse_settings_bond_6(opts, iface, bond_def):
    """
    Filters given options and outputs valid settings for bond6.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    """
    bond = {"mode": "6"}
    for binding in ["miimon", "downdelay", "updelay"]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, ["integer"])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})
    if "use_carrier" in opts:
        if opts["use_carrier"] in _CONFIG_TRUE:
            bond.update({"use_carrier": "1"})
        elif opts["use_carrier"] in _CONFIG_FALSE:
            bond.update({"use_carrier": "0"})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, "use_carrier", valid)
    else:
        _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
        bond.update({"use_carrier": bond_def["use_carrier"]})
    if "primary" in opts:
        bond.update({"primary": opts["primary"]})
    return bond
def _parse_bridge_opts(opts, iface):
    """
    Filters given options and outputs valid settings for BRIDGING_OPTS
    If an option has a value that is not expected, this
    function will log the Interface, Setting and what was expected.
    """
    config = {}
    if "ports" in opts:
        if isinstance(opts["ports"], list):
            opts["ports"] = " ".join(opts["ports"])
        config.update({"ports": opts["ports"]})
    for opt in ["ageing", "fd", "gcint", "hello", "maxage"]:
        if opt in opts:
            try:
                float(opts[opt])
                config.update({opt: opts[opt]})
            except ValueError:
                _raise_error_iface(iface, opt, ["float"])
    for opt in ["bridgeprio", "maxwait"]:
        if opt in opts:
            if isinstance(opts[opt], int):
                config.update({opt: opts[opt]})
            else:
                _raise_error_iface(iface, opt, ["integer"])
    if "hw" in opts:
        if re.match(
            "[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", opts["hw"].lower()
        ):
            config.update({"hw": opts["hw"]})
        else:
            _raise_error_iface(iface, "hw", ["valid MAC address"])
    for opt in ["pathcost", "portprio"]:
        if opt in opts:
            try:
                port, cost_or_prio = opts[opt].split()
                int(cost_or_prio)
                config.update({opt: "{} {}".format(port, cost_or_prio)})
            except ValueError:
                _raise_error_iface(iface, opt, ["interface integer"])
    if "stp" in opts:
        if opts["stp"] in _CONFIG_TRUE:
            config.update({"stp": "on"})
        elif opts["stp"] in _CONFIG_FALSE:
            config.update({"stp": "off"})
        else:
    if "waitport" in opts:
        if isinstance(opts<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["waitport"], int):
            config.update({"waitport": opts["waitport"]})
        else:
            values = opts["waitport"].split()
            waitport_time = values.pop(</b></font>0)
            if waitport_time.isdigit() and values:
                config.update(
                    {"waitport": "{} {}".format(waitport_time, " ".join(values))}
                )
            else:
                _raise_error_iface(iface, opt, ["integer [interfaces]"])
    return config
def _parse_settings_eth(opts, iface_type, enabled, iface):
    """
    Filters given options and outputs valid settings for a
    network interface.
    """
    adapters = salt.utils.odict.OrderedDict()
    adapters[iface] = salt.utils.odict.OrderedDict()
    adapters[iface]["type"] = iface_type
    adapters[iface]["data"] = salt.utils.odict<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.OrderedDict()
    iface_data = adapters[iface]["data"]
    iface_data["inet"] = salt.utils.odict.OrderedDict()
    iface_data["inet6"] = salt.</b></font>utils.odict.OrderedDict()
    if enabled:
        adapters[iface]["enabled"] = True
    if opts.get("hotplug", False):
        adapters[iface]["hotplug"] = True
    if opts.get("enable_ipv6", None) and opts.get("iface_type", "") == "vlan":
        iface_data["inet6"]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
    for addrfam in ["inet", "inet6"]:
        if iface_type not in ["bridge"]:
            tmp_ethtool = _parse_ethtool_opts(opts, iface)
            if tmp_ethtool:
                ethtool = {}
                for item in tmp_ethtool:
                    ethtool[_ETHTOOL_CONFIG_OPTS[item]] = tmp_ethtool[item]
                iface_data[addrfam]["ethtool"] = ethtool
                iface_data[addrfam]["ethtool_keys"] = sorted(ethtool)
        if iface_type == "bridge":
            bridging = _parse_bridge_opts(opts, iface)
            if bridging:
                iface_data[addrfam]["bridging"] = bridging
                iface_data[addrfam]["bridging_keys"] = sorted(bridging)
                iface_data[addrfam]["addrfam"] = addrfam
        elif iface_type == "bond":
            bonding = _parse_settings_bond(opts, iface)
            if bonding:
                iface_data[addrfam]["bonding"] = bonding
                iface_data[addrfam]["bonding"]["slaves"] = opts["slaves"]
                iface_data[addrfam]["bonding_keys"] = sorted(bonding)
                iface_data[addrfam]["addrfam"] = addrfam
        elif iface_type == "slave":
            adapters[iface]["master"] = opts["master"]
            opts["proto"] = "manual"
            iface_data[addrfam]["master"] = adapters[iface]["master"]
            iface_data[addrfam]["addrfam"] = addrfam
        elif iface_type == "vlan":
            iface_data[addrfam]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
            iface_data[addrfam]["addrfam"] = addrfam
        elif iface_type == "pppoe":
            tmp_ethtool = _parse_ethtool_pppoe_opts(opts, iface)
            if tmp_ethtool:
                for item in tmp_ethtool:
                    adapters[iface]["data"][addrfam][
                        _DEB_CONFIG_PPPOE_OPTS[item]
                    ] = tmp_ethtool[item]
            iface_data[addrfam]["addrfam"] = addrfam
    opts.pop("mode", None)
    for opt, val in opts.items():
        inet = None
        if opt.startswith("ipv4"):
            opt = opt[4:]
            inet = "inet"
            iface_data["inet"]["addrfam"] = "inet"
        elif opt.startswith("ipv6"):
            iface_data["inet6"]["addrfam"] = "inet6"
            opt = opt[4:]
            inet = "inet6"
        elif opt in [
            "ipaddr",
            "address",
            "ipaddresses",
            "addresses",
            "gateway",
            "proto",
        ]:
            iface_data["inet"]["addrfam"] = "inet"
            inet = "inet"
        _opt = SALT_ATTR_TO_DEBIAN_ATTR_MAP.get(opt, opt)
        _debopt = _opt.replace("-", "_")
        for addrfam in ["inet", "inet6"]:
            (valid, value, errmsg) = _validate_interface_option(
                _opt, val, addrfam=addrfam
            )
            if not valid:
                continue
            if inet is None and _debopt not in iface_data[addrfam]:
                iface_data[addrfam][_debopt] = value
            elif inet == addrfam:
                iface_data[addrfam][_debopt] = value
    for opt in [
        "up_cmds",
        "pre_up_cmds",
        "post_up_cmds",
        "down_cmds",
        "pre_down_cmds",
        "post_down_cmds",
    ]:
        if opt in opts:
            iface_data["inet"][opt] = opts[opt]
            iface_data["inet6"][opt] = opts[opt]
    for (addrfam, opt) in [("inet", "enable_ipv4"), ("inet6", "enable_ipv6")]:
        if opts.get(opt, None) is False:
            iface_data.pop(addrfam)
        elif iface_data[addrfam].get("addrfam", "") != addrfam:
            iface_data.pop(addrfam)
    return adapters
def _parse_settings_source(opts, iface_type, enabled, iface):
    """
    Filters given options and outputs valid settings for a
    network interface.
    """
    adapters = salt.utils.odict.OrderedDict()
    adapters[iface] = salt.utils.odict.OrderedDict()
    adapters[iface]["type"] = iface_type
    adapters[iface]["data"] = salt.utils.odict.OrderedDict()
    iface_data = adapters[iface]["data"]
    iface_data["sources"] = [opts["source"]]
    return adapters
def _parse_network_settings(opts, current):
    """
    Filters given options and outputs valid settings for
    the global network settings file.
    """
    opts = {k.lower(): v for (k, v) in opts.items()}
    current = {k.lower(): v for (k, v) in current.items()}
    result = {}
    valid = _CONFIG_TRUE + _CONFIG_FALSE
    if "enabled" not in opts:
        try:
            opts["networking"] = current["networking"]
            _log_default_network("networking", current["networking"])
        except ValueError:
            _raise_error_network("networking", valid)
    else:
        opts["networking"] = opts["enabled"]
    if opts["networking"] in valid:
        if opts["networking"] in _CONFIG_TRUE:
            result["networking"] = "yes"
        elif opts["networking"] in _CONFIG_FALSE:
            result["networking"] = "no"
    else:
        _raise_error_network("networking", valid)
    if "hostname" not in opts:
        try:
            opts["hostname"] = current["hostname"]
            _log_default_network("hostname", current["hostname"])
        except ValueError:
            _raise_error_network("hostname", ["server1.example.com"])
    if opts["hostname"]:
        result["hostname"] = opts["hostname"]
    else:
        _raise_error_network("hostname", ["server1.example.com"])
    if "search" in opts:
        result["search"] = opts["search"]
    return result
def _parse_routes(iface, opts):
    """
    Filters given options and outputs valid settings for
    the route settings file.
    """
    opts = {k.lower(): v for (k, v) in opts.items()}
    result = {}
    if "routes" not in opts:
        _raise_error_routes(iface, "routes", "List of routes")
    for opt in opts:
        result[opt] = opts[opt]
    return result
def _write_file(iface, data, folder, pattern):
    """
    Writes a file to disk
    """
    filename = os.path.join(folder, pattern.format(iface))
    if not os.path.exists(folder):
        msg = "{0} cannot be written. {1} does not exist"
        msg = msg.format(filename, folder)
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, "w") as fout:
        fout.write(salt.utils.stringutils.to_str(data))
    return filename
def _write_file_routes(iface, data, folder, pattern):
    """
    Writes a file to disk
    """
    iface = iface.replace(".", "_")
    filename = os.path.join(folder, pattern.format(iface))
    if not os.path.exists(folder):
        msg = "{0} cannot be written. {1} does not exist"
        msg = msg.format(filename, folder)
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, "w") as fout:
        fout.write(salt.utils.stringutils.to_str(data))
    __salt__["file.set_mode"](filename, "0755")
    return filename
def _write_file_network(data, filename, create=False):
    """
    Writes a file to disk
    If file does not exist, only create if create
    argument is True
    """
    if not os.path.exists(filename) and not create:
        msg = "{0} cannot be written. {0} does not exist and create is setto False".format(
            filename
        )
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, "w") as fout:
        fout.write(salt.utils.stringutils.to_str(data))
def _read_temp(data):
    """
    Return what would be written to disk
    """
    tout = io.StringIO()
    tout.write(data)
    tout.seek(0)
    output = tout.readlines()
    tout.close()
    return output
def _read_temp_ifaces(iface, data):
    """
    Return what would be written to disk for interfaces
    """
    try:
        template = JINJA.get_template("debian_eth.jinja")
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template debian_eth.jinja")
        return ""
    ifcfg = template.render({"name": iface, "data": data})
    return [item + "\n" for item in ifcfg.split("\n")]
def _write_file_ifaces(iface, data, **settings):
    """
    Writes a file to disk
    """
    try:
        eth_template = JINJA.get_template("debian_eth.jinja")
        source_template = JINJA.get_template("debian_source.jinja")
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template debian_eth.jinja")
        return ""
    adapters = _parse_interfaces()
    adapters[iface] = data
    ifcfg = ""
    for adapter in adapters:
        if "type" in adapters[adapter] and adapters[adapter]["type"] == "source":
            tmp = source_template.render({"name": adapter, "data": adapters[adapter]})
        else:
            tmp = eth_template.render({"name": adapter, "data": adapters[adapter]})
        ifcfg = ifcfg + tmp
        if adapter == iface:
            saved_ifcfg = tmp
    _SEPARATE_FILE = False
    if "filename" in settings:
        if not settings["filename"].startswith("/"):
            filename = "{}/{}".format(_DEB_NETWORK_DIR, settings["filename"])
        else:
            filename = settings["filename"]
        _SEPARATE_FILE = True
    else:
        if "filename" in adapters[adapter]["data"]:
            filename = adapters[adapter]["data"]
        else:
            filename = _DEB_NETWORK_FILE
    if not os.path.exists(os.path.dirname(filename)):
        msg = "{0} cannot be written."
        msg = msg.format(os.path.dirname(filename))
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, "w") as fout:
        if _SEPARATE_FILE:
            fout.write(salt.utils.stringutils.to_str(saved_ifcfg))
        else:
            fout.write(salt.utils.stringutils.to_str(ifcfg))
    return saved_ifcfg.split("\n")
def _write_file_ppp_ifaces(iface, data):
    """
    Writes a file to disk
    """
    try:
        template = JINJA.get_template("debian_ppp_eth.jinja")
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template debian_ppp_eth.jinja")
        return ""
    adapters = _parse_interfaces()
    adapters[iface] = data
    ifcfg = ""
    tmp = template.render({"data": adapters[iface]})
    ifcfg = tmp + ifcfg
    filename = _DEB_PPP_DIR + "/" + adapters[iface]["data"]["inet"]["provider"]
    if not os.path.exists(os.path.dirname(filename)):
        msg = "{0} cannot be written."
        msg = msg.format(os.path.dirname(filename))
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.fopen(filename, "w") as fout:
        fout.write(salt.utils.stringutils.to_str(ifcfg))
    return filename
def build_bond(iface, **settings):
    """
    Create a bond script in /etc/modprobe.d with the passed settings
    and load the bonding kernel module.
    CLI Example:
    .. code-block:: bash
        salt '*' ip.build_bond bond0 mode=balance-alb
    """
    deb_major = __grains__["osrelease"][:1]
    opts = _parse_settings_bond(settings, iface)
    try:
        template = JINJA.get_template("conf.jinja")
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template conf.jinja")
        return ""
    data = template.render({"name": iface, "bonding": opts})
    if "test" in settings and settings["test"]:
        return _read_temp(data)
    _write_file(iface, data, _DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
    path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
    if deb_major == "5":
        for line_type in ("alias", "options"):
            cmd = [
                "sed",
                "-i",
                "-e",
                r"/^{}\s{}.*/d".format(line_type, iface),
                "/etc/modprobe.conf",
            ]
            __salt__["cmd.run"](cmd, python_shell=False)
        __salt__["file.append"]("/etc/modprobe.conf", path)
    __salt__["kmod.load"]("bonding")
    __salt__["pkg.install"]("ifenslave")
    return _read_file(path)
def build_interface(iface, iface_type, enabled, **settings):
    """
    Build an interface script for a network interface.
    CLI Example:
    .. code-block:: bash
        salt '*' ip.build_interface eth0 eth &lt;settings&gt;
    """
    iface_type = iface_type.lower()
    if iface_type not in _IFACE_TYPES:
        _raise_error_iface(iface, iface_type, _IFACE_TYPES)
    if iface_type == "slave":
        settings["slave"] = "yes"
        if "master" not in settings:
            msg = "master is a required setting for slave interfaces"
            log.error(msg)
            raise AttributeError(msg)
    elif iface_type == "vlan":
        settings["vlan"] = "yes"
        __salt__["pkg.install"]("vlan")
    elif iface_type == "pppoe":
        settings["pppoe"] = "yes"
        if not __salt__["pkg.version"]("ppp"):
            inst = __salt__["pkg.install"]("ppp")
    elif iface_type == "bond":
        if "slaves" not in settings:
            msg = "slaves is a required setting for bond interfaces"
            log.error(msg)
            raise AttributeError(msg)
    elif iface_type == "bridge":
        if "ports" not in settings:
            msg = (
                "ports is a required setting for bridge interfaces on Debian "
                "or Ubuntu based systems"
            )
            log.error(msg)
            raise AttributeError(msg)
        __salt__["pkg.install"]("bridge-utils")
    if iface_type in ["eth", "bond", "bridge", "slave", "vlan", "pppoe"]:
        opts = _parse_settings_eth(settings, iface_type, enabled, iface)
    if iface_type in ["source"]:
        opts = _parse_settings_source(settings, iface_type, enabled, iface)
    if "test" in settings and settings["test"]:
        return _read_temp_ifaces(iface, opts[iface])
    ifcfg = _write_file_ifaces(iface, opts[iface], **settings)
    if iface_type == "pppoe":
        _write_file_ppp_ifaces(iface, opts[iface])
    return [item + "\n" for item in ifcfg]
def build_routes(iface, **settings):
    """
    Add route scripts for a network interface using up commands.
    CLI Example:
    .. code-block:: bash
        salt '*' ip.build_routes eth0 &lt;settings&gt;
    """
    opts = _parse_routes(iface, settings)
    try:
        template = JINJA.get_template("route_eth.jinja")
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template route_eth.jinja")
        return ""
    add_routecfg = template.render(route_type="add", routes=opts["routes"], iface=iface)
    del_routecfg = template.render(route_type="del", routes=opts["routes"], iface=iface)
    if "test" in settings and settings["test"]:
        return _read_temp(add_routecfg + del_routecfg)
    filename = _write_file_routes(iface, add_routecfg, _DEB_NETWORK_UP_DIR, "route-{0}")
    results = _read_file(filename)
    filename = _write_file_routes(
        iface, del_routecfg, _DEB_NETWORK_DOWN_DIR, "route-{0}"
    )
    results += _read_file(filename)
    return results
def down(iface, iface_type):
    """
    Shutdown a network interface
    CLI Example:
    .. code-block:: bash
        salt '*' ip.down eth0 eth
    """
    if iface_type not in ["slave", "source"]:
        return __salt__["cmd.run"](["ifdown", iface])
    return None
def get_bond(iface):
    """
    Return the content of a bond script
    CLI Example:
    .. code-block:: bash
        salt '*' ip.get_bond bond0
    """
    path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
    return _read_file(path)
def get_interface(iface):
    """
    Return the contents of an interface script
    CLI Example:
    .. code-block:: bash
        salt '*' ip.get_interface eth0
    """
    adapters = _parse_interfaces()
    if iface in adapters:
        try:
            if iface == "source":
                template = JINJA.get_template("debian_source.jinja")
            else:
                template = JINJA.get_template("debian_eth.jinja")
        except jinja2.exceptions.TemplateNotFound:
            log.error("Could not load template debian_eth.jinja")
            return ""
        ifcfg = template.render({"name": iface, "data": adapters[iface]})
        return [item + "\n" for item in ifcfg.split("\n")]
    else:
        return []
def up(iface, iface_type):  # pylint: disable=C0103
    """
    Start up a network interface
    CLI Example:
    .. code-block:: bash
        salt '*' ip.up eth0 eth
    """
    if iface_type not in ("slave", "source"):
        return __salt__["cmd.run"](["ifup", iface])
    return None
def get_network_settings():
    """
    Return the contents of the global network script.
    CLI Example:
    .. code-block:: bash
        salt '*' ip.get_network_settings
    """
    skip_etc_default_networking = (
        __grains__["osfullname"] == "Ubuntu"
        and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
    )
    if skip_etc_default_networking:
        settings = {}
        if __salt__["service.available"]("networking"):
            if __salt__["service.status"]("networking"):
                settings["networking"] = "yes"
            else:
                settings["networking"] = "no"
        else:
            settings["networking"] = "no"
        hostname = _parse_hostname()
        domainname = _parse_domainname()
        settings["hostname"] = hostname
        settings["domainname"] = domainname
    else:
        settings = _parse_current_network_settings()
    try:
        template = JINJA.get_template("display-network.jinja")
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template display-network.jinja")
        return ""
    network = template.render(settings)
    return _read_temp(network)
def get_routes(iface):
    """
    Return the routes for the interface
    CLI Example:
    .. code-block:: bash
        salt '*' ip.get_routes eth0
    """
    filename = os.path.join(_DEB_NETWORK_UP_DIR, "route-{}".format(iface))
    results = _read_file(filename)
    filename = os.path.join(_DEB_NETWORK_DOWN_DIR, "route-{}".format(iface))
    results += _read_file(filename)
    return results
def apply_network_settings(**settings):
    """
    Apply global network configuration.
    CLI Example:
    .. code-block:: bash
        salt '*' ip.apply_network_settings
    """
    if "require_reboot" not in settings:
        settings["require_reboot"] = False
    if "apply_hostname" not in settings:
        settings["apply_hostname"] = False
    hostname_res = True
    if settings["apply_hostname"] in _CONFIG_TRUE:
        if "hostname" in settings:
            hostname_res = __salt__["network.mod_hostname"](settings["hostname"])
        else:
            log.warning(
                "The network state sls is trying to apply hostname "
                "changes but no hostname is defined."
            )
            hostname_res = False
    res = True
    if settings["require_reboot"] in _CONFIG_TRUE:
        log.warning(
            "The network state sls is requiring a reboot of the system to "
            "properly apply network configuration."
        )
        res = True
    else:
        stop = __salt__["service.stop"]("networking")
        time.sleep(2)
        res = stop and __salt__["service.start"]("networking")
    return hostname_res and res
def build_network_settings(**settings):
    """
    Build the global network script.
    CLI Example:
    .. code-block:: bash
        salt '*' ip.build_network_settings &lt;settings&gt;
    """
    changes = []
    current_network_settings = _parse_current_network_settings()
    opts = _parse_network_settings(settings, current_network_settings)
    skip_etc_default_networking = (
        __grains__["osfullname"] == "Ubuntu"
        and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
    )
    if skip_etc_default_networking:
        if opts["networking"] == "yes":
            service_cmd = "service.enable"
        else:
            service_cmd = "service.disable"
        if __salt__["service.available"]("NetworkManager"):
            __salt__[service_cmd]("NetworkManager")
        if __salt__["service.available"]("networking"):
            __salt__[service_cmd]("networking")
    else:
        try:
            template = JINJA.get_template("network.jinja")
        except jinja2.exceptions.TemplateNotFound:
            log.error("Could not load template network.jinja")
            return ""
        network = template.render(opts)
        if "test" in settings and settings["test"]:
            return _read_temp(network)
        _write_file_network(network, _DEB_NETWORKING_FILE, True)
    sline = opts["hostname"].split(".", 1)
    opts["hostname"] = sline[0]
    current_domainname = current_network_settings["domainname"]
    current_searchdomain = current_network_settings["searchdomain"]
    new_domain = False
    if len(sline) &gt; 1:
        new_domainname = sline[1]
        if new_domainname != current_domainname:
            domainname = new_domainname
            opts["domainname"] = new_domainname
            new_domain = True
        else:
            domainname = current_domainname
            opts["domainname"] = domainname
    else:
        domainname = current_domainname
        opts["domainname"] = domainname
    new_search = False
    if "search" in opts:
        new_searchdomain = opts["search"]
        if new_searchdomain != current_searchdomain:
            searchdomain = new_searchdomain
            opts["searchdomain"] = new_searchdomain
            new_search = True
        else:
            searchdomain = current_searchdomain
            opts["searchdomain"] = searchdomain
    else:
        searchdomain = current_searchdomain
        opts["searchdomain"] = searchdomain
    if new_domain or new_search:
        resolve = _parse_resolve()
        domain_prog = re.compile(r"domain\s+")
        search_prog = re.compile(r"search\s+")
        new_contents = []
        for item in _read_file(_DEB_RESOLV_FILE):
            if domain_prog.match(item):
                item = "domain {}".format(domainname)
            elif search_prog.match(item):
                item = "search {}".format(searchdomain)
            new_contents.append(item)
        if "domain" not in resolve:
            new_contents.insert(0, "domain {}".format(domainname))
        if "search" not in resolve:
            new_contents.insert("domain" in resolve, "search {}".format(searchdomain))
        new_resolv = "\n".join(new_contents)
        if not ("test" in settings and settings["test"]):
            _write_file_network(new_resolv, _DEB_RESOLV_FILE)
    try:
        template = JINJA.get_template("display-network.jinja")
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template display-network.jinja")
        return ""
    network = template.render(opts)
    changes.extend(_read_temp(network))
    return changes
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
