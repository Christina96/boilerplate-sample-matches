<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for tcp.py & debian_ip.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for tcp.py & debian_ip.py
      </h3>
      <h1 align="center">
        1.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>tcp.py (2.2803113%)<TH>debian_ip.py (1.5763168%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match183307-0.html#0',2,'match183307-1.html#0',3)" NAME="0">(10-25)<TD><A HREF="javascript:ZweiFrames('match183307-0.html#0',2,'match183307-1.html#0',3)" NAME="0">(8-23)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match183307-0.html#1',2,'match183307-1.html#1',3)" NAME="1">(334-340)<TD><A HREF="javascript:ZweiFrames('match183307-0.html#1',2,'match183307-1.html#1',3)" NAME="1">(1241-1244)</A><TD ALIGN=center><FONT COLOR="#ee0000">14</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match183307-0.html#2',2,'match183307-1.html#2',3)" NAME="2">(1046-1048)<TD><A HREF="javascript:ZweiFrames('match183307-0.html#2',2,'match183307-1.html#2',3)" NAME="2">(1216-1220)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tcp.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
TCP transport classes

Wire protocol: &quot;len(payload) msgpack({'head': SOMEHEADER, 'body': SOMEBODY})&quot;


<A NAME="0"></A>&quot;&quot;&quot;


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match183307-1.html#0',3,'match183307-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import errno
import logging
import os
import queue
import socket
import threading
import urllib

import salt.ext.tornado
import salt.ext.tornado.concurrent
import salt.ext.tornado.gen
import salt.ext.tornado.iostream
import salt.ext.tornado.netutil
import salt.ext.tornado.tcpclient
import salt.ext.tornado.tcpserver
import</B></FONT> salt.master
import salt.payload
import salt.transport.client
import salt.transport.frame
import salt.transport.ipc
import salt.transport.server
import salt.utils.asynchronous
import salt.utils.files
import salt.utils.msgpack
import salt.utils.platform
import salt.utils.versions
from salt.exceptions import SaltClientError, SaltReqTimeoutError

if salt.utils.platform.is_windows():
    USE_LOAD_BALANCER = True
else:
    USE_LOAD_BALANCER = False

if USE_LOAD_BALANCER:
    import threading
    import multiprocessing
    import salt.ext.tornado.util
    from salt.utils.process import SignalHandlingProcess

log = logging.getLogger(__name__)


class ClosingError(Exception):
    &quot;&quot;&quot; &quot;&quot;&quot;


def _set_tcp_keepalive(sock, opts):
    &quot;&quot;&quot;
    Ensure that TCP keepalives are set for the socket.
    &quot;&quot;&quot;
    if hasattr(socket, &quot;SO_KEEPALIVE&quot;):
        if opts.get(&quot;tcp_keepalive&quot;, False):
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            if hasattr(socket, &quot;SOL_TCP&quot;):
                if hasattr(socket, &quot;TCP_KEEPIDLE&quot;):
                    tcp_keepalive_idle = opts.get(&quot;tcp_keepalive_idle&quot;, -1)
                    if tcp_keepalive_idle &gt; 0:
                        sock.setsockopt(
                            socket.SOL_TCP, socket.TCP_KEEPIDLE, int(tcp_keepalive_idle)
                        )
                if hasattr(socket, &quot;TCP_KEEPCNT&quot;):
                    tcp_keepalive_cnt = opts.get(&quot;tcp_keepalive_cnt&quot;, -1)
                    if tcp_keepalive_cnt &gt; 0:
                        sock.setsockopt(
                            socket.SOL_TCP, socket.TCP_KEEPCNT, int(tcp_keepalive_cnt)
                        )
                if hasattr(socket, &quot;TCP_KEEPINTVL&quot;):
                    tcp_keepalive_intvl = opts.get(&quot;tcp_keepalive_intvl&quot;, -1)
                    if tcp_keepalive_intvl &gt; 0:
                        sock.setsockopt(
                            socket.SOL_TCP,
                            socket.TCP_KEEPINTVL,
                            int(tcp_keepalive_intvl),
                        )
            if hasattr(socket, &quot;SIO_KEEPALIVE_VALS&quot;):
                # Windows doesn't support TCP_KEEPIDLE, TCP_KEEPCNT, nor
                # TCP_KEEPINTVL. Instead, it has its own proprietary
                # SIO_KEEPALIVE_VALS.
                tcp_keepalive_idle = opts.get(&quot;tcp_keepalive_idle&quot;, -1)
                tcp_keepalive_intvl = opts.get(&quot;tcp_keepalive_intvl&quot;, -1)
                # Windows doesn't support changing something equivalent to
                # TCP_KEEPCNT.
                if tcp_keepalive_idle &gt; 0 or tcp_keepalive_intvl &gt; 0:
                    # Windows defaults may be found by using the link below.
                    # Search for 'KeepAliveTime' and 'KeepAliveInterval'.
                    # https://technet.microsoft.com/en-us/library/bb726981.aspx#EDAA
                    # If one value is set and the other isn't, we still need
                    # to send both values to SIO_KEEPALIVE_VALS and they both
                    # need to be valid. So in that case, use the Windows
                    # default.
                    if tcp_keepalive_idle &lt;= 0:
                        tcp_keepalive_idle = 7200
                    if tcp_keepalive_intvl &lt;= 0:
                        tcp_keepalive_intvl = 1
                    # The values expected are in milliseconds, so multiply by
                    # 1000.
                    sock.ioctl(
                        socket.SIO_KEEPALIVE_VALS,
                        (
                            1,
                            int(tcp_keepalive_idle * 1000),
                            int(tcp_keepalive_intvl * 1000),
                        ),
                    )
        else:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 0)


if USE_LOAD_BALANCER:

    class LoadBalancerServer(SignalHandlingProcess):
        &quot;&quot;&quot;
        Raw TCP server which runs in its own process and will listen
        for incoming connections. Each incoming connection will be
        sent via multiprocessing queue to the workers.
        Since the queue is shared amongst workers, only one worker will
        handle a given connection.
        &quot;&quot;&quot;

        # TODO: opts!
        # Based on default used in salt.ext.tornado.netutil.bind_sockets()
        backlog = 128

        def __init__(self, opts, socket_queue, **kwargs):
            super().__init__(**kwargs)
            self.opts = opts
            self.socket_queue = socket_queue
            self._socket = None

        def close(self):
            if self._socket is not None:
                self._socket.shutdown(socket.SHUT_RDWR)
                self._socket.close()
                self._socket = None

        # pylint: disable=W1701
        def __del__(self):
            self.close()

        # pylint: enable=W1701

        def run(self):
            &quot;&quot;&quot;
            Start the load balancer
            &quot;&quot;&quot;
            self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            _set_tcp_keepalive(self._socket, self.opts)
            self._socket.setblocking(1)
            self._socket.bind((self.opts[&quot;interface&quot;], int(self.opts[&quot;ret_port&quot;])))
            self._socket.listen(self.backlog)

            while True:
                try:
                    # Wait for a connection to occur since the socket is
                    # blocking.
                    connection, address = self._socket.accept()
                    # Wait for a free slot to be available to put
                    # the connection into.
                    # Sockets are picklable on Windows in Python 3.
                    self.socket_queue.put((connection, address), True, None)
                except OSError as e:
                    # ECONNABORTED indicates that there was a connection
                    # but it was closed while still in the accept queue.
                    # (observed on FreeBSD).
                    if (
                        salt.ext.tornado.util.errno_from_exception(e)
                        == errno.ECONNABORTED
                    ):
                        continue
                    raise


class Resolver:

    _resolver_configured = False

    @classmethod
    def _config_resolver(cls, num_threads=10):
        salt.ext.tornado.netutil.Resolver.configure(
            &quot;salt.ext.tornado.netutil.ThreadedResolver&quot;, num_threads=num_threads
        )
        cls._resolver_configured = True

    def __init__(self, *args, **kwargs):
        if not self._resolver_configured:
            # TODO: add opt to specify number of resolver threads
            self._config_resolver()


class TCPPubClient(salt.transport.base.PublishClient):
    &quot;&quot;&quot;
    Tornado based TCP Pub Client
    &quot;&quot;&quot;

    ttype = &quot;tcp&quot;

    def __init__(self, opts, io_loop, **kwargs):  # pylint: disable=W0231
        self.opts = opts
        self.io_loop = io_loop
        self.message_client = None
        self.connected = False
        self._closing = False
        self.resolver = Resolver()

    def close(self):
        if self._closing:
            return
        self._closing = True
        if self.message_client is not None:
            self.message_client.close()
            self.message_client = None

    # pylint: disable=W1701
    def __del__(self):
        self.close()

    # pylint: enable=W1701

    @salt.ext.tornado.gen.coroutine
    def connect(self, publish_port, connect_callback=None, disconnect_callback=None):
        self.publish_port = publish_port
        self.message_client = MessageClient(
            self.opts,
            self.opts[&quot;master_ip&quot;],
            int(self.publish_port),
            io_loop=self.io_loop,
            connect_callback=connect_callback,
            disconnect_callback=disconnect_callback,
            source_ip=self.opts.get(&quot;source_ip&quot;),
            source_port=self.opts.get(&quot;source_publish_port&quot;),
        )
        yield self.message_client.connect()  # wait for the client to be connected
        self.connected = True

    @salt.ext.tornado.gen.coroutine
    def _decode_messages(self, messages):
        if not isinstance(messages, dict):
            # TODO: For some reason we need to decode here for things
            #       to work. Fix this.
            body = salt.utils.msgpack.loads(messages)
            body = salt.transport.frame.decode_embedded_strs(body)
        else:
            body = messages
        raise salt.ext.tornado.gen.Return(body)

    @salt.ext.tornado.gen.coroutine
    def send(self, msg):
        yield self.message_client._stream.write(msg)

    def on_recv(self, callback):
        &quot;&quot;&quot;
        Register an on_recv callback
        &quot;&quot;&quot;
        return self.message_client.on_recv(callback)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


class TCPReqServer(salt.transport.base.DaemonizedRequestServer):
    &quot;&quot;&quot;
    Tornado based TCP Request/Reply Server

    :param dict opts: Salt master config options.
    &quot;&quot;&quot;

    # TODO: opts!
    backlog = 5

    def __init__(self, opts):  # pylint: disable=W0231
        self.opts = opts
        self._socket = None
        self.req_server = None

    @property
    def socket(self):
        return self._socket

    def close(self):
        if self._socket is not None:
            try:
                self._socket.shutdown(socket.SHUT_RDWR)
            except OSError as exc:
                if exc.errno == errno.ENOTCONN:
                    # We may try to shutdown a socket which is already disconnected.
                    # Ignore this condition and continue.
                    pass
                else:
                    raise
            if self.req_server is None:
                # We only close the socket if we don't have a req_server instance.
                # If we did, because the req_server is also handling this socket, when we call
                # req_server.stop(), tornado will give us an AssertionError because it's trying to
                # match the socket.fileno() (after close it's -1) to the fd it holds on it's _sockets cache
                # so it can remove the socket from the IOLoop handlers
                self._socket.close()
            self._socket = None
        if self.req_server is not None:
            try:
                self.req_server.close()
            except OSError as exc:
                if exc.errno != 9:
                    raise
                log.exception(
                    &quot;TCPReqServerChannel close generated an exception: %s&quot;, str(exc)
                )
            self.req_server = None

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def pre_fork(self, process_manager):
        &quot;&quot;&quot;
        Pre-fork we need to create the zmq router device
<A NAME="1"></A>        &quot;&quot;&quot;
        if USE_LOAD_BALANCER:
            self.socket_queue = multiprocessing.Queue()
            process_manager<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match183307-1.html#1',3,'match183307-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.add_process(
                LoadBalancerServer,
                args=(self.opts, self.socket_queue),
                name=&quot;LoadBalancerServer&quot;,
            )
        elif not salt.utils.platform.is_windows():
            self._socket = socket.</B></FONT>socket(socket.AF_INET, socket.SOCK_STREAM)
            self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            _set_tcp_keepalive(self._socket, self.opts)
            self._socket.setblocking(0)
            self._socket.bind((self.opts[&quot;interface&quot;], int(self.opts[&quot;ret_port&quot;])))

    def post_fork(self, message_handler, io_loop):
        &quot;&quot;&quot;
        After forking we need to create all of the local sockets to listen to the
        router

        message_handler: function to call with your payloads
        &quot;&quot;&quot;
        self.message_handler = message_handler

        with salt.utils.asynchronous.current_ioloop(io_loop):
            if USE_LOAD_BALANCER:
                self.req_server = LoadBalancerWorker(
                    self.socket_queue,
                    self.handle_message,
                    ssl_options=self.opts.get(&quot;ssl&quot;),
                )
            else:
                if salt.utils.platform.is_windows():
                    self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                    _set_tcp_keepalive(self._socket, self.opts)
                    self._socket.setblocking(0)
                    self._socket.bind(
                        (self.opts[&quot;interface&quot;], int(self.opts[&quot;ret_port&quot;]))
                    )
                self.req_server = SaltMessageServer(
                    self.handle_message,
                    ssl_options=self.opts.get(&quot;ssl&quot;),
                    io_loop=io_loop,
                )
                self.req_server.add_socket(self._socket)
                self._socket.listen(self.backlog)

    @salt.ext.tornado.gen.coroutine
    def handle_message(self, stream, payload, header=None):
        payload = self.decode_payload(payload)
        reply = yield self.message_handler(payload)
        stream.write(salt.transport.frame.frame_msg(reply, header=header))

    def decode_payload(self, payload):
        return payload


class SaltMessageServer(salt.ext.tornado.tcpserver.TCPServer):
    &quot;&quot;&quot;
    Raw TCP server which will receive all of the TCP streams and re-assemble
    messages that are sent through to us
    &quot;&quot;&quot;

    def __init__(self, message_handler, *args, **kwargs):
        io_loop = (
            kwargs.pop(&quot;io_loop&quot;, None) or salt.ext.tornado.ioloop.IOLoop.current()
        )
        self._closing = False
        super().__init__(*args, **kwargs)
        self.io_loop = io_loop
        self.clients = []
        self.message_handler = message_handler

    @salt.ext.tornado.gen.coroutine
    def handle_stream(self, stream, address):
        &quot;&quot;&quot;
        Handle incoming streams and add messages to the incoming queue
        &quot;&quot;&quot;
        log.trace(&quot;Req client %s connected&quot;, address)
        self.clients.append((stream, address))
        unpacker = salt.utils.msgpack.Unpacker()
        try:
            while True:
                wire_bytes = yield stream.read_bytes(4096, partial=True)
                unpacker.feed(wire_bytes)
                for framed_msg in unpacker:
                    framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
                    header = framed_msg[&quot;head&quot;]
                    self.io_loop.spawn_callback(
                        self.message_handler, stream, framed_msg[&quot;body&quot;], header
                    )
        except salt.ext.tornado.iostream.StreamClosedError:
            log.trace(&quot;req client disconnected %s&quot;, address)
            self.remove_client((stream, address))
        except Exception as e:  # pylint: disable=broad-except
            log.trace(&quot;other master-side exception: %s&quot;, e, exc_info=True)
            self.remove_client((stream, address))
            stream.close()

    def remove_client(self, client):
        try:
            self.clients.remove(client)
        except ValueError:
            log.trace(&quot;Message server client was not in list to remove&quot;)

    def close(self):
        &quot;&quot;&quot;
        Close the server
        &quot;&quot;&quot;
        if self._closing:
            return
        self._closing = True
        for item in self.clients:
            client, address = item
            client.close()
            self.remove_client(item)
        try:
            self.stop()
        except OSError as exc:
            if exc.errno != 9:
                raise


if USE_LOAD_BALANCER:

    class LoadBalancerWorker(SaltMessageServer):
        &quot;&quot;&quot;
        This will receive TCP connections from 'LoadBalancerServer' via
        a multiprocessing queue.
        Since the queue is shared amongst workers, only one worker will handle
        a given connection.
        &quot;&quot;&quot;

        def __init__(self, socket_queue, message_handler, *args, **kwargs):
            super().__init__(message_handler, *args, **kwargs)
            self.socket_queue = socket_queue
            self._stop = threading.Event()
            self.thread = threading.Thread(target=self.socket_queue_thread)
            self.thread.start()

        def close(self):
            self._stop.set()
            self.thread.join()
            super().close()

        def socket_queue_thread(self):
            try:
                while True:
                    try:
                        client_socket, address = self.socket_queue.get(True, 1)
                    except queue.Empty:
                        if self._stop.is_set():
                            break
                        continue
                    # 'self.io_loop' initialized in super class
                    # 'salt.ext.tornado.tcpserver.TCPServer'.
                    # 'self._handle_connection' defined in same super class.
                    self.io_loop.spawn_callback(
                        self._handle_connection, client_socket, address
                    )
            except (KeyboardInterrupt, SystemExit):
                pass


class TCPClientKeepAlive(salt.ext.tornado.tcpclient.TCPClient):
    &quot;&quot;&quot;
    Override _create_stream() in TCPClient to enable keep alive support.
    &quot;&quot;&quot;

    def __init__(self, opts, resolver=None):
        self.opts = opts
        super().__init__(resolver=resolver)

    def _create_stream(
        self, max_buffer_size, af, addr, **kwargs
    ):  # pylint: disable=unused-argument,arguments-differ
        &quot;&quot;&quot;
        Override _create_stream() in TCPClient.

        Tornado 4.5 added the kwargs 'source_ip' and 'source_port'.
        Due to this, use **kwargs to swallow these and any future
        kwargs to maintain compatibility.
        &quot;&quot;&quot;
        # Always connect in plaintext; we'll convert to ssl if necessary
        # after one connection has completed.
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        _set_tcp_keepalive(sock, self.opts)
        stream = salt.ext.tornado.iostream.IOStream(
            sock, max_buffer_size=max_buffer_size
        )
        if salt.ext.tornado.version_info &lt; (5,):
            return stream.connect(addr)
        return stream, stream.connect(addr)


# TODO consolidate with IPCClient
# TODO: limit in-flight messages.
# TODO: singleton? Something to not re-create the tcp connection so much
class MessageClient:
    &quot;&quot;&quot;
    Low-level message sending client
    &quot;&quot;&quot;

    def __init__(
        self,
        opts,
        host,
        port,
        io_loop=None,
        resolver=None,
        connect_callback=None,
        disconnect_callback=None,
        source_ip=None,
        source_port=None,
    ):
        self.opts = opts
        self.host = host
        self.port = port
        self.source_ip = source_ip
        self.source_port = source_port
        self.connect_callback = connect_callback
        self.disconnect_callback = disconnect_callback
        self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
        with salt.utils.asynchronous.current_ioloop(self.io_loop):
            self._tcp_client = TCPClientKeepAlive(opts, resolver=resolver)
        self._mid = 1
        self._max_messages = int((1 &lt;&lt; 31) - 2)  # number of IDs before we wrap
        # TODO: max queue size
        self.send_queue = []  # queue of messages to be sent
        self.send_future_map = {}  # mapping of request_id -&gt; Future

        self._read_until_future = None
        self._on_recv = None
        self._closing = False
        self._closed = False
        self._connecting_future = salt.ext.tornado.concurrent.Future()
        self._stream_return_running = False
        self._stream = None

        self.backoff = opts.get(&quot;tcp_reconnect_backoff&quot;, 1)

    def _stop_io_loop(self):
        if self.io_loop is not None:
            self.io_loop.stop()

    # TODO: timeout inflight sessions
    def close(self):
        if self._closing:
            return
        self._closing = True
        self.io_loop.add_timeout(1, self.check_close)

    @salt.ext.tornado.gen.coroutine
    def check_close(self):
        if not self.send_future_map:
            self._tcp_client.close()
            self._stream = None
            self._closing = False
            self._closed = True
        else:
            self.io_loop.add_timeout(1, self.check_close)

    # pylint: disable=W1701
    def __del__(self):
        self.close()

    # pylint: enable=W1701

    @salt.ext.tornado.gen.coroutine
    def getstream(self, **kwargs):
        if self.source_ip or self.source_port:
            kwargs = {
                &quot;source_ip&quot;: self.source_ip,
                &quot;source_port&quot;: self.source_port,
            }
        stream = None
        while stream is None and (not self._closed and not self._closing):
            try:
                stream = yield self._tcp_client.connect(
                    self.host, self.port, ssl_options=self.opts.get(&quot;ssl&quot;), **kwargs
                )
            except Exception as exc:  # pylint: disable=broad-except
                log.warning(
                    &quot;TCP Message Client encountered an exception while connecting to&quot;
                    &quot; %s:%s: %r, will reconnect in %d seconds&quot;,
                    self.host,
                    self.port,
                    exc,
                    self.backoff,
                )
                yield salt.ext.tornado.gen.sleep(self.backoff)
        raise salt.ext.tornado.gen.Return(stream)

    @salt.ext.tornado.gen.coroutine
    def connect(self):
        if self._stream is None:
            self._stream = yield self.getstream()
            if self._stream:
                if not self._stream_return_running:
                    self.io_loop.spawn_callback(self._stream_return)
                if self.connect_callback:
                    self.connect_callback(True)

    @salt.ext.tornado.gen.coroutine
    def _stream_return(self):
        self._stream_return_running = True
        unpacker = salt.utils.msgpack.Unpacker()
        while not self._closing:
            try:
                wire_bytes = yield self._stream.read_bytes(4096, partial=True)
                unpacker.feed(wire_bytes)
                for framed_msg in unpacker:
                    framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
                    header = framed_msg[&quot;head&quot;]
                    body = framed_msg[&quot;body&quot;]
                    message_id = header.get(&quot;mid&quot;)

                    if message_id in self.send_future_map:
                        self.send_future_map.pop(message_id).set_result(body)
                        # self.remove_message_timeout(message_id)
                    else:
                        if self._on_recv is not None:
                            self.io_loop.spawn_callback(self._on_recv, header, body)
                        else:
                            log.error(
                                &quot;Got response for message_id %s that we are not&quot;
                                &quot; tracking&quot;,
                                message_id,
                            )
            except salt.ext.tornado.iostream.StreamClosedError as e:
                log.debug(
                    &quot;tcp stream to %s:%s closed, unable to recv&quot;,
                    self.host,
                    self.port,
                )
                for future in self.send_future_map.values():
                    future.set_exception(e)
                self.send_future_map = {}
                if self._closing or self._closed:
                    return
                if self.disconnect_callback:
                    self.disconnect_callback()
                stream = self._stream
                self._stream = None
                if stream:
                    stream.close()
                yield self.connect()
            except TypeError:
                # This is an invalid transport
                if &quot;detect_mode&quot; in self.opts:
                    log.info(
                        &quot;There was an error trying to use TCP transport; &quot;
                        &quot;attempting to fallback to another transport&quot;
                    )
                else:
                    raise SaltClientError
            except Exception as e:  # pylint: disable=broad-except
                log.error(&quot;Exception parsing response&quot;, exc_info=True)
                for future in self.send_future_map.values():
                    future.set_exception(e)
                self.send_future_map = {}
                if self._closing or self._closed:
                    return
                if self.disconnect_callback:
                    self.disconnect_callback()
                stream = self._stream
                self._stream = None
                if stream:
                    stream.close()
                yield self.connect()
        self._stream_return_running = False

    def _message_id(self):
        wrap = False
        while self._mid in self.send_future_map:
            if self._mid &gt;= self._max_messages:
                if wrap:
                    # this shouldn't ever happen, but just in case
                    raise Exception(&quot;Unable to find available messageid&quot;)
                self._mid = 1
                wrap = True
            else:
                self._mid += 1

        return self._mid

    # TODO: return a message object which takes care of multiplexing?
    def on_recv(self, callback):
        &quot;&quot;&quot;
        Register a callback for received messages (that we didn't initiate)
        &quot;&quot;&quot;
        if callback is None:
            self._on_recv = callback
        else:

            def wrap_recv(header, body):
                callback(body)

            self._on_recv = wrap_recv

    def remove_message_timeout(self, message_id):
        if message_id not in self.send_timeout_map:
            return
        timeout = self.send_timeout_map.pop(message_id)
        self.io_loop.remove_timeout(timeout)

    def timeout_message(self, message_id, msg):
        if message_id not in self.send_future_map:
            return
        future = self.send_future_map.pop(message_id)
        if future is not None:
            future.set_exception(SaltReqTimeoutError(&quot;Message timed out&quot;))

    @salt.ext.tornado.gen.coroutine
    def send(self, msg, timeout=None, callback=None, raw=False):
        if self._closing:
            raise ClosingError()
        message_id = self._message_id()
        header = {&quot;mid&quot;: message_id}

        future = salt.ext.tornado.concurrent.Future()

        if callback is not None:

            def handle_future(future):
                response = future.result()
                self.io_loop.add_callback(callback, response)

            future.add_done_callback(handle_future)
        # Add this future to the mapping
        self.send_future_map[message_id] = future

        if self.opts.get(&quot;detect_mode&quot;) is True:
            timeout = 1

        if timeout is not None:
            self.io_loop.call_later(timeout, self.timeout_message, message_id, msg)

        item = salt.transport.frame.frame_msg(msg, header=header)

        @salt.ext.tornado.gen.coroutine
        def _do_send():
            yield self.connect()
            # If the _stream is None, we failed to connect.
            if self._stream:
                yield self._stream.write(item)

        # Run send in a callback so we can wait on the future, in case we time
        # out before we are able to connect.
        self.io_loop.add_callback(_do_send)
        recv = yield future
        raise salt.ext.tornado.gen.Return(recv)


class Subscriber:
    &quot;&quot;&quot;
    Client object for use with the TCP publisher server
    &quot;&quot;&quot;

    def __init__(self, stream, address):
        self.stream = stream
        self.address = address
        self._closing = False
        self._read_until_future = None
        self.id_ = None

    def close(self):
        if self._closing:
            return
        self._closing = True
        if not self.stream.closed():
            self.stream.close()
            if self._read_until_future is not None and self._read_until_future.done():
                # This will prevent this message from showing up:
                # '[ERROR   ] Future exception was never retrieved:
                # StreamClosedError'
                # This happens because the logic is always waiting to read
                # the next message and the associated read future is marked
                # 'StreamClosedError' when the stream is closed.
                self._read_until_future.exception()

    # pylint: disable=W1701
    def __del__(self):
        self.close()

    # pylint: enable=W1701


class PubServer(salt.ext.tornado.tcpserver.TCPServer):
    &quot;&quot;&quot;
    TCP publisher
    &quot;&quot;&quot;

    def __init__(
        self, opts, io_loop=None, presence_callback=None, remove_presence_callback=None
    ):
        super().__init__(ssl_options=opts.get(&quot;ssl&quot;))
        self.io_loop = io_loop
        self.opts = opts
        self._closing = False
        self.clients = set()
        self.presence_events = False
        if presence_callback:
            self.presence_callback = presence_callback
        else:
            self.presence_callback = lambda subscriber, msg: msg
        if remove_presence_callback:
            self.remove_presence_callback = remove_presence_callback
        else:
            self.remove_presence_callback = lambda subscriber: subscriber

    def close(self):
        if self._closing:
            return
        self._closing = True
        for client in self.clients:
            client.stream.disconnect()

    # pylint: disable=W1701
    def __del__(self):
        self.close()

    # pylint: enable=W1701

    @salt.ext.tornado.gen.coroutine
    def _stream_read(self, client):
        unpacker = salt.utils.msgpack.Unpacker()
        while not self._closing:
            try:
                client._read_until_future = client.stream.read_bytes(4096, partial=True)
                wire_bytes = yield client._read_until_future
                unpacker.feed(wire_bytes)
                for framed_msg in unpacker:
                    framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
                    body = framed_msg[&quot;body&quot;]
                    if self.presence_callback:
                        self.presence_callback(client, body)
            except salt.ext.tornado.iostream.StreamClosedError as e:
                log.debug(&quot;tcp stream to %s closed, unable to recv&quot;, client.address)
                client.close()
                self.remove_presence_callback(client)
                self.clients.discard(client)
                break
            except Exception as e:  # pylint: disable=broad-except
                log.error(
                    &quot;Exception parsing response from %s&quot;, client.address, exc_info=True
                )
                continue

    def handle_stream(self, stream, address):
        log.debug(&quot;Subscriber at %s connected&quot;, address)
        client = Subscriber(stream, address)
        self.clients.add(client)
        self.io_loop.spawn_callback(self._stream_read, client)

    # TODO: ACK the publish through IPC
    @salt.ext.tornado.gen.coroutine
    def publish_payload(self, package, topic_list=None):
        log.trace(&quot;TCP PubServer sending payload: %s \n\n %r&quot;, package, topic_list)
        payload = salt.transport.frame.frame_msg(package)
        to_remove = []
        if topic_list:
            for topic in topic_list:
                sent = False
                for client in self.clients:
                    if topic == client.id_:
                        try:
                            # Write the packed str
                            yield client.stream.write(payload)
                            sent = True
                            # self.io_loop.add_future(f, lambda f: True)
                        except salt.ext.tornado.iostream.StreamClosedError:
                            to_remove.append(client)
                if not sent:
                    log.debug(&quot;Publish target %s not connected %r&quot;, topic, self.clients)
        else:
            for client in self.clients:
                try:
                    # Write the packed str
                    yield client.stream.write(payload)
                except salt.ext.tornado.iostream.StreamClosedError:
                    to_remove.append(client)
        for client in to_remove:
            log.debug(
                &quot;Subscriber at %s has disconnected from publisher&quot;, client.address
            )
            client.close()
            self._remove_client_present(client)
            self.clients.discard(client)
        log.trace(&quot;TCP PubServer finished publishing payload&quot;)


class TCPPublishServer(salt.transport.base.DaemonizedPublishServer):
    &quot;&quot;&quot;
    Tornado based TCP PublishServer
    &quot;&quot;&quot;

    # TODO: opts!
    # Based on default used in salt.ext.tornado.netutil.bind_sockets()
    backlog = 128

    def __init__(self, opts):
        self.opts = opts
        self.pub_sock = None

    @property
    def topic_support(self):
        return not self.opts.get(&quot;order_masters&quot;, False)

    def __setstate__(self, state):
        self.__init__(state[&quot;opts&quot;])

    def __getstate__(self):
        return {&quot;opts&quot;: self.opts}

    def publish_daemon(
        self,
        publish_payload,
        presence_callback=None,
        remove_presence_callback=None,
    ):
        &quot;&quot;&quot;
        Bind to the interface specified in the configuration file
        &quot;&quot;&quot;
        io_loop = salt.ext.tornado.ioloop.IOLoop()
        io_loop.make_current()

        # Spin up the publisher
        self.pub_server = pub_server = PubServer(
            self.opts,
            io_loop=io_loop,
            presence_callback=presence_callback,
            remove_presence_callback=remove_presence_callback,
        )
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        _set_tcp_keepalive(sock, self.opts)
        sock.setblocking(0)
        sock.bind((self.opts[&quot;interface&quot;], int(self.opts[&quot;publish_port&quot;])))
        sock.listen(self.backlog)
        # pub_server will take ownership of the socket
        pub_server.add_socket(sock)

        # Set up Salt IPC server
        if self.opts.get(&quot;ipc_mode&quot;, &quot;&quot;) == &quot;tcp&quot;:
            pull_uri = int(self.opts.get(&quot;tcp_master_publish_pull&quot;, 4514))
        else:
            pull_uri = os.path.join(self.opts[&quot;sock_dir&quot;], &quot;publish_pull.ipc&quot;)
        self.pub_server = pub_server
        pull_sock = salt.transport.ipc.IPCMessageServer(
            pull_uri,
            io_loop=io_loop,
            payload_handler=publish_payload,
        )

        # Securely create socket
        log.warn(&quot;Starting the Salt Puller on %s&quot;, pull_uri)
        with salt.utils.files.set_umask(0o177):
            pull_sock.start()

        # run forever
        try:
            io_loop.start()
        except (KeyboardInterrupt, SystemExit):
            pass
        finally:
            pull_sock.close()

    def pre_fork(self, process_manager):
        &quot;&quot;&quot;
        Do anything necessary pre-fork. Since this is on the master side this will
        primarily be used to create IPC channels and create our daemon process to
        do the actual publishing
        &quot;&quot;&quot;
        process_manager.add_process(self.publish_daemon, name=self.__class__.__name__)

    @salt.ext.tornado.gen.coroutine
    def publish_payload(self, payload, *args):
        ret = yield self.pub_server.publish_payload(payload, *args)
        raise salt.ext.tornado.gen.Return(ret)

    def publish(self, payload, **kwargs):
        &quot;&quot;&quot;
        Publish &quot;load&quot; to minions
        &quot;&quot;&quot;
        if self.opts.get(&quot;ipc_mode&quot;, &quot;&quot;) == &quot;tcp&quot;:
            pull_uri = int(self.opts.get(&quot;tcp_master_publish_pull&quot;, 4514))
        else:
            pull_uri = os.path.join(self.opts[&quot;sock_dir&quot;], &quot;publish_pull.ipc&quot;)
        if not self.pub_sock:
            self.pub_sock = salt.utils.asynchronous.SyncWrapper(
                salt.transport.ipc.IPCMessageClient,
                (pull_uri,),
                loop_kwarg=&quot;io_loop&quot;,
            )
            self.pub_sock.connect()
        self.pub_sock.send(payload)

    def close(self):
        if self.pub_sock:
            self.pub_sock.close()
            self.pub_sock = None


class TCPReqClient(salt.transport.base.RequestClient):
    &quot;&quot;&quot;
    Tornado based TCP RequestClient
    &quot;&quot;&quot;

    ttype = &quot;tcp&quot;

<A NAME="2"></A>    def __init__(self, opts, io_loop, **kwargs):  # pylint: disable=W0231
        self.opts = opts
        self.io_loop = io_loop
        parse = urllib<FONT color="#980517"><A HREF="javascript:ZweiFrames('match183307-1.html#2',3,'match183307-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.parse.urlparse(self.opts[&quot;master_uri&quot;])
        master_host, master_port = parse.netloc.rsplit(&quot;:&quot;, 1)
        master_addr = (master_host, int(</B></FONT>master_port))
        # self.resolver = Resolver()
        resolver = kwargs.get(&quot;resolver&quot;)
        self.message_client = salt.transport.tcp.MessageClient(
            opts,
            master_host,
            int(master_port),
            io_loop=io_loop,
            resolver=resolver,
            source_ip=opts.get(&quot;source_ip&quot;),
            source_port=opts.get(&quot;source_ret_port&quot;),
        )

    @salt.ext.tornado.gen.coroutine
    def connect(self):
        yield self.message_client.connect()

    @salt.ext.tornado.gen.coroutine
    def send(self, load, timeout=60):
        ret = yield self.message_client.send(load, timeout=timeout)
        raise salt.ext.tornado.gen.Return(ret)

    def close(self):
        self.message_client.close()
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>debian_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
The networking module for Debian-based distros

References:
<A NAME="0"></A>
* http://www.debian.org/doc/manuals/debian-reference/ch05.en.html
&quot;&quot;&quot;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match183307-0.html#0',2,'match183307-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import functools
import io
import logging
import os
import os.path
import re
import time

import jinja2
import jinja2.exceptions
import salt.utils.dns
import salt.utils.files
import salt.utils.odict
import salt.utils.stringutils
import salt.utils.templates
import</B></FONT> salt.utils.validate.net

log = logging.getLogger(__name__)

# Set up template environment
JINJA = jinja2.Environment(
    loader=jinja2.FileSystemLoader(
        os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, &quot;debian_ip&quot;)
    )
)

# Define the module's virtual name
__virtualname__ = &quot;ip&quot;


def __virtual__():
    &quot;&quot;&quot;
    Confine this module to Debian-based distros
    &quot;&quot;&quot;
    if __grains__[&quot;os_family&quot;] == &quot;Debian&quot;:
        return __virtualname__
    return (False, &quot;The debian_ip module could not be loaded: unsupported OS family&quot;)


_ETHTOOL_CONFIG_OPTS = {
    &quot;speed&quot;: &quot;link-speed&quot;,
    &quot;duplex&quot;: &quot;link-duplex&quot;,
    &quot;autoneg&quot;: &quot;ethernet-autoneg&quot;,
    &quot;ethernet-port&quot;: &quot;ethernet-port&quot;,
    &quot;wol&quot;: &quot;ethernet-wol&quot;,
    &quot;driver-message-level&quot;: &quot;driver-message-level&quot;,
    &quot;ethernet-pause-rx&quot;: &quot;ethernet-pause-rx&quot;,
    &quot;ethernet-pause-tx&quot;: &quot;ethernet-pause-tx&quot;,
    &quot;ethernet-pause-autoneg&quot;: &quot;ethernet-pause-autoneg&quot;,
    &quot;rx&quot;: &quot;offload-rx&quot;,
    &quot;tx&quot;: &quot;offload-tx&quot;,
    &quot;sg&quot;: &quot;offload-sg&quot;,
    &quot;tso&quot;: &quot;offload-tso&quot;,
    &quot;ufo&quot;: &quot;offload-ufo&quot;,
    &quot;gso&quot;: &quot;offload-gso&quot;,
    &quot;gro&quot;: &quot;offload-gro&quot;,
    &quot;lro&quot;: &quot;offload-lro&quot;,
    &quot;hardware-irq-coalesce-adaptive-rx&quot;: &quot;hardware-irq-coalesce-adaptive-rx&quot;,
    &quot;hardware-irq-coalesce-adaptive-tx&quot;: &quot;hardware-irq-coalesce-adaptive-tx&quot;,
    &quot;hardware-irq-coalesce-rx-usecs&quot;: &quot;hardware-irq-coalesce-rx-usecs&quot;,
    &quot;hardware-irq-coalesce-rx-frames&quot;: &quot;hardware-irq-coalesce-rx-frames&quot;,
    &quot;hardware-dma-ring-rx&quot;: &quot;hardware-dma-ring-rx&quot;,
    &quot;hardware-dma-ring-rx-mini&quot;: &quot;hardware-dma-ring-rx-mini&quot;,
    &quot;hardware-dma-ring-rx-jumbo&quot;: &quot;hardware-dma-ring-rx-jumbo&quot;,
    &quot;hardware-dma-ring-tx&quot;: &quot;hardware-dma-ring-tx&quot;,
}

_REV_ETHTOOL_CONFIG_OPTS = {
    &quot;link-speed&quot;: &quot;speed&quot;,
    &quot;link-duplex&quot;: &quot;duplex&quot;,
    &quot;ethernet-autoneg&quot;: &quot;autoneg&quot;,
    &quot;ethernet-port&quot;: &quot;ethernet-port&quot;,
    &quot;ethernet-wol&quot;: &quot;wol&quot;,
    &quot;driver-message-level&quot;: &quot;driver-message-level&quot;,
    &quot;ethernet-pause-rx&quot;: &quot;ethernet-pause-rx&quot;,
    &quot;ethernet-pause-tx&quot;: &quot;ethernet-pause-tx&quot;,
    &quot;ethernet-pause-autoneg&quot;: &quot;ethernet-pause-autoneg&quot;,
    &quot;offload-rx&quot;: &quot;rx&quot;,
    &quot;offload-tx&quot;: &quot;tx&quot;,
    &quot;offload-sg&quot;: &quot;sg&quot;,
    &quot;offload-tso&quot;: &quot;tso&quot;,
    &quot;offload-ufo&quot;: &quot;ufo&quot;,
    &quot;offload-gso&quot;: &quot;gso&quot;,
    &quot;offload-lro&quot;: &quot;lro&quot;,
    &quot;offload-gro&quot;: &quot;gro&quot;,
    &quot;hardware-irq-coalesce-adaptive-rx&quot;: &quot;hardware-irq-coalesce-adaptive-rx&quot;,
    &quot;hardware-irq-coalesce-adaptive-tx&quot;: &quot;hardware-irq-coalesce-adaptive-tx&quot;,
    &quot;hardware-irq-coalesce-rx-usecs&quot;: &quot;hardware-irq-coalesce-rx-usecs&quot;,
    &quot;hardware-irq-coalesce-rx-frames&quot;: &quot;hardware-irq-coalesce-rx-frames&quot;,
    &quot;hardware-dma-ring-rx&quot;: &quot;hardware-dma-ring-rx&quot;,
    &quot;hardware-dma-ring-rx-mini&quot;: &quot;hardware-dma-ring-rx-mini&quot;,
    &quot;hardware-dma-ring-rx-jumbo&quot;: &quot;hardware-dma-ring-rx-jumbo&quot;,
    &quot;hardware-dma-ring-tx&quot;: &quot;hardware-dma-ring-tx&quot;,
}

_DEB_CONFIG_PPPOE_OPTS = {
    &quot;user&quot;: &quot;user&quot;,
    &quot;password&quot;: &quot;password&quot;,
    &quot;provider&quot;: &quot;provider&quot;,
    &quot;pppoe_iface&quot;: &quot;pppoe_iface&quot;,
    &quot;noipdefault&quot;: &quot;noipdefault&quot;,
    &quot;usepeerdns&quot;: &quot;usepeerdns&quot;,
    &quot;defaultroute&quot;: &quot;defaultroute&quot;,
    &quot;holdoff&quot;: &quot;holdoff&quot;,
    &quot;maxfail&quot;: &quot;maxfail&quot;,
    &quot;hide-password&quot;: &quot;hide-password&quot;,
    &quot;lcp-echo-interval&quot;: &quot;lcp-echo-interval&quot;,
    &quot;lcp-echo-failure&quot;: &quot;lcp-echo-failure&quot;,
    &quot;connect&quot;: &quot;connect&quot;,
    &quot;noauth&quot;: &quot;noauth&quot;,
    &quot;persist&quot;: &quot;persist&quot;,
    &quot;mtu&quot;: &quot;mtu&quot;,
    &quot;noaccomp&quot;: &quot;noaccomp&quot;,
    &quot;linkname&quot;: &quot;linkname&quot;,
}

_DEB_ROUTES_FILE = &quot;/etc/network/routes&quot;
_DEB_NETWORK_FILE = &quot;/etc/network/interfaces&quot;
_DEB_NETWORK_DIR = &quot;/etc/network/interfaces.d/&quot;
_DEB_NETWORK_UP_DIR = &quot;/etc/network/if-up.d/&quot;
_DEB_NETWORK_DOWN_DIR = &quot;/etc/network/if-down.d/&quot;
_DEB_NETWORK_CONF_FILES = &quot;/etc/modprobe.d/&quot;
_DEB_NETWORKING_FILE = &quot;/etc/default/networking&quot;
_DEB_HOSTNAME_FILE = &quot;/etc/hostname&quot;
_DEB_RESOLV_FILE = &quot;/etc/resolv.conf&quot;
_DEB_PPP_DIR = &quot;/etc/ppp/peers/&quot;

_CONFIG_TRUE = [&quot;yes&quot;, &quot;on&quot;, &quot;true&quot;, &quot;1&quot;, True]
_CONFIG_FALSE = [&quot;no&quot;, &quot;off&quot;, &quot;false&quot;, &quot;0&quot;, False]
_IFACE_TYPES = [
    &quot;eth&quot;,
    &quot;bond&quot;,
    &quot;alias&quot;,
    &quot;clone&quot;,
    &quot;ipsec&quot;,
    &quot;dialup&quot;,
    &quot;bridge&quot;,
    &quot;slave&quot;,
    &quot;vlan&quot;,
    &quot;pppoe&quot;,
    &quot;source&quot;,
]


def _error_msg_iface(iface, option, expected):
    &quot;&quot;&quot;
    Build an appropriate error message from a given option and
    a list of expected values.
    &quot;&quot;&quot;
    msg = &quot;Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]&quot;
    return msg.format(iface, option, &quot;|&quot;.join(str(e) for e in expected))


def _error_msg_routes(iface, option, expected):
    &quot;&quot;&quot;
    Build an appropriate error message from a given option and
    a list of expected values.
    &quot;&quot;&quot;
    msg = &quot;Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]&quot;
    return msg.format(iface, option, expected)


def _log_default_iface(iface, opt, value):
    log.info(
        &quot;Using default option -- Interface: %s Option: %s Value: %s&quot;, iface, opt, value
    )


def _error_msg_network(option, expected):
    &quot;&quot;&quot;
    Build an appropriate error message from a given option and
    a list of expected values.
    &quot;&quot;&quot;
    msg = &quot;Invalid network setting -- Setting: {0}, Expected: [{1}]&quot;
    return msg.format(option, &quot;|&quot;.join(str(e) for e in expected))


def _log_default_network(opt, value):
    log.info(&quot;Using existing setting -- Setting: %s Value: %s&quot;, opt, value)


def _raise_error_iface(iface, option, expected):
    &quot;&quot;&quot;
    Log and raise an error with a logical formatted message.
    &quot;&quot;&quot;
    msg = _error_msg_iface(iface, option, expected)
    log.error(msg)
    raise AttributeError(msg)


def _raise_error_network(option, expected):
    &quot;&quot;&quot;
    Log and raise an error with a logical formatted message.
    &quot;&quot;&quot;
    msg = _error_msg_network(option, expected)
    log.error(msg)
    raise AttributeError(msg)


def _raise_error_routes(iface, option, expected):
    &quot;&quot;&quot;
    Log and raise an error with a logical formatted message.
    &quot;&quot;&quot;
    msg = _error_msg_routes(iface, option, expected)
    log.error(msg)
    raise AttributeError(msg)


def _read_file(path):
    &quot;&quot;&quot;
    Reads and returns the contents of a text file
    &quot;&quot;&quot;
    try:
        with salt.utils.files.flopen(path, &quot;rb&quot;) as contents:
            return [
                salt.utils.stringutils.to_str(line) for line in contents.readlines()
            ]
    except OSError:
        return &quot;&quot;


def _parse_resolve():
    &quot;&quot;&quot;
    Parse /etc/resolv.conf
    &quot;&quot;&quot;
    return salt.utils.dns.parse_resolv(_DEB_RESOLV_FILE)


def _parse_domainname():
    &quot;&quot;&quot;
    Parse /etc/resolv.conf and return domainname
    &quot;&quot;&quot;
    return _parse_resolve().get(&quot;domain&quot;, &quot;&quot;)


def _parse_searchdomain():
    &quot;&quot;&quot;
    Parse /etc/resolv.conf and return searchdomain
    &quot;&quot;&quot;
    return _parse_resolve().get(&quot;search&quot;, &quot;&quot;)


def _parse_hostname():
    &quot;&quot;&quot;
    Parse /etc/hostname and return hostname
    &quot;&quot;&quot;
    contents = _read_file(_DEB_HOSTNAME_FILE)
    if contents:
        return contents[0].split(&quot;\n&quot;)[0]
    else:
        return &quot;&quot;


def _parse_current_network_settings():
    &quot;&quot;&quot;
    Parse /etc/default/networking and return current configuration
    &quot;&quot;&quot;
    opts = salt.utils.odict.OrderedDict()
    opts[&quot;networking&quot;] = &quot;&quot;

    if os.path.isfile(_DEB_NETWORKING_FILE):
        with salt.utils.files.fopen(_DEB_NETWORKING_FILE) as contents:
            for line in contents:
                salt.utils.stringutils.to_unicode(line)
                if line.startswith(&quot;#&quot;):
                    continue
                elif line.startswith(&quot;CONFIGURE_INTERFACES&quot;):
                    opts[&quot;networking&quot;] = line.split(&quot;=&quot;, 1)[1].strip()

    hostname = _parse_hostname()
    domainname = _parse_domainname()
    searchdomain = _parse_searchdomain()

    opts[&quot;hostname&quot;] = hostname
    opts[&quot;domainname&quot;] = domainname
    opts[&quot;searchdomain&quot;] = searchdomain
    return opts


# def __validator_func(value):
#    return (valid: True/False, (transformed) value, error message)


def __ipv4_quad(value):
    &quot;&quot;&quot;validate an IPv4 address&quot;&quot;&quot;
    return (salt.utils.validate.net.ipv4_addr(value), value, &quot;dotted IPv4 address&quot;)


def __ipv6(value):
    &quot;&quot;&quot;validate an IPv6 address&quot;&quot;&quot;
    return (salt.utils.validate.net.ipv6_addr(value), value, &quot;IPv6 address&quot;)


def __mac(value):
    &quot;&quot;&quot;validate a mac address&quot;&quot;&quot;
    return (salt.utils.validate.net.mac(value), value, &quot;MAC address&quot;)


def __anything(value):
    return (True, value, None)


def __int(value):
    &quot;&quot;&quot;validate an integer&quot;&quot;&quot;
    valid, _value = False, value
    try:
        _value = int(value)
        valid = True
    except ValueError:
        pass
    return (valid, _value, &quot;integer&quot;)


def __float(value):
    &quot;&quot;&quot;validate a float&quot;&quot;&quot;
    valid, _value = False, value
    try:
        _value = float(value)
        valid = True
    except ValueError:
        pass
    return (valid, _value, &quot;float&quot;)


def __ipv4_netmask(value):
    &quot;&quot;&quot;validate an IPv4 dotted quad or integer CIDR netmask&quot;&quot;&quot;
    valid, errmsg = False, &quot;dotted quad or integer CIDR (0-&gt;32)&quot;
    valid, value, _ = __int(value)
    if not (valid and 0 &lt;= value &lt;= 32):
        valid = salt.utils.validate.net.netmask(value)
    return (valid, value, errmsg)


def __ipv6_netmask(value):
    &quot;&quot;&quot;validate an IPv6 integer netmask&quot;&quot;&quot;
    valid, errmsg = False, &quot;IPv6 netmask (0-&gt;128)&quot;
    valid, value, _ = __int(value)
    valid = valid and 0 &lt;= value &lt;= 128
    return (valid, value, errmsg)


def __within2(value, within=None, errmsg=None, dtype=None):
    &quot;&quot;&quot;validate that a value is in ``within`` and optionally a ``dtype``&quot;&quot;&quot;
    valid, _value = False, value
    if dtype:
        try:
            _value = dtype(value)  # TODO: this is a bit loose when dtype is a class
            valid = _value in within
        except ValueError:
            pass
    else:
        valid = _value in within
    if errmsg is None:
        if dtype:
            typename = getattr(
                dtype,
                &quot;__name__&quot;,
                hasattr(dtype, &quot;__class__&quot;) and getattr(dtype.__class__, &quot;name&quot;, dtype),
            )
            errmsg = &quot;{} within '{}'&quot;.format(typename, within)
        else:
            errmsg = &quot;within '{}'&quot;.format(within)
    return (valid, _value, errmsg)


def __within(within=None, errmsg=None, dtype=None):
    return functools.partial(__within2, within=within, errmsg=errmsg, dtype=dtype)


def __space_delimited_list(value):
    &quot;&quot;&quot;validate that a value contains one or more space-delimited values&quot;&quot;&quot;
    if isinstance(value, str):
        value = value.strip().split()

    if hasattr(value, &quot;__iter__&quot;) and value != []:
        return (True, value, &quot;space-delimited string&quot;)
    else:
        return (
            False,
            value,
            &quot;{} is not a valid space-delimited value.\n&quot;.format(value),
        )


SALT_ATTR_TO_DEBIAN_ATTR_MAP = {
    &quot;dns&quot;: &quot;dns-nameservers&quot;,
    &quot;search&quot;: &quot;dns-search&quot;,
    &quot;hwaddr&quot;: &quot;hwaddress&quot;,  # TODO: this limits bootp functionality
    &quot;ipaddr&quot;: &quot;address&quot;,
    &quot;ipaddrs&quot;: &quot;addresses&quot;,
}


DEBIAN_ATTR_TO_SALT_ATTR_MAP = {v: k for (k, v) in SALT_ATTR_TO_DEBIAN_ATTR_MAP.items()}

# TODO
DEBIAN_ATTR_TO_SALT_ATTR_MAP[&quot;address&quot;] = &quot;address&quot;
DEBIAN_ATTR_TO_SALT_ATTR_MAP[&quot;hwaddress&quot;] = &quot;hwaddress&quot;

IPV4_VALID_PROTO = [&quot;bootp&quot;, &quot;dhcp&quot;, &quot;static&quot;, &quot;manual&quot;, &quot;loopback&quot;, &quot;ppp&quot;]

IPV4_ATTR_MAP = {
    &quot;proto&quot;: __within(IPV4_VALID_PROTO, dtype=str),
    # ipv4 static &amp; manual
    &quot;address&quot;: __ipv4_quad,
    &quot;addresses&quot;: __anything,
    &quot;netmask&quot;: __ipv4_netmask,
    &quot;broadcast&quot;: __ipv4_quad,
    &quot;metric&quot;: __int,
    &quot;gateway&quot;: __ipv4_quad,  # supports a colon-delimited list
    &quot;pointopoint&quot;: __ipv4_quad,
    &quot;hwaddress&quot;: __mac,
    &quot;mtu&quot;: __int,
    &quot;scope&quot;: __within([&quot;global&quot;, &quot;link&quot;, &quot;host&quot;], dtype=str),
    # dhcp
    &quot;hostname&quot;: __anything,
    &quot;leasehours&quot;: __int,
    &quot;leasetime&quot;: __int,
    &quot;vendor&quot;: __anything,
    &quot;client&quot;: __anything,
    # bootp
    &quot;bootfile&quot;: __anything,
    &quot;server&quot;: __ipv4_quad,
    &quot;hwaddr&quot;: __mac,
    # tunnel
    &quot;mode&quot;: __within([&quot;gre&quot;, &quot;GRE&quot;, &quot;ipip&quot;, &quot;IPIP&quot;, &quot;802.3ad&quot;], dtype=str),
    &quot;endpoint&quot;: __ipv4_quad,
    &quot;dstaddr&quot;: __ipv4_quad,
    &quot;local&quot;: __ipv4_quad,
    &quot;ttl&quot;: __int,
    # bond
    &quot;slaves&quot;: __anything,
    # ppp
    &quot;provider&quot;: __anything,
    &quot;unit&quot;: __int,
    &quot;options&quot;: __anything,
    # resolvconf
    &quot;dns-nameservers&quot;: __space_delimited_list,
    &quot;dns-search&quot;: __space_delimited_list,
    #
    &quot;vlan-raw-device&quot;: __anything,
    #
    &quot;network&quot;: __anything,  # i don't know what this is
    &quot;test&quot;: __anything,  # TODO
    &quot;enable_ipv4&quot;: __anything,  # TODO
    &quot;enable_ipv6&quot;: __anything,  # TODO
}


IPV6_VALID_PROTO = [&quot;auto&quot;, &quot;loopback&quot;, &quot;static&quot;, &quot;manual&quot;, &quot;dhcp&quot;, &quot;v4tunnel&quot;, &quot;6to4&quot;]

IPV6_ATTR_MAP = {
    &quot;proto&quot;: __within(IPV6_VALID_PROTO),
    # ipv6 static &amp; manual
    &quot;address&quot;: __ipv6,
    &quot;addresses&quot;: __anything,
    &quot;netmask&quot;: __ipv6_netmask,
    &quot;broadcast&quot;: __ipv6,
    &quot;gateway&quot;: __ipv6,  # supports a colon-delimited list
    &quot;hwaddress&quot;: __mac,
    &quot;mtu&quot;: __int,
    &quot;scope&quot;: __within([&quot;global&quot;, &quot;site&quot;, &quot;link&quot;, &quot;host&quot;], dtype=str),
    # inet6 auto
    &quot;privext&quot;: __within([0, 1, 2], dtype=int),
    &quot;dhcp&quot;: __within([0, 1], dtype=int),
    # inet6 static &amp; manual &amp; dhcp
    &quot;media&quot;: __anything,
    &quot;accept_ra&quot;: __within([0, 1, 2], dtype=int),
    &quot;autoconf&quot;: __within([0, 1], dtype=int),
    &quot;preferred-lifetime&quot;: __int,
    &quot;dad-attempts&quot;: __int,  # 0 to disable
    &quot;dad-interval&quot;: __float,
    # bond
    &quot;slaves&quot;: __anything,
    # tunnel
    &quot;mode&quot;: __within([&quot;gre&quot;, &quot;GRE&quot;, &quot;ipip&quot;, &quot;IPIP&quot;, &quot;802.3ad&quot;], dtype=str),
    &quot;endpoint&quot;: __ipv4_quad,
    &quot;local&quot;: __ipv4_quad,
    &quot;ttl&quot;: __int,
    # resolvconf
    &quot;dns-nameservers&quot;: __space_delimited_list,
    &quot;dns-search&quot;: __space_delimited_list,
    #
    &quot;vlan-raw-device&quot;: __anything,
    &quot;test&quot;: __anything,  # TODO
    &quot;enable_ipv4&quot;: __anything,  # TODO
    &quot;enable_ipv6&quot;: __anything,  # TODO
}


WIRELESS_ATTR_MAP = {
    &quot;wireless-essid&quot;: __anything,
    &quot;wireless-mode&quot;: __anything,  # TODO
    &quot;wpa-ap-scan&quot;: __within([0, 1, 2], dtype=int),  # TODO
    &quot;wpa-conf&quot;: __anything,
    &quot;wpa-driver&quot;: __anything,
    &quot;wpa-group&quot;: __anything,
    &quot;wpa-key-mgmt&quot;: __anything,
    &quot;wpa-pairwise&quot;: __anything,
    &quot;wpa-psk&quot;: __anything,
    &quot;wpa-proto&quot;: __anything,  # partial(__within,
    &quot;wpa-roam&quot;: __anything,
    &quot;wpa-ssid&quot;: __anything,  # TODO
}

ATTRMAPS = {
    &quot;inet&quot;: [IPV4_ATTR_MAP, WIRELESS_ATTR_MAP],
    &quot;inet6&quot;: [IPV6_ATTR_MAP, WIRELESS_ATTR_MAP],
}


def _validate_interface_option(attr, value, addrfam=&quot;inet&quot;):
    &quot;&quot;&quot;lookup the validation function for a [addrfam][attr] and
    return the results

    :param attr: attribute name
    :param value: raw setting value
    :param addrfam: address family (inet, inet6,
    &quot;&quot;&quot;
    valid, _value, errmsg = False, value, &quot;Unknown validator&quot;
    attrmaps = ATTRMAPS.get(addrfam, [])
    for attrmap in attrmaps:
        if attr in attrmap:
            validate_func = attrmap[attr]
            (valid, _value, errmsg) = validate_func(value)
            break
    return (valid, _value, errmsg)


def _attrmaps_contain_attr(attr):
    return attr in WIRELESS_ATTR_MAP or attr in IPV4_ATTR_MAP or attr in IPV6_ATTR_MAP


def _parse_interfaces(interface_files=None):
    &quot;&quot;&quot;
    Parse /etc/network/interfaces and return current configured interfaces
    &quot;&quot;&quot;
    if interface_files is None:
        interface_files = []
        # Add this later.
        if os.path.exists(_DEB_NETWORK_DIR):
            interface_files += [
                &quot;{}/{}&quot;.format(_DEB_NETWORK_DIR, dir)
                for dir in os.listdir(_DEB_NETWORK_DIR)
            ]

        if os.path.isfile(_DEB_NETWORK_FILE):
            interface_files.insert(0, _DEB_NETWORK_FILE)

    adapters = salt.utils.odict.OrderedDict()
    method = -1

    for interface_file in interface_files:
        with salt.utils.files.fopen(interface_file) as interfaces:
            # This ensures iface_dict exists, but does not ensure we're not reading a new interface.
            iface_dict = {}
            for line in interfaces:
                line = salt.utils.stringutils.to_unicode(line)
                # Identify the clauses by the first word of each line.
                # Go to the next line if the current line is a comment
                # or all spaces.
                if line.lstrip().startswith(&quot;#&quot;) or line.isspace():
                    continue
                # Parse the iface clause
                if line.startswith(&quot;iface&quot;):
                    sline = line.split()

                    if len(sline) != 4:
                        msg = &quot;Interface file malformed: {0}.&quot;
                        msg = msg.format(sline)
                        log.error(msg)
                        raise AttributeError(msg)

                    iface_name = sline[1]
                    addrfam = sline[2]
                    method = sline[3]

                    # Create item in dict, if not already there
                    if iface_name not in adapters:
                        adapters[iface_name] = salt.utils.odict.OrderedDict()

                    # Create item in dict, if not already there
                    if &quot;data&quot; not in adapters[iface_name]:
                        adapters[iface_name][&quot;data&quot;] = salt.utils.odict.OrderedDict()

                    if addrfam not in adapters[iface_name][&quot;data&quot;]:
                        adapters[iface_name][&quot;data&quot;][
                            addrfam
                        ] = salt.utils.odict.OrderedDict()

                    iface_dict = adapters[iface_name][&quot;data&quot;][addrfam]

                    iface_dict[&quot;addrfam&quot;] = addrfam
                    iface_dict[&quot;proto&quot;] = method
                    iface_dict[&quot;filename&quot;] = interface_file

                # Parse the detail clauses.
                elif line[0].isspace():
                    sline = line.split()

                    # conf file attr: dns-nameservers
                    # salt states.network attr: dns

                    attr, valuestr = line.rstrip().split(None, 1)
                    if _attrmaps_contain_attr(attr):
                        if &quot;-&quot; in attr:
                            attrname = attr.replace(&quot;-&quot;, &quot;_&quot;)
                        else:
                            attrname = attr
                        (valid, value, errmsg) = _validate_interface_option(
                            attr, valuestr, addrfam
                        )
                        if attrname == &quot;address&quot; and &quot;address&quot; in iface_dict:
                            if &quot;addresses&quot; not in iface_dict:
                                iface_dict[&quot;addresses&quot;] = []
                            iface_dict[&quot;addresses&quot;].append(value)
                        else:
                            iface_dict[attrname] = value

                    elif attr in _REV_ETHTOOL_CONFIG_OPTS:
                        if &quot;ethtool&quot; not in iface_dict:
                            iface_dict[&quot;ethtool&quot;] = salt.utils.odict.OrderedDict()
                        iface_dict[&quot;ethtool&quot;][attr] = valuestr

                    elif attr.startswith(&quot;bond&quot;):
                        opt = re.split(r&quot;[_-]&quot;, attr, maxsplit=1)[1]
                        if &quot;bonding&quot; not in iface_dict:
                            iface_dict[&quot;bonding&quot;] = salt.utils.odict.OrderedDict()
                        iface_dict[&quot;bonding&quot;][opt] = valuestr

                    elif attr.startswith(&quot;bridge&quot;):
                        opt = re.split(r&quot;[_-]&quot;, attr, maxsplit=1)[1]
                        if &quot;bridging&quot; not in iface_dict:
                            iface_dict[&quot;bridging&quot;] = salt.utils.odict.OrderedDict()
                        iface_dict[&quot;bridging&quot;][opt] = valuestr

                    elif attr in [
                        &quot;up&quot;,
                        &quot;pre-up&quot;,
                        &quot;post-up&quot;,
                        &quot;down&quot;,
                        &quot;pre-down&quot;,
                        &quot;post-down&quot;,
                    ]:
                        cmd = valuestr
                        cmd_key = &quot;{}_cmds&quot;.format(re.sub(&quot;-&quot;, &quot;_&quot;, attr))
                        if cmd_key not in iface_dict:
                            iface_dict[cmd_key] = []
                        iface_dict[cmd_key].append(cmd)

                elif line.startswith(&quot;auto&quot;):
                    for word in line.split()[1:]:
                        if word not in adapters:
                            adapters[word] = salt.utils.odict.OrderedDict()
                        adapters[word][&quot;enabled&quot;] = True

                elif line.startswith(&quot;allow-hotplug&quot;):
                    for word in line.split()[1:]:
                        if word not in adapters:
                            adapters[word] = salt.utils.odict.OrderedDict()
                        adapters[word][&quot;hotplug&quot;] = True

                elif line.startswith(&quot;source&quot;):
                    if &quot;source&quot; not in adapters:
                        adapters[&quot;source&quot;] = salt.utils.odict.OrderedDict()

                    # Create item in dict, if not already there
                    if &quot;data&quot; not in adapters[&quot;source&quot;]:
                        adapters[&quot;source&quot;][&quot;data&quot;] = salt.utils.odict.OrderedDict()
                        adapters[&quot;source&quot;][&quot;data&quot;][&quot;sources&quot;] = []
                    adapters[&quot;source&quot;][&quot;data&quot;][&quot;sources&quot;].append(line.split()[1])

    adapters = _filter_malformed_interfaces(adapters=adapters)
    return adapters


def _filter_malformed_interfaces(*, adapters):
    # Return a sorted list of the keys for bond, bridge and ethtool options to
    # ensure a consistent order
    for iface_name in list(adapters):
        if iface_name == &quot;source&quot;:
            continue
        if &quot;data&quot; not in adapters[iface_name]:
            msg = &quot;Interface file malformed for interface: {}.&quot;.format(iface_name)
            log.error(msg)
            adapters.pop(iface_name)
            continue
        for opt in [&quot;ethtool&quot;, &quot;bonding&quot;, &quot;bridging&quot;]:
            for inet in [&quot;inet&quot;, &quot;inet6&quot;]:
                if inet in adapters[iface_name][&quot;data&quot;]:
                    if opt in adapters[iface_name][&quot;data&quot;][inet]:
                        opt_keys = sorted(
                            adapters[iface_name][&quot;data&quot;][inet][opt].keys()
                        )
                        adapters[iface_name][&quot;data&quot;][inet][opt + &quot;_keys&quot;] = opt_keys
    return adapters


def _parse_ethtool_opts(opts, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for ETHTOOLS_OPTS
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    config = {}

    if &quot;autoneg&quot; in opts:
        if opts[&quot;autoneg&quot;] in _CONFIG_TRUE:
            config.update({&quot;autoneg&quot;: &quot;on&quot;})
        elif opts[&quot;autoneg&quot;] in _CONFIG_FALSE:
            config.update({&quot;autoneg&quot;: &quot;off&quot;})
        else:
            _raise_error_iface(iface, &quot;autoneg&quot;, _CONFIG_TRUE + _CONFIG_FALSE)

    if &quot;duplex&quot; in opts:
        valid = [&quot;full&quot;, &quot;half&quot;]
        if opts[&quot;duplex&quot;] in valid:
            config.update({&quot;duplex&quot;: opts[&quot;duplex&quot;]})
        else:
            _raise_error_iface(iface, &quot;duplex&quot;, valid)

    if &quot;speed&quot; in opts:
        valid = [&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;, &quot;10000&quot;]
        if str(opts[&quot;speed&quot;]) in valid:
            config.update({&quot;speed&quot;: opts[&quot;speed&quot;]})
        else:
            _raise_error_iface(iface, opts[&quot;speed&quot;], valid)

    valid = _CONFIG_TRUE + _CONFIG_FALSE
    for option in (&quot;rx&quot;, &quot;tx&quot;, &quot;sg&quot;, &quot;tso&quot;, &quot;ufo&quot;, &quot;gso&quot;, &quot;gro&quot;, &quot;lro&quot;):
        if option in opts:
            if opts[option] in _CONFIG_TRUE:
                config.update({option: &quot;on&quot;})
            elif opts[option] in _CONFIG_FALSE:
                config.update({option: &quot;off&quot;})
            else:
                _raise_error_iface(iface, option, valid)

    return config


def _parse_ethtool_pppoe_opts(opts, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for ETHTOOLS_PPPOE_OPTS
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    config = {}

    for opt in _DEB_CONFIG_PPPOE_OPTS:
        if opt in opts:
            config[opt] = opts[opt]

    if &quot;provider&quot; in opts and not opts[&quot;provider&quot;]:
        _raise_error_iface(iface, &quot;provider&quot;, _CONFIG_TRUE + _CONFIG_FALSE)

    valid = _CONFIG_TRUE + _CONFIG_FALSE
    for option in (
        &quot;noipdefault&quot;,
        &quot;usepeerdns&quot;,
        &quot;defaultroute&quot;,
        &quot;hide-password&quot;,
        &quot;noauth&quot;,
        &quot;persist&quot;,
        &quot;noaccomp&quot;,
    ):
        if option in opts:
            if opts[option] in _CONFIG_TRUE:
                config.update({option: &quot;True&quot;})
            elif opts[option] in _CONFIG_FALSE:
                config.update({option: &quot;False&quot;})
            else:
                _raise_error_iface(iface, option, valid)

    return config


def _parse_settings_bond(opts, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for requested
    operation. If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;

    bond_def = {
        # 803.ad aggregation selection logic
        # 0 for stable (default)
        # 1 for bandwidth
        # 2 for count
        &quot;ad_select&quot;: &quot;0&quot;,
        # Max number of transmit queues (default = 16)
        &quot;tx_queues&quot;: &quot;16&quot;,
        # Link monitoring in milliseconds. Most NICs support this
        &quot;miimon&quot;: &quot;100&quot;,
        # ARP interval in milliseconds
        &quot;arp_interval&quot;: &quot;250&quot;,
        # Delay before considering link down in milliseconds (miimon * 2)
        &quot;downdelay&quot;: &quot;200&quot;,
        # lacp_rate 0: Slow - every 30 seconds
        # lacp_rate 1: Fast - every 1 second
        &quot;lacp_rate&quot;: &quot;0&quot;,
        # Max bonds for this driver
        &quot;max_bonds&quot;: &quot;1&quot;,
        # Specifies the time, in milliseconds, to wait before
        # enabling a slave after a link recovery has been
        # detected. Only used with miimon.
        &quot;updelay&quot;: &quot;0&quot;,
        # Used with miimon.
        # On: driver sends mii
        # Off: ethtool sends mii
        &quot;use_carrier&quot;: &quot;on&quot;,
        # Default. Don't change unless you know what you are doing.
        &quot;xmit_hash_policy&quot;: &quot;layer2&quot;,
    }

    if opts[&quot;mode&quot;] in [&quot;balance-rr&quot;, &quot;0&quot;]:
        log.info(&quot;Device: %s Bonding Mode: load balancing (round-robin)&quot;, iface)
        return _parse_settings_bond_0(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;active-backup&quot;, &quot;1&quot;]:
        log.info(&quot;Device: %s Bonding Mode: fault-tolerance (active-backup)&quot;, iface)
        return _parse_settings_bond_1(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;balance-xor&quot;, &quot;2&quot;]:
        log.info(&quot;Device: %s Bonding Mode: load balancing (xor)&quot;, iface)
        return _parse_settings_bond_2(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;broadcast&quot;, &quot;3&quot;]:
        log.info(&quot;Device: %s Bonding Mode: fault-tolerance (broadcast)&quot;, iface)
        return _parse_settings_bond_3(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;802.3ad&quot;, &quot;4&quot;]:
        log.info(
            &quot;Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation&quot;, iface
        )
        return _parse_settings_bond_4(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;balance-tlb&quot;, &quot;5&quot;]:
        log.info(&quot;Device: %s Bonding Mode: transmit load balancing&quot;, iface)
        return _parse_settings_bond_5(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;balance-alb&quot;, &quot;6&quot;]:
        log.info(&quot;Device: %s Bonding Mode: adaptive load balancing&quot;, iface)
        return _parse_settings_bond_6(opts, iface, bond_def)
    else:
        valid = [
            &quot;0&quot;,
            &quot;1&quot;,
            &quot;2&quot;,
            &quot;3&quot;,
            &quot;4&quot;,
            &quot;5&quot;,
            &quot;6&quot;,
            &quot;balance-rr&quot;,
            &quot;active-backup&quot;,
            &quot;balance-xor&quot;,
            &quot;broadcast&quot;,
            &quot;802.3ad&quot;,
            &quot;balance-tlb&quot;,
            &quot;balance-alb&quot;,
        ]
        _raise_error_iface(iface, &quot;mode&quot;, valid)


def _parse_settings_bond_0(opts, iface, bond_def):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond0.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;0&quot;}

    # ARP targets in n.n.n.n form
    valid = [&quot;list of ips (up to 16)&quot;]
    if &quot;arp_ip_target&quot; in opts:
        if isinstance(opts[&quot;arp_ip_target&quot;], list):
            if 1 &lt;= len(opts[&quot;arp_ip_target&quot;]) &lt;= 16:
                bond.update({&quot;arp_ip_target&quot;: &quot;&quot;})
                for ip in opts[&quot;arp_ip_target&quot;]:  # pylint: disable=C0103
                    if len(bond[&quot;arp_ip_target&quot;]) &gt; 0:
                        bond[&quot;arp_ip_target&quot;] = bond[&quot;arp_ip_target&quot;] + &quot;,&quot; + ip
                    else:
                        bond[&quot;arp_ip_target&quot;] = ip
            else:
                _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)
        else:
            _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)
    else:
        _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)

    if &quot;arp_interval&quot; in opts:
        try:
            int(opts[&quot;arp_interval&quot;])
            bond.update({&quot;arp_interval&quot;: opts[&quot;arp_interval&quot;]})
        except ValueError:
            _raise_error_iface(iface, &quot;arp_interval&quot;, [&quot;integer&quot;])
    else:
        _log_default_iface(iface, &quot;arp_interval&quot;, bond_def[&quot;arp_interval&quot;])
        bond.update({&quot;arp_interval&quot;: bond_def[&quot;arp_interval&quot;]})

    return bond


def _parse_settings_bond_1(opts, iface, bond_def):

    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond1.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;1&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, [&quot;integer&quot;])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;primary&quot; in opts:
        bond.update({&quot;primary&quot;: opts[&quot;primary&quot;]})

    if not (__grains__[&quot;os&quot;] == &quot;Ubuntu&quot; and __grains__[&quot;osrelease_info&quot;][0] &gt;= 16):
        if &quot;use_carrier&quot; in opts:
            if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
                bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
            elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
                bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
            else:
                valid = _CONFIG_TRUE + _CONFIG_FALSE
                _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
        else:
            _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
            bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    return bond


def _parse_settings_bond_2(opts, iface, bond_def):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond2.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;

    bond = {&quot;mode&quot;: &quot;2&quot;}

    valid = [&quot;list of ips (up to 16)&quot;]
    if &quot;arp_ip_target&quot; in opts:
        if isinstance(opts[&quot;arp_ip_target&quot;], list):
            if 1 &lt;= len(opts[&quot;arp_ip_target&quot;]) &lt;= 16:
                bond.update({&quot;arp_ip_target&quot;: &quot;&quot;})
                for ip in opts[&quot;arp_ip_target&quot;]:  # pylint: disable=C0103
                    if len(bond[&quot;arp_ip_target&quot;]) &gt; 0:
                        bond[&quot;arp_ip_target&quot;] = bond[&quot;arp_ip_target&quot;] + &quot;,&quot; + ip
                    else:
                        bond[&quot;arp_ip_target&quot;] = ip
            else:
                _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)
        else:
            _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)
    else:
        _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)

    if &quot;arp_interval&quot; in opts:
        try:
            int(opts[&quot;arp_interval&quot;])
            bond.update({&quot;arp_interval&quot;: opts[&quot;arp_interval&quot;]})
        except ValueError:
            _raise_error_iface(iface, &quot;arp_interval&quot;, [&quot;integer&quot;])
    else:
        _log_default_iface(iface, &quot;arp_interval&quot;, bond_def[&quot;arp_interval&quot;])
        bond.update({&quot;arp_interval&quot;: bond_def[&quot;arp_interval&quot;]})

    if &quot;hashing-algorithm&quot; in opts:
        valid = [&quot;layer2&quot;, &quot;layer2+3&quot;, &quot;layer3+4&quot;]
        if opts[&quot;hashing-algorithm&quot;] in valid:
            bond.update({&quot;xmit_hash_policy&quot;: opts[&quot;hashing-algorithm&quot;]})
        else:
            _raise_error_iface(iface, &quot;hashing-algorithm&quot;, valid)

    return bond


def _parse_settings_bond_3(opts, iface, bond_def):

    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond3.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;3&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, [&quot;integer&quot;])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;use_carrier&quot; in opts:
        if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
            bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
        elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
            bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
    else:
        _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
        bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    return bond


def _parse_settings_bond_4(opts, iface, bond_def):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond4.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;

    bond = {&quot;mode&quot;: &quot;4&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;, &quot;lacp_rate&quot;, &quot;ad_select&quot;]:
        if binding in opts:
            if binding == &quot;lacp_rate&quot;:
                if opts[binding] == &quot;fast&quot;:
                    opts.update({binding: &quot;1&quot;})
                if opts[binding] == &quot;slow&quot;:
                    opts.update({binding: &quot;0&quot;})
                valid = [&quot;fast&quot;, &quot;1&quot;, &quot;slow&quot;, &quot;0&quot;]
            else:
                valid = [&quot;integer&quot;]
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, valid)
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;use_carrier&quot; in opts:
        if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
            bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
        elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
            bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
    else:
        _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
        bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    if &quot;hashing-algorithm&quot; in opts:
        valid = [&quot;layer2&quot;, &quot;layer2+3&quot;, &quot;layer3+4&quot;]
        if opts[&quot;hashing-algorithm&quot;] in valid:
            bond.update({&quot;xmit_hash_policy&quot;: opts[&quot;hashing-algorithm&quot;]})
        else:
            _raise_error_iface(iface, &quot;hashing-algorithm&quot;, valid)

    return bond


def _parse_settings_bond_5(opts, iface, bond_def):

    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond5.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;5&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, [&quot;integer&quot;])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;use_carrier&quot; in opts:
        if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
            bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
        elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
            bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
    else:
        _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
        bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    if &quot;primary&quot; in opts:
        bond.update({&quot;primary&quot;: opts[&quot;primary&quot;]})

    return bond


def _parse_settings_bond_6(opts, iface, bond_def):

    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond6.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;6&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, [&quot;integer&quot;])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;use_carrier&quot; in opts:
        if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
            bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
        elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
            bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
    else:
        _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
        bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    if &quot;primary&quot; in opts:
        bond.update({&quot;primary&quot;: opts[&quot;primary&quot;]})

    return bond


def _parse_bridge_opts(opts, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for BRIDGING_OPTS
    If an option has a value that is not expected, this
    function will log the Interface, Setting and what was expected.
    &quot;&quot;&quot;
    config = {}

    if &quot;ports&quot; in opts:
        if isinstance(opts[&quot;ports&quot;], list):
            opts[&quot;ports&quot;] = &quot; &quot;.join(opts[&quot;ports&quot;])
        config.update({&quot;ports&quot;: opts[&quot;ports&quot;]})

    for opt in [&quot;ageing&quot;, &quot;fd&quot;, &quot;gcint&quot;, &quot;hello&quot;, &quot;maxage&quot;]:
        if opt in opts:
            try:
                float(opts[opt])
                config.update({opt: opts[opt]})
            except ValueError:
                _raise_error_iface(iface, opt, [&quot;float&quot;])

    for opt in [&quot;bridgeprio&quot;, &quot;maxwait&quot;]:
        if opt in opts:
            if isinstance(opts[opt], int):
                config.update({opt: opts[opt]})
            else:
                _raise_error_iface(iface, opt, [&quot;integer&quot;])

    if &quot;hw&quot; in opts:
        # match 12 hex digits with either : or - as separators between pairs
        if re.match(
            &quot;[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$&quot;, opts[&quot;hw&quot;].lower()
        ):
            config.update({&quot;hw&quot;: opts[&quot;hw&quot;]})
        else:
            _raise_error_iface(iface, &quot;hw&quot;, [&quot;valid MAC address&quot;])

    for opt in [&quot;pathcost&quot;, &quot;portprio&quot;]:
        if opt in opts:
            try:
                port, cost_or_prio = opts[opt].split()
                int(cost_or_prio)
                config.update({opt: &quot;{} {}&quot;.format(port, cost_or_prio)})
            except ValueError:
                _raise_error_iface(iface, opt, [&quot;interface integer&quot;])

    if &quot;stp&quot; in opts:
        if opts[&quot;stp&quot;] in _CONFIG_TRUE:
            config.update({&quot;stp&quot;: &quot;on&quot;})
        elif opts[&quot;stp&quot;] in _CONFIG_FALSE:
            config.update({&quot;stp&quot;: &quot;off&quot;})
        else:
<A NAME="2"></A>            _raise_error_iface(iface, &quot;stp&quot;, _CONFIG_TRUE + _CONFIG_FALSE)

    if &quot;waitport&quot; in opts:
        if isinstance(opts<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match183307-0.html#2',2,'match183307-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;waitport&quot;], int):
            config.update({&quot;waitport&quot;: opts[&quot;waitport&quot;]})
        else:
            values = opts[&quot;waitport&quot;].split()
            waitport_time = values.pop(</B></FONT>0)
            if waitport_time.isdigit() and values:
                config.update(
                    {&quot;waitport&quot;: &quot;{} {}&quot;.format(waitport_time, &quot; &quot;.join(values))}
                )
            else:
                _raise_error_iface(iface, opt, [&quot;integer [interfaces]&quot;])

    return config


def _parse_settings_eth(opts, iface_type, enabled, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for a
    network interface.
    &quot;&quot;&quot;
    adapters = salt.utils.odict.OrderedDict()
    adapters[iface] = salt.utils.odict.OrderedDict()
<A NAME="1"></A>
    adapters[iface][&quot;type&quot;] = iface_type

    adapters[iface][&quot;data&quot;] = salt.utils.odict<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match183307-0.html#1',2,'match183307-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.OrderedDict()
    iface_data = adapters[iface][&quot;data&quot;]
    iface_data[&quot;inet&quot;] = salt.utils.odict.OrderedDict()
    iface_data[&quot;inet6&quot;] = salt.</B></FONT>utils.odict.OrderedDict()

    if enabled:
        adapters[iface][&quot;enabled&quot;] = True

    if opts.get(&quot;hotplug&quot;, False):
        adapters[iface][&quot;hotplug&quot;] = True

    if opts.get(&quot;enable_ipv6&quot;, None) and opts.get(&quot;iface_type&quot;, &quot;&quot;) == &quot;vlan&quot;:
        iface_data[&quot;inet6&quot;][&quot;vlan_raw_device&quot;] = re.sub(r&quot;\.\d*&quot;, &quot;&quot;, iface)

    for addrfam in [&quot;inet&quot;, &quot;inet6&quot;]:
        if iface_type not in [&quot;bridge&quot;]:
            tmp_ethtool = _parse_ethtool_opts(opts, iface)
            if tmp_ethtool:
                ethtool = {}
                for item in tmp_ethtool:
                    ethtool[_ETHTOOL_CONFIG_OPTS[item]] = tmp_ethtool[item]

                iface_data[addrfam][&quot;ethtool&quot;] = ethtool
                # return a list of sorted keys to ensure consistent order
                iface_data[addrfam][&quot;ethtool_keys&quot;] = sorted(ethtool)

        if iface_type == &quot;bridge&quot;:
            bridging = _parse_bridge_opts(opts, iface)
            if bridging:
                iface_data[addrfam][&quot;bridging&quot;] = bridging
                iface_data[addrfam][&quot;bridging_keys&quot;] = sorted(bridging)
                iface_data[addrfam][&quot;addrfam&quot;] = addrfam

        elif iface_type == &quot;bond&quot;:
            bonding = _parse_settings_bond(opts, iface)
            if bonding:
                iface_data[addrfam][&quot;bonding&quot;] = bonding
                iface_data[addrfam][&quot;bonding&quot;][&quot;slaves&quot;] = opts[&quot;slaves&quot;]
                iface_data[addrfam][&quot;bonding_keys&quot;] = sorted(bonding)
                iface_data[addrfam][&quot;addrfam&quot;] = addrfam

        elif iface_type == &quot;slave&quot;:
            adapters[iface][&quot;master&quot;] = opts[&quot;master&quot;]

            opts[&quot;proto&quot;] = &quot;manual&quot;
            iface_data[addrfam][&quot;master&quot;] = adapters[iface][&quot;master&quot;]
            iface_data[addrfam][&quot;addrfam&quot;] = addrfam

        elif iface_type == &quot;vlan&quot;:
            iface_data[addrfam][&quot;vlan_raw_device&quot;] = re.sub(r&quot;\.\d*&quot;, &quot;&quot;, iface)
            iface_data[addrfam][&quot;addrfam&quot;] = addrfam

        elif iface_type == &quot;pppoe&quot;:
            tmp_ethtool = _parse_ethtool_pppoe_opts(opts, iface)
            if tmp_ethtool:
                for item in tmp_ethtool:
                    adapters[iface][&quot;data&quot;][addrfam][
                        _DEB_CONFIG_PPPOE_OPTS[item]
                    ] = tmp_ethtool[item]
            iface_data[addrfam][&quot;addrfam&quot;] = addrfam

    opts.pop(&quot;mode&quot;, None)

    for opt, val in opts.items():
        inet = None
        if opt.startswith(&quot;ipv4&quot;):
            opt = opt[4:]
            inet = &quot;inet&quot;
            iface_data[&quot;inet&quot;][&quot;addrfam&quot;] = &quot;inet&quot;
        elif opt.startswith(&quot;ipv6&quot;):
            iface_data[&quot;inet6&quot;][&quot;addrfam&quot;] = &quot;inet6&quot;
            opt = opt[4:]
            inet = &quot;inet6&quot;
        elif opt in [
            &quot;ipaddr&quot;,
            &quot;address&quot;,
            &quot;ipaddresses&quot;,
            &quot;addresses&quot;,
            &quot;gateway&quot;,
            &quot;proto&quot;,
        ]:
            iface_data[&quot;inet&quot;][&quot;addrfam&quot;] = &quot;inet&quot;
            inet = &quot;inet&quot;

        _opt = SALT_ATTR_TO_DEBIAN_ATTR_MAP.get(opt, opt)
        _debopt = _opt.replace(&quot;-&quot;, &quot;_&quot;)

        for addrfam in [&quot;inet&quot;, &quot;inet6&quot;]:
            (valid, value, errmsg) = _validate_interface_option(
                _opt, val, addrfam=addrfam
            )
            if not valid:
                continue
            if inet is None and _debopt not in iface_data[addrfam]:
                iface_data[addrfam][_debopt] = value
            elif inet == addrfam:
                iface_data[addrfam][_debopt] = value

    for opt in [
        &quot;up_cmds&quot;,
        &quot;pre_up_cmds&quot;,
        &quot;post_up_cmds&quot;,
        &quot;down_cmds&quot;,
        &quot;pre_down_cmds&quot;,
        &quot;post_down_cmds&quot;,
    ]:
        if opt in opts:
            iface_data[&quot;inet&quot;][opt] = opts[opt]
            iface_data[&quot;inet6&quot;][opt] = opts[opt]

    # Remove incomplete/disabled inet blocks
    for (addrfam, opt) in [(&quot;inet&quot;, &quot;enable_ipv4&quot;), (&quot;inet6&quot;, &quot;enable_ipv6&quot;)]:
        if opts.get(opt, None) is False:
            iface_data.pop(addrfam)
        elif iface_data[addrfam].get(&quot;addrfam&quot;, &quot;&quot;) != addrfam:
            iface_data.pop(addrfam)

    return adapters


def _parse_settings_source(opts, iface_type, enabled, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for a
    network interface.
    &quot;&quot;&quot;
    adapters = salt.utils.odict.OrderedDict()
    adapters[iface] = salt.utils.odict.OrderedDict()

    adapters[iface][&quot;type&quot;] = iface_type

    adapters[iface][&quot;data&quot;] = salt.utils.odict.OrderedDict()
    iface_data = adapters[iface][&quot;data&quot;]
    iface_data[&quot;sources&quot;] = [opts[&quot;source&quot;]]

    return adapters


def _parse_network_settings(opts, current):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for
    the global network settings file.
    &quot;&quot;&quot;
    # Normalize keys
    opts = {k.lower(): v for (k, v) in opts.items()}
    current = {k.lower(): v for (k, v) in current.items()}
    result = {}

    valid = _CONFIG_TRUE + _CONFIG_FALSE
    if &quot;enabled&quot; not in opts:
        try:
            opts[&quot;networking&quot;] = current[&quot;networking&quot;]
            _log_default_network(&quot;networking&quot;, current[&quot;networking&quot;])
        except ValueError:
            _raise_error_network(&quot;networking&quot;, valid)
    else:
        opts[&quot;networking&quot;] = opts[&quot;enabled&quot;]

    if opts[&quot;networking&quot;] in valid:
        if opts[&quot;networking&quot;] in _CONFIG_TRUE:
            result[&quot;networking&quot;] = &quot;yes&quot;
        elif opts[&quot;networking&quot;] in _CONFIG_FALSE:
            result[&quot;networking&quot;] = &quot;no&quot;
    else:
        _raise_error_network(&quot;networking&quot;, valid)

    if &quot;hostname&quot; not in opts:
        try:
            opts[&quot;hostname&quot;] = current[&quot;hostname&quot;]
            _log_default_network(&quot;hostname&quot;, current[&quot;hostname&quot;])
        except ValueError:
            _raise_error_network(&quot;hostname&quot;, [&quot;server1.example.com&quot;])

    if opts[&quot;hostname&quot;]:
        result[&quot;hostname&quot;] = opts[&quot;hostname&quot;]
    else:
        _raise_error_network(&quot;hostname&quot;, [&quot;server1.example.com&quot;])

    if &quot;search&quot; in opts:
        result[&quot;search&quot;] = opts[&quot;search&quot;]

    return result


def _parse_routes(iface, opts):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for
    the route settings file.
    &quot;&quot;&quot;
    # Normalize keys
    opts = {k.lower(): v for (k, v) in opts.items()}
    result = {}
    if &quot;routes&quot; not in opts:
        _raise_error_routes(iface, &quot;routes&quot;, &quot;List of routes&quot;)

    for opt in opts:
        result[opt] = opts[opt]

    return result


def _write_file(iface, data, folder, pattern):
    &quot;&quot;&quot;
    Writes a file to disk
    &quot;&quot;&quot;
    filename = os.path.join(folder, pattern.format(iface))
    if not os.path.exists(folder):
        msg = &quot;{0} cannot be written. {1} does not exist&quot;
        msg = msg.format(filename, folder)
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, &quot;w&quot;) as fout:
        fout.write(salt.utils.stringutils.to_str(data))
    return filename


def _write_file_routes(iface, data, folder, pattern):
    &quot;&quot;&quot;
    Writes a file to disk
    &quot;&quot;&quot;
    # ifup / ifdown is executing given folder via run-parts.
    # according to run-parts man-page, only filenames with this pattern are
    # executed: (^[a-zA-Z0-9_-]+$)

    # In order to make the routes file work for vlan interfaces
    # (default would have been in example /etc/network/if-up.d/route-bond0.12)
    # these dots in the iface name need to be replaced by underscores, so it
    # can be executed by run-parts
    iface = iface.replace(&quot;.&quot;, &quot;_&quot;)

    filename = os.path.join(folder, pattern.format(iface))
    if not os.path.exists(folder):
        msg = &quot;{0} cannot be written. {1} does not exist&quot;
        msg = msg.format(filename, folder)
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, &quot;w&quot;) as fout:
        fout.write(salt.utils.stringutils.to_str(data))

    __salt__[&quot;file.set_mode&quot;](filename, &quot;0755&quot;)
    return filename


def _write_file_network(data, filename, create=False):
    &quot;&quot;&quot;
    Writes a file to disk
    If file does not exist, only create if create
    argument is True
    &quot;&quot;&quot;
    if not os.path.exists(filename) and not create:
        msg = &quot;{0} cannot be written. {0} does not exist and create is setto False&quot;.format(
            filename
        )
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, &quot;w&quot;) as fout:
        fout.write(salt.utils.stringutils.to_str(data))


def _read_temp(data):
    &quot;&quot;&quot;
    Return what would be written to disk
    &quot;&quot;&quot;
    tout = io.StringIO()
    tout.write(data)
    tout.seek(0)
    output = tout.readlines()
    tout.close()

    return output


def _read_temp_ifaces(iface, data):
    &quot;&quot;&quot;
    Return what would be written to disk for interfaces
    &quot;&quot;&quot;
    try:
        template = JINJA.get_template(&quot;debian_eth.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template debian_eth.jinja&quot;)
        return &quot;&quot;

    ifcfg = template.render({&quot;name&quot;: iface, &quot;data&quot;: data})
    # Return as an array so the difflib works
    return [item + &quot;\n&quot; for item in ifcfg.split(&quot;\n&quot;)]


def _write_file_ifaces(iface, data, **settings):
    &quot;&quot;&quot;
    Writes a file to disk
    &quot;&quot;&quot;
    try:
        eth_template = JINJA.get_template(&quot;debian_eth.jinja&quot;)
        source_template = JINJA.get_template(&quot;debian_source.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template debian_eth.jinja&quot;)
        return &quot;&quot;

    # Read /etc/network/interfaces into a dict
    adapters = _parse_interfaces()
    # Apply supplied settings over on-disk settings
    adapters[iface] = data

    ifcfg = &quot;&quot;
    for adapter in adapters:
        if &quot;type&quot; in adapters[adapter] and adapters[adapter][&quot;type&quot;] == &quot;source&quot;:
            tmp = source_template.render({&quot;name&quot;: adapter, &quot;data&quot;: adapters[adapter]})
        else:
            tmp = eth_template.render({&quot;name&quot;: adapter, &quot;data&quot;: adapters[adapter]})
        ifcfg = ifcfg + tmp
        if adapter == iface:
            saved_ifcfg = tmp

    _SEPARATE_FILE = False
    if &quot;filename&quot; in settings:
        if not settings[&quot;filename&quot;].startswith(&quot;/&quot;):
            filename = &quot;{}/{}&quot;.format(_DEB_NETWORK_DIR, settings[&quot;filename&quot;])
        else:
            filename = settings[&quot;filename&quot;]
        _SEPARATE_FILE = True
    else:
        if &quot;filename&quot; in adapters[adapter][&quot;data&quot;]:
            filename = adapters[adapter][&quot;data&quot;]
        else:
            filename = _DEB_NETWORK_FILE

    if not os.path.exists(os.path.dirname(filename)):
        msg = &quot;{0} cannot be written.&quot;
        msg = msg.format(os.path.dirname(filename))
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, &quot;w&quot;) as fout:
        if _SEPARATE_FILE:
            fout.write(salt.utils.stringutils.to_str(saved_ifcfg))
        else:
            fout.write(salt.utils.stringutils.to_str(ifcfg))

    # Return as an array so the difflib works
    return saved_ifcfg.split(&quot;\n&quot;)


def _write_file_ppp_ifaces(iface, data):
    &quot;&quot;&quot;
    Writes a file to disk
    &quot;&quot;&quot;
    try:
        template = JINJA.get_template(&quot;debian_ppp_eth.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template debian_ppp_eth.jinja&quot;)
        return &quot;&quot;

    adapters = _parse_interfaces()
    adapters[iface] = data

    ifcfg = &quot;&quot;
    tmp = template.render({&quot;data&quot;: adapters[iface]})
    ifcfg = tmp + ifcfg

    filename = _DEB_PPP_DIR + &quot;/&quot; + adapters[iface][&quot;data&quot;][&quot;inet&quot;][&quot;provider&quot;]
    if not os.path.exists(os.path.dirname(filename)):
        msg = &quot;{0} cannot be written.&quot;
        msg = msg.format(os.path.dirname(filename))
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.fopen(filename, &quot;w&quot;) as fout:
        fout.write(salt.utils.stringutils.to_str(ifcfg))

    # Return as an array so the difflib works
    return filename


def build_bond(iface, **settings):
    &quot;&quot;&quot;
    Create a bond script in /etc/modprobe.d with the passed settings
    and load the bonding kernel module.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.build_bond bond0 mode=balance-alb
    &quot;&quot;&quot;
    deb_major = __grains__[&quot;osrelease&quot;][:1]

    opts = _parse_settings_bond(settings, iface)
    try:
        template = JINJA.get_template(&quot;conf.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template conf.jinja&quot;)
        return &quot;&quot;
    data = template.render({&quot;name&quot;: iface, &quot;bonding&quot;: opts})

    if &quot;test&quot; in settings and settings[&quot;test&quot;]:
        return _read_temp(data)

    _write_file(iface, data, _DEB_NETWORK_CONF_FILES, &quot;{}.conf&quot;.format(iface))
    path = os.path.join(_DEB_NETWORK_CONF_FILES, &quot;{}.conf&quot;.format(iface))
    if deb_major == &quot;5&quot;:
        for line_type in (&quot;alias&quot;, &quot;options&quot;):
            cmd = [
                &quot;sed&quot;,
                &quot;-i&quot;,
                &quot;-e&quot;,
                r&quot;/^{}\s{}.*/d&quot;.format(line_type, iface),
                &quot;/etc/modprobe.conf&quot;,
            ]
            __salt__[&quot;cmd.run&quot;](cmd, python_shell=False)
        __salt__[&quot;file.append&quot;](&quot;/etc/modprobe.conf&quot;, path)

    # Load kernel module
    __salt__[&quot;kmod.load&quot;](&quot;bonding&quot;)

    # install ifenslave
    __salt__[&quot;pkg.install&quot;](&quot;ifenslave&quot;)

    return _read_file(path)


def build_interface(iface, iface_type, enabled, **settings):
    &quot;&quot;&quot;
    Build an interface script for a network interface.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.build_interface eth0 eth &lt;settings&gt;
    &quot;&quot;&quot;

    iface_type = iface_type.lower()

    if iface_type not in _IFACE_TYPES:
        _raise_error_iface(iface, iface_type, _IFACE_TYPES)

    if iface_type == &quot;slave&quot;:
        settings[&quot;slave&quot;] = &quot;yes&quot;
        if &quot;master&quot; not in settings:
            msg = &quot;master is a required setting for slave interfaces&quot;
            log.error(msg)
            raise AttributeError(msg)

    elif iface_type == &quot;vlan&quot;:
        settings[&quot;vlan&quot;] = &quot;yes&quot;
        __salt__[&quot;pkg.install&quot;](&quot;vlan&quot;)

    elif iface_type == &quot;pppoe&quot;:
        settings[&quot;pppoe&quot;] = &quot;yes&quot;
        if not __salt__[&quot;pkg.version&quot;](&quot;ppp&quot;):
            inst = __salt__[&quot;pkg.install&quot;](&quot;ppp&quot;)

    elif iface_type == &quot;bond&quot;:
        if &quot;slaves&quot; not in settings:
            msg = &quot;slaves is a required setting for bond interfaces&quot;
            log.error(msg)
            raise AttributeError(msg)

    elif iface_type == &quot;bridge&quot;:
        if &quot;ports&quot; not in settings:
            msg = (
                &quot;ports is a required setting for bridge interfaces on Debian &quot;
                &quot;or Ubuntu based systems&quot;
            )
            log.error(msg)
            raise AttributeError(msg)
        __salt__[&quot;pkg.install&quot;](&quot;bridge-utils&quot;)

    if iface_type in [&quot;eth&quot;, &quot;bond&quot;, &quot;bridge&quot;, &quot;slave&quot;, &quot;vlan&quot;, &quot;pppoe&quot;]:
        opts = _parse_settings_eth(settings, iface_type, enabled, iface)

    if iface_type in [&quot;source&quot;]:
        opts = _parse_settings_source(settings, iface_type, enabled, iface)

    if &quot;test&quot; in settings and settings[&quot;test&quot;]:
        return _read_temp_ifaces(iface, opts[iface])

    ifcfg = _write_file_ifaces(iface, opts[iface], **settings)

    if iface_type == &quot;pppoe&quot;:
        _write_file_ppp_ifaces(iface, opts[iface])

    # ensure lines in list end with newline, so difflib works
    return [item + &quot;\n&quot; for item in ifcfg]


def build_routes(iface, **settings):
    &quot;&quot;&quot;
    Add route scripts for a network interface using up commands.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.build_routes eth0 &lt;settings&gt;
    &quot;&quot;&quot;

    opts = _parse_routes(iface, settings)
    try:
        template = JINJA.get_template(&quot;route_eth.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template route_eth.jinja&quot;)
        return &quot;&quot;

    add_routecfg = template.render(route_type=&quot;add&quot;, routes=opts[&quot;routes&quot;], iface=iface)

    del_routecfg = template.render(route_type=&quot;del&quot;, routes=opts[&quot;routes&quot;], iface=iface)

    if &quot;test&quot; in settings and settings[&quot;test&quot;]:
        return _read_temp(add_routecfg + del_routecfg)

    filename = _write_file_routes(iface, add_routecfg, _DEB_NETWORK_UP_DIR, &quot;route-{0}&quot;)
    results = _read_file(filename)

    filename = _write_file_routes(
        iface, del_routecfg, _DEB_NETWORK_DOWN_DIR, &quot;route-{0}&quot;
    )
    results += _read_file(filename)

    return results


def down(iface, iface_type):
    &quot;&quot;&quot;
    Shutdown a network interface

    CLI Example:

    .. code-block:: bash

        salt '*' ip.down eth0 eth
    &quot;&quot;&quot;
    # Slave devices are controlled by the master.
    # Source 'interfaces' aren't brought down.
    if iface_type not in [&quot;slave&quot;, &quot;source&quot;]:
        return __salt__[&quot;cmd.run&quot;]([&quot;ifdown&quot;, iface])
    return None


def get_bond(iface):
    &quot;&quot;&quot;
    Return the content of a bond script

    CLI Example:

    .. code-block:: bash

        salt '*' ip.get_bond bond0
    &quot;&quot;&quot;
    path = os.path.join(_DEB_NETWORK_CONF_FILES, &quot;{}.conf&quot;.format(iface))
    return _read_file(path)


def get_interface(iface):
    &quot;&quot;&quot;
    Return the contents of an interface script

    CLI Example:

    .. code-block:: bash

        salt '*' ip.get_interface eth0
    &quot;&quot;&quot;

    adapters = _parse_interfaces()
    if iface in adapters:
        try:
            if iface == &quot;source&quot;:
                template = JINJA.get_template(&quot;debian_source.jinja&quot;)
            else:
                template = JINJA.get_template(&quot;debian_eth.jinja&quot;)
        except jinja2.exceptions.TemplateNotFound:
            log.error(&quot;Could not load template debian_eth.jinja&quot;)
            return &quot;&quot;

        ifcfg = template.render({&quot;name&quot;: iface, &quot;data&quot;: adapters[iface]})

        # ensure lines in list end with newline, so difflib works
        return [item + &quot;\n&quot; for item in ifcfg.split(&quot;\n&quot;)]
    else:
        return []


def up(iface, iface_type):  # pylint: disable=C0103
    &quot;&quot;&quot;
    Start up a network interface

    CLI Example:

    .. code-block:: bash

        salt '*' ip.up eth0 eth
    &quot;&quot;&quot;
    # Slave devices are controlled by the master.
    # Source 'interfaces' aren't brought up.
    if iface_type not in (&quot;slave&quot;, &quot;source&quot;):
        return __salt__[&quot;cmd.run&quot;]([&quot;ifup&quot;, iface])
    return None


def get_network_settings():
    &quot;&quot;&quot;
    Return the contents of the global network script.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.get_network_settings
    &quot;&quot;&quot;
    skip_etc_default_networking = (
        __grains__[&quot;osfullname&quot;] == &quot;Ubuntu&quot;
        and int(__grains__[&quot;osrelease&quot;].split(&quot;.&quot;)[0]) &gt;= 12
    )

    if skip_etc_default_networking:
        settings = {}
        if __salt__[&quot;service.available&quot;](&quot;networking&quot;):
            if __salt__[&quot;service.status&quot;](&quot;networking&quot;):
                settings[&quot;networking&quot;] = &quot;yes&quot;
            else:
                settings[&quot;networking&quot;] = &quot;no&quot;
        else:
            settings[&quot;networking&quot;] = &quot;no&quot;

        hostname = _parse_hostname()
        domainname = _parse_domainname()

        settings[&quot;hostname&quot;] = hostname
        settings[&quot;domainname&quot;] = domainname

    else:
        settings = _parse_current_network_settings()

    try:
        template = JINJA.get_template(&quot;display-network.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template display-network.jinja&quot;)
        return &quot;&quot;

    network = template.render(settings)
    return _read_temp(network)


def get_routes(iface):
    &quot;&quot;&quot;
    Return the routes for the interface

    CLI Example:

    .. code-block:: bash

        salt '*' ip.get_routes eth0
    &quot;&quot;&quot;

    filename = os.path.join(_DEB_NETWORK_UP_DIR, &quot;route-{}&quot;.format(iface))
    results = _read_file(filename)

    filename = os.path.join(_DEB_NETWORK_DOWN_DIR, &quot;route-{}&quot;.format(iface))
    results += _read_file(filename)

    return results


def apply_network_settings(**settings):
    &quot;&quot;&quot;
    Apply global network configuration.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.apply_network_settings
    &quot;&quot;&quot;
    if &quot;require_reboot&quot; not in settings:
        settings[&quot;require_reboot&quot;] = False

    if &quot;apply_hostname&quot; not in settings:
        settings[&quot;apply_hostname&quot;] = False

    hostname_res = True
    if settings[&quot;apply_hostname&quot;] in _CONFIG_TRUE:
        if &quot;hostname&quot; in settings:
            hostname_res = __salt__[&quot;network.mod_hostname&quot;](settings[&quot;hostname&quot;])
        else:
            log.warning(
                &quot;The network state sls is trying to apply hostname &quot;
                &quot;changes but no hostname is defined.&quot;
            )
            hostname_res = False

    res = True
    if settings[&quot;require_reboot&quot;] in _CONFIG_TRUE:
        log.warning(
            &quot;The network state sls is requiring a reboot of the system to &quot;
            &quot;properly apply network configuration.&quot;
        )
        res = True
    else:
        stop = __salt__[&quot;service.stop&quot;](&quot;networking&quot;)
        time.sleep(2)
        res = stop and __salt__[&quot;service.start&quot;](&quot;networking&quot;)

    return hostname_res and res


def build_network_settings(**settings):
    &quot;&quot;&quot;
    Build the global network script.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.build_network_settings &lt;settings&gt;
    &quot;&quot;&quot;
    changes = []

    # Read current configuration and store default values
    current_network_settings = _parse_current_network_settings()

    # Build settings
    opts = _parse_network_settings(settings, current_network_settings)

    # Ubuntu has moved away from /etc/default/networking
    # beginning with the 12.04 release so we disable or enable
    # the networking related services on boot
    skip_etc_default_networking = (
        __grains__[&quot;osfullname&quot;] == &quot;Ubuntu&quot;
        and int(__grains__[&quot;osrelease&quot;].split(&quot;.&quot;)[0]) &gt;= 12
    )
    if skip_etc_default_networking:
        if opts[&quot;networking&quot;] == &quot;yes&quot;:
            service_cmd = &quot;service.enable&quot;
        else:
            service_cmd = &quot;service.disable&quot;

        if __salt__[&quot;service.available&quot;](&quot;NetworkManager&quot;):
            __salt__[service_cmd](&quot;NetworkManager&quot;)

        if __salt__[&quot;service.available&quot;](&quot;networking&quot;):
            __salt__[service_cmd](&quot;networking&quot;)
    else:
        try:
            template = JINJA.get_template(&quot;network.jinja&quot;)
        except jinja2.exceptions.TemplateNotFound:
            log.error(&quot;Could not load template network.jinja&quot;)
            return &quot;&quot;
        network = template.render(opts)

        if &quot;test&quot; in settings and settings[&quot;test&quot;]:
            return _read_temp(network)
        # Write settings
        _write_file_network(network, _DEB_NETWORKING_FILE, True)

    # Get hostname and domain from opts
    sline = opts[&quot;hostname&quot;].split(&quot;.&quot;, 1)
    opts[&quot;hostname&quot;] = sline[0]
    current_domainname = current_network_settings[&quot;domainname&quot;]
    current_searchdomain = current_network_settings[&quot;searchdomain&quot;]

    new_domain = False
    if len(sline) &gt; 1:
        new_domainname = sline[1]
        if new_domainname != current_domainname:
            domainname = new_domainname
            opts[&quot;domainname&quot;] = new_domainname
            new_domain = True
        else:
            domainname = current_domainname
            opts[&quot;domainname&quot;] = domainname
    else:
        domainname = current_domainname
        opts[&quot;domainname&quot;] = domainname

    new_search = False
    if &quot;search&quot; in opts:
        new_searchdomain = opts[&quot;search&quot;]
        if new_searchdomain != current_searchdomain:
            searchdomain = new_searchdomain
            opts[&quot;searchdomain&quot;] = new_searchdomain
            new_search = True
        else:
            searchdomain = current_searchdomain
            opts[&quot;searchdomain&quot;] = searchdomain
    else:
        searchdomain = current_searchdomain
        opts[&quot;searchdomain&quot;] = searchdomain

    # If the domain changes, then we should write the resolv.conf file.
    if new_domain or new_search:
        # Look for existing domain line and update if necessary
        resolve = _parse_resolve()
        domain_prog = re.compile(r&quot;domain\s+&quot;)
        search_prog = re.compile(r&quot;search\s+&quot;)
        new_contents = []

        for item in _read_file(_DEB_RESOLV_FILE):
            if domain_prog.match(item):
                item = &quot;domain {}&quot;.format(domainname)
            elif search_prog.match(item):
                item = &quot;search {}&quot;.format(searchdomain)
            new_contents.append(item)

        # A domain line didn't exist so we'll add one in
        # with the new domainname
        if &quot;domain&quot; not in resolve:
            new_contents.insert(0, &quot;domain {}&quot;.format(domainname))

        # A search line didn't exist so we'll add one in
        # with the new search domain
        if &quot;search&quot; not in resolve:
            new_contents.insert(&quot;domain&quot; in resolve, &quot;search {}&quot;.format(searchdomain))

        new_resolv = &quot;\n&quot;.join(new_contents)

        # Write /etc/resolv.conf
        if not (&quot;test&quot; in settings and settings[&quot;test&quot;]):
            _write_file_network(new_resolv, _DEB_RESOLV_FILE)

    #  used for returning the results back
    try:
        template = JINJA.get_template(&quot;display-network.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template display-network.jinja&quot;)
        return &quot;&quot;
    network = template.render(opts)
    changes.extend(_read_temp(network))

    return changes
</PRE>
</div>
  </div>
</body>
</html>
