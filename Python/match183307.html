<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tcp.py &amp; debian_ip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tcp.py &amp; debian_ip.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tcp.py (2.2803113%)<th>debian_ip.py (1.5763168%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(10-25)<td><a href="#" name="0">(8-23)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(334-340)<td><a href="#" name="1">(1241-1244)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1046-1048)<td><a href="#" name="2">(1216-1220)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tcp.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
2 import logging
3 import os
4 import queue
5 import socket
6 import threading
7 import urllib
8 import salt.ext.tornado
9 import salt.ext.tornado.concurrent
10 import salt.ext.tornado.gen
11 import salt.ext.tornado.iostream
12 import salt.ext.tornado.netutil
13 import salt.ext.tornado.tcpclient
14 import salt.ext.tornado.tcpserver
15 import</b></font> salt.master
16 import salt.payload
17 import salt.transport.client
18 import salt.transport.frame
19 import salt.transport.ipc
20 import salt.transport.server
21 import salt.utils.asynchronous
22 import salt.utils.files
23 import salt.utils.msgpack
24 import salt.utils.platform
25 import salt.utils.versions
26 from salt.exceptions import SaltClientError, SaltReqTimeoutError
27 if salt.utils.platform.is_windows():
28     USE_LOAD_BALANCER = True
29 else:
30     USE_LOAD_BALANCER = False
31 if USE_LOAD_BALANCER:
32     import threading
33     import multiprocessing
34     import salt.ext.tornado.util
35     from salt.utils.process import SignalHandlingProcess
36 log = logging.getLogger(__name__)
37 class ClosingError(Exception):
38 def _set_tcp_keepalive(sock, opts):
39     if hasattr(socket, "SO_KEEPALIVE"):
40         if opts.get("tcp_keepalive", False):
41             sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
42             if hasattr(socket, "SOL_TCP"):
43                 if hasattr(socket, "TCP_KEEPIDLE"):
44                     tcp_keepalive_idle = opts.get("tcp_keepalive_idle", -1)
45                     if tcp_keepalive_idle &gt; 0:
46                         sock.setsockopt(
47                             socket.SOL_TCP, socket.TCP_KEEPIDLE, int(tcp_keepalive_idle)
48                         )
49                 if hasattr(socket, "TCP_KEEPCNT"):
50                     tcp_keepalive_cnt = opts.get("tcp_keepalive_cnt", -1)
51                     if tcp_keepalive_cnt &gt; 0:
52                         sock.setsockopt(
53                             socket.SOL_TCP, socket.TCP_KEEPCNT, int(tcp_keepalive_cnt)
54                         )
55                 if hasattr(socket, "TCP_KEEPINTVL"):
56                     tcp_keepalive_intvl = opts.get("tcp_keepalive_intvl", -1)
57                     if tcp_keepalive_intvl &gt; 0:
58                         sock.setsockopt(
59                             socket.SOL_TCP,
60                             socket.TCP_KEEPINTVL,
61                             int(tcp_keepalive_intvl),
62                         )
63             if hasattr(socket, "SIO_KEEPALIVE_VALS"):
64                 tcp_keepalive_idle = opts.get("tcp_keepalive_idle", -1)
65                 tcp_keepalive_intvl = opts.get("tcp_keepalive_intvl", -1)
66                 if tcp_keepalive_idle &gt; 0 or tcp_keepalive_intvl &gt; 0:
67                     if tcp_keepalive_idle &lt;= 0:
68                         tcp_keepalive_idle = 7200
69                     if tcp_keepalive_intvl &lt;= 0:
70                         tcp_keepalive_intvl = 1
71                     sock.ioctl(
72                         socket.SIO_KEEPALIVE_VALS,
73                         (
74                             1,
75                             int(tcp_keepalive_idle * 1000),
76                             int(tcp_keepalive_intvl * 1000),
77                         ),
78                     )
79         else:
80             sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 0)
81 if USE_LOAD_BALANCER:
82     class LoadBalancerServer(SignalHandlingProcess):
83         backlog = 128
84         def __init__(self, opts, socket_queue, **kwargs):
85             super().__init__(**kwargs)
86             self.opts = opts
87             self.socket_queue = socket_queue
88             self._socket = None
89         def close(self):
90             if self._socket is not None:
91                 self._socket.shutdown(socket.SHUT_RDWR)
92                 self._socket.close()
93                 self._socket = None
94         def __del__(self):
95             self.close()
96         def run(self):
97             self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
98             self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
99             _set_tcp_keepalive(self._socket, self.opts)
100             self._socket.setblocking(1)
101             self._socket.bind((self.opts["interface"], int(self.opts["ret_port"])))
102             self._socket.listen(self.backlog)
103             while True:
104                 try:
105                     connection, address = self._socket.accept()
106                     self.socket_queue.put((connection, address), True, None)
107                 except OSError as e:
108                     if (
109                         salt.ext.tornado.util.errno_from_exception(e)
110                         == errno.ECONNABORTED
111                     ):
112                         continue
113                     raise
114 class Resolver:
115     _resolver_configured = False
116     @classmethod
117     def _config_resolver(cls, num_threads=10):
118         salt.ext.tornado.netutil.Resolver.configure(
119             "salt.ext.tornado.netutil.ThreadedResolver", num_threads=num_threads
120         )
121         cls._resolver_configured = True
122     def __init__(self, *args, **kwargs):
123         if not self._resolver_configured:
124             self._config_resolver()
125 class TCPPubClient(salt.transport.base.PublishClient):
126     ttype = "tcp"
127     def __init__(self, opts, io_loop, **kwargs):  # pylint: disable=W0231
128         self.opts = opts
129         self.io_loop = io_loop
130         self.message_client = None
131         self.connected = False
132         self._closing = False
133         self.resolver = Resolver()
134     def close(self):
135         if self._closing:
136             return
137         self._closing = True
138         if self.message_client is not None:
139             self.message_client.close()
140             self.message_client = None
141     def __del__(self):
142         self.close()
143     @salt.ext.tornado.gen.coroutine
144     def connect(self, publish_port, connect_callback=None, disconnect_callback=None):
145         self.publish_port = publish_port
146         self.message_client = MessageClient(
147             self.opts,
148             self.opts["master_ip"],
149             int(self.publish_port),
150             io_loop=self.io_loop,
151             connect_callback=connect_callback,
152             disconnect_callback=disconnect_callback,
153             source_ip=self.opts.get("source_ip"),
154             source_port=self.opts.get("source_publish_port"),
155         )
156         yield self.message_client.connect()  # wait for the client to be connected
157         self.connected = True
158     @salt.ext.tornado.gen.coroutine
159     def _decode_messages(self, messages):
160         if not isinstance(messages, dict):
161             body = salt.utils.msgpack.loads(messages)
162             body = salt.transport.frame.decode_embedded_strs(body)
163         else:
164             body = messages
165         raise salt.ext.tornado.gen.Return(body)
166     @salt.ext.tornado.gen.coroutine
167     def send(self, msg):
168         yield self.message_client._stream.write(msg)
169     def on_recv(self, callback):
170         return self.message_client.on_recv(callback)
171     def __enter__(self):
172         return self
173     def __exit__(self, exc_type, exc_val, exc_tb):
174         self.close()
175 class TCPReqServer(salt.transport.base.DaemonizedRequestServer):
176     backlog = 5
177     def __init__(self, opts):  # pylint: disable=W0231
178         self.opts = opts
179         self._socket = None
180         self.req_server = None
181     @property
182     def socket(self):
183         return self._socket
184     def close(self):
185         if self._socket is not None:
186             try:
187                 self._socket.shutdown(socket.SHUT_RDWR)
188             except OSError as exc:
189                 if exc.errno == errno.ENOTCONN:
190                     pass
191                 else:
192                     raise
193             if self.req_server is None:
194                 self._socket.close()
195             self._socket = None
196         if self.req_server is not None:
197             try:
198                 self.req_server.close()
199             except OSError as exc:
200                 if exc.errno != 9:
201                     raise
202                 log.exception(
203                     "TCPReqServerChannel close generated an exception: %s", str(exc)
204                 )
205             self.req_server = None
206     def __enter__(self):
207         return self
208     def __exit__(self, *args):
209         self.close()
210     def pre_fork(self, process_manager):
211             process_manager<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_process(
212                 LoadBalancerServer,
213                 args=(self.opts, self.socket_queue),
214                 name="LoadBalancerServer",
215             )
216         elif not salt.utils.platform.is_windows():
217             self._socket = socket.</b></font>socket(socket.AF_INET, socket.SOCK_STREAM)
218             self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
219             _set_tcp_keepalive(self._socket, self.opts)
220             self._socket.setblocking(0)
221             self._socket.bind((self.opts["interface"], int(self.opts["ret_port"])))
222     def post_fork(self, message_handler, io_loop):
223         self.message_handler = message_handler
224         with salt.utils.asynchronous.current_ioloop(io_loop):
225             if USE_LOAD_BALANCER:
226                 self.req_server = LoadBalancerWorker(
227                     self.socket_queue,
228                     self.handle_message,
229                     ssl_options=self.opts.get("ssl"),
230                 )
231             else:
232                 if salt.utils.platform.is_windows():
233                     self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
234                     self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
235                     _set_tcp_keepalive(self._socket, self.opts)
236                     self._socket.setblocking(0)
237                     self._socket.bind(
238                         (self.opts["interface"], int(self.opts["ret_port"]))
239                     )
240                 self.req_server = SaltMessageServer(
241                     self.handle_message,
242                     ssl_options=self.opts.get("ssl"),
243                     io_loop=io_loop,
244                 )
245                 self.req_server.add_socket(self._socket)
246                 self._socket.listen(self.backlog)
247     @salt.ext.tornado.gen.coroutine
248     def handle_message(self, stream, payload, header=None):
249         payload = self.decode_payload(payload)
250         reply = yield self.message_handler(payload)
251         stream.write(salt.transport.frame.frame_msg(reply, header=header))
252     def decode_payload(self, payload):
253         return payload
254 class SaltMessageServer(salt.ext.tornado.tcpserver.TCPServer):
255     def __init__(self, message_handler, *args, **kwargs):
256         io_loop = (
257             kwargs.pop("io_loop", None) or salt.ext.tornado.ioloop.IOLoop.current()
258         )
259         self._closing = False
260         super().__init__(*args, **kwargs)
261         self.io_loop = io_loop
262         self.clients = []
263         self.message_handler = message_handler
264     @salt.ext.tornado.gen.coroutine
265     def handle_stream(self, stream, address):
266         log.trace("Req client %s connected", address)
267         self.clients.append((stream, address))
268         unpacker = salt.utils.msgpack.Unpacker()
269         try:
270             while True:
271                 wire_bytes = yield stream.read_bytes(4096, partial=True)
272                 unpacker.feed(wire_bytes)
273                 for framed_msg in unpacker:
274                     framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
275                     header = framed_msg["head"]
276                     self.io_loop.spawn_callback(
277                         self.message_handler, stream, framed_msg["body"], header
278                     )
279         except salt.ext.tornado.iostream.StreamClosedError:
280             log.trace("req client disconnected %s", address)
281             self.remove_client((stream, address))
282         except Exception as e:  # pylint: disable=broad-except
283             log.trace("other master-side exception: %s", e, exc_info=True)
284             self.remove_client((stream, address))
285             stream.close()
286     def remove_client(self, client):
287         try:
288             self.clients.remove(client)
289         except ValueError:
290             log.trace("Message server client was not in list to remove")
291     def close(self):
292         if self._closing:
293             return
294         self._closing = True
295         for item in self.clients:
296             client, address = item
297             client.close()
298             self.remove_client(item)
299         try:
300             self.stop()
301         except OSError as exc:
302             if exc.errno != 9:
303                 raise
304 if USE_LOAD_BALANCER:
305     class LoadBalancerWorker(SaltMessageServer):
306         def __init__(self, socket_queue, message_handler, *args, **kwargs):
307             super().__init__(message_handler, *args, **kwargs)
308             self.socket_queue = socket_queue
309             self._stop = threading.Event()
310             self.thread = threading.Thread(target=self.socket_queue_thread)
311             self.thread.start()
312         def close(self):
313             self._stop.set()
314             self.thread.join()
315             super().close()
316         def socket_queue_thread(self):
317             try:
318                 while True:
319                     try:
320                         client_socket, address = self.socket_queue.get(True, 1)
321                     except queue.Empty:
322                         if self._stop.is_set():
323                             break
324                         continue
325                     self.io_loop.spawn_callback(
326                         self._handle_connection, client_socket, address
327                     )
328             except (KeyboardInterrupt, SystemExit):
329                 pass
330 class TCPClientKeepAlive(salt.ext.tornado.tcpclient.TCPClient):
331     def __init__(self, opts, resolver=None):
332         self.opts = opts
333         super().__init__(resolver=resolver)
334     def _create_stream(
335         self, max_buffer_size, af, addr, **kwargs
336     ):  # pylint: disable=unused-argument,arguments-differ
337         sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
338         _set_tcp_keepalive(sock, self.opts)
339         stream = salt.ext.tornado.iostream.IOStream(
340             sock, max_buffer_size=max_buffer_size
341         )
342         if salt.ext.tornado.version_info &lt; (5,):
343             return stream.connect(addr)
344         return stream, stream.connect(addr)
345 class MessageClient:
346     def __init__(
347         self,
348         opts,
349         host,
350         port,
351         io_loop=None,
352         resolver=None,
353         connect_callback=None,
354         disconnect_callback=None,
355         source_ip=None,
356         source_port=None,
357     ):
358         self.opts = opts
359         self.host = host
360         self.port = port
361         self.source_ip = source_ip
362         self.source_port = source_port
363         self.connect_callback = connect_callback
364         self.disconnect_callback = disconnect_callback
365         self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
366         with salt.utils.asynchronous.current_ioloop(self.io_loop):
367             self._tcp_client = TCPClientKeepAlive(opts, resolver=resolver)
368         self._mid = 1
369         self._max_messages = int((1 &lt;&lt; 31) - 2)  # number of IDs before we wrap
370         self.send_queue = []  # queue of messages to be sent
371         self.send_future_map = {}  # mapping of request_id -&gt; Future
372         self._read_until_future = None
373         self._on_recv = None
374         self._closing = False
375         self._closed = False
376         self._connecting_future = salt.ext.tornado.concurrent.Future()
377         self._stream_return_running = False
378         self._stream = None
379         self.backoff = opts.get("tcp_reconnect_backoff", 1)
380     def _stop_io_loop(self):
381         if self.io_loop is not None:
382             self.io_loop.stop()
383     def close(self):
384         if self._closing:
385             return
386         self._closing = True
387         self.io_loop.add_timeout(1, self.check_close)
388     @salt.ext.tornado.gen.coroutine
389     def check_close(self):
390         if not self.send_future_map:
391             self._tcp_client.close()
392             self._stream = None
393             self._closing = False
394             self._closed = True
395         else:
396             self.io_loop.add_timeout(1, self.check_close)
397     def __del__(self):
398         self.close()
399     @salt.ext.tornado.gen.coroutine
400     def getstream(self, **kwargs):
401         if self.source_ip or self.source_port:
402             kwargs = {
403                 "source_ip": self.source_ip,
404                 "source_port": self.source_port,
405             }
406         stream = None
407         while stream is None and (not self._closed and not self._closing):
408             try:
409                 stream = yield self._tcp_client.connect(
410                     self.host, self.port, ssl_options=self.opts.get("ssl"), **kwargs
411                 )
412             except Exception as exc:  # pylint: disable=broad-except
413                 log.warning(
414                     "TCP Message Client encountered an exception while connecting to"
415                     " %s:%s: %r, will reconnect in %d seconds",
416                     self.host,
417                     self.port,
418                     exc,
419                     self.backoff,
420                 )
421                 yield salt.ext.tornado.gen.sleep(self.backoff)
422         raise salt.ext.tornado.gen.Return(stream)
423     @salt.ext.tornado.gen.coroutine
424     def connect(self):
425         if self._stream is None:
426             self._stream = yield self.getstream()
427             if self._stream:
428                 if not self._stream_return_running:
429                     self.io_loop.spawn_callback(self._stream_return)
430                 if self.connect_callback:
431                     self.connect_callback(True)
432     @salt.ext.tornado.gen.coroutine
433     def _stream_return(self):
434         self._stream_return_running = True
435         unpacker = salt.utils.msgpack.Unpacker()
436         while not self._closing:
437             try:
438                 wire_bytes = yield self._stream.read_bytes(4096, partial=True)
439                 unpacker.feed(wire_bytes)
440                 for framed_msg in unpacker:
441                     framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
442                     header = framed_msg["head"]
443                     body = framed_msg["body"]
444                     message_id = header.get("mid")
445                     if message_id in self.send_future_map:
446                         self.send_future_map.pop(message_id).set_result(body)
447                     else:
448                         if self._on_recv is not None:
449                             self.io_loop.spawn_callback(self._on_recv, header, body)
450                         else:
451                             log.error(
452                                 "Got response for message_id %s that we are not"
453                                 " tracking",
454                                 message_id,
455                             )
456             except salt.ext.tornado.iostream.StreamClosedError as e:
457                 log.debug(
458                     "tcp stream to %s:%s closed, unable to recv",
459                     self.host,
460                     self.port,
461                 )
462                 for future in self.send_future_map.values():
463                     future.set_exception(e)
464                 self.send_future_map = {}
465                 if self._closing or self._closed:
466                     return
467                 if self.disconnect_callback:
468                     self.disconnect_callback()
469                 stream = self._stream
470                 self._stream = None
471                 if stream:
472                     stream.close()
473                 yield self.connect()
474             except TypeError:
475                 if "detect_mode" in self.opts:
476                     log.info(
477                         "There was an error trying to use TCP transport; "
478                         "attempting to fallback to another transport"
479                     )
480                 else:
481                     raise SaltClientError
482             except Exception as e:  # pylint: disable=broad-except
483                 log.error("Exception parsing response", exc_info=True)
484                 for future in self.send_future_map.values():
485                     future.set_exception(e)
486                 self.send_future_map = {}
487                 if self._closing or self._closed:
488                     return
489                 if self.disconnect_callback:
490                     self.disconnect_callback()
491                 stream = self._stream
492                 self._stream = None
493                 if stream:
494                     stream.close()
495                 yield self.connect()
496         self._stream_return_running = False
497     def _message_id(self):
498         wrap = False
499         while self._mid in self.send_future_map:
500             if self._mid &gt;= self._max_messages:
501                 if wrap:
502                     raise Exception("Unable to find available messageid")
503                 self._mid = 1
504                 wrap = True
505             else:
506                 self._mid += 1
507         return self._mid
508     def on_recv(self, callback):
509         if callback is None:
510             self._on_recv = callback
511         else:
512             def wrap_recv(header, body):
513                 callback(body)
514             self._on_recv = wrap_recv
515     def remove_message_timeout(self, message_id):
516         if message_id not in self.send_timeout_map:
517             return
518         timeout = self.send_timeout_map.pop(message_id)
519         self.io_loop.remove_timeout(timeout)
520     def timeout_message(self, message_id, msg):
521         if message_id not in self.send_future_map:
522             return
523         future = self.send_future_map.pop(message_id)
524         if future is not None:
525             future.set_exception(SaltReqTimeoutError("Message timed out"))
526     @salt.ext.tornado.gen.coroutine
527     def send(self, msg, timeout=None, callback=None, raw=False):
528         if self._closing:
529             raise ClosingError()
530         message_id = self._message_id()
531         header = {"mid": message_id}
532         future = salt.ext.tornado.concurrent.Future()
533         if callback is not None:
534             def handle_future(future):
535                 response = future.result()
536                 self.io_loop.add_callback(callback, response)
537             future.add_done_callback(handle_future)
538         self.send_future_map[message_id] = future
539         if self.opts.get("detect_mode") is True:
540             timeout = 1
541         if timeout is not None:
542             self.io_loop.call_later(timeout, self.timeout_message, message_id, msg)
543         item = salt.transport.frame.frame_msg(msg, header=header)
544         @salt.ext.tornado.gen.coroutine
545         def _do_send():
546             yield self.connect()
547             if self._stream:
548                 yield self._stream.write(item)
549         self.io_loop.add_callback(_do_send)
550         recv = yield future
551         raise salt.ext.tornado.gen.Return(recv)
552 class Subscriber:
553     def __init__(self, stream, address):
554         self.stream = stream
555         self.address = address
556         self._closing = False
557         self._read_until_future = None
558         self.id_ = None
559     def close(self):
560         if self._closing:
561             return
562         self._closing = True
563         if not self.stream.closed():
564             self.stream.close()
565             if self._read_until_future is not None and self._read_until_future.done():
566                 self._read_until_future.exception()
567     def __del__(self):
568         self.close()
569 class PubServer(salt.ext.tornado.tcpserver.TCPServer):
570     def __init__(
571         self, opts, io_loop=None, presence_callback=None, remove_presence_callback=None
572     ):
573         super().__init__(ssl_options=opts.get("ssl"))
574         self.io_loop = io_loop
575         self.opts = opts
576         self._closing = False
577         self.clients = set()
578         self.presence_events = False
579         if presence_callback:
580             self.presence_callback = presence_callback
581         else:
582             self.presence_callback = lambda subscriber, msg: msg
583         if remove_presence_callback:
584             self.remove_presence_callback = remove_presence_callback
585         else:
586             self.remove_presence_callback = lambda subscriber: subscriber
587     def close(self):
588         if self._closing:
589             return
590         self._closing = True
591         for client in self.clients:
592             client.stream.disconnect()
593     def __del__(self):
594         self.close()
595     @salt.ext.tornado.gen.coroutine
596     def _stream_read(self, client):
597         unpacker = salt.utils.msgpack.Unpacker()
598         while not self._closing:
599             try:
600                 client._read_until_future = client.stream.read_bytes(4096, partial=True)
601                 wire_bytes = yield client._read_until_future
602                 unpacker.feed(wire_bytes)
603                 for framed_msg in unpacker:
604                     framed_msg = salt.transport.frame.decode_embedded_strs(framed_msg)
605                     body = framed_msg["body"]
606                     if self.presence_callback:
607                         self.presence_callback(client, body)
608             except salt.ext.tornado.iostream.StreamClosedError as e:
609                 log.debug("tcp stream to %s closed, unable to recv", client.address)
610                 client.close()
611                 self.remove_presence_callback(client)
612                 self.clients.discard(client)
613                 break
614             except Exception as e:  # pylint: disable=broad-except
615                 log.error(
616                     "Exception parsing response from %s", client.address, exc_info=True
617                 )
618                 continue
619     def handle_stream(self, stream, address):
620         log.debug("Subscriber at %s connected", address)
621         client = Subscriber(stream, address)
622         self.clients.add(client)
623         self.io_loop.spawn_callback(self._stream_read, client)
624     @salt.ext.tornado.gen.coroutine
625     def publish_payload(self, package, topic_list=None):
626         log.trace("TCP PubServer sending payload: %s \n\n %r", package, topic_list)
627         payload = salt.transport.frame.frame_msg(package)
628         to_remove = []
629         if topic_list:
630             for topic in topic_list:
631                 sent = False
632                 for client in self.clients:
633                     if topic == client.id_:
634                         try:
635                             yield client.stream.write(payload)
636                             sent = True
637                         except salt.ext.tornado.iostream.StreamClosedError:
638                             to_remove.append(client)
639                 if not sent:
640                     log.debug("Publish target %s not connected %r", topic, self.clients)
641         else:
642             for client in self.clients:
643                 try:
644                     yield client.stream.write(payload)
645                 except salt.ext.tornado.iostream.StreamClosedError:
646                     to_remove.append(client)
647         for client in to_remove:
648             log.debug(
649                 "Subscriber at %s has disconnected from publisher", client.address
650             )
651             client.close()
652             self._remove_client_present(client)
653             self.clients.discard(client)
654         log.trace("TCP PubServer finished publishing payload")
655 class TCPPublishServer(salt.transport.base.DaemonizedPublishServer):
656     backlog = 128
657     def __init__(self, opts):
658         self.opts = opts
659         self.pub_sock = None
660     @property
661     def topic_support(self):
662         return not self.opts.get("order_masters", False)
663     def __setstate__(self, state):
664         self.__init__(state["opts"])
665     def __getstate__(self):
666         return {"opts": self.opts}
667     def publish_daemon(
668         self,
669         publish_payload,
670         presence_callback=None,
671         remove_presence_callback=None,
672     ):
673         io_loop = salt.ext.tornado.ioloop.IOLoop()
674         io_loop.make_current()
675         self.pub_server = pub_server = PubServer(
676             self.opts,
677             io_loop=io_loop,
678             presence_callback=presence_callback,
679             remove_presence_callback=remove_presence_callback,
680         )
681         sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
682         sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
683         _set_tcp_keepalive(sock, self.opts)
684         sock.setblocking(0)
685         sock.bind((self.opts["interface"], int(self.opts["publish_port"])))
686         sock.listen(self.backlog)
687         pub_server.add_socket(sock)
688         if self.opts.get("ipc_mode", "") == "tcp":
689             pull_uri = int(self.opts.get("tcp_master_publish_pull", 4514))
690         else:
691             pull_uri = os.path.join(self.opts["sock_dir"], "publish_pull.ipc")
692         self.pub_server = pub_server
693         pull_sock = salt.transport.ipc.IPCMessageServer(
694             pull_uri,
695             io_loop=io_loop,
696             payload_handler=publish_payload,
697         )
698         log.warn("Starting the Salt Puller on %s", pull_uri)
699         with salt.utils.files.set_umask(0o177):
700             pull_sock.start()
701         try:
702             io_loop.start()
703         except (KeyboardInterrupt, SystemExit):
704             pass
705         finally:
706             pull_sock.close()
707     def pre_fork(self, process_manager):
708         process_manager.add_process(self.publish_daemon, name=self.__class__.__name__)
709     @salt.ext.tornado.gen.coroutine
710     def publish_payload(self, payload, *args):
711         ret = yield self.pub_server.publish_payload(payload, *args)
712         raise salt.ext.tornado.gen.Return(ret)
713     def publish(self, payload, **kwargs):
714         if self.opts.get("ipc_mode", "") == "tcp":
715             pull_uri = int(self.opts.get("tcp_master_publish_pull", 4514))
716         else:
717             pull_uri = os.path.join(self.opts["sock_dir"], "publish_pull.ipc")
718         if not self.pub_sock:
719             self.pub_sock = salt.utils.asynchronous.SyncWrapper(
720                 salt.transport.ipc.IPCMessageClient,
721                 (pull_uri,),
722                 loop_kwarg="io_loop",
723             )
724             self.pub_sock.connect()
725         self.pub_sock.send(payload)
726     def close(self):
727         if self.pub_sock:
728             self.pub_sock.close()
729             self.pub_sock = None
730 class TCPReqClient(salt.transport.base.RequestClient):
731     ttype = "tcp"
732         self.opts = opts
733         self.io_loop = io_loop
734         parse = urllib<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.parse.urlparse(self.opts["master_uri"])
735         master_host, master_port = parse.netloc.rsplit(":", 1)
736         master_addr = (master_host, int(</b></font>master_port))
737         resolver = kwargs.get("resolver")
738         self.message_client = salt.transport.tcp.MessageClient(
739             opts,
740             master_host,
741             int(master_port),
742             io_loop=io_loop,
743             resolver=resolver,
744             source_ip=opts.get("source_ip"),
745             source_port=opts.get("source_ret_port"),
746         )
747     @salt.ext.tornado.gen.coroutine
748     def connect(self):
749         yield self.message_client.connect()
750     @salt.ext.tornado.gen.coroutine
751     def send(self, load, timeout=60):
752         ret = yield self.message_client.send(load, timeout=timeout)
753         raise salt.ext.tornado.gen.Return(ret)
754     def close(self):
755         self.message_client.close()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>debian_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import functools
2 import io
3 import logging
4 import os
5 import os.path
6 import re
7 import time
8 import jinja2
9 import jinja2.exceptions
10 import salt.utils.dns
11 import salt.utils.files
12 import salt.utils.odict
13 import salt.utils.stringutils
14 import salt.utils.templates
15 import</b></font> salt.utils.validate.net
16 log = logging.getLogger(__name__)
17 JINJA = jinja2.Environment(
18     loader=jinja2.FileSystemLoader(
19         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "debian_ip")
20     )
21 )
22 __virtualname__ = "ip"
23 def __virtual__():
24     if __grains__["os_family"] == "Debian":
25         return __virtualname__
26     return (False, "The debian_ip module could not be loaded: unsupported OS family")
27 _ETHTOOL_CONFIG_OPTS = {
28     "speed": "link-speed",
29     "duplex": "link-duplex",
30     "autoneg": "ethernet-autoneg",
31     "ethernet-port": "ethernet-port",
32     "wol": "ethernet-wol",
33     "driver-message-level": "driver-message-level",
34     "ethernet-pause-rx": "ethernet-pause-rx",
35     "ethernet-pause-tx": "ethernet-pause-tx",
36     "ethernet-pause-autoneg": "ethernet-pause-autoneg",
37     "rx": "offload-rx",
38     "tx": "offload-tx",
39     "sg": "offload-sg",
40     "tso": "offload-tso",
41     "ufo": "offload-ufo",
42     "gso": "offload-gso",
43     "gro": "offload-gro",
44     "lro": "offload-lro",
45     "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
46     "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
47     "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
48     "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
49     "hardware-dma-ring-rx": "hardware-dma-ring-rx",
50     "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
51     "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
52     "hardware-dma-ring-tx": "hardware-dma-ring-tx",
53 }
54 _REV_ETHTOOL_CONFIG_OPTS = {
55     "link-speed": "speed",
56     "link-duplex": "duplex",
57     "ethernet-autoneg": "autoneg",
58     "ethernet-port": "ethernet-port",
59     "ethernet-wol": "wol",
60     "driver-message-level": "driver-message-level",
61     "ethernet-pause-rx": "ethernet-pause-rx",
62     "ethernet-pause-tx": "ethernet-pause-tx",
63     "ethernet-pause-autoneg": "ethernet-pause-autoneg",
64     "offload-rx": "rx",
65     "offload-tx": "tx",
66     "offload-sg": "sg",
67     "offload-tso": "tso",
68     "offload-ufo": "ufo",
69     "offload-gso": "gso",
70     "offload-lro": "lro",
71     "offload-gro": "gro",
72     "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
73     "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
74     "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
75     "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
76     "hardware-dma-ring-rx": "hardware-dma-ring-rx",
77     "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
78     "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
79     "hardware-dma-ring-tx": "hardware-dma-ring-tx",
80 }
81 _DEB_CONFIG_PPPOE_OPTS = {
82     "user": "user",
83     "password": "password",
84     "provider": "provider",
85     "pppoe_iface": "pppoe_iface",
86     "noipdefault": "noipdefault",
87     "usepeerdns": "usepeerdns",
88     "defaultroute": "defaultroute",
89     "holdoff": "holdoff",
90     "maxfail": "maxfail",
91     "hide-password": "hide-password",
92     "lcp-echo-interval": "lcp-echo-interval",
93     "lcp-echo-failure": "lcp-echo-failure",
94     "connect": "connect",
95     "noauth": "noauth",
96     "persist": "persist",
97     "mtu": "mtu",
98     "noaccomp": "noaccomp",
99     "linkname": "linkname",
100 }
101 _DEB_ROUTES_FILE = "/etc/network/routes"
102 _DEB_NETWORK_FILE = "/etc/network/interfaces"
103 _DEB_NETWORK_DIR = "/etc/network/interfaces.d/"
104 _DEB_NETWORK_UP_DIR = "/etc/network/if-up.d/"
105 _DEB_NETWORK_DOWN_DIR = "/etc/network/if-down.d/"
106 _DEB_NETWORK_CONF_FILES = "/etc/modprobe.d/"
107 _DEB_NETWORKING_FILE = "/etc/default/networking"
108 _DEB_HOSTNAME_FILE = "/etc/hostname"
109 _DEB_RESOLV_FILE = "/etc/resolv.conf"
110 _DEB_PPP_DIR = "/etc/ppp/peers/"
111 _CONFIG_TRUE = ["yes", "on", "true", "1", True]
112 _CONFIG_FALSE = ["no", "off", "false", "0", False]
113 _IFACE_TYPES = [
114     "eth",
115     "bond",
116     "alias",
117     "clone",
118     "ipsec",
119     "dialup",
120     "bridge",
121     "slave",
122     "vlan",
123     "pppoe",
124     "source",
125 ]
126 def _error_msg_iface(iface, option, expected):
127     msg = "Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]"
128     return msg.format(iface, option, "|".join(str(e) for e in expected))
129 def _error_msg_routes(iface, option, expected):
130     msg = "Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]"
131     return msg.format(iface, option, expected)
132 def _log_default_iface(iface, opt, value):
133     log.info(
134         "Using default option -- Interface: %s Option: %s Value: %s", iface, opt, value
135     )
136 def _error_msg_network(option, expected):
137     msg = "Invalid network setting -- Setting: {0}, Expected: [{1}]"
138     return msg.format(option, "|".join(str(e) for e in expected))
139 def _log_default_network(opt, value):
140     log.info("Using existing setting -- Setting: %s Value: %s", opt, value)
141 def _raise_error_iface(iface, option, expected):
142     msg = _error_msg_iface(iface, option, expected)
143     log.error(msg)
144     raise AttributeError(msg)
145 def _raise_error_network(option, expected):
146     msg = _error_msg_network(option, expected)
147     log.error(msg)
148     raise AttributeError(msg)
149 def _raise_error_routes(iface, option, expected):
150     msg = _error_msg_routes(iface, option, expected)
151     log.error(msg)
152     raise AttributeError(msg)
153 def _read_file(path):
154     try:
155         with salt.utils.files.flopen(path, "rb") as contents:
156             return [
157                 salt.utils.stringutils.to_str(line) for line in contents.readlines()
158             ]
159     except OSError:
160         return ""
161 def _parse_resolve():
162     return salt.utils.dns.parse_resolv(_DEB_RESOLV_FILE)
163 def _parse_domainname():
164     return _parse_resolve().get("domain", "")
165 def _parse_searchdomain():
166     return _parse_resolve().get("search", "")
167 def _parse_hostname():
168     contents = _read_file(_DEB_HOSTNAME_FILE)
169     if contents:
170         return contents[0].split("\n")[0]
171     else:
172         return ""
173 def _parse_current_network_settings():
174     opts = salt.utils.odict.OrderedDict()
175     opts["networking"] = ""
176     if os.path.isfile(_DEB_NETWORKING_FILE):
177         with salt.utils.files.fopen(_DEB_NETWORKING_FILE) as contents:
178             for line in contents:
179                 salt.utils.stringutils.to_unicode(line)
180                 if line.startswith("#"):
181                     continue
182                 elif line.startswith("CONFIGURE_INTERFACES"):
183                     opts["networking"] = line.split("=", 1)[1].strip()
184     hostname = _parse_hostname()
185     domainname = _parse_domainname()
186     searchdomain = _parse_searchdomain()
187     opts["hostname"] = hostname
188     opts["domainname"] = domainname
189     opts["searchdomain"] = searchdomain
190     return opts
191 def __ipv4_quad(value):
192     return (salt.utils.validate.net.ipv4_addr(value), value, "dotted IPv4 address")
193 def __ipv6(value):
194     return (salt.utils.validate.net.ipv6_addr(value), value, "IPv6 address")
195 def __mac(value):
196     return (salt.utils.validate.net.mac(value), value, "MAC address")
197 def __anything(value):
198     return (True, value, None)
199 def __int(value):
200     valid, _value = False, value
201     try:
202         _value = int(value)
203         valid = True
204     except ValueError:
205         pass
206     return (valid, _value, "integer")
207 def __float(value):
208     valid, _value = False, value
209     try:
210         _value = float(value)
211         valid = True
212     except ValueError:
213         pass
214     return (valid, _value, "float")
215 def __ipv4_netmask(value):
216     valid, errmsg = False, "dotted quad or integer CIDR (0-&gt;32)"
217     valid, value, _ = __int(value)
218     if not (valid and 0 &lt;= value &lt;= 32):
219         valid = salt.utils.validate.net.netmask(value)
220     return (valid, value, errmsg)
221 def __ipv6_netmask(value):
222     valid, errmsg = False, "IPv6 netmask (0-&gt;128)"
223     valid, value, _ = __int(value)
224     valid = valid and 0 &lt;= value &lt;= 128
225     return (valid, value, errmsg)
226 def __within2(value, within=None, errmsg=None, dtype=None):
227     valid, _value = False, value
228     if dtype:
229         try:
230             _value = dtype(value)  # TODO: this is a bit loose when dtype is a class
231             valid = _value in within
232         except ValueError:
233             pass
234     else:
235         valid = _value in within
236     if errmsg is None:
237         if dtype:
238             typename = getattr(
239                 dtype,
240                 "__name__",
241                 hasattr(dtype, "__class__") and getattr(dtype.__class__, "name", dtype),
242             )
243             errmsg = "{} within '{}'".format(typename, within)
244         else:
245             errmsg = "within '{}'".format(within)
246     return (valid, _value, errmsg)
247 def __within(within=None, errmsg=None, dtype=None):
248     return functools.partial(__within2, within=within, errmsg=errmsg, dtype=dtype)
249 def __space_delimited_list(value):
250     if isinstance(value, str):
251         value = value.strip().split()
252     if hasattr(value, "__iter__") and value != []:
253         return (True, value, "space-delimited string")
254     else:
255         return (
256             False,
257             value,
258             "{} is not a valid space-delimited value.\n".format(value),
259         )
260 SALT_ATTR_TO_DEBIAN_ATTR_MAP = {
261     "dns": "dns-nameservers",
262     "search": "dns-search",
263     "hwaddr": "hwaddress",  # TODO: this limits bootp functionality
264     "ipaddr": "address",
265     "ipaddrs": "addresses",
266 }
267 DEBIAN_ATTR_TO_SALT_ATTR_MAP = {v: k for (k, v) in SALT_ATTR_TO_DEBIAN_ATTR_MAP.items()}
268 DEBIAN_ATTR_TO_SALT_ATTR_MAP["address"] = "address"
269 DEBIAN_ATTR_TO_SALT_ATTR_MAP["hwaddress"] = "hwaddress"
270 IPV4_VALID_PROTO = ["bootp", "dhcp", "static", "manual", "loopback", "ppp"]
271 IPV4_ATTR_MAP = {
272     "proto": __within(IPV4_VALID_PROTO, dtype=str),
273     "address": __ipv4_quad,
274     "addresses": __anything,
275     "netmask": __ipv4_netmask,
276     "broadcast": __ipv4_quad,
277     "metric": __int,
278     "gateway": __ipv4_quad,  # supports a colon-delimited list
279     "pointopoint": __ipv4_quad,
280     "hwaddress": __mac,
281     "mtu": __int,
282     "scope": __within(["global", "link", "host"], dtype=str),
283     "hostname": __anything,
284     "leasehours": __int,
285     "leasetime": __int,
286     "vendor": __anything,
287     "client": __anything,
288     "bootfile": __anything,
289     "server": __ipv4_quad,
290     "hwaddr": __mac,
291     "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
292     "endpoint": __ipv4_quad,
293     "dstaddr": __ipv4_quad,
294     "local": __ipv4_quad,
295     "ttl": __int,
296     "slaves": __anything,
297     "provider": __anything,
298     "unit": __int,
299     "options": __anything,
300     "dns-nameservers": __space_delimited_list,
301     "dns-search": __space_delimited_list,
302     "vlan-raw-device": __anything,
303     "network": __anything,  # i don't know what this is
304     "test": __anything,  # TODO
305     "enable_ipv4": __anything,  # TODO
306     "enable_ipv6": __anything,  # TODO
307 }
308 IPV6_VALID_PROTO = ["auto", "loopback", "static", "manual", "dhcp", "v4tunnel", "6to4"]
309 IPV6_ATTR_MAP = {
310     "proto": __within(IPV6_VALID_PROTO),
311     "address": __ipv6,
312     "addresses": __anything,
313     "netmask": __ipv6_netmask,
314     "broadcast": __ipv6,
315     "gateway": __ipv6,  # supports a colon-delimited list
316     "hwaddress": __mac,
317     "mtu": __int,
318     "scope": __within(["global", "site", "link", "host"], dtype=str),
319     "privext": __within([0, 1, 2], dtype=int),
320     "dhcp": __within([0, 1], dtype=int),
321     "media": __anything,
322     "accept_ra": __within([0, 1, 2], dtype=int),
323     "autoconf": __within([0, 1], dtype=int),
324     "preferred-lifetime": __int,
325     "dad-attempts": __int,  # 0 to disable
326     "dad-interval": __float,
327     "slaves": __anything,
328     "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
329     "endpoint": __ipv4_quad,
330     "local": __ipv4_quad,
331     "ttl": __int,
332     "dns-nameservers": __space_delimited_list,
333     "dns-search": __space_delimited_list,
334     "vlan-raw-device": __anything,
335     "test": __anything,  # TODO
336     "enable_ipv4": __anything,  # TODO
337     "enable_ipv6": __anything,  # TODO
338 }
339 WIRELESS_ATTR_MAP = {
340     "wireless-essid": __anything,
341     "wireless-mode": __anything,  # TODO
342     "wpa-ap-scan": __within([0, 1, 2], dtype=int),  # TODO
343     "wpa-conf": __anything,
344     "wpa-driver": __anything,
345     "wpa-group": __anything,
346     "wpa-key-mgmt": __anything,
347     "wpa-pairwise": __anything,
348     "wpa-psk": __anything,
349     "wpa-proto": __anything,  # partial(__within,
350     "wpa-roam": __anything,
351     "wpa-ssid": __anything,  # TODO
352 }
353 ATTRMAPS = {
354     "inet": [IPV4_ATTR_MAP, WIRELESS_ATTR_MAP],
355     "inet6": [IPV6_ATTR_MAP, WIRELESS_ATTR_MAP],
356 }
357 def _validate_interface_option(attr, value, addrfam="inet"):
358     valid, _value, errmsg = False, value, "Unknown validator"
359     attrmaps = ATTRMAPS.get(addrfam, [])
360     for attrmap in attrmaps:
361         if attr in attrmap:
362             validate_func = attrmap[attr]
363             (valid, _value, errmsg) = validate_func(value)
364             break
365     return (valid, _value, errmsg)
366 def _attrmaps_contain_attr(attr):
367     return attr in WIRELESS_ATTR_MAP or attr in IPV4_ATTR_MAP or attr in IPV6_ATTR_MAP
368 def _parse_interfaces(interface_files=None):
369     if interface_files is None:
370         interface_files = []
371         if os.path.exists(_DEB_NETWORK_DIR):
372             interface_files += [
373                 "{}/{}".format(_DEB_NETWORK_DIR, dir)
374                 for dir in os.listdir(_DEB_NETWORK_DIR)
375             ]
376         if os.path.isfile(_DEB_NETWORK_FILE):
377             interface_files.insert(0, _DEB_NETWORK_FILE)
378     adapters = salt.utils.odict.OrderedDict()
379     method = -1
380     for interface_file in interface_files:
381         with salt.utils.files.fopen(interface_file) as interfaces:
382             iface_dict = {}
383             for line in interfaces:
384                 line = salt.utils.stringutils.to_unicode(line)
385                 if line.lstrip().startswith("#") or line.isspace():
386                     continue
387                 if line.startswith("iface"):
388                     sline = line.split()
389                     if len(sline) != 4:
390                         msg = "Interface file malformed: {0}."
391                         msg = msg.format(sline)
392                         log.error(msg)
393                         raise AttributeError(msg)
394                     iface_name = sline[1]
395                     addrfam = sline[2]
396                     method = sline[3]
397                     if iface_name not in adapters:
398                         adapters[iface_name] = salt.utils.odict.OrderedDict()
399                     if "data" not in adapters[iface_name]:
400                         adapters[iface_name]["data"] = salt.utils.odict.OrderedDict()
401                     if addrfam not in adapters[iface_name]["data"]:
402                         adapters[iface_name]["data"][
403                             addrfam
404                         ] = salt.utils.odict.OrderedDict()
405                     iface_dict = adapters[iface_name]["data"][addrfam]
406                     iface_dict["addrfam"] = addrfam
407                     iface_dict["proto"] = method
408                     iface_dict["filename"] = interface_file
409                 elif line[0].isspace():
410                     sline = line.split()
411                     attr, valuestr = line.rstrip().split(None, 1)
412                     if _attrmaps_contain_attr(attr):
413                         if "-" in attr:
414                             attrname = attr.replace("-", "_")
415                         else:
416                             attrname = attr
417                         (valid, value, errmsg) = _validate_interface_option(
418                             attr, valuestr, addrfam
419                         )
420                         if attrname == "address" and "address" in iface_dict:
421                             if "addresses" not in iface_dict:
422                                 iface_dict["addresses"] = []
423                             iface_dict["addresses"].append(value)
424                         else:
425                             iface_dict[attrname] = value
426                     elif attr in _REV_ETHTOOL_CONFIG_OPTS:
427                         if "ethtool" not in iface_dict:
428                             iface_dict["ethtool"] = salt.utils.odict.OrderedDict()
429                         iface_dict["ethtool"][attr] = valuestr
430                     elif attr.startswith("bond"):
431                         opt = re.split(r"[_-]", attr, maxsplit=1)[1]
432                         if "bonding" not in iface_dict:
433                             iface_dict["bonding"] = salt.utils.odict.OrderedDict()
434                         iface_dict["bonding"][opt] = valuestr
435                     elif attr.startswith("bridge"):
436                         opt = re.split(r"[_-]", attr, maxsplit=1)[1]
437                         if "bridging" not in iface_dict:
438                             iface_dict["bridging"] = salt.utils.odict.OrderedDict()
439                         iface_dict["bridging"][opt] = valuestr
440                     elif attr in [
441                         "up",
442                         "pre-up",
443                         "post-up",
444                         "down",
445                         "pre-down",
446                         "post-down",
447                     ]:
448                         cmd = valuestr
449                         cmd_key = "{}_cmds".format(re.sub("-", "_", attr))
450                         if cmd_key not in iface_dict:
451                             iface_dict[cmd_key] = []
452                         iface_dict[cmd_key].append(cmd)
453                 elif line.startswith("auto"):
454                     for word in line.split()[1:]:
455                         if word not in adapters:
456                             adapters[word] = salt.utils.odict.OrderedDict()
457                         adapters[word]["enabled"] = True
458                 elif line.startswith("allow-hotplug"):
459                     for word in line.split()[1:]:
460                         if word not in adapters:
461                             adapters[word] = salt.utils.odict.OrderedDict()
462                         adapters[word]["hotplug"] = True
463                 elif line.startswith("source"):
464                     if "source" not in adapters:
465                         adapters["source"] = salt.utils.odict.OrderedDict()
466                     if "data" not in adapters["source"]:
467                         adapters["source"]["data"] = salt.utils.odict.OrderedDict()
468                         adapters["source"]["data"]["sources"] = []
469                     adapters["source"]["data"]["sources"].append(line.split()[1])
470     adapters = _filter_malformed_interfaces(adapters=adapters)
471     return adapters
472 def _filter_malformed_interfaces(*, adapters):
473     for iface_name in list(adapters):
474         if iface_name == "source":
475             continue
476         if "data" not in adapters[iface_name]:
477             msg = "Interface file malformed for interface: {}.".format(iface_name)
478             log.error(msg)
479             adapters.pop(iface_name)
480             continue
481         for opt in ["ethtool", "bonding", "bridging"]:
482             for inet in ["inet", "inet6"]:
483                 if inet in adapters[iface_name]["data"]:
484                     if opt in adapters[iface_name]["data"][inet]:
485                         opt_keys = sorted(
486                             adapters[iface_name]["data"][inet][opt].keys()
487                         )
488                         adapters[iface_name]["data"][inet][opt + "_keys"] = opt_keys
489     return adapters
490 def _parse_ethtool_opts(opts, iface):
491     config = {}
492     if "autoneg" in opts:
493         if opts["autoneg"] in _CONFIG_TRUE:
494             config.update({"autoneg": "on"})
495         elif opts["autoneg"] in _CONFIG_FALSE:
496             config.update({"autoneg": "off"})
497         else:
498             _raise_error_iface(iface, "autoneg", _CONFIG_TRUE + _CONFIG_FALSE)
499     if "duplex" in opts:
500         valid = ["full", "half"]
501         if opts["duplex"] in valid:
502             config.update({"duplex": opts["duplex"]})
503         else:
504             _raise_error_iface(iface, "duplex", valid)
505     if "speed" in opts:
506         valid = ["10", "100", "1000", "10000"]
507         if str(opts["speed"]) in valid:
508             config.update({"speed": opts["speed"]})
509         else:
510             _raise_error_iface(iface, opts["speed"], valid)
511     valid = _CONFIG_TRUE + _CONFIG_FALSE
512     for option in ("rx", "tx", "sg", "tso", "ufo", "gso", "gro", "lro"):
513         if option in opts:
514             if opts[option] in _CONFIG_TRUE:
515                 config.update({option: "on"})
516             elif opts[option] in _CONFIG_FALSE:
517                 config.update({option: "off"})
518             else:
519                 _raise_error_iface(iface, option, valid)
520     return config
521 def _parse_ethtool_pppoe_opts(opts, iface):
522     config = {}
523     for opt in _DEB_CONFIG_PPPOE_OPTS:
524         if opt in opts:
525             config[opt] = opts[opt]
526     if "provider" in opts and not opts["provider"]:
527         _raise_error_iface(iface, "provider", _CONFIG_TRUE + _CONFIG_FALSE)
528     valid = _CONFIG_TRUE + _CONFIG_FALSE
529     for option in (
530         "noipdefault",
531         "usepeerdns",
532         "defaultroute",
533         "hide-password",
534         "noauth",
535         "persist",
536         "noaccomp",
537     ):
538         if option in opts:
539             if opts[option] in _CONFIG_TRUE:
540                 config.update({option: "True"})
541             elif opts[option] in _CONFIG_FALSE:
542                 config.update({option: "False"})
543             else:
544                 _raise_error_iface(iface, option, valid)
545     return config
546 def _parse_settings_bond(opts, iface):
547     bond_def = {
548         "ad_select": "0",
549         "tx_queues": "16",
550         "miimon": "100",
551         "arp_interval": "250",
552         "downdelay": "200",
553         "lacp_rate": "0",
554         "max_bonds": "1",
555         "updelay": "0",
556         "use_carrier": "on",
557         "xmit_hash_policy": "layer2",
558     }
559     if opts["mode"] in ["balance-rr", "0"]:
560         log.info("Device: %s Bonding Mode: load balancing (round-robin)", iface)
561         return _parse_settings_bond_0(opts, iface, bond_def)
562     elif opts["mode"] in ["active-backup", "1"]:
563         log.info("Device: %s Bonding Mode: fault-tolerance (active-backup)", iface)
564         return _parse_settings_bond_1(opts, iface, bond_def)
565     elif opts["mode"] in ["balance-xor", "2"]:
566         log.info("Device: %s Bonding Mode: load balancing (xor)", iface)
567         return _parse_settings_bond_2(opts, iface, bond_def)
568     elif opts["mode"] in ["broadcast", "3"]:
569         log.info("Device: %s Bonding Mode: fault-tolerance (broadcast)", iface)
570         return _parse_settings_bond_3(opts, iface, bond_def)
571     elif opts["mode"] in ["802.3ad", "4"]:
572         log.info(
573             "Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation", iface
574         )
575         return _parse_settings_bond_4(opts, iface, bond_def)
576     elif opts["mode"] in ["balance-tlb", "5"]:
577         log.info("Device: %s Bonding Mode: transmit load balancing", iface)
578         return _parse_settings_bond_5(opts, iface, bond_def)
579     elif opts["mode"] in ["balance-alb", "6"]:
580         log.info("Device: %s Bonding Mode: adaptive load balancing", iface)
581         return _parse_settings_bond_6(opts, iface, bond_def)
582     else:
583         valid = [
584             "0",
585             "1",
586             "2",
587             "3",
588             "4",
589             "5",
590             "6",
591             "balance-rr",
592             "active-backup",
593             "balance-xor",
594             "broadcast",
595             "802.3ad",
596             "balance-tlb",
597             "balance-alb",
598         ]
599         _raise_error_iface(iface, "mode", valid)
600 def _parse_settings_bond_0(opts, iface, bond_def):
601     bond = {"mode": "0"}
602     valid = ["list of ips (up to 16)"]
603     if "arp_ip_target" in opts:
604         if isinstance(opts["arp_ip_target"], list):
605             if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
606                 bond.update({"arp_ip_target": ""})
607                 for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
608                     if len(bond["arp_ip_target"]) &gt; 0:
609                         bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
610                     else:
611                         bond["arp_ip_target"] = ip
612             else:
613                 _raise_error_iface(iface, "arp_ip_target", valid)
614         else:
615             _raise_error_iface(iface, "arp_ip_target", valid)
616     else:
617         _raise_error_iface(iface, "arp_ip_target", valid)
618     if "arp_interval" in opts:
619         try:
620             int(opts["arp_interval"])
621             bond.update({"arp_interval": opts["arp_interval"]})
622         except ValueError:
623             _raise_error_iface(iface, "arp_interval", ["integer"])
624     else:
625         _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
626         bond.update({"arp_interval": bond_def["arp_interval"]})
627     return bond
628 def _parse_settings_bond_1(opts, iface, bond_def):
629     bond = {"mode": "1"}
630     for binding in ["miimon", "downdelay", "updelay"]:
631         if binding in opts:
632             try:
633                 int(opts[binding])
634                 bond.update({binding: opts[binding]})
635             except ValueError:
636                 _raise_error_iface(iface, binding, ["integer"])
637         else:
638             _log_default_iface(iface, binding, bond_def[binding])
639             bond.update({binding: bond_def[binding]})
640     if "primary" in opts:
641         bond.update({"primary": opts["primary"]})
642     if not (__grains__["os"] == "Ubuntu" and __grains__["osrelease_info"][0] &gt;= 16):
643         if "use_carrier" in opts:
644             if opts["use_carrier"] in _CONFIG_TRUE:
645                 bond.update({"use_carrier": "1"})
646             elif opts["use_carrier"] in _CONFIG_FALSE:
647                 bond.update({"use_carrier": "0"})
648             else:
649                 valid = _CONFIG_TRUE + _CONFIG_FALSE
650                 _raise_error_iface(iface, "use_carrier", valid)
651         else:
652             _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
653             bond.update({"use_carrier": bond_def["use_carrier"]})
654     return bond
655 def _parse_settings_bond_2(opts, iface, bond_def):
656     bond = {"mode": "2"}
657     valid = ["list of ips (up to 16)"]
658     if "arp_ip_target" in opts:
659         if isinstance(opts["arp_ip_target"], list):
660             if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
661                 bond.update({"arp_ip_target": ""})
662                 for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
663                     if len(bond["arp_ip_target"]) &gt; 0:
664                         bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
665                     else:
666                         bond["arp_ip_target"] = ip
667             else:
668                 _raise_error_iface(iface, "arp_ip_target", valid)
669         else:
670             _raise_error_iface(iface, "arp_ip_target", valid)
671     else:
672         _raise_error_iface(iface, "arp_ip_target", valid)
673     if "arp_interval" in opts:
674         try:
675             int(opts["arp_interval"])
676             bond.update({"arp_interval": opts["arp_interval"]})
677         except ValueError:
678             _raise_error_iface(iface, "arp_interval", ["integer"])
679     else:
680         _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
681         bond.update({"arp_interval": bond_def["arp_interval"]})
682     if "hashing-algorithm" in opts:
683         valid = ["layer2", "layer2+3", "layer3+4"]
684         if opts["hashing-algorithm"] in valid:
685             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
686         else:
687             _raise_error_iface(iface, "hashing-algorithm", valid)
688     return bond
689 def _parse_settings_bond_3(opts, iface, bond_def):
690     bond = {"mode": "3"}
691     for binding in ["miimon", "downdelay", "updelay"]:
692         if binding in opts:
693             try:
694                 int(opts[binding])
695                 bond.update({binding: opts[binding]})
696             except ValueError:
697                 _raise_error_iface(iface, binding, ["integer"])
698         else:
699             _log_default_iface(iface, binding, bond_def[binding])
700             bond.update({binding: bond_def[binding]})
701     if "use_carrier" in opts:
702         if opts["use_carrier"] in _CONFIG_TRUE:
703             bond.update({"use_carrier": "1"})
704         elif opts["use_carrier"] in _CONFIG_FALSE:
705             bond.update({"use_carrier": "0"})
706         else:
707             valid = _CONFIG_TRUE + _CONFIG_FALSE
708             _raise_error_iface(iface, "use_carrier", valid)
709     else:
710         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
711         bond.update({"use_carrier": bond_def["use_carrier"]})
712     return bond
713 def _parse_settings_bond_4(opts, iface, bond_def):
714     bond = {"mode": "4"}
715     for binding in ["miimon", "downdelay", "updelay", "lacp_rate", "ad_select"]:
716         if binding in opts:
717             if binding == "lacp_rate":
718                 if opts[binding] == "fast":
719                     opts.update({binding: "1"})
720                 if opts[binding] == "slow":
721                     opts.update({binding: "0"})
722                 valid = ["fast", "1", "slow", "0"]
723             else:
724                 valid = ["integer"]
725             try:
726                 int(opts[binding])
727                 bond.update({binding: opts[binding]})
728             except ValueError:
729                 _raise_error_iface(iface, binding, valid)
730         else:
731             _log_default_iface(iface, binding, bond_def[binding])
732             bond.update({binding: bond_def[binding]})
733     if "use_carrier" in opts:
734         if opts["use_carrier"] in _CONFIG_TRUE:
735             bond.update({"use_carrier": "1"})
736         elif opts["use_carrier"] in _CONFIG_FALSE:
737             bond.update({"use_carrier": "0"})
738         else:
739             valid = _CONFIG_TRUE + _CONFIG_FALSE
740             _raise_error_iface(iface, "use_carrier", valid)
741     else:
742         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
743         bond.update({"use_carrier": bond_def["use_carrier"]})
744     if "hashing-algorithm" in opts:
745         valid = ["layer2", "layer2+3", "layer3+4"]
746         if opts["hashing-algorithm"] in valid:
747             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
748         else:
749             _raise_error_iface(iface, "hashing-algorithm", valid)
750     return bond
751 def _parse_settings_bond_5(opts, iface, bond_def):
752     bond = {"mode": "5"}
753     for binding in ["miimon", "downdelay", "updelay"]:
754         if binding in opts:
755             try:
756                 int(opts[binding])
757                 bond.update({binding: opts[binding]})
758             except ValueError:
759                 _raise_error_iface(iface, binding, ["integer"])
760         else:
761             _log_default_iface(iface, binding, bond_def[binding])
762             bond.update({binding: bond_def[binding]})
763     if "use_carrier" in opts:
764         if opts["use_carrier"] in _CONFIG_TRUE:
765             bond.update({"use_carrier": "1"})
766         elif opts["use_carrier"] in _CONFIG_FALSE:
767             bond.update({"use_carrier": "0"})
768         else:
769             valid = _CONFIG_TRUE + _CONFIG_FALSE
770             _raise_error_iface(iface, "use_carrier", valid)
771     else:
772         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
773         bond.update({"use_carrier": bond_def["use_carrier"]})
774     if "primary" in opts:
775         bond.update({"primary": opts["primary"]})
776     return bond
777 def _parse_settings_bond_6(opts, iface, bond_def):
778     bond = {"mode": "6"}
779     for binding in ["miimon", "downdelay", "updelay"]:
780         if binding in opts:
781             try:
782                 int(opts[binding])
783                 bond.update({binding: opts[binding]})
784             except ValueError:
785                 _raise_error_iface(iface, binding, ["integer"])
786         else:
787             _log_default_iface(iface, binding, bond_def[binding])
788             bond.update({binding: bond_def[binding]})
789     if "use_carrier" in opts:
790         if opts["use_carrier"] in _CONFIG_TRUE:
791             bond.update({"use_carrier": "1"})
792         elif opts["use_carrier"] in _CONFIG_FALSE:
793             bond.update({"use_carrier": "0"})
794         else:
795             valid = _CONFIG_TRUE + _CONFIG_FALSE
796             _raise_error_iface(iface, "use_carrier", valid)
797     else:
798         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
799         bond.update({"use_carrier": bond_def["use_carrier"]})
800     if "primary" in opts:
801         bond.update({"primary": opts["primary"]})
802     return bond
803 def _parse_bridge_opts(opts, iface):
804     config = {}
805     if "ports" in opts:
806         if isinstance(opts["ports"], list):
807             opts["ports"] = " ".join(opts["ports"])
808         config.update({"ports": opts["ports"]})
809     for opt in ["ageing", "fd", "gcint", "hello", "maxage"]:
810         if opt in opts:
811             try:
812                 float(opts[opt])
813                 config.update({opt: opts[opt]})
814             except ValueError:
815                 _raise_error_iface(iface, opt, ["float"])
816     for opt in ["bridgeprio", "maxwait"]:
817         if opt in opts:
818             if isinstance(opts[opt], int):
819                 config.update({opt: opts[opt]})
820             else:
821                 _raise_error_iface(iface, opt, ["integer"])
822     if "hw" in opts:
823         if re.match(
824             "[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", opts["hw"].lower()
825         ):
826             config.update({"hw": opts["hw"]})
827         else:
828             _raise_error_iface(iface, "hw", ["valid MAC address"])
829     for opt in ["pathcost", "portprio"]:
830         if opt in opts:
831             try:
832                 port, cost_or_prio = opts[opt].split()
833                 int(cost_or_prio)
834                 config.update({opt: "{} {}".format(port, cost_or_prio)})
835             except ValueError:
836                 _raise_error_iface(iface, opt, ["interface integer"])
837     if "stp" in opts:
838         if opts["stp"] in _CONFIG_TRUE:
839             config.update({"stp": "on"})
840         elif opts["stp"] in _CONFIG_FALSE:
841             config.update({"stp": "off"})
842         else:
843 <a name="2"></a>            _raise_error_iface(iface, "stp", _CONFIG_TRUE + _CONFIG_FALSE)
844     if "waitport" in opts:
845         if isinstance(opts<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["waitport"], int):
846             config.update({"waitport": opts["waitport"]})
847         else:
848             values = opts["waitport"].split()
849             waitport_time = values.pop(</b></font>0)
850             if waitport_time.isdigit() and values:
851                 config.update(
852                     {"waitport": "{} {}".format(waitport_time, " ".join(values))}
853                 )
854             else:
855                 _raise_error_iface(iface, opt, ["integer [interfaces]"])
856     return config
857 def _parse_settings_eth(opts, iface_type, enabled, iface):
858     adapters = salt.utils.odict.OrderedDict()
859     adapters[iface] = salt.utils.odict.OrderedDict()
860 <a name="1"></a>
861     adapters[iface]["type"] = iface_type
862     adapters[iface]["data"] = salt.utils.odict<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.OrderedDict()
863     iface_data = adapters[iface]["data"]
864     iface_data["inet"] = salt.utils.odict.OrderedDict()
865     iface_data["inet6"] = salt.</b></font>utils.odict.OrderedDict()
866     if enabled:
867         adapters[iface]["enabled"] = True
868     if opts.get("hotplug", False):
869         adapters[iface]["hotplug"] = True
870     if opts.get("enable_ipv6", None) and opts.get("iface_type", "") == "vlan":
871         iface_data["inet6"]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
872     for addrfam in ["inet", "inet6"]:
873         if iface_type not in ["bridge"]:
874             tmp_ethtool = _parse_ethtool_opts(opts, iface)
875             if tmp_ethtool:
876                 ethtool = {}
877                 for item in tmp_ethtool:
878                     ethtool[_ETHTOOL_CONFIG_OPTS[item]] = tmp_ethtool[item]
879                 iface_data[addrfam]["ethtool"] = ethtool
880                 iface_data[addrfam]["ethtool_keys"] = sorted(ethtool)
881         if iface_type == "bridge":
882             bridging = _parse_bridge_opts(opts, iface)
883             if bridging:
884                 iface_data[addrfam]["bridging"] = bridging
885                 iface_data[addrfam]["bridging_keys"] = sorted(bridging)
886                 iface_data[addrfam]["addrfam"] = addrfam
887         elif iface_type == "bond":
888             bonding = _parse_settings_bond(opts, iface)
889             if bonding:
890                 iface_data[addrfam]["bonding"] = bonding
891                 iface_data[addrfam]["bonding"]["slaves"] = opts["slaves"]
892                 iface_data[addrfam]["bonding_keys"] = sorted(bonding)
893                 iface_data[addrfam]["addrfam"] = addrfam
894         elif iface_type == "slave":
895             adapters[iface]["master"] = opts["master"]
896             opts["proto"] = "manual"
897             iface_data[addrfam]["master"] = adapters[iface]["master"]
898             iface_data[addrfam]["addrfam"] = addrfam
899         elif iface_type == "vlan":
900             iface_data[addrfam]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
901             iface_data[addrfam]["addrfam"] = addrfam
902         elif iface_type == "pppoe":
903             tmp_ethtool = _parse_ethtool_pppoe_opts(opts, iface)
904             if tmp_ethtool:
905                 for item in tmp_ethtool:
906                     adapters[iface]["data"][addrfam][
907                         _DEB_CONFIG_PPPOE_OPTS[item]
908                     ] = tmp_ethtool[item]
909             iface_data[addrfam]["addrfam"] = addrfam
910     opts.pop("mode", None)
911     for opt, val in opts.items():
912         inet = None
913         if opt.startswith("ipv4"):
914             opt = opt[4:]
915             inet = "inet"
916             iface_data["inet"]["addrfam"] = "inet"
917         elif opt.startswith("ipv6"):
918             iface_data["inet6"]["addrfam"] = "inet6"
919             opt = opt[4:]
920             inet = "inet6"
921         elif opt in [
922             "ipaddr",
923             "address",
924             "ipaddresses",
925             "addresses",
926             "gateway",
927             "proto",
928         ]:
929             iface_data["inet"]["addrfam"] = "inet"
930             inet = "inet"
931         _opt = SALT_ATTR_TO_DEBIAN_ATTR_MAP.get(opt, opt)
932         _debopt = _opt.replace("-", "_")
933         for addrfam in ["inet", "inet6"]:
934             (valid, value, errmsg) = _validate_interface_option(
935                 _opt, val, addrfam=addrfam
936             )
937             if not valid:
938                 continue
939             if inet is None and _debopt not in iface_data[addrfam]:
940                 iface_data[addrfam][_debopt] = value
941             elif inet == addrfam:
942                 iface_data[addrfam][_debopt] = value
943     for opt in [
944         "up_cmds",
945         "pre_up_cmds",
946         "post_up_cmds",
947         "down_cmds",
948         "pre_down_cmds",
949         "post_down_cmds",
950     ]:
951         if opt in opts:
952             iface_data["inet"][opt] = opts[opt]
953             iface_data["inet6"][opt] = opts[opt]
954     for (addrfam, opt) in [("inet", "enable_ipv4"), ("inet6", "enable_ipv6")]:
955         if opts.get(opt, None) is False:
956             iface_data.pop(addrfam)
957         elif iface_data[addrfam].get("addrfam", "") != addrfam:
958             iface_data.pop(addrfam)
959     return adapters
960 def _parse_settings_source(opts, iface_type, enabled, iface):
961     adapters = salt.utils.odict.OrderedDict()
962     adapters[iface] = salt.utils.odict.OrderedDict()
963     adapters[iface]["type"] = iface_type
964     adapters[iface]["data"] = salt.utils.odict.OrderedDict()
965     iface_data = adapters[iface]["data"]
966     iface_data["sources"] = [opts["source"]]
967     return adapters
968 def _parse_network_settings(opts, current):
969     opts = {k.lower(): v for (k, v) in opts.items()}
970     current = {k.lower(): v for (k, v) in current.items()}
971     result = {}
972     valid = _CONFIG_TRUE + _CONFIG_FALSE
973     if "enabled" not in opts:
974         try:
975             opts["networking"] = current["networking"]
976             _log_default_network("networking", current["networking"])
977         except ValueError:
978             _raise_error_network("networking", valid)
979     else:
980         opts["networking"] = opts["enabled"]
981     if opts["networking"] in valid:
982         if opts["networking"] in _CONFIG_TRUE:
983             result["networking"] = "yes"
984         elif opts["networking"] in _CONFIG_FALSE:
985             result["networking"] = "no"
986     else:
987         _raise_error_network("networking", valid)
988     if "hostname" not in opts:
989         try:
990             opts["hostname"] = current["hostname"]
991             _log_default_network("hostname", current["hostname"])
992         except ValueError:
993             _raise_error_network("hostname", ["server1.example.com"])
994     if opts["hostname"]:
995         result["hostname"] = opts["hostname"]
996     else:
997         _raise_error_network("hostname", ["server1.example.com"])
998     if "search" in opts:
999         result["search"] = opts["search"]
1000     return result
1001 def _parse_routes(iface, opts):
1002     opts = {k.lower(): v for (k, v) in opts.items()}
1003     result = {}
1004     if "routes" not in opts:
1005         _raise_error_routes(iface, "routes", "List of routes")
1006     for opt in opts:
1007         result[opt] = opts[opt]
1008     return result
1009 def _write_file(iface, data, folder, pattern):
1010     filename = os.path.join(folder, pattern.format(iface))
1011     if not os.path.exists(folder):
1012         msg = "{0} cannot be written. {1} does not exist"
1013         msg = msg.format(filename, folder)
1014         log.error(msg)
1015         raise AttributeError(msg)
1016     with salt.utils.files.flopen(filename, "w") as fout:
1017         fout.write(salt.utils.stringutils.to_str(data))
1018     return filename
1019 def _write_file_routes(iface, data, folder, pattern):
1020     iface = iface.replace(".", "_")
1021     filename = os.path.join(folder, pattern.format(iface))
1022     if not os.path.exists(folder):
1023         msg = "{0} cannot be written. {1} does not exist"
1024         msg = msg.format(filename, folder)
1025         log.error(msg)
1026         raise AttributeError(msg)
1027     with salt.utils.files.flopen(filename, "w") as fout:
1028         fout.write(salt.utils.stringutils.to_str(data))
1029     __salt__["file.set_mode"](filename, "0755")
1030     return filename
1031 def _write_file_network(data, filename, create=False):
1032     if not os.path.exists(filename) and not create:
1033         msg = "{0} cannot be written. {0} does not exist and create is setto False".format(
1034             filename
1035         )
1036         log.error(msg)
1037         raise AttributeError(msg)
1038     with salt.utils.files.flopen(filename, "w") as fout:
1039         fout.write(salt.utils.stringutils.to_str(data))
1040 def _read_temp(data):
1041     tout = io.StringIO()
1042     tout.write(data)
1043     tout.seek(0)
1044     output = tout.readlines()
1045     tout.close()
1046     return output
1047 def _read_temp_ifaces(iface, data):
1048     try:
1049         template = JINJA.get_template("debian_eth.jinja")
1050     except jinja2.exceptions.TemplateNotFound:
1051         log.error("Could not load template debian_eth.jinja")
1052         return ""
1053     ifcfg = template.render({"name": iface, "data": data})
1054     return [item + "\n" for item in ifcfg.split("\n")]
1055 def _write_file_ifaces(iface, data, **settings):
1056     try:
1057         eth_template = JINJA.get_template("debian_eth.jinja")
1058         source_template = JINJA.get_template("debian_source.jinja")
1059     except jinja2.exceptions.TemplateNotFound:
1060         log.error("Could not load template debian_eth.jinja")
1061         return ""
1062     adapters = _parse_interfaces()
1063     adapters[iface] = data
1064     ifcfg = ""
1065     for adapter in adapters:
1066         if "type" in adapters[adapter] and adapters[adapter]["type"] == "source":
1067             tmp = source_template.render({"name": adapter, "data": adapters[adapter]})
1068         else:
1069             tmp = eth_template.render({"name": adapter, "data": adapters[adapter]})
1070         ifcfg = ifcfg + tmp
1071         if adapter == iface:
1072             saved_ifcfg = tmp
1073     _SEPARATE_FILE = False
1074     if "filename" in settings:
1075         if not settings["filename"].startswith("/"):
1076             filename = "{}/{}".format(_DEB_NETWORK_DIR, settings["filename"])
1077         else:
1078             filename = settings["filename"]
1079         _SEPARATE_FILE = True
1080     else:
1081         if "filename" in adapters[adapter]["data"]:
1082             filename = adapters[adapter]["data"]
1083         else:
1084             filename = _DEB_NETWORK_FILE
1085     if not os.path.exists(os.path.dirname(filename)):
1086         msg = "{0} cannot be written."
1087         msg = msg.format(os.path.dirname(filename))
1088         log.error(msg)
1089         raise AttributeError(msg)
1090     with salt.utils.files.flopen(filename, "w") as fout:
1091         if _SEPARATE_FILE:
1092             fout.write(salt.utils.stringutils.to_str(saved_ifcfg))
1093         else:
1094             fout.write(salt.utils.stringutils.to_str(ifcfg))
1095     return saved_ifcfg.split("\n")
1096 def _write_file_ppp_ifaces(iface, data):
1097     try:
1098         template = JINJA.get_template("debian_ppp_eth.jinja")
1099     except jinja2.exceptions.TemplateNotFound:
1100         log.error("Could not load template debian_ppp_eth.jinja")
1101         return ""
1102     adapters = _parse_interfaces()
1103     adapters[iface] = data
1104     ifcfg = ""
1105     tmp = template.render({"data": adapters[iface]})
1106     ifcfg = tmp + ifcfg
1107     filename = _DEB_PPP_DIR + "/" + adapters[iface]["data"]["inet"]["provider"]
1108     if not os.path.exists(os.path.dirname(filename)):
1109         msg = "{0} cannot be written."
1110         msg = msg.format(os.path.dirname(filename))
1111         log.error(msg)
1112         raise AttributeError(msg)
1113     with salt.utils.files.fopen(filename, "w") as fout:
1114         fout.write(salt.utils.stringutils.to_str(ifcfg))
1115     return filename
1116 def build_bond(iface, **settings):
1117     deb_major = __grains__["osrelease"][:1]
1118     opts = _parse_settings_bond(settings, iface)
1119     try:
1120         template = JINJA.get_template("conf.jinja")
1121     except jinja2.exceptions.TemplateNotFound:
1122         log.error("Could not load template conf.jinja")
1123         return ""
1124     data = template.render({"name": iface, "bonding": opts})
1125     if "test" in settings and settings["test"]:
1126         return _read_temp(data)
1127     _write_file(iface, data, _DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1128     path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1129     if deb_major == "5":
1130         for line_type in ("alias", "options"):
1131             cmd = [
1132                 "sed",
1133                 "-i",
1134                 "-e",
1135                 r"/^{}\s{}.*/d".format(line_type, iface),
1136                 "/etc/modprobe.conf",
1137             ]
1138             __salt__["cmd.run"](cmd, python_shell=False)
1139         __salt__["file.append"]("/etc/modprobe.conf", path)
1140     __salt__["kmod.load"]("bonding")
1141     __salt__["pkg.install"]("ifenslave")
1142     return _read_file(path)
1143 def build_interface(iface, iface_type, enabled, **settings):
1144     iface_type = iface_type.lower()
1145     if iface_type not in _IFACE_TYPES:
1146         _raise_error_iface(iface, iface_type, _IFACE_TYPES)
1147     if iface_type == "slave":
1148         settings["slave"] = "yes"
1149         if "master" not in settings:
1150             msg = "master is a required setting for slave interfaces"
1151             log.error(msg)
1152             raise AttributeError(msg)
1153     elif iface_type == "vlan":
1154         settings["vlan"] = "yes"
1155         __salt__["pkg.install"]("vlan")
1156     elif iface_type == "pppoe":
1157         settings["pppoe"] = "yes"
1158         if not __salt__["pkg.version"]("ppp"):
1159             inst = __salt__["pkg.install"]("ppp")
1160     elif iface_type == "bond":
1161         if "slaves" not in settings:
1162             msg = "slaves is a required setting for bond interfaces"
1163             log.error(msg)
1164             raise AttributeError(msg)
1165     elif iface_type == "bridge":
1166         if "ports" not in settings:
1167             msg = (
1168                 "ports is a required setting for bridge interfaces on Debian "
1169                 "or Ubuntu based systems"
1170             )
1171             log.error(msg)
1172             raise AttributeError(msg)
1173         __salt__["pkg.install"]("bridge-utils")
1174     if iface_type in ["eth", "bond", "bridge", "slave", "vlan", "pppoe"]:
1175         opts = _parse_settings_eth(settings, iface_type, enabled, iface)
1176     if iface_type in ["source"]:
1177         opts = _parse_settings_source(settings, iface_type, enabled, iface)
1178     if "test" in settings and settings["test"]:
1179         return _read_temp_ifaces(iface, opts[iface])
1180     ifcfg = _write_file_ifaces(iface, opts[iface], **settings)
1181     if iface_type == "pppoe":
1182         _write_file_ppp_ifaces(iface, opts[iface])
1183     return [item + "\n" for item in ifcfg]
1184 def build_routes(iface, **settings):
1185     opts = _parse_routes(iface, settings)
1186     try:
1187         template = JINJA.get_template("route_eth.jinja")
1188     except jinja2.exceptions.TemplateNotFound:
1189         log.error("Could not load template route_eth.jinja")
1190         return ""
1191     add_routecfg = template.render(route_type="add", routes=opts["routes"], iface=iface)
1192     del_routecfg = template.render(route_type="del", routes=opts["routes"], iface=iface)
1193     if "test" in settings and settings["test"]:
1194         return _read_temp(add_routecfg + del_routecfg)
1195     filename = _write_file_routes(iface, add_routecfg, _DEB_NETWORK_UP_DIR, "route-{0}")
1196     results = _read_file(filename)
1197     filename = _write_file_routes(
1198         iface, del_routecfg, _DEB_NETWORK_DOWN_DIR, "route-{0}"
1199     )
1200     results += _read_file(filename)
1201     return results
1202 def down(iface, iface_type):
1203     if iface_type not in ["slave", "source"]:
1204         return __salt__["cmd.run"](["ifdown", iface])
1205     return None
1206 def get_bond(iface):
1207     path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1208     return _read_file(path)
1209 def get_interface(iface):
1210     adapters = _parse_interfaces()
1211     if iface in adapters:
1212         try:
1213             if iface == "source":
1214                 template = JINJA.get_template("debian_source.jinja")
1215             else:
1216                 template = JINJA.get_template("debian_eth.jinja")
1217         except jinja2.exceptions.TemplateNotFound:
1218             log.error("Could not load template debian_eth.jinja")
1219             return ""
1220         ifcfg = template.render({"name": iface, "data": adapters[iface]})
1221         return [item + "\n" for item in ifcfg.split("\n")]
1222     else:
1223         return []
1224 def up(iface, iface_type):  # pylint: disable=C0103
1225     if iface_type not in ("slave", "source"):
1226         return __salt__["cmd.run"](["ifup", iface])
1227     return None
1228 def get_network_settings():
1229     skip_etc_default_networking = (
1230         __grains__["osfullname"] == "Ubuntu"
1231         and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
1232     )
1233     if skip_etc_default_networking:
1234         settings = {}
1235         if __salt__["service.available"]("networking"):
1236             if __salt__["service.status"]("networking"):
1237                 settings["networking"] = "yes"
1238             else:
1239                 settings["networking"] = "no"
1240         else:
1241             settings["networking"] = "no"
1242         hostname = _parse_hostname()
1243         domainname = _parse_domainname()
1244         settings["hostname"] = hostname
1245         settings["domainname"] = domainname
1246     else:
1247         settings = _parse_current_network_settings()
1248     try:
1249         template = JINJA.get_template("display-network.jinja")
1250     except jinja2.exceptions.TemplateNotFound:
1251         log.error("Could not load template display-network.jinja")
1252         return ""
1253     network = template.render(settings)
1254     return _read_temp(network)
1255 def get_routes(iface):
1256     filename = os.path.join(_DEB_NETWORK_UP_DIR, "route-{}".format(iface))
1257     results = _read_file(filename)
1258     filename = os.path.join(_DEB_NETWORK_DOWN_DIR, "route-{}".format(iface))
1259     results += _read_file(filename)
1260     return results
1261 def apply_network_settings(**settings):
1262     if "require_reboot" not in settings:
1263         settings["require_reboot"] = False
1264     if "apply_hostname" not in settings:
1265         settings["apply_hostname"] = False
1266     hostname_res = True
1267     if settings["apply_hostname"] in _CONFIG_TRUE:
1268         if "hostname" in settings:
1269             hostname_res = __salt__["network.mod_hostname"](settings["hostname"])
1270         else:
1271             log.warning(
1272                 "The network state sls is trying to apply hostname "
1273                 "changes but no hostname is defined."
1274             )
1275             hostname_res = False
1276     res = True
1277     if settings["require_reboot"] in _CONFIG_TRUE:
1278         log.warning(
1279             "The network state sls is requiring a reboot of the system to "
1280             "properly apply network configuration."
1281         )
1282         res = True
1283     else:
1284         stop = __salt__["service.stop"]("networking")
1285         time.sleep(2)
1286         res = stop and __salt__["service.start"]("networking")
1287     return hostname_res and res
1288 def build_network_settings(**settings):
1289     changes = []
1290     current_network_settings = _parse_current_network_settings()
1291     opts = _parse_network_settings(settings, current_network_settings)
1292     skip_etc_default_networking = (
1293         __grains__["osfullname"] == "Ubuntu"
1294         and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
1295     )
1296     if skip_etc_default_networking:
1297         if opts["networking"] == "yes":
1298             service_cmd = "service.enable"
1299         else:
1300             service_cmd = "service.disable"
1301         if __salt__["service.available"]("NetworkManager"):
1302             __salt__[service_cmd]("NetworkManager")
1303         if __salt__["service.available"]("networking"):
1304             __salt__[service_cmd]("networking")
1305     else:
1306         try:
1307             template = JINJA.get_template("network.jinja")
1308         except jinja2.exceptions.TemplateNotFound:
1309             log.error("Could not load template network.jinja")
1310             return ""
1311         network = template.render(opts)
1312         if "test" in settings and settings["test"]:
1313             return _read_temp(network)
1314         _write_file_network(network, _DEB_NETWORKING_FILE, True)
1315     sline = opts["hostname"].split(".", 1)
1316     opts["hostname"] = sline[0]
1317     current_domainname = current_network_settings["domainname"]
1318     current_searchdomain = current_network_settings["searchdomain"]
1319     new_domain = False
1320     if len(sline) &gt; 1:
1321         new_domainname = sline[1]
1322         if new_domainname != current_domainname:
1323             domainname = new_domainname
1324             opts["domainname"] = new_domainname
1325             new_domain = True
1326         else:
1327             domainname = current_domainname
1328             opts["domainname"] = domainname
1329     else:
1330         domainname = current_domainname
1331         opts["domainname"] = domainname
1332     new_search = False
1333     if "search" in opts:
1334         new_searchdomain = opts["search"]
1335         if new_searchdomain != current_searchdomain:
1336             searchdomain = new_searchdomain
1337             opts["searchdomain"] = new_searchdomain
1338             new_search = True
1339         else:
1340             searchdomain = current_searchdomain
1341             opts["searchdomain"] = searchdomain
1342     else:
1343         searchdomain = current_searchdomain
1344         opts["searchdomain"] = searchdomain
1345     if new_domain or new_search:
1346         resolve = _parse_resolve()
1347         domain_prog = re.compile(r"domain\s+")
1348         search_prog = re.compile(r"search\s+")
1349         new_contents = []
1350         for item in _read_file(_DEB_RESOLV_FILE):
1351             if domain_prog.match(item):
1352                 item = "domain {}".format(domainname)
1353             elif search_prog.match(item):
1354                 item = "search {}".format(searchdomain)
1355             new_contents.append(item)
1356         if "domain" not in resolve:
1357             new_contents.insert(0, "domain {}".format(domainname))
1358         if "search" not in resolve:
1359             new_contents.insert("domain" in resolve, "search {}".format(searchdomain))
1360         new_resolv = "\n".join(new_contents)
1361         if not ("test" in settings and settings["test"]):
1362             _write_file_network(new_resolv, _DEB_RESOLV_FILE)
1363     try:
1364         template = JINJA.get_template("display-network.jinja")
1365     except jinja2.exceptions.TemplateNotFound:
1366         log.error("Could not load template display-network.jinja")
1367         return ""
1368     network = template.render(opts)
1369     changes.extend(_read_temp(network))
1370     return changes
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
