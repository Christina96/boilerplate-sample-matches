<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for napalm_formula.py & redis_return.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for napalm_formula.py & redis_return.py
      </h3>
      <h1 align="center">
        4.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>napalm_formula.py (5.194805%)<TH>redis_return.py (3.7974684%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match73357-0.html#0',2,'match73357-1.html#0',3)" NAME="0">(219-223)<TD><A HREF="javascript:ZweiFrames('match73357-0.html#0',2,'match73357-1.html#0',3)" NAME="0">(240-243)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>napalm_formula.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
NAPALM Formula helpers
======================

.. versionadded:: 2019.2.0

This is an Execution Module providing helpers for various NAPALM formulas,
e.g., napalm-interfaces-formula, napalm-bgp-formula, napalm-ntp-formula etc.,
meant to provide various helper functions to make the templates more readable.
&quot;&quot;&quot;

import copy
import fnmatch
import logging

import salt.utils.dictupdate

# Import salt modules
import salt.utils.napalm
from salt.defaults import DEFAULT_TARGET_DELIM
from salt.utils.data import traverse_dict_and_list as _traverse_dict_and_list

__proxyenabled__ = [&quot;*&quot;]
__virtualname__ = &quot;napalm_formula&quot;

log = logging.getLogger(__name__)


def __virtual__():
    &quot;&quot;&quot;
    Available only on NAPALM Minions.
    &quot;&quot;&quot;
    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)


def _container_path(model, key=None, container=None, delim=DEFAULT_TARGET_DELIM):
    &quot;&quot;&quot;
    Generate all the possible paths within an OpenConfig-like object.
    This function returns a generator.
    &quot;&quot;&quot;
    if not key:
        key = &quot;&quot;
    if not container:
        container = &quot;config&quot;
    for model_key, model_value in model.items():
        if key:
            key_depth = &quot;{prev_key}{delim}{cur_key}&quot;.format(
                prev_key=key, delim=delim, cur_key=model_key
            )
        else:
            key_depth = model_key
        if model_key == container:
            yield key_depth
        else:
            yield from _container_path(
                model_value, key=key_depth, container=container, delim=delim
            )


def container_path(model, key=None, container=None, delim=DEFAULT_TARGET_DELIM):
    &quot;&quot;&quot;
    Return the list of all the possible paths in a container, down to the
    ``config`` container.
    This function can be used to verify that the ``model`` is a Python object
    correctly structured and respecting the OpenConfig hierarchy.

    model
        The OpenConfig-structured object to inspect.

    delim: ``:``
        The key delimiter. In particular cases, it is indicated to use ``//``
        as ``:`` might be already used in various cases, e.g., IPv6 addresses,
        interface name (e.g., Juniper QFX series), etc.

    CLI Example:

    .. code-block:: bash

        salt '*' napalm_formula.container_path &quot;{'interfaces': {'interface': {'Ethernet1': {'config': {'name': 'Ethernet1'}}}}}&quot;

    The example above would return a list with the following element:
    ``interfaces:interface:Ethernet1:config`` which is the only possible path
    in that hierarchy.

    Other output examples:

    .. code-block:: text

        - interfaces:interface:Ethernet1:config
        - interfaces:interface:Ethernet1:subinterfaces:subinterface:0:config
        - interfaces:interface:Ethernet2:config
    &quot;&quot;&quot;
    return list(_container_path(model))


def setval(key, val, dict_=None, delim=DEFAULT_TARGET_DELIM):
    &quot;&quot;&quot;
    Set a value under the dictionary hierarchy identified
    under the key. The target 'foo/bar/baz' returns the
    dictionary hierarchy {'foo': {'bar': {'baz': {}}}}.

    .. note::

        Currently this doesn't work with integers, i.e.
        cannot build lists dynamically.

    CLI Example:

    .. code-block:: bash

        salt '*' formula.setval foo:baz:bar True
    &quot;&quot;&quot;
    if not dict_:
        dict_ = {}
    prev_hier = dict_
    dict_hier = key.split(delim)
    for each in dict_hier[:-1]:
        if each not in prev_hier:
            prev_hier[each] = {}
        prev_hier = prev_hier[each]
    prev_hier[dict_hier[-1]] = copy.deepcopy(val)
    return dict_


def traverse(data, key, default=None, delimiter=DEFAULT_TARGET_DELIM):
    &quot;&quot;&quot;
    Traverse a dict or list using a colon-delimited (or otherwise delimited,
    using the ``delimiter`` param) target string. The target ``foo:bar:0`` will
    return ``data['foo']['bar'][0]`` if this value exists, and will otherwise
    return the dict in the default argument.
    Function will automatically determine the target type.
    The target ``foo:bar:0`` will return data['foo']['bar'][0] if data like
    ``{'foo':{'bar':['baz']}}`` , if data like ``{'foo':{'bar':{'0':'baz'}}}``
    then ``return data['foo']['bar']['0']``

    CLI Example:

    .. code-block:: bash

        salt '*' napalm_formula.traverse &quot;{'foo': {'bar': {'baz': True}}}&quot; foo:baz:bar
    &quot;&quot;&quot;
    return _traverse_dict_and_list(data, key, default=default, delimiter=delimiter)


def dictupdate(dest, upd, recursive_update=True, merge_lists=False):
    &quot;&quot;&quot;
    Recursive version of the default dict.update

    Merges upd recursively into dest

    If recursive_update=False, will use the classic dict.update, or fall back
    on a manual merge (helpful for non-dict types like ``FunctionWrapper``).

    If ``merge_lists=True``, will aggregate list object types instead of replace.
    The list in ``upd`` is added to the list in ``dest``, so the resulting list
    is ``dest[key] + upd[key]``. This behaviour is only activated when
    ``recursive_update=True``. By default ``merge_lists=False``.
    &quot;&quot;&quot;
    return salt.utils.dictupdate.update(
        dest, upd, recursive_update=recursive_update, merge_lists=merge_lists
    )


def defaults(model, defaults_, delim=&quot;//&quot;, flipped_merge=False):
    &quot;&quot;&quot;
    Apply the defaults to a Python dictionary having the structure as described
    in the OpenConfig standards.

    model
        The OpenConfig model to apply the defaults to.

    defaults
        The dictionary of defaults. This argument must equally be structured
        with respect to the OpenConfig standards.

        For ease of use, the keys of these support glob matching, therefore
        we don't have to provide the defaults for each entity but only for
        the entity type. See an example below.

    delim: ``//``
        The key delimiter to use. Generally, ``//`` should cover all the possible
        cases, and you don't need to override this value.

    flipped_merge: ``False``
        Whether should merge the model into the defaults, or the defaults
        into the model. Default: ``False`` (merge the model into the defaults,
        i.e., any defaults would be overridden by the values from the ``model``).

    CLI Example:

    .. code-block:: bash

        salt '*' napalm_formula.defaults &quot;{'interfaces': {'interface': {'Ethernet1': {'config': {'name': 'Ethernet1'}}}}}&quot; &quot;{'interfaces': {'interface': {'*': {'config': {'enabled': True}}}}}&quot;

    As one can notice in the example above, the ``*`` corresponds to the
    interface name, therefore, the defaults will be applied on all the
    interfaces.
    &quot;&quot;&quot;
    merged = {}
    log.debug(&quot;Applying the defaults:&quot;)
    log.debug(defaults_)
    log.debug(&quot;openconfig like dictionary:&quot;)
    log.debug(model)
    for model_path in _container_path(model, delim=delim):
        for default_path in _container_path(defaults_, delim=delim):
            log.debug(&quot;Comparing %s to %s&quot;, model_path, default_path)
            if not fnmatch.fnmatch(model_path, default_path) or not len(
                model_path.split(delim)
            ) == len(default_path.split(delim)):
                continue
            log.debug(&quot;%s matches %s&quot;, model_path, default_path)
            # If there's a match, it will build the dictionary from the top
            devault_val = _traverse_dict_and_list(
                defaults_, default_path, delimiter=delim
            )
<A NAME="0"></A>            merged = setval(model_path, devault_val, dict_=merged, delim=delim)
    log.debug(&quot;Complete default dictionary&quot;)
    log.debug(merged)
    log<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match73357-1.html#0',3,'match73357-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.debug(&quot;Merging with the model&quot;)
    log.debug(model)
    if flipped_merge:
        return salt.utils.dictupdate.update(model, merged)
    return</B></FONT> salt.utils.dictupdate.update(merged, model)


def render_field(dictionary, field, prepend=None, append=None, quotes=False, **opts):
    &quot;&quot;&quot;
    Render a field found under the ``field`` level of the hierarchy in the
    ``dictionary`` object.
    This is useful to render a field in a Jinja template without worrying that
    the hierarchy might not exist. For example if we do the following in Jinja:
    ``{{ interfaces.interface.Ethernet5.config.description }}`` for the
    following object:
    ``{'interfaces': {'interface': {'Ethernet1': {'config': {'enabled': True}}}}}``
    it would error, as the ``Ethernet5`` key does not exist.
    With this helper, we can skip this and avoid existence checks. This must be
    however used with care.

    dictionary
        The dictionary to traverse.

    field
        The key name or part to traverse in the ``dictionary``.

    prepend: ``None``
        The text to prepend in front of the text. Usually, we need to have the
        name of the field too when generating the configuration.

    append: ``None``
        Text to append at the end.

    quotes: ``False``
        Whether should wrap the text around quotes.

    CLI Example:

    .. code-block:: bash

        salt '*' napalm_formula.render_field &quot;{'enabled': True}&quot; enabled
        # This would return the value of the ``enabled`` leaf key
        salt '*' napalm_formula.render_field &quot;{'enabled': True}&quot; description
        # This would not error

    Jinja usage example:

    .. code-block:: jinja

        {%- set config = {'enabled': True, 'description': 'Interface description'} %}
        {{ salt.napalm_formula.render_field(config, 'description', quotes=True) }}

    The example above would be rendered on Arista / Cisco as:

    .. code-block:: text

        description &quot;Interface description&quot;

    While on Junos (the semicolon is important to be added, otherwise the
    configuration won't be accepted by Junos):

    .. code-block:: text

        description &quot;Interface description&quot;;
    &quot;&quot;&quot;
    value = traverse(dictionary, field)
    if value is None:
        return &quot;&quot;
    if prepend is None:
        prepend = field.replace(&quot;_&quot;, &quot;-&quot;)
    if append is None:
        if __grains__[&quot;os&quot;] in (&quot;junos&quot;,):
            append = &quot;;&quot;
        else:
            append = &quot;&quot;
    if quotes:
        value = '&quot;{value}&quot;'.format(value=value)
    return &quot;{prepend} {value}{append}&quot;.format(
        prepend=prepend, value=value, append=append
    )


def render_fields(dictionary, *fields, **opts):
    &quot;&quot;&quot;
    This function works similarly to
    :mod:`render_field &lt;salt.modules.napalm_formula.render_field&gt;` but for a
    list of fields from the same dictionary, rendering, indenting and
    distributing them on separate lines.

    dictionary
        The dictionary to traverse.

    fields
        A list of field names or paths in the dictionary.

    indent: ``0``
        The indentation to use, prepended to the rendered field.

    separator: ``\\n``
        The separator to use between fields.

    CLI Example:

    .. code-block:: bash

        salt '*' napalm_formula.render_fields &quot;{'mtu': 68, 'description': 'Interface description'}&quot; mtu description

    Jinja usage example:

    .. code-block:: jinja

        {%- set config={'mtu': 68, 'description': 'Interface description'} %}
        {{ salt.napalm_formula.render_fields(config, 'mtu', 'description', quotes=True) }}

    The Jinja example above would generate the following configuration:

    .. code-block:: text

        mtu &quot;68&quot;
        description &quot;Interface description&quot;
    &quot;&quot;&quot;
    results = []
    for field in fields:
        res = render_field(dictionary, field, **opts)
        if res:
            results.append(res)
    if &quot;indent&quot; not in opts:
        opts[&quot;indent&quot;] = 0
    if &quot;separator&quot; not in opts:
        opts[&quot;separator&quot;] = &quot;\n{ind}&quot;.format(ind=&quot; &quot; * opts[&quot;indent&quot;])
    return opts[&quot;separator&quot;].join(results)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>redis_return.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Return data to a redis server

To enable this returner the minion will need the python client for redis
installed and the following values configured in the minion or master
config, these are the defaults:

.. code-block:: yaml

    redis.db: '0'
    redis.host: 'salt'
    redis.port: 6379

.. versionadded:: 2018.3.1

    Alternatively a UNIX socket can be specified by `unix_socket_path`:

.. code-block:: yaml

    redis.db: '0'
    redis.unix_socket_path: /var/run/redis/redis.sock

Cluster Mode Example:

.. code-block:: yaml

    redis.db: '0'
    redis.cluster_mode: true
    redis.cluster.skip_full_coverage_check: true
    redis.cluster.startup_nodes:
      - host: redis-member-1
        port: 6379
      - host: redis-member-2
        port: 6379

Alternative configuration values can be used by prefacing the configuration.
Any values not found in the alternative configuration will be pulled from
the default location:

.. code-block:: yaml

    alternative.redis.db: '0'
    alternative.redis.host: 'salt'
    alternative.redis.port: 6379

To use the redis returner, append '--return redis' to the salt command.

.. code-block:: bash

    salt '*' test.ping --return redis

To use the alternative configuration, append '--return_config alternative' to the salt command.

.. versionadded:: 2015.5.0

.. code-block:: bash

    salt '*' test.ping --return redis --return_config alternative

To override individual configuration items, append --return_kwargs '{&quot;key:&quot;: &quot;value&quot;}' to the salt command.

.. versionadded:: 2016.3.0

.. code-block:: bash

    salt '*' test.ping --return redis --return_kwargs '{&quot;db&quot;: &quot;another-salt&quot;}'

Redis Cluster Mode Options:

cluster_mode: ``False``
    Whether cluster_mode is enabled or not

cluster.startup_nodes:
    A list of host, port dictionaries pointing to cluster members. At least one is required
    but multiple nodes are better

    .. code-block:: yaml

        redis.cluster.startup_nodes
          - host: redis-member-1
            port: 6379
          - host: redis-member-2
            port: 6379

cluster.skip_full_coverage_check: ``False``
    Some cluster providers restrict certain redis commands such as CONFIG for enhanced security.
    Set this option to true to skip checks that required advanced privileges.

    .. note::

        Most cloud hosted redis clusters will require this to be set to ``True``


&quot;&quot;&quot;

import logging

import salt.returners
import salt.utils.jid
import salt.utils.json
import salt.utils.platform

try:
    import redis

    HAS_REDIS = True
except ImportError:
    HAS_REDIS = False

log = logging.getLogger(__name__)

try:
    # pylint: disable=no-name-in-module
    from rediscluster import StrictRedisCluster

    # pylint: enable=no-name-in-module

    HAS_REDIS_CLUSTER = True
except ImportError:
    HAS_REDIS_CLUSTER = False

REDIS_POOL = None

# Define the module's virtual name
__virtualname__ = &quot;redis&quot;


def __virtual__():
    &quot;&quot;&quot;
    The redis library must be installed for this module to work.

    The redis redis cluster library must be installed if cluster_mode is True
    &quot;&quot;&quot;

    if not HAS_REDIS:
        return (
            False,
            &quot;Could not import redis returner; redis python client is not installed.&quot;,
        )
    if not HAS_REDIS_CLUSTER and _get_options().get(&quot;cluster_mode&quot;, False):
        return (False, &quot;Please install the redis-py-cluster package.&quot;)
    return __virtualname__


def _get_options(ret=None):
    &quot;&quot;&quot;
    Get the redis options from salt.
    &quot;&quot;&quot;
    attrs = {
        &quot;host&quot;: &quot;host&quot;,
        &quot;port&quot;: &quot;port&quot;,
        &quot;unix_socket_path&quot;: &quot;unix_socket_path&quot;,
        &quot;db&quot;: &quot;db&quot;,
        &quot;cluster_mode&quot;: &quot;cluster_mode&quot;,
        &quot;startup_nodes&quot;: &quot;cluster.startup_nodes&quot;,
        &quot;skip_full_coverage_check&quot;: &quot;cluster.skip_full_coverage_check&quot;,
    }

    if salt.utils.platform.is_proxy():
        return {
            &quot;host&quot;: __opts__.get(&quot;redis.host&quot;, &quot;salt&quot;),
            &quot;port&quot;: __opts__.get(&quot;redis.port&quot;, 6379),
            &quot;unix_socket_path&quot;: __opts__.get(&quot;redis.unix_socket_path&quot;, None),
            &quot;db&quot;: __opts__.get(&quot;redis.db&quot;, &quot;0&quot;),
            &quot;cluster_mode&quot;: __opts__.get(&quot;redis.cluster_mode&quot;, False),
            &quot;startup_nodes&quot;: __opts__.get(&quot;redis.cluster.startup_nodes&quot;, {}),
            &quot;skip_full_coverage_check&quot;: __opts__.get(
                &quot;redis.cluster.skip_full_coverage_check&quot;, False
            ),
        }

    _options = salt.returners.get_returner_options(
        __virtualname__, ret, attrs, __salt__=__salt__, __opts__=__opts__
    )
    return _options


def _get_serv(ret=None):
    &quot;&quot;&quot;
    Return a redis server object
    &quot;&quot;&quot;
    _options = _get_options(ret)
    global REDIS_POOL
    if REDIS_POOL:
        return REDIS_POOL
    elif _options.get(&quot;cluster_mode&quot;):
        REDIS_POOL = StrictRedisCluster(
            startup_nodes=_options.get(&quot;startup_nodes&quot;),
            skip_full_coverage_check=_options.get(&quot;skip_full_coverage_check&quot;),
            decode_responses=True,
        )
    else:
        REDIS_POOL = redis.StrictRedis(
            host=_options.get(&quot;host&quot;),
            port=_options.get(&quot;port&quot;),
            unix_socket_path=_options.get(&quot;unix_socket_path&quot;, None),
            db=_options.get(&quot;db&quot;),
            decode_responses=True,
        )
    return REDIS_POOL


def _get_ttl():
    return __opts__.get(&quot;keep_jobs&quot;, 24) * 3600


def returner(ret):
    &quot;&quot;&quot;
    Return data to a redis data store
    &quot;&quot;&quot;
    serv = _get_serv(ret)
    pipeline = serv.pipeline(transaction=False)
    minion, jid = ret[&quot;id&quot;], ret[&quot;jid&quot;]
    pipeline.hset(&quot;ret:{}&quot;.format(jid), minion, salt.utils.json.dumps(ret))
    pipeline.expire(&quot;ret:{}&quot;.format(jid), _get_ttl())
    pipeline.set(&quot;{}:{}&quot;.format(minion, ret[&quot;fun&quot;]), jid)
    pipeline.sadd(&quot;minions&quot;, minion)
    pipeline.execute()


def save_load(jid, load, minions=None):
    &quot;&quot;&quot;
    Save the load to the specified jid
    &quot;&quot;&quot;
    serv = _get_serv(ret=None)
    serv.setex(&quot;load:{}&quot;.format(jid), _get_ttl(), salt.utils.json.dumps(load))


def save_minions(jid, minions, syndic_id=None):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    Included for API consistency
    &quot;&quot;&quot;


def get_load(jid):
    &quot;&quot;&quot;
<A NAME="0"></A>    Return the load data that marks a specified jid
    &quot;&quot;&quot;
    serv = _get_serv(ret=None)
    data = serv<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match73357-0.html#0',2,'match73357-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.get(&quot;load:{}&quot;.format(jid))
    if data:
        return salt.utils.json.loads(data)
    return</B></FONT> {}


def get_jid(jid):
    &quot;&quot;&quot;
    Return the information returned when the specified job id was executed
    &quot;&quot;&quot;
    serv = _get_serv(ret=None)
    ret = {}
    for minion, data in serv.hgetall(&quot;ret:{}&quot;.format(jid)).items():
        if data:
            ret[minion] = salt.utils.json.loads(data)
    return ret


def get_fun(fun):
    &quot;&quot;&quot;
    Return a dict of the last function called for all minions
    &quot;&quot;&quot;
    serv = _get_serv(ret=None)
    ret = {}
    for minion in serv.smembers(&quot;minions&quot;):
        ind_str = &quot;{}:{}&quot;.format(minion, fun)
        try:
            jid = serv.get(ind_str)
        except Exception:  # pylint: disable=broad-except
            continue
        if not jid:
            continue
        data = serv.get(&quot;{}:{}&quot;.format(minion, jid))
        if data:
            ret[minion] = salt.utils.json.loads(data)
    return ret


def get_jids():
    &quot;&quot;&quot;
    Return a dict mapping all job ids to job information
    &quot;&quot;&quot;
    serv = _get_serv(ret=None)
    ret = {}
    for s in serv.mget(serv.keys(&quot;load:*&quot;)):
        if s is None:
            continue
        load = salt.utils.json.loads(s)
        jid = load[&quot;jid&quot;]
        ret[jid] = salt.utils.jid.format_jid_instance(jid, load)
    return ret


def get_minions():
    &quot;&quot;&quot;
    Return a list of minions
    &quot;&quot;&quot;
    serv = _get_serv(ret=None)
    return list(serv.smembers(&quot;minions&quot;))


def clean_old_jobs():
    &quot;&quot;&quot;
    Clean out minions's return data for old jobs.

    Normally, hset 'ret:&lt;jid&gt;' are saved with a TTL, and will eventually
    get cleaned by redis.But for jobs with some very late minion return, the
    corresponding hset's TTL will be refreshed to a too late timestamp, we'll
    do manually cleaning here.
    &quot;&quot;&quot;
    serv = _get_serv(ret=None)
    ret_jids = serv.keys(&quot;ret:*&quot;)
    living_jids = set(serv.keys(&quot;load:*&quot;))
    to_remove = []
    for ret_key in ret_jids:
        load_key = ret_key.replace(&quot;ret:&quot;, &quot;load:&quot;, 1)
        if load_key not in living_jids:
            to_remove.append(ret_key)
    if len(to_remove) != 0:
        serv.delete(*to_remove)
        log.debug(&quot;clean old jobs: %s&quot;, to_remove)


def prep_jid(nocache=False, passed_jid=None):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    Do any work necessary to prepare a JID, including sending a custom id
    &quot;&quot;&quot;
    return passed_jid if passed_jid is not None else salt.utils.jid.gen_jid(__opts__)
</PRE>
</div>
  </div>
</body>
</html>
