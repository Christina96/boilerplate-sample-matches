<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_pip_state.py & setup_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_pip_state.py & setup_1.py
      </h3>
      <h1 align="center">
        1.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_pip_state.py (1.7948718%)<TH>setup_1.py (1.4814814%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match203317-0.html#0',2,'match203317-1.html#0',3)" NAME="0">(1-15)<TD><A HREF="javascript:ZweiFrames('match203317-0.html#0',2,'match203317-1.html#0',3)" NAME="0">(15-48)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pip_state.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match203317-1.html#0',3,'match203317-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import glob
import logging
import os
import pprint
import shutil
import sys

import pytest
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import salt.utils.versions
import salt.utils.win_dacl
import salt.utils.win_functions
import</B></FONT> salt.utils.win_runas
from tests.support.helpers import SKIP_INITIAL_PHOTONOS_FAILURES, patched_environ

try:
    import pwd

    HAS_PWD = True
except ImportError:
    HAS_PWD = False

log = logging.getLogger(__name__)


def _win_user_where(username, password, program):
    cmd = &quot;cmd.exe /c where {}&quot;.format(program)
    ret = salt.utils.win_runas.runas(cmd, username, password)
    assert ret[&quot;retcode&quot;] == 0, &quot;{} returned {}&quot;.format(cmd, ret[&quot;retcode&quot;])
    return ret[&quot;stdout&quot;].strip().split(&quot;\n&quot;)[-1].strip()


@pytest.fixture(scope=&quot;module&quot;)
def create_virtualenv(modules):
    def run_command(path, **kwargs):
        &quot;&quot;&quot;
        The reason why the virtualenv creation is proxied by this function is mostly
        because under windows, we can't seem to properly create a virtualenv off of
        another virtualenv(we can on linux) and also because, we really don't want to
        test virtualenv creation off of another virtualenv, we want a virtualenv created
        from the original python.
        Also, one windows, we must also point to the virtualenv binary outside the existing
        virtualenv because it will fail otherwise
        &quot;&quot;&quot;
        if &quot;python&quot; not in kwargs:
            try:
                if salt.utils.platform.is_windows():
                    python = os.path.join(
                        sys.real_prefix, os.path.basename(sys.executable)
                    )
                else:
                    python_binary_names = [
                        &quot;python{}.{}&quot;.format(*sys.version_info),
                        &quot;python{}&quot;.format(*sys.version_info),
                        &quot;python&quot;,
                    ]
                    for binary_name in python_binary_names:
                        python = os.path.join(sys.real_prefix, &quot;bin&quot;, binary_name)
                        if os.path.exists(python):
                            break
                    else:
                        pytest.fail(
                            &quot;Couldn't find a python binary name under '{}' matching: {}&quot;.format(
                                os.path.join(sys.real_prefix, &quot;bin&quot;),
                                python_binary_names,
                            )
                        )
                # We're running off a virtualenv, and we don't want to create a virtualenv off of
                # a virtualenv, let's point to the actual python that created the virtualenv
                kwargs[&quot;python&quot;] = python
            except AttributeError:
                # We're running off of the system python
                pass
        return modules.virtualenv.create(path, **kwargs)

    return run_command


@pytest.mark.slow_test
def test_pip_installed_removed(modules, states):
    &quot;&quot;&quot;
    Tests installed and removed states
    &quot;&quot;&quot;
    name = &quot;pudb&quot;
    if name in modules.pip.list():
        pytest.skip(&quot;{} is already installed, uninstall to run this test&quot;.format(name))
    ret = states.pip.installed(name=name)
    assert ret.result is True
    ret = states.pip.removed(name=name)
    assert ret.result is True


@pytest.mark.slow_test
def test_pip_installed_removed_venv(tmp_path, create_virtualenv, states):
    venv_dir = tmp_path / &quot;pip_installed_removed&quot;
    create_virtualenv(str(venv_dir))
    name = &quot;pudb&quot;
    ret = states.pip.installed(name=name, bin_env=str(venv_dir))
    assert ret.result is True
    ret = states.pip.removed(name=name, bin_env=str(venv_dir))
    assert ret.result is True


@pytest.mark.slow_test
def test_pip_installed_errors(tmp_path, modules, state_tree):
    venv_dir = tmp_path / &quot;pip-installed-errors&quot;
    # Since we don't have the virtualenv created, pip.installed will
    # throw an error.
    # Example error strings:
    #  * &quot;Error installing 'pep8': /tmp/pip-installed-errors: not found&quot;
    #  * &quot;Error installing 'pep8': /bin/sh: 1: /tmp/pip-installed-errors: not found&quot;
    #  * &quot;Error installing 'pep8': /bin/bash: /tmp/pip-installed-errors: No such file or directory&quot;
    sls_contents = &quot;&quot;&quot;
pep8-pip:
  pip.installed:
    - name: pep8
    - bin_env: '{}'
&quot;&quot;&quot;.format(
        str(venv_dir)
    )

    with patched_environ(SHELL=&quot;/bin/sh&quot;):
        with pytest.helpers.temp_file(
            &quot;pip-installed-errors.sls&quot;, sls_contents, state_tree
        ):
            ret = modules.state.sls(&quot;pip-installed-errors&quot;)
            for state_return in ret:
                assert state_return.result is False
                assert &quot;Error installing 'pep8':&quot; in state_return.comment

            # We now create the missing virtualenv
            ret = modules.virtualenv.create(str(venv_dir))
            assert ret[&quot;retcode&quot;] == 0

            # The state should not have any issues running now
            ret = modules.state.sls(mods=&quot;pip-installed-errors&quot;)
            for state_return in ret:
                assert state_return.result is True


def test_pip_installed_name_test_mode(tmp_path, create_virtualenv, states):
    &quot;&quot;&quot;
    Test pip.installed state while test=true
    &quot;&quot;&quot;
    venv_dir = tmp_path / &quot;pip_installed_test_mode_name&quot;
    create_virtualenv(str(venv_dir))

    name = &quot;pudb&quot;
    msg = &quot;Python package(s) set to be installed:\npudb&quot;
    ret = states.pip.installed(name=name, bin_env=str(venv_dir), test=True)
    assert name in ret.comment


def test_pip_installed_pkgs_test_mode(tmp_path, create_virtualenv, states):
    &quot;&quot;&quot;
    Test pip.installed state while test=true
    &quot;&quot;&quot;
    venv_dir = tmp_path / &quot;pip_installed_test_mode_pkgs&quot;
    create_virtualenv(str(venv_dir))

    pkgs = [&quot;boto&quot;, &quot;pudb&quot;, &quot;black&quot;]
    msg = &quot;Python package(s) set to be installed:\nboto\npudb\nblack&quot;
    ret = states.pip.installed(name=None, pkgs=pkgs, bin_env=str(venv_dir), test=True)
    assert msg in ret.comment


@pytest.mark.slow_test
def test_issue_2028_pip_installed_state(
    tmp_path, modules, state_tree, get_python_executable
):

    venv_dir = tmp_path / &quot;issue-2028-pip-installed&quot;
    python_executable = get_python_executable

    sls_contents = &quot;&quot;&quot;
{%- set virtualenv_base = salt['pillar.get']('venv_dir') %}
{%- set python_executable = salt['pillar.get']('python_executable') %}

{{ virtualenv_base }}:
  virtualenv.managed:
    - system_site_packages: False
    - distribute: False
    {#- Provide the real path for the python executable in case tests are running inside a virtualenv #}
    {%- if python_executable %}
    - python: {{ python_executable }}
    {%- endif %}

install-working-setuptools:
  pip.installed:
    - name: 'setuptools!=50.*,!=51.*,!=52.*'
    - bin_env: {{ virtualenv_base }}
    - require:
      - virtualenv: {{ virtualenv_base }}

pep8-pip:
  pip.installed:
    - name: pep8
    - bin_env: {{ virtualenv_base }}
    - require:
      - pip: install-working-setuptools
      - virtualenv: {{ virtualenv_base }}
&quot;&quot;&quot;
    with pytest.helpers.temp_file(
        &quot;issue-2028-pip-installed.sls&quot;, sls_contents, state_tree
    ):
        ret = modules.state.sls(
            mods=&quot;issue-2028-pip-installed&quot;,
            pillar={
                &quot;venv_dir&quot;: str(venv_dir),
                &quot;python_exeutable&quot;: get_python_executable,
            },
        )

        pep8_bin = venv_dir / &quot;bin&quot; / &quot;pep8&quot;

        if salt.utils.platform.is_windows():
            pep8_bin = venv_dir / &quot;Scripts&quot; / &quot;pep8.exe&quot;

        for state_return in ret:
            assert state_return.result is True

        assert os.path.isfile(str(pep8_bin)) is True


@pytest.mark.slow_test
def test_issue_2087_missing_pip(tmp_path, create_virtualenv, modules):
    venv_dir = tmp_path / &quot;issue-2087-missing-pip&quot;

    sls_contents = &quot;&quot;&quot;pep8-pip:
pip.installed:
    - name: pep8
    - bin_env: {}
&quot;&quot;&quot;.format(
        str(venv_dir)
    )

    # Let's create the testing virtualenv
    ret = create_virtualenv(str(venv_dir))
    assert ret[&quot;retcode&quot;] == 0

    # Let's remove the pip binary
    pip_bin = venv_dir / &quot;bin&quot; / &quot;pip&quot;
    site_dir = modules.virtualenv.get_distribution_path(str(venv_dir), &quot;pip&quot;)
    if salt.utils.platform.is_windows():
        pip_bin = venv_dir / &quot;Scripts&quot; / &quot;pip.exe&quot;
        site_dir = venv_dir / &quot;lib&quot; / &quot;site-packages&quot;
    if not os.path.isfile(str(pip_bin)):
        pytest.skip(&quot;Failed to find the pip binary to the test virtualenv&quot;)
    os.remove(str(pip_bin))

    # Also remove the pip dir from site-packages
    # This is needed now that we're using python -m pip instead of the
    # pip binary directly. python -m pip will still work even if the
    # pip binary is missing
    shutil.rmtree(os.path.join(str(site_dir), &quot;pip&quot;))

    # Let's run the state which should fail because pip is missing
    ret = modules.state.sls(mods=&quot;issue-2087-missing-pip&quot;)
    for state_return in ret:
        assert state_return.result is True
        assert (
            &quot;Error installing 'pep8': Could not find a `pip` binary&quot;
            in state_return.comment
        )


@SKIP_INITIAL_PHOTONOS_FAILURES
@pytest.mark.destructive_test
@pytest.mark.slow_test
@pytest.mark.skip_if_not_root
def test_issue_6912_wrong_owner(tmp_path, create_virtualenv, modules, states):
    # Setup virtual environment directory to be used throughout the test
    venv_dir = tmp_path / &quot;6912-wrong-owner&quot;
    venv_kwargs = {}

    with pytest.helpers.create_account(
        username=&quot;issue-6912&quot;, password=&quot;PassWord1!&quot;
    ) as account:
        # The virtual environment needs to be in a location that is accessible
        # by both the user running the test and the runas user
        if salt.utils.platform.is_windows():
            salt.utils.win_dacl.set_permissions(
                tmp_path, account.username, &quot;full_control&quot;
            )
            # Make sure we're calling a virtualenv and python
            # program that the user has access too.
            venv_kwargs[&quot;venv_bin&quot;] = _win_user_where(
                account.username,
                &quot;PassWord1!&quot;,
                &quot;virtualenv&quot;,
            )
            venv_kwargs[&quot;python&quot;] = _win_user_where(
                account.username,
                &quot;PassWord1!&quot;,
                &quot;python&quot;,
            )
        else:
            uid = modules.file.user_to_uid(account.username)
            os.chown(str(tmp_path), uid, -1)

        # Create the virtual environment
        venv_create = create_virtualenv(
            str(venv_dir), user=account.username, password=&quot;PassWord1!&quot;, **venv_kwargs
        )
        if venv_create.get(&quot;retcode&quot;, 1) &gt; 0:
            pytest.skip(
                &quot;Failed to create testcase virtual environment: {}&quot;.format(venv_create)
            )

        # pip install passing the package name in `name`
        ret = states.pip.installed(
            name=&quot;pep8&quot;,
            user=account.username,
            bin_env=str(venv_dir),
            password=&quot;PassWord1!&quot;,
        )
        assert ret.result is True

        if HAS_PWD:
            uid = pwd.getpwnam(account.username).pw_uid
        for globmatch in (
            os.path.join(str(venv_dir), &quot;**&quot;, &quot;pep8*&quot;),
            os.path.join(str(venv_dir), &quot;*&quot;, &quot;**&quot;, &quot;pep8*&quot;),
            os.path.join(str(venv_dir), &quot;*&quot;, &quot;*&quot;, &quot;**&quot;, &quot;pep8*&quot;),
        ):
            for path in glob.glob(globmatch):
                if HAS_PWD:
                    assert uid == os.stat(path).st_uid
                elif salt.utils.platform.is_windows():
                    assert salt.utils.win_dacl.get_owner(path) == account.username


@SKIP_INITIAL_PHOTONOS_FAILURES
@pytest.mark.destructive_test
@pytest.mark.skip_on_darwin(reason=&quot;Test is flaky on macosx&quot;)
@pytest.mark.slow_test
@pytest.mark.skip_if_not_root
def test_issue_6912_wrong_owner_requirements_file(
    tmp_path, create_virtualenv, state_tree, modules, states
):
    # Setup virtual environment directory to be used throughout the test
    venv_dir = tmp_path / &quot;6912-wrong-owner&quot;
    venv_kwargs = {}

    with pytest.helpers.create_account(
        username=&quot;issue-6912&quot;, password=&quot;PassWord1!&quot;
    ) as account:
        # The virtual environment needs to be in a location that is accessible
        # by both the user running the test and the runas user
        if salt.utils.platform.is_windows():
            salt.utils.win_dacl.set_permissions(
                str(tmp_path), account.username, &quot;full_control&quot;
            )
            # Make sure we're calling a virtualenv and python
            # program that the user has access too.
            venv_kwargs[&quot;venv_bin&quot;] = _win_user_where(
                account.username,
                &quot;PassWord1!&quot;,
                &quot;virtualenv&quot;,
            )
            venv_kwargs[&quot;python&quot;] = _win_user_where(
                account.username,
                &quot;PassWord1!&quot;,
                &quot;python&quot;,
            )
        else:
            uid = modules.file.user_to_uid(account.username)
            os.chown(str(tmp_path), uid, -1)

        # Create the virtual environment again as it should have been removed
        venv_create = create_virtualenv(
            str(venv_dir), user=account.username, password=&quot;PassWord1!&quot;, **venv_kwargs
        )
        if venv_create.get(&quot;retcode&quot;, 1) &gt; 0:
            pytest.skip(
                &quot;failed to create testcase virtual environment: {}&quot;.format(venv_create)
            )

        # pip install using a requirements file
        contents = &quot;pep8\n&quot;
        with pytest.helpers.temp_file(
            &quot;issue-6912-requirements.txt&quot;, contents, state_tree
        ):
            ret = states.pip.installed(
                name=&quot;&quot;,
                user=account.username,
                bin_env=str(venv_dir),
                requirements=&quot;salt://issue-6912-requirements.txt&quot;,
                password=&quot;PassWord1!&quot;,
            )
            assert ret.result is True

        if HAS_PWD:
            uid = pwd.getpwnam(account.username).pw_uid
        for globmatch in (
            os.path.join(str(venv_dir), &quot;**&quot;, &quot;pep8*&quot;),
            os.path.join(str(venv_dir), &quot;*&quot;, &quot;**&quot;, &quot;pep8*&quot;),
            os.path.join(str(venv_dir), &quot;*&quot;, &quot;*&quot;, &quot;**&quot;, &quot;pep8*&quot;),
        ):
            for path in glob.glob(globmatch):
                if HAS_PWD:
                    assert uid == os.stat(path).st_uid
                elif salt.utils.platform.is_windows():
                    assert salt.utils.win_dacl.get_owner(path) == account.username


@pytest.mark.destructive_test
@pytest.mark.slow_test
def test_issue_6833_pip_upgrade_pip(tmp_path, create_virtualenv, modules, states):
    # Create the testing virtualenv
    if sys.platform == &quot;win32&quot;:
        # To keeps the path short, we'll create this directory on the root
        # of the system drive. Otherwise the path is too long and the pip
        # upgrade will fail. Also, I don't know why salt.utils.platform
        # doesn't work in this function, that's why I used sys.platform
        # Need to use os.sep.join here instead of os.path.join because of
        # the colon in SystemDrive
        venv_dir = os.sep.join([os.environ[&quot;SystemDrive&quot;], &quot;tmp-6833-pip-upgrade-pip&quot;])
    else:
        venv_dir = str(tmp_path / &quot;6833-pip-upgrade-pip&quot;)
    ret = create_virtualenv(venv_dir)

    assert ret[&quot;retcode&quot;] == 0

    if not (
        &quot;New python executable&quot; in ret[&quot;stdout&quot;]
        or &quot;created virtual environment&quot; in ret[&quot;stdout&quot;]
    ):
        assert (
            False
        ), &quot;Expected STDOUT did not match. Full return dictionary:\n{}&quot;.format(
            pprint.pformat(ret)
        )

    # Let's install a fixed version pip over whatever pip was
    # previously installed
    ret = modules.pip.install(&quot;pip==19.3.1&quot;, upgrade=True, bin_env=venv_dir)

    if not isinstance(ret, dict):
        pytest.fail(
            &quot;The 'pip.install' command did not return the excepted dictionary.&quot;
            &quot; Output:\n{}&quot;.format(ret)
        )

    assert ret[&quot;retcode&quot;] == 0
    assert &quot;Successfully installed pip&quot; in ret[&quot;stdout&quot;]

    # Let's make sure we have pip 9.0.1 installed
    assert modules.pip.list(&quot;pip&quot;, bin_env=venv_dir) == {&quot;pip&quot;: &quot;19.3.1&quot;}

    # Now the actual pip upgrade pip test
    ret = states.pip.installed(name=&quot;pip==20.0.1&quot;, upgrade=True, bin_env=venv_dir)

    if not isinstance(ret.raw, dict):
        pytest.fail(
            &quot;The 'pip.install' command did not return the excepted dictionary.&quot;
            &quot; Output:\n{}&quot;.format(ret)
        )

    assert ret.result is True
    assert ret.changes == {&quot;pip==20.0.1&quot;: &quot;Installed&quot;}


@pytest.mark.slow_test
def test_pip_installed_specific_env(
    tmp_path, state_tree_prod, states, create_virtualenv
):
    # Create the testing virtualenv
    venv_dir = tmp_path / &quot;pip-installed-specific-env&quot;

    contents = &quot;pep8\n&quot;

    # Let's write a requirements file
    with pytest.helpers.temp_file(
        &quot;prod-env-requirements.txt&quot;, contents, state_tree_prod
    ):

        create_virtualenv(str(venv_dir))

        # The requirements file should not be found the base environment
        ret = states.pip.installed(
            name=&quot;&quot;,
            bin_env=str(venv_dir),
            requirements=&quot;salt://prod-env-requirements.txt&quot;,
        )
        assert ret.result is False
        assert &quot;'salt://prod-env-requirements.txt' not found&quot; in ret.comment

        # The requirements file must be found in the prod environment
        ret = states.pip.installed(
            name=&quot;&quot;,
            bin_env=str(venv_dir),
            saltenv=&quot;prod&quot;,
            requirements=&quot;salt://prod-env-requirements.txt&quot;,
        )
        assert ret.result is True
        assert (
            &quot;Successfully processed requirements file salt://prod-env-requirements.txt&quot;
            in ret.comment
        )

        # We're using the base environment but we're passing the prod
        # environment as an url arg to salt://
        ret = states.pip.installed(
            name=&quot;&quot;,
            bin_env=str(venv_dir),
            requirements=&quot;salt://prod-env-requirements.txt?saltenv=prod&quot;,
        )
        assert ret.result is True
        assert &quot;Requirements were already installed.&quot; in ret.comment


@pytest.mark.slow_test
def test_22359_pip_installed_unless_does_not_trigger_warnings(
    create_virtualenv, tmp_path, states
):
    # This test case should be moved to a format_call unit test specific to
    # the state internal keywords
    venv_dir = str(tmp_path / &quot;pip-installed-unless&quot;)
    venv_create = create_virtualenv(venv_dir)
    if venv_create[&quot;retcode&quot;] &gt; 0:
        pytest.skip(
            &quot;Failed to create testcase virtual environment: {}&quot;.format(venv_create)
        )

    false_cmd = salt.utils.path.which(&quot;false&quot;)
    if salt.utils.platform.is_windows():
        false_cmd = &quot;exit 1 &gt;nul&quot;
    try:
        ret = states.pip.installed(
            name=&quot;pep8&quot;,
            bin_env=str(venv_dir),
            unless=false_cmd,
            timeout=600,
        )
        assert ret.result is True
        assert &quot;warnings&quot; not in next(iter(ret.raw.values()))
    finally:
        if os.path.isdir(str(venv_dir)):
            shutil.rmtree(str(venv_dir), ignore_errors=True)


@pytest.mark.windows_whitelisted
@pytest.mark.slow_test
def test_issue_54755(tmp_path, state_tree, modules):
    &quot;&quot;&quot;
    Verify github issue 54755 is resolved. This only fails when there is no
    pip module in the python environment. Since the test suite normally has
    a pip module this test will pass and is here for posterity. See also

    unit.states.test_pip_state.PipStateUtilsTest.test_pip_purge_method_with_pip

     and

    unit.states.test_pip_state.PipStateUtilsTest.test_pip_purge_method_without_pip

    Which also validate this issue and will pass/fail regardless of whether
    or not pip is installed.
    &quot;&quot;&quot;
    file_path = tmp_path / &quot;issue-54755&quot;
    sls_contents = &quot;&quot;&quot;issue-54755:
    file.managed:
        - name: {{ pillar['file_path'] }}
        - contents: issue-54755
        - unless: /bin/bash -c false
    &quot;&quot;&quot;

    with pytest.helpers.temp_file(&quot;issue-54755.sls&quot;, sls_contents, state_tree):
        ret = modules.state.sls(mods=&quot;issue-54755&quot;, pillar={&quot;file_path&quot;: file_path})
        key = &quot;file_|-issue-54755_|-{}_|-managed&quot;.format(file_path)
        assert key in ret.raw
        assert ret.raw[key][&quot;result&quot;] is True
        with salt.utils.files.fopen(str(file_path), &quot;r&quot;) as fp:
            assert fp.read().strip() == &quot;issue-54755&quot;
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>setup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Pedro Algarvio (pedro@algarvio.me)


    salt.log.setup
    ~~~~~~~~~~~~~~

    This is where Salt's logging gets set up.

    This module should be imported as soon as possible, preferably the first
    module salt or any salt depending library imports so any new logging
<A NAME="0"></A>    logger instance uses our ``salt.log.setup.SaltLoggingClass``.
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match203317-0.html#0',2,'match203317-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import logging
import logging.handlers
import multiprocessing
import os
import socket
import sys
import time
import traceback
import types
import urllib.parse

# pylint: disable=unused-import
from salt._logging import (
    LOG_COLORS,
    LOG_LEVELS,
    LOG_VALUES_TO_LEVELS,
    SORTED_LEVEL_NAMES,
)
from salt._logging.handlers import (
    FileHandler,
    QueueHandler,
    RotatingFileHandler,
    StreamHandler,
    SysLogHandler,
    WatchedFileHandler,
)
from salt._logging.impl import (
    LOGGING_NULL_HANDLER,
    LOGGING_STORE_HANDLER,
    LOGGING_TEMP_HANDLER,
    SaltColorLogRecord,
    SaltLogRecord,
)
from</B></FONT> salt._logging.impl import set_log_record_factory as setLogRecordFactory

# pylint: enable=unused-import

__CONSOLE_CONFIGURED = False
__LOGGING_CONSOLE_HANDLER = None
__LOGFILE_CONFIGURED = False
__LOGGING_LOGFILE_HANDLER = None
__TEMP_LOGGING_CONFIGURED = False
__EXTERNAL_LOGGERS_CONFIGURED = False
__MP_LOGGING_LISTENER_CONFIGURED = False
__MP_LOGGING_CONFIGURED = False
__MP_LOGGING_QUEUE = None
__MP_LOGGING_LEVEL = logging.GARBAGE
__MP_LOGGING_QUEUE_PROCESS = None
__MP_LOGGING_QUEUE_HANDLER = None
__MP_IN_MAINPROCESS = multiprocessing.current_process().name == &quot;MainProcess&quot;
__MP_MAINPROCESS_ID = None


def is_console_configured():
    return __CONSOLE_CONFIGURED


def is_logfile_configured():
    return __LOGFILE_CONFIGURED


def is_logging_configured():
    return __CONSOLE_CONFIGURED or __LOGFILE_CONFIGURED


def is_temp_logging_configured():
    return __TEMP_LOGGING_CONFIGURED


def is_mp_logging_listener_configured():
    return __MP_LOGGING_LISTENER_CONFIGURED


def is_mp_logging_configured():
    return __MP_LOGGING_LISTENER_CONFIGURED


def is_extended_logging_configured():
    return __EXTERNAL_LOGGERS_CONFIGURED


class SaltLogQueueHandler(QueueHandler):
    &quot;&quot;&quot;
    Subclassed just to differentiate when debugging
    &quot;&quot;&quot;


def getLogger(name):  # pylint: disable=C0103
    &quot;&quot;&quot;
    This function is just a helper, an alias to:
        logging.getLogger(name)

    Although you might find it useful, there's no reason why you should not be
    using the aliased method.
    &quot;&quot;&quot;
    return logging.getLogger(name)


def setup_temp_logger(log_level=&quot;error&quot;):
    &quot;&quot;&quot;
    Setup the temporary console logger
    &quot;&quot;&quot;
    if is_temp_logging_configured():
        logging.getLogger(__name__).warning(&quot;Temporary logging is already configured&quot;)
        return

    if log_level is None:
        log_level = &quot;warning&quot;

    level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)

    handler = None
    for handler in logging.root.handlers:
        if handler in (LOGGING_NULL_HANDLER, LOGGING_STORE_HANDLER):
            continue

        if not hasattr(handler, &quot;stream&quot;):
            # Not a stream handler, continue
            continue

        if handler.stream is sys.stderr:
            # There's already a logging handler outputting to sys.stderr
            break
    else:
        handler = LOGGING_TEMP_HANDLER
    handler.setLevel(level)

    # Set the default temporary console formatter config
    formatter = logging.Formatter(&quot;[%(levelname)-8s] %(message)s&quot;, datefmt=&quot;%H:%M:%S&quot;)
    handler.setFormatter(formatter)
    logging.root.addHandler(handler)

    # Sync the null logging handler messages with the temporary handler
    if LOGGING_NULL_HANDLER is not None:
        LOGGING_NULL_HANDLER.sync_with_handlers([handler])
    else:
        logging.getLogger(__name__).debug(
            &quot;LOGGING_NULL_HANDLER is already None, can't sync messages with it&quot;
        )

    # Remove the temporary null logging handler
    __remove_null_logging_handler()

    global __TEMP_LOGGING_CONFIGURED
    __TEMP_LOGGING_CONFIGURED = True


def setup_console_logger(log_level=&quot;error&quot;, log_format=None, date_format=None):
    &quot;&quot;&quot;
    Setup the console logger
    &quot;&quot;&quot;
    if is_console_configured():
        logging.getLogger(__name__).warning(&quot;Console logging already configured&quot;)
        return

    # Remove the temporary logging handler
    __remove_temp_logging_handler()

    if log_level is None:
        log_level = &quot;warning&quot;

    level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)

    setLogRecordFactory(SaltColorLogRecord)

    handler = None
    for handler in logging.root.handlers:
        if handler is LOGGING_STORE_HANDLER:
            continue

        if not hasattr(handler, &quot;stream&quot;):
            # Not a stream handler, continue
            continue

        if handler.stream is sys.stderr:
            # There's already a logging handler outputting to sys.stderr
            break
    else:
        handler = StreamHandler(sys.stderr)
    handler.setLevel(level)

    # Set the default console formatter config
    if not log_format:
        log_format = &quot;[%(levelname)-8s] %(message)s&quot;
    if not date_format:
        date_format = &quot;%H:%M:%S&quot;

    formatter = logging.Formatter(log_format, datefmt=date_format)

    handler.setFormatter(formatter)
    logging.root.addHandler(handler)

    global __CONSOLE_CONFIGURED
    global __LOGGING_CONSOLE_HANDLER
    __CONSOLE_CONFIGURED = True
    __LOGGING_CONSOLE_HANDLER = handler


def setup_logfile_logger(
    log_path,
    log_level=&quot;error&quot;,
    log_format=None,
    date_format=None,
    max_bytes=0,
    backup_count=0,
):
    &quot;&quot;&quot;
    Setup the logfile logger

    Since version 0.10.6 we support logging to syslog, some examples:

        tcp://localhost:514/LOG_USER
        tcp://localhost/LOG_DAEMON
        udp://localhost:5145/LOG_KERN
        udp://localhost
        file:///dev/log
        file:///dev/log/LOG_SYSLOG
        file:///dev/log/LOG_DAEMON

    The above examples are self explanatory, but:
        &lt;file|udp|tcp&gt;://&lt;host|socketpath&gt;:&lt;port-if-required&gt;/&lt;log-facility&gt;

    If you're thinking on doing remote logging you might also be thinking that
    you could point salt's logging to the remote syslog. **Please Don't!**
    An issue has been reported when doing this over TCP when the logged lines
    get concatenated. See #3061.

    The preferred way to do remote logging is setup a local syslog, point
    salt's logging to the local syslog(unix socket is much faster) and then
    have the local syslog forward the log messages to the remote syslog.
    &quot;&quot;&quot;

    if is_logfile_configured():
        logging.getLogger(__name__).warning(&quot;Logfile logging already configured&quot;)
        return

    if log_path is None:
        logging.getLogger(__name__).warning(
            &quot;log_path setting is set to `None`. Nothing else to do&quot;
        )
        return

    # Remove the temporary logging handler
    __remove_temp_logging_handler()

    if log_level is None:
        log_level = &quot;warning&quot;

    level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)

    parsed_log_path = urllib.parse.urlparse(log_path)

    root_logger = logging.getLogger()

    if parsed_log_path.scheme in (&quot;tcp&quot;, &quot;udp&quot;, &quot;file&quot;):
        syslog_opts = {
            &quot;facility&quot;: SysLogHandler.LOG_USER,
            &quot;socktype&quot;: socket.SOCK_DGRAM,
        }

        if parsed_log_path.scheme == &quot;file&quot; and parsed_log_path.path:
            facility_name = parsed_log_path.path.split(os.sep)[-1].upper()
            if not facility_name.startswith(&quot;LOG_&quot;):
                # The user is not specifying a syslog facility
                facility_name = &quot;LOG_USER&quot;  # Syslog default
                syslog_opts[&quot;address&quot;] = parsed_log_path.path
            else:
                # The user has set a syslog facility, let's update the path to
                # the logging socket
                syslog_opts[&quot;address&quot;] = os.sep.join(
                    parsed_log_path.path.split(os.sep)[:-1]
                )
        elif parsed_log_path.path:
            # In case of udp or tcp with a facility specified
            facility_name = parsed_log_path.path.lstrip(os.sep).upper()
            if not facility_name.startswith(&quot;LOG_&quot;):
                # Logging facilities start with LOG_ if this is not the case
                # fail right now!
                raise RuntimeError(
                    &quot;The syslog facility '{}' is not known&quot;.format(facility_name)
                )
        else:
            # This is the case of udp or tcp without a facility specified
            facility_name = &quot;LOG_USER&quot;  # Syslog default

        facility = getattr(SysLogHandler, facility_name, None)
        if facility is None:
            # This python syslog version does not know about the user provided
            # facility name
            raise RuntimeError(
                &quot;The syslog facility '{}' is not known&quot;.format(facility_name)
            )
        syslog_opts[&quot;facility&quot;] = facility

        if parsed_log_path.scheme == &quot;tcp&quot;:
            # tcp syslog support was only added on python versions &gt;= 2.7
            if sys.version_info &lt; (2, 7):
                raise RuntimeError(
                    &quot;Python versions lower than 2.7 do not support logging &quot;
                    &quot;to syslog using tcp sockets&quot;
                )
            syslog_opts[&quot;socktype&quot;] = socket.SOCK_STREAM

        if parsed_log_path.scheme in (&quot;tcp&quot;, &quot;udp&quot;):
            syslog_opts[&quot;address&quot;] = (
                parsed_log_path.hostname,
                parsed_log_path.port or logging.handlers.SYSLOG_UDP_PORT,
            )

        if sys.version_info &lt; (2, 7) or parsed_log_path.scheme == &quot;file&quot;:
            # There's not socktype support on python versions lower than 2.7
            syslog_opts.pop(&quot;socktype&quot;, None)

        try:
            # Et voil√°! Finally our syslog handler instance
            handler = SysLogHandler(**syslog_opts)
        except OSError as err:
            logging.getLogger(__name__).error(
                &quot;Failed to setup the Syslog logging handler: %s&quot;, err
            )
            shutdown_multiprocessing_logging_listener()
            sys.exit(2)
    else:
        # make sure, the logging directory exists and attempt to create it if necessary
        log_dir = os.path.dirname(log_path)
        if not os.path.exists(log_dir):
            logging.getLogger(__name__).info(
                &quot;Log directory not found, trying to create it: %s&quot;, log_dir
            )
            try:
                os.makedirs(log_dir, mode=0o700)
            except OSError as ose:
                logging.getLogger(__name__).warning(
                    &quot;Failed to create directory for log file: %s (%s)&quot;, log_dir, ose
                )
                return
        try:
            # Logfile logging is UTF-8 on purpose.
            # Since salt uses YAML and YAML uses either UTF-8 or UTF-16, if a
            # user is not using plain ASCII, their system should be ready to
            # handle UTF-8.
            if max_bytes &gt; 0:
                handler = RotatingFileHandler(
                    log_path,
                    mode=&quot;a&quot;,
                    maxBytes=max_bytes,
                    backupCount=backup_count,
                    encoding=&quot;utf-8&quot;,
                    delay=0,
                )
            else:
                handler = WatchedFileHandler(
                    log_path, mode=&quot;a&quot;, encoding=&quot;utf-8&quot;, delay=0
                )
        except OSError:
            logging.getLogger(__name__).warning(
                &quot;Failed to open log file, do you have permission to write to %s?&quot;,
                log_path,
            )
            # Do not proceed with any more configuration since it will fail, we
            # have the console logging already setup and the user should see
            # the error.
            return

    handler.setLevel(level)

    # Set the default console formatter config
    if not log_format:
        log_format = &quot;%(asctime)s [%(name)-15s][%(levelname)-8s] %(message)s&quot;
    if not date_format:
        date_format = &quot;%Y-%m-%d %H:%M:%S&quot;

    formatter = logging.Formatter(log_format, datefmt=date_format)

    handler.setFormatter(formatter)
    root_logger.addHandler(handler)

    global __LOGFILE_CONFIGURED
    global __LOGGING_LOGFILE_HANDLER
    __LOGFILE_CONFIGURED = True
    __LOGGING_LOGFILE_HANDLER = handler


def setup_extended_logging(opts):
    &quot;&quot;&quot;
    Setup any additional logging handlers, internal or external
    &quot;&quot;&quot;
    if is_extended_logging_configured() is True:
        # Don't re-configure external loggers
        return

    # Explicit late import of salt's loader
    import salt.loader

    # Let's keep a reference to the current logging handlers
    initial_handlers = logging.root.handlers[:]

    # Load any additional logging handlers
    providers = salt.loader.log_handlers(opts)

    # Let's keep track of the new logging handlers so we can sync the stored
    # log records with them
    additional_handlers = []

    for name, get_handlers_func in providers.items():
        logging.getLogger(__name__).info(&quot;Processing `log_handlers.%s`&quot;, name)
        # Keep a reference to the logging handlers count before getting the
        # possible additional ones.
        initial_handlers_count = len(logging.root.handlers)

        handlers = get_handlers_func()
        if isinstance(handlers, types.GeneratorType):
            handlers = list(handlers)
        elif handlers is False or handlers == [False]:
            # A false return value means not configuring any logging handler on
            # purpose
            logging.getLogger(__name__).info(
                &quot;The `log_handlers.%s.setup_handlers()` function returned &quot;
                &quot;`False` which means no logging handler was configured on &quot;
                &quot;purpose. Continuing...&quot;,
                name,
            )
            continue
        else:
            # Make sure we have an iterable
            handlers = [handlers]

        for handler in handlers:
            if not handler and len(logging.root.handlers) == initial_handlers_count:
                logging.getLogger(__name__).info(
                    &quot;The `log_handlers.%s`, did not return any handlers &quot;
                    &quot;and the global handlers count did not increase. This &quot;
                    &quot;could be a sign of `log_handlers.%s` not working as &quot;
                    &quot;supposed&quot;,
                    name,
                    name,
                )
                continue

            logging.getLogger(__name__).debug(
                &quot;Adding the '%s' provided logging handler: '%s'&quot;, name, handler
            )
            additional_handlers.append(handler)
            logging.root.addHandler(handler)

    for handler in logging.root.handlers:
        if handler in initial_handlers:
            continue
        additional_handlers.append(handler)

    # Sync the null logging handler messages with the temporary handler
    if LOGGING_STORE_HANDLER is not None:
        LOGGING_STORE_HANDLER.sync_with_handlers(additional_handlers)
    else:
        logging.getLogger(__name__).debug(
            &quot;LOGGING_STORE_HANDLER is already None, can't sync messages with it&quot;
        )

    # Remove the temporary queue logging handler
    __remove_queue_logging_handler()

    # Remove the temporary null logging handler (if it exists)
    __remove_null_logging_handler()

    global __EXTERNAL_LOGGERS_CONFIGURED
    __EXTERNAL_LOGGERS_CONFIGURED = True


def get_multiprocessing_logging_queue():
    global __MP_LOGGING_QUEUE
    from salt.utils.platform import is_darwin, is_aix

    if __MP_LOGGING_QUEUE is not None:
        return __MP_LOGGING_QUEUE

    if __MP_IN_MAINPROCESS is False:
        # We're not in the MainProcess, return! No Queue shall be instantiated
        return __MP_LOGGING_QUEUE

    if __MP_LOGGING_QUEUE is None:
        if is_darwin() or is_aix():
            __MP_LOGGING_QUEUE = multiprocessing.Queue(32767)
        else:
            __MP_LOGGING_QUEUE = multiprocessing.Queue(100000)
    return __MP_LOGGING_QUEUE


def set_multiprocessing_logging_queue(queue):
    global __MP_LOGGING_QUEUE
    if __MP_LOGGING_QUEUE is not queue:
        __MP_LOGGING_QUEUE = queue


def get_multiprocessing_logging_level():
    return __MP_LOGGING_LEVEL


def set_multiprocessing_logging_level(log_level):
    global __MP_LOGGING_LEVEL
    __MP_LOGGING_LEVEL = log_level


def set_multiprocessing_logging_level_by_opts(opts):
    &quot;&quot;&quot;
    This will set the multiprocessing logging level to the lowest
    logging level of all the types of logging that are configured.
    &quot;&quot;&quot;
    global __MP_LOGGING_LEVEL

    log_levels = [
        LOG_LEVELS.get(opts.get(&quot;log_level&quot;, &quot;&quot;).lower(), logging.ERROR),
        LOG_LEVELS.get(opts.get(&quot;log_level_logfile&quot;, &quot;&quot;).lower(), logging.ERROR),
    ]
    for level in opts.get(&quot;log_granular_levels&quot;, {}).values():
        log_levels.append(LOG_LEVELS.get(level.lower(), logging.ERROR))

    __MP_LOGGING_LEVEL = min(log_levels)


def setup_multiprocessing_logging_listener(opts, queue=None):
    global __MP_LOGGING_QUEUE_PROCESS
    global __MP_LOGGING_LISTENER_CONFIGURED
    global __MP_MAINPROCESS_ID

    if __MP_IN_MAINPROCESS is False:
        # We're not in the MainProcess, return! No logging listener setup shall happen
        return

    if __MP_LOGGING_LISTENER_CONFIGURED is True:
        return

    if __MP_MAINPROCESS_ID is not None and __MP_MAINPROCESS_ID != os.getpid():
        # We're not in the MainProcess, return! No logging listener setup shall happen
        return

    __MP_MAINPROCESS_ID = os.getpid()
    __MP_LOGGING_QUEUE_PROCESS = multiprocessing.Process(
        name=&quot;MultiprocessingLoggingQueue&quot;,
        target=__process_multiprocessing_logging_queue,
        args=(
            opts,
            queue or get_multiprocessing_logging_queue(),
        ),
    )
    __MP_LOGGING_QUEUE_PROCESS.daemon = True
    __MP_LOGGING_QUEUE_PROCESS.start()
    __MP_LOGGING_LISTENER_CONFIGURED = True


def setup_multiprocessing_logging(queue=None):
    &quot;&quot;&quot;
    This code should be called from within a running multiprocessing
    process instance.
    &quot;&quot;&quot;
    from salt.utils.platform import is_windows

    global __MP_LOGGING_CONFIGURED
    global __MP_LOGGING_QUEUE_HANDLER

    if __MP_IN_MAINPROCESS is True and not is_windows():
        # We're in the MainProcess, return! No multiprocessing logging setup shall happen
        # Windows is the exception where we want to set up multiprocessing
        # logging in the MainProcess.
        return

    try:
        logging._acquireLock()  # pylint: disable=protected-access

        if __MP_LOGGING_CONFIGURED is True:
            return

        # Let's set it to true as fast as possible
        __MP_LOGGING_CONFIGURED = True

        if __MP_LOGGING_QUEUE_HANDLER is not None:
            return

        # The temp null and temp queue logging handlers will store messages.
        # Since noone will process them, memory usage will grow. If they
        # exist, remove them.
        __remove_null_logging_handler()
        __remove_queue_logging_handler()

        # Let's add a queue handler to the logging root handlers
        __MP_LOGGING_QUEUE_HANDLER = SaltLogQueueHandler(
            queue or get_multiprocessing_logging_queue()
        )
        logging.root.addHandler(__MP_LOGGING_QUEUE_HANDLER)
        # Set the logging root level to the lowest needed level to get all
        # desired messages.
        log_level = get_multiprocessing_logging_level()
        logging.root.setLevel(log_level)
        logging.getLogger(__name__).debug(
            &quot;Multiprocessing queue logging configured for the process running &quot;
            &quot;under PID: %s at log level %s&quot;,
            os.getpid(),
            log_level,
        )
        # The above logging call will create, in some situations, a futex wait
        # lock condition, probably due to the multiprocessing Queue's internal
        # lock and semaphore mechanisms.
        # A small sleep will allow us not to hit that futex wait lock condition.
        time.sleep(0.0001)
    finally:
        logging._releaseLock()  # pylint: disable=protected-access


def shutdown_console_logging():
    global __CONSOLE_CONFIGURED
    global __LOGGING_CONSOLE_HANDLER

    if not __CONSOLE_CONFIGURED or not __LOGGING_CONSOLE_HANDLER:
        return

    try:
        logging._acquireLock()
        logging.root.removeHandler(__LOGGING_CONSOLE_HANDLER)
        __LOGGING_CONSOLE_HANDLER = None
        __CONSOLE_CONFIGURED = False
    finally:
        logging._releaseLock()


def shutdown_logfile_logging():
    global __LOGFILE_CONFIGURED
    global __LOGGING_LOGFILE_HANDLER

    if not __LOGFILE_CONFIGURED or not __LOGGING_LOGFILE_HANDLER:
        return

    try:
        logging._acquireLock()
        logging.root.removeHandler(__LOGGING_LOGFILE_HANDLER)
        __LOGGING_LOGFILE_HANDLER = None
        __LOGFILE_CONFIGURED = False
    finally:
        logging._releaseLock()


def shutdown_temp_logging():
    __remove_temp_logging_handler()


def shutdown_multiprocessing_logging():
    global __MP_LOGGING_CONFIGURED
    global __MP_LOGGING_QUEUE_HANDLER

    if not __MP_LOGGING_CONFIGURED or not __MP_LOGGING_QUEUE_HANDLER:
        return

    try:
        logging._acquireLock()
        # Let's remove the queue handler from the logging root handlers
        logging.root.removeHandler(__MP_LOGGING_QUEUE_HANDLER)
        __MP_LOGGING_QUEUE_HANDLER = None
        __MP_LOGGING_CONFIGURED = False
        if not logging.root.handlers:
            # Ensure we have at least one logging root handler so
            # something can handle logging messages. This case should
            # only occur on Windows since on Windows we log to console
            # and file through the Multiprocessing Logging Listener.
            setup_console_logger()
    finally:
        logging._releaseLock()


def shutdown_multiprocessing_logging_listener(daemonizing=False):
    global __MP_LOGGING_QUEUE
    global __MP_LOGGING_QUEUE_PROCESS
    global __MP_LOGGING_LISTENER_CONFIGURED

    if daemonizing is False and __MP_IN_MAINPROCESS is True:
        # We're in the MainProcess and we're not daemonizing, return!
        # No multiprocessing logging listener shutdown shall happen
        return

    if not daemonizing:
        # Need to remove the queue handler so that it doesn't try to send
        # data over a queue that was shut down on the listener end.
        shutdown_multiprocessing_logging()

    if __MP_LOGGING_QUEUE_PROCESS is None:
        return

    if __MP_MAINPROCESS_ID is not None and __MP_MAINPROCESS_ID != os.getpid():
        # We're not in the MainProcess, return! No logging listener setup shall happen
        return

    if __MP_LOGGING_QUEUE_PROCESS.is_alive():
        logging.getLogger(__name__).debug(
            &quot;Stopping the multiprocessing logging queue listener&quot;
        )
        try:
            # Sent None sentinel to stop the logging processing queue
            __MP_LOGGING_QUEUE.put(None)
            # Let's join the multiprocessing logging handle thread
            time.sleep(0.5)
            logging.getLogger(__name__).debug(&quot;closing multiprocessing queue&quot;)
            __MP_LOGGING_QUEUE.close()
            logging.getLogger(__name__).debug(&quot;joining multiprocessing queue thread&quot;)
            __MP_LOGGING_QUEUE.join_thread()
            __MP_LOGGING_QUEUE = None
            __MP_LOGGING_QUEUE_PROCESS.join(1)
            __MP_LOGGING_QUEUE = None
        except OSError:
            # We were unable to deliver the sentinel to the queue
            # carry on...
            pass
        if __MP_LOGGING_QUEUE_PROCESS.is_alive():
            # Process is still alive!?
            __MP_LOGGING_QUEUE_PROCESS.terminate()
        __MP_LOGGING_QUEUE_PROCESS = None
        __MP_LOGGING_LISTENER_CONFIGURED = False
        logging.getLogger(__name__).debug(
            &quot;Stopped the multiprocessing logging queue listener&quot;
        )


def set_logger_level(logger_name, log_level=&quot;error&quot;):
    &quot;&quot;&quot;
    Tweak a specific logger's logging level
    &quot;&quot;&quot;
    logging.getLogger(logger_name).setLevel(
        LOG_LEVELS.get(log_level.lower(), logging.ERROR)
    )


def patch_python_logging_handlers():
    &quot;&quot;&quot;
    Patch the python logging handlers with out mixed-in classes
    &quot;&quot;&quot;
    logging.StreamHandler = StreamHandler
    logging.FileHandler = FileHandler
    logging.handlers.SysLogHandler = SysLogHandler
    logging.handlers.WatchedFileHandler = WatchedFileHandler
    logging.handlers.RotatingFileHandler = RotatingFileHandler
    if sys.version_info &gt;= (3, 2):
        logging.handlers.QueueHandler = QueueHandler


def __process_multiprocessing_logging_queue(opts, queue):
    # Assign UID/GID of user to proc if set
    from salt.utils.verify import check_user

    user = opts.get(&quot;user&quot;)
    if user:
        check_user(user)

    from salt.utils.platform import is_windows

    if is_windows():
        # On Windows, creating a new process doesn't fork (copy the parent
        # process image). Due to this, we need to setup all of our logging
        # inside this process.
        setup_temp_logger()
        setup_console_logger(
            log_level=opts.get(&quot;log_level&quot;),
            log_format=opts.get(&quot;log_fmt_console&quot;),
            date_format=opts.get(&quot;log_datefmt_console&quot;),
        )
        setup_logfile_logger(
            opts.get(&quot;log_file&quot;),
            log_level=opts.get(&quot;log_level_logfile&quot;),
            log_format=opts.get(&quot;log_fmt_logfile&quot;),
            date_format=opts.get(&quot;log_datefmt_logfile&quot;),
            max_bytes=opts.get(&quot;log_rotate_max_bytes&quot;, 0),
            backup_count=opts.get(&quot;log_rotate_backup_count&quot;, 0),
        )
        setup_extended_logging(opts)
    while True:
        try:
            record = queue.get()
            if record is None:
                # A sentinel to stop processing the queue
                break
            # Just log everything, filtering will happen on the main process
            # logging handlers
            logger = logging.getLogger(record.name)
            logger.handle(record)
        except (EOFError, KeyboardInterrupt, SystemExit):
            break
        except Exception as exc:  # pylint: disable=broad-except
            logging.getLogger(__name__).warning(
                &quot;An exception occurred in the multiprocessing logging queue thread: %r&quot;,
                exc,
                exc_info_on_loglevel=logging.DEBUG,
            )


def __remove_null_logging_handler():
    &quot;&quot;&quot;
    This function will run once the temporary logging has been configured. It
    just removes the NullHandler from the logging handlers.
    &quot;&quot;&quot;
    global LOGGING_NULL_HANDLER
    if LOGGING_NULL_HANDLER is None:
        # Already removed
        return

    root_logger = logging.getLogger()

    for handler in root_logger.handlers:
        if handler is LOGGING_NULL_HANDLER:
            root_logger.removeHandler(LOGGING_NULL_HANDLER)
            # Redefine the null handler to None so it can be garbage collected
            LOGGING_NULL_HANDLER = None
            break


def __remove_queue_logging_handler():
    &quot;&quot;&quot;
    This function will run once the additional loggers have been synchronized.
    It just removes the QueueLoggingHandler from the logging handlers.
    &quot;&quot;&quot;
    global LOGGING_STORE_HANDLER
    if LOGGING_STORE_HANDLER is None:
        # Already removed
        return

    root_logger = logging.getLogger()

    for handler in root_logger.handlers:
        if handler is LOGGING_STORE_HANDLER:
            root_logger.removeHandler(LOGGING_STORE_HANDLER)
            # Redefine the null handler to None so it can be garbage collected
            LOGGING_STORE_HANDLER = None
            break


def __remove_temp_logging_handler():
    &quot;&quot;&quot;
    This function will run once logging has been configured. It just removes
    the temporary stream Handler from the logging handlers.
    &quot;&quot;&quot;
    if is_logging_configured():
        # In this case, the temporary logging handler has been removed, return!
        return

    # This should already be done, but...
    __remove_null_logging_handler()

    root_logger = logging.getLogger()
    global LOGGING_TEMP_HANDLER

    for handler in root_logger.handlers:
        if handler is LOGGING_TEMP_HANDLER:
            root_logger.removeHandler(LOGGING_TEMP_HANDLER)
            # Redefine the null handler to None so it can be garbage collected
            LOGGING_TEMP_HANDLER = None
            break

    if sys.version_info &gt;= (2, 7):
        # Python versions &gt;= 2.7 allow warnings to be redirected to the logging
        # system now that it's configured. Let's enable it.
        logging.captureWarnings(True)


def __global_logging_exception_handler(
    exc_type,
    exc_value,
    exc_traceback,
    _logger=logging.getLogger(__name__),
    _stderr=sys.__stderr__,
    _format_exception=traceback.format_exception,
):
    &quot;&quot;&quot;
    This function will log all un-handled python exceptions.
    &quot;&quot;&quot;
    if exc_type.__name__ == &quot;KeyboardInterrupt&quot;:
        # Do not log the exception or display the traceback on Keyboard Interrupt
        # Stop the logging queue listener thread
        if is_mp_logging_listener_configured():
            shutdown_multiprocessing_logging_listener()
        return

    # Log the exception
    msg = &quot;An un-handled exception was caught by salt's global exception handler:&quot;
    try:
        msg = &quot;{}\n{}: {}\n{}&quot;.format(
            msg,
            exc_type.__name__,
            exc_value,
            &quot;&quot;.join(_format_exception(exc_type, exc_value, exc_traceback)).strip(),
        )
    except Exception:  # pylint: disable=broad-except
        msg = &quot;{}\n{}: {}\n(UNABLE TO FORMAT TRACEBACK)&quot;.format(
            msg,
            exc_type.__name__,
            exc_value,
        )
    try:
        _logger.error(msg)
    except Exception:  # pylint: disable=broad-except
        # Python is shutting down and logging has been set to None already
        try:
            _stderr.write(msg + &quot;\n&quot;)
        except Exception:  # pylint: disable=broad-except
            # We have also lost reference to sys.__stderr__ ?!
            print(msg)

    # Call the original sys.excepthook
    try:
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
    except Exception:  # pylint: disable=broad-except
        # Python is shutting down and sys has been set to None already
        pass


# Set our own exception handler as the one to use
sys.excepthook = __global_logging_exception_handler
</PRE>
</div>
  </div>
</body>
</html>
