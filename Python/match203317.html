<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_pip_state.py &amp; setup_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_pip_state.py &amp; setup_1.py
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_pip_state.py (1.7948718%)<th>setup_1.py (1.4814814%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-15)<td><a href="#" name="0">(15-48)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pip_state.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
2 import logging
3 import os
4 import pprint
5 import shutil
6 import sys
7 import pytest
8 import salt.utils.files
9 import salt.utils.path
10 import salt.utils.platform
11 import salt.utils.versions
12 import salt.utils.win_dacl
13 import salt.utils.win_functions
14 import</b></font> salt.utils.win_runas
15 from tests.support.helpers import SKIP_INITIAL_PHOTONOS_FAILURES, patched_environ
16 try:
17     import pwd
18     HAS_PWD = True
19 except ImportError:
20     HAS_PWD = False
21 log = logging.getLogger(__name__)
22 def _win_user_where(username, password, program):
23     cmd = "cmd.exe /c where {}".format(program)
24     ret = salt.utils.win_runas.runas(cmd, username, password)
25     assert ret["retcode"] == 0, "{} returned {}".format(cmd, ret["retcode"])
26     return ret["stdout"].strip().split("\n")[-1].strip()
27 @pytest.fixture(scope="module")
28 def create_virtualenv(modules):
29     def run_command(path, **kwargs):
30         if "python" not in kwargs:
31             try:
32                 if salt.utils.platform.is_windows():
33                     python = os.path.join(
34                         sys.real_prefix, os.path.basename(sys.executable)
35                     )
36                 else:
37                     python_binary_names = [
38                         "python{}.{}".format(*sys.version_info),
39                         "python{}".format(*sys.version_info),
40                         "python",
41                     ]
42                     for binary_name in python_binary_names:
43                         python = os.path.join(sys.real_prefix, "bin", binary_name)
44                         if os.path.exists(python):
45                             break
46                     else:
47                         pytest.fail(
48                             "Couldn't find a python binary name under '{}' matching: {}".format(
49                                 os.path.join(sys.real_prefix, "bin"),
50                                 python_binary_names,
51                             )
52                         )
53                 kwargs["python"] = python
54             except AttributeError:
55                 pass
56         return modules.virtualenv.create(path, **kwargs)
57     return run_command
58 @pytest.mark.slow_test
59 def test_pip_installed_removed(modules, states):
60     name = "pudb"
61     if name in modules.pip.list():
62         pytest.skip("{} is already installed, uninstall to run this test".format(name))
63     ret = states.pip.installed(name=name)
64     assert ret.result is True
65     ret = states.pip.removed(name=name)
66     assert ret.result is True
67 @pytest.mark.slow_test
68 def test_pip_installed_removed_venv(tmp_path, create_virtualenv, states):
69     venv_dir = tmp_path / "pip_installed_removed"
70     create_virtualenv(str(venv_dir))
71     name = "pudb"
72     ret = states.pip.installed(name=name, bin_env=str(venv_dir))
73     assert ret.result is True
74     ret = states.pip.removed(name=name, bin_env=str(venv_dir))
75     assert ret.result is True
76 @pytest.mark.slow_test
77 def test_pip_installed_errors(tmp_path, modules, state_tree):
78     venv_dir = tmp_path / "pip-installed-errors"
79     sls_contents = """
80 pep8-pip:
81   pip.installed:
82     - name: pep8
83     - bin_env: '{}'
84     Test pip.installed state while test=true
85     Test pip.installed state while test=true
86     with pytest.helpers.temp_file(
87         "issue-2028-pip-installed.sls", sls_contents, state_tree
88     ):
89         ret = modules.state.sls(
90             mods="issue-2028-pip-installed",
91             pillar={
92                 "venv_dir": str(venv_dir),
93                 "python_exeutable": get_python_executable,
94             },
95         )
96         pep8_bin = venv_dir / "bin" / "pep8"
97         if salt.utils.platform.is_windows():
98             pep8_bin = venv_dir / "Scripts" / "pep8.exe"
99         for state_return in ret:
100             assert state_return.result is True
101         assert os.path.isfile(str(pep8_bin)) is True
102 @pytest.mark.slow_test
103 def test_issue_2087_missing_pip(tmp_path, create_virtualenv, modules):
104     venv_dir = tmp_path / "issue-2087-missing-pip"
105     sls_contents = """pep8-pip:
106 pip.installed:
107     - name: pep8
108     - bin_env: {}
109     Verify github issue 54755 is resolved. This only fails when there is no
110     pip module in the python environment. Since the test suite normally has
111     a pip module this test will pass and is here for posterity. See also
112     unit.states.test_pip_state.PipStateUtilsTest.test_pip_purge_method_with_pip
113      and
114     unit.states.test_pip_state.PipStateUtilsTest.test_pip_purge_method_without_pip
115     Which also validate this issue and will pass/fail regardless of whether
116     or not pip is installed.
117     with pytest.helpers.temp_file("issue-54755.sls", sls_contents, state_tree):
118         ret = modules.state.sls(mods="issue-54755", pillar={"file_path": file_path})
119         key = "file_|-issue-54755_|-{}_|-managed".format(file_path)
120         assert key in ret.raw
121         assert ret.raw[key]["result"] is True
122         with salt.utils.files.fopen(str(file_path), "r") as fp:
123             assert fp.read().strip() == "issue-54755"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>setup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
2 import logging.handlers
3 import multiprocessing
4 import os
5 import socket
6 import sys
7 import time
8 import traceback
9 import types
10 import urllib.parse
11 from salt._logging import (
12     LOG_COLORS,
13     LOG_LEVELS,
14     LOG_VALUES_TO_LEVELS,
15     SORTED_LEVEL_NAMES,
16 )
17 from salt._logging.handlers import (
18     FileHandler,
19     QueueHandler,
20     RotatingFileHandler,
21     StreamHandler,
22     SysLogHandler,
23     WatchedFileHandler,
24 )
25 from salt._logging.impl import (
26     LOGGING_NULL_HANDLER,
27     LOGGING_STORE_HANDLER,
28     LOGGING_TEMP_HANDLER,
29     SaltColorLogRecord,
30     SaltLogRecord,
31 )
32 from</b></font> salt._logging.impl import set_log_record_factory as setLogRecordFactory
33 __CONSOLE_CONFIGURED = False
34 __LOGGING_CONSOLE_HANDLER = None
35 __LOGFILE_CONFIGURED = False
36 __LOGGING_LOGFILE_HANDLER = None
37 __TEMP_LOGGING_CONFIGURED = False
38 __EXTERNAL_LOGGERS_CONFIGURED = False
39 __MP_LOGGING_LISTENER_CONFIGURED = False
40 __MP_LOGGING_CONFIGURED = False
41 __MP_LOGGING_QUEUE = None
42 __MP_LOGGING_LEVEL = logging.GARBAGE
43 __MP_LOGGING_QUEUE_PROCESS = None
44 __MP_LOGGING_QUEUE_HANDLER = None
45 __MP_IN_MAINPROCESS = multiprocessing.current_process().name == "MainProcess"
46 __MP_MAINPROCESS_ID = None
47 def is_console_configured():
48     return __CONSOLE_CONFIGURED
49 def is_logfile_configured():
50     return __LOGFILE_CONFIGURED
51 def is_logging_configured():
52     return __CONSOLE_CONFIGURED or __LOGFILE_CONFIGURED
53 def is_temp_logging_configured():
54     return __TEMP_LOGGING_CONFIGURED
55 def is_mp_logging_listener_configured():
56     return __MP_LOGGING_LISTENER_CONFIGURED
57 def is_mp_logging_configured():
58     return __MP_LOGGING_LISTENER_CONFIGURED
59 def is_extended_logging_configured():
60     return __EXTERNAL_LOGGERS_CONFIGURED
61 class SaltLogQueueHandler(QueueHandler):
62 def getLogger(name):  # pylint: disable=C0103
63     return logging.getLogger(name)
64 def setup_temp_logger(log_level="error"):
65     if is_temp_logging_configured():
66         logging.getLogger(__name__).warning("Temporary logging is already configured")
67         return
68     if log_level is None:
69         log_level = "warning"
70     level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)
71     handler = None
72     for handler in logging.root.handlers:
73         if handler in (LOGGING_NULL_HANDLER, LOGGING_STORE_HANDLER):
74             continue
75         if not hasattr(handler, "stream"):
76             continue
77         if handler.stream is sys.stderr:
78             break
79     else:
80         handler = LOGGING_TEMP_HANDLER
81     handler.setLevel(level)
82     formatter = logging.Formatter("[%(levelname)-8s] %(message)s", datefmt="%H:%M:%S")
83     handler.setFormatter(formatter)
84     logging.root.addHandler(handler)
85     if LOGGING_NULL_HANDLER is not None:
86         LOGGING_NULL_HANDLER.sync_with_handlers([handler])
87     else:
88         logging.getLogger(__name__).debug(
89             "LOGGING_NULL_HANDLER is already None, can't sync messages with it"
90         )
91     __remove_null_logging_handler()
92     global __TEMP_LOGGING_CONFIGURED
93     __TEMP_LOGGING_CONFIGURED = True
94 def setup_console_logger(log_level="error", log_format=None, date_format=None):
95     if is_console_configured():
96         logging.getLogger(__name__).warning("Console logging already configured")
97         return
98     __remove_temp_logging_handler()
99     if log_level is None:
100         log_level = "warning"
101     level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)
102     setLogRecordFactory(SaltColorLogRecord)
103     handler = None
104     for handler in logging.root.handlers:
105         if handler is LOGGING_STORE_HANDLER:
106             continue
107         if not hasattr(handler, "stream"):
108             continue
109         if handler.stream is sys.stderr:
110             break
111     else:
112         handler = StreamHandler(sys.stderr)
113     handler.setLevel(level)
114     if not log_format:
115         log_format = "[%(levelname)-8s] %(message)s"
116     if not date_format:
117         date_format = "%H:%M:%S"
118     formatter = logging.Formatter(log_format, datefmt=date_format)
119     handler.setFormatter(formatter)
120     logging.root.addHandler(handler)
121     global __CONSOLE_CONFIGURED
122     global __LOGGING_CONSOLE_HANDLER
123     __CONSOLE_CONFIGURED = True
124     __LOGGING_CONSOLE_HANDLER = handler
125 def setup_logfile_logger(
126     log_path,
127     log_level="error",
128     log_format=None,
129     date_format=None,
130     max_bytes=0,
131     backup_count=0,
132 ):
133     if is_logfile_configured():
134         logging.getLogger(__name__).warning("Logfile logging already configured")
135         return
136     if log_path is None:
137         logging.getLogger(__name__).warning(
138             "log_path setting is set to `None`. Nothing else to do"
139         )
140         return
141     __remove_temp_logging_handler()
142     if log_level is None:
143         log_level = "warning"
144     level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)
145     parsed_log_path = urllib.parse.urlparse(log_path)
146     root_logger = logging.getLogger()
147     if parsed_log_path.scheme in ("tcp", "udp", "file"):
148         syslog_opts = {
149             "facility": SysLogHandler.LOG_USER,
150             "socktype": socket.SOCK_DGRAM,
151         }
152         if parsed_log_path.scheme == "file" and parsed_log_path.path:
153             facility_name = parsed_log_path.path.split(os.sep)[-1].upper()
154             if not facility_name.startswith("LOG_"):
155                 facility_name = "LOG_USER"  # Syslog default
156                 syslog_opts["address"] = parsed_log_path.path
157             else:
158                 syslog_opts["address"] = os.sep.join(
159                     parsed_log_path.path.split(os.sep)[:-1]
160                 )
161         elif parsed_log_path.path:
162             facility_name = parsed_log_path.path.lstrip(os.sep).upper()
163             if not facility_name.startswith("LOG_"):
164                 raise RuntimeError(
165                     "The syslog facility '{}' is not known".format(facility_name)
166                 )
167         else:
168             facility_name = "LOG_USER"  # Syslog default
169         facility = getattr(SysLogHandler, facility_name, None)
170         if facility is None:
171             raise RuntimeError(
172                 "The syslog facility '{}' is not known".format(facility_name)
173             )
174         syslog_opts["facility"] = facility
175         if parsed_log_path.scheme == "tcp":
176             if sys.version_info &lt; (2, 7):
177                 raise RuntimeError(
178                     "Python versions lower than 2.7 do not support logging "
179                     "to syslog using tcp sockets"
180                 )
181             syslog_opts["socktype"] = socket.SOCK_STREAM
182         if parsed_log_path.scheme in ("tcp", "udp"):
183             syslog_opts["address"] = (
184                 parsed_log_path.hostname,
185                 parsed_log_path.port or logging.handlers.SYSLOG_UDP_PORT,
186             )
187         if sys.version_info &lt; (2, 7) or parsed_log_path.scheme == "file":
188             syslog_opts.pop("socktype", None)
189         try:
190             handler = SysLogHandler(**syslog_opts)
191         except OSError as err:
192             logging.getLogger(__name__).error(
193                 "Failed to setup the Syslog logging handler: %s", err
194             )
195             shutdown_multiprocessing_logging_listener()
196             sys.exit(2)
197     else:
198         log_dir = os.path.dirname(log_path)
199         if not os.path.exists(log_dir):
200             logging.getLogger(__name__).info(
201                 "Log directory not found, trying to create it: %s", log_dir
202             )
203             try:
204                 os.makedirs(log_dir, mode=0o700)
205             except OSError as ose:
206                 logging.getLogger(__name__).warning(
207                     "Failed to create directory for log file: %s (%s)", log_dir, ose
208                 )
209                 return
210         try:
211             if max_bytes &gt; 0:
212                 handler = RotatingFileHandler(
213                     log_path,
214                     mode="a",
215                     maxBytes=max_bytes,
216                     backupCount=backup_count,
217                     encoding="utf-8",
218                     delay=0,
219                 )
220             else:
221                 handler = WatchedFileHandler(
222                     log_path, mode="a", encoding="utf-8", delay=0
223                 )
224         except OSError:
225             logging.getLogger(__name__).warning(
226                 "Failed to open log file, do you have permission to write to %s?",
227                 log_path,
228             )
229             return
230     handler.setLevel(level)
231     if not log_format:
232         log_format = "%(asctime)s [%(name)-15s][%(levelname)-8s] %(message)s"
233     if not date_format:
234         date_format = "%Y-%m-%d %H:%M:%S"
235     formatter = logging.Formatter(log_format, datefmt=date_format)
236     handler.setFormatter(formatter)
237     root_logger.addHandler(handler)
238     global __LOGFILE_CONFIGURED
239     global __LOGGING_LOGFILE_HANDLER
240     __LOGFILE_CONFIGURED = True
241     __LOGGING_LOGFILE_HANDLER = handler
242 def setup_extended_logging(opts):
243     if is_extended_logging_configured() is True:
244         return
245     import salt.loader
246     initial_handlers = logging.root.handlers[:]
247     providers = salt.loader.log_handlers(opts)
248     additional_handlers = []
249     for name, get_handlers_func in providers.items():
250         logging.getLogger(__name__).info("Processing `log_handlers.%s`", name)
251         initial_handlers_count = len(logging.root.handlers)
252         handlers = get_handlers_func()
253         if isinstance(handlers, types.GeneratorType):
254             handlers = list(handlers)
255         elif handlers is False or handlers == [False]:
256             logging.getLogger(__name__).info(
257                 "The `log_handlers.%s.setup_handlers()` function returned "
258                 "`False` which means no logging handler was configured on "
259                 "purpose. Continuing...",
260                 name,
261             )
262             continue
263         else:
264             handlers = [handlers]
265         for handler in handlers:
266             if not handler and len(logging.root.handlers) == initial_handlers_count:
267                 logging.getLogger(__name__).info(
268                     "The `log_handlers.%s`, did not return any handlers "
269                     "and the global handlers count did not increase. This "
270                     "could be a sign of `log_handlers.%s` not working as "
271                     "supposed",
272                     name,
273                     name,
274                 )
275                 continue
276             logging.getLogger(__name__).debug(
277                 "Adding the '%s' provided logging handler: '%s'", name, handler
278             )
279             additional_handlers.append(handler)
280             logging.root.addHandler(handler)
281     for handler in logging.root.handlers:
282         if handler in initial_handlers:
283             continue
284         additional_handlers.append(handler)
285     if LOGGING_STORE_HANDLER is not None:
286         LOGGING_STORE_HANDLER.sync_with_handlers(additional_handlers)
287     else:
288         logging.getLogger(__name__).debug(
289             "LOGGING_STORE_HANDLER is already None, can't sync messages with it"
290         )
291     __remove_queue_logging_handler()
292     __remove_null_logging_handler()
293     global __EXTERNAL_LOGGERS_CONFIGURED
294     __EXTERNAL_LOGGERS_CONFIGURED = True
295 def get_multiprocessing_logging_queue():
296     global __MP_LOGGING_QUEUE
297     from salt.utils.platform import is_darwin, is_aix
298     if __MP_LOGGING_QUEUE is not None:
299         return __MP_LOGGING_QUEUE
300     if __MP_IN_MAINPROCESS is False:
301         return __MP_LOGGING_QUEUE
302     if __MP_LOGGING_QUEUE is None:
303         if is_darwin() or is_aix():
304             __MP_LOGGING_QUEUE = multiprocessing.Queue(32767)
305         else:
306             __MP_LOGGING_QUEUE = multiprocessing.Queue(100000)
307     return __MP_LOGGING_QUEUE
308 def set_multiprocessing_logging_queue(queue):
309     global __MP_LOGGING_QUEUE
310     if __MP_LOGGING_QUEUE is not queue:
311         __MP_LOGGING_QUEUE = queue
312 def get_multiprocessing_logging_level():
313     return __MP_LOGGING_LEVEL
314 def set_multiprocessing_logging_level(log_level):
315     global __MP_LOGGING_LEVEL
316     __MP_LOGGING_LEVEL = log_level
317 def set_multiprocessing_logging_level_by_opts(opts):
318     global __MP_LOGGING_LEVEL
319     log_levels = [
320         LOG_LEVELS.get(opts.get("log_level", "").lower(), logging.ERROR),
321         LOG_LEVELS.get(opts.get("log_level_logfile", "").lower(), logging.ERROR),
322     ]
323     for level in opts.get("log_granular_levels", {}).values():
324         log_levels.append(LOG_LEVELS.get(level.lower(), logging.ERROR))
325     __MP_LOGGING_LEVEL = min(log_levels)
326 def setup_multiprocessing_logging_listener(opts, queue=None):
327     global __MP_LOGGING_QUEUE_PROCESS
328     global __MP_LOGGING_LISTENER_CONFIGURED
329     global __MP_MAINPROCESS_ID
330     if __MP_IN_MAINPROCESS is False:
331         return
332     if __MP_LOGGING_LISTENER_CONFIGURED is True:
333         return
334     if __MP_MAINPROCESS_ID is not None and __MP_MAINPROCESS_ID != os.getpid():
335         return
336     __MP_MAINPROCESS_ID = os.getpid()
337     __MP_LOGGING_QUEUE_PROCESS = multiprocessing.Process(
338         name="MultiprocessingLoggingQueue",
339         target=__process_multiprocessing_logging_queue,
340         args=(
341             opts,
342             queue or get_multiprocessing_logging_queue(),
343         ),
344     )
345     __MP_LOGGING_QUEUE_PROCESS.daemon = True
346     __MP_LOGGING_QUEUE_PROCESS.start()
347     __MP_LOGGING_LISTENER_CONFIGURED = True
348 def setup_multiprocessing_logging(queue=None):
349     from salt.utils.platform import is_windows
350     global __MP_LOGGING_CONFIGURED
351     global __MP_LOGGING_QUEUE_HANDLER
352     if __MP_IN_MAINPROCESS is True and not is_windows():
353         return
354     try:
355         logging._acquireLock()  # pylint: disable=protected-access
356         if __MP_LOGGING_CONFIGURED is True:
357             return
358         __MP_LOGGING_CONFIGURED = True
359         if __MP_LOGGING_QUEUE_HANDLER is not None:
360             return
361         __remove_null_logging_handler()
362         __remove_queue_logging_handler()
363         __MP_LOGGING_QUEUE_HANDLER = SaltLogQueueHandler(
364             queue or get_multiprocessing_logging_queue()
365         )
366         logging.root.addHandler(__MP_LOGGING_QUEUE_HANDLER)
367         log_level = get_multiprocessing_logging_level()
368         logging.root.setLevel(log_level)
369         logging.getLogger(__name__).debug(
370             "Multiprocessing queue logging configured for the process running "
371             "under PID: %s at log level %s",
372             os.getpid(),
373             log_level,
374         )
375         time.sleep(0.0001)
376     finally:
377         logging._releaseLock()  # pylint: disable=protected-access
378 def shutdown_console_logging():
379     global __CONSOLE_CONFIGURED
380     global __LOGGING_CONSOLE_HANDLER
381     if not __CONSOLE_CONFIGURED or not __LOGGING_CONSOLE_HANDLER:
382         return
383     try:
384         logging._acquireLock()
385         logging.root.removeHandler(__LOGGING_CONSOLE_HANDLER)
386         __LOGGING_CONSOLE_HANDLER = None
387         __CONSOLE_CONFIGURED = False
388     finally:
389         logging._releaseLock()
390 def shutdown_logfile_logging():
391     global __LOGFILE_CONFIGURED
392     global __LOGGING_LOGFILE_HANDLER
393     if not __LOGFILE_CONFIGURED or not __LOGGING_LOGFILE_HANDLER:
394         return
395     try:
396         logging._acquireLock()
397         logging.root.removeHandler(__LOGGING_LOGFILE_HANDLER)
398         __LOGGING_LOGFILE_HANDLER = None
399         __LOGFILE_CONFIGURED = False
400     finally:
401         logging._releaseLock()
402 def shutdown_temp_logging():
403     __remove_temp_logging_handler()
404 def shutdown_multiprocessing_logging():
405     global __MP_LOGGING_CONFIGURED
406     global __MP_LOGGING_QUEUE_HANDLER
407     if not __MP_LOGGING_CONFIGURED or not __MP_LOGGING_QUEUE_HANDLER:
408         return
409     try:
410         logging._acquireLock()
411         logging.root.removeHandler(__MP_LOGGING_QUEUE_HANDLER)
412         __MP_LOGGING_QUEUE_HANDLER = None
413         __MP_LOGGING_CONFIGURED = False
414         if not logging.root.handlers:
415             setup_console_logger()
416     finally:
417         logging._releaseLock()
418 def shutdown_multiprocessing_logging_listener(daemonizing=False):
419     global __MP_LOGGING_QUEUE
420     global __MP_LOGGING_QUEUE_PROCESS
421     global __MP_LOGGING_LISTENER_CONFIGURED
422     if daemonizing is False and __MP_IN_MAINPROCESS is True:
423         return
424     if not daemonizing:
425         shutdown_multiprocessing_logging()
426     if __MP_LOGGING_QUEUE_PROCESS is None:
427         return
428     if __MP_MAINPROCESS_ID is not None and __MP_MAINPROCESS_ID != os.getpid():
429         return
430     if __MP_LOGGING_QUEUE_PROCESS.is_alive():
431         logging.getLogger(__name__).debug(
432             "Stopping the multiprocessing logging queue listener"
433         )
434         try:
435             __MP_LOGGING_QUEUE.put(None)
436             time.sleep(0.5)
437             logging.getLogger(__name__).debug("closing multiprocessing queue")
438             __MP_LOGGING_QUEUE.close()
439             logging.getLogger(__name__).debug("joining multiprocessing queue thread")
440             __MP_LOGGING_QUEUE.join_thread()
441             __MP_LOGGING_QUEUE = None
442             __MP_LOGGING_QUEUE_PROCESS.join(1)
443             __MP_LOGGING_QUEUE = None
444         except OSError:
445             pass
446         if __MP_LOGGING_QUEUE_PROCESS.is_alive():
447             __MP_LOGGING_QUEUE_PROCESS.terminate()
448         __MP_LOGGING_QUEUE_PROCESS = None
449         __MP_LOGGING_LISTENER_CONFIGURED = False
450         logging.getLogger(__name__).debug(
451             "Stopped the multiprocessing logging queue listener"
452         )
453 def set_logger_level(logger_name, log_level="error"):
454     logging.getLogger(logger_name).setLevel(
455         LOG_LEVELS.get(log_level.lower(), logging.ERROR)
456     )
457 def patch_python_logging_handlers():
458     logging.StreamHandler = StreamHandler
459     logging.FileHandler = FileHandler
460     logging.handlers.SysLogHandler = SysLogHandler
461     logging.handlers.WatchedFileHandler = WatchedFileHandler
462     logging.handlers.RotatingFileHandler = RotatingFileHandler
463     if sys.version_info &gt;= (3, 2):
464         logging.handlers.QueueHandler = QueueHandler
465 def __process_multiprocessing_logging_queue(opts, queue):
466     from salt.utils.verify import check_user
467     user = opts.get("user")
468     if user:
469         check_user(user)
470     from salt.utils.platform import is_windows
471     if is_windows():
472         setup_temp_logger()
473         setup_console_logger(
474             log_level=opts.get("log_level"),
475             log_format=opts.get("log_fmt_console"),
476             date_format=opts.get("log_datefmt_console"),
477         )
478         setup_logfile_logger(
479             opts.get("log_file"),
480             log_level=opts.get("log_level_logfile"),
481             log_format=opts.get("log_fmt_logfile"),
482             date_format=opts.get("log_datefmt_logfile"),
483             max_bytes=opts.get("log_rotate_max_bytes", 0),
484             backup_count=opts.get("log_rotate_backup_count", 0),
485         )
486         setup_extended_logging(opts)
487     while True:
488         try:
489             record = queue.get()
490             if record is None:
491                 break
492             logger = logging.getLogger(record.name)
493             logger.handle(record)
494         except (EOFError, KeyboardInterrupt, SystemExit):
495             break
496         except Exception as exc:  # pylint: disable=broad-except
497             logging.getLogger(__name__).warning(
498                 "An exception occurred in the multiprocessing logging queue thread: %r",
499                 exc,
500                 exc_info_on_loglevel=logging.DEBUG,
501             )
502 def __remove_null_logging_handler():
503     global LOGGING_NULL_HANDLER
504     if LOGGING_NULL_HANDLER is None:
505         return
506     root_logger = logging.getLogger()
507     for handler in root_logger.handlers:
508         if handler is LOGGING_NULL_HANDLER:
509             root_logger.removeHandler(LOGGING_NULL_HANDLER)
510             LOGGING_NULL_HANDLER = None
511             break
512 def __remove_queue_logging_handler():
513     global LOGGING_STORE_HANDLER
514     if LOGGING_STORE_HANDLER is None:
515         return
516     root_logger = logging.getLogger()
517     for handler in root_logger.handlers:
518         if handler is LOGGING_STORE_HANDLER:
519             root_logger.removeHandler(LOGGING_STORE_HANDLER)
520             LOGGING_STORE_HANDLER = None
521             break
522 def __remove_temp_logging_handler():
523     if is_logging_configured():
524         return
525     __remove_null_logging_handler()
526     root_logger = logging.getLogger()
527     global LOGGING_TEMP_HANDLER
528     for handler in root_logger.handlers:
529         if handler is LOGGING_TEMP_HANDLER:
530             root_logger.removeHandler(LOGGING_TEMP_HANDLER)
531             LOGGING_TEMP_HANDLER = None
532             break
533     if sys.version_info &gt;= (2, 7):
534         logging.captureWarnings(True)
535 def __global_logging_exception_handler(
536     exc_type,
537     exc_value,
538     exc_traceback,
539     _logger=logging.getLogger(__name__),
540     _stderr=sys.__stderr__,
541     _format_exception=traceback.format_exception,
542 ):
543     if exc_type.__name__ == "KeyboardInterrupt":
544         if is_mp_logging_listener_configured():
545             shutdown_multiprocessing_logging_listener()
546         return
547     msg = "An un-handled exception was caught by salt's global exception handler:"
548     try:
549         msg = "{}\n{}: {}\n{}".format(
550             msg,
551             exc_type.__name__,
552             exc_value,
553             "".join(_format_exception(exc_type, exc_value, exc_traceback)).strip(),
554         )
555     except Exception:  # pylint: disable=broad-except
556         msg = "{}\n{}: {}\n(UNABLE TO FORMAT TRACEBACK)".format(
557             msg,
558             exc_type.__name__,
559             exc_value,
560         )
561     try:
562         _logger.error(msg)
563     except Exception:  # pylint: disable=broad-except
564         try:
565             _stderr.write(msg + "\n")
566         except Exception:  # pylint: disable=broad-except
567             print(msg)
568     try:
569         sys.__excepthook__(exc_type, exc_value, exc_traceback)
570     except Exception:  # pylint: disable=broad-except
571         pass
572 sys.excepthook = __global_logging_exception_handler
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
