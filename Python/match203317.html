<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_pip_state.py &amp; setup_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_pip_state.py &amp; setup_1.py
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_pip_state.py (1.7948718%)<th>setup_1.py (1.4814814%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-15)<td><a href="#" name="0">(15-48)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pip_state.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
import logging
import os
import pprint
import shutil
import sys
import pytest
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import salt.utils.versions
import salt.utils.win_dacl
import salt.utils.win_functions
import</b></font> salt.utils.win_runas
from tests.support.helpers import SKIP_INITIAL_PHOTONOS_FAILURES, patched_environ
try:
    import pwd
    HAS_PWD = True
except ImportError:
    HAS_PWD = False
log = logging.getLogger(__name__)
def _win_user_where(username, password, program):
    cmd = "cmd.exe /c where {}".format(program)
    ret = salt.utils.win_runas.runas(cmd, username, password)
    assert ret["retcode"] == 0, "{} returned {}".format(cmd, ret["retcode"])
    return ret["stdout"].strip().split("\n")[-1].strip()
@pytest.fixture(scope="module")
def create_virtualenv(modules):
    def run_command(path, **kwargs):
        if "python" not in kwargs:
            try:
                if salt.utils.platform.is_windows():
                    python = os.path.join(
                        sys.real_prefix, os.path.basename(sys.executable)
                    )
                else:
                    python_binary_names = [
                        "python{}.{}".format(*sys.version_info),
                        "python{}".format(*sys.version_info),
                        "python",
                    ]
                    for binary_name in python_binary_names:
                        python = os.path.join(sys.real_prefix, "bin", binary_name)
                        if os.path.exists(python):
                            break
                    else:
                        pytest.fail(
                            "Couldn't find a python binary name under '{}' matching: {}".format(
                                os.path.join(sys.real_prefix, "bin"),
                                python_binary_names,
                            )
                        )
                kwargs["python"] = python
            except AttributeError:
                pass
        return modules.virtualenv.create(path, **kwargs)
    return run_command
@pytest.mark.slow_test
def test_pip_installed_removed(modules, states):
    name = "pudb"
    if name in modules.pip.list():
        pytest.skip("{} is already installed, uninstall to run this test".format(name))
    ret = states.pip.installed(name=name)
    assert ret.result is True
    ret = states.pip.removed(name=name)
    assert ret.result is True
@pytest.mark.slow_test
def test_pip_installed_removed_venv(tmp_path, create_virtualenv, states):
    venv_dir = tmp_path / "pip_installed_removed"
    create_virtualenv(str(venv_dir))
    name = "pudb"
    ret = states.pip.installed(name=name, bin_env=str(venv_dir))
    assert ret.result is True
    ret = states.pip.removed(name=name, bin_env=str(venv_dir))
    assert ret.result is True
@pytest.mark.slow_test
def test_pip_installed_errors(tmp_path, modules, state_tree):
    venv_dir = tmp_path / "pip-installed-errors"
    sls_contents = """
pep8-pip:
  pip.installed:
    - name: pep8
    - bin_env: '{}'
    Test pip.installed state while test=true
    Test pip.installed state while test=true
    with pytest.helpers.temp_file(
        "issue-2028-pip-installed.sls", sls_contents, state_tree
    ):
        ret = modules.state.sls(
            mods="issue-2028-pip-installed",
            pillar={
                "venv_dir": str(venv_dir),
                "python_exeutable": get_python_executable,
            },
        )
        pep8_bin = venv_dir / "bin" / "pep8"
        if salt.utils.platform.is_windows():
            pep8_bin = venv_dir / "Scripts" / "pep8.exe"
        for state_return in ret:
            assert state_return.result is True
        assert os.path.isfile(str(pep8_bin)) is True
@pytest.mark.slow_test
def test_issue_2087_missing_pip(tmp_path, create_virtualenv, modules):
    venv_dir = tmp_path / "issue-2087-missing-pip"
    sls_contents = """pep8-pip:
pip.installed:
    - name: pep8
    - bin_env: {}
    Verify github issue 54755 is resolved. This only fails when there is no
    pip module in the python environment. Since the test suite normally has
    a pip module this test will pass and is here for posterity. See also
    unit.states.test_pip_state.PipStateUtilsTest.test_pip_purge_method_with_pip
     and
    unit.states.test_pip_state.PipStateUtilsTest.test_pip_purge_method_without_pip
    Which also validate this issue and will pass/fail regardless of whether
    or not pip is installed.
    with pytest.helpers.temp_file("issue-54755.sls", sls_contents, state_tree):
        ret = modules.state.sls(mods="issue-54755", pillar={"file_path": file_path})
        key = "file_|-issue-54755_|-{}_|-managed".format(file_path)
        assert key in ret.raw
        assert ret.raw[key]["result"] is True
        with salt.utils.files.fopen(str(file_path), "r") as fp:
            assert fp.read().strip() == "issue-54755"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>setup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
import logging.handlers
import multiprocessing
import os
import socket
import sys
import time
import traceback
import types
import urllib.parse
from salt._logging import (
    LOG_COLORS,
    LOG_LEVELS,
    LOG_VALUES_TO_LEVELS,
    SORTED_LEVEL_NAMES,
)
from salt._logging.handlers import (
    FileHandler,
    QueueHandler,
    RotatingFileHandler,
    StreamHandler,
    SysLogHandler,
    WatchedFileHandler,
)
from salt._logging.impl import (
    LOGGING_NULL_HANDLER,
    LOGGING_STORE_HANDLER,
    LOGGING_TEMP_HANDLER,
    SaltColorLogRecord,
    SaltLogRecord,
)
from</b></font> salt._logging.impl import set_log_record_factory as setLogRecordFactory
__CONSOLE_CONFIGURED = False
__LOGGING_CONSOLE_HANDLER = None
__LOGFILE_CONFIGURED = False
__LOGGING_LOGFILE_HANDLER = None
__TEMP_LOGGING_CONFIGURED = False
__EXTERNAL_LOGGERS_CONFIGURED = False
__MP_LOGGING_LISTENER_CONFIGURED = False
__MP_LOGGING_CONFIGURED = False
__MP_LOGGING_QUEUE = None
__MP_LOGGING_LEVEL = logging.GARBAGE
__MP_LOGGING_QUEUE_PROCESS = None
__MP_LOGGING_QUEUE_HANDLER = None
__MP_IN_MAINPROCESS = multiprocessing.current_process().name == "MainProcess"
__MP_MAINPROCESS_ID = None
def is_console_configured():
    return __CONSOLE_CONFIGURED
def is_logfile_configured():
    return __LOGFILE_CONFIGURED
def is_logging_configured():
    return __CONSOLE_CONFIGURED or __LOGFILE_CONFIGURED
def is_temp_logging_configured():
    return __TEMP_LOGGING_CONFIGURED
def is_mp_logging_listener_configured():
    return __MP_LOGGING_LISTENER_CONFIGURED
def is_mp_logging_configured():
    return __MP_LOGGING_LISTENER_CONFIGURED
def is_extended_logging_configured():
    return __EXTERNAL_LOGGERS_CONFIGURED
class SaltLogQueueHandler(QueueHandler):
def getLogger(name):  # pylint: disable=C0103
    return logging.getLogger(name)
def setup_temp_logger(log_level="error"):
    if is_temp_logging_configured():
        logging.getLogger(__name__).warning("Temporary logging is already configured")
        return
    if log_level is None:
        log_level = "warning"
    level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)
    handler = None
    for handler in logging.root.handlers:
        if handler in (LOGGING_NULL_HANDLER, LOGGING_STORE_HANDLER):
            continue
        if not hasattr(handler, "stream"):
            continue
        if handler.stream is sys.stderr:
            break
    else:
        handler = LOGGING_TEMP_HANDLER
    handler.setLevel(level)
    formatter = logging.Formatter("[%(levelname)-8s] %(message)s", datefmt="%H:%M:%S")
    handler.setFormatter(formatter)
    logging.root.addHandler(handler)
    if LOGGING_NULL_HANDLER is not None:
        LOGGING_NULL_HANDLER.sync_with_handlers([handler])
    else:
        logging.getLogger(__name__).debug(
            "LOGGING_NULL_HANDLER is already None, can't sync messages with it"
        )
    __remove_null_logging_handler()
    global __TEMP_LOGGING_CONFIGURED
    __TEMP_LOGGING_CONFIGURED = True
def setup_console_logger(log_level="error", log_format=None, date_format=None):
    if is_console_configured():
        logging.getLogger(__name__).warning("Console logging already configured")
        return
    __remove_temp_logging_handler()
    if log_level is None:
        log_level = "warning"
    level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)
    setLogRecordFactory(SaltColorLogRecord)
    handler = None
    for handler in logging.root.handlers:
        if handler is LOGGING_STORE_HANDLER:
            continue
        if not hasattr(handler, "stream"):
            continue
        if handler.stream is sys.stderr:
            break
    else:
        handler = StreamHandler(sys.stderr)
    handler.setLevel(level)
    if not log_format:
        log_format = "[%(levelname)-8s] %(message)s"
    if not date_format:
        date_format = "%H:%M:%S"
    formatter = logging.Formatter(log_format, datefmt=date_format)
    handler.setFormatter(formatter)
    logging.root.addHandler(handler)
    global __CONSOLE_CONFIGURED
    global __LOGGING_CONSOLE_HANDLER
    __CONSOLE_CONFIGURED = True
    __LOGGING_CONSOLE_HANDLER = handler
def setup_logfile_logger(
    log_path,
    log_level="error",
    log_format=None,
    date_format=None,
    max_bytes=0,
    backup_count=0,
):
    if is_logfile_configured():
        logging.getLogger(__name__).warning("Logfile logging already configured")
        return
    if log_path is None:
        logging.getLogger(__name__).warning(
            "log_path setting is set to `None`. Nothing else to do"
        )
        return
    __remove_temp_logging_handler()
    if log_level is None:
        log_level = "warning"
    level = LOG_LEVELS.get(log_level.lower(), logging.ERROR)
    parsed_log_path = urllib.parse.urlparse(log_path)
    root_logger = logging.getLogger()
    if parsed_log_path.scheme in ("tcp", "udp", "file"):
        syslog_opts = {
            "facility": SysLogHandler.LOG_USER,
            "socktype": socket.SOCK_DGRAM,
        }
        if parsed_log_path.scheme == "file" and parsed_log_path.path:
            facility_name = parsed_log_path.path.split(os.sep)[-1].upper()
            if not facility_name.startswith("LOG_"):
                facility_name = "LOG_USER"  # Syslog default
                syslog_opts["address"] = parsed_log_path.path
            else:
                syslog_opts["address"] = os.sep.join(
                    parsed_log_path.path.split(os.sep)[:-1]
                )
        elif parsed_log_path.path:
            facility_name = parsed_log_path.path.lstrip(os.sep).upper()
            if not facility_name.startswith("LOG_"):
                raise RuntimeError(
                    "The syslog facility '{}' is not known".format(facility_name)
                )
        else:
            facility_name = "LOG_USER"  # Syslog default
        facility = getattr(SysLogHandler, facility_name, None)
        if facility is None:
            raise RuntimeError(
                "The syslog facility '{}' is not known".format(facility_name)
            )
        syslog_opts["facility"] = facility
        if parsed_log_path.scheme == "tcp":
            if sys.version_info &lt; (2, 7):
                raise RuntimeError(
                    "Python versions lower than 2.7 do not support logging "
                    "to syslog using tcp sockets"
                )
            syslog_opts["socktype"] = socket.SOCK_STREAM
        if parsed_log_path.scheme in ("tcp", "udp"):
            syslog_opts["address"] = (
                parsed_log_path.hostname,
                parsed_log_path.port or logging.handlers.SYSLOG_UDP_PORT,
            )
        if sys.version_info &lt; (2, 7) or parsed_log_path.scheme == "file":
            syslog_opts.pop("socktype", None)
        try:
            handler = SysLogHandler(**syslog_opts)
        except OSError as err:
            logging.getLogger(__name__).error(
                "Failed to setup the Syslog logging handler: %s", err
            )
            shutdown_multiprocessing_logging_listener()
            sys.exit(2)
    else:
        log_dir = os.path.dirname(log_path)
        if not os.path.exists(log_dir):
            logging.getLogger(__name__).info(
                "Log directory not found, trying to create it: %s", log_dir
            )
            try:
                os.makedirs(log_dir, mode=0o700)
            except OSError as ose:
                logging.getLogger(__name__).warning(
                    "Failed to create directory for log file: %s (%s)", log_dir, ose
                )
                return
        try:
            if max_bytes &gt; 0:
                handler = RotatingFileHandler(
                    log_path,
                    mode="a",
                    maxBytes=max_bytes,
                    backupCount=backup_count,
                    encoding="utf-8",
                    delay=0,
                )
            else:
                handler = WatchedFileHandler(
                    log_path, mode="a", encoding="utf-8", delay=0
                )
        except OSError:
            logging.getLogger(__name__).warning(
                "Failed to open log file, do you have permission to write to %s?",
                log_path,
            )
            return
    handler.setLevel(level)
    if not log_format:
        log_format = "%(asctime)s [%(name)-15s][%(levelname)-8s] %(message)s"
    if not date_format:
        date_format = "%Y-%m-%d %H:%M:%S"
    formatter = logging.Formatter(log_format, datefmt=date_format)
    handler.setFormatter(formatter)
    root_logger.addHandler(handler)
    global __LOGFILE_CONFIGURED
    global __LOGGING_LOGFILE_HANDLER
    __LOGFILE_CONFIGURED = True
    __LOGGING_LOGFILE_HANDLER = handler
def setup_extended_logging(opts):
    if is_extended_logging_configured() is True:
        return
    import salt.loader
    initial_handlers = logging.root.handlers[:]
    providers = salt.loader.log_handlers(opts)
    additional_handlers = []
    for name, get_handlers_func in providers.items():
        logging.getLogger(__name__).info("Processing `log_handlers.%s`", name)
        initial_handlers_count = len(logging.root.handlers)
        handlers = get_handlers_func()
        if isinstance(handlers, types.GeneratorType):
            handlers = list(handlers)
        elif handlers is False or handlers == [False]:
            logging.getLogger(__name__).info(
                "The `log_handlers.%s.setup_handlers()` function returned "
                "`False` which means no logging handler was configured on "
                "purpose. Continuing...",
                name,
            )
            continue
        else:
            handlers = [handlers]
        for handler in handlers:
            if not handler and len(logging.root.handlers) == initial_handlers_count:
                logging.getLogger(__name__).info(
                    "The `log_handlers.%s`, did not return any handlers "
                    "and the global handlers count did not increase. This "
                    "could be a sign of `log_handlers.%s` not working as "
                    "supposed",
                    name,
                    name,
                )
                continue
            logging.getLogger(__name__).debug(
                "Adding the '%s' provided logging handler: '%s'", name, handler
            )
            additional_handlers.append(handler)
            logging.root.addHandler(handler)
    for handler in logging.root.handlers:
        if handler in initial_handlers:
            continue
        additional_handlers.append(handler)
    if LOGGING_STORE_HANDLER is not None:
        LOGGING_STORE_HANDLER.sync_with_handlers(additional_handlers)
    else:
        logging.getLogger(__name__).debug(
            "LOGGING_STORE_HANDLER is already None, can't sync messages with it"
        )
    __remove_queue_logging_handler()
    __remove_null_logging_handler()
    global __EXTERNAL_LOGGERS_CONFIGURED
    __EXTERNAL_LOGGERS_CONFIGURED = True
def get_multiprocessing_logging_queue():
    global __MP_LOGGING_QUEUE
    from salt.utils.platform import is_darwin, is_aix
    if __MP_LOGGING_QUEUE is not None:
        return __MP_LOGGING_QUEUE
    if __MP_IN_MAINPROCESS is False:
        return __MP_LOGGING_QUEUE
    if __MP_LOGGING_QUEUE is None:
        if is_darwin() or is_aix():
            __MP_LOGGING_QUEUE = multiprocessing.Queue(32767)
        else:
            __MP_LOGGING_QUEUE = multiprocessing.Queue(100000)
    return __MP_LOGGING_QUEUE
def set_multiprocessing_logging_queue(queue):
    global __MP_LOGGING_QUEUE
    if __MP_LOGGING_QUEUE is not queue:
        __MP_LOGGING_QUEUE = queue
def get_multiprocessing_logging_level():
    return __MP_LOGGING_LEVEL
def set_multiprocessing_logging_level(log_level):
    global __MP_LOGGING_LEVEL
    __MP_LOGGING_LEVEL = log_level
def set_multiprocessing_logging_level_by_opts(opts):
    global __MP_LOGGING_LEVEL
    log_levels = [
        LOG_LEVELS.get(opts.get("log_level", "").lower(), logging.ERROR),
        LOG_LEVELS.get(opts.get("log_level_logfile", "").lower(), logging.ERROR),
    ]
    for level in opts.get("log_granular_levels", {}).values():
        log_levels.append(LOG_LEVELS.get(level.lower(), logging.ERROR))
    __MP_LOGGING_LEVEL = min(log_levels)
def setup_multiprocessing_logging_listener(opts, queue=None):
    global __MP_LOGGING_QUEUE_PROCESS
    global __MP_LOGGING_LISTENER_CONFIGURED
    global __MP_MAINPROCESS_ID
    if __MP_IN_MAINPROCESS is False:
        return
    if __MP_LOGGING_LISTENER_CONFIGURED is True:
        return
    if __MP_MAINPROCESS_ID is not None and __MP_MAINPROCESS_ID != os.getpid():
        return
    __MP_MAINPROCESS_ID = os.getpid()
    __MP_LOGGING_QUEUE_PROCESS = multiprocessing.Process(
        name="MultiprocessingLoggingQueue",
        target=__process_multiprocessing_logging_queue,
        args=(
            opts,
            queue or get_multiprocessing_logging_queue(),
        ),
    )
    __MP_LOGGING_QUEUE_PROCESS.daemon = True
    __MP_LOGGING_QUEUE_PROCESS.start()
    __MP_LOGGING_LISTENER_CONFIGURED = True
def setup_multiprocessing_logging(queue=None):
    from salt.utils.platform import is_windows
    global __MP_LOGGING_CONFIGURED
    global __MP_LOGGING_QUEUE_HANDLER
    if __MP_IN_MAINPROCESS is True and not is_windows():
        return
    try:
        logging._acquireLock()  # pylint: disable=protected-access
        if __MP_LOGGING_CONFIGURED is True:
            return
        __MP_LOGGING_CONFIGURED = True
        if __MP_LOGGING_QUEUE_HANDLER is not None:
            return
        __remove_null_logging_handler()
        __remove_queue_logging_handler()
        __MP_LOGGING_QUEUE_HANDLER = SaltLogQueueHandler(
            queue or get_multiprocessing_logging_queue()
        )
        logging.root.addHandler(__MP_LOGGING_QUEUE_HANDLER)
        log_level = get_multiprocessing_logging_level()
        logging.root.setLevel(log_level)
        logging.getLogger(__name__).debug(
            "Multiprocessing queue logging configured for the process running "
            "under PID: %s at log level %s",
            os.getpid(),
            log_level,
        )
        time.sleep(0.0001)
    finally:
        logging._releaseLock()  # pylint: disable=protected-access
def shutdown_console_logging():
    global __CONSOLE_CONFIGURED
    global __LOGGING_CONSOLE_HANDLER
    if not __CONSOLE_CONFIGURED or not __LOGGING_CONSOLE_HANDLER:
        return
    try:
        logging._acquireLock()
        logging.root.removeHandler(__LOGGING_CONSOLE_HANDLER)
        __LOGGING_CONSOLE_HANDLER = None
        __CONSOLE_CONFIGURED = False
    finally:
        logging._releaseLock()
def shutdown_logfile_logging():
    global __LOGFILE_CONFIGURED
    global __LOGGING_LOGFILE_HANDLER
    if not __LOGFILE_CONFIGURED or not __LOGGING_LOGFILE_HANDLER:
        return
    try:
        logging._acquireLock()
        logging.root.removeHandler(__LOGGING_LOGFILE_HANDLER)
        __LOGGING_LOGFILE_HANDLER = None
        __LOGFILE_CONFIGURED = False
    finally:
        logging._releaseLock()
def shutdown_temp_logging():
    __remove_temp_logging_handler()
def shutdown_multiprocessing_logging():
    global __MP_LOGGING_CONFIGURED
    global __MP_LOGGING_QUEUE_HANDLER
    if not __MP_LOGGING_CONFIGURED or not __MP_LOGGING_QUEUE_HANDLER:
        return
    try:
        logging._acquireLock()
        logging.root.removeHandler(__MP_LOGGING_QUEUE_HANDLER)
        __MP_LOGGING_QUEUE_HANDLER = None
        __MP_LOGGING_CONFIGURED = False
        if not logging.root.handlers:
            setup_console_logger()
    finally:
        logging._releaseLock()
def shutdown_multiprocessing_logging_listener(daemonizing=False):
    global __MP_LOGGING_QUEUE
    global __MP_LOGGING_QUEUE_PROCESS
    global __MP_LOGGING_LISTENER_CONFIGURED
    if daemonizing is False and __MP_IN_MAINPROCESS is True:
        return
    if not daemonizing:
        shutdown_multiprocessing_logging()
    if __MP_LOGGING_QUEUE_PROCESS is None:
        return
    if __MP_MAINPROCESS_ID is not None and __MP_MAINPROCESS_ID != os.getpid():
        return
    if __MP_LOGGING_QUEUE_PROCESS.is_alive():
        logging.getLogger(__name__).debug(
            "Stopping the multiprocessing logging queue listener"
        )
        try:
            __MP_LOGGING_QUEUE.put(None)
            time.sleep(0.5)
            logging.getLogger(__name__).debug("closing multiprocessing queue")
            __MP_LOGGING_QUEUE.close()
            logging.getLogger(__name__).debug("joining multiprocessing queue thread")
            __MP_LOGGING_QUEUE.join_thread()
            __MP_LOGGING_QUEUE = None
            __MP_LOGGING_QUEUE_PROCESS.join(1)
            __MP_LOGGING_QUEUE = None
        except OSError:
            pass
        if __MP_LOGGING_QUEUE_PROCESS.is_alive():
            __MP_LOGGING_QUEUE_PROCESS.terminate()
        __MP_LOGGING_QUEUE_PROCESS = None
        __MP_LOGGING_LISTENER_CONFIGURED = False
        logging.getLogger(__name__).debug(
            "Stopped the multiprocessing logging queue listener"
        )
def set_logger_level(logger_name, log_level="error"):
    logging.getLogger(logger_name).setLevel(
        LOG_LEVELS.get(log_level.lower(), logging.ERROR)
    )
def patch_python_logging_handlers():
    logging.StreamHandler = StreamHandler
    logging.FileHandler = FileHandler
    logging.handlers.SysLogHandler = SysLogHandler
    logging.handlers.WatchedFileHandler = WatchedFileHandler
    logging.handlers.RotatingFileHandler = RotatingFileHandler
    if sys.version_info &gt;= (3, 2):
        logging.handlers.QueueHandler = QueueHandler
def __process_multiprocessing_logging_queue(opts, queue):
    from salt.utils.verify import check_user
    user = opts.get("user")
    if user:
        check_user(user)
    from salt.utils.platform import is_windows
    if is_windows():
        setup_temp_logger()
        setup_console_logger(
            log_level=opts.get("log_level"),
            log_format=opts.get("log_fmt_console"),
            date_format=opts.get("log_datefmt_console"),
        )
        setup_logfile_logger(
            opts.get("log_file"),
            log_level=opts.get("log_level_logfile"),
            log_format=opts.get("log_fmt_logfile"),
            date_format=opts.get("log_datefmt_logfile"),
            max_bytes=opts.get("log_rotate_max_bytes", 0),
            backup_count=opts.get("log_rotate_backup_count", 0),
        )
        setup_extended_logging(opts)
    while True:
        try:
            record = queue.get()
            if record is None:
                break
            logger = logging.getLogger(record.name)
            logger.handle(record)
        except (EOFError, KeyboardInterrupt, SystemExit):
            break
        except Exception as exc:  # pylint: disable=broad-except
            logging.getLogger(__name__).warning(
                "An exception occurred in the multiprocessing logging queue thread: %r",
                exc,
                exc_info_on_loglevel=logging.DEBUG,
            )
def __remove_null_logging_handler():
    global LOGGING_NULL_HANDLER
    if LOGGING_NULL_HANDLER is None:
        return
    root_logger = logging.getLogger()
    for handler in root_logger.handlers:
        if handler is LOGGING_NULL_HANDLER:
            root_logger.removeHandler(LOGGING_NULL_HANDLER)
            LOGGING_NULL_HANDLER = None
            break
def __remove_queue_logging_handler():
    global LOGGING_STORE_HANDLER
    if LOGGING_STORE_HANDLER is None:
        return
    root_logger = logging.getLogger()
    for handler in root_logger.handlers:
        if handler is LOGGING_STORE_HANDLER:
            root_logger.removeHandler(LOGGING_STORE_HANDLER)
            LOGGING_STORE_HANDLER = None
            break
def __remove_temp_logging_handler():
    if is_logging_configured():
        return
    __remove_null_logging_handler()
    root_logger = logging.getLogger()
    global LOGGING_TEMP_HANDLER
    for handler in root_logger.handlers:
        if handler is LOGGING_TEMP_HANDLER:
            root_logger.removeHandler(LOGGING_TEMP_HANDLER)
            LOGGING_TEMP_HANDLER = None
            break
    if sys.version_info &gt;= (2, 7):
        logging.captureWarnings(True)
def __global_logging_exception_handler(
    exc_type,
    exc_value,
    exc_traceback,
    _logger=logging.getLogger(__name__),
    _stderr=sys.__stderr__,
    _format_exception=traceback.format_exception,
):
    if exc_type.__name__ == "KeyboardInterrupt":
        if is_mp_logging_listener_configured():
            shutdown_multiprocessing_logging_listener()
        return
    msg = "An un-handled exception was caught by salt's global exception handler:"
    try:
        msg = "{}\n{}: {}\n{}".format(
            msg,
            exc_type.__name__,
            exc_value,
            "".join(_format_exception(exc_type, exc_value, exc_traceback)).strip(),
        )
    except Exception:  # pylint: disable=broad-except
        msg = "{}\n{}: {}\n(UNABLE TO FORMAT TRACEBACK)".format(
            msg,
            exc_type.__name__,
            exc_value,
        )
    try:
        _logger.error(msg)
    except Exception:  # pylint: disable=broad-except
        try:
            _stderr.write(msg + "\n")
        except Exception:  # pylint: disable=broad-except
            print(msg)
    try:
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
    except Exception:  # pylint: disable=broad-except
        pass
sys.excepthook = __global_logging_exception_handler
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
