<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_cloudwatch.py &amp; boto_apigateway_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_cloudwatch.py &amp; boto_apigateway_1.py
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_cloudwatch.py (16.25767%)<th>boto_apigateway_1.py (2.4559777%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(76-91)<td><a href="#" name="0">(331-351)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(125-164)<td><a href="#" name="1">(224-245)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(317-328)<td><a href="#" name="2">(436-455)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(176-188)<td><a href="#" name="3">(799-813)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_cloudwatch.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import salt.utils.json
import salt.utils.odict as odict
import salt.utils.versions
import yaml  # pylint: disable=blacklisted-import
try:
    import boto
    import boto.ec2.cloudwatch
    import boto.ec2.cloudwatch.listelement
    import boto.ec2.cloudwatch.dimension
    logging.getLogger("boto").setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
log = logging.getLogger(__name__)
def __virtual__():
    has_boto_reqs = salt.utils.versions.check_boto_reqs(check_boto3=False)
    if has_boto_reqs is True:
<a name="0"></a>        __utils__["boto.assign_funcs"](
            __name__, "cloudwatch", module="ec2.cloudwatch", pack=__salt__
        )
    r<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn has_boto_reqs
def get_alarm(name, region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    alarms = conn.describe_alarms(</b></font>alarm_names=[name])
    if not alarms:
        return None
    if len(alarms) &gt; 1:
        log.error("multiple alarms matched name '%s'", name)
    return _metric_alarm_to_dict(alarms[0])
def _safe_dump(data):
    custom_dumper = __utils__["yaml.get_dumper"]("SafeOrderedDumper")
    def boto_listelement_presenter(dumper, data):
        return dumper.represent_list(list(data))
    yaml.add_representer(
        boto.ec2.cloudwatch.listelement.ListElement,
        boto_listelement_presenter,
        Dumper=custom_dumper,
    )
    def dimension_presenter(dumper, data):
        return dumper.represent_dict(dict(data))
    yaml.add_representer(
        boto.ec2.cloudwatch.dimension.Dimension,
        dimension_presenter,
<a name="1"></a>        Dumper=custom_dumper,
    )
    return __utils__["yaml.dump"](data, Dumper=<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>custom_dumper)
def get_all_alarms(region=None, prefix=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    alarms =</b></font> conn.describe_alarms()
    results = odict.OrderedDict()
    for alarm in alarms:
        alarm = _metric_alarm_to_dict(alarm)
        name = alarm["name"]
        if prefix:
            if name.startswith(prefix):
                continue
            name = prefix + alarm["name"]
<a name="3"></a>        del alarm["name"]
        alarm_sls = [{"name": name}, {"attributes": alarm}]
        results["manage alarm " + name] = {"boto_cloudwatch_alarm.present": alarm_sls}
    return _safe_dump<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(results)
def create_or_update_alarm(
    connection=None,
    name=None,
    metric=None,
    namespace=None,
    statistic=None,
    comparison=None,
    threshold=None,
    period=None,
    evaluation_periods=</b></font>None,
    unit=None,
    description="",
    dimensions=None,
    alarm_actions=None,
    insufficient_data_actions=None,
    ok_actions=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if threshold:
        threshold = float(threshold)
    if period:
        period = int(period)
    if evaluation_periods:
        evaluation_periods = int(evaluation_periods)
    if isinstance(dimensions, str):
        dimensions = salt.utils.json.loads(dimensions)
        if not isinstance(dimensions, dict):
            log.error(
                "could not parse dimensions argument: must be json encoding of a dict:"
                " '%s'",
                dimensions,
            )
            return False
    if isinstance(alarm_actions, str):
        alarm_actions = alarm_actions.split(",")
    if isinstance(insufficient_data_actions, str):
        insufficient_data_actions = insufficient_data_actions.split(",")
    if isinstance(ok_actions, str):
        ok_actions = ok_actions.split(",")
    if alarm_actions:
        alarm_actions = convert_to_arn(
            alarm_actions, region=region, key=key, keyid=keyid, profile=profile
        )
    if insufficient_data_actions:
        insufficient_data_actions = convert_to_arn(
            insufficient_data_actions,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    if ok_actions:
        ok_actions = convert_to_arn(
            ok_actions, region=region, key=key, keyid=keyid, profile=profile
        )
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    alarm = boto.ec2.cloudwatch.alarm.MetricAlarm(
        connection=connection,
        name=name,
        metric=metric,
        namespace=namespace,
        statistic=statistic,
        comparison=comparison,
        threshold=threshold,
        period=period,
        evaluation_periods=evaluation_periods,
        unit=unit,
        description=description,
        dimensions=dimensions,
        alarm_actions=alarm_actions,
        insufficient_data_actions=insufficient_data_actions,
        ok_actions=ok_actions,
    )
    conn.create_alarm(alarm)
    log.info("Created/updated alarm %s", name)
    return True
def convert_to_arn(arns, region=None, key=None, keyid=None, profile=None):
    results = []
    for arn in arns:
        if arn.startswith("scaling_policy:"):
            _, as_group, scaling_policy_name = arn.split(":")
            policy_arn = __salt__["boto_asg.get_scaling_policy_arn"](
                as_group, scaling_policy_name, region, key, keyid, profile
            )
            if policy_arn:
                results.append(policy_arn)
            else:
<a name="2"></a>                log.error("Could not convert: %s", arn)
        else:
            results.append(arn)
    r<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn results
def delete_alarm(name, region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=</b></font>profile)
    conn.delete_alarms([name])
    log.info("Deleted alarm %s", name)
    return True
def _metric_alarm_to_dict(alarm):
    d = odict.OrderedDict()
    fields = [
        "name",
        "metric",
        "namespace",
        "statistic",
        "comparison",
        "threshold",
        "period",
        "evaluation_periods",
        "unit",
        "description",
        "dimensions",
        "alarm_actions",
        "insufficient_data_actions",
        "ok_actions",
    ]
    for f in fields:
        if hasattr(alarm, f):
            d[f] = getattr(alarm, f)
    return d
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_apigateway_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import datetime
import logging
import salt.utils.compat
import salt.utils.json
import salt.utils.versions
log = logging.getLogger(__name__)
try:
    import boto
    import boto3
    from botocore.exceptions import ClientError
    from botocore import __version__ as found_botocore_version
    logging.getLogger("boto").setLevel(logging.CRITICAL)
    logging.getLogger("boto3").setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
def __virtual__():
    return salt.utils.versions.check_boto_reqs(
        boto_ver="2.8.0", boto3_ver="1.2.1", botocore_ver="1.4.49"
    )
def __init__(opts):
    if HAS_BOTO:
        __utils__["boto3.assign_funcs"](__name__, "apigateway")
def _convert_datetime_str(response):
    if response:
        return dict(
            [
                (k, "{}".format(v)) if isinstance(v, datetime.date) else (k, v)
                for k, v in response.items()
            ]
        )
    return None
def _filter_apis(name, apis):
    return [api for api in apis if api["name"] == name]
def _filter_apis_desc(desc, apis):
    return [api for api in apis if api["description"] == desc]
def _multi_call(function, contentkey, *args, **kwargs):
    ret = function(*args, **kwargs)
    position = ret.get("position")
    while position:
        more = function(*args, position=position, **kwargs)
        ret[contentkey].extend(more[contentkey])
        position = more.get("position")
    return ret.get(contentkey)
def _find_apis_by_name(
    name, description=None, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        apis = _multi_call(conn.get_rest_apis, "items")
        if name:
            apis = _filter_apis(name, apis)
        if description is not None:
            apis = _filter_apis_desc(description, apis)
        return {"restapi": [_convert_datetime_str(api) for api in apis]}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def describe_apis(
    name=None, description=None, region=None, key=None, keyid=None, profile=None
):
    if name:
        return _find_apis_by_name(
            name,
            description=description,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    else:
        return _find_apis_by_name(
            "",
            description=description,
<a name="1"></a>            region=region,
            key=key,
            keyid=keyid,
            profile=p<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>rofile,
        )
def api_exists(name, description=None, region=None, key=None, keyid=None, profile=None):
    apis = _find_apis_by_name(
        name,
        description=description,
        region=region,
        key=key,
        keyid=keyid,
        profile=</b></font>profile,
    )
    return {"exists": bool(apis.get("restapi"))}
def create_api(
    name, description, cloneFrom=None, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if cloneFrom:
            api = conn.create_rest_api(
                name=name, description=description, cloneFrom=cloneFrom
            )
        else:
            api = conn.create_rest_api(name=name, description=description)
        api = _convert_datetime_str(api)
        return {"created": True, "restapi": api} if api else {"created": False}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def delete_api(name, description=None, region=None, key=None, keyid=None, profile=None):
    try:
        conn_params = dict(region=region, key=key, keyid=keyid, profile=profile)
        r = _find_apis_by_name(name, description=description, **conn_params)
        apis = r.get("restapi")
        if apis:
            conn = _get_conn(**conn_params)
            for api in apis:
                conn.delete_rest_api(restApiId=api["id"])
            return {"deleted": True, "count": len(apis)}
        else:
            return {"deleted": False}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def describe_api_resources(restApiId, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        resources = sorted(
            _multi_call(conn.get_resources, "items", restApiId=restApiId),
            key=lambda k: k["path"],
        )
<a name="0"></a>
        return {"resources": resources}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>e)}
def describe_api_resource(
    restApiId, path, region=None, key=None, keyid=None, profile=None
):
    r = describe_api_resources(
        restApiId, region=region, key=key, keyid=keyid, profile=profile
    )
    resources = r.get(</b></font>"resources")
    if resources is None:
        return r
    for resource in resources:
        if resource["path"] == path:
            return {"resource": resource}
    return {"resource": None}
def create_api_resources(
    restApiId, path, region=None, key=None, keyid=None, profile=None
):
    path_parts = path.split("/")
    created = []
    current_path = ""
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        for path_part in path_parts:
            if current_path == "/":
                current_path = "{}{}".format(current_path, path_part)
            else:
                current_path = "{}/{}".format(current_path, path_part)
            r = describe_api_resource(
                restApiId,
                current_path,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            resource = r.get("resource")
            if not resource:
                resource = conn.create_resource(
                    restApiId=restApiId, parentId=created[-1]["id"], pathPart=path_part
                )
            created.append(resource)
        if created:
            return {"created": True, "restApiId": restApiId, "resources": created}
        else:
            return {"created": False, "error": "unexpected error."}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def delete_api_resources(
    restApiId, path, region=None, key=None, keyid=None, profile=None
):
    if path == "/":
        return {"deleted": False, "error": "use delete_api to remove the root resource"}
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        r = describe_api_resource(
            restApiId, path, region=region, key=key, keyid=keyid, profile=profile
        )
        resource = r.get("resource")
        if resource:
            conn.delete_resource(restApiId=restApiId, resourceId=resource["id"])
            return {"deleted": True}
<a name="2"></a>        else:
            return {"deleted": False, "error": "no resource found by {}".format(path)}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>e)}
def describe_api_resource_method(
    restApiId, resourcePath, httpMethod, region=None, key=None, keyid=None, profile=None
):
    r = describe_api_resource(
        restApiId, resourcePath, region=region, key=key, keyid=keyid, profile=</b></font>profile
    )
    resource = r.get("resource")
    if not resource:
        return {"error": "no such resource"}
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        method = conn.get_method(
            restApiId=restApiId, resourceId=resource["id"], httpMethod=httpMethod
        )
        return {"method": method}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def describe_api_key(apiKey, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        response = conn.get_api_key(apiKey=apiKey)
        return {"apiKey": _convert_datetime_str(response)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def describe_api_keys(region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        apikeys = _multi_call(conn.get_api_keys, "items")
        return {"apiKeys": [_convert_datetime_str(apikey) for apikey in apikeys]}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def create_api_key(
    name,
    description,
    enabled=True,
    stageKeys=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        stageKeys = list() if stageKeys is None else stageKeys
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        response = conn.create_api_key(
            name=name, description=description, enabled=enabled, stageKeys=stageKeys
        )
        if not response:
            return {"created": False}
        return {"created": True, "apiKey": _convert_datetime_str(response)}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def delete_api_key(apiKey, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_api_key(apiKey=apiKey)
        return {"deleted": True}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def _api_key_patch_replace(conn, apiKey, path, value):
    response = conn.update_api_key(
        apiKey=apiKey, patchOperations=[{"op": "replace", "path": path, "value": value}]
    )
    return response
def _api_key_patchops(op, pvlist):
    return [{"op": op, "path": p, "value": v} for (p, v) in pvlist]
def _api_key_patch_add(conn, apiKey, pvlist):
    response = conn.update_api_key(
        apiKey=apiKey, patchOperations=_api_key_patchops("add", pvlist)
    )
    return response
def _api_key_patch_remove(conn, apiKey, pvlist):
    response = conn.update_api_key(
        apiKey=apiKey, patchOperations=_api_key_patchops("remove", pvlist)
    )
    return response
def update_api_key_description(
    apiKey, description, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        response = _api_key_patch_replace(conn, apiKey, "/description", description)
        return {"updated": True, "apiKey": _convert_datetime_str(response)}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def enable_api_key(apiKey, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        response = _api_key_patch_replace(conn, apiKey, "/enabled", "True")
        return {"apiKey": _convert_datetime_str(response)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def disable_api_key(apiKey, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        response = _api_key_patch_replace(conn, apiKey, "/enabled", "False")
        return {"apiKey": _convert_datetime_str(response)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def associate_api_key_stagekeys(
    apiKey, stagekeyslist, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        pvlist = [("/stages", stagekey) for stagekey in stagekeyslist]
        response = _api_key_patch_add(conn, apiKey, pvlist)
        return {"associated": True, "apiKey": _convert_datetime_str(response)}
    except ClientError as e:
        return {"associated": False, "error": __utils__["boto3.get_error"](e)}
def disassociate_api_key_stagekeys(
    apiKey, stagekeyslist, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        pvlist = [("/stages", stagekey) for stagekey in stagekeyslist]
        response = _api_key_patch_remove(conn, apiKey, pvlist)
        return {"disassociated": True}
    except ClientError as e:
        return {"disassociated": False, "error": __utils__["boto3.get_error"](e)}
def describe_api_deployments(
    restApiId, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        deployments = []
        _deployments = conn.get_deployments(restApiId=restApiId)
        while True:
            if _deployments:
                deployments = deployments + _deployments["items"]
                if "position" not in _deployments:
                    break
                _deployments = conn.get_deployments(
                    restApiId=restApiId, position=_deployments["position"]
                )
        return {
            "deployments": [
                _convert_datetime_str(deployment) for deployment in deployments
            ]
        }
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def describe_api_deployment(
    restApiId, deploymentId, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        deployment = conn.get_deployment(restApiId=restApiId, deploymentId=deploymentId)
        return {"deployment": _convert_datetime_str(deployment)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def activate_api_deployment(
    restApiId, stageName, deploymentId, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        response = conn.update_stage(
            restApiId=restApiId,
            stageName=stageName,
            patchOperations=[
                {"op": "replace", "path": "/deploymentId", "value": deploymentId}
            ],
<a name="3"></a>        )
        return {"set": True, "response": _convert_datetime_str(response)}
    except ClientError as e:
        return {"set": False, "error": __utils__["boto3.get_error"]<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(e)}
def create_api_deployment(
    restApiId,
    stageName,
    stageDescription="",
    description="",
    cacheClusterEnabled=False,
    cacheClusterSize="0.5",
    variables=None,
    region=None,
    key=None,
    keyid=None,
    profile=</b></font>None,
):
    try:
        variables = dict() if variables is None else variables
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        deployment = conn.create_deployment(
            restApiId=restApiId,
            stageName=stageName,
            stageDescription=stageDescription,
            description=description,
            cacheClusterEnabled=cacheClusterEnabled,
            cacheClusterSize=cacheClusterSize,
            variables=variables,
        )
        return {"created": True, "deployment": _convert_datetime_str(deployment)}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def delete_api_deployment(
    restApiId, deploymentId, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_deployment(restApiId=restApiId, deploymentId=deploymentId)
        return {"deleted": True}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def overwrite_api_stage_variables(
    restApiId, stageName, variables, region=None, key=None, keyid=None, profile=None
):
    try:
        res = describe_api_stage(
            restApiId, stageName, region=region, key=key, keyid=keyid, profile=profile
        )
        if res.get("error"):
            return {"overwrite": False, "error": res.get("error")}
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        stage = res.get("stage")
        old_vars = stage.get("variables", {})
        patch_ops = []
        for old_var in old_vars:
            if old_var not in variables:
                patch_ops.append(
                    dict(op="remove", path="/variables/{}".format(old_var), value="")
                )
        for var, val in variables.items():
            if var not in old_vars or old_vars[var] != val:
                patch_ops.append(
                    dict(op="replace", path="/variables/{}".format(var), value=val)
                )
        if patch_ops:
            stage = conn.update_stage(
                restApiId=restApiId, stageName=stageName, patchOperations=patch_ops
            )
        return {"overwrite": True, "stage": _convert_datetime_str(stage)}
    except ClientError as e:
        return {"overwrite": False, "error": __utils__["boto3.get_error"](e)}
def describe_api_stage(
    restApiId, stageName, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        stage = conn.get_stage(restApiId=restApiId, stageName=stageName)
        return {"stage": _convert_datetime_str(stage)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def describe_api_stages(
    restApiId, deploymentId, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        stages = conn.get_stages(restApiId=restApiId, deploymentId=deploymentId)
        return {"stages": [_convert_datetime_str(stage) for stage in stages["item"]]}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def create_api_stage(
    restApiId,
    stageName,
    deploymentId,
    description="",
    cacheClusterEnabled=False,
    cacheClusterSize="0.5",
    variables=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        variables = dict() if variables is None else variables
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        stage = conn.create_stage(
            restApiId=restApiId,
            stageName=stageName,
            deploymentId=deploymentId,
            description=description,
            cacheClusterEnabled=cacheClusterEnabled,
            cacheClusterSize=cacheClusterSize,
            variables=variables,
        )
        return {"created": True, "stage": _convert_datetime_str(stage)}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def delete_api_stage(
    restApiId, stageName, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_stage(restApiId=restApiId, stageName=stageName)
        return {"deleted": True}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def flush_api_stage_cache(
    restApiId, stageName, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.flush_stage_cache(restApiId=restApiId, stageName=stageName)
        return {"flushed": True}
    except ClientError as e:
        return {"flushed": False, "error": __utils__["boto3.get_error"](e)}
def create_api_method(
    restApiId,
    resourcePath,
    httpMethod,
    authorizationType,
    apiKeyRequired=False,
    requestParameters=None,
    requestModels=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            requestParameters = (
                dict() if requestParameters is None else requestParameters
            )
            requestModels = dict() if requestModels is None else requestModels
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            method = conn.put_method(
                restApiId=restApiId,
                resourceId=resource["id"],
                httpMethod=httpMethod,
                authorizationType=str(authorizationType),
                apiKeyRequired=apiKeyRequired,
                requestParameters=requestParameters,
                requestModels=requestModels,
            )
            return {"created": True, "method": method}
        return {"created": False, "error": "Failed to create method"}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def describe_api_method(
    restApiId, resourcePath, httpMethod, region=None, key=None, keyid=None, profile=None
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            method = conn.get_method(
                restApiId=restApiId, resourceId=resource["id"], httpMethod=httpMethod
            )
            return {"method": _convert_datetime_str(method)}
        return {"error": "get API method failed: no such resource"}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def delete_api_method(
    restApiId, resourcePath, httpMethod, region=None, key=None, keyid=None, profile=None
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            conn.delete_method(
                restApiId=restApiId, resourceId=resource["id"], httpMethod=httpMethod
            )
            return {"deleted": True}
        return {"deleted": False, "error": "get API method failed: no such resource"}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def create_api_method_response(
    restApiId,
    resourcePath,
    httpMethod,
    statusCode,
    responseParameters=None,
    responseModels=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            responseParameters = (
                dict() if responseParameters is None else responseParameters
            )
            responseModels = dict() if responseModels is None else responseModels
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            response = conn.put_method_response(
                restApiId=restApiId,
                resourceId=resource["id"],
                httpMethod=httpMethod,
                statusCode=str(statusCode),
                responseParameters=responseParameters,
                responseModels=responseModels,
            )
            return {"created": True, "response": response}
        return {"created": False, "error": "no such resource"}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def delete_api_method_response(
    restApiId,
    resourcePath,
    httpMethod,
    statusCode,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            conn.delete_method_response(
                restApiId=restApiId,
                resourceId=resource["id"],
                httpMethod=httpMethod,
                statusCode=str(statusCode),
            )
            return {"deleted": True}
        return {"deleted": False, "error": "no such resource"}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def describe_api_method_response(
    restApiId,
    resourcePath,
    httpMethod,
    statusCode,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            response = conn.get_method_response(
                restApiId=restApiId,
                resourceId=resource["id"],
                httpMethod=httpMethod,
                statusCode=str(statusCode),
            )
            return {"response": _convert_datetime_str(response)}
        return {"error": "no such resource"}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def describe_api_models(restApiId, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        models = _multi_call(conn.get_models, "items", restApiId=restApiId)
        return {"models": [_convert_datetime_str(model) for model in models]}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def describe_api_model(
    restApiId, modelName, flatten=True, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        model = conn.get_model(
            restApiId=restApiId, modelName=modelName, flatten=flatten
        )
        return {"model": _convert_datetime_str(model)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def api_model_exists(
    restApiId, modelName, region=None, key=None, keyid=None, profile=None
):
    r = describe_api_model(
        restApiId, modelName, region=region, key=key, keyid=keyid, profile=profile
    )
    return {"exists": bool(r.get("model"))}
def _api_model_patch_replace(conn, restApiId, modelName, path, value):
    response = conn.update_model(
        restApiId=restApiId,
        modelName=modelName,
        patchOperations=[{"op": "replace", "path": path, "value": value}],
    )
    return response
def update_api_model_schema(
    restApiId, modelName, schema, region=None, key=None, keyid=None, profile=None
):
    try:
        schema_json = (
            salt.utils.json.dumps(schema) if isinstance(schema, dict) else schema
        )
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        response = _api_model_patch_replace(
            conn, restApiId, modelName, "/schema", schema_json
        )
        return {"updated": True, "model": _convert_datetime_str(response)}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def delete_api_model(
    restApiId, modelName, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_model(restApiId=restApiId, modelName=modelName)
        return {"deleted": True}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def create_api_model(
    restApiId,
    modelName,
    modelDescription,
    schema,
    contentType="application/json",
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        schema_json = (
            salt.utils.json.dumps(schema) if isinstance(schema, dict) else schema
        )
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        model = conn.create_model(
            restApiId=restApiId,
            name=modelName,
            description=modelDescription,
            schema=schema_json,
            contentType=contentType,
        )
        return {"created": True, "model": _convert_datetime_str(model)}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def describe_api_integration(
    restApiId, resourcePath, httpMethod, region=None, key=None, keyid=None, profile=None
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            integration = conn.get_integration(
                restApiId=restApiId, resourceId=resource["id"], httpMethod=httpMethod
            )
            return {"integration": _convert_datetime_str(integration)}
        return {"error": "no such resource"}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def describe_api_integration_response(
    restApiId,
    resourcePath,
    httpMethod,
    statusCode,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            response = conn.get_integration_response(
                restApiId=restApiId,
                resourceId=resource["id"],
                httpMethod=httpMethod,
                statusCode=statusCode,
            )
            return {"response": _convert_datetime_str(response)}
        return {"error": "no such resource"}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def delete_api_integration(
    restApiId, resourcePath, httpMethod, region=None, key=None, keyid=None, profile=None
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            conn.delete_integration(
                restApiId=restApiId, resourceId=resource["id"], httpMethod=httpMethod
            )
            return {"deleted": True}
        return {"deleted": False, "error": "no such resource"}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def delete_api_integration_response(
    restApiId,
    resourcePath,
    httpMethod,
    statusCode,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            conn.delete_integration_response(
                restApiId=restApiId,
                resourceId=resource["id"],
                httpMethod=httpMethod,
                statusCode=statusCode,
            )
            return {"deleted": True}
        return {"deleted": False, "error": "no such resource"}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def _get_role_arn(name, region=None, key=None, keyid=None, profile=None):
    if name.startswith("arn:aws:iam:"):
        return name
    account_id = __salt__["boto_iam.get_account_id"](
        region=region, key=key, keyid=keyid, profile=profile
    )
    return "arn:aws:iam::{}:role/{}".format(account_id, name)
def create_api_integration(
    restApiId,
    resourcePath,
    httpMethod,
    integrationType,
    integrationHttpMethod,
    uri,
    credentials,
    requestParameters=None,
    requestTemplates=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        credentials = _get_role_arn(
            credentials, region=region, key=key, keyid=keyid, profile=profile
        )
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            requestParameters = (
                dict() if requestParameters is None else requestParameters
            )
            requestTemplates = dict() if requestTemplates is None else requestTemplates
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            if httpMethod.lower() == "options":
                uri = ""
                credentials = ""
            integration = conn.put_integration(
                restApiId=restApiId,
                resourceId=resource["id"],
                httpMethod=httpMethod,
                type=integrationType,
                integrationHttpMethod=integrationHttpMethod,
                uri=uri,
                credentials=credentials,
                requestParameters=requestParameters,
                requestTemplates=requestTemplates,
            )
            return {"created": True, "integration": integration}
        return {"created": False, "error": "no such resource"}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def create_api_integration_response(
    restApiId,
    resourcePath,
    httpMethod,
    statusCode,
    selectionPattern,
    responseParameters=None,
    responseTemplates=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        resource = describe_api_resource(
            restApiId,
            resourcePath,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("resource")
        if resource:
            responseParameters = (
                dict() if responseParameters is None else responseParameters
            )
            responseTemplates = (
                dict() if responseTemplates is None else responseTemplates
            )
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            response = conn.put_integration_response(
                restApiId=restApiId,
                resourceId=resource["id"],
                httpMethod=httpMethod,
                statusCode=statusCode,
                selectionPattern=selectionPattern,
                responseParameters=responseParameters,
                responseTemplates=responseTemplates,
            )
            return {"created": True, "response": response}
        return {"created": False, "error": "no such resource"}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def _filter_plans(attr, name, plans):
    return [plan for plan in plans if plan[attr] == name]
def describe_usage_plans(
    name=None, plan_id=None, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        plans = _multi_call(conn.get_usage_plans, "items")
        if name:
            plans = _filter_plans("name", name, plans)
        if plan_id:
            plans = _filter_plans("id", plan_id, plans)
        return {"plans": [_convert_datetime_str(plan) for plan in plans]}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def _validate_throttle(throttle):
    if throttle is not None:
        if not isinstance(throttle, dict):
            raise TypeError(
                "throttle must be a dictionary, provided value: {}".format(throttle)
            )
def _validate_quota(quota):
    if quota is not None:
        if not isinstance(quota, dict):
            raise TypeError(
                "quota must be a dictionary, provided value: {}".format(quota)
            )
        periods = ["DAY", "WEEK", "MONTH"]
        if "period" not in quota or quota["period"] not in periods:
            raise ValueError(
                "quota must have a valid period specified, valid values are {}".format(
                    ",".join(periods)
                )
            )
        if "limit" not in quota:
            raise ValueError("quota limit must have a valid value")
def create_usage_plan(
    name,
    description=None,
    throttle=None,
    quota=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        _validate_throttle(throttle)
        _validate_quota(quota)
        values = dict(name=name)
        if description:
            values["description"] = description
        if throttle:
            values["throttle"] = throttle
        if quota:
            values["quota"] = quota
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        res = conn.create_usage_plan(**values)
        return {"created": True, "result": res}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
    except (TypeError, ValueError) as e:
        return {"error": str(e)}
def update_usage_plan(
    plan_id, throttle=None, quota=None, region=None, key=None, keyid=None, profile=None
):
    try:
        _validate_throttle(throttle)
        _validate_quota(quota)
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        patchOperations = []
        if throttle is None:
            patchOperations.append({"op": "remove", "path": "/throttle"})
        else:
            if "rateLimit" in throttle:
                patchOperations.append(
                    {
                        "op": "replace",
                        "path": "/throttle/rateLimit",
                        "value": str(throttle["rateLimit"]),
                    }
                )
            if "burstLimit" in throttle:
                patchOperations.append(
                    {
                        "op": "replace",
                        "path": "/throttle/burstLimit",
                        "value": str(throttle["burstLimit"]),
                    }
                )
        if quota is None:
            patchOperations.append({"op": "remove", "path": "/quota"})
        else:
            patchOperations.append(
                {
                    "op": "replace",
                    "path": "/quota/period",
                    "value": str(quota["period"]),
                }
            )
            patchOperations.append(
                {"op": "replace", "path": "/quota/limit", "value": str(quota["limit"])}
            )
            if "offset" in quota:
                patchOperations.append(
                    {
                        "op": "replace",
                        "path": "/quota/offset",
                        "value": str(quota["offset"]),
                    }
                )
        if patchOperations:
            res = conn.update_usage_plan(
                usagePlanId=plan_id, patchOperations=patchOperations
            )
            return {"updated": True, "result": res}
        return {"updated": False}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
    except (TypeError, ValueError) as e:
        return {"error": str(e)}
def delete_usage_plan(plan_id, region=None, key=None, keyid=None, profile=None):
    try:
        existing = describe_usage_plans(
            plan_id=plan_id, region=region, key=key, keyid=keyid, profile=profile
        )
        if "error" in existing:
            return {"error": existing["error"]}
        if "plans" in existing and existing["plans"]:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            res = conn.delete_usage_plan(usagePlanId=plan_id)
        return {"deleted": True, "usagePlanId": plan_id}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def _update_usage_plan_apis(
    plan_id, apis, op, region=None, key=None, keyid=None, profile=None
):
    try:
        patchOperations = []
        for api in apis:
            patchOperations.append(
                {
                    "op": op,
                    "path": "/apiStages",
                    "value": "{}:{}".format(api["apiId"], api["stage"]),
                }
            )
        res = None
        if patchOperations:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            res = conn.update_usage_plan(
                usagePlanId=plan_id, patchOperations=patchOperations
            )
        return {"success": True, "result": res}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
    except Exception as e:  # pylint: disable=broad-except
        return {"error": e}
def attach_usage_plan_to_apis(
    plan_id, apis, region=None, key=None, keyid=None, profile=None
):
    return _update_usage_plan_apis(
        plan_id, apis, "add", region=region, key=key, keyid=keyid, profile=profile
    )
def detach_usage_plan_from_apis(
    plan_id, apis, region=None, key=None, keyid=None, profile=None
):
    return _update_usage_plan_apis(
        plan_id, apis, "remove", region=region, key=key, keyid=keyid, profile=profile
    )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
