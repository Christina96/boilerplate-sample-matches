<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for httpclient_test.py & web_test.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for httpclient_test.py & web_test.py
      </h3>
      <h1 align="center">
        8.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>httpclient_test.py (23.381878%)<TH>web_test.py (5.416042%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#0',2,'match25839-1.html#0',3)" NAME="0">(473-478)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#0',2,'match25839-1.html#0',3)" NAME="0">(1964-1969)</A><TD ALIGN=center><FONT COLOR="#ff0000">23</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#1',2,'match25839-1.html#1',3)" NAME="1">(4-28)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#1',2,'match25839-1.html#1',3)" NAME="1">(2-25)</A><TD ALIGN=center><FONT COLOR="#ff0000">23</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#2',2,'match25839-1.html#2',3)" NAME="2">(274-280)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#2',2,'match25839-1.html#2',3)" NAME="2">(1481-1488)</A><TD ALIGN=center><FONT COLOR="#c70000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#3',2,'match25839-1.html#3',3)" NAME="3">(530-538)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#3',2,'match25839-1.html#3',3)" NAME="3">(1017-1023)</A><TD ALIGN=center><FONT COLOR="#b10000">16</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#4',2,'match25839-1.html#4',3)" NAME="4">(444-450)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#4',2,'match25839-1.html#4',3)" NAME="4">(2194-2199)</A><TD ALIGN=center><FONT COLOR="#a60000">15</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#5',2,'match25839-1.html#5',3)" NAME="5">(305-311)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#5',2,'match25839-1.html#5',3)" NAME="5">(1087-1092)</A><TD ALIGN=center><FONT COLOR="#a60000">15</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#6',2,'match25839-1.html#6',3)" NAME="6">(264-269)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#6',2,'match25839-1.html#6',3)" NAME="6">(1242-1247)</A><TD ALIGN=center><FONT COLOR="#a60000">15</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#7',2,'match25839-1.html#7',3)" NAME="7">(479-485)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#7',2,'match25839-1.html#7',3)" NAME="7">(834-840)</A><TD ALIGN=center><FONT COLOR="#9b0000">14</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#8',2,'match25839-1.html#8',3)" NAME="8">(285-290)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#8',2,'match25839-1.html#8',3)" NAME="8">(2242-2246)</A><TD ALIGN=center><FONT COLOR="#900000">13</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#9',2,'match25839-1.html#9',3)" NAME="9">(271-274)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#9',2,'match25839-1.html#9',3)" NAME="9">(2707-2711)</A><TD ALIGN=center><FONT COLOR="#900000">13</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#10',2,'match25839-1.html#10',3)" NAME="10">(173-178)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#10',2,'match25839-1.html#10',3)" NAME="10">(1548-1552)</A><TD ALIGN=center><FONT COLOR="#900000">13</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#11',2,'match25839-1.html#11',3)" NAME="11">(61-68)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#11',2,'match25839-1.html#11',3)" NAME="11">(589-595)</A><TD ALIGN=center><FONT COLOR="#900000">13</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#12',2,'match25839-1.html#12',3)" NAME="12">(41-47)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#12',2,'match25839-1.html#12',3)" NAME="12">(557-565)</A><TD ALIGN=center><FONT COLOR="#900000">13</FONT>
<TR><TD BGCOLOR="#3b9c9c"><FONT COLOR="#3b9c9c">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#13',2,'match25839-1.html#13',3)" NAME="13">(33-41)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#13',2,'match25839-1.html#13',3)" NAME="13">(193-199)</A><TD ALIGN=center><FONT COLOR="#900000">13</FONT>
<TR><TD BGCOLOR="#842dce"><FONT COLOR="#842dce">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#14',2,'match25839-1.html#14',3)" NAME="14">(671-676)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#14',2,'match25839-1.html#14',3)" NAME="14">(1579-1586)</A><TD ALIGN=center><FONT COLOR="#850000">12</FONT>
<TR><TD BGCOLOR="#f52887"><FONT COLOR="#f52887">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#15',2,'match25839-1.html#15',3)" NAME="15">(617-620)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#15',2,'match25839-1.html#15',3)" NAME="15">(1194-1198)</A><TD ALIGN=center><FONT COLOR="#850000">12</FONT>
<TR><TD BGCOLOR="#2981b2"><FONT COLOR="#2981b2">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#16',2,'match25839-1.html#16',3)" NAME="16">(410-419)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#16',2,'match25839-1.html#16',3)" NAME="16">(1520-1526)</A><TD ALIGN=center><FONT COLOR="#850000">12</FONT>
<TR><TD BGCOLOR="#3090c7"><FONT COLOR="#3090c7">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#17',2,'match25839-1.html#17',3)" NAME="17">(219-222)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#17',2,'match25839-1.html#17',3)" NAME="17">(2835-2838)</A><TD ALIGN=center><FONT COLOR="#850000">12</FONT>
<TR><TD BGCOLOR="#800517"><FONT COLOR="#800517">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#18',2,'match25839-1.html#18',3)" NAME="18">(179-185)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#18',2,'match25839-1.html#18',3)" NAME="18">(803-808)</A><TD ALIGN=center><FONT COLOR="#850000">12</FONT>
<TR><TD BGCOLOR="#f62817"><FONT COLOR="#f62817">-</FONT><TD><A HREF="javascript:ZweiFrames('match25839-0.html#19',2,'match25839-1.html#19',3)" NAME="19">(157-160)<TD><A HREF="javascript:ZweiFrames('match25839-0.html#19',2,'match25839-1.html#19',3)" NAME="19">(1597-1599)</A><TD ALIGN=center><FONT COLOR="#850000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>httpclient_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="1"></A>#!/usr/bin/env python
# pylint: skip-file

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match25839-1.html#1',3,'match25839-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>from __future__ import absolute_import, division, print_function

import base64
import binascii
from contextlib import closing
import copy
import functools
import sys
import threading
import datetime
from io import BytesIO

from salt.ext.tornado.escape import utf8, native_str
from salt.ext.tornado import gen
from salt.ext.tornado.httpclient import HTTPRequest, HTTPResponse, _RequestProxy, HTTPError, HTTPClient
from salt.ext.tornado.httpserver import HTTPServer
from salt.ext.tornado.ioloop import IOLoop
from salt.ext.tornado.iostream import IOStream
from salt.ext.tornado.log import gen_log
from salt.ext.tornado import netutil
from salt.ext.tornado.stack_context import ExceptionStackContext, NullContext
from salt.ext.tornado.testing import AsyncHTTPTestCase, bind_unused_port, gen_test, ExpectLog
from salt.ext.tornado.test.util import unittest, skipOnTravis
from salt.ext.tornado.web import Application, RequestHandler, url
from</B></FONT> salt.ext.tornado.httputil import format_timestamp, HTTPHeaders

<A NAME="13"></A>
class HelloWorldHandler(RequestHandler):
    def get(self):
        name = self<FONT color="#3b9c9c"><A HREF="javascript:ZweiFrames('match25839-1.html#13',3,'match25839-top.html#13',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.get_argument(&quot;name&quot;, &quot;world&quot;)
        self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)
        self.finish(&quot;Hello %s!&quot; % name)


<A NAME="12"></A>class PostHandler(RequestHandler):
    def post(self):
        self.finish(&quot;Post arg1: %s, arg2: %s&quot; % (
            self</B></FONT><FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match25839-1.html#12',3,'match25839-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.get_argument(&quot;arg1&quot;), self.get_argument(&quot;arg2&quot;)))


class PutHandler(RequestHandler):
    def put(self):
        self.write(&quot;Put body: &quot;)
        self.write(self.</B></FONT>request.body)


class RedirectHandler(RequestHandler):
    def prepare(self):
        self.write('redirects can have bodies too')
        self.redirect(self.get_argument(&quot;url&quot;),
                      status=int(self.get_argument(&quot;status&quot;, &quot;302&quot;)))


class ChunkHandler(RequestHandler):
<A NAME="11"></A>    @gen.coroutine
    def get(self):
        self.write(&quot;asdf&quot;)
        self<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match25839-1.html#11',3,'match25839-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.flush()
        # Wait a bit to ensure the chunks are sent and received separately.
        yield gen.sleep(0.01)
        self.write(&quot;qwer&quot;)


class AuthHandler(RequestHandler):
    def</B></FONT> get(self):
        self.finish(self.request.headers[&quot;Authorization&quot;])


class CountdownHandler(RequestHandler):
    def get(self, count):
        count = int(count)
        if count &gt; 0:
            self.redirect(self.reverse_url(&quot;countdown&quot;, count - 1))
        else:
            self.write(&quot;Zero&quot;)


class EchoPostHandler(RequestHandler):
    def post(self):
        self.write(self.request.body)


class UserAgentHandler(RequestHandler):
    def get(self):
        self.write(self.request.headers.get('User-Agent', 'User agent not set'))


class ContentLength304Handler(RequestHandler):
    def get(self):
        self.set_status(304)
        self.set_header('Content-Length', 42)

    def _clear_headers_for_304(self):
        # Tornado strips content-length from 304 responses, but here we
        # want to simulate servers that include the headers anyway.
        pass


class PatchHandler(RequestHandler):

    def patch(self):
        &quot;Return the request payload - so we can check it is being kept&quot;
        self.write(self.request.body)


class AllMethodsHandler(RequestHandler):
    SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)

    def method(self):
        self.write(self.request.method)

    get = post = put = delete = options = patch = other = method


class SetHeaderHandler(RequestHandler):
    def get(self):
        # Use get_arguments for keys to get strings, but
        # request.arguments for values to get bytes.
        for k, v in zip(self.get_arguments('k'),
                        self.request.arguments['v']):
            self.set_header(k, v)

# These tests end up getting run redundantly: once here with the default
# HTTPClient implementation, and then again in each implementation's own
# test suite.


class HTTPClientCommonTestCase(AsyncHTTPTestCase):
    def get_app(self):
        return Application([
            url(&quot;/hello&quot;, HelloWorldHandler),
            url(&quot;/post&quot;, PostHandler),
            url(&quot;/put&quot;, PutHandler),
            url(&quot;/redirect&quot;, RedirectHandler),
            url(&quot;/chunk&quot;, ChunkHandler),
            url(&quot;/auth&quot;, AuthHandler),
            url(&quot;/countdown/([0-9]+)&quot;, CountdownHandler, name=&quot;countdown&quot;),
            url(&quot;/echopost&quot;, EchoPostHandler),
            url(&quot;/user_agent&quot;, UserAgentHandler),
            url(&quot;/304_with_content_length&quot;, ContentLength304Handler),
            url(&quot;/all_methods&quot;, AllMethodsHandler),
            url('/patch', PatchHandler),
            url('/set_header', SetHeaderHandler),
        ], gzip=True)

    def test_patch_receives_payload(self):
        body = b&quot;some patch data&quot;
        response = self.fetch(&quot;/patch&quot;, method='PATCH', body=body)
        self.assertEqual(response.code, 200)
        self.assertEqual(response.body, body)
<A NAME="19"></A>
    @skipOnTravis
    def test_hello_world(self):
        response = self<FONT color="#f62817"><A HREF="javascript:ZweiFrames('match25839-1.html#19',3,'match25839-top.html#19',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.fetch(&quot;/hello&quot;)
        self.assertEqual(response.code, 200)
        self.assertEqual(response.headers[&quot;Content-Type&quot;], &quot;text/plain&quot;)
        self.assertEqual(response.</B></FONT>body, b&quot;Hello world!&quot;)
        self.assertEqual(int(response.request_time), 0)

        response = self.fetch(&quot;/hello?name=Ben&quot;)
        self.assertEqual(response.body, b&quot;Hello Ben!&quot;)

    def test_streaming_callback(self):
        # streaming_callback is also tested in test_chunked
        chunks = []
        response = self.fetch(&quot;/hello&quot;,
<A NAME="10"></A>                              streaming_callback=chunks.append)
        # with streaming_callback, data goes to the callback and not response.body
        self.assertEqual(chunks, [b&quot;Hello world!&quot;])
        self<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match25839-1.html#10',3,'match25839-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.assertFalse(response.body)

    def test_post(self):
<A NAME="18"></A>        response = self.fetch(&quot;/post&quot;, method=&quot;POST&quot;,
                              body=&quot;arg1=foo&amp;arg2=bar&quot;)
        self.assertEqual(response.</B></FONT>code, 200)
        self<FONT color="#800517"><A HREF="javascript:ZweiFrames('match25839-1.html#18',3,'match25839-top.html#18',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.assertEqual(response.body, b&quot;Post arg1: foo, arg2: bar&quot;)

    def test_chunked(self):
        response = self.fetch(&quot;/chunk&quot;)
        self.assertEqual(response.body, b&quot;asdfqwer&quot;)

        chunks =</B></FONT> []
        response = self.fetch(&quot;/chunk&quot;,
                              streaming_callback=chunks.append)
        self.assertEqual(chunks, [b&quot;asdf&quot;, b&quot;qwer&quot;])
        self.assertFalse(response.body)

    def test_chunked_close(self):
        # test case in which chunks spread read-callback processing
        # over several ioloop iterations, but the connection is already closed.
        sock, port = bind_unused_port()
        with closing(sock):
            def write_response(stream, request_data):
                if b&quot;HTTP/1.&quot; not in request_data:
                    self.skipTest(&quot;requires HTTP/1.x&quot;)
                stream.write(b&quot;&quot;&quot;\
HTTP/1.1 200 OK
Transfer-Encoding: chunked

1
1
1
2
0

&quot;&quot;&quot;.replace(b&quot;\n&quot;, b&quot;\r\n&quot;), callback=stream.close)

            def accept_callback(conn, address):
                # fake an HTTP server using chunked encoding where the final chunks
                # and connection close all happen at once
                stream = IOStream(conn, io_loop=self.io_loop)
                stream.read_until(b&quot;\r\n\r\n&quot;,
<A NAME="17"></A>                                  functools.partial(write_response, stream))
            netutil.add_accept_handler(sock, accept_callback, self.io_loop)
            self.http_client.fetch(&quot;http://127.0.0.1:%d/&quot; % port, self.stop)
            resp <FONT color="#3090c7"><A HREF="javascript:ZweiFrames('match25839-1.html#17',3,'match25839-top.html#17',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= self.wait()
            resp.rethrow()
            self.assertEqual(resp.body, b&quot;12&quot;)
            self.io_loop.remove_handler(sock.</B></FONT>fileno())

    def test_streaming_stack_context(self):
        chunks = []
        exc_info = []

        def error_handler(typ, value, tb):
            exc_info.append((typ, value, tb))
            return True

        def streaming_cb(chunk):
            chunks.append(chunk)
            if chunk == b'qwer':
                1 / 0

        with ExceptionStackContext(error_handler):
            self.fetch('/chunk', streaming_callback=streaming_cb)

        self.assertEqual(chunks, [b'asdf', b'qwer'])
        self.assertEqual(1, len(exc_info))
        self.assertIs(exc_info[0][0], ZeroDivisionError)

    def test_basic_auth(self):
        self.assertEqual(self.fetch(&quot;/auth&quot;, auth_username=&quot;Aladdin&quot;,
                                    auth_password=&quot;open sesame&quot;).body,
                         b&quot;Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==&quot;)

    def test_basic_auth_explicit_mode(self):
        self.assertEqual(self.fetch(&quot;/auth&quot;, auth_username=&quot;Aladdin&quot;,
                                    auth_password=&quot;open sesame&quot;,
                                    auth_mode=&quot;basic&quot;).body,
                         b&quot;Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==&quot;)

    def test_unsupported_auth_mode(self):
        # curl and simple clients handle errors a bit differently; the
        # important thing is that they don't fall back to basic auth
        # on an unknown mode.
        with ExpectLog(gen_log, &quot;uncaught exception&quot;, required=False):
            with self.assertRaises((ValueError, HTTPError)):
<A NAME="6"></A>                response = self.fetch(&quot;/auth&quot;, auth_username=&quot;Aladdin&quot;,
                                      auth_password=&quot;open sesame&quot;,
                                      auth_mode=&quot;asdf&quot;)
                response.rethrow()<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match25839-1.html#6',3,'match25839-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>

    def test_follow_redirect(self):
        response = self.fetch(&quot;/countdown/2&quot;, follow_redirects=False)
<A NAME="9"></A>        self.assertEqual(302, response.code)
        self.assertTrue(response.headers[&quot;Location&quot;].endswith(</B></FONT>&quot;/countdown/1&quot;))

<A NAME="2"></A>        response <FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match25839-1.html#9',3,'match25839-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= self.fetch(&quot;/countdown/2&quot;)
        self.assertEqual(200, response.code)
        self.assertTrue(response.effective_url.endswith(&quot;/countdown/0&quot;))
        self.assertEqual(</B></FONT>b&quot;Zero&quot;, response<FONT color="#980517"><A HREF="javascript:ZweiFrames('match25839-1.html#2',3,'match25839-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.body)

    def test_credentials_in_url(self):
        url = self.get_url(&quot;/auth&quot;).replace(&quot;http://&quot;, &quot;http://me:secret@&quot;)
        self.http_client.fetch(url, self.stop)
        response = self.wait()
        self.assertEqual(b&quot;Basic &quot; + base64.</B></FONT>b64encode(b&quot;me:secret&quot;),
                         response.body)
<A NAME="8"></A>
    def test_body_encoding(self):
        unicode_body = u&quot;\xe9&quot;
        byte_body <FONT color="#c58917"><A HREF="javascript:ZweiFrames('match25839-1.html#8',3,'match25839-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= binascii.a2b_hex(b&quot;e9&quot;)

        # unicode string in body gets converted to utf8
        response = self.fetch(&quot;/echopost&quot;, method=&quot;POST&quot;, body=unicode_body,
                              headers={&quot;Content-Type&quot;: &quot;application/blah&quot;})
        self.assertEqual(response.</B></FONT>headers[&quot;Content-Length&quot;], &quot;2&quot;)
        self.assertEqual(response.body, utf8(unicode_body))

        # byte strings pass through directly
        response = self.fetch(&quot;/echopost&quot;, method=&quot;POST&quot;,
                              body=byte_body,
                              headers={&quot;Content-Type&quot;: &quot;application/blah&quot;})
        self.assertEqual(response.headers[&quot;Content-Length&quot;], &quot;1&quot;)
        self.assertEqual(response.body, byte_body)

        # Mixing unicode in headers and byte string bodies shouldn't
        # break anything
<A NAME="5"></A>        response = self.fetch(&quot;/echopost&quot;, method=&quot;POST&quot;, body=byte_body,
                              headers={&quot;Content-Type&quot;: &quot;application/blah&quot;},
                              user_agent=u&quot;foo&quot;)
        self.assertEqual(response.headers<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match25839-1.html#5',3,'match25839-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;Content-Length&quot;], &quot;1&quot;)
        self.assertEqual(response.body, byte_body)

    def test_types(self):
        response = self.fetch(&quot;/hello&quot;)
        self.assertEqual(type(response.body), bytes)
        self.assertEqual(</B></FONT>type(response.headers[&quot;Content-Type&quot;]), str)
        self.assertEqual(type(response.code), int)
        self.assertEqual(type(response.effective_url), str)

    def test_header_callback(self):
        first_line = []
        headers = {}
        chunks = []

        def header_callback(header_line):
            if header_line.startswith('HTTP/1.1 101'):
                # Upgrading to HTTP/2
                pass
            elif header_line.startswith('HTTP/'):
                first_line.append(header_line)
            elif header_line != '\r\n':
                k, v = header_line.split(':', 1)
                headers[k.lower()] = v.strip()

        def streaming_callback(chunk):
            # All header callbacks are run before any streaming callbacks,
            # so the header data is available to process the data as it
            # comes in.
            self.assertEqual(headers['content-type'], 'text/html; charset=UTF-8')
            chunks.append(chunk)

        self.fetch('/chunk', header_callback=header_callback,
                   streaming_callback=streaming_callback)
        self.assertEqual(len(first_line), 1, first_line)
        self.assertRegexpMatches(first_line[0], 'HTTP/[0-9]\\.[0-9] 200.*\r\n')
        self.assertEqual(chunks, [b'asdf', b'qwer'])

    def test_header_callback_stack_context(self):
        exc_info = []

        def error_handler(typ, value, tb):
            exc_info.append((typ, value, tb))
            return True

        def header_callback(header_line):
            if header_line.lower().startswith('content-type:'):
                1 / 0

        with ExceptionStackContext(error_handler):
            self.fetch('/chunk', header_callback=header_callback)
        self.assertEqual(len(exc_info), 1)
        self.assertIs(exc_info[0][0], ZeroDivisionError)

    def test_configure_defaults(self):
        defaults = dict(user_agent='TestDefaultUserAgent', allow_ipv6=False)
        # Construct a new instance of the configured client class
        client = self.http_client.__class__(self.io_loop, force_instance=True,
                                            defaults=defaults)
        try:
            client.fetch(self.get_url('/user_agent'), callback=self.stop)
            response = self.wait()
            self.assertEqual(response.body, b'TestDefaultUserAgent')
        finally:
            client.close()

    def test_header_types(self):
        # Header values may be passed as character or utf8 byte strings,
        # in a plain dictionary or an HTTPHeaders object.
        # Keys must always be the native str type.
        # All combinations should have the same results on the wire.
        for value in [u&quot;MyUserAgent&quot;, b&quot;MyUserAgent&quot;]:
            for container in [dict, HTTPHeaders]:
                headers = container()
                headers['User-Agent'] = value
                resp = self.fetch('/user_agent', headers=headers)
                self.assertEqual(
                    resp.body, b&quot;MyUserAgent&quot;,
                    &quot;response=%r, value=%r, container=%r&quot; %
                    (resp.body, value, container))

    def test_multi_line_headers(self):
        # Multi-line http headers are rare but rfc-allowed
        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
        sock, port = bind_unused_port()
        with closing(sock):
            def write_response(stream, request_data):
                if b&quot;HTTP/1.&quot; not in request_data:
                    self.skipTest(&quot;requires HTTP/1.x&quot;)
                stream.write(b&quot;&quot;&quot;\
HTTP/1.1 200 OK
X-XSS-Protection: 1;
\tmode=block

&quot;&quot;&quot;.replace(b&quot;\n&quot;, b&quot;\r\n&quot;), callback=stream.close)

            def accept_callback(conn, address):
                stream = IOStream(conn, io_loop=self.io_loop)
                stream.read_until(b&quot;\r\n\r\n&quot;,
                                  functools.partial(write_response, stream))
            netutil.add_accept_handler(sock, accept_callback, self.io_loop)
            self.http_client.fetch(&quot;http://127.0.0.1:%d/&quot; % port, self.stop)
<A NAME="16"></A>            resp = self.wait()
            resp.rethrow()
            self.assertEqual(resp.headers['X-XSS-Protection'], &quot;1; mode=block&quot;)
            self.io_loop.remove_handler(sock.fileno()<FONT color="#2981b2"><A HREF="javascript:ZweiFrames('match25839-1.html#16',3,'match25839-top.html#16',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>)

    def test_304_with_content_length(self):
        # According to the spec 304 responses SHOULD NOT include
        # Content-Length or other entity headers, but some servers do it
        # anyway.
        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5
        response = self.fetch('/304_with_content_length')
        self.assertEqual(response.code, 304)
        self.assertEqual(response.headers[</B></FONT>'Content-Length'], '42')

    def test_final_callback_stack_context(self):
        # The final callback should be run outside of the httpclient's
        # stack_context.  We want to ensure that there is not stack_context
        # between the user's callback and the IOLoop, so monkey-patch
        # IOLoop.handle_callback_exception and disable the test harness's
        # context with a NullContext.
        # Note that this does not apply to secondary callbacks (header
        # and streaming_callback), as errors there must be seen as errors
        # by the http client so it can clean up the connection.
        exc_info = []

        def handle_callback_exception(callback):
            exc_info.append(sys.exc_info())
            self.stop()
        self.io_loop.handle_callback_exception = handle_callback_exception
        with NullContext():
            self.http_client.fetch(self.get_url('/hello'),
                                   lambda response: 1 / 0)
        self.wait()
        self.assertEqual(exc_info[0][0], ZeroDivisionError)
<A NAME="4"></A>
    @gen_test
    def test_future_interface(self):
        response = yield self.http_client.fetch(self<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match25839-1.html#4',3,'match25839-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.get_url('/hello'))
        self.assertEqual(response.body, b'Hello world!')

    @gen_test
    def test_future_http_error(self):
        with self.assertRaises(HTTPError) as context:
            yield self.</B></FONT>http_client.fetch(self.get_url('/notfound'))
        self.assertEqual(context.exception.code, 404)
        self.assertEqual(context.exception.response.code, 404)

    @gen_test
    def test_future_http_error_no_raise(self):
        response = yield self.http_client.fetch(self.get_url('/notfound'), raise_error=False)
        self.assertEqual(response.code, 404)

    @gen_test
    def test_reuse_request_from_response(self):
        # The response.request attribute should be an HTTPRequest, not
        # a _RequestProxy.
        # This test uses self.http_client.fetch because self.fetch calls
        # self.get_url on the input unconditionally.
        url = self.get_url('/hello')
        response = yield self.http_client.fetch(url)
        self.assertEqual(response.request.url, url)
        self.assertTrue(isinstance(response.request, HTTPRequest))
        response2 = yield self.http_client.fetch(response.request)
<A NAME="0"></A>        self.assertEqual(response2.body, b'Hello world!')

    def test_all_methods(self):
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match25839-1.html#0',3,'match25839-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for method in ['GET', 'DELETE', 'OPTIONS']:
            response = self.fetch('/all_methods', method=method)
            self.assertEqual(response.body, utf8(method))
<A NAME="7"></A>        for method in ['POST', 'PUT', 'PATCH']:
            response = self.fetch('/all_methods', method=method, body=b'')
            self.assertEqual(response.body, utf8(</B></FONT>method))
        response = self.fetch('/all_methods', method<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match25839-1.html#7',3,'match25839-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>='HEAD')
        self.assertEqual(response.body, b'')
        response = self.fetch('/all_methods', method='OTHER',
                              allow_nonstandard_methods=True)
        self.assertEqual(response.body, b'OTHER')

    def</B></FONT> test_body_sanity_checks(self):
        # These methods require a body.
        for method in ('POST', 'PUT', 'PATCH'):
            with self.assertRaises(ValueError) as context:
                resp = self.fetch('/all_methods', method=method)
                resp.rethrow()
            self.assertIn('must not be None', str(context.exception))

            resp = self.fetch('/all_methods', method=method,
                              allow_nonstandard_methods=True)
            self.assertEqual(resp.code, 200)

        # These methods don't allow a body.
        for method in ('GET', 'DELETE', 'OPTIONS'):
            with self.assertRaises(ValueError) as context:
                resp = self.fetch('/all_methods', method=method, body=b'asdf')
                resp.rethrow()
            self.assertIn('must be None', str(context.exception))

            # In most cases this can be overridden, but curl_httpclient
            # does not allow body with a GET at all.
            if method != 'GET':
                resp = self.fetch('/all_methods', method=method, body=b'asdf',
                                  allow_nonstandard_methods=True)
                resp.rethrow()
                self.assertEqual(resp.code, 200)

    # This test causes odd failures with the combination of
    # curl_httpclient (at least with the version of libcurl available
    # on ubuntu 12.04), TwistedIOLoop, and epoll.  For POST (but not PUT),
    # curl decides the response came back too soon and closes the connection
    # to start again.  It does this *before* telling the socket callback to
    # unregister the FD.  Some IOLoop implementations have special kernel
    # integration to discover this immediately.  Tornado's IOLoops
    # ignore errors on remove_handler to accommodate this behavior, but
    # Twisted's reactor does not.  The removeReader call fails and so
    # do all future removeAll calls (which our tests do at cleanup).
    #
    # def test_post_307(self):
    #    response = self.fetch(&quot;/redirect?status=307&amp;url=/post&quot;,
    #                          method=&quot;POST&quot;, body=b&quot;arg1=foo&amp;arg2=bar&quot;)
    #    self.assertEqual(response.body, b&quot;Post arg1: foo, arg2: bar&quot;)
<A NAME="3"></A>
    def test_put_307(self):
        response = self.fetch(&quot;/redirect?status=307&amp;url=/put&quot;,
                              method=&quot;PUT&quot;, body<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match25839-1.html#3',3,'match25839-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=b&quot;hello&quot;)
        response.rethrow()
        self.assertEqual(response.body, b&quot;Put body: hello&quot;)

    def test_non_ascii_header(self):
        # Non-ascii headers are sent as latin1.
        response = self.fetch(&quot;/set_header?k=foo&amp;v=%E9&quot;)
        response.rethrow()
        self.assertEqual(response.</B></FONT>headers[&quot;Foo&quot;], native_str(u&quot;\u00e9&quot;))


class RequestProxyTest(unittest.TestCase):
    def test_request_set(self):
        proxy = _RequestProxy(HTTPRequest('http://example.com/',
                                          user_agent='foo'),
                              dict())
        self.assertEqual(proxy.user_agent, 'foo')

    def test_default_set(self):
        proxy = _RequestProxy(HTTPRequest('http://example.com/'),
                              dict(network_interface='foo'))
        self.assertEqual(proxy.network_interface, 'foo')

    def test_both_set(self):
        proxy = _RequestProxy(HTTPRequest('http://example.com/',
                                          proxy_host='foo'),
                              dict(proxy_host='bar'))
        self.assertEqual(proxy.proxy_host, 'foo')

    def test_neither_set(self):
        proxy = _RequestProxy(HTTPRequest('http://example.com/'),
                              dict())
        self.assertIs(proxy.auth_username, None)

    def test_bad_attribute(self):
        proxy = _RequestProxy(HTTPRequest('http://example.com/'),
                              dict())
        with self.assertRaises(AttributeError):
            proxy.foo

    def test_defaults_none(self):
        proxy = _RequestProxy(HTTPRequest('http://example.com/'), None)
        self.assertIs(proxy.auth_username, None)


class HTTPResponseTestCase(unittest.TestCase):
    def test_str(self):
        response = HTTPResponse(HTTPRequest('http://example.com'),
                                200, headers={}, buffer=BytesIO())
        s = str(response)
        self.assertTrue(s.startswith('HTTPResponse('))
        self.assertIn('code=200', s)


class SyncHTTPClientTest(unittest.TestCase):
    def setUp(self):
        if IOLoop.configured_class().__name__ in ('TwistedIOLoop',
                                                  'AsyncIOMainLoop'):
            # TwistedIOLoop only supports the global reactor, so we can't have
            # separate IOLoops for client and server threads.
            # AsyncIOMainLoop doesn't work with the default policy
            # (although it could with some tweaks to this test and a
            # policy that created loops for non-main threads).
            raise unittest.SkipTest(
                'Sync HTTPClient not compatible with TwistedIOLoop or '
                'AsyncIOMainLoop')
        self.server_ioloop = IOLoop()

        sock, self.port = bind_unused_port()
        app = Application([('/', HelloWorldHandler)])
        self.server = HTTPServer(app, io_loop=self.server_ioloop)
        self.server.add_socket(sock)

        self.server_thread = threading.Thread(target=self.server_ioloop.start)
        self.server_thread.start()

        self.http_client = HTTPClient()

    def tearDown(self):
        def stop_server():
            self.server.stop()
            # Delay the shutdown of the IOLoop by one iteration because
            # the server may still have some cleanup work left when
            # the client finishes with the response (this is noticable
<A NAME="15"></A>            # with http/2, which leaves a Future with an unexamined
            # StreamClosedError on the loop).
            self.server_ioloop.add_callback(self.server_ioloop.stop)
        self<FONT color="#f52887"><A HREF="javascript:ZweiFrames('match25839-1.html#15',3,'match25839-top.html#15',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.server_ioloop.add_callback(stop_server)
        self.server_thread.join()
        self.http_client.close()
        self.server_ioloop.close(</B></FONT>all_fds=True)

    def get_url(self, path):
        return 'http://127.0.0.1:%d%s' % (self.port, path)

    def test_sync_client(self):
        response = self.http_client.fetch(self.get_url('/'))
        self.assertEqual(b'Hello world!', response.body)

    def test_sync_client_error(self):
        # Synchronous HTTPClient raises errors directly; no need for
        # response.rethrow()
        with self.assertRaises(HTTPError) as assertion:
            self.http_client.fetch(self.get_url('/notfound'))
        self.assertEqual(assertion.exception.code, 404)


class HTTPRequestTestCase(unittest.TestCase):
    def test_headers(self):
        request = HTTPRequest('http://example.com', headers={'foo': 'bar'})
        self.assertEqual(request.headers, {'foo': 'bar'})

    def test_headers_setter(self):
        request = HTTPRequest('http://example.com')
        request.headers = {'bar': 'baz'}
        self.assertEqual(request.headers, {'bar': 'baz'})

    def test_null_headers_setter(self):
        request = HTTPRequest('http://example.com')
        request.headers = None
        self.assertEqual(request.headers, {})

    def test_body(self):
        request = HTTPRequest('http://example.com', body='foo')
        self.assertEqual(request.body, utf8('foo'))

    def test_body_setter(self):
        request = HTTPRequest('http://example.com')
        request.body = 'foo'
        self.assertEqual(request.body, utf8('foo'))

    def test_if_modified_since(self):
        http_date = datetime.datetime.utcnow()
        request = HTTPRequest('http://example.com', if_modified_since=http_date)
        self.assertEqual(request.headers,
                         {'If-Modified-Since': format_timestamp(http_date)})


<A NAME="14"></A>class HTTPErrorTestCase(unittest.TestCase):
    def test_copy(self):
        e = HTTPError(403)
        e2 <FONT color="#842dce"><A HREF="javascript:ZweiFrames('match25839-1.html#14',3,'match25839-top.html#14',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= copy.copy(e)
        self.assertIsNot(e, e2)
        self.assertEqual(e.code, e2.code)

    def test_plain_error(self):
        e =</B></FONT> HTTPError(403)
        self.assertEqual(str(e), &quot;HTTP 403: Forbidden&quot;)
        self.assertEqual(repr(e), &quot;HTTP 403: Forbidden&quot;)

    def test_error_with_response(self):
        resp = HTTPResponse(HTTPRequest('http://example.com/'), 403)
        with self.assertRaises(HTTPError) as cm:
            resp.rethrow()
        e = cm.exception
        self.assertEqual(str(e), &quot;HTTP 403: Forbidden&quot;)
        self.assertEqual(repr(e), &quot;HTTP 403: Forbidden&quot;)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>web_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="1"></A># pylint: skip-file
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#1',2,'match25839-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>from __future__ import absolute_import, division, print_function
from salt.ext.tornado.concurrent import Future
from salt.ext.tornado import gen
from salt.ext.tornado.escape import json_decode, utf8, to_unicode, recursive_unicode, native_str, to_basestring
from salt.ext.tornado.httputil import format_timestamp
from salt.ext.tornado.ioloop import IOLoop
from salt.ext.tornado.iostream import IOStream
from salt.ext.tornado import locale
from salt.ext.tornado.log import app_log, gen_log
from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
from salt.ext.tornado.template import DictLoader
from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncTestCase, ExpectLog, gen_test
from salt.ext.tornado.test.util import unittest, skipBefore35, exec_test
from salt.ext.tornado.util import ObjectDict, unicode_type, timedelta_to_seconds, PY3
from salt.ext.tornado.web import RequestHandler, authenticated, Application, asynchronous, url, HTTPError, StaticFileHandler, _create_signature_v1, create_signed_value, decode_signed_value, ErrorHandler, UIModule, MissingArgumentError, stream_request_body, Finish, removeslash, addslash, RedirectHandler as WebRedirectHandler, get_signature_key_version, GZipContentEncoding

import binascii
import contextlib
import copy
import datetime
import email.utils
import gzip
from io import BytesIO
import</B></FONT> itertools
import logging
import os
import re
import socket

if PY3:
    import urllib.parse as urllib_parse  # py3
else:
    import urllib as urllib_parse  # py2

wsgi_safe_tests = []


def relpath(*a):
    return os.path.join(os.path.dirname(__file__), *a)


def wsgi_safe(cls):
    wsgi_safe_tests.append(cls)
    return cls


class WebTestCase(AsyncHTTPTestCase):
    &quot;&quot;&quot;Base class for web tests that also supports WSGI mode.

    Override get_handlers and get_app_kwargs instead of get_app.
    Append to wsgi_safe to have it run in wsgi_test as well.
    &quot;&quot;&quot;
    def get_app(self):
        self.app = Application(self.get_handlers(), **self.get_app_kwargs())
        return self.app

    def get_handlers(self):
        raise NotImplementedError()

    def get_app_kwargs(self):
        return {}


class SimpleHandlerTestCase(WebTestCase):
    &quot;&quot;&quot;Simplified base class for tests that work with a single handler class.

    To use, define a nested class named ``Handler``.
    &quot;&quot;&quot;
    def get_handlers(self):
        return [('/', self.Handler)]


class HelloHandler(RequestHandler):
    def get(self):
        self.write('hello')


class CookieTestRequestHandler(RequestHandler):
    # stub out enough methods to make the secure_cookie functions work
    def __init__(self, cookie_secret='0123456789', key_version=None):
        # don't call super.__init__
        self._cookies = {}
        if key_version is None:
            self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret))
        else:
            self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret,
                                                        key_version=key_version))

    def get_cookie(self, name):
        return self._cookies.get(name)

    def set_cookie(self, name, value, expires_days=None):
        self._cookies[name] = value


# See SignedValueTest below for more.
class SecureCookieV1Test(unittest.TestCase):
    def test_round_trip(self):
        handler = CookieTestRequestHandler()
        handler.set_secure_cookie('foo', b'bar', version=1)
        self.assertEqual(handler.get_secure_cookie('foo', min_version=1),
                         b'bar')

    def test_cookie_tampering_future_timestamp(self):
        handler = CookieTestRequestHandler()
        # this string base64-encodes to '12345678'
        handler.set_secure_cookie('foo', binascii.a2b_hex(b'd76df8e7aefc'),
                                  version=1)
        cookie = handler._cookies['foo']
        match = re.match(br'12345678\|([0-9]+)\|([0-9a-f]+)', cookie)
        self.assertTrue(match)
        timestamp = match.group(1)
        sig = match.group(2)
        self.assertEqual(
            _create_signature_v1(handler.application.settings[&quot;cookie_secret&quot;],
                                 'foo', '12345678', timestamp),
            sig)
        # shifting digits from payload to timestamp doesn't alter signature
        # (this is not desirable behavior, just confirming that that's how it
        # works)
        self.assertEqual(
            _create_signature_v1(handler.application.settings[&quot;cookie_secret&quot;],
                                 'foo', '1234', b'5678' + timestamp),
            sig)
        # tamper with the cookie
        handler._cookies['foo'] = utf8('1234|5678%s|%s' % (
            to_basestring(timestamp), to_basestring(sig)))
        # it gets rejected
        with ExpectLog(gen_log, &quot;Cookie timestamp in future&quot;):
            self.assertTrue(
                handler.get_secure_cookie('foo', min_version=1) is None)

    def test_arbitrary_bytes(self):
        # Secure cookies accept arbitrary data (which is base64 encoded).
        # Note that normal cookies accept only a subset of ascii.
        handler = CookieTestRequestHandler()
        handler.set_secure_cookie('foo', b'\xe9', version=1)
        self.assertEqual(handler.get_secure_cookie('foo', min_version=1), b'\xe9')


# See SignedValueTest below for more.
class SecureCookieV2Test(unittest.TestCase):
    KEY_VERSIONS = {
        0: 'ajklasdf0ojaisdf',
        1: 'aslkjasaolwkjsdf'
    }

    def test_round_trip(self):
        handler = CookieTestRequestHandler()
        handler.set_secure_cookie('foo', b'bar', version=2)
        self.assertEqual(handler.get_secure_cookie('foo', min_version=2), b'bar')

    def test_key_version_roundtrip(self):
        handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                           key_version=0)
        handler.set_secure_cookie('foo', b'bar')
        self.assertEqual(handler.get_secure_cookie('foo'), b'bar')

    def test_key_version_roundtrip_differing_version(self):
        handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                           key_version=1)
        handler.set_secure_cookie('foo', b'bar')
        self.assertEqual(handler.get_secure_cookie('foo'), b'bar')

    def test_key_version_increment_version(self):
        handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                           key_version=0)
        handler.set_secure_cookie('foo', b'bar')
        new_handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                               key_version=1)
        new_handler._cookies = handler._cookies
        self.assertEqual(new_handler.get_secure_cookie('foo'), b'bar')

    def test_key_version_invalidate_version(self):
        handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                           key_version=0)
        handler.set_secure_cookie('foo', b'bar')
        new_key_versions = self.KEY_VERSIONS.copy()
        new_key_versions.pop(0)
        new_handler = CookieTestRequestHandler(cookie_secret=new_key_versions,
                                               key_version=1)
        new_handler._cookies = handler._cookies
        self.assertEqual(new_handler.get_secure_cookie('foo'), None)


class CookieTest(WebTestCase):
    def get_handlers(self):
        class SetCookieHandler(RequestHandler):
<A NAME="13"></A>            def get(self):
                # Try setting cookies with different argument types
                # to ensure that everything gets encoded correctly
                self<FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#13',2,'match25839-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.set_cookie(&quot;str&quot;, &quot;asdf&quot;)
                self.set_cookie(&quot;unicode&quot;, u&quot;qwer&quot;)
                self.set_cookie(&quot;bytes&quot;, b&quot;zxcv&quot;)

        class GetCookieHandler(RequestHandler):
            def get(self):
                self.write(self.</B></FONT>get_cookie(&quot;foo&quot;, &quot;default&quot;))

        class SetCookieDomainHandler(RequestHandler):
            def get(self):
                # unicode domain and path arguments shouldn't break things
                # either (see bug #285)
                self.set_cookie(&quot;unicode_args&quot;, &quot;blah&quot;, domain=u&quot;foo.com&quot;,
                                path=u&quot;/foo&quot;)

        class SetCookieSpecialCharHandler(RequestHandler):
            def get(self):
                self.set_cookie(&quot;equals&quot;, &quot;a=b&quot;)
                self.set_cookie(&quot;semicolon&quot;, &quot;a;b&quot;)
                self.set_cookie(&quot;quote&quot;, 'a&quot;b')

        class SetCookieOverwriteHandler(RequestHandler):
            def get(self):
                self.set_cookie(&quot;a&quot;, &quot;b&quot;, domain=&quot;example.com&quot;)
                self.set_cookie(&quot;c&quot;, &quot;d&quot;, domain=&quot;example.com&quot;)
                # A second call with the same name clobbers the first.
                # Attributes from the first call are not carried over.
                self.set_cookie(&quot;a&quot;, &quot;e&quot;)

        class SetCookieMaxAgeHandler(RequestHandler):
            def get(self):
                self.set_cookie(&quot;foo&quot;, &quot;bar&quot;, max_age=10)

        class SetCookieExpiresDaysHandler(RequestHandler):
            def get(self):
                self.set_cookie(&quot;foo&quot;, &quot;bar&quot;, expires_days=10)

        class SetCookieFalsyFlags(RequestHandler):
            def get(self):
                self.set_cookie(&quot;a&quot;, &quot;1&quot;, secure=True)
                self.set_cookie(&quot;b&quot;, &quot;1&quot;, secure=False)
                self.set_cookie(&quot;c&quot;, &quot;1&quot;, httponly=True)
                self.set_cookie(&quot;d&quot;, &quot;1&quot;, httponly=False)

        return [(&quot;/set&quot;, SetCookieHandler),
                (&quot;/get&quot;, GetCookieHandler),
                (&quot;/set_domain&quot;, SetCookieDomainHandler),
                (&quot;/special_char&quot;, SetCookieSpecialCharHandler),
                (&quot;/set_overwrite&quot;, SetCookieOverwriteHandler),
                (&quot;/set_max_age&quot;, SetCookieMaxAgeHandler),
                (&quot;/set_expires_days&quot;, SetCookieExpiresDaysHandler),
                (&quot;/set_falsy_flags&quot;, SetCookieFalsyFlags)
                ]

    def test_set_cookie(self):
        response = self.fetch(&quot;/set&quot;)
        self.assertEqual(sorted(response.headers.get_list(&quot;Set-Cookie&quot;)),
                         [&quot;bytes=zxcv; Path=/&quot;,
                          &quot;str=asdf; Path=/&quot;,
                          &quot;unicode=qwer; Path=/&quot;,
                          ])

    def test_get_cookie(self):
        response = self.fetch(&quot;/get&quot;, headers={&quot;Cookie&quot;: &quot;foo=bar&quot;})
        self.assertEqual(response.body, b&quot;bar&quot;)

        response = self.fetch(&quot;/get&quot;, headers={&quot;Cookie&quot;: 'foo=&quot;bar&quot;'})
        self.assertEqual(response.body, b&quot;bar&quot;)

        response = self.fetch(&quot;/get&quot;, headers={&quot;Cookie&quot;: &quot;/=exception;&quot;})
        self.assertEqual(response.body, b&quot;default&quot;)

    def test_set_cookie_domain(self):
        response = self.fetch(&quot;/set_domain&quot;)
        self.assertEqual(response.headers.get_list(&quot;Set-Cookie&quot;),
                         [&quot;unicode_args=blah; Domain=foo.com; Path=/foo&quot;])

    def test_cookie_special_char(self):
        response = self.fetch(&quot;/special_char&quot;)
        headers = sorted(response.headers.get_list(&quot;Set-Cookie&quot;))
        self.assertEqual(len(headers), 3)
        self.assertEqual(headers[0], 'equals=&quot;a=b&quot;; Path=/')
        self.assertEqual(headers[1], 'quote=&quot;a\\&quot;b&quot;; Path=/')
        # python 2.7 octal-escapes the semicolon; older versions leave it alone
        self.assertTrue(headers[2] in ('semicolon=&quot;a;b&quot;; Path=/',
                                       'semicolon=&quot;a\\073b&quot;; Path=/'),
                        headers[2])

        data = [('foo=a=b', 'a=b'),
                ('foo=&quot;a=b&quot;', 'a=b'),
                ('foo=&quot;a;b&quot;', '&quot;a'),  # even quoted, &quot;;&quot; is a delimiter
                ('foo=a\\073b', 'a\\073b'),  # escapes only decoded in quotes
                ('foo=&quot;a\\073b&quot;', 'a;b'),
                ('foo=&quot;a\\&quot;b&quot;', 'a&quot;b'),
                ]
        for header, expected in data:
            logging.debug(&quot;trying %r&quot;, header)
            response = self.fetch(&quot;/get&quot;, headers={&quot;Cookie&quot;: header})
            self.assertEqual(response.body, utf8(expected))

    def test_set_cookie_overwrite(self):
        response = self.fetch(&quot;/set_overwrite&quot;)
        headers = response.headers.get_list(&quot;Set-Cookie&quot;)
        self.assertEqual(sorted(headers),
                         [&quot;a=e; Path=/&quot;, &quot;c=d; Domain=example.com; Path=/&quot;])

    def test_set_cookie_max_age(self):
        response = self.fetch(&quot;/set_max_age&quot;)
        headers = response.headers.get_list(&quot;Set-Cookie&quot;)
        self.assertEqual(sorted(headers),
                         [&quot;foo=bar; Max-Age=10; Path=/&quot;])

    def test_set_cookie_expires_days(self):
        response = self.fetch(&quot;/set_expires_days&quot;)
        header = response.headers.get(&quot;Set-Cookie&quot;)
        match = re.match(&quot;foo=bar; expires=(?P&lt;expires&gt;.+); Path=/&quot;, header)
        self.assertIsNotNone(match)

        expires = datetime.datetime.utcnow() + datetime.timedelta(days=10)
        header_expires = datetime.datetime(
            *email.utils.parsedate(match.groupdict()[&quot;expires&quot;])[:6])
        self.assertTrue(abs(timedelta_to_seconds(expires - header_expires)) &lt; 10)

    def test_set_cookie_false_flags(self):
        response = self.fetch(&quot;/set_falsy_flags&quot;)
        headers = sorted(response.headers.get_list(&quot;Set-Cookie&quot;))
        # The secure and httponly headers are capitalized in py35 and
        # lowercase in older versions.
        self.assertEqual(headers[0].lower(), 'a=1; path=/; secure')
        self.assertEqual(headers[1].lower(), 'b=1; path=/')
        self.assertEqual(headers[2].lower(), 'c=1; httponly; path=/')
        self.assertEqual(headers[3].lower(), 'd=1; path=/')


class AuthRedirectRequestHandler(RequestHandler):
    def initialize(self, login_url):
        self.login_url = login_url

    def get_login_url(self):
        return self.login_url

    @authenticated
    def get(self):
        # we'll never actually get here because the test doesn't follow redirects
        self.send_error(500)


class AuthRedirectTest(WebTestCase):
    def get_handlers(self):
        return [('/relative', AuthRedirectRequestHandler,
                 dict(login_url='/login')),
                ('/absolute', AuthRedirectRequestHandler,
                 dict(login_url='http://example.com/login'))]

    def test_relative_auth_redirect(self):
        self.http_client.fetch(self.get_url('/relative'), self.stop,
                               follow_redirects=False)
        response = self.wait()
        self.assertEqual(response.code, 302)
        self.assertEqual(response.headers['Location'], '/login?next=%2Frelative')

    def test_absolute_auth_redirect(self):
        self.http_client.fetch(self.get_url('/absolute'), self.stop,
                               follow_redirects=False)
        response = self.wait()
        self.assertEqual(response.code, 302)
        self.assertTrue(re.match(
            'http://example.com/login\?next=http%3A%2F%2F127.0.0.1%3A[0-9]+%2Fabsolute',
            response.headers['Location']), response.headers['Location'])


class ConnectionCloseHandler(RequestHandler):
    def initialize(self, test):
        self.test = test

    @asynchronous
    def get(self):
        self.test.on_handler_waiting()

    def on_connection_close(self):
        self.test.on_connection_close()


class ConnectionCloseTest(WebTestCase):
    def get_handlers(self):
        return [('/', ConnectionCloseHandler, dict(test=self))]

    def test_connection_close(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        s.connect((&quot;127.0.0.1&quot;, self.get_http_port()))
        self.stream = IOStream(s, io_loop=self.io_loop)
        self.stream.write(b&quot;GET / HTTP/1.0\r\n\r\n&quot;)
        self.wait()

    def on_handler_waiting(self):
        logging.debug('handler waiting')
        self.stream.close()

    def on_connection_close(self):
        logging.debug('connection closed')
        self.stop()


class EchoHandler(RequestHandler):
    def get(self, *path_args):
        # Type checks: web.py interfaces convert argument values to
        # unicode strings (by default, but see also decode_argument).
        # In httpserver.py (i.e. self.request.arguments), they're left
        # as bytes.  Keys are always native strings.
        for key in self.request.arguments:
            if type(key) != str:
                raise Exception(&quot;incorrect type for key: %r&quot; % type(key))
            for value in self.request.arguments[key]:
                if type(value) != bytes:
                    raise Exception(&quot;incorrect type for value: %r&quot; %
                                    type(value))
            for value in self.get_arguments(key):
                if type(value) != unicode_type:
                    raise Exception(&quot;incorrect type for value: %r&quot; %
                                    type(value))
        for arg in path_args:
            if type(arg) != unicode_type:
                raise Exception(&quot;incorrect type for path arg: %r&quot; % type(arg))
        self.write(dict(path=self.request.path,
                        path_args=path_args,
                        args=recursive_unicode(self.request.arguments)))


class RequestEncodingTest(WebTestCase):
    def get_handlers(self):
        return [(&quot;/group/(.*)&quot;, EchoHandler),
                (&quot;/slashes/([^/]*)/([^/]*)&quot;, EchoHandler),
                ]

    def fetch_json(self, path):
        return json_decode(self.fetch(path).body)

    def test_group_question_mark(self):
        # Ensure that url-encoded question marks are handled properly
        self.assertEqual(self.fetch_json('/group/%3F'),
                         dict(path='/group/%3F', path_args=['?'], args={}))
        self.assertEqual(self.fetch_json('/group/%3F?%3F=%3F'),
                         dict(path='/group/%3F', path_args=['?'], args={'?': ['?']}))

    def test_group_encoding(self):
        # Path components and query arguments should be decoded the same way
        self.assertEqual(self.fetch_json('/group/%C3%A9?arg=%C3%A9'),
                         {u&quot;path&quot;: u&quot;/group/%C3%A9&quot;,
                          u&quot;path_args&quot;: [u&quot;\u00e9&quot;],
                          u&quot;args&quot;: {u&quot;arg&quot;: [u&quot;\u00e9&quot;]}})

    def test_slashes(self):
        # Slashes may be escaped to appear as a single &quot;directory&quot; in the path,
        # but they are then unescaped when passed to the get() method.
        self.assertEqual(self.fetch_json('/slashes/foo/bar'),
                         dict(path=&quot;/slashes/foo/bar&quot;,
                              path_args=[&quot;foo&quot;, &quot;bar&quot;],
                              args={}))
        self.assertEqual(self.fetch_json('/slashes/a%2Fb/c%2Fd'),
                         dict(path=&quot;/slashes/a%2Fb/c%2Fd&quot;,
                              path_args=[&quot;a/b&quot;, &quot;c/d&quot;],
                              args={}))

    def test_error(self):
        # Percent signs (encoded as %25) should not mess up printf-style
        # messages in logs
        with ExpectLog(gen_log, &quot;.*Invalid unicode&quot;):
            self.fetch(&quot;/group/?arg=%25%e9&quot;)


class TypeCheckHandler(RequestHandler):
    def prepare(self):
        self.errors = {}

        self.check_type('status', self.get_status(), int)

        # get_argument is an exception from the general rule of using
        # type str for non-body data mainly for historical reasons.
        self.check_type('argument', self.get_argument('foo'), unicode_type)
        self.check_type('cookie_key', list(self.cookies.keys())[0], str)
        self.check_type('cookie_value', list(self.cookies.values())[0].value, str)

        # Secure cookies return bytes because they can contain arbitrary
        # data, but regular cookies are native strings.
        if list(self.cookies.keys()) != ['asdf']:
            raise Exception(&quot;unexpected values for cookie keys: %r&quot; %
                            self.cookies.keys())
        self.check_type('get_secure_cookie', self.get_secure_cookie('asdf'), bytes)
        self.check_type('get_cookie', self.get_cookie('asdf'), str)

        self.check_type('xsrf_token', self.xsrf_token, bytes)
        self.check_type('xsrf_form_html', self.xsrf_form_html(), str)

        self.check_type('reverse_url', self.reverse_url('typecheck', 'foo'), str)

        self.check_type('request_summary', self._request_summary(), str)

    def get(self, path_component):
        # path_component uses type unicode instead of str for consistency
        # with get_argument()
        self.check_type('path_component', path_component, unicode_type)
        self.write(self.errors)

    def post(self, path_component):
        self.check_type('path_component', path_component, unicode_type)
        self.write(self.errors)

    def check_type(self, name, obj, expected_type):
        actual_type = type(obj)
        if expected_type != actual_type:
            self.errors[name] = &quot;expected %s, got %s&quot; % (expected_type,
                                                         actual_type)


class DecodeArgHandler(RequestHandler):
    def decode_argument(self, value, name=None):
        if type(value) != bytes:
            raise Exception(&quot;unexpected type for value: %r&quot; % type(value))
        # use self.request.arguments directly to avoid recursion
        if 'encoding' in self.request.arguments:
            return value.decode(to_unicode(self.request.arguments['encoding'][0]))
        else:
            return value

    def get(self, arg):
        def describe(s):
            if type(s) == bytes:
                return [&quot;bytes&quot;, native_str(binascii.b2a_hex(s))]
            elif type(s) == unicode_type:
                return [&quot;unicode&quot;, s]
            raise Exception(&quot;unknown type&quot;)
        self.write({'path': describe(arg),
                    'query': describe(self.get_argument(&quot;foo&quot;)),
                    })


class LinkifyHandler(RequestHandler):
    def get(self):
        self.render(&quot;linkify.html&quot;, message=&quot;http://example.com&quot;)


class UIModuleResourceHandler(RequestHandler):
    def get(self):
        self.render(&quot;page.html&quot;, entries=[1, 2])


class OptionalPathHandler(RequestHandler):
    def get(self, path):
        self.write({&quot;path&quot;: path})


class FlowControlHandler(RequestHandler):
    # These writes are too small to demonstrate real flow control,
    # but at least it shows that the callbacks get run.
    @asynchronous
    def get(self):
        self.write(&quot;1&quot;)
        self.flush(callback=self.step2)

    def step2(self):
        self.write(&quot;2&quot;)
<A NAME="12"></A>        self.flush(callback=self.step3)

    def step3(self):
        self<FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#12',2,'match25839-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.write(&quot;3&quot;)
        self.finish()


class MultiHeaderHandler(RequestHandler):
    def get(self):
        self.set_header(&quot;x-overwrite&quot;, &quot;1&quot;)
        self.set_header(&quot;X-Overwrite&quot;, 2)
        self.</B></FONT>add_header(&quot;x-multi&quot;, 3)
        self.add_header(&quot;X-Multi&quot;, &quot;4&quot;)


class RedirectHandler(RequestHandler):
    def get(self):
        if self.get_argument('permanent', None) is not None:
            self.redirect('/', permanent=int(self.get_argument('permanent')))
        elif self.get_argument('status', None) is not None:
            self.redirect('/', status=int(self.get_argument('status')))
        else:
            raise Exception(&quot;didn't get permanent or status arguments&quot;)


class EmptyFlushCallbackHandler(RequestHandler):
    @asynchronous
    @gen.engine
    def get(self):
        # Ensure that the flush callback is run whether or not there
        # was any output.  The gen.Task and direct yield forms are
        # equivalent.
<A NAME="11"></A>        yield gen.Task(self.flush)  # &quot;empty&quot; flush, but writes headers
        yield gen.Task(self.flush)  # empty flush
        self.write(&quot;o&quot;)
        yield self<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#11',2,'match25839-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.flush()  # flushes the &quot;o&quot;
        yield self.flush()  # empty flush
        self.finish(&quot;k&quot;)


class HeaderInjectionHandler(RequestHandler):
    def</B></FONT> get(self):
        try:
            self.set_header(&quot;X-Foo&quot;, &quot;foo\r\nX-Bar: baz&quot;)
            raise Exception(&quot;Didn't get expected exception&quot;)
        except ValueError as e:
            if &quot;Unsafe header value&quot; in str(e):
                self.finish(b&quot;ok&quot;)
            else:
                raise


class GetArgumentHandler(RequestHandler):
    def prepare(self):
        if self.get_argument('source', None) == 'query':
            method = self.get_query_argument
        elif self.get_argument('source', None) == 'body':
            method = self.get_body_argument
        else:
            method = self.get_argument
        self.finish(method(&quot;foo&quot;, &quot;default&quot;))


class GetArgumentsHandler(RequestHandler):
    def prepare(self):
        self.finish(dict(default=self.get_arguments(&quot;foo&quot;),
                         query=self.get_query_arguments(&quot;foo&quot;),
                         body=self.get_body_arguments(&quot;foo&quot;)))


# This test is shared with wsgi_test.py
@wsgi_safe
class WSGISafeWebTest(WebTestCase):
    COOKIE_SECRET = &quot;WebTest.COOKIE_SECRET&quot;

    def get_app_kwargs(self):
        loader = DictLoader({
            &quot;linkify.html&quot;: &quot;{% module linkify(message) %}&quot;,
            &quot;page.html&quot;: &quot;&quot;&quot;\
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
{% for e in entries %}
{% module Template(&quot;entry.html&quot;, entry=e) %}
{% end %}
&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;,
            &quot;entry.html&quot;: &quot;&quot;&quot;\
{{ set_resources(embedded_css=&quot;.entry { margin-bottom: 1em; }&quot;, embedded_javascript=&quot;js_embed()&quot;, css_files=[&quot;/base.css&quot;, &quot;/foo.css&quot;], javascript_files=&quot;/common.js&quot;, html_head=&quot;&lt;meta&gt;&quot;, html_body='&lt;script src=&quot;/analytics.js&quot;/&gt;') }}
&lt;div class=&quot;entry&quot;&gt;...&lt;/div&gt;&quot;&quot;&quot;,
        })
        return dict(template_loader=loader,
                    autoescape=&quot;xhtml_escape&quot;,
                    cookie_secret=self.COOKIE_SECRET)

    def tearDown(self):
        super(WSGISafeWebTest, self).tearDown()
        RequestHandler._template_loaders.clear()

    def get_handlers(self):
        urls = [
            url(&quot;/typecheck/(.*)&quot;, TypeCheckHandler, name='typecheck'),
            url(&quot;/decode_arg/(.*)&quot;, DecodeArgHandler, name='decode_arg'),
            url(&quot;/decode_arg_kw/(?P&lt;arg&gt;.*)&quot;, DecodeArgHandler),
            url(&quot;/linkify&quot;, LinkifyHandler),
            url(&quot;/uimodule_resources&quot;, UIModuleResourceHandler),
            url(&quot;/optional_path/(.+)?&quot;, OptionalPathHandler),
            url(&quot;/multi_header&quot;, MultiHeaderHandler),
            url(&quot;/redirect&quot;, RedirectHandler),
            url(&quot;/web_redirect_permanent&quot;, WebRedirectHandler, {&quot;url&quot;: &quot;/web_redirect_newpath&quot;}),
            url(&quot;/web_redirect&quot;, WebRedirectHandler, {&quot;url&quot;: &quot;/web_redirect_newpath&quot;, &quot;permanent&quot;: False}),
            url(&quot;//web_redirect_double_slash&quot;, WebRedirectHandler, {&quot;url&quot;: '/web_redirect_newpath'}),
            url(&quot;/header_injection&quot;, HeaderInjectionHandler),
            url(&quot;/get_argument&quot;, GetArgumentHandler),
            url(&quot;/get_arguments&quot;, GetArgumentsHandler),
        ]
        return urls

    def fetch_json(self, *args, **kwargs):
        response = self.fetch(*args, **kwargs)
        response.rethrow()
        return json_decode(response.body)

    def test_types(self):
        cookie_value = to_unicode(create_signed_value(self.COOKIE_SECRET,
                                                      &quot;asdf&quot;, &quot;qwer&quot;))
        response = self.fetch(&quot;/typecheck/asdf?foo=bar&quot;,
                              headers={&quot;Cookie&quot;: &quot;asdf=&quot; + cookie_value})
        data = json_decode(response.body)
        self.assertEqual(data, {})

        response = self.fetch(&quot;/typecheck/asdf?foo=bar&quot;, method=&quot;POST&quot;,
                              headers={&quot;Cookie&quot;: &quot;asdf=&quot; + cookie_value},
                              body=&quot;foo=bar&quot;)

    def test_decode_argument(self):
        # These urls all decode to the same thing
        urls = [&quot;/decode_arg/%C3%A9?foo=%C3%A9&amp;encoding=utf-8&quot;,
                &quot;/decode_arg/%E9?foo=%E9&amp;encoding=latin1&quot;,
                &quot;/decode_arg_kw/%E9?foo=%E9&amp;encoding=latin1&quot;,
                ]
        for req_url in urls:
            response = self.fetch(req_url)
            response.rethrow()
            data = json_decode(response.body)
            self.assertEqual(data, {u'path': [u'unicode', u'\u00e9'],
                                    u'query': [u'unicode', u'\u00e9'],
                                    })

        response = self.fetch(&quot;/decode_arg/%C3%A9?foo=%C3%A9&quot;)
        response.rethrow()
        data = json_decode(response.body)
        self.assertEqual(data, {u'path': [u'bytes', u'c3a9'],
                                u'query': [u'bytes', u'c3a9'],
                                })

    def test_decode_argument_invalid_unicode(self):
        # test that invalid unicode in URLs causes 400, not 500
        with ExpectLog(gen_log, &quot;.*Invalid unicode.*&quot;):
            response = self.fetch(&quot;/typecheck/invalid%FF&quot;)
            self.assertEqual(response.code, 400)
            response = self.fetch(&quot;/typecheck/invalid?foo=%FF&quot;)
            self.assertEqual(response.code, 400)

    def test_decode_argument_plus(self):
        # These urls are all equivalent.
        urls = [&quot;/decode_arg/1%20%2B%201?foo=1%20%2B%201&amp;encoding=utf-8&quot;,
                &quot;/decode_arg/1%20+%201?foo=1+%2B+1&amp;encoding=utf-8&quot;]
        for req_url in urls:
            response = self.fetch(req_url)
            response.rethrow()
            data = json_decode(response.body)
            self.assertEqual(data, {u'path': [u'unicode', u'1 + 1'],
                                    u'query': [u'unicode', u'1 + 1'],
                                    })

    def test_reverse_url(self):
        self.assertEqual(self.app.reverse_url('decode_arg', 'foo'),
                         '/decode_arg/foo')
        self.assertEqual(self.app.reverse_url('decode_arg', 42),
                         '/decode_arg/42')
        self.assertEqual(self.app.reverse_url('decode_arg', b'\xe9'),
                         '/decode_arg/%E9')
        self.assertEqual(self.app.reverse_url('decode_arg', u'\u00e9'),
                         '/decode_arg/%C3%A9')
        self.assertEqual(self.app.reverse_url('decode_arg', '1 + 1'),
                         '/decode_arg/1%20%2B%201')

    def test_uimodule_unescaped(self):
        response = self.fetch(&quot;/linkify&quot;)
        self.assertEqual(response.body,
                         b&quot;&lt;a href=\&quot;http://example.com\&quot;&gt;http://example.com&lt;/a&gt;&quot;)

    def test_uimodule_resources(self):
        response = self.fetch(&quot;/uimodule_resources&quot;)
        self.assertEqual(response.body, b&quot;&quot;&quot;\
&lt;html&gt;&lt;head&gt;&lt;link href=&quot;/base.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt;&lt;link href=&quot;/foo.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt;
&lt;style type=&quot;text/css&quot;&gt;
.entry { margin-bottom: 1em; }
&lt;/style&gt;
&lt;meta&gt;
&lt;/head&gt;&lt;body&gt;


&lt;div class=&quot;entry&quot;&gt;...&lt;/div&gt;


&lt;div class=&quot;entry&quot;&gt;...&lt;/div&gt;

&lt;script src=&quot;/common.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
//&lt;![CDATA[
js_embed()
//]]&gt;
&lt;/script&gt;
&lt;script src=&quot;/analytics.js&quot;/&gt;
&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;)

    def test_optional_path(self):
        self.assertEqual(self.fetch_json(&quot;/optional_path/foo&quot;),
                         {u&quot;path&quot;: u&quot;foo&quot;})
        self.assertEqual(self.fetch_json(&quot;/optional_path/&quot;),
                         {u&quot;path&quot;: None})

    def test_multi_header(self):
        response = self.fetch(&quot;/multi_header&quot;)
        self.assertEqual(response.headers[&quot;x-overwrite&quot;], &quot;2&quot;)
        self.assertEqual(response.headers.get_list(&quot;x-multi&quot;), [&quot;3&quot;, &quot;4&quot;])

    def test_redirect(self):
        response = self.fetch(&quot;/redirect?permanent=1&quot;, follow_redirects=False)
        self.assertEqual(response.code, 301)
        response = self.fetch(&quot;/redirect?permanent=0&quot;, follow_redirects=False)
        self.assertEqual(response.code, 302)
        response = self.fetch(&quot;/redirect?status=307&quot;, follow_redirects=False)
        self.assertEqual(response.code, 307)

    def test_web_redirect(self):
        response = self.fetch(&quot;/web_redirect_permanent&quot;, follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
        response = self.fetch(&quot;/web_redirect&quot;, follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertEqual(response.headers['Location'], '/web_redirect_newpath')

    def test_web_redirect_double_slash(self):
        response = self.fetch(&quot;//web_redirect_double_slash&quot;, follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
<A NAME="18"></A>
    def test_header_injection(self):
        response = self.fetch(&quot;/header_injection&quot;)
        self<FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#18',2,'match25839-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertEqual(response.body, b&quot;ok&quot;)

    def test_get_argument(self):
        response = self.fetch(&quot;/get_argument?foo=bar&quot;)
        self.assertEqual(response.body, b&quot;bar&quot;)
        response =</B></FONT> self.fetch(&quot;/get_argument?foo=&quot;)
        self.assertEqual(response.body, b&quot;&quot;)
        response = self.fetch(&quot;/get_argument&quot;)
        self.assertEqual(response.body, b&quot;default&quot;)

        # Test merging of query and body arguments.
        # In singular form, body arguments take precedence over query arguments.
        body = urllib_parse.urlencode(dict(foo=&quot;hello&quot;))
        response = self.fetch(&quot;/get_argument?foo=bar&quot;, method=&quot;POST&quot;, body=body)
        self.assertEqual(response.body, b&quot;hello&quot;)
        # In plural methods they are merged.
        response = self.fetch(&quot;/get_arguments?foo=bar&quot;,
                              method=&quot;POST&quot;, body=body)
        self.assertEqual(json_decode(response.body),
                         dict(default=['bar', 'hello'],
                              query=['bar'],
                              body=['hello']))

    def test_get_query_arguments(self):
        # send as a post so we can ensure the separation between query
        # string and body arguments.
        body = urllib_parse.urlencode(dict(foo=&quot;hello&quot;))
        response = self.fetch(&quot;/get_argument?source=query&amp;foo=bar&quot;,
<A NAME="7"></A>                              method=&quot;POST&quot;, body=body)
        self.assertEqual(response.body, b&quot;bar&quot;)
        response = self.fetch(&quot;/get_argument?source=query&amp;foo=&quot;,
                              method=&quot;POST&quot;, body<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#7',2,'match25839-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=body)
        self.assertEqual(response.body, b&quot;&quot;)
        response = self.fetch(&quot;/get_argument?source=query&quot;,
                              method=&quot;POST&quot;, body=body)
        self.assertEqual(response.body, b&quot;default&quot;)

    def</B></FONT> test_get_body_arguments(self):
        body = urllib_parse.urlencode(dict(foo=&quot;bar&quot;))
        response = self.fetch(&quot;/get_argument?source=body&amp;foo=hello&quot;,
                              method=&quot;POST&quot;, body=body)
        self.assertEqual(response.body, b&quot;bar&quot;)

        body = urllib_parse.urlencode(dict(foo=&quot;&quot;))
        response = self.fetch(&quot;/get_argument?source=body&amp;foo=hello&quot;,
                              method=&quot;POST&quot;, body=body)
        self.assertEqual(response.body, b&quot;&quot;)

        body = urllib_parse.urlencode(dict())
        response = self.fetch(&quot;/get_argument?source=body&amp;foo=hello&quot;,
                              method=&quot;POST&quot;, body=body)
        self.assertEqual(response.body, b&quot;default&quot;)

    def test_no_gzip(self):
        response = self.fetch('/get_argument')
        self.assertNotIn('Accept-Encoding', response.headers.get('Vary', ''))
        self.assertNotIn('gzip', response.headers.get('Content-Encoding', ''))


class NonWSGIWebTests(WebTestCase):
    def get_handlers(self):
        return [(&quot;/flow_control&quot;, FlowControlHandler),
                (&quot;/empty_flush&quot;, EmptyFlushCallbackHandler),
                ]

    def test_flow_control(self):
        self.assertEqual(self.fetch(&quot;/flow_control&quot;).body, b&quot;123&quot;)

    def test_empty_flush(self):
        response = self.fetch(&quot;/empty_flush&quot;)
        self.assertEqual(response.body, b&quot;ok&quot;)


@wsgi_safe
class ErrorResponseTest(WebTestCase):
    def get_handlers(self):
        class DefaultHandler(RequestHandler):
            def get(self):
                if self.get_argument(&quot;status&quot;, None):
                    raise HTTPError(int(self.get_argument(&quot;status&quot;)))
                1 / 0

        class WriteErrorHandler(RequestHandler):
            def get(self):
                if self.get_argument(&quot;status&quot;, None):
                    self.send_error(int(self.get_argument(&quot;status&quot;)))
                else:
                    1 / 0

            def write_error(self, status_code, **kwargs):
                self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)
                if &quot;exc_info&quot; in kwargs:
                    self.write(&quot;Exception: %s&quot; % kwargs[&quot;exc_info&quot;][0].__name__)
                else:
                    self.write(&quot;Status: %d&quot; % status_code)

        class FailedWriteErrorHandler(RequestHandler):
            def get(self):
                1 / 0

            def write_error(self, status_code, **kwargs):
                raise Exception(&quot;exception in write_error&quot;)

        return [url(&quot;/default&quot;, DefaultHandler),
                url(&quot;/write_error&quot;, WriteErrorHandler),
                url(&quot;/failed_write_error&quot;, FailedWriteErrorHandler),
                ]

    def test_default(self):
        with ExpectLog(app_log, &quot;Uncaught exception&quot;):
            response = self.fetch(&quot;/default&quot;)
            self.assertEqual(response.code, 500)
            self.assertTrue(b&quot;500: Internal Server Error&quot; in response.body)

            response = self.fetch(&quot;/default?status=503&quot;)
            self.assertEqual(response.code, 503)
            self.assertTrue(b&quot;503: Service Unavailable&quot; in response.body)

    def test_write_error(self):
        with ExpectLog(app_log, &quot;Uncaught exception&quot;):
            response = self.fetch(&quot;/write_error&quot;)
            self.assertEqual(response.code, 500)
            self.assertEqual(b&quot;Exception: ZeroDivisionError&quot;, response.body)

            response = self.fetch(&quot;/write_error?status=503&quot;)
            self.assertEqual(response.code, 503)
            self.assertEqual(b&quot;Status: 503&quot;, response.body)

    def test_failed_write_error(self):
        with ExpectLog(app_log, &quot;Uncaught exception&quot;):
            response = self.fetch(&quot;/failed_write_error&quot;)
            self.assertEqual(response.code, 500)
            self.assertEqual(b&quot;&quot;, response.body)


@wsgi_safe
class StaticFileTest(WebTestCase):
    # The expected MD5 hash of robots.txt, used in tests that call
    # StaticFileHandler.get_version
    robots_txt_hash = b&quot;f71d20196d4caf35b6a670db8c70b03d&quot;
    static_dir = os.path.join(os.path.dirname(__file__), 'static')

    def get_handlers(self):
        class StaticUrlHandler(RequestHandler):
            def get(self, path):
                with_v = int(self.get_argument('include_version', 1))
                self.write(self.static_url(path, include_version=with_v))

        class AbsoluteStaticUrlHandler(StaticUrlHandler):
            include_host = True

        class OverrideStaticUrlHandler(RequestHandler):
            def get(self, path):
                do_include = bool(self.get_argument(&quot;include_host&quot;))
                self.include_host = not do_include

                regular_url = self.static_url(path)
                override_url = self.static_url(path, include_host=do_include)
                if override_url == regular_url:
                    return self.write(str(False))

                protocol = self.request.protocol + &quot;://&quot;
                protocol_length = len(protocol)
                check_regular = regular_url.find(protocol, 0, protocol_length)
                check_override = override_url.find(protocol, 0, protocol_length)

                if do_include:
                    result = (check_override == 0 and check_regular == -1)
                else:
                    result = (check_override == -1 and check_regular == 0)
                self.write(str(result))

        return [('/static_url/(.*)', StaticUrlHandler),
                ('/abs_static_url/(.*)', AbsoluteStaticUrlHandler),
                ('/override_static_url/(.*)', OverrideStaticUrlHandler),
                ('/root_static/(.*)', StaticFileHandler, dict(path='/'))]

    def get_app_kwargs(self):
        return dict(static_path=relpath('static'))

    def test_static_files(self):
        response = self.fetch('/robots.txt')
        self.assertTrue(b&quot;Disallow: /&quot; in response.body)

        response = self.fetch('/static/robots.txt')
        self.assertTrue(b&quot;Disallow: /&quot; in response.body)
        self.assertEqual(response.headers.get(&quot;Content-Type&quot;), &quot;text/plain&quot;)

    def test_static_compressed_files(self):
        response = self.fetch(&quot;/static/sample.xml.gz&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Type&quot;),
                         &quot;application/gzip&quot;)
        response = self.fetch(&quot;/static/sample.xml.bz2&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Type&quot;),
                         &quot;application/octet-stream&quot;)
        # make sure the uncompressed file still has the correct type
        response = self.fetch(&quot;/static/sample.xml&quot;)
        self.assertTrue(response.headers.get(&quot;Content-Type&quot;)
                        in set((&quot;text/xml&quot;, &quot;application/xml&quot;)))

    def test_static_url(self):
        response = self.fetch(&quot;/static_url/robots.txt&quot;)
        self.assertEqual(response.body,
                         b&quot;/static/robots.txt?v=&quot; + self.robots_txt_hash)

    def test_absolute_static_url(self):
        response = self.fetch(&quot;/abs_static_url/robots.txt&quot;)
        self.assertEqual(response.body, (
            utf8(self.get_url(&quot;/&quot;)) +
            b&quot;static/robots.txt?v=&quot; +
            self.robots_txt_hash
<A NAME="3"></A>        ))

    def test_relative_version_exclusion(self):
        response <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#3',2,'match25839-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= self.fetch(&quot;/static_url/robots.txt?include_version=0&quot;)
        self.assertEqual(response.body, b&quot;/static/robots.txt&quot;)

    def test_absolute_version_exclusion(self):
        response = self.fetch(&quot;/abs_static_url/robots.txt?include_version=0&quot;)
        self.assertEqual(response.body,
                         utf8(self.</B></FONT>get_url(&quot;/&quot;) + &quot;static/robots.txt&quot;))

    def test_include_host_override(self):
        self._trigger_include_host_check(False)
        self._trigger_include_host_check(True)

    def _trigger_include_host_check(self, include_host):
        path = &quot;/override_static_url/robots.txt?include_host=%s&quot;
        response = self.fetch(path % int(include_host))
        self.assertEqual(response.body, utf8(str(True)))

    def get_and_head(self, *args, **kwargs):
        &quot;&quot;&quot;Performs a GET and HEAD request and returns the GET response.

        Fails if any ``Content-*`` headers returned by the two requests
        differ.
        &quot;&quot;&quot;
        head_response = self.fetch(*args, method=&quot;HEAD&quot;, **kwargs)
        get_response = self.fetch(*args, method=&quot;GET&quot;, **kwargs)
        content_headers = set()
        for h in itertools.chain(head_response.headers, get_response.headers):
            if h.startswith('Content-'):
                content_headers.add(h)
        for h in content_headers:
            self.assertEqual(head_response.headers.get(h),
                             get_response.headers.get(h),
                             &quot;%s differs between GET (%s) and HEAD (%s)&quot; %
                             (h, head_response.headers.get(h),
                              get_response.headers.get(h)))
        return get_response

    def test_static_304_if_modified_since(self):
        response1 = self.get_and_head(&quot;/static/robots.txt&quot;)
        response2 = self.get_and_head(&quot;/static/robots.txt&quot;, headers={
            'If-Modified-Since': response1.headers['Last-Modified']})
        self.assertEqual(response2.code, 304)
        self.assertTrue('Content-Length' not in response2.headers)
        self.assertTrue('Last-Modified' not in response2.headers)

    def test_static_304_if_none_match(self):
        response1 = self.get_and_head(&quot;/static/robots.txt&quot;)
        response2 = self.get_and_head(&quot;/static/robots.txt&quot;, headers={
            'If-None-Match': response1.headers['Etag']})
        self.assertEqual(response2.code, 304)

    def test_static_if_modified_since_pre_epoch(self):
        # On windows, the functions that work with time_t do not accept
        # negative values, and at least one client (processing.js) seems
        # to use if-modified-since 1/1/1960 as a cache-busting technique.
        response = self.get_and_head(&quot;/static/robots.txt&quot;, headers={
            'If-Modified-Since': 'Fri, 01 Jan 1960 00:00:00 GMT'})
        self.assertEqual(response.code, 200)

    def test_static_if_modified_since_time_zone(self):
        # Instead of the value from Last-Modified, make requests with times
        # chosen just before and after the known modification time
        # of the file to ensure that the right time zone is being used
        # when parsing If-Modified-Since.
        stat = os.stat(relpath('static/robots.txt'))

        response = self.get_and_head('/static/robots.txt', headers={
<A NAME="5"></A>            'If-Modified-Since': format_timestamp(stat.st_mtime - 1)})
        self.assertEqual(response.code, 200)
        response = self.get_and_head('/static/robots.txt', headers={
            'If-Modified-Since': format_timestamp(stat<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#5',2,'match25839-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.st_mtime + 1)})
        self.assertEqual(response.code, 304)

    def test_static_etag(self):
        response = self.get_and_head('/static/robots.txt')
        self.assertEqual(utf8(response.headers.get(</B></FONT>&quot;Etag&quot;)),
                         b'&quot;' + self.robots_txt_hash + b'&quot;')

    def test_static_with_range(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=0-9'})
        self.assertEqual(response.code, 206)
        self.assertEqual(response.body, b&quot;User-agent&quot;)
        self.assertEqual(utf8(response.headers.get(&quot;Etag&quot;)),
                         b'&quot;' + self.robots_txt_hash + b'&quot;')
        self.assertEqual(response.headers.get(&quot;Content-Length&quot;), &quot;10&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Range&quot;),
                         &quot;bytes 0-9/26&quot;)

    def test_static_with_range_full_file(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=0-'})
        # Note: Chrome refuses to play audio if it gets an HTTP 206 in response
        # to ``Range: bytes=0-`` :(
        self.assertEqual(response.code, 200)
        robots_file_path = os.path.join(self.static_dir, &quot;robots.txt&quot;)
        with open(robots_file_path) as f:
            self.assertEqual(response.body, utf8(f.read()))
        self.assertEqual(response.headers.get(&quot;Content-Length&quot;), &quot;26&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Range&quot;), None)

    def test_static_with_range_full_past_end(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=0-10000000'})
        self.assertEqual(response.code, 200)
        robots_file_path = os.path.join(self.static_dir, &quot;robots.txt&quot;)
        with open(robots_file_path) as f:
            self.assertEqual(response.body, utf8(f.read()))
        self.assertEqual(response.headers.get(&quot;Content-Length&quot;), &quot;26&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Range&quot;), None)

    def test_static_with_range_partial_past_end(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=1-10000000'})
        self.assertEqual(response.code, 206)
        robots_file_path = os.path.join(self.static_dir, &quot;robots.txt&quot;)
        with open(robots_file_path) as f:
            self.assertEqual(response.body, utf8(f.read()[1:]))
        self.assertEqual(response.headers.get(&quot;Content-Length&quot;), &quot;25&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Range&quot;), &quot;bytes 1-25/26&quot;)

    def test_static_with_range_end_edge(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=22-'})
        self.assertEqual(response.body, b&quot;: /\n&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Length&quot;), &quot;4&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Range&quot;),
                         &quot;bytes 22-25/26&quot;)

    def test_static_with_range_neg_end(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=-4'})
        self.assertEqual(response.body, b&quot;: /\n&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Length&quot;), &quot;4&quot;)
        self.assertEqual(response.headers.get(&quot;Content-Range&quot;),
                         &quot;bytes 22-25/26&quot;)

    def test_static_invalid_range(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'asdf'})
        self.assertEqual(response.code, 200)

    def test_static_unsatisfiable_range_zero_suffix(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=-0'})
        self.assertEqual(response.headers.get(&quot;Content-Range&quot;),
                         &quot;bytes */26&quot;)
        self.assertEqual(response.code, 416)

    def test_static_unsatisfiable_range_invalid_start(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=26'})
        self.assertEqual(response.code, 416)
        self.assertEqual(response.headers.get(&quot;Content-Range&quot;),
                         &quot;bytes */26&quot;)

    def test_static_head(self):
        response = self.fetch('/static/robots.txt', method='HEAD')
        self.assertEqual(response.code, 200)
        # No body was returned, but we did get the right content length.
        self.assertEqual(response.body, b'')
        self.assertEqual(response.headers['Content-Length'], '26')
        self.assertEqual(utf8(response.headers['Etag']),
                         b'&quot;' + self.robots_txt_hash + b'&quot;')

    def test_static_head_range(self):
        response = self.fetch('/static/robots.txt', method='HEAD',
                              headers={'Range': 'bytes=1-4'})
        self.assertEqual(response.code, 206)
        self.assertEqual(response.body, b'')
        self.assertEqual(response.headers['Content-Length'], '4')
        self.assertEqual(utf8(response.headers['Etag']),
                         b'&quot;' + self.robots_txt_hash + b'&quot;')

<A NAME="15"></A>    def test_static_range_if_none_match(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=1-4',
            'If-None-Match': b'&quot;' + self<FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#15',2,'match25839-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.robots_txt_hash + b'&quot;'})
        self.assertEqual(response.code, 304)
        self.assertEqual(response.body, b'')
        self.assertTrue('Content-Length' not in response.headers)
        self.assertEqual(</B></FONT>utf8(response.headers['Etag']),
                         b'&quot;' + self.robots_txt_hash + b'&quot;')

    def test_static_404(self):
        response = self.get_and_head('/static/blarg')
        self.assertEqual(response.code, 404)

    def test_path_traversal_protection(self):
        # curl_httpclient processes &quot;..&quot; on the client side, so we
        # must test this with simple_httpclient.
        self.http_client.close()
        self.http_client = SimpleAsyncHTTPClient()
        with ExpectLog(gen_log, &quot;.*not in root static directory&quot;):
            response = self.get_and_head('/static/../static_foo.txt')
        # Attempted path traversal should result in 403, not 200
        # (which means the check failed and the file was served)
        # or 404 (which means that the file didn't exist and
        # is probably a packaging error).
        self.assertEqual(response.code, 403)

    @unittest.skipIf(os.name != 'posix', 'non-posix OS')
    def test_root_static_path(self):
        # Sometimes people set the StaticFileHandler's path to '/'
        # to disable Tornado's path validation (in conjunction with
        # their own validation in get_absolute_path). Make sure
        # that the stricter validation in 4.2.1 doesn't break them.
        path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                            'static/robots.txt')
        response = self.get_and_head('/root_static' + urllib_parse.quote(path))
        self.assertEqual(response.code, 200)


@wsgi_safe
class StaticDefaultFilenameTest(WebTestCase):
    def get_app_kwargs(self):
        return dict(static_path=relpath('static'),
                    static_handler_args=dict(default_filename='index.html'))

    def get_handlers(self):
        return []

<A NAME="6"></A>    def test_static_default_filename(self):
        response = self.fetch('/static/dir/', follow_redirects=False)
        self.assertEqual(response.code, 200)
        self.assertEqual(b'this is the index\n', response.<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#6',2,'match25839-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>body)

    def test_static_default_redirect(self):
        response = self.fetch('/static/dir', follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertTrue(response.headers['Location'].endswith(</B></FONT>'/static/dir/'))


@wsgi_safe
class StaticFileWithPathTest(WebTestCase):
    def get_app_kwargs(self):
        return dict(static_path=relpath('static'),
                    static_handler_args=dict(default_filename='index.html'))

    def get_handlers(self):
        return [(&quot;/foo/(.*)&quot;, StaticFileHandler, {
            &quot;path&quot;: relpath(&quot;templates/&quot;),
        })]

    def test_serve(self):
        response = self.fetch(&quot;/foo/utf8.html&quot;)
        self.assertEqual(response.body, b&quot;H\xc3\xa9llo\n&quot;)


@wsgi_safe
class CustomStaticFileTest(WebTestCase):
    def get_handlers(self):
        class MyStaticFileHandler(StaticFileHandler):
            @classmethod
            def make_static_url(cls, settings, path):
                version_hash = cls.get_version(settings, path)
                extension_index = path.rindex('.')
                before_version = path[:extension_index]
                after_version = path[(extension_index + 1):]
                return '/static/%s.%s.%s' % (before_version, version_hash,
                                             after_version)

            def parse_url_path(self, url_path):
                extension_index = url_path.rindex('.')
                version_index = url_path.rindex('.', 0, extension_index)
                return '%s%s' % (url_path[:version_index],
                                 url_path[extension_index:])

            @classmethod
            def get_absolute_path(cls, settings, path):
                return 'CustomStaticFileTest:' + path

            def validate_absolute_path(self, root, absolute_path):
                return absolute_path

            @classmethod
            def get_content(self, path, start=None, end=None):
                assert start is None and end is None
                if path == 'CustomStaticFileTest:foo.txt':
                    return b'bar'
                raise Exception(&quot;unexpected path %r&quot; % path)

            def get_content_size(self):
                if self.absolute_path == 'CustomStaticFileTest:foo.txt':
                    return 3
                raise Exception(&quot;unexpected path %r&quot; % self.absolute_path)

            def get_modified_time(self):
                return None

            @classmethod
            def get_version(cls, settings, path):
                return &quot;42&quot;

        class StaticUrlHandler(RequestHandler):
            def get(self, path):
                self.write(self.static_url(path))

        self.static_handler_class = MyStaticFileHandler

        return [(&quot;/static_url/(.*)&quot;, StaticUrlHandler)]

    def get_app_kwargs(self):
        return dict(static_path=&quot;dummy&quot;,
                    static_handler_class=self.static_handler_class)

    def test_serve(self):
        response = self.fetch(&quot;/static/foo.42.txt&quot;)
        self.assertEqual(response.body, b&quot;bar&quot;)

    def test_static_url(self):
        with ExpectLog(gen_log, &quot;Could not open static file&quot;, required=False):
            response = self.fetch(&quot;/static_url/foo.txt&quot;)
            self.assertEqual(response.body, b&quot;/static/foo.42.txt&quot;)


@wsgi_safe
class HostMatchingTest(WebTestCase):
    class Handler(RequestHandler):
        def initialize(self, reply):
            self.reply = reply

        def get(self):
            self.write(self.reply)

    def get_handlers(self):
        return [(&quot;/foo&quot;, HostMatchingTest.Handler, {&quot;reply&quot;: &quot;wildcard&quot;})]

    def test_host_matching(self):
        self.app.add_handlers(&quot;www.example.com&quot;,
                              [(&quot;/foo&quot;, HostMatchingTest.Handler, {&quot;reply&quot;: &quot;[0]&quot;})])
        self.app.add_handlers(r&quot;www\.example\.com&quot;,
                              [(&quot;/bar&quot;, HostMatchingTest.Handler, {&quot;reply&quot;: &quot;[1]&quot;})])
        self.app.add_handlers(&quot;www.example.com&quot;,
                              [(&quot;/baz&quot;, HostMatchingTest.Handler, {&quot;reply&quot;: &quot;[2]&quot;})])
        self.app.add_handlers(&quot;www.e.*e.com&quot;,
                              [(&quot;/baz&quot;, HostMatchingTest.Handler, {&quot;reply&quot;: &quot;[3]&quot;})])

        response = self.fetch(&quot;/foo&quot;)
        self.assertEqual(response.body, b&quot;wildcard&quot;)
        response = self.fetch(&quot;/bar&quot;)
        self.assertEqual(response.code, 404)
        response = self.fetch(&quot;/baz&quot;)
        self.assertEqual(response.code, 404)

        response = self.fetch(&quot;/foo&quot;, headers={'Host': 'www.example.com'})
        self.assertEqual(response.body, b&quot;[0]&quot;)
        response = self.fetch(&quot;/bar&quot;, headers={'Host': 'www.example.com'})
        self.assertEqual(response.body, b&quot;[1]&quot;)
        response = self.fetch(&quot;/baz&quot;, headers={'Host': 'www.example.com'})
        self.assertEqual(response.body, b&quot;[2]&quot;)
        response = self.fetch(&quot;/baz&quot;, headers={'Host': 'www.exe.com'})
        self.assertEqual(response.body, b&quot;[3]&quot;)


@wsgi_safe
class DefaultHostMatchingTest(WebTestCase):
    def get_handlers(self):
        return []

    def get_app_kwargs(self):
        return {'default_host': &quot;www.example.com&quot;}

    def test_default_host_matching(self):
        self.app.add_handlers(&quot;www.example.com&quot;,
                              [(&quot;/foo&quot;, HostMatchingTest.Handler, {&quot;reply&quot;: &quot;[0]&quot;})])
        self.app.add_handlers(r&quot;www\.example\.com&quot;,
                              [(&quot;/bar&quot;, HostMatchingTest.Handler, {&quot;reply&quot;: &quot;[1]&quot;})])
        self.app.add_handlers(&quot;www.test.com&quot;,
                              [(&quot;/baz&quot;, HostMatchingTest.Handler, {&quot;reply&quot;: &quot;[2]&quot;})])

        response = self.fetch(&quot;/foo&quot;)
        self.assertEqual(response.body, b&quot;[0]&quot;)
        response = self.fetch(&quot;/bar&quot;)
        self.assertEqual(response.body, b&quot;[1]&quot;)
        response = self.fetch(&quot;/baz&quot;)
        self.assertEqual(response.code, 404)

        response = self.fetch(&quot;/foo&quot;, headers={&quot;X-Real-Ip&quot;: &quot;127.0.0.1&quot;})
        self.assertEqual(response.code, 404)

        self.app.default_host = &quot;www.test.com&quot;

        response = self.fetch(&quot;/baz&quot;)
        self.assertEqual(response.body, b&quot;[2]&quot;)


@wsgi_safe
class NamedURLSpecGroupsTest(WebTestCase):
    def get_handlers(self):
        class EchoHandler(RequestHandler):
            def get(self, path):
                self.write(path)

        return [(&quot;/str/(?P&lt;path&gt;.*)&quot;, EchoHandler),
                (u&quot;/unicode/(?P&lt;path&gt;.*)&quot;, EchoHandler)]

    def test_named_urlspec_groups(self):
        response = self.fetch(&quot;/str/foo&quot;)
        self.assertEqual(response.body, b&quot;foo&quot;)

        response = self.fetch(&quot;/unicode/bar&quot;)
        self.assertEqual(response.body, b&quot;bar&quot;)


@wsgi_safe
class ClearHeaderTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.set_header(&quot;h1&quot;, &quot;foo&quot;)
            self.set_header(&quot;h2&quot;, &quot;bar&quot;)
            self.clear_header(&quot;h1&quot;)
            self.clear_header(&quot;nonexistent&quot;)

    def test_clear_header(self):
        response = self.fetch(&quot;/&quot;)
        self.assertTrue(&quot;h1&quot; not in response.headers)
        self.assertEqual(response.headers[&quot;h2&quot;], &quot;bar&quot;)


class Header204Test(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.set_status(204)
            self.finish()

    def test_204_headers(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 204)
        self.assertNotIn(&quot;Content-Length&quot;, response.headers)
        self.assertNotIn(&quot;Transfer-Encoding&quot;, response.headers)


@wsgi_safe
class Header304Test(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.set_header(&quot;Content-Language&quot;, &quot;en_US&quot;)
            self.write(&quot;hello&quot;)

    def test_304_headers(self):
        response1 = self.fetch('/')
        self.assertEqual(response1.headers[&quot;Content-Length&quot;], &quot;5&quot;)
        self.assertEqual(response1.headers[&quot;Content-Language&quot;], &quot;en_US&quot;)

        response2 = self.fetch('/', headers={
            'If-None-Match': response1.headers[&quot;Etag&quot;]})
        self.assertEqual(response2.code, 304)
        self.assertTrue(&quot;Content-Length&quot; not in response2.headers)
        self.assertTrue(&quot;Content-Language&quot; not in response2.headers)
        # Not an entity header, but should not be added to 304s by chunking
        self.assertTrue(&quot;Transfer-Encoding&quot; not in response2.headers)


@wsgi_safe
class StatusReasonTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            reason = self.request.arguments.get('reason', [])
            self.set_status(int(self.get_argument('code')),
                            reason=reason[0] if reason else None)
<A NAME="2"></A>
    def get_http_client(self):
        # simple_httpclient only: curl doesn't expose the reason string
        return SimpleAsyncHTTPClient(io_loop=self<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#2',2,'match25839-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.io_loop)

    def test_status(self):
        response = self.fetch(&quot;/?code=304&quot;)
        self.assertEqual(response.code, 304)
        self.assertEqual(response.reason, &quot;Not Modified&quot;)
        response = self.fetch(&quot;/?code=304&amp;reason=Foo&quot;)
        self.assertEqual(response.</B></FONT>code, 304)
        self.assertEqual(response.reason, &quot;Foo&quot;)
        response = self.fetch(&quot;/?code=682&amp;reason=Bar&quot;)
        self.assertEqual(response.code, 682)
        self.assertEqual(response.reason, &quot;Bar&quot;)
        with ExpectLog(app_log, 'Uncaught exception'):
            response = self.fetch(&quot;/?code=682&quot;)
        self.assertEqual(response.code, 500)


@wsgi_safe
class DateHeaderTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.write(&quot;hello&quot;)

    def test_date_header(self):
        response = self.fetch('/')
        header_date = datetime.datetime(
            *email.utils.parsedate(response.headers['Date'])[:6])
        self.assertTrue(header_date - datetime.datetime.utcnow() &lt;
                        datetime.timedelta(seconds=2))


@wsgi_safe
class RaiseWithReasonTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            raise HTTPError(682, reason=&quot;Foo&quot;)
<A NAME="16"></A>
    def get_http_client(self):
        # simple_httpclient only: curl doesn't expose the reason string
        return SimpleAsyncHTTPClient(io_loop=self.<FONT color="#2981b2"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#16',2,'match25839-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>io_loop)

    def test_raise_with_reason(self):
        response = self.fetch(&quot;/&quot;)
        self.assertEqual(response.code, 682)
        self.assertEqual(response.reason, &quot;Foo&quot;)
        self.</B></FONT>assertIn(b'682: Foo', response.body)

    def test_httperror_str(self):
        self.assertEqual(str(HTTPError(682, reason=&quot;Foo&quot;)), &quot;HTTP 682: Foo&quot;)

    def test_httperror_str_from_httputil(self):
        self.assertEqual(str(HTTPError(682)), &quot;HTTP 682: Unknown&quot;)


@wsgi_safe
class ErrorHandlerXSRFTest(WebTestCase):
    def get_handlers(self):
        # note that if the handlers list is empty we get the default_host
        # redirect fallback instead of a 404, so test with both an
        # explicitly defined error handler and an implicit 404.
        return [('/error', ErrorHandler, dict(status_code=417))]

    def get_app_kwargs(self):
        return dict(xsrf_cookies=True)
<A NAME="10"></A>
    def test_error_xsrf(self):
        response = self.fetch('/error', method='POST', body='')
        self<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#10',2,'match25839-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertEqual(response.code, 417)

    def test_404_xsrf(self):
        response = self.fetch('/404', method='POST', body='')
        self.assertEqual(response.</B></FONT>code, 404)


@wsgi_safe
class GzipTestCase(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            for v in self.get_arguments('vary'):
                self.add_header('Vary', v)
            # Must write at least MIN_LENGTH bytes to activate compression.
            self.write('hello world' + ('!' * GZipContentEncoding.MIN_LENGTH))

    def get_app_kwargs(self):
        return dict(
            gzip=True,
            static_path=os.path.join(os.path.dirname(__file__), 'static'))

    def assert_compressed(self, response):
        # simple_httpclient renames the content-encoding header;
        # curl_httpclient doesn't.
        self.assertEqual(
            response.headers.get(
                'Content-Encoding',
                response.headers.get('X-Consumed-Content-Encoding')),
<A NAME="14"></A>            'gzip')

    def test_gzip(self):
        response <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#14',2,'match25839-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= self.fetch('/')
        self.assert_compressed(response)
        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')

    def test_gzip_static(self):
        # The streaming responses in StaticFileHandler have subtle
        # interactions with the gzip output so test this case separately.
        response =</B></FONT> self.fetch('/robots.txt')
        self.assert_compressed(response)
        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')

    def test_gzip_not_requested(self):
        response = self.fetch('/', use_gzip=False)
        self.assertNotIn('Content-Encoding', response.headers)
        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
<A NAME="19"></A>
    def test_vary_already_present(self):
        response = self.fetch('/?vary=Accept-Language')
        self<FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#19',2,'match25839-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assert_compressed(response)
        self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
                         ['Accept-Language'</B></FONT>, 'Accept-Encoding'])

    def test_vary_already_present_multiple(self):
        # Regression test for https://github.com/tornadoweb/tornado/issues/1670
        response = self.fetch('/?vary=Accept-Language&amp;vary=Cookie')
        self.assert_compressed(response)
        self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
                         ['Accept-Language', 'Cookie', 'Accept-Encoding'])


@wsgi_safe
class PathArgsInPrepareTest(WebTestCase):
    class Handler(RequestHandler):
        def prepare(self):
            self.write(dict(args=self.path_args, kwargs=self.path_kwargs))

        def get(self, path):
            assert path == 'foo'
            self.finish()

    def get_handlers(self):
        return [('/pos/(.*)', self.Handler),
                ('/kw/(?P&lt;path&gt;.*)', self.Handler)]

    def test_pos(self):
        response = self.fetch('/pos/foo')
        response.rethrow()
        data = json_decode(response.body)
        self.assertEqual(data, {'args': ['foo'], 'kwargs': {}})

    def test_kw(self):
        response = self.fetch('/kw/foo')
        response.rethrow()
        data = json_decode(response.body)
        self.assertEqual(data, {'args': [], 'kwargs': {'path': 'foo'}})


@wsgi_safe
class ClearAllCookiesTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.clear_all_cookies()
            self.write('ok')

    def test_clear_all_cookies(self):
        response = self.fetch('/', headers={'Cookie': 'foo=bar; baz=xyzzy'})
        set_cookies = sorted(response.headers.get_list('Set-Cookie'))
        # Python 3.5 sends 'baz=&quot;&quot;;'; older versions use 'baz=;'
        self.assertTrue(set_cookies[0].startswith('baz=;') or
                        set_cookies[0].startswith('baz=&quot;&quot;;'))
        self.assertTrue(set_cookies[1].startswith('foo=;') or
                        set_cookies[1].startswith('foo=&quot;&quot;;'))


class PermissionError(Exception):
    pass


@wsgi_safe
class ExceptionHandlerTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            exc = self.get_argument('exc')
            if exc == 'http':
                raise HTTPError(410, &quot;no longer here&quot;)
            elif exc == 'zero':
                1 / 0
            elif exc == 'permission':
                raise PermissionError('not allowed')

        def write_error(self, status_code, **kwargs):
            if 'exc_info' in kwargs:
                typ, value, tb = kwargs['exc_info']
                if isinstance(value, PermissionError):
                    self.set_status(403)
                    self.write('PermissionError')
                    return
            RequestHandler.write_error(self, status_code, **kwargs)

        def log_exception(self, typ, value, tb):
            if isinstance(value, PermissionError):
                app_log.warning('custom logging for PermissionError: %s',
                                value.args[0])
            else:
                RequestHandler.log_exception(self, typ, value, tb)

    def test_http_error(self):
        # HTTPErrors are logged as warnings with no stack trace.
        # TODO: extend ExpectLog to test this more precisely
        with ExpectLog(gen_log, '.*no longer here'):
            response = self.fetch('/?exc=http')
            self.assertEqual(response.code, 410)

    def test_unknown_error(self):
        # Unknown errors are logged as errors with a stack trace.
        with ExpectLog(app_log, 'Uncaught exception'):
            response = self.fetch('/?exc=zero')
            self.assertEqual(response.code, 500)

    def test_known_error(self):
        # log_exception can override logging behavior, and write_error
        # can override the response.
        with ExpectLog(app_log,
                       'custom logging for PermissionError: not allowed'):
            response = self.fetch('/?exc=permission')
            self.assertEqual(response.code, 403)


@wsgi_safe
class BuggyLoggingTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            1 / 0

        def log_exception(self, typ, value, tb):
            1 / 0

    def test_buggy_log_exception(self):
        # Something gets logged even though the application's
        # logger is broken.
        with ExpectLog(app_log, '.*'):
            self.fetch('/')


@wsgi_safe
class UIMethodUIModuleTest(SimpleHandlerTestCase):
    &quot;&quot;&quot;Test that UI methods and modules are created correctly and
    associated with the handler.
    &quot;&quot;&quot;
    class Handler(RequestHandler):
        def get(self):
            self.render('foo.html')

        def value(self):
            return self.get_argument(&quot;value&quot;)

    def get_app_kwargs(self):
        def my_ui_method(handler, x):
            return &quot;In my_ui_method(%s) with handler value %s.&quot; % (
                x, handler.value())

        class MyModule(UIModule):
            def render(self, x):
                return &quot;In MyModule(%s) with handler value %s.&quot; % (
                    x, self.handler.value())

        loader = DictLoader({
            'foo.html': '{{ my_ui_method(42) }} {% module MyModule(123) %}',
        })
        return dict(template_loader=loader,
                    ui_methods={'my_ui_method': my_ui_method},
                    ui_modules={'MyModule': MyModule})

    def tearDown(self):
        super(UIMethodUIModuleTest, self).tearDown()
        # TODO: fix template loader caching so this isn't necessary.
        RequestHandler._template_loaders.clear()

    def test_ui_method(self):
        response = self.fetch('/?value=asdf')
        self.assertEqual(response.body,
                         b'In my_ui_method(42) with handler value asdf. '
                         b'In MyModule(123) with handler value asdf.')


@wsgi_safe
class GetArgumentErrorTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            try:
                self.get_argument('foo')
                self.write({})
            except MissingArgumentError as e:
                self.write({'arg_name': e.arg_name,
                            'log_message': e.log_message})

    def test_catch_error(self):
        response = self.fetch('/')
        self.assertEqual(json_decode(response.body),
                         {'arg_name': 'foo',
                          'log_message': 'Missing argument foo'})


class MultipleExceptionTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        exc_count = 0

        @asynchronous
        def get(self):
            from salt.ext.tornado.ioloop import IOLoop
            IOLoop.current().add_callback(lambda: 1 / 0)
            IOLoop.current().add_callback(lambda: 1 / 0)

        def log_exception(self, typ, value, tb):
            MultipleExceptionTest.Handler.exc_count += 1

    def test_multi_exception(self):
        # This test verifies that multiple exceptions raised into the same
        # ExceptionStackContext do not generate extraneous log entries
        # due to &quot;Cannot send error response after headers written&quot;.
        # log_exception is called, but it does not proceed to send_error.
        response = self.fetch('/')
        self.assertEqual(response.code, 500)
        response = self.fetch('/')
        self.assertEqual(response.code, 500)
        # Each of our two requests generated two exceptions, we should have
        # seen at least three of them by now (the fourth may still be
        # in the queue).
        self.assertGreater(MultipleExceptionTest.Handler.exc_count, 2)


@wsgi_safe
class SetLazyPropertiesTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def prepare(self):
            self.current_user = 'Ben'
            self.locale = locale.get('en_US')

        def get_user_locale(self):
            raise NotImplementedError()

        def get_current_user(self):
            raise NotImplementedError()

        def get(self):
            self.write('Hello %s (%s)' % (self.current_user, self.locale.code))

    def test_set_properties(self):
        # Ensure that current_user can be assigned to normally for apps
        # that want to forgo the lazy get_current_user property
        response = self.fetch('/')
        self.assertEqual(response.body, b'Hello Ben (en_US)')


@wsgi_safe
class GetCurrentUserTest(WebTestCase):
    def get_app_kwargs(self):
        class WithoutUserModule(UIModule):
            def render(self):
                return ''

        class WithUserModule(UIModule):
            def render(self):
                return str(self.current_user)

        loader = DictLoader({
            'without_user.html': '',
            'with_user.html': '{{ current_user }}',
            'without_user_module.html': '{% module WithoutUserModule() %}',
            'with_user_module.html': '{% module WithUserModule() %}',
        })
        return dict(template_loader=loader,
                    ui_modules={'WithUserModule': WithUserModule,
                                'WithoutUserModule': WithoutUserModule})

    def tearDown(self):
        super(GetCurrentUserTest, self).tearDown()
        RequestHandler._template_loaders.clear()

    def get_handlers(self):
        class CurrentUserHandler(RequestHandler):
            def prepare(self):
                self.has_loaded_current_user = False

            def get_current_user(self):
                self.has_loaded_current_user = True
                return ''

        class WithoutUserHandler(CurrentUserHandler):
            def get(self):
                self.render_string('without_user.html')
                self.finish(str(self.has_loaded_current_user))

        class WithUserHandler(CurrentUserHandler):
            def get(self):
                self.render_string('with_user.html')
                self.finish(str(self.has_loaded_current_user))

        class CurrentUserModuleHandler(CurrentUserHandler):
            def get_template_namespace(self):
                # If RequestHandler.get_template_namespace is called, then
                # get_current_user is evaluated. Until #820 is fixed, this
                # is a small hack to circumvent the issue.
                return self.ui

        class WithoutUserModuleHandler(CurrentUserModuleHandler):
            def get(self):
                self.render_string('without_user_module.html')
                self.finish(str(self.has_loaded_current_user))

        class WithUserModuleHandler(CurrentUserModuleHandler):
            def get(self):
                self.render_string('with_user_module.html')
                self.finish(str(self.has_loaded_current_user))

        return [('/without_user', WithoutUserHandler),
                ('/with_user', WithUserHandler),
                ('/without_user_module', WithoutUserModuleHandler),
                ('/with_user_module', WithUserModuleHandler)]

    @unittest.skip('needs fix')
    def test_get_current_user_is_lazy(self):
        # TODO: Make this test pass. See #820.
        response = self.fetch('/without_user')
        self.assertEqual(response.body, b'False')

    def test_get_current_user_works(self):
        response = self.fetch('/with_user')
        self.assertEqual(response.body, b'True')

    def test_get_current_user_from_ui_module_is_lazy(self):
        response = self.fetch('/without_user_module')
        self.assertEqual(response.body, b'False')

    def test_get_current_user_from_ui_module_works(self):
        response = self.fetch('/with_user_module')
        self.assertEqual(response.body, b'True')


@wsgi_safe
class UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        pass

    def test_unimplemented_standard_methods(self):
        for method in ['HEAD', 'GET', 'DELETE', 'OPTIONS']:
            response = self.fetch('/', method=method)
            self.assertEqual(response.code, 405)
        for method in ['POST', 'PUT']:
            response = self.fetch('/', method=method, body=b'')
            self.assertEqual(response.code, 405)


class UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):
    # wsgiref.validate complains about unknown methods in a way that makes
    # this test not wsgi_safe.
    class Handler(RequestHandler):
        def other(self):
            # Even though this method exists, it won't get called automatically
            # because it is not in SUPPORTED_METHODS.
            self.write('other')

    def test_unimplemented_patch(self):
        # PATCH is recently standardized; Tornado supports it by default
        # but wsgiref.validate doesn't like it.
        response = self.fetch('/', method='PATCH', body=b'')
        self.assertEqual(response.code, 405)

    def test_unimplemented_other(self):
        response = self.fetch('/', method='OTHER',
                              allow_nonstandard_methods=True)
        self.assertEqual(response.code, 405)


@wsgi_safe
class AllHTTPMethodsTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def method(self):
            self.write(self.request.method)

        get = delete = options = post = put = method

<A NAME="0"></A>    def test_standard_methods(self):
        response = self.fetch('/', method='HEAD')
        self.assertEqual(response.body, b'')
        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#0',2,'match25839-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for method in ['GET', 'DELETE', 'OPTIONS']:
            response = self.fetch('/', method=method)
            self.assertEqual(response.body, utf8(method))
        for method in ['POST', 'PUT']:
            response = self.fetch('/', method=method, body=b'')
            self.assertEqual(response.body, utf8(</B></FONT>method))


class PatchMethodTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)

        def patch(self):
            self.write('patch')

        def other(self):
            self.write('other')

    def test_patch(self):
        response = self.fetch('/', method='PATCH', body=b'')
        self.assertEqual(response.body, b'patch')

    def test_other(self):
        response = self.fetch('/', method='OTHER',
                              allow_nonstandard_methods=True)
        self.assertEqual(response.body, b'other')


@wsgi_safe
class FinishInPrepareTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def prepare(self):
            self.finish('done')

        def get(self):
            # It's difficult to assert for certain that a method did not
            # or will not be called in an asynchronous context, but this
            # will be logged noisily if it is reached.
            raise Exception('should not reach this method')

    def test_finish_in_prepare(self):
        response = self.fetch('/')
        self.assertEqual(response.body, b'done')


@wsgi_safe
class Default404Test(WebTestCase):
    def get_handlers(self):
        # If there are no handlers at all a default redirect handler gets added.
        return [('/foo', RequestHandler)]

    def test_404(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 404)
        self.assertEqual(response.body,
                         b'&lt;html&gt;&lt;title&gt;404: Not Found&lt;/title&gt;'
                         b'&lt;body&gt;404: Not Found&lt;/body&gt;&lt;/html&gt;')


@wsgi_safe
class Custom404Test(WebTestCase):
    def get_handlers(self):
        return [('/foo', RequestHandler)]

    def get_app_kwargs(self):
        class Custom404Handler(RequestHandler):
            def get(self):
                self.set_status(404)
                self.write('custom 404 response')

        return dict(default_handler_class=Custom404Handler)

    def test_404(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 404)
        self.assertEqual(response.body, b'custom 404 response')


@wsgi_safe
class DefaultHandlerArgumentsTest(WebTestCase):
    def get_handlers(self):
        return [('/foo', RequestHandler)]

    def get_app_kwargs(self):
        return dict(default_handler_class=ErrorHandler,
                    default_handler_args=dict(status_code=403))

    def test_403(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 403)


@wsgi_safe
class HandlerByNameTest(WebTestCase):
    def get_handlers(self):
        # All three are equivalent.
        return [('/hello1', HelloHandler),
                ('/hello2', 'tornado.test.web_test.HelloHandler'),
                url('/hello3', 'tornado.test.web_test.HelloHandler'),
                ]

    def test_handler_by_name(self):
        resp = self.fetch('/hello1')
        self.assertEqual(resp.body, b'hello')
        resp = self.fetch('/hello2')
        self.assertEqual(resp.body, b'hello')
        resp = self.fetch('/hello3')
        self.assertEqual(resp.body, b'hello')


class StreamingRequestBodyTest(WebTestCase):
    def get_handlers(self):
        @stream_request_body
        class StreamingBodyHandler(RequestHandler):
            def initialize(self, test):
                self.test = test

            def prepare(self):
                self.test.prepared.set_result(None)

            def data_received(self, data):
                self.test.data.set_result(data)

            def get(self):
                self.test.finished.set_result(None)
                self.write({})

        @stream_request_body
        class EarlyReturnHandler(RequestHandler):
            def prepare(self):
                # If we finish the response in prepare, it won't continue to
                # the (non-existent) data_received.
                raise HTTPError(401)

        @stream_request_body
        class CloseDetectionHandler(RequestHandler):
            def initialize(self, test):
                self.test = test

            def on_connection_close(self):
                super(CloseDetectionHandler, self).on_connection_close()
                self.test.close_future.set_result(None)

        return [('/stream_body', StreamingBodyHandler, dict(test=self)),
                ('/early_return', EarlyReturnHandler),
                ('/close_detection', CloseDetectionHandler, dict(test=self))]

    def connect(self, url, connection_close):
        # Use a raw connection so we can control the sending of data.
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        s.connect((&quot;127.0.0.1&quot;, self.get_http_port()))
        stream = IOStream(s, io_loop=self.io_loop)
        stream.write(b&quot;GET &quot; + url + b&quot; HTTP/1.1\r\n&quot;)
        if connection_close:
            stream.write(b&quot;Connection: close\r\n&quot;)
        stream.write(b&quot;Transfer-Encoding: chunked\r\n\r\n&quot;)
        return stream

    @gen_test
    def test_streaming_body(self):
        self.prepared = Future()
        self.data = Future()
        self.finished = Future()

        stream = self.connect(b&quot;/stream_body&quot;, connection_close=True)
        yield self.prepared
        stream.write(b&quot;4\r\nasdf\r\n&quot;)
        # Ensure the first chunk is received before we send the second.
        data = yield self.data
        self.assertEqual(data, b&quot;asdf&quot;)
        self.data = Future()
        stream.write(b&quot;4\r\nqwer\r\n&quot;)
        data = yield self.data
        self.assertEquals(data, b&quot;qwer&quot;)
        stream.write(b&quot;0\r\n\r\n&quot;)
        yield self.finished
        data = yield gen.Task(stream.read_until_close)
        # This would ideally use an HTTP1Connection to read the response.
        self.assertTrue(data.endswith(b&quot;{}&quot;))
        stream.close()

    @gen_test
    def test_early_return(self):
        stream = self.connect(b&quot;/early_return&quot;, connection_close=False)
        data = yield gen.Task(stream.read_until_close)
        self.assertTrue(data.startswith(b&quot;HTTP/1.1 401&quot;))

    @gen_test
    def test_early_return_with_data(self):
        stream = self.connect(b&quot;/early_return&quot;, connection_close=False)
        stream.write(b&quot;4\r\nasdf\r\n&quot;)
        data = yield gen.Task(stream.read_until_close)
        self.assertTrue(data.startswith(b&quot;HTTP/1.1 401&quot;))

    @gen_test
    def test_close_during_upload(self):
        self.close_future = Future()
        stream = self.connect(b&quot;/close_detection&quot;, connection_close=False)
        stream.close()
        yield self.close_future


# Each method in this handler returns a yieldable object and yields to the
# IOLoop so the future is not immediately ready.  Ensure that the
# yieldables are respected and no method is called before the previous
# one has completed.
@stream_request_body
class BaseFlowControlHandler(RequestHandler):
    def initialize(self, test):
        self.test = test
        self.method = None
        self.methods = []

    @contextlib.contextmanager
    def in_method(self, method):
        if self.method is not None:
            self.test.fail(&quot;entered method %s while in %s&quot; %
                           (method, self.method))
        self.method = method
        self.methods.append(method)
        try:
            yield
        finally:
            self.method = None

    @gen.coroutine
    def prepare(self):
<A NAME="4"></A>        # Note that asynchronous prepare() does not block data_received,
        # so we don't use in_method here.
        self.methods.append('prepare')
        yield gen<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#4',2,'match25839-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.Task(IOLoop.current().add_callback)

    @gen.coroutine
    def post(self):
        with self.in_method('post'):
            yield gen.</B></FONT>Task(IOLoop.current().add_callback)
        self.write(dict(methods=self.methods))


class BaseStreamingRequestFlowControlTest(object):
    def get_httpserver_options(self):
        # Use a small chunk size so flow control is relevant even though
        # all the data arrives at once.
        return dict(chunk_size=10, decompress_request=True)

    def get_http_client(self):
        # simple_httpclient only: curl doesn't support body_producer.
        return SimpleAsyncHTTPClient(io_loop=self.io_loop)

    # Test all the slightly different code paths for fixed, chunked, etc bodies.
    def test_flow_control_fixed_body(self):
        response = self.fetch('/', body='abcdefghijklmnopqrstuvwxyz',
                              method='POST')
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         dict(methods=['prepare', 'data_received',
                                       'data_received', 'data_received',
                                       'post']))

    def test_flow_control_chunked_body(self):
        chunks = [b'abcd', b'efgh', b'ijkl']

        @gen.coroutine
        def body_producer(write):
            for i in chunks:
                yield write(i)
        response = self.fetch('/', body_producer=body_producer, method='POST')
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         dict(methods=['prepare', 'data_received',
                                       'data_received', 'data_received',
                                       'post']))

    def test_flow_control_compressed_body(self):
        bytesio = BytesIO()
<A NAME="8"></A>        gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
        gzip_file.write(b'abcdefghijklmnopqrstuvwxyz')
        gzip_file.close()
        compressed_body <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#8',2,'match25839-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= bytesio.getvalue()
        response = self.fetch('/', body=compressed_body, method='POST',
                              headers={'Content-Encoding': 'gzip'})
        response.rethrow()
        self.</B></FONT>assertEqual(json_decode(response.body),
                         dict(methods=['prepare', 'data_received',
                                       'data_received', 'data_received',
                                       'post']))


class DecoratedStreamingRequestFlowControlTest(
        BaseStreamingRequestFlowControlTest,
        WebTestCase):
    def get_handlers(self):
        class DecoratedFlowControlHandler(BaseFlowControlHandler):
            @gen.coroutine
            def data_received(self, data):
                with self.in_method('data_received'):
                    yield gen.Task(IOLoop.current().add_callback)
        return [('/', DecoratedFlowControlHandler, dict(test=self))]


@skipBefore35
class NativeStreamingRequestFlowControlTest(
        BaseStreamingRequestFlowControlTest,
        WebTestCase):
    def get_handlers(self):
        class NativeFlowControlHandler(BaseFlowControlHandler):
            data_received = exec_test(globals(), locals(), &quot;&quot;&quot;
            async def data_received(self, data):
                with self.in_method('data_received'):
                    await gen.Task(IOLoop.current().add_callback)
            &quot;&quot;&quot;)[&quot;data_received&quot;]
        return [('/', NativeFlowControlHandler, dict(test=self))]


@wsgi_safe
class IncorrectContentLengthTest(SimpleHandlerTestCase):
    def get_handlers(self):
        test = self
        self.server_error = None

        # Manually set a content-length that doesn't match the actual content.
        class TooHigh(RequestHandler):
            def get(self):
                self.set_header(&quot;Content-Length&quot;, &quot;42&quot;)
                try:
                    self.finish(&quot;ok&quot;)
                except Exception as e:
                    test.server_error = e
                    raise

        class TooLow(RequestHandler):
            def get(self):
                self.set_header(&quot;Content-Length&quot;, &quot;2&quot;)
                try:
                    self.finish(&quot;hello&quot;)
                except Exception as e:
                    test.server_error = e
                    raise

        return [('/high', TooHigh),
                ('/low', TooLow)]

    def test_content_length_too_high(self):
        # When the content-length is too high, the connection is simply
        # closed without completing the response.  An error is logged on
        # the server.
        with ExpectLog(app_log, &quot;(Uncaught exception|Exception in callback)&quot;):
            with ExpectLog(gen_log,
                           &quot;(Cannot send error response after headers written&quot;
                           &quot;|Failed to flush partial response)&quot;):
                response = self.fetch(&quot;/high&quot;)
        self.assertEqual(response.code, 599)
        self.assertEqual(str(self.server_error),
                         &quot;Tried to write 40 bytes less than Content-Length&quot;)

    def test_content_length_too_low(self):
        # When the content-length is too low, the connection is closed
        # without writing the last chunk, so the client never sees the request
        # complete (which would be a framing error).
        with ExpectLog(app_log, &quot;(Uncaught exception|Exception in callback)&quot;):
            with ExpectLog(gen_log,
                           &quot;(Cannot send error response after headers written&quot;
                           &quot;|Failed to flush partial response)&quot;):
                response = self.fetch(&quot;/low&quot;)
        self.assertEqual(response.code, 599)
        self.assertEqual(str(self.server_error),
                         &quot;Tried to write more data than Content-Length&quot;)


class ClientCloseTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            if self.request.version.startswith('HTTP/1'):
                # Simulate a connection closed by the client during
                # request processing.  The client will see an error, but the
                # server should respond gracefully (without logging errors
                # because we were unable to write out as many bytes as
                # Content-Length said we would)
                self.request.connection.stream.close()
                self.write('hello')
            else:
                # TODO: add a HTTP2-compatible version of this test.
                self.write('requires HTTP/1.x')

    def test_client_close(self):
        response = self.fetch('/')
        if response.body == b'requires HTTP/1.x':
            self.skipTest('requires HTTP/1.x')
        self.assertEqual(response.code, 599)


class SignedValueTest(unittest.TestCase):
    SECRET = &quot;It's a secret to everybody&quot;
    SECRET_DICT = {0: &quot;asdfbasdf&quot;, 1: &quot;12312312&quot;, 2: &quot;2342342&quot;}

    def past(self):
        return self.present() - 86400 * 32

    def present(self):
        return 1300000000

    def test_known_values(self):
        signed_v1 = create_signed_value(SignedValueTest.SECRET, &quot;key&quot;, &quot;value&quot;,
                                        version=1, clock=self.present)
        self.assertEqual(
            signed_v1,
            b&quot;dmFsdWU=|1300000000|31c934969f53e48164c50768b40cbd7e2daaaa4f&quot;)

        signed_v2 = create_signed_value(SignedValueTest.SECRET, &quot;key&quot;, &quot;value&quot;,
                                        version=2, clock=self.present)
        self.assertEqual(
            signed_v2,
            b&quot;2|1:0|10:1300000000|3:key|8:dmFsdWU=|&quot;
            b&quot;3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152&quot;)

        signed_default = create_signed_value(SignedValueTest.SECRET,
                                             &quot;key&quot;, &quot;value&quot;, clock=self.present)
        self.assertEqual(signed_default, signed_v2)

        decoded_v1 = decode_signed_value(SignedValueTest.SECRET, &quot;key&quot;,
                                         signed_v1, min_version=1,
                                         clock=self.present)
        self.assertEqual(decoded_v1, b&quot;value&quot;)

        decoded_v2 = decode_signed_value(SignedValueTest.SECRET, &quot;key&quot;,
                                         signed_v2, min_version=2,
                                         clock=self.present)
        self.assertEqual(decoded_v2, b&quot;value&quot;)

    def test_name_swap(self):
        signed1 = create_signed_value(SignedValueTest.SECRET, &quot;key1&quot;, &quot;value&quot;,
                                      clock=self.present)
        signed2 = create_signed_value(SignedValueTest.SECRET, &quot;key2&quot;, &quot;value&quot;,
                                      clock=self.present)
        # Try decoding each string with the other's &quot;name&quot;
        decoded1 = decode_signed_value(SignedValueTest.SECRET, &quot;key2&quot;, signed1,
                                       clock=self.present)
        self.assertIs(decoded1, None)
        decoded2 = decode_signed_value(SignedValueTest.SECRET, &quot;key1&quot;, signed2,
                                       clock=self.present)
        self.assertIs(decoded2, None)

    def test_expired(self):
        signed = create_signed_value(SignedValueTest.SECRET, &quot;key1&quot;, &quot;value&quot;,
                                     clock=self.past)
        decoded_past = decode_signed_value(SignedValueTest.SECRET, &quot;key1&quot;,
                                           signed, clock=self.past)
        self.assertEqual(decoded_past, b&quot;value&quot;)
        decoded_present = decode_signed_value(SignedValueTest.SECRET, &quot;key1&quot;,
                                              signed, clock=self.present)
        self.assertIs(decoded_present, None)

    def test_payload_tampering(self):
        # These cookies are variants of the one in test_known_values.
        sig = &quot;3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152&quot;

        def validate(prefix):
            return (b'value' ==
                    decode_signed_value(SignedValueTest.SECRET, &quot;key&quot;,
                                        prefix + sig, clock=self.present))
        self.assertTrue(validate(&quot;2|1:0|10:1300000000|3:key|8:dmFsdWU=|&quot;))
        # Change key version
        self.assertFalse(validate(&quot;2|1:1|10:1300000000|3:key|8:dmFsdWU=|&quot;))
        # length mismatch (field too short)
        self.assertFalse(validate(&quot;2|1:0|10:130000000|3:key|8:dmFsdWU=|&quot;))
        # length mismatch (field too long)
        self.assertFalse(validate(&quot;2|1:0|10:1300000000|3:keey|8:dmFsdWU=|&quot;))

    def test_signature_tampering(self):
        prefix = &quot;2|1:0|10:1300000000|3:key|8:dmFsdWU=|&quot;

        def validate(sig):
            return (b'value' ==
                    decode_signed_value(SignedValueTest.SECRET, &quot;key&quot;,
                                        prefix + sig, clock=self.present))
        self.assertTrue(validate(
            &quot;3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152&quot;))
        # All zeros
        self.assertFalse(validate(&quot;0&quot; * 32))
        # Change one character
        self.assertFalse(validate(
            &quot;4d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152&quot;))
        # Change another character
        self.assertFalse(validate(
            &quot;3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e153&quot;))
        # Truncate
        self.assertFalse(validate(
            &quot;3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e15&quot;))
        # Lengthen
        self.assertFalse(validate(
            &quot;3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e1538&quot;))

    def test_non_ascii(self):
        value = b&quot;\xe9&quot;
        signed = create_signed_value(SignedValueTest.SECRET, &quot;key&quot;, value,
                                     clock=self.present)
        decoded = decode_signed_value(SignedValueTest.SECRET, &quot;key&quot;, signed,
                                      clock=self.present)
        self.assertEqual(value, decoded)

    def test_key_versioning_read_write_default_key(self):
        value = b&quot;\xe9&quot;
        signed = create_signed_value(SignedValueTest.SECRET_DICT,
                                     &quot;key&quot;, value, clock=self.present,
                                     key_version=0)
        decoded = decode_signed_value(SignedValueTest.SECRET_DICT,
                                      &quot;key&quot;, signed, clock=self.present)
        self.assertEqual(value, decoded)

    def test_key_versioning_read_write_non_default_key(self):
        value = b&quot;\xe9&quot;
        signed = create_signed_value(SignedValueTest.SECRET_DICT,
                                     &quot;key&quot;, value, clock=self.present,
                                     key_version=1)
        decoded = decode_signed_value(SignedValueTest.SECRET_DICT,
                                      &quot;key&quot;, signed, clock=self.present)
        self.assertEqual(value, decoded)

    def test_key_versioning_invalid_key(self):
        value = b&quot;\xe9&quot;
        signed = create_signed_value(SignedValueTest.SECRET_DICT,
                                     &quot;key&quot;, value, clock=self.present,
                                     key_version=0)
        newkeys = SignedValueTest.SECRET_DICT.copy()
        newkeys.pop(0)
        decoded = decode_signed_value(newkeys,
                                      &quot;key&quot;, signed, clock=self.present)
        self.assertEqual(None, decoded)

    def test_key_version_retrieval(self):
        value = b&quot;\xe9&quot;
        signed = create_signed_value(SignedValueTest.SECRET_DICT,
                                     &quot;key&quot;, value, clock=self.present,
                                     key_version=1)
        key_version = get_signature_key_version(signed)
        self.assertEqual(1, key_version)


@wsgi_safe
class XSRFTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            version = int(self.get_argument(&quot;version&quot;, &quot;2&quot;))
            # This would be a bad idea in a real app, but in this test
            # it's fine.
            self.settings[&quot;xsrf_cookie_version&quot;] = version
            self.write(self.xsrf_token)

        def post(self):
            self.write(&quot;ok&quot;)

    def get_app_kwargs(self):
        return dict(xsrf_cookies=True)

    def setUp(self):
        super(XSRFTest, self).setUp()
        self.xsrf_token = self.get_token()

    def get_token(self, old_token=None, version=None):
        if old_token is not None:
            headers = self.cookie_headers(old_token)
        else:
            headers = None
        response = self.fetch(
            &quot;/&quot; if version is None else (&quot;/?version=%d&quot; % version),
            headers=headers)
        response.rethrow()
        return native_str(response.body)

    def cookie_headers(self, token=None):
        if token is None:
            token = self.xsrf_token
        return {&quot;Cookie&quot;: &quot;_xsrf=&quot; + token}

    def test_xsrf_fail_no_token(self):
        with ExpectLog(gen_log, &quot;.*'_xsrf' argument missing&quot;):
            response = self.fetch(&quot;/&quot;, method=&quot;POST&quot;, body=b&quot;&quot;)
        self.assertEqual(response.code, 403)

    def test_xsrf_fail_body_no_cookie(self):
        with ExpectLog(gen_log, &quot;.*XSRF cookie does not match POST&quot;):
            response = self.fetch(
                &quot;/&quot;, method=&quot;POST&quot;,
                body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)))
        self.assertEqual(response.code, 403)

    def test_xsrf_fail_argument_invalid_format(self):
        with ExpectLog(gen_log, &quot;.*'_xsrf' argument has invalid format&quot;):
            response = self.fetch(
                &quot;/&quot;, method=&quot;POST&quot;,
                headers=self.cookie_headers(),
                body=urllib_parse.urlencode(dict(_xsrf='3|')))
        self.assertEqual(response.code, 403)

    def test_xsrf_fail_cookie_invalid_format(self):
        with ExpectLog(gen_log, &quot;.*XSRF cookie does not match POST&quot;):
            response = self.fetch(
                &quot;/&quot;, method=&quot;POST&quot;,
                headers=self.cookie_headers(token='3|'),
                body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)))
        self.assertEqual(response.code, 403)

    def test_xsrf_fail_cookie_no_body(self):
        with ExpectLog(gen_log, &quot;.*'_xsrf' argument missing&quot;):
            response = self.fetch(
                &quot;/&quot;, method=&quot;POST&quot;, body=b&quot;&quot;,
                headers=self.cookie_headers())
        self.assertEqual(response.code, 403)

    def test_xsrf_success_short_token(self):
        response = self.fetch(
            &quot;/&quot;, method=&quot;POST&quot;,
            body=urllib_parse.urlencode(dict(_xsrf='deadbeef')),
            headers=self.cookie_headers(token='deadbeef'))
        self.assertEqual(response.code, 200)

    def test_xsrf_success_non_hex_token(self):
        response = self.fetch(
            &quot;/&quot;, method=&quot;POST&quot;,
            body=urllib_parse.urlencode(dict(_xsrf='xoxo')),
            headers=self.cookie_headers(token='xoxo'))
        self.assertEqual(response.code, 200)

    def test_xsrf_success_post_body(self):
        response = self.fetch(
            &quot;/&quot;, method=&quot;POST&quot;,
            body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
            headers=self.cookie_headers())
        self.assertEqual(response.code, 200)

    def test_xsrf_success_query_string(self):
        response = self.fetch(
            &quot;/?&quot; + urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
            method=&quot;POST&quot;, body=b&quot;&quot;,
            headers=self.cookie_headers())
        self.assertEqual(response.code, 200)

    def test_xsrf_success_header(self):
        response = self.fetch(&quot;/&quot;, method=&quot;POST&quot;, body=b&quot;&quot;,
                              headers=dict({&quot;X-Xsrftoken&quot;: self.xsrf_token},  # type: ignore
                                           **self.cookie_headers()))
        self.assertEqual(response.code, 200)

    def test_distinct_tokens(self):
        # Every request gets a distinct token.
        NUM_TOKENS = 10
        tokens = set()
        for i in range(NUM_TOKENS):
            tokens.add(self.get_token())
        self.assertEqual(len(tokens), NUM_TOKENS)

    def test_cross_user(self):
        token2 = self.get_token()
        # Each token can be used to authenticate its own request.
        for token in (self.xsrf_token, token2):
            response = self.fetch(
                &quot;/&quot;, method=&quot;POST&quot;,
                body=urllib_parse.urlencode(dict(_xsrf=token)),
                headers=self.cookie_headers(token))
            self.assertEqual(response.code, 200)
        # Sending one in the cookie and the other in the body is not allowed.
        for cookie_token, body_token in ((self.xsrf_token, token2),
                                         (token2, self.xsrf_token)):
            with ExpectLog(gen_log, '.*XSRF cookie does not match POST'):
                response = self.fetch(
                    &quot;/&quot;, method=&quot;POST&quot;,
                    body=urllib_parse.urlencode(dict(_xsrf=body_token)),
                    headers=self.cookie_headers(cookie_token))
            self.assertEqual(response.code, 403)

    def test_refresh_token(self):
        token = self.xsrf_token
        tokens_seen = set([token])
        # A user's token is stable over time.  Refreshing the page in one tab
        # might update the cookie while an older tab still has the old cookie
        # in its DOM.  Simulate this scenario by passing a constant token
        # in the body and re-querying for the token.
        for i in range(5):
            token = self.get_token(token)
            # Tokens are encoded uniquely each time
            tokens_seen.add(token)
            response = self.fetch(
                &quot;/&quot;, method=&quot;POST&quot;,
                body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
                headers=self.cookie_headers(token))
            self.assertEqual(response.code, 200)
        self.assertEqual(len(tokens_seen), 6)

    def test_versioning(self):
        # Version 1 still produces distinct tokens per request.
        self.assertNotEqual(self.get_token(version=1),
                            self.get_token(version=1))

        # Refreshed v1 tokens are all identical.
        v1_token = self.get_token(version=1)
        for i in range(5):
            self.assertEqual(self.get_token(v1_token, version=1), v1_token)

        # Upgrade to a v2 version of the same token
        v2_token = self.get_token(v1_token)
        self.assertNotEqual(v1_token, v2_token)
        # Each v1 token can map to many v2 tokens.
        self.assertNotEqual(v2_token, self.get_token(v1_token))

        # The tokens are cross-compatible.
        for cookie_token, body_token in ((v1_token, v2_token),
                                         (v2_token, v1_token)):
            response = self.fetch(
                &quot;/&quot;, method=&quot;POST&quot;,
                body=urllib_parse.urlencode(dict(_xsrf=body_token)),
                headers=self.cookie_headers(cookie_token))
            self.assertEqual(response.code, 200)


@wsgi_safe
class XSRFCookieKwargsTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.write(self.xsrf_token)

    def get_app_kwargs(self):
        return dict(xsrf_cookies=True,
                    xsrf_cookie_kwargs=dict(httponly=True))

    def test_xsrf_httponly(self):
        response = self.fetch(&quot;/&quot;)
        self.assertIn('httponly;', response.headers['Set-Cookie'].lower())


@wsgi_safe
class FinishExceptionTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.set_status(401)
            self.set_header('WWW-Authenticate', 'Basic realm=&quot;something&quot;')
            if self.get_argument('finish_value', ''):
                raise Finish('authentication required')
            else:
                self.write('authentication required')
                raise Finish()
<A NAME="9"></A>
    def test_finish_exception(self):
        for u in ['/', '/?finish_value=1']:
            response <FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#9',2,'match25839-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= self.fetch(u)
            self.assertEqual(response.code, 401)
            self.assertEqual('Basic realm=&quot;something&quot;',
                             response.headers.get('WWW-Authenticate'))
            self.assertEqual(</B></FONT>b'authentication required', response.body)


@wsgi_safe
class DecoratorTest(WebTestCase):
    def get_handlers(self):
        class RemoveSlashHandler(RequestHandler):
            @removeslash
            def get(self):
                pass

        class AddSlashHandler(RequestHandler):
            @addslash
            def get(self):
                pass

        return [(&quot;/removeslash/&quot;, RemoveSlashHandler),
                (&quot;/addslash&quot;, AddSlashHandler),
                ]

    def test_removeslash(self):
        response = self.fetch(&quot;/removeslash/&quot;, follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], &quot;/removeslash&quot;)

        response = self.fetch(&quot;/removeslash/?foo=bar&quot;, follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], &quot;/removeslash?foo=bar&quot;)

    def test_addslash(self):
        response = self.fetch(&quot;/addslash&quot;, follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], &quot;/addslash/&quot;)

        response = self.fetch(&quot;/addslash?foo=bar&quot;, follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], &quot;/addslash/?foo=bar&quot;)


@wsgi_safe
class CacheTest(WebTestCase):
    def get_handlers(self):
        class EtagHandler(RequestHandler):
            def get(self, computed_etag):
                self.write(computed_etag)

            def compute_etag(self):
                return self._write_buffer[0]

        return [
            ('/etag/(.*)', EtagHandler)
        ]

    def test_wildcard_etag(self):
        computed_etag = '&quot;xyzzy&quot;'
        etags = '*'
        self._test_etag(computed_etag, etags, 304)

    def test_strong_etag_match(self):
        computed_etag = '&quot;xyzzy&quot;'
        etags = '&quot;xyzzy&quot;'
        self._test_etag(computed_etag, etags, 304)

    def test_multiple_strong_etag_match(self):
        computed_etag = '&quot;xyzzy1&quot;'
        etags = '&quot;xyzzy1&quot;, &quot;xyzzy2&quot;'
        self._test_etag(computed_etag, etags, 304)

    def test_strong_etag_not_match(self):
        computed_etag = '&quot;xyzzy&quot;'
        etags = '&quot;xyzzy1&quot;'
        self._test_etag(computed_etag, etags, 200)

    def test_multiple_strong_etag_not_match(self):
        computed_etag = '&quot;xyzzy&quot;'
        etags = '&quot;xyzzy1&quot;, &quot;xyzzy2&quot;'
        self._test_etag(computed_etag, etags, 200)

    def test_weak_etag_match(self):
        computed_etag = '&quot;xyzzy1&quot;'
        etags = 'W/&quot;xyzzy1&quot;'
        self._test_etag(computed_etag, etags, 304)

    def test_multiple_weak_etag_match(self):
        computed_etag = '&quot;xyzzy2&quot;'
        etags = 'W/&quot;xyzzy1&quot;, W/&quot;xyzzy2&quot;'
        self._test_etag(computed_etag, etags, 304)

    def test_weak_etag_not_match(self):
        computed_etag = '&quot;xyzzy2&quot;'
        etags = 'W/&quot;xyzzy1&quot;'
        self._test_etag(computed_etag, etags, 200)

    def test_multiple_weak_etag_not_match(self):
        computed_etag = '&quot;xyzzy3&quot;'
        etags = 'W/&quot;xyzzy1&quot;, W/&quot;xyzzy2&quot;'
        self._test_etag(computed_etag, etags, 200)

    def _test_etag(self, computed_etag, etags, status_code):
        response = self.fetch(
            '/etag/' + computed_etag,
            headers={'If-None-Match': etags}
        )
        self.assertEqual(response.code, status_code)


@wsgi_safe
class RequestSummaryTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            # remote_ip is optional, although it's set by
            # both HTTPServer and WSGIAdapter.
            # Clobber it to make sure it doesn't break logging.
            self.request.remote_ip = None
            self.finish(self._request_summary())

    def test_missing_remote_ip(self):
        resp = self.fetch(&quot;/&quot;)
        self.assertEqual(resp.body, b&quot;GET / (None)&quot;)


<A NAME="17"></A>class HTTPErrorTest(unittest.TestCase):
    def test_copy(self):
        e = HTTPError(403, reason=&quot;Go away&quot;)
        e2 <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25839-0.html#17',2,'match25839-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= copy.copy(e)
        self.assertIsNot(e, e2)
        self.assertEqual(e.status_code, e2.status_code)
        self.assertEqual(e.</B></FONT>reason, e2.reason)


class ApplicationTest(AsyncTestCase):
    def test_listen(self):
        app = Application([])
        server = app.listen(0, address='127.0.0.1')
        server.stop()


class URLSpecReverseTest(unittest.TestCase):
    def test_reverse(self):
        self.assertEqual('/favicon.ico', url(r'/favicon\.ico', None).reverse())
        self.assertEqual('/favicon.ico', url(r'^/favicon\.ico$', None).reverse())

    def test_non_reversible(self):
        # URLSpecs are non-reversible if they include non-constant
        # regex features outside capturing groups. Currently, this is
        # only strictly enforced for backslash-escaped character
        # classes.
        paths = [
            r'^/api/v\d+/foo/(\w+)$',
        ]
        for path in paths:
            # A URLSpec can still be created even if it cannot be reversed.
            url_spec = url(path, None)
            try:
                result = url_spec.reverse()
                self.fail(&quot;did not get expected exception when reversing %s. &quot;
                          &quot;result: %s&quot; % (path, result))
            except ValueError:
                pass

    def test_reverse_arguments(self):
        self.assertEqual('/api/v1/foo/bar',
                         url(r'^/api/v1/foo/(\w+)$', None).reverse('bar'))


class RedirectHandlerTest(WebTestCase):
    def get_handlers(self):
        return [
            ('/src', WebRedirectHandler, {'url': '/dst'}),
            (r'/(.*?)/(.*?)/(.*)', WebRedirectHandler, {'url': '/{1}/{0}/{2}'})]

    def test_basic_redirect(self):
        response = self.fetch('/src', follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], '/dst')

    def test_redirect_pattern(self):
        response = self.fetch('/a/b/c', follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], '/b/a/c')
</PRE>
</div>
  </div>
</body>
</html>
