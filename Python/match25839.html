<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for httpclient_test.py &amp; web_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for httpclient_test.py &amp; web_test.py
      </h3>
<h1 align="center">
        8.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>httpclient_test.py (23.381878%)<th>web_test.py (5.416042%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(473-478)<td><a href="#" name="0">(1964-1969)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(4-28)<td><a href="#" name="1">(2-25)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(274-280)<td><a href="#" name="2">(1481-1488)</a><td align="center"><font color="#c70000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(530-538)<td><a href="#" name="3">(1017-1023)</a><td align="center"><font color="#b10000">16</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(444-450)<td><a href="#" name="4">(2194-2199)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(305-311)<td><a href="#" name="5">(1087-1092)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(264-269)<td><a href="#" name="6">(1242-1247)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(479-485)<td><a href="#" name="7">(834-840)</a><td align="center"><font color="#9b0000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(285-290)<td><a href="#" name="8">(2242-2246)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(271-274)<td><a href="#" name="9">(2707-2711)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(173-178)<td><a href="#" name="10">(1548-1552)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(61-68)<td><a href="#" name="11">(589-595)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(41-47)<td><a href="#" name="12">(557-565)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(33-41)<td><a href="#" name="13">(193-199)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(671-676)<td><a href="#" name="14">(1579-1586)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(617-620)<td><a href="#" name="15">(1194-1198)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(410-419)<td><a href="#" name="16">(1520-1526)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(219-222)<td><a href="#" name="17">(2835-2838)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(179-185)<td><a href="#" name="18">(803-808)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(157-160)<td><a href="#" name="19">(1597-1599)</a><td align="center"><font color="#850000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>httpclient_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
2 import base64
3 import binascii
4 from contextlib import closing
5 import copy
6 import functools
7 import sys
8 import threading
9 import datetime
10 from io import BytesIO
11 from salt.ext.tornado.escape import utf8, native_str
12 from salt.ext.tornado import gen
13 from salt.ext.tornado.httpclient import HTTPRequest, HTTPResponse, _RequestProxy, HTTPError, HTTPClient
14 from salt.ext.tornado.httpserver import HTTPServer
15 from salt.ext.tornado.ioloop import IOLoop
16 from salt.ext.tornado.iostream import IOStream
17 from salt.ext.tornado.log import gen_log
18 from salt.ext.tornado import netutil
19 from salt.ext.tornado.stack_context import ExceptionStackContext, NullContext
20 from salt.ext.tornado.testing import AsyncHTTPTestCase, bind_unused_port, gen_test, ExpectLog
21 from salt.ext.tornado.test.util import unittest, skipOnTravis
22 from salt.ext.tornado.web import Application, RequestHandler, url
23 from</b></font> salt.ext.tornado.httputil import format_timestamp, HTTPHeaders
24 class HelloWorldHandler(RequestHandler):
25     def get(self):
26         name = self<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_argument("name", "world")
27         self.set_header("Content-Type", "text/plain")
28         self.finish("Hello %s!" % name)
29     def post(self):
30         self.finish("Post arg1: %s, arg2: %s" % (
31             self</b></font><font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_argument("arg1"), self.get_argument("arg2")))
32 class PutHandler(RequestHandler):
33     def put(self):
34         self.write("Put body: ")
35         self.write(self.</b></font>request.body)
36 class RedirectHandler(RequestHandler):
37     def prepare(self):
38         self.write('redirects can have bodies too')
39         self.redirect(self.get_argument("url"),
40                       status=int(self.get_argument("status", "302")))
41 class ChunkHandler(RequestHandler):
42     def get(self):
43         self.write("asdf")
44         self<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.flush()
45         yield gen.sleep(0.01)
46         self.write("qwer")
47 class AuthHandler(RequestHandler):
48     def</b></font> get(self):
49         self.finish(self.request.headers["Authorization"])
50 class CountdownHandler(RequestHandler):
51     def get(self, count):
52         count = int(count)
53         if count &gt; 0:
54             self.redirect(self.reverse_url("countdown", count - 1))
55         else:
56             self.write("Zero")
57 class EchoPostHandler(RequestHandler):
58     def post(self):
59         self.write(self.request.body)
60 class UserAgentHandler(RequestHandler):
61     def get(self):
62         self.write(self.request.headers.get('User-Agent', 'User agent not set'))
63 class ContentLength304Handler(RequestHandler):
64     def get(self):
65         self.set_status(304)
66         self.set_header('Content-Length', 42)
67     def _clear_headers_for_304(self):
68         pass
69 class PatchHandler(RequestHandler):
70     def patch(self):
71         "Return the request payload - so we can check it is being kept"
72         self.write(self.request.body)
73 class AllMethodsHandler(RequestHandler):
74     SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)
75     def method(self):
76         self.write(self.request.method)
77     get = post = put = delete = options = patch = other = method
78 class SetHeaderHandler(RequestHandler):
79     def get(self):
80         for k, v in zip(self.get_arguments('k'),
81                         self.request.arguments['v']):
82             self.set_header(k, v)
83 class HTTPClientCommonTestCase(AsyncHTTPTestCase):
84     def get_app(self):
85         return Application([
86             url("/hello", HelloWorldHandler),
87             url("/post", PostHandler),
88             url("/put", PutHandler),
89             url("/redirect", RedirectHandler),
90             url("/chunk", ChunkHandler),
91             url("/auth", AuthHandler),
92             url("/countdown/([0-9]+)", CountdownHandler, name="countdown"),
93             url("/echopost", EchoPostHandler),
94             url("/user_agent", UserAgentHandler),
95             url("/304_with_content_length", ContentLength304Handler),
96             url("/all_methods", AllMethodsHandler),
97             url('/patch', PatchHandler),
98             url('/set_header', SetHeaderHandler),
99         ], gzip=True)
100     def test_patch_receives_payload(self):
101         body = b"some patch data"
102         response = self.fetch("/patch", method='PATCH', body=body)
103         self.assertEqual(response.code, 200)
104         self.assertEqual(response.body, body)
105     @skipOnTravis
106     def test_hello_world(self):
107         response = self<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.fetch("/hello")
108         self.assertEqual(response.code, 200)
109         self.assertEqual(response.headers["Content-Type"], "text/plain")
110         self.assertEqual(response.</b></font>body, b"Hello world!")
111         self.assertEqual(int(response.request_time), 0)
112         response = self.fetch("/hello?name=Ben")
113         self.assertEqual(response.body, b"Hello Ben!")
114     def test_streaming_callback(self):
115         chunks = []
116         response = self.fetch("/hello",
117         self.assertEqual(chunks, [b"Hello world!"])
118         self<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertFalse(response.body)
119     def test_post(self):
120                               body="arg1=foo&amp;arg2=bar")
121         self.assertEqual(response.</b></font>code, 200)
122         self<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(response.body, b"Post arg1: foo, arg2: bar")
123     def test_chunked(self):
124         response = self.fetch("/chunk")
125         self.assertEqual(response.body, b"asdfqwer")
126         chunks =</b></font> []
127         response = self.fetch("/chunk",
128                               streaming_callback=chunks.append)
129         self.assertEqual(chunks, [b"asdf", b"qwer"])
130         self.assertFalse(response.body)
131     def test_chunked_close(self):
132         sock, port = bind_unused_port()
133         with closing(sock):
134             def write_response(stream, request_data):
135                 if b"HTTP/1." not in request_data:
136                     self.skipTest("requires HTTP/1.x")
137                 stream.write(b"""\
138 HTTP/1.1 200 OK
139 Transfer-Encoding: chunked
140 1
141 1
142 1
143 2
144 0
145 """.replace(b"\n", b"\r\n"), callback=stream.close)
146             resp <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.wait()
147             resp.rethrow()
148             self.assertEqual(resp.body, b"12")
149             self.io_loop.remove_handler(sock.</b></font>fileno())
150     def test_streaming_stack_context(self):
151         chunks = []
152         exc_info = []
153         def error_handler(typ, value, tb):
154             exc_info.append((typ, value, tb))
155             return True
156         def streaming_cb(chunk):
157             chunks.append(chunk)
158             if chunk == b'qwer':
159                 1 / 0
160         with ExceptionStackContext(error_handler):
161             self.fetch('/chunk', streaming_callback=streaming_cb)
162         self.assertEqual(chunks, [b'asdf', b'qwer'])
163         self.assertEqual(1, len(exc_info))
164         self.assertIs(exc_info[0][0], ZeroDivisionError)
165     def test_basic_auth(self):
166         self.assertEqual(self.fetch("/auth", auth_username="Aladdin",
167                                     auth_password="open sesame").body,
168                          b"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==")
169     def test_basic_auth_explicit_mode(self):
170         self.assertEqual(self.fetch("/auth", auth_username="Aladdin",
171                                     auth_password="open sesame",
172                                     auth_mode="basic").body,
173                          b"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==")
174     def test_unsupported_auth_mode(self):
175         with ExpectLog(gen_log, "uncaught exception", required=False):
176             with self.assertRaises((ValueError, HTTPError)):
177                                       auth_password="open sesame",
178                                       auth_mode="asdf")
179                 response.rethrow()<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>
180     def test_follow_redirect(self):
181         response = self.fetch("/countdown/2", follow_redirects=False)
182         self.assertTrue(response.headers["Location"].endswith(</b></font>"/countdown/1"))
183         self.assertEqual(200, response.code)
184         self.assertTrue(response.effective_url.endswith("/countdown/0"))
185         self.assertEqual(</b></font>b"Zero", response<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.body)
186     def test_credentials_in_url(self):
187         url = self.get_url("/auth").replace("http://", "http://me:secret@")
188         self.http_client.fetch(url, self.stop)
189         response = self.wait()
190         self.assertEqual(b"Basic " + base64.</b></font>b64encode(b"me:secret"),
191                          response.body)
192     def test_body_encoding(self):
193         unicode_body = u"\xe9"
194         byte_body <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= binascii.a2b_hex(b"e9")
195         response = self.fetch("/echopost", method="POST", body=unicode_body,
196                               headers={"Content-Type": "application/blah"})
197         self.assertEqual(response.</b></font>headers["Content-Length"], "2")
198         self.assertEqual(response.body, utf8(unicode_body))
199         response = self.fetch("/echopost", method="POST",
200                               body=byte_body,
201                               headers={"Content-Type": "application/blah"})
202         self.assertEqual(response.headers["Content-Length"], "1")
203         self.assertEqual(response.body, byte_body)
204                               headers={"Content-Type": "application/blah"},
205                               user_agent=u"foo")
206         self.assertEqual(response.headers<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["Content-Length"], "1")
207         self.assertEqual(response.body, byte_body)
208     def test_types(self):
209         response = self.fetch("/hello")
210         self.assertEqual(type(response.body), bytes)
211         self.assertEqual(</b></font>type(response.headers["Content-Type"]), str)
212         self.assertEqual(type(response.code), int)
213         self.assertEqual(type(response.effective_url), str)
214     def test_header_callback(self):
215         first_line = []
216         headers = {}
217         chunks = []
218         def header_callback(header_line):
219             if header_line.startswith('HTTP/1.1 101'):
220                 pass
221             elif header_line.startswith('HTTP/'):
222                 first_line.append(header_line)
223             elif header_line != '\r\n':
224                 k, v = header_line.split(':', 1)
225                 headers[k.lower()] = v.strip()
226         def streaming_callback(chunk):
227             self.assertEqual(headers['content-type'], 'text/html; charset=UTF-8')
228             chunks.append(chunk)
229         self.fetch('/chunk', header_callback=header_callback,
230                    streaming_callback=streaming_callback)
231         self.assertEqual(len(first_line), 1, first_line)
232         self.assertRegexpMatches(first_line[0], 'HTTP/[0-9]\\.[0-9] 200.*\r\n')
233         self.assertEqual(chunks, [b'asdf', b'qwer'])
234     def test_header_callback_stack_context(self):
235         exc_info = []
236         def error_handler(typ, value, tb):
237             exc_info.append((typ, value, tb))
238             return True
239         def header_callback(header_line):
240             if header_line.lower().startswith('content-type:'):
241                 1 / 0
242         with ExceptionStackContext(error_handler):
243             self.fetch('/chunk', header_callback=header_callback)
244         self.assertEqual(len(exc_info), 1)
245         self.assertIs(exc_info[0][0], ZeroDivisionError)
246     def test_configure_defaults(self):
247         defaults = dict(user_agent='TestDefaultUserAgent', allow_ipv6=False)
248         client = self.http_client.__class__(self.io_loop, force_instance=True,
249                                             defaults=defaults)
250         try:
251             client.fetch(self.get_url('/user_agent'), callback=self.stop)
252             response = self.wait()
253             self.assertEqual(response.body, b'TestDefaultUserAgent')
254         finally:
255             client.close()
256     def test_header_types(self):
257         for value in [u"MyUserAgent", b"MyUserAgent"]:
258             for container in [dict, HTTPHeaders]:
259                 headers = container()
260                 headers['User-Agent'] = value
261                 resp = self.fetch('/user_agent', headers=headers)
262                 self.assertEqual(
263                     resp.body, b"MyUserAgent",
264                     "response=%r, value=%r, container=%r" %
265                     (resp.body, value, container))
266     def test_multi_line_headers(self):
267         sock, port = bind_unused_port()
268         with closing(sock):
269             def write_response(stream, request_data):
270                 if b"HTTP/1." not in request_data:
271                     self.skipTest("requires HTTP/1.x")
272                 stream.write(b"""\
273 HTTP/1.1 200 OK
274 X-XSS-Protection: 1;
275 \tmode=block
276 """.replace(b"\n", b"\r\n"), callback=stream.close)
277             def accept_callback(conn, address):
278                 stream = IOStream(conn, io_loop=self.io_loop)
279                 stream.read_until(b"\r\n\r\n",
280                                   functools.partial(write_response, stream))
281             netutil.add_accept_handler(sock, accept_callback, self.io_loop)
282             self.http_client.fetch("http://127.0.0.1:%d/" % port, self.stop)
283             resp.rethrow()
284             self.assertEqual(resp.headers['X-XSS-Protection'], "1; mode=block")
285             self.io_loop.remove_handler(sock.fileno()<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>)
286     def test_304_with_content_length(self):
287         response = self.fetch('/304_with_content_length')
288         self.assertEqual(response.code, 304)
289         self.assertEqual(response.headers[</b></font>'Content-Length'], '42')
290     def test_final_callback_stack_context(self):
291         exc_info = []
292         def handle_callback_exception(callback):
293             exc_info.append(sys.exc_info())
294             self.stop()
295         self.io_loop.handle_callback_exception = handle_callback_exception
296         with NullContext():
297             self.http_client.fetch(self.get_url('/hello'),
298                                    lambda response: 1 / 0)
299         self.wait()
300         self.assertEqual(exc_info[0][0], ZeroDivisionError)
301     @gen_test
302     def test_future_interface(self):
303         response = yield self.http_client.fetch(self<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_url('/hello'))
304         self.assertEqual(response.body, b'Hello world!')
305     @gen_test
306     def test_future_http_error(self):
307         with self.assertRaises(HTTPError) as context:
308             yield self.</b></font>http_client.fetch(self.get_url('/notfound'))
309         self.assertEqual(context.exception.code, 404)
310         self.assertEqual(context.exception.response.code, 404)
311     @gen_test
312     def test_future_http_error_no_raise(self):
313         response = yield self.http_client.fetch(self.get_url('/notfound'), raise_error=False)
314         self.assertEqual(response.code, 404)
315     @gen_test
316     def test_reuse_request_from_response(self):
317         url = self.get_url('/hello')
318         response = yield self.http_client.fetch(url)
319         self.assertEqual(response.request.url, url)
320         self.assertTrue(isinstance(response.request, HTTPRequest))
321         response2 = yield self.http_client.fetch(response.request)
322     def test_all_methods(self):
323         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>for method in ['GET', 'DELETE', 'OPTIONS']:
324             response = self.fetch('/all_methods', method=method)
325             self.assertEqual(response.body, utf8(method))
326             response = self.fetch('/all_methods', method=method, body=b'')
327             self.assertEqual(response.body, utf8(</b></font>method))
328         response = self.fetch('/all_methods', method<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>='HEAD')
329         self.assertEqual(response.body, b'')
330         response = self.fetch('/all_methods', method='OTHER',
331                               allow_nonstandard_methods=True)
332         self.assertEqual(response.body, b'OTHER')
333     def</b></font> test_body_sanity_checks(self):
334         for method in ('POST', 'PUT', 'PATCH'):
335             with self.assertRaises(ValueError) as context:
336                 resp = self.fetch('/all_methods', method=method)
337                 resp.rethrow()
338             self.assertIn('must not be None', str(context.exception))
339             resp = self.fetch('/all_methods', method=method,
340                               allow_nonstandard_methods=True)
341             self.assertEqual(resp.code, 200)
342         for method in ('GET', 'DELETE', 'OPTIONS'):
343             with self.assertRaises(ValueError) as context:
344                 resp = self.fetch('/all_methods', method=method, body=b'asdf')
345                 resp.rethrow()
346             self.assertIn('must be None', str(context.exception))
347             if method != 'GET':
348                 resp = self.fetch('/all_methods', method=method, body=b'asdf',
349                                   allow_nonstandard_methods=True)
350                 resp.rethrow()
351                 self.assertEqual(resp.code, 200)
352     def test_put_307(self):
353         response = self.fetch("/redirect?status=307&amp;url=/put",
354                               method="PUT", body<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=b"hello")
355         response.rethrow()
356         self.assertEqual(response.body, b"Put body: hello")
357     def test_non_ascii_header(self):
358         response = self.fetch("/set_header?k=foo&amp;v=%E9")
359         response.rethrow()
360         self.assertEqual(response.</b></font>headers["Foo"], native_str(u"\u00e9"))
361 class RequestProxyTest(unittest.TestCase):
362     def test_request_set(self):
363         proxy = _RequestProxy(HTTPRequest('http://example.com/',
364                                           user_agent='foo'),
365                               dict())
366         self.assertEqual(proxy.user_agent, 'foo')
367     def test_default_set(self):
368         proxy = _RequestProxy(HTTPRequest('http://example.com/'),
369                               dict(network_interface='foo'))
370         self.assertEqual(proxy.network_interface, 'foo')
371     def test_both_set(self):
372         proxy = _RequestProxy(HTTPRequest('http://example.com/',
373                                           proxy_host='foo'),
374                               dict(proxy_host='bar'))
375         self.assertEqual(proxy.proxy_host, 'foo')
376     def test_neither_set(self):
377         proxy = _RequestProxy(HTTPRequest('http://example.com/'),
378                               dict())
379         self.assertIs(proxy.auth_username, None)
380     def test_bad_attribute(self):
381         proxy = _RequestProxy(HTTPRequest('http://example.com/'),
382                               dict())
383         with self.assertRaises(AttributeError):
384             proxy.foo
385     def test_defaults_none(self):
386         proxy = _RequestProxy(HTTPRequest('http://example.com/'), None)
387         self.assertIs(proxy.auth_username, None)
388 class HTTPResponseTestCase(unittest.TestCase):
389     def test_str(self):
390         response = HTTPResponse(HTTPRequest('http://example.com'),
391                                 200, headers={}, buffer=BytesIO())
392         s = str(response)
393         self.assertTrue(s.startswith('HTTPResponse('))
394         self.assertIn('code=200', s)
395 class SyncHTTPClientTest(unittest.TestCase):
396     def setUp(self):
397         if IOLoop.configured_class().__name__ in ('TwistedIOLoop',
398                                                   'AsyncIOMainLoop'):
399             raise unittest.SkipTest(
400                 'Sync HTTPClient not compatible with TwistedIOLoop or '
401                 'AsyncIOMainLoop')
402         self.server_ioloop = IOLoop()
403         sock, self.port = bind_unused_port()
404         app = Application([('/', HelloWorldHandler)])
405         self.server = HTTPServer(app, io_loop=self.server_ioloop)
406         self.server.add_socket(sock)
407         self.server_thread = threading.Thread(target=self.server_ioloop.start)
408         self.server_thread.start()
409         self.http_client = HTTPClient()
410     def tearDown(self):
411         def stop_server():
412             self.server.stop()
413             self.server_ioloop.add_callback(self.server_ioloop.stop)
414         self<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.server_ioloop.add_callback(stop_server)
415         self.server_thread.join()
416         self.http_client.close()
417         self.server_ioloop.close(</b></font>all_fds=True)
418     def get_url(self, path):
419         return 'http://127.0.0.1:%d%s' % (self.port, path)
420     def test_sync_client(self):
421         response = self.http_client.fetch(self.get_url('/'))
422         self.assertEqual(b'Hello world!', response.body)
423     def test_sync_client_error(self):
424         with self.assertRaises(HTTPError) as assertion:
425             self.http_client.fetch(self.get_url('/notfound'))
426         self.assertEqual(assertion.exception.code, 404)
427 class HTTPRequestTestCase(unittest.TestCase):
428     def test_headers(self):
429         request = HTTPRequest('http://example.com', headers={'foo': 'bar'})
430         self.assertEqual(request.headers, {'foo': 'bar'})
431     def test_headers_setter(self):
432         request = HTTPRequest('http://example.com')
433         request.headers = {'bar': 'baz'}
434         self.assertEqual(request.headers, {'bar': 'baz'})
435     def test_null_headers_setter(self):
436         request = HTTPRequest('http://example.com')
437         request.headers = None
438         self.assertEqual(request.headers, {})
439     def test_body(self):
440         request = HTTPRequest('http://example.com', body='foo')
441         self.assertEqual(request.body, utf8('foo'))
442     def test_body_setter(self):
443         request = HTTPRequest('http://example.com')
444         request.body = 'foo'
445         self.assertEqual(request.body, utf8('foo'))
446     def test_if_modified_since(self):
447         http_date = datetime.datetime.utcnow()
448         request = HTTPRequest('http://example.com', if_modified_since=http_date)
449         self.assertEqual(request.headers,
450                          {'If-Modified-Since': format_timestamp(http_date)})
451     def test_copy(self):
452         e = HTTPError(403)
453         e2 <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= copy.copy(e)
454         self.assertIsNot(e, e2)
455         self.assertEqual(e.code, e2.code)
456     def test_plain_error(self):
457         e =</b></font> HTTPError(403)
458         self.assertEqual(str(e), "HTTP 403: Forbidden")
459         self.assertEqual(repr(e), "HTTP 403: Forbidden")
460     def test_error_with_response(self):
461         resp = HTTPResponse(HTTPRequest('http://example.com/'), 403)
462         with self.assertRaises(HTTPError) as cm:
463             resp.rethrow()
464         e = cm.exception
465         self.assertEqual(str(e), "HTTP 403: Forbidden")
466         self.assertEqual(repr(e), "HTTP 403: Forbidden")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>web_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado.concurrent import Future
3 from salt.ext.tornado import gen
4 from salt.ext.tornado.escape import json_decode, utf8, to_unicode, recursive_unicode, native_str, to_basestring
5 from salt.ext.tornado.httputil import format_timestamp
6 from salt.ext.tornado.ioloop import IOLoop
7 from salt.ext.tornado.iostream import IOStream
8 from salt.ext.tornado import locale
9 from salt.ext.tornado.log import app_log, gen_log
10 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
11 from salt.ext.tornado.template import DictLoader
12 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipBefore35, exec_test
14 from salt.ext.tornado.util import ObjectDict, unicode_type, timedelta_to_seconds, PY3
15 from salt.ext.tornado.web import RequestHandler, authenticated, Application, asynchronous, url, HTTPError, StaticFileHandler, _create_signature_v1, create_signed_value, decode_signed_value, ErrorHandler, UIModule, MissingArgumentError, stream_request_body, Finish, removeslash, addslash, RedirectHandler as WebRedirectHandler, get_signature_key_version, GZipContentEncoding
16 import binascii
17 import contextlib
18 import copy
19 import datetime
20 import email.utils
21 import gzip
22 from io import BytesIO
23 import</b></font> itertools
24 import logging
25 import os
26 import re
27 import socket
28 if PY3:
29     import urllib.parse as urllib_parse  # py3
30 else:
31     import urllib as urllib_parse  # py2
32 wsgi_safe_tests = []
33 def relpath(*a):
34     return os.path.join(os.path.dirname(__file__), *a)
35 def wsgi_safe(cls):
36     wsgi_safe_tests.append(cls)
37     return cls
38 class WebTestCase(AsyncHTTPTestCase):
39     """Base class for web tests that also supports WSGI mode.
40     Override get_handlers and get_app_kwargs instead of get_app.
41     Append to wsgi_safe to have it run in wsgi_test as well.
42     """
43     def get_app(self):
44         self.app = Application(self.get_handlers(), **self.get_app_kwargs())
45         return self.app
46     def get_handlers(self):
47         raise NotImplementedError()
48     def get_app_kwargs(self):
49         return {}
50 class SimpleHandlerTestCase(WebTestCase):
51     """Simplified base class for tests that work with a single handler class.
52     To use, define a nested class named ``Handler``.
53     """
54     def get_handlers(self):
55         return [('/', self.Handler)]
56 class HelloHandler(RequestHandler):
57     def get(self):
58         self.write('hello')
59 class CookieTestRequestHandler(RequestHandler):
60     def __init__(self, cookie_secret='0123456789', key_version=None):
61         self._cookies = {}
62         if key_version is None:
63             self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret))
64         else:
65             self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret,
66                                                         key_version=key_version))
67     def get_cookie(self, name):
68         return self._cookies.get(name)
69     def set_cookie(self, name, value, expires_days=None):
70         self._cookies[name] = value
71 class SecureCookieV1Test(unittest.TestCase):
72     def test_round_trip(self):
73         handler = CookieTestRequestHandler()
74         handler.set_secure_cookie('foo', b'bar', version=1)
75         self.assertEqual(handler.get_secure_cookie('foo', min_version=1),
76                          b'bar')
77     def test_cookie_tampering_future_timestamp(self):
78         handler = CookieTestRequestHandler()
79         handler.set_secure_cookie('foo', binascii.a2b_hex(b'd76df8e7aefc'),
80                                   version=1)
81         cookie = handler._cookies['foo']
82         match = re.match(br'12345678\|([0-9]+)\|([0-9a-f]+)', cookie)
83         self.assertTrue(match)
84         timestamp = match.group(1)
85         sig = match.group(2)
86         self.assertEqual(
87             _create_signature_v1(handler.application.settings["cookie_secret"],
88                                  'foo', '12345678', timestamp),
89             sig)
90         self.assertEqual(
91             _create_signature_v1(handler.application.settings["cookie_secret"],
92                                  'foo', '1234', b'5678' + timestamp),
93             sig)
94         handler._cookies['foo'] = utf8('1234|5678%s|%s' % (
95             to_basestring(timestamp), to_basestring(sig)))
96         with ExpectLog(gen_log, "Cookie timestamp in future"):
97             self.assertTrue(
98                 handler.get_secure_cookie('foo', min_version=1) is None)
99     def test_arbitrary_bytes(self):
100         handler = CookieTestRequestHandler()
101         handler.set_secure_cookie('foo', b'\xe9', version=1)
102         self.assertEqual(handler.get_secure_cookie('foo', min_version=1), b'\xe9')
103 class SecureCookieV2Test(unittest.TestCase):
104     KEY_VERSIONS = {
105         0: 'ajklasdf0ojaisdf',
106         1: 'aslkjasaolwkjsdf'
107     }
108     def test_round_trip(self):
109         handler = CookieTestRequestHandler()
110         handler.set_secure_cookie('foo', b'bar', version=2)
111         self.assertEqual(handler.get_secure_cookie('foo', min_version=2), b'bar')
112     def test_key_version_roundtrip(self):
113         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
114                                            key_version=0)
115         handler.set_secure_cookie('foo', b'bar')
116         self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
117     def test_key_version_roundtrip_differing_version(self):
118         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
119                                            key_version=1)
120         handler.set_secure_cookie('foo', b'bar')
121         self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
122     def test_key_version_increment_version(self):
123         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
124                                            key_version=0)
125         handler.set_secure_cookie('foo', b'bar')
126         new_handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
127                                                key_version=1)
128         new_handler._cookies = handler._cookies
129         self.assertEqual(new_handler.get_secure_cookie('foo'), b'bar')
130     def test_key_version_invalidate_version(self):
131         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
132                                            key_version=0)
133         handler.set_secure_cookie('foo', b'bar')
134         new_key_versions = self.KEY_VERSIONS.copy()
135         new_key_versions.pop(0)
136         new_handler = CookieTestRequestHandler(cookie_secret=new_key_versions,
137                                                key_version=1)
138         new_handler._cookies = handler._cookies
139         self.assertEqual(new_handler.get_secure_cookie('foo'), None)
140 class CookieTest(WebTestCase):
141     def get_handlers(self):
142         class SetCookieHandler(RequestHandler):
143                 self<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.set_cookie("str", "asdf")
144                 self.set_cookie("unicode", u"qwer")
145                 self.set_cookie("bytes", b"zxcv")
146         class GetCookieHandler(RequestHandler):
147             def get(self):
148                 self.write(self.</b></font>get_cookie("foo", "default"))
149         class SetCookieDomainHandler(RequestHandler):
150             def get(self):
151                 self.set_cookie("unicode_args", "blah", domain=u"foo.com",
152                                 path=u"/foo")
153         class SetCookieSpecialCharHandler(RequestHandler):
154             def get(self):
155                 self.set_cookie("equals", "a=b")
156                 self.set_cookie("semicolon", "a;b")
157                 self.set_cookie("quote", 'a"b')
158         class SetCookieOverwriteHandler(RequestHandler):
159             def get(self):
160                 self.set_cookie("a", "b", domain="example.com")
161                 self.set_cookie("c", "d", domain="example.com")
162                 self.set_cookie("a", "e")
163         class SetCookieMaxAgeHandler(RequestHandler):
164             def get(self):
165                 self.set_cookie("foo", "bar", max_age=10)
166         class SetCookieExpiresDaysHandler(RequestHandler):
167             def get(self):
168                 self.set_cookie("foo", "bar", expires_days=10)
169         class SetCookieFalsyFlags(RequestHandler):
170             def get(self):
171                 self.set_cookie("a", "1", secure=True)
172                 self.set_cookie("b", "1", secure=False)
173                 self.set_cookie("c", "1", httponly=True)
174                 self.set_cookie("d", "1", httponly=False)
175         return [("/set", SetCookieHandler),
176                 ("/get", GetCookieHandler),
177                 ("/set_domain", SetCookieDomainHandler),
178                 ("/special_char", SetCookieSpecialCharHandler),
179                 ("/set_overwrite", SetCookieOverwriteHandler),
180                 ("/set_max_age", SetCookieMaxAgeHandler),
181                 ("/set_expires_days", SetCookieExpiresDaysHandler),
182                 ("/set_falsy_flags", SetCookieFalsyFlags)
183                 ]
184     def test_set_cookie(self):
185         response = self.fetch("/set")
186         self.assertEqual(sorted(response.headers.get_list("Set-Cookie")),
187                          ["bytes=zxcv; Path=/",
188                           "str=asdf; Path=/",
189                           "unicode=qwer; Path=/",
190                           ])
191     def test_get_cookie(self):
192         response = self.fetch("/get", headers={"Cookie": "foo=bar"})
193         self.assertEqual(response.body, b"bar")
194         response = self.fetch("/get", headers={"Cookie": 'foo="bar"'})
195         self.assertEqual(response.body, b"bar")
196         response = self.fetch("/get", headers={"Cookie": "/=exception;"})
197         self.assertEqual(response.body, b"default")
198     def test_set_cookie_domain(self):
199         response = self.fetch("/set_domain")
200         self.assertEqual(response.headers.get_list("Set-Cookie"),
201                          ["unicode_args=blah; Domain=foo.com; Path=/foo"])
202     def test_cookie_special_char(self):
203         response = self.fetch("/special_char")
204         headers = sorted(response.headers.get_list("Set-Cookie"))
205         self.assertEqual(len(headers), 3)
206         self.assertEqual(headers[0], 'equals="a=b"; Path=/')
207         self.assertEqual(headers[1], 'quote="a\\"b"; Path=/')
208         self.assertTrue(headers[2] in ('semicolon="a;b"; Path=/',
209                                        'semicolon="a\\073b"; Path=/'),
210                         headers[2])
211         data = [('foo=a=b', 'a=b'),
212                 ('foo="a=b"', 'a=b'),
213                 ('foo="a;b"', '"a'),  # even quoted, ";" is a delimiter
214                 ('foo=a\\073b', 'a\\073b'),  # escapes only decoded in quotes
215                 ('foo="a\\073b"', 'a;b'),
216                 ('foo="a\\"b"', 'a"b'),
217                 ]
218         for header, expected in data:
219             logging.debug("trying %r", header)
220             response = self.fetch("/get", headers={"Cookie": header})
221             self.assertEqual(response.body, utf8(expected))
222     def test_set_cookie_overwrite(self):
223         response = self.fetch("/set_overwrite")
224         headers = response.headers.get_list("Set-Cookie")
225         self.assertEqual(sorted(headers),
226                          ["a=e; Path=/", "c=d; Domain=example.com; Path=/"])
227     def test_set_cookie_max_age(self):
228         response = self.fetch("/set_max_age")
229         headers = response.headers.get_list("Set-Cookie")
230         self.assertEqual(sorted(headers),
231                          ["foo=bar; Max-Age=10; Path=/"])
232     def test_set_cookie_expires_days(self):
233         response = self.fetch("/set_expires_days")
234         header = response.headers.get("Set-Cookie")
235         match = re.match("foo=bar; expires=(?P&lt;expires&gt;.+); Path=/", header)
236         self.assertIsNotNone(match)
237         expires = datetime.datetime.utcnow() + datetime.timedelta(days=10)
238         header_expires = datetime.datetime(
239             *email.utils.parsedate(match.groupdict()["expires"])[:6])
240         self.assertTrue(abs(timedelta_to_seconds(expires - header_expires)) &lt; 10)
241     def test_set_cookie_false_flags(self):
242         response = self.fetch("/set_falsy_flags")
243         headers = sorted(response.headers.get_list("Set-Cookie"))
244         self.assertEqual(headers[0].lower(), 'a=1; path=/; secure')
245         self.assertEqual(headers[1].lower(), 'b=1; path=/')
246         self.assertEqual(headers[2].lower(), 'c=1; httponly; path=/')
247         self.assertEqual(headers[3].lower(), 'd=1; path=/')
248 class AuthRedirectRequestHandler(RequestHandler):
249     def initialize(self, login_url):
250         self.login_url = login_url
251     def get_login_url(self):
252         return self.login_url
253     @authenticated
254     def get(self):
255         self.send_error(500)
256 class AuthRedirectTest(WebTestCase):
257     def get_handlers(self):
258         return [('/relative', AuthRedirectRequestHandler,
259                  dict(login_url='/login')),
260                 ('/absolute', AuthRedirectRequestHandler,
261                  dict(login_url='http://example.com/login'))]
262     def test_relative_auth_redirect(self):
263         self.http_client.fetch(self.get_url('/relative'), self.stop,
264                                follow_redirects=False)
265         response = self.wait()
266         self.assertEqual(response.code, 302)
267         self.assertEqual(response.headers['Location'], '/login?next=%2Frelative')
268     def test_absolute_auth_redirect(self):
269         self.http_client.fetch(self.get_url('/absolute'), self.stop,
270                                follow_redirects=False)
271         response = self.wait()
272         self.assertEqual(response.code, 302)
273         self.assertTrue(re.match(
274             'http://example.com/login\?next=http%3A%2F%2F127.0.0.1%3A[0-9]+%2Fabsolute',
275             response.headers['Location']), response.headers['Location'])
276 class ConnectionCloseHandler(RequestHandler):
277     def initialize(self, test):
278         self.test = test
279     @asynchronous
280     def get(self):
281         self.test.on_handler_waiting()
282     def on_connection_close(self):
283         self.test.on_connection_close()
284 class ConnectionCloseTest(WebTestCase):
285     def get_handlers(self):
286         return [('/', ConnectionCloseHandler, dict(test=self))]
287     def test_connection_close(self):
288         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
289         s.connect(("127.0.0.1", self.get_http_port()))
290         self.stream = IOStream(s, io_loop=self.io_loop)
291         self.stream.write(b"GET / HTTP/1.0\r\n\r\n")
292         self.wait()
293     def on_handler_waiting(self):
294         logging.debug('handler waiting')
295         self.stream.close()
296     def on_connection_close(self):
297         logging.debug('connection closed')
298         self.stop()
299 class EchoHandler(RequestHandler):
300     def get(self, *path_args):
301         for key in self.request.arguments:
302             if type(key) != str:
303                 raise Exception("incorrect type for key: %r" % type(key))
304             for value in self.request.arguments[key]:
305                 if type(value) != bytes:
306                     raise Exception("incorrect type for value: %r" %
307                                     type(value))
308             for value in self.get_arguments(key):
309                 if type(value) != unicode_type:
310                     raise Exception("incorrect type for value: %r" %
311                                     type(value))
312         for arg in path_args:
313             if type(arg) != unicode_type:
314                 raise Exception("incorrect type for path arg: %r" % type(arg))
315         self.write(dict(path=self.request.path,
316                         path_args=path_args,
317                         args=recursive_unicode(self.request.arguments)))
318 class RequestEncodingTest(WebTestCase):
319     def get_handlers(self):
320         return [("/group/(.*)", EchoHandler),
321                 ("/slashes/([^/]*)/([^/]*)", EchoHandler),
322                 ]
323     def fetch_json(self, path):
324         return json_decode(self.fetch(path).body)
325     def test_group_question_mark(self):
326         self.assertEqual(self.fetch_json('/group/%3F'),
327                          dict(path='/group/%3F', path_args=['?'], args={}))
328         self.assertEqual(self.fetch_json('/group/%3F?%3F=%3F'),
329                          dict(path='/group/%3F', path_args=['?'], args={'?': ['?']}))
330     def test_group_encoding(self):
331         self.assertEqual(self.fetch_json('/group/%C3%A9?arg=%C3%A9'),
332                          {u"path": u"/group/%C3%A9",
333                           u"path_args": [u"\u00e9"],
334                           u"args": {u"arg": [u"\u00e9"]}})
335     def test_slashes(self):
336         self.assertEqual(self.fetch_json('/slashes/foo/bar'),
337                          dict(path="/slashes/foo/bar",
338                               path_args=["foo", "bar"],
339                               args={}))
340         self.assertEqual(self.fetch_json('/slashes/a%2Fb/c%2Fd'),
341                          dict(path="/slashes/a%2Fb/c%2Fd",
342                               path_args=["a/b", "c/d"],
343                               args={}))
344     def test_error(self):
345         with ExpectLog(gen_log, ".*Invalid unicode"):
346             self.fetch("/group/?arg=%25%e9")
347 class TypeCheckHandler(RequestHandler):
348     def prepare(self):
349         self.errors = {}
350         self.check_type('status', self.get_status(), int)
351         self.check_type('argument', self.get_argument('foo'), unicode_type)
352         self.check_type('cookie_key', list(self.cookies.keys())[0], str)
353         self.check_type('cookie_value', list(self.cookies.values())[0].value, str)
354         if list(self.cookies.keys()) != ['asdf']:
355             raise Exception("unexpected values for cookie keys: %r" %
356                             self.cookies.keys())
357         self.check_type('get_secure_cookie', self.get_secure_cookie('asdf'), bytes)
358         self.check_type('get_cookie', self.get_cookie('asdf'), str)
359         self.check_type('xsrf_token', self.xsrf_token, bytes)
360         self.check_type('xsrf_form_html', self.xsrf_form_html(), str)
361         self.check_type('reverse_url', self.reverse_url('typecheck', 'foo'), str)
362         self.check_type('request_summary', self._request_summary(), str)
363     def get(self, path_component):
364         self.check_type('path_component', path_component, unicode_type)
365         self.write(self.errors)
366     def post(self, path_component):
367         self.check_type('path_component', path_component, unicode_type)
368         self.write(self.errors)
369     def check_type(self, name, obj, expected_type):
370         actual_type = type(obj)
371         if expected_type != actual_type:
372             self.errors[name] = "expected %s, got %s" % (expected_type,
373                                                          actual_type)
374 class DecodeArgHandler(RequestHandler):
375     def decode_argument(self, value, name=None):
376         if type(value) != bytes:
377             raise Exception("unexpected type for value: %r" % type(value))
378         if 'encoding' in self.request.arguments:
379             return value.decode(to_unicode(self.request.arguments['encoding'][0]))
380         else:
381             return value
382     def get(self, arg):
383         def describe(s):
384             if type(s) == bytes:
385                 return ["bytes", native_str(binascii.b2a_hex(s))]
386             elif type(s) == unicode_type:
387                 return ["unicode", s]
388             raise Exception("unknown type")
389         self.write({'path': describe(arg),
390                     'query': describe(self.get_argument("foo")),
391                     })
392 class LinkifyHandler(RequestHandler):
393     def get(self):
394         self.render("linkify.html", message="http://example.com")
395 class UIModuleResourceHandler(RequestHandler):
396     def get(self):
397         self.render("page.html", entries=[1, 2])
398 class OptionalPathHandler(RequestHandler):
399     def get(self, path):
400         self.write({"path": path})
401 class FlowControlHandler(RequestHandler):
402     @asynchronous
403     def get(self):
404         self.write("1")
405         self.flush(callback=self.step2)
406     def step2(self):
407         self.write("2")
408     def step3(self):
409         self<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.write("3")
410         self.finish()
411 class MultiHeaderHandler(RequestHandler):
412     def get(self):
413         self.set_header("x-overwrite", "1")
414         self.set_header("X-Overwrite", 2)
415         self.</b></font>add_header("x-multi", 3)
416         self.add_header("X-Multi", "4")
417 class RedirectHandler(RequestHandler):
418     def get(self):
419         if self.get_argument('permanent', None) is not None:
420             self.redirect('/', permanent=int(self.get_argument('permanent')))
421         elif self.get_argument('status', None) is not None:
422             self.redirect('/', status=int(self.get_argument('status')))
423         else:
424             raise Exception("didn't get permanent or status arguments")
425 class EmptyFlushCallbackHandler(RequestHandler):
426     @asynchronous
427     @gen.engine
428     def get(self):
429         yield gen.Task(self.flush)  # empty flush
430         self.write("o")
431         yield self<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.flush()  # flushes the "o"
432         yield self.flush()  # empty flush
433         self.finish("k")
434 class HeaderInjectionHandler(RequestHandler):
435     def</b></font> get(self):
436         try:
437             self.set_header("X-Foo", "foo\r\nX-Bar: baz")
438             raise Exception("Didn't get expected exception")
439         except ValueError as e:
440             if "Unsafe header value" in str(e):
441                 self.finish(b"ok")
442             else:
443                 raise
444 class GetArgumentHandler(RequestHandler):
445     def prepare(self):
446         if self.get_argument('source', None) == 'query':
447             method = self.get_query_argument
448         elif self.get_argument('source', None) == 'body':
449             method = self.get_body_argument
450         else:
451             method = self.get_argument
452         self.finish(method("foo", "default"))
453 class GetArgumentsHandler(RequestHandler):
454     def prepare(self):
455         self.finish(dict(default=self.get_arguments("foo"),
456                          query=self.get_query_arguments("foo"),
457                          body=self.get_body_arguments("foo")))
458 @wsgi_safe
459 class WSGISafeWebTest(WebTestCase):
460     COOKIE_SECRET = "WebTest.COOKIE_SECRET"
461     def get_app_kwargs(self):
462         loader = DictLoader({
463             "linkify.html": "{% module linkify(message) %}",
464             "page.html": """\
465 &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
466 {% for e in entries %}
467 {% module Template("entry.html", entry=e) %}
468 {% end %}
469 &lt;/body&gt;&lt;/html&gt;""",
470             "entry.html": """\
471 {{ set_resources(embedded_css=".entry { margin-bottom: 1em; }", embedded_javascript="js_embed()", css_files=["/base.css", "/foo.css"], javascript_files="/common.js", html_head="&lt;meta&gt;", html_body='&lt;script src="/analytics.js"/&gt;') }}
472 &lt;div class="entry"&gt;...&lt;/div&gt;""",
473         })
474         return dict(template_loader=loader,
475                     autoescape="xhtml_escape",
476                     cookie_secret=self.COOKIE_SECRET)
477     def tearDown(self):
478         super(WSGISafeWebTest, self).tearDown()
479         RequestHandler._template_loaders.clear()
480     def get_handlers(self):
481         urls = [
482             url("/typecheck/(.*)", TypeCheckHandler, name='typecheck'),
483             url("/decode_arg/(.*)", DecodeArgHandler, name='decode_arg'),
484             url("/decode_arg_kw/(?P&lt;arg&gt;.*)", DecodeArgHandler),
485             url("/linkify", LinkifyHandler),
486             url("/uimodule_resources", UIModuleResourceHandler),
487             url("/optional_path/(.+)?", OptionalPathHandler),
488             url("/multi_header", MultiHeaderHandler),
489             url("/redirect", RedirectHandler),
490             url("/web_redirect_permanent", WebRedirectHandler, {"url": "/web_redirect_newpath"}),
491             url("/web_redirect", WebRedirectHandler, {"url": "/web_redirect_newpath", "permanent": False}),
492             url("//web_redirect_double_slash", WebRedirectHandler, {"url": '/web_redirect_newpath'}),
493             url("/header_injection", HeaderInjectionHandler),
494             url("/get_argument", GetArgumentHandler),
495             url("/get_arguments", GetArgumentsHandler),
496         ]
497         return urls
498     def fetch_json(self, *args, **kwargs):
499         response = self.fetch(*args, **kwargs)
500         response.rethrow()
501         return json_decode(response.body)
502     def test_types(self):
503         cookie_value = to_unicode(create_signed_value(self.COOKIE_SECRET,
504                                                       "asdf", "qwer"))
505         response = self.fetch("/typecheck/asdf?foo=bar",
506                               headers={"Cookie": "asdf=" + cookie_value})
507         data = json_decode(response.body)
508         self.assertEqual(data, {})
509         response = self.fetch("/typecheck/asdf?foo=bar", method="POST",
510                               headers={"Cookie": "asdf=" + cookie_value},
511                               body="foo=bar")
512     def test_decode_argument(self):
513         urls = ["/decode_arg/%C3%A9?foo=%C3%A9&amp;encoding=utf-8",
514                 "/decode_arg/%E9?foo=%E9&amp;encoding=latin1",
515                 "/decode_arg_kw/%E9?foo=%E9&amp;encoding=latin1",
516                 ]
517         for req_url in urls:
518             response = self.fetch(req_url)
519             response.rethrow()
520             data = json_decode(response.body)
521             self.assertEqual(data, {u'path': [u'unicode', u'\u00e9'],
522                                     u'query': [u'unicode', u'\u00e9'],
523                                     })
524         response = self.fetch("/decode_arg/%C3%A9?foo=%C3%A9")
525         response.rethrow()
526         data = json_decode(response.body)
527         self.assertEqual(data, {u'path': [u'bytes', u'c3a9'],
528                                 u'query': [u'bytes', u'c3a9'],
529                                 })
530     def test_decode_argument_invalid_unicode(self):
531         with ExpectLog(gen_log, ".*Invalid unicode.*"):
532             response = self.fetch("/typecheck/invalid%FF")
533             self.assertEqual(response.code, 400)
534             response = self.fetch("/typecheck/invalid?foo=%FF")
535             self.assertEqual(response.code, 400)
536     def test_decode_argument_plus(self):
537         urls = ["/decode_arg/1%20%2B%201?foo=1%20%2B%201&amp;encoding=utf-8",
538                 "/decode_arg/1%20+%201?foo=1+%2B+1&amp;encoding=utf-8"]
539         for req_url in urls:
540             response = self.fetch(req_url)
541             response.rethrow()
542             data = json_decode(response.body)
543             self.assertEqual(data, {u'path': [u'unicode', u'1 + 1'],
544                                     u'query': [u'unicode', u'1 + 1'],
545                                     })
546     def test_reverse_url(self):
547         self.assertEqual(self.app.reverse_url('decode_arg', 'foo'),
548                          '/decode_arg/foo')
549         self.assertEqual(self.app.reverse_url('decode_arg', 42),
550                          '/decode_arg/42')
551         self.assertEqual(self.app.reverse_url('decode_arg', b'\xe9'),
552                          '/decode_arg/%E9')
553         self.assertEqual(self.app.reverse_url('decode_arg', u'\u00e9'),
554                          '/decode_arg/%C3%A9')
555         self.assertEqual(self.app.reverse_url('decode_arg', '1 + 1'),
556                          '/decode_arg/1%20%2B%201')
557     def test_uimodule_unescaped(self):
558         response = self.fetch("/linkify")
559         self.assertEqual(response.body,
560                          b"&lt;a href=\"http://example.com\"&gt;http://example.com&lt;/a&gt;")
561     def test_uimodule_resources(self):
562         response = self.fetch("/uimodule_resources")
563         self.assertEqual(response.body, b"""\
564 &lt;html&gt;&lt;head&gt;&lt;link href="/base.css" type="text/css" rel="stylesheet"/&gt;&lt;link href="/foo.css" type="text/css" rel="stylesheet"/&gt;
565 &lt;style type="text/css"&gt;
566 .entry { margin-bottom: 1em; }
567 &lt;/style&gt;
568 &lt;meta&gt;
569 &lt;/head&gt;&lt;body&gt;
570 &lt;div class="entry"&gt;...&lt;/div&gt;
571 &lt;div class="entry"&gt;...&lt;/div&gt;
572 &lt;script src="/common.js" type="text/javascript"&gt;&lt;/script&gt;
573 &lt;script type="text/javascript"&gt;
574 //&lt;![CDATA[
575 js_embed()
576 //]]&gt;
577 &lt;/script&gt;
578 &lt;script src="/analytics.js"/&gt;
579 &lt;/body&gt;&lt;/html&gt;""")
580     def test_optional_path(self):
581         self.assertEqual(self.fetch_json("/optional_path/foo"),
582                          {u"path": u"foo"})
583         self.assertEqual(self.fetch_json("/optional_path/"),
584                          {u"path": None})
585     def test_multi_header(self):
586         response = self.fetch("/multi_header")
587         self.assertEqual(response.headers["x-overwrite"], "2")
588         self.assertEqual(response.headers.get_list("x-multi"), ["3", "4"])
589     def test_redirect(self):
590         response = self.fetch("/redirect?permanent=1", follow_redirects=False)
591         self.assertEqual(response.code, 301)
592         response = self.fetch("/redirect?permanent=0", follow_redirects=False)
593         self.assertEqual(response.code, 302)
594         response = self.fetch("/redirect?status=307", follow_redirects=False)
595         self.assertEqual(response.code, 307)
596     def test_web_redirect(self):
597         response = self.fetch("/web_redirect_permanent", follow_redirects=False)
598         self.assertEqual(response.code, 301)
599         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
600         response = self.fetch("/web_redirect", follow_redirects=False)
601         self.assertEqual(response.code, 302)
602         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
603     def test_web_redirect_double_slash(self):
604         response = self.fetch("//web_redirect_double_slash", follow_redirects=False)
605         self.assertEqual(response.code, 301)
606         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
607     def test_header_injection(self):
608         response = self.fetch("/header_injection")
609         self<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(response.body, b"ok")
610     def test_get_argument(self):
611         response = self.fetch("/get_argument?foo=bar")
612         self.assertEqual(response.body, b"bar")
613         response =</b></font> self.fetch("/get_argument?foo=")
614         self.assertEqual(response.body, b"")
615         response = self.fetch("/get_argument")
616         self.assertEqual(response.body, b"default")
617         body = urllib_parse.urlencode(dict(foo="hello"))
618         response = self.fetch("/get_argument?foo=bar", method="POST", body=body)
619         self.assertEqual(response.body, b"hello")
620         response = self.fetch("/get_arguments?foo=bar",
621                               method="POST", body=body)
622         self.assertEqual(json_decode(response.body),
623                          dict(default=['bar', 'hello'],
624                               query=['bar'],
625                               body=['hello']))
626     def test_get_query_arguments(self):
627         body = urllib_parse.urlencode(dict(foo="hello"))
628         response = self.fetch("/get_argument?source=query&amp;foo=bar",
629         self.assertEqual(response.body, b"bar")
630         response = self.fetch("/get_argument?source=query&amp;foo=",
631                               method="POST", body<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=body)
632         self.assertEqual(response.body, b"")
633         response = self.fetch("/get_argument?source=query",
634                               method="POST", body=body)
635         self.assertEqual(response.body, b"default")
636     def</b></font> test_get_body_arguments(self):
637         body = urllib_parse.urlencode(dict(foo="bar"))
638         response = self.fetch("/get_argument?source=body&amp;foo=hello",
639                               method="POST", body=body)
640         self.assertEqual(response.body, b"bar")
641         body = urllib_parse.urlencode(dict(foo=""))
642         response = self.fetch("/get_argument?source=body&amp;foo=hello",
643                               method="POST", body=body)
644         self.assertEqual(response.body, b"")
645         body = urllib_parse.urlencode(dict())
646         response = self.fetch("/get_argument?source=body&amp;foo=hello",
647                               method="POST", body=body)
648         self.assertEqual(response.body, b"default")
649     def test_no_gzip(self):
650         response = self.fetch('/get_argument')
651         self.assertNotIn('Accept-Encoding', response.headers.get('Vary', ''))
652         self.assertNotIn('gzip', response.headers.get('Content-Encoding', ''))
653 class NonWSGIWebTests(WebTestCase):
654     def get_handlers(self):
655         return [("/flow_control", FlowControlHandler),
656                 ("/empty_flush", EmptyFlushCallbackHandler),
657                 ]
658     def test_flow_control(self):
659         self.assertEqual(self.fetch("/flow_control").body, b"123")
660     def test_empty_flush(self):
661         response = self.fetch("/empty_flush")
662         self.assertEqual(response.body, b"ok")
663 @wsgi_safe
664 class ErrorResponseTest(WebTestCase):
665     def get_handlers(self):
666         class DefaultHandler(RequestHandler):
667             def get(self):
668                 if self.get_argument("status", None):
669                     raise HTTPError(int(self.get_argument("status")))
670                 1 / 0
671         class WriteErrorHandler(RequestHandler):
672             def get(self):
673                 if self.get_argument("status", None):
674                     self.send_error(int(self.get_argument("status")))
675                 else:
676                     1 / 0
677             def write_error(self, status_code, **kwargs):
678                 self.set_header("Content-Type", "text/plain")
679                 if "exc_info" in kwargs:
680                     self.write("Exception: %s" % kwargs["exc_info"][0].__name__)
681                 else:
682                     self.write("Status: %d" % status_code)
683         class FailedWriteErrorHandler(RequestHandler):
684             def get(self):
685                 1 / 0
686             def write_error(self, status_code, **kwargs):
687                 raise Exception("exception in write_error")
688         return [url("/default", DefaultHandler),
689                 url("/write_error", WriteErrorHandler),
690                 url("/failed_write_error", FailedWriteErrorHandler),
691                 ]
692     def test_default(self):
693         with ExpectLog(app_log, "Uncaught exception"):
694             response = self.fetch("/default")
695             self.assertEqual(response.code, 500)
696             self.assertTrue(b"500: Internal Server Error" in response.body)
697             response = self.fetch("/default?status=503")
698             self.assertEqual(response.code, 503)
699             self.assertTrue(b"503: Service Unavailable" in response.body)
700     def test_write_error(self):
701         with ExpectLog(app_log, "Uncaught exception"):
702             response = self.fetch("/write_error")
703             self.assertEqual(response.code, 500)
704             self.assertEqual(b"Exception: ZeroDivisionError", response.body)
705             response = self.fetch("/write_error?status=503")
706             self.assertEqual(response.code, 503)
707             self.assertEqual(b"Status: 503", response.body)
708     def test_failed_write_error(self):
709         with ExpectLog(app_log, "Uncaught exception"):
710             response = self.fetch("/failed_write_error")
711             self.assertEqual(response.code, 500)
712             self.assertEqual(b"", response.body)
713 @wsgi_safe
714 class StaticFileTest(WebTestCase):
715     robots_txt_hash = b"f71d20196d4caf35b6a670db8c70b03d"
716     static_dir = os.path.join(os.path.dirname(__file__), 'static')
717     def get_handlers(self):
718         class StaticUrlHandler(RequestHandler):
719             def get(self, path):
720                 with_v = int(self.get_argument('include_version', 1))
721                 self.write(self.static_url(path, include_version=with_v))
722         class AbsoluteStaticUrlHandler(StaticUrlHandler):
723             include_host = True
724         class OverrideStaticUrlHandler(RequestHandler):
725             def get(self, path):
726                 do_include = bool(self.get_argument("include_host"))
727                 self.include_host = not do_include
728                 regular_url = self.static_url(path)
729                 override_url = self.static_url(path, include_host=do_include)
730                 if override_url == regular_url:
731                     return self.write(str(False))
732                 protocol = self.request.protocol + "://"
733                 protocol_length = len(protocol)
734                 check_regular = regular_url.find(protocol, 0, protocol_length)
735                 check_override = override_url.find(protocol, 0, protocol_length)
736                 if do_include:
737                     result = (check_override == 0 and check_regular == -1)
738                 else:
739                     result = (check_override == -1 and check_regular == 0)
740                 self.write(str(result))
741         return [('/static_url/(.*)', StaticUrlHandler),
742                 ('/abs_static_url/(.*)', AbsoluteStaticUrlHandler),
743                 ('/override_static_url/(.*)', OverrideStaticUrlHandler),
744                 ('/root_static/(.*)', StaticFileHandler, dict(path='/'))]
745     def get_app_kwargs(self):
746         return dict(static_path=relpath('static'))
747     def test_static_files(self):
748         response = self.fetch('/robots.txt')
749         self.assertTrue(b"Disallow: /" in response.body)
750         response = self.fetch('/static/robots.txt')
751         self.assertTrue(b"Disallow: /" in response.body)
752         self.assertEqual(response.headers.get("Content-Type"), "text/plain")
753     def test_static_compressed_files(self):
754         response = self.fetch("/static/sample.xml.gz")
755         self.assertEqual(response.headers.get("Content-Type"),
756                          "application/gzip")
757         response = self.fetch("/static/sample.xml.bz2")
758         self.assertEqual(response.headers.get("Content-Type"),
759                          "application/octet-stream")
760         response = self.fetch("/static/sample.xml")
761         self.assertTrue(response.headers.get("Content-Type")
762                         in set(("text/xml", "application/xml")))
763     def test_static_url(self):
764         response = self.fetch("/static_url/robots.txt")
765         self.assertEqual(response.body,
766                          b"/static/robots.txt?v=" + self.robots_txt_hash)
767     def test_absolute_static_url(self):
768         response = self.fetch("/abs_static_url/robots.txt")
769         self.assertEqual(response.body, (
770             utf8(self.get_url("/")) +
771             b"static/robots.txt?v=" +
772             self.robots_txt_hash
773     def test_relative_version_exclusion(self):
774         response <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.fetch("/static_url/robots.txt?include_version=0")
775         self.assertEqual(response.body, b"/static/robots.txt")
776     def test_absolute_version_exclusion(self):
777         response = self.fetch("/abs_static_url/robots.txt?include_version=0")
778         self.assertEqual(response.body,
779                          utf8(self.</b></font>get_url("/") + "static/robots.txt"))
780     def test_include_host_override(self):
781         self._trigger_include_host_check(False)
782         self._trigger_include_host_check(True)
783     def _trigger_include_host_check(self, include_host):
784         path = "/override_static_url/robots.txt?include_host=%s"
785         response = self.fetch(path % int(include_host))
786         self.assertEqual(response.body, utf8(str(True)))
787     def get_and_head(self, *args, **kwargs):
788         """Performs a GET and HEAD request and returns the GET response.
789         Fails if any ``Content-*`` headers returned by the two requests
790         differ.
791         """
792         head_response = self.fetch(*args, method="HEAD", **kwargs)
793         get_response = self.fetch(*args, method="GET", **kwargs)
794         content_headers = set()
795         for h in itertools.chain(head_response.headers, get_response.headers):
796             if h.startswith('Content-'):
797                 content_headers.add(h)
798         for h in content_headers:
799             self.assertEqual(head_response.headers.get(h),
800                              get_response.headers.get(h),
801                              "%s differs between GET (%s) and HEAD (%s)" %
802                              (h, head_response.headers.get(h),
803                               get_response.headers.get(h)))
804         return get_response
805     def test_static_304_if_modified_since(self):
806         response1 = self.get_and_head("/static/robots.txt")
807         response2 = self.get_and_head("/static/robots.txt", headers={
808             'If-Modified-Since': response1.headers['Last-Modified']})
809         self.assertEqual(response2.code, 304)
810         self.assertTrue('Content-Length' not in response2.headers)
811         self.assertTrue('Last-Modified' not in response2.headers)
812     def test_static_304_if_none_match(self):
813         response1 = self.get_and_head("/static/robots.txt")
814         response2 = self.get_and_head("/static/robots.txt", headers={
815             'If-None-Match': response1.headers['Etag']})
816         self.assertEqual(response2.code, 304)
817     def test_static_if_modified_since_pre_epoch(self):
818         response = self.get_and_head("/static/robots.txt", headers={
819             'If-Modified-Since': 'Fri, 01 Jan 1960 00:00:00 GMT'})
820         self.assertEqual(response.code, 200)
821     def test_static_if_modified_since_time_zone(self):
822         stat = os.stat(relpath('static/robots.txt'))
823         response = self.get_and_head('/static/robots.txt', headers={
824         self.assertEqual(response.code, 200)
825         response = self.get_and_head('/static/robots.txt', headers={
826             'If-Modified-Since': format_timestamp(stat<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.st_mtime + 1)})
827         self.assertEqual(response.code, 304)
828     def test_static_etag(self):
829         response = self.get_and_head('/static/robots.txt')
830         self.assertEqual(utf8(response.headers.get(</b></font>"Etag")),
831                          b'"' + self.robots_txt_hash + b'"')
832     def test_static_with_range(self):
833         response = self.get_and_head('/static/robots.txt', headers={
834             'Range': 'bytes=0-9'})
835         self.assertEqual(response.code, 206)
836         self.assertEqual(response.body, b"User-agent")
837         self.assertEqual(utf8(response.headers.get("Etag")),
838                          b'"' + self.robots_txt_hash + b'"')
839         self.assertEqual(response.headers.get("Content-Length"), "10")
840         self.assertEqual(response.headers.get("Content-Range"),
841                          "bytes 0-9/26")
842     def test_static_with_range_full_file(self):
843         response = self.get_and_head('/static/robots.txt', headers={
844             'Range': 'bytes=0-'})
845         self.assertEqual(response.code, 200)
846         robots_file_path = os.path.join(self.static_dir, "robots.txt")
847         with open(robots_file_path) as f:
848             self.assertEqual(response.body, utf8(f.read()))
849         self.assertEqual(response.headers.get("Content-Length"), "26")
850         self.assertEqual(response.headers.get("Content-Range"), None)
851     def test_static_with_range_full_past_end(self):
852         response = self.get_and_head('/static/robots.txt', headers={
853             'Range': 'bytes=0-10000000'})
854         self.assertEqual(response.code, 200)
855         robots_file_path = os.path.join(self.static_dir, "robots.txt")
856         with open(robots_file_path) as f:
857             self.assertEqual(response.body, utf8(f.read()))
858         self.assertEqual(response.headers.get("Content-Length"), "26")
859         self.assertEqual(response.headers.get("Content-Range"), None)
860     def test_static_with_range_partial_past_end(self):
861         response = self.get_and_head('/static/robots.txt', headers={
862             'Range': 'bytes=1-10000000'})
863         self.assertEqual(response.code, 206)
864         robots_file_path = os.path.join(self.static_dir, "robots.txt")
865         with open(robots_file_path) as f:
866             self.assertEqual(response.body, utf8(f.read()[1:]))
867         self.assertEqual(response.headers.get("Content-Length"), "25")
868         self.assertEqual(response.headers.get("Content-Range"), "bytes 1-25/26")
869     def test_static_with_range_end_edge(self):
870         response = self.get_and_head('/static/robots.txt', headers={
871             'Range': 'bytes=22-'})
872         self.assertEqual(response.body, b": /\n")
873         self.assertEqual(response.headers.get("Content-Length"), "4")
874         self.assertEqual(response.headers.get("Content-Range"),
875                          "bytes 22-25/26")
876     def test_static_with_range_neg_end(self):
877         response = self.get_and_head('/static/robots.txt', headers={
878             'Range': 'bytes=-4'})
879         self.assertEqual(response.body, b": /\n")
880         self.assertEqual(response.headers.get("Content-Length"), "4")
881         self.assertEqual(response.headers.get("Content-Range"),
882                          "bytes 22-25/26")
883     def test_static_invalid_range(self):
884         response = self.get_and_head('/static/robots.txt', headers={
885             'Range': 'asdf'})
886         self.assertEqual(response.code, 200)
887     def test_static_unsatisfiable_range_zero_suffix(self):
888         response = self.get_and_head('/static/robots.txt', headers={
889             'Range': 'bytes=-0'})
890         self.assertEqual(response.headers.get("Content-Range"),
891                          "bytes */26")
892         self.assertEqual(response.code, 416)
893     def test_static_unsatisfiable_range_invalid_start(self):
894         response = self.get_and_head('/static/robots.txt', headers={
895             'Range': 'bytes=26'})
896         self.assertEqual(response.code, 416)
897         self.assertEqual(response.headers.get("Content-Range"),
898                          "bytes */26")
899     def test_static_head(self):
900         response = self.fetch('/static/robots.txt', method='HEAD')
901         self.assertEqual(response.code, 200)
902         self.assertEqual(response.body, b'')
903         self.assertEqual(response.headers['Content-Length'], '26')
904         self.assertEqual(utf8(response.headers['Etag']),
905                          b'"' + self.robots_txt_hash + b'"')
906     def test_static_head_range(self):
907         response = self.fetch('/static/robots.txt', method='HEAD',
908                               headers={'Range': 'bytes=1-4'})
909         self.assertEqual(response.code, 206)
910         self.assertEqual(response.body, b'')
911         self.assertEqual(response.headers['Content-Length'], '4')
912         self.assertEqual(utf8(response.headers['Etag']),
913                          b'"' + self.robots_txt_hash + b'"')
914         response = self.get_and_head('/static/robots.txt', headers={
915             'Range': 'bytes=1-4',
916             'If-None-Match': b'"' + self<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.robots_txt_hash + b'"'})
917         self.assertEqual(response.code, 304)
918         self.assertEqual(response.body, b'')
919         self.assertTrue('Content-Length' not in response.headers)
920         self.assertEqual(</b></font>utf8(response.headers['Etag']),
921                          b'"' + self.robots_txt_hash + b'"')
922     def test_static_404(self):
923         response = self.get_and_head('/static/blarg')
924         self.assertEqual(response.code, 404)
925     def test_path_traversal_protection(self):
926         self.http_client.close()
927         self.http_client = SimpleAsyncHTTPClient()
928         with ExpectLog(gen_log, ".*not in root static directory"):
929             response = self.get_and_head('/static/../static_foo.txt')
930         self.assertEqual(response.code, 403)
931     @unittest.skipIf(os.name != 'posix', 'non-posix OS')
932     def test_root_static_path(self):
933         path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
934                             'static/robots.txt')
935         response = self.get_and_head('/root_static' + urllib_parse.quote(path))
936         self.assertEqual(response.code, 200)
937 @wsgi_safe
938 class StaticDefaultFilenameTest(WebTestCase):
939     def get_app_kwargs(self):
940         return dict(static_path=relpath('static'),
941                     static_handler_args=dict(default_filename='index.html'))
942     def get_handlers(self):
943         return []
944         response = self.fetch('/static/dir/', follow_redirects=False)
945         self.assertEqual(response.code, 200)
946         self.assertEqual(b'this is the index\n', response.<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>body)
947     def test_static_default_redirect(self):
948         response = self.fetch('/static/dir', follow_redirects=False)
949         self.assertEqual(response.code, 301)
950         self.assertTrue(response.headers['Location'].endswith(</b></font>'/static/dir/'))
951 @wsgi_safe
952 class StaticFileWithPathTest(WebTestCase):
953     def get_app_kwargs(self):
954         return dict(static_path=relpath('static'),
955                     static_handler_args=dict(default_filename='index.html'))
956     def get_handlers(self):
957         return [("/foo/(.*)", StaticFileHandler, {
958             "path": relpath("templates/"),
959         })]
960     def test_serve(self):
961         response = self.fetch("/foo/utf8.html")
962         self.assertEqual(response.body, b"H\xc3\xa9llo\n")
963 @wsgi_safe
964 class CustomStaticFileTest(WebTestCase):
965     def get_handlers(self):
966         class MyStaticFileHandler(StaticFileHandler):
967             @classmethod
968             def make_static_url(cls, settings, path):
969                 version_hash = cls.get_version(settings, path)
970                 extension_index = path.rindex('.')
971                 before_version = path[:extension_index]
972                 after_version = path[(extension_index + 1):]
973                 return '/static/%s.%s.%s' % (before_version, version_hash,
974                                              after_version)
975             def parse_url_path(self, url_path):
976                 extension_index = url_path.rindex('.')
977                 version_index = url_path.rindex('.', 0, extension_index)
978                 return '%s%s' % (url_path[:version_index],
979                                  url_path[extension_index:])
980             @classmethod
981             def get_absolute_path(cls, settings, path):
982                 return 'CustomStaticFileTest:' + path
983             def validate_absolute_path(self, root, absolute_path):
984                 return absolute_path
985             @classmethod
986             def get_content(self, path, start=None, end=None):
987                 assert start is None and end is None
988                 if path == 'CustomStaticFileTest:foo.txt':
989                     return b'bar'
990                 raise Exception("unexpected path %r" % path)
991             def get_content_size(self):
992                 if self.absolute_path == 'CustomStaticFileTest:foo.txt':
993                     return 3
994                 raise Exception("unexpected path %r" % self.absolute_path)
995             def get_modified_time(self):
996                 return None
997             @classmethod
998             def get_version(cls, settings, path):
999                 return "42"
1000         class StaticUrlHandler(RequestHandler):
1001             def get(self, path):
1002                 self.write(self.static_url(path))
1003         self.static_handler_class = MyStaticFileHandler
1004         return [("/static_url/(.*)", StaticUrlHandler)]
1005     def get_app_kwargs(self):
1006         return dict(static_path="dummy",
1007                     static_handler_class=self.static_handler_class)
1008     def test_serve(self):
1009         response = self.fetch("/static/foo.42.txt")
1010         self.assertEqual(response.body, b"bar")
1011     def test_static_url(self):
1012         with ExpectLog(gen_log, "Could not open static file", required=False):
1013             response = self.fetch("/static_url/foo.txt")
1014             self.assertEqual(response.body, b"/static/foo.42.txt")
1015 @wsgi_safe
1016 class HostMatchingTest(WebTestCase):
1017     class Handler(RequestHandler):
1018         def initialize(self, reply):
1019             self.reply = reply
1020         def get(self):
1021             self.write(self.reply)
1022     def get_handlers(self):
1023         return [("/foo", HostMatchingTest.Handler, {"reply": "wildcard"})]
1024     def test_host_matching(self):
1025         self.app.add_handlers("www.example.com",
1026                               [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
1027         self.app.add_handlers(r"www\.example\.com",
1028                               [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
1029         self.app.add_handlers("www.example.com",
1030                               [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
1031         self.app.add_handlers("www.e.*e.com",
1032                               [("/baz", HostMatchingTest.Handler, {"reply": "[3]"})])
1033         response = self.fetch("/foo")
1034         self.assertEqual(response.body, b"wildcard")
1035         response = self.fetch("/bar")
1036         self.assertEqual(response.code, 404)
1037         response = self.fetch("/baz")
1038         self.assertEqual(response.code, 404)
1039         response = self.fetch("/foo", headers={'Host': 'www.example.com'})
1040         self.assertEqual(response.body, b"[0]")
1041         response = self.fetch("/bar", headers={'Host': 'www.example.com'})
1042         self.assertEqual(response.body, b"[1]")
1043         response = self.fetch("/baz", headers={'Host': 'www.example.com'})
1044         self.assertEqual(response.body, b"[2]")
1045         response = self.fetch("/baz", headers={'Host': 'www.exe.com'})
1046         self.assertEqual(response.body, b"[3]")
1047 @wsgi_safe
1048 class DefaultHostMatchingTest(WebTestCase):
1049     def get_handlers(self):
1050         return []
1051     def get_app_kwargs(self):
1052         return {'default_host': "www.example.com"}
1053     def test_default_host_matching(self):
1054         self.app.add_handlers("www.example.com",
1055                               [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
1056         self.app.add_handlers(r"www\.example\.com",
1057                               [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
1058         self.app.add_handlers("www.test.com",
1059                               [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
1060         response = self.fetch("/foo")
1061         self.assertEqual(response.body, b"[0]")
1062         response = self.fetch("/bar")
1063         self.assertEqual(response.body, b"[1]")
1064         response = self.fetch("/baz")
1065         self.assertEqual(response.code, 404)
1066         response = self.fetch("/foo", headers={"X-Real-Ip": "127.0.0.1"})
1067         self.assertEqual(response.code, 404)
1068         self.app.default_host = "www.test.com"
1069         response = self.fetch("/baz")
1070         self.assertEqual(response.body, b"[2]")
1071 @wsgi_safe
1072 class NamedURLSpecGroupsTest(WebTestCase):
1073     def get_handlers(self):
1074         class EchoHandler(RequestHandler):
1075             def get(self, path):
1076                 self.write(path)
1077         return [("/str/(?P&lt;path&gt;.*)", EchoHandler),
1078                 (u"/unicode/(?P&lt;path&gt;.*)", EchoHandler)]
1079     def test_named_urlspec_groups(self):
1080         response = self.fetch("/str/foo")
1081         self.assertEqual(response.body, b"foo")
1082         response = self.fetch("/unicode/bar")
1083         self.assertEqual(response.body, b"bar")
1084 @wsgi_safe
1085 class ClearHeaderTest(SimpleHandlerTestCase):
1086     class Handler(RequestHandler):
1087         def get(self):
1088             self.set_header("h1", "foo")
1089             self.set_header("h2", "bar")
1090             self.clear_header("h1")
1091             self.clear_header("nonexistent")
1092     def test_clear_header(self):
1093         response = self.fetch("/")
1094         self.assertTrue("h1" not in response.headers)
1095         self.assertEqual(response.headers["h2"], "bar")
1096 class Header204Test(SimpleHandlerTestCase):
1097     class Handler(RequestHandler):
1098         def get(self):
1099             self.set_status(204)
1100             self.finish()
1101     def test_204_headers(self):
1102         response = self.fetch('/')
1103         self.assertEqual(response.code, 204)
1104         self.assertNotIn("Content-Length", response.headers)
1105         self.assertNotIn("Transfer-Encoding", response.headers)
1106 @wsgi_safe
1107 class Header304Test(SimpleHandlerTestCase):
1108     class Handler(RequestHandler):
1109         def get(self):
1110             self.set_header("Content-Language", "en_US")
1111             self.write("hello")
1112     def test_304_headers(self):
1113         response1 = self.fetch('/')
1114         self.assertEqual(response1.headers["Content-Length"], "5")
1115         self.assertEqual(response1.headers["Content-Language"], "en_US")
1116         response2 = self.fetch('/', headers={
1117             'If-None-Match': response1.headers["Etag"]})
1118         self.assertEqual(response2.code, 304)
1119         self.assertTrue("Content-Length" not in response2.headers)
1120         self.assertTrue("Content-Language" not in response2.headers)
1121         self.assertTrue("Transfer-Encoding" not in response2.headers)
1122 @wsgi_safe
1123 class StatusReasonTest(SimpleHandlerTestCase):
1124     class Handler(RequestHandler):
1125         def get(self):
1126             reason = self.request.arguments.get('reason', [])
1127             self.set_status(int(self.get_argument('code')),
1128                             reason=reason[0] if reason else None)
1129     def get_http_client(self):
1130         return SimpleAsyncHTTPClient(io_loop=self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.io_loop)
1131     def test_status(self):
1132         response = self.fetch("/?code=304")
1133         self.assertEqual(response.code, 304)
1134         self.assertEqual(response.reason, "Not Modified")
1135         response = self.fetch("/?code=304&amp;reason=Foo")
1136         self.assertEqual(response.</b></font>code, 304)
1137         self.assertEqual(response.reason, "Foo")
1138         response = self.fetch("/?code=682&amp;reason=Bar")
1139         self.assertEqual(response.code, 682)
1140         self.assertEqual(response.reason, "Bar")
1141         with ExpectLog(app_log, 'Uncaught exception'):
1142             response = self.fetch("/?code=682")
1143         self.assertEqual(response.code, 500)
1144 @wsgi_safe
1145 class DateHeaderTest(SimpleHandlerTestCase):
1146     class Handler(RequestHandler):
1147         def get(self):
1148             self.write("hello")
1149     def test_date_header(self):
1150         response = self.fetch('/')
1151         header_date = datetime.datetime(
1152             *email.utils.parsedate(response.headers['Date'])[:6])
1153         self.assertTrue(header_date - datetime.datetime.utcnow() &lt;
1154                         datetime.timedelta(seconds=2))
1155 @wsgi_safe
1156 class RaiseWithReasonTest(SimpleHandlerTestCase):
1157     class Handler(RequestHandler):
1158         def get(self):
1159             raise HTTPError(682, reason="Foo")
1160     def get_http_client(self):
1161         return SimpleAsyncHTTPClient(io_loop=self.<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>io_loop)
1162     def test_raise_with_reason(self):
1163         response = self.fetch("/")
1164         self.assertEqual(response.code, 682)
1165         self.assertEqual(response.reason, "Foo")
1166         self.</b></font>assertIn(b'682: Foo', response.body)
1167     def test_httperror_str(self):
1168         self.assertEqual(str(HTTPError(682, reason="Foo")), "HTTP 682: Foo")
1169     def test_httperror_str_from_httputil(self):
1170         self.assertEqual(str(HTTPError(682)), "HTTP 682: Unknown")
1171 @wsgi_safe
1172 class ErrorHandlerXSRFTest(WebTestCase):
1173     def get_handlers(self):
1174         return [('/error', ErrorHandler, dict(status_code=417))]
1175     def get_app_kwargs(self):
1176         return dict(xsrf_cookies=True)
1177     def test_error_xsrf(self):
1178         response = self.fetch('/error', method='POST', body='')
1179         self<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(response.code, 417)
1180     def test_404_xsrf(self):
1181         response = self.fetch('/404', method='POST', body='')
1182         self.assertEqual(response.</b></font>code, 404)
1183 @wsgi_safe
1184 class GzipTestCase(SimpleHandlerTestCase):
1185     class Handler(RequestHandler):
1186         def get(self):
1187             for v in self.get_arguments('vary'):
1188                 self.add_header('Vary', v)
1189             self.write('hello world' + ('!' * GZipContentEncoding.MIN_LENGTH))
1190     def get_app_kwargs(self):
1191         return dict(
1192             gzip=True,
1193             static_path=os.path.join(os.path.dirname(__file__), 'static'))
1194     def assert_compressed(self, response):
1195         self.assertEqual(
1196             response.headers.get(
1197                 'Content-Encoding',
1198                 response.headers.get('X-Consumed-Content-Encoding')),
1199     def test_gzip(self):
1200         response <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.fetch('/')
1201         self.assert_compressed(response)
1202         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1203     def test_gzip_static(self):
1204         response =</b></font> self.fetch('/robots.txt')
1205         self.assert_compressed(response)
1206         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1207     def test_gzip_not_requested(self):
1208         response = self.fetch('/', use_gzip=False)
1209         self.assertNotIn('Content-Encoding', response.headers)
1210         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1211     def test_vary_already_present(self):
1212         response = self.fetch('/?vary=Accept-Language')
1213         self<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assert_compressed(response)
1214         self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
1215                          ['Accept-Language'</b></font>, 'Accept-Encoding'])
1216     def test_vary_already_present_multiple(self):
1217         response = self.fetch('/?vary=Accept-Language&amp;vary=Cookie')
1218         self.assert_compressed(response)
1219         self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
1220                          ['Accept-Language', 'Cookie', 'Accept-Encoding'])
1221 @wsgi_safe
1222 class PathArgsInPrepareTest(WebTestCase):
1223     class Handler(RequestHandler):
1224         def prepare(self):
1225             self.write(dict(args=self.path_args, kwargs=self.path_kwargs))
1226         def get(self, path):
1227             assert path == 'foo'
1228             self.finish()
1229     def get_handlers(self):
1230         return [('/pos/(.*)', self.Handler),
1231                 ('/kw/(?P&lt;path&gt;.*)', self.Handler)]
1232     def test_pos(self):
1233         response = self.fetch('/pos/foo')
1234         response.rethrow()
1235         data = json_decode(response.body)
1236         self.assertEqual(data, {'args': ['foo'], 'kwargs': {}})
1237     def test_kw(self):
1238         response = self.fetch('/kw/foo')
1239         response.rethrow()
1240         data = json_decode(response.body)
1241         self.assertEqual(data, {'args': [], 'kwargs': {'path': 'foo'}})
1242 @wsgi_safe
1243 class ClearAllCookiesTest(SimpleHandlerTestCase):
1244     class Handler(RequestHandler):
1245         def get(self):
1246             self.clear_all_cookies()
1247             self.write('ok')
1248     def test_clear_all_cookies(self):
1249         response = self.fetch('/', headers={'Cookie': 'foo=bar; baz=xyzzy'})
1250         set_cookies = sorted(response.headers.get_list('Set-Cookie'))
1251         self.assertTrue(set_cookies[0].startswith('baz=;') or
1252                         set_cookies[0].startswith('baz="";'))
1253         self.assertTrue(set_cookies[1].startswith('foo=;') or
1254                         set_cookies[1].startswith('foo="";'))
1255 class PermissionError(Exception):
1256     pass
1257 @wsgi_safe
1258 class ExceptionHandlerTest(SimpleHandlerTestCase):
1259     class Handler(RequestHandler):
1260         def get(self):
1261             exc = self.get_argument('exc')
1262             if exc == 'http':
1263                 raise HTTPError(410, "no longer here")
1264             elif exc == 'zero':
1265                 1 / 0
1266             elif exc == 'permission':
1267                 raise PermissionError('not allowed')
1268         def write_error(self, status_code, **kwargs):
1269             if 'exc_info' in kwargs:
1270                 typ, value, tb = kwargs['exc_info']
1271                 if isinstance(value, PermissionError):
1272                     self.set_status(403)
1273                     self.write('PermissionError')
1274                     return
1275             RequestHandler.write_error(self, status_code, **kwargs)
1276         def log_exception(self, typ, value, tb):
1277             if isinstance(value, PermissionError):
1278                 app_log.warning('custom logging for PermissionError: %s',
1279                                 value.args[0])
1280             else:
1281                 RequestHandler.log_exception(self, typ, value, tb)
1282     def test_http_error(self):
1283         with ExpectLog(gen_log, '.*no longer here'):
1284             response = self.fetch('/?exc=http')
1285             self.assertEqual(response.code, 410)
1286     def test_unknown_error(self):
1287         with ExpectLog(app_log, 'Uncaught exception'):
1288             response = self.fetch('/?exc=zero')
1289             self.assertEqual(response.code, 500)
1290     def test_known_error(self):
1291         with ExpectLog(app_log,
1292                        'custom logging for PermissionError: not allowed'):
1293             response = self.fetch('/?exc=permission')
1294             self.assertEqual(response.code, 403)
1295 @wsgi_safe
1296 class BuggyLoggingTest(SimpleHandlerTestCase):
1297     class Handler(RequestHandler):
1298         def get(self):
1299             1 / 0
1300         def log_exception(self, typ, value, tb):
1301             1 / 0
1302     def test_buggy_log_exception(self):
1303         with ExpectLog(app_log, '.*'):
1304             self.fetch('/')
1305 @wsgi_safe
1306 class UIMethodUIModuleTest(SimpleHandlerTestCase):
1307     """Test that UI methods and modules are created correctly and
1308     associated with the handler.
1309     """
1310     class Handler(RequestHandler):
1311         def get(self):
1312             self.render('foo.html')
1313         def value(self):
1314             return self.get_argument("value")
1315     def get_app_kwargs(self):
1316         def my_ui_method(handler, x):
1317             return "In my_ui_method(%s) with handler value %s." % (
1318                 x, handler.value())
1319         class MyModule(UIModule):
1320             def render(self, x):
1321                 return "In MyModule(%s) with handler value %s." % (
1322                     x, self.handler.value())
1323         loader = DictLoader({
1324             'foo.html': '{{ my_ui_method(42) }} {% module MyModule(123) %}',
1325         })
1326         return dict(template_loader=loader,
1327                     ui_methods={'my_ui_method': my_ui_method},
1328                     ui_modules={'MyModule': MyModule})
1329     def tearDown(self):
1330         super(UIMethodUIModuleTest, self).tearDown()
1331         RequestHandler._template_loaders.clear()
1332     def test_ui_method(self):
1333         response = self.fetch('/?value=asdf')
1334         self.assertEqual(response.body,
1335                          b'In my_ui_method(42) with handler value asdf. '
1336                          b'In MyModule(123) with handler value asdf.')
1337 @wsgi_safe
1338 class GetArgumentErrorTest(SimpleHandlerTestCase):
1339     class Handler(RequestHandler):
1340         def get(self):
1341             try:
1342                 self.get_argument('foo')
1343                 self.write({})
1344             except MissingArgumentError as e:
1345                 self.write({'arg_name': e.arg_name,
1346                             'log_message': e.log_message})
1347     def test_catch_error(self):
1348         response = self.fetch('/')
1349         self.assertEqual(json_decode(response.body),
1350                          {'arg_name': 'foo',
1351                           'log_message': 'Missing argument foo'})
1352 class MultipleExceptionTest(SimpleHandlerTestCase):
1353     class Handler(RequestHandler):
1354         exc_count = 0
1355         @asynchronous
1356         def get(self):
1357             from salt.ext.tornado.ioloop import IOLoop
1358             IOLoop.current().add_callback(lambda: 1 / 0)
1359             IOLoop.current().add_callback(lambda: 1 / 0)
1360         def log_exception(self, typ, value, tb):
1361             MultipleExceptionTest.Handler.exc_count += 1
1362     def test_multi_exception(self):
1363         response = self.fetch('/')
1364         self.assertEqual(response.code, 500)
1365         response = self.fetch('/')
1366         self.assertEqual(response.code, 500)
1367         self.assertGreater(MultipleExceptionTest.Handler.exc_count, 2)
1368 @wsgi_safe
1369 class SetLazyPropertiesTest(SimpleHandlerTestCase):
1370     class Handler(RequestHandler):
1371         def prepare(self):
1372             self.current_user = 'Ben'
1373             self.locale = locale.get('en_US')
1374         def get_user_locale(self):
1375             raise NotImplementedError()
1376         def get_current_user(self):
1377             raise NotImplementedError()
1378         def get(self):
1379             self.write('Hello %s (%s)' % (self.current_user, self.locale.code))
1380     def test_set_properties(self):
1381         response = self.fetch('/')
1382         self.assertEqual(response.body, b'Hello Ben (en_US)')
1383 @wsgi_safe
1384 class GetCurrentUserTest(WebTestCase):
1385     def get_app_kwargs(self):
1386         class WithoutUserModule(UIModule):
1387             def render(self):
1388                 return ''
1389         class WithUserModule(UIModule):
1390             def render(self):
1391                 return str(self.current_user)
1392         loader = DictLoader({
1393             'without_user.html': '',
1394             'with_user.html': '{{ current_user }}',
1395             'without_user_module.html': '{% module WithoutUserModule() %}',
1396             'with_user_module.html': '{% module WithUserModule() %}',
1397         })
1398         return dict(template_loader=loader,
1399                     ui_modules={'WithUserModule': WithUserModule,
1400                                 'WithoutUserModule': WithoutUserModule})
1401     def tearDown(self):
1402         super(GetCurrentUserTest, self).tearDown()
1403         RequestHandler._template_loaders.clear()
1404     def get_handlers(self):
1405         class CurrentUserHandler(RequestHandler):
1406             def prepare(self):
1407                 self.has_loaded_current_user = False
1408             def get_current_user(self):
1409                 self.has_loaded_current_user = True
1410                 return ''
1411         class WithoutUserHandler(CurrentUserHandler):
1412             def get(self):
1413                 self.render_string('without_user.html')
1414                 self.finish(str(self.has_loaded_current_user))
1415         class WithUserHandler(CurrentUserHandler):
1416             def get(self):
1417                 self.render_string('with_user.html')
1418                 self.finish(str(self.has_loaded_current_user))
1419         class CurrentUserModuleHandler(CurrentUserHandler):
1420             def get_template_namespace(self):
1421                 return self.ui
1422         class WithoutUserModuleHandler(CurrentUserModuleHandler):
1423             def get(self):
1424                 self.render_string('without_user_module.html')
1425                 self.finish(str(self.has_loaded_current_user))
1426         class WithUserModuleHandler(CurrentUserModuleHandler):
1427             def get(self):
1428                 self.render_string('with_user_module.html')
1429                 self.finish(str(self.has_loaded_current_user))
1430         return [('/without_user', WithoutUserHandler),
1431                 ('/with_user', WithUserHandler),
1432                 ('/without_user_module', WithoutUserModuleHandler),
1433                 ('/with_user_module', WithUserModuleHandler)]
1434     @unittest.skip('needs fix')
1435     def test_get_current_user_is_lazy(self):
1436         response = self.fetch('/without_user')
1437         self.assertEqual(response.body, b'False')
1438     def test_get_current_user_works(self):
1439         response = self.fetch('/with_user')
1440         self.assertEqual(response.body, b'True')
1441     def test_get_current_user_from_ui_module_is_lazy(self):
1442         response = self.fetch('/without_user_module')
1443         self.assertEqual(response.body, b'False')
1444     def test_get_current_user_from_ui_module_works(self):
1445         response = self.fetch('/with_user_module')
1446         self.assertEqual(response.body, b'True')
1447 @wsgi_safe
1448 class UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):
1449     class Handler(RequestHandler):
1450         pass
1451     def test_unimplemented_standard_methods(self):
1452         for method in ['HEAD', 'GET', 'DELETE', 'OPTIONS']:
1453             response = self.fetch('/', method=method)
1454             self.assertEqual(response.code, 405)
1455         for method in ['POST', 'PUT']:
1456             response = self.fetch('/', method=method, body=b'')
1457             self.assertEqual(response.code, 405)
1458 class UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):
1459     class Handler(RequestHandler):
1460         def other(self):
1461             self.write('other')
1462     def test_unimplemented_patch(self):
1463         response = self.fetch('/', method='PATCH', body=b'')
1464         self.assertEqual(response.code, 405)
1465     def test_unimplemented_other(self):
1466         response = self.fetch('/', method='OTHER',
1467                               allow_nonstandard_methods=True)
1468         self.assertEqual(response.code, 405)
1469 @wsgi_safe
1470 class AllHTTPMethodsTest(SimpleHandlerTestCase):
1471     class Handler(RequestHandler):
1472         def method(self):
1473             self.write(self.request.method)
1474         get = delete = options = post = put = method
1475         response = self.fetch('/', method='HEAD')
1476         self.assertEqual(response.body, b'')
1477         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>for method in ['GET', 'DELETE', 'OPTIONS']:
1478             response = self.fetch('/', method=method)
1479             self.assertEqual(response.body, utf8(method))
1480         for method in ['POST', 'PUT']:
1481             response = self.fetch('/', method=method, body=b'')
1482             self.assertEqual(response.body, utf8(</b></font>method))
1483 class PatchMethodTest(SimpleHandlerTestCase):
1484     class Handler(RequestHandler):
1485         SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)
1486         def patch(self):
1487             self.write('patch')
1488         def other(self):
1489             self.write('other')
1490     def test_patch(self):
1491         response = self.fetch('/', method='PATCH', body=b'')
1492         self.assertEqual(response.body, b'patch')
1493     def test_other(self):
1494         response = self.fetch('/', method='OTHER',
1495                               allow_nonstandard_methods=True)
1496         self.assertEqual(response.body, b'other')
1497 @wsgi_safe
1498 class FinishInPrepareTest(SimpleHandlerTestCase):
1499     class Handler(RequestHandler):
1500         def prepare(self):
1501             self.finish('done')
1502         def get(self):
1503             raise Exception('should not reach this method')
1504     def test_finish_in_prepare(self):
1505         response = self.fetch('/')
1506         self.assertEqual(response.body, b'done')
1507 @wsgi_safe
1508 class Default404Test(WebTestCase):
1509     def get_handlers(self):
1510         return [('/foo', RequestHandler)]
1511     def test_404(self):
1512         response = self.fetch('/')
1513         self.assertEqual(response.code, 404)
1514         self.assertEqual(response.body,
1515                          b'&lt;html&gt;&lt;title&gt;404: Not Found&lt;/title&gt;'
1516                          b'&lt;body&gt;404: Not Found&lt;/body&gt;&lt;/html&gt;')
1517 @wsgi_safe
1518 class Custom404Test(WebTestCase):
1519     def get_handlers(self):
1520         return [('/foo', RequestHandler)]
1521     def get_app_kwargs(self):
1522         class Custom404Handler(RequestHandler):
1523             def get(self):
1524                 self.set_status(404)
1525                 self.write('custom 404 response')
1526         return dict(default_handler_class=Custom404Handler)
1527     def test_404(self):
1528         response = self.fetch('/')
1529         self.assertEqual(response.code, 404)
1530         self.assertEqual(response.body, b'custom 404 response')
1531 @wsgi_safe
1532 class DefaultHandlerArgumentsTest(WebTestCase):
1533     def get_handlers(self):
1534         return [('/foo', RequestHandler)]
1535     def get_app_kwargs(self):
1536         return dict(default_handler_class=ErrorHandler,
1537                     default_handler_args=dict(status_code=403))
1538     def test_403(self):
1539         response = self.fetch('/')
1540         self.assertEqual(response.code, 403)
1541 @wsgi_safe
1542 class HandlerByNameTest(WebTestCase):
1543     def get_handlers(self):
1544         return [('/hello1', HelloHandler),
1545                 ('/hello2', 'tornado.test.web_test.HelloHandler'),
1546                 url('/hello3', 'tornado.test.web_test.HelloHandler'),
1547                 ]
1548     def test_handler_by_name(self):
1549         resp = self.fetch('/hello1')
1550         self.assertEqual(resp.body, b'hello')
1551         resp = self.fetch('/hello2')
1552         self.assertEqual(resp.body, b'hello')
1553         resp = self.fetch('/hello3')
1554         self.assertEqual(resp.body, b'hello')
1555 class StreamingRequestBodyTest(WebTestCase):
1556     def get_handlers(self):
1557         @stream_request_body
1558         class StreamingBodyHandler(RequestHandler):
1559             def initialize(self, test):
1560                 self.test = test
1561             def prepare(self):
1562                 self.test.prepared.set_result(None)
1563             def data_received(self, data):
1564                 self.test.data.set_result(data)
1565             def get(self):
1566                 self.test.finished.set_result(None)
1567                 self.write({})
1568         @stream_request_body
1569         class EarlyReturnHandler(RequestHandler):
1570             def prepare(self):
1571                 raise HTTPError(401)
1572         @stream_request_body
1573         class CloseDetectionHandler(RequestHandler):
1574             def initialize(self, test):
1575                 self.test = test
1576             def on_connection_close(self):
1577                 super(CloseDetectionHandler, self).on_connection_close()
1578                 self.test.close_future.set_result(None)
1579         return [('/stream_body', StreamingBodyHandler, dict(test=self)),
1580                 ('/early_return', EarlyReturnHandler),
1581                 ('/close_detection', CloseDetectionHandler, dict(test=self))]
1582     def connect(self, url, connection_close):
1583         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
1584         s.connect(("127.0.0.1", self.get_http_port()))
1585         stream = IOStream(s, io_loop=self.io_loop)
1586         stream.write(b"GET " + url + b" HTTP/1.1\r\n")
1587         if connection_close:
1588             stream.write(b"Connection: close\r\n")
1589         stream.write(b"Transfer-Encoding: chunked\r\n\r\n")
1590         return stream
1591     @gen_test
1592     def test_streaming_body(self):
1593         self.prepared = Future()
1594         self.data = Future()
1595         self.finished = Future()
1596         stream = self.connect(b"/stream_body", connection_close=True)
1597         yield self.prepared
1598         stream.write(b"4\r\nasdf\r\n")
1599         data = yield self.data
1600         self.assertEqual(data, b"asdf")
1601         self.data = Future()
1602         stream.write(b"4\r\nqwer\r\n")
1603         data = yield self.data
1604         self.assertEquals(data, b"qwer")
1605         stream.write(b"0\r\n\r\n")
1606         yield self.finished
1607         data = yield gen.Task(stream.read_until_close)
1608         self.assertTrue(data.endswith(b"{}"))
1609         stream.close()
1610     @gen_test
1611     def test_early_return(self):
1612         stream = self.connect(b"/early_return", connection_close=False)
1613         data = yield gen.Task(stream.read_until_close)
1614         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
1615     @gen_test
1616     def test_early_return_with_data(self):
1617         stream = self.connect(b"/early_return", connection_close=False)
1618         stream.write(b"4\r\nasdf\r\n")
1619         data = yield gen.Task(stream.read_until_close)
1620         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
1621     @gen_test
1622     def test_close_during_upload(self):
1623         self.close_future = Future()
1624         stream = self.connect(b"/close_detection", connection_close=False)
1625         stream.close()
1626         yield self.close_future
1627 @stream_request_body
1628 class BaseFlowControlHandler(RequestHandler):
1629     def initialize(self, test):
1630         self.test = test
1631         self.method = None
1632         self.methods = []
1633     @contextlib.contextmanager
1634     def in_method(self, method):
1635         if self.method is not None:
1636             self.test.fail("entered method %s while in %s" %
1637                            (method, self.method))
1638         self.method = method
1639         self.methods.append(method)
1640         try:
1641             yield
1642         finally:
1643             self.method = None
1644     @gen.coroutine
1645     def prepare(self):
1646         self.methods.append('prepare')
1647         yield gen<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Task(IOLoop.current().add_callback)
1648     @gen.coroutine
1649     def post(self):
1650         with self.in_method('post'):
1651             yield gen.</b></font>Task(IOLoop.current().add_callback)
1652         self.write(dict(methods=self.methods))
1653 class BaseStreamingRequestFlowControlTest(object):
1654     def get_httpserver_options(self):
1655         return dict(chunk_size=10, decompress_request=True)
1656     def get_http_client(self):
1657         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1658     def test_flow_control_fixed_body(self):
1659         response = self.fetch('/', body='abcdefghijklmnopqrstuvwxyz',
1660                               method='POST')
1661         response.rethrow()
1662         self.assertEqual(json_decode(response.body),
1663                          dict(methods=['prepare', 'data_received',
1664                                        'data_received', 'data_received',
1665                                        'post']))
1666     def test_flow_control_chunked_body(self):
1667         chunks = [b'abcd', b'efgh', b'ijkl']
1668         @gen.coroutine
1669         def body_producer(write):
1670             for i in chunks:
1671                 yield write(i)
1672         response = self.fetch('/', body_producer=body_producer, method='POST')
1673         response.rethrow()
1674         self.assertEqual(json_decode(response.body),
1675                          dict(methods=['prepare', 'data_received',
1676                                        'data_received', 'data_received',
1677                                        'post']))
1678     def test_flow_control_compressed_body(self):
1679         bytesio = BytesIO()
1680         gzip_file.write(b'abcdefghijklmnopqrstuvwxyz')
1681         gzip_file.close()
1682         compressed_body <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= bytesio.getvalue()
1683         response = self.fetch('/', body=compressed_body, method='POST',
1684                               headers={'Content-Encoding': 'gzip'})
1685         response.rethrow()
1686         self.</b></font>assertEqual(json_decode(response.body),
1687                          dict(methods=['prepare', 'data_received',
1688                                        'data_received', 'data_received',
1689                                        'post']))
1690 class DecoratedStreamingRequestFlowControlTest(
1691         BaseStreamingRequestFlowControlTest,
1692         WebTestCase):
1693     def get_handlers(self):
1694         class DecoratedFlowControlHandler(BaseFlowControlHandler):
1695             @gen.coroutine
1696             def data_received(self, data):
1697                 with self.in_method('data_received'):
1698                     yield gen.Task(IOLoop.current().add_callback)
1699         return [('/', DecoratedFlowControlHandler, dict(test=self))]
1700 @skipBefore35
1701 class NativeStreamingRequestFlowControlTest(
1702         BaseStreamingRequestFlowControlTest,
1703         WebTestCase):
1704     def get_handlers(self):
1705         class NativeFlowControlHandler(BaseFlowControlHandler):
1706             data_received = exec_test(globals(), locals(), """
1707             async def data_received(self, data):
1708                 with self.in_method('data_received'):
1709                     await gen.Task(IOLoop.current().add_callback)
1710             """)["data_received"]
1711         return [('/', NativeFlowControlHandler, dict(test=self))]
1712 @wsgi_safe
1713 class IncorrectContentLengthTest(SimpleHandlerTestCase):
1714     def get_handlers(self):
1715         test = self
1716         self.server_error = None
1717         class TooHigh(RequestHandler):
1718             def get(self):
1719                 self.set_header("Content-Length", "42")
1720                 try:
1721                     self.finish("ok")
1722                 except Exception as e:
1723                     test.server_error = e
1724                     raise
1725         class TooLow(RequestHandler):
1726             def get(self):
1727                 self.set_header("Content-Length", "2")
1728                 try:
1729                     self.finish("hello")
1730                 except Exception as e:
1731                     test.server_error = e
1732                     raise
1733         return [('/high', TooHigh),
1734                 ('/low', TooLow)]
1735     def test_content_length_too_high(self):
1736         with ExpectLog(app_log, "(Uncaught exception|Exception in callback)"):
1737             with ExpectLog(gen_log,
1738                            "(Cannot send error response after headers written"
1739                            "|Failed to flush partial response)"):
1740                 response = self.fetch("/high")
1741         self.assertEqual(response.code, 599)
1742         self.assertEqual(str(self.server_error),
1743                          "Tried to write 40 bytes less than Content-Length")
1744     def test_content_length_too_low(self):
1745         with ExpectLog(app_log, "(Uncaught exception|Exception in callback)"):
1746             with ExpectLog(gen_log,
1747                            "(Cannot send error response after headers written"
1748                            "|Failed to flush partial response)"):
1749                 response = self.fetch("/low")
1750         self.assertEqual(response.code, 599)
1751         self.assertEqual(str(self.server_error),
1752                          "Tried to write more data than Content-Length")
1753 class ClientCloseTest(SimpleHandlerTestCase):
1754     class Handler(RequestHandler):
1755         def get(self):
1756             if self.request.version.startswith('HTTP/1'):
1757                 self.request.connection.stream.close()
1758                 self.write('hello')
1759             else:
1760                 self.write('requires HTTP/1.x')
1761     def test_client_close(self):
1762         response = self.fetch('/')
1763         if response.body == b'requires HTTP/1.x':
1764             self.skipTest('requires HTTP/1.x')
1765         self.assertEqual(response.code, 599)
1766 class SignedValueTest(unittest.TestCase):
1767     SECRET = "It's a secret to everybody"
1768     SECRET_DICT = {0: "asdfbasdf", 1: "12312312", 2: "2342342"}
1769     def past(self):
1770         return self.present() - 86400 * 32
1771     def present(self):
1772         return 1300000000
1773     def test_known_values(self):
1774         signed_v1 = create_signed_value(SignedValueTest.SECRET, "key", "value",
1775                                         version=1, clock=self.present)
1776         self.assertEqual(
1777             signed_v1,
1778             b"dmFsdWU=|1300000000|31c934969f53e48164c50768b40cbd7e2daaaa4f")
1779         signed_v2 = create_signed_value(SignedValueTest.SECRET, "key", "value",
1780                                         version=2, clock=self.present)
1781         self.assertEqual(
1782             signed_v2,
1783             b"2|1:0|10:1300000000|3:key|8:dmFsdWU=|"
1784             b"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152")
1785         signed_default = create_signed_value(SignedValueTest.SECRET,
1786                                              "key", "value", clock=self.present)
1787         self.assertEqual(signed_default, signed_v2)
1788         decoded_v1 = decode_signed_value(SignedValueTest.SECRET, "key",
1789                                          signed_v1, min_version=1,
1790                                          clock=self.present)
1791         self.assertEqual(decoded_v1, b"value")
1792         decoded_v2 = decode_signed_value(SignedValueTest.SECRET, "key",
1793                                          signed_v2, min_version=2,
1794                                          clock=self.present)
1795         self.assertEqual(decoded_v2, b"value")
1796     def test_name_swap(self):
1797         signed1 = create_signed_value(SignedValueTest.SECRET, "key1", "value",
1798                                       clock=self.present)
1799         signed2 = create_signed_value(SignedValueTest.SECRET, "key2", "value",
1800                                       clock=self.present)
1801         decoded1 = decode_signed_value(SignedValueTest.SECRET, "key2", signed1,
1802                                        clock=self.present)
1803         self.assertIs(decoded1, None)
1804         decoded2 = decode_signed_value(SignedValueTest.SECRET, "key1", signed2,
1805                                        clock=self.present)
1806         self.assertIs(decoded2, None)
1807     def test_expired(self):
1808         signed = create_signed_value(SignedValueTest.SECRET, "key1", "value",
1809                                      clock=self.past)
1810         decoded_past = decode_signed_value(SignedValueTest.SECRET, "key1",
1811                                            signed, clock=self.past)
1812         self.assertEqual(decoded_past, b"value")
1813         decoded_present = decode_signed_value(SignedValueTest.SECRET, "key1",
1814                                               signed, clock=self.present)
1815         self.assertIs(decoded_present, None)
1816     def test_payload_tampering(self):
1817         sig = "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152"
1818         def validate(prefix):
1819             return (b'value' ==
1820                     decode_signed_value(SignedValueTest.SECRET, "key",
1821                                         prefix + sig, clock=self.present))
1822         self.assertTrue(validate("2|1:0|10:1300000000|3:key|8:dmFsdWU=|"))
1823         self.assertFalse(validate("2|1:1|10:1300000000|3:key|8:dmFsdWU=|"))
1824         self.assertFalse(validate("2|1:0|10:130000000|3:key|8:dmFsdWU=|"))
1825         self.assertFalse(validate("2|1:0|10:1300000000|3:keey|8:dmFsdWU=|"))
1826     def test_signature_tampering(self):
1827         prefix = "2|1:0|10:1300000000|3:key|8:dmFsdWU=|"
1828         def validate(sig):
1829             return (b'value' ==
1830                     decode_signed_value(SignedValueTest.SECRET, "key",
1831                                         prefix + sig, clock=self.present))
1832         self.assertTrue(validate(
1833             "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152"))
1834         self.assertFalse(validate("0" * 32))
1835         self.assertFalse(validate(
1836             "4d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152"))
1837         self.assertFalse(validate(
1838             "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e153"))
1839         self.assertFalse(validate(
1840             "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e15"))
1841         self.assertFalse(validate(
1842             "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e1538"))
1843     def test_non_ascii(self):
1844         value = b"\xe9"
1845         signed = create_signed_value(SignedValueTest.SECRET, "key", value,
1846                                      clock=self.present)
1847         decoded = decode_signed_value(SignedValueTest.SECRET, "key", signed,
1848                                       clock=self.present)
1849         self.assertEqual(value, decoded)
1850     def test_key_versioning_read_write_default_key(self):
1851         value = b"\xe9"
1852         signed = create_signed_value(SignedValueTest.SECRET_DICT,
1853                                      "key", value, clock=self.present,
1854                                      key_version=0)
1855         decoded = decode_signed_value(SignedValueTest.SECRET_DICT,
1856                                       "key", signed, clock=self.present)
1857         self.assertEqual(value, decoded)
1858     def test_key_versioning_read_write_non_default_key(self):
1859         value = b"\xe9"
1860         signed = create_signed_value(SignedValueTest.SECRET_DICT,
1861                                      "key", value, clock=self.present,
1862                                      key_version=1)
1863         decoded = decode_signed_value(SignedValueTest.SECRET_DICT,
1864                                       "key", signed, clock=self.present)
1865         self.assertEqual(value, decoded)
1866     def test_key_versioning_invalid_key(self):
1867         value = b"\xe9"
1868         signed = create_signed_value(SignedValueTest.SECRET_DICT,
1869                                      "key", value, clock=self.present,
1870                                      key_version=0)
1871         newkeys = SignedValueTest.SECRET_DICT.copy()
1872         newkeys.pop(0)
1873         decoded = decode_signed_value(newkeys,
1874                                       "key", signed, clock=self.present)
1875         self.assertEqual(None, decoded)
1876     def test_key_version_retrieval(self):
1877         value = b"\xe9"
1878         signed = create_signed_value(SignedValueTest.SECRET_DICT,
1879                                      "key", value, clock=self.present,
1880                                      key_version=1)
1881         key_version = get_signature_key_version(signed)
1882         self.assertEqual(1, key_version)
1883 @wsgi_safe
1884 class XSRFTest(SimpleHandlerTestCase):
1885     class Handler(RequestHandler):
1886         def get(self):
1887             version = int(self.get_argument("version", "2"))
1888             self.settings["xsrf_cookie_version"] = version
1889             self.write(self.xsrf_token)
1890         def post(self):
1891             self.write("ok")
1892     def get_app_kwargs(self):
1893         return dict(xsrf_cookies=True)
1894     def setUp(self):
1895         super(XSRFTest, self).setUp()
1896         self.xsrf_token = self.get_token()
1897     def get_token(self, old_token=None, version=None):
1898         if old_token is not None:
1899             headers = self.cookie_headers(old_token)
1900         else:
1901             headers = None
1902         response = self.fetch(
1903             "/" if version is None else ("/?version=%d" % version),
1904             headers=headers)
1905         response.rethrow()
1906         return native_str(response.body)
1907     def cookie_headers(self, token=None):
1908         if token is None:
1909             token = self.xsrf_token
1910         return {"Cookie": "_xsrf=" + token}
1911     def test_xsrf_fail_no_token(self):
1912         with ExpectLog(gen_log, ".*'_xsrf' argument missing"):
1913             response = self.fetch("/", method="POST", body=b"")
1914         self.assertEqual(response.code, 403)
1915     def test_xsrf_fail_body_no_cookie(self):
1916         with ExpectLog(gen_log, ".*XSRF cookie does not match POST"):
1917             response = self.fetch(
1918                 "/", method="POST",
1919                 body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)))
1920         self.assertEqual(response.code, 403)
1921     def test_xsrf_fail_argument_invalid_format(self):
1922         with ExpectLog(gen_log, ".*'_xsrf' argument has invalid format"):
1923             response = self.fetch(
1924                 "/", method="POST",
1925                 headers=self.cookie_headers(),
1926                 body=urllib_parse.urlencode(dict(_xsrf='3|')))
1927         self.assertEqual(response.code, 403)
1928     def test_xsrf_fail_cookie_invalid_format(self):
1929         with ExpectLog(gen_log, ".*XSRF cookie does not match POST"):
1930             response = self.fetch(
1931                 "/", method="POST",
1932                 headers=self.cookie_headers(token='3|'),
1933                 body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)))
1934         self.assertEqual(response.code, 403)
1935     def test_xsrf_fail_cookie_no_body(self):
1936         with ExpectLog(gen_log, ".*'_xsrf' argument missing"):
1937             response = self.fetch(
1938                 "/", method="POST", body=b"",
1939                 headers=self.cookie_headers())
1940         self.assertEqual(response.code, 403)
1941     def test_xsrf_success_short_token(self):
1942         response = self.fetch(
1943             "/", method="POST",
1944             body=urllib_parse.urlencode(dict(_xsrf='deadbeef')),
1945             headers=self.cookie_headers(token='deadbeef'))
1946         self.assertEqual(response.code, 200)
1947     def test_xsrf_success_non_hex_token(self):
1948         response = self.fetch(
1949             "/", method="POST",
1950             body=urllib_parse.urlencode(dict(_xsrf='xoxo')),
1951             headers=self.cookie_headers(token='xoxo'))
1952         self.assertEqual(response.code, 200)
1953     def test_xsrf_success_post_body(self):
1954         response = self.fetch(
1955             "/", method="POST",
1956             body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
1957             headers=self.cookie_headers())
1958         self.assertEqual(response.code, 200)
1959     def test_xsrf_success_query_string(self):
1960         response = self.fetch(
1961             "/?" + urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
1962             method="POST", body=b"",
1963             headers=self.cookie_headers())
1964         self.assertEqual(response.code, 200)
1965     def test_xsrf_success_header(self):
1966         response = self.fetch("/", method="POST", body=b"",
1967                               headers=dict({"X-Xsrftoken": self.xsrf_token},  # type: ignore
1968                                            **self.cookie_headers()))
1969         self.assertEqual(response.code, 200)
1970     def test_distinct_tokens(self):
1971         NUM_TOKENS = 10
1972         tokens = set()
1973         for i in range(NUM_TOKENS):
1974             tokens.add(self.get_token())
1975         self.assertEqual(len(tokens), NUM_TOKENS)
1976     def test_cross_user(self):
1977         token2 = self.get_token()
1978         for token in (self.xsrf_token, token2):
1979             response = self.fetch(
1980                 "/", method="POST",
1981                 body=urllib_parse.urlencode(dict(_xsrf=token)),
1982                 headers=self.cookie_headers(token))
1983             self.assertEqual(response.code, 200)
1984         for cookie_token, body_token in ((self.xsrf_token, token2),
1985                                          (token2, self.xsrf_token)):
1986             with ExpectLog(gen_log, '.*XSRF cookie does not match POST'):
1987                 response = self.fetch(
1988                     "/", method="POST",
1989                     body=urllib_parse.urlencode(dict(_xsrf=body_token)),
1990                     headers=self.cookie_headers(cookie_token))
1991             self.assertEqual(response.code, 403)
1992     def test_refresh_token(self):
1993         token = self.xsrf_token
1994         tokens_seen = set([token])
1995         for i in range(5):
1996             token = self.get_token(token)
1997             tokens_seen.add(token)
1998             response = self.fetch(
1999                 "/", method="POST",
2000                 body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
2001                 headers=self.cookie_headers(token))
2002             self.assertEqual(response.code, 200)
2003         self.assertEqual(len(tokens_seen), 6)
2004     def test_versioning(self):
2005         self.assertNotEqual(self.get_token(version=1),
2006                             self.get_token(version=1))
2007         v1_token = self.get_token(version=1)
2008         for i in range(5):
2009             self.assertEqual(self.get_token(v1_token, version=1), v1_token)
2010         v2_token = self.get_token(v1_token)
2011         self.assertNotEqual(v1_token, v2_token)
2012         self.assertNotEqual(v2_token, self.get_token(v1_token))
2013         for cookie_token, body_token in ((v1_token, v2_token),
2014                                          (v2_token, v1_token)):
2015             response = self.fetch(
2016                 "/", method="POST",
2017                 body=urllib_parse.urlencode(dict(_xsrf=body_token)),
2018                 headers=self.cookie_headers(cookie_token))
2019             self.assertEqual(response.code, 200)
2020 @wsgi_safe
2021 class XSRFCookieKwargsTest(SimpleHandlerTestCase):
2022     class Handler(RequestHandler):
2023         def get(self):
2024             self.write(self.xsrf_token)
2025     def get_app_kwargs(self):
2026         return dict(xsrf_cookies=True,
2027                     xsrf_cookie_kwargs=dict(httponly=True))
2028     def test_xsrf_httponly(self):
2029         response = self.fetch("/")
2030         self.assertIn('httponly;', response.headers['Set-Cookie'].lower())
2031 @wsgi_safe
2032 class FinishExceptionTest(SimpleHandlerTestCase):
2033     class Handler(RequestHandler):
2034         def get(self):
2035             self.set_status(401)
2036             self.set_header('WWW-Authenticate', 'Basic realm="something"')
2037             if self.get_argument('finish_value', ''):
2038                 raise Finish('authentication required')
2039             else:
2040                 self.write('authentication required')
2041                 raise Finish()
2042     def test_finish_exception(self):
2043         for u in ['/', '/?finish_value=1']:
2044             response <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.fetch(u)
2045             self.assertEqual(response.code, 401)
2046             self.assertEqual('Basic realm="something"',
2047                              response.headers.get('WWW-Authenticate'))
2048             self.assertEqual(</b></font>b'authentication required', response.body)
2049 @wsgi_safe
2050 class DecoratorTest(WebTestCase):
2051     def get_handlers(self):
2052         class RemoveSlashHandler(RequestHandler):
2053             @removeslash
2054             def get(self):
2055                 pass
2056         class AddSlashHandler(RequestHandler):
2057             @addslash
2058             def get(self):
2059                 pass
2060         return [("/removeslash/", RemoveSlashHandler),
2061                 ("/addslash", AddSlashHandler),
2062                 ]
2063     def test_removeslash(self):
2064         response = self.fetch("/removeslash/", follow_redirects=False)
2065         self.assertEqual(response.code, 301)
2066         self.assertEqual(response.headers['Location'], "/removeslash")
2067         response = self.fetch("/removeslash/?foo=bar", follow_redirects=False)
2068         self.assertEqual(response.code, 301)
2069         self.assertEqual(response.headers['Location'], "/removeslash?foo=bar")
2070     def test_addslash(self):
2071         response = self.fetch("/addslash", follow_redirects=False)
2072         self.assertEqual(response.code, 301)
2073         self.assertEqual(response.headers['Location'], "/addslash/")
2074         response = self.fetch("/addslash?foo=bar", follow_redirects=False)
2075         self.assertEqual(response.code, 301)
2076         self.assertEqual(response.headers['Location'], "/addslash/?foo=bar")
2077 @wsgi_safe
2078 class CacheTest(WebTestCase):
2079     def get_handlers(self):
2080         class EtagHandler(RequestHandler):
2081             def get(self, computed_etag):
2082                 self.write(computed_etag)
2083             def compute_etag(self):
2084                 return self._write_buffer[0]
2085         return [
2086             ('/etag/(.*)', EtagHandler)
2087         ]
2088     def test_wildcard_etag(self):
2089         computed_etag = '"xyzzy"'
2090         etags = '*'
2091         self._test_etag(computed_etag, etags, 304)
2092     def test_strong_etag_match(self):
2093         computed_etag = '"xyzzy"'
2094         etags = '"xyzzy"'
2095         self._test_etag(computed_etag, etags, 304)
2096     def test_multiple_strong_etag_match(self):
2097         computed_etag = '"xyzzy1"'
2098         etags = '"xyzzy1", "xyzzy2"'
2099         self._test_etag(computed_etag, etags, 304)
2100     def test_strong_etag_not_match(self):
2101         computed_etag = '"xyzzy"'
2102         etags = '"xyzzy1"'
2103         self._test_etag(computed_etag, etags, 200)
2104     def test_multiple_strong_etag_not_match(self):
2105         computed_etag = '"xyzzy"'
2106         etags = '"xyzzy1", "xyzzy2"'
2107         self._test_etag(computed_etag, etags, 200)
2108     def test_weak_etag_match(self):
2109         computed_etag = '"xyzzy1"'
2110         etags = 'W/"xyzzy1"'
2111         self._test_etag(computed_etag, etags, 304)
2112     def test_multiple_weak_etag_match(self):
2113         computed_etag = '"xyzzy2"'
2114         etags = 'W/"xyzzy1", W/"xyzzy2"'
2115         self._test_etag(computed_etag, etags, 304)
2116     def test_weak_etag_not_match(self):
2117         computed_etag = '"xyzzy2"'
2118         etags = 'W/"xyzzy1"'
2119         self._test_etag(computed_etag, etags, 200)
2120     def test_multiple_weak_etag_not_match(self):
2121         computed_etag = '"xyzzy3"'
2122         etags = 'W/"xyzzy1", W/"xyzzy2"'
2123         self._test_etag(computed_etag, etags, 200)
2124     def _test_etag(self, computed_etag, etags, status_code):
2125         response = self.fetch(
2126             '/etag/' + computed_etag,
2127             headers={'If-None-Match': etags}
2128         )
2129         self.assertEqual(response.code, status_code)
2130 @wsgi_safe
2131 class RequestSummaryTest(SimpleHandlerTestCase):
2132     class Handler(RequestHandler):
2133         def get(self):
2134             self.request.remote_ip = None
2135             self.finish(self._request_summary())
2136     def test_missing_remote_ip(self):
2137         resp = self.fetch("/")
2138         self.assertEqual(resp.body, b"GET / (None)")
2139     def test_copy(self):
2140         e = HTTPError(403, reason="Go away")
2141         e2 <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= copy.copy(e)
2142         self.assertIsNot(e, e2)
2143         self.assertEqual(e.status_code, e2.status_code)
2144         self.assertEqual(e.</b></font>reason, e2.reason)
2145 class ApplicationTest(AsyncTestCase):
2146     def test_listen(self):
2147         app = Application([])
2148         server = app.listen(0, address='127.0.0.1')
2149         server.stop()
2150 class URLSpecReverseTest(unittest.TestCase):
2151     def test_reverse(self):
2152         self.assertEqual('/favicon.ico', url(r'/favicon\.ico', None).reverse())
2153         self.assertEqual('/favicon.ico', url(r'^/favicon\.ico$', None).reverse())
2154     def test_non_reversible(self):
2155         paths = [
2156             r'^/api/v\d+/foo/(\w+)$',
2157         ]
2158         for path in paths:
2159             url_spec = url(path, None)
2160             try:
2161                 result = url_spec.reverse()
2162                 self.fail("did not get expected exception when reversing %s. "
2163                           "result: %s" % (path, result))
2164             except ValueError:
2165                 pass
2166     def test_reverse_arguments(self):
2167         self.assertEqual('/api/v1/foo/bar',
2168                          url(r'^/api/v1/foo/(\w+)$', None).reverse('bar'))
2169 class RedirectHandlerTest(WebTestCase):
2170     def get_handlers(self):
2171         return [
2172             ('/src', WebRedirectHandler, {'url': '/dst'}),
2173             (r'/(.*?)/(.*?)/(.*)', WebRedirectHandler, {'url': '/{1}/{0}/{2}'})]
2174     def test_basic_redirect(self):
2175         response = self.fetch('/src', follow_redirects=False)
2176         self.assertEqual(response.code, 301)
2177         self.assertEqual(response.headers['Location'], '/dst')
2178     def test_redirect_pattern(self):
2179         response = self.fetch('/a/b/c', follow_redirects=False)
2180         self.assertEqual(response.code, 301)
2181         self.assertEqual(response.headers['Location'], '/b/a/c')
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
