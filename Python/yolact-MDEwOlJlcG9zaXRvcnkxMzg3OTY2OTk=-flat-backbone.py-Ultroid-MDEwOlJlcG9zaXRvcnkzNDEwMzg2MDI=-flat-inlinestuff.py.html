
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.357142857142857%, Tokens: 10</h2>
        <div class="column">
            <h3>yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-backbone.py</h3>
            <pre><code>1  import torch
2  import torch.nn as nn
3  import pickle
4  from collections import OrderedDict
5  try:
6      from dcn_v2 import DCN
7  except ImportError:
8      def DCN(*args, **kwdargs):
9          raise Exception('DCN could not be imported. If you want to use YOLACT++ models, compile DCN. Check the README for instructions.')
10  class Bottleneck(nn.Module):
11      expansion = 4
12      def __init__(self, inplanes, planes, stride=1, downsample=None, norm_layer=nn.BatchNorm2d, dilation=1, use_dcn=False):
13          super(Bottleneck, self).__init__()
14          self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=1, bias=False, dilation=dilation)
15          self.bn1 = norm_layer(planes)
16          if use_dcn:
17              self.conv2 = DCN(planes, planes, kernel_size=3, stride=stride,
18                                  padding=dilation, dilation=dilation, deformable_groups=1)
19              self.conv2.bias.data.zero_()
20              self.conv2.conv_offset_mask.weight.data.zero_()
21              self.conv2.conv_offset_mask.bias.data.zero_()
22          else:
23              self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=stride,
24                                  padding=dilation, bias=False, dilation=dilation)
25          self.bn2 = norm_layer(planes)
26          self.conv3 = nn.Conv2d(planes, planes * 4, kernel_size=1, bias=False, dilation=dilation)
27          self.bn3 = norm_layer(planes * 4)
28          self.relu = nn.ReLU(inplace=True)
29          self.downsample = downsample
30          self.stride = stride
31      def forward(self, x):
32          residual = x
33          out = self.conv1(x)
34          out = self.bn1(out)
35          out = self.relu(out)
36          out = self.conv2(out)
37          out = self.bn2(out)
38          out = self.relu(out)
39          out = self.conv3(out)
40          out = self.bn3(out)
41          if self.downsample is not None:
42              residual = self.downsample(x)
43          out += residual
44          out = self.relu(out)
45          return out
46  class ResNetBackbone(nn.Module):
47      def __init__(self, layers, dcn_layers=[0, 0, 0, 0], dcn_interval=1, atrous_layers=[], block=Bottleneck, norm_layer=nn.BatchNorm2d):
48          super().__init__()
49          self.num_base_layers = len(layers)
50          self.layers = nn.ModuleList()
51          self.channels = []
52          self.norm_layer = norm_layer
53          self.dilation = 1
54          self.atrous_layers = atrous_layers
55          self.inplanes = 64
56          self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False)
57          self.bn1 = norm_layer(64)
<span onclick='openModal()' class='match'>58          self.relu = nn.ReLU(inplace=True)
59          self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
</span>60          self._make_layer(block, 64, layers[0], dcn_layers=dcn_layers[0], dcn_interval=dcn_interval)
61          self._make_layer(block, 128, layers[1], stride=2, dcn_layers=dcn_layers[1], dcn_interval=dcn_interval)
62          self._make_layer(block, 256, layers[2], stride=2, dcn_layers=dcn_layers[2], dcn_interval=dcn_interval)
63          self._make_layer(block, 512, layers[3], stride=2, dcn_layers=dcn_layers[3], dcn_interval=dcn_interval)
64          self.backbone_modules = [m for m in self.modules() if isinstance(m, nn.Conv2d)]
65      def _make_layer(self, block, planes, blocks, stride=1, dcn_layers=0, dcn_interval=1):
66          downsample = None
67          if stride != 1 or self.inplanes != planes * block.expansion:
68              if len(self.layers) in self.atrous_layers:
69                  self.dilation += 1
70                  stride = 1
71              downsample = nn.Sequential(
72                  nn.Conv2d(self.inplanes, planes * block.expansion,
73                            kernel_size=1, stride=stride, bias=False,
74                            dilation=self.dilation),
75                  self.norm_layer(planes * block.expansion),
76              )
77          layers = []
78          use_dcn = (dcn_layers >= blocks)
79          layers.append(block(self.inplanes, planes, stride, downsample, self.norm_layer, self.dilation, use_dcn=use_dcn))
80          self.inplanes = planes * block.expansion
81          for i in range(1, blocks):
82              use_dcn = ((i+dcn_layers) >= blocks) and (i % dcn_interval == 0)
83              layers.append(block(self.inplanes, planes, norm_layer=self.norm_layer, use_dcn=use_dcn))
84          layer = nn.Sequential(*layers)
85          self.channels.append(planes * block.expansion)
86          self.layers.append(layer)
87          return layer
88      def forward(self, x):
89          x = self.conv1(x)
90          x = self.bn1(x)
91          x = self.relu(x)
92          x = self.maxpool(x)
93          outs = []
94          for layer in self.layers:
95              x = layer(x)
96              outs.append(x)
97          return tuple(outs)
98      def init_backbone(self, path):
99          state_dict = torch.load(path)
100          keys = list(state_dict)
101          for key in keys:
102              if key.startswith('layer'):
103                  idx = int(key[5])
104                  new_key = 'layers.' + str(idx-1) + key[6:]
105                  state_dict[new_key] = state_dict.pop(key)
106          self.load_state_dict(state_dict, strict=False)
107      def add_layer(self, conv_channels=1024, downsample=2, depth=1, block=Bottleneck):
108          self._make_layer(block, conv_channels // block.expansion, blocks=depth, stride=downsample)
109  class ResNetBackboneGN(ResNetBackbone):
110      def __init__(self, layers, num_groups=32):
111          super().__init__(layers, norm_layer=lambda x: nn.GroupNorm(num_groups, x))
112      def init_backbone(self, path):
113          with open(path, 'rb') as f:
114              state_dict = pickle.load(f, encoding='latin1') # From the detectron source
115              state_dict = state_dict['blobs']
116          our_state_dict_keys = list(self.state_dict().keys())
117          new_state_dict = {}
118          gn_trans     = lambda x: ('gn_s' if x == 'weight' else 'gn_b')
119          layeridx2res = lambda x: 'res' + str(int(x)+2)
120          block2branch = lambda x: 'branch2' + ('a', 'b', 'c')[int(x[-1:])-1]
121          for key in our_state_dict_keys:
122              parts = key.split('.')
123              transcribed_key = ''
124              if (parts[0] == 'conv1'):
125                  transcribed_key = 'conv1_w'
126              elif (parts[0] == 'bn1'):
127                  transcribed_key = 'conv1_' + gn_trans(parts[1])
128              elif (parts[0] == 'layers'):
129                  if int(parts[1]) >= self.num_base_layers: continue
130                  transcribed_key = layeridx2res(parts[1])
131                  transcribed_key += '_' + parts[2] + '_'
132                  if parts[3] == 'downsample':
133                      transcribed_key += 'branch1_'
134                      if parts[4] == '0':
135                          transcribed_key += 'w'
136                      else:
137                          transcribed_key += gn_trans(parts[5])
138                  else:
139                      transcribed_key += block2branch(parts[3]) + '_'
140                      if 'conv' in parts[3]:
141                          transcribed_key += 'w'
142                      else:
143                          transcribed_key += gn_trans(parts[4])
144              new_state_dict[key] = torch.Tensor(state_dict[transcribed_key])
145          self.load_state_dict(new_state_dict, strict=False)
146  def darknetconvlayer(in_channels, out_channels, *args, **kwdargs):
147      return nn.Sequential(
148          nn.Conv2d(in_channels, out_channels, *args, **kwdargs, bias=False),
149          nn.BatchNorm2d(out_channels),
150          nn.LeakyReLU(0.1, inplace=True)
151      )
152  class DarkNetBlock(nn.Module):
153      expansion = 2
154      def __init__(self, in_channels, channels):
155          super().__init__()
156          self.conv1 = darknetconvlayer(in_channels, channels,                  kernel_size=1)
157          self.conv2 = darknetconvlayer(channels,    channels * self.expansion, kernel_size=3, padding=1)
158      def forward(self, x):
159          return self.conv2(self.conv1(x)) + x
160  class DarkNetBackbone(nn.Module):
161      def __init__(self, layers=[1, 2, 8, 8, 4], block=DarkNetBlock):
162          super().__init__()
163          self.num_base_layers = len(layers)
164          self.layers = nn.ModuleList()
165          self.channels = []
166          self._preconv = darknetconvlayer(3, 32, kernel_size=3, padding=1)
167          self.in_channels = 32
168          self._make_layer(block, 32,  layers[0])
169          self._make_layer(block, 64,  layers[1])
170          self._make_layer(block, 128, layers[2])
171          self._make_layer(block, 256, layers[3])
172          self._make_layer(block, 512, layers[4])
173          self.backbone_modules = [m for m in self.modules() if isinstance(m, nn.Conv2d)]
174      def _make_layer(self, block, channels, num_blocks, stride=2):
175          layer_list = []
176          layer_list.append(
177              darknetconvlayer(self.in_channels, channels * block.expansion,
178                               kernel_size=3, padding=1, stride=stride))
179          self.in_channels = channels * block.expansion
180          layer_list += [block(self.in_channels, channels) for _ in range(num_blocks)]
181          self.channels.append(self.in_channels)
182          self.layers.append(nn.Sequential(*layer_list))
183      def forward(self, x):
184          x = self._preconv(x)
185          outs = []
186          for layer in self.layers:
187              x = layer(x)
188              outs.append(x)
189          return tuple(outs)
190      def add_layer(self, conv_channels=1024, stride=2, depth=1, block=DarkNetBlock):
191          self._make_layer(block, conv_channels // block.expansion, num_blocks=depth, stride=stride)
192      def init_backbone(self, path):
193          self.load_state_dict(torch.load(path), strict=False)
194  class VGGBackbone(nn.Module):
195      def __init__(self, cfg, extra_args=[], norm_layers=[]):
196          super().__init__()
197          self.channels = []
198          self.layers = nn.ModuleList()
199          self.in_channels = 3
200          self.extra_args = list(reversed(extra_args)) # So I can use it as a stack
201          self.total_layer_count = 0
202          self.state_dict_lookup = {}
203          for idx, layer_cfg in enumerate(cfg):
204              self._make_layer(layer_cfg)
205          self.norms = nn.ModuleList([nn.BatchNorm2d(self.channels[l]) for l in norm_layers])
206          self.norm_lookup = {l: idx for idx, l in enumerate(norm_layers)}
207          self.backbone_modules = [m for m in self.modules() if isinstance(m, nn.Conv2d)]
208      def _make_layer(self, cfg):
209          layers = []
210          for v in cfg:
211              args = None
212              if isinstance(v, tuple):
213                  args = v[1]
214                  v = v[0]
215              if v == 'M':
216                  if args is None:
217                      args = {'kernel_size': 2, 'stride': 2}
218                  layers.append(nn.MaxPool2d(**args))
219              else:
220                  cur_layer_idx = self.total_layer_count + len(layers)
221                  self.state_dict_lookup[cur_layer_idx] = '%d.%d' % (len(self.layers), len(layers))
222                  if args is None:
223                      args = {'kernel_size': 3, 'padding': 1}
224                  layers.append(nn.Conv2d(self.in_channels, v, **args))
225                  layers.append(nn.ReLU(inplace=True))
226                  self.in_channels = v
227          self.total_layer_count += len(layers)
228          self.channels.append(self.in_channels)
229          self.layers.append(nn.Sequential(*layers))
230      def forward(self, x):
231          outs = []
232          for idx, layer in enumerate(self.layers):
233              x = layer(x)
234              if idx in self.norm_lookup:
235                  x = self.norms[self.norm_lookup[idx]](x)
236              outs.append(x)
237          return tuple(outs)
238      def transform_key(self, k):
239          vals = k.split('.')
240          layerIdx = self.state_dict_lookup[int(vals[0])]
241          return 'layers.%s.%s' % (layerIdx, vals[1])
242      def init_backbone(self, path):
243          state_dict = torch.load(path)
244          state_dict = OrderedDict([(self.transform_key(k), v) for k,v in state_dict.items()])
245          self.load_state_dict(state_dict, strict=False)
246      def add_layer(self, conv_channels=128, downsample=2):
247          if len(self.extra_args) > 0:
248              conv_channels, downsample = self.extra_args.pop()
249          padding = 1 if downsample > 1 else 0
250          layer = nn.Sequential(
251              nn.Conv2d(self.in_channels, conv_channels, kernel_size=1),
252              nn.ReLU(inplace=True),
253              nn.Conv2d(conv_channels, conv_channels*2, kernel_size=3, stride=downsample, padding=padding),
254              nn.ReLU(inplace=True)
255          )
256          self.in_channels = conv_channels*2
257          self.channels.append(self.in_channels)
258          self.layers.append(layer)
259  def construct_backbone(cfg):
260      backbone = cfg.type(*cfg.args)
261      num_layers = max(cfg.selected_layers) + 1
262      while len(backbone.layers) < num_layers:
263          backbone.add_layer()
264      return backbone
</code></pre>
        </div>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-inlinestuff.py</h3>
            <pre><code>1  import base64
2  import inspect
3  from datetime import datetime
4  from html import unescape
5  from random import choice
6  from re import compile as re_compile
7  from bs4 import BeautifulSoup as bs
8  from telethon import Button
9  from telethon.tl.alltlobjects import LAYER, tlobjects
10  from telethon.tl.types import DocumentAttributeAudio as Audio
11  from telethon.tl.types import InputWebDocument as wb
12  from pyUltroid.fns.misc import google_search
13  from pyUltroid.fns.tools import (
14      _webupload_cache,
15      async_searcher,
16      get_ofox,
17      saavn_search,
18      webuploader,
19  )
20  from . import *
21  from . import _ult_cache
22  SUP_BUTTONS = [
23      [
24          Button.url("• Repo •", url="https://github.com/TeamUltroid/Ultroid"),
25          Button.url("• Support •", url="t.me/UltroidSupportChat"),
26      ],
27  ]
28  ofox = "https://graph.org/file/231f0049fcd722824f13b.jpg"
29  gugirl = "https://graph.org/file/0df54ae4541abca96aa11.jpg"
30  ultpic = "https://graph.org/file/4136aa1650bc9d4109cc5.jpg"
31  apis = [
32      "QUl6YVN5QXlEQnNZM1dSdEI1WVBDNmFCX3c4SkF5NlpkWE5jNkZV",
33      "QUl6YVN5QkYwenhMbFlsUE1wOXh3TVFxVktDUVJxOERnZHJMWHNn",
34      "QUl6YVN5RGRPS253blB3VklRX2xiSDVzWUU0Rm9YakFLSVFWMERR",
35  ]
36  @in_pattern("ofox", owner=True)
37  async def _(e):
38      try:
39          match = e.text.split(" ", maxsplit=1)[1]
40      except IndexError:
41          kkkk = e.builder.article(
42              title="Enter Device Codename",
43              thumb=wb(ofox, 0, "image/jpeg", []),
44              text="**OFᴏx🦊Rᴇᴄᴏᴠᴇʀʏ**\n\nYou didn't search anything",
45              buttons=Button.switch_inline("Sᴇᴀʀᴄʜ Aɢᴀɪɴ", query="ofox ", same_peer=True),
46          )
47          return await e.answer([kkkk])
48      device, releases = await get_ofox(match)
49      if device.get("detail") is None:
50          fox = []
51          fullname = device["full_name"]
52          codename = device["codename"]
53          str(device["supported"])
54          maintainer = device["maintainer"]["name"]
55          link = f"https://orangefox.download/device/{codename}"
56          for data in releases["data"]:
57              release = data["type"]
58              version = data["version"]
59              size = humanbytes(data["size"])
60              release_date = datetime.utcfromtimestamp(data["date"]).strftime("%Y-%m-%d")
61              text = f"[\xad]({ofox})**OʀᴀɴɢᴇFᴏx Rᴇᴄᴏᴠᴇʀʏ Fᴏʀ**\n\n"
62              text += f"`  Fᴜʟʟ Nᴀᴍᴇ: {fullname}`\n"
63              text += f"`  Cᴏᴅᴇɴᴀᴍᴇ: {codename}`\n"
64              text += f"`  Mᴀɪɴᴛᴀɪɴᴇʀ: {maintainer}`\n"
65              text += f"`  Bᴜɪʟᴅ Tʏᴘᴇ: {release}`\n"
66              text += f"`  Vᴇʀsɪᴏɴ: {version}`\n"
67              text += f"`  Sɪᴢᴇ: {size}`\n"
68              text += f"`  Bᴜɪʟᴅ Dᴀᴛᴇ: {release_date}`"
69              fox.append(
70                  await e.builder.article(
71                      title=f"{fullname}",
72                      description=f"{version}\n{release_date}",
73                      text=text,
74                      thumb=wb(ofox, 0, "image/jpeg", []),
75                      link_preview=True,
76                      buttons=[
77                          Button.url("Dᴏᴡɴʟᴏᴀᴅ", url=f"{link}"),
78                          Button.switch_inline(
79                              "Sᴇᴀʀᴄʜ Aɢᴀɪɴ", query="ofox ", same_peer=True
80                          ),
81                      ],
82                  )
83              )
84          await e.answer(
85              fox, switch_pm="OrangeFox Recovery Search.", switch_pm_param="start"
86          )
87      else:
88          await e.answer(
89              [], switch_pm="OrangeFox Recovery Search.", switch_pm_param="start"
90          )
91  @in_pattern("fl2lnk ?(.*)", owner=True)
92  async def _(e):
93      match = e.pattern_match.group(1)
94      chat_id, msg_id = match.split(":")
95      filename = _webupload_cache[int(chat_id)][int(msg_id)]
96      if "/" in filename:
97          filename = filename.split("/")[-1]
98      __cache = f"{chat_id}:{msg_id}"
99      buttons = [
100          [
101              Button.inline("anonfiles", data=f"flanonfiles//{__cache}"),
102              Button.inline("transfer", data=f"fltransfer//{__cache}"),
103          ],
104          [
105              Button.inline("bayfiles", data=f"flbayfiles//{__cache}"),
106              Button.inline("x0.at", data=f"flx0.at//{__cache}"),
107          ],
108          [
109              Button.inline("file.io", data=f"flfile.io//{__cache}"),
110              Button.inline("siasky", data=f"flsiasky//{__cache}"),
111          ],
112      ]
113      try:
114          lnk = [
115              await e.builder.article(
116                  title=f"Upload {filename}",
117                  text=f"**File:**\n{filename}",
118                  buttons=buttons,
119              )
120          ]
121      except BaseException as er:
122          LOGS.exception(er)
123          lnk = [
124              await e.builder.article(
125                  title="fl2lnk",
126                  text="File not found",
127              )
128          ]
129      await e.answer(lnk, switch_pm="File to Link.", switch_pm_param="start")
130  @callback(
131      re_compile(
132          "fl(.*)",
133      ),
134      owner=True,
135  )
136  async def _(e):
137      t = (e.data).decode("UTF-8")
138      data = t[2:]
139      host = data.split("//")[0]
140      chat_id, msg_id = data.split("//")[1].split(":")
141      filename = _webupload_cache[int(chat_id)][int(msg_id)]
142      if "/" in filename:
143          filename = filename.split("/")[-1]
144      await e.edit(f"Uploading `{filename}` on {host}")
145      link = (await webuploader(chat_id, msg_id, host)).strip().replace("\n", "")
146      await e.edit(f"Uploaded `{filename}` on {host}.", buttons=Button.url("View", link))
147  @in_pattern("repo", owner=True)
148  async def repo(e):
149      res = [
150          await e.builder.article(
151              title="Ultroid Userbot",
152              description="Userbot | Telethon",
153              thumb=wb(ultpic, 0, "image/jpeg", []),
154              text="• **ULTROID USERBOT** •",
155              buttons=SUP_BUTTONS,
156          ),
157      ]
158      await e.answer(res, switch_pm="Ultroid Repo.", switch_pm_param="start")
159  @in_pattern("go", owner=True)
160  async def gsearch(q_event):
161      try:
162          match = q_event.text.split(maxsplit=1)[1]
163      except IndexError:
164          return await q_event.answer(
165              [], switch_pm="Google Search. Enter a query!", switch_pm_param="start"
166          )
167      searcher = []
168      gresults = await google_search(match)
169      for i in gresults:
170          try:
171              title = i["title"]
172              link = i["link"]
173              desc = i["description"]
174              searcher.append(
175                  await q_event.builder.article(
176                      title=title,
177                      description=desc,
178                      thumb=wb(gugirl, 0, "image/jpeg", []),
179                      text=f"**Gᴏᴏɢʟᴇ Sᴇᴀʀᴄʜ**\n\n**••Tɪᴛʟᴇ••**\n`{title}`\n\n**••Dᴇsᴄʀɪᴘᴛɪᴏɴ••**\n`{desc}`",
180                      link_preview=False,
181                      buttons=[
182                          [Button.url("Lɪɴᴋ", url=f"{link}")],
183                          [
184                              Button.switch_inline(
185                                  "Sᴇᴀʀᴄʜ Aɢᴀɪɴ",
186                                  query="go ",
187                                  same_peer=True,
188                              ),
189                              Button.switch_inline(
190                                  "Sʜᴀʀᴇ",
191                                  query=f"go {match}",
192                                  same_peer=False,
193                              ),
194                          ],
195                      ],
196                  ),
197              )
198          except IndexError:
199              break
200      await q_event.answer(searcher, switch_pm="Google Search.", switch_pm_param="start")
201  @in_pattern("mods", owner=True)
202  async def _(e):
203      try:
204          quer = e.text.split(" ", maxsplit=1)[1]
205      except IndexError:
206          return await e.answer(
207              [], switch_pm="Mod Apps Search. Enter app name!", switch_pm_param="start"
208          )
209      start = 0 * 3 + 1
210      da = base64.b64decode(choice(apis)).decode("ascii")
211      url = f"https://www.googleapis.com/customsearch/v1?key={da}&cx=25b3b50edb928435b&q={quer}&start={start}"
212      data = await async_searcher(url, re_json=True)
213      search_items = data.get("items", [])
214      modss = []
215      for a in search_items:
216          title = a.get("title")
217          desc = a.get("snippet")
218          link = a.get("link")
219          text = f"**••Tɪᴛʟᴇ••** `{title}`\n\n"
220          text += f"**Dᴇsᴄʀɪᴘᴛɪᴏɴ** `{desc}`"
221          modss.append(
222              await e.builder.article(
223                  title=title,
224                  description=desc,
225                  text=text,
226                  link_preview=True,
227                  buttons=[
228                      [Button.url("Dᴏᴡɴʟᴏᴀᴅ", url=f"{link}")],
229                      [
230                          Button.switch_inline(
231                              "Mᴏʀᴇ Mᴏᴅs",
232                              query="mods ",
233                              same_peer=True,
234                          ),
235                          Button.switch_inline(
236                              "Sʜᴀʀᴇ",
237                              query=f"mods {quer}",
238                              same_peer=False,
239                          ),
240                      ],
241                  ],
242              ),
243          )
244      await e.answer(modss, switch_pm="Search Mod Applications.", switch_pm_param="start")
245  APP_CACHE = {}
246  RECENTS = {}
247  PLAY_API = "https://googleplay.onrender.com/api/apps?q="
248  @in_pattern("app", owner=True)
249  async def _(e):
250      try:
251          f = e.text.split(maxsplit=1)[1].lower()
252      except IndexError:
253          get_string("instu_1")
254          res = []
255          if APP_CACHE and RECENTS.get(e.sender_id):
256              res.extend(
257                  APP_CACHE[a][0] for a in RECENTS[e.sender_id] if APP_CACHE.get(a)
258              )
259          return await e.answer(
260              res, switch_pm=get_string("instu_2"), switch_pm_param="start"
261          )
262      try:
263          return await e.answer(
264              APP_CACHE[f], switch_pm="Application Searcher.", switch_pm_param="start"
265          )
266      except KeyError:
267          pass
268      foles = []
269      url = PLAY_API + f.replace(" ", "+")
270      aap = await async_searcher(url, re_json=True)
271      for z in aap["results"][:50]:
272          url = "https://play.google.com/store/apps/details?id=" + z["appId"]
273          name = z["title"]
274          desc = unescape(z["summary"])[:300].replace("<br>", "\n") + "..."
275          dev = z["developer"]["devId"]
276          text = f"**••Aᴘᴘ Nᴀᴍᴇ••** [{name}]({url})\n"
277          text += f"**••Dᴇᴠᴇʟᴏᴘᴇʀ••** `{dev}`\n"
278          text += f"**••Dᴇsᴄʀɪᴘᴛɪᴏɴ••**\n`{desc}`"
279          foles.append(
280              await e.builder.article(
281                  title=name,
282                  description=dev,
283                  thumb=wb(z["icon"], 0, "image/jpeg", []),
284                  text=text,
285                  link_preview=True,
286                  buttons=[
287                      [Button.url("Lɪɴᴋ", url=url)],
288                      [
289                          Button.switch_inline(
290                              "Mᴏʀᴇ Aᴘᴘs",
291                              query="app ",
292                              same_peer=True,
293                          ),
294                          Button.switch_inline(
295                              "Sʜᴀʀᴇ",
296                              query=f"app {f}",
297                              same_peer=False,
298                          ),
299                      ],
300                  ],
301              ),
302          )
303      APP_CACHE.update({f: foles})
304      if RECENTS.get(e.sender_id):
305          RECENTS[e.sender_id].append(f)
306      else:
307          RECENTS.update({e.sender_id: [f]})
308      await e.answer(foles, switch_pm="Application Searcher.", switch_pm_param="start")
309  PISTON_URI = "https://emkc.org/api/v2/piston/"
310  PISTON_LANGS = {}
311  @in_pattern("run", owner=True)
312  async def piston_run(event):
313      try:
314          lang = event.text.split()[1]
315          code = event.text.split(maxsplit=2)[2]
316      except IndexError:
317          result = await event.builder.article(
318              title="Bad Query",
319              description="Usage: [Language] [code]",
320              thumb=wb(
321                  "https://graph.org/file/e33c57fc5f1044547e4d8.jpg", 0, "image/jpeg", []
322              ),
323              text=f'**Inline Usage**\n\n`@{asst.me.username} run python print("hello world")`\n\n[Language List](https://graph.org/Ultroid-09-01-6)',
324          )
325          return await event.answer([result])
326      if not PISTON_LANGS:
327          se = await async_searcher(f"{PISTON_URI}runtimes", re_json=True)
328          PISTON_LANGS.update({lang.pop("language"): lang for lang in se})
329      if lang in PISTON_LANGS.keys():
330          version = PISTON_LANGS[lang]["version"]
331      else:
332          result = await event.builder.article(
333              title="Unsupported Language",
334              description="Usage: [Language] [code]",
335              thumb=wb(
336                  "https://graph.org/file/e33c57fc5f1044547e4d8.jpg", 0, "image/jpeg", []
337              ),
338              text=f'**Inline Usage**\n\n`@{asst.me.username} run python print("hello world")`\n\n[Language List](https://graph.org/Ultroid-09-01-6)',
339          )
340          return await event.answer([result])
341      output = await async_searcher(
342          f"{PISTON_URI}execute",
343          post=True,
344          json={
345              "language": lang,
346              "version": version,
347              "files": [{"content": code}],
348          },
349          re_json=True,
350      )
351      output = output["run"]["output"] or get_string("instu_4")
352      if len(output) > 3000:
353          output = f"{output[:3000]}..."
354      result = await event.builder.article(
355          title="Result",
356          description=output,
357          text=f"• **Language:**\n`{lang}`\n\n• **Code:**\n`{code}`\n\n• **Result:**\n`{output}`",
358          thumb=wb(
359              "https://graph.org/file/871ee4a481f58117dccc4.jpg", 0, "image/jpeg", []
360          ),
<span onclick='openModal()' class='match'>361          buttons=Button.switch_inline("Fork", query=event.text, same_peer=True),
362      )
363      await event.answer([result], switch_pm="• Piston •", switch_pm_param="start")
</span>364  FDROID_ = {}
365  @in_pattern("fdroid", owner=True)
366  async def do_magic(event):
367      try:
368          match = event.text.split(" ", maxsplit=1)[1].lower()
369      except IndexError:
370          return await event.answer(
371              [], switch_pm="Enter Query to Search", switch_pm_param="start"
372          )
373      if FDROID_.get(match):
374          return await event.answer(
375              FDROID_[match], switch_pm=f"• Results for {match}", switch_pm_param="start"
376          )
377      link = "https://search.f-droid.org/?q=" + match.replace(" ", "+")
378      content = await async_searcher(link, re_content=True)
379      BSC = bs(content, "html.parser", from_encoding="utf-8")
380      ress = []
381      for dat in BSC.find_all("a", "package-header")[:10]:
382          image = dat.find("img", "package-icon")["src"]
383          if image.endswith("/"):
384              image = "https://graph.org/file/a8dd4a92c5a53a89d0eff.jpg"
385          title = dat.find("h4", "package-name").text.strip()
386          desc = dat.find("span", "package-summary").text.strip()
387          text = f"• **Name :** `{title}`\n\n"
388          text += f"• **Description :** `{desc}`\n"
389          text += f"• **License :** `{dat.find('span', 'package-license').text.strip()}`"
390          imga = wb(image, 0, "image/jpeg", [])
391          ress.append(
392              await event.builder.article(
393                  title=title,
394                  type="photo",
395                  description=desc,
396                  text=text,
397                  content=imga,
398                  thumb=imga,
399                  include_media=True,
400                  buttons=[
401                      Button.inline(
402                          "• Download •", "fd" + dat["href"].split("packages/")[-1]
403                      ),
404                      Button.switch_inline("• Share •", query=event.text),
405                  ],
406              )
407          )
408      msg = f"Showing {len(ress)} Results!" if ress else "No Results Found"
409      FDROID_.update({match: ress})
410      await event.answer(ress, switch_pm=msg, switch_pm_param="start")
411  _bearer_collected = [
412      "AAAAAAAAAAAAAAAAAAAAALIKKgEAAAAA1DRuS%2BI7ZRKiagD6KHYmreaXomo%3DP5Vaje4UTtEkODg0fX7nCh5laSrchhtLxeyEqxXpv0w9ZKspLD",
413      "AAAAAAAAAAAAAAAAAAAAAL5iUAEAAAAAmo6FYRjqdKlI3cNziIm%2BHUQB9Xs%3DS31pj0mxARMTOk2g9dvQ1yP9wknvY4FPBPUlE00smJcncw4dPR",
414      "AAAAAAAAAAAAAAAAAAAAAN6sVgEAAAAAMMjMMWrwgGyv7YQOWN%2FSAsO5SGM%3Dg8MG9Jq93Rlllaok6eht7HvRCruN4Vpzp4NaVsZaaHHWSTzKI8",
415  ]
416  @in_pattern("twitter", owner=True)
417  async def twitter_search(event):
418      try:
419          match = event.text.split(maxsplit=1)[1].lower()
420      except IndexError:
421          return await event.answer(
422              [], switch_pm="Enter Query to Search", switch_pm_param="start"
423          )
424      try:
425          return await event.answer(
426              _ult_cache["twitter"][match],
427              switch_pm="• Twitter Search •",
428              switch_pm_param="start",
429          )
430      except KeyError:
431          pass
432      headers = {"Authorization": f"bearer {choice(_bearer_collected)}"}
433      res = await async_searcher(
434          f"https://api.twitter.com/1.1/users/search.json?q={match}",
435          headers=headers,
436          re_json=True,
437      )
438      reso = []
439      for user in res:
440          thumb = wb(user["profile_image_url_https"], 0, "image/jpeg", [])
441          if user.get("profile_banner_url"):
442              url = user["profile_banner_url"]
443              text = f"[\xad]({url})• **Name :** `{user['name']}`\n"
444          else:
445              text = f"• **Name :** `{user['name']}`\n"
446          text += f"• **Description :** `{user['description']}`\n"
447          text += f"• **Username :** `@{user['screen_name']}`\n"
448          text += f"• **Followers :** `{user['followers_count']}`    • **Following :** `{user['friends_count']}`\n"
449          pro_ = "https://twitter.com/" + user["screen_name"]
450          text += f"• **Link :** [Click Here]({pro_})\n_"
451          reso.append(
452              await event.builder.article(
453                  title=user["name"],
454                  description=user["description"],
455                  url=pro_,
456                  text=text,
457                  thumb=thumb,
458              )
459          )
460      swi_ = f"🐦 Showing {len(reso)} Results!" if reso else "No User Found :("
461      await event.answer(reso, switch_pm=swi_, switch_pm_param="start")
462      if _ult_cache.get("twitter"):
463          _ult_cache["twitter"].update({match: reso})
464      else:
465          _ult_cache.update({"twitter": {match: reso}})
466  _savn_cache = {}
467  @in_pattern("saavn", owner=True)
468  async def savn_s(event):
469      try:
470          query = event.text.split(maxsplit=1)[1].lower()
471      except IndexError:
472          return await event.answer(
473              [], switch_pm="Enter Query to search 🔍", switch_pm_param="start"
474          )
475      if query in _savn_cache:
476          return await event.answer(
477              _savn_cache[query],
478              switch_pm=f"Showing Results for {query}",
479              switch_pm_param="start",
480          )
481      results = await saavn_search(query)
482      swi = "🎵 Saavn Search" if results else "No Results Found!"
483      res = []
484      for song in results:
485          thumb = wb(song["image"], 0, "image/jpeg", [])
486          text = f"• **Title :** {song['title']}"
487          text += f"\n• **Year :** {song['year']}"
488          text += f"\n• **Lang :** {song['language']}"
489          text += f"\n• **Artist :** {song['artists']}"
490          text += f"\n• **Release Date :** {song['release_date']}"
491          res.append(
492              await event.builder.article(
493                  title=song["title"],
494                  description=song["artists"],
495                  type="audio",
496                  text=text,
497                  include_media=True,
498                  buttons=Button.switch_inline(
499                      "Search Again 🔍", query="saavn", same_peer=True
500                  ),
501                  thumb=thumb,
502                  content=wb(
503                      song["url"],
504                      0,
505                      "audio/mp4",
506                      [
507                          Audio(
508                              title=song["title"],
509                              duration=int(song["duration"]),
510                              performer=song["artists"],
511                          )
512                      ],
513                  ),
514              )
515          )
516      await event.answer(res, switch_pm=swi, switch_pm_param="start")
517      _savn_cache.update({query: res})
518  @in_pattern("tl", owner=True)
519  async def inline_tl(ult):
520      try:
521          match = ult.text.split(maxsplit=1)[1]
522      except IndexError:
523          text = f"**Telegram TlObjects Searcher.**\n__(Don't use if you don't know what it is!)__\n\n• Example Usage\n`@{asst.me.username} tl GetFullUserRequest`"
524          return await ult.answer(
525              [
526                  await ult.builder.article(
527                      title="How to Use?",
528                      description="Tl Searcher by Ultroid",
529                      url="https://t.me/TeamUltroid",
530                      text=text,
531                  )
532              ],
533              switch_pm="Tl Search 🔍",
534              switch_pm_param="start",
535          )
536      res = []
537      for key in tlobjects.values():
538          if match.lower() in key.__name__.lower():
539              tyyp = "Function" if "tl.functions." in str(key) else "Type"
540              text = f"**Name:** `{key.__name__}`\n"
541              text += f"**Category:** `{tyyp}`\n"
542              text += f"\n`from {key.__module__} import {key.__name__}`\n\n"
543              if args := str(inspect.signature(key))[1:][:-1]:
544                  text += "**Parameter:**\n"
545                  for para in args.split(","):
546                      text += " " * 4 + "`" + para + "`\n"
547              text += f"\n**Layer:** `{LAYER}`"
548              res.append(
549                  await ult.builder.article(
550                      title=key.__name__,
551                      description=tyyp,
552                      url="https://t.me/TeamUltroid",
553                      text=text[:4000],
554                  )
555              )
556      mo = f"Showing {len(res)} results!" if res else f"No Results for {match}!"
557      await ult.answer(res[:50], switch_pm=mo, switch_pm_param="start")
558  InlinePlugin.update(
559      {
560          "Pʟᴀʏ Sᴛᴏʀᴇ Aᴘᴘs": "app telegram",
561          "Mᴏᴅᴅᴇᴅ Aᴘᴘs": "mods minecraft",
562          "Sᴇᴀʀᴄʜ Oɴ Gᴏᴏɢʟᴇ": "go TeamUltroid",
563          "WʜɪSᴘᴇʀ": "wspr @username Hello🎉",
564          "YᴏᴜTᴜʙᴇ Dᴏᴡɴʟᴏᴀᴅᴇʀ": "yt Ed Sheeran Perfect",
565          "Piston Eval": "run javascript console.log('Hello Ultroid')",
566          "OʀᴀɴɢᴇFᴏx🦊": "ofox beryllium",
567          "Tᴡɪᴛᴛᴇʀ Usᴇʀ": "twitter theultroid",
568          "Fᴅʀᴏɪᴅ Sᴇᴀʀᴄʜ": "fdroid telegram",
569          "Sᴀᴀᴠɴ sᴇᴀʀᴄʜ": "saavn",
570          "Tʟ Sᴇᴀʀᴄʜ": "tl",
571      }
572  )
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-backbone.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-inlinestuff.py</div>
                </div>
                <div class="column column_space"><pre><code>58          self.relu = nn.ReLU(inplace=True)
59          self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
</pre></code></div>
                <div class="column column_space"><pre><code>361          buttons=Button.switch_inline("Fork", query=event.text, same_peer=True),
362      )
363      await event.answer([result], switch_pm="• Piston •", switch_pm_param="start")
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    