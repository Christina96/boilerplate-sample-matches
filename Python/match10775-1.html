<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_voronoi.py & test_weighted.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style>
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_voronoi.py & test_weighted.py
      </h3>
      <h1 align="center">
        2.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_voronoi.py (11.904762%)<TH>test_weighted.py (1.4108353%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match10775-0.html#0',2,'match10775-1.html#0',3)" NAME="0">(90-100)<TD><A HREF="javascript:ZweiFrames('match10775-0.html#0',2,'match10775-1.html#0',3)" NAME="0">(50-60)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match10775-0.html#1',2,'match10775-1.html#1',3)" NAME="1">(52-55)<TD><A HREF="javascript:ZweiFrames('match10775-0.html#1',2,'match10775-1.html#1',3)" NAME="1">(478-481)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_voronoi.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 import networkx as nx
2 from networkx.utils import pairwise
3 class TestVoronoiCells:
4     &quot;&quot;&quot;Unit tests for the Voronoi cells function.&quot;&quot;&quot;
5     def test_isolates(self):
6         &quot;&quot;&quot;Tests that a graph with isolated nodes has all isolates in
7         one block of the partition.
8         &quot;&quot;&quot;
9         G = nx.empty_graph(5)
10         cells = nx.voronoi_cells(G, {0, 2, 4})
11         expected = {0: {0}, 2: {2}, 4: {4}, &quot;unreachable&quot;: {1, 3}}
12         assert expected == cells
13     def test_undirected_unweighted(self):
14         G = nx.cycle_graph(6)
15         cells = nx.voronoi_cells(G, {0, 3})
16         expected = {0: {0, 1, 5}, 3: {2, 3, 4}}
17         assert expected == cells
18     def test_directed_unweighted(self):
19         G = nx.DiGraph(pairwise(range(6), cyclic=True))
20         cells = nx.voronoi_cells(G, {0, 3})
21         expected = {0: {0, 1, 2}, 3: {3, 4, 5}}
22         assert expected == cells
23     def test_directed_inward(self):
24         &quot;&quot;&quot;Tests that reversing the graph gives the &quot;inward&quot; Voronoi
25         partition.
26         &quot;&quot;&quot;
27         G = nx.DiGraph(pairwise(range(6), cyclic=True))
28         G = G.reverse(copy=False)
29         cells = nx.voronoi_cells(G, {0, 3})
30         expected = {0: {0, 4, 5}, 3: {1, 2, 3}}
31         assert expected == cells
32     def test_undirected_weighted(self):
33         edges = [(0, 1, 10), (1, 2, 1), (2, 3, 1)]
34         G = nx.Graph()
35         G.add_weighted_edges_from(edges)
36         cells = nx.voronoi_cells(G, {0, 3})
37         expected = {0: {0}, 3: {1, 2, 3}}
38 <A NAME="1"></A>        assert expected == cells
39     def test_directed_weighted(self):
40         edges = [(<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match10775-1.html#1',3,'match10775-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>0, 1, 10), (1, 2, 1), (2, 3, 1), (3, 2, 1), (2, 1, 1)]
41         G = nx.DiGraph()
42         G.add_weighted_edges_from(edges)
43         cells = nx.</B></FONT>voronoi_cells(G, {0, 3})
44         expected = {0: {0}, 3: {1, 2, 3}}
45         assert expected == cells
46     def test_multigraph_unweighted(self):
47         &quot;&quot;&quot;Tests that the Voronoi cells for a multigraph are the same as
48         for a simple graph.
49         &quot;&quot;&quot;
50         edges = [(0, 1), (1, 2), (2, 3)]
51         G = nx.MultiGraph(2 * edges)
52         H = nx.Graph(G)
53         G_cells = nx.voronoi_cells(G, {0, 3})
54         H_cells = nx.voronoi_cells(H, {0, 3})
55         assert G_cells == H_cells
56     def test_multidigraph_unweighted(self):
57         edges = list(pairwise(range(6), cyclic=True))
58         G = nx.MultiDiGraph(2 * edges)
59         H = nx.DiGraph(G)
60         G_cells = nx.voronoi_cells(G, {0, 3})
61         H_cells = nx.voronoi_cells(H, {0, 3})
62         assert G_cells == H_cells
63     def test_multigraph_weighted(self):
64         edges = [(0, 1, 10), (0, 1, 10), (1, 2, 1), (1, 2, 100), (2, 3, 1), (2, 3, 100)]
65         G = nx.MultiGraph()
66         G.add_weighted_edges_from(edges)
67         cells = nx.voronoi_cells(G, {0, 3})
68         expected = {0: {0}, 3: {1, 2, 3}}
69         assert expected == cells
70 <A NAME="0"></A>
71     def test_multidigraph_weighted(self):
72         edges = [
73             <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match10775-1.html#0',3,'match10775-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(0, 1, 10),
74             (0, 1, 10),
75             (1, 2, 1),
76             (2, 3, 1),
77             (3, 2, 10),
78             (3, 2, 1),
79             (2, 1, 10),
80             (2, 1, 1),
81         ]
82         G = nx.MultiDiGraph()
83         G.</B></FONT>add_weighted_edges_from(edges)
84         cells = nx.voronoi_cells(G, {0, 3})
85         expected = {0: {0}, 3: {1, 2, 3}}
86         assert expected == cells
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_weighted.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 import pytest
2 import networkx as nx
3 from networkx.utils import pairwise
4 def validate_path(G, s, t, soln_len, path, weight=&quot;weight&quot;):
5     assert path[0] == s
6     assert path[-1] == t
7     if callable(weight):
8         weight_f = weight
9     else:
10         if G.is_multigraph():
11             def weight_f(u, v, d):
12                 return min(e.get(weight, 1) for e in d.values())
13         else:
14             def weight_f(u, v, d):
15                 return d.get(weight, 1)
16     computed = sum(weight_f(u, v, G[u][v]) for u, v in pairwise(path))
17     assert soln_len == computed
18 def validate_length_path(G, s, t, soln_len, length, path, weight=&quot;weight&quot;):
19     assert soln_len == length
20     validate_path(G, s, t, length, path, weight=weight)
21 class WeightedTestBase:
22     &quot;&quot;&quot;Base class for test classes that test functions for computing
23     shortest paths in weighted graphs.
24     &quot;&quot;&quot;
25     def setup(self):
26         &quot;&quot;&quot;Creates some graphs for use in the unit tests.&quot;&quot;&quot;
27         cnlti = nx.convert_node_labels_to_integers
28         self.grid = cnlti(nx.grid_2d_graph(4, 4), first_label=1, ordering=&quot;sorted&quot;)
29         self.cycle = nx.cycle_graph(7)
30         self.directed_cycle = nx.cycle_graph(7, create_using=nx.DiGraph())
31         self.XG = nx.DiGraph()
32         self.XG.add_weighted_edges_from(
33 <A NAME="0"></A>            [
34                 (&quot;s&quot;, &quot;u&quot;, 10),
35                 (&quot;s&quot;, &quot;x&quot;, 5),
36                 (<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match10775-0.html#0',2,'match10775-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;u&quot;, &quot;v&quot;, 1),
37                 (&quot;u&quot;, &quot;x&quot;, 2),
38                 (&quot;v&quot;, &quot;y&quot;, 1),
39                 (&quot;x&quot;, &quot;u&quot;, 3),
40                 (&quot;x&quot;, &quot;v&quot;, 5),
41                 (&quot;x&quot;, &quot;y&quot;, 2),
42                 (&quot;y&quot;, &quot;s&quot;, 7),
43                 (&quot;y&quot;, &quot;v&quot;, 6),
44             ]
45         )
46         self.MXG = nx.MultiDiGraph(self.</B></FONT>XG)
47         self.MXG.add_edge(&quot;s&quot;, &quot;u&quot;, weight=15)
48         self.XG2 = nx.DiGraph()
49         self.XG2.add_weighted_edges_from(
50             [
51                 [1, 4, 1],
52                 [4, 5, 1],
53                 [5, 6, 1],
54                 [6, 3, 1],
55                 [1, 3, 50],
56                 [1, 2, 100],
57                 [2, 3, 100],
58             ]
59         )
60         self.XG3 = nx.Graph()
61         self.XG3.add_weighted_edges_from(
62             [[0, 1, 2], [1, 2, 12], [2, 3, 1], [3, 4, 5], [4, 5, 1], [5, 0, 10]]
63         )
64         self.XG4 = nx.Graph()
65         self.XG4.add_weighted_edges_from(
66             [
67                 [0, 1, 2],
68                 [1, 2, 2],
69                 [2, 3, 1],
70                 [3, 4, 1],
71                 [4, 5, 1],
72                 [5, 6, 1],
73                 [6, 7, 1],
74                 [7, 0, 1],
75             ]
76         )
77         self.MXG4 = nx.MultiGraph(self.XG4)
78         self.MXG4.add_edge(0, 1, weight=3)
79         self.G = nx.DiGraph()  # no weights
80         self.G.add_edges_from(
81             [
82                 (&quot;s&quot;, &quot;u&quot;),
83                 (&quot;s&quot;, &quot;x&quot;),
84                 (&quot;u&quot;, &quot;v&quot;),
85                 (&quot;u&quot;, &quot;x&quot;),
86                 (&quot;v&quot;, &quot;y&quot;),
87                 (&quot;x&quot;, &quot;u&quot;),
88                 (&quot;x&quot;, &quot;v&quot;),
89                 (&quot;x&quot;, &quot;y&quot;),
90                 (&quot;y&quot;, &quot;s&quot;),
91                 (&quot;y&quot;, &quot;v&quot;),
92             ]
93         )
94 class TestWeightedPath(WeightedTestBase):
95     def test_dijkstra(self):
96         (D, P) = nx.single_source_dijkstra(self.XG, &quot;s&quot;)
97         validate_path(self.XG, &quot;s&quot;, &quot;v&quot;, 9, P[&quot;v&quot;])
98         assert D[&quot;v&quot;] == 9
99         validate_path(
100             self.XG, &quot;s&quot;, &quot;v&quot;, 9, nx.single_source_dijkstra_path(self.XG, &quot;s&quot;)[&quot;v&quot;]
101         )
102         assert dict(nx.single_source_dijkstra_path_length(self.XG, &quot;s&quot;))[&quot;v&quot;] == 9
103         validate_path(
104             self.XG, &quot;s&quot;, &quot;v&quot;, 9, nx.single_source_dijkstra(self.XG, &quot;s&quot;)[1][&quot;v&quot;]
105         )
106         validate_path(
107             self.MXG, &quot;s&quot;, &quot;v&quot;, 9, nx.single_source_dijkstra_path(self.MXG, &quot;s&quot;)[&quot;v&quot;]
108         )
109         GG = self.XG.to_undirected()
110         GG[&quot;u&quot;][&quot;x&quot;][&quot;weight&quot;] = 2
111         (D, P) = nx.single_source_dijkstra(GG, &quot;s&quot;)
112         validate_path(GG, &quot;s&quot;, &quot;v&quot;, 8, P[&quot;v&quot;])
113         assert D[&quot;v&quot;] == 8  # uses lower weight of 2 on u&lt;-&gt;x edge
114         validate_path(GG, &quot;s&quot;, &quot;v&quot;, 8, nx.dijkstra_path(GG, &quot;s&quot;, &quot;v&quot;))
115         assert nx.dijkstra_path_length(GG, &quot;s&quot;, &quot;v&quot;) == 8
116         validate_path(self.XG2, 1, 3, 4, nx.dijkstra_path(self.XG2, 1, 3))
117         validate_path(self.XG3, 0, 3, 15, nx.dijkstra_path(self.XG3, 0, 3))
118         assert nx.dijkstra_path_length(self.XG3, 0, 3) == 15
119         validate_path(self.XG4, 0, 2, 4, nx.dijkstra_path(self.XG4, 0, 2))
120         assert nx.dijkstra_path_length(self.XG4, 0, 2) == 4
121         validate_path(self.MXG4, 0, 2, 4, nx.dijkstra_path(self.MXG4, 0, 2))
122         validate_path(
123             self.G, &quot;s&quot;, &quot;v&quot;, 2, nx.single_source_dijkstra(self.G, &quot;s&quot;, &quot;v&quot;)[1]
124         )
125         validate_path(
126             self.G, &quot;s&quot;, &quot;v&quot;, 2, nx.single_source_dijkstra(self.G, &quot;s&quot;)[1][&quot;v&quot;]
127         )
128         validate_path(self.G, &quot;s&quot;, &quot;v&quot;, 2, nx.dijkstra_path(self.G, &quot;s&quot;, &quot;v&quot;))
129         assert nx.dijkstra_path_length(self.G, &quot;s&quot;, &quot;v&quot;) == 2
130         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path, self.G, &quot;s&quot;, &quot;moon&quot;)
131         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path_length, self.G, &quot;s&quot;, &quot;moon&quot;)
132         validate_path(self.cycle, 0, 3, 3, nx.dijkstra_path(self.cycle, 0, 3))
133         validate_path(self.cycle, 0, 4, 3, nx.dijkstra_path(self.cycle, 0, 4))
134         assert nx.single_source_dijkstra(self.cycle, 0, 0) == (0, [0])
135     def test_bidirectional_dijkstra(self):
136         validate_length_path(
137             self.XG, &quot;s&quot;, &quot;v&quot;, 9, *nx.bidirectional_dijkstra(self.XG, &quot;s&quot;, &quot;v&quot;)
138         )
139         validate_length_path(
140             self.G, &quot;s&quot;, &quot;v&quot;, 2, *nx.bidirectional_dijkstra(self.G, &quot;s&quot;, &quot;v&quot;)
141         )
142         validate_length_path(
143             self.cycle, 0, 3, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 3)
144         )
145         validate_length_path(
146             self.cycle, 0, 4, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 4)
147         )
148         validate_length_path(
149             self.XG3, 0, 3, 15, *nx.bidirectional_dijkstra(self.XG3, 0, 3)
150         )
151         validate_length_path(
152             self.XG4, 0, 2, 4, *nx.bidirectional_dijkstra(self.XG4, 0, 2)
153         )
154         P = nx.single_source_dijkstra_path(self.XG, &quot;s&quot;)[&quot;v&quot;]
155         validate_path(
156             self.XG,
157             &quot;s&quot;,
158             &quot;v&quot;,
159             sum(self.XG[u][v][&quot;weight&quot;] for u, v in zip(P[:-1], P[1:])),
160             nx.dijkstra_path(self.XG, &quot;s&quot;, &quot;v&quot;),
161         )
162         G = nx.path_graph(2)
163         pytest.raises(nx.NodeNotFound, nx.bidirectional_dijkstra, G, 3, 0)
164     def test_weight_functions(self):
165         def heuristic(*z):
166             return sum(val ** 2 for val in z)
167         def getpath(pred, v, s):
168             return [v] if v == s else getpath(pred, pred[v], s) + [v]
169         def goldberg_radzik(g, s, t, weight=&quot;weight&quot;):
170             pred, dist = nx.goldberg_radzik(g, s, weight=weight)
171             dist = dist[t]
172             return dist, getpath(pred, t, s)
173         def astar(g, s, t, weight=&quot;weight&quot;):
174             path = nx.astar_path(g, s, t, heuristic, weight=weight)
175             dist = nx.astar_path_length(g, s, t, heuristic, weight=weight)
176             return dist, path
177         def vlp(G, s, t, l, F, w):
178             res = F(G, s, t, weight=w)
179             validate_length_path(G, s, t, l, *res, weight=w)
180         G = self.cycle
181         s = 6
182         t = 4
183         path = [6] + list(range(t + 1))
184         def weight(u, v, _):
185             return 1 + v ** 2
186         length = sum(weight(u, v, None) for u, v in pairwise(path))
187         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
188         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
189         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
190         vlp(G, s, t, length, goldberg_radzik, weight)
191         vlp(G, s, t, length, astar, weight)
192         def weight(u, v, _):
193             return 2 ** (u * v)
194         length = sum(weight(u, v, None) for u, v in pairwise(path))
195         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
196         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
197         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
198         vlp(G, s, t, length, goldberg_radzik, weight)
199         vlp(G, s, t, length, astar, weight)
200     def test_bidirectional_dijkstra_no_path(self):
201         with pytest.raises(nx.NetworkXNoPath):
202             G = nx.Graph()
203             nx.add_path(G, [1, 2, 3])
204             nx.add_path(G, [4, 5, 6])
205             path = nx.bidirectional_dijkstra(G, 1, 6)
206     @pytest.mark.parametrize(
207         &quot;fn&quot;,
208         (
209             nx.dijkstra_path,
210             nx.dijkstra_path_length,
211             nx.single_source_dijkstra_path,
212             nx.single_source_dijkstra_path_length,
213             nx.single_source_dijkstra,
214             nx.dijkstra_predecessor_and_distance,
215         ),
216     )
217     def test_absent_source(self, fn):
218         G = nx.path_graph(2)
219         with pytest.raises(nx.NodeNotFound):
220             fn(G, 3, 0)
221         with pytest.raises(nx.NodeNotFound):
222             fn(G, 3, 3)
223     def test_dijkstra_predecessor1(self):
224         G = nx.path_graph(4)
225         assert nx.dijkstra_predecessor_and_distance(G, 0) == (
226             {0: [], 1: [0], 2: [1], 3: [2]},
227             {0: 0, 1: 1, 2: 2, 3: 3},
228         )
229     def test_dijkstra_predecessor2(self):
230         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
231         pred, dist = nx.dijkstra_predecessor_and_distance(G, (0))
232         assert pred[0] == []
233         assert pred[1] == [0]
234         assert pred[2] in [[1, 3], [3, 1]]
235         assert pred[3] == [0]
236         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
237     def test_dijkstra_predecessor3(self):
238         XG = nx.DiGraph()
239         XG.add_weighted_edges_from(
240             [
241                 (&quot;s&quot;, &quot;u&quot;, 10),
242                 (&quot;s&quot;, &quot;x&quot;, 5),
243                 (&quot;u&quot;, &quot;v&quot;, 1),
244                 (&quot;u&quot;, &quot;x&quot;, 2),
245                 (&quot;v&quot;, &quot;y&quot;, 1),
246                 (&quot;x&quot;, &quot;u&quot;, 3),
247                 (&quot;x&quot;, &quot;v&quot;, 5),
248                 (&quot;x&quot;, &quot;y&quot;, 2),
249                 (&quot;y&quot;, &quot;s&quot;, 7),
250                 (&quot;y&quot;, &quot;v&quot;, 6),
251             ]
252         )
253         (P, D) = nx.dijkstra_predecessor_and_distance(XG, &quot;s&quot;)
254         assert P[&quot;v&quot;] == [&quot;u&quot;]
255         assert D[&quot;v&quot;] == 9
256         (P, D) = nx.dijkstra_predecessor_and_distance(XG, &quot;s&quot;, cutoff=8)
257         assert &quot;v&quot; not in D
258     def test_single_source_dijkstra_path_length(self):
259         pl = nx.single_source_dijkstra_path_length
260         assert dict(pl(self.MXG4, 0))[2] == 4
261         spl = pl(self.MXG4, 0, cutoff=2)
262         assert 2 not in spl
263     def test_bidirectional_dijkstra_multigraph(self):
264         G = nx.MultiGraph()
265         G.add_edge(&quot;a&quot;, &quot;b&quot;, weight=10)
266         G.add_edge(&quot;a&quot;, &quot;b&quot;, weight=100)
267         dp = nx.bidirectional_dijkstra(G, &quot;a&quot;, &quot;b&quot;)
268         assert dp == (10, [&quot;a&quot;, &quot;b&quot;])
269     def test_dijkstra_pred_distance_multigraph(self):
270         G = nx.MultiGraph()
271         G.add_edge(&quot;a&quot;, &quot;b&quot;, key=&quot;short&quot;, foo=5, weight=100)
272         G.add_edge(&quot;a&quot;, &quot;b&quot;, key=&quot;long&quot;, bar=1, weight=110)
273         p, d = nx.dijkstra_predecessor_and_distance(G, &quot;a&quot;)
274         assert p == {&quot;a&quot;: [], &quot;b&quot;: [&quot;a&quot;]}
275         assert d == {&quot;a&quot;: 0, &quot;b&quot;: 100}
276     def test_negative_edge_cycle(self):
277         G = nx.cycle_graph(5, create_using=nx.DiGraph())
278         assert not nx.negative_edge_cycle(G)
279         G.add_edge(8, 9, weight=-7)
280         G.add_edge(9, 8, weight=3)
281         graph_size = len(G)
282         assert nx.negative_edge_cycle(G)
283         assert graph_size == len(G)
284         pytest.raises(ValueError, nx.single_source_dijkstra_path_length, G, 8)
285         pytest.raises(ValueError, nx.single_source_dijkstra, G, 8)
286         pytest.raises(ValueError, nx.dijkstra_predecessor_and_distance, G, 8)
287         G.add_edge(9, 10)
288         pytest.raises(ValueError, nx.bidirectional_dijkstra, G, 8, 10)
289     def test_negative_edge_cycle_custom_weight_key(self):
290         d = nx.DiGraph()
291         d.add_edge(&quot;a&quot;, &quot;b&quot;, w=-2)
292         d.add_edge(&quot;b&quot;, &quot;a&quot;, w=-1)
293         assert nx.negative_edge_cycle(d, weight=&quot;w&quot;)
294     def test_weight_function(self):
295         &quot;&quot;&quot;Tests that a callable weight is interpreted as a weight
296         function instead of an edge attribute.
297         &quot;&quot;&quot;
298         G = nx.complete_graph(3)
299         G.adj[0][2][&quot;weight&quot;] = 10
300         G.adj[0][1][&quot;weight&quot;] = 1
301         G.adj[1][2][&quot;weight&quot;] = 1
302         def weight(u, v, d):
303             return 1 / d[&quot;weight&quot;]
304         distance, path = nx.single_source_dijkstra(G, 0, 2)
305         assert distance == 2
306         assert path == [0, 1, 2]
307         distance, path = nx.single_source_dijkstra(G, 0, 2, weight=weight)
308         assert distance == 1 / 10
309         assert path == [0, 2]
310     def test_all_pairs_dijkstra_path(self):
311         cycle = nx.cycle_graph(7)
312         p = dict(nx.all_pairs_dijkstra_path(cycle))
313         assert p[0][3] == [0, 1, 2, 3]
314         cycle[1][2][&quot;weight&quot;] = 10
315         p = dict(nx.all_pairs_dijkstra_path(cycle))
316         assert p[0][3] == [0, 6, 5, 4, 3]
317     def test_all_pairs_dijkstra_path_length(self):
318         cycle = nx.cycle_graph(7)
319         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
320         assert pl[0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
321         cycle[1][2][&quot;weight&quot;] = 10
322         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
323         assert pl[0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
324     def test_all_pairs_dijkstra(self):
325         cycle = nx.cycle_graph(7)
326         out = dict(nx.all_pairs_dijkstra(cycle))
327         assert out[0][0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
328         assert out[0][1][3] == [0, 1, 2, 3]
329         cycle[1][2][&quot;weight&quot;] = 10
330         out = dict(nx.all_pairs_dijkstra(cycle))
331         assert out[0][0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
332         assert out[0][1][3] == [0, 6, 5, 4, 3]
333 class TestDijkstraPathLength:
334     &quot;&quot;&quot;Unit tests for the :func:`networkx.dijkstra_path_length`
335     function.
336     &quot;&quot;&quot;
337     def test_weight_function(self):
338         &quot;&quot;&quot;Tests for computing the length of the shortest path using
339         Dijkstra's algorithm with a user-defined weight function.
340         &quot;&quot;&quot;
341         G = nx.complete_graph(3)
342         G.adj[0][2][&quot;weight&quot;] = 10
343         G.adj[0][1][&quot;weight&quot;] = 1
344         G.adj[1][2][&quot;weight&quot;] = 1
345         def weight(u, v, d):
346             return 1 / d[&quot;weight&quot;]
347         length = nx.dijkstra_path_length(G, 0, 2, weight=weight)
348         assert length == 1 / 10
349 class TestMultiSourceDijkstra:
350     &quot;&quot;&quot;Unit tests for the multi-source dialect of Dijkstra's shortest
351     path algorithms.
352     &quot;&quot;&quot;
353     def test_no_sources(self):
354         with pytest.raises(ValueError):
355             nx.multi_source_dijkstra(nx.Graph(), {})
356     def test_path_no_sources(self):
357         with pytest.raises(ValueError):
358             nx.multi_source_dijkstra_path(nx.Graph(), {})
359     def test_path_length_no_sources(self):
360         with pytest.raises(ValueError):
361             nx.multi_source_dijkstra_path_length(nx.Graph(), {})
362     @pytest.mark.parametrize(
363         &quot;fn&quot;,
364         (
365             nx.multi_source_dijkstra_path,
366             nx.multi_source_dijkstra_path_length,
367             nx.multi_source_dijkstra,
368         ),
369     )
370     def test_absent_source(self, fn):
371         G = nx.path_graph(2)
372         with pytest.raises(nx.NodeNotFound):
373             fn(G, [3], 0)
374         with pytest.raises(nx.NodeNotFound):
375 <A NAME="1"></A>            fn(G, [3], 3)
376     def test_two_sources(self):
377         edges = [<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match10775-0.html#1',2,'match10775-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>(0, 1, 1), (1, 2, 1), (2, 3, 10), (3, 4, 1)]
378         G = nx.Graph()
379         G.add_weighted_edges_from(edges)
380         sources = {0</B></FONT>, 4}
381         distances, paths = nx.multi_source_dijkstra(G, sources)
382         expected_distances = {0: 0, 1: 1, 2: 2, 3: 1, 4: 0}
383         expected_paths = {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [4, 3], 4: [4]}
384         assert distances == expected_distances
385         assert paths == expected_paths
386     def test_simple_paths(self):
387         G = nx.path_graph(4)
388         lengths = nx.multi_source_dijkstra_path_length(G, [0])
389         assert lengths == {n: n for n in G}
390         paths = nx.multi_source_dijkstra_path(G, [0])
391         assert paths == {n: list(range(n + 1)) for n in G}
392 class TestBellmanFordAndGoldbergRadzik(WeightedTestBase):
393     def test_single_node_graph(self):
394         G = nx.DiGraph()
395         G.add_node(0)
396         assert nx.single_source_bellman_ford_path(G, 0) == {0: [0]}
397         assert nx.single_source_bellman_ford_path_length(G, 0) == {0: 0}
398         assert nx.single_source_bellman_ford(G, 0) == ({0: 0}, {0: [0]})
399         assert nx.bellman_ford_predecessor_and_distance(G, 0) == ({0: []}, {0: 0})
400         assert nx.goldberg_radzik(G, 0) == ({0: None}, {0: 0})
401     def test_absent_source_bellman_ford(self):
402         G = nx.path_graph(2)
403         for fn in (
404             nx.bellman_ford_predecessor_and_distance,
405             nx.bellman_ford_path,
406             nx.bellman_ford_path_length,
407             nx.single_source_bellman_ford_path,
408             nx.single_source_bellman_ford_path_length,
409             nx.single_source_bellman_ford,
410         ):
411             pytest.raises(nx.NodeNotFound, fn, G, 3, 0)
412             pytest.raises(nx.NodeNotFound, fn, G, 3, 3)
413     def test_absent_source_goldberg_radzik(self):
414         with pytest.raises(nx.NodeNotFound):
415             G = nx.path_graph(2)
416             nx.goldberg_radzik(G, 3, 0)
417     def test_negative_cycle_heuristic(self):
418         G = nx.DiGraph()
419         G.add_edge(0, 1, weight=-1)
420         G.add_edge(1, 2, weight=-1)
421         G.add_edge(2, 3, weight=-1)
422         G.add_edge(3, 0, weight=3)
423         assert not nx.negative_edge_cycle(G, heuristic=True)
424         G.add_edge(2, 0, weight=1.999)
425         assert nx.negative_edge_cycle(G, heuristic=True)
426         G.edges[2, 0][&quot;weight&quot;] = 2
427         assert not nx.negative_edge_cycle(G, heuristic=True)
428     def test_negative_cycle_consistency(self):
429         import random
430         unif = random.uniform
431         for random_seed in range(2):  # range(20):
432             random.seed(random_seed)
433             for density in [0.1, 0.9]:  # .3, .7, .9]:
434                 for N in [1, 10, 20]:  # range(1, 60 - int(30 * density)):
435                     for max_cost in [1, 90]:  # [1, 10, 40, 90]:
436                         G = nx.binomial_graph(N, density, seed=4, directed=True)
437                         edges = ((u, v, unif(-1, max_cost)) for u, v in G.edges)
438                         G.add_weighted_edges_from(edges)
439                         no_heuristic = nx.negative_edge_cycle(G, heuristic=False)
440                         with_heuristic = nx.negative_edge_cycle(G, heuristic=True)
441                         assert no_heuristic == with_heuristic
442     def test_negative_cycle(self):
443         G = nx.cycle_graph(5, create_using=nx.DiGraph())
444         G.add_edge(1, 2, weight=-7)
445         for i in range(5):
446             pytest.raises(
447                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
448             )
449             pytest.raises(
450                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
451             )
452             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
453             pytest.raises(
454                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
455             )
456             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
457         G = nx.cycle_graph(5)  # undirected Graph
458         G.add_edge(1, 2, weight=-3)
459         for i in range(5):
460             pytest.raises(
461                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
462             )
463             pytest.raises(
464                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
465             )
466             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
467             pytest.raises(
468                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
469             )
470             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
471         G = nx.DiGraph([(1, 1, {&quot;weight&quot;: -1})])
472         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, 1)
473         pytest.raises(
474             nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, 1
475         )
476         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, 1)
477         pytest.raises(
478             nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, 1
479         )
480         pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, 1)
481     def test_find_negative_cycle_longer_cycle(self):
482         G = nx.cycle_graph(5, create_using=nx.DiGraph())
483         nx.add_cycle(G, [3, 5, 6, 7, 8, 9])
484         G.add_edge(1, 2, weight=-30)
485         assert nx.find_negative_cycle(G, 1) == [0, 1, 2, 3, 4, 0]
486         assert nx.find_negative_cycle(G, 7) == [2, 3, 4, 0, 1, 2]
487     def test_find_negative_cycle_no_cycle(self):
488         G = nx.path_graph(5, create_using=nx.DiGraph())
489         pytest.raises(nx.NetworkXError, nx.find_negative_cycle, G, 3)
490     def test_find_negative_cycle_single_edge(self):
491         G = nx.Graph()
492         G.add_edge(0, 1, weight=-1)
493         assert nx.find_negative_cycle(G, 1) == [1, 0, 1]
494     def test_negative_weight(self):
495         G = nx.cycle_graph(5, create_using=nx.DiGraph())
496         G.add_edge(1, 2, weight=-3)
497         assert nx.single_source_bellman_ford_path(G, 0) == {
498             0: [0],
499             1: [0, 1],
500             2: [0, 1, 2],
501             3: [0, 1, 2, 3],
502             4: [0, 1, 2, 3, 4],
503         }
504         assert nx.single_source_bellman_ford_path_length(G, 0) == {
505             0: 0,
506             1: 1,
507             2: -2,
508             3: -1,
509             4: 0,
510         }
511         assert nx.single_source_bellman_ford(G, 0) == (
512             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
513             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3], 4: [0, 1, 2, 3, 4]},
514         )
515         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
516             {0: [], 1: [0], 2: [1], 3: [2], 4: [3]},
517             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
518         )
519         assert nx.goldberg_radzik(G, 0) == (
520             {0: None, 1: 0, 2: 1, 3: 2, 4: 3},
521             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
522         )
523     def test_not_connected(self):
524         G = nx.complete_graph(6)
525         G.add_edge(10, 11)
526         G.add_edge(10, 12)
527         assert nx.single_source_bellman_ford_path(G, 0) == {
528             0: [0],
529             1: [0, 1],
530             2: [0, 2],
531             3: [0, 3],
532             4: [0, 4],
533             5: [0, 5],
534         }
535         assert nx.single_source_bellman_ford_path_length(G, 0) == {
536             0: 0,
537             1: 1,
538             2: 1,
539             3: 1,
540             4: 1,
541             5: 1,
542         }
543         assert nx.single_source_bellman_ford(G, 0) == (
544             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
545             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
546         )
547         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
548             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
549             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
550         )
551         assert nx.goldberg_radzik(G, 0) == (
552             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
553             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
554         )
555         G = nx.complete_graph(6)
556         G.add_edges_from(
557             [
558                 (&quot;A&quot;, &quot;B&quot;, {&quot;load&quot;: 3}),
559                 (&quot;B&quot;, &quot;C&quot;, {&quot;load&quot;: -10}),
560                 (&quot;C&quot;, &quot;A&quot;, {&quot;load&quot;: 2}),
561             ]
562         )
563         assert nx.single_source_bellman_ford_path(G, 0, weight=&quot;load&quot;) == {
564             0: [0],
565             1: [0, 1],
566             2: [0, 2],
567             3: [0, 3],
568             4: [0, 4],
569             5: [0, 5],
570         }
571         assert nx.single_source_bellman_ford_path_length(G, 0, weight=&quot;load&quot;) == {
572             0: 0,
573             1: 1,
574             2: 1,
575             3: 1,
576             4: 1,
577             5: 1,
578         }
579         assert nx.single_source_bellman_ford(G, 0, weight=&quot;load&quot;) == (
580             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
581             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
582         )
583         assert nx.bellman_ford_predecessor_and_distance(G, 0, weight=&quot;load&quot;) == (
584             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
585             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
586         )
587         assert nx.goldberg_radzik(G, 0, weight=&quot;load&quot;) == (
588             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
589             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
590         )
591     def test_multigraph(self):
592         assert nx.bellman_ford_path(self.MXG, &quot;s&quot;, &quot;v&quot;) == [&quot;s&quot;, &quot;x&quot;, &quot;u&quot;, &quot;v&quot;]
593         assert nx.bellman_ford_path_length(self.MXG, &quot;s&quot;, &quot;v&quot;) == 9
594         assert nx.single_source_bellman_ford_path(self.MXG, &quot;s&quot;)[&quot;v&quot;] == [
595             &quot;s&quot;,
596             &quot;x&quot;,
597             &quot;u&quot;,
598             &quot;v&quot;,
599         ]
600         assert nx.single_source_bellman_ford_path_length(self.MXG, &quot;s&quot;)[&quot;v&quot;] == 9
601         D, P = nx.single_source_bellman_ford(self.MXG, &quot;s&quot;, target=&quot;v&quot;)
602         assert D == 9
603         assert P == [&quot;s&quot;, &quot;x&quot;, &quot;u&quot;, &quot;v&quot;]
604         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG, &quot;s&quot;)
605         assert P[&quot;v&quot;] == [&quot;u&quot;]
606         assert D[&quot;v&quot;] == 9
607         P, D = nx.goldberg_radzik(self.MXG, &quot;s&quot;)
608         assert P[&quot;v&quot;] == &quot;u&quot;
609         assert D[&quot;v&quot;] == 9
610         assert nx.bellman_ford_path(self.MXG4, 0, 2) == [0, 1, 2]
611         assert nx.bellman_ford_path_length(self.MXG4, 0, 2) == 4
612         assert nx.single_source_bellman_ford_path(self.MXG4, 0)[2] == [0, 1, 2]
613         assert nx.single_source_bellman_ford_path_length(self.MXG4, 0)[2] == 4
614         D, P = nx.single_source_bellman_ford(self.MXG4, 0, target=2)
615         assert D == 4
616         assert P == [0, 1, 2]
617         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG4, 0)
618         assert P[2] == [1]
619         assert D[2] == 4
620         P, D = nx.goldberg_radzik(self.MXG4, 0)
621         assert P[2] == 1
622         assert D[2] == 4
623     def test_others(self):
624         assert nx.bellman_ford_path(self.XG, &quot;s&quot;, &quot;v&quot;) == [&quot;s&quot;, &quot;x&quot;, &quot;u&quot;, &quot;v&quot;]
625         assert nx.bellman_ford_path_length(self.XG, &quot;s&quot;, &quot;v&quot;) == 9
626         assert nx.single_source_bellman_ford_path(self.XG, &quot;s&quot;)[&quot;v&quot;] == [
627             &quot;s&quot;,
628             &quot;x&quot;,
629             &quot;u&quot;,
630             &quot;v&quot;,
631         ]
632         assert nx.single_source_bellman_ford_path_length(self.XG, &quot;s&quot;)[&quot;v&quot;] == 9
633         D, P = nx.single_source_bellman_ford(self.XG, &quot;s&quot;, target=&quot;v&quot;)
634         assert D == 9
635         assert P == [&quot;s&quot;, &quot;x&quot;, &quot;u&quot;, &quot;v&quot;]
636         (P, D) = nx.bellman_ford_predecessor_and_distance(self.XG, &quot;s&quot;)
637         assert P[&quot;v&quot;] == [&quot;u&quot;]
638         assert D[&quot;v&quot;] == 9
639         (P, D) = nx.goldberg_radzik(self.XG, &quot;s&quot;)
640         assert P[&quot;v&quot;] == &quot;u&quot;
641         assert D[&quot;v&quot;] == 9
642     def test_path_graph(self):
643         G = nx.path_graph(4)
644         assert nx.single_source_bellman_ford_path(G, 0) == {
645             0: [0],
646             1: [0, 1],
647             2: [0, 1, 2],
648             3: [0, 1, 2, 3],
649         }
650         assert nx.single_source_bellman_ford_path_length(G, 0) == {
651             0: 0,
652             1: 1,
653             2: 2,
654             3: 3,
655         }
656         assert nx.single_source_bellman_ford(G, 0) == (
657             {0: 0, 1: 1, 2: 2, 3: 3},
658             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3]},
659         )
660         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
661             {0: [], 1: [0], 2: [1], 3: [2]},
662             {0: 0, 1: 1, 2: 2, 3: 3},
663         )
664         assert nx.goldberg_radzik(G, 0) == (
665             {0: None, 1: 0, 2: 1, 3: 2},
666             {0: 0, 1: 1, 2: 2, 3: 3},
667         )
668         assert nx.single_source_bellman_ford_path(G, 3) == {
669             0: [3, 2, 1, 0],
670             1: [3, 2, 1],
671             2: [3, 2],
672             3: [3],
673         }
674         assert nx.single_source_bellman_ford_path_length(G, 3) == {
675             0: 3,
676             1: 2,
677             2: 1,
678             3: 0,
679         }
680         assert nx.single_source_bellman_ford(G, 3) == (
681             {0: 3, 1: 2, 2: 1, 3: 0},
682             {0: [3, 2, 1, 0], 1: [3, 2, 1], 2: [3, 2], 3: [3]},
683         )
684         assert nx.bellman_ford_predecessor_and_distance(G, 3) == (
685             {0: [1], 1: [2], 2: [3], 3: []},
686             {0: 3, 1: 2, 2: 1, 3: 0},
687         )
688         assert nx.goldberg_radzik(G, 3) == (
689             {0: 1, 1: 2, 2: 3, 3: None},
690             {0: 3, 1: 2, 2: 1, 3: 0},
691         )
692     def test_4_cycle(self):
693         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
694         dist, path = nx.single_source_bellman_ford(G, 0)
695         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
696         assert path[0] == [0]
697         assert path[1] == [0, 1]
698         assert path[2] in [[0, 1, 2], [0, 3, 2]]
699         assert path[3] == [0, 3]
700         pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0)
701         assert pred[0] == []
702         assert pred[1] == [0]
703         assert pred[2] in [[1, 3], [3, 1]]
704         assert pred[3] == [0]
705         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
706         pred, dist = nx.goldberg_radzik(G, 0)
707         assert pred[0] is None
708         assert pred[1] == 0
709         assert pred[2] in [1, 3]
710         assert pred[3] == 0
711         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
712     def test_negative_weight_bf_path(self):
713         G = nx.DiGraph()
714         G.add_nodes_from(&quot;abcd&quot;)
715         G.add_edge(&quot;a&quot;, &quot;d&quot;, weight=0)
716         G.add_edge(&quot;a&quot;, &quot;b&quot;, weight=1)
717         G.add_edge(&quot;b&quot;, &quot;c&quot;, weight=-3)
718         G.add_edge(&quot;c&quot;, &quot;d&quot;, weight=1)
719         assert nx.bellman_ford_path(G, &quot;a&quot;, &quot;d&quot;) == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
720         assert nx.bellman_ford_path_length(G, &quot;a&quot;, &quot;d&quot;) == -1
721     def test_zero_cycle_smoke(self):
722         D = nx.DiGraph()
723         D.add_weighted_edges_from([(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 1, -2)])
724         nx.bellman_ford_path(D, 1, 3)
725         nx.dijkstra_path(D, 1, 3)
726         nx.bidirectional_dijkstra(D, 1, 3)
727 class TestJohnsonAlgorithm(WeightedTestBase):
728     def test_single_node_graph(self):
729         with pytest.raises(nx.NetworkXError):
730             G = nx.DiGraph()
731             G.add_node(0)
732             nx.johnson(G)
733     def test_negative_cycle(self):
734         G = nx.DiGraph()
735         G.add_weighted_edges_from(
736             [
737                 (&quot;0&quot;, &quot;3&quot;, 3),
738                 (&quot;0&quot;, &quot;1&quot;, -5),
739                 (&quot;1&quot;, &quot;0&quot;, -5),
740                 (&quot;0&quot;, &quot;2&quot;, 2),
741                 (&quot;1&quot;, &quot;2&quot;, 4),
742                 (&quot;2&quot;, &quot;3&quot;, 1),
743             ]
744         )
745         pytest.raises(nx.NetworkXUnbounded, nx.johnson, G)
746         G = nx.Graph()
747         G.add_weighted_edges_from(
748             [
749                 (&quot;0&quot;, &quot;3&quot;, 3),
750                 (&quot;0&quot;, &quot;1&quot;, -5),
751                 (&quot;1&quot;, &quot;0&quot;, -5),
752                 (&quot;0&quot;, &quot;2&quot;, 2),
753                 (&quot;1&quot;, &quot;2&quot;, 4),
754                 (&quot;2&quot;, &quot;3&quot;, 1),
755             ]
756         )
757         pytest.raises(nx.NetworkXUnbounded, nx.johnson, G)
758     def test_negative_weights(self):
759         G = nx.DiGraph()
760         G.add_weighted_edges_from(
761             [(&quot;0&quot;, &quot;3&quot;, 3), (&quot;0&quot;, &quot;1&quot;, -5), (&quot;0&quot;, &quot;2&quot;, 2), (&quot;1&quot;, &quot;2&quot;, 4), (&quot;2&quot;, &quot;3&quot;, 1)]
762         )
763         paths = nx.johnson(G)
764         assert paths == {
765             &quot;1&quot;: {&quot;1&quot;: [&quot;1&quot;], &quot;3&quot;: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], &quot;2&quot;: [&quot;1&quot;, &quot;2&quot;]},
766             &quot;0&quot;: {
767                 &quot;1&quot;: [&quot;0&quot;, &quot;1&quot;],
768                 &quot;0&quot;: [&quot;0&quot;],
769                 &quot;3&quot;: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;],
770                 &quot;2&quot;: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;],
771             },
772             &quot;3&quot;: {&quot;3&quot;: [&quot;3&quot;]},
773             &quot;2&quot;: {&quot;3&quot;: [&quot;2&quot;, &quot;3&quot;], &quot;2&quot;: [&quot;2&quot;]},
774         }
775     def test_unweighted_graph(self):
776         with pytest.raises(nx.NetworkXError):
777             G = nx.path_graph(5)
778             nx.johnson(G)
779     def test_graphs(self):
780         validate_path(self.XG, &quot;s&quot;, &quot;v&quot;, 9, nx.johnson(self.XG)[&quot;s&quot;][&quot;v&quot;])
781         validate_path(self.MXG, &quot;s&quot;, &quot;v&quot;, 9, nx.johnson(self.MXG)[&quot;s&quot;][&quot;v&quot;])
782         validate_path(self.XG2, 1, 3, 4, nx.johnson(self.XG2)[1][3])
783         validate_path(self.XG3, 0, 3, 15, nx.johnson(self.XG3)[0][3])
784         validate_path(self.XG4, 0, 2, 4, nx.johnson(self.XG4)[0][2])
785         validate_path(self.MXG4, 0, 2, 4, nx.johnson(self.MXG4)[0][2])
</PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
